{
  "metadata": {
    "timestamp": 1736567994071,
    "page": 128,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "pion/webrtc",
      "stars": 14132,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codacy.yaml",
          "type": "blob",
          "size": 0.142578125,
          "content": "---\n# SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n# SPDX-License-Identifier: MIT\n\nexclude_paths:\n  - examples/examples.json\n"
        },
        {
          "name": ".eslintrc.json",
          "type": "blob",
          "size": 0.029296875,
          "content": "{\n  \"extends\": [\"standard\"]\n}\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.400390625,
          "content": "# SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n# SPDX-License-Identifier: MIT\n\n### JetBrains IDE ###\n#####################\n.idea/\n\n### Emacs Temporary Files ###\n#############################\n*~\n\n### Folders ###\n###############\nbin/\nvendor/\nnode_modules/\n\n### Files ###\n#############\n*.ivf\n*.ogg\ntags\ncover.out\n*.sw[poe]\n*.wasm\nexamples/sfu-ws/cert.pem\nexamples/sfu-ws/key.pem\nwasm_exec.js\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 7.689453125,
          "content": "# SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n# SPDX-License-Identifier: MIT\n\nrun:\n  timeout: 5m\n\nlinters-settings:\n  govet:\n    enable:\n      - shadow\n  misspell:\n    locale: US\n  exhaustive:\n    default-signifies-exhaustive: true\n  gomodguard:\n    blocked:\n      modules:\n        - github.com/pkg/errors:\n            recommendations:\n              - errors\n  forbidigo:\n    forbid:\n      - ^fmt.Print(f|ln)?$\n      - ^log.(Panic|Fatal|Print)(f|ln)?$\n      - ^os.Exit$\n      - ^panic$\n      - ^print(ln)?$\n\nlinters:\n  enable:\n    - asciicheck       # Simple linter to check that your code does not contain non-ASCII identifiers\n    - bidichk          # Checks for dangerous unicode character sequences\n    - bodyclose        # checks whether HTTP response body is closed successfully\n    - contextcheck     # check the function whether use a non-inherited context\n    - decorder         # check declaration order and count of types, constants, variables and functions\n    - dogsled          # Checks assignments with too many blank identifiers (e.g. x, _, _, _, := f())\n    - dupl             # Tool for code clone detection\n    - durationcheck    # check for two durations multiplied together\n    - errcheck         # Errcheck is a program for checking for unchecked errors in go programs. These unchecked errors can be critical bugs in some cases\n    - errchkjson       # Checks types passed to the json encoding functions. Reports unsupported types and optionally reports occations, where the check for the returned error can be omitted.\n    - errname          # Checks that sentinel errors are prefixed with the `Err` and error types are suffixed with the `Error`.\n    - errorlint        # errorlint is a linter for that can be used to find code that will cause problems with the error wrapping scheme introduced in Go 1.13.\n    - exhaustive       # check exhaustiveness of enum switch statements\n    - exportloopref    # checks for pointers to enclosing loop variables\n    - forbidigo        # Forbids identifiers\n    - forcetypeassert  # finds forced type assertions\n    - gci              # Gci control golang package import order and make it always deterministic.\n    - gochecknoglobals # Checks that no globals are present in Go code\n    - gochecknoinits   # Checks that no init functions are present in Go code\n    - gocognit         # Computes and checks the cognitive complexity of functions\n    - goconst          # Finds repeated strings that could be replaced by a constant\n    - gocritic         # The most opinionated Go source code linter\n    - godox            # Tool for detection of FIXME, TODO and other comment keywords\n    - err113           # Golang linter to check the errors handling expressions\n    - gofmt            # Gofmt checks whether code was gofmt-ed. By default this tool runs with -s option to check for code simplification\n    - gofumpt          # Gofumpt checks whether code was gofumpt-ed.\n    - goheader         # Checks is file header matches to pattern\n    - goimports        # Goimports does everything that gofmt does. Additionally it checks unused imports\n    - gomoddirectives  # Manage the use of 'replace', 'retract', and 'excludes' directives in go.mod.\n    - gomodguard       # Allow and block list linter for direct Go module dependencies. This is different from depguard where there are different block types for example version constraints and module recommendations.\n    - goprintffuncname # Checks that printf-like functions are named with `f` at the end\n    - gosec            # Inspects source code for security problems\n    - gosimple         # Linter for Go source code that specializes in simplifying a code\n    - govet            # Vet examines Go source code and reports suspicious constructs, such as Printf calls whose arguments do not align with the format string\n    - grouper          # An analyzer to analyze expression groups.\n    - importas         # Enforces consistent import aliases\n    - ineffassign      # Detects when assignments to existing variables are not used\n    - misspell         # Finds commonly misspelled English words in comments\n    - nilerr           # Finds the code that returns nil even if it checks that the error is not nil.\n    - nilnil           # Checks that there is no simultaneous return of `nil` error and an invalid value.\n    - noctx            # noctx finds sending http request without context.Context\n    - predeclared      # find code that shadows one of Go's predeclared identifiers\n    - revive           # golint replacement, finds style mistakes\n    - staticcheck      # Staticcheck is a go vet on steroids, applying a ton of static analysis checks\n    - stylecheck       # Stylecheck is a replacement for golint\n    - tagliatelle      # Checks the struct tags.\n    - tenv             # tenv is analyzer that detects using os.Setenv instead of t.Setenv since Go1.17\n    - tparallel        # tparallel detects inappropriate usage of t.Parallel() method in your Go test codes\n    - typecheck        # Like the front-end of a Go compiler, parses and type-checks Go code\n    - unconvert        # Remove unnecessary type conversions\n    - unparam          # Reports unused function parameters\n    - unused           # Checks Go code for unused constants, variables, functions and types\n    - wastedassign     # wastedassign finds wasted assignment statements\n    - whitespace       # Tool for detection of leading and trailing whitespace\n  disable:\n    - depguard         # Go linter that checks if package imports are in a list of acceptable packages\n    - containedctx     # containedctx is a linter that detects struct contained context.Context field\n    - cyclop           # checks function and package cyclomatic complexity\n    - funlen           # Tool for detection of long functions\n    - gocyclo          # Computes and checks the cyclomatic complexity of functions\n    - godot            # Check if comments end in a period\n    - gomnd            # An analyzer to detect magic numbers.\n    - ireturn          # Accept Interfaces, Return Concrete Types\n    - lll              # Reports long lines\n    - maintidx         # maintidx measures the maintainability index of each function.\n    - makezero         # Finds slice declarations with non-zero initial length\n    - nakedret         # Finds naked returns in functions greater than a specified function length\n    - nestif           # Reports deeply nested if statements\n    - nlreturn         # nlreturn checks for a new line before return and branch statements to increase code clarity\n    - nolintlint       # Reports ill-formed or insufficient nolint directives\n    - paralleltest     # paralleltest detects missing usage of t.Parallel() method in your Go test\n    - prealloc         # Finds slice declarations that could potentially be preallocated\n    - promlinter       # Check Prometheus metrics naming via promlint\n    - rowserrcheck     # checks whether Err of rows is checked successfully\n    - sqlclosecheck    # Checks that sql.Rows and sql.Stmt are closed.\n    - testpackage      # linter that makes you use a separate _test package\n    - thelper          # thelper detects golang test helpers without t.Helper() call and checks the consistency of test helpers\n    - varnamelen       # checks that the length of a variable's name matches its scope\n    - wrapcheck        # Checks that errors returned from external packages are wrapped\n    - wsl              # Whitespace Linter - Forces you to use empty lines!\n\nissues:\n  exclude-use-default: false\n  exclude-dirs-use-default: false\n  exclude-rules:\n    # Allow complex tests and examples, better to be self contained\n    - path: (examples|main\\.go|_test\\.go)\n      linters:\n        - forbidigo\n        - gocognit\n\n    # Allow forbidden identifiers in CLI commands\n    - path: cmd\n      linters:\n        - forbidigo\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.1181640625,
          "content": "# SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n# SPDX-License-Identifier: MIT\n\nbuilds:\n- skip: true\n"
        },
        {
          "name": ".reuse",
          "type": "tree",
          "content": null
        },
        {
          "name": "DESIGN.md",
          "type": "blob",
          "size": 2.50390625,
          "content": "<h1 align=\"center\">\n  Design\n</h1>\nWebRTC is a powerful, but complicated technology you can build amazing things with, it comes with a steep learning curve though.\nUsing WebRTC in the browser is easy, but outside the browser is more of a challenge. There are multiple libraries, and they all have\nvarying levels of quality. Most are also difficult to build, and depend on libraries that aren't available in repos or portable.\n\nPion WebRTC aims to solve all that! Built in native Go you should be able to send and receive media and text from anywhere with minimal headache.\nThese are the design principals that drive Pion WebRTC and hopefully convince you it is worth a try.\n\n### Portable\nPion WebRTC is written in Go and extremely portable. Anywhere Golang runs, Pion WebRTC should work as well! Instead of dealing with complicated\ncross-compiling of multiple libraries, you now can run anywhere with one `go build`\n\n### Flexible\nWhen possible we leave all decisions to the user. When choice is possible (like what logging library is used) we defer to the developer.\n\n### Simple API\nIf you know how to use WebRTC in your browser, you know how to use Pion WebRTC.\nWe try our best just to duplicate the Javascript API, so your code can look the same everywhere.\n\nIf this is your first time using WebRTC, don't worry! We have multiple [examples](https://github.com/pion/webrtc/tree/master/examples) and [GoDoc](https://pkg.go.dev/github.com/pion/webrtc/v4)\n\n### Bring your own media\nPion WebRTC doesn't make any assumptions about where your audio, video or text come from. You can use FFmpeg, GStreamer, MLT or just serve a video file.\nThis library only serves to transport, not create media.\n\n### Safe\nGolang provides a great foundation to build safe network services.\nEspecially when running a networked service that is highly concurrent bugs can be devastating.\n\n### Readable\nIf code comes from an RFC we try to make sure everything is commented with a link to the spec.\nThis makes learning and debugging easier, this WebRTC library was written to also serve as a guide for others.\n\n### Tested\nEvery commit is tested via travis-ci Go provides fantastic facilities for testing, and more will be added as time goes on.\n\n### Shared libraries\nEvery Pion project is built using shared libraries, allowing others to review and reuse our libraries.\n\n### Community\nThe most important part of Pion is the community. This projects only exist because of individual contributions. We aim to be radically open and do everything we can to support those that make Pion possible.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0673828125,
          "content": "MIT License\n\nCopyright (c) 2023 The Pion community <https://pion.ly>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "LICENSES",
          "type": "tree",
          "content": null
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.353515625,
          "content": "<h1 align=\"center\">\n  <a href=\"https://pion.ly\"><img src=\"./.github/pion-gopher-webrtc.png\" alt=\"Pion WebRTC\" height=\"250px\"></a>\n  <br>\n  Pion WebRTC\n  <br>\n</h1>\n<h4 align=\"center\">A pure Go implementation of the WebRTC API</h4>\n<p align=\"center\">\n  <a href=\"https://pion.ly\"><img src=\"https://img.shields.io/badge/pion-webrtc-gray.svg?longCache=true&colorB=brightgreen\" alt=\"Pion WebRTC\"></a>\n  <a href=\"https://sourcegraph.com/github.com/pion/webrtc?badge\"><img src=\"https://sourcegraph.com/github.com/pion/webrtc/-/badge.svg\" alt=\"Sourcegraph Widget\"></a>\n  <a href=\"https://pion.ly/slack\"><img src=\"https://img.shields.io/badge/join-us%20on%20slack-gray.svg?longCache=true&logo=slack&colorB=brightgreen\" alt=\"Slack Widget\"></a>\n  <a href=\"https://twitter.com/_pion?ref_src=twsrc%5Etfw\"><img src=\"https://img.shields.io/twitter/url.svg?label=Follow%20%40_pion&style=social&url=https%3A%2F%2Ftwitter.com%2F_pion\" alt=\"Twitter Widget\"></a>\n  <a href=\"https://github.com/pion/awesome-pion\" alt=\"Awesome Pion\"><img src=\"https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg\"></a>\n  <br>\n  <img alt=\"GitHub Workflow Status\" src=\"https://img.shields.io/github/actions/workflow/status/pion/webrtc/test.yaml\">\n  <a href=\"https://pkg.go.dev/github.com/pion/webrtc/v4\"><img src=\"https://pkg.go.dev/badge/github.com/pion/webrtc/v4.svg\" alt=\"Go Reference\"></a>\n  <a href=\"https://codecov.io/gh/pion/webrtc\"><img src=\"https://codecov.io/gh/pion/webrtc/branch/master/graph/badge.svg\" alt=\"Coverage Status\"></a>\n  <a href=\"https://goreportcard.com/report/github.com/pion/webrtc/v4\"><img src=\"https://goreportcard.com/badge/github.com/pion/webrtc/v4\" alt=\"Go Report Card\"></a>\n  <a href=\"LICENSE\"><img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"License: MIT\"></a>\n</p>\n<br>\n\n### New Release\n\nPion WebRTC v4.0.0 has been released! See the [release notes](https://github.com/pion/webrtc/wiki/Release-WebRTC@v4.0.0) to learn about new features and breaking changes.\n\nIf you aren't able to upgrade yet check the [tags](https://github.com/pion/webrtc/tags) for the latest `v3` release.\n\nWe would love your feedback! Please create GitHub issues or join [the Slack channel](https://pion.ly/slack) to follow development and speak with the maintainers.\n\n-----\n\n### Usage\n[Go Modules](https://blog.golang.org/using-go-modules) are mandatory for using Pion WebRTC. So make sure you set `export GO111MODULE=on`, and explicitly specify `/v4` (or an earlier version) when importing.\n\n\n**[example applications](examples/README.md)** contains code samples of common things people build with Pion WebRTC.\n\n**[example-webrtc-applications](https://github.com/pion/example-webrtc-applications)** contains more full featured examples that use 3rd party libraries.\n\n**[awesome-pion](https://github.com/pion/awesome-pion)** contains projects that have used Pion, and serve as real world examples of usage.\n\n**[GoDoc](https://pkg.go.dev/github.com/pion/webrtc/v4)** is an auto generated API reference. All our Public APIs are commented.\n\n**[FAQ](https://github.com/pion/webrtc/wiki/FAQ)** has answers to common questions. If you have a question not covered please ask in [Slack](https://pion.ly/slack) we are always looking to expand it.\n\nNow go build something awesome! Here are some **ideas** to get your creative juices flowing:\n* Send a video file to multiple browser in real time for perfectly synchronized movie watching.\n* Send a webcam on an embedded device to your browser with no additional server required!\n* Securely send data between two servers, without using pub/sub.\n* Record your webcam and do special effects server side.\n* Build a conferencing application that processes audio/video and make decisions off of it.\n* Remotely control a robots and stream its cameras in realtime.\n\n### Need Help?\nCheck out [WebRTC for the Curious](https://webrtcforthecurious.com). A book about WebRTC in depth, not just about the APIs.\nLearn the full details of ICE, SCTP, DTLS, SRTP, and how they work together to make up the WebRTC stack. This is also a great\nresource if you are trying to debug. Learn the tools of the trade and how to approach WebRTC issues. This book is vendor\nagnostic and will not have any Pion specific information.\n\nPion has an active community on [Slack](https://pion.ly/slack). Please ask for help about anything, questions don't have to be Pion specific!\nCome share your interesting project you are working on. We are here to support you.\n\nOne of the maintainers of Pion [Sean-Der](https://github.com/sean-der) is available to help. Schedule at [siobud.com/meeting](https://siobud.com/meeting)\nHe is available to talk about Pion or general WebRTC questions, feel free to reach out about anything!\n\n### Features\n#### PeerConnection API\n* Go implementation of [webrtc-pc](https://w3c.github.io/webrtc-pc/) and [webrtc-stats](https://www.w3.org/TR/webrtc-stats/)\n* DataChannels\n* Send/Receive audio and video\n* Renegotiation\n* Plan-B and Unified Plan\n* [SettingEngine](https://pkg.go.dev/github.com/pion/webrtc/v4#SettingEngine) for Pion specific extensions\n\n\n#### Connectivity\n* Full ICE Agent\n* ICE Restart\n* Trickle ICE\n* STUN\n* TURN (UDP, TCP, DTLS and TLS)\n* mDNS candidates\n\n#### DataChannels\n* Ordered/Unordered\n* Lossy/Lossless\n\n#### Media\n* API with direct RTP/RTCP access\n* Opus, PCM, H264, VP8 and VP9 packetizer\n* API also allows developer to pass their own packetizer\n* IVF, Ogg, H264 and Matroska provided for easy sending and saving\n* [getUserMedia](https://github.com/pion/mediadevices) implementation (Requires Cgo)\n* Easy integration with x264, libvpx, GStreamer and ffmpeg.\n* [Simulcast](https://github.com/pion/webrtc/tree/master/examples/simulcast)\n* [SVC](https://github.com/pion/rtp/blob/master/codecs/vp9_packet.go#L138)\n* [NACK](https://github.com/pion/interceptor/pull/4)\n* [Sender/Receiver Reports](https://github.com/pion/interceptor/tree/master/pkg/report)\n* [Transport Wide Congestion Control Feedback](https://github.com/pion/interceptor/tree/master/pkg/twcc)\n* [Bandwidth Estimation](https://github.com/pion/webrtc/tree/master/examples/bandwidth-estimation-from-disk)\n\n#### Security\n* TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 and TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA for DTLS v1.2\n* SRTP_AEAD_AES_256_GCM and SRTP_AES128_CM_HMAC_SHA1_80 for SRTP\n* Hardware acceleration available for GCM suites\n\n#### Pure Go\n* No Cgo usage\n* Wide platform support\n  * Windows, macOS, Linux, FreeBSD\n  * iOS, Android\n  * [WASM](https://github.com/pion/webrtc/wiki/WebAssembly-Development-and-Testing) see [examples](examples/README.md#webassembly)\n  *  386, amd64, arm, mips, ppc64\n* Easy to build *Numbers generated on Intel(R) Core(TM) i5-2520M CPU @ 2.50GHz*\n  * **Time to build examples/play-from-disk** - 0.66s user 0.20s system 306% cpu 0.279 total\n  * **Time to run entire test suite** - 25.60s user 9.40s system 45% cpu 1:16.69 total\n* Tools to measure performance [provided](https://github.com/pion/rtsp-bench)\n\n### Roadmap\nThe library is in active development, please refer to the [roadmap](https://github.com/pion/webrtc/issues/9) to track our major milestones.\nWe also maintain a list of [Big Ideas](https://github.com/pion/webrtc/wiki/Big-Ideas) these are things we want to build but don't have a clear plan or the resources yet.\nIf you are looking to get involved this is a great place to get started! We would also love to hear your ideas! Even if you can't implement it yourself, it could inspire others.\n\n### Sponsoring\nWork on Pion's congestion control and bandwidth estimation was funded through the [User-Operated Internet](https://nlnet.nl/useroperated/) fund, a fund established by [NLnet](https://nlnet.nl/) made possible by financial support from the [PKT Community](https://pkt.cash/)/[The Network Steward](https://pkt.cash/network-steward) and stichting [Technology Commons Trust](https://technologycommons.org/).\n\n### Community\nPion has an active community on the [Slack](https://pion.ly/slack).\n\nFollow the [Pion Twitter](https://twitter.com/_pion) for project updates and important WebRTC news.\n\nWe are always looking to support **your projects**. Please reach out if you have something to build!\nIf you need commercial support or don't want to use public methods you can contact us at [team@pion.ly](mailto:team@pion.ly)\n\n### Contributing\nCheck out the [contributing wiki](https://github.com/pion/webrtc/wiki/Contributing) to join the group of amazing people making this project possible\n\n### License\nMIT License - see [LICENSE](LICENSE) for full text\n"
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 2.638671875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/logging\"\n)\n\n// API allows configuration of a PeerConnection\n// with APIs that are available in the standard. This\n// lets you set custom behavior via the SettingEngine, configure\n// codecs via the MediaEngine and define custom media behaviors via\n// Interceptors.\ntype API struct {\n\tsettingEngine       *SettingEngine\n\tmediaEngine         *MediaEngine\n\tinterceptorRegistry *interceptor.Registry\n\n\tinterceptor interceptor.Interceptor // Generated per PeerConnection\n}\n\n// NewAPI Creates a new API object for keeping semi-global settings to WebRTC objects\n//\n// It uses the default Codecs and Interceptors unless you customize them\n// using WithMediaEngine and WithInterceptorRegistry respectively.\nfunc NewAPI(options ...func(*API)) *API {\n\ta := &API{\n\t\tinterceptor:   &interceptor.NoOp{},\n\t\tsettingEngine: &SettingEngine{},\n\t}\n\n\tfor _, o := range options {\n\t\to(a)\n\t}\n\n\tif a.settingEngine.LoggerFactory == nil {\n\t\ta.settingEngine.LoggerFactory = logging.NewDefaultLoggerFactory()\n\t}\n\n\tlogger := a.settingEngine.LoggerFactory.NewLogger(\"api\")\n\n\tif a.mediaEngine == nil {\n\t\ta.mediaEngine = &MediaEngine{}\n\t\terr := a.mediaEngine.RegisterDefaultCodecs()\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed to register default codecs %s\", err)\n\t\t}\n\t}\n\n\tif a.interceptorRegistry == nil {\n\t\ta.interceptorRegistry = &interceptor.Registry{}\n\t\terr := RegisterDefaultInterceptors(a.mediaEngine, a.interceptorRegistry)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Failed to register default interceptors %s\", err)\n\t\t}\n\t}\n\n\treturn a\n}\n\n// WithMediaEngine allows providing a MediaEngine to the API.\n// Settings can be changed after passing the engine to an API.\n// When a PeerConnection is created the MediaEngine is copied\n// and no more changes can be made.\nfunc WithMediaEngine(m *MediaEngine) func(a *API) {\n\treturn func(a *API) {\n\t\ta.mediaEngine = m\n\t\tif a.mediaEngine == nil {\n\t\t\ta.mediaEngine = &MediaEngine{}\n\t\t}\n\t}\n}\n\n// WithSettingEngine allows providing a SettingEngine to the API.\n// Settings should not be changed after passing the engine to an API.\nfunc WithSettingEngine(s SettingEngine) func(a *API) {\n\treturn func(a *API) {\n\t\ta.settingEngine = &s\n\t}\n}\n\n// WithInterceptorRegistry allows providing Interceptors to the API.\n// Settings should not be changed after passing the registry to an API.\nfunc WithInterceptorRegistry(ir *interceptor.Registry) func(a *API) {\n\treturn func(a *API) {\n\t\ta.interceptorRegistry = ir\n\t\tif a.interceptorRegistry == nil {\n\t\t\ta.interceptorRegistry = &interceptor.Registry{}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "api_js.go",
          "type": "blob",
          "size": 0.7626953125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\n// API bundles the global functions of the WebRTC and ORTC API.\ntype API struct {\n\tsettingEngine *SettingEngine\n}\n\n// NewAPI Creates a new API object for keeping semi-global settings to WebRTC objects\nfunc NewAPI(options ...func(*API)) *API {\n\ta := &API{}\n\n\tfor _, o := range options {\n\t\to(a)\n\t}\n\n\tif a.settingEngine == nil {\n\t\ta.settingEngine = &SettingEngine{}\n\t}\n\n\treturn a\n}\n\n// WithSettingEngine allows providing a SettingEngine to the API.\n// Settings should not be changed after passing the engine to an API.\nfunc WithSettingEngine(s SettingEngine) func(a *API) {\n\treturn func(a *API) {\n\t\ta.settingEngine = &s\n\t}\n}\n"
        },
        {
          "name": "api_test.go",
          "type": "blob",
          "size": 1.076171875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewAPI(t *testing.T) {\n\tapi := NewAPI()\n\n\tif api.settingEngine == nil {\n\t\tt.Error(\"Failed to init settings engine\")\n\t}\n\n\tif api.mediaEngine == nil {\n\t\tt.Error(\"Failed to init media engine\")\n\t}\n\n\tif api.interceptorRegistry == nil {\n\t\tt.Error(\"Failed to init interceptor registry\")\n\t}\n}\n\nfunc TestNewAPI_Options(t *testing.T) {\n\ts := SettingEngine{}\n\ts.DetachDataChannels()\n\n\tapi := NewAPI(\n\t\tWithSettingEngine(s),\n\t)\n\n\tif !api.settingEngine.detach.DataChannels {\n\t\tt.Error(\"Failed to set settings engine\")\n\t}\n\n\tif len(api.mediaEngine.audioCodecs) == 0 || len(api.mediaEngine.videoCodecs) == 0 {\n\t\tt.Error(\"Failed to set media engine\")\n\t}\n}\n\nfunc TestNewAPI_OptionsDefaultize(t *testing.T) {\n\tapi := NewAPI(\n\t\tWithMediaEngine(nil),\n\t\tWithInterceptorRegistry(nil),\n\t)\n\n\tassert.NotNil(t, api.settingEngine)\n\tassert.NotNil(t, api.mediaEngine)\n\tassert.NotNil(t, api.interceptorRegistry)\n}\n"
        },
        {
          "name": "atomicbool.go",
          "type": "blob",
          "size": 0.5,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport \"sync/atomic\"\n\ntype atomicBool struct {\n\tval int32\n}\n\nfunc (b *atomicBool) set(value bool) { // nolint: unparam\n\tvar i int32\n\tif value {\n\t\ti = 1\n\t}\n\n\tatomic.StoreInt32(&(b.val), i)\n}\n\nfunc (b *atomicBool) get() bool {\n\treturn atomic.LoadInt32(&(b.val)) != 0\n}\n\nfunc (b *atomicBool) swap(value bool) bool {\n\tvar i int32\n\tif value {\n\t\ti = 1\n\t}\n\treturn atomic.SwapInt32(&(b.val), i) != 0\n}\n"
        },
        {
          "name": "bundlepolicy.go",
          "type": "blob",
          "size": 2.263671875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n)\n\n// BundlePolicy affects which media tracks are negotiated if the remote\n// endpoint is not bundle-aware, and what ICE candidates are gathered. If the\n// remote endpoint is bundle-aware, all media tracks and data channels are\n// bundled onto the same transport.\ntype BundlePolicy int\n\nconst (\n\t// BundlePolicyUnknown is the enum's zero-value\n\tBundlePolicyUnknown BundlePolicy = iota\n\n\t// BundlePolicyBalanced indicates to gather ICE candidates for each\n\t// media type in use (audio, video, and data). If the remote endpoint is\n\t// not bundle-aware, negotiate only one audio and video track on separate\n\t// transports.\n\tBundlePolicyBalanced\n\n\t// BundlePolicyMaxCompat indicates to gather ICE candidates for each\n\t// track. If the remote endpoint is not bundle-aware, negotiate all media\n\t// tracks on separate transports.\n\tBundlePolicyMaxCompat\n\n\t// BundlePolicyMaxBundle indicates to gather ICE candidates for only\n\t// one track. If the remote endpoint is not bundle-aware, negotiate only\n\t// one media track.\n\tBundlePolicyMaxBundle\n)\n\n// This is done this way because of a linter.\nconst (\n\tbundlePolicyBalancedStr  = \"balanced\"\n\tbundlePolicyMaxCompatStr = \"max-compat\"\n\tbundlePolicyMaxBundleStr = \"max-bundle\"\n)\n\nfunc newBundlePolicy(raw string) BundlePolicy {\n\tswitch raw {\n\tcase bundlePolicyBalancedStr:\n\t\treturn BundlePolicyBalanced\n\tcase bundlePolicyMaxCompatStr:\n\t\treturn BundlePolicyMaxCompat\n\tcase bundlePolicyMaxBundleStr:\n\t\treturn BundlePolicyMaxBundle\n\tdefault:\n\t\treturn BundlePolicyUnknown\n\t}\n}\n\nfunc (t BundlePolicy) String() string {\n\tswitch t {\n\tcase BundlePolicyBalanced:\n\t\treturn bundlePolicyBalancedStr\n\tcase BundlePolicyMaxCompat:\n\t\treturn bundlePolicyMaxCompatStr\n\tcase BundlePolicyMaxBundle:\n\t\treturn bundlePolicyMaxBundleStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// UnmarshalJSON parses the JSON-encoded data and stores the result\nfunc (t *BundlePolicy) UnmarshalJSON(b []byte) error {\n\tvar val string\n\tif err := json.Unmarshal(b, &val); err != nil {\n\t\treturn err\n\t}\n\n\t*t = newBundlePolicy(val)\n\treturn nil\n}\n\n// MarshalJSON returns the JSON encoding\nfunc (t BundlePolicy) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(t.String())\n}\n"
        },
        {
          "name": "bundlepolicy_test.go",
          "type": "blob",
          "size": 1.0810546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewBundlePolicy(t *testing.T) {\n\ttestCases := []struct {\n\t\tpolicyString   string\n\t\texpectedPolicy BundlePolicy\n\t}{\n\t\t{ErrUnknownType.Error(), BundlePolicyUnknown},\n\t\t{\"balanced\", BundlePolicyBalanced},\n\t\t{\"max-compat\", BundlePolicyMaxCompat},\n\t\t{\"max-bundle\", BundlePolicyMaxBundle},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedPolicy,\n\t\t\tnewBundlePolicy(testCase.policyString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestBundlePolicy_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tpolicy         BundlePolicy\n\t\texpectedString string\n\t}{\n\t\t{BundlePolicyUnknown, ErrUnknownType.Error()},\n\t\t{BundlePolicyBalanced, \"balanced\"},\n\t\t{BundlePolicyMaxCompat, \"max-compat\"},\n\t\t{BundlePolicyMaxBundle, \"max-bundle\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.policy.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "certificate.go",
          "type": "blob",
          "size": 7.185546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/base64\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pion/dtls/v3/pkg/crypto/fingerprint\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\n// Certificate represents a x509Cert used to authenticate WebRTC communications.\ntype Certificate struct {\n\tprivateKey crypto.PrivateKey\n\tx509Cert   *x509.Certificate\n\tstatsID    string\n}\n\n// NewCertificate generates a new x509 compliant Certificate to be used\n// by DTLS for encrypting data sent over the wire. This method differs from\n// GenerateCertificate by allowing to specify a template x509.Certificate to\n// be used in order to define certificate parameters.\nfunc NewCertificate(key crypto.PrivateKey, tpl x509.Certificate) (*Certificate, error) {\n\tvar err error\n\tvar certDER []byte\n\tswitch sk := key.(type) {\n\tcase *rsa.PrivateKey:\n\t\tpk := sk.Public()\n\t\ttpl.SignatureAlgorithm = x509.SHA256WithRSA\n\t\tcertDER, err = x509.CreateCertificate(rand.Reader, &tpl, &tpl, pk, sk)\n\t\tif err != nil {\n\t\t\treturn nil, &rtcerr.UnknownError{Err: err}\n\t\t}\n\tcase *ecdsa.PrivateKey:\n\t\tpk := sk.Public()\n\t\ttpl.SignatureAlgorithm = x509.ECDSAWithSHA256\n\t\tcertDER, err = x509.CreateCertificate(rand.Reader, &tpl, &tpl, pk, sk)\n\t\tif err != nil {\n\t\t\treturn nil, &rtcerr.UnknownError{Err: err}\n\t\t}\n\tdefault:\n\t\treturn nil, &rtcerr.NotSupportedError{Err: ErrPrivateKeyType}\n\t}\n\n\tcert, err := x509.ParseCertificate(certDER)\n\tif err != nil {\n\t\treturn nil, &rtcerr.UnknownError{Err: err}\n\t}\n\n\treturn &Certificate{privateKey: key, x509Cert: cert, statsID: fmt.Sprintf(\"certificate-%d\", time.Now().UnixNano())}, nil\n}\n\n// Equals determines if two certificates are identical by comparing both the\n// secretKeys and x509Certificates.\nfunc (c Certificate) Equals(o Certificate) bool {\n\tswitch cSK := c.privateKey.(type) {\n\tcase *rsa.PrivateKey:\n\t\tif oSK, ok := o.privateKey.(*rsa.PrivateKey); ok {\n\t\t\tif cSK.N.Cmp(oSK.N) != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn c.x509Cert.Equal(o.x509Cert)\n\t\t}\n\t\treturn false\n\tcase *ecdsa.PrivateKey:\n\t\tif oSK, ok := o.privateKey.(*ecdsa.PrivateKey); ok {\n\t\t\tif cSK.X.Cmp(oSK.X) != 0 || cSK.Y.Cmp(oSK.Y) != 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn c.x509Cert.Equal(o.x509Cert)\n\t\t}\n\t\treturn false\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Expires returns the timestamp after which this certificate is no longer valid.\nfunc (c Certificate) Expires() time.Time {\n\tif c.x509Cert == nil {\n\t\treturn time.Time{}\n\t}\n\treturn c.x509Cert.NotAfter\n}\n\n// GetFingerprints returns the list of certificate fingerprints, one of which\n// is computed with the digest algorithm used in the certificate signature.\nfunc (c Certificate) GetFingerprints() ([]DTLSFingerprint, error) {\n\tfingerprintAlgorithms := []crypto.Hash{crypto.SHA256}\n\tres := make([]DTLSFingerprint, len(fingerprintAlgorithms))\n\n\ti := 0\n\tfor _, algo := range fingerprintAlgorithms {\n\t\tname, err := fingerprint.StringFromHash(algo)\n\t\tif err != nil {\n\t\t\t// nolint\n\t\t\treturn nil, fmt.Errorf(\"%w: %v\", ErrFailedToGenerateCertificateFingerprint, err)\n\t\t}\n\t\tvalue, err := fingerprint.Fingerprint(c.x509Cert, algo)\n\t\tif err != nil {\n\t\t\t// nolint\n\t\t\treturn nil, fmt.Errorf(\"%w: %v\", ErrFailedToGenerateCertificateFingerprint, err)\n\t\t}\n\t\tres[i] = DTLSFingerprint{\n\t\t\tAlgorithm: name,\n\t\t\tValue:     value,\n\t\t}\n\t}\n\n\treturn res[:i+1], nil\n}\n\n// GenerateCertificate causes the creation of an X.509 certificate and\n// corresponding private key.\nfunc GenerateCertificate(secretKey crypto.PrivateKey) (*Certificate, error) {\n\t// Max random value, a 130-bits integer, i.e 2^130 - 1\n\tmaxBigInt := new(big.Int)\n\t/* #nosec */\n\tmaxBigInt.Exp(big.NewInt(2), big.NewInt(130), nil).Sub(maxBigInt, big.NewInt(1))\n\t/* #nosec */\n\tserialNumber, err := rand.Int(rand.Reader, maxBigInt)\n\tif err != nil {\n\t\treturn nil, &rtcerr.UnknownError{Err: err}\n\t}\n\n\treturn NewCertificate(secretKey, x509.Certificate{\n\t\tIssuer:       pkix.Name{CommonName: generatedCertificateOrigin},\n\t\tNotBefore:    time.Now().AddDate(0, 0, -1),\n\t\tNotAfter:     time.Now().AddDate(0, 1, -1),\n\t\tSerialNumber: serialNumber,\n\t\tVersion:      2,\n\t\tSubject:      pkix.Name{CommonName: generatedCertificateOrigin},\n\t})\n}\n\n// CertificateFromX509 creates a new WebRTC Certificate from a given PrivateKey and Certificate\n//\n// This can be used if you want to share a certificate across multiple PeerConnections\nfunc CertificateFromX509(privateKey crypto.PrivateKey, certificate *x509.Certificate) Certificate {\n\treturn Certificate{privateKey, certificate, fmt.Sprintf(\"certificate-%d\", time.Now().UnixNano())}\n}\n\nfunc (c Certificate) collectStats(report *statsReportCollector) error {\n\treport.Collecting()\n\n\tfingerPrintAlgo, err := c.GetFingerprints()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbase64Certificate := base64.RawURLEncoding.EncodeToString(c.x509Cert.Raw)\n\n\tstats := CertificateStats{\n\t\tTimestamp:            statsTimestampFrom(time.Now()),\n\t\tType:                 StatsTypeCertificate,\n\t\tID:                   c.statsID,\n\t\tFingerprint:          fingerPrintAlgo[0].Value,\n\t\tFingerprintAlgorithm: fingerPrintAlgo[0].Algorithm,\n\t\tBase64Certificate:    base64Certificate,\n\t\tIssuerCertificateID:  c.x509Cert.Issuer.String(),\n\t}\n\n\treport.Collect(stats.ID, stats)\n\treturn nil\n}\n\n// CertificateFromPEM creates a fresh certificate based on a string containing\n// pem blocks fort the private key and x509 certificate\nfunc CertificateFromPEM(pems string) (*Certificate, error) {\n\t// decode & parse the certificate\n\tblock, more := pem.Decode([]byte(pems))\n\tif block == nil || block.Type != \"CERTIFICATE\" {\n\t\treturn nil, errCertificatePEMFormatError\n\t}\n\tcertBytes := make([]byte, base64.StdEncoding.DecodedLen(len(block.Bytes)))\n\tn, err := base64.StdEncoding.Decode(certBytes, block.Bytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to decode ceritifcate: %w\", err)\n\t}\n\tcert, err := x509.ParseCertificate(certBytes[:n])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed parsing ceritifcate: %w\", err)\n\t}\n\t// decode & parse the private key\n\tblock, _ = pem.Decode(more)\n\tif block == nil || block.Type != \"PRIVATE KEY\" {\n\t\treturn nil, errCertificatePEMFormatError\n\t}\n\tprivateKey, err := x509.ParsePKCS8PrivateKey(block.Bytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to parse private key: %w\", err)\n\t}\n\tx := CertificateFromX509(privateKey, cert)\n\treturn &x, nil\n}\n\n// PEM returns the certificate encoded as two pem block: once for the X509\n// certificate and the other for the private key\nfunc (c Certificate) PEM() (string, error) {\n\t// First write the X509 certificate\n\tvar o strings.Builder\n\txcertBytes := make(\n\t\t[]byte, base64.StdEncoding.EncodedLen(len(c.x509Cert.Raw)))\n\tbase64.StdEncoding.Encode(xcertBytes, c.x509Cert.Raw)\n\terr := pem.Encode(&o, &pem.Block{Type: \"CERTIFICATE\", Bytes: xcertBytes})\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to pem encode the X certificate: %w\", err)\n\t}\n\t// Next write the private key\n\tprivBytes, err := x509.MarshalPKCS8PrivateKey(c.privateKey)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to marshal private key: %w\", err)\n\t}\n\terr = pem.Encode(&o, &pem.Block{Type: \"PRIVATE KEY\", Bytes: privBytes})\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"failed to encode private key: %w\", err)\n\t}\n\treturn o.String(), nil\n}\n"
        },
        {
          "name": "certificate_test.go",
          "type": "blob",
          "size": 3.0126953125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGenerateCertificateRSA(t *testing.T) {\n\tsk, err := rsa.GenerateKey(rand.Reader, 2048)\n\tassert.Nil(t, err)\n\n\tskPEM := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"RSA PRIVATE KEY\",\n\t\tBytes: x509.MarshalPKCS1PrivateKey(sk),\n\t})\n\n\tcert, err := GenerateCertificate(sk)\n\tassert.Nil(t, err)\n\n\tcertPEM := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: cert.x509Cert.Raw,\n\t})\n\n\t_, err = tls.X509KeyPair(certPEM, skPEM)\n\tassert.Nil(t, err)\n}\n\nfunc TestGenerateCertificateECDSA(t *testing.T) {\n\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\n\tskDER, err := x509.MarshalECPrivateKey(sk)\n\tassert.Nil(t, err)\n\n\tskPEM := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"EC PRIVATE KEY\",\n\t\tBytes: skDER,\n\t})\n\n\tcert, err := GenerateCertificate(sk)\n\tassert.Nil(t, err)\n\n\tcertPEM := pem.EncodeToMemory(&pem.Block{\n\t\tType:  \"CERTIFICATE\",\n\t\tBytes: cert.x509Cert.Raw,\n\t})\n\n\t_, err = tls.X509KeyPair(certPEM, skPEM)\n\tassert.Nil(t, err)\n}\n\nfunc TestGenerateCertificateEqual(t *testing.T) {\n\tsk1, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\n\tsk3, err := rsa.GenerateKey(rand.Reader, 2048)\n\tassert.NoError(t, err)\n\n\tcert1, err := GenerateCertificate(sk1)\n\tassert.Nil(t, err)\n\n\tsk2, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\n\tcert2, err := GenerateCertificate(sk2)\n\tassert.Nil(t, err)\n\n\tcert3, err := GenerateCertificate(sk3)\n\tassert.NoError(t, err)\n\n\tassert.True(t, cert1.Equals(*cert1))\n\tassert.False(t, cert1.Equals(*cert2))\n\tassert.True(t, cert3.Equals(*cert3))\n}\n\nfunc TestGenerateCertificateExpires(t *testing.T) {\n\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\n\tcert, err := GenerateCertificate(sk)\n\tassert.Nil(t, err)\n\n\tnow := time.Now()\n\tassert.False(t, cert.Expires().IsZero() || now.After(cert.Expires()))\n\n\tx509Cert := CertificateFromX509(sk, &x509.Certificate{})\n\tassert.NotNil(t, x509Cert)\n\tassert.Contains(t, x509Cert.statsID, \"certificate\")\n}\n\nfunc TestBadCertificate(t *testing.T) {\n\tvar nokey interface{}\n\tbadcert, err := NewCertificate(nokey, x509.Certificate{})\n\tassert.Nil(t, badcert)\n\tassert.Error(t, err)\n\n\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\n\tbadcert, err = NewCertificate(sk, x509.Certificate{})\n\tassert.Nil(t, badcert)\n\tassert.Error(t, err)\n\n\tc0 := Certificate{}\n\tc1 := Certificate{}\n\tassert.False(t, c0.Equals(c1))\n}\n\nfunc TestPEM(t *testing.T) {\n\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\tcert, err := GenerateCertificate(sk)\n\tassert.Nil(t, err)\n\n\tpem, err := cert.PEM()\n\tassert.Nil(t, err)\n\tcert2, err := CertificateFromPEM(pem)\n\tassert.Nil(t, err)\n\tpem2, err := cert2.PEM()\n\tassert.Nil(t, err)\n\tassert.Equal(t, pem, pem2)\n}\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.4501953125,
          "content": "#\n# DO NOT EDIT THIS FILE\n#\n# It is automatically copied from https://github.com/pion/.goassets repository.\n#\n# SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n# SPDX-License-Identifier: MIT\n\ncoverage:\n  status:\n    project:\n      default:\n        # Allow decreasing 2% of total coverage to avoid noise.\n        threshold: 2%\n    patch:\n      default:\n        target: 70%\n        only_pulls: true\n\nignore:\n  - \"examples/*\"\n  - \"examples/**/*\"\n"
        },
        {
          "name": "configuration.go",
          "type": "blob",
          "size": 2.505859375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\n// A Configuration defines how peer-to-peer communication via PeerConnection\n// is established or re-established.\n// Configurations may be set up once and reused across multiple connections.\n// Configurations are treated as readonly. As long as they are unmodified,\n// they are safe for concurrent use.\ntype Configuration struct {\n\t// ICEServers defines a slice describing servers available to be used by\n\t// ICE, such as STUN and TURN servers.\n\tICEServers []ICEServer `json:\"iceServers,omitempty\"`\n\n\t// ICETransportPolicy indicates which candidates the ICEAgent is allowed\n\t// to use.\n\tICETransportPolicy ICETransportPolicy `json:\"iceTransportPolicy,omitempty\"`\n\n\t// BundlePolicy indicates which media-bundling policy to use when gathering\n\t// ICE candidates.\n\tBundlePolicy BundlePolicy `json:\"bundlePolicy,omitempty\"`\n\n\t// RTCPMuxPolicy indicates which rtcp-mux policy to use when gathering ICE\n\t// candidates.\n\tRTCPMuxPolicy RTCPMuxPolicy `json:\"rtcpMuxPolicy,omitempty\"`\n\n\t// PeerIdentity sets the target peer identity for the PeerConnection.\n\t// The PeerConnection will not establish a connection to a remote peer\n\t// unless it can be successfully authenticated with the provided name.\n\tPeerIdentity string `json:\"peerIdentity,omitempty\"`\n\n\t// Certificates describes a set of certificates that the PeerConnection\n\t// uses to authenticate. Valid values for this parameter are created\n\t// through calls to the GenerateCertificate function. Although any given\n\t// DTLS connection will use only one certificate, this attribute allows the\n\t// caller to provide multiple certificates that support different\n\t// algorithms. The final certificate will be selected based on the DTLS\n\t// handshake, which establishes which certificates are allowed. The\n\t// PeerConnection implementation selects which of the certificates is\n\t// used for a given connection; how certificates are selected is outside\n\t// the scope of this specification. If this value is absent, then a default\n\t// set of certificates is generated for each PeerConnection instance.\n\tCertificates []Certificate `json:\"certificates,omitempty\"`\n\n\t// ICECandidatePoolSize describes the size of the prefetched ICE pool.\n\tICECandidatePoolSize uint8 `json:\"iceCandidatePoolSize,omitempty\"`\n\n\t// SDPSemantics controls the type of SDP offers accepted by and\n\t// SDP answers generated by the PeerConnection.\n\tSDPSemantics SDPSemantics `json:\"sdpSemantics,omitempty\"`\n}\n"
        },
        {
          "name": "configuration_common.go",
          "type": "blob",
          "size": 0.888671875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport \"strings\"\n\n// getICEServers side-steps the strict parsing mode of the ice package\n// (as defined in https://tools.ietf.org/html/rfc7064) by copying and then\n// stripping any erroneous queries from \"stun(s):\" URLs before parsing.\nfunc (c Configuration) getICEServers() []ICEServer {\n\ticeServers := append([]ICEServer{}, c.ICEServers...)\n\n\tfor iceServersIndex := range iceServers {\n\t\ticeServers[iceServersIndex].URLs = append([]string{}, iceServers[iceServersIndex].URLs...)\n\n\t\tfor urlsIndex, rawURL := range iceServers[iceServersIndex].URLs {\n\t\t\tif strings.HasPrefix(rawURL, \"stun\") {\n\t\t\t\t// strip the query from \"stun(s):\" if present\n\t\t\t\tparts := strings.Split(rawURL, \"?\")\n\t\t\t\trawURL = parts[0]\n\t\t\t}\n\t\t\ticeServers[iceServersIndex].URLs[urlsIndex] = rawURL\n\t\t}\n\t}\n\treturn iceServers\n}\n"
        },
        {
          "name": "configuration_js.go",
          "type": "blob",
          "size": 1.259765625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\n// Configuration defines a set of parameters to configure how the\n// peer-to-peer communication via PeerConnection is established or\n// re-established.\ntype Configuration struct {\n\t// ICEServers defines a slice describing servers available to be used by\n\t// ICE, such as STUN and TURN servers.\n\tICEServers []ICEServer\n\n\t// ICETransportPolicy indicates which candidates the ICEAgent is allowed\n\t// to use.\n\tICETransportPolicy ICETransportPolicy\n\n\t// BundlePolicy indicates which media-bundling policy to use when gathering\n\t// ICE candidates.\n\tBundlePolicy BundlePolicy\n\n\t// RTCPMuxPolicy indicates which rtcp-mux policy to use when gathering ICE\n\t// candidates.\n\tRTCPMuxPolicy RTCPMuxPolicy\n\n\t// PeerIdentity sets the target peer identity for the PeerConnection.\n\t// The PeerConnection will not establish a connection to a remote peer\n\t// unless it can be successfully authenticated with the provided name.\n\tPeerIdentity string\n\n\t// Certificates are not supported in the JavaScript/Wasm bindings.\n\t// Certificates []Certificate\n\n\t// ICECandidatePoolSize describes the size of the prefetched ICE pool.\n\tICECandidatePoolSize uint8\n}\n"
        },
        {
          "name": "configuration_test.go",
          "type": "blob",
          "size": 1.84375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestConfiguration_getICEServers(t *testing.T) {\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\texpectedServerStr := \"stun:stun.l.google.com:19302\"\n\t\tcfg := Configuration{\n\t\t\tICEServers: []ICEServer{\n\t\t\t\t{\n\t\t\t\t\tURLs: []string{expectedServerStr},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tparsedURLs := cfg.getICEServers()\n\t\tassert.Equal(t, expectedServerStr, parsedURLs[0].URLs[0])\n\t})\n\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\t// ignore the fact that stun URLs shouldn't have a query\n\t\tserverStr := \"stun:global.stun.twilio.com:3478?transport=udp\"\n\t\texpectedServerStr := \"stun:global.stun.twilio.com:3478\"\n\t\tcfg := Configuration{\n\t\t\tICEServers: []ICEServer{\n\t\t\t\t{\n\t\t\t\t\tURLs: []string{serverStr},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tparsedURLs := cfg.getICEServers()\n\t\tassert.Equal(t, expectedServerStr, parsedURLs[0].URLs[0])\n\t})\n}\n\nfunc TestConfigurationJSON(t *testing.T) {\n\tj := `{\n    \"iceServers\": [{\"urls\": [\"turn:turn.example.org\"],\n                    \"username\": \"jch\",\n                    \"credential\": \"topsecret\"\n                  }],\n    \"iceTransportPolicy\": \"relay\",\n    \"bundlePolicy\": \"balanced\",\n    \"rtcpMuxPolicy\": \"require\"\n}`\n\n\tconf := Configuration{\n\t\tICEServers: []ICEServer{\n\t\t\t{\n\t\t\t\tURLs:       []string{\"turn:turn.example.org\"},\n\t\t\t\tUsername:   \"jch\",\n\t\t\t\tCredential: \"topsecret\",\n\t\t\t},\n\t\t},\n\t\tICETransportPolicy: ICETransportPolicyRelay,\n\t\tBundlePolicy:       BundlePolicyBalanced,\n\t\tRTCPMuxPolicy:      RTCPMuxPolicyRequire,\n\t}\n\n\tvar conf2 Configuration\n\tassert.NoError(t, json.Unmarshal([]byte(j), &conf2))\n\tassert.Equal(t, conf, conf2)\n\n\tj2, err := json.Marshal(conf2)\n\tassert.NoError(t, err)\n\n\tvar conf3 Configuration\n\tassert.NoError(t, json.Unmarshal(j2, &conf3))\n\tassert.Equal(t, conf2, conf3)\n}\n"
        },
        {
          "name": "constants.go",
          "type": "blob",
          "size": 1.7119140625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport \"github.com/pion/dtls/v3\"\n\nconst (\n\t// default as the standard ethernet MTU\n\t// can be overwritten with SettingEngine.SetReceiveMTU()\n\treceiveMTU = 1500\n\n\t// simulcastProbeCount is the amount of RTP Packets\n\t// that handleUndeclaredSSRC will read and try to dispatch from\n\t// mid and rid values\n\tsimulcastProbeCount = 10\n\n\t// simulcastMaxProbeRoutines is how many active routines can be used to probe\n\t// If the total amount of incoming SSRCes exceeds this new requests will be ignored\n\tsimulcastMaxProbeRoutines = 25\n\n\tmediaSectionApplication = \"application\"\n\n\tsdpAttributeRid = \"rid\"\n\n\tsdpAttributeSimulcast = \"simulcast\"\n\n\trtpOutboundMTU = 1200\n\n\trtpPayloadTypeBitmask = 0x7F\n\n\tincomingUnhandledRTPSsrc = \"Incoming unhandled RTP ssrc(%d), OnTrack will not be fired. %v\"\n\n\tgeneratedCertificateOrigin = \"WebRTC\"\n\n\tsdesRepairRTPStreamIDURI = \"urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id\"\n\n\t// AttributeRtxPayloadType is the interceptor attribute added when Read() returns an RTX packet containing the RTX stream payload type\n\tAttributeRtxPayloadType = \"rtx_payload_type\"\n\t// AttributeRtxSsrc is the interceptor attribute added when Read() returns an RTX packet containing the RTX stream SSRC\n\tAttributeRtxSsrc = \"rtx_ssrc\"\n\t// AttributeRtxSequenceNumber is the interceptor attribute added when Read() returns an RTX packet containing the RTX stream sequence number\n\tAttributeRtxSequenceNumber = \"rtx_sequence_number\"\n)\n\nfunc defaultSrtpProtectionProfiles() []dtls.SRTPProtectionProfile {\n\treturn []dtls.SRTPProtectionProfile{dtls.SRTP_AEAD_AES_256_GCM, dtls.SRTP_AEAD_AES_128_GCM, dtls.SRTP_AES128_CM_HMAC_SHA1_80}\n}\n"
        },
        {
          "name": "datachannel.go",
          "type": "blob",
          "size": 19.759765625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pion/datachannel\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\nconst dataChannelBufferSize = math.MaxUint16 // message size limit for Chromium\nvar errSCTPNotEstablished = errors.New(\"SCTP not established\")\n\n// DataChannel represents a WebRTC DataChannel\n// The DataChannel interface represents a network channel\n// which can be used for bidirectional peer-to-peer transfers of arbitrary data\ntype DataChannel struct {\n\tmu sync.RWMutex\n\n\tstatsID                    string\n\tlabel                      string\n\tordered                    bool\n\tmaxPacketLifeTime          *uint16\n\tmaxRetransmits             *uint16\n\tprotocol                   string\n\tnegotiated                 bool\n\tid                         *uint16\n\treadyState                 atomic.Value // DataChannelState\n\tbufferedAmountLowThreshold uint64\n\tdetachCalled               bool\n\treadLoopActive             chan struct{}\n\tisGracefulClosed           bool\n\n\t// The binaryType represents attribute MUST, on getting, return the value to\n\t// which it was last set. On setting, if the new value is either the string\n\t// \"blob\" or the string \"arraybuffer\", then set the IDL attribute to this\n\t// new value. Otherwise, throw a SyntaxError. When an DataChannel object\n\t// is created, the binaryType attribute MUST be initialized to the string\n\t// \"blob\". This attribute controls how binary data is exposed to scripts.\n\t// binaryType                 string\n\n\tonMessageHandler    func(DataChannelMessage)\n\topenHandlerOnce     sync.Once\n\tonOpenHandler       func()\n\tdialHandlerOnce     sync.Once\n\tonDialHandler       func()\n\tonCloseHandler      func()\n\tonBufferedAmountLow func()\n\tonErrorHandler      func(error)\n\n\tsctpTransport *SCTPTransport\n\tdataChannel   *datachannel.DataChannel\n\n\t// A reference to the associated api object used by this datachannel\n\tapi *API\n\tlog logging.LeveledLogger\n}\n\n// NewDataChannel creates a new DataChannel.\n// This constructor is part of the ORTC API. It is not\n// meant to be used together with the basic WebRTC API.\nfunc (api *API) NewDataChannel(transport *SCTPTransport, params *DataChannelParameters) (*DataChannel, error) {\n\td, err := api.newDataChannel(params, nil, api.settingEngine.LoggerFactory.NewLogger(\"ortc\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = d.open(transport)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn d, nil\n}\n\n// newDataChannel is an internal constructor for the data channel used to\n// create the DataChannel object before the networking is set up.\nfunc (api *API) newDataChannel(params *DataChannelParameters, sctpTransport *SCTPTransport, log logging.LeveledLogger) (*DataChannel, error) {\n\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #5)\n\tif len(params.Label) > 65535 {\n\t\treturn nil, &rtcerr.TypeError{Err: ErrStringSizeLimit}\n\t}\n\n\td := &DataChannel{\n\t\tsctpTransport:     sctpTransport,\n\t\tstatsID:           fmt.Sprintf(\"DataChannel-%d\", time.Now().UnixNano()),\n\t\tlabel:             params.Label,\n\t\tprotocol:          params.Protocol,\n\t\tnegotiated:        params.Negotiated,\n\t\tid:                params.ID,\n\t\tordered:           params.Ordered,\n\t\tmaxPacketLifeTime: params.MaxPacketLifeTime,\n\t\tmaxRetransmits:    params.MaxRetransmits,\n\t\tapi:               api,\n\t\tlog:               log,\n\t}\n\n\td.setReadyState(DataChannelStateConnecting)\n\treturn d, nil\n}\n\n// open opens the datachannel over the sctp transport\nfunc (d *DataChannel) open(sctpTransport *SCTPTransport) error {\n\tassociation := sctpTransport.association()\n\tif association == nil {\n\t\treturn errSCTPNotEstablished\n\t}\n\n\td.mu.Lock()\n\tif d.sctpTransport != nil { // already open\n\t\td.mu.Unlock()\n\t\treturn nil\n\t}\n\td.sctpTransport = sctpTransport\n\tvar channelType datachannel.ChannelType\n\tvar reliabilityParameter uint32\n\n\tswitch {\n\tcase d.maxPacketLifeTime == nil && d.maxRetransmits == nil:\n\t\tif d.ordered {\n\t\t\tchannelType = datachannel.ChannelTypeReliable\n\t\t} else {\n\t\t\tchannelType = datachannel.ChannelTypeReliableUnordered\n\t\t}\n\n\tcase d.maxRetransmits != nil:\n\t\treliabilityParameter = uint32(*d.maxRetransmits)\n\t\tif d.ordered {\n\t\t\tchannelType = datachannel.ChannelTypePartialReliableRexmit\n\t\t} else {\n\t\t\tchannelType = datachannel.ChannelTypePartialReliableRexmitUnordered\n\t\t}\n\tdefault:\n\t\treliabilityParameter = uint32(*d.maxPacketLifeTime)\n\t\tif d.ordered {\n\t\t\tchannelType = datachannel.ChannelTypePartialReliableTimed\n\t\t} else {\n\t\t\tchannelType = datachannel.ChannelTypePartialReliableTimedUnordered\n\t\t}\n\t}\n\n\tcfg := &datachannel.Config{\n\t\tChannelType:          channelType,\n\t\tPriority:             datachannel.ChannelPriorityNormal,\n\t\tReliabilityParameter: reliabilityParameter,\n\t\tLabel:                d.label,\n\t\tProtocol:             d.protocol,\n\t\tNegotiated:           d.negotiated,\n\t\tLoggerFactory:        d.api.settingEngine.LoggerFactory,\n\t}\n\n\tif d.id == nil {\n\t\t// avoid holding lock when generating ID, since id generation locks\n\t\td.mu.Unlock()\n\t\tvar dcID *uint16\n\t\terr := d.sctpTransport.generateAndSetDataChannelID(d.sctpTransport.dtlsTransport.role(), &dcID)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\td.mu.Lock()\n\t\td.id = dcID\n\t}\n\tdc, err := datachannel.Dial(association, *d.id, cfg)\n\tif err != nil {\n\t\td.mu.Unlock()\n\t\treturn err\n\t}\n\n\t// bufferedAmountLowThreshold and onBufferedAmountLow might be set earlier\n\tdc.SetBufferedAmountLowThreshold(d.bufferedAmountLowThreshold)\n\tdc.OnBufferedAmountLow(d.onBufferedAmountLow)\n\td.mu.Unlock()\n\n\td.onDial()\n\td.handleOpen(dc, false, d.negotiated)\n\treturn nil\n}\n\n// Transport returns the SCTPTransport instance the DataChannel is sending over.\nfunc (d *DataChannel) Transport() *SCTPTransport {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.sctpTransport\n}\n\n// After onOpen is complete check that the user called detach\n// and provide an error message if the call was missed\nfunc (d *DataChannel) checkDetachAfterOpen() {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\tif d.api.settingEngine.detach.DataChannels && !d.detachCalled {\n\t\td.log.Warn(\"webrtc.DetachDataChannels() enabled but didn't Detach, call Detach from OnOpen\")\n\t}\n}\n\n// OnOpen sets an event handler which is invoked when\n// the underlying data transport has been established (or re-established).\nfunc (d *DataChannel) OnOpen(f func()) {\n\td.mu.Lock()\n\td.openHandlerOnce = sync.Once{}\n\td.onOpenHandler = f\n\td.mu.Unlock()\n\n\tif d.ReadyState() == DataChannelStateOpen {\n\t\t// If the data channel is already open, call the handler immediately.\n\t\tgo d.openHandlerOnce.Do(func() {\n\t\t\tf()\n\t\t\td.checkDetachAfterOpen()\n\t\t})\n\t}\n}\n\nfunc (d *DataChannel) onOpen() {\n\td.mu.RLock()\n\thandler := d.onOpenHandler\n\tif d.isGracefulClosed {\n\t\td.mu.RUnlock()\n\t\treturn\n\t}\n\td.mu.RUnlock()\n\n\tif handler != nil {\n\t\tgo d.openHandlerOnce.Do(func() {\n\t\t\thandler()\n\t\t\td.checkDetachAfterOpen()\n\t\t})\n\t}\n}\n\n// OnDial sets an event handler which is invoked when the\n// peer has been dialed, but before said peer has responded\nfunc (d *DataChannel) OnDial(f func()) {\n\td.mu.Lock()\n\td.dialHandlerOnce = sync.Once{}\n\td.onDialHandler = f\n\td.mu.Unlock()\n\n\tif d.ReadyState() == DataChannelStateOpen {\n\t\t// If the data channel is already open, call the handler immediately.\n\t\tgo d.dialHandlerOnce.Do(f)\n\t}\n}\n\nfunc (d *DataChannel) onDial() {\n\td.mu.RLock()\n\thandler := d.onDialHandler\n\tif d.isGracefulClosed {\n\t\td.mu.RUnlock()\n\t\treturn\n\t}\n\td.mu.RUnlock()\n\n\tif handler != nil {\n\t\tgo d.dialHandlerOnce.Do(handler)\n\t}\n}\n\n// OnClose sets an event handler which is invoked when\n// the underlying data transport has been closed.\n// Note: Due to backwards compatibility, there is a chance that\n// OnClose can be called, even if the GracefulClose is used.\n// If this is the case for you, you can deregister OnClose\n// prior to GracefulClose.\nfunc (d *DataChannel) OnClose(f func()) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\td.onCloseHandler = f\n}\n\nfunc (d *DataChannel) onClose() {\n\td.mu.RLock()\n\thandler := d.onCloseHandler\n\td.mu.RUnlock()\n\n\tif handler != nil {\n\t\tgo handler()\n\t}\n}\n\n// OnMessage sets an event handler which is invoked on a binary\n// message arrival over the sctp transport from a remote peer.\n// OnMessage can currently receive messages up to 16384 bytes\n// in size. Check out the detach API if you want to use larger\n// message sizes. Note that browser support for larger messages\n// is also limited.\nfunc (d *DataChannel) OnMessage(f func(msg DataChannelMessage)) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\td.onMessageHandler = f\n}\n\nfunc (d *DataChannel) onMessage(msg DataChannelMessage) {\n\td.mu.RLock()\n\thandler := d.onMessageHandler\n\tif d.isGracefulClosed {\n\t\td.mu.RUnlock()\n\t\treturn\n\t}\n\td.mu.RUnlock()\n\n\tif handler == nil {\n\t\treturn\n\t}\n\thandler(msg)\n}\n\nfunc (d *DataChannel) handleOpen(dc *datachannel.DataChannel, isRemote, isAlreadyNegotiated bool) {\n\td.mu.Lock()\n\tif d.isGracefulClosed { // The channel was closed during the connecting state\n\t\td.mu.Unlock()\n\t\tif err := dc.Close(); err != nil {\n\t\t\td.log.Errorf(\"Failed to close DataChannel that was closed during connecting state %v\", err.Error())\n\t\t}\n\t\td.onClose()\n\n\t\treturn\n\t}\n\td.dataChannel = dc\n\tbufferedAmountLowThreshold := d.bufferedAmountLowThreshold\n\tonBufferedAmountLow := d.onBufferedAmountLow\n\td.mu.Unlock()\n\td.setReadyState(DataChannelStateOpen)\n\n\t// Fire the OnOpen handler immediately not using pion/datachannel\n\t// * detached datachannels have no read loop, the user needs to read and query themselves\n\t// * remote datachannels should fire OnOpened. This isn't spec compliant, but we can't break behavior yet\n\t// * already negotiated datachannels should fire OnOpened\n\tif d.api.settingEngine.detach.DataChannels || isRemote || isAlreadyNegotiated {\n\t\t// bufferedAmountLowThreshold and onBufferedAmountLow might be set earlier\n\t\td.dataChannel.SetBufferedAmountLowThreshold(bufferedAmountLowThreshold)\n\t\td.dataChannel.OnBufferedAmountLow(onBufferedAmountLow)\n\t\td.onOpen()\n\t} else {\n\t\tdc.OnOpen(func() {\n\t\t\td.onOpen()\n\t\t})\n\t}\n\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tif d.isGracefulClosed {\n\t\treturn\n\t}\n\n\tif !d.api.settingEngine.detach.DataChannels {\n\t\td.readLoopActive = make(chan struct{})\n\t\tgo d.readLoop()\n\t}\n}\n\n// OnError sets an event handler which is invoked when\n// the underlying data transport cannot be read.\nfunc (d *DataChannel) OnError(f func(err error)) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\td.onErrorHandler = f\n}\n\nfunc (d *DataChannel) onError(err error) {\n\td.mu.RLock()\n\thandler := d.onErrorHandler\n\tif d.isGracefulClosed {\n\t\td.mu.RUnlock()\n\t\treturn\n\t}\n\td.mu.RUnlock()\n\n\tif handler != nil {\n\t\tgo handler(err)\n\t}\n}\n\nfunc (d *DataChannel) readLoop() {\n\tdefer func() {\n\t\td.mu.Lock()\n\t\treadLoopActive := d.readLoopActive\n\t\td.mu.Unlock()\n\t\tdefer close(readLoopActive)\n\t}()\n\tbuffer := make([]byte, dataChannelBufferSize)\n\tfor {\n\t\tn, isString, err := d.dataChannel.ReadDataChannel(buffer)\n\t\tif err != nil {\n\t\t\td.setReadyState(DataChannelStateClosed)\n\t\t\tif !errors.Is(err, io.EOF) {\n\t\t\t\td.onError(err)\n\t\t\t}\n\t\t\td.onClose()\n\t\t\treturn\n\t\t}\n\n\t\tm := DataChannelMessage{Data: make([]byte, n), IsString: isString}\n\t\tcopy(m.Data, buffer[:n])\n\n\t\t// NB: Why was DataChannelMessage not passed as a pointer value?\n\t\td.onMessage(m) // nolint:staticcheck\n\t}\n}\n\n// Send sends the binary message to the DataChannel peer\nfunc (d *DataChannel) Send(data []byte) error {\n\terr := d.ensureOpen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = d.dataChannel.WriteDataChannel(data, false)\n\treturn err\n}\n\n// SendText sends the text message to the DataChannel peer\nfunc (d *DataChannel) SendText(s string) error {\n\terr := d.ensureOpen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = d.dataChannel.WriteDataChannel([]byte(s), true)\n\treturn err\n}\n\nfunc (d *DataChannel) ensureOpen() error {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\tif d.ReadyState() != DataChannelStateOpen {\n\t\treturn io.ErrClosedPipe\n\t}\n\treturn nil\n}\n\n// Detach allows you to detach the underlying datachannel.\n// This provides an idiomatic API to work with\n// (`io.ReadWriteCloser` with its `.Read()` and `.Write()` methods,\n// as opposed to `.Send()` and `.OnMessage`),\n// however it disables the OnMessage callback.\n// Before calling Detach you have to enable this behavior by calling\n// webrtc.DetachDataChannels(). Combining detached and normal data channels\n// is not supported.\n// Please refer to the data-channels-detach example and the\n// pion/datachannel documentation for the correct way to handle the\n// resulting DataChannel object.\nfunc (d *DataChannel) Detach() (datachannel.ReadWriteCloser, error) {\n\treturn d.DetachWithDeadline()\n}\n\n// DetachWithDeadline allows you to detach the underlying datachannel.\n// It is the same as Detach but returns a ReadWriteCloserDeadliner.\nfunc (d *DataChannel) DetachWithDeadline() (datachannel.ReadWriteCloserDeadliner, error) {\n\td.mu.Lock()\n\n\tif !d.api.settingEngine.detach.DataChannels {\n\t\treturn nil, errDetachNotEnabled\n\t}\n\n\tif d.dataChannel == nil {\n\t\treturn nil, errDetachBeforeOpened\n\t}\n\n\td.detachCalled = true\n\n\tdataChannel := d.dataChannel\n\td.mu.Unlock()\n\n\t// Remove the reference from SCTPTransport so that the datachannel\n\t// can be garbage collected on close\n\td.sctpTransport.lock.Lock()\n\tn := len(d.sctpTransport.dataChannels)\n\tj := 0\n\tfor i := 0; i < n; i++ {\n\t\tif d == d.sctpTransport.dataChannels[i] {\n\t\t\tcontinue\n\t\t}\n\t\td.sctpTransport.dataChannels[j] = d.sctpTransport.dataChannels[i]\n\t\tj++\n\t}\n\tfor i := j; i < n; i++ {\n\t\td.sctpTransport.dataChannels[i] = nil\n\t}\n\td.sctpTransport.dataChannels = d.sctpTransport.dataChannels[:j]\n\td.sctpTransport.lock.Unlock()\n\n\treturn dataChannel, nil\n}\n\n// Close Closes the DataChannel. It may be called regardless of whether\n// the DataChannel object was created by this peer or the remote peer.\nfunc (d *DataChannel) Close() error {\n\treturn d.close(false)\n}\n\n// GracefulClose Closes the DataChannel. It may be called regardless of whether\n// the DataChannel object was created by this peer or the remote peer. It also waits\n// for any goroutines it started to complete. This is only safe to call outside of\n// DataChannel callbacks or if in a callback, in its own goroutine.\nfunc (d *DataChannel) GracefulClose() error {\n\treturn d.close(true)\n}\n\n// Normally, close only stops writes from happening, so graceful=true\n// will wait for reads to be finished based on underlying SCTP association\n// closure or a SCTP reset stream from the other side. This is safe to call\n// with graceful=true after tearing down a PeerConnection but not\n// necessarily before. For example, if you used a vnet and dropped all packets\n// right before closing the DataChannel, you'd need never see a reset stream.\nfunc (d *DataChannel) close(shouldGracefullyClose bool) error {\n\td.mu.Lock()\n\td.isGracefulClosed = true\n\treadLoopActive := d.readLoopActive\n\tif shouldGracefullyClose && readLoopActive != nil {\n\t\tdefer func() {\n\t\t\t<-readLoopActive\n\t\t}()\n\t}\n\thaveSctpTransport := d.dataChannel != nil\n\td.mu.Unlock()\n\n\tif d.ReadyState() == DataChannelStateClosed {\n\t\treturn nil\n\t}\n\n\td.setReadyState(DataChannelStateClosing)\n\tif !haveSctpTransport {\n\t\treturn nil\n\t}\n\n\treturn d.dataChannel.Close()\n}\n\n// Label represents a label that can be used to distinguish this\n// DataChannel object from other DataChannel objects. Scripts are\n// allowed to create multiple DataChannel objects with the same label.\nfunc (d *DataChannel) Label() string {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.label\n}\n\n// Ordered returns true if the DataChannel is ordered, and false if\n// out-of-order delivery is allowed.\nfunc (d *DataChannel) Ordered() bool {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.ordered\n}\n\n// MaxPacketLifeTime represents the length of the time window (msec) during\n// which transmissions and retransmissions may occur in unreliable mode.\nfunc (d *DataChannel) MaxPacketLifeTime() *uint16 {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.maxPacketLifeTime\n}\n\n// MaxRetransmits represents the maximum number of retransmissions that are\n// attempted in unreliable mode.\nfunc (d *DataChannel) MaxRetransmits() *uint16 {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.maxRetransmits\n}\n\n// Protocol represents the name of the sub-protocol used with this\n// DataChannel.\nfunc (d *DataChannel) Protocol() string {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.protocol\n}\n\n// Negotiated represents whether this DataChannel was negotiated by the\n// application (true), or not (false).\nfunc (d *DataChannel) Negotiated() bool {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.negotiated\n}\n\n// ID represents the ID for this DataChannel. The value is initially\n// null, which is what will be returned if the ID was not provided at\n// channel creation time, and the DTLS role of the SCTP transport has not\n// yet been negotiated. Otherwise, it will return the ID that was either\n// selected by the script or generated. After the ID is set to a non-null\n// value, it will not change.\nfunc (d *DataChannel) ID() *uint16 {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\treturn d.id\n}\n\n// ReadyState represents the state of the DataChannel object.\nfunc (d *DataChannel) ReadyState() DataChannelState {\n\tif v, ok := d.readyState.Load().(DataChannelState); ok {\n\t\treturn v\n\t}\n\treturn DataChannelState(0)\n}\n\n// BufferedAmount represents the number of bytes of application data\n// (UTF-8 text and binary data) that have been queued using send(). Even\n// though the data transmission can occur in parallel, the returned value\n// MUST NOT be decreased before the current task yielded back to the event\n// loop to prevent race conditions. The value does not include framing\n// overhead incurred by the protocol, or buffering done by the operating\n// system or network hardware. The value of BufferedAmount slot will only\n// increase with each call to the send() method as long as the ReadyState is\n// open; however, BufferedAmount does not reset to zero once the channel\n// closes.\nfunc (d *DataChannel) BufferedAmount() uint64 {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\tif d.dataChannel == nil {\n\t\treturn 0\n\t}\n\treturn d.dataChannel.BufferedAmount()\n}\n\n// BufferedAmountLowThreshold represents the threshold at which the\n// bufferedAmount is considered to be low. When the bufferedAmount decreases\n// from above this threshold to equal or below it, the bufferedamountlow\n// event fires. BufferedAmountLowThreshold is initially zero on each new\n// DataChannel, but the application may change its value at any time.\n// The threshold is set to 0 by default.\nfunc (d *DataChannel) BufferedAmountLowThreshold() uint64 {\n\td.mu.RLock()\n\tdefer d.mu.RUnlock()\n\n\tif d.dataChannel == nil {\n\t\treturn d.bufferedAmountLowThreshold\n\t}\n\treturn d.dataChannel.BufferedAmountLowThreshold()\n}\n\n// SetBufferedAmountLowThreshold is used to update the threshold.\n// See BufferedAmountLowThreshold().\nfunc (d *DataChannel) SetBufferedAmountLowThreshold(th uint64) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\td.bufferedAmountLowThreshold = th\n\n\tif d.dataChannel != nil {\n\t\td.dataChannel.SetBufferedAmountLowThreshold(th)\n\t}\n}\n\n// OnBufferedAmountLow sets an event handler which is invoked when\n// the number of bytes of outgoing data becomes lower than or equal to the\n// BufferedAmountLowThreshold.\nfunc (d *DataChannel) OnBufferedAmountLow(f func()) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\td.onBufferedAmountLow = f\n\tif d.dataChannel != nil {\n\t\td.dataChannel.OnBufferedAmountLow(f)\n\t}\n}\n\nfunc (d *DataChannel) getStatsID() string {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\treturn d.statsID\n}\n\nfunc (d *DataChannel) collectStats(collector *statsReportCollector) {\n\tcollector.Collecting()\n\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tstats := DataChannelStats{\n\t\tTimestamp: statsTimestampNow(),\n\t\tType:      StatsTypeDataChannel,\n\t\tID:        d.statsID,\n\t\tLabel:     d.label,\n\t\tProtocol:  d.protocol,\n\t\t// TransportID string `json:\"transportId\"`\n\t\tState: d.ReadyState(),\n\t}\n\n\tif d.id != nil {\n\t\tstats.DataChannelIdentifier = int32(*d.id)\n\t}\n\n\tif d.dataChannel != nil {\n\t\tstats.MessagesSent = d.dataChannel.MessagesSent()\n\t\tstats.BytesSent = d.dataChannel.BytesSent()\n\t\tstats.MessagesReceived = d.dataChannel.MessagesReceived()\n\t\tstats.BytesReceived = d.dataChannel.BytesReceived()\n\t}\n\n\tcollector.Collect(stats.ID, stats)\n}\n\nfunc (d *DataChannel) setReadyState(r DataChannelState) {\n\td.readyState.Store(r)\n}\n"
        },
        {
          "name": "datachannel_go_test.go",
          "type": "blob",
          "size": 20.3857421875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"io\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/datachannel\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDataChannel_EventHandlers(t *testing.T) {\n\tto := test.TimeOut(time.Second * 20)\n\tdefer to.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tapi := NewAPI()\n\tdc := &DataChannel{api: api}\n\n\tonDialCalled := make(chan struct{})\n\tonOpenCalled := make(chan struct{})\n\tonMessageCalled := make(chan struct{})\n\n\t// Verify that the noop case works\n\tassert.NotPanics(t, func() { dc.onOpen() })\n\n\tdc.OnDial(func() {\n\t\tclose(onDialCalled)\n\t})\n\n\tdc.OnOpen(func() {\n\t\tclose(onOpenCalled)\n\t})\n\n\tdc.OnMessage(func(DataChannelMessage) {\n\t\tclose(onMessageCalled)\n\t})\n\n\t// Verify that the set handlers are called\n\tassert.NotPanics(t, func() { dc.onDial() })\n\tassert.NotPanics(t, func() { dc.onOpen() })\n\tassert.NotPanics(t, func() { dc.onMessage(DataChannelMessage{Data: []byte(\"o hai\")}) })\n\n\t// Wait for all handlers to be called\n\t<-onDialCalled\n\t<-onOpenCalled\n\t<-onMessageCalled\n}\n\nfunc TestDataChannel_MessagesAreOrdered(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tapi := NewAPI()\n\tdc := &DataChannel{api: api}\n\n\tmaxVal := 512\n\tout := make(chan int)\n\tinner := func(msg DataChannelMessage) {\n\t\t// randomly sleep\n\t\t// math/rand a weak RNG, but this does not need to be secure. Ignore with #nosec\n\t\t/* #nosec */\n\t\trandInt, err := rand.Int(rand.Reader, big.NewInt(int64(maxVal)))\n\t\t/* #nosec */ if err != nil {\n\t\t\tt.Fatalf(\"Failed to get random sleep duration: %s\", err)\n\t\t}\n\t\ttime.Sleep(time.Duration(randInt.Int64()) * time.Microsecond)\n\t\ts, _ := binary.Varint(msg.Data)\n\t\tout <- int(s)\n\t}\n\tdc.OnMessage(func(p DataChannelMessage) {\n\t\tinner(p)\n\t})\n\n\tgo func() {\n\t\tfor i := 1; i <= maxVal; i++ {\n\t\t\tbuf := make([]byte, 8)\n\t\t\tbinary.PutVarint(buf, int64(i))\n\t\t\tdc.onMessage(DataChannelMessage{Data: buf})\n\t\t\t// Change the registered handler a couple of times to make sure\n\t\t\t// that everything continues to work, we don't lose messages, etc.\n\t\t\tif i%2 == 0 {\n\t\t\t\thandler := func(msg DataChannelMessage) {\n\t\t\t\t\tinner(msg)\n\t\t\t\t}\n\t\t\t\tdc.OnMessage(handler)\n\t\t\t}\n\t\t}\n\t}()\n\n\tvalues := make([]int, 0, maxVal)\n\tfor v := range out {\n\t\tvalues = append(values, v)\n\t\tif len(values) == maxVal {\n\t\t\tclose(out)\n\t\t}\n\t}\n\n\texpected := make([]int, maxVal)\n\tfor i := 1; i <= maxVal; i++ {\n\t\texpected[i-1] = i\n\t}\n\tassert.EqualValues(t, expected, values)\n}\n\n// Note(albrow): This test includes some features that aren't supported by the\n// Wasm bindings (at least for now).\nfunc TestDataChannelParamters_Go(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tt.Run(\"MaxPacketLifeTime exchange\", func(t *testing.T) {\n\t\tordered := true\n\t\tvar maxPacketLifeTime uint16 = 3\n\t\toptions := &DataChannelInit{\n\t\t\tOrdered:           &ordered,\n\t\t\tMaxPacketLifeTime: &maxPacketLifeTime,\n\t\t}\n\n\t\tofferPC, answerPC, dc, done := setUpDataChannelParametersTest(t, options)\n\n\t\t// Check if parameters are correctly set\n\t\tassert.True(t, dc.Ordered(), \"Ordered should be set to true\")\n\t\tif assert.NotNil(t, dc.MaxPacketLifeTime(), \"should not be nil\") {\n\t\t\tassert.Equal(t, maxPacketLifeTime, *dc.MaxPacketLifeTime(), \"should match\")\n\t\t}\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Check if parameters are correctly set\n\t\t\tassert.True(t, d.ordered, \"Ordered should be set to true\")\n\t\t\tif assert.NotNil(t, d.maxPacketLifeTime, \"should not be nil\") {\n\t\t\t\tassert.Equal(t, maxPacketLifeTime, *d.maxPacketLifeTime, \"should match\")\n\t\t\t}\n\t\t\tdone <- true\n\t\t})\n\n\t\tcloseReliabilityParamTest(t, offerPC, answerPC, done)\n\t})\n\n\tt.Run(\"All other property methods\", func(t *testing.T) {\n\t\tid := uint16(123)\n\t\tdc := &DataChannel{}\n\t\tdc.id = &id\n\t\tdc.label = \"mylabel\"\n\t\tdc.protocol = \"myprotocol\"\n\t\tdc.negotiated = true\n\n\t\tassert.Equal(t, dc.id, dc.ID(), \"should match\")\n\t\tassert.Equal(t, dc.label, dc.Label(), \"should match\")\n\t\tassert.Equal(t, dc.protocol, dc.Protocol(), \"should match\")\n\t\tassert.Equal(t, dc.negotiated, dc.Negotiated(), \"should match\")\n\t\tassert.Equal(t, uint64(0), dc.BufferedAmount(), \"should match\")\n\t\tdc.SetBufferedAmountLowThreshold(1500)\n\t\tassert.Equal(t, uint64(1500), dc.BufferedAmountLowThreshold(), \"should match\")\n\t})\n}\n\nfunc TestDataChannelBufferedAmount(t *testing.T) {\n\tt.Run(\"set before datachannel becomes open\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tvar nOfferBufferedAmountLowCbs uint32\n\t\tvar offerBufferedAmountLowThreshold uint64 = 1500\n\t\tvar nAnswerBufferedAmountLowCbs uint32\n\t\tvar answerBufferedAmountLowThreshold uint64 = 1400\n\n\t\tbuf := make([]byte, 1000)\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tnPacketsToSend := int(10)\n\t\tvar nOfferReceived uint32\n\t\tvar nAnswerReceived uint32\n\n\t\tdone := make(chan bool)\n\n\t\tanswerPC.OnDataChannel(func(answerDC *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif answerDC.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tanswerDC.OnOpen(func() {\n\t\t\t\tassert.Equal(t, answerBufferedAmountLowThreshold, answerDC.BufferedAmountLowThreshold(), \"value mismatch\")\n\n\t\t\t\tfor i := 0; i < nPacketsToSend; i++ {\n\t\t\t\t\te := answerDC.Send(buf)\n\t\t\t\t\tif e != nil {\n\t\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tanswerDC.OnMessage(func(DataChannelMessage) {\n\t\t\t\tatomic.AddUint32(&nAnswerReceived, 1)\n\t\t\t})\n\t\t\tassert.True(t, answerDC.Ordered(), \"Ordered should be set to true\")\n\n\t\t\t// The value is temporarily stored in the answerDC object\n\t\t\t// until the answerDC gets opened\n\t\t\tanswerDC.SetBufferedAmountLowThreshold(answerBufferedAmountLowThreshold)\n\t\t\t// The callback function is temporarily stored in the answerDC object\n\t\t\t// until the answerDC gets opened\n\t\t\tanswerDC.OnBufferedAmountLow(func() {\n\t\t\t\tatomic.AddUint32(&nAnswerBufferedAmountLowCbs, 1)\n\t\t\t\tif atomic.LoadUint32(&nOfferBufferedAmountLowCbs) > 0 {\n\t\t\t\t\tdone <- true\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\n\t\tofferDC, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tassert.True(t, offerDC.Ordered(), \"Ordered should be set to true\")\n\n\t\tofferDC.OnOpen(func() {\n\t\t\tassert.Equal(t, offerBufferedAmountLowThreshold, offerDC.BufferedAmountLowThreshold(), \"value mismatch\")\n\n\t\t\tfor i := 0; i < nPacketsToSend; i++ {\n\t\t\t\te := offerDC.Send(buf)\n\t\t\t\tif e != nil {\n\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t\t}\n\t\t\t\t// assert.Equal(t, (i+1)*len(buf), int(offerDC.BufferedAmount()), \"unexpected bufferedAmount\")\n\t\t\t}\n\t\t})\n\n\t\tofferDC.OnMessage(func(DataChannelMessage) {\n\t\t\tatomic.AddUint32(&nOfferReceived, 1)\n\t\t})\n\n\t\t// The value is temporarily stored in the offerDC object\n\t\t// until the offerDC gets opened\n\t\tofferDC.SetBufferedAmountLowThreshold(offerBufferedAmountLowThreshold)\n\t\t// The callback function is temporarily stored in the offerDC object\n\t\t// until the offerDC gets opened\n\t\tofferDC.OnBufferedAmountLow(func() {\n\t\t\tatomic.AddUint32(&nOfferBufferedAmountLowCbs, 1)\n\t\t\tif atomic.LoadUint32(&nAnswerBufferedAmountLowCbs) > 0 {\n\t\t\t\tdone <- true\n\t\t\t}\n\t\t})\n\n\t\terr = signalPair(offerPC, answerPC)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")\n\t\t}\n\n\t\tclosePair(t, offerPC, answerPC, done)\n\n\t\tt.Logf(\"nOfferBufferedAmountLowCbs : %d\", nOfferBufferedAmountLowCbs)\n\t\tt.Logf(\"nAnswerBufferedAmountLowCbs: %d\", nAnswerBufferedAmountLowCbs)\n\t\tassert.True(t, nOfferBufferedAmountLowCbs > uint32(0), \"callback should be made at least once\")\n\t\tassert.True(t, nAnswerBufferedAmountLowCbs > uint32(0), \"callback should be made at least once\")\n\t})\n\n\tt.Run(\"set after datachannel becomes open\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tvar nCbs int\n\t\tbuf := make([]byte, 1000)\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tdone := make(chan bool)\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvar nPacketsReceived int\n\t\t\td.OnMessage(func(DataChannelMessage) {\n\t\t\t\tnPacketsReceived++\n\n\t\t\t\tif nPacketsReceived == 10 {\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\ttime.Sleep(time.Second)\n\t\t\t\t\t\tdone <- true\n\t\t\t\t\t}()\n\t\t\t\t}\n\t\t\t})\n\t\t\tassert.True(t, d.Ordered(), \"Ordered should be set to true\")\n\t\t})\n\n\t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tassert.True(t, dc.Ordered(), \"Ordered should be set to true\")\n\n\t\tdc.OnOpen(func() {\n\t\t\t// The value should directly be passed to sctp\n\t\t\tdc.SetBufferedAmountLowThreshold(1500)\n\t\t\t// The callback function should directly be passed to sctp\n\t\t\tdc.OnBufferedAmountLow(func() {\n\t\t\t\tnCbs++\n\t\t\t})\n\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\te := dc.Send(buf)\n\t\t\t\tif e != nil {\n\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t\t}\n\t\t\t\tassert.Equal(t, uint64(1500), dc.BufferedAmountLowThreshold(), \"value mismatch\")\n\t\t\t\t// assert.Equal(t, (i+1)*len(buf), int(dc.BufferedAmount()), \"unexpected bufferedAmount\")\n\t\t\t}\n\t\t})\n\n\t\tdc.OnMessage(func(DataChannelMessage) {\n\t\t})\n\n\t\terr = signalPair(offerPC, answerPC)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")\n\t\t}\n\n\t\tclosePair(t, offerPC, answerPC, done)\n\n\t\tassert.True(t, nCbs > 0, \"callback should be made at least once\")\n\t})\n}\n\nfunc TestEOF(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlog := logging.NewDefaultLoggerFactory().NewLogger(\"test\")\n\tlabel := \"test-channel\"\n\ttestData := []byte(\"this is some test data\")\n\n\tt.Run(\"Detach\", func(t *testing.T) {\n\t\t// Use Detach data channels mode\n\t\ts := SettingEngine{}\n\t\ts.DetachDataChannels()\n\t\tapi := NewAPI(WithSettingEngine(s))\n\n\t\t// Set up two peer connections.\n\t\tconfig := Configuration{}\n\t\tpca, err := api.NewPeerConnection(config)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tpcb, err := api.NewPeerConnection(config)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tdefer closePairNow(t, pca, pcb)\n\n\t\tvar wg sync.WaitGroup\n\n\t\tdcChan := make(chan datachannel.ReadWriteCloser)\n\t\tpcb.OnDataChannel(func(dc *DataChannel) {\n\t\t\tif dc.Label() != label {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlog.Debug(\"OnDataChannel was called\")\n\t\t\tdc.OnOpen(func() {\n\t\t\t\tdetached, err2 := dc.Detach()\n\t\t\t\tif err2 != nil {\n\t\t\t\t\tlog.Debugf(\"Detach failed: %s\", err2.Error())\n\t\t\t\t\tt.Error(err2)\n\t\t\t\t}\n\n\t\t\t\tdcChan <- detached\n\t\t\t})\n\t\t})\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\tvar msg []byte\n\n\t\t\tlog.Debug(\"Waiting for OnDataChannel\")\n\t\t\tdc := <-dcChan\n\t\t\tlog.Debug(\"data channel opened\")\n\t\t\tdefer func() { assert.NoError(t, dc.Close(), \"should succeed\") }()\n\n\t\t\tlog.Debug(\"Waiting for ping...\")\n\t\t\tmsg, err2 := io.ReadAll(dc)\n\t\t\tlog.Debugf(\"Received ping! \\\"%s\\\"\", string(msg))\n\t\t\tif err2 != nil {\n\t\t\t\tt.Error(err2)\n\t\t\t}\n\n\t\t\tif !bytes.Equal(msg, testData) {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", string(msg), string(testData))\n\t\t\t} else {\n\t\t\t\tlog.Debug(\"Received ping successfully!\")\n\t\t\t}\n\t\t}()\n\n\t\tif err = signalPair(pca, pcb); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tattached, err := pca.CreateDataChannel(label, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tlog.Debug(\"Waiting for data channel to open\")\n\t\topen := make(chan struct{})\n\t\tattached.OnOpen(func() {\n\t\t\topen <- struct{}{}\n\t\t})\n\t\t<-open\n\t\tlog.Debug(\"data channel opened\")\n\n\t\tvar dc io.ReadWriteCloser\n\t\tdc, err = attached.Detach()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tlog.Debug(\"Sending ping...\")\n\t\t\tif _, err2 := dc.Write(testData); err2 != nil {\n\t\t\t\tt.Error(err2)\n\t\t\t}\n\t\t\tlog.Debug(\"Sent ping\")\n\n\t\t\tassert.NoError(t, dc.Close(), \"should succeed\")\n\n\t\t\tlog.Debug(\"Wating for EOF\")\n\t\t\tret, err2 := io.ReadAll(dc)\n\t\t\tassert.Nil(t, err2, \"should succeed\")\n\t\t\tassert.Equal(t, 0, len(ret), \"should be empty\")\n\t\t}()\n\n\t\twg.Wait()\n\t})\n\n\tt.Run(\"No detach\", func(t *testing.T) {\n\t\tlim := test.TimeOut(time.Second * 5)\n\t\tdefer lim.Stop()\n\n\t\t// Set up two peer connections.\n\t\tconfig := Configuration{}\n\t\tpca, err := NewPeerConnection(config)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tpcb, err := NewPeerConnection(config)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tdefer closePairNow(t, pca, pcb)\n\n\t\tvar dca, dcb *DataChannel\n\t\tdcaClosedCh := make(chan struct{})\n\t\tdcbClosedCh := make(chan struct{})\n\n\t\tpcb.OnDataChannel(func(dc *DataChannel) {\n\t\t\tif dc.Label() != label {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlog.Debugf(\"pcb: new datachannel: %s\", dc.Label())\n\n\t\t\tdcb = dc\n\t\t\t// Register channel opening handling\n\t\t\tdcb.OnOpen(func() {\n\t\t\t\tlog.Debug(\"pcb: datachannel opened\")\n\t\t\t})\n\n\t\t\tdcb.OnClose(func() {\n\t\t\t\t// (2)\n\t\t\t\tlog.Debug(\"pcb: data channel closed\")\n\t\t\t\tclose(dcbClosedCh)\n\t\t\t})\n\n\t\t\t// Register the OnMessage to handle incoming messages\n\t\t\tlog.Debug(\"pcb: registering onMessage callback\")\n\t\t\tdcb.OnMessage(func(dcMsg DataChannelMessage) {\n\t\t\t\tlog.Debugf(\"pcb: received ping: %s\", string(dcMsg.Data))\n\t\t\t\tif !reflect.DeepEqual(dcMsg.Data, testData) {\n\t\t\t\t\tt.Error(\"data mismatch\")\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\n\t\tdca, err = pca.CreateDataChannel(label, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tdca.OnOpen(func() {\n\t\t\tlog.Debug(\"pca: data channel opened\")\n\t\t\tlog.Debugf(\"pca: sending \\\"%s\\\"\", string(testData))\n\t\t\tif err := dca.Send(testData); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tlog.Debug(\"pca: sent ping\")\n\t\t\tassert.NoError(t, dca.Close(), \"should succeed\") // <-- dca closes\n\t\t})\n\n\t\tdca.OnClose(func() {\n\t\t\t// (1)\n\t\t\tlog.Debug(\"pca: data channel closed\")\n\t\t\tclose(dcaClosedCh)\n\t\t})\n\n\t\t// Register the OnMessage to handle incoming messages\n\t\tlog.Debug(\"pca: registering onMessage callback\")\n\t\tdca.OnMessage(func(dcMsg DataChannelMessage) {\n\t\t\tlog.Debugf(\"pca: received pong: %s\", string(dcMsg.Data))\n\t\t\tif !reflect.DeepEqual(dcMsg.Data, testData) {\n\t\t\t\tt.Error(\"data mismatch\")\n\t\t\t}\n\t\t})\n\n\t\tif err := signalPair(pca, pcb); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// When dca closes the channel,\n\t\t// (1) dca.Onclose() will fire immediately, then\n\t\t// (2) dcb.OnClose will also fire\n\t\t<-dcaClosedCh // (1)\n\t\t<-dcbClosedCh // (2)\n\t})\n}\n\n// Assert that a Session Description that doesn't follow\n// draft-ietf-mmusic-sctp-sdp is still accepted\nfunc TestDataChannel_NonStandardSessionDescription(t *testing.T) {\n\tto := test.TimeOut(time.Second * 20)\n\tdefer to.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tofferPC, answerPC, err := newPair()\n\tassert.NoError(t, err)\n\n\t_, err = offerPC.CreateDataChannel(\"foo\", nil)\n\tassert.NoError(t, err)\n\n\tonDataChannelCalled := make(chan struct{})\n\tanswerPC.OnDataChannel(func(_ *DataChannel) {\n\t\tclose(onDataChannelCalled)\n\t})\n\n\toffer, err := offerPC.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tofferGatheringComplete := GatheringCompletePromise(offerPC)\n\tassert.NoError(t, offerPC.SetLocalDescription(offer))\n\t<-offerGatheringComplete\n\n\toffer = *offerPC.LocalDescription()\n\n\t// Replace with old values\n\tconst (\n\t\toldApplication = \"m=application 63743 DTLS/SCTP 5000\\r\"\n\t\toldAttribute   = \"a=sctpmap:5000 webrtc-datachannel 256\\r\"\n\t)\n\n\toffer.SDP = regexp.MustCompile(`m=application (.*?)\\r`).ReplaceAllString(offer.SDP, oldApplication)\n\toffer.SDP = regexp.MustCompile(`a=sctp-port(.*?)\\r`).ReplaceAllString(offer.SDP, oldAttribute)\n\n\t// Assert that replace worked\n\tassert.True(t, strings.Contains(offer.SDP, oldApplication))\n\tassert.True(t, strings.Contains(offer.SDP, oldAttribute))\n\n\tassert.NoError(t, answerPC.SetRemoteDescription(offer))\n\n\tanswer, err := answerPC.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tanswerGatheringComplete := GatheringCompletePromise(answerPC)\n\tassert.NoError(t, answerPC.SetLocalDescription(answer))\n\t<-answerGatheringComplete\n\tassert.NoError(t, offerPC.SetRemoteDescription(*answerPC.LocalDescription()))\n\n\t<-onDataChannelCalled\n\tclosePairNow(t, offerPC, answerPC)\n}\n\nfunc TestDataChannel_Dial(t *testing.T) {\n\tt.Run(\"handler should be called once, by dialing peer only\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tdialCalls := make(chan bool, 2)\n\t\twg := new(sync.WaitGroup)\n\t\twg.Add(2)\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\td.OnDial(func() {\n\t\t\t\t// only dialing side should fire OnDial\n\t\t\t\tt.Fatalf(\"answering side should not call on dial\")\n\t\t\t})\n\n\t\t\td.OnOpen(wg.Done)\n\t\t})\n\n\t\td, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tassert.NoError(t, err)\n\t\td.OnDial(func() {\n\t\t\tdialCalls <- true\n\t\t\twg.Done()\n\t\t})\n\n\t\tassert.NoError(t, signalPair(offerPC, answerPC))\n\n\t\twg.Wait()\n\t\tclosePairNow(t, offerPC, answerPC)\n\n\t\tassert.Len(t, dialCalls, 1)\n\t})\n\n\tt.Run(\"handler should be called immediately if already dialed\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tdone := make(chan bool)\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\td, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tassert.NoError(t, err)\n\t\td.OnOpen(func() {\n\t\t\t// when the offer DC has been opened, its guaranteed to have dialed since it has\n\t\t\t// received a response to said dial. this test represents an unrealistic usage,\n\t\t\t// but its the best way to guarantee we \"missed\" the dial event and still invoke\n\t\t\t// the handler.\n\t\t\td.OnDial(func() {\n\t\t\t\tdone <- true\n\t\t\t})\n\t\t})\n\n\t\tassert.NoError(t, signalPair(offerPC, answerPC))\n\n\t\tclosePair(t, offerPC, answerPC, done)\n\t})\n}\n\nfunc TestDetachRemovesDatachannelReference(t *testing.T) {\n\t// Use Detach data channels mode\n\ts := SettingEngine{}\n\ts.DetachDataChannels()\n\tapi := NewAPI(WithSettingEngine(s))\n\n\t// Set up two peer connections.\n\tconfig := Configuration{}\n\tpca, err := api.NewPeerConnection(config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcb, err := api.NewPeerConnection(config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdefer closePairNow(t, pca, pcb)\n\n\tdcChan := make(chan *DataChannel, 1)\n\tpcb.OnDataChannel(func(d *DataChannel) {\n\t\td.OnOpen(func() {\n\t\t\tif _, detachErr := d.Detach(); detachErr != nil {\n\t\t\t\tt.Error(detachErr)\n\t\t\t}\n\n\t\t\tdcChan <- d\n\t\t})\n\t})\n\n\tif err = signalPair(pca, pcb); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tattached, err := pca.CreateDataChannel(\"\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\topen := make(chan struct{}, 1)\n\tattached.OnOpen(func() {\n\t\topen <- struct{}{}\n\t})\n\t<-open\n\n\td := <-dcChan\n\td.sctpTransport.lock.RLock()\n\tdefer d.sctpTransport.lock.RUnlock()\n\tfor _, dc := range d.sctpTransport.dataChannels[:cap(d.sctpTransport.dataChannels)] {\n\t\tif dc == d {\n\t\t\tt.Errorf(\"expected sctpTransport to drop reference to datachannel\")\n\t\t}\n\t}\n}\n\nfunc TestDataChannelClose(t *testing.T) {\n\t// Test if onClose is fired for self and remote after Close is called\n\tt.Run(\"close open channels\", func(t *testing.T) {\n\t\toptions := &DataChannelInit{}\n\n\t\tofferPC, answerPC, dc, done := setUpDataChannelParametersTest(t, options)\n\n\t\tanswerPC.OnDataChannel(func(dataChannel *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif dataChannel.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdataChannel.OnOpen(func() {\n\t\t\t\tassert.NoError(t, dataChannel.Close())\n\t\t\t})\n\n\t\t\tdataChannel.OnClose(func() {\n\t\t\t\tdone <- true\n\t\t\t})\n\t\t})\n\n\t\tdc.OnClose(func() {\n\t\t\tdone <- true\n\t\t})\n\n\t\tassert.NoError(t, signalPair(offerPC, answerPC))\n\n\t\t// Offer and Answer OnClose\n\t\t<-done\n\t\t<-done\n\n\t\tassert.NoError(t, offerPC.Close())\n\t\tassert.NoError(t, answerPC.Close())\n\t})\n\n\t// Test if OnClose is fired for self and remote after Close is called on non-established channel\n\t// https://github.com/pion/webrtc/issues/2659\n\tt.Run(\"Close connecting channels\", func(t *testing.T) {\n\t\toptions := &DataChannelInit{}\n\n\t\tofferPC, answerPC, dc, done := setUpDataChannelParametersTest(t, options)\n\n\t\tanswerPC.OnDataChannel(func(dataChannel *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif dataChannel.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdataChannel.OnOpen(func() {\n\t\t\t\tt.Fatal(\"OnOpen must not be fired after we call Close\")\n\t\t\t})\n\n\t\t\tdataChannel.OnClose(func() {\n\t\t\t\tdone <- true\n\t\t\t})\n\n\t\t\tassert.NoError(t, dataChannel.Close())\n\t\t})\n\n\t\tdc.OnClose(func() {\n\t\t\tdone <- true\n\t\t})\n\n\t\tassert.NoError(t, signalPair(offerPC, answerPC))\n\n\t\t// Offer and Answer OnClose\n\t\t<-done\n\t\t<-done\n\n\t\tassert.NoError(t, offerPC.Close())\n\t\tassert.NoError(t, answerPC.Close())\n\t})\n}\n"
        },
        {
          "name": "datachannel_js.go",
          "type": "blob",
          "size": 10.7783203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"syscall/js\"\n\n\t\"github.com/pion/datachannel\"\n)\n\nconst dataChannelBufferSize = 16384 // Lowest common denominator among browsers\n\n// DataChannel represents a WebRTC DataChannel\n// The DataChannel interface represents a network channel\n// which can be used for bidirectional peer-to-peer transfers of arbitrary data\ntype DataChannel struct {\n\t// Pointer to the underlying JavaScript RTCPeerConnection object.\n\tunderlying js.Value\n\n\t// Keep track of handlers/callbacks so we can call Release as required by the\n\t// syscall/js API. Initially nil.\n\tonOpenHandler       *js.Func\n\tonCloseHandler      *js.Func\n\tonMessageHandler    *js.Func\n\tonBufferedAmountLow *js.Func\n\n\t// A reference to the associated api object used by this datachannel\n\tapi *API\n}\n\n// OnOpen sets an event handler which is invoked when\n// the underlying data transport has been established (or re-established).\nfunc (d *DataChannel) OnOpen(f func()) {\n\tif d.onOpenHandler != nil {\n\t\toldHandler := d.onOpenHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonOpenHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo f()\n\t\treturn js.Undefined()\n\t})\n\td.onOpenHandler = &onOpenHandler\n\td.underlying.Set(\"onopen\", onOpenHandler)\n}\n\n// OnClose sets an event handler which is invoked when\n// the underlying data transport has been closed.\nfunc (d *DataChannel) OnClose(f func()) {\n\tif d.onCloseHandler != nil {\n\t\toldHandler := d.onCloseHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonCloseHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo f()\n\t\treturn js.Undefined()\n\t})\n\td.onCloseHandler = &onCloseHandler\n\td.underlying.Set(\"onclose\", onCloseHandler)\n}\n\n// OnMessage sets an event handler which is invoked on a binary message arrival\n// from a remote peer. Note that browsers may place limitations on message size.\nfunc (d *DataChannel) OnMessage(f func(msg DataChannelMessage)) {\n\tif d.onMessageHandler != nil {\n\t\toldHandler := d.onMessageHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonMessageHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t// pion/webrtc/projects/15\n\t\tdata := args[0].Get(\"data\")\n\t\tgo func() {\n\t\t\t// valueToDataChannelMessage may block when handling 'Blob' data\n\t\t\t// so we need to call it from a new routine. See:\n\t\t\t// https://pkg.go.dev/syscall/js#FuncOf\n\t\t\tmsg := valueToDataChannelMessage(data)\n\t\t\tf(msg)\n\t\t}()\n\t\treturn js.Undefined()\n\t})\n\td.onMessageHandler = &onMessageHandler\n\td.underlying.Set(\"onmessage\", onMessageHandler)\n}\n\n// Send sends the binary message to the DataChannel peer\nfunc (d *DataChannel) Send(data []byte) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tarray := js.Global().Get(\"Uint8Array\").New(len(data))\n\tjs.CopyBytesToJS(array, data)\n\td.underlying.Call(\"send\", array)\n\treturn nil\n}\n\n// SendText sends the text message to the DataChannel peer\nfunc (d *DataChannel) SendText(s string) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\td.underlying.Call(\"send\", s)\n\treturn nil\n}\n\n// Detach allows you to detach the underlying datachannel. This provides\n// an idiomatic API to work with, however it disables the OnMessage callback.\n// Before calling Detach you have to enable this behavior by calling\n// webrtc.DetachDataChannels(). Combining detached and normal data channels\n// is not supported.\n// Please refer to the data-channels-detach example and the\n// pion/datachannel documentation for the correct way to handle the\n// resulting DataChannel object.\nfunc (d *DataChannel) Detach() (datachannel.ReadWriteCloser, error) {\n\tif !d.api.settingEngine.detach.DataChannels {\n\t\treturn nil, fmt.Errorf(\"enable detaching by calling webrtc.DetachDataChannels()\")\n\t}\n\n\tdetached := newDetachedDataChannel(d)\n\treturn detached, nil\n}\n\n// Close Closes the DataChannel. It may be called regardless of whether\n// the DataChannel object was created by this peer or the remote peer.\nfunc (d *DataChannel) Close() (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\n\td.underlying.Call(\"close\")\n\n\t// Release any handlers as required by the syscall/js API.\n\tif d.onOpenHandler != nil {\n\t\td.onOpenHandler.Release()\n\t}\n\tif d.onCloseHandler != nil {\n\t\td.onCloseHandler.Release()\n\t}\n\tif d.onMessageHandler != nil {\n\t\td.onMessageHandler.Release()\n\t}\n\tif d.onBufferedAmountLow != nil {\n\t\td.onBufferedAmountLow.Release()\n\t}\n\n\treturn nil\n}\n\n// Label represents a label that can be used to distinguish this\n// DataChannel object from other DataChannel objects. Scripts are\n// allowed to create multiple DataChannel objects with the same label.\nfunc (d *DataChannel) Label() string {\n\treturn d.underlying.Get(\"label\").String()\n}\n\n// Ordered represents if the DataChannel is ordered, and false if\n// out-of-order delivery is allowed.\nfunc (d *DataChannel) Ordered() bool {\n\tordered := d.underlying.Get(\"ordered\")\n\tif ordered.IsUndefined() {\n\t\treturn true // default is true\n\t}\n\treturn ordered.Bool()\n}\n\n// MaxPacketLifeTime represents the length of the time window (msec) during\n// which transmissions and retransmissions may occur in unreliable mode.\nfunc (d *DataChannel) MaxPacketLifeTime() *uint16 {\n\tif !d.underlying.Get(\"maxPacketLifeTime\").IsUndefined() {\n\t\treturn valueToUint16Pointer(d.underlying.Get(\"maxPacketLifeTime\"))\n\t}\n\n\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n\t// Chrome calls this \"maxRetransmitTime\"\n\treturn valueToUint16Pointer(d.underlying.Get(\"maxRetransmitTime\"))\n}\n\n// MaxRetransmits represents the maximum number of retransmissions that are\n// attempted in unreliable mode.\nfunc (d *DataChannel) MaxRetransmits() *uint16 {\n\treturn valueToUint16Pointer(d.underlying.Get(\"maxRetransmits\"))\n}\n\n// Protocol represents the name of the sub-protocol used with this\n// DataChannel.\nfunc (d *DataChannel) Protocol() string {\n\treturn d.underlying.Get(\"protocol\").String()\n}\n\n// Negotiated represents whether this DataChannel was negotiated by the\n// application (true), or not (false).\nfunc (d *DataChannel) Negotiated() bool {\n\treturn d.underlying.Get(\"negotiated\").Bool()\n}\n\n// ID represents the ID for this DataChannel. The value is initially\n// null, which is what will be returned if the ID was not provided at\n// channel creation time. Otherwise, it will return the ID that was either\n// selected by the script or generated. After the ID is set to a non-null\n// value, it will not change.\nfunc (d *DataChannel) ID() *uint16 {\n\treturn valueToUint16Pointer(d.underlying.Get(\"id\"))\n}\n\n// ReadyState represents the state of the DataChannel object.\nfunc (d *DataChannel) ReadyState() DataChannelState {\n\treturn newDataChannelState(d.underlying.Get(\"readyState\").String())\n}\n\n// BufferedAmount represents the number of bytes of application data\n// (UTF-8 text and binary data) that have been queued using send(). Even\n// though the data transmission can occur in parallel, the returned value\n// MUST NOT be decreased before the current task yielded back to the event\n// loop to prevent race conditions. The value does not include framing\n// overhead incurred by the protocol, or buffering done by the operating\n// system or network hardware. The value of BufferedAmount slot will only\n// increase with each call to the send() method as long as the ReadyState is\n// open; however, BufferedAmount does not reset to zero once the channel\n// closes.\nfunc (d *DataChannel) BufferedAmount() uint64 {\n\treturn uint64(d.underlying.Get(\"bufferedAmount\").Int())\n}\n\n// BufferedAmountLowThreshold represents the threshold at which the\n// bufferedAmount is considered to be low. When the bufferedAmount decreases\n// from above this threshold to equal or below it, the bufferedamountlow\n// event fires. BufferedAmountLowThreshold is initially zero on each new\n// DataChannel, but the application may change its value at any time.\nfunc (d *DataChannel) BufferedAmountLowThreshold() uint64 {\n\treturn uint64(d.underlying.Get(\"bufferedAmountLowThreshold\").Int())\n}\n\n// SetBufferedAmountLowThreshold is used to update the threshold.\n// See BufferedAmountLowThreshold().\nfunc (d *DataChannel) SetBufferedAmountLowThreshold(th uint64) {\n\td.underlying.Set(\"bufferedAmountLowThreshold\", th)\n}\n\n// OnBufferedAmountLow sets an event handler which is invoked when\n// the number of bytes of outgoing data becomes lower than or equal to the\n// BufferedAmountLowThreshold.\nfunc (d *DataChannel) OnBufferedAmountLow(f func()) {\n\tif d.onBufferedAmountLow != nil {\n\t\toldHandler := d.onBufferedAmountLow\n\t\tdefer oldHandler.Release()\n\t}\n\tonBufferedAmountLow := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo f()\n\t\treturn js.Undefined()\n\t})\n\td.onBufferedAmountLow = &onBufferedAmountLow\n\td.underlying.Set(\"onbufferedamountlow\", onBufferedAmountLow)\n}\n\n// valueToDataChannelMessage converts the given value to a DataChannelMessage.\n// val should be obtained from MessageEvent.data where MessageEvent is received\n// via the RTCDataChannel.onmessage callback.\nfunc valueToDataChannelMessage(val js.Value) DataChannelMessage {\n\t// If val is of type string, the conversion is straightforward.\n\tif val.Type() == js.TypeString {\n\t\treturn DataChannelMessage{\n\t\t\tIsString: true,\n\t\t\tData:     []byte(val.String()),\n\t\t}\n\t}\n\n\t// For other types, we need to first determine val.constructor.name.\n\tconstructorName := val.Get(\"constructor\").Get(\"name\").String()\n\tvar data []byte\n\tswitch constructorName {\n\tcase \"Uint8Array\":\n\t\t// We can easily convert Uint8Array to []byte\n\t\tdata = uint8ArrayValueToBytes(val)\n\tcase \"Blob\":\n\t\t// Convert the Blob to an ArrayBuffer and then convert the ArrayBuffer\n\t\t// to a Uint8Array.\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/Blob\n\n\t\t// The JavaScript API for reading from the Blob is asynchronous. We use a\n\t\t// channel to signal when reading is done.\n\t\treader := js.Global().Get(\"FileReader\").New()\n\t\tdoneChan := make(chan struct{})\n\t\treader.Call(\"addEventListener\", \"loadend\", js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t\tgo func() {\n\t\t\t\t// Signal that the FileReader is done reading/loading by sending through\n\t\t\t\t// the doneChan.\n\t\t\t\tdoneChan <- struct{}{}\n\t\t\t}()\n\t\t\treturn js.Undefined()\n\t\t}))\n\n\t\treader.Call(\"readAsArrayBuffer\", val)\n\n\t\t// Wait for the FileReader to finish reading/loading.\n\t\t<-doneChan\n\n\t\t// At this point buffer.result is a typed array, which we know how to\n\t\t// handle.\n\t\tbuffer := reader.Get(\"result\")\n\t\tuint8Array := js.Global().Get(\"Uint8Array\").New(buffer)\n\t\tdata = uint8ArrayValueToBytes(uint8Array)\n\tdefault:\n\t\t// Assume we have an ArrayBufferView type which we can convert to a\n\t\t// Uint8Array in JavaScript.\n\t\t// See: https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView\n\t\tuint8Array := js.Global().Get(\"Uint8Array\").New(val)\n\t\tdata = uint8ArrayValueToBytes(uint8Array)\n\t}\n\n\treturn DataChannelMessage{\n\t\tIsString: false,\n\t\tData:     data,\n\t}\n}\n"
        },
        {
          "name": "datachannel_js_detach.go",
          "type": "blob",
          "size": 1.4462890625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport (\n\t\"errors\"\n)\n\ntype detachedDataChannel struct {\n\tdc *DataChannel\n\n\tread chan DataChannelMessage\n\tdone chan struct{}\n}\n\nfunc newDetachedDataChannel(dc *DataChannel) *detachedDataChannel {\n\tread := make(chan DataChannelMessage)\n\tdone := make(chan struct{})\n\n\t// Wire up callbacks\n\tdc.OnMessage(func(msg DataChannelMessage) {\n\t\tread <- msg // pion/webrtc/projects/15\n\t})\n\n\t// pion/webrtc/projects/15\n\n\treturn &detachedDataChannel{\n\t\tdc:   dc,\n\t\tread: read,\n\t\tdone: done,\n\t}\n}\n\nfunc (c *detachedDataChannel) Read(p []byte) (int, error) {\n\tn, _, err := c.ReadDataChannel(p)\n\treturn n, err\n}\n\nfunc (c *detachedDataChannel) ReadDataChannel(p []byte) (int, bool, error) {\n\tselect {\n\tcase <-c.done:\n\t\treturn 0, false, errors.New(\"Reader closed\")\n\tcase msg := <-c.read:\n\t\tn := copy(p, msg.Data)\n\t\tif n < len(msg.Data) {\n\t\t\treturn n, msg.IsString, errors.New(\"Read buffer to small\")\n\t\t}\n\t\treturn n, msg.IsString, nil\n\t}\n}\n\nfunc (c *detachedDataChannel) Write(p []byte) (n int, err error) {\n\treturn c.WriteDataChannel(p, false)\n}\n\nfunc (c *detachedDataChannel) WriteDataChannel(p []byte, isString bool) (n int, err error) {\n\tif isString {\n\t\terr = c.dc.SendText(string(p))\n\t\treturn len(p), err\n\t}\n\n\terr = c.dc.Send(p)\n\n\treturn len(p), err\n}\n\nfunc (c *detachedDataChannel) Close() error {\n\tclose(c.done)\n\n\treturn c.dc.Close()\n}\n"
        },
        {
          "name": "datachannel_test.go",
          "type": "blob",
          "size": 13.658203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// expectedLabel represents the label of the data channel we are trying to test.\n// Some other channels may have been created during initialization (in the Wasm\n// bindings this is a requirement).\nconst expectedLabel = \"data\"\n\nfunc closePairNow(t testing.TB, pc1, pc2 io.Closer) {\n\tvar fail bool\n\tif err := pc1.Close(); err != nil {\n\t\tt.Errorf(\"Failed to close PeerConnection: %v\", err)\n\t\tfail = true\n\t}\n\tif err := pc2.Close(); err != nil {\n\t\tt.Errorf(\"Failed to close PeerConnection: %v\", err)\n\t\tfail = true\n\t}\n\tif fail {\n\t\tt.FailNow()\n\t}\n}\n\nfunc closePair(t *testing.T, pc1, pc2 io.Closer, done <-chan bool) {\n\tselect {\n\tcase <-time.After(10 * time.Second):\n\t\tt.Fatalf(\"closePair timed out waiting for done signal\")\n\tcase <-done:\n\t\tclosePairNow(t, pc1, pc2)\n\t}\n}\n\nfunc setUpDataChannelParametersTest(t *testing.T, options *DataChannelInit) (*PeerConnection, *PeerConnection, *DataChannel, chan bool) {\n\tofferPC, answerPC, err := newPair()\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t}\n\tdone := make(chan bool)\n\n\tdc, err := offerPC.CreateDataChannel(expectedLabel, options)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t}\n\n\treturn offerPC, answerPC, dc, done\n}\n\nfunc closeReliabilityParamTest(t *testing.T, pc1, pc2 *PeerConnection, done chan bool) {\n\terr := signalPair(pc1, pc2)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")\n\t}\n\n\tclosePair(t, pc1, pc2, done)\n}\n\nfunc BenchmarkDataChannelSend2(b *testing.B)  { benchmarkDataChannelSend(b, 2) }\nfunc BenchmarkDataChannelSend4(b *testing.B)  { benchmarkDataChannelSend(b, 4) }\nfunc BenchmarkDataChannelSend8(b *testing.B)  { benchmarkDataChannelSend(b, 8) }\nfunc BenchmarkDataChannelSend16(b *testing.B) { benchmarkDataChannelSend(b, 16) }\nfunc BenchmarkDataChannelSend32(b *testing.B) { benchmarkDataChannelSend(b, 32) }\n\n// See https://github.com/pion/webrtc/issues/1516\nfunc benchmarkDataChannelSend(b *testing.B, numChannels int) {\n\tofferPC, answerPC, err := newPair()\n\tif err != nil {\n\t\tb.Fatalf(\"Failed to create a PC pair for testing\")\n\t}\n\n\topen := make(map[string]chan bool)\n\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\tif _, ok := open[d.Label()]; !ok {\n\t\t\t// Ignore anything unknown channel label.\n\t\t\treturn\n\t\t}\n\t\td.OnOpen(func() { open[d.Label()] <- true })\n\t})\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < numChannels; i++ {\n\t\tlabel := fmt.Sprintf(\"dc-%d\", i)\n\t\topen[label] = make(chan bool)\n\t\twg.Add(1)\n\t\tdc, err := offerPC.CreateDataChannel(label, nil)\n\t\tassert.NoError(b, err)\n\n\t\tdc.OnOpen(func() {\n\t\t\t<-open[label]\n\t\t\tfor n := 0; n < b.N/numChannels; n++ {\n\t\t\t\tif err := dc.SendText(\"Ping\"); err != nil {\n\t\t\t\t\tb.Fatalf(\"Unexpected error sending data (label=%q): %v\", label, err)\n\t\t\t\t}\n\t\t\t}\n\t\t\twg.Done()\n\t\t})\n\t}\n\n\tassert.NoError(b, signalPair(offerPC, answerPC))\n\twg.Wait()\n\tclosePairNow(b, offerPC, answerPC)\n}\n\nfunc TestDataChannel_Open(t *testing.T) {\n\tconst openOnceChannelCapacity = 2\n\n\tt.Run(\"handler should be called once\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tdone := make(chan bool)\n\t\topenCalls := make(chan bool, openOnceChannelCapacity)\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\t\t\td.OnOpen(func() {\n\t\t\t\topenCalls <- true\n\t\t\t})\n\t\t\td.OnMessage(func(DataChannelMessage) {\n\t\t\t\tgo func() {\n\t\t\t\t\t// Wait a little bit to ensure all messages are processed.\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\tdone <- true\n\t\t\t\t}()\n\t\t\t})\n\t\t})\n\n\t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tassert.NoError(t, err)\n\n\t\tdc.OnOpen(func() {\n\t\t\te := dc.SendText(\"Ping\")\n\t\t\tif e != nil {\n\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t}\n\t\t})\n\n\t\tassert.NoError(t, signalPair(offerPC, answerPC))\n\n\t\tclosePair(t, offerPC, answerPC, done)\n\n\t\tassert.Len(t, openCalls, 1)\n\t})\n\n\tt.Run(\"handler should be called once when already negotiated\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tdone := make(chan bool)\n\t\tanswerOpenCalls := make(chan bool, openOnceChannelCapacity)\n\t\tofferOpenCalls := make(chan bool, openOnceChannelCapacity)\n\n\t\tnegotiated := true\n\t\tordered := true\n\t\tdataChannelID := uint16(0)\n\n\t\tanswerDC, err := answerPC.CreateDataChannel(expectedLabel, &DataChannelInit{\n\t\t\tID:         &dataChannelID,\n\t\t\tNegotiated: &negotiated,\n\t\t\tOrdered:    &ordered,\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tofferDC, err := offerPC.CreateDataChannel(expectedLabel, &DataChannelInit{\n\t\t\tID:         &dataChannelID,\n\t\t\tNegotiated: &negotiated,\n\t\t\tOrdered:    &ordered,\n\t\t})\n\t\tassert.NoError(t, err)\n\n\t\tanswerDC.OnMessage(func(DataChannelMessage) {\n\t\t\tgo func() {\n\t\t\t\t// Wait a little bit to ensure all messages are processed.\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t})\n\t\tanswerDC.OnOpen(func() {\n\t\t\tanswerOpenCalls <- true\n\t\t})\n\n\t\tofferDC.OnOpen(func() {\n\t\t\tofferOpenCalls <- true\n\t\t\te := offerDC.SendText(\"Ping\")\n\t\t\tif e != nil {\n\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t}\n\t\t})\n\n\t\tassert.NoError(t, signalPair(offerPC, answerPC))\n\n\t\tclosePair(t, offerPC, answerPC, done)\n\n\t\tassert.Len(t, answerOpenCalls, 1)\n\t\tassert.Len(t, offerOpenCalls, 1)\n\t})\n}\n\nfunc TestDataChannel_Send(t *testing.T) {\n\tt.Run(\"before signaling\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tdone := make(chan bool)\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\t\t\td.OnMessage(func(DataChannelMessage) {\n\t\t\t\te := d.Send([]byte(\"Pong\"))\n\t\t\t\tif e != nil {\n\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t\t}\n\t\t\t})\n\t\t\tassert.True(t, d.Ordered(), \"Ordered should be set to true\")\n\t\t})\n\n\t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tassert.True(t, dc.Ordered(), \"Ordered should be set to true\")\n\n\t\tdc.OnOpen(func() {\n\t\t\te := dc.SendText(\"Ping\")\n\t\t\tif e != nil {\n\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t}\n\t\t})\n\t\tdc.OnMessage(func(DataChannelMessage) {\n\t\t\tdone <- true\n\t\t})\n\n\t\terr = signalPair(offerPC, answerPC)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing: %+v\", err)\n\t\t}\n\n\t\tclosePair(t, offerPC, answerPC, done)\n\t})\n\n\tt.Run(\"after connected\", func(t *testing.T) {\n\t\treport := test.CheckRoutines(t)\n\t\tdefer report()\n\n\t\tofferPC, answerPC, err := newPair()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t}\n\n\t\tdone := make(chan bool)\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\t\t\td.OnMessage(func(DataChannelMessage) {\n\t\t\t\te := d.Send([]byte(\"Pong\"))\n\t\t\t\tif e != nil {\n\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t\t}\n\t\t\t})\n\t\t\tassert.True(t, d.Ordered(), \"Ordered should be set to true\")\n\t\t})\n\n\t\tonce := &sync.Once{}\n\t\tofferPC.OnICEConnectionStateChange(func(state ICEConnectionState) {\n\t\t\tif state == ICEConnectionStateConnected || state == ICEConnectionStateCompleted {\n\t\t\t\t// wasm fires completed state multiple times\n\t\t\t\tonce.Do(func() {\n\t\t\t\t\tdc, createErr := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\t\t\t\tif createErr != nil {\n\t\t\t\t\t\tt.Fatalf(\"Failed to create a PC pair for testing\")\n\t\t\t\t\t}\n\n\t\t\t\t\tassert.True(t, dc.Ordered(), \"Ordered should be set to true\")\n\n\t\t\t\t\tdc.OnMessage(func(DataChannelMessage) {\n\t\t\t\t\t\tdone <- true\n\t\t\t\t\t})\n\n\t\t\t\t\tif e := dc.SendText(\"Ping\"); e != nil {\n\t\t\t\t\t\t// wasm binding doesn't fire OnOpen (we probably already missed it)\n\t\t\t\t\t\tdc.OnOpen(func() {\n\t\t\t\t\t\t\te = dc.SendText(\"Ping\")\n\t\t\t\t\t\t\tif e != nil {\n\t\t\t\t\t\t\t\tt.Fatalf(\"Failed to send string on data channel\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\n\t\terr = signalPair(offerPC, answerPC)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to signal our PC pair for testing\")\n\t\t}\n\n\t\tclosePair(t, offerPC, answerPC, done)\n\t})\n}\n\nfunc TestDataChannel_Close(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tt.Run(\"Close after PeerConnection Closed\", func(t *testing.T) {\n\t\tofferPC, answerPC, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tassert.NoError(t, err)\n\n\t\tclosePairNow(t, offerPC, answerPC)\n\t\tassert.NoError(t, dc.Close())\n\t})\n\n\tt.Run(\"Close before connected\", func(t *testing.T) {\n\t\tofferPC, answerPC, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tdc, err := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, dc.Close())\n\t\tclosePairNow(t, offerPC, answerPC)\n\t})\n}\n\nfunc TestDataChannelParameters(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tt.Run(\"MaxPacketLifeTime exchange\", func(t *testing.T) {\n\t\tordered := true\n\t\tmaxPacketLifeTime := uint16(3)\n\t\toptions := &DataChannelInit{\n\t\t\tOrdered:           &ordered,\n\t\t\tMaxPacketLifeTime: &maxPacketLifeTime,\n\t\t}\n\n\t\tofferPC, answerPC, dc, done := setUpDataChannelParametersTest(t, options)\n\n\t\t// Check if parameters are correctly set\n\t\tassert.Equal(t, dc.Ordered(), ordered, \"Ordered should be same value as set in DataChannelInit\")\n\t\tif assert.NotNil(t, dc.MaxPacketLifeTime(), \"should not be nil\") {\n\t\t\tassert.Equal(t, maxPacketLifeTime, *dc.MaxPacketLifeTime(), \"should match\")\n\t\t}\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Check if parameters are correctly set\n\t\t\tassert.Equal(t, d.Ordered(), ordered, \"Ordered should be same value as set in DataChannelInit\")\n\t\t\tif assert.NotNil(t, d.MaxPacketLifeTime(), \"should not be nil\") {\n\t\t\t\tassert.Equal(t, maxPacketLifeTime, *d.MaxPacketLifeTime(), \"should match\")\n\t\t\t}\n\t\t\tdone <- true\n\t\t})\n\n\t\tcloseReliabilityParamTest(t, offerPC, answerPC, done)\n\t})\n\n\tt.Run(\"MaxRetransmits exchange\", func(t *testing.T) {\n\t\tordered := false\n\t\tmaxRetransmits := uint16(3000)\n\t\toptions := &DataChannelInit{\n\t\t\tOrdered:        &ordered,\n\t\t\tMaxRetransmits: &maxRetransmits,\n\t\t}\n\n\t\tofferPC, answerPC, dc, done := setUpDataChannelParametersTest(t, options)\n\n\t\t// Check if parameters are correctly set\n\t\tassert.False(t, dc.Ordered(), \"Ordered should be set to false\")\n\t\tif assert.NotNil(t, dc.MaxRetransmits(), \"should not be nil\") {\n\t\t\tassert.Equal(t, maxRetransmits, *dc.MaxRetransmits(), \"should match\")\n\t\t}\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Check if parameters are correctly set\n\t\t\tassert.False(t, d.Ordered(), \"Ordered should be set to false\")\n\t\t\tif assert.NotNil(t, d.MaxRetransmits(), \"should not be nil\") {\n\t\t\t\tassert.Equal(t, maxRetransmits, *d.MaxRetransmits(), \"should match\")\n\t\t\t}\n\t\t\tdone <- true\n\t\t})\n\n\t\tcloseReliabilityParamTest(t, offerPC, answerPC, done)\n\t})\n\n\tt.Run(\"Protocol exchange\", func(t *testing.T) {\n\t\tprotocol := \"json\"\n\t\toptions := &DataChannelInit{\n\t\t\tProtocol: &protocol,\n\t\t}\n\n\t\tofferPC, answerPC, dc, done := setUpDataChannelParametersTest(t, options)\n\n\t\t// Check if parameters are correctly set\n\t\tassert.Equal(t, protocol, dc.Protocol(), \"Protocol should match DataChannelInit\")\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t\t// created in signalPair).\n\t\t\tif d.Label() != expectedLabel {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Check if parameters are correctly set\n\t\t\tassert.Equal(t, protocol, d.Protocol(), \"Protocol should match what channel creator declared\")\n\t\t\tdone <- true\n\t\t})\n\n\t\tcloseReliabilityParamTest(t, offerPC, answerPC, done)\n\t})\n\n\tt.Run(\"Negotiated exchange\", func(t *testing.T) {\n\t\tconst expectedMessage = \"Hello World\"\n\n\t\tnegotiated := true\n\t\tvar id uint16 = 500\n\t\toptions := &DataChannelInit{\n\t\t\tNegotiated: &negotiated,\n\t\t\tID:         &id,\n\t\t}\n\n\t\tofferPC, answerPC, offerDatachannel, done := setUpDataChannelParametersTest(t, options)\n\t\tanswerDatachannel, err := answerPC.CreateDataChannel(expectedLabel, options)\n\t\tassert.NoError(t, err)\n\n\t\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\t\t// Ignore our default channel, exists to force ICE candidates. See signalPair for more info\n\t\t\tif d.Label() == \"initial_data_channel\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt.Fatal(\"OnDataChannel must not be fired when negotiated == true\")\n\t\t})\n\t\tofferPC.OnDataChannel(func(*DataChannel) {\n\t\t\tt.Fatal(\"OnDataChannel must not be fired when negotiated == true\")\n\t\t})\n\n\t\tseenAnswerMessage := &atomicBool{}\n\t\tseenOfferMessage := &atomicBool{}\n\n\t\tanswerDatachannel.OnMessage(func(msg DataChannelMessage) {\n\t\t\tif msg.IsString && string(msg.Data) == expectedMessage {\n\t\t\t\tseenAnswerMessage.set(true)\n\t\t\t}\n\t\t})\n\n\t\tofferDatachannel.OnMessage(func(msg DataChannelMessage) {\n\t\t\tif msg.IsString && string(msg.Data) == expectedMessage {\n\t\t\t\tseenOfferMessage.set(true)\n\t\t\t}\n\t\t})\n\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tif seenAnswerMessage.get() && seenOfferMessage.get() {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif offerDatachannel.ReadyState() == DataChannelStateOpen {\n\t\t\t\t\tassert.NoError(t, offerDatachannel.SendText(expectedMessage))\n\t\t\t\t}\n\t\t\t\tif answerDatachannel.ReadyState() == DataChannelStateOpen {\n\t\t\t\t\tassert.NoError(t, answerDatachannel.SendText(expectedMessage))\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t}\n\n\t\t\tdone <- true\n\t\t}()\n\n\t\tcloseReliabilityParamTest(t, offerPC, answerPC, done)\n\t})\n}\n"
        },
        {
          "name": "datachannelinit.go",
          "type": "blob",
          "size": 1.4169921875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// DataChannelInit can be used to configure properties of the underlying\n// channel such as data reliability.\ntype DataChannelInit struct {\n\t// Ordered indicates if data is allowed to be delivered out of order. The\n\t// default value of true, guarantees that data will be delivered in order.\n\tOrdered *bool\n\n\t// MaxPacketLifeTime limits the time (in milliseconds) during which the\n\t// channel will transmit or retransmit data if not acknowledged. This value\n\t// may be clamped if it exceeds the maximum value supported.\n\tMaxPacketLifeTime *uint16\n\n\t// MaxRetransmits limits the number of times a channel will retransmit data\n\t// if not successfully delivered. This value may be clamped if it exceeds\n\t// the maximum value supported.\n\tMaxRetransmits *uint16\n\n\t// Protocol describes the subprotocol name used for this channel.\n\tProtocol *string\n\n\t// Negotiated describes if the data channel is created by the local peer or\n\t// the remote peer. The default value of false tells the user agent to\n\t// announce the channel in-band and instruct the other peer to dispatch a\n\t// corresponding DataChannel. If set to true, it is up to the application\n\t// to negotiate the channel and create an DataChannel with the same id\n\t// at the other peer.\n\tNegotiated *bool\n\n\t// ID overrides the default selection of ID for this channel.\n\tID *uint16\n}\n"
        },
        {
          "name": "datachannelmessage.go",
          "type": "blob",
          "size": 0.37890625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// DataChannelMessage represents a message received from the\n// data channel. IsString will be set to true if the incoming\n// message is of the string type. Otherwise the message is of\n// a binary type.\ntype DataChannelMessage struct {\n\tIsString bool\n\tData     []byte\n}\n"
        },
        {
          "name": "datachannelparameters.go",
          "type": "blob",
          "size": 0.5380859375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// DataChannelParameters describes the configuration of the DataChannel.\ntype DataChannelParameters struct {\n\tLabel             string  `json:\"label\"`\n\tProtocol          string  `json:\"protocol\"`\n\tID                *uint16 `json:\"id\"`\n\tOrdered           bool    `json:\"ordered\"`\n\tMaxPacketLifeTime *uint16 `json:\"maxPacketLifeTime\"`\n\tMaxRetransmits    *uint16 `json:\"maxRetransmits\"`\n\tNegotiated        bool    `json:\"negotiated\"`\n}\n"
        },
        {
          "name": "datachannelstate.go",
          "type": "blob",
          "size": 2.236328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// DataChannelState indicates the state of a data channel.\ntype DataChannelState int\n\nconst (\n\t// DataChannelStateUnknown is the enum's zero-value\n\tDataChannelStateUnknown DataChannelState = iota\n\n\t// DataChannelStateConnecting indicates that the data channel is being\n\t// established. This is the initial state of DataChannel, whether created\n\t// with CreateDataChannel, or dispatched as a part of an DataChannelEvent.\n\tDataChannelStateConnecting\n\n\t// DataChannelStateOpen indicates that the underlying data transport is\n\t// established and communication is possible.\n\tDataChannelStateOpen\n\n\t// DataChannelStateClosing indicates that the procedure to close down the\n\t// underlying data transport has started.\n\tDataChannelStateClosing\n\n\t// DataChannelStateClosed indicates that the underlying data transport\n\t// has been closed or could not be established.\n\tDataChannelStateClosed\n)\n\n// This is done this way because of a linter.\nconst (\n\tdataChannelStateConnectingStr = \"connecting\"\n\tdataChannelStateOpenStr       = \"open\"\n\tdataChannelStateClosingStr    = \"closing\"\n\tdataChannelStateClosedStr     = \"closed\"\n)\n\nfunc newDataChannelState(raw string) DataChannelState {\n\tswitch raw {\n\tcase dataChannelStateConnectingStr:\n\t\treturn DataChannelStateConnecting\n\tcase dataChannelStateOpenStr:\n\t\treturn DataChannelStateOpen\n\tcase dataChannelStateClosingStr:\n\t\treturn DataChannelStateClosing\n\tcase dataChannelStateClosedStr:\n\t\treturn DataChannelStateClosed\n\tdefault:\n\t\treturn DataChannelStateUnknown\n\t}\n}\n\nfunc (t DataChannelState) String() string {\n\tswitch t {\n\tcase DataChannelStateConnecting:\n\t\treturn dataChannelStateConnectingStr\n\tcase DataChannelStateOpen:\n\t\treturn dataChannelStateOpenStr\n\tcase DataChannelStateClosing:\n\t\treturn dataChannelStateClosingStr\n\tcase DataChannelStateClosed:\n\t\treturn dataChannelStateClosedStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// MarshalText implements encoding.TextMarshaler\nfunc (t DataChannelState) MarshalText() ([]byte, error) {\n\treturn []byte(t.String()), nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler\nfunc (t *DataChannelState) UnmarshalText(b []byte) error {\n\t*t = newDataChannelState(string(b))\n\treturn nil\n}\n"
        },
        {
          "name": "datachannelstate_test.go",
          "type": "blob",
          "size": 1.177734375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewDataChannelState(t *testing.T) {\n\ttestCases := []struct {\n\t\tstateString   string\n\t\texpectedState DataChannelState\n\t}{\n\t\t{ErrUnknownType.Error(), DataChannelStateUnknown},\n\t\t{\"connecting\", DataChannelStateConnecting},\n\t\t{\"open\", DataChannelStateOpen},\n\t\t{\"closing\", DataChannelStateClosing},\n\t\t{\"closed\", DataChannelStateClosed},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedState,\n\t\t\tnewDataChannelState(testCase.stateString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestDataChannelState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          DataChannelState\n\t\texpectedString string\n\t}{\n\t\t{DataChannelStateUnknown, ErrUnknownType.Error()},\n\t\t{DataChannelStateConnecting, \"connecting\"},\n\t\t{DataChannelStateOpen, \"open\"},\n\t\t{DataChannelStateClosing, \"closing\"},\n\t\t{DataChannelStateClosed, \"closed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "dtlsfingerprint.go",
          "type": "blob",
          "size": 0.6552734375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// DTLSFingerprint specifies the hash function algorithm and certificate\n// fingerprint as described in https://tools.ietf.org/html/rfc4572.\ntype DTLSFingerprint struct {\n\t// Algorithm specifies one of the hash function algorithms defined in\n\t// the 'Hash function Textual Names' registry.\n\tAlgorithm string `json:\"algorithm\"`\n\n\t// Value specifies the value of the certificate fingerprint in lowercase\n\t// hex string as expressed utilizing the syntax of 'fingerprint' in\n\t// https://tools.ietf.org/html/rfc4572#section-5.\n\tValue string `json:\"value\"`\n}\n"
        },
        {
          "name": "dtlsparameters.go",
          "type": "blob",
          "size": 0.3095703125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// DTLSParameters holds information relating to DTLS configuration.\ntype DTLSParameters struct {\n\tRole         DTLSRole          `json:\"role\"`\n\tFingerprints []DTLSFingerprint `json:\"fingerprints\"`\n}\n"
        },
        {
          "name": "dtlsrole.go",
          "type": "blob",
          "size": 2.53515625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"github.com/pion/sdp/v3\"\n)\n\n// DTLSRole indicates the role of the DTLS transport.\ntype DTLSRole byte\n\nconst (\n\t// DTLSRoleUnknown is the enum's zero-value\n\tDTLSRoleUnknown DTLSRole = iota\n\n\t// DTLSRoleAuto defines the DTLS role is determined based on\n\t// the resolved ICE role: the ICE controlled role acts as the DTLS\n\t// client and the ICE controlling role acts as the DTLS server.\n\tDTLSRoleAuto\n\n\t// DTLSRoleClient defines the DTLS client role.\n\tDTLSRoleClient\n\n\t// DTLSRoleServer defines the DTLS server role.\n\tDTLSRoleServer\n)\n\nconst (\n\t// https://tools.ietf.org/html/rfc5763\n\t/*\n\t\tThe answerer MUST use either a\n\t\tsetup attribute value of setup:active or setup:passive.  Note that\n\t\tif the answerer uses setup:passive, then the DTLS handshake will\n\t\tnot begin until the answerer is received, which adds additional\n\t\tlatency. setup:active allows the answer and the DTLS handshake to\n\t\toccur in parallel.  Thus, setup:active is RECOMMENDED.\n\t*/\n\tdefaultDtlsRoleAnswer = DTLSRoleClient\n\t/*\n\t\tThe endpoint that is the offerer MUST use the setup attribute\n\t\tvalue of setup:actpass and be prepared to receive a client_hello\n\t\tbefore it receives the answer.\n\t*/\n\tdefaultDtlsRoleOffer = DTLSRoleAuto\n)\n\nfunc (r DTLSRole) String() string {\n\tswitch r {\n\tcase DTLSRoleAuto:\n\t\treturn \"auto\"\n\tcase DTLSRoleClient:\n\t\treturn \"client\"\n\tcase DTLSRoleServer:\n\t\treturn \"server\"\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// Iterate a SessionDescription from a remote to determine if an explicit\n// role can been determined from it. The decision is made from the first role we we parse.\n// If no role can be found we return DTLSRoleAuto\nfunc dtlsRoleFromRemoteSDP(sessionDescription *sdp.SessionDescription) DTLSRole {\n\tif sessionDescription == nil {\n\t\treturn DTLSRoleAuto\n\t}\n\n\tfor _, mediaSection := range sessionDescription.MediaDescriptions {\n\t\tfor _, attribute := range mediaSection.Attributes {\n\t\t\tif attribute.Key == \"setup\" {\n\t\t\t\tswitch attribute.Value {\n\t\t\t\tcase sdp.ConnectionRoleActive.String():\n\t\t\t\t\treturn DTLSRoleClient\n\t\t\t\tcase sdp.ConnectionRolePassive.String():\n\t\t\t\t\treturn DTLSRoleServer\n\t\t\t\tdefault:\n\t\t\t\t\treturn DTLSRoleAuto\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn DTLSRoleAuto\n}\n\nfunc connectionRoleFromDtlsRole(d DTLSRole) sdp.ConnectionRole {\n\tswitch d {\n\tcase DTLSRoleClient:\n\t\treturn sdp.ConnectionRoleActive\n\tcase DTLSRoleServer:\n\t\treturn sdp.ConnectionRolePassive\n\tcase DTLSRoleAuto:\n\t\treturn sdp.ConnectionRoleActpass\n\tdefault:\n\t\treturn sdp.ConnectionRole(0)\n\t}\n}\n"
        },
        {
          "name": "dtlsrole_test.go",
          "type": "blob",
          "size": 2.021484375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDTLSRole_String(t *testing.T) {\n\ttestCases := []struct {\n\t\trole           DTLSRole\n\t\texpectedString string\n\t}{\n\t\t{DTLSRoleUnknown, ErrUnknownType.Error()},\n\t\t{DTLSRoleAuto, \"auto\"},\n\t\t{DTLSRoleClient, \"client\"},\n\t\t{DTLSRoleServer, \"server\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.role.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestDTLSRoleFromRemoteSDP(t *testing.T) {\n\tparseSDP := func(raw string) *sdp.SessionDescription {\n\t\tparsed := &sdp.SessionDescription{}\n\t\tif err := parsed.Unmarshal([]byte(raw)); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn parsed\n\t}\n\n\tconst noMedia = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\n`\n\n\tconst mediaNoSetup = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=application 47299 DTLS/SCTP 5000\nc=IN IP4 192.168.20.129\n`\n\n\tconst mediaSetupDeclared = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=application 47299 DTLS/SCTP 5000\nc=IN IP4 192.168.20.129\na=setup:%s\n`\n\n\ttestCases := []struct {\n\t\ttest               string\n\t\tsessionDescription *sdp.SessionDescription\n\t\texpectedRole       DTLSRole\n\t}{\n\t\t{\"nil SessionDescription\", nil, DTLSRoleAuto},\n\t\t{\"No MediaDescriptions\", parseSDP(noMedia), DTLSRoleAuto},\n\t\t{\"MediaDescription, no setup\", parseSDP(mediaNoSetup), DTLSRoleAuto},\n\t\t{\"MediaDescription, setup:actpass\", parseSDP(fmt.Sprintf(mediaSetupDeclared, \"actpass\")), DTLSRoleAuto},\n\t\t{\"MediaDescription, setup:passive\", parseSDP(fmt.Sprintf(mediaSetupDeclared, \"passive\")), DTLSRoleServer},\n\t\t{\"MediaDescription, setup:active\", parseSDP(fmt.Sprintf(mediaSetupDeclared, \"active\")), DTLSRoleClient},\n\t}\n\tfor _, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedRole,\n\t\t\tdtlsRoleFromRemoteSDP(testCase.sessionDescription),\n\t\t\t\"TestDTLSRoleFromSDP (%s)\", testCase.test,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "dtlstransport.go",
          "type": "blob",
          "size": 15.3662109375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pion/dtls/v3\"\n\t\"github.com/pion/dtls/v3/pkg/crypto/fingerprint\"\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/rtcp\"\n\t\"github.com/pion/srtp/v3\"\n\t\"github.com/pion/webrtc/v4/internal/mux\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\n// DTLSTransport allows an application access to information about the DTLS\n// transport over which RTP and RTCP packets are sent and received by\n// RTPSender and RTPReceiver, as well other data such as SCTP packets sent\n// and received by data channels.\ntype DTLSTransport struct {\n\tlock sync.RWMutex\n\n\ticeTransport          *ICETransport\n\tcertificates          []Certificate\n\tremoteParameters      DTLSParameters\n\tremoteCertificate     []byte\n\tstate                 DTLSTransportState\n\tsrtpProtectionProfile srtp.ProtectionProfile\n\n\tonStateChangeHandler   func(DTLSTransportState)\n\tinternalOnCloseHandler func()\n\n\tconn *dtls.Conn\n\n\tsrtpSession, srtcpSession   atomic.Value\n\tsrtpEndpoint, srtcpEndpoint *mux.Endpoint\n\tsimulcastStreams            []simulcastStreamPair\n\tsrtpReady                   chan struct{}\n\n\tdtlsMatcher mux.MatchFunc\n\n\tapi *API\n\tlog logging.LeveledLogger\n}\n\ntype simulcastStreamPair struct {\n\tsrtp  *srtp.ReadStreamSRTP\n\tsrtcp *srtp.ReadStreamSRTCP\n}\n\n// NewDTLSTransport creates a new DTLSTransport.\n// This constructor is part of the ORTC API. It is not\n// meant to be used together with the basic WebRTC API.\nfunc (api *API) NewDTLSTransport(transport *ICETransport, certificates []Certificate) (*DTLSTransport, error) {\n\tt := &DTLSTransport{\n\t\ticeTransport: transport,\n\t\tapi:          api,\n\t\tstate:        DTLSTransportStateNew,\n\t\tdtlsMatcher:  mux.MatchDTLS,\n\t\tsrtpReady:    make(chan struct{}),\n\t\tlog:          api.settingEngine.LoggerFactory.NewLogger(\"DTLSTransport\"),\n\t}\n\n\tif len(certificates) > 0 {\n\t\tnow := time.Now()\n\t\tfor _, x509Cert := range certificates {\n\t\t\tif !x509Cert.Expires().IsZero() && now.After(x509Cert.Expires()) {\n\t\t\t\treturn nil, &rtcerr.InvalidAccessError{Err: ErrCertificateExpired}\n\t\t\t}\n\t\t\tt.certificates = append(t.certificates, x509Cert)\n\t\t}\n\t} else {\n\t\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\tif err != nil {\n\t\t\treturn nil, &rtcerr.UnknownError{Err: err}\n\t\t}\n\t\tcertificate, err := GenerateCertificate(sk)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tt.certificates = []Certificate{*certificate}\n\t}\n\n\treturn t, nil\n}\n\n// ICETransport returns the currently-configured *ICETransport or nil\n// if one has not been configured\nfunc (t *DTLSTransport) ICETransport() *ICETransport {\n\tt.lock.RLock()\n\tdefer t.lock.RUnlock()\n\treturn t.iceTransport\n}\n\n// onStateChange requires the caller holds the lock\nfunc (t *DTLSTransport) onStateChange(state DTLSTransportState) {\n\tt.state = state\n\thandler := t.onStateChangeHandler\n\tif handler != nil {\n\t\thandler(state)\n\t}\n}\n\n// OnStateChange sets a handler that is fired when the DTLS\n// connection state changes.\nfunc (t *DTLSTransport) OnStateChange(f func(DTLSTransportState)) {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\tt.onStateChangeHandler = f\n}\n\n// State returns the current dtls transport state.\nfunc (t *DTLSTransport) State() DTLSTransportState {\n\tt.lock.RLock()\n\tdefer t.lock.RUnlock()\n\treturn t.state\n}\n\n// WriteRTCP sends a user provided RTCP packet to the connected peer. If no peer is connected the\n// packet is discarded.\nfunc (t *DTLSTransport) WriteRTCP(pkts []rtcp.Packet) (int, error) {\n\traw, err := rtcp.Marshal(pkts)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tsrtcpSession, err := t.getSRTCPSession()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\twriteStream, err := srtcpSession.OpenWriteStream()\n\tif err != nil {\n\t\t// nolint\n\t\treturn 0, fmt.Errorf(\"%w: %v\", errPeerConnWriteRTCPOpenWriteStream, err)\n\t}\n\n\treturn writeStream.Write(raw)\n}\n\n// GetLocalParameters returns the DTLS parameters of the local DTLSTransport upon construction.\nfunc (t *DTLSTransport) GetLocalParameters() (DTLSParameters, error) {\n\tfingerprints := []DTLSFingerprint{}\n\n\tfor _, c := range t.certificates {\n\t\tprints, err := c.GetFingerprints()\n\t\tif err != nil {\n\t\t\treturn DTLSParameters{}, err\n\t\t}\n\n\t\tfingerprints = append(fingerprints, prints...)\n\t}\n\n\treturn DTLSParameters{\n\t\tRole:         DTLSRoleAuto, // always returns the default role\n\t\tFingerprints: fingerprints,\n\t}, nil\n}\n\n// GetRemoteCertificate returns the certificate chain in use by the remote side\n// returns an empty list prior to selection of the remote certificate\nfunc (t *DTLSTransport) GetRemoteCertificate() []byte {\n\tt.lock.RLock()\n\tdefer t.lock.RUnlock()\n\treturn t.remoteCertificate\n}\n\nfunc (t *DTLSTransport) startSRTP() error {\n\tsrtpConfig := &srtp.Config{\n\t\tProfile:       t.srtpProtectionProfile,\n\t\tBufferFactory: t.api.settingEngine.BufferFactory,\n\t\tLoggerFactory: t.api.settingEngine.LoggerFactory,\n\t}\n\tif t.api.settingEngine.replayProtection.SRTP != nil {\n\t\tsrtpConfig.RemoteOptions = append(\n\t\t\tsrtpConfig.RemoteOptions,\n\t\t\tsrtp.SRTPReplayProtection(*t.api.settingEngine.replayProtection.SRTP),\n\t\t)\n\t}\n\n\tif t.api.settingEngine.disableSRTPReplayProtection {\n\t\tsrtpConfig.RemoteOptions = append(\n\t\t\tsrtpConfig.RemoteOptions,\n\t\t\tsrtp.SRTPNoReplayProtection(),\n\t\t)\n\t}\n\n\tif t.api.settingEngine.replayProtection.SRTCP != nil {\n\t\tsrtpConfig.RemoteOptions = append(\n\t\t\tsrtpConfig.RemoteOptions,\n\t\t\tsrtp.SRTCPReplayProtection(*t.api.settingEngine.replayProtection.SRTCP),\n\t\t)\n\t}\n\n\tif t.api.settingEngine.disableSRTCPReplayProtection {\n\t\tsrtpConfig.RemoteOptions = append(\n\t\t\tsrtpConfig.RemoteOptions,\n\t\t\tsrtp.SRTCPNoReplayProtection(),\n\t\t)\n\t}\n\n\tconnState, ok := t.conn.ConnectionState()\n\tif !ok {\n\t\t// nolint\n\t\treturn fmt.Errorf(\"%w: Failed to get DTLS ConnectionState\", errDtlsKeyExtractionFailed)\n\t}\n\n\terr := srtpConfig.ExtractSessionKeysFromDTLS(&connState, t.role() == DTLSRoleClient)\n\tif err != nil {\n\t\t// nolint\n\t\treturn fmt.Errorf(\"%w: %v\", errDtlsKeyExtractionFailed, err)\n\t}\n\n\tsrtpSession, err := srtp.NewSessionSRTP(t.srtpEndpoint, srtpConfig)\n\tif err != nil {\n\t\t// nolint\n\t\treturn fmt.Errorf(\"%w: %v\", errFailedToStartSRTP, err)\n\t}\n\n\tsrtcpSession, err := srtp.NewSessionSRTCP(t.srtcpEndpoint, srtpConfig)\n\tif err != nil {\n\t\t// nolint\n\t\treturn fmt.Errorf(\"%w: %v\", errFailedToStartSRTCP, err)\n\t}\n\n\tt.srtpSession.Store(srtpSession)\n\tt.srtcpSession.Store(srtcpSession)\n\tclose(t.srtpReady)\n\treturn nil\n}\n\nfunc (t *DTLSTransport) getSRTPSession() (*srtp.SessionSRTP, error) {\n\tif value, ok := t.srtpSession.Load().(*srtp.SessionSRTP); ok {\n\t\treturn value, nil\n\t}\n\n\treturn nil, errDtlsTransportNotStarted\n}\n\nfunc (t *DTLSTransport) getSRTCPSession() (*srtp.SessionSRTCP, error) {\n\tif value, ok := t.srtcpSession.Load().(*srtp.SessionSRTCP); ok {\n\t\treturn value, nil\n\t}\n\n\treturn nil, errDtlsTransportNotStarted\n}\n\nfunc (t *DTLSTransport) role() DTLSRole {\n\t// If remote has an explicit role use the inverse\n\tswitch t.remoteParameters.Role {\n\tcase DTLSRoleClient:\n\t\treturn DTLSRoleServer\n\tcase DTLSRoleServer:\n\t\treturn DTLSRoleClient\n\tdefault:\n\t}\n\n\t// If SettingEngine has an explicit role\n\tswitch t.api.settingEngine.answeringDTLSRole {\n\tcase DTLSRoleServer:\n\t\treturn DTLSRoleServer\n\tcase DTLSRoleClient:\n\t\treturn DTLSRoleClient\n\tdefault:\n\t}\n\n\t// Remote was auto and no explicit role was configured via SettingEngine\n\tif t.iceTransport.Role() == ICERoleControlling {\n\t\treturn DTLSRoleServer\n\t}\n\treturn defaultDtlsRoleAnswer\n}\n\n// Start DTLS transport negotiation with the parameters of the remote DTLS transport\nfunc (t *DTLSTransport) Start(remoteParameters DTLSParameters) error { //nolint: gocognit\n\t// Take lock and prepare connection, we must not hold the lock\n\t// when connecting\n\tprepareTransport := func() (DTLSRole, *dtls.Config, error) {\n\t\tt.lock.Lock()\n\t\tdefer t.lock.Unlock()\n\n\t\tif err := t.ensureICEConn(); err != nil {\n\t\t\treturn DTLSRole(0), nil, err\n\t\t}\n\n\t\tif t.state != DTLSTransportStateNew {\n\t\t\treturn DTLSRole(0), nil, &rtcerr.InvalidStateError{Err: fmt.Errorf(\"%w: %s\", errInvalidDTLSStart, t.state)}\n\t\t}\n\n\t\tt.srtpEndpoint = t.iceTransport.newEndpoint(mux.MatchSRTP)\n\t\tt.srtcpEndpoint = t.iceTransport.newEndpoint(mux.MatchSRTCP)\n\t\tt.remoteParameters = remoteParameters\n\n\t\tcert := t.certificates[0]\n\t\tt.onStateChange(DTLSTransportStateConnecting)\n\n\t\treturn t.role(), &dtls.Config{\n\t\t\tCertificates: []tls.Certificate{\n\t\t\t\t{\n\t\t\t\t\tCertificate: [][]byte{cert.x509Cert.Raw},\n\t\t\t\t\tPrivateKey:  cert.privateKey,\n\t\t\t\t},\n\t\t\t},\n\t\t\tSRTPProtectionProfiles: func() []dtls.SRTPProtectionProfile {\n\t\t\t\tif len(t.api.settingEngine.srtpProtectionProfiles) > 0 {\n\t\t\t\t\treturn t.api.settingEngine.srtpProtectionProfiles\n\t\t\t\t}\n\n\t\t\t\treturn defaultSrtpProtectionProfiles()\n\t\t\t}(),\n\t\t\tClientAuth:         dtls.RequireAnyClientCert,\n\t\t\tLoggerFactory:      t.api.settingEngine.LoggerFactory,\n\t\t\tInsecureSkipVerify: !t.api.settingEngine.dtls.disableInsecureSkipVerify,\n\t\t\tCustomCipherSuites: t.api.settingEngine.dtls.customCipherSuites,\n\t\t}, nil\n\t}\n\n\tvar dtlsConn *dtls.Conn\n\tdtlsEndpoint := t.iceTransport.newEndpoint(mux.MatchDTLS)\n\tdtlsEndpoint.SetOnClose(t.internalOnCloseHandler)\n\trole, dtlsConfig, err := prepareTransport()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif t.api.settingEngine.replayProtection.DTLS != nil {\n\t\tdtlsConfig.ReplayProtectionWindow = int(*t.api.settingEngine.replayProtection.DTLS)\n\t}\n\n\tif t.api.settingEngine.dtls.clientAuth != nil {\n\t\tdtlsConfig.ClientAuth = *t.api.settingEngine.dtls.clientAuth\n\t}\n\n\tdtlsConfig.FlightInterval = t.api.settingEngine.dtls.retransmissionInterval\n\tdtlsConfig.InsecureSkipVerifyHello = t.api.settingEngine.dtls.insecureSkipHelloVerify\n\tdtlsConfig.EllipticCurves = t.api.settingEngine.dtls.ellipticCurves\n\tdtlsConfig.ExtendedMasterSecret = t.api.settingEngine.dtls.extendedMasterSecret\n\tdtlsConfig.ClientCAs = t.api.settingEngine.dtls.clientCAs\n\tdtlsConfig.RootCAs = t.api.settingEngine.dtls.rootCAs\n\tdtlsConfig.KeyLogWriter = t.api.settingEngine.dtls.keyLogWriter\n\tdtlsConfig.ClientHelloMessageHook = t.api.settingEngine.dtls.clientHelloMessageHook\n\tdtlsConfig.ServerHelloMessageHook = t.api.settingEngine.dtls.serverHelloMessageHook\n\tdtlsConfig.CertificateRequestMessageHook = t.api.settingEngine.dtls.certificateRequestMessageHook\n\n\t// Connect as DTLS Client/Server, function is blocking and we\n\t// must not hold the DTLSTransport lock\n\tif role == DTLSRoleClient {\n\t\tdtlsConn, err = dtls.Client(dtlsEndpoint, dtlsEndpoint.RemoteAddr(), dtlsConfig)\n\t} else {\n\t\tdtlsConn, err = dtls.Server(dtlsEndpoint, dtlsEndpoint.RemoteAddr(), dtlsConfig)\n\t}\n\n\tif err == nil {\n\t\tif t.api.settingEngine.dtls.connectContextMaker != nil {\n\t\t\thandshakeCtx, _ := t.api.settingEngine.dtls.connectContextMaker()\n\t\t\terr = dtlsConn.HandshakeContext(handshakeCtx)\n\t\t} else {\n\t\t\terr = dtlsConn.Handshake()\n\t\t}\n\t}\n\n\t// Re-take the lock, nothing beyond here is blocking\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\n\tif err != nil {\n\t\tt.onStateChange(DTLSTransportStateFailed)\n\t\treturn err\n\t}\n\n\tsrtpProfile, ok := dtlsConn.SelectedSRTPProtectionProfile()\n\tif !ok {\n\t\tt.onStateChange(DTLSTransportStateFailed)\n\t\treturn ErrNoSRTPProtectionProfile\n\t}\n\n\tswitch srtpProfile {\n\tcase dtls.SRTP_AEAD_AES_128_GCM:\n\t\tt.srtpProtectionProfile = srtp.ProtectionProfileAeadAes128Gcm\n\tcase dtls.SRTP_AEAD_AES_256_GCM:\n\t\tt.srtpProtectionProfile = srtp.ProtectionProfileAeadAes256Gcm\n\tcase dtls.SRTP_AES128_CM_HMAC_SHA1_80:\n\t\tt.srtpProtectionProfile = srtp.ProtectionProfileAes128CmHmacSha1_80\n\tcase dtls.SRTP_NULL_HMAC_SHA1_80:\n\t\tt.srtpProtectionProfile = srtp.ProtectionProfileNullHmacSha1_80\n\tdefault:\n\t\tt.onStateChange(DTLSTransportStateFailed)\n\t\treturn ErrNoSRTPProtectionProfile\n\t}\n\n\t// Check the fingerprint if a certificate was exchanged\n\tconnectionState, ok := dtlsConn.ConnectionState()\n\tif !ok {\n\t\tt.onStateChange(DTLSTransportStateFailed)\n\t\treturn errNoRemoteCertificate\n\t}\n\n\tif len(connectionState.PeerCertificates) == 0 {\n\t\tt.onStateChange(DTLSTransportStateFailed)\n\t\treturn errNoRemoteCertificate\n\t}\n\tt.remoteCertificate = connectionState.PeerCertificates[0]\n\n\tif !t.api.settingEngine.disableCertificateFingerprintVerification {\n\t\tparsedRemoteCert, err := x509.ParseCertificate(t.remoteCertificate)\n\t\tif err != nil {\n\t\t\tif closeErr := dtlsConn.Close(); closeErr != nil {\n\t\t\t\tt.log.Error(err.Error())\n\t\t\t}\n\n\t\t\tt.onStateChange(DTLSTransportStateFailed)\n\t\t\treturn err\n\t\t}\n\n\t\tif err = t.validateFingerPrint(parsedRemoteCert); err != nil {\n\t\t\tif closeErr := dtlsConn.Close(); closeErr != nil {\n\t\t\t\tt.log.Error(err.Error())\n\t\t\t}\n\n\t\t\tt.onStateChange(DTLSTransportStateFailed)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tt.conn = dtlsConn\n\tt.onStateChange(DTLSTransportStateConnected)\n\n\treturn t.startSRTP()\n}\n\n// Stop stops and closes the DTLSTransport object.\nfunc (t *DTLSTransport) Stop() error {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\n\t// Try closing everything and collect the errors\n\tvar closeErrs []error\n\n\tif srtpSession, err := t.getSRTPSession(); err == nil && srtpSession != nil {\n\t\tcloseErrs = append(closeErrs, srtpSession.Close())\n\t}\n\n\tif srtcpSession, err := t.getSRTCPSession(); err == nil && srtcpSession != nil {\n\t\tcloseErrs = append(closeErrs, srtcpSession.Close())\n\t}\n\n\tfor i := range t.simulcastStreams {\n\t\tcloseErrs = append(closeErrs, t.simulcastStreams[i].srtp.Close())\n\t\tcloseErrs = append(closeErrs, t.simulcastStreams[i].srtcp.Close())\n\t}\n\n\tif t.conn != nil {\n\t\t// dtls connection may be closed on sctp close.\n\t\tif err := t.conn.Close(); err != nil && !errors.Is(err, dtls.ErrConnClosed) {\n\t\t\tcloseErrs = append(closeErrs, err)\n\t\t}\n\t}\n\tt.onStateChange(DTLSTransportStateClosed)\n\treturn util.FlattenErrs(closeErrs)\n}\n\nfunc (t *DTLSTransport) validateFingerPrint(remoteCert *x509.Certificate) error {\n\tfor _, fp := range t.remoteParameters.Fingerprints {\n\t\thashAlgo, err := fingerprint.HashFromString(fp.Algorithm)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tremoteValue, err := fingerprint.Fingerprint(remoteCert, hashAlgo)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif strings.EqualFold(remoteValue, fp.Value) {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn errNoMatchingCertificateFingerprint\n}\n\nfunc (t *DTLSTransport) ensureICEConn() error {\n\tif t.iceTransport == nil {\n\t\treturn errICEConnectionNotStarted\n\t}\n\n\treturn nil\n}\n\nfunc (t *DTLSTransport) storeSimulcastStream(srtpReadStream *srtp.ReadStreamSRTP, srtcpReadStream *srtp.ReadStreamSRTCP) {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\n\tt.simulcastStreams = append(t.simulcastStreams, simulcastStreamPair{srtpReadStream, srtcpReadStream})\n}\n\nfunc (t *DTLSTransport) streamsForSSRC(ssrc SSRC, streamInfo interceptor.StreamInfo) (*srtp.ReadStreamSRTP, interceptor.RTPReader, *srtp.ReadStreamSRTCP, interceptor.RTCPReader, error) {\n\tsrtpSession, err := t.getSRTPSession()\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\trtpReadStream, err := srtpSession.OpenReadStream(uint32(ssrc))\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\trtpInterceptor := t.api.interceptor.BindRemoteStream(&streamInfo, interceptor.RTPReaderFunc(func(in []byte, a interceptor.Attributes) (n int, attributes interceptor.Attributes, err error) {\n\t\tn, err = rtpReadStream.Read(in)\n\t\treturn n, a, err\n\t}))\n\n\tsrtcpSession, err := t.getSRTCPSession()\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\trtcpReadStream, err := srtcpSession.OpenReadStream(uint32(ssrc))\n\tif err != nil {\n\t\treturn nil, nil, nil, nil, err\n\t}\n\n\trtcpInterceptor := t.api.interceptor.BindRTCPReader(interceptor.RTCPReaderFunc(func(in []byte, a interceptor.Attributes) (n int, attributes interceptor.Attributes, err error) {\n\t\tn, err = rtcpReadStream.Read(in)\n\t\treturn n, a, err\n\t}))\n\n\treturn rtpReadStream, rtpInterceptor, rtcpReadStream, rtcpInterceptor, nil\n}\n"
        },
        {
          "name": "dtlstransport_js.go",
          "type": "blob",
          "size": 0.861328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport \"syscall/js\"\n\n// DTLSTransport allows an application access to information about the DTLS\n// transport over which RTP and RTCP packets are sent and received by\n// RTPSender and RTPReceiver, as well other data such as SCTP packets sent\n// and received by data channels.\ntype DTLSTransport struct {\n\t// Pointer to the underlying JavaScript DTLSTransport object.\n\tunderlying js.Value\n}\n\n// ICETransport returns the currently-configured *ICETransport or nil\n// if one has not been configured\nfunc (r *DTLSTransport) ICETransport() *ICETransport {\n\tunderlying := r.underlying.Get(\"iceTransport\")\n\tif underlying.IsNull() || underlying.IsUndefined() {\n\t\treturn nil\n\t}\n\n\treturn &ICETransport{\n\t\tunderlying: underlying,\n\t}\n}\n"
        },
        {
          "name": "dtlstransport_test.go",
          "type": "blob",
          "size": 3.5517578125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// An invalid fingerprint MUST cause PeerConnectionState to go to PeerConnectionStateFailed\nfunc TestInvalidFingerprintCausesFailed(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 5)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpcAnswer.OnDataChannel(func(_ *DataChannel) {\n\t\tt.Fatal(\"A DataChannel must not be created when Fingerprint verification fails\")\n\t})\n\n\tdefer closePairNow(t, pcOffer, pcAnswer)\n\n\tofferChan := make(chan SessionDescription)\n\tpcOffer.OnICECandidate(func(candidate *ICECandidate) {\n\t\tif candidate == nil {\n\t\t\tofferChan <- *pcOffer.PendingLocalDescription()\n\t\t}\n\t})\n\n\tofferConnectionHasClosed := untilConnectionState(PeerConnectionStateClosed, pcOffer)\n\tanswerConnectionHasClosed := untilConnectionState(PeerConnectionStateClosed, pcAnswer)\n\n\tif _, err = pcOffer.CreateDataChannel(\"unusedDataChannel\", nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t} else if err := pcOffer.SetLocalDescription(offer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase offer := <-offerChan:\n\t\t// Replace with invalid fingerprint\n\t\tre := regexp.MustCompile(`sha-256 (.*?)\\r`)\n\t\toffer.SDP = re.ReplaceAllString(offer.SDP, \"sha-256 AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA\\r\")\n\n\t\tif err := pcAnswer.SetRemoteDescription(offer); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tanswer, err := pcAnswer.CreateAnswer(nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err = pcAnswer.SetLocalDescription(answer); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tanswer.SDP = re.ReplaceAllString(answer.SDP, \"sha-256 AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA\\r\")\n\n\t\terr = pcOffer.SetRemoteDescription(answer)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"timed out waiting to receive offer\")\n\t}\n\n\tofferConnectionHasClosed.Wait()\n\tanswerConnectionHasClosed.Wait()\n\n\tif pcOffer.SCTP().Transport().State() != DTLSTransportStateClosed && pcOffer.SCTP().Transport().State() != DTLSTransportStateFailed {\n\t\tt.Fail()\n\t}\n\tassert.Nil(t, pcOffer.SCTP().Transport().conn)\n\n\tif pcAnswer.SCTP().Transport().State() != DTLSTransportStateClosed && pcAnswer.SCTP().Transport().State() != DTLSTransportStateFailed {\n\t\tt.Fail()\n\t}\n\tassert.Nil(t, pcAnswer.SCTP().Transport().conn)\n}\n\nfunc TestPeerConnection_DTLSRoleSettingEngine(t *testing.T) {\n\trunTest := func(r DTLSRole) {\n\t\ts := SettingEngine{}\n\t\tassert.NoError(t, s.SetAnsweringDTLSRole(r))\n\n\t\tofferPC, err := NewAPI(WithSettingEngine(s)).NewPeerConnection(Configuration{})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tanswerPC, err := NewAPI(WithSettingEngine(s)).NewPeerConnection(Configuration{})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err = signalPair(offerPC, answerPC); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tconnectionComplete := untilConnectionState(PeerConnectionStateConnected, answerPC)\n\t\tconnectionComplete.Wait()\n\t\tclosePairNow(t, offerPC, answerPC)\n\t}\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tt.Run(\"Server\", func(*testing.T) {\n\t\trunTest(DTLSRoleServer)\n\t})\n\n\tt.Run(\"Client\", func(*testing.T) {\n\t\trunTest(DTLSRoleClient)\n\t})\n}\n"
        },
        {
          "name": "dtlstransportstate.go",
          "type": "blob",
          "size": 2.6669921875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// DTLSTransportState indicates the DTLS transport establishment state.\ntype DTLSTransportState int\n\nconst (\n\t// DTLSTransportStateUnknown is the enum's zero-value\n\tDTLSTransportStateUnknown DTLSTransportState = iota\n\n\t// DTLSTransportStateNew indicates that DTLS has not started negotiating\n\t// yet.\n\tDTLSTransportStateNew\n\n\t// DTLSTransportStateConnecting indicates that DTLS is in the process of\n\t// negotiating a secure connection and verifying the remote fingerprint.\n\tDTLSTransportStateConnecting\n\n\t// DTLSTransportStateConnected indicates that DTLS has completed\n\t// negotiation of a secure connection and verified the remote fingerprint.\n\tDTLSTransportStateConnected\n\n\t// DTLSTransportStateClosed indicates that the transport has been closed\n\t// intentionally as the result of receipt of a close_notify alert, or\n\t// calling close().\n\tDTLSTransportStateClosed\n\n\t// DTLSTransportStateFailed indicates that the transport has failed as\n\t// the result of an error (such as receipt of an error alert or failure to\n\t// validate the remote fingerprint).\n\tDTLSTransportStateFailed\n)\n\n// This is done this way because of a linter.\nconst (\n\tdtlsTransportStateNewStr        = \"new\"\n\tdtlsTransportStateConnectingStr = \"connecting\"\n\tdtlsTransportStateConnectedStr  = \"connected\"\n\tdtlsTransportStateClosedStr     = \"closed\"\n\tdtlsTransportStateFailedStr     = \"failed\"\n)\n\nfunc newDTLSTransportState(raw string) DTLSTransportState {\n\tswitch raw {\n\tcase dtlsTransportStateNewStr:\n\t\treturn DTLSTransportStateNew\n\tcase dtlsTransportStateConnectingStr:\n\t\treturn DTLSTransportStateConnecting\n\tcase dtlsTransportStateConnectedStr:\n\t\treturn DTLSTransportStateConnected\n\tcase dtlsTransportStateClosedStr:\n\t\treturn DTLSTransportStateClosed\n\tcase dtlsTransportStateFailedStr:\n\t\treturn DTLSTransportStateFailed\n\tdefault:\n\t\treturn DTLSTransportStateUnknown\n\t}\n}\n\nfunc (t DTLSTransportState) String() string {\n\tswitch t {\n\tcase DTLSTransportStateNew:\n\t\treturn dtlsTransportStateNewStr\n\tcase DTLSTransportStateConnecting:\n\t\treturn dtlsTransportStateConnectingStr\n\tcase DTLSTransportStateConnected:\n\t\treturn dtlsTransportStateConnectedStr\n\tcase DTLSTransportStateClosed:\n\t\treturn dtlsTransportStateClosedStr\n\tcase DTLSTransportStateFailed:\n\t\treturn dtlsTransportStateFailedStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// MarshalText implements encoding.TextMarshaler\nfunc (t DTLSTransportState) MarshalText() ([]byte, error) {\n\treturn []byte(t.String()), nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler\nfunc (t *DTLSTransportState) UnmarshalText(b []byte) error {\n\t*t = newDTLSTransportState(string(b))\n\treturn nil\n}\n"
        },
        {
          "name": "dtlstransportstate_test.go",
          "type": "blob",
          "size": 1.2890625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewDTLSTransportState(t *testing.T) {\n\ttestCases := []struct {\n\t\tstateString   string\n\t\texpectedState DTLSTransportState\n\t}{\n\t\t{ErrUnknownType.Error(), DTLSTransportStateUnknown},\n\t\t{\"new\", DTLSTransportStateNew},\n\t\t{\"connecting\", DTLSTransportStateConnecting},\n\t\t{\"connected\", DTLSTransportStateConnected},\n\t\t{\"closed\", DTLSTransportStateClosed},\n\t\t{\"failed\", DTLSTransportStateFailed},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedState,\n\t\t\tnewDTLSTransportState(testCase.stateString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestDTLSTransportState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          DTLSTransportState\n\t\texpectedString string\n\t}{\n\t\t{DTLSTransportStateUnknown, ErrUnknownType.Error()},\n\t\t{DTLSTransportStateNew, \"new\"},\n\t\t{DTLSTransportStateConnecting, \"connecting\"},\n\t\t{DTLSTransportStateConnected, \"connected\"},\n\t\t{DTLSTransportStateClosed, \"closed\"},\n\t\t{DTLSTransportStateFailed, \"failed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "e2e",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 15.4267578125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"errors\"\n)\n\nvar (\n\t// ErrUnknownType indicates an error with Unknown info.\n\tErrUnknownType = errors.New(\"unknown\")\n\n\t// ErrConnectionClosed indicates an operation executed after connection\n\t// has already been closed.\n\tErrConnectionClosed = errors.New(\"connection closed\")\n\n\t// ErrDataChannelNotOpen indicates an operation executed when the data\n\t// channel is not (yet) open.\n\tErrDataChannelNotOpen = errors.New(\"data channel not open\")\n\n\t// ErrCertificateExpired indicates that an x509 certificate has expired.\n\tErrCertificateExpired = errors.New(\"x509Cert expired\")\n\n\t// ErrNoTurnCredentials indicates that a TURN server URL was provided\n\t// without required credentials.\n\tErrNoTurnCredentials = errors.New(\"turn server credentials required\")\n\n\t// ErrTurnCredentials indicates that provided TURN credentials are partial\n\t// or malformed.\n\tErrTurnCredentials = errors.New(\"invalid turn server credentials\")\n\n\t// ErrExistingTrack indicates that a track already exists.\n\tErrExistingTrack = errors.New(\"track already exists\")\n\n\t// ErrPrivateKeyType indicates that a particular private key encryption\n\t// chosen to generate a certificate is not supported.\n\tErrPrivateKeyType = errors.New(\"private key type not supported\")\n\n\t// ErrModifyingPeerIdentity indicates that an attempt to modify\n\t// PeerIdentity was made after PeerConnection has been initialized.\n\tErrModifyingPeerIdentity = errors.New(\"peerIdentity cannot be modified\")\n\n\t// ErrModifyingCertificates indicates that an attempt to modify\n\t// Certificates was made after PeerConnection has been initialized.\n\tErrModifyingCertificates = errors.New(\"certificates cannot be modified\")\n\n\t// ErrModifyingBundlePolicy indicates that an attempt to modify\n\t// BundlePolicy was made after PeerConnection has been initialized.\n\tErrModifyingBundlePolicy = errors.New(\"bundle policy cannot be modified\")\n\n\t// ErrModifyingRTCPMuxPolicy indicates that an attempt to modify\n\t// RTCPMuxPolicy was made after PeerConnection has been initialized.\n\tErrModifyingRTCPMuxPolicy = errors.New(\"rtcp mux policy cannot be modified\")\n\n\t// ErrModifyingICECandidatePoolSize indicates that an attempt to modify\n\t// ICECandidatePoolSize was made after PeerConnection has been initialized.\n\tErrModifyingICECandidatePoolSize = errors.New(\"ice candidate pool size cannot be modified\")\n\n\t// ErrStringSizeLimit indicates that the character size limit of string is\n\t// exceeded. The limit is hardcoded to 65535 according to specifications.\n\tErrStringSizeLimit = errors.New(\"data channel label exceeds size limit\")\n\n\t// ErrMaxDataChannelID indicates that the maximum number ID that could be\n\t// specified for a data channel has been exceeded.\n\tErrMaxDataChannelID = errors.New(\"maximum number ID for datachannel specified\")\n\n\t// ErrNegotiatedWithoutID indicates that an attempt to create a data channel\n\t// was made while setting the negotiated option to true without providing\n\t// the negotiated channel ID.\n\tErrNegotiatedWithoutID = errors.New(\"negotiated set without channel id\")\n\n\t// ErrRetransmitsOrPacketLifeTime indicates that an attempt to create a data\n\t// channel was made with both options MaxPacketLifeTime and MaxRetransmits\n\t// set together. Such configuration is not supported by the specification\n\t// and is mutually exclusive.\n\tErrRetransmitsOrPacketLifeTime = errors.New(\"both MaxPacketLifeTime and MaxRetransmits was set\")\n\n\t// ErrCodecNotFound is returned when a codec search to the Media Engine fails\n\tErrCodecNotFound = errors.New(\"codec not found\")\n\n\t// ErrNoRemoteDescription indicates that an operation was rejected because\n\t// the remote description is not set\n\tErrNoRemoteDescription = errors.New(\"remote description is not set\")\n\n\t// ErrIncorrectSDPSemantics indicates that the PeerConnection was configured to\n\t// generate SDP Answers with different SDP Semantics than the received Offer\n\tErrIncorrectSDPSemantics = errors.New(\"remote SessionDescription semantics does not match configuration\")\n\n\t// ErrIncorrectSignalingState indicates that the signaling state of PeerConnection is not correct\n\tErrIncorrectSignalingState = errors.New(\"operation can not be run in current signaling state\")\n\n\t// ErrProtocolTooLarge indicates that value given for a DataChannelInit protocol is\n\t// longer then 65535 bytes\n\tErrProtocolTooLarge = errors.New(\"protocol is larger then 65535 bytes\")\n\n\t// ErrSenderNotCreatedByConnection indicates RemoveTrack was called with a RtpSender not created\n\t// by this PeerConnection\n\tErrSenderNotCreatedByConnection = errors.New(\"RtpSender not created by this PeerConnection\")\n\n\t// ErrSessionDescriptionNoFingerprint indicates SetRemoteDescription was called with a SessionDescription that has no\n\t// fingerprint\n\tErrSessionDescriptionNoFingerprint = errors.New(\"SetRemoteDescription called with no fingerprint\")\n\n\t// ErrSessionDescriptionInvalidFingerprint indicates SetRemoteDescription was called with a SessionDescription that\n\t// has an invalid fingerprint\n\tErrSessionDescriptionInvalidFingerprint = errors.New(\"SetRemoteDescription called with an invalid fingerprint\")\n\n\t// ErrSessionDescriptionConflictingFingerprints indicates SetRemoteDescription was called with a SessionDescription that\n\t// has an conflicting fingerprints\n\tErrSessionDescriptionConflictingFingerprints = errors.New(\"SetRemoteDescription called with multiple conflicting fingerprint\")\n\n\t// ErrSessionDescriptionMissingIceUfrag indicates SetRemoteDescription was called with a SessionDescription that\n\t// is missing an ice-ufrag value\n\tErrSessionDescriptionMissingIceUfrag = errors.New(\"SetRemoteDescription called with no ice-ufrag\")\n\n\t// ErrSessionDescriptionMissingIcePwd indicates SetRemoteDescription was called with a SessionDescription that\n\t// is missing an ice-pwd value\n\tErrSessionDescriptionMissingIcePwd = errors.New(\"SetRemoteDescription called with no ice-pwd\")\n\n\t// ErrSessionDescriptionConflictingIceUfrag  indicates SetRemoteDescription was called with a SessionDescription that\n\t// contains multiple conflicting ice-ufrag values\n\tErrSessionDescriptionConflictingIceUfrag = errors.New(\"SetRemoteDescription called with multiple conflicting ice-ufrag values\")\n\n\t// ErrSessionDescriptionConflictingIcePwd indicates SetRemoteDescription was called with a SessionDescription that\n\t// contains multiple conflicting ice-pwd values\n\tErrSessionDescriptionConflictingIcePwd = errors.New(\"SetRemoteDescription called with multiple conflicting ice-pwd values\")\n\n\t// ErrNoSRTPProtectionProfile indicates that the DTLS handshake completed and no SRTP Protection Profile was chosen\n\tErrNoSRTPProtectionProfile = errors.New(\"DTLS Handshake completed and no SRTP Protection Profile was chosen\")\n\n\t// ErrFailedToGenerateCertificateFingerprint indicates that we failed to generate the fingerprint used for comparing certificates\n\tErrFailedToGenerateCertificateFingerprint = errors.New(\"failed to generate certificate fingerprint\")\n\n\t// ErrNoCodecsAvailable indicates that operation isn't possible because the MediaEngine has no codecs available\n\tErrNoCodecsAvailable = errors.New(\"operation failed no codecs are available\")\n\n\t// ErrUnsupportedCodec indicates the remote peer doesn't support the requested codec\n\tErrUnsupportedCodec = errors.New(\"unable to start track, codec is not supported by remote\")\n\n\t// ErrSenderWithNoCodecs indicates that a RTPSender was created without any codecs. To send media the MediaEngine needs at\n\t// least one configured codec.\n\tErrSenderWithNoCodecs = errors.New(\"unable to populate media section, RTPSender created with no codecs\")\n\n\t// ErrRTPSenderNewTrackHasIncorrectKind indicates that the new track is of a different kind than the previous/original\n\tErrRTPSenderNewTrackHasIncorrectKind = errors.New(\"new track must be of the same kind as previous\")\n\n\t// ErrRTPSenderNewTrackHasIncorrectEnvelope indicates that the new track has a different envelope than the previous/original\n\tErrRTPSenderNewTrackHasIncorrectEnvelope = errors.New(\"new track must have the same envelope as previous\")\n\n\t// ErrUnbindFailed indicates that a TrackLocal was not able to be unbind\n\tErrUnbindFailed = errors.New(\"failed to unbind TrackLocal from PeerConnection\")\n\n\t// ErrNoPayloaderForCodec indicates that the requested codec does not have a payloader\n\tErrNoPayloaderForCodec = errors.New(\"the requested codec does not have a payloader\")\n\n\t// ErrRegisterHeaderExtensionInvalidDirection indicates that a extension was registered with a direction besides `sendonly` or `recvonly`\n\tErrRegisterHeaderExtensionInvalidDirection = errors.New(\"a header extension must be registered as 'recvonly', 'sendonly' or both\")\n\n\t// ErrSimulcastProbeOverflow indicates that too many Simulcast probe streams are in flight and the requested SSRC was ignored\n\tErrSimulcastProbeOverflow = errors.New(\"simulcast probe limit has been reached, new SSRC has been discarded\")\n\n\terrDetachNotEnabled                 = errors.New(\"enable detaching by calling webrtc.DetachDataChannels()\")\n\terrDetachBeforeOpened               = errors.New(\"datachannel not opened yet, try calling Detach from OnOpen\")\n\terrDtlsTransportNotStarted          = errors.New(\"the DTLS transport has not started yet\")\n\terrDtlsKeyExtractionFailed          = errors.New(\"failed extracting keys from DTLS for SRTP\")\n\terrFailedToStartSRTP                = errors.New(\"failed to start SRTP\")\n\terrFailedToStartSRTCP               = errors.New(\"failed to start SRTCP\")\n\terrInvalidDTLSStart                 = errors.New(\"attempted to start DTLSTransport that is not in new state\")\n\terrNoRemoteCertificate              = errors.New(\"peer didn't provide certificate via DTLS\")\n\terrIdentityProviderNotImplemented   = errors.New(\"identity provider is not implemented\")\n\terrNoMatchingCertificateFingerprint = errors.New(\"remote certificate does not match any fingerprint\")\n\n\terrICEConnectionNotStarted        = errors.New(\"ICE connection not started\")\n\terrICECandidateTypeUnknown        = errors.New(\"unknown candidate type\")\n\terrICEInvalidConvertCandidateType = errors.New(\"cannot convert ice.CandidateType into webrtc.ICECandidateType, invalid type\")\n\terrICEAgentNotExist               = errors.New(\"ICEAgent does not exist\")\n\terrICECandiatesCoversionFailed    = errors.New(\"unable to convert ICE candidates to ICECandidates\")\n\terrICERoleUnknown                 = errors.New(\"unknown ICE Role\")\n\terrICEProtocolUnknown             = errors.New(\"unknown protocol\")\n\terrICEGathererNotStarted          = errors.New(\"gatherer not started\")\n\n\terrNetworkTypeUnknown = errors.New(\"unknown network type\")\n\n\terrSDPDoesNotMatchOffer                           = errors.New(\"new sdp does not match previous offer\")\n\terrSDPDoesNotMatchAnswer                          = errors.New(\"new sdp does not match previous answer\")\n\terrPeerConnSDPTypeInvalidValue                    = errors.New(\"provided value is not a valid enum value of type SDPType\")\n\terrPeerConnStateChangeInvalid                     = errors.New(\"invalid state change op\")\n\terrPeerConnStateChangeUnhandled                   = errors.New(\"unhandled state change op\")\n\terrPeerConnSDPTypeInvalidValueSetLocalDescription = errors.New(\"invalid SDP type supplied to SetLocalDescription()\")\n\terrPeerConnRemoteDescriptionWithoutMidValue       = errors.New(\"remoteDescription contained media section without mid value\")\n\terrPeerConnRemoteDescriptionNil                   = errors.New(\"remoteDescription has not been set yet\")\n\terrPeerConnSingleMediaSectionHasExplicitSSRC      = errors.New(\"single media section has an explicit SSRC\")\n\terrPeerConnRemoteSSRCAddTransceiver               = errors.New(\"could not add transceiver for remote SSRC\")\n\terrPeerConnSimulcastMidRTPExtensionRequired       = errors.New(\"mid RTP Extensions required for Simulcast\")\n\terrPeerConnSimulcastStreamIDRTPExtensionRequired  = errors.New(\"stream id RTP Extensions required for Simulcast\")\n\terrPeerConnSimulcastIncomingSSRCFailed            = errors.New(\"incoming SSRC failed Simulcast probing\")\n\terrPeerConnAddTransceiverFromKindOnlyAcceptsOne   = errors.New(\"AddTransceiverFromKind only accepts one RTPTransceiverInit\")\n\terrPeerConnAddTransceiverFromTrackOnlyAcceptsOne  = errors.New(\"AddTransceiverFromTrack only accepts one RTPTransceiverInit\")\n\terrPeerConnAddTransceiverFromKindSupport          = errors.New(\"AddTransceiverFromKind currently only supports recvonly\")\n\terrPeerConnAddTransceiverFromTrackSupport         = errors.New(\"AddTransceiverFromTrack currently only supports sendonly and sendrecv\")\n\terrPeerConnSetIdentityProviderNotImplemented      = errors.New(\"TODO SetIdentityProvider\")\n\terrPeerConnWriteRTCPOpenWriteStream               = errors.New(\"WriteRTCP failed to open WriteStream\")\n\terrPeerConnTranscieverMidNil                      = errors.New(\"cannot find transceiver with mid\")\n\n\terrRTPReceiverDTLSTransportNil            = errors.New(\"DTLSTransport must not be nil\")\n\terrRTPReceiverReceiveAlreadyCalled        = errors.New(\"Receive has already been called\")\n\terrRTPReceiverWithSSRCTrackStreamNotFound = errors.New(\"unable to find stream for Track with SSRC\")\n\terrRTPReceiverForRIDTrackStreamNotFound   = errors.New(\"no trackStreams found for RID\")\n\n\terrRTPSenderTrackNil             = errors.New(\"Track must not be nil\")\n\terrRTPSenderDTLSTransportNil     = errors.New(\"DTLSTransport must not be nil\")\n\terrRTPSenderSendAlreadyCalled    = errors.New(\"Send has already been called\")\n\terrRTPSenderStopped              = errors.New(\"Sender has already been stopped\")\n\terrRTPSenderTrackRemoved         = errors.New(\"Sender Track has been removed or replaced to nil\")\n\terrRTPSenderRidNil               = errors.New(\"Sender cannot add encoding as rid is empty\")\n\terrRTPSenderNoBaseEncoding       = errors.New(\"Sender cannot add encoding as there is no base track\")\n\terrRTPSenderBaseEncodingMismatch = errors.New(\"Sender cannot add encoding as provided track does not match base track\")\n\terrRTPSenderRIDCollision         = errors.New(\"Sender cannot encoding due to RID collision\")\n\terrRTPSenderNoTrackForRID        = errors.New(\"Sender does not have track for RID\")\n\n\terrRTPTransceiverCannotChangeMid        = errors.New(\"errRTPSenderTrackNil\")\n\terrRTPTransceiverSetSendingInvalidState = errors.New(\"invalid state change in RTPTransceiver.setSending\")\n\terrRTPTransceiverCodecUnsupported       = errors.New(\"unsupported codec type by this transceiver\")\n\n\terrSCTPTransportDTLS = errors.New(\"DTLS not established\")\n\n\terrSDPZeroTransceivers                 = errors.New(\"addTransceiverSDP() called with 0 transceivers\")\n\terrSDPMediaSectionMediaDataChanInvalid = errors.New(\"invalid Media Section. Media + DataChannel both enabled\")\n\terrSDPMediaSectionMultipleTrackInvalid = errors.New(\"invalid Media Section. Can not have multiple tracks in one MediaSection in UnifiedPlan\")\n\n\terrSettingEngineSetAnsweringDTLSRole = errors.New(\"SetAnsweringDTLSRole must DTLSRoleClient or DTLSRoleServer\")\n\n\terrSignalingStateCannotRollback            = errors.New(\"can't rollback from stable state\")\n\terrSignalingStateProposedTransitionInvalid = errors.New(\"invalid proposed signaling state transition\")\n\n\terrStatsICECandidateStateInvalid = errors.New(\"cannot convert to StatsICECandidatePairStateSucceeded invalid ice candidate state\")\n\n\terrInvalidICECredentialTypeString = errors.New(\"invalid ICECredentialType\")\n\terrInvalidICEServer               = errors.New(\"invalid ICEServer\")\n\n\terrICETransportNotInNew = errors.New(\"ICETransport can only be called in ICETransportStateNew\")\n\terrICETransportClosed   = errors.New(\"ICETransport closed\")\n\n\terrCertificatePEMFormatError = errors.New(\"bad Certificate PEM format\")\n\n\terrRTPTooShort = errors.New(\"not long enough to be a RTP Packet\")\n\n\terrExcessiveRetries = errors.New(\"excessive retries in CreateOffer\")\n)\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "gathering_complete_promise.go",
          "type": "blob",
          "size": 1.1630859375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"context\"\n)\n\n// GatheringCompletePromise is a Pion specific helper function that returns a channel that is closed when gathering is complete.\n// This function may be helpful in cases where you are unable to trickle your ICE Candidates.\n//\n// It is better to not use this function, and instead trickle candidates. If you use this function you will see longer connection startup times.\n// When the call is connected you will see no impact however.\nfunc GatheringCompletePromise(pc *PeerConnection) (gatherComplete <-chan struct{}) {\n\tgatheringComplete, done := context.WithCancel(context.Background())\n\n\t// It's possible to miss the GatherComplete event since setGatherCompleteHandler is an atomic operation and the\n\t// promise might have been created after the gathering is finished. Therefore, we need to check if the ICE gathering\n\t// state has changed to complete so that we don't block the caller forever.\n\tpc.setGatherCompleteHandler(func() { done() })\n\tif pc.ICEGatheringState() == ICEGatheringStateComplete {\n\t\tdone()\n\t}\n\n\treturn gatheringComplete.Done()\n}\n"
        },
        {
          "name": "gathering_complete_promise_example_test.go",
          "type": "blob",
          "size": 1.7861328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// ExampleGatheringCompletePromise demonstrates how to implement\n// non-trickle ICE in Pion, an older form of ICE that does not require an\n// asynchronous side channel between peers: negotiation is just a single\n// offer-answer exchange.  It works by explicitly waiting for all local\n// ICE candidates to have been gathered before sending an offer to the peer.\nfunc ExampleGatheringCompletePromise() {\n\t// create a peer connection\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer func() {\n\t\tcloseErr := pc.Close()\n\t\tif closeErr != nil {\n\t\t\tpanic(closeErr)\n\t\t}\n\t}()\n\n\t// add at least one transceiver to the peer connection, or nothing\n\t// interesting will happen.  This could use pc.AddTrack instead.\n\t_, err = pc.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// create a first offer that does not contain any local candidates\n\toffer, err := pc.CreateOffer(nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// gatherComplete is a channel that will be closed when\n\t// the gathering of local candidates is complete.\n\tgatherComplete := GatheringCompletePromise(pc)\n\n\t// apply the offer\n\terr = pc.SetLocalDescription(offer)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// wait for gathering of local candidates to complete\n\t<-gatherComplete\n\n\t// compute the local offer again\n\toffer2 := pc.LocalDescription()\n\n\t// this second offer contains all candidates, and may be sent to\n\t// the peer with no need for further communication.  In this\n\t// example, we simply check that it contains at least one\n\t// candidate.\n\thasCandidate := strings.Contains(offer2.SDP, \"\\na=candidate:\")\n\tif hasCandidate {\n\t\tfmt.Println(\"Ok!\")\n\t}\n\t// Output: Ok!\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.0517578125,
          "content": "module github.com/pion/webrtc/v4\n\ngo 1.20\n\nrequire (\n\tgithub.com/pion/datachannel v1.5.10\n\tgithub.com/pion/dtls/v3 v3.0.4\n\tgithub.com/pion/ice/v4 v4.0.3\n\tgithub.com/pion/interceptor v0.1.37\n\tgithub.com/pion/logging v0.2.2\n\tgithub.com/pion/randutil v0.1.0\n\tgithub.com/pion/rtcp v1.2.15\n\tgithub.com/pion/rtp v1.8.10\n\tgithub.com/pion/sctp v1.8.35\n\tgithub.com/pion/sdp/v3 v3.0.9\n\tgithub.com/pion/srtp/v3 v3.0.4\n\tgithub.com/pion/stun/v3 v3.0.0\n\tgithub.com/pion/transport/v3 v3.0.7\n\tgithub.com/sclevine/agouti v3.0.0+incompatible\n\tgithub.com/stretchr/testify v1.10.0\n\tgolang.org/x/net v0.33.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/google/uuid v1.6.0 // indirect\n\tgithub.com/onsi/ginkgo v1.16.5 // indirect\n\tgithub.com/onsi/gomega v1.17.0 // indirect\n\tgithub.com/pion/mdns/v2 v2.0.7 // indirect\n\tgithub.com/pion/turn/v4 v4.0.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/wlynxg/anet v0.0.5 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 13.236328125,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fsnotify/fsnotify v1.4.9 h1:hsms1Qyu0jgnwNXIxa+/V/PDsU6CfLf6CNO8H7IWoS4=\ngithub.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=\ngithub.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\ngithub.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=\ngithub.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\ngithub.com/onsi/ginkgo v1.16.4/go.mod h1:dX+/inL/fNMqNlz0e9LfyB9TswhZpCVdJM/Z6Vvnwo0=\ngithub.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=\ngithub.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.17.0 h1:9Luw4uT5HTjHTN8+aNcSThgH1vdXnmdJ8xIfZ4wyTRE=\ngithub.com/onsi/gomega v1.17.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=\ngithub.com/pion/datachannel v1.5.10 h1:ly0Q26K1i6ZkGf42W7D4hQYR90pZwzFOjTq5AuCKk4o=\ngithub.com/pion/datachannel v1.5.10/go.mod h1:p/jJfC9arb29W7WrxyKbepTU20CFgyx5oLo8Rs4Py/M=\ngithub.com/pion/dtls/v3 v3.0.4 h1:44CZekewMzfrn9pmGrj5BNnTMDCFwr+6sLH+cCuLM7U=\ngithub.com/pion/dtls/v3 v3.0.4/go.mod h1:R373CsjxWqNPf6MEkfdy3aSe9niZvL/JaKlGeFphtMg=\ngithub.com/pion/ice/v4 v4.0.3 h1:9s5rI1WKzF5DRqhJ+Id8bls/8PzM7mau0mj1WZb4IXE=\ngithub.com/pion/ice/v4 v4.0.3/go.mod h1:VfHy0beAZ5loDT7BmJ2LtMtC4dbawIkkkejHPRZNB3Y=\ngithub.com/pion/interceptor v0.1.37 h1:aRA8Zpab/wE7/c0O3fh1PqY0AJI3fCSEM5lRWJVorwI=\ngithub.com/pion/interceptor v0.1.37/go.mod h1:JzxbJ4umVTlZAf+/utHzNesY8tmRkM2lVmkS82TTj8Y=\ngithub.com/pion/logging v0.2.2 h1:M9+AIj/+pxNsDfAT64+MAVgJO0rsyLnoJKCqf//DoeY=\ngithub.com/pion/logging v0.2.2/go.mod h1:k0/tDVsRCX2Mb2ZEmTqNa7CWsQPc+YYCB7Q+5pahoms=\ngithub.com/pion/mdns/v2 v2.0.7 h1:c9kM8ewCgjslaAmicYMFQIde2H9/lrZpjBkN8VwoVtM=\ngithub.com/pion/mdns/v2 v2.0.7/go.mod h1:vAdSYNAT0Jy3Ru0zl2YiW3Rm/fJCwIeM0nToenfOJKA=\ngithub.com/pion/randutil v0.1.0 h1:CFG1UdESneORglEsnimhUjf33Rwjubwj6xfiOXBa3mA=\ngithub.com/pion/randutil v0.1.0/go.mod h1:XcJrSMMbbMRhASFVOlj/5hQial/Y8oH/HVo7TBZq+j8=\ngithub.com/pion/rtcp v1.2.15 h1:LZQi2JbdipLOj4eBjK4wlVoQWfrZbh3Q6eHtWtJBZBo=\ngithub.com/pion/rtcp v1.2.15/go.mod h1:jlGuAjHMEXwMUHK78RgX0UmEJFV4zUKOFHR7OP+D3D0=\ngithub.com/pion/rtp v1.8.10 h1:puphjdbjPB+L+NFaVuZ5h6bt1g5q4kFIoI+r5q/g0CU=\ngithub.com/pion/rtp v1.8.10/go.mod h1:8uMBJj32Pa1wwx8Fuv/AsFhn8jsgw+3rUC2PfoBZ8p4=\ngithub.com/pion/sctp v1.8.35 h1:qwtKvNK1Wc5tHMIYgTDJhfZk7vATGVHhXbUDfHbYwzA=\ngithub.com/pion/sctp v1.8.35/go.mod h1:EcXP8zCYVTRy3W9xtOF7wJm1L1aXfKRQzaM33SjQlzg=\ngithub.com/pion/sdp/v3 v3.0.9 h1:pX++dCHoHUwq43kuwf3PyJfHlwIj4hXA7Vrifiq0IJY=\ngithub.com/pion/sdp/v3 v3.0.9/go.mod h1:B5xmvENq5IXJimIO4zfp6LAe1fD9N+kFv+V/1lOdz8M=\ngithub.com/pion/srtp/v3 v3.0.4 h1:2Z6vDVxzrX3UHEgrUyIGM4rRouoC7v+NiF1IHtp9B5M=\ngithub.com/pion/srtp/v3 v3.0.4/go.mod h1:1Jx3FwDoxpRaTh1oRV8A/6G1BnFL+QI82eK4ms8EEJQ=\ngithub.com/pion/stun/v3 v3.0.0 h1:4h1gwhWLWuZWOJIJR9s2ferRO+W3zA/b6ijOI6mKzUw=\ngithub.com/pion/stun/v3 v3.0.0/go.mod h1:HvCN8txt8mwi4FBvS3EmDghW6aQJ24T+y+1TKjB5jyU=\ngithub.com/pion/transport/v3 v3.0.7 h1:iRbMH05BzSNwhILHoBoAPxoB9xQgOaJk+591KC9P1o0=\ngithub.com/pion/transport/v3 v3.0.7/go.mod h1:YleKiTZ4vqNxVwh77Z0zytYi7rXHl7j6uPLGhhz9rwo=\ngithub.com/pion/turn/v4 v4.0.0 h1:qxplo3Rxa9Yg1xXDxxH8xaqcyGUtbHYw4QSCvmFWvhM=\ngithub.com/pion/turn/v4 v4.0.0/go.mod h1:MuPDkm15nYSklKpN8vWJ9W2M0PlyQZqYt1McGuxG7mA=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/sclevine/agouti v3.0.0+incompatible h1:8IBJS6PWz3uTlMP3YBIR5f+KAldcGuOeFkFbUWfBgK4=\ngithub.com/sclevine/agouti v3.0.0+incompatible/go.mod h1:b4WX9W9L1sfQKXeJf1mUTLZKJ48R1S7H23Ji7oFO5Bw=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/wlynxg/anet v0.0.5 h1:J3VJGi1gvo0JwZ/P1/Yc/8p63SoW98B5dHkYDmpgvvU=\ngithub.com/wlynxg/anet v0.0.5/go.mod h1:eay5PRQr7fIVAMbTbchTnO9gG65Hg/uYGdc7mguHxoA=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210428140749-89ef3d95e781/go.mod h1:OJAsFXCWl8Ukc7SiCT/9KSuxbyM7479/AVlXFRxuMCk=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "ice_go.go",
          "type": "blob",
          "size": 0.4384765625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\n// NewICETransport creates a new NewICETransport.\n// This constructor is part of the ORTC API. It is not\n// meant to be used together with the basic WebRTC API.\nfunc (api *API) NewICETransport(gatherer *ICEGatherer) *ICETransport {\n\treturn NewICETransport(gatherer, api.settingEngine.LoggerFactory)\n}\n"
        },
        {
          "name": "icecandidate.go",
          "type": "blob",
          "size": 4.79296875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pion/ice/v4\"\n)\n\n// ICECandidate represents a ice candidate\ntype ICECandidate struct {\n\tstatsID        string\n\tFoundation     string           `json:\"foundation\"`\n\tPriority       uint32           `json:\"priority\"`\n\tAddress        string           `json:\"address\"`\n\tProtocol       ICEProtocol      `json:\"protocol\"`\n\tPort           uint16           `json:\"port\"`\n\tTyp            ICECandidateType `json:\"type\"`\n\tComponent      uint16           `json:\"component\"`\n\tRelatedAddress string           `json:\"relatedAddress\"`\n\tRelatedPort    uint16           `json:\"relatedPort\"`\n\tTCPType        string           `json:\"tcpType\"`\n\tSDPMid         string           `json:\"sdpMid\"`\n\tSDPMLineIndex  uint16           `json:\"sdpMLineIndex\"`\n}\n\n// Conversion for package ice\n\nfunc newICECandidatesFromICE(iceCandidates []ice.Candidate, sdpMid string, sdpMLineIndex uint16) ([]ICECandidate, error) {\n\tcandidates := []ICECandidate{}\n\n\tfor _, i := range iceCandidates {\n\t\tc, err := newICECandidateFromICE(i, sdpMid, sdpMLineIndex)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcandidates = append(candidates, c)\n\t}\n\n\treturn candidates, nil\n}\n\nfunc newICECandidateFromICE(i ice.Candidate, sdpMid string, sdpMLineIndex uint16) (ICECandidate, error) {\n\ttyp, err := convertTypeFromICE(i.Type())\n\tif err != nil {\n\t\treturn ICECandidate{}, err\n\t}\n\tprotocol, err := NewICEProtocol(i.NetworkType().NetworkShort())\n\tif err != nil {\n\t\treturn ICECandidate{}, err\n\t}\n\n\tc := ICECandidate{\n\t\tstatsID:       i.ID(),\n\t\tFoundation:    i.Foundation(),\n\t\tPriority:      i.Priority(),\n\t\tAddress:       i.Address(),\n\t\tProtocol:      protocol,\n\t\tPort:          uint16(i.Port()),\n\t\tComponent:     i.Component(),\n\t\tTyp:           typ,\n\t\tTCPType:       i.TCPType().String(),\n\t\tSDPMid:        sdpMid,\n\t\tSDPMLineIndex: sdpMLineIndex,\n\t}\n\n\tif i.RelatedAddress() != nil {\n\t\tc.RelatedAddress = i.RelatedAddress().Address\n\t\tc.RelatedPort = uint16(i.RelatedAddress().Port)\n\t}\n\n\treturn c, nil\n}\n\nfunc (c ICECandidate) toICE() (ice.Candidate, error) {\n\tcandidateID := c.statsID\n\tswitch c.Typ {\n\tcase ICECandidateTypeHost:\n\t\tconfig := ice.CandidateHostConfig{\n\t\t\tCandidateID: candidateID,\n\t\t\tNetwork:     c.Protocol.String(),\n\t\t\tAddress:     c.Address,\n\t\t\tPort:        int(c.Port),\n\t\t\tComponent:   c.Component,\n\t\t\tTCPType:     ice.NewTCPType(c.TCPType),\n\t\t\tFoundation:  c.Foundation,\n\t\t\tPriority:    c.Priority,\n\t\t}\n\t\treturn ice.NewCandidateHost(&config)\n\tcase ICECandidateTypeSrflx:\n\t\tconfig := ice.CandidateServerReflexiveConfig{\n\t\t\tCandidateID: candidateID,\n\t\t\tNetwork:     c.Protocol.String(),\n\t\t\tAddress:     c.Address,\n\t\t\tPort:        int(c.Port),\n\t\t\tComponent:   c.Component,\n\t\t\tFoundation:  c.Foundation,\n\t\t\tPriority:    c.Priority,\n\t\t\tRelAddr:     c.RelatedAddress,\n\t\t\tRelPort:     int(c.RelatedPort),\n\t\t}\n\t\treturn ice.NewCandidateServerReflexive(&config)\n\tcase ICECandidateTypePrflx:\n\t\tconfig := ice.CandidatePeerReflexiveConfig{\n\t\t\tCandidateID: candidateID,\n\t\t\tNetwork:     c.Protocol.String(),\n\t\t\tAddress:     c.Address,\n\t\t\tPort:        int(c.Port),\n\t\t\tComponent:   c.Component,\n\t\t\tFoundation:  c.Foundation,\n\t\t\tPriority:    c.Priority,\n\t\t\tRelAddr:     c.RelatedAddress,\n\t\t\tRelPort:     int(c.RelatedPort),\n\t\t}\n\t\treturn ice.NewCandidatePeerReflexive(&config)\n\tcase ICECandidateTypeRelay:\n\t\tconfig := ice.CandidateRelayConfig{\n\t\t\tCandidateID: candidateID,\n\t\t\tNetwork:     c.Protocol.String(),\n\t\t\tAddress:     c.Address,\n\t\t\tPort:        int(c.Port),\n\t\t\tComponent:   c.Component,\n\t\t\tFoundation:  c.Foundation,\n\t\t\tPriority:    c.Priority,\n\t\t\tRelAddr:     c.RelatedAddress,\n\t\t\tRelPort:     int(c.RelatedPort),\n\t\t}\n\t\treturn ice.NewCandidateRelay(&config)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"%w: %s\", errICECandidateTypeUnknown, c.Typ)\n\t}\n}\n\nfunc convertTypeFromICE(t ice.CandidateType) (ICECandidateType, error) {\n\tswitch t {\n\tcase ice.CandidateTypeHost:\n\t\treturn ICECandidateTypeHost, nil\n\tcase ice.CandidateTypeServerReflexive:\n\t\treturn ICECandidateTypeSrflx, nil\n\tcase ice.CandidateTypePeerReflexive:\n\t\treturn ICECandidateTypePrflx, nil\n\tcase ice.CandidateTypeRelay:\n\t\treturn ICECandidateTypeRelay, nil\n\tdefault:\n\t\treturn ICECandidateType(t), fmt.Errorf(\"%w: %s\", errICECandidateTypeUnknown, t)\n\t}\n}\n\nfunc (c ICECandidate) String() string {\n\tic, err := c.toICE()\n\tif err != nil {\n\t\treturn fmt.Sprintf(\"%#v failed to convert to ICE: %s\", c, err)\n\t}\n\treturn ic.String()\n}\n\n// ToJSON returns an ICECandidateInit\n// as indicated by the spec https://w3c.github.io/webrtc-pc/#dom-rtcicecandidate-tojson\nfunc (c ICECandidate) ToJSON() ICECandidateInit {\n\tcandidateStr := \"\"\n\n\tcandidate, err := c.toICE()\n\tif err == nil {\n\t\tcandidateStr = candidate.Marshal()\n\t}\n\n\treturn ICECandidateInit{\n\t\tCandidate:     fmt.Sprintf(\"candidate:%s\", candidateStr),\n\t\tSDPMid:        &c.SDPMid,\n\t\tSDPMLineIndex: &c.SDPMLineIndex,\n\t}\n}\n"
        },
        {
          "name": "icecandidate_test.go",
          "type": "blob",
          "size": 6.1640625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICECandidate_Convert(t *testing.T) {\n\ttestCases := []struct {\n\t\tnative ICECandidate\n\n\t\texpectedType           ice.CandidateType\n\t\texpectedNetwork        string\n\t\texpectedAddress        string\n\t\texpectedPort           int\n\t\texpectedComponent      uint16\n\t\texpectedRelatedAddress *ice.CandidateRelatedAddress\n\t}{\n\t\t{\n\t\t\tICECandidate{\n\t\t\t\tFoundation: \"foundation\",\n\t\t\t\tPriority:   128,\n\t\t\t\tAddress:    \"1.0.0.1\",\n\t\t\t\tProtocol:   ICEProtocolUDP,\n\t\t\t\tPort:       1234,\n\t\t\t\tTyp:        ICECandidateTypeHost,\n\t\t\t\tComponent:  1,\n\t\t\t},\n\n\t\t\tice.CandidateTypeHost,\n\t\t\t\"udp\",\n\t\t\t\"1.0.0.1\",\n\t\t\t1234,\n\t\t\t1,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\tICECandidate{\n\t\t\t\tFoundation:     \"foundation\",\n\t\t\t\tPriority:       128,\n\t\t\t\tAddress:        \"::1\",\n\t\t\t\tProtocol:       ICEProtocolUDP,\n\t\t\t\tPort:           1234,\n\t\t\t\tTyp:            ICECandidateTypeSrflx,\n\t\t\t\tComponent:      1,\n\t\t\t\tRelatedAddress: \"1.0.0.1\",\n\t\t\t\tRelatedPort:    4321,\n\t\t\t},\n\n\t\t\tice.CandidateTypeServerReflexive,\n\t\t\t\"udp\",\n\t\t\t\"::1\",\n\t\t\t1234,\n\t\t\t1,\n\t\t\t&ice.CandidateRelatedAddress{\n\t\t\t\tAddress: \"1.0.0.1\",\n\t\t\t\tPort:    4321,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tICECandidate{\n\t\t\t\tFoundation:     \"foundation\",\n\t\t\t\tPriority:       128,\n\t\t\t\tAddress:        \"::1\",\n\t\t\t\tProtocol:       ICEProtocolUDP,\n\t\t\t\tPort:           1234,\n\t\t\t\tTyp:            ICECandidateTypePrflx,\n\t\t\t\tComponent:      1,\n\t\t\t\tRelatedAddress: \"1.0.0.1\",\n\t\t\t\tRelatedPort:    4321,\n\t\t\t},\n\n\t\t\tice.CandidateTypePeerReflexive,\n\t\t\t\"udp\",\n\t\t\t\"::1\",\n\t\t\t1234,\n\t\t\t1,\n\t\t\t&ice.CandidateRelatedAddress{\n\t\t\t\tAddress: \"1.0.0.1\",\n\t\t\t\tPort:    4321,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tvar expectedICE ice.Candidate\n\t\tvar err error\n\t\tswitch testCase.expectedType { // nolint:exhaustive\n\t\tcase ice.CandidateTypeHost:\n\t\t\tconfig := ice.CandidateHostConfig{\n\t\t\t\tNetwork:    testCase.expectedNetwork,\n\t\t\t\tAddress:    testCase.expectedAddress,\n\t\t\t\tPort:       testCase.expectedPort,\n\t\t\t\tComponent:  testCase.expectedComponent,\n\t\t\t\tFoundation: \"foundation\",\n\t\t\t\tPriority:   128,\n\t\t\t}\n\t\t\texpectedICE, err = ice.NewCandidateHost(&config)\n\t\tcase ice.CandidateTypeServerReflexive:\n\t\t\tconfig := ice.CandidateServerReflexiveConfig{\n\t\t\t\tNetwork:    testCase.expectedNetwork,\n\t\t\t\tAddress:    testCase.expectedAddress,\n\t\t\t\tPort:       testCase.expectedPort,\n\t\t\t\tComponent:  testCase.expectedComponent,\n\t\t\t\tFoundation: \"foundation\",\n\t\t\t\tPriority:   128,\n\t\t\t\tRelAddr:    testCase.expectedRelatedAddress.Address,\n\t\t\t\tRelPort:    testCase.expectedRelatedAddress.Port,\n\t\t\t}\n\t\t\texpectedICE, err = ice.NewCandidateServerReflexive(&config)\n\t\tcase ice.CandidateTypePeerReflexive:\n\t\t\tconfig := ice.CandidatePeerReflexiveConfig{\n\t\t\t\tNetwork:    testCase.expectedNetwork,\n\t\t\t\tAddress:    testCase.expectedAddress,\n\t\t\t\tPort:       testCase.expectedPort,\n\t\t\t\tComponent:  testCase.expectedComponent,\n\t\t\t\tFoundation: \"foundation\",\n\t\t\t\tPriority:   128,\n\t\t\t\tRelAddr:    testCase.expectedRelatedAddress.Address,\n\t\t\t\tRelPort:    testCase.expectedRelatedAddress.Port,\n\t\t\t}\n\t\t\texpectedICE, err = ice.NewCandidatePeerReflexive(&config)\n\t\t}\n\t\tassert.NoError(t, err)\n\n\t\t// first copy the candidate ID so it matches the new one\n\t\ttestCase.native.statsID = expectedICE.ID()\n\t\tactualICE, err := testCase.native.toICE()\n\t\tassert.NoError(t, err)\n\n\t\tassert.Equal(t, expectedICE, actualICE, \"testCase: %d ice not equal %v\", i, actualICE)\n\t}\n}\n\nfunc TestConvertTypeFromICE(t *testing.T) {\n\tt.Run(\"host\", func(t *testing.T) {\n\t\tct, err := convertTypeFromICE(ice.CandidateTypeHost)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"failed coverting ice.CandidateTypeHost\")\n\t\t}\n\t\tif ct != ICECandidateTypeHost {\n\t\t\tt.Fatal(\"should be converted to ICECandidateTypeHost\")\n\t\t}\n\t})\n\tt.Run(\"srflx\", func(t *testing.T) {\n\t\tct, err := convertTypeFromICE(ice.CandidateTypeServerReflexive)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"failed coverting ice.CandidateTypeServerReflexive\")\n\t\t}\n\t\tif ct != ICECandidateTypeSrflx {\n\t\t\tt.Fatal(\"should be converted to ICECandidateTypeSrflx\")\n\t\t}\n\t})\n\tt.Run(\"prflx\", func(t *testing.T) {\n\t\tct, err := convertTypeFromICE(ice.CandidateTypePeerReflexive)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"failed coverting ice.CandidateTypePeerReflexive\")\n\t\t}\n\t\tif ct != ICECandidateTypePrflx {\n\t\t\tt.Fatal(\"should be converted to ICECandidateTypePrflx\")\n\t\t}\n\t})\n}\n\nfunc TestNewIdentifiedICECandidateFromICE(t *testing.T) {\n\tconfig := ice.CandidateHostConfig{\n\t\tNetwork:    \"udp\",\n\t\tAddress:    \"::1\",\n\t\tPort:       1234,\n\t\tComponent:  1,\n\t\tFoundation: \"foundation\",\n\t\tPriority:   128,\n\t}\n\tice, err := ice.NewCandidateHost(&config)\n\tassert.NoError(t, err)\n\n\tct, err := newICECandidateFromICE(ice, \"1\", 2)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, \"1\", ct.SDPMid)\n\tassert.Equal(t, uint16(2), ct.SDPMLineIndex)\n}\n\nfunc TestNewIdentifiedICECandidatesFromICE(t *testing.T) {\n\tic, err := ice.NewCandidateHost(&ice.CandidateHostConfig{\n\t\tNetwork:    \"udp\",\n\t\tAddress:    \"::1\",\n\t\tPort:       1234,\n\t\tComponent:  1,\n\t\tFoundation: \"foundation\",\n\t\tPriority:   128,\n\t})\n\n\tassert.NoError(t, err)\n\n\tcandidates := []ice.Candidate{ic, ic, ic}\n\n\tsdpMid := \"1\"\n\tsdpMLineIndex := uint16(2)\n\n\tresults, err := newICECandidatesFromICE(candidates, sdpMid, sdpMLineIndex)\n\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, 3, len(results))\n\n\tfor _, result := range results {\n\t\tassert.Equal(t, sdpMid, result.SDPMid)\n\t\tassert.Equal(t, sdpMLineIndex, result.SDPMLineIndex)\n\t}\n}\n\nfunc TestICECandidate_ToJSON(t *testing.T) {\n\tcandidate := ICECandidate{\n\t\tFoundation: \"foundation\",\n\t\tPriority:   128,\n\t\tAddress:    \"1.0.0.1\",\n\t\tProtocol:   ICEProtocolUDP,\n\t\tPort:       1234,\n\t\tTyp:        ICECandidateTypeHost,\n\t\tComponent:  1,\n\t}\n\n\tcandidateInit := candidate.ToJSON()\n\n\tassert.Equal(t, uint16(0), *candidateInit.SDPMLineIndex)\n\tassert.Equal(t, \"candidate:foundation 1 udp 128 1.0.0.1 1234 typ host\", candidateInit.Candidate)\n}\n\nfunc TestICECandidateZeroSDPid(t *testing.T) {\n\tcandidate := ICECandidate{}\n\n\tassert.Equal(t, candidate.SDPMid, \"\")\n\tassert.Equal(t, candidate.SDPMLineIndex, uint16(0))\n}\n\nfunc TestICECandidateSDPMid_ToJSON(t *testing.T) {\n\tcandidate := ICECandidate{}\n\n\tcandidate.SDPMid = \"0\"\n\tcandidate.SDPMLineIndex = 1\n\n\tassert.Equal(t, candidate.SDPMid, \"0\")\n\tassert.Equal(t, candidate.SDPMLineIndex, uint16(1))\n}\n"
        },
        {
          "name": "icecandidateinit.go",
          "type": "blob",
          "size": 0.3857421875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// ICECandidateInit is used to serialize ice candidates\ntype ICECandidateInit struct {\n\tCandidate        string  `json:\"candidate\"`\n\tSDPMid           *string `json:\"sdpMid\"`\n\tSDPMLineIndex    *uint16 `json:\"sdpMLineIndex\"`\n\tUsernameFragment *string `json:\"usernameFragment\"`\n}\n"
        },
        {
          "name": "icecandidateinit_test.go",
          "type": "blob",
          "size": 1.306640625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICECandidateInit_Serialization(t *testing.T) {\n\ttt := []struct {\n\t\tcandidate  ICECandidateInit\n\t\tserialized string\n\t}{\n\t\t{ICECandidateInit{\n\t\t\tCandidate:        \"candidate:abc123\",\n\t\t\tSDPMid:           refString(\"0\"),\n\t\t\tSDPMLineIndex:    refUint16(0),\n\t\t\tUsernameFragment: refString(\"def\"),\n\t\t}, `{\"candidate\":\"candidate:abc123\",\"sdpMid\":\"0\",\"sdpMLineIndex\":0,\"usernameFragment\":\"def\"}`},\n\t\t{ICECandidateInit{\n\t\t\tCandidate: \"candidate:abc123\",\n\t\t}, `{\"candidate\":\"candidate:abc123\",\"sdpMid\":null,\"sdpMLineIndex\":null,\"usernameFragment\":null}`},\n\t}\n\n\tfor i, tc := range tt {\n\t\tb, err := json.Marshal(tc.candidate)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to marshal %d: %v\", i, err)\n\t\t}\n\t\tactualSerialized := string(b)\n\t\tif actualSerialized != tc.serialized {\n\t\t\tt.Errorf(\"%d expected %s got %s\", i, tc.serialized, actualSerialized)\n\t\t}\n\n\t\tvar actual ICECandidateInit\n\t\terr = json.Unmarshal(b, &actual)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to unmarshal %d: %v\", i, err)\n\t\t}\n\n\t\tassert.Equal(t, tc.candidate, actual, \"should match\")\n\t}\n}\n\nfunc refString(s string) *string {\n\treturn &s\n}\n\nfunc refUint16(i uint16) *uint16 {\n\treturn &i\n}\n"
        },
        {
          "name": "icecandidatepair.go",
          "type": "blob",
          "size": 0.8408203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport \"fmt\"\n\n// ICECandidatePair represents an ICE Candidate pair\ntype ICECandidatePair struct {\n\tstatsID string\n\tLocal   *ICECandidate\n\tRemote  *ICECandidate\n}\n\nfunc newICECandidatePairStatsID(localID, remoteID string) string {\n\treturn fmt.Sprintf(\"%s-%s\", localID, remoteID)\n}\n\nfunc (p *ICECandidatePair) String() string {\n\treturn fmt.Sprintf(\"(local) %s <-> (remote) %s\", p.Local, p.Remote)\n}\n\n// NewICECandidatePair returns an initialized *ICECandidatePair\n// for the given pair of ICECandidate instances\nfunc NewICECandidatePair(local, remote *ICECandidate) *ICECandidatePair {\n\tstatsID := newICECandidatePairStatsID(local.statsID, remote.statsID)\n\treturn &ICECandidatePair{\n\t\tstatsID: statsID,\n\t\tLocal:   local,\n\t\tRemote:  remote,\n\t}\n}\n"
        },
        {
          "name": "icecandidatetype.go",
          "type": "blob",
          "size": 3.5185546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pion/ice/v4\"\n)\n\n// ICECandidateType represents the type of the ICE candidate used.\ntype ICECandidateType int\n\nconst (\n\t// ICECandidateTypeUnknown is the enum's zero-value\n\tICECandidateTypeUnknown ICECandidateType = iota\n\n\t// ICECandidateTypeHost indicates that the candidate is of Host type as\n\t// described in https://tools.ietf.org/html/rfc8445#section-5.1.1.1. A\n\t// candidate obtained by binding to a specific port from an IP address on\n\t// the host. This includes IP addresses on physical interfaces and logical\n\t// ones, such as ones obtained through VPNs.\n\tICECandidateTypeHost\n\n\t// ICECandidateTypeSrflx indicates the candidate is of Server\n\t// Reflexive type as described\n\t// https://tools.ietf.org/html/rfc8445#section-5.1.1.2. A candidate type\n\t// whose IP address and port are a binding allocated by a NAT for an ICE\n\t// agent after it sends a packet through the NAT to a server, such as a\n\t// STUN server.\n\tICECandidateTypeSrflx\n\n\t// ICECandidateTypePrflx indicates that the candidate is of Peer\n\t// Reflexive type. A candidate type whose IP address and port are a binding\n\t// allocated by a NAT for an ICE agent after it sends a packet through the\n\t// NAT to its peer.\n\tICECandidateTypePrflx\n\n\t// ICECandidateTypeRelay indicates the candidate is of Relay type as\n\t// described in https://tools.ietf.org/html/rfc8445#section-5.1.1.2. A\n\t// candidate type obtained from a relay server, such as a TURN server.\n\tICECandidateTypeRelay\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeCandidateTypeHostStr  = \"host\"\n\ticeCandidateTypeSrflxStr = \"srflx\"\n\ticeCandidateTypePrflxStr = \"prflx\"\n\ticeCandidateTypeRelayStr = \"relay\"\n)\n\n// NewICECandidateType takes a string and converts it into ICECandidateType\nfunc NewICECandidateType(raw string) (ICECandidateType, error) {\n\tswitch raw {\n\tcase iceCandidateTypeHostStr:\n\t\treturn ICECandidateTypeHost, nil\n\tcase iceCandidateTypeSrflxStr:\n\t\treturn ICECandidateTypeSrflx, nil\n\tcase iceCandidateTypePrflxStr:\n\t\treturn ICECandidateTypePrflx, nil\n\tcase iceCandidateTypeRelayStr:\n\t\treturn ICECandidateTypeRelay, nil\n\tdefault:\n\t\treturn ICECandidateTypeUnknown, fmt.Errorf(\"%w: %s\", errICECandidateTypeUnknown, raw)\n\t}\n}\n\nfunc (t ICECandidateType) String() string {\n\tswitch t {\n\tcase ICECandidateTypeHost:\n\t\treturn iceCandidateTypeHostStr\n\tcase ICECandidateTypeSrflx:\n\t\treturn iceCandidateTypeSrflxStr\n\tcase ICECandidateTypePrflx:\n\t\treturn iceCandidateTypePrflxStr\n\tcase ICECandidateTypeRelay:\n\t\treturn iceCandidateTypeRelayStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\nfunc getCandidateType(candidateType ice.CandidateType) (ICECandidateType, error) {\n\tswitch candidateType {\n\tcase ice.CandidateTypeHost:\n\t\treturn ICECandidateTypeHost, nil\n\tcase ice.CandidateTypeServerReflexive:\n\t\treturn ICECandidateTypeSrflx, nil\n\tcase ice.CandidateTypePeerReflexive:\n\t\treturn ICECandidateTypePrflx, nil\n\tcase ice.CandidateTypeRelay:\n\t\treturn ICECandidateTypeRelay, nil\n\tdefault:\n\t\t// NOTE: this should never happen[tm]\n\t\terr := fmt.Errorf(\"%w: %s\", errICEInvalidConvertCandidateType, candidateType.String())\n\t\treturn ICECandidateTypeUnknown, err\n\t}\n}\n\n// MarshalText implements the encoding.TextMarshaler interface.\nfunc (t ICECandidateType) MarshalText() ([]byte, error) {\n\treturn []byte(t.String()), nil\n}\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface.\nfunc (t *ICECandidateType) UnmarshalText(b []byte) error {\n\tvar err error\n\t*t, err = NewICECandidateType(string(b))\n\treturn err\n}\n"
        },
        {
          "name": "icecandidatetype_test.go",
          "type": "blob",
          "size": 1.27734375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICECandidateType(t *testing.T) {\n\ttestCases := []struct {\n\t\ttypeString   string\n\t\tshouldFail   bool\n\t\texpectedType ICECandidateType\n\t}{\n\t\t{ErrUnknownType.Error(), true, ICECandidateTypeUnknown},\n\t\t{\"host\", false, ICECandidateTypeHost},\n\t\t{\"srflx\", false, ICECandidateTypeSrflx},\n\t\t{\"prflx\", false, ICECandidateTypePrflx},\n\t\t{\"relay\", false, ICECandidateTypeRelay},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactual, err := NewICECandidateType(testCase.typeString)\n\t\tif (err != nil) != testCase.shouldFail {\n\t\t\tt.Error(err)\n\t\t}\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedType,\n\t\t\tactual,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICECandidateType_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tcType          ICECandidateType\n\t\texpectedString string\n\t}{\n\t\t{ICECandidateTypeUnknown, ErrUnknownType.Error()},\n\t\t{ICECandidateTypeHost, \"host\"},\n\t\t{ICECandidateTypeSrflx, \"srflx\"},\n\t\t{ICECandidateTypePrflx, \"prflx\"},\n\t\t{ICECandidateTypeRelay, \"relay\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.cType.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "icecomponent.go",
          "type": "blob",
          "size": 1.41796875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// ICEComponent describes if the ice transport is used for RTP\n// (or RTCP multiplexing).\ntype ICEComponent int\n\nconst (\n\t// ICEComponentUnknown is the enum's zero-value\n\tICEComponentUnknown ICEComponent = iota\n\n\t// ICEComponentRTP indicates that the ICE Transport is used for RTP (or\n\t// RTCP multiplexing), as defined in\n\t// https://tools.ietf.org/html/rfc5245#section-4.1.1.1. Protocols\n\t// multiplexed with RTP (e.g. data channel) share its component ID. This\n\t// represents the component-id value 1 when encoded in candidate-attribute.\n\tICEComponentRTP\n\n\t// ICEComponentRTCP indicates that the ICE Transport is used for RTCP as\n\t// defined by https://tools.ietf.org/html/rfc5245#section-4.1.1.1. This\n\t// represents the component-id value 2 when encoded in candidate-attribute.\n\tICEComponentRTCP\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeComponentRTPStr  = \"rtp\"\n\ticeComponentRTCPStr = \"rtcp\"\n)\n\nfunc newICEComponent(raw string) ICEComponent {\n\tswitch raw {\n\tcase iceComponentRTPStr:\n\t\treturn ICEComponentRTP\n\tcase iceComponentRTCPStr:\n\t\treturn ICEComponentRTCP\n\tdefault:\n\t\treturn ICEComponentUnknown\n\t}\n}\n\nfunc (t ICEComponent) String() string {\n\tswitch t {\n\tcase ICEComponentRTP:\n\t\treturn iceComponentRTPStr\n\tcase ICEComponentRTCP:\n\t\treturn iceComponentRTCPStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n"
        },
        {
          "name": "icecomponent_test.go",
          "type": "blob",
          "size": 0.9677734375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICEComponent(t *testing.T) {\n\ttestCases := []struct {\n\t\tcomponentString   string\n\t\texpectedComponent ICEComponent\n\t}{\n\t\t{ErrUnknownType.Error(), ICEComponentUnknown},\n\t\t{\"rtp\", ICEComponentRTP},\n\t\t{\"rtcp\", ICEComponentRTCP},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\tnewICEComponent(testCase.componentString),\n\t\t\ttestCase.expectedComponent,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICEComponent_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          ICEComponent\n\t\texpectedString string\n\t}{\n\t\t{ICEComponentUnknown, ErrUnknownType.Error()},\n\t\t{ICEComponentRTP, \"rtp\"},\n\t\t{ICEComponentRTCP, \"rtcp\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.state.String(),\n\t\t\ttestCase.expectedString,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "iceconnectionstate.go",
          "type": "blob",
          "size": 3.28125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// ICEConnectionState indicates signaling state of the ICE Connection.\ntype ICEConnectionState int\n\nconst (\n\t// ICEConnectionStateUnknown is the enum's zero-value\n\tICEConnectionStateUnknown ICEConnectionState = iota\n\n\t// ICEConnectionStateNew indicates that any of the ICETransports are\n\t// in the \"new\" state and none of them are in the \"checking\", \"disconnected\"\n\t// or \"failed\" state, or all ICETransports are in the \"closed\" state, or\n\t// there are no transports.\n\tICEConnectionStateNew\n\n\t// ICEConnectionStateChecking indicates that any of the ICETransports\n\t// are in the \"checking\" state and none of them are in the \"disconnected\"\n\t// or \"failed\" state.\n\tICEConnectionStateChecking\n\n\t// ICEConnectionStateConnected indicates that all ICETransports are\n\t// in the \"connected\", \"completed\" or \"closed\" state and at least one of\n\t// them is in the \"connected\" state.\n\tICEConnectionStateConnected\n\n\t// ICEConnectionStateCompleted indicates that all ICETransports are\n\t// in the \"completed\" or \"closed\" state and at least one of them is in the\n\t// \"completed\" state.\n\tICEConnectionStateCompleted\n\n\t// ICEConnectionStateDisconnected indicates that any of the\n\t// ICETransports are in the \"disconnected\" state and none of them are\n\t// in the \"failed\" state.\n\tICEConnectionStateDisconnected\n\n\t// ICEConnectionStateFailed indicates that any of the ICETransports\n\t// are in the \"failed\" state.\n\tICEConnectionStateFailed\n\n\t// ICEConnectionStateClosed indicates that the PeerConnection's\n\t// isClosed is true.\n\tICEConnectionStateClosed\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeConnectionStateNewStr          = \"new\"\n\ticeConnectionStateCheckingStr     = \"checking\"\n\ticeConnectionStateConnectedStr    = \"connected\"\n\ticeConnectionStateCompletedStr    = \"completed\"\n\ticeConnectionStateDisconnectedStr = \"disconnected\"\n\ticeConnectionStateFailedStr       = \"failed\"\n\ticeConnectionStateClosedStr       = \"closed\"\n)\n\n// NewICEConnectionState takes a string and converts it to ICEConnectionState\nfunc NewICEConnectionState(raw string) ICEConnectionState {\n\tswitch raw {\n\tcase iceConnectionStateNewStr:\n\t\treturn ICEConnectionStateNew\n\tcase iceConnectionStateCheckingStr:\n\t\treturn ICEConnectionStateChecking\n\tcase iceConnectionStateConnectedStr:\n\t\treturn ICEConnectionStateConnected\n\tcase iceConnectionStateCompletedStr:\n\t\treturn ICEConnectionStateCompleted\n\tcase iceConnectionStateDisconnectedStr:\n\t\treturn ICEConnectionStateDisconnected\n\tcase iceConnectionStateFailedStr:\n\t\treturn ICEConnectionStateFailed\n\tcase iceConnectionStateClosedStr:\n\t\treturn ICEConnectionStateClosed\n\tdefault:\n\t\treturn ICEConnectionStateUnknown\n\t}\n}\n\nfunc (c ICEConnectionState) String() string {\n\tswitch c {\n\tcase ICEConnectionStateNew:\n\t\treturn iceConnectionStateNewStr\n\tcase ICEConnectionStateChecking:\n\t\treturn iceConnectionStateCheckingStr\n\tcase ICEConnectionStateConnected:\n\t\treturn iceConnectionStateConnectedStr\n\tcase ICEConnectionStateCompleted:\n\t\treturn iceConnectionStateCompletedStr\n\tcase ICEConnectionStateDisconnected:\n\t\treturn iceConnectionStateDisconnectedStr\n\tcase ICEConnectionStateFailed:\n\t\treturn iceConnectionStateFailedStr\n\tcase ICEConnectionStateClosed:\n\t\treturn iceConnectionStateClosedStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n"
        },
        {
          "name": "iceconnectionstate_test.go",
          "type": "blob",
          "size": 1.47265625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewICEConnectionState(t *testing.T) {\n\ttestCases := []struct {\n\t\tstateString   string\n\t\texpectedState ICEConnectionState\n\t}{\n\t\t{ErrUnknownType.Error(), ICEConnectionStateUnknown},\n\t\t{\"new\", ICEConnectionStateNew},\n\t\t{\"checking\", ICEConnectionStateChecking},\n\t\t{\"connected\", ICEConnectionStateConnected},\n\t\t{\"completed\", ICEConnectionStateCompleted},\n\t\t{\"disconnected\", ICEConnectionStateDisconnected},\n\t\t{\"failed\", ICEConnectionStateFailed},\n\t\t{\"closed\", ICEConnectionStateClosed},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedState,\n\t\t\tNewICEConnectionState(testCase.stateString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICEConnectionState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          ICEConnectionState\n\t\texpectedString string\n\t}{\n\t\t{ICEConnectionStateUnknown, ErrUnknownType.Error()},\n\t\t{ICEConnectionStateNew, \"new\"},\n\t\t{ICEConnectionStateChecking, \"checking\"},\n\t\t{ICEConnectionStateConnected, \"connected\"},\n\t\t{ICEConnectionStateCompleted, \"completed\"},\n\t\t{ICEConnectionStateDisconnected, \"disconnected\"},\n\t\t{ICEConnectionStateFailed, \"failed\"},\n\t\t{ICEConnectionStateClosed, \"closed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "icecredentialtype.go",
          "type": "blob",
          "size": 1.740234375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// ICECredentialType indicates the type of credentials used to connect to\n// an ICE server.\ntype ICECredentialType int\n\nconst (\n\t// ICECredentialTypePassword describes username and password based\n\t// credentials as described in https://tools.ietf.org/html/rfc5389.\n\tICECredentialTypePassword ICECredentialType = iota\n\n\t// ICECredentialTypeOauth describes token based credential as described\n\t// in https://tools.ietf.org/html/rfc7635.\n\tICECredentialTypeOauth\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeCredentialTypePasswordStr = \"password\"\n\ticeCredentialTypeOauthStr    = \"oauth\"\n)\n\nfunc newICECredentialType(raw string) (ICECredentialType, error) {\n\tswitch raw {\n\tcase iceCredentialTypePasswordStr:\n\t\treturn ICECredentialTypePassword, nil\n\tcase iceCredentialTypeOauthStr:\n\t\treturn ICECredentialTypeOauth, nil\n\tdefault:\n\t\treturn ICECredentialTypePassword, errInvalidICECredentialTypeString\n\t}\n}\n\nfunc (t ICECredentialType) String() string {\n\tswitch t {\n\tcase ICECredentialTypePassword:\n\t\treturn iceCredentialTypePasswordStr\n\tcase ICECredentialTypeOauth:\n\t\treturn iceCredentialTypeOauthStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// UnmarshalJSON parses the JSON-encoded data and stores the result\nfunc (t *ICECredentialType) UnmarshalJSON(b []byte) error {\n\tvar val string\n\tif err := json.Unmarshal(b, &val); err != nil {\n\t\treturn err\n\t}\n\n\ttmp, err := newICECredentialType(val)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%w: (%s)\", err, val)\n\t}\n\n\t*t = tmp\n\treturn nil\n}\n\n// MarshalJSON returns the JSON encoding\nfunc (t ICECredentialType) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(t.String())\n}\n"
        },
        {
          "name": "icecredentialtype_test.go",
          "type": "blob",
          "size": 2.396484375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewICECredentialType(t *testing.T) {\n\ttestCases := []struct {\n\t\tcredentialTypeString   string\n\t\texpectedCredentialType ICECredentialType\n\t}{\n\t\t{\"password\", ICECredentialTypePassword},\n\t\t{\"oauth\", ICECredentialTypeOauth},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\ttpe, err := newICECredentialType(testCase.credentialTypeString)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedCredentialType, tpe,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICECredentialType_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tcredentialType ICECredentialType\n\t\texpectedString string\n\t}{\n\t\t{ICECredentialTypePassword, \"password\"},\n\t\t{ICECredentialTypeOauth, \"oauth\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.credentialType.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICECredentialType_new(t *testing.T) {\n\ttestCases := []struct {\n\t\tcredentialType ICECredentialType\n\t\texpectedString string\n\t}{\n\t\t{ICECredentialTypePassword, \"password\"},\n\t\t{ICECredentialTypeOauth, \"oauth\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\ttpe, err := newICECredentialType(testCase.expectedString)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t,\n\t\t\ttpe, testCase.credentialType,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICECredentialType_Json(t *testing.T) {\n\ttestCases := []struct {\n\t\tcredentialType     ICECredentialType\n\t\tjsonRepresentation []byte\n\t}{\n\t\t{ICECredentialTypePassword, []byte(\"\\\"password\\\"\")},\n\t\t{ICECredentialTypeOauth, []byte(\"\\\"oauth\\\"\")},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tm, err := json.Marshal(testCase.credentialType)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t,\n\t\t\ttestCase.jsonRepresentation,\n\t\t\tm,\n\t\t\t\"Marshal testCase: %d %v\", i, testCase,\n\t\t)\n\t\tvar ct ICECredentialType\n\t\terr = json.Unmarshal(testCase.jsonRepresentation, &ct)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t,\n\t\t\ttestCase.credentialType,\n\t\t\tct,\n\t\t\t\"Unmarshal testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n\n\t{\n\t\tct := ICECredentialType(1000)\n\t\terr := json.Unmarshal([]byte(\"\\\"invalid\\\"\"), &ct)\n\t\tassert.Error(t, err)\n\t\tassert.Equal(t, ct, ICECredentialType(1000))\n\t\terr = json.Unmarshal([]byte(\"\\\"invalid\"), &ct)\n\t\tassert.Error(t, err)\n\t\tassert.Equal(t, ct, ICECredentialType(1000))\n\t}\n}\n"
        },
        {
          "name": "icegatherer.go",
          "type": "blob",
          "size": 12.5498046875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/stun/v3\"\n)\n\n// ICEGatherer gathers local host, server reflexive and relay\n// candidates, as well as enabling the retrieval of local Interactive\n// Connectivity Establishment (ICE) parameters which can be\n// exchanged in signaling.\ntype ICEGatherer struct {\n\tlock  sync.RWMutex\n\tlog   logging.LeveledLogger\n\tstate ICEGathererState\n\n\tvalidatedServers []*stun.URI\n\tgatherPolicy     ICETransportPolicy\n\n\tagent *ice.Agent\n\n\tonLocalCandidateHandler atomic.Value // func(candidate *ICECandidate)\n\tonStateChangeHandler    atomic.Value // func(state ICEGathererState)\n\n\t// Used for GatheringCompletePromise\n\tonGatheringCompleteHandler atomic.Value // func()\n\n\tapi *API\n\n\t// Used to set the corresponding media stream identification tag and media description index\n\t// for ICE candidates generated by this gatherer.\n\tsdpMid        atomic.Value  // string\n\tsdpMLineIndex atomic.Uint32 // uint16\n}\n\n// NewICEGatherer creates a new NewICEGatherer.\n// This constructor is part of the ORTC API. It is not\n// meant to be used together with the basic WebRTC API.\nfunc (api *API) NewICEGatherer(opts ICEGatherOptions) (*ICEGatherer, error) {\n\tvar validatedServers []*stun.URI\n\tif len(opts.ICEServers) > 0 {\n\t\tfor _, server := range opts.ICEServers {\n\t\t\turl, err := server.urls()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvalidatedServers = append(validatedServers, url...)\n\t\t}\n\t}\n\n\treturn &ICEGatherer{\n\t\tstate:            ICEGathererStateNew,\n\t\tgatherPolicy:     opts.ICEGatherPolicy,\n\t\tvalidatedServers: validatedServers,\n\t\tapi:              api,\n\t\tlog:              api.settingEngine.LoggerFactory.NewLogger(\"ice\"),\n\t\tsdpMid:           atomic.Value{},\n\t\tsdpMLineIndex:    atomic.Uint32{},\n\t}, nil\n}\n\nfunc (g *ICEGatherer) createAgent() error {\n\tg.lock.Lock()\n\tdefer g.lock.Unlock()\n\n\tif g.agent != nil || g.State() != ICEGathererStateNew {\n\t\treturn nil\n\t}\n\n\tcandidateTypes := []ice.CandidateType{}\n\tif g.api.settingEngine.candidates.ICELite {\n\t\tcandidateTypes = append(candidateTypes, ice.CandidateTypeHost)\n\t} else if g.gatherPolicy == ICETransportPolicyRelay {\n\t\tcandidateTypes = append(candidateTypes, ice.CandidateTypeRelay)\n\t}\n\n\tvar nat1To1CandiTyp ice.CandidateType\n\tswitch g.api.settingEngine.candidates.NAT1To1IPCandidateType {\n\tcase ICECandidateTypeHost:\n\t\tnat1To1CandiTyp = ice.CandidateTypeHost\n\tcase ICECandidateTypeSrflx:\n\t\tnat1To1CandiTyp = ice.CandidateTypeServerReflexive\n\tdefault:\n\t\tnat1To1CandiTyp = ice.CandidateTypeUnspecified\n\t}\n\n\tmDNSMode := g.api.settingEngine.candidates.MulticastDNSMode\n\tif mDNSMode != ice.MulticastDNSModeDisabled && mDNSMode != ice.MulticastDNSModeQueryAndGather {\n\t\t// If enum is in state we don't recognized default to MulticastDNSModeQueryOnly\n\t\tmDNSMode = ice.MulticastDNSModeQueryOnly\n\t}\n\n\tconfig := &ice.AgentConfig{\n\t\tLite:                   g.api.settingEngine.candidates.ICELite,\n\t\tUrls:                   g.validatedServers,\n\t\tPortMin:                g.api.settingEngine.ephemeralUDP.PortMin,\n\t\tPortMax:                g.api.settingEngine.ephemeralUDP.PortMax,\n\t\tDisconnectedTimeout:    g.api.settingEngine.timeout.ICEDisconnectedTimeout,\n\t\tFailedTimeout:          g.api.settingEngine.timeout.ICEFailedTimeout,\n\t\tKeepaliveInterval:      g.api.settingEngine.timeout.ICEKeepaliveInterval,\n\t\tLoggerFactory:          g.api.settingEngine.LoggerFactory,\n\t\tCandidateTypes:         candidateTypes,\n\t\tHostAcceptanceMinWait:  g.api.settingEngine.timeout.ICEHostAcceptanceMinWait,\n\t\tSrflxAcceptanceMinWait: g.api.settingEngine.timeout.ICESrflxAcceptanceMinWait,\n\t\tPrflxAcceptanceMinWait: g.api.settingEngine.timeout.ICEPrflxAcceptanceMinWait,\n\t\tRelayAcceptanceMinWait: g.api.settingEngine.timeout.ICERelayAcceptanceMinWait,\n\t\tSTUNGatherTimeout:      g.api.settingEngine.timeout.ICESTUNGatherTimeout,\n\t\tInterfaceFilter:        g.api.settingEngine.candidates.InterfaceFilter,\n\t\tIPFilter:               g.api.settingEngine.candidates.IPFilter,\n\t\tNAT1To1IPs:             g.api.settingEngine.candidates.NAT1To1IPs,\n\t\tNAT1To1IPCandidateType: nat1To1CandiTyp,\n\t\tIncludeLoopback:        g.api.settingEngine.candidates.IncludeLoopbackCandidate,\n\t\tNet:                    g.api.settingEngine.net,\n\t\tMulticastDNSMode:       mDNSMode,\n\t\tMulticastDNSHostName:   g.api.settingEngine.candidates.MulticastDNSHostName,\n\t\tLocalUfrag:             g.api.settingEngine.candidates.UsernameFragment,\n\t\tLocalPwd:               g.api.settingEngine.candidates.Password,\n\t\tTCPMux:                 g.api.settingEngine.iceTCPMux,\n\t\tUDPMux:                 g.api.settingEngine.iceUDPMux,\n\t\tProxyDialer:            g.api.settingEngine.iceProxyDialer,\n\t\tDisableActiveTCP:       g.api.settingEngine.iceDisableActiveTCP,\n\t\tMaxBindingRequests:     g.api.settingEngine.iceMaxBindingRequests,\n\t\tBindingRequestHandler:  g.api.settingEngine.iceBindingRequestHandler,\n\t}\n\n\trequestedNetworkTypes := g.api.settingEngine.candidates.ICENetworkTypes\n\tif len(requestedNetworkTypes) == 0 {\n\t\trequestedNetworkTypes = supportedNetworkTypes()\n\t}\n\n\tfor _, typ := range requestedNetworkTypes {\n\t\tconfig.NetworkTypes = append(config.NetworkTypes, ice.NetworkType(typ))\n\t}\n\n\tagent, err := ice.NewAgent(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tg.agent = agent\n\treturn nil\n}\n\n// Gather ICE candidates.\nfunc (g *ICEGatherer) Gather() error {\n\tif err := g.createAgent(); err != nil {\n\t\treturn err\n\t}\n\n\tagent := g.getAgent()\n\t// it is possible agent had just been closed\n\tif agent == nil {\n\t\treturn fmt.Errorf(\"%w: unable to gather\", errICEAgentNotExist)\n\t}\n\n\tg.setState(ICEGathererStateGathering)\n\tif err := agent.OnCandidate(func(candidate ice.Candidate) {\n\t\tonLocalCandidateHandler := func(*ICECandidate) {}\n\t\tif handler, ok := g.onLocalCandidateHandler.Load().(func(candidate *ICECandidate)); ok && handler != nil {\n\t\t\tonLocalCandidateHandler = handler\n\t\t}\n\n\t\tonGatheringCompleteHandler := func() {}\n\t\tif handler, ok := g.onGatheringCompleteHandler.Load().(func()); ok && handler != nil {\n\t\t\tonGatheringCompleteHandler = handler\n\t\t}\n\n\t\tsdpMid := \"\"\n\n\t\tif mid, ok := g.sdpMid.Load().(string); ok {\n\t\t\tsdpMid = mid\n\t\t}\n\n\t\tsdpMLineIndex := uint16(g.sdpMLineIndex.Load())\n\n\t\tif candidate != nil {\n\t\t\tc, err := newICECandidateFromICE(candidate, sdpMid, sdpMLineIndex)\n\t\t\tif err != nil {\n\t\t\t\tg.log.Warnf(\"Failed to convert ice.Candidate: %s\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tonLocalCandidateHandler(&c)\n\t\t} else {\n\t\t\tg.setState(ICEGathererStateComplete)\n\n\t\t\tonGatheringCompleteHandler()\n\t\t\tonLocalCandidateHandler(nil)\n\t\t}\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn agent.GatherCandidates()\n}\n\n// set media stream identification tag and media description index for this gatherer\nfunc (g *ICEGatherer) setMediaStreamIdentification(mid string, mLineIndex uint16) {\n\tg.sdpMid.Store(mid)\n\tg.sdpMLineIndex.Store(uint32(mLineIndex))\n}\n\n// Close prunes all local candidates, and closes the ports.\nfunc (g *ICEGatherer) Close() error {\n\treturn g.close(false /* shouldGracefullyClose */)\n}\n\n// GracefulClose prunes all local candidates, and closes the ports. It also waits\n// for any goroutines it started to complete. This is only safe to call outside of\n// ICEGatherer callbacks or if in a callback, in its own goroutine.\nfunc (g *ICEGatherer) GracefulClose() error {\n\treturn g.close(true /* shouldGracefullyClose */)\n}\n\nfunc (g *ICEGatherer) close(shouldGracefullyClose bool) error {\n\tg.lock.Lock()\n\tdefer g.lock.Unlock()\n\n\tif g.agent == nil {\n\t\treturn nil\n\t}\n\tif shouldGracefullyClose {\n\t\tif err := g.agent.GracefulClose(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := g.agent.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tg.agent = nil\n\tg.setState(ICEGathererStateClosed)\n\n\treturn nil\n}\n\n// GetLocalParameters returns the ICE parameters of the ICEGatherer.\nfunc (g *ICEGatherer) GetLocalParameters() (ICEParameters, error) {\n\tif err := g.createAgent(); err != nil {\n\t\treturn ICEParameters{}, err\n\t}\n\n\tagent := g.getAgent()\n\t// it is possible agent had just been closed\n\tif agent == nil {\n\t\treturn ICEParameters{}, fmt.Errorf(\"%w: unable to get local parameters\", errICEAgentNotExist)\n\t}\n\n\tfrag, pwd, err := agent.GetLocalUserCredentials()\n\tif err != nil {\n\t\treturn ICEParameters{}, err\n\t}\n\n\treturn ICEParameters{\n\t\tUsernameFragment: frag,\n\t\tPassword:         pwd,\n\t\tICELite:          false,\n\t}, nil\n}\n\n// GetLocalCandidates returns the sequence of valid local candidates associated with the ICEGatherer.\nfunc (g *ICEGatherer) GetLocalCandidates() ([]ICECandidate, error) {\n\tif err := g.createAgent(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tagent := g.getAgent()\n\t// it is possible agent had just been closed\n\tif agent == nil {\n\t\treturn nil, fmt.Errorf(\"%w: unable to get local candidates\", errICEAgentNotExist)\n\t}\n\n\ticeCandidates, err := agent.GetLocalCandidates()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsdpMid := \"\"\n\tif mid, ok := g.sdpMid.Load().(string); ok {\n\t\tsdpMid = mid\n\t}\n\n\tsdpMLineIndex := uint16(g.sdpMLineIndex.Load())\n\n\treturn newICECandidatesFromICE(iceCandidates, sdpMid, sdpMLineIndex)\n}\n\n// OnLocalCandidate sets an event handler which fires when a new local ICE candidate is available\n// Take note that the handler will be called with a nil pointer when gathering is finished.\nfunc (g *ICEGatherer) OnLocalCandidate(f func(*ICECandidate)) {\n\tg.onLocalCandidateHandler.Store(f)\n}\n\n// OnStateChange fires any time the ICEGatherer changes\nfunc (g *ICEGatherer) OnStateChange(f func(ICEGathererState)) {\n\tg.onStateChangeHandler.Store(f)\n}\n\n// State indicates the current state of the ICE gatherer.\nfunc (g *ICEGatherer) State() ICEGathererState {\n\treturn atomicLoadICEGathererState(&g.state)\n}\n\nfunc (g *ICEGatherer) setState(s ICEGathererState) {\n\tatomicStoreICEGathererState(&g.state, s)\n\n\tif handler, ok := g.onStateChangeHandler.Load().(func(state ICEGathererState)); ok && handler != nil {\n\t\thandler(s)\n\t}\n}\n\nfunc (g *ICEGatherer) getAgent() *ice.Agent {\n\tg.lock.RLock()\n\tdefer g.lock.RUnlock()\n\treturn g.agent\n}\n\nfunc (g *ICEGatherer) collectStats(collector *statsReportCollector) {\n\tagent := g.getAgent()\n\tif agent == nil {\n\t\treturn\n\t}\n\n\tcollector.Collecting()\n\tgo func(collector *statsReportCollector, agent *ice.Agent) {\n\t\tfor _, candidatePairStats := range agent.GetCandidatePairsStats() {\n\t\t\tcollector.Collecting()\n\n\t\t\tstats, err := toICECandidatePairStats(candidatePairStats)\n\t\t\tif err != nil {\n\t\t\t\tg.log.Error(err.Error())\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tcollector.Collect(stats.ID, stats)\n\t\t}\n\n\t\tfor _, candidateStats := range agent.GetLocalCandidatesStats() {\n\t\t\tcollector.Collecting()\n\n\t\t\tnetworkType, err := getNetworkType(candidateStats.NetworkType)\n\t\t\tif err != nil {\n\t\t\t\tg.log.Error(err.Error())\n\t\t\t}\n\n\t\t\tcandidateType, err := getCandidateType(candidateStats.CandidateType)\n\t\t\tif err != nil {\n\t\t\t\tg.log.Error(err.Error())\n\t\t\t}\n\n\t\t\tstats := ICECandidateStats{\n\t\t\t\tTimestamp:     statsTimestampFrom(candidateStats.Timestamp),\n\t\t\t\tID:            candidateStats.ID,\n\t\t\t\tType:          StatsTypeLocalCandidate,\n\t\t\t\tIP:            candidateStats.IP,\n\t\t\t\tPort:          int32(candidateStats.Port),\n\t\t\t\tProtocol:      networkType.Protocol(),\n\t\t\t\tCandidateType: candidateType,\n\t\t\t\tPriority:      int32(candidateStats.Priority),\n\t\t\t\tURL:           candidateStats.URL,\n\t\t\t\tRelayProtocol: candidateStats.RelayProtocol,\n\t\t\t\tDeleted:       candidateStats.Deleted,\n\t\t\t}\n\t\t\tcollector.Collect(stats.ID, stats)\n\t\t}\n\n\t\tfor _, candidateStats := range agent.GetRemoteCandidatesStats() {\n\t\t\tcollector.Collecting()\n\t\t\tnetworkType, err := getNetworkType(candidateStats.NetworkType)\n\t\t\tif err != nil {\n\t\t\t\tg.log.Error(err.Error())\n\t\t\t}\n\n\t\t\tcandidateType, err := getCandidateType(candidateStats.CandidateType)\n\t\t\tif err != nil {\n\t\t\t\tg.log.Error(err.Error())\n\t\t\t}\n\n\t\t\tstats := ICECandidateStats{\n\t\t\t\tTimestamp:     statsTimestampFrom(candidateStats.Timestamp),\n\t\t\t\tID:            candidateStats.ID,\n\t\t\t\tType:          StatsTypeRemoteCandidate,\n\t\t\t\tIP:            candidateStats.IP,\n\t\t\t\tPort:          int32(candidateStats.Port),\n\t\t\t\tProtocol:      networkType.Protocol(),\n\t\t\t\tCandidateType: candidateType,\n\t\t\t\tPriority:      int32(candidateStats.Priority),\n\t\t\t\tURL:           candidateStats.URL,\n\t\t\t\tRelayProtocol: candidateStats.RelayProtocol,\n\t\t\t}\n\t\t\tcollector.Collect(stats.ID, stats)\n\t\t}\n\t\tcollector.Done()\n\t}(collector, agent)\n}\n\nfunc (g *ICEGatherer) getSelectedCandidatePairStats() (ICECandidatePairStats, bool) {\n\tagent := g.getAgent()\n\tif agent == nil {\n\t\treturn ICECandidatePairStats{}, false\n\t}\n\n\tselectedCandidatePairStats, isAvailable := agent.GetSelectedCandidatePairStats()\n\tif !isAvailable {\n\t\treturn ICECandidatePairStats{}, false\n\t}\n\n\tstats, err := toICECandidatePairStats(selectedCandidatePairStats)\n\tif err != nil {\n\t\tg.log.Error(err.Error())\n\t\treturn ICECandidatePairStats{}, false\n\t}\n\n\treturn stats, true\n}\n"
        },
        {
          "name": "icegatherer_test.go",
          "type": "blob",
          "size": 4.76171875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewICEGatherer_Success(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\topts := ICEGatherOptions{\n\t\tICEServers: []ICEServer{{URLs: []string{\"stun:stun.l.google.com:19302\"}}},\n\t}\n\n\tgatherer, err := NewAPI().NewICEGatherer(opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif gatherer.State() != ICEGathererStateNew {\n\t\tt.Fatalf(\"Expected gathering state new\")\n\t}\n\n\tgatherFinished := make(chan struct{})\n\tgatherer.OnLocalCandidate(func(i *ICECandidate) {\n\t\tif i == nil {\n\t\t\tclose(gatherFinished)\n\t\t}\n\t})\n\n\tif err = gatherer.Gather(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t<-gatherFinished\n\n\tparams, err := gatherer.GetLocalParameters()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif params.UsernameFragment == \"\" ||\n\t\tparams.Password == \"\" {\n\t\tt.Fatalf(\"Empty local username or password frag\")\n\t}\n\n\tcandidates, err := gatherer.GetLocalCandidates()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif len(candidates) == 0 {\n\t\tt.Fatalf(\"No candidates gathered\")\n\t}\n\n\tassert.NoError(t, gatherer.Close())\n}\n\nfunc TestICEGather_mDNSCandidateGathering(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ts := SettingEngine{}\n\ts.SetICEMulticastDNSMode(ice.MulticastDNSModeQueryAndGather)\n\n\tgatherer, err := NewAPI(WithSettingEngine(s)).NewICEGatherer(ICEGatherOptions{})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tgotMulticastDNSCandidate, resolveFunc := context.WithCancel(context.Background())\n\tgatherer.OnLocalCandidate(func(c *ICECandidate) {\n\t\tif c != nil && strings.HasSuffix(c.Address, \".local\") {\n\t\t\tresolveFunc()\n\t\t}\n\t})\n\n\tassert.NoError(t, gatherer.Gather())\n\n\t<-gotMulticastDNSCandidate.Done()\n\tassert.NoError(t, gatherer.Close())\n}\n\nfunc TestICEGatherer_AlreadyClosed(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\topts := ICEGatherOptions{\n\t\tICEServers: []ICEServer{{URLs: []string{\"stun:stun.l.google.com:19302\"}}},\n\t}\n\n\tt.Run(\"Gather\", func(t *testing.T) {\n\t\tgatherer, err := NewAPI().NewICEGatherer(opts)\n\t\tassert.NoError(t, err)\n\n\t\terr = gatherer.createAgent()\n\t\tassert.NoError(t, err)\n\n\t\terr = gatherer.Close()\n\t\tassert.NoError(t, err)\n\n\t\terr = gatherer.Gather()\n\t\tassert.ErrorIs(t, err, errICEAgentNotExist)\n\t})\n\n\tt.Run(\"GetLocalParameters\", func(t *testing.T) {\n\t\tgatherer, err := NewAPI().NewICEGatherer(opts)\n\t\tassert.NoError(t, err)\n\n\t\terr = gatherer.createAgent()\n\t\tassert.NoError(t, err)\n\n\t\terr = gatherer.Close()\n\t\tassert.NoError(t, err)\n\n\t\t_, err = gatherer.GetLocalParameters()\n\t\tassert.ErrorIs(t, err, errICEAgentNotExist)\n\t})\n\n\tt.Run(\"GetLocalCandidates\", func(t *testing.T) {\n\t\tgatherer, err := NewAPI().NewICEGatherer(opts)\n\t\tassert.NoError(t, err)\n\n\t\terr = gatherer.createAgent()\n\t\tassert.NoError(t, err)\n\n\t\terr = gatherer.Close()\n\t\tassert.NoError(t, err)\n\n\t\t_, err = gatherer.GetLocalCandidates()\n\t\tassert.ErrorIs(t, err, errICEAgentNotExist)\n\t})\n}\n\nfunc TestNewICEGathererSetMediaStreamIdentification(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\topts := ICEGatherOptions{\n\t\tICEServers: []ICEServer{{URLs: []string{\"stun:stun.l.google.com:19302\"}}},\n\t}\n\n\tgatherer, err := NewAPI().NewICEGatherer(opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\texpectedMid := \"5\"\n\texpectedMLineIndex := uint16(1)\n\n\tgatherer.setMediaStreamIdentification(expectedMid, expectedMLineIndex)\n\n\tif gatherer.State() != ICEGathererStateNew {\n\t\tt.Fatalf(\"Expected gathering state new\")\n\t}\n\n\tgatherFinished := make(chan struct{})\n\tgatherer.OnLocalCandidate(func(i *ICECandidate) {\n\t\tif i == nil {\n\t\t\tclose(gatherFinished)\n\t\t} else {\n\t\t\tassert.Equal(t, expectedMid, i.SDPMid)\n\t\t\tassert.Equal(t, expectedMLineIndex, i.SDPMLineIndex)\n\t\t}\n\t})\n\n\tif err = gatherer.Gather(); err != nil {\n\t\tt.Error(err)\n\t}\n\n\t<-gatherFinished\n\n\tparams, err := gatherer.GetLocalParameters()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif params.UsernameFragment == \"\" ||\n\t\tparams.Password == \"\" {\n\t\tt.Fatalf(\"Empty local username or password frag\")\n\t}\n\n\tcandidates, err := gatherer.GetLocalCandidates()\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif len(candidates) == 0 {\n\t\tt.Fatalf(\"No candidates gathered\")\n\t}\n\n\tfor _, c := range candidates {\n\t\tassert.Equal(t, expectedMid, c.SDPMid)\n\t\tassert.Equal(t, expectedMLineIndex, c.SDPMLineIndex)\n\t}\n\n\tassert.NoError(t, gatherer.Close())\n}\n"
        },
        {
          "name": "icegathererstate.go",
          "type": "blob",
          "size": 1.46875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"sync/atomic\"\n)\n\n// ICEGathererState represents the current state of the ICE gatherer.\ntype ICEGathererState uint32\n\nconst (\n\t// ICEGathererStateUnknown is the enum's zero-value\n\tICEGathererStateUnknown ICEGathererState = iota\n\n\t// ICEGathererStateNew indicates object has been created but\n\t// gather() has not been called.\n\tICEGathererStateNew\n\n\t// ICEGathererStateGathering indicates gather() has been called,\n\t// and the ICEGatherer is in the process of gathering candidates.\n\tICEGathererStateGathering\n\n\t// ICEGathererStateComplete indicates the ICEGatherer has completed gathering.\n\tICEGathererStateComplete\n\n\t// ICEGathererStateClosed indicates the closed state can only be entered\n\t// when the ICEGatherer has been closed intentionally by calling close().\n\tICEGathererStateClosed\n)\n\nfunc (s ICEGathererState) String() string {\n\tswitch s {\n\tcase ICEGathererStateNew:\n\t\treturn \"new\"\n\tcase ICEGathererStateGathering:\n\t\treturn \"gathering\"\n\tcase ICEGathererStateComplete:\n\t\treturn \"complete\"\n\tcase ICEGathererStateClosed:\n\t\treturn \"closed\"\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\nfunc atomicStoreICEGathererState(state *ICEGathererState, newState ICEGathererState) {\n\tatomic.StoreUint32((*uint32)(state), uint32(newState))\n}\n\nfunc atomicLoadICEGathererState(state *ICEGathererState) ICEGathererState {\n\treturn ICEGathererState(atomic.LoadUint32((*uint32)(state)))\n}\n"
        },
        {
          "name": "icegathererstate_test.go",
          "type": "blob",
          "size": 0.6689453125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICEGathererState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          ICEGathererState\n\t\texpectedString string\n\t}{\n\t\t{ICEGathererStateUnknown, ErrUnknownType.Error()},\n\t\t{ICEGathererStateNew, \"new\"},\n\t\t{ICEGathererStateGathering, \"gathering\"},\n\t\t{ICEGathererStateComplete, \"complete\"},\n\t\t{ICEGathererStateClosed, \"closed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "icegatheringstate.go",
          "type": "blob",
          "size": 1.7158203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// ICEGatheringState describes the state of the candidate gathering process.\ntype ICEGatheringState int\n\nconst (\n\t// ICEGatheringStateUnknown is the enum's zero-value\n\tICEGatheringStateUnknown ICEGatheringState = iota\n\n\t// ICEGatheringStateNew indicates that any of the ICETransports are\n\t// in the \"new\" gathering state and none of the transports are in the\n\t// \"gathering\" state, or there are no transports.\n\tICEGatheringStateNew\n\n\t// ICEGatheringStateGathering indicates that any of the ICETransports\n\t// are in the \"gathering\" state.\n\tICEGatheringStateGathering\n\n\t// ICEGatheringStateComplete indicates that at least one ICETransport\n\t// exists, and all ICETransports are in the \"completed\" gathering state.\n\tICEGatheringStateComplete\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeGatheringStateNewStr       = \"new\"\n\ticeGatheringStateGatheringStr = \"gathering\"\n\ticeGatheringStateCompleteStr  = \"complete\"\n)\n\n// NewICEGatheringState takes a string and converts it to ICEGatheringState\nfunc NewICEGatheringState(raw string) ICEGatheringState {\n\tswitch raw {\n\tcase iceGatheringStateNewStr:\n\t\treturn ICEGatheringStateNew\n\tcase iceGatheringStateGatheringStr:\n\t\treturn ICEGatheringStateGathering\n\tcase iceGatheringStateCompleteStr:\n\t\treturn ICEGatheringStateComplete\n\tdefault:\n\t\treturn ICEGatheringStateUnknown\n\t}\n}\n\nfunc (t ICEGatheringState) String() string {\n\tswitch t {\n\tcase ICEGatheringStateNew:\n\t\treturn iceGatheringStateNewStr\n\tcase ICEGatheringStateGathering:\n\t\treturn iceGatheringStateGatheringStr\n\tcase ICEGatheringStateComplete:\n\t\treturn iceGatheringStateCompleteStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n"
        },
        {
          "name": "icegatheringstate_test.go",
          "type": "blob",
          "size": 1.1123046875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewICEGatheringState(t *testing.T) {\n\ttestCases := []struct {\n\t\tstateString   string\n\t\texpectedState ICEGatheringState\n\t}{\n\t\t{ErrUnknownType.Error(), ICEGatheringStateUnknown},\n\t\t{\"new\", ICEGatheringStateNew},\n\t\t{\"gathering\", ICEGatheringStateGathering},\n\t\t{\"complete\", ICEGatheringStateComplete},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedState,\n\t\t\tNewICEGatheringState(testCase.stateString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICEGatheringState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          ICEGatheringState\n\t\texpectedString string\n\t}{\n\t\t{ICEGatheringStateUnknown, ErrUnknownType.Error()},\n\t\t{ICEGatheringStateNew, \"new\"},\n\t\t{ICEGatheringStateGathering, \"gathering\"},\n\t\t{ICEGatheringStateComplete, \"complete\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "icegatheroptions.go",
          "type": "blob",
          "size": 0.291015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// ICEGatherOptions provides options relating to the gathering of ICE candidates.\ntype ICEGatherOptions struct {\n\tICEServers      []ICEServer\n\tICEGatherPolicy ICETransportPolicy\n}\n"
        },
        {
          "name": "icemux.go",
          "type": "blob",
          "size": 0.833984375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"net\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/logging\"\n)\n\n// NewICETCPMux creates a new instance of ice.TCPMuxDefault. It enables use of\n// passive ICE TCP candidates.\nfunc NewICETCPMux(logger logging.LeveledLogger, listener net.Listener, readBufferSize int) ice.TCPMux {\n\treturn ice.NewTCPMuxDefault(ice.TCPMuxParams{\n\t\tListener:       listener,\n\t\tLogger:         logger,\n\t\tReadBufferSize: readBufferSize,\n\t})\n}\n\n// NewICEUDPMux creates a new instance of ice.UDPMuxDefault. It allows many PeerConnections to be served\n// by a single UDP Port.\nfunc NewICEUDPMux(logger logging.LeveledLogger, udpConn net.PacketConn) ice.UDPMux {\n\treturn ice.NewUDPMuxDefault(ice.UDPMuxParams{\n\t\tUDPConn: udpConn,\n\t\tLogger:  logger,\n\t})\n}\n"
        },
        {
          "name": "iceparameters.go",
          "type": "blob",
          "size": 0.376953125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// ICEParameters includes the ICE username fragment\n// and password and other ICE-related parameters.\ntype ICEParameters struct {\n\tUsernameFragment string `json:\"usernameFragment\"`\n\tPassword         string `json:\"password\"`\n\tICELite          bool   `json:\"iceLite\"`\n}\n"
        },
        {
          "name": "iceprotocol.go",
          "type": "blob",
          "size": 1.1728515625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// ICEProtocol indicates the transport protocol type that is used in the\n// ice.URL structure.\ntype ICEProtocol int\n\nconst (\n\t// ICEProtocolUnknown is the enum's zero-value\n\tICEProtocolUnknown ICEProtocol = iota\n\n\t// ICEProtocolUDP indicates the URL uses a UDP transport.\n\tICEProtocolUDP\n\n\t// ICEProtocolTCP indicates the URL uses a TCP transport.\n\tICEProtocolTCP\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeProtocolUDPStr = \"udp\"\n\ticeProtocolTCPStr = \"tcp\"\n)\n\n// NewICEProtocol takes a string and converts it to ICEProtocol\nfunc NewICEProtocol(raw string) (ICEProtocol, error) {\n\tswitch {\n\tcase strings.EqualFold(iceProtocolUDPStr, raw):\n\t\treturn ICEProtocolUDP, nil\n\tcase strings.EqualFold(iceProtocolTCPStr, raw):\n\t\treturn ICEProtocolTCP, nil\n\tdefault:\n\t\treturn ICEProtocolUnknown, fmt.Errorf(\"%w: %s\", errICEProtocolUnknown, raw)\n\t}\n}\n\nfunc (t ICEProtocol) String() string {\n\tswitch t {\n\tcase ICEProtocolUDP:\n\t\treturn iceProtocolUDPStr\n\tcase ICEProtocolTCP:\n\t\treturn iceProtocolTCPStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n"
        },
        {
          "name": "iceprotocol_test.go",
          "type": "blob",
          "size": 1.1318359375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewICEProtocol(t *testing.T) {\n\ttestCases := []struct {\n\t\tprotoString   string\n\t\tshouldFail    bool\n\t\texpectedProto ICEProtocol\n\t}{\n\t\t{ErrUnknownType.Error(), true, ICEProtocolUnknown},\n\t\t{\"udp\", false, ICEProtocolUDP},\n\t\t{\"tcp\", false, ICEProtocolTCP},\n\t\t{\"UDP\", false, ICEProtocolUDP},\n\t\t{\"TCP\", false, ICEProtocolTCP},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactual, err := NewICEProtocol(testCase.protoString)\n\t\tif (err != nil) != testCase.shouldFail {\n\t\t\tt.Error(err)\n\t\t}\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedProto,\n\t\t\tactual,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICEProtocol_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tproto          ICEProtocol\n\t\texpectedString string\n\t}{\n\t\t{ICEProtocolUnknown, ErrUnknownType.Error()},\n\t\t{ICEProtocolUDP, \"udp\"},\n\t\t{ICEProtocolTCP, \"tcp\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.proto.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "icerole.go",
          "type": "blob",
          "size": 1.5703125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// ICERole describes the role ice.Agent is playing in selecting the\n// preferred the candidate pair.\ntype ICERole int\n\nconst (\n\t// ICERoleUnknown is the enum's zero-value\n\tICERoleUnknown ICERole = iota\n\n\t// ICERoleControlling indicates that the ICE agent that is responsible\n\t// for selecting the final choice of candidate pairs and signaling them\n\t// through STUN and an updated offer, if needed. In any session, one agent\n\t// is always controlling. The other is the controlled agent.\n\tICERoleControlling\n\n\t// ICERoleControlled indicates that an ICE agent that waits for the\n\t// controlling agent to select the final choice of candidate pairs.\n\tICERoleControlled\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeRoleControllingStr = \"controlling\"\n\ticeRoleControlledStr  = \"controlled\"\n)\n\nfunc newICERole(raw string) ICERole {\n\tswitch raw {\n\tcase iceRoleControllingStr:\n\t\treturn ICERoleControlling\n\tcase iceRoleControlledStr:\n\t\treturn ICERoleControlled\n\tdefault:\n\t\treturn ICERoleUnknown\n\t}\n}\n\nfunc (t ICERole) String() string {\n\tswitch t {\n\tcase ICERoleControlling:\n\t\treturn iceRoleControllingStr\n\tcase ICERoleControlled:\n\t\treturn iceRoleControlledStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// MarshalText implements encoding.TextMarshaler\nfunc (t ICERole) MarshalText() ([]byte, error) {\n\treturn []byte(t.String()), nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler\nfunc (t *ICERole) UnmarshalText(b []byte) error {\n\t*t = newICERole(string(b))\n\treturn nil\n}\n"
        },
        {
          "name": "icerole_test.go",
          "type": "blob",
          "size": 0.9521484375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewICERole(t *testing.T) {\n\ttestCases := []struct {\n\t\troleString   string\n\t\texpectedRole ICERole\n\t}{\n\t\t{ErrUnknownType.Error(), ICERoleUnknown},\n\t\t{\"controlling\", ICERoleControlling},\n\t\t{\"controlled\", ICERoleControlled},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedRole,\n\t\t\tnewICERole(testCase.roleString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICERole_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tproto          ICERole\n\t\texpectedString string\n\t}{\n\t\t{ICERoleUnknown, ErrUnknownType.Error()},\n\t\t{ICERoleControlling, \"controlling\"},\n\t\t{ICERoleControlled, \"controlled\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.proto.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "iceserver.go",
          "type": "blob",
          "size": 4.2255859375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pion/stun/v3\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\n// ICEServer describes a single STUN and TURN server that can be used by\n// the ICEAgent to establish a connection with a peer.\ntype ICEServer struct {\n\tURLs           []string          `json:\"urls\"`\n\tUsername       string            `json:\"username,omitempty\"`\n\tCredential     interface{}       `json:\"credential,omitempty\"`\n\tCredentialType ICECredentialType `json:\"credentialType,omitempty\"`\n}\n\nfunc (s ICEServer) parseURL(i int) (*stun.URI, error) {\n\treturn stun.ParseURI(s.URLs[i])\n}\n\nfunc (s ICEServer) validate() error {\n\t_, err := s.urls()\n\treturn err\n}\n\nfunc (s ICEServer) urls() ([]*stun.URI, error) {\n\turls := []*stun.URI{}\n\n\tfor i := range s.URLs {\n\t\turl, err := s.parseURL(i)\n\t\tif err != nil {\n\t\t\treturn nil, &rtcerr.InvalidAccessError{Err: err}\n\t\t}\n\n\t\tif url.Scheme == stun.SchemeTypeTURN || url.Scheme == stun.SchemeTypeTURNS {\n\t\t\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #11.3.2)\n\t\t\tif s.Username == \"\" || s.Credential == nil {\n\t\t\t\treturn nil, &rtcerr.InvalidAccessError{Err: ErrNoTurnCredentials}\n\t\t\t}\n\t\t\turl.Username = s.Username\n\n\t\t\tswitch s.CredentialType {\n\t\t\tcase ICECredentialTypePassword:\n\t\t\t\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #11.3.3)\n\t\t\t\tpassword, ok := s.Credential.(string)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, &rtcerr.InvalidAccessError{Err: ErrTurnCredentials}\n\t\t\t\t}\n\t\t\t\turl.Password = password\n\n\t\t\tcase ICECredentialTypeOauth:\n\t\t\t\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #11.3.4)\n\t\t\t\tif _, ok := s.Credential.(OAuthCredential); !ok {\n\t\t\t\t\treturn nil, &rtcerr.InvalidAccessError{Err: ErrTurnCredentials}\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\treturn nil, &rtcerr.InvalidAccessError{Err: ErrTurnCredentials}\n\t\t\t}\n\t\t}\n\n\t\turls = append(urls, url)\n\t}\n\n\treturn urls, nil\n}\n\nfunc iceserverUnmarshalUrls(val interface{}) (*[]string, error) {\n\ts, ok := val.([]interface{})\n\tif !ok {\n\t\treturn nil, errInvalidICEServer\n\t}\n\tout := make([]string, len(s))\n\tfor idx, url := range s {\n\t\tout[idx], ok = url.(string)\n\t\tif !ok {\n\t\t\treturn nil, errInvalidICEServer\n\t\t}\n\t}\n\treturn &out, nil\n}\n\nfunc iceserverUnmarshalOauth(val interface{}) (*OAuthCredential, error) {\n\tc, ok := val.(map[string]interface{})\n\tif !ok {\n\t\treturn nil, errInvalidICEServer\n\t}\n\tMACKey, ok := c[\"MACKey\"].(string)\n\tif !ok {\n\t\treturn nil, errInvalidICEServer\n\t}\n\tAccessToken, ok := c[\"AccessToken\"].(string)\n\tif !ok {\n\t\treturn nil, errInvalidICEServer\n\t}\n\treturn &OAuthCredential{\n\t\tMACKey:      MACKey,\n\t\tAccessToken: AccessToken,\n\t}, nil\n}\n\nfunc (s *ICEServer) iceserverUnmarshalFields(m map[string]interface{}) error {\n\tif val, ok := m[\"urls\"]; ok {\n\t\tu, err := iceserverUnmarshalUrls(val)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.URLs = *u\n\t} else {\n\t\ts.URLs = []string{}\n\t}\n\n\tif val, ok := m[\"username\"]; ok {\n\t\ts.Username, ok = val.(string)\n\t\tif !ok {\n\t\t\treturn errInvalidICEServer\n\t\t}\n\t}\n\tif val, ok := m[\"credentialType\"]; ok {\n\t\tct, ok := val.(string)\n\t\tif !ok {\n\t\t\treturn errInvalidICEServer\n\t\t}\n\t\ttpe, err := newICECredentialType(ct)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.CredentialType = tpe\n\t} else {\n\t\ts.CredentialType = ICECredentialTypePassword\n\t}\n\tif val, ok := m[\"credential\"]; ok {\n\t\tswitch s.CredentialType {\n\t\tcase ICECredentialTypePassword:\n\t\t\ts.Credential = val\n\t\tcase ICECredentialTypeOauth:\n\t\t\tc, err := iceserverUnmarshalOauth(val)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ts.Credential = *c\n\t\tdefault:\n\t\t\treturn errInvalidICECredentialTypeString\n\t\t}\n\t}\n\treturn nil\n}\n\n// UnmarshalJSON parses the JSON-encoded data and stores the result\nfunc (s *ICEServer) UnmarshalJSON(b []byte) error {\n\tvar tmp interface{}\n\terr := json.Unmarshal(b, &tmp)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif m, ok := tmp.(map[string]interface{}); ok {\n\t\treturn s.iceserverUnmarshalFields(m)\n\t}\n\treturn errInvalidICEServer\n}\n\n// MarshalJSON returns the JSON encoding\nfunc (s ICEServer) MarshalJSON() ([]byte, error) {\n\tm := make(map[string]interface{})\n\tm[\"urls\"] = s.URLs\n\tif s.Username != \"\" {\n\t\tm[\"username\"] = s.Username\n\t}\n\tif s.Credential != nil {\n\t\tm[\"credential\"] = s.Credential\n\t}\n\tm[\"credentialType\"] = s.CredentialType\n\treturn json.Marshal(m)\n}\n"
        },
        {
          "name": "iceserver_js.go",
          "type": "blob",
          "size": 0.98046875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport (\n\t\"errors\"\n\n\t\"github.com/pion/ice/v4\"\n)\n\n// ICEServer describes a single STUN and TURN server that can be used by\n// the ICEAgent to establish a connection with a peer.\ntype ICEServer struct {\n\tURLs     []string\n\tUsername string\n\t// Note: TURN is not supported in the WASM bindings yet\n\tCredential     interface{}\n\tCredentialType ICECredentialType\n}\n\nfunc (s ICEServer) parseURL(i int) (*ice.URL, error) {\n\treturn ice.ParseURL(s.URLs[i])\n}\n\nfunc (s ICEServer) validate() ([]*ice.URL, error) {\n\turls := []*ice.URL{}\n\n\tfor i := range s.URLs {\n\t\turl, err := s.parseURL(i)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif url.Scheme == ice.SchemeTypeTURN || url.Scheme == ice.SchemeTypeTURNS {\n\t\t\treturn nil, errors.New(\"TURN is not currently supported in the JavaScript/Wasm bindings\")\n\t\t}\n\n\t\turls = append(urls, url)\n\t}\n\n\treturn urls, nil\n}\n"
        },
        {
          "name": "iceserver_test.go",
          "type": "blob",
          "size": 4.5517578125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/pion/stun/v3\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICEServer_validate(t *testing.T) {\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\ticeServer        ICEServer\n\t\t\texpectedValidate bool\n\t\t}{\n\t\t\t{ICEServer{\n\t\t\t\tURLs:           []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\t\tUsername:       \"unittest\",\n\t\t\t\tCredential:     \"placeholder\",\n\t\t\t\tCredentialType: ICECredentialTypePassword,\n\t\t\t}, true},\n\t\t\t{ICEServer{\n\t\t\t\tURLs:           []string{\"turn:[2001:db8:1234:5678::1]?transport=udp\"},\n\t\t\t\tUsername:       \"unittest\",\n\t\t\t\tCredential:     \"placeholder\",\n\t\t\t\tCredentialType: ICECredentialTypePassword,\n\t\t\t}, true},\n\t\t\t{ICEServer{\n\t\t\t\tURLs:     []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\t\tUsername: \"unittest\",\n\t\t\t\tCredential: OAuthCredential{\n\t\t\t\t\tMACKey:      \"WmtzanB3ZW9peFhtdm42NzUzNG0=\",\n\t\t\t\t\tAccessToken: \"AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ5VhNDgeMR3+ZlZ35byg972fW8QjpEl7bx91YLBPFsIhsxloWcXPhA==\",\n\t\t\t\t},\n\t\t\t\tCredentialType: ICECredentialTypeOauth,\n\t\t\t}, true},\n\t\t}\n\n\t\tfor i, testCase := range testCases {\n\t\t\tvar iceServer ICEServer\n\t\t\tjsonobj, err := json.Marshal(testCase.iceServer)\n\t\t\tassert.NoError(t, err)\n\t\t\terr = json.Unmarshal(jsonobj, &iceServer)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, iceServer, testCase.iceServer)\n\t\t\t_, err = testCase.iceServer.urls()\n\t\t\tassert.Nil(t, err, \"testCase: %d %v\", i, testCase)\n\t\t}\n\t})\n\tt.Run(\"Failure\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\ticeServer   ICEServer\n\t\t\texpectedErr error\n\t\t}{\n\t\t\t{ICEServer{\n\t\t\t\tURLs: []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\t}, &rtcerr.InvalidAccessError{Err: ErrNoTurnCredentials}},\n\t\t\t{ICEServer{\n\t\t\t\tURLs:           []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\t\tUsername:       \"unittest\",\n\t\t\t\tCredential:     false,\n\t\t\t\tCredentialType: ICECredentialTypePassword,\n\t\t\t}, &rtcerr.InvalidAccessError{Err: ErrTurnCredentials}},\n\t\t\t{ICEServer{\n\t\t\t\tURLs:           []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\t\tUsername:       \"unittest\",\n\t\t\t\tCredential:     false,\n\t\t\t\tCredentialType: ICECredentialTypeOauth,\n\t\t\t}, &rtcerr.InvalidAccessError{Err: ErrTurnCredentials}},\n\t\t\t{ICEServer{\n\t\t\t\tURLs:           []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\t\tUsername:       \"unittest\",\n\t\t\t\tCredential:     false,\n\t\t\t\tCredentialType: ICECredentialTypePassword,\n\t\t\t}, &rtcerr.InvalidAccessError{Err: ErrTurnCredentials}},\n\t\t\t{ICEServer{\n\t\t\t\tURLs:           []string{\"stun:google.de?transport=udp\"},\n\t\t\t\tUsername:       \"unittest\",\n\t\t\t\tCredential:     false,\n\t\t\t\tCredentialType: ICECredentialTypeOauth,\n\t\t\t}, &rtcerr.InvalidAccessError{Err: stun.ErrSTUNQuery}},\n\t\t}\n\n\t\tfor i, testCase := range testCases {\n\t\t\t_, err := testCase.iceServer.urls()\n\t\t\tassert.EqualError(t,\n\t\t\t\terr,\n\t\t\t\ttestCase.expectedErr.Error(),\n\t\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t\t)\n\t\t}\n\t})\n\tt.Run(\"JsonFailure\", func(t *testing.T) {\n\t\ttestCases := [][]byte{\n\t\t\t[]byte(`{\"urls\":\"NOTAURL\",\"username\":\"unittest\",\"credential\":\"placeholder\",\"credentialType\":\"password\"}`),\n\t\t\t[]byte(`{\"urls\":[\"turn:[2001:db8:1234:5678::1]?transport=udp\"],\"username\":\"unittest\",\"credential\":\"placeholder\",\"credentialType\":\"invalid\"}`),\n\t\t\t[]byte(`{\"urls\":[\"turn:[2001:db8:1234:5678::1]?transport=udp\"],\"username\":6,\"credential\":\"placeholder\",\"credentialType\":\"password\"}`),\n\t\t\t[]byte(`{\"urls\":[\"turn:192.158.29.39?transport=udp\"],\"username\":\"unittest\",\"credential\":{\"Bad Object\": true},\"credentialType\":\"oauth\"}`),\n\t\t\t[]byte(`{\"urls\":[\"turn:192.158.29.39?transport=udp\"],\"username\":\"unittest\",\"credential\":{\"MACKey\":\"WmtzanB3ZW9peFhtdm42NzUzNG0=\",\"AccessToken\":null,\"credentialType\":\"oauth\"}`),\n\t\t\t[]byte(`{\"urls\":[\"turn:192.158.29.39?transport=udp\"],\"username\":\"unittest\",\"credential\":{\"MACKey\":\"WmtzanB3ZW9peFhtdm42NzUzNG0=\",\"AccessToken\":null,\"credentialType\":\"password\"}`),\n\t\t\t[]byte(`{\"urls\":[\"turn:192.158.29.39?transport=udp\"],\"username\":\"unittest\",\"credential\":{\"MACKey\":1337,\"AccessToken\":\"AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ5VhNDgeMR3+ZlZ35byg972fW8QjpEl7bx91YLBPFsIhsxloWcXPhA==\"},\"credentialType\":\"oauth\"}`),\n\t\t}\n\t\tfor i, testCase := range testCases {\n\t\t\tvar tc ICEServer\n\t\t\terr := json.Unmarshal(testCase, &tc)\n\t\t\tassert.Error(t, err, \"testCase: %d %v\", i, string(testCase))\n\t\t}\n\t})\n}\n\nfunc TestICEServerZeroValue(t *testing.T) {\n\tserver := ICEServer{\n\t\tURLs:       []string{\"turn:galene.org:1195\"},\n\t\tUsername:   \"galene\",\n\t\tCredential: \"secret\",\n\t}\n\tassert.Equal(t, server.CredentialType, ICECredentialTypePassword)\n}\n"
        },
        {
          "name": "icetransport.go",
          "type": "blob",
          "size": 10.416015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/webrtc/v4/internal/mux\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n)\n\n// ICETransport allows an application access to information about the ICE\n// transport over which packets are sent and received.\ntype ICETransport struct {\n\tlock sync.RWMutex\n\n\trole ICERole\n\n\tonConnectionStateChangeHandler         atomic.Value // func(ICETransportState)\n\tinternalOnConnectionStateChangeHandler atomic.Value // func(ICETransportState)\n\tonSelectedCandidatePairChangeHandler   atomic.Value // func(*ICECandidatePair)\n\n\tstate atomic.Value // ICETransportState\n\n\tgatherer *ICEGatherer\n\tconn     *ice.Conn\n\tmux      *mux.Mux\n\n\tctx       context.Context\n\tctxCancel func()\n\n\tloggerFactory logging.LoggerFactory\n\n\tlog logging.LeveledLogger\n}\n\n// GetSelectedCandidatePair returns the selected candidate pair on which packets are sent\n// if there is no selected pair nil is returned\nfunc (t *ICETransport) GetSelectedCandidatePair() (*ICECandidatePair, error) {\n\tagent := t.gatherer.getAgent()\n\tif agent == nil {\n\t\treturn nil, nil //nolint:nilnil\n\t}\n\n\ticePair, err := agent.GetSelectedCandidatePair()\n\tif icePair == nil || err != nil {\n\t\treturn nil, err\n\t}\n\n\tlocal, err := newICECandidateFromICE(icePair.Local, \"\", 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tremote, err := newICECandidateFromICE(icePair.Remote, \"\", 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewICECandidatePair(&local, &remote), nil\n}\n\n// GetSelectedCandidatePairStats returns the selected candidate pair stats on which packets are sent\n// if there is no selected pair empty stats, false is returned to indicate stats not available\nfunc (t *ICETransport) GetSelectedCandidatePairStats() (ICECandidatePairStats, bool) {\n\treturn t.gatherer.getSelectedCandidatePairStats()\n}\n\n// NewICETransport creates a new NewICETransport.\nfunc NewICETransport(gatherer *ICEGatherer, loggerFactory logging.LoggerFactory) *ICETransport {\n\ticeTransport := &ICETransport{\n\t\tgatherer:      gatherer,\n\t\tloggerFactory: loggerFactory,\n\t\tlog:           loggerFactory.NewLogger(\"ortc\"),\n\t}\n\ticeTransport.setState(ICETransportStateNew)\n\treturn iceTransport\n}\n\n// Start incoming connectivity checks based on its configured role.\nfunc (t *ICETransport) Start(gatherer *ICEGatherer, params ICEParameters, role *ICERole) error {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\n\tif t.State() != ICETransportStateNew {\n\t\treturn errICETransportNotInNew\n\t}\n\n\tif gatherer != nil {\n\t\tt.gatherer = gatherer\n\t}\n\n\tif err := t.ensureGatherer(); err != nil {\n\t\treturn err\n\t}\n\n\tagent := t.gatherer.getAgent()\n\tif agent == nil {\n\t\treturn fmt.Errorf(\"%w: unable to start ICETransport\", errICEAgentNotExist)\n\t}\n\n\tif err := agent.OnConnectionStateChange(func(iceState ice.ConnectionState) {\n\t\tstate := newICETransportStateFromICE(iceState)\n\n\t\tt.setState(state)\n\t\tt.onConnectionStateChange(state)\n\t}); err != nil {\n\t\treturn err\n\t}\n\tif err := agent.OnSelectedCandidatePairChange(func(local, remote ice.Candidate) {\n\t\tcandidates, err := newICECandidatesFromICE([]ice.Candidate{local, remote}, \"\", 0)\n\t\tif err != nil {\n\t\t\tt.log.Warnf(\"%w: %s\", errICECandiatesCoversionFailed, err)\n\t\t\treturn\n\t\t}\n\t\tt.onSelectedCandidatePairChange(NewICECandidatePair(&candidates[0], &candidates[1]))\n\t}); err != nil {\n\t\treturn err\n\t}\n\n\tif role == nil {\n\t\tcontrolled := ICERoleControlled\n\t\trole = &controlled\n\t}\n\tt.role = *role\n\n\tt.ctx, t.ctxCancel = context.WithCancel(context.Background())\n\n\t// Drop the lock here to allow ICE candidates to be\n\t// added so that the agent can complete a connection\n\tt.lock.Unlock()\n\n\tvar iceConn *ice.Conn\n\tvar err error\n\tswitch *role {\n\tcase ICERoleControlling:\n\t\ticeConn, err = agent.Dial(t.ctx,\n\t\t\tparams.UsernameFragment,\n\t\t\tparams.Password)\n\n\tcase ICERoleControlled:\n\t\ticeConn, err = agent.Accept(t.ctx,\n\t\t\tparams.UsernameFragment,\n\t\t\tparams.Password)\n\n\tdefault:\n\t\terr = errICERoleUnknown\n\t}\n\n\t// Reacquire the lock to set the connection/mux\n\tt.lock.Lock()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif t.State() == ICETransportStateClosed {\n\t\treturn errICETransportClosed\n\t}\n\n\tt.conn = iceConn\n\n\tconfig := mux.Config{\n\t\tConn:          t.conn,\n\t\tBufferSize:    int(t.gatherer.api.settingEngine.getReceiveMTU()),\n\t\tLoggerFactory: t.loggerFactory,\n\t}\n\tt.mux = mux.NewMux(config)\n\n\treturn nil\n}\n\n// restart is not exposed currently because ORTC has users create a whole new ICETransport\n// so for now lets keep it private so we don't cause ORTC users to depend on non-standard APIs\nfunc (t *ICETransport) restart() error {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\n\tagent := t.gatherer.getAgent()\n\tif agent == nil {\n\t\treturn fmt.Errorf(\"%w: unable to restart ICETransport\", errICEAgentNotExist)\n\t}\n\n\tif err := agent.Restart(t.gatherer.api.settingEngine.candidates.UsernameFragment, t.gatherer.api.settingEngine.candidates.Password); err != nil {\n\t\treturn err\n\t}\n\treturn t.gatherer.Gather()\n}\n\n// Stop irreversibly stops the ICETransport.\nfunc (t *ICETransport) Stop() error {\n\treturn t.stop(false /* shouldGracefullyClose */)\n}\n\n// GracefulStop irreversibly stops the ICETransport. It also waits\n// for any goroutines it started to complete. This is only safe to call outside of\n// ICETransport callbacks or if in a callback, in its own goroutine.\nfunc (t *ICETransport) GracefulStop() error {\n\treturn t.stop(true /* shouldGracefullyClose */)\n}\n\nfunc (t *ICETransport) stop(shouldGracefullyClose bool) error {\n\tt.lock.Lock()\n\tt.setState(ICETransportStateClosed)\n\n\tif t.ctxCancel != nil {\n\t\tt.ctxCancel()\n\t}\n\n\t// mux and gatherer can only be set when ICETransport.State != Closed.\n\tmux := t.mux\n\tgatherer := t.gatherer\n\tt.lock.Unlock()\n\n\tif mux != nil {\n\t\tvar closeErrs []error\n\t\tif shouldGracefullyClose && gatherer != nil {\n\t\t\t// we can't access icegatherer/icetransport.Close via\n\t\t\t// mux's net.Conn Close so we call it earlier here.\n\t\t\tcloseErrs = append(closeErrs, gatherer.GracefulClose())\n\t\t}\n\t\tcloseErrs = append(closeErrs, mux.Close())\n\t\treturn util.FlattenErrs(closeErrs)\n\t} else if gatherer != nil {\n\t\tif shouldGracefullyClose {\n\t\t\treturn gatherer.GracefulClose()\n\t\t}\n\t\treturn gatherer.Close()\n\t}\n\treturn nil\n}\n\n// OnSelectedCandidatePairChange sets a handler that is invoked when a new\n// ICE candidate pair is selected\nfunc (t *ICETransport) OnSelectedCandidatePairChange(f func(*ICECandidatePair)) {\n\tt.onSelectedCandidatePairChangeHandler.Store(f)\n}\n\nfunc (t *ICETransport) onSelectedCandidatePairChange(pair *ICECandidatePair) {\n\tif handler, ok := t.onSelectedCandidatePairChangeHandler.Load().(func(*ICECandidatePair)); ok {\n\t\thandler(pair)\n\t}\n}\n\n// OnConnectionStateChange sets a handler that is fired when the ICE\n// connection state changes.\nfunc (t *ICETransport) OnConnectionStateChange(f func(ICETransportState)) {\n\tt.onConnectionStateChangeHandler.Store(f)\n}\n\nfunc (t *ICETransport) onConnectionStateChange(state ICETransportState) {\n\tif handler, ok := t.onConnectionStateChangeHandler.Load().(func(ICETransportState)); ok {\n\t\thandler(state)\n\t}\n\tif handler, ok := t.internalOnConnectionStateChangeHandler.Load().(func(ICETransportState)); ok {\n\t\thandler(state)\n\t}\n}\n\n// Role indicates the current role of the ICE transport.\nfunc (t *ICETransport) Role() ICERole {\n\tt.lock.RLock()\n\tdefer t.lock.RUnlock()\n\n\treturn t.role\n}\n\n// SetRemoteCandidates sets the sequence of candidates associated with the remote ICETransport.\nfunc (t *ICETransport) SetRemoteCandidates(remoteCandidates []ICECandidate) error {\n\tt.lock.RLock()\n\tdefer t.lock.RUnlock()\n\n\tif err := t.ensureGatherer(); err != nil {\n\t\treturn err\n\t}\n\n\tagent := t.gatherer.getAgent()\n\tif agent == nil {\n\t\treturn fmt.Errorf(\"%w: unable to set remote candidates\", errICEAgentNotExist)\n\t}\n\n\tfor _, c := range remoteCandidates {\n\t\ti, err := c.toICE()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err = agent.AddRemoteCandidate(i); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// AddRemoteCandidate adds a candidate associated with the remote ICETransport.\nfunc (t *ICETransport) AddRemoteCandidate(remoteCandidate *ICECandidate) error {\n\tt.lock.RLock()\n\tdefer t.lock.RUnlock()\n\n\tvar (\n\t\tc   ice.Candidate\n\t\terr error\n\t)\n\n\tif err = t.ensureGatherer(); err != nil {\n\t\treturn err\n\t}\n\n\tif remoteCandidate != nil {\n\t\tif c, err = remoteCandidate.toICE(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tagent := t.gatherer.getAgent()\n\tif agent == nil {\n\t\treturn fmt.Errorf(\"%w: unable to add remote candidates\", errICEAgentNotExist)\n\t}\n\n\treturn agent.AddRemoteCandidate(c)\n}\n\n// State returns the current ice transport state.\nfunc (t *ICETransport) State() ICETransportState {\n\tif v, ok := t.state.Load().(ICETransportState); ok {\n\t\treturn v\n\t}\n\treturn ICETransportState(0)\n}\n\n// GetLocalParameters returns an IceParameters object which provides information\n// uniquely identifying the local peer for the duration of the ICE session.\nfunc (t *ICETransport) GetLocalParameters() (ICEParameters, error) {\n\tif err := t.ensureGatherer(); err != nil {\n\t\treturn ICEParameters{}, err\n\t}\n\n\treturn t.gatherer.GetLocalParameters()\n}\n\nfunc (t *ICETransport) setState(i ICETransportState) {\n\tt.state.Store(i)\n}\n\nfunc (t *ICETransport) newEndpoint(f mux.MatchFunc) *mux.Endpoint {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\treturn t.mux.NewEndpoint(f)\n}\n\nfunc (t *ICETransport) ensureGatherer() error {\n\tif t.gatherer == nil {\n\t\treturn errICEGathererNotStarted\n\t} else if t.gatherer.getAgent() == nil {\n\t\tif err := t.gatherer.createAgent(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (t *ICETransport) collectStats(collector *statsReportCollector) {\n\tt.lock.Lock()\n\tconn := t.conn\n\tt.lock.Unlock()\n\n\tcollector.Collecting()\n\n\tstats := TransportStats{\n\t\tTimestamp: statsTimestampFrom(time.Now()),\n\t\tType:      StatsTypeTransport,\n\t\tID:        \"iceTransport\",\n\t}\n\n\tif conn != nil {\n\t\tstats.BytesSent = conn.BytesSent()\n\t\tstats.BytesReceived = conn.BytesReceived()\n\t}\n\n\tcollector.Collect(stats.ID, stats)\n}\n\nfunc (t *ICETransport) haveRemoteCredentialsChange(newUfrag, newPwd string) bool {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\n\tagent := t.gatherer.getAgent()\n\tif agent == nil {\n\t\treturn false\n\t}\n\n\tuFrag, uPwd, err := agent.GetRemoteUserCredentials()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn uFrag != newUfrag || uPwd != newPwd\n}\n\nfunc (t *ICETransport) setRemoteCredentials(newUfrag, newPwd string) error {\n\tt.lock.Lock()\n\tdefer t.lock.Unlock()\n\n\tagent := t.gatherer.getAgent()\n\tif agent == nil {\n\t\treturn fmt.Errorf(\"%w: unable to SetRemoteCredentials\", errICEAgentNotExist)\n\t}\n\n\treturn agent.SetRemoteCredentials(newUfrag, newPwd)\n}\n"
        },
        {
          "name": "icetransport_js.go",
          "type": "blob",
          "size": 0.8564453125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport \"syscall/js\"\n\n// ICETransport allows an application access to information about the ICE\n// transport over which packets are sent and received.\ntype ICETransport struct {\n\t// Pointer to the underlying JavaScript ICETransport object.\n\tunderlying js.Value\n}\n\n// GetSelectedCandidatePair returns the selected candidate pair on which packets are sent\n// if there is no selected pair nil is returned\nfunc (t *ICETransport) GetSelectedCandidatePair() (*ICECandidatePair, error) {\n\tval := t.underlying.Call(\"getSelectedCandidatePair\")\n\tif val.IsNull() || val.IsUndefined() {\n\t\treturn nil, nil\n\t}\n\n\treturn NewICECandidatePair(\n\t\tvalueToICECandidate(val.Get(\"local\")),\n\t\tvalueToICECandidate(val.Get(\"remote\")),\n\t), nil\n}\n"
        },
        {
          "name": "icetransport_test.go",
          "type": "blob",
          "size": 4.158203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICETransport_OnConnectionStateChange(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\tvar (\n\t\ticeComplete             sync.WaitGroup\n\t\tpeerConnectionConnected sync.WaitGroup\n\t)\n\ticeComplete.Add(2)\n\tpeerConnectionConnected.Add(2)\n\n\tonIceComplete := func(s ICETransportState) {\n\t\tif s == ICETransportStateConnected {\n\t\t\ticeComplete.Done()\n\t\t}\n\t}\n\tpcOffer.SCTP().Transport().ICETransport().OnConnectionStateChange(onIceComplete)\n\tpcAnswer.SCTP().Transport().ICETransport().OnConnectionStateChange(onIceComplete)\n\n\tonConnected := func(s PeerConnectionState) {\n\t\tif s == PeerConnectionStateConnected {\n\t\t\tpeerConnectionConnected.Done()\n\t\t}\n\t}\n\tpcOffer.OnConnectionStateChange(onConnected)\n\tpcAnswer.OnConnectionStateChange(onConnected)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\ticeComplete.Wait()\n\tpeerConnectionConnected.Wait()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestICETransport_OnSelectedCandidatePairChange(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\ticeComplete := make(chan bool)\n\tpcAnswer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {\n\t\tif iceState == ICEConnectionStateConnected {\n\t\t\ttime.Sleep(3 * time.Second)\n\t\t\tclose(iceComplete)\n\t\t}\n\t})\n\n\tsenderCalledCandidateChange := int32(0)\n\tpcOffer.SCTP().Transport().ICETransport().OnSelectedCandidatePairChange(func(*ICECandidatePair) {\n\t\tatomic.StoreInt32(&senderCalledCandidateChange, 1)\n\t})\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\t<-iceComplete\n\n\tif atomic.LoadInt32(&senderCalledCandidateChange) == 0 {\n\t\tt.Fatalf(\"Sender ICETransport OnSelectedCandidateChange was never called\")\n\t}\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestICETransport_GetSelectedCandidatePair(t *testing.T) {\n\tofferer, answerer, err := newPair()\n\tassert.NoError(t, err)\n\n\tpeerConnectionConnected := untilConnectionState(PeerConnectionStateConnected, offerer, answerer)\n\n\toffererSelectedPair, err := offerer.SCTP().Transport().ICETransport().GetSelectedCandidatePair()\n\tassert.NoError(t, err)\n\tassert.Nil(t, offererSelectedPair)\n\t_, statsAvailable := offerer.SCTP().Transport().ICETransport().GetSelectedCandidatePairStats()\n\tassert.False(t, statsAvailable)\n\n\tanswererSelectedPair, err := answerer.SCTP().Transport().ICETransport().GetSelectedCandidatePair()\n\tassert.NoError(t, err)\n\tassert.Nil(t, answererSelectedPair)\n\t_, statsAvailable = answerer.SCTP().Transport().ICETransport().GetSelectedCandidatePairStats()\n\tassert.False(t, statsAvailable)\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\tpeerConnectionConnected.Wait()\n\n\toffererSelectedPair, err = offerer.SCTP().Transport().ICETransport().GetSelectedCandidatePair()\n\tassert.NoError(t, err)\n\tassert.NotNil(t, offererSelectedPair)\n\t_, statsAvailable = offerer.SCTP().Transport().ICETransport().GetSelectedCandidatePairStats()\n\tassert.True(t, statsAvailable)\n\n\tanswererSelectedPair, err = answerer.SCTP().Transport().ICETransport().GetSelectedCandidatePair()\n\tassert.NoError(t, err)\n\tassert.NotNil(t, answererSelectedPair)\n\t_, statsAvailable = answerer.SCTP().Transport().ICETransport().GetSelectedCandidatePairStats()\n\tassert.True(t, statsAvailable)\n\n\tclosePairNow(t, offerer, answerer)\n}\n\nfunc TestICETransport_GetLocalParameters(t *testing.T) {\n\tofferer, answerer, err := newPair()\n\tassert.NoError(t, err)\n\n\tpeerConnectionConnected := untilConnectionState(PeerConnectionStateConnected, offerer, answerer)\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\tpeerConnectionConnected.Wait()\n\n\tlocalParameters, err := offerer.SCTP().Transport().ICETransport().GetLocalParameters()\n\tassert.NoError(t, err)\n\tassert.NotEqual(t, localParameters.UsernameFragment, \"\")\n\tassert.NotEqual(t, localParameters.Password, \"\")\n\n\tclosePairNow(t, offerer, answerer)\n}\n"
        },
        {
          "name": "icetransportpolicy.go",
          "type": "blob",
          "size": 1.69921875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n)\n\n// ICETransportPolicy defines the ICE candidate policy surface the\n// permitted candidates. Only these candidates are used for connectivity checks.\ntype ICETransportPolicy int\n\n// ICEGatherPolicy is the ORTC equivalent of ICETransportPolicy\ntype ICEGatherPolicy = ICETransportPolicy\n\nconst (\n\t// ICETransportPolicyAll indicates any type of candidate is used.\n\tICETransportPolicyAll ICETransportPolicy = iota\n\n\t// ICETransportPolicyRelay indicates only media relay candidates such\n\t// as candidates passing through a TURN server are used.\n\tICETransportPolicyRelay\n)\n\n// This is done this way because of a linter.\nconst (\n\ticeTransportPolicyRelayStr = \"relay\"\n\ticeTransportPolicyAllStr   = \"all\"\n)\n\n// NewICETransportPolicy takes a string and converts it to ICETransportPolicy\nfunc NewICETransportPolicy(raw string) ICETransportPolicy {\n\tswitch raw {\n\tcase iceTransportPolicyRelayStr:\n\t\treturn ICETransportPolicyRelay\n\tdefault:\n\t\treturn ICETransportPolicyAll\n\t}\n}\n\nfunc (t ICETransportPolicy) String() string {\n\tswitch t {\n\tcase ICETransportPolicyRelay:\n\t\treturn iceTransportPolicyRelayStr\n\tcase ICETransportPolicyAll:\n\t\treturn iceTransportPolicyAllStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// UnmarshalJSON parses the JSON-encoded data and stores the result\nfunc (t *ICETransportPolicy) UnmarshalJSON(b []byte) error {\n\tvar val string\n\tif err := json.Unmarshal(b, &val); err != nil {\n\t\treturn err\n\t}\n\t*t = NewICETransportPolicy(val)\n\treturn nil\n}\n\n// MarshalJSON returns the JSON encoding\nfunc (t ICETransportPolicy) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(t.String())\n}\n"
        },
        {
          "name": "icetransportpolicy_test.go",
          "type": "blob",
          "size": 0.9208984375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewICETransportPolicy(t *testing.T) {\n\ttestCases := []struct {\n\t\tpolicyString   string\n\t\texpectedPolicy ICETransportPolicy\n\t}{\n\t\t{\"relay\", ICETransportPolicyRelay},\n\t\t{\"all\", ICETransportPolicyAll},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedPolicy,\n\t\t\tNewICETransportPolicy(testCase.policyString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICETransportPolicy_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tpolicy         ICETransportPolicy\n\t\texpectedString string\n\t}{\n\t\t{ICETransportPolicyRelay, \"relay\"},\n\t\t{ICETransportPolicyAll, \"all\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.policy.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "icetransportstate.go",
          "type": "blob",
          "size": 4.861328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport \"github.com/pion/ice/v4\"\n\n// ICETransportState represents the current state of the ICE transport.\ntype ICETransportState int\n\nconst (\n\t// ICETransportStateUnknown is the enum's zero-value\n\tICETransportStateUnknown ICETransportState = iota\n\n\t// ICETransportStateNew indicates the ICETransport is waiting\n\t// for remote candidates to be supplied.\n\tICETransportStateNew\n\n\t// ICETransportStateChecking indicates the ICETransport has\n\t// received at least one remote candidate, and a local and remote\n\t// ICECandidateComplete dictionary was not added as the last candidate.\n\tICETransportStateChecking\n\n\t// ICETransportStateConnected indicates the ICETransport has\n\t// received a response to an outgoing connectivity check, or has\n\t// received incoming DTLS/media after a successful response to an\n\t// incoming connectivity check, but is still checking other candidate\n\t// pairs to see if there is a better connection.\n\tICETransportStateConnected\n\n\t// ICETransportStateCompleted indicates the ICETransport tested\n\t// all appropriate candidate pairs and at least one functioning\n\t// candidate pair has been found.\n\tICETransportStateCompleted\n\n\t// ICETransportStateFailed indicates the ICETransport the last\n\t// candidate was added and all appropriate candidate pairs have either\n\t// failed connectivity checks or have lost consent.\n\tICETransportStateFailed\n\n\t// ICETransportStateDisconnected indicates the ICETransport has received\n\t// at least one local and remote candidate, but the final candidate was\n\t// received yet and all appropriate candidate pairs thus far have been\n\t// tested and failed.\n\tICETransportStateDisconnected\n\n\t// ICETransportStateClosed indicates the ICETransport has shut down\n\t// and is no longer responding to STUN requests.\n\tICETransportStateClosed\n)\n\nconst (\n\ticeTransportStateNewStr          = \"new\"\n\ticeTransportStateCheckingStr     = \"checking\"\n\ticeTransportStateConnectedStr    = \"connected\"\n\ticeTransportStateCompletedStr    = \"completed\"\n\ticeTransportStateFailedStr       = \"failed\"\n\ticeTransportStateDisconnectedStr = \"disconnected\"\n\ticeTransportStateClosedStr       = \"closed\"\n)\n\nfunc newICETransportState(raw string) ICETransportState {\n\tswitch raw {\n\tcase iceTransportStateNewStr:\n\t\treturn ICETransportStateNew\n\tcase iceTransportStateCheckingStr:\n\t\treturn ICETransportStateChecking\n\tcase iceTransportStateConnectedStr:\n\t\treturn ICETransportStateConnected\n\tcase iceTransportStateCompletedStr:\n\t\treturn ICETransportStateCompleted\n\tcase iceTransportStateFailedStr:\n\t\treturn ICETransportStateFailed\n\tcase iceTransportStateDisconnectedStr:\n\t\treturn ICETransportStateDisconnected\n\tcase iceTransportStateClosedStr:\n\t\treturn ICETransportStateClosed\n\tdefault:\n\t\treturn ICETransportStateUnknown\n\t}\n}\n\nfunc (c ICETransportState) String() string {\n\tswitch c {\n\tcase ICETransportStateNew:\n\t\treturn iceTransportStateNewStr\n\tcase ICETransportStateChecking:\n\t\treturn iceTransportStateCheckingStr\n\tcase ICETransportStateConnected:\n\t\treturn iceTransportStateConnectedStr\n\tcase ICETransportStateCompleted:\n\t\treturn iceTransportStateCompletedStr\n\tcase ICETransportStateFailed:\n\t\treturn iceTransportStateFailedStr\n\tcase ICETransportStateDisconnected:\n\t\treturn iceTransportStateDisconnectedStr\n\tcase ICETransportStateClosed:\n\t\treturn iceTransportStateClosedStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\nfunc newICETransportStateFromICE(i ice.ConnectionState) ICETransportState {\n\tswitch i {\n\tcase ice.ConnectionStateNew:\n\t\treturn ICETransportStateNew\n\tcase ice.ConnectionStateChecking:\n\t\treturn ICETransportStateChecking\n\tcase ice.ConnectionStateConnected:\n\t\treturn ICETransportStateConnected\n\tcase ice.ConnectionStateCompleted:\n\t\treturn ICETransportStateCompleted\n\tcase ice.ConnectionStateFailed:\n\t\treturn ICETransportStateFailed\n\tcase ice.ConnectionStateDisconnected:\n\t\treturn ICETransportStateDisconnected\n\tcase ice.ConnectionStateClosed:\n\t\treturn ICETransportStateClosed\n\tdefault:\n\t\treturn ICETransportStateUnknown\n\t}\n}\n\nfunc (c ICETransportState) toICE() ice.ConnectionState {\n\tswitch c {\n\tcase ICETransportStateNew:\n\t\treturn ice.ConnectionStateNew\n\tcase ICETransportStateChecking:\n\t\treturn ice.ConnectionStateChecking\n\tcase ICETransportStateConnected:\n\t\treturn ice.ConnectionStateConnected\n\tcase ICETransportStateCompleted:\n\t\treturn ice.ConnectionStateCompleted\n\tcase ICETransportStateFailed:\n\t\treturn ice.ConnectionStateFailed\n\tcase ICETransportStateDisconnected:\n\t\treturn ice.ConnectionStateDisconnected\n\tcase ICETransportStateClosed:\n\t\treturn ice.ConnectionStateClosed\n\tdefault:\n\t\treturn ice.ConnectionStateUnknown\n\t}\n}\n\n// MarshalText implements encoding.TextMarshaler\nfunc (c ICETransportState) MarshalText() ([]byte, error) {\n\treturn []byte(c.String()), nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler\nfunc (c *ICETransportState) UnmarshalText(b []byte) error {\n\t*c = newICETransportState(string(b))\n\treturn nil\n}\n"
        },
        {
          "name": "icetransportstate_test.go",
          "type": "blob",
          "size": 1.693359375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestICETransportState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          ICETransportState\n\t\texpectedString string\n\t}{\n\t\t{ICETransportStateUnknown, ErrUnknownType.Error()},\n\t\t{ICETransportStateNew, \"new\"},\n\t\t{ICETransportStateChecking, \"checking\"},\n\t\t{ICETransportStateConnected, \"connected\"},\n\t\t{ICETransportStateCompleted, \"completed\"},\n\t\t{ICETransportStateFailed, \"failed\"},\n\t\t{ICETransportStateDisconnected, \"disconnected\"},\n\t\t{ICETransportStateClosed, \"closed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestICETransportState_Convert(t *testing.T) {\n\ttestCases := []struct {\n\t\tnative ICETransportState\n\t\tice    ice.ConnectionState\n\t}{\n\t\t{ICETransportStateUnknown, ice.ConnectionStateUnknown},\n\t\t{ICETransportStateNew, ice.ConnectionStateNew},\n\t\t{ICETransportStateChecking, ice.ConnectionStateChecking},\n\t\t{ICETransportStateConnected, ice.ConnectionStateConnected},\n\t\t{ICETransportStateCompleted, ice.ConnectionStateCompleted},\n\t\t{ICETransportStateFailed, ice.ConnectionStateFailed},\n\t\t{ICETransportStateDisconnected, ice.ConnectionStateDisconnected},\n\t\t{ICETransportStateClosed, ice.ConnectionStateClosed},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.native.toICE(),\n\t\t\ttestCase.ice,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t\tassert.Equal(t,\n\t\t\ttestCase.native,\n\t\t\tnewICETransportStateFromICE(testCase.ice),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "interceptor.go",
          "type": "blob",
          "size": 6.8466796875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"sync/atomic\"\n\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/interceptor/pkg/nack\"\n\t\"github.com/pion/interceptor/pkg/report\"\n\t\"github.com/pion/interceptor/pkg/rfc8888\"\n\t\"github.com/pion/interceptor/pkg/twcc\"\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/sdp/v3\"\n)\n\n// RegisterDefaultInterceptors will register some useful interceptors.\n// If you want to customize which interceptors are loaded, you should copy the\n// code from this method and remove unwanted interceptors.\nfunc RegisterDefaultInterceptors(mediaEngine *MediaEngine, interceptorRegistry *interceptor.Registry) error {\n\tif err := ConfigureNack(mediaEngine, interceptorRegistry); err != nil {\n\t\treturn err\n\t}\n\n\tif err := ConfigureRTCPReports(interceptorRegistry); err != nil {\n\t\treturn err\n\t}\n\n\tif err := ConfigureSimulcastExtensionHeaders(mediaEngine); err != nil {\n\t\treturn err\n\t}\n\n\treturn ConfigureTWCCSender(mediaEngine, interceptorRegistry)\n}\n\n// ConfigureRTCPReports will setup everything necessary for generating Sender and Receiver Reports\nfunc ConfigureRTCPReports(interceptorRegistry *interceptor.Registry) error {\n\treciver, err := report.NewReceiverInterceptor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsender, err := report.NewSenderInterceptor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinterceptorRegistry.Add(reciver)\n\tinterceptorRegistry.Add(sender)\n\treturn nil\n}\n\n// ConfigureNack will setup everything necessary for handling generating/responding to nack messages.\nfunc ConfigureNack(mediaEngine *MediaEngine, interceptorRegistry *interceptor.Registry) error {\n\tgenerator, err := nack.NewGeneratorInterceptor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresponder, err := nack.NewResponderInterceptor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmediaEngine.RegisterFeedback(RTCPFeedback{Type: \"nack\"}, RTPCodecTypeVideo)\n\tmediaEngine.RegisterFeedback(RTCPFeedback{Type: \"nack\", Parameter: \"pli\"}, RTPCodecTypeVideo)\n\tinterceptorRegistry.Add(responder)\n\tinterceptorRegistry.Add(generator)\n\treturn nil\n}\n\n// ConfigureTWCCHeaderExtensionSender will setup everything necessary for adding\n// a TWCC header extension to outgoing RTP packets. This will allow the remote peer to generate TWCC reports.\nfunc ConfigureTWCCHeaderExtensionSender(mediaEngine *MediaEngine, interceptorRegistry *interceptor.Registry) error {\n\tif err := mediaEngine.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdp.TransportCCURI}, RTPCodecTypeVideo); err != nil {\n\t\treturn err\n\t}\n\n\tif err := mediaEngine.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdp.TransportCCURI}, RTPCodecTypeAudio); err != nil {\n\t\treturn err\n\t}\n\n\ti, err := twcc.NewHeaderExtensionInterceptor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinterceptorRegistry.Add(i)\n\treturn nil\n}\n\n// ConfigureTWCCSender will setup everything necessary for generating TWCC reports.\n// This must be called after registering codecs with the MediaEngine.\nfunc ConfigureTWCCSender(mediaEngine *MediaEngine, interceptorRegistry *interceptor.Registry) error {\n\tmediaEngine.RegisterFeedback(RTCPFeedback{Type: TypeRTCPFBTransportCC}, RTPCodecTypeVideo)\n\tif err := mediaEngine.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdp.TransportCCURI}, RTPCodecTypeVideo); err != nil {\n\t\treturn err\n\t}\n\n\tmediaEngine.RegisterFeedback(RTCPFeedback{Type: TypeRTCPFBTransportCC}, RTPCodecTypeAudio)\n\tif err := mediaEngine.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdp.TransportCCURI}, RTPCodecTypeAudio); err != nil {\n\t\treturn err\n\t}\n\n\tgenerator, err := twcc.NewSenderInterceptor()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinterceptorRegistry.Add(generator)\n\treturn nil\n}\n\n// ConfigureCongestionControlFeedback registers congestion control feedback as\n// defined in RFC 8888 (https://datatracker.ietf.org/doc/rfc8888/)\nfunc ConfigureCongestionControlFeedback(mediaEngine *MediaEngine, interceptorRegistry *interceptor.Registry) error {\n\tmediaEngine.RegisterFeedback(RTCPFeedback{Type: TypeRTCPFBACK, Parameter: \"ccfb\"}, RTPCodecTypeVideo)\n\tmediaEngine.RegisterFeedback(RTCPFeedback{Type: TypeRTCPFBACK, Parameter: \"ccfb\"}, RTPCodecTypeAudio)\n\tgenerator, err := rfc8888.NewSenderInterceptor()\n\tif err != nil {\n\t\treturn err\n\t}\n\tinterceptorRegistry.Add(generator)\n\treturn nil\n}\n\n// ConfigureSimulcastExtensionHeaders enables the RTP Extension Headers needed for Simulcast\nfunc ConfigureSimulcastExtensionHeaders(mediaEngine *MediaEngine) error {\n\tif err := mediaEngine.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdp.SDESMidURI}, RTPCodecTypeVideo); err != nil {\n\t\treturn err\n\t}\n\n\tif err := mediaEngine.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdp.SDESRTPStreamIDURI}, RTPCodecTypeVideo); err != nil {\n\t\treturn err\n\t}\n\n\treturn mediaEngine.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdesRepairRTPStreamIDURI}, RTPCodecTypeVideo)\n}\n\ntype interceptorToTrackLocalWriter struct{ interceptor atomic.Value } // interceptor.RTPWriter }\n\nfunc (i *interceptorToTrackLocalWriter) WriteRTP(header *rtp.Header, payload []byte) (int, error) {\n\tif writer, ok := i.interceptor.Load().(interceptor.RTPWriter); ok && writer != nil {\n\t\treturn writer.Write(header, payload, interceptor.Attributes{})\n\t}\n\n\treturn 0, nil\n}\n\nfunc (i *interceptorToTrackLocalWriter) Write(b []byte) (int, error) {\n\tpacket := &rtp.Packet{}\n\tif err := packet.Unmarshal(b); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn i.WriteRTP(&packet.Header, packet.Payload)\n}\n\n// nolint: unparam\nfunc createStreamInfo(id string, ssrc, ssrcRTX, ssrcFEC SSRC, payloadType, payloadTypeRTX, payloadTypeFEC PayloadType, codec RTPCodecCapability, webrtcHeaderExtensions []RTPHeaderExtensionParameter) *interceptor.StreamInfo {\n\theaderExtensions := make([]interceptor.RTPHeaderExtension, 0, len(webrtcHeaderExtensions))\n\tfor _, h := range webrtcHeaderExtensions {\n\t\theaderExtensions = append(headerExtensions, interceptor.RTPHeaderExtension{ID: h.ID, URI: h.URI})\n\t}\n\n\tfeedbacks := make([]interceptor.RTCPFeedback, 0, len(codec.RTCPFeedback))\n\tfor _, f := range codec.RTCPFeedback {\n\t\tfeedbacks = append(feedbacks, interceptor.RTCPFeedback{Type: f.Type, Parameter: f.Parameter})\n\t}\n\n\treturn &interceptor.StreamInfo{\n\t\tID:                                id,\n\t\tAttributes:                        interceptor.Attributes{},\n\t\tSSRC:                              uint32(ssrc),\n\t\tSSRCRetransmission:                uint32(ssrcRTX),\n\t\tSSRCForwardErrorCorrection:        uint32(ssrcFEC),\n\t\tPayloadType:                       uint8(payloadType),\n\t\tPayloadTypeRetransmission:         uint8(payloadTypeRTX),\n\t\tPayloadTypeForwardErrorCorrection: uint8(payloadTypeFEC),\n\t\tRTPHeaderExtensions:               headerExtensions,\n\t\tMimeType:                          codec.MimeType,\n\t\tClockRate:                         codec.ClockRate,\n\t\tChannels:                          codec.Channels,\n\t\tSDPFmtpLine:                       codec.SDPFmtpLine,\n\t\tRTCPFeedback:                      feedbacks,\n\t}\n}\n"
        },
        {
          "name": "interceptor_test.go",
          "type": "blob",
          "size": 11.7685546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\n//\nimport (\n\t\"context\"\n\t\"io\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/interceptor\"\n\tmock_interceptor \"github.com/pion/interceptor/pkg/mock\"\n\t\"github.com/pion/rtcp\"\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// E2E test of the features of Interceptors\n// * Assert an extension can be set on an outbound packet\n// * Assert an extension can be read on an outbound packet\n// * Assert that attributes set by an interceptor are returned to the Reader\nfunc TestPeerConnection_Interceptor(t *testing.T) {\n\tto := test.TimeOut(time.Second * 20)\n\tdefer to.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tcreatePC := func() *PeerConnection {\n\t\tir := &interceptor.Registry{}\n\t\tir.Add(&mock_interceptor.Factory{\n\t\t\tNewInterceptorFn: func(_ string) (interceptor.Interceptor, error) {\n\t\t\t\treturn &mock_interceptor.Interceptor{\n\t\t\t\t\tBindLocalStreamFn: func(_ *interceptor.StreamInfo, writer interceptor.RTPWriter) interceptor.RTPWriter {\n\t\t\t\t\t\treturn interceptor.RTPWriterFunc(func(header *rtp.Header, payload []byte, attributes interceptor.Attributes) (int, error) {\n\t\t\t\t\t\t\t// set extension on outgoing packet\n\t\t\t\t\t\t\theader.Extension = true\n\t\t\t\t\t\t\theader.ExtensionProfile = 0xBEDE\n\t\t\t\t\t\t\tassert.NoError(t, header.SetExtension(2, []byte(\"foo\")))\n\n\t\t\t\t\t\t\treturn writer.Write(header, payload, attributes)\n\t\t\t\t\t\t})\n\t\t\t\t\t},\n\t\t\t\t\tBindRemoteStreamFn: func(_ *interceptor.StreamInfo, reader interceptor.RTPReader) interceptor.RTPReader {\n\t\t\t\t\t\treturn interceptor.RTPReaderFunc(func(b []byte, a interceptor.Attributes) (int, interceptor.Attributes, error) {\n\t\t\t\t\t\t\tif a == nil {\n\t\t\t\t\t\t\t\ta = interceptor.Attributes{}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ta.Set(\"attribute\", \"value\")\n\t\t\t\t\t\t\treturn reader.Read(b, a)\n\t\t\t\t\t\t})\n\t\t\t\t\t},\n\t\t\t\t}, nil\n\t\t\t},\n\t\t})\n\n\t\tpc, err := NewAPI(WithInterceptorRegistry(ir)).NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\treturn pc\n\t}\n\n\tofferer := createPC()\n\tanswerer := createPC()\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = offerer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tseenRTP, seenRTPCancel := context.WithCancel(context.Background())\n\tanswerer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tp, attributes, readErr := track.ReadRTP()\n\t\tassert.NoError(t, readErr)\n\n\t\tassert.Equal(t, p.Extension, true)\n\t\tassert.Equal(t, \"foo\", string(p.GetExtension(2)))\n\t\tassert.Equal(t, \"value\", attributes.Get(\"attribute\"))\n\n\t\tseenRTPCancel()\n\t})\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\tfunc() {\n\t\tticker := time.NewTicker(time.Millisecond * 20)\n\t\tdefer ticker.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-seenRTP.Done():\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}))\n\t\t\t}\n\t\t}\n\t}()\n\n\tclosePairNow(t, offerer, answerer)\n}\n\nfunc Test_Interceptor_BindUnbind(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tvar (\n\t\tcntBindRTCPReader     uint32\n\t\tcntBindRTCPWriter     uint32\n\t\tcntBindLocalStream    uint32\n\t\tcntUnbindLocalStream  uint32\n\t\tcntBindRemoteStream   uint32\n\t\tcntUnbindRemoteStream uint32\n\t\tcntClose              uint32\n\t)\n\tmockInterceptor := &mock_interceptor.Interceptor{\n\t\tBindRTCPReaderFn: func(reader interceptor.RTCPReader) interceptor.RTCPReader {\n\t\t\tatomic.AddUint32(&cntBindRTCPReader, 1)\n\t\t\treturn reader\n\t\t},\n\t\tBindRTCPWriterFn: func(writer interceptor.RTCPWriter) interceptor.RTCPWriter {\n\t\t\tatomic.AddUint32(&cntBindRTCPWriter, 1)\n\t\t\treturn writer\n\t\t},\n\t\tBindLocalStreamFn: func(_ *interceptor.StreamInfo, writer interceptor.RTPWriter) interceptor.RTPWriter {\n\t\t\tatomic.AddUint32(&cntBindLocalStream, 1)\n\t\t\treturn writer\n\t\t},\n\t\tUnbindLocalStreamFn: func(*interceptor.StreamInfo) {\n\t\t\tatomic.AddUint32(&cntUnbindLocalStream, 1)\n\t\t},\n\t\tBindRemoteStreamFn: func(_ *interceptor.StreamInfo, reader interceptor.RTPReader) interceptor.RTPReader {\n\t\t\tatomic.AddUint32(&cntBindRemoteStream, 1)\n\t\t\treturn reader\n\t\t},\n\t\tUnbindRemoteStreamFn: func(_ *interceptor.StreamInfo) {\n\t\t\tatomic.AddUint32(&cntUnbindRemoteStream, 1)\n\t\t},\n\t\tCloseFn: func() error {\n\t\t\tatomic.AddUint32(&cntClose, 1)\n\t\t\treturn nil\n\t\t},\n\t}\n\tir := &interceptor.Registry{}\n\tir.Add(&mock_interceptor.Factory{\n\t\tNewInterceptorFn: func(_ string) (interceptor.Interceptor, error) { return mockInterceptor, nil },\n\t})\n\n\tsender, receiver, err := NewAPI(WithInterceptorRegistry(ir)).newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = sender.AddTrack(track)\n\tassert.NoError(t, err)\n\n\treceiverReady, receiverReadyFn := context.WithCancel(context.Background())\n\treceiver.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\t_, _, readErr := track.ReadRTP()\n\t\tassert.NoError(t, readErr)\n\t\treceiverReadyFn()\n\t})\n\n\tassert.NoError(t, signalPair(sender, receiver))\n\n\tticker := time.NewTicker(time.Millisecond * 20)\n\tdefer ticker.Stop()\n\tfunc() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-receiverReady.Done():\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\t// Send packet to make receiver track actual creates RTPReceiver.\n\t\t\t\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0xAA}, Duration: time.Second}))\n\t\t\t}\n\t\t}\n\t}()\n\n\tassert.NoError(t, sender.GracefulClose())\n\tassert.NoError(t, receiver.GracefulClose())\n\n\t// Bind/UnbindLocal/RemoteStream should be called from one side.\n\tif cnt := atomic.LoadUint32(&cntBindLocalStream); cnt != 1 {\n\t\tt.Errorf(\"BindLocalStreamFn is expected to be called once, but called %d times\", cnt)\n\t}\n\tif cnt := atomic.LoadUint32(&cntUnbindLocalStream); cnt != 1 {\n\t\tt.Errorf(\"UnbindLocalStreamFn is expected to be called once, but called %d times\", cnt)\n\t}\n\tif cnt := atomic.LoadUint32(&cntBindRemoteStream); cnt != 2 {\n\t\tt.Errorf(\"BindRemoteStreamFn is expected to be called once, but called %d times\", cnt)\n\t}\n\tif cnt := atomic.LoadUint32(&cntUnbindRemoteStream); cnt != 2 {\n\t\tt.Errorf(\"UnbindRemoteStreamFn is expected to be called once, but called %d times\", cnt)\n\t}\n\n\t// BindRTCPWriter/Reader and Close should be called from both side.\n\tif cnt := atomic.LoadUint32(&cntBindRTCPWriter); cnt != 2 {\n\t\tt.Errorf(\"BindRTCPWriterFn is expected to be called twice, but called %d times\", cnt)\n\t}\n\tif cnt := atomic.LoadUint32(&cntBindRTCPReader); cnt != 3 {\n\t\tt.Errorf(\"BindRTCPReaderFn is expected to be called twice, but called %d times\", cnt)\n\t}\n\tif cnt := atomic.LoadUint32(&cntClose); cnt != 2 {\n\t\tt.Errorf(\"CloseFn is expected to be called twice, but called %d times\", cnt)\n\t}\n}\n\nfunc Test_InterceptorRegistry_Build(t *testing.T) {\n\tregistryBuildCount := 0\n\n\tir := &interceptor.Registry{}\n\tir.Add(&mock_interceptor.Factory{\n\t\tNewInterceptorFn: func(_ string) (interceptor.Interceptor, error) {\n\t\t\tregistryBuildCount++\n\t\t\treturn &interceptor.NoOp{}, nil\n\t\t},\n\t})\n\n\tpeerConnectionA, peerConnectionB, err := NewAPI(WithInterceptorRegistry(ir)).newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, 2, registryBuildCount)\n\tclosePairNow(t, peerConnectionA, peerConnectionB)\n}\n\nfunc Test_Interceptor_ZeroSSRC(t *testing.T) {\n\tto := test.TimeOut(time.Second * 20)\n\tdefer to.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ttrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tofferer, answerer, err := newPair()\n\tassert.NoError(t, err)\n\n\t_, err = offerer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tprobeReceiverCreated := make(chan struct{})\n\n\tgo func() {\n\t\tsequenceNumber := uint16(0)\n\t\tticker := time.NewTicker(time.Millisecond * 20)\n\t\tdefer ticker.Stop()\n\t\tfor range ticker.C {\n\t\t\ttrack.mu.Lock()\n\t\t\tif len(track.bindings) == 1 {\n\t\t\t\t_, err = track.bindings[0].writeStream.WriteRTP(&rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSSRC:           0,\n\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t}, []byte{0, 1, 2, 3, 4, 5})\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t\tsequenceNumber++\n\t\t\ttrack.mu.Unlock()\n\n\t\t\tif nonMediaBandwidthProbe, ok := answerer.nonMediaBandwidthProbe.Load().(*RTPReceiver); ok {\n\t\t\t\tassert.Equal(t, len(nonMediaBandwidthProbe.Tracks()), 1)\n\t\t\t\tclose(probeReceiverCreated)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\tpeerConnectionConnected := untilConnectionState(PeerConnectionStateConnected, offerer, answerer)\n\tpeerConnectionConnected.Wait()\n\n\t<-probeReceiverCreated\n\tclosePairNow(t, offerer, answerer)\n}\n\n// TestInterceptorNack is an end-to-end test for the NACK sender.\n// It tests that:\n//   - we get a NACK if we negotiated generic NACks;\n//   - we don't get a NACK if we did not negotiate generick NACKs;\n//   - the NACK corresponds to the missing packet.\nfunc TestInterceptorNack(t *testing.T) {\n\tto := test.TimeOut(time.Second * 20)\n\tdefer to.Stop()\n\n\tt.Run(\"Nack\", func(t *testing.T) { testInterceptorNack(t, true) })\n\tt.Run(\"NoNack\", func(t *testing.T) { testInterceptorNack(t, false) })\n}\n\nfunc testInterceptorNack(t *testing.T, requestNack bool) {\n\tconst numPackets = 20\n\n\tir := interceptor.Registry{}\n\tm := MediaEngine{}\n\tvar feedback []RTCPFeedback\n\tif requestNack {\n\t\tfeedback = append(feedback, RTCPFeedback{\"nack\", \"\"})\n\t}\n\terr := m.RegisterCodec(\n\t\tRTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{\n\t\t\t\t\"video/VP8\", 90000, 0,\n\t\t\t\t\"\",\n\t\t\t\tfeedback,\n\t\t\t},\n\t\t\tPayloadType: 96,\n\t\t},\n\t\tRTPCodecTypeVideo,\n\t)\n\tassert.NoError(t, err)\n\tapi := NewAPI(\n\t\tWithMediaEngine(&m),\n\t\tWithInterceptorRegistry(&ir),\n\t)\n\n\tpc1, err := api.NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack1, err := NewTrackLocalStaticRTP(\n\t\tRTPCodecCapability{MimeType: MimeTypeVP8},\n\t\t\"video\", \"pion\",\n\t)\n\tassert.NoError(t, err)\n\tsender, err := pc1.AddTrack(track1)\n\tassert.NoError(t, err)\n\n\tpc2, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\toffer, err := pc1.CreateOffer(nil)\n\tassert.NoError(t, err)\n\terr = pc1.SetLocalDescription(offer)\n\tassert.NoError(t, err)\n\t<-GatheringCompletePromise(pc1)\n\n\terr = pc2.SetRemoteDescription(*pc1.LocalDescription())\n\tassert.NoError(t, err)\n\tanswer, err := pc2.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\terr = pc2.SetLocalDescription(answer)\n\tassert.NoError(t, err)\n\t<-GatheringCompletePromise(pc2)\n\n\terr = pc1.SetRemoteDescription(*pc2.LocalDescription())\n\tassert.NoError(t, err)\n\n\tvar gotNack bool\n\trtcpDone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(rtcpDone)\n\t\tbuf := make([]byte, 1500)\n\t\tfor {\n\t\t\tn, _, err2 := sender.Read(buf)\n\t\t\t// nolint\n\t\t\tif err2 == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tassert.NoError(t, err2)\n\t\t\tps, err2 := rtcp.Unmarshal(buf[:n])\n\t\t\tassert.NoError(t, err2)\n\t\t\tfor _, p := range ps {\n\t\t\t\tif pn, ok := p.(*rtcp.TransportLayerNack); ok {\n\t\t\t\t\tassert.Equal(t, len(pn.Nacks), 1)\n\t\t\t\t\tassert.Equal(t,\n\t\t\t\t\t\tpn.Nacks[0].PacketID, uint16(1),\n\t\t\t\t\t)\n\t\t\t\t\tassert.Equal(t,\n\t\t\t\t\t\tpn.Nacks[0].LostPackets,\n\t\t\t\t\t\trtcp.PacketBitmap(0),\n\t\t\t\t\t)\n\t\t\t\t\tgotNack = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tdone := make(chan struct{})\n\tpc2.OnTrack(func(track2 *TrackRemote, _ *RTPReceiver) {\n\t\tfor i := 0; i < numPackets; i++ {\n\t\t\tif i == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tp, _, err2 := track2.ReadRTP()\n\t\t\tassert.NoError(t, err2)\n\t\t\tassert.Equal(t, p.SequenceNumber, uint16(i))\n\t\t}\n\t\tclose(done)\n\t})\n\n\tgo func() {\n\t\tfor i := 0; i < numPackets; i++ {\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t\tif i == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar p rtp.Packet\n\t\t\tp.Version = 2\n\t\t\tp.Marker = true\n\t\t\tp.PayloadType = 96\n\t\t\tp.SequenceNumber = uint16(i)\n\t\t\tp.Timestamp = uint32(i * 90000 / 50)\n\t\t\tp.Payload = []byte{42}\n\t\t\terr2 := track1.WriteRTP(&p)\n\t\t\tassert.NoError(t, err2)\n\t\t}\n\t}()\n\n\t<-done\n\terr = pc1.Close()\n\tassert.NoError(t, err)\n\terr = pc2.Close()\n\tassert.NoError(t, err)\n\n\tif requestNack {\n\t\tif !gotNack {\n\t\t\tt.Errorf(\"Expected to get a NACK, got none\")\n\t\t}\n\t} else {\n\t\tif gotNack {\n\t\t\tt.Errorf(\"Expected to get no NACK, got one\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "js_utils.go",
          "type": "blob",
          "size": 3.44921875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"syscall/js\"\n)\n\n// awaitPromise accepts a js.Value representing a Promise. If the promise\n// resolves, it returns (result, nil). If the promise rejects, it returns\n// (js.Undefined, error). awaitPromise has a synchronous-like API but does not\n// block the JavaScript event loop.\nfunc awaitPromise(promise js.Value) (js.Value, error) {\n\tresultsChan := make(chan js.Value)\n\terrChan := make(chan js.Error)\n\n\tthenFunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo func() {\n\t\t\tresultsChan <- args[0]\n\t\t}()\n\t\treturn js.Undefined()\n\t})\n\tdefer thenFunc.Release()\n\n\tcatchFunc := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo func() {\n\t\t\terrChan <- js.Error{args[0]}\n\t\t}()\n\t\treturn js.Undefined()\n\t})\n\tdefer catchFunc.Release()\n\n\tpromise.Call(\"then\", thenFunc).Call(\"catch\", catchFunc)\n\n\tselect {\n\tcase result := <-resultsChan:\n\t\treturn result, nil\n\tcase err := <-errChan:\n\t\treturn js.Undefined(), err\n\t}\n}\n\nfunc valueToUint16Pointer(val js.Value) *uint16 {\n\tif val.IsNull() || val.IsUndefined() {\n\t\treturn nil\n\t}\n\tconvertedVal := uint16(val.Int())\n\treturn &convertedVal\n}\n\nfunc valueToStringPointer(val js.Value) *string {\n\tif val.IsNull() || val.IsUndefined() {\n\t\treturn nil\n\t}\n\tstringVal := val.String()\n\treturn &stringVal\n}\n\nfunc stringToValueOrUndefined(val string) js.Value {\n\tif val == \"\" {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(val)\n}\n\nfunc uint8ToValueOrUndefined(val uint8) js.Value {\n\tif val == 0 {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(val)\n}\n\nfunc interfaceToValueOrUndefined(val interface{}) js.Value {\n\tif val == nil {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(val)\n}\n\nfunc valueToStringOrZero(val js.Value) string {\n\tif val.IsUndefined() || val.IsNull() {\n\t\treturn \"\"\n\t}\n\treturn val.String()\n}\n\nfunc valueToUint8OrZero(val js.Value) uint8 {\n\tif val.IsUndefined() || val.IsNull() {\n\t\treturn 0\n\t}\n\treturn uint8(val.Int())\n}\n\nfunc valueToUint16OrZero(val js.Value) uint16 {\n\tif val.IsNull() || val.IsUndefined() {\n\t\treturn 0\n\t}\n\treturn uint16(val.Int())\n}\n\nfunc valueToUint32OrZero(val js.Value) uint32 {\n\tif val.IsNull() || val.IsUndefined() {\n\t\treturn 0\n\t}\n\treturn uint32(val.Int())\n}\n\nfunc valueToStrings(val js.Value) []string {\n\tresult := make([]string, val.Length())\n\tfor i := 0; i < val.Length(); i++ {\n\t\tresult[i] = val.Index(i).String()\n\t}\n\treturn result\n}\n\nfunc stringPointerToValue(val *string) js.Value {\n\tif val == nil {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(*val)\n}\n\nfunc uint16PointerToValue(val *uint16) js.Value {\n\tif val == nil {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(*val)\n}\n\nfunc boolPointerToValue(val *bool) js.Value {\n\tif val == nil {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(*val)\n}\n\nfunc stringsToValue(strings []string) js.Value {\n\tval := make([]interface{}, len(strings))\n\tfor i, s := range strings {\n\t\tval[i] = s\n\t}\n\treturn js.ValueOf(val)\n}\n\nfunc stringEnumToValueOrUndefined(s string) js.Value {\n\tif s == \"unknown\" {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(s)\n}\n\n// Converts the return value of recover() to an error.\nfunc recoveryToError(e interface{}) error {\n\tswitch e := e.(type) {\n\tcase error:\n\t\treturn e\n\tdefault:\n\t\treturn fmt.Errorf(\"recovered with non-error value: (%T) %s\", e, e)\n\t}\n}\n\nfunc uint8ArrayValueToBytes(val js.Value) []byte {\n\tresult := make([]byte, val.Length())\n\tjs.CopyBytesToGo(result, val)\n\n\treturn result\n}\n"
        },
        {
          "name": "mediaengine.go",
          "type": "blob",
          "size": 21.7041015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/rtp/codecs\"\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/webrtc/v4/internal/fmtp\"\n)\n\nconst (\n\t// MimeTypeH264 H264 MIME type.\n\t// Note: Matching should be case insensitive.\n\tMimeTypeH264 = \"video/H264\"\n\t// MimeTypeH265 H265 MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeH265 = \"video/H265\"\n\t// MimeTypeOpus Opus MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeOpus = \"audio/opus\"\n\t// MimeTypeVP8 VP8 MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeVP8 = \"video/VP8\"\n\t// MimeTypeVP9 VP9 MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeVP9 = \"video/VP9\"\n\t// MimeTypeAV1 AV1 MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeAV1 = \"video/AV1\"\n\t// MimeTypeG722 G722 MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeG722 = \"audio/G722\"\n\t// MimeTypePCMU PCMU MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypePCMU = \"audio/PCMU\"\n\t// MimeTypePCMA PCMA MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypePCMA = \"audio/PCMA\"\n\t// MimeTypeRTX RTX MIME type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeRTX = \"video/rtx\"\n\t// MimeTypeFlexFEC FEC MIME Type\n\t// Note: Matching should be case insensitive.\n\tMimeTypeFlexFEC = \"video/flexfec\"\n)\n\ntype mediaEngineHeaderExtension struct {\n\turi              string\n\tisAudio, isVideo bool\n\n\t// If set only Transceivers of this direction are allowed\n\tallowedDirections []RTPTransceiverDirection\n}\n\n// A MediaEngine defines the codecs supported by a PeerConnection, and the\n// configuration of those codecs.\ntype MediaEngine struct {\n\t// If we have attempted to negotiate a codec type yet.\n\tnegotiatedVideo, negotiatedAudio bool\n\n\tvideoCodecs, audioCodecs                     []RTPCodecParameters\n\tnegotiatedVideoCodecs, negotiatedAudioCodecs []RTPCodecParameters\n\n\theaderExtensions           []mediaEngineHeaderExtension\n\tnegotiatedHeaderExtensions map[int]mediaEngineHeaderExtension\n\n\tmu sync.RWMutex\n}\n\n// RegisterDefaultCodecs registers the default codecs supported by Pion WebRTC.\n// RegisterDefaultCodecs is not safe for concurrent use.\nfunc (m *MediaEngine) RegisterDefaultCodecs() error {\n\t// Default Pion Audio Codecs\n\tfor _, codec := range []RTPCodecParameters{\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 2, \"minptime=10;useinbandfec=1\", nil},\n\t\t\tPayloadType:        111,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeG722, 8000, 0, \"\", nil},\n\t\t\tPayloadType:        rtp.PayloadTypeG722,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypePCMU, 8000, 0, \"\", nil},\n\t\t\tPayloadType:        rtp.PayloadTypePCMU,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypePCMA, 8000, 0, \"\", nil},\n\t\t\tPayloadType:        rtp.PayloadTypePCMA,\n\t\t},\n\t} {\n\t\tif err := m.RegisterCodec(codec, RTPCodecTypeAudio); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvideoRTCPFeedback := []RTCPFeedback{{\"goog-remb\", \"\"}, {\"ccm\", \"fir\"}, {\"nack\", \"\"}, {\"nack\", \"pli\"}}\n\tfor _, codec := range []RTPCodecParameters{\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", videoRTCPFeedback},\n\t\t\tPayloadType:        96,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=96\", nil},\n\t\t\tPayloadType:        97,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\", videoRTCPFeedback},\n\t\t\tPayloadType:        102,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=102\", nil},\n\t\t\tPayloadType:        103,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f\", videoRTCPFeedback},\n\t\t\tPayloadType:        104,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=104\", nil},\n\t\t\tPayloadType:        105,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\", videoRTCPFeedback},\n\t\t\tPayloadType:        106,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=106\", nil},\n\t\t\tPayloadType:        107,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f\", videoRTCPFeedback},\n\t\t\tPayloadType:        108,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=108\", nil},\n\t\t\tPayloadType:        109,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d001f\", videoRTCPFeedback},\n\t\t\tPayloadType:        127,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=127\", nil},\n\t\t\tPayloadType:        125,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=4d001f\", videoRTCPFeedback},\n\t\t\tPayloadType:        39,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=39\", nil},\n\t\t\tPayloadType:        40,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeAV1, 90000, 0, \"\", videoRTCPFeedback},\n\t\t\tPayloadType:        45,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=45\", nil},\n\t\t\tPayloadType:        46,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP9, 90000, 0, \"profile-id=0\", videoRTCPFeedback},\n\t\t\tPayloadType:        98,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=98\", nil},\n\t\t\tPayloadType:        99,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP9, 90000, 0, \"profile-id=2\", videoRTCPFeedback},\n\t\t\tPayloadType:        100,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=100\", nil},\n\t\t\tPayloadType:        101,\n\t\t},\n\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=64001f\", videoRTCPFeedback},\n\t\t\tPayloadType:        112,\n\t\t},\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=112\", nil},\n\t\t\tPayloadType:        113,\n\t\t},\n\t} {\n\t\tif err := m.RegisterCodec(codec, RTPCodecTypeVideo); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// addCodec will append codec if it not exists\nfunc (m *MediaEngine) addCodec(codecs []RTPCodecParameters, codec RTPCodecParameters) []RTPCodecParameters {\n\tfor _, c := range codecs {\n\t\tif c.MimeType == codec.MimeType && c.PayloadType == codec.PayloadType {\n\t\t\treturn codecs\n\t\t}\n\t}\n\treturn append(codecs, codec)\n}\n\n// RegisterCodec adds codec to the MediaEngine\n// These are the list of codecs supported by this PeerConnection.\n// RegisterCodec is not safe for concurrent use.\nfunc (m *MediaEngine) RegisterCodec(codec RTPCodecParameters, typ RTPCodecType) error {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tcodec.statsID = fmt.Sprintf(\"RTPCodec-%d\", time.Now().UnixNano())\n\tswitch typ {\n\tcase RTPCodecTypeAudio:\n\t\tm.audioCodecs = m.addCodec(m.audioCodecs, codec)\n\tcase RTPCodecTypeVideo:\n\t\tm.videoCodecs = m.addCodec(m.videoCodecs, codec)\n\tdefault:\n\t\treturn ErrUnknownType\n\t}\n\treturn nil\n}\n\n// RegisterHeaderExtension adds a header extension to the MediaEngine\n// To determine the negotiated value use `GetHeaderExtensionID` after signaling is complete\nfunc (m *MediaEngine) RegisterHeaderExtension(extension RTPHeaderExtensionCapability, typ RTPCodecType, allowedDirections ...RTPTransceiverDirection) error {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tif m.negotiatedHeaderExtensions == nil {\n\t\tm.negotiatedHeaderExtensions = map[int]mediaEngineHeaderExtension{}\n\t}\n\n\tif len(allowedDirections) == 0 {\n\t\tallowedDirections = []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly, RTPTransceiverDirectionSendonly}\n\t}\n\n\tfor _, direction := range allowedDirections {\n\t\tif direction != RTPTransceiverDirectionRecvonly && direction != RTPTransceiverDirectionSendonly {\n\t\t\treturn ErrRegisterHeaderExtensionInvalidDirection\n\t\t}\n\t}\n\n\textensionIndex := -1\n\tfor i := range m.headerExtensions {\n\t\tif extension.URI == m.headerExtensions[i].uri {\n\t\t\textensionIndex = i\n\t\t}\n\t}\n\n\tif extensionIndex == -1 {\n\t\tm.headerExtensions = append(m.headerExtensions, mediaEngineHeaderExtension{})\n\t\textensionIndex = len(m.headerExtensions) - 1\n\t}\n\n\tif typ == RTPCodecTypeAudio {\n\t\tm.headerExtensions[extensionIndex].isAudio = true\n\t} else if typ == RTPCodecTypeVideo {\n\t\tm.headerExtensions[extensionIndex].isVideo = true\n\t}\n\n\tm.headerExtensions[extensionIndex].uri = extension.URI\n\tm.headerExtensions[extensionIndex].allowedDirections = allowedDirections\n\n\treturn nil\n}\n\n// RegisterFeedback adds feedback mechanism to already registered codecs.\nfunc (m *MediaEngine) RegisterFeedback(feedback RTCPFeedback, typ RTPCodecType) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tif typ == RTPCodecTypeVideo {\n\t\tfor i, v := range m.videoCodecs {\n\t\t\tv.RTCPFeedback = append(v.RTCPFeedback, feedback)\n\t\t\tm.videoCodecs[i] = v\n\t\t}\n\t} else if typ == RTPCodecTypeAudio {\n\t\tfor i, v := range m.audioCodecs {\n\t\t\tv.RTCPFeedback = append(v.RTCPFeedback, feedback)\n\t\t\tm.audioCodecs[i] = v\n\t\t}\n\t}\n}\n\n// getHeaderExtensionID returns the negotiated ID for a header extension.\n// If the Header Extension isn't enabled ok will be false\nfunc (m *MediaEngine) getHeaderExtensionID(extension RTPHeaderExtensionCapability) (val int, audioNegotiated, videoNegotiated bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tif m.negotiatedHeaderExtensions == nil {\n\t\treturn 0, false, false\n\t}\n\n\tfor id, h := range m.negotiatedHeaderExtensions {\n\t\tif extension.URI == h.uri {\n\t\t\treturn id, h.isAudio, h.isVideo\n\t\t}\n\t}\n\n\treturn\n}\n\n// copy copies any user modifiable state of the MediaEngine\n// all internal state is reset\nfunc (m *MediaEngine) copy() *MediaEngine {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tcloned := &MediaEngine{\n\t\tvideoCodecs:      append([]RTPCodecParameters{}, m.videoCodecs...),\n\t\taudioCodecs:      append([]RTPCodecParameters{}, m.audioCodecs...),\n\t\theaderExtensions: append([]mediaEngineHeaderExtension{}, m.headerExtensions...),\n\t}\n\tif len(m.headerExtensions) > 0 {\n\t\tcloned.negotiatedHeaderExtensions = map[int]mediaEngineHeaderExtension{}\n\t}\n\treturn cloned\n}\n\nfunc findCodecByPayload(codecs []RTPCodecParameters, payloadType PayloadType) *RTPCodecParameters {\n\tfor _, codec := range codecs {\n\t\tif codec.PayloadType == payloadType {\n\t\t\treturn &codec\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *MediaEngine) getCodecByPayload(payloadType PayloadType) (RTPCodecParameters, RTPCodecType, error) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\t// if we've negotiated audio or video, check the negotiated types before our\n\t// built-in payload types, to ensure we pick the codec the other side wants.\n\tif m.negotiatedVideo {\n\t\tif codec := findCodecByPayload(m.negotiatedVideoCodecs, payloadType); codec != nil {\n\t\t\treturn *codec, RTPCodecTypeVideo, nil\n\t\t}\n\t}\n\tif m.negotiatedAudio {\n\t\tif codec := findCodecByPayload(m.negotiatedAudioCodecs, payloadType); codec != nil {\n\t\t\treturn *codec, RTPCodecTypeAudio, nil\n\t\t}\n\t}\n\tif !m.negotiatedVideo {\n\t\tif codec := findCodecByPayload(m.videoCodecs, payloadType); codec != nil {\n\t\t\treturn *codec, RTPCodecTypeVideo, nil\n\t\t}\n\t}\n\tif !m.negotiatedAudio {\n\t\tif codec := findCodecByPayload(m.audioCodecs, payloadType); codec != nil {\n\t\t\treturn *codec, RTPCodecTypeAudio, nil\n\t\t}\n\t}\n\n\treturn RTPCodecParameters{}, 0, ErrCodecNotFound\n}\n\nfunc (m *MediaEngine) collectStats(collector *statsReportCollector) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tstatsLoop := func(codecs []RTPCodecParameters) {\n\t\tfor _, codec := range codecs {\n\t\t\tcollector.Collecting()\n\t\t\tstats := CodecStats{\n\t\t\t\tTimestamp:   statsTimestampFrom(time.Now()),\n\t\t\t\tType:        StatsTypeCodec,\n\t\t\t\tID:          codec.statsID,\n\t\t\t\tPayloadType: codec.PayloadType,\n\t\t\t\tMimeType:    codec.MimeType,\n\t\t\t\tClockRate:   codec.ClockRate,\n\t\t\t\tChannels:    uint8(codec.Channels),\n\t\t\t\tSDPFmtpLine: codec.SDPFmtpLine,\n\t\t\t}\n\n\t\t\tcollector.Collect(stats.ID, stats)\n\t\t}\n\t}\n\n\tstatsLoop(m.videoCodecs)\n\tstatsLoop(m.audioCodecs)\n}\n\n// Look up a codec and enable if it exists\nfunc (m *MediaEngine) matchRemoteCodec(remoteCodec RTPCodecParameters, typ RTPCodecType, exactMatches, partialMatches []RTPCodecParameters) (RTPCodecParameters, codecMatchType, error) {\n\tcodecs := m.videoCodecs\n\tif typ == RTPCodecTypeAudio {\n\t\tcodecs = m.audioCodecs\n\t}\n\n\tremoteFmtp := fmtp.Parse(remoteCodec.RTPCodecCapability.MimeType, remoteCodec.RTPCodecCapability.SDPFmtpLine)\n\tif apt, hasApt := remoteFmtp.Parameter(\"apt\"); hasApt {\n\t\tpayloadType, err := strconv.ParseUint(apt, 10, 8)\n\t\tif err != nil {\n\t\t\treturn RTPCodecParameters{}, codecMatchNone, err\n\t\t}\n\n\t\taptMatch := codecMatchNone\n\t\tvar aptCodec RTPCodecParameters\n\t\tfor _, codec := range exactMatches {\n\t\t\tif codec.PayloadType == PayloadType(payloadType) {\n\t\t\t\taptMatch = codecMatchExact\n\t\t\t\taptCodec = codec\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif aptMatch == codecMatchNone {\n\t\t\tfor _, codec := range partialMatches {\n\t\t\t\tif codec.PayloadType == PayloadType(payloadType) {\n\t\t\t\t\taptMatch = codecMatchPartial\n\t\t\t\t\taptCodec = codec\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif aptMatch == codecMatchNone {\n\t\t\treturn RTPCodecParameters{}, codecMatchNone, nil // not an error, we just ignore this codec we don't support\n\t\t}\n\n\t\t// replace the apt value with the original codec's payload type\n\t\ttoMatchCodec := remoteCodec\n\t\tif aptMatched, mt := codecParametersFuzzySearch(aptCodec, codecs); mt == aptMatch {\n\t\t\ttoMatchCodec.SDPFmtpLine = strings.Replace(toMatchCodec.SDPFmtpLine, fmt.Sprintf(\"apt=%d\", payloadType), fmt.Sprintf(\"apt=%d\", aptMatched.PayloadType), 1)\n\t\t}\n\n\t\t// if apt's media codec is partial match, then apt codec must be partial match too\n\t\tlocalCodec, matchType := codecParametersFuzzySearch(toMatchCodec, codecs)\n\t\tif matchType == codecMatchExact && aptMatch == codecMatchPartial {\n\t\t\tmatchType = codecMatchPartial\n\t\t}\n\t\treturn localCodec, matchType, nil\n\t}\n\n\tlocalCodec, matchType := codecParametersFuzzySearch(remoteCodec, codecs)\n\treturn localCodec, matchType, nil\n}\n\n// Update header extensions from a remote media section\nfunc (m *MediaEngine) updateHeaderExtensionFromMediaSection(media *sdp.MediaDescription) error {\n\tvar typ RTPCodecType\n\tswitch {\n\tcase strings.EqualFold(media.MediaName.Media, \"audio\"):\n\t\ttyp = RTPCodecTypeAudio\n\tcase strings.EqualFold(media.MediaName.Media, \"video\"):\n\t\ttyp = RTPCodecTypeVideo\n\tdefault:\n\t\treturn nil\n\t}\n\textensions, err := rtpExtensionsFromMediaDescription(media)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor extension, id := range extensions {\n\t\tif err = m.updateHeaderExtension(id, extension, typ); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Look up a header extension and enable if it exists\nfunc (m *MediaEngine) updateHeaderExtension(id int, extension string, typ RTPCodecType) error {\n\tif m.negotiatedHeaderExtensions == nil {\n\t\treturn nil\n\t}\n\n\tfor _, localExtension := range m.headerExtensions {\n\t\tif localExtension.uri == extension {\n\t\t\th := mediaEngineHeaderExtension{uri: extension, allowedDirections: localExtension.allowedDirections}\n\t\t\tif existingValue, ok := m.negotiatedHeaderExtensions[id]; ok {\n\t\t\t\th = existingValue\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase localExtension.isAudio && typ == RTPCodecTypeAudio:\n\t\t\t\th.isAudio = true\n\t\t\tcase localExtension.isVideo && typ == RTPCodecTypeVideo:\n\t\t\t\th.isVideo = true\n\t\t\t}\n\n\t\t\tm.negotiatedHeaderExtensions[id] = h\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *MediaEngine) pushCodecs(codecs []RTPCodecParameters, typ RTPCodecType) {\n\tfor _, codec := range codecs {\n\t\tif typ == RTPCodecTypeAudio {\n\t\t\tm.negotiatedAudioCodecs = m.addCodec(m.negotiatedAudioCodecs, codec)\n\t\t} else if typ == RTPCodecTypeVideo {\n\t\t\tm.negotiatedVideoCodecs = m.addCodec(m.negotiatedVideoCodecs, codec)\n\t\t}\n\t}\n}\n\n// Update the MediaEngine from a remote description\nfunc (m *MediaEngine) updateFromRemoteDescription(desc sdp.SessionDescription) error {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tfor _, media := range desc.MediaDescriptions {\n\t\tvar typ RTPCodecType\n\n\t\tswitch {\n\t\tcase strings.EqualFold(media.MediaName.Media, \"audio\"):\n\t\t\ttyp = RTPCodecTypeAudio\n\t\tcase strings.EqualFold(media.MediaName.Media, \"video\"):\n\t\t\ttyp = RTPCodecTypeVideo\n\t\t}\n\n\t\tswitch {\n\t\tcase !m.negotiatedAudio && typ == RTPCodecTypeAudio:\n\t\t\tm.negotiatedAudio = true\n\t\tcase !m.negotiatedVideo && typ == RTPCodecTypeVideo:\n\t\t\tm.negotiatedVideo = true\n\t\tdefault:\n\t\t\t// update header extesions from remote sdp if codec is negotiated, Firefox\n\t\t\t// would send updated header extension in renegotiation.\n\t\t\t// e.g. publish first track without simucalst ->negotiated-> publish second track with simucalst\n\t\t\t// then the two media secontions have different rtp header extensions in offer\n\t\t\tif err := m.updateHeaderExtensionFromMediaSection(media); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tcodecs, err := codecsFromMediaDescription(media)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\texactMatches := make([]RTPCodecParameters, 0, len(codecs))\n\t\tpartialMatches := make([]RTPCodecParameters, 0, len(codecs))\n\n\t\tfor _, remoteCodec := range codecs {\n\t\t\tlocalCodec, matchType, mErr := m.matchRemoteCodec(remoteCodec, typ, exactMatches, partialMatches)\n\t\t\tif mErr != nil {\n\t\t\t\treturn mErr\n\t\t\t}\n\n\t\t\tremoteCodec.RTCPFeedback = rtcpFeedbackIntersection(localCodec.RTCPFeedback, remoteCodec.RTCPFeedback)\n\n\t\t\tif matchType == codecMatchExact {\n\t\t\t\texactMatches = append(exactMatches, remoteCodec)\n\t\t\t} else if matchType == codecMatchPartial {\n\t\t\t\tpartialMatches = append(partialMatches, remoteCodec)\n\t\t\t}\n\t\t}\n\n\t\t// use exact matches when they exist, otherwise fall back to partial\n\t\tswitch {\n\t\tcase len(exactMatches) > 0:\n\t\t\tm.pushCodecs(exactMatches, typ)\n\t\tcase len(partialMatches) > 0:\n\t\t\tm.pushCodecs(partialMatches, typ)\n\t\tdefault:\n\t\t\t// no match, not negotiated\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := m.updateHeaderExtensionFromMediaSection(media); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *MediaEngine) getCodecsByKind(typ RTPCodecType) []RTPCodecParameters {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tif typ == RTPCodecTypeVideo {\n\t\tif m.negotiatedVideo {\n\t\t\treturn m.negotiatedVideoCodecs\n\t\t}\n\n\t\treturn m.videoCodecs\n\t} else if typ == RTPCodecTypeAudio {\n\t\tif m.negotiatedAudio {\n\t\t\treturn m.negotiatedAudioCodecs\n\t\t}\n\n\t\treturn m.audioCodecs\n\t}\n\n\treturn nil\n}\n\nfunc (m *MediaEngine) getRTPParametersByKind(typ RTPCodecType, directions []RTPTransceiverDirection) RTPParameters { //nolint:gocognit\n\theaderExtensions := make([]RTPHeaderExtensionParameter, 0)\n\n\t// perform before locking to prevent recursive RLocks\n\tfoundCodecs := m.getCodecsByKind(typ)\n\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tif m.negotiatedVideo && typ == RTPCodecTypeVideo ||\n\t\tm.negotiatedAudio && typ == RTPCodecTypeAudio {\n\t\tfor id, e := range m.negotiatedHeaderExtensions {\n\t\t\tif haveRTPTransceiverDirectionIntersection(e.allowedDirections, directions) && (e.isAudio && typ == RTPCodecTypeAudio || e.isVideo && typ == RTPCodecTypeVideo) {\n\t\t\t\theaderExtensions = append(headerExtensions, RTPHeaderExtensionParameter{ID: id, URI: e.uri})\n\t\t\t}\n\t\t}\n\t} else {\n\t\tmediaHeaderExtensions := make(map[int]mediaEngineHeaderExtension)\n\t\tfor _, e := range m.headerExtensions {\n\t\t\tusingNegotiatedID := false\n\t\t\tfor id := range m.negotiatedHeaderExtensions {\n\t\t\t\tif m.negotiatedHeaderExtensions[id].uri == e.uri {\n\t\t\t\t\tusingNegotiatedID = true\n\t\t\t\t\tmediaHeaderExtensions[id] = e\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !usingNegotiatedID {\n\t\t\t\tfor id := 1; id < 15; id++ {\n\t\t\t\t\tidAvailable := true\n\t\t\t\t\tif _, ok := mediaHeaderExtensions[id]; ok {\n\t\t\t\t\t\tidAvailable = false\n\t\t\t\t\t}\n\t\t\t\t\tif _, taken := m.negotiatedHeaderExtensions[id]; idAvailable && !taken {\n\t\t\t\t\t\tmediaHeaderExtensions[id] = e\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor id, e := range mediaHeaderExtensions {\n\t\t\tif haveRTPTransceiverDirectionIntersection(e.allowedDirections, directions) && (e.isAudio && typ == RTPCodecTypeAudio || e.isVideo && typ == RTPCodecTypeVideo) {\n\t\t\t\theaderExtensions = append(headerExtensions, RTPHeaderExtensionParameter{ID: id, URI: e.uri})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn RTPParameters{\n\t\tHeaderExtensions: headerExtensions,\n\t\tCodecs:           foundCodecs,\n\t}\n}\n\nfunc (m *MediaEngine) getRTPParametersByPayloadType(payloadType PayloadType) (RTPParameters, error) {\n\tcodec, typ, err := m.getCodecByPayload(payloadType)\n\tif err != nil {\n\t\treturn RTPParameters{}, err\n\t}\n\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\theaderExtensions := make([]RTPHeaderExtensionParameter, 0)\n\tfor id, e := range m.negotiatedHeaderExtensions {\n\t\tif e.isAudio && typ == RTPCodecTypeAudio || e.isVideo && typ == RTPCodecTypeVideo {\n\t\t\theaderExtensions = append(headerExtensions, RTPHeaderExtensionParameter{ID: id, URI: e.uri})\n\t\t}\n\t}\n\n\treturn RTPParameters{\n\t\tHeaderExtensions: headerExtensions,\n\t\tCodecs:           []RTPCodecParameters{codec},\n\t}, nil\n}\n\nfunc payloaderForCodec(codec RTPCodecCapability) (rtp.Payloader, error) {\n\tswitch strings.ToLower(codec.MimeType) {\n\tcase strings.ToLower(MimeTypeH264):\n\t\treturn &codecs.H264Payloader{}, nil\n\tcase strings.ToLower(MimeTypeOpus):\n\t\treturn &codecs.OpusPayloader{}, nil\n\tcase strings.ToLower(MimeTypeVP8):\n\t\treturn &codecs.VP8Payloader{\n\t\t\tEnablePictureID: true,\n\t\t}, nil\n\tcase strings.ToLower(MimeTypeVP9):\n\t\treturn &codecs.VP9Payloader{}, nil\n\tcase strings.ToLower(MimeTypeAV1):\n\t\treturn &codecs.AV1Payloader{}, nil\n\tcase strings.ToLower(MimeTypeG722):\n\t\treturn &codecs.G722Payloader{}, nil\n\tcase strings.ToLower(MimeTypePCMU), strings.ToLower(MimeTypePCMA):\n\t\treturn &codecs.G711Payloader{}, nil\n\tdefault:\n\t\treturn nil, ErrNoPayloaderForCodec\n\t}\n}\n\nfunc (m *MediaEngine) isRTXEnabled(typ RTPCodecType, directions []RTPTransceiverDirection) bool {\n\tfor _, p := range m.getRTPParametersByKind(typ, directions).Codecs {\n\t\tif p.MimeType == MimeTypeRTX {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (m *MediaEngine) isFECEnabled(typ RTPCodecType, directions []RTPTransceiverDirection) bool {\n\tfor _, p := range m.getRTPParametersByKind(typ, directions).Codecs {\n\t\tif strings.Contains(p.MimeType, MimeTypeFlexFEC) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "mediaengine_test.go",
          "type": "blob",
          "size": 25.3974609375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// pion/webrtc#1078\nfunc TestOpusCase(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTransceiverFromKind(RTPCodecTypeAudio)\n\tassert.NoError(t, err)\n\n\toffer, err := pc.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.True(t, regexp.MustCompile(`(?m)^a=rtpmap:\\d+ opus/48000/2`).MatchString(offer.SDP))\n\tassert.NoError(t, pc.Close())\n}\n\n// pion/example-webrtc-applications#89\nfunc TestVideoCase(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\toffer, err := pc.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.True(t, regexp.MustCompile(`(?m)^a=rtpmap:\\d+ H264/90000`).MatchString(offer.SDP))\n\tassert.True(t, regexp.MustCompile(`(?m)^a=rtpmap:\\d+ VP8/90000`).MatchString(offer.SDP))\n\tassert.True(t, regexp.MustCompile(`(?m)^a=rtpmap:\\d+ VP9/90000`).MatchString(offer.SDP))\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestMediaEngineRemoteDescription(t *testing.T) {\n\tmustParse := func(raw string) sdp.SessionDescription {\n\t\ts := sdp.SessionDescription{}\n\t\tassert.NoError(t, s.Unmarshal([]byte(raw)))\n\t\treturn s\n\t}\n\n\tt.Run(\"No Media\", func(t *testing.T) {\n\t\tconst noMedia = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(noMedia)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.False(t, m.negotiatedAudio)\n\t})\n\n\tt.Run(\"Enable Opus\", func(t *testing.T) {\n\t\tconst opusSamePayload = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 111\na=rtpmap:111 opus/48000/2\na=fmtp:111 minptime=10; useinbandfec=1\n`\n\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(opusSamePayload)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.True(t, m.negotiatedAudio)\n\n\t\topusCodec, _, err := m.getCodecByPayload(111)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, opusCodec.MimeType, MimeTypeOpus)\n\t})\n\n\tt.Run(\"Change Payload Type\", func(t *testing.T) {\n\t\tconst opusSamePayload = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 112\na=rtpmap:112 opus/48000/2\na=fmtp:112 minptime=10; useinbandfec=1\n`\n\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(opusSamePayload)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.True(t, m.negotiatedAudio)\n\n\t\t_, _, err := m.getCodecByPayload(111)\n\t\tassert.Error(t, err)\n\n\t\topusCodec, _, err := m.getCodecByPayload(112)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, opusCodec.MimeType, MimeTypeOpus)\n\t})\n\n\tt.Run(\"Ambiguous Payload Type\", func(t *testing.T) {\n\t\tconst opusSamePayload = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 96\na=rtpmap:96 opus/48000/2\na=fmtp:96 minptime=10; useinbandfec=1\n`\n\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(opusSamePayload)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.True(t, m.negotiatedAudio)\n\n\t\topusCodec, _, err := m.getCodecByPayload(96)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, opusCodec.MimeType, MimeTypeOpus)\n\t})\n\n\tt.Run(\"Case Insensitive\", func(t *testing.T) {\n\t\tconst opusUpcase = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 111\na=rtpmap:111 OPUS/48000/2\na=fmtp:111 minptime=10; useinbandfec=1\n`\n\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(opusUpcase)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.True(t, m.negotiatedAudio)\n\n\t\topusCodec, _, err := m.getCodecByPayload(111)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, opusCodec.MimeType, \"audio/OPUS\")\n\t})\n\n\tt.Run(\"Handle different fmtp\", func(t *testing.T) {\n\t\tconst opusNoFmtp = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 111\na=rtpmap:111 opus/48000/2\n`\n\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(opusNoFmtp)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.True(t, m.negotiatedAudio)\n\n\t\topusCodec, _, err := m.getCodecByPayload(111)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, opusCodec.MimeType, MimeTypeOpus)\n\t})\n\n\tt.Run(\"Header Extensions\", func(t *testing.T) {\n\t\tconst headerExtensions = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 111\na=extmap:7 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:5 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtpmap:111 opus/48000/2\n`\n\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: sdp.SDESMidURI}, RTPCodecTypeAudio))\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(headerExtensions)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.True(t, m.negotiatedAudio)\n\n\t\tabsID, absAudioEnabled, absVideoEnabled := m.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.ABSSendTimeURI})\n\t\tassert.Equal(t, absID, 0)\n\t\tassert.False(t, absAudioEnabled)\n\t\tassert.False(t, absVideoEnabled)\n\n\t\tmidID, midAudioEnabled, midVideoEnabled := m.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.SDESMidURI})\n\t\tassert.Equal(t, midID, 7)\n\t\tassert.True(t, midAudioEnabled)\n\t\tassert.False(t, midVideoEnabled)\n\t})\n\n\tt.Run(\"Different Header Extensions on same codec\", func(t *testing.T) {\n\t\tconst headerExtensions = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 111\na=rtpmap:111 opus/48000/2\nm=audio 9 UDP/TLS/RTP/SAVPF 111\na=extmap:7 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:5 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtpmap:111 opus/48000/2\n`\n\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: \"urn:ietf:params:rtp-hdrext:sdes:mid\"}, RTPCodecTypeAudio))\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{URI: \"urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\"}, RTPCodecTypeAudio))\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(headerExtensions)))\n\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.True(t, m.negotiatedAudio)\n\n\t\tabsID, absAudioEnabled, absVideoEnabled := m.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.ABSSendTimeURI})\n\t\tassert.Equal(t, absID, 0)\n\t\tassert.False(t, absAudioEnabled)\n\t\tassert.False(t, absVideoEnabled)\n\n\t\tmidID, midAudioEnabled, midVideoEnabled := m.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.SDESMidURI})\n\t\tassert.Equal(t, midID, 7)\n\t\tassert.True(t, midAudioEnabled)\n\t\tassert.False(t, midVideoEnabled)\n\t})\n\n\tt.Run(\"Prefers exact codec matches\", func(t *testing.T) {\n\t\tconst profileLevels = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=video 60323 UDP/TLS/RTP/SAVPF 96 98\na=rtpmap:96 H264/90000\na=fmtp:96 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640c1f\na=rtpmap:98 H264/90000\na=fmtp:98 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\", nil},\n\t\t\tPayloadType:        127,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(profileLevels)))\n\n\t\tassert.True(t, m.negotiatedVideo)\n\t\tassert.False(t, m.negotiatedAudio)\n\n\t\tsupportedH264, _, err := m.getCodecByPayload(98)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, supportedH264.MimeType, MimeTypeH264)\n\n\t\t_, _, err = m.getCodecByPayload(96)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Does not match when fmtpline is set and does not match\", func(t *testing.T) {\n\t\tconst profileLevels = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=video 60323 UDP/TLS/RTP/SAVPF 96 98\na=rtpmap:96 H264/90000\na=fmtp:96 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640c1f\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\", nil},\n\t\t\tPayloadType:        127,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.Error(t, m.updateFromRemoteDescription(mustParse(profileLevels)))\n\n\t\t_, _, err := m.getCodecByPayload(96)\n\t\tassert.Error(t, err)\n\t})\n\n\tt.Run(\"Matches when fmtpline is not set in offer, but exists in mediaengine\", func(t *testing.T) {\n\t\tconst profileLevels = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=video 60323 UDP/TLS/RTP/SAVPF 96\na=rtpmap:96 VP9/90000\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP9, 90000, 0, \"profile-id=0\", nil},\n\t\t\tPayloadType:        98,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(profileLevels)))\n\n\t\tassert.True(t, m.negotiatedVideo)\n\n\t\t_, _, err := m.getCodecByPayload(96)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"Matches when fmtpline exists in neither\", func(t *testing.T) {\n\t\tconst profileLevels = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=video 60323 UDP/TLS/RTP/SAVPF 96\na=rtpmap:96 VP8/90000\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        96,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(profileLevels)))\n\n\t\tassert.True(t, m.negotiatedVideo)\n\n\t\t_, _, err := m.getCodecByPayload(96)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"Matches when rtx apt for exact match codec\", func(t *testing.T) {\n\t\tconst profileLevels = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=video 60323 UDP/TLS/RTP/SAVPF 94 95 106 107 108 109 96 97\na=rtpmap:94 VP8/90000\na=rtpmap:95 rtx/90000\na=fmtp:95 apt=94\na=rtpmap:106 H264/90000\na=fmtp:106 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\na=rtpmap:107 rtx/90000\na=fmtp:107 apt=106\na=rtpmap:108 H264/90000\na=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f\na=rtpmap:109 rtx/90000\na=fmtp:109 apt=108\na=rtpmap:96 VP9/90000\na=fmtp:96 profile-id=2\na=rtpmap:97 rtx/90000\na=fmtp:97 apt=96\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        96,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=96\", nil},\n\t\t\tPayloadType:        97,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\", nil},\n\t\t\tPayloadType:        102,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=102\", nil},\n\t\t\tPayloadType:        103,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f\", nil},\n\t\t\tPayloadType:        104,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=104\", nil},\n\t\t\tPayloadType:        105,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP9, 90000, 0, \"profile-id=2\", nil},\n\t\t\tPayloadType:        98,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=98\", nil},\n\t\t\tPayloadType:        99,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(profileLevels)))\n\n\t\tassert.True(t, m.negotiatedVideo)\n\n\t\tvp9Codec, _, err := m.getCodecByPayload(96)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, vp9Codec.MimeType, MimeTypeVP9)\n\t\tvp9RTX, _, err := m.getCodecByPayload(97)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, vp9RTX.MimeType, MimeTypeRTX)\n\n\t\th264P1Codec, _, err := m.getCodecByPayload(106)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, h264P1Codec.MimeType, MimeTypeH264)\n\t\tassert.Equal(t, h264P1Codec.SDPFmtpLine, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\")\n\t\th264P1RTX, _, err := m.getCodecByPayload(107)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, h264P1RTX.MimeType, MimeTypeRTX)\n\t\tassert.Equal(t, h264P1RTX.SDPFmtpLine, \"apt=106\")\n\n\t\th264P0Codec, _, err := m.getCodecByPayload(108)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, h264P0Codec.MimeType, MimeTypeH264)\n\t\tassert.Equal(t, h264P0Codec.SDPFmtpLine, \"level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001f\")\n\t\th264P0RTX, _, err := m.getCodecByPayload(109)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, h264P0RTX.MimeType, MimeTypeRTX)\n\t\tassert.Equal(t, h264P0RTX.SDPFmtpLine, \"apt=108\")\n\t})\n\n\tt.Run(\"Matches when rtx apt for partial match codec\", func(t *testing.T) {\n\t\tconst profileLevels = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=video 60323 UDP/TLS/RTP/SAVPF 94 96 97\na=rtpmap:94 VP8/90000\na=rtpmap:96 VP9/90000\na=fmtp:96 profile-id=2\na=rtpmap:97 rtx/90000\na=fmtp:97 apt=96\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        94,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP9, 90000, 0, \"profile-id=1\", nil},\n\t\t\tPayloadType:        96,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=96\", nil},\n\t\t\tPayloadType:        97,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(profileLevels)))\n\n\t\tassert.True(t, m.negotiatedVideo)\n\n\t\t_, _, err := m.getCodecByPayload(97)\n\t\tassert.ErrorIs(t, err, ErrCodecNotFound)\n\t})\n}\n\nfunc TestMediaEngineHeaderExtensionDirection(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tregisterCodec := func(m *MediaEngine) {\n\t\tassert.NoError(t, m.RegisterCodec(\n\t\t\tRTPCodecParameters{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},\n\t\t\t\tPayloadType:        111,\n\t\t\t}, RTPCodecTypeAudio))\n\t}\n\n\tt.Run(\"No Direction\", func(t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tregisterCodec(m)\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test\"}, RTPCodecTypeAudio))\n\n\t\tparams := m.getRTPParametersByKind(RTPCodecTypeAudio, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})\n\n\t\tassert.Equal(t, 1, len(params.HeaderExtensions))\n\t})\n\n\tt.Run(\"Same Direction\", func(t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tregisterCodec(m)\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test\"}, RTPCodecTypeAudio, RTPTransceiverDirectionRecvonly))\n\n\t\tparams := m.getRTPParametersByKind(RTPCodecTypeAudio, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})\n\n\t\tassert.Equal(t, 1, len(params.HeaderExtensions))\n\t})\n\n\tt.Run(\"Different Direction\", func(t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tregisterCodec(m)\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test\"}, RTPCodecTypeAudio, RTPTransceiverDirectionSendonly))\n\n\t\tparams := m.getRTPParametersByKind(RTPCodecTypeAudio, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})\n\n\t\tassert.Equal(t, 0, len(params.HeaderExtensions))\n\t})\n\n\tt.Run(\"Invalid Direction\", func(t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tregisterCodec(m)\n\n\t\tassert.ErrorIs(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test\"}, RTPCodecTypeAudio, RTPTransceiverDirectionSendrecv), ErrRegisterHeaderExtensionInvalidDirection)\n\t\tassert.ErrorIs(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test\"}, RTPCodecTypeAudio, RTPTransceiverDirectionInactive), ErrRegisterHeaderExtensionInvalidDirection)\n\t\tassert.ErrorIs(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test\"}, RTPCodecTypeAudio, RTPTransceiverDirection(0)), ErrRegisterHeaderExtensionInvalidDirection)\n\t})\n\n\tt.Run(\"Unique extmapid with different codec\", func(t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tregisterCodec(m)\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test\"}, RTPCodecTypeAudio))\n\t\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"pion-header-test2\"}, RTPCodecTypeVideo))\n\n\t\taudio := m.getRTPParametersByKind(RTPCodecTypeAudio, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})\n\t\tvideo := m.getRTPParametersByKind(RTPCodecTypeVideo, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})\n\n\t\tassert.Equal(t, 1, len(audio.HeaderExtensions))\n\t\tassert.Equal(t, 1, len(video.HeaderExtensions))\n\t\tassert.NotEqual(t, audio.HeaderExtensions[0].ID, video.HeaderExtensions[0].ID)\n\t})\n}\n\n// If a user attempts to register a codec twice we should just discard duplicate calls\nfunc TestMediaEngineDoubleRegister(t *testing.T) {\n\tm := MediaEngine{}\n\n\tassert.NoError(t, m.RegisterCodec(\n\t\tRTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},\n\t\t\tPayloadType:        111,\n\t\t}, RTPCodecTypeAudio))\n\n\tassert.NoError(t, m.RegisterCodec(\n\t\tRTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},\n\t\t\tPayloadType:        111,\n\t\t}, RTPCodecTypeAudio))\n\n\tassert.Equal(t, len(m.audioCodecs), 1)\n}\n\n// The cloned MediaEngine instance should be able to update negotiated header extensions.\nfunc TestUpdateHeaderExtenstionToClonedMediaEngine(t *testing.T) {\n\tsrc := MediaEngine{}\n\n\tassert.NoError(t, src.RegisterCodec(\n\t\tRTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 0, \"\", nil},\n\t\t\tPayloadType:        111,\n\t\t}, RTPCodecTypeAudio))\n\n\tassert.NoError(t, src.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"test-extension\"}, RTPCodecTypeAudio))\n\n\tvalidate := func(m *MediaEngine) {\n\t\tassert.NoError(t, m.updateHeaderExtension(2, \"test-extension\", RTPCodecTypeAudio))\n\n\t\tid, audioNegotiated, videoNegotiated := m.getHeaderExtensionID(RTPHeaderExtensionCapability{URI: \"test-extension\"})\n\t\tassert.Equal(t, 2, id)\n\t\tassert.True(t, audioNegotiated)\n\t\tassert.False(t, videoNegotiated)\n\t}\n\n\tvalidate(&src)\n\tvalidate(src.copy())\n}\n\nfunc TestExtensionIdCollision(t *testing.T) {\n\tmustParse := func(raw string) sdp.SessionDescription {\n\t\ts := sdp.SessionDescription{}\n\t\tassert.NoError(t, s.Unmarshal([]byte(raw)))\n\t\treturn s\n\t}\n\tsdpSnippet := `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\nm=audio 9 UDP/TLS/RTP/SAVPF 111\na=extmap:2 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:5 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id\na=rtpmap:111 opus/48000/2\n`\n\n\tm := MediaEngine{}\n\tassert.NoError(t, m.RegisterDefaultCodecs())\n\n\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{sdp.SDESMidURI}, RTPCodecTypeVideo))\n\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{\"urn:3gpp:video-orientation\"}, RTPCodecTypeVideo))\n\n\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{sdp.SDESMidURI}, RTPCodecTypeAudio))\n\tassert.NoError(t, m.RegisterHeaderExtension(RTPHeaderExtensionCapability{sdp.AudioLevelURI}, RTPCodecTypeAudio))\n\n\tassert.NoError(t, m.updateFromRemoteDescription(mustParse(sdpSnippet)))\n\n\tassert.True(t, m.negotiatedAudio)\n\tassert.False(t, m.negotiatedVideo)\n\n\tid, audioNegotiated, videoNegotiated := m.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.ABSSendTimeURI})\n\tassert.Equal(t, id, 0)\n\tassert.False(t, audioNegotiated)\n\tassert.False(t, videoNegotiated)\n\n\tid, audioNegotiated, videoNegotiated = m.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.SDESMidURI})\n\tassert.Equal(t, id, 2)\n\tassert.True(t, audioNegotiated)\n\tassert.False(t, videoNegotiated)\n\n\tid, audioNegotiated, videoNegotiated = m.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.AudioLevelURI})\n\tassert.Equal(t, id, 1)\n\tassert.True(t, audioNegotiated)\n\tassert.False(t, videoNegotiated)\n\n\tparams := m.getRTPParametersByKind(RTPCodecTypeVideo, []RTPTransceiverDirection{RTPTransceiverDirectionSendonly})\n\textensions := params.HeaderExtensions\n\n\tassert.Equal(t, 2, len(extensions))\n\n\tmidIndex := -1\n\tif extensions[0].URI == sdp.SDESMidURI {\n\t\tmidIndex = 0\n\t} else if extensions[1].URI == sdp.SDESMidURI {\n\t\tmidIndex = 1\n\t}\n\n\tvoIndex := -1\n\tif extensions[0].URI == \"urn:3gpp:video-orientation\" {\n\t\tvoIndex = 0\n\t} else if extensions[1].URI == \"urn:3gpp:video-orientation\" {\n\t\tvoIndex = 1\n\t}\n\n\tassert.NotEqual(t, midIndex, -1)\n\tassert.NotEqual(t, voIndex, -1)\n\n\tassert.Equal(t, 2, extensions[midIndex].ID)\n\tassert.NotEqual(t, 1, extensions[voIndex].ID)\n\tassert.NotEqual(t, 2, extensions[voIndex].ID)\n\tassert.NotEqual(t, 5, extensions[voIndex].ID)\n}\n\nfunc TestCaseInsensitiveMimeType(t *testing.T) {\n\tconst offerSdp = `\nv=0\no=- 8448668841136641781 4 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 1\na=extmap-allow-mixed\na=msid-semantic: WMS 4beea6b0-cf95-449c-a1ec-78e16b247426\nm=video 9 UDP/TLS/RTP/SAVPF 96 127\nc=IN IP4 0.0.0.0\na=rtcp:9 IN IP4 0.0.0.0\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=ice-options:google-ice\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=setup:actpass\na=mid:1\na=sendonly\na=rtpmap:96 VP8/90000\na=rtcp-fb:96 goog-remb\na=rtcp-fb:96 transport-cc\na=rtcp-fb:96 ccm fir\na=rtcp-fb:96 nack\na=rtcp-fb:96 nack pli\na=rtpmap:127 H264/90000\na=rtcp-fb:127 goog-remb\na=rtcp-fb:127 transport-cc\na=rtcp-fb:127 ccm fir\na=rtcp-fb:127 nack\na=rtcp-fb:127 nack pli\na=fmtp:127 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\n\n`\n\n\tfor _, mimeTypeVp8 := range []string{\n\t\t\"video/vp8\",\n\t\t\"video/VP8\",\n\t} {\n\t\tt.Run(fmt.Sprintf(\"MimeType: %s\", mimeTypeVp8), func(t *testing.T) {\n\t\t\tme := &MediaEngine{}\n\t\t\tfeedback := []RTCPFeedback{\n\t\t\t\t{Type: TypeRTCPFBTransportCC},\n\t\t\t\t{Type: TypeRTCPFBCCM, Parameter: \"fir\"},\n\t\t\t\t{Type: TypeRTCPFBNACK},\n\t\t\t\t{Type: TypeRTCPFBNACK, Parameter: \"pli\"},\n\t\t\t}\n\n\t\t\tfor _, codec := range []RTPCodecParameters{\n\t\t\t\t{\n\t\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: mimeTypeVp8, ClockRate: 90000, RTCPFeedback: feedback},\n\t\t\t\t\tPayloadType:        96,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/h264\", ClockRate: 90000, SDPFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\", RTCPFeedback: feedback},\n\t\t\t\t\tPayloadType:        127,\n\t\t\t\t},\n\t\t\t} {\n\t\t\t\tassert.NoError(t, me.RegisterCodec(codec, RTPCodecTypeVideo))\n\t\t\t}\n\n\t\t\tapi := NewAPI(WithMediaEngine(me))\n\t\t\tpc, err := api.NewPeerConnection(Configuration{\n\t\t\t\tSDPSemantics: SDPSemanticsUnifiedPlan,\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\n\t\t\toffer := SessionDescription{\n\t\t\t\tType: SDPTypeOffer,\n\t\t\t\tSDP:  offerSdp,\n\t\t\t}\n\n\t\t\tassert.NoError(t, pc.SetRemoteDescription(offer))\n\t\t\tanswer, err := pc.CreateAnswer(nil)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotNil(t, answer)\n\t\t\tassert.NoError(t, pc.SetLocalDescription(answer))\n\t\t\tassert.True(t, strings.Contains(answer.SDP, \"VP8\") || strings.Contains(answer.SDP, \"vp8\"))\n\n\t\t\tassert.NoError(t, pc.Close())\n\t\t})\n\t}\n}\n\n// rtcp-fb should be an intersection of local and remote\nfunc TestRTCPFeedbackHandling(t *testing.T) {\n\tconst offerSdp = `\nv=0\no=- 8448668841136641781 4 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0\na=extmap-allow-mixed\na=msid-semantic: WMS 4beea6b0-cf95-449c-a1ec-78e16b247426\nm=video 9 UDP/TLS/RTP/SAVPF 96\nc=IN IP4 0.0.0.0\na=rtcp:9 IN IP4 0.0.0.0\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=ice-options:google-ice\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=setup:actpass\na=mid:0\na=sendrecv\na=rtpmap:96 VP8/90000\na=rtcp-fb:96 goog-remb\na=rtcp-fb:96 nack\n`\n\n\trunTest := func(createTransceiver bool, t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeVP8, ClockRate: 90000, RTCPFeedback: []RTCPFeedback{\n\t\t\t\t{Type: TypeRTCPFBTransportCC},\n\t\t\t\t{Type: TypeRTCPFBNACK},\n\t\t\t}},\n\t\t\tPayloadType: 96,\n\t\t}, RTPCodecTypeVideo))\n\n\t\tpeerConnection, err := NewAPI(WithMediaEngine(m)).NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\tif createTransceiver {\n\t\t\t_, err = peerConnection.AddTransceiverFromKind(RTPCodecTypeVideo)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\n\t\tassert.NoError(t, peerConnection.SetRemoteDescription(SessionDescription{\n\t\t\tType: SDPTypeOffer,\n\t\t\tSDP:  offerSdp,\n\t\t},\n\t\t))\n\n\t\tanswer, err := peerConnection.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\t// Both clients support\n\t\tassert.True(t, strings.Contains(answer.SDP, \"a=rtcp-fb:96 nack\"))\n\n\t\t// Only one client supports\n\t\tassert.False(t, strings.Contains(answer.SDP, \"a=rtcp-fb:96 goog-remb\"))\n\t\tassert.False(t, strings.Contains(answer.SDP, \"a=rtcp-fb:96 transport-cc\"))\n\n\t\tassert.NoError(t, peerConnection.Close())\n\t}\n\n\tt.Run(\"recvonly\", func(t *testing.T) {\n\t\trunTest(false, t)\n\t})\n\n\tt.Run(\"sendrecv\", func(t *testing.T) {\n\t\trunTest(true, t)\n\t})\n}\n"
        },
        {
          "name": "networktype.go",
          "type": "blob",
          "size": 2.4423828125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pion/ice/v4\"\n)\n\nfunc supportedNetworkTypes() []NetworkType {\n\treturn []NetworkType{\n\t\tNetworkTypeUDP4,\n\t\tNetworkTypeUDP6,\n\t\t// NetworkTypeTCP4, // Not supported yet\n\t\t// NetworkTypeTCP6, // Not supported yet\n\t}\n}\n\n// NetworkType represents the type of network\ntype NetworkType int\n\nconst (\n\t// NetworkTypeUnknown is the enum's zero-value\n\tNetworkTypeUnknown NetworkType = iota\n\n\t// NetworkTypeUDP4 indicates UDP over IPv4.\n\tNetworkTypeUDP4\n\n\t// NetworkTypeUDP6 indicates UDP over IPv6.\n\tNetworkTypeUDP6\n\n\t// NetworkTypeTCP4 indicates TCP over IPv4.\n\tNetworkTypeTCP4\n\n\t// NetworkTypeTCP6 indicates TCP over IPv6.\n\tNetworkTypeTCP6\n)\n\n// This is done this way because of a linter.\nconst (\n\tnetworkTypeUDP4Str = \"udp4\"\n\tnetworkTypeUDP6Str = \"udp6\"\n\tnetworkTypeTCP4Str = \"tcp4\"\n\tnetworkTypeTCP6Str = \"tcp6\"\n)\n\nfunc (t NetworkType) String() string {\n\tswitch t {\n\tcase NetworkTypeUDP4:\n\t\treturn networkTypeUDP4Str\n\tcase NetworkTypeUDP6:\n\t\treturn networkTypeUDP6Str\n\tcase NetworkTypeTCP4:\n\t\treturn networkTypeTCP4Str\n\tcase NetworkTypeTCP6:\n\t\treturn networkTypeTCP6Str\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// Protocol returns udp or tcp\nfunc (t NetworkType) Protocol() string {\n\tswitch t {\n\tcase NetworkTypeUDP4:\n\t\treturn \"udp\"\n\tcase NetworkTypeUDP6:\n\t\treturn \"udp\"\n\tcase NetworkTypeTCP4:\n\t\treturn \"tcp\"\n\tcase NetworkTypeTCP6:\n\t\treturn \"tcp\"\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// NewNetworkType allows create network type from string\n// It will be useful for getting custom network types from external config.\nfunc NewNetworkType(raw string) (NetworkType, error) {\n\tswitch raw {\n\tcase networkTypeUDP4Str:\n\t\treturn NetworkTypeUDP4, nil\n\tcase networkTypeUDP6Str:\n\t\treturn NetworkTypeUDP6, nil\n\tcase networkTypeTCP4Str:\n\t\treturn NetworkTypeTCP4, nil\n\tcase networkTypeTCP6Str:\n\t\treturn NetworkTypeTCP6, nil\n\tdefault:\n\t\treturn NetworkTypeUnknown, fmt.Errorf(\"%w: %s\", errNetworkTypeUnknown, raw)\n\t}\n}\n\nfunc getNetworkType(iceNetworkType ice.NetworkType) (NetworkType, error) {\n\tswitch iceNetworkType {\n\tcase ice.NetworkTypeUDP4:\n\t\treturn NetworkTypeUDP4, nil\n\tcase ice.NetworkTypeUDP6:\n\t\treturn NetworkTypeUDP6, nil\n\tcase ice.NetworkTypeTCP4:\n\t\treturn NetworkTypeTCP4, nil\n\tcase ice.NetworkTypeTCP6:\n\t\treturn NetworkTypeTCP6, nil\n\tdefault:\n\t\treturn NetworkTypeUnknown, fmt.Errorf(\"%w: %s\", errNetworkTypeUnknown, iceNetworkType.String())\n\t}\n}\n"
        },
        {
          "name": "networktype_test.go",
          "type": "blob",
          "size": 1.1923828125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNetworkType_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tcType          NetworkType\n\t\texpectedString string\n\t}{\n\t\t{NetworkTypeUnknown, ErrUnknownType.Error()},\n\t\t{NetworkTypeUDP4, \"udp4\"},\n\t\t{NetworkTypeUDP6, \"udp6\"},\n\t\t{NetworkTypeTCP4, \"tcp4\"},\n\t\t{NetworkTypeTCP6, \"tcp6\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.cType.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestNetworkType(t *testing.T) {\n\ttestCases := []struct {\n\t\ttypeString   string\n\t\tshouldFail   bool\n\t\texpectedType NetworkType\n\t}{\n\t\t{ErrUnknownType.Error(), true, NetworkTypeUnknown},\n\t\t{\"udp4\", false, NetworkTypeUDP4},\n\t\t{\"udp6\", false, NetworkTypeUDP6},\n\t\t{\"tcp4\", false, NetworkTypeTCP4},\n\t\t{\"tcp6\", false, NetworkTypeTCP6},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tactual, err := NewNetworkType(testCase.typeString)\n\t\tif (err != nil) != testCase.shouldFail {\n\t\t\tt.Error(err)\n\t\t}\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedType,\n\t\t\tactual,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "oauthcredential.go",
          "type": "blob",
          "size": 0.6806640625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// OAuthCredential represents OAuth credential information which is used by\n// the STUN/TURN client to connect to an ICE server as defined in\n// https://tools.ietf.org/html/rfc7635. Note that the kid parameter is not\n// located in OAuthCredential, but in ICEServer's username member.\ntype OAuthCredential struct {\n\t// MACKey is a base64-url encoded format. It is used in STUN message\n\t// integrity hash calculation.\n\tMACKey string\n\n\t// AccessToken is a base64-encoded format. This is an encrypted\n\t// self-contained token that is opaque to the application.\n\tAccessToken string\n}\n"
        },
        {
          "name": "offeransweroptions.go",
          "type": "blob",
          "size": 0.9658203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// OfferAnswerOptions is a base structure which describes the options that\n// can be used to control the offer/answer creation process.\ntype OfferAnswerOptions struct {\n\t// VoiceActivityDetection allows the application to provide information\n\t// about whether it wishes voice detection feature to be enabled or disabled.\n\tVoiceActivityDetection bool\n}\n\n// AnswerOptions structure describes the options used to control the answer\n// creation process.\ntype AnswerOptions struct {\n\tOfferAnswerOptions\n}\n\n// OfferOptions structure describes the options used to control the offer\n// creation process\ntype OfferOptions struct {\n\tOfferAnswerOptions\n\n\t// ICERestart forces the underlying ice gathering process to be restarted.\n\t// When this value is true, the generated description will have ICE\n\t// credentials that are different from the current credentials\n\tICERestart bool\n}\n"
        },
        {
          "name": "operations.go",
          "type": "blob",
          "size": 3.1904296875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"container/list\"\n\t\"sync\"\n)\n\n// Operation is a function\ntype operation func()\n\n// Operations is a task executor.\ntype operations struct {\n\tmu     sync.Mutex\n\tbusyCh chan struct{}\n\tops    *list.List\n\n\tupdateNegotiationNeededFlagOnEmptyChain *atomicBool\n\tonNegotiationNeeded                     func()\n\tisClosed                                bool\n}\n\nfunc newOperations(\n\tupdateNegotiationNeededFlagOnEmptyChain *atomicBool,\n\tonNegotiationNeeded func(),\n) *operations {\n\treturn &operations{\n\t\tops:                                     list.New(),\n\t\tupdateNegotiationNeededFlagOnEmptyChain: updateNegotiationNeededFlagOnEmptyChain,\n\t\tonNegotiationNeeded:                     onNegotiationNeeded,\n\t}\n}\n\n// Enqueue adds a new action to be executed. If there are no actions scheduled,\n// the execution will start immediately in a new goroutine. If the queue has been\n// closed, the operation will be dropped. The queue is only deliberately closed\n// by a user.\nfunc (o *operations) Enqueue(op operation) {\n\to.mu.Lock()\n\tdefer o.mu.Unlock()\n\t_ = o.tryEnqueue(op)\n}\n\n// tryEnqueue attempts to enqueue the given operation. It returns false\n// if the op is invalid or the queue is closed. mu must be locked by\n// tryEnqueue's caller.\nfunc (o *operations) tryEnqueue(op operation) bool {\n\tif op == nil {\n\t\treturn false\n\t}\n\n\tif o.isClosed {\n\t\treturn false\n\t}\n\to.ops.PushBack(op)\n\n\tif o.busyCh == nil {\n\t\to.busyCh = make(chan struct{})\n\t\tgo o.start()\n\t}\n\n\treturn true\n}\n\n// IsEmpty checks if there are tasks in the queue\nfunc (o *operations) IsEmpty() bool {\n\to.mu.Lock()\n\tdefer o.mu.Unlock()\n\treturn o.ops.Len() == 0\n}\n\n// Done blocks until all currently enqueued operations are finished executing.\n// For more complex synchronization, use Enqueue directly.\nfunc (o *operations) Done() {\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\to.mu.Lock()\n\tenqueued := o.tryEnqueue(func() {\n\t\twg.Done()\n\t})\n\to.mu.Unlock()\n\tif !enqueued {\n\t\treturn\n\t}\n\twg.Wait()\n}\n\n// GracefulClose waits for the operations queue to be cleared and forbids\n// new operations from being enqueued.\nfunc (o *operations) GracefulClose() {\n\to.mu.Lock()\n\tif o.isClosed {\n\t\to.mu.Unlock()\n\t\treturn\n\t}\n\t// do not enqueue anymore ops from here on\n\t// o.isClosed=true will also not allow a new busyCh\n\t// to be created.\n\to.isClosed = true\n\n\tbusyCh := o.busyCh\n\to.mu.Unlock()\n\tif busyCh == nil {\n\t\treturn\n\t}\n\t<-busyCh\n}\n\nfunc (o *operations) pop() func() {\n\to.mu.Lock()\n\tdefer o.mu.Unlock()\n\tif o.ops.Len() == 0 {\n\t\treturn nil\n\t}\n\n\te := o.ops.Front()\n\to.ops.Remove(e)\n\tif op, ok := e.Value.(operation); ok {\n\t\treturn op\n\t}\n\treturn nil\n}\n\nfunc (o *operations) start() {\n\tdefer func() {\n\t\to.mu.Lock()\n\t\tdefer o.mu.Unlock()\n\t\t// this wil lbe the most recent busy chan\n\t\tclose(o.busyCh)\n\n\t\tif o.ops.Len() == 0 || o.isClosed {\n\t\t\to.busyCh = nil\n\t\t\treturn\n\t\t}\n\n\t\t// either a new operation was enqueued while we\n\t\t// were busy, or an operation panicked\n\t\to.busyCh = make(chan struct{})\n\t\tgo o.start()\n\t}()\n\n\tfn := o.pop()\n\tfor fn != nil {\n\t\tfn()\n\t\tfn = o.pop()\n\t}\n\tif !o.updateNegotiationNeededFlagOnEmptyChain.get() {\n\t\treturn\n\t}\n\to.updateNegotiationNeededFlagOnEmptyChain.set(false)\n\to.onNegotiationNeeded()\n}\n"
        },
        {
          "name": "operations_test.go",
          "type": "blob",
          "size": 1.8642578125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestOperations_Enqueue(t *testing.T) {\n\tupdateNegotiationNeededFlagOnEmptyChain := &atomicBool{}\n\tonNegotiationNeededCalledCount := 0\n\tvar onNegotiationNeededCalledCountMu sync.Mutex\n\tops := newOperations(updateNegotiationNeededFlagOnEmptyChain, func() {\n\t\tonNegotiationNeededCalledCountMu.Lock()\n\t\tonNegotiationNeededCalledCount++\n\t\tonNegotiationNeededCalledCountMu.Unlock()\n\t})\n\tdefer ops.GracefulClose()\n\n\tfor resultSet := 0; resultSet < 100; resultSet++ {\n\t\tresults := make([]int, 16)\n\t\tresultSetCopy := resultSet\n\t\tfor i := range results {\n\t\t\tfunc(j int) {\n\t\t\t\tops.Enqueue(func() {\n\t\t\t\t\tresults[j] = j * j\n\t\t\t\t\tif resultSetCopy > 50 {\n\t\t\t\t\t\tupdateNegotiationNeededFlagOnEmptyChain.set(true)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}(i)\n\t\t}\n\n\t\tops.Done()\n\t\texpected := []int{0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225}\n\t\tassert.Equal(t, len(expected), len(results))\n\t\tassert.Equal(t, expected, results)\n\t}\n\tonNegotiationNeededCalledCountMu.Lock()\n\tdefer onNegotiationNeededCalledCountMu.Unlock()\n\tassert.NotEqual(t, onNegotiationNeededCalledCount, 0)\n}\n\nfunc TestOperations_Done(*testing.T) {\n\tops := newOperations(&atomicBool{}, func() {\n\t})\n\tdefer ops.GracefulClose()\n\tops.Done()\n}\n\nfunc TestOperations_GracefulClose(t *testing.T) {\n\tops := newOperations(&atomicBool{}, func() {\n\t})\n\n\tcounter := 0\n\tvar counterMu sync.Mutex\n\tincFunc := func() {\n\t\tcounterMu.Lock()\n\t\tcounter++\n\t\tcounterMu.Unlock()\n\t}\n\tconst times = 25\n\tfor i := 0; i < times; i++ {\n\t\tops.Enqueue(incFunc)\n\t}\n\tops.Done()\n\tcounterMu.Lock()\n\tcounterCur := counter\n\tcounterMu.Unlock()\n\tassert.Equal(t, counterCur, times)\n\n\tops.GracefulClose()\n\tfor i := 0; i < times; i++ {\n\t\tops.Enqueue(incFunc)\n\t}\n\tops.Done()\n\tassert.Equal(t, counterCur, times)\n}\n"
        },
        {
          "name": "ortc_datachannel_test.go",
          "type": "blob",
          "size": 2.2548828125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDataChannel_ORTC_SCTPTransport(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tstackA, stackB, err := newORTCPair()\n\tassert.NoError(t, err)\n\n\tgetSelectedCandidatePairErrChan := make(chan error)\n\tstackB.sctp.OnDataChannel(func(d *DataChannel) {\n\t\t_, getSelectedCandidatePairErr := d.Transport().Transport().ICETransport().GetSelectedCandidatePair()\n\t\tgetSelectedCandidatePairErrChan <- getSelectedCandidatePairErr\n\t})\n\n\tassert.NoError(t, signalORTCPair(stackA, stackB))\n\n\tvar id uint16 = 1\n\t_, err = stackA.api.NewDataChannel(stackA.sctp, &DataChannelParameters{\n\t\tLabel: \"Foo\",\n\t\tID:    &id,\n\t})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, <-getSelectedCandidatePairErrChan)\n\tassert.NoError(t, stackA.close())\n\tassert.NoError(t, stackB.close())\n}\n\nfunc TestDataChannel_ORTCE2E(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tstackA, stackB, err := newORTCPair()\n\tassert.NoError(t, err)\n\n\tawaitSetup := make(chan struct{})\n\tawaitString := make(chan struct{})\n\tawaitBinary := make(chan struct{})\n\tstackB.sctp.OnDataChannel(func(d *DataChannel) {\n\t\tclose(awaitSetup)\n\n\t\td.OnMessage(func(msg DataChannelMessage) {\n\t\t\tif msg.IsString {\n\t\t\t\tclose(awaitString)\n\t\t\t} else {\n\t\t\t\tclose(awaitBinary)\n\t\t\t}\n\t\t})\n\t})\n\n\tassert.NoError(t, signalORTCPair(stackA, stackB))\n\n\tvar id uint16 = 1\n\tdcParams := &DataChannelParameters{\n\t\tLabel: \"Foo\",\n\t\tID:    &id,\n\t}\n\tchannelA, err := stackA.api.NewDataChannel(stackA.sctp, dcParams)\n\tassert.NoError(t, err)\n\n\t<-awaitSetup\n\n\tassert.NoError(t, channelA.SendText(\"ABC\"))\n\tassert.NoError(t, channelA.Send([]byte(\"ABC\")))\n\n\t<-awaitString\n\t<-awaitBinary\n\n\tassert.NoError(t, stackA.close())\n\tassert.NoError(t, stackB.close())\n\n\t// attempt to send when channel is closed\n\tassert.ErrorIs(t, channelA.Send([]byte(\"ABC\")), io.ErrClosedPipe)\n\tassert.ErrorIs(t, channelA.SendText(\"test\"), io.ErrClosedPipe)\n\tassert.ErrorIs(t, channelA.ensureOpen(), io.ErrClosedPipe)\n}\n"
        },
        {
          "name": "ortc_media_test.go",
          "type": "blob",
          "size": 1.6767578125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_ORTC_Media(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tstackA, stackB, err := newORTCPair()\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalORTCPair(stackA, stackB))\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\trtpSender, err := stackA.api.NewRTPSender(track, stackA.dtls)\n\tassert.NoError(t, err)\n\tassert.NoError(t, rtpSender.Send(rtpSender.GetParameters()))\n\n\trtpReceiver, err := stackB.api.NewRTPReceiver(RTPCodecTypeVideo, stackB.dtls)\n\tassert.NoError(t, err)\n\tassert.NoError(t, rtpReceiver.Receive(RTPReceiveParameters{Encodings: []RTPDecodingParameters{\n\t\t{RTPCodingParameters: rtpSender.GetParameters().Encodings[0].RTPCodingParameters},\n\t}}))\n\n\tseenPacket, seenPacketCancel := context.WithCancel(context.Background())\n\tgo func() {\n\t\ttrack := rtpReceiver.Track()\n\t\t_, _, err := track.ReadRTP()\n\t\tassert.NoError(t, err)\n\n\t\tseenPacketCancel()\n\t}()\n\n\tfunc() {\n\t\tfor range time.Tick(time.Millisecond * 20) {\n\t\t\tselect {\n\t\t\tcase <-seenPacket.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0xAA}, Duration: time.Second}))\n\t\t\t}\n\t\t}\n\t}()\n\n\tassert.NoError(t, rtpSender.Stop())\n\tassert.NoError(t, rtpReceiver.Stop())\n\n\tassert.NoError(t, stackA.close())\n\tassert.NoError(t, stackB.close())\n}\n"
        },
        {
          "name": "ortc_test.go",
          "type": "blob",
          "size": 3.3603515625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"github.com/pion/webrtc/v4/internal/util\"\n)\n\ntype testORTCStack struct {\n\tapi      *API\n\tgatherer *ICEGatherer\n\tice      *ICETransport\n\tdtls     *DTLSTransport\n\tsctp     *SCTPTransport\n}\n\nfunc (s *testORTCStack) setSignal(sig *testORTCSignal, isOffer bool) error {\n\ticeRole := ICERoleControlled\n\tif isOffer {\n\t\ticeRole = ICERoleControlling\n\t}\n\n\terr := s.ice.SetRemoteCandidates(sig.ICECandidates)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Start the ICE transport\n\terr = s.ice.Start(nil, sig.ICEParameters, &iceRole)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Start the DTLS transport\n\terr = s.dtls.Start(sig.DTLSParameters)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Start the SCTP transport\n\terr = s.sctp.Start(sig.SCTPCapabilities)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *testORTCStack) getSignal() (*testORTCSignal, error) {\n\tgatherFinished := make(chan struct{})\n\ts.gatherer.OnLocalCandidate(func(i *ICECandidate) {\n\t\tif i == nil {\n\t\t\tclose(gatherFinished)\n\t\t}\n\t})\n\n\tif err := s.gatherer.Gather(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t<-gatherFinished\n\ticeCandidates, err := s.gatherer.GetLocalCandidates()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ticeParams, err := s.gatherer.GetLocalParameters()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdtlsParams, err := s.dtls.GetLocalParameters()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsctpCapabilities := s.sctp.GetCapabilities()\n\n\treturn &testORTCSignal{\n\t\tICECandidates:    iceCandidates,\n\t\tICEParameters:    iceParams,\n\t\tDTLSParameters:   dtlsParams,\n\t\tSCTPCapabilities: sctpCapabilities,\n\t}, nil\n}\n\nfunc (s *testORTCStack) close() error {\n\tvar closeErrs []error\n\n\tif err := s.sctp.Stop(); err != nil {\n\t\tcloseErrs = append(closeErrs, err)\n\t}\n\n\tif err := s.ice.Stop(); err != nil {\n\t\tcloseErrs = append(closeErrs, err)\n\t}\n\n\treturn util.FlattenErrs(closeErrs)\n}\n\ntype testORTCSignal struct {\n\tICECandidates    []ICECandidate\n\tICEParameters    ICEParameters\n\tDTLSParameters   DTLSParameters\n\tSCTPCapabilities SCTPCapabilities\n}\n\nfunc newORTCPair() (stackA *testORTCStack, stackB *testORTCStack, err error) {\n\tsa, err := newORTCStack()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsb, err := newORTCStack()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn sa, sb, nil\n}\n\nfunc newORTCStack() (*testORTCStack, error) {\n\t// Create an API object\n\tapi := NewAPI()\n\n\t// Create the ICE gatherer\n\tgatherer, err := api.NewICEGatherer(ICEGatherOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Construct the ICE transport\n\tice := api.NewICETransport(gatherer)\n\n\t// Construct the DTLS transport\n\tdtls, err := api.NewDTLSTransport(ice, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Construct the SCTP transport\n\tsctp := api.NewSCTPTransport(dtls)\n\n\treturn &testORTCStack{\n\t\tapi:      api,\n\t\tgatherer: gatherer,\n\t\tice:      ice,\n\t\tdtls:     dtls,\n\t\tsctp:     sctp,\n\t}, nil\n}\n\nfunc signalORTCPair(stackA *testORTCStack, stackB *testORTCStack) error {\n\tsigA, err := stackA.getSignal()\n\tif err != nil {\n\t\treturn err\n\t}\n\tsigB, err := stackB.getSignal()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta := make(chan error)\n\tb := make(chan error)\n\n\tgo func() {\n\t\ta <- stackB.setSignal(sigA, false)\n\t}()\n\n\tgo func() {\n\t\tb <- stackA.setSignal(sigB, true)\n\t}()\n\n\terrA := <-a\n\terrB := <-b\n\n\tcloseErrs := []error{errA, errB}\n\n\treturn util.FlattenErrs(closeErrs)\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.361328125,
          "content": "{\n  \"name\": \"webrtc\",\n  \"repository\": \"git@github.com:pion/webrtc.git\",\n  \"private\": true,\n  \"devDependencies\": {\n    \"@roamhq/wrtc\": \"^0.8.0\"\n  },\n  \"dependencies\": {\n    \"request\": \"2.88.2\"\n  },\n  \"packageManager\": \"yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e\"\n}\n"
        },
        {
          "name": "peerconnection.go",
          "type": "blob",
          "size": 84.7998046875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/rtcp\"\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/srtp/v3\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\n// PeerConnection represents a WebRTC connection that establishes a\n// peer-to-peer communications with another PeerConnection instance in a\n// browser, or to another endpoint implementing the required protocols.\ntype PeerConnection struct {\n\tstatsID string\n\tmu      sync.RWMutex\n\n\tsdpOrigin sdp.Origin\n\n\t// ops is an operations queue which will ensure the enqueued actions are\n\t// executed in order. It is used for asynchronously, but serially processing\n\t// remote and local descriptions\n\tops *operations\n\n\tconfiguration Configuration\n\n\tcurrentLocalDescription  *SessionDescription\n\tpendingLocalDescription  *SessionDescription\n\tcurrentRemoteDescription *SessionDescription\n\tpendingRemoteDescription *SessionDescription\n\tsignalingState           SignalingState\n\ticeConnectionState       atomic.Value // ICEConnectionState\n\tconnectionState          atomic.Value // PeerConnectionState\n\n\tidpLoginURL *string\n\n\tisClosed                                *atomicBool\n\tisGracefullyClosingOrClosed             bool\n\tisCloseDone                             chan struct{}\n\tisGracefulCloseDone                     chan struct{}\n\tisNegotiationNeeded                     *atomicBool\n\tupdateNegotiationNeededFlagOnEmptyChain *atomicBool\n\n\tlastOffer  string\n\tlastAnswer string\n\n\t// a value containing the last known greater mid value\n\t// we internally generate mids as numbers. Needed since JSEP\n\t// requires that when reusing a media section a new unique mid\n\t// should be defined (see JSEP 3.4.1).\n\tgreaterMid int\n\n\trtpTransceivers        []*RTPTransceiver\n\tnonMediaBandwidthProbe atomic.Value // RTPReceiver\n\n\tonSignalingStateChangeHandler     func(SignalingState)\n\tonICEConnectionStateChangeHandler atomic.Value // func(ICEConnectionState)\n\tonConnectionStateChangeHandler    atomic.Value // func(PeerConnectionState)\n\tonTrackHandler                    func(*TrackRemote, *RTPReceiver)\n\tonDataChannelHandler              func(*DataChannel)\n\tonNegotiationNeededHandler        atomic.Value // func()\n\n\ticeGatherer   *ICEGatherer\n\ticeTransport  *ICETransport\n\tdtlsTransport *DTLSTransport\n\tsctpTransport *SCTPTransport\n\n\t// A reference to the associated API state used by this connection\n\tapi *API\n\tlog logging.LeveledLogger\n\n\tinterceptorRTCPWriter interceptor.RTCPWriter\n}\n\n// NewPeerConnection creates a PeerConnection with the default codecs and interceptors.\n//\n// If you wish to customize the set of available codecs and/or the set of active interceptors,\n// create an API with a custom MediaEngine and/or interceptor.Registry,\n// then call [(*API).NewPeerConnection] instead of this function.\nfunc NewPeerConnection(configuration Configuration) (*PeerConnection, error) {\n\tapi := NewAPI()\n\treturn api.NewPeerConnection(configuration)\n}\n\n// NewPeerConnection creates a new PeerConnection with the provided configuration against the received API object.\n// This method will attach a default set of codecs and interceptors to\n// the resulting PeerConnection.  If this behavior is not desired,\n// set the set of codecs and interceptors explicitly by using\n// [WithMediaEngine] and [WithInterceptorRegistry] when calling [NewAPI].\nfunc (api *API) NewPeerConnection(configuration Configuration) (*PeerConnection, error) {\n\t// https://w3c.github.io/webrtc-pc/#constructor (Step #2)\n\t// Some variables defined explicitly despite their implicit zero values to\n\t// allow better readability to understand what is happening.\n\n\tpc := &PeerConnection{\n\t\tstatsID: fmt.Sprintf(\"PeerConnection-%d\", time.Now().UnixNano()),\n\t\tconfiguration: Configuration{\n\t\t\tICEServers:           []ICEServer{},\n\t\t\tICETransportPolicy:   ICETransportPolicyAll,\n\t\t\tBundlePolicy:         BundlePolicyBalanced,\n\t\t\tRTCPMuxPolicy:        RTCPMuxPolicyRequire,\n\t\t\tCertificates:         []Certificate{},\n\t\t\tICECandidatePoolSize: 0,\n\t\t},\n\t\tisClosed:                                &atomicBool{},\n\t\tisCloseDone:                             make(chan struct{}),\n\t\tisGracefulCloseDone:                     make(chan struct{}),\n\t\tisNegotiationNeeded:                     &atomicBool{},\n\t\tupdateNegotiationNeededFlagOnEmptyChain: &atomicBool{},\n\t\tlastOffer:                               \"\",\n\t\tlastAnswer:                              \"\",\n\t\tgreaterMid:                              -1,\n\t\tsignalingState:                          SignalingStateStable,\n\n\t\tapi: api,\n\t\tlog: api.settingEngine.LoggerFactory.NewLogger(\"pc\"),\n\t}\n\tpc.ops = newOperations(pc.updateNegotiationNeededFlagOnEmptyChain, pc.onNegotiationNeeded)\n\n\tpc.iceConnectionState.Store(ICEConnectionStateNew)\n\tpc.connectionState.Store(PeerConnectionStateNew)\n\n\ti, err := api.interceptorRegistry.Build(\"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpc.api = &API{\n\t\tsettingEngine: api.settingEngine,\n\t\tinterceptor:   i,\n\t}\n\n\tif api.settingEngine.disableMediaEngineCopy {\n\t\tpc.api.mediaEngine = api.mediaEngine\n\t} else {\n\t\tpc.api.mediaEngine = api.mediaEngine.copy()\n\t}\n\n\tif err = pc.initConfiguration(configuration); err != nil {\n\t\treturn nil, err\n\t}\n\n\tpc.iceGatherer, err = pc.createICEGatherer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create the ice transport\n\ticeTransport := pc.createICETransport()\n\tpc.iceTransport = iceTransport\n\n\t// Create the DTLS transport\n\tdtlsTransport, err := pc.api.NewDTLSTransport(pc.iceTransport, pc.configuration.Certificates)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpc.dtlsTransport = dtlsTransport\n\n\t// Create the SCTP transport\n\tpc.sctpTransport = pc.api.NewSCTPTransport(pc.dtlsTransport)\n\n\t// Wire up the on datachannel handler\n\tpc.sctpTransport.OnDataChannel(func(d *DataChannel) {\n\t\tpc.mu.RLock()\n\t\thandler := pc.onDataChannelHandler\n\t\tpc.mu.RUnlock()\n\t\tif handler != nil {\n\t\t\thandler(d)\n\t\t}\n\t})\n\n\tpc.interceptorRTCPWriter = pc.api.interceptor.BindRTCPWriter(interceptor.RTCPWriterFunc(pc.writeRTCP))\n\n\treturn pc, nil\n}\n\n// initConfiguration defines validation of the specified Configuration and\n// its assignment to the internal configuration variable. This function differs\n// from its SetConfiguration counterpart because most of the checks do not\n// include verification statements related to the existing state. Thus the\n// function describes only minor verification of some the struct variables.\nfunc (pc *PeerConnection) initConfiguration(configuration Configuration) error {\n\tif configuration.PeerIdentity != \"\" {\n\t\tpc.configuration.PeerIdentity = configuration.PeerIdentity\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#constructor (step #3)\n\tif len(configuration.Certificates) > 0 {\n\t\tnow := time.Now()\n\t\tfor _, x509Cert := range configuration.Certificates {\n\t\t\tif !x509Cert.Expires().IsZero() && now.After(x509Cert.Expires()) {\n\t\t\t\treturn &rtcerr.InvalidAccessError{Err: ErrCertificateExpired}\n\t\t\t}\n\t\t\tpc.configuration.Certificates = append(pc.configuration.Certificates, x509Cert)\n\t\t}\n\t} else {\n\t\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\tif err != nil {\n\t\t\treturn &rtcerr.UnknownError{Err: err}\n\t\t}\n\t\tcertificate, err := GenerateCertificate(sk)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpc.configuration.Certificates = []Certificate{*certificate}\n\t}\n\n\tif configuration.BundlePolicy != BundlePolicyUnknown {\n\t\tpc.configuration.BundlePolicy = configuration.BundlePolicy\n\t}\n\n\tif configuration.RTCPMuxPolicy != RTCPMuxPolicyUnknown {\n\t\tpc.configuration.RTCPMuxPolicy = configuration.RTCPMuxPolicy\n\t}\n\n\tif configuration.ICECandidatePoolSize != 0 {\n\t\tpc.configuration.ICECandidatePoolSize = configuration.ICECandidatePoolSize\n\t}\n\n\tpc.configuration.ICETransportPolicy = configuration.ICETransportPolicy\n\tpc.configuration.SDPSemantics = configuration.SDPSemantics\n\n\tsanitizedICEServers := configuration.getICEServers()\n\tif len(sanitizedICEServers) > 0 {\n\t\tfor _, server := range sanitizedICEServers {\n\t\t\tif err := server.validate(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tpc.configuration.ICEServers = sanitizedICEServers\n\t}\n\n\treturn nil\n}\n\n// OnSignalingStateChange sets an event handler which is invoked when the\n// peer connection's signaling state changes\nfunc (pc *PeerConnection) OnSignalingStateChange(f func(SignalingState)) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tpc.onSignalingStateChangeHandler = f\n}\n\nfunc (pc *PeerConnection) onSignalingStateChange(newState SignalingState) {\n\tpc.mu.RLock()\n\thandler := pc.onSignalingStateChangeHandler\n\tpc.mu.RUnlock()\n\n\tpc.log.Infof(\"signaling state changed to %s\", newState)\n\tif handler != nil {\n\t\tgo handler(newState)\n\t}\n}\n\n// OnDataChannel sets an event handler which is invoked when a data\n// channel message arrives from a remote peer.\nfunc (pc *PeerConnection) OnDataChannel(f func(*DataChannel)) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tpc.onDataChannelHandler = f\n}\n\n// OnNegotiationNeeded sets an event handler which is invoked when\n// a change has occurred which requires session negotiation\nfunc (pc *PeerConnection) OnNegotiationNeeded(f func()) {\n\tpc.onNegotiationNeededHandler.Store(f)\n}\n\n// onNegotiationNeeded enqueues negotiationNeededOp if necessary\n// caller of this method should hold `pc.mu` lock\n// https://www.w3.org/TR/webrtc/#dfn-update-the-negotiation-needed-flag\nfunc (pc *PeerConnection) onNegotiationNeeded() {\n\t// 4.7.3.1 If the length of connection.[[Operations]] is not 0, then set\n\t// connection.[[UpdateNegotiationNeededFlagOnEmptyChain]] to true, and abort these steps.\n\tif !pc.ops.IsEmpty() {\n\t\tpc.updateNegotiationNeededFlagOnEmptyChain.set(true)\n\t\treturn\n\t}\n\tpc.ops.Enqueue(pc.negotiationNeededOp)\n}\n\n// https://www.w3.org/TR/webrtc/#dfn-update-the-negotiation-needed-flag\nfunc (pc *PeerConnection) negotiationNeededOp() {\n\t// 4.7.3.2.1 If connection.[[IsClosed]] is true, abort these steps.\n\tif pc.isClosed.get() {\n\t\treturn\n\t}\n\n\t// 4.7.3.2.2 If the length of connection.[[Operations]] is not 0,\n\t// then set connection.[[UpdateNegotiationNeededFlagOnEmptyChain]] to\n\t// true, and abort these steps.\n\tif !pc.ops.IsEmpty() {\n\t\tpc.updateNegotiationNeededFlagOnEmptyChain.set(true)\n\t\treturn\n\t}\n\n\t// 4.7.3.2.3 If connection's signaling state is not \"stable\", abort these steps.\n\tif pc.SignalingState() != SignalingStateStable {\n\t\treturn\n\t}\n\n\t// 4.7.3.2.4 If the result of checking if negotiation is needed is false,\n\t// clear the negotiation-needed flag by setting connection.[[NegotiationNeeded]]\n\t// to false, and abort these steps.\n\tif !pc.checkNegotiationNeeded() {\n\t\tpc.isNegotiationNeeded.set(false)\n\t\treturn\n\t}\n\n\t// 4.7.3.2.5 If connection.[[NegotiationNeeded]] is already true, abort these steps.\n\tif pc.isNegotiationNeeded.get() {\n\t\treturn\n\t}\n\n\t// 4.7.3.2.6 Set connection.[[NegotiationNeeded]] to true.\n\tpc.isNegotiationNeeded.set(true)\n\n\t// 4.7.3.2.7 Fire an event named negotiationneeded at connection.\n\tif handler, ok := pc.onNegotiationNeededHandler.Load().(func()); ok && handler != nil {\n\t\thandler()\n\t}\n}\n\nfunc (pc *PeerConnection) checkNegotiationNeeded() bool { //nolint:gocognit\n\t// To check if negotiation is needed for connection, perform the following checks:\n\t// Skip 1, 2 steps\n\t// Step 3\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\tlocalDesc := pc.currentLocalDescription\n\tremoteDesc := pc.currentRemoteDescription\n\n\tif localDesc == nil {\n\t\treturn true\n\t}\n\n\tpc.sctpTransport.lock.Lock()\n\tlenDataChannel := len(pc.sctpTransport.dataChannels)\n\tpc.sctpTransport.lock.Unlock()\n\n\tif lenDataChannel != 0 && haveDataChannel(localDesc) == nil {\n\t\treturn true\n\t}\n\n\tfor _, t := range pc.rtpTransceivers {\n\t\t// https://www.w3.org/TR/webrtc/#dfn-update-the-negotiation-needed-flag\n\t\t// Step 5.1\n\t\t// if t.stopping && !t.stopped {\n\t\t// \treturn true\n\t\t// }\n\t\tm := getByMid(t.Mid(), localDesc)\n\n\t\t// Step 5.2\n\t\tif m == nil {\n\t\t\treturn true\n\t\t}\n\n\t\t// Step 5.3.1\n\t\tif t.Direction() == RTPTransceiverDirectionSendrecv || t.Direction() == RTPTransceiverDirectionSendonly {\n\t\t\tdescMsid, okMsid := m.Attribute(sdp.AttrKeyMsid)\n\t\t\tsender := t.Sender()\n\t\t\tif sender == nil {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\ttrack := sender.Track()\n\t\t\tif track == nil {\n\t\t\t\t// Situation when sender's track is nil could happen when\n\t\t\t\t// a) replaceTrack(nil) is called\n\t\t\t\t// b) removeTrack() is called, changing the transceiver's direction to inactive\n\t\t\t\t// As t.Direction() in this branch is either sendrecv or sendonly, we believe (a) option is the case\n\t\t\t\t// As calling replaceTrack does not require renegotiation, we skip check for this transceiver\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !okMsid || descMsid != track.StreamID()+\" \"+track.ID() {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\tswitch localDesc.Type {\n\t\tcase SDPTypeOffer:\n\t\t\t// Step 5.3.2\n\t\t\trm := getByMid(t.Mid(), remoteDesc)\n\t\t\tif rm == nil {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tif getPeerDirection(m) != t.Direction() && getPeerDirection(rm) != t.Direction().Revers() {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase SDPTypeAnswer:\n\t\t\t// Step 5.3.3\n\t\t\tif _, ok := m.Attribute(t.Direction().String()); !ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\tdefault:\n\t\t}\n\n\t\t// Step 5.4\n\t\t// if t.stopped && t.Mid() != \"\" {\n\t\t// \tif getByMid(t.Mid(), localDesc) != nil || getByMid(t.Mid(), remoteDesc) != nil {\n\t\t// \t\treturn true\n\t\t// \t}\n\t\t// }\n\t}\n\t// Step 6\n\treturn false\n}\n\n// OnICECandidate sets an event handler which is invoked when a new ICE\n// candidate is found.\n// ICE candidate gathering only begins when SetLocalDescription or\n// SetRemoteDescription is called.\n// Take note that the handler will be called with a nil pointer when\n// gathering is finished.\nfunc (pc *PeerConnection) OnICECandidate(f func(*ICECandidate)) {\n\tpc.iceGatherer.OnLocalCandidate(f)\n}\n\n// OnICEGatheringStateChange sets an event handler which is invoked when the\n// ICE candidate gathering state has changed.\nfunc (pc *PeerConnection) OnICEGatheringStateChange(f func(ICEGatheringState)) {\n\tpc.iceGatherer.OnStateChange(\n\t\tfunc(gathererState ICEGathererState) {\n\t\t\tswitch gathererState {\n\t\t\tcase ICEGathererStateGathering:\n\t\t\t\tf(ICEGatheringStateGathering)\n\t\t\tcase ICEGathererStateComplete:\n\t\t\t\tf(ICEGatheringStateComplete)\n\t\t\tdefault:\n\t\t\t\t// Other states ignored\n\t\t\t}\n\t\t})\n}\n\n// OnTrack sets an event handler which is called when remote track\n// arrives from a remote peer.\nfunc (pc *PeerConnection) OnTrack(f func(*TrackRemote, *RTPReceiver)) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tpc.onTrackHandler = f\n}\n\nfunc (pc *PeerConnection) onTrack(t *TrackRemote, r *RTPReceiver) {\n\tpc.mu.RLock()\n\thandler := pc.onTrackHandler\n\tpc.mu.RUnlock()\n\n\tpc.log.Debugf(\"got new track: %+v\", t)\n\tif t != nil {\n\t\tif handler != nil {\n\t\t\tgo handler(t, r)\n\t\t} else {\n\t\t\tpc.log.Warnf(\"OnTrack unset, unable to handle incoming media streams\")\n\t\t}\n\t}\n}\n\n// OnICEConnectionStateChange sets an event handler which is called\n// when an ICE connection state is changed.\nfunc (pc *PeerConnection) OnICEConnectionStateChange(f func(ICEConnectionState)) {\n\tpc.onICEConnectionStateChangeHandler.Store(f)\n}\n\nfunc (pc *PeerConnection) onICEConnectionStateChange(cs ICEConnectionState) {\n\tpc.iceConnectionState.Store(cs)\n\tpc.log.Infof(\"ICE connection state changed: %s\", cs)\n\tif handler, ok := pc.onICEConnectionStateChangeHandler.Load().(func(ICEConnectionState)); ok && handler != nil {\n\t\thandler(cs)\n\t}\n}\n\n// OnConnectionStateChange sets an event handler which is called\n// when the PeerConnectionState has changed\nfunc (pc *PeerConnection) OnConnectionStateChange(f func(PeerConnectionState)) {\n\tpc.onConnectionStateChangeHandler.Store(f)\n}\n\nfunc (pc *PeerConnection) onConnectionStateChange(cs PeerConnectionState) {\n\tpc.connectionState.Store(cs)\n\tpc.log.Infof(\"peer connection state changed: %s\", cs)\n\tif handler, ok := pc.onConnectionStateChangeHandler.Load().(func(PeerConnectionState)); ok && handler != nil {\n\t\tgo handler(cs)\n\t}\n}\n\n// SetConfiguration updates the configuration of this PeerConnection object.\nfunc (pc *PeerConnection) SetConfiguration(configuration Configuration) error { //nolint:gocognit\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-setconfiguration (step #2)\n\tif pc.isClosed.get() {\n\t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #3)\n\tif configuration.PeerIdentity != \"\" {\n\t\tif configuration.PeerIdentity != pc.configuration.PeerIdentity {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingPeerIdentity}\n\t\t}\n\t\tpc.configuration.PeerIdentity = configuration.PeerIdentity\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #4)\n\tif len(configuration.Certificates) > 0 {\n\t\tif len(configuration.Certificates) != len(pc.configuration.Certificates) {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingCertificates}\n\t\t}\n\n\t\tfor i, certificate := range configuration.Certificates {\n\t\t\tif !pc.configuration.Certificates[i].Equals(certificate) {\n\t\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingCertificates}\n\t\t\t}\n\t\t}\n\t\tpc.configuration.Certificates = configuration.Certificates\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #5)\n\tif configuration.BundlePolicy != BundlePolicyUnknown {\n\t\tif configuration.BundlePolicy != pc.configuration.BundlePolicy {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingBundlePolicy}\n\t\t}\n\t\tpc.configuration.BundlePolicy = configuration.BundlePolicy\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #6)\n\tif configuration.RTCPMuxPolicy != RTCPMuxPolicyUnknown {\n\t\tif configuration.RTCPMuxPolicy != pc.configuration.RTCPMuxPolicy {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingRTCPMuxPolicy}\n\t\t}\n\t\tpc.configuration.RTCPMuxPolicy = configuration.RTCPMuxPolicy\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #7)\n\tif configuration.ICECandidatePoolSize != 0 {\n\t\tif pc.configuration.ICECandidatePoolSize != configuration.ICECandidatePoolSize &&\n\t\t\tpc.LocalDescription() != nil {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingICECandidatePoolSize}\n\t\t}\n\t\tpc.configuration.ICECandidatePoolSize = configuration.ICECandidatePoolSize\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #8)\n\tpc.configuration.ICETransportPolicy = configuration.ICETransportPolicy\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #11)\n\tif len(configuration.ICEServers) > 0 {\n\t\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #11.3)\n\t\tfor _, server := range configuration.ICEServers {\n\t\t\tif err := server.validate(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tpc.configuration.ICEServers = configuration.ICEServers\n\t}\n\treturn nil\n}\n\n// GetConfiguration returns a Configuration object representing the current\n// configuration of this PeerConnection object. The returned object is a\n// copy and direct mutation on it will not take affect until SetConfiguration\n// has been called with Configuration passed as its only argument.\n// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-getconfiguration\nfunc (pc *PeerConnection) GetConfiguration() Configuration {\n\treturn pc.configuration\n}\n\nfunc (pc *PeerConnection) getStatsID() string {\n\tpc.mu.RLock()\n\tdefer pc.mu.RUnlock()\n\treturn pc.statsID\n}\n\n// hasLocalDescriptionChanged returns whether local media (rtpTransceivers) has changed\n// caller of this method should hold `pc.mu` lock\nfunc (pc *PeerConnection) hasLocalDescriptionChanged(desc *SessionDescription) bool {\n\tfor _, t := range pc.rtpTransceivers {\n\t\tm := getByMid(t.Mid(), desc)\n\t\tif m == nil {\n\t\t\treturn true\n\t\t}\n\n\t\tif getPeerDirection(m) != t.Direction() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// CreateOffer starts the PeerConnection and generates the localDescription\n// https://w3c.github.io/webrtc-pc/#dom-rtcpeerconnection-createoffer\nfunc (pc *PeerConnection) CreateOffer(options *OfferOptions) (SessionDescription, error) { //nolint:gocognit\n\tuseIdentity := pc.idpLoginURL != nil\n\tswitch {\n\tcase useIdentity:\n\t\treturn SessionDescription{}, errIdentityProviderNotImplemented\n\tcase pc.isClosed.get():\n\t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\tif options != nil && options.ICERestart {\n\t\tif err := pc.iceTransport.restart(); err != nil {\n\t\t\treturn SessionDescription{}, err\n\t\t}\n\t}\n\n\tvar (\n\t\td     *sdp.SessionDescription\n\t\toffer SessionDescription\n\t\terr   error\n\t)\n\n\t// This may be necessary to recompute if, for example, createOffer was called when only an\n\t// audio RTCRtpTransceiver was added to connection, but while performing the in-parallel\n\t// steps to create an offer, a video RTCRtpTransceiver was added, requiring additional\n\t// inspection of video system resources.\n\tcount := 0\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tfor {\n\t\t// We cache current transceivers to ensure they aren't\n\t\t// mutated during offer generation. We later check if they have\n\t\t// been mutated and recompute the offer if necessary.\n\t\tcurrentTransceivers := pc.rtpTransceivers\n\n\t\t// in-parallel steps to create an offer\n\t\t// https://w3c.github.io/webrtc-pc/#dfn-in-parallel-steps-to-create-an-offer\n\t\tisPlanB := pc.configuration.SDPSemantics == SDPSemanticsPlanB\n\t\tif pc.currentRemoteDescription != nil && isPlanB {\n\t\t\tisPlanB = descriptionPossiblyPlanB(pc.currentRemoteDescription)\n\t\t}\n\n\t\t// include unmatched local transceivers\n\t\tif !isPlanB {\n\t\t\t// update the greater mid if the remote description provides a greater one\n\t\t\tif pc.currentRemoteDescription != nil {\n\t\t\t\tvar numericMid int\n\t\t\t\tfor _, media := range pc.currentRemoteDescription.parsed.MediaDescriptions {\n\t\t\t\t\tmid := getMidValue(media)\n\t\t\t\t\tif mid == \"\" {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tnumericMid, err = strconv.Atoi(mid)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif numericMid > pc.greaterMid {\n\t\t\t\t\t\tpc.greaterMid = numericMid\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, t := range currentTransceivers {\n\t\t\t\tif mid := t.Mid(); mid != \"\" {\n\t\t\t\t\tnumericMid, errMid := strconv.Atoi(mid)\n\t\t\t\t\tif errMid == nil {\n\t\t\t\t\t\tif numericMid > pc.greaterMid {\n\t\t\t\t\t\t\tpc.greaterMid = numericMid\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tpc.greaterMid++\n\t\t\t\terr = t.SetMid(strconv.Itoa(pc.greaterMid))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn SessionDescription{}, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif pc.currentRemoteDescription == nil {\n\t\t\td, err = pc.generateUnmatchedSDP(currentTransceivers, useIdentity)\n\t\t} else {\n\t\t\td, err = pc.generateMatchedSDP(currentTransceivers, useIdentity, true /*includeUnmatched */, connectionRoleFromDtlsRole(defaultDtlsRoleOffer))\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn SessionDescription{}, err\n\t\t}\n\n\t\tupdateSDPOrigin(&pc.sdpOrigin, d)\n\t\tsdpBytes, err := d.Marshal()\n\t\tif err != nil {\n\t\t\treturn SessionDescription{}, err\n\t\t}\n\n\t\toffer = SessionDescription{\n\t\t\tType:   SDPTypeOffer,\n\t\t\tSDP:    string(sdpBytes),\n\t\t\tparsed: d,\n\t\t}\n\n\t\t// Verify local media hasn't changed during offer\n\t\t// generation. Recompute if necessary\n\t\tif isPlanB || !pc.hasLocalDescriptionChanged(&offer) {\n\t\t\tbreak\n\t\t}\n\t\tcount++\n\t\tif count >= 128 {\n\t\t\treturn SessionDescription{}, errExcessiveRetries\n\t\t}\n\t}\n\n\tpc.lastOffer = offer.SDP\n\treturn offer, nil\n}\n\nfunc (pc *PeerConnection) createICEGatherer() (*ICEGatherer, error) {\n\tg, err := pc.api.NewICEGatherer(ICEGatherOptions{\n\t\tICEServers:      pc.configuration.getICEServers(),\n\t\tICEGatherPolicy: pc.configuration.ICETransportPolicy,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn g, nil\n}\n\n// Update the PeerConnectionState given the state of relevant transports\n// https://www.w3.org/TR/webrtc/#rtcpeerconnectionstate-enum\nfunc (pc *PeerConnection) updateConnectionState(iceConnectionState ICEConnectionState, dtlsTransportState DTLSTransportState) {\n\tconnectionState := PeerConnectionStateNew\n\tswitch {\n\t// The RTCPeerConnection object's [[IsClosed]] slot is true.\n\tcase pc.isClosed.get():\n\t\tconnectionState = PeerConnectionStateClosed\n\n\t// Any of the RTCIceTransports or RTCDtlsTransports are in a \"failed\" state.\n\tcase iceConnectionState == ICEConnectionStateFailed || dtlsTransportState == DTLSTransportStateFailed:\n\t\tconnectionState = PeerConnectionStateFailed\n\n\t// Any of the RTCIceTransports or RTCDtlsTransports are in the \"disconnected\"\n\t// state and none of them are in the \"failed\" or \"connecting\" or \"checking\" state.  */\n\tcase iceConnectionState == ICEConnectionStateDisconnected:\n\t\tconnectionState = PeerConnectionStateDisconnected\n\n\t// None of the previous states apply and all RTCIceTransports are in the \"new\" or \"closed\" state,\n\t// and all RTCDtlsTransports are in the \"new\" or \"closed\" state, or there are no transports.\n\tcase (iceConnectionState == ICEConnectionStateNew || iceConnectionState == ICEConnectionStateClosed) &&\n\t\t(dtlsTransportState == DTLSTransportStateNew || dtlsTransportState == DTLSTransportStateClosed):\n\t\tconnectionState = PeerConnectionStateNew\n\n\t// None of the previous states apply and any RTCIceTransport is in the \"new\" or \"checking\" state or\n\t// any RTCDtlsTransport is in the \"new\" or \"connecting\" state.\n\tcase (iceConnectionState == ICEConnectionStateNew || iceConnectionState == ICEConnectionStateChecking) ||\n\t\t(dtlsTransportState == DTLSTransportStateNew || dtlsTransportState == DTLSTransportStateConnecting):\n\t\tconnectionState = PeerConnectionStateConnecting\n\n\t// All RTCIceTransports and RTCDtlsTransports are in the \"connected\", \"completed\" or \"closed\"\n\t// state and all RTCDtlsTransports are in the \"connected\" or \"closed\" state.\n\tcase (iceConnectionState == ICEConnectionStateConnected || iceConnectionState == ICEConnectionStateCompleted || iceConnectionState == ICEConnectionStateClosed) &&\n\t\t(dtlsTransportState == DTLSTransportStateConnected || dtlsTransportState == DTLSTransportStateClosed):\n\t\tconnectionState = PeerConnectionStateConnected\n\t}\n\n\tif pc.connectionState.Load() == connectionState {\n\t\treturn\n\t}\n\n\tpc.onConnectionStateChange(connectionState)\n}\n\nfunc (pc *PeerConnection) createICETransport() *ICETransport {\n\tt := pc.api.NewICETransport(pc.iceGatherer)\n\tt.internalOnConnectionStateChangeHandler.Store(func(state ICETransportState) {\n\t\tvar cs ICEConnectionState\n\t\tswitch state {\n\t\tcase ICETransportStateNew:\n\t\t\tcs = ICEConnectionStateNew\n\t\tcase ICETransportStateChecking:\n\t\t\tcs = ICEConnectionStateChecking\n\t\tcase ICETransportStateConnected:\n\t\t\tcs = ICEConnectionStateConnected\n\t\tcase ICETransportStateCompleted:\n\t\t\tcs = ICEConnectionStateCompleted\n\t\tcase ICETransportStateFailed:\n\t\t\tcs = ICEConnectionStateFailed\n\t\tcase ICETransportStateDisconnected:\n\t\t\tcs = ICEConnectionStateDisconnected\n\t\tcase ICETransportStateClosed:\n\t\t\tcs = ICEConnectionStateClosed\n\t\tdefault:\n\t\t\tpc.log.Warnf(\"OnConnectionStateChange: unhandled ICE state: %s\", state)\n\t\t\treturn\n\t\t}\n\t\tpc.onICEConnectionStateChange(cs)\n\t\tpc.updateConnectionState(cs, pc.dtlsTransport.State())\n\t})\n\n\treturn t\n}\n\n// CreateAnswer starts the PeerConnection and generates the localDescription\nfunc (pc *PeerConnection) CreateAnswer(*AnswerOptions) (SessionDescription, error) {\n\tuseIdentity := pc.idpLoginURL != nil\n\tremoteDesc := pc.RemoteDescription()\n\tswitch {\n\tcase remoteDesc == nil:\n\t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrNoRemoteDescription}\n\tcase useIdentity:\n\t\treturn SessionDescription{}, errIdentityProviderNotImplemented\n\tcase pc.isClosed.get():\n\t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\tcase pc.signalingState.Get() != SignalingStateHaveRemoteOffer && pc.signalingState.Get() != SignalingStateHaveLocalPranswer:\n\t\treturn SessionDescription{}, &rtcerr.InvalidStateError{Err: ErrIncorrectSignalingState}\n\t}\n\n\tconnectionRole := connectionRoleFromDtlsRole(pc.api.settingEngine.answeringDTLSRole)\n\tif connectionRole == sdp.ConnectionRole(0) {\n\t\tconnectionRole = connectionRoleFromDtlsRole(defaultDtlsRoleAnswer)\n\n\t\t// If one of the agents is lite and the other one is not, the lite agent must be the controlled agent.\n\t\t// If both or neither agents are lite the offering agent is controlling.\n\t\t// RFC 8445 S6.1.1\n\t\tif isIceLiteSet(remoteDesc.parsed) && !pc.api.settingEngine.candidates.ICELite {\n\t\t\tconnectionRole = connectionRoleFromDtlsRole(DTLSRoleServer)\n\t\t}\n\t}\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\td, err := pc.generateMatchedSDP(pc.rtpTransceivers, useIdentity, false /*includeUnmatched */, connectionRole)\n\tif err != nil {\n\t\treturn SessionDescription{}, err\n\t}\n\n\tupdateSDPOrigin(&pc.sdpOrigin, d)\n\tsdpBytes, err := d.Marshal()\n\tif err != nil {\n\t\treturn SessionDescription{}, err\n\t}\n\n\tdesc := SessionDescription{\n\t\tType:   SDPTypeAnswer,\n\t\tSDP:    string(sdpBytes),\n\t\tparsed: d,\n\t}\n\tpc.lastAnswer = desc.SDP\n\treturn desc, nil\n}\n\n// 4.4.1.6 Set the SessionDescription\nfunc (pc *PeerConnection) setDescription(sd *SessionDescription, op stateChangeOp) error { //nolint:gocognit\n\tswitch {\n\tcase pc.isClosed.get():\n\t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\tcase NewSDPType(sd.Type.String()) == SDPTypeUnknown:\n\t\treturn &rtcerr.TypeError{Err: fmt.Errorf(\"%w: '%d' is not a valid enum value of type SDPType\", errPeerConnSDPTypeInvalidValue, sd.Type)}\n\t}\n\n\tnextState, err := func() (SignalingState, error) {\n\t\tpc.mu.Lock()\n\t\tdefer pc.mu.Unlock()\n\n\t\tcur := pc.SignalingState()\n\t\tsetLocal := stateChangeOpSetLocal\n\t\tsetRemote := stateChangeOpSetRemote\n\t\tnewSDPDoesNotMatchOffer := &rtcerr.InvalidModificationError{Err: errSDPDoesNotMatchOffer}\n\t\tnewSDPDoesNotMatchAnswer := &rtcerr.InvalidModificationError{Err: errSDPDoesNotMatchAnswer}\n\n\t\tvar nextState SignalingState\n\t\tvar err error\n\t\tswitch op {\n\t\tcase setLocal:\n\t\t\tswitch sd.Type {\n\t\t\t// stable->SetLocal(offer)->have-local-offer\n\t\t\tcase SDPTypeOffer:\n\t\t\t\tif sd.SDP != pc.lastOffer {\n\t\t\t\t\treturn nextState, newSDPDoesNotMatchOffer\n\t\t\t\t}\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateHaveLocalOffer, setLocal, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.pendingLocalDescription = sd\n\t\t\t\t}\n\t\t\t// have-remote-offer->SetLocal(answer)->stable\n\t\t\t// have-local-pranswer->SetLocal(answer)->stable\n\t\t\tcase SDPTypeAnswer:\n\t\t\t\tif sd.SDP != pc.lastAnswer {\n\t\t\t\t\treturn nextState, newSDPDoesNotMatchAnswer\n\t\t\t\t}\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateStable, setLocal, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.currentLocalDescription = sd\n\t\t\t\t\tpc.currentRemoteDescription = pc.pendingRemoteDescription\n\t\t\t\t\tpc.pendingRemoteDescription = nil\n\t\t\t\t\tpc.pendingLocalDescription = nil\n\t\t\t\t}\n\t\t\tcase SDPTypeRollback:\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateStable, setLocal, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.pendingLocalDescription = nil\n\t\t\t\t}\n\t\t\t// have-remote-offer->SetLocal(pranswer)->have-local-pranswer\n\t\t\tcase SDPTypePranswer:\n\t\t\t\tif sd.SDP != pc.lastAnswer {\n\t\t\t\t\treturn nextState, newSDPDoesNotMatchAnswer\n\t\t\t\t}\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateHaveLocalPranswer, setLocal, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.pendingLocalDescription = sd\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn nextState, &rtcerr.OperationError{Err: fmt.Errorf(\"%w: %s(%s)\", errPeerConnStateChangeInvalid, op, sd.Type)}\n\t\t\t}\n\t\tcase setRemote:\n\t\t\tswitch sd.Type {\n\t\t\t// stable->SetRemote(offer)->have-remote-offer\n\t\t\tcase SDPTypeOffer:\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateHaveRemoteOffer, setRemote, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.pendingRemoteDescription = sd\n\t\t\t\t}\n\t\t\t// have-local-offer->SetRemote(answer)->stable\n\t\t\t// have-remote-pranswer->SetRemote(answer)->stable\n\t\t\tcase SDPTypeAnswer:\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateStable, setRemote, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.currentRemoteDescription = sd\n\t\t\t\t\tpc.currentLocalDescription = pc.pendingLocalDescription\n\t\t\t\t\tpc.pendingRemoteDescription = nil\n\t\t\t\t\tpc.pendingLocalDescription = nil\n\t\t\t\t}\n\t\t\tcase SDPTypeRollback:\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateStable, setRemote, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.pendingRemoteDescription = nil\n\t\t\t\t}\n\t\t\t// have-local-offer->SetRemote(pranswer)->have-remote-pranswer\n\t\t\tcase SDPTypePranswer:\n\t\t\t\tnextState, err = checkNextSignalingState(cur, SignalingStateHaveRemotePranswer, setRemote, sd.Type)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpc.pendingRemoteDescription = sd\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn nextState, &rtcerr.OperationError{Err: fmt.Errorf(\"%w: %s(%s)\", errPeerConnStateChangeInvalid, op, sd.Type)}\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nextState, &rtcerr.OperationError{Err: fmt.Errorf(\"%w: %q\", errPeerConnStateChangeUnhandled, op)}\n\t\t}\n\n\t\treturn nextState, err\n\t}()\n\n\tif err == nil {\n\t\tpc.signalingState.Set(nextState)\n\t\tif pc.signalingState.Get() == SignalingStateStable {\n\t\t\tpc.isNegotiationNeeded.set(false)\n\t\t\tpc.mu.Lock()\n\t\t\tpc.onNegotiationNeeded()\n\t\t\tpc.mu.Unlock()\n\t\t}\n\t\tpc.onSignalingStateChange(nextState)\n\t}\n\treturn err\n}\n\n// SetLocalDescription sets the SessionDescription of the local peer\nfunc (pc *PeerConnection) SetLocalDescription(desc SessionDescription) error {\n\tif pc.isClosed.get() {\n\t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\thaveLocalDescription := pc.currentLocalDescription != nil\n\n\t// JSEP 5.4\n\tif desc.SDP == \"\" {\n\t\tswitch desc.Type {\n\t\tcase SDPTypeAnswer, SDPTypePranswer:\n\t\t\tdesc.SDP = pc.lastAnswer\n\t\tcase SDPTypeOffer:\n\t\t\tdesc.SDP = pc.lastOffer\n\t\tdefault:\n\t\t\treturn &rtcerr.InvalidModificationError{\n\t\t\t\tErr: fmt.Errorf(\"%w: %s\", errPeerConnSDPTypeInvalidValueSetLocalDescription, desc.Type),\n\t\t\t}\n\t\t}\n\t}\n\n\tdesc.parsed = &sdp.SessionDescription{}\n\tif err := desc.parsed.UnmarshalString(desc.SDP); err != nil {\n\t\treturn err\n\t}\n\tif err := pc.setDescription(&desc, stateChangeOpSetLocal); err != nil {\n\t\treturn err\n\t}\n\n\tcurrentTransceivers := append([]*RTPTransceiver{}, pc.GetTransceivers()...)\n\n\tweAnswer := desc.Type == SDPTypeAnswer\n\tremoteDesc := pc.RemoteDescription()\n\tif weAnswer && remoteDesc != nil {\n\t\t_ = setRTPTransceiverCurrentDirection(&desc, currentTransceivers, false)\n\t\tif err := pc.startRTPSenders(currentTransceivers); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpc.configureRTPReceivers(haveLocalDescription, remoteDesc, currentTransceivers)\n\t\tpc.ops.Enqueue(func() {\n\t\t\tpc.startRTP(haveLocalDescription, remoteDesc, currentTransceivers)\n\t\t})\n\t}\n\n\tmediaSection, ok := selectCandidateMediaSection(desc.parsed)\n\tif ok {\n\t\tpc.iceGatherer.setMediaStreamIdentification(mediaSection.SDPMid, mediaSection.SDPMLineIndex)\n\t}\n\n\tif pc.iceGatherer.State() == ICEGathererStateNew {\n\t\treturn pc.iceGatherer.Gather()\n\t}\n\treturn nil\n}\n\n// LocalDescription returns PendingLocalDescription if it is not null and\n// otherwise it returns CurrentLocalDescription. This property is used to\n// determine if SetLocalDescription has already been called.\n// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-localdescription\nfunc (pc *PeerConnection) LocalDescription() *SessionDescription {\n\tif pendingLocalDescription := pc.PendingLocalDescription(); pendingLocalDescription != nil {\n\t\treturn pendingLocalDescription\n\t}\n\treturn pc.CurrentLocalDescription()\n}\n\n// SetRemoteDescription sets the SessionDescription of the remote peer\nfunc (pc *PeerConnection) SetRemoteDescription(desc SessionDescription) error { //nolint:gocognit,gocyclo\n\tif pc.isClosed.get() {\n\t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\tisRenegotiation := pc.currentRemoteDescription != nil\n\n\tif _, err := desc.Unmarshal(); err != nil {\n\t\treturn err\n\t}\n\tif err := pc.setDescription(&desc, stateChangeOpSetRemote); err != nil {\n\t\treturn err\n\t}\n\n\tif err := pc.api.mediaEngine.updateFromRemoteDescription(*desc.parsed); err != nil {\n\t\treturn err\n\t}\n\n\t// Disable RTX/FEC on RTPSenders if the remote didn't support it\n\tfor _, sender := range pc.GetSenders() {\n\t\tsender.configureRTXAndFEC()\n\t}\n\n\tvar t *RTPTransceiver\n\tlocalTransceivers := append([]*RTPTransceiver{}, pc.GetTransceivers()...)\n\tdetectedPlanB := descriptionIsPlanB(pc.RemoteDescription(), pc.log)\n\tif pc.configuration.SDPSemantics != SDPSemanticsUnifiedPlan {\n\t\tdetectedPlanB = descriptionPossiblyPlanB(pc.RemoteDescription())\n\t}\n\n\tweOffer := desc.Type == SDPTypeAnswer\n\n\tif !weOffer && !detectedPlanB {\n\t\tfor _, media := range pc.RemoteDescription().parsed.MediaDescriptions {\n\t\t\tmidValue := getMidValue(media)\n\t\t\tif midValue == \"\" {\n\t\t\t\treturn errPeerConnRemoteDescriptionWithoutMidValue\n\t\t\t}\n\n\t\t\tif media.MediaName.Media == mediaSectionApplication {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tkind := NewRTPCodecType(media.MediaName.Media)\n\t\t\tdirection := getPeerDirection(media)\n\t\t\tif kind == 0 || direction == RTPTransceiverDirectionUnknown {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tt, localTransceivers = findByMid(midValue, localTransceivers)\n\t\t\tif t == nil {\n\t\t\t\tt, localTransceivers = satisfyTypeAndDirection(kind, direction, localTransceivers)\n\t\t\t} else if direction == RTPTransceiverDirectionInactive {\n\t\t\t\tif err := t.Stop(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase t == nil:\n\t\t\t\treceiver, err := pc.api.NewRTPReceiver(kind, pc.dtlsTransport)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tlocalDirection := RTPTransceiverDirectionRecvonly\n\t\t\t\tif direction == RTPTransceiverDirectionRecvonly {\n\t\t\t\t\tlocalDirection = RTPTransceiverDirectionSendonly\n\t\t\t\t} else if direction == RTPTransceiverDirectionInactive {\n\t\t\t\t\tlocalDirection = RTPTransceiverDirectionInactive\n\t\t\t\t}\n\n\t\t\t\tt = newRTPTransceiver(receiver, nil, localDirection, kind, pc.api)\n\t\t\t\tpc.mu.Lock()\n\t\t\t\tpc.addRTPTransceiver(t)\n\t\t\t\tpc.mu.Unlock()\n\n\t\t\t\t// if transceiver is create by remote sdp, set prefer codec same as remote peer\n\t\t\t\tif codecs, err := codecsFromMediaDescription(media); err == nil {\n\t\t\t\t\tfilteredCodecs := []RTPCodecParameters{}\n\t\t\t\t\tfor _, codec := range codecs {\n\t\t\t\t\t\tif c, matchType := codecParametersFuzzySearch(codec, pc.api.mediaEngine.getCodecsByKind(kind)); matchType == codecMatchExact {\n\t\t\t\t\t\t\t// if codec match exact, use payloadtype register to mediaengine\n\t\t\t\t\t\t\tcodec.PayloadType = c.PayloadType\n\t\t\t\t\t\t\tfilteredCodecs = append(filteredCodecs, codec)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_ = t.SetCodecPreferences(filteredCodecs)\n\t\t\t\t}\n\n\t\t\tcase direction == RTPTransceiverDirectionRecvonly:\n\t\t\t\tif t.Direction() == RTPTransceiverDirectionSendrecv {\n\t\t\t\t\tt.setDirection(RTPTransceiverDirectionSendonly)\n\t\t\t\t} else if t.Direction() == RTPTransceiverDirectionRecvonly {\n\t\t\t\t\tt.setDirection(RTPTransceiverDirectionInactive)\n\t\t\t\t}\n\t\t\tcase direction == RTPTransceiverDirectionSendrecv:\n\t\t\t\tif t.Direction() == RTPTransceiverDirectionSendonly {\n\t\t\t\t\tt.setDirection(RTPTransceiverDirectionSendrecv)\n\t\t\t\t} else if t.Direction() == RTPTransceiverDirectionInactive {\n\t\t\t\t\tt.setDirection(RTPTransceiverDirectionRecvonly)\n\t\t\t\t}\n\t\t\tcase direction == RTPTransceiverDirectionSendonly:\n\t\t\t\tif t.Direction() == RTPTransceiverDirectionInactive {\n\t\t\t\t\tt.setDirection(RTPTransceiverDirectionRecvonly)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif t.Mid() == \"\" {\n\t\t\t\tif err := t.SetMid(midValue); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ticeDetails, err := extractICEDetails(desc.parsed, pc.log)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif isRenegotiation && pc.iceTransport.haveRemoteCredentialsChange(iceDetails.Ufrag, iceDetails.Password) {\n\t\t// An ICE Restart only happens implicitly for a SetRemoteDescription of type offer\n\t\tif !weOffer {\n\t\t\tif err = pc.iceTransport.restart(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif err = pc.iceTransport.setRemoteCredentials(iceDetails.Ufrag, iceDetails.Password); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor i := range iceDetails.Candidates {\n\t\tif err = pc.iceTransport.AddRemoteCandidate(&iceDetails.Candidates[i]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcurrentTransceivers := append([]*RTPTransceiver{}, pc.GetTransceivers()...)\n\n\tif isRenegotiation {\n\t\tif weOffer {\n\t\t\t_ = setRTPTransceiverCurrentDirection(&desc, currentTransceivers, true)\n\t\t\tif err = pc.startRTPSenders(currentTransceivers); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpc.configureRTPReceivers(true, &desc, currentTransceivers)\n\t\t\tpc.ops.Enqueue(func() {\n\t\t\t\tpc.startRTP(true, &desc, currentTransceivers)\n\t\t\t})\n\t\t}\n\t\treturn nil\n\t}\n\n\tremoteIsLite := isIceLiteSet(desc.parsed)\n\n\tfingerprint, fingerprintHash, err := extractFingerprint(desc.parsed)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ticeRole := ICERoleControlled\n\t// If one of the agents is lite and the other one is not, the lite agent must be the controlled agent.\n\t// If both or neither agents are lite the offering agent is controlling.\n\t// RFC 8445 S6.1.1\n\tif (weOffer && remoteIsLite == pc.api.settingEngine.candidates.ICELite) || (remoteIsLite && !pc.api.settingEngine.candidates.ICELite) {\n\t\ticeRole = ICERoleControlling\n\t}\n\n\t// Start the networking in a new routine since it will block until\n\t// the connection is actually established.\n\tif weOffer {\n\t\t_ = setRTPTransceiverCurrentDirection(&desc, currentTransceivers, true)\n\t\tif err := pc.startRTPSenders(currentTransceivers); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpc.configureRTPReceivers(false, &desc, currentTransceivers)\n\t}\n\n\tpc.ops.Enqueue(func() {\n\t\tpc.startTransports(iceRole, dtlsRoleFromRemoteSDP(desc.parsed), iceDetails.Ufrag, iceDetails.Password, fingerprint, fingerprintHash)\n\t\tif weOffer {\n\t\t\tpc.startRTP(false, &desc, currentTransceivers)\n\t\t}\n\t})\n\treturn nil\n}\n\nfunc (pc *PeerConnection) configureReceiver(incoming trackDetails, receiver *RTPReceiver) {\n\treceiver.configureReceive(trackDetailsToRTPReceiveParameters(&incoming))\n\n\t// set track id and label early so they can be set as new track information\n\t// is received from the SDP.\n\tfor i := range receiver.tracks {\n\t\treceiver.tracks[i].track.mu.Lock()\n\t\treceiver.tracks[i].track.id = incoming.id\n\t\treceiver.tracks[i].track.streamID = incoming.streamID\n\t\treceiver.tracks[i].track.mu.Unlock()\n\t}\n}\n\nfunc (pc *PeerConnection) startReceiver(incoming trackDetails, receiver *RTPReceiver) {\n\tif err := receiver.startReceive(trackDetailsToRTPReceiveParameters(&incoming)); err != nil {\n\t\tpc.log.Warnf(\"RTPReceiver Receive failed %s\", err)\n\t\treturn\n\t}\n\n\tfor _, t := range receiver.Tracks() {\n\t\tif t.SSRC() == 0 || t.RID() != \"\" {\n\t\t\treturn\n\t\t}\n\n\t\tif pc.api.settingEngine.fireOnTrackBeforeFirstRTP {\n\t\t\tpc.onTrack(t, receiver)\n\t\t\treturn\n\t\t}\n\t\tgo func(track *TrackRemote) {\n\t\t\tb := make([]byte, pc.api.settingEngine.getReceiveMTU())\n\t\t\tn, _, err := track.peek(b)\n\t\t\tif err != nil {\n\t\t\t\tpc.log.Warnf(\"Could not determine PayloadType for SSRC %d (%s)\", track.SSRC(), err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif err = track.checkAndUpdateTrack(b[:n]); err != nil {\n\t\t\t\tpc.log.Warnf(\"Failed to set codec settings for track SSRC %d (%s)\", track.SSRC(), err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpc.onTrack(track, receiver)\n\t\t}(t)\n\t}\n}\n\nfunc setRTPTransceiverCurrentDirection(answer *SessionDescription, currentTransceivers []*RTPTransceiver, weOffer bool) error {\n\tcurrentTransceivers = append([]*RTPTransceiver{}, currentTransceivers...)\n\tfor _, media := range answer.parsed.MediaDescriptions {\n\t\tmidValue := getMidValue(media)\n\t\tif midValue == \"\" {\n\t\t\treturn errPeerConnRemoteDescriptionWithoutMidValue\n\t\t}\n\n\t\tif media.MediaName.Media == mediaSectionApplication {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar t *RTPTransceiver\n\t\tt, currentTransceivers = findByMid(midValue, currentTransceivers)\n\n\t\tif t == nil {\n\t\t\treturn fmt.Errorf(\"%w: %q\", errPeerConnTranscieverMidNil, midValue)\n\t\t}\n\n\t\tdirection := getPeerDirection(media)\n\t\tif direction == RTPTransceiverDirectionUnknown {\n\t\t\tcontinue\n\t\t}\n\n\t\t// reverse direction if it was a remote answer\n\t\tif weOffer {\n\t\t\tswitch direction {\n\t\t\tcase RTPTransceiverDirectionSendonly:\n\t\t\t\tdirection = RTPTransceiverDirectionRecvonly\n\t\t\tcase RTPTransceiverDirectionRecvonly:\n\t\t\t\tdirection = RTPTransceiverDirectionSendonly\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\n\t\t// If a transceiver is created by applying a remote description that has recvonly transceiver,\n\t\t// it will have no sender. In this case, the transceiver's current direction is set to inactive so\n\t\t// that the transceiver can be reused by next AddTrack.\n\t\tif !weOffer && direction == RTPTransceiverDirectionSendonly && t.Sender() == nil {\n\t\t\tdirection = RTPTransceiverDirectionInactive\n\t\t}\n\n\t\tt.setCurrentDirection(direction)\n\t}\n\treturn nil\n}\n\nfunc runIfNewReceiver(\n\tincomingTrack trackDetails,\n\ttransceivers []*RTPTransceiver,\n\tf func(incomingTrack trackDetails, receiver *RTPReceiver),\n) bool {\n\tfor _, t := range transceivers {\n\t\tif t.Mid() != incomingTrack.mid {\n\t\t\tcontinue\n\t\t}\n\n\t\treceiver := t.Receiver()\n\t\tif (incomingTrack.kind != t.Kind()) ||\n\t\t\t(t.Direction() != RTPTransceiverDirectionRecvonly && t.Direction() != RTPTransceiverDirectionSendrecv) ||\n\t\t\treceiver == nil ||\n\t\t\t(receiver.haveReceived()) {\n\t\t\tcontinue\n\t\t}\n\n\t\tf(incomingTrack, receiver)\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// configureRTPReceivers opens knows inbound SRTP streams from the RemoteDescription\nfunc (pc *PeerConnection) configureRTPReceivers(isRenegotiation bool, remoteDesc *SessionDescription, currentTransceivers []*RTPTransceiver) { //nolint:gocognit\n\tincomingTracks := trackDetailsFromSDP(pc.log, remoteDesc.parsed)\n\n\tif isRenegotiation {\n\t\tfor _, t := range currentTransceivers {\n\t\t\treceiver := t.Receiver()\n\t\t\tif receiver == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttracks := t.Receiver().Tracks()\n\t\t\tif len(tracks) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tmid := t.Mid()\n\t\t\treceiverNeedsStopped := false\n\t\t\tfor _, track := range tracks {\n\t\t\t\tfunc(t *TrackRemote) {\n\t\t\t\t\tt.mu.Lock()\n\t\t\t\t\tdefer t.mu.Unlock()\n\n\t\t\t\t\tif t.rid != \"\" {\n\t\t\t\t\t\tif details := trackDetailsForRID(incomingTracks, mid, t.rid); details != nil {\n\t\t\t\t\t\t\tt.id = details.id\n\t\t\t\t\t\t\tt.streamID = details.streamID\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if t.ssrc != 0 {\n\t\t\t\t\t\tif details := trackDetailsForSSRC(incomingTracks, t.ssrc); details != nil {\n\t\t\t\t\t\t\tt.id = details.id\n\t\t\t\t\t\t\tt.streamID = details.streamID\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treceiverNeedsStopped = true\n\t\t\t\t}(track)\n\t\t\t}\n\n\t\t\tif !receiverNeedsStopped {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif err := receiver.Stop(); err != nil {\n\t\t\t\tpc.log.Warnf(\"Failed to stop RtpReceiver: %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treceiver, err := pc.api.NewRTPReceiver(receiver.kind, pc.dtlsTransport)\n\t\t\tif err != nil {\n\t\t\t\tpc.log.Warnf(\"Failed to create new RtpReceiver: %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.setReceiver(receiver)\n\t\t}\n\t}\n\n\tlocalTransceivers := append([]*RTPTransceiver{}, currentTransceivers...)\n\n\t// Ensure we haven't already started a transceiver for this ssrc\n\tfilteredTracks := append([]trackDetails{}, incomingTracks...)\n\tfor _, incomingTrack := range incomingTracks {\n\t\t// If we already have a TrackRemote for a given SSRC don't handle it again\n\t\tfor _, t := range localTransceivers {\n\t\t\tif receiver := t.Receiver(); receiver != nil {\n\t\t\t\tfor _, track := range receiver.Tracks() {\n\t\t\t\t\tfor _, ssrc := range incomingTrack.ssrcs {\n\t\t\t\t\t\tif ssrc == track.SSRC() {\n\t\t\t\t\t\t\tfilteredTracks = filterTrackWithSSRC(filteredTracks, track.SSRC())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, incomingTrack := range filteredTracks {\n\t\t_ = runIfNewReceiver(incomingTrack, localTransceivers, pc.configureReceiver)\n\t}\n}\n\n// startRTPReceivers opens knows inbound SRTP streams from the RemoteDescription\nfunc (pc *PeerConnection) startRTPReceivers(remoteDesc *SessionDescription, currentTransceivers []*RTPTransceiver) {\n\tincomingTracks := trackDetailsFromSDP(pc.log, remoteDesc.parsed)\n\tif len(incomingTracks) == 0 {\n\t\treturn\n\t}\n\n\tlocalTransceivers := append([]*RTPTransceiver{}, currentTransceivers...)\n\n\tunhandledTracks := incomingTracks[:0]\n\tfor _, incomingTrack := range incomingTracks {\n\t\ttrackHandled := runIfNewReceiver(incomingTrack, localTransceivers, pc.startReceiver)\n\t\tif !trackHandled {\n\t\t\tunhandledTracks = append(unhandledTracks, incomingTrack)\n\t\t}\n\t}\n\n\tremoteIsPlanB := false\n\tswitch pc.configuration.SDPSemantics {\n\tcase SDPSemanticsPlanB:\n\t\tremoteIsPlanB = true\n\tcase SDPSemanticsUnifiedPlanWithFallback:\n\t\tremoteIsPlanB = descriptionPossiblyPlanB(pc.RemoteDescription())\n\tdefault:\n\t\t// none\n\t}\n\n\tif remoteIsPlanB {\n\t\tfor _, incomingTrack := range unhandledTracks {\n\t\t\tt, err := pc.AddTransceiverFromKind(incomingTrack.kind, RTPTransceiverInit{\n\t\t\t\tDirection: RTPTransceiverDirectionSendrecv,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tpc.log.Warnf(\"Could not add transceiver for remote SSRC %d: %s\", incomingTrack.ssrcs[0], err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpc.configureReceiver(incomingTrack, t.Receiver())\n\t\t\tpc.startReceiver(incomingTrack, t.Receiver())\n\t\t}\n\t}\n}\n\n// startRTPSenders starts all outbound RTP streams\nfunc (pc *PeerConnection) startRTPSenders(currentTransceivers []*RTPTransceiver) error {\n\tfor _, transceiver := range currentTransceivers {\n\t\tif sender := transceiver.Sender(); sender != nil && sender.isNegotiated() && !sender.hasSent() {\n\t\t\terr := sender.Send(sender.GetParameters())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Start SCTP subsystem\nfunc (pc *PeerConnection) startSCTP() {\n\t// Start sctp\n\tif err := pc.sctpTransport.Start(SCTPCapabilities{\n\t\tMaxMessageSize: 0,\n\t}); err != nil {\n\t\tpc.log.Warnf(\"Failed to start SCTP: %s\", err)\n\t\tif err = pc.sctpTransport.Stop(); err != nil {\n\t\t\tpc.log.Warnf(\"Failed to stop SCTPTransport: %s\", err)\n\t\t}\n\n\t\treturn\n\t}\n}\n\nfunc (pc *PeerConnection) handleUndeclaredSSRC(ssrc SSRC, remoteDescription *SessionDescription) (handled bool, err error) {\n\tif len(remoteDescription.parsed.MediaDescriptions) != 1 {\n\t\treturn false, nil\n\t}\n\n\tonlyMediaSection := remoteDescription.parsed.MediaDescriptions[0]\n\tstreamID := \"\"\n\tid := \"\"\n\thasRidAttribute := false\n\thasSSRCAttribute := false\n\n\tfor _, a := range onlyMediaSection.Attributes {\n\t\tswitch a.Key {\n\t\tcase sdp.AttrKeyMsid:\n\t\t\tif split := strings.Split(a.Value, \" \"); len(split) == 2 {\n\t\t\t\tstreamID = split[0]\n\t\t\t\tid = split[1]\n\t\t\t}\n\t\tcase sdp.AttrKeySSRC:\n\t\t\thasSSRCAttribute = true\n\t\tcase sdpAttributeRid:\n\t\t\thasRidAttribute = true\n\t\t}\n\t}\n\n\tif hasRidAttribute {\n\t\treturn false, nil\n\t} else if hasSSRCAttribute {\n\t\treturn false, errPeerConnSingleMediaSectionHasExplicitSSRC\n\t}\n\n\tincoming := trackDetails{\n\t\tssrcs:    []SSRC{ssrc},\n\t\tkind:     RTPCodecTypeVideo,\n\t\tstreamID: streamID,\n\t\tid:       id,\n\t}\n\tif onlyMediaSection.MediaName.Media == RTPCodecTypeAudio.String() {\n\t\tincoming.kind = RTPCodecTypeAudio\n\t}\n\n\tt, err := pc.AddTransceiverFromKind(incoming.kind, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendrecv,\n\t})\n\tif err != nil {\n\t\t// nolint\n\t\treturn false, fmt.Errorf(\"%w: %d: %s\", errPeerConnRemoteSSRCAddTransceiver, ssrc, err)\n\t}\n\n\tpc.configureReceiver(incoming, t.Receiver())\n\tpc.startReceiver(incoming, t.Receiver())\n\treturn true, nil\n}\n\n// Chrome sends probing traffic on SSRC 0. This reads the packets to ensure that we properly\n// generate TWCC reports for it. Since this isn't actually media we don't pass this to the user\nfunc (pc *PeerConnection) handleNonMediaBandwidthProbe() {\n\tnonMediaBandwidthProbe, err := pc.api.NewRTPReceiver(RTPCodecTypeVideo, pc.dtlsTransport)\n\tif err != nil {\n\t\tpc.log.Errorf(\"handleNonMediaBandwidthProbe failed to create RTPReceiver: %v\", err)\n\t\treturn\n\t}\n\n\tif err = nonMediaBandwidthProbe.Receive(RTPReceiveParameters{\n\t\tEncodings: []RTPDecodingParameters{{RTPCodingParameters: RTPCodingParameters{}}},\n\t}); err != nil {\n\t\tpc.log.Errorf(\"handleNonMediaBandwidthProbe failed to start RTPReceiver: %v\", err)\n\t\treturn\n\t}\n\n\tpc.nonMediaBandwidthProbe.Store(nonMediaBandwidthProbe)\n\tb := make([]byte, pc.api.settingEngine.getReceiveMTU())\n\tfor {\n\t\tif _, _, err = nonMediaBandwidthProbe.readRTP(b, nonMediaBandwidthProbe.Track()); err != nil {\n\t\t\tpc.log.Tracef(\"handleNonMediaBandwidthProbe read exiting: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (pc *PeerConnection) handleIncomingSSRC(rtpStream io.Reader, ssrc SSRC) error { //nolint:gocognit\n\tremoteDescription := pc.RemoteDescription()\n\tif remoteDescription == nil {\n\t\treturn errPeerConnRemoteDescriptionNil\n\t}\n\n\t// If a SSRC already exists in the RemoteDescription don't perform heuristics upon it\n\tfor _, track := range trackDetailsFromSDP(pc.log, remoteDescription.parsed) {\n\t\tif track.repairSsrc != nil && ssrc == *track.repairSsrc {\n\t\t\treturn nil\n\t\t}\n\t\tfor _, trackSsrc := range track.ssrcs {\n\t\t\tif ssrc == trackSsrc {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the remote SDP was only one media section the ssrc doesn't have to be explicitly declared\n\tif handled, err := pc.handleUndeclaredSSRC(ssrc, remoteDescription); handled || err != nil {\n\t\treturn err\n\t}\n\n\tmidExtensionID, audioSupported, videoSupported := pc.api.mediaEngine.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.SDESMidURI})\n\tif !audioSupported && !videoSupported {\n\t\treturn errPeerConnSimulcastMidRTPExtensionRequired\n\t}\n\n\tstreamIDExtensionID, audioSupported, videoSupported := pc.api.mediaEngine.getHeaderExtensionID(RTPHeaderExtensionCapability{sdp.SDESRTPStreamIDURI})\n\tif !audioSupported && !videoSupported {\n\t\treturn errPeerConnSimulcastStreamIDRTPExtensionRequired\n\t}\n\n\trepairStreamIDExtensionID, _, _ := pc.api.mediaEngine.getHeaderExtensionID(RTPHeaderExtensionCapability{sdesRepairRTPStreamIDURI})\n\n\tb := make([]byte, pc.api.settingEngine.getReceiveMTU())\n\n\ti, err := rtpStream.Read(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif i < 4 {\n\t\treturn errRTPTooShort\n\t}\n\n\tpayloadType := PayloadType(b[1] & 0x7f)\n\tparams, err := pc.api.mediaEngine.getRTPParametersByPayloadType(payloadType)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstreamInfo := createStreamInfo(\"\", ssrc, 0, 0, params.Codecs[0].PayloadType, 0, 0, params.Codecs[0].RTPCodecCapability, params.HeaderExtensions)\n\treadStream, interceptor, rtcpReadStream, rtcpInterceptor, err := pc.dtlsTransport.streamsForSSRC(ssrc, *streamInfo)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar mid, rid, rsid string\n\tvar paddingOnly bool\n\tfor readCount := 0; readCount <= simulcastProbeCount; readCount++ {\n\t\tif mid == \"\" || (rid == \"\" && rsid == \"\") {\n\t\t\t// skip padding only packets for probing\n\t\t\tif paddingOnly {\n\t\t\t\treadCount--\n\t\t\t}\n\n\t\t\ti, _, err := interceptor.Read(b, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif _, paddingOnly, err = handleUnknownRTPPacket(b[:i], uint8(midExtensionID), uint8(streamIDExtensionID), uint8(repairStreamIDExtensionID), &mid, &rid, &rsid); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, t := range pc.GetTransceivers() {\n\t\t\treceiver := t.Receiver()\n\t\t\tif t.Mid() != mid || receiver == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif rsid != \"\" {\n\t\t\t\treceiver.mu.Lock()\n\t\t\t\tdefer receiver.mu.Unlock()\n\t\t\t\treturn receiver.receiveForRtx(SSRC(0), rsid, streamInfo, readStream, interceptor, rtcpReadStream, rtcpInterceptor)\n\t\t\t}\n\n\t\t\ttrack, err := receiver.receiveForRid(rid, params, streamInfo, readStream, interceptor, rtcpReadStream, rtcpInterceptor)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tpc.onTrack(track, receiver)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tpc.api.interceptor.UnbindRemoteStream(streamInfo)\n\treturn errPeerConnSimulcastIncomingSSRCFailed\n}\n\n// undeclaredMediaProcessor handles RTP/RTCP packets that don't match any a:ssrc lines\nfunc (pc *PeerConnection) undeclaredMediaProcessor() {\n\tgo pc.undeclaredRTPMediaProcessor()\n\tgo pc.undeclaredRTCPMediaProcessor()\n}\n\nfunc (pc *PeerConnection) undeclaredRTPMediaProcessor() {\n\tvar simulcastRoutineCount uint64\n\tfor {\n\t\tsrtpSession, err := pc.dtlsTransport.getSRTPSession()\n\t\tif err != nil {\n\t\t\tpc.log.Warnf(\"undeclaredMediaProcessor failed to open SrtpSession: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tsrtcpSession, err := pc.dtlsTransport.getSRTCPSession()\n\t\tif err != nil {\n\t\t\tpc.log.Warnf(\"undeclaredMediaProcessor failed to open SrtcpSession: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tsrtpReadStream, ssrc, err := srtpSession.AcceptStream()\n\t\tif err != nil {\n\t\t\tpc.log.Warnf(\"Failed to accept RTP %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// open accompanying srtcp stream\n\t\tsrtcpReadStream, err := srtcpSession.OpenReadStream(ssrc)\n\t\tif err != nil {\n\t\t\tpc.log.Warnf(\"Failed to open RTCP stream for %d: %v\", ssrc, err)\n\t\t\treturn\n\t\t}\n\n\t\tif pc.isClosed.get() {\n\t\t\tif err = srtpReadStream.Close(); err != nil {\n\t\t\t\tpc.log.Warnf(\"Failed to close RTP stream %v\", err)\n\t\t\t}\n\t\t\tif err = srtcpReadStream.Close(); err != nil {\n\t\t\t\tpc.log.Warnf(\"Failed to close RTCP stream %v\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tpc.dtlsTransport.storeSimulcastStream(srtpReadStream, srtcpReadStream)\n\n\t\tif ssrc == 0 {\n\t\t\tgo pc.handleNonMediaBandwidthProbe()\n\t\t\tcontinue\n\t\t}\n\n\t\tif atomic.AddUint64(&simulcastRoutineCount, 1) >= simulcastMaxProbeRoutines {\n\t\t\tatomic.AddUint64(&simulcastRoutineCount, ^uint64(0))\n\t\t\tpc.log.Warn(ErrSimulcastProbeOverflow.Error())\n\t\t\tcontinue\n\t\t}\n\n\t\tgo func(rtpStream io.Reader, ssrc SSRC) {\n\t\t\tif err := pc.handleIncomingSSRC(rtpStream, ssrc); err != nil {\n\t\t\t\tpc.log.Errorf(incomingUnhandledRTPSsrc, ssrc, err)\n\t\t\t}\n\t\t\tatomic.AddUint64(&simulcastRoutineCount, ^uint64(0))\n\t\t}(srtpReadStream, SSRC(ssrc))\n\t}\n}\n\nfunc (pc *PeerConnection) undeclaredRTCPMediaProcessor() {\n\tvar unhandledStreams []*srtp.ReadStreamSRTCP\n\tdefer func() {\n\t\tfor _, s := range unhandledStreams {\n\t\t\t_ = s.Close()\n\t\t}\n\t}()\n\tfor {\n\t\tsrtcpSession, err := pc.dtlsTransport.getSRTCPSession()\n\t\tif err != nil {\n\t\t\tpc.log.Warnf(\"undeclaredMediaProcessor failed to open SrtcpSession: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\tstream, ssrc, err := srtcpSession.AcceptStream()\n\t\tif err != nil {\n\t\t\tpc.log.Warnf(\"Failed to accept RTCP %v\", err)\n\t\t\treturn\n\t\t}\n\t\tpc.log.Warnf(\"Incoming unhandled RTCP ssrc(%d), OnTrack will not be fired\", ssrc)\n\t\tunhandledStreams = append(unhandledStreams, stream)\n\t}\n}\n\n// RemoteDescription returns pendingRemoteDescription if it is not null and\n// otherwise it returns currentRemoteDescription. This property is used to\n// determine if setRemoteDescription has already been called.\n// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-remotedescription\nfunc (pc *PeerConnection) RemoteDescription() *SessionDescription {\n\tpc.mu.RLock()\n\tdefer pc.mu.RUnlock()\n\n\tif pc.pendingRemoteDescription != nil {\n\t\treturn pc.pendingRemoteDescription\n\t}\n\treturn pc.currentRemoteDescription\n}\n\n// AddICECandidate accepts an ICE candidate string and adds it\n// to the existing set of candidates.\nfunc (pc *PeerConnection) AddICECandidate(candidate ICECandidateInit) error {\n\tif pc.RemoteDescription() == nil {\n\t\treturn &rtcerr.InvalidStateError{Err: ErrNoRemoteDescription}\n\t}\n\n\tcandidateValue := strings.TrimPrefix(candidate.Candidate, \"candidate:\")\n\n\tvar iceCandidate *ICECandidate\n\tif candidateValue != \"\" {\n\t\tcandidate, err := ice.UnmarshalCandidate(candidateValue)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, ice.ErrUnknownCandidateTyp) || errors.Is(err, ice.ErrDetermineNetworkType) {\n\t\t\t\tpc.log.Warnf(\"Discarding remote candidate: %s\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tc, err := newICECandidateFromICE(candidate, \"\", 0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ticeCandidate = &c\n\t}\n\n\treturn pc.iceTransport.AddRemoteCandidate(iceCandidate)\n}\n\n// ICEConnectionState returns the ICE connection state of the\n// PeerConnection instance.\nfunc (pc *PeerConnection) ICEConnectionState() ICEConnectionState {\n\tif state, ok := pc.iceConnectionState.Load().(ICEConnectionState); ok {\n\t\treturn state\n\t}\n\treturn ICEConnectionState(0)\n}\n\n// GetSenders returns the RTPSender that are currently attached to this PeerConnection\nfunc (pc *PeerConnection) GetSenders() (result []*RTPSender) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\tfor _, transceiver := range pc.rtpTransceivers {\n\t\tif sender := transceiver.Sender(); sender != nil {\n\t\t\tresult = append(result, sender)\n\t\t}\n\t}\n\treturn result\n}\n\n// GetReceivers returns the RTPReceivers that are currently attached to this PeerConnection\nfunc (pc *PeerConnection) GetReceivers() (receivers []*RTPReceiver) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\tfor _, transceiver := range pc.rtpTransceivers {\n\t\tif receiver := transceiver.Receiver(); receiver != nil {\n\t\t\treceivers = append(receivers, receiver)\n\t\t}\n\t}\n\treturn\n}\n\n// GetTransceivers returns the RtpTransceiver that are currently attached to this PeerConnection\nfunc (pc *PeerConnection) GetTransceivers() []*RTPTransceiver {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\treturn pc.rtpTransceivers\n}\n\n// AddTrack adds a Track to the PeerConnection\nfunc (pc *PeerConnection) AddTrack(track TrackLocal) (*RTPSender, error) {\n\tif pc.isClosed.get() {\n\t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tfor _, t := range pc.rtpTransceivers {\n\t\tcurrentDirection := t.getCurrentDirection()\n\t\t// According to https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-addtrack, if the\n\t\t// transceiver can be reused only if it's currentDirection never be sendrecv or sendonly.\n\t\t// But that will cause sdp inflate. So we only check currentDirection's current value,\n\t\t// that's worked for all browsers.\n\t\tif t.kind == track.Kind() && t.Sender() == nil &&\n\t\t\t!(currentDirection == RTPTransceiverDirectionSendrecv || currentDirection == RTPTransceiverDirectionSendonly) {\n\t\t\tsender, err := pc.api.NewRTPSender(track, pc.dtlsTransport)\n\t\t\tif err == nil {\n\t\t\t\terr = t.SetSender(sender, track)\n\t\t\t\tif err != nil {\n\t\t\t\t\t_ = sender.Stop()\n\t\t\t\t\tt.setSender(nil)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpc.onNegotiationNeeded()\n\t\t\treturn sender, nil\n\t\t}\n\t}\n\n\ttransceiver, err := pc.newTransceiverFromTrack(RTPTransceiverDirectionSendrecv, track)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpc.addRTPTransceiver(transceiver)\n\treturn transceiver.Sender(), nil\n}\n\n// RemoveTrack removes a Track from the PeerConnection\nfunc (pc *PeerConnection) RemoveTrack(sender *RTPSender) (err error) {\n\tif pc.isClosed.get() {\n\t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\tvar transceiver *RTPTransceiver\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\tfor _, t := range pc.rtpTransceivers {\n\t\tif t.Sender() == sender {\n\t\t\ttransceiver = t\n\t\t\tbreak\n\t\t}\n\t}\n\tif transceiver == nil {\n\t\treturn &rtcerr.InvalidAccessError{Err: ErrSenderNotCreatedByConnection}\n\t} else if err = sender.Stop(); err == nil {\n\t\terr = transceiver.setSendingTrack(nil)\n\t\tif err == nil {\n\t\t\tpc.onNegotiationNeeded()\n\t\t}\n\t}\n\treturn\n}\n\nfunc (pc *PeerConnection) newTransceiverFromTrack(direction RTPTransceiverDirection, track TrackLocal, init ...RTPTransceiverInit) (t *RTPTransceiver, err error) {\n\tvar (\n\t\tr *RTPReceiver\n\t\ts *RTPSender\n\t)\n\tswitch direction {\n\tcase RTPTransceiverDirectionSendrecv:\n\t\tr, err = pc.api.NewRTPReceiver(track.Kind(), pc.dtlsTransport)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\ts, err = pc.api.NewRTPSender(track, pc.dtlsTransport)\n\tcase RTPTransceiverDirectionSendonly:\n\t\ts, err = pc.api.NewRTPSender(track, pc.dtlsTransport)\n\tdefault:\n\t\terr = errPeerConnAddTransceiverFromTrackSupport\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Allow RTPTransceiverInit to override SSRC\n\tif s != nil && len(s.trackEncodings) == 1 &&\n\t\tlen(init) == 1 && len(init[0].SendEncodings) == 1 && init[0].SendEncodings[0].SSRC != 0 {\n\t\ts.trackEncodings[0].ssrc = init[0].SendEncodings[0].SSRC\n\t}\n\n\treturn newRTPTransceiver(r, s, direction, track.Kind(), pc.api), nil\n}\n\n// AddTransceiverFromKind Create a new RtpTransceiver and adds it to the set of transceivers.\nfunc (pc *PeerConnection) AddTransceiverFromKind(kind RTPCodecType, init ...RTPTransceiverInit) (t *RTPTransceiver, err error) {\n\tif pc.isClosed.get() {\n\t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\tdirection := RTPTransceiverDirectionSendrecv\n\tif len(init) > 1 {\n\t\treturn nil, errPeerConnAddTransceiverFromKindOnlyAcceptsOne\n\t} else if len(init) == 1 {\n\t\tdirection = init[0].Direction\n\t}\n\tswitch direction {\n\tcase RTPTransceiverDirectionSendonly, RTPTransceiverDirectionSendrecv:\n\t\tcodecs := pc.api.mediaEngine.getCodecsByKind(kind)\n\t\tif len(codecs) == 0 {\n\t\t\treturn nil, ErrNoCodecsAvailable\n\t\t}\n\t\ttrack, err := NewTrackLocalStaticSample(codecs[0].RTPCodecCapability, util.MathRandAlpha(16), util.MathRandAlpha(16))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tt, err = pc.newTransceiverFromTrack(direction, track, init...)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase RTPTransceiverDirectionRecvonly:\n\t\treceiver, err := pc.api.NewRTPReceiver(kind, pc.dtlsTransport)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tt = newRTPTransceiver(receiver, nil, RTPTransceiverDirectionRecvonly, kind, pc.api)\n\tdefault:\n\t\treturn nil, errPeerConnAddTransceiverFromKindSupport\n\t}\n\tpc.mu.Lock()\n\tpc.addRTPTransceiver(t)\n\tpc.mu.Unlock()\n\treturn t, nil\n}\n\n// AddTransceiverFromTrack Create a new RtpTransceiver(SendRecv or SendOnly) and add it to the set of transceivers.\nfunc (pc *PeerConnection) AddTransceiverFromTrack(track TrackLocal, init ...RTPTransceiverInit) (t *RTPTransceiver, err error) {\n\tif pc.isClosed.get() {\n\t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\tdirection := RTPTransceiverDirectionSendrecv\n\tif len(init) > 1 {\n\t\treturn nil, errPeerConnAddTransceiverFromTrackOnlyAcceptsOne\n\t} else if len(init) == 1 {\n\t\tdirection = init[0].Direction\n\t}\n\n\tt, err = pc.newTransceiverFromTrack(direction, track, init...)\n\tif err == nil {\n\t\tpc.mu.Lock()\n\t\tpc.addRTPTransceiver(t)\n\t\tpc.mu.Unlock()\n\t}\n\treturn\n}\n\n// CreateDataChannel creates a new DataChannel object with the given label\n// and optional DataChannelInit used to configure properties of the\n// underlying channel such as data reliability.\nfunc (pc *PeerConnection) CreateDataChannel(label string, options *DataChannelInit) (*DataChannel, error) {\n\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #2)\n\tif pc.isClosed.get() {\n\t\treturn nil, &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\tparams := &DataChannelParameters{\n\t\tLabel:   label,\n\t\tOrdered: true,\n\t}\n\n\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #19)\n\tif options != nil {\n\t\tparams.ID = options.ID\n\t}\n\n\tif options != nil {\n\t\t// Ordered indicates if data is allowed to be delivered out of order. The\n\t\t// default value of true, guarantees that data will be delivered in order.\n\t\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #9)\n\t\tif options.Ordered != nil {\n\t\t\tparams.Ordered = *options.Ordered\n\t\t}\n\n\t\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #7)\n\t\tif options.MaxPacketLifeTime != nil {\n\t\t\tparams.MaxPacketLifeTime = options.MaxPacketLifeTime\n\t\t}\n\n\t\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #8)\n\t\tif options.MaxRetransmits != nil {\n\t\t\tparams.MaxRetransmits = options.MaxRetransmits\n\t\t}\n\n\t\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #10)\n\t\tif options.Protocol != nil {\n\t\t\tparams.Protocol = *options.Protocol\n\t\t}\n\n\t\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #11)\n\t\tif len(params.Protocol) > 65535 {\n\t\t\treturn nil, &rtcerr.TypeError{Err: ErrProtocolTooLarge}\n\t\t}\n\n\t\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #12)\n\t\tif options.Negotiated != nil {\n\t\t\tparams.Negotiated = *options.Negotiated\n\t\t}\n\t}\n\n\td, err := pc.api.newDataChannel(params, nil, pc.log)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// https://w3c.github.io/webrtc-pc/#peer-to-peer-data-api (Step #16)\n\tif d.maxPacketLifeTime != nil && d.maxRetransmits != nil {\n\t\treturn nil, &rtcerr.TypeError{Err: ErrRetransmitsOrPacketLifeTime}\n\t}\n\n\tpc.sctpTransport.lock.Lock()\n\tpc.sctpTransport.dataChannels = append(pc.sctpTransport.dataChannels, d)\n\tif d.ID() != nil {\n\t\tpc.sctpTransport.dataChannelIDsUsed[*d.ID()] = struct{}{}\n\t}\n\tpc.sctpTransport.dataChannelsRequested++\n\tpc.sctpTransport.lock.Unlock()\n\n\t// If SCTP already connected open all the channels\n\tif pc.sctpTransport.State() == SCTPTransportStateConnected {\n\t\tif err = d.open(pc.sctpTransport); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tpc.mu.Lock()\n\tpc.onNegotiationNeeded()\n\tpc.mu.Unlock()\n\n\treturn d, nil\n}\n\n// SetIdentityProvider is used to configure an identity provider to generate identity assertions\nfunc (pc *PeerConnection) SetIdentityProvider(string) error {\n\treturn errPeerConnSetIdentityProviderNotImplemented\n}\n\n// WriteRTCP sends a user provided RTCP packet to the connected peer. If no peer is connected the\n// packet is discarded. It also runs any configured interceptors.\nfunc (pc *PeerConnection) WriteRTCP(pkts []rtcp.Packet) error {\n\t_, err := pc.interceptorRTCPWriter.Write(pkts, make(interceptor.Attributes))\n\treturn err\n}\n\nfunc (pc *PeerConnection) writeRTCP(pkts []rtcp.Packet, _ interceptor.Attributes) (int, error) {\n\treturn pc.dtlsTransport.WriteRTCP(pkts)\n}\n\n// Close ends the PeerConnection.\nfunc (pc *PeerConnection) Close() error {\n\treturn pc.close(false /* shouldGracefullyClose */)\n}\n\n// GracefulClose ends the PeerConnection. It also waits\n// for any goroutines it started to complete. This is only safe to call outside of\n// PeerConnection callbacks or if in a callback, in its own goroutine.\nfunc (pc *PeerConnection) GracefulClose() error {\n\treturn pc.close(true /* shouldGracefullyClose */)\n}\n\nfunc (pc *PeerConnection) close(shouldGracefullyClose bool) error {\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #1)\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #2)\n\n\tpc.mu.Lock()\n\t// A lock in this critical section is needed because pc.isClosed and\n\t// pc.isGracefullyClosingOrClosed are related to each other in that we\n\t// want to make graceful and normal closure one time operations in order\n\t// to avoid any double closure errors from cropping up. However, there are\n\t// some overlapping close cases when both normal and graceful close are used\n\t// that should be idempotent, but be cautioned when writing new close behavior\n\t// to preserve this property.\n\tisAlreadyClosingOrClosed := pc.isClosed.swap(true)\n\tisAlreadyGracefullyClosingOrClosed := pc.isGracefullyClosingOrClosed\n\tif shouldGracefullyClose && !isAlreadyGracefullyClosingOrClosed {\n\t\tpc.isGracefullyClosingOrClosed = true\n\t}\n\tpc.mu.Unlock()\n\n\tif isAlreadyClosingOrClosed {\n\t\tif !shouldGracefullyClose {\n\t\t\treturn nil\n\t\t}\n\t\t// Even if we're already closing, it may not be graceful:\n\t\t// If we are not the ones doing the closing, we just wait for the graceful close\n\t\t// to happen and then return.\n\t\tif isAlreadyGracefullyClosingOrClosed {\n\t\t\t<-pc.isGracefulCloseDone\n\t\t\treturn nil\n\t\t}\n\t\t// Otherwise we need to go through the graceful closure flow once the\n\t\t// normal closure is done since there are extra steps to take with a\n\t\t// graceful close.\n\t\t<-pc.isCloseDone\n\t} else {\n\t\tdefer close(pc.isCloseDone)\n\t}\n\n\tif shouldGracefullyClose {\n\t\tdefer close(pc.isGracefulCloseDone)\n\t}\n\n\t// Try closing everything and collect the errors\n\t// Shutdown strategy:\n\t// 1. All Conn close by closing their underlying Conn.\n\t// 2. A Mux stops this chain. It won't close the underlying\n\t//    Conn if one of the endpoints is closed down. To\n\t//    continue the chain the Mux has to be closed.\n\tcloseErrs := make([]error, 4)\n\n\tdoGracefulCloseOps := func() []error {\n\t\tif !shouldGracefullyClose {\n\t\t\treturn nil\n\t\t}\n\n\t\t// these are all non-canon steps\n\t\tvar gracefulCloseErrors []error\n\t\tif pc.iceTransport != nil {\n\t\t\tgracefulCloseErrors = append(gracefulCloseErrors, pc.iceTransport.GracefulStop())\n\t\t}\n\n\t\tpc.ops.GracefulClose()\n\n\t\tpc.sctpTransport.lock.Lock()\n\t\tfor _, d := range pc.sctpTransport.dataChannels {\n\t\t\tgracefulCloseErrors = append(gracefulCloseErrors, d.GracefulClose())\n\t\t}\n\t\tpc.sctpTransport.lock.Unlock()\n\t\treturn gracefulCloseErrors\n\t}\n\n\tif isAlreadyClosingOrClosed {\n\t\treturn util.FlattenErrs(doGracefulCloseOps())\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #3)\n\tpc.signalingState.Set(SignalingStateClosed)\n\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #4)\n\tpc.mu.Lock()\n\tfor _, t := range pc.rtpTransceivers {\n\t\tcloseErrs = append(closeErrs, t.Stop())\n\t}\n\tif nonMediaBandwidthProbe, ok := pc.nonMediaBandwidthProbe.Load().(*RTPReceiver); ok {\n\t\tcloseErrs = append(closeErrs, nonMediaBandwidthProbe.Stop())\n\t}\n\tpc.mu.Unlock()\n\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #5)\n\tpc.sctpTransport.lock.Lock()\n\tfor _, d := range pc.sctpTransport.dataChannels {\n\t\td.setReadyState(DataChannelStateClosed)\n\t}\n\tpc.sctpTransport.lock.Unlock()\n\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #6)\n\tif pc.sctpTransport != nil {\n\t\tcloseErrs = append(closeErrs, pc.sctpTransport.Stop())\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #7)\n\tcloseErrs = append(closeErrs, pc.dtlsTransport.Stop())\n\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #8, #9, #10)\n\tif pc.iceTransport != nil && !shouldGracefullyClose {\n\t\t// we will stop gracefully in doGracefulCloseOps\n\t\tcloseErrs = append(closeErrs, pc.iceTransport.Stop())\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-close (step #11)\n\tpc.updateConnectionState(pc.ICEConnectionState(), pc.dtlsTransport.State())\n\n\tcloseErrs = append(closeErrs, doGracefulCloseOps()...)\n\n\t// Interceptor closes at the end to prevent Bind from being called after interceptor is closed\n\tcloseErrs = append(closeErrs, pc.api.interceptor.Close())\n\n\treturn util.FlattenErrs(closeErrs)\n}\n\n// addRTPTransceiver appends t into rtpTransceivers\n// and fires onNegotiationNeeded;\n// caller of this method should hold `pc.mu` lock\nfunc (pc *PeerConnection) addRTPTransceiver(t *RTPTransceiver) {\n\tpc.rtpTransceivers = append(pc.rtpTransceivers, t)\n\tpc.onNegotiationNeeded()\n}\n\n// CurrentLocalDescription represents the local description that was\n// successfully negotiated the last time the PeerConnection transitioned\n// into the stable state plus any local candidates that have been generated\n// by the ICEAgent since the offer or answer was created.\nfunc (pc *PeerConnection) CurrentLocalDescription() *SessionDescription {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\tlocalDescription := pc.currentLocalDescription\n\ticeGather := pc.iceGatherer\n\ticeGatheringState := pc.ICEGatheringState()\n\treturn populateLocalCandidates(localDescription, iceGather, iceGatheringState)\n}\n\n// PendingLocalDescription represents a local description that is in the\n// process of being negotiated plus any local candidates that have been\n// generated by the ICEAgent since the offer or answer was created. If the\n// PeerConnection is in the stable state, the value is null.\nfunc (pc *PeerConnection) PendingLocalDescription() *SessionDescription {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\tlocalDescription := pc.pendingLocalDescription\n\ticeGather := pc.iceGatherer\n\ticeGatheringState := pc.ICEGatheringState()\n\treturn populateLocalCandidates(localDescription, iceGather, iceGatheringState)\n}\n\n// CurrentRemoteDescription represents the last remote description that was\n// successfully negotiated the last time the PeerConnection transitioned\n// into the stable state plus any remote candidates that have been supplied\n// via AddICECandidate() since the offer or answer was created.\nfunc (pc *PeerConnection) CurrentRemoteDescription() *SessionDescription {\n\tpc.mu.RLock()\n\tdefer pc.mu.RUnlock()\n\n\treturn pc.currentRemoteDescription\n}\n\n// PendingRemoteDescription represents a remote description that is in the\n// process of being negotiated, complete with any remote candidates that\n// have been supplied via AddICECandidate() since the offer or answer was\n// created. If the PeerConnection is in the stable state, the value is\n// null.\nfunc (pc *PeerConnection) PendingRemoteDescription() *SessionDescription {\n\tpc.mu.RLock()\n\tdefer pc.mu.RUnlock()\n\n\treturn pc.pendingRemoteDescription\n}\n\n// SignalingState attribute returns the signaling state of the\n// PeerConnection instance.\nfunc (pc *PeerConnection) SignalingState() SignalingState {\n\treturn pc.signalingState.Get()\n}\n\n// ICEGatheringState attribute returns the ICE gathering state of the\n// PeerConnection instance.\nfunc (pc *PeerConnection) ICEGatheringState() ICEGatheringState {\n\tif pc.iceGatherer == nil {\n\t\treturn ICEGatheringStateNew\n\t}\n\n\tswitch pc.iceGatherer.State() {\n\tcase ICEGathererStateNew:\n\t\treturn ICEGatheringStateNew\n\tcase ICEGathererStateGathering:\n\t\treturn ICEGatheringStateGathering\n\tdefault:\n\t\treturn ICEGatheringStateComplete\n\t}\n}\n\n// ConnectionState attribute returns the connection state of the\n// PeerConnection instance.\nfunc (pc *PeerConnection) ConnectionState() PeerConnectionState {\n\tif state, ok := pc.connectionState.Load().(PeerConnectionState); ok {\n\t\treturn state\n\t}\n\treturn PeerConnectionState(0)\n}\n\n// GetStats return data providing statistics about the overall connection\nfunc (pc *PeerConnection) GetStats() StatsReport {\n\tvar (\n\t\tdataChannelsAccepted  uint32\n\t\tdataChannelsClosed    uint32\n\t\tdataChannelsOpened    uint32\n\t\tdataChannelsRequested uint32\n\t)\n\tstatsCollector := newStatsReportCollector()\n\tstatsCollector.Collecting()\n\n\tpc.mu.Lock()\n\tif pc.iceGatherer != nil {\n\t\tpc.iceGatherer.collectStats(statsCollector)\n\t}\n\tif pc.iceTransport != nil {\n\t\tpc.iceTransport.collectStats(statsCollector)\n\t}\n\n\tpc.sctpTransport.lock.Lock()\n\tdataChannels := append([]*DataChannel{}, pc.sctpTransport.dataChannels...)\n\tdataChannelsAccepted = pc.sctpTransport.dataChannelsAccepted\n\tdataChannelsOpened = pc.sctpTransport.dataChannelsOpened\n\tdataChannelsRequested = pc.sctpTransport.dataChannelsRequested\n\tpc.sctpTransport.lock.Unlock()\n\n\tfor _, d := range dataChannels {\n\t\tstate := d.ReadyState()\n\t\tif state != DataChannelStateConnecting && state != DataChannelStateOpen {\n\t\t\tdataChannelsClosed++\n\t\t}\n\n\t\td.collectStats(statsCollector)\n\t}\n\tpc.sctpTransport.collectStats(statsCollector)\n\n\tstats := PeerConnectionStats{\n\t\tTimestamp:             statsTimestampNow(),\n\t\tType:                  StatsTypePeerConnection,\n\t\tID:                    pc.statsID,\n\t\tDataChannelsAccepted:  dataChannelsAccepted,\n\t\tDataChannelsClosed:    dataChannelsClosed,\n\t\tDataChannelsOpened:    dataChannelsOpened,\n\t\tDataChannelsRequested: dataChannelsRequested,\n\t}\n\n\tstatsCollector.Collect(stats.ID, stats)\n\n\tcertificates := pc.configuration.Certificates\n\tfor _, certificate := range certificates {\n\t\tif err := certificate.collectStats(statsCollector); err != nil {\n\t\t\tcontinue\n\t\t}\n\t}\n\tpc.mu.Unlock()\n\n\tpc.api.mediaEngine.collectStats(statsCollector)\n\n\treturn statsCollector.Ready()\n}\n\n// Start all transports. PeerConnection now has enough state\nfunc (pc *PeerConnection) startTransports(iceRole ICERole, dtlsRole DTLSRole, remoteUfrag, remotePwd, fingerprint, fingerprintHash string) {\n\t// Start the ice transport\n\terr := pc.iceTransport.Start(\n\t\tpc.iceGatherer,\n\t\tICEParameters{\n\t\t\tUsernameFragment: remoteUfrag,\n\t\t\tPassword:         remotePwd,\n\t\t\tICELite:          false,\n\t\t},\n\t\t&iceRole,\n\t)\n\tif err != nil {\n\t\tpc.log.Warnf(\"Failed to start manager: %s\", err)\n\t\treturn\n\t}\n\n\tpc.dtlsTransport.internalOnCloseHandler = func() {\n\t\tif pc.isClosed.get() || pc.api.settingEngine.disableCloseByDTLS {\n\t\t\treturn\n\t\t}\n\n\t\tpc.log.Info(\"Closing PeerConnection from DTLS CloseNotify\")\n\t\tgo func() {\n\t\t\tif pcClosErr := pc.Close(); pcClosErr != nil {\n\t\t\t\tpc.log.Warnf(\"Failed to close PeerConnection from DTLS CloseNotify: %s\", pcClosErr)\n\t\t\t}\n\t\t}()\n\t}\n\n\t// Start the dtls transport\n\terr = pc.dtlsTransport.Start(DTLSParameters{\n\t\tRole:         dtlsRole,\n\t\tFingerprints: []DTLSFingerprint{{Algorithm: fingerprintHash, Value: fingerprint}},\n\t})\n\tpc.updateConnectionState(pc.ICEConnectionState(), pc.dtlsTransport.State())\n\tif err != nil {\n\t\tpc.log.Warnf(\"Failed to start manager: %s\", err)\n\t\treturn\n\t}\n}\n\n// nolint: gocognit\nfunc (pc *PeerConnection) startRTP(isRenegotiation bool, remoteDesc *SessionDescription, currentTransceivers []*RTPTransceiver) {\n\tif !isRenegotiation {\n\t\tpc.undeclaredMediaProcessor()\n\t}\n\n\tpc.startRTPReceivers(remoteDesc, currentTransceivers)\n\tif haveApplicationMediaSection(remoteDesc.parsed) {\n\t\tpc.startSCTP()\n\t}\n}\n\n// generateUnmatchedSDP generates an SDP that doesn't take remote state into account\n// This is used for the initial call for CreateOffer\nfunc (pc *PeerConnection) generateUnmatchedSDP(transceivers []*RTPTransceiver, useIdentity bool) (*sdp.SessionDescription, error) {\n\td, err := sdp.NewJSEPSessionDescription(useIdentity)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\td.Attributes = append(d.Attributes, sdp.Attribute{Key: sdp.AttrKeyMsidSemantic, Value: \"WMS*\"})\n\n\ticeParams, err := pc.iceGatherer.GetLocalParameters()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcandidates, err := pc.iceGatherer.GetLocalCandidates()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tisPlanB := pc.configuration.SDPSemantics == SDPSemanticsPlanB\n\tmediaSections := []mediaSection{}\n\n\t// Needed for pc.sctpTransport.dataChannelsRequested\n\tpc.sctpTransport.lock.Lock()\n\tdefer pc.sctpTransport.lock.Unlock()\n\n\tif isPlanB {\n\t\tvideo := make([]*RTPTransceiver, 0)\n\t\taudio := make([]*RTPTransceiver, 0)\n\n\t\tfor _, t := range transceivers {\n\t\t\tif t.kind == RTPCodecTypeVideo {\n\t\t\t\tvideo = append(video, t)\n\t\t\t} else if t.kind == RTPCodecTypeAudio {\n\t\t\t\taudio = append(audio, t)\n\t\t\t}\n\t\t\tif sender := t.Sender(); sender != nil {\n\t\t\t\tsender.setNegotiated()\n\t\t\t}\n\t\t}\n\n\t\tif len(video) > 0 {\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: \"video\", transceivers: video})\n\t\t}\n\t\tif len(audio) > 0 {\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: \"audio\", transceivers: audio})\n\t\t}\n\n\t\tif pc.sctpTransport.dataChannelsRequested != 0 {\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: \"data\", data: true})\n\t\t}\n\t} else {\n\t\tfor _, t := range transceivers {\n\t\t\tif sender := t.Sender(); sender != nil {\n\t\t\t\tsender.setNegotiated()\n\t\t\t}\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: t.Mid(), transceivers: []*RTPTransceiver{t}})\n\t\t}\n\n\t\tif pc.sctpTransport.dataChannelsRequested != 0 {\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: strconv.Itoa(len(mediaSections)), data: true})\n\t\t}\n\t}\n\n\tdtlsFingerprints, err := pc.configuration.Certificates[0].GetFingerprints()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn populateSDP(d, isPlanB, dtlsFingerprints, pc.api.settingEngine.sdpMediaLevelFingerprints, pc.api.settingEngine.candidates.ICELite, true, pc.api.mediaEngine, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), candidates, iceParams, mediaSections, pc.ICEGatheringState(), nil)\n}\n\n// generateMatchedSDP generates a SDP and takes the remote state into account\n// this is used everytime we have a RemoteDescription\n// nolint: gocyclo\nfunc (pc *PeerConnection) generateMatchedSDP(transceivers []*RTPTransceiver, useIdentity bool, includeUnmatched bool, connectionRole sdp.ConnectionRole) (*sdp.SessionDescription, error) { //nolint:gocognit\n\td, err := sdp.NewJSEPSessionDescription(useIdentity)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\td.Attributes = append(d.Attributes, sdp.Attribute{Key: sdp.AttrKeyMsidSemantic, Value: \"WMS*\"})\n\n\ticeParams, err := pc.iceGatherer.GetLocalParameters()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcandidates, err := pc.iceGatherer.GetLocalCandidates()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar t *RTPTransceiver\n\tremoteDescription := pc.currentRemoteDescription\n\tif pc.pendingRemoteDescription != nil {\n\t\tremoteDescription = pc.pendingRemoteDescription\n\t}\n\tisExtmapAllowMixed := isExtMapAllowMixedSet(remoteDescription.parsed)\n\tlocalTransceivers := append([]*RTPTransceiver{}, transceivers...)\n\n\tdetectedPlanB := descriptionIsPlanB(remoteDescription, pc.log)\n\tif pc.configuration.SDPSemantics != SDPSemanticsUnifiedPlan {\n\t\tdetectedPlanB = descriptionPossiblyPlanB(remoteDescription)\n\t}\n\n\tmediaSections := []mediaSection{}\n\talreadyHaveApplicationMediaSection := false\n\tfor _, media := range remoteDescription.parsed.MediaDescriptions {\n\t\tmidValue := getMidValue(media)\n\t\tif midValue == \"\" {\n\t\t\treturn nil, errPeerConnRemoteDescriptionWithoutMidValue\n\t\t}\n\n\t\tif media.MediaName.Media == mediaSectionApplication {\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: midValue, data: true})\n\t\t\talreadyHaveApplicationMediaSection = true\n\t\t\tcontinue\n\t\t}\n\n\t\tkind := NewRTPCodecType(media.MediaName.Media)\n\t\tdirection := getPeerDirection(media)\n\t\tif kind == 0 || direction == RTPTransceiverDirectionUnknown {\n\t\t\tcontinue\n\t\t}\n\n\t\tsdpSemantics := pc.configuration.SDPSemantics\n\n\t\tswitch {\n\t\tcase sdpSemantics == SDPSemanticsPlanB || sdpSemantics == SDPSemanticsUnifiedPlanWithFallback && detectedPlanB:\n\t\t\tif !detectedPlanB {\n\t\t\t\treturn nil, &rtcerr.TypeError{Err: fmt.Errorf(\"%w: Expected PlanB, but RemoteDescription is UnifiedPlan\", ErrIncorrectSDPSemantics)}\n\t\t\t}\n\t\t\t// If we're responding to a plan-b offer, then we should try to fill up this\n\t\t\t// media entry with all matching local transceivers\n\t\t\tmediaTransceivers := []*RTPTransceiver{}\n\t\t\tfor {\n\t\t\t\t// keep going until we can't get any more\n\t\t\t\tt, localTransceivers = satisfyTypeAndDirection(kind, direction, localTransceivers)\n\t\t\t\tif t == nil {\n\t\t\t\t\tif len(mediaTransceivers) == 0 {\n\t\t\t\t\t\tt = &RTPTransceiver{kind: kind, api: pc.api, codecs: pc.api.mediaEngine.getCodecsByKind(kind)}\n\t\t\t\t\t\tt.setDirection(RTPTransceiverDirectionInactive)\n\t\t\t\t\t\tmediaTransceivers = append(mediaTransceivers, t)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif sender := t.Sender(); sender != nil {\n\t\t\t\t\tsender.setNegotiated()\n\t\t\t\t}\n\t\t\t\tmediaTransceivers = append(mediaTransceivers, t)\n\t\t\t}\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: midValue, transceivers: mediaTransceivers})\n\t\tcase sdpSemantics == SDPSemanticsUnifiedPlan || sdpSemantics == SDPSemanticsUnifiedPlanWithFallback:\n\t\t\tif detectedPlanB {\n\t\t\t\treturn nil, &rtcerr.TypeError{Err: fmt.Errorf(\"%w: Expected UnifiedPlan, but RemoteDescription is PlanB\", ErrIncorrectSDPSemantics)}\n\t\t\t}\n\t\t\tt, localTransceivers = findByMid(midValue, localTransceivers)\n\t\t\tif t == nil {\n\t\t\t\treturn nil, fmt.Errorf(\"%w: %q\", errPeerConnTranscieverMidNil, midValue)\n\t\t\t}\n\t\t\tif sender := t.Sender(); sender != nil {\n\t\t\t\tsender.setNegotiated()\n\t\t\t}\n\t\t\tmediaTransceivers := []*RTPTransceiver{t}\n\n\t\t\textensions, _ := rtpExtensionsFromMediaDescription(media)\n\t\t\tmediaSections = append(mediaSections, mediaSection{id: midValue, transceivers: mediaTransceivers, matchExtensions: extensions, rids: getRids(media)})\n\t\t}\n\t}\n\n\tvar bundleGroup *string\n\t// If we are offering also include unmatched local transceivers\n\tif includeUnmatched {\n\t\tif !detectedPlanB {\n\t\t\tfor _, t := range localTransceivers {\n\t\t\t\tif sender := t.Sender(); sender != nil {\n\t\t\t\t\tsender.setNegotiated()\n\t\t\t\t}\n\t\t\t\tmediaSections = append(mediaSections, mediaSection{id: t.Mid(), transceivers: []*RTPTransceiver{t}})\n\t\t\t}\n\t\t}\n\n\t\tif pc.sctpTransport.dataChannelsRequested != 0 && !alreadyHaveApplicationMediaSection {\n\t\t\tif detectedPlanB {\n\t\t\t\tmediaSections = append(mediaSections, mediaSection{id: \"data\", data: true})\n\t\t\t} else {\n\t\t\t\tmediaSections = append(mediaSections, mediaSection{id: strconv.Itoa(len(mediaSections)), data: true})\n\t\t\t}\n\t\t}\n\t} else if remoteDescription != nil {\n\t\tgroupValue, _ := remoteDescription.parsed.Attribute(sdp.AttrKeyGroup)\n\t\tgroupValue = strings.TrimLeft(groupValue, \"BUNDLE\")\n\t\tbundleGroup = &groupValue\n\t}\n\n\tif pc.configuration.SDPSemantics == SDPSemanticsUnifiedPlanWithFallback && detectedPlanB {\n\t\tpc.log.Info(\"Plan-B Offer detected; responding with Plan-B Answer\")\n\t}\n\n\tdtlsFingerprints, err := pc.configuration.Certificates[0].GetFingerprints()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn populateSDP(d, detectedPlanB, dtlsFingerprints, pc.api.settingEngine.sdpMediaLevelFingerprints, pc.api.settingEngine.candidates.ICELite, isExtmapAllowMixed, pc.api.mediaEngine, connectionRole, candidates, iceParams, mediaSections, pc.ICEGatheringState(), bundleGroup)\n}\n\nfunc (pc *PeerConnection) setGatherCompleteHandler(handler func()) {\n\tpc.iceGatherer.onGatheringCompleteHandler.Store(handler)\n}\n\n// SCTP returns the SCTPTransport for this PeerConnection\n//\n// The SCTP transport over which SCTP data is sent and received. If SCTP has not been negotiated, the value is nil.\n// https://www.w3.org/TR/webrtc/#attributes-15\nfunc (pc *PeerConnection) SCTP() *SCTPTransport {\n\treturn pc.sctpTransport\n}\n"
        },
        {
          "name": "peerconnection_close_test.go",
          "type": "blob",
          "size": 6.7177734375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPeerConnection_Close(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tawaitSetup := make(chan struct{})\n\tpcAnswer.OnDataChannel(func(d *DataChannel) {\n\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t// created in signalPair).\n\t\tif d.Label() != \"data\" {\n\t\t\treturn\n\t\t}\n\t\tclose(awaitSetup)\n\t})\n\n\tawaitICEClosed := make(chan struct{})\n\tpcAnswer.OnICEConnectionStateChange(func(i ICEConnectionState) {\n\t\tif i == ICEConnectionStateClosed {\n\t\t\tclose(awaitICEClosed)\n\t\t}\n\t})\n\n\t_, err = pcOffer.CreateDataChannel(\"data\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = signalPair(pcOffer, pcAnswer)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t<-awaitSetup\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n\n\t<-awaitICEClosed\n}\n\n// Assert that a PeerConnection that is shutdown before ICE starts doesn't leak\nfunc TestPeerConnection_Close_PreICE(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = pcOffer.CreateDataChannel(\"test-channel\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tanswer, err := pcOffer.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tassert.NoError(t, pcOffer.Close())\n\n\tif err = pcAnswer.SetRemoteDescription(answer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor {\n\t\tif pcAnswer.iceTransport.State() == ICETransportStateChecking {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(time.Second / 4)\n\t}\n\n\tassert.NoError(t, pcAnswer.Close())\n\n\t// Assert that ICETransport is shutdown, test timeout will prevent deadlock\n\tfor {\n\t\tif pcAnswer.iceTransport.State() == ICETransportStateClosed {\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(time.Second / 4)\n\t}\n}\n\nfunc TestPeerConnection_Close_DuringICE(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclosedOffer := make(chan struct{})\n\tclosedAnswer := make(chan struct{})\n\tpcAnswer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {\n\t\tif iceState == ICEConnectionStateConnected {\n\t\t\tgo func() {\n\t\t\t\tassert.NoError(t, pcAnswer.Close())\n\t\t\t\tclose(closedAnswer)\n\n\t\t\t\tassert.NoError(t, pcOffer.Close())\n\t\t\t\tclose(closedOffer)\n\t\t\t}()\n\t\t}\n\t})\n\n\t_, err = pcOffer.CreateDataChannel(\"test-channel\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\tif err = pcOffer.SetLocalDescription(offer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t<-offerGatheringComplete\n\n\tif err = pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\tif err = pcAnswer.SetLocalDescription(answer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t<-answerGatheringComplete\n\tif err = pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tselect {\n\tcase <-closedAnswer:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Error(\"pcAnswer.Close() Timeout\")\n\t}\n\tselect {\n\tcase <-closedOffer:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Error(\"pcOffer.Close() Timeout\")\n\t}\n}\n\nfunc TestPeerConnection_GracefulCloseWithIncomingMessages(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 20)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutinesStrict(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar dcAnswer *DataChannel\n\tanswerDataChannelOpened := make(chan struct{})\n\tpcAnswer.OnDataChannel(func(d *DataChannel) {\n\t\t// Make sure this is the data channel we were looking for. (Not the one\n\t\t// created in signalPair).\n\t\tif d.Label() != \"data\" {\n\t\t\treturn\n\t\t}\n\t\tdcAnswer = d\n\t\tclose(answerDataChannelOpened)\n\t})\n\n\tdcOffer, err := pcOffer.CreateDataChannel(\"data\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tofferDataChannelOpened := make(chan struct{})\n\tdcOffer.OnOpen(func() {\n\t\tclose(offerDataChannelOpened)\n\t})\n\n\terr = signalPair(pcOffer, pcAnswer)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t<-offerDataChannelOpened\n\t<-answerDataChannelOpened\n\n\tmsgNum := 0\n\tdcOffer.OnMessage(func(_ DataChannelMessage) {\n\t\tt.Log(\"msg\", msgNum)\n\t\tmsgNum++\n\t})\n\n\t// send 50 messages, then close pcOffer, and then send another 50\n\tfor i := 0; i < 100; i++ {\n\t\tif i == 50 {\n\t\t\terr = pcOffer.GracefulClose()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\t_ = dcAnswer.Send([]byte(\"hello!\"))\n\t}\n\n\terr = pcAnswer.GracefulClose()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestPeerConnection_GracefulCloseWhileOpening(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 5)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutinesStrict(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err = pcOffer.CreateDataChannel(\"initial_data_channel\", nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\tif err = pcOffer.SetLocalDescription(offer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t<-offerGatheringComplete\n\n\terr = pcOffer.GracefulClose()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = pcAnswer.SetRemoteDescription(offer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = pcAnswer.GracefulClose()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestPeerConnection_GracefulCloseConcurrent(t *testing.T) {\n\t// Limit runtime in case of deadlocks\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\tfor _, mixed := range []bool{false, true} {\n\t\tt.Run(fmt.Sprintf(\"mixed_graceful=%t\", mixed), func(t *testing.T) {\n\t\t\treport := test.CheckRoutinesStrict(t)\n\t\t\tdefer report()\n\n\t\t\tpc, err := NewPeerConnection(Configuration{})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tconst gracefulCloseConcurrency = 50\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(gracefulCloseConcurrency)\n\t\t\tfor i := 0; i < gracefulCloseConcurrency; i++ {\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\tassert.NoError(t, pc.GracefulClose())\n\t\t\t\t}()\n\t\t\t}\n\t\t\tif !mixed {\n\t\t\t\tif err := pc.Close(); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err := pc.GracefulClose(); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\twg.Wait()\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "peerconnection_go_test.go",
          "type": "blob",
          "size": 54.3466796875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/dtls/v3\"\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/transport/v3/vnet\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// newPair creates two new peer connections (an offerer and an answerer) using\n// the api.\nfunc (api *API) newPair(cfg Configuration) (pcOffer *PeerConnection, pcAnswer *PeerConnection, err error) {\n\tpca, err := api.NewPeerConnection(cfg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpcb, err := api.NewPeerConnection(cfg)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn pca, pcb, nil\n}\n\nfunc TestNew_Go(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tapi := NewAPI()\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\tsecretKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\tassert.Nil(t, err)\n\n\t\tcertificate, err := GenerateCertificate(secretKey)\n\t\tassert.Nil(t, err)\n\n\t\tpc, err := api.NewPeerConnection(Configuration{\n\t\t\tICEServers: []ICEServer{\n\t\t\t\t{\n\t\t\t\t\tURLs: []string{\n\t\t\t\t\t\t\"stun:stun.l.google.com:19302\",\n\t\t\t\t\t\t\"turns:google.de?transport=tcp\",\n\t\t\t\t\t},\n\t\t\t\t\tUsername: \"unittest\",\n\t\t\t\t\tCredential: OAuthCredential{\n\t\t\t\t\t\tMACKey:      \"WmtzanB3ZW9peFhtdm42NzUzNG0=\",\n\t\t\t\t\t\tAccessToken: \"AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ==\",\n\t\t\t\t\t},\n\t\t\t\t\tCredentialType: ICECredentialTypeOauth,\n\t\t\t\t},\n\t\t\t},\n\t\t\tICETransportPolicy:   ICETransportPolicyRelay,\n\t\t\tBundlePolicy:         BundlePolicyMaxCompat,\n\t\t\tRTCPMuxPolicy:        RTCPMuxPolicyNegotiate,\n\t\t\tPeerIdentity:         \"unittest\",\n\t\t\tCertificates:         []Certificate{*certificate},\n\t\t\tICECandidatePoolSize: 5,\n\t\t})\n\t\tassert.Nil(t, err)\n\t\tassert.NotNil(t, pc)\n\t\tassert.NoError(t, pc.Close())\n\t})\n\tt.Run(\"Failure\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\tinitialize  func() (*PeerConnection, error)\n\t\t\texpectedErr error\n\t\t}{\n\t\t\t{func() (*PeerConnection, error) {\n\t\t\t\tsecretKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\t\t\t\tassert.Nil(t, err)\n\n\t\t\t\tcertificate, err := NewCertificate(secretKey, x509.Certificate{\n\t\t\t\t\tVersion:      2,\n\t\t\t\t\tSerialNumber: big.NewInt(1653),\n\t\t\t\t\tNotBefore:    time.Now().AddDate(0, -2, 0),\n\t\t\t\t\tNotAfter:     time.Now().AddDate(0, -1, 0),\n\t\t\t\t})\n\t\t\t\tassert.Nil(t, err)\n\n\t\t\t\treturn api.NewPeerConnection(Configuration{\n\t\t\t\t\tCertificates: []Certificate{*certificate},\n\t\t\t\t})\n\t\t\t}, &rtcerr.InvalidAccessError{Err: ErrCertificateExpired}},\n\t\t\t{func() (*PeerConnection, error) {\n\t\t\t\treturn api.NewPeerConnection(Configuration{\n\t\t\t\t\tICEServers: []ICEServer{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURLs: []string{\n\t\t\t\t\t\t\t\t\"stun:stun.l.google.com:19302\",\n\t\t\t\t\t\t\t\t\"turns:google.de?transport=tcp\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUsername: \"unittest\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}, &rtcerr.InvalidAccessError{Err: ErrNoTurnCredentials}},\n\t\t}\n\n\t\tfor i, testCase := range testCases {\n\t\t\tpc, err := testCase.initialize()\n\t\t\tassert.EqualError(t, err, testCase.expectedErr.Error(),\n\t\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t\t)\n\t\t\tif pc != nil {\n\t\t\t\tassert.NoError(t, pc.Close())\n\t\t\t}\n\t\t}\n\t})\n\tt.Run(\"ICEServers_Copy\", func(t *testing.T) {\n\t\tconst expectedURL = \"stun:stun.l.google.com:19302?foo=bar\"\n\t\tconst expectedUsername = \"username\"\n\t\tconst expectedPassword = \"password\"\n\n\t\tcfg := Configuration{\n\t\t\tICEServers: []ICEServer{\n\t\t\t\t{\n\t\t\t\t\tURLs:       []string{expectedURL},\n\t\t\t\t\tUsername:   expectedUsername,\n\t\t\t\t\tCredential: expectedPassword,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tpc, err := api.NewPeerConnection(cfg)\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, pc)\n\n\t\tpc.configuration.ICEServers[0].Username = util.MathRandAlpha(15) // Tests doesn't need crypto random\n\t\tpc.configuration.ICEServers[0].Credential = util.MathRandAlpha(15)\n\t\tpc.configuration.ICEServers[0].URLs[0] = util.MathRandAlpha(15)\n\n\t\tassert.Equal(t, expectedUsername, cfg.ICEServers[0].Username)\n\t\tassert.Equal(t, expectedPassword, cfg.ICEServers[0].Credential)\n\t\tassert.Equal(t, expectedURL, cfg.ICEServers[0].URLs[0])\n\n\t\tassert.NoError(t, pc.Close())\n\t})\n}\n\nfunc TestPeerConnection_SetConfiguration_Go(t *testing.T) {\n\t// Note: this test includes all SetConfiguration features that are supported\n\t// by Go but not the WASM bindings, namely: ICEServer.Credential,\n\t// ICEServer.CredentialType, and Certificates.\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tapi := NewAPI()\n\n\tsecretKey1, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\n\tcertificate1, err := GenerateCertificate(secretKey1)\n\tassert.Nil(t, err)\n\n\tsecretKey2, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.Nil(t, err)\n\n\tcertificate2, err := GenerateCertificate(secretKey2)\n\tassert.Nil(t, err)\n\n\tfor _, test := range []struct {\n\t\tname    string\n\t\tinit    func() (*PeerConnection, error)\n\t\tconfig  Configuration\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname: \"valid\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\tpc, err := api.NewPeerConnection(Configuration{\n\t\t\t\t\tPeerIdentity:         \"unittest\",\n\t\t\t\t\tCertificates:         []Certificate{*certificate1},\n\t\t\t\t\tICECandidatePoolSize: 5,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn pc, err\n\t\t\t\t}\n\n\t\t\t\terr = pc.SetConfiguration(Configuration{\n\t\t\t\t\tICEServers: []ICEServer{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURLs: []string{\n\t\t\t\t\t\t\t\t\"stun:stun.l.google.com:19302\",\n\t\t\t\t\t\t\t\t\"turns:google.de?transport=tcp\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUsername: \"unittest\",\n\t\t\t\t\t\t\tCredential: OAuthCredential{\n\t\t\t\t\t\t\t\tMACKey:      \"WmtzanB3ZW9peFhtdm42NzUzNG0=\",\n\t\t\t\t\t\t\t\tAccessToken: \"AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ==\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tCredentialType: ICECredentialTypeOauth,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tICETransportPolicy:   ICETransportPolicyAll,\n\t\t\t\t\tBundlePolicy:         BundlePolicyBalanced,\n\t\t\t\t\tRTCPMuxPolicy:        RTCPMuxPolicyRequire,\n\t\t\t\t\tPeerIdentity:         \"unittest\",\n\t\t\t\t\tCertificates:         []Certificate{*certificate1},\n\t\t\t\t\tICECandidatePoolSize: 5,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn pc, err\n\t\t\t\t}\n\n\t\t\t\treturn pc, nil\n\t\t\t},\n\t\t\tconfig:  Configuration{},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"update multiple certificates\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\treturn api.NewPeerConnection(Configuration{})\n\t\t\t},\n\t\t\tconfig: Configuration{\n\t\t\t\tCertificates: []Certificate{*certificate1, *certificate2},\n\t\t\t},\n\t\t\twantErr: &rtcerr.InvalidModificationError{Err: ErrModifyingCertificates},\n\t\t},\n\t\t{\n\t\t\tname: \"update certificate\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\treturn api.NewPeerConnection(Configuration{})\n\t\t\t},\n\t\t\tconfig: Configuration{\n\t\t\t\tCertificates: []Certificate{*certificate1},\n\t\t\t},\n\t\t\twantErr: &rtcerr.InvalidModificationError{Err: ErrModifyingCertificates},\n\t\t},\n\t\t{\n\t\t\tname: \"update ICEServers, no TURN credentials\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\treturn NewPeerConnection(Configuration{})\n\t\t\t},\n\t\t\tconfig: Configuration{\n\t\t\t\tICEServers: []ICEServer{\n\t\t\t\t\t{\n\t\t\t\t\t\tURLs: []string{\n\t\t\t\t\t\t\t\"stun:stun.l.google.com:19302\",\n\t\t\t\t\t\t\t\"turns:google.de?transport=tcp\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tUsername: \"unittest\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: &rtcerr.InvalidAccessError{Err: ErrNoTurnCredentials},\n\t\t},\n\t} {\n\t\tpc, err := test.init()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"SetConfiguration %q: init failed: %v\", test.name, err)\n\t\t}\n\n\t\terr = pc.SetConfiguration(test.config)\n\t\tif got, want := err, test.wantErr; !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"SetConfiguration %q: err = %v, want %v\", test.name, got, want)\n\t\t}\n\n\t\tassert.NoError(t, pc.Close())\n\t}\n}\n\nfunc TestPeerConnection_EventHandlers_Go(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 5)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\t// Note: When testing the Go event handlers we peer into the state a bit more\n\t// than what is possible for the environment agnostic (Go or WASM/JavaScript)\n\t// EventHandlers test.\n\tapi := NewAPI()\n\tpc, err := api.NewPeerConnection(Configuration{})\n\tassert.Nil(t, err)\n\n\tonTrackCalled := make(chan struct{})\n\tonICEConnectionStateChangeCalled := make(chan struct{})\n\tonDataChannelCalled := make(chan struct{})\n\n\t// Verify that the noop case works\n\tassert.NotPanics(t, func() { pc.onTrack(nil, nil) })\n\tassert.NotPanics(t, func() { pc.onICEConnectionStateChange(ICEConnectionStateNew) })\n\n\tpc.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\tclose(onTrackCalled)\n\t})\n\n\tpc.OnICEConnectionStateChange(func(ICEConnectionState) {\n\t\tclose(onICEConnectionStateChangeCalled)\n\t})\n\n\tpc.OnDataChannel(func(dc *DataChannel) {\n\t\t// Questions:\n\t\t//  (1) How come this callback is made with dc being nil?\n\t\t//  (2) How come this callback is made without CreateDataChannel?\n\t\tif dc != nil {\n\t\t\tclose(onDataChannelCalled)\n\t\t}\n\t})\n\n\t// Verify that the handlers deal with nil inputs\n\tassert.NotPanics(t, func() { pc.onTrack(nil, nil) })\n\tassert.NotPanics(t, func() { go pc.onDataChannelHandler(nil) })\n\n\t// Verify that the set handlers are called\n\tassert.NotPanics(t, func() { pc.onTrack(&TrackRemote{}, &RTPReceiver{}) })\n\tassert.NotPanics(t, func() { pc.onICEConnectionStateChange(ICEConnectionStateNew) })\n\tassert.NotPanics(t, func() { go pc.onDataChannelHandler(&DataChannel{api: api}) })\n\n\t<-onTrackCalled\n\t<-onICEConnectionStateChangeCalled\n\t<-onDataChannelCalled\n\tassert.NoError(t, pc.Close())\n}\n\n// This test asserts that nothing deadlocks we try to shutdown when DTLS is in flight\n// We ensure that DTLS is in flight by removing the mux func for it, so all inbound DTLS is lost\nfunc TestPeerConnection_ShutdownNoDTLS(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tapi := NewAPI()\n\tofferPC, answerPC, err := api.newPair(Configuration{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Drop all incoming DTLS traffic\n\tdropAllDTLS := func([]byte) bool {\n\t\treturn false\n\t}\n\tofferPC.dtlsTransport.dtlsMatcher = dropAllDTLS\n\tanswerPC.dtlsTransport.dtlsMatcher = dropAllDTLS\n\n\tif err = signalPair(offerPC, answerPC); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ticeComplete := make(chan interface{})\n\tanswerPC.OnICEConnectionStateChange(func(iceState ICEConnectionState) {\n\t\tif iceState == ICEConnectionStateConnected {\n\t\t\ttime.Sleep(time.Second) // Give time for DTLS to start\n\n\t\t\tselect {\n\t\t\tcase <-iceComplete:\n\t\t\tdefault:\n\t\t\t\tclose(iceComplete)\n\t\t\t}\n\t\t}\n\t})\n\n\t<-iceComplete\n\tclosePairNow(t, offerPC, answerPC)\n}\n\nfunc TestPeerConnection_PropertyGetters(t *testing.T) {\n\tpc := &PeerConnection{\n\t\tcurrentLocalDescription:  &SessionDescription{},\n\t\tpendingLocalDescription:  &SessionDescription{},\n\t\tcurrentRemoteDescription: &SessionDescription{},\n\t\tpendingRemoteDescription: &SessionDescription{},\n\t\tsignalingState:           SignalingStateHaveLocalOffer,\n\t}\n\tpc.iceConnectionState.Store(ICEConnectionStateChecking)\n\tpc.connectionState.Store(PeerConnectionStateConnecting)\n\n\tassert.Equal(t, pc.currentLocalDescription, pc.CurrentLocalDescription(), \"should match\")\n\tassert.Equal(t, pc.pendingLocalDescription, pc.PendingLocalDescription(), \"should match\")\n\tassert.Equal(t, pc.currentRemoteDescription, pc.CurrentRemoteDescription(), \"should match\")\n\tassert.Equal(t, pc.pendingRemoteDescription, pc.PendingRemoteDescription(), \"should match\")\n\tassert.Equal(t, pc.signalingState, pc.SignalingState(), \"should match\")\n\tassert.Equal(t, pc.iceConnectionState.Load(), pc.ICEConnectionState(), \"should match\")\n\tassert.Equal(t, pc.connectionState.Load(), pc.ConnectionState(), \"should match\")\n}\n\nfunc TestPeerConnection_AnswerWithoutOffer(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Errorf(\"New PeerConnection: got error: %v\", err)\n\t}\n\t_, err = pc.CreateAnswer(nil)\n\tif !reflect.DeepEqual(&rtcerr.InvalidStateError{Err: ErrNoRemoteDescription}, err) {\n\t\tt.Errorf(\"CreateAnswer without RemoteDescription: got error: %v\", err)\n\t}\n\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestPeerConnection_AnswerWithClosedConnection(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tofferPeerConn, answerPeerConn, err := newPair()\n\tassert.NoError(t, err)\n\n\tinChecking, inCheckingCancel := context.WithCancel(context.Background())\n\tanswerPeerConn.OnICEConnectionStateChange(func(i ICEConnectionState) {\n\t\tif i == ICEConnectionStateChecking {\n\t\t\tinCheckingCancel()\n\t\t}\n\t})\n\n\t_, err = offerPeerConn.CreateDataChannel(\"test-channel\", nil)\n\tassert.NoError(t, err)\n\n\toffer, err := offerPeerConn.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, offerPeerConn.SetLocalDescription(offer))\n\n\tassert.NoError(t, offerPeerConn.Close())\n\n\tassert.NoError(t, answerPeerConn.SetRemoteDescription(offer))\n\n\t<-inChecking.Done()\n\tassert.NoError(t, answerPeerConn.Close())\n\n\t_, err = answerPeerConn.CreateAnswer(nil)\n\tassert.Equal(t, err, &rtcerr.InvalidStateError{Err: ErrConnectionClosed})\n}\n\nfunc TestPeerConnection_satisfyTypeAndDirection(t *testing.T) {\n\tcreateTransceiver := func(kind RTPCodecType, direction RTPTransceiverDirection) *RTPTransceiver {\n\t\tr := &RTPTransceiver{kind: kind}\n\t\tr.setDirection(direction)\n\n\t\treturn r\n\t}\n\n\tfor _, test := range []struct {\n\t\tname string\n\n\t\tkinds      []RTPCodecType\n\t\tdirections []RTPTransceiverDirection\n\n\t\tlocalTransceivers []*RTPTransceiver\n\t\twant              []*RTPTransceiver\n\t}{\n\t\t{\n\t\t\t\"Audio and Video Transceivers can not satisfy each other\",\n\t\t\t[]RTPCodecType{RTPCodecTypeVideo},\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendrecv},\n\t\t\t[]*RTPTransceiver{createTransceiver(RTPCodecTypeAudio, RTPTransceiverDirectionSendrecv)},\n\t\t\t[]*RTPTransceiver{nil},\n\t\t},\n\t\t{\n\t\t\t\"No local Transceivers, every remote should get nil\",\n\t\t\t[]RTPCodecType{RTPCodecTypeVideo, RTPCodecTypeAudio, RTPCodecTypeVideo, RTPCodecTypeVideo},\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendrecv, RTPTransceiverDirectionRecvonly, RTPTransceiverDirectionSendonly, RTPTransceiverDirectionInactive},\n\n\t\t\t[]*RTPTransceiver{},\n\n\t\t\t[]*RTPTransceiver{\n\t\t\t\tnil,\n\t\t\t\tnil,\n\t\t\t\tnil,\n\t\t\t\tnil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Local Recv can satisfy remote SendRecv\",\n\t\t\t[]RTPCodecType{RTPCodecTypeVideo},\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendrecv},\n\n\t\t\t[]*RTPTransceiver{createTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly)},\n\n\t\t\t[]*RTPTransceiver{createTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly)},\n\t\t},\n\t\t{\n\t\t\t\"Don't satisfy a Sendonly with a SendRecv, later SendRecv will be marked as Inactive\",\n\t\t\t[]RTPCodecType{RTPCodecTypeVideo, RTPCodecTypeVideo},\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendonly, RTPTransceiverDirectionSendrecv},\n\n\t\t\t[]*RTPTransceiver{\n\t\t\t\tcreateTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionSendrecv),\n\t\t\t\tcreateTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly),\n\t\t\t},\n\n\t\t\t[]*RTPTransceiver{\n\t\t\t\tcreateTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly),\n\t\t\t\tcreateTransceiver(RTPCodecTypeVideo, RTPTransceiverDirectionSendrecv),\n\t\t\t},\n\t\t},\n\t} {\n\t\tif len(test.kinds) != len(test.directions) {\n\t\t\tt.Fatal(\"Kinds and Directions must be the same length\")\n\t\t}\n\n\t\tgot := []*RTPTransceiver{}\n\t\tfor i := range test.kinds {\n\t\t\tres, filteredLocalTransceivers := satisfyTypeAndDirection(test.kinds[i], test.directions[i], test.localTransceivers)\n\n\t\t\tgot = append(got, res)\n\t\t\ttest.localTransceivers = filteredLocalTransceivers\n\t\t}\n\n\t\tif !reflect.DeepEqual(got, test.want) {\n\t\t\tgotStr := \"\"\n\t\t\tfor _, t := range got {\n\t\t\t\tgotStr += fmt.Sprintf(\"%+v\\n\", t)\n\t\t\t}\n\n\t\t\twantStr := \"\"\n\t\t\tfor _, t := range test.want {\n\t\t\t\twantStr += fmt.Sprintf(\"%+v\\n\", t)\n\t\t\t}\n\t\t\tt.Errorf(\"satisfyTypeAndDirection %q: \\ngot\\n%s \\nwant\\n%s\", test.name, gotStr, wantStr)\n\t\t}\n\t}\n}\n\nfunc TestOneAttrKeyConnectionSetupPerMediaDescriptionInSDP(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTransceiverFromKind(RTPCodecTypeAudio)\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTransceiverFromKind(RTPCodecTypeAudio)\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tsdp, err := pc.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tre := regexp.MustCompile(`a=setup:[[:alpha:]]+`)\n\n\tmatches := re.FindAllStringIndex(sdp.SDP, -1)\n\n\tassert.Len(t, matches, 4)\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestPeerConnection_IceLite(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\tconnectTwoAgents := func(offerIsLite, answerisLite bool) {\n\t\tofferSettingEngine := SettingEngine{}\n\t\tofferSettingEngine.SetLite(offerIsLite)\n\t\tofferPC, err := NewAPI(WithSettingEngine(offerSettingEngine)).NewPeerConnection(Configuration{})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tanswerSettingEngine := SettingEngine{}\n\t\tanswerSettingEngine.SetLite(answerisLite)\n\t\tanswerPC, err := NewAPI(WithSettingEngine(answerSettingEngine)).NewPeerConnection(Configuration{})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err = signalPair(offerPC, answerPC); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tdataChannelOpen := make(chan interface{})\n\t\tanswerPC.OnDataChannel(func(_ *DataChannel) {\n\t\t\tclose(dataChannelOpen)\n\t\t})\n\n\t\t<-dataChannelOpen\n\t\tclosePairNow(t, offerPC, answerPC)\n\t}\n\n\tt.Run(\"Offerer\", func(*testing.T) {\n\t\tconnectTwoAgents(true, false)\n\t})\n\n\tt.Run(\"Answerer\", func(*testing.T) {\n\t\tconnectTwoAgents(false, true)\n\t})\n\n\tt.Run(\"Both\", func(*testing.T) {\n\t\tconnectTwoAgents(true, true)\n\t})\n}\n\nfunc TestOnICEGatheringStateChange(t *testing.T) {\n\tseenGathering := &atomicBool{}\n\tseenComplete := &atomicBool{}\n\n\tseenGatheringAndComplete := make(chan interface{})\n\n\tpeerConn, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tvar onStateChange func(s ICEGatheringState)\n\tonStateChange = func(s ICEGatheringState) {\n\t\t// Access to ICEGatherer in the callback must not cause dead lock.\n\t\tpeerConn.OnICEGatheringStateChange(onStateChange)\n\n\t\tswitch s { // nolint:exhaustive\n\t\tcase ICEGatheringStateGathering:\n\t\t\tif seenComplete.get() {\n\t\t\t\tt.Error(\"Completed before gathering\")\n\t\t\t}\n\t\t\tseenGathering.set(true)\n\t\tcase ICEGatheringStateComplete:\n\t\t\tseenComplete.set(true)\n\t\t}\n\n\t\tif seenGathering.get() && seenComplete.get() {\n\t\t\tclose(seenGatheringAndComplete)\n\t\t}\n\t}\n\tpeerConn.OnICEGatheringStateChange(onStateChange)\n\n\toffer, err := peerConn.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, peerConn.SetLocalDescription(offer))\n\n\tselect {\n\tcase <-time.After(time.Second * 10):\n\t\tt.Fatal(\"Gathering and Complete were never seen\")\n\tcase <-seenGatheringAndComplete:\n\t}\n\n\tassert.NoError(t, peerConn.Close())\n}\n\n// Assert Trickle ICE behaviors\nfunc TestPeerConnectionTrickle(t *testing.T) {\n\tofferPC, answerPC, err := newPair()\n\tassert.NoError(t, err)\n\n\t_, err = offerPC.CreateDataChannel(\"test-channel\", nil)\n\tassert.NoError(t, err)\n\n\taddOrCacheCandidate := func(pc *PeerConnection, c *ICECandidate, candidateCache []ICECandidateInit) []ICECandidateInit {\n\t\tif c == nil {\n\t\t\treturn candidateCache\n\t\t}\n\n\t\tif pc.RemoteDescription() == nil {\n\t\t\treturn append(candidateCache, c.ToJSON())\n\t\t}\n\n\t\tassert.NoError(t, pc.AddICECandidate(c.ToJSON()))\n\t\treturn candidateCache\n\t}\n\n\tcandidateLock := sync.RWMutex{}\n\tvar offerCandidateDone, answerCandidateDone bool\n\n\tcachedOfferCandidates := []ICECandidateInit{}\n\tofferPC.OnICECandidate(func(c *ICECandidate) {\n\t\tif offerCandidateDone {\n\t\t\tt.Error(\"Received OnICECandidate after finishing gathering\")\n\t\t}\n\t\tif c == nil {\n\t\t\tofferCandidateDone = true\n\t\t}\n\n\t\tcandidateLock.Lock()\n\t\tdefer candidateLock.Unlock()\n\n\t\tcachedOfferCandidates = addOrCacheCandidate(answerPC, c, cachedOfferCandidates)\n\t})\n\n\tcachedAnswerCandidates := []ICECandidateInit{}\n\tanswerPC.OnICECandidate(func(c *ICECandidate) {\n\t\tif answerCandidateDone {\n\t\t\tt.Error(\"Received OnICECandidate after finishing gathering\")\n\t\t}\n\t\tif c == nil {\n\t\t\tanswerCandidateDone = true\n\t\t}\n\n\t\tcandidateLock.Lock()\n\t\tdefer candidateLock.Unlock()\n\n\t\tcachedAnswerCandidates = addOrCacheCandidate(offerPC, c, cachedAnswerCandidates)\n\t})\n\n\tofferPCConnected, offerPCConnectedCancel := context.WithCancel(context.Background())\n\tofferPC.OnICEConnectionStateChange(func(i ICEConnectionState) {\n\t\tif i == ICEConnectionStateConnected {\n\t\t\tofferPCConnectedCancel()\n\t\t}\n\t})\n\n\tanswerPCConnected, answerPCConnectedCancel := context.WithCancel(context.Background())\n\tanswerPC.OnICEConnectionStateChange(func(i ICEConnectionState) {\n\t\tif i == ICEConnectionStateConnected {\n\t\t\tanswerPCConnectedCancel()\n\t\t}\n\t})\n\n\toffer, err := offerPC.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, offerPC.SetLocalDescription(offer))\n\tassert.NoError(t, answerPC.SetRemoteDescription(offer))\n\n\tanswer, err := answerPC.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, answerPC.SetLocalDescription(answer))\n\tassert.NoError(t, offerPC.SetRemoteDescription(answer))\n\n\tcandidateLock.Lock()\n\tfor _, c := range cachedAnswerCandidates {\n\t\tassert.NoError(t, offerPC.AddICECandidate(c))\n\t}\n\tfor _, c := range cachedOfferCandidates {\n\t\tassert.NoError(t, answerPC.AddICECandidate(c))\n\t}\n\tcandidateLock.Unlock()\n\n\t<-answerPCConnected.Done()\n\t<-offerPCConnected.Done()\n\tclosePairNow(t, offerPC, answerPC)\n}\n\n// Issue #1121, assert populateLocalCandidates doesn't mutate\nfunc TestPopulateLocalCandidates(t *testing.T) {\n\tt.Run(\"PendingLocalDescription shouldn't add extra mutations\", func(t *testing.T) {\n\t\tpc, err := NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\toffer, err := pc.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tofferGatheringComplete := GatheringCompletePromise(pc)\n\t\tassert.NoError(t, pc.SetLocalDescription(offer))\n\t\t<-offerGatheringComplete\n\n\t\tassert.Equal(t, pc.PendingLocalDescription(), pc.PendingLocalDescription())\n\t\tassert.NoError(t, pc.Close())\n\t})\n\n\tt.Run(\"end-of-candidates only when gathering is complete\", func(t *testing.T) {\n\t\tpc, err := NewAPI().NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pc.CreateDataChannel(\"test-channel\", nil)\n\t\tassert.NoError(t, err)\n\n\t\toffer, err := pc.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\t\tassert.NotContains(t, offer.SDP, \"a=candidate\")\n\t\tassert.NotContains(t, offer.SDP, \"a=end-of-candidates\")\n\n\t\tofferGatheringComplete := GatheringCompletePromise(pc)\n\t\tassert.NoError(t, pc.SetLocalDescription(offer))\n\t\t<-offerGatheringComplete\n\n\t\tassert.Contains(t, pc.PendingLocalDescription().SDP, \"a=candidate\")\n\t\tassert.Contains(t, pc.PendingLocalDescription().SDP, \"a=end-of-candidates\")\n\n\t\tassert.NoError(t, pc.Close())\n\t})\n}\n\n// Assert that two agents that only generate mDNS candidates can connect\nfunc TestMulticastDNSCandidates(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ts := SettingEngine{}\n\ts.SetICEMulticastDNSMode(ice.MulticastDNSModeQueryAndGather)\n\n\tpcOffer, pcAnswer, err := NewAPI(WithSettingEngine(s)).newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tonDataChannel, onDataChannelCancel := context.WithCancel(context.Background())\n\tpcAnswer.OnDataChannel(func(*DataChannel) {\n\t\tonDataChannelCancel()\n\t})\n\t<-onDataChannel.Done()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestICERestart(t *testing.T) {\n\textractCandidates := func(sdp string) (candidates []string) {\n\t\tsc := bufio.NewScanner(strings.NewReader(sdp))\n\t\tfor sc.Scan() {\n\t\t\tif strings.HasPrefix(sc.Text(), \"a=candidate:\") {\n\t\t\t\tcandidates = append(candidates, sc.Text())\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t}\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tofferPC, answerPC, err := newPair()\n\tassert.NoError(t, err)\n\n\tvar connectedWaitGroup sync.WaitGroup\n\tconnectedWaitGroup.Add(2)\n\n\tofferPC.OnICEConnectionStateChange(func(state ICEConnectionState) {\n\t\tif state == ICEConnectionStateConnected {\n\t\t\tconnectedWaitGroup.Done()\n\t\t}\n\t})\n\tanswerPC.OnICEConnectionStateChange(func(state ICEConnectionState) {\n\t\tif state == ICEConnectionStateConnected {\n\t\t\tconnectedWaitGroup.Done()\n\t\t}\n\t})\n\n\t// Connect two PeerConnections and block until ICEConnectionStateConnected\n\tassert.NoError(t, signalPair(offerPC, answerPC))\n\tconnectedWaitGroup.Wait()\n\n\t// Store candidates from first Offer/Answer, compare later to make sure we re-gathered\n\tfirstOfferCandidates := extractCandidates(offerPC.LocalDescription().SDP)\n\tfirstAnswerCandidates := extractCandidates(answerPC.LocalDescription().SDP)\n\n\t// Use Trickle ICE for ICE Restart\n\tofferPC.OnICECandidate(func(c *ICECandidate) {\n\t\tif c != nil {\n\t\t\tassert.NoError(t, answerPC.AddICECandidate(c.ToJSON()))\n\t\t}\n\t})\n\n\tanswerPC.OnICECandidate(func(c *ICECandidate) {\n\t\tif c != nil {\n\t\t\tassert.NoError(t, offerPC.AddICECandidate(c.ToJSON()))\n\t\t}\n\t})\n\n\t// Re-signal with ICE Restart, block until ICEConnectionStateConnected\n\tconnectedWaitGroup.Add(2)\n\toffer, err := offerPC.CreateOffer(&OfferOptions{ICERestart: true})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, offerPC.SetLocalDescription(offer))\n\tassert.NoError(t, answerPC.SetRemoteDescription(offer))\n\n\tanswer, err := answerPC.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, answerPC.SetLocalDescription(answer))\n\tassert.NoError(t, offerPC.SetRemoteDescription(answer))\n\n\t// Block until we have connected again\n\tconnectedWaitGroup.Wait()\n\n\t// Compare ICE Candidates across each run, fail if they haven't changed\n\tassert.NotEqual(t, firstOfferCandidates, extractCandidates(offerPC.LocalDescription().SDP))\n\tassert.NotEqual(t, firstAnswerCandidates, extractCandidates(answerPC.LocalDescription().SDP))\n\tclosePairNow(t, offerPC, answerPC)\n}\n\n// Assert error handling when an Agent is restart\nfunc TestICERestart_Error_Handling(t *testing.T) {\n\ticeStates := make(chan ICEConnectionState, 100)\n\tblockUntilICEState := func(wantedState ICEConnectionState) {\n\t\tstateCount := 0\n\t\tfor i := range iceStates {\n\t\t\tif i == wantedState {\n\t\t\t\tstateCount++\n\t\t\t}\n\n\t\t\tif stateCount == 2 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tconnectWithICERestart := func(offerPeerConnection, answerPeerConnection *PeerConnection) {\n\t\toffer, err := offerPeerConnection.CreateOffer(&OfferOptions{ICERestart: true})\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, offerPeerConnection.SetLocalDescription(offer))\n\t\tassert.NoError(t, answerPeerConnection.SetRemoteDescription(*offerPeerConnection.LocalDescription()))\n\n\t\tanswer, err := answerPeerConnection.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, answerPeerConnection.SetLocalDescription(answer))\n\t\tassert.NoError(t, offerPeerConnection.SetRemoteDescription(*answerPeerConnection.LocalDescription()))\n\t}\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tofferPeerConnection, answerPeerConnection, wan := createVNetPair(t, nil)\n\n\tpushICEState := func(i ICEConnectionState) { iceStates <- i }\n\tofferPeerConnection.OnICEConnectionStateChange(pushICEState)\n\tanswerPeerConnection.OnICEConnectionStateChange(pushICEState)\n\n\tkeepPackets := &atomicBool{}\n\tkeepPackets.set(true)\n\n\t// Add a filter that monitors the traffic on the router\n\twan.AddChunkFilter(func(vnet.Chunk) bool {\n\t\treturn keepPackets.get()\n\t})\n\n\tconst testMessage = \"testMessage\"\n\n\td, err := answerPeerConnection.CreateDataChannel(\"foo\", nil)\n\tassert.NoError(t, err)\n\n\tdataChannelMessages := make(chan string, 100)\n\td.OnMessage(func(m DataChannelMessage) {\n\t\tdataChannelMessages <- string(m.Data)\n\t})\n\n\tdataChannelAnswerer := make(chan *DataChannel)\n\tofferPeerConnection.OnDataChannel(func(d *DataChannel) {\n\t\td.OnOpen(func() {\n\t\t\tdataChannelAnswerer <- d\n\t\t})\n\t})\n\n\t// Connect and Assert we have connected\n\tassert.NoError(t, signalPair(offerPeerConnection, answerPeerConnection))\n\tblockUntilICEState(ICEConnectionStateConnected)\n\n\tofferPeerConnection.OnICECandidate(func(c *ICECandidate) {\n\t\tif c != nil {\n\t\t\tassert.NoError(t, answerPeerConnection.AddICECandidate(c.ToJSON()))\n\t\t}\n\t})\n\n\tanswerPeerConnection.OnICECandidate(func(c *ICECandidate) {\n\t\tif c != nil {\n\t\t\tassert.NoError(t, offerPeerConnection.AddICECandidate(c.ToJSON()))\n\t\t}\n\t})\n\n\tdataChannel := <-dataChannelAnswerer\n\tassert.NoError(t, dataChannel.SendText(testMessage))\n\tassert.Equal(t, testMessage, <-dataChannelMessages)\n\n\t// Drop all packets, assert we have disconnected\n\t// and send a DataChannel message when disconnected\n\tkeepPackets.set(false)\n\tblockUntilICEState(ICEConnectionStateFailed)\n\tassert.NoError(t, dataChannel.SendText(testMessage))\n\n\t// ICE Restart and assert we have reconnected\n\t// block until our DataChannel message is delivered\n\tkeepPackets.set(true)\n\tconnectWithICERestart(offerPeerConnection, answerPeerConnection)\n\tblockUntilICEState(ICEConnectionStateConnected)\n\tassert.Equal(t, testMessage, <-dataChannelMessages)\n\n\tassert.NoError(t, wan.Stop())\n\tclosePairNow(t, offerPeerConnection, answerPeerConnection)\n}\n\ntype trackRecords struct {\n\tmu               sync.Mutex\n\ttrackIDs         map[string]struct{}\n\treceivedTrackIDs map[string]struct{}\n}\n\nfunc (r *trackRecords) newTrack() (*TrackLocalStaticRTP, error) {\n\ttrackID := fmt.Sprintf(\"pion-track-%d\", len(r.trackIDs))\n\ttrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, trackID, \"pion\")\n\tr.trackIDs[trackID] = struct{}{}\n\treturn track, err\n}\n\nfunc (r *trackRecords) handleTrack(t *TrackRemote, _ *RTPReceiver) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\ttID := t.ID()\n\tif _, exist := r.trackIDs[tID]; exist {\n\t\tr.receivedTrackIDs[tID] = struct{}{}\n\t}\n}\n\nfunc (r *trackRecords) remains() int {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\treturn len(r.trackIDs) - len(r.receivedTrackIDs)\n}\n\n// This test assure that all track events emits.\nfunc TestPeerConnection_MassiveTracks(t *testing.T) {\n\tvar (\n\t\ttRecs = &trackRecords{\n\t\t\ttrackIDs:         make(map[string]struct{}),\n\t\t\treceivedTrackIDs: make(map[string]struct{}),\n\t\t}\n\t\ttracks          = []*TrackLocalStaticRTP{}\n\t\ttrackCount      = 256\n\t\tpingInterval    = 1 * time.Second\n\t\tnoiseInterval   = 100 * time.Microsecond\n\t\ttimeoutDuration = 20 * time.Second\n\t\trawPkt          = []byte{\n\t\t\t0x90, 0xe0, 0x69, 0x8f, 0xd9, 0xc2, 0x93, 0xda, 0x1c, 0x64,\n\t\t\t0x27, 0x82, 0x00, 0x01, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0x98, 0x36, 0xbe, 0x88, 0x9e,\n\t\t}\n\t\tsamplePkt = &rtp.Packet{\n\t\t\tHeader: rtp.Header{\n\t\t\t\tMarker:           true,\n\t\t\t\tExtension:        false,\n\t\t\t\tExtensionProfile: 1,\n\t\t\t\tVersion:          2,\n\t\t\t\tSequenceNumber:   27023,\n\t\t\t\tTimestamp:        3653407706,\n\t\t\t\tCSRC:             []uint32{},\n\t\t\t},\n\t\t\tPayload: rawPkt[20:],\n\t\t}\n\t\tconnected = make(chan struct{})\n\t\tstopped   = make(chan struct{})\n\t)\n\tofferPC, answerPC, err := newPair()\n\tassert.NoError(t, err)\n\t// Create massive tracks.\n\tfor range make([]struct{}, trackCount) {\n\t\ttrack, err := tRecs.newTrack()\n\t\tassert.NoError(t, err)\n\t\t_, err = offerPC.AddTrack(track)\n\t\tassert.NoError(t, err)\n\t\ttracks = append(tracks, track)\n\t}\n\tanswerPC.OnTrack(tRecs.handleTrack)\n\tofferPC.OnICEConnectionStateChange(func(s ICEConnectionState) {\n\t\tif s == ICEConnectionStateConnected {\n\t\t\tclose(connected)\n\t\t}\n\t})\n\t// A routine to periodically call GetTransceivers. This action might cause\n\t// the deadlock and prevent track event to emit.\n\tgo func() {\n\t\tfor {\n\t\t\tanswerPC.GetTransceivers()\n\t\t\ttime.Sleep(noiseInterval)\n\t\t\tselect {\n\t\t\tcase <-stopped:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tassert.NoError(t, signalPair(offerPC, answerPC))\n\t// Send a RTP packets to each track to trigger track event after connected.\n\t<-connected\n\ttime.Sleep(1 * time.Second)\n\tfor _, track := range tracks {\n\t\tassert.NoError(t, track.WriteRTP(samplePkt))\n\t}\n\t// Ping trackRecords to see if any track event not received yet.\n\ttooLong := time.After(timeoutDuration)\n\tfor {\n\t\tremains := tRecs.remains()\n\t\tif remains == 0 {\n\t\t\tbreak\n\t\t}\n\t\tt.Log(\"remain tracks\", remains)\n\t\ttime.Sleep(pingInterval)\n\t\tselect {\n\t\tcase <-tooLong:\n\t\t\tt.Error(\"unable to receive all track events in time\")\n\t\tdefault:\n\t\t}\n\t}\n\tclose(stopped)\n\tclosePairNow(t, offerPC, answerPC)\n}\n\nfunc TestEmptyCandidate(t *testing.T) {\n\ttestCases := []struct {\n\t\tICECandidate ICECandidateInit\n\t\texpectError  bool\n\t}{\n\t\t{ICECandidateInit{\"\", nil, nil, nil}, false},\n\t\t{ICECandidateInit{\n\t\t\t\"211962667 1 udp 2122194687 10.0.3.1 40864 typ host generation 0\",\n\t\t\tnil, nil, nil,\n\t\t}, false},\n\t\t{ICECandidateInit{\n\t\t\t\"1234567\",\n\t\t\tnil, nil, nil,\n\t\t}, true},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tpeerConn, err := NewPeerConnection(Configuration{})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Case %d: got error: %v\", i, err)\n\t\t}\n\n\t\terr = peerConn.SetRemoteDescription(SessionDescription{Type: SDPTypeOffer, SDP: minimalOffer})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Case %d: got error: %v\", i, err)\n\t\t}\n\n\t\tif testCase.expectError {\n\t\t\tassert.Error(t, peerConn.AddICECandidate(testCase.ICECandidate))\n\t\t} else {\n\t\t\tassert.NoError(t, peerConn.AddICECandidate(testCase.ICECandidate))\n\t\t}\n\n\t\tassert.NoError(t, peerConn.Close())\n\t}\n}\n\nconst liteOffer = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=msid-semantic: WMS\na=ice-lite\nm=application 47299 DTLS/SCTP 5000\nc=IN IP4 192.168.20.129\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=mid:data\n`\n\n// this test asserts that if an ice-lite offer is received,\n// pion will take the ICE-CONTROLLING role\nfunc TestICELite(t *testing.T) {\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, peerConnection.SetRemoteDescription(\n\t\tSessionDescription{SDP: liteOffer, Type: SDPTypeOffer},\n\t))\n\n\tSDPAnswer, err := peerConnection.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, peerConnection.SetLocalDescription(SDPAnswer))\n\n\tassert.Equal(t, ICERoleControlling, peerConnection.iceTransport.Role(),\n\t\t\"pion did not set state to ICE-CONTROLLED against ice-light offer\")\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\nfunc TestPeerConnection_TransceiverDirection(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tcreateTransceiver := func(pc *PeerConnection, dir RTPTransceiverDirection) error {\n\t\t// AddTransceiverFromKind() can't be used with sendonly\n\t\tif dir == RTPTransceiverDirectionSendonly {\n\t\t\tcodecs := pc.api.mediaEngine.getCodecsByKind(RTPCodecTypeVideo)\n\n\t\t\ttrack, err := NewTrackLocalStaticSample(codecs[0].RTPCodecCapability, util.MathRandAlpha(16), util.MathRandAlpha(16))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = pc.AddTransceiverFromTrack(track, []RTPTransceiverInit{\n\t\t\t\t{Direction: dir},\n\t\t\t}...)\n\t\t\treturn err\n\t\t}\n\n\t\t_, err := pc.AddTransceiverFromKind(\n\t\t\tRTPCodecTypeVideo,\n\t\t\tRTPTransceiverInit{Direction: dir},\n\t\t)\n\t\treturn err\n\t}\n\n\tfor _, test := range []struct {\n\t\tname                  string\n\t\tofferDirection        RTPTransceiverDirection\n\t\tanswerStartDirection  RTPTransceiverDirection\n\t\tanswerFinalDirections []RTPTransceiverDirection\n\t}{\n\t\t{\n\t\t\t\"offer sendrecv answer sendrecv\",\n\t\t\tRTPTransceiverDirectionSendrecv,\n\t\t\tRTPTransceiverDirectionSendrecv,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendrecv},\n\t\t},\n\t\t{\n\t\t\t\"offer sendonly answer sendrecv\",\n\t\t\tRTPTransceiverDirectionSendonly,\n\t\t\tRTPTransceiverDirectionSendrecv,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendrecv},\n\t\t},\n\t\t{\n\t\t\t\"offer recvonly answer sendrecv\",\n\t\t\tRTPTransceiverDirectionRecvonly,\n\t\t\tRTPTransceiverDirectionSendrecv,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendonly},\n\t\t},\n\t\t{\n\t\t\t\"offer sendrecv answer sendonly\",\n\t\t\tRTPTransceiverDirectionSendrecv,\n\t\t\tRTPTransceiverDirectionSendonly,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendrecv},\n\t\t},\n\t\t{\n\t\t\t\"offer sendonly answer sendonly\",\n\t\t\tRTPTransceiverDirectionSendonly,\n\t\t\tRTPTransceiverDirectionSendonly,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendonly, RTPTransceiverDirectionRecvonly},\n\t\t},\n\t\t{\n\t\t\t\"offer recvonly answer sendonly\",\n\t\t\tRTPTransceiverDirectionRecvonly,\n\t\t\tRTPTransceiverDirectionSendonly,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendonly},\n\t\t},\n\t\t{\n\t\t\t\"offer sendrecv answer recvonly\",\n\t\t\tRTPTransceiverDirectionSendrecv,\n\t\t\tRTPTransceiverDirectionRecvonly,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionRecvonly},\n\t\t},\n\t\t{\n\t\t\t\"offer sendonly answer recvonly\",\n\t\t\tRTPTransceiverDirectionSendonly,\n\t\t\tRTPTransceiverDirectionRecvonly,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionRecvonly},\n\t\t},\n\t\t{\n\t\t\t\"offer recvonly answer recvonly\",\n\t\t\tRTPTransceiverDirectionRecvonly,\n\t\t\tRTPTransceiverDirectionRecvonly,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionRecvonly, RTPTransceiverDirectionSendonly},\n\t\t},\n\t} {\n\t\tofferDirection := test.offerDirection\n\t\tanswerStartDirection := test.answerStartDirection\n\t\tanswerFinalDirections := test.answerFinalDirections\n\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpcOffer, pcAnswer, err := newPair()\n\t\t\tassert.NoError(t, err)\n\n\t\t\terr = createTransceiver(pcOffer, offerDirection)\n\t\t\tassert.NoError(t, err)\n\n\t\t\toffer, err := pcOffer.CreateOffer(nil)\n\t\t\tassert.NoError(t, err)\n\n\t\t\terr = createTransceiver(pcAnswer, answerStartDirection)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\n\t\t\tassert.Equal(t, len(answerFinalDirections), len(pcAnswer.GetTransceivers()))\n\n\t\t\tfor i, tr := range pcAnswer.GetTransceivers() {\n\t\t\t\tassert.Equal(t, answerFinalDirections[i], tr.Direction())\n\t\t\t}\n\n\t\t\tassert.NoError(t, pcOffer.Close())\n\t\t\tassert.NoError(t, pcAnswer.Close())\n\t\t})\n\t}\n}\n\nfunc TestPeerConnection_SessionID(t *testing.T) {\n\tdefer test.TimeOut(time.Second * 10).Stop()\n\tdefer test.CheckRoutines(t)()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\tvar offerSessionID uint64\n\tvar offerSessionVersion uint64\n\tvar answerSessionID uint64\n\tvar answerSessionVersion uint64\n\tfor i := 0; i < 10; i++ {\n\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\t\toffer := pcOffer.LocalDescription().parsed\n\t\tsessionID := offer.Origin.SessionID\n\t\tsessionVersion := offer.Origin.SessionVersion\n\t\tif offerSessionID == 0 {\n\t\t\tofferSessionID = sessionID\n\t\t\tofferSessionVersion = sessionVersion\n\t\t} else {\n\t\t\tif offerSessionID != sessionID {\n\t\t\t\tt.Errorf(\"offer[%v] session id mismatch: expected=%v, got=%v\", i, offerSessionID, sessionID)\n\t\t\t}\n\t\t\tif offerSessionVersion+1 != sessionVersion {\n\t\t\t\tt.Errorf(\"offer[%v] session version mismatch: expected=%v, got=%v\", i, offerSessionVersion+1, sessionVersion)\n\t\t\t}\n\t\t\tofferSessionVersion++\n\t\t}\n\n\t\tanswer := pcAnswer.LocalDescription().parsed\n\t\tsessionID = answer.Origin.SessionID\n\t\tsessionVersion = answer.Origin.SessionVersion\n\t\tif answerSessionID == 0 {\n\t\t\tanswerSessionID = sessionID\n\t\t\tanswerSessionVersion = sessionVersion\n\t\t} else {\n\t\t\tif answerSessionID != sessionID {\n\t\t\t\tt.Errorf(\"answer[%v] session id mismatch: expected=%v, got=%v\", i, answerSessionID, sessionID)\n\t\t\t}\n\t\t\tif answerSessionVersion+1 != sessionVersion {\n\t\t\t\tt.Errorf(\"answer[%v] session version mismatch: expected=%v, got=%v\", i, answerSessionVersion+1, sessionVersion)\n\t\t\t}\n\t\t\tanswerSessionVersion++\n\t\t}\n\t}\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnectionNilCallback(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tpc.onSignalingStateChange(SignalingStateStable)\n\tpc.OnSignalingStateChange(func(SignalingState) {\n\t\tt.Error(\"OnSignalingStateChange called\")\n\t})\n\tpc.OnSignalingStateChange(nil)\n\tpc.onSignalingStateChange(SignalingStateStable)\n\n\tpc.onConnectionStateChange(PeerConnectionStateNew)\n\tpc.OnConnectionStateChange(func(PeerConnectionState) {\n\t\tt.Error(\"OnConnectionStateChange called\")\n\t})\n\tpc.OnConnectionStateChange(nil)\n\tpc.onConnectionStateChange(PeerConnectionStateNew)\n\n\tpc.onICEConnectionStateChange(ICEConnectionStateNew)\n\tpc.OnICEConnectionStateChange(func(ICEConnectionState) {\n\t\tt.Error(\"OnConnectionStateChange called\")\n\t})\n\tpc.OnICEConnectionStateChange(nil)\n\tpc.onICEConnectionStateChange(ICEConnectionStateNew)\n\n\tpc.onNegotiationNeeded()\n\tpc.negotiationNeededOp()\n\tpc.OnNegotiationNeeded(func() {\n\t\tt.Error(\"OnNegotiationNeeded called\")\n\t})\n\tpc.OnNegotiationNeeded(nil)\n\tpc.onNegotiationNeeded()\n\tpc.negotiationNeededOp()\n\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestTransceiverCreatedByRemoteSdpHasSameCodecOrderAsRemote(t *testing.T) {\n\tt.Run(\"Codec MatchExact\", func(t *testing.T) { //nolint:dupl\n\t\tconst remoteSdp = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0 1\nm=video 60323 UDP/TLS/RTP/SAVPF 98 94 106\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=ice-options:google-ice\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=mid:0\na=rtpmap:98 H264/90000\na=fmtp:98 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\na=rtpmap:94 VP8/90000\na=rtpmap:106 H264/90000\na=fmtp:106 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f\na=sendonly\nm=video 60323 UDP/TLS/RTP/SAVPF 108 98 125\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=ice-options:google-ice\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=mid:1\na=rtpmap:98 H264/90000\na=fmtp:98 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\na=rtpmap:108 VP8/90000\na=sendonly\na=rtpmap:125 H264/90000\na=fmtp:125 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        94,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\", nil},\n\t\t\tPayloadType:        98,\n\t\t}, RTPCodecTypeVideo))\n\n\t\tapi := NewAPI(WithMediaEngine(&m))\n\t\tpc, err := api.NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\t\tassert.NoError(t, pc.SetRemoteDescription(SessionDescription{\n\t\t\tType: SDPTypeOffer,\n\t\t\tSDP:  remoteSdp,\n\t\t}))\n\t\tans, _ := pc.CreateAnswer(nil)\n\t\tassert.NoError(t, pc.SetLocalDescription(ans))\n\t\tcodecOfTr1 := pc.GetTransceivers()[0].getCodecs()[0]\n\t\tcodecs := pc.api.mediaEngine.getCodecsByKind(RTPCodecTypeVideo)\n\t\t_, matchType := codecParametersFuzzySearch(codecOfTr1, codecs)\n\t\tassert.Equal(t, codecMatchExact, matchType)\n\t\tcodecOfTr2 := pc.GetTransceivers()[1].getCodecs()[0]\n\t\t_, matchType = codecParametersFuzzySearch(codecOfTr2, codecs)\n\t\tassert.Equal(t, codecMatchExact, matchType)\n\t\tassert.EqualValues(t, 94, codecOfTr2.PayloadType)\n\t\tassert.NoError(t, pc.Close())\n\t})\n\n\tt.Run(\"Codec PartialExact Only\", func(t *testing.T) { //nolint:dupl\n\t\tconst remoteSdp = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0 1\nm=video 60323 UDP/TLS/RTP/SAVPF 98 106\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=ice-options:google-ice\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=mid:0\na=rtpmap:98 H264/90000\na=fmtp:98 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f\na=rtpmap:106 H264/90000\na=fmtp:106 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640032\na=sendonly\nm=video 60323 UDP/TLS/RTP/SAVPF 125 98\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=ice-options:google-ice\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=mid:1\na=rtpmap:125 H264/90000\na=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640032\na=rtpmap:98 H264/90000\na=fmtp:98 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01f\na=sendonly\n`\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        94,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeH264, 90000, 0, \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\", nil},\n\t\t\tPayloadType:        98,\n\t\t}, RTPCodecTypeVideo))\n\n\t\tapi := NewAPI(WithMediaEngine(&m))\n\t\tpc, err := api.NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\t\tassert.NoError(t, pc.SetRemoteDescription(SessionDescription{\n\t\t\tType: SDPTypeOffer,\n\t\t\tSDP:  remoteSdp,\n\t\t}))\n\t\tans, _ := pc.CreateAnswer(nil)\n\t\tassert.NoError(t, pc.SetLocalDescription(ans))\n\t\tcodecOfTr1 := pc.GetTransceivers()[0].getCodecs()[0]\n\t\tcodecs := pc.api.mediaEngine.getCodecsByKind(RTPCodecTypeVideo)\n\t\t_, matchType := codecParametersFuzzySearch(codecOfTr1, codecs)\n\t\tassert.Equal(t, codecMatchExact, matchType)\n\t\tcodecOfTr2 := pc.GetTransceivers()[1].getCodecs()[0]\n\t\t_, matchType = codecParametersFuzzySearch(codecOfTr2, codecs)\n\t\tassert.Equal(t, codecMatchExact, matchType)\n\t\t// h.264/profile-id=640032 should be remap to 106 as same as transceiver 1\n\t\tassert.EqualValues(t, 106, codecOfTr2.PayloadType)\n\t\tassert.NoError(t, pc.Close())\n\t})\n}\n\n// Assert that remote candidates with an unknown transport are ignored and logged.\n// This allows us to accept SessionDescriptions with proprietary candidates\n// like `ssltcp`.\nfunc TestInvalidCandidateTransport(t *testing.T) {\n\tconst (\n\t\tsslTCPCandidate = `candidate:1 1 ssltcp 1 127.0.0.1 443 typ host generation 0`\n\t\tsslTCPOffer     = `v=0\no=- 0 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=msid-semantic: WMS\nm=application 9 DTLS/SCTP 5000\nc=IN IP4 0.0.0.0\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=mid:0\na=` + sslTCPCandidate + \"\\n\"\n\t)\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, peerConnection.SetRemoteDescription(SessionDescription{Type: SDPTypeOffer, SDP: sslTCPOffer}))\n\tassert.NoError(t, peerConnection.AddICECandidate(ICECandidateInit{Candidate: sslTCPCandidate}))\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\nfunc TestOfferWithInactiveDirection(t *testing.T) {\n\tconst remoteSDP = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=fingerprint:sha-256 F7:BF:B4:42:5B:44:C0:B9:49:70:6D:26:D7:3E:E6:08:B1:5B:25:2E:32:88:50:B6:3C:BE:4E:18:A7:2C:85:7C\na=group:BUNDLE 0\na=msid-semantic:WMS *\nm=video 9 UDP/TLS/RTP/SAVPF 97\nc=IN IP4 0.0.0.0\na=inactive\na=ice-pwd:05d682b2902af03db90d9a9a5f2f8d7f\na=ice-ufrag:93cc7e4d\na=mid:0\na=rtpmap:97 H264/90000\na=setup:actpass\na=ssrc:1455629982 cname:{61fd3093-0326-4b12-8258-86bdc1fe677a}\n`\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, peerConnection.SetRemoteDescription(SessionDescription{Type: SDPTypeOffer, SDP: remoteSDP}))\n\tassert.Equal(t, RTPTransceiverDirectionInactive, peerConnection.rtpTransceivers[0].direction.Load().(RTPTransceiverDirection)) //nolint:forcetypeassert\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\nfunc TestPeerConnectionState(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, PeerConnectionStateNew, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateChecking, DTLSTransportStateNew)\n\tassert.Equal(t, PeerConnectionStateConnecting, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateConnected, DTLSTransportStateNew)\n\tassert.Equal(t, PeerConnectionStateConnecting, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateConnected, DTLSTransportStateConnecting)\n\tassert.Equal(t, PeerConnectionStateConnecting, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateConnected, DTLSTransportStateConnected)\n\tassert.Equal(t, PeerConnectionStateConnected, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateCompleted, DTLSTransportStateConnected)\n\tassert.Equal(t, PeerConnectionStateConnected, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateConnected, DTLSTransportStateClosed)\n\tassert.Equal(t, PeerConnectionStateConnected, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateDisconnected, DTLSTransportStateConnected)\n\tassert.Equal(t, PeerConnectionStateDisconnected, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateFailed, DTLSTransportStateConnected)\n\tassert.Equal(t, PeerConnectionStateFailed, pc.ConnectionState())\n\n\tpc.updateConnectionState(ICEConnectionStateConnected, DTLSTransportStateFailed)\n\tassert.Equal(t, PeerConnectionStateFailed, pc.ConnectionState())\n\n\tassert.NoError(t, pc.Close())\n\tassert.Equal(t, PeerConnectionStateClosed, pc.ConnectionState())\n}\n\nfunc TestPeerConnectionDeadlock(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 5)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tcloseHdlr := func(peerConnection *PeerConnection) {\n\t\tpeerConnection.OnICEConnectionStateChange(func(i ICEConnectionState) {\n\t\t\tif i == ICEConnectionStateFailed || i == ICEConnectionStateClosed {\n\t\t\t\tif err := peerConnection.Close(); err != nil {\n\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tpcOffer, pcAnswer, err := NewAPI().newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tonDataChannel, onDataChannelCancel := context.WithCancel(context.Background())\n\tpcAnswer.OnDataChannel(func(*DataChannel) {\n\t\tonDataChannelCancel()\n\t})\n\t<-onDataChannel.Done()\n\n\tcloseHdlr(pcOffer)\n\tcloseHdlr(pcAnswer)\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Assert that by default NULL Ciphers aren't enabled. Even if\n// the remote Peer Requests a NULL Cipher we should fail\nfunc TestPeerConnectionNoNULLCipherDefault(t *testing.T) {\n\tsettingEngine := SettingEngine{}\n\tsettingEngine.SetSRTPProtectionProfiles(dtls.SRTP_NULL_HMAC_SHA1_80, dtls.SRTP_NULL_HMAC_SHA1_32)\n\tofferPC, err := NewAPI(WithSettingEngine(settingEngine)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tanswerPC, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(offerPC, answerPC))\n\n\tpeerConnectionClosed := make(chan struct{})\n\tanswerPC.OnConnectionStateChange(func(s PeerConnectionState) {\n\t\tif s == PeerConnectionStateClosed {\n\t\t\tclose(peerConnectionClosed)\n\t\t}\n\t})\n\n\t<-peerConnectionClosed\n\tclosePairNow(t, offerPC, answerPC)\n}\n\n// https://github.com/pion/webrtc/issues/2690\nfunc TestPeerConnectionTrickleMediaStreamIdentification(t *testing.T) {\n\tconst remoteSdp = `v=0\no=- 1735985477255306 1 IN IP4 127.0.0.1\ns=VideoRoom 1234\nt=0 0\na=group:BUNDLE 0 1\na=ice-options:trickle\na=fingerprint:sha-256 61:BF:17:29:C0:EF:B2:77:75:79:64:F9:D8:D0:03:6C:5A:D3:9A:BC:E5:F4:5A:05:4C:3C:3B:A0:B4:2B:CF:A8\na=extmap-allow-mixed\na=msid-semantic: WMS *\nm=audio 9 UDP/TLS/RTP/SAVPF 111\nc=IN IP4 127.0.0.1\na=sendonly\na=mid:0\na=rtcp-mux\na=ice-ufrag:xv3r\na=ice-pwd:NT22yM6JeOsahq00U9ZJS/\na=ice-options:trickle\na=setup:actpass\na=rtpmap:111 opus/48000/2\na=rtcp-fb:111 transport-cc\na=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level\na=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid\na=fmtp:111 useinbandfec=1\na=msid:janus janus0\na=ssrc:2280306597 cname:janus\nm=video 9 UDP/TLS/RTP/SAVPF 96 97\nc=IN IP4 127.0.0.1\na=sendonly\na=mid:1\na=rtcp-mux\na=ice-ufrag:xv3r\na=ice-pwd:NT22yM6JeOsahq00U9ZJS/\na=ice-options:trickle\na=setup:actpass\na=rtpmap:96 VP8/90000\na=rtcp-fb:96 ccm fir\na=rtcp-fb:96 nack\na=rtcp-fb:96 nack pli\na=rtcp-fb:96 goog-remb\na=rtcp-fb:96 transport-cc\na=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time\na=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\na=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid\na=extmap:12 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay\na=extmap:13 urn:3gpp:video-orientation\na=rtpmap:97 rtx/90000\na=fmtp:97 apt=96\na=ssrc-group:FID 4099488402 29586368\na=msid:janus janus1\na=ssrc:4099488402 cname:janus\na=ssrc:29586368 cname:janus\n`\n\n\tmediaEngine := &MediaEngine{}\n\n\tassert.NoError(t, mediaEngine.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        96,\n\t}, RTPCodecTypeVideo))\n\tassert.NoError(t, mediaEngine.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        111,\n\t}, RTPCodecTypeAudio))\n\n\tapi := NewAPI(WithMediaEngine(mediaEngine))\n\tpc, err := api.NewPeerConnection(Configuration{\n\t\tICEServers: []ICEServer{\n\t\t\t{\n\t\t\t\tURLs: []string{\"stun:stun.l.google.com:19302\"},\n\t\t\t},\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\n\tpc.OnICECandidate(func(candidate *ICECandidate) {\n\t\tif candidate == nil {\n\t\t\treturn\n\t\t}\n\n\t\tassert.NotEmpty(t, candidate.SDPMid)\n\n\t\tassert.Contains(t, []string{\"0\", \"1\"}, candidate.SDPMid)\n\t\tassert.Contains(t, []uint16{0, 1}, candidate.SDPMLineIndex)\n\t})\n\n\tassert.NoError(t, pc.SetRemoteDescription(SessionDescription{\n\t\tType: SDPTypeOffer,\n\t\tSDP:  remoteSdp,\n\t}))\n\n\tgatherComplete := GatheringCompletePromise(pc)\n\tans, _ := pc.CreateAnswer(nil)\n\tassert.NoError(t, pc.SetLocalDescription(ans))\n\n\t<-gatherComplete\n\n\tassert.NoError(t, pc.Close())\n\n\tassert.Equal(t, PeerConnectionStateClosed, pc.ConnectionState())\n}\n\nfunc TestTranceiverMediaStreamIdentification(t *testing.T) {\n\tconst videoMid = \"0\"\n\tconst audioMid = \"1\"\n\n\tmediaEngine := &MediaEngine{}\n\n\tassert.NoError(t, mediaEngine.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        96,\n\t}, RTPCodecTypeVideo))\n\tassert.NoError(t, mediaEngine.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        111,\n\t}, RTPCodecTypeAudio))\n\n\tapi := NewAPI(WithMediaEngine(mediaEngine))\n\tpcOfferer, pcAnswerer, err := api.newPair(Configuration{\n\t\tICEServers: []ICEServer{\n\t\t\t{\n\t\t\t\tURLs: []string{\"stun:stun.l.google.com:19302\"},\n\t\t\t},\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\n\tpcOfferer.OnICECandidate(func(candidate *ICECandidate) {\n\t\tif candidate == nil {\n\t\t\treturn\n\t\t}\n\n\t\tassert.NotEmpty(t, candidate.SDPMid)\n\t\tassert.Contains(t, []string{videoMid, audioMid}, candidate.SDPMid)\n\t\tassert.Contains(t, []uint16{0, 1}, candidate.SDPMLineIndex)\n\t})\n\n\tpcAnswerer.OnICECandidate(func(candidate *ICECandidate) {\n\t\tif candidate == nil {\n\t\t\treturn\n\t\t}\n\n\t\tassert.NotEmpty(t, candidate.SDPMid)\n\t\tassert.Contains(t, []string{videoMid, audioMid}, candidate.SDPMid)\n\t\tassert.Contains(t, []uint16{0, 1}, candidate.SDPMLineIndex)\n\t})\n\n\tvideoTransceiver, err := pcOfferer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tassert.NoError(t, err)\n\n\taudioTransceiver, err := pcOfferer.AddTransceiverFromKind(RTPCodecTypeAudio, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, videoTransceiver.SetMid(videoMid))\n\tassert.NoError(t, audioTransceiver.SetMid(audioMid))\n\n\toffer, err := pcOfferer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, pcOfferer.SetLocalDescription(offer))\n\n\tassert.NoError(t, pcAnswerer.SetRemoteDescription(offer))\n\n\tanswer, err := pcAnswerer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, pcAnswerer.SetLocalDescription(answer))\n\n\tanswerGatherComplete := GatheringCompletePromise(pcOfferer)\n\tofferGatherComplete := GatheringCompletePromise(pcAnswerer)\n\n\t<-answerGatherComplete\n\t<-offerGatherComplete\n\n\tassert.NoError(t, pcOfferer.Close())\n\tassert.NoError(t, pcAnswerer.Close())\n}\n"
        },
        {
          "name": "peerconnection_js.go",
          "type": "blob",
          "size": 26.791015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\n// Package webrtc implements the WebRTC 1.0 as defined in W3C WebRTC specification document.\npackage webrtc\n\nimport (\n\t\"syscall/js\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\n// PeerConnection represents a WebRTC connection that establishes a\n// peer-to-peer communications with another PeerConnection instance in a\n// browser, or to another endpoint implementing the required protocols.\ntype PeerConnection struct {\n\t// Pointer to the underlying JavaScript RTCPeerConnection object.\n\tunderlying js.Value\n\n\t// Keep track of handlers/callbacks so we can call Release as required by the\n\t// syscall/js API. Initially nil.\n\tonSignalingStateChangeHandler     *js.Func\n\tonDataChannelHandler              *js.Func\n\tonNegotiationNeededHandler        *js.Func\n\tonConnectionStateChangeHandler    *js.Func\n\tonICEConnectionStateChangeHandler *js.Func\n\tonICECandidateHandler             *js.Func\n\tonICEGatheringStateChangeHandler  *js.Func\n\n\t// Used by GatheringCompletePromise\n\tonGatherCompleteHandler func()\n\n\t// A reference to the associated API state used by this connection\n\tapi *API\n}\n\n// NewPeerConnection creates a peerconnection.\nfunc NewPeerConnection(configuration Configuration) (*PeerConnection, error) {\n\tapi := NewAPI()\n\treturn api.NewPeerConnection(configuration)\n}\n\n// NewPeerConnection creates a new PeerConnection with the provided configuration against the received API object\nfunc (api *API) NewPeerConnection(configuration Configuration) (_ *PeerConnection, err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tconfigMap := configurationToValue(configuration)\n\tunderlying := js.Global().Get(\"window\").Get(\"RTCPeerConnection\").New(configMap)\n\treturn &PeerConnection{\n\t\tunderlying: underlying,\n\t\tapi:        api,\n\t}, nil\n}\n\n// JSValue returns the underlying PeerConnection\nfunc (pc *PeerConnection) JSValue() js.Value {\n\treturn pc.underlying\n}\n\n// OnSignalingStateChange sets an event handler which is invoked when the\n// peer connection's signaling state changes\nfunc (pc *PeerConnection) OnSignalingStateChange(f func(SignalingState)) {\n\tif pc.onSignalingStateChangeHandler != nil {\n\t\toldHandler := pc.onSignalingStateChangeHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonSignalingStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tstate := newSignalingState(args[0].String())\n\t\tgo f(state)\n\t\treturn js.Undefined()\n\t})\n\tpc.onSignalingStateChangeHandler = &onSignalingStateChangeHandler\n\tpc.underlying.Set(\"onsignalingstatechange\", onSignalingStateChangeHandler)\n}\n\n// OnDataChannel sets an event handler which is invoked when a data\n// channel message arrives from a remote peer.\nfunc (pc *PeerConnection) OnDataChannel(f func(*DataChannel)) {\n\tif pc.onDataChannelHandler != nil {\n\t\toldHandler := pc.onDataChannelHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonDataChannelHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\t// pion/webrtc/projects/15\n\t\t// This reference to the underlying DataChannel doesn't know\n\t\t// about any other references to the same DataChannel. This might result in\n\t\t// memory leaks where we don't clean up handler functions. Could possibly fix\n\t\t// by keeping a mutex-protected list of all DataChannel references as a\n\t\t// property of this PeerConnection, but at the cost of additional overhead.\n\t\tdataChannel := &DataChannel{\n\t\t\tunderlying: args[0].Get(\"channel\"),\n\t\t\tapi:        pc.api,\n\t\t}\n\t\tgo f(dataChannel)\n\t\treturn js.Undefined()\n\t})\n\tpc.onDataChannelHandler = &onDataChannelHandler\n\tpc.underlying.Set(\"ondatachannel\", onDataChannelHandler)\n}\n\n// OnNegotiationNeeded sets an event handler which is invoked when\n// a change has occurred which requires session negotiation\nfunc (pc *PeerConnection) OnNegotiationNeeded(f func()) {\n\tif pc.onNegotiationNeededHandler != nil {\n\t\toldHandler := pc.onNegotiationNeededHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonNegotiationNeededHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo f()\n\t\treturn js.Undefined()\n\t})\n\tpc.onNegotiationNeededHandler = &onNegotiationNeededHandler\n\tpc.underlying.Set(\"onnegotiationneeded\", onNegotiationNeededHandler)\n}\n\n// OnICEConnectionStateChange sets an event handler which is called\n// when an ICE connection state is changed.\nfunc (pc *PeerConnection) OnICEConnectionStateChange(f func(ICEConnectionState)) {\n\tif pc.onICEConnectionStateChangeHandler != nil {\n\t\toldHandler := pc.onICEConnectionStateChangeHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonICEConnectionStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tconnectionState := NewICEConnectionState(pc.underlying.Get(\"iceConnectionState\").String())\n\t\tgo f(connectionState)\n\t\treturn js.Undefined()\n\t})\n\tpc.onICEConnectionStateChangeHandler = &onICEConnectionStateChangeHandler\n\tpc.underlying.Set(\"oniceconnectionstatechange\", onICEConnectionStateChangeHandler)\n}\n\n// OnConnectionStateChange sets an event handler which is called\n// when an PeerConnectionState is changed.\nfunc (pc *PeerConnection) OnConnectionStateChange(f func(PeerConnectionState)) {\n\tif pc.onConnectionStateChangeHandler != nil {\n\t\toldHandler := pc.onConnectionStateChangeHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonConnectionStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tconnectionState := newPeerConnectionState(pc.underlying.Get(\"connectionState\").String())\n\t\tgo f(connectionState)\n\t\treturn js.Undefined()\n\t})\n\tpc.onConnectionStateChangeHandler = &onConnectionStateChangeHandler\n\tpc.underlying.Set(\"onconnectionstatechange\", onConnectionStateChangeHandler)\n}\n\nfunc (pc *PeerConnection) checkConfiguration(configuration Configuration) error {\n\t// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-setconfiguration (step #2)\n\tif pc.ConnectionState() == PeerConnectionStateClosed {\n\t\treturn &rtcerr.InvalidStateError{Err: ErrConnectionClosed}\n\t}\n\n\texistingConfig := pc.GetConfiguration()\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #3)\n\tif configuration.PeerIdentity != \"\" {\n\t\tif configuration.PeerIdentity != existingConfig.PeerIdentity {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingPeerIdentity}\n\t\t}\n\t}\n\n\t// https://github.com/pion/webrtc/issues/513\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #4)\n\t// if len(configuration.Certificates) > 0 {\n\t// \tif len(configuration.Certificates) != len(existingConfiguration.Certificates) {\n\t// \t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingCertificates}\n\t// \t}\n\n\t// \tfor i, certificate := range configuration.Certificates {\n\t// \t\tif !pc.configuration.Certificates[i].Equals(certificate) {\n\t// \t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingCertificates}\n\t// \t\t}\n\t// \t}\n\t// \tpc.configuration.Certificates = configuration.Certificates\n\t// }\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #5)\n\tif configuration.BundlePolicy != BundlePolicyUnknown {\n\t\tif configuration.BundlePolicy != existingConfig.BundlePolicy {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingBundlePolicy}\n\t\t}\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #6)\n\tif configuration.RTCPMuxPolicy != RTCPMuxPolicyUnknown {\n\t\tif configuration.RTCPMuxPolicy != existingConfig.RTCPMuxPolicy {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingRTCPMuxPolicy}\n\t\t}\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #7)\n\tif configuration.ICECandidatePoolSize != 0 {\n\t\tif configuration.ICECandidatePoolSize != existingConfig.ICECandidatePoolSize &&\n\t\t\tpc.LocalDescription() != nil {\n\t\t\treturn &rtcerr.InvalidModificationError{Err: ErrModifyingICECandidatePoolSize}\n\t\t}\n\t}\n\n\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #11)\n\tif len(configuration.ICEServers) > 0 {\n\t\t// https://www.w3.org/TR/webrtc/#set-the-configuration (step #11.3)\n\t\tfor _, server := range configuration.ICEServers {\n\t\t\tif _, err := server.validate(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// SetConfiguration updates the configuration of this PeerConnection object.\nfunc (pc *PeerConnection) SetConfiguration(configuration Configuration) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tif err := pc.checkConfiguration(configuration); err != nil {\n\t\treturn err\n\t}\n\tconfigMap := configurationToValue(configuration)\n\tpc.underlying.Call(\"setConfiguration\", configMap)\n\treturn nil\n}\n\n// GetConfiguration returns a Configuration object representing the current\n// configuration of this PeerConnection object. The returned object is a\n// copy and direct mutation on it will not take affect until SetConfiguration\n// has been called with Configuration passed as its only argument.\n// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-getconfiguration\nfunc (pc *PeerConnection) GetConfiguration() Configuration {\n\treturn valueToConfiguration(pc.underlying.Call(\"getConfiguration\"))\n}\n\n// CreateOffer starts the PeerConnection and generates the localDescription\nfunc (pc *PeerConnection) CreateOffer(options *OfferOptions) (_ SessionDescription, err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tpromise := pc.underlying.Call(\"createOffer\", offerOptionsToValue(options))\n\tdesc, err := awaitPromise(promise)\n\tif err != nil {\n\t\treturn SessionDescription{}, err\n\t}\n\treturn *valueToSessionDescription(desc), nil\n}\n\n// CreateAnswer starts the PeerConnection and generates the localDescription\nfunc (pc *PeerConnection) CreateAnswer(options *AnswerOptions) (_ SessionDescription, err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tpromise := pc.underlying.Call(\"createAnswer\", answerOptionsToValue(options))\n\tdesc, err := awaitPromise(promise)\n\tif err != nil {\n\t\treturn SessionDescription{}, err\n\t}\n\treturn *valueToSessionDescription(desc), nil\n}\n\n// SetLocalDescription sets the SessionDescription of the local peer\nfunc (pc *PeerConnection) SetLocalDescription(desc SessionDescription) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tpromise := pc.underlying.Call(\"setLocalDescription\", sessionDescriptionToValue(&desc))\n\t_, err = awaitPromise(promise)\n\treturn err\n}\n\n// LocalDescription returns PendingLocalDescription if it is not null and\n// otherwise it returns CurrentLocalDescription. This property is used to\n// determine if setLocalDescription has already been called.\n// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-localdescription\nfunc (pc *PeerConnection) LocalDescription() *SessionDescription {\n\treturn valueToSessionDescription(pc.underlying.Get(\"localDescription\"))\n}\n\n// SetRemoteDescription sets the SessionDescription of the remote peer\nfunc (pc *PeerConnection) SetRemoteDescription(desc SessionDescription) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tpromise := pc.underlying.Call(\"setRemoteDescription\", sessionDescriptionToValue(&desc))\n\t_, err = awaitPromise(promise)\n\treturn err\n}\n\n// RemoteDescription returns PendingRemoteDescription if it is not null and\n// otherwise it returns CurrentRemoteDescription. This property is used to\n// determine if setRemoteDescription has already been called.\n// https://www.w3.org/TR/webrtc/#dom-rtcpeerconnection-remotedescription\nfunc (pc *PeerConnection) RemoteDescription() *SessionDescription {\n\treturn valueToSessionDescription(pc.underlying.Get(\"remoteDescription\"))\n}\n\n// AddICECandidate accepts an ICE candidate string and adds it\n// to the existing set of candidates\nfunc (pc *PeerConnection) AddICECandidate(candidate ICECandidateInit) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tpromise := pc.underlying.Call(\"addIceCandidate\", iceCandidateInitToValue(candidate))\n\t_, err = awaitPromise(promise)\n\treturn err\n}\n\n// ICEConnectionState returns the ICE connection state of the\n// PeerConnection instance.\nfunc (pc *PeerConnection) ICEConnectionState() ICEConnectionState {\n\treturn NewICEConnectionState(pc.underlying.Get(\"iceConnectionState\").String())\n}\n\n// OnICECandidate sets an event handler which is invoked when a new ICE\n// candidate is found.\nfunc (pc *PeerConnection) OnICECandidate(f func(candidate *ICECandidate)) {\n\tif pc.onICECandidateHandler != nil {\n\t\toldHandler := pc.onICECandidateHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonICECandidateHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tcandidate := valueToICECandidate(args[0].Get(\"candidate\"))\n\t\tif candidate == nil && pc.onGatherCompleteHandler != nil {\n\t\t\tgo pc.onGatherCompleteHandler()\n\t\t}\n\n\t\tgo f(candidate)\n\t\treturn js.Undefined()\n\t})\n\tpc.onICECandidateHandler = &onICECandidateHandler\n\tpc.underlying.Set(\"onicecandidate\", onICECandidateHandler)\n}\n\n// OnICEGatheringStateChange sets an event handler which is invoked when the\n// ICE candidate gathering state has changed.\nfunc (pc *PeerConnection) OnICEGatheringStateChange(f func()) {\n\tif pc.onICEGatheringStateChangeHandler != nil {\n\t\toldHandler := pc.onICEGatheringStateChangeHandler\n\t\tdefer oldHandler.Release()\n\t}\n\tonICEGatheringStateChangeHandler := js.FuncOf(func(this js.Value, args []js.Value) interface{} {\n\t\tgo f()\n\t\treturn js.Undefined()\n\t})\n\tpc.onICEGatheringStateChangeHandler = &onICEGatheringStateChangeHandler\n\tpc.underlying.Set(\"onicegatheringstatechange\", onICEGatheringStateChangeHandler)\n}\n\n// CreateDataChannel creates a new DataChannel object with the given label\n// and optional DataChannelInit used to configure properties of the\n// underlying channel such as data reliability.\nfunc (pc *PeerConnection) CreateDataChannel(label string, options *DataChannelInit) (_ *DataChannel, err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tchannel := pc.underlying.Call(\"createDataChannel\", label, dataChannelInitToValue(options))\n\treturn &DataChannel{\n\t\tunderlying: channel,\n\t\tapi:        pc.api,\n\t}, nil\n}\n\n// SetIdentityProvider is used to configure an identity provider to generate identity assertions\nfunc (pc *PeerConnection) SetIdentityProvider(provider string) (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\tpc.underlying.Call(\"setIdentityProvider\", provider)\n\treturn nil\n}\n\n// Close ends the PeerConnection\nfunc (pc *PeerConnection) Close() (err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\n\tpc.underlying.Call(\"close\")\n\n\t// Release any handlers as required by the syscall/js API.\n\tif pc.onSignalingStateChangeHandler != nil {\n\t\tpc.onSignalingStateChangeHandler.Release()\n\t}\n\tif pc.onDataChannelHandler != nil {\n\t\tpc.onDataChannelHandler.Release()\n\t}\n\tif pc.onNegotiationNeededHandler != nil {\n\t\tpc.onNegotiationNeededHandler.Release()\n\t}\n\tif pc.onConnectionStateChangeHandler != nil {\n\t\tpc.onConnectionStateChangeHandler.Release()\n\t}\n\tif pc.onICEConnectionStateChangeHandler != nil {\n\t\tpc.onICEConnectionStateChangeHandler.Release()\n\t}\n\tif pc.onICECandidateHandler != nil {\n\t\tpc.onICECandidateHandler.Release()\n\t}\n\tif pc.onICEGatheringStateChangeHandler != nil {\n\t\tpc.onICEGatheringStateChangeHandler.Release()\n\t}\n\n\treturn nil\n}\n\n// CurrentLocalDescription represents the local description that was\n// successfully negotiated the last time the PeerConnection transitioned\n// into the stable state plus any local candidates that have been generated\n// by the ICEAgent since the offer or answer was created.\nfunc (pc *PeerConnection) CurrentLocalDescription() *SessionDescription {\n\tdesc := pc.underlying.Get(\"currentLocalDescription\")\n\treturn valueToSessionDescription(desc)\n}\n\n// PendingLocalDescription represents a local description that is in the\n// process of being negotiated plus any local candidates that have been\n// generated by the ICEAgent since the offer or answer was created. If the\n// PeerConnection is in the stable state, the value is null.\nfunc (pc *PeerConnection) PendingLocalDescription() *SessionDescription {\n\tdesc := pc.underlying.Get(\"pendingLocalDescription\")\n\treturn valueToSessionDescription(desc)\n}\n\n// CurrentRemoteDescription represents the last remote description that was\n// successfully negotiated the last time the PeerConnection transitioned\n// into the stable state plus any remote candidates that have been supplied\n// via AddICECandidate() since the offer or answer was created.\nfunc (pc *PeerConnection) CurrentRemoteDescription() *SessionDescription {\n\tdesc := pc.underlying.Get(\"currentRemoteDescription\")\n\treturn valueToSessionDescription(desc)\n}\n\n// PendingRemoteDescription represents a remote description that is in the\n// process of being negotiated, complete with any remote candidates that\n// have been supplied via AddICECandidate() since the offer or answer was\n// created. If the PeerConnection is in the stable state, the value is\n// null.\nfunc (pc *PeerConnection) PendingRemoteDescription() *SessionDescription {\n\tdesc := pc.underlying.Get(\"pendingRemoteDescription\")\n\treturn valueToSessionDescription(desc)\n}\n\n// SignalingState returns the signaling state of the PeerConnection instance.\nfunc (pc *PeerConnection) SignalingState() SignalingState {\n\trawState := pc.underlying.Get(\"signalingState\").String()\n\treturn newSignalingState(rawState)\n}\n\n// ICEGatheringState attribute the ICE gathering state of the PeerConnection\n// instance.\nfunc (pc *PeerConnection) ICEGatheringState() ICEGatheringState {\n\trawState := pc.underlying.Get(\"iceGatheringState\").String()\n\treturn NewICEGatheringState(rawState)\n}\n\n// ConnectionState attribute the connection state of the PeerConnection\n// instance.\nfunc (pc *PeerConnection) ConnectionState() PeerConnectionState {\n\trawState := pc.underlying.Get(\"connectionState\").String()\n\treturn newPeerConnectionState(rawState)\n}\n\nfunc (pc *PeerConnection) setGatherCompleteHandler(handler func()) {\n\tpc.onGatherCompleteHandler = handler\n\n\t// If no onIceCandidate handler has been set provide an empty one\n\t// otherwise our onGatherCompleteHandler will not be executed\n\tif pc.onICECandidateHandler == nil {\n\t\tpc.OnICECandidate(func(i *ICECandidate) {})\n\t}\n}\n\n// AddTransceiverFromKind Create a new RtpTransceiver and adds it to the set of transceivers.\nfunc (pc *PeerConnection) AddTransceiverFromKind(kind RTPCodecType, init ...RTPTransceiverInit) (transceiver *RTPTransceiver, err error) {\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = recoveryToError(e)\n\t\t}\n\t}()\n\n\tif len(init) == 1 {\n\t\treturn &RTPTransceiver{\n\t\t\tunderlying: pc.underlying.Call(\"addTransceiver\", kind.String(), rtpTransceiverInitInitToValue(init[0])),\n\t\t}, err\n\t}\n\n\treturn &RTPTransceiver{\n\t\tunderlying: pc.underlying.Call(\"addTransceiver\", kind.String()),\n\t}, err\n}\n\n// GetTransceivers returns the RtpTransceiver that are currently attached to this PeerConnection\nfunc (pc *PeerConnection) GetTransceivers() (transceivers []*RTPTransceiver) {\n\trawTransceivers := pc.underlying.Call(\"getTransceivers\")\n\ttransceivers = make([]*RTPTransceiver, rawTransceivers.Length())\n\n\tfor i := 0; i < rawTransceivers.Length(); i++ {\n\t\ttransceivers[i] = &RTPTransceiver{\n\t\t\tunderlying: rawTransceivers.Index(i),\n\t\t}\n\t}\n\n\treturn\n}\n\n// SCTP returns the SCTPTransport for this PeerConnection\n//\n// The SCTP transport over which SCTP data is sent and received. If SCTP has not been negotiated, the value is nil.\n// https://www.w3.org/TR/webrtc/#attributes-15\nfunc (pc *PeerConnection) SCTP() *SCTPTransport {\n\tunderlying := pc.underlying.Get(\"sctp\")\n\tif underlying.IsNull() || underlying.IsUndefined() {\n\t\treturn nil\n\t}\n\n\treturn &SCTPTransport{\n\t\tunderlying: underlying,\n\t}\n}\n\n// Converts a Configuration to js.Value so it can be passed\n// through to the JavaScript WebRTC API. Any zero values are converted to\n// js.Undefined(), which will result in the default value being used.\nfunc configurationToValue(configuration Configuration) js.Value {\n\treturn js.ValueOf(map[string]interface{}{\n\t\t\"iceServers\":           iceServersToValue(configuration.ICEServers),\n\t\t\"iceTransportPolicy\":   stringEnumToValueOrUndefined(configuration.ICETransportPolicy.String()),\n\t\t\"bundlePolicy\":         stringEnumToValueOrUndefined(configuration.BundlePolicy.String()),\n\t\t\"rtcpMuxPolicy\":        stringEnumToValueOrUndefined(configuration.RTCPMuxPolicy.String()),\n\t\t\"peerIdentity\":         stringToValueOrUndefined(configuration.PeerIdentity),\n\t\t\"iceCandidatePoolSize\": uint8ToValueOrUndefined(configuration.ICECandidatePoolSize),\n\n\t\t// Note: Certificates are not currently supported.\n\t\t// \"certificates\": configuration.Certificates,\n\t})\n}\n\nfunc iceServersToValue(iceServers []ICEServer) js.Value {\n\tif len(iceServers) == 0 {\n\t\treturn js.Undefined()\n\t}\n\tmaps := make([]interface{}, len(iceServers))\n\tfor i, server := range iceServers {\n\t\tmaps[i] = iceServerToValue(server)\n\t}\n\treturn js.ValueOf(maps)\n}\n\nfunc oauthCredentialToValue(o OAuthCredential) js.Value {\n\tout := map[string]interface{}{\n\t\t\"MACKey\":      o.MACKey,\n\t\t\"AccessToken\": o.AccessToken,\n\t}\n\treturn js.ValueOf(out)\n}\n\nfunc iceServerToValue(server ICEServer) js.Value {\n\tout := map[string]interface{}{\n\t\t\"urls\": stringsToValue(server.URLs), // required\n\t}\n\tif server.Username != \"\" {\n\t\tout[\"username\"] = stringToValueOrUndefined(server.Username)\n\t}\n\tif server.Credential != nil {\n\t\tswitch t := server.Credential.(type) {\n\t\tcase string:\n\t\t\tout[\"credential\"] = stringToValueOrUndefined(t)\n\t\tcase OAuthCredential:\n\t\t\tout[\"credential\"] = oauthCredentialToValue(t)\n\t\t}\n\t}\n\tout[\"credentialType\"] = stringEnumToValueOrUndefined(server.CredentialType.String())\n\treturn js.ValueOf(out)\n}\n\nfunc valueToConfiguration(configValue js.Value) Configuration {\n\tif configValue.IsNull() || configValue.IsUndefined() {\n\t\treturn Configuration{}\n\t}\n\treturn Configuration{\n\t\tICEServers:           valueToICEServers(configValue.Get(\"iceServers\")),\n\t\tICETransportPolicy:   NewICETransportPolicy(valueToStringOrZero(configValue.Get(\"iceTransportPolicy\"))),\n\t\tBundlePolicy:         newBundlePolicy(valueToStringOrZero(configValue.Get(\"bundlePolicy\"))),\n\t\tRTCPMuxPolicy:        newRTCPMuxPolicy(valueToStringOrZero(configValue.Get(\"rtcpMuxPolicy\"))),\n\t\tPeerIdentity:         valueToStringOrZero(configValue.Get(\"peerIdentity\")),\n\t\tICECandidatePoolSize: valueToUint8OrZero(configValue.Get(\"iceCandidatePoolSize\")),\n\n\t\t// Note: Certificates are not supported.\n\t\t// Certificates []Certificate\n\t}\n}\n\nfunc valueToICEServers(iceServersValue js.Value) []ICEServer {\n\tif iceServersValue.IsNull() || iceServersValue.IsUndefined() {\n\t\treturn nil\n\t}\n\ticeServers := make([]ICEServer, iceServersValue.Length())\n\tfor i := 0; i < iceServersValue.Length(); i++ {\n\t\ticeServers[i] = valueToICEServer(iceServersValue.Index(i))\n\t}\n\treturn iceServers\n}\n\nfunc valueToICECredential(iceCredentialValue js.Value) interface{} {\n\tif iceCredentialValue.IsNull() || iceCredentialValue.IsUndefined() {\n\t\treturn nil\n\t}\n\tif iceCredentialValue.Type() == js.TypeString {\n\t\treturn iceCredentialValue.String()\n\t}\n\tif iceCredentialValue.Type() == js.TypeObject {\n\t\treturn OAuthCredential{\n\t\t\tMACKey:      iceCredentialValue.Get(\"MACKey\").String(),\n\t\t\tAccessToken: iceCredentialValue.Get(\"AccessToken\").String(),\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc valueToICEServer(iceServerValue js.Value) ICEServer {\n\ttpe, err := newICECredentialType(valueToStringOrZero(iceServerValue.Get(\"credentialType\")))\n\tif err != nil {\n\t\ttpe = ICECredentialTypePassword\n\t}\n\ts := ICEServer{\n\t\tURLs:     valueToStrings(iceServerValue.Get(\"urls\")), // required\n\t\tUsername: valueToStringOrZero(iceServerValue.Get(\"username\")),\n\t\t// Note: Credential and CredentialType are not currently supported.\n\t\tCredential:     valueToICECredential(iceServerValue.Get(\"credential\")),\n\t\tCredentialType: tpe,\n\t}\n\n\treturn s\n}\n\nfunc valueToICECandidate(val js.Value) *ICECandidate {\n\tif val.IsNull() || val.IsUndefined() {\n\t\treturn nil\n\t}\n\tif val.Get(\"protocol\").IsUndefined() && !val.Get(\"candidate\").IsUndefined() {\n\t\t// Missing some fields, assume it's Firefox and parse SDP candidate.\n\t\tc, err := ice.UnmarshalCandidate(val.Get(\"candidate\").String())\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\ticeCandidate, err := newICECandidateFromICE(c, \"\", 0)\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn &iceCandidate\n\t}\n\tprotocol, _ := NewICEProtocol(val.Get(\"protocol\").String())\n\tcandidateType, _ := NewICECandidateType(val.Get(\"type\").String())\n\treturn &ICECandidate{\n\t\tFoundation:     val.Get(\"foundation\").String(),\n\t\tPriority:       valueToUint32OrZero(val.Get(\"priority\")),\n\t\tAddress:        val.Get(\"address\").String(),\n\t\tProtocol:       protocol,\n\t\tPort:           valueToUint16OrZero(val.Get(\"port\")),\n\t\tTyp:            candidateType,\n\t\tComponent:      stringToComponentIDOrZero(val.Get(\"component\").String()),\n\t\tRelatedAddress: val.Get(\"relatedAddress\").String(),\n\t\tRelatedPort:    valueToUint16OrZero(val.Get(\"relatedPort\")),\n\t}\n}\n\nfunc stringToComponentIDOrZero(val string) uint16 {\n\t// See: https://developer.mozilla.org/en-US/docs/Web/API/RTCIceComponent\n\tswitch val {\n\tcase \"rtp\":\n\t\treturn 1\n\tcase \"rtcp\":\n\t\treturn 2\n\t}\n\treturn 0\n}\n\nfunc sessionDescriptionToValue(desc *SessionDescription) js.Value {\n\tif desc == nil {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(map[string]interface{}{\n\t\t\"type\": desc.Type.String(),\n\t\t\"sdp\":  desc.SDP,\n\t})\n}\n\nfunc valueToSessionDescription(descValue js.Value) *SessionDescription {\n\tif descValue.IsNull() || descValue.IsUndefined() {\n\t\treturn nil\n\t}\n\treturn &SessionDescription{\n\t\tType: NewSDPType(descValue.Get(\"type\").String()),\n\t\tSDP:  descValue.Get(\"sdp\").String(),\n\t}\n}\n\nfunc offerOptionsToValue(offerOptions *OfferOptions) js.Value {\n\tif offerOptions == nil {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(map[string]interface{}{\n\t\t\"iceRestart\":             offerOptions.ICERestart,\n\t\t\"voiceActivityDetection\": offerOptions.VoiceActivityDetection,\n\t})\n}\n\nfunc answerOptionsToValue(answerOptions *AnswerOptions) js.Value {\n\tif answerOptions == nil {\n\t\treturn js.Undefined()\n\t}\n\treturn js.ValueOf(map[string]interface{}{\n\t\t\"voiceActivityDetection\": answerOptions.VoiceActivityDetection,\n\t})\n}\n\nfunc iceCandidateInitToValue(candidate ICECandidateInit) js.Value {\n\treturn js.ValueOf(map[string]interface{}{\n\t\t\"candidate\":        candidate.Candidate,\n\t\t\"sdpMid\":           stringPointerToValue(candidate.SDPMid),\n\t\t\"sdpMLineIndex\":    uint16PointerToValue(candidate.SDPMLineIndex),\n\t\t\"usernameFragment\": stringPointerToValue(candidate.UsernameFragment),\n\t})\n}\n\nfunc dataChannelInitToValue(options *DataChannelInit) js.Value {\n\tif options == nil {\n\t\treturn js.Undefined()\n\t}\n\n\tmaxPacketLifeTime := uint16PointerToValue(options.MaxPacketLifeTime)\n\treturn js.ValueOf(map[string]interface{}{\n\t\t\"ordered\":           boolPointerToValue(options.Ordered),\n\t\t\"maxPacketLifeTime\": maxPacketLifeTime,\n\t\t// See https://bugs.chromium.org/p/chromium/issues/detail?id=696681\n\t\t// Chrome calls this \"maxRetransmitTime\"\n\t\t\"maxRetransmitTime\": maxPacketLifeTime,\n\t\t\"maxRetransmits\":    uint16PointerToValue(options.MaxRetransmits),\n\t\t\"protocol\":          stringPointerToValue(options.Protocol),\n\t\t\"negotiated\":        boolPointerToValue(options.Negotiated),\n\t\t\"id\":                uint16PointerToValue(options.ID),\n\t})\n}\n\nfunc rtpTransceiverInitInitToValue(init RTPTransceiverInit) js.Value {\n\treturn js.ValueOf(map[string]interface{}{\n\t\t\"direction\": init.Direction.String(),\n\t})\n}\n"
        },
        {
          "name": "peerconnection_js_test.go",
          "type": "blob",
          "size": 3.1591796875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"syscall/js\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestValueToICECandidate(t *testing.T) {\n\ttestCases := []struct {\n\t\tjsonCandidate string\n\t\texpect        ICECandidate\n\t}{\n\t\t{\n\t\t\t// Firefox-style ICECandidateInit:\n\t\t\t`{\"candidate\":\"1966762133 1 udp 2122260222 192.168.20.128 47298 typ srflx raddr 203.0.113.1 rport 5000\"}`,\n\t\t\tICECandidate{\n\t\t\t\tFoundation:     \"1966762133\",\n\t\t\t\tPriority:       2122260222,\n\t\t\t\tAddress:        \"192.168.20.128\",\n\t\t\t\tProtocol:       ICEProtocolUDP,\n\t\t\t\tPort:           47298,\n\t\t\t\tTyp:            ICECandidateTypeSrflx,\n\t\t\t\tComponent:      1,\n\t\t\t\tRelatedAddress: \"203.0.113.1\",\n\t\t\t\tRelatedPort:    5000,\n\t\t\t},\n\t\t}, {\n\t\t\t// Chrome/Webkit-style ICECandidate:\n\t\t\t`{\"foundation\":\"1966762134\", \"component\":\"rtp\", \"protocol\":\"udp\", \"priority\":2122260223, \"address\":\"192.168.20.129\", \"port\":47299, \"type\":\"host\", \"relatedAddress\":null}`,\n\t\t\tICECandidate{\n\t\t\t\tFoundation:     \"1966762134\",\n\t\t\t\tPriority:       2122260223,\n\t\t\t\tAddress:        \"192.168.20.129\",\n\t\t\t\tProtocol:       ICEProtocolUDP,\n\t\t\t\tPort:           47299,\n\t\t\t\tTyp:            ICECandidateTypeHost,\n\t\t\t\tComponent:      1,\n\t\t\t\tRelatedAddress: \"<null>\",\n\t\t\t\tRelatedPort:    0,\n\t\t\t},\n\t\t}, {\n\t\t\t// Both are present, Chrome/Webkit-style takes precedent:\n\t\t\t`{\"candidate\":\"1966762133 1 udp 2122260222 192.168.20.128 47298 typ srflx raddr 203.0.113.1 rport 5000\", \"foundation\":\"1966762134\", \"component\":\"rtp\", \"protocol\":\"udp\", \"priority\":2122260223, \"address\":\"192.168.20.129\", \"port\":47299, \"type\":\"host\", \"relatedAddress\":null}`,\n\t\t\tICECandidate{\n\t\t\t\tFoundation:     \"1966762134\",\n\t\t\t\tPriority:       2122260223,\n\t\t\t\tAddress:        \"192.168.20.129\",\n\t\t\t\tProtocol:       ICEProtocolUDP,\n\t\t\t\tPort:           47299,\n\t\t\t\tTyp:            ICECandidateTypeHost,\n\t\t\t\tComponent:      1,\n\t\t\t\tRelatedAddress: \"<null>\",\n\t\t\t\tRelatedPort:    0,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tv := map[string]interface{}{}\n\t\terr := json.Unmarshal([]byte(testCase.jsonCandidate), &v)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Case %d: bad test, got error: %v\", i, err)\n\t\t}\n\t\tval := *valueToICECandidate(js.ValueOf(v))\n\t\tval.statsID = \"\"\n\t\tassert.Equal(t, testCase.expect, val)\n\t}\n}\n\nfunc TestValueToICEServer(t *testing.T) {\n\ttestCases := []ICEServer{\n\t\t{\n\t\t\tURLs:           []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\tUsername:       \"unittest\",\n\t\t\tCredential:     \"placeholder\",\n\t\t\tCredentialType: ICECredentialTypePassword,\n\t\t},\n\t\t{\n\t\t\tURLs:           []string{\"turn:[2001:db8:1234:5678::1]?transport=udp\"},\n\t\t\tUsername:       \"unittest\",\n\t\t\tCredential:     \"placeholder\",\n\t\t\tCredentialType: ICECredentialTypePassword,\n\t\t},\n\t\t{\n\t\t\tURLs:     []string{\"turn:192.158.29.39?transport=udp\"},\n\t\t\tUsername: \"unittest\",\n\t\t\tCredential: OAuthCredential{\n\t\t\t\tMACKey:      \"WmtzanB3ZW9peFhtdm42NzUzNG0=\",\n\t\t\t\tAccessToken: \"AAwg3kPHWPfvk9bDFL936wYvkoctMADzQ5VhNDgeMR3+ZlZ35byg972fW8QjpEl7bx91YLBPFsIhsxloWcXPhA==\",\n\t\t\t},\n\t\t\tCredentialType: ICECredentialTypeOauth,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tv := iceServerToValue(testCase)\n\t\ts := valueToICEServer(v)\n\t\tassert.Equal(t, testCase, s)\n\t}\n}\n"
        },
        {
          "name": "peerconnection_media_test.go",
          "type": "blob",
          "size": 49.5830078125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/rtcp\"\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/transport/v3/vnet\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\terrIncomingTrackIDInvalid    = errors.New(\"incoming Track ID is invalid\")\n\terrIncomingTrackLabelInvalid = errors.New(\"incoming Track Label is invalid\")\n\terrNoTransceiverwithMid      = errors.New(\"no transceiver with mid\")\n)\n\n/*\nIntegration test for bi-directional peers\n\nThis asserts we can send RTP and RTCP both ways, and blocks until\neach side gets something (and asserts payload contents)\n*/\n// nolint: gocyclo\nfunc TestPeerConnection_Media_Sample(t *testing.T) {\n\tconst (\n\t\texpectedTrackID  = \"video\"\n\t\texpectedStreamID = \"pion\"\n\t)\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tawaitRTPRecv := make(chan bool)\n\tawaitRTPRecvClosed := make(chan bool)\n\tawaitRTPSend := make(chan bool)\n\n\tawaitRTCPSenderRecv := make(chan bool)\n\tawaitRTCPSenderSend := make(chan error)\n\n\tawaitRTCPReceiverRecv := make(chan error)\n\tawaitRTCPReceiverSend := make(chan error)\n\n\ttrackMetadataValid := make(chan error)\n\n\tpcAnswer.OnTrack(func(track *TrackRemote, receiver *RTPReceiver) {\n\t\tif track.ID() != expectedTrackID {\n\t\t\ttrackMetadataValid <- fmt.Errorf(\"%w: expected(%s) actual(%s)\", errIncomingTrackIDInvalid, expectedTrackID, track.ID())\n\t\t\treturn\n\t\t}\n\n\t\tif track.StreamID() != expectedStreamID {\n\t\t\ttrackMetadataValid <- fmt.Errorf(\"%w: expected(%s) actual(%s)\", errIncomingTrackLabelInvalid, expectedStreamID, track.StreamID())\n\t\t\treturn\n\t\t}\n\t\tclose(trackMetadataValid)\n\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\tif routineErr := pcAnswer.WriteRTCP([]rtcp.Packet{&rtcp.RapidResynchronizationRequest{SenderSSRC: uint32(track.SSRC()), MediaSSRC: uint32(track.SSRC())}}); routineErr != nil {\n\t\t\t\t\tawaitRTCPReceiverSend <- routineErr\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tselect {\n\t\t\t\tcase <-awaitRTCPSenderRecv:\n\t\t\t\t\tclose(awaitRTCPReceiverSend)\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tgo func() {\n\t\t\t_, _, routineErr := receiver.Read(make([]byte, 1400))\n\t\t\tif routineErr != nil {\n\t\t\t\tawaitRTCPReceiverRecv <- routineErr\n\t\t\t} else {\n\t\t\t\tclose(awaitRTCPReceiverRecv)\n\t\t\t}\n\t\t}()\n\n\t\thaveClosedAwaitRTPRecv := false\n\t\tfor {\n\t\t\tp, _, routineErr := track.ReadRTP()\n\t\t\tif routineErr != nil {\n\t\t\t\tclose(awaitRTPRecvClosed)\n\t\t\t\treturn\n\t\t\t} else if bytes.Equal(p.Payload, []byte{0x10, 0x00}) && !haveClosedAwaitRTPRecv {\n\t\t\t\thaveClosedAwaitRTPRecv = true\n\t\t\t\tclose(awaitRTPRecv)\n\t\t\t}\n\t\t}\n\t})\n\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, expectedTrackID, expectedStreamID)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsender, err := pcOffer.AddTrack(vp8Track)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\tif pcOffer.ICEConnectionState() != ICEConnectionStateConnected {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif routineErr := vp8Track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}); routineErr != nil {\n\t\t\t\tfmt.Println(routineErr)\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-awaitRTPRecv:\n\t\t\t\tclose(awaitRTPSend)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tparameters := sender.GetParameters()\n\n\t\tfor {\n\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\tif routineErr := pcOffer.WriteRTCP([]rtcp.Packet{&rtcp.PictureLossIndication{SenderSSRC: uint32(parameters.Encodings[0].SSRC), MediaSSRC: uint32(parameters.Encodings[0].SSRC)}}); routineErr != nil {\n\t\t\t\tawaitRTCPSenderSend <- routineErr\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-awaitRTCPReceiverRecv:\n\t\t\t\tclose(awaitRTCPSenderSend)\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tif _, _, routineErr := sender.Read(make([]byte, 1400)); routineErr == nil {\n\t\t\tclose(awaitRTCPSenderRecv)\n\t\t}\n\t}()\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\terr, ok := <-trackMetadataValid\n\tif ok {\n\t\tt.Fatal(err)\n\t}\n\n\t<-awaitRTPRecv\n\t<-awaitRTPSend\n\n\t<-awaitRTCPSenderRecv\n\tif err, ok = <-awaitRTCPSenderSend; ok {\n\t\tt.Fatal(err)\n\t}\n\n\t<-awaitRTCPReceiverRecv\n\tif err, ok = <-awaitRTCPReceiverSend; ok {\n\t\tt.Fatal(err)\n\t}\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n\t<-awaitRTPRecvClosed\n}\n\n/*\nPeerConnection should be able to be torn down at anytime\nThis test adds an input track and asserts\n\n* OnTrack doesn't fire since no video packets will arrive\n* No goroutine leaks\n* No deadlocks on shutdown\n*/\nfunc TestPeerConnection_Media_Shutdown(t *testing.T) {\n\ticeCompleteAnswer := make(chan struct{})\n\ticeCompleteOffer := make(chan struct{})\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeAudio, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\topusTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"audio\", \"pion1\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif _, err = pcOffer.AddTrack(opusTrack); err != nil {\n\t\tt.Fatal(err)\n\t} else if _, err = pcAnswer.AddTrack(vp8Track); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar onTrackFiredLock sync.Mutex\n\tonTrackFired := false\n\n\tpcAnswer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\tonTrackFiredLock.Lock()\n\t\tdefer onTrackFiredLock.Unlock()\n\t\tonTrackFired = true\n\t})\n\n\tpcAnswer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {\n\t\tif iceState == ICEConnectionStateConnected {\n\t\t\tclose(iceCompleteAnswer)\n\t\t}\n\t})\n\tpcOffer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {\n\t\tif iceState == ICEConnectionStateConnected {\n\t\t\tclose(iceCompleteOffer)\n\t\t}\n\t})\n\n\terr = signalPair(pcOffer, pcAnswer)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t<-iceCompleteAnswer\n\t<-iceCompleteOffer\n\n\t// Each PeerConnection should have one sender, one receiver and one transceiver\n\tfor _, pc := range []*PeerConnection{pcOffer, pcAnswer} {\n\t\tsenders := pc.GetSenders()\n\t\tif len(senders) != 1 {\n\t\t\tt.Errorf(\"Each PeerConnection should have one RTPSender, we have %d\", len(senders))\n\t\t}\n\n\t\treceivers := pc.GetReceivers()\n\t\tif len(receivers) != 2 {\n\t\t\tt.Errorf(\"Each PeerConnection should have two RTPReceivers, we have %d\", len(receivers))\n\t\t}\n\n\t\ttransceivers := pc.GetTransceivers()\n\t\tif len(transceivers) != 2 {\n\t\t\tt.Errorf(\"Each PeerConnection should have two RTPTransceivers, we have %d\", len(transceivers))\n\t\t}\n\t}\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n\n\tonTrackFiredLock.Lock()\n\tif onTrackFired {\n\t\tt.Fatalf(\"PeerConnection OnTrack fired even though we got no packets\")\n\t}\n\tonTrackFiredLock.Unlock()\n}\n\n/*\nIntegration test for behavior around media and disconnected peers\n\n* Sending RTP and RTCP to a disconnected Peer shouldn't return an error\n*/\nfunc TestPeerConnection_Media_Disconnected(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ts := SettingEngine{}\n\ts.SetICETimeouts(time.Second/2, time.Second/2, time.Second/8)\n\n\tm := &MediaEngine{}\n\tassert.NoError(t, m.RegisterDefaultCodecs())\n\n\tpcOffer, pcAnswer, wan := createVNetPair(t, nil)\n\n\tkeepPackets := &atomicBool{}\n\tkeepPackets.set(true)\n\n\t// Add a filter that monitors the traffic on the router\n\twan.AddChunkFilter(func(vnet.Chunk) bool {\n\t\treturn keepPackets.get()\n\t})\n\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvp8Sender, err := pcOffer.AddTrack(vp8Track)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thaveDisconnected := make(chan error)\n\tpcOffer.OnICEConnectionStateChange(func(iceState ICEConnectionState) {\n\t\tif iceState == ICEConnectionStateDisconnected {\n\t\t\tclose(haveDisconnected)\n\t\t} else if iceState == ICEConnectionStateConnected {\n\t\t\t// Assert that DTLS is done by pull remote certificate, don't tear down the PC early\n\t\t\tfor {\n\t\t\t\tif len(vp8Sender.Transport().GetRemoteCertificate()) != 0 {\n\t\t\t\t\tif pcAnswer.sctpTransport.association() != nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttime.Sleep(time.Second)\n\t\t\t}\n\n\t\t\tkeepPackets.set(false)\n\t\t}\n\t})\n\n\tif err = signalPair(pcOffer, pcAnswer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr, ok := <-haveDisconnected\n\tif ok {\n\t\tt.Fatal(err)\n\t}\n\tfor i := 0; i <= 5; i++ {\n\t\tif rtpErr := vp8Track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}); rtpErr != nil {\n\t\t\tt.Fatal(rtpErr)\n\t\t} else if rtcpErr := pcOffer.WriteRTCP([]rtcp.Packet{&rtcp.PictureLossIndication{MediaSSRC: 0}}); rtcpErr != nil {\n\t\t\tt.Fatal(rtcpErr)\n\t\t}\n\t}\n\n\tassert.NoError(t, wan.Stop())\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\ntype undeclaredSsrcLogger struct{ unhandledSimulcastError chan struct{} }\n\nfunc (u *undeclaredSsrcLogger) Trace(string)                  {}\nfunc (u *undeclaredSsrcLogger) Tracef(string, ...interface{}) {}\nfunc (u *undeclaredSsrcLogger) Debug(string)                  {}\nfunc (u *undeclaredSsrcLogger) Debugf(string, ...interface{}) {}\nfunc (u *undeclaredSsrcLogger) Info(string)                   {}\nfunc (u *undeclaredSsrcLogger) Infof(string, ...interface{})  {}\nfunc (u *undeclaredSsrcLogger) Warn(string)                   {}\nfunc (u *undeclaredSsrcLogger) Warnf(string, ...interface{})  {}\nfunc (u *undeclaredSsrcLogger) Error(string)                  {}\nfunc (u *undeclaredSsrcLogger) Errorf(format string, _ ...interface{}) {\n\tif format == incomingUnhandledRTPSsrc {\n\t\tclose(u.unhandledSimulcastError)\n\t}\n}\n\ntype undeclaredSsrcLoggerFactory struct{ unhandledSimulcastError chan struct{} }\n\nfunc (u *undeclaredSsrcLoggerFactory) NewLogger(string) logging.LeveledLogger {\n\treturn &undeclaredSsrcLogger{u.unhandledSimulcastError}\n}\n\n// Filter SSRC lines\nfunc filterSsrc(offer string) (filteredSDP string) {\n\tscanner := bufio.NewScanner(strings.NewReader(offer))\n\tfor scanner.Scan() {\n\t\tl := scanner.Text()\n\t\tif strings.HasPrefix(l, \"a=ssrc\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tfilteredSDP += l + \"\\n\"\n\t}\n\treturn\n}\n\n// If a SessionDescription has a single media section and no SSRC\n// assume that it is meant to handle all RTP packets\nfunc TestUndeclaredSSRC(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tt.Run(\"No SSRC\", func(t *testing.T) {\n\t\tpcOffer, pcAnswer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tvp8Writer, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pcOffer.AddTrack(vp8Writer)\n\t\tassert.NoError(t, err)\n\n\t\tonTrackFired := make(chan struct{})\n\t\tpcAnswer.OnTrack(func(trackRemote *TrackRemote, _ *RTPReceiver) {\n\t\t\tassert.Equal(t, trackRemote.StreamID(), vp8Writer.StreamID())\n\t\t\tassert.Equal(t, trackRemote.ID(), vp8Writer.ID())\n\t\t\tclose(onTrackFired)\n\t\t})\n\n\t\toffer, err := pcOffer.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\t\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\t\t<-offerGatheringComplete\n\n\t\toffer.SDP = filterSsrc(pcOffer.LocalDescription().SDP)\n\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\n\t\tanswer, err := pcAnswer.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t\t<-answerGatheringComplete\n\n\t\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\n\t\tsendVideoUntilDone(onTrackFired, t, []*TrackLocalStaticSample{vp8Writer})\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t})\n\n\tt.Run(\"Has RID\", func(t *testing.T) {\n\t\tunhandledSimulcastError := make(chan struct{})\n\n\t\tm := &MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\n\t\tpcOffer, pcAnswer, err := NewAPI(WithSettingEngine(SettingEngine{\n\t\t\tLoggerFactory: &undeclaredSsrcLoggerFactory{unhandledSimulcastError},\n\t\t}), WithMediaEngine(m)).newPair(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\tvp8Writer, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pcOffer.AddTrack(vp8Writer)\n\t\tassert.NoError(t, err)\n\n\t\toffer, err := pcOffer.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\t\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\t\t<-offerGatheringComplete\n\n\t\t// Append RID to end of SessionDescription. Will not be considered unhandled anymore\n\t\toffer.SDP = filterSsrc(pcOffer.LocalDescription().SDP) + \"a=\" + sdpAttributeRid + \"\\r\\n\"\n\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\n\t\tanswer, err := pcAnswer.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t\t<-answerGatheringComplete\n\n\t\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\n\t\tsendVideoUntilDone(unhandledSimulcastError, t, []*TrackLocalStaticSample{vp8Writer})\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t})\n}\n\nfunc TestAddTransceiverFromTrackSendOnly(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\ttrack, err := NewTrackLocalStaticSample(\n\t\tRTPCodecCapability{MimeType: \"audio/Opus\"},\n\t\t\"track-id\",\n\t\t\"stream-id\",\n\t)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\ttransceiver, err := pc.AddTransceiverFromTrack(track, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendonly,\n\t})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif transceiver.Receiver() != nil {\n\t\tt.Errorf(\"Transceiver shouldn't have a receiver\")\n\t}\n\n\tif transceiver.Sender() == nil {\n\t\tt.Errorf(\"Transceiver should have a sender\")\n\t}\n\n\tif len(pc.GetTransceivers()) != 1 {\n\t\tt.Errorf(\"PeerConnection should have one transceiver but has %d\", len(pc.GetTransceivers()))\n\t}\n\n\tif len(pc.GetSenders()) != 1 {\n\t\tt.Errorf(\"PeerConnection should have one sender but has %d\", len(pc.GetSenders()))\n\t}\n\n\toffer, err := pc.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif !offerMediaHasDirection(offer, RTPCodecTypeAudio, RTPTransceiverDirectionSendonly) {\n\t\tt.Errorf(\"Direction on SDP is not %s\", RTPTransceiverDirectionSendonly)\n\t}\n\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestAddTransceiverFromTrackSendRecv(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\ttrack, err := NewTrackLocalStaticSample(\n\t\tRTPCodecCapability{MimeType: \"audio/Opus\"},\n\t\t\"track-id\",\n\t\t\"stream-id\",\n\t)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\ttransceiver, err := pc.AddTransceiverFromTrack(track, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendrecv,\n\t})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif transceiver.Receiver() == nil {\n\t\tt.Errorf(\"Transceiver should have a receiver\")\n\t}\n\n\tif transceiver.Sender() == nil {\n\t\tt.Errorf(\"Transceiver should have a sender\")\n\t}\n\n\tif len(pc.GetTransceivers()) != 1 {\n\t\tt.Errorf(\"PeerConnection should have one transceiver but has %d\", len(pc.GetTransceivers()))\n\t}\n\n\toffer, err := pc.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif !offerMediaHasDirection(offer, RTPCodecTypeAudio, RTPTransceiverDirectionSendrecv) {\n\t\tt.Errorf(\"Direction on SDP is not %s\", RTPTransceiverDirectionSendrecv)\n\t}\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestAddTransceiverAddTrack_Reuse(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttr, err := pc.AddTransceiverFromKind(\n\t\tRTPCodecTypeVideo,\n\t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly},\n\t)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, []*RTPTransceiver{tr}, pc.GetTransceivers())\n\n\taddTrack := func() (TrackLocal, *RTPSender) {\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\t\tassert.NoError(t, err)\n\n\t\tsender, err := pc.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\treturn track, sender\n\t}\n\n\ttrack1, sender1 := addTrack()\n\tassert.Equal(t, 1, len(pc.GetTransceivers()))\n\tassert.Equal(t, sender1, tr.Sender())\n\tassert.Equal(t, track1, tr.Sender().Track())\n\trequire.NoError(t, pc.RemoveTrack(sender1))\n\n\ttrack2, _ := addTrack()\n\tassert.Equal(t, 1, len(pc.GetTransceivers()))\n\tassert.Equal(t, track2, tr.Sender().Track())\n\n\taddTrack()\n\tassert.Equal(t, 2, len(pc.GetTransceivers()))\n\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestAddTransceiverAddTrack_NewRTPSender_Error(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTransceiverFromKind(\n\t\tRTPCodecTypeVideo,\n\t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly},\n\t)\n\tassert.NoError(t, err)\n\n\tdtlsTransport := pc.dtlsTransport\n\tpc.dtlsTransport = nil\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTrack(track)\n\tassert.Error(t, err, \"DTLSTransport must not be nil\")\n\n\tassert.Equal(t, 1, len(pc.GetTransceivers()))\n\n\tpc.dtlsTransport = dtlsTransport\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestRtpSenderReceiver_ReadClose_Error(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttr, err := pc.AddTransceiverFromKind(\n\t\tRTPCodecTypeVideo,\n\t\tRTPTransceiverInit{Direction: RTPTransceiverDirectionSendrecv},\n\t)\n\tassert.NoError(t, err)\n\n\tsender, receiver := tr.Sender(), tr.Receiver()\n\tassert.NoError(t, sender.Stop())\n\t_, _, err = sender.Read(make([]byte, 0, 1400))\n\tassert.ErrorIs(t, err, io.ErrClosedPipe)\n\n\tassert.NoError(t, receiver.Stop())\n\t_, _, err = receiver.Read(make([]byte, 0, 1400))\n\tassert.ErrorIs(t, err, io.ErrClosedPipe)\n\n\tassert.NoError(t, pc.Close())\n}\n\n// nolint: dupl\nfunc TestAddTransceiverFromKind(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\ttransceiver, err := pc.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif transceiver.Receiver() == nil {\n\t\tt.Errorf(\"Transceiver should have a receiver\")\n\t}\n\n\tif transceiver.Sender() != nil {\n\t\tt.Errorf(\"Transceiver shouldn't have a sender\")\n\t}\n\n\toffer, err := pc.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tif !offerMediaHasDirection(offer, RTPCodecTypeVideo, RTPTransceiverDirectionRecvonly) {\n\t\tt.Errorf(\"Direction on SDP is not %s\", RTPTransceiverDirectionRecvonly)\n\t}\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestAddTransceiverFromTrackFailsRecvOnly(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\ttrack, err := NewTrackLocalStaticSample(\n\t\tRTPCodecCapability{MimeType: MimeTypeH264, SDPFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\"},\n\t\t\"track-id\",\n\t\t\"track-label\",\n\t)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\ttransceiver, err := pc.AddTransceiverFromTrack(track, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\n\tif transceiver != nil {\n\t\tt.Error(\"AddTransceiverFromTrack shouldn't succeed with Direction RTPTransceiverDirectionRecvonly\")\n\t}\n\n\tassert.NotNil(t, err)\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestPlanBMediaExchange(t *testing.T) {\n\trunTest := func(trackCount int, t *testing.T) {\n\t\taddSingleTrack := func(p *PeerConnection) *TrackLocalStaticSample {\n\t\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, fmt.Sprintf(\"video-%d\", util.RandUint32()), fmt.Sprintf(\"video-%d\", util.RandUint32()))\n\t\t\tassert.NoError(t, err)\n\n\t\t\t_, err = p.AddTrack(track)\n\t\t\tassert.NoError(t, err)\n\n\t\t\treturn track\n\t\t}\n\n\t\tpcOffer, err := NewPeerConnection(Configuration{SDPSemantics: SDPSemanticsPlanB})\n\t\tassert.NoError(t, err)\n\n\t\tpcAnswer, err := NewPeerConnection(Configuration{SDPSemantics: SDPSemanticsPlanB})\n\t\tassert.NoError(t, err)\n\n\t\tvar onTrackWaitGroup sync.WaitGroup\n\t\tonTrackWaitGroup.Add(trackCount)\n\t\tpcAnswer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\t\tonTrackWaitGroup.Done()\n\t\t})\n\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tonTrackWaitGroup.Wait()\n\t\t\tclose(done)\n\t\t}()\n\n\t\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\t\tassert.NoError(t, err)\n\n\t\toutboundTracks := []*TrackLocalStaticSample{}\n\t\tfor i := 0; i < trackCount; i++ {\n\t\t\toutboundTracks = append(outboundTracks, addSingleTrack(pcOffer))\n\t\t}\n\n\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t\tfunc() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-time.After(20 * time.Millisecond):\n\t\t\t\t\tfor _, track := range outboundTracks {\n\t\t\t\t\t\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}))\n\t\t\t\t\t}\n\t\t\t\tcase <-done:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t}\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tt.Run(\"Single Track\", func(t *testing.T) {\n\t\trunTest(1, t)\n\t})\n\tt.Run(\"Multi Track\", func(t *testing.T) {\n\t\trunTest(2, t)\n\t})\n}\n\n// TestPeerConnection_Start_Only_Negotiated_Senders tests that only\n// the current negotiated transceivers senders provided in an\n// offer/answer are started\nfunc TestPeerConnection_Start_Only_Negotiated_Senders(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\tdefer func() { assert.NoError(t, pcOffer.Close()) }()\n\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\tdefer func() { assert.NoError(t, pcAnswer.Close()) }()\n\n\ttrack1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion1\")\n\trequire.NoError(t, err)\n\n\tsender1, err := pcOffer.AddTrack(track1)\n\trequire.NoError(t, err)\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\t<-offerGatheringComplete\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t<-answerGatheringComplete\n\n\t// Add a new track between providing the offer and applying the answer\n\n\ttrack2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\trequire.NoError(t, err)\n\n\tsender2, err := pcOffer.AddTrack(track2)\n\trequire.NoError(t, err)\n\n\t// apply answer so we'll test generateMatchedSDP\n\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\n\t// Wait for senders to be started by startTransports spawned goroutine\n\tpcOffer.ops.Done()\n\n\t// sender1 should be started but sender2 should not be started\n\tassert.True(t, sender1.hasSent(), \"sender1 is not started but should be started\")\n\tassert.False(t, sender2.hasSent(), \"sender2 is started but should not be started\")\n}\n\n// TestPeerConnection_Start_Right_Receiver tests that the right\n// receiver (the receiver which transceiver has the same media section as the track)\n// is started for the specified track\nfunc TestPeerConnection_Start_Right_Receiver(t *testing.T) {\n\tisTransceiverReceiverStarted := func(pc *PeerConnection, mid string) (bool, error) {\n\t\tfor _, transceiver := range pc.GetTransceivers() {\n\t\t\tif transceiver.Mid() != mid {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn transceiver.Receiver() != nil && transceiver.Receiver().haveReceived(), nil\n\t\t}\n\t\treturn false, fmt.Errorf(\"%w: %q\", errNoTransceiverwithMid, mid)\n\t}\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\trequire.NoError(t, err)\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tassert.NoError(t, err)\n\n\ttrack1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion1\")\n\trequire.NoError(t, err)\n\n\tsender1, err := pcOffer.AddTrack(track1)\n\trequire.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\t// transceiver with mid 0 should be started\n\tstarted, err := isTransceiverReceiverStarted(pcAnswer, \"0\")\n\tassert.NoError(t, err)\n\tassert.True(t, started, \"transceiver with mid 0 should be started\")\n\n\t// Remove track\n\tassert.NoError(t, pcOffer.RemoveTrack(sender1))\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\t// transceiver with mid 0 should not be started\n\tstarted, err = isTransceiverReceiverStarted(pcAnswer, \"0\")\n\tassert.NoError(t, err)\n\tassert.False(t, started, \"transceiver with mid 0 should not be started\")\n\n\t// Add a new transceiver (we're not using AddTrack since it'll reuse the transceiver with mid 0)\n\t_, err = pcOffer.AddTransceiverFromTrack(track1)\n\tassert.NoError(t, err)\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\t// transceiver with mid 0 should not be started\n\tstarted, err = isTransceiverReceiverStarted(pcAnswer, \"0\")\n\tassert.NoError(t, err)\n\tassert.False(t, started, \"transceiver with mid 0 should not be started\")\n\t// transceiver with mid 2 should be started\n\tstarted, err = isTransceiverReceiverStarted(pcAnswer, \"2\")\n\tassert.NoError(t, err)\n\tassert.True(t, started, \"transceiver with mid 2 should be started\")\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnection_Simulcast_Probe(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30) //nolint\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\t// Assert that failed Simulcast probing doesn't cause\n\t// the handleUndeclaredSSRC to be leaked\n\tt.Run(\"Leak\", func(t *testing.T) {\n\t\ttrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\t\tassert.NoError(t, err)\n\n\t\tofferer, answerer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\t_, err = offerer.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\tticker := time.NewTicker(time.Millisecond * 20)\n\t\tdefer ticker.Stop()\n\t\ttestFinished := make(chan struct{})\n\t\tseenFiveStreams, seenFiveStreamsCancel := context.WithCancel(context.Background())\n\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-testFinished:\n\t\t\t\t\treturn\n\t\t\t\tcase <-ticker.C:\n\t\t\t\t\tanswerer.dtlsTransport.lock.Lock()\n\t\t\t\t\tif len(answerer.dtlsTransport.simulcastStreams) >= 5 {\n\t\t\t\t\t\tseenFiveStreamsCancel()\n\t\t\t\t\t}\n\t\t\t\t\tanswerer.dtlsTransport.lock.Unlock()\n\n\t\t\t\t\ttrack.mu.Lock()\n\t\t\t\t\tif len(track.bindings) == 1 {\n\t\t\t\t\t\t_, err = track.bindings[0].writeStream.WriteRTP(&rtp.Header{\n\t\t\t\t\t\t\tVersion: 2,\n\t\t\t\t\t\t\tSSRC:    util.RandUint32(),\n\t\t\t\t\t\t}, []byte{0, 1, 2, 3, 4, 5})\n\t\t\t\t\t\tassert.NoError(t, err)\n\t\t\t\t\t}\n\t\t\t\t\ttrack.mu.Unlock()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tassert.NoError(t, signalPair(offerer, answerer))\n\n\t\tpeerConnectionConnected := untilConnectionState(PeerConnectionStateConnected, offerer, answerer)\n\t\tpeerConnectionConnected.Wait()\n\n\t\t<-seenFiveStreams.Done()\n\n\t\tclosePairNow(t, offerer, answerer)\n\t\tclose(testFinished)\n\t})\n\n\t// Assert that NonSimulcast Traffic isn't incorrectly broken by the probe\n\tt.Run(\"Break NonSimulcast\", func(t *testing.T) {\n\t\tunhandledSimulcastError := make(chan struct{})\n\n\t\tm := &MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\t\tassert.NoError(t, ConfigureSimulcastExtensionHeaders(m))\n\n\t\tpcOffer, pcAnswer, err := NewAPI(WithSettingEngine(SettingEngine{\n\t\t\tLoggerFactory: &undeclaredSsrcLoggerFactory{unhandledSimulcastError},\n\t\t}), WithMediaEngine(m)).newPair(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\tfirstTrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"firstTrack\", \"firstTrack\")\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pcOffer.AddTrack(firstTrack)\n\t\tassert.NoError(t, err)\n\n\t\tsecondTrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"secondTrack\", \"secondTrack\")\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pcOffer.AddTrack(secondTrack)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, signalPairWithModification(pcOffer, pcAnswer, func(sessionDescription string) (filtered string) {\n\t\t\tshouldDiscard := false\n\n\t\t\tscanner := bufio.NewScanner(strings.NewReader(sessionDescription))\n\t\t\tfor scanner.Scan() {\n\t\t\t\tif strings.HasPrefix(scanner.Text(), \"m=video\") {\n\t\t\t\t\tshouldDiscard = !shouldDiscard\n\t\t\t\t} else if strings.HasPrefix(scanner.Text(), \"a=group:BUNDLE\") {\n\t\t\t\t\tfiltered += \"a=group:BUNDLE 1 2\\r\\n\"\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif !shouldDiscard {\n\t\t\t\t\tfiltered += scanner.Text() + \"\\r\\n\"\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}))\n\n\t\tpeerConnectionConnected := untilConnectionState(PeerConnectionStateConnected, pcOffer, pcAnswer)\n\t\tpeerConnectionConnected.Wait()\n\n\t\tsequenceNumber := uint16(0)\n\t\tsendRTPPacket := func() {\n\t\t\tsequenceNumber++\n\t\t\tassert.NoError(t, firstTrack.WriteRTP(&rtp.Packet{\n\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t},\n\t\t\t\tPayload: []byte{0x00},\n\t\t\t}))\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\t\t}\n\n\t\tfor ; sequenceNumber <= 5; sequenceNumber++ {\n\t\t\tsendRTPPacket()\n\t\t}\n\n\t\ttrackRemoteChan := make(chan *TrackRemote, 1)\n\t\tpcAnswer.OnTrack(func(trackRemote *TrackRemote, _ *RTPReceiver) {\n\t\t\ttrackRemoteChan <- trackRemote\n\t\t})\n\n\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t\ttrackRemote := func() *TrackRemote {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase t := <-trackRemoteChan:\n\t\t\t\t\treturn t\n\t\t\t\tdefault:\n\t\t\t\t\tsendRTPPacket()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tfunc() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase <-unhandledSimulcastError:\n\t\t\t\t\treturn\n\t\t\t\tdefault:\n\t\t\t\t\tsendRTPPacket()\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t_, _, err = trackRemote.Read(make([]byte, 1500))\n\t\tassert.NoError(t, err)\n\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t})\n}\n\n// Assert that CreateOffer returns an error for a RTPSender with no codecs\n// pion/webrtc#1702\nfunc TestPeerConnection_CreateOffer_NoCodecs(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tm := &MediaEngine{}\n\n\tpc, err := NewAPI(WithMediaEngine(m)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = pc.AddTrack(track)\n\tassert.NoError(t, err)\n\n\t_, err = pc.CreateOffer(nil)\n\tassert.Equal(t, err, ErrSenderWithNoCodecs)\n\n\tassert.NoError(t, pc.Close())\n}\n\n// Assert that AddTrack is thread-safe\nfunc TestPeerConnection_RaceReplaceTrack(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\taddTrack := func() *TrackLocalStaticSample {\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\t\tassert.NoError(t, err)\n\t\t_, err = pc.AddTrack(track)\n\t\tassert.NoError(t, err)\n\t\treturn track\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\taddTrack()\n\t}\n\tfor _, tr := range pc.GetTransceivers() {\n\t\tassert.NoError(t, pc.RemoveTrack(tr.Sender()))\n\t}\n\n\tvar wg sync.WaitGroup\n\ttracks := make([]*TrackLocalStaticSample, 10)\n\twg.Add(10)\n\tfor i := 0; i < 10; i++ {\n\t\tgo func(j int) {\n\t\t\ttracks[j] = addTrack()\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\twg.Wait()\n\n\tfor _, track := range tracks {\n\t\thave := false\n\t\tfor _, t := range pc.GetTransceivers() {\n\t\t\tif t.Sender() != nil && t.Sender().Track() == track {\n\t\t\t\thave = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !have {\n\t\t\tt.Errorf(\"track was added but not found on senders\")\n\t\t}\n\t}\n\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestPeerConnection_Simulcast(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\trids := []string{\"a\", \"b\", \"c\"}\n\n\tt.Run(\"E2E\", func(t *testing.T) {\n\t\tpcOffer, pcAnswer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tvp8WriterA, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[0]))\n\t\tassert.NoError(t, err)\n\n\t\tvp8WriterB, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[1]))\n\t\tassert.NoError(t, err)\n\n\t\tvp8WriterC, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[2]))\n\t\tassert.NoError(t, err)\n\n\t\tsender, err := pcOffer.AddTrack(vp8WriterA)\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, sender)\n\n\t\tassert.NoError(t, sender.AddEncoding(vp8WriterB))\n\t\tassert.NoError(t, sender.AddEncoding(vp8WriterC))\n\n\t\tvar ridMapLock sync.RWMutex\n\t\tridMap := map[string]int{}\n\n\t\tassertRidCorrect := func(t *testing.T) {\n\t\t\tridMapLock.Lock()\n\t\t\tdefer ridMapLock.Unlock()\n\n\t\t\tfor _, rid := range rids {\n\t\t\t\tassert.Equal(t, ridMap[rid], 1)\n\t\t\t}\n\t\t\tassert.Equal(t, len(ridMap), 3)\n\t\t}\n\n\t\tridsFullfilled := func() bool {\n\t\t\tridMapLock.Lock()\n\t\t\tdefer ridMapLock.Unlock()\n\n\t\t\tridCount := len(ridMap)\n\t\t\treturn ridCount == 3\n\t\t}\n\n\t\tpcAnswer.OnTrack(func(trackRemote *TrackRemote, _ *RTPReceiver) {\n\t\t\tridMapLock.Lock()\n\t\t\tdefer ridMapLock.Unlock()\n\t\t\tridMap[trackRemote.RID()] = ridMap[trackRemote.RID()] + 1\n\t\t})\n\n\t\tparameters := sender.GetParameters()\n\t\tassert.Equal(t, \"a\", parameters.Encodings[0].RID)\n\t\tassert.Equal(t, \"b\", parameters.Encodings[1].RID)\n\t\tassert.Equal(t, \"c\", parameters.Encodings[2].RID)\n\n\t\tvar midID, ridID uint8\n\t\tfor _, extension := range parameters.HeaderExtensions {\n\t\t\tswitch extension.URI {\n\t\t\tcase sdp.SDESMidURI:\n\t\t\t\tmidID = uint8(extension.ID)\n\t\t\tcase sdp.SDESRTPStreamIDURI:\n\t\t\t\tridID = uint8(extension.ID)\n\t\t\t}\n\t\t}\n\t\tassert.NotZero(t, midID)\n\t\tassert.NotZero(t, ridID)\n\n\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t\t// padding only packets should not affect simulcast probe\n\t\tvar sequenceNumber uint16\n\t\tfor sequenceNumber = 0; sequenceNumber < simulcastProbeCount+10; sequenceNumber++ {\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tfor _, track := range []*TrackLocalStaticRTP{vp8WriterA, vp8WriterB, vp8WriterC} {\n\t\t\t\tpkt := &rtp.Packet{\n\t\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\t\tVersion:        2,\n\t\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\t\tPayloadType:    96,\n\t\t\t\t\t\tPadding:        true,\n\t\t\t\t\t},\n\t\t\t\t\tPayload: []byte{0x00, 0x02},\n\t\t\t\t}\n\n\t\t\t\tassert.NoError(t, track.WriteRTP(pkt))\n\t\t\t}\n\t\t}\n\t\tassert.False(t, ridsFullfilled(), \"Simulcast probe should not be fulfilled by padding only packets\")\n\n\t\tfor ; !ridsFullfilled(); sequenceNumber++ {\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tfor _, track := range []*TrackLocalStaticRTP{vp8WriterA, vp8WriterB, vp8WriterC} {\n\t\t\t\tpkt := &rtp.Packet{\n\t\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\t\tVersion:        2,\n\t\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\t\tPayloadType:    96,\n\t\t\t\t\t},\n\t\t\t\t\tPayload: []byte{0x00},\n\t\t\t\t}\n\t\t\t\tassert.NoError(t, pkt.Header.SetExtension(midID, []byte(\"0\")))\n\t\t\t\tassert.NoError(t, pkt.Header.SetExtension(ridID, []byte(track.RID())))\n\n\t\t\t\tassert.NoError(t, track.WriteRTP(pkt))\n\t\t\t}\n\t\t}\n\n\t\tassertRidCorrect(t)\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t})\n\n\tt.Run(\"RTCP\", func(t *testing.T) {\n\t\tpcOffer, pcAnswer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tvp8WriterA, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[0]))\n\t\tassert.NoError(t, err)\n\n\t\tvp8WriterB, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[1]))\n\t\tassert.NoError(t, err)\n\n\t\tvp8WriterC, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[2]))\n\t\tassert.NoError(t, err)\n\n\t\tsender, err := pcOffer.AddTrack(vp8WriterA)\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, sender)\n\n\t\tassert.NoError(t, sender.AddEncoding(vp8WriterB))\n\t\tassert.NoError(t, sender.AddEncoding(vp8WriterC))\n\n\t\trtcpCounter := uint64(0)\n\t\tpcAnswer.OnTrack(func(trackRemote *TrackRemote, receiver *RTPReceiver) {\n\t\t\t_, _, simulcastReadErr := receiver.ReadSimulcastRTCP(trackRemote.RID())\n\t\t\tassert.NoError(t, simulcastReadErr)\n\t\t\tatomic.AddUint64(&rtcpCounter, 1)\n\t\t})\n\n\t\tvar midID, ridID uint8\n\t\tfor _, extension := range sender.GetParameters().HeaderExtensions {\n\t\t\tswitch extension.URI {\n\t\t\tcase sdp.SDESMidURI:\n\t\t\t\tmidID = uint8(extension.ID)\n\t\t\tcase sdp.SDESRTPStreamIDURI:\n\t\t\t\tridID = uint8(extension.ID)\n\t\t\t}\n\t\t}\n\t\tassert.NotZero(t, midID)\n\t\tassert.NotZero(t, ridID)\n\n\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t\tfor sequenceNumber := uint16(0); atomic.LoadUint64(&rtcpCounter) < 3; sequenceNumber++ {\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tfor _, track := range []*TrackLocalStaticRTP{vp8WriterA, vp8WriterB, vp8WriterC} {\n\t\t\t\tpkt := &rtp.Packet{\n\t\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\t\tVersion:        2,\n\t\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\t\tPayloadType:    96,\n\t\t\t\t\t},\n\t\t\t\t\tPayload: []byte{0x00},\n\t\t\t\t}\n\t\t\t\tassert.NoError(t, pkt.Header.SetExtension(midID, []byte(\"0\")))\n\t\t\t\tassert.NoError(t, pkt.Header.SetExtension(ridID, []byte(track.RID())))\n\n\t\t\t\tassert.NoError(t, track.WriteRTP(pkt))\n\t\t\t}\n\t\t}\n\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t})\n}\n\ntype simulcastTestTrackLocal struct {\n\t*TrackLocalStaticRTP\n}\n\n// don't use ssrc&payload in bindings to let the test write different stream packets.\nfunc (s *simulcastTestTrackLocal) WriteRTP(pkt *rtp.Packet) error {\n\tpacket := getPacketAllocationFromPool()\n\n\tdefer resetPacketPoolAllocation(packet)\n\n\t*packet = *pkt\n\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\twriteErrs := []error{}\n\n\tfor _, b := range s.bindings {\n\t\tif _, err := b.writeStream.WriteRTP(&packet.Header, packet.Payload); err != nil {\n\t\t\twriteErrs = append(writeErrs, err)\n\t\t}\n\t}\n\n\treturn util.FlattenErrs(writeErrs)\n}\n\nfunc TestPeerConnection_Simulcast_RTX(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\trids := []string{\"a\", \"b\"}\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\tvp8WriterAStatic, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[0]))\n\tassert.NoError(t, err)\n\n\tvp8WriterBStatic, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\", WithRTPStreamID(rids[1]))\n\tassert.NoError(t, err)\n\n\tvp8WriterA, vp8WriterB := &simulcastTestTrackLocal{vp8WriterAStatic}, &simulcastTestTrackLocal{vp8WriterBStatic}\n\n\tsender, err := pcOffer.AddTrack(vp8WriterA)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, sender)\n\n\tassert.NoError(t, sender.AddEncoding(vp8WriterB))\n\n\tvar ridMapLock sync.RWMutex\n\tridMap := map[string]int{}\n\n\tassertRidCorrect := func(t *testing.T) {\n\t\tridMapLock.Lock()\n\t\tdefer ridMapLock.Unlock()\n\n\t\tfor _, rid := range rids {\n\t\t\tassert.Equal(t, ridMap[rid], 1)\n\t\t}\n\t\tassert.Equal(t, len(ridMap), 2)\n\t}\n\n\tridsFullfilled := func() bool {\n\t\tridMapLock.Lock()\n\t\tdefer ridMapLock.Unlock()\n\n\t\tridCount := len(ridMap)\n\t\treturn ridCount == 2\n\t}\n\n\tvar rtxPacketRead atomic.Int32\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\n\tpcAnswer.OnTrack(func(trackRemote *TrackRemote, _ *RTPReceiver) {\n\t\tridMapLock.Lock()\n\t\tridMap[trackRemote.RID()] = ridMap[trackRemote.RID()] + 1\n\t\tridMapLock.Unlock()\n\n\t\tdefer wg.Done()\n\n\t\tfor {\n\t\t\t_, attr, rerr := trackRemote.ReadRTP()\n\t\t\tif rerr != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif pt, ok := attr.Get(AttributeRtxPayloadType).(byte); ok {\n\t\t\t\tif pt == 97 {\n\t\t\t\t\trtxPacketRead.Add(1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tparameters := sender.GetParameters()\n\tassert.Equal(t, \"a\", parameters.Encodings[0].RID)\n\tassert.Equal(t, \"b\", parameters.Encodings[1].RID)\n\n\tvar midID, ridID, rsid uint8\n\tfor _, extension := range parameters.HeaderExtensions {\n\t\tswitch extension.URI {\n\t\tcase sdp.SDESMidURI:\n\t\t\tmidID = uint8(extension.ID)\n\t\tcase sdp.SDESRTPStreamIDURI:\n\t\t\tridID = uint8(extension.ID)\n\t\tcase sdesRepairRTPStreamIDURI:\n\t\t\trsid = uint8(extension.ID)\n\t\t}\n\t}\n\tassert.NotZero(t, midID)\n\tassert.NotZero(t, ridID)\n\tassert.NotZero(t, rsid)\n\n\terr = signalPairWithModification(pcOffer, pcAnswer, func(sdp string) string {\n\t\t// Original chrome sdp contains no ssrc info https://pastebin.com/raw/JTjX6zg6\n\t\tre := regexp.MustCompile(\"(?m)[\\r\\n]+^.*a=ssrc.*$\")\n\t\tres := re.ReplaceAllString(sdp, \"\")\n\t\treturn res\n\t})\n\tassert.NoError(t, err)\n\n\t// padding only packets should not affect simulcast probe\n\tvar sequenceNumber uint16\n\tfor sequenceNumber = 0; sequenceNumber < simulcastProbeCount+10; sequenceNumber++ {\n\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\tfor i, track := range []*simulcastTestTrackLocal{vp8WriterA, vp8WriterB} {\n\t\t\tpkt := &rtp.Packet{\n\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\tPayloadType:    96,\n\t\t\t\t\tPadding:        true,\n\t\t\t\t\tSSRC:           uint32(i + 1),\n\t\t\t\t},\n\t\t\t\tPayload: []byte{0x00, 0x02},\n\t\t\t}\n\n\t\t\tassert.NoError(t, track.WriteRTP(pkt))\n\t\t}\n\t}\n\tassert.False(t, ridsFullfilled(), \"Simulcast probe should not be fulfilled by padding only packets\")\n\n\tfor ; !ridsFullfilled(); sequenceNumber++ {\n\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\tfor i, track := range []*simulcastTestTrackLocal{vp8WriterA, vp8WriterB} {\n\t\t\tpkt := &rtp.Packet{\n\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\tPayloadType:    96,\n\t\t\t\t\tSSRC:           uint32(i + 1),\n\t\t\t\t},\n\t\t\t\tPayload: []byte{0x00},\n\t\t\t}\n\t\t\tassert.NoError(t, pkt.Header.SetExtension(midID, []byte(\"0\")))\n\t\t\tassert.NoError(t, pkt.Header.SetExtension(ridID, []byte(track.RID())))\n\n\t\t\tassert.NoError(t, track.WriteRTP(pkt))\n\t\t}\n\t}\n\n\tassertRidCorrect(t)\n\n\tfor i := 0; i < simulcastProbeCount+10; i++ {\n\t\tsequenceNumber++\n\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\tfor j, track := range []*simulcastTestTrackLocal{vp8WriterA, vp8WriterB} {\n\t\t\tpkt := &rtp.Packet{\n\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\tPayloadType:    97,\n\t\t\t\t\tSSRC:           uint32(100 + j),\n\t\t\t\t},\n\t\t\t\tPayload: []byte{0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t\t}\n\t\t\tassert.NoError(t, pkt.Header.SetExtension(midID, []byte(\"0\")))\n\t\t\tassert.NoError(t, pkt.Header.SetExtension(ridID, []byte(track.RID())))\n\t\t\tassert.NoError(t, pkt.Header.SetExtension(rsid, []byte(track.RID())))\n\n\t\t\tassert.NoError(t, track.WriteRTP(pkt))\n\t\t}\n\t}\n\n\tfor ; rtxPacketRead.Load() == 0; sequenceNumber++ {\n\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\tfor i, track := range []*simulcastTestTrackLocal{vp8WriterA, vp8WriterB} {\n\t\t\tpkt := &rtp.Packet{\n\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\tPayloadType:    96,\n\t\t\t\t\tSSRC:           uint32(i + 1),\n\t\t\t\t},\n\t\t\t\tPayload: []byte{0x00},\n\t\t\t}\n\t\t\tassert.NoError(t, pkt.Header.SetExtension(midID, []byte(\"0\")))\n\t\t\tassert.NoError(t, pkt.Header.SetExtension(ridID, []byte(track.RID())))\n\n\t\t\tassert.NoError(t, track.WriteRTP(pkt))\n\t\t}\n\t}\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n\n\twg.Wait()\n\n\tassert.Greater(t, rtxPacketRead.Load(), int32(0), \"no rtx packet read\")\n}\n\n// Everytime we receive a new SSRC we probe it and try to determine the proper way to handle it.\n// In most cases a Track explicitly declares a SSRC and a OnTrack is fired. In two cases we don't\n// know the SSRC ahead of time\n// * Undeclared SSRC in a single media section (https://github.com/pion/webrtc/issues/880)\n// * Simulcast\n//\n// The Undeclared SSRC processing code would run before Simulcast. If a Simulcast Offer/Answer only\n// contained one Media Section we would never fire the OnTrack. We would assume it was a failed\n// Undeclared SSRC processing. This test asserts that we properly handled this.\nfunc TestPeerConnection_Simulcast_NoDataChannel(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcSender, pcReceiver, err := newPair()\n\tassert.NoError(t, err)\n\n\tvar wg sync.WaitGroup\n\twg.Add(4)\n\n\tvar connectionWg sync.WaitGroup\n\tconnectionWg.Add(2)\n\n\tconnectionStateChangeHandler := func(state PeerConnectionState) {\n\t\tif state == PeerConnectionStateConnected {\n\t\t\tconnectionWg.Done()\n\t\t}\n\t}\n\n\tpcSender.OnConnectionStateChange(connectionStateChangeHandler)\n\tpcReceiver.OnConnectionStateChange(connectionStateChangeHandler)\n\n\tpcReceiver.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\tdefer wg.Done()\n\t})\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tvp8WriterA, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"a\"))\n\t\tassert.NoError(t, err)\n\n\t\tsender, err := pcSender.AddTrack(vp8WriterA)\n\t\tassert.NoError(t, err)\n\t\tassert.NotNil(t, sender)\n\n\t\tvp8WriterB, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"b\"))\n\t\tassert.NoError(t, err)\n\t\terr = sender.AddEncoding(vp8WriterB)\n\t\tassert.NoError(t, err)\n\n\t\tvp8WriterC, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"c\"))\n\t\tassert.NoError(t, err)\n\t\terr = sender.AddEncoding(vp8WriterC)\n\t\tassert.NoError(t, err)\n\n\t\tparameters := sender.GetParameters()\n\t\tvar midID, ridID, rsidID uint8\n\t\tfor _, extension := range parameters.HeaderExtensions {\n\t\t\tswitch extension.URI {\n\t\t\tcase sdp.SDESMidURI:\n\t\t\t\tmidID = uint8(extension.ID)\n\t\t\tcase sdp.SDESRTPStreamIDURI:\n\t\t\t\tridID = uint8(extension.ID)\n\t\t\tcase sdesRepairRTPStreamIDURI:\n\t\t\t\trsidID = uint8(extension.ID)\n\t\t\t}\n\t\t}\n\t\tassert.NotZero(t, midID)\n\t\tassert.NotZero(t, ridID)\n\t\tassert.NotZero(t, rsidID)\n\n\t\t// signaling\n\t\tofferSDP, err := pcSender.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\t\terr = pcSender.SetLocalDescription(offerSDP)\n\t\tassert.NoError(t, err)\n\n\t\terr = pcReceiver.SetRemoteDescription(offerSDP)\n\t\tassert.NoError(t, err)\n\t\tanswerSDP, err := pcReceiver.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tanswerGatheringComplete := GatheringCompletePromise(pcReceiver)\n\t\terr = pcReceiver.SetLocalDescription(answerSDP)\n\t\tassert.NoError(t, err)\n\t\t<-answerGatheringComplete\n\n\t\tassert.NoError(t, pcSender.SetRemoteDescription(*pcReceiver.LocalDescription()))\n\n\t\tconnectionWg.Wait()\n\n\t\tvar seqNo uint16\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tpkt := &rtp.Packet{\n\t\t\t\tHeader: rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSequenceNumber: seqNo,\n\t\t\t\t\tPayloadType:    96,\n\t\t\t\t},\n\t\t\t\tPayload: []byte{0x00, 0x00},\n\t\t\t}\n\n\t\t\tassert.NoError(t, pkt.SetExtension(ridID, []byte(\"a\")))\n\t\t\tassert.NoError(t, pkt.SetExtension(midID, []byte(sender.rtpTransceiver.Mid())))\n\t\t\tassert.NoError(t, vp8WriterA.WriteRTP(pkt))\n\n\t\t\tassert.NoError(t, pkt.SetExtension(ridID, []byte(\"b\")))\n\t\t\tassert.NoError(t, pkt.SetExtension(midID, []byte(sender.rtpTransceiver.Mid())))\n\t\t\tassert.NoError(t, vp8WriterB.WriteRTP(pkt))\n\n\t\t\tassert.NoError(t, pkt.SetExtension(ridID, []byte(\"c\")))\n\t\t\tassert.NoError(t, pkt.SetExtension(midID, []byte(sender.rtpTransceiver.Mid())))\n\t\t\tassert.NoError(t, vp8WriterC.WriteRTP(pkt))\n\n\t\t\tseqNo++\n\t\t}\n\t}()\n\n\twg.Wait()\n\n\tclosePairNow(t, pcSender, pcReceiver)\n}\n\n// Check that PayloadType of 0 is handled correctly. At one point\n// we incorrectly assumed 0 meant an invalid stream and wouldn't update things\n// properly\nfunc TestPeerConnection_Zero_PayloadType(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 5)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\trequire.NoError(t, err)\n\n\taudioTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypePCMU}, \"audio\", \"audio\")\n\trequire.NoError(t, err)\n\n\t_, err = pcOffer.AddTrack(audioTrack)\n\trequire.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\ttrackFired := make(chan struct{})\n\n\tpcAnswer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\trequire.Equal(t, track.Codec().MimeType, MimeTypePCMU)\n\t\tclose(trackFired)\n\t})\n\n\tfunc() {\n\t\tticker := time.NewTicker(20 * time.Millisecond)\n\t\tdefer ticker.Stop()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-trackFired:\n\t\t\t\treturn\n\t\t\tcase <-ticker.C:\n\t\t\t\tif routineErr := audioTrack.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}); routineErr != nil {\n\t\t\t\t\tfmt.Println(routineErr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Assert that NACKs work E2E with no extra configuration. If media is sent over a lossy connection\n// the user gets retransmitted RTP packets with no extra configuration\nfunc Test_PeerConnection_RTX_E2E(t *testing.T) {\n\tdefer test.TimeOut(time.Second * 30).Stop()\n\n\tpcOffer, pcAnswer, wan := createVNetPair(t, nil)\n\n\twan.AddChunkFilter(func(vnet.Chunk) bool {\n\t\treturn rand.Intn(5) != 4 //nolint: gosec\n\t})\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"track-id\", \"stream-id\")\n\tassert.NoError(t, err)\n\n\trtpSender, err := pcOffer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tgo func() {\n\t\trtcpBuf := make([]byte, 1500)\n\t\tfor {\n\t\t\tif _, _, rtcpErr := rtpSender.Read(rtcpBuf); rtcpErr != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\trtxSsrc := rtpSender.GetParameters().Encodings[0].RTX.SSRC\n\tssrc := rtpSender.GetParameters().Encodings[0].SSRC\n\n\trtxRead, rtxReadCancel := context.WithCancel(context.Background())\n\tpcAnswer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tfor {\n\t\t\tpkt, attributes, readRTPErr := track.ReadRTP()\n\t\t\tif errors.Is(readRTPErr, io.EOF) {\n\t\t\t\treturn\n\t\t\t} else if pkt.PayloadType == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tassert.NotNil(t, pkt)\n\t\t\tassert.Equal(t, pkt.SSRC, uint32(ssrc))\n\t\t\tassert.Equal(t, pkt.PayloadType, uint8(96))\n\n\t\t\trtxPayloadType := attributes.Get(AttributeRtxPayloadType)\n\t\t\trtxSequenceNumber := attributes.Get(AttributeRtxSequenceNumber)\n\t\t\trtxSSRC := attributes.Get(AttributeRtxSsrc)\n\t\t\tif rtxPayloadType != nil && rtxSequenceNumber != nil && rtxSSRC != nil {\n\t\t\t\tassert.Equal(t, rtxPayloadType, uint8(97))\n\t\t\t\tassert.Equal(t, rtxSSRC, uint32(rtxSsrc))\n\n\t\t\t\trtxReadCancel()\n\t\t\t}\n\t\t}\n\t})\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tfunc() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-time.After(20 * time.Millisecond):\n\t\t\t\twriteErr := track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second})\n\t\t\t\tassert.NoError(t, writeErr)\n\t\t\tcase <-rtxRead.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tassert.NoError(t, wan.Stop())\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n"
        },
        {
          "name": "peerconnection_renegotiation_test.go",
          "type": "blob",
          "size": 40.103515625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc sendVideoUntilDone(done <-chan struct{}, t *testing.T, tracks []*TrackLocalStaticSample) {\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(20 * time.Millisecond):\n\t\t\tfor _, track := range tracks {\n\t\t\t\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}))\n\t\t\t}\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc sdpMidHasSsrc(offer SessionDescription, mid string, ssrc SSRC) bool {\n\tfor _, media := range offer.parsed.MediaDescriptions {\n\t\tcmid, ok := media.Attribute(\"mid\")\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif cmid != mid {\n\t\t\tcontinue\n\t\t}\n\t\tcssrc, ok := media.Attribute(\"ssrc\")\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tparts := strings.Split(cssrc, \" \")\n\n\t\tssrcInt64, err := strconv.ParseUint(parts[0], 10, 32)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif uint32(ssrcInt64) == uint32(ssrc) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc TestPeerConnection_Renegotiation_AddRecvonlyTransceiver(t *testing.T) {\n\ttype testCase struct {\n\t\tname          string\n\t\tanswererSends bool\n\t}\n\n\ttestCases := []testCase{\n\t\t// Assert the following behaviors:\n\t\t// - Offerer can add a recvonly transceiver\n\t\t// - During negotiation, answerer peer adds an inactive (or sendonly) transceiver\n\t\t// - Offerer can add a track\n\t\t// - Answerer can receive the RTP packets.\n\t\t{\"add recvonly, then receive from answerer\", false},\n\t\t// Assert the following behaviors:\n\t\t// - Offerer can add a recvonly transceiver\n\t\t// - During negotiation, answerer peer adds an inactive (or sendonly) transceiver\n\t\t// - Answerer can add a track to the existing sendonly transceiver\n\t\t// - Offerer can receive the RTP packets.\n\t\t{\"add recvonly, then send to answerer\", true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tlim := test.TimeOut(time.Second * 30)\n\t\t\tdefer lim.Stop()\n\n\t\t\treport := test.CheckRoutines(t)\n\t\t\tdefer report()\n\n\t\t\tpcOffer, pcAnswer, err := newPair()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t_, err = pcOffer.AddTransceiverFromKind(\n\t\t\t\tRTPCodecTypeVideo,\n\t\t\t\tRTPTransceiverInit{\n\t\t\t\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t\t\t\t},\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t\t\tlocalTrack, err := NewTrackLocalStaticSample(\n\t\t\t\tRTPCodecCapability{MimeType: \"video/VP8\"}, \"track-one\", \"stream-one\",\n\t\t\t)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif tc.answererSends {\n\t\t\t\t_, err = pcAnswer.AddTrack(localTrack)\n\t\t\t} else {\n\t\t\t\t_, err = pcOffer.AddTrack(localTrack)\n\t\t\t}\n\n\t\t\trequire.NoError(t, err)\n\n\t\t\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\n\t\t\tif tc.answererSends {\n\t\t\t\tpcOffer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\t\t\t\tonTrackFiredFunc()\n\t\t\t\t})\n\t\t\t\tassert.NoError(t, signalPair(pcAnswer, pcOffer))\n\t\t\t} else {\n\t\t\t\tpcAnswer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\t\t\t\tonTrackFiredFunc()\n\t\t\t\t})\n\t\t\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\t\t\t}\n\n\t\t\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{localTrack})\n\n\t\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t\t})\n\t}\n}\n\n/*\n*  Assert the following behaviors\n* - We are able to call AddTrack after signaling\n* - OnTrack is NOT called on the other side until after SetRemoteDescription\n* - We are able to re-negotiate and AddTrack is properly called\n */\nfunc TestPeerConnection_Renegotiation_AddTrack(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thaveRenegotiated := &atomicBool{}\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\tpcAnswer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\tif !haveRenegotiated.get() {\n\t\t\tt.Fatal(\"OnTrack was called before renegotiation\")\n\t\t}\n\t\tonTrackFiredFunc()\n\t})\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tassert.NoError(t, err)\n\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\n\tsender, err := pcOffer.AddTrack(vp8Track)\n\tassert.NoError(t, err)\n\n\t// Send 10 packets, OnTrack MUST not be fired\n\tfor i := 0; i <= 10; i++ {\n\t\tassert.NoError(t, vp8Track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}))\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\n\thaveRenegotiated.set(true)\n\tassert.False(t, sender.isNegotiated())\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.True(t, sender.isNegotiated())\n\tassert.NoError(t, err)\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\n\tpcOffer.ops.Done()\n\tassert.Equal(t, 0, len(vp8Track.rtpTrack.bindings))\n\n\tassert.NoError(t, pcOffer.SetRemoteDescription(answer))\n\n\tpcOffer.ops.Done()\n\tassert.Equal(t, 1, len(vp8Track.rtpTrack.bindings))\n\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{vp8Track})\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Assert that adding tracks across multiple renegotiations performs as expected\nfunc TestPeerConnection_Renegotiation_AddTrack_Multiple(t *testing.T) {\n\taddTrackWithLabel := func(trackID string, pcOffer, pcAnswer *PeerConnection) *TrackLocalStaticSample {\n\t\t_, err := pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\t\tassert.NoError(t, err)\n\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, trackID, trackID)\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pcOffer.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\treturn track\n\t}\n\n\ttrackIDs := []string{util.MathRandAlpha(16), util.MathRandAlpha(16), util.MathRandAlpha(16)}\n\toutboundTracks := []*TrackLocalStaticSample{}\n\tonTrackCount := map[string]int{}\n\tonTrackChan := make(chan struct{}, 1)\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpcAnswer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tonTrackCount[track.ID()]++\n\t\tonTrackChan <- struct{}{}\n\t})\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tfor i := range trackIDs {\n\t\toutboundTracks = append(outboundTracks, addTrackWithLabel(trackIDs[i], pcOffer, pcAnswer))\n\t\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\t\tsendVideoUntilDone(onTrackChan, t, outboundTracks)\n\t}\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n\n\tassert.Equal(t, onTrackCount[trackIDs[0]], 1)\n\tassert.Equal(t, onTrackCount[trackIDs[1]], 1)\n\tassert.Equal(t, onTrackCount[trackIDs[2]], 1)\n}\n\n// Assert that renegotiation triggers OnTrack() with correct ID and label from\n// remote side, even when a transceiver was added before the actual track data\n// was received. This happens when we add a transceiver on the server, create\n// an offer on the server and the browser's answer contains the same SSRC, but\n// a track hasn't been added on the browser side yet. The browser can add a\n// track later and renegotiate, and track ID and label will be set by the time\n// first packets are received.\nfunc TestPeerConnection_Renegotiation_AddTrack_Rename(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\thaveRenegotiated := &atomicBool{}\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\tvar atomicRemoteTrack atomic.Value\n\tpcOffer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tif !haveRenegotiated.get() {\n\t\t\tt.Fatal(\"OnTrack was called before renegotiation\")\n\t\t}\n\t\tonTrackFiredFunc()\n\t\tatomicRemoteTrack.Store(track)\n\t})\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tassert.NoError(t, err)\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo1\", \"bar1\")\n\tassert.NoError(t, err)\n\t_, err = pcAnswer.AddTrack(vp8Track)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tvp8Track.rtpTrack.id = \"foo2\"\n\tvp8Track.rtpTrack.streamID = \"bar2\"\n\n\thaveRenegotiated.set(true)\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{vp8Track})\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n\n\tremoteTrack, ok := atomicRemoteTrack.Load().(*TrackRemote)\n\trequire.True(t, ok)\n\trequire.NotNil(t, remoteTrack)\n\tassert.Equal(t, \"foo2\", remoteTrack.ID())\n\tassert.Equal(t, \"bar2\", remoteTrack.StreamID())\n}\n\n// TestPeerConnection_Transceiver_Mid tests that we'll provide the same\n// transceiver for a media id on successive offer/answer\nfunc TestPeerConnection_Transceiver_Mid(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion1\")\n\trequire.NoError(t, err)\n\n\tsender1, err := pcOffer.AddTrack(track1)\n\trequire.NoError(t, err)\n\n\ttrack2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\trequire.NoError(t, err)\n\n\tsender2, err := pcOffer.AddTrack(track2)\n\trequire.NoError(t, err)\n\n\t// this will create the initial offer using generateUnmatchedSDP\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\t<-offerGatheringComplete\n\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))\n\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t<-answerGatheringComplete\n\n\t// apply answer so we'll test generateMatchedSDP\n\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\t// Must have 3 media descriptions (2 video channels)\n\tassert.Equal(t, len(offer.parsed.MediaDescriptions), 2)\n\n\tassert.True(t, sdpMidHasSsrc(offer, \"0\", sender1.trackEncodings[0].ssrc), \"Expected mid %q with ssrc %d, offer.SDP: %s\", \"0\", sender1.trackEncodings[0].ssrc, offer.SDP)\n\n\t// Remove first track, must keep same number of media\n\t// descriptions and same track ssrc for mid 1 as previous\n\tassert.NoError(t, pcOffer.RemoveTrack(sender1))\n\n\toffer, err = pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\n\tassert.Equal(t, len(offer.parsed.MediaDescriptions), 2)\n\n\tassert.True(t, sdpMidHasSsrc(offer, \"1\", sender2.trackEncodings[0].ssrc), \"Expected mid %q with ssrc %d, offer.SDP: %s\", \"1\", sender2.trackEncodings[0].ssrc, offer.SDP)\n\n\t_, err = pcAnswer.CreateAnswer(nil)\n\tassert.Equal(t, err, &rtcerr.InvalidStateError{Err: ErrIncorrectSignalingState})\n\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\tanswer, err = pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, pcOffer.SetRemoteDescription(answer))\n\n\ttrack3, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion3\")\n\trequire.NoError(t, err)\n\n\tsender3, err := pcOffer.AddTrack(track3)\n\trequire.NoError(t, err)\n\n\toffer, err = pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\t// We reuse the existing non-sending transceiver\n\tassert.Equal(t, len(offer.parsed.MediaDescriptions), 2)\n\n\tassert.True(t, sdpMidHasSsrc(offer, \"0\", sender3.trackEncodings[0].ssrc), \"Expected mid %q with ssrc %d, offer.sdp: %s\", \"0\", sender3.trackEncodings[0].ssrc, offer.SDP)\n\tassert.True(t, sdpMidHasSsrc(offer, \"1\", sender2.trackEncodings[0].ssrc), \"Expected mid %q with ssrc %d, offer.sdp: %s\", \"1\", sender2.trackEncodings[0].ssrc, offer.SDP)\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnection_Renegotiation_CodecChange(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video1\", \"pion1\")\n\trequire.NoError(t, err)\n\n\ttrack2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video2\", \"pion2\")\n\trequire.NoError(t, err)\n\n\tsender1, err := pcOffer.AddTrack(track1)\n\trequire.NoError(t, err)\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\trequire.NoError(t, err)\n\n\ttracksCh := make(chan *TrackRemote)\n\ttracksClosed := make(chan struct{})\n\tpcAnswer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\ttracksCh <- track\n\t\tfor {\n\t\t\tif _, _, readErr := track.ReadRTP(); errors.Is(readErr, io.EOF) {\n\t\t\t\ttracksClosed <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\n\terr = signalPair(pcOffer, pcAnswer)\n\trequire.NoError(t, err)\n\n\ttransceivers := pcOffer.GetTransceivers()\n\trequire.Equal(t, 1, len(transceivers))\n\trequire.Equal(t, \"0\", transceivers[0].Mid())\n\n\ttransceivers = pcAnswer.GetTransceivers()\n\trequire.Equal(t, 1, len(transceivers))\n\trequire.Equal(t, \"0\", transceivers[0].Mid())\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tgo sendVideoUntilDone(ctx.Done(), t, []*TrackLocalStaticSample{track1})\n\n\tremoteTrack1 := <-tracksCh\n\tcancel()\n\n\tassert.Equal(t, \"video1\", remoteTrack1.ID())\n\tassert.Equal(t, \"pion1\", remoteTrack1.StreamID())\n\n\trequire.NoError(t, pcOffer.RemoveTrack(sender1))\n\n\trequire.NoError(t, signalPair(pcOffer, pcAnswer))\n\t<-tracksClosed\n\n\tsender2, err := pcOffer.AddTrack(track2)\n\trequire.NoError(t, err)\n\trequire.NoError(t, signalPair(pcOffer, pcAnswer))\n\ttransceivers = pcOffer.GetTransceivers()\n\trequire.Equal(t, 1, len(transceivers))\n\trequire.Equal(t, \"0\", transceivers[0].Mid())\n\n\ttransceivers = pcAnswer.GetTransceivers()\n\trequire.Equal(t, 1, len(transceivers))\n\trequire.Equal(t, \"0\", transceivers[0].Mid())\n\n\tctx, cancel = context.WithCancel(context.Background())\n\tgo sendVideoUntilDone(ctx.Done(), t, []*TrackLocalStaticSample{track2})\n\n\tremoteTrack2 := <-tracksCh\n\tcancel()\n\n\trequire.NoError(t, pcOffer.RemoveTrack(sender2))\n\n\terr = signalPair(pcOffer, pcAnswer)\n\trequire.NoError(t, err)\n\t<-tracksClosed\n\n\tassert.Equal(t, \"video2\", remoteTrack2.ID())\n\tassert.Equal(t, \"pion2\", remoteTrack2.StreamID())\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnection_Renegotiation_RemoveTrack(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tassert.NoError(t, err)\n\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\n\tsender, err := pcOffer.AddTrack(vp8Track)\n\tassert.NoError(t, err)\n\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\ttrackClosed, trackClosedFunc := context.WithCancel(context.Background())\n\n\tpcAnswer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tonTrackFiredFunc()\n\n\t\tfor {\n\t\t\tif _, _, err := track.ReadRTP(); errors.Is(err, io.EOF) {\n\t\t\t\ttrackClosedFunc()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{vp8Track})\n\n\tassert.NoError(t, pcOffer.RemoveTrack(sender))\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t<-trackClosed.Done()\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnection_RoleSwitch(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcFirstOfferer, pcSecondOfferer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\tpcFirstOfferer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\tonTrackFiredFunc()\n\t})\n\n\tassert.NoError(t, signalPair(pcFirstOfferer, pcSecondOfferer))\n\n\t// Add a new Track to the second offerer\n\t// This asserts that it will match the ordering of the last RemoteDescription, but then also add new Transceivers to the end\n\t_, err = pcFirstOfferer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tassert.NoError(t, err)\n\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\n\t_, err = pcSecondOfferer.AddTrack(vp8Track)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcSecondOfferer, pcFirstOfferer))\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{vp8Track})\n\n\tclosePairNow(t, pcFirstOfferer, pcSecondOfferer)\n}\n\n// Assert that renegotiation doesn't attempt to gather ICE twice\n// Before we would attempt to gather multiple times and would put\n// the PeerConnection into a broken state\nfunc TestPeerConnection_Renegotiation_Trickle(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tsettingEngine := SettingEngine{}\n\n\tapi := NewAPI(WithSettingEngine(settingEngine))\n\n\t// Invalid STUN server on purpose, will stop ICE Gathering from completing in time\n\tpcOffer, pcAnswer, err := api.newPair(Configuration{\n\t\tICEServers: []ICEServer{\n\t\t\t{\n\t\t\t\tURLs: []string{\"stun:127.0.0.1:5000\"},\n\t\t\t},\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t_, err = pcOffer.CreateDataChannel(\"test-channel\", nil)\n\tassert.NoError(t, err)\n\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tpcOffer.OnICECandidate(func(c *ICECandidate) {\n\t\tif c != nil {\n\t\t\tassert.NoError(t, pcAnswer.AddICECandidate(c.ToJSON()))\n\t\t} else {\n\t\t\twg.Done()\n\t\t}\n\t})\n\tpcAnswer.OnICECandidate(func(c *ICECandidate) {\n\t\tif c != nil {\n\t\t\tassert.NoError(t, pcOffer.AddICECandidate(c.ToJSON()))\n\t\t} else {\n\t\t\twg.Done()\n\t\t}\n\t})\n\n\tnegotiate := func() {\n\t\toffer, err := pcOffer.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\t\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\n\t\tanswer, err := pcAnswer.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, pcOffer.SetRemoteDescription(answer))\n\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t}\n\tnegotiate()\n\tnegotiate()\n\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\twg.Wait()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnection_Renegotiation_SetLocalDescription(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\tpcOffer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\tonTrackFiredFunc()\n\t})\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tassert.NoError(t, err)\n\n\tlocalTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\n\tsender, err := pcAnswer.AddTrack(localTrack)\n\tassert.NoError(t, err)\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\tassert.False(t, sender.isNegotiated())\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\tassert.True(t, sender.isNegotiated())\n\n\tpcAnswer.ops.Done()\n\tassert.Equal(t, 0, len(localTrack.rtpTrack.bindings))\n\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\n\tpcAnswer.ops.Done()\n\tassert.Equal(t, 1, len(localTrack.rtpTrack.bindings))\n\n\tassert.NoError(t, pcOffer.SetRemoteDescription(answer))\n\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{localTrack})\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Issue #346, don't start the SCTP Subsystem if the RemoteDescription doesn't contain one\n// Before we would always start it, and re-negotiations would fail because SCTP was in flight\nfunc TestPeerConnection_Renegotiation_NoApplication(t *testing.T) {\n\tsignalPairExcludeDataChannel := func(pcOffer, pcAnswer *PeerConnection) {\n\t\toffer, err := pcOffer.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\t\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\t\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\t\t<-offerGatheringComplete\n\n\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))\n\n\t\tanswer, err := pcAnswer.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t\t<-answerGatheringComplete\n\n\t\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\t}\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpcOfferConnected, pcOfferConnectedCancel := context.WithCancel(context.Background())\n\tpcOffer.OnICEConnectionStateChange(func(i ICEConnectionState) {\n\t\tif i == ICEConnectionStateConnected {\n\t\t\tpcOfferConnectedCancel()\n\t\t}\n\t})\n\n\tpcAnswerConnected, pcAnswerConnectedCancel := context.WithCancel(context.Background())\n\tpcAnswer.OnICEConnectionStateChange(func(i ICEConnectionState) {\n\t\tif i == ICEConnectionStateConnected {\n\t\t\tpcAnswerConnectedCancel()\n\t\t}\n\t})\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionSendrecv})\n\tassert.NoError(t, err)\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionSendrecv})\n\tassert.NoError(t, err)\n\n\tsignalPairExcludeDataChannel(pcOffer, pcAnswer)\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\tsignalPairExcludeDataChannel(pcOffer, pcAnswer)\n\tpcOffer.ops.Done()\n\tpcAnswer.ops.Done()\n\n\t<-pcAnswerConnected.Done()\n\t<-pcOfferConnected.Done()\n\n\tassert.Equal(t, pcOffer.SCTP().State(), SCTPTransportStateConnecting)\n\tassert.Equal(t, pcAnswer.SCTP().State(), SCTPTransportStateConnecting)\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestAddDataChannelDuringRenegotiation(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = pcOffer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\t<-offerGatheringComplete\n\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))\n\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t<-answerGatheringComplete\n\n\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\n\t_, err = pcOffer.CreateDataChannel(\"data-channel\", nil)\n\tassert.NoError(t, err)\n\n\t// Assert that DataChannel is in offer now\n\toffer, err = pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tapplicationMediaSectionCount := 0\n\tfor _, d := range offer.parsed.MediaDescriptions {\n\t\tif d.MediaName.Media == mediaSectionApplication {\n\t\t\tapplicationMediaSectionCount++\n\t\t}\n\t}\n\tassert.Equal(t, applicationMediaSectionCount, 1)\n\n\tonDataChannelFired, onDataChannelFiredFunc := context.WithCancel(context.Background())\n\tpcAnswer.OnDataChannel(func(*DataChannel) {\n\t\tonDataChannelFiredFunc()\n\t})\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t<-onDataChannelFired.Done()\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Assert that CreateDataChannel fires OnNegotiationNeeded\nfunc TestNegotiationCreateDataChannel(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tpc.OnNegotiationNeeded(func() {\n\t\tdefer func() {\n\t\t\twg.Done()\n\t\t}()\n\t})\n\n\t// Create DataChannel, wait until OnNegotiationNeeded is fired\n\tif _, err = pc.CreateDataChannel(\"testChannel\", nil); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\t// Wait until OnNegotiationNeeded is fired\n\twg.Wait()\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestNegotiationNeededRemoveTrack(t *testing.T) {\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tpcOffer.OnNegotiationNeeded(func() {\n\t\twg.Add(1)\n\t\toffer, createOfferErr := pcOffer.CreateOffer(nil)\n\t\tassert.NoError(t, createOfferErr)\n\n\t\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\t\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\n\t\t<-offerGatheringComplete\n\t\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))\n\n\t\tanswer, createAnswerErr := pcAnswer.CreateAnswer(nil)\n\t\tassert.NoError(t, createAnswerErr)\n\n\t\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\t\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\n\t\t<-answerGatheringComplete\n\t\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\t\twg.Done()\n\t\twg.Done()\n\t})\n\n\tsender, err := pcOffer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0x00}, Duration: time.Second}))\n\n\twg.Wait()\n\n\twg.Add(1)\n\tassert.NoError(t, pcOffer.RemoveTrack(sender))\n\n\twg.Wait()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestNegotiationNeededStressOneSided(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcA, pcB, err := newPair()\n\tassert.NoError(t, err)\n\n\tconst expectedTrackCount = 500\n\tctx, done := context.WithCancel(context.Background())\n\tpcA.OnNegotiationNeeded(func() {\n\t\tcount := len(pcA.GetTransceivers())\n\t\tassert.NoError(t, signalPair(pcA, pcB))\n\t\tif count == expectedTrackCount {\n\t\t\tdone()\n\t\t}\n\t})\n\n\tfor i := 0; i < expectedTrackCount; i++ {\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pcA.AddTrack(track)\n\t\tassert.NoError(t, err)\n\t}\n\t<-ctx.Done()\n\tassert.Equal(t, expectedTrackCount, len(pcB.GetTransceivers()))\n\tclosePairNow(t, pcA, pcB)\n}\n\n// TestPeerConnection_Renegotiation_DisableTrack asserts that if a remote track is set inactive\n// that locally it goes inactive as well\nfunc TestPeerConnection_Renegotiation_DisableTrack(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\t// Create two transceivers\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\ttransceiver, err := pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t// Assert we have three active transceivers\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, strings.Count(offer.SDP, \"a=sendrecv\"), 3)\n\n\t// Assert we have two active transceivers, one inactive\n\tassert.NoError(t, transceiver.Stop())\n\toffer, err = pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, strings.Count(offer.SDP, \"a=sendrecv\"), 2)\n\tassert.Equal(t, strings.Count(offer.SDP, \"a=inactive\"), 1)\n\n\t// Assert that the offer disabled one of our transceivers\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, strings.Count(answer.SDP, \"a=sendrecv\"), 1) // DataChannel\n\tassert.Equal(t, strings.Count(answer.SDP, \"a=recvonly\"), 1)\n\tassert.Equal(t, strings.Count(answer.SDP, \"a=inactive\"), 1)\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnection_Renegotiation_Simulcast(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\toriginalRids := []string{\"a\", \"b\", \"c\"}\n\tsignalWithRids := func(sessionDescription string, rids []string) string {\n\t\tsessionDescription = strings.SplitAfter(sessionDescription, \"a=end-of-candidates\\r\\n\")[0]\n\t\tsessionDescription = filterSsrc(sessionDescription)\n\t\tfor _, rid := range rids {\n\t\t\tsessionDescription += \"a=\" + sdpAttributeRid + \":\" + rid + \" send\\r\\n\"\n\t\t}\n\t\treturn sessionDescription + \"a=simulcast:send \" + strings.Join(rids, \";\") + \"\\r\\n\"\n\t}\n\n\tvar trackMapLock sync.RWMutex\n\ttrackMap := map[string]*TrackRemote{}\n\n\tonTrackHandler := func(track *TrackRemote, _ *RTPReceiver) {\n\t\ttrackMapLock.Lock()\n\t\tdefer trackMapLock.Unlock()\n\t\ttrackMap[track.RID()] = track\n\t}\n\n\tsendUntilAllTracksFired := func(vp8Writer *TrackLocalStaticRTP, rids []string) {\n\t\tallTracksFired := func() bool {\n\t\t\ttrackMapLock.Lock()\n\t\t\tdefer trackMapLock.Unlock()\n\n\t\t\treturn len(trackMap) == len(rids)\n\t\t}\n\n\t\tfor sequenceNumber := uint16(0); !allTracksFired(); sequenceNumber++ {\n\t\t\ttime.Sleep(20 * time.Millisecond)\n\n\t\t\tfor ssrc, rid := range rids {\n\t\t\t\theader := &rtp.Header{\n\t\t\t\t\tVersion:        2,\n\t\t\t\t\tSSRC:           uint32(ssrc + 1),\n\t\t\t\t\tSequenceNumber: sequenceNumber,\n\t\t\t\t\tPayloadType:    96,\n\t\t\t\t}\n\t\t\t\tassert.NoError(t, header.SetExtension(1, []byte(\"0\")))\n\t\t\t\tassert.NoError(t, header.SetExtension(2, []byte(rid)))\n\n\t\t\t\t_, err := vp8Writer.bindings[0].writeStream.WriteRTP(header, []byte{0x00})\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tassertTracksClosed := func(t *testing.T) {\n\t\ttrackMapLock.Lock()\n\t\tdefer trackMapLock.Unlock()\n\n\t\tfor _, track := range trackMap {\n\t\t\t_, _, err := track.ReadRTP() // Ignore first Read, this is our peeked data\n\t\t\tassert.Nil(t, err)\n\n\t\t\t_, _, err = track.ReadRTP()\n\t\t\tassert.Equal(t, err, io.EOF)\n\t\t}\n\t}\n\n\tt.Run(\"Disable Transceiver\", func(t *testing.T) {\n\t\ttrackMap = map[string]*TrackRemote{}\n\t\tpcOffer, pcAnswer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tvp8Writer, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\t\tassert.NoError(t, err)\n\n\t\trtpTransceiver, err := pcOffer.AddTransceiverFromTrack(\n\t\t\tvp8Writer,\n\t\t\tRTPTransceiverInit{\n\t\t\t\tDirection: RTPTransceiverDirectionSendonly,\n\t\t\t},\n\t\t)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, signalPairWithModification(pcOffer, pcAnswer, func(sessionDescription string) string {\n\t\t\treturn signalWithRids(sessionDescription, originalRids)\n\t\t}))\n\n\t\tpcAnswer.OnTrack(onTrackHandler)\n\t\tsendUntilAllTracksFired(vp8Writer, originalRids)\n\n\t\tassert.NoError(t, pcOffer.RemoveTrack(rtpTransceiver.Sender()))\n\t\tassert.NoError(t, signalPairWithModification(pcOffer, pcAnswer, func(sessionDescription string) string {\n\t\t\tsessionDescription = strings.SplitAfter(sessionDescription, \"a=end-of-candidates\\r\\n\")[0]\n\t\t\treturn sessionDescription\n\t\t}))\n\n\t\tassertTracksClosed(t)\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t})\n\n\tt.Run(\"Change RID\", func(t *testing.T) {\n\t\ttrackMap = map[string]*TrackRemote{}\n\t\tpcOffer, pcAnswer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tvp8Writer, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion2\")\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pcOffer.AddTransceiverFromTrack(\n\t\t\tvp8Writer,\n\t\t\tRTPTransceiverInit{\n\t\t\t\tDirection: RTPTransceiverDirectionSendonly,\n\t\t\t},\n\t\t)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, signalPairWithModification(pcOffer, pcAnswer, func(sessionDescription string) string {\n\t\t\treturn signalWithRids(sessionDescription, originalRids)\n\t\t}))\n\n\t\tpcAnswer.OnTrack(onTrackHandler)\n\t\tsendUntilAllTracksFired(vp8Writer, originalRids)\n\n\t\tnewRids := []string{\"d\", \"e\", \"f\"}\n\t\tassert.NoError(t, signalPairWithModification(pcOffer, pcAnswer, func(sessionDescription string) string {\n\t\t\tscanner := bufio.NewScanner(strings.NewReader(sessionDescription))\n\t\t\tsessionDescription = \"\"\n\t\t\tfor scanner.Scan() {\n\t\t\t\tl := scanner.Text()\n\t\t\t\tif strings.HasPrefix(l, \"a=rid\") || strings.HasPrefix(l, \"a=simulcast\") {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tsessionDescription += l + \"\\n\"\n\t\t\t}\n\t\t\treturn signalWithRids(sessionDescription, newRids)\n\t\t}))\n\n\t\tassertTracksClosed(t)\n\t\tclosePairNow(t, pcOffer, pcAnswer)\n\t})\n}\n\nfunc TestPeerConnection_Regegotiation_ReuseTransceiver(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvp8Track, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\tsender, err := pcOffer.AddTrack(vp8Track)\n\tassert.NoError(t, err)\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tpeerConnectionConnected := untilConnectionState(PeerConnectionStateConnected, pcOffer, pcAnswer)\n\tpeerConnectionConnected.Wait()\n\n\tassert.Equal(t, len(pcOffer.GetTransceivers()), 1)\n\tassert.Equal(t, pcOffer.GetTransceivers()[0].getCurrentDirection(), RTPTransceiverDirectionSendonly)\n\tassert.NoError(t, pcOffer.RemoveTrack(sender))\n\tassert.Equal(t, pcOffer.GetTransceivers()[0].getCurrentDirection(), RTPTransceiverDirectionSendonly)\n\n\t// should not reuse tranceiver\n\tvp8Track2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\tsender2, err := pcOffer.AddTrack(vp8Track2)\n\tassert.NoError(t, err)\n\tassert.Equal(t, len(pcOffer.GetTransceivers()), 2)\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\tassert.True(t, sender2.rtpTransceiver == pcOffer.GetTransceivers()[1])\n\n\t// should reuse first transceiver\n\tsender, err = pcOffer.AddTrack(vp8Track)\n\tassert.NoError(t, err)\n\tassert.Equal(t, len(pcOffer.GetTransceivers()), 2)\n\tassert.True(t, sender.rtpTransceiver == pcOffer.GetTransceivers()[0])\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\ttracksCh := make(chan *TrackRemote, 2)\n\tpcAnswer.OnTrack(func(tr *TrackRemote, _ *RTPReceiver) {\n\t\ttracksCh <- tr\n\t})\n\n\tssrcReuse := sender.GetParameters().Encodings[0].SSRC\n\tfor i := 0; i < 10; i++ {\n\t\tassert.NoError(t, vp8Track.WriteRTP(&rtp.Packet{Header: rtp.Header{Version: 2}, Payload: []byte{0, 1, 2, 3, 4, 5}}))\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\n\t// shold not reuse tranceiver between two CreateOffer\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, pcOffer.RemoveTrack(sender))\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\tassert.NoError(t, err)\n\tassert.NoError(t, pcOffer.SetRemoteDescription(answer))\n\tsender3, err := pcOffer.AddTrack(vp8Track)\n\tssrcNotReuse := sender3.GetParameters().Encodings[0].SSRC\n\tassert.NoError(t, err)\n\tassert.Equal(t, len(pcOffer.GetTransceivers()), 3)\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\tassert.True(t, sender3.rtpTransceiver == pcOffer.GetTransceivers()[2])\n\n\tfor i := 0; i < 10; i++ {\n\t\tassert.NoError(t, vp8Track.WriteRTP(&rtp.Packet{Header: rtp.Header{Version: 2}, Payload: []byte{0, 1, 2, 3, 4, 5}}))\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\n\ttr1 := <-tracksCh\n\ttr2 := <-tracksCh\n\tassert.Equal(t, tr1.SSRC(), ssrcReuse)\n\tassert.Equal(t, tr2.SSRC(), ssrcNotReuse)\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestPeerConnection_Renegotiation_MidConflict(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tofferPC, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\tanswerPC, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\t_, err = offerPC.CreateDataChannel(\"test\", nil)\n\tassert.NoError(t, err)\n\n\t_, err = offerPC.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionSendonly})\n\tassert.NoError(t, err)\n\t_, err = offerPC.AddTransceiverFromKind(RTPCodecTypeAudio, RTPTransceiverInit{Direction: RTPTransceiverDirectionSendonly})\n\tassert.NoError(t, err)\n\n\toffer, err := offerPC.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, offerPC.SetLocalDescription(offer))\n\tassert.NoError(t, answerPC.SetRemoteDescription(offer), offer.SDP)\n\tanswer, err := answerPC.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, answerPC.SetLocalDescription(answer))\n\tassert.NoError(t, offerPC.SetRemoteDescription(answer))\n\tassert.Equal(t, SignalingStateStable, offerPC.SignalingState())\n\n\ttr, err := offerPC.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionSendonly})\n\tassert.NoError(t, err)\n\tassert.NoError(t, tr.SetMid(\"3\"))\n\t_, err = offerPC.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionSendrecv})\n\tassert.NoError(t, err)\n\t_, err = offerPC.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, offerPC.Close())\n\tassert.NoError(t, answerPC.Close())\n}\n\nfunc TestPeerConnection_Regegotiation_AnswerAddsTrack(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttracksCh := make(chan *TrackRemote)\n\tpcOffer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\ttracksCh <- track\n\t\tfor {\n\t\t\tif _, _, readErr := track.ReadRTP(); errors.Is(readErr, io.EOF) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\n\tvp8Track, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"foo\", \"bar\")\n\tassert.NoError(t, err)\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tassert.NoError(t, err)\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendonly,\n\t})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, err)\n\t_, err = pcAnswer.AddTrack(vp8Track)\n\tassert.NoError(t, err)\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo sendVideoUntilDone(ctx.Done(), t, []*TrackLocalStaticSample{vp8Track})\n\n\t<-tracksCh\n\tcancel()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestNegotiationNeededWithRecvonlyTrack(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tpcAnswer.OnNegotiationNeeded(wg.Done)\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{Direction: RTPTransceiverDirectionRecvonly})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := signalPair(pcOffer, pcAnswer); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tonDataChannel, onDataChannelCancel := context.WithCancel(context.Background())\n\tpcAnswer.OnDataChannel(func(*DataChannel) {\n\t\tonDataChannelCancel()\n\t})\n\t<-onDataChannel.Done()\n\twg.Wait()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestNegotiationNotNeededAfterReplaceTrackNil(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttr, err := pcOffer.AddTransceiverFromKind(RTPCodecTypeAudio)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tassert.NoError(t, tr.Sender().ReplaceTrack(nil))\n\n\tassert.False(t, pcOffer.checkNegotiationNeeded())\n\n\tassert.NoError(t, pcOffer.Close())\n\tassert.NoError(t, pcAnswer.Close())\n}\n"
        },
        {
          "name": "peerconnection_test.go",
          "type": "blob",
          "size": 21.3232421875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// newPair creates two new peer connections (an offerer and an answerer)\n// *without* using an api (i.e. using the default settings).\nfunc newPair() (pcOffer *PeerConnection, pcAnswer *PeerConnection, err error) {\n\tpca, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpcb, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn pca, pcb, nil\n}\n\nfunc signalPairWithModification(pcOffer *PeerConnection, pcAnswer *PeerConnection, modificationFunc func(string) string) error {\n\t// Note(albrow): We need to create a data channel in order to trigger ICE\n\t// candidate gathering in the background for the JavaScript/Wasm bindings. If\n\t// we don't do this, the complete offer including ICE candidates will never be\n\t// generated.\n\tif _, err := pcOffer.CreateDataChannel(\"initial_data_channel\", nil); err != nil {\n\t\treturn err\n\t}\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\tif err = pcOffer.SetLocalDescription(offer); err != nil {\n\t\treturn err\n\t}\n\t<-offerGatheringComplete\n\n\toffer.SDP = modificationFunc(pcOffer.LocalDescription().SDP)\n\tif err = pcAnswer.SetRemoteDescription(offer); err != nil {\n\t\treturn err\n\t}\n\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\tif err = pcAnswer.SetLocalDescription(answer); err != nil {\n\t\treturn err\n\t}\n\t<-answerGatheringComplete\n\treturn pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription())\n}\n\nfunc signalPair(pcOffer *PeerConnection, pcAnswer *PeerConnection) error {\n\treturn signalPairWithModification(pcOffer, pcAnswer, func(sessionDescription string) string { return sessionDescription })\n}\n\nfunc offerMediaHasDirection(offer SessionDescription, kind RTPCodecType, direction RTPTransceiverDirection) bool {\n\tparsed := &sdp.SessionDescription{}\n\tif err := parsed.Unmarshal([]byte(offer.SDP)); err != nil {\n\t\treturn false\n\t}\n\n\tfor _, media := range parsed.MediaDescriptions {\n\t\tif media.MediaName.Media == kind.String() {\n\t\t\t_, exists := media.Attribute(direction.String())\n\t\t\treturn exists\n\t\t}\n\t}\n\treturn false\n}\n\nfunc untilConnectionState(state PeerConnectionState, peers ...*PeerConnection) *sync.WaitGroup {\n\tvar triggered sync.WaitGroup\n\ttriggered.Add(len(peers))\n\n\tfor _, p := range peers {\n\t\tvar done atomic.Value\n\t\tdone.Store(false)\n\t\thdlr := func(p PeerConnectionState) {\n\t\t\tif val, ok := done.Load().(bool); ok && (!val && p == state) {\n\t\t\t\tdone.Store(true)\n\t\t\t\ttriggered.Done()\n\t\t\t}\n\t\t}\n\n\t\tp.OnConnectionStateChange(hdlr)\n\t}\n\treturn &triggered\n}\n\nfunc TestNew(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{\n\t\tICEServers: []ICEServer{\n\t\t\t{\n\t\t\t\tURLs: []string{\n\t\t\t\t\t\"stun:stun.l.google.com:19302\",\n\t\t\t\t},\n\t\t\t\tUsername: \"unittest\",\n\t\t\t},\n\t\t},\n\t\tICETransportPolicy:   ICETransportPolicyRelay,\n\t\tBundlePolicy:         BundlePolicyMaxCompat,\n\t\tRTCPMuxPolicy:        RTCPMuxPolicyNegotiate,\n\t\tPeerIdentity:         \"unittest\",\n\t\tICECandidatePoolSize: 5,\n\t})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, pc)\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestPeerConnection_SetConfiguration(t *testing.T) {\n\t// Note: These tests don't include ICEServer.Credential,\n\t// ICEServer.CredentialType, or Certificates because those are not supported\n\t// in the WASM bindings.\n\n\tfor _, test := range []struct {\n\t\tname    string\n\t\tinit    func() (*PeerConnection, error)\n\t\tconfig  Configuration\n\t\twantErr error\n\t}{\n\t\t{\n\t\t\tname: \"valid\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\tpc, err := NewPeerConnection(Configuration{\n\t\t\t\t\tICECandidatePoolSize: 5,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn pc, err\n\t\t\t\t}\n\n\t\t\t\terr = pc.SetConfiguration(Configuration{\n\t\t\t\t\tICEServers: []ICEServer{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tURLs: []string{\n\t\t\t\t\t\t\t\t\"stun:stun.l.google.com:19302\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tUsername: \"unittest\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tICETransportPolicy:   ICETransportPolicyAll,\n\t\t\t\t\tBundlePolicy:         BundlePolicyBalanced,\n\t\t\t\t\tRTCPMuxPolicy:        RTCPMuxPolicyRequire,\n\t\t\t\t\tICECandidatePoolSize: 5,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn pc, err\n\t\t\t\t}\n\n\t\t\t\treturn pc, nil\n\t\t\t},\n\t\t\tconfig:  Configuration{},\n\t\t\twantErr: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"closed connection\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\tpc, err := NewPeerConnection(Configuration{})\n\t\t\t\tassert.Nil(t, err)\n\n\t\t\t\terr = pc.Close()\n\t\t\t\tassert.Nil(t, err)\n\t\t\t\treturn pc, err\n\t\t\t},\n\t\t\tconfig:  Configuration{},\n\t\t\twantErr: &rtcerr.InvalidStateError{Err: ErrConnectionClosed},\n\t\t},\n\t\t{\n\t\t\tname: \"update PeerIdentity\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\treturn NewPeerConnection(Configuration{})\n\t\t\t},\n\t\t\tconfig: Configuration{\n\t\t\t\tPeerIdentity: \"unittest\",\n\t\t\t},\n\t\t\twantErr: &rtcerr.InvalidModificationError{Err: ErrModifyingPeerIdentity},\n\t\t},\n\t\t{\n\t\t\tname: \"update BundlePolicy\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\treturn NewPeerConnection(Configuration{})\n\t\t\t},\n\t\t\tconfig: Configuration{\n\t\t\t\tBundlePolicy: BundlePolicyMaxCompat,\n\t\t\t},\n\t\t\twantErr: &rtcerr.InvalidModificationError{Err: ErrModifyingBundlePolicy},\n\t\t},\n\t\t{\n\t\t\tname: \"update RTCPMuxPolicy\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\treturn NewPeerConnection(Configuration{})\n\t\t\t},\n\t\t\tconfig: Configuration{\n\t\t\t\tRTCPMuxPolicy: RTCPMuxPolicyNegotiate,\n\t\t\t},\n\t\t\twantErr: &rtcerr.InvalidModificationError{Err: ErrModifyingRTCPMuxPolicy},\n\t\t},\n\t\t{\n\t\t\tname: \"update ICECandidatePoolSize\",\n\t\t\tinit: func() (*PeerConnection, error) {\n\t\t\t\tpc, err := NewPeerConnection(Configuration{\n\t\t\t\t\tICECandidatePoolSize: 0,\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn pc, err\n\t\t\t\t}\n\t\t\t\toffer, err := pc.CreateOffer(nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn pc, err\n\t\t\t\t}\n\t\t\t\terr = pc.SetLocalDescription(offer)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn pc, err\n\t\t\t\t}\n\t\t\t\treturn pc, nil\n\t\t\t},\n\t\t\tconfig: Configuration{\n\t\t\t\tICECandidatePoolSize: 1,\n\t\t\t},\n\t\t\twantErr: &rtcerr.InvalidModificationError{Err: ErrModifyingICECandidatePoolSize},\n\t\t},\n\t} {\n\t\tpc, err := test.init()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"SetConfiguration %q: init failed: %v\", test.name, err)\n\t\t}\n\n\t\terr = pc.SetConfiguration(test.config)\n\t\tif got, want := err, test.wantErr; !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"SetConfiguration %q: err = %v, want %v\", test.name, got, want)\n\t\t}\n\n\t\tassert.NoError(t, pc.Close())\n\t}\n}\n\nfunc TestPeerConnection_GetConfiguration(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\texpected := Configuration{\n\t\tICEServers:           []ICEServer{},\n\t\tICETransportPolicy:   ICETransportPolicyAll,\n\t\tBundlePolicy:         BundlePolicyBalanced,\n\t\tRTCPMuxPolicy:        RTCPMuxPolicyRequire,\n\t\tICECandidatePoolSize: 0,\n\t}\n\tactual := pc.GetConfiguration()\n\tassert.True(t, &expected != &actual)\n\tassert.Equal(t, expected.ICEServers, actual.ICEServers)\n\tassert.Equal(t, expected.ICETransportPolicy, actual.ICETransportPolicy)\n\tassert.Equal(t, expected.BundlePolicy, actual.BundlePolicy)\n\tassert.Equal(t, expected.RTCPMuxPolicy, actual.RTCPMuxPolicy)\n\t// nolint:godox\n\t// TODO(albrow): Uncomment this after #513 is fixed.\n\t// See: https://github.com/pion/webrtc/issues/513.\n\t// assert.Equal(t, len(expected.Certificates), len(actual.Certificates))\n\tassert.Equal(t, expected.ICECandidatePoolSize, actual.ICECandidatePoolSize)\n\tassert.NoError(t, pc.Close())\n}\n\nconst minimalOffer = `v=0\no=- 4596489990601351948 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE data\na=msid-semantic: WMS\nm=application 47299 DTLS/SCTP 5000\nc=IN IP4 192.168.20.129\na=candidate:1966762134 1 udp 2122260223 192.168.20.129 47299 typ host generation 0\na=candidate:1966762134 1 udp 2122262783 2001:db8::1 47199 typ host generation 0\na=candidate:211962667 1 udp 2122194687 10.0.3.1 40864 typ host generation 0\na=candidate:1002017894 1 tcp 1518280447 192.168.20.129 0 typ host tcptype active generation 0\na=candidate:1109506011 1 tcp 1518214911 10.0.3.1 0 typ host tcptype active generation 0\na=ice-ufrag:1/MvHwjAyVf27aLu\na=ice-pwd:3dBU7cFOBl120v33cynDvN1E\na=ice-options:google-ice\na=fingerprint:sha-256 75:74:5A:A6:A4:E5:52:F4:A7:67:4C:01:C7:EE:91:3F:21:3D:A2:E3:53:7B:6F:30:86:F2:30:AA:65:FB:04:24\na=setup:actpass\na=mid:data\na=sctpmap:5000 webrtc-datachannel 1024\n`\n\nfunc TestSetRemoteDescription(t *testing.T) {\n\ttestCases := []struct {\n\t\tdesc        SessionDescription\n\t\texpectError bool\n\t}{\n\t\t{SessionDescription{Type: SDPTypeOffer, SDP: minimalOffer}, false},\n\t\t{SessionDescription{Type: 0, SDP: \"\"}, true},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tpeerConn, err := NewPeerConnection(Configuration{})\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Case %d: got error: %v\", i, err)\n\t\t}\n\n\t\tif testCase.expectError {\n\t\t\tassert.Error(t, peerConn.SetRemoteDescription(testCase.desc))\n\t\t} else {\n\t\t\tassert.NoError(t, peerConn.SetRemoteDescription(testCase.desc))\n\t\t}\n\n\t\tassert.NoError(t, peerConn.Close())\n\t}\n}\n\nfunc TestCreateOfferAnswer(t *testing.T) {\n\tofferPeerConn, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tanswerPeerConn, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\t_, err = offerPeerConn.CreateDataChannel(\"test-channel\", nil)\n\tassert.NoError(t, err)\n\n\toffer, err := offerPeerConn.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, offerPeerConn.SetLocalDescription(offer))\n\n\tassert.NoError(t, answerPeerConn.SetRemoteDescription(offer))\n\n\tanswer, err := answerPeerConn.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, answerPeerConn.SetLocalDescription(answer))\n\tassert.NoError(t, offerPeerConn.SetRemoteDescription(answer))\n\n\t// after setLocalDescription(answer), signaling state should be stable.\n\t// so CreateAnswer should return an InvalidStateError\n\tassert.Equal(t, answerPeerConn.SignalingState(), SignalingStateStable)\n\t_, err = answerPeerConn.CreateAnswer(nil)\n\tassert.Error(t, err)\n\n\tclosePairNow(t, offerPeerConn, answerPeerConn)\n}\n\nfunc TestPeerConnection_EventHandlers(t *testing.T) {\n\tpcOffer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\tpcAnswer, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\t// wasCalled is a list of event handlers that were called.\n\twasCalled := []string{}\n\twasCalledMut := &sync.Mutex{}\n\t// wg is used to wait for all event handlers to be called.\n\twg := &sync.WaitGroup{}\n\twg.Add(6)\n\n\t// Each sync.Once is used to ensure that we call wg.Done once for each event\n\t// handler and don't add multiple entries to wasCalled. The event handlers can\n\t// be called more than once in some cases.\n\tonceOffererOnICEConnectionStateChange := &sync.Once{}\n\tonceOffererOnConnectionStateChange := &sync.Once{}\n\tonceOffererOnSignalingStateChange := &sync.Once{}\n\tonceAnswererOnICEConnectionStateChange := &sync.Once{}\n\tonceAnswererOnConnectionStateChange := &sync.Once{}\n\tonceAnswererOnSignalingStateChange := &sync.Once{}\n\n\t// Register all the event handlers.\n\tpcOffer.OnICEConnectionStateChange(func(ICEConnectionState) {\n\t\tonceOffererOnICEConnectionStateChange.Do(func() {\n\t\t\twasCalledMut.Lock()\n\t\t\tdefer wasCalledMut.Unlock()\n\t\t\twasCalled = append(wasCalled, \"offerer OnICEConnectionStateChange\")\n\t\t\twg.Done()\n\t\t})\n\t})\n\tpcOffer.OnConnectionStateChange(func(PeerConnectionState) {\n\t\tonceOffererOnConnectionStateChange.Do(func() {\n\t\t\twasCalledMut.Lock()\n\t\t\tdefer wasCalledMut.Unlock()\n\t\t\twasCalled = append(wasCalled, \"offerer OnConnectionStateChange\")\n\t\t\twg.Done()\n\t\t})\n\t})\n\tpcOffer.OnSignalingStateChange(func(SignalingState) {\n\t\tonceOffererOnSignalingStateChange.Do(func() {\n\t\t\twasCalledMut.Lock()\n\t\t\tdefer wasCalledMut.Unlock()\n\t\t\twasCalled = append(wasCalled, \"offerer OnSignalingStateChange\")\n\t\t\twg.Done()\n\t\t})\n\t})\n\tpcAnswer.OnICEConnectionStateChange(func(ICEConnectionState) {\n\t\tonceAnswererOnICEConnectionStateChange.Do(func() {\n\t\t\twasCalledMut.Lock()\n\t\t\tdefer wasCalledMut.Unlock()\n\t\t\twasCalled = append(wasCalled, \"answerer OnICEConnectionStateChange\")\n\t\t\twg.Done()\n\t\t})\n\t})\n\tpcAnswer.OnConnectionStateChange(func(PeerConnectionState) {\n\t\tonceAnswererOnConnectionStateChange.Do(func() {\n\t\t\twasCalledMut.Lock()\n\t\t\tdefer wasCalledMut.Unlock()\n\t\t\twasCalled = append(wasCalled, \"answerer OnConnectionStateChange\")\n\t\t\twg.Done()\n\t\t})\n\t})\n\tpcAnswer.OnSignalingStateChange(func(SignalingState) {\n\t\tonceAnswererOnSignalingStateChange.Do(func() {\n\t\t\twasCalledMut.Lock()\n\t\t\tdefer wasCalledMut.Unlock()\n\t\t\twasCalled = append(wasCalled, \"answerer OnSignalingStateChange\")\n\t\t\twg.Done()\n\t\t})\n\t})\n\n\t// Use signalPair to establish a connection between pcOffer and pcAnswer. This\n\t// process should trigger the above event handlers.\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t// Wait for all of the event handlers to be triggered.\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tdone <- struct{}{}\n\t}()\n\ttimeout := time.After(5 * time.Second)\n\tselect {\n\tcase <-done:\n\t\tbreak\n\tcase <-timeout:\n\t\tt.Fatalf(\"timed out waiting for one or more events handlers to be called (these *were* called: %+v)\", wasCalled)\n\t}\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestMultipleOfferAnswer(t *testing.T) {\n\tfirstPeerConn, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Errorf(\"New PeerConnection: got error: %v\", err)\n\t}\n\n\tif _, err = firstPeerConn.CreateOffer(nil); err != nil {\n\t\tt.Errorf(\"First Offer: got error: %v\", err)\n\t}\n\tif _, err = firstPeerConn.CreateOffer(nil); err != nil {\n\t\tt.Errorf(\"Second Offer: got error: %v\", err)\n\t}\n\n\tsecondPeerConn, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Errorf(\"New PeerConnection: got error: %v\", err)\n\t}\n\tsecondPeerConn.OnICECandidate(func(*ICECandidate) {\n\t})\n\n\tif _, err = secondPeerConn.CreateOffer(nil); err != nil {\n\t\tt.Errorf(\"First Offer: got error: %v\", err)\n\t}\n\tif _, err = secondPeerConn.CreateOffer(nil); err != nil {\n\t\tt.Errorf(\"Second Offer: got error: %v\", err)\n\t}\n\n\tclosePairNow(t, firstPeerConn, secondPeerConn)\n}\n\nfunc TestNoFingerprintInFirstMediaIfSetRemoteDescription(t *testing.T) {\n\tconst sdpNoFingerprintInFirstMedia = `v=0\no=- 143087887 1561022767 IN IP4 192.168.84.254\ns=VideoRoom 404986692241682\nt=0 0\na=group:BUNDLE audio\na=msid-semantic: WMS 2867270241552712\nm=video 0 UDP/TLS/RTP/SAVPF 0\na=mid:video\nc=IN IP4 192.168.84.254\na=inactive\nm=audio 9 UDP/TLS/RTP/SAVPF 111\nc=IN IP4 192.168.84.254\na=recvonly\na=mid:audio\na=rtcp-mux\na=ice-ufrag:AS/w\na=ice-pwd:9NOgoAOMALYu/LOpA1iqg/\na=ice-options:trickle\na=fingerprint:sha-256 D2:B9:31:8F:DF:24:D8:0E:ED:D2:EF:25:9E:AF:6F:B8:34:AE:53:9C:E6:F3:8F:F2:64:15:FA:E8:7F:53:2D:38\na=setup:active\na=rtpmap:111 opus/48000/2\na=candidate:1 1 udp 2013266431 192.168.84.254 46492 typ host\na=end-of-candidates\n`\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tdesc := SessionDescription{\n\t\tType: SDPTypeOffer,\n\t\tSDP:  sdpNoFingerprintInFirstMedia,\n\t}\n\n\tif err = pc.SetRemoteDescription(desc); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestNegotiationNeeded(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpc, err := NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tpc.OnNegotiationNeeded(wg.Done)\n\t_, err = pc.CreateDataChannel(\"initial_data_channel\", nil)\n\tassert.NoError(t, err)\n\n\twg.Wait()\n\n\tassert.NoError(t, pc.Close())\n}\n\nfunc TestMultipleCreateChannel(t *testing.T) {\n\tvar wg sync.WaitGroup\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\t// Two OnDataChannel\n\t// One OnNegotiationNeeded\n\twg.Add(3)\n\n\tpcOffer, _ := NewPeerConnection(Configuration{})\n\tpcAnswer, _ := NewPeerConnection(Configuration{})\n\n\tpcAnswer.OnDataChannel(func(*DataChannel) {\n\t\twg.Done()\n\t})\n\n\tpcOffer.OnNegotiationNeeded(func() {\n\t\toffer, err := pcOffer.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\t\tif err = pcOffer.SetLocalDescription(offer); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\t<-offerGatheringComplete\n\t\tif err = pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tanswer, err := pcAnswer.CreateAnswer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\t\tif err = pcAnswer.SetLocalDescription(answer); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\t<-answerGatheringComplete\n\t\tif err = pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\twg.Done()\n\t})\n\n\tif _, err := pcOffer.CreateDataChannel(\"initial_data_channel_0\", nil); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err := pcOffer.CreateDataChannel(\"initial_data_channel_1\", nil); err != nil {\n\t\tt.Error(err)\n\t}\n\n\twg.Wait()\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Assert that candidates are gathered by calling SetLocalDescription, not SetRemoteDescription\nfunc TestGatherOnSetLocalDescription(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOfferGathered := make(chan SessionDescription)\n\tpcAnswerGathered := make(chan SessionDescription)\n\n\ts := SettingEngine{}\n\tapi := NewAPI(WithSettingEngine(s))\n\n\tpcOffer, err := api.NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\t// We need to create a data channel in order to trigger ICE\n\tif _, err = pcOffer.CreateDataChannel(\"initial_data_channel\", nil); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tpcOffer.OnICECandidate(func(i *ICECandidate) {\n\t\tif i == nil {\n\t\t\tclose(pcOfferGathered)\n\t\t}\n\t})\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t} else if err = pcOffer.SetLocalDescription(offer); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\t<-pcOfferGathered\n\n\tpcAnswer, err := api.NewPeerConnection(Configuration{})\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tpcAnswer.OnICECandidate(func(i *ICECandidate) {\n\t\tif i == nil {\n\t\t\tclose(pcAnswerGathered)\n\t\t}\n\t})\n\n\tif err = pcAnswer.SetRemoteDescription(offer); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tselect {\n\tcase <-pcAnswerGathered:\n\t\tt.Fatal(\"pcAnswer started gathering with no SetLocalDescription\")\n\t// Gathering is async, not sure of a better way to catch this currently\n\tcase <-time.After(3 * time.Second):\n\t}\n\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t} else if err = pcAnswer.SetLocalDescription(answer); err != nil {\n\t\tt.Error(err.Error())\n\t}\n\t<-pcAnswerGathered\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Assert that SetRemoteDescription handles invalid states\nfunc TestSetRemoteDescriptionInvalid(t *testing.T) {\n\tt.Run(\"local-offer+SetRemoteDescription(Offer)\", func(t *testing.T) {\n\t\tpc, err := NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\toffer, err := pc.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, pc.SetLocalDescription(offer))\n\t\tassert.Error(t, pc.SetRemoteDescription(offer))\n\n\t\tassert.NoError(t, pc.Close())\n\t})\n}\n\nfunc TestAddTransceiver(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tfor _, testCase := range []struct {\n\t\texpectSender, expectReceiver bool\n\t\tdirection                    RTPTransceiverDirection\n\t}{\n\t\t{true, true, RTPTransceiverDirectionSendrecv},\n\t\t// Go and WASM diverge\n\t\t// {true, false, RTPTransceiverDirectionSendonly},\n\t\t// {false, true, RTPTransceiverDirectionRecvonly},\n\t} {\n\t\tpc, err := NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\ttransceiver, err := pc.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\t\tDirection: testCase.direction,\n\t\t})\n\t\tassert.NoError(t, err)\n\n\t\tif testCase.expectReceiver {\n\t\t\tassert.NotNil(t, transceiver.Receiver())\n\t\t} else {\n\t\t\tassert.Nil(t, transceiver.Receiver())\n\t\t}\n\n\t\tif testCase.expectSender {\n\t\t\tassert.NotNil(t, transceiver.Sender())\n\t\t} else {\n\t\t\tassert.Nil(t, transceiver.Sender())\n\t\t}\n\n\t\toffer, err := pc.CreateOffer(nil)\n\t\tassert.NoError(t, err)\n\n\t\tassert.True(t, offerMediaHasDirection(offer, RTPCodecTypeVideo, testCase.direction))\n\t\tassert.NoError(t, pc.Close())\n\t}\n}\n\n// Assert that SCTPTransport -> DTLSTransport -> ICETransport works after connected\nfunc TestTransportChain(t *testing.T) {\n\toffer, answer, err := newPair()\n\tassert.NoError(t, err)\n\n\tpeerConnectionsConnected := untilConnectionState(PeerConnectionStateConnected, offer, answer)\n\tassert.NoError(t, signalPair(offer, answer))\n\tpeerConnectionsConnected.Wait()\n\n\tassert.NotNil(t, offer.SCTP().Transport().ICETransport())\n\n\tclosePairNow(t, offer, answer)\n}\n\n// Assert that the PeerConnection closes via DTLS (and not ICE)\nfunc TestDTLSClose(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tpeerConnectionsConnected := untilConnectionState(PeerConnectionStateConnected, pcOffer, pcAnswer)\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tofferGatheringComplete := GatheringCompletePromise(pcOffer)\n\tassert.NoError(t, pcOffer.SetLocalDescription(offer))\n\t<-offerGatheringComplete\n\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(*pcOffer.LocalDescription()))\n\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tanswerGatheringComplete := GatheringCompletePromise(pcAnswer)\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\t<-answerGatheringComplete\n\n\tassert.NoError(t, pcOffer.SetRemoteDescription(*pcAnswer.LocalDescription()))\n\n\tpeerConnectionsConnected.Wait()\n\tassert.NoError(t, pcOffer.Close())\n}\n"
        },
        {
          "name": "peerconnectionstate.go",
          "type": "blob",
          "size": 3.068359375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// PeerConnectionState indicates the state of the PeerConnection.\ntype PeerConnectionState int\n\nconst (\n\t// PeerConnectionStateUnknown is the enum's zero-value\n\tPeerConnectionStateUnknown PeerConnectionState = iota\n\n\t// PeerConnectionStateNew indicates that any of the ICETransports or\n\t// DTLSTransports are in the \"new\" state and none of the transports are\n\t// in the \"connecting\", \"checking\", \"failed\" or \"disconnected\" state, or\n\t// all transports are in the \"closed\" state, or there are no transports.\n\tPeerConnectionStateNew\n\n\t// PeerConnectionStateConnecting indicates that any of the\n\t// ICETransports or DTLSTransports are in the \"connecting\" or\n\t// \"checking\" state and none of them is in the \"failed\" state.\n\tPeerConnectionStateConnecting\n\n\t// PeerConnectionStateConnected indicates that all ICETransports and\n\t// DTLSTransports are in the \"connected\", \"completed\" or \"closed\" state\n\t// and at least one of them is in the \"connected\" or \"completed\" state.\n\tPeerConnectionStateConnected\n\n\t// PeerConnectionStateDisconnected indicates that any of the\n\t// ICETransports or DTLSTransports are in the \"disconnected\" state\n\t// and none of them are in the \"failed\" or \"connecting\" or \"checking\" state.\n\tPeerConnectionStateDisconnected\n\n\t// PeerConnectionStateFailed indicates that any of the ICETransports\n\t// or DTLSTransports are in a \"failed\" state.\n\tPeerConnectionStateFailed\n\n\t// PeerConnectionStateClosed indicates the peer connection is closed\n\t// and the isClosed member variable of PeerConnection is true.\n\tPeerConnectionStateClosed\n)\n\n// This is done this way because of a linter.\nconst (\n\tpeerConnectionStateNewStr          = \"new\"\n\tpeerConnectionStateConnectingStr   = \"connecting\"\n\tpeerConnectionStateConnectedStr    = \"connected\"\n\tpeerConnectionStateDisconnectedStr = \"disconnected\"\n\tpeerConnectionStateFailedStr       = \"failed\"\n\tpeerConnectionStateClosedStr       = \"closed\"\n)\n\nfunc newPeerConnectionState(raw string) PeerConnectionState {\n\tswitch raw {\n\tcase peerConnectionStateNewStr:\n\t\treturn PeerConnectionStateNew\n\tcase peerConnectionStateConnectingStr:\n\t\treturn PeerConnectionStateConnecting\n\tcase peerConnectionStateConnectedStr:\n\t\treturn PeerConnectionStateConnected\n\tcase peerConnectionStateDisconnectedStr:\n\t\treturn PeerConnectionStateDisconnected\n\tcase peerConnectionStateFailedStr:\n\t\treturn PeerConnectionStateFailed\n\tcase peerConnectionStateClosedStr:\n\t\treturn PeerConnectionStateClosed\n\tdefault:\n\t\treturn PeerConnectionStateUnknown\n\t}\n}\n\nfunc (t PeerConnectionState) String() string {\n\tswitch t {\n\tcase PeerConnectionStateNew:\n\t\treturn peerConnectionStateNewStr\n\tcase PeerConnectionStateConnecting:\n\t\treturn peerConnectionStateConnectingStr\n\tcase PeerConnectionStateConnected:\n\t\treturn peerConnectionStateConnectedStr\n\tcase PeerConnectionStateDisconnected:\n\t\treturn peerConnectionStateDisconnectedStr\n\tcase PeerConnectionStateFailed:\n\t\treturn peerConnectionStateFailedStr\n\tcase PeerConnectionStateClosed:\n\t\treturn peerConnectionStateClosedStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n"
        },
        {
          "name": "peerconnectionstate_test.go",
          "type": "blob",
          "size": 1.4091796875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewPeerConnectionState(t *testing.T) {\n\ttestCases := []struct {\n\t\tstateString   string\n\t\texpectedState PeerConnectionState\n\t}{\n\t\t{ErrUnknownType.Error(), PeerConnectionStateUnknown},\n\t\t{\"new\", PeerConnectionStateNew},\n\t\t{\"connecting\", PeerConnectionStateConnecting},\n\t\t{\"connected\", PeerConnectionStateConnected},\n\t\t{\"disconnected\", PeerConnectionStateDisconnected},\n\t\t{\"failed\", PeerConnectionStateFailed},\n\t\t{\"closed\", PeerConnectionStateClosed},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedState,\n\t\t\tnewPeerConnectionState(testCase.stateString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestPeerConnectionState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          PeerConnectionState\n\t\texpectedString string\n\t}{\n\t\t{PeerConnectionStateUnknown, ErrUnknownType.Error()},\n\t\t{PeerConnectionStateNew, \"new\"},\n\t\t{PeerConnectionStateConnecting, \"connecting\"},\n\t\t{PeerConnectionStateConnected, \"connected\"},\n\t\t{PeerConnectionStateDisconnected, \"disconnected\"},\n\t\t{PeerConnectionStateFailed, \"failed\"},\n\t\t{PeerConnectionStateClosed, \"closed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "renovate.json",
          "type": "blob",
          "size": 0.1201171875,
          "content": "{\n  \"$schema\": \"https://docs.renovatebot.com/renovate-schema.json\",\n  \"extends\": [\n    \"github>pion/renovate-config\"\n  ]\n}\n"
        },
        {
          "name": "rtcpfeedback.go",
          "type": "blob",
          "size": 0.8310546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nconst (\n\t// TypeRTCPFBTransportCC ..\n\tTypeRTCPFBTransportCC = \"transport-cc\"\n\n\t// TypeRTCPFBGoogREMB ..\n\tTypeRTCPFBGoogREMB = \"goog-remb\"\n\n\t// TypeRTCPFBACK ..\n\tTypeRTCPFBACK = \"ack\"\n\n\t// TypeRTCPFBCCM ..\n\tTypeRTCPFBCCM = \"ccm\"\n\n\t// TypeRTCPFBNACK ..\n\tTypeRTCPFBNACK = \"nack\"\n)\n\n// RTCPFeedback signals the connection to use additional RTCP packet types.\n// https://draft.ortc.org/#dom-rtcrtcpfeedback\ntype RTCPFeedback struct {\n\t// Type is the type of feedback.\n\t// see: https://draft.ortc.org/#dom-rtcrtcpfeedback\n\t// valid: ack, ccm, nack, goog-remb, transport-cc\n\tType string\n\n\t// The parameter value depends on the type.\n\t// For example, type=\"nack\" parameter=\"pli\" will send Picture Loss Indicator packets.\n\tParameter string\n}\n"
        },
        {
          "name": "rtcpmuxpolicy.go",
          "type": "blob",
          "size": 1.8232421875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n)\n\n// RTCPMuxPolicy affects what ICE candidates are gathered to support\n// non-multiplexed RTCP.\ntype RTCPMuxPolicy int\n\nconst (\n\t// RTCPMuxPolicyUnknown is the enum's zero-value\n\tRTCPMuxPolicyUnknown RTCPMuxPolicy = iota\n\n\t// RTCPMuxPolicyNegotiate indicates to gather ICE candidates for both\n\t// RTP and RTCP candidates. If the remote-endpoint is capable of\n\t// multiplexing RTCP, multiplex RTCP on the RTP candidates. If it is not,\n\t// use both the RTP and RTCP candidates separately.\n\tRTCPMuxPolicyNegotiate\n\n\t// RTCPMuxPolicyRequire indicates to gather ICE candidates only for\n\t// RTP and multiplex RTCP on the RTP candidates. If the remote endpoint is\n\t// not capable of rtcp-mux, session negotiation will fail.\n\tRTCPMuxPolicyRequire\n)\n\n// This is done this way because of a linter.\nconst (\n\trtcpMuxPolicyNegotiateStr = \"negotiate\"\n\trtcpMuxPolicyRequireStr   = \"require\"\n)\n\nfunc newRTCPMuxPolicy(raw string) RTCPMuxPolicy {\n\tswitch raw {\n\tcase rtcpMuxPolicyNegotiateStr:\n\t\treturn RTCPMuxPolicyNegotiate\n\tcase rtcpMuxPolicyRequireStr:\n\t\treturn RTCPMuxPolicyRequire\n\tdefault:\n\t\treturn RTCPMuxPolicyUnknown\n\t}\n}\n\nfunc (t RTCPMuxPolicy) String() string {\n\tswitch t {\n\tcase RTCPMuxPolicyNegotiate:\n\t\treturn rtcpMuxPolicyNegotiateStr\n\tcase RTCPMuxPolicyRequire:\n\t\treturn rtcpMuxPolicyRequireStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// UnmarshalJSON parses the JSON-encoded data and stores the result\nfunc (t *RTCPMuxPolicy) UnmarshalJSON(b []byte) error {\n\tvar val string\n\tif err := json.Unmarshal(b, &val); err != nil {\n\t\treturn err\n\t}\n\n\t*t = newRTCPMuxPolicy(val)\n\treturn nil\n}\n\n// MarshalJSON returns the JSON encoding\nfunc (t RTCPMuxPolicy) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(t.String())\n}\n"
        },
        {
          "name": "rtcpmuxpolicy_test.go",
          "type": "blob",
          "size": 1.005859375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewRTCPMuxPolicy(t *testing.T) {\n\ttestCases := []struct {\n\t\tpolicyString   string\n\t\texpectedPolicy RTCPMuxPolicy\n\t}{\n\t\t{ErrUnknownType.Error(), RTCPMuxPolicyUnknown},\n\t\t{\"negotiate\", RTCPMuxPolicyNegotiate},\n\t\t{\"require\", RTCPMuxPolicyRequire},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedPolicy,\n\t\t\tnewRTCPMuxPolicy(testCase.policyString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestRTCPMuxPolicy_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tpolicy         RTCPMuxPolicy\n\t\texpectedString string\n\t}{\n\t\t{RTCPMuxPolicyUnknown, ErrUnknownType.Error()},\n\t\t{RTCPMuxPolicyNegotiate, \"negotiate\"},\n\t\t{RTCPMuxPolicyRequire, \"require\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.policy.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "rtpcapabilities.go",
          "type": "blob",
          "size": 0.3515625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPCapabilities represents the capabilities of a transceiver\n//\n// https://w3c.github.io/webrtc-pc/#rtcrtpcapabilities\ntype RTPCapabilities struct {\n\tCodecs           []RTPCodecCapability\n\tHeaderExtensions []RTPHeaderExtensionCapability\n}\n"
        },
        {
          "name": "rtpcodec.go",
          "type": "blob",
          "size": 4.0234375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/pion/webrtc/v4/internal/fmtp\"\n)\n\n// RTPCodecType determines the type of a codec\ntype RTPCodecType int\n\nconst (\n\t// RTPCodecTypeUnknown is the enum's zero-value\n\tRTPCodecTypeUnknown RTPCodecType = iota\n\n\t// RTPCodecTypeAudio indicates this is an audio codec\n\tRTPCodecTypeAudio\n\n\t// RTPCodecTypeVideo indicates this is a video codec\n\tRTPCodecTypeVideo\n)\n\nfunc (t RTPCodecType) String() string {\n\tswitch t {\n\tcase RTPCodecTypeAudio:\n\t\treturn \"audio\" //nolint: goconst\n\tcase RTPCodecTypeVideo:\n\t\treturn \"video\" //nolint: goconst\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// NewRTPCodecType creates a RTPCodecType from a string\nfunc NewRTPCodecType(r string) RTPCodecType {\n\tswitch {\n\tcase strings.EqualFold(r, RTPCodecTypeAudio.String()):\n\t\treturn RTPCodecTypeAudio\n\tcase strings.EqualFold(r, RTPCodecTypeVideo.String()):\n\t\treturn RTPCodecTypeVideo\n\tdefault:\n\t\treturn RTPCodecType(0)\n\t}\n}\n\n// RTPCodecCapability provides information about codec capabilities.\n//\n// https://w3c.github.io/webrtc-pc/#dictionary-rtcrtpcodeccapability-members\ntype RTPCodecCapability struct {\n\tMimeType     string\n\tClockRate    uint32\n\tChannels     uint16\n\tSDPFmtpLine  string\n\tRTCPFeedback []RTCPFeedback\n}\n\n// RTPHeaderExtensionCapability is used to define a RFC5285 RTP header extension supported by the codec.\n//\n// https://w3c.github.io/webrtc-pc/#dom-rtcrtpcapabilities-headerextensions\ntype RTPHeaderExtensionCapability struct {\n\tURI string\n}\n\n// RTPHeaderExtensionParameter represents a negotiated RFC5285 RTP header extension.\n//\n// https://w3c.github.io/webrtc-pc/#dictionary-rtcrtpheaderextensionparameters-members\ntype RTPHeaderExtensionParameter struct {\n\tURI string\n\tID  int\n}\n\n// RTPCodecParameters is a sequence containing the media codecs that an RtpSender\n// will choose from, as well as entries for RTX, RED and FEC mechanisms. This also\n// includes the PayloadType that has been negotiated\n//\n// https://w3c.github.io/webrtc-pc/#rtcrtpcodecparameters\ntype RTPCodecParameters struct {\n\tRTPCodecCapability\n\tPayloadType PayloadType\n\n\tstatsID string\n}\n\n// RTPParameters is a list of negotiated codecs and header extensions\n//\n// https://w3c.github.io/webrtc-pc/#dictionary-rtcrtpparameters-members\ntype RTPParameters struct {\n\tHeaderExtensions []RTPHeaderExtensionParameter\n\tCodecs           []RTPCodecParameters\n}\n\ntype codecMatchType int\n\nconst (\n\tcodecMatchNone    codecMatchType = 0\n\tcodecMatchPartial codecMatchType = 1\n\tcodecMatchExact   codecMatchType = 2\n)\n\n// Do a fuzzy find for a codec in the list of codecs\n// Used for lookup up a codec in an existing list to find a match\n// Returns codecMatchExact, codecMatchPartial, or codecMatchNone\nfunc codecParametersFuzzySearch(needle RTPCodecParameters, haystack []RTPCodecParameters) (RTPCodecParameters, codecMatchType) {\n\tneedleFmtp := fmtp.Parse(needle.RTPCodecCapability.MimeType, needle.RTPCodecCapability.SDPFmtpLine)\n\n\t// First attempt to match on MimeType + SDPFmtpLine\n\tfor _, c := range haystack {\n\t\tcfmtp := fmtp.Parse(c.RTPCodecCapability.MimeType, c.RTPCodecCapability.SDPFmtpLine)\n\t\tif needleFmtp.Match(cfmtp) {\n\t\t\treturn c, codecMatchExact\n\t\t}\n\t}\n\n\t// Fallback to just MimeType\n\tfor _, c := range haystack {\n\t\tif strings.EqualFold(c.RTPCodecCapability.MimeType, needle.RTPCodecCapability.MimeType) {\n\t\t\treturn c, codecMatchPartial\n\t\t}\n\t}\n\n\treturn RTPCodecParameters{}, codecMatchNone\n}\n\n// Given a CodecParameters find the RTX CodecParameters if one exists\nfunc findRTXPayloadType(needle PayloadType, haystack []RTPCodecParameters) PayloadType {\n\taptStr := fmt.Sprintf(\"apt=%d\", needle)\n\tfor _, c := range haystack {\n\t\tif aptStr == c.SDPFmtpLine {\n\t\t\treturn c.PayloadType\n\t\t}\n\t}\n\n\treturn PayloadType(0)\n}\n\nfunc rtcpFeedbackIntersection(a, b []RTCPFeedback) (out []RTCPFeedback) {\n\tfor _, aFeedback := range a {\n\t\tfor _, bFeeback := range b {\n\t\t\tif aFeedback.Type == bFeeback.Type && aFeedback.Parameter == bFeeback.Parameter {\n\t\t\t\tout = append(out, aFeedback)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "rtpcodingparameters.go",
          "type": "blob",
          "size": 1.0029296875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPRtxParameters dictionary contains information relating to retransmission (RTX) settings.\n// https://draft.ortc.org/#dom-rtcrtprtxparameters\ntype RTPRtxParameters struct {\n\tSSRC SSRC `json:\"ssrc\"`\n}\n\n// RTPFecParameters dictionary contains information relating to forward error correction (FEC) settings.\n// https://draft.ortc.org/#dom-rtcrtpfecparameters\ntype RTPFecParameters struct {\n\tSSRC SSRC `json:\"ssrc\"`\n}\n\n// RTPCodingParameters provides information relating to both encoding and decoding.\n// This is a subset of the RFC since Pion WebRTC doesn't implement encoding/decoding itself\n// http://draft.ortc.org/#dom-rtcrtpcodingparameters\ntype RTPCodingParameters struct {\n\tRID         string           `json:\"rid\"`\n\tSSRC        SSRC             `json:\"ssrc\"`\n\tPayloadType PayloadType      `json:\"payloadType\"`\n\tRTX         RTPRtxParameters `json:\"rtx\"`\n\tFEC         RTPFecParameters `json:\"fec\"`\n}\n"
        },
        {
          "name": "rtpdecodingparameters.go",
          "type": "blob",
          "size": 0.3916015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPDecodingParameters provides information relating to both encoding and decoding.\n// This is a subset of the RFC since Pion WebRTC doesn't implement decoding itself\n// http://draft.ortc.org/#dom-rtcrtpdecodingparameters\ntype RTPDecodingParameters struct {\n\tRTPCodingParameters\n}\n"
        },
        {
          "name": "rtpencodingparameters.go",
          "type": "blob",
          "size": 0.3916015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPEncodingParameters provides information relating to both encoding and decoding.\n// This is a subset of the RFC since Pion WebRTC doesn't implement encoding itself\n// http://draft.ortc.org/#dom-rtcrtpencodingparameters\ntype RTPEncodingParameters struct {\n\tRTPCodingParameters\n}\n"
        },
        {
          "name": "rtpreceiveparameters.go",
          "type": "blob",
          "size": 0.2578125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPReceiveParameters contains the RTP stack settings used by receivers\ntype RTPReceiveParameters struct {\n\tEncodings []RTPDecodingParameters\n}\n"
        },
        {
          "name": "rtpreceiver.go",
          "type": "blob",
          "size": 14.72265625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/rtcp\"\n\t\"github.com/pion/srtp/v3\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n)\n\n// trackStreams maintains a mapping of RTP/RTCP streams to a specific track\n// a RTPReceiver may contain multiple streams if we are dealing with Simulcast\ntype trackStreams struct {\n\ttrack *TrackRemote\n\n\tstreamInfo, repairStreamInfo *interceptor.StreamInfo\n\n\trtpReadStream  *srtp.ReadStreamSRTP\n\trtpInterceptor interceptor.RTPReader\n\n\trtcpReadStream  *srtp.ReadStreamSRTCP\n\trtcpInterceptor interceptor.RTCPReader\n\n\trepairReadStream    *srtp.ReadStreamSRTP\n\trepairInterceptor   interceptor.RTPReader\n\trepairStreamChannel chan rtxPacketWithAttributes\n\n\trepairRtcpReadStream  *srtp.ReadStreamSRTCP\n\trepairRtcpInterceptor interceptor.RTCPReader\n}\n\ntype rtxPacketWithAttributes struct {\n\tpkt        []byte\n\tattributes interceptor.Attributes\n\tpool       *sync.Pool\n}\n\nfunc (p *rtxPacketWithAttributes) release() {\n\tif p.pkt != nil {\n\t\tb := p.pkt[:cap(p.pkt)]\n\t\tp.pool.Put(b) // nolint:staticcheck\n\t\tp.pkt = nil\n\t}\n}\n\n// RTPReceiver allows an application to inspect the receipt of a TrackRemote\ntype RTPReceiver struct {\n\tkind      RTPCodecType\n\ttransport *DTLSTransport\n\n\ttracks []trackStreams\n\n\tclosed, received chan interface{}\n\tmu               sync.RWMutex\n\n\ttr *RTPTransceiver\n\n\t// A reference to the associated api object\n\tapi *API\n\n\trtxPool sync.Pool\n}\n\n// NewRTPReceiver constructs a new RTPReceiver\nfunc (api *API) NewRTPReceiver(kind RTPCodecType, transport *DTLSTransport) (*RTPReceiver, error) {\n\tif transport == nil {\n\t\treturn nil, errRTPReceiverDTLSTransportNil\n\t}\n\n\tr := &RTPReceiver{\n\t\tkind:      kind,\n\t\ttransport: transport,\n\t\tapi:       api,\n\t\tclosed:    make(chan interface{}),\n\t\treceived:  make(chan interface{}),\n\t\ttracks:    []trackStreams{},\n\t\trtxPool: sync.Pool{New: func() interface{} {\n\t\t\treturn make([]byte, api.settingEngine.getReceiveMTU())\n\t\t}},\n\t}\n\n\treturn r, nil\n}\n\nfunc (r *RTPReceiver) setRTPTransceiver(tr *RTPTransceiver) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.tr = tr\n}\n\n// Transport returns the currently-configured *DTLSTransport or nil\n// if one has not yet been configured\nfunc (r *RTPReceiver) Transport() *DTLSTransport {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\treturn r.transport\n}\n\nfunc (r *RTPReceiver) getParameters() RTPParameters {\n\tparameters := r.api.mediaEngine.getRTPParametersByKind(r.kind, []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly})\n\tif r.tr != nil {\n\t\tparameters.Codecs = r.tr.getCodecs()\n\t}\n\treturn parameters\n}\n\n// GetParameters describes the current configuration for the encoding and\n// transmission of media on the receiver's track.\nfunc (r *RTPReceiver) GetParameters() RTPParameters {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\treturn r.getParameters()\n}\n\n// Track returns the RtpTransceiver TrackRemote\nfunc (r *RTPReceiver) Track() *TrackRemote {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tif len(r.tracks) != 1 {\n\t\treturn nil\n\t}\n\treturn r.tracks[0].track\n}\n\n// Tracks returns the RtpTransceiver tracks\n// A RTPReceiver to support Simulcast may now have multiple tracks\nfunc (r *RTPReceiver) Tracks() []*TrackRemote {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tvar tracks []*TrackRemote\n\tfor i := range r.tracks {\n\t\ttracks = append(tracks, r.tracks[i].track)\n\t}\n\treturn tracks\n}\n\n// RTPTransceiver returns the RTPTransceiver this\n// RTPReceiver belongs too, or nil if none\nfunc (r *RTPReceiver) RTPTransceiver() *RTPTransceiver {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\treturn r.tr\n}\n\n// configureReceive initialize the track\nfunc (r *RTPReceiver) configureReceive(parameters RTPReceiveParameters) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tfor i := range parameters.Encodings {\n\t\tt := trackStreams{\n\t\t\ttrack: newTrackRemote(\n\t\t\t\tr.kind,\n\t\t\t\tparameters.Encodings[i].SSRC,\n\t\t\t\tparameters.Encodings[i].RTX.SSRC,\n\t\t\t\tparameters.Encodings[i].RID,\n\t\t\t\tr,\n\t\t\t),\n\t\t}\n\n\t\tr.tracks = append(r.tracks, t)\n\t}\n}\n\n// startReceive starts all the transports\nfunc (r *RTPReceiver) startReceive(parameters RTPReceiveParameters) error {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tselect {\n\tcase <-r.received:\n\t\treturn errRTPReceiverReceiveAlreadyCalled\n\tdefault:\n\t}\n\tdefer close(r.received)\n\n\tglobalParams := r.getParameters()\n\tcodec := RTPCodecCapability{}\n\tif len(globalParams.Codecs) != 0 {\n\t\tcodec = globalParams.Codecs[0].RTPCodecCapability\n\t}\n\n\tfor i := range parameters.Encodings {\n\t\tif parameters.Encodings[i].RID != \"\" {\n\t\t\t// RID based tracks will be set up in receiveForRid\n\t\t\tcontinue\n\t\t}\n\n\t\tvar t *trackStreams\n\t\tfor idx, ts := range r.tracks {\n\t\t\tif ts.track != nil && ts.track.SSRC() == parameters.Encodings[i].SSRC {\n\t\t\t\tt = &r.tracks[idx]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif t == nil {\n\t\t\treturn fmt.Errorf(\"%w: %d\", errRTPReceiverWithSSRCTrackStreamNotFound, parameters.Encodings[i].SSRC)\n\t\t}\n\n\t\tt.streamInfo = createStreamInfo(\"\", parameters.Encodings[i].SSRC, 0, 0, 0, 0, 0, codec, globalParams.HeaderExtensions)\n\t\tvar err error\n\t\tif t.rtpReadStream, t.rtpInterceptor, t.rtcpReadStream, t.rtcpInterceptor, err = r.transport.streamsForSSRC(parameters.Encodings[i].SSRC, *t.streamInfo); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif rtxSsrc := parameters.Encodings[i].RTX.SSRC; rtxSsrc != 0 {\n\t\t\tstreamInfo := createStreamInfo(\"\", rtxSsrc, 0, 0, 0, 0, 0, codec, globalParams.HeaderExtensions)\n\t\t\trtpReadStream, rtpInterceptor, rtcpReadStream, rtcpInterceptor, err := r.transport.streamsForSSRC(rtxSsrc, *streamInfo)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = r.receiveForRtx(rtxSsrc, \"\", streamInfo, rtpReadStream, rtpInterceptor, rtcpReadStream, rtcpInterceptor); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Receive initialize the track and starts all the transports\nfunc (r *RTPReceiver) Receive(parameters RTPReceiveParameters) error {\n\tr.configureReceive(parameters)\n\treturn r.startReceive(parameters)\n}\n\n// Read reads incoming RTCP for this RTPReceiver\nfunc (r *RTPReceiver) Read(b []byte) (n int, a interceptor.Attributes, err error) {\n\tselect {\n\tcase <-r.received:\n\t\treturn r.tracks[0].rtcpInterceptor.Read(b, a)\n\tcase <-r.closed:\n\t\treturn 0, nil, io.ErrClosedPipe\n\t}\n}\n\n// ReadSimulcast reads incoming RTCP for this RTPReceiver for given rid\nfunc (r *RTPReceiver) ReadSimulcast(b []byte, rid string) (n int, a interceptor.Attributes, err error) {\n\tselect {\n\tcase <-r.received:\n\t\tvar rtcpInterceptor interceptor.RTCPReader\n\n\t\tr.mu.Lock()\n\t\tfor _, t := range r.tracks {\n\t\t\tif t.track != nil && t.track.rid == rid {\n\t\t\t\trtcpInterceptor = t.rtcpInterceptor\n\t\t\t}\n\t\t}\n\t\tr.mu.Unlock()\n\n\t\tif rtcpInterceptor == nil {\n\t\t\treturn 0, nil, fmt.Errorf(\"%w: %s\", errRTPReceiverForRIDTrackStreamNotFound, rid)\n\t\t}\n\t\treturn rtcpInterceptor.Read(b, a)\n\n\tcase <-r.closed:\n\t\treturn 0, nil, io.ErrClosedPipe\n\t}\n}\n\n// ReadRTCP is a convenience method that wraps Read and unmarshal for you.\n// It also runs any configured interceptors.\nfunc (r *RTPReceiver) ReadRTCP() ([]rtcp.Packet, interceptor.Attributes, error) {\n\tb := make([]byte, r.api.settingEngine.getReceiveMTU())\n\ti, attributes, err := r.Read(b)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpkts, err := rtcp.Unmarshal(b[:i])\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn pkts, attributes, nil\n}\n\n// ReadSimulcastRTCP is a convenience method that wraps ReadSimulcast and unmarshal for you\nfunc (r *RTPReceiver) ReadSimulcastRTCP(rid string) ([]rtcp.Packet, interceptor.Attributes, error) {\n\tb := make([]byte, r.api.settingEngine.getReceiveMTU())\n\ti, attributes, err := r.ReadSimulcast(b, rid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpkts, err := rtcp.Unmarshal(b[:i])\n\treturn pkts, attributes, err\n}\n\nfunc (r *RTPReceiver) haveReceived() bool {\n\tselect {\n\tcase <-r.received:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Stop irreversibly stops the RTPReceiver\nfunc (r *RTPReceiver) Stop() error {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tvar err error\n\n\tselect {\n\tcase <-r.closed:\n\t\treturn err\n\tdefault:\n\t}\n\n\tselect {\n\tcase <-r.received:\n\t\tfor i := range r.tracks {\n\t\t\terrs := []error{}\n\n\t\t\tif r.tracks[i].rtcpReadStream != nil {\n\t\t\t\terrs = append(errs, r.tracks[i].rtcpReadStream.Close())\n\t\t\t}\n\n\t\t\tif r.tracks[i].rtpReadStream != nil {\n\t\t\t\terrs = append(errs, r.tracks[i].rtpReadStream.Close())\n\t\t\t}\n\n\t\t\tif r.tracks[i].repairReadStream != nil {\n\t\t\t\terrs = append(errs, r.tracks[i].repairReadStream.Close())\n\t\t\t}\n\n\t\t\tif r.tracks[i].repairRtcpReadStream != nil {\n\t\t\t\terrs = append(errs, r.tracks[i].repairRtcpReadStream.Close())\n\t\t\t}\n\n\t\t\tif r.tracks[i].streamInfo != nil {\n\t\t\t\tr.api.interceptor.UnbindRemoteStream(r.tracks[i].streamInfo)\n\t\t\t}\n\n\t\t\tif r.tracks[i].repairStreamInfo != nil {\n\t\t\t\tr.api.interceptor.UnbindRemoteStream(r.tracks[i].repairStreamInfo)\n\t\t\t}\n\n\t\t\terr = util.FlattenErrs(errs)\n\t\t}\n\tdefault:\n\t}\n\n\tclose(r.closed)\n\treturn err\n}\n\nfunc (r *RTPReceiver) streamsForTrack(t *TrackRemote) *trackStreams {\n\tfor i := range r.tracks {\n\t\tif r.tracks[i].track == t {\n\t\t\treturn &r.tracks[i]\n\t\t}\n\t}\n\treturn nil\n}\n\n// readRTP should only be called by a track, this only exists so we can keep state in one place\nfunc (r *RTPReceiver) readRTP(b []byte, reader *TrackRemote) (n int, a interceptor.Attributes, err error) {\n\t<-r.received\n\tif t := r.streamsForTrack(reader); t != nil {\n\t\treturn t.rtpInterceptor.Read(b, a)\n\t}\n\n\treturn 0, nil, fmt.Errorf(\"%w: %d\", errRTPReceiverWithSSRCTrackStreamNotFound, reader.SSRC())\n}\n\n// receiveForRid is the sibling of Receive expect for RIDs instead of SSRCs\n// It populates all the internal state for the given RID\nfunc (r *RTPReceiver) receiveForRid(rid string, params RTPParameters, streamInfo *interceptor.StreamInfo, rtpReadStream *srtp.ReadStreamSRTP, rtpInterceptor interceptor.RTPReader, rtcpReadStream *srtp.ReadStreamSRTCP, rtcpInterceptor interceptor.RTCPReader) (*TrackRemote, error) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tfor i := range r.tracks {\n\t\tif r.tracks[i].track.RID() == rid {\n\t\t\tr.tracks[i].track.mu.Lock()\n\t\t\tr.tracks[i].track.kind = r.kind\n\t\t\tr.tracks[i].track.codec = params.Codecs[0]\n\t\t\tr.tracks[i].track.params = params\n\t\t\tr.tracks[i].track.ssrc = SSRC(streamInfo.SSRC)\n\t\t\tr.tracks[i].track.mu.Unlock()\n\n\t\t\tr.tracks[i].streamInfo = streamInfo\n\t\t\tr.tracks[i].rtpReadStream = rtpReadStream\n\t\t\tr.tracks[i].rtpInterceptor = rtpInterceptor\n\t\t\tr.tracks[i].rtcpReadStream = rtcpReadStream\n\t\t\tr.tracks[i].rtcpInterceptor = rtcpInterceptor\n\n\t\t\treturn r.tracks[i].track, nil\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"%w: %s\", errRTPReceiverForRIDTrackStreamNotFound, rid)\n}\n\n// receiveForRtx starts a routine that processes the repair stream\nfunc (r *RTPReceiver) receiveForRtx(ssrc SSRC, rsid string, streamInfo *interceptor.StreamInfo, rtpReadStream *srtp.ReadStreamSRTP, rtpInterceptor interceptor.RTPReader, rtcpReadStream *srtp.ReadStreamSRTCP, rtcpInterceptor interceptor.RTCPReader) error {\n\tvar track *trackStreams\n\tif ssrc != 0 && len(r.tracks) == 1 {\n\t\ttrack = &r.tracks[0]\n\t} else {\n\t\tfor i := range r.tracks {\n\t\t\tif r.tracks[i].track.RID() == rsid {\n\t\t\t\ttrack = &r.tracks[i]\n\t\t\t\tif track.track.RtxSSRC() == 0 {\n\t\t\t\t\ttrack.track.setRtxSSRC(SSRC(streamInfo.SSRC))\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif track == nil {\n\t\treturn fmt.Errorf(\"%w: ssrc(%d) rsid(%s)\", errRTPReceiverForRIDTrackStreamNotFound, ssrc, rsid)\n\t}\n\n\ttrack.repairStreamInfo = streamInfo\n\ttrack.repairReadStream = rtpReadStream\n\ttrack.repairInterceptor = rtpInterceptor\n\ttrack.repairRtcpReadStream = rtcpReadStream\n\ttrack.repairRtcpInterceptor = rtcpInterceptor\n\ttrack.repairStreamChannel = make(chan rtxPacketWithAttributes, 50)\n\n\tgo func() {\n\t\tfor {\n\t\t\tb := r.rtxPool.Get().([]byte) // nolint:forcetypeassert\n\t\t\ti, attributes, err := track.repairInterceptor.Read(b, nil)\n\t\t\tif err != nil {\n\t\t\t\tr.rtxPool.Put(b) // nolint:staticcheck\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// RTX packets have a different payload format. Move the OSN in the payload to the RTP header and rewrite the\n\t\t\t// payload type and SSRC, so that we can return RTX packets to the caller 'transparently' i.e. in the same format\n\t\t\t// as non-RTX RTP packets\n\t\t\thasExtension := b[0]&0b10000 > 0\n\t\t\thasPadding := b[0]&0b100000 > 0\n\t\t\tcsrcCount := b[0] & 0b1111\n\t\t\theaderLength := uint16(12 + (4 * csrcCount))\n\t\t\tpaddingLength := 0\n\t\t\tif hasExtension {\n\t\t\t\theaderLength += 4 * (1 + binary.BigEndian.Uint16(b[headerLength+2:headerLength+4]))\n\t\t\t}\n\t\t\tif hasPadding {\n\t\t\t\tpaddingLength = int(b[i-1])\n\t\t\t}\n\n\t\t\tif i-int(headerLength)-paddingLength < 2 {\n\t\t\t\t// BWE probe packet, ignore\n\t\t\t\tr.rtxPool.Put(b) // nolint:staticcheck\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif attributes == nil {\n\t\t\t\tattributes = make(interceptor.Attributes)\n\t\t\t}\n\t\t\tattributes.Set(AttributeRtxPayloadType, b[1]&0x7F)\n\t\t\tattributes.Set(AttributeRtxSequenceNumber, binary.BigEndian.Uint16(b[2:4]))\n\t\t\tattributes.Set(AttributeRtxSsrc, binary.BigEndian.Uint32(b[8:12]))\n\n\t\t\tb[1] = (b[1] & 0x80) | uint8(track.track.PayloadType())\n\t\t\tb[2] = b[headerLength]\n\t\t\tb[3] = b[headerLength+1]\n\t\t\tbinary.BigEndian.PutUint32(b[8:12], uint32(track.track.SSRC()))\n\t\t\tcopy(b[headerLength:i-2], b[headerLength+2:i])\n\n\t\t\tselect {\n\t\t\tcase <-r.closed:\n\t\t\t\tr.rtxPool.Put(b) // nolint:staticcheck\n\t\t\t\treturn\n\t\t\tcase track.repairStreamChannel <- rtxPacketWithAttributes{pkt: b[:i-2], attributes: attributes, pool: &r.rtxPool}:\n\t\t\tdefault:\n\t\t\t\t// skip the RTX packet if the repair stream channel is full, could be blocked in the application's read loop\n\t\t\t}\n\t\t}\n\t}()\n\treturn nil\n}\n\n// SetReadDeadline sets the max amount of time the RTCP stream will block before returning. 0 is forever.\nfunc (r *RTPReceiver) SetReadDeadline(t time.Time) error {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\treturn r.tracks[0].rtcpReadStream.SetReadDeadline(t)\n}\n\n// SetReadDeadlineSimulcast sets the max amount of time the RTCP stream for a given rid will block before returning. 0 is forever.\nfunc (r *RTPReceiver) SetReadDeadlineSimulcast(deadline time.Time, rid string) error {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tfor _, t := range r.tracks {\n\t\tif t.track != nil && t.track.rid == rid {\n\t\t\treturn t.rtcpReadStream.SetReadDeadline(deadline)\n\t\t}\n\t}\n\treturn fmt.Errorf(\"%w: %s\", errRTPReceiverForRIDTrackStreamNotFound, rid)\n}\n\n// setRTPReadDeadline sets the max amount of time the RTP stream will block before returning. 0 is forever.\n// This should be fired by calling SetReadDeadline on the TrackRemote\nfunc (r *RTPReceiver) setRTPReadDeadline(deadline time.Time, reader *TrackRemote) error {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tif t := r.streamsForTrack(reader); t != nil {\n\t\treturn t.rtpReadStream.SetReadDeadline(deadline)\n\t}\n\treturn fmt.Errorf(\"%w: %d\", errRTPReceiverWithSSRCTrackStreamNotFound, reader.SSRC())\n}\n\n// readRTX returns an RTX packet if one is available on the RTX track, otherwise returns nil\nfunc (r *RTPReceiver) readRTX(reader *TrackRemote) *rtxPacketWithAttributes {\n\tif !reader.HasRTX() {\n\t\treturn nil\n\t}\n\n\tselect {\n\tcase <-r.received:\n\tdefault:\n\t\treturn nil\n\t}\n\n\tif t := r.streamsForTrack(reader); t != nil {\n\t\tselect {\n\t\tcase rtxPacketReceived := <-t.repairStreamChannel:\n\t\t\treturn &rtxPacketReceived\n\t\tdefault:\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "rtpreceiver_go.go",
          "type": "blob",
          "size": 1.0361328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport \"github.com/pion/interceptor\"\n\n// SetRTPParameters applies provided RTPParameters the RTPReceiver's tracks.\n//\n// This method is part of the ORTC API. It is not\n// meant to be used together with the basic WebRTC API.\n//\n// The amount of provided codecs must match the number of tracks on the receiver.\nfunc (r *RTPReceiver) SetRTPParameters(params RTPParameters) {\n\theaderExtensions := make([]interceptor.RTPHeaderExtension, 0, len(params.HeaderExtensions))\n\tfor _, h := range params.HeaderExtensions {\n\t\theaderExtensions = append(headerExtensions, interceptor.RTPHeaderExtension{ID: h.ID, URI: h.URI})\n\t}\n\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tfor ndx, codec := range params.Codecs {\n\t\tcurrentTrack := r.tracks[ndx].track\n\n\t\tr.tracks[ndx].streamInfo.RTPHeaderExtensions = headerExtensions\n\n\t\tcurrentTrack.mu.Lock()\n\t\tcurrentTrack.codec = codec\n\t\tcurrentTrack.params = params\n\t\tcurrentTrack.mu.Unlock()\n\t}\n}\n"
        },
        {
          "name": "rtpreceiver_go_test.go",
          "type": "blob",
          "size": 2.203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSetRTPParameters(t *testing.T) {\n\tsender, receiver, wan := createVNetPair(t, nil)\n\n\toutgoingTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = sender.AddTrack(outgoingTrack)\n\tassert.NoError(t, err)\n\n\t// Those parameters wouldn't make sense in a real application,\n\t// but for the sake of the test we just need different values.\n\tp := RTPParameters{\n\t\tCodecs: []RTPCodecParameters{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 2, \"minptime=10;useinbandfec=1\", []RTCPFeedback{{\"nack\", \"\"}}},\n\t\t\t\tPayloadType:        111,\n\t\t\t},\n\t\t},\n\t\tHeaderExtensions: []RTPHeaderExtensionParameter{\n\t\t\t{URI: sdp.SDESMidURI},\n\t\t\t{URI: sdp.SDESRTPStreamIDURI},\n\t\t\t{URI: sdesRepairRTPStreamIDURI},\n\t\t},\n\t}\n\n\tseenPacket, seenPacketCancel := context.WithCancel(context.Background())\n\treceiver.OnTrack(func(_ *TrackRemote, r *RTPReceiver) {\n\t\tr.SetRTPParameters(p)\n\n\t\tincomingTrackCodecs := r.Track().Codec()\n\n\t\tassert.EqualValues(t, p.HeaderExtensions, r.Track().params.HeaderExtensions)\n\n\t\tassert.EqualValues(t, p.Codecs[0].MimeType, incomingTrackCodecs.MimeType)\n\t\tassert.EqualValues(t, p.Codecs[0].ClockRate, incomingTrackCodecs.ClockRate)\n\t\tassert.EqualValues(t, p.Codecs[0].Channels, incomingTrackCodecs.Channels)\n\t\tassert.EqualValues(t, p.Codecs[0].SDPFmtpLine, incomingTrackCodecs.SDPFmtpLine)\n\t\tassert.EqualValues(t, p.Codecs[0].RTCPFeedback, incomingTrackCodecs.RTCPFeedback)\n\t\tassert.EqualValues(t, p.Codecs[0].PayloadType, incomingTrackCodecs.PayloadType)\n\n\t\tseenPacketCancel()\n\t})\n\n\tpeerConnectionsConnected := untilConnectionState(PeerConnectionStateConnected, sender, receiver)\n\n\tassert.NoError(t, signalPair(sender, receiver))\n\n\tpeerConnectionsConnected.Wait()\n\tassert.NoError(t, outgoingTrack.WriteSample(media.Sample{Data: []byte{0xAA}, Duration: time.Second}))\n\n\t<-seenPacket.Done()\n\tassert.NoError(t, wan.Stop())\n\tclosePairNow(t, sender, receiver)\n}\n"
        },
        {
          "name": "rtpreceiver_js.go",
          "type": "blob",
          "size": 0.361328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport \"syscall/js\"\n\n// RTPReceiver allows an application to inspect the receipt of a TrackRemote\ntype RTPReceiver struct {\n\t// Pointer to the underlying JavaScript RTCRTPReceiver object.\n\tunderlying js.Value\n}\n"
        },
        {
          "name": "rtpreceiver_test.go",
          "type": "blob",
          "size": 1.7958984375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Assert that SetReadDeadline works as expected\n// This test uses VNet since we must have zero loss\nfunc Test_RTPReceiver_SetReadDeadline(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tsender, receiver, wan := createVNetPair(t, &interceptor.Registry{})\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = sender.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tseenPacket, seenPacketCancel := context.WithCancel(context.Background())\n\treceiver.OnTrack(func(trackRemote *TrackRemote, r *RTPReceiver) {\n\t\t// Set Deadline for both RTP and RTCP Stream\n\t\tassert.NoError(t, r.SetReadDeadline(time.Now().Add(time.Second)))\n\t\tassert.NoError(t, trackRemote.SetReadDeadline(time.Now().Add(time.Second)))\n\n\t\t// First call will not error because we cache for probing\n\t\t_, _, readErr := trackRemote.ReadRTP()\n\t\tassert.NoError(t, readErr)\n\n\t\t_, _, readErr = trackRemote.ReadRTP()\n\t\tassert.Error(t, readErr)\n\n\t\t_, _, readErr = r.ReadRTCP()\n\t\tassert.Error(t, readErr)\n\n\t\tseenPacketCancel()\n\t})\n\n\tpeerConnectionsConnected := untilConnectionState(PeerConnectionStateConnected, sender, receiver)\n\n\tassert.NoError(t, signalPair(sender, receiver))\n\n\tpeerConnectionsConnected.Wait()\n\tassert.NoError(t, track.WriteSample(media.Sample{Data: []byte{0xAA}, Duration: time.Second}))\n\n\t<-seenPacket.Done()\n\tassert.NoError(t, wan.Stop())\n\tclosePairNow(t, sender, receiver)\n}\n"
        },
        {
          "name": "rtpsender.go",
          "type": "blob",
          "size": 12.748046875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/randutil\"\n\t\"github.com/pion/rtcp\"\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n)\n\ntype trackEncoding struct {\n\ttrack TrackLocal\n\n\tsrtpStream *srtpWriterFuture\n\n\trtcpInterceptor interceptor.RTCPReader\n\tstreamInfo      interceptor.StreamInfo\n\n\tcontext *baseTrackLocalContext\n\n\tssrc, ssrcRTX, ssrcFEC SSRC\n}\n\n// RTPSender allows an application to control how a given Track is encoded and transmitted to a remote peer\ntype RTPSender struct {\n\ttrackEncodings []*trackEncoding\n\n\ttransport *DTLSTransport\n\n\tpayloadType PayloadType\n\tkind        RTPCodecType\n\n\t// nolint:godox\n\t// TODO(sgotti) remove this when in future we'll avoid replacing\n\t// a transceiver sender since we can just check the\n\t// transceiver negotiation status\n\tnegotiated bool\n\n\t// A reference to the associated api object\n\tapi *API\n\tid  string\n\n\trtpTransceiver *RTPTransceiver\n\n\tmu                     sync.RWMutex\n\tsendCalled, stopCalled chan struct{}\n}\n\n// NewRTPSender constructs a new RTPSender\nfunc (api *API) NewRTPSender(track TrackLocal, transport *DTLSTransport) (*RTPSender, error) {\n\tif track == nil {\n\t\treturn nil, errRTPSenderTrackNil\n\t} else if transport == nil {\n\t\treturn nil, errRTPSenderDTLSTransportNil\n\t}\n\n\tid, err := randutil.GenerateCryptoRandomString(32, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr := &RTPSender{\n\t\ttransport:  transport,\n\t\tapi:        api,\n\t\tsendCalled: make(chan struct{}),\n\t\tstopCalled: make(chan struct{}),\n\t\tid:         id,\n\t\tkind:       track.Kind(),\n\t}\n\n\tr.addEncoding(track)\n\n\treturn r, nil\n}\n\nfunc (r *RTPSender) isNegotiated() bool {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\treturn r.negotiated\n}\n\nfunc (r *RTPSender) setNegotiated() {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.negotiated = true\n}\n\nfunc (r *RTPSender) setRTPTransceiver(rtpTransceiver *RTPTransceiver) {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\tr.rtpTransceiver = rtpTransceiver\n}\n\n// Transport returns the currently-configured *DTLSTransport or nil\n// if one has not yet been configured\nfunc (r *RTPSender) Transport() *DTLSTransport {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\treturn r.transport\n}\n\n// GetParameters describes the current configuration for the encoding and\n// transmission of media on the sender's track.\nfunc (r *RTPSender) GetParameters() RTPSendParameters {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tvar encodings []RTPEncodingParameters\n\tfor _, trackEncoding := range r.trackEncodings {\n\t\tvar rid string\n\t\tif trackEncoding.track != nil {\n\t\t\trid = trackEncoding.track.RID()\n\t\t}\n\t\tencodings = append(encodings, RTPEncodingParameters{\n\t\t\tRTPCodingParameters: RTPCodingParameters{\n\t\t\t\tRID:         rid,\n\t\t\t\tSSRC:        trackEncoding.ssrc,\n\t\t\t\tRTX:         RTPRtxParameters{SSRC: trackEncoding.ssrcRTX},\n\t\t\t\tFEC:         RTPFecParameters{SSRC: trackEncoding.ssrcFEC},\n\t\t\t\tPayloadType: r.payloadType,\n\t\t\t},\n\t\t})\n\t}\n\tsendParameters := RTPSendParameters{\n\t\tRTPParameters: r.api.mediaEngine.getRTPParametersByKind(\n\t\t\tr.kind,\n\t\t\t[]RTPTransceiverDirection{RTPTransceiverDirectionSendonly},\n\t\t),\n\t\tEncodings: encodings,\n\t}\n\tif r.rtpTransceiver != nil {\n\t\tsendParameters.Codecs = r.rtpTransceiver.getCodecs()\n\t} else {\n\t\tsendParameters.Codecs = r.api.mediaEngine.getCodecsByKind(r.kind)\n\t}\n\treturn sendParameters\n}\n\n// AddEncoding adds an encoding to RTPSender. Used by simulcast senders.\nfunc (r *RTPSender) AddEncoding(track TrackLocal) error {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif track == nil {\n\t\treturn errRTPSenderTrackNil\n\t}\n\n\tif track.RID() == \"\" {\n\t\treturn errRTPSenderRidNil\n\t}\n\n\tif r.hasStopped() {\n\t\treturn errRTPSenderStopped\n\t}\n\n\tif r.hasSent() {\n\t\treturn errRTPSenderSendAlreadyCalled\n\t}\n\n\tvar refTrack TrackLocal\n\tif len(r.trackEncodings) != 0 {\n\t\trefTrack = r.trackEncodings[0].track\n\t}\n\tif refTrack == nil || refTrack.RID() == \"\" {\n\t\treturn errRTPSenderNoBaseEncoding\n\t}\n\n\tif refTrack.ID() != track.ID() || refTrack.StreamID() != track.StreamID() || refTrack.Kind() != track.Kind() {\n\t\treturn errRTPSenderBaseEncodingMismatch\n\t}\n\n\tfor _, encoding := range r.trackEncodings {\n\t\tif encoding.track == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif encoding.track.RID() == track.RID() {\n\t\t\treturn errRTPSenderRIDCollision\n\t\t}\n\t}\n\n\tr.addEncoding(track)\n\treturn nil\n}\n\nfunc (r *RTPSender) addEncoding(track TrackLocal) {\n\ttrackEncoding := &trackEncoding{\n\t\ttrack: track,\n\t\tssrc:  SSRC(util.RandUint32()),\n\t}\n\n\tif r.api.mediaEngine.isRTXEnabled(r.kind, []RTPTransceiverDirection{RTPTransceiverDirectionSendonly}) {\n\t\ttrackEncoding.ssrcRTX = SSRC(util.RandUint32())\n\t}\n\n\tif r.api.mediaEngine.isFECEnabled(r.kind, []RTPTransceiverDirection{RTPTransceiverDirectionSendonly}) {\n\t\ttrackEncoding.ssrcFEC = SSRC(util.RandUint32())\n\t}\n\n\tr.trackEncodings = append(r.trackEncodings, trackEncoding)\n}\n\n// Track returns the RTCRtpTransceiver track, or nil\nfunc (r *RTPSender) Track() TrackLocal {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tif len(r.trackEncodings) == 0 {\n\t\treturn nil\n\t}\n\n\treturn r.trackEncodings[0].track\n}\n\n// ReplaceTrack replaces the track currently being used as the sender's source with a new TrackLocal.\n// The new track must be of the same media kind (audio, video, etc) and switching the track should not\n// require negotiation.\nfunc (r *RTPSender) ReplaceTrack(track TrackLocal) error {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tif track != nil && r.kind != track.Kind() {\n\t\treturn ErrRTPSenderNewTrackHasIncorrectKind\n\t}\n\n\t// cannot replace simulcast envelope\n\tif track != nil && len(r.trackEncodings) > 1 {\n\t\treturn ErrRTPSenderNewTrackHasIncorrectEnvelope\n\t}\n\n\tvar replacedTrack TrackLocal\n\tvar context *baseTrackLocalContext\n\tfor _, e := range r.trackEncodings {\n\t\treplacedTrack = e.track\n\t\tcontext = e.context\n\n\t\tif r.hasSent() && replacedTrack != nil {\n\t\t\tif err := replacedTrack.Unbind(context); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif !r.hasSent() || track == nil {\n\t\t\te.track = track\n\t\t}\n\t}\n\n\tif !r.hasSent() || track == nil {\n\t\treturn nil\n\t}\n\n\t// If we reach this point in the routine, there is only 1 track encoding\n\tcodec, err := track.Bind(&baseTrackLocalContext{\n\t\tid:              context.ID(),\n\t\tparams:          r.api.mediaEngine.getRTPParametersByKind(track.Kind(), []RTPTransceiverDirection{RTPTransceiverDirectionSendonly}),\n\t\tssrc:            context.SSRC(),\n\t\tssrcRTX:         context.SSRCRetransmission(),\n\t\tssrcFEC:         context.SSRCForwardErrorCorrection(),\n\t\twriteStream:     context.WriteStream(),\n\t\trtcpInterceptor: context.RTCPReader(),\n\t})\n\tif err != nil {\n\t\t// Re-bind the original track\n\t\tif _, reBindErr := replacedTrack.Bind(context); reBindErr != nil {\n\t\t\treturn reBindErr\n\t\t}\n\n\t\treturn err\n\t}\n\n\t// Codec has changed\n\tif r.payloadType != codec.PayloadType {\n\t\tcontext.params.Codecs = []RTPCodecParameters{codec}\n\t}\n\n\tr.trackEncodings[0].track = track\n\n\treturn nil\n}\n\n// Send Attempts to set the parameters controlling the sending of media.\nfunc (r *RTPSender) Send(parameters RTPSendParameters) error {\n\tr.mu.Lock()\n\tdefer r.mu.Unlock()\n\n\tswitch {\n\tcase r.hasSent():\n\t\treturn errRTPSenderSendAlreadyCalled\n\tcase r.trackEncodings[0].track == nil:\n\t\treturn errRTPSenderTrackRemoved\n\t}\n\n\tfor idx := range r.trackEncodings {\n\t\ttrackEncoding := r.trackEncodings[idx]\n\t\tsrtpStream := &srtpWriterFuture{ssrc: parameters.Encodings[idx].SSRC, rtpSender: r}\n\t\twriteStream := &interceptorToTrackLocalWriter{}\n\t\trtpParameters := r.api.mediaEngine.getRTPParametersByKind(trackEncoding.track.Kind(), []RTPTransceiverDirection{RTPTransceiverDirectionSendonly})\n\n\t\ttrackEncoding.srtpStream = srtpStream\n\t\ttrackEncoding.ssrc = parameters.Encodings[idx].SSRC\n\t\ttrackEncoding.ssrcRTX = parameters.Encodings[idx].RTX.SSRC\n\t\ttrackEncoding.ssrcFEC = parameters.Encodings[idx].FEC.SSRC\n\t\ttrackEncoding.rtcpInterceptor = r.api.interceptor.BindRTCPReader(\n\t\t\tinterceptor.RTCPReaderFunc(func(in []byte, a interceptor.Attributes) (n int, attributes interceptor.Attributes, err error) {\n\t\t\t\tn, err = trackEncoding.srtpStream.Read(in)\n\t\t\t\treturn n, a, err\n\t\t\t}),\n\t\t)\n\t\ttrackEncoding.context = &baseTrackLocalContext{\n\t\t\tid:              r.id,\n\t\t\tparams:          rtpParameters,\n\t\t\tssrc:            parameters.Encodings[idx].SSRC,\n\t\t\tssrcFEC:         parameters.Encodings[idx].FEC.SSRC,\n\t\t\tssrcRTX:         parameters.Encodings[idx].RTX.SSRC,\n\t\t\twriteStream:     writeStream,\n\t\t\trtcpInterceptor: trackEncoding.rtcpInterceptor,\n\t\t}\n\n\t\tcodec, err := trackEncoding.track.Bind(trackEncoding.context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttrackEncoding.context.params.Codecs = []RTPCodecParameters{codec}\n\n\t\ttrackEncoding.streamInfo = *createStreamInfo(\n\t\t\tr.id,\n\t\t\tparameters.Encodings[idx].SSRC,\n\t\t\tparameters.Encodings[idx].RTX.SSRC,\n\t\t\tparameters.Encodings[idx].FEC.SSRC,\n\t\t\tcodec.PayloadType,\n\t\t\tfindRTXPayloadType(codec.PayloadType, rtpParameters.Codecs),\n\t\t\t0,\n\t\t\tcodec.RTPCodecCapability,\n\t\t\tparameters.HeaderExtensions,\n\t\t)\n\n\t\trtpInterceptor := r.api.interceptor.BindLocalStream(\n\t\t\t&trackEncoding.streamInfo,\n\t\t\tinterceptor.RTPWriterFunc(func(header *rtp.Header, payload []byte, _ interceptor.Attributes) (int, error) {\n\t\t\t\treturn srtpStream.WriteRTP(header, payload)\n\t\t\t}),\n\t\t)\n\n\t\twriteStream.interceptor.Store(rtpInterceptor)\n\t}\n\n\tclose(r.sendCalled)\n\treturn nil\n}\n\n// Stop irreversibly stops the RTPSender\nfunc (r *RTPSender) Stop() error {\n\tr.mu.Lock()\n\n\tif stopped := r.hasStopped(); stopped {\n\t\tr.mu.Unlock()\n\t\treturn nil\n\t}\n\n\tclose(r.stopCalled)\n\tr.mu.Unlock()\n\n\tif !r.hasSent() {\n\t\treturn nil\n\t}\n\n\tif err := r.ReplaceTrack(nil); err != nil {\n\t\treturn err\n\t}\n\n\terrs := []error{}\n\tfor _, trackEncoding := range r.trackEncodings {\n\t\tr.api.interceptor.UnbindLocalStream(&trackEncoding.streamInfo)\n\t\tif trackEncoding.srtpStream != nil {\n\t\t\terrs = append(errs, trackEncoding.srtpStream.Close())\n\t\t}\n\t}\n\n\treturn util.FlattenErrs(errs)\n}\n\n// Read reads incoming RTCP for this RTPSender\nfunc (r *RTPSender) Read(b []byte) (n int, a interceptor.Attributes, err error) {\n\tselect {\n\tcase <-r.sendCalled:\n\t\treturn r.trackEncodings[0].rtcpInterceptor.Read(b, a)\n\tcase <-r.stopCalled:\n\t\treturn 0, nil, io.ErrClosedPipe\n\t}\n}\n\n// ReadRTCP is a convenience method that wraps Read and unmarshals for you.\nfunc (r *RTPSender) ReadRTCP() ([]rtcp.Packet, interceptor.Attributes, error) {\n\tb := make([]byte, r.api.settingEngine.getReceiveMTU())\n\ti, attributes, err := r.Read(b)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpkts, err := rtcp.Unmarshal(b[:i])\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn pkts, attributes, nil\n}\n\n// ReadSimulcast reads incoming RTCP for this RTPSender for given rid\nfunc (r *RTPSender) ReadSimulcast(b []byte, rid string) (n int, a interceptor.Attributes, err error) {\n\tselect {\n\tcase <-r.sendCalled:\n\t\tfor _, t := range r.trackEncodings {\n\t\t\tif t.track != nil && t.track.RID() == rid {\n\t\t\t\treturn t.rtcpInterceptor.Read(b, a)\n\t\t\t}\n\t\t}\n\t\treturn 0, nil, fmt.Errorf(\"%w: %s\", errRTPSenderNoTrackForRID, rid)\n\tcase <-r.stopCalled:\n\t\treturn 0, nil, io.ErrClosedPipe\n\t}\n}\n\n// ReadSimulcastRTCP is a convenience method that wraps ReadSimulcast and unmarshal for you\nfunc (r *RTPSender) ReadSimulcastRTCP(rid string) ([]rtcp.Packet, interceptor.Attributes, error) {\n\tb := make([]byte, r.api.settingEngine.getReceiveMTU())\n\ti, attributes, err := r.ReadSimulcast(b, rid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpkts, err := rtcp.Unmarshal(b[:i])\n\treturn pkts, attributes, err\n}\n\n// SetReadDeadline sets the deadline for the Read operation.\n// Setting to zero means no deadline.\nfunc (r *RTPSender) SetReadDeadline(t time.Time) error {\n\treturn r.trackEncodings[0].srtpStream.SetReadDeadline(t)\n}\n\n// SetReadDeadlineSimulcast sets the max amount of time the RTCP stream for a given rid will block before returning. 0 is forever.\nfunc (r *RTPSender) SetReadDeadlineSimulcast(deadline time.Time, rid string) error {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tfor _, t := range r.trackEncodings {\n\t\tif t.track != nil && t.track.RID() == rid {\n\t\t\treturn t.srtpStream.SetReadDeadline(deadline)\n\t\t}\n\t}\n\treturn fmt.Errorf(\"%w: %s\", errRTPSenderNoTrackForRID, rid)\n}\n\n// hasSent tells if data has been ever sent for this instance\nfunc (r *RTPSender) hasSent() bool {\n\tselect {\n\tcase <-r.sendCalled:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// hasStopped tells if stop has been called\nfunc (r *RTPSender) hasStopped() bool {\n\tselect {\n\tcase <-r.stopCalled:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Set a SSRC for FEC and RTX if MediaEngine has them enabled\n// If the remote doesn't support FEC or RTX we disable locally\nfunc (r *RTPSender) configureRTXAndFEC() {\n\tr.mu.RLock()\n\tdefer r.mu.RUnlock()\n\n\tfor _, trackEncoding := range r.trackEncodings {\n\t\tif !r.api.mediaEngine.isRTXEnabled(r.kind, []RTPTransceiverDirection{RTPTransceiverDirectionSendonly}) {\n\t\t\ttrackEncoding.ssrcRTX = SSRC(0)\n\t\t}\n\n\t\tif !r.api.mediaEngine.isFECEnabled(r.kind, []RTPTransceiverDirection{RTPTransceiverDirectionSendonly}) {\n\t\t\ttrackEncoding.ssrcFEC = SSRC(0)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "rtpsender_js.go",
          "type": "blob",
          "size": 0.3876953125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport \"syscall/js\"\n\n// RTPSender allows an application to control how a given Track is encoded and transmitted to a remote peer\ntype RTPSender struct {\n\t// Pointer to the underlying JavaScript RTCRTPSender object.\n\tunderlying js.Value\n}\n"
        },
        {
          "name": "rtpsender_test.go",
          "type": "blob",
          "size": 15.291015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_RTPSender_ReplaceTrack(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ts := SettingEngine{}\n\ts.DisableSRTPReplayProtection(true)\n\n\tsender, receiver, err := NewAPI(WithSettingEngine(s)).newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrackA, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\ttrackB, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeH264}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\trtpSender, err := sender.AddTrack(trackA)\n\tassert.NoError(t, err)\n\n\tseenPacketA, seenPacketACancel := context.WithCancel(context.Background())\n\tseenPacketB, seenPacketBCancel := context.WithCancel(context.Background())\n\n\tvar onTrackCount uint64\n\treceiver.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tassert.Equal(t, uint64(1), atomic.AddUint64(&onTrackCount, 1))\n\n\t\tfor {\n\t\t\tpkt, _, err := track.ReadRTP()\n\t\t\tif err != nil {\n\t\t\t\tassert.True(t, errors.Is(err, io.EOF))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase pkt.Payload[len(pkt.Payload)-1] == 0xAA:\n\t\t\t\tassert.Equal(t, track.Codec().MimeType, MimeTypeVP8)\n\t\t\t\tseenPacketACancel()\n\t\t\tcase pkt.Payload[len(pkt.Payload)-1] == 0xBB:\n\t\t\t\tassert.Equal(t, track.Codec().MimeType, MimeTypeH264)\n\t\t\t\tseenPacketBCancel()\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unexpected RTP Data % 02x\", pkt.Payload[len(pkt.Payload)-1])\n\t\t\t}\n\t\t}\n\t})\n\n\tassert.NoError(t, signalPair(sender, receiver))\n\n\t// Block Until packet with 0xAA has been seen\n\tfunc() {\n\t\tfor range time.Tick(time.Millisecond * 20) {\n\t\t\tselect {\n\t\t\tcase <-seenPacketA.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tassert.NoError(t, trackA.WriteSample(media.Sample{Data: []byte{0xAA}, Duration: time.Second}))\n\t\t\t}\n\t\t}\n\t}()\n\n\tassert.NoError(t, rtpSender.ReplaceTrack(trackB))\n\n\t// Block Until packet with 0xBB has been seen\n\tfunc() {\n\t\tfor range time.Tick(time.Millisecond * 20) {\n\t\t\tselect {\n\t\t\tcase <-seenPacketB.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tassert.NoError(t, trackB.WriteSample(media.Sample{Data: []byte{0xBB}, Duration: time.Second}))\n\t\t\t}\n\t\t}\n\t}()\n\n\tclosePairNow(t, sender, receiver)\n}\n\nfunc Test_RTPSender_GetParameters(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tofferer, answerer, err := newPair()\n\tassert.NoError(t, err)\n\n\trtpTransceiver, err := offerer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\tparameters := rtpTransceiver.Sender().GetParameters()\n\tassert.NotEqual(t, 0, len(parameters.Codecs))\n\tassert.Equal(t, 1, len(parameters.Encodings))\n\tassert.Equal(t, rtpTransceiver.Sender().trackEncodings[0].ssrc, parameters.Encodings[0].SSRC)\n\tassert.Equal(t, \"\", parameters.Encodings[0].RID)\n\n\tclosePairNow(t, offerer, answerer)\n}\n\nfunc Test_RTPSender_GetParameters_WithRID(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tofferer, answerer, err := newPair()\n\tassert.NoError(t, err)\n\n\trtpTransceiver, err := offerer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"moo\"))\n\tassert.NoError(t, err)\n\n\terr = rtpTransceiver.setSendingTrack(track)\n\tassert.NoError(t, err)\n\n\tparameters := rtpTransceiver.Sender().GetParameters()\n\tassert.Equal(t, track.RID(), parameters.Encodings[0].RID)\n\n\tclosePairNow(t, offerer, answerer)\n}\n\nfunc Test_RTPSender_SetReadDeadline(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tsender, receiver, wan := createVNetPair(t, &interceptor.Registry{})\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\trtpSender, err := sender.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tpeerConnectionsConnected := untilConnectionState(PeerConnectionStateConnected, sender, receiver)\n\n\tassert.NoError(t, signalPair(sender, receiver))\n\n\tpeerConnectionsConnected.Wait()\n\n\tassert.NoError(t, rtpSender.SetReadDeadline(time.Now().Add(1*time.Second)))\n\t_, _, err = rtpSender.ReadRTCP()\n\tassert.Error(t, err)\n\n\tassert.NoError(t, wan.Stop())\n\tclosePairNow(t, sender, receiver)\n}\n\nfunc Test_RTPSender_ReplaceTrack_InvalidTrackKindChange(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tsender, receiver, err := newPair()\n\tassert.NoError(t, err)\n\n\ttrackA, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\ttrackB, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"audio\", \"pion\")\n\tassert.NoError(t, err)\n\n\trtpSender, err := sender.AddTrack(trackA)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(sender, receiver))\n\n\tseenPacket, seenPacketCancel := context.WithCancel(context.Background())\n\treceiver.OnTrack(func(_ *TrackRemote, _ *RTPReceiver) {\n\t\tseenPacketCancel()\n\t})\n\n\tfunc() {\n\t\tfor range time.Tick(time.Millisecond * 20) {\n\t\t\tselect {\n\t\t\tcase <-seenPacket.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tassert.NoError(t, trackA.WriteSample(media.Sample{Data: []byte{0xAA}, Duration: time.Second}))\n\t\t\t}\n\t\t}\n\t}()\n\n\tassert.True(t, errors.Is(rtpSender.ReplaceTrack(trackB), ErrRTPSenderNewTrackHasIncorrectKind))\n\n\tclosePairNow(t, sender, receiver)\n}\n\nfunc Test_RTPSender_ReplaceTrack_InvalidCodecChange(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 10)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tsender, receiver, err := newPair()\n\tassert.NoError(t, err)\n\n\ttrackA, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\ttrackB, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP9}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\trtpSender, err := sender.AddTrack(trackA)\n\tassert.NoError(t, err)\n\n\terr = rtpSender.rtpTransceiver.SetCodecPreferences([]RTPCodecParameters{{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeVP8},\n\t\tPayloadType:        96,\n\t}})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(sender, receiver))\n\n\tseenPacket, seenPacketCancel := context.WithCancel(context.Background())\n\treceiver.OnTrack(func(_ *TrackRemote, _ *RTPReceiver) {\n\t\tseenPacketCancel()\n\t})\n\n\tfunc() {\n\t\tfor range time.Tick(time.Millisecond * 20) {\n\t\t\tselect {\n\t\t\tcase <-seenPacket.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tassert.NoError(t, trackA.WriteSample(media.Sample{Data: []byte{0xAA}, Duration: time.Second}))\n\t\t\t}\n\t\t}\n\t}()\n\n\tassert.True(t, errors.Is(rtpSender.ReplaceTrack(trackB), ErrUnsupportedCodec))\n\n\tclosePairNow(t, sender, receiver)\n}\n\nfunc Test_RTPSender_GetParameters_NilTrack(t *testing.T) {\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\trtpSender, err := peerConnection.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, rtpSender.ReplaceTrack(nil))\n\trtpSender.GetParameters()\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\nfunc Test_RTPSender_Send(t *testing.T) {\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\trtpSender, err := peerConnection.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tparameter := rtpSender.GetParameters()\n\terr = rtpSender.Send(parameter)\n\t<-rtpSender.sendCalled\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\nfunc Test_RTPSender_Send_Called_Once(t *testing.T) {\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\trtpSender, err := peerConnection.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tparameter := rtpSender.GetParameters()\n\terr = rtpSender.Send(parameter)\n\t<-rtpSender.sendCalled\n\tassert.NoError(t, err)\n\n\terr = rtpSender.Send(parameter)\n\tassert.Equal(t, errRTPSenderSendAlreadyCalled, err)\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\nfunc Test_RTPSender_Send_Track_Removed(t *testing.T) {\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\trtpSender, err := peerConnection.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tparameter := rtpSender.GetParameters()\n\tassert.NoError(t, peerConnection.RemoveTrack(rtpSender))\n\tassert.Equal(t, errRTPSenderTrackRemoved, rtpSender.Send(parameter))\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\nfunc Test_RTPSender_Add_Encoding(t *testing.T) {\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\trtpSender, err := peerConnection.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, errRTPSenderTrackNil, rtpSender.AddEncoding(nil))\n\n\ttrack1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, errRTPSenderRidNil, rtpSender.AddEncoding(track1))\n\n\ttrack1, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"h\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, errRTPSenderNoBaseEncoding, rtpSender.AddEncoding(track1))\n\n\ttrack, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"q\"))\n\tassert.NoError(t, err)\n\n\trtpSender, err = peerConnection.AddTrack(track)\n\tassert.NoError(t, err)\n\n\ttrack1, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video1\", \"pion\", WithRTPStreamID(\"h\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, errRTPSenderBaseEncodingMismatch, rtpSender.AddEncoding(track1))\n\n\ttrack1, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion1\", WithRTPStreamID(\"h\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, errRTPSenderBaseEncodingMismatch, rtpSender.AddEncoding(track1))\n\n\ttrack1, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"video\", \"pion\", WithRTPStreamID(\"h\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, errRTPSenderBaseEncodingMismatch, rtpSender.AddEncoding(track1))\n\n\ttrack1, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"q\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, errRTPSenderRIDCollision, rtpSender.AddEncoding(track1))\n\n\ttrack1, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"h\"))\n\tassert.NoError(t, err)\n\tassert.NoError(t, rtpSender.AddEncoding(track1))\n\n\terr = rtpSender.Send(rtpSender.GetParameters())\n\tassert.NoError(t, err)\n\n\ttrack1, err = NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\", WithRTPStreamID(\"f\"))\n\tassert.NoError(t, err)\n\tassert.Equal(t, errRTPSenderSendAlreadyCalled, rtpSender.AddEncoding(track1))\n\n\terr = rtpSender.Stop()\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, errRTPSenderStopped, rtpSender.AddEncoding(track1))\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\n// nolint: dupl\nfunc Test_RTPSender_FEC_Support(t *testing.T) {\n\tt.Run(\"FEC disabled by default\", func(t *testing.T) {\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\t\tassert.NoError(t, err)\n\n\t\tpeerConnection, err := NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\trtpSender, err := peerConnection.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\tassert.Zero(t, rtpSender.GetParameters().Encodings[0].FEC.SSRC)\n\t\tassert.NoError(t, peerConnection.Close())\n\t})\n\n\tt.Run(\"FEC can be enabled\", func(t *testing.T) {\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        94,\n\t\t}, RTPCodecTypeVideo))\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeFlexFEC, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        95,\n\t\t}, RTPCodecTypeVideo))\n\n\t\tapi := NewAPI(WithMediaEngine(&m))\n\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\t\tassert.NoError(t, err)\n\n\t\tpeerConnection, err := api.NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\trtpSender, err := peerConnection.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NotZero(t, rtpSender.GetParameters().Encodings[0].FEC.SSRC)\n\t\tassert.NoError(t, peerConnection.Close())\n\t})\n}\n\n// nolint: dupl\nfunc Test_RTPSender_RTX_Support(t *testing.T) {\n\tt.Run(\"RTX SSRC by Default\", func(t *testing.T) {\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\t\tassert.NoError(t, err)\n\n\t\tpeerConnection, err := NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\trtpSender, err := peerConnection.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NotZero(t, rtpSender.GetParameters().Encodings[0].RTX.SSRC)\n\t\tassert.NoError(t, peerConnection.Close())\n\t})\n\n\tt.Run(\"RTX can be disabled\", func(t *testing.T) {\n\t\tm := MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        94,\n\t\t}, RTPCodecTypeVideo))\n\t\tapi := NewAPI(WithMediaEngine(&m))\n\n\t\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\t\tassert.NoError(t, err)\n\n\t\tpeerConnection, err := api.NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\trtpSender, err := peerConnection.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\tassert.Zero(t, rtpSender.GetParameters().Encodings[0].RTX.SSRC)\n\n\t\tassert.NoError(t, peerConnection.Close())\n\t})\n}\n\nfunc Test_RTPSender_RTCPReader_Bind_Not_Nil(t *testing.T) {\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tpeerConnection, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tbindCalled := make(chan struct{})\n\trtpSender, err := peerConnection.AddTrack(&TrackLocalCheckRTCPReaderOnBind{\n\t\tt:                      t,\n\t\tTrackLocalStaticSample: track,\n\t\tbindCalled:             bindCalled,\n\t})\n\tassert.NoError(t, err)\n\n\tparameter := rtpSender.GetParameters()\n\terr = rtpSender.Send(parameter)\n\t<-rtpSender.sendCalled\n\t<-bindCalled\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, peerConnection.Close())\n}\n\ntype TrackLocalCheckRTCPReaderOnBind struct {\n\t*TrackLocalStaticSample\n\tt          *testing.T\n\tbindCalled chan struct{}\n}\n\nfunc (s *TrackLocalCheckRTCPReaderOnBind) Bind(ctx TrackLocalContext) (RTPCodecParameters, error) {\n\tassert.NotNil(s.t, ctx.RTCPReader())\n\tp, err := s.TrackLocalStaticSample.Bind(ctx)\n\tclose(s.bindCalled)\n\treturn p, err\n}\n"
        },
        {
          "name": "rtpsendparameters.go",
          "type": "blob",
          "size": 0.2666015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPSendParameters contains the RTP stack settings used by receivers\ntype RTPSendParameters struct {\n\tRTPParameters\n\tEncodings []RTPEncodingParameters\n}\n"
        },
        {
          "name": "rtptransceiver.go",
          "type": "blob",
          "size": 8.4111328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\n\t\"github.com/pion/rtp\"\n)\n\n// RTPTransceiver represents a combination of an RTPSender and an RTPReceiver that share a common mid.\ntype RTPTransceiver struct {\n\tmid              atomic.Value // string\n\tsender           atomic.Value // *RTPSender\n\treceiver         atomic.Value // *RTPReceiver\n\tdirection        atomic.Value // RTPTransceiverDirection\n\tcurrentDirection atomic.Value // RTPTransceiverDirection\n\n\tcodecs []RTPCodecParameters // User provided codecs via SetCodecPreferences\n\n\tkind RTPCodecType\n\n\tapi *API\n\tmu  sync.RWMutex\n}\n\nfunc newRTPTransceiver(\n\treceiver *RTPReceiver,\n\tsender *RTPSender,\n\tdirection RTPTransceiverDirection,\n\tkind RTPCodecType,\n\tapi *API,\n) *RTPTransceiver {\n\tt := &RTPTransceiver{kind: kind, api: api}\n\tt.setReceiver(receiver)\n\tt.setSender(sender)\n\tt.setDirection(direction)\n\tt.setCurrentDirection(RTPTransceiverDirectionUnknown)\n\treturn t\n}\n\n// SetCodecPreferences sets preferred list of supported codecs\n// if codecs is empty or nil we reset to default from MediaEngine\nfunc (t *RTPTransceiver) SetCodecPreferences(codecs []RTPCodecParameters) error {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\n\tfor _, codec := range codecs {\n\t\tif _, matchType := codecParametersFuzzySearch(codec, t.api.mediaEngine.getCodecsByKind(t.kind)); matchType == codecMatchNone {\n\t\t\treturn fmt.Errorf(\"%w %s\", errRTPTransceiverCodecUnsupported, codec.MimeType)\n\t\t}\n\t}\n\n\tt.codecs = codecs\n\treturn nil\n}\n\n// Codecs returns list of supported codecs\nfunc (t *RTPTransceiver) getCodecs() []RTPCodecParameters {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\n\tmediaEngineCodecs := t.api.mediaEngine.getCodecsByKind(t.kind)\n\tif len(t.codecs) == 0 {\n\t\treturn mediaEngineCodecs\n\t}\n\n\tfilteredCodecs := []RTPCodecParameters{}\n\tfor _, codec := range t.codecs {\n\t\tif c, matchType := codecParametersFuzzySearch(codec, mediaEngineCodecs); matchType != codecMatchNone {\n\t\t\tif codec.PayloadType == 0 {\n\t\t\t\tcodec.PayloadType = c.PayloadType\n\t\t\t}\n\t\t\tcodec.RTCPFeedback = rtcpFeedbackIntersection(codec.RTCPFeedback, c.RTCPFeedback)\n\t\t\tfilteredCodecs = append(filteredCodecs, codec)\n\t\t}\n\t}\n\n\treturn filteredCodecs\n}\n\n// Sender returns the RTPTransceiver's RTPSender if it has one\nfunc (t *RTPTransceiver) Sender() *RTPSender {\n\tif v, ok := t.sender.Load().(*RTPSender); ok {\n\t\treturn v\n\t}\n\n\treturn nil\n}\n\n// SetSender sets the RTPSender and Track to current transceiver\nfunc (t *RTPTransceiver) SetSender(s *RTPSender, track TrackLocal) error {\n\tt.setSender(s)\n\treturn t.setSendingTrack(track)\n}\n\nfunc (t *RTPTransceiver) setSender(s *RTPSender) {\n\tif s != nil {\n\t\ts.setRTPTransceiver(t)\n\t}\n\n\tif prevSender := t.Sender(); prevSender != nil {\n\t\tprevSender.setRTPTransceiver(nil)\n\t}\n\n\tt.sender.Store(s)\n}\n\n// Receiver returns the RTPTransceiver's RTPReceiver if it has one\nfunc (t *RTPTransceiver) Receiver() *RTPReceiver {\n\tif v, ok := t.receiver.Load().(*RTPReceiver); ok {\n\t\treturn v\n\t}\n\n\treturn nil\n}\n\n// SetMid sets the RTPTransceiver's mid. If it was already set, will return an error.\nfunc (t *RTPTransceiver) SetMid(mid string) error {\n\tif currentMid := t.Mid(); currentMid != \"\" {\n\t\treturn fmt.Errorf(\"%w: %s to %s\", errRTPTransceiverCannotChangeMid, currentMid, mid)\n\t}\n\tt.mid.Store(mid)\n\treturn nil\n}\n\n// Mid gets the Transceiver's mid value. When not already set, this value will be set in CreateOffer or CreateAnswer.\nfunc (t *RTPTransceiver) Mid() string {\n\tif v, ok := t.mid.Load().(string); ok {\n\t\treturn v\n\t}\n\treturn \"\"\n}\n\n// Kind returns RTPTransceiver's kind.\nfunc (t *RTPTransceiver) Kind() RTPCodecType {\n\treturn t.kind\n}\n\n// Direction returns the RTPTransceiver's current direction\nfunc (t *RTPTransceiver) Direction() RTPTransceiverDirection {\n\tif direction, ok := t.direction.Load().(RTPTransceiverDirection); ok {\n\t\treturn direction\n\t}\n\treturn RTPTransceiverDirection(0)\n}\n\n// Stop irreversibly stops the RTPTransceiver\nfunc (t *RTPTransceiver) Stop() error {\n\tif sender := t.Sender(); sender != nil {\n\t\tif err := sender.Stop(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif receiver := t.Receiver(); receiver != nil {\n\t\tif err := receiver.Stop(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tt.setDirection(RTPTransceiverDirectionInactive)\n\tt.setCurrentDirection(RTPTransceiverDirectionInactive)\n\treturn nil\n}\n\nfunc (t *RTPTransceiver) setReceiver(r *RTPReceiver) {\n\tif r != nil {\n\t\tr.setRTPTransceiver(t)\n\t}\n\n\tif prevReceiver := t.Receiver(); prevReceiver != nil {\n\t\tprevReceiver.setRTPTransceiver(nil)\n\t}\n\n\tt.receiver.Store(r)\n}\n\nfunc (t *RTPTransceiver) setDirection(d RTPTransceiverDirection) {\n\tt.direction.Store(d)\n}\n\nfunc (t *RTPTransceiver) setCurrentDirection(d RTPTransceiverDirection) {\n\tt.currentDirection.Store(d)\n}\n\nfunc (t *RTPTransceiver) getCurrentDirection() RTPTransceiverDirection {\n\tif v, ok := t.currentDirection.Load().(RTPTransceiverDirection); ok {\n\t\treturn v\n\t}\n\treturn RTPTransceiverDirectionUnknown\n}\n\nfunc (t *RTPTransceiver) setSendingTrack(track TrackLocal) error {\n\tif err := t.Sender().ReplaceTrack(track); err != nil {\n\t\treturn err\n\t}\n\tif track == nil {\n\t\tt.setSender(nil)\n\t}\n\n\tswitch {\n\tcase track != nil && t.Direction() == RTPTransceiverDirectionRecvonly:\n\t\tt.setDirection(RTPTransceiverDirectionSendrecv)\n\tcase track != nil && t.Direction() == RTPTransceiverDirectionInactive:\n\t\tt.setDirection(RTPTransceiverDirectionSendonly)\n\tcase track == nil && t.Direction() == RTPTransceiverDirectionSendrecv:\n\t\tt.setDirection(RTPTransceiverDirectionRecvonly)\n\tcase track != nil && t.Direction() == RTPTransceiverDirectionSendonly:\n\t\t// Handle the case where a sendonly transceiver was added by a negotiation\n\t\t// initiated by remote peer. For example a remote peer added a transceiver\n\t\t// with direction recvonly.\n\tcase track != nil && t.Direction() == RTPTransceiverDirectionSendrecv:\n\t\t// Similar to above, but for sendrecv transceiver.\n\tcase track == nil && t.Direction() == RTPTransceiverDirectionSendonly:\n\t\tt.setDirection(RTPTransceiverDirectionInactive)\n\tdefault:\n\t\treturn errRTPTransceiverSetSendingInvalidState\n\t}\n\treturn nil\n}\n\nfunc findByMid(mid string, localTransceivers []*RTPTransceiver) (*RTPTransceiver, []*RTPTransceiver) {\n\tfor i, t := range localTransceivers {\n\t\tif t.Mid() == mid {\n\t\t\treturn t, append(localTransceivers[:i], localTransceivers[i+1:]...)\n\t\t}\n\t}\n\n\treturn nil, localTransceivers\n}\n\n// Given a direction+type pluck a transceiver from the passed list\n// if no entry satisfies the requested type+direction return a inactive Transceiver\nfunc satisfyTypeAndDirection(remoteKind RTPCodecType, remoteDirection RTPTransceiverDirection, localTransceivers []*RTPTransceiver) (*RTPTransceiver, []*RTPTransceiver) {\n\t// Get direction order from most preferred to least\n\tgetPreferredDirections := func() []RTPTransceiverDirection {\n\t\tswitch remoteDirection {\n\t\tcase RTPTransceiverDirectionSendrecv:\n\t\t\treturn []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly, RTPTransceiverDirectionSendrecv, RTPTransceiverDirectionSendonly}\n\t\tcase RTPTransceiverDirectionSendonly:\n\t\t\treturn []RTPTransceiverDirection{RTPTransceiverDirectionRecvonly, RTPTransceiverDirectionSendrecv}\n\t\tcase RTPTransceiverDirectionRecvonly:\n\t\t\treturn []RTPTransceiverDirection{RTPTransceiverDirectionSendonly, RTPTransceiverDirectionSendrecv}\n\t\tdefault:\n\t\t\treturn []RTPTransceiverDirection{}\n\t\t}\n\t}\n\n\tfor _, possibleDirection := range getPreferredDirections() {\n\t\tfor i := range localTransceivers {\n\t\t\tt := localTransceivers[i]\n\t\t\tif t.Mid() == \"\" && t.kind == remoteKind && possibleDirection == t.Direction() {\n\t\t\t\treturn t, append(localTransceivers[:i], localTransceivers[i+1:]...)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, localTransceivers\n}\n\n// handleUnknownRTPPacket consumes a single RTP Packet and returns information that is helpful\n// for demuxing and handling an unknown SSRC (usually for Simulcast)\nfunc handleUnknownRTPPacket(buf []byte, midExtensionID, streamIDExtensionID, repairStreamIDExtensionID uint8, mid, rid, rsid *string) (payloadType PayloadType, paddingOnly bool, err error) {\n\trp := &rtp.Packet{}\n\tif err = rp.Unmarshal(buf); err != nil {\n\t\treturn\n\t}\n\n\tif rp.Padding && len(rp.Payload) == 0 {\n\t\tpaddingOnly = true\n\t}\n\n\tif !rp.Header.Extension {\n\t\treturn\n\t}\n\n\tpayloadType = PayloadType(rp.PayloadType)\n\tif payload := rp.GetExtension(midExtensionID); payload != nil {\n\t\t*mid = string(payload)\n\t}\n\n\tif payload := rp.GetExtension(streamIDExtensionID); payload != nil {\n\t\t*rid = string(payload)\n\t}\n\n\tif payload := rp.GetExtension(repairStreamIDExtensionID); payload != nil {\n\t\t*rsid = string(payload)\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "rtptransceiver_js.go",
          "type": "blob",
          "size": 1.076171875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport (\n\t\"syscall/js\"\n)\n\n// RTPTransceiver represents a combination of an RTPSender and an RTPReceiver that share a common mid.\ntype RTPTransceiver struct {\n\t// Pointer to the underlying JavaScript RTCRTPTransceiver object.\n\tunderlying js.Value\n}\n\n// Direction returns the RTPTransceiver's current direction\nfunc (r *RTPTransceiver) Direction() RTPTransceiverDirection {\n\treturn NewRTPTransceiverDirection(r.underlying.Get(\"direction\").String())\n}\n\n// Sender returns the RTPTransceiver's RTPSender if it has one\nfunc (r *RTPTransceiver) Sender() *RTPSender {\n\tunderlying := r.underlying.Get(\"sender\")\n\tif underlying.IsNull() {\n\t\treturn nil\n\t}\n\n\treturn &RTPSender{underlying: underlying}\n}\n\n// Receiver returns the RTPTransceiver's RTPReceiver if it has one\nfunc (r *RTPTransceiver) Receiver() *RTPReceiver {\n\tunderlying := r.underlying.Get(\"receiver\")\n\tif underlying.IsNull() {\n\t\treturn nil\n\t}\n\n\treturn &RTPReceiver{underlying: underlying}\n}\n"
        },
        {
          "name": "rtptransceiver_test.go",
          "type": "blob",
          "size": 3.6728515625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_RTPTransceiver_SetCodecPreferences(t *testing.T) {\n\tme := &MediaEngine{}\n\tapi := NewAPI(WithMediaEngine(me))\n\tassert.NoError(t, me.RegisterDefaultCodecs())\n\n\tme.pushCodecs(me.videoCodecs, RTPCodecTypeVideo)\n\tme.pushCodecs(me.audioCodecs, RTPCodecTypeAudio)\n\n\ttr := RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}\n\tassert.EqualValues(t, me.videoCodecs, tr.getCodecs())\n\n\tfailTestCases := [][]RTPCodecParameters{\n\t\t{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 2, \"minptime=10;useinbandfec=1\", nil},\n\t\t\t\tPayloadType:        111,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\t\tPayloadType:        96,\n\t\t\t},\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 2, \"minptime=10;useinbandfec=1\", nil},\n\t\t\t\tPayloadType:        111,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, testCase := range failTestCases {\n\t\tassert.ErrorIs(t, tr.SetCodecPreferences(testCase), errRTPTransceiverCodecUnsupported)\n\t}\n\n\tsuccessTestCases := [][]RTPCodecParameters{\n\t\t{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\t\tPayloadType:        96,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\t\tPayloadType:        96,\n\t\t\t},\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=96\", nil},\n\t\t\t\tPayloadType:        97,\n\t\t\t},\n\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP9, 90000, 0, \"profile-id=0\", nil},\n\t\t\t\tPayloadType:        98,\n\t\t\t},\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeRTX, 90000, 0, \"apt=98\", nil},\n\t\t\t\tPayloadType:        99,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, testCase := range successTestCases {\n\t\tassert.NoError(t, tr.SetCodecPreferences(testCase))\n\t}\n\n\tassert.NoError(t, tr.SetCodecPreferences(nil))\n\tassert.NotEqual(t, 0, len(tr.getCodecs()))\n\n\tassert.NoError(t, tr.SetCodecPreferences([]RTPCodecParameters{}))\n\tassert.NotEqual(t, 0, len(tr.getCodecs()))\n}\n\n// Assert that SetCodecPreferences properly filters codecs and PayloadTypes are respected\nfunc Test_RTPTransceiver_SetCodecPreferences_PayloadType(t *testing.T) {\n\ttestCodec := RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{\"video/testCodec\", 90000, 0, \"\", nil},\n\t\tPayloadType:        50,\n\t}\n\n\tm := &MediaEngine{}\n\tassert.NoError(t, m.RegisterDefaultCodecs())\n\n\tofferPC, err := NewAPI(WithMediaEngine(m)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, m.RegisterCodec(testCodec, RTPCodecTypeVideo))\n\n\tanswerPC, err := NewAPI(WithMediaEngine(m)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\t_, err = offerPC.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tanswerTransceiver, err := answerPC.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, answerTransceiver.SetCodecPreferences([]RTPCodecParameters{\n\t\ttestCodec,\n\t\t{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\tPayloadType:        51,\n\t\t},\n\t}))\n\n\toffer, err := offerPC.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, offerPC.SetLocalDescription(offer))\n\tassert.NoError(t, answerPC.SetRemoteDescription(offer))\n\n\tanswer, err := answerPC.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\t// VP8 with proper PayloadType\n\tassert.NotEqual(t, -1, strings.Index(answer.SDP, \"a=rtpmap:51 VP8/90000\"))\n\n\t// testCodec is ignored since offerer doesn't support\n\tassert.Equal(t, -1, strings.Index(answer.SDP, \"testCodec\"))\n\n\tclosePairNow(t, offerPC, answerPC)\n}\n"
        },
        {
          "name": "rtptransceiverdirection.go",
          "type": "blob",
          "size": 2.74609375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPTransceiverDirection indicates the direction of the RTPTransceiver.\ntype RTPTransceiverDirection int\n\nconst (\n\t// RTPTransceiverDirectionUnknown is the enum's zero-value\n\tRTPTransceiverDirectionUnknown RTPTransceiverDirection = iota\n\n\t// RTPTransceiverDirectionSendrecv indicates the RTPSender will offer\n\t// to send RTP and the RTPReceiver will offer to receive RTP.\n\tRTPTransceiverDirectionSendrecv\n\n\t// RTPTransceiverDirectionSendonly indicates the RTPSender will offer\n\t// to send RTP.\n\tRTPTransceiverDirectionSendonly\n\n\t// RTPTransceiverDirectionRecvonly indicates the RTPReceiver will\n\t// offer to receive RTP.\n\tRTPTransceiverDirectionRecvonly\n\n\t// RTPTransceiverDirectionInactive indicates the RTPSender won't offer\n\t// to send RTP and the RTPReceiver won't offer to receive RTP.\n\tRTPTransceiverDirectionInactive\n)\n\n// This is done this way because of a linter.\nconst (\n\trtpTransceiverDirectionSendrecvStr = \"sendrecv\"\n\trtpTransceiverDirectionSendonlyStr = \"sendonly\"\n\trtpTransceiverDirectionRecvonlyStr = \"recvonly\"\n\trtpTransceiverDirectionInactiveStr = \"inactive\"\n)\n\n// NewRTPTransceiverDirection defines a procedure for creating a new\n// RTPTransceiverDirection from a raw string naming the transceiver direction.\nfunc NewRTPTransceiverDirection(raw string) RTPTransceiverDirection {\n\tswitch raw {\n\tcase rtpTransceiverDirectionSendrecvStr:\n\t\treturn RTPTransceiverDirectionSendrecv\n\tcase rtpTransceiverDirectionSendonlyStr:\n\t\treturn RTPTransceiverDirectionSendonly\n\tcase rtpTransceiverDirectionRecvonlyStr:\n\t\treturn RTPTransceiverDirectionRecvonly\n\tcase rtpTransceiverDirectionInactiveStr:\n\t\treturn RTPTransceiverDirectionInactive\n\tdefault:\n\t\treturn RTPTransceiverDirectionUnknown\n\t}\n}\n\nfunc (t RTPTransceiverDirection) String() string {\n\tswitch t {\n\tcase RTPTransceiverDirectionSendrecv:\n\t\treturn rtpTransceiverDirectionSendrecvStr\n\tcase RTPTransceiverDirectionSendonly:\n\t\treturn rtpTransceiverDirectionSendonlyStr\n\tcase RTPTransceiverDirectionRecvonly:\n\t\treturn rtpTransceiverDirectionRecvonlyStr\n\tcase RTPTransceiverDirectionInactive:\n\t\treturn rtpTransceiverDirectionInactiveStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// Revers indicate the opposite direction\nfunc (t RTPTransceiverDirection) Revers() RTPTransceiverDirection {\n\tswitch t {\n\tcase RTPTransceiverDirectionSendonly:\n\t\treturn RTPTransceiverDirectionRecvonly\n\tcase RTPTransceiverDirectionRecvonly:\n\t\treturn RTPTransceiverDirectionSendonly\n\tdefault:\n\t\treturn t\n\t}\n}\n\nfunc haveRTPTransceiverDirectionIntersection(haystack []RTPTransceiverDirection, needle []RTPTransceiverDirection) bool {\n\tfor _, n := range needle {\n\t\tfor _, h := range haystack {\n\t\t\tif n == h {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "rtptransceiverdirection_test.go",
          "type": "blob",
          "size": 1.3193359375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewRTPTransceiverDirection(t *testing.T) {\n\ttestCases := []struct {\n\t\tdirectionString   string\n\t\texpectedDirection RTPTransceiverDirection\n\t}{\n\t\t{ErrUnknownType.Error(), RTPTransceiverDirectionUnknown},\n\t\t{\"sendrecv\", RTPTransceiverDirectionSendrecv},\n\t\t{\"sendonly\", RTPTransceiverDirectionSendonly},\n\t\t{\"recvonly\", RTPTransceiverDirectionRecvonly},\n\t\t{\"inactive\", RTPTransceiverDirectionInactive},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\tNewRTPTransceiverDirection(testCase.directionString),\n\t\t\ttestCase.expectedDirection,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestRTPTransceiverDirection_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tdirection      RTPTransceiverDirection\n\t\texpectedString string\n\t}{\n\t\t{RTPTransceiverDirectionUnknown, ErrUnknownType.Error()},\n\t\t{RTPTransceiverDirectionSendrecv, \"sendrecv\"},\n\t\t{RTPTransceiverDirectionSendonly, \"sendonly\"},\n\t\t{RTPTransceiverDirectionRecvonly, \"recvonly\"},\n\t\t{RTPTransceiverDirectionInactive, \"inactive\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.direction.String(),\n\t\t\ttestCase.expectedString,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "rtptransceiverinit.go",
          "type": "blob",
          "size": 0.3974609375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// RTPTransceiverInit dictionary is used when calling the WebRTC function addTransceiver() to provide configuration options for the new transceiver.\ntype RTPTransceiverInit struct {\n\tDirection     RTPTransceiverDirection\n\tSendEncodings []RTPEncodingParameters\n\t// Streams       []*Track\n}\n"
        },
        {
          "name": "rtptransceiverinit_go_test.go",
          "type": "blob",
          "size": 1.974609375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_RTPTransceiverInit_SSRC(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30) //nolint\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"a\", \"b\")\n\tassert.NoError(t, err)\n\n\tt.Run(\"SSRC of 0 is ignored\", func(t *testing.T) {\n\t\tofferer, answerer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tanswerer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\t\tassert.NotEqual(t, 0, track.SSRC())\n\t\t\tcancel()\n\t\t})\n\n\t\t_, err = offerer.AddTransceiverFromTrack(track, RTPTransceiverInit{\n\t\t\tDirection: RTPTransceiverDirectionSendonly,\n\t\t\tSendEncodings: []RTPEncodingParameters{\n\t\t\t\t{\n\t\t\t\t\tRTPCodingParameters: RTPCodingParameters{\n\t\t\t\t\t\tSSRC: 0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tassert.NoError(t, signalPair(offerer, answerer))\n\t\tsendVideoUntilDone(ctx.Done(), t, []*TrackLocalStaticSample{track})\n\t\tclosePairNow(t, offerer, answerer)\n\t})\n\n\tt.Run(\"SSRC of 5000\", func(t *testing.T) {\n\t\tofferer, answerer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tanswerer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\t\tassert.NotEqual(t, 5000, track.SSRC())\n\t\t\tcancel()\n\t\t})\n\n\t\t_, err = offerer.AddTransceiverFromTrack(track, RTPTransceiverInit{\n\t\t\tDirection: RTPTransceiverDirectionSendonly,\n\t\t\tSendEncodings: []RTPEncodingParameters{\n\t\t\t\t{\n\t\t\t\t\tRTPCodingParameters: RTPCodingParameters{\n\t\t\t\t\t\tSSRC: 5000,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t\tassert.NoError(t, signalPair(offerer, answerer))\n\t\tsendVideoUntilDone(ctx.Done(), t, []*TrackLocalStaticSample{track})\n\t\tclosePairNow(t, offerer, answerer)\n\t})\n}\n"
        },
        {
          "name": "sctpcapabilities.go",
          "type": "blob",
          "size": 0.2607421875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// SCTPCapabilities indicates the capabilities of the SCTPTransport.\ntype SCTPCapabilities struct {\n\tMaxMessageSize uint32 `json:\"maxMessageSize\"`\n}\n"
        },
        {
          "name": "sctptransport.go",
          "type": "blob",
          "size": 10.9130859375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"math\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pion/datachannel\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/sctp\"\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\nconst sctpMaxChannels = uint16(65535)\n\n// SCTPTransport provides details about the SCTP transport.\ntype SCTPTransport struct {\n\tlock sync.RWMutex\n\n\tdtlsTransport *DTLSTransport\n\n\t// State represents the current state of the SCTP transport.\n\tstate SCTPTransportState\n\n\t// SCTPTransportState doesn't have an enum to distinguish between New/Connecting\n\t// so we need a dedicated field\n\tisStarted bool\n\n\t// MaxMessageSize represents the maximum size of data that can be passed to\n\t// DataChannel's send() method.\n\tmaxMessageSize float64\n\n\t// MaxChannels represents the maximum amount of DataChannel's that can\n\t// be used simultaneously.\n\tmaxChannels *uint16\n\n\t// OnStateChange  func()\n\n\tonErrorHandler func(error)\n\tonCloseHandler func(error)\n\n\tsctpAssociation            *sctp.Association\n\tonDataChannelHandler       func(*DataChannel)\n\tonDataChannelOpenedHandler func(*DataChannel)\n\n\t// DataChannels\n\tdataChannels          []*DataChannel\n\tdataChannelIDsUsed    map[uint16]struct{}\n\tdataChannelsOpened    uint32\n\tdataChannelsRequested uint32\n\tdataChannelsAccepted  uint32\n\n\tapi *API\n\tlog logging.LeveledLogger\n}\n\n// NewSCTPTransport creates a new SCTPTransport.\n// This constructor is part of the ORTC API. It is not\n// meant to be used together with the basic WebRTC API.\nfunc (api *API) NewSCTPTransport(dtls *DTLSTransport) *SCTPTransport {\n\tres := &SCTPTransport{\n\t\tdtlsTransport:      dtls,\n\t\tstate:              SCTPTransportStateConnecting,\n\t\tapi:                api,\n\t\tlog:                api.settingEngine.LoggerFactory.NewLogger(\"ortc\"),\n\t\tdataChannelIDsUsed: make(map[uint16]struct{}),\n\t}\n\n\tres.updateMessageSize()\n\tres.updateMaxChannels()\n\n\treturn res\n}\n\n// Transport returns the DTLSTransport instance the SCTPTransport is sending over.\nfunc (r *SCTPTransport) Transport() *DTLSTransport {\n\tr.lock.RLock()\n\tdefer r.lock.RUnlock()\n\n\treturn r.dtlsTransport\n}\n\n// GetCapabilities returns the SCTPCapabilities of the SCTPTransport.\nfunc (r *SCTPTransport) GetCapabilities() SCTPCapabilities {\n\treturn SCTPCapabilities{\n\t\tMaxMessageSize: 0,\n\t}\n}\n\n// Start the SCTPTransport. Since both local and remote parties must mutually\n// create an SCTPTransport, SCTP SO (Simultaneous Open) is used to establish\n// a connection over SCTP.\nfunc (r *SCTPTransport) Start(_ SCTPCapabilities) error {\n\tif r.isStarted {\n\t\treturn nil\n\t}\n\tr.isStarted = true\n\n\tdtlsTransport := r.Transport()\n\tif dtlsTransport == nil || dtlsTransport.conn == nil {\n\t\treturn errSCTPTransportDTLS\n\t}\n\tsctpAssociation, err := sctp.Client(sctp.Config{\n\t\tNetConn:              dtlsTransport.conn,\n\t\tMaxReceiveBufferSize: r.api.settingEngine.sctp.maxReceiveBufferSize,\n\t\tEnableZeroChecksum:   r.api.settingEngine.sctp.enableZeroChecksum,\n\t\tLoggerFactory:        r.api.settingEngine.LoggerFactory,\n\t\tRTOMax:               float64(r.api.settingEngine.sctp.rtoMax) / float64(time.Millisecond),\n\t\tBlockWrite:           r.api.settingEngine.detach.DataChannels && r.api.settingEngine.dataChannelBlockWrite,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tr.lock.Lock()\n\tr.sctpAssociation = sctpAssociation\n\tr.state = SCTPTransportStateConnected\n\tdataChannels := append([]*DataChannel{}, r.dataChannels...)\n\tr.lock.Unlock()\n\n\tvar openedDCCount uint32\n\tfor _, d := range dataChannels {\n\t\tif d.ReadyState() == DataChannelStateConnecting {\n\t\t\terr := d.open(r)\n\t\t\tif err != nil {\n\t\t\t\tr.log.Warnf(\"failed to open data channel: %s\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\topenedDCCount++\n\t\t}\n\t}\n\n\tr.lock.Lock()\n\tr.dataChannelsOpened += openedDCCount\n\tr.lock.Unlock()\n\n\tgo r.acceptDataChannels(sctpAssociation, dataChannels)\n\n\treturn nil\n}\n\n// Stop stops the SCTPTransport\nfunc (r *SCTPTransport) Stop() error {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\tif r.sctpAssociation == nil {\n\t\treturn nil\n\t}\n\n\tr.sctpAssociation.Abort(\"\")\n\n\tr.sctpAssociation = nil\n\tr.state = SCTPTransportStateClosed\n\n\treturn nil\n}\n\nfunc (r *SCTPTransport) acceptDataChannels(a *sctp.Association, existingDataChannels []*DataChannel) {\n\tdataChannels := make([]*datachannel.DataChannel, 0, len(existingDataChannels))\n\tfor _, dc := range existingDataChannels {\n\t\tdc.mu.Lock()\n\t\tisNil := dc.dataChannel == nil\n\t\tdc.mu.Unlock()\n\t\tif isNil {\n\t\t\tcontinue\n\t\t}\n\t\tdataChannels = append(dataChannels, dc.dataChannel)\n\t}\nACCEPT:\n\tfor {\n\t\tdc, err := datachannel.Accept(a, &datachannel.Config{\n\t\t\tLoggerFactory: r.api.settingEngine.LoggerFactory,\n\t\t}, dataChannels...)\n\t\tif err != nil {\n\t\t\tif !errors.Is(err, io.EOF) {\n\t\t\t\tr.log.Errorf(\"Failed to accept data channel: %v\", err)\n\t\t\t\tr.onError(err)\n\t\t\t\tr.onClose(err)\n\t\t\t} else {\n\t\t\t\tr.onClose(nil)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tfor _, ch := range dataChannels {\n\t\t\tif ch.StreamIdentifier() == dc.StreamIdentifier() {\n\t\t\t\tcontinue ACCEPT\n\t\t\t}\n\t\t}\n\n\t\tvar (\n\t\t\tmaxRetransmits    *uint16\n\t\t\tmaxPacketLifeTime *uint16\n\t\t)\n\t\tval := uint16(dc.Config.ReliabilityParameter)\n\t\tordered := true\n\n\t\tswitch dc.Config.ChannelType {\n\t\tcase datachannel.ChannelTypeReliable:\n\t\t\tordered = true\n\t\tcase datachannel.ChannelTypeReliableUnordered:\n\t\t\tordered = false\n\t\tcase datachannel.ChannelTypePartialReliableRexmit:\n\t\t\tordered = true\n\t\t\tmaxRetransmits = &val\n\t\tcase datachannel.ChannelTypePartialReliableRexmitUnordered:\n\t\t\tordered = false\n\t\t\tmaxRetransmits = &val\n\t\tcase datachannel.ChannelTypePartialReliableTimed:\n\t\t\tordered = true\n\t\t\tmaxPacketLifeTime = &val\n\t\tcase datachannel.ChannelTypePartialReliableTimedUnordered:\n\t\t\tordered = false\n\t\t\tmaxPacketLifeTime = &val\n\t\tdefault:\n\t\t}\n\n\t\tsid := dc.StreamIdentifier()\n\t\trtcDC, err := r.api.newDataChannel(&DataChannelParameters{\n\t\t\tID:                &sid,\n\t\t\tLabel:             dc.Config.Label,\n\t\t\tProtocol:          dc.Config.Protocol,\n\t\t\tNegotiated:        dc.Config.Negotiated,\n\t\t\tOrdered:           ordered,\n\t\t\tMaxPacketLifeTime: maxPacketLifeTime,\n\t\t\tMaxRetransmits:    maxRetransmits,\n\t\t}, r, r.api.settingEngine.LoggerFactory.NewLogger(\"ortc\"))\n\t\tif err != nil {\n\t\t\t// This data channel is invalid. Close it and log an error.\n\t\t\tif err1 := dc.Close(); err1 != nil {\n\t\t\t\tr.log.Errorf(\"Failed to close invalid data channel: %v\", err1)\n\t\t\t}\n\t\t\tr.log.Errorf(\"Failed to accept data channel: %v\", err)\n\t\t\tr.onError(err)\n\t\t\t// We've received a datachannel with invalid configuration. We can still receive other datachannels.\n\t\t\tcontinue ACCEPT\n\t\t}\n\n\t\t<-r.onDataChannel(rtcDC)\n\t\trtcDC.handleOpen(dc, true, dc.Config.Negotiated)\n\n\t\tr.lock.Lock()\n\t\tr.dataChannelsOpened++\n\t\thandler := r.onDataChannelOpenedHandler\n\t\tr.lock.Unlock()\n\n\t\tif handler != nil {\n\t\t\thandler(rtcDC)\n\t\t}\n\t}\n}\n\n// OnError sets an event handler which is invoked when the SCTP Association errors.\nfunc (r *SCTPTransport) OnError(f func(err error)) {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\tr.onErrorHandler = f\n}\n\nfunc (r *SCTPTransport) onError(err error) {\n\tr.lock.RLock()\n\thandler := r.onErrorHandler\n\tr.lock.RUnlock()\n\n\tif handler != nil {\n\t\tgo handler(err)\n\t}\n}\n\n// OnClose sets an event handler which is invoked when the SCTP Association closes.\nfunc (r *SCTPTransport) OnClose(f func(err error)) {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\tr.onCloseHandler = f\n}\n\nfunc (r *SCTPTransport) onClose(err error) {\n\tr.lock.RLock()\n\thandler := r.onCloseHandler\n\tr.lock.RUnlock()\n\n\tif handler != nil {\n\t\tgo handler(err)\n\t}\n}\n\n// OnDataChannel sets an event handler which is invoked when a data\n// channel message arrives from a remote peer.\nfunc (r *SCTPTransport) OnDataChannel(f func(*DataChannel)) {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\tr.onDataChannelHandler = f\n}\n\n// OnDataChannelOpened sets an event handler which is invoked when a data\n// channel is opened\nfunc (r *SCTPTransport) OnDataChannelOpened(f func(*DataChannel)) {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\tr.onDataChannelOpenedHandler = f\n}\n\nfunc (r *SCTPTransport) onDataChannel(dc *DataChannel) (done chan struct{}) {\n\tr.lock.Lock()\n\tr.dataChannels = append(r.dataChannels, dc)\n\tr.dataChannelsAccepted++\n\tif dc.ID() != nil {\n\t\tr.dataChannelIDsUsed[*dc.ID()] = struct{}{}\n\t} else {\n\t\t// This cannot happen, the constructor for this datachannel in the caller\n\t\t// takes a pointer to the id.\n\t\tr.log.Errorf(\"accepted data channel with no ID\")\n\t}\n\thandler := r.onDataChannelHandler\n\tr.lock.Unlock()\n\n\tdone = make(chan struct{})\n\tif handler == nil || dc == nil {\n\t\tclose(done)\n\t\treturn\n\t}\n\n\t// Run this synchronously to allow setup done in onDataChannelFn()\n\t// to complete before datachannel event handlers might be called.\n\tgo func() {\n\t\thandler(dc)\n\t\tclose(done)\n\t}()\n\n\treturn\n}\n\nfunc (r *SCTPTransport) updateMessageSize() {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\n\tvar remoteMaxMessageSize float64 = 65536 // pion/webrtc#758\n\tvar canSendSize float64 = 65536          // pion/webrtc#758\n\n\tr.maxMessageSize = r.calcMessageSize(remoteMaxMessageSize, canSendSize)\n}\n\nfunc (r *SCTPTransport) calcMessageSize(remoteMaxMessageSize, canSendSize float64) float64 {\n\tswitch {\n\tcase remoteMaxMessageSize == 0 &&\n\t\tcanSendSize == 0:\n\t\treturn math.Inf(1)\n\n\tcase remoteMaxMessageSize == 0:\n\t\treturn canSendSize\n\n\tcase canSendSize == 0:\n\t\treturn remoteMaxMessageSize\n\n\tcase canSendSize > remoteMaxMessageSize:\n\t\treturn remoteMaxMessageSize\n\n\tdefault:\n\t\treturn canSendSize\n\t}\n}\n\nfunc (r *SCTPTransport) updateMaxChannels() {\n\tval := sctpMaxChannels\n\tr.maxChannels = &val\n}\n\n// MaxChannels is the maximum number of RTCDataChannels that can be open simultaneously.\nfunc (r *SCTPTransport) MaxChannels() uint16 {\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\n\tif r.maxChannels == nil {\n\t\treturn sctpMaxChannels\n\t}\n\n\treturn *r.maxChannels\n}\n\n// State returns the current state of the SCTPTransport\nfunc (r *SCTPTransport) State() SCTPTransportState {\n\tr.lock.RLock()\n\tdefer r.lock.RUnlock()\n\treturn r.state\n}\n\nfunc (r *SCTPTransport) collectStats(collector *statsReportCollector) {\n\tcollector.Collecting()\n\n\tstats := SCTPTransportStats{\n\t\tTimestamp: statsTimestampFrom(time.Now()),\n\t\tType:      StatsTypeSCTPTransport,\n\t\tID:        \"sctpTransport\",\n\t}\n\n\tassociation := r.association()\n\tif association != nil {\n\t\tstats.BytesSent = association.BytesSent()\n\t\tstats.BytesReceived = association.BytesReceived()\n\t\tstats.SmoothedRoundTripTime = association.SRTT() * 0.001 // convert milliseconds to seconds\n\t\tstats.CongestionWindow = association.CWND()\n\t\tstats.ReceiverWindow = association.RWND()\n\t\tstats.MTU = association.MTU()\n\t}\n\n\tcollector.Collect(stats.ID, stats)\n}\n\nfunc (r *SCTPTransport) generateAndSetDataChannelID(dtlsRole DTLSRole, idOut **uint16) error {\n\tvar id uint16\n\tif dtlsRole != DTLSRoleClient {\n\t\tid++\n\t}\n\n\tmaxVal := r.MaxChannels()\n\n\tr.lock.Lock()\n\tdefer r.lock.Unlock()\n\n\tfor ; id < maxVal-1; id += 2 {\n\t\tif _, ok := r.dataChannelIDsUsed[id]; ok {\n\t\t\tcontinue\n\t\t}\n\t\t*idOut = &id\n\t\tr.dataChannelIDsUsed[id] = struct{}{}\n\t\treturn nil\n\t}\n\n\treturn &rtcerr.OperationError{Err: ErrMaxDataChannelID}\n}\n\nfunc (r *SCTPTransport) association() *sctp.Association {\n\tif r == nil {\n\t\treturn nil\n\t}\n\tr.lock.RLock()\n\tassociation := r.sctpAssociation\n\tr.lock.RUnlock()\n\treturn association\n}\n"
        },
        {
          "name": "sctptransport_js.go",
          "type": "blob",
          "size": 0.646484375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\nimport \"syscall/js\"\n\n// SCTPTransport provides details about the SCTP transport.\ntype SCTPTransport struct {\n\t// Pointer to the underlying JavaScript SCTPTransport object.\n\tunderlying js.Value\n}\n\n// Transport returns the DTLSTransport instance the SCTPTransport is sending over.\nfunc (r *SCTPTransport) Transport() *DTLSTransport {\n\tunderlying := r.underlying.Get(\"transport\")\n\tif underlying.IsNull() || underlying.IsUndefined() {\n\t\treturn nil\n\t}\n\n\treturn &DTLSTransport{\n\t\tunderlying: underlying,\n\t}\n}\n"
        },
        {
          "name": "sctptransport_test.go",
          "type": "blob",
          "size": 5.9443359375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"bytes\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGenerateDataChannelID(t *testing.T) {\n\tsctpTransportWithChannels := func(ids []uint16) *SCTPTransport {\n\t\tret := &SCTPTransport{\n\t\t\tdataChannels:       []*DataChannel{},\n\t\t\tdataChannelIDsUsed: make(map[uint16]struct{}),\n\t\t}\n\n\t\tfor i := range ids {\n\t\t\tid := ids[i]\n\t\t\tret.dataChannels = append(ret.dataChannels, &DataChannel{id: &id})\n\t\t\tret.dataChannelIDsUsed[id] = struct{}{}\n\t\t}\n\n\t\treturn ret\n\t}\n\n\ttestCases := []struct {\n\t\trole   DTLSRole\n\t\ts      *SCTPTransport\n\t\tresult uint16\n\t}{\n\t\t{DTLSRoleClient, sctpTransportWithChannels([]uint16{}), 0},\n\t\t{DTLSRoleClient, sctpTransportWithChannels([]uint16{1}), 0},\n\t\t{DTLSRoleClient, sctpTransportWithChannels([]uint16{0}), 2},\n\t\t{DTLSRoleClient, sctpTransportWithChannels([]uint16{0, 2}), 4},\n\t\t{DTLSRoleClient, sctpTransportWithChannels([]uint16{0, 4}), 2},\n\t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{}), 1},\n\t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{0}), 1},\n\t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{1}), 3},\n\t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{1, 3}), 5},\n\t\t{DTLSRoleServer, sctpTransportWithChannels([]uint16{1, 5}), 3},\n\t}\n\tfor _, testCase := range testCases {\n\t\tidPtr := new(uint16)\n\t\terr := testCase.s.generateAndSetDataChannelID(testCase.role, &idPtr)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to generate id: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tif *idPtr != testCase.result {\n\t\t\tt.Errorf(\"Wrong id: %d expected %d\", *idPtr, testCase.result)\n\t\t}\n\t\tif _, ok := testCase.s.dataChannelIDsUsed[*idPtr]; !ok {\n\t\t\tt.Errorf(\"expected new id to be added to the map: %d\", *idPtr)\n\t\t}\n\t}\n}\n\nfunc TestSCTPTransportOnClose(t *testing.T) {\n\tofferPC, answerPC, err := newPair()\n\trequire.NoError(t, err)\n\n\tdefer closePairNow(t, offerPC, answerPC)\n\n\tanswerPC.OnDataChannel(func(dc *DataChannel) {\n\t\tdc.OnMessage(func(_ DataChannelMessage) {\n\t\t\tif err1 := dc.Send([]byte(\"hello\")); err1 != nil {\n\t\t\t\tt.Error(\"failed to send message\")\n\t\t\t}\n\t\t})\n\t})\n\n\trecvMsg := make(chan struct{}, 1)\n\tofferPC.OnConnectionStateChange(func(state PeerConnectionState) {\n\t\tif state == PeerConnectionStateConnected {\n\t\t\tdefer func() {\n\t\t\t\tofferPC.OnConnectionStateChange(nil)\n\t\t\t}()\n\n\t\t\tdc, createErr := offerPC.CreateDataChannel(expectedLabel, nil)\n\t\t\tif createErr != nil {\n\t\t\t\tt.Errorf(\"Failed to create a PC pair for testing\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdc.OnMessage(func(msg DataChannelMessage) {\n\t\t\t\tif !bytes.Equal(msg.Data, []byte(\"hello\")) {\n\t\t\t\t\tt.Error(\"invalid msg received\")\n\t\t\t\t}\n\t\t\t\trecvMsg <- struct{}{}\n\t\t\t})\n\t\t\tdc.OnOpen(func() {\n\t\t\t\tif err1 := dc.Send([]byte(\"hello\")); err1 != nil {\n\t\t\t\t\tt.Error(\"failed to send initial msg\", err1)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\terr = signalPair(offerPC, answerPC)\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase <-recvMsg:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"timed out\")\n\t}\n\n\t// setup SCTP OnClose callback\n\tch := make(chan error, 1)\n\tanswerPC.SCTP().OnClose(func(err error) {\n\t\tch <- err\n\t})\n\n\terr = offerPC.Close() // This will trigger sctp onclose callback on remote\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase <-ch:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"timed out\")\n\t}\n}\n\nfunc TestSCTPTransportOutOfBandNegotiatedDataChannelDetach(t *testing.T) {\n\tconst N = 10\n\tdone := make(chan struct{}, N)\n\tfor i := 0; i < N; i++ {\n\t\tgo func() {\n\t\t\t// Use Detach data channels mode\n\t\t\ts := SettingEngine{}\n\t\t\ts.DetachDataChannels()\n\t\t\tapi := NewAPI(WithSettingEngine(s))\n\n\t\t\t// Set up two peer connections.\n\t\t\tconfig := Configuration{}\n\t\t\tofferPC, err := api.NewPeerConnection(config)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tanswerPC, err := api.NewPeerConnection(config)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdefer closePairNow(t, offerPC, answerPC)\n\t\t\tdefer func() { done <- struct{}{} }()\n\n\t\t\tnegotiated := true\n\t\t\tid := uint16(0)\n\t\t\treadDetach := make(chan struct{})\n\t\t\tdc1, err := offerPC.CreateDataChannel(\"\", &DataChannelInit{\n\t\t\t\tNegotiated: &negotiated,\n\t\t\t\tID:         &id,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdc1.OnOpen(func() {\n\t\t\t\t_, _ = dc1.Detach()\n\t\t\t\tclose(readDetach)\n\t\t\t})\n\n\t\t\twriteDetach := make(chan struct{})\n\t\t\tdc2, err := answerPC.CreateDataChannel(\"\", &DataChannelInit{\n\t\t\t\tNegotiated: &negotiated,\n\t\t\t\tID:         &id,\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdc2.OnOpen(func() {\n\t\t\t\t_, _ = dc2.Detach()\n\t\t\t\tclose(writeDetach)\n\t\t\t})\n\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(2)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tconnestd := make(chan struct{}, 1)\n\t\t\t\tofferPC.OnConnectionStateChange(func(state PeerConnectionState) {\n\t\t\t\t\tif state == PeerConnectionStateConnected {\n\t\t\t\t\t\tconnestd <- struct{}{}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tselect {\n\t\t\t\tcase <-connestd:\n\t\t\t\tcase <-time.After(10 * time.Second):\n\t\t\t\t\tt.Error(\"conn establishment timed out\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t<-readDetach\n\t\t\t\terr1 := dc1.dataChannel.SetReadDeadline(time.Now().Add(10 * time.Second))\n\t\t\t\tif err1 != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tbuf := make([]byte, 10)\n\t\t\t\tn, err1 := dc1.dataChannel.Read(buf)\n\t\t\t\tif err1 != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif string(buf[:n]) != \"hello\" {\n\t\t\t\t\tt.Error(\"invalid read\")\n\t\t\t\t}\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tconnestd := make(chan struct{}, 1)\n\t\t\t\tanswerPC.OnConnectionStateChange(func(state PeerConnectionState) {\n\t\t\t\t\tif state == PeerConnectionStateConnected {\n\t\t\t\t\t\tconnestd <- struct{}{}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tselect {\n\t\t\t\tcase <-connestd:\n\t\t\t\tcase <-time.After(10 * time.Second):\n\t\t\t\t\tt.Error(\"connection establishment timed out\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t<-writeDetach\n\t\t\t\tn, err1 := dc2.dataChannel.Write([]byte(\"hello\"))\n\t\t\t\tif err1 != nil || n != len(\"hello\") {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\terr = signalPair(offerPC, answerPC)\n\t\t\trequire.NoError(t, err)\n\t\t\twg.Wait()\n\t\t}()\n\t}\n\n\tfor i := 0; i < N; i++ {\n\t\tselect {\n\t\tcase <-done:\n\t\tcase <-time.After(20 * time.Second):\n\t\t\tt.Fatal(\"timed out\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "sctptransportstate.go",
          "type": "blob",
          "size": 1.806640625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\n// SCTPTransportState indicates the state of the SCTP transport.\ntype SCTPTransportState int\n\nconst (\n\t// SCTPTransportStateUnknown is the enum's zero-value\n\tSCTPTransportStateUnknown SCTPTransportState = iota\n\n\t// SCTPTransportStateConnecting indicates the SCTPTransport is in the\n\t// process of negotiating an association. This is the initial state of the\n\t// SCTPTransportState when an SCTPTransport is created.\n\tSCTPTransportStateConnecting\n\n\t// SCTPTransportStateConnected indicates the negotiation of an\n\t// association is completed.\n\tSCTPTransportStateConnected\n\n\t// SCTPTransportStateClosed indicates a SHUTDOWN or ABORT chunk is\n\t// received or when the SCTP association has been closed intentionally,\n\t// such as by closing the peer connection or applying a remote description\n\t// that rejects data or changes the SCTP port.\n\tSCTPTransportStateClosed\n)\n\n// This is done this way because of a linter.\nconst (\n\tsctpTransportStateConnectingStr = \"connecting\"\n\tsctpTransportStateConnectedStr  = \"connected\"\n\tsctpTransportStateClosedStr     = \"closed\"\n)\n\nfunc newSCTPTransportState(raw string) SCTPTransportState {\n\tswitch raw {\n\tcase sctpTransportStateConnectingStr:\n\t\treturn SCTPTransportStateConnecting\n\tcase sctpTransportStateConnectedStr:\n\t\treturn SCTPTransportStateConnected\n\tcase sctpTransportStateClosedStr:\n\t\treturn SCTPTransportStateClosed\n\tdefault:\n\t\treturn SCTPTransportStateUnknown\n\t}\n}\n\nfunc (s SCTPTransportState) String() string {\n\tswitch s {\n\tcase SCTPTransportStateConnecting:\n\t\treturn sctpTransportStateConnectingStr\n\tcase SCTPTransportStateConnected:\n\t\treturn sctpTransportStateConnectedStr\n\tcase SCTPTransportStateClosed:\n\t\treturn sctpTransportStateClosedStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n"
        },
        {
          "name": "sctptransportstate_test.go",
          "type": "blob",
          "size": 1.1884765625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewSCTPTransportState(t *testing.T) {\n\ttestCases := []struct {\n\t\ttransportStateString   string\n\t\texpectedTransportState SCTPTransportState\n\t}{\n\t\t{ErrUnknownType.Error(), SCTPTransportStateUnknown},\n\t\t{\"connecting\", SCTPTransportStateConnecting},\n\t\t{\"connected\", SCTPTransportStateConnected},\n\t\t{\"closed\", SCTPTransportStateClosed},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedTransportState,\n\t\t\tnewSCTPTransportState(testCase.transportStateString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestSCTPTransportState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\ttransportState SCTPTransportState\n\t\texpectedString string\n\t}{\n\t\t{SCTPTransportStateUnknown, ErrUnknownType.Error()},\n\t\t{SCTPTransportStateConnecting, \"connecting\"},\n\t\t{SCTPTransportStateConnected, \"connected\"},\n\t\t{SCTPTransportStateClosed, \"closed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.transportState.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "sdp.go",
          "type": "blob",
          "size": 27.646484375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/sdp/v3\"\n)\n\n// trackDetails represents any media source that can be represented in a SDP\n// This isn't keyed by SSRC because it also needs to support rid based sources\ntype trackDetails struct {\n\tmid        string\n\tkind       RTPCodecType\n\tstreamID   string\n\tid         string\n\tssrcs      []SSRC\n\trepairSsrc *SSRC\n\trids       []string\n}\n\nfunc trackDetailsForSSRC(trackDetails []trackDetails, ssrc SSRC) *trackDetails {\n\tfor i := range trackDetails {\n\t\tfor j := range trackDetails[i].ssrcs {\n\t\t\tif trackDetails[i].ssrcs[j] == ssrc {\n\t\t\t\treturn &trackDetails[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc trackDetailsForRID(trackDetails []trackDetails, mid, rid string) *trackDetails {\n\tfor i := range trackDetails {\n\t\tif trackDetails[i].mid != mid {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor j := range trackDetails[i].rids {\n\t\t\tif trackDetails[i].rids[j] == rid {\n\t\t\t\treturn &trackDetails[i]\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc filterTrackWithSSRC(incomingTracks []trackDetails, ssrc SSRC) []trackDetails {\n\tfiltered := []trackDetails{}\n\tdoesTrackHaveSSRC := func(t trackDetails) bool {\n\t\tfor i := range t.ssrcs {\n\t\t\tif t.ssrcs[i] == ssrc {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\tfor i := range incomingTracks {\n\t\tif !doesTrackHaveSSRC(incomingTracks[i]) {\n\t\t\tfiltered = append(filtered, incomingTracks[i])\n\t\t}\n\t}\n\n\treturn filtered\n}\n\n// extract all trackDetails from an SDP.\nfunc trackDetailsFromSDP(log logging.LeveledLogger, s *sdp.SessionDescription) (incomingTracks []trackDetails) { // nolint:gocognit\n\tfor _, media := range s.MediaDescriptions {\n\t\ttracksInMediaSection := []trackDetails{}\n\t\trtxRepairFlows := map[uint64]uint64{}\n\n\t\t// Plan B can have multiple tracks in a single media section\n\t\tstreamID := \"\"\n\t\ttrackID := \"\"\n\n\t\t// If media section is recvonly or inactive skip\n\t\tif _, ok := media.Attribute(sdp.AttrKeyRecvOnly); ok {\n\t\t\tcontinue\n\t\t} else if _, ok := media.Attribute(sdp.AttrKeyInactive); ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tmidValue := getMidValue(media)\n\t\tif midValue == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tcodecType := NewRTPCodecType(media.MediaName.Media)\n\t\tif codecType == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tfor _, attr := range media.Attributes {\n\t\t\tswitch attr.Key {\n\t\t\tcase sdp.AttrKeySSRCGroup:\n\t\t\t\tsplit := strings.Split(attr.Value, \" \")\n\t\t\t\tif split[0] == sdp.SemanticTokenFlowIdentification {\n\t\t\t\t\t// Add rtx ssrcs to blacklist, to avoid adding them as tracks\n\t\t\t\t\t// Essentially lines like `a=ssrc-group:FID 2231627014 632943048` are processed by this section\n\t\t\t\t\t// as this declares that the second SSRC (632943048) is a rtx repair flow (RFC4588) for the first\n\t\t\t\t\t// (2231627014) as specified in RFC5576\n\t\t\t\t\tif len(split) == 3 {\n\t\t\t\t\t\tbaseSsrc, err := strconv.ParseUint(split[1], 10, 32)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlog.Warnf(\"Failed to parse SSRC: %v\", err)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\trtxRepairFlow, err := strconv.ParseUint(split[2], 10, 32)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlog.Warnf(\"Failed to parse SSRC: %v\", err)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t\trtxRepairFlows[rtxRepairFlow] = baseSsrc\n\t\t\t\t\t\ttracksInMediaSection = filterTrackWithSSRC(tracksInMediaSection, SSRC(rtxRepairFlow)) // Remove if rtx was added as track before\n\t\t\t\t\t\tfor i := range tracksInMediaSection {\n\t\t\t\t\t\t\tif tracksInMediaSection[i].ssrcs[0] == SSRC(baseSsrc) {\n\t\t\t\t\t\t\t\trepairSsrc := SSRC(rtxRepairFlow)\n\t\t\t\t\t\t\t\ttracksInMediaSection[i].repairSsrc = &repairSsrc\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Handle `a=msid:<stream_id> <track_label>` for Unified plan. The first value is the same as MediaStream.id\n\t\t\t// in the browser and can be used to figure out which tracks belong to the same stream. The browser should\n\t\t\t// figure this out automatically when an ontrack event is emitted on RTCPeerConnection.\n\t\t\tcase sdp.AttrKeyMsid:\n\t\t\t\tsplit := strings.Split(attr.Value, \" \")\n\t\t\t\tif len(split) == 2 {\n\t\t\t\t\tstreamID = split[0]\n\t\t\t\t\ttrackID = split[1]\n\t\t\t\t}\n\n\t\t\tcase sdp.AttrKeySSRC:\n\t\t\t\tsplit := strings.Split(attr.Value, \" \")\n\t\t\t\tssrc, err := strconv.ParseUint(split[0], 10, 32)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Warnf(\"Failed to parse SSRC: %v\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif _, ok := rtxRepairFlows[ssrc]; ok {\n\t\t\t\t\tcontinue // This ssrc is a RTX repair flow, ignore\n\t\t\t\t}\n\n\t\t\t\tif len(split) == 3 && strings.HasPrefix(split[1], \"msid:\") {\n\t\t\t\t\tstreamID = split[1][len(\"msid:\"):]\n\t\t\t\t\ttrackID = split[2]\n\t\t\t\t}\n\n\t\t\t\tisNewTrack := true\n\t\t\t\ttrackDetails := &trackDetails{}\n\t\t\t\tfor i := range tracksInMediaSection {\n\t\t\t\t\tfor j := range tracksInMediaSection[i].ssrcs {\n\t\t\t\t\t\tif tracksInMediaSection[i].ssrcs[j] == SSRC(ssrc) {\n\t\t\t\t\t\t\ttrackDetails = &tracksInMediaSection[i]\n\t\t\t\t\t\t\tisNewTrack = false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttrackDetails.mid = midValue\n\t\t\t\ttrackDetails.kind = codecType\n\t\t\t\ttrackDetails.streamID = streamID\n\t\t\t\ttrackDetails.id = trackID\n\t\t\t\ttrackDetails.ssrcs = []SSRC{SSRC(ssrc)}\n\n\t\t\t\tfor r, baseSsrc := range rtxRepairFlows {\n\t\t\t\t\tif baseSsrc == ssrc {\n\t\t\t\t\t\trepairSsrc := SSRC(r)\n\t\t\t\t\t\ttrackDetails.repairSsrc = &repairSsrc\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif isNewTrack {\n\t\t\t\t\ttracksInMediaSection = append(tracksInMediaSection, *trackDetails)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif rids := getRids(media); len(rids) != 0 && trackID != \"\" && streamID != \"\" {\n\t\t\tsimulcastTrack := trackDetails{\n\t\t\t\tmid:      midValue,\n\t\t\t\tkind:     codecType,\n\t\t\t\tstreamID: streamID,\n\t\t\t\tid:       trackID,\n\t\t\t\trids:     []string{},\n\t\t\t}\n\t\t\tfor _, rid := range rids {\n\t\t\t\tsimulcastTrack.rids = append(simulcastTrack.rids, rid.id)\n\t\t\t}\n\n\t\t\ttracksInMediaSection = []trackDetails{simulcastTrack}\n\t\t}\n\n\t\tincomingTracks = append(incomingTracks, tracksInMediaSection...)\n\t}\n\n\treturn incomingTracks\n}\n\nfunc trackDetailsToRTPReceiveParameters(t *trackDetails) RTPReceiveParameters {\n\tencodingSize := len(t.ssrcs)\n\tif len(t.rids) >= encodingSize {\n\t\tencodingSize = len(t.rids)\n\t}\n\n\tencodings := make([]RTPDecodingParameters, encodingSize)\n\tfor i := range encodings {\n\t\tif len(t.rids) > i {\n\t\t\tencodings[i].RID = t.rids[i]\n\t\t}\n\t\tif len(t.ssrcs) > i {\n\t\t\tencodings[i].SSRC = t.ssrcs[i]\n\t\t}\n\n\t\tif t.repairSsrc != nil {\n\t\t\tencodings[i].RTX.SSRC = *t.repairSsrc\n\t\t}\n\t}\n\n\treturn RTPReceiveParameters{Encodings: encodings}\n}\n\nfunc getRids(media *sdp.MediaDescription) []*simulcastRid {\n\trids := []*simulcastRid{}\n\tvar simulcastAttr string\n\tfor _, attr := range media.Attributes {\n\t\tif attr.Key == sdpAttributeRid {\n\t\t\tsplit := strings.Split(attr.Value, \" \")\n\t\t\trids = append(rids, &simulcastRid{id: split[0], attrValue: attr.Value})\n\t\t} else if attr.Key == sdpAttributeSimulcast {\n\t\t\tsimulcastAttr = attr.Value\n\t\t}\n\t}\n\t// process paused stream like \"a=simulcast:send 1;~2;~3\"\n\tif simulcastAttr != \"\" {\n\t\tif space := strings.Index(simulcastAttr, \" \"); space > 0 {\n\t\t\tsimulcastAttr = simulcastAttr[space+1:]\n\t\t}\n\t\tridStates := strings.Split(simulcastAttr, \";\")\n\t\tfor _, ridState := range ridStates {\n\t\t\tif ridState[:1] == \"~\" {\n\t\t\t\tridID := ridState[1:]\n\t\t\t\tfor _, rid := range rids {\n\t\t\t\t\tif rid.id == ridID {\n\t\t\t\t\t\trid.paused = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn rids\n}\n\nfunc addCandidatesToMediaDescriptions(candidates []ICECandidate, m *sdp.MediaDescription, iceGatheringState ICEGatheringState) error {\n\tappendCandidateIfNew := func(c ice.Candidate, attributes []sdp.Attribute) {\n\t\tmarshaled := c.Marshal()\n\t\tfor _, a := range attributes {\n\t\t\tif marshaled == a.Value {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tm.WithValueAttribute(\"candidate\", marshaled)\n\t}\n\n\tfor _, c := range candidates {\n\t\tcandidate, err := c.toICE()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcandidate.SetComponent(1)\n\t\tappendCandidateIfNew(candidate, m.Attributes)\n\n\t\tcandidate.SetComponent(2)\n\t\tappendCandidateIfNew(candidate, m.Attributes)\n\t}\n\n\tif iceGatheringState != ICEGatheringStateComplete {\n\t\treturn nil\n\t}\n\tfor _, a := range m.Attributes {\n\t\tif a.Key == \"end-of-candidates\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tm.WithPropertyAttribute(\"end-of-candidates\")\n\treturn nil\n}\n\nfunc addDataMediaSection(d *sdp.SessionDescription, shouldAddCandidates bool, dtlsFingerprints []DTLSFingerprint, midValue string, iceParams ICEParameters, candidates []ICECandidate, dtlsRole sdp.ConnectionRole, iceGatheringState ICEGatheringState) error {\n\tmedia := (&sdp.MediaDescription{\n\t\tMediaName: sdp.MediaName{\n\t\t\tMedia:   mediaSectionApplication,\n\t\t\tPort:    sdp.RangedPort{Value: 9},\n\t\t\tProtos:  []string{\"UDP\", \"DTLS\", \"SCTP\"},\n\t\t\tFormats: []string{\"webrtc-datachannel\"},\n\t\t},\n\t\tConnectionInformation: &sdp.ConnectionInformation{\n\t\t\tNetworkType: \"IN\",\n\t\t\tAddressType: \"IP4\",\n\t\t\tAddress: &sdp.Address{\n\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t},\n\t\t},\n\t}).\n\t\tWithValueAttribute(sdp.AttrKeyConnectionSetup, dtlsRole.String()).\n\t\tWithValueAttribute(sdp.AttrKeyMID, midValue).\n\t\tWithPropertyAttribute(RTPTransceiverDirectionSendrecv.String()).\n\t\tWithPropertyAttribute(\"sctp-port:5000\").\n\t\tWithICECredentials(iceParams.UsernameFragment, iceParams.Password)\n\n\tfor _, f := range dtlsFingerprints {\n\t\tmedia = media.WithFingerprint(f.Algorithm, strings.ToUpper(f.Value))\n\t}\n\n\tif shouldAddCandidates {\n\t\tif err := addCandidatesToMediaDescriptions(candidates, media, iceGatheringState); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\td.WithMedia(media)\n\treturn nil\n}\n\nfunc populateLocalCandidates(sessionDescription *SessionDescription, i *ICEGatherer, iceGatheringState ICEGatheringState) *SessionDescription {\n\tif sessionDescription == nil || i == nil {\n\t\treturn sessionDescription\n\t}\n\n\tcandidates, err := i.GetLocalCandidates()\n\tif err != nil {\n\t\treturn sessionDescription\n\t}\n\n\tparsed := sessionDescription.parsed\n\tif len(parsed.MediaDescriptions) > 0 {\n\t\tm := parsed.MediaDescriptions[0]\n\t\tif err = addCandidatesToMediaDescriptions(candidates, m, iceGatheringState); err != nil {\n\t\t\treturn sessionDescription\n\t\t}\n\t}\n\n\tsdp, err := parsed.Marshal()\n\tif err != nil {\n\t\treturn sessionDescription\n\t}\n\n\treturn &SessionDescription{\n\t\tSDP:    string(sdp),\n\t\tType:   sessionDescription.Type,\n\t\tparsed: parsed,\n\t}\n}\n\n// nolint: gocognit\nfunc addSenderSDP(\n\tmediaSection mediaSection,\n\tisPlanB bool,\n\tmedia *sdp.MediaDescription,\n) {\n\tfor _, mt := range mediaSection.transceivers {\n\t\tsender := mt.Sender()\n\t\tif sender == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\ttrack := sender.Track()\n\t\tif track == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tsendParameters := sender.GetParameters()\n\t\tfor _, encoding := range sendParameters.Encodings {\n\t\t\tif encoding.RTX.SSRC != 0 {\n\t\t\t\tmedia = media.WithValueAttribute(\"ssrc-group\", fmt.Sprintf(\"FID %d %d\", encoding.SSRC, encoding.RTX.SSRC))\n\t\t\t}\n\t\t\tif encoding.FEC.SSRC != 0 {\n\t\t\t\tmedia = media.WithValueAttribute(\"ssrc-group\", fmt.Sprintf(\"FEC-FR %d %d\", encoding.SSRC, encoding.FEC.SSRC))\n\t\t\t}\n\n\t\t\tmedia = media.WithMediaSource(uint32(encoding.SSRC), track.StreamID() /* cname */, track.StreamID() /* streamLabel */, track.ID())\n\n\t\t\tif !isPlanB {\n\t\t\t\tif encoding.RTX.SSRC != 0 {\n\t\t\t\t\tmedia = media.WithMediaSource(uint32(encoding.RTX.SSRC), track.StreamID() /* cname */, track.StreamID() /* streamLabel */, track.ID())\n\t\t\t\t}\n\t\t\t\tif encoding.FEC.SSRC != 0 {\n\t\t\t\t\tmedia = media.WithMediaSource(uint32(encoding.FEC.SSRC), track.StreamID() /* cname */, track.StreamID() /* streamLabel */, track.ID())\n\t\t\t\t}\n\n\t\t\t\tmedia = media.WithPropertyAttribute(\"msid:\" + track.StreamID() + \" \" + track.ID())\n\t\t\t}\n\t\t}\n\n\t\tif len(sendParameters.Encodings) > 1 {\n\t\t\tsendRids := make([]string, 0, len(sendParameters.Encodings))\n\n\t\t\tfor _, encoding := range sendParameters.Encodings {\n\t\t\t\tmedia.WithValueAttribute(sdpAttributeRid, encoding.RID+\" send\")\n\t\t\t\tsendRids = append(sendRids, encoding.RID)\n\t\t\t}\n\t\t\t// Simulcast\n\t\t\tmedia.WithValueAttribute(sdpAttributeSimulcast, \"send \"+strings.Join(sendRids, \";\"))\n\t\t}\n\n\t\tif !isPlanB {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc addTransceiverSDP(\n\td *sdp.SessionDescription,\n\tisPlanB bool,\n\tshouldAddCandidates bool,\n\tdtlsFingerprints []DTLSFingerprint,\n\tmediaEngine *MediaEngine,\n\tmidValue string,\n\ticeParams ICEParameters,\n\tcandidates []ICECandidate,\n\tdtlsRole sdp.ConnectionRole,\n\ticeGatheringState ICEGatheringState,\n\tmediaSection mediaSection,\n) (bool, error) {\n\ttransceivers := mediaSection.transceivers\n\tif len(transceivers) < 1 {\n\t\treturn false, errSDPZeroTransceivers\n\t}\n\t// Use the first transceiver to generate the section attributes\n\tt := transceivers[0]\n\tmedia := sdp.NewJSEPMediaDescription(t.kind.String(), []string{}).\n\t\tWithValueAttribute(sdp.AttrKeyConnectionSetup, dtlsRole.String()).\n\t\tWithValueAttribute(sdp.AttrKeyMID, midValue).\n\t\tWithICECredentials(iceParams.UsernameFragment, iceParams.Password).\n\t\tWithPropertyAttribute(sdp.AttrKeyRTCPMux).\n\t\tWithPropertyAttribute(sdp.AttrKeyRTCPRsize)\n\n\tcodecs := t.getCodecs()\n\tfor _, codec := range codecs {\n\t\tname := strings.TrimPrefix(codec.MimeType, \"audio/\")\n\t\tname = strings.TrimPrefix(name, \"video/\")\n\t\tmedia.WithCodec(uint8(codec.PayloadType), name, codec.ClockRate, codec.Channels, codec.SDPFmtpLine)\n\n\t\tfor _, feedback := range codec.RTPCodecCapability.RTCPFeedback {\n\t\t\tmedia.WithValueAttribute(\"rtcp-fb\", fmt.Sprintf(\"%d %s %s\", codec.PayloadType, feedback.Type, feedback.Parameter))\n\t\t}\n\t}\n\tif len(codecs) == 0 {\n\t\t// If we are sender and we have no codecs throw an error early\n\t\tif t.Sender() != nil {\n\t\t\treturn false, ErrSenderWithNoCodecs\n\t\t}\n\n\t\t// Explicitly reject track if we don't have the codec\n\t\t// We need to include connection information even if we're rejecting a track, otherwise Firefox will fail to\n\t\t// parse the SDP with an error like:\n\t\t// SIPCC Failed to parse SDP: SDP Parse Error on line 50:  c= connection line not specified for every media level, validation failed.\n\t\t// In addition this makes our SDP compliant with RFC 4566 Section 5.7: https://datatracker.ietf.org/doc/html/rfc4566#section-5.7\n\t\td.WithMedia(&sdp.MediaDescription{\n\t\t\tMediaName: sdp.MediaName{\n\t\t\t\tMedia:   t.kind.String(),\n\t\t\t\tPort:    sdp.RangedPort{Value: 0},\n\t\t\t\tProtos:  []string{\"UDP\", \"TLS\", \"RTP\", \"SAVPF\"},\n\t\t\t\tFormats: []string{\"0\"},\n\t\t\t},\n\t\t\tConnectionInformation: &sdp.ConnectionInformation{\n\t\t\t\tNetworkType: \"IN\",\n\t\t\t\tAddressType: \"IP4\",\n\t\t\t\tAddress: &sdp.Address{\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\treturn false, nil\n\t}\n\n\tdirections := []RTPTransceiverDirection{}\n\tif t.Sender() != nil {\n\t\tdirections = append(directions, RTPTransceiverDirectionSendonly)\n\t}\n\tif t.Receiver() != nil {\n\t\tdirections = append(directions, RTPTransceiverDirectionRecvonly)\n\t}\n\n\tparameters := mediaEngine.getRTPParametersByKind(t.kind, directions)\n\tfor _, rtpExtension := range parameters.HeaderExtensions {\n\t\tif mediaSection.matchExtensions != nil {\n\t\t\tif _, enabled := mediaSection.matchExtensions[rtpExtension.URI]; !enabled {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\textURL, err := url.Parse(rtpExtension.URI)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tmedia.WithExtMap(sdp.ExtMap{Value: rtpExtension.ID, URI: extURL})\n\t}\n\n\tif len(mediaSection.rids) > 0 {\n\t\trecvRids := make([]string, 0, len(mediaSection.rids))\n\n\t\tfor _, rid := range mediaSection.rids {\n\t\t\tridID := rid.id\n\t\t\tmedia.WithValueAttribute(sdpAttributeRid, ridID+\" recv\")\n\t\t\tif rid.paused {\n\t\t\t\tridID = \"~\" + ridID\n\t\t\t}\n\t\t\trecvRids = append(recvRids, ridID)\n\t\t}\n\t\t// Simulcast\n\t\tmedia.WithValueAttribute(sdpAttributeSimulcast, \"recv \"+strings.Join(recvRids, \";\"))\n\t}\n\n\taddSenderSDP(mediaSection, isPlanB, media)\n\n\tmedia = media.WithPropertyAttribute(t.Direction().String())\n\n\tfor _, fingerprint := range dtlsFingerprints {\n\t\tmedia = media.WithFingerprint(fingerprint.Algorithm, strings.ToUpper(fingerprint.Value))\n\t}\n\n\tif shouldAddCandidates {\n\t\tif err := addCandidatesToMediaDescriptions(candidates, media, iceGatheringState); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\td.WithMedia(media)\n\n\treturn true, nil\n}\n\ntype simulcastRid struct {\n\tid        string\n\tattrValue string\n\tpaused    bool\n}\n\ntype mediaSection struct {\n\tid              string\n\ttransceivers    []*RTPTransceiver\n\tdata            bool\n\tmatchExtensions map[string]int\n\trids            []*simulcastRid\n}\n\nfunc bundleMatchFromRemote(matchBundleGroup *string) func(mid string) bool {\n\tif matchBundleGroup == nil {\n\t\treturn func(string) bool {\n\t\t\treturn true\n\t\t}\n\t}\n\tbundleTags := strings.Split(*matchBundleGroup, \" \")\n\treturn func(midValue string) bool {\n\t\tfor _, tag := range bundleTags {\n\t\t\tif tag == midValue {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n}\n\n// populateSDP serializes a PeerConnections state into an SDP\nfunc populateSDP(\n\td *sdp.SessionDescription,\n\tisPlanB bool,\n\tdtlsFingerprints []DTLSFingerprint,\n\tmediaDescriptionFingerprint bool,\n\tisICELite bool,\n\tisExtmapAllowMixed bool,\n\tmediaEngine *MediaEngine,\n\tconnectionRole sdp.ConnectionRole,\n\tcandidates []ICECandidate,\n\ticeParams ICEParameters,\n\tmediaSections []mediaSection,\n\ticeGatheringState ICEGatheringState,\n\tmatchBundleGroup *string,\n) (*sdp.SessionDescription, error) {\n\tvar err error\n\tmediaDtlsFingerprints := []DTLSFingerprint{}\n\n\tif mediaDescriptionFingerprint {\n\t\tmediaDtlsFingerprints = dtlsFingerprints\n\t}\n\n\tbundleValue := \"BUNDLE\"\n\tbundleCount := 0\n\n\tbundleMatch := bundleMatchFromRemote(matchBundleGroup)\n\tappendBundle := func(midValue string) {\n\t\tbundleValue += \" \" + midValue\n\t\tbundleCount++\n\t}\n\n\tfor i, m := range mediaSections {\n\t\tif m.data && len(m.transceivers) != 0 {\n\t\t\treturn nil, errSDPMediaSectionMediaDataChanInvalid\n\t\t} else if !isPlanB && len(m.transceivers) > 1 {\n\t\t\treturn nil, errSDPMediaSectionMultipleTrackInvalid\n\t\t}\n\n\t\tshouldAddID := true\n\t\tshouldAddCandidates := i == 0\n\t\tif m.data {\n\t\t\tif err = addDataMediaSection(d, shouldAddCandidates, mediaDtlsFingerprints, m.id, iceParams, candidates, connectionRole, iceGatheringState); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tshouldAddID, err = addTransceiverSDP(d, isPlanB, shouldAddCandidates, mediaDtlsFingerprints, mediaEngine, m.id, iceParams, candidates, connectionRole, iceGatheringState, m)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tif shouldAddID {\n\t\t\tif bundleMatch(m.id) {\n\t\t\t\tappendBundle(m.id)\n\t\t\t} else {\n\t\t\t\td.MediaDescriptions[len(d.MediaDescriptions)-1].MediaName.Port = sdp.RangedPort{Value: 0}\n\t\t\t}\n\t\t}\n\t}\n\n\tif !mediaDescriptionFingerprint {\n\t\tfor _, fingerprint := range dtlsFingerprints {\n\t\t\td.WithFingerprint(fingerprint.Algorithm, strings.ToUpper(fingerprint.Value))\n\t\t}\n\t}\n\n\tif isICELite {\n\t\t// RFC 5245 S15.3\n\t\td = d.WithValueAttribute(sdp.AttrKeyICELite, \"\")\n\t}\n\n\tif isExtmapAllowMixed {\n\t\td = d.WithPropertyAttribute(sdp.AttrKeyExtMapAllowMixed)\n\t}\n\n\tif bundleCount > 0 {\n\t\td = d.WithValueAttribute(sdp.AttrKeyGroup, bundleValue)\n\t}\n\treturn d, nil\n}\n\nfunc getMidValue(media *sdp.MediaDescription) string {\n\tfor _, attr := range media.Attributes {\n\t\tif attr.Key == \"mid\" {\n\t\t\treturn attr.Value\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// SessionDescription contains a MediaSection with Multiple SSRCs, it is Plan-B\nfunc descriptionIsPlanB(desc *SessionDescription, log logging.LeveledLogger) bool {\n\tif desc == nil || desc.parsed == nil {\n\t\treturn false\n\t}\n\n\t// Store all MIDs that already contain a track\n\tmidWithTrack := map[string]bool{}\n\n\tfor _, trackDetail := range trackDetailsFromSDP(log, desc.parsed) {\n\t\tif _, ok := midWithTrack[trackDetail.mid]; ok {\n\t\t\treturn true\n\t\t}\n\t\tmidWithTrack[trackDetail.mid] = true\n\t}\n\n\treturn false\n}\n\n// SessionDescription contains a MediaSection with name `audio`, `video` or `data`\n// If only one SSRC is set we can't know if it is Plan-B or Unified. If users have\n// set fallback mode assume it is Plan-B\nfunc descriptionPossiblyPlanB(desc *SessionDescription) bool {\n\tif desc == nil || desc.parsed == nil {\n\t\treturn false\n\t}\n\n\tdetectionRegex := regexp.MustCompile(`(?i)^(audio|video|data)$`)\n\tfor _, media := range desc.parsed.MediaDescriptions {\n\t\tif len(detectionRegex.FindStringSubmatch(getMidValue(media))) == 2 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc getPeerDirection(media *sdp.MediaDescription) RTPTransceiverDirection {\n\tfor _, a := range media.Attributes {\n\t\tif direction := NewRTPTransceiverDirection(a.Key); direction != RTPTransceiverDirectionUnknown {\n\t\t\treturn direction\n\t\t}\n\t}\n\treturn RTPTransceiverDirectionUnknown\n}\n\nfunc extractBundleID(desc *sdp.SessionDescription) string {\n\tgroupAttribute, _ := desc.Attribute(sdp.AttrKeyGroup)\n\n\tisBundled := strings.Contains(groupAttribute, \"BUNDLE\")\n\n\tif !isBundled {\n\t\treturn \"\"\n\t}\n\n\tbundleIDs := strings.Split(groupAttribute, \" \")\n\n\tif len(bundleIDs) < 2 {\n\t\treturn \"\"\n\t}\n\n\treturn bundleIDs[1]\n}\n\nfunc extractFingerprint(desc *sdp.SessionDescription) (string, string, error) { //nolint: gocognit\n\tfingerprint := \"\"\n\n\t// Fingerprint on session level has highest priority\n\tif sessionFingerprint, haveFingerprint := desc.Attribute(\"fingerprint\"); haveFingerprint {\n\t\tfingerprint = sessionFingerprint\n\t}\n\n\tif fingerprint == \"\" {\n\t\tbundleID := extractBundleID(desc)\n\t\tif bundleID != \"\" {\n\t\t\t// Locate the fingerprint of the bundled media section\n\t\t\tfor _, m := range desc.MediaDescriptions {\n\t\t\t\tif mid, haveMid := m.Attribute(\"mid\"); haveMid {\n\t\t\t\t\tif mid == bundleID && fingerprint == \"\" {\n\t\t\t\t\t\tif mediaFingerprint, haveFingerprint := m.Attribute(\"fingerprint\"); haveFingerprint {\n\t\t\t\t\t\t\tfingerprint = mediaFingerprint\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Take the fingerprint from the first media section which has one.\n\t\t\t// Note: According to Bundle spec each media section would have it's own transport\n\t\t\t//       with it's own cert and fingerprint each, so we would need to return a list.\n\t\t\tfor _, m := range desc.MediaDescriptions {\n\t\t\t\tmediaFingerprint, haveFingerprint := m.Attribute(\"fingerprint\")\n\t\t\t\tif haveFingerprint && fingerprint == \"\" {\n\t\t\t\t\tfingerprint = mediaFingerprint\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif fingerprint == \"\" {\n\t\treturn \"\", \"\", ErrSessionDescriptionNoFingerprint\n\t}\n\n\tparts := strings.Split(fingerprint, \" \")\n\tif len(parts) != 2 {\n\t\treturn \"\", \"\", ErrSessionDescriptionInvalidFingerprint\n\t}\n\treturn parts[1], parts[0], nil\n}\n\n// identifiedMediaDescription contains a MediaDescription with sdpMid and sdpMLineIndex\ntype identifiedMediaDescription struct {\n\tMediaDescription *sdp.MediaDescription\n\tSDPMid           string\n\tSDPMLineIndex    uint16\n}\n\nfunc extractICEDetailsFromMedia(media *identifiedMediaDescription, log logging.LeveledLogger) (string, string, []ICECandidate, error) {\n\tremoteUfrag := \"\"\n\tremotePwd := \"\"\n\tcandidates := []ICECandidate{}\n\tdescr := media.MediaDescription\n\n\tif ufrag, haveUfrag := descr.Attribute(\"ice-ufrag\"); haveUfrag {\n\t\tremoteUfrag = ufrag\n\t}\n\tif pwd, havePwd := descr.Attribute(\"ice-pwd\"); havePwd {\n\t\tremotePwd = pwd\n\t}\n\tfor _, a := range descr.Attributes {\n\t\tif a.IsICECandidate() {\n\t\t\tc, err := ice.UnmarshalCandidate(a.Value)\n\t\t\tif err != nil {\n\t\t\t\tif errors.Is(err, ice.ErrUnknownCandidateTyp) || errors.Is(err, ice.ErrDetermineNetworkType) {\n\t\t\t\t\tlog.Warnf(\"Discarding remote candidate: %s\", err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn \"\", \"\", nil, err\n\t\t\t}\n\n\t\t\tcandidate, err := newICECandidateFromICE(c, media.SDPMid, media.SDPMLineIndex)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", \"\", nil, err\n\t\t\t}\n\n\t\t\tcandidates = append(candidates, candidate)\n\t\t}\n\t}\n\n\treturn remoteUfrag, remotePwd, candidates, nil\n}\n\ntype sdpICEDetails struct {\n\tUfrag      string\n\tPassword   string\n\tCandidates []ICECandidate\n}\n\nfunc extractICEDetails(desc *sdp.SessionDescription, log logging.LeveledLogger) (*sdpICEDetails, error) { // nolint:gocognit\n\tdetails := &sdpICEDetails{\n\t\tCandidates: []ICECandidate{},\n\t}\n\n\t// Ufrag and Pw are allow at session level and thus have highest prio\n\tif ufrag, haveUfrag := desc.Attribute(\"ice-ufrag\"); haveUfrag {\n\t\tdetails.Ufrag = ufrag\n\t}\n\tif pwd, havePwd := desc.Attribute(\"ice-pwd\"); havePwd {\n\t\tdetails.Password = pwd\n\t}\n\n\tmediaDescr, ok := selectCandidateMediaSection(desc)\n\tif ok {\n\t\tufrag, pwd, candidates, err := extractICEDetailsFromMedia(mediaDescr, log)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif details.Ufrag == \"\" && ufrag != \"\" {\n\t\t\tdetails.Ufrag = ufrag\n\t\t\tdetails.Password = pwd\n\t\t}\n\n\t\tdetails.Candidates = candidates\n\t}\n\n\tif details.Ufrag == \"\" {\n\t\treturn nil, ErrSessionDescriptionMissingIceUfrag\n\t} else if details.Password == \"\" {\n\t\treturn nil, ErrSessionDescriptionMissingIcePwd\n\t}\n\n\treturn details, nil\n}\n\n// Select the first media section or the first bundle section\n// Currently Pion uses the first media section to gather candidates.\n// https://github.com/pion/webrtc/pull/2950\nfunc selectCandidateMediaSection(sessionDescription *sdp.SessionDescription) (descr *identifiedMediaDescription, ok bool) {\n\tbundleID := extractBundleID(sessionDescription)\n\n\tfor mLineIndex, mediaDescr := range sessionDescription.MediaDescriptions {\n\t\tmid := getMidValue(mediaDescr)\n\t\t// If bundled, only take ICE detail from bundle master section\n\t\tif bundleID != \"\" {\n\t\t\tif mid == bundleID {\n\t\t\t\treturn &identifiedMediaDescription{\n\t\t\t\t\tMediaDescription: mediaDescr,\n\t\t\t\t\tSDPMid:           mid,\n\t\t\t\t\tSDPMLineIndex:    uint16(mLineIndex),\n\t\t\t\t}, true\n\t\t\t}\n\t\t} else {\n\t\t\t// For not-bundled, take ICE details from the first media section\n\t\t\treturn &identifiedMediaDescription{\n\t\t\t\tMediaDescription: mediaDescr,\n\t\t\t\tSDPMid:           mid,\n\t\t\t\tSDPMLineIndex:    uint16(mLineIndex),\n\t\t\t}, true\n\t\t}\n\t}\n\n\treturn nil, false\n}\n\nfunc haveApplicationMediaSection(desc *sdp.SessionDescription) bool {\n\tfor _, m := range desc.MediaDescriptions {\n\t\tif m.MediaName.Media == mediaSectionApplication {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc getByMid(searchMid string, desc *SessionDescription) *sdp.MediaDescription {\n\tfor _, m := range desc.parsed.MediaDescriptions {\n\t\tif mid, ok := m.Attribute(sdp.AttrKeyMID); ok && mid == searchMid {\n\t\t\treturn m\n\t\t}\n\t}\n\treturn nil\n}\n\n// haveDataChannel return MediaDescription with MediaName equal application\nfunc haveDataChannel(desc *SessionDescription) *sdp.MediaDescription {\n\tfor _, d := range desc.parsed.MediaDescriptions {\n\t\tif d.MediaName.Media == mediaSectionApplication {\n\t\t\treturn d\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc codecsFromMediaDescription(m *sdp.MediaDescription) (out []RTPCodecParameters, err error) {\n\ts := &sdp.SessionDescription{\n\t\tMediaDescriptions: []*sdp.MediaDescription{m},\n\t}\n\n\tfor _, payloadStr := range m.MediaName.Formats {\n\t\tpayloadType, err := strconv.ParseUint(payloadStr, 10, 8)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcodec, err := s.GetCodecForPayloadType(uint8(payloadType))\n\t\tif err != nil {\n\t\t\tif payloadType == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\tchannels := uint16(0)\n\t\tval, err := strconv.ParseUint(codec.EncodingParameters, 10, 16)\n\t\tif err == nil {\n\t\t\tchannels = uint16(val)\n\t\t}\n\n\t\tfeedback := []RTCPFeedback{}\n\t\tfor _, raw := range codec.RTCPFeedback {\n\t\t\tsplit := strings.Split(raw, \" \")\n\t\t\tentry := RTCPFeedback{Type: split[0]}\n\t\t\tif len(split) == 2 {\n\t\t\t\tentry.Parameter = split[1]\n\t\t\t}\n\n\t\t\tfeedback = append(feedback, entry)\n\t\t}\n\n\t\tout = append(out, RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{m.MediaName.Media + \"/\" + codec.Name, codec.ClockRate, channels, codec.Fmtp, feedback},\n\t\t\tPayloadType:        PayloadType(payloadType),\n\t\t})\n\t}\n\n\treturn out, nil\n}\n\nfunc rtpExtensionsFromMediaDescription(m *sdp.MediaDescription) (map[string]int, error) {\n\tout := map[string]int{}\n\n\tfor _, a := range m.Attributes {\n\t\tif a.Key == sdp.AttrKeyExtMap {\n\t\t\te := sdp.ExtMap{}\n\t\t\tif err := e.Unmarshal(a.String()); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tout[e.URI.String()] = e.Value\n\t\t}\n\t}\n\n\treturn out, nil\n}\n\n// updateSDPOrigin saves sdp.Origin in PeerConnection when creating 1st local SDP;\n// for subsequent calling, it updates Origin for SessionDescription from saved one\n// and increments session version by one.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-25#section-5.2.2\nfunc updateSDPOrigin(origin *sdp.Origin, d *sdp.SessionDescription) {\n\tif atomic.CompareAndSwapUint64(&origin.SessionVersion, 0, d.Origin.SessionVersion) { // store\n\t\tatomic.StoreUint64(&origin.SessionID, d.Origin.SessionID)\n\t} else { // load\n\t\tfor { // awaiting for saving session id\n\t\t\td.Origin.SessionID = atomic.LoadUint64(&origin.SessionID)\n\t\t\tif d.Origin.SessionID != 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\td.Origin.SessionVersion = atomic.AddUint64(&origin.SessionVersion, 1)\n\t}\n}\n\nfunc isIceLiteSet(desc *sdp.SessionDescription) bool {\n\tfor _, a := range desc.Attributes {\n\t\tif strings.TrimSpace(a.Key) == sdp.AttrKeyICELite {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc isExtMapAllowMixedSet(desc *sdp.SessionDescription) bool {\n\tfor _, a := range desc.Attributes {\n\t\tif strings.TrimSpace(a.Key) == sdp.AttrKeyExtMapAllowMixed {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "sdp_test.go",
          "type": "blob",
          "size": 33.3857421875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestExtractFingerprint(t *testing.T) {\n\tt.Run(\"Good Session Fingerprint\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{{Key: \"fingerprint\", Value: \"foo bar\"}},\n\t\t}\n\n\t\tfingerprint, hash, err := extractFingerprint(s)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, fingerprint, \"bar\")\n\t\tassert.Equal(t, hash, \"foo\")\n\t})\n\n\tt.Run(\"Good Media Fingerprint\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{{Key: \"fingerprint\", Value: \"foo bar\"}}},\n\t\t\t},\n\t\t}\n\n\t\tfingerprint, hash, err := extractFingerprint(s)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, fingerprint, \"bar\")\n\t\tassert.Equal(t, hash, \"foo\")\n\t})\n\n\tt.Run(\"No Fingerprint\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{}\n\n\t\t_, _, err := extractFingerprint(s)\n\t\tassert.Equal(t, ErrSessionDescriptionNoFingerprint, err)\n\t})\n\n\tt.Run(\"Invalid Fingerprint\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{{Key: \"fingerprint\", Value: \"foo\"}},\n\t\t}\n\n\t\t_, _, err := extractFingerprint(s)\n\t\tassert.Equal(t, ErrSessionDescriptionInvalidFingerprint, err)\n\t})\n\n\tt.Run(\"Session fingerprint wins over media\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{{Key: \"fingerprint\", Value: \"foo bar\"}},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{{Key: \"fingerprint\", Value: \"zoo boo\"}}},\n\t\t\t},\n\t\t}\n\n\t\tfingerprint, hash, err := extractFingerprint(s)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, fingerprint, \"bar\")\n\t\tassert.Equal(t, hash, \"foo\")\n\t})\n\n\tt.Run(\"Fingerprint from master bundle section\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"group\", Value: \"BUNDLE 1 0\"},\n\t\t\t},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{\n\t\t\t\t\t{Key: \"mid\", Value: \"0\"},\n\t\t\t\t\t{Key: \"fingerprint\", Value: \"zoo boo\"},\n\t\t\t\t}},\n\t\t\t\t{Attributes: []sdp.Attribute{\n\t\t\t\t\t{Key: \"mid\", Value: \"1\"},\n\t\t\t\t\t{Key: \"fingerprint\", Value: \"bar foo\"},\n\t\t\t\t}},\n\t\t\t},\n\t\t}\n\n\t\tfingerprint, hash, err := extractFingerprint(s)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, fingerprint, \"foo\")\n\t\tassert.Equal(t, hash, \"bar\")\n\t})\n\n\tt.Run(\"Fingerprint from first media section\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{\n\t\t\t\t\t{Key: \"mid\", Value: \"0\"},\n\t\t\t\t\t{Key: \"fingerprint\", Value: \"zoo boo\"},\n\t\t\t\t}},\n\t\t\t\t{Attributes: []sdp.Attribute{\n\t\t\t\t\t{Key: \"mid\", Value: \"1\"},\n\t\t\t\t\t{Key: \"fingerprint\", Value: \"bar foo\"},\n\t\t\t\t}},\n\t\t\t},\n\t\t}\n\n\t\tfingerprint, hash, err := extractFingerprint(s)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, fingerprint, \"boo\")\n\t\tassert.Equal(t, hash, \"zoo\")\n\t})\n}\n\nfunc TestExtractICEDetails(t *testing.T) {\n\tconst defaultUfrag = \"defaultUfrag\"\n\tconst defaultPwd = \"defaultPwd\"\n\tconst invalidUfrag = \"invalidUfrag\"\n\tconst invalidPwd = \"invalidPwd\"\n\n\tt.Run(\"Missing ice-pwd\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{{Key: \"ice-ufrag\", Value: defaultUfrag}}},\n\t\t\t},\n\t\t}\n\n\t\t_, err := extractICEDetails(s, nil)\n\t\tassert.Equal(t, err, ErrSessionDescriptionMissingIcePwd)\n\t})\n\n\tt.Run(\"Missing ice-ufrag\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{{Key: \"ice-pwd\", Value: defaultPwd}}},\n\t\t\t},\n\t\t}\n\n\t\t_, err := extractICEDetails(s, nil)\n\t\tassert.Equal(t, err, ErrSessionDescriptionMissingIceUfrag)\n\t})\n\n\tt.Run(\"ice details at session level\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"ice-ufrag\", Value: defaultUfrag},\n\t\t\t\t{Key: \"ice-pwd\", Value: defaultPwd},\n\t\t\t},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{},\n\t\t}\n\n\t\tdetails, err := extractICEDetails(s, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, details.Ufrag, defaultUfrag)\n\t\tassert.Equal(t, details.Password, defaultPwd)\n\t})\n\n\tt.Run(\"ice details at media level\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: defaultUfrag},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: defaultPwd},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tdetails, err := extractICEDetails(s, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, details.Ufrag, defaultUfrag)\n\t\tassert.Equal(t, details.Password, defaultPwd)\n\t})\n\n\tt.Run(\"ice details at session preferred over media\", func(t *testing.T) {\n\t\tdescr := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"ice-ufrag\", Value: defaultUfrag},\n\t\t\t\t{Key: \"ice-pwd\", Value: defaultPwd},\n\t\t\t},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: invalidUfrag},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: invalidPwd},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tdetails, err := extractICEDetails(descr, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, details.Ufrag, defaultUfrag)\n\t\tassert.Equal(t, details.Password, defaultPwd)\n\t})\n\n\tt.Run(\"ice details from bundle media section\", func(t *testing.T) {\n\t\tdescr := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"group\", Value: \"BUNDLE 5 2\"},\n\t\t\t},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"2\"},\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: invalidUfrag},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: invalidPwd},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"5\"},\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: defaultUfrag},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: defaultPwd},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tdetails, err := extractICEDetails(descr, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, details.Ufrag, defaultUfrag)\n\t\tassert.Equal(t, details.Password, defaultPwd)\n\t})\n\n\tt.Run(\"ice details from first media section\", func(t *testing.T) {\n\t\tdescr := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: defaultUfrag},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: defaultPwd},\n\t\t\t\t\t\t{Key: \"mid\", Value: \"5\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: invalidUfrag},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: invalidPwd},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tdetails, err := extractICEDetails(descr, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, details.Ufrag, defaultUfrag)\n\t\tassert.Equal(t, details.Password, defaultPwd)\n\t})\n\n\tt.Run(\"Missing pwd at session level\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{{Key: \"ice-ufrag\", Value: \"invalidUfrag\"}},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{{Key: \"ice-ufrag\", Value: defaultUfrag}, {Key: \"ice-pwd\", Value: defaultPwd}}},\n\t\t\t},\n\t\t}\n\n\t\t_, err := extractICEDetails(s, nil)\n\t\tassert.Equal(t, err, ErrSessionDescriptionMissingIcePwd)\n\t})\n\n\tt.Run(\"Extracts candidate from media section\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"group\", Value: \"BUNDLE video audio\"},\n\t\t\t},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"audio\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: \"ufrag\"},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: \"pwd\"},\n\t\t\t\t\t\t{Key: \"ice-options\", Value: \"google-ice\"},\n\t\t\t\t\t\t{Key: \"candidate\", Value: \"1 1 udp 2122162783 192.168.84.254 46492 typ host generation 0\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"ice-ufrag\", Value: \"ufrag\"},\n\t\t\t\t\t\t{Key: \"ice-pwd\", Value: \"pwd\"},\n\t\t\t\t\t\t{Key: \"ice-options\", Value: \"google-ice\"},\n\t\t\t\t\t\t{Key: \"mid\", Value: \"video\"},\n\t\t\t\t\t\t{Key: \"candidate\", Value: \"1 1 udp 2122162783 192.168.84.254 46492 typ host generation 0\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tdetails, err := extractICEDetails(s, nil)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, details.Ufrag, \"ufrag\")\n\t\tassert.Equal(t, details.Password, \"pwd\")\n\t\tassert.Equal(t, details.Candidates[0].Address, \"192.168.84.254\")\n\t\tassert.Equal(t, details.Candidates[0].Port, uint16(46492))\n\t\tassert.Equal(t, details.Candidates[0].Typ, ICECandidateTypeHost)\n\t\tassert.Equal(t, details.Candidates[0].SDPMid, \"video\")\n\t\tassert.Equal(t, details.Candidates[0].SDPMLineIndex, uint16(1))\n\t})\n}\n\nfunc TestSelectCandidateMediaSection(t *testing.T) {\n\tt.Run(\"no media section\", func(t *testing.T) {\n\t\tdescr := &sdp.SessionDescription{}\n\n\t\tmedia, ok := selectCandidateMediaSection(descr)\n\t\tassert.False(t, ok)\n\t\tassert.Nil(t, media)\n\t})\n\n\tt.Run(\"no bundle\", func(t *testing.T) {\n\t\tdescr := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{Attributes: []sdp.Attribute{{Key: \"mid\", Value: \"0\"}}},\n\t\t\t\t{Attributes: []sdp.Attribute{{Key: \"mid\", Value: \"1\"}}},\n\t\t\t},\n\t\t}\n\n\t\tmedia, ok := selectCandidateMediaSection(descr)\n\t\tassert.True(t, ok)\n\t\tassert.NotNil(t, media)\n\t\tassert.NotNil(t, media.MediaDescription)\n\t\tassert.Equal(t, \"0\", media.SDPMid)\n\t\tassert.Equal(t, uint16(0), media.SDPMLineIndex)\n\t})\n\n\tt.Run(\"with bundle\", func(t *testing.T) {\n\t\tdescr := &sdp.SessionDescription{\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"group\", Value: \"BUNDLE 5 2\"},\n\t\t\t},\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"5\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tmedia, ok := selectCandidateMediaSection(descr)\n\t\tassert.True(t, ok)\n\t\tassert.NotNil(t, media)\n\t\tassert.NotNil(t, media.MediaDescription)\n\t\tassert.Equal(t, \"5\", media.SDPMid)\n\t\tassert.Equal(t, uint16(1), media.SDPMLineIndex)\n\t})\n}\n\nfunc TestTrackDetailsFromSDP(t *testing.T) {\n\tt.Run(\"Tracks unknown, audio and video with RTX\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"foobar\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"0\"},\n\t\t\t\t\t\t{Key: \"sendrecv\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"1000 msid:unknown_trk_label unknown_trk_guid\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"audio\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"1\"},\n\t\t\t\t\t\t{Key: \"sendrecv\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"2000 msid:audio_trk_label audio_trk_guid\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"2\"},\n\t\t\t\t\t\t{Key: \"sendrecv\"},\n\t\t\t\t\t\t{Key: \"ssrc-group\", Value: \"FID 3000 4000\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"3000 msid:video_trk_label video_trk_guid\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"4000 msid:rtx_trk_label rtx_trck_guid\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"3\"},\n\t\t\t\t\t\t{Key: \"sendonly\"},\n\t\t\t\t\t\t{Key: \"msid\", Value: \"video_stream_id video_trk_id\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"5000\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"sendonly\"},\n\t\t\t\t\t\t{Key: sdpAttributeRid, Value: \"f send pt=97;max-width=1280;max-height=720\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttracks := trackDetailsFromSDP(nil, s)\n\t\tassert.Equal(t, 3, len(tracks))\n\t\tif trackDetail := trackDetailsForSSRC(tracks, 1000); trackDetail != nil {\n\t\t\tassert.Fail(t, \"got the unknown track ssrc:1000 which should have been skipped\")\n\t\t}\n\t\tif track := trackDetailsForSSRC(tracks, 2000); track == nil {\n\t\t\tassert.Fail(t, \"missing audio track with ssrc:2000\")\n\t\t} else {\n\t\t\tassert.Equal(t, RTPCodecTypeAudio, track.kind)\n\t\t\tassert.Equal(t, SSRC(2000), track.ssrcs[0])\n\t\t\tassert.Equal(t, \"audio_trk_label\", track.streamID)\n\t\t}\n\t\tif track := trackDetailsForSSRC(tracks, 3000); track == nil {\n\t\t\tassert.Fail(t, \"missing video track with ssrc:3000\")\n\t\t} else {\n\t\t\tassert.Equal(t, RTPCodecTypeVideo, track.kind)\n\t\t\tassert.Equal(t, SSRC(3000), track.ssrcs[0])\n\t\t\tassert.Equal(t, \"video_trk_label\", track.streamID)\n\t\t}\n\t\tif track := trackDetailsForSSRC(tracks, 4000); track != nil {\n\t\t\tassert.Fail(t, \"got the rtx track ssrc:3000 which should have been skipped\")\n\t\t}\n\t\tif track := trackDetailsForSSRC(tracks, 5000); track == nil {\n\t\t\tassert.Fail(t, \"missing video track with ssrc:5000\")\n\t\t} else {\n\t\t\tassert.Equal(t, RTPCodecTypeVideo, track.kind)\n\t\t\tassert.Equal(t, SSRC(5000), track.ssrcs[0])\n\t\t\tassert.Equal(t, \"video_trk_id\", track.id)\n\t\t\tassert.Equal(t, \"video_stream_id\", track.streamID)\n\t\t}\n\t})\n\n\tt.Run(\"inactive and recvonly tracks ignored\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"inactive\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"6000\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"recvonly\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"7000\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tassert.Equal(t, 0, len(trackDetailsFromSDP(nil, s)))\n\t})\n\n\tt.Run(\"ssrc-group after ssrc\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"0\"},\n\t\t\t\t\t\t{Key: \"sendrecv\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"3000 msid:video_trk_label video_trk_guid\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"4000 msid:rtx_trk_label rtx_trck_guid\"},\n\t\t\t\t\t\t{Key: \"ssrc-group\", Value: \"FID 3000 4000\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"video\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"mid\", Value: \"1\"},\n\t\t\t\t\t\t{Key: \"sendrecv\"},\n\t\t\t\t\t\t{Key: \"ssrc-group\", Value: \"FID 5000 6000\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"5000 msid:video_trk_label video_trk_guid\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"6000 msid:rtx_trk_label rtx_trck_guid\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\ttracks := trackDetailsFromSDP(nil, s)\n\t\tassert.Equal(t, 2, len(tracks))\n\t\tassert.Equal(t, SSRC(4000), *tracks[0].repairSsrc)\n\t\tassert.Equal(t, SSRC(6000), *tracks[1].repairSsrc)\n\t})\n}\n\nfunc TestHaveApplicationMediaSection(t *testing.T) {\n\tt.Run(\"Audio only\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: \"audio\",\n\t\t\t\t\t},\n\t\t\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t\t\t{Key: \"sendrecv\"},\n\t\t\t\t\t\t{Key: \"ssrc\", Value: \"2000\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tassert.False(t, haveApplicationMediaSection(s))\n\t})\n\n\tt.Run(\"Application\", func(t *testing.T) {\n\t\ts := &sdp.SessionDescription{\n\t\t\tMediaDescriptions: []*sdp.MediaDescription{\n\t\t\t\t{\n\t\t\t\t\tMediaName: sdp.MediaName{\n\t\t\t\t\t\tMedia: mediaSectionApplication,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tassert.True(t, haveApplicationMediaSection(s))\n\t})\n}\n\nfunc TestMediaDescriptionFingerprints(t *testing.T) {\n\tengine := &MediaEngine{}\n\tassert.NoError(t, engine.RegisterDefaultCodecs())\n\n\tapi := NewAPI(WithMediaEngine(engine))\n\n\tsk, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tassert.NoError(t, err)\n\n\tcertificate, err := GenerateCertificate(sk)\n\tassert.NoError(t, err)\n\n\tmedia := []mediaSection{\n\t\t{\n\t\t\tid: \"video\",\n\t\t\ttransceivers: []*RTPTransceiver{{\n\t\t\t\tkind:   RTPCodecTypeVideo,\n\t\t\t\tapi:    api,\n\t\t\t\tcodecs: engine.getCodecsByKind(RTPCodecTypeVideo),\n\t\t\t}},\n\t\t},\n\t\t{\n\t\t\tid: \"audio\",\n\t\t\ttransceivers: []*RTPTransceiver{{\n\t\t\t\tkind:   RTPCodecTypeAudio,\n\t\t\t\tapi:    api,\n\t\t\t\tcodecs: engine.getCodecsByKind(RTPCodecTypeAudio),\n\t\t\t}},\n\t\t},\n\t\t{\n\t\t\tid:   \"application\",\n\t\t\tdata: true,\n\t\t},\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\tmedia[i].transceivers[0].setSender(&RTPSender{})\n\t\tmedia[i].transceivers[0].setDirection(RTPTransceiverDirectionSendonly)\n\t}\n\n\tfingerprintTest := func(SDPMediaDescriptionFingerprints bool, expectedFingerprintCount int) func(t *testing.T) {\n\t\treturn func(t *testing.T) {\n\t\t\ts := &sdp.SessionDescription{}\n\n\t\t\tdtlsFingerprints, err := certificate.GetFingerprints()\n\t\t\tassert.NoError(t, err)\n\n\t\t\ts, err = populateSDP(s, false,\n\t\t\t\tdtlsFingerprints,\n\t\t\t\tSDPMediaDescriptionFingerprints,\n\t\t\t\tfalse, true, engine, sdp.ConnectionRoleActive, []ICECandidate{}, ICEParameters{}, media, ICEGatheringStateNew, nil)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tsdparray, err := s.Marshal()\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Equal(t, strings.Count(string(sdparray), \"sha-256\"), expectedFingerprintCount)\n\t\t}\n\t}\n\n\tt.Run(\"Per-Media Description Fingerprints\", fingerprintTest(true, 3))\n\tt.Run(\"Per-Session Description Fingerprints\", fingerprintTest(false, 1))\n}\n\nfunc TestPopulateSDP(t *testing.T) {\n\tt.Run(\"rid\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\n\t\tme := &MediaEngine{}\n\t\tassert.NoError(t, me.RegisterDefaultCodecs())\n\t\tapi := NewAPI(WithMediaEngine(me))\n\n\t\ttr := &RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}\n\t\ttr.setDirection(RTPTransceiverDirectionRecvonly)\n\t\trids := []*simulcastRid{\n\t\t\t{\n\t\t\t\tid:        \"ridkey\",\n\t\t\t\tattrValue: \"some\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid:        \"ridPaused\",\n\t\t\t\tattrValue: \"some2\",\n\t\t\t\tpaused:    true,\n\t\t\t},\n\t\t}\n\t\tmediaSections := []mediaSection{{id: \"video\", transceivers: []*RTPTransceiver{tr}, rids: rids}}\n\n\t\td := &sdp.SessionDescription{}\n\n\t\tofferSdp, err := populateSDP(d, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, me, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, mediaSections, ICEGatheringStateComplete, nil)\n\t\tassert.Nil(t, err)\n\n\t\t// Test contains rid map keys\n\t\tvar ridFound int\n\t\tfor _, desc := range offerSdp.MediaDescriptions {\n\t\t\tif desc.MediaName.Media != \"video\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tridsInSDP := getRids(desc)\n\t\t\tfor _, rid := range ridsInSDP {\n\t\t\t\tif rid.id == \"ridkey\" && !rid.paused {\n\t\t\t\t\tridFound++\n\t\t\t\t}\n\t\t\t\tif rid.id == \"ridPaused\" && rid.paused {\n\t\t\t\t\tridFound++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert.Equal(t, 2, ridFound, \"All rid keys should be present\")\n\t})\n\tt.Run(\"SetCodecPreferences\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\n\t\tme := &MediaEngine{}\n\t\tassert.NoError(t, me.RegisterDefaultCodecs())\n\t\tapi := NewAPI(WithMediaEngine(me))\n\t\tme.pushCodecs(me.videoCodecs, RTPCodecTypeVideo)\n\t\tme.pushCodecs(me.audioCodecs, RTPCodecTypeAudio)\n\n\t\ttr := &RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}\n\t\ttr.setDirection(RTPTransceiverDirectionRecvonly)\n\t\tcodecErr := tr.SetCodecPreferences([]RTPCodecParameters{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeVP8, 90000, 0, \"\", nil},\n\t\t\t\tPayloadType:        96,\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, codecErr)\n\n\t\tmediaSections := []mediaSection{{id: \"video\", transceivers: []*RTPTransceiver{tr}}}\n\n\t\td := &sdp.SessionDescription{}\n\n\t\tofferSdp, err := populateSDP(d, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, me, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, mediaSections, ICEGatheringStateComplete, nil)\n\t\tassert.Nil(t, err)\n\n\t\t// Test codecs\n\t\tfoundVP8 := false\n\t\tfor _, desc := range offerSdp.MediaDescriptions {\n\t\t\tif desc.MediaName.Media != \"video\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, a := range desc.Attributes {\n\t\t\t\tif strings.Contains(a.Key, \"rtpmap\") {\n\t\t\t\t\tif a.Value == \"98 VP9/90000\" {\n\t\t\t\t\t\tt.Fatal(\"vp9 should not be present in sdp\")\n\t\t\t\t\t} else if a.Value == \"96 VP8/90000\" {\n\t\t\t\t\t\tfoundVP8 = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert.Equal(t, true, foundVP8, \"vp8 should be present in sdp\")\n\t})\n\tt.Run(\"ice-lite\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\t\tse.SetLite(true)\n\n\t\tofferSdp, err := populateSDP(&sdp.SessionDescription{}, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, &MediaEngine{}, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, []mediaSection{}, ICEGatheringStateComplete, nil)\n\t\tassert.Nil(t, err)\n\n\t\tvar found bool\n\t\t// ice-lite is an session-level attribute\n\t\tfor _, a := range offerSdp.Attributes {\n\t\t\tif a.Key == sdp.AttrKeyICELite {\n\t\t\t\t// ice-lite does not have value (e.g. \":<value>\") and it should be an empty string\n\t\t\t\tif a.Value == \"\" {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert.Equal(t, true, found, \"ICELite key should be present\")\n\t})\n\tt.Run(\"rejected track\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\n\t\tme := &MediaEngine{}\n\t\tregisterCodecErr := me.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\t\tPayloadType:        96,\n\t\t}, RTPCodecTypeVideo)\n\t\tassert.NoError(t, registerCodecErr)\n\t\tapi := NewAPI(WithMediaEngine(me))\n\n\t\tvideoTransceiver := &RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}\n\t\taudioTransceiver := &RTPTransceiver{kind: RTPCodecTypeAudio, api: api, codecs: []RTPCodecParameters{}}\n\t\tmediaSections := []mediaSection{{id: \"video\", transceivers: []*RTPTransceiver{videoTransceiver}}, {id: \"audio\", transceivers: []*RTPTransceiver{audioTransceiver}}}\n\n\t\td := &sdp.SessionDescription{}\n\n\t\tofferSdp, err := populateSDP(d, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, me, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, mediaSections, ICEGatheringStateComplete, nil)\n\t\tassert.NoError(t, err)\n\n\t\t// Test codecs\n\t\tfoundRejectedTrack := false\n\t\tfor _, desc := range offerSdp.MediaDescriptions {\n\t\t\tif desc.MediaName.Media != \"audio\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tassert.True(t, desc.ConnectionInformation != nil, \"connection information must be provided for rejected tracks\")\n\t\t\tassert.Equal(t, desc.MediaName.Formats, []string{\"0\"}, \"rejected tracks have 0 for Formats\")\n\t\t\tassert.Equal(t, desc.MediaName.Port, sdp.RangedPort{Value: 0}, \"rejected tracks have 0 for Port\")\n\t\t\tfoundRejectedTrack = true\n\t\t}\n\t\tassert.Equal(t, true, foundRejectedTrack, \"rejected track wasn't present\")\n\t})\n\tt.Run(\"allow mixed extmap\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\t\tofferSdp, err := populateSDP(&sdp.SessionDescription{}, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, &MediaEngine{}, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, []mediaSection{}, ICEGatheringStateComplete, nil)\n\t\tassert.Nil(t, err)\n\n\t\tvar found bool\n\t\t// session-level attribute\n\t\tfor _, a := range offerSdp.Attributes {\n\t\t\tif a.Key == sdp.AttrKeyExtMapAllowMixed {\n\t\t\t\tif a.Value == \"\" {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert.Equal(t, true, found, \"AllowMixedExtMap key should be present\")\n\n\t\tofferSdp, err = populateSDP(&sdp.SessionDescription{}, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, false, &MediaEngine{}, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, []mediaSection{}, ICEGatheringStateComplete, nil)\n\t\tassert.Nil(t, err)\n\n\t\tfound = false\n\t\t// session-level attribute\n\t\tfor _, a := range offerSdp.Attributes {\n\t\t\tif a.Key == sdp.AttrKeyExtMapAllowMixed {\n\t\t\t\tif a.Value == \"\" {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert.Equal(t, false, found, \"AllowMixedExtMap key should not be present\")\n\t})\n\tt.Run(\"bundle all\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\n\t\tme := &MediaEngine{}\n\t\tassert.NoError(t, me.RegisterDefaultCodecs())\n\t\tapi := NewAPI(WithMediaEngine(me))\n\n\t\ttr := &RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}\n\t\ttr.setDirection(RTPTransceiverDirectionRecvonly)\n\t\tmediaSections := []mediaSection{{id: \"video\", transceivers: []*RTPTransceiver{tr}}}\n\n\t\td := &sdp.SessionDescription{}\n\n\t\tofferSdp, err := populateSDP(d, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, me, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, mediaSections, ICEGatheringStateComplete, nil)\n\t\tassert.Nil(t, err)\n\n\t\tbundle, ok := offerSdp.Attribute(sdp.AttrKeyGroup)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, \"BUNDLE video\", bundle)\n\t})\n\tt.Run(\"bundle matched\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\n\t\tme := &MediaEngine{}\n\t\tassert.NoError(t, me.RegisterDefaultCodecs())\n\t\tapi := NewAPI(WithMediaEngine(me))\n\n\t\ttra := &RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}\n\t\ttra.setDirection(RTPTransceiverDirectionRecvonly)\n\t\tmediaSections := []mediaSection{{id: \"video\", transceivers: []*RTPTransceiver{tra}}}\n\n\t\ttrv := &RTPTransceiver{kind: RTPCodecTypeAudio, api: api, codecs: me.audioCodecs}\n\t\ttrv.setDirection(RTPTransceiverDirectionRecvonly)\n\t\tmediaSections = append(mediaSections, mediaSection{id: \"audio\", transceivers: []*RTPTransceiver{trv}})\n\n\t\td := &sdp.SessionDescription{}\n\n\t\tmatchedBundle := \"audio\"\n\t\tofferSdp, err := populateSDP(d, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, me, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, mediaSections, ICEGatheringStateComplete, &matchedBundle)\n\t\tassert.Nil(t, err)\n\n\t\tbundle, ok := offerSdp.Attribute(sdp.AttrKeyGroup)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, \"BUNDLE audio\", bundle)\n\n\t\tmediaVideo := offerSdp.MediaDescriptions[0]\n\t\tmid, ok := mediaVideo.Attribute(sdp.AttrKeyMID)\n\t\tassert.True(t, ok)\n\t\tassert.Equal(t, \"video\", mid)\n\t\tassert.True(t, mediaVideo.MediaName.Port.Value == 0)\n\t})\n\tt.Run(\"empty bundle group\", func(t *testing.T) {\n\t\tse := SettingEngine{}\n\n\t\tme := &MediaEngine{}\n\t\tassert.NoError(t, me.RegisterDefaultCodecs())\n\t\tapi := NewAPI(WithMediaEngine(me))\n\n\t\ttra := &RTPTransceiver{kind: RTPCodecTypeVideo, api: api, codecs: me.videoCodecs}\n\t\ttra.setDirection(RTPTransceiverDirectionRecvonly)\n\t\tmediaSections := []mediaSection{{id: \"video\", transceivers: []*RTPTransceiver{tra}}}\n\n\t\td := &sdp.SessionDescription{}\n\n\t\tmatchedBundle := \"\"\n\t\tofferSdp, err := populateSDP(d, false, []DTLSFingerprint{}, se.sdpMediaLevelFingerprints, se.candidates.ICELite, true, me, connectionRoleFromDtlsRole(defaultDtlsRoleOffer), []ICECandidate{}, ICEParameters{}, mediaSections, ICEGatheringStateComplete, &matchedBundle)\n\t\tassert.Nil(t, err)\n\n\t\t_, ok := offerSdp.Attribute(sdp.AttrKeyGroup)\n\t\tassert.False(t, ok)\n\t})\n}\n\nfunc TestGetRIDs(t *testing.T) {\n\tm := []*sdp.MediaDescription{\n\t\t{\n\t\t\tMediaName: sdp.MediaName{\n\t\t\t\tMedia: \"video\",\n\t\t\t},\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"sendonly\"},\n\t\t\t\t{Key: sdpAttributeRid, Value: \"f send pt=97;max-width=1280;max-height=720\"},\n\t\t\t},\n\t\t},\n\t}\n\n\trids := getRids(m[0])\n\n\tassert.NotEmpty(t, rids, \"Rid mapping should be present\")\n\tfound := false\n\tfor _, rid := range rids {\n\t\tif rid.id == \"f\" {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !found {\n\t\tassert.Fail(t, \"rid values should contain 'f'\")\n\t}\n}\n\nfunc TestCodecsFromMediaDescription(t *testing.T) {\n\tt.Run(\"Codec Only\", func(t *testing.T) {\n\t\tcodecs, err := codecsFromMediaDescription(&sdp.MediaDescription{\n\t\t\tMediaName: sdp.MediaName{\n\t\t\t\tMedia:   \"audio\",\n\t\t\t\tFormats: []string{\"111\"},\n\t\t\t},\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"rtpmap\", Value: \"111 opus/48000/2\"},\n\t\t\t},\n\t\t})\n\n\t\tassert.Equal(t, codecs, []RTPCodecParameters{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 2, \"\", []RTCPFeedback{}},\n\t\t\t\tPayloadType:        111,\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"Codec with fmtp/rtcp-fb\", func(t *testing.T) {\n\t\tcodecs, err := codecsFromMediaDescription(&sdp.MediaDescription{\n\t\t\tMediaName: sdp.MediaName{\n\t\t\t\tMedia:   \"audio\",\n\t\t\t\tFormats: []string{\"111\"},\n\t\t\t},\n\t\t\tAttributes: []sdp.Attribute{\n\t\t\t\t{Key: \"rtpmap\", Value: \"111 opus/48000/2\"},\n\t\t\t\t{Key: \"fmtp\", Value: \"111 minptime=10;useinbandfec=1\"},\n\t\t\t\t{Key: \"rtcp-fb\", Value: \"111 goog-remb\"},\n\t\t\t\t{Key: \"rtcp-fb\", Value: \"111 ccm fir\"},\n\t\t\t\t{Key: \"rtcp-fb\", Value: \"* ccm fir\"},\n\t\t\t\t{Key: \"rtcp-fb\", Value: \"* nack\"},\n\t\t\t},\n\t\t})\n\n\t\tassert.Equal(t, codecs, []RTPCodecParameters{\n\t\t\t{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeTypeOpus, 48000, 2, \"minptime=10;useinbandfec=1\", []RTCPFeedback{{\"goog-remb\", \"\"}, {\"ccm\", \"fir\"}, {\"nack\", \"\"}}},\n\t\t\t\tPayloadType:        111,\n\t\t\t},\n\t\t})\n\t\tassert.NoError(t, err)\n\t})\n}\n\nfunc TestRtpExtensionsFromMediaDescription(t *testing.T) {\n\textensions, err := rtpExtensionsFromMediaDescription(&sdp.MediaDescription{\n\t\tMediaName: sdp.MediaName{\n\t\t\tMedia:   \"audio\",\n\t\t\tFormats: []string{\"111\"},\n\t\t},\n\t\tAttributes: []sdp.Attribute{\n\t\t\t{Key: \"extmap\", Value: \"1 \" + sdp.ABSSendTimeURI},\n\t\t\t{Key: \"extmap\", Value: \"3 \" + sdp.SDESMidURI},\n\t\t},\n\t})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, extensions[sdp.ABSSendTimeURI], 1)\n\tassert.Equal(t, extensions[sdp.SDESMidURI], 3)\n}\n\n// Assert that FEC and RTX SSRCes are present if they are enabled in the MediaEngine\nfunc Test_SSRC_Groups(t *testing.T) {\n\tconst offerWithRTX = `v=0\no=- 930222930247584370 1727933945 IN IP4 0.0.0.0\ns=-\nt=0 0\na=msid-semantic:WMS*\na=fingerprint:sha-256 11:3F:1C:8D:D4:1D:8D:E7:E1:3E:AF:38:06:0D:1D:40:22:DC:FE:C9:93:E4:80:D8:0B:17:9F:2E:C1:CA:C8:3D\na=extmap-allow-mixed\na=group:BUNDLE 0 1\nm=audio 9 UDP/TLS/RTP/SAVPF 101\nc=IN IP4 0.0.0.0\na=setup:actpass\na=mid:0\na=ice-ufrag:yIgpPUMarFReduuM\na=ice-pwd:VmnVaqCByWiOTatFoDBbMGhSFGlsxviz\na=rtcp-mux\na=rtcp-rsize\na=rtpmap:101 opus/90000\na=rtcp-fb:101 transport-cc\na=extmap:4 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\na=ssrc:3566446228 cname:stream-id\na=ssrc:3566446228 msid:stream-id audio-id\na=ssrc:3566446228 mslabel:stream-id\na=ssrc:3566446228 label:audio-id\na=msid:stream-id audio-id\na=sendrecv\nm=video 9 UDP/TLS/RTP/SAVPF 96 97\nc=IN IP4 0.0.0.0\na=setup:actpass\na=mid:1\na=ice-ufrag:yIgpPUMarFReduuM\na=ice-pwd:VmnVaqCByWiOTatFoDBbMGhSFGlsxviz\na=rtpmap:96 VP8/90000\na=rtcp-fb:96 nack\na=rtcp-fb:96 nack pli\na=rtcp-fb:96 transport-cc\na=rtpmap:97 rtx/90000\na=fmtp:97 apt=96\na=ssrc-group:FID 1701050765 2578535262\na=ssrc:1701050765 cname:stream-id\na=ssrc:1701050765 msid:stream-id track-id\na=ssrc:1701050765 mslabel:stream-id\na=ssrc:1701050765 label:track-id\na=msid:stream-id track-id\na=sendrecv\n`\n\n\tconst offerNoRTX = `v=0\no=- 930222930247584370 1727933945 IN IP4 0.0.0.0\ns=-\nt=0 0\na=msid-semantic:WMS*\na=fingerprint:sha-256 11:3F:1C:8D:D4:1D:8D:E7:E1:3E:AF:38:06:0D:1D:40:22:DC:FE:C9:93:E4:80:D8:0B:17:9F:2E:C1:CA:C8:3D\na=extmap-allow-mixed\na=group:BUNDLE 0 1\nm=audio 9 UDP/TLS/RTP/SAVPF 101\na=mid:0\na=ice-ufrag:yIgpPUMarFReduuM\na=ice-pwd:VmnVaqCByWiOTatFoDBbMGhSFGlsxviz\na=rtcp-mux\na=rtcp-rsize\na=rtpmap:101 opus/90000\na=rtcp-fb:101 transport-cc\na=extmap:4 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01\na=ssrc:3566446228 cname:stream-id\na=ssrc:3566446228 msid:stream-id audio-id\na=ssrc:3566446228 mslabel:stream-id\na=ssrc:3566446228 label:audio-id\na=msid:stream-id audio-id\na=sendrecv\nm=video 9 UDP/TLS/RTP/SAVPF 96\nc=IN IP4 0.0.0.0\na=setup:actpass\na=mid:1\na=ice-ufrag:yIgpPUMarFReduuM\na=ice-pwd:VmnVaqCByWiOTatFoDBbMGhSFGlsxviz\na=rtpmap:96 VP8/90000\na=rtcp-fb:96 nack\na=rtcp-fb:96 nack pli\na=rtcp-fb:96 transport-cc\na=ssrc-group:FID 1701050765 2578535262\na=ssrc:1701050765 cname:stream-id\na=ssrc:1701050765 msid:stream-id track-id\na=ssrc:1701050765 mslabel:stream-id\na=ssrc:1701050765 label:track-id\na=msid:stream-id track-id\na=sendrecv\n`\n\tdefer test.CheckRoutines(t)()\n\n\tfor _, testCase := range []struct {\n\t\tname                   string\n\t\tenableRTXInMediaEngine bool\n\t\trtxExpected            bool\n\t\tremoteOffer            string\n\t}{\n\t\t{\"Offer\", true, true, \"\"},\n\t\t{\"Offer no Local Groups\", false, false, \"\"},\n\t\t{\"Answer\", true, true, offerWithRTX},\n\t\t{\"Answer No Local Groups\", false, false, offerWithRTX},\n\t\t{\"Answer No Remote Groups\", true, false, offerNoRTX},\n\t} {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tcheckRTXSupport := func(s *sdp.SessionDescription) {\n\t\t\t\t// RTX is never enabled for audio\n\t\t\t\tassert.Nil(t, trackDetailsFromSDP(nil, s)[0].repairSsrc)\n\n\t\t\t\t// RTX is conditionally enabled for video\n\t\t\t\tif testCase.rtxExpected {\n\t\t\t\t\tassert.NotNil(t, trackDetailsFromSDP(nil, s)[1].repairSsrc)\n\t\t\t\t} else {\n\t\t\t\t\tassert.Nil(t, trackDetailsFromSDP(nil, s)[1].repairSsrc)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tm := &MediaEngine{}\n\t\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeOpus, ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\t\t\tPayloadType:        101,\n\t\t\t}, RTPCodecTypeAudio))\n\t\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\t\t\tPayloadType:        96,\n\t\t\t}, RTPCodecTypeVideo))\n\t\t\tif testCase.enableRTXInMediaEngine {\n\t\t\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: MimeTypeRTX, ClockRate: 90000, Channels: 0, SDPFmtpLine: \"apt=96\", RTCPFeedback: nil},\n\t\t\t\t\tPayloadType:        97,\n\t\t\t\t}, RTPCodecTypeVideo))\n\t\t\t}\n\n\t\t\tpeerConnection, err := NewAPI(WithMediaEngine(m)).NewPeerConnection(Configuration{})\n\t\t\tassert.NoError(t, err)\n\n\t\t\taudioTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"audio-id\", \"stream-id\")\n\t\t\tassert.NoError(t, err)\n\n\t\t\t_, err = peerConnection.AddTrack(audioTrack)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tvideoTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video-id\", \"stream-id\")\n\t\t\tassert.NoError(t, err)\n\n\t\t\t_, err = peerConnection.AddTrack(videoTrack)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tif testCase.remoteOffer == \"\" {\n\t\t\t\toffer, err := peerConnection.CreateOffer(nil)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tcheckRTXSupport(offer.parsed)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, peerConnection.SetRemoteDescription(SessionDescription{Type: SDPTypeOffer, SDP: testCase.remoteOffer}))\n\t\t\t\tanswer, err := peerConnection.CreateAnswer(nil)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tcheckRTXSupport(answer.parsed)\n\t\t\t}\n\n\t\t\tassert.NoError(t, peerConnection.Close())\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "sdpsemantics.go",
          "type": "blob",
          "size": 1.9111328125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n)\n\n// SDPSemantics determines which style of SDP offers and answers\n// can be used\ntype SDPSemantics int\n\nconst (\n\t// SDPSemanticsUnifiedPlan uses unified-plan offers and answers\n\t// (the default in Chrome since M72)\n\t// https://tools.ietf.org/html/draft-roach-mmusic-unified-plan-00\n\tSDPSemanticsUnifiedPlan SDPSemantics = iota\n\n\t// SDPSemanticsPlanB uses plan-b offers and answers\n\t// NB: This format should be considered deprecated\n\t// https://tools.ietf.org/html/draft-uberti-rtcweb-plan-00\n\tSDPSemanticsPlanB\n\n\t// SDPSemanticsUnifiedPlanWithFallback prefers unified-plan\n\t// offers and answers, but will respond to a plan-b offer\n\t// with a plan-b answer\n\tSDPSemanticsUnifiedPlanWithFallback\n)\n\nconst (\n\tsdpSemanticsUnifiedPlanWithFallback = \"unified-plan-with-fallback\"\n\tsdpSemanticsUnifiedPlan             = \"unified-plan\"\n\tsdpSemanticsPlanB                   = \"plan-b\"\n)\n\nfunc newSDPSemantics(raw string) SDPSemantics {\n\tswitch raw {\n\tcase sdpSemanticsPlanB:\n\t\treturn SDPSemanticsPlanB\n\tcase sdpSemanticsUnifiedPlanWithFallback:\n\t\treturn SDPSemanticsUnifiedPlanWithFallback\n\tdefault:\n\t\treturn SDPSemanticsUnifiedPlan\n\t}\n}\n\nfunc (s SDPSemantics) String() string {\n\tswitch s {\n\tcase SDPSemanticsUnifiedPlanWithFallback:\n\t\treturn sdpSemanticsUnifiedPlanWithFallback\n\tcase SDPSemanticsUnifiedPlan:\n\t\treturn sdpSemanticsUnifiedPlan\n\tcase SDPSemanticsPlanB:\n\t\treturn sdpSemanticsPlanB\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// UnmarshalJSON parses the JSON-encoded data and stores the result\nfunc (s *SDPSemantics) UnmarshalJSON(b []byte) error {\n\tvar val string\n\tif err := json.Unmarshal(b, &val); err != nil {\n\t\treturn err\n\t}\n\n\t*s = newSDPSemantics(val)\n\treturn nil\n}\n\n// MarshalJSON returns the JSON encoding\nfunc (s SDPSemantics) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(s.String())\n}\n"
        },
        {
          "name": "sdpsemantics_test.go",
          "type": "blob",
          "size": 11.4306640625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/sdp/v3\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSDPSemantics_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tvalue          SDPSemantics\n\t\texpectedString string\n\t}{\n\t\t{SDPSemanticsUnifiedPlanWithFallback, \"unified-plan-with-fallback\"},\n\t\t{SDPSemanticsPlanB, \"plan-b\"},\n\t\t{SDPSemanticsUnifiedPlan, \"unified-plan\"},\n\t}\n\n\tassert.Equal(t,\n\t\tErrUnknownType.Error(),\n\t\tSDPSemantics(42).String(),\n\t)\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.value.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t\tassert.Equal(t,\n\t\t\ttestCase.value,\n\t\t\tnewSDPSemantics(testCase.expectedString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestSDPSemantics_JSON(t *testing.T) {\n\ttestCases := []struct {\n\t\tvalue SDPSemantics\n\t\tJSON  []byte\n\t}{\n\t\t{SDPSemanticsUnifiedPlanWithFallback, []byte(\"\\\"unified-plan-with-fallback\\\"\")},\n\t\t{SDPSemanticsPlanB, []byte(\"\\\"plan-b\\\"\")},\n\t\t{SDPSemanticsUnifiedPlan, []byte(\"\\\"unified-plan\\\"\")},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tres, err := json.Marshal(testCase.value)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t,\n\t\t\ttestCase.JSON,\n\t\t\tres,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\n\t\tvar v SDPSemantics\n\t\terr = json.Unmarshal(testCase.JSON, &v)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, v, testCase.value)\n\t}\n}\n\n// The following tests are for non-standard SDP semantics\n// (i.e. not unified-unified)\n\nfunc getMdNames(sdp *sdp.SessionDescription) []string {\n\tmdNames := make([]string, 0, len(sdp.MediaDescriptions))\n\tfor _, media := range sdp.MediaDescriptions {\n\t\tmdNames = append(mdNames, media.MediaName.Media)\n\t}\n\treturn mdNames\n}\n\nfunc extractSsrcList(md *sdp.MediaDescription) []string {\n\tssrcMap := map[string]struct{}{}\n\tfor _, attr := range md.Attributes {\n\t\tif attr.Key == sdp.AttrKeySSRC {\n\t\t\tssrc := strings.Fields(attr.Value)[0]\n\t\t\tssrcMap[ssrc] = struct{}{}\n\t\t}\n\t}\n\tssrcList := make([]string, 0, len(ssrcMap))\n\tfor ssrc := range ssrcMap {\n\t\tssrcList = append(ssrcList, ssrc)\n\t}\n\treturn ssrcList\n}\n\nfunc TestSDPSemantics_PlanBOfferTransceivers(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\topc, err := NewPeerConnection(Configuration{\n\t\tSDPSemantics: SDPSemanticsPlanB,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendrecv,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendrecv,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeAudio, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendrecv,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeAudio, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionSendrecv,\n\t})\n\tassert.NoError(t, err)\n\n\toffer, err := opc.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tmdNames := getMdNames(offer.parsed)\n\tassert.ObjectsAreEqual(mdNames, []string{\"video\", \"audio\", \"data\"})\n\n\t// Verify that each section has 2 SSRCs (one for each transceiver)\n\tfor _, section := range []string{\"video\", \"audio\"} {\n\t\tfor _, media := range offer.parsed.MediaDescriptions {\n\t\t\tif media.MediaName.Media == section {\n\t\t\t\tassert.Len(t, extractSsrcList(media), 2)\n\t\t\t}\n\t\t}\n\t}\n\n\tapc, err := NewPeerConnection(Configuration{\n\t\tSDPSemantics: SDPSemanticsPlanB,\n\t})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, apc.SetRemoteDescription(offer))\n\n\tanswer, err := apc.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tmdNames = getMdNames(answer.parsed)\n\tassert.ObjectsAreEqual(mdNames, []string{\"video\", \"audio\", \"data\"})\n\n\tclosePairNow(t, apc, opc)\n}\n\nfunc TestSDPSemantics_PlanBAnswerSenders(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\topc, err := NewPeerConnection(Configuration{\n\t\tSDPSemantics: SDPSemanticsPlanB,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeAudio, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tassert.NoError(t, err)\n\n\toffer, err := opc.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.ObjectsAreEqual(getMdNames(offer.parsed), []string{\"video\", \"audio\", \"data\"})\n\n\tapc, err := NewPeerConnection(Configuration{\n\t\tSDPSemantics: SDPSemanticsPlanB,\n\t})\n\tassert.NoError(t, err)\n\n\tvideo1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeH264, SDPFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\"}, \"1\", \"1\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(video1)\n\tassert.NoError(t, err)\n\n\tvideo2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeH264, SDPFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\"}, \"2\", \"2\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(video2)\n\tassert.NoError(t, err)\n\n\taudio1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"3\", \"3\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(audio1)\n\tassert.NoError(t, err)\n\n\taudio2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"4\", \"4\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(audio2)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, apc.SetRemoteDescription(offer))\n\n\tanswer, err := apc.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.ObjectsAreEqual(getMdNames(answer.parsed), []string{\"video\", \"audio\", \"data\"})\n\n\t// Verify that each section has 2 SSRCs (one for each sender)\n\tfor _, section := range []string{\"video\", \"audio\"} {\n\t\tfor _, media := range answer.parsed.MediaDescriptions {\n\t\t\tif media.MediaName.Media == section {\n\t\t\t\tassert.Lenf(t, extractSsrcList(media), 2, \"%q should have 2 SSRCs in Plan-B mode\", section)\n\t\t\t}\n\t\t}\n\t}\n\n\tclosePairNow(t, apc, opc)\n}\n\nfunc TestSDPSemantics_UnifiedPlanWithFallback(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\topc, err := NewPeerConnection(Configuration{\n\t\tSDPSemantics: SDPSemanticsPlanB,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeVideo, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tassert.NoError(t, err)\n\n\t_, err = opc.AddTransceiverFromKind(RTPCodecTypeAudio, RTPTransceiverInit{\n\t\tDirection: RTPTransceiverDirectionRecvonly,\n\t})\n\tassert.NoError(t, err)\n\n\toffer, err := opc.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.ObjectsAreEqual(getMdNames(offer.parsed), []string{\"video\", \"audio\", \"data\"})\n\n\tapc, err := NewPeerConnection(Configuration{\n\t\tSDPSemantics: SDPSemanticsUnifiedPlanWithFallback,\n\t})\n\tassert.NoError(t, err)\n\n\tvideo1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeH264, SDPFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\"}, \"1\", \"1\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(video1)\n\tassert.NoError(t, err)\n\n\tvideo2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeH264, SDPFmtpLine: \"level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f\"}, \"2\", \"2\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(video2)\n\tassert.NoError(t, err)\n\n\taudio1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"3\", \"3\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(audio1)\n\tassert.NoError(t, err)\n\n\taudio2, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeOpus}, \"4\", \"4\")\n\tassert.NoError(t, err)\n\n\t_, err = apc.AddTrack(audio2)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, apc.SetRemoteDescription(offer))\n\n\tanswer, err := apc.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\n\tassert.ObjectsAreEqual(getMdNames(answer.parsed), []string{\"video\", \"audio\", \"data\"})\n\n\textractSsrcList := func(md *sdp.MediaDescription) []string {\n\t\tssrcMap := map[string]struct{}{}\n\t\tfor _, attr := range md.Attributes {\n\t\t\tif attr.Key == sdp.AttrKeySSRC {\n\t\t\t\tssrc := strings.Fields(attr.Value)[0]\n\t\t\t\tssrcMap[ssrc] = struct{}{}\n\t\t\t}\n\t\t}\n\t\tssrcList := make([]string, 0, len(ssrcMap))\n\t\tfor ssrc := range ssrcMap {\n\t\t\tssrcList = append(ssrcList, ssrc)\n\t\t}\n\t\treturn ssrcList\n\t}\n\t// Verify that each section has 2 SSRCs (one for each sender)\n\tfor _, section := range []string{\"video\", \"audio\"} {\n\t\tfor _, media := range answer.parsed.MediaDescriptions {\n\t\t\tif media.MediaName.Media == section {\n\t\t\t\tassert.Lenf(t, extractSsrcList(media), 2, \"%q should have 2 SSRCs in Plan-B fallback mode\", section)\n\t\t\t}\n\t\t}\n\t}\n\n\tclosePairNow(t, apc, opc)\n}\n\n// Assert that we can catch Remote SessionDescription that don't match our Semantics\nfunc TestSDPSemantics_SetRemoteDescription_Mismatch(t *testing.T) {\n\tplanBOffer := \"v=0\\r\\no=- 4648475892259889561 3 IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\na=group:BUNDLE video audio\\r\\na=ice-ufrag:1hhfzwf0ijpzm\\r\\na=ice-pwd:jm5puo2ab1op3vs59ca53bdk7s\\r\\na=fingerprint:sha-256 40:42:FB:47:87:52:BF:CB:EC:3A:DF:EB:06:DA:2D:B7:2F:59:42:10:23:7B:9D:4C:C9:58:DD:FF:A2:8F:17:67\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 96\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=setup:passive\\r\\na=mid:video\\r\\na=sendonly\\r\\na=rtcp-mux\\r\\na=rtpmap:96 H264/90000\\r\\na=rtcp-fb:96 nack\\r\\na=rtcp-fb:96 goog-remb\\r\\na=fmtp:96 packetization-mode=1;profile-level-id=42e01f\\r\\na=ssrc:1505338584 cname:10000000b5810aac\\r\\na=ssrc:1 cname:trackB\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=setup:passive\\r\\na=mid:audio\\r\\na=sendonly\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\na=ssrc:697641945 cname:10000000b5810aac\\r\\n\"\n\tunifiedPlanOffer := \"v=0\\r\\no=- 4648475892259889561 3 IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\na=group:BUNDLE 0 1\\r\\na=ice-ufrag:1hhfzwf0ijpzm\\r\\na=ice-pwd:jm5puo2ab1op3vs59ca53bdk7s\\r\\na=fingerprint:sha-256 40:42:FB:47:87:52:BF:CB:EC:3A:DF:EB:06:DA:2D:B7:2F:59:42:10:23:7B:9D:4C:C9:58:DD:FF:A2:8F:17:67\\r\\nm=video 9 UDP/TLS/RTP/SAVPF 96\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=setup:passive\\r\\na=mid:0\\r\\na=sendonly\\r\\na=rtcp-mux\\r\\na=rtpmap:96 H264/90000\\r\\na=rtcp-fb:96 nack\\r\\na=rtcp-fb:96 goog-remb\\r\\na=fmtp:96 packetization-mode=1;profile-level-id=42e01f\\r\\na=ssrc:1505338584 cname:10000000b5810aac\\r\\nm=audio 9 UDP/TLS/RTP/SAVPF 111\\r\\nc=IN IP4 0.0.0.0\\r\\na=rtcp:9 IN IP4 0.0.0.0\\r\\na=setup:passive\\r\\na=mid:1\\r\\na=sendonly\\r\\na=rtcp-mux\\r\\na=rtpmap:111 opus/48000/2\\r\\na=ssrc:697641945 cname:10000000b5810aac\\r\\n\"\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\tt.Run(\"PlanB\", func(t *testing.T) {\n\t\tpc, err := NewPeerConnection(Configuration{\n\t\t\tSDPSemantics: SDPSemanticsUnifiedPlan,\n\t\t})\n\t\tassert.NoError(t, err)\n\n\t\terr = pc.SetRemoteDescription(SessionDescription{SDP: planBOffer, Type: SDPTypeOffer})\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pc.CreateAnswer(nil)\n\t\tassert.True(t, errors.Is(err, ErrIncorrectSDPSemantics))\n\n\t\tassert.NoError(t, pc.Close())\n\t})\n\n\tt.Run(\"UnifiedPlan\", func(t *testing.T) {\n\t\tpc, err := NewPeerConnection(Configuration{\n\t\t\tSDPSemantics: SDPSemanticsPlanB,\n\t\t})\n\t\tassert.NoError(t, err)\n\n\t\terr = pc.SetRemoteDescription(SessionDescription{SDP: unifiedPlanOffer, Type: SDPTypeOffer})\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pc.CreateAnswer(nil)\n\t\tassert.True(t, errors.Is(err, ErrIncorrectSDPSemantics))\n\n\t\tassert.NoError(t, pc.Close())\n\t})\n}\n"
        },
        {
          "name": "sdptype.go",
          "type": "blob",
          "size": 2.66015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n)\n\n// SDPType describes the type of an SessionDescription.\ntype SDPType int\n\nconst (\n\t// SDPTypeUnknown is the enum's zero-value\n\tSDPTypeUnknown SDPType = iota\n\n\t// SDPTypeOffer indicates that a description MUST be treated as an SDP offer.\n\tSDPTypeOffer\n\n\t// SDPTypePranswer indicates that a description MUST be treated as an\n\t// SDP answer, but not a final answer. A description used as an SDP\n\t// pranswer may be applied as a response to an SDP offer, or an update to\n\t// a previously sent SDP pranswer.\n\tSDPTypePranswer\n\n\t// SDPTypeAnswer indicates that a description MUST be treated as an SDP\n\t// final answer, and the offer-answer exchange MUST be considered complete.\n\t// A description used as an SDP answer may be applied as a response to an\n\t// SDP offer or as an update to a previously sent SDP pranswer.\n\tSDPTypeAnswer\n\n\t// SDPTypeRollback indicates that a description MUST be treated as\n\t// canceling the current SDP negotiation and moving the SDP offer and\n\t// answer back to what it was in the previous stable state. Note the\n\t// local or remote SDP descriptions in the previous stable state could be\n\t// null if there has not yet been a successful offer-answer negotiation.\n\tSDPTypeRollback\n)\n\n// This is done this way because of a linter.\nconst (\n\tsdpTypeOfferStr    = \"offer\"\n\tsdpTypePranswerStr = \"pranswer\"\n\tsdpTypeAnswerStr   = \"answer\"\n\tsdpTypeRollbackStr = \"rollback\"\n)\n\n// NewSDPType creates an SDPType from a string\nfunc NewSDPType(raw string) SDPType {\n\tswitch raw {\n\tcase sdpTypeOfferStr:\n\t\treturn SDPTypeOffer\n\tcase sdpTypePranswerStr:\n\t\treturn SDPTypePranswer\n\tcase sdpTypeAnswerStr:\n\t\treturn SDPTypeAnswer\n\tcase sdpTypeRollbackStr:\n\t\treturn SDPTypeRollback\n\tdefault:\n\t\treturn SDPTypeUnknown\n\t}\n}\n\nfunc (t SDPType) String() string {\n\tswitch t {\n\tcase SDPTypeOffer:\n\t\treturn sdpTypeOfferStr\n\tcase SDPTypePranswer:\n\t\treturn sdpTypePranswerStr\n\tcase SDPTypeAnswer:\n\t\treturn sdpTypeAnswerStr\n\tcase SDPTypeRollback:\n\t\treturn sdpTypeRollbackStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// MarshalJSON enables JSON marshaling of a SDPType\nfunc (t SDPType) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(t.String())\n}\n\n// UnmarshalJSON enables JSON unmarshaling of a SDPType\nfunc (t *SDPType) UnmarshalJSON(b []byte) error {\n\tvar s string\n\tif err := json.Unmarshal(b, &s); err != nil {\n\t\treturn err\n\t}\n\tswitch strings.ToLower(s) {\n\tdefault:\n\t\treturn ErrUnknownType\n\tcase \"offer\":\n\t\t*t = SDPTypeOffer\n\tcase \"pranswer\":\n\t\t*t = SDPTypePranswer\n\tcase \"answer\":\n\t\t*t = SDPTypeAnswer\n\tcase \"rollback\":\n\t\t*t = SDPTypeRollback\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "sdptype_test.go",
          "type": "blob",
          "size": 1.0556640625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewSDPType(t *testing.T) {\n\ttestCases := []struct {\n\t\tsdpTypeString   string\n\t\texpectedSDPType SDPType\n\t}{\n\t\t{ErrUnknownType.Error(), SDPTypeUnknown},\n\t\t{\"offer\", SDPTypeOffer},\n\t\t{\"pranswer\", SDPTypePranswer},\n\t\t{\"answer\", SDPTypeAnswer},\n\t\t{\"rollback\", SDPTypeRollback},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedSDPType,\n\t\t\tNewSDPType(testCase.sdpTypeString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestSDPType_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tsdpType        SDPType\n\t\texpectedString string\n\t}{\n\t\t{SDPTypeUnknown, ErrUnknownType.Error()},\n\t\t{SDPTypeOffer, \"offer\"},\n\t\t{SDPTypePranswer, \"pranswer\"},\n\t\t{SDPTypeAnswer, \"answer\"},\n\t\t{SDPTypeRollback, \"rollback\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.sdpType.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "sessiondescription.go",
          "type": "blob",
          "size": 0.6396484375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"github.com/pion/sdp/v3\"\n)\n\n// SessionDescription is used to expose local and remote session descriptions.\ntype SessionDescription struct {\n\tType SDPType `json:\"type\"`\n\tSDP  string  `json:\"sdp\"`\n\n\t// This will never be initialized by callers, internal use only\n\tparsed *sdp.SessionDescription\n}\n\n// Unmarshal is a helper to deserialize the sdp\nfunc (sd *SessionDescription) Unmarshal() (*sdp.SessionDescription, error) {\n\tsd.parsed = &sdp.SessionDescription{}\n\terr := sd.parsed.UnmarshalString(sd.SDP)\n\treturn sd.parsed, err\n}\n"
        },
        {
          "name": "sessiondescription_test.go",
          "type": "blob",
          "size": 2.15234375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSessionDescription_JSON(t *testing.T) {\n\ttestCases := []struct {\n\t\tdesc           SessionDescription\n\t\texpectedString string\n\t\tunmarshalErr   error\n\t}{\n\t\t{SessionDescription{Type: SDPTypeOffer, SDP: \"sdp\"}, `{\"type\":\"offer\",\"sdp\":\"sdp\"}`, nil},\n\t\t{SessionDescription{Type: SDPTypePranswer, SDP: \"sdp\"}, `{\"type\":\"pranswer\",\"sdp\":\"sdp\"}`, nil},\n\t\t{SessionDescription{Type: SDPTypeAnswer, SDP: \"sdp\"}, `{\"type\":\"answer\",\"sdp\":\"sdp\"}`, nil},\n\t\t{SessionDescription{Type: SDPTypeRollback, SDP: \"sdp\"}, `{\"type\":\"rollback\",\"sdp\":\"sdp\"}`, nil},\n\t\t{SessionDescription{Type: SDPTypeUnknown, SDP: \"sdp\"}, `{\"type\":\"unknown\",\"sdp\":\"sdp\"}`, ErrUnknownType},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tdescData, err := json.Marshal(testCase.desc)\n\t\tassert.Nil(t,\n\t\t\terr,\n\t\t\t\"testCase: %d %v marshal err: %v\", i, testCase, err,\n\t\t)\n\n\t\tassert.Equal(t,\n\t\t\tstring(descData),\n\t\t\ttestCase.expectedString,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\n\t\tvar desc SessionDescription\n\t\terr = json.Unmarshal(descData, &desc)\n\n\t\tif testCase.unmarshalErr != nil {\n\t\t\tassert.Equal(t,\n\t\t\t\terr,\n\t\t\t\ttestCase.unmarshalErr,\n\t\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t\t)\n\t\t\tcontinue\n\t\t}\n\n\t\tassert.Nil(t,\n\t\t\terr,\n\t\t\t\"testCase: %d %v unmarshal err: %v\", i, testCase, err,\n\t\t)\n\n\t\tassert.Equal(t,\n\t\t\tdesc,\n\t\t\ttestCase.desc,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestSessionDescription_Unmarshal(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\toffer, err := pc.CreateOffer(nil)\n\tassert.NoError(t, err)\n\tdesc := SessionDescription{\n\t\tType: offer.Type,\n\t\tSDP:  offer.SDP,\n\t}\n\tassert.Nil(t, desc.parsed)\n\tparsed1, err := desc.Unmarshal()\n\tassert.NotNil(t, parsed1)\n\tassert.NotNil(t, desc.parsed)\n\tassert.NoError(t, err)\n\tparsed2, err2 := desc.Unmarshal()\n\tassert.NotNil(t, parsed2)\n\tassert.NoError(t, err2)\n\tassert.NoError(t, pc.Close())\n\n\t// check if the two parsed results _really_ match, could be affected by internal caching\n\tassert.True(t, reflect.DeepEqual(parsed1, parsed2))\n}\n"
        },
        {
          "name": "settingengine.go",
          "type": "blob",
          "size": 20.9560546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"crypto/x509\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/pion/dtls/v3\"\n\tdtlsElliptic \"github.com/pion/dtls/v3/pkg/crypto/elliptic\"\n\t\"github.com/pion/dtls/v3/pkg/protocol/handshake\"\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/stun/v3\"\n\t\"github.com/pion/transport/v3\"\n\t\"github.com/pion/transport/v3/packetio\"\n\t\"golang.org/x/net/proxy\"\n)\n\n// SettingEngine allows influencing behavior in ways that are not\n// supported by the WebRTC API. This allows us to support additional\n// use-cases without deviating from the WebRTC API elsewhere.\ntype SettingEngine struct {\n\tephemeralUDP struct {\n\t\tPortMin uint16\n\t\tPortMax uint16\n\t}\n\tdetach struct {\n\t\tDataChannels bool\n\t}\n\ttimeout struct {\n\t\tICEDisconnectedTimeout    *time.Duration\n\t\tICEFailedTimeout          *time.Duration\n\t\tICEKeepaliveInterval      *time.Duration\n\t\tICEHostAcceptanceMinWait  *time.Duration\n\t\tICESrflxAcceptanceMinWait *time.Duration\n\t\tICEPrflxAcceptanceMinWait *time.Duration\n\t\tICERelayAcceptanceMinWait *time.Duration\n\t\tICESTUNGatherTimeout      *time.Duration\n\t}\n\tcandidates struct {\n\t\tICELite                  bool\n\t\tICENetworkTypes          []NetworkType\n\t\tInterfaceFilter          func(string) (keep bool)\n\t\tIPFilter                 func(net.IP) (keep bool)\n\t\tNAT1To1IPs               []string\n\t\tNAT1To1IPCandidateType   ICECandidateType\n\t\tMulticastDNSMode         ice.MulticastDNSMode\n\t\tMulticastDNSHostName     string\n\t\tUsernameFragment         string\n\t\tPassword                 string\n\t\tIncludeLoopbackCandidate bool\n\t}\n\treplayProtection struct {\n\t\tDTLS  *uint\n\t\tSRTP  *uint\n\t\tSRTCP *uint\n\t}\n\tdtls struct {\n\t\tinsecureSkipHelloVerify       bool\n\t\tdisableInsecureSkipVerify     bool\n\t\tretransmissionInterval        time.Duration\n\t\tellipticCurves                []dtlsElliptic.Curve\n\t\tconnectContextMaker           func() (context.Context, func())\n\t\textendedMasterSecret          dtls.ExtendedMasterSecretType\n\t\tclientAuth                    *dtls.ClientAuthType\n\t\tclientCAs                     *x509.CertPool\n\t\trootCAs                       *x509.CertPool\n\t\tkeyLogWriter                  io.Writer\n\t\tcustomCipherSuites            func() []dtls.CipherSuite\n\t\tclientHelloMessageHook        func(handshake.MessageClientHello) handshake.Message\n\t\tserverHelloMessageHook        func(handshake.MessageServerHello) handshake.Message\n\t\tcertificateRequestMessageHook func(handshake.MessageCertificateRequest) handshake.Message\n\t}\n\tsctp struct {\n\t\tmaxReceiveBufferSize uint32\n\t\tenableZeroChecksum   bool\n\t\trtoMax               time.Duration\n\t}\n\tsdpMediaLevelFingerprints                 bool\n\tansweringDTLSRole                         DTLSRole\n\tdisableCertificateFingerprintVerification bool\n\tdisableSRTPReplayProtection               bool\n\tdisableSRTCPReplayProtection              bool\n\tnet                                       transport.Net\n\tBufferFactory                             func(packetType packetio.BufferPacketType, ssrc uint32) io.ReadWriteCloser\n\tLoggerFactory                             logging.LoggerFactory\n\ticeTCPMux                                 ice.TCPMux\n\ticeUDPMux                                 ice.UDPMux\n\ticeProxyDialer                            proxy.Dialer\n\ticeDisableActiveTCP                       bool\n\ticeBindingRequestHandler                  func(m *stun.Message, local, remote ice.Candidate, pair *ice.CandidatePair) bool\n\tdisableMediaEngineCopy                    bool\n\tsrtpProtectionProfiles                    []dtls.SRTPProtectionProfile\n\treceiveMTU                                uint\n\ticeMaxBindingRequests                     *uint16\n\tfireOnTrackBeforeFirstRTP                 bool\n\tdisableCloseByDTLS                        bool\n\tdataChannelBlockWrite                     bool\n}\n\n// getReceiveMTU returns the configured MTU. If SettingEngine's MTU is configured to 0 it returns the default\nfunc (e *SettingEngine) getReceiveMTU() uint {\n\tif e.receiveMTU != 0 {\n\t\treturn e.receiveMTU\n\t}\n\n\treturn receiveMTU\n}\n\n// DetachDataChannels enables detaching data channels. When enabled\n// data channels have to be detached in the OnOpen callback using the\n// DataChannel.Detach method.\nfunc (e *SettingEngine) DetachDataChannels() {\n\te.detach.DataChannels = true\n}\n\n// EnableDataChannelBlockWrite allows data channels to block on write,\n// it only works if DetachDataChannels is enabled\nfunc (e *SettingEngine) EnableDataChannelBlockWrite(nonblockWrite bool) {\n\te.dataChannelBlockWrite = nonblockWrite\n}\n\n// SetSRTPProtectionProfiles allows the user to override the default SRTP Protection Profiles\n// The default srtp protection profiles are provided by the function `defaultSrtpProtectionProfiles`\nfunc (e *SettingEngine) SetSRTPProtectionProfiles(profiles ...dtls.SRTPProtectionProfile) {\n\te.srtpProtectionProfiles = profiles\n}\n\n// SetICETimeouts sets the behavior around ICE Timeouts\n//\n// disconnectedTimeout:\n//\n//\tDuration without network activity before an Agent is considered disconnected. Default is 5 Seconds\n//\n// failedTimeout:\n//\n//\tDuration without network activity before an Agent is considered failed after disconnected. Default is 25 Seconds\n//\n// keepAliveInterval:\n//\n//\tHow often the ICE Agent sends extra traffic if there is no activity, if media is flowing no traffic will be sent. Default is 2 seconds\nfunc (e *SettingEngine) SetICETimeouts(disconnectedTimeout, failedTimeout, keepAliveInterval time.Duration) {\n\te.timeout.ICEDisconnectedTimeout = &disconnectedTimeout\n\te.timeout.ICEFailedTimeout = &failedTimeout\n\te.timeout.ICEKeepaliveInterval = &keepAliveInterval\n}\n\n// SetHostAcceptanceMinWait sets the ICEHostAcceptanceMinWait\nfunc (e *SettingEngine) SetHostAcceptanceMinWait(t time.Duration) {\n\te.timeout.ICEHostAcceptanceMinWait = &t\n}\n\n// SetSrflxAcceptanceMinWait sets the ICESrflxAcceptanceMinWait\nfunc (e *SettingEngine) SetSrflxAcceptanceMinWait(t time.Duration) {\n\te.timeout.ICESrflxAcceptanceMinWait = &t\n}\n\n// SetPrflxAcceptanceMinWait sets the ICEPrflxAcceptanceMinWait\nfunc (e *SettingEngine) SetPrflxAcceptanceMinWait(t time.Duration) {\n\te.timeout.ICEPrflxAcceptanceMinWait = &t\n}\n\n// SetRelayAcceptanceMinWait sets the ICERelayAcceptanceMinWait\nfunc (e *SettingEngine) SetRelayAcceptanceMinWait(t time.Duration) {\n\te.timeout.ICERelayAcceptanceMinWait = &t\n}\n\n// SetSTUNGatherTimeout sets the ICESTUNGatherTimeout\nfunc (e *SettingEngine) SetSTUNGatherTimeout(t time.Duration) {\n\te.timeout.ICESTUNGatherTimeout = &t\n}\n\n// SetEphemeralUDPPortRange limits the pool of ephemeral ports that\n// ICE UDP connections can allocate from. This affects both host candidates,\n// and the local address of server reflexive candidates.\n//\n// When portMin and portMax are left to the 0 default value, pion/ice candidate\n// gatherer replaces them and uses 1 for portMin and 65535 for portMax.\nfunc (e *SettingEngine) SetEphemeralUDPPortRange(portMin, portMax uint16) error {\n\tif portMax < portMin {\n\t\treturn ice.ErrPort\n\t}\n\n\te.ephemeralUDP.PortMin = portMin\n\te.ephemeralUDP.PortMax = portMax\n\treturn nil\n}\n\n// SetLite configures whether or not the ice agent should be a lite agent\nfunc (e *SettingEngine) SetLite(lite bool) {\n\te.candidates.ICELite = lite\n}\n\n// SetNetworkTypes configures what types of candidate networks are supported\n// during local and server reflexive gathering.\nfunc (e *SettingEngine) SetNetworkTypes(candidateTypes []NetworkType) {\n\te.candidates.ICENetworkTypes = candidateTypes\n}\n\n// SetInterfaceFilter sets the filtering functions when gathering ICE candidates\n// This can be used to exclude certain network interfaces from ICE. Which may be\n// useful if you know a certain interface will never succeed, or if you wish to reduce\n// the amount of information you wish to expose to the remote peer\nfunc (e *SettingEngine) SetInterfaceFilter(filter func(string) (keep bool)) {\n\te.candidates.InterfaceFilter = filter\n}\n\n// SetIPFilter sets the filtering functions when gathering ICE candidates\n// This can be used to exclude certain ip from ICE. Which may be\n// useful if you know a certain ip will never succeed, or if you wish to reduce\n// the amount of information you wish to expose to the remote peer\nfunc (e *SettingEngine) SetIPFilter(filter func(net.IP) (keep bool)) {\n\te.candidates.IPFilter = filter\n}\n\n// SetNAT1To1IPs sets a list of external IP addresses of 1:1 (D)NAT\n// and a candidate type for which the external IP address is used.\n// This is useful when you host a server using Pion on an AWS EC2 instance\n// which has a private address, behind a 1:1 DNAT with a public IP (e.g.\n// Elastic IP). In this case, you can give the public IP address so that\n// Pion will use the public IP address in its candidate instead of the private\n// IP address. The second argument, candidateType, is used to tell Pion which\n// type of candidate should use the given public IP address.\n// Two types of candidates are supported:\n//\n// ICECandidateTypeHost:\n//\n//\tThe public IP address will be used for the host candidate in the SDP.\n//\n// ICECandidateTypeSrflx:\n//\n//\tA server reflexive candidate with the given public IP address will be added to the SDP.\n//\n// Please note that if you choose ICECandidateTypeHost, then the private IP address\n// won't be advertised with the peer. Also, this option cannot be used along with mDNS.\n//\n// If you choose ICECandidateTypeSrflx, it simply adds a server reflexive candidate\n// with the public IP. The host candidate is still available along with mDNS\n// capabilities unaffected. Also, you cannot give STUN server URL at the same time.\n// It will result in an error otherwise.\nfunc (e *SettingEngine) SetNAT1To1IPs(ips []string, candidateType ICECandidateType) {\n\te.candidates.NAT1To1IPs = ips\n\te.candidates.NAT1To1IPCandidateType = candidateType\n}\n\n// SetIncludeLoopbackCandidate enable pion to gather loopback candidates, it is useful\n// for some VM have public IP mapped to loopback interface\nfunc (e *SettingEngine) SetIncludeLoopbackCandidate(include bool) {\n\te.candidates.IncludeLoopbackCandidate = include\n}\n\n// SetAnsweringDTLSRole sets the DTLS role that is selected when offering\n// The DTLS role controls if the WebRTC Client as a client or server. This\n// may be useful when interacting with non-compliant clients or debugging issues.\n//\n// DTLSRoleActive:\n//\n//\tAct as DTLS Client, send the ClientHello and starts the handshake\n//\n// DTLSRolePassive:\n//\n//\tAct as DTLS Server, wait for ClientHello\nfunc (e *SettingEngine) SetAnsweringDTLSRole(role DTLSRole) error {\n\tif role != DTLSRoleClient && role != DTLSRoleServer {\n\t\treturn errSettingEngineSetAnsweringDTLSRole\n\t}\n\n\te.answeringDTLSRole = role\n\treturn nil\n}\n\n// SetNet sets the Net instance that is passed to pion/ice\n//\n// Net is an network interface layer for Pion, allowing users to replace\n// Pions network stack with a custom implementation.\nfunc (e *SettingEngine) SetNet(net transport.Net) {\n\te.net = net\n}\n\n// SetICEMulticastDNSMode controls if pion/ice queries and generates mDNS ICE Candidates\nfunc (e *SettingEngine) SetICEMulticastDNSMode(multicastDNSMode ice.MulticastDNSMode) {\n\te.candidates.MulticastDNSMode = multicastDNSMode\n}\n\n// SetMulticastDNSHostName sets a static HostName to be used by pion/ice instead of generating one on startup\n//\n// This should only be used for a single PeerConnection. Having multiple PeerConnections with the same HostName will cause\n// undefined behavior\nfunc (e *SettingEngine) SetMulticastDNSHostName(hostName string) {\n\te.candidates.MulticastDNSHostName = hostName\n}\n\n// SetICECredentials sets a staic uFrag/uPwd to be used by pion/ice\n//\n// This is useful if you want to do signalless WebRTC session, or having a reproducible environment with static credentials\nfunc (e *SettingEngine) SetICECredentials(usernameFragment, password string) {\n\te.candidates.UsernameFragment = usernameFragment\n\te.candidates.Password = password\n}\n\n// DisableCertificateFingerprintVerification disables fingerprint verification after DTLS Handshake has finished\nfunc (e *SettingEngine) DisableCertificateFingerprintVerification(isDisabled bool) {\n\te.disableCertificateFingerprintVerification = isDisabled\n}\n\n// SetDTLSReplayProtectionWindow sets a replay attack protection window size of DTLS connection.\nfunc (e *SettingEngine) SetDTLSReplayProtectionWindow(n uint) {\n\te.replayProtection.DTLS = &n\n}\n\n// SetSRTPReplayProtectionWindow sets a replay attack protection window size of SRTP session.\nfunc (e *SettingEngine) SetSRTPReplayProtectionWindow(n uint) {\n\te.disableSRTPReplayProtection = false\n\te.replayProtection.SRTP = &n\n}\n\n// SetSRTCPReplayProtectionWindow sets a replay attack protection window size of SRTCP session.\nfunc (e *SettingEngine) SetSRTCPReplayProtectionWindow(n uint) {\n\te.disableSRTCPReplayProtection = false\n\te.replayProtection.SRTCP = &n\n}\n\n// DisableSRTPReplayProtection disables SRTP replay protection.\nfunc (e *SettingEngine) DisableSRTPReplayProtection(isDisabled bool) {\n\te.disableSRTPReplayProtection = isDisabled\n}\n\n// DisableSRTCPReplayProtection disables SRTCP replay protection.\nfunc (e *SettingEngine) DisableSRTCPReplayProtection(isDisabled bool) {\n\te.disableSRTCPReplayProtection = isDisabled\n}\n\n// SetSDPMediaLevelFingerprints configures the logic for DTLS Fingerprint insertion\n// If true, fingerprints will be inserted in the sdp at the fingerprint\n// level, instead of the session level. This helps with compatibility with\n// some webrtc implementations.\nfunc (e *SettingEngine) SetSDPMediaLevelFingerprints(sdpMediaLevelFingerprints bool) {\n\te.sdpMediaLevelFingerprints = sdpMediaLevelFingerprints\n}\n\n// SetICETCPMux enables ICE-TCP when set to a non-nil value. Make sure that\n// NetworkTypeTCP4 or NetworkTypeTCP6 is enabled as well.\nfunc (e *SettingEngine) SetICETCPMux(tcpMux ice.TCPMux) {\n\te.iceTCPMux = tcpMux\n}\n\n// SetICEUDPMux allows ICE traffic to come through a single UDP port, drastically\n// simplifying deployments where ports will need to be opened/forwarded.\n// UDPMux should be started prior to creating PeerConnections.\nfunc (e *SettingEngine) SetICEUDPMux(udpMux ice.UDPMux) {\n\te.iceUDPMux = udpMux\n}\n\n// SetICEProxyDialer sets the proxy dialer interface based on golang.org/x/net/proxy.\nfunc (e *SettingEngine) SetICEProxyDialer(d proxy.Dialer) {\n\te.iceProxyDialer = d\n}\n\n// SetICEMaxBindingRequests sets the maximum amount of binding requests\n// that can be sent on a candidate before it is considered invalid.\nfunc (e *SettingEngine) SetICEMaxBindingRequests(d uint16) {\n\te.iceMaxBindingRequests = &d\n}\n\n// DisableActiveTCP disables using active TCP for ICE. Active TCP is enabled by default\nfunc (e *SettingEngine) DisableActiveTCP(isDisabled bool) {\n\te.iceDisableActiveTCP = isDisabled\n}\n\n// DisableMediaEngineCopy stops the MediaEngine from being copied. This allows a user to modify\n// the MediaEngine after the PeerConnection has been constructed. This is useful if you wish to\n// modify codecs after signaling. Make sure not to share MediaEngines between PeerConnections.\nfunc (e *SettingEngine) DisableMediaEngineCopy(isDisabled bool) {\n\te.disableMediaEngineCopy = isDisabled\n}\n\n// SetReceiveMTU sets the size of read buffer that copies incoming packets. This is optional.\n// Leave this 0 for the default receiveMTU\nfunc (e *SettingEngine) SetReceiveMTU(receiveMTU uint) {\n\te.receiveMTU = receiveMTU\n}\n\n// SetDTLSRetransmissionInterval sets the retranmission interval for DTLS.\nfunc (e *SettingEngine) SetDTLSRetransmissionInterval(interval time.Duration) {\n\te.dtls.retransmissionInterval = interval\n}\n\n// SetDTLSInsecureSkipHelloVerify sets the skip HelloVerify flag for DTLS.\n// If true and when acting as DTLS server, will allow client to skip hello verify phase and\n// receive ServerHello after initial ClientHello. This will mean faster connect times,\n// but will have lower DoS attack resistance.\nfunc (e *SettingEngine) SetDTLSInsecureSkipHelloVerify(skip bool) {\n\te.dtls.insecureSkipHelloVerify = skip\n}\n\n// SetDTLSDisableInsecureSkipVerify sets the disable skip insecure verify flag for DTLS.\n// This controls whether a client verifies the server's certificate chain and host name.\nfunc (e *SettingEngine) SetDTLSDisableInsecureSkipVerify(disable bool) {\n\te.dtls.disableInsecureSkipVerify = disable\n}\n\n// SetDTLSEllipticCurves sets the elliptic curves for DTLS.\nfunc (e *SettingEngine) SetDTLSEllipticCurves(ellipticCurves ...dtlsElliptic.Curve) {\n\te.dtls.ellipticCurves = ellipticCurves\n}\n\n// SetDTLSConnectContextMaker sets the context used during the DTLS Handshake.\n// It can be used to extend or reduce the timeout on the DTLS Handshake.\n// If nil, the default dtls.ConnectContextMaker is used. It can be implemented as following.\n//\n//\tfunc ConnectContextMaker() (context.Context, func()) {\n//\t\treturn context.WithTimeout(context.Background(), 30*time.Second)\n//\t}\nfunc (e *SettingEngine) SetDTLSConnectContextMaker(connectContextMaker func() (context.Context, func())) {\n\te.dtls.connectContextMaker = connectContextMaker\n}\n\n// SetDTLSExtendedMasterSecret sets the extended master secret type for DTLS.\nfunc (e *SettingEngine) SetDTLSExtendedMasterSecret(extendedMasterSecret dtls.ExtendedMasterSecretType) {\n\te.dtls.extendedMasterSecret = extendedMasterSecret\n}\n\n// SetDTLSClientAuth sets the client auth type for DTLS.\nfunc (e *SettingEngine) SetDTLSClientAuth(clientAuth dtls.ClientAuthType) {\n\te.dtls.clientAuth = &clientAuth\n}\n\n// SetDTLSClientCAs sets the client CA certificate pool for DTLS certificate verification.\nfunc (e *SettingEngine) SetDTLSClientCAs(clientCAs *x509.CertPool) {\n\te.dtls.clientCAs = clientCAs\n}\n\n// SetDTLSRootCAs sets the root CA certificate pool for DTLS certificate verification.\nfunc (e *SettingEngine) SetDTLSRootCAs(rootCAs *x509.CertPool) {\n\te.dtls.rootCAs = rootCAs\n}\n\n// SetDTLSKeyLogWriter sets the destination of the TLS key material for debugging.\n// Logging key material compromises security and should only be use for debugging.\nfunc (e *SettingEngine) SetDTLSKeyLogWriter(writer io.Writer) {\n\te.dtls.keyLogWriter = writer\n}\n\n// SetSCTPMaxReceiveBufferSize sets the maximum receive buffer size.\n// Leave this 0 for the default maxReceiveBufferSize.\nfunc (e *SettingEngine) SetSCTPMaxReceiveBufferSize(maxReceiveBufferSize uint32) {\n\te.sctp.maxReceiveBufferSize = maxReceiveBufferSize\n}\n\n// EnableSCTPZeroChecksum controls the zero checksum feature in SCTP.\n// This removes the need to checksum every incoming/outgoing packet and will reduce\n// latency and CPU usage. This feature is not backwards compatible so is disabled by default\nfunc (e *SettingEngine) EnableSCTPZeroChecksum(isEnabled bool) {\n\te.sctp.enableZeroChecksum = isEnabled\n}\n\n// SetDTLSCustomerCipherSuites allows the user to specify a list of DTLS CipherSuites.\n// This allow usage of Ciphers that are reserved for private usage.\nfunc (e *SettingEngine) SetDTLSCustomerCipherSuites(customCipherSuites func() []dtls.CipherSuite) {\n\te.dtls.customCipherSuites = customCipherSuites\n}\n\n// SetDTLSClientHelloMessageHook if not nil, is called when a DTLS Client Hello message is sent\n// from a client. The returned handshake message replaces the original message.\nfunc (e *SettingEngine) SetDTLSClientHelloMessageHook(hook func(handshake.MessageClientHello) handshake.Message) {\n\te.dtls.clientHelloMessageHook = hook\n}\n\n// SetDTLSServerHelloMessageHook if not nil, is called when a DTLS Server Hello message is sent\n// from a client. The returned handshake message replaces the original message.\nfunc (e *SettingEngine) SetDTLSServerHelloMessageHook(hook func(handshake.MessageServerHello) handshake.Message) {\n\te.dtls.serverHelloMessageHook = hook\n}\n\n// SetDTLSCertificateRequestMessageHook if not nil, is called when a DTLS Certificate Request message is sent\n// from a client. The returned handshake message replaces the original message.\nfunc (e *SettingEngine) SetDTLSCertificateRequestMessageHook(hook func(handshake.MessageCertificateRequest) handshake.Message) {\n\te.dtls.certificateRequestMessageHook = hook\n}\n\n// SetSCTPRTOMax sets the maximum retransmission timeout.\n// Leave this 0 for the default timeout.\nfunc (e *SettingEngine) SetSCTPRTOMax(rtoMax time.Duration) {\n\te.sctp.rtoMax = rtoMax\n}\n\n// SetICEBindingRequestHandler sets a callback that is fired on a STUN BindingRequest\n// This allows users to do things like\n// - Log incoming Binding Requests for debugging\n// - Implement draft-thatcher-ice-renomination\n// - Implement custom CandidatePair switching logic\nfunc (e *SettingEngine) SetICEBindingRequestHandler(bindingRequestHandler func(m *stun.Message, local, remote ice.Candidate, pair *ice.CandidatePair) bool) {\n\te.iceBindingRequestHandler = bindingRequestHandler\n}\n\n// SetFireOnTrackBeforeFirstRTP sets if firing the OnTrack event should happen\n// before any RTP packets are received. Setting this to true will\n// have the Track's Codec and PayloadTypes be initially set to their\n// zero values in the OnTrack handler.\n// Note: This does not yet affect simulcast tracks.\nfunc (e *SettingEngine) SetFireOnTrackBeforeFirstRTP(fireOnTrackBeforeFirstRTP bool) {\n\te.fireOnTrackBeforeFirstRTP = fireOnTrackBeforeFirstRTP\n}\n\n// DisableCloseByDTLS sets if the connection should be closed when dtls transport is closed.\n// Setting this to true will keep the connection open when dtls transport is closed\n// and relies on the ice failed state to detect the connection is interrupted.\nfunc (e *SettingEngine) DisableCloseByDTLS(isEnabled bool) {\n\te.disableCloseByDTLS = isEnabled\n}\n"
        },
        {
          "name": "settingengine_js.go",
          "type": "blob",
          "size": 0.658203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build js && wasm\n// +build js,wasm\n\npackage webrtc\n\n// SettingEngine allows influencing behavior in ways that are not\n// supported by the WebRTC API. This allows us to support additional\n// use-cases without deviating from the WebRTC API elsewhere.\ntype SettingEngine struct {\n\tdetach struct {\n\t\tDataChannels bool\n\t}\n}\n\n// DetachDataChannels enables detaching data channels. When enabled\n// data channels have to be detached in the OnOpen callback using the\n// DataChannel.Detach method.\nfunc (e *SettingEngine) DetachDataChannels() {\n\te.detach.DataChannels = true\n}\n"
        },
        {
          "name": "settingengine_test.go",
          "type": "blob",
          "size": 12.978515625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/datachannel\"\n\t\"github.com/pion/dtls/v3/pkg/crypto/elliptic\"\n\t\"github.com/pion/dtls/v3/pkg/protocol/handshake\"\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/pion/stun/v3\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSetEphemeralUDPPortRange(t *testing.T) {\n\ts := SettingEngine{}\n\n\tif s.ephemeralUDP.PortMin != 0 ||\n\t\ts.ephemeralUDP.PortMax != 0 {\n\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")\n\t}\n\n\t// set bad ephemeral ports\n\tif err := s.SetEphemeralUDPPortRange(3000, 2999); err == nil {\n\t\tt.Fatalf(\"Setting engine should fail bad ephemeral ports.\")\n\t}\n\n\tif err := s.SetEphemeralUDPPortRange(3000, 4000); err != nil {\n\t\tt.Fatalf(\"Setting engine failed valid port range: %s\", err)\n\t}\n\n\tif s.ephemeralUDP.PortMin != 3000 ||\n\t\ts.ephemeralUDP.PortMax != 4000 {\n\t\tt.Fatalf(\"Setting engine ports do not reflect expected range\")\n\t}\n}\n\nfunc TestSetConnectionTimeout(t *testing.T) {\n\ts := SettingEngine{}\n\n\tvar nilDuration *time.Duration\n\tassert.Equal(t, s.timeout.ICEDisconnectedTimeout, nilDuration)\n\tassert.Equal(t, s.timeout.ICEFailedTimeout, nilDuration)\n\tassert.Equal(t, s.timeout.ICEKeepaliveInterval, nilDuration)\n\n\ts.SetICETimeouts(1*time.Second, 2*time.Second, 3*time.Second)\n\tassert.Equal(t, *s.timeout.ICEDisconnectedTimeout, 1*time.Second)\n\tassert.Equal(t, *s.timeout.ICEFailedTimeout, 2*time.Second)\n\tassert.Equal(t, *s.timeout.ICEKeepaliveInterval, 3*time.Second)\n}\n\nfunc TestDetachDataChannels(t *testing.T) {\n\ts := SettingEngine{}\n\n\tif s.detach.DataChannels {\n\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")\n\t}\n\n\ts.DetachDataChannels()\n\n\tif !s.detach.DataChannels {\n\t\tt.Fatalf(\"Failed to enable detached data channels.\")\n\t}\n}\n\nfunc TestSetNAT1To1IPs(t *testing.T) {\n\ts := SettingEngine{}\n\tif s.candidates.NAT1To1IPs != nil {\n\t\tt.Errorf(\"Invalid default value\")\n\t}\n\tif s.candidates.NAT1To1IPCandidateType != 0 {\n\t\tt.Errorf(\"Invalid default value\")\n\t}\n\n\tips := []string{\"1.2.3.4\"}\n\ttyp := ICECandidateTypeHost\n\ts.SetNAT1To1IPs(ips, typ)\n\tif len(s.candidates.NAT1To1IPs) != 1 || s.candidates.NAT1To1IPs[0] != \"1.2.3.4\" {\n\t\tt.Fatalf(\"Failed to set NAT1To1IPs\")\n\t}\n\tif s.candidates.NAT1To1IPCandidateType != typ {\n\t\tt.Fatalf(\"Failed to set NAT1To1IPCandidateType\")\n\t}\n}\n\nfunc TestSetAnsweringDTLSRole(t *testing.T) {\n\ts := SettingEngine{}\n\tassert.Error(t, s.SetAnsweringDTLSRole(DTLSRoleAuto), \"SetAnsweringDTLSRole can only be called with DTLSRoleClient or DTLSRoleServer\")\n\tassert.Error(t, s.SetAnsweringDTLSRole(DTLSRole(0)), \"SetAnsweringDTLSRole can only be called with DTLSRoleClient or DTLSRoleServer\")\n}\n\nfunc TestSetReplayProtection(t *testing.T) {\n\ts := SettingEngine{}\n\n\tif s.replayProtection.DTLS != nil ||\n\t\ts.replayProtection.SRTP != nil ||\n\t\ts.replayProtection.SRTCP != nil {\n\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")\n\t}\n\n\ts.SetDTLSReplayProtectionWindow(128)\n\ts.SetSRTPReplayProtectionWindow(64)\n\ts.SetSRTCPReplayProtectionWindow(32)\n\n\tif s.replayProtection.DTLS == nil ||\n\t\t*s.replayProtection.DTLS != 128 {\n\t\tt.Errorf(\"Failed to set DTLS replay protection window\")\n\t}\n\tif s.replayProtection.SRTP == nil ||\n\t\t*s.replayProtection.SRTP != 64 {\n\t\tt.Errorf(\"Failed to set SRTP replay protection window\")\n\t}\n\tif s.replayProtection.SRTCP == nil ||\n\t\t*s.replayProtection.SRTCP != 32 {\n\t\tt.Errorf(\"Failed to set SRTCP replay protection window\")\n\t}\n}\n\nfunc TestSettingEngine_SetICETCP(t *testing.T) {\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tlistener, err := net.ListenTCP(\"tcp\", &net.TCPAddr{})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdefer func() {\n\t\t_ = listener.Close()\n\t}()\n\n\ttcpMux := NewICETCPMux(nil, listener, 8)\n\n\tdefer func() {\n\t\t_ = tcpMux.Close()\n\t}()\n\n\tsettingEngine := SettingEngine{}\n\tsettingEngine.SetICETCPMux(tcpMux)\n\n\tassert.Equal(t, tcpMux, settingEngine.iceTCPMux)\n}\n\nfunc TestSettingEngine_SetDisableMediaEngineCopy(t *testing.T) {\n\tt.Run(\"Copy\", func(t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\n\t\tapi := NewAPI(WithMediaEngine(m))\n\n\t\tofferer, answerer, err := api.newPair(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\t_, err = offerer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, signalPair(offerer, answerer))\n\n\t\t// Assert that the MediaEngine the user created isn't modified\n\t\tassert.False(t, m.negotiatedVideo)\n\t\tassert.Empty(t, m.negotiatedVideoCodecs)\n\n\t\t// Assert that the internal MediaEngine is modified\n\t\tassert.True(t, offerer.api.mediaEngine.negotiatedVideo)\n\t\tassert.NotEmpty(t, offerer.api.mediaEngine.negotiatedVideoCodecs)\n\n\t\tclosePairNow(t, offerer, answerer)\n\n\t\tnewOfferer, newAnswerer, err := api.newPair(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\t// Assert that the first internal MediaEngine hasn't been cleared\n\t\tassert.True(t, offerer.api.mediaEngine.negotiatedVideo)\n\t\tassert.NotEmpty(t, offerer.api.mediaEngine.negotiatedVideoCodecs)\n\n\t\t// Assert that the new internal MediaEngine isn't modified\n\t\tassert.False(t, newOfferer.api.mediaEngine.negotiatedVideo)\n\t\tassert.Empty(t, newAnswerer.api.mediaEngine.negotiatedVideoCodecs)\n\n\t\tclosePairNow(t, newOfferer, newAnswerer)\n\t})\n\n\tt.Run(\"No Copy\", func(t *testing.T) {\n\t\tm := &MediaEngine{}\n\t\tassert.NoError(t, m.RegisterDefaultCodecs())\n\n\t\ts := SettingEngine{}\n\t\ts.DisableMediaEngineCopy(true)\n\n\t\tapi := NewAPI(WithMediaEngine(m), WithSettingEngine(s))\n\n\t\tofferer, answerer, err := api.newPair(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\t_, err = offerer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\t\tassert.NoError(t, err)\n\n\t\tassert.NoError(t, signalPair(offerer, answerer))\n\n\t\t// Assert that the user MediaEngine was modified, so no copy happened\n\t\tassert.True(t, m.negotiatedVideo)\n\t\tassert.NotEmpty(t, m.negotiatedVideoCodecs)\n\n\t\tclosePairNow(t, offerer, answerer)\n\n\t\tofferer, answerer, err = api.newPair(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\t// Assert that the new internal MediaEngine was modified, so no copy happened\n\t\tassert.True(t, offerer.api.mediaEngine.negotiatedVideo)\n\t\tassert.NotEmpty(t, offerer.api.mediaEngine.negotiatedVideoCodecs)\n\n\t\tclosePairNow(t, offerer, answerer)\n\t})\n}\n\nfunc TestSetDTLSRetransmissionInterval(t *testing.T) {\n\ts := SettingEngine{}\n\n\tif s.dtls.retransmissionInterval != 0 {\n\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")\n\t}\n\n\ts.SetDTLSRetransmissionInterval(100 * time.Millisecond)\n\tif s.dtls.retransmissionInterval == 0 ||\n\t\ts.dtls.retransmissionInterval != 100*time.Millisecond {\n\t\tt.Errorf(\"Failed to set DTLS retransmission interval\")\n\t}\n\n\ts.SetDTLSRetransmissionInterval(1 * time.Second)\n\tif s.dtls.retransmissionInterval == 0 ||\n\t\ts.dtls.retransmissionInterval != 1*time.Second {\n\t\tt.Errorf(\"Failed to set DTLS retransmission interval\")\n\t}\n}\n\nfunc TestSetDTLSEllipticCurves(t *testing.T) {\n\ts := SettingEngine{}\n\n\tif len(s.dtls.ellipticCurves) != 0 {\n\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")\n\t}\n\n\ts.SetDTLSEllipticCurves(elliptic.P256)\n\tif len(s.dtls.ellipticCurves) == 0 ||\n\t\ts.dtls.ellipticCurves[0] != elliptic.P256 {\n\t\tt.Errorf(\"Failed to set DTLS elliptic curves\")\n\t}\n}\n\nfunc TestSetDTLSHandShakeTimeout(*testing.T) {\n\ts := SettingEngine{}\n\n\ts.SetDTLSConnectContextMaker(func() (context.Context, func()) {\n\t\treturn context.WithTimeout(context.Background(), 60*time.Second)\n\t})\n}\n\nfunc TestSetSCTPMaxReceiverBufferSize(t *testing.T) {\n\ts := SettingEngine{}\n\tassert.Equal(t, uint32(0), s.sctp.maxReceiveBufferSize)\n\n\texpSize := uint32(4 * 1024 * 1024)\n\ts.SetSCTPMaxReceiveBufferSize(expSize)\n\tassert.Equal(t, expSize, s.sctp.maxReceiveBufferSize)\n}\n\nfunc TestSetSCTPRTOMax(t *testing.T) {\n\ts := SettingEngine{}\n\tassert.Equal(t, time.Duration(0), s.sctp.rtoMax)\n\n\texpSize := time.Second\n\ts.SetSCTPRTOMax(expSize)\n\tassert.Equal(t, expSize, s.sctp.rtoMax)\n}\n\nfunc TestSetICEBindingRequestHandler(t *testing.T) {\n\tseenICEControlled, seenICEControlledCancel := context.WithCancel(context.Background())\n\tseenICEControlling, seenICEControllingCancel := context.WithCancel(context.Background())\n\n\ts := SettingEngine{}\n\ts.SetICEBindingRequestHandler(func(m *stun.Message, _, _ ice.Candidate, _ *ice.CandidatePair) bool {\n\t\tfor _, a := range m.Attributes {\n\t\t\tswitch a.Type {\n\t\t\tcase stun.AttrICEControlled:\n\t\t\t\tseenICEControlledCancel()\n\t\t\tcase stun.AttrICEControlling:\n\t\t\t\tseenICEControllingCancel()\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t})\n\n\tpcOffer, pcAnswer, err := NewAPI(WithSettingEngine(s)).newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\t<-seenICEControlled.Done()\n\t<-seenICEControlling.Done()\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc TestSetHooks(t *testing.T) {\n\ts := SettingEngine{}\n\n\tif s.dtls.clientHelloMessageHook != nil ||\n\t\ts.dtls.serverHelloMessageHook != nil ||\n\t\ts.dtls.certificateRequestMessageHook != nil {\n\t\tt.Fatalf(\"SettingEngine defaults aren't as expected.\")\n\t}\n\n\ts.SetDTLSClientHelloMessageHook(func(msg handshake.MessageClientHello) handshake.Message {\n\t\treturn &msg\n\t})\n\ts.SetDTLSServerHelloMessageHook(func(msg handshake.MessageServerHello) handshake.Message {\n\t\treturn &msg\n\t})\n\ts.SetDTLSCertificateRequestMessageHook(func(msg handshake.MessageCertificateRequest) handshake.Message {\n\t\treturn &msg\n\t})\n\n\tif s.dtls.clientHelloMessageHook == nil {\n\t\tt.Errorf(\"Failed to set DTLS Client Hello Hook\")\n\t}\n\tif s.dtls.serverHelloMessageHook == nil {\n\t\tt.Errorf(\"Failed to set DTLS Server Hello Hook\")\n\t}\n\tif s.dtls.certificateRequestMessageHook == nil {\n\t\tt.Errorf(\"Failed to set DTLS Certificate Request Hook\")\n\t}\n}\n\nfunc TestSetFireOnTrackBeforeFirstRTP(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ts := SettingEngine{}\n\ts.SetFireOnTrackBeforeFirstRTP(true)\n\n\tmediaEngineOne := &MediaEngine{}\n\tassert.NoError(t, mediaEngineOne.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/VP8\", ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        100,\n\t}, RTPCodecTypeVideo))\n\n\tmediaEngineTwo := &MediaEngine{}\n\tassert.NoError(t, mediaEngineTwo.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/VP8\", ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        200,\n\t}, RTPCodecTypeVideo))\n\n\tofferer, err := NewAPI(WithMediaEngine(mediaEngineOne), WithSettingEngine(s)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tanswerer, err := NewAPI(WithMediaEngine(mediaEngineTwo)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = offerer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\t_, err = answerer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\tofferer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\t_, _, err = track.Read(make([]byte, 1500))\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, track.PayloadType(), PayloadType(100))\n\t\tassert.Equal(t, track.Codec().RTPCodecCapability.MimeType, \"video/VP8\")\n\n\t\tonTrackFiredFunc()\n\t})\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{track})\n\n\tclosePairNow(t, offerer, answerer)\n}\n\nfunc TestDisableCloseByDTLS(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ts := SettingEngine{}\n\ts.DisableCloseByDTLS(true)\n\n\toffer, answer, err := NewAPI(WithSettingEngine(s)).newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(offer, answer))\n\n\tuntilConnectionState(PeerConnectionStateConnected, offer, answer).Wait()\n\tassert.NoError(t, answer.Close())\n\n\ttime.Sleep(time.Second)\n\tassert.True(t, offer.ConnectionState() == PeerConnectionStateConnected)\n\tassert.NoError(t, offer.Close())\n}\n\nfunc TestEnableDataChannelBlockWrite(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ts := SettingEngine{}\n\ts.DetachDataChannels()\n\ts.EnableDataChannelBlockWrite(true)\n\ts.SetSCTPMaxReceiveBufferSize(1500)\n\n\toffer, answer, err := NewAPI(WithSettingEngine(s)).newPair(Configuration{})\n\tassert.NoError(t, err)\n\n\tdc, err := offer.CreateDataChannel(\"data\", nil)\n\tassert.NoError(t, err)\n\tdetachChan := make(chan datachannel.ReadWriteCloserDeadliner, 1)\n\tdc.OnOpen(func() {\n\t\tdetached, err1 := dc.DetachWithDeadline()\n\t\tassert.NoError(t, err1)\n\t\tdetachChan <- detached\n\t})\n\n\tassert.NoError(t, signalPair(offer, answer))\n\tuntilConnectionState(PeerConnectionStateConnected, offer, answer).Wait()\n\n\t// write should block and return deadline exceeded since the receiver is not reading\n\t// and the buffer size is 1500 bytes\n\trawDC := <-detachChan\n\tassert.NoError(t, rawDC.SetWriteDeadline(time.Now().Add(time.Second)))\n\tbuf := make([]byte, 1000)\n\tfor i := 0; i < 10; i++ {\n\t\t_, err = rawDC.Write(buf)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tassert.ErrorIs(t, err, context.DeadlineExceeded)\n\tclosePairNow(t, offer, answer)\n}\n"
        },
        {
          "name": "signalingstate.go",
          "type": "blob",
          "size": 5.6943359375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n)\n\ntype stateChangeOp int\n\nconst (\n\tstateChangeOpSetLocal stateChangeOp = iota + 1\n\tstateChangeOpSetRemote\n)\n\nfunc (op stateChangeOp) String() string {\n\tswitch op {\n\tcase stateChangeOpSetLocal:\n\t\treturn \"SetLocal\"\n\tcase stateChangeOpSetRemote:\n\t\treturn \"SetRemote\"\n\tdefault:\n\t\treturn \"Unknown State Change Operation\"\n\t}\n}\n\n// SignalingState indicates the signaling state of the offer/answer process.\ntype SignalingState int32\n\nconst (\n\t// SignalingStateUnknown is the enum's zero-value\n\tSignalingStateUnknown SignalingState = iota\n\n\t// SignalingStateStable indicates there is no offer/answer exchange in\n\t// progress. This is also the initial state, in which case the local and\n\t// remote descriptions are nil.\n\tSignalingStateStable\n\n\t// SignalingStateHaveLocalOffer indicates that a local description, of\n\t// type \"offer\", has been successfully applied.\n\tSignalingStateHaveLocalOffer\n\n\t// SignalingStateHaveRemoteOffer indicates that a remote description, of\n\t// type \"offer\", has been successfully applied.\n\tSignalingStateHaveRemoteOffer\n\n\t// SignalingStateHaveLocalPranswer indicates that a remote description\n\t// of type \"offer\" has been successfully applied and a local description\n\t// of type \"pranswer\" has been successfully applied.\n\tSignalingStateHaveLocalPranswer\n\n\t// SignalingStateHaveRemotePranswer indicates that a local description\n\t// of type \"offer\" has been successfully applied and a remote description\n\t// of type \"pranswer\" has been successfully applied.\n\tSignalingStateHaveRemotePranswer\n\n\t// SignalingStateClosed indicates The PeerConnection has been closed.\n\tSignalingStateClosed\n)\n\n// This is done this way because of a linter.\nconst (\n\tsignalingStateStableStr             = \"stable\"\n\tsignalingStateHaveLocalOfferStr     = \"have-local-offer\"\n\tsignalingStateHaveRemoteOfferStr    = \"have-remote-offer\"\n\tsignalingStateHaveLocalPranswerStr  = \"have-local-pranswer\"\n\tsignalingStateHaveRemotePranswerStr = \"have-remote-pranswer\"\n\tsignalingStateClosedStr             = \"closed\"\n)\n\nfunc newSignalingState(raw string) SignalingState {\n\tswitch raw {\n\tcase signalingStateStableStr:\n\t\treturn SignalingStateStable\n\tcase signalingStateHaveLocalOfferStr:\n\t\treturn SignalingStateHaveLocalOffer\n\tcase signalingStateHaveRemoteOfferStr:\n\t\treturn SignalingStateHaveRemoteOffer\n\tcase signalingStateHaveLocalPranswerStr:\n\t\treturn SignalingStateHaveLocalPranswer\n\tcase signalingStateHaveRemotePranswerStr:\n\t\treturn SignalingStateHaveRemotePranswer\n\tcase signalingStateClosedStr:\n\t\treturn SignalingStateClosed\n\tdefault:\n\t\treturn SignalingStateUnknown\n\t}\n}\n\nfunc (t SignalingState) String() string {\n\tswitch t {\n\tcase SignalingStateStable:\n\t\treturn signalingStateStableStr\n\tcase SignalingStateHaveLocalOffer:\n\t\treturn signalingStateHaveLocalOfferStr\n\tcase SignalingStateHaveRemoteOffer:\n\t\treturn signalingStateHaveRemoteOfferStr\n\tcase SignalingStateHaveLocalPranswer:\n\t\treturn signalingStateHaveLocalPranswerStr\n\tcase SignalingStateHaveRemotePranswer:\n\t\treturn signalingStateHaveRemotePranswerStr\n\tcase SignalingStateClosed:\n\t\treturn signalingStateClosedStr\n\tdefault:\n\t\treturn ErrUnknownType.Error()\n\t}\n}\n\n// Get thread safe read value\nfunc (t *SignalingState) Get() SignalingState {\n\treturn SignalingState(atomic.LoadInt32((*int32)(t)))\n}\n\n// Set thread safe write value\nfunc (t *SignalingState) Set(state SignalingState) {\n\tatomic.StoreInt32((*int32)(t), int32(state))\n}\n\nfunc checkNextSignalingState(cur, next SignalingState, op stateChangeOp, sdpType SDPType) (SignalingState, error) { // nolint:gocognit\n\t// Special case for rollbacks\n\tif sdpType == SDPTypeRollback && cur == SignalingStateStable {\n\t\treturn cur, &rtcerr.InvalidModificationError{\n\t\t\tErr: errSignalingStateCannotRollback,\n\t\t}\n\t}\n\n\t// 4.3.1 valid state transitions\n\tswitch cur { // nolint:exhaustive\n\tcase SignalingStateStable:\n\t\tswitch op {\n\t\tcase stateChangeOpSetLocal:\n\t\t\t// stable->SetLocal(offer)->have-local-offer\n\t\t\tif sdpType == SDPTypeOffer && next == SignalingStateHaveLocalOffer {\n\t\t\t\treturn next, nil\n\t\t\t}\n\t\tcase stateChangeOpSetRemote:\n\t\t\t// stable->SetRemote(offer)->have-remote-offer\n\t\t\tif sdpType == SDPTypeOffer && next == SignalingStateHaveRemoteOffer {\n\t\t\t\treturn next, nil\n\t\t\t}\n\t\t}\n\tcase SignalingStateHaveLocalOffer:\n\t\tif op == stateChangeOpSetRemote {\n\t\t\tswitch sdpType { // nolint:exhaustive\n\t\t\t// have-local-offer->SetRemote(answer)->stable\n\t\t\tcase SDPTypeAnswer:\n\t\t\t\tif next == SignalingStateStable {\n\t\t\t\t\treturn next, nil\n\t\t\t\t}\n\t\t\t// have-local-offer->SetRemote(pranswer)->have-remote-pranswer\n\t\t\tcase SDPTypePranswer:\n\t\t\t\tif next == SignalingStateHaveRemotePranswer {\n\t\t\t\t\treturn next, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase SignalingStateHaveRemotePranswer:\n\t\tif op == stateChangeOpSetRemote && sdpType == SDPTypeAnswer {\n\t\t\t// have-remote-pranswer->SetRemote(answer)->stable\n\t\t\tif next == SignalingStateStable {\n\t\t\t\treturn next, nil\n\t\t\t}\n\t\t}\n\tcase SignalingStateHaveRemoteOffer:\n\t\tif op == stateChangeOpSetLocal {\n\t\t\tswitch sdpType { // nolint:exhaustive\n\t\t\t// have-remote-offer->SetLocal(answer)->stable\n\t\t\tcase SDPTypeAnswer:\n\t\t\t\tif next == SignalingStateStable {\n\t\t\t\t\treturn next, nil\n\t\t\t\t}\n\t\t\t// have-remote-offer->SetLocal(pranswer)->have-local-pranswer\n\t\t\tcase SDPTypePranswer:\n\t\t\t\tif next == SignalingStateHaveLocalPranswer {\n\t\t\t\t\treturn next, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase SignalingStateHaveLocalPranswer:\n\t\tif op == stateChangeOpSetLocal && sdpType == SDPTypeAnswer {\n\t\t\t// have-local-pranswer->SetLocal(answer)->stable\n\t\t\tif next == SignalingStateStable {\n\t\t\t\treturn next, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn cur, &rtcerr.InvalidModificationError{\n\t\tErr: fmt.Errorf(\"%w: %s->%s(%s)->%s\", errSignalingStateProposedTransitionInvalid, cur, op, sdpType, next),\n\t}\n}\n"
        },
        {
          "name": "signalingstate_test.go",
          "type": "blob",
          "size": 3.8837890625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\n\t\"github.com/pion/webrtc/v4/pkg/rtcerr\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewSignalingState(t *testing.T) {\n\ttestCases := []struct {\n\t\tstateString   string\n\t\texpectedState SignalingState\n\t}{\n\t\t{ErrUnknownType.Error(), SignalingStateUnknown},\n\t\t{\"stable\", SignalingStateStable},\n\t\t{\"have-local-offer\", SignalingStateHaveLocalOffer},\n\t\t{\"have-remote-offer\", SignalingStateHaveRemoteOffer},\n\t\t{\"have-local-pranswer\", SignalingStateHaveLocalPranswer},\n\t\t{\"have-remote-pranswer\", SignalingStateHaveRemotePranswer},\n\t\t{\"closed\", SignalingStateClosed},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedState,\n\t\t\tnewSignalingState(testCase.stateString),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestSignalingState_String(t *testing.T) {\n\ttestCases := []struct {\n\t\tstate          SignalingState\n\t\texpectedString string\n\t}{\n\t\t{SignalingStateUnknown, ErrUnknownType.Error()},\n\t\t{SignalingStateStable, \"stable\"},\n\t\t{SignalingStateHaveLocalOffer, \"have-local-offer\"},\n\t\t{SignalingStateHaveRemoteOffer, \"have-remote-offer\"},\n\t\t{SignalingStateHaveLocalPranswer, \"have-local-pranswer\"},\n\t\t{SignalingStateHaveRemotePranswer, \"have-remote-pranswer\"},\n\t\t{SignalingStateClosed, \"closed\"},\n\t}\n\n\tfor i, testCase := range testCases {\n\t\tassert.Equal(t,\n\t\t\ttestCase.expectedString,\n\t\t\ttestCase.state.String(),\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestSignalingState_Transitions(t *testing.T) {\n\ttestCases := []struct {\n\t\tdesc        string\n\t\tcurrent     SignalingState\n\t\tnext        SignalingState\n\t\top          stateChangeOp\n\t\tsdpType     SDPType\n\t\texpectedErr error\n\t}{\n\t\t{\n\t\t\t\"stable->SetLocal(offer)->have-local-offer\",\n\t\t\tSignalingStateStable,\n\t\t\tSignalingStateHaveLocalOffer,\n\t\t\tstateChangeOpSetLocal,\n\t\t\tSDPTypeOffer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"stable->SetRemote(offer)->have-remote-offer\",\n\t\t\tSignalingStateStable,\n\t\t\tSignalingStateHaveRemoteOffer,\n\t\t\tstateChangeOpSetRemote,\n\t\t\tSDPTypeOffer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"have-local-offer->SetRemote(answer)->stable\",\n\t\t\tSignalingStateHaveLocalOffer,\n\t\t\tSignalingStateStable,\n\t\t\tstateChangeOpSetRemote,\n\t\t\tSDPTypeAnswer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"have-local-offer->SetRemote(pranswer)->have-remote-pranswer\",\n\t\t\tSignalingStateHaveLocalOffer,\n\t\t\tSignalingStateHaveRemotePranswer,\n\t\t\tstateChangeOpSetRemote,\n\t\t\tSDPTypePranswer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"have-remote-pranswer->SetRemote(answer)->stable\",\n\t\t\tSignalingStateHaveRemotePranswer,\n\t\t\tSignalingStateStable,\n\t\t\tstateChangeOpSetRemote,\n\t\t\tSDPTypeAnswer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"have-remote-offer->SetLocal(answer)->stable\",\n\t\t\tSignalingStateHaveRemoteOffer,\n\t\t\tSignalingStateStable,\n\t\t\tstateChangeOpSetLocal,\n\t\t\tSDPTypeAnswer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"have-remote-offer->SetLocal(pranswer)->have-local-pranswer\",\n\t\t\tSignalingStateHaveRemoteOffer,\n\t\t\tSignalingStateHaveLocalPranswer,\n\t\t\tstateChangeOpSetLocal,\n\t\t\tSDPTypePranswer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"have-local-pranswer->SetLocal(answer)->stable\",\n\t\t\tSignalingStateHaveLocalPranswer,\n\t\t\tSignalingStateStable,\n\t\t\tstateChangeOpSetLocal,\n\t\t\tSDPTypeAnswer,\n\t\t\tnil,\n\t\t},\n\t\t{\n\t\t\t\"(invalid) stable->SetRemote(pranswer)->have-remote-pranswer\",\n\t\t\tSignalingStateStable,\n\t\t\tSignalingStateHaveRemotePranswer,\n\t\t\tstateChangeOpSetRemote,\n\t\t\tSDPTypePranswer,\n\t\t\t&rtcerr.InvalidModificationError{},\n\t\t},\n\t\t{\n\t\t\t\"(invalid) stable->SetRemote(rollback)->have-local-offer\",\n\t\t\tSignalingStateStable,\n\t\t\tSignalingStateHaveLocalOffer,\n\t\t\tstateChangeOpSetRemote,\n\t\t\tSDPTypeRollback,\n\t\t\t&rtcerr.InvalidModificationError{},\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tnext, err := checkNextSignalingState(tc.current, tc.next, tc.op, tc.sdpType)\n\t\tif tc.expectedErr != nil {\n\t\t\tassert.Error(t, err, \"testCase: %d %s\", i, tc.desc)\n\t\t} else {\n\t\t\tassert.NoError(t, err, \"testCase: %d %s\", i, tc.desc)\n\t\t\tassert.Equal(t,\n\t\t\t\ttc.next,\n\t\t\t\tnext,\n\t\t\t\t\"testCase: %d %s\", i, tc.desc,\n\t\t\t)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "srtp_writer_future.go",
          "type": "blob",
          "size": 2.8291015625,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"io\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/srtp/v3\"\n)\n\n// srtpWriterFuture blocks Read/Write calls until\n// the SRTP Session is available\ntype srtpWriterFuture struct {\n\tssrc           SSRC\n\trtpSender      *RTPSender\n\trtcpReadStream atomic.Value // *srtp.ReadStreamSRTCP\n\trtpWriteStream atomic.Value // *srtp.WriteStreamSRTP\n\tmu             sync.Mutex\n\tclosed         bool\n}\n\nfunc (s *srtpWriterFuture) init(returnWhenNoSRTP bool) error {\n\tif returnWhenNoSRTP {\n\t\tselect {\n\t\tcase <-s.rtpSender.stopCalled:\n\t\t\treturn io.ErrClosedPipe\n\t\tcase <-s.rtpSender.transport.srtpReady:\n\t\tdefault:\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\tselect {\n\t\tcase <-s.rtpSender.stopCalled:\n\t\t\treturn io.ErrClosedPipe\n\t\tcase <-s.rtpSender.transport.srtpReady:\n\t\t}\n\t}\n\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.closed {\n\t\treturn io.ErrClosedPipe\n\t}\n\n\tsrtcpSession, err := s.rtpSender.transport.getSRTCPSession()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trtcpReadStream, err := srtcpSession.OpenReadStream(uint32(s.ssrc))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsrtpSession, err := s.rtpSender.transport.getSRTPSession()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trtpWriteStream, err := srtpSession.OpenWriteStream()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.rtcpReadStream.Store(rtcpReadStream)\n\ts.rtpWriteStream.Store(rtpWriteStream)\n\treturn nil\n}\n\nfunc (s *srtpWriterFuture) Close() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.closed {\n\t\treturn nil\n\t}\n\ts.closed = true\n\n\tif value, ok := s.rtcpReadStream.Load().(*srtp.ReadStreamSRTCP); ok {\n\t\treturn value.Close()\n\t}\n\n\treturn nil\n}\n\nfunc (s *srtpWriterFuture) Read(b []byte) (n int, err error) {\n\tif value, ok := s.rtcpReadStream.Load().(*srtp.ReadStreamSRTCP); ok {\n\t\treturn value.Read(b)\n\t}\n\n\tif err := s.init(false); err != nil || s.rtcpReadStream.Load() == nil {\n\t\treturn 0, err\n\t}\n\n\treturn s.Read(b)\n}\n\nfunc (s *srtpWriterFuture) SetReadDeadline(t time.Time) error {\n\tif value, ok := s.rtcpReadStream.Load().(*srtp.ReadStreamSRTCP); ok {\n\t\treturn value.SetReadDeadline(t)\n\t}\n\n\tif err := s.init(false); err != nil || s.rtcpReadStream.Load() == nil {\n\t\treturn err\n\t}\n\n\treturn s.SetReadDeadline(t)\n}\n\nfunc (s *srtpWriterFuture) WriteRTP(header *rtp.Header, payload []byte) (int, error) {\n\tif value, ok := s.rtpWriteStream.Load().(*srtp.WriteStreamSRTP); ok {\n\t\treturn value.WriteRTP(header, payload)\n\t}\n\n\tif err := s.init(true); err != nil || s.rtpWriteStream.Load() == nil {\n\t\treturn 0, err\n\t}\n\n\treturn s.WriteRTP(header, payload)\n}\n\nfunc (s *srtpWriterFuture) Write(b []byte) (int, error) {\n\tif value, ok := s.rtpWriteStream.Load().(*srtp.WriteStreamSRTP); ok {\n\t\treturn value.Write(b)\n\t}\n\n\tif err := s.init(true); err != nil || s.rtpWriteStream.Load() == nil {\n\t\treturn 0, err\n\t}\n\n\treturn s.Write(b)\n}\n"
        },
        {
          "name": "stats.go",
          "type": "blob",
          "size": 108.5810546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pion/ice/v4\"\n)\n\n// A Stats object contains a set of statistics copies out of a monitored component\n// of the WebRTC stack at a specific time.\ntype Stats interface {\n\tstatsMarker()\n}\n\n// UnmarshalStatsJSON unmarshals a Stats object from JSON\nfunc UnmarshalStatsJSON(b []byte) (Stats, error) {\n\ttype typeJSON struct {\n\t\tType StatsType `json:\"type\"`\n\t}\n\ttypeHolder := typeJSON{}\n\n\terr := json.Unmarshal(b, &typeHolder)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal json type: %w\", err)\n\t}\n\n\tswitch typeHolder.Type {\n\tcase StatsTypeCodec:\n\t\treturn unmarshalCodecStats(b)\n\tcase StatsTypeInboundRTP:\n\t\treturn unmarshalInboundRTPStreamStats(b)\n\tcase StatsTypeOutboundRTP:\n\t\treturn unmarshalOutboundRTPStreamStats(b)\n\tcase StatsTypeRemoteInboundRTP:\n\t\treturn unmarshalRemoteInboundRTPStreamStats(b)\n\tcase StatsTypeRemoteOutboundRTP:\n\t\treturn unmarshalRemoteOutboundRTPStreamStats(b)\n\tcase StatsTypeCSRC:\n\t\treturn unmarshalCSRCStats(b)\n\tcase StatsTypeMediaSource:\n\t\treturn unmarshalMediaSourceStats(b)\n\tcase StatsTypeMediaPlayout:\n\t\treturn unmarshalMediaPlayoutStats(b)\n\tcase StatsTypePeerConnection:\n\t\treturn unmarshalPeerConnectionStats(b)\n\tcase StatsTypeDataChannel:\n\t\treturn unmarshalDataChannelStats(b)\n\tcase StatsTypeStream:\n\t\treturn unmarshalStreamStats(b)\n\tcase StatsTypeTrack:\n\t\treturn unmarshalTrackStats(b)\n\tcase StatsTypeSender:\n\t\treturn unmarshalSenderStats(b)\n\tcase StatsTypeReceiver:\n\t\treturn unmarshalReceiverStats(b)\n\tcase StatsTypeTransport:\n\t\treturn unmarshalTransportStats(b)\n\tcase StatsTypeCandidatePair:\n\t\treturn unmarshalICECandidatePairStats(b)\n\tcase StatsTypeLocalCandidate, StatsTypeRemoteCandidate:\n\t\treturn unmarshalICECandidateStats(b)\n\tcase StatsTypeCertificate:\n\t\treturn unmarshalCertificateStats(b)\n\tcase StatsTypeSCTPTransport:\n\t\treturn unmarshalSCTPTransportStats(b)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"type: %w\", ErrUnknownType)\n\t}\n}\n\n// StatsType indicates the type of the object that a Stats object represents.\ntype StatsType string\n\nconst (\n\t// StatsTypeCodec is used by CodecStats.\n\tStatsTypeCodec StatsType = \"codec\"\n\n\t// StatsTypeInboundRTP is used by InboundRTPStreamStats.\n\tStatsTypeInboundRTP StatsType = \"inbound-rtp\"\n\n\t// StatsTypeOutboundRTP is used by OutboundRTPStreamStats.\n\tStatsTypeOutboundRTP StatsType = \"outbound-rtp\"\n\n\t// StatsTypeRemoteInboundRTP is used by RemoteInboundRTPStreamStats.\n\tStatsTypeRemoteInboundRTP StatsType = \"remote-inbound-rtp\"\n\n\t// StatsTypeRemoteOutboundRTP is used by RemoteOutboundRTPStreamStats.\n\tStatsTypeRemoteOutboundRTP StatsType = \"remote-outbound-rtp\"\n\n\t// StatsTypeCSRC is used by RTPContributingSourceStats.\n\tStatsTypeCSRC StatsType = \"csrc\"\n\n\t// StatsTypeMediaSource is used by AudioSourceStats or VideoSourceStats depending on kind.\n\tStatsTypeMediaSource = \"media-source\"\n\n\t// StatsTypeMediaPlayout is used by AudioPlayoutStats.\n\tStatsTypeMediaPlayout StatsType = \"media-playout\"\n\n\t// StatsTypePeerConnection used by PeerConnectionStats.\n\tStatsTypePeerConnection StatsType = \"peer-connection\"\n\n\t// StatsTypeDataChannel is used by DataChannelStats.\n\tStatsTypeDataChannel StatsType = \"data-channel\"\n\n\t// StatsTypeStream is used by MediaStreamStats.\n\tStatsTypeStream StatsType = \"stream\"\n\n\t// StatsTypeTrack is used by SenderVideoTrackAttachmentStats and SenderAudioTrackAttachmentStats depending on kind.\n\tStatsTypeTrack StatsType = \"track\"\n\n\t// StatsTypeSender is used by the AudioSenderStats or VideoSenderStats depending on kind.\n\tStatsTypeSender StatsType = \"sender\"\n\n\t// StatsTypeReceiver is used by the AudioReceiverStats or VideoReceiverStats depending on kind.\n\tStatsTypeReceiver StatsType = \"receiver\"\n\n\t// StatsTypeTransport is used by TransportStats.\n\tStatsTypeTransport StatsType = \"transport\"\n\n\t// StatsTypeCandidatePair is used by ICECandidatePairStats.\n\tStatsTypeCandidatePair StatsType = \"candidate-pair\"\n\n\t// StatsTypeLocalCandidate is used by ICECandidateStats for the local candidate.\n\tStatsTypeLocalCandidate StatsType = \"local-candidate\"\n\n\t// StatsTypeRemoteCandidate is used by ICECandidateStats for the remote candidate.\n\tStatsTypeRemoteCandidate StatsType = \"remote-candidate\"\n\n\t// StatsTypeCertificate is used by CertificateStats.\n\tStatsTypeCertificate StatsType = \"certificate\"\n\n\t// StatsTypeSCTPTransport is used by SCTPTransportStats\n\tStatsTypeSCTPTransport StatsType = \"sctp-transport\"\n)\n\n// MediaKind indicates the kind of media (audio or video)\ntype MediaKind string\n\nconst (\n\t// MediaKindAudio indicates this is audio stats\n\tMediaKindAudio MediaKind = \"audio\"\n\t// MediaKindVideo indicates this is video stats\n\tMediaKindVideo MediaKind = \"video\"\n)\n\n// StatsTimestamp is a timestamp represented by the floating point number of\n// milliseconds since the epoch.\ntype StatsTimestamp float64\n\n// Time returns the time.Time represented by this timestamp.\nfunc (s StatsTimestamp) Time() time.Time {\n\tmillis := float64(s)\n\tnanos := int64(millis * float64(time.Millisecond))\n\n\treturn time.Unix(0, nanos).UTC()\n}\n\nfunc statsTimestampFrom(t time.Time) StatsTimestamp {\n\treturn StatsTimestamp(t.UnixNano() / int64(time.Millisecond))\n}\n\nfunc statsTimestampNow() StatsTimestamp {\n\treturn statsTimestampFrom(time.Now())\n}\n\n// StatsReport collects Stats objects indexed by their ID.\ntype StatsReport map[string]Stats\n\ntype statsReportCollector struct {\n\tcollectingGroup sync.WaitGroup\n\treport          StatsReport\n\tmux             sync.Mutex\n}\n\nfunc newStatsReportCollector() *statsReportCollector {\n\treturn &statsReportCollector{report: make(StatsReport)}\n}\n\nfunc (src *statsReportCollector) Collecting() {\n\tsrc.collectingGroup.Add(1)\n}\n\nfunc (src *statsReportCollector) Collect(id string, stats Stats) {\n\tsrc.mux.Lock()\n\tdefer src.mux.Unlock()\n\n\tsrc.report[id] = stats\n\tsrc.collectingGroup.Done()\n}\n\nfunc (src *statsReportCollector) Done() {\n\tsrc.collectingGroup.Done()\n}\n\nfunc (src *statsReportCollector) Ready() StatsReport {\n\tsrc.collectingGroup.Wait()\n\tsrc.mux.Lock()\n\tdefer src.mux.Unlock()\n\treturn src.report\n}\n\n// CodecType specifies whether a CodecStats objects represents a media format\n// that is being encoded or decoded\ntype CodecType string\n\nconst (\n\t// CodecTypeEncode means the attached CodecStats represents a media format that\n\t// is being encoded, or that the implementation is prepared to encode.\n\tCodecTypeEncode CodecType = \"encode\"\n\n\t// CodecTypeDecode means the attached CodecStats represents a media format\n\t// that the implementation is prepared to decode.\n\tCodecTypeDecode CodecType = \"decode\"\n)\n\n// CodecStats contains statistics for a codec that is currently being used by RTP streams\n// being sent or received by this PeerConnection object.\ntype CodecStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// PayloadType as used in RTP encoding or decoding\n\tPayloadType PayloadType `json:\"payloadType\"`\n\n\t// CodecType of this CodecStats\n\tCodecType CodecType `json:\"codecType\"`\n\n\t// TransportID is the unique identifier of the transport on which this codec is\n\t// being used, which can be used to look up the corresponding TransportStats object.\n\tTransportID string `json:\"transportId\"`\n\n\t// MimeType is the codec MIME media type/subtype. e.g., video/vp8 or equivalent.\n\tMimeType string `json:\"mimeType\"`\n\n\t// ClockRate represents the media sampling rate.\n\tClockRate uint32 `json:\"clockRate\"`\n\n\t// Channels is 2 for stereo, missing for most other cases.\n\tChannels uint8 `json:\"channels\"`\n\n\t// SDPFmtpLine is the a=fmtp line in the SDP corresponding to the codec,\n\t// i.e., after the colon following the PT.\n\tSDPFmtpLine string `json:\"sdpFmtpLine\"`\n\n\t// Implementation identifies the implementation used. This is useful for diagnosing\n\t// interoperability issues.\n\tImplementation string `json:\"implementation\"`\n}\n\nfunc (s CodecStats) statsMarker() {}\n\nfunc unmarshalCodecStats(b []byte) (CodecStats, error) {\n\tvar codecStats CodecStats\n\terr := json.Unmarshal(b, &codecStats)\n\tif err != nil {\n\t\treturn CodecStats{}, fmt.Errorf(\"unmarshal codec stats: %w\", err)\n\t}\n\treturn codecStats, nil\n}\n\n// InboundRTPStreamStats contains statistics for an inbound RTP stream that is\n// currently received with this PeerConnection object.\ntype InboundRTPStreamStats struct {\n\t// Mid represents a mid value of RTPTransceiver owning this stream, if that value is not\n\t// null. Otherwise, this member is not present.\n\tMid string `json:\"mid\"`\n\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// SSRC is the 32-bit unsigned integer value used to identify the source of the\n\t// stream of RTP packets that this stats object concerns.\n\tSSRC SSRC `json:\"ssrc\"`\n\n\t// Kind is either \"audio\" or \"video\"\n\tKind string `json:\"kind\"`\n\n\t// It is a unique identifier that is associated to the object that was inspected\n\t// to produce the TransportStats associated with this RTP stream.\n\tTransportID string `json:\"transportId\"`\n\n\t// CodecID is a unique identifier that is associated to the object that was inspected\n\t// to produce the CodecStats associated with this RTP stream.\n\tCodecID string `json:\"codecId\"`\n\n\t// FIRCount counts the total number of Full Intra Request (FIR) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tFIRCount uint32 `json:\"firCount\"`\n\n\t// PLICount counts the total number of Picture Loss Indication (PLI) packets\n\t// received by the sender. This metric is only valid for video and is sent by receiver.\n\tPLICount uint32 `json:\"pliCount\"`\n\n\t// TotalProcessingDelay is the sum of the time, in seconds, each audio sample or video frame\n\t// takes from the time the first RTP packet is received (reception timestamp) and to the time\n\t// the corresponding sample or frame is decoded (decoded timestamp). At this point the audio\n\t// sample or video frame is ready for playout by the MediaStreamTrack. Typically ready for\n\t// playout here means after the audio sample or video frame is fully decoded by the decoder.\n\tTotalProcessingDelay float64 `json:\"totalProcessingDelay\"`\n\n\t// NACKCount counts the total number of Negative ACKnowledgement (NACK) packets\n\t// received by the sender and is sent by receiver.\n\tNACKCount uint32 `json:\"nackCount\"`\n\n\t// JitterBufferDelay is the sum of the time, in seconds, each audio sample or a video frame\n\t// takes from the time the first packet is received by the jitter buffer (ingest timestamp)\n\t// to the time it exits the jitter buffer (emit timestamp). The average jitter buffer delay\n\t// can be calculated by dividing the JitterBufferDelay with the JitterBufferEmittedCount.\n\tJitterBufferDelay float64 `json:\"jitterBufferDelay\"`\n\n\t// JitterBufferTargetDelay is increased by the target jitter buffer delay every time a sample is emitted\n\t// by the jitter buffer. The added target is the target delay, in seconds, at the time that\n\t// the sample was emitted from the jitter buffer. To get the average target delay,\n\t// divide by JitterBufferEmittedCount\n\tJitterBufferTargetDelay float64 `json:\"jitterBufferTargetDelay\"`\n\n\t// JitterBufferEmittedCount is the total number of audio samples or video frames that\n\t// have come out of the jitter buffer (increasing jitterBufferDelay).\n\tJitterBufferEmittedCount uint64 `json:\"jitterBufferEmittedCount\"`\n\n\t// JitterBufferMinimumDelay works the same way as jitterBufferTargetDelay, except that\n\t// it is not affected by external mechanisms that increase the jitter buffer target delay,\n\t// such as  jitterBufferTarget, AV sync, or any other mechanisms. This metric is purely\n\t// based on the network characteristics such as jitter and packet loss, and can be seen\n\t// as the minimum obtainable jitter  buffer delay if no external factors would affect it.\n\t// The metric is updated every time JitterBufferEmittedCount is updated.\n\tJitterBufferMinimumDelay float64 `json:\"jitterBufferMinimumDelay\"`\n\n\t// TotalSamplesReceived is the total number of samples that have been received on\n\t// this RTP stream. This includes concealedSamples. Does not exist for video.\n\tTotalSamplesReceived uint64 `json:\"totalSamplesReceived\"`\n\n\t// ConcealedSamples is the total number of samples that are concealed samples.\n\t// A concealed sample is a sample that was replaced with synthesized samples generated\n\t// locally before being played out. Examples of samples that have to be concealed are\n\t// samples from lost packets (reported in packetsLost) or samples from packets that\n\t// arrive too late to be played out (reported in packetsDiscarded). Does not exist for video.\n\tConcealedSamples uint64 `json:\"concealedSamples\"`\n\n\t// SilentConcealedSamples is the total number of concealed samples inserted that\n\t// are \"silent\". Playing out silent samples results in silence or comfort noise.\n\t// This is a subset of concealedSamples. Does not exist for video.\n\tSilentConcealedSamples uint64 `json:\"silentConcealedSamples\"`\n\n\t// ConcealmentEvents increases every time a concealed sample is synthesized after\n\t// a non-concealed sample. That is, multiple consecutive concealed samples will increase\n\t// the concealedSamples count multiple times but is a single concealment event.\n\t// Does not exist for video.\n\tConcealmentEvents uint64 `json:\"concealmentEvents\"`\n\n\t// InsertedSamplesForDeceleration is increased by the difference between the number of\n\t// samples received and the number of samples played out when playout is slowed down.\n\t// If playout is slowed down by inserting samples, this will be the number of inserted samples.\n\t// Does not exist for video.\n\tInsertedSamplesForDeceleration uint64 `json:\"insertedSamplesForDeceleration\"`\n\n\t// RemovedSamplesForAcceleration is increased by the difference between the number of\n\t// samples received and the number of samples played out when playout is sped up. If speedup\n\t// is achieved by removing samples, this will be the count of samples removed.\n\t// Does not exist for video.\n\tRemovedSamplesForAcceleration uint64 `json:\"removedSamplesForAcceleration\"`\n\n\t// AudioLevel represents the audio level of the receiving track..\n\t//\n\t// The value is a value between 0..1 (linear), where 1.0 represents 0 dBov,\n\t// 0 represents silence, and 0.5 represents approximately 6 dBSPL change in\n\t// the sound pressure level from 0 dBov. Does not exist for video.\n\tAudioLevel float64 `json:\"audioLevel\"`\n\n\t// TotalAudioEnergy represents the audio energy of the receiving track. It is calculated\n\t// by duration * Math.pow(energy/maxEnergy, 2) for each audio sample received (and thus\n\t// counted by TotalSamplesReceived). Does not exist for video.\n\tTotalAudioEnergy float64 `json:\"totalAudioEnergy\"`\n\n\t// TotalSamplesDuration represents the total duration in seconds of all samples that have been\n\t// received (and thus counted by TotalSamplesReceived). Can be used with totalAudioEnergy to\n\t// compute an average audio level over different intervals. Does not exist for video.\n\tTotalSamplesDuration float64 `json:\"totalSamplesDuration\"`\n\n\t// SLICount counts the total number of Slice Loss Indication (SLI) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tSLICount uint32 `json:\"sliCount\"`\n\n\t// QPSum is the sum of the QP values of frames passed. The count of frames is\n\t// in FramesDecoded for inbound stream stats, and in FramesEncoded for outbound stream stats.\n\tQPSum uint64 `json:\"qpSum\"`\n\n\t// TotalDecodeTime is the total number of seconds that have been spent decoding the FramesDecoded\n\t// frames of this stream. The average decode time can be calculated by dividing this value\n\t// with FramesDecoded. The time it takes to decode one frame is the time passed between\n\t// feeding the decoder a frame and the decoder returning decoded data for that frame.\n\tTotalDecodeTime float64 `json:\"totalDecodeTime\"`\n\n\t// TotalInterFrameDelay is the sum of the interframe delays in seconds between consecutively\n\t// rendered frames, recorded just after a frame has been rendered. The interframe delay variance\n\t// be calculated from TotalInterFrameDelay, TotalSquaredInterFrameDelay, and FramesRendered according\n\t// to the formula: (TotalSquaredInterFrameDelay - TotalInterFrameDelay^2 / FramesRendered) / FramesRendered.\n\t// Does not exist for audio.\n\tTotalInterFrameDelay float64 `json:\"totalInterFrameDelay\"`\n\n\t// TotalSquaredInterFrameDelay is the sum of the squared interframe delays in seconds\n\t// between consecutively rendered frames, recorded just after a frame has been rendered.\n\t// See TotalInterFrameDelay for details on how to calculate the interframe delay variance.\n\t// Does not exist for audio.\n\tTotalSquaredInterFrameDelay float64 `json:\"totalSquaredInterFrameDelay\"`\n\n\t// PacketsReceived is the total number of RTP packets received for this SSRC.\n\tPacketsReceived uint32 `json:\"packetsReceived\"`\n\n\t// PacketsLost is the total number of RTP packets lost for this SSRC. Note that\n\t// because of how this is estimated, it can be negative if more packets are received than sent.\n\tPacketsLost int32 `json:\"packetsLost\"`\n\n\t// Jitter is the packet jitter measured in seconds for this SSRC\n\tJitter float64 `json:\"jitter\"`\n\n\t// PacketsDiscarded is the cumulative number of RTP packets discarded by the jitter\n\t// buffer due to late or early-arrival, i.e., these packets are not played out.\n\t// RTP packets discarded due to packet duplication are not reported in this metric.\n\tPacketsDiscarded uint32 `json:\"packetsDiscarded\"`\n\n\t// PacketsRepaired is the cumulative number of lost RTP packets repaired after applying\n\t// an error-resilience mechanism. It is measured for the primary source RTP packets\n\t// and only counted for RTP packets that have no further chance of repair.\n\tPacketsRepaired uint32 `json:\"packetsRepaired\"`\n\n\t// BurstPacketsLost is the cumulative number of RTP packets lost during loss bursts.\n\tBurstPacketsLost uint32 `json:\"burstPacketsLost\"`\n\n\t// BurstPacketsDiscarded is the cumulative number of RTP packets discarded during discard bursts.\n\tBurstPacketsDiscarded uint32 `json:\"burstPacketsDiscarded\"`\n\n\t// BurstLossCount is the cumulative number of bursts of lost RTP packets.\n\tBurstLossCount uint32 `json:\"burstLossCount\"`\n\n\t// BurstDiscardCount is the cumulative number of bursts of discarded RTP packets.\n\tBurstDiscardCount uint32 `json:\"burstDiscardCount\"`\n\n\t// BurstLossRate is the fraction of RTP packets lost during bursts to the\n\t// total number of RTP packets expected in the bursts.\n\tBurstLossRate float64 `json:\"burstLossRate\"`\n\n\t// BurstDiscardRate is the fraction of RTP packets discarded during bursts to\n\t// the total number of RTP packets expected in bursts.\n\tBurstDiscardRate float64 `json:\"burstDiscardRate\"`\n\n\t// GapLossRate is the fraction of RTP packets lost during the gap periods.\n\tGapLossRate float64 `json:\"gapLossRate\"`\n\n\t// GapDiscardRate is the fraction of RTP packets discarded during the gap periods.\n\tGapDiscardRate float64 `json:\"gapDiscardRate\"`\n\n\t// TrackID is the identifier of the stats object representing the receiving track,\n\t// a ReceiverAudioTrackAttachmentStats or ReceiverVideoTrackAttachmentStats.\n\tTrackID string `json:\"trackId\"`\n\n\t// ReceiverID is the stats ID used to look up the AudioReceiverStats or VideoReceiverStats\n\t// object receiving this stream.\n\tReceiverID string `json:\"receiverId\"`\n\n\t// RemoteID is used for looking up the remote RemoteOutboundRTPStreamStats object\n\t// for the same SSRC.\n\tRemoteID string `json:\"remoteId\"`\n\n\t// FramesDecoded represents the total number of frames correctly decoded for this SSRC,\n\t// i.e., frames that would be displayed if no frames are dropped. Only valid for video.\n\tFramesDecoded uint32 `json:\"framesDecoded\"`\n\n\t// KeyFramesDecoded represents the total number of key frames, such as key frames in\n\t// VP8 [RFC6386] or IDR-frames in H.264 [RFC6184], successfully decoded for this RTP\n\t// media stream. This is a subset of FramesDecoded. FramesDecoded - KeyFramesDecoded\n\t// gives you the number of delta frames decoded. Does not exist for audio.\n\tKeyFramesDecoded uint32 `json:\"keyFramesDecoded\"`\n\n\t// FramesRendered represents the total number of frames that have been rendered.\n\t// It is incremented just after a frame has been rendered. Does not exist for audio.\n\tFramesRendered uint32 `json:\"framesRendered\"`\n\n\t// FramesDropped is the total number of frames dropped prior to decode or dropped\n\t// because the frame missed its display deadline for this receiver's track.\n\t// The measurement begins when the receiver is created and is a cumulative metric\n\t// as defined in Appendix A (g) of [RFC7004]. Does not exist for audio.\n\tFramesDropped uint32 `json:\"framesDropped\"`\n\n\t// FrameWidth represents the width of the last decoded frame. Before the first\n\t// frame is decoded this member does not exist. Does not exist for audio.\n\tFrameWidth uint32 `json:\"frameWidth\"`\n\n\t// FrameHeight represents the height of the last decoded frame. Before the first\n\t// frame is decoded this member does not exist. Does not exist for audio.\n\tFrameHeight uint32 `json:\"frameHeight\"`\n\n\t// LastPacketReceivedTimestamp represents the timestamp at which the last packet was\n\t// received for this SSRC. This differs from Timestamp, which represents the time\n\t// at which the statistics were generated by the local endpoint.\n\tLastPacketReceivedTimestamp StatsTimestamp `json:\"lastPacketReceivedTimestamp\"`\n\n\t// HeaderBytesReceived is the total number of RTP header and padding bytes received for this SSRC.\n\t// This includes retransmissions. This does not include the size of transport layer headers such\n\t// as IP or UDP. headerBytesReceived + bytesReceived equals the number of bytes received as\n\t// payload over the transport.\n\tHeaderBytesReceived uint64 `json:\"headerBytesReceived\"`\n\n\t// AverageRTCPInterval is the average RTCP interval between two consecutive compound RTCP packets.\n\t// This is calculated by the sending endpoint when sending compound RTCP reports.\n\t// Compound packets must contain at least a RTCP RR or SR packet and an SDES packet\n\t// with the CNAME item.\n\tAverageRTCPInterval float64 `json:\"averageRtcpInterval\"`\n\n\t// FECPacketsReceived is the total number of RTP FEC packets received for this SSRC.\n\t// This counter can also be incremented when receiving FEC packets in-band with media packets (e.g., with Opus).\n\tFECPacketsReceived uint32 `json:\"fecPacketsReceived\"`\n\n\t// FECPacketsDiscarded is the total number of RTP FEC packets received for this SSRC where the\n\t// error correction payload was discarded by the application. This may happen\n\t// 1. if all the source packets protected by the FEC packet were received or already\n\t// recovered by a separate FEC packet, or\n\t// 2. if the FEC packet arrived late, i.e., outside the recovery window, and the\n\t// lost RTP packets have already been skipped during playout.\n\t// This is a subset of FECPacketsReceived.\n\tFECPacketsDiscarded uint64 `json:\"fecPacketsDiscarded\"`\n\n\t// BytesReceived is the total number of bytes received for this SSRC.\n\tBytesReceived uint64 `json:\"bytesReceived\"`\n\n\t// FramesReceived represents the total number of complete frames received on this RTP stream.\n\t// This metric is incremented when the complete frame is received. Does not exist for audio.\n\tFramesReceived uint32 `json:\"framesReceived\"`\n\n\t// PacketsFailedDecryption is the cumulative number of RTP packets that failed\n\t// to be decrypted. These packets are not counted by PacketsDiscarded.\n\tPacketsFailedDecryption uint32 `json:\"packetsFailedDecryption\"`\n\n\t// PacketsDuplicated is the cumulative number of packets discarded because they\n\t// are duplicated. Duplicate packets are not counted in PacketsDiscarded.\n\t//\n\t// Duplicated packets have the same RTP sequence number and content as a previously\n\t// received packet. If multiple duplicates of a packet are received, all of them are counted.\n\t// An improved estimate of lost packets can be calculated by adding PacketsDuplicated to PacketsLost.\n\tPacketsDuplicated uint32 `json:\"packetsDuplicated\"`\n\n\t// PerDSCPPacketsReceived is the total number of packets received for this SSRC,\n\t// per Differentiated Services code point (DSCP) [RFC2474]. DSCPs are identified\n\t// as decimal integers in string form. Note that due to network remapping and bleaching,\n\t// these numbers are not expected to match the numbers seen on sending. Not all\n\t// OSes make this information available.\n\tPerDSCPPacketsReceived map[string]uint32 `json:\"perDscpPacketsReceived\"`\n\n\t// Identifies the decoder implementation used. This is useful for diagnosing interoperability issues.\n\t// Does not exist for audio.\n\tDecoderImplementation string `json:\"decoderImplementation\"`\n\n\t// PauseCount is the total number of video pauses experienced by this receiver.\n\t// Video is considered to be paused if time passed since last rendered frame exceeds 5 seconds.\n\t// PauseCount is incremented when a frame is rendered after such a pause. Does not exist for audio.\n\tPauseCount uint32 `json:\"pauseCount\"`\n\n\t// TotalPausesDuration is the total duration of pauses (for definition of pause see PauseCount), in seconds.\n\t// Does not exist for audio.\n\tTotalPausesDuration float64 `json:\"totalPausesDuration\"`\n\n\t// FreezeCount is the total number of video freezes experienced by this receiver.\n\t// It is a freeze if frame duration, which is time interval between two consecutively rendered frames,\n\t// is equal or exceeds Max(3 * avg_frame_duration_ms, avg_frame_duration_ms + 150),\n\t// where avg_frame_duration_ms is linear average of durations of last 30 rendered frames.\n\t// Does not exist for audio.\n\tFreezeCount uint32 `json:\"freezeCount\"`\n\n\t// TotalFreezesDuration is the total duration of rendered frames which are considered as frozen\n\t// (for definition of freeze see freezeCount), in seconds. Does not exist for audio.\n\tTotalFreezesDuration float64 `json:\"totalFreezesDuration\"`\n\n\t// PowerEfficientDecoder indicates whether the decoder currently used is considered power efficient\n\t// by the user agent. Does not exist for audio.\n\tPowerEfficientDecoder bool `json:\"powerEfficientDecoder\"`\n}\n\nfunc (s InboundRTPStreamStats) statsMarker() {}\n\nfunc unmarshalInboundRTPStreamStats(b []byte) (InboundRTPStreamStats, error) {\n\tvar inboundRTPStreamStats InboundRTPStreamStats\n\terr := json.Unmarshal(b, &inboundRTPStreamStats)\n\tif err != nil {\n\t\treturn InboundRTPStreamStats{}, fmt.Errorf(\"unmarshal inbound rtp stream stats: %w\", err)\n\t}\n\treturn inboundRTPStreamStats, nil\n}\n\n// QualityLimitationReason lists the reason for limiting the resolution and/or framerate.\n// Only valid for video.\ntype QualityLimitationReason string\n\nconst (\n\t// QualityLimitationReasonNone means the resolution and/or framerate is not limited.\n\tQualityLimitationReasonNone QualityLimitationReason = \"none\"\n\n\t// QualityLimitationReasonCPU means the resolution and/or framerate is primarily limited due to CPU load.\n\tQualityLimitationReasonCPU QualityLimitationReason = \"cpu\"\n\n\t// QualityLimitationReasonBandwidth means the resolution and/or framerate is primarily limited due to congestion cues during bandwidth estimation. Typical, congestion control algorithms use inter-arrival time, round-trip time, packet or other congestion cues to perform bandwidth estimation.\n\tQualityLimitationReasonBandwidth QualityLimitationReason = \"bandwidth\"\n\n\t// QualityLimitationReasonOther means the resolution and/or framerate is primarily limited for a reason other than the above.\n\tQualityLimitationReasonOther QualityLimitationReason = \"other\"\n)\n\n// OutboundRTPStreamStats contains statistics for an outbound RTP stream that is\n// currently sent with this PeerConnection object.\ntype OutboundRTPStreamStats struct {\n\t// Mid represents a mid value of RTPTransceiver owning this stream, if that value is not\n\t// null. Otherwise, this member is not present.\n\tMid string `json:\"mid\"`\n\n\t// Rid only exists if a rid has been set for this RTP stream.\n\t// Must not exist for audio.\n\tRid string `json:\"rid\"`\n\n\t// MediaSourceID is the identifier of the stats object representing the track currently\n\t// attached to the sender of this stream, an RTCMediaSourceStats.\n\tMediaSourceID string `json:\"mediaSourceId\"`\n\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// SSRC is the 32-bit unsigned integer value used to identify the source of the\n\t// stream of RTP packets that this stats object concerns.\n\tSSRC SSRC `json:\"ssrc\"`\n\n\t// Kind is either \"audio\" or \"video\"\n\tKind string `json:\"kind\"`\n\n\t// It is a unique identifier that is associated to the object that was inspected\n\t// to produce the TransportStats associated with this RTP stream.\n\tTransportID string `json:\"transportId\"`\n\n\t// CodecID is a unique identifier that is associated to the object that was inspected\n\t// to produce the CodecStats associated with this RTP stream.\n\tCodecID string `json:\"codecId\"`\n\n\t// HeaderBytesSent is the total number of RTP header and padding bytes sent for this SSRC. This does not\n\t// include the size of transport layer headers such as IP or UDP.\n\t// HeaderBytesSent + BytesSent equals the number of bytes sent as payload over the transport.\n\tHeaderBytesSent uint64 `json:\"headerBytesSent\"`\n\n\t// RetransmittedPacketsSent is the total number of packets that were retransmitted for this SSRC.\n\t// This is a subset of packetsSent. If RTX is not negotiated, retransmitted packets are sent\n\t// over this ssrc. If RTX was negotiated, retransmitted packets are sent over a separate SSRC\n\t// but is still accounted for here.\n\tRetransmittedPacketsSent uint64 `json:\"retransmittedPacketsSent\"`\n\n\t// RetransmittedBytesSent is the total number of bytes that were retransmitted for this SSRC,\n\t// only including payload bytes. This is a subset of bytesSent. If RTX is not negotiated,\n\t// retransmitted bytes are sent over this ssrc. If RTX was negotiated, retransmitted bytes\n\t// are sent over a separate SSRC but is still accounted for here.\n\tRetransmittedBytesSent uint64 `json:\"retransmittedBytesSent\"`\n\n\t// FIRCount counts the total number of Full Intra Request (FIR) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tFIRCount uint32 `json:\"firCount\"`\n\n\t// PLICount counts the total number of Picture Loss Indication (PLI) packets\n\t// received by the sender. This metric is only valid for video and is sent by receiver.\n\tPLICount uint32 `json:\"pliCount\"`\n\n\t// NACKCount counts the total number of Negative ACKnowledgement (NACK) packets\n\t// received by the sender and is sent by receiver.\n\tNACKCount uint32 `json:\"nackCount\"`\n\n\t// SLICount counts the total number of Slice Loss Indication (SLI) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tSLICount uint32 `json:\"sliCount\"`\n\n\t// QPSum is the sum of the QP values of frames passed. The count of frames is\n\t// in FramesDecoded for inbound stream stats, and in FramesEncoded for outbound stream stats.\n\tQPSum uint64 `json:\"qpSum\"`\n\n\t// PacketsSent is the total number of RTP packets sent for this SSRC.\n\tPacketsSent uint32 `json:\"packetsSent\"`\n\n\t// PacketsDiscardedOnSend is the total number of RTP packets for this SSRC that\n\t// have been discarded due to socket errors, i.e. a socket error occurred when handing\n\t// the packets to the socket. This might happen due to various reasons, including\n\t// full buffer or no available memory.\n\tPacketsDiscardedOnSend uint32 `json:\"packetsDiscardedOnSend\"`\n\n\t// FECPacketsSent is the total number of RTP FEC packets sent for this SSRC.\n\t// This counter can also be incremented when sending FEC packets in-band with\n\t// media packets (e.g., with Opus).\n\tFECPacketsSent uint32 `json:\"fecPacketsSent\"`\n\n\t// BytesSent is the total number of bytes sent for this SSRC.\n\tBytesSent uint64 `json:\"bytesSent\"`\n\n\t// BytesDiscardedOnSend is the total number of bytes for this SSRC that have\n\t// been discarded due to socket errors, i.e. a socket error occurred when handing\n\t// the packets containing the bytes to the socket. This might happen due to various\n\t// reasons, including full buffer or no available memory.\n\tBytesDiscardedOnSend uint64 `json:\"bytesDiscardedOnSend\"`\n\n\t// TrackID is the identifier of the stats object representing the current track\n\t// attachment to the sender of this stream, a SenderAudioTrackAttachmentStats\n\t// or SenderVideoTrackAttachmentStats.\n\tTrackID string `json:\"trackId\"`\n\n\t// SenderID is the stats ID used to look up the AudioSenderStats or VideoSenderStats\n\t// object sending this stream.\n\tSenderID string `json:\"senderId\"`\n\n\t// RemoteID is used for looking up the remote RemoteInboundRTPStreamStats object\n\t// for the same SSRC.\n\tRemoteID string `json:\"remoteId\"`\n\n\t// LastPacketSentTimestamp represents the timestamp at which the last packet was\n\t// sent for this SSRC. This differs from timestamp, which represents the time at\n\t// which the statistics were generated by the local endpoint.\n\tLastPacketSentTimestamp StatsTimestamp `json:\"lastPacketSentTimestamp\"`\n\n\t// TargetBitrate is the current target bitrate configured for this particular SSRC\n\t// and is the Transport Independent Application Specific (TIAS) bitrate [RFC3890].\n\t// Typically, the target bitrate is a configuration parameter provided to the codec's\n\t// encoder and does not count the size of the IP or other transport layers like TCP or UDP.\n\t// It is measured in bits per second and the bitrate is calculated over a 1 second window.\n\tTargetBitrate float64 `json:\"targetBitrate\"`\n\n\t// TotalEncodedBytesTarget is increased by the target frame size in bytes every time\n\t// a frame has been encoded. The actual frame size may be bigger or smaller than this number.\n\t// This value goes up every time framesEncoded goes up.\n\tTotalEncodedBytesTarget uint64 `json:\"totalEncodedBytesTarget\"`\n\n\t// FrameWidth represents the width of the last encoded frame. The resolution of the\n\t// encoded frame may be lower than the media source. Before the first frame is encoded\n\t// this member does not exist. Does not exist for audio.\n\tFrameWidth uint32 `json:\"frameWidth\"`\n\n\t// FrameHeight represents the height of the last encoded frame. The resolution of the\n\t// encoded frame may be lower than the media source. Before the first frame is encoded\n\t// this member does not exist. Does not exist for audio.\n\tFrameHeight uint32 `json:\"frameHeight\"`\n\n\t// FramesPerSecond is the number of encoded frames during the last second. This may be\n\t// lower than the media source frame rate. Does not exist for audio.\n\tFramesPerSecond float64 `json:\"framesPerSecond\"`\n\n\t// FramesSent represents the total number of frames sent on this RTP stream. Does not exist for audio.\n\tFramesSent uint32 `json:\"framesSent\"`\n\n\t// HugeFramesSent represents the total number of huge frames sent by this RTP stream.\n\t// Huge frames, by definition, are frames that have an encoded size at least 2.5 times\n\t// the average size of the frames. The average size of the frames is defined as the\n\t// target bitrate per second divided by the target FPS at the time the frame was encoded.\n\t// These are usually complex to encode frames with a lot of changes in the picture.\n\t// This can be used to estimate, e.g slide changes in the streamed presentation.\n\t// Does not exist for audio.\n\tHugeFramesSent uint32 `json:\"hugeFramesSent\"`\n\n\t// FramesEncoded represents the total number of frames successfully encoded for this RTP media stream.\n\t// Only valid for video.\n\tFramesEncoded uint32 `json:\"framesEncoded\"`\n\n\t// KeyFramesEncoded represents the total number of key frames, such as key frames in VP8 [RFC6386] or\n\t// IDR-frames in H.264 [RFC6184], successfully encoded for this RTP media stream. This is a subset of\n\t// FramesEncoded. FramesEncoded - KeyFramesEncoded gives you the number of delta frames encoded.\n\t// Does not exist for audio.\n\tKeyFramesEncoded uint32 `json:\"keyFramesEncoded\"`\n\n\t// TotalEncodeTime is the total number of seconds that has been spent encoding the\n\t// framesEncoded frames of this stream. The average encode time can be calculated by\n\t// dividing this value with FramesEncoded. The time it takes to encode one frame is the\n\t// time passed between feeding the encoder a frame and the encoder returning encoded data\n\t// for that frame. This does not include any additional time it may take to packetize the resulting data.\n\tTotalEncodeTime float64 `json:\"totalEncodeTime\"`\n\n\t// TotalPacketSendDelay is the total number of seconds that packets have spent buffered\n\t// locally before being transmitted onto the network. The time is measured from when\n\t// a packet is emitted from the RTP packetizer until it is handed over to the OS network socket.\n\t// This measurement is added to totalPacketSendDelay when packetsSent is incremented.\n\tTotalPacketSendDelay float64 `json:\"totalPacketSendDelay\"`\n\n\t// AverageRTCPInterval is the average RTCP interval between two consecutive compound RTCP\n\t// packets. This is calculated by the sending endpoint when sending compound RTCP reports.\n\t// Compound packets must contain at least a RTCP RR or SR packet and an SDES packet with the CNAME item.\n\tAverageRTCPInterval float64 `json:\"averageRtcpInterval\"`\n\n\t// QualityLimitationReason is the current reason for limiting the resolution and/or framerate,\n\t// or \"none\" if not limited. Only valid for video.\n\tQualityLimitationReason QualityLimitationReason `json:\"qualityLimitationReason\"`\n\n\t// QualityLimitationDurations is record of the total time, in seconds, that this\n\t// stream has spent in each quality limitation state. The record includes a mapping\n\t// for all QualityLimitationReason types, including \"none\". Only valid for video.\n\tQualityLimitationDurations map[string]float64 `json:\"qualityLimitationDurations\"`\n\n\t// QualityLimitationResolutionChanges is the number of times that the resolution has changed\n\t// because we are quality limited (qualityLimitationReason has a value other than \"none\").\n\t// The counter is initially zero and increases when the resolution goes up or down.\n\t// For example, if a 720p track is sent as 480p for some time and then recovers to 720p,\n\t// qualityLimitationResolutionChanges will have the value 2. Does not exist for audio.\n\tQualityLimitationResolutionChanges uint32 `json:\"qualityLimitationResolutionChanges\"`\n\n\t// PerDSCPPacketsSent is the total number of packets sent for this SSRC, per DSCP.\n\t// DSCPs are identified as decimal integers in string form.\n\tPerDSCPPacketsSent map[string]uint32 `json:\"perDscpPacketsSent\"`\n\n\t// Active indicates whether this RTP stream is configured to be sent or disabled. Note that an\n\t// active stream can still not be sending, e.g. when being limited by network conditions.\n\tActive bool `json:\"active\"`\n\n\t// Identifies the encoder implementation used. This is useful for diagnosing interoperability issues.\n\t// Does not exist for audio.\n\tEncoderImplementation string `json:\"encoderImplementation\"`\n\n\t// PowerEfficientEncoder indicates whether the encoder currently used is considered power efficient.\n\t// by the user agent. Does not exist for audio.\n\tPowerEfficientEncoder bool `json:\"powerEfficientEncoder\"`\n\n\t// ScalabilityMode identifies the layering mode used for video encoding. Does not exist for audio.\n\tScalabilityMode string `json:\"scalabilityMode\"`\n}\n\nfunc (s OutboundRTPStreamStats) statsMarker() {}\n\nfunc unmarshalOutboundRTPStreamStats(b []byte) (OutboundRTPStreamStats, error) {\n\tvar outboundRTPStreamStats OutboundRTPStreamStats\n\terr := json.Unmarshal(b, &outboundRTPStreamStats)\n\tif err != nil {\n\t\treturn OutboundRTPStreamStats{}, fmt.Errorf(\"unmarshal outbound rtp stream stats: %w\", err)\n\t}\n\treturn outboundRTPStreamStats, nil\n}\n\n// RemoteInboundRTPStreamStats contains statistics for the remote endpoint's inbound\n// RTP stream corresponding to an outbound stream that is currently sent with this\n// PeerConnection object. It is measured at the remote endpoint and reported in an RTCP\n// Receiver Report (RR) or RTCP Extended Report (XR).\ntype RemoteInboundRTPStreamStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// SSRC is the 32-bit unsigned integer value used to identify the source of the\n\t// stream of RTP packets that this stats object concerns.\n\tSSRC SSRC `json:\"ssrc\"`\n\n\t// Kind is either \"audio\" or \"video\"\n\tKind string `json:\"kind\"`\n\n\t// It is a unique identifier that is associated to the object that was inspected\n\t// to produce the TransportStats associated with this RTP stream.\n\tTransportID string `json:\"transportId\"`\n\n\t// CodecID is a unique identifier that is associated to the object that was inspected\n\t// to produce the CodecStats associated with this RTP stream.\n\tCodecID string `json:\"codecId\"`\n\n\t// FIRCount counts the total number of Full Intra Request (FIR) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tFIRCount uint32 `json:\"firCount\"`\n\n\t// PLICount counts the total number of Picture Loss Indication (PLI) packets\n\t// received by the sender. This metric is only valid for video and is sent by receiver.\n\tPLICount uint32 `json:\"pliCount\"`\n\n\t// NACKCount counts the total number of Negative ACKnowledgement (NACK) packets\n\t// received by the sender and is sent by receiver.\n\tNACKCount uint32 `json:\"nackCount\"`\n\n\t// SLICount counts the total number of Slice Loss Indication (SLI) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tSLICount uint32 `json:\"sliCount\"`\n\n\t// QPSum is the sum of the QP values of frames passed. The count of frames is\n\t// in FramesDecoded for inbound stream stats, and in FramesEncoded for outbound stream stats.\n\tQPSum uint64 `json:\"qpSum\"`\n\n\t// PacketsReceived is the total number of RTP packets received for this SSRC.\n\tPacketsReceived uint32 `json:\"packetsReceived\"`\n\n\t// PacketsLost is the total number of RTP packets lost for this SSRC. Note that\n\t// because of how this is estimated, it can be negative if more packets are received than sent.\n\tPacketsLost int32 `json:\"packetsLost\"`\n\n\t// Jitter is the packet jitter measured in seconds for this SSRC\n\tJitter float64 `json:\"jitter\"`\n\n\t// PacketsDiscarded is the cumulative number of RTP packets discarded by the jitter\n\t// buffer due to late or early-arrival, i.e., these packets are not played out.\n\t// RTP packets discarded due to packet duplication are not reported in this metric.\n\tPacketsDiscarded uint32 `json:\"packetsDiscarded\"`\n\n\t// PacketsRepaired is the cumulative number of lost RTP packets repaired after applying\n\t// an error-resilience mechanism. It is measured for the primary source RTP packets\n\t// and only counted for RTP packets that have no further chance of repair.\n\tPacketsRepaired uint32 `json:\"packetsRepaired\"`\n\n\t// BurstPacketsLost is the cumulative number of RTP packets lost during loss bursts.\n\tBurstPacketsLost uint32 `json:\"burstPacketsLost\"`\n\n\t// BurstPacketsDiscarded is the cumulative number of RTP packets discarded during discard bursts.\n\tBurstPacketsDiscarded uint32 `json:\"burstPacketsDiscarded\"`\n\n\t// BurstLossCount is the cumulative number of bursts of lost RTP packets.\n\tBurstLossCount uint32 `json:\"burstLossCount\"`\n\n\t// BurstDiscardCount is the cumulative number of bursts of discarded RTP packets.\n\tBurstDiscardCount uint32 `json:\"burstDiscardCount\"`\n\n\t// BurstLossRate is the fraction of RTP packets lost during bursts to the\n\t// total number of RTP packets expected in the bursts.\n\tBurstLossRate float64 `json:\"burstLossRate\"`\n\n\t// BurstDiscardRate is the fraction of RTP packets discarded during bursts to\n\t// the total number of RTP packets expected in bursts.\n\tBurstDiscardRate float64 `json:\"burstDiscardRate\"`\n\n\t// GapLossRate is the fraction of RTP packets lost during the gap periods.\n\tGapLossRate float64 `json:\"gapLossRate\"`\n\n\t// GapDiscardRate is the fraction of RTP packets discarded during the gap periods.\n\tGapDiscardRate float64 `json:\"gapDiscardRate\"`\n\n\t// LocalID is used for looking up the local OutboundRTPStreamStats object for the same SSRC.\n\tLocalID string `json:\"localId\"`\n\n\t// RoundTripTime is the estimated round trip time for this SSRC based on the\n\t// RTCP timestamps in the RTCP Receiver Report (RR) and measured in seconds.\n\tRoundTripTime float64 `json:\"roundTripTime\"`\n\n\t// TotalRoundTripTime represents the cumulative sum of all round trip time measurements\n\t// in seconds since the beginning of the session. The individual round trip time is calculated\n\t// based on the RTCP timestamps in the RTCP Receiver Report (RR) [RFC3550], hence requires\n\t// a DLSR value other than 0. The average round trip time can be computed from\n\t// TotalRoundTripTime by dividing it by RoundTripTimeMeasurements.\n\tTotalRoundTripTime float64 `json:\"totalRoundTripTime\"`\n\n\t// FractionLost is the fraction packet loss reported for this SSRC.\n\tFractionLost float64 `json:\"fractionLost\"`\n\n\t// RoundTripTimeMeasurements represents the total number of RTCP RR blocks received for this SSRC\n\t// that contain a valid round trip time. This counter will not increment if the RoundTripTime can\n\t// not be calculated because no RTCP Receiver Report with a DLSR value other than 0 has been received.\n\tRoundTripTimeMeasurements uint64 `json:\"roundTripTimeMeasurements\"`\n}\n\nfunc (s RemoteInboundRTPStreamStats) statsMarker() {}\n\nfunc unmarshalRemoteInboundRTPStreamStats(b []byte) (RemoteInboundRTPStreamStats, error) {\n\tvar remoteInboundRTPStreamStats RemoteInboundRTPStreamStats\n\terr := json.Unmarshal(b, &remoteInboundRTPStreamStats)\n\tif err != nil {\n\t\treturn RemoteInboundRTPStreamStats{}, fmt.Errorf(\"unmarshal remote inbound rtp stream stats: %w\", err)\n\t}\n\treturn remoteInboundRTPStreamStats, nil\n}\n\n// RemoteOutboundRTPStreamStats contains statistics for the remote endpoint's outbound\n// RTP stream corresponding to an inbound stream that is currently received with this\n// PeerConnection object. It is measured at the remote endpoint and reported in an\n// RTCP Sender Report (SR).\ntype RemoteOutboundRTPStreamStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// SSRC is the 32-bit unsigned integer value used to identify the source of the\n\t// stream of RTP packets that this stats object concerns.\n\tSSRC SSRC `json:\"ssrc\"`\n\n\t// Kind is either \"audio\" or \"video\"\n\tKind string `json:\"kind\"`\n\n\t// It is a unique identifier that is associated to the object that was inspected\n\t// to produce the TransportStats associated with this RTP stream.\n\tTransportID string `json:\"transportId\"`\n\n\t// CodecID is a unique identifier that is associated to the object that was inspected\n\t// to produce the CodecStats associated with this RTP stream.\n\tCodecID string `json:\"codecId\"`\n\n\t// FIRCount counts the total number of Full Intra Request (FIR) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tFIRCount uint32 `json:\"firCount\"`\n\n\t// PLICount counts the total number of Picture Loss Indication (PLI) packets\n\t// received by the sender. This metric is only valid for video and is sent by receiver.\n\tPLICount uint32 `json:\"pliCount\"`\n\n\t// NACKCount counts the total number of Negative ACKnowledgement (NACK) packets\n\t// received by the sender and is sent by receiver.\n\tNACKCount uint32 `json:\"nackCount\"`\n\n\t// SLICount counts the total number of Slice Loss Indication (SLI) packets received\n\t// by the sender. This metric is only valid for video and is sent by receiver.\n\tSLICount uint32 `json:\"sliCount\"`\n\n\t// QPSum is the sum of the QP values of frames passed. The count of frames is\n\t// in FramesDecoded for inbound stream stats, and in FramesEncoded for outbound stream stats.\n\tQPSum uint64 `json:\"qpSum\"`\n\n\t// PacketsSent is the total number of RTP packets sent for this SSRC.\n\tPacketsSent uint32 `json:\"packetsSent\"`\n\n\t// PacketsDiscardedOnSend is the total number of RTP packets for this SSRC that\n\t// have been discarded due to socket errors, i.e. a socket error occurred when handing\n\t// the packets to the socket. This might happen due to various reasons, including\n\t// full buffer or no available memory.\n\tPacketsDiscardedOnSend uint32 `json:\"packetsDiscardedOnSend\"`\n\n\t// FECPacketsSent is the total number of RTP FEC packets sent for this SSRC.\n\t// This counter can also be incremented when sending FEC packets in-band with\n\t// media packets (e.g., with Opus).\n\tFECPacketsSent uint32 `json:\"fecPacketsSent\"`\n\n\t// BytesSent is the total number of bytes sent for this SSRC.\n\tBytesSent uint64 `json:\"bytesSent\"`\n\n\t// BytesDiscardedOnSend is the total number of bytes for this SSRC that have\n\t// been discarded due to socket errors, i.e. a socket error occurred when handing\n\t// the packets containing the bytes to the socket. This might happen due to various\n\t// reasons, including full buffer or no available memory.\n\tBytesDiscardedOnSend uint64 `json:\"bytesDiscardedOnSend\"`\n\n\t// LocalID is used for looking up the local InboundRTPStreamStats object for the same SSRC.\n\tLocalID string `json:\"localId\"`\n\n\t// RemoteTimestamp represents the remote timestamp at which these statistics were\n\t// sent by the remote endpoint. This differs from timestamp, which represents the\n\t// time at which the statistics were generated or received by the local endpoint.\n\t// The RemoteTimestamp, if present, is derived from the NTP timestamp in an RTCP\n\t// Sender Report (SR) packet, which reflects the remote endpoint's clock.\n\t// That clock may not be synchronized with the local clock.\n\tRemoteTimestamp StatsTimestamp `json:\"remoteTimestamp\"`\n\n\t// ReportsSent represents the total number of RTCP Sender Report (SR) blocks sent for this SSRC.\n\tReportsSent uint64 `json:\"reportsSent\"`\n\n\t// RoundTripTime is estimated round trip time for this SSRC based on the latest\n\t// RTCP Sender Report (SR) that contains a DLRR report block as defined in [RFC3611].\n\t// The Calculation of the round trip time is defined in section 4.5. of [RFC3611].\n\t// Does not exist if the latest SR does not contain the DLRR report block, or if the last RR timestamp\n\t// in the DLRR report block is zero, or if the delay since last RR value in the DLRR report block is zero.\n\tRoundTripTime float64 `json:\"roundTripTime\"`\n\n\t// TotalRoundTripTime represents the cumulative sum of all round trip time measurements in seconds\n\t// since the beginning of the session. The individual round trip time is calculated based on the DLRR\n\t// report block in the RTCP Sender Report (SR) [RFC3611]. This counter will not increment if the\n\t// RoundTripTime can not be calculated. The average round trip time can be computed from\n\t// TotalRoundTripTime by dividing it by RoundTripTimeMeasurements.\n\tTotalRoundTripTime float64 `json:\"totalRoundTripTime\"`\n\n\t// RoundTripTimeMeasurements represents the total number of RTCP Sender Report (SR) blocks\n\t// received for this SSRC that contain a DLRR report block that can derive a valid round trip time\n\t// according to [RFC3611]. This counter will not increment if the RoundTripTime can not be calculated.\n\tRoundTripTimeMeasurements uint64 `json:\"roundTripTimeMeasurements\"`\n}\n\nfunc (s RemoteOutboundRTPStreamStats) statsMarker() {}\n\nfunc unmarshalRemoteOutboundRTPStreamStats(b []byte) (RemoteOutboundRTPStreamStats, error) {\n\tvar remoteOutboundRTPStreamStats RemoteOutboundRTPStreamStats\n\terr := json.Unmarshal(b, &remoteOutboundRTPStreamStats)\n\tif err != nil {\n\t\treturn RemoteOutboundRTPStreamStats{}, fmt.Errorf(\"unmarshal remote outbound rtp stream stats: %w\", err)\n\t}\n\treturn remoteOutboundRTPStreamStats, nil\n}\n\n// RTPContributingSourceStats contains statistics for a contributing source (CSRC) that contributed\n// to an inbound RTP stream.\ntype RTPContributingSourceStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// ContributorSSRC is the SSRC identifier of the contributing source represented\n\t// by this stats object. It is a 32-bit unsigned integer that appears in the CSRC\n\t// list of any packets the relevant source contributed to.\n\tContributorSSRC SSRC `json:\"contributorSsrc\"`\n\n\t// InboundRTPStreamID is the ID of the InboundRTPStreamStats object representing\n\t// the inbound RTP stream that this contributing source is contributing to.\n\tInboundRTPStreamID string `json:\"inboundRtpStreamId\"`\n\n\t// PacketsContributedTo is the total number of RTP packets that this contributing\n\t// source contributed to. This value is incremented each time a packet is counted\n\t// by InboundRTPStreamStats.packetsReceived, and the packet's CSRC list contains\n\t// the SSRC identifier of this contributing source, ContributorSSRC.\n\tPacketsContributedTo uint32 `json:\"packetsContributedTo\"`\n\n\t// AudioLevel is present if the last received RTP packet that this source contributed\n\t// to contained an [RFC6465] mixer-to-client audio level header extension. The value\n\t// of audioLevel is between 0..1 (linear), where 1.0 represents 0 dBov, 0 represents\n\t// silence, and 0.5 represents approximately 6 dBSPL change in the sound pressure level from 0 dBov.\n\tAudioLevel float64 `json:\"audioLevel\"`\n}\n\nfunc (s RTPContributingSourceStats) statsMarker() {}\n\nfunc unmarshalCSRCStats(b []byte) (RTPContributingSourceStats, error) {\n\tvar csrcStats RTPContributingSourceStats\n\terr := json.Unmarshal(b, &csrcStats)\n\tif err != nil {\n\t\treturn RTPContributingSourceStats{}, fmt.Errorf(\"unmarshal csrc stats: %w\", err)\n\t}\n\treturn csrcStats, nil\n}\n\n// AudioSourceStats represents an audio track that is attached to one or more senders.\ntype AudioSourceStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// TrackIdentifier represents the id property of the track.\n\tTrackIdentifier string `json:\"trackIdentifier\"`\n\n\t// Kind is \"audio\"\n\tKind string `json:\"kind\"`\n\n\t// AudioLevel represents the output audio level of the track.\n\t//\n\t// The value is a value between 0..1 (linear), where 1.0 represents 0 dBov,\n\t// 0 represents silence, and 0.5 represents approximately 6 dBSPL change in\n\t// the sound pressure level from 0 dBov.\n\t//\n\t// If the track is sourced from an Receiver, does no audio processing, has a\n\t// constant level, and has a volume setting of 1.0, the audio level is expected\n\t// to be the same as the audio level of the source SSRC, while if the volume setting\n\t// is 0.5, the AudioLevel is expected to be half that value.\n\tAudioLevel float64 `json:\"audioLevel\"`\n\n\t// TotalAudioEnergy is the total energy of all the audio samples sent/received\n\t// for this object, calculated by duration * Math.pow(energy/maxEnergy, 2) for\n\t// each audio sample seen.\n\tTotalAudioEnergy float64 `json:\"totalAudioEnergy\"`\n\n\t// TotalSamplesDuration represents the total duration in seconds of all samples\n\t// that have sent or received (and thus counted by TotalSamplesSent or TotalSamplesReceived).\n\t// Can be used with TotalAudioEnergy to compute an average audio level over different intervals.\n\tTotalSamplesDuration float64 `json:\"totalSamplesDuration\"`\n\n\t// EchoReturnLoss is only present while the sender is sending a track sourced from\n\t// a microphone where echo cancellation is applied. Calculated in decibels.\n\tEchoReturnLoss float64 `json:\"echoReturnLoss\"`\n\n\t// EchoReturnLossEnhancement is only present while the sender is sending a track\n\t// sourced from a microphone where echo cancellation is applied. Calculated in decibels.\n\tEchoReturnLossEnhancement float64 `json:\"echoReturnLossEnhancement\"`\n\n\t// DroppedSamplesDuration represents the total duration, in seconds, of samples produced by the device that got\n\t// dropped before reaching the media source. Only applicable if this media source is backed by an audio capture device.\n\tDroppedSamplesDuration float64 `json:\"droppedSamplesDuration\"`\n\n\t// DroppedSamplesEvents is the number of dropped samples events. This counter increases every time a sample is\n\t// dropped after a non-dropped sample. That is, multiple consecutive dropped samples will increase\n\t// droppedSamplesDuration multiple times but is a single dropped samples event.\n\tDroppedSamplesEvents uint64 `json:\"droppedSamplesEvents\"`\n\n\t// TotalCaptureDelay is the total delay, in seconds, for each audio sample between the time the sample was emitted\n\t// by the capture device and the sample reaching the source. This can be used together with totalSamplesCaptured to\n\t// calculate the average capture delay per sample. Only applicable if the audio source represents an audio capture device.\n\tTotalCaptureDelay float64 `json:\"totalCaptureDelay\"`\n\n\t// TotalSamplesCaptured is the total number of captured samples reaching the audio source, i.e. that were not dropped\n\t// by the capture pipeline. The frequency of the media source is not necessarily the same as the frequency of encoders\n\t// later in the pipeline. Only applicable if the audio source represents an audio capture device.\n\tTotalSamplesCaptured uint64 `json:\"totalSamplesCaptured\"`\n}\n\nfunc (s AudioSourceStats) statsMarker() {}\n\n// VideoSourceStats represents a video track that is attached to one or more senders.\ntype VideoSourceStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// TrackIdentifier represents the id property of the track.\n\tTrackIdentifier string `json:\"trackIdentifier\"`\n\n\t// Kind is \"video\"\n\tKind string `json:\"kind\"`\n\n\t// Width is width of the last frame originating from this source in pixels.\n\tWidth uint32 `json:\"width\"`\n\n\t// Height is height of the last frame originating from this source in pixels.\n\tHeight uint32 `json:\"height\"`\n\n\t// Frames is the total number of frames originating from this source.\n\tFrames uint32 `json:\"frames\"`\n\n\t// FramesPerSecond is the number of frames originating from this source, measured during the last second.\n\tFramesPerSecond float64 `json:\"framesPerSecond\"`\n}\n\nfunc (s VideoSourceStats) statsMarker() {}\n\nfunc unmarshalMediaSourceStats(b []byte) (Stats, error) {\n\ttype kindJSON struct {\n\t\tKind string `json:\"kind\"`\n\t}\n\tkindHolder := kindJSON{}\n\n\terr := json.Unmarshal(b, &kindHolder)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal json kind: %w\", err)\n\t}\n\n\tswitch MediaKind(kindHolder.Kind) {\n\tcase MediaKindAudio:\n\t\tvar mediaSourceStats AudioSourceStats\n\t\terr := json.Unmarshal(b, &mediaSourceStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal audio source stats: %w\", err)\n\t\t}\n\t\treturn mediaSourceStats, nil\n\tcase MediaKindVideo:\n\t\tvar mediaSourceStats VideoSourceStats\n\t\terr := json.Unmarshal(b, &mediaSourceStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal video source stats: %w\", err)\n\t\t}\n\t\treturn mediaSourceStats, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"kind: %w\", ErrUnknownType)\n\t}\n}\n\n// AudioPlayoutStats represents one playout path - if the same playout stats object is referenced by multiple\n// RTCInboundRtpStreamStats this is an indication that audio mixing is happening in which case sample counters in this\n// stats object refer to the samples after mixing. Only applicable if the playout path represents an audio device.\ntype AudioPlayoutStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// Kind is \"audio\"\n\tKind string `json:\"kind\"`\n\n\t// SynthesizedSamplesDuration is measured in seconds and is incremented each time an audio sample is synthesized by\n\t// this playout path. This metric can be used together with totalSamplesDuration to calculate the percentage of played\n\t// out media being synthesized. If the playout path is unable to produce audio samples on time for device playout,\n\t// samples are synthesized to be playout out instead. Synthesization typically only happens if the pipeline is\n\t// underperforming. Samples synthesized by the RTCInboundRtpStreamStats are not counted for here, but in\n\t// InboundRtpStreamStats.concealedSamples.\n\tSynthesizedSamplesDuration float64 `json:\"synthesizedSamplesDuration\"`\n\n\t// SynthesizedSamplesEvents is the number of synthesized samples events. This counter increases every time a sample\n\t// is synthesized after a non-synthesized sample. That is, multiple consecutive synthesized samples will increase\n\t// synthesizedSamplesDuration multiple times but is a single synthesization samples event.\n\tSynthesizedSamplesEvents uint64 `json:\"synthesizedSamplesEvents\"`\n\n\t// TotalSamplesDuration represents the total duration in seconds of all samples\n\t// that have sent or received (and thus counted by TotalSamplesSent or TotalSamplesReceived).\n\t// Can be used with TotalAudioEnergy to compute an average audio level over different intervals.\n\tTotalSamplesDuration float64 `json:\"totalSamplesDuration\"`\n\n\t// When audio samples are pulled by the playout device, this counter is incremented with the estimated delay of the\n\t// playout path for that audio sample. The playout delay includes the delay from being emitted to the actual time of\n\t// playout on the device. This metric can be used together with totalSamplesCount to calculate the average\n\t// playout delay per sample.\n\tTotalPlayoutDelay float64 `json:\"totalPlayoutDelay\"`\n\n\t// When audio samples are pulled by the playout device, this counter is incremented with the number of samples\n\t// emitted for playout.\n\tTotalSamplesCount uint64 `json:\"totalSamplesCount\"`\n}\n\nfunc (s AudioPlayoutStats) statsMarker() {}\n\nfunc unmarshalMediaPlayoutStats(b []byte) (Stats, error) {\n\tvar audioPlayoutStats AudioPlayoutStats\n\terr := json.Unmarshal(b, &audioPlayoutStats)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal audio playout stats: %w\", err)\n\t}\n\treturn audioPlayoutStats, nil\n}\n\n// PeerConnectionStats contains statistics related to the PeerConnection object.\ntype PeerConnectionStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// DataChannelsOpened represents the number of unique DataChannels that have\n\t// entered the \"open\" state during their lifetime.\n\tDataChannelsOpened uint32 `json:\"dataChannelsOpened\"`\n\n\t// DataChannelsClosed represents the number of unique DataChannels that have\n\t// left the \"open\" state during their lifetime (due to being closed by either\n\t// end or the underlying transport being closed). DataChannels that transition\n\t// from \"connecting\" to \"closing\" or \"closed\" without ever being \"open\"\n\t// are not counted in this number.\n\tDataChannelsClosed uint32 `json:\"dataChannelsClosed\"`\n\n\t// DataChannelsRequested Represents the number of unique DataChannels returned\n\t// from a successful createDataChannel() call on the PeerConnection. If the\n\t// underlying data transport is not established, these may be in the \"connecting\" state.\n\tDataChannelsRequested uint32 `json:\"dataChannelsRequested\"`\n\n\t// DataChannelsAccepted represents the number of unique DataChannels signaled\n\t// in a \"datachannel\" event on the PeerConnection.\n\tDataChannelsAccepted uint32 `json:\"dataChannelsAccepted\"`\n}\n\nfunc (s PeerConnectionStats) statsMarker() {}\n\nfunc unmarshalPeerConnectionStats(b []byte) (PeerConnectionStats, error) {\n\tvar pcStats PeerConnectionStats\n\terr := json.Unmarshal(b, &pcStats)\n\tif err != nil {\n\t\treturn PeerConnectionStats{}, fmt.Errorf(\"unmarshal pc stats: %w\", err)\n\t}\n\treturn pcStats, nil\n}\n\n// DataChannelStats contains statistics related to each DataChannel ID.\ntype DataChannelStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// Label is the \"label\" value of the DataChannel object.\n\tLabel string `json:\"label\"`\n\n\t// Protocol is the \"protocol\" value of the DataChannel object.\n\tProtocol string `json:\"protocol\"`\n\n\t// DataChannelIdentifier is the \"id\" attribute of the DataChannel object.\n\tDataChannelIdentifier int32 `json:\"dataChannelIdentifier\"`\n\n\t// TransportID the ID of the TransportStats object for transport used to carry this datachannel.\n\tTransportID string `json:\"transportId\"`\n\n\t// State is the \"readyState\" value of the DataChannel object.\n\tState DataChannelState `json:\"state\"`\n\n\t// MessagesSent represents the total number of API \"message\" events sent.\n\tMessagesSent uint32 `json:\"messagesSent\"`\n\n\t// BytesSent represents the total number of payload bytes sent on this\n\t// datachannel not including headers or padding.\n\tBytesSent uint64 `json:\"bytesSent\"`\n\n\t// MessagesReceived represents the total number of API \"message\" events received.\n\tMessagesReceived uint32 `json:\"messagesReceived\"`\n\n\t// BytesReceived represents the total number of bytes received on this\n\t// datachannel not including headers or padding.\n\tBytesReceived uint64 `json:\"bytesReceived\"`\n}\n\nfunc (s DataChannelStats) statsMarker() {}\n\nfunc unmarshalDataChannelStats(b []byte) (DataChannelStats, error) {\n\tvar dataChannelStats DataChannelStats\n\terr := json.Unmarshal(b, &dataChannelStats)\n\tif err != nil {\n\t\treturn DataChannelStats{}, fmt.Errorf(\"unmarshal data channel stats: %w\", err)\n\t}\n\treturn dataChannelStats, nil\n}\n\n// MediaStreamStats contains statistics related to a specific MediaStream.\ntype MediaStreamStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// StreamIdentifier is the \"id\" property of the MediaStream\n\tStreamIdentifier string `json:\"streamIdentifier\"`\n\n\t// TrackIDs is a list of the identifiers of the stats object representing the\n\t// stream's tracks, either ReceiverAudioTrackAttachmentStats or ReceiverVideoTrackAttachmentStats.\n\tTrackIDs []string `json:\"trackIds\"`\n}\n\nfunc (s MediaStreamStats) statsMarker() {}\n\nfunc unmarshalStreamStats(b []byte) (MediaStreamStats, error) {\n\tvar streamStats MediaStreamStats\n\terr := json.Unmarshal(b, &streamStats)\n\tif err != nil {\n\t\treturn MediaStreamStats{}, fmt.Errorf(\"unmarshal stream stats: %w\", err)\n\t}\n\treturn streamStats, nil\n}\n\n// AudioSenderStats represents the stats about one audio sender of a PeerConnection\n// object for which one calls GetStats.\n//\n// It appears in the stats as soon as the RTPSender is added by either AddTrack\n// or AddTransceiver, or by media negotiation.\ntype AudioSenderStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// TrackIdentifier represents the id property of the track.\n\tTrackIdentifier string `json:\"trackIdentifier\"`\n\n\t// RemoteSource is true if the source is remote, for instance if it is sourced\n\t// from another host via a PeerConnection. False otherwise. Only applicable for 'track' stats.\n\tRemoteSource bool `json:\"remoteSource\"`\n\n\t// Ended reflects the \"ended\" state of the track.\n\tEnded bool `json:\"ended\"`\n\n\t// Kind is \"audio\"\n\tKind string `json:\"kind\"`\n\n\t// AudioLevel represents the output audio level of the track.\n\t//\n\t// The value is a value between 0..1 (linear), where 1.0 represents 0 dBov,\n\t// 0 represents silence, and 0.5 represents approximately 6 dBSPL change in\n\t// the sound pressure level from 0 dBov.\n\t//\n\t// If the track is sourced from an Receiver, does no audio processing, has a\n\t// constant level, and has a volume setting of 1.0, the audio level is expected\n\t// to be the same as the audio level of the source SSRC, while if the volume setting\n\t// is 0.5, the AudioLevel is expected to be half that value.\n\t//\n\t// For outgoing audio tracks, the AudioLevel is the level of the audio being sent.\n\tAudioLevel float64 `json:\"audioLevel\"`\n\n\t// TotalAudioEnergy is the total energy of all the audio samples sent/received\n\t// for this object, calculated by duration * Math.pow(energy/maxEnergy, 2) for\n\t// each audio sample seen.\n\tTotalAudioEnergy float64 `json:\"totalAudioEnergy\"`\n\n\t// VoiceActivityFlag represents whether the last RTP packet sent or played out\n\t// by this track contained voice activity or not based on the presence of the\n\t// V bit in the extension header, as defined in [RFC6464].\n\t//\n\t// This value indicates the voice activity in the latest RTP packet played out\n\t// from a given SSRC, and is defined in RTPSynchronizationSource.voiceActivityFlag.\n\tVoiceActivityFlag bool `json:\"voiceActivityFlag\"`\n\n\t// TotalSamplesDuration represents the total duration in seconds of all samples\n\t// that have sent or received (and thus counted by TotalSamplesSent or TotalSamplesReceived).\n\t// Can be used with TotalAudioEnergy to compute an average audio level over different intervals.\n\tTotalSamplesDuration float64 `json:\"totalSamplesDuration\"`\n\n\t// EchoReturnLoss is only present while the sender is sending a track sourced from\n\t// a microphone where echo cancellation is applied. Calculated in decibels.\n\tEchoReturnLoss float64 `json:\"echoReturnLoss\"`\n\n\t// EchoReturnLossEnhancement is only present while the sender is sending a track\n\t// sourced from a microphone where echo cancellation is applied. Calculated in decibels.\n\tEchoReturnLossEnhancement float64 `json:\"echoReturnLossEnhancement\"`\n\n\t// TotalSamplesSent is the total number of samples that have been sent by this sender.\n\tTotalSamplesSent uint64 `json:\"totalSamplesSent\"`\n}\n\nfunc (s AudioSenderStats) statsMarker() {}\n\n// SenderAudioTrackAttachmentStats object represents the stats about one attachment\n// of an audio MediaStreamTrack to the PeerConnection object for which one calls GetStats.\n//\n// It appears in the stats as soon as it is attached (via AddTrack, via AddTransceiver,\n// via ReplaceTrack on an RTPSender object).\n//\n// If an audio track is attached twice (via AddTransceiver or ReplaceTrack), there\n// will be two SenderAudioTrackAttachmentStats objects, one for each attachment.\n// They will have the same \"TrackIdentifier\" attribute, but different \"ID\" attributes.\n//\n// If the track is detached from the PeerConnection (via removeTrack or via replaceTrack),\n// it continues to appear, but with the \"ObjectDeleted\" member set to true.\ntype SenderAudioTrackAttachmentStats AudioSenderStats\n\nfunc (s SenderAudioTrackAttachmentStats) statsMarker() {}\n\n// VideoSenderStats represents the stats about one video sender of a PeerConnection\n// object for which one calls GetStats.\n//\n// It appears in the stats as soon as the sender is added by either AddTrack or\n// AddTransceiver, or by media negotiation.\ntype VideoSenderStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// Kind is \"video\"\n\tKind string `json:\"kind\"`\n\n\t// FramesCaptured represents the total number of frames captured, before encoding,\n\t// for this RTPSender (or for this MediaStreamTrack, if type is \"track\"). For example,\n\t// if type is \"sender\" and this sender's track represents a camera, then this is the\n\t// number of frames produced by the camera for this track while being sent by this sender,\n\t// combined with the number of frames produced by all tracks previously attached to this\n\t// sender while being sent by this sender. Framerates can vary due to hardware limitations\n\t// or environmental factors such as lighting conditions.\n\tFramesCaptured uint32 `json:\"framesCaptured\"`\n\n\t// FramesSent represents the total number of frames sent by this RTPSender\n\t// (or for this MediaStreamTrack, if type is \"track\").\n\tFramesSent uint32 `json:\"framesSent\"`\n\n\t// HugeFramesSent represents the total number of huge frames sent by this RTPSender\n\t// (or for this MediaStreamTrack, if type is \"track\"). Huge frames, by definition,\n\t// are frames that have an encoded size at least 2.5 times the average size of the frames.\n\t// The average size of the frames is defined as the target bitrate per second divided\n\t// by the target fps at the time the frame was encoded. These are usually complex\n\t// to encode frames with a lot of changes in the picture. This can be used to estimate,\n\t// e.g slide changes in the streamed presentation. If a huge frame is also a key frame,\n\t// then both counters HugeFramesSent and KeyFramesSent are incremented.\n\tHugeFramesSent uint32 `json:\"hugeFramesSent\"`\n\n\t// KeyFramesSent represents the total number of key frames sent by this RTPSender\n\t// (or for this MediaStreamTrack, if type is \"track\"), such as Infra-frames in\n\t// VP8 [RFC6386] or I-frames in H.264 [RFC6184]. This is a subset of FramesSent.\n\t// FramesSent - KeyFramesSent gives you the number of delta frames sent.\n\tKeyFramesSent uint32 `json:\"keyFramesSent\"`\n}\n\nfunc (s VideoSenderStats) statsMarker() {}\n\n// SenderVideoTrackAttachmentStats represents the stats about one attachment of a\n// video MediaStreamTrack to the PeerConnection object for which one calls GetStats.\n//\n// It appears in the stats as soon as it is attached (via AddTrack, via AddTransceiver,\n// via ReplaceTrack on an RTPSender object).\n//\n// If a video track is attached twice (via AddTransceiver or ReplaceTrack), there\n// will be two SenderVideoTrackAttachmentStats objects, one for each attachment.\n// They will have the same \"TrackIdentifier\" attribute, but different \"ID\" attributes.\n//\n// If the track is detached from the PeerConnection (via RemoveTrack or via ReplaceTrack),\n// it continues to appear, but with the \"ObjectDeleted\" member set to true.\ntype SenderVideoTrackAttachmentStats VideoSenderStats\n\nfunc (s SenderVideoTrackAttachmentStats) statsMarker() {}\n\nfunc unmarshalSenderStats(b []byte) (Stats, error) {\n\ttype kindJSON struct {\n\t\tKind string `json:\"kind\"`\n\t}\n\tkindHolder := kindJSON{}\n\n\terr := json.Unmarshal(b, &kindHolder)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal json kind: %w\", err)\n\t}\n\n\tswitch MediaKind(kindHolder.Kind) {\n\tcase MediaKindAudio:\n\t\tvar senderStats AudioSenderStats\n\t\terr := json.Unmarshal(b, &senderStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal audio sender stats: %w\", err)\n\t\t}\n\t\treturn senderStats, nil\n\tcase MediaKindVideo:\n\t\tvar senderStats VideoSenderStats\n\t\terr := json.Unmarshal(b, &senderStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal video sender stats: %w\", err)\n\t\t}\n\t\treturn senderStats, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"kind: %w\", ErrUnknownType)\n\t}\n}\n\nfunc unmarshalTrackStats(b []byte) (Stats, error) {\n\ttype kindJSON struct {\n\t\tKind string `json:\"kind\"`\n\t}\n\tkindHolder := kindJSON{}\n\n\terr := json.Unmarshal(b, &kindHolder)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal json kind: %w\", err)\n\t}\n\n\tswitch MediaKind(kindHolder.Kind) {\n\tcase MediaKindAudio:\n\t\tvar trackStats SenderAudioTrackAttachmentStats\n\t\terr := json.Unmarshal(b, &trackStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal audio track stats: %w\", err)\n\t\t}\n\t\treturn trackStats, nil\n\tcase MediaKindVideo:\n\t\tvar trackStats SenderVideoTrackAttachmentStats\n\t\terr := json.Unmarshal(b, &trackStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal video track stats: %w\", err)\n\t\t}\n\t\treturn trackStats, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"kind: %w\", ErrUnknownType)\n\t}\n}\n\n// AudioReceiverStats contains audio metrics related to a specific receiver.\ntype AudioReceiverStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// Kind is \"audio\"\n\tKind string `json:\"kind\"`\n\n\t// AudioLevel represents the output audio level of the track.\n\t//\n\t// The value is a value between 0..1 (linear), where 1.0 represents 0 dBov,\n\t// 0 represents silence, and 0.5 represents approximately 6 dBSPL change in\n\t// the sound pressure level from 0 dBov.\n\t//\n\t// If the track is sourced from an Receiver, does no audio processing, has a\n\t// constant level, and has a volume setting of 1.0, the audio level is expected\n\t// to be the same as the audio level of the source SSRC, while if the volume setting\n\t// is 0.5, the AudioLevel is expected to be half that value.\n\t//\n\t// For outgoing audio tracks, the AudioLevel is the level of the audio being sent.\n\tAudioLevel float64 `json:\"audioLevel\"`\n\n\t// TotalAudioEnergy is the total energy of all the audio samples sent/received\n\t// for this object, calculated by duration * Math.pow(energy/maxEnergy, 2) for\n\t// each audio sample seen.\n\tTotalAudioEnergy float64 `json:\"totalAudioEnergy\"`\n\n\t// VoiceActivityFlag represents whether the last RTP packet sent or played out\n\t// by this track contained voice activity or not based on the presence of the\n\t// V bit in the extension header, as defined in [RFC6464].\n\t//\n\t// This value indicates the voice activity in the latest RTP packet played out\n\t// from a given SSRC, and is defined in RTPSynchronizationSource.voiceActivityFlag.\n\tVoiceActivityFlag bool `json:\"voiceActivityFlag\"`\n\n\t// TotalSamplesDuration represents the total duration in seconds of all samples\n\t// that have sent or received (and thus counted by TotalSamplesSent or TotalSamplesReceived).\n\t// Can be used with TotalAudioEnergy to compute an average audio level over different intervals.\n\tTotalSamplesDuration float64 `json:\"totalSamplesDuration\"`\n\n\t// EstimatedPlayoutTimestamp is the estimated playout time of this receiver's\n\t// track. The playout time is the NTP timestamp of the last playable sample that\n\t// has a known timestamp (from an RTCP SR packet mapping RTP timestamps to NTP\n\t// timestamps), extrapolated with the time elapsed since it was ready to be played out.\n\t// This is the \"current time\" of the track in NTP clock time of the sender and\n\t// can be present even if there is no audio currently playing.\n\t//\n\t// This can be useful for estimating how much audio and video is out of\n\t// sync for two tracks from the same source:\n\t// \t\tAudioTrackStats.EstimatedPlayoutTimestamp - VideoTrackStats.EstimatedPlayoutTimestamp\n\tEstimatedPlayoutTimestamp StatsTimestamp `json:\"estimatedPlayoutTimestamp\"`\n\n\t// JitterBufferDelay is the sum of the time, in seconds, each sample takes from\n\t// the time it is received and to the time it exits the jitter buffer.\n\t// This increases upon samples exiting, having completed their time in the buffer\n\t// (incrementing JitterBufferEmittedCount). The average jitter buffer delay can\n\t// be calculated by dividing the JitterBufferDelay with the JitterBufferEmittedCount.\n\tJitterBufferDelay float64 `json:\"jitterBufferDelay\"`\n\n\t// JitterBufferEmittedCount is the total number of samples that have come out\n\t// of the jitter buffer (increasing JitterBufferDelay).\n\tJitterBufferEmittedCount uint64 `json:\"jitterBufferEmittedCount\"`\n\n\t// TotalSamplesReceived is the total number of samples that have been received\n\t// by this receiver. This includes ConcealedSamples.\n\tTotalSamplesReceived uint64 `json:\"totalSamplesReceived\"`\n\n\t// ConcealedSamples is the total number of samples that are concealed samples.\n\t// A concealed sample is a sample that is based on data that was synthesized\n\t// to conceal packet loss and does not represent incoming data.\n\tConcealedSamples uint64 `json:\"concealedSamples\"`\n\n\t// ConcealmentEvents is the number of concealment events. This counter increases\n\t// every time a concealed sample is synthesized after a non-concealed sample.\n\t// That is, multiple consecutive concealed samples will increase the concealedSamples\n\t// count multiple times but is a single concealment event.\n\tConcealmentEvents uint64 `json:\"concealmentEvents\"`\n}\n\nfunc (s AudioReceiverStats) statsMarker() {}\n\n// VideoReceiverStats contains video metrics related to a specific receiver.\ntype VideoReceiverStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// Kind is \"video\"\n\tKind string `json:\"kind\"`\n\n\t// FrameWidth represents the width of the last processed frame for this track.\n\t// Before the first frame is processed this attribute is missing.\n\tFrameWidth uint32 `json:\"frameWidth\"`\n\n\t// FrameHeight represents the height of the last processed frame for this track.\n\t// Before the first frame is processed this attribute is missing.\n\tFrameHeight uint32 `json:\"frameHeight\"`\n\n\t// FramesPerSecond represents the nominal FPS value before the degradation preference\n\t// is applied. It is the number of complete frames in the last second. For sending\n\t// tracks it is the current captured FPS and for the receiving tracks it is the\n\t// current decoding framerate.\n\tFramesPerSecond float64 `json:\"framesPerSecond\"`\n\n\t// EstimatedPlayoutTimestamp is the estimated playout time of this receiver's\n\t// track. The playout time is the NTP timestamp of the last playable sample that\n\t// has a known timestamp (from an RTCP SR packet mapping RTP timestamps to NTP\n\t// timestamps), extrapolated with the time elapsed since it was ready to be played out.\n\t// This is the \"current time\" of the track in NTP clock time of the sender and\n\t// can be present even if there is no audio currently playing.\n\t//\n\t// This can be useful for estimating how much audio and video is out of\n\t// sync for two tracks from the same source:\n\t// \t\tAudioTrackStats.EstimatedPlayoutTimestamp - VideoTrackStats.EstimatedPlayoutTimestamp\n\tEstimatedPlayoutTimestamp StatsTimestamp `json:\"estimatedPlayoutTimestamp\"`\n\n\t// JitterBufferDelay is the sum of the time, in seconds, each sample takes from\n\t// the time it is received and to the time it exits the jitter buffer.\n\t// This increases upon samples exiting, having completed their time in the buffer\n\t// (incrementing JitterBufferEmittedCount). The average jitter buffer delay can\n\t// be calculated by dividing the JitterBufferDelay with the JitterBufferEmittedCount.\n\tJitterBufferDelay float64 `json:\"jitterBufferDelay\"`\n\n\t// JitterBufferEmittedCount is the total number of samples that have come out\n\t// of the jitter buffer (increasing JitterBufferDelay).\n\tJitterBufferEmittedCount uint64 `json:\"jitterBufferEmittedCount\"`\n\n\t// FramesReceived Represents the total number of complete frames received for\n\t// this receiver. This metric is incremented when the complete frame is received.\n\tFramesReceived uint32 `json:\"framesReceived\"`\n\n\t// KeyFramesReceived represents the total number of complete key frames received\n\t// for this MediaStreamTrack, such as Infra-frames in VP8 [RFC6386] or I-frames\n\t// in H.264 [RFC6184]. This is a subset of framesReceived. `framesReceived - keyFramesReceived`\n\t// gives you the number of delta frames received. This metric is incremented when\n\t// the complete key frame is received. It is not incremented if a partial key\n\t// frames is received and sent for decoding, i.e., the frame could not be recovered\n\t// via retransmission or FEC.\n\tKeyFramesReceived uint32 `json:\"keyFramesReceived\"`\n\n\t// FramesDecoded represents the total number of frames correctly decoded for this\n\t// SSRC, i.e., frames that would be displayed if no frames are dropped.\n\tFramesDecoded uint32 `json:\"framesDecoded\"`\n\n\t// FramesDropped is the total number of frames dropped predecode or dropped\n\t// because the frame missed its display deadline for this receiver's track.\n\tFramesDropped uint32 `json:\"framesDropped\"`\n\n\t// The cumulative number of partial frames lost. This metric is incremented when\n\t// the frame is sent to the decoder. If the partial frame is received and recovered\n\t// via retransmission or FEC before decoding, the FramesReceived counter is incremented.\n\tPartialFramesLost uint32 `json:\"partialFramesLost\"`\n\n\t// FullFramesLost is the cumulative number of full frames lost.\n\tFullFramesLost uint32 `json:\"fullFramesLost\"`\n}\n\nfunc (s VideoReceiverStats) statsMarker() {}\n\nfunc unmarshalReceiverStats(b []byte) (Stats, error) {\n\ttype kindJSON struct {\n\t\tKind string `json:\"kind\"`\n\t}\n\tkindHolder := kindJSON{}\n\n\terr := json.Unmarshal(b, &kindHolder)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unmarshal json kind: %w\", err)\n\t}\n\n\tswitch MediaKind(kindHolder.Kind) {\n\tcase MediaKindAudio:\n\t\tvar receiverStats AudioReceiverStats\n\t\terr := json.Unmarshal(b, &receiverStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal audio receiver stats: %w\", err)\n\t\t}\n\t\treturn receiverStats, nil\n\tcase MediaKindVideo:\n\t\tvar receiverStats VideoReceiverStats\n\t\terr := json.Unmarshal(b, &receiverStats)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"unmarshal video receiver stats: %w\", err)\n\t\t}\n\t\treturn receiverStats, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"kind: %w\", ErrUnknownType)\n\t}\n}\n\n// TransportStats contains transport statistics related to the PeerConnection object.\ntype TransportStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// PacketsSent represents the total number of packets sent over this transport.\n\tPacketsSent uint32 `json:\"packetsSent\"`\n\n\t// PacketsReceived represents the total number of packets received on this transport.\n\tPacketsReceived uint32 `json:\"packetsReceived\"`\n\n\t// BytesSent represents the total number of payload bytes sent on this PeerConnection\n\t// not including headers or padding.\n\tBytesSent uint64 `json:\"bytesSent\"`\n\n\t// BytesReceived represents the total number of bytes received on this PeerConnection\n\t// not including headers or padding.\n\tBytesReceived uint64 `json:\"bytesReceived\"`\n\n\t// RTCPTransportStatsID is the ID of the transport that gives stats for the RTCP\n\t// component If RTP and RTCP are not multiplexed and this record has only\n\t// the RTP component stats.\n\tRTCPTransportStatsID string `json:\"rtcpTransportStatsId\"`\n\n\t// ICERole is set to the current value of the \"role\" attribute of the underlying\n\t// DTLSTransport's \"iceTransport\".\n\tICERole ICERole `json:\"iceRole\"`\n\n\t// DTLSState is set to the current value of the \"state\" attribute of the underlying DTLSTransport.\n\tDTLSState DTLSTransportState `json:\"dtlsState\"`\n\n\t// ICEState is set to the current value of the \"state\" attribute of the underlying\n\t// RTCIceTransport's \"state\".\n\tICEState ICETransportState `json:\"iceState\"`\n\n\t// SelectedCandidatePairID is a unique identifier that is associated to the object\n\t// that was inspected to produce the ICECandidatePairStats associated with this transport.\n\tSelectedCandidatePairID string `json:\"selectedCandidatePairId\"`\n\n\t// LocalCertificateID is the ID of the CertificateStats for the local certificate.\n\t// Present only if DTLS is negotiated.\n\tLocalCertificateID string `json:\"localCertificateId\"`\n\n\t// LocalCertificateID is the ID of the CertificateStats for the remote certificate.\n\t// Present only if DTLS is negotiated.\n\tRemoteCertificateID string `json:\"remoteCertificateId\"`\n\n\t// DTLSCipher is the descriptive name of the cipher suite used for the DTLS transport,\n\t// as defined in the \"Description\" column of the IANA cipher suite registry.\n\tDTLSCipher string `json:\"dtlsCipher\"`\n\n\t// SRTPCipher is the descriptive name of the protection profile used for the SRTP\n\t// transport, as defined in the \"Profile\" column of the IANA DTLS-SRTP protection\n\t// profile registry.\n\tSRTPCipher string `json:\"srtpCipher\"`\n}\n\nfunc (s TransportStats) statsMarker() {}\n\nfunc unmarshalTransportStats(b []byte) (TransportStats, error) {\n\tvar transportStats TransportStats\n\terr := json.Unmarshal(b, &transportStats)\n\tif err != nil {\n\t\treturn TransportStats{}, fmt.Errorf(\"unmarshal transport stats: %w\", err)\n\t}\n\treturn transportStats, nil\n}\n\n// StatsICECandidatePairState is the state of an ICE candidate pair used in the\n// ICECandidatePairStats object.\ntype StatsICECandidatePairState string\n\nfunc toStatsICECandidatePairState(state ice.CandidatePairState) (StatsICECandidatePairState, error) {\n\tswitch state {\n\tcase ice.CandidatePairStateWaiting:\n\t\treturn StatsICECandidatePairStateWaiting, nil\n\tcase ice.CandidatePairStateInProgress:\n\t\treturn StatsICECandidatePairStateInProgress, nil\n\tcase ice.CandidatePairStateFailed:\n\t\treturn StatsICECandidatePairStateFailed, nil\n\tcase ice.CandidatePairStateSucceeded:\n\t\treturn StatsICECandidatePairStateSucceeded, nil\n\tdefault:\n\t\t// NOTE: this should never happen[tm]\n\t\terr := fmt.Errorf(\"%w: %s\", errStatsICECandidateStateInvalid, state.String())\n\t\treturn StatsICECandidatePairState(\"Unknown\"), err\n\t}\n}\n\nfunc toICECandidatePairStats(candidatePairStats ice.CandidatePairStats) (ICECandidatePairStats, error) {\n\tstate, err := toStatsICECandidatePairState(candidatePairStats.State)\n\tif err != nil {\n\t\treturn ICECandidatePairStats{}, err\n\t}\n\n\treturn ICECandidatePairStats{\n\t\tTimestamp: statsTimestampFrom(candidatePairStats.Timestamp),\n\t\tType:      StatsTypeCandidatePair,\n\t\tID:        newICECandidatePairStatsID(candidatePairStats.LocalCandidateID, candidatePairStats.RemoteCandidateID),\n\t\t// TransportID:\n\t\tLocalCandidateID:            candidatePairStats.LocalCandidateID,\n\t\tRemoteCandidateID:           candidatePairStats.RemoteCandidateID,\n\t\tState:                       state,\n\t\tNominated:                   candidatePairStats.Nominated,\n\t\tPacketsSent:                 candidatePairStats.PacketsSent,\n\t\tPacketsReceived:             candidatePairStats.PacketsReceived,\n\t\tBytesSent:                   candidatePairStats.BytesSent,\n\t\tBytesReceived:               candidatePairStats.BytesReceived,\n\t\tLastPacketSentTimestamp:     statsTimestampFrom(candidatePairStats.LastPacketSentTimestamp),\n\t\tLastPacketReceivedTimestamp: statsTimestampFrom(candidatePairStats.LastPacketReceivedTimestamp),\n\t\tFirstRequestTimestamp:       statsTimestampFrom(candidatePairStats.FirstRequestTimestamp),\n\t\tLastRequestTimestamp:        statsTimestampFrom(candidatePairStats.LastRequestTimestamp),\n\t\tLastResponseTimestamp:       statsTimestampFrom(candidatePairStats.LastResponseTimestamp),\n\t\tTotalRoundTripTime:          candidatePairStats.TotalRoundTripTime,\n\t\tCurrentRoundTripTime:        candidatePairStats.CurrentRoundTripTime,\n\t\tAvailableOutgoingBitrate:    candidatePairStats.AvailableOutgoingBitrate,\n\t\tAvailableIncomingBitrate:    candidatePairStats.AvailableIncomingBitrate,\n\t\tCircuitBreakerTriggerCount:  candidatePairStats.CircuitBreakerTriggerCount,\n\t\tRequestsReceived:            candidatePairStats.RequestsReceived,\n\t\tRequestsSent:                candidatePairStats.RequestsSent,\n\t\tResponsesReceived:           candidatePairStats.ResponsesReceived,\n\t\tResponsesSent:               candidatePairStats.ResponsesSent,\n\t\tRetransmissionsReceived:     candidatePairStats.RetransmissionsReceived,\n\t\tRetransmissionsSent:         candidatePairStats.RetransmissionsSent,\n\t\tConsentRequestsSent:         candidatePairStats.ConsentRequestsSent,\n\t\tConsentExpiredTimestamp:     statsTimestampFrom(candidatePairStats.ConsentExpiredTimestamp),\n\t}, nil\n}\n\nconst (\n\t// StatsICECandidatePairStateFrozen means a check for this pair hasn't been\n\t// performed, and it can't yet be performed until some other check succeeds,\n\t// allowing this pair to unfreeze and move into the Waiting state.\n\tStatsICECandidatePairStateFrozen StatsICECandidatePairState = \"frozen\"\n\n\t// StatsICECandidatePairStateWaiting means a check has not been performed for\n\t// this pair, and can be performed as soon as it is the highest-priority Waiting\n\t// pair on the check list.\n\tStatsICECandidatePairStateWaiting StatsICECandidatePairState = \"waiting\"\n\n\t// StatsICECandidatePairStateInProgress means a check has been sent for this pair,\n\t// but the transaction is in progress.\n\tStatsICECandidatePairStateInProgress StatsICECandidatePairState = \"in-progress\"\n\n\t// StatsICECandidatePairStateFailed means a check for this pair was already done\n\t// and failed, either never producing any response or producing an unrecoverable\n\t// failure response.\n\tStatsICECandidatePairStateFailed StatsICECandidatePairState = \"failed\"\n\n\t// StatsICECandidatePairStateSucceeded means a check for this pair was already\n\t// done and produced a successful result.\n\tStatsICECandidatePairStateSucceeded StatsICECandidatePairState = \"succeeded\"\n)\n\n// ICECandidatePairStats contains ICE candidate pair statistics related\n// to the ICETransport objects.\ntype ICECandidatePairStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// TransportID is a unique identifier that is associated to the object that\n\t// was inspected to produce the TransportStats associated with this candidate pair.\n\tTransportID string `json:\"transportId\"`\n\n\t// LocalCandidateID is a unique identifier that is associated to the object\n\t// that was inspected to produce the ICECandidateStats for the local candidate\n\t// associated with this candidate pair.\n\tLocalCandidateID string `json:\"localCandidateId\"`\n\n\t// RemoteCandidateID is a unique identifier that is associated to the object\n\t// that was inspected to produce the ICECandidateStats for the remote candidate\n\t// associated with this candidate pair.\n\tRemoteCandidateID string `json:\"remoteCandidateId\"`\n\n\t// State represents the state of the checklist for the local and remote\n\t// candidates in a pair.\n\tState StatsICECandidatePairState `json:\"state\"`\n\n\t// Nominated is true when this valid pair that should be used for media\n\t// if it is the highest-priority one amongst those whose nominated flag is set\n\tNominated bool `json:\"nominated\"`\n\n\t// PacketsSent represents the total number of packets sent on this candidate pair.\n\tPacketsSent uint32 `json:\"packetsSent\"`\n\n\t// PacketsReceived represents the total number of packets received on this candidate pair.\n\tPacketsReceived uint32 `json:\"packetsReceived\"`\n\n\t// BytesSent represents the total number of payload bytes sent on this candidate pair\n\t// not including headers or padding.\n\tBytesSent uint64 `json:\"bytesSent\"`\n\n\t// BytesReceived represents the total number of payload bytes received on this candidate pair\n\t// not including headers or padding.\n\tBytesReceived uint64 `json:\"bytesReceived\"`\n\n\t// LastPacketSentTimestamp represents the timestamp at which the last packet was\n\t// sent on this particular candidate pair, excluding STUN packets.\n\tLastPacketSentTimestamp StatsTimestamp `json:\"lastPacketSentTimestamp\"`\n\n\t// LastPacketReceivedTimestamp represents the timestamp at which the last packet\n\t// was received on this particular candidate pair, excluding STUN packets.\n\tLastPacketReceivedTimestamp StatsTimestamp `json:\"lastPacketReceivedTimestamp\"`\n\n\t// FirstRequestTimestamp represents the timestamp at which the first STUN request\n\t// was sent on this particular candidate pair.\n\tFirstRequestTimestamp StatsTimestamp `json:\"firstRequestTimestamp\"`\n\n\t// LastRequestTimestamp represents the timestamp at which the last STUN request\n\t// was sent on this particular candidate pair. The average interval between two\n\t// consecutive connectivity checks sent can be calculated with\n\t// (LastRequestTimestamp - FirstRequestTimestamp) / RequestsSent.\n\tLastRequestTimestamp StatsTimestamp `json:\"lastRequestTimestamp\"`\n\n\t// LastResponseTimestamp represents the timestamp at which the last STUN response\n\t// was received on this particular candidate pair.\n\tLastResponseTimestamp StatsTimestamp `json:\"lastResponseTimestamp\"`\n\n\t// TotalRoundTripTime represents the sum of all round trip time measurements\n\t// in seconds since the beginning of the session, based on STUN connectivity\n\t// check responses (ResponsesReceived), including those that reply to requests\n\t// that are sent in order to verify consent. The average round trip time can\n\t// be computed from TotalRoundTripTime by dividing it by ResponsesReceived.\n\tTotalRoundTripTime float64 `json:\"totalRoundTripTime\"`\n\n\t// CurrentRoundTripTime represents the latest round trip time measured in seconds,\n\t// computed from both STUN connectivity checks, including those that are sent\n\t// for consent verification.\n\tCurrentRoundTripTime float64 `json:\"currentRoundTripTime\"`\n\n\t// AvailableOutgoingBitrate is calculated by the underlying congestion control\n\t// by combining the available bitrate for all the outgoing RTP streams using\n\t// this candidate pair. The bitrate measurement does not count the size of the\n\t// IP or other transport layers like TCP or UDP. It is similar to the TIAS defined\n\t// in RFC 3890, i.e., it is measured in bits per second and the bitrate is calculated\n\t// over a 1 second window.\n\tAvailableOutgoingBitrate float64 `json:\"availableOutgoingBitrate\"`\n\n\t// AvailableIncomingBitrate is calculated by the underlying congestion control\n\t// by combining the available bitrate for all the incoming RTP streams using\n\t// this candidate pair. The bitrate measurement does not count the size of the\n\t// IP or other transport layers like TCP or UDP. It is similar to the TIAS defined\n\t// in  RFC 3890, i.e., it is measured in bits per second and the bitrate is\n\t// calculated over a 1 second window.\n\tAvailableIncomingBitrate float64 `json:\"availableIncomingBitrate\"`\n\n\t// CircuitBreakerTriggerCount represents the number of times the circuit breaker\n\t// is triggered for this particular 5-tuple, ceasing transmission.\n\tCircuitBreakerTriggerCount uint32 `json:\"circuitBreakerTriggerCount\"`\n\n\t// RequestsReceived represents the total number of connectivity check requests\n\t// received (including retransmissions). It is impossible for the receiver to\n\t// tell whether the request was sent in order to check connectivity or check\n\t// consent, so all connectivity checks requests are counted here.\n\tRequestsReceived uint64 `json:\"requestsReceived\"`\n\n\t// RequestsSent represents the total number of connectivity check requests\n\t// sent (not including retransmissions).\n\tRequestsSent uint64 `json:\"requestsSent\"`\n\n\t// ResponsesReceived represents the total number of connectivity check responses received.\n\tResponsesReceived uint64 `json:\"responsesReceived\"`\n\n\t// ResponsesSent represents the total number of connectivity check responses sent.\n\t// Since we cannot distinguish connectivity check requests and consent requests,\n\t// all responses are counted.\n\tResponsesSent uint64 `json:\"responsesSent\"`\n\n\t// RetransmissionsReceived represents the total number of connectivity check\n\t// request retransmissions received.\n\tRetransmissionsReceived uint64 `json:\"retransmissionsReceived\"`\n\n\t// RetransmissionsSent represents the total number of connectivity check\n\t// request retransmissions sent.\n\tRetransmissionsSent uint64 `json:\"retransmissionsSent\"`\n\n\t// ConsentRequestsSent represents the total number of consent requests sent.\n\tConsentRequestsSent uint64 `json:\"consentRequestsSent\"`\n\n\t// ConsentExpiredTimestamp represents the timestamp at which the latest valid\n\t// STUN binding response expired.\n\tConsentExpiredTimestamp StatsTimestamp `json:\"consentExpiredTimestamp\"`\n\n\t// PacketsDiscardedOnSend retpresents the total number of packets for this candidate pair\n\t// that have been discarded due to socket errors, i.e. a socket error occurred\n\t// when handing the packets to the socket. This might happen due to various reasons,\n\t// including full buffer or no available memory.\n\tPacketsDiscardedOnSend uint32 `json:\"packetsDiscardedOnSend\"`\n\n\t// BytesDiscardedOnSend represents the total number of bytes for this candidate pair\n\t// that have been discarded due to socket errors, i.e. a socket error occurred\n\t// when handing the packets containing the bytes to the socket. This might happen due\n\t// to various reasons, including full buffer or no available memory.\n\t// Calculated as defined in [RFC3550] section 6.4.1.\n\tBytesDiscardedOnSend uint32 `json:\"bytesDiscardedOnSend\"`\n}\n\nfunc (s ICECandidatePairStats) statsMarker() {}\n\nfunc unmarshalICECandidatePairStats(b []byte) (ICECandidatePairStats, error) {\n\tvar iceCandidatePairStats ICECandidatePairStats\n\terr := json.Unmarshal(b, &iceCandidatePairStats)\n\tif err != nil {\n\t\treturn ICECandidatePairStats{}, fmt.Errorf(\"unmarshal ice candidate pair stats: %w\", err)\n\t}\n\treturn iceCandidatePairStats, nil\n}\n\n// ICECandidateStats contains ICE candidate statistics related to the ICETransport objects.\ntype ICECandidateStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// TransportID is a unique identifier that is associated to the object that\n\t// was inspected to produce the TransportStats associated with this candidate.\n\tTransportID string `json:\"transportId\"`\n\n\t// NetworkType represents the type of network interface used by the base of a\n\t// local candidate (the address the ICE agent sends from). Only present for\n\t// local candidates; it's not possible to know what type of network interface\n\t// a remote candidate is using.\n\t//\n\t// Note:\n\t// This stat only tells you about the network interface used by the first \"hop\";\n\t// it's possible that a connection will be bottlenecked by another type of network.\n\t// For example, when using Wi-Fi tethering, the networkType of the relevant candidate\n\t// would be \"wifi\", even when the next hop is over a cellular connection.\n\t//\n\t// DEPRECATED. Although it may still work in some browsers, the networkType property was deprecated for\n\t// preserving privacy.\n\tNetworkType string `json:\"networkType,omitempty\"`\n\n\t// IP is the IP address of the candidate, allowing for IPv4 addresses and\n\t// IPv6 addresses, but fully qualified domain names (FQDNs) are not allowed.\n\tIP string `json:\"ip\"`\n\n\t// Port is the port number of the candidate.\n\tPort int32 `json:\"port\"`\n\n\t// Protocol is one of udp and tcp.\n\tProtocol string `json:\"protocol\"`\n\n\t// CandidateType is the \"Type\" field of the ICECandidate.\n\tCandidateType ICECandidateType `json:\"candidateType\"`\n\n\t// Priority is the \"Priority\" field of the ICECandidate.\n\tPriority int32 `json:\"priority\"`\n\n\t// URL is the URL of the TURN or STUN server indicated in the that translated\n\t// this IP address. It is the URL address surfaced in an PeerConnectionICEEvent.\n\tURL string `json:\"url\"`\n\n\t// RelayProtocol is the protocol used by the endpoint to communicate with the\n\t// TURN server. This is only present for local candidates. Valid values for\n\t// the TURN URL protocol is one of udp, tcp, or tls.\n\tRelayProtocol string `json:\"relayProtocol\"`\n\n\t// Deleted is true if the candidate has been deleted/freed. For host candidates,\n\t// this means that any network resources (typically a socket) associated with the\n\t// candidate have been released. For TURN candidates, this means the TURN allocation\n\t// is no longer active.\n\t//\n\t// Only defined for local candidates. For remote candidates, this property is not applicable.\n\tDeleted bool `json:\"deleted\"`\n}\n\nfunc (s ICECandidateStats) statsMarker() {}\n\nfunc unmarshalICECandidateStats(b []byte) (ICECandidateStats, error) {\n\tvar iceCandidateStats ICECandidateStats\n\terr := json.Unmarshal(b, &iceCandidateStats)\n\tif err != nil {\n\t\treturn ICECandidateStats{}, fmt.Errorf(\"unmarshal ice candidate stats: %w\", err)\n\t}\n\treturn iceCandidateStats, nil\n}\n\n// CertificateStats contains information about a certificate used by an ICETransport.\ntype CertificateStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// Fingerprint is the fingerprint of the certificate.\n\tFingerprint string `json:\"fingerprint\"`\n\n\t// FingerprintAlgorithm is the hash function used to compute the certificate fingerprint. For instance, \"sha-256\".\n\tFingerprintAlgorithm string `json:\"fingerprintAlgorithm\"`\n\n\t// Base64Certificate is the DER-encoded base-64 representation of the certificate.\n\tBase64Certificate string `json:\"base64Certificate\"`\n\n\t// IssuerCertificateID refers to the stats object that contains the next certificate\n\t// in the certificate chain. If the current certificate is at the end of the chain\n\t// (i.e. a self-signed certificate), this will not be set.\n\tIssuerCertificateID string `json:\"issuerCertificateId\"`\n}\n\nfunc (s CertificateStats) statsMarker() {}\n\nfunc unmarshalCertificateStats(b []byte) (CertificateStats, error) {\n\tvar certificateStats CertificateStats\n\terr := json.Unmarshal(b, &certificateStats)\n\tif err != nil {\n\t\treturn CertificateStats{}, fmt.Errorf(\"unmarshal certificate stats: %w\", err)\n\t}\n\treturn certificateStats, nil\n}\n\n// SCTPTransportStats contains information about a certificate used by an SCTPTransport.\ntype SCTPTransportStats struct {\n\t// Timestamp is the timestamp associated with this object.\n\tTimestamp StatsTimestamp `json:\"timestamp\"`\n\n\t// Type is the object's StatsType\n\tType StatsType `json:\"type\"`\n\n\t// ID is a unique id that is associated with the component inspected to produce\n\t// this Stats object. Two Stats objects will have the same ID if they were produced\n\t// by inspecting the same underlying object.\n\tID string `json:\"id\"`\n\n\t// TransportID is the identifier of the object that was inspected to produce the\n\t// RTCTransportStats for the DTLSTransport and ICETransport supporting the SCTP transport.\n\tTransportID string `json:\"transportId\"`\n\n\t// SmoothedRoundTripTime is the latest smoothed round-trip time value, corresponding to spinfo_srtt defined in [RFC6458]\n\t// but converted to seconds. If there has been no round-trip time measurements yet, this value is undefined.\n\tSmoothedRoundTripTime float64 `json:\"smoothedRoundTripTime\"`\n\n\t// CongestionWindow is the latest congestion window, corresponding to spinfo_cwnd defined in [RFC6458].\n\tCongestionWindow uint32 `json:\"congestionWindow\"`\n\n\t// ReceiverWindow is the latest receiver window, corresponding to sstat_rwnd defined in [RFC6458].\n\tReceiverWindow uint32 `json:\"receiverWindow\"`\n\n\t// MTU is the latest maximum transmission unit, corresponding to spinfo_mtu defined in [RFC6458].\n\tMTU uint32 `json:\"mtu\"`\n\n\t// UNACKData is the number of unacknowledged DATA chunks, corresponding to sstat_unackdata defined in [RFC6458].\n\tUNACKData uint32 `json:\"unackData\"`\n\n\t// BytesSent represents the total number of bytes sent on this SCTPTransport\n\tBytesSent uint64 `json:\"bytesSent\"`\n\n\t// BytesReceived represents the total number of bytes received on this SCTPTransport\n\tBytesReceived uint64 `json:\"bytesReceived\"`\n}\n\nfunc (s SCTPTransportStats) statsMarker() {}\n\nfunc unmarshalSCTPTransportStats(b []byte) (SCTPTransportStats, error) {\n\tvar sctpTransportStats SCTPTransportStats\n\tif err := json.Unmarshal(b, &sctpTransportStats); err != nil {\n\t\treturn SCTPTransportStats{}, fmt.Errorf(\"unmarshal sctp transport stats: %w\", err)\n\t}\n\treturn sctpTransportStats, nil\n}\n"
        },
        {
          "name": "stats_go.go",
          "type": "blob",
          "size": 2.53125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\n// GetConnectionStats is a helper method to return the associated stats for a given PeerConnection\nfunc (r StatsReport) GetConnectionStats(conn *PeerConnection) (PeerConnectionStats, bool) {\n\tstatsID := conn.getStatsID()\n\tstats, ok := r[statsID]\n\tif !ok {\n\t\treturn PeerConnectionStats{}, false\n\t}\n\n\tpcStats, ok := stats.(PeerConnectionStats)\n\tif !ok {\n\t\treturn PeerConnectionStats{}, false\n\t}\n\treturn pcStats, true\n}\n\n// GetDataChannelStats is a helper method to return the associated stats for a given DataChannel\nfunc (r StatsReport) GetDataChannelStats(dc *DataChannel) (DataChannelStats, bool) {\n\tstatsID := dc.getStatsID()\n\tstats, ok := r[statsID]\n\tif !ok {\n\t\treturn DataChannelStats{}, false\n\t}\n\n\tdcStats, ok := stats.(DataChannelStats)\n\tif !ok {\n\t\treturn DataChannelStats{}, false\n\t}\n\treturn dcStats, true\n}\n\n// GetICECandidateStats is a helper method to return the associated stats for a given ICECandidate\nfunc (r StatsReport) GetICECandidateStats(c *ICECandidate) (ICECandidateStats, bool) {\n\tstatsID := c.statsID\n\tstats, ok := r[statsID]\n\tif !ok {\n\t\treturn ICECandidateStats{}, false\n\t}\n\n\tcandidateStats, ok := stats.(ICECandidateStats)\n\tif !ok {\n\t\treturn ICECandidateStats{}, false\n\t}\n\treturn candidateStats, true\n}\n\n// GetICECandidatePairStats is a helper method to return the associated stats for a given ICECandidatePair\nfunc (r StatsReport) GetICECandidatePairStats(c *ICECandidatePair) (ICECandidatePairStats, bool) {\n\tstatsID := c.statsID\n\tstats, ok := r[statsID]\n\tif !ok {\n\t\treturn ICECandidatePairStats{}, false\n\t}\n\n\tcandidateStats, ok := stats.(ICECandidatePairStats)\n\tif !ok {\n\t\treturn ICECandidatePairStats{}, false\n\t}\n\treturn candidateStats, true\n}\n\n// GetCertificateStats is a helper method to return the associated stats for a given Certificate\nfunc (r StatsReport) GetCertificateStats(c *Certificate) (CertificateStats, bool) {\n\tstatsID := c.statsID\n\tstats, ok := r[statsID]\n\tif !ok {\n\t\treturn CertificateStats{}, false\n\t}\n\n\tcertificateStats, ok := stats.(CertificateStats)\n\tif !ok {\n\t\treturn CertificateStats{}, false\n\t}\n\treturn certificateStats, true\n}\n\n// GetCodecStats is a helper method to return the associated stats for a given Codec\nfunc (r StatsReport) GetCodecStats(c *RTPCodecParameters) (CodecStats, bool) {\n\tstatsID := c.statsID\n\tstats, ok := r[statsID]\n\tif !ok {\n\t\treturn CodecStats{}, false\n\t}\n\n\tcodecStats, ok := stats.(CodecStats)\n\tif !ok {\n\t\treturn CodecStats{}, false\n\t}\n\treturn codecStats, true\n}\n"
        },
        {
          "name": "stats_go_test.go",
          "type": "blob",
          "size": 42.3662109375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/ice/v4\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar errReceiveOfferTimeout = fmt.Errorf(\"timed out waiting to receive offer\")\n\nfunc TestStatsTimestampTime(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tTimestamp StatsTimestamp\n\t\tWantTime  time.Time\n\t}{\n\t\t{\n\t\t\tTimestamp: 0,\n\t\t\tWantTime:  time.Unix(0, 0),\n\t\t},\n\t\t{\n\t\t\tTimestamp: 1,\n\t\t\tWantTime:  time.Unix(0, 1e6),\n\t\t},\n\t\t{\n\t\t\tTimestamp: 0.001,\n\t\t\tWantTime:  time.Unix(0, 1e3),\n\t\t},\n\t} {\n\t\tif got, want := test.Timestamp.Time(), test.WantTime.UTC(); got != want {\n\t\t\tt.Fatalf(\"StatsTimestamp(%v).Time() = %v, want %v\", test.Timestamp, got, want)\n\t\t}\n\t}\n}\n\ntype statSample struct {\n\tname  string\n\tstats Stats\n\tjson  string\n}\n\nfunc getStatsSamples() []statSample {\n\tcodecStats := CodecStats{\n\t\tTimestamp:      1688978831527.718,\n\t\tType:           StatsTypeCodec,\n\t\tID:             \"COT01_111_minptime=10;useinbandfec=1\",\n\t\tPayloadType:    111,\n\t\tCodecType:      CodecTypeEncode,\n\t\tTransportID:    \"T01\",\n\t\tMimeType:       \"audio/opus\",\n\t\tClockRate:      48000,\n\t\tChannels:       2,\n\t\tSDPFmtpLine:    \"minptime=10;useinbandfec=1\",\n\t\tImplementation: \"libvpx\",\n\t}\n\tcodecStatsJSON := `\n{\n\t\"timestamp\": 1688978831527.718,\n\t\"type\": \"codec\",\n\t\"id\": \"COT01_111_minptime=10;useinbandfec=1\",\n\t\"payloadType\": 111,\n\t\"codecType\": \"encode\",\n\t\"transportId\": \"T01\",\n\t\"mimeType\": \"audio/opus\",\n\t\"clockRate\": 48000,\n\t\"channels\": 2,\n\t\"sdpFmtpLine\": \"minptime=10;useinbandfec=1\",\n\t\"implementation\": \"libvpx\"\n}\n`\n\tinboundRTPStreamStats := InboundRTPStreamStats{\n\t\tMid:                            \"1\",\n\t\tTimestamp:                      1688978831527.718,\n\t\tID:                             \"IT01A2184088143\",\n\t\tType:                           StatsTypeInboundRTP,\n\t\tSSRC:                           2184088143,\n\t\tKind:                           \"audio\",\n\t\tTransportID:                    \"T01\",\n\t\tCodecID:                        \"CIT01_111_minptime=10;useinbandfec=1\",\n\t\tFIRCount:                       1,\n\t\tPLICount:                       2,\n\t\tTotalProcessingDelay:           23,\n\t\tNACKCount:                      3,\n\t\tJitterBufferDelay:              24,\n\t\tJitterBufferTargetDelay:        25,\n\t\tJitterBufferEmittedCount:       26,\n\t\tJitterBufferMinimumDelay:       27,\n\t\tTotalSamplesReceived:           28,\n\t\tConcealedSamples:               29,\n\t\tSilentConcealedSamples:         30,\n\t\tConcealmentEvents:              31,\n\t\tInsertedSamplesForDeceleration: 32,\n\t\tRemovedSamplesForAcceleration:  33,\n\t\tAudioLevel:                     34,\n\t\tTotalAudioEnergy:               35,\n\t\tTotalSamplesDuration:           36,\n\t\tSLICount:                       4,\n\t\tQPSum:                          5,\n\t\tTotalDecodeTime:                37,\n\t\tTotalInterFrameDelay:           38,\n\t\tTotalSquaredInterFrameDelay:    39,\n\t\tPacketsReceived:                6,\n\t\tPacketsLost:                    7,\n\t\tJitter:                         8,\n\t\tPacketsDiscarded:               9,\n\t\tPacketsRepaired:                10,\n\t\tBurstPacketsLost:               11,\n\t\tBurstPacketsDiscarded:          12,\n\t\tBurstLossCount:                 13,\n\t\tBurstDiscardCount:              14,\n\t\tBurstLossRate:                  15,\n\t\tBurstDiscardRate:               16,\n\t\tGapLossRate:                    17,\n\t\tGapDiscardRate:                 18,\n\t\tTrackID:                        \"d57dbc4b-484b-4b40-9088-d3150e3a2010\",\n\t\tReceiverID:                     \"R01\",\n\t\tRemoteID:                       \"ROA2184088143\",\n\t\tFramesDecoded:                  17,\n\t\tKeyFramesDecoded:               40,\n\t\tFramesRendered:                 41,\n\t\tFramesDropped:                  42,\n\t\tFrameWidth:                     43,\n\t\tFrameHeight:                    44,\n\t\tLastPacketReceivedTimestamp:    1689668364374.181,\n\t\tHeaderBytesReceived:            45,\n\t\tAverageRTCPInterval:            18,\n\t\tFECPacketsReceived:             19,\n\t\tFECPacketsDiscarded:            46,\n\t\tBytesReceived:                  20,\n\t\tFramesReceived:                 47,\n\t\tPacketsFailedDecryption:        21,\n\t\tPacketsDuplicated:              22,\n\t\tPerDSCPPacketsReceived: map[string]uint32{\n\t\t\t\"123\": 23,\n\t\t},\n\t\tDecoderImplementation: \"libvpx\",\n\t\tPauseCount:            48,\n\t\tTotalPausesDuration:   48.123,\n\t\tFreezeCount:           49,\n\t\tTotalFreezesDuration:  49.321,\n\t\tPowerEfficientDecoder: true,\n\t}\n\tinboundRTPStreamStatsJSON := `\n{\n  \"mid\": \"1\",\n  \"timestamp\": 1688978831527.718,\n  \"id\": \"IT01A2184088143\",\n  \"type\": \"inbound-rtp\",\n  \"ssrc\": 2184088143,\n  \"kind\": \"audio\",\n  \"transportId\": \"T01\",\n  \"codecId\": \"CIT01_111_minptime=10;useinbandfec=1\",\n  \"firCount\": 1,\n  \"pliCount\": 2,\n  \"totalProcessingDelay\": 23,\n  \"nackCount\": 3,\n  \"jitterBufferDelay\": 24,\n  \"jitterBufferTargetDelay\": 25,\n  \"jitterBufferEmittedCount\": 26,\n  \"jitterBufferMinimumDelay\": 27,\n  \"totalSamplesReceived\": 28,\n  \"concealedSamples\": 29,\n  \"silentConcealedSamples\": 30,\n  \"concealmentEvents\": 31,\n  \"insertedSamplesForDeceleration\": 32,\n  \"removedSamplesForAcceleration\": 33,\n  \"audioLevel\": 34,\n  \"totalAudioEnergy\": 35,\n  \"totalSamplesDuration\": 36,\n  \"sliCount\": 4,\n  \"qpSum\": 5,\n  \"totalDecodeTime\": 37,\n  \"totalInterFrameDelay\": 38,\n  \"totalSquaredInterFrameDelay\": 39,\n  \"packetsReceived\": 6,\n  \"packetsLost\": 7,\n  \"jitter\": 8,\n  \"packetsDiscarded\": 9,\n  \"packetsRepaired\": 10,\n  \"burstPacketsLost\": 11,\n  \"burstPacketsDiscarded\": 12,\n  \"burstLossCount\": 13,\n  \"burstDiscardCount\": 14,\n  \"burstLossRate\": 15,\n  \"burstDiscardRate\": 16,\n  \"gapLossRate\": 17,\n  \"gapDiscardRate\": 18,\n  \"trackId\": \"d57dbc4b-484b-4b40-9088-d3150e3a2010\",\n  \"receiverId\": \"R01\",\n  \"remoteId\": \"ROA2184088143\",\n  \"framesDecoded\": 17,\n  \"keyFramesDecoded\": 40,\n  \"framesRendered\": 41,\n  \"framesDropped\": 42,\n  \"frameWidth\": 43,\n  \"frameHeight\": 44,\n  \"lastPacketReceivedTimestamp\": 1689668364374.181,\n  \"headerBytesReceived\": 45,\n  \"averageRtcpInterval\": 18,\n  \"fecPacketsReceived\": 19,\n  \"fecPacketsDiscarded\": 46,\n  \"bytesReceived\": 20,\n  \"framesReceived\": 47,\n  \"packetsFailedDecryption\": 21,\n  \"packetsDuplicated\": 22,\n  \"perDscpPacketsReceived\": {\n    \"123\": 23\n  },\n  \"decoderImplementation\": \"libvpx\",\n  \"pauseCount\": 48,\n  \"totalPausesDuration\": 48.123,\n  \"freezeCount\": 49,\n  \"totalFreezesDuration\": 49.321,\n  \"powerEfficientDecoder\": true\n}\n`\n\toutboundRTPStreamStats := OutboundRTPStreamStats{\n\t\tMid:                      \"1\",\n\t\tRid:                      \"hi\",\n\t\tMediaSourceID:            \"SA5\",\n\t\tTimestamp:                1688978831527.718,\n\t\tType:                     StatsTypeOutboundRTP,\n\t\tID:                       \"OT01A2184088143\",\n\t\tSSRC:                     2184088143,\n\t\tKind:                     \"audio\",\n\t\tTransportID:              \"T01\",\n\t\tCodecID:                  \"COT01_111_minptime=10;useinbandfec=1\",\n\t\tHeaderBytesSent:          24,\n\t\tRetransmittedPacketsSent: 25,\n\t\tRetransmittedBytesSent:   26,\n\t\tFIRCount:                 1,\n\t\tPLICount:                 2,\n\t\tNACKCount:                3,\n\t\tSLICount:                 4,\n\t\tQPSum:                    5,\n\t\tPacketsSent:              6,\n\t\tPacketsDiscardedOnSend:   7,\n\t\tFECPacketsSent:           8,\n\t\tBytesSent:                9,\n\t\tBytesDiscardedOnSend:     10,\n\t\tTrackID:                  \"d57dbc4b-484b-4b40-9088-d3150e3a2010\",\n\t\tSenderID:                 \"S01\",\n\t\tRemoteID:                 \"ROA2184088143\",\n\t\tLastPacketSentTimestamp:  11,\n\t\tTargetBitrate:            12,\n\t\tTotalEncodedBytesTarget:  27,\n\t\tFrameWidth:               28,\n\t\tFrameHeight:              29,\n\t\tFramesPerSecond:          30,\n\t\tFramesSent:               31,\n\t\tHugeFramesSent:           32,\n\t\tFramesEncoded:            13,\n\t\tKeyFramesEncoded:         33,\n\t\tTotalEncodeTime:          14,\n\t\tTotalPacketSendDelay:     34,\n\t\tAverageRTCPInterval:      15,\n\t\tQualityLimitationReason:  \"cpu\",\n\t\tQualityLimitationDurations: map[string]float64{\n\t\t\t\"none\":      16,\n\t\t\t\"cpu\":       17,\n\t\t\t\"bandwidth\": 18,\n\t\t\t\"other\":     19,\n\t\t},\n\t\tQualityLimitationResolutionChanges: 35,\n\t\tPerDSCPPacketsSent: map[string]uint32{\n\t\t\t\"123\": 23,\n\t\t},\n\t\tActive:                true,\n\t\tEncoderImplementation: \"libvpx\",\n\t\tPowerEfficientEncoder: true,\n\t\tScalabilityMode:       \"L1T1\",\n\t}\n\toutboundRTPStreamStatsJSON := `\n{\n  \"mid\": \"1\",\n  \"rid\": \"hi\",\n  \"mediaSourceId\": \"SA5\",\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"outbound-rtp\",\n  \"id\": \"OT01A2184088143\",\n  \"ssrc\": 2184088143,\n  \"kind\": \"audio\",\n  \"transportId\": \"T01\",\n  \"codecId\": \"COT01_111_minptime=10;useinbandfec=1\",\n  \"headerBytesSent\": 24,\n  \"retransmittedPacketsSent\": 25,\n  \"retransmittedBytesSent\": 26,\n  \"firCount\": 1,\n  \"pliCount\": 2,\n  \"nackCount\": 3,\n  \"sliCount\": 4,\n  \"qpSum\": 5,\n  \"packetsSent\": 6,\n  \"packetsDiscardedOnSend\": 7,\n  \"fecPacketsSent\": 8,\n  \"bytesSent\": 9,\n  \"bytesDiscardedOnSend\": 10,\n  \"trackId\": \"d57dbc4b-484b-4b40-9088-d3150e3a2010\",\n  \"senderId\": \"S01\",\n  \"remoteId\": \"ROA2184088143\",\n  \"lastPacketSentTimestamp\": 11,\n  \"targetBitrate\": 12,\n  \"totalEncodedBytesTarget\": 27,\n  \"frameWidth\": 28,\n  \"frameHeight\": 29,\n  \"framesPerSecond\": 30,\n  \"framesSent\": 31,\n  \"hugeFramesSent\": 32,\n  \"framesEncoded\": 13,\n  \"keyFramesEncoded\": 33,\n  \"totalEncodeTime\": 14,\n  \"totalPacketSendDelay\": 34,\n  \"averageRtcpInterval\": 15,\n  \"qualityLimitationReason\": \"cpu\",\n  \"qualityLimitationDurations\": {\n    \"none\": 16,\n    \"cpu\": 17,\n    \"bandwidth\": 18,\n    \"other\": 19\n  },\n  \"qualityLimitationResolutionChanges\": 35,\n  \"perDscpPacketsSent\": {\n    \"123\": 23\n  },\n  \"active\": true,\n  \"encoderImplementation\": \"libvpx\",\n  \"powerEfficientEncoder\": true,\n  \"scalabilityMode\": \"L1T1\"\n}\n`\n\tremoteInboundRTPStreamStats := RemoteInboundRTPStreamStats{\n\t\tTimestamp:                 1688978831527.718,\n\t\tType:                      StatsTypeRemoteInboundRTP,\n\t\tID:                        \"RIA2184088143\",\n\t\tSSRC:                      2184088143,\n\t\tKind:                      \"audio\",\n\t\tTransportID:               \"T01\",\n\t\tCodecID:                   \"COT01_111_minptime=10;useinbandfec=1\",\n\t\tFIRCount:                  1,\n\t\tPLICount:                  2,\n\t\tNACKCount:                 3,\n\t\tSLICount:                  4,\n\t\tQPSum:                     5,\n\t\tPacketsReceived:           6,\n\t\tPacketsLost:               7,\n\t\tJitter:                    8,\n\t\tPacketsDiscarded:          9,\n\t\tPacketsRepaired:           10,\n\t\tBurstPacketsLost:          11,\n\t\tBurstPacketsDiscarded:     12,\n\t\tBurstLossCount:            13,\n\t\tBurstDiscardCount:         14,\n\t\tBurstLossRate:             15,\n\t\tBurstDiscardRate:          16,\n\t\tGapLossRate:               17,\n\t\tGapDiscardRate:            18,\n\t\tLocalID:                   \"RIA2184088143\",\n\t\tRoundTripTime:             19,\n\t\tTotalRoundTripTime:        21,\n\t\tFractionLost:              20,\n\t\tRoundTripTimeMeasurements: 22,\n\t}\n\tremoteInboundRTPStreamStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"remote-inbound-rtp\",\n  \"id\": \"RIA2184088143\",\n  \"ssrc\": 2184088143,\n  \"kind\": \"audio\",\n  \"transportId\": \"T01\",\n  \"codecId\": \"COT01_111_minptime=10;useinbandfec=1\",\n  \"firCount\": 1,\n  \"pliCount\": 2,\n  \"nackCount\": 3,\n  \"sliCount\": 4,\n  \"qpSum\": 5,\n  \"packetsReceived\": 6,\n  \"packetsLost\": 7,\n  \"jitter\": 8,\n  \"packetsDiscarded\": 9,\n  \"packetsRepaired\": 10,\n  \"burstPacketsLost\": 11,\n  \"burstPacketsDiscarded\": 12,\n  \"burstLossCount\": 13,\n  \"burstDiscardCount\": 14,\n  \"burstLossRate\": 15,\n  \"burstDiscardRate\": 16,\n  \"gapLossRate\": 17,\n  \"gapDiscardRate\": 18,\n  \"localId\": \"RIA2184088143\",\n  \"roundTripTime\": 19,\n  \"totalRoundTripTime\": 21,\n  \"fractionLost\": 20,\n  \"roundTripTimeMeasurements\": 22\n}\n`\n\tremoteOutboundRTPStreamStats := RemoteOutboundRTPStreamStats{\n\t\tTimestamp:                 1688978831527.718,\n\t\tType:                      StatsTypeRemoteOutboundRTP,\n\t\tID:                        \"ROA2184088143\",\n\t\tSSRC:                      2184088143,\n\t\tKind:                      \"audio\",\n\t\tTransportID:               \"T01\",\n\t\tCodecID:                   \"CIT01_111_minptime=10;useinbandfec=1\",\n\t\tFIRCount:                  1,\n\t\tPLICount:                  2,\n\t\tNACKCount:                 3,\n\t\tSLICount:                  4,\n\t\tQPSum:                     5,\n\t\tPacketsSent:               1259,\n\t\tPacketsDiscardedOnSend:    6,\n\t\tFECPacketsSent:            7,\n\t\tBytesSent:                 92654,\n\t\tBytesDiscardedOnSend:      8,\n\t\tLocalID:                   \"IT01A2184088143\",\n\t\tRemoteTimestamp:           1689668361298,\n\t\tReportsSent:               9,\n\t\tRoundTripTime:             10,\n\t\tTotalRoundTripTime:        11,\n\t\tRoundTripTimeMeasurements: 12,\n\t}\n\tremoteOutboundRTPStreamStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"remote-outbound-rtp\",\n  \"id\": \"ROA2184088143\",\n  \"ssrc\": 2184088143,\n  \"kind\": \"audio\",\n  \"transportId\": \"T01\",\n  \"codecId\": \"CIT01_111_minptime=10;useinbandfec=1\",\n  \"firCount\": 1,\n  \"pliCount\": 2,\n  \"nackCount\": 3,\n  \"sliCount\": 4,\n  \"qpSum\": 5,\n  \"packetsSent\": 1259,\n  \"packetsDiscardedOnSend\": 6,\n  \"fecPacketsSent\": 7,\n  \"bytesSent\": 92654,\n  \"bytesDiscardedOnSend\": 8,\n  \"localId\": \"IT01A2184088143\",\n  \"remoteTimestamp\": 1689668361298,\n  \"reportsSent\": 9,\n  \"roundTripTime\": 10,\n  \"totalRoundTripTime\": 11,\n  \"roundTripTimeMeasurements\": 12\n}\n`\n\tcsrcStats := RTPContributingSourceStats{\n\t\tTimestamp:            1688978831527.718,\n\t\tType:                 StatsTypeCSRC,\n\t\tID:                   \"ROA2184088143\",\n\t\tContributorSSRC:      2184088143,\n\t\tInboundRTPStreamID:   \"IT01A2184088143\",\n\t\tPacketsContributedTo: 5,\n\t\tAudioLevel:           0.3,\n\t}\n\tcsrcStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"csrc\",\n  \"id\": \"ROA2184088143\",\n  \"contributorSsrc\": 2184088143,\n  \"inboundRtpStreamId\": \"IT01A2184088143\",\n  \"packetsContributedTo\": 5,\n  \"audioLevel\": 0.3\n}\n`\n\taudioSourceStats := AudioSourceStats{\n\t\tTimestamp:                 1689668364374.479,\n\t\tType:                      StatsTypeMediaSource,\n\t\tID:                        \"SA5\",\n\t\tTrackIdentifier:           \"d57dbc4b-484b-4b40-9088-d3150e3a2010\",\n\t\tKind:                      \"audio\",\n\t\tAudioLevel:                0.0030518509475997192,\n\t\tTotalAudioEnergy:          0.0024927631236904358,\n\t\tTotalSamplesDuration:      28.360000000001634,\n\t\tEchoReturnLoss:            -30,\n\t\tEchoReturnLossEnhancement: 0.17551203072071075,\n\t\tDroppedSamplesDuration:    0.1,\n\t\tDroppedSamplesEvents:      2,\n\t\tTotalCaptureDelay:         0.3,\n\t\tTotalSamplesCaptured:      4,\n\t}\n\taudioSourceStatsJSON := `\n{\n  \"timestamp\": 1689668364374.479,\n  \"type\": \"media-source\",\n  \"id\": \"SA5\",\n  \"trackIdentifier\": \"d57dbc4b-484b-4b40-9088-d3150e3a2010\",\n  \"kind\": \"audio\",\n  \"audioLevel\": 0.0030518509475997192,\n  \"totalAudioEnergy\": 0.0024927631236904358,\n  \"totalSamplesDuration\": 28.360000000001634,\n  \"echoReturnLoss\": -30,\n  \"echoReturnLossEnhancement\": 0.17551203072071075,\n  \"droppedSamplesDuration\": 0.1,\n  \"droppedSamplesEvents\": 2,\n  \"totalCaptureDelay\": 0.3,\n  \"totalSamplesCaptured\": 4\n}\n`\n\tvideoSourceStats := VideoSourceStats{\n\t\tTimestamp:       1689668364374.479,\n\t\tType:            StatsTypeMediaSource,\n\t\tID:              \"SV6\",\n\t\tTrackIdentifier: \"d7f11739-d395-42e9-af87-5dfa1cc10ee0\",\n\t\tKind:            \"video\",\n\t\tWidth:           640,\n\t\tHeight:          480,\n\t\tFrames:          850,\n\t\tFramesPerSecond: 30,\n\t}\n\tvideoSourceStatsJSON := `\n{\n  \"timestamp\": 1689668364374.479,\n  \"type\": \"media-source\",\n  \"id\": \"SV6\",\n  \"trackIdentifier\": \"d7f11739-d395-42e9-af87-5dfa1cc10ee0\",\n  \"kind\": \"video\",\n  \"width\": 640,\n  \"height\": 480,\n  \"frames\": 850,\n  \"framesPerSecond\": 30\n}\n`\n\taudioPlayoutStats := AudioPlayoutStats{\n\t\tTimestamp:                  1689668364374.181,\n\t\tType:                       StatsTypeMediaPlayout,\n\t\tID:                         \"AP\",\n\t\tKind:                       \"audio\",\n\t\tSynthesizedSamplesDuration: 1,\n\t\tSynthesizedSamplesEvents:   2,\n\t\tTotalSamplesDuration:       593.5,\n\t\tTotalPlayoutDelay:          1062194.11536,\n\t\tTotalSamplesCount:          28488000,\n\t}\n\taudioPlayoutStatsJSON := `\n{\n  \"timestamp\": 1689668364374.181,\n  \"type\": \"media-playout\",\n  \"id\": \"AP\",\n  \"kind\": \"audio\",\n  \"synthesizedSamplesDuration\": 1,\n  \"synthesizedSamplesEvents\": 2,\n  \"totalSamplesDuration\": 593.5,\n  \"totalPlayoutDelay\": 1062194.11536,\n  \"totalSamplesCount\": 28488000\n}\n`\n\tpeerConnectionStats := PeerConnectionStats{\n\t\tTimestamp:             1688978831527.718,\n\t\tType:                  StatsTypePeerConnection,\n\t\tID:                    \"P\",\n\t\tDataChannelsOpened:    1,\n\t\tDataChannelsClosed:    2,\n\t\tDataChannelsRequested: 3,\n\t\tDataChannelsAccepted:  4,\n\t}\n\tpeerConnectionStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"peer-connection\",\n  \"id\": \"P\",\n  \"dataChannelsOpened\": 1,\n  \"dataChannelsClosed\": 2,\n  \"dataChannelsRequested\": 3,\n  \"dataChannelsAccepted\": 4\n}\n`\n\tdataChannelStats := DataChannelStats{\n\t\tTimestamp:             1688978831527.718,\n\t\tType:                  StatsTypeDataChannel,\n\t\tID:                    \"D1\",\n\t\tLabel:                 \"display\",\n\t\tProtocol:              \"protocol\",\n\t\tDataChannelIdentifier: 1,\n\t\tTransportID:           \"T1\",\n\t\tState:                 DataChannelStateOpen,\n\t\tMessagesSent:          1,\n\t\tBytesSent:             16,\n\t\tMessagesReceived:      2,\n\t\tBytesReceived:         20,\n\t}\n\tdataChannelStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"data-channel\",\n  \"id\": \"D1\",\n  \"label\": \"display\",\n  \"protocol\": \"protocol\",\n  \"dataChannelIdentifier\": 1,\n  \"transportId\": \"T1\",\n  \"state\": \"open\",\n  \"messagesSent\": 1,\n  \"bytesSent\": 16,\n  \"messagesReceived\": 2,\n  \"bytesReceived\": 20\n}\n`\n\tstreamStats := MediaStreamStats{\n\t\tTimestamp:        1688978831527.718,\n\t\tType:             StatsTypeStream,\n\t\tID:               \"ROA2184088143\",\n\t\tStreamIdentifier: \"S1\",\n\t\tTrackIDs:         []string{\"d57dbc4b-484b-4b40-9088-d3150e3a2010\"},\n\t}\n\tstreamStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"stream\",\n  \"id\": \"ROA2184088143\",\n  \"streamIdentifier\": \"S1\",\n  \"trackIds\": [\n    \"d57dbc4b-484b-4b40-9088-d3150e3a2010\"\n  ]\n}\n`\n\tsenderVideoTrackAttachmentStats := SenderVideoTrackAttachmentStats{\n\t\tTimestamp:      1688978831527.718,\n\t\tType:           StatsTypeTrack,\n\t\tID:             \"S2\",\n\t\tKind:           \"video\",\n\t\tFramesCaptured: 1,\n\t\tFramesSent:     2,\n\t\tHugeFramesSent: 3,\n\t\tKeyFramesSent:  4,\n\t}\n\tsenderVideoTrackAttachmentStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"track\",\n  \"id\": \"S2\",\n  \"kind\": \"video\",\n  \"framesCaptured\": 1,\n  \"framesSent\": 2,\n  \"hugeFramesSent\": 3,\n  \"keyFramesSent\": 4\n}\n`\n\tsenderAudioTrackAttachmentStats := SenderAudioTrackAttachmentStats{\n\t\tTimestamp:                 1688978831527.718,\n\t\tType:                      StatsTypeTrack,\n\t\tID:                        \"S1\",\n\t\tTrackIdentifier:           \"audio\",\n\t\tRemoteSource:              true,\n\t\tEnded:                     true,\n\t\tKind:                      \"audio\",\n\t\tAudioLevel:                0.1,\n\t\tTotalAudioEnergy:          0.2,\n\t\tVoiceActivityFlag:         true,\n\t\tTotalSamplesDuration:      0.3,\n\t\tEchoReturnLoss:            0.4,\n\t\tEchoReturnLossEnhancement: 0.5,\n\t\tTotalSamplesSent:          200,\n\t}\n\tsenderAudioTrackAttachmentStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"track\",\n  \"id\": \"S1\",\n  \"trackIdentifier\": \"audio\",\n  \"remoteSource\": true,\n  \"ended\": true,\n  \"kind\": \"audio\",\n  \"audioLevel\": 0.1,\n  \"totalAudioEnergy\": 0.2,\n  \"voiceActivityFlag\": true,\n  \"totalSamplesDuration\": 0.3,\n  \"echoReturnLoss\": 0.4,\n  \"echoReturnLossEnhancement\": 0.5,\n  \"totalSamplesSent\": 200\n}\n`\n\tvideoSenderStats := VideoSenderStats{\n\t\tTimestamp:      1688978831527.718,\n\t\tType:           StatsTypeSender,\n\t\tID:             \"S2\",\n\t\tKind:           \"video\",\n\t\tFramesCaptured: 1,\n\t\tFramesSent:     2,\n\t\tHugeFramesSent: 3,\n\t\tKeyFramesSent:  4,\n\t}\n\tvideoSenderStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"sender\",\n  \"id\": \"S2\",\n  \"kind\": \"video\",\n  \"framesCaptured\": 1,\n  \"framesSent\": 2,\n  \"hugeFramesSent\": 3,\n  \"keyFramesSent\": 4\n}\n`\n\taudioSenderStats := AudioSenderStats{\n\t\tTimestamp:                 1688978831527.718,\n\t\tType:                      StatsTypeSender,\n\t\tID:                        \"S1\",\n\t\tTrackIdentifier:           \"audio\",\n\t\tRemoteSource:              true,\n\t\tEnded:                     true,\n\t\tKind:                      \"audio\",\n\t\tAudioLevel:                0.1,\n\t\tTotalAudioEnergy:          0.2,\n\t\tVoiceActivityFlag:         true,\n\t\tTotalSamplesDuration:      0.3,\n\t\tEchoReturnLoss:            0.4,\n\t\tEchoReturnLossEnhancement: 0.5,\n\t\tTotalSamplesSent:          200,\n\t}\n\taudioSenderStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"sender\",\n  \"id\": \"S1\",\n  \"trackIdentifier\": \"audio\",\n  \"remoteSource\": true,\n  \"ended\": true,\n  \"kind\": \"audio\",\n  \"audioLevel\": 0.1,\n  \"totalAudioEnergy\": 0.2,\n  \"voiceActivityFlag\": true,\n  \"totalSamplesDuration\": 0.3,\n  \"echoReturnLoss\": 0.4,\n  \"echoReturnLossEnhancement\": 0.5,\n  \"totalSamplesSent\": 200\n}\n`\n\tvideoReceiverStats := VideoReceiverStats{\n\t\tTimestamp:                 1688978831527.718,\n\t\tType:                      StatsTypeReceiver,\n\t\tID:                        \"ROA2184088143\",\n\t\tKind:                      \"video\",\n\t\tFrameWidth:                720,\n\t\tFrameHeight:               480,\n\t\tFramesPerSecond:           30.0,\n\t\tEstimatedPlayoutTimestamp: 1688978831527.718,\n\t\tJitterBufferDelay:         0.1,\n\t\tJitterBufferEmittedCount:  1,\n\t\tFramesReceived:            79,\n\t\tKeyFramesReceived:         10,\n\t\tFramesDecoded:             10,\n\t\tFramesDropped:             10,\n\t\tPartialFramesLost:         5,\n\t\tFullFramesLost:            5,\n\t}\n\tvideoReceiverStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"receiver\",\n  \"id\": \"ROA2184088143\",\n  \"kind\": \"video\",\n  \"frameWidth\": 720,\n  \"frameHeight\": 480,\n  \"framesPerSecond\": 30.0,\n  \"estimatedPlayoutTimestamp\": 1688978831527.718,\n  \"jitterBufferDelay\": 0.1,\n  \"jitterBufferEmittedCount\": 1,\n  \"framesReceived\": 79,\n  \"keyFramesReceived\": 10,\n  \"framesDecoded\": 10,\n  \"framesDropped\": 10,\n  \"partialFramesLost\": 5,\n  \"fullFramesLost\": 5\n}\n`\n\taudioReceiverStats := AudioReceiverStats{\n\t\tTimestamp:                 1688978831527.718,\n\t\tType:                      StatsTypeReceiver,\n\t\tID:                        \"R1\",\n\t\tKind:                      \"audio\",\n\t\tAudioLevel:                0.1,\n\t\tTotalAudioEnergy:          0.2,\n\t\tVoiceActivityFlag:         true,\n\t\tTotalSamplesDuration:      0.3,\n\t\tEstimatedPlayoutTimestamp: 1688978831527.718,\n\t\tJitterBufferDelay:         0.5,\n\t\tJitterBufferEmittedCount:  6,\n\t\tTotalSamplesReceived:      7,\n\t\tConcealedSamples:          8,\n\t\tConcealmentEvents:         9,\n\t}\n\taudioReceiverStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"receiver\",\n  \"id\": \"R1\",\n  \"kind\": \"audio\",\n  \"audioLevel\": 0.1,\n  \"totalAudioEnergy\": 0.2,\n  \"voiceActivityFlag\": true,\n  \"totalSamplesDuration\": 0.3,\n  \"estimatedPlayoutTimestamp\": 1688978831527.718,\n  \"jitterBufferDelay\": 0.5,\n  \"jitterBufferEmittedCount\": 6,\n  \"totalSamplesReceived\": 7,\n  \"concealedSamples\": 8,\n  \"concealmentEvents\": 9\n}\n`\n\ttransportStats := TransportStats{\n\t\tTimestamp:               1688978831527.718,\n\t\tType:                    StatsTypeTransport,\n\t\tID:                      \"T01\",\n\t\tPacketsSent:             60,\n\t\tPacketsReceived:         8,\n\t\tBytesSent:               6517,\n\t\tBytesReceived:           1159,\n\t\tRTCPTransportStatsID:    \"T01\",\n\t\tICERole:                 ICERoleControlling,\n\t\tDTLSState:               DTLSTransportStateConnected,\n\t\tICEState:                ICETransportStateConnected,\n\t\tSelectedCandidatePairID: \"CPxIhBDNnT_sPDhy1TB\",\n\t\tLocalCertificateID:      \"CFF4:4F:C4:C7:F3:31:6C:B9:D5:AD:19:64:05:9F:2F:E9:00:70:56:1E:BA:92:29:3A:08:CE:1B:27:CF:2D:AB:24\",\n\t\tRemoteCertificateID:     \"CF62:AF:88:F7:F3:0F:D6:C4:93:91:1E:AD:52:F0:A4:12:04:F9:48:E7:06:16:BA:A3:86:26:8F:1E:38:1C:48:49\",\n\t\tDTLSCipher:              \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n\t\tSRTPCipher:              \"AES_CM_128_HMAC_SHA1_80\",\n\t}\n\ttransportStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"transport\",\n  \"id\": \"T01\",\n  \"packetsSent\": 60,\n  \"packetsReceived\": 8,\n  \"bytesSent\": 6517,\n  \"bytesReceived\": 1159,\n  \"rtcpTransportStatsId\": \"T01\",\n  \"iceRole\": \"controlling\",\n  \"dtlsState\": \"connected\",\n  \"iceState\": \"connected\",\n  \"selectedCandidatePairId\": \"CPxIhBDNnT_sPDhy1TB\",\n  \"localCertificateId\": \"CFF4:4F:C4:C7:F3:31:6C:B9:D5:AD:19:64:05:9F:2F:E9:00:70:56:1E:BA:92:29:3A:08:CE:1B:27:CF:2D:AB:24\",\n  \"remoteCertificateId\": \"CF62:AF:88:F7:F3:0F:D6:C4:93:91:1E:AD:52:F0:A4:12:04:F9:48:E7:06:16:BA:A3:86:26:8F:1E:38:1C:48:49\",\n  \"dtlsCipher\": \"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\",\n  \"srtpCipher\": \"AES_CM_128_HMAC_SHA1_80\"\n}\n`\n\ticeCandidatePairStats := ICECandidatePairStats{\n\t\tTimestamp:                   1688978831527.718,\n\t\tType:                        StatsTypeCandidatePair,\n\t\tID:                          \"CPxIhBDNnT_LlMJOnBv\",\n\t\tTransportID:                 \"T01\",\n\t\tLocalCandidateID:            \"IxIhBDNnT\",\n\t\tRemoteCandidateID:           \"ILlMJOnBv\",\n\t\tState:                       \"waiting\",\n\t\tNominated:                   true,\n\t\tPacketsSent:                 1,\n\t\tPacketsReceived:             2,\n\t\tBytesSent:                   3,\n\t\tBytesReceived:               4,\n\t\tLastPacketSentTimestamp:     5,\n\t\tLastPacketReceivedTimestamp: 6,\n\t\tFirstRequestTimestamp:       7,\n\t\tLastRequestTimestamp:        8,\n\t\tLastResponseTimestamp:       9,\n\t\tTotalRoundTripTime:          10,\n\t\tCurrentRoundTripTime:        11,\n\t\tAvailableOutgoingBitrate:    12,\n\t\tAvailableIncomingBitrate:    13,\n\t\tCircuitBreakerTriggerCount:  14,\n\t\tRequestsReceived:            15,\n\t\tRequestsSent:                16,\n\t\tResponsesReceived:           17,\n\t\tResponsesSent:               18,\n\t\tRetransmissionsReceived:     19,\n\t\tRetransmissionsSent:         20,\n\t\tConsentRequestsSent:         21,\n\t\tConsentExpiredTimestamp:     22,\n\t\tPacketsDiscardedOnSend:      23,\n\t\tBytesDiscardedOnSend:        24,\n\t}\n\ticeCandidatePairStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"candidate-pair\",\n  \"id\": \"CPxIhBDNnT_LlMJOnBv\",\n  \"transportId\": \"T01\",\n  \"localCandidateId\": \"IxIhBDNnT\",\n  \"remoteCandidateId\": \"ILlMJOnBv\",\n  \"state\": \"waiting\",\n  \"nominated\": true,\n  \"packetsSent\": 1,\n  \"packetsReceived\": 2,\n  \"bytesSent\": 3,\n  \"bytesReceived\": 4,\n  \"lastPacketSentTimestamp\": 5,\n  \"lastPacketReceivedTimestamp\": 6,\n  \"firstRequestTimestamp\": 7,\n  \"lastRequestTimestamp\": 8,\n  \"lastResponseTimestamp\": 9,\n  \"totalRoundTripTime\": 10,\n  \"currentRoundTripTime\": 11,\n  \"availableOutgoingBitrate\": 12,\n  \"availableIncomingBitrate\": 13,\n  \"circuitBreakerTriggerCount\": 14,\n  \"requestsReceived\": 15,\n  \"requestsSent\": 16,\n  \"responsesReceived\": 17,\n  \"responsesSent\": 18,\n  \"retransmissionsReceived\": 19,\n  \"retransmissionsSent\": 20,\n  \"consentRequestsSent\": 21,\n  \"consentExpiredTimestamp\": 22,\n  \"packetsDiscardedOnSend\": 23,\n  \"bytesDiscardedOnSend\": 24\n}\n`\n\tlocalIceCandidateStats := ICECandidateStats{\n\t\tTimestamp:     1688978831527.718,\n\t\tType:          StatsTypeLocalCandidate,\n\t\tID:            \"ILO8S8KYr\",\n\t\tTransportID:   \"T01\",\n\t\tNetworkType:   \"wifi\",\n\t\tIP:            \"192.168.0.36\",\n\t\tPort:          65400,\n\t\tProtocol:      \"udp\",\n\t\tCandidateType: ICECandidateTypeHost,\n\t\tPriority:      2122260223,\n\t\tURL:           \"example.com\",\n\t\tRelayProtocol: \"tcp\",\n\t\tDeleted:       true,\n\t}\n\tlocalIceCandidateStatsJSON := `\n{\n  \"timestamp\": 1688978831527.718,\n  \"type\": \"local-candidate\",\n  \"id\": \"ILO8S8KYr\",\n  \"transportId\": \"T01\",\n  \"networkType\": \"wifi\",\n  \"ip\": \"192.168.0.36\",\n  \"port\": 65400,\n  \"protocol\": \"udp\",\n  \"candidateType\": \"host\",\n  \"priority\": 2122260223,\n  \"url\": \"example.com\",\n  \"relayProtocol\": \"tcp\",\n  \"deleted\": true\n}\n`\n\tremoteIceCandidateStats := ICECandidateStats{\n\t\tTimestamp:     1689668364374.181,\n\t\tType:          StatsTypeRemoteCandidate,\n\t\tID:            \"IGPGeswsH\",\n\t\tTransportID:   \"T01\",\n\t\tIP:            \"10.213.237.226\",\n\t\tPort:          50618,\n\t\tProtocol:      \"udp\",\n\t\tCandidateType: ICECandidateTypeHost,\n\t\tPriority:      2122194687,\n\t\tURL:           \"example.com\",\n\t\tRelayProtocol: \"tcp\",\n\t\tDeleted:       true,\n\t}\n\tremoteIceCandidateStatsJSON := `\n{\n  \"timestamp\": 1689668364374.181,\n  \"type\": \"remote-candidate\",\n  \"id\": \"IGPGeswsH\",\n  \"transportId\": \"T01\",\n  \"ip\": \"10.213.237.226\",\n  \"port\": 50618,\n  \"protocol\": \"udp\",\n  \"candidateType\": \"host\",\n  \"priority\": 2122194687,\n  \"url\": \"example.com\",\n  \"relayProtocol\": \"tcp\",\n  \"deleted\": true\n}\n`\n\tcertificateStats := CertificateStats{\n\t\tTimestamp:            1689668364374.479,\n\t\tType:                 StatsTypeCertificate,\n\t\tID:                   \"CF23:AB:FA:0B:0E:DF:12:34:D3:6C:EA:83:43:BD:79:39:87:39:11:49:41:8A:63:0E:17:B1:3F:94:FA:E3:62:20\",\n\t\tFingerprint:          \"23:AB:FA:0B:0E:DF:12:34:D3:6C:EA:83:43:BD:79:39:87:39:11:49:41:8A:63:0E:17:B1:3F:94:FA:E3:62:20\",\n\t\tFingerprintAlgorithm: \"sha-256\",\n\t\tBase64Certificate:    \"MIIBFjCBvKADAgECAggAwlrxojpmgTAKBggqhkjOPQQDAjARMQ8wDQYDVQQDDAZXZWJSVEMwHhcNMjMwNzE3MDgxODU2WhcNMjMwODE3MDgxODU2WjARMQ8wDQYDVQQDDAZXZWJSVEMwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARKETeS9qNGe3ltwp+q2KgsYWsJLFCJGap4L2aa862sPijHeuzLgO2bju/mosJN0Li7mXhuKBOsCkCMU7vZHVVVMAoGCCqGSM49BAMCA0kAMEYCIQDXyuyMMrgzd+w3c4h3vPn9AzLcf9CHVHRGYyy5ReI/hgIhALkXfaZ96TQRf5FI2mBJJUX9O/q4Poe3wNZxxWeDcYN+\",\n\t\tIssuerCertificateID:  \"CF62:AF:88:F7:F3:0F:D6:C4:93:91:1E:AD:52:F0:A4:12:04:F9:48:E7:06:16:BA:A3:86:26:8F:1E:38:1C:48:49\",\n\t}\n\tcertificateStatsJSON := `\n{\n  \"timestamp\": 1689668364374.479,\n  \"type\": \"certificate\",\n  \"id\": \"CF23:AB:FA:0B:0E:DF:12:34:D3:6C:EA:83:43:BD:79:39:87:39:11:49:41:8A:63:0E:17:B1:3F:94:FA:E3:62:20\",\n  \"fingerprint\": \"23:AB:FA:0B:0E:DF:12:34:D3:6C:EA:83:43:BD:79:39:87:39:11:49:41:8A:63:0E:17:B1:3F:94:FA:E3:62:20\",\n  \"fingerprintAlgorithm\": \"sha-256\",\n  \"base64Certificate\": \"MIIBFjCBvKADAgECAggAwlrxojpmgTAKBggqhkjOPQQDAjARMQ8wDQYDVQQDDAZXZWJSVEMwHhcNMjMwNzE3MDgxODU2WhcNMjMwODE3MDgxODU2WjARMQ8wDQYDVQQDDAZXZWJSVEMwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARKETeS9qNGe3ltwp+q2KgsYWsJLFCJGap4L2aa862sPijHeuzLgO2bju/mosJN0Li7mXhuKBOsCkCMU7vZHVVVMAoGCCqGSM49BAMCA0kAMEYCIQDXyuyMMrgzd+w3c4h3vPn9AzLcf9CHVHRGYyy5ReI/hgIhALkXfaZ96TQRf5FI2mBJJUX9O/q4Poe3wNZxxWeDcYN+\",\n  \"issuerCertificateId\": \"CF62:AF:88:F7:F3:0F:D6:C4:93:91:1E:AD:52:F0:A4:12:04:F9:48:E7:06:16:BA:A3:86:26:8F:1E:38:1C:48:49\"\n}\n`\n\n\treturn []statSample{\n\t\t{\n\t\t\tname:  \"codec_stats\",\n\t\t\tstats: codecStats,\n\t\t\tjson:  codecStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"inbound_rtp_stream_stats\",\n\t\t\tstats: inboundRTPStreamStats,\n\t\t\tjson:  inboundRTPStreamStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"outbound_rtp_stream_stats\",\n\t\t\tstats: outboundRTPStreamStats,\n\t\t\tjson:  outboundRTPStreamStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"remote_inbound_rtp_stream_stats\",\n\t\t\tstats: remoteInboundRTPStreamStats,\n\t\t\tjson:  remoteInboundRTPStreamStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"remote_outbound_rtp_stream_stats\",\n\t\t\tstats: remoteOutboundRTPStreamStats,\n\t\t\tjson:  remoteOutboundRTPStreamStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"rtp_contributing_source_stats\",\n\t\t\tstats: csrcStats,\n\t\t\tjson:  csrcStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"audio_source_stats\",\n\t\t\tstats: audioSourceStats,\n\t\t\tjson:  audioSourceStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"video_source_stats\",\n\t\t\tstats: videoSourceStats,\n\t\t\tjson:  videoSourceStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"audio_playout_stats\",\n\t\t\tstats: audioPlayoutStats,\n\t\t\tjson:  audioPlayoutStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"peer_connection_stats\",\n\t\t\tstats: peerConnectionStats,\n\t\t\tjson:  peerConnectionStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"data_channel_stats\",\n\t\t\tstats: dataChannelStats,\n\t\t\tjson:  dataChannelStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"media_stream_stats\",\n\t\t\tstats: streamStats,\n\t\t\tjson:  streamStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"sender_video_track_stats\",\n\t\t\tstats: senderVideoTrackAttachmentStats,\n\t\t\tjson:  senderVideoTrackAttachmentStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"sender_audio_track_stats\",\n\t\t\tstats: senderAudioTrackAttachmentStats,\n\t\t\tjson:  senderAudioTrackAttachmentStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"receiver_video_track_stats\",\n\t\t\tstats: videoSenderStats,\n\t\t\tjson:  videoSenderStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"receiver_audio_track_stats\",\n\t\t\tstats: audioSenderStats,\n\t\t\tjson:  audioSenderStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"receiver_video_track_stats\",\n\t\t\tstats: videoReceiverStats,\n\t\t\tjson:  videoReceiverStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"receiver_audio_track_stats\",\n\t\t\tstats: audioReceiverStats,\n\t\t\tjson:  audioReceiverStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"transport_stats\",\n\t\t\tstats: transportStats,\n\t\t\tjson:  transportStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"ice_candidate_pair_stats\",\n\t\t\tstats: iceCandidatePairStats,\n\t\t\tjson:  iceCandidatePairStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"local_ice_candidate_stats\",\n\t\t\tstats: localIceCandidateStats,\n\t\t\tjson:  localIceCandidateStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"remote_ice_candidate_stats\",\n\t\t\tstats: remoteIceCandidateStats,\n\t\t\tjson:  remoteIceCandidateStatsJSON,\n\t\t},\n\t\t{\n\t\t\tname:  \"certificate_stats\",\n\t\t\tstats: certificateStats,\n\t\t\tjson:  certificateStatsJSON,\n\t\t},\n\t}\n}\n\nfunc TestStatsMarshal(t *testing.T) {\n\tfor _, test := range getStatsSamples() {\n\t\tt.Run(test.name+\"_marshal\", func(t *testing.T) {\n\t\t\tactualJSON, err := json.Marshal(test.stats)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.JSONEq(t, test.json, string(actualJSON))\n\t\t})\n\t}\n}\n\nfunc TestStatsUnmarshal(t *testing.T) {\n\tfor _, test := range getStatsSamples() {\n\t\tt.Run(test.name+\"_unmarshal\", func(t *testing.T) {\n\t\t\tactualStats, err := UnmarshalStatsJSON([]byte(test.json))\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, test.stats, actualStats)\n\t\t})\n\t}\n}\n\nfunc waitWithTimeout(t *testing.T, wg *sync.WaitGroup) {\n\t// Wait for all of the event handlers to be triggered.\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tdone <- struct{}{}\n\t}()\n\ttimeout := time.After(5 * time.Second)\n\tselect {\n\tcase <-done:\n\t\tbreak\n\tcase <-timeout:\n\t\tt.Fatal(\"timed out waiting for waitgroup\")\n\t}\n}\n\nfunc getConnectionStats(t *testing.T, report StatsReport, pc *PeerConnection) PeerConnectionStats {\n\tstats, ok := report.GetConnectionStats(pc)\n\tassert.True(t, ok)\n\tassert.Equal(t, stats.Type, StatsTypePeerConnection)\n\treturn stats\n}\n\nfunc getDataChannelStats(t *testing.T, report StatsReport, dc *DataChannel) DataChannelStats {\n\tstats, ok := report.GetDataChannelStats(dc)\n\tassert.True(t, ok)\n\tassert.Equal(t, stats.Type, StatsTypeDataChannel)\n\treturn stats\n}\n\nfunc getCodecStats(t *testing.T, report StatsReport, c *RTPCodecParameters) CodecStats {\n\tstats, ok := report.GetCodecStats(c)\n\tassert.True(t, ok)\n\tassert.Equal(t, stats.Type, StatsTypeCodec)\n\treturn stats\n}\n\nfunc getTransportStats(t *testing.T, report StatsReport, statsID string) TransportStats {\n\tstats, ok := report[statsID]\n\tassert.True(t, ok)\n\ttransportStats, ok := stats.(TransportStats)\n\tassert.True(t, ok)\n\tassert.Equal(t, transportStats.Type, StatsTypeTransport)\n\treturn transportStats\n}\n\nfunc getSctpTransportStats(t *testing.T, report StatsReport) SCTPTransportStats {\n\tstats, ok := report[\"sctpTransport\"]\n\tassert.True(t, ok)\n\ttransportStats, ok := stats.(SCTPTransportStats)\n\tassert.True(t, ok)\n\tassert.Equal(t, transportStats.Type, StatsTypeSCTPTransport)\n\treturn transportStats\n}\n\nfunc getCertificateStats(t *testing.T, report StatsReport, certificate *Certificate) CertificateStats {\n\tcertificateStats, ok := report.GetCertificateStats(certificate)\n\tassert.True(t, ok)\n\tassert.Equal(t, certificateStats.Type, StatsTypeCertificate)\n\treturn certificateStats\n}\n\nfunc findLocalCandidateStats(report StatsReport) []ICECandidateStats {\n\tresult := []ICECandidateStats{}\n\tfor _, s := range report {\n\t\tstats, ok := s.(ICECandidateStats)\n\t\tif ok && stats.Type == StatsTypeLocalCandidate {\n\t\t\tresult = append(result, stats)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc findRemoteCandidateStats(report StatsReport) []ICECandidateStats {\n\tresult := []ICECandidateStats{}\n\tfor _, s := range report {\n\t\tstats, ok := s.(ICECandidateStats)\n\t\tif ok && stats.Type == StatsTypeRemoteCandidate {\n\t\t\tresult = append(result, stats)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc findCandidatePairStats(t *testing.T, report StatsReport) []ICECandidatePairStats {\n\tresult := []ICECandidatePairStats{}\n\tfor _, s := range report {\n\t\tstats, ok := s.(ICECandidatePairStats)\n\t\tif ok {\n\t\t\tassert.Equal(t, StatsTypeCandidatePair, stats.Type)\n\t\t\tresult = append(result, stats)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc signalPairForStats(pcOffer *PeerConnection, pcAnswer *PeerConnection) error {\n\tofferChan := make(chan SessionDescription)\n\tpcOffer.OnICECandidate(func(candidate *ICECandidate) {\n\t\tif candidate == nil {\n\t\t\tofferChan <- *pcOffer.PendingLocalDescription()\n\t\t}\n\t})\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := pcOffer.SetLocalDescription(offer); err != nil {\n\t\treturn err\n\t}\n\n\ttimeout := time.After(3 * time.Second)\n\tselect {\n\tcase <-timeout:\n\t\treturn errReceiveOfferTimeout\n\tcase offer := <-offerChan:\n\t\tif err := pcAnswer.SetRemoteDescription(offer); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tanswer, err := pcAnswer.CreateAnswer(nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err = pcAnswer.SetLocalDescription(answer); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = pcOffer.SetRemoteDescription(answer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n}\n\nfunc TestStatsConvertState(t *testing.T) {\n\ttestCases := []struct {\n\t\tice   ice.CandidatePairState\n\t\tstats StatsICECandidatePairState\n\t}{\n\t\t{\n\t\t\tice.CandidatePairStateWaiting,\n\t\t\tStatsICECandidatePairStateWaiting,\n\t\t},\n\t\t{\n\t\t\tice.CandidatePairStateInProgress,\n\t\t\tStatsICECandidatePairStateInProgress,\n\t\t},\n\t\t{\n\t\t\tice.CandidatePairStateFailed,\n\t\t\tStatsICECandidatePairStateFailed,\n\t\t},\n\t\t{\n\t\t\tice.CandidatePairStateSucceeded,\n\t\t\tStatsICECandidatePairStateSucceeded,\n\t\t},\n\t}\n\n\ts, err := toStatsICECandidatePairState(ice.CandidatePairState(42))\n\n\tassert.Error(t, err)\n\tassert.Equal(t,\n\t\tStatsICECandidatePairState(\"Unknown\"),\n\t\ts)\n\tfor i, testCase := range testCases {\n\t\ts, err := toStatsICECandidatePairState(testCase.ice)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t,\n\t\t\ttestCase.stats,\n\t\t\ts,\n\t\t\t\"testCase: %d %v\", i, testCase,\n\t\t)\n\t}\n}\n\nfunc TestPeerConnection_GetStats(t *testing.T) {\n\tofferPC, answerPC, err := newPair()\n\tassert.NoError(t, err)\n\n\ttrack1, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion1\")\n\trequire.NoError(t, err)\n\n\t_, err = offerPC.AddTrack(track1)\n\trequire.NoError(t, err)\n\n\tbaseLineReportPCOffer := offerPC.GetStats()\n\tbaseLineReportPCAnswer := answerPC.GetStats()\n\n\tconnStatsOffer := getConnectionStats(t, baseLineReportPCOffer, offerPC)\n\tconnStatsAnswer := getConnectionStats(t, baseLineReportPCAnswer, answerPC)\n\n\tfor _, connStats := range []PeerConnectionStats{connStatsOffer, connStatsAnswer} {\n\t\tassert.Equal(t, uint32(0), connStats.DataChannelsOpened)\n\t\tassert.Equal(t, uint32(0), connStats.DataChannelsClosed)\n\t\tassert.Equal(t, uint32(0), connStats.DataChannelsRequested)\n\t\tassert.Equal(t, uint32(0), connStats.DataChannelsAccepted)\n\t}\n\n\t// Create a DC, open it and send a message\n\tofferDC, err := offerPC.CreateDataChannel(\"offerDC\", nil)\n\tassert.NoError(t, err)\n\n\tmsg := []byte(\"a classic test message\")\n\tofferDC.OnOpen(func() {\n\t\tassert.NoError(t, offerDC.Send(msg))\n\t})\n\n\tdcWait := sync.WaitGroup{}\n\tdcWait.Add(1)\n\n\tanswerDCChan := make(chan *DataChannel)\n\tanswerPC.OnDataChannel(func(d *DataChannel) {\n\t\td.OnOpen(func() {\n\t\t\tanswerDCChan <- d\n\t\t})\n\t\td.OnMessage(func(DataChannelMessage) {\n\t\t\tdcWait.Done()\n\t\t})\n\t})\n\n\tassert.NoError(t, signalPairForStats(offerPC, answerPC))\n\twaitWithTimeout(t, &dcWait)\n\n\tanswerDC := <-answerDCChan\n\n\treportPCOffer := offerPC.GetStats()\n\treportPCAnswer := answerPC.GetStats()\n\n\tconnStatsOffer = getConnectionStats(t, reportPCOffer, offerPC)\n\tassert.Equal(t, uint32(1), connStatsOffer.DataChannelsOpened)\n\tassert.Equal(t, uint32(0), connStatsOffer.DataChannelsClosed)\n\tassert.Equal(t, uint32(1), connStatsOffer.DataChannelsRequested)\n\tassert.Equal(t, uint32(0), connStatsOffer.DataChannelsAccepted)\n\tdcStatsOffer := getDataChannelStats(t, reportPCOffer, offerDC)\n\tassert.Equal(t, DataChannelStateOpen, dcStatsOffer.State)\n\tassert.Equal(t, uint32(1), dcStatsOffer.MessagesSent)\n\tassert.Equal(t, uint64(len(msg)), dcStatsOffer.BytesSent)\n\tassert.NotEmpty(t, findLocalCandidateStats(reportPCOffer))\n\tassert.NotEmpty(t, findRemoteCandidateStats(reportPCOffer))\n\tassert.NotEmpty(t, findCandidatePairStats(t, reportPCOffer))\n\n\tconnStatsAnswer = getConnectionStats(t, reportPCAnswer, answerPC)\n\tassert.Equal(t, uint32(1), connStatsAnswer.DataChannelsOpened)\n\tassert.Equal(t, uint32(0), connStatsAnswer.DataChannelsClosed)\n\tassert.Equal(t, uint32(0), connStatsAnswer.DataChannelsRequested)\n\tassert.Equal(t, uint32(1), connStatsAnswer.DataChannelsAccepted)\n\tdcStatsAnswer := getDataChannelStats(t, reportPCAnswer, answerDC)\n\tassert.Equal(t, DataChannelStateOpen, dcStatsAnswer.State)\n\tassert.Equal(t, uint32(1), dcStatsAnswer.MessagesReceived)\n\tassert.Equal(t, uint64(len(msg)), dcStatsAnswer.BytesReceived)\n\tassert.NotEmpty(t, findLocalCandidateStats(reportPCAnswer))\n\tassert.NotEmpty(t, findRemoteCandidateStats(reportPCAnswer))\n\tassert.NotEmpty(t, findCandidatePairStats(t, reportPCAnswer))\n\tassert.NoError(t, err)\n\tfor i := range offerPC.api.mediaEngine.videoCodecs {\n\t\tcodecStat := getCodecStats(t, reportPCOffer, &(offerPC.api.mediaEngine.videoCodecs[i]))\n\t\tassert.NotEmpty(t, codecStat)\n\t}\n\tfor i := range offerPC.api.mediaEngine.audioCodecs {\n\t\tcodecStat := getCodecStats(t, reportPCOffer, &(offerPC.api.mediaEngine.audioCodecs[i]))\n\t\tassert.NotEmpty(t, codecStat)\n\t}\n\n\t// Close answer DC now\n\tdcWait = sync.WaitGroup{}\n\tdcWait.Add(1)\n\tofferDC.OnClose(func() {\n\t\tdcWait.Done()\n\t})\n\tassert.NoError(t, answerDC.Close())\n\twaitWithTimeout(t, &dcWait)\n\ttime.Sleep(10 * time.Millisecond)\n\n\treportPCOffer = offerPC.GetStats()\n\treportPCAnswer = answerPC.GetStats()\n\n\tconnStatsOffer = getConnectionStats(t, reportPCOffer, offerPC)\n\tassert.Equal(t, uint32(1), connStatsOffer.DataChannelsOpened)\n\tassert.Equal(t, uint32(1), connStatsOffer.DataChannelsClosed)\n\tassert.Equal(t, uint32(1), connStatsOffer.DataChannelsRequested)\n\tassert.Equal(t, uint32(0), connStatsOffer.DataChannelsAccepted)\n\tdcStatsOffer = getDataChannelStats(t, reportPCOffer, offerDC)\n\tassert.Equal(t, DataChannelStateClosed, dcStatsOffer.State)\n\n\tconnStatsAnswer = getConnectionStats(t, reportPCAnswer, answerPC)\n\tassert.Equal(t, uint32(1), connStatsAnswer.DataChannelsOpened)\n\tassert.Equal(t, uint32(1), connStatsAnswer.DataChannelsClosed)\n\tassert.Equal(t, uint32(0), connStatsAnswer.DataChannelsRequested)\n\tassert.Equal(t, uint32(1), connStatsAnswer.DataChannelsAccepted)\n\tdcStatsAnswer = getDataChannelStats(t, reportPCAnswer, answerDC)\n\tassert.Equal(t, DataChannelStateClosed, dcStatsAnswer.State)\n\n\tanswerICETransportStats := getTransportStats(t, reportPCAnswer, \"iceTransport\")\n\tofferICETransportStats := getTransportStats(t, reportPCOffer, \"iceTransport\")\n\tassert.GreaterOrEqual(t, offerICETransportStats.BytesSent, answerICETransportStats.BytesReceived)\n\tassert.GreaterOrEqual(t, answerICETransportStats.BytesSent, offerICETransportStats.BytesReceived)\n\n\tanswerSCTPTransportStats := getSctpTransportStats(t, reportPCAnswer)\n\tofferSCTPTransportStats := getSctpTransportStats(t, reportPCOffer)\n\tassert.GreaterOrEqual(t, offerSCTPTransportStats.BytesSent, answerSCTPTransportStats.BytesReceived)\n\tassert.GreaterOrEqual(t, answerSCTPTransportStats.BytesSent, offerSCTPTransportStats.BytesReceived)\n\n\tcertificates := offerPC.configuration.Certificates\n\n\tfor i := range certificates {\n\t\tassert.NotEmpty(t, getCertificateStats(t, reportPCOffer, &certificates[i]))\n\t}\n\n\tclosePairNow(t, offerPC, answerPC)\n}\n\nfunc TestPeerConnection_GetStats_Closed(t *testing.T) {\n\tpc, err := NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, pc.Close())\n\n\tpc.GetStats()\n}\n"
        },
        {
          "name": "test-wasm",
          "type": "tree",
          "content": null
        },
        {
          "name": "track_local.go",
          "type": "blob",
          "size": 4.53125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\npackage webrtc\n\nimport (\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/rtp\"\n)\n\n// TrackLocalWriter is the Writer for outbound RTP Packets\ntype TrackLocalWriter interface {\n\t// WriteRTP encrypts a RTP packet and writes to the connection\n\tWriteRTP(header *rtp.Header, payload []byte) (int, error)\n\n\t// Write encrypts and writes a full RTP packet\n\tWrite(b []byte) (int, error)\n}\n\n// TrackLocalContext is the Context passed when a TrackLocal has been Binded/Unbinded from a PeerConnection, and used\n// in Interceptors.\ntype TrackLocalContext interface {\n\t// CodecParameters returns the negotiated RTPCodecParameters. These are the codecs supported by both\n\t// PeerConnections and the PayloadTypes\n\tCodecParameters() []RTPCodecParameters\n\n\t// HeaderExtensions returns the negotiated RTPHeaderExtensionParameters. These are the header extensions supported by\n\t// both PeerConnections and the URI/IDs\n\tHeaderExtensions() []RTPHeaderExtensionParameter\n\n\t// SSRC returns the negotiated SSRC of this track\n\tSSRC() SSRC\n\n\t// SSRCRetransmission returns the negotiated SSRC used to send retransmissions for this track\n\tSSRCRetransmission() SSRC\n\n\t// SSRCForwardErrorCorrection returns the negotiated SSRC to send forward error correction for this track\n\tSSRCForwardErrorCorrection() SSRC\n\n\t// WriteStream returns the WriteStream for this TrackLocal. The implementer writes the outbound\n\t// media packets to it\n\tWriteStream() TrackLocalWriter\n\n\t// ID is a unique identifier that is used for both Bind/Unbind\n\tID() string\n\n\t// RTCPReader returns the RTCP interceptor for this TrackLocal. Used to read RTCP of this TrackLocal.\n\tRTCPReader() interceptor.RTCPReader\n}\n\ntype baseTrackLocalContext struct {\n\tid                     string\n\tparams                 RTPParameters\n\tssrc, ssrcRTX, ssrcFEC SSRC\n\twriteStream            TrackLocalWriter\n\trtcpInterceptor        interceptor.RTCPReader\n}\n\n// CodecParameters returns the negotiated RTPCodecParameters. These are the codecs supported by both\n// PeerConnections and the SSRC/PayloadTypes\nfunc (t *baseTrackLocalContext) CodecParameters() []RTPCodecParameters {\n\treturn t.params.Codecs\n}\n\n// HeaderExtensions returns the negotiated RTPHeaderExtensionParameters. These are the header extensions supported by\n// both PeerConnections and the SSRC/PayloadTypes\nfunc (t *baseTrackLocalContext) HeaderExtensions() []RTPHeaderExtensionParameter {\n\treturn t.params.HeaderExtensions\n}\n\n// SSRC requires the negotiated SSRC of this track\nfunc (t *baseTrackLocalContext) SSRC() SSRC {\n\treturn t.ssrc\n}\n\n// SSRCRetransmission returns the negotiated SSRC used to send retransmissions for this track\nfunc (t *baseTrackLocalContext) SSRCRetransmission() SSRC {\n\treturn t.ssrcRTX\n}\n\n// SSRCForwardErrorCorrection returns the negotiated SSRC to send forward error correction for this track\nfunc (t *baseTrackLocalContext) SSRCForwardErrorCorrection() SSRC {\n\treturn t.ssrcFEC\n}\n\n// WriteStream returns the WriteStream for this TrackLocal. The implementer writes the outbound\n// media packets to it\nfunc (t *baseTrackLocalContext) WriteStream() TrackLocalWriter {\n\treturn t.writeStream\n}\n\n// ID is a unique identifier that is used for both Bind/Unbind\nfunc (t *baseTrackLocalContext) ID() string {\n\treturn t.id\n}\n\n// RTCPReader returns the RTCP interceptor for this TrackLocal. Used to read RTCP of this TrackLocal.\nfunc (t *baseTrackLocalContext) RTCPReader() interceptor.RTCPReader {\n\treturn t.rtcpInterceptor\n}\n\n// TrackLocal is an interface that controls how the user can send media\n// The user can provide their own TrackLocal implementations, or use\n// the implementations in pkg/media\ntype TrackLocal interface {\n\t// Bind should implement the way how the media data flows from the Track to the PeerConnection\n\t// This will be called internally after signaling is complete and the list of available\n\t// codecs has been determined\n\tBind(TrackLocalContext) (RTPCodecParameters, error)\n\n\t// Unbind should implement the teardown logic when the track is no longer needed. This happens\n\t// because a track has been stopped.\n\tUnbind(TrackLocalContext) error\n\n\t// ID is the unique identifier for this Track. This should be unique for the\n\t// stream, but doesn't have to globally unique. A common example would be 'audio' or 'video'\n\t// and StreamID would be 'desktop' or 'webcam'\n\tID() string\n\n\t// RID is the RTP Stream ID for this track.\n\tRID() string\n\n\t// StreamID is the group this track belongs too. This must be unique\n\tStreamID() string\n\n\t// Kind controls if this TrackLocal is audio or video\n\tKind() RTPCodecType\n}\n"
        },
        {
          "name": "track_local_static.go",
          "type": "blob",
          "size": 10.158203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/webrtc/v4/internal/util\"\n\t\"github.com/pion/webrtc/v4/pkg/media\"\n)\n\n// trackBinding is a single bind for a Track\n// Bind can be called multiple times, this stores the\n// result for a single bind call so that it can be used when writing\ntype trackBinding struct {\n\tid                          string\n\tssrc, ssrcRTX, ssrcFEC      SSRC\n\tpayloadType, payloadTypeRTX PayloadType\n\twriteStream                 TrackLocalWriter\n}\n\n// TrackLocalStaticRTP  is a TrackLocal that has a pre-set codec and accepts RTP Packets.\n// If you wish to send a media.Sample use TrackLocalStaticSample\ntype TrackLocalStaticRTP struct {\n\tmu                sync.RWMutex\n\tbindings          []trackBinding\n\tcodec             RTPCodecCapability\n\tpayloader         func(RTPCodecCapability) (rtp.Payloader, error)\n\tid, rid, streamID string\n}\n\n// NewTrackLocalStaticRTP returns a TrackLocalStaticRTP.\nfunc NewTrackLocalStaticRTP(c RTPCodecCapability, id, streamID string, options ...func(*TrackLocalStaticRTP)) (*TrackLocalStaticRTP, error) {\n\tt := &TrackLocalStaticRTP{\n\t\tcodec:    c,\n\t\tbindings: []trackBinding{},\n\t\tid:       id,\n\t\tstreamID: streamID,\n\t}\n\n\tfor _, option := range options {\n\t\toption(t)\n\t}\n\n\treturn t, nil\n}\n\n// WithRTPStreamID sets the RTP stream ID for this TrackLocalStaticRTP.\nfunc WithRTPStreamID(rid string) func(*TrackLocalStaticRTP) {\n\treturn func(t *TrackLocalStaticRTP) {\n\t\tt.rid = rid\n\t}\n}\n\n// WithPayloader allows the user to override the Payloader\nfunc WithPayloader(h func(RTPCodecCapability) (rtp.Payloader, error)) func(*TrackLocalStaticRTP) {\n\treturn func(s *TrackLocalStaticRTP) {\n\t\ts.payloader = h\n\t}\n}\n\n// Bind is called by the PeerConnection after negotiation is complete\n// This asserts that the code requested is supported by the remote peer.\n// If so it sets up all the state (SSRC and PayloadType) to have a call\nfunc (s *TrackLocalStaticRTP) Bind(t TrackLocalContext) (RTPCodecParameters, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tparameters := RTPCodecParameters{RTPCodecCapability: s.codec}\n\tif codec, matchType := codecParametersFuzzySearch(parameters, t.CodecParameters()); matchType != codecMatchNone {\n\t\ts.bindings = append(s.bindings, trackBinding{\n\t\t\tssrc:           t.SSRC(),\n\t\t\tssrcRTX:        t.SSRCRetransmission(),\n\t\t\tssrcFEC:        t.SSRCForwardErrorCorrection(),\n\t\t\tpayloadType:    codec.PayloadType,\n\t\t\tpayloadTypeRTX: findRTXPayloadType(codec.PayloadType, t.CodecParameters()),\n\t\t\twriteStream:    t.WriteStream(),\n\t\t\tid:             t.ID(),\n\t\t})\n\n\t\treturn codec, nil\n\t}\n\n\treturn RTPCodecParameters{}, ErrUnsupportedCodec\n}\n\n// Unbind implements the teardown logic when the track is no longer needed. This happens\n// because a track has been stopped.\nfunc (s *TrackLocalStaticRTP) Unbind(t TrackLocalContext) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tfor i := range s.bindings {\n\t\tif s.bindings[i].id == t.ID() {\n\t\t\ts.bindings[i] = s.bindings[len(s.bindings)-1]\n\t\t\ts.bindings = s.bindings[:len(s.bindings)-1]\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn ErrUnbindFailed\n}\n\n// ID is the unique identifier for this Track. This should be unique for the\n// stream, but doesn't have to globally unique. A common example would be 'audio' or 'video'\n// and StreamID would be 'desktop' or 'webcam'\nfunc (s *TrackLocalStaticRTP) ID() string { return s.id }\n\n// StreamID is the group this track belongs too. This must be unique\nfunc (s *TrackLocalStaticRTP) StreamID() string { return s.streamID }\n\n// RID is the RTP stream identifier.\nfunc (s *TrackLocalStaticRTP) RID() string { return s.rid }\n\n// Kind controls if this TrackLocal is audio or video\nfunc (s *TrackLocalStaticRTP) Kind() RTPCodecType {\n\tswitch {\n\tcase strings.HasPrefix(s.codec.MimeType, \"audio/\"):\n\t\treturn RTPCodecTypeAudio\n\tcase strings.HasPrefix(s.codec.MimeType, \"video/\"):\n\t\treturn RTPCodecTypeVideo\n\tdefault:\n\t\treturn RTPCodecType(0)\n\t}\n}\n\n// Codec gets the Codec of the track\nfunc (s *TrackLocalStaticRTP) Codec() RTPCodecCapability {\n\treturn s.codec\n}\n\n// packetPool is a pool of packets used by WriteRTP and Write below\n// nolint:gochecknoglobals\nvar rtpPacketPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn &rtp.Packet{}\n\t},\n}\n\nfunc resetPacketPoolAllocation(localPacket *rtp.Packet) {\n\t*localPacket = rtp.Packet{}\n\trtpPacketPool.Put(localPacket)\n}\n\nfunc getPacketAllocationFromPool() *rtp.Packet {\n\tipacket := rtpPacketPool.Get()\n\treturn ipacket.(*rtp.Packet) //nolint:forcetypeassert\n}\n\n// WriteRTP writes a RTP Packet to the TrackLocalStaticRTP\n// If one PeerConnection fails the packets will still be sent to\n// all PeerConnections. The error message will contain the ID of the failed\n// PeerConnections so you can remove them\nfunc (s *TrackLocalStaticRTP) WriteRTP(p *rtp.Packet) error {\n\tpacket := getPacketAllocationFromPool()\n\n\tdefer resetPacketPoolAllocation(packet)\n\n\t*packet = *p\n\n\treturn s.writeRTP(packet)\n}\n\n// writeRTP is like WriteRTP, except that it may modify the packet p\nfunc (s *TrackLocalStaticRTP) writeRTP(p *rtp.Packet) error {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\twriteErrs := []error{}\n\n\tfor _, b := range s.bindings {\n\t\tp.Header.SSRC = uint32(b.ssrc)\n\t\tp.Header.PayloadType = uint8(b.payloadType)\n\t\tif _, err := b.writeStream.WriteRTP(&p.Header, p.Payload); err != nil {\n\t\t\twriteErrs = append(writeErrs, err)\n\t\t}\n\t}\n\n\treturn util.FlattenErrs(writeErrs)\n}\n\n// Write writes a RTP Packet as a buffer to the TrackLocalStaticRTP\n// If one PeerConnection fails the packets will still be sent to\n// all PeerConnections. The error message will contain the ID of the failed\n// PeerConnections so you can remove them\nfunc (s *TrackLocalStaticRTP) Write(b []byte) (n int, err error) {\n\tpacket := getPacketAllocationFromPool()\n\n\tdefer resetPacketPoolAllocation(packet)\n\n\tif err = packet.Unmarshal(b); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn len(b), s.writeRTP(packet)\n}\n\n// TrackLocalStaticSample is a TrackLocal that has a pre-set codec and accepts Samples.\n// If you wish to send a RTP Packet use TrackLocalStaticRTP\ntype TrackLocalStaticSample struct {\n\tpacketizer rtp.Packetizer\n\tsequencer  rtp.Sequencer\n\trtpTrack   *TrackLocalStaticRTP\n\tclockRate  float64\n}\n\n// NewTrackLocalStaticSample returns a TrackLocalStaticSample\nfunc NewTrackLocalStaticSample(c RTPCodecCapability, id, streamID string, options ...func(*TrackLocalStaticRTP)) (*TrackLocalStaticSample, error) {\n\trtpTrack, err := NewTrackLocalStaticRTP(c, id, streamID, options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &TrackLocalStaticSample{\n\t\trtpTrack: rtpTrack,\n\t}, nil\n}\n\n// ID is the unique identifier for this Track. This should be unique for the\n// stream, but doesn't have to globally unique. A common example would be 'audio' or 'video'\n// and StreamID would be 'desktop' or 'webcam'\nfunc (s *TrackLocalStaticSample) ID() string { return s.rtpTrack.ID() }\n\n// StreamID is the group this track belongs too. This must be unique\nfunc (s *TrackLocalStaticSample) StreamID() string { return s.rtpTrack.StreamID() }\n\n// RID is the RTP stream identifier.\nfunc (s *TrackLocalStaticSample) RID() string { return s.rtpTrack.RID() }\n\n// Kind controls if this TrackLocal is audio or video\nfunc (s *TrackLocalStaticSample) Kind() RTPCodecType { return s.rtpTrack.Kind() }\n\n// Codec gets the Codec of the track\nfunc (s *TrackLocalStaticSample) Codec() RTPCodecCapability {\n\treturn s.rtpTrack.Codec()\n}\n\n// Bind is called by the PeerConnection after negotiation is complete\n// This asserts that the code requested is supported by the remote peer.\n// If so it setups all the state (SSRC and PayloadType) to have a call\nfunc (s *TrackLocalStaticSample) Bind(t TrackLocalContext) (RTPCodecParameters, error) {\n\tcodec, err := s.rtpTrack.Bind(t)\n\tif err != nil {\n\t\treturn codec, err\n\t}\n\n\ts.rtpTrack.mu.Lock()\n\tdefer s.rtpTrack.mu.Unlock()\n\n\t// We only need one packetizer\n\tif s.packetizer != nil {\n\t\treturn codec, nil\n\t}\n\n\tpayloadHandler := s.rtpTrack.payloader\n\tif payloadHandler == nil {\n\t\tpayloadHandler = payloaderForCodec\n\t}\n\n\tpayloader, err := payloadHandler(codec.RTPCodecCapability)\n\tif err != nil {\n\t\treturn codec, err\n\t}\n\n\ts.sequencer = rtp.NewRandomSequencer()\n\ts.packetizer = rtp.NewPacketizer(\n\t\trtpOutboundMTU,\n\t\t0, // Value is handled when writing\n\t\t0, // Value is handled when writing\n\t\tpayloader,\n\t\ts.sequencer,\n\t\tcodec.ClockRate,\n\t)\n\ts.clockRate = float64(codec.RTPCodecCapability.ClockRate)\n\treturn codec, nil\n}\n\n// Unbind implements the teardown logic when the track is no longer needed. This happens\n// because a track has been stopped.\nfunc (s *TrackLocalStaticSample) Unbind(t TrackLocalContext) error {\n\treturn s.rtpTrack.Unbind(t)\n}\n\n// WriteSample writes a Sample to the TrackLocalStaticSample\n// If one PeerConnection fails the packets will still be sent to\n// all PeerConnections. The error message will contain the ID of the failed\n// PeerConnections so you can remove them\nfunc (s *TrackLocalStaticSample) WriteSample(sample media.Sample) error {\n\ts.rtpTrack.mu.RLock()\n\tp := s.packetizer\n\tclockRate := s.clockRate\n\ts.rtpTrack.mu.RUnlock()\n\n\tif p == nil {\n\t\treturn nil\n\t}\n\n\t// skip packets by the number of previously dropped packets\n\tfor i := uint16(0); i < sample.PrevDroppedPackets; i++ {\n\t\ts.sequencer.NextSequenceNumber()\n\t}\n\n\tsamples := uint32(sample.Duration.Seconds() * clockRate)\n\tif sample.PrevDroppedPackets > 0 {\n\t\tp.SkipSamples(samples * uint32(sample.PrevDroppedPackets))\n\t}\n\tpackets := p.Packetize(sample.Data, samples)\n\n\twriteErrs := []error{}\n\tfor _, p := range packets {\n\t\tif err := s.rtpTrack.WriteRTP(p); err != nil {\n\t\t\twriteErrs = append(writeErrs, err)\n\t\t}\n\t}\n\n\treturn util.FlattenErrs(writeErrs)\n}\n\n// GeneratePadding writes padding-only samples to the TrackLocalStaticSample\n// If one PeerConnection fails the packets will still be sent to\n// all PeerConnections. The error message will contain the ID of the failed\n// PeerConnections so you can remove them\nfunc (s *TrackLocalStaticSample) GeneratePadding(samples uint32) error {\n\ts.rtpTrack.mu.RLock()\n\tp := s.packetizer\n\ts.rtpTrack.mu.RUnlock()\n\n\tif p == nil {\n\t\treturn nil\n\t}\n\n\tpackets := p.GeneratePadding(samples)\n\n\twriteErrs := []error{}\n\tfor _, p := range packets {\n\t\tif err := s.rtpTrack.WriteRTP(p); err != nil {\n\t\t\twriteErrs = append(writeErrs, err)\n\t\t}\n\t}\n\n\treturn util.FlattenErrs(writeErrs)\n}\n"
        },
        {
          "name": "track_local_static_test.go",
          "type": "blob",
          "size": 11.0849609375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/rtp\"\n\t\"github.com/pion/transport/v3/test\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// If a remote doesn't support a Codec used by a `TrackLocalStatic`\n// an error should be returned to the user\nfunc Test_TrackLocalStatic_NoCodecIntersection(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\tt.Run(\"Offerer\", func(t *testing.T) {\n\t\tpc, err := NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\tnoCodecPC, err := NewAPI(WithMediaEngine(&MediaEngine{})).NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pc.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\tassert.ErrorIs(t, signalPair(pc, noCodecPC), ErrUnsupportedCodec)\n\n\t\tclosePairNow(t, noCodecPC, pc)\n\t})\n\n\tt.Run(\"Answerer\", func(t *testing.T) {\n\t\tpc, err := NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\tm := &MediaEngine{}\n\t\tassert.NoError(t, m.RegisterCodec(RTPCodecParameters{\n\t\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/VP9\", ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\t\tPayloadType:        96,\n\t\t}, RTPCodecTypeVideo))\n\n\t\tvp9OnlyPC, err := NewAPI(WithMediaEngine(m)).NewPeerConnection(Configuration{})\n\t\tassert.NoError(t, err)\n\n\t\t_, err = vp9OnlyPC.AddTransceiverFromKind(RTPCodecTypeVideo)\n\t\tassert.NoError(t, err)\n\n\t\t_, err = pc.AddTrack(track)\n\t\tassert.NoError(t, err)\n\n\t\tassert.True(t, errors.Is(signalPair(vp9OnlyPC, pc), ErrUnsupportedCodec))\n\n\t\tclosePairNow(t, vp9OnlyPC, pc)\n\t})\n\n\tt.Run(\"Local\", func(t *testing.T) {\n\t\tofferer, answerer, err := newPair()\n\t\tassert.NoError(t, err)\n\n\t\tinvalidCodecTrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: \"video/invalid-codec\"}, \"video\", \"pion\")\n\t\tassert.NoError(t, err)\n\n\t\t_, err = offerer.AddTrack(invalidCodecTrack)\n\t\tassert.NoError(t, err)\n\n\t\tassert.True(t, errors.Is(signalPair(offerer, answerer), ErrUnsupportedCodec))\n\t\tclosePairNow(t, offerer, answerer)\n\t})\n}\n\n// Assert that Bind/Unbind happens when expected\nfunc Test_TrackLocalStatic_Closed(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\t_, err = pcAnswer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tvp8Writer, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = pcOffer.AddTrack(vp8Writer)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, len(vp8Writer.bindings), 0, \"No binding should exist before signaling\")\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tassert.Equal(t, len(vp8Writer.bindings), 1, \"binding should exist after signaling\")\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n\n\tassert.Equal(t, len(vp8Writer.bindings), 0, \"No binding should exist after close\")\n}\n\nfunc Test_TrackLocalStatic_PayloadType(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tmediaEngineOne := &MediaEngine{}\n\tassert.NoError(t, mediaEngineOne.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/VP8\", ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        100,\n\t}, RTPCodecTypeVideo))\n\n\tmediaEngineTwo := &MediaEngine{}\n\tassert.NoError(t, mediaEngineTwo.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/VP8\", ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        200,\n\t}, RTPCodecTypeVideo))\n\n\tofferer, err := NewAPI(WithMediaEngine(mediaEngineOne)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tanswerer, err := NewAPI(WithMediaEngine(mediaEngineTwo)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = offerer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\t_, err = answerer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\tofferer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tassert.Equal(t, track.PayloadType(), PayloadType(100))\n\t\tassert.Equal(t, track.Codec().RTPCodecCapability.MimeType, \"video/VP8\")\n\n\t\tonTrackFiredFunc()\n\t})\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{track})\n\n\tclosePairNow(t, offerer, answerer)\n}\n\n// Assert that writing to a Track doesn't modify the input\n// Even though we can pass a pointer we shouldn't modify the incoming value\nfunc Test_TrackLocalStatic_Mutate_Input(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 30)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\tvp8Writer, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = pcOffer.AddTrack(vp8Writer)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(pcOffer, pcAnswer))\n\n\tpkt := &rtp.Packet{Header: rtp.Header{SSRC: 1, PayloadType: 1}}\n\tassert.NoError(t, vp8Writer.WriteRTP(pkt))\n\n\tassert.Equal(t, pkt.Header.SSRC, uint32(1))\n\tassert.Equal(t, pkt.Header.PayloadType, uint8(1))\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\n// Assert that writing to a Track that has Binded (but not connected)\n// does not block\nfunc Test_TrackLocalStatic_Binding_NonBlocking(t *testing.T) {\n\tlim := test.TimeOut(time.Second * 5)\n\tdefer lim.Stop()\n\n\treport := test.CheckRoutines(t)\n\tdefer report()\n\n\tpcOffer, pcAnswer, err := newPair()\n\tassert.NoError(t, err)\n\n\t_, err = pcOffer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\tvp8Writer, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = pcAnswer.AddTrack(vp8Writer)\n\tassert.NoError(t, err)\n\n\toffer, err := pcOffer.CreateOffer(nil)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, pcAnswer.SetRemoteDescription(offer))\n\n\tanswer, err := pcAnswer.CreateAnswer(nil)\n\tassert.NoError(t, err)\n\tassert.NoError(t, pcAnswer.SetLocalDescription(answer))\n\n\t_, err = vp8Writer.Write(make([]byte, 20))\n\tassert.NoError(t, err)\n\n\tclosePairNow(t, pcOffer, pcAnswer)\n}\n\nfunc BenchmarkTrackLocalWrite(b *testing.B) {\n\tofferPC, answerPC, err := newPair()\n\tdefer closePairNow(b, offerPC, answerPC)\n\tif err != nil {\n\t\tb.Fatalf(\"Failed to create a PC pair for testing\")\n\t}\n\n\ttrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(b, err)\n\n\t_, err = offerPC.AddTrack(track)\n\tassert.NoError(b, err)\n\n\t_, err = answerPC.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(b, err)\n\n\tb.SetBytes(1024)\n\n\tbuf := make([]byte, 1024)\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := track.Write(buf)\n\t\tassert.NoError(b, err)\n\t}\n}\n\nfunc Test_TrackLocalStatic_Padding(t *testing.T) {\n\tmediaEngineOne := &MediaEngine{}\n\tassert.NoError(t, mediaEngineOne.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/VP8\", ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        100,\n\t}, RTPCodecTypeVideo))\n\n\tmediaEngineTwo := &MediaEngine{}\n\tassert.NoError(t, mediaEngineTwo.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: \"video/VP8\", ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        200,\n\t}, RTPCodecTypeVideo))\n\n\tofferer, err := NewAPI(WithMediaEngine(mediaEngineOne)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tanswerer, err := NewAPI(WithMediaEngine(mediaEngineTwo)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = offerer.AddTransceiverFromKind(RTPCodecTypeVideo)\n\tassert.NoError(t, err)\n\n\t_, err = answerer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\n\tofferer.OnTrack(func(track *TrackRemote, _ *RTPReceiver) {\n\t\tassert.Equal(t, track.PayloadType(), PayloadType(100))\n\t\tassert.Equal(t, track.Codec().RTPCodecCapability.MimeType, \"video/VP8\")\n\n\t\tfor i := 0; i < 20; i++ {\n\t\t\t// Padding payload\n\t\t\tp, _, e := track.ReadRTP()\n\t\t\tassert.NoError(t, e)\n\t\t\tassert.True(t, p.Padding)\n\t\t\tassert.Equal(t, p.PaddingSize, byte(255))\n\t\t}\n\n\t\tonTrackFiredFunc()\n\t})\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\texit := false\n\n\tfor !exit {\n\t\tselect {\n\t\tcase <-time.After(1 * time.Millisecond):\n\t\t\tassert.NoError(t, track.GeneratePadding(1))\n\t\tcase <-onTrackFired.Done():\n\t\t\texit = true\n\t\t}\n\t}\n\n\tclosePairNow(t, offerer, answerer)\n}\n\nfunc Test_TrackLocalStatic_RTX(t *testing.T) {\n\tdefer test.TimeOut(time.Second * 30).Stop()\n\tdefer test.CheckRoutines(t)()\n\n\tofferer, answerer, err := newPair()\n\tassert.NoError(t, err)\n\n\ttrack, err := NewTrackLocalStaticRTP(RTPCodecCapability{MimeType: MimeTypeVP8}, \"video\", \"pion\")\n\tassert.NoError(t, err)\n\n\t_, err = offerer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\ttrack.mu.Lock()\n\tassert.NotZero(t, track.bindings[0].ssrcRTX)\n\tassert.NotZero(t, track.bindings[0].payloadTypeRTX)\n\ttrack.mu.Unlock()\n\n\tclosePairNow(t, offerer, answerer)\n}\n\ntype customCodecPayloader struct {\n\tinvokeCount atomic.Int32\n}\n\nfunc (c *customCodecPayloader) Payload(_ uint16, payload []byte) [][]byte {\n\tc.invokeCount.Add(1)\n\treturn [][]byte{payload}\n}\n\nfunc Test_TrackLocalStatic_Payloader(t *testing.T) {\n\tconst mimeTypeCustomCodec = \"video/custom-codec\"\n\n\tmediaEngine := &MediaEngine{}\n\tassert.NoError(t, mediaEngine.RegisterCodec(RTPCodecParameters{\n\t\tRTPCodecCapability: RTPCodecCapability{MimeType: mimeTypeCustomCodec, ClockRate: 90000, Channels: 0, SDPFmtpLine: \"\", RTCPFeedback: nil},\n\t\tPayloadType:        96,\n\t}, RTPCodecTypeVideo))\n\n\tofferer, err := NewAPI(WithMediaEngine(mediaEngine)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tanswerer, err := NewAPI(WithMediaEngine(mediaEngine)).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tcustomPayloader := &customCodecPayloader{}\n\ttrack, err := NewTrackLocalStaticSample(RTPCodecCapability{MimeType: mimeTypeCustomCodec}, \"video\", \"pion\", WithPayloader(func(c RTPCodecCapability) (rtp.Payloader, error) {\n\t\trequire.Equal(t, c.MimeType, mimeTypeCustomCodec)\n\t\treturn customPayloader, nil\n\t}))\n\tassert.NoError(t, err)\n\n\t_, err = offerer.AddTrack(track)\n\tassert.NoError(t, err)\n\n\tassert.NoError(t, signalPair(offerer, answerer))\n\n\tonTrackFired, onTrackFiredFunc := context.WithCancel(context.Background())\n\tanswerer.OnTrack(func(*TrackRemote, *RTPReceiver) {\n\t\tonTrackFiredFunc()\n\t})\n\n\tsendVideoUntilDone(onTrackFired.Done(), t, []*TrackLocalStaticSample{track})\n\n\tclosePairNow(t, offerer, answerer)\n}\n"
        },
        {
          "name": "track_remote.go",
          "type": "blob",
          "size": 5.5263671875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/rtp\"\n)\n\n// TrackRemote represents a single inbound source of media\ntype TrackRemote struct {\n\tmu sync.RWMutex\n\n\tid       string\n\tstreamID string\n\n\tpayloadType PayloadType\n\tkind        RTPCodecType\n\tssrc        SSRC\n\trtxSsrc     SSRC\n\tcodec       RTPCodecParameters\n\tparams      RTPParameters\n\trid         string\n\n\treceiver         *RTPReceiver\n\tpeeked           []byte\n\tpeekedAttributes interceptor.Attributes\n}\n\nfunc newTrackRemote(kind RTPCodecType, ssrc, rtxSsrc SSRC, rid string, receiver *RTPReceiver) *TrackRemote {\n\treturn &TrackRemote{\n\t\tkind:     kind,\n\t\tssrc:     ssrc,\n\t\trtxSsrc:  rtxSsrc,\n\t\trid:      rid,\n\t\treceiver: receiver,\n\t}\n}\n\n// ID is the unique identifier for this Track. This should be unique for the\n// stream, but doesn't have to globally unique. A common example would be 'audio' or 'video'\n// and StreamID would be 'desktop' or 'webcam'\nfunc (t *TrackRemote) ID() string {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.id\n}\n\n// RID gets the RTP Stream ID of this Track\n// With Simulcast you will have multiple tracks with the same ID, but different RID values.\n// In many cases a TrackRemote will not have an RID, so it is important to assert it is non-zero\nfunc (t *TrackRemote) RID() string {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\n\treturn t.rid\n}\n\n// PayloadType gets the PayloadType of the track\nfunc (t *TrackRemote) PayloadType() PayloadType {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.payloadType\n}\n\n// Kind gets the Kind of the track\nfunc (t *TrackRemote) Kind() RTPCodecType {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.kind\n}\n\n// StreamID is the group this track belongs too. This must be unique\nfunc (t *TrackRemote) StreamID() string {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.streamID\n}\n\n// SSRC gets the SSRC of the track\nfunc (t *TrackRemote) SSRC() SSRC {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.ssrc\n}\n\n// Msid gets the Msid of the track\nfunc (t *TrackRemote) Msid() string {\n\treturn t.StreamID() + \" \" + t.ID()\n}\n\n// Codec gets the Codec of the track\nfunc (t *TrackRemote) Codec() RTPCodecParameters {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.codec\n}\n\n// Read reads data from the track.\nfunc (t *TrackRemote) Read(b []byte) (n int, attributes interceptor.Attributes, err error) {\n\tt.mu.RLock()\n\tr := t.receiver\n\tpeeked := t.peeked != nil\n\tt.mu.RUnlock()\n\n\tif peeked {\n\t\tt.mu.Lock()\n\t\tdata := t.peeked\n\t\tattributes = t.peekedAttributes\n\n\t\tt.peeked = nil\n\t\tt.peekedAttributes = nil\n\t\tt.mu.Unlock()\n\t\t// someone else may have stolen our packet when we\n\t\t// released the lock.  Deal with it.\n\t\tif data != nil {\n\t\t\tn = copy(b, data)\n\t\t\terr = t.checkAndUpdateTrack(b)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// If there's a separate RTX track and an RTX packet is available, return that\n\tif rtxPacketReceived := r.readRTX(t); rtxPacketReceived != nil {\n\t\tn = copy(b, rtxPacketReceived.pkt)\n\t\tattributes = rtxPacketReceived.attributes\n\t\trtxPacketReceived.release()\n\t\terr = nil\n\t} else {\n\t\t// If there's no separate RTX track (or there's a separate RTX track but no RTX packet waiting), wait for and return\n\t\t// a packet from the main track\n\t\tn, attributes, err = r.readRTP(b, t)\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\terr = t.checkAndUpdateTrack(b)\n\t}\n\n\treturn n, attributes, err\n}\n\n// checkAndUpdateTrack checks payloadType for every incoming packet\n// once a different payloadType is detected the track will be updated\nfunc (t *TrackRemote) checkAndUpdateTrack(b []byte) error {\n\tif len(b) < 2 {\n\t\treturn errRTPTooShort\n\t}\n\n\tpayloadType := PayloadType(b[1] & rtpPayloadTypeBitmask)\n\tif payloadType != t.PayloadType() || len(t.params.Codecs) == 0 {\n\t\tt.mu.Lock()\n\t\tdefer t.mu.Unlock()\n\n\t\tparams, err := t.receiver.api.mediaEngine.getRTPParametersByPayloadType(payloadType)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tt.kind = t.receiver.kind\n\t\tt.payloadType = payloadType\n\t\tt.codec = params.Codecs[0]\n\t\tt.params = params\n\t}\n\n\treturn nil\n}\n\n// ReadRTP is a convenience method that wraps Read and unmarshals for you.\nfunc (t *TrackRemote) ReadRTP() (*rtp.Packet, interceptor.Attributes, error) {\n\tb := make([]byte, t.receiver.api.settingEngine.getReceiveMTU())\n\ti, attributes, err := t.Read(b)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := &rtp.Packet{}\n\tif err := r.Unmarshal(b[:i]); err != nil {\n\t\treturn nil, nil, err\n\t}\n\treturn r, attributes, nil\n}\n\n// peek is like Read, but it doesn't discard the packet read\nfunc (t *TrackRemote) peek(b []byte) (n int, a interceptor.Attributes, err error) {\n\tn, a, err = t.Read(b)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tt.mu.Lock()\n\t// this might overwrite data if somebody peeked between the Read\n\t// and us getting the lock.  Oh well, we'll just drop a packet in\n\t// that case.\n\tdata := make([]byte, n)\n\tn = copy(data, b[:n])\n\tt.peeked = data\n\tt.peekedAttributes = a\n\tt.mu.Unlock()\n\treturn\n}\n\n// SetReadDeadline sets the max amount of time the RTP stream will block before returning. 0 is forever.\nfunc (t *TrackRemote) SetReadDeadline(deadline time.Time) error {\n\treturn t.receiver.setRTPReadDeadline(deadline, t)\n}\n\n// RtxSSRC returns the RTX SSRC for a track, or 0 if track does not have a separate RTX stream\nfunc (t *TrackRemote) RtxSSRC() SSRC {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.rtxSsrc\n}\n\n// HasRTX returns true if the track has a separate RTX stream\nfunc (t *TrackRemote) HasRTX() bool {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\treturn t.rtxSsrc != 0\n}\n\nfunc (t *TrackRemote) setRtxSSRC(ssrc SSRC) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.rtxSsrc = ssrc\n}\n"
        },
        {
          "name": "track_test.go",
          "type": "blob",
          "size": 0.1435546875,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n"
        },
        {
          "name": "vnet_test.go",
          "type": "blob",
          "size": 2.1533203125,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n//go:build !js\n// +build !js\n\npackage webrtc\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/pion/interceptor\"\n\t\"github.com/pion/logging\"\n\t\"github.com/pion/transport/v3/vnet\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc createVNetPair(t *testing.T, interceptorRegistry *interceptor.Registry) (*PeerConnection, *PeerConnection, *vnet.Router) {\n\t// Create a root router\n\twan, err := vnet.NewRouter(&vnet.RouterConfig{\n\t\tCIDR:          \"1.2.3.0/24\",\n\t\tLoggerFactory: logging.NewDefaultLoggerFactory(),\n\t})\n\tassert.NoError(t, err)\n\n\t// Create a network interface for offerer\n\tofferVNet, err := vnet.NewNet(&vnet.NetConfig{\n\t\tStaticIPs: []string{\"1.2.3.4\"},\n\t})\n\tassert.NoError(t, err)\n\n\t// Add the network interface to the router\n\tassert.NoError(t, wan.AddNet(offerVNet))\n\n\tofferSettingEngine := SettingEngine{}\n\tofferSettingEngine.SetNet(offerVNet)\n\tofferSettingEngine.SetICETimeouts(time.Second, time.Second, time.Millisecond*200)\n\n\t// Create a network interface for answerer\n\tanswerVNet, err := vnet.NewNet(&vnet.NetConfig{\n\t\tStaticIPs: []string{\"1.2.3.5\"},\n\t})\n\tassert.NoError(t, err)\n\n\t// Add the network interface to the router\n\tassert.NoError(t, wan.AddNet(answerVNet))\n\n\tanswerSettingEngine := SettingEngine{}\n\tanswerSettingEngine.SetNet(answerVNet)\n\tanswerSettingEngine.SetICETimeouts(time.Second, time.Second, time.Millisecond*200)\n\n\t// Start the virtual network by calling Start() on the root router\n\tassert.NoError(t, wan.Start())\n\n\tofferOptions := []func(*API){WithSettingEngine(offerSettingEngine)}\n\tif interceptorRegistry != nil {\n\t\tofferOptions = append(offerOptions, WithInterceptorRegistry(interceptorRegistry))\n\t}\n\tofferPeerConnection, err := NewAPI(offerOptions...).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\tanswerOptions := []func(*API){WithSettingEngine(answerSettingEngine)}\n\tif interceptorRegistry != nil {\n\t\tanswerOptions = append(answerOptions, WithInterceptorRegistry(interceptorRegistry))\n\t}\n\tanswerPeerConnection, err := NewAPI(answerOptions...).NewPeerConnection(Configuration{})\n\tassert.NoError(t, err)\n\n\treturn offerPeerConnection, answerPeerConnection, wan\n}\n"
        },
        {
          "name": "webrtc.go",
          "type": "blob",
          "size": 0.7255859375,
          "content": "// SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n// SPDX-License-Identifier: MIT\n\n// Package webrtc implements the WebRTC 1.0 as defined in W3C WebRTC specification document.\npackage webrtc\n\n// SSRC represents a synchronization source\n// A synchronization source is a randomly chosen\n// value meant to be globally unique within a particular\n// RTP session. Used to identify a single stream of media.\n//\n// https://tools.ietf.org/html/rfc3550#section-3\ntype SSRC uint32\n\n// PayloadType identifies the format of the RTP payload and determines\n// its interpretation by the application. Each codec in a RTP Session\n// will have a different PayloadType\n//\n// https://tools.ietf.org/html/rfc3550#section-3\ntype PayloadType uint8\n"
        },
        {
          "name": "yarn.lock",
          "type": "blob",
          "size": 15.5947265625,
          "content": "# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n# SPDX-FileCopyrightText: 2023 The Pion community <https://pion.ly>\n# SPDX-License-Identifier: MIT\n\n\"@roamhq/wrtc-darwin-arm64@0.8.0\":\n  version \"0.8.0\"\n  resolved \"https://registry.yarnpkg.com/@roamhq/wrtc-darwin-arm64/-/wrtc-darwin-arm64-0.8.0.tgz#15057e6b8f57e4d1b7008a9d848b6f2036adbb24\"\n  integrity sha512-OtV2KWO7zOG3L8TF3KCt9aucynVCD/ww2xeXXgg+FLkya3ca0uzehN8EQJ3BL4tkInksbFJ2ssyu9cehfJ3ZuA==\n\n\"@roamhq/wrtc-darwin-x64@0.8.0\":\n  version \"0.8.0\"\n  resolved \"https://registry.yarnpkg.com/@roamhq/wrtc-darwin-x64/-/wrtc-darwin-x64-0.8.0.tgz#e09137b5a7edf2c2412bc63f1da1893dcaa211fd\"\n  integrity sha512-VY7Vzt/SDDDCpW//h8GW9bOZrOr8gWXPZVD9473ypl4jyBIoO57yyLbHzd1G0vBUkS6szsHlQCz1WwpI30YL+g==\n\n\"@roamhq/wrtc-linux-arm64@0.8.1\":\n  version \"0.8.1\"\n  resolved \"https://registry.yarnpkg.com/@roamhq/wrtc-linux-arm64/-/wrtc-linux-arm64-0.8.1.tgz#9a5f3297de44fcec86713d0baefa0594658ab71e\"\n  integrity sha512-FBJLLazlWkGQUXaokC/rTbrUQbb0CNFYry52fZGstufrGLTWu+g4HcwXdVvxh1tnVtVMvkQGk+mlOL52sCxw0A==\n\n\"@roamhq/wrtc-linux-x64@0.8.1\":\n  version \"0.8.1\"\n  resolved \"https://registry.yarnpkg.com/@roamhq/wrtc-linux-x64/-/wrtc-linux-x64-0.8.1.tgz#3c5b60ca6cc6ebf5c2389d852f4a101135031da2\"\n  integrity sha512-I9oWG7b4uvWO1IOR/aF34n+ID6TKVuSs0jd19h5KdhfRtw7FFh9xxuwN9rONPxLVa6fS0q+MCZgAf8Scz89L8Q==\n\n\"@roamhq/wrtc-win32-x64@0.8.0\":\n  version \"0.8.0\"\n  resolved \"https://registry.yarnpkg.com/@roamhq/wrtc-win32-x64/-/wrtc-win32-x64-0.8.0.tgz#582e2478df48201d5757b60dcd4b4dcc40a054b7\"\n  integrity sha512-R2fxl41BLWPiP4eaTHGLzbbVvRjx1mV/OsgINCvawO7Hwz5Zx9I45+Fhrw3hd4n5amIeSG9VIF7Kz8eeTFXTGQ==\n\n\"@roamhq/wrtc@^0.8.0\":\n  version \"0.8.0\"\n  resolved \"https://registry.yarnpkg.com/@roamhq/wrtc/-/wrtc-0.8.0.tgz#03c8c64c3b6a1e6e8965ec6496fa7e97571ae04b\"\n  integrity sha512-C0V/nqc4/2xzORI5qa4mIeN/8UO3ywN1kInrJ9u6GljFx0D18JMUJEqe8yYHa61RrEeoWN3PKdW++k8TocSx/A==\n  optionalDependencies:\n    \"@roamhq/wrtc-darwin-arm64\" \"0.8.0\"\n    \"@roamhq/wrtc-darwin-x64\" \"0.8.0\"\n    \"@roamhq/wrtc-linux-arm64\" \"0.8.1\"\n    \"@roamhq/wrtc-linux-x64\" \"0.8.1\"\n    \"@roamhq/wrtc-win32-x64\" \"0.8.0\"\n    domexception \"^4.0.0\"\n\najv@^6.5.5:\n  version \"6.12.2\"\n  resolved \"https://registry.yarnpkg.com/ajv/-/ajv-6.12.2.tgz#c629c5eced17baf314437918d2da88c99d5958cd\"\n  integrity sha512-k+V+hzjm5q/Mr8ef/1Y9goCmlsK4I6Sm74teeyGvFk1XrOsbsKLjEdrvny42CZ+a8sXbk8KWpY/bDwS+FLL2UQ==\n  dependencies:\n    fast-deep-equal \"^3.1.1\"\n    fast-json-stable-stringify \"^2.0.0\"\n    json-schema-traverse \"^0.4.1\"\n    uri-js \"^4.2.2\"\n\nasn1@~0.2.3:\n  version \"0.2.4\"\n  resolved \"https://registry.yarnpkg.com/asn1/-/asn1-0.2.4.tgz#8d2475dfab553bb33e77b54e59e880bb8ce23136\"\n  integrity sha512-jxwzQpLQjSmWXgwaCZE9Nz+glAG01yF1QnWgbhGwHI5A6FRIEY6IVqtHhIepHqI7/kyEyQEagBC5mBEFlIYvdg==\n  dependencies:\n    safer-buffer \"~2.1.0\"\n\nassert-plus@1.0.0, assert-plus@^1.0.0:\n  version \"1.0.0\"\n  resolved \"https://registry.yarnpkg.com/assert-plus/-/assert-plus-1.0.0.tgz#f12e0f3c5d77b0b1cdd9146942e4e96c1e4dd525\"\n  integrity sha1-8S4PPF13sLHN2RRpQuTpbB5N1SU=\n\nasynckit@^0.4.0:\n  version \"0.4.0\"\n  resolved \"https://registry.yarnpkg.com/asynckit/-/asynckit-0.4.0.tgz#c79ed97f7f34cb8f2ba1bc9790bcc366474b4b79\"\n  integrity sha1-x57Zf380y48robyXkLzDZkdLS3k=\n\naws-sign2@~0.7.0:\n  version \"0.7.0\"\n  resolved \"https://registry.yarnpkg.com/aws-sign2/-/aws-sign2-0.7.0.tgz#b46e890934a9591f2d2f6f86d7e6a9f1b3fe76a8\"\n  integrity sha1-tG6JCTSpWR8tL2+G1+ap8bP+dqg=\n\naws4@^1.8.0:\n  version \"1.10.0\"\n  resolved \"https://registry.yarnpkg.com/aws4/-/aws4-1.10.0.tgz#a17b3a8ea811060e74d47d306122400ad4497ae2\"\n  integrity sha512-3YDiu347mtVtjpyV3u5kVqQLP242c06zwDOgpeRnybmXlYYsLbtTrUBUm8i8srONt+FWobl5aibnU1030PeeuA==\n\nbcrypt-pbkdf@^1.0.0:\n  version \"1.0.2\"\n  resolved \"https://registry.yarnpkg.com/bcrypt-pbkdf/-/bcrypt-pbkdf-1.0.2.tgz#a4301d389b6a43f9b67ff3ca11a3f6637e360e9e\"\n  integrity sha1-pDAdOJtqQ/m2f/PKEaP2Y342Dp4=\n  dependencies:\n    tweetnacl \"^0.14.3\"\n\ncaseless@~0.12.0:\n  version \"0.12.0\"\n  resolved \"https://registry.yarnpkg.com/caseless/-/caseless-0.12.0.tgz#1b681c21ff84033c826543090689420d187151dc\"\n  integrity sha1-G2gcIf+EAzyCZUMJBolCDRhxUdw=\n\ncombined-stream@^1.0.6, combined-stream@~1.0.6:\n  version \"1.0.8\"\n  resolved \"https://registry.yarnpkg.com/combined-stream/-/combined-stream-1.0.8.tgz#c3d45a8b34fd730631a110a8a2520682b31d5a7f\"\n  integrity sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==\n  dependencies:\n    delayed-stream \"~1.0.0\"\n\ncore-util-is@1.0.2:\n  version \"1.0.2\"\n  resolved \"https://registry.yarnpkg.com/core-util-is/-/core-util-is-1.0.2.tgz#b5fd54220aa2bc5ab57aab7140c940754503c1a7\"\n  integrity sha1-tf1UIgqivFq1eqtxQMlAdUUDwac=\n\ndashdash@^1.12.0:\n  version \"1.14.1\"\n  resolved \"https://registry.yarnpkg.com/dashdash/-/dashdash-1.14.1.tgz#853cfa0f7cbe2fed5de20326b8dd581035f6e2f0\"\n  integrity sha1-hTz6D3y+L+1d4gMmuN1YEDX24vA=\n  dependencies:\n    assert-plus \"^1.0.0\"\n\ndelayed-stream@~1.0.0:\n  version \"1.0.0\"\n  resolved \"https://registry.yarnpkg.com/delayed-stream/-/delayed-stream-1.0.0.tgz#df3ae199acadfb7d440aaae0b29e2272b24ec619\"\n  integrity sha1-3zrhmayt+31ECqrgsp4icrJOxhk=\n\ndomexception@^4.0.0:\n  version \"4.0.0\"\n  resolved \"https://registry.yarnpkg.com/domexception/-/domexception-4.0.0.tgz#4ad1be56ccadc86fc76d033353999a8037d03673\"\n  integrity sha512-A2is4PLG+eeSfoTMA95/s4pvAoSo2mKtiM5jlHkAVewmiO8ISFTFKZjH7UAM1Atli/OT/7JHOrJRJiMKUZKYBw==\n  dependencies:\n    webidl-conversions \"^7.0.0\"\n\necc-jsbn@~0.1.1:\n  version \"0.1.2\"\n  resolved \"https://registry.yarnpkg.com/ecc-jsbn/-/ecc-jsbn-0.1.2.tgz#3a83a904e54353287874c564b7549386849a98c9\"\n  integrity sha1-OoOpBOVDUyh4dMVkt1SThoSamMk=\n  dependencies:\n    jsbn \"~0.1.0\"\n    safer-buffer \"^2.1.0\"\n\nextend@~3.0.2:\n  version \"3.0.2\"\n  resolved \"https://registry.yarnpkg.com/extend/-/extend-3.0.2.tgz#f8b1136b4071fbd8eb140aff858b1019ec2915fa\"\n  integrity sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==\n\nextsprintf@1.3.0:\n  version \"1.3.0\"\n  resolved \"https://registry.yarnpkg.com/extsprintf/-/extsprintf-1.3.0.tgz#96918440e3041a7a414f8c52e3c574eb3c3e1e05\"\n  integrity sha1-lpGEQOMEGnpBT4xS48V06zw+HgU=\n\nextsprintf@^1.2.0:\n  version \"1.4.0\"\n  resolved \"https://registry.yarnpkg.com/extsprintf/-/extsprintf-1.4.0.tgz#e2689f8f356fad62cca65a3a91c5df5f9551692f\"\n  integrity sha1-4mifjzVvrWLMplo6kcXfX5VRaS8=\n\nfast-deep-equal@^3.1.1:\n  version \"3.1.1\"\n  resolved \"https://registry.yarnpkg.com/fast-deep-equal/-/fast-deep-equal-3.1.1.tgz#545145077c501491e33b15ec408c294376e94ae4\"\n  integrity sha512-8UEa58QDLauDNfpbrX55Q9jrGHThw2ZMdOky5Gl1CDtVeJDPVrG4Jxx1N8jw2gkWaff5UUuX1KJd+9zGe2B+ZA==\n\nfast-json-stable-stringify@^2.0.0:\n  version \"2.1.0\"\n  resolved \"https://registry.yarnpkg.com/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz#874bf69c6f404c2b5d99c481341399fd55892633\"\n  integrity sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==\n\nforever-agent@~0.6.1:\n  version \"0.6.1\"\n  resolved \"https://registry.yarnpkg.com/forever-agent/-/forever-agent-0.6.1.tgz#fbc71f0c41adeb37f96c577ad1ed42d8fdacca91\"\n  integrity sha1-+8cfDEGt6zf5bFd60e1C2P2sypE=\n\nform-data@~2.3.2:\n  version \"2.3.3\"\n  resolved \"https://registry.yarnpkg.com/form-data/-/form-data-2.3.3.tgz#dcce52c05f644f298c6a7ab936bd724ceffbf3a6\"\n  integrity sha512-1lLKB2Mu3aGP1Q/2eCOx0fNbRMe7XdwktwOruhfqqd0rIJWwN4Dh+E3hrPSlDCXnSR7UtZ1N38rVXm+6+MEhJQ==\n  dependencies:\n    asynckit \"^0.4.0\"\n    combined-stream \"^1.0.6\"\n    mime-types \"^2.1.12\"\n\ngetpass@^0.1.1:\n  version \"0.1.7\"\n  resolved \"https://registry.yarnpkg.com/getpass/-/getpass-0.1.7.tgz#5eff8e3e684d569ae4cb2b1282604e8ba62149fa\"\n  integrity sha1-Xv+OPmhNVprkyysSgmBOi6YhSfo=\n  dependencies:\n    assert-plus \"^1.0.0\"\n\nhar-schema@^2.0.0:\n  version \"2.0.0\"\n  resolved \"https://registry.yarnpkg.com/har-schema/-/har-schema-2.0.0.tgz#a94c2224ebcac04782a0d9035521f24735b7ec92\"\n  integrity sha1-qUwiJOvKwEeCoNkDVSHyRzW37JI=\n\nhar-validator@~5.1.3:\n  version \"5.1.3\"\n  resolved \"https://registry.yarnpkg.com/har-validator/-/har-validator-5.1.3.tgz#1ef89ebd3e4996557675eed9893110dc350fa080\"\n  integrity sha512-sNvOCzEQNr/qrvJgc3UG/kD4QtlHycrzwS+6mfTrrSq97BvaYcPZZI1ZSqGSPR73Cxn4LKTD4PttRwfU7jWq5g==\n  dependencies:\n    ajv \"^6.5.5\"\n    har-schema \"^2.0.0\"\n\nhttp-signature@~1.2.0:\n  version \"1.2.0\"\n  resolved \"https://registry.yarnpkg.com/http-signature/-/http-signature-1.2.0.tgz#9aecd925114772f3d95b65a60abb8f7c18fbace1\"\n  integrity sha1-muzZJRFHcvPZW2WmCruPfBj7rOE=\n  dependencies:\n    assert-plus \"^1.0.0\"\n    jsprim \"^1.2.2\"\n    sshpk \"^1.7.0\"\n\nis-typedarray@~1.0.0:\n  version \"1.0.0\"\n  resolved \"https://registry.yarnpkg.com/is-typedarray/-/is-typedarray-1.0.0.tgz#e479c80858df0c1b11ddda6940f96011fcda4a9a\"\n  integrity sha1-5HnICFjfDBsR3dppQPlgEfzaSpo=\n\nisstream@~0.1.2:\n  version \"0.1.2\"\n  resolved \"https://registry.yarnpkg.com/isstream/-/isstream-0.1.2.tgz#47e63f7af55afa6f92e1500e690eb8b8529c099a\"\n  integrity sha1-R+Y/evVa+m+S4VAOaQ64uFKcCZo=\n\njsbn@~0.1.0:\n  version \"0.1.1\"\n  resolved \"https://registry.yarnpkg.com/jsbn/-/jsbn-0.1.1.tgz#a5e654c2e5a2deb5f201d96cefbca80c0ef2f513\"\n  integrity sha1-peZUwuWi3rXyAdls77yoDA7y9RM=\n\njson-schema-traverse@^0.4.1:\n  version \"0.4.1\"\n  resolved \"https://registry.yarnpkg.com/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz#69f6a87d9513ab8bb8fe63bdb0979c448e684660\"\n  integrity sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==\n\njson-schema@0.2.3:\n  version \"0.2.3\"\n  resolved \"https://registry.yarnpkg.com/json-schema/-/json-schema-0.2.3.tgz#b480c892e59a2f05954ce727bd3f2a4e882f9e13\"\n  integrity sha1-tIDIkuWaLwWVTOcnvT8qTogvnhM=\n\njson-stringify-safe@~5.0.1:\n  version \"5.0.1\"\n  resolved \"https://registry.yarnpkg.com/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz#1296a2d58fd45f19a0f6ce01d65701e2c735b6eb\"\n  integrity sha1-Epai1Y/UXxmg9s4B1lcB4sc1tus=\n\njsprim@^1.2.2:\n  version \"1.4.1\"\n  resolved \"https://registry.yarnpkg.com/jsprim/-/jsprim-1.4.1.tgz#313e66bc1e5cc06e438bc1b7499c2e5c56acb6a2\"\n  integrity sha1-MT5mvB5cwG5Di8G3SZwuXFastqI=\n  dependencies:\n    assert-plus \"1.0.0\"\n    extsprintf \"1.3.0\"\n    json-schema \"0.2.3\"\n    verror \"1.10.0\"\n\nmime-db@1.44.0:\n  version \"1.44.0\"\n  resolved \"https://registry.yarnpkg.com/mime-db/-/mime-db-1.44.0.tgz#fa11c5eb0aca1334b4233cb4d52f10c5a6272f92\"\n  integrity sha512-/NOTfLrsPBVeH7YtFPgsVWveuL+4SjjYxaQ1xtM1KMFj7HdxlBlxeyNLzhyJVx7r4rZGJAZ/6lkKCitSc/Nmpg==\n\nmime-types@^2.1.12, mime-types@~2.1.19:\n  version \"2.1.27\"\n  resolved \"https://registry.yarnpkg.com/mime-types/-/mime-types-2.1.27.tgz#47949f98e279ea53119f5722e0f34e529bec009f\"\n  integrity sha512-JIhqnCasI9yD+SsmkquHBxTSEuZdQX5BuQnS2Vc7puQQQ+8yiP5AY5uWhpdv4YL4VM5c6iliiYWPgJ/nJQLp7w==\n  dependencies:\n    mime-db \"1.44.0\"\n\noauth-sign@~0.9.0:\n  version \"0.9.0\"\n  resolved \"https://registry.yarnpkg.com/oauth-sign/-/oauth-sign-0.9.0.tgz#47a7b016baa68b5fa0ecf3dee08a85c679ac6455\"\n  integrity sha512-fexhUFFPTGV8ybAtSIGbV6gOkSv8UtRbDBnAyLQw4QPKkgNlsH2ByPGtMUqdWkos6YCRmAqViwgZrJc/mRDzZQ==\n\nperformance-now@^2.1.0:\n  version \"2.1.0\"\n  resolved \"https://registry.yarnpkg.com/performance-now/-/performance-now-2.1.0.tgz#6309f4e0e5fa913ec1c69307ae364b4b377c9e7b\"\n  integrity sha1-Ywn04OX6kT7BxpMHrjZLSzd8nns=\n\npsl@^1.1.28:\n  version \"1.8.0\"\n  resolved \"https://registry.yarnpkg.com/psl/-/psl-1.8.0.tgz#9326f8bcfb013adcc005fdff056acce020e51c24\"\n  integrity sha512-RIdOzyoavK+hA18OGGWDqUTsCLhtA7IcZ/6NCs4fFJaHBDab+pDDmDIByWFRQJq2Cd7r1OoQxBGKOaztq+hjIQ==\n\npunycode@^2.1.0, punycode@^2.1.1:\n  version \"2.1.1\"\n  resolved \"https://registry.yarnpkg.com/punycode/-/punycode-2.1.1.tgz#b58b010ac40c22c5657616c8d2c2c02c7bf479ec\"\n  integrity sha512-XRsRjdf+j5ml+y/6GKHPZbrF/8p2Yga0JPtdqTIY2Xe5ohJPD9saDJJLPvp9+NSBprVvevdXZybnj2cv8OEd0A==\n\nqs@~6.5.2:\n  version \"6.5.2\"\n  resolved \"https://registry.yarnpkg.com/qs/-/qs-6.5.2.tgz#cb3ae806e8740444584ef154ce8ee98d403f3e36\"\n  integrity sha512-N5ZAX4/LxJmF+7wN74pUD6qAh9/wnvdQcjq9TZjevvXzSUo7bfmw91saqMjzGS2xq91/odN2dW/WOl7qQHNDGA==\n\nrequest@2.88.2:\n  version \"2.88.2\"\n  resolved \"https://registry.yarnpkg.com/request/-/request-2.88.2.tgz#d73c918731cb5a87da047e207234146f664d12b3\"\n  integrity sha512-MsvtOrfG9ZcrOwAW+Qi+F6HbD0CWXEh9ou77uOb7FM2WPhwT7smM833PzanhJLsgXjN89Ir6V2PczXNnMpwKhw==\n  dependencies:\n    aws-sign2 \"~0.7.0\"\n    aws4 \"^1.8.0\"\n    caseless \"~0.12.0\"\n    combined-stream \"~1.0.6\"\n    extend \"~3.0.2\"\n    forever-agent \"~0.6.1\"\n    form-data \"~2.3.2\"\n    har-validator \"~5.1.3\"\n    http-signature \"~1.2.0\"\n    is-typedarray \"~1.0.0\"\n    isstream \"~0.1.2\"\n    json-stringify-safe \"~5.0.1\"\n    mime-types \"~2.1.19\"\n    oauth-sign \"~0.9.0\"\n    performance-now \"^2.1.0\"\n    qs \"~6.5.2\"\n    safe-buffer \"^5.1.2\"\n    tough-cookie \"~2.5.0\"\n    tunnel-agent \"^0.6.0\"\n    uuid \"^3.3.2\"\n\nsafe-buffer@^5.0.1:\n  version \"5.2.1\"\n  resolved \"https://registry.yarnpkg.com/safe-buffer/-/safe-buffer-5.2.1.tgz#1eaf9fa9bdb1fdd4ec75f58f9cdb4e6b7827eec6\"\n  integrity sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==\n\nsafe-buffer@^5.1.2:\n  version \"5.1.2\"\n  resolved \"https://registry.yarnpkg.com/safe-buffer/-/safe-buffer-5.1.2.tgz#991ec69d296e0313747d59bdfd2b745c35f8828d\"\n  integrity sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==\n\nsafer-buffer@^2.0.2, safer-buffer@^2.1.0, safer-buffer@~2.1.0:\n  version \"2.1.2\"\n  resolved \"https://registry.yarnpkg.com/safer-buffer/-/safer-buffer-2.1.2.tgz#44fa161b0187b9549dd84bb91802f9bd8385cd6a\"\n  integrity sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==\n\nsshpk@^1.7.0:\n  version \"1.16.1\"\n  resolved \"https://registry.yarnpkg.com/sshpk/-/sshpk-1.16.1.tgz#fb661c0bef29b39db40769ee39fa70093d6f6877\"\n  integrity sha512-HXXqVUq7+pcKeLqqZj6mHFUMvXtOJt1uoUx09pFW6011inTMxqI8BA8PM95myrIyyKwdnzjdFjLiE6KBPVtJIg==\n  dependencies:\n    asn1 \"~0.2.3\"\n    assert-plus \"^1.0.0\"\n    bcrypt-pbkdf \"^1.0.0\"\n    dashdash \"^1.12.0\"\n    ecc-jsbn \"~0.1.1\"\n    getpass \"^0.1.1\"\n    jsbn \"~0.1.0\"\n    safer-buffer \"^2.0.2\"\n    tweetnacl \"~0.14.0\"\n\ntough-cookie@~2.5.0:\n  version \"2.5.0\"\n  resolved \"https://registry.yarnpkg.com/tough-cookie/-/tough-cookie-2.5.0.tgz#cd9fb2a0aa1d5a12b473bd9fb96fa3dcff65ade2\"\n  integrity sha512-nlLsUzgm1kfLXSXfRZMc1KLAugd4hqJHDTvc2hDIwS3mZAfMEuMbc03SujMF+GEcpaX/qboeycw6iO8JwVv2+g==\n  dependencies:\n    psl \"^1.1.28\"\n    punycode \"^2.1.1\"\n\ntunnel-agent@^0.6.0:\n  version \"0.6.0\"\n  resolved \"https://registry.yarnpkg.com/tunnel-agent/-/tunnel-agent-0.6.0.tgz#27a5dea06b36b04a0a9966774b290868f0fc40fd\"\n  integrity sha1-J6XeoGs2sEoKmWZ3SykIaPD8QP0=\n  dependencies:\n    safe-buffer \"^5.0.1\"\n\ntweetnacl@^0.14.3, tweetnacl@~0.14.0:\n  version \"0.14.5\"\n  resolved \"https://registry.yarnpkg.com/tweetnacl/-/tweetnacl-0.14.5.tgz#5ae68177f192d4456269d108afa93ff8743f4f64\"\n  integrity sha1-WuaBd/GS1EViadEIr6k/+HQ/T2Q=\n\nuri-js@^4.2.2:\n  version \"4.2.2\"\n  resolved \"https://registry.yarnpkg.com/uri-js/-/uri-js-4.2.2.tgz#94c540e1ff772956e2299507c010aea6c8838eb0\"\n  integrity sha512-KY9Frmirql91X2Qgjry0Wd4Y+YTdrdZheS8TFwvkbLWf/G5KNJDCh6pKL5OZctEW4+0Baa5idK2ZQuELRwPznQ==\n  dependencies:\n    punycode \"^2.1.0\"\n\nuuid@^3.3.2:\n  version \"3.4.0\"\n  resolved \"https://registry.yarnpkg.com/uuid/-/uuid-3.4.0.tgz#b23e4358afa8a202fe7a100af1f5f883f02007ee\"\n  integrity sha512-HjSDRw6gZE5JMggctHBcjVak08+KEVhSIiDzFnT9S9aegmp85S/bReBVTb4QTFaRNptJ9kuYaNhnbNEOkbKb/A==\n\nverror@1.10.0:\n  version \"1.10.0\"\n  resolved \"https://registry.yarnpkg.com/verror/-/verror-1.10.0.tgz#3a105ca17053af55d6e270c1f8288682e18da400\"\n  integrity sha1-OhBcoXBTr1XW4nDB+CiGguGNpAA=\n  dependencies:\n    assert-plus \"^1.0.0\"\n    core-util-is \"1.0.2\"\n    extsprintf \"^1.2.0\"\n\nwebidl-conversions@^7.0.0:\n  version \"7.0.0\"\n  resolved \"https://registry.yarnpkg.com/webidl-conversions/-/webidl-conversions-7.0.0.tgz#256b4e1882be7debbf01d05f0aa2039778ea080a\"\n  integrity sha512-VwddBukDzu71offAQR975unBIGqfKZpM+8ZX6ySk8nYhVoo5CYaZyzt3YBvYtRtO+aoGlqxPg/B87NGVZ/fu6g==\n"
        }
      ]
    }
  ]
}