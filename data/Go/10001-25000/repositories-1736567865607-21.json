{
  "metadata": {
    "timestamp": 1736567865607,
    "page": 21,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "urfave/cli",
      "stars": 22598,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.107421875,
          "content": "*.coverprofile\n*.exe\n*.orig\n.*envrc\n.envrc\n.idea\n/.local/\n/site/\ncoverage.txt\nexamples/*/built-example\nvendor\n"
        },
        {
          "name": ".golangci.yaml",
          "type": "blob",
          "size": 0.095703125,
          "content": "# https://golangci-lint.run/usage/configuration/\nlinters:\n  enable:\n    - makezero\n    - misspell\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.19140625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of experience,\neducation, socio-economic status, nationality, personal appearance, race,\nreligion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting urfave-governance@googlegroups.com, a members-only group\nthat is world-postable. All complaints will be reviewed and investigated and\nwill result in a response that is deemed necessary and appropriate to the\ncircumstances. The project team is obligated to maintain confidentiality with\nregard to the reporter of an incident. Further details of specific enforcement\npolicies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0537109375,
          "content": "MIT License\n\nCopyright (c) 2023 urfave/cli maintainers\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.7998046875,
          "content": "# NOTE: this Makefile is meant to provide a simplified entry point for humans to\n# run all of the critical steps to verify one's changes are harmonious in\n# nature. Keeping target bodies to one line each and abstaining from make magic\n# are very important so that maintainers and contributors can focus their\n# attention on files that are primarily Go.\n\nGO_RUN_BUILD := go run scripts/build.go\n\n.PHONY: all\nall: generate vet test check-binary-size gfmrun\n\n# NOTE: this is a special catch-all rule to run any of the commands\n# defined in scripts/build.go with optional arguments passed\n# via GFLAGS (global flags) and FLAGS (command-specific flags), e.g.:\n#\n#   $ make test GFLAGS='--packages cli'\n%:\n\t$(GO_RUN_BUILD) $(GFLAGS) $* $(FLAGS)\n\n.PHONY: docs\ndocs:\n\tmkdocs build\n\n.PHONY: serve-docs\nserve-docs:\n\tmkdocs serve\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.32421875,
          "content": "# Welcome to urfave/cli\n\n[![Go Reference][goreference_badge]][goreference_link]\n[![Go Report Card][goreportcard_badge]][goreportcard_link]\n[![codecov][codecov_badge]][codecov_link]\n[![Tests status][test_badge]][test_link]\n\nurfave/cli is a **declarative**, simple, fast, and fun package for building\ncommand line tools in Go featuring:\n\n- commands and subcommands with alias and prefix match support\n- flexible and permissive help system\n- dynamic shell completion for `bash`, `zsh`, `fish`, and `powershell`\n- no dependencies except Go standard library\n- input flags for simple types, slices of simple types, time, duration, and\n  others\n- compound short flag support (`-a` `-b` `-c` can be shortened to `-abc`)\n- documentation generation in `man` and Markdown (supported via the\n  [`urfave/cli-docs`][urfave/cli-docs] module)\n- input lookup from:\n  - environment variables\n  - plain text files\n  - structured file formats (supported via the\n    [`urfave/cli-altsrc`][urfave/cli-altsrc] module)\n\n## Documentation\n\nSee the hosted documentation website at <https://cli.urfave.org>. Contents of\nthis website are built from the [`./docs`](./docs) directory.\n\n## Support\n\nCheck the [Q&A discussions]. If you don't find answer to your question, [create\na new discussion].\n\nIf you found a bug or have a feature request, [create a new issue].\n\nPlease keep in mind that this project is run by unpaid volunteers.\n\n### License\n\nSee [`LICENSE`](./LICENSE).\n\n[test_badge]: https://github.com/urfave/cli/actions/workflows/test.yml/badge.svg\n[test_link]: https://github.com/urfave/cli/actions/workflows/test.yml\n[goreference_badge]: https://pkg.go.dev/badge/github.com/urfave/cli/v3.svg\n[goreference_link]: https://pkg.go.dev/github.com/urfave/cli/v3\n[goreportcard_badge]: https://goreportcard.com/badge/github.com/urfave/cli/v3\n[goreportcard_link]: https://goreportcard.com/report/github.com/urfave/cli/v3\n[codecov_badge]: https://codecov.io/gh/urfave/cli/branch/main/graph/badge.svg?token=t9YGWLh05g\n[codecov_link]: https://codecov.io/gh/urfave/cli\n[Q&A discussions]: https://github.com/urfave/cli/discussions/categories/q-a\n[create a new discussion]: https://github.com/urfave/cli/discussions/new?category=q-a\n[urfave/cli-docs]: https://github.com/urfave/cli-docs\n[urfave/cli-altsrc]: https://github.com/urfave/cli-altsrc\n[create a new issue]: https://github.com/urfave/cli/issues/new/choose\n"
        },
        {
          "name": "args.go",
          "type": "blob",
          "size": 3.8037109375,
          "content": "package cli\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype Args interface {\n\t// Get returns the nth argument, or else a blank string\n\tGet(n int) string\n\t// First returns the first argument, or else a blank string\n\tFirst() string\n\t// Tail returns the rest of the arguments (not the first one)\n\t// or else an empty string slice\n\tTail() []string\n\t// Len returns the length of the wrapped slice\n\tLen() int\n\t// Present checks if there are any arguments present\n\tPresent() bool\n\t// Slice returns a copy of the internal slice\n\tSlice() []string\n}\n\ntype stringSliceArgs struct {\n\tv []string\n}\n\nfunc (a *stringSliceArgs) Get(n int) string {\n\tif len(a.v) > n {\n\t\treturn a.v[n]\n\t}\n\treturn \"\"\n}\n\nfunc (a *stringSliceArgs) First() string {\n\treturn a.Get(0)\n}\n\nfunc (a *stringSliceArgs) Tail() []string {\n\tif a.Len() >= 2 {\n\t\ttail := a.v[1:]\n\t\tret := make([]string, len(tail))\n\t\tcopy(ret, tail)\n\t\treturn ret\n\t}\n\n\treturn []string{}\n}\n\nfunc (a *stringSliceArgs) Len() int {\n\treturn len(a.v)\n}\n\nfunc (a *stringSliceArgs) Present() bool {\n\treturn a.Len() != 0\n}\n\nfunc (a *stringSliceArgs) Slice() []string {\n\tret := make([]string, len(a.v))\n\tcopy(ret, a.v)\n\treturn ret\n}\n\ntype Argument interface {\n\tParse([]string) ([]string, error)\n\tUsage() string\n}\n\n// AnyArguments to differentiate between no arguments(nil) vs aleast one\nvar AnyArguments = []Argument{\n\t&StringArg{\n\t\tMax: -1,\n\t},\n}\n\ntype ArgumentBase[T any, C any, VC ValueCreator[T, C]] struct {\n\tName        string `json:\"name\"`      // the name of this argument\n\tValue       T      `json:\"value\"`     // the default value of this argument\n\tDestination *T     `json:\"-\"`         // the destination point for this argument\n\tValues      *[]T   `json:\"-\"`         // all the values of this argument, only if multiple are supported\n\tUsageText   string `json:\"usageText\"` // the usage text to show\n\tMin         int    `json:\"minTimes\"`  // the min num of occurrences of this argument\n\tMax         int    `json:\"maxTimes\"`  // the max num of occurrences of this argument, set to -1 for unlimited\n\tConfig      C      `json:\"config\"`    // config for this argument similar to Flag Config\n}\n\nfunc (a *ArgumentBase[T, C, VC]) Usage() string {\n\tif a.UsageText != \"\" {\n\t\treturn a.UsageText\n\t}\n\n\tusageFormat := \"\"\n\tif a.Min == 0 {\n\t\tif a.Max == 1 {\n\t\t\tusageFormat = \"[%[1]s]\"\n\t\t} else {\n\t\t\tusageFormat = \"[%[1]s ...]\"\n\t\t}\n\t} else {\n\t\tusageFormat = \"%[1]s [%[1]s ...]\"\n\t}\n\treturn fmt.Sprintf(usageFormat, a.Name)\n}\n\nfunc (a *ArgumentBase[T, C, VC]) Parse(s []string) ([]string, error) {\n\ttracef(\"calling arg%[1] parse with args %[2]\", &a.Name, s)\n\tif a.Max == 0 {\n\t\tfmt.Printf(\"WARNING args %s has max 0, not parsing argument\\n\", a.Name)\n\t\treturn s, nil\n\t}\n\tif a.Max != -1 && a.Min > a.Max {\n\t\tfmt.Printf(\"WARNING args %s has min[%d] > max[%d], not parsing argument\\n\", a.Name, a.Min, a.Max)\n\t\treturn s, nil\n\t}\n\n\tcount := 0\n\tvar vc VC\n\tvar t T\n\tvalue := vc.Create(a.Value, &t, a.Config)\n\tvalues := []T{}\n\n\tfor _, arg := range s {\n\t\tif err := value.Set(arg); err != nil {\n\t\t\treturn s, err\n\t\t}\n\t\tvalues = append(values, value.Get().(T))\n\t\tcount++\n\t\tif count >= a.Max && a.Max > -1 {\n\t\t\tbreak\n\t\t}\n\t}\n\tif count < a.Min {\n\t\treturn s, fmt.Errorf(\"sufficient count of arg %s not provided, given %d expected %d\", a.Name, count, a.Min)\n\t}\n\n\tif a.Values == nil {\n\t\ta.Values = &values\n\t} else if count > 0 {\n\t\t*a.Values = values\n\t}\n\n\tif a.Max == 1 && a.Destination != nil {\n\t\tif len(values) > 0 {\n\t\t\t*a.Destination = values[0]\n\t\t} else {\n\t\t\t*a.Destination = t\n\t\t}\n\t}\n\n\treturn s[count:], nil\n}\n\ntype (\n\tFloatArg     = ArgumentBase[float64, NoConfig, floatValue]\n\tIntArg       = ArgumentBase[int64, IntegerConfig, intValue]\n\tStringArg    = ArgumentBase[string, StringConfig, stringValue]\n\tStringMapArg = ArgumentBase[map[string]string, StringConfig, StringMap]\n\tTimestampArg = ArgumentBase[time.Time, TimestampConfig, timestampValue]\n\tUintArg      = ArgumentBase[uint64, IntegerConfig, uintValue]\n)\n"
        },
        {
          "name": "args_test.go",
          "type": "blob",
          "size": 5.279296875,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestArgumentsRootCommand(t *testing.T) {\n\tcmd := buildMinimalTestCommand()\n\tvar ival int64\n\tvar fval float64\n\tvar fvals []float64\n\tcmd.Arguments = []Argument{\n\t\t&IntArg{\n\t\t\tName:        \"ia\",\n\t\t\tMin:         1,\n\t\t\tMax:         1,\n\t\t\tDestination: &ival,\n\t\t},\n\t\t&FloatArg{\n\t\t\tName:        \"fa\",\n\t\t\tMin:         0,\n\t\t\tMax:         2,\n\t\t\tDestination: &fval,\n\t\t\tValues:      &fvals,\n\t\t},\n\t}\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\", \"10\"}))\n\trequire.Equal(t, int64(10), ival)\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\", \"12\", \"10.1\"}))\n\trequire.Equal(t, int64(12), ival)\n\trequire.Equal(t, []float64{10.1}, fvals)\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\", \"13\", \"10.1\", \"11.09\"}))\n\trequire.Equal(t, int64(13), ival)\n\trequire.Equal(t, []float64{10.1, 11.09}, fvals)\n\n\trequire.Error(t, errors.New(\"No help topic for '12.1\"), cmd.Run(context.Background(), []string{\"foo\", \"13\", \"10.1\", \"11.09\", \"12.1\"}))\n\trequire.Equal(t, int64(13), ival)\n\trequire.Equal(t, []float64{10.1, 11.09}, fvals)\n\n\tcmd.Arguments = append(cmd.Arguments,\n\t\t&StringArg{\n\t\t\tName: \"sa\",\n\t\t},\n\t\t&UintArg{\n\t\t\tName: \"ua\",\n\t\t\tMin:  2,\n\t\t\tMax:  1, // max is less than min\n\t\t},\n\t)\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\", \"10\"}))\n}\n\nfunc TestArgumentsSubcommand(t *testing.T) {\n\tcmd := buildMinimalTestCommand()\n\tvar ifval int64\n\tvar svals []string\n\tvar tval time.Time\n\tcmd.Commands = []*Command{\n\t\t{\n\t\t\tName: \"subcmd\",\n\t\t\tFlags: []Flag{\n\t\t\t\t&IntFlag{\n\t\t\t\t\tName:        \"foo\",\n\t\t\t\t\tValue:       10,\n\t\t\t\t\tDestination: &ifval,\n\t\t\t\t},\n\t\t\t},\n\t\t\tArguments: []Argument{\n\t\t\t\t&TimestampArg{\n\t\t\t\t\tName:        \"ta\",\n\t\t\t\t\tMin:         1,\n\t\t\t\t\tMax:         1,\n\t\t\t\t\tDestination: &tval,\n\t\t\t\t\tConfig: TimestampConfig{\n\t\t\t\t\t\tLayouts: []string{time.RFC3339},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t&StringArg{\n\t\t\t\t\tName:   \"sa\",\n\t\t\t\t\tMin:    1,\n\t\t\t\t\tMax:    3,\n\t\t\t\t\tValues: &svals,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire.Error(t, errors.New(\"sufficient count of arg sa not provided, given 0 expected 1\"), cmd.Run(context.Background(), []string{\"foo\", \"subcmd\", \"2006-01-02T15:04:05Z\"}))\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\", \"subcmd\", \"2006-01-02T15:04:05Z\", \"fubar\"}))\n\trequire.Equal(t, time.Date(2006, time.January, 2, 15, 4, 5, 0, time.UTC), tval)\n\trequire.Equal(t, []string{\"fubar\"}, svals)\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\", \"subcmd\", \"--foo\", \"100\", \"2006-01-02T15:04:05Z\", \"fubar\", \"some\"}))\n\trequire.Equal(t, int64(100), ifval)\n\trequire.Equal(t, time.Date(2006, time.January, 2, 15, 4, 5, 0, time.UTC), tval)\n\trequire.Equal(t, []string{\"fubar\", \"some\"}, svals)\n}\n\nfunc TestArgsUsage(t *testing.T) {\n\targ := &IntArg{\n\t\tName: \"ia\",\n\t\tMin:  0,\n\t\tMax:  1,\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\tmin      int\n\t\tmax      int\n\t\tusage    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"optional\",\n\t\t\tmin:      0,\n\t\t\tmax:      1,\n\t\t\texpected: \"[ia]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"optional\",\n\t\t\tmin:      0,\n\t\t\tmax:      1,\n\t\t\tusage:    \"[my optional usage]\",\n\t\t\texpected: \"[my optional usage]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"zero or more\",\n\t\t\tmin:      0,\n\t\t\tmax:      2,\n\t\t\texpected: \"[ia ...]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"one\",\n\t\t\tmin:      1,\n\t\t\tmax:      1,\n\t\t\texpected: \"ia [ia ...]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"many\",\n\t\t\tmin:      2,\n\t\t\tmax:      1,\n\t\t\texpected: \"ia [ia ...]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"many2\",\n\t\t\tmin:      2,\n\t\t\tmax:      0,\n\t\t\texpected: \"ia [ia ...]\",\n\t\t},\n\t\t{\n\t\t\tname:     \"unlimited\",\n\t\t\tmin:      2,\n\t\t\tmax:      -1,\n\t\t\texpected: \"ia [ia ...]\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\targ.Min, arg.Max, arg.UsageText = test.min, test.max, test.usage\n\t\t\trequire.Equal(t, test.expected, arg.Usage())\n\t\t})\n\t}\n}\n\nfunc TestSingleOptionalArg(t *testing.T) {\n\tcmd := buildMinimalTestCommand()\n\tvar s1 string\n\targ := &StringArg{\n\t\tMin:         0,\n\t\tMax:         1,\n\t\tDestination: &s1,\n\t}\n\tcmd.Arguments = []Argument{\n\t\targ,\n\t}\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\"}))\n\trequire.Equal(t, \"\", s1)\n\n\targ.Value = \"bar\"\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\"}))\n\trequire.Equal(t, \"bar\", s1)\n\n\trequire.NoError(t, cmd.Run(context.Background(), []string{\"foo\", \"zbar\"}))\n\trequire.Equal(t, \"zbar\", s1)\n}\n\nfunc TestUnboundedArgs(t *testing.T) {\n\targ := &StringArg{\n\t\tMin: 0,\n\t\tMax: -1,\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\targs     []string\n\t\tvalues   []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\tname:     \"cmd accepts no args\",\n\t\t\targs:     []string{\"foo\"},\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"cmd uses given args\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"baz\"},\n\t\t\texpected: []string{\"bar\", \"baz\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"cmd uses default values\",\n\t\t\targs:     []string{\"foo\"},\n\t\t\tvalues:   []string{\"zbar\", \"zbaz\"},\n\t\t\texpected: []string{\"zbar\", \"zbaz\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"given args override default values\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"baz\"},\n\t\t\tvalues:   []string{\"zbar\", \"zbaz\"},\n\t\t\texpected: []string{\"bar\", \"baz\"},\n\t\t},\n\t}\n\n\tcmd := buildMinimalTestCommand()\n\tcmd.Arguments = []Argument{arg}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\targ.Values = &test.values\n\t\t\trequire.NoError(t, cmd.Run(context.Background(), test.args))\n\t\t\trequire.Equal(t, test.expected, *arg.Values)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "autocomplete",
          "type": "tree",
          "content": null
        },
        {
          "name": "category.go",
          "type": "blob",
          "size": 4.2998046875,
          "content": "package cli\n\nimport \"sort\"\n\n// CommandCategories interface allows for category manipulation\ntype CommandCategories interface {\n\t// AddCommand adds a command to a category, creating a new category if necessary.\n\tAddCommand(category string, command *Command)\n\t// Categories returns a slice of categories sorted by name\n\tCategories() []CommandCategory\n}\n\ntype commandCategories []*commandCategory\n\nfunc newCommandCategories() CommandCategories {\n\tret := commandCategories([]*commandCategory{})\n\treturn &ret\n}\n\nfunc (c *commandCategories) Less(i, j int) bool {\n\treturn lexicographicLess((*c)[i].Name(), (*c)[j].Name())\n}\n\nfunc (c *commandCategories) Len() int {\n\treturn len(*c)\n}\n\nfunc (c *commandCategories) Swap(i, j int) {\n\t(*c)[i], (*c)[j] = (*c)[j], (*c)[i]\n}\n\nfunc (c *commandCategories) AddCommand(category string, command *Command) {\n\tfor _, commandCategory := range []*commandCategory(*c) {\n\t\tif commandCategory.name == category {\n\t\t\tcommandCategory.commands = append(commandCategory.commands, command)\n\t\t\treturn\n\t\t}\n\t}\n\tnewVal := append(*c,\n\t\t&commandCategory{name: category, commands: []*Command{command}})\n\t*c = newVal\n}\n\nfunc (c *commandCategories) Categories() []CommandCategory {\n\tret := make([]CommandCategory, len(*c))\n\tfor i, cat := range *c {\n\t\tret[i] = cat\n\t}\n\treturn ret\n}\n\n// CommandCategory is a category containing commands.\ntype CommandCategory interface {\n\t// Name returns the category name string\n\tName() string\n\t// VisibleCommands returns a slice of the Commands with Hidden=false\n\tVisibleCommands() []*Command\n}\n\ntype commandCategory struct {\n\tname     string\n\tcommands []*Command\n}\n\nfunc (c *commandCategory) Name() string {\n\treturn c.name\n}\n\nfunc (c *commandCategory) VisibleCommands() []*Command {\n\tif c.commands == nil {\n\t\tc.commands = []*Command{}\n\t}\n\n\tvar ret []*Command\n\tfor _, command := range c.commands {\n\t\tif !command.Hidden {\n\t\t\tret = append(ret, command)\n\t\t}\n\t}\n\treturn ret\n}\n\n// FlagCategories interface allows for category manipulation\ntype FlagCategories interface {\n\t// AddFlags adds a flag to a category, creating a new category if necessary.\n\tAddFlag(category string, fl Flag)\n\t// VisibleCategories returns a slice of visible flag categories sorted by name\n\tVisibleCategories() []VisibleFlagCategory\n}\n\ntype defaultFlagCategories struct {\n\tm map[string]*defaultVisibleFlagCategory\n}\n\nfunc newFlagCategories() FlagCategories {\n\treturn &defaultFlagCategories{\n\t\tm: map[string]*defaultVisibleFlagCategory{},\n\t}\n}\n\nfunc newFlagCategoriesFromFlags(fs []Flag) FlagCategories {\n\tfc := newFlagCategories()\n\n\tvar categorized bool\n\n\tfor _, fl := range fs {\n\t\tif cf, ok := fl.(CategorizableFlag); ok {\n\t\t\tvisible := false\n\t\t\tif vf, ok := fl.(VisibleFlag); ok {\n\t\t\t\tvisible = vf.IsVisible()\n\t\t\t}\n\t\t\tif cat := cf.GetCategory(); cat != \"\" && visible {\n\t\t\t\tfc.AddFlag(cat, fl)\n\t\t\t\tcategorized = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif categorized {\n\t\tfor _, fl := range fs {\n\t\t\tif cf, ok := fl.(CategorizableFlag); ok {\n\t\t\t\tvisible := false\n\t\t\t\tif vf, ok := fl.(VisibleFlag); ok {\n\t\t\t\t\tvisible = vf.IsVisible()\n\t\t\t\t}\n\t\t\t\tif cf.GetCategory() == \"\" && visible {\n\t\t\t\t\tfc.AddFlag(\"\", fl)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fc\n}\n\nfunc (f *defaultFlagCategories) AddFlag(category string, fl Flag) {\n\tif _, ok := f.m[category]; !ok {\n\t\tf.m[category] = &defaultVisibleFlagCategory{name: category, m: map[string]Flag{}}\n\t}\n\n\tf.m[category].m[fl.String()] = fl\n}\n\nfunc (f *defaultFlagCategories) VisibleCategories() []VisibleFlagCategory {\n\tcatNames := []string{}\n\tfor name := range f.m {\n\t\tcatNames = append(catNames, name)\n\t}\n\n\tsort.Strings(catNames)\n\n\tret := make([]VisibleFlagCategory, len(catNames))\n\tfor i, name := range catNames {\n\t\tret[i] = f.m[name]\n\t}\n\n\treturn ret\n}\n\n// VisibleFlagCategory is a category containing flags.\ntype VisibleFlagCategory interface {\n\t// Name returns the category name string\n\tName() string\n\t// Flags returns a slice of VisibleFlag sorted by name\n\tFlags() []Flag\n}\n\ntype defaultVisibleFlagCategory struct {\n\tname string\n\tm    map[string]Flag\n}\n\nfunc (fc *defaultVisibleFlagCategory) Name() string {\n\treturn fc.name\n}\n\nfunc (fc *defaultVisibleFlagCategory) Flags() []Flag {\n\tvfNames := []string{}\n\tfor flName, fl := range fc.m {\n\t\tif vf, ok := fl.(VisibleFlag); ok {\n\t\t\tif vf.IsVisible() {\n\t\t\t\tvfNames = append(vfNames, flName)\n\t\t\t}\n\t\t}\n\t}\n\n\tsort.Strings(vfNames)\n\n\tret := make([]Flag, len(vfNames))\n\tfor i, flName := range vfNames {\n\t\tret[i] = fc.m[flName]\n\t}\n\n\treturn ret\n}\n"
        },
        {
          "name": "cli.go",
          "type": "blob",
          "size": 1.1640625,
          "content": "// Package cli provides a minimal framework for creating and organizing command line\n// Go applications. cli is designed to be easy to understand and write, the most simple\n// cli application can be written as follows:\n//\n//\tfunc main() {\n//\t\t(&cli.Command{}).Run(context.Background(), os.Args)\n//\t}\n//\n// Of course this application does not do much, so let's make this an actual application:\n//\n//\tfunc main() {\n//\t\tcmd := &cli.Command{\n//\t  \t\tName: \"greet\",\n//\t  \t\tUsage: \"say a greeting\",\n//\t  \t\tAction: func(c *cli.Context) error {\n//\t  \t\t\tfmt.Println(\"Greetings\")\n//\t  \t\t\treturn nil\n//\t  \t\t},\n//\t\t}\n//\n//\t\tcmd.Run(context.Background(), os.Args)\n//\t}\npackage cli\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n)\n\nvar isTracingOn = os.Getenv(\"URFAVE_CLI_TRACING\") == \"on\"\n\nfunc tracef(format string, a ...any) {\n\tif !isTracingOn {\n\t\treturn\n\t}\n\n\tif !strings.HasSuffix(format, \"\\n\") {\n\t\tformat = format + \"\\n\"\n\t}\n\n\tpc, file, line, _ := runtime.Caller(1)\n\tcf := runtime.FuncForPC(pc)\n\n\tfmt.Fprintf(\n\t\tos.Stderr,\n\t\tstrings.Join([]string{\n\t\t\t\"## URFAVE CLI TRACE \",\n\t\t\tfile,\n\t\t\t\":\",\n\t\t\tfmt.Sprintf(\"%v\", line),\n\t\t\t\" \",\n\t\t\tfmt.Sprintf(\"(%s)\", cf.Name()),\n\t\t\t\" \",\n\t\t\tformat,\n\t\t}, \"\"),\n\t\ta...,\n\t)\n}\n"
        },
        {
          "name": "cli_test.go",
          "type": "blob",
          "size": 1.1875,
          "content": "package cli\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc expectFileContent(t *testing.T, file, got string) {\n\tdata, err := os.ReadFile(file)\n\t// Ignore windows line endings\n\tdata = bytes.ReplaceAll(data, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n\n\tr := require.New(t)\n\tr.NoError(err)\n\tr.Equal(got, string(data))\n}\n\nfunc buildTestContext(t *testing.T) context.Context {\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tt.Cleanup(cancel)\n\n\treturn ctx\n}\n\nfunc TestTracing(t *testing.T) {\n\tolderr := os.Stderr\n\toldtracing := isTracingOn\n\tdefer func() {\n\t\tos.Stderr = olderr\n\t\tisTracingOn = oldtracing\n\t}()\n\n\tfile, err := os.CreateTemp(os.TempDir(), \"cli*\")\n\tassert.NoError(t, err)\n\tos.Stderr = file\n\n\t// Note we cant really set the env since the isTracingOn\n\t// is read at module startup so any changes mid code\n\t// wont take effect\n\tisTracingOn = false\n\ttracef(\"something\")\n\n\tisTracingOn = true\n\ttracef(\"foothing\")\n\n\tassert.NoError(t, file.Close())\n\n\tb, err := os.ReadFile(file.Name())\n\tassert.NoError(t, err)\n\n\tassert.Contains(t, string(b), \"foothing\")\n\tassert.NotContains(t, string(b), \"something\")\n}\n"
        },
        {
          "name": "command.go",
          "type": "blob",
          "size": 34.283203125,
          "content": "package cli\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"slices\"\n\t\"sort\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nconst (\n\t// ignoreFlagPrefix is to ignore test flags when adding flags from other packages\n\tignoreFlagPrefix = \"test.\"\n\n\tcommandContextKey = contextKey(\"cli.context\")\n)\n\ntype contextKey string\n\n// Command contains everything needed to run an application that\n// accepts a string slice of arguments such as os.Args. A given\n// Command may contain Flags and sub-commands in Commands.\ntype Command struct {\n\t// The name of the command\n\tName string `json:\"name\"`\n\t// A list of aliases for the command\n\tAliases []string `json:\"aliases\"`\n\t// A short description of the usage of this command\n\tUsage string `json:\"usage\"`\n\t// Text to override the USAGE section of help\n\tUsageText string `json:\"usageText\"`\n\t// A short description of the arguments of this command\n\tArgsUsage string `json:\"argsUsage\"`\n\t// Version of the command\n\tVersion string `json:\"version\"`\n\t// Longer explanation of how the command works\n\tDescription string `json:\"description\"`\n\t// DefaultCommand is the (optional) name of a command\n\t// to run if no command names are passed as CLI arguments.\n\tDefaultCommand string `json:\"defaultCommand\"`\n\t// The category the command is part of\n\tCategory string `json:\"category\"`\n\t// List of child commands\n\tCommands []*Command `json:\"commands\"`\n\t// List of flags to parse\n\tFlags []Flag `json:\"flags\"`\n\t// Boolean to hide built-in help command and help flag\n\tHideHelp bool `json:\"hideHelp\"`\n\t// Ignored if HideHelp is true.\n\tHideHelpCommand bool `json:\"hideHelpCommand\"`\n\t// Boolean to hide built-in version flag and the VERSION section of help\n\tHideVersion bool `json:\"hideVersion\"`\n\t// Boolean to enable shell completion commands\n\tEnableShellCompletion bool `json:\"-\"`\n\t// Shell Completion generation command name\n\tShellCompletionCommandName string `json:\"-\"`\n\t// The function to call when checking for shell command completions\n\tShellComplete ShellCompleteFunc `json:\"-\"`\n\t// An action to execute before any subcommands are run, but after the context is ready\n\t// If a non-nil error is returned, no subcommands are run\n\tBefore BeforeFunc `json:\"-\"`\n\t// An action to execute after any subcommands are run, but after the subcommand has finished\n\t// It is run even if Action() panics\n\tAfter AfterFunc `json:\"-\"`\n\t// The function to call when this command is invoked\n\tAction ActionFunc `json:\"-\"`\n\t// Execute this function if the proper command cannot be found\n\tCommandNotFound CommandNotFoundFunc `json:\"-\"`\n\t// Execute this function if a usage error occurs.\n\tOnUsageError OnUsageErrorFunc `json:\"-\"`\n\t// Execute this function when an invalid flag is accessed from the context\n\tInvalidFlagAccessHandler InvalidFlagAccessFunc `json:\"-\"`\n\t// Boolean to hide this command from help or completion\n\tHidden bool `json:\"hidden\"`\n\t// List of all authors who contributed (string or fmt.Stringer)\n\t// TODO: ~string | fmt.Stringer when interface unions are available\n\tAuthors []any `json:\"authors\"`\n\t// Copyright of the binary if any\n\tCopyright string `json:\"copyright\"`\n\t// Reader reader to write input to (useful for tests)\n\tReader io.Reader `json:\"-\"`\n\t// Writer writer to write output to\n\tWriter io.Writer `json:\"-\"`\n\t// ErrWriter writes error output\n\tErrWriter io.Writer `json:\"-\"`\n\t// ExitErrHandler processes any error encountered while running an App before\n\t// it is returned to the caller. If no function is provided, HandleExitCoder\n\t// is used as the default behavior.\n\tExitErrHandler ExitErrHandlerFunc `json:\"-\"`\n\t// Other custom info\n\tMetadata map[string]interface{} `json:\"metadata\"`\n\t// Carries a function which returns app specific info.\n\tExtraInfo func() map[string]string `json:\"-\"`\n\t// CustomRootCommandHelpTemplate the text template for app help topic.\n\t// cli.go uses text/template to render templates. You can\n\t// render custom help text by setting this variable.\n\tCustomRootCommandHelpTemplate string `json:\"-\"`\n\t// SliceFlagSeparator is used to customize the separator for SliceFlag, the default is \",\"\n\tSliceFlagSeparator string `json:\"sliceFlagSeparator\"`\n\t// DisableSliceFlagSeparator is used to disable SliceFlagSeparator, the default is false\n\tDisableSliceFlagSeparator bool `json:\"disableSliceFlagSeparator\"`\n\t// Boolean to enable short-option handling so user can combine several\n\t// single-character bool arguments into one\n\t// i.e. foobar -o -v -> foobar -ov\n\tUseShortOptionHandling bool `json:\"useShortOptionHandling\"`\n\t// Enable suggestions for commands and flags\n\tSuggest bool `json:\"suggest\"`\n\t// Allows global flags set by libraries which use flag.XXXVar(...) directly\n\t// to be parsed through this library\n\tAllowExtFlags bool `json:\"allowExtFlags\"`\n\t// Treat all flags as normal arguments if true\n\tSkipFlagParsing bool `json:\"skipFlagParsing\"`\n\t// CustomHelpTemplate the text template for the command help topic.\n\t// cli.go uses text/template to render templates. You can\n\t// render custom help text by setting this variable.\n\tCustomHelpTemplate string `json:\"-\"`\n\t// Use longest prefix match for commands\n\tPrefixMatchCommands bool `json:\"prefixMatchCommands\"`\n\t// Custom suggest command for matching\n\tSuggestCommandFunc SuggestCommandFunc `json:\"-\"`\n\t// Flag exclusion group\n\tMutuallyExclusiveFlags []MutuallyExclusiveFlags `json:\"mutuallyExclusiveFlags\"`\n\t// Arguments to parse for this command\n\tArguments []Argument `json:\"arguments\"`\n\t// Whether to read arguments from stdin\n\t// applicable to root command only\n\tReadArgsFromStdin bool `json:\"readArgsFromStdin\"`\n\n\t// categories contains the categorized commands and is populated on app startup\n\tcategories CommandCategories\n\t// flagCategories contains the categorized flags and is populated on app startup\n\tflagCategories FlagCategories\n\t// flags that have been applied in current parse\n\tappliedFlags []Flag\n\t// The parent of this command. This value will be nil for the\n\t// command at the root of the graph.\n\tparent *Command\n\t// the flag.FlagSet for this command\n\tflagSet *flag.FlagSet\n\t// parsed args\n\tparsedArgs Args\n\t// track state of error handling\n\tisInError bool\n\t// track state of defaults\n\tdidSetupDefaults bool\n\t// whether in shell completion mode\n\tshellCompletion bool\n}\n\n// FullName returns the full name of the command.\n// For commands with parents this ensures that the parent commands\n// are part of the command path.\nfunc (cmd *Command) FullName() string {\n\tnamePath := []string{}\n\n\tif cmd.parent != nil {\n\t\tnamePath = append(namePath, cmd.parent.FullName())\n\t}\n\n\treturn strings.Join(append(namePath, cmd.Name), \" \")\n}\n\nfunc (cmd *Command) Command(name string) *Command {\n\tfor _, subCmd := range cmd.Commands {\n\t\tif subCmd.HasName(name) {\n\t\t\treturn subCmd\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (cmd *Command) setupDefaults(osArgs []string) {\n\tif cmd.didSetupDefaults {\n\t\ttracef(\"already did setup (cmd=%[1]q)\", cmd.Name)\n\t\treturn\n\t}\n\n\tcmd.didSetupDefaults = true\n\n\tisRoot := cmd.parent == nil\n\ttracef(\"isRoot? %[1]v (cmd=%[2]q)\", isRoot, cmd.Name)\n\n\tif cmd.ShellComplete == nil {\n\t\ttracef(\"setting default ShellComplete (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.ShellComplete = DefaultCompleteWithFlags\n\t}\n\n\tif cmd.Name == \"\" && isRoot {\n\t\tname := filepath.Base(osArgs[0])\n\t\ttracef(\"setting cmd.Name from first arg basename (cmd=%[1]q)\", name)\n\t\tcmd.Name = name\n\t}\n\n\tif cmd.Usage == \"\" && isRoot {\n\t\ttracef(\"setting default Usage (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.Usage = \"A new cli application\"\n\t}\n\n\tif cmd.Version == \"\" {\n\t\ttracef(\"setting HideVersion=true due to empty Version (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.HideVersion = true\n\t}\n\n\tif cmd.Action == nil {\n\t\ttracef(\"setting default Action as help command action (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.Action = helpCommandAction\n\t}\n\n\tif cmd.Reader == nil {\n\t\ttracef(\"setting default Reader as os.Stdin (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.Reader = os.Stdin\n\t}\n\n\tif cmd.Writer == nil {\n\t\ttracef(\"setting default Writer as os.Stdout (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.Writer = os.Stdout\n\t}\n\n\tif cmd.ErrWriter == nil {\n\t\ttracef(\"setting default ErrWriter as os.Stderr (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.ErrWriter = os.Stderr\n\t}\n\n\tif cmd.AllowExtFlags {\n\t\ttracef(\"visiting all flags given AllowExtFlags=true (cmd=%[1]q)\", cmd.Name)\n\t\t// add global flags added by other packages\n\t\tflag.VisitAll(func(f *flag.Flag) {\n\t\t\t// skip test flags\n\t\t\tif !strings.HasPrefix(f.Name, ignoreFlagPrefix) {\n\t\t\t\tcmd.Flags = append(cmd.Flags, &extFlag{f})\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, subCmd := range cmd.Commands {\n\t\ttracef(\"setting sub-command (cmd=%[1]q) parent as self (cmd=%[2]q)\", subCmd.Name, cmd.Name)\n\t\tsubCmd.parent = cmd\n\t}\n\n\tcmd.ensureHelp()\n\n\tif !cmd.HideVersion && isRoot {\n\t\ttracef(\"appending version flag (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.appendFlag(VersionFlag)\n\t}\n\n\tif cmd.PrefixMatchCommands && cmd.SuggestCommandFunc == nil {\n\t\ttracef(\"setting default SuggestCommandFunc (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.SuggestCommandFunc = suggestCommand\n\t}\n\n\tif cmd.EnableShellCompletion || cmd.Root().shellCompletion {\n\t\tcompletionCommand := buildCompletionCommand(cmd.Name)\n\n\t\tif cmd.ShellCompletionCommandName != \"\" {\n\t\t\ttracef(\n\t\t\t\t\"setting completion command name (%[1]q) from \"+\n\t\t\t\t\t\"cmd.ShellCompletionCommandName (cmd=%[2]q)\",\n\t\t\t\tcmd.ShellCompletionCommandName, cmd.Name,\n\t\t\t)\n\t\t\tcompletionCommand.Name = cmd.ShellCompletionCommandName\n\t\t}\n\n\t\ttracef(\"appending completionCommand (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.appendCommand(completionCommand)\n\t}\n\n\ttracef(\"setting command categories (cmd=%[1]q)\", cmd.Name)\n\tcmd.categories = newCommandCategories()\n\n\tfor _, subCmd := range cmd.Commands {\n\t\tcmd.categories.AddCommand(subCmd.Category, subCmd)\n\t}\n\n\ttracef(\"sorting command categories (cmd=%[1]q)\", cmd.Name)\n\tsort.Sort(cmd.categories.(*commandCategories))\n\n\ttracef(\"setting category on mutually exclusive flags (cmd=%[1]q)\", cmd.Name)\n\tfor _, grp := range cmd.MutuallyExclusiveFlags {\n\t\tgrp.propagateCategory()\n\t}\n\n\ttracef(\"setting flag categories (cmd=%[1]q)\", cmd.Name)\n\tcmd.flagCategories = newFlagCategoriesFromFlags(cmd.allFlags())\n\n\tif cmd.Metadata == nil {\n\t\ttracef(\"setting default Metadata (cmd=%[1]q)\", cmd.Name)\n\t\tcmd.Metadata = map[string]any{}\n\t}\n\n\tif len(cmd.SliceFlagSeparator) != 0 {\n\t\ttracef(\"setting defaultSliceFlagSeparator from cmd.SliceFlagSeparator (cmd=%[1]q)\", cmd.Name)\n\t\tdefaultSliceFlagSeparator = cmd.SliceFlagSeparator\n\t}\n\n\ttracef(\"setting disableSliceFlagSeparator from cmd.DisableSliceFlagSeparator (cmd=%[1]q)\", cmd.Name)\n\tdisableSliceFlagSeparator = cmd.DisableSliceFlagSeparator\n}\n\nfunc (cmd *Command) setupCommandGraph() {\n\ttracef(\"setting up command graph (cmd=%[1]q)\", cmd.Name)\n\n\tfor _, subCmd := range cmd.Commands {\n\t\tsubCmd.parent = cmd\n\t\tsubCmd.setupSubcommand()\n\t\tsubCmd.setupCommandGraph()\n\t}\n}\n\nfunc (cmd *Command) setupSubcommand() {\n\ttracef(\"setting up self as sub-command (cmd=%[1]q)\", cmd.Name)\n\n\tcmd.ensureHelp()\n\n\ttracef(\"setting command categories (cmd=%[1]q)\", cmd.Name)\n\tcmd.categories = newCommandCategories()\n\n\tfor _, subCmd := range cmd.Commands {\n\t\tcmd.categories.AddCommand(subCmd.Category, subCmd)\n\t}\n\n\ttracef(\"sorting command categories (cmd=%[1]q)\", cmd.Name)\n\tsort.Sort(cmd.categories.(*commandCategories))\n\n\ttracef(\"setting category on mutually exclusive flags (cmd=%[1]q)\", cmd.Name)\n\tfor _, grp := range cmd.MutuallyExclusiveFlags {\n\t\tgrp.propagateCategory()\n\t}\n\n\ttracef(\"setting flag categories (cmd=%[1]q)\", cmd.Name)\n\tcmd.flagCategories = newFlagCategoriesFromFlags(cmd.allFlags())\n}\n\nfunc (cmd *Command) hideHelp() bool {\n\ttracef(\"hide help (cmd=%[1]q)\", cmd.Name)\n\tfor c := cmd; c != nil; c = c.parent {\n\t\tif c.HideHelp {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (cmd *Command) ensureHelp() {\n\ttracef(\"ensuring help (cmd=%[1]q)\", cmd.Name)\n\n\thelpCommand := buildHelpCommand(true)\n\n\tif !cmd.hideHelp() {\n\t\tif cmd.Command(helpCommand.Name) == nil {\n\t\t\tif !cmd.HideHelpCommand {\n\t\t\t\ttracef(\"appending helpCommand (cmd=%[1]q)\", cmd.Name)\n\t\t\t\tcmd.appendCommand(helpCommand)\n\t\t\t}\n\t\t}\n\n\t\tif HelpFlag != nil {\n\t\t\ttracef(\"appending HelpFlag (cmd=%[1]q)\", cmd.Name)\n\t\t\tcmd.appendFlag(HelpFlag)\n\t\t}\n\t}\n}\n\nfunc (cmd *Command) parseArgsFromStdin() ([]string, error) {\n\ttype state int\n\tconst (\n\t\tstateSearchForToken  state = -1\n\t\tstateSearchForString state = 0\n\t)\n\n\tst := stateSearchForToken\n\tlinenum := 1\n\ttoken := \"\"\n\targs := []string{}\n\n\tbreader := bufio.NewReader(cmd.Reader)\n\nouter:\n\tfor {\n\t\tch, _, err := breader.ReadRune()\n\t\tif err == io.EOF {\n\t\t\tswitch st {\n\t\t\tcase stateSearchForToken:\n\t\t\t\tif token != \"--\" {\n\t\t\t\t\targs = append(args, token)\n\t\t\t\t}\n\t\t\tcase stateSearchForString:\n\t\t\t\t// make sure string is not empty\n\t\t\t\tfor _, t := range token {\n\t\t\t\t\tif !unicode.IsSpace(t) {\n\t\t\t\t\t\targs = append(args, token)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak outer\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tswitch st {\n\t\tcase stateSearchForToken:\n\t\t\tif unicode.IsSpace(ch) || ch == '\"' {\n\t\t\t\tif ch == '\\n' {\n\t\t\t\t\tlinenum++\n\t\t\t\t}\n\t\t\t\tif token != \"\" {\n\t\t\t\t\t// end the processing here\n\t\t\t\t\tif token == \"--\" {\n\t\t\t\t\t\tbreak outer\n\t\t\t\t\t}\n\t\t\t\t\targs = append(args, token)\n\t\t\t\t\ttoken = \"\"\n\t\t\t\t}\n\t\t\t\tif ch == '\"' {\n\t\t\t\t\tst = stateSearchForString\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttoken += string(ch)\n\t\tcase stateSearchForString:\n\t\t\tif ch != '\"' {\n\t\t\t\ttoken += string(ch)\n\t\t\t} else {\n\t\t\t\tif token != \"\" {\n\t\t\t\t\targs = append(args, token)\n\t\t\t\t\ttoken = \"\"\n\t\t\t\t}\n\t\t\t\t/*else {\n\t\t\t\t\t//TODO. Should we pass in empty strings ?\n\t\t\t\t}*/\n\t\t\t\tst = stateSearchForToken\n\t\t\t}\n\t\t}\n\t}\n\n\ttracef(\"parsed stdin args as %v (cmd=%[2]q)\", args, cmd.Name)\n\n\treturn args, nil\n}\n\n// Run is the entry point to the command graph. The positional\n// arguments are parsed according to the Flag and Command\n// definitions and the matching Action functions are run.\nfunc (cmd *Command) Run(ctx context.Context, osArgs []string) (deferErr error) {\n\ttracef(\"running with arguments %[1]q (cmd=%[2]q)\", osArgs, cmd.Name)\n\tcmd.setupDefaults(osArgs)\n\n\tif v, ok := ctx.Value(commandContextKey).(*Command); ok {\n\t\ttracef(\"setting parent (cmd=%[1]q) command from context.Context value (cmd=%[2]q)\", v.Name, cmd.Name)\n\t\tcmd.parent = v\n\t}\n\n\tif cmd.parent == nil {\n\t\tif cmd.ReadArgsFromStdin {\n\t\t\tif args, err := cmd.parseArgsFromStdin(); err != nil {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\tosArgs = append(osArgs, args...)\n\t\t\t}\n\t\t}\n\t\t// handle the completion flag separately from the flagset since\n\t\t// completion could be attempted after a flag, but before its value was put\n\t\t// on the command line. this causes the flagset to interpret the completion\n\t\t// flag name as the value of the flag before it which is undesirable\n\t\t// note that we can only do this because the shell autocomplete function\n\t\t// always appends the completion flag at the end of the command\n\t\ttracef(\"checking osArgs %v (cmd=%[2]q)\", osArgs, cmd.Name)\n\t\tcmd.shellCompletion, osArgs = checkShellCompleteFlag(cmd, osArgs)\n\n\t\ttracef(\"setting cmd.shellCompletion=%[1]v from checkShellCompleteFlag (cmd=%[2]q)\", cmd.shellCompletion && cmd.EnableShellCompletion, cmd.Name)\n\t\tcmd.shellCompletion = cmd.EnableShellCompletion && cmd.shellCompletion\n\t}\n\n\ttracef(\"using post-checkShellCompleteFlag arguments %[1]q (cmd=%[2]q)\", osArgs, cmd.Name)\n\n\ttracef(\"setting self as cmd in context (cmd=%[1]q)\", cmd.Name)\n\tctx = context.WithValue(ctx, commandContextKey, cmd)\n\n\tif cmd.parent == nil {\n\t\tcmd.setupCommandGraph()\n\t}\n\n\targs, err := cmd.parseFlags(&stringSliceArgs{v: osArgs})\n\n\ttracef(\"using post-parse arguments %[1]q (cmd=%[2]q)\", args, cmd.Name)\n\n\tif checkCompletions(ctx, cmd) {\n\t\treturn nil\n\t}\n\n\tif err != nil {\n\t\ttracef(\"setting deferErr from %[1]q (cmd=%[2]q)\", err, cmd.Name)\n\t\tdeferErr = err\n\n\t\tcmd.isInError = true\n\t\tif cmd.OnUsageError != nil {\n\t\t\terr = cmd.OnUsageError(ctx, cmd, err, cmd.parent != nil)\n\t\t\terr = cmd.handleExitCoder(ctx, err)\n\t\t\treturn err\n\t\t}\n\t\tfmt.Fprintf(cmd.Root().ErrWriter, \"Incorrect Usage: %s\\n\\n\", err.Error())\n\t\tif cmd.Suggest {\n\t\t\tif suggestion, err := cmd.suggestFlagFromError(err, \"\"); err == nil {\n\t\t\t\tfmt.Fprintf(cmd.Root().ErrWriter, \"%s\", suggestion)\n\t\t\t}\n\t\t}\n\t\tif !cmd.hideHelp() {\n\t\t\tif cmd.parent == nil {\n\t\t\t\ttracef(\"running ShowAppHelp\")\n\t\t\t\tif err := ShowAppHelp(cmd); err != nil {\n\t\t\t\t\ttracef(\"SILENTLY IGNORING ERROR running ShowAppHelp %[1]v (cmd=%[2]q)\", err, cmd.Name)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttracef(\"running ShowCommandHelp with %[1]q\", cmd.Name)\n\t\t\t\tif err := ShowCommandHelp(ctx, cmd, cmd.Name); err != nil {\n\t\t\t\t\ttracef(\"SILENTLY IGNORING ERROR running ShowCommandHelp with %[1]q %[2]v\", cmd.Name, err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn err\n\t}\n\n\tif cmd.checkHelp() {\n\t\treturn helpCommandAction(ctx, cmd)\n\t} else {\n\t\ttracef(\"no help is wanted (cmd=%[1]q)\", cmd.Name)\n\t}\n\n\tif cmd.parent == nil && !cmd.HideVersion && checkVersion(cmd) {\n\t\tShowVersion(cmd)\n\t\treturn nil\n\t}\n\n\tif cmd.After != nil && !cmd.Root().shellCompletion {\n\t\tdefer func() {\n\t\t\tif err := cmd.After(ctx, cmd); err != nil {\n\t\t\t\terr = cmd.handleExitCoder(ctx, err)\n\n\t\t\t\tif deferErr != nil {\n\t\t\t\t\tdeferErr = newMultiError(deferErr, err)\n\t\t\t\t} else {\n\t\t\t\t\tdeferErr = err\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tfor _, grp := range cmd.MutuallyExclusiveFlags {\n\t\tif err := grp.check(cmd); err != nil {\n\t\t\t_ = ShowSubcommandHelp(cmd)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar subCmd *Command\n\tif args.Present() {\n\t\ttracef(\"checking positional args %[1]q (cmd=%[2]q)\", args, cmd.Name)\n\n\t\tname := args.First()\n\n\t\ttracef(\"using first positional argument as sub-command name=%[1]q (cmd=%[2]q)\", name, cmd.Name)\n\n\t\tif cmd.SuggestCommandFunc != nil {\n\t\t\tname = cmd.SuggestCommandFunc(cmd.Commands, name)\n\t\t}\n\t\tsubCmd = cmd.Command(name)\n\t\tif subCmd == nil {\n\t\t\thasDefault := cmd.DefaultCommand != \"\"\n\t\t\tisFlagName := checkStringSliceIncludes(name, cmd.FlagNames())\n\n\t\t\tif hasDefault {\n\t\t\t\ttracef(\"using default command=%[1]q (cmd=%[2]q)\", cmd.DefaultCommand, cmd.Name)\n\t\t\t}\n\n\t\t\tif isFlagName || hasDefault {\n\t\t\t\targsWithDefault := cmd.argsWithDefaultCommand(args)\n\t\t\t\ttracef(\"using default command args=%[1]q (cmd=%[2]q)\", argsWithDefault, cmd.Name)\n\t\t\t\tif !reflect.DeepEqual(args, argsWithDefault) {\n\t\t\t\t\tsubCmd = cmd.Command(argsWithDefault.First())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if cmd.parent == nil && cmd.DefaultCommand != \"\" {\n\t\ttracef(\"no positional args present; checking default command %[1]q (cmd=%[2]q)\", cmd.DefaultCommand, cmd.Name)\n\n\t\tif dc := cmd.Command(cmd.DefaultCommand); dc != cmd {\n\t\t\tsubCmd = dc\n\t\t}\n\t}\n\n\t// If a subcommand has been resolved, let it handle the remaining execution.\n\tif subCmd != nil {\n\t\ttracef(\"running sub-command %[1]q with arguments %[2]q (cmd=%[3]q)\", subCmd.Name, cmd.Args(), cmd.Name)\n\t\treturn subCmd.Run(ctx, cmd.Args().Slice())\n\t}\n\n\t// This code path is the innermost command execution. Here we actually\n\t// perform the command action.\n\t//\n\t// First, resolve the chain of nested commands up to the parent.\n\tvar cmdChain []*Command\n\tfor p := cmd; p != nil; p = p.parent {\n\t\tcmdChain = append(cmdChain, p)\n\t}\n\tslices.Reverse(cmdChain)\n\n\t// Run Before actions in order.\n\tfor _, cmd := range cmdChain {\n\t\tif cmd.Before == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif bctx, err := cmd.Before(ctx, cmd); err != nil {\n\t\t\tdeferErr = cmd.handleExitCoder(ctx, err)\n\t\t\treturn deferErr\n\t\t} else if bctx != nil {\n\t\t\tctx = bctx\n\t\t}\n\t}\n\n\t// Run flag actions in order.\n\t// These take a context, so this has to happen after Before actions.\n\tfor _, cmd := range cmdChain {\n\t\ttracef(\"running flag actions (cmd=%[1]q)\", cmd.Name)\n\t\tif err := cmd.runFlagActions(ctx); err != nil {\n\t\t\tdeferErr = cmd.handleExitCoder(ctx, err)\n\t\t\treturn deferErr\n\t\t}\n\t}\n\n\t// Run the command action.\n\tif cmd.Action == nil {\n\t\tcmd.Action = helpCommandAction\n\t} else {\n\t\tif err := cmd.checkAllRequiredFlags(); err != nil {\n\t\t\tcmd.isInError = true\n\t\t\t_ = ShowSubcommandHelp(cmd)\n\t\t\treturn err\n\t\t}\n\n\t\tif len(cmd.Arguments) > 0 {\n\t\t\trargs := cmd.Args().Slice()\n\t\t\ttracef(\"calling argparse with %[1]v\", rargs)\n\t\t\tfor _, arg := range cmd.Arguments {\n\t\t\t\tvar err error\n\t\t\t\trargs, err = arg.Parse(rargs)\n\t\t\t\tif err != nil {\n\t\t\t\t\ttracef(\"calling with %[1]v (cmd=%[2]q)\", err, cmd.Name)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tcmd.parsedArgs = &stringSliceArgs{v: rargs}\n\t\t}\n\t}\n\n\tif err := cmd.Action(ctx, cmd); err != nil {\n\t\ttracef(\"calling handleExitCoder with %[1]v (cmd=%[2]q)\", err, cmd.Name)\n\t\tdeferErr = cmd.handleExitCoder(ctx, err)\n\t}\n\n\ttracef(\"returning deferErr (cmd=%[1]q) %[2]q\", cmd.Name, deferErr)\n\treturn deferErr\n}\n\nfunc (cmd *Command) checkHelp() bool {\n\ttracef(\"checking if help is wanted (cmd=%[1]q)\", cmd.Name)\n\n\tif HelpFlag == nil {\n\t\treturn false\n\t}\n\n\tfor _, name := range HelpFlag.Names() {\n\t\tif cmd.Bool(name) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (cmd *Command) newFlagSet() (*flag.FlagSet, error) {\n\tallFlags := cmd.allFlags()\n\n\tcmd.appliedFlags = append(cmd.appliedFlags, allFlags...)\n\n\ttracef(\"making new flag set (cmd=%[1]q)\", cmd.Name)\n\n\treturn newFlagSet(cmd.Name, allFlags)\n}\n\nfunc (cmd *Command) allFlags() []Flag {\n\tvar flags []Flag\n\tflags = append(flags, cmd.Flags...)\n\tfor _, grpf := range cmd.MutuallyExclusiveFlags {\n\t\tfor _, f1 := range grpf.Flags {\n\t\t\tflags = append(flags, f1...)\n\t\t}\n\t}\n\treturn flags\n}\n\n// useShortOptionHandling traverses Lineage() for *any* ancestors\n// with UseShortOptionHandling\nfunc (cmd *Command) useShortOptionHandling() bool {\n\tfor _, pCmd := range cmd.Lineage() {\n\t\tif pCmd.UseShortOptionHandling {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (cmd *Command) suggestFlagFromError(err error, commandName string) (string, error) {\n\tfl, parseErr := flagFromError(err)\n\tif parseErr != nil {\n\t\treturn \"\", err\n\t}\n\n\tflags := cmd.Flags\n\thideHelp := cmd.hideHelp()\n\n\tif commandName != \"\" {\n\t\tsubCmd := cmd.Command(commandName)\n\t\tif subCmd == nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tflags = subCmd.Flags\n\t\thideHelp = hideHelp || subCmd.HideHelp\n\t}\n\n\tsuggestion := SuggestFlag(flags, fl, hideHelp)\n\tif len(suggestion) == 0 {\n\t\treturn \"\", err\n\t}\n\n\treturn fmt.Sprintf(SuggestDidYouMeanTemplate, suggestion) + \"\\n\\n\", nil\n}\n\nfunc (cmd *Command) parseFlags(args Args) (Args, error) {\n\ttracef(\"parsing flags from arguments %[1]q (cmd=%[2]q)\", args, cmd.Name)\n\n\tcmd.parsedArgs = nil\n\tif v, err := cmd.newFlagSet(); err != nil {\n\t\treturn args, err\n\t} else {\n\t\tcmd.flagSet = v\n\t}\n\n\tif cmd.SkipFlagParsing {\n\t\ttracef(\"skipping flag parsing (cmd=%[1]q)\", cmd.Name)\n\n\t\treturn cmd.Args(), cmd.flagSet.Parse(append([]string{\"--\"}, args.Tail()...))\n\t}\n\n\ttracef(\"walking command lineage for persistent flags (cmd=%[1]q)\", cmd.Name)\n\n\tfor pCmd := cmd.parent; pCmd != nil; pCmd = pCmd.parent {\n\t\ttracef(\n\t\t\t\"checking ancestor command=%[1]q for persistent flags (cmd=%[2]q)\",\n\t\t\tpCmd.Name, cmd.Name,\n\t\t)\n\n\t\tfor _, fl := range pCmd.Flags {\n\t\t\tflNames := fl.Names()\n\n\t\t\tpfl, ok := fl.(LocalFlag)\n\t\t\tif !ok || pfl.IsLocal() {\n\t\t\t\ttracef(\"skipping non-persistent flag %[1]q (cmd=%[2]q)\", flNames, cmd.Name)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttracef(\n\t\t\t\t\"checking for applying persistent flag=%[1]q pCmd=%[2]q (cmd=%[3]q)\",\n\t\t\t\tflNames, pCmd.Name, cmd.Name,\n\t\t\t)\n\n\t\t\tapplyPersistentFlag := true\n\n\t\t\tcmd.flagSet.VisitAll(func(f *flag.Flag) {\n\t\t\t\tfor _, name := range flNames {\n\t\t\t\t\tif name == f.Name {\n\t\t\t\t\t\tapplyPersistentFlag = false\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif !applyPersistentFlag {\n\t\t\t\ttracef(\"not applying as persistent flag=%[1]q (cmd=%[2]q)\", flNames, cmd.Name)\n\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttracef(\"applying as persistent flag=%[1]q (cmd=%[2]q)\", flNames, cmd.Name)\n\n\t\t\tif err := fl.Apply(cmd.flagSet); err != nil {\n\t\t\t\treturn cmd.Args(), err\n\t\t\t}\n\n\t\t\ttracef(\"appending to applied flags flag=%[1]q (cmd=%[2]q)\", flNames, cmd.Name)\n\t\t\tcmd.appliedFlags = append(cmd.appliedFlags, fl)\n\t\t}\n\t}\n\n\ttracef(\"parsing flags iteratively tail=%[1]q (cmd=%[2]q)\", args.Tail(), cmd.Name)\n\tdefer tracef(\"done parsing flags (cmd=%[1]q)\", cmd.Name)\n\n\trargs := args.Tail()\n\tposArgs := []string{}\n\tfor {\n\t\ttracef(\"rearrange:1 (cmd=%[1]q) %[2]q\", cmd.Name, rargs)\n\t\tfor {\n\t\t\ttracef(\"rearrange:2 (cmd=%[1]q) %[2]q %[3]q\", cmd.Name, posArgs, rargs)\n\n\t\t\t// no more args to parse. Break out of inner loop\n\t\t\tif len(rargs) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif strings.TrimSpace(rargs[0]) == \"\" {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// stop parsing once we see a \"--\"\n\t\t\tif rargs[0] == \"--\" {\n\t\t\t\tposArgs = append(posArgs, rargs...)\n\t\t\t\tcmd.parsedArgs = &stringSliceArgs{posArgs}\n\t\t\t\treturn cmd.parsedArgs, nil\n\t\t\t}\n\n\t\t\t// let flagset parse this\n\t\t\tif rargs[0][0] == '-' {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\ttracef(\"rearrange-3 (cmd=%[1]q) check %[2]q\", cmd.Name, rargs[0])\n\n\t\t\t// if there is a command by that name let the command handle the\n\t\t\t// rest of the parsing\n\t\t\tif cmd.Command(rargs[0]) != nil {\n\t\t\t\tposArgs = append(posArgs, rargs...)\n\t\t\t\tcmd.parsedArgs = &stringSliceArgs{posArgs}\n\t\t\t\treturn cmd.parsedArgs, nil\n\t\t\t}\n\n\t\t\tposArgs = append(posArgs, rargs[0])\n\n\t\t\t// if this is the sole argument then\n\t\t\t// break from inner loop\n\t\t\tif len(rargs) == 1 {\n\t\t\t\trargs = []string{}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\trargs = rargs[1:]\n\t\t}\n\t\tif err := parseIter(cmd.flagSet, cmd, rargs, cmd.Root().shellCompletion); err != nil {\n\t\t\tposArgs = append(posArgs, cmd.flagSet.Args()...)\n\t\t\ttracef(\"returning-1 (cmd=%[1]q) args %[2]q\", cmd.Name, posArgs)\n\t\t\tcmd.parsedArgs = &stringSliceArgs{posArgs}\n\t\t\treturn cmd.parsedArgs, err\n\t\t}\n\t\ttracef(\"rearrange-4 (cmd=%[1]q) check %[2]q\", cmd.Name, cmd.flagSet.Args())\n\t\trargs = cmd.flagSet.Args()\n\t\tif len(rargs) == 0 || strings.TrimSpace(rargs[0]) == \"\" || rargs[0] == \"-\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tposArgs = append(posArgs, cmd.flagSet.Args()...)\n\ttracef(\"returning-2 (cmd=%[1]q) args %[2]q\", cmd.Name, posArgs)\n\tcmd.parsedArgs = &stringSliceArgs{posArgs}\n\treturn cmd.parsedArgs, nil\n}\n\n// Names returns the names including short names and aliases.\nfunc (cmd *Command) Names() []string {\n\treturn append([]string{cmd.Name}, cmd.Aliases...)\n}\n\n// HasName returns true if Command.Name matches given name\nfunc (cmd *Command) HasName(name string) bool {\n\tfor _, n := range cmd.Names() {\n\t\tif n == name {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// VisibleCategories returns a slice of categories and commands that are\n// Hidden=false\nfunc (cmd *Command) VisibleCategories() []CommandCategory {\n\tret := []CommandCategory{}\n\tfor _, category := range cmd.categories.Categories() {\n\t\tif visible := func() CommandCategory {\n\t\t\tif len(category.VisibleCommands()) > 0 {\n\t\t\t\treturn category\n\t\t\t}\n\t\t\treturn nil\n\t\t}(); visible != nil {\n\t\t\tret = append(ret, visible)\n\t\t}\n\t}\n\treturn ret\n}\n\n// VisibleCommands returns a slice of the Commands with Hidden=false\nfunc (cmd *Command) VisibleCommands() []*Command {\n\tvar ret []*Command\n\tfor _, command := range cmd.Commands {\n\t\tif command.Hidden || command.Name == helpName {\n\t\t\tcontinue\n\t\t}\n\t\tret = append(ret, command)\n\t}\n\treturn ret\n}\n\n// VisibleFlagCategories returns a slice containing all the visible flag categories with the flags they contain\nfunc (cmd *Command) VisibleFlagCategories() []VisibleFlagCategory {\n\tif cmd.flagCategories == nil {\n\t\tcmd.flagCategories = newFlagCategoriesFromFlags(cmd.allFlags())\n\t}\n\treturn cmd.flagCategories.VisibleCategories()\n}\n\n// VisibleFlags returns a slice of the Flags with Hidden=false\nfunc (cmd *Command) VisibleFlags() []Flag {\n\treturn visibleFlags(cmd.allFlags())\n}\n\nfunc (cmd *Command) appendFlag(fl Flag) {\n\tif !hasFlag(cmd.Flags, fl) {\n\t\tcmd.Flags = append(cmd.Flags, fl)\n\t}\n}\n\n// VisiblePersistentFlags returns a slice of [LocalFlag] with Persistent=true and Hidden=false.\nfunc (cmd *Command) VisiblePersistentFlags() []Flag {\n\tvar flags []Flag\n\tfor _, fl := range cmd.Root().Flags {\n\t\tpfl, ok := fl.(LocalFlag)\n\t\tif !ok || pfl.IsLocal() {\n\t\t\tcontinue\n\t\t}\n\t\tflags = append(flags, fl)\n\t}\n\treturn visibleFlags(flags)\n}\n\nfunc (cmd *Command) appendCommand(aCmd *Command) {\n\tif !hasCommand(cmd.Commands, aCmd) {\n\t\taCmd.parent = cmd\n\t\tcmd.Commands = append(cmd.Commands, aCmd)\n\t}\n}\n\nfunc (cmd *Command) handleExitCoder(ctx context.Context, err error) error {\n\tif cmd.parent != nil {\n\t\treturn cmd.parent.handleExitCoder(ctx, err)\n\t}\n\n\tif cmd.ExitErrHandler != nil {\n\t\tcmd.ExitErrHandler(ctx, cmd, err)\n\t\treturn err\n\t}\n\n\tHandleExitCoder(err)\n\treturn err\n}\n\nfunc (cmd *Command) argsWithDefaultCommand(oldArgs Args) Args {\n\tif cmd.DefaultCommand != \"\" {\n\t\trawArgs := append([]string{cmd.DefaultCommand}, oldArgs.Slice()...)\n\t\tnewArgs := &stringSliceArgs{v: rawArgs}\n\n\t\treturn newArgs\n\t}\n\n\treturn oldArgs\n}\n\n// Root returns the Command at the root of the graph\nfunc (cmd *Command) Root() *Command {\n\tif cmd.parent == nil {\n\t\treturn cmd\n\t}\n\n\treturn cmd.parent.Root()\n}\n\nfunc (cmd *Command) lookupFlag(name string) Flag {\n\tfor _, pCmd := range cmd.Lineage() {\n\t\tfor _, f := range pCmd.Flags {\n\t\t\tfor _, n := range f.Names() {\n\t\t\t\tif n == name {\n\t\t\t\t\ttracef(\"flag found for name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\t\t\t\t\treturn f\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttracef(\"flag NOT found for name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n\nfunc (cmd *Command) lookupFlagSet(name string) *flag.FlagSet {\n\tfor _, pCmd := range cmd.Lineage() {\n\t\tif pCmd.flagSet == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif f := pCmd.flagSet.Lookup(name); f != nil {\n\t\t\ttracef(\"matching flag set found for name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\t\t\treturn pCmd.flagSet\n\t\t}\n\t}\n\n\ttracef(\"matching flag set NOT found for name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\tcmd.onInvalidFlag(context.TODO(), name)\n\treturn nil\n}\n\nfunc (cmd *Command) checkRequiredFlag(f Flag) (bool, string) {\n\tif rf, ok := f.(RequiredFlag); ok && rf.IsRequired() {\n\t\tflagPresent := false\n\t\tflagName := \"\"\n\n\t\tfor _, key := range f.Names() {\n\t\t\t// use the first name to return since that is the\n\t\t\t// primary flag name\n\t\t\tif flagName == \"\" {\n\t\t\t\tflagName = key\n\t\t\t}\n\n\t\t\tif cmd.IsSet(strings.TrimSpace(key)) {\n\t\t\t\tflagPresent = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !flagPresent && flagName != \"\" {\n\t\t\treturn false, flagName\n\t\t}\n\t}\n\treturn true, \"\"\n}\n\nfunc (cmd *Command) checkAllRequiredFlags() requiredFlagsErr {\n\tfor pCmd := cmd; pCmd != nil; pCmd = pCmd.parent {\n\t\tif err := pCmd.checkRequiredFlags(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (cmd *Command) checkRequiredFlags() requiredFlagsErr {\n\ttracef(\"checking for required flags (cmd=%[1]q)\", cmd.Name)\n\n\tmissingFlags := []string{}\n\n\tfor _, f := range cmd.appliedFlags {\n\t\tif ok, name := cmd.checkRequiredFlag(f); !ok {\n\t\t\tmissingFlags = append(missingFlags, name)\n\t\t}\n\t}\n\n\tif len(missingFlags) != 0 {\n\t\ttracef(\"found missing required flags %[1]q (cmd=%[2]q)\", missingFlags, cmd.Name)\n\n\t\treturn &errRequiredFlags{missingFlags: missingFlags}\n\t}\n\n\ttracef(\"all required flags set (cmd=%[1]q)\", cmd.Name)\n\n\treturn nil\n}\n\nfunc (cmd *Command) onInvalidFlag(ctx context.Context, name string) {\n\tfor cmd != nil {\n\t\tif cmd.InvalidFlagAccessHandler != nil {\n\t\t\tcmd.InvalidFlagAccessHandler(ctx, cmd, name)\n\t\t\tbreak\n\t\t}\n\t\tcmd = cmd.parent\n\t}\n}\n\n// NumFlags returns the number of flags set\nfunc (cmd *Command) NumFlags() int {\n\treturn cmd.flagSet.NFlag()\n}\n\n// Set sets a context flag to a value.\nfunc (cmd *Command) Set(name, value string) error {\n\tif fs := cmd.lookupFlagSet(name); fs != nil {\n\t\treturn fs.Set(name, value)\n\t}\n\n\treturn fmt.Errorf(\"no such flag -%s\", name)\n}\n\n// IsSet determines if the flag was actually set\nfunc (cmd *Command) IsSet(name string) bool {\n\tflSet := cmd.lookupFlagSet(name)\n\n\tif flSet == nil {\n\t\treturn false\n\t}\n\n\tisSet := false\n\n\tflSet.Visit(func(f *flag.Flag) {\n\t\tif f.Name == name {\n\t\t\tisSet = true\n\t\t}\n\t})\n\n\tif isSet {\n\t\ttracef(\"flag with name %[1]q found via flag set lookup (cmd=%[2]q)\", name, cmd.Name)\n\t\treturn true\n\t}\n\n\tfl := cmd.lookupFlag(name)\n\tif fl == nil {\n\t\ttracef(\"flag with name %[1]q NOT found; assuming not set (cmd=%[2]q)\", name, cmd.Name)\n\t\treturn false\n\t}\n\n\tisSet = fl.IsSet()\n\tif isSet {\n\t\ttracef(\"flag with name %[1]q is set (cmd=%[2]q)\", name, cmd.Name)\n\t} else {\n\t\ttracef(\"flag with name %[1]q is NOT set (cmd=%[2]q)\", name, cmd.Name)\n\t}\n\n\treturn isSet\n}\n\n// LocalFlagNames returns a slice of flag names used in this\n// command.\nfunc (cmd *Command) LocalFlagNames() []string {\n\tnames := []string{}\n\n\tcmd.flagSet.Visit(makeFlagNameVisitor(&names))\n\n\t// Check the flags which have been set via env or file\n\tfor _, f := range cmd.Flags {\n\t\tif f.IsSet() {\n\t\t\tnames = append(names, f.Names()...)\n\t\t}\n\t}\n\n\t// Sort out the duplicates since flag could be set via multiple\n\t// paths\n\tm := map[string]struct{}{}\n\tuniqNames := []string{}\n\n\tfor _, name := range names {\n\t\tif _, ok := m[name]; !ok {\n\t\t\tm[name] = struct{}{}\n\t\t\tuniqNames = append(uniqNames, name)\n\t\t}\n\t}\n\n\treturn uniqNames\n}\n\n// FlagNames returns a slice of flag names used by the this command\n// and all of its parent commands.\nfunc (cmd *Command) FlagNames() []string {\n\tnames := cmd.LocalFlagNames()\n\n\tif cmd.parent != nil {\n\t\tnames = append(cmd.parent.FlagNames(), names...)\n\t}\n\n\treturn names\n}\n\n// Lineage returns *this* command and all of its ancestor commands\n// in order from child to parent\nfunc (cmd *Command) Lineage() []*Command {\n\tlineage := []*Command{cmd}\n\n\tif cmd.parent != nil {\n\t\tlineage = append(lineage, cmd.parent.Lineage()...)\n\t}\n\n\treturn lineage\n}\n\n// Count returns the num of occurrences of this flag\nfunc (cmd *Command) Count(name string) int {\n\tif fs := cmd.lookupFlagSet(name); fs != nil {\n\t\tif cf, ok := fs.Lookup(name).Value.(Countable); ok {\n\t\t\treturn cf.Count()\n\t\t}\n\t}\n\treturn 0\n}\n\n// Value returns the value of the flag corresponding to `name`\nfunc (cmd *Command) Value(name string) interface{} {\n\tif fs := cmd.lookupFlagSet(name); fs != nil {\n\t\ttracef(\"value found for name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\t\treturn fs.Lookup(name).Value.(flag.Getter).Get()\n\t}\n\n\ttracef(\"value NOT found for name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n\n// Args returns the command line arguments associated with the\n// command.\nfunc (cmd *Command) Args() Args {\n\tif cmd.parsedArgs != nil {\n\t\treturn cmd.parsedArgs\n\t}\n\treturn &stringSliceArgs{v: cmd.flagSet.Args()}\n}\n\n// NArg returns the number of the command line arguments.\nfunc (cmd *Command) NArg() int {\n\treturn cmd.Args().Len()\n}\n\nfunc hasCommand(commands []*Command, command *Command) bool {\n\tfor _, existing := range commands {\n\t\tif command == existing {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (cmd *Command) runFlagActions(ctx context.Context) error {\n\tfor _, fl := range cmd.appliedFlags {\n\t\tisSet := false\n\n\t\t// check only local flagset for running local flag actions\n\t\tfor _, name := range fl.Names() {\n\t\t\tcmd.flagSet.Visit(func(f *flag.Flag) {\n\t\t\t\tif f.Name == name {\n\t\t\t\t\tisSet = true\n\t\t\t\t}\n\t\t\t})\n\t\t\tif isSet {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If the flag hasnt been set on cmd line then we need to further\n\t\t// check if it has been set via other means. If however it has\n\t\t// been set by other means but it is persistent(and not set via current cmd)\n\t\t// do not run the flag action\n\t\tif !isSet {\n\t\t\tif !fl.IsSet() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif pf, ok := fl.(LocalFlag); ok && !pf.IsLocal() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif af, ok := fl.(ActionableFlag); ok {\n\t\t\tif err := af.RunAction(ctx, cmd); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc checkStringSliceIncludes(want string, sSlice []string) bool {\n\tfound := false\n\tfor _, s := range sSlice {\n\t\tif want == s {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn found\n}\n\nfunc makeFlagNameVisitor(names *[]string) func(*flag.Flag) {\n\treturn func(f *flag.Flag) {\n\t\tnameParts := strings.Split(f.Name, \",\")\n\t\tname := strings.TrimSpace(nameParts[0])\n\n\t\tfor _, part := range nameParts {\n\t\t\tpart = strings.TrimSpace(part)\n\t\t\tif len(part) > len(name) {\n\t\t\t\tname = part\n\t\t\t}\n\t\t}\n\n\t\tif name != \"\" {\n\t\t\t*names = append(*names, name)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "command_test.go",
          "type": "blob",
          "size": 112.75390625,
          "content": "package cli\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/mail\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\tlastExitCode = 0\n\tfakeOsExiter = func(rc int) {\n\t\tlastExitCode = rc\n\t}\n\tfakeErrWriter = &bytes.Buffer{}\n)\n\nfunc init() {\n\tOsExiter = fakeOsExiter\n\tErrWriter = fakeErrWriter\n}\n\ntype opCounts struct {\n\tTotal, ShellComplete, OnUsageError, Before, CommandNotFound, Action, After, SubCommand int\n}\n\nfunc buildExtendedTestCommand() *Command {\n\tcmd := buildMinimalTestCommand()\n\tcmd.Name = \"greet\"\n\tcmd.Flags = []Flag{\n\t\t&StringFlag{\n\t\t\tName:      \"socket\",\n\t\t\tAliases:   []string{\"s\"},\n\t\t\tUsage:     \"some 'usage' text\",\n\t\t\tValue:     \"value\",\n\t\t\tTakesFile: true,\n\t\t},\n\t\t&StringFlag{Name: \"flag\", Aliases: []string{\"fl\", \"f\"}},\n\t\t&BoolFlag{\n\t\t\tName:    \"another-flag\",\n\t\t\tAliases: []string{\"b\"},\n\t\t\tUsage:   \"another usage text\",\n\t\t\tSources: EnvVars(\"EXAMPLE_VARIABLE_NAME\"),\n\t\t},\n\t\t&BoolFlag{\n\t\t\tName:   \"hidden-flag\",\n\t\t\tHidden: true,\n\t\t},\n\t}\n\tcmd.Commands = []*Command{{\n\t\tAliases: []string{\"c\"},\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName:      \"flag\",\n\t\t\t\tAliases:   []string{\"fl\", \"f\"},\n\t\t\t\tTakesFile: true,\n\t\t\t},\n\t\t\t&BoolFlag{\n\t\t\t\tName:    \"another-flag\",\n\t\t\t\tAliases: []string{\"b\"},\n\t\t\t\tUsage:   \"another usage text\",\n\t\t\t},\n\t\t},\n\t\tName:  \"config\",\n\t\tUsage: \"another usage test\",\n\t\tCommands: []*Command{{\n\t\t\tAliases: []string{\"s\", \"ss\"},\n\t\t\tFlags: []Flag{\n\t\t\t\t&StringFlag{Name: \"sub-flag\", Aliases: []string{\"sub-fl\", \"s\"}},\n\t\t\t\t&BoolFlag{\n\t\t\t\t\tName:    \"sub-command-flag\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"some usage text\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tName:  \"sub-config\",\n\t\t\tUsage: \"another usage test\",\n\t\t}},\n\t}, {\n\t\tAliases: []string{\"i\", \"in\"},\n\t\tName:    \"info\",\n\t\tUsage:   \"retrieve generic information\",\n\t}, {\n\t\tName: \"some-command\",\n\t}, {\n\t\tName:   \"hidden-command\",\n\t\tHidden: true,\n\t}, {\n\t\tAliases: []string{\"u\"},\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName:      \"flag\",\n\t\t\t\tAliases:   []string{\"fl\", \"f\"},\n\t\t\t\tTakesFile: true,\n\t\t\t},\n\t\t\t&BoolFlag{\n\t\t\t\tName:    \"another-flag\",\n\t\t\t\tAliases: []string{\"b\"},\n\t\t\t\tUsage:   \"another usage text\",\n\t\t\t},\n\t\t},\n\t\tName:  \"usage\",\n\t\tUsage: \"standard usage text\",\n\t\tUsageText: `\nUsage for the usage text\n- formatted:  Based on the specified ConfigMap and summon secrets.yml\n- list:       Inspect the environment for a specific process running on a Pod\n- for_effect: Compare 'namespace' environment with 'local'\n\n` + \"```\" + `\nfunc() { ... }\n` + \"```\" + `\n\nShould be a part of the same code block\n`,\n\t\tCommands: []*Command{{\n\t\t\tAliases: []string{\"su\"},\n\t\t\tFlags: []Flag{\n\t\t\t\t&BoolFlag{\n\t\t\t\t\tName:    \"sub-command-flag\",\n\t\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\t\tUsage:   \"some usage text\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tName:      \"sub-usage\",\n\t\t\tUsage:     \"standard usage text\",\n\t\t\tUsageText: \"Single line of UsageText\",\n\t\t}},\n\t}}\n\tcmd.UsageText = \"app [first_arg] [second_arg]\"\n\tcmd.Description = `Description of the application.`\n\tcmd.Usage = \"Some app\"\n\tcmd.Authors = []any{\n\t\t\"Harrison <harrison@lolwut.example.com>\",\n\t\t&mail.Address{Name: \"Oliver Allen\", Address: \"oliver@toyshop.com\"},\n\t}\n\n\treturn cmd\n}\n\nfunc TestCommandFlagParsing(t *testing.T) {\n\tcases := []struct {\n\t\ttestArgs               []string\n\t\tskipFlagParsing        bool\n\t\tuseShortOptionHandling bool\n\t\texpectedErr            string\n\t}{\n\t\t// Test normal \"not ignoring flags\" flow\n\t\t{testArgs: []string{\"test-cmd\", \"-break\", \"blah\", \"blah\"}, skipFlagParsing: false, useShortOptionHandling: false, expectedErr: \"flag provided but not defined: -break\"},\n\t\t{testArgs: []string{\"test-cmd\", \"blah\", \"blah\"}, skipFlagParsing: true, useShortOptionHandling: false},                                        // Test SkipFlagParsing without any args that look like flags\n\t\t{testArgs: []string{\"test-cmd\", \"blah\", \"-break\"}, skipFlagParsing: true, useShortOptionHandling: false},                                      // Test SkipFlagParsing with random flag arg\n\t\t{testArgs: []string{\"test-cmd\", \"blah\", \"-help\"}, skipFlagParsing: true, useShortOptionHandling: false},                                       // Test SkipFlagParsing with \"special\" help flag arg\n\t\t{testArgs: []string{\"test-cmd\", \"blah\", \"-h\"}, skipFlagParsing: false, useShortOptionHandling: true, expectedErr: \"No help topic for 'blah'\"}, // Test UseShortOptionHandling\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(strings.Join(c.testArgs, \" \"), func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tWriter:          io.Discard,\n\t\t\t\tName:            \"test-cmd\",\n\t\t\t\tAliases:         []string{\"tc\"},\n\t\t\t\tUsage:           \"this is for testing\",\n\t\t\t\tDescription:     \"testing\",\n\t\t\t\tAction:          func(context.Context, *Command) error { return nil },\n\t\t\t\tSkipFlagParsing: c.skipFlagParsing,\n\t\t\t}\n\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\t\t\tt.Cleanup(cancel)\n\n\t\t\tr := require.New(t)\n\n\t\t\terr := cmd.Run(ctx, c.testArgs)\n\n\t\t\tif c.expectedErr != \"\" {\n\t\t\t\tr.EqualError(err, c.expectedErr)\n\t\t\t} else {\n\t\t\t\tr.NoError(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseAndRunShortOpts(t *testing.T) {\n\ttestCases := []struct {\n\t\ttestArgs     *stringSliceArgs\n\t\texpectedErr  string\n\t\texpectedArgs Args\n\t}{\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-a\"}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-c\", \"arg1\", \"arg2\"}}, expectedArgs: &stringSliceArgs{v: []string{\"arg1\", \"arg2\"}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-f\"}}, expectedArgs: &stringSliceArgs{v: []string{}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-ac\", \"--fgh\"}}, expectedArgs: &stringSliceArgs{v: []string{}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-af\"}}, expectedArgs: &stringSliceArgs{v: []string{}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-cf\"}}, expectedArgs: &stringSliceArgs{v: []string{}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-acf\"}}, expectedArgs: &stringSliceArgs{v: []string{}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"--acf\"}}, expectedErr: \"flag provided but not defined: -acf\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-invalid\"}}, expectedErr: \"flag provided but not defined: -invalid\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-acf\", \"-invalid\"}}, expectedErr: \"flag provided but not defined: -invalid\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"--invalid\"}}, expectedErr: \"flag provided but not defined: -invalid\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-acf\", \"--invalid\"}}, expectedErr: \"flag provided but not defined: -invalid\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-acf\", \"arg1\", \"-invalid\"}}, expectedErr: \"flag provided but not defined: -invalid\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-acf\", \"arg1\", \"--invalid\"}}, expectedErr: \"flag provided but not defined: -invalid\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-acfi\", \"not-arg\", \"arg1\", \"-invalid\"}}, expectedErr: \"flag provided but not defined: -invalid\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-i\", \"ivalue\"}}, expectedArgs: &stringSliceArgs{v: []string{}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-i\", \"ivalue\", \"arg1\"}}, expectedArgs: &stringSliceArgs{v: []string{\"arg1\"}}},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"test\", \"-i\"}}, expectedErr: \"flag needs an argument: -i\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(strings.Join(tc.testArgs.v, \" \"), func(t *testing.T) {\n\t\t\tstate := map[string]Args{\"args\": nil}\n\n\t\t\tcmd := &Command{\n\t\t\t\tName:        \"test\",\n\t\t\t\tUsage:       \"this is for testing\",\n\t\t\t\tDescription: \"testing\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tstate[\"args\"] = cmd.Args()\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tUseShortOptionHandling: true,\n\t\t\t\tWriter:                 io.Discard,\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"abc\", Aliases: []string{\"a\"}},\n\t\t\t\t\t&BoolFlag{Name: \"cde\", Aliases: []string{\"c\"}},\n\t\t\t\t\t&BoolFlag{Name: \"fgh\", Aliases: []string{\"f\"}},\n\t\t\t\t\t&StringFlag{Name: \"ijk\", Aliases: []string{\"i\"}},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), tc.testArgs.Slice())\n\n\t\t\tr := require.New(t)\n\n\t\t\tif tc.expectedErr == \"\" {\n\t\t\t\tr.NoError(err)\n\t\t\t} else {\n\t\t\t\tr.ErrorContains(err, tc.expectedErr)\n\t\t\t}\n\n\t\t\tif tc.expectedArgs == nil {\n\t\t\t\tif state[\"args\"] != nil {\n\t\t\t\t\tr.Len(state[\"args\"].Slice(), 0)\n\t\t\t\t} else {\n\t\t\t\t\tr.Nil(state[\"args\"])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr.Equal(tc.expectedArgs, state[\"args\"])\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommand_Run_DoesNotOverwriteErrorFromBefore(t *testing.T) {\n\tcmd := &Command{\n\t\tName: \"bar\",\n\t\tBefore: func(context.Context, *Command) (context.Context, error) {\n\t\t\treturn nil, fmt.Errorf(\"before error\")\n\t\t},\n\t\tAfter: func(context.Context, *Command) error {\n\t\t\treturn fmt.Errorf(\"after error\")\n\t\t},\n\t\tWriter: io.Discard,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"bar\"})\n\n\trequire.ErrorContains(t, err, \"before error\")\n\trequire.ErrorContains(t, err, \"after error\")\n}\n\nfunc TestCommand_Run_BeforeSavesMetadata(t *testing.T) {\n\tvar receivedMsgFromAction string\n\tvar receivedMsgFromAfter string\n\n\tcmd := &Command{\n\t\tName: \"bar\",\n\t\tBefore: func(ctx context.Context, cmd *Command) (context.Context, error) {\n\t\t\tcmd.Metadata[\"msg\"] = \"hello world\"\n\t\t\treturn nil, nil\n\t\t},\n\t\tAction: func(ctx context.Context, cmd *Command) error {\n\t\t\tmsg, ok := cmd.Metadata[\"msg\"]\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"msg not found\")\n\t\t\t}\n\t\t\treceivedMsgFromAction = msg.(string)\n\n\t\t\treturn nil\n\t\t},\n\t\tAfter: func(_ context.Context, cmd *Command) error {\n\t\t\tmsg, ok := cmd.Metadata[\"msg\"]\n\t\t\tif !ok {\n\t\t\t\treturn errors.New(\"msg not found\")\n\t\t\t}\n\t\t\treceivedMsgFromAfter = msg.(string)\n\t\t\treturn nil\n\t\t},\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"foo\", \"bar\"}))\n\trequire.Equal(t, \"hello world\", receivedMsgFromAction)\n\trequire.Equal(t, \"hello world\", receivedMsgFromAfter)\n}\n\nfunc TestCommand_Run_BeforeReturnNewContext(t *testing.T) {\n\tvar receivedValFromAction, receivedValFromAfter string\n\ttype key string\n\n\tbkey := key(\"bkey\")\n\n\tcmd := &Command{\n\t\tName: \"bar\",\n\t\tBefore: func(ctx context.Context, cmd *Command) (context.Context, error) {\n\t\t\treturn context.WithValue(ctx, bkey, \"bval\"), nil\n\t\t},\n\t\tAction: func(ctx context.Context, cmd *Command) error {\n\t\t\tif val := ctx.Value(bkey); val == nil {\n\t\t\t\treturn errors.New(\"bkey value not found\")\n\t\t\t} else {\n\t\t\t\treceivedValFromAction = val.(string)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tAfter: func(ctx context.Context, cmd *Command) error {\n\t\t\tif val := ctx.Value(bkey); val == nil {\n\t\t\t\treturn errors.New(\"bkey value not found\")\n\t\t\t} else {\n\t\t\t\treceivedValFromAfter = val.(string)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"foo\", \"bar\"}))\n\trequire.Equal(t, \"bval\", receivedValFromAfter)\n\trequire.Equal(t, \"bval\", receivedValFromAction)\n}\n\nfunc TestCommand_OnUsageError_hasCommandContext(t *testing.T) {\n\tcmd := &Command{\n\t\tName: \"bar\",\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"flag\"},\n\t\t},\n\t\tOnUsageError: func(_ context.Context, cmd *Command, err error, _ bool) error {\n\t\t\treturn fmt.Errorf(\"intercepted in %s: %s\", cmd.Name, err.Error())\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"bar\", \"--flag=wrong\"})\n\tassert.ErrorContains(t, err, \"intercepted in bar\")\n}\n\nfunc TestCommand_OnUsageError_WithWrongFlagValue(t *testing.T) {\n\tcmd := &Command{\n\t\tName: \"bar\",\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"flag\"},\n\t\t},\n\t\tOnUsageError: func(_ context.Context, _ *Command, err error, _ bool) error {\n\t\t\tassert.ErrorContains(t, err, \"invalid value \\\"wrong\\\"\")\n\t\t\treturn errors.New(\"intercepted: \" + err.Error())\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"bar\", \"--flag=wrong\"})\n\tassert.ErrorContains(t, err, \"intercepted: invalid value\")\n}\n\nfunc TestCommand_OnUsageError_WithSubcommand(t *testing.T) {\n\tcmd := &Command{\n\t\tName: \"bar\",\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"baz\",\n\t\t\t},\n\t\t},\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"flag\"},\n\t\t},\n\t\tOnUsageError: func(_ context.Context, _ *Command, err error, _ bool) error {\n\t\t\tassert.ErrorContains(t, err, \"invalid value \\\"wrong\\\"\")\n\t\t\treturn errors.New(\"intercepted: \" + err.Error())\n\t\t},\n\t}\n\n\trequire.ErrorContains(t, cmd.Run(buildTestContext(t), []string{\"bar\", \"--flag=wrong\"}), \"intercepted: invalid value\")\n}\n\nfunc TestCommand_Run_SubcommandsCanUseErrWriter(t *testing.T) {\n\tcmd := &Command{\n\t\tErrWriter: io.Discard,\n\t\tName:      \"bar\",\n\t\tUsage:     \"this is for testing\",\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:  \"baz\",\n\t\t\t\tUsage: \"this is for testing\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\trequire.Equal(t, io.Discard, cmd.Root().ErrWriter)\n\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"bar\", \"baz\"}))\n}\n\nfunc TestCommandSkipFlagParsing(t *testing.T) {\n\tcases := []struct {\n\t\ttestArgs     *stringSliceArgs\n\t\texpectedArgs *stringSliceArgs\n\t\texpectedErr  error\n\t}{\n\t\t{testArgs: &stringSliceArgs{v: []string{\"some-command\", \"some-arg\", \"--flag\", \"foo\"}}, expectedArgs: &stringSliceArgs{v: []string{\"some-arg\", \"--flag\", \"foo\"}}, expectedErr: nil},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"some-command\", \"some-arg\", \"--flag=foo\"}}, expectedArgs: &stringSliceArgs{v: []string{\"some-arg\", \"--flag=foo\"}}, expectedErr: nil},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(strings.Join(c.testArgs.Slice(), \" \"), func(t *testing.T) {\n\t\t\tvar args Args\n\t\t\tcmd := &Command{\n\t\t\t\tSkipFlagParsing: true,\n\t\t\t\tName:            \"some-command\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&StringFlag{Name: \"flag\"},\n\t\t\t\t},\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\targs = cmd.Args()\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tWriter: io.Discard,\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), c.testArgs.Slice())\n\t\t\tassert.Equal(t, c.expectedErr, err)\n\t\t\tassert.Equal(t, c.expectedArgs, args)\n\t\t})\n\t}\n}\n\nfunc TestCommand_Run_CustomShellCompleteAcceptsMalformedFlags(t *testing.T) {\n\tcases := []struct {\n\t\ttestArgs    *stringSliceArgs\n\t\texpectedOut string\n\t}{\n\t\t{testArgs: &stringSliceArgs{v: []string{\"--undefined\"}}, expectedOut: \"found 0 args\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"--number\"}}, expectedOut: \"found 0 args\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"--number\", \"forty-two\"}}, expectedOut: \"found 0 args\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"--number\", \"42\"}}, expectedOut: \"found 0 args\"},\n\t\t{testArgs: &stringSliceArgs{v: []string{\"--number\", \"42\", \"newArg\"}}, expectedOut: \"found 1 args\"},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(strings.Join(c.testArgs.Slice(), \" \"), func(t *testing.T) {\n\t\t\tout := &bytes.Buffer{}\n\t\t\tcmd := &Command{\n\t\t\t\tWriter:                out,\n\t\t\t\tEnableShellCompletion: true,\n\t\t\t\tName:                  \"bar\",\n\t\t\t\tUsage:                 \"this is for testing\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\tName:  \"number\",\n\t\t\t\t\t\tUsage: \"A number to parse\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tShellComplete: func(_ context.Context, cmd *Command) {\n\t\t\t\t\tfmt.Fprintf(cmd.Root().Writer, \"found %[1]d args\", cmd.NArg())\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tosArgs := &stringSliceArgs{v: []string{\"bar\"}}\n\t\t\tosArgs.v = append(osArgs.v, c.testArgs.Slice()...)\n\t\t\tosArgs.v = append(osArgs.v, completionFlag)\n\n\t\t\tr := require.New(t)\n\n\t\t\tr.NoError(cmd.Run(buildTestContext(t), osArgs.Slice()))\n\t\t\tr.Equal(c.expectedOut, out.String())\n\t\t})\n\t}\n}\n\nfunc TestCommand_CanAddVFlagOnSubCommands(t *testing.T) {\n\tcmd := &Command{\n\t\tVersion: \"some version\",\n\t\tWriter:  io.Discard,\n\t\tName:    \"foo\",\n\t\tUsage:   \"this is for testing\",\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"bar\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"v\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"bar\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestCommand_VisibleSubcCommands(t *testing.T) {\n\tsubc1 := &Command{\n\t\tName:  \"subc1\",\n\t\tUsage: \"subc1 command1\",\n\t}\n\tsubc3 := &Command{\n\t\tName:  \"subc3\",\n\t\tUsage: \"subc3 command2\",\n\t}\n\tcmd := &Command{\n\t\tName:  \"bar\",\n\t\tUsage: \"this is for testing\",\n\t\tCommands: []*Command{\n\t\t\tsubc1,\n\t\t\t{\n\t\t\t\tName:   \"subc2\",\n\t\t\t\tUsage:  \"subc2 command2\",\n\t\t\t\tHidden: true,\n\t\t\t},\n\t\t\tsubc3,\n\t\t},\n\t}\n\n\tassert.Equal(t, cmd.VisibleCommands(), []*Command{subc1, subc3})\n}\n\nfunc TestCommand_VisibleFlagCategories(t *testing.T) {\n\tcmd := &Command{\n\t\tName:  \"bar\",\n\t\tUsage: \"this is for testing\",\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName: \"strd\", // no category set\n\t\t\t},\n\t\t\t&StringFlag{\n\t\t\t\tName:   \"strd1\", // no category set and also hidden\n\t\t\t\tHidden: true,\n\t\t\t},\n\t\t\t&IntFlag{\n\t\t\t\tName:     \"intd\",\n\t\t\t\tAliases:  []string{\"altd1\", \"altd2\"},\n\t\t\t\tCategory: \"cat1\",\n\t\t\t},\n\t\t\t&StringFlag{\n\t\t\t\tName:     \"sfd\",\n\t\t\t\tCategory: \"cat2\", // category set and hidden\n\t\t\t\tHidden:   true,\n\t\t\t},\n\t\t},\n\t\tMutuallyExclusiveFlags: []MutuallyExclusiveFlags{{\n\t\t\tCategory: \"cat2\",\n\t\t\tFlags: [][]Flag{\n\t\t\t\t{\n\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\tName: \"mutex\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}},\n\t}\n\n\tcmd.MutuallyExclusiveFlags[0].propagateCategory()\n\n\tvfc := cmd.VisibleFlagCategories()\n\trequire.Len(t, vfc, 3)\n\n\tassert.Equal(t, vfc[0].Name(), \"\", \"expected category name to be empty\")\n\tassert.Equal(t, vfc[0].Flags()[0].Names(), []string{\"strd\"})\n\n\tassert.Equal(t, vfc[1].Name(), \"cat1\", \"expected category name cat1\")\n\trequire.Len(t, vfc[1].Flags(), 1, \"expected flag category to have one flag\")\n\tassert.Equal(t, vfc[1].Flags()[0].Names(), []string{\"intd\", \"altd1\", \"altd2\"})\n\n\tassert.Equal(t, vfc[2].Name(), \"cat2\", \"expected category name cat2\")\n\trequire.Len(t, vfc[2].Flags(), 1, \"expected flag category to have one flag\")\n\tassert.Equal(t, vfc[2].Flags()[0].Names(), []string{\"mutex\"})\n}\n\nfunc TestCommand_RunSubcommandWithDefault(t *testing.T) {\n\tcmd := &Command{\n\t\tVersion:        \"some version\",\n\t\tName:           \"app\",\n\t\tDefaultCommand: \"foo\",\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"foo\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn errors.New(\"should not run this subcommand\")\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"bar\",\n\t\t\t\tUsage:    \"this is for testing\",\n\t\t\t\tCommands: []*Command{{}}, // some subcommand\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"app\", \"bar\"})\n\tassert.NoError(t, err)\n\n\terr = cmd.Run(buildTestContext(t), []string{\"app\"})\n\tassert.EqualError(t, err, \"should not run this subcommand\")\n}\n\nfunc TestCommand_Run(t *testing.T) {\n\ts := \"\"\n\n\tcmd := &Command{\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\ts = s + cmd.Args().First()\n\t\t\treturn nil\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"command\", \"foo\"})\n\tassert.NoError(t, err)\n\terr = cmd.Run(buildTestContext(t), []string{\"command\", \"bar\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, s, \"foobar\")\n}\n\nvar commandTests = []struct {\n\tname     string\n\texpected bool\n}{\n\t{\"foobar\", true},\n\t{\"batbaz\", true},\n\t{\"b\", true},\n\t{\"f\", true},\n\t{\"bat\", false},\n\t{\"nothing\", false},\n}\n\nfunc TestCommand_Command(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{Name: \"foobar\", Aliases: []string{\"f\"}},\n\t\t\t{Name: \"batbaz\", Aliases: []string{\"b\"}},\n\t\t},\n\t}\n\n\tfor _, test := range commandTests {\n\t\tif test.expected {\n\t\t\tassert.NotEmpty(t, cmd.Command(test.name))\n\t\t} else {\n\t\t\tassert.Empty(t, cmd.Command(test.name))\n\t\t}\n\t}\n}\n\nvar defaultCommandTests = []struct {\n\tcmdName        string\n\tdefaultCmd     string\n\terrNotExpected bool\n}{\n\t{\"foobar\", \"foobar\", true},\n\t{\"batbaz\", \"foobar\", true},\n\t{\"b\", \"\", true},\n\t{\"f\", \"\", true},\n\t{\"\", \"foobar\", true},\n\t{\"\", \"\", true},\n\t{\" \", \"\", false},\n\t{\"bat\", \"batbaz\", true},\n\t{\"nothing\", \"batbaz\", true},\n\t{\"nothing\", \"\", false},\n}\n\nfunc TestCommand_RunDefaultCommand(t *testing.T) {\n\tfor _, test := range defaultCommandTests {\n\t\ttestTitle := fmt.Sprintf(\"command=%[1]s-default=%[2]s\", test.cmdName, test.defaultCmd)\n\t\tt.Run(testTitle, func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tDefaultCommand: test.defaultCmd,\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{Name: \"foobar\", Aliases: []string{\"f\"}},\n\t\t\t\t\t{Name: \"batbaz\", Aliases: []string{\"b\"}},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), []string{\"c\", test.cmdName})\n\t\t\tif test.errNotExpected {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar defaultCommandSubCommandTests = []struct {\n\tcmdName        string\n\tsubCmd         string\n\tdefaultCmd     string\n\terrNotExpected bool\n}{\n\t{\"foobar\", \"\", \"foobar\", true},\n\t{\"foobar\", \"carly\", \"foobar\", true},\n\t{\"batbaz\", \"\", \"foobar\", true},\n\t{\"b\", \"\", \"\", true},\n\t{\"f\", \"\", \"\", true},\n\t{\"\", \"\", \"foobar\", true},\n\t{\"\", \"\", \"\", true},\n\t{\"\", \"jimbob\", \"foobar\", true},\n\t{\"\", \"j\", \"foobar\", true},\n\t{\"\", \"carly\", \"foobar\", true},\n\t{\"\", \"jimmers\", \"foobar\", false},\n\t{\"\", \"jimmers\", \"\", true},\n\t{\" \", \"jimmers\", \"foobar\", false},\n\t{\"\", \"\", \"\", true},\n\t{\" \", \"\", \"\", false},\n\t{\" \", \"j\", \"\", false},\n\t{\"bat\", \"\", \"batbaz\", true},\n\t{\"nothing\", \"\", \"batbaz\", true},\n\t{\"nothing\", \"\", \"\", false},\n\t{\"nothing\", \"j\", \"batbaz\", false},\n\t{\"nothing\", \"carly\", \"\", false},\n}\n\nfunc TestCommand_RunDefaultCommandWithSubCommand(t *testing.T) {\n\tfor _, test := range defaultCommandSubCommandTests {\n\t\ttestTitle := fmt.Sprintf(\"command=%[1]s-subcmd=%[2]s-default=%[3]s\", test.cmdName, test.subCmd, test.defaultCmd)\n\t\tt.Run(testTitle, func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tDefaultCommand: test.defaultCmd,\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:    \"foobar\",\n\t\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\t\tCommands: []*Command{\n\t\t\t\t\t\t\t{Name: \"jimbob\", Aliases: []string{\"j\"}},\n\t\t\t\t\t\t\t{Name: \"carly\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{Name: \"batbaz\", Aliases: []string{\"b\"}},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), []string{\"c\", test.cmdName, test.subCmd})\n\t\t\tif test.errNotExpected {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar defaultCommandFlagTests = []struct {\n\tcmdName        string\n\tflag           string\n\tdefaultCmd     string\n\terrNotExpected bool\n}{\n\t{\"foobar\", \"\", \"foobar\", true},\n\t{\"foobar\", \"-c derp\", \"foobar\", true},\n\t{\"batbaz\", \"\", \"foobar\", true},\n\t{\"b\", \"\", \"\", true},\n\t{\"f\", \"\", \"\", true},\n\t{\"\", \"\", \"foobar\", true},\n\t{\"\", \"\", \"\", true},\n\t{\"\", \"-j\", \"foobar\", true},\n\t{\"\", \"-j\", \"foobar\", true},\n\t{\"\", \"-c derp\", \"foobar\", true},\n\t{\"\", \"--carly=derp\", \"foobar\", true},\n\t{\"\", \"-j\", \"foobar\", true},\n\t{\"\", \"-j\", \"\", true},\n\t{\" \", \"-j\", \"foobar\", true},\n\t{\"\", \"\", \"\", true},\n\t{\" \", \"\", \"\", false},\n\t{\" \", \"-j\", \"\", false},\n\t{\"bat\", \"\", \"batbaz\", true},\n\t{\"nothing\", \"\", \"batbaz\", true},\n\t{\"nothing\", \"\", \"\", false},\n\t{\"nothing\", \"--jimbob\", \"batbaz\", true},\n\t{\"nothing\", \"--carly\", \"\", false},\n}\n\nfunc TestCommand_RunDefaultCommandWithFlags(t *testing.T) {\n\tfor _, test := range defaultCommandFlagTests {\n\t\ttestTitle := fmt.Sprintf(\"command=%[1]s-flag=%[2]s-default=%[3]s\", test.cmdName, test.flag, test.defaultCmd)\n\t\tt.Run(testTitle, func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tDefaultCommand: test.defaultCmd,\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\tName:     \"carly\",\n\t\t\t\t\t\tAliases:  []string{\"c\"},\n\t\t\t\t\t\tRequired: false,\n\t\t\t\t\t},\n\t\t\t\t\t&BoolFlag{\n\t\t\t\t\t\tName:     \"jimbob\",\n\t\t\t\t\t\tAliases:  []string{\"j\"},\n\t\t\t\t\t\tRequired: false,\n\t\t\t\t\t\tValue:    true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:    \"foobar\",\n\t\t\t\t\t\tAliases: []string{\"f\"},\n\t\t\t\t\t},\n\t\t\t\t\t{Name: \"batbaz\", Aliases: []string{\"b\"}},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tappArgs := []string{\"c\"}\n\n\t\t\tif test.flag != \"\" {\n\t\t\t\tflags := strings.Split(test.flag, \" \")\n\t\t\t\tif len(flags) > 1 {\n\t\t\t\t\tappArgs = append(appArgs, flags...)\n\t\t\t\t}\n\n\t\t\t\tflags = strings.Split(test.flag, \"=\")\n\t\t\t\tif len(flags) > 1 {\n\t\t\t\t\tappArgs = append(appArgs, flags...)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tappArgs = append(appArgs, test.cmdName)\n\n\t\t\terr := cmd.Run(buildTestContext(t), appArgs)\n\t\t\tif test.errNotExpected {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommand_FlagsFromExtPackage(t *testing.T) {\n\tvar someint int\n\tflag.IntVar(&someint, \"epflag\", 2, \"ext package flag usage\")\n\n\t// Based on source code we can reset the global flag parsing this way\n\tdefer func() {\n\t\tflag.CommandLine = flag.NewFlagSet(os.Args[0], flag.ExitOnError)\n\t}()\n\n\tcmd := &Command{\n\t\tAllowExtFlags: true,\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName:     \"carly\",\n\t\t\t\tAliases:  []string{\"c\"},\n\t\t\t\tRequired: false,\n\t\t\t},\n\t\t\t&BoolFlag{\n\t\t\t\tName:     \"jimbob\",\n\t\t\t\tAliases:  []string{\"j\"},\n\t\t\t\tRequired: false,\n\t\t\t\tValue:    true,\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"-c\", \"cly\", \"--epflag\", \"10\"})\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, someint, int(10))\n\n\tcmd = &Command{\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName:     \"carly\",\n\t\t\t\tAliases:  []string{\"c\"},\n\t\t\t\tRequired: false,\n\t\t\t},\n\t\t\t&BoolFlag{\n\t\t\t\tName:     \"jimbob\",\n\t\t\t\tAliases:  []string{\"j\"},\n\t\t\t\tRequired: false,\n\t\t\t\tValue:    true,\n\t\t\t},\n\t\t},\n\t}\n\n\t// this should return an error since epflag shouldnt be registered\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"-c\", \"cly\", \"--epflag\", \"10\"})\n\tassert.Error(t, err)\n}\n\nfunc TestCommand_Setup_defaultsReader(t *testing.T) {\n\tcmd := &Command{}\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\tassert.Equal(t, cmd.Reader, os.Stdin)\n}\n\nfunc TestCommand_Setup_defaultsWriter(t *testing.T) {\n\tcmd := &Command{}\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\tassert.Equal(t, cmd.Writer, os.Stdout)\n}\n\nfunc TestCommand_CommandWithFlagBeforeTerminator(t *testing.T) {\n\tvar parsedOption string\n\tvar args Args\n\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"cmd\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&StringFlag{Name: \"option\", Value: \"\", Usage: \"some option\"},\n\t\t\t\t},\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tparsedOption = cmd.String(\"option\")\n\t\t\t\t\targs = cmd.Args()\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"--option\", \"my-option\", \"my-arg\", \"--\", \"--notARealFlag\"}))\n\n\trequire.Equal(t, \"my-option\", parsedOption)\n\trequire.Equal(t, \"my-arg\", args.Get(0))\n\trequire.Equal(t, \"--\", args.Get(1))\n\trequire.Equal(t, \"--notARealFlag\", args.Get(2))\n}\n\nfunc TestCommand_CommandWithDash(t *testing.T) {\n\tvar args Args\n\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"cmd\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\targs = cmd.Args()\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"my-arg\", \"-\"}))\n\trequire.NotNil(t, args)\n\trequire.Equal(t, \"my-arg\", args.Get(0))\n\trequire.Equal(t, \"-\", args.Get(1))\n}\n\nfunc TestCommand_CommandWithNoFlagBeforeTerminator(t *testing.T) {\n\tvar args Args\n\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"cmd\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\targs = cmd.Args()\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"my-arg\", \"--\", \"notAFlagAtAll\"}))\n\n\trequire.NotNil(t, args)\n\trequire.Equal(t, \"my-arg\", args.Get(0))\n\trequire.Equal(t, \"--\", args.Get(1))\n\trequire.Equal(t, \"notAFlagAtAll\", args.Get(2))\n}\n\nfunc TestCommand_SkipFlagParsing(t *testing.T) {\n\tvar args Args\n\n\tcmd := &Command{\n\t\tSkipFlagParsing: true,\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\targs = cmd.Args()\n\t\t\treturn nil\n\t\t},\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"\", \"--\", \"my-arg\", \"notAFlagAtAll\"})\n\n\tassert.Equal(t, args.Get(0), \"--\")\n\tassert.Equal(t, args.Get(1), \"my-arg\")\n\tassert.Equal(t, args.Get(2), \"notAFlagAtAll\")\n}\n\nfunc TestCommand_VisibleCommands(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:   \"frob\",\n\t\t\t\tAction: func(context.Context, *Command) error { return nil },\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"frib\",\n\t\t\t\tHidden: true,\n\t\t\t\tAction: func(context.Context, *Command) error { return nil },\n\t\t\t},\n\t\t},\n\t}\n\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\texpected := []*Command{\n\t\tcmd.Commands[0],\n\t}\n\tactual := cmd.VisibleCommands()\n\tassert.Len(t, actual, len(expected))\n\tfor i, actualCommand := range actual {\n\t\texpectedCommand := expected[i]\n\n\t\tif expectedCommand.Action != nil {\n\t\t\t// comparing func addresses is OK!\n\t\t\tassert.Equal(t, fmt.Sprintf(\"%p\", expectedCommand.Action), fmt.Sprintf(\"%p\", actualCommand.Action))\n\t\t}\n\n\t\tfunc() {\n\t\t\t// nil out funcs, as they cannot be compared\n\t\t\t// (https://github.com/golang/go/issues/8554)\n\t\t\texpectedAction := expectedCommand.Action\n\t\t\tactualAction := actualCommand.Action\n\t\t\tdefer func() {\n\t\t\t\texpectedCommand.Action = expectedAction\n\t\t\t\tactualCommand.Action = actualAction\n\t\t\t}()\n\t\t\texpectedCommand.Action = nil\n\t\t\tactualCommand.Action = nil\n\n\t\t\tassert.Equal(t, expectedCommand, actualCommand)\n\t\t}()\n\t}\n}\n\nfunc TestCommand_UseShortOptionHandling(t *testing.T) {\n\tvar one, two bool\n\tvar name string\n\texpected := \"expectedName\"\n\n\tcmd := buildMinimalTestCommand()\n\tcmd.UseShortOptionHandling = true\n\tcmd.Flags = []Flag{\n\t\t&BoolFlag{Name: \"one\", Aliases: []string{\"o\"}},\n\t\t&BoolFlag{Name: \"two\", Aliases: []string{\"t\"}},\n\t\t&StringFlag{Name: \"name\", Aliases: []string{\"n\"}},\n\t}\n\tcmd.Action = func(_ context.Context, cmd *Command) error {\n\t\tone = cmd.Bool(\"one\")\n\t\ttwo = cmd.Bool(\"two\")\n\t\tname = cmd.String(\"name\")\n\t\treturn nil\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"\", \"-on\", expected})\n\tassert.True(t, one)\n\tassert.False(t, two)\n\tassert.Equal(t, name, expected)\n}\n\nfunc TestCommand_UseShortOptionHandling_missing_value(t *testing.T) {\n\tcmd := buildMinimalTestCommand()\n\tcmd.UseShortOptionHandling = true\n\tcmd.Flags = []Flag{\n\t\t&StringFlag{Name: \"name\", Aliases: []string{\"n\"}},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"\", \"-n\"})\n\tassert.EqualError(t, err, \"flag needs an argument: -n\")\n}\n\nfunc TestCommand_UseShortOptionHandlingCommand(t *testing.T) {\n\tvar (\n\t\tone, two bool\n\t\tname     string\n\t\texpected = \"expectedName\"\n\t)\n\n\tcmd := &Command{\n\t\tName: \"cmd\",\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{Name: \"one\", Aliases: []string{\"o\"}},\n\t\t\t&BoolFlag{Name: \"two\", Aliases: []string{\"t\"}},\n\t\t\t&StringFlag{Name: \"name\", Aliases: []string{\"n\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tone = cmd.Bool(\"one\")\n\t\t\ttwo = cmd.Bool(\"two\")\n\t\t\tname = cmd.String(\"name\")\n\t\t\treturn nil\n\t\t},\n\t\tUseShortOptionHandling: true,\n\t\tWriter:                 io.Discard,\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"cmd\", \"-on\", expected}))\n\trequire.True(t, one)\n\trequire.False(t, two)\n\trequire.Equal(t, expected, name)\n}\n\nfunc TestCommand_UseShortOptionHandlingCommand_missing_value(t *testing.T) {\n\tcmd := buildMinimalTestCommand()\n\tcmd.UseShortOptionHandling = true\n\tcommand := &Command{\n\t\tName: \"cmd\",\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"name\", Aliases: []string{\"n\"}},\n\t\t},\n\t}\n\tcmd.Commands = []*Command{command}\n\n\trequire.EqualError(\n\t\tt,\n\t\tcmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"-n\"}),\n\t\t\"flag needs an argument: -n\",\n\t)\n}\n\nfunc TestCommand_UseShortOptionHandlingSubCommand(t *testing.T) {\n\tvar one, two bool\n\tvar name string\n\n\tcmd := buildMinimalTestCommand()\n\tcmd.UseShortOptionHandling = true\n\tcmd.Commands = []*Command{\n\t\t{\n\t\t\tName: \"cmd\",\n\t\t\tCommands: []*Command{\n\t\t\t\t{\n\t\t\t\t\tName: \"sub\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"one\", Aliases: []string{\"o\"}},\n\t\t\t\t\t\t&BoolFlag{Name: \"two\", Aliases: []string{\"t\"}},\n\t\t\t\t\t\t&StringFlag{Name: \"name\", Aliases: []string{\"n\"}},\n\t\t\t\t\t},\n\t\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\t\tone = cmd.Bool(\"one\")\n\t\t\t\t\t\ttwo = cmd.Bool(\"two\")\n\t\t\t\t\t\tname = cmd.String(\"name\")\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\texpected := \"expectedName\"\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"sub\", \"-on\", expected}))\n\trequire.True(t, one)\n\trequire.False(t, two)\n\trequire.Equal(t, expected, name)\n}\n\nfunc TestCommand_UseShortOptionHandlingSubCommand_missing_value(t *testing.T) {\n\tcmd := buildMinimalTestCommand()\n\tcmd.UseShortOptionHandling = true\n\tcommand := &Command{\n\t\tName: \"cmd\",\n\t}\n\tsubCommand := &Command{\n\t\tName: \"sub\",\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"name\", Aliases: []string{\"n\"}},\n\t\t},\n\t}\n\tcommand.Commands = []*Command{subCommand}\n\tcmd.Commands = []*Command{command}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"sub\", \"-n\"})\n\tassert.EqualError(t, err, \"flag needs an argument: -n\")\n}\n\nfunc TestCommand_UseShortOptionAfterSliceFlag(t *testing.T) {\n\tvar one, two bool\n\tvar name string\n\tvar sliceValDest []string\n\tvar sliceVal []string\n\texpected := \"expectedName\"\n\n\tcmd := buildMinimalTestCommand()\n\tcmd.UseShortOptionHandling = true\n\tcmd.Flags = []Flag{\n\t\t&StringSliceFlag{Name: \"env\", Aliases: []string{\"e\"}, Destination: &sliceValDest},\n\t\t&BoolFlag{Name: \"one\", Aliases: []string{\"o\"}},\n\t\t&BoolFlag{Name: \"two\", Aliases: []string{\"t\"}},\n\t\t&StringFlag{Name: \"name\", Aliases: []string{\"n\"}},\n\t}\n\tcmd.Action = func(_ context.Context, cmd *Command) error {\n\t\tsliceVal = cmd.StringSlice(\"env\")\n\t\tone = cmd.Bool(\"one\")\n\t\ttwo = cmd.Bool(\"two\")\n\t\tname = cmd.String(\"name\")\n\t\treturn nil\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"\", \"-e\", \"foo\", \"-on\", expected})\n\tassert.Equal(t, sliceVal, []string{\"foo\"})\n\tassert.Equal(t, sliceValDest, []string{\"foo\"})\n\tassert.True(t, one)\n\tassert.False(t, two)\n\tassert.Equal(t, expected, name)\n}\n\nfunc TestCommand_Float64Flag(t *testing.T) {\n\tvar meters float64\n\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatFlag{Name: \"height\", Value: 1.5, Usage: \"Set the height, in meters\"},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tmeters = cmd.Float(\"height\")\n\t\t\treturn nil\n\t\t},\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"\", \"--height\", \"1.93\"})\n\tassert.Equal(t, 1.93, meters)\n}\n\nfunc TestCommand_ParseSliceFlags(t *testing.T) {\n\tvar parsedIntSlice []int64\n\tvar parsedStringSlice []string\n\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"cmd\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&IntSliceFlag{Name: \"p\", Value: []int64{}, Usage: \"set one or more ip addr\"},\n\t\t\t\t\t&StringSliceFlag{Name: \"ip\", Value: []string{}, Usage: \"set one or more ports to open\"},\n\t\t\t\t},\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tparsedIntSlice = cmd.IntSlice(\"p\")\n\t\t\t\t\tparsedStringSlice = cmd.StringSlice(\"ip\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tr := require.New(t)\n\n\tr.NoError(cmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"-p\", \"22\", \"-p\", \"80\", \"-ip\", \"8.8.8.8\", \"-ip\", \"8.8.4.4\"}))\n\tr.Equal([]int64{22, 80}, parsedIntSlice)\n\tr.Equal([]string{\"8.8.8.8\", \"8.8.4.4\"}, parsedStringSlice)\n}\n\nfunc TestCommand_ParseSliceFlagsWithMissingValue(t *testing.T) {\n\tvar parsedIntSlice []int64\n\tvar parsedStringSlice []string\n\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"cmd\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&IntSliceFlag{Name: \"a\", Usage: \"set numbers\"},\n\t\t\t\t\t&StringSliceFlag{Name: \"str\", Usage: \"set strings\"},\n\t\t\t\t},\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tparsedIntSlice = cmd.IntSlice(\"a\")\n\t\t\t\t\tparsedStringSlice = cmd.StringSlice(\"str\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tr := require.New(t)\n\n\tr.NoError(cmd.Run(buildTestContext(t), []string{\"\", \"cmd\", \"-a\", \"2\", \"-str\", \"A\"}))\n\tr.Equal([]int64{2}, parsedIntSlice)\n\tr.Equal([]string{\"A\"}, parsedStringSlice)\n}\n\nfunc TestCommand_DefaultStdin(t *testing.T) {\n\tcmd := &Command{}\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\n\tassert.Equal(t, cmd.Reader, os.Stdin, \"Default input reader not set.\")\n}\n\nfunc TestCommand_DefaultStdout(t *testing.T) {\n\tcmd := &Command{}\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\n\tassert.Equal(t, cmd.Writer, os.Stdout, \"Default output writer not set.\")\n}\n\nfunc TestCommand_SetStdin(t *testing.T) {\n\tbuf := make([]byte, 12)\n\n\tcmd := &Command{\n\t\tName:   \"test\",\n\t\tReader: strings.NewReader(\"Hello World!\"),\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t_, err := cmd.Reader.Read(buf)\n\t\t\treturn err\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"help\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"Hello World!\", string(buf), \"Command did not read input from desired reader.\")\n}\n\nfunc TestCommand_SetStdin_Subcommand(t *testing.T) {\n\tbuf := make([]byte, 12)\n\n\tcmd := &Command{\n\t\tName:   \"test\",\n\t\tReader: strings.NewReader(\"Hello World!\"),\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"command\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"subcommand\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\t\t\t_, err := cmd.Root().Reader.Read(buf)\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"test\", \"command\", \"subcommand\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"Hello World!\", string(buf), \"Command did not read input from desired reader.\")\n}\n\nfunc TestCommand_SetStdout(t *testing.T) {\n\tvar w bytes.Buffer\n\n\tcmd := &Command{\n\t\tName:   \"test\",\n\t\tWriter: &w,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"help\"})\n\trequire.NoError(t, err)\n\tassert.NotZero(t, w.Len(), \"Command did not write output to desired writer.\")\n}\n\nfunc TestCommand_BeforeFunc(t *testing.T) {\n\tcounts := &opCounts{}\n\tbeforeError := fmt.Errorf(\"fail\")\n\tvar err error\n\n\tcmd := &Command{\n\t\tBefore: func(_ context.Context, cmd *Command) (context.Context, error) {\n\t\t\tcounts.Total++\n\t\t\tcounts.Before = counts.Total\n\t\t\ts := cmd.String(\"opt\")\n\t\t\tif s == \"fail\" {\n\t\t\t\treturn nil, beforeError\n\t\t\t}\n\n\t\t\treturn nil, nil\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"sub\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tcounts.Total++\n\t\t\t\t\tcounts.SubCommand = counts.Total\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"opt\"},\n\t\t},\n\t\tWriter: io.Discard,\n\t}\n\n\t// run with the Before() func succeeding\n\terr = cmd.Run(buildTestContext(t), []string{\"command\", \"--opt\", \"succeed\", \"sub\"})\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, 1, counts.Before, \"Before() not executed when expected\")\n\tassert.Equal(t, 2, counts.SubCommand, \"Subcommand not executed when expected\")\n\n\t// reset\n\tcounts = &opCounts{}\n\n\t// run with the Before() func failing\n\terr = cmd.Run(buildTestContext(t), []string{\"command\", \"--opt\", \"fail\", \"sub\"})\n\n\t// should be the same error produced by the Before func\n\tassert.ErrorIs(t, err, beforeError, \"Run error expected, but not received\")\n\tassert.Equal(t, 1, counts.Before, \"Before() not executed when expected\")\n\tassert.Equal(t, 0, counts.SubCommand, \"Subcommand executed when NOT expected\")\n\n\t// reset\n\tcounts = &opCounts{}\n\n\tafterError := errors.New(\"fail again\")\n\tcmd.After = func(context.Context, *Command) error {\n\t\treturn afterError\n\t}\n\n\t// run with the Before() func failing, wrapped by After()\n\terr = cmd.Run(buildTestContext(t), []string{\"command\", \"--opt\", \"fail\", \"sub\"})\n\n\t// should be the same error produced by the Before func\n\tif _, ok := err.(MultiError); !ok {\n\t\tt.Errorf(\"MultiError expected, but not received\")\n\t}\n\n\tassert.Equal(t, 1, counts.Before, \"Before() not executed when expected\")\n\tassert.Zero(t, counts.SubCommand, \"Subcommand executed when NOT expected\")\n}\n\nfunc TestCommand_BeforeFuncPersistentFlag(t *testing.T) {\n\tcounts := &opCounts{}\n\tbeforeError := fmt.Errorf(\"fail\")\n\tvar err error\n\n\tcmd := &Command{\n\t\tBefore: func(_ context.Context, cmd *Command) (context.Context, error) {\n\t\t\tcounts.Before++\n\t\t\ts := cmd.String(\"opt\")\n\t\t\tif s != \"value\" {\n\t\t\t\treturn nil, beforeError\n\t\t\t}\n\t\t\treturn nil, nil\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"sub\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tcounts.SubCommand++\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"opt\"},\n\t\t},\n\t\tWriter: io.Discard,\n\t}\n\n\t// Check that --opt value is available in root command Before hook,\n\t// even when it was set on the subcommand.\n\terr = cmd.Run(buildTestContext(t), []string{\"command\", \"sub\", \"--opt\", \"value\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, 1, counts.Before, \"Before() not executed when expected\")\n\tassert.Equal(t, 1, counts.SubCommand, \"Subcommand not executed when expected\")\n}\n\nfunc TestCommand_BeforeAfterFuncShellCompletion(t *testing.T) {\n\tt.Skip(\"TODO: is '--generate-shell-completion' (flag) still supported?\")\n\n\tcounts := &opCounts{}\n\n\tcmd := &Command{\n\t\tEnableShellCompletion: true,\n\t\tBefore: func(context.Context, *Command) (context.Context, error) {\n\t\t\tcounts.Total++\n\t\t\tcounts.Before = counts.Total\n\t\t\treturn nil, nil\n\t\t},\n\t\tAfter: func(context.Context, *Command) error {\n\t\t\tcounts.Total++\n\t\t\tcounts.After = counts.Total\n\t\t\treturn nil\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"sub\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tcounts.Total++\n\t\t\t\t\tcounts.SubCommand = counts.Total\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"opt\"},\n\t\t},\n\t\tWriter: io.Discard,\n\t}\n\n\tr := require.New(t)\n\n\t// run with the Before() func succeeding\n\tr.NoError(\n\t\tcmd.Run(\n\t\t\tbuildTestContext(t),\n\t\t\t[]string{\n\t\t\t\t\"command\",\n\t\t\t\t\"--opt\", \"succeed\",\n\t\t\t\t\"sub\", completionFlag,\n\t\t\t},\n\t\t),\n\t)\n\n\tr.Equalf(0, counts.Before, \"Before was run\")\n\tr.Equal(0, counts.After, \"After was run\")\n\tr.Equal(0, counts.SubCommand, \"SubCommand was run\")\n}\n\nfunc TestCommand_AfterFunc(t *testing.T) {\n\tcounts := &opCounts{}\n\tafterError := fmt.Errorf(\"fail\")\n\tvar err error\n\n\tcmd := &Command{\n\t\tAfter: func(_ context.Context, cmd *Command) error {\n\t\t\tcounts.Total++\n\t\t\tcounts.After = counts.Total\n\t\t\ts := cmd.String(\"opt\")\n\t\t\tif s == \"fail\" {\n\t\t\t\treturn afterError\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"sub\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tcounts.Total++\n\t\t\t\t\tcounts.SubCommand = counts.Total\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"opt\"},\n\t\t},\n\t}\n\n\t// run with the After() func succeeding\n\terr = cmd.Run(buildTestContext(t), []string{\"command\", \"--opt\", \"succeed\", \"sub\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, 2, counts.After, \"After() not executed when expected\")\n\tassert.Equal(t, 1, counts.SubCommand, \"Subcommand not executed when expected\")\n\n\t// reset\n\tcounts = &opCounts{}\n\n\t// run with the Before() func failing\n\terr = cmd.Run(buildTestContext(t), []string{\"command\", \"--opt\", \"fail\", \"sub\"})\n\n\t// should be the same error produced by the Before func\n\tassert.ErrorIs(t, err, afterError, \"Run error expected, but not received\")\n\tassert.Equal(t, 2, counts.After, \"After() not executed when expected\")\n\tassert.Equal(t, 1, counts.SubCommand, \"Subcommand not executed when expected\")\n\n\t/*\n\t\treset\n\t*/\n\tcounts = &opCounts{}\n\t// reset the flags since they are set previously\n\tcmd.Flags = []Flag{\n\t\t&StringFlag{Name: \"opt\"},\n\t}\n\n\t// run with none args\n\terr = cmd.Run(buildTestContext(t), []string{\"command\"})\n\n\t// should be the same error produced by the Before func\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, 1, counts.After, \"After() not executed when expected\")\n\tassert.Equal(t, 0, counts.SubCommand, \"Subcommand not executed when expected\")\n}\n\nfunc TestCommandNoHelpFlag(t *testing.T) {\n\toldFlag := HelpFlag\n\tdefer func() {\n\t\tHelpFlag = oldFlag\n\t}()\n\n\tHelpFlag = nil\n\n\tcmd := &Command{Writer: io.Discard}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"test\", \"-h\"})\n\n\tassert.ErrorIs(t, err, flag.ErrHelp, \"expected error about missing help flag\")\n}\n\nfunc TestRequiredFlagCommandRunBehavior(t *testing.T) {\n\ttdata := []struct {\n\t\ttestCase        string\n\t\tappFlags        []Flag\n\t\tappRunInput     []string\n\t\tappCommands     []*Command\n\t\texpectedAnError bool\n\t}{\n\t\t// assertion: empty input, when a required flag is present, errors\n\t\t{\n\t\t\ttestCase:        \"error_case_empty_input_with_required_flag_on_app\",\n\t\t\tappRunInput:     []string{\"myCLI\"},\n\t\t\tappFlags:        []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"error_case_empty_input_with_required_flag_on_command\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName:  \"myCommand\",\n\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t\t}},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"error_case_empty_input_with_required_flag_on_subcommand\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\", \"mySubCommand\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName: \"myCommand\",\n\t\t\t\tCommands: []*Command{{\n\t\t\t\t\tName:  \"mySubCommand\",\n\t\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t// assertion: inputting --help, when a required flag is present, does not error\n\t\t{\n\t\t\ttestCase:    \"valid_case_help_input_with_required_flag_on_app\",\n\t\t\tappRunInput: []string{\"myCLI\", \"--help\"},\n\t\t\tappFlags:    []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"valid_case_help_input_with_required_flag_on_command\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\", \"--help\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName:  \"myCommand\",\n\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t\t}},\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"valid_case_help_input_with_required_flag_on_subcommand\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\", \"mySubCommand\", \"--help\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName: \"myCommand\",\n\t\t\t\tCommands: []*Command{{\n\t\t\t\t\tName:  \"mySubCommand\",\n\t\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t\t// assertion: giving optional input, when a required flag is present, errors\n\t\t{\n\t\t\ttestCase:        \"error_case_optional_input_with_required_flag_on_app\",\n\t\t\tappRunInput:     []string{\"myCLI\", \"--optional\", \"cats\"},\n\t\t\tappFlags:        []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}, &StringFlag{Name: \"optional\"}},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"error_case_optional_input_with_required_flag_on_command\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\", \"--optional\", \"cats\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName:  \"myCommand\",\n\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}, &StringFlag{Name: \"optional\"}},\n\t\t\t}},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"error_case_optional_input_with_required_flag_on_subcommand\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\", \"mySubCommand\", \"--optional\", \"cats\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName: \"myCommand\",\n\t\t\t\tCommands: []*Command{{\n\t\t\t\t\tName:  \"mySubCommand\",\n\t\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}, &StringFlag{Name: \"optional\"}},\n\t\t\t\t}},\n\t\t\t}},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t// assertion: when a required flag is present, inputting that required flag does not error\n\t\t{\n\t\t\ttestCase:    \"valid_case_required_flag_input_on_app\",\n\t\t\tappRunInput: []string{\"myCLI\", \"--requiredFlag\", \"cats\"},\n\t\t\tappFlags:    []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"valid_case_required_flag_input_on_command\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\", \"--requiredFlag\", \"cats\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName:  \"myCommand\",\n\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t\t}},\n\t\t},\n\t\t{\n\t\t\ttestCase:    \"valid_case_required_flag_input_on_subcommand\",\n\t\t\tappRunInput: []string{\"myCLI\", \"myCommand\", \"mySubCommand\", \"--requiredFlag\", \"cats\"},\n\t\t\tappCommands: []*Command{{\n\t\t\t\tName: \"myCommand\",\n\t\t\t\tCommands: []*Command{{\n\t\t\t\t\tName:  \"mySubCommand\",\n\t\t\t\t\tFlags: []Flag{&StringFlag{Name: \"requiredFlag\", Required: true}},\n\t\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t\t}},\n\t\t},\n\t}\n\tfor _, test := range tdata {\n\t\tt.Run(test.testCase, func(t *testing.T) {\n\t\t\t// setup\n\t\t\tcmd := buildMinimalTestCommand()\n\t\t\tcmd.Flags = test.appFlags\n\t\t\tcmd.Commands = test.appCommands\n\n\t\t\t// logic under test\n\t\t\terr := cmd.Run(buildTestContext(t), test.appRunInput)\n\n\t\t\t// assertions\n\t\t\tif test.expectedAnError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tif _, ok := err.(requiredFlagsErr); test.expectedAnError && !ok {\n\t\t\t\t\tt.Errorf(\"expected a requiredFlagsErr, but got: %s\", err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommandHelpPrinter(t *testing.T) {\n\toldPrinter := HelpPrinter\n\tdefer func() {\n\t\tHelpPrinter = oldPrinter\n\t}()\n\n\twasCalled := false\n\tHelpPrinter = func(io.Writer, string, interface{}) {\n\t\twasCalled = true\n\t}\n\n\tcmd := &Command{}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"-h\"})\n\n\tassert.True(t, wasCalled, \"Help printer expected to be called, but was not\")\n}\n\nfunc TestCommand_VersionPrinter(t *testing.T) {\n\toldPrinter := VersionPrinter\n\tdefer func() {\n\t\tVersionPrinter = oldPrinter\n\t}()\n\n\twasCalled := false\n\tVersionPrinter = func(*Command) {\n\t\twasCalled = true\n\t}\n\n\tcmd := &Command{}\n\tShowVersion(cmd)\n\n\tassert.True(t, wasCalled, \"Version printer expected to be called, but was not\")\n}\n\nfunc TestCommand_CommandNotFound(t *testing.T) {\n\tcounts := &opCounts{}\n\tcmd := &Command{\n\t\tCommandNotFound: func(context.Context, *Command, string) {\n\t\t\tcounts.Total++\n\t\t\tcounts.CommandNotFound = counts.Total\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"bar\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tcounts.Total++\n\t\t\t\t\tcounts.SubCommand = counts.Total\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"command\", \"foo\"})\n\n\tassert.Equal(t, 1, counts.CommandNotFound)\n\tassert.Equal(t, 0, counts.SubCommand)\n\tassert.Equal(t, 1, counts.Total)\n}\n\nfunc TestCommand_OrderOfOperations(t *testing.T) {\n\tbuildCmdCounts := func() (*Command, *opCounts) {\n\t\tcounts := &opCounts{}\n\n\t\tcmd := &Command{\n\t\t\tEnableShellCompletion: true,\n\t\t\tShellComplete: func(context.Context, *Command) {\n\t\t\t\tcounts.Total++\n\t\t\t\tcounts.ShellComplete = counts.Total\n\t\t\t},\n\t\t\tOnUsageError: func(context.Context, *Command, error, bool) error {\n\t\t\t\tcounts.Total++\n\t\t\t\tcounts.OnUsageError = counts.Total\n\t\t\t\treturn errors.New(\"hay OnUsageError\")\n\t\t\t},\n\t\t\tWriter: io.Discard,\n\t\t}\n\n\t\tbeforeNoError := func(context.Context, *Command) (context.Context, error) {\n\t\t\tcounts.Total++\n\t\t\tcounts.Before = counts.Total\n\t\t\treturn nil, nil\n\t\t}\n\n\t\tcmd.Before = beforeNoError\n\t\tcmd.CommandNotFound = func(context.Context, *Command, string) {\n\t\t\tcounts.Total++\n\t\t\tcounts.CommandNotFound = counts.Total\n\t\t}\n\n\t\tafterNoError := func(context.Context, *Command) error {\n\t\t\tcounts.Total++\n\t\t\tcounts.After = counts.Total\n\t\t\treturn nil\n\t\t}\n\n\t\tcmd.After = afterNoError\n\t\tcmd.Commands = []*Command{\n\t\t\t{\n\t\t\t\tName: \"bar\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tcounts.Total++\n\t\t\t\t\tcounts.SubCommand = counts.Total\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tcmd.Action = func(context.Context, *Command) error {\n\t\t\tcounts.Total++\n\t\t\tcounts.Action = counts.Total\n\t\t\treturn nil\n\t\t}\n\n\t\treturn cmd, counts\n\t}\n\n\tt.Run(\"on usage error\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tr := require.New(t)\n\n\t\t_ = cmd.Run(buildTestContext(t), []string{\"command\", \"--nope\"})\n\t\tr.Equal(1, counts.OnUsageError)\n\t\tr.Equal(1, counts.Total)\n\t})\n\n\tt.Run(\"shell complete\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tr := require.New(t)\n\n\t\t_ = cmd.Run(buildTestContext(t), []string{\"command\", completionFlag})\n\t\tr.Equal(1, counts.ShellComplete)\n\t\tr.Equal(1, counts.Total)\n\t})\n\n\tt.Run(\"nil on usage error\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tcmd.OnUsageError = nil\n\n\t\t_ = cmd.Run(buildTestContext(t), []string{\"command\", \"--nope\"})\n\t\trequire.Equal(t, 0, counts.Total)\n\t})\n\n\tt.Run(\"before after action hooks\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tr := require.New(t)\n\n\t\t_ = cmd.Run(buildTestContext(t), []string{\"command\", \"foo\"})\n\t\tr.Equal(0, counts.OnUsageError)\n\t\tr.Equal(1, counts.Before)\n\t\tr.Equal(0, counts.CommandNotFound)\n\t\tr.Equal(2, counts.Action)\n\t\tr.Equal(3, counts.After)\n\t\tr.Equal(3, counts.Total)\n\t})\n\n\tt.Run(\"before with error\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tcmd.Before = func(context.Context, *Command) (context.Context, error) {\n\t\t\tcounts.Total++\n\t\t\tcounts.Before = counts.Total\n\t\t\treturn nil, errors.New(\"hay Before\")\n\t\t}\n\n\t\tr := require.New(t)\n\n\t\t_ = cmd.Run(buildTestContext(t), []string{\"command\", \"bar\"})\n\t\tr.Equal(0, counts.OnUsageError)\n\t\tr.Equal(1, counts.Before)\n\t\tr.Equal(2, counts.After)\n\t\tr.Equal(2, counts.Total)\n\t})\n\n\tt.Run(\"nil after\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tcmd.After = nil\n\t\tr := require.New(t)\n\n\t\t_ = cmd.Run(buildTestContext(t), []string{\"command\", \"bar\"})\n\t\tr.Equal(0, counts.OnUsageError)\n\t\tr.Equal(1, counts.Before)\n\t\tr.Equal(2, counts.SubCommand)\n\t\tr.Equal(2, counts.Total)\n\t})\n\n\tt.Run(\"after errors\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tcmd.After = func(context.Context, *Command) error {\n\t\t\tcounts.Total++\n\t\t\tcounts.After = counts.Total\n\t\t\treturn errors.New(\"hay After\")\n\t\t}\n\n\t\tr := require.New(t)\n\n\t\terr := cmd.Run(buildTestContext(t), []string{\"command\", \"bar\"})\n\t\tr.Error(err)\n\t\tr.Equal(0, counts.OnUsageError)\n\t\tr.Equal(1, counts.Before)\n\t\tr.Equal(2, counts.SubCommand)\n\t\tr.Equal(3, counts.After)\n\t\tr.Equal(3, counts.Total)\n\t})\n\n\tt.Run(\"nil commands\", func(t *testing.T) {\n\t\tcmd, counts := buildCmdCounts()\n\t\tcmd.Commands = nil\n\t\tr := require.New(t)\n\n\t\t_ = cmd.Run(buildTestContext(t), []string{\"command\"})\n\t\tr.Equal(0, counts.OnUsageError)\n\t\tr.Equal(1, counts.Before)\n\t\tr.Equal(2, counts.Action)\n\t\tr.Equal(3, counts.After)\n\t\tr.Equal(3, counts.Total)\n\t})\n}\n\nfunc TestCommand_Run_CommandWithSubcommandHasHelpTopic(t *testing.T) {\n\tsubcommandHelpTopics := [][]string{\n\t\t{\"foo\", \"--help\"},\n\t\t{\"foo\", \"-h\"},\n\t\t{\"foo\", \"help\"},\n\t}\n\n\tfor _, flagSet := range subcommandHelpTopics {\n\t\tt.Run(fmt.Sprintf(\"checking with flags %v\", flagSet), func(t *testing.T) {\n\t\t\tbuf := new(bytes.Buffer)\n\n\t\t\tsubCmdBar := &Command{\n\t\t\t\tName:  \"bar\",\n\t\t\t\tUsage: \"does bar things\",\n\t\t\t}\n\t\t\tsubCmdBaz := &Command{\n\t\t\t\tName:  \"baz\",\n\t\t\t\tUsage: \"does baz things\",\n\t\t\t}\n\t\t\tcmd := &Command{\n\t\t\t\tName:        \"foo\",\n\t\t\t\tDescription: \"descriptive wall of text about how it does foo things\",\n\t\t\t\tCommands:    []*Command{subCmdBar, subCmdBaz},\n\t\t\t\tAction:      func(context.Context, *Command) error { return nil },\n\t\t\t\tWriter:      buf,\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), flagSet)\n\t\t\tassert.NoError(t, err)\n\n\t\t\toutput := buf.String()\n\n\t\t\tassert.NotContains(t, output, \"No help topic for\", \"expect a help topic, got none\")\n\n\t\t\tfor _, shouldContain := range []string{\n\t\t\t\tcmd.Name, cmd.Description,\n\t\t\t\tsubCmdBar.Name, subCmdBar.Usage,\n\t\t\t\tsubCmdBaz.Name, subCmdBaz.Usage,\n\t\t\t} {\n\t\t\t\tassert.Contains(t, output, shouldContain, \"want help to contain %q, did not: \\n%q\", shouldContain, output)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommand_Run_SubcommandFullPath(t *testing.T) {\n\tout := &bytes.Buffer{}\n\n\tsubCmd := &Command{\n\t\tName:      \"bar\",\n\t\tUsage:     \"does bar things\",\n\t\tArgsUsage: \"[arguments...]\",\n\t}\n\n\tcmd := &Command{\n\t\tName:        \"foo\",\n\t\tDescription: \"foo commands\",\n\t\tCommands:    []*Command{subCmd},\n\t\tWriter:      out,\n\t}\n\n\trequire.NoError(t, cmd.Run(buildTestContext(t), []string{\"foo\", \"bar\", \"--help\"}))\n\n\toutString := out.String()\n\trequire.Contains(t, outString, \"foo bar - does bar things\")\n\trequire.Contains(t, outString, \"foo bar [command [command options]] [arguments...]\")\n}\n\nfunc TestCommand_Run_Help(t *testing.T) {\n\ttests := []struct {\n\t\thelpArguments []string\n\t\thideHelp      bool\n\t\twantContains  string\n\t\twantErr       error\n\t}{\n\t\t{\n\t\t\thelpArguments: []string{\"boom\", \"--help\"},\n\t\t\thideHelp:      false,\n\t\t\twantContains:  \"boom - make an explosive entrance\",\n\t\t},\n\t\t{\n\t\t\thelpArguments: []string{\"boom\", \"-h\"},\n\t\t\thideHelp:      false,\n\t\t\twantContains:  \"boom - make an explosive entrance\",\n\t\t},\n\t\t{\n\t\t\thelpArguments: []string{\"boom\", \"help\"},\n\t\t\thideHelp:      false,\n\t\t\twantContains:  \"boom - make an explosive entrance\",\n\t\t},\n\t\t{\n\t\t\thelpArguments: []string{\"boom\", \"--help\"},\n\t\t\thideHelp:      true,\n\t\t\twantErr:       fmt.Errorf(\"flag: help requested\"),\n\t\t},\n\t\t{\n\t\t\thelpArguments: []string{\"boom\", \"-h\"},\n\t\t\thideHelp:      true,\n\t\t\twantErr:       fmt.Errorf(\"flag: help requested\"),\n\t\t},\n\t\t{\n\t\t\thelpArguments: []string{\"boom\", \"help\"},\n\t\t\thideHelp:      true,\n\t\t\twantContains:  \"boom I say!\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"checking with arguments %v\", tt.helpArguments), func(t *testing.T) {\n\t\t\tbuf := new(bytes.Buffer)\n\n\t\t\tcmd := &Command{\n\t\t\t\tName:     \"boom\",\n\t\t\t\tUsage:    \"make an explosive entrance\",\n\t\t\t\tWriter:   buf,\n\t\t\t\tHideHelp: tt.hideHelp,\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tbuf.WriteString(\"boom I say!\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), tt.helpArguments)\n\t\t\tif tt.wantErr != nil {\n\t\t\t\tassert.ErrorContains(t, err, tt.wantErr.Error())\n\t\t\t}\n\n\t\t\toutput := buf.String()\n\n\t\t\tassert.Contains(t, output, tt.wantContains, \"want help to contain %q, did not: \\n%q\", \"boom - make an explosive entrance\", output)\n\t\t})\n\t}\n}\n\nfunc TestCommand_Run_Version(t *testing.T) {\n\tversionArguments := [][]string{{\"boom\", \"--version\"}, {\"boom\", \"-v\"}}\n\n\tfor _, args := range versionArguments {\n\t\tt.Run(fmt.Sprintf(\"checking with arguments %v\", args), func(t *testing.T) {\n\t\t\tbuf := new(bytes.Buffer)\n\n\t\t\tcmd := &Command{\n\t\t\t\tName:    \"boom\",\n\t\t\t\tUsage:   \"make an explosive entrance\",\n\t\t\t\tVersion: \"0.1.0\",\n\t\t\t\tWriter:  buf,\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\tbuf.WriteString(\"boom I say!\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), args)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, buf.String(), \"0.1.0\", \"want version to contain 0.1.0\")\n\t\t})\n\t}\n}\n\nfunc TestCommand_Run_Categories(t *testing.T) {\n\tbuf := new(bytes.Buffer)\n\n\tcmd := &Command{\n\t\tName:     \"categories\",\n\t\tHideHelp: true,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:     \"command1\",\n\t\t\t\tCategory: \"1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command2\",\n\t\t\t\tCategory: \"1\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command3\",\n\t\t\t\tCategory: \"2\",\n\t\t\t},\n\t\t},\n\t\tWriter: buf,\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"categories\"})\n\n\texpect := commandCategories([]*commandCategory{\n\t\t{\n\t\t\tname: \"1\",\n\t\t\tcommands: []*Command{\n\t\t\t\tcmd.Commands[0],\n\t\t\t\tcmd.Commands[1],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"2\",\n\t\t\tcommands: []*Command{\n\t\t\t\tcmd.Commands[2],\n\t\t\t},\n\t\t},\n\t})\n\n\trequire.Equal(t, &expect, cmd.categories)\n\n\toutput := buf.String()\n\n\tassert.Contains(t, output, \"1:\\n     command1\", \"want buffer to include category %q, did not: \\n%q\", \"1:\\n     command1\", output)\n}\n\nfunc TestCommand_VisibleCategories(t *testing.T) {\n\tcmd := &Command{\n\t\tName:     \"visible-categories\",\n\t\tHideHelp: true,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:     \"command1\",\n\t\t\t\tCategory: \"1\",\n\t\t\t\tHidden:   true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command2\",\n\t\t\t\tCategory: \"2\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command3\",\n\t\t\t\tCategory: \"3\",\n\t\t\t},\n\t\t},\n\t}\n\n\texpected := []CommandCategory{\n\t\t&commandCategory{\n\t\t\tname: \"2\",\n\t\t\tcommands: []*Command{\n\t\t\t\tcmd.Commands[1],\n\t\t\t},\n\t\t},\n\t\t&commandCategory{\n\t\t\tname: \"3\",\n\t\t\tcommands: []*Command{\n\t\t\t\tcmd.Commands[2],\n\t\t\t},\n\t\t},\n\t}\n\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\tassert.Equal(t, expected, cmd.VisibleCategories())\n\n\tcmd = &Command{\n\t\tName:     \"visible-categories\",\n\t\tHideHelp: true,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:     \"command1\",\n\t\t\t\tCategory: \"1\",\n\t\t\t\tHidden:   true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command2\",\n\t\t\t\tCategory: \"2\",\n\t\t\t\tHidden:   true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command3\",\n\t\t\t\tCategory: \"3\",\n\t\t\t},\n\t\t},\n\t}\n\n\texpected = []CommandCategory{\n\t\t&commandCategory{\n\t\t\tname: \"3\",\n\t\t\tcommands: []*Command{\n\t\t\t\tcmd.Commands[2],\n\t\t\t},\n\t\t},\n\t}\n\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\tassert.Equal(t, expected, cmd.VisibleCategories())\n\n\tcmd = &Command{\n\t\tName:     \"visible-categories\",\n\t\tHideHelp: true,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:     \"command1\",\n\t\t\t\tCategory: \"1\",\n\t\t\t\tHidden:   true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command2\",\n\t\t\t\tCategory: \"2\",\n\t\t\t\tHidden:   true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"command3\",\n\t\t\t\tCategory: \"3\",\n\t\t\t\tHidden:   true,\n\t\t\t},\n\t\t},\n\t}\n\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\tassert.Empty(t, cmd.VisibleCategories())\n}\n\nfunc TestCommand_Run_SubcommandDoesNotOverwriteErrorFromBefore(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"sub\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tName:   \"bar\",\n\t\t\t\tBefore: func(context.Context, *Command) (context.Context, error) { return nil, fmt.Errorf(\"before error\") },\n\t\t\t\tAfter:  func(context.Context, *Command) error { return fmt.Errorf(\"after error\") },\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"bar\"})\n\tassert.ErrorContains(t, err, \"before error\")\n\tassert.ErrorContains(t, err, \"after error\")\n}\n\nfunc TestCommand_OnUsageError_WithWrongFlagValue_ForSubcommand(t *testing.T) {\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"flag\"},\n\t\t},\n\t\tOnUsageError: func(_ context.Context, _ *Command, err error, isSubcommand bool) error {\n\t\t\tassert.False(t, isSubcommand, \"Expect subcommand\")\n\t\t\tassert.ErrorContains(t, err, \"invalid value \\\"wrong\\\"\")\n\t\t\treturn errors.New(\"intercepted: \" + err.Error())\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"bar\",\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"--flag=wrong\", \"bar\"})\n\tassert.ErrorContains(t, err, \"intercepted: invalid value\", \"Expect an intercepted error\")\n}\n\n// A custom flag that conforms to the relevant interfaces, but has none of the\n// fields that the other flag types do.\ntype customBoolFlag struct {\n\tNombre string\n}\n\n// Don't use the normal FlagStringer\nfunc (c *customBoolFlag) String() string {\n\treturn \"***\" + c.Nombre + \"***\"\n}\n\nfunc (c *customBoolFlag) Names() []string {\n\treturn []string{c.Nombre}\n}\n\nfunc (c *customBoolFlag) TakesValue() bool {\n\treturn false\n}\n\nfunc (c *customBoolFlag) GetValue() string {\n\treturn \"value\"\n}\n\nfunc (c *customBoolFlag) GetUsage() string {\n\treturn \"usage\"\n}\n\nfunc (c *customBoolFlag) Apply(set *flag.FlagSet) error {\n\tset.String(c.Nombre, c.Nombre, \"\")\n\treturn nil\n}\n\nfunc (c *customBoolFlag) RunAction(context.Context, *Command) error {\n\treturn nil\n}\n\nfunc (c *customBoolFlag) IsSet() bool {\n\treturn false\n}\n\nfunc (c *customBoolFlag) IsRequired() bool {\n\treturn false\n}\n\nfunc (c *customBoolFlag) IsVisible() bool {\n\treturn false\n}\n\nfunc (c *customBoolFlag) GetCategory() string {\n\treturn \"\"\n}\n\nfunc (c *customBoolFlag) GetEnvVars() []string {\n\treturn nil\n}\n\nfunc (c *customBoolFlag) GetDefaultText() string {\n\treturn \"\"\n}\n\nfunc TestCustomFlagsUnused(t *testing.T) {\n\tcmd := &Command{\n\t\tFlags:  []Flag{&customBoolFlag{\"custom\"}},\n\t\tWriter: io.Discard,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\"})\n\tassert.NoError(t, err, \"Run returned unexpected error\")\n}\n\nfunc TestCustomFlagsUsed(t *testing.T) {\n\tcmd := &Command{\n\t\tFlags:  []Flag{&customBoolFlag{\"custom\"}},\n\t\tWriter: io.Discard,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"--custom=bar\"})\n\tassert.NoError(t, err, \"Run returned unexpected error\")\n}\n\nfunc TestCustomHelpVersionFlags(t *testing.T) {\n\tcmd := &Command{\n\t\tWriter: io.Discard,\n\t}\n\n\t// Be sure to reset the global flags\n\tdefer func(helpFlag Flag, versionFlag Flag) {\n\t\tHelpFlag = helpFlag.(*BoolFlag)\n\t\tVersionFlag = versionFlag.(*BoolFlag)\n\t}(HelpFlag, VersionFlag)\n\n\tHelpFlag = &customBoolFlag{\"help-custom\"}\n\tVersionFlag = &customBoolFlag{\"version-custom\"}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"--help-custom=bar\"})\n\tassert.NoError(t, err, \"Run returned unexpected error\")\n}\n\nfunc TestHandleExitCoder_Default(t *testing.T) {\n\tapp := buildMinimalTestCommand()\n\tfs, err := newFlagSet(app.Name, app.Flags)\n\tassert.NoError(t, err, \"error creating FlagSet\")\n\n\tapp.flagSet = fs\n\n\t_ = app.handleExitCoder(context.Background(), Exit(\"Default Behavior Error\", 42))\n\n\toutput := fakeErrWriter.String()\n\tassert.Contains(t, output, \"Default\", \"Expected Default Behavior from Error Handler\")\n}\n\nfunc TestHandleExitCoder_Custom(t *testing.T) {\n\tcmd := buildMinimalTestCommand()\n\n\tcmd.ExitErrHandler = func(context.Context, *Command, error) {\n\t\t_, _ = fmt.Fprintln(ErrWriter, \"I'm a Custom error handler, I print what I want!\")\n\t}\n\n\t_ = cmd.handleExitCoder(context.Background(), Exit(\"Default Behavior Error\", 42))\n\n\toutput := fakeErrWriter.String()\n\tassert.Contains(t, output, \"Custom\", \"Expected Custom Behavior from Error Handler\")\n}\n\nfunc TestShellCompletionForIncompleteFlags(t *testing.T) {\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{\n\t\t\t\tName: \"test-completion\",\n\t\t\t},\n\t\t},\n\t\tEnableShellCompletion: true,\n\t\tShellComplete: func(_ context.Context, cmd *Command) {\n\t\t\tfor _, command := range cmd.Commands {\n\t\t\t\tif command.Hidden {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor _, name := range command.Names() {\n\t\t\t\t\t_, _ = fmt.Fprintln(cmd.Writer, name)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor _, fl := range cmd.Flags {\n\t\t\t\tfor _, name := range fl.Names() {\n\t\t\t\t\tif name == GenerateShellCompletionFlag.Names()[0] {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch name = strings.TrimSpace(name); len(name) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t_, _ = fmt.Fprintln(cmd.Writer, \"-\"+name)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_, _ = fmt.Fprintln(cmd.Writer, \"--\"+name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tAction: func(context.Context, *Command) error {\n\t\t\treturn fmt.Errorf(\"should not get here\")\n\t\t},\n\t\tWriter: io.Discard,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"\", \"--test-completion\", completionFlag})\n\tassert.NoError(t, err, \"app should not return an error\")\n}\n\nfunc TestWhenExitSubCommandWithCodeThenCommandQuitUnexpectedly(t *testing.T) {\n\ttestCode := 104\n\n\tcmd := buildMinimalTestCommand()\n\tcmd.Commands = []*Command{\n\t\t{\n\t\t\tName: \"cmd\",\n\t\t\tCommands: []*Command{\n\t\t\t\t{\n\t\t\t\t\tName: \"subcmd\",\n\t\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\t\treturn Exit(\"exit error\", testCode)\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// set user function as ExitErrHandler\n\texitCodeFromExitErrHandler := int(0)\n\tcmd.ExitErrHandler = func(_ context.Context, _ *Command, err error) {\n\t\tif exitErr, ok := err.(ExitCoder); ok {\n\t\t\texitCodeFromExitErrHandler = exitErr.ExitCode()\n\t\t}\n\t}\n\n\t// keep and restore original OsExiter\n\torigExiter := OsExiter\n\tt.Cleanup(func() { OsExiter = origExiter })\n\n\t// set user function as OsExiter\n\texitCodeFromOsExiter := int(0)\n\tOsExiter = func(exitCode int) {\n\t\texitCodeFromOsExiter = exitCode\n\t}\n\n\tr := require.New(t)\n\n\tr.Error(cmd.Run(buildTestContext(t), []string{\n\t\t\"myapp\",\n\t\t\"cmd\",\n\t\t\"subcmd\",\n\t}))\n\n\tr.Equal(0, exitCodeFromOsExiter)\n\tr.Equal(testCode, exitCodeFromExitErrHandler)\n}\n\nfunc buildMinimalTestCommand() *Command {\n\t// reset the help flag because tests may have set it\n\tHelpFlag.(*BoolFlag).hasBeenSet = false\n\treturn &Command{Writer: io.Discard}\n}\n\nfunc TestSetupInitializesBothWriters(t *testing.T) {\n\tcmd := &Command{}\n\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\n\tassert.Equal(t, cmd.ErrWriter, os.Stderr, \"expected a.ErrWriter to be os.Stderr\")\n\tassert.Equal(t, cmd.Writer, os.Stdout, \"expected a.Writer to be os.Stdout\")\n}\n\nfunc TestSetupInitializesOnlyNilWriters(t *testing.T) {\n\twr := &bytes.Buffer{}\n\tcmd := &Command{\n\t\tErrWriter: wr,\n\t}\n\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\n\tassert.Equal(t, cmd.ErrWriter, wr, \"expected a.ErrWriter to be a *bytes.Buffer instance\")\n\tassert.Equal(t, cmd.Writer, os.Stdout, \"expected a.Writer to be os.Stdout\")\n}\n\nfunc TestFlagAction(t *testing.T) {\n\tnow := time.Now().UTC().Truncate(time.Minute)\n\ttestCases := []struct {\n\t\tname string\n\t\targs []string\n\t\terr  string\n\t\texp  string\n\t}{\n\t\t{\n\t\t\tname: \"flag_string\",\n\t\t\targs: []string{\"app\", \"--f_string=string\"},\n\t\t\texp:  \"string \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_string_error\",\n\t\t\targs: []string{\"app\", \"--f_string=\"},\n\t\t\terr:  \"empty string\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_string_slice\",\n\t\t\targs: []string{\"app\", \"--f_string_slice=s1,s2,s3\"},\n\t\t\texp:  \"[s1 s2 s3] \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_string_slice_error\",\n\t\t\targs: []string{\"app\", \"--f_string_slice=err\"},\n\t\t\terr:  \"error string slice\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_bool\",\n\t\t\targs: []string{\"app\", \"--f_bool\"},\n\t\t\texp:  \"true \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_bool_error\",\n\t\t\targs: []string{\"app\", \"--f_bool=false\"},\n\t\t\terr:  \"value is false\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_duration\",\n\t\t\targs: []string{\"app\", \"--f_duration=1h30m20s\"},\n\t\t\texp:  \"1h30m20s \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_duration_error\",\n\t\t\targs: []string{\"app\", \"--f_duration=0\"},\n\t\t\terr:  \"empty duration\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_float64\",\n\t\t\targs: []string{\"app\", \"--f_float64=3.14159\"},\n\t\t\texp:  \"3.14159 \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_float64_error\",\n\t\t\targs: []string{\"app\", \"--f_float64=-1\"},\n\t\t\terr:  \"negative float64\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_float64_slice\",\n\t\t\targs: []string{\"app\", \"--f_float64_slice=1.1,2.2,3.3\"},\n\t\t\texp:  \"[1.1 2.2 3.3] \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_float64_slice_error\",\n\t\t\targs: []string{\"app\", \"--f_float64_slice=-1\"},\n\t\t\terr:  \"invalid float64 slice\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_int\",\n\t\t\targs: []string{\"app\", \"--f_int=1\"},\n\t\t\texp:  \"1 \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_int_error\",\n\t\t\targs: []string{\"app\", \"--f_int=-1\"},\n\t\t\terr:  \"negative int\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_int_slice\",\n\t\t\targs: []string{\"app\", \"--f_int_slice=1,2,3\"},\n\t\t\texp:  \"[1 2 3] \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_int_slice_error\",\n\t\t\targs: []string{\"app\", \"--f_int_slice=-1\"},\n\t\t\terr:  \"invalid int slice\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_timestamp\",\n\t\t\targs: []string{\"app\", \"--f_timestamp\", now.Format(time.DateTime)},\n\t\t\texp:  now.UTC().Format(time.RFC3339) + \" \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_timestamp_error\",\n\t\t\targs: []string{\"app\", \"--f_timestamp\", \"0001-01-01 00:00:00\"},\n\t\t\terr:  \"zero timestamp\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_uint\",\n\t\t\targs: []string{\"app\", \"--f_uint=1\"},\n\t\t\texp:  \"1 \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_uint_error\",\n\t\t\targs: []string{\"app\", \"--f_uint=0\"},\n\t\t\terr:  \"zero uint64\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_no_action\",\n\t\t\targs: []string{\"app\", \"--f_no_action=\"},\n\t\t\texp:  \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"command_flag\",\n\t\t\targs: []string{\"app\", \"c1\", \"--f_string=c1\"},\n\t\t\texp:  \"c1 \",\n\t\t},\n\t\t{\n\t\t\tname: \"subCommand_flag\",\n\t\t\targs: []string{\"app\", \"c1\", \"sub1\", \"--f_string=sub1\"},\n\t\t\texp:  \"sub1 \",\n\t\t},\n\t\t{\n\t\t\tname: \"mixture\",\n\t\t\targs: []string{\"app\", \"--f_string=app\", \"--f_uint=1\", \"--f_int_slice=1,2,3\", \"--f_duration=1h30m20s\", \"c1\", \"--f_string=c1\", \"sub1\", \"--f_string=sub1\"},\n\t\t\texp:  \"sub1 1h30m20s [1 2 3] 1 sub1 sub1 \",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_string_map\",\n\t\t\targs: []string{\"app\", \"--f_string_map=s1=s2,s3=\"},\n\t\t\texp:  \"map[s1:s2 s3:]\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag_string_map_error\",\n\t\t\targs: []string{\"app\", \"--f_string_map=err=\"},\n\t\t\terr:  \"error string map\",\n\t\t},\n\t}\n\n\tfor _, test := range testCases {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tout := &bytes.Buffer{}\n\n\t\t\tstringFlag := &StringFlag{\n\t\t\t\tName: \"f_string\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command, v string) error {\n\t\t\t\t\tif v == \"\" {\n\t\t\t\t\t\treturn fmt.Errorf(\"empty string\")\n\t\t\t\t\t}\n\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(v + \" \"))\n\t\t\t\t\treturn err\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tcmd := &Command{\n\t\t\t\tWriter: out,\n\t\t\t\tName:   \"app\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:   \"c1\",\n\t\t\t\t\t\tFlags:  []Flag{stringFlag},\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command) error { return nil },\n\t\t\t\t\t\tCommands: []*Command{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:   \"sub1\",\n\t\t\t\t\t\t\t\tAction: func(context.Context, *Command) error { return nil },\n\t\t\t\t\t\t\t\tFlags:  []Flag{stringFlag},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\tstringFlag,\n\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\tName: \"f_no_action\",\n\t\t\t\t\t},\n\t\t\t\t\t&StringSliceFlag{\n\t\t\t\t\t\tName: \"f_string_slice\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v []string) error {\n\t\t\t\t\t\t\tif v[0] == \"err\" {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"error string slice\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(fmt.Sprintf(\"%v \", v)))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&BoolFlag{\n\t\t\t\t\t\tName: \"f_bool\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v bool) error {\n\t\t\t\t\t\t\tif !v {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"value is false\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(fmt.Sprintf(\"%t \", v)))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&DurationFlag{\n\t\t\t\t\t\tName: \"f_duration\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v time.Duration) error {\n\t\t\t\t\t\t\tif v == 0 {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"empty duration\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(v.String() + \" \"))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&FloatFlag{\n\t\t\t\t\t\tName: \"f_float64\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v float64) error {\n\t\t\t\t\t\t\tif v < 0 {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"negative float64\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(strconv.FormatFloat(v, 'f', -1, 64) + \" \"))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&FloatSliceFlag{\n\t\t\t\t\t\tName: \"f_float64_slice\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v []float64) error {\n\t\t\t\t\t\t\tif len(v) > 0 && v[0] < 0 {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"invalid float64 slice\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(fmt.Sprintf(\"%v \", v)))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\tName: \"f_int\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v int64) error {\n\t\t\t\t\t\t\tif v < 0 {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"negative int\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(fmt.Sprintf(\"%v \", v)))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&IntSliceFlag{\n\t\t\t\t\t\tName: \"f_int_slice\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v []int64) error {\n\t\t\t\t\t\t\tif len(v) > 0 && v[0] < 0 {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"invalid int slice\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(fmt.Sprintf(\"%v \", v)))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&TimestampFlag{\n\t\t\t\t\t\tName: \"f_timestamp\",\n\t\t\t\t\t\tConfig: TimestampConfig{\n\t\t\t\t\t\t\tTimezone: time.UTC,\n\t\t\t\t\t\t\tLayouts:  []string{time.DateTime},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v time.Time) error {\n\t\t\t\t\t\t\tif v.IsZero() {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"zero timestamp\")\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(v.Format(time.RFC3339) + \" \"))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&UintFlag{\n\t\t\t\t\t\tName: \"f_uint\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v uint64) error {\n\t\t\t\t\t\t\tif v == 0 {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"zero uint64\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(fmt.Sprintf(\"%v \", v)))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&StringMapFlag{\n\t\t\t\t\t\tName: \"f_string_map\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command, v map[string]string) error {\n\t\t\t\t\t\t\tif _, ok := v[\"err\"]; ok {\n\t\t\t\t\t\t\t\treturn fmt.Errorf(\"error string map\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_, err := cmd.Root().Writer.Write([]byte(fmt.Sprintf(\"%v\", v)))\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(context.Context, *Command) error { return nil },\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), test.args)\n\n\t\t\tr := require.New(t)\n\n\t\t\tif test.err != \"\" {\n\t\t\t\tr.EqualError(err, test.err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tr.NoError(err)\n\t\t\tr.Equal(test.exp, out.String())\n\t\t})\n\t}\n}\n\nfunc TestPersistentFlag(t *testing.T) {\n\tvar topInt, topPersistentInt, subCommandInt, appOverrideInt int64\n\tvar appFlag string\n\tvar appRequiredFlag string\n\tvar appOverrideCmdInt int64\n\tvar appSliceFloat64 []float64\n\tvar persistentCommandSliceInt []int64\n\tvar persistentFlagActionCount int64\n\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName:        \"persistentCommandFlag\",\n\t\t\t\tDestination: &appFlag,\n\t\t\t\tAction: func(context.Context, *Command, string) error {\n\t\t\t\t\tpersistentFlagActionCount++\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t\t&IntSliceFlag{\n\t\t\t\tName:        \"persistentCommandSliceFlag\",\n\t\t\t\tDestination: &persistentCommandSliceInt,\n\t\t\t},\n\t\t\t&FloatSliceFlag{\n\t\t\t\tName:  \"persistentCommandFloatSliceFlag\",\n\t\t\t\tValue: []float64{11.3, 12.5},\n\t\t\t},\n\t\t\t&IntFlag{\n\t\t\t\tName:        \"persistentCommandOverrideFlag\",\n\t\t\t\tDestination: &appOverrideInt,\n\t\t\t},\n\t\t\t&StringFlag{\n\t\t\t\tName:        \"persistentRequiredCommandFlag\",\n\t\t\t\tRequired:    true,\n\t\t\t\tDestination: &appRequiredFlag,\n\t\t\t},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"cmd\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\tName:        \"cmdFlag\",\n\t\t\t\t\t\tDestination: &topInt,\n\t\t\t\t\t\tLocal:       true,\n\t\t\t\t\t},\n\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\tName:        \"cmdPersistentFlag\",\n\t\t\t\t\t\tDestination: &topPersistentInt,\n\t\t\t\t\t},\n\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\tName:        \"paof\",\n\t\t\t\t\t\tAliases:     []string{\"persistentCommandOverrideFlag\"},\n\t\t\t\t\t\tDestination: &appOverrideCmdInt,\n\t\t\t\t\t\tLocal:       true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"subcmd\",\n\t\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\t\t\tName:        \"cmdFlag\",\n\t\t\t\t\t\t\t\tDestination: &subCommandInt,\n\t\t\t\t\t\t\t\tLocal:       true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\t\t\tappSliceFloat64 = cmd.FloatSlice(\"persistentCommandFloatSliceFlag\")\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\n\t\t\"app\",\n\t\t\"--persistentCommandFlag\", \"hello\",\n\t\t\"--persistentCommandSliceFlag\", \"100\",\n\t\t\"--persistentCommandOverrideFlag\", \"102\",\n\t\t\"cmd\",\n\t\t\"--cmdFlag\", \"12\",\n\t\t\"--persistentCommandSliceFlag\", \"102\",\n\t\t\"--persistentCommandFloatSliceFlag\", \"102.455\",\n\t\t\"--paof\", \"105\",\n\t\t\"--persistentRequiredCommandFlag\", \"hellor\",\n\t\t\"subcmd\",\n\t\t\"--cmdPersistentFlag\", \"20\",\n\t\t\"--cmdFlag\", \"11\",\n\t\t\"--persistentCommandFlag\", \"bar\",\n\t\t\"--persistentCommandSliceFlag\", \"130\",\n\t\t\"--persistentCommandFloatSliceFlag\", \"3.1445\",\n\t})\n\n\trequire.NoError(t, err)\n\n\tassert.Equal(t, \"bar\", appFlag)\n\tassert.Equal(t, \"hellor\", appRequiredFlag)\n\tassert.Equal(t, int64(12), topInt)\n\tassert.Equal(t, int64(20), topPersistentInt)\n\n\t// this should be changed from app since\n\t// cmd overrides it\n\tassert.Equal(t, int64(102), appOverrideInt)\n\tassert.Equal(t, int64(11), subCommandInt)\n\tassert.Equal(t, int64(105), appOverrideCmdInt)\n\tassert.Equal(t, []int64{100, 102, 130}, persistentCommandSliceInt)\n\tassert.Equal(t, []float64{102.455, 3.1445}, appSliceFloat64)\n\tassert.Equal(t, int64(2), persistentFlagActionCount, \"Expected persistent flag action to be called 2 times\")\n}\n\nfunc TestPersistentFlagIsSet(t *testing.T) {\n\tresult := \"\"\n\tresultIsSet := false\n\n\tapp := &Command{\n\t\tName: \"root\",\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName: \"result\",\n\t\t\t},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"sub\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tresult = cmd.String(\"result\")\n\t\t\t\t\tresultIsSet = cmd.IsSet(\"result\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := app.Run(context.Background(), []string{\"root\", \"--result\", \"before\", \"sub\"})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"before\", result)\n\trequire.True(t, resultIsSet)\n\n\terr = app.Run(context.Background(), []string{\"root\", \"sub\", \"--result\", \"after\"})\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"after\", result)\n\trequire.True(t, resultIsSet)\n}\n\nfunc TestRequiredFlagDelayed(t *testing.T) {\n\tsf := &StringFlag{\n\t\tName:     \"result\",\n\t\tRequired: true,\n\t}\n\n\texpectedErr := &errRequiredFlags{\n\t\tmissingFlags: []string{sf.Name},\n\t}\n\n\ttests := []struct {\n\t\tname        string\n\t\targs        []string\n\t\terrExpected error\n\t}{\n\t\t{\n\t\t\tname:        \"leaf help\",\n\t\t\targs:        []string{\"root\", \"sub\", \"-h\"},\n\t\t\terrExpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:        \"leaf action\",\n\t\t\targs:        []string{\"root\", \"sub\"},\n\t\t\terrExpected: expectedErr,\n\t\t},\n\t\t{\n\t\t\tname:        \"leaf flags set\",\n\t\t\targs:        []string{\"root\", \"sub\", \"--if\", \"10\"},\n\t\t\terrExpected: expectedErr,\n\t\t},\n\t\t{\n\t\t\tname:        \"leaf invalid flags set\",\n\t\t\targs:        []string{\"root\", \"sub\", \"--xx\"},\n\t\t\terrExpected: expectedErr,\n\t\t},\n\t}\n\n\tapp := &Command{\n\t\tName: \"root\",\n\t\tFlags: []Flag{\n\t\t\tsf,\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"sub\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\tName:     \"if\",\n\t\t\t\t\t\tRequired: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(ctx context.Context, c *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\terr := app.Run(context.Background(), test.args)\n\t\t\tif test.errExpected == nil {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t} else {\n\t\t\t\trequire.ErrorAs(t, err, &test.errExpected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRequiredPersistentFlag(t *testing.T) {\n\tapp := &Command{\n\t\tName: \"root\",\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName:     \"result\",\n\t\t\t\tRequired: true,\n\t\t\t},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"sub\",\n\t\t\t\tAction: func(ctx context.Context, c *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := app.Run(context.Background(), []string{\"root\", \"sub\"})\n\trequire.Error(t, err)\n\n\terr = app.Run(context.Background(), []string{\"root\", \"sub\", \"--result\", \"after\"})\n\trequire.NoError(t, err)\n}\n\nfunc TestFlagDuplicates(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\targs        []string\n\t\terrExpected bool\n\t}{\n\t\t{\n\t\t\tname: \"all args present once\",\n\t\t\targs: []string{\"foo\", \"--sflag\", \"hello\", \"--isflag\", \"1\", \"--isflag\", \"2\", \"--fsflag\", \"2.0\", \"--iflag\", \"10\"},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate non slice flag(duplicatable)\",\n\t\t\targs: []string{\"foo\", \"--sflag\", \"hello\", \"--isflag\", \"1\", \"--isflag\", \"2\", \"--fsflag\", \"2.0\", \"--iflag\", \"10\", \"--iflag\", \"20\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"duplicate non slice flag(non duplicatable)\",\n\t\t\targs:        []string{\"foo\", \"--sflag\", \"hello\", \"--isflag\", \"1\", \"--isflag\", \"2\", \"--fsflag\", \"2.0\", \"--iflag\", \"10\", \"--sflag\", \"trip\"},\n\t\t\terrExpected: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"duplicate slice flag(non duplicatable)\",\n\t\t\targs:        []string{\"foo\", \"--sflag\", \"hello\", \"--isflag\", \"1\", \"--isflag\", \"2\", \"--fsflag\", \"2.0\", \"--fsflag\", \"3.0\", \"--iflag\", \"10\"},\n\t\t\terrExpected: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\tName:     \"sflag\",\n\t\t\t\t\t\tOnlyOnce: true,\n\t\t\t\t\t},\n\t\t\t\t\t&IntSliceFlag{\n\t\t\t\t\t\tName: \"isflag\",\n\t\t\t\t\t},\n\t\t\t\t\t&FloatSliceFlag{\n\t\t\t\t\t\tName:     \"fsflag\",\n\t\t\t\t\t\tOnlyOnce: true,\n\t\t\t\t\t},\n\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\tName: \"iflag\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), test.args)\n\t\t\tif test.errExpected {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestShorthandCommand(t *testing.T) {\n\taf := func(p *int) ActionFunc {\n\t\treturn func(context.Context, *Command) error {\n\t\t\t*p = *p + 1\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tvar cmd1, cmd2 int\n\n\tcmd := &Command{\n\t\tPrefixMatchCommands: true,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:    \"cthdisd\",\n\t\t\t\tAliases: []string{\"cth\"},\n\t\t\t\tAction:  af(&cmd1),\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"cthertoop\",\n\t\t\t\tAliases: []string{\"cer\"},\n\t\t\t\tAction:  af(&cmd2),\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"cth\"})\n\tassert.NoError(t, err)\n\tassert.True(t, cmd1 == 1 && cmd2 == 0, \"Expected command1 to be triggered once\")\n\n\tcmd1 = 0\n\tcmd2 = 0\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"cthd\"})\n\tassert.NoError(t, err)\n\tassert.True(t, cmd1 == 1 && cmd2 == 0, \"Expected command1 to be triggered once\")\n\n\tcmd1 = 0\n\tcmd2 = 0\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"cthe\"})\n\tassert.NoError(t, err)\n\tassert.True(t, cmd1 == 1 && cmd2 == 0, \"Expected command1 to be triggered once\")\n\n\tcmd1 = 0\n\tcmd2 = 0\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"cthert\"})\n\tassert.NoError(t, err)\n\tassert.True(t, cmd1 == 0 && cmd2 == 1, \"Expected command1 to be triggered once\")\n\n\tcmd1 = 0\n\tcmd2 = 0\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"cthet\"})\n\tassert.NoError(t, err)\n\tassert.True(t, cmd1 == 0 && cmd2 == 1, \"Expected command1 to be triggered once\")\n}\n\nfunc TestCommand_Int(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Int64(\"myflag\", 12, \"doc\")\n\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Int64(\"top-flag\", 13, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\n\trequire.Equal(t, int64(12), cmd.Int(\"myflag\"))\n\trequire.Equal(t, int64(13), cmd.Int(\"top-flag\"))\n}\n\nfunc TestCommand_Uint(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Uint64(\"myflagUint\", uint64(13), \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Uint64(\"top-flag\", uint64(14), \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\n\trequire.Equal(t, uint64(13), cmd.Uint(\"myflagUint\"))\n\trequire.Equal(t, uint64(14), cmd.Uint(\"top-flag\"))\n}\n\nfunc TestCommand_Float64(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Float64(\"myflag\", float64(17), \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Float64(\"top-flag\", float64(18), \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\n\tr := require.New(t)\n\tr.Equal(float64(17), cmd.Float(\"myflag\"))\n\tr.Equal(float64(18), cmd.Float(\"top-flag\"))\n}\n\nfunc TestCommand_Duration(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Duration(\"myflag\", 12*time.Second, \"doc\")\n\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Duration(\"top-flag\", 13*time.Second, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\n\tr := require.New(t)\n\tr.Equal(12*time.Second, cmd.Duration(\"myflag\"))\n\tr.Equal(13*time.Second, cmd.Duration(\"top-flag\"))\n}\n\nfunc TestCommand_Timestamp(t *testing.T) {\n\tt1 := time.Time{}.Add(12 * time.Second)\n\tt2 := time.Time{}.Add(13 * time.Second)\n\n\tcmd := &Command{\n\t\tName: \"hello\",\n\t\tFlags: []Flag{\n\t\t\t&TimestampFlag{\n\t\t\t\tName:  \"myflag\",\n\t\t\t\tValue: t1,\n\t\t\t},\n\t\t},\n\t\tAction: func(ctx context.Context, c *Command) error {\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tpCmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&TimestampFlag{\n\t\t\t\tName:  \"top-flag\",\n\t\t\t\tValue: t2,\n\t\t\t},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\tcmd,\n\t\t},\n\t}\n\n\terr := pCmd.Run(context.Background(), []string{\"foo\", \"hello\"})\n\tassert.NoError(t, err)\n\n\tr := require.New(t)\n\tr.Equal(t1, cmd.Timestamp(\"myflag\"))\n\tr.Equal(t2, cmd.Timestamp(\"top-flag\"))\n}\n\nfunc TestCommand_String(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.String(\"myflag\", \"hello world\", \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.String(\"top-flag\", \"hai veld\", \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\n\tr := require.New(t)\n\tr.Equal(\"hello world\", cmd.String(\"myflag\"))\n\tr.Equal(\"hai veld\", cmd.String(\"top-flag\"))\n\n\tcmd = &Command{parent: pCmd}\n\tr.Equal(\"hai veld\", cmd.String(\"top-flag\"))\n}\n\nfunc TestCommand_Bool(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"myflag\", false, \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Bool(\"top-flag\", true, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\n\tr := require.New(t)\n\tr.False(cmd.Bool(\"myflag\"))\n\tr.True(cmd.Bool(\"top-flag\"))\n}\n\nfunc TestCommand_Value(t *testing.T) {\n\tsubCmd := &Command{\n\t\tName: \"test\",\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{\n\t\t\t\tName:    \"myflag\",\n\t\t\t\tUsage:   \"doc\",\n\t\t\t\tAliases: []string{\"m\", \"mf\"},\n\t\t\t},\n\t\t},\n\t\tAction: func(ctx context.Context, c *Command) error {\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{\n\t\t\t\tName:    \"top-flag\",\n\t\t\t\tUsage:   \"doc\",\n\t\t\t\tAliases: []string{\"t\", \"tf\"},\n\t\t\t},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\tsubCmd,\n\t\t},\n\t}\n\tt.Run(\"flag name\", func(t *testing.T) {\n\t\tr := require.New(t)\n\t\terr := cmd.Run(buildTestContext(t), []string{\"main\", \"--top-flag\", \"13\", \"test\", \"--myflag\", \"14\"})\n\n\t\tr.NoError(err)\n\t\tr.Equal(int64(13), cmd.Value(\"top-flag\"))\n\t\tr.Equal(int64(13), cmd.Value(\"t\"))\n\t\tr.Equal(int64(13), cmd.Value(\"tf\"))\n\n\t\tr.Equal(int64(14), subCmd.Value(\"myflag\"))\n\t\tr.Equal(int64(14), subCmd.Value(\"m\"))\n\t\tr.Equal(int64(14), subCmd.Value(\"mf\"))\n\t})\n\n\tt.Run(\"flag aliases\", func(t *testing.T) {\n\t\tr := require.New(t)\n\t\terr := cmd.Run(buildTestContext(t), []string{\"main\", \"-tf\", \"15\", \"test\", \"-m\", \"16\"})\n\n\t\tr.NoError(err)\n\t\tr.Equal(int64(15), cmd.Value(\"top-flag\"))\n\t\tr.Equal(int64(15), cmd.Value(\"t\"))\n\t\tr.Equal(int64(15), cmd.Value(\"tf\"))\n\n\t\tr.Equal(int64(16), subCmd.Value(\"myflag\"))\n\t\tr.Equal(int64(16), subCmd.Value(\"m\"))\n\t\tr.Equal(int64(16), subCmd.Value(\"mf\"))\n\t\tr.Nil(cmd.Value(\"unknown-flag\"))\n\t})\n}\n\nfunc TestCommand_Value_InvalidFlagAccessHandler(t *testing.T) {\n\tvar flagName string\n\tcmd := &Command{\n\t\tInvalidFlagAccessHandler: func(_ context.Context, _ *Command, name string) {\n\t\t\tflagName = name\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"command\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"subcommand\",\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\t\t\tcmd.Value(\"missing\")\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tr := require.New(t)\n\n\tr.NoError(cmd.Run(buildTestContext(t), []string{\"run\", \"command\", \"subcommand\"}))\n\tr.Equal(\"missing\", flagName)\n}\n\nfunc TestCommand_Args(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"myflag\", false, \"doc\")\n\tcmd := &Command{flagSet: set}\n\t_ = set.Parse([]string{\"--myflag\", \"bat\", \"baz\"})\n\n\tr := require.New(t)\n\tr.Equal(2, cmd.Args().Len())\n\tr.True(cmd.Bool(\"myflag\"))\n}\n\nfunc TestCommand_NArg(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"myflag\", false, \"doc\")\n\tcmd := &Command{flagSet: set}\n\t_ = set.Parse([]string{\"--myflag\", \"bat\", \"baz\"})\n\n\trequire.Equal(t, 2, cmd.NArg())\n}\n\nfunc TestCommand_IsSet(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"one-flag\", false, \"doc\")\n\tset.Bool(\"two-flag\", false, \"doc\")\n\tset.String(\"three-flag\", \"hello world\", \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Bool(\"top-flag\", true, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\n\t_ = set.Parse([]string{\"--one-flag\", \"--two-flag\", \"--three-flag\", \"frob\"})\n\t_ = parentSet.Parse([]string{\"--top-flag\"})\n\n\tr := require.New(t)\n\n\tr.True(cmd.IsSet(\"one-flag\"))\n\tr.True(cmd.IsSet(\"two-flag\"))\n\tr.True(cmd.IsSet(\"three-flag\"))\n\tr.True(cmd.IsSet(\"top-flag\"))\n\tr.False(cmd.IsSet(\"bogus\"))\n}\n\n// XXX Corresponds to hack in context.IsSet for flags with EnvVar field\n// Should be moved to `flag_test` in v2\nfunc TestCommand_IsSet_fromEnv(t *testing.T) {\n\tvar (\n\t\ttimeoutIsSet, tIsSet    bool\n\t\tnoEnvVarIsSet, nIsSet   bool\n\t\tpasswordIsSet, pIsSet   bool\n\t\tunparsableIsSet, uIsSet bool\n\t)\n\n\tt.Setenv(\"APP_TIMEOUT_SECONDS\", \"15.5\")\n\tt.Setenv(\"APP_PASSWORD\", \"\")\n\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatFlag{Name: \"timeout\", Aliases: []string{\"t\"}, Local: true, Sources: EnvVars(\"APP_TIMEOUT_SECONDS\")},\n\t\t\t&StringFlag{Name: \"password\", Aliases: []string{\"p\"}, Local: true, Sources: EnvVars(\"APP_PASSWORD\")},\n\t\t\t&FloatFlag{Name: \"unparsable\", Aliases: []string{\"u\"}, Local: true, Sources: EnvVars(\"APP_UNPARSABLE\")},\n\t\t\t&FloatFlag{Name: \"no-env-var\", Aliases: []string{\"n\"}, Local: true},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\ttimeoutIsSet = cmd.IsSet(\"timeout\")\n\t\t\ttIsSet = cmd.IsSet(\"t\")\n\t\t\tpasswordIsSet = cmd.IsSet(\"password\")\n\t\t\tpIsSet = cmd.IsSet(\"p\")\n\t\t\tunparsableIsSet = cmd.IsSet(\"unparsable\")\n\t\t\tuIsSet = cmd.IsSet(\"u\")\n\t\t\tnoEnvVarIsSet = cmd.IsSet(\"no-env-var\")\n\t\t\tnIsSet = cmd.IsSet(\"n\")\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tr := require.New(t)\n\n\tr.NoError(cmd.Run(buildTestContext(t), []string{\"run\"}))\n\tr.True(timeoutIsSet)\n\tr.True(tIsSet)\n\tr.True(passwordIsSet)\n\tr.True(pIsSet)\n\tr.False(noEnvVarIsSet)\n\tr.False(nIsSet)\n\n\tt.Setenv(\"APP_UNPARSABLE\", \"foobar\")\n\n\tr.Error(cmd.Run(buildTestContext(t), []string{\"run\"}))\n\tr.False(unparsableIsSet)\n\tr.False(uIsSet)\n}\n\nfunc TestCommand_NumFlags(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"myflag\", false, \"doc\")\n\tset.String(\"otherflag\", \"hello world\", \"doc\")\n\tglobalSet := flag.NewFlagSet(\"test\", 0)\n\tglobalSet.Bool(\"myflagGlobal\", true, \"doc\")\n\tglobalCmd := &Command{flagSet: globalSet}\n\tcmd := &Command{flagSet: set, parent: globalCmd}\n\t_ = set.Parse([]string{\"--myflag\", \"--otherflag=foo\"})\n\t_ = globalSet.Parse([]string{\"--myflagGlobal\"})\n\trequire.Equal(t, 2, cmd.NumFlags())\n}\n\nfunc TestCommand_Set(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Int64(\"int\", int64(5), \"an int\")\n\tcmd := &Command{flagSet: set}\n\n\tr := require.New(t)\n\n\tr.False(cmd.IsSet(\"int\"))\n\tr.NoError(cmd.Set(\"int\", \"1\"))\n\tr.Equal(int64(1), cmd.Int(\"int\"))\n\tr.True(cmd.IsSet(\"int\"))\n}\n\nfunc TestCommand_Set_InvalidFlagAccessHandler(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tvar flagName string\n\tcmd := &Command{\n\t\tInvalidFlagAccessHandler: func(_ context.Context, _ *Command, name string) {\n\t\t\tflagName = name\n\t\t},\n\t\tflagSet: set,\n\t}\n\n\tr := require.New(t)\n\n\tr.True(cmd.Set(\"missing\", \"\") != nil)\n\tr.Equal(\"missing\", flagName)\n}\n\nfunc TestCommand_LocalFlagNames(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"one-flag\", false, \"doc\")\n\tset.String(\"two-flag\", \"hello world\", \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Bool(\"top-flag\", true, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\t_ = set.Parse([]string{\"--one-flag\", \"--two-flag=foo\"})\n\t_ = parentSet.Parse([]string{\"--top-flag\"})\n\n\tactualFlags := cmd.LocalFlagNames()\n\tsort.Strings(actualFlags)\n\n\trequire.Equal(t, []string{\"one-flag\", \"two-flag\"}, actualFlags)\n}\n\nfunc TestCommand_FlagNames(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"one-flag\", false, \"doc\")\n\tset.String(\"two-flag\", \"hello world\", \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Bool(\"top-flag\", true, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\t_ = set.Parse([]string{\"--one-flag\", \"--two-flag=foo\"})\n\t_ = parentSet.Parse([]string{\"--top-flag\"})\n\n\tactualFlags := cmd.FlagNames()\n\tsort.Strings(actualFlags)\n\n\trequire.Equal(t, []string{\"one-flag\", \"top-flag\", \"two-flag\"}, actualFlags)\n}\n\nfunc TestCommand_Lineage(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"local-flag\", false, \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Bool(\"top-flag\", true, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\t_ = set.Parse([]string{\"--local-flag\"})\n\t_ = parentSet.Parse([]string{\"--top-flag\"})\n\n\tlineage := cmd.Lineage()\n\n\tr := require.New(t)\n\tr.Equal(2, len(lineage))\n\tr.Equal(cmd, lineage[0])\n\tr.Equal(pCmd, lineage[1])\n}\n\nfunc TestCommand_lookupFlagSet(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"local-flag\", false, \"doc\")\n\tparentSet := flag.NewFlagSet(\"test\", 0)\n\tparentSet.Bool(\"top-flag\", true, \"doc\")\n\tpCmd := &Command{flagSet: parentSet}\n\tcmd := &Command{flagSet: set, parent: pCmd}\n\t_ = set.Parse([]string{\"--local-flag\"})\n\t_ = parentSet.Parse([]string{\"--top-flag\"})\n\n\tr := require.New(t)\n\n\tfs := cmd.lookupFlagSet(\"top-flag\")\n\tr.Equal(pCmd.flagSet, fs)\n\n\tfs = cmd.lookupFlagSet(\"local-flag\")\n\tr.Equal(cmd.flagSet, fs)\n\tr.Nil(cmd.lookupFlagSet(\"frob\"))\n}\n\nfunc TestCommandAttributeAccessing(t *testing.T) {\n\ttdata := []struct {\n\t\ttestCase     string\n\t\tsetBoolInput string\n\t\tctxBoolInput string\n\t\tparent       *Command\n\t}{\n\t\t{\n\t\t\ttestCase:     \"empty\",\n\t\t\tsetBoolInput: \"\",\n\t\t\tctxBoolInput: \"\",\n\t\t},\n\t\t{\n\t\t\ttestCase:     \"empty_with_background_context\",\n\t\t\tsetBoolInput: \"\",\n\t\t\tctxBoolInput: \"\",\n\t\t\tparent:       &Command{},\n\t\t},\n\t\t{\n\t\t\ttestCase:     \"empty_set_bool_and_present_ctx_bool\",\n\t\t\tsetBoolInput: \"\",\n\t\t\tctxBoolInput: \"ctx-bool\",\n\t\t},\n\t\t{\n\t\t\ttestCase:     \"present_set_bool_and_present_ctx_bool_with_background_context\",\n\t\t\tsetBoolInput: \"\",\n\t\t\tctxBoolInput: \"ctx-bool\",\n\t\t\tparent:       &Command{},\n\t\t},\n\t\t{\n\t\t\ttestCase:     \"present_set_bool_and_present_ctx_bool\",\n\t\t\tsetBoolInput: \"ctx-bool\",\n\t\t\tctxBoolInput: \"ctx-bool\",\n\t\t},\n\t\t{\n\t\t\ttestCase:     \"present_set_bool_and_present_ctx_bool_with_background_context\",\n\t\t\tsetBoolInput: \"ctx-bool\",\n\t\t\tctxBoolInput: \"ctx-bool\",\n\t\t\tparent:       &Command{},\n\t\t},\n\t\t{\n\t\t\ttestCase:     \"present_set_bool_and_different_ctx_bool\",\n\t\t\tsetBoolInput: \"ctx-bool\",\n\t\t\tctxBoolInput: \"not-ctx-bool\",\n\t\t},\n\t\t{\n\t\t\ttestCase:     \"present_set_bool_and_different_ctx_bool_with_background_context\",\n\t\t\tsetBoolInput: \"ctx-bool\",\n\t\t\tctxBoolInput: \"not-ctx-bool\",\n\t\t\tparent:       &Command{},\n\t\t},\n\t}\n\n\tfor _, test := range tdata {\n\t\tt.Run(test.testCase, func(t *testing.T) {\n\t\t\tset := flag.NewFlagSet(\"some-flag-set-name\", 0)\n\t\t\tset.Bool(test.setBoolInput, false, \"usage documentation\")\n\t\t\tcmd := &Command{flagSet: set, parent: test.parent}\n\n\t\t\trequire.False(t, cmd.Bool(test.ctxBoolInput))\n\t\t})\n\t}\n}\n\nfunc TestCheckRequiredFlags(t *testing.T) {\n\ttdata := []struct {\n\t\ttestCase              string\n\t\tparseInput            []string\n\t\tenvVarInput           [2]string\n\t\tflags                 []Flag\n\t\texpectedAnError       bool\n\t\texpectedErrorContents []string\n\t}{\n\t\t{\n\t\t\ttestCase: \"empty\",\n\t\t},\n\t\t{\n\t\t\ttestCase: \"optional\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"optionalFlag\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t},\n\t\t\texpectedAnError:       true,\n\t\t\texpectedErrorContents: []string{\"requiredFlag\"},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_and_present\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t},\n\t\t\tparseInput: []string{\"--requiredFlag\", \"myinput\"},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_and_present_via_env_var\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true, Sources: EnvVars(\"REQUIRED_FLAG\")},\n\t\t\t},\n\t\t\tenvVarInput: [2]string{\"REQUIRED_FLAG\", \"true\"},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_and_optional\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t\t&StringFlag{Name: \"optionalFlag\"},\n\t\t\t},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_and_optional_and_optional_present\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t\t&StringFlag{Name: \"optionalFlag\"},\n\t\t\t},\n\t\t\tparseInput:      []string{\"--optionalFlag\", \"myinput\"},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_and_optional_and_optional_present_via_env_var\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t\t&StringFlag{Name: \"optionalFlag\", Sources: EnvVars(\"OPTIONAL_FLAG\")},\n\t\t\t},\n\t\t\tenvVarInput:     [2]string{\"OPTIONAL_FLAG\", \"true\"},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_and_optional_and_required_present\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t\t&StringFlag{Name: \"optionalFlag\"},\n\t\t\t},\n\t\t\tparseInput: []string{\"--requiredFlag\", \"myinput\"},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"two_required\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlagOne\", Required: true},\n\t\t\t\t&StringFlag{Name: \"requiredFlagTwo\", Required: true},\n\t\t\t},\n\t\t\texpectedAnError:       true,\n\t\t\texpectedErrorContents: []string{\"requiredFlagOne\", \"requiredFlagTwo\"},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"two_required_and_one_present\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t\t&StringFlag{Name: \"requiredFlagTwo\", Required: true},\n\t\t\t},\n\t\t\tparseInput:      []string{\"--requiredFlag\", \"myinput\"},\n\t\t\texpectedAnError: true,\n\t\t},\n\t\t{\n\t\t\ttestCase: \"two_required_and_both_present\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"requiredFlag\", Required: true},\n\t\t\t\t&StringFlag{Name: \"requiredFlagTwo\", Required: true},\n\t\t\t},\n\t\t\tparseInput: []string{\"--requiredFlag\", \"myinput\", \"--requiredFlagTwo\", \"myinput\"},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_flag_with_short_name\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringSliceFlag{Name: \"names\", Aliases: []string{\"N\"}, Required: true},\n\t\t\t},\n\t\t\tparseInput: []string{\"-N\", \"asd\", \"-N\", \"qwe\"},\n\t\t},\n\t\t{\n\t\t\ttestCase: \"required_flag_with_multiple_short_names\",\n\t\t\tflags: []Flag{\n\t\t\t\t&StringSliceFlag{Name: \"names\", Aliases: []string{\"N\", \"n\"}, Required: true},\n\t\t\t},\n\t\t\tparseInput: []string{\"-n\", \"asd\", \"-n\", \"qwe\"},\n\t\t},\n\t\t{\n\t\t\ttestCase:              \"required_flag_with_short_alias_not_printed_on_error\",\n\t\t\texpectedAnError:       true,\n\t\t\texpectedErrorContents: []string{\"Required flag \\\"names\\\" not set\"},\n\t\t\tflags: []Flag{\n\t\t\t\t&StringSliceFlag{Name: \"names\", Aliases: []string{\"n\"}, Required: true},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttestCase:              \"required_flag_with_one_character\",\n\t\t\texpectedAnError:       true,\n\t\t\texpectedErrorContents: []string{\"Required flag \\\"n\\\" not set\"},\n\t\t\tflags: []Flag{\n\t\t\t\t&StringFlag{Name: \"n\", Required: true},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tdata {\n\t\tt.Run(test.testCase, func(t *testing.T) {\n\t\t\t// setup\n\t\t\tif test.envVarInput[0] != \"\" {\n\t\t\t\tdefer resetEnv(os.Environ())\n\t\t\t\tos.Clearenv()\n\t\t\t\t_ = os.Setenv(test.envVarInput[0], test.envVarInput[1])\n\t\t\t}\n\n\t\t\tcmd := &Command{\n\t\t\t\tName:  \"foo\",\n\t\t\t\tFlags: test.flags,\n\t\t\t}\n\t\t\targs := []string{\"foo\"}\n\t\t\targs = append(args, test.parseInput...)\n\t\t\t_ = cmd.Run(context.Background(), args)\n\n\t\t\terr := cmd.checkAllRequiredFlags()\n\n\t\t\t// assertions\n\t\t\tif test.expectedAnError {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t}\n\t\t\tfor _, errString := range test.expectedErrorContents {\n\t\t\t\tif err != nil {\n\t\t\t\t\tassert.ErrorContains(t, err, errString)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCommand_ParentCommand_Set(t *testing.T) {\n\tparentSet := flag.NewFlagSet(\"parent\", flag.ContinueOnError)\n\tparentSet.String(\"Name\", \"\", \"\")\n\n\tcmd := &Command{\n\t\tflagSet: flag.NewFlagSet(\"child\", flag.ContinueOnError),\n\t\tparent: &Command{\n\t\t\tflagSet: parentSet,\n\t\t},\n\t}\n\n\terr := cmd.Set(\"Name\", \"aaa\")\n\tassert.NoError(t, err)\n}\n\nfunc TestCommandStringDashOption(t *testing.T) {\n\ttests := []struct {\n\t\tname                string\n\t\tshortOptionHandling bool\n\t\targs                []string\n\t}{\n\t\t{\n\t\t\tname: \"double dash separate value\",\n\t\t\targs: []string{\"foo\", \"--bar\", \"-\", \"test\"},\n\t\t},\n\t\t{\n\t\t\tname: \"single dash separate value\",\n\t\t\targs: []string{\"foo\", \"-bar\", \"-\", \"test\"},\n\t\t},\n\t\t{\n\t\t\tname:                \"single dash combined value\",\n\t\t\targs:                []string{\"foo\", \"-b-\", \"test\"},\n\t\t\tshortOptionHandling: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tName:                   \"foo\",\n\t\t\t\tUseShortOptionHandling: test.shortOptionHandling,\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\tName:    \"bar\",\n\t\t\t\t\t\tAliases: []string{\"b\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(ctx context.Context, c *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), test.args)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Equal(t, \"-\", cmd.String(\"b\"))\n\t\t})\n\t}\n}\n\nfunc TestCommandReadArgsFromStdIn(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tinput         string\n\t\targs          []string\n\t\texpectedInt   int64\n\t\texpectedFloat float64\n\t\texpectedSlice []string\n\t\texpectError   bool\n\t}{\n\t\t{\n\t\t\tname:          \"empty\",\n\t\t\tinput:         \"\",\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedInt:   0,\n\t\t\texpectedFloat: 0.0,\n\t\t\texpectedSlice: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"empty2\",\n\t\t\tinput: `\n\n\t\t\t`,\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedInt:   0,\n\t\t\texpectedFloat: 0.0,\n\t\t\texpectedSlice: []string{},\n\t\t},\n\t\t{\n\t\t\tname:          \"intflag-from-input\",\n\t\t\tinput:         \"--if=100\",\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedInt:   100,\n\t\t\texpectedFloat: 0.0,\n\t\t\texpectedSlice: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"intflag-from-input2\",\n\t\t\tinput: `\n\t\t\t--if\n\n\t\t\t100`,\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedInt:   100,\n\t\t\texpectedFloat: 0.0,\n\t\t\texpectedSlice: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"multiflag-from-input\",\n\t\t\tinput: `\n\t\t\t--if\n\n\t\t\t100\n\t\t\t--ff      100.1\n\n\t\t\t--ssf hello\n\t\t\t--ssf\n\n\t\t\t\"hello\n  123\n44\"\n\t\t\t`,\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedInt:   100,\n\t\t\texpectedFloat: 100.1,\n\t\t\texpectedSlice: []string{\"hello\", \"hello\\n  123\\n44\"},\n\t\t},\n\t\t{\n\t\t\tname: \"end-args\",\n\t\t\tinput: `\n\t\t\t--if\n\n\t\t\t100\n\t\t\t--\n\t\t\t--ff      100.1\n\n\t\t\t--ssf hello\n\t\t\t--ssf\n\n\t\t\thell02\n\t\t\t`,\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedInt:   100,\n\t\t\texpectedFloat: 0,\n\t\t\texpectedSlice: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string\",\n\t\t\tinput: `\n\t\t\t\"\n\t\t\t`,\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedInt:   0,\n\t\t\texpectedFloat: 0,\n\t\t\texpectedSlice: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid string2\",\n\t\t\tinput: `\n\t\t\t--if\n\t\t\t\"\n\t\t\t`,\n\t\t\targs:        []string{\"foo\"},\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"incomplete string\",\n\t\t\tinput: `\n\t\t\t--ssf\n\t\t\t\"\n\t\t\thello\n\t\t\t`,\n\t\t\targs:          []string{\"foo\"},\n\t\t\texpectedSlice: []string{\"hello\"},\n\t\t},\n\t}\n\n\tfor _, tst := range tests {\n\t\tt.Run(tst.name, func(t *testing.T) {\n\t\t\tr := require.New(t)\n\n\t\t\tfp, err := os.CreateTemp(\"\", \"readargs\")\n\t\t\tr.NoError(err)\n\t\t\t_, err = fp.Write([]byte(tst.input))\n\t\t\tr.NoError(err)\n\t\t\tfp.Close()\n\n\t\t\tcmd := buildMinimalTestCommand()\n\t\t\tcmd.ReadArgsFromStdin = true\n\t\t\tcmd.Reader, err = os.Open(fp.Name())\n\t\t\tr.NoError(err)\n\t\t\tcmd.Flags = []Flag{\n\t\t\t\t&IntFlag{\n\t\t\t\t\tName: \"if\",\n\t\t\t\t},\n\t\t\t\t&FloatFlag{\n\t\t\t\t\tName: \"ff\",\n\t\t\t\t},\n\t\t\t\t&StringSliceFlag{\n\t\t\t\t\tName: \"ssf\",\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tactionCalled := false\n\t\t\tcmd.Action = func(ctx context.Context, c *Command) error {\n\t\t\t\tr.Equal(tst.expectedInt, c.Int(\"if\"))\n\t\t\t\tr.Equal(tst.expectedFloat, c.Float(\"ff\"))\n\t\t\t\tr.Equal(tst.expectedSlice, c.StringSlice(\"ssf\"))\n\t\t\t\tactionCalled = true\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\terr = cmd.Run(context.Background(), tst.args)\n\t\t\tif !tst.expectError {\n\t\t\t\tr.NoError(err)\n\t\t\t\tr.True(actionCalled)\n\t\t\t} else {\n\t\t\t\tr.Error(err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestZeroValueCommand(t *testing.T) {\n\tvar cmd Command\n\tassert.NoError(t, cmd.Run(context.Background(), []string{\"foo\"}))\n}\n\nfunc TestCommandInvalidName(t *testing.T) {\n\tvar cmd Command\n\tassert.Equal(t, int64(0), cmd.Int(\"foo\"))\n\tassert.Equal(t, uint64(0), cmd.Uint(\"foo\"))\n\tassert.Equal(t, float64(0), cmd.Float(\"foo\"))\n\tassert.Equal(t, \"\", cmd.String(\"foo\"))\n\tassert.Equal(t, time.Time{}, cmd.Timestamp(\"foo\"))\n\tassert.Equal(t, time.Duration(0), cmd.Duration(\"foo\"))\n\n\tassert.Equal(t, []int64(nil), cmd.IntSlice(\"foo\"))\n\tassert.Equal(t, []uint64(nil), cmd.UintSlice(\"foo\"))\n\tassert.Equal(t, []float64(nil), cmd.FloatSlice(\"foo\"))\n\tassert.Equal(t, []string(nil), cmd.StringSlice(\"foo\"))\n}\n\nfunc TestCommandCategories(t *testing.T) {\n\tvar cc commandCategories = []*commandCategory{\n\t\t{\n\t\t\tname:     \"foo\",\n\t\t\tcommands: []*Command{},\n\t\t},\n\t\t{\n\t\t\tname:     \"bar\",\n\t\t\tcommands: []*Command{},\n\t\t},\n\t\t{\n\t\t\tname:     \"goo\",\n\t\t\tcommands: nil,\n\t\t},\n\t}\n\n\tsort.Sort(&cc)\n\n\tvar prev *commandCategory\n\tfor _, c := range cc {\n\t\tif prev != nil {\n\t\t\tassert.LessOrEqual(t, prev.name, c.name)\n\t\t}\n\t\tprev = c\n\t\tassert.Equal(t, []*Command(nil), c.VisibleCommands())\n\t}\n}\n\nfunc TestJSONExportCommand(t *testing.T) {\n\tcmd := buildExtendedTestCommand()\n\tcmd.Arguments = []Argument{\n\t\t&IntArg{\n\t\t\tName: \"fooi\",\n\t\t},\n\t}\n\n\tout, err := json.Marshal(cmd)\n\trequire.NoError(t, err)\n\n\texpected := `{\n\t\t\"name\": \"greet\",\n\t\t\"aliases\": null,\n\t\t\"usage\": \"Some app\",\n\t\t\"usageText\": \"app [first_arg] [second_arg]\",\n\t\t\"argsUsage\": \"\",\n\t\t\"version\": \"\",\n\t\t\"description\": \"Description of the application.\",\n\t\t\"defaultCommand\": \"\",\n\t\t\"category\": \"\",\n\t\t\"commands\": [\n\t\t  {\n\t\t\t\"name\": \"config\",\n\t\t\t\"aliases\": [\n\t\t\t  \"c\"\n\t\t\t],\n\t\t\t\"usage\": \"another usage test\",\n\t\t\t\"usageText\": \"\",\n\t\t\t\"argsUsage\": \"\",\n\t\t\t\"version\": \"\",\n\t\t\t\"description\": \"\",\n\t\t\t\"defaultCommand\": \"\",\n\t\t\t\"category\": \"\",\n\t\t\t\"commands\": [\n\t\t\t  {\n\t\t\t\t\"name\": \"sub-config\",\n\t\t\t\t\"aliases\": [\n\t\t\t\t  \"s\",\n\t\t\t\t  \"ss\"\n\t\t\t\t],\n\t\t\t\t\"usage\": \"another usage test\",\n\t\t\t\t\"usageText\": \"\",\n\t\t\t\t\"argsUsage\": \"\",\n\t\t\t\t\"version\": \"\",\n\t\t\t\t\"description\": \"\",\n\t\t\t\t\"defaultCommand\": \"\",\n\t\t\t\t\"category\": \"\",\n\t\t\t\t\"commands\": null,\n\t\t\t\t\"flags\": [\n\t\t\t\t  {\n\t\t\t\t\t\"name\": \"sub-flag\",\n\t\t\t\t\t\"category\": \"\",\n\t\t\t\t\t\"defaultText\": \"\",\n\t\t\t\t\t\"usage\": \"\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"hideDefault\": false,\n\t\t\t\t\t\"local\": false,\n\t\t\t\t\t\"defaultValue\": \"\",\n\t\t\t\t\t\"aliases\": [\n\t\t\t\t\t  \"sub-fl\",\n\t\t\t\t\t  \"s\"\n\t\t\t\t\t],\n\t\t\t\t\t\"takesFileArg\": false,\n\t\t\t\t\t\"config\": {\n\t\t\t\t\t  \"TrimSpace\": false\n\t\t\t\t\t},\n\t\t\t\t\t\"onlyOnce\": false,\n\t\t\t\t\t\"validateDefaults\" : false\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"name\": \"sub-command-flag\",\n\t\t\t\t\t\"category\": \"\",\n\t\t\t\t\t\"defaultText\": \"\",\n\t\t\t\t\t\"usage\": \"some usage text\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"hideDefault\": false,\n\t\t\t\t\t\"local\": false,\n\t\t\t\t\t\"defaultValue\": false,\n\t\t\t\t\t\"aliases\": [\n\t\t\t\t\t  \"s\"\n\t\t\t\t\t],\n\t\t\t\t\t\"takesFileArg\": false,\n\t\t\t\t\t\"config\": {\n\t\t\t\t\t  \"Count\": null\n\t\t\t\t\t},\n\t\t\t\t\t\"onlyOnce\": false,\n\t\t\t\t\t\"validateDefaults\" : false\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"hideHelp\": false,\n\t\t\t\t\"hideHelpCommand\": false,\n\t\t\t\t\"hideVersion\": false,\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"authors\": null,\n\t\t\t\t\"copyright\": \"\",\n\t\t\t\t\"metadata\": null,\n\t\t\t\t\"sliceFlagSeparator\": \"\",\n\t\t\t\t\"disableSliceFlagSeparator\": false,\n\t\t\t\t\"useShortOptionHandling\": false,\n\t\t\t\t\"suggest\": false,\n\t\t\t\t\"allowExtFlags\": false,\n\t\t\t\t\"skipFlagParsing\": false,\n\t\t\t\t\"prefixMatchCommands\": false,\n\t\t\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\t\t\"arguments\": null,\n\t\t\t\t\"readArgsFromStdin\": false\n\t\t\t  }\n\t\t\t],\n\t\t\t\"flags\": [\n\t\t\t  {\n\t\t\t\t\"name\": \"flag\",\n\t\t\t\t\"category\": \"\",\n\t\t\t\t\"defaultText\": \"\",\n\t\t\t\t\"usage\": \"\",\n\t\t\t\t\"required\": false,\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"hideDefault\": false,\n\t\t\t\t\"local\": false,\n\t\t\t\t\"defaultValue\": \"\",\n\t\t\t\t\"aliases\": [\n\t\t\t\t  \"fl\",\n\t\t\t\t  \"f\"\n\t\t\t\t],\n\t\t\t\t\"takesFileArg\": true,\n\t\t\t\t\"config\": {\n\t\t\t\t  \"TrimSpace\": false\n\t\t\t\t},\n\t\t\t\t\"onlyOnce\": false,\n\t\t\t\t\"validateDefaults\" : false\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"name\": \"another-flag\",\n\t\t\t\t\"category\": \"\",\n\t\t\t\t\"defaultText\": \"\",\n\t\t\t\t\"usage\": \"another usage text\",\n\t\t\t\t\"required\": false,\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"hideDefault\": false,\n\t\t\t\t\"local\": false,\n\t\t\t\t\"defaultValue\": false,\n\t\t\t\t\"aliases\": [\n\t\t\t\t  \"b\"\n\t\t\t\t],\n\t\t\t\t\"takesFileArg\": false,\n\t\t\t\t\"config\": {\n\t\t\t\t  \"Count\": null\n\t\t\t\t},\n\t\t\t\t\"onlyOnce\": false,\n\t\t\t\t\"validateDefaults\" : false\n\t\t\t  }\n\t\t\t],\n\t\t\t\"hideHelp\": false,\n\t\t\t\"hideHelpCommand\": false,\n\t\t\t\"hideVersion\": false,\n\t\t\t\"hidden\": false,\n\t\t\t\"authors\": null,\n\t\t\t\"copyright\": \"\",\n\t\t\t\"metadata\": null,\n\t\t\t\"sliceFlagSeparator\": \"\",\n\t\t\t\"disableSliceFlagSeparator\": false,\n\t\t\t\"useShortOptionHandling\": false,\n\t\t\t\"suggest\": false,\n\t\t\t\"allowExtFlags\": false,\n\t\t\t\"skipFlagParsing\": false,\n\t\t\t\"prefixMatchCommands\": false,\n\t\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\t\"arguments\": null,\n\t\t\t\"readArgsFromStdin\": false\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"info\",\n\t\t\t\"aliases\": [\n\t\t\t  \"i\",\n\t\t\t  \"in\"\n\t\t\t],\n\t\t\t\"usage\": \"retrieve generic information\",\n\t\t\t\"usageText\": \"\",\n\t\t\t\"argsUsage\": \"\",\n\t\t\t\"version\": \"\",\n\t\t\t\"description\": \"\",\n\t\t\t\"defaultCommand\": \"\",\n\t\t\t\"category\": \"\",\n\t\t\t\"commands\": null,\n\t\t\t\"flags\": null,\n\t\t\t\"hideHelp\": false,\n\t\t\t\"hideHelpCommand\": false,\n\t\t\t\"hideVersion\": false,\n\t\t\t\"hidden\": false,\n\t\t\t\"authors\": null,\n\t\t\t\"copyright\": \"\",\n\t\t\t\"metadata\": null,\n\t\t\t\"sliceFlagSeparator\": \"\",\n\t\t\t\"disableSliceFlagSeparator\": false,\n\t\t\t\"useShortOptionHandling\": false,\n\t\t\t\"suggest\": false,\n\t\t\t\"allowExtFlags\": false,\n\t\t\t\"skipFlagParsing\": false,\n\t\t\t\"prefixMatchCommands\": false,\n\t\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\t\"arguments\": null,\n\t\t\t\"readArgsFromStdin\": false\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"some-command\",\n\t\t\t\"aliases\": null,\n\t\t\t\"usage\": \"\",\n\t\t\t\"usageText\": \"\",\n\t\t\t\"argsUsage\": \"\",\n\t\t\t\"version\": \"\",\n\t\t\t\"description\": \"\",\n\t\t\t\"defaultCommand\": \"\",\n\t\t\t\"category\": \"\",\n\t\t\t\"commands\": null,\n\t\t\t\"flags\": null,\n\t\t\t\"hideHelp\": false,\n\t\t\t\"hideHelpCommand\": false,\n\t\t\t\"hideVersion\": false,\n\t\t\t\"hidden\": false,\n\t\t\t\"authors\": null,\n\t\t\t\"copyright\": \"\",\n\t\t\t\"metadata\": null,\n\t\t\t\"sliceFlagSeparator\": \"\",\n\t\t\t\"disableSliceFlagSeparator\": false,\n\t\t\t\"useShortOptionHandling\": false,\n\t\t\t\"suggest\": false,\n\t\t\t\"allowExtFlags\": false,\n\t\t\t\"skipFlagParsing\": false,\n\t\t\t\"prefixMatchCommands\": false,\n\t\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\t\"arguments\": null,\n\t\t\t\"readArgsFromStdin\": false\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"hidden-command\",\n\t\t\t\"aliases\": null,\n\t\t\t\"usage\": \"\",\n\t\t\t\"usageText\": \"\",\n\t\t\t\"argsUsage\": \"\",\n\t\t\t\"version\": \"\",\n\t\t\t\"description\": \"\",\n\t\t\t\"defaultCommand\": \"\",\n\t\t\t\"category\": \"\",\n\t\t\t\"commands\": null,\n\t\t\t\"flags\": null,\n\t\t\t\"hideHelp\": false,\n\t\t\t\"hideHelpCommand\": false,\n\t\t\t\"hideVersion\": false,\n\t\t\t\"hidden\": true,\n\t\t\t\"authors\": null,\n\t\t\t\"copyright\": \"\",\n\t\t\t\"metadata\": null,\n\t\t\t\"sliceFlagSeparator\": \"\",\n\t\t\t\"disableSliceFlagSeparator\": false,\n\t\t\t\"useShortOptionHandling\": false,\n\t\t\t\"suggest\": false,\n\t\t\t\"allowExtFlags\": false,\n\t\t\t\"skipFlagParsing\": false,\n\t\t\t\"prefixMatchCommands\": false,\n\t\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\t\"arguments\": null,\n\t\t\t\"readArgsFromStdin\": false\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"usage\",\n\t\t\t\"aliases\": [\n\t\t\t  \"u\"\n\t\t\t],\n\t\t\t\"usage\": \"standard usage text\",\n\t\t\t\"usageText\": \"\\nUsage for the usage text\\n- formatted:  Based on the specified ConfigMap and summon secrets.yml\\n- list:       Inspect the environment for a specific process running on a Pod\\n- for_effect: Compare 'namespace' environment with 'local'\\n\\n` + \"```\\\\nfunc() { ... }\\\\n```\" + `\\n\\nShould be a part of the same code block\\n\",\n\t\t\t\"argsUsage\": \"\",\n\t\t\t\"version\": \"\",\n\t\t\t\"description\": \"\",\n\t\t\t\"defaultCommand\": \"\",\n\t\t\t\"category\": \"\",\n\t\t\t\"commands\": [\n\t\t\t  {\n\t\t\t\t\"name\": \"sub-usage\",\n\t\t\t\t\"aliases\": [\n\t\t\t\t  \"su\"\n\t\t\t\t],\n\t\t\t\t\"usage\": \"standard usage text\",\n\t\t\t\t\"usageText\": \"Single line of UsageText\",\n\t\t\t\t\"argsUsage\": \"\",\n\t\t\t\t\"version\": \"\",\n\t\t\t\t\"description\": \"\",\n\t\t\t\t\"defaultCommand\": \"\",\n\t\t\t\t\"category\": \"\",\n\t\t\t\t\"commands\": null,\n\t\t\t\t\"flags\": [\n\t\t\t\t  {\n\t\t\t\t\t\"name\": \"sub-command-flag\",\n\t\t\t\t\t\"category\": \"\",\n\t\t\t\t\t\"defaultText\": \"\",\n\t\t\t\t\t\"usage\": \"some usage text\",\n\t\t\t\t\t\"required\": false,\n\t\t\t\t\t\"hidden\": false,\n\t\t\t\t\t\"hideDefault\": false,\n\t\t\t\t\t\"local\": false,\n\t\t\t\t\t\"defaultValue\": false,\n\t\t\t\t\t\"aliases\": [\n\t\t\t\t\t  \"s\"\n\t\t\t\t\t],\n\t\t\t\t\t\"takesFileArg\": false,\n\t\t\t\t\t\"config\": {\n\t\t\t\t\t  \"Count\": null\n\t\t\t\t\t},\n\t\t\t\t\t\"onlyOnce\": false,\n\t\t\t\t\t\"validateDefaults\" : false\n\t\t\t\t  }\n\t\t\t\t],\n\t\t\t\t\"hideHelp\": false,\n\t\t\t\t\"hideHelpCommand\": false,\n\t\t\t\t\"hideVersion\": false,\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"authors\": null,\n\t\t\t\t\"copyright\": \"\",\n\t\t\t\t\"metadata\": null,\n\t\t\t\t\"sliceFlagSeparator\": \"\",\n\t\t\t\t\"disableSliceFlagSeparator\": false,\n\t\t\t\t\"useShortOptionHandling\": false,\n\t\t\t\t\"suggest\": false,\n\t\t\t\t\"allowExtFlags\": false,\n\t\t\t\t\"skipFlagParsing\": false,\n\t\t\t\t\"prefixMatchCommands\": false,\n\t\t\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\t\t\"arguments\": null,\n\t\t\t\t\"readArgsFromStdin\": false\n\t\t\t  }\n\t\t\t],\n\t\t\t\"flags\": [\n\t\t\t  {\n\t\t\t\t\"name\": \"flag\",\n\t\t\t\t\"category\": \"\",\n\t\t\t\t\"defaultText\": \"\",\n\t\t\t\t\"usage\": \"\",\n\t\t\t\t\"required\": false,\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"hideDefault\": false,\n\t\t\t\t\"local\": false,\n\t\t\t\t\"defaultValue\": \"\",\n\t\t\t\t\"aliases\": [\n\t\t\t\t  \"fl\",\n\t\t\t\t  \"f\"\n\t\t\t\t],\n\t\t\t\t\"takesFileArg\": true,\n\t\t\t\t\"config\": {\n\t\t\t\t  \"TrimSpace\": false\n\t\t\t\t},\n\t\t\t\t\"onlyOnce\": false,\n\t\t\t\t\"validateDefaults\" : false\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"name\": \"another-flag\",\n\t\t\t\t\"category\": \"\",\n\t\t\t\t\"defaultText\": \"\",\n\t\t\t\t\"usage\": \"another usage text\",\n\t\t\t\t\"required\": false,\n\t\t\t\t\"hidden\": false,\n\t\t\t\t\"hideDefault\": false,\n\t\t\t\t\"local\": false,\n\t\t\t\t\"defaultValue\": false,\n\t\t\t\t\"aliases\": [\n\t\t\t\t  \"b\"\n\t\t\t\t],\n\t\t\t\t\"takesFileArg\": false,\n\t\t\t\t\"config\": {\n\t\t\t\t  \"Count\": null\n\t\t\t\t},\n\t\t\t\t\"onlyOnce\": false,\n\t\t\t\t\"validateDefaults\" : false\n\t\t\t  }\n\t\t\t],\n\t\t\t\"hideHelp\": false,\n\t\t\t\"hideHelpCommand\": false,\n\t\t\t\"hideVersion\": false,\n\t\t\t\"hidden\": false,\n\t\t\t\"authors\": null,\n\t\t\t\"copyright\": \"\",\n\t\t\t\"metadata\": null,\n\t\t\t\"sliceFlagSeparator\": \"\",\n\t\t\t\"disableSliceFlagSeparator\": false,\n\t\t\t\"useShortOptionHandling\": false,\n\t\t\t\"suggest\": false,\n\t\t\t\"allowExtFlags\": false,\n\t\t\t\"skipFlagParsing\": false,\n\t\t\t\"prefixMatchCommands\": false,\n\t\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\t\"arguments\": null,\n\t\t\t\"readArgsFromStdin\": false\n\t\t  }\n\t\t],\n\t\t\"flags\": [\n\t\t  {\n\t\t\t\"name\": \"socket\",\n\t\t\t\"category\": \"\",\n\t\t\t\"defaultText\": \"\",\n\t\t\t\"usage\": \"some 'usage' text\",\n\t\t\t\"required\": false,\n\t\t\t\"hidden\": false,\n\t\t\t\"hideDefault\": false,\n\t\t\t\"local\": false,\n\t\t\t\"defaultValue\": \"value\",\n\t\t\t\"aliases\": [\n\t\t\t  \"s\"\n\t\t\t],\n\t\t\t\"takesFileArg\": true,\n\t\t\t\"config\": {\n\t\t\t  \"TrimSpace\": false\n\t\t\t},\n\t\t\t\"onlyOnce\": false,\n\t\t\t\"validateDefaults\" : false\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"flag\",\n\t\t\t\"category\": \"\",\n\t\t\t\"defaultText\": \"\",\n\t\t\t\"usage\": \"\",\n\t\t\t\"required\": false,\n\t\t\t\"hidden\": false,\n\t\t\t\"hideDefault\": false,\n\t\t\t\"local\": false,\n\t\t\t\"defaultValue\": \"\",\n\t\t\t\"aliases\": [\n\t\t\t  \"fl\",\n\t\t\t  \"f\"\n\t\t\t],\n\t\t\t\"takesFileArg\": false,\n\t\t\t\"config\": {\n\t\t\t  \"TrimSpace\": false\n\t\t\t},\n\t\t\t\"onlyOnce\": false,\n\t\t\t\"validateDefaults\" : false\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"another-flag\",\n\t\t\t\"category\": \"\",\n\t\t\t\"defaultText\": \"\",\n\t\t\t\"usage\": \"another usage text\",\n\t\t\t\"required\": false,\n\t\t\t\"hidden\": false,\n\t\t\t\"hideDefault\": false,\n\t\t\t\"local\": false,\n\t\t\t\"defaultValue\": false,\n\t\t\t\"aliases\": [\n\t\t\t  \"b\"\n\t\t\t],\n\t\t\t\"takesFileArg\": false,\n\t\t\t\"config\": {\n\t\t\t  \"Count\": null\n\t\t\t},\n\t\t\t\"onlyOnce\": false,\n\t\t\t\"validateDefaults\" : false\n\t\t  },\n\t\t  {\n\t\t\t\"name\": \"hidden-flag\",\n\t\t\t\"category\": \"\",\n\t\t\t\"defaultText\": \"\",\n\t\t\t\"usage\": \"\",\n\t\t\t\"required\": false,\n\t\t\t\"hidden\": true,\n\t\t\t\"hideDefault\": false,\n\t\t\t\"local\": false,\n\t\t\t\"defaultValue\": false,\n\t\t\t\"aliases\": null,\n\t\t\t\"takesFileArg\": false,\n\t\t\t\"config\": {\n\t\t\t  \"Count\": null\n\t\t\t},\n\t\t\t\"onlyOnce\": false,\n\t\t\t\"validateDefaults\" : false\n\t\t  }\n\t\t],\n\t\t\"hideHelp\": false,\n\t\t\"hideHelpCommand\": false,\n\t\t\"hideVersion\": false,\n\t\t\"hidden\": false,\n\t\t\"authors\": [\n\t\t  \"Harrison <harrison@lolwut.example.com>\",\n\t\t  {\n\t\t\t\"Name\": \"Oliver Allen\",\n\t\t\t\"Address\": \"oliver@toyshop.com\"\n\t\t  }\n\t\t],\n\t\t\"copyright\": \"\",\n\t\t\"metadata\": null,\n\t\t\"sliceFlagSeparator\": \"\",\n\t\t\"disableSliceFlagSeparator\": false,\n\t\t\"useShortOptionHandling\": false,\n\t\t\"suggest\": false,\n\t\t\"allowExtFlags\": false,\n\t\t\"skipFlagParsing\": false,\n\t\t\"prefixMatchCommands\": false,\n\t\t\"mutuallyExclusiveFlags\": null,\n\t\t\"arguments\": [\n\t\t  {\n\t\t\t\"name\": \"fooi\",\n\t\t\t\"value\": 0,\n\t\t\t\"usageText\": \"\",\n\t\t\t\"minTimes\": 0,\n\t\t\t\"maxTimes\": 0,\n\t\t\t\"config\": {\n\t\t\t  \"Base\": 0\n\t\t\t}\n\t\t  }\n\t\t],\n\t\t\"readArgsFromStdin\": false\n\t  }\n`\n\tassert.JSONEq(t, expected, string(out))\n}\n"
        },
        {
          "name": "completion.go",
          "type": "blob",
          "size": 1.998046875,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"embed\"\n\t\"fmt\"\n\t\"sort\"\n)\n\nconst (\n\tcompletionCommandName = \"completion\"\n\n\t// This flag is supposed to only be used by the completion script itself to generate completions on the fly.\n\tcompletionFlag = \"--generate-shell-completion\"\n)\n\ntype renderCompletion func(cmd *Command, appName string) (string, error)\n\nvar (\n\t//go:embed autocomplete\n\tautoCompleteFS embed.FS\n\n\tshellCompletions = map[string]renderCompletion{\n\t\t\"bash\": func(c *Command, appName string) (string, error) {\n\t\t\tb, err := autoCompleteFS.ReadFile(\"autocomplete/bash_autocomplete\")\n\t\t\treturn fmt.Sprintf(string(b), appName), err\n\t\t},\n\t\t\"zsh\": func(c *Command, appName string) (string, error) {\n\t\t\tb, err := autoCompleteFS.ReadFile(\"autocomplete/zsh_autocomplete\")\n\t\t\treturn fmt.Sprintf(string(b), appName), err\n\t\t},\n\t\t\"fish\": func(c *Command, appName string) (string, error) {\n\t\t\treturn c.ToFishCompletion()\n\t\t},\n\t\t\"pwsh\": func(c *Command, appName string) (string, error) {\n\t\t\tb, err := autoCompleteFS.ReadFile(\"autocomplete/powershell_autocomplete.ps1\")\n\t\t\treturn string(b), err\n\t\t},\n\t}\n)\n\nfunc buildCompletionCommand(appName string) *Command {\n\treturn &Command{\n\t\tName:   completionCommandName,\n\t\tHidden: true,\n\t\tAction: func(ctx context.Context, cmd *Command) error {\n\t\t\treturn printShellCompletion(ctx, cmd, appName)\n\t\t},\n\t}\n}\n\nfunc printShellCompletion(_ context.Context, cmd *Command, appName string) error {\n\tvar shells []string\n\tfor k := range shellCompletions {\n\t\tshells = append(shells, k)\n\t}\n\n\tsort.Strings(shells)\n\n\tif cmd.Args().Len() == 0 {\n\t\treturn Exit(fmt.Sprintf(\"no shell provided for completion command. available shells are %+v\", shells), 1)\n\t}\n\ts := cmd.Args().First()\n\n\trenderCompletion, ok := shellCompletions[s]\n\tif !ok {\n\t\treturn Exit(fmt.Sprintf(\"unknown shell %s, available shells are %+v\", s, shells), 1)\n\t}\n\n\tcompletionScript, err := renderCompletion(cmd, appName)\n\tif err != nil {\n\t\treturn Exit(err, 1)\n\t}\n\n\t_, err = cmd.Writer.Write([]byte(completionScript))\n\tif err != nil {\n\t\treturn Exit(err, 1)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "completion_test.go",
          "type": "blob",
          "size": 5.1845703125,
          "content": "package cli\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCompletionDisable(t *testing.T) {\n\tcmd := &Command{}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", completionCommandName})\n\tassert.Error(t, err, \"Expected error for no help topic for completion\")\n}\n\nfunc TestCompletionEnable(t *testing.T) {\n\tcmd := &Command{\n\t\tEnableShellCompletion: true,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", completionCommandName})\n\tassert.ErrorContains(t, err, \"no shell provided\")\n}\n\nfunc TestCompletionEnableDiffCommandName(t *testing.T) {\n\tcmd := &Command{\n\t\tEnableShellCompletion:      true,\n\t\tShellCompletionCommandName: \"junky\",\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"junky\"})\n\tassert.ErrorContains(t, err, \"no shell provided\")\n}\n\nfunc TestCompletionShell(t *testing.T) {\n\tfor k := range shellCompletions {\n\t\tout := &bytes.Buffer{}\n\n\t\tt.Run(k, func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tEnableShellCompletion: true,\n\t\t\t\tWriter:                out,\n\t\t\t}\n\n\t\t\tr := require.New(t)\n\n\t\t\tr.NoError(cmd.Run(buildTestContext(t), []string{\"foo\", completionCommandName, k}))\n\t\t\tr.Containsf(\n\t\t\t\tk, out.String(),\n\t\t\t\t\"Expected output to contain shell name %[1]q\", k,\n\t\t\t)\n\t\t})\n\t}\n}\n\nfunc TestCompletionSubcommand(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\targs        []string\n\t\tcontains    string\n\t\tmsg         string\n\t\tmsgArgs     []interface{}\n\t\tnotContains bool\n\t}{\n\t\t{\n\t\t\tname:     \"subcommand general completion\",\n\t\t\targs:     []string{\"foo\", \"bar\", completionFlag},\n\t\t\tcontains: \"xyz\",\n\t\t\tmsg:      \"Expected output to contain shell name %[1]q\",\n\t\t\tmsgArgs: []interface{}{\n\t\t\t\t\"xyz\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"subcommand flag completion\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"-\", completionFlag},\n\t\t\tcontains: \"l1\",\n\t\t\tmsg:      \"Expected output to contain shell name %[1]q\",\n\t\t\tmsgArgs: []interface{}{\n\t\t\t\t\"l1\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"subcommand flag no completion\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"--\", completionFlag},\n\t\t\tcontains: \"l1\",\n\t\t\tmsg:      \"Expected output to contain shell name %[1]q\",\n\t\t\tmsgArgs: []interface{}{\n\t\t\t\t\"l1\",\n\t\t\t},\n\t\t\tnotContains: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"sub sub command general completion\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"xyz\", completionFlag},\n\t\t\tcontains: \"-g\",\n\t\t\tmsg:      \"Expected output to contain flag %[1]q\",\n\t\t\tmsgArgs: []interface{}{\n\t\t\t\t\"-g\",\n\t\t\t},\n\t\t\tnotContains: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"sub sub command flag completion\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"xyz\", \"-\", completionFlag},\n\t\t\tcontains: \"-g\",\n\t\t\tmsg:      \"Expected output to contain flag %[1]q\",\n\t\t\tmsgArgs: []interface{}{\n\t\t\t\t\"-g\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"sub sub command no completion\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"xyz\", \"--\", completionFlag},\n\t\t\tcontains: \"-g\",\n\t\t\tmsg:      \"Expected output to contain flag %[1]q\",\n\t\t\tmsgArgs: []interface{}{\n\t\t\t\t\"-g\",\n\t\t\t},\n\t\t\tnotContains: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"sub sub command no completion extra args\",\n\t\t\targs:     []string{\"foo\", \"bar\", \"xyz\", \"--\", \"sargs\", completionFlag},\n\t\t\tcontains: \"-g\",\n\t\t\tmsg:      \"Expected output to contain flag %[1]q\",\n\t\t\tmsgArgs: []interface{}{\n\t\t\t\t\"-g\",\n\t\t\t},\n\t\t\tnotContains: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tout := &bytes.Buffer{}\n\n\t\t\tcmd := &Command{\n\t\t\t\tEnableShellCompletion: true,\n\t\t\t\tWriter:                out,\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"bar\",\n\t\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\t\t\tName: \"l1\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tCommands: []*Command{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: \"xyz\",\n\t\t\t\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\t\t\t\t\tName: \"g\",\n\t\t\t\t\t\t\t\t\t\tAliases: []string{\n\t\t\t\t\t\t\t\t\t\t\t\"t\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tr := require.New(t)\n\n\t\t\tr.NoError(cmd.Run(buildTestContext(t), test.args))\n\t\t\tt.Log(out.String())\n\t\t\tif test.notContains {\n\t\t\t\tr.NotContainsf(out.String(), test.contains, test.msg, test.msgArgs...)\n\t\t\t} else {\n\t\t\t\tr.Containsf(out.String(), test.contains, test.msg, test.msgArgs...)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype mockWriter struct {\n\terr error\n}\n\nfunc (mw *mockWriter) Write(p []byte) (int, error) {\n\tif mw.err != nil {\n\t\treturn 0, mw.err\n\t}\n\treturn len(p), nil\n}\n\nfunc TestCompletionInvalidShell(t *testing.T) {\n\tcmd := &Command{\n\t\tEnableShellCompletion: true,\n\t}\n\n\tunknownShellName := \"junky-sheell\"\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", completionCommandName, unknownShellName})\n\tassert.ErrorContains(t, err, \"unknown shell junky-sheell\")\n\n\tenableError := true\n\tshellCompletions[unknownShellName] = func(c *Command, appName string) (string, error) {\n\t\tif enableError {\n\t\t\treturn \"\", fmt.Errorf(\"cant do completion\")\n\t\t}\n\t\treturn \"something\", nil\n\t}\n\tdefer func() {\n\t\tdelete(shellCompletions, unknownShellName)\n\t}()\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", completionCommandName, unknownShellName})\n\tassert.ErrorContains(t, err, \"cant do completion\")\n\n\t// now disable shell completion error\n\tenableError = false\n\tc := cmd.Command(completionCommandName)\n\tassert.NotNil(t, c)\n\tc.Writer = &mockWriter{\n\t\terr: fmt.Errorf(\"writer error\"),\n\t}\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", completionCommandName, unknownShellName})\n\tassert.ErrorContains(t, err, \"writer error\")\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 4.33984375,
          "content": "package cli\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\n// OsExiter is the function used when the app exits. If not set defaults to os.Exit.\nvar OsExiter = os.Exit\n\n// ErrWriter is used to write errors to the user. This can be anything\n// implementing the io.Writer interface and defaults to os.Stderr.\nvar ErrWriter io.Writer = os.Stderr\n\n// MultiError is an error that wraps multiple errors.\ntype MultiError interface {\n\terror\n\tErrors() []error\n}\n\n// newMultiError creates a new MultiError. Pass in one or more errors.\nfunc newMultiError(err ...error) MultiError {\n\tret := multiError(err)\n\treturn &ret\n}\n\ntype multiError []error\n\n// Error implements the error interface.\nfunc (m *multiError) Error() string {\n\terrs := make([]string, len(*m))\n\tfor i, err := range *m {\n\t\terrs[i] = err.Error()\n\t}\n\n\treturn strings.Join(errs, \"\\n\")\n}\n\n// Errors returns a copy of the errors slice\nfunc (m *multiError) Errors() []error {\n\terrs := make([]error, len(*m))\n\tcopy(errs, *m)\n\treturn errs\n}\n\ntype requiredFlagsErr interface {\n\terror\n}\n\ntype errRequiredFlags struct {\n\tmissingFlags []string\n}\n\nfunc (e *errRequiredFlags) Error() string {\n\tif len(e.missingFlags) == 1 {\n\t\treturn fmt.Sprintf(\"Required flag %q not set\", e.missingFlags[0])\n\t}\n\tjoinedMissingFlags := strings.Join(e.missingFlags, \", \")\n\treturn fmt.Sprintf(\"Required flags %q not set\", joinedMissingFlags)\n}\n\ntype mutuallyExclusiveGroup struct {\n\tflag1Name string\n\tflag2Name string\n}\n\nfunc (e *mutuallyExclusiveGroup) Error() string {\n\treturn fmt.Sprintf(\"option %s cannot be set along with option %s\", e.flag1Name, e.flag2Name)\n}\n\ntype mutuallyExclusiveGroupRequiredFlag struct {\n\tflags *MutuallyExclusiveFlags\n}\n\nfunc (e *mutuallyExclusiveGroupRequiredFlag) Error() string {\n\tvar missingFlags []string\n\tfor _, grpf := range e.flags.Flags {\n\t\tvar grpString []string\n\t\tfor _, f := range grpf {\n\t\t\tgrpString = append(grpString, f.Names()...)\n\t\t}\n\t\tmissingFlags = append(missingFlags, strings.Join(grpString, \" \"))\n\t}\n\n\treturn fmt.Sprintf(\"one of these flags needs to be provided: %s\", strings.Join(missingFlags, \", \"))\n}\n\n// ErrorFormatter is the interface that will suitably format the error output\ntype ErrorFormatter interface {\n\tFormat(s fmt.State, verb rune)\n}\n\n// ExitCoder is the interface checked by `App` and `Command` for a custom exit\n// code\ntype ExitCoder interface {\n\terror\n\tExitCode() int\n}\n\ntype exitError struct {\n\texitCode int\n\terr      error\n}\n\n// Exit wraps a message and exit code into an error, which by default is\n// handled with a call to os.Exit during default error handling.\n//\n// This is the simplest way to trigger a non-zero exit code for an App without\n// having to call os.Exit manually. During testing, this behavior can be avoided\n// by overriding the ExitErrHandler function on an App or the package-global\n// OsExiter function.\nfunc Exit(message interface{}, exitCode int) ExitCoder {\n\tvar err error\n\n\tswitch e := message.(type) {\n\tcase ErrorFormatter:\n\t\terr = fmt.Errorf(\"%+v\", message)\n\tcase error:\n\t\terr = e\n\tdefault:\n\t\terr = fmt.Errorf(\"%+v\", message)\n\t}\n\n\treturn &exitError{\n\t\terr:      err,\n\t\texitCode: exitCode,\n\t}\n}\n\nfunc (ee *exitError) Error() string {\n\treturn ee.err.Error()\n}\n\nfunc (ee *exitError) ExitCode() int {\n\treturn ee.exitCode\n}\n\n// HandleExitCoder handles errors implementing ExitCoder by printing their\n// message and calling OsExiter with the given exit code.\n//\n// If the given error instead implements MultiError, each error will be checked\n// for the ExitCoder interface, and OsExiter will be called with the last exit\n// code found, or exit code 1 if no ExitCoder is found.\n//\n// This function is the default error-handling behavior for an App.\nfunc HandleExitCoder(err error) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tif exitErr, ok := err.(ExitCoder); ok {\n\t\tif err.Error() != \"\" {\n\t\t\tif _, ok := exitErr.(ErrorFormatter); ok {\n\t\t\t\t_, _ = fmt.Fprintf(ErrWriter, \"%+v\\n\", err)\n\t\t\t} else {\n\t\t\t\t_, _ = fmt.Fprintln(ErrWriter, err)\n\t\t\t}\n\t\t}\n\t\tOsExiter(exitErr.ExitCode())\n\t\treturn\n\t}\n\n\tif multiErr, ok := err.(MultiError); ok {\n\t\tcode := handleMultiError(multiErr)\n\t\tOsExiter(code)\n\t\treturn\n\t}\n}\n\nfunc handleMultiError(multiErr MultiError) int {\n\tcode := 1\n\tfor _, merr := range multiErr.Errors() {\n\t\tif multiErr2, ok := merr.(MultiError); ok {\n\t\t\tcode = handleMultiError(multiErr2)\n\t\t} else if merr != nil {\n\t\t\tfmt.Fprintln(ErrWriter, merr)\n\t\t\tif exitErr, ok := merr.(ExitCoder); ok {\n\t\t\t\tcode = exitErr.ExitCode()\n\t\t\t}\n\t\t}\n\t}\n\treturn code\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 4.6630859375,
          "content": "package cli\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestHandleExitCoder_nil(t *testing.T) {\n\texitCode := 0\n\tcalled := false\n\n\tOsExiter = func(rc int) {\n\t\tif !called {\n\t\t\texitCode = rc\n\t\t\tcalled = true\n\t\t}\n\t}\n\n\tdefer func() { OsExiter = fakeOsExiter }()\n\n\tHandleExitCoder(nil)\n\n\tassert.Equal(t, 0, exitCode)\n\tassert.False(t, called)\n}\n\nfunc TestHandleExitCoder_ExitCoder(t *testing.T) {\n\texitCode := 0\n\tcalled := false\n\n\tOsExiter = func(rc int) {\n\t\tif !called {\n\t\t\texitCode = rc\n\t\t\tcalled = true\n\t\t}\n\t}\n\n\tdefer func() { OsExiter = fakeOsExiter }()\n\n\tHandleExitCoder(Exit(\"galactic perimeter breach\", 9))\n\n\tassert.Equal(t, 9, exitCode)\n\tassert.True(t, called)\n}\n\nfunc TestHandleExitCoder_ErrorExitCoder(t *testing.T) {\n\texitCode := 0\n\tcalled := false\n\n\tOsExiter = func(rc int) {\n\t\tif !called {\n\t\t\texitCode = rc\n\t\t\tcalled = true\n\t\t}\n\t}\n\n\tdefer func() { OsExiter = fakeOsExiter }()\n\n\tHandleExitCoder(Exit(errors.New(\"galactic perimeter breach\"), 9))\n\n\tassert.Equal(t, 9, exitCode)\n\tassert.True(t, called)\n}\n\nfunc TestHandleExitCoder_MultiErrorWithExitCoder(t *testing.T) {\n\texitCode := 0\n\tcalled := false\n\n\tOsExiter = func(rc int) {\n\t\tif !called {\n\t\t\texitCode = rc\n\t\t\tcalled = true\n\t\t}\n\t}\n\n\tdefer func() { OsExiter = fakeOsExiter }()\n\n\texitErr := Exit(\"galactic perimeter breach\", 9)\n\texitErr2 := Exit(\"last ExitCoder\", 11)\n\n\terr := newMultiError(errors.New(\"wowsa\"), errors.New(\"egad\"), exitErr, exitErr2)\n\tHandleExitCoder(err)\n\n\tassert.Equal(t, 11, exitCode)\n\tassert.True(t, called)\n}\n\ntype exitFormatter struct {\n\tcode int\n}\n\nfunc (f *exitFormatter) Format(s fmt.State, verb rune) {\n\t_, _ = s.Write([]byte(\"some other special\"))\n}\n\nfunc (f *exitFormatter) ExitCode() int {\n\treturn f.code\n}\n\nfunc (f *exitFormatter) Error() string {\n\treturn fmt.Sprintf(\"my special error code %d\", f.code)\n}\n\nfunc TestHandleExitCoder_ErrorFormatter(t *testing.T) {\n\texitCode := 0\n\tcalled := false\n\n\tOsExiter = func(rc int) {\n\t\tif !called {\n\t\t\texitCode = rc\n\t\t\tcalled = true\n\t\t}\n\t}\n\n\toldWriter := ErrWriter\n\tvar buf bytes.Buffer\n\tErrWriter = &buf\n\tdefer func() {\n\t\tOsExiter = fakeOsExiter\n\t\tErrWriter = oldWriter\n\t}()\n\n\texitErr := Exit(\"galactic perimeter breach\", 9)\n\texitErr2 := Exit(\"last ExitCoder\", 11)\n\texitErr3 := &exitFormatter{code: 12}\n\n\t// add some recursion for multi error to fix test coverage\n\terr := newMultiError(errors.New(\"wowsa\"), errors.New(\"egad\"), exitErr3, newMultiError(exitErr, exitErr2))\n\tHandleExitCoder(err)\n\n\tassert.Equal(t, 11, exitCode)\n\tassert.True(t, called)\n\tassert.Contains(t, buf.String(), \"some other special\")\n}\n\nfunc TestHandleExitCoder_MultiErrorWithoutExitCoder(t *testing.T) {\n\texitCode := 0\n\tcalled := false\n\n\tOsExiter = func(rc int) {\n\t\tif !called {\n\t\t\texitCode = rc\n\t\t\tcalled = true\n\t\t}\n\t}\n\n\tdefer func() { OsExiter = fakeOsExiter }()\n\n\terr := newMultiError(errors.New(\"wowsa\"), errors.New(\"egad\"))\n\tHandleExitCoder(err)\n\n\tassert.Equal(t, 1, exitCode)\n\tassert.True(t, called)\n}\n\n// make a stub to not import pkg/errors\ntype ErrorWithFormat struct {\n\terror\n}\n\nfunc NewErrorWithFormat(m string) *ErrorWithFormat {\n\treturn &ErrorWithFormat{error: errors.New(m)}\n}\n\nfunc (f *ErrorWithFormat) Format(s fmt.State, verb rune) {\n\tfmt.Fprintf(s, \"This the format: %v\", f.error)\n}\n\nfunc TestHandleExitCoder_ErrorWithFormat(t *testing.T) {\n\tcalled := false\n\n\tOsExiter = func(int) {\n\t\tif !called {\n\t\t\tcalled = true\n\t\t}\n\t}\n\tErrWriter = &bytes.Buffer{}\n\n\tdefer func() {\n\t\tOsExiter = fakeOsExiter\n\t\tErrWriter = fakeErrWriter\n\t}()\n\n\terr := Exit(NewErrorWithFormat(\"I am formatted\"), 1)\n\tHandleExitCoder(err)\n\n\tassert.True(t, called)\n\tassert.Equal(t, ErrWriter.(*bytes.Buffer).String(), \"This the format: I am formatted\\n\")\n}\n\nfunc TestHandleExitCoder_MultiErrorWithFormat(t *testing.T) {\n\tcalled := false\n\n\tOsExiter = func(int) {\n\t\tif !called {\n\t\t\tcalled = true\n\t\t}\n\t}\n\tErrWriter = &bytes.Buffer{}\n\n\tdefer func() { OsExiter = fakeOsExiter }()\n\n\terr := newMultiError(NewErrorWithFormat(\"err1\"), NewErrorWithFormat(\"err2\"))\n\tHandleExitCoder(err)\n\n\tassert.True(t, called)\n\tassert.Equal(t, ErrWriter.(*bytes.Buffer).String(), \"This the format: err1\\nThis the format: err2\\n\")\n}\n\nfunc TestMultiErrorErrorsCopy(t *testing.T) {\n\terrList := []error{\n\t\terrors.New(\"foo\"),\n\t\terrors.New(\"bar\"),\n\t\terrors.New(\"baz\"),\n\t}\n\tme := newMultiError(errList...)\n\tassert.Equal(t, errList, me.Errors())\n}\n\nfunc TestErrRequiredFlags_Error(t *testing.T) {\n\tmissingFlags := []string{\"flag1\", \"flag2\"}\n\terr := &errRequiredFlags{missingFlags: missingFlags}\n\texpectedMsg := \"Required flags \\\"flag1, flag2\\\" not set\"\n\tassert.Equal(t, expectedMsg, err.Error())\n\n\tmissingFlags = []string{\"flag1\"}\n\terr = &errRequiredFlags{missingFlags: missingFlags}\n\texpectedMsg = \"Required flag \\\"flag1\\\" not set\"\n\tassert.Equal(t, expectedMsg, err.Error())\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples_test.go",
          "type": "blob",
          "size": 14.017578125,
          "content": "package cli_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/mail\"\n\t\"os\"\n\t\"time\"\n\n\t// Alias the package import to make the examples runnable on pkg.go.dev.\n\t//\n\t// See issue #1811.\n\tcli \"github.com/urfave/cli/v3\"\n)\n\nfunc ExampleCommand_Run() {\n\t// Declare a command\n\tcmd := &cli.Command{\n\t\tName: \"greet\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{Name: \"name\", Value: \"pat\", Usage: \"a name to say\"},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *cli.Command) error {\n\t\t\tfmt.Printf(\"Hello %[1]v\\n\", cmd.String(\"name\"))\n\t\t\treturn nil\n\t\t},\n\t\tAuthors: []any{\n\t\t\t&mail.Address{Name: \"Oliver Allen\", Address: \"oliver@toyshop.example.com\"},\n\t\t\t\"gruffalo@soup-world.example.org\",\n\t\t},\n\t\tVersion: \"v0.13.12\",\n\t}\n\n\t// Simulate the command line arguments\n\tos.Args = []string{\"greet\", \"--name\", \"Jeremy\"}\n\n\tif err := cmd.Run(context.Background(), os.Args); err != nil {\n\t\t// do something with unhandled errors\n\t\tfmt.Fprintf(os.Stderr, \"Unhandled error: %[1]v\\n\", err)\n\t\tos.Exit(86)\n\t}\n\t// Output:\n\t// Hello Jeremy\n}\n\nfunc ExampleCommand_Run_subcommand() {\n\tcmd := &cli.Command{\n\t\tName: \"say\",\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:        \"hello\",\n\t\t\t\tAliases:     []string{\"hi\"},\n\t\t\t\tUsage:       \"use it to see a description\",\n\t\t\t\tDescription: \"This is how we describe hello the function\",\n\t\t\t\tCommands: []*cli.Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:        \"english\",\n\t\t\t\t\t\tAliases:     []string{\"en\"},\n\t\t\t\t\t\tUsage:       \"sends a greeting in english\",\n\t\t\t\t\t\tDescription: \"greets someone in english\",\n\t\t\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t\t\t&cli.StringFlag{\n\t\t\t\t\t\t\t\tName:  \"name\",\n\t\t\t\t\t\t\t\tValue: \"Bob\",\n\t\t\t\t\t\t\t\tUsage: \"Name of the person to greet\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tAction: func(_ context.Context, cmd *cli.Command) error {\n\t\t\t\t\t\t\tfmt.Println(\"Hello,\", cmd.String(\"name\"))\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\t// Simulate the command line arguments\n\tos.Args = []string{\"say\", \"hi\", \"english\", \"--name\", \"Jeremy\"}\n\n\t_ = cmd.Run(ctx, os.Args)\n\t// Output:\n\t// Hello, Jeremy\n}\n\nfunc ExampleCommand_Run_appHelp() {\n\tcmd := &cli.Command{\n\t\tName:        \"greet\",\n\t\tVersion:     \"0.1.0\",\n\t\tDescription: \"This is how we describe greet the app\",\n\t\tAuthors: []any{\n\t\t\t&mail.Address{Name: \"Harrison\", Address: \"harrison@lolwut.example.com\"},\n\t\t\t\"Oliver Allen  <oliver@toyshop.example.com>\",\n\t\t},\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{Name: \"name\", Value: \"bob\", Usage: \"a name to say\"},\n\t\t},\n\t\tArguments: cli.AnyArguments,\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:        \"describeit\",\n\t\t\t\tAliases:     []string{\"d\"},\n\t\t\t\tUsage:       \"use it to see a description\",\n\t\t\t\tDescription: \"This is how we describe describeit the function\",\n\t\t\t\tArgsUsage:   \"[arguments...]\",\n\t\t\t\tAction: func(context.Context, *cli.Command) error {\n\t\t\t\t\tfmt.Printf(\"i like to describe things\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), 100*time.Millisecond)\n\tdefer cancel()\n\n\t// Simulate the command line arguments\n\tos.Args = []string{\"greet\", \"help\"}\n\n\t_ = cmd.Run(ctx, os.Args)\n\t// Output:\n\t// NAME:\n\t//    greet - A new cli application\n\t//\n\t// USAGE:\n\t//    greet [global options] [command [command options]] [arguments...]\n\t//\n\t// VERSION:\n\t//    0.1.0\n\t//\n\t// DESCRIPTION:\n\t//    This is how we describe greet the app\n\t//\n\t// AUTHORS:\n\t//    \"Harrison\" <harrison@lolwut.example.com>\n\t//    Oliver Allen  <oliver@toyshop.example.com>\n\t//\n\t// COMMANDS:\n\t//    describeit, d  use it to see a description\n\t//    help, h        Shows a list of commands or help for one command\n\t//\n\t// GLOBAL OPTIONS:\n\t//    --name value   a name to say (default: \"bob\")\n\t//    --help, -h     show help\n\t//    --version, -v  print the version\n}\n\nfunc ExampleCommand_Run_commandHelp() {\n\tcmd := &cli.Command{\n\t\tName: \"greet\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{Name: \"name\", Value: \"pat\", Usage: \"a name to say\"},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *cli.Command) error {\n\t\t\tfmt.Fprintf(cmd.Root().Writer, \"hello to %[1]q\\n\", cmd.String(\"name\"))\n\t\t\treturn nil\n\t\t},\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:        \"describeit\",\n\t\t\t\tAliases:     []string{\"d\"},\n\t\t\t\tUsage:       \"use it to see a description\",\n\t\t\t\tDescription: \"This is how we describe describeit the function\",\n\t\t\t\tArgsUsage:   \"[arguments...]\",\n\t\t\t\tAction: func(context.Context, *cli.Command) error {\n\t\t\t\t\tfmt.Println(\"i like to describe things\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Simulate the command line arguments\n\tos.Args = []string{\"greet\", \"h\", \"describeit\"}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// NAME:\n\t//    greet describeit - use it to see a description\n\t//\n\t// USAGE:\n\t//    greet describeit [arguments...]\n\t//\n\t// DESCRIPTION:\n\t//    This is how we describe describeit the function\n\t//\n\t// OPTIONS:\n\t//    --help, -h  show help\n}\n\nfunc ExampleCommand_Run_noAction() {\n\tcmd := &cli.Command{Name: \"greet\"}\n\n\t// Simulate the command line arguments\n\tos.Args = []string{\"greet\"}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// NAME:\n\t//    greet - A new cli application\n\t//\n\t// USAGE:\n\t//    greet [global options]\n\t//\n\t// GLOBAL OPTIONS:\n\t//    --help, -h  show help\n}\n\nfunc ExampleCommand_Run_subcommandNoAction() {\n\tcmd := &cli.Command{\n\t\tName: \"greet\",\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:        \"describeit\",\n\t\t\t\tAliases:     []string{\"d\"},\n\t\t\t\tUsage:       \"use it to see a description\",\n\t\t\t\tArgsUsage:   \"[arguments...]\",\n\t\t\t\tDescription: \"This is how we describe describeit the function\",\n\t\t\t},\n\t\t},\n\t}\n\n\t// Simulate the command line arguments\n\tos.Args = []string{\"greet\", \"describeit\"}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// NAME:\n\t//    greet describeit - use it to see a description\n\t//\n\t// USAGE:\n\t//    greet describeit [command [command options]] [arguments...]\n\t//\n\t// DESCRIPTION:\n\t//    This is how we describe describeit the function\n\t//\n\t// OPTIONS:\n\t//    --help, -h  show help\n}\n\nfunc ExampleCommand_Run_shellComplete_bash_withShortFlag() {\n\tcmd := &cli.Command{\n\t\tName:                  \"greet\",\n\t\tEnableShellCompletion: true,\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.IntFlag{\n\t\t\t\tName:    \"other\",\n\t\t\t\tAliases: []string{\"o\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"xyz\",\n\t\t\t\tAliases: []string{\"x\"},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Simulate a bash environment and command line arguments\n\tos.Setenv(\"SHELL\", \"bash\")\n\tos.Args = []string{\"greet\", \"-\", \"--generate-shell-completion\"}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// --other\n\t// --xyz\n\t// --help\n}\n\nfunc ExampleCommand_Run_shellComplete_bash_withLongFlag() {\n\tcmd := &cli.Command{\n\t\tName:                  \"greet\",\n\t\tEnableShellCompletion: true,\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.IntFlag{\n\t\t\t\tName:    \"other\",\n\t\t\t\tAliases: []string{\"o\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"xyz\",\n\t\t\t\tAliases: []string{\"x\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName: \"some-flag,s\",\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName: \"similar-flag\",\n\t\t\t},\n\t\t},\n\t}\n\n\t// Simulate a bash environment and command line arguments\n\tos.Setenv(\"SHELL\", \"bash\")\n\tos.Args = []string{\"greet\", \"--s\", \"--generate-shell-completion\"}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// --some-flag\n\t// --similar-flag\n}\n\nfunc ExampleCommand_Run_shellComplete_bash_withMultipleLongFlag() {\n\tcmd := &cli.Command{\n\t\tName:                  \"greet\",\n\t\tEnableShellCompletion: true,\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.IntFlag{\n\t\t\t\tName:    \"int-flag\",\n\t\t\t\tAliases: []string{\"i\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:    \"string\",\n\t\t\t\tAliases: []string{\"s\"},\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName: \"string-flag-2\",\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName: \"similar-flag\",\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName: \"some-flag\",\n\t\t\t},\n\t\t},\n\t}\n\n\t// Simulate a bash environment and command line arguments\n\tos.Setenv(\"SHELL\", \"bash\")\n\tos.Args = []string{\"greet\", \"--st\", \"--generate-shell-completion\"}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// --string\n\t// --string-flag-2\n}\n\nfunc ExampleCommand_Run_shellComplete_bash() {\n\tcmd := &cli.Command{\n\t\tName:                  \"greet\",\n\t\tEnableShellCompletion: true,\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:        \"describeit\",\n\t\t\t\tAliases:     []string{\"d\"},\n\t\t\t\tUsage:       \"use it to see a description\",\n\t\t\t\tDescription: \"This is how we describe describeit the function\",\n\t\t\t\tAction: func(context.Context, *cli.Command) error {\n\t\t\t\t\tfmt.Printf(\"i like to describe things\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tName:        \"next\",\n\t\t\t\tUsage:       \"next example\",\n\t\t\t\tDescription: \"more stuff to see when generating shell completion\",\n\t\t\t\tAction: func(context.Context, *cli.Command) error {\n\t\t\t\t\tfmt.Printf(\"the next example\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Simulate a bash environment and command line arguments\n\tos.Setenv(\"SHELL\", \"bash\")\n\tos.Args = []string{\"greet\", \"--generate-shell-completion\"}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// describeit\n\t// next\n\t// help\n}\n\nfunc ExampleCommand_Run_shellComplete_zsh() {\n\tcmd := &cli.Command{\n\t\tName:                  \"greet\",\n\t\tEnableShellCompletion: true,\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:        \"describeit\",\n\t\t\t\tAliases:     []string{\"d\"},\n\t\t\t\tUsage:       \"use it to see a description\",\n\t\t\t\tDescription: \"This is how we describe describeit the function\",\n\t\t\t\tAction: func(context.Context, *cli.Command) error {\n\t\t\t\t\tfmt.Printf(\"i like to describe things\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}, {\n\t\t\t\tName:        \"next\",\n\t\t\t\tUsage:       \"next example\",\n\t\t\t\tDescription: \"more stuff to see when generating bash completion\",\n\t\t\t\tAction: func(context.Context, *cli.Command) error {\n\t\t\t\t\tfmt.Printf(\"the next example\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Simulate a zsh environment and command line arguments\n\tos.Args = []string{\"greet\", \"--generate-shell-completion\"}\n\tos.Setenv(\"SHELL\", \"/usr/bin/zsh\")\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// describeit:use it to see a description\n\t// next:next example\n\t// help:Shows a list of commands or help for one command\n}\n\nfunc ExampleCommand_Run_sliceValues() {\n\tcmd := &cli.Command{\n\t\tName: \"multi_values\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringSliceFlag{Name: \"stringSlice\"},\n\t\t\t&cli.FloatSliceFlag{Name: \"float64Slice\"},\n\t\t\t&cli.IntSliceFlag{Name: \"intSlice\"},\n\t\t},\n\t\tHideHelp: true,\n\t\tAction: func(ctx context.Context, cmd *cli.Command) error {\n\t\t\tfor i, v := range cmd.FlagNames() {\n\t\t\t\tfmt.Printf(\"%d-%s %#v\\n\", i, v, cmd.Value(v))\n\t\t\t}\n\t\t\terr := ctx.Err()\n\t\t\tfmt.Println(\"error:\", err)\n\t\t\treturn err\n\t\t},\n\t}\n\n\t// Simulate command line arguments\n\tos.Args = []string{\n\t\t\"multi_values\",\n\t\t\"--stringSlice\", \"parsed1,parsed2\", \"--stringSlice\", \"parsed3,parsed4\",\n\t\t\"--float64Slice\", \"13.3,14.4\", \"--float64Slice\", \"15.5,16.6\",\n\t\t\"--intSlice\", \"13,14\", \"--intSlice\", \"15,16\",\n\t}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// 0-float64Slice []float64{13.3, 14.4, 15.5, 16.6}\n\t// 1-intSlice []int64{13, 14, 15, 16}\n\t// 2-stringSlice []string{\"parsed1\", \"parsed2\", \"parsed3\", \"parsed4\"}\n\t// error: <nil>\n}\n\nfunc ExampleCommand_Run_mapValues() {\n\tcmd := &cli.Command{\n\t\tName: \"multi_values\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringMapFlag{Name: \"stringMap\"},\n\t\t},\n\t\tHideHelp: true,\n\t\tAction: func(ctx context.Context, cmd *cli.Command) error {\n\t\t\tfor i, v := range cmd.FlagNames() {\n\t\t\t\tfmt.Printf(\"%d-%s %#v\\n\", i, v, cmd.StringMap(v))\n\t\t\t}\n\t\t\tfmt.Printf(\"notfound %#v\\n\", cmd.StringMap(\"notfound\"))\n\t\t\terr := ctx.Err()\n\t\t\tfmt.Println(\"error:\", err)\n\t\t\treturn err\n\t\t},\n\t}\n\n\t// Simulate command line arguments\n\tos.Args = []string{\n\t\t\"multi_values\",\n\t\t\"--stringMap\", \"parsed1=parsed two\", \"--stringMap\", \"parsed3=\",\n\t}\n\n\t_ = cmd.Run(context.Background(), os.Args)\n\t// Output:\n\t// 0-stringMap map[string]string{\"parsed1\":\"parsed two\", \"parsed3\":\"\"}\n\t// notfound map[string]string(nil)\n\t// error: <nil>\n}\n\nfunc ExampleBoolWithInverseFlag() {\n\tflagWithInverse := &cli.BoolWithInverseFlag{\n\t\tBoolFlag: &cli.BoolFlag{\n\t\t\tName: \"env\",\n\t\t},\n\t}\n\n\tcmd := &cli.Command{\n\t\tFlags: []cli.Flag{\n\t\t\tflagWithInverse,\n\t\t},\n\t\tAction: func(_ context.Context, cmd *cli.Command) error {\n\t\t\tif flagWithInverse.IsSet() {\n\t\t\t\tif flagWithInverse.Value() {\n\t\t\t\t\tfmt.Println(\"env is set\")\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Println(\"no-env is set\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\t_ = cmd.Run(context.Background(), []string{\"prog\", \"--no-env\"})\n\t_ = cmd.Run(context.Background(), []string{\"prog\", \"--env\"})\n\n\tfmt.Println(\"flags:\", len(flagWithInverse.Flags()))\n\n\t// Output:\n\t// no-env is set\n\t// env is set\n\t// flags: 2\n}\n\nfunc ExampleCommand_Suggest() {\n\tcmd := &cli.Command{\n\t\tName:                          \"greet\",\n\t\tErrWriter:                     os.Stdout,\n\t\tSuggest:                       true,\n\t\tHideHelp:                      false,\n\t\tHideHelpCommand:               true,\n\t\tCustomRootCommandHelpTemplate: \"(this space intentionally left blank)\\n\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{Name: \"name\", Value: \"squirrel\", Usage: \"a name to say\"},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *cli.Command) error {\n\t\t\tfmt.Printf(\"Hello %v\\n\", cmd.String(\"name\"))\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tif cmd.Run(context.Background(), []string{\"greet\", \"--nema\", \"chipmunk\"}) == nil {\n\t\tfmt.Println(\"Expected error\")\n\t}\n\t// Output:\n\t// Incorrect Usage: flag provided but not defined: -nema\n\t//\n\t// Did you mean \"--name\"?\n\t//\n\t// (this space intentionally left blank)\n}\n\nfunc ExampleCommand_Suggest_command() {\n\tcmd := &cli.Command{\n\t\tErrWriter: os.Stdout,\n\t\tName:      \"greet\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{Name: \"name\", Value: \"squirrel\", Usage: \"a name to say\"},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *cli.Command) error {\n\t\t\tfmt.Printf(\"Hello %v\\n\", cmd.String(\"name\"))\n\t\t\treturn nil\n\t\t},\n\t\tCommands: []*cli.Command{\n\t\t\t{\n\t\t\t\tName:               \"neighbors\",\n\t\t\t\tHideHelp:           true,\n\t\t\t\tHideHelpCommand:    true,\n\t\t\t\tSuggest:            true,\n\t\t\t\tCustomHelpTemplate: \"(this space intentionally left blank)\\n\",\n\t\t\t\tFlags: []cli.Flag{\n\t\t\t\t\t&cli.BoolFlag{Name: \"smiling\"},\n\t\t\t\t},\n\t\t\t\tAction: func(_ context.Context, cmd *cli.Command) error {\n\t\t\t\t\tif cmd.Bool(\"smiling\") {\n\t\t\t\t\t\tfmt.Println(\"\")\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Println(\"Hello, neighbors\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif cmd.Run(context.Background(), []string{\"greet\", \"neighbors\", \"--sliming\"}) == nil {\n\t\tfmt.Println(\"Expected error\")\n\t}\n\t// Output:\n\t// Incorrect Usage: flag provided but not defined: -sliming\n\t//\n\t// Did you mean \"--smiling\"?\n}\n"
        },
        {
          "name": "fish.go",
          "type": "blob",
          "size": 4,
          "content": "package cli\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"text/template\"\n)\n\n// ToFishCompletion creates a fish completion string for the `*App`\n// The function errors if either parsing or writing of the string fails.\nfunc (cmd *Command) ToFishCompletion() (string, error) {\n\tvar w bytes.Buffer\n\tif err := cmd.writeFishCompletionTemplate(&w); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn w.String(), nil\n}\n\ntype fishCommandCompletionTemplate struct {\n\tCommand     *Command\n\tCompletions []string\n\tAllCommands []string\n}\n\nfunc (cmd *Command) writeFishCompletionTemplate(w io.Writer) error {\n\tconst name = \"cli\"\n\tt, err := template.New(name).Parse(FishCompletionTemplate)\n\tif err != nil {\n\t\treturn err\n\t}\n\tallCommands := []string{}\n\n\t// Add global flags\n\tcompletions := cmd.prepareFishFlags(cmd.VisibleFlags(), allCommands)\n\n\t// Add help flag\n\tif !cmd.HideHelp {\n\t\tcompletions = append(\n\t\t\tcompletions,\n\t\t\tcmd.prepareFishFlags([]Flag{HelpFlag}, allCommands)...,\n\t\t)\n\t}\n\n\t// Add version flag\n\tif !cmd.HideVersion {\n\t\tcompletions = append(\n\t\t\tcompletions,\n\t\t\tcmd.prepareFishFlags([]Flag{VersionFlag}, allCommands)...,\n\t\t)\n\t}\n\n\t// Add commands and their flags\n\tcompletions = append(\n\t\tcompletions,\n\t\tcmd.prepareFishCommands(cmd.VisibleCommands(), &allCommands, []string{})...,\n\t)\n\n\treturn t.ExecuteTemplate(w, name, &fishCommandCompletionTemplate{\n\t\tCommand:     cmd,\n\t\tCompletions: completions,\n\t\tAllCommands: allCommands,\n\t})\n}\n\nfunc (cmd *Command) prepareFishCommands(commands []*Command, allCommands *[]string, previousCommands []string) []string {\n\tcompletions := []string{}\n\tfor _, command := range commands {\n\t\tvar completion strings.Builder\n\t\tcompletion.WriteString(fmt.Sprintf(\n\t\t\t\"complete -r -c %s -n '%s' -a '%s'\",\n\t\t\tcmd.Name,\n\t\t\tcmd.fishSubcommandHelper(previousCommands),\n\t\t\tstrings.Join(command.Names(), \" \"),\n\t\t))\n\n\t\tif command.Usage != \"\" {\n\t\t\tcompletion.WriteString(fmt.Sprintf(\" -d '%s'\",\n\t\t\t\tescapeSingleQuotes(command.Usage)))\n\t\t}\n\n\t\tif !command.HideHelp {\n\t\t\tcompletions = append(\n\t\t\t\tcompletions,\n\t\t\t\tcmd.prepareFishFlags([]Flag{HelpFlag}, command.Names())...,\n\t\t\t)\n\t\t}\n\n\t\t*allCommands = append(*allCommands, command.Names()...)\n\t\tcompletions = append(completions, completion.String())\n\t\tcompletions = append(\n\t\t\tcompletions,\n\t\t\tcmd.prepareFishFlags(command.VisibleFlags(), command.Names())...,\n\t\t)\n\n\t\t// recursively iterate subcommands\n\t\tif len(command.Commands) > 0 {\n\t\t\tcompletions = append(\n\t\t\t\tcompletions,\n\t\t\t\tcmd.prepareFishCommands(\n\t\t\t\t\tcommand.Commands, allCommands, command.Names(),\n\t\t\t\t)...,\n\t\t\t)\n\t\t}\n\t}\n\n\treturn completions\n}\n\nfunc (cmd *Command) prepareFishFlags(flags []Flag, previousCommands []string) []string {\n\tcompletions := []string{}\n\tfor _, f := range flags {\n\t\tcompletion := &strings.Builder{}\n\t\tcompletion.WriteString(fmt.Sprintf(\n\t\t\t\"complete -c %s -n '%s'\",\n\t\t\tcmd.Name,\n\t\t\tcmd.fishSubcommandHelper(previousCommands),\n\t\t))\n\n\t\tfishAddFileFlag(f, completion)\n\n\t\tfor idx, opt := range f.Names() {\n\t\t\tif idx == 0 {\n\t\t\t\tcompletion.WriteString(fmt.Sprintf(\n\t\t\t\t\t\" -l %s\", strings.TrimSpace(opt),\n\t\t\t\t))\n\t\t\t} else {\n\t\t\t\tcompletion.WriteString(fmt.Sprintf(\n\t\t\t\t\t\" -s %s\", strings.TrimSpace(opt),\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\n\t\tif flag, ok := f.(DocGenerationFlag); ok {\n\t\t\tif flag.TakesValue() {\n\t\t\t\tcompletion.WriteString(\" -r\")\n\t\t\t}\n\n\t\t\tif flag.GetUsage() != \"\" {\n\t\t\t\tcompletion.WriteString(fmt.Sprintf(\" -d '%s'\",\n\t\t\t\t\tescapeSingleQuotes(flag.GetUsage())))\n\t\t\t}\n\t\t}\n\n\t\tcompletions = append(completions, completion.String())\n\t}\n\n\treturn completions\n}\n\nfunc fishAddFileFlag(flag Flag, completion *strings.Builder) {\n\tswitch f := flag.(type) {\n\tcase *StringFlag:\n\t\tif f.TakesFile {\n\t\t\treturn\n\t\t}\n\tcase *StringSliceFlag:\n\t\tif f.TakesFile {\n\t\t\treturn\n\t\t}\n\t}\n\tcompletion.WriteString(\" -f\")\n}\n\nfunc (cmd *Command) fishSubcommandHelper(allCommands []string) string {\n\tfishHelper := fmt.Sprintf(\"__fish_%s_no_subcommand\", cmd.Name)\n\tif len(allCommands) > 0 {\n\t\tfishHelper = fmt.Sprintf(\n\t\t\t\"__fish_seen_subcommand_from %s\",\n\t\t\tstrings.Join(allCommands, \" \"),\n\t\t)\n\t}\n\treturn fishHelper\n}\n\nfunc escapeSingleQuotes(input string) string {\n\treturn strings.Replace(input, `'`, `\\'`, -1)\n}\n"
        },
        {
          "name": "fish_test.go",
          "type": "blob",
          "size": 0.76953125,
          "content": "package cli\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestFishCompletion(t *testing.T) {\n\t// Given\n\tcmd := buildExtendedTestCommand()\n\tcmd.Flags = append(cmd.Flags,\n\t\t&StringFlag{\n\t\t\tName:      \"logfile\",\n\t\t\tTakesFile: true,\n\t\t},\n\t\t&StringSliceFlag{\n\t\t\tName:      \"foofile\",\n\t\t\tTakesFile: true,\n\t\t})\n\n\toldTemplate := FishCompletionTemplate\n\tdefer func() { FishCompletionTemplate = oldTemplate }()\n\tFishCompletionTemplate = \"{{something\"\n\n\t// test error case\n\t_, err1 := cmd.ToFishCompletion()\n\tassert.Error(t, err1)\n\n\t// reset the template\n\tFishCompletionTemplate = oldTemplate\n\t// When\n\tres, err := cmd.ToFishCompletion()\n\n\t// Then\n\trequire.NoError(t, err)\n\texpectFileContent(t, \"testdata/expected-fish-full.fish\", res)\n}\n"
        },
        {
          "name": "flag.go",
          "type": "blob",
          "size": 8.4111328125,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst defaultPlaceholder = \"value\"\n\nvar (\n\tdefaultSliceFlagSeparator       = \",\"\n\tdefaultMapFlagKeyValueSeparator = \"=\"\n\tdisableSliceFlagSeparator       = false\n)\n\nvar (\n\tslPfx = fmt.Sprintf(\"sl:::%d:::\", time.Now().UTC().UnixNano())\n\n\tcommaWhitespace = regexp.MustCompile(\"[, ]+.*\")\n)\n\n// GenerateShellCompletionFlag enables shell completion\nvar GenerateShellCompletionFlag Flag = &BoolFlag{\n\tName:   \"generate-shell-completion\",\n\tHidden: true,\n}\n\n// VersionFlag prints the version for the application\nvar VersionFlag Flag = &BoolFlag{\n\tName:        \"version\",\n\tAliases:     []string{\"v\"},\n\tUsage:       \"print the version\",\n\tHideDefault: true,\n\tLocal:       true,\n}\n\n// HelpFlag prints the help for all commands and subcommands.\n// Set to nil to disable the flag.  The subcommand\n// will still be added unless HideHelp or HideHelpCommand is set to true.\nvar HelpFlag Flag = &BoolFlag{\n\tName:        \"help\",\n\tAliases:     []string{\"h\"},\n\tUsage:       \"show help\",\n\tHideDefault: true,\n\tLocal:       true,\n}\n\n// FlagStringer converts a flag definition to a string. This is used by help\n// to display a flag.\nvar FlagStringer FlagStringFunc = stringifyFlag\n\n// Serializer is used to circumvent the limitations of flag.FlagSet.Set\ntype Serializer interface {\n\tSerialize() string\n}\n\n// FlagNamePrefixer converts a full flag name and its placeholder into the help\n// message flag prefix. This is used by the default FlagStringer.\nvar FlagNamePrefixer FlagNamePrefixFunc = prefixedNames\n\n// FlagEnvHinter annotates flag help message with the environment variable\n// details. This is used by the default FlagStringer.\nvar FlagEnvHinter FlagEnvHintFunc = withEnvHint\n\n// FlagFileHinter annotates flag help message with the environment variable\n// details. This is used by the default FlagStringer.\nvar FlagFileHinter FlagFileHintFunc = withFileHint\n\n// FlagsByName is a slice of Flag.\ntype FlagsByName []Flag\n\nfunc (f FlagsByName) Len() int {\n\treturn len(f)\n}\n\nfunc (f FlagsByName) Less(i, j int) bool {\n\tif len(f[j].Names()) == 0 {\n\t\treturn false\n\t} else if len(f[i].Names()) == 0 {\n\t\treturn true\n\t}\n\treturn lexicographicLess(f[i].Names()[0], f[j].Names()[0])\n}\n\nfunc (f FlagsByName) Swap(i, j int) {\n\tf[i], f[j] = f[j], f[i]\n}\n\n// ActionableFlag is an interface that wraps Flag interface and RunAction operation.\ntype ActionableFlag interface {\n\tRunAction(context.Context, *Command) error\n}\n\n// Flag is a common interface related to parsing flags in cli.\n// For more advanced flag parsing techniques, it is recommended that\n// this interface be implemented.\ntype Flag interface {\n\tfmt.Stringer\n\n\t// Apply Flag settings to the given flag set\n\tApply(*flag.FlagSet) error\n\n\t// All possible names for this flag\n\tNames() []string\n\n\t// Whether the flag has been set or not\n\tIsSet() bool\n}\n\n// RequiredFlag is an interface that allows us to mark flags as required\n// it allows flags required flags to be backwards compatible with the Flag interface\ntype RequiredFlag interface {\n\t// whether the flag is a required flag or not\n\tIsRequired() bool\n}\n\n// DocGenerationFlag is an interface that allows documentation generation for the flag\ntype DocGenerationFlag interface {\n\t// TakesValue returns true if the flag takes a value, otherwise false\n\tTakesValue() bool\n\n\t// GetUsage returns the usage string for the flag\n\tGetUsage() string\n\n\t// GetValue returns the flags value as string representation and an empty\n\t// string if the flag takes no value at all.\n\tGetValue() string\n\n\t// GetDefaultText returns the default text for this flag\n\tGetDefaultText() string\n\n\t// GetEnvVars returns the env vars for this flag\n\tGetEnvVars() []string\n\n\t// IsDefaultVisible returns whether the default value should be shown in\n\t// help text\n\tIsDefaultVisible() bool\n}\n\n// DocGenerationMultiValueFlag extends DocGenerationFlag for slice/map based flags.\ntype DocGenerationMultiValueFlag interface {\n\tDocGenerationFlag\n\n\t// IsMultiValueFlag returns true for flags that can be given multiple times.\n\tIsMultiValueFlag() bool\n}\n\n// Countable is an interface to enable detection of flag values which support\n// repetitive flags\ntype Countable interface {\n\tCount() int\n}\n\n// VisibleFlag is an interface that allows to check if a flag is visible\ntype VisibleFlag interface {\n\t// IsVisible returns true if the flag is not hidden, otherwise false\n\tIsVisible() bool\n}\n\n// CategorizableFlag is an interface that allows us to potentially\n// use a flag in a categorized representation.\ntype CategorizableFlag interface {\n\t// Returns the category of the flag\n\tGetCategory() string\n\n\t// Sets the category of the flag\n\tSetCategory(string)\n}\n\n// LocalFlag is an interface to enable detection of flags which are local\n// to current command\ntype LocalFlag interface {\n\tIsLocal() bool\n}\n\nfunc newFlagSet(name string, flags []Flag) (*flag.FlagSet, error) {\n\tset := flag.NewFlagSet(name, flag.ContinueOnError)\n\n\tfor _, f := range flags {\n\t\tif err := f.Apply(set); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tset.SetOutput(io.Discard)\n\n\treturn set, nil\n}\n\nfunc visibleFlags(fl []Flag) []Flag {\n\tvar visible []Flag\n\tfor _, f := range fl {\n\t\tif vf, ok := f.(VisibleFlag); ok && vf.IsVisible() {\n\t\t\tvisible = append(visible, f)\n\t\t}\n\t}\n\treturn visible\n}\n\nfunc prefixFor(name string) (prefix string) {\n\tif len(name) == 1 {\n\t\tprefix = \"-\"\n\t} else {\n\t\tprefix = \"--\"\n\t}\n\n\treturn\n}\n\n// Returns the placeholder, if any, and the unquoted usage string.\nfunc unquoteUsage(usage string) (string, string) {\n\tfor i := 0; i < len(usage); i++ {\n\t\tif usage[i] == '`' {\n\t\t\tfor j := i + 1; j < len(usage); j++ {\n\t\t\t\tif usage[j] == '`' {\n\t\t\t\t\tname := usage[i+1 : j]\n\t\t\t\t\tusage = usage[:i] + name + usage[j+1:]\n\t\t\t\t\treturn name, usage\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn \"\", usage\n}\n\nfunc prefixedNames(names []string, placeholder string) string {\n\tvar prefixed string\n\tfor i, name := range names {\n\t\tif name == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tprefixed += prefixFor(name) + name\n\t\tif placeholder != \"\" {\n\t\t\tprefixed += \" \" + placeholder\n\t\t}\n\t\tif i < len(names)-1 {\n\t\t\tprefixed += \", \"\n\t\t}\n\t}\n\treturn prefixed\n}\n\nfunc envFormat(envVars []string, prefix, sep, suffix string) string {\n\tif len(envVars) > 0 {\n\t\treturn fmt.Sprintf(\" [%s%s%s]\", prefix, strings.Join(envVars, sep), suffix)\n\t}\n\treturn \"\"\n}\n\nfunc defaultEnvFormat(envVars []string) string {\n\treturn envFormat(envVars, \"$\", \", $\", \"\")\n}\n\nfunc withEnvHint(envVars []string, str string) string {\n\tenvText := \"\"\n\tif runtime.GOOS != \"windows\" || os.Getenv(\"PSHOME\") != \"\" {\n\t\tenvText = defaultEnvFormat(envVars)\n\t} else {\n\t\tenvText = envFormat(envVars, \"%\", \"%, %\", \"%\")\n\t}\n\treturn str + envText\n}\n\nfunc FlagNames(name string, aliases []string) []string {\n\tvar ret []string\n\n\tfor _, part := range append([]string{name}, aliases...) {\n\t\t// v1 -> v2 migration warning zone:\n\t\t// Strip off anything after the first found comma or space, which\n\t\t// *hopefully* makes it a tiny bit more obvious that unexpected behavior is\n\t\t// caused by using the v1 form of stringly typed \"Name\".\n\t\tret = append(ret, commaWhitespace.ReplaceAllString(part, \"\"))\n\t}\n\n\treturn ret\n}\n\nfunc withFileHint(filePath, str string) string {\n\tfileText := \"\"\n\tif filePath != \"\" {\n\t\tfileText = fmt.Sprintf(\" [%s]\", filePath)\n\t}\n\treturn str + fileText\n}\n\nfunc formatDefault(format string) string {\n\treturn \" (default: \" + format + \")\"\n}\n\nfunc stringifyFlag(f Flag) string {\n\t// enforce DocGeneration interface on flags to avoid reflection\n\tdf, ok := f.(DocGenerationFlag)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tplaceholder, usage := unquoteUsage(df.GetUsage())\n\tneedsPlaceholder := df.TakesValue()\n\n\tif needsPlaceholder && placeholder == \"\" {\n\t\tplaceholder = defaultPlaceholder\n\t}\n\n\tdefaultValueString := \"\"\n\n\t// don't print default text for required flags\n\tif rf, ok := f.(RequiredFlag); !ok || !rf.IsRequired() {\n\t\tisVisible := df.IsDefaultVisible()\n\t\tif s := df.GetDefaultText(); isVisible && s != \"\" {\n\t\t\tdefaultValueString = fmt.Sprintf(formatDefault(\"%s\"), s)\n\t\t}\n\t}\n\n\tusageWithDefault := strings.TrimSpace(usage + defaultValueString)\n\n\tpn := prefixedNames(f.Names(), placeholder)\n\tsliceFlag, ok := f.(DocGenerationMultiValueFlag)\n\tif ok && sliceFlag.IsMultiValueFlag() {\n\t\tpn = pn + \" [ \" + pn + \" ]\"\n\t}\n\n\treturn withEnvHint(df.GetEnvVars(), fmt.Sprintf(\"%s\\t%s\", pn, usageWithDefault))\n}\n\nfunc hasFlag(flags []Flag, fl Flag) bool {\n\tfor _, existing := range flags {\n\t\tif fl == existing {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc flagSplitMultiValues(val string) []string {\n\tif disableSliceFlagSeparator {\n\t\treturn []string{val}\n\t}\n\n\treturn strings.Split(val, defaultSliceFlagSeparator)\n}\n"
        },
        {
          "name": "flag_bool.go",
          "type": "blob",
          "size": 1.654296875,
          "content": "package cli\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n)\n\ntype BoolFlag = FlagBase[bool, BoolConfig, boolValue]\n\n// BoolConfig defines the configuration for bool flags\ntype BoolConfig struct {\n\tCount *int\n}\n\n// boolValue needs to implement the boolFlag internal interface in flag\n// to be able to capture bool fields and values\n//\n//\ttype boolFlag interface {\n//\t\t  Value\n//\t\t  IsBoolFlag() bool\n//\t}\ntype boolValue struct {\n\tdestination *bool\n\tcount       *int\n}\n\nfunc (cmd *Command) Bool(name string) bool {\n\tif v, ok := cmd.Value(name).(bool); ok {\n\t\ttracef(\"bool available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"bool NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn false\n}\n\n// Below functions are to satisfy the ValueCreator interface\n\n// Create creates the bool value\nfunc (b boolValue) Create(val bool, p *bool, c BoolConfig) Value {\n\t*p = val\n\tif c.Count == nil {\n\t\tc.Count = new(int)\n\t}\n\treturn &boolValue{\n\t\tdestination: p,\n\t\tcount:       c.Count,\n\t}\n}\n\n// ToString formats the bool value\nfunc (b boolValue) ToString(value bool) string {\n\treturn strconv.FormatBool(value)\n}\n\n// Below functions are to satisfy the flag.Value interface\n\nfunc (b *boolValue) Set(s string) error {\n\tv, err := strconv.ParseBool(s)\n\tif err != nil {\n\t\terr = errors.New(\"parse error\")\n\t\treturn err\n\t}\n\t*b.destination = v\n\tif b.count != nil {\n\t\t*b.count = *b.count + 1\n\t}\n\treturn err\n}\n\nfunc (b *boolValue) Get() interface{} { return *b.destination }\n\nfunc (b *boolValue) String() string {\n\treturn strconv.FormatBool(*b.destination)\n}\n\nfunc (b *boolValue) IsBoolFlag() bool { return true }\n\nfunc (b *boolValue) Count() int {\n\treturn *b.count\n}\n"
        },
        {
          "name": "flag_bool_with_inverse.go",
          "type": "blob",
          "size": 4.5908203125,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nvar DefaultInverseBoolPrefix = \"no-\"\n\ntype BoolWithInverseFlag struct {\n\t// The BoolFlag which the positive and negative flags are generated from\n\t*BoolFlag\n\n\t// The prefix used to indicate a negative value\n\t// Default: `env` becomes `no-env`\n\tInversePrefix string\n\n\tpositiveFlag *BoolFlag\n\tnegativeFlag *BoolFlag\n\n\t// pointers obtained from the embedded bool flag\n\tposDest  *bool\n\tposCount *int\n\n\tnegDest *bool\n}\n\nfunc (parent *BoolWithInverseFlag) Flags() []Flag {\n\treturn []Flag{parent.positiveFlag, parent.negativeFlag}\n}\n\nfunc (parent *BoolWithInverseFlag) IsSet() bool {\n\treturn (*parent.posCount > 0) || (parent.positiveFlag.IsSet() || parent.negativeFlag.IsSet())\n}\n\nfunc (parent *BoolWithInverseFlag) Value() bool {\n\treturn *parent.posDest\n}\n\nfunc (parent *BoolWithInverseFlag) RunAction(ctx context.Context, cmd *Command) error {\n\tif *parent.negDest && *parent.posDest {\n\t\treturn fmt.Errorf(\"cannot set both flags `--%s` and `--%s`\", parent.positiveFlag.Name, parent.negativeFlag.Name)\n\t}\n\n\tif *parent.negDest {\n\t\t_ = cmd.Set(parent.positiveFlag.Name, \"false\")\n\t}\n\n\tif parent.BoolFlag.Action != nil {\n\t\treturn parent.BoolFlag.Action(ctx, cmd, parent.Value())\n\t}\n\n\treturn nil\n}\n\n// Initialize creates a new BoolFlag that has an inverse flag\n//\n// consider a bool flag `--env`, there is no way to set it to false\n// this function allows you to set `--env` or `--no-env` and in the command action\n// it can be determined that BoolWithInverseFlag.IsSet().\nfunc (parent *BoolWithInverseFlag) initialize() {\n\tchild := parent.BoolFlag\n\n\tparent.negDest = new(bool)\n\tif child.Destination != nil {\n\t\tparent.posDest = child.Destination\n\t} else {\n\t\tparent.posDest = new(bool)\n\t}\n\n\tif child.Config.Count != nil {\n\t\tparent.posCount = child.Config.Count\n\t} else {\n\t\tparent.posCount = new(int)\n\t}\n\n\tparent.positiveFlag = child\n\tparent.positiveFlag.Destination = parent.posDest\n\tparent.positiveFlag.Config.Count = parent.posCount\n\n\tparent.negativeFlag = &BoolFlag{\n\t\tCategory:    child.Category,\n\t\tDefaultText: child.DefaultText,\n\t\tSources:     NewValueSourceChain(child.Sources.Chain...),\n\t\tUsage:       child.Usage,\n\t\tRequired:    child.Required,\n\t\tHidden:      child.Hidden,\n\t\tLocal:       child.Local,\n\t\tValue:       child.Value,\n\t\tDestination: parent.negDest,\n\t\tTakesFile:   child.TakesFile,\n\t\tOnlyOnce:    child.OnlyOnce,\n\t\thasBeenSet:  child.hasBeenSet,\n\t\tapplied:     child.applied,\n\t\tcreator:     boolValue{},\n\t\tvalue:       child.value,\n\t}\n\n\t// Set inverse names ex: --env => --no-env\n\tparent.negativeFlag.Name = parent.inverseName()\n\tparent.negativeFlag.Aliases = parent.inverseAliases()\n\n\tif len(child.Sources.EnvKeys()) > 0 {\n\t\tsources := []ValueSource{}\n\n\t\tfor _, envVar := range child.GetEnvVars() {\n\t\t\tsources = append(sources, EnvVar(strings.ToUpper(parent.InversePrefix)+envVar))\n\t\t}\n\t\tparent.negativeFlag.Sources = NewValueSourceChain(sources...)\n\t}\n}\n\nfunc (parent *BoolWithInverseFlag) inverseName() string {\n\treturn parent.inversePrefix() + parent.BoolFlag.Name\n}\n\nfunc (parent *BoolWithInverseFlag) inversePrefix() string {\n\tif parent.InversePrefix == \"\" {\n\t\tparent.InversePrefix = DefaultInverseBoolPrefix\n\t}\n\n\treturn parent.InversePrefix\n}\n\nfunc (parent *BoolWithInverseFlag) inverseAliases() (aliases []string) {\n\tif len(parent.BoolFlag.Aliases) > 0 {\n\t\taliases = make([]string, len(parent.BoolFlag.Aliases))\n\t\tfor idx, alias := range parent.BoolFlag.Aliases {\n\t\t\taliases[idx] = parent.InversePrefix + alias\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (parent *BoolWithInverseFlag) Apply(set *flag.FlagSet) error {\n\tif parent.positiveFlag == nil {\n\t\tparent.initialize()\n\t}\n\n\tif err := parent.positiveFlag.Apply(set); err != nil {\n\t\treturn err\n\t}\n\n\tif err := parent.negativeFlag.Apply(set); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (parent *BoolWithInverseFlag) Names() []string {\n\t// Get Names when flag has not been initialized\n\tif parent.positiveFlag == nil {\n\t\treturn append(parent.BoolFlag.Names(), FlagNames(parent.inverseName(), parent.inverseAliases())...)\n\t}\n\n\tif *parent.negDest {\n\t\treturn parent.negativeFlag.Names()\n\t}\n\n\tif *parent.posDest {\n\t\treturn parent.positiveFlag.Names()\n\t}\n\n\treturn append(parent.negativeFlag.Names(), parent.positiveFlag.Names()...)\n}\n\n// String implements the standard Stringer interface.\n//\n// Example for BoolFlag{Name: \"env\"}\n// --[no-]env\t(default: false)\nfunc (parent *BoolWithInverseFlag) String() string {\n\tout := FlagStringer(parent)\n\ti := strings.Index(out, \"\\t\")\n\n\tprefix := \"--\"\n\n\t// single character flags are prefixed with `-` instead of `--`\n\tif len(parent.Name) == 1 {\n\t\tprefix = \"-\"\n\t}\n\n\treturn fmt.Sprintf(\"%s[%s]%s%s\", prefix, parent.inversePrefix(), parent.Name, out[i:])\n}\n"
        },
        {
          "name": "flag_bool_with_inverse_test.go",
          "type": "blob",
          "size": 9.546875,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar errBothEnvFlagsAreSet = fmt.Errorf(\"cannot set both flags `--env` and `--no-env`\")\n\ntype boolWithInverseTestCase struct {\n\targs    []string\n\ttoBeSet bool\n\tvalue   bool\n\terr     error\n\tenvVars map[string]string\n}\n\nfunc (tc *boolWithInverseTestCase) Run(t *testing.T, flagWithInverse *BoolWithInverseFlag) error {\n\tcmd := &Command{\n\t\tFlags:  []Flag{flagWithInverse},\n\t\tAction: func(context.Context, *Command) error { return nil },\n\t}\n\n\tfor key, val := range tc.envVars {\n\t\tt.Setenv(key, val)\n\t}\n\n\terr := cmd.Run(buildTestContext(t), append([]string{\"prog\"}, tc.args...))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif flagWithInverse.IsSet() != tc.toBeSet {\n\t\treturn fmt.Errorf(\"flag should be set %t, but got %t\", tc.toBeSet, flagWithInverse.IsSet())\n\t}\n\n\tif flagWithInverse.Value() != tc.value {\n\t\treturn fmt.Errorf(\"flag value should be %t, but got %t\", tc.value, flagWithInverse.Value())\n\t}\n\n\treturn nil\n}\n\nfunc runBoolWithInverseFlagTests(t *testing.T, newFlagMethod func() *BoolWithInverseFlag, cases []*boolWithInverseTestCase) error {\n\tfor _, tc := range cases {\n\t\tt.Run(strings.Join(tc.args, \" \")+fmt.Sprintf(\"%[1]v %[2]v %[3]v\", tc.value, tc.toBeSet, tc.err), func(t *testing.T) {\n\t\t\tr := require.New(t)\n\n\t\t\tfl := newFlagMethod()\n\n\t\t\terr := tc.Run(t, fl)\n\t\t\tif err != nil && tc.err == nil {\n\t\t\t\tr.NoError(err)\n\t\t\t}\n\n\t\t\tif err == nil && tc.err != nil {\n\t\t\t\tr.Error(err)\n\t\t\t}\n\n\t\t\tif err != nil && tc.err != nil {\n\t\t\t\tr.EqualError(err, tc.err.Error())\n\t\t\t}\n\t\t})\n\t}\n\n\treturn nil\n}\n\nfunc TestBoolWithInverseBasic(t *testing.T) {\n\tflagMethod := func() *BoolWithInverseFlag {\n\t\treturn &BoolWithInverseFlag{\n\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\tName: \"env\",\n\t\t\t},\n\t\t}\n\t}\n\n\ttestCases := []*boolWithInverseTestCase{\n\t\t{\n\t\t\targs:    []string{\"--no-env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs:    []string{\"--env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   true,\n\t\t},\n\t\t{\n\t\t\ttoBeSet: false,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--env\", \"--no-env\"},\n\t\t\terr:  errBothEnvFlagsAreSet,\n\t\t},\n\t}\n\n\terr := runBoolWithInverseFlagTests(t, flagMethod, testCases)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestBoolWithInverseAction(t *testing.T) {\n\tflagMethod := func() *BoolWithInverseFlag {\n\t\treturn &BoolWithInverseFlag{\n\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\tName: \"env\",\n\n\t\t\t\t// Setting env to the opposite to test flag Action is working as intended\n\t\t\t\tAction: func(_ context.Context, cmd *Command, value bool) error {\n\t\t\t\t\tif value {\n\t\t\t\t\t\treturn cmd.Set(\"env\", \"false\")\n\t\t\t\t\t}\n\n\t\t\t\t\treturn cmd.Set(\"env\", \"true\")\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\ttestCases := []*boolWithInverseTestCase{\n\t\t{\n\t\t\targs:    []string{\"--no-env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   true,\n\t\t},\n\t\t{\n\t\t\targs:    []string{\"--env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   false,\n\t\t},\n\n\t\t// This test is not inverse because the flag action is never called\n\t\t{\n\t\t\ttoBeSet: false,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--env\", \"--no-env\"},\n\t\t\terr:  errBothEnvFlagsAreSet,\n\t\t},\n\t}\n\n\terr := runBoolWithInverseFlagTests(t, flagMethod, testCases)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestBoolWithInverseAlias(t *testing.T) {\n\tflagMethod := func() *BoolWithInverseFlag {\n\t\treturn &BoolWithInverseFlag{\n\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\tName:    \"env\",\n\t\t\t\tAliases: []string{\"e\", \"do-env\"},\n\t\t\t},\n\t\t}\n\t}\n\n\ttestCases := []*boolWithInverseTestCase{\n\t\t{\n\t\t\targs:    []string{\"--no-e\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs:    []string{\"--e\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   true,\n\t\t},\n\t\t{\n\t\t\ttoBeSet: false,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--do-env\", \"--no-do-env\"},\n\t\t\terr:  errBothEnvFlagsAreSet,\n\t\t},\n\t}\n\n\terr := runBoolWithInverseFlagTests(t, flagMethod, testCases)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestBoolWithInverseEnvVars(t *testing.T) {\n\tflagMethod := func() *BoolWithInverseFlag {\n\t\treturn &BoolWithInverseFlag{\n\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\tName:    \"env\",\n\t\t\t\tSources: EnvVars(\"ENV\"),\n\t\t\t\tLocal:   true,\n\t\t\t},\n\t\t}\n\t}\n\n\ttestCases := []*boolWithInverseTestCase{\n\t\t{\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   false,\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"NO-ENV\": \"true\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   true,\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"ENV\": \"true\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   false,\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"ENV\": \"false\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttoBeSet: false,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\terr: errBothEnvFlagsAreSet,\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"ENV\":    \"true\",\n\t\t\t\t\"NO-ENV\": \"true\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\terr: fmt.Errorf(\"could not parse \\\"true_env\\\" as bool value from environment variable \\\"ENV\\\" for flag env: parse error\"),\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"ENV\": \"true_env\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\terr: fmt.Errorf(\"could not parse \\\"false_env\\\" as bool value from environment variable \\\"NO-ENV\\\" for flag no-env: parse error\"),\n\t\t\tenvVars: map[string]string{\n\t\t\t\t\"NO-ENV\": \"false_env\",\n\t\t\t},\n\t\t},\n\t}\n\n\terr := runBoolWithInverseFlagTests(t, flagMethod, testCases)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestBoolWithInverseWithPrefix(t *testing.T) {\n\tflagMethod := func() *BoolWithInverseFlag {\n\t\treturn &BoolWithInverseFlag{\n\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\tName: \"env\",\n\t\t\t},\n\t\t\tInversePrefix: \"without-\",\n\t\t}\n\t}\n\n\ttestCases := []*boolWithInverseTestCase{\n\t\t{\n\t\t\targs:    []string{\"--without-env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs:    []string{\"--env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   true,\n\t\t},\n\t\t{\n\t\t\ttoBeSet: false,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--env\", \"--without-env\"},\n\t\t\terr:  fmt.Errorf(\"cannot set both flags `--env` and `--without-env`\"),\n\t\t},\n\t}\n\n\terr := runBoolWithInverseFlagTests(t, flagMethod, testCases)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestBoolWithInverseRequired(t *testing.T) {\n\tflagMethod := func() *BoolWithInverseFlag {\n\t\treturn &BoolWithInverseFlag{\n\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\tName:     \"env\",\n\t\t\t\tRequired: true,\n\t\t\t},\n\t\t}\n\t}\n\n\ttestCases := []*boolWithInverseTestCase{\n\t\t{\n\t\t\targs:    []string{\"--no-env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   false,\n\t\t},\n\t\t{\n\t\t\targs:    []string{\"--env\"},\n\t\t\ttoBeSet: true,\n\t\t\tvalue:   true,\n\t\t},\n\t\t{\n\t\t\ttoBeSet: false,\n\t\t\tvalue:   false,\n\t\t\terr:     fmt.Errorf(`Required flag \"no-env\" not set`),\n\t\t},\n\t\t{\n\t\t\targs: []string{\"--env\", \"--no-env\"},\n\t\t\terr:  errBothEnvFlagsAreSet,\n\t\t},\n\t}\n\n\terr := runBoolWithInverseFlagTests(t, flagMethod, testCases)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n\nfunc TestBoolWithInverseNames(t *testing.T) {\n\tflag := &BoolWithInverseFlag{\n\t\tBoolFlag: &BoolFlag{\n\t\t\tName:     \"env\",\n\t\t\tRequired: true,\n\t\t},\n\t}\n\tnames := flag.Names()\n\n\trequire.Len(t, names, 2)\n\trequire.Equal(t, \"env\", names[0], \"expected first name to be `env`\")\n\trequire.Equal(t, \"no-env\", names[1], \"expected first name to be `no-env`\")\n}\n\nfunc TestBoolWithInverseString(t *testing.T) {\n\ttcs := []struct {\n\t\ttestName      string\n\t\tflagName      string\n\t\trequired      bool\n\t\tusage         string\n\t\tinversePrefix string\n\t\texpected      string\n\t}{\n\t\t{\n\t\t\ttestName: \"empty inverse prefix\",\n\t\t\tflagName: \"\",\n\t\t\trequired: true,\n\t\t\texpected: \"--[no-]\\t\",\n\t\t},\n\t\t{\n\t\t\ttestName: \"single-char flag name\",\n\t\t\tflagName: \"e\",\n\t\t\trequired: true,\n\t\t\texpected: \"-[no-]e\\t\",\n\t\t},\n\t\t{\n\t\t\ttestName: \"multi-char flag name\",\n\t\t\tflagName: \"env\",\n\t\t\trequired: true,\n\t\t\texpected: \"--[no-]env\\t\",\n\t\t},\n\t\t{\n\t\t\ttestName: \"required with usage\",\n\t\t\tflagName: \"env\",\n\t\t\trequired: true,\n\t\t\tusage:    \"env usage\",\n\t\t\texpected: \"--[no-]env\\tenv usage\",\n\t\t},\n\t\t{\n\t\t\ttestName: \"required without usage\",\n\t\t\tflagName: \"env\",\n\t\t\trequired: true,\n\t\t\texpected: \"--[no-]env\\t\",\n\t\t},\n\t\t{\n\t\t\ttestName: \"not required with default usage\",\n\t\t\tflagName: \"env\",\n\t\t\trequired: false,\n\t\t\texpected: \"--[no-]env\\t(default: false)\",\n\t\t},\n\t\t{\n\t\t\ttestName:      \"custom inverse prefix\",\n\t\t\tflagName:      \"env\",\n\t\t\trequired:      true,\n\t\t\tinversePrefix: \"nope-\",\n\t\t\texpected:      \"--[nope-]env\\t\",\n\t\t},\n\t\t{\n\t\t\ttestName: \"empty inverse prefix\",\n\t\t\tflagName: \"env\",\n\t\t\trequired: true,\n\t\t\texpected: \"--[no-]env\\t\",\n\t\t},\n\t}\n\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.testName, func(t *testing.T) {\n\t\t\tflag := &BoolWithInverseFlag{\n\t\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\t\tName:     tc.flagName,\n\t\t\t\t\tUsage:    tc.usage,\n\t\t\t\t\tRequired: tc.required,\n\t\t\t\t},\n\t\t\t\tInversePrefix: tc.inversePrefix,\n\t\t\t}\n\n\t\t\trequire.Equal(t, tc.expected, flag.String())\n\t\t})\n\t}\n}\n\nfunc TestBoolWithInverseDestination(t *testing.T) {\n\tdestination := new(bool)\n\tcount := new(int)\n\n\tflagMethod := func() *BoolWithInverseFlag {\n\t\treturn &BoolWithInverseFlag{\n\t\t\tBoolFlag: &BoolFlag{\n\t\t\t\tName:        \"env\",\n\t\t\t\tDestination: destination,\n\t\t\t\tConfig: BoolConfig{\n\t\t\t\t\tCount: count,\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\tcheckAndReset := func(expectedCount int, expectedValue bool) error {\n\t\tif *count != expectedCount {\n\t\t\treturn fmt.Errorf(\"expected count to be %d, got %d\", expectedCount, *count)\n\t\t}\n\n\t\tif *destination != expectedValue {\n\t\t\treturn fmt.Errorf(\"expected destination to be %t, got %t\", expectedValue, *destination)\n\t\t}\n\n\t\t*count = 0\n\t\t*destination = false\n\n\t\treturn nil\n\t}\n\n\terr := (&boolWithInverseTestCase{\n\t\targs:    []string{\"--env\"},\n\t\ttoBeSet: true,\n\t\tvalue:   true,\n\t}).Run(t, flagMethod())\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = checkAndReset(1, true)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = (&boolWithInverseTestCase{\n\t\targs:    []string{\"--no-env\"},\n\t\ttoBeSet: true,\n\t\tvalue:   false,\n\t}).Run(t, flagMethod())\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = checkAndReset(1, false)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = (&boolWithInverseTestCase{\n\t\targs:    []string{},\n\t\ttoBeSet: false,\n\t\tvalue:   false,\n\t}).Run(t, flagMethod())\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\n\terr = checkAndReset(0, false)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "flag_duration.go",
          "type": "blob",
          "size": 1.095703125,
          "content": "package cli\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype DurationFlag = FlagBase[time.Duration, NoConfig, durationValue]\n\n// -- time.Duration Value\ntype durationValue time.Duration\n\n// Below functions are to satisfy the ValueCreator interface\n\nfunc (d durationValue) Create(val time.Duration, p *time.Duration, c NoConfig) Value {\n\t*p = val\n\treturn (*durationValue)(p)\n}\n\nfunc (d durationValue) ToString(val time.Duration) string {\n\treturn fmt.Sprintf(\"%v\", val)\n}\n\n// Below functions are to satisfy the flag.Value interface\n\nfunc (d *durationValue) Set(s string) error {\n\tv, err := time.ParseDuration(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*d = durationValue(v)\n\treturn err\n}\n\nfunc (d *durationValue) Get() any { return time.Duration(*d) }\n\nfunc (d *durationValue) String() string { return (*time.Duration)(d).String() }\n\nfunc (cmd *Command) Duration(name string) time.Duration {\n\tif v, ok := cmd.Value(name).(time.Duration); ok {\n\t\ttracef(\"duration available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"bool NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn 0\n}\n"
        },
        {
          "name": "flag_ext.go",
          "type": "blob",
          "size": 0.6943359375,
          "content": "package cli\n\nimport \"flag\"\n\ntype extFlag struct {\n\tf *flag.Flag\n}\n\nfunc (e *extFlag) Apply(fs *flag.FlagSet) error {\n\tfs.Var(e.f.Value, e.f.Name, e.f.Usage)\n\treturn nil\n}\n\nfunc (e *extFlag) Names() []string {\n\treturn []string{e.f.Name}\n}\n\nfunc (e *extFlag) IsSet() bool {\n\treturn false\n}\n\nfunc (e *extFlag) String() string {\n\treturn FlagStringer(e)\n}\n\nfunc (e *extFlag) IsVisible() bool {\n\treturn true\n}\n\nfunc (e *extFlag) TakesValue() bool {\n\treturn false\n}\n\nfunc (e *extFlag) GetUsage() string {\n\treturn e.f.Usage\n}\n\nfunc (e *extFlag) GetValue() string {\n\treturn e.f.Value.String()\n}\n\nfunc (e *extFlag) GetDefaultText() string {\n\treturn e.f.DefValue\n}\n\nfunc (e *extFlag) GetEnvVars() []string {\n\treturn nil\n}\n"
        },
        {
          "name": "flag_float.go",
          "type": "blob",
          "size": 1.1103515625,
          "content": "package cli\n\nimport (\n\t\"strconv\"\n)\n\ntype FloatFlag = FlagBase[float64, NoConfig, floatValue]\n\n// -- float64 Value\ntype floatValue float64\n\n// Below functions are to satisfy the ValueCreator interface\n\nfunc (f floatValue) Create(val float64, p *float64, c NoConfig) Value {\n\t*p = val\n\treturn (*floatValue)(p)\n}\n\nfunc (f floatValue) ToString(b float64) string {\n\treturn strconv.FormatFloat(b, 'g', -1, 64)\n}\n\n// Below functions are to satisfy the flag.Value interface\n\nfunc (f *floatValue) Set(s string) error {\n\tv, err := strconv.ParseFloat(s, 64)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*f = floatValue(v)\n\treturn err\n}\n\nfunc (f *floatValue) Get() any { return float64(*f) }\n\nfunc (f *floatValue) String() string { return strconv.FormatFloat(float64(*f), 'g', -1, 64) }\n\n// Float looks up the value of a local FloatFlag, returns\n// 0 if not found\nfunc (cmd *Command) Float(name string) float64 {\n\tif v, ok := cmd.Value(name).(float64); ok {\n\t\ttracef(\"float available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"float NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn 0\n}\n"
        },
        {
          "name": "flag_float_slice.go",
          "type": "blob",
          "size": 0.599609375,
          "content": "package cli\n\ntype (\n\tFloatSlice     = SliceBase[float64, NoConfig, floatValue]\n\tFloatSliceFlag = FlagBase[[]float64, NoConfig, FloatSlice]\n)\n\nvar NewFloatSlice = NewSliceBase[float64, NoConfig, floatValue]\n\n// FloatSlice looks up the value of a local FloatSliceFlag, returns\n// nil if not found\nfunc (cmd *Command) FloatSlice(name string) []float64 {\n\tif v, ok := cmd.Value(name).([]float64); ok {\n\t\ttracef(\"float slice available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"float slice NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n"
        },
        {
          "name": "flag_generic.go",
          "type": "blob",
          "size": 1.265625,
          "content": "package cli\n\ntype GenericFlag = FlagBase[Value, NoConfig, genericValue]\n\n// -- Value Value\ntype genericValue struct {\n\tval Value\n}\n\n// Below functions are to satisfy the ValueCreator interface\n\nfunc (f genericValue) Create(val Value, p *Value, c NoConfig) Value {\n\t*p = val\n\treturn &genericValue{\n\t\tval: *p,\n\t}\n}\n\nfunc (f genericValue) ToString(b Value) string {\n\tif b != nil {\n\t\treturn b.String()\n\t}\n\treturn \"\"\n}\n\n// Below functions are to satisfy the flag.Value interface\n\nfunc (f *genericValue) Set(s string) error {\n\tif f.val != nil {\n\t\treturn f.val.Set(s)\n\t}\n\treturn nil\n}\n\nfunc (f *genericValue) Get() any {\n\tif f.val != nil {\n\t\treturn f.val.Get()\n\t}\n\treturn nil\n}\n\nfunc (f *genericValue) String() string {\n\tif f.val != nil {\n\t\treturn f.val.String()\n\t}\n\treturn \"\"\n}\n\nfunc (f *genericValue) IsBoolFlag() bool {\n\tif f.val == nil {\n\t\treturn false\n\t}\n\tbf, ok := f.val.(boolFlag)\n\treturn ok && bf.IsBoolFlag()\n}\n\n// Generic looks up the value of a local GenericFlag, returns\n// nil if not found\nfunc (cmd *Command) Generic(name string) Value {\n\tif v, ok := cmd.Value(name).(Value); ok {\n\t\ttracef(\"generic available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"generic NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n"
        },
        {
          "name": "flag_impl.go",
          "type": "blob",
          "size": 8.73828125,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"flag\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Value represents a value as used by cli.\n// For now it implements the golang flag.Value interface\ntype Value interface {\n\tflag.Value\n\tflag.Getter\n}\n\ntype boolFlag interface {\n\tIsBoolFlag() bool\n}\n\ntype fnValue struct {\n\tfn     func(string) error\n\tisBool bool\n\tv      Value\n}\n\nfunc (f *fnValue) Get() any           { return f.v.Get() }\nfunc (f *fnValue) Set(s string) error { return f.fn(s) }\nfunc (f *fnValue) String() string {\n\tif f.v == nil {\n\t\treturn \"\"\n\t}\n\treturn f.v.String()\n}\n\nfunc (f *fnValue) IsBoolFlag() bool { return f.isBool }\nfunc (f *fnValue) Count() int {\n\tif s, ok := f.v.(Countable); ok {\n\t\treturn s.Count()\n\t}\n\treturn 0\n}\n\n// ValueCreator is responsible for creating a flag.Value emulation\n// as well as custom formatting\n//\n//\tT specifies the type\n//\tC specifies the config for the type\ntype ValueCreator[T any, C any] interface {\n\tCreate(T, *T, C) Value\n\tToString(T) string\n}\n\n// NoConfig is for flags which dont need a custom configuration\ntype NoConfig struct{}\n\n// FlagBase [T,C,VC] is a generic flag base which can be used\n// as a boilerplate to implement the most common interfaces\n// used by urfave/cli.\n//\n//\tT specifies the type\n//\tC specifies the configuration required(if any for that flag type)\n//\tVC specifies the value creator which creates the flag.Value emulation\ntype FlagBase[T any, C any, VC ValueCreator[T, C]] struct {\n\tName             string                                   `json:\"name\"`             // name of the flag\n\tCategory         string                                   `json:\"category\"`         // category of the flag, if any\n\tDefaultText      string                                   `json:\"defaultText\"`      // default text of the flag for usage purposes\n\tHideDefault      bool                                     `json:\"hideDefault\"`      // whether to hide the default value in output\n\tUsage            string                                   `json:\"usage\"`            // usage string for help output\n\tSources          ValueSourceChain                         `json:\"-\"`                // sources to load flag value from\n\tRequired         bool                                     `json:\"required\"`         // whether the flag is required or not\n\tHidden           bool                                     `json:\"hidden\"`           // whether to hide the flag in help output\n\tLocal            bool                                     `json:\"local\"`            // whether the flag needs to be applied to subcommands as well\n\tValue            T                                        `json:\"defaultValue\"`     // default value for this flag if not set by from any source\n\tDestination      *T                                       `json:\"-\"`                // destination pointer for value when set\n\tAliases          []string                                 `json:\"aliases\"`          // Aliases that are allowed for this flag\n\tTakesFile        bool                                     `json:\"takesFileArg\"`     // whether this flag takes a file argument, mainly for shell completion purposes\n\tAction           func(context.Context, *Command, T) error `json:\"-\"`                // Action callback to be called when flag is set\n\tConfig           C                                        `json:\"config\"`           // Additional/Custom configuration associated with this flag type\n\tOnlyOnce         bool                                     `json:\"onlyOnce\"`         // whether this flag can be duplicated on the command line\n\tValidator        func(T) error                            `json:\"-\"`                // custom function to validate this flag value\n\tValidateDefaults bool                                     `json:\"validateDefaults\"` // whether to validate defaults or not\n\n\t// unexported fields for internal use\n\tcount      int   // number of times the flag has been set\n\thasBeenSet bool  // whether the flag has been set from env or file\n\tapplied    bool  // whether the flag has been applied to a flag set already\n\tcreator    VC    // value creator for this flag type\n\tvalue      Value // value representing this flag's value\n}\n\n// GetValue returns the flags value as string representation and an empty\n// string if the flag takes no value at all.\nfunc (f *FlagBase[T, C, V]) GetValue() string {\n\tif !f.TakesValue() {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"%v\", f.Value)\n}\n\n// Apply populates the flag given the flag set and environment\nfunc (f *FlagBase[T, C, V]) Apply(set *flag.FlagSet) error {\n\ttracef(\"apply (flag=%[1]q)\", f.Name)\n\n\t// TODO move this phase into a separate flag initialization function\n\t// if flag has been applied previously then it would have already been set\n\t// from env or file. So no need to apply the env set again. However\n\t// lots of units tests prior to persistent flags assumed that the\n\t// flag can be applied to different flag sets multiple times while still\n\t// keeping the env set.\n\tif !f.applied || f.Local {\n\t\tnewVal := f.Value\n\n\t\tif val, source, found := f.Sources.LookupWithSource(); found {\n\t\t\ttmpVal := f.creator.Create(f.Value, new(T), f.Config)\n\t\t\tif val != \"\" || reflect.TypeOf(f.Value).Kind() == reflect.String {\n\t\t\t\tif err := tmpVal.Set(val); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\n\t\t\t\t\t\t\"could not parse %[1]q as %[2]T value from %[3]s for flag %[4]s: %[5]s\",\n\t\t\t\t\t\tval, f.Value, source, f.Name, err,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t} else if val == \"\" && reflect.TypeOf(f.Value).Kind() == reflect.Bool {\n\t\t\t\t_ = tmpVal.Set(\"false\")\n\t\t\t}\n\n\t\t\tnewVal = tmpVal.Get().(T)\n\t\t\tf.hasBeenSet = true\n\t\t}\n\n\t\tif f.Destination == nil {\n\t\t\tf.value = f.creator.Create(newVal, new(T), f.Config)\n\t\t} else {\n\t\t\tf.value = f.creator.Create(newVal, f.Destination, f.Config)\n\t\t}\n\n\t\t// Validate the given default or values set from external sources as well\n\t\tif f.Validator != nil && f.ValidateDefaults {\n\t\t\tif err := f.Validator(f.value.Get().(T)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tisBool := false\n\tif b, ok := f.value.(boolFlag); ok && b.IsBoolFlag() {\n\t\tisBool = true\n\t}\n\n\tfor _, name := range f.Names() {\n\t\tset.Var(&fnValue{\n\t\t\tfn: func(val string) error {\n\t\t\t\tif f.count == 1 && f.OnlyOnce {\n\t\t\t\t\treturn fmt.Errorf(\"cant duplicate this flag\")\n\t\t\t\t}\n\t\t\t\tf.count++\n\t\t\t\tif err := f.value.Set(val); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tf.hasBeenSet = true\n\t\t\t\tif f.Validator != nil {\n\t\t\t\t\tif err := f.Validator(f.value.Get().(T)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tisBool: isBool,\n\t\t\tv:      f.value,\n\t\t}, name, f.Usage)\n\t}\n\n\tf.applied = true\n\treturn nil\n}\n\n// IsDefaultVisible returns true if the flag is not hidden, otherwise false\nfunc (f *FlagBase[T, C, V]) IsDefaultVisible() bool {\n\treturn !f.HideDefault\n}\n\n// String returns a readable representation of this value (for usage defaults)\nfunc (f *FlagBase[T, C, V]) String() string {\n\treturn FlagStringer(f)\n}\n\n// IsSet returns whether or not the flag has been set through env or file\nfunc (f *FlagBase[T, C, V]) IsSet() bool {\n\treturn f.hasBeenSet\n}\n\n// Names returns the names of the flag\nfunc (f *FlagBase[T, C, V]) Names() []string {\n\treturn FlagNames(f.Name, f.Aliases)\n}\n\n// IsRequired returns whether or not the flag is required\nfunc (f *FlagBase[T, C, V]) IsRequired() bool {\n\treturn f.Required\n}\n\n// IsVisible returns true if the flag is not hidden, otherwise false\nfunc (f *FlagBase[T, C, V]) IsVisible() bool {\n\treturn !f.Hidden\n}\n\n// GetCategory returns the category of the flag\nfunc (f *FlagBase[T, C, V]) GetCategory() string {\n\treturn f.Category\n}\n\nfunc (f *FlagBase[T, C, V]) SetCategory(c string) {\n\tf.Category = c\n}\n\n// GetUsage returns the usage string for the flag\nfunc (f *FlagBase[T, C, V]) GetUsage() string {\n\treturn f.Usage\n}\n\n// GetEnvVars returns the env vars for this flag\nfunc (f *FlagBase[T, C, V]) GetEnvVars() []string {\n\treturn f.Sources.EnvKeys()\n}\n\n// TakesValue returns true if the flag takes a value, otherwise false\nfunc (f *FlagBase[T, C, V]) TakesValue() bool {\n\tvar t T\n\treturn reflect.TypeOf(t) == nil || reflect.TypeOf(t).Kind() != reflect.Bool\n}\n\n// GetDefaultText returns the default text for this flag\nfunc (f *FlagBase[T, C, V]) GetDefaultText() string {\n\tif f.DefaultText != \"\" {\n\t\treturn f.DefaultText\n\t}\n\tvar v V\n\treturn v.ToString(f.Value)\n}\n\n// RunAction executes flag action if set\nfunc (f *FlagBase[T, C, V]) RunAction(ctx context.Context, cmd *Command) error {\n\tif f.Action != nil {\n\t\treturn f.Action(ctx, cmd, cmd.Value(f.Name).(T))\n\t}\n\n\treturn nil\n}\n\n// IsMultiValueFlag returns true if the value type T can take multiple\n// values from cmd line. This is true for slice and map type flags\nfunc (f *FlagBase[T, C, VC]) IsMultiValueFlag() bool {\n\t// TBD how to specify\n\tif reflect.TypeOf(f.Value) == nil {\n\t\treturn false\n\t}\n\tkind := reflect.TypeOf(f.Value).Kind()\n\treturn kind == reflect.Slice || kind == reflect.Map\n}\n\n// IsLocal returns false if flag needs to be persistent across subcommands\nfunc (f *FlagBase[T, C, VC]) IsLocal() bool {\n\treturn f.Local\n}\n"
        },
        {
          "name": "flag_int.go",
          "type": "blob",
          "size": 1.2158203125,
          "content": "package cli\n\nimport (\n\t\"strconv\"\n)\n\ntype IntFlag = FlagBase[int64, IntegerConfig, intValue]\n\n// IntegerConfig is the configuration for all integer type flags\ntype IntegerConfig struct {\n\tBase int\n}\n\n// -- int64 Value\ntype intValue struct {\n\tval  *int64\n\tbase int\n}\n\n// Below functions are to satisfy the ValueCreator interface\n\nfunc (i intValue) Create(val int64, p *int64, c IntegerConfig) Value {\n\t*p = val\n\treturn &intValue{\n\t\tval:  p,\n\t\tbase: c.Base,\n\t}\n}\n\nfunc (i intValue) ToString(b int64) string {\n\treturn strconv.FormatInt(b, 10)\n}\n\n// Below functions are to satisfy the flag.Value interface\n\nfunc (i *intValue) Set(s string) error {\n\tv, err := strconv.ParseInt(s, i.base, 64)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*i.val = v\n\treturn err\n}\n\nfunc (i *intValue) Get() any { return int64(*i.val) }\n\nfunc (i *intValue) String() string { return strconv.FormatInt(int64(*i.val), 10) }\n\n// Int looks up the value of a local Int64Flag, returns\n// 0 if not found\nfunc (cmd *Command) Int(name string) int64 {\n\tif v, ok := cmd.Value(name).(int64); ok {\n\t\ttracef(\"int available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"int NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn 0\n}\n"
        },
        {
          "name": "flag_int_slice.go",
          "type": "blob",
          "size": 0.5830078125,
          "content": "package cli\n\ntype (\n\tIntSlice     = SliceBase[int64, IntegerConfig, intValue]\n\tIntSliceFlag = FlagBase[[]int64, IntegerConfig, IntSlice]\n)\n\nvar NewIntSlice = NewSliceBase[int64, IntegerConfig, intValue]\n\n// IntSlice looks up the value of a local IntSliceFlag, returns\n// nil if not found\nfunc (cmd *Command) IntSlice(name string) []int64 {\n\tif v, ok := cmd.Value(name).([]int64); ok {\n\t\ttracef(\"int slice available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"int slice NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n"
        },
        {
          "name": "flag_map_impl.go",
          "type": "blob",
          "size": 2.59375,
          "content": "package cli\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// MapBase wraps map[string]T to satisfy flag.Value\ntype MapBase[T any, C any, VC ValueCreator[T, C]] struct {\n\tdict       *map[string]T\n\thasBeenSet bool\n\tvalue      Value\n}\n\nfunc (i MapBase[T, C, VC]) Create(val map[string]T, p *map[string]T, c C) Value {\n\t*p = map[string]T{}\n\tfor k, v := range val {\n\t\t(*p)[k] = v\n\t}\n\tvar t T\n\tnp := new(T)\n\tvar vc VC\n\treturn &MapBase[T, C, VC]{\n\t\tdict:  p,\n\t\tvalue: vc.Create(t, np, c),\n\t}\n}\n\n// NewMapBase makes a *MapBase with default values\nfunc NewMapBase[T any, C any, VC ValueCreator[T, C]](defaults map[string]T) *MapBase[T, C, VC] {\n\treturn &MapBase[T, C, VC]{\n\t\tdict: &defaults,\n\t}\n}\n\n// Set parses the value and appends it to the list of values\nfunc (i *MapBase[T, C, VC]) Set(value string) error {\n\tif !i.hasBeenSet {\n\t\t*i.dict = map[string]T{}\n\t\ti.hasBeenSet = true\n\t}\n\n\tif strings.HasPrefix(value, slPfx) {\n\t\t// Deserializing assumes overwrite\n\t\t_ = json.Unmarshal([]byte(strings.Replace(value, slPfx, \"\", 1)), &i.dict)\n\t\ti.hasBeenSet = true\n\t\treturn nil\n\t}\n\n\tfor _, item := range flagSplitMultiValues(value) {\n\t\tkey, value, ok := strings.Cut(item, defaultMapFlagKeyValueSeparator)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"item %q is missing separator %q\", item, defaultMapFlagKeyValueSeparator)\n\t\t}\n\t\tif err := i.value.Set(value); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t(*i.dict)[key] = i.value.Get().(T)\n\t}\n\n\treturn nil\n}\n\n// String returns a readable representation of this value (for usage defaults)\nfunc (i *MapBase[T, C, VC]) String() string {\n\tv := i.Value()\n\tvar t T\n\tif reflect.TypeOf(t).Kind() == reflect.String {\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}\n\treturn fmt.Sprintf(\"%T{%s}\", v, i.ToString(v))\n}\n\n// Serialize allows MapBase to fulfill Serializer\nfunc (i *MapBase[T, C, VC]) Serialize() string {\n\tjsonBytes, _ := json.Marshal(i.dict)\n\treturn fmt.Sprintf(\"%s%s\", slPfx, string(jsonBytes))\n}\n\n// Value returns the mapping of values set by this flag\nfunc (i *MapBase[T, C, VC]) Value() map[string]T {\n\tif i.dict == nil {\n\t\treturn map[string]T{}\n\t}\n\treturn *i.dict\n}\n\n// Get returns the mapping of values set by this flag\nfunc (i *MapBase[T, C, VC]) Get() interface{} {\n\treturn *i.dict\n}\n\nfunc (i MapBase[T, C, VC]) ToString(t map[string]T) string {\n\tvar defaultVals []string\n\tvar vc VC\n\tfor _, k := range sortedKeys(t) {\n\t\tdefaultVals = append(defaultVals, k+defaultMapFlagKeyValueSeparator+vc.ToString(t[k]))\n\t}\n\treturn strings.Join(defaultVals, \", \")\n}\n\nfunc sortedKeys[T any](dict map[string]T) []string {\n\tkeys := make([]string, 0, len(dict))\n\tfor k := range dict {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}\n"
        },
        {
          "name": "flag_mutex.go",
          "type": "blob",
          "size": 1.12109375,
          "content": "package cli\n\n// MutuallyExclusiveFlags defines a mutually exclusive flag group\n// Multiple option paths can be provided out of which\n// only one can be defined on cmdline\n// So for example\n// [ --foo | [ --bar something --darth somethingelse ] ]\ntype MutuallyExclusiveFlags struct {\n\t// Flag list\n\tFlags [][]Flag\n\n\t// whether this group is required\n\tRequired bool\n\n\t// Category to apply to all flags within group\n\tCategory string\n}\n\nfunc (grp MutuallyExclusiveFlags) check(cmd *Command) error {\n\toneSet := false\n\te := &mutuallyExclusiveGroup{}\n\n\tfor _, grpf := range grp.Flags {\n\t\tfor _, f := range grpf {\n\t\t\tfor _, name := range f.Names() {\n\t\t\t\tif cmd.IsSet(name) {\n\t\t\t\t\tif oneSet {\n\t\t\t\t\t\te.flag2Name = name\n\t\t\t\t\t\treturn e\n\t\t\t\t\t}\n\t\t\t\t\te.flag1Name = name\n\t\t\t\t\toneSet = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif oneSet {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif !oneSet && grp.Required {\n\t\treturn &mutuallyExclusiveGroupRequiredFlag{flags: &grp}\n\t}\n\treturn nil\n}\n\nfunc (grp MutuallyExclusiveFlags) propagateCategory() {\n\tfor _, grpf := range grp.Flags {\n\t\tfor _, f := range grpf {\n\t\t\tif cf, ok := f.(CategorizableFlag); ok {\n\t\t\t\tcf.SetCategory(grp.Category)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "flag_mutex_test.go",
          "type": "blob",
          "size": 1.802734375,
          "content": "package cli\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFlagMutuallyExclusiveFlags(t *testing.T) {\n\tcmd := &Command{\n\t\tMutuallyExclusiveFlags: []MutuallyExclusiveFlags{\n\t\t\t{\n\t\t\t\tFlags: [][]Flag{\n\t\t\t\t\t{\n\t\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\t\tName: \"i\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\t\tName: \"s\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t&IntFlag{\n\t\t\t\t\t\t\tName:    \"t\",\n\t\t\t\t\t\t\tAliases: []string{\"ai\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\"})\n\tassert.NoError(t, err)\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"--i\", \"10\"})\n\tassert.NoError(t, err)\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"--i\", \"11\", \"--ai\", \"12\"})\n\tif err == nil {\n\t\tt.Error(\"Expected mutual exclusion error\")\n\t} else if err1, ok := err.(*mutuallyExclusiveGroup); !ok {\n\t\tt.Errorf(\"Got invalid error %v\", err)\n\t} else if !strings.Contains(err1.Error(), \"option i cannot be set along with option ai\") {\n\t\tt.Errorf(\"Invalid error string %v\", err1)\n\t}\n\n\tcmd.MutuallyExclusiveFlags[0].Required = true\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\"})\n\tif err == nil {\n\t\tt.Error(\"Required flags error\")\n\t} else if err1, ok := err.(*mutuallyExclusiveGroupRequiredFlag); !ok {\n\t\tt.Errorf(\"Got invalid error %v\", err)\n\t} else if !strings.Contains(err1.Error(), \"one of\") {\n\t\tt.Errorf(\"Invalid error string %v\", err1)\n\t}\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"--i\", \"10\"})\n\tassert.NoError(t, err)\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"--i\", \"11\", \"--ai\", \"12\"})\n\tif err == nil {\n\t\tt.Error(\"Expected mutual exclusion error\")\n\t} else if err1, ok := err.(*mutuallyExclusiveGroup); !ok {\n\t\tt.Errorf(\"Got invalid error %v\", err)\n\t} else if !strings.Contains(err1.Error(), \"option i cannot be set along with option ai\") {\n\t\tt.Errorf(\"Invalid error string %v\", err1)\n\t}\n}\n"
        },
        {
          "name": "flag_slice_base.go",
          "type": "blob",
          "size": 2.1376953125,
          "content": "package cli\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// SliceBase wraps []T to satisfy flag.Value\ntype SliceBase[T any, C any, VC ValueCreator[T, C]] struct {\n\tslice      *[]T\n\thasBeenSet bool\n\tvalue      Value\n}\n\nfunc (i SliceBase[T, C, VC]) Create(val []T, p *[]T, c C) Value {\n\t*p = []T{}\n\t*p = append(*p, val...)\n\tvar t T\n\tnp := new(T)\n\tvar vc VC\n\treturn &SliceBase[T, C, VC]{\n\t\tslice: p,\n\t\tvalue: vc.Create(t, np, c),\n\t}\n}\n\n// NewSliceBase makes a *SliceBase with default values\nfunc NewSliceBase[T any, C any, VC ValueCreator[T, C]](defaults ...T) *SliceBase[T, C, VC] {\n\treturn &SliceBase[T, C, VC]{\n\t\tslice: &defaults,\n\t}\n}\n\n// Set parses the value and appends it to the list of values\nfunc (i *SliceBase[T, C, VC]) Set(value string) error {\n\tif !i.hasBeenSet {\n\t\t*i.slice = []T{}\n\t\ti.hasBeenSet = true\n\t}\n\n\tif strings.HasPrefix(value, slPfx) {\n\t\t// Deserializing assumes overwrite\n\t\t_ = json.Unmarshal([]byte(strings.Replace(value, slPfx, \"\", 1)), &i.slice)\n\t\ti.hasBeenSet = true\n\t\treturn nil\n\t}\n\n\tfor _, s := range flagSplitMultiValues(value) {\n\t\tif err := i.value.Set(strings.TrimSpace(s)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*i.slice = append(*i.slice, i.value.Get().(T))\n\t}\n\n\treturn nil\n}\n\n// String returns a readable representation of this value (for usage defaults)\nfunc (i *SliceBase[T, C, VC]) String() string {\n\tv := i.Value()\n\tvar t T\n\tif reflect.TypeOf(t).Kind() == reflect.String {\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}\n\treturn fmt.Sprintf(\"%T{%s}\", v, i.ToString(v))\n}\n\n// Serialize allows SliceBase to fulfill Serializer\nfunc (i *SliceBase[T, C, VC]) Serialize() string {\n\tjsonBytes, _ := json.Marshal(i.slice)\n\treturn fmt.Sprintf(\"%s%s\", slPfx, string(jsonBytes))\n}\n\n// Value returns the slice of values set by this flag\nfunc (i *SliceBase[T, C, VC]) Value() []T {\n\tif i.slice == nil {\n\t\treturn nil\n\t}\n\treturn *i.slice\n}\n\n// Get returns the slice of values set by this flag\nfunc (i *SliceBase[T, C, VC]) Get() interface{} {\n\treturn *i.slice\n}\n\nfunc (i SliceBase[T, C, VC]) ToString(t []T) string {\n\tvar defaultVals []string\n\tvar v VC\n\tfor _, s := range t {\n\t\tdefaultVals = append(defaultVals, v.ToString(s))\n\t}\n\treturn strings.Join(defaultVals, \", \")\n}\n"
        },
        {
          "name": "flag_string.go",
          "type": "blob",
          "size": 1.3115234375,
          "content": "package cli\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype StringFlag = FlagBase[string, StringConfig, stringValue]\n\n// StringConfig defines the configuration for string flags\ntype StringConfig struct {\n\t// Whether to trim whitespace of parsed value\n\tTrimSpace bool\n}\n\n// -- string Value\ntype stringValue struct {\n\tdestination *string\n\ttrimSpace   bool\n}\n\n// Below functions are to satisfy the ValueCreator interface\n\nfunc (s stringValue) Create(val string, p *string, c StringConfig) Value {\n\t*p = val\n\treturn &stringValue{\n\t\tdestination: p,\n\t\ttrimSpace:   c.TrimSpace,\n\t}\n}\n\nfunc (s stringValue) ToString(val string) string {\n\tif val == \"\" {\n\t\treturn val\n\t}\n\treturn fmt.Sprintf(\"%q\", val)\n}\n\n// Below functions are to satisfy the flag.Value interface\n\nfunc (s *stringValue) Set(val string) error {\n\tif s.trimSpace {\n\t\tval = strings.TrimSpace(val)\n\t}\n\t*s.destination = val\n\treturn nil\n}\n\nfunc (s *stringValue) Get() any { return *s.destination }\n\nfunc (s *stringValue) String() string {\n\tif s.destination != nil {\n\t\treturn *s.destination\n\t}\n\treturn \"\"\n}\n\nfunc (cmd *Command) String(name string) string {\n\tif v, ok := cmd.Value(name).(string); ok {\n\t\ttracef(\"string available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"string NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn \"\"\n}\n"
        },
        {
          "name": "flag_string_map.go",
          "type": "blob",
          "size": 0.6220703125,
          "content": "package cli\n\ntype (\n\tStringMap     = MapBase[string, StringConfig, stringValue]\n\tStringMapFlag = FlagBase[map[string]string, StringConfig, StringMap]\n)\n\nvar NewStringMap = NewMapBase[string, StringConfig, stringValue]\n\n// StringMap looks up the value of a local StringMapFlag, returns\n// nil if not found\nfunc (cmd *Command) StringMap(name string) map[string]string {\n\tif v, ok := cmd.Value(name).(map[string]string); ok {\n\t\ttracef(\"string map available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"string map NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n"
        },
        {
          "name": "flag_string_slice.go",
          "type": "blob",
          "size": 0.6171875,
          "content": "package cli\n\ntype (\n\tStringSlice     = SliceBase[string, StringConfig, stringValue]\n\tStringSliceFlag = FlagBase[[]string, StringConfig, StringSlice]\n)\n\nvar NewStringSlice = NewSliceBase[string, StringConfig, stringValue]\n\n// StringSlice looks up the value of a local StringSliceFlag, returns\n// nil if not found\nfunc (cmd *Command) StringSlice(name string) []string {\n\tif v, ok := cmd.Value(name).([]string); ok {\n\t\ttracef(\"string slice available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"string slice NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n"
        },
        {
          "name": "flag_test.go",
          "type": "blob",
          "size": 95.251953125,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar boolFlagTests = []struct {\n\tname     string\n\texpected string\n}{\n\t{\"help\", \"--help\\t(default: false)\"},\n\t{\"h\", \"-h\\t(default: false)\"},\n}\n\nfunc resetEnv(env []string) {\n\tfor _, e := range env {\n\t\tfields := strings.SplitN(e, \"=\", 2)\n\t\tos.Setenv(fields[0], fields[1])\n\t}\n}\n\nfunc TestBoolFlagHelpOutput(t *testing.T) {\n\tfor _, test := range boolFlagTests {\n\t\tfl := &BoolFlag{Name: test.name}\n\t\toutput := fl.String()\n\t\tassert.Equal(t, test.expected, output)\n\t}\n}\n\nfunc TestBoolFlagApply_SetsAllNames(t *testing.T) {\n\tv := false\n\tfl := BoolFlag{Name: \"wat\", Aliases: []string{\"W\", \"huh\"}, Destination: &v}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--wat\", \"-W\", \"--huh\"})\n\tassert.NoError(t, err)\n\tassert.True(t, v)\n}\n\nfunc TestBoolFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Bool(\"trueflag\", true, \"doc\")\n\tset.Bool(\"falseflag\", false, \"doc\")\n\tcmd := &Command{flagSet: set}\n\ttf := &BoolFlag{Name: \"trueflag\"}\n\tff := &BoolFlag{Name: \"falseflag\"}\n\n\tr := require.New(t)\n\tr.True(cmd.Bool(tf.Name))\n\tr.False(cmd.Bool(ff.Name))\n}\n\nfunc TestBoolFlagApply_SetsCount(t *testing.T) {\n\tv := false\n\tcount := 0\n\tfl := BoolFlag{Name: \"wat\", Aliases: []string{\"W\", \"huh\"}, Destination: &v, Config: BoolConfig{Count: &count}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\terr := fl.Apply(set)\n\tassert.NoError(t, err)\n\n\terr = set.Parse([]string{\"--wat\", \"-W\", \"--huh\"})\n\tassert.NoError(t, err)\n\tassert.True(t, v)\n\tassert.Equal(t, 3, count)\n}\n\nfunc TestBoolFlagCountFromCommand(t *testing.T) {\n\tboolCountTests := []struct {\n\t\tinput         []string\n\t\texpectedVal   bool\n\t\texpectedCount int\n\t}{\n\t\t{\n\t\t\tinput:         []string{\"main\", \"-tf\", \"-w\", \"-huh\"},\n\t\t\texpectedVal:   true,\n\t\t\texpectedCount: 3,\n\t\t},\n\t\t{\n\t\t\tinput:         []string{\"main\", \"-huh\"},\n\t\t\texpectedVal:   true,\n\t\t\texpectedCount: 1,\n\t\t},\n\t\t{\n\t\t\tinput:         []string{\"main\"},\n\t\t\texpectedVal:   false,\n\t\t\texpectedCount: 0,\n\t\t},\n\t}\n\n\tfor _, bct := range boolCountTests {\n\t\tbf := &BoolFlag{Name: \"tf\", Aliases: []string{\"w\", \"huh\"}}\n\t\tcmd := &Command{\n\t\t\tFlags: []Flag{\n\t\t\t\tbf,\n\t\t\t},\n\t\t}\n\t\tr := require.New(t)\n\n\t\tr.NoError(cmd.Run(buildTestContext(t), bct.input))\n\n\t\tr.Equal(bct.expectedVal, cmd.Value(bf.Name))\n\t\tr.Equal(bct.expectedCount, cmd.Count(bf.Name))\n\t\tfor _, alias := range bf.Aliases {\n\t\t\tr.Equal(bct.expectedCount, cmd.Count(alias))\n\t\t}\n\t}\n}\n\nfunc TestFlagsFromEnv(t *testing.T) {\n\ttestCases := []struct {\n\t\tname        string\n\t\tinput       string\n\t\toutput      any\n\t\tfl          Flag\n\t\terrContains string\n\t}{\n\t\t{\n\t\t\tname:   \"BoolFlag valid true\",\n\t\t\tinput:  \"1\",\n\t\t\toutput: true,\n\t\t\tfl:     &BoolFlag{Name: \"debug\", Sources: EnvVars(\"DEBUG\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"BoolFlag valid false\",\n\t\t\tinput:  \"false\",\n\t\t\toutput: false,\n\t\t\tfl:     &BoolFlag{Name: \"debug\", Sources: EnvVars(\"DEBUG\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"BoolFlag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: true,\n\t\t\tfl:     &BoolFlag{Name: \"debug\", Sources: EnvVars(\"DEBUG\")},\n\t\t\terrContains: `could not parse \"foobar\" as bool value from environment variable ` +\n\t\t\t\t`\"DEBUG\" for flag debug:`,\n\t\t},\n\n\t\t{\n\t\t\tname:   \"DurationFlag valid\",\n\t\t\tinput:  \"1s\",\n\t\t\toutput: 1 * time.Second,\n\t\t\tfl:     &DurationFlag{Name: \"time\", Sources: EnvVars(\"TIME\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"DurationFlag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: false,\n\t\t\tfl:     &DurationFlag{Name: \"time\", Sources: EnvVars(\"TIME\")},\n\t\t\terrContains: `could not parse \"foobar\" as time.Duration value from environment ` +\n\t\t\t\t`variable \"TIME\" for flag time:`,\n\t\t},\n\n\t\t{\n\t\t\tname:   \"Float64Flag valid\",\n\t\t\tinput:  \"1.2\",\n\t\t\toutput: 1.2,\n\t\t\tfl:     &FloatFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"Float64Flag valid from int\",\n\t\t\tinput:  \"1\",\n\t\t\toutput: 1.0,\n\t\t\tfl:     &FloatFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"Float64Flag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: 0,\n\t\t\tfl:     &FloatFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"foobar\" as float64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\n\t\t{\n\t\t\tname:   \"IntFlag valid\",\n\t\t\tinput:  \"1\",\n\t\t\toutput: int64(1),\n\t\t\tfl:     &IntFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"IntFlag invalid from float\",\n\t\t\tinput:  \"1.2\",\n\t\t\toutput: 0,\n\t\t\tfl:     &IntFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"1.2\" as int64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\t\t{\n\t\t\tname:   \"IntFlag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: 0,\n\t\t\tfl:     &IntFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"foobar\" as int64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\t\t{\n\t\t\tname:   \"IntFlag valid from hex\",\n\t\t\tinput:  \"deadBEEF\",\n\t\t\toutput: int64(3735928559),\n\t\t\tfl:     &IntFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\"), Config: IntegerConfig{Base: 16}},\n\t\t},\n\t\t{\n\t\t\tname:   \"IntFlag invalid from octal\",\n\t\t\tinput:  \"08\",\n\t\t\toutput: 0,\n\t\t\tfl:     &IntFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\"), Config: IntegerConfig{Base: 0}},\n\t\t\terrContains: `could not parse \"08\" as int64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\n\t\t{\n\t\t\tname:   \"Float64SliceFlag valid\",\n\t\t\tinput:  \"1.0,2\",\n\t\t\toutput: []float64{1, 2},\n\t\t\tfl:     &FloatSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"Float64SliceFlag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: []float64{},\n\t\t\tfl:     &FloatSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"foobar\" as []float64 value from environment ` +\n\t\t\t\t`variable \"SECONDS\" for flag seconds:`,\n\t\t},\n\t\t{\n\t\t\tname:   \"Generic\",\n\t\t\tinput:  \"foo,bar\",\n\t\t\toutput: &Parser{\"foo\", \"bar\"},\n\t\t\tfl:     &GenericFlag{Name: \"names\", Value: &Parser{}, Sources: EnvVars(\"NAMES\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"IntSliceFlag valid\",\n\t\t\tinput:  \"1,2\",\n\t\t\toutput: []int64{1, 2},\n\t\t\tfl:     &IntSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"IntSliceFlag invalid from float\",\n\t\t\tinput:  \"1.2,2\",\n\t\t\toutput: []int64{},\n\t\t\tfl:     &IntSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"1.2,2\" as []int64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\t\t{\n\t\t\tname:   \"IntSliceFlag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: []int64{},\n\t\t\tfl:     &IntSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"foobar\" as []int64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\n\t\t{\n\t\t\tname:   \"UintSliceFlag valid\",\n\t\t\tinput:  \"1,2\",\n\t\t\toutput: []uint64{1, 2},\n\t\t\tfl:     &UintSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"UintSliceFlag invalid with float\",\n\t\t\tinput:  \"1.2,2\",\n\t\t\toutput: []uint64{},\n\t\t\tfl:     &UintSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"1.2,2\" as []uint64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\t\t{\n\t\t\tname:   \"UintSliceFlag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: []uint64{},\n\t\t\tfl:     &UintSliceFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"foobar\" as []uint64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\n\t\t{\n\t\t\tname:   \"StringFlag valid\",\n\t\t\tinput:  \"foo\",\n\t\t\toutput: \"foo\",\n\t\t\tfl:     &StringFlag{Name: \"name\", Sources: EnvVars(\"NAME\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"StringFlag valid with TrimSpace\",\n\t\t\tinput:  \" foo\",\n\t\t\toutput: \"foo\",\n\t\t\tfl:     &StringFlag{Name: \"names\", Sources: EnvVars(\"NAMES\"), Config: StringConfig{TrimSpace: true}},\n\t\t},\n\n\t\t{\n\t\t\tname:   \"StringSliceFlag valid\",\n\t\t\tinput:  \"foo,bar\",\n\t\t\toutput: []string{\"foo\", \"bar\"},\n\t\t\tfl:     &StringSliceFlag{Name: \"names\", Sources: EnvVars(\"NAMES\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"StringSliceFlag valid with TrimSpace\",\n\t\t\tinput:  \"foo , bar \",\n\t\t\toutput: []string{\"foo\", \"bar\"},\n\t\t\tfl:     &StringSliceFlag{Name: \"names\", Sources: EnvVars(\"NAMES\"), Config: StringConfig{TrimSpace: true}},\n\t\t},\n\n\t\t{\n\t\t\tname:   \"StringMapFlag valid\",\n\t\t\tinput:  \"foo=bar,empty=\",\n\t\t\toutput: map[string]string{\"foo\": \"bar\", \"empty\": \"\"},\n\t\t\tfl:     &StringMapFlag{Name: \"names\", Sources: EnvVars(\"NAMES\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"StringMapFlag valid with TrimSpace\",\n\t\t\tinput:  \"foo= bar \",\n\t\t\toutput: map[string]string{\"foo\": \"bar\"},\n\t\t\tfl:     &StringMapFlag{Name: \"names\", Sources: EnvVars(\"NAMES\"), Config: StringConfig{TrimSpace: true}},\n\t\t},\n\n\t\t{\n\t\t\tname:   \"UintFlag valid\",\n\t\t\tinput:  \"1\",\n\t\t\toutput: uint64(1),\n\t\t\tfl:     &UintFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t},\n\t\t{\n\t\t\tname:   \"UintFlag valid leading zero\",\n\t\t\tinput:  \"08\",\n\t\t\toutput: uint64(8),\n\t\t\tfl:     &UintFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\"), Config: IntegerConfig{Base: 10}},\n\t\t},\n\t\t{\n\t\t\tname:   \"UintFlag valid from octal\",\n\t\t\tinput:  \"755\",\n\t\t\toutput: uint64(493),\n\t\t\tfl:     &UintFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\"), Config: IntegerConfig{Base: 8}},\n\t\t},\n\t\t{\n\t\t\tname:   \"UintFlag valid from hex\",\n\t\t\tinput:  \"deadBEEF\",\n\t\t\toutput: uint64(3735928559),\n\t\t\tfl:     &UintFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\"), Config: IntegerConfig{Base: 16}},\n\t\t},\n\t\t{\n\t\t\tname:   \"UintFlag invalid octal\",\n\t\t\tinput:  \"08\",\n\t\t\toutput: 0,\n\t\t\tfl:     &UintFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\"), Config: IntegerConfig{Base: 0}},\n\t\t\terrContains: `could not parse \"08\" as uint64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\t\t{\n\t\t\tname:   \"UintFlag invalid float\",\n\t\t\tinput:  \"1.2\",\n\t\t\toutput: 0,\n\t\t\tfl:     &UintFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"1.2\" as uint64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\t\t{\n\t\t\tname:   \"UintFlag invalid\",\n\t\t\tinput:  \"foobar\",\n\t\t\toutput: 0,\n\t\t\tfl:     &UintFlag{Name: \"seconds\", Sources: EnvVars(\"SECONDS\")},\n\t\t\terrContains: `could not parse \"foobar\" as uint64 value from environment variable ` +\n\t\t\t\t`\"SECONDS\" for flag seconds:`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := require.New(t)\n\n\t\t\tr.Implements((*DocGenerationFlag)(nil), tc.fl)\n\t\t\tf := tc.fl.(DocGenerationFlag)\n\n\t\t\tenvVarSlice := f.GetEnvVars()\n\t\t\tt.Setenv(envVarSlice[0], tc.input)\n\n\t\t\tcmd := &Command{\n\t\t\t\tFlags: []Flag{tc.fl},\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tr.Equal(tc.output, cmd.Value(tc.fl.Names()[0]))\n\t\t\t\t\tr.True(tc.fl.IsSet())\n\t\t\t\t\tr.Equal(tc.fl.Names(), cmd.FlagNames())\n\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), []string{\"run\"})\n\n\t\t\tif tc.errContains != \"\" {\n\t\t\t\tr.NotNil(err)\n\t\t\t\tr.ErrorContains(err, tc.errContains)\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tr.NoError(err)\n\t\t})\n\t}\n}\n\ntype nodocFlag struct {\n\tFlag\n\n\tName string\n}\n\nfunc TestFlagStringifying(t *testing.T) {\n\tfor _, tc := range []struct {\n\t\tname     string\n\t\tfl       Flag\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"bool-flag\",\n\t\t\tfl:       &BoolFlag{Name: \"vividly\"},\n\t\t\texpected: \"--vividly\\t(default: false)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"bool-flag-with-default-text\",\n\t\t\tfl:       &BoolFlag{Name: \"wildly\", DefaultText: \"scrambled\"},\n\t\t\texpected: \"--wildly\\t(default: scrambled)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"duration-flag\",\n\t\t\tfl:       &DurationFlag{Name: \"scream-for\"},\n\t\t\texpected: \"--scream-for value\\t(default: 0s)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"duration-flag-with-default-text\",\n\t\t\tfl:       &DurationFlag{Name: \"feels-about\", DefaultText: \"whimsically\"},\n\t\t\texpected: \"--feels-about value\\t(default: whimsically)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float64-flag\",\n\t\t\tfl:       &FloatFlag{Name: \"arduous\"},\n\t\t\texpected: \"--arduous value\\t(default: 0)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float64-flag-with-default-text\",\n\t\t\tfl:       &FloatFlag{Name: \"filibuster\", DefaultText: \"42\"},\n\t\t\texpected: \"--filibuster value\\t(default: 42)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float64-slice-flag\",\n\t\t\tfl:       &FloatSliceFlag{Name: \"pizzas\"},\n\t\t\texpected: \"--pizzas value [ --pizzas value ]\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"float64-slice-flag-with-default-text\",\n\t\t\tfl:       &FloatSliceFlag{Name: \"pepperonis\", DefaultText: \"shaved\"},\n\t\t\texpected: \"--pepperonis value [ --pepperonis value ]\\t(default: shaved)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"generic-flag\",\n\t\t\tfl:       &GenericFlag{Name: \"yogurt\"},\n\t\t\texpected: \"--yogurt value\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"generic-flag-with-default-text\",\n\t\t\tfl:       &GenericFlag{Name: \"ricotta\", DefaultText: \"plops\"},\n\t\t\texpected: \"--ricotta value\\t(default: plops)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"int-flag\",\n\t\t\tfl:       &IntFlag{Name: \"grubs\"},\n\t\t\texpected: \"--grubs value\\t(default: 0)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"int-flag-with-default-text\",\n\t\t\tfl:       &IntFlag{Name: \"poisons\", DefaultText: \"11ty\"},\n\t\t\texpected: \"--poisons value\\t(default: 11ty)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"int-slice-flag\",\n\t\t\tfl:       &IntSliceFlag{Name: \"pencils\"},\n\t\t\texpected: \"--pencils value [ --pencils value ]\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"int-slice-flag-with-default-text\",\n\t\t\tfl:       &IntFlag{Name: \"pens\", DefaultText: \"-19\"},\n\t\t\texpected: \"--pens value\\t(default: -19)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint-slice-flag\",\n\t\t\tfl:       &UintSliceFlag{Name: \"pencils\"},\n\t\t\texpected: \"--pencils value [ --pencils value ]\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint-slice-flag-with-default-text\",\n\t\t\tfl:       &UintFlag{Name: \"pens\", DefaultText: \"29\"},\n\t\t\texpected: \"--pens value\\t(default: 29)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"int64-flag\",\n\t\t\tfl:       &IntFlag{Name: \"flume\"},\n\t\t\texpected: \"--flume value\\t(default: 0)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"int64-flag-with-default-text\",\n\t\t\tfl:       &IntFlag{Name: \"shattering\", DefaultText: \"22\"},\n\t\t\texpected: \"--shattering value\\t(default: 22)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64-slice-flag\",\n\t\t\tfl:       &UintSliceFlag{Name: \"drawers\"},\n\t\t\texpected: \"--drawers value [ --drawers value ]\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64-slice-flag-with-default-text\",\n\t\t\tfl:       &UintSliceFlag{Name: \"handles\", DefaultText: \"-2\"},\n\t\t\texpected: \"--handles value [ --handles value ]\\t(default: -2)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string-flag\",\n\t\t\tfl:       &StringFlag{Name: \"arf-sound\"},\n\t\t\texpected: \"--arf-sound value\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string-flag-with-default-text\",\n\t\t\tfl:       &StringFlag{Name: \"woof-sound\", DefaultText: \"urp\"},\n\t\t\texpected: \"--woof-sound value\\t(default: urp)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string-slice-flag\",\n\t\t\tfl:       &StringSliceFlag{Name: \"meow-sounds\"},\n\t\t\texpected: \"--meow-sounds value [ --meow-sounds value ]\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"string-slice-flag-with-default-text\",\n\t\t\tfl:       &StringSliceFlag{Name: \"moo-sounds\", DefaultText: \"awoo\"},\n\t\t\texpected: \"--moo-sounds value [ --moo-sounds value ]\\t(default: awoo)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"timestamp-flag\",\n\t\t\tfl:       &TimestampFlag{Name: \"eating\"},\n\t\t\texpected: \"--eating value\\t\",\n\t\t},\n\t\t{\n\t\t\tname:     \"timestamp-flag-with-default-text\",\n\t\t\tfl:       &TimestampFlag{Name: \"sleeping\", DefaultText: \"earlier\"},\n\t\t\texpected: \"--sleeping value\\t(default: earlier)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint-flag\",\n\t\t\tfl:       &UintFlag{Name: \"jars\"},\n\t\t\texpected: \"--jars value\\t(default: 0)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint-flag-with-default-text\",\n\t\t\tfl:       &UintFlag{Name: \"bottles\", DefaultText: \"99\"},\n\t\t\texpected: \"--bottles value\\t(default: 99)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64-flag\",\n\t\t\tfl:       &UintFlag{Name: \"cans\"},\n\t\t\texpected: \"--cans value\\t(default: 0)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uint64-flag-with-default-text\",\n\t\t\tfl:       &UintFlag{Name: \"tubes\", DefaultText: \"13\"},\n\t\t\texpected: \"--tubes value\\t(default: 13)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"nodoc-flag\",\n\t\t\tfl:       &nodocFlag{Name: \"scarecrow\"},\n\t\t\texpected: \"\",\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(ct *testing.T) {\n\t\t\ts := stringifyFlag(tc.fl)\n\t\t\tassert.Equal(t, tc.expected, s, \"stringified flag %q does not match expected\", s)\n\t\t})\n\t}\n}\n\nvar stringFlagTests = []struct {\n\tname     string\n\taliases  []string\n\tusage    string\n\tvalue    string\n\texpected string\n}{\n\t{\"foo\", nil, \"\", \"\", \"--foo value\\t\"},\n\t{\"f\", nil, \"\", \"\", \"-f value\\t\"},\n\t{\"f\", nil, \"The total `foo` desired\", \"all\", \"-f foo\\tThe total foo desired (default: \\\"all\\\")\"},\n\t{\"test\", nil, \"\", \"Something\", \"--test value\\t(default: \\\"Something\\\")\"},\n\t{\"config\", []string{\"c\"}, \"Load configuration from `FILE`\", \"\", \"--config FILE, -c FILE\\tLoad configuration from FILE\"},\n\t{\"config\", []string{\"c\"}, \"Load configuration from `CONFIG`\", \"config.json\", \"--config CONFIG, -c CONFIG\\tLoad configuration from CONFIG (default: \\\"config.json\\\")\"},\n}\n\nfunc TestStringFlagHelpOutput(t *testing.T) {\n\tfor _, test := range stringFlagTests {\n\t\tfl := &StringFlag{Name: test.name, Aliases: test.aliases, Usage: test.usage, Value: test.value}\n\t\t// create a tmp flagset\n\t\ttfs := flag.NewFlagSet(\"test\", 0)\n\t\tassert.NoError(t, fl.Apply(tfs))\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestStringFlagDefaultText(t *testing.T) {\n\tfl := &StringFlag{Name: \"foo\", Aliases: nil, Usage: \"amount of `foo` requested\", Value: \"none\", DefaultText: \"all of it\"}\n\texpected := \"--foo foo\\tamount of foo requested (default: all of it)\"\n\tassert.Equal(t, expected, fl.String())\n}\n\nfunc TestStringFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_FOO\", \"derp\")\n\n\tfor _, test := range stringFlagTests {\n\t\tfl := &StringFlag{Name: test.name, Aliases: test.aliases, Value: test.value, Sources: EnvVars(\"APP_FOO\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_FOO\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%s does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nvar _ = []struct {\n\tname     string\n\taliases  []string\n\tusage    string\n\tvalue    string\n\tprefixer FlagNamePrefixFunc\n\texpected string\n}{\n\t{name: \"foo\", usage: \"\", value: \"\", prefixer: func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"name: %s, ph: %s\", a, b)\n\t}, expected: \"name: foo, ph: value\\t\"},\n\t{name: \"f\", usage: \"\", value: \"\", prefixer: func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"name: %s, ph: %s\", a, b)\n\t}, expected: \"name: f, ph: value\\t\"},\n\t{name: \"f\", usage: \"The total `foo` desired\", value: \"all\", prefixer: func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"name: %s, ph: %s\", a, b)\n\t}, expected: \"name: f, ph: foo\\tThe total foo desired (default: \\\"all\\\")\"},\n\t{name: \"test\", usage: \"\", value: \"Something\", prefixer: func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"name: %s, ph: %s\", a, b)\n\t}, expected: \"name: test, ph: value\\t(default: \\\"Something\\\")\"},\n\t{name: \"config\", aliases: []string{\"c\"}, usage: \"Load configuration from `FILE`\", value: \"\", prefixer: func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"name: %s, ph: %s\", a, b)\n\t}, expected: \"name: config,c, ph: FILE\\tLoad configuration from FILE\"},\n\t{name: \"config\", aliases: []string{\"c\"}, usage: \"Load configuration from `CONFIG`\", value: \"config.json\", prefixer: func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"name: %s, ph: %s\", a, b)\n\t}, expected: \"name: config,c, ph: CONFIG\\tLoad configuration from CONFIG (default: \\\"config.json\\\")\"},\n}\n\nfunc TestStringFlagApply_SetsAllNames(t *testing.T) {\n\tv := \"mmm\"\n\tfl := StringFlag{Name: \"hay\", Aliases: []string{\"H\", \"hayyy\"}, Destination: &v}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--hay\", \"u\", \"-H\", \"yuu\", \"--hayyy\", \"YUUUU\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"YUUUU\", v)\n}\n\nfunc TestStringFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.String(\"myflag\", \"foobar\", \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &StringFlag{Name: \"myflag\"}\n\trequire.Equal(t, \"foobar\", cmd.String(f.Name))\n}\n\nvar _ = []struct {\n\tname     string\n\tenv      string\n\thinter   FlagEnvHintFunc\n\texpected string\n}{\n\t{\"foo\", \"\", func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"env: %s, str: %s\", a, b)\n\t}, \"env: , str: --foo value\\t\"},\n\t{\"f\", \"\", func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"env: %s, str: %s\", a, b)\n\t}, \"env: , str: -f value\\t\"},\n\t{\"foo\", \"ENV_VAR\", func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"env: %s, str: %s\", a, b)\n\t}, \"env: ENV_VAR, str: --foo value\\t\"},\n\t{\"f\", \"ENV_VAR\", func(a []string, b string) string {\n\t\treturn fmt.Sprintf(\"env: %s, str: %s\", a, b)\n\t}, \"env: ENV_VAR, str: -f value\\t\"},\n}\n\n//func TestFlagEnvHinter(t *testing.T) {\n//\tdefer func() {\n//\t\tFlagEnvHinter = withEnvHint\n//\t}()\n//\n//\tfor _, test := range envHintFlagTests {\n//\t\tFlagEnvHinter = test.hinter\n//\t\tfl := StringFlag{Name: test.name, Sources: ValueSources{test.env}}\n//\t\toutput := fl.String()\n//\t\tif output != test.expected {\n//\t\t\tt.Errorf(\"%q does not match %q\", output, test.expected)\n//\t\t}\n//\t}\n//}\n\nvar stringSliceFlagTests = []struct {\n\tname     string\n\taliases  []string\n\tvalue    []string\n\texpected string\n}{\n\t{\"foo\", nil, []string{}, \"--foo value [ --foo value ]\\t\"},\n\t{\"f\", nil, []string{}, \"-f value [ -f value ]\\t\"},\n\t{\"f\", nil, []string{\"Lipstick\"}, \"-f value [ -f value ]\\t(default: \\\"Lipstick\\\")\"},\n\t{\"test\", nil, []string{\"Something\"}, \"--test value [ --test value ]\\t(default: \\\"Something\\\")\"},\n\t{\"dee\", []string{\"d\"}, []string{\"Inka\", \"Dinka\", \"dooo\"}, \"--dee value, -d value [ --dee value, -d value ]\\t(default: \\\"Inka\\\", \\\"Dinka\\\", \\\"dooo\\\")\"},\n}\n\nfunc TestStringSliceFlagHelpOutput(t *testing.T) {\n\tfor _, test := range stringSliceFlagTests {\n\t\tf := &StringSliceFlag{Name: test.name, Aliases: test.aliases, Value: test.value}\n\t\tassert.Equal(t, test.expected, f.String())\n\t}\n}\n\nfunc TestStringSliceFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_QWWX\", \"11,4\")\n\n\tfor _, test := range stringSliceFlagTests {\n\t\tfl := &StringSliceFlag{Name: test.name, Aliases: test.aliases, Value: test.value, Sources: EnvVars(\"APP_QWWX\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_QWWX\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%q does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestStringSliceFlagApply_SetsAllNames(t *testing.T) {\n\tfl := StringSliceFlag{Name: \"goat\", Aliases: []string{\"G\", \"gooots\"}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--goat\", \"aaa\", \"-G\", \"bbb\", \"--gooots\", \"eeeee\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestStringSliceFlagApply_UsesEnvValues_noDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"vincent van goat,scape goat\")\n\tfl := StringSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\")}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"vincent van goat\", \"scape goat\"}, set.Lookup(\"goat\").Value.(flag.Getter).Get())\n}\n\nfunc TestStringSliceFlagApply_UsesEnvValues_withDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"vincent van goat,scape goat\")\n\tval := []string{`some default`, `values here`}\n\tfl := StringSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\"), Value: val}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []string{\"vincent van goat\", \"scape goat\"}, set.Lookup(\"goat\").Value.(flag.Getter).Get())\n}\n\nfunc TestStringSliceFlagApply_DefaultValueWithDestination(t *testing.T) {\n\tdefValue := []string{\"UA\", \"US\"}\n\tdest := []string{\"CA\"}\n\n\tfl := StringSliceFlag{Name: \"country\", Value: defValue, Destination: &dest}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, defValue, dest)\n}\n\nfunc TestStringSliceFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Var(NewStringSlice(\"a\", \"b\", \"c\"), \"myflag\", \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &StringSliceFlag{Name: \"myflag\"}\n\trequire.Equal(t, []string{\"a\", \"b\", \"c\"}, cmd.StringSlice(f.Name))\n}\n\nvar intFlagTests = []struct {\n\tname     string\n\texpected string\n}{\n\t{\"hats\", \"--hats value\\t(default: 9)\"},\n\t{\"H\", \"-H value\\t(default: 9)\"},\n}\n\nfunc TestIntFlagHelpOutput(t *testing.T) {\n\tfor _, test := range intFlagTests {\n\t\tfl := &IntFlag{Name: test.name, Value: 9}\n\n\t\t// create a temporary flag set to apply\n\t\ttfs := flag.NewFlagSet(\"test\", 0)\n\t\trequire.NoError(t, fl.Apply(tfs))\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestIntFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_BAR\", \"2\")\n\n\tfor _, test := range intFlagTests {\n\t\tfl := &IntFlag{Name: test.name, Sources: EnvVars(\"APP_BAR\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_BAR\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%s does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestIntFlagApply_SetsAllNames(t *testing.T) {\n\tv := int64(3)\n\tfl := IntFlag{Name: \"banana\", Aliases: []string{\"B\", \"banannanana\"}, Destination: &v}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\n\tr.NoError(set.Parse([]string{\"--banana\", \"1\", \"-B\", \"2\", \"--banannanana\", \"5\"}))\n\tr.Equal(int64(5), v)\n}\n\nfunc TestIntFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Int64(\"myflag\", int64(42), \"doc\")\n\tcmd := &Command{flagSet: set}\n\tfl := &IntFlag{Name: \"myflag\"}\n\trequire.Equal(t, int64(42), cmd.Int(fl.Name))\n}\n\nvar uintFlagTests = []struct {\n\tname     string\n\texpected string\n}{\n\t{\"nerfs\", \"--nerfs value\\t(default: 41)\"},\n\t{\"N\", \"-N value\\t(default: 41)\"},\n}\n\nfunc TestUintFlagHelpOutput(t *testing.T) {\n\tfor _, test := range uintFlagTests {\n\t\tfl := &UintFlag{Name: test.name, Value: 41}\n\n\t\t// create a temporary flag set to apply\n\t\ttfs := flag.NewFlagSet(\"test\", 0)\n\t\trequire.NoError(t, fl.Apply(tfs))\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestUintFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_BAR\", \"2\")\n\n\tfor _, test := range uintFlagTests {\n\t\tfl := &UintFlag{Name: test.name, Sources: EnvVars(\"APP_BAR\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_BAR\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%s does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestUintFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Uint64(\"myflag\", 42, \"doc\")\n\tcmd := &Command{flagSet: set}\n\tfl := &UintFlag{Name: \"myflag\"}\n\trequire.Equal(t, uint64(42), cmd.Uint(fl.Name))\n}\n\nvar uint64FlagTests = []struct {\n\tname     string\n\texpected string\n}{\n\t{\"gerfs\", \"--gerfs value\\t(default: 8589934582)\"},\n\t{\"G\", \"-G value\\t(default: 8589934582)\"},\n}\n\nfunc TestUint64FlagHelpOutput(t *testing.T) {\n\tfor _, test := range uint64FlagTests {\n\t\tfl := UintFlag{Name: test.name, Value: 8589934582}\n\n\t\t// create a temporary flag set to apply\n\t\ttfs := flag.NewFlagSet(\"test\", 0)\n\t\trequire.NoError(t, fl.Apply(tfs))\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestUint64FlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_BAR\", \"2\")\n\n\tfor _, test := range uint64FlagTests {\n\t\tfl := &UintFlag{Name: test.name, Sources: EnvVars(\"APP_BAR\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_BAR\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%s does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestUint64FlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Uint64(\"myflag\", 42, \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &UintFlag{Name: \"myflag\"}\n\trequire.Equal(t, uint64(42), cmd.Uint(f.Name))\n}\n\nvar durationFlagTests = []struct {\n\tname     string\n\texpected string\n}{\n\t{\"hooting\", \"--hooting value\\t(default: 1s)\"},\n\t{\"H\", \"-H value\\t(default: 1s)\"},\n}\n\nfunc TestDurationFlagHelpOutput(t *testing.T) {\n\tfor _, test := range durationFlagTests {\n\t\tfl := &DurationFlag{Name: test.name, Value: 1 * time.Second}\n\n\t\t// create a temporary flag set to apply\n\t\ttfs := flag.NewFlagSet(\"test\", 0)\n\t\trequire.NoError(t, fl.Apply(tfs))\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestDurationFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_BAR\", \"2h3m6s\")\n\n\tfor _, test := range durationFlagTests {\n\t\tfl := &DurationFlag{Name: test.name, Sources: EnvVars(\"APP_BAR\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_BAR\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%s does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestDurationFlagApply_SetsAllNames(t *testing.T) {\n\tv := time.Second * 20\n\tfl := DurationFlag{Name: \"howmuch\", Aliases: []string{\"H\", \"whyyy\"}, Destination: &v}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--howmuch\", \"30s\", \"-H\", \"5m\", \"--whyyy\", \"30h\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, time.Hour*30, v)\n}\n\nfunc TestDurationFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Duration(\"myflag\", 42*time.Second, \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &DurationFlag{Name: \"myflag\"}\n\trequire.Equal(t, 42*time.Second, cmd.Duration(f.Name))\n}\n\nvar intSliceFlagTests = []struct {\n\tname     string\n\taliases  []string\n\tvalue    []int64\n\texpected string\n}{\n\t{\"heads\", nil, []int64{}, \"--heads value [ --heads value ]\\t\"},\n\t{\"H\", nil, []int64{}, \"-H value [ -H value ]\\t\"},\n\t{\"H\", []string{\"heads\"}, []int64{9, 3}, \"-H value, --heads value [ -H value, --heads value ]\\t(default: 9, 3)\"},\n}\n\nfunc TestIntSliceFlagHelpOutput(t *testing.T) {\n\tfor _, test := range intSliceFlagTests {\n\t\tfl := &IntSliceFlag{Name: test.name, Aliases: test.aliases, Value: test.value}\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestIntSliceFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_SMURF\", \"42,3\")\n\n\tfor _, test := range intSliceFlagTests {\n\t\tfl := &IntSliceFlag{Name: test.name, Aliases: test.aliases, Value: test.value, Sources: EnvVars(\"APP_SMURF\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_SMURF\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%q does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestIntSliceFlagApply_SetsAllNames(t *testing.T) {\n\tfl := IntSliceFlag{Name: \"bits\", Aliases: []string{\"B\", \"bips\"}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--bits\", \"23\", \"-B\", \"3\", \"--bips\", \"99\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestIntSliceFlagApply_UsesEnvValues_noDefault(t *testing.T) {\n\tt.Setenv(\"MY_GOAT\", \"1 , 2\")\n\n\tfl := &IntSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\")}\n\tset := flag.NewFlagSet(\"test\", 0)\n\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\tr.NoError(set.Parse(nil))\n\tr.Equal([]int64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get())\n}\n\nfunc TestIntSliceFlagApply_UsesEnvValues_withDefault(t *testing.T) {\n\tt.Setenv(\"MY_GOAT\", \"1 , 2\")\n\tval := []int64{3, 4}\n\tfl := &IntSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\"), Value: val}\n\tset := flag.NewFlagSet(\"test\", 0)\n\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\tr.NoError(set.Parse(nil))\n\tr.Equal([]int64{3, 4}, val)\n\tr.Equal([]int64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get())\n}\n\nfunc TestIntSliceFlagApply_DefaultValueWithDestination(t *testing.T) {\n\tdefValue := []int64{1, 2}\n\tdest := []int64{3}\n\n\tfl := IntSliceFlag{Name: \"country\", Value: defValue, Destination: &dest}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, defValue, dest)\n}\n\nfunc TestIntSliceFlagApply_ParentContext(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"numbers\", Aliases: []string{\"n\"}, Value: []int64{1, 2, 3}},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"child\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\trequire.Equalf(t, []int64{1, 2, 3}, cmd.IntSlice(\"numbers\"), \"child context unable to view parent flag\")\n\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"child\"})\n}\n\nfunc TestIntSliceFlag_SetFromParentCommand(t *testing.T) {\n\tfl := &IntSliceFlag{Name: \"numbers\", Aliases: []string{\"n\"}, Value: []int64{1, 2, 3, 4}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\tcmd := &Command{\n\t\tparent: &Command{\n\t\t\tflagSet: set,\n\t\t},\n\t\tflagSet: flag.NewFlagSet(\"empty\", 0),\n\t}\n\n\trequire.Equalf(t, []int64{1, 2, 3, 4}, cmd.IntSlice(\"numbers\"), \"child context unable to view parent flag\")\n}\n\nfunc TestIntSliceFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Var(NewIntSlice(1, 2, 3), \"myflag\", \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &IntSliceFlag{Name: \"myflag\"}\n\trequire.Equal(t, []int64{1, 2, 3}, cmd.IntSlice(f.Name))\n}\n\nvar uintSliceFlagTests = []struct {\n\tname     string\n\taliases  []string\n\tvalue    []uint64\n\texpected string\n}{\n\t{\"heads\", nil, []uint64{}, \"--heads value [ --heads value ]\\t\"},\n\t{\"H\", nil, []uint64{}, \"-H value [ -H value ]\\t\"},\n\t{\n\t\t\"heads\",\n\t\t[]string{\"H\"},\n\t\t[]uint64{2, 17179869184},\n\t\t\"--heads value, -H value [ --heads value, -H value ]\\t(default: 2, 17179869184)\",\n\t},\n}\n\nfunc TestUintSliceFlagHelpOutput(t *testing.T) {\n\tfor _, test := range uintSliceFlagTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tfl := &UintSliceFlag{Name: test.name, Aliases: test.aliases, Value: test.value}\n\t\t\trequire.Equal(t, test.expected, fl.String())\n\t\t})\n\t}\n}\n\nfunc TestUintSliceFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_SMURF\", \"42,17179869184\")\n\n\tfor _, test := range uintSliceFlagTests {\n\t\tfl := &UintSliceFlag{Name: test.name, Value: test.value, Sources: EnvVars(\"APP_SMURF\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_SMURF\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%q does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestUintSliceFlagApply_SetsAllNames(t *testing.T) {\n\tfl := &UintSliceFlag{Name: \"bits\", Aliases: []string{\"B\", \"bips\"}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--bits\", \"23\", \"-B\", \"3\", \"--bips\", \"99\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestUintSliceFlagApply_UsesEnvValues_noDefault(t *testing.T) {\n\tt.Setenv(\"MY_GOAT\", \"1 , 2\")\n\n\tfl := &UintSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\")}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\n\tr.NoError(set.Parse(nil))\n\tr.Equal([]uint64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get().([]uint64))\n}\n\nfunc TestUintSliceFlagApply_UsesEnvValues_withDefault(t *testing.T) {\n\tt.Setenv(\"MY_GOAT\", \"1 , 2\")\n\tval := NewUintSlice(3, 4)\n\tfl := &UintSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\"), Value: val.Value()}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\tr.NoError(set.Parse(nil))\n\tr.Equal([]uint64{3, 4}, val.Value())\n\tr.Equal([]uint64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get().([]uint64))\n}\n\nfunc TestUintSliceFlagApply_DefaultValueWithDestination(t *testing.T) {\n\tdefValue := []uint64{1, 2}\n\tvar dest []uint64\n\n\tfl := &UintSliceFlag{Name: \"country\", Value: defValue, Destination: &dest}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, defValue, dest)\n}\n\nfunc TestUintSliceFlagApply_ParentContext(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&UintSliceFlag{Name: \"numbers\", Aliases: []string{\"n\"}, Value: []uint64{1, 2, 3}},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"child\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\trequire.Equalf(\n\t\t\t\t\t\tt, []uint64{1, 2, 3}, cmd.UintSlice(\"numbers\"),\n\t\t\t\t\t\t\"child context unable to view parent flag\",\n\t\t\t\t\t)\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"child\"})\n}\n\nfunc TestUintSliceFlag_SetFromParentCommand(t *testing.T) {\n\tfl := &UintSliceFlag{Name: \"numbers\", Aliases: []string{\"n\"}, Value: []uint64{1, 2, 3, 4}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\n\tcmd := &Command{\n\t\tparent: &Command{\n\t\t\tflagSet: set,\n\t\t},\n\t\tflagSet: flag.NewFlagSet(\"empty\", 0),\n\t}\n\n\tr.Equalf(\n\t\t[]uint64{1, 2, 3, 4},\n\t\tcmd.UintSlice(\"numbers\"),\n\t\t\"child context unable to view parent flag\",\n\t)\n}\n\nfunc TestUintSliceFlag_ReturnNil(t *testing.T) {\n\tfl := &UintSliceFlag{}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\tcmd := &Command{\n\t\tparent: &Command{\n\t\t\tflagSet: set,\n\t\t},\n\t\tflagSet: flag.NewFlagSet(\"empty\", 0),\n\t}\n\tr.Equalf(\n\t\t[]uint64(nil),\n\t\tcmd.UintSlice(\"numbers\"),\n\t\t\"child context unable to view parent flag\",\n\t)\n}\n\nvar uint64SliceFlagTests = []struct {\n\tname     string\n\taliases  []string\n\tvalue    []uint64\n\texpected string\n}{\n\t{\"heads\", nil, []uint64{}, \"--heads value [ --heads value ]\\t\"},\n\t{\"H\", nil, []uint64{}, \"-H value [ -H value ]\\t\"},\n\t{\n\t\t\"heads\",\n\t\t[]string{\"H\"},\n\t\t[]uint64{2, 17179869184},\n\t\t\"--heads value, -H value [ --heads value, -H value ]\\t(default: 2, 17179869184)\",\n\t},\n}\n\nfunc TestUint64SliceFlagHelpOutput(t *testing.T) {\n\tfor _, test := range uint64SliceFlagTests {\n\t\tfl := UintSliceFlag{Name: test.name, Aliases: test.aliases, Value: test.value}\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestUint64SliceFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_SMURF\", \"42,17179869184\")\n\n\tfor _, test := range uint64SliceFlagTests {\n\t\tfl := UintSliceFlag{Name: test.name, Value: test.value, Sources: EnvVars(\"APP_SMURF\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_SMURF\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%q does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestUint64SliceFlagApply_SetsAllNames(t *testing.T) {\n\tfl := UintSliceFlag{Name: \"bits\", Aliases: []string{\"B\", \"bips\"}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--bits\", \"23\", \"-B\", \"3\", \"--bips\", \"99\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestUint64SliceFlagApply_UsesEnvValues_noDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"1 , 2\")\n\tfl := UintSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\")}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []uint64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get().([]uint64))\n}\n\nfunc TestUint64SliceFlagApply_UsesEnvValues_withDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"1 , 2\")\n\tval := []uint64{3, 4}\n\tfl := UintSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\"), Value: val}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []uint64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get().([]uint64))\n}\n\nfunc TestUint64SliceFlagApply_DefaultValueWithDestination(t *testing.T) {\n\tdefValue := []uint64{1, 2}\n\tdest := []uint64{3}\n\n\tfl := UintSliceFlag{Name: \"country\", Value: defValue, Destination: &dest}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, defValue, dest)\n}\n\nfunc TestUint64SliceFlagApply_ParentCommand(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&UintSliceFlag{Name: \"numbers\", Aliases: []string{\"n\"}, Value: []uint64{1, 2, 3}},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"child\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\trequire.Equalf(\n\t\t\t\t\t\tt, []uint64{1, 2, 3}, cmd.UintSlice(\"numbers\"),\n\t\t\t\t\t\t\"child context unable to view parent flag\",\n\t\t\t\t\t)\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"child\"})\n}\n\nfunc TestUint64SliceFlag_SetFromParentCommand(t *testing.T) {\n\tfl := &UintSliceFlag{Name: \"numbers\", Aliases: []string{\"n\"}, Value: []uint64{1, 2, 3, 4}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\tcmd := &Command{\n\t\tparent: &Command{\n\t\t\tflagSet: set,\n\t\t},\n\t\tflagSet: flag.NewFlagSet(\"empty\", 0),\n\t}\n\tr.Equalf(\n\t\t[]uint64{1, 2, 3, 4}, cmd.UintSlice(\"numbers\"),\n\t\t\"child context unable to view parent flag\",\n\t)\n}\n\nfunc TestUint64SliceFlag_ReturnNil(t *testing.T) {\n\tfl := &UintSliceFlag{}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tr := require.New(t)\n\tr.NoError(fl.Apply(set))\n\tcmd := &Command{\n\t\tparent: &Command{\n\t\t\tflagSet: set,\n\t\t},\n\t\tflagSet: flag.NewFlagSet(\"empty\", 0),\n\t}\n\tr.Equalf(\n\t\t[]uint64(nil), cmd.UintSlice(\"numbers\"),\n\t\t\"child context unable to view parent flag\",\n\t)\n}\n\nvar float64FlagTests = []struct {\n\tname     string\n\texpected string\n}{\n\t{\"hooting\", \"--hooting value\\t(default: 0.1)\"},\n\t{\"H\", \"-H value\\t(default: 0.1)\"},\n}\n\nfunc TestFloat64FlagHelpOutput(t *testing.T) {\n\tfor _, test := range float64FlagTests {\n\t\tf := &FloatFlag{Name: test.name, Value: 0.1}\n\t\tassert.Equal(t, test.expected, f.String())\n\t}\n}\n\nfunc TestFloat64FlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_BAZ\", \"99.4\")\n\n\tfor _, test := range float64FlagTests {\n\t\tfl := &FloatFlag{Name: test.name, Sources: EnvVars(\"APP_BAZ\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_BAZ\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%s does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestFloat64FlagApply_SetsAllNames(t *testing.T) {\n\tv := 99.1\n\tfl := FloatFlag{Name: \"noodles\", Aliases: []string{\"N\", \"nurbles\"}, Destination: &v}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--noodles\", \"1.3\", \"-N\", \"11\", \"--nurbles\", \"43.33333\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, float64(43.33333), v)\n}\n\nfunc TestFloat64FlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Float64(\"myflag\", 1.23, \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &FloatFlag{Name: \"myflag\"}\n\trequire.Equal(t, 1.23, cmd.Float(f.Name))\n}\n\nvar float64SliceFlagTests = []struct {\n\tname     string\n\taliases  []string\n\tvalue    []float64\n\texpected string\n}{\n\t{\"heads\", nil, []float64{}, \"--heads value [ --heads value ]\\t\"},\n\t{\"H\", nil, []float64{}, \"-H value [ -H value ]\\t\"},\n\t{\n\t\t\"heads\",\n\t\t[]string{\"H\"},\n\t\t[]float64{0.1234, -10.5},\n\t\t\"--heads value, -H value [ --heads value, -H value ]\\t(default: 0.1234, -10.5)\",\n\t},\n}\n\nfunc TestFloat64SliceFlagHelpOutput(t *testing.T) {\n\tfor _, test := range float64SliceFlagTests {\n\t\tfl := FloatSliceFlag{Name: test.name, Aliases: test.aliases, Value: test.value}\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestFloat64SliceFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_SMURF\", \"0.1234,-10.5\")\n\tfor _, test := range float64SliceFlagTests {\n\t\tfl := FloatSliceFlag{Name: test.name, Value: test.value, Sources: EnvVars(\"APP_SMURF\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_SMURF\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%q does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestFloat64SliceFlagApply_SetsAllNames(t *testing.T) {\n\tfl := FloatSliceFlag{Name: \"bits\", Aliases: []string{\"B\", \"bips\"}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--bits\", \"23\", \"-B\", \"3\", \"--bips\", \"99\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestFloat64SliceFlagApply_UsesEnvValues_noDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"1.0 , 2.0\")\n\n\tfl := FloatSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\")}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []float64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get().([]float64))\n}\n\nfunc TestFloat64SliceFlagApply_UsesEnvValues_withDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"1.0 , 2.0\")\n\tval := []float64{3.0, 4.0}\n\tfl := FloatSliceFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\"), Value: val}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, []float64{1, 2}, set.Lookup(\"goat\").Value.(flag.Getter).Get().([]float64))\n}\n\nfunc TestFloat64SliceFlagApply_DefaultValueWithDestination(t *testing.T) {\n\tdefValue := []float64{1.0, 2.0}\n\tdest := []float64{3}\n\n\tfl := FloatSliceFlag{Name: \"country\", Value: defValue, Destination: &dest}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, defValue, dest)\n}\n\nfunc TestFloat64SliceFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Var(NewFloatSlice(1.23, 4.56), \"myflag\", \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &FloatSliceFlag{Name: \"myflag\"}\n\trequire.Equal(t, []float64{1.23, 4.56}, cmd.FloatSlice(f.Name))\n}\n\nfunc TestFloat64SliceFlagApply_ParentCommand(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatSliceFlag{Name: \"numbers\", Aliases: []string{\"n\"}, Value: []float64{1.0, 2.0, 3.0}},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"child\",\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\trequire.Equalf(t, []float64{1.0, 2.0, 3.0}, cmd.FloatSlice(\"numbers\"), \"child context unable to view parent flag\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"child\"})\n}\n\nvar genericFlagTests = []struct {\n\tname     string\n\tvalue    Value\n\texpected string\n}{\n\t{\"toads\", &Parser{\"abc\", \"def\"}, \"--toads value\\ttest flag (default: abc,def)\"},\n\t{\"t\", &Parser{\"abc\", \"def\"}, \"-t value\\ttest flag (default: abc,def)\"},\n}\n\nfunc TestGenericFlagHelpOutput(t *testing.T) {\n\tfor _, test := range genericFlagTests {\n\t\tfl := &GenericFlag{Name: test.name, Value: test.value, Usage: \"test flag\"}\n\t\t// create a temporary flag set to apply\n\t\ttfs := flag.NewFlagSet(\"test\", 0)\n\t\tassert.NoError(t, fl.Apply(tfs))\n\t\tassert.Equal(t, test.expected, fl.String())\n\t}\n}\n\nfunc TestGenericFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_ZAP\", \"3\")\n\n\tfor _, test := range genericFlagTests {\n\t\tfl := &GenericFlag{Name: test.name, Sources: EnvVars(\"APP_ZAP\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_ZAP\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%s does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestGenericFlagApply_SetsAllNames(t *testing.T) {\n\tfl := GenericFlag{Name: \"orbs\", Aliases: []string{\"O\", \"obrs\"}, Value: &Parser{}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tassert.NoError(t, fl.Apply(set))\n\tassert.NoError(t, set.Parse([]string{\"--orbs\", \"eleventy,3\", \"-O\", \"4,bloop\", \"--obrs\", \"19,s\"}))\n}\n\nfunc TestGenericFlagValueFromCommand(t *testing.T) {\n\tcmd := &Command{\n\t\tName: \"foo\",\n\t\tFlags: []Flag{\n\t\t\t&GenericFlag{Name: \"myflag\", Value: &Parser{}},\n\t\t},\n\t}\n\n\tassert.NoError(t, cmd.Run(buildTestContext(t), []string{\"foo\", \"--myflag\", \"abc,def\"}))\n\tassert.Equal(t, &Parser{\"abc\", \"def\"}, cmd.Generic(\"myflag\"))\n\tassert.Nil(t, cmd.Generic(\"someother\"))\n}\n\nfunc TestParseGenericFromEnv(t *testing.T) {\n\tt.Setenv(\"APP_SERVE\", \"20,30\")\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&GenericFlag{\n\t\t\t\tName:    \"serve\",\n\t\t\t\tAliases: []string{\"s\"},\n\t\t\t\tValue:   &Parser{},\n\t\t\t\tSources: EnvVars(\"APP_SERVE\"),\n\t\t\t},\n\t\t},\n\t\tAction: func(ctx context.Context, cmd *Command) error {\n\t\t\tif !reflect.DeepEqual(cmd.Generic(\"serve\"), &Parser{\"20\", \"30\"}) {\n\t\t\t\tt.Errorf(\"main name not set from env\")\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(cmd.Generic(\"s\"), &Parser{\"20\", \"30\"}) {\n\t\t\t\tt.Errorf(\"short name not set from env\")\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t}\n\tassert.NoError(t, cmd.Run(buildTestContext(t), []string{\"run\"}))\n}\n\nfunc TestParseMultiString(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, \"10\", cmd.String(\"serve\"), \"main name not set\")\n\t\t\tassert.Equal(t, \"10\", cmd.String(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\"})\n}\n\nfunc TestParseDestinationString(t *testing.T) {\n\tvar dest string\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName:        \"dest\",\n\t\t\t\tDestination: &dest,\n\t\t\t},\n\t\t},\n\t\tAction: func(context.Context, *Command) error {\n\t\t\tassert.Equal(t, \"10\", dest, \"expected destination String 10\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"--dest\", \"10\"})\n}\n\nfunc TestParseMultiStringFromEnv(t *testing.T) {\n\tt.Setenv(\"APP_COUNT\", \"20\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"count\", Aliases: []string{\"c\"}, Sources: EnvVars(\"APP_COUNT\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, \"20\", cmd.String(\"count\"), \"main name not set\")\n\t\t\tassert.Equal(t, \"20\", cmd.String(\"c\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiStringFromEnvCascade(t *testing.T) {\n\tt.Setenv(\"APP_COUNT\", \"20\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{Name: \"count\", Aliases: []string{\"c\"}, Sources: EnvVars(\"COMPAT_COUNT\", \"APP_COUNT\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, \"20\", cmd.String(\"count\"), \"main name not set\")\n\t\t\tassert.Equal(t, \"20\", cmd.String(\"c\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiStringSlice(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Value: []string{}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"10\", \"20\"}\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"serve\"), \"main name not set\")\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiStringSliceWithDefaults(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Value: []string{\"9\", \"2\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"10\", \"20\"}\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"serve\"), \"main name not set\")\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiStringSliceWithDestination(t *testing.T) {\n\tdest := []string{}\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Destination: &dest},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"10\", \"20\"}\n\t\t\tassert.Equal(t, expected, dest, \"destination val not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiStringSliceWithDestinationAndEnv(t *testing.T) {\n\tt.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\tdest := []string{}\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Destination: &dest, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"10\", \"20\"}\n\t\t\tassert.Equal(t, expected, dest, \"destination val not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiFloat64SliceWithDestinationAndEnv(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\tdest := []float64{}\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Destination: &dest, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []float64{10, 20}\n\t\t\tassert.Equal(t, expected, dest, \"destination val not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiIntSliceWithDestinationAndEnv(t *testing.T) {\n\tt.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\tdest := []int64{}\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Destination: &dest, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(context.Context, *Command) error {\n\t\t\trequire.Equalf(t, []int64{10, 20}, dest, \"main name not set\")\n\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiStringSliceWithDefaultsUnset(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Value: []string{\"9\", \"2\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"9\", \"2\"}\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"serve\"), \"main name not set\")\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiStringSliceFromEnv(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []string{}, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"20\", \"30\", \"40\"}\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"intervals\"), \"main name not set from env\")\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"i\"), \"short name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiStringSliceFromEnvWithDefaults(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []string{\"1\", \"2\", \"5\"}, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"20\", \"30\", \"40\"}\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"intervals\"), \"main name not set from env\")\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"i\"), \"short name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiStringSliceFromEnvCascade(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []string{}, Sources: EnvVars(\"COMPAT_INTERVALS\", \"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"20\", \"30\", \"40\"}\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"intervals\"), \"main name not set from env\")\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"i\"), \"short name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiStringSliceFromEnvCascadeWithDefaults(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []string{\"1\", \"2\", \"5\"}, Sources: EnvVars(\"COMPAT_INTERVALS\", \"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []string{\"20\", \"30\", \"40\"}\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"intervals\"), \"main name not set from env\")\n\t\t\tassert.Equal(t, expected, cmd.StringSlice(\"i\"), \"short name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiStringSliceFromEnvWithDestination(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\tdest := []string{}\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Destination: &dest, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(context.Context, *Command) error {\n\t\t\tassert.Equal(t, []string{\"20\", \"30\", \"40\"}, dest, \"destination value not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiInt(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, int64(10), cmd.Int(\"serve\"), \"main name not set\")\n\t\t\tassert.Equal(t, int64(10), cmd.Int(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\"})\n}\n\nfunc TestParseDestinationInt(t *testing.T) {\n\tvar dest int64\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{\n\t\t\t\tName:        \"dest\",\n\t\t\t\tDestination: &dest,\n\t\t\t},\n\t\t},\n\t\tAction: func(context.Context, *Command) error {\n\t\t\tassert.Equal(t, int64(10), dest, \"expected destination Int 10\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"--dest\", \"10\"})\n}\n\nfunc TestParseMultiIntFromEnv(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_TIMEOUT_SECONDS\", \"10\")\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"timeout\", Aliases: []string{\"t\"}, Sources: EnvVars(\"APP_TIMEOUT_SECONDS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, int64(10), cmd.Int(\"timeout\"), \"main name not set\")\n\t\t\tassert.Equal(t, int64(10), cmd.Int(\"t\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiIntFromEnvCascade(t *testing.T) {\n\tt.Setenv(\"APP_TIMEOUT_SECONDS\", \"10\")\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"timeout\", Aliases: []string{\"t\"}, Sources: EnvVars(\"COMPAT_TIMEOUT_SECONDS\", \"APP_TIMEOUT_SECONDS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, int64(10), cmd.Int(\"timeout\"), \"main name not set\")\n\t\t\tassert.Equal(t, int64(10), cmd.Int(\"t\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiIntSlice(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Value: []int64{}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tr := require.New(t)\n\n\t\t\tr.Equalf([]int64{10, 20}, cmd.IntSlice(\"serve\"), \"main name not set\")\n\t\t\tr.Equalf([]int64{10, 20}, cmd.IntSlice(\"s\"), \"short name not set\")\n\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiIntSliceWithDefaults(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Value: []int64{9, 2}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tr := require.New(t)\n\n\t\t\tr.Equalf([]int64{10, 20}, cmd.IntSlice(\"serve\"), \"main name not set\")\n\t\t\tr.Equalf([]int64{10, 20}, cmd.IntSlice(\"s\"), \"short name not set\")\n\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10\", \"-s\", \"20\"})\n}\n\nfunc TestParseMultiIntSliceWithDefaultsUnset(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"serve\", Aliases: []string{\"s\"}, Value: []int64{9, 2}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\texpected := []int64{9, 2}\n\t\t\tassert.Equal(t, expected, cmd.IntSlice(\"serve\"), \"main name not set\")\n\t\t\tassert.Equal(t, expected, cmd.IntSlice(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiIntSliceFromEnv(t *testing.T) {\n\tt.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []int64{}, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tr := require.New(t)\n\n\t\t\tr.Equalf([]int64{20, 30, 40}, cmd.IntSlice(\"intervals\"), \"main name not set from env\")\n\t\t\tr.Equalf([]int64{20, 30, 40}, cmd.IntSlice(\"i\"), \"short name not set from env\")\n\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiIntSliceFromEnvWithDefaults(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []int64{1, 2, 5}, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tr := require.New(t)\n\n\t\t\tr.Equalf([]int64{20, 30, 40}, cmd.IntSlice(\"intervals\"), \"main name not set from env\")\n\t\t\tr.Equalf([]int64{20, 30, 40}, cmd.IntSlice(\"i\"), \"short name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiIntSliceFromEnvCascade(t *testing.T) {\n\tt.Setenv(\"APP_INTERVALS\", \"20,30,40\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&IntSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []int64{}, Sources: EnvVars(\"COMPAT_INTERVALS\", \"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tr := require.New(t)\n\n\t\t\tr.Equalf([]int64{20, 30, 40}, cmd.IntSlice(\"intervals\"), \"main name not set from env\")\n\t\t\tr.Equalf([]int64{20, 30, 40}, cmd.IntSlice(\"i\"), \"short name not set from env\")\n\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiFloat64(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, 10.2, cmd.Float(\"serve\"), \"main name not set\")\n\t\t\tassert.Equal(t, 10.2, cmd.Float(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"-s\", \"10.2\"})\n}\n\nfunc TestParseDestinationFloat64(t *testing.T) {\n\tvar dest float64\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatFlag{\n\t\t\t\tName:        \"dest\",\n\t\t\t\tDestination: &dest,\n\t\t\t},\n\t\t},\n\t\tAction: func(context.Context, *Command) error {\n\t\t\tassert.Equal(t, 10.2, dest, \"expected destination Float64 10.2\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"--dest\", \"10.2\"})\n}\n\nfunc TestParseMultiFloat64FromEnv(t *testing.T) {\n\tt.Setenv(\"APP_TIMEOUT_SECONDS\", \"15.5\")\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatFlag{Name: \"timeout\", Aliases: []string{\"t\"}, Sources: EnvVars(\"APP_TIMEOUT_SECONDS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, 15.5, cmd.Float(\"timeout\"), \"main name not set\")\n\t\t\tassert.Equal(t, 15.5, cmd.Float(\"t\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiFloat64FromEnvCascade(t *testing.T) {\n\tt.Setenv(\"APP_TIMEOUT_SECONDS\", \"15.5\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatFlag{Name: \"timeout\", Aliases: []string{\"t\"}, Sources: EnvVars(\"COMPAT_TIMEOUT_SECONDS\", \"APP_TIMEOUT_SECONDS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.Equal(t, 15.5, cmd.Float(\"timeout\"), \"main name not set\")\n\t\t\tassert.Equal(t, 15.5, cmd.Float(\"t\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiFloat64SliceFromEnv(t *testing.T) {\n\tt.Setenv(\"APP_INTERVALS\", \"0.1,-10.5\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []float64{}, Sources: EnvVars(\"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\trequire.Equalf(t, []float64{0.1, -10.5}, cmd.FloatSlice(\"intervals\"), \"main name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiFloat64SliceFromEnvCascade(t *testing.T) {\n\tt.Setenv(\"APP_INTERVALS\", \"0.1234,-10.5\")\n\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&FloatSliceFlag{Name: \"intervals\", Aliases: []string{\"i\"}, Value: []float64{}, Sources: EnvVars(\"COMPAT_INTERVALS\", \"APP_INTERVALS\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\trequire.Equalf(t, []float64{0.1234, -10.5}, cmd.FloatSlice(\"intervals\"), \"main name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiBool(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.True(t, cmd.Bool(\"serve\"), \"main name not set\")\n\t\t\tassert.True(t, cmd.Bool(\"s\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"--serve\"})\n}\n\nfunc TestParseBoolShortOptionHandle(t *testing.T) {\n\t_ = (&Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:                   \"foobar\",\n\t\t\t\tUseShortOptionHandling: true,\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tassert.True(t, cmd.Bool(\"serve\"), \"main name not set\")\n\t\t\t\t\tassert.True(t, cmd.Bool(\"option\"), \"short name not set\")\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"serve\", Aliases: []string{\"s\"}},\n\t\t\t\t\t&BoolFlag{Name: \"option\", Aliases: []string{\"o\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"foobar\", \"-so\"})\n}\n\nfunc TestParseDestinationBool(t *testing.T) {\n\tvar dest bool\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{\n\t\t\t\tName:        \"dest\",\n\t\t\t\tDestination: &dest,\n\t\t\t},\n\t\t},\n\t\tAction: func(context.Context, *Command) error {\n\t\t\tassert.True(t, dest, \"expected destination Bool true\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"--dest\"})\n}\n\nfunc TestParseMultiBoolFromEnv(t *testing.T) {\n\tt.Setenv(\"APP_DEBUG\", \"1\")\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{Name: \"debug\", Aliases: []string{\"d\"}, Sources: EnvVars(\"APP_DEBUG\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.True(t, cmd.Bool(\"debug\"), \"main name not set\")\n\t\t\tassert.True(t, cmd.Bool(\"d\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseMultiBoolFromEnvCascade(t *testing.T) {\n\tt.Setenv(\"APP_DEBUG\", \"1\")\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{Name: \"debug\", Aliases: []string{\"d\"}, Sources: EnvVars(\"COMPAT_DEBUG\", \"APP_DEBUG\")},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.True(t, cmd.Bool(\"debug\"), \"main name not set from env\")\n\t\t\tassert.True(t, cmd.Bool(\"d\"), \"short name not set from env\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\"})\n}\n\nfunc TestParseBoolFromEnv(t *testing.T) {\n\tboolFlagTests := []struct {\n\t\tinput  string\n\t\toutput bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"1\", true},\n\t\t{\"false\", false},\n\t\t{\"true\", true},\n\t}\n\n\tfor _, test := range boolFlagTests {\n\t\tt.Run(fmt.Sprintf(\"%[1]q %[2]v\", test.input, test.output), func(t *testing.T) {\n\t\t\tt.Setenv(\"DEBUG\", test.input)\n\t\t\t_ = (&Command{\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"debug\", Aliases: []string{\"d\"}, Sources: EnvVars(\"DEBUG\")},\n\t\t\t\t},\n\t\t\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\t\t\tassert.Equal(t, test.output, cmd.Bool(\"debug\"))\n\t\t\t\t\tassert.Equal(t, test.output, cmd.Bool(\"d\"))\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t}).Run(buildTestContext(t), []string{\"run\"})\n\t\t})\n\t}\n}\n\nfunc TestParseMultiBoolT(t *testing.T) {\n\t_ = (&Command{\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{Name: \"implode\", Aliases: []string{\"i\"}, Value: true},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.False(t, cmd.Bool(\"implode\"), \"main name not set\")\n\t\t\tassert.False(t, cmd.Bool(\"i\"), \"short name not set\")\n\t\t\treturn nil\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"run\", \"--implode=false\"})\n}\n\ntype Parser [2]string\n\nfunc (p *Parser) Set(value string) error {\n\tparts := strings.Split(value, \",\")\n\tif len(parts) != 2 {\n\t\treturn fmt.Errorf(\"invalid format\")\n\t}\n\n\t(*p)[0] = parts[0]\n\t(*p)[1] = parts[1]\n\n\treturn nil\n}\n\nfunc (p *Parser) String() string {\n\treturn fmt.Sprintf(\"%s,%s\", p[0], p[1])\n}\n\nfunc (p *Parser) Get() interface{} {\n\treturn p\n}\n\nfunc TestStringSlice_Serialized_Set(t *testing.T) {\n\tsl0 := NewStringSlice(\"a\", \"b\")\n\tser0 := sl0.Serialize()\n\n\trequire.GreaterOrEqual(t, len(ser0), len(slPfx), \"serialized shorter than expected\")\n\n\tsl1 := NewStringSlice(\"c\", \"d\")\n\t_ = sl1.Set(ser0)\n\n\trequire.Equal(t, sl0.String(), sl1.String(), \"pre and post serialization do not match\")\n}\n\nfunc TestIntSlice_Serialized_Set(t *testing.T) {\n\tsl0 := NewIntSlice(1, 2)\n\tser0 := sl0.Serialize()\n\n\trequire.GreaterOrEqual(t, len(ser0), len(slPfx), \"serialized shorter than expected\")\n\n\tsl1 := NewIntSlice(3, 4)\n\t_ = sl1.Set(ser0)\n\n\trequire.Equal(t, sl0.String(), sl1.String(), \"pre and post serialization do not match\")\n}\n\nfunc TestUintSlice_Serialized_Set(t *testing.T) {\n\tsl0 := NewUintSlice(1, 2)\n\tser0 := sl0.Serialize()\n\n\trequire.GreaterOrEqual(t, len(ser0), len(slPfx), \"serialized shorter than expected\")\n\n\tsl1 := NewUintSlice(3, 4)\n\t_ = sl1.Set(ser0)\n\n\trequire.Equal(t, sl0.String(), sl1.String(), \"pre and post serialization do not match\")\n}\n\nfunc TestUint64Slice_Serialized_Set(t *testing.T) {\n\tsl0 := NewUintSlice(1, 2)\n\tser0 := sl0.Serialize()\n\n\trequire.GreaterOrEqual(t, len(ser0), len(slPfx), \"serialized shorter than expected\")\n\n\tsl1 := NewUintSlice(3, 4)\n\t_ = sl1.Set(ser0)\n\n\trequire.Equal(t, sl0.String(), sl1.String(), \"pre and post serialization do not match\")\n}\n\nfunc TestStringMap_Serialized_Set(t *testing.T) {\n\tm0 := NewStringMap(map[string]string{\"a\": \"b\"})\n\tser0 := m0.Serialize()\n\n\trequire.GreaterOrEqual(t, len(ser0), len(slPfx), \"serialized shorter than expected\")\n\n\tm1 := NewStringMap(map[string]string{\"c\": \"d\"})\n\t_ = m1.Set(ser0)\n\n\trequire.Equal(t, m0.String(), m1.String(), \"pre and post serialization do not match\")\n}\n\nfunc TestTimestamp_set(t *testing.T) {\n\tts := timestampValue{\n\t\ttimestamp:  nil,\n\t\thasBeenSet: false,\n\t\tlayouts:    []string{\"Jan 2, 2006 at 3:04pm (MST)\"},\n\t}\n\n\ttime1 := \"Feb 3, 2013 at 7:54pm (PST)\"\n\trequire.NoError(t, ts.Set(time1), \"Failed to parse time %s with layouts %v\", time1, ts.layouts)\n\trequire.True(t, ts.hasBeenSet, \"hasBeenSet is not true after setting a time\")\n\n\tts.hasBeenSet = false\n\tts.layouts = []string{time.RFC3339}\n\ttime2 := \"2006-01-02T15:04:05Z\"\n\trequire.NoError(t, ts.Set(time2), \"Failed to parse time %s with layout %v\", time2, ts.layouts)\n\trequire.True(t, ts.hasBeenSet, \"hasBeenSet is not true after setting a time\")\n}\n\nfunc TestTimestampFlagApply_SingleFormat(t *testing.T) {\n\texpectedResult, _ := time.Parse(time.RFC3339, \"2006-01-02T15:04:05Z\")\n\tfl := TimestampFlag{Name: \"time\", Aliases: []string{\"t\"}, Config: TimestampConfig{Layouts: []string{time.RFC3339}}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--time\", \"2006-01-02T15:04:05Z\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, expectedResult, set.Lookup(\"time\").Value.(flag.Getter).Get())\n}\n\nfunc TestTimestampFlagApply_MultipleFormats(t *testing.T) {\n\tnow := time.Now().UTC()\n\n\ttestCases := []struct {\n\t\tcaseName          string\n\t\tlayoutsPrecisions map[string]time.Duration\n\t\texpRes            time.Time\n\t\texpErrValidation  func(err error) (validation error)\n\t}{\n\t\t{\n\t\t\tcaseName: \"all_valid_layouts\",\n\t\t\tlayoutsPrecisions: map[string]time.Duration{\n\t\t\t\ttime.RFC3339:  time.Second,\n\t\t\t\ttime.DateTime: time.Second,\n\t\t\t\ttime.RFC1123:  time.Second,\n\t\t\t},\n\t\t\texpRes: now.Truncate(time.Second),\n\t\t},\n\t\t{\n\t\t\tcaseName: \"one_invalid_layout\",\n\t\t\tlayoutsPrecisions: map[string]time.Duration{\n\t\t\t\ttime.RFC3339:  time.Second,\n\t\t\t\ttime.DateTime: time.Second,\n\t\t\t\t\"foo\":         0,\n\t\t\t},\n\t\t\texpRes: now.Truncate(time.Second),\n\t\t},\n\t\t{\n\t\t\tcaseName: \"multiple_invalid_layouts\",\n\t\t\tlayoutsPrecisions: map[string]time.Duration{\n\t\t\t\ttime.RFC3339:  time.Second,\n\t\t\t\t\"foo\":         0,\n\t\t\t\ttime.DateTime: time.Second,\n\t\t\t\t\"bar\":         0,\n\t\t\t},\n\t\t\texpRes: now.Truncate(time.Second),\n\t\t},\n\t\t{\n\t\t\tcaseName: \"all_invalid_layouts\",\n\t\t\tlayoutsPrecisions: map[string]time.Duration{\n\t\t\t\t\"foo\":                      0,\n\t\t\t\t\"2024-08-07 74:01:82Z-100\": 0,\n\t\t\t\t\"25:70\":                    0,\n\t\t\t\t\"\":                         0,\n\t\t\t},\n\t\t\texpErrValidation: func(err error) error {\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn errors.New(\"got nil err\")\n\t\t\t\t}\n\n\t\t\t\tfound := regexp.MustCompile(`(cannot parse \".+\" as \".*\")|(extra text: \".+\")`).Match([]byte(err.Error()))\n\t\t\t\tif !found {\n\t\t\t\t\treturn fmt.Errorf(\"given error does not satisfy pattern: %w\", err)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcaseName: \"empty_layout\",\n\t\t\tlayoutsPrecisions: map[string]time.Duration{\n\t\t\t\t\"\": 0,\n\t\t\t},\n\t\t\texpErrValidation: func(err error) error {\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn errors.New(\"got nil err\")\n\t\t\t\t}\n\n\t\t\t\tfound := regexp.MustCompile(`extra text: \".+\"`).Match([]byte(err.Error()))\n\t\t\t\tif !found {\n\t\t\t\t\treturn fmt.Errorf(\"given error does not satisfy pattern: %w\", err)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcaseName: \"nil_layouts_slice\",\n\t\t\texpErrValidation: func(err error) error {\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn errors.New(\"got nil err\")\n\t\t\t\t}\n\n\t\t\t\tfound := regexp.MustCompile(`got nil/empty layouts slice`).Match([]byte(err.Error()))\n\t\t\t\tif !found {\n\t\t\t\t\treturn fmt.Errorf(\"given error does not satisfy pattern: %w\", err)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tcaseName:          \"empty_layouts_slice\",\n\t\t\tlayoutsPrecisions: map[string]time.Duration{},\n\t\t\texpErrValidation: func(err error) error {\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn errors.New(\"got nil err\")\n\t\t\t\t}\n\n\t\t\t\tfound := regexp.MustCompile(`got nil/empty layouts slice`).Match([]byte(err.Error()))\n\t\t\t\tif !found {\n\t\t\t\t\treturn fmt.Errorf(\"given error does not satisfy pattern: %w\", err)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t}\n\n\t// TODO: replace with maps.Keys() (go >= ), lo.Keys() if acceptable\n\tgetKeys := func(m map[string]time.Duration) []string {\n\t\tif m == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tkeys := make([]string, 0, len(m))\n\t\tfor k := range m {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\treturn keys\n\t}\n\n\tfor idx := range testCases {\n\t\ttestCase := testCases[idx]\n\t\tt.Run(testCase.caseName, func(t *testing.T) {\n\t\t\t// t.Parallel()\n\t\t\tfl := TimestampFlag{\n\t\t\t\tName: \"time\",\n\t\t\t\tConfig: TimestampConfig{\n\t\t\t\t\tLayouts: getKeys(testCase.layoutsPrecisions),\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tset := flag.NewFlagSet(\"test\", 0)\n\t\t\t_ = fl.Apply(set)\n\n\t\t\tif len(testCase.layoutsPrecisions) == 0 {\n\t\t\t\terr := set.Parse([]string{\"--time\", now.Format(time.RFC3339)})\n\t\t\t\tif testCase.expErrValidation != nil {\n\t\t\t\t\tassert.NoError(t, testCase.expErrValidation(err))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvalidLayouts := make([]string, 0, len(testCase.layoutsPrecisions))\n\t\t\tinvalidLayouts := make([]string, 0, len(testCase.layoutsPrecisions))\n\n\t\t\t// TODO: replace with lo.Filter if acceptable\n\t\t\tfor layout, prec := range testCase.layoutsPrecisions {\n\t\t\t\tv, err := time.Parse(layout, now.Format(layout))\n\t\t\t\tif err != nil || prec == 0 || now.Truncate(prec).UnixNano() != v.Truncate(prec).UnixNano() {\n\t\t\t\t\tinvalidLayouts = append(invalidLayouts, layout)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tvalidLayouts = append(validLayouts, layout)\n\t\t\t}\n\n\t\t\tfor _, layout := range validLayouts {\n\t\t\t\terr := set.Parse([]string{\"--time\", now.Format(layout)})\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tif !testCase.expRes.IsZero() {\n\t\t\t\t\tassert.Equal(t, testCase.expRes, set.Lookup(\"time\").Value.(flag.Getter).Get())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor range invalidLayouts {\n\t\t\t\terr := set.Parse([]string{\"--time\", now.Format(time.RFC3339)})\n\t\t\t\tif testCase.expErrValidation != nil {\n\t\t\t\t\tassert.NoError(t, testCase.expErrValidation(err))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTimestampFlagApply_ShortenedLayouts(t *testing.T) {\n\tnow := time.Now().UTC()\n\n\tshortenedLayoutsPrecisions := map[string]time.Duration{\n\t\ttime.Kitchen:    time.Minute,\n\t\ttime.Stamp:      time.Second,\n\t\ttime.StampMilli: time.Millisecond,\n\t\ttime.StampMicro: time.Microsecond,\n\t\ttime.StampNano:  time.Nanosecond,\n\t\ttime.TimeOnly:   time.Second,\n\t\t\"15:04\":         time.Minute,\n\t}\n\n\t// TODO: replace with maps.Keys() (go >= ), lo.Keys() if acceptable\n\tgetKeys := func(m map[string]time.Duration) []string {\n\t\tif m == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tkeys := make([]string, 0, len(m))\n\t\tfor k := range m {\n\t\t\tkeys = append(keys, k)\n\t\t}\n\t\treturn keys\n\t}\n\n\tfl := TimestampFlag{\n\t\tName: \"time\",\n\t\tConfig: TimestampConfig{\n\t\t\tLayouts: getKeys(shortenedLayoutsPrecisions),\n\t\t},\n\t}\n\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\tfor layout, prec := range shortenedLayoutsPrecisions {\n\t\terr := set.Parse([]string{\"--time\", now.Format(layout)})\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, now.Truncate(prec), set.Lookup(\"time\").Value.(flag.Getter).Get())\n\t}\n}\n\nfunc TestTimestampFlagApplyValue(t *testing.T) {\n\texpectedResult, _ := time.Parse(time.RFC3339, \"2006-01-02T15:04:05Z\")\n\tfl := TimestampFlag{Name: \"time\", Aliases: []string{\"t\"}, Config: TimestampConfig{Layouts: []string{time.RFC3339}}, Value: expectedResult}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, expectedResult, set.Lookup(\"time\").Value.(flag.Getter).Get())\n}\n\nfunc TestTimestampFlagApply_Fail_Parse_Wrong_Layout(t *testing.T) {\n\tfl := TimestampFlag{Name: \"time\", Aliases: []string{\"t\"}, Config: TimestampConfig{Layouts: []string{\"randomlayout\"}}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.SetOutput(io.Discard)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--time\", \"2006-01-02T15:04:05Z\"})\n\tassert.EqualError(t, err, \"invalid value \\\"2006-01-02T15:04:05Z\\\" for flag -time: parsing time \\\"2006-01-02T15:04:05Z\\\" as \\\"randomlayout\\\": cannot parse \\\"2006-01-02T15:04:05Z\\\" as \\\"randomlayout\\\"\")\n}\n\nfunc TestTimestampFlagApply_Fail_Parse_Wrong_Time(t *testing.T) {\n\tfl := TimestampFlag{Name: \"time\", Aliases: []string{\"t\"}, Config: TimestampConfig{Layouts: []string{\"Jan 2, 2006 at 3:04pm (MST)\"}}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.SetOutput(io.Discard)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--time\", \"2006-01-02T15:04:05Z\"})\n\tassert.EqualError(t, err, \"invalid value \\\"2006-01-02T15:04:05Z\\\" for flag -time: parsing time \\\"2006-01-02T15:04:05Z\\\" as \\\"Jan 2, 2006 at 3:04pm (MST)\\\": cannot parse \\\"2006-01-02T15:04:05Z\\\" as \\\"Jan\\\"\")\n}\n\nfunc TestTimestampFlagApply_Timezoned(t *testing.T) {\n\tpdt := time.FixedZone(\"PDT\", -7*60*60)\n\texpectedResult, _ := time.Parse(time.RFC3339, \"2006-01-02T15:04:05Z\")\n\tfl := TimestampFlag{Name: \"time\", Aliases: []string{\"t\"}, Config: TimestampConfig{Layouts: []string{time.ANSIC}, Timezone: pdt}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--time\", \"Mon Jan 2 08:04:05 2006\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, expectedResult.In(pdt), set.Lookup(\"time\").Value.(flag.Getter).Get())\n}\n\nfunc TestTimestampFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tnow := time.Now()\n\tset.Var(newTimestamp(now), \"myflag\", \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &TimestampFlag{Name: \"myflag\"}\n\trequire.Equal(t, now, cmd.Timestamp(f.Name))\n}\n\ntype flagDefaultTestCase struct {\n\tname    string\n\tflag    Flag\n\ttoParse []string\n\texpect  string\n}\n\nfunc TestFlagDefaultValue(t *testing.T) {\n\tcases := []*flagDefaultTestCase{\n\t\t{\n\t\t\tname:    \"stringSlice\",\n\t\t\tflag:    &StringSliceFlag{Name: \"flag\", Value: []string{\"default1\", \"default2\"}},\n\t\t\ttoParse: []string{\"--flag\", \"parsed\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: \"default1\", \"default2\")`,\n\t\t},\n\t\t{\n\t\t\tname:    \"float64Slice\",\n\t\t\tflag:    &FloatSliceFlag{Name: \"flag\", Value: []float64{1.1, 2.2}},\n\t\t\ttoParse: []string{\"--flag\", \"13.3\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: 1.1, 2.2)`,\n\t\t},\n\t\t{\n\t\t\tname:    \"intSlice\",\n\t\t\tflag:    &IntSliceFlag{Name: \"flag\", Value: []int64{1, 2}},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: 1, 2)`,\n\t\t},\n\t\t{\n\t\t\tname:    \"uintSlice\",\n\t\t\tflag:    &UintSliceFlag{Name: \"flag\", Value: []uint64{1, 2}},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: 1, 2)`,\n\t\t},\n\t\t{\n\t\t\tname:    \"string\",\n\t\t\tflag:    &StringFlag{Name: \"flag\", Value: \"default\"},\n\t\t\ttoParse: []string{\"--flag\", \"parsed\"},\n\t\t\texpect:  `--flag value\t(default: \"default\")`,\n\t\t},\n\t\t{\n\t\t\tname:    \"bool\",\n\t\t\tflag:    &BoolFlag{Name: \"flag\", Value: true},\n\t\t\ttoParse: []string{\"--flag\", \"false\"},\n\t\t\texpect:  `--flag\t(default: true)`,\n\t\t},\n\t\t{\n\t\t\tname:    \"uint64\",\n\t\t\tflag:    &UintFlag{Name: \"flag\", Value: 1},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value\t(default: 1)`,\n\t\t},\n\t\t{\n\t\t\tname:    \"stringMap\",\n\t\t\tflag:    &StringMapFlag{Name: \"flag\", Value: map[string]string{\"default1\": \"default2\"}},\n\t\t\ttoParse: []string{\"--flag\", \"parsed=\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: default1=\"default2\")`,\n\t\t},\n\t}\n\tfor _, v := range cases {\n\t\tset := flag.NewFlagSet(\"test\", 0)\n\t\tset.SetOutput(io.Discard)\n\t\t_ = v.flag.Apply(set)\n\t\tassert.NoError(t, set.Parse(v.toParse))\n\t\tassert.Equal(t, v.expect, v.flag.String())\n\t}\n}\n\ntype flagDefaultTestCaseWithEnv struct {\n\tname    string\n\tflag    Flag\n\ttoParse []string\n\texpect  string\n\tenviron map[string]string\n}\n\nfunc TestFlagDefaultValueWithEnv(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\n\tts, err := time.Parse(time.RFC3339, \"2005-01-02T15:04:05Z\")\n\trequire.NoError(t, err)\n\tcases := []*flagDefaultTestCaseWithEnv{\n\t\t{\n\t\t\tname:    \"stringSlice\",\n\t\t\tflag:    &StringSliceFlag{Name: \"flag\", Value: []string{\"default1\", \"default2\"}, Sources: EnvVars(\"ssflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"parsed\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: \"default1\", \"default2\")` + withEnvHint([]string{\"ssflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"ssflag\": \"some-other-env_value\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"float64Slice\",\n\t\t\tflag:    &FloatSliceFlag{Name: \"flag\", Value: []float64{1.1, 2.2}, Sources: EnvVars(\"fsflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"13.3\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: 1.1, 2.2)` + withEnvHint([]string{\"fsflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"fsflag\": \"20304.222\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"intSlice\",\n\t\t\tflag:    &IntSliceFlag{Name: \"flag\", Value: []int64{1, 2}, Sources: EnvVars(\"isflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: 1, 2)` + withEnvHint([]string{\"isflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"isflag\": \"101\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"uintSlice\",\n\t\t\tflag:    &UintSliceFlag{Name: \"flag\", Value: []uint64{1, 2}, Sources: EnvVars(\"uisflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: 1, 2)` + withEnvHint([]string{\"uisflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uisflag\": \"3\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"string\",\n\t\t\tflag:    &StringFlag{Name: \"flag\", Value: \"default\", Sources: EnvVars(\"uflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"parsed\"},\n\t\t\texpect:  `--flag value\t(default: \"default\")` + withEnvHint([]string{\"uflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uflag\": \"some-other-string\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"bool\",\n\t\t\tflag:    &BoolFlag{Name: \"flag\", Value: true, Sources: EnvVars(\"uflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"false\"},\n\t\t\texpect:  `--flag\t(default: true)` + withEnvHint([]string{\"uflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uflag\": \"false\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"uint64\",\n\t\t\tflag:    &UintFlag{Name: \"flag\", Value: 1, Sources: EnvVars(\"uflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value\t(default: 1)` + withEnvHint([]string{\"uflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uflag\": \"10\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"uint\",\n\t\t\tflag:    &UintFlag{Name: \"flag\", Value: 1, Sources: EnvVars(\"uflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value\t(default: 1)` + withEnvHint([]string{\"uflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uflag\": \"10\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"int64\",\n\t\t\tflag:    &IntFlag{Name: \"flag\", Value: 1, Sources: EnvVars(\"uflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value\t(default: 1)` + withEnvHint([]string{\"uflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uflag\": \"10\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"int\",\n\t\t\tflag:    &IntFlag{Name: \"flag\", Value: 1, Sources: EnvVars(\"uflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"13\"},\n\t\t\texpect:  `--flag value\t(default: 1)` + withEnvHint([]string{\"uflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uflag\": \"10\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"duration\",\n\t\t\tflag:    &DurationFlag{Name: \"flag\", Value: time.Second, Sources: EnvVars(\"uflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"2m\"},\n\t\t\texpect:  `--flag value\t(default: 1s)` + withEnvHint([]string{\"uflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"uflag\": \"2h4m10s\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"timestamp\",\n\t\t\tflag:    &TimestampFlag{Name: \"flag\", Value: ts, Config: TimestampConfig{Layouts: []string{time.RFC3339}}, Sources: EnvVars(\"tflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"2006-11-02T15:04:05Z\"},\n\t\t\texpect:  `--flag value\t(default: 2005-01-02 15:04:05 +0000 UTC)` + withEnvHint([]string{\"tflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"tflag\": \"2010-01-02T15:04:05Z\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"stringMap\",\n\t\t\tflag:    &StringMapFlag{Name: \"flag\", Value: map[string]string{\"default1\": \"default2\"}, Sources: EnvVars(\"ssflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"parsed=\"},\n\t\t\texpect:  `--flag value [ --flag value ]\t(default: default1=\"default2\")` + withEnvHint([]string{\"ssflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"ssflag\": \"some-other-env_value=\",\n\t\t\t},\n\t\t},\n\t\t// TODO\n\t\t/*{\n\t\t\tname:    \"generic\",\n\t\t\tflag:    &GenericFlag{Name: \"flag\", Value: &Parser{\"11\", \"12\"}, Sources: EnvVars(\"gflag\")},\n\t\t\ttoParse: []string{\"--flag\", \"15,16\"},\n\t\t\texpect:  `--flag value\t(default: 11,12)` + withEnvHint([]string{\"gflag\"}, \"\"),\n\t\t\tenviron: map[string]string{\n\t\t\t\t\"gflag\": \"13,14\",\n\t\t\t},\n\t\t},*/\n\t}\n\tfor _, v := range cases {\n\t\tfor key, val := range v.environ {\n\t\t\tos.Setenv(key, val)\n\t\t}\n\t\tset := flag.NewFlagSet(\"test\", 0)\n\t\tset.SetOutput(io.Discard)\n\t\trequire.NoError(t, v.flag.Apply(set))\n\t\trequire.NoError(t, set.Parse(v.toParse))\n\t\tassert.Equal(t, v.expect, v.flag.String())\n\t}\n}\n\ntype flagValueTestCase struct {\n\tname    string\n\tflag    Flag\n\ttoParse []string\n\texpect  string\n}\n\nfunc TestFlagValue(t *testing.T) {\n\tcases := []*flagValueTestCase{\n\t\t{\n\t\t\tname:    \"stringSlice\",\n\t\t\tflag:    &StringSliceFlag{Name: \"flag\", Value: []string{\"default1\", \"default2\"}},\n\t\t\ttoParse: []string{\"--flag\", \"parsed,parsed2\", \"--flag\", \"parsed3,parsed4\"},\n\t\t\texpect:  `[parsed parsed2 parsed3 parsed4]`,\n\t\t},\n\t\t{\n\t\t\tname:    \"float64Slice\",\n\t\t\tflag:    &FloatSliceFlag{Name: \"flag\", Value: []float64{1.1, 2.2}},\n\t\t\ttoParse: []string{\"--flag\", \"13.3,14.4\", \"--flag\", \"15.5,16.6\"},\n\t\t\texpect:  `[]float64{13.3, 14.4, 15.5, 16.6}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"intSlice\",\n\t\t\tflag:    &IntSliceFlag{Name: \"flag\", Value: []int64{1, 2}},\n\t\t\ttoParse: []string{\"--flag\", \"13,14\", \"--flag\", \"15,16\"},\n\t\t\texpect:  `[]int64{13, 14, 15, 16}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"uintSlice\",\n\t\t\tflag:    &UintSliceFlag{Name: \"flag\", Value: []uint64{1, 2}},\n\t\t\ttoParse: []string{\"--flag\", \"13,14\", \"--flag\", \"15,16\"},\n\t\t\texpect:  `[]uint64{13, 14, 15, 16}`,\n\t\t},\n\t\t{\n\t\t\tname:    \"stringMap\",\n\t\t\tflag:    &StringMapFlag{Name: \"flag\", Value: map[string]string{\"default1\": \"default2\"}},\n\t\t\ttoParse: []string{\"--flag\", \"parsed=parsed2\", \"--flag\", \"parsed3=parsed4\"},\n\t\t\texpect:  `map[parsed:parsed2 parsed3:parsed4]`,\n\t\t},\n\t}\n\tfor _, v := range cases {\n\t\tt.Run(v.name, func(t *testing.T) {\n\t\t\tset := flag.NewFlagSet(\"test\", 0)\n\t\t\tset.SetOutput(io.Discard)\n\t\t\t_ = v.flag.Apply(set)\n\t\t\tassert.NoError(t, set.Parse(v.toParse))\n\t\t\tf := set.Lookup(\"flag\")\n\t\t\trequire.Equal(t, v.expect, f.Value.String())\n\t\t})\n\t}\n}\n\nfunc TestTimestampFlagApply_WithDestination(t *testing.T) {\n\tvar destination time.Time\n\texpectedResult, _ := time.Parse(time.RFC3339, \"2006-01-02T15:04:05Z\")\n\tfl := TimestampFlag{Name: \"time\", Aliases: []string{\"t\"}, Config: TimestampConfig{Layouts: []string{time.RFC3339}}, Destination: &destination}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--time\", \"2006-01-02T15:04:05Z\"})\n\tassert.NoError(t, err)\n\tassert.Equal(t, expectedResult, destination)\n}\n\n// Test issue #1254\n// StringSlice() with UseShortOptionHandling causes duplicated entries, depending on the ordering of the flags\nfunc TestSliceShortOptionHandle(t *testing.T) {\n\twasCalled := false\n\terr := (&Command{\n\t\tName:                   \"foobar\",\n\t\tUseShortOptionHandling: true,\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\twasCalled = true\n\n\t\t\tif !cmd.Bool(\"i\") {\n\t\t\t\treturn fmt.Errorf(\"bool i not set\")\n\t\t\t}\n\n\t\t\tif !cmd.Bool(\"t\") {\n\t\t\t\treturn fmt.Errorf(\"bool i not set\")\n\t\t\t}\n\n\t\t\tss := cmd.StringSlice(\"net\")\n\t\t\tif !reflect.DeepEqual(ss, []string{\"foo\"}) {\n\t\t\t\treturn fmt.Errorf(\"got different slice %q than expected\", ss)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tFlags: []Flag{\n\t\t\t&StringSliceFlag{Name: \"net\"},\n\t\t\t&BoolFlag{Name: \"i\"},\n\t\t\t&BoolFlag{Name: \"t\"},\n\t\t},\n\t}).Run(buildTestContext(t), []string{\"foobar\", \"--net=foo\", \"-it\"})\n\n\tr := require.New(t)\n\n\tr.NoError(err)\n\tr.Truef(wasCalled, \"action callback was never called\")\n}\n\n// Test issue #1541\nfunc TestCustomizedSliceFlagSeparator(t *testing.T) {\n\tdefaultSliceFlagSeparator = \";\"\n\tdefer func() {\n\t\tdefaultSliceFlagSeparator = \",\"\n\t}()\n\topts := []string{\"opt1\", \"opt2\", \"opt3,op\", \"opt4\"}\n\tret := flagSplitMultiValues(strings.Join(opts, \";\"))\n\trequire.Equal(t, 4, len(ret), \"split slice flag failed\")\n\tfor idx, r := range ret {\n\t\trequire.Equal(t, opts[idx], r, \"get %dth failed\", idx)\n\t}\n}\n\nfunc TestFlagSplitMultiValues_Disabled(t *testing.T) {\n\tdisableSliceFlagSeparator = true\n\tdefer func() {\n\t\tdisableSliceFlagSeparator = false\n\t}()\n\n\topts := []string{\"opt1\", \"opt2\", \"opt3,op\", \"opt4\"}\n\tret := flagSplitMultiValues(strings.Join(opts, defaultSliceFlagSeparator))\n\trequire.Equal(t, 1, len(ret), \"failed to disable split slice flag\")\n\trequire.Equal(t, strings.Join(opts, defaultSliceFlagSeparator), ret[0])\n}\n\nvar stringMapFlagTests = []struct {\n\tname     string\n\taliases  []string\n\tvalue    map[string]string\n\texpected string\n}{\n\t{\"foo\", nil, nil, \"--foo value [ --foo value ]\\t\"},\n\t{\"f\", nil, nil, \"-f value [ -f value ]\\t\"},\n\t{\"f\", nil, map[string]string{\"Lipstick\": \"\"}, \"-f value [ -f value ]\\t(default: Lipstick=)\"},\n\t{\"test\", nil, map[string]string{\"Something\": \"\"}, \"--test value [ --test value ]\\t(default: Something=)\"},\n\t{\"dee\", []string{\"d\"}, map[string]string{\"Inka\": \"Dinka\", \"dooo\": \"\"}, \"--dee value, -d value [ --dee value, -d value ]\\t(default: Inka=\\\"Dinka\\\", dooo=)\"},\n}\n\nfunc TestStringMapFlagHelpOutput(t *testing.T) {\n\tfor _, test := range stringMapFlagTests {\n\t\tf := &StringMapFlag{Name: test.name, Aliases: test.aliases, Value: test.value}\n\t\tassert.Equal(t, test.expected, f.String())\n\t}\n}\n\nfunc TestStringMapFlagWithEnvVarHelpOutput(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"APP_QWWX\", \"11,4\")\n\n\tfor _, test := range stringMapFlagTests {\n\t\tfl := &StringMapFlag{Name: test.name, Aliases: test.aliases, Value: test.value, Sources: EnvVars(\"APP_QWWX\")}\n\t\toutput := fl.String()\n\n\t\texpectedSuffix := withEnvHint([]string{\"APP_QWWX\"}, \"\")\n\t\tif !strings.HasSuffix(output, expectedSuffix) {\n\t\t\tt.Errorf(\"%q does not end with\"+expectedSuffix, output)\n\t\t}\n\t}\n}\n\nfunc TestStringMapFlagApply_SetsAllNames(t *testing.T) {\n\tfl := StringMapFlag{Name: \"goat\", Aliases: []string{\"G\", \"gooots\"}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--goat\", \"aaa=\", \"-G\", \"bbb=\", \"--gooots\", \"eeeee=\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestStringMapFlagApply_UsesEnvValues_noDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"vincent van goat=scape goat\")\n\tvar val map[string]string\n\tfl := StringMapFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\"), Value: val}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Nil(t, val)\n\tassert.Equal(t, map[string]string{\"vincent van goat\": \"scape goat\"}, set.Lookup(\"goat\").Value.(flag.Getter).Get())\n}\n\nfunc TestStringMapFlagApply_UsesEnvValues_withDefault(t *testing.T) {\n\tdefer resetEnv(os.Environ())\n\tos.Clearenv()\n\t_ = os.Setenv(\"MY_GOAT\", \"vincent van goat=scape goat\")\n\tval := map[string]string{`some default`: `values here`}\n\tfl := StringMapFlag{Name: \"goat\", Sources: EnvVars(\"MY_GOAT\"), Value: val}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\terr := set.Parse(nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]string{`some default`: `values here`}, val)\n\tassert.Equal(t, map[string]string{\"vincent van goat\": \"scape goat\"}, set.Lookup(\"goat\").Value.(flag.Getter).Get())\n}\n\nfunc TestStringMapFlagApply_DefaultValueWithDestination(t *testing.T) {\n\tdefValue := map[string]string{\"UA\": \"US\"}\n\n\tfl := StringMapFlag{Name: \"country\", Value: defValue, Destination: &map[string]string{\"CA\": \"\"}}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{})\n\tassert.NoError(t, err)\n\tassert.Equal(t, defValue, *fl.Destination)\n}\n\nfunc TestStringMapFlagValueFromCommand(t *testing.T) {\n\tset := flag.NewFlagSet(\"test\", 0)\n\tset.Var(NewStringMap(map[string]string{\"a\": \"b\", \"c\": \"\"}), \"myflag\", \"doc\")\n\tcmd := &Command{flagSet: set}\n\tf := &StringMapFlag{Name: \"myflag\"}\n\trequire.Equal(t, map[string]string{\"a\": \"b\", \"c\": \"\"}, cmd.StringMap(f.Name))\n}\n\nfunc TestStringMapFlagApply_Error(t *testing.T) {\n\tfl := StringMapFlag{Name: \"goat\"}\n\tset := flag.NewFlagSet(\"test\", 0)\n\t_ = fl.Apply(set)\n\n\terr := set.Parse([]string{\"--goat\", \"aaa\", \"bbb=\"})\n\tassert.Error(t, err)\n}\n\nfunc TestZeroValueMutexFlag(t *testing.T) {\n\tvar fl MutuallyExclusiveFlags\n\tassert.NoError(t, fl.check(&Command{}))\n}\n\nfunc TestExtFlag(t *testing.T) {\n\tfs := flag.NewFlagSet(\"foo\", flag.ContinueOnError)\n\n\tvar iv intValue\n\tvar ipv int64\n\n\tf := &flag.Flag{\n\t\tName:     \"bar\",\n\t\tUsage:    \"bar usage\",\n\t\tValue:    iv.Create(11, &ipv, IntegerConfig{}),\n\t\tDefValue: \"10\",\n\t}\n\n\textF := &extFlag{\n\t\tf: f,\n\t}\n\n\tassert.NoError(t, extF.Apply(fs))\n\tassert.Equal(t, []string{\"bar\"}, extF.Names())\n\tassert.True(t, extF.IsVisible())\n\tassert.False(t, extF.IsSet())\n\tassert.False(t, extF.TakesValue())\n\tassert.Equal(t, \"bar usage\", extF.GetUsage())\n\tassert.Equal(t, \"11\", extF.GetValue())\n\tassert.Equal(t, \"10\", extF.GetDefaultText())\n\tassert.Nil(t, extF.GetEnvVars())\n}\n\nfunc TestSliceValuesNil(t *testing.T) {\n\tassert.Equal(t, []float64(nil), NewFloatSlice().Value())\n\tassert.Equal(t, []int64(nil), NewIntSlice().Value())\n\tassert.Equal(t, []uint64(nil), NewUintSlice().Value())\n\tassert.Equal(t, []string(nil), NewStringSlice().Value())\n\n\tassert.Equal(t, []float64(nil), (&FloatSlice{}).Value())\n\tassert.Equal(t, []int64(nil), (&IntSlice{}).Value())\n\tassert.Equal(t, []uint64(nil), (&UintSlice{}).Value())\n\tassert.Equal(t, []string(nil), (&StringSlice{}).Value())\n}\n\nfunc TestFileHint(t *testing.T) {\n\tassert.Equal(t, \"\", withFileHint(\"\", \"\"))\n\tassert.Equal(t, \" [/tmp/foo.txt]\", withFileHint(\"/tmp/foo.txt\", \"\"))\n\tassert.Equal(t, \"foo\", withFileHint(\"\", \"foo\"))\n\tassert.Equal(t, \"bar [/tmp/foo.txt]\", withFileHint(\"/tmp/foo.txt\", \"bar\"))\n}\n\nfunc TestFlagsByName(t *testing.T) {\n\tflags := []Flag{\n\t\t&StringFlag{\n\t\t\tName: \"b2\",\n\t\t},\n\t\t&IntFlag{\n\t\t\tName: \"a0\",\n\t\t},\n\t\t&FloatFlag{\n\t\t\tName: \"b1\",\n\t\t},\n\t}\n\n\tflagsByName := FlagsByName(flags)\n\tsort.Sort(flagsByName)\n\n\tassert.Equal(t, len(flags), flagsByName.Len())\n\n\tvar prev Flag\n\tfor _, f := range flags {\n\t\tif prev != nil {\n\t\t\tassert.LessOrEqual(t, prev.Names()[0], f.Names()[0])\n\t\t}\n\t\tprev = f\n\t}\n}\n\nfunc TestNonStringMap(t *testing.T) {\n\ttype (\n\t\tfloatMap = MapBase[float64, NoConfig, floatValue]\n\t)\n\n\tp := map[string]float64{}\n\n\tvar fv floatValue\n\n\tf := &floatMap{\n\t\tvalue: &fv,\n\t}\n\n\tassert.Equal(t, map[string]float64{}, f.Value())\n\tf.dict = &p\n\tassert.Equal(t, map[string]float64{}, f.Value())\n\tassert.Equal(t, \"map[string]float64{}\", f.String())\n\n\tassert.ErrorContains(t, f.Set(\"invalid=value\"), \"ParseFloat\")\n}\n\nfunc TestUnquoteUsage(t *testing.T) {\n\ttests := []struct {\n\t\tstr      string\n\t\texpStr   string\n\t\texpUsage string\n\t}{\n\t\t{\"foo\", \"\", \"foo\"},\n\t\t{\"foo something\", \"\", \"foo something\"},\n\t\t{\"foo `bar 11`\", \"bar 11\", \"foo bar 11\"},\n\t\t{\"foo `bar 11` sobar\", \"bar 11\", \"foo bar 11 sobar\"},\n\t\t{\"foo `bar 11\", \"\", \"foo `bar 11\"},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(fmt.Sprintf(\"unquote %d\", i), func(t *testing.T) {\n\t\t\tstr, usage := unquoteUsage(test.str)\n\t\t\tassert.Equal(t, test.expStr, str)\n\t\t\tassert.Equal(t, test.expUsage, usage)\n\t\t})\n\t}\n}\n\nfunc TestEnvHintWindows(t *testing.T) {\n\tif runtime.GOOS == \"windows\" && os.Getenv(\"PSHOME\") == \"\" {\n\t\tassert.Equal(t, \"something [%foo%, %bar%, %ss%]\", withEnvHint([]string{\"foo\", \"bar\", \"ss\"}, \"something\"))\n\t}\n}\n\nfunc TestDocGetValue(t *testing.T) {\n\tassert.Equal(t, \"\", (&BoolFlag{Name: \"foo\", Value: true}).GetValue())\n\tassert.Equal(t, \"\", (&BoolFlag{Name: \"foo\", Value: false}).GetValue())\n\tassert.Equal(t, \"bar\", (&StringFlag{Name: \"foo\", Value: \"bar\"}).GetValue())\n}\n\nfunc TestGenericFlag_SatisfiesFlagInterface(t *testing.T) {\n\tvar f Flag = &GenericFlag{}\n\n\t_ = f.IsSet()\n\t_ = f.Names()\n}\n\nfunc TestGenericValue_SatisfiesBoolInterface(t *testing.T) {\n\tvar f boolFlag = &genericValue{}\n\n\tassert.False(t, f.IsBoolFlag())\n\n\tfv := floatValue(0)\n\tf = &genericValue{\n\t\tval: &fv,\n\t}\n\n\tassert.False(t, f.IsBoolFlag())\n\n\tf = &genericValue{\n\t\tval: &boolValue{},\n\t}\n\tassert.True(t, f.IsBoolFlag())\n}\n\nfunc TestGenericFlag_SatisfiesFmtStringerInterface(t *testing.T) {\n\tvar f fmt.Stringer = &GenericFlag{}\n\n\t_ = f.String()\n}\n\nfunc TestGenericFlag_SatisfiesRequiredFlagInterface(t *testing.T) {\n\tvar f RequiredFlag = &GenericFlag{}\n\n\t_ = f.IsRequired()\n}\n\nfunc TestGenericFlag_SatisfiesVisibleFlagInterface(t *testing.T) {\n\tvar f VisibleFlag = &GenericFlag{}\n\n\t_ = f.IsVisible()\n}\n\nfunc TestGenericFlag_SatisfiesDocFlagInterface(t *testing.T) {\n\tvar f DocGenerationFlag = &GenericFlag{}\n\n\t_ = f.GetUsage()\n}\n\nfunc TestGenericValue(t *testing.T) {\n\tg := &genericValue{}\n\tassert.NoError(t, g.Set(\"something\"))\n\tassert.Nil(t, g.Get())\n\tassert.Empty(t, g.String())\n}\n"
        },
        {
          "name": "flag_timestamp.go",
          "type": "blob",
          "size": 3.3798828125,
          "content": "package cli\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n)\n\ntype TimestampFlag = FlagBase[time.Time, TimestampConfig, timestampValue]\n\n// TimestampConfig defines the config for timestamp flags\ntype TimestampConfig struct {\n\tTimezone *time.Location\n\t// Available layouts for flag value.\n\t//\n\t// Note that value for formats with missing year/date will be interpreted as current year/date respectively.\n\t//\n\t// Read more about time layouts: https://pkg.go.dev/time#pkg-constants\n\tLayouts []string\n}\n\n// timestampValue wrap to satisfy golang's flag interface.\ntype timestampValue struct {\n\ttimestamp  *time.Time\n\thasBeenSet bool\n\tlayouts    []string\n\tlocation   *time.Location\n}\n\nvar _ ValueCreator[time.Time, TimestampConfig] = timestampValue{}\n\n// Below functions are to satisfy the ValueCreator interface\n\nfunc (t timestampValue) Create(val time.Time, p *time.Time, c TimestampConfig) Value {\n\t*p = val\n\treturn &timestampValue{\n\t\ttimestamp: p,\n\t\tlayouts:   c.Layouts,\n\t\tlocation:  c.Timezone,\n\t}\n}\n\nfunc (t timestampValue) ToString(b time.Time) string {\n\tif b.IsZero() {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"%v\", b)\n}\n\n// Timestamp constructor(for internal testing only)\nfunc newTimestamp(timestamp time.Time) *timestampValue {\n\treturn &timestampValue{timestamp: &timestamp}\n}\n\n// Below functions are to satisfy the flag.Value interface\n\n// Parses the string value to timestamp\nfunc (t *timestampValue) Set(value string) error {\n\tvar timestamp time.Time\n\tvar err error\n\n\tif t.location == nil {\n\t\tt.location = time.UTC\n\t}\n\n\tif len(t.layouts) == 0 {\n\t\treturn errors.New(\"got nil/empty layouts slice\")\n\t}\n\n\tfor _, layout := range t.layouts {\n\t\tvar locErr error\n\n\t\ttimestamp, locErr = time.ParseInLocation(layout, value, t.location)\n\t\tif locErr != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = locErr\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terr = newMultiError(err, locErr)\n\t\t\tcontinue\n\t\t}\n\n\t\terr = nil\n\t\tbreak\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefaultTS, _ := time.ParseInLocation(time.TimeOnly, time.TimeOnly, timestamp.Location())\n\n\tn := time.Now()\n\n\t// If format is missing date (or year only), set it explicitly to current\n\tif timestamp.Truncate(time.Hour*24).UnixNano() == defaultTS.Truncate(time.Hour*24).UnixNano() {\n\t\ttimestamp = time.Date(\n\t\t\tn.Year(),\n\t\t\tn.Month(),\n\t\t\tn.Day(),\n\t\t\ttimestamp.Hour(),\n\t\t\ttimestamp.Minute(),\n\t\t\ttimestamp.Second(),\n\t\t\ttimestamp.Nanosecond(),\n\t\t\ttimestamp.Location(),\n\t\t)\n\t} else if timestamp.Year() == 0 {\n\t\ttimestamp = time.Date(\n\t\t\tn.Year(),\n\t\t\ttimestamp.Month(),\n\t\t\ttimestamp.Day(),\n\t\t\ttimestamp.Hour(),\n\t\t\ttimestamp.Minute(),\n\t\t\ttimestamp.Second(),\n\t\t\ttimestamp.Nanosecond(),\n\t\t\ttimestamp.Location(),\n\t\t)\n\t}\n\n\tif t.timestamp != nil {\n\t\t*t.timestamp = timestamp\n\t}\n\tt.hasBeenSet = true\n\treturn nil\n}\n\n// String returns a readable representation of this value (for usage defaults)\nfunc (t *timestampValue) String() string {\n\treturn fmt.Sprintf(\"%#v\", t.timestamp)\n}\n\n// Value returns the timestamp value stored in the flag\nfunc (t *timestampValue) Value() *time.Time {\n\treturn t.timestamp\n}\n\n// Get returns the flag structure\nfunc (t *timestampValue) Get() any {\n\treturn *t.timestamp\n}\n\n// Timestamp gets the timestamp from a flag name\nfunc (cmd *Command) Timestamp(name string) time.Time {\n\tif v, ok := cmd.Value(name).(time.Time); ok {\n\t\ttracef(\"time.Time available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"time.Time NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn time.Time{}\n}\n"
        },
        {
          "name": "flag_uint.go",
          "type": "blob",
          "size": 1.138671875,
          "content": "package cli\n\nimport (\n\t\"strconv\"\n)\n\ntype UintFlag = FlagBase[uint64, IntegerConfig, uintValue]\n\n// -- uint64 Value\ntype uintValue struct {\n\tval  *uint64\n\tbase int\n}\n\n// Below functions are to satisfy the ValueCreator interface\n\nfunc (i uintValue) Create(val uint64, p *uint64, c IntegerConfig) Value {\n\t*p = val\n\treturn &uintValue{\n\t\tval:  p,\n\t\tbase: c.Base,\n\t}\n}\n\nfunc (i uintValue) ToString(b uint64) string {\n\treturn strconv.FormatUint(b, 10)\n}\n\n// Below functions are to satisfy the flag.Value interface\n\nfunc (i *uintValue) Set(s string) error {\n\tv, err := strconv.ParseUint(s, i.base, 64)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*i.val = v\n\treturn err\n}\n\nfunc (i *uintValue) Get() any { return uint64(*i.val) }\n\nfunc (i *uintValue) String() string { return strconv.FormatUint(uint64(*i.val), 10) }\n\n// Uint looks up the value of a local Uint64Flag, returns\n// 0 if not found\nfunc (cmd *Command) Uint(name string) uint64 {\n\tif v, ok := cmd.Value(name).(uint64); ok {\n\t\ttracef(\"uint available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"uint NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn 0\n}\n"
        },
        {
          "name": "flag_uint_slice.go",
          "type": "blob",
          "size": 0.5986328125,
          "content": "package cli\n\ntype (\n\tUintSlice     = SliceBase[uint64, IntegerConfig, uintValue]\n\tUintSliceFlag = FlagBase[[]uint64, IntegerConfig, UintSlice]\n)\n\nvar NewUintSlice = NewSliceBase[uint64, IntegerConfig, uintValue]\n\n// UintSlice looks up the value of a local UintSliceFlag, returns\n// nil if not found\nfunc (cmd *Command) UintSlice(name string) []uint64 {\n\tif v, ok := cmd.Value(name).([]uint64); ok {\n\t\ttracef(\"uint slice available for flag name %[1]q with value=%[2]v (cmd=%[3]q)\", name, v, cmd.Name)\n\t\treturn v\n\t}\n\n\ttracef(\"uint slice NOT available for flag name %[1]q (cmd=%[2]q)\", name, cmd.Name)\n\treturn nil\n}\n"
        },
        {
          "name": "flag_validation_test.go",
          "type": "blob",
          "size": 2.037109375,
          "content": "package cli\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestFlagDefaultValidation(t *testing.T) {\n\tcmd := &Command{\n\t\tName: \"foo\",\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{\n\t\t\t\tName:  \"if\",\n\t\t\t\tValue: 2, // this value should fail validation\n\t\t\t\tValidator: func(i int64) error {\n\t\t\t\t\tif (i >= 3 && i <= 10) || (i >= 20 && i <= 24) {\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\treturn fmt.Errorf(\"Value %d not in range [3,10] or [20,24]\", i)\n\t\t\t\t},\n\t\t\t\tValidateDefaults: true,\n\t\t\t},\n\t\t},\n\t}\n\n\tr := require.New(t)\n\n\t// Default value of flag is 2 which should fail validation\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"--if\", \"5\"})\n\tr.Error(err)\n}\n\nfunc TestFlagValidation(t *testing.T) {\n\tr := require.New(t)\n\n\ttestCases := []struct {\n\t\tname        string\n\t\targ         string\n\t\terrExpected bool\n\t}{\n\t\t{\n\t\t\tname:        \"first range less than min\",\n\t\t\targ:         \"2\",\n\t\t\terrExpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"first range min\",\n\t\t\targ:  \"3\",\n\t\t},\n\t\t{\n\t\t\tname: \"first range mid\",\n\t\t\targ:  \"7\",\n\t\t},\n\t\t{\n\t\t\tname: \"first range max\",\n\t\t\targ:  \"10\",\n\t\t},\n\t\t{\n\t\t\tname:        \"first range greater than max\",\n\t\t\targ:         \"15\",\n\t\t\terrExpected: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"second range less than min\",\n\t\t\targ:         \"19\",\n\t\t\terrExpected: true,\n\t\t},\n\t\t{\n\t\t\tname: \"second range min\",\n\t\t\targ:  \"20\",\n\t\t},\n\t\t{\n\t\t\tname: \"second range mid\",\n\t\t\targ:  \"21\",\n\t\t},\n\t\t{\n\t\t\tname: \"second range max\",\n\t\t\targ:  \"24\",\n\t\t},\n\t\t{\n\t\t\tname:        \"second range greater than max\",\n\t\t\targ:         \"27\",\n\t\t\terrExpected: true,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tcmd := &Command{\n\t\t\tName: \"foo\",\n\t\t\tFlags: []Flag{\n\t\t\t\t&IntFlag{\n\t\t\t\t\tName:  \"it\",\n\t\t\t\t\tValue: 5, // note that this value should pass validation\n\t\t\t\t\tValidator: func(i int64) error {\n\t\t\t\t\t\tif (i >= 3 && i <= 10) || (i >= 20 && i <= 24) {\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fmt.Errorf(\"Value %d not in range [3,10]U[20,24]\", i)\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"--it\", testCase.arg})\n\t\tif !testCase.errExpected {\n\t\t\tr.NoError(err)\n\t\t} else {\n\t\t\tr.Error(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "funcs.go",
          "type": "blob",
          "size": 2.244140625,
          "content": "package cli\n\nimport \"context\"\n\n// ShellCompleteFunc is an action to execute when the shell completion flag is set\ntype ShellCompleteFunc func(context.Context, *Command)\n\n// BeforeFunc is an action that executes prior to any subcommands being run once\n// the context is ready.  If a non-nil error is returned, no subcommands are\n// run.\ntype BeforeFunc func(context.Context, *Command) (context.Context, error)\n\n// AfterFunc is an action that executes after any subcommands are run and have\n// finished. The AfterFunc is run even if Action() panics.\ntype AfterFunc func(context.Context, *Command) error\n\n// ActionFunc is the action to execute when no subcommands are specified\ntype ActionFunc func(context.Context, *Command) error\n\n// CommandNotFoundFunc is executed if the proper command cannot be found\ntype CommandNotFoundFunc func(context.Context, *Command, string)\n\n// OnUsageErrorFunc is executed if a usage error occurs. This is useful for displaying\n// customized usage error messages.  This function is able to replace the\n// original error messages.  If this function is not set, the \"Incorrect usage\"\n// is displayed and the execution is interrupted.\ntype OnUsageErrorFunc func(ctx context.Context, cmd *Command, err error, isSubcommand bool) error\n\n// InvalidFlagAccessFunc is executed when an invalid flag is accessed from the context.\ntype InvalidFlagAccessFunc func(context.Context, *Command, string)\n\n// ExitErrHandlerFunc is executed if provided in order to handle exitError values\n// returned by Actions and Before/After functions.\ntype ExitErrHandlerFunc func(context.Context, *Command, error)\n\n// FlagStringFunc is used by the help generation to display a flag, which is\n// expected to be a single line.\ntype FlagStringFunc func(Flag) string\n\n// FlagNamePrefixFunc is used by the default FlagStringFunc to create prefix\n// text for a flag's full name.\ntype FlagNamePrefixFunc func(fullName []string, placeholder string) string\n\n// FlagEnvHintFunc is used by the default FlagStringFunc to annotate flag help\n// with the environment variable details.\ntype FlagEnvHintFunc func(envVars []string, str string) string\n\n// FlagFileHintFunc is used by the default FlagStringFunc to annotate flag help\n// with the file path details.\ntype FlagFileHintFunc func(filePath, str string) string\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2265625,
          "content": "module github.com/urfave/cli/v3\n\ngo 1.22\n\nrequire github.com/stretchr/testify v1.9.0\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.8603515625,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "godoc-current.txt",
          "type": "blob",
          "size": 38.7626953125,
          "content": "package cli // import \"github.com/urfave/cli/v3\"\n\nPackage cli provides a minimal framework for creating and organizing command\nline Go applications. cli is designed to be easy to understand and write,\nthe most simple cli application can be written as follows:\n\n    func main() {\n    \t(&cli.Command{}).Run(context.Background(), os.Args)\n    }\n\nOf course this application does not do much, so let's make this an actual\napplication:\n\n    func main() {\n    \tcmd := &cli.Command{\n      \t\tName: \"greet\",\n      \t\tUsage: \"say a greeting\",\n      \t\tAction: func(c *cli.Context) error {\n      \t\t\tfmt.Println(\"Greetings\")\n      \t\t\treturn nil\n      \t\t},\n    \t}\n\n    \tcmd.Run(context.Background(), os.Args)\n    }\n\nVARIABLES\n\nvar (\n\tSuggestFlag               SuggestFlagFunc    = suggestFlag\n\tSuggestCommand            SuggestCommandFunc = suggestCommand\n\tSuggestDidYouMeanTemplate string             = suggestDidYouMeanTemplate\n)\nvar AnyArguments = []Argument{\n\t&StringArg{\n\t\tMax: -1,\n\t},\n}\n    AnyArguments to differentiate between no arguments(nil) vs aleast one\n\nvar CommandHelpTemplate = `NAME:\n   {{template \"helpNameTemplate\" .}}\n\nUSAGE:\n   {{template \"usageTemplate\" .}}{{if .Category}}\n\nCATEGORY:\n   {{.Category}}{{end}}{{if .Description}}\n\nDESCRIPTION:\n   {{template \"descriptionTemplate\" .}}{{end}}{{if .VisibleFlagCategories}}\n\nOPTIONS:{{template \"visibleFlagCategoryTemplate\" .}}{{else if .VisibleFlags}}\n\nOPTIONS:{{template \"visibleFlagTemplate\" .}}{{end}}{{if .VisiblePersistentFlags}}\n\nGLOBAL OPTIONS:{{template \"visiblePersistentFlagTemplate\" .}}{{end}}\n`\n    CommandHelpTemplate is the text template for the command help topic. cli.go\n    uses text/template to render templates. You can render custom help text by\n    setting this variable.\n\nvar DefaultInverseBoolPrefix = \"no-\"\nvar ErrWriter io.Writer = os.Stderr\n    ErrWriter is used to write errors to the user. This can be anything\n    implementing the io.Writer interface and defaults to os.Stderr.\n\nvar FishCompletionTemplate = `# {{ .Command.Name }} fish shell completion\n\nfunction __fish_{{ .Command.Name }}_no_subcommand --description 'Test if there has been any subcommand yet'\n    for i in (commandline -opc)\n        if contains -- $i{{ range $v := .AllCommands }} {{ $v }}{{ end }}\n            return 1\n        end\n    end\n    return 0\nend\n\n{{ range $v := .Completions }}{{ $v }}\n{{ end }}`\nvar NewFloatSlice = NewSliceBase[float64, NoConfig, floatValue]\nvar NewIntSlice = NewSliceBase[int64, IntegerConfig, intValue]\nvar NewStringMap = NewMapBase[string, StringConfig, stringValue]\nvar NewStringSlice = NewSliceBase[string, StringConfig, stringValue]\nvar NewUintSlice = NewSliceBase[uint64, IntegerConfig, uintValue]\nvar OsExiter = os.Exit\n    OsExiter is the function used when the app exits. If not set defaults to\n    os.Exit.\n\nvar RootCommandHelpTemplate = `NAME:\n   {{template \"helpNameTemplate\" .}}\n\nUSAGE:\n   {{if .UsageText}}{{wrap .UsageText 3}}{{else}}{{.FullName}} {{if .VisibleFlags}}[global options]{{end}}{{if .VisibleCommands}} [command [command options]]{{end}}{{if .ArgsUsage}} {{.ArgsUsage}}{{else}}{{if .Arguments}} [arguments...]{{end}}{{end}}{{end}}{{if .Version}}{{if not .HideVersion}}\n\nVERSION:\n   {{.Version}}{{end}}{{end}}{{if .Description}}\n\nDESCRIPTION:\n   {{template \"descriptionTemplate\" .}}{{end}}\n{{- if len .Authors}}\n\nAUTHOR{{template \"authorsTemplate\" .}}{{end}}{{if .VisibleCommands}}\n\nCOMMANDS:{{template \"visibleCommandCategoryTemplate\" .}}{{end}}{{if .VisibleFlagCategories}}\n\nGLOBAL OPTIONS:{{template \"visibleFlagCategoryTemplate\" .}}{{else if .VisibleFlags}}\n\nGLOBAL OPTIONS:{{template \"visibleFlagTemplate\" .}}{{end}}{{if .Copyright}}\n\nCOPYRIGHT:\n   {{template \"copyrightTemplate\" .}}{{end}}\n`\n    RootCommandHelpTemplate is the text template for the Default help topic.\n    cli.go uses text/template to render templates. You can render custom help\n    text by setting this variable.\n\nvar SubcommandHelpTemplate = `NAME:\n   {{template \"helpNameTemplate\" .}}\n\nUSAGE:\n   {{if .UsageText}}{{wrap .UsageText 3}}{{else}}{{.FullName}}{{if .VisibleCommands}} [command [command options]] {{end}}{{if .ArgsUsage}} {{.ArgsUsage}}{{else}}{{if .Arguments}} [arguments...]{{end}}{{end}}{{end}}{{if .Category}}\n\nCATEGORY:\n   {{.Category}}{{end}}{{if .Description}}\n\nDESCRIPTION:\n   {{template \"descriptionTemplate\" .}}{{end}}{{if .VisibleCommands}}\n\nCOMMANDS:{{template \"visibleCommandTemplate\" .}}{{end}}{{if .VisibleFlagCategories}}\n\nOPTIONS:{{template \"visibleFlagCategoryTemplate\" .}}{{else if .VisibleFlags}}\n\nOPTIONS:{{template \"visibleFlagTemplate\" .}}{{end}}\n`\n    SubcommandHelpTemplate is the text template for the subcommand help topic.\n    cli.go uses text/template to render templates. You can render custom help\n    text by setting this variable.\n\nvar VersionPrinter = printVersion\n    VersionPrinter prints the version for the App\n\nvar HelpPrinter helpPrinter = printHelp\n    HelpPrinter is a function that writes the help output. If not set\n    explicitly, this calls HelpPrinterCustom using only the default template\n    functions.\n\n    If custom logic for printing help is required, this function can be\n    overridden. If the ExtraInfo field is defined on an App, this function\n    should not be modified, as HelpPrinterCustom will be used directly in order\n    to capture the extra information.\n\nvar HelpPrinterCustom helpPrinterCustom = printHelpCustom\n    HelpPrinterCustom is a function that writes the help output. It is used as\n    the default implementation of HelpPrinter, and may be called directly if the\n    ExtraInfo field is set on an App.\n\n    In the default implementation, if the customFuncs argument contains a\n    \"wrapAt\" key, which is a function which takes no arguments and returns an\n    int, this int value will be used to produce a \"wrap\" function used by the\n    default template to wrap long lines.\n\n\nFUNCTIONS\n\nfunc DefaultAppComplete(ctx context.Context, cmd *Command)\n    DefaultAppComplete prints the list of subcommands as the default app\n    completion method\n\nfunc DefaultCompleteWithFlags(ctx context.Context, cmd *Command)\nfunc FlagNames(name string, aliases []string) []string\nfunc HandleExitCoder(err error)\n    HandleExitCoder handles errors implementing ExitCoder by printing their\n    message and calling OsExiter with the given exit code.\n\n    If the given error instead implements MultiError, each error will be checked\n    for the ExitCoder interface, and OsExiter will be called with the last exit\n    code found, or exit code 1 if no ExitCoder is found.\n\n    This function is the default error-handling behavior for an App.\n\nfunc ShowAppHelp(cmd *Command) error\n    ShowAppHelp is an action that displays the help.\n\nfunc ShowAppHelpAndExit(cmd *Command, exitCode int)\n    ShowAppHelpAndExit - Prints the list of subcommands for the app and exits\n    with exit code.\n\nfunc ShowCommandHelp(ctx context.Context, cmd *Command, commandName string) error\n    ShowCommandHelp prints help for the given command\n\nfunc ShowCommandHelpAndExit(ctx context.Context, cmd *Command, command string, code int)\n    ShowCommandHelpAndExit - exits with code after showing help\n\nfunc ShowSubcommandHelp(cmd *Command) error\n    ShowSubcommandHelp prints help for the given subcommand\n\nfunc ShowSubcommandHelpAndExit(cmd *Command, exitCode int)\n    ShowSubcommandHelpAndExit - Prints help for the given subcommand and exits\n    with exit code.\n\nfunc ShowVersion(cmd *Command)\n    ShowVersion prints the version number of the App\n\n\nTYPES\n\ntype ActionFunc func(context.Context, *Command) error\n    ActionFunc is the action to execute when no subcommands are specified\n\ntype ActionableFlag interface {\n\tRunAction(context.Context, *Command) error\n}\n    ActionableFlag is an interface that wraps Flag interface and RunAction\n    operation.\n\ntype AfterFunc func(context.Context, *Command) error\n    AfterFunc is an action that executes after any subcommands are run and have\n    finished. The AfterFunc is run even if Action() panics.\n\ntype Args interface {\n\t// Get returns the nth argument, or else a blank string\n\tGet(n int) string\n\t// First returns the first argument, or else a blank string\n\tFirst() string\n\t// Tail returns the rest of the arguments (not the first one)\n\t// or else an empty string slice\n\tTail() []string\n\t// Len returns the length of the wrapped slice\n\tLen() int\n\t// Present checks if there are any arguments present\n\tPresent() bool\n\t// Slice returns a copy of the internal slice\n\tSlice() []string\n}\n\ntype Argument interface {\n\tParse([]string) ([]string, error)\n\tUsage() string\n}\n\ntype ArgumentBase[T any, C any, VC ValueCreator[T, C]] struct {\n\tName        string `json:\"name\"`      // the name of this argument\n\tValue       T      `json:\"value\"`     // the default value of this argument\n\tDestination *T     `json:\"-\"`         // the destination point for this argument\n\tValues      *[]T   `json:\"-\"`         // all the values of this argument, only if multiple are supported\n\tUsageText   string `json:\"usageText\"` // the usage text to show\n\tMin         int    `json:\"minTimes\"`  // the min num of occurrences of this argument\n\tMax         int    `json:\"maxTimes\"`  // the max num of occurrences of this argument, set to -1 for unlimited\n\tConfig      C      `json:\"config\"`    // config for this argument similar to Flag Config\n}\n\nfunc (a *ArgumentBase[T, C, VC]) Parse(s []string) ([]string, error)\n\nfunc (a *ArgumentBase[T, C, VC]) Usage() string\n\ntype BeforeFunc func(context.Context, *Command) (context.Context, error)\n    BeforeFunc is an action that executes prior to any subcommands being run\n    once the context is ready. If a non-nil error is returned, no subcommands\n    are run.\n\ntype BoolConfig struct {\n\tCount *int\n}\n    BoolConfig defines the configuration for bool flags\n\ntype BoolFlag = FlagBase[bool, BoolConfig, boolValue]\n\ntype BoolWithInverseFlag struct {\n\t// The BoolFlag which the positive and negative flags are generated from\n\t*BoolFlag\n\n\t// The prefix used to indicate a negative value\n\t// Default: `env` becomes `no-env`\n\tInversePrefix string\n\n\t// Has unexported fields.\n}\n\nfunc (parent *BoolWithInverseFlag) Apply(set *flag.FlagSet) error\n\nfunc (parent *BoolWithInverseFlag) Flags() []Flag\n\nfunc (parent *BoolWithInverseFlag) IsSet() bool\n\nfunc (parent *BoolWithInverseFlag) Names() []string\n\nfunc (parent *BoolWithInverseFlag) RunAction(ctx context.Context, cmd *Command) error\n\nfunc (parent *BoolWithInverseFlag) String() string\n    String implements the standard Stringer interface.\n\n    Example for BoolFlag{Name: \"env\"} --[no-]env (default: false)\n\nfunc (parent *BoolWithInverseFlag) Value() bool\n\ntype CategorizableFlag interface {\n\t// Returns the category of the flag\n\tGetCategory() string\n\n\t// Sets the category of the flag\n\tSetCategory(string)\n}\n    CategorizableFlag is an interface that allows us to potentially use a flag\n    in a categorized representation.\n\ntype Command struct {\n\t// The name of the command\n\tName string `json:\"name\"`\n\t// A list of aliases for the command\n\tAliases []string `json:\"aliases\"`\n\t// A short description of the usage of this command\n\tUsage string `json:\"usage\"`\n\t// Text to override the USAGE section of help\n\tUsageText string `json:\"usageText\"`\n\t// A short description of the arguments of this command\n\tArgsUsage string `json:\"argsUsage\"`\n\t// Version of the command\n\tVersion string `json:\"version\"`\n\t// Longer explanation of how the command works\n\tDescription string `json:\"description\"`\n\t// DefaultCommand is the (optional) name of a command\n\t// to run if no command names are passed as CLI arguments.\n\tDefaultCommand string `json:\"defaultCommand\"`\n\t// The category the command is part of\n\tCategory string `json:\"category\"`\n\t// List of child commands\n\tCommands []*Command `json:\"commands\"`\n\t// List of flags to parse\n\tFlags []Flag `json:\"flags\"`\n\t// Boolean to hide built-in help command and help flag\n\tHideHelp bool `json:\"hideHelp\"`\n\t// Ignored if HideHelp is true.\n\tHideHelpCommand bool `json:\"hideHelpCommand\"`\n\t// Boolean to hide built-in version flag and the VERSION section of help\n\tHideVersion bool `json:\"hideVersion\"`\n\t// Boolean to enable shell completion commands\n\tEnableShellCompletion bool `json:\"-\"`\n\t// Shell Completion generation command name\n\tShellCompletionCommandName string `json:\"-\"`\n\t// The function to call when checking for shell command completions\n\tShellComplete ShellCompleteFunc `json:\"-\"`\n\t// An action to execute before any subcommands are run, but after the context is ready\n\t// If a non-nil error is returned, no subcommands are run\n\tBefore BeforeFunc `json:\"-\"`\n\t// An action to execute after any subcommands are run, but after the subcommand has finished\n\t// It is run even if Action() panics\n\tAfter AfterFunc `json:\"-\"`\n\t// The function to call when this command is invoked\n\tAction ActionFunc `json:\"-\"`\n\t// Execute this function if the proper command cannot be found\n\tCommandNotFound CommandNotFoundFunc `json:\"-\"`\n\t// Execute this function if a usage error occurs.\n\tOnUsageError OnUsageErrorFunc `json:\"-\"`\n\t// Execute this function when an invalid flag is accessed from the context\n\tInvalidFlagAccessHandler InvalidFlagAccessFunc `json:\"-\"`\n\t// Boolean to hide this command from help or completion\n\tHidden bool `json:\"hidden\"`\n\t// List of all authors who contributed (string or fmt.Stringer)\n\t// TODO: ~string | fmt.Stringer when interface unions are available\n\tAuthors []any `json:\"authors\"`\n\t// Copyright of the binary if any\n\tCopyright string `json:\"copyright\"`\n\t// Reader reader to write input to (useful for tests)\n\tReader io.Reader `json:\"-\"`\n\t// Writer writer to write output to\n\tWriter io.Writer `json:\"-\"`\n\t// ErrWriter writes error output\n\tErrWriter io.Writer `json:\"-\"`\n\t// ExitErrHandler processes any error encountered while running an App before\n\t// it is returned to the caller. If no function is provided, HandleExitCoder\n\t// is used as the default behavior.\n\tExitErrHandler ExitErrHandlerFunc `json:\"-\"`\n\t// Other custom info\n\tMetadata map[string]interface{} `json:\"metadata\"`\n\t// Carries a function which returns app specific info.\n\tExtraInfo func() map[string]string `json:\"-\"`\n\t// CustomRootCommandHelpTemplate the text template for app help topic.\n\t// cli.go uses text/template to render templates. You can\n\t// render custom help text by setting this variable.\n\tCustomRootCommandHelpTemplate string `json:\"-\"`\n\t// SliceFlagSeparator is used to customize the separator for SliceFlag, the default is \",\"\n\tSliceFlagSeparator string `json:\"sliceFlagSeparator\"`\n\t// DisableSliceFlagSeparator is used to disable SliceFlagSeparator, the default is false\n\tDisableSliceFlagSeparator bool `json:\"disableSliceFlagSeparator\"`\n\t// Boolean to enable short-option handling so user can combine several\n\t// single-character bool arguments into one\n\t// i.e. foobar -o -v -> foobar -ov\n\tUseShortOptionHandling bool `json:\"useShortOptionHandling\"`\n\t// Enable suggestions for commands and flags\n\tSuggest bool `json:\"suggest\"`\n\t// Allows global flags set by libraries which use flag.XXXVar(...) directly\n\t// to be parsed through this library\n\tAllowExtFlags bool `json:\"allowExtFlags\"`\n\t// Treat all flags as normal arguments if true\n\tSkipFlagParsing bool `json:\"skipFlagParsing\"`\n\t// CustomHelpTemplate the text template for the command help topic.\n\t// cli.go uses text/template to render templates. You can\n\t// render custom help text by setting this variable.\n\tCustomHelpTemplate string `json:\"-\"`\n\t// Use longest prefix match for commands\n\tPrefixMatchCommands bool `json:\"prefixMatchCommands\"`\n\t// Custom suggest command for matching\n\tSuggestCommandFunc SuggestCommandFunc `json:\"-\"`\n\t// Flag exclusion group\n\tMutuallyExclusiveFlags []MutuallyExclusiveFlags `json:\"mutuallyExclusiveFlags\"`\n\t// Arguments to parse for this command\n\tArguments []Argument `json:\"arguments\"`\n\t// Whether to read arguments from stdin\n\t// applicable to root command only\n\tReadArgsFromStdin bool `json:\"readArgsFromStdin\"`\n\n\t// Has unexported fields.\n}\n    Command contains everything needed to run an application that accepts a\n    string slice of arguments such as os.Args. A given Command may contain Flags\n    and sub-commands in Commands.\n\nfunc (cmd *Command) Args() Args\n    Args returns the command line arguments associated with the command.\n\nfunc (cmd *Command) Bool(name string) bool\n\nfunc (cmd *Command) Command(name string) *Command\n\nfunc (cmd *Command) Count(name string) int\n    Count returns the num of occurrences of this flag\n\nfunc (cmd *Command) Duration(name string) time.Duration\n\nfunc (cmd *Command) FlagNames() []string\n    FlagNames returns a slice of flag names used by the this command and all of\n    its parent commands.\n\nfunc (cmd *Command) Float(name string) float64\n    Float looks up the value of a local FloatFlag, returns 0 if not found\n\nfunc (cmd *Command) FloatSlice(name string) []float64\n    FloatSlice looks up the value of a local FloatSliceFlag, returns nil if not\n    found\n\nfunc (cmd *Command) FullName() string\n    FullName returns the full name of the command. For commands with parents\n    this ensures that the parent commands are part of the command path.\n\nfunc (cmd *Command) Generic(name string) Value\n    Generic looks up the value of a local GenericFlag, returns nil if not found\n\nfunc (cmd *Command) HasName(name string) bool\n    HasName returns true if Command.Name matches given name\n\nfunc (cmd *Command) Int(name string) int64\n    Int looks up the value of a local Int64Flag, returns 0 if not found\n\nfunc (cmd *Command) IntSlice(name string) []int64\n    IntSlice looks up the value of a local IntSliceFlag, returns nil if not\n    found\n\nfunc (cmd *Command) IsSet(name string) bool\n    IsSet determines if the flag was actually set\n\nfunc (cmd *Command) Lineage() []*Command\n    Lineage returns *this* command and all of its ancestor commands in order\n    from child to parent\n\nfunc (cmd *Command) LocalFlagNames() []string\n    LocalFlagNames returns a slice of flag names used in this command.\n\nfunc (cmd *Command) NArg() int\n    NArg returns the number of the command line arguments.\n\nfunc (cmd *Command) Names() []string\n    Names returns the names including short names and aliases.\n\nfunc (cmd *Command) NumFlags() int\n    NumFlags returns the number of flags set\n\nfunc (cmd *Command) Root() *Command\n    Root returns the Command at the root of the graph\n\nfunc (cmd *Command) Run(ctx context.Context, osArgs []string) (deferErr error)\n    Run is the entry point to the command graph. The positional arguments are\n    parsed according to the Flag and Command definitions and the matching Action\n    functions are run.\n\nfunc (cmd *Command) Set(name, value string) error\n    Set sets a context flag to a value.\n\nfunc (cmd *Command) String(name string) string\n\nfunc (cmd *Command) StringMap(name string) map[string]string\n    StringMap looks up the value of a local StringMapFlag, returns nil if not\n    found\n\nfunc (cmd *Command) StringSlice(name string) []string\n    StringSlice looks up the value of a local StringSliceFlag, returns nil if\n    not found\n\nfunc (cmd *Command) Timestamp(name string) time.Time\n    Timestamp gets the timestamp from a flag name\n\nfunc (cmd *Command) ToFishCompletion() (string, error)\n    ToFishCompletion creates a fish completion string for the `*App` The\n    function errors if either parsing or writing of the string fails.\n\nfunc (cmd *Command) Uint(name string) uint64\n    Uint looks up the value of a local Uint64Flag, returns 0 if not found\n\nfunc (cmd *Command) UintSlice(name string) []uint64\n    UintSlice looks up the value of a local UintSliceFlag, returns nil if not\n    found\n\nfunc (cmd *Command) Value(name string) interface{}\n    Value returns the value of the flag corresponding to `name`\n\nfunc (cmd *Command) VisibleCategories() []CommandCategory\n    VisibleCategories returns a slice of categories and commands that are\n    Hidden=false\n\nfunc (cmd *Command) VisibleCommands() []*Command\n    VisibleCommands returns a slice of the Commands with Hidden=false\n\nfunc (cmd *Command) VisibleFlagCategories() []VisibleFlagCategory\n    VisibleFlagCategories returns a slice containing all the visible flag\n    categories with the flags they contain\n\nfunc (cmd *Command) VisibleFlags() []Flag\n    VisibleFlags returns a slice of the Flags with Hidden=false\n\nfunc (cmd *Command) VisiblePersistentFlags() []Flag\n    VisiblePersistentFlags returns a slice of LocalFlag with Persistent=true and\n    Hidden=false.\n\ntype CommandCategories interface {\n\t// AddCommand adds a command to a category, creating a new category if necessary.\n\tAddCommand(category string, command *Command)\n\t// Categories returns a slice of categories sorted by name\n\tCategories() []CommandCategory\n}\n    CommandCategories interface allows for category manipulation\n\ntype CommandCategory interface {\n\t// Name returns the category name string\n\tName() string\n\t// VisibleCommands returns a slice of the Commands with Hidden=false\n\tVisibleCommands() []*Command\n}\n    CommandCategory is a category containing commands.\n\ntype CommandNotFoundFunc func(context.Context, *Command, string)\n    CommandNotFoundFunc is executed if the proper command cannot be found\n\ntype Countable interface {\n\tCount() int\n}\n    Countable is an interface to enable detection of flag values which support\n    repetitive flags\n\ntype DocGenerationFlag interface {\n\t// TakesValue returns true if the flag takes a value, otherwise false\n\tTakesValue() bool\n\n\t// GetUsage returns the usage string for the flag\n\tGetUsage() string\n\n\t// GetValue returns the flags value as string representation and an empty\n\t// string if the flag takes no value at all.\n\tGetValue() string\n\n\t// GetDefaultText returns the default text for this flag\n\tGetDefaultText() string\n\n\t// GetEnvVars returns the env vars for this flag\n\tGetEnvVars() []string\n\n\t// IsDefaultVisible returns whether the default value should be shown in\n\t// help text\n\tIsDefaultVisible() bool\n}\n    DocGenerationFlag is an interface that allows documentation generation for\n    the flag\n\ntype DocGenerationMultiValueFlag interface {\n\tDocGenerationFlag\n\n\t// IsMultiValueFlag returns true for flags that can be given multiple times.\n\tIsMultiValueFlag() bool\n}\n    DocGenerationMultiValueFlag extends DocGenerationFlag for slice/map based\n    flags.\n\ntype DurationFlag = FlagBase[time.Duration, NoConfig, durationValue]\n\ntype EnvValueSource interface {\n\tIsFromEnv() bool\n\tKey() string\n}\n    EnvValueSource is to specifically detect env sources when printing help text\n\ntype ErrorFormatter interface {\n\tFormat(s fmt.State, verb rune)\n}\n    ErrorFormatter is the interface that will suitably format the error output\n\ntype ExitCoder interface {\n\terror\n\tExitCode() int\n}\n    ExitCoder is the interface checked by `App` and `Command` for a custom exit\n    code\n\nfunc Exit(message interface{}, exitCode int) ExitCoder\n    Exit wraps a message and exit code into an error, which by default is\n    handled with a call to os.Exit during default error handling.\n\n    This is the simplest way to trigger a non-zero exit code for an App\n    without having to call os.Exit manually. During testing, this behavior\n    can be avoided by overriding the ExitErrHandler function on an App or the\n    package-global OsExiter function.\n\ntype ExitErrHandlerFunc func(context.Context, *Command, error)\n    ExitErrHandlerFunc is executed if provided in order to handle exitError\n    values returned by Actions and Before/After functions.\n\ntype Flag interface {\n\tfmt.Stringer\n\n\t// Apply Flag settings to the given flag set\n\tApply(*flag.FlagSet) error\n\n\t// All possible names for this flag\n\tNames() []string\n\n\t// Whether the flag has been set or not\n\tIsSet() bool\n}\n    Flag is a common interface related to parsing flags in cli. For more\n    advanced flag parsing techniques, it is recommended that this interface be\n    implemented.\n\nvar GenerateShellCompletionFlag Flag = &BoolFlag{\n\tName:   \"generate-shell-completion\",\n\tHidden: true,\n}\n    GenerateShellCompletionFlag enables shell completion\n\nvar HelpFlag Flag = &BoolFlag{\n\tName:        \"help\",\n\tAliases:     []string{\"h\"},\n\tUsage:       \"show help\",\n\tHideDefault: true,\n\tLocal:       true,\n}\n    HelpFlag prints the help for all commands and subcommands. Set to nil to\n    disable the flag. The subcommand will still be added unless HideHelp or\n    HideHelpCommand is set to true.\n\nvar VersionFlag Flag = &BoolFlag{\n\tName:        \"version\",\n\tAliases:     []string{\"v\"},\n\tUsage:       \"print the version\",\n\tHideDefault: true,\n\tLocal:       true,\n}\n    VersionFlag prints the version for the application\n\ntype FlagBase[T any, C any, VC ValueCreator[T, C]] struct {\n\tName             string                                   `json:\"name\"`             // name of the flag\n\tCategory         string                                   `json:\"category\"`         // category of the flag, if any\n\tDefaultText      string                                   `json:\"defaultText\"`      // default text of the flag for usage purposes\n\tHideDefault      bool                                     `json:\"hideDefault\"`      // whether to hide the default value in output\n\tUsage            string                                   `json:\"usage\"`            // usage string for help output\n\tSources          ValueSourceChain                         `json:\"-\"`                // sources to load flag value from\n\tRequired         bool                                     `json:\"required\"`         // whether the flag is required or not\n\tHidden           bool                                     `json:\"hidden\"`           // whether to hide the flag in help output\n\tLocal            bool                                     `json:\"local\"`            // whether the flag needs to be applied to subcommands as well\n\tValue            T                                        `json:\"defaultValue\"`     // default value for this flag if not set by from any source\n\tDestination      *T                                       `json:\"-\"`                // destination pointer for value when set\n\tAliases          []string                                 `json:\"aliases\"`          // Aliases that are allowed for this flag\n\tTakesFile        bool                                     `json:\"takesFileArg\"`     // whether this flag takes a file argument, mainly for shell completion purposes\n\tAction           func(context.Context, *Command, T) error `json:\"-\"`                // Action callback to be called when flag is set\n\tConfig           C                                        `json:\"config\"`           // Additional/Custom configuration associated with this flag type\n\tOnlyOnce         bool                                     `json:\"onlyOnce\"`         // whether this flag can be duplicated on the command line\n\tValidator        func(T) error                            `json:\"-\"`                // custom function to validate this flag value\n\tValidateDefaults bool                                     `json:\"validateDefaults\"` // whether to validate defaults or not\n\n\t// Has unexported fields.\n}\n    FlagBase [T,C,VC] is a generic flag base which can be used as a boilerplate\n    to implement the most common interfaces used by urfave/cli.\n\n        T specifies the type\n        C specifies the configuration required(if any for that flag type)\n        VC specifies the value creator which creates the flag.Value emulation\n\nfunc (f *FlagBase[T, C, V]) Apply(set *flag.FlagSet) error\n    Apply populates the flag given the flag set and environment\n\nfunc (f *FlagBase[T, C, V]) GetCategory() string\n    GetCategory returns the category of the flag\n\nfunc (f *FlagBase[T, C, V]) GetDefaultText() string\n    GetDefaultText returns the default text for this flag\n\nfunc (f *FlagBase[T, C, V]) GetEnvVars() []string\n    GetEnvVars returns the env vars for this flag\n\nfunc (f *FlagBase[T, C, V]) GetUsage() string\n    GetUsage returns the usage string for the flag\n\nfunc (f *FlagBase[T, C, V]) GetValue() string\n    GetValue returns the flags value as string representation and an empty\n    string if the flag takes no value at all.\n\nfunc (f *FlagBase[T, C, V]) IsDefaultVisible() bool\n    IsDefaultVisible returns true if the flag is not hidden, otherwise false\n\nfunc (f *FlagBase[T, C, VC]) IsLocal() bool\n    IsLocal returns false if flag needs to be persistent across subcommands\n\nfunc (f *FlagBase[T, C, VC]) IsMultiValueFlag() bool\n    IsMultiValueFlag returns true if the value type T can take multiple values\n    from cmd line. This is true for slice and map type flags\n\nfunc (f *FlagBase[T, C, V]) IsRequired() bool\n    IsRequired returns whether or not the flag is required\n\nfunc (f *FlagBase[T, C, V]) IsSet() bool\n    IsSet returns whether or not the flag has been set through env or file\n\nfunc (f *FlagBase[T, C, V]) IsVisible() bool\n    IsVisible returns true if the flag is not hidden, otherwise false\n\nfunc (f *FlagBase[T, C, V]) Names() []string\n    Names returns the names of the flag\n\nfunc (f *FlagBase[T, C, V]) RunAction(ctx context.Context, cmd *Command) error\n    RunAction executes flag action if set\n\nfunc (f *FlagBase[T, C, V]) SetCategory(c string)\n\nfunc (f *FlagBase[T, C, V]) String() string\n    String returns a readable representation of this value (for usage defaults)\n\nfunc (f *FlagBase[T, C, V]) TakesValue() bool\n    TakesValue returns true if the flag takes a value, otherwise false\n\ntype FlagCategories interface {\n\t// AddFlags adds a flag to a category, creating a new category if necessary.\n\tAddFlag(category string, fl Flag)\n\t// VisibleCategories returns a slice of visible flag categories sorted by name\n\tVisibleCategories() []VisibleFlagCategory\n}\n    FlagCategories interface allows for category manipulation\n\ntype FlagEnvHintFunc func(envVars []string, str string) string\n    FlagEnvHintFunc is used by the default FlagStringFunc to annotate flag help\n    with the environment variable details.\n\nvar FlagEnvHinter FlagEnvHintFunc = withEnvHint\n    FlagEnvHinter annotates flag help message with the environment variable\n    details. This is used by the default FlagStringer.\n\ntype FlagFileHintFunc func(filePath, str string) string\n    FlagFileHintFunc is used by the default FlagStringFunc to annotate flag help\n    with the file path details.\n\nvar FlagFileHinter FlagFileHintFunc = withFileHint\n    FlagFileHinter annotates flag help message with the environment variable\n    details. This is used by the default FlagStringer.\n\ntype FlagNamePrefixFunc func(fullName []string, placeholder string) string\n    FlagNamePrefixFunc is used by the default FlagStringFunc to create prefix\n    text for a flag's full name.\n\nvar FlagNamePrefixer FlagNamePrefixFunc = prefixedNames\n    FlagNamePrefixer converts a full flag name and its placeholder into the help\n    message flag prefix. This is used by the default FlagStringer.\n\ntype FlagStringFunc func(Flag) string\n    FlagStringFunc is used by the help generation to display a flag, which is\n    expected to be a single line.\n\nvar FlagStringer FlagStringFunc = stringifyFlag\n    FlagStringer converts a flag definition to a string. This is used by help to\n    display a flag.\n\ntype FlagsByName []Flag\n    FlagsByName is a slice of Flag.\n\nfunc (f FlagsByName) Len() int\n\nfunc (f FlagsByName) Less(i, j int) bool\n\nfunc (f FlagsByName) Swap(i, j int)\n\ntype FloatArg = ArgumentBase[float64, NoConfig, floatValue]\n\ntype FloatFlag = FlagBase[float64, NoConfig, floatValue]\n\ntype FloatSlice = SliceBase[float64, NoConfig, floatValue]\n\ntype FloatSliceFlag = FlagBase[[]float64, NoConfig, FloatSlice]\n\ntype GenericFlag = FlagBase[Value, NoConfig, genericValue]\n\ntype IntArg = ArgumentBase[int64, IntegerConfig, intValue]\n\ntype IntFlag = FlagBase[int64, IntegerConfig, intValue]\n\ntype IntSlice = SliceBase[int64, IntegerConfig, intValue]\n\ntype IntSliceFlag = FlagBase[[]int64, IntegerConfig, IntSlice]\n\ntype IntegerConfig struct {\n\tBase int\n}\n    IntegerConfig is the configuration for all integer type flags\n\ntype InvalidFlagAccessFunc func(context.Context, *Command, string)\n    InvalidFlagAccessFunc is executed when an invalid flag is accessed from the\n    context.\n\ntype LocalFlag interface {\n\tIsLocal() bool\n}\n    LocalFlag is an interface to enable detection of flags which are local to\n    current command\n\ntype MapBase[T any, C any, VC ValueCreator[T, C]] struct {\n\t// Has unexported fields.\n}\n    MapBase wraps map[string]T to satisfy flag.Value\n\nfunc NewMapBase[T any, C any, VC ValueCreator[T, C]](defaults map[string]T) *MapBase[T, C, VC]\n    NewMapBase makes a *MapBase with default values\n\nfunc (i MapBase[T, C, VC]) Create(val map[string]T, p *map[string]T, c C) Value\n\nfunc (i *MapBase[T, C, VC]) Get() interface{}\n    Get returns the mapping of values set by this flag\n\nfunc (i *MapBase[T, C, VC]) Serialize() string\n    Serialize allows MapBase to fulfill Serializer\n\nfunc (i *MapBase[T, C, VC]) Set(value string) error\n    Set parses the value and appends it to the list of values\n\nfunc (i *MapBase[T, C, VC]) String() string\n    String returns a readable representation of this value (for usage defaults)\n\nfunc (i MapBase[T, C, VC]) ToString(t map[string]T) string\n\nfunc (i *MapBase[T, C, VC]) Value() map[string]T\n    Value returns the mapping of values set by this flag\n\ntype MapSource interface {\n\tfmt.Stringer\n\tfmt.GoStringer\n\n\t// Lookup returns the value from the source based on key\n\t// and if it was found\n\t// or returns an empty string and false\n\tLookup(string) (any, bool)\n}\n    MapSource is a source which can be used to look up a value based on a key\n    typically for use with a cli.Flag\n\nfunc NewMapSource(name string, m map[any]any) MapSource\n\ntype MultiError interface {\n\terror\n\tErrors() []error\n}\n    MultiError is an error that wraps multiple errors.\n\ntype MutuallyExclusiveFlags struct {\n\t// Flag list\n\tFlags [][]Flag\n\n\t// whether this group is required\n\tRequired bool\n\n\t// Category to apply to all flags within group\n\tCategory string\n}\n    MutuallyExclusiveFlags defines a mutually exclusive flag group Multiple\n    option paths can be provided out of which only one can be defined on cmdline\n    So for example [ --foo | [ --bar something --darth somethingelse ] ]\n\ntype NoConfig struct{}\n    NoConfig is for flags which dont need a custom configuration\n\ntype OnUsageErrorFunc func(ctx context.Context, cmd *Command, err error, isSubcommand bool) error\n    OnUsageErrorFunc is executed if a usage error occurs. This is useful for\n    displaying customized usage error messages. This function is able to replace\n    the original error messages. If this function is not set, the \"Incorrect\n    usage\" is displayed and the execution is interrupted.\n\ntype RequiredFlag interface {\n\t// whether the flag is a required flag or not\n\tIsRequired() bool\n}\n    RequiredFlag is an interface that allows us to mark flags as required\n    it allows flags required flags to be backwards compatible with the Flag\n    interface\n\ntype Serializer interface {\n\tSerialize() string\n}\n    Serializer is used to circumvent the limitations of flag.FlagSet.Set\n\ntype ShellCompleteFunc func(context.Context, *Command)\n    ShellCompleteFunc is an action to execute when the shell completion flag is\n    set\n\ntype SliceBase[T any, C any, VC ValueCreator[T, C]] struct {\n\t// Has unexported fields.\n}\n    SliceBase wraps []T to satisfy flag.Value\n\nfunc NewSliceBase[T any, C any, VC ValueCreator[T, C]](defaults ...T) *SliceBase[T, C, VC]\n    NewSliceBase makes a *SliceBase with default values\n\nfunc (i SliceBase[T, C, VC]) Create(val []T, p *[]T, c C) Value\n\nfunc (i *SliceBase[T, C, VC]) Get() interface{}\n    Get returns the slice of values set by this flag\n\nfunc (i *SliceBase[T, C, VC]) Serialize() string\n    Serialize allows SliceBase to fulfill Serializer\n\nfunc (i *SliceBase[T, C, VC]) Set(value string) error\n    Set parses the value and appends it to the list of values\n\nfunc (i *SliceBase[T, C, VC]) String() string\n    String returns a readable representation of this value (for usage defaults)\n\nfunc (i SliceBase[T, C, VC]) ToString(t []T) string\n\nfunc (i *SliceBase[T, C, VC]) Value() []T\n    Value returns the slice of values set by this flag\n\ntype StringArg = ArgumentBase[string, StringConfig, stringValue]\n\ntype StringConfig struct {\n\t// Whether to trim whitespace of parsed value\n\tTrimSpace bool\n}\n    StringConfig defines the configuration for string flags\n\ntype StringFlag = FlagBase[string, StringConfig, stringValue]\n\ntype StringMap = MapBase[string, StringConfig, stringValue]\n\ntype StringMapArg = ArgumentBase[map[string]string, StringConfig, StringMap]\n\ntype StringMapFlag = FlagBase[map[string]string, StringConfig, StringMap]\n\ntype StringSlice = SliceBase[string, StringConfig, stringValue]\n\ntype StringSliceFlag = FlagBase[[]string, StringConfig, StringSlice]\n\ntype SuggestCommandFunc func(commands []*Command, provided string) string\n\ntype SuggestFlagFunc func(flags []Flag, provided string, hideHelp bool) string\n\ntype TimestampArg = ArgumentBase[time.Time, TimestampConfig, timestampValue]\n\ntype TimestampConfig struct {\n\tTimezone *time.Location\n\t// Available layouts for flag value.\n\t//\n\t// Note that value for formats with missing year/date will be interpreted as current year/date respectively.\n\t//\n\t// Read more about time layouts: https://pkg.go.dev/time#pkg-constants\n\tLayouts []string\n}\n    TimestampConfig defines the config for timestamp flags\n\ntype TimestampFlag = FlagBase[time.Time, TimestampConfig, timestampValue]\n\ntype UintArg = ArgumentBase[uint64, IntegerConfig, uintValue]\n\ntype UintFlag = FlagBase[uint64, IntegerConfig, uintValue]\n\ntype UintSlice = SliceBase[uint64, IntegerConfig, uintValue]\n\ntype UintSliceFlag = FlagBase[[]uint64, IntegerConfig, UintSlice]\n\ntype Value interface {\n\tflag.Value\n\tflag.Getter\n}\n    Value represents a value as used by cli. For now it implements the golang\n    flag.Value interface\n\ntype ValueCreator[T any, C any] interface {\n\tCreate(T, *T, C) Value\n\tToString(T) string\n}\n    ValueCreator is responsible for creating a flag.Value emulation as well as\n    custom formatting\n\n        T specifies the type\n        C specifies the config for the type\n\ntype ValueSource interface {\n\tfmt.Stringer\n\tfmt.GoStringer\n\n\t// Lookup returns the value from the source and if it was found\n\t// or returns an empty string and false\n\tLookup() (string, bool)\n}\n    ValueSource is a source which can be used to look up a value, typically for\n    use with a cli.Flag\n\nfunc EnvVar(key string) ValueSource\n\nfunc File(path string) ValueSource\n\nfunc NewMapValueSource(key string, ms MapSource) ValueSource\n\ntype ValueSourceChain struct {\n\tChain []ValueSource\n}\n    ValueSourceChain contains an ordered series of ValueSource that allows for\n    lookup where the first ValueSource to resolve is returned\n\nfunc EnvVars(keys ...string) ValueSourceChain\n    EnvVars is a helper function to encapsulate a number of envVarValueSource\n    together as a ValueSourceChain\n\nfunc Files(paths ...string) ValueSourceChain\n    Files is a helper function to encapsulate a number of fileValueSource\n    together as a ValueSourceChain\n\nfunc NewValueSourceChain(src ...ValueSource) ValueSourceChain\n\nfunc (vsc *ValueSourceChain) Append(other ValueSourceChain)\n\nfunc (vsc *ValueSourceChain) EnvKeys() []string\n\nfunc (vsc *ValueSourceChain) GoString() string\n\nfunc (vsc *ValueSourceChain) Lookup() (string, bool)\n\nfunc (vsc *ValueSourceChain) LookupWithSource() (string, ValueSource, bool)\n\nfunc (vsc *ValueSourceChain) String() string\n\ntype VisibleFlag interface {\n\t// IsVisible returns true if the flag is not hidden, otherwise false\n\tIsVisible() bool\n}\n    VisibleFlag is an interface that allows to check if a flag is visible\n\ntype VisibleFlagCategory interface {\n\t// Name returns the category name string\n\tName() string\n\t// Flags returns a slice of VisibleFlag sorted by name\n\tFlags() []Flag\n}\n    VisibleFlagCategory is a category containing flags.\n\n"
        },
        {
          "name": "help.go",
          "type": "blob",
          "size": 15.7109375,
          "content": "package cli\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"text/tabwriter\"\n\t\"text/template\"\n\t\"unicode/utf8\"\n)\n\nconst (\n\thelpName  = \"help\"\n\thelpAlias = \"h\"\n)\n\n// Prints help for the App or Command\ntype helpPrinter func(w io.Writer, templ string, data interface{})\n\n// Prints help for the App or Command with custom template function.\ntype helpPrinterCustom func(w io.Writer, templ string, data interface{}, customFunc map[string]interface{})\n\n// HelpPrinter is a function that writes the help output. If not set explicitly,\n// this calls HelpPrinterCustom using only the default template functions.\n//\n// If custom logic for printing help is required, this function can be\n// overridden. If the ExtraInfo field is defined on an App, this function\n// should not be modified, as HelpPrinterCustom will be used directly in order\n// to capture the extra information.\nvar HelpPrinter helpPrinter = printHelp\n\n// HelpPrinterCustom is a function that writes the help output. It is used as\n// the default implementation of HelpPrinter, and may be called directly if\n// the ExtraInfo field is set on an App.\n//\n// In the default implementation, if the customFuncs argument contains a\n// \"wrapAt\" key, which is a function which takes no arguments and returns\n// an int, this int value will be used to produce a \"wrap\" function used\n// by the default template to wrap long lines.\nvar HelpPrinterCustom helpPrinterCustom = printHelpCustom\n\n// VersionPrinter prints the version for the App\nvar VersionPrinter = printVersion\n\nfunc buildHelpCommand(withAction bool) *Command {\n\tcmd := &Command{\n\t\tName:      helpName,\n\t\tAliases:   []string{helpAlias},\n\t\tUsage:     \"Shows a list of commands or help for one command\",\n\t\tArgsUsage: \"[command]\",\n\t\tHideHelp:  true,\n\t}\n\n\tif withAction {\n\t\tcmd.Action = helpCommandAction\n\t}\n\n\treturn cmd\n}\n\nfunc helpCommandAction(ctx context.Context, cmd *Command) error {\n\targs := cmd.Args()\n\tfirstArg := args.First()\n\n\ttracef(\"doing help for cmd %[1]q with args %[2]q\", cmd, args)\n\n\t// This action can be triggered by a \"default\" action of a command\n\t// or via cmd.Run when cmd == helpCmd. So we have following possibilities\n\t//\n\t// 1 $ app\n\t// 2 $ app help\n\t// 3 $ app foo\n\t// 4 $ app help foo\n\t// 5 $ app foo help\n\n\t// Case 4. when executing a help command set the context to parent\n\t// to allow resolution of subsequent args. This will transform\n\t// $ app help foo\n\t//     to\n\t// $ app foo\n\t// which will then be handled as case 3\n\tif cmd.parent != nil && (cmd.HasName(helpName) || cmd.HasName(helpAlias)) {\n\t\ttracef(\"setting cmd to cmd.parent\")\n\t\tcmd = cmd.parent\n\t}\n\n\t// Case 4. $ app help foo\n\t// foo is the command for which help needs to be shown\n\tif firstArg != \"\" {\n\t\tif firstArg == \"--\" {\n\t\t\treturn nil\n\t\t}\n\t\ttracef(\"returning ShowCommandHelp with %[1]q\", firstArg)\n\t\treturn ShowCommandHelp(ctx, cmd, firstArg)\n\t}\n\n\t// Case 1 & 2\n\t// Special case when running help on main app itself as opposed to individual\n\t// commands/subcommands\n\tif cmd.parent == nil {\n\t\ttracef(\"returning ShowAppHelp\")\n\t\t_ = ShowAppHelp(cmd)\n\t\treturn nil\n\t}\n\n\t// Case 3, 5\n\tif (len(cmd.Commands) == 1 && !cmd.HideHelp) ||\n\t\t(len(cmd.Commands) == 0 && cmd.HideHelp) {\n\n\t\ttmpl := cmd.CustomHelpTemplate\n\t\tif tmpl == \"\" {\n\t\t\ttmpl = CommandHelpTemplate\n\t\t}\n\n\t\ttracef(\"running HelpPrinter with command %[1]q\", cmd.Name)\n\t\tHelpPrinter(cmd.Root().Writer, tmpl, cmd)\n\n\t\treturn nil\n\t}\n\n\ttracef(\"running ShowSubcommandHelp\")\n\treturn ShowSubcommandHelp(cmd)\n}\n\n// ShowAppHelpAndExit - Prints the list of subcommands for the app and exits with exit code.\nfunc ShowAppHelpAndExit(cmd *Command, exitCode int) {\n\t_ = ShowAppHelp(cmd)\n\tos.Exit(exitCode)\n}\n\n// ShowAppHelp is an action that displays the help.\nfunc ShowAppHelp(cmd *Command) error {\n\ttmpl := cmd.CustomRootCommandHelpTemplate\n\tif tmpl == \"\" {\n\t\ttracef(\"using RootCommandHelpTemplate\")\n\t\ttmpl = RootCommandHelpTemplate\n\t}\n\n\tif cmd.ExtraInfo == nil {\n\t\tHelpPrinter(cmd.Root().Writer, tmpl, cmd.Root())\n\t\treturn nil\n\t}\n\n\ttracef(\"setting ExtraInfo in customAppData\")\n\tcustomAppData := func() map[string]any {\n\t\treturn map[string]any{\n\t\t\t\"ExtraInfo\": cmd.ExtraInfo,\n\t\t}\n\t}\n\tHelpPrinterCustom(cmd.Root().Writer, tmpl, cmd.Root(), customAppData())\n\n\treturn nil\n}\n\n// DefaultAppComplete prints the list of subcommands as the default app completion method\nfunc DefaultAppComplete(ctx context.Context, cmd *Command) {\n\tDefaultCompleteWithFlags(ctx, cmd)\n}\n\nfunc printCommandSuggestions(commands []*Command, writer io.Writer) {\n\tfor _, command := range commands {\n\t\tif command.Hidden {\n\t\t\tcontinue\n\t\t}\n\t\tif strings.HasSuffix(os.Getenv(\"SHELL\"), \"zsh\") {\n\t\t\t_, _ = fmt.Fprintf(writer, \"%s:%s\\n\", command.Name, command.Usage)\n\t\t} else {\n\t\t\t_, _ = fmt.Fprintf(writer, \"%s\\n\", command.Name)\n\t\t}\n\t}\n}\n\nfunc cliArgContains(flagName string, args []string) bool {\n\tfor _, name := range strings.Split(flagName, \",\") {\n\t\tname = strings.TrimSpace(name)\n\t\tcount := utf8.RuneCountInString(name)\n\t\tif count > 2 {\n\t\t\tcount = 2\n\t\t}\n\t\tflag := fmt.Sprintf(\"%s%s\", strings.Repeat(\"-\", count), name)\n\t\tfor _, a := range args {\n\t\t\tif a == flag {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc printFlagSuggestions(lastArg string, flags []Flag, writer io.Writer) {\n\t// Trim to handle both \"-short\" and \"--long\" flags.\n\tcur := strings.TrimLeft(lastArg, \"-\")\n\tfor _, flag := range flags {\n\t\tif bflag, ok := flag.(*BoolFlag); ok && bflag.Hidden {\n\t\t\tcontinue\n\t\t}\n\n\t\tusage := \"\"\n\t\tif docFlag, ok := flag.(DocGenerationFlag); ok {\n\t\t\tusage = docFlag.GetUsage()\n\t\t}\n\n\t\tname := strings.TrimSpace(flag.Names()[0])\n\t\t// this will get total count utf8 letters in flag name\n\t\tcount := utf8.RuneCountInString(name)\n\t\tif count > 2 {\n\t\t\tcount = 2 // reuse this count to generate single - or -- in flag completion\n\t\t}\n\t\t// if flag name has more than one utf8 letter and last argument in cli has -- prefix then\n\t\t// skip flag completion for short flags example -v or -x\n\t\tif strings.HasPrefix(lastArg, \"--\") && count == 1 {\n\t\t\tcontinue\n\t\t}\n\t\t// match if last argument matches this flag and it is not repeated\n\t\tif strings.HasPrefix(name, cur) && cur != name && !cliArgContains(name, os.Args) {\n\t\t\tflagCompletion := fmt.Sprintf(\"%s%s\", strings.Repeat(\"-\", count), name)\n\t\t\tif usage != \"\" && strings.HasSuffix(os.Getenv(\"SHELL\"), \"zsh\") {\n\t\t\t\tflagCompletion = fmt.Sprintf(\"%s:%s\", flagCompletion, usage)\n\t\t\t}\n\t\t\tfmt.Fprintln(writer, flagCompletion)\n\t\t}\n\t}\n}\n\nfunc DefaultCompleteWithFlags(ctx context.Context, cmd *Command) {\n\targs := os.Args\n\tif cmd != nil && cmd.flagSet != nil && cmd.parent != nil {\n\t\targs = cmd.Args().Slice()\n\t\ttracef(\"running default complete with flags[%v] on command %[2]q\", args, cmd.Name)\n\t} else {\n\t\ttracef(\"running default complete with os.Args flags[%v]\", args)\n\t}\n\targsLen := len(args)\n\tlastArg := \"\"\n\t// parent command will have --generate-shell-completion so we need\n\t// to account for that\n\tif argsLen > 1 {\n\t\tlastArg = args[argsLen-2]\n\t} else if argsLen > 0 {\n\t\tlastArg = args[argsLen-1]\n\t}\n\n\tif lastArg == \"--\" {\n\t\ttracef(\"not printing flag suggestion as last arg is --\")\n\t\treturn\n\t}\n\n\tif strings.HasPrefix(lastArg, \"-\") {\n\t\ttracef(\"printing flag suggestion for flag[%v] on command %[1]q\", lastArg, cmd.Name)\n\t\tprintFlagSuggestions(lastArg, cmd.Flags, cmd.Root().Writer)\n\t\treturn\n\t}\n\n\tif cmd != nil {\n\t\ttracef(\"printing command suggestions on command %[1]q\", cmd.Name)\n\t\tprintCommandSuggestions(cmd.Commands, cmd.Root().Writer)\n\t\treturn\n\t}\n}\n\n// ShowCommandHelpAndExit - exits with code after showing help\nfunc ShowCommandHelpAndExit(ctx context.Context, cmd *Command, command string, code int) {\n\t_ = ShowCommandHelp(ctx, cmd, command)\n\tos.Exit(code)\n}\n\n// ShowCommandHelp prints help for the given command\nfunc ShowCommandHelp(ctx context.Context, cmd *Command, commandName string) error {\n\tfor _, subCmd := range cmd.Commands {\n\t\tif !subCmd.HasName(commandName) {\n\t\t\tcontinue\n\t\t}\n\n\t\ttmpl := subCmd.CustomHelpTemplate\n\t\tif tmpl == \"\" {\n\t\t\tif len(subCmd.Commands) == 0 {\n\t\t\t\ttracef(\"using CommandHelpTemplate\")\n\t\t\t\ttmpl = CommandHelpTemplate\n\t\t\t} else {\n\t\t\t\ttracef(\"using SubcommandHelpTemplate\")\n\t\t\t\ttmpl = SubcommandHelpTemplate\n\t\t\t}\n\t\t}\n\n\t\ttracef(\"running HelpPrinter\")\n\t\tHelpPrinter(cmd.Root().Writer, tmpl, subCmd)\n\n\t\ttracef(\"returning nil after printing help\")\n\t\treturn nil\n\t}\n\n\ttracef(\"no matching command found\")\n\n\tif cmd.CommandNotFound == nil {\n\t\terrMsg := fmt.Sprintf(\"No help topic for '%v'\", commandName)\n\n\t\tif cmd.Suggest {\n\t\t\tif suggestion := SuggestCommand(cmd.Commands, commandName); suggestion != \"\" {\n\t\t\t\terrMsg += \". \" + suggestion\n\t\t\t}\n\t\t}\n\n\t\ttracef(\"exiting 3 with errMsg %[1]q\", errMsg)\n\t\treturn Exit(errMsg, 3)\n\t}\n\n\ttracef(\"running CommandNotFound func for %[1]q\", commandName)\n\tcmd.CommandNotFound(ctx, cmd, commandName)\n\n\treturn nil\n}\n\n// ShowSubcommandHelpAndExit - Prints help for the given subcommand and exits with exit code.\nfunc ShowSubcommandHelpAndExit(cmd *Command, exitCode int) {\n\t_ = ShowSubcommandHelp(cmd)\n\tos.Exit(exitCode)\n}\n\n// ShowSubcommandHelp prints help for the given subcommand\nfunc ShowSubcommandHelp(cmd *Command) error {\n\tHelpPrinter(cmd.Root().Writer, SubcommandHelpTemplate, cmd)\n\treturn nil\n}\n\n// ShowVersion prints the version number of the App\nfunc ShowVersion(cmd *Command) {\n\ttracef(\"showing version via VersionPrinter (cmd=%[1]q)\", cmd.Name)\n\tVersionPrinter(cmd)\n}\n\nfunc printVersion(cmd *Command) {\n\t_, _ = fmt.Fprintf(cmd.Root().Writer, \"%v version %v\\n\", cmd.Name, cmd.Version)\n}\n\nfunc handleTemplateError(err error) {\n\tif err != nil {\n\t\ttracef(\"error encountered during template parse: %[1]v\", err)\n\t\t// If the writer is closed, t.Execute will fail, and there's nothing\n\t\t// we can do to recover.\n\t\tif os.Getenv(\"CLI_TEMPLATE_ERROR_DEBUG\") != \"\" {\n\t\t\t_, _ = fmt.Fprintf(ErrWriter, \"CLI TEMPLATE ERROR: %#v\\n\", err)\n\t\t}\n\t\treturn\n\t}\n}\n\n// printHelpCustom is the default implementation of HelpPrinterCustom.\n//\n// The customFuncs map will be combined with a default template.FuncMap to\n// allow using arbitrary functions in template rendering.\nfunc printHelpCustom(out io.Writer, templ string, data interface{}, customFuncs map[string]interface{}) {\n\tconst maxLineLength = 10000\n\n\ttracef(\"building default funcMap\")\n\tfuncMap := template.FuncMap{\n\t\t\"join\":           strings.Join,\n\t\t\"subtract\":       subtract,\n\t\t\"indent\":         indent,\n\t\t\"nindent\":        nindent,\n\t\t\"trim\":           strings.TrimSpace,\n\t\t\"wrap\":           func(input string, offset int) string { return wrap(input, offset, maxLineLength) },\n\t\t\"offset\":         offset,\n\t\t\"offsetCommands\": offsetCommands,\n\t}\n\n\tif wa, ok := customFuncs[\"wrapAt\"]; ok {\n\t\tif wrapAtFunc, ok := wa.(func() int); ok {\n\t\t\twrapAt := wrapAtFunc()\n\t\t\tcustomFuncs[\"wrap\"] = func(input string, offset int) string {\n\t\t\t\treturn wrap(input, offset, wrapAt)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor key, value := range customFuncs {\n\t\tfuncMap[key] = value\n\t}\n\n\tw := tabwriter.NewWriter(out, 1, 8, 2, ' ', 0)\n\tt := template.Must(template.New(\"help\").Funcs(funcMap).Parse(templ))\n\n\tif _, err := t.New(\"helpNameTemplate\").Parse(helpNameTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"argsTemplate\").Parse(argsTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"usageTemplate\").Parse(usageTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"descriptionTemplate\").Parse(descriptionTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"visibleCommandTemplate\").Parse(visibleCommandTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"copyrightTemplate\").Parse(copyrightTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"versionTemplate\").Parse(versionTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"visibleFlagCategoryTemplate\").Parse(visibleFlagCategoryTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"visibleFlagTemplate\").Parse(visibleFlagTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"visiblePersistentFlagTemplate\").Parse(visiblePersistentFlagTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"visibleGlobalFlagCategoryTemplate\").Parse(strings.Replace(visibleFlagCategoryTemplate, \"OPTIONS\", \"GLOBAL OPTIONS\", -1)); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"authorsTemplate\").Parse(authorsTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\tif _, err := t.New(\"visibleCommandCategoryTemplate\").Parse(visibleCommandCategoryTemplate); err != nil {\n\t\thandleTemplateError(err)\n\t}\n\n\ttracef(\"executing template\")\n\thandleTemplateError(t.Execute(w, data))\n\n\t_ = w.Flush()\n}\n\nfunc printHelp(out io.Writer, templ string, data interface{}) {\n\tHelpPrinterCustom(out, templ, data, nil)\n}\n\nfunc checkVersion(cmd *Command) bool {\n\tfound := false\n\tfor _, name := range VersionFlag.Names() {\n\t\tif cmd.Bool(name) {\n\t\t\tfound = true\n\t\t}\n\t}\n\treturn found\n}\n\nfunc checkShellCompleteFlag(c *Command, arguments []string) (bool, []string) {\n\tif (c.parent == nil && !c.EnableShellCompletion) || (c.parent != nil && !c.Root().shellCompletion) {\n\t\treturn false, arguments\n\t}\n\n\tpos := len(arguments) - 1\n\tlastArg := arguments[pos]\n\n\tif lastArg != completionFlag {\n\t\treturn false, arguments\n\t}\n\n\tfor _, arg := range arguments {\n\t\t// If arguments include \"--\", shell completion is disabled\n\t\t// because after \"--\" only positional arguments are accepted.\n\t\t// https://unix.stackexchange.com/a/11382\n\t\tif arg == \"--\" {\n\t\t\treturn false, arguments[:pos]\n\t\t}\n\t}\n\n\treturn true, arguments[:pos]\n}\n\nfunc checkCompletions(ctx context.Context, cmd *Command) bool {\n\ttracef(\"checking completions on command %[1]q\", cmd.Name)\n\n\tif !cmd.Root().shellCompletion {\n\t\ttracef(\"completion not enabled skipping %[1]q\", cmd.Name)\n\t\treturn false\n\t}\n\n\tif argsArguments := cmd.Args(); argsArguments.Present() {\n\t\tname := argsArguments.First()\n\t\tif cmd := cmd.Command(name); cmd != nil {\n\t\t\t// let the command handle the completion\n\t\t\treturn false\n\t\t}\n\t}\n\n\ttracef(\"no subcommand found for completiot %[1]q\", cmd.Name)\n\n\tif cmd.ShellComplete != nil {\n\t\ttracef(\"running shell completion func for command %[1]q\", cmd.Name)\n\t\tcmd.ShellComplete(ctx, cmd)\n\t}\n\n\treturn true\n}\n\nfunc subtract(a, b int) int {\n\treturn a - b\n}\n\nfunc indent(spaces int, v string) string {\n\tpad := strings.Repeat(\" \", spaces)\n\treturn pad + strings.Replace(v, \"\\n\", \"\\n\"+pad, -1)\n}\n\nfunc nindent(spaces int, v string) string {\n\treturn \"\\n\" + indent(spaces, v)\n}\n\nfunc wrap(input string, offset int, wrapAt int) string {\n\tvar ss []string\n\n\tlines := strings.Split(input, \"\\n\")\n\n\tpadding := strings.Repeat(\" \", offset)\n\n\tfor i, line := range lines {\n\t\tif line == \"\" {\n\t\t\tss = append(ss, line)\n\t\t} else {\n\t\t\twrapped := wrapLine(line, offset, wrapAt, padding)\n\t\t\tif i == 0 {\n\t\t\t\tss = append(ss, wrapped)\n\t\t\t} else {\n\t\t\t\tss = append(ss, padding+wrapped)\n\t\t\t}\n\n\t\t}\n\t}\n\n\treturn strings.Join(ss, \"\\n\")\n}\n\nfunc wrapLine(input string, offset int, wrapAt int, padding string) string {\n\tif wrapAt <= offset || len(input) <= wrapAt-offset {\n\t\treturn input\n\t}\n\n\tlineWidth := wrapAt - offset\n\twords := strings.Fields(input)\n\tif len(words) == 0 {\n\t\treturn input\n\t}\n\n\twrapped := words[0]\n\tspaceLeft := lineWidth - len(wrapped)\n\tfor _, word := range words[1:] {\n\t\tif len(word)+1 > spaceLeft {\n\t\t\twrapped += \"\\n\" + padding + word\n\t\t\tspaceLeft = lineWidth - len(word)\n\t\t} else {\n\t\t\twrapped += \" \" + word\n\t\t\tspaceLeft -= 1 + len(word)\n\t\t}\n\t}\n\n\treturn wrapped\n}\n\nfunc offset(input string, fixed int) int {\n\treturn len(input) + fixed\n}\n\n// this function tries to find the max width of the names column\n// so say we have the following rows for help\n//\n//\tfoo1, foo2, foo3  some string here\n//\tbar1, b2 some other string here\n//\n// We want to offset the 2nd row usage by some amount so that everything\n// is aligned\n//\n//\tfoo1, foo2, foo3  some string here\n//\tbar1, b2          some other string here\n//\n// to find that offset we find the length of all the rows and use the max\n// to calculate the offset\nfunc offsetCommands(cmds []*Command, fixed int) int {\n\tmax := 0\n\tfor _, cmd := range cmds {\n\t\ts := strings.Join(cmd.Names(), \", \")\n\t\tif len(s) > max {\n\t\t\tmax = len(s)\n\t\t}\n\t}\n\treturn max + fixed\n}\n"
        },
        {
          "name": "help_test.go",
          "type": "blob",
          "size": 44.638671875,
          "content": "package cli\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc Test_ShowAppHelp_NoAuthor(t *testing.T) {\n\toutput := new(bytes.Buffer)\n\tcmd := &Command{Writer: output}\n\t_ = ShowAppHelp(cmd)\n\n\tif bytes.Contains(output.Bytes(), []byte(\"AUTHOR(S):\")) {\n\t\tt.Errorf(\"expected\\n%snot to include %s\", output.String(), \"AUTHOR(S):\")\n\t}\n}\n\nfunc Test_ShowAppHelp_NoVersion(t *testing.T) {\n\toutput := new(bytes.Buffer)\n\tcmd := &Command{Writer: output}\n\n\tcmd.Version = \"\"\n\n\t_ = ShowAppHelp(cmd)\n\n\tif bytes.Contains(output.Bytes(), []byte(\"VERSION:\")) {\n\t\tt.Errorf(\"expected\\n%snot to include %s\", output.String(), \"VERSION:\")\n\t}\n}\n\nfunc Test_ShowAppHelp_HideVersion(t *testing.T) {\n\toutput := new(bytes.Buffer)\n\tcmd := &Command{Writer: output}\n\n\tcmd.HideVersion = true\n\n\t_ = ShowAppHelp(cmd)\n\n\tif bytes.Contains(output.Bytes(), []byte(\"VERSION:\")) {\n\t\tt.Errorf(\"expected\\n%snot to include %s\", output.String(), \"VERSION:\")\n\t}\n}\n\nfunc Test_ShowAppHelp_MultiLineDescription(t *testing.T) {\n\toutput := new(bytes.Buffer)\n\tcmd := &Command{Writer: output}\n\n\tcmd.HideVersion = true\n\tcmd.Description = \"multi\\n  line\"\n\n\t_ = ShowAppHelp(cmd)\n\n\tif !bytes.Contains(output.Bytes(), []byte(\"DESCRIPTION:\\n   multi\\n     line\")) {\n\t\tt.Errorf(\"expected\\n%s\\nto include\\n%s\", output.String(), \"DESCRIPTION:\\n   multi\\n     line\")\n\t}\n}\n\nfunc Test_Help_RequiredFlagsNoDefault(t *testing.T) {\n\toutput := new(bytes.Buffer)\n\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&IntFlag{Name: \"foo\", Aliases: []string{\"f\"}, Required: true},\n\t\t},\n\t\tArguments: AnyArguments,\n\t\tWriter:    output,\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"test\", \"-h\"})\n\n\texpected := `NAME:\n   test - A new cli application\n\nUSAGE:\n   test [global options] [arguments...]\n\nGLOBAL OPTIONS:\n   --foo value, -f value  \n   --help, -h             show help\n`\n\n\tassert.Contains(t, output.String(), expected,\n\t\t\"expected output to include usage text\")\n}\n\nfunc Test_Help_Custom_Flags(t *testing.T) {\n\toldFlag := HelpFlag\n\tdefer func() {\n\t\tHelpFlag = oldFlag\n\t}()\n\n\tHelpFlag = &BoolFlag{\n\t\tName:    \"help\",\n\t\tAliases: []string{\"x\"},\n\t\tUsage:   \"show help\",\n\t}\n\n\tout := &bytes.Buffer{}\n\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{Name: \"foo\", Aliases: []string{\"h\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.True(t, cmd.Bool(\"h\"), \"custom help flag not set\")\n\t\t\treturn nil\n\t\t},\n\t\tWriter: out,\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"test\", \"-h\"})\n\trequire.Len(t, out.String(), 0)\n}\n\nfunc Test_Help_Nil_Flags(t *testing.T) {\n\toldFlag := HelpFlag\n\tdefer func() {\n\t\tHelpFlag = oldFlag\n\t}()\n\tHelpFlag = nil\n\n\tcmd := &Command{\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\treturn nil\n\t\t},\n\t}\n\tout := new(bytes.Buffer)\n\tcmd.Writer = out\n\t_ = cmd.Run(buildTestContext(t), []string{\"test\"})\n\trequire.Len(t, out.String(), 0)\n}\n\nfunc Test_Version_Custom_Flags(t *testing.T) {\n\toldFlag := VersionFlag\n\tdefer func() {\n\t\tVersionFlag = oldFlag\n\t}()\n\n\tVersionFlag = &BoolFlag{\n\t\tName:    \"version\",\n\t\tAliases: []string{\"V\"},\n\t\tUsage:   \"show version\",\n\t}\n\n\tout := &bytes.Buffer{}\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{Name: \"foo\", Aliases: []string{\"v\"}},\n\t\t},\n\t\tAction: func(_ context.Context, cmd *Command) error {\n\t\t\tassert.True(t, cmd.Bool(\"v\"), \"custom version flag not set\")\n\t\t\treturn nil\n\t\t},\n\t\tWriter: out,\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"test\", \"-v\"})\n\trequire.Len(t, out.String(), 0)\n}\n\nfunc Test_helpCommand_Action_ErrorIfNoTopic(t *testing.T) {\n\tcmd := &Command{\n\t\tflagSet: flag.NewFlagSet(\"test\", 0),\n\t}\n\n\t_ = cmd.Run(context.Background(), []string{\"foo\", \"bar\"})\n\n\terr := helpCommandAction(context.Background(), cmd)\n\trequire.Error(t, err, \"expected error from helpCommandAction()\")\n\n\texitErr, ok := err.(*exitError)\n\trequire.True(t, ok, \"expected *exitError from helpCommandAction()\")\n\n\trequire.Contains(t, exitErr.Error(), \"No help topic for\", \"expected an unknown help topic error\")\n\trequire.Equal(t, 3, exitErr.exitCode, \"expected exit value = 3\")\n}\n\nfunc Test_helpCommand_InHelpOutput(t *testing.T) {\n\tcmd := &Command{}\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"test\", \"--help\"})\n\n\ts := output.String()\n\n\trequire.NotContains(t, s, \"\\nCOMMANDS:\\nGLOBAL OPTIONS:\\n\", \"empty COMMANDS section detected\")\n\trequire.Contains(t, s, \"--help, -h\", \"missing \\\"--help, --h\\\"\")\n}\n\nfunc TestHelpCommand_FullName(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\targs     []string\n\t\tcontains string\n\t\tskip     bool\n\t}{\n\t\t{\n\t\t\tname:     \"app help's FullName\",\n\t\t\targs:     []string{\"app\", \"help\", \"help\"},\n\t\t\tcontains: \"app help -\",\n\t\t},\n\t\t{\n\t\t\tname:     \"app help's FullName via flag\",\n\t\t\targs:     []string{\"app\", \"-h\", \"help\"},\n\t\t\tcontains: \"app help -\",\n\t\t},\n\t\t{\n\t\t\tname:     \"cmd help's FullName\",\n\t\t\targs:     []string{\"app\", \"cmd\", \"help\", \"help\"},\n\t\t\tcontains: \"app cmd help -\",\n\t\t\tskip:     true, // FIXME: App Command collapse\n\t\t},\n\t\t{\n\t\t\tname:     \"cmd help's FullName via flag\",\n\t\t\targs:     []string{\"app\", \"cmd\", \"-h\", \"help\"},\n\t\t\tcontains: \"app cmd help -\",\n\t\t\tskip:     true, // FIXME: App Command collapse\n\t\t},\n\t\t{\n\t\t\tname:     \"subcmd help's FullName\",\n\t\t\targs:     []string{\"app\", \"cmd\", \"subcmd\", \"help\", \"help\"},\n\t\t\tcontains: \"app cmd subcmd help -\",\n\t\t},\n\t\t{\n\t\t\tname:     \"subcmd help's FullName via flag\",\n\t\t\targs:     []string{\"app\", \"cmd\", \"subcmd\", \"-h\", \"help\"},\n\t\t\tcontains: \"app cmd subcmd help -\",\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tout := &bytes.Buffer{}\n\n\t\t\tif tc.skip {\n\t\t\t\tt.SkipNow()\n\t\t\t}\n\n\t\t\tcmd := &Command{\n\t\t\t\tName: \"app\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\t\tCommands: []*Command{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName: \"subcmd\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tWriter:    out,\n\t\t\t\tErrWriter: out,\n\t\t\t}\n\n\t\t\tr := require.New(t)\n\t\t\tr.NoError(cmd.Run(buildTestContext(t), tc.args))\n\t\t\tr.Contains(out.String(), tc.contains)\n\t\t})\n\t}\n}\n\nfunc Test_helpCommand_HideHelpCommand(t *testing.T) {\n\tbuf := &bytes.Buffer{}\n\tcmd := &Command{\n\t\tName:   \"app\",\n\t\tWriter: buf,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"app\", \"help\", \"help\"})\n\tassert.NoError(t, err)\n\tgot := buf.String()\n\tnotWant := \"COMMANDS:\"\n\tassert.NotContains(t, got, notWant)\n}\n\nfunc Test_helpCommand_HideHelpFlag(t *testing.T) {\n\tapp := buildMinimalTestCommand()\n\n\tassert.Error(t, app.Run(buildTestContext(t), []string{\"app\", \"help\", \"-h\"}), \"Expected flag error - Got nil\")\n}\n\nfunc Test_helpSubcommand_Action_ErrorIfNoTopic(t *testing.T) {\n\tcmd := &Command{\n\t\tflagSet: flag.NewFlagSet(\"test\", 0),\n\t}\n\t_ = cmd.Run(context.Background(), []string{\"foo\", \"bar\"})\n\n\terr := helpCommandAction(context.Background(), cmd)\n\trequire.Error(t, err, \"expected error from helpCommandAction(), but got nil\")\n\n\texitErr, ok := err.(*exitError)\n\trequire.True(t, ok, \"expected *exitError from helpCommandAction(), but instead got: %v\", err.Error())\n\n\trequire.Contains(t, exitErr.Error(), \"No help topic for\", \"expected an unknown help topic error\")\n\trequire.Equal(t, 3, exitErr.exitCode, \"unexpected exit value\")\n}\n\nfunc TestShowAppHelp_CommandAliases(t *testing.T) {\n\tout := &bytes.Buffer{}\n\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:    \"frobbly\",\n\t\t\t\tAliases: []string{\"fr\", \"frob\"},\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tWriter: out,\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"--help\"})\n\trequire.Contains(t, out.String(), \"frobbly, fr, frob\")\n}\n\nfunc TestShowCommandHelp_AppendHelp(t *testing.T) {\n\ttestCases := []struct {\n\t\tname            string\n\t\thideHelp        bool\n\t\thideHelpCommand bool\n\t\targs            []string\n\t\tverify          func(*testing.T, string)\n\t}{\n\t\t{\n\t\t\tname:     \"with HideHelp\",\n\t\t\thideHelp: true,\n\t\t\targs:     []string{\"app\", \"help\"},\n\t\t\tverify: func(t *testing.T, outString string) {\n\t\t\t\tr := require.New(t)\n\t\t\t\tr.NotContains(outString, \"help, h  Shows a list of commands or help for one command\")\n\t\t\t\tr.NotContains(outString, \"--help, -h  show help\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:            \"with HideHelpCommand\",\n\t\t\thideHelpCommand: true,\n\t\t\targs:            []string{\"app\", \"--help\"},\n\t\t\tverify: func(t *testing.T, outString string) {\n\t\t\t\tr := require.New(t)\n\t\t\t\tr.NotContains(outString, \"help, h  Shows a list of commands or help for one command\")\n\t\t\t\tr.Contains(outString, \"--help, -h  show help\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"with Subcommand\",\n\t\t\targs: []string{\"app\", \"cmd\", \"help\"},\n\t\t\tverify: func(t *testing.T, outString string) {\n\t\t\t\tr := require.New(t)\n\t\t\t\tr.Contains(outString, \"--help, -h  show help\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"without Subcommand\",\n\t\t\targs: []string{\"app\", \"help\"},\n\t\t\tverify: func(t *testing.T, outString string) {\n\t\t\t\tr := require.New(t)\n\t\t\t\tr.Contains(outString, \"help, h  Shows a list of commands or help for one command\")\n\t\t\t\tr.Contains(outString, \"--help, -h  show help\")\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tout := &bytes.Buffer{}\n\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tcmd := &Command{\n\t\t\t\tName:            \"app\",\n\t\t\t\tHideHelp:        tc.hideHelp,\n\t\t\t\tHideHelpCommand: tc.hideHelpCommand,\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:            \"cmd\",\n\t\t\t\t\t\tHideHelp:        tc.hideHelp,\n\t\t\t\t\t\tHideHelpCommand: tc.hideHelpCommand,\n\t\t\t\t\t\tCommands:        []*Command{{Name: \"subcmd\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tWriter:    out,\n\t\t\t\tErrWriter: out,\n\t\t\t}\n\n\t\t\t_ = cmd.Run(buildTestContext(t), tc.args)\n\t\t\ttc.verify(t, out.String())\n\t\t})\n\t}\n}\n\nfunc TestShowCommandHelp_HelpPrinter(t *testing.T) {\n\t/*doublecho := func(text string) string {\n\t\treturn text + \" \" + text\n\t}*/\n\n\ttests := []struct {\n\t\tname         string\n\t\ttemplate     string\n\t\tprinter      helpPrinter\n\t\tcommand      string\n\t\twantTemplate string\n\t\twantOutput   string\n\t}{\n\t\t{\n\t\t\tname:     \"no-command\",\n\t\t\ttemplate: \"\",\n\t\t\tprinter: func(w io.Writer, _ string, _ interface{}) {\n\t\t\t\tfmt.Fprint(w, \"yo\")\n\t\t\t},\n\t\t\tcommand:      \"\",\n\t\t\twantTemplate: RootCommandHelpTemplate,\n\t\t\twantOutput:   \"yo\",\n\t\t},\n\t\t/*{\n\t\t\tname:     \"standard-command\",\n\t\t\ttemplate: \"\",\n\t\t\tprinter: func(w io.Writer, templ string, data interface{}) {\n\t\t\t\tfmt.Fprint(w, \"yo\")\n\t\t\t},\n\t\t\tcommand:      \"my-command\",\n\t\t\twantTemplate: CommandHelpTemplate,\n\t\t\twantOutput:   \"yo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"custom-template-command\",\n\t\t\ttemplate: \"{{doublecho .Name}}\",\n\t\t\tprinter: func(w io.Writer, templ string, data interface{}) {\n\t\t\t\t// Pass a custom function to ensure it gets used\n\t\t\t\tfm := map[string]interface{}{\"doublecho\": doublecho}\n\t\t\t\tHelpPrinterCustom(w, templ, data, fm)\n\t\t\t},\n\t\t\tcommand:      \"my-command\",\n\t\t\twantTemplate: \"{{doublecho .Name}}\",\n\t\t\twantOutput:   \"my-command my-command\",\n\t\t},*/\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func(old helpPrinter) {\n\t\t\t\tHelpPrinter = old\n\t\t\t}(HelpPrinter)\n\t\t\tHelpPrinter = func(w io.Writer, templ string, data interface{}) {\n\t\t\t\tassert.Equal(t, tt.wantTemplate, templ, \"template mismatch\")\n\t\t\t\ttt.printer(w, templ, data)\n\t\t\t}\n\n\t\t\tvar buf bytes.Buffer\n\t\t\tcmd := &Command{\n\t\t\t\tName:   \"my-app\",\n\t\t\t\tWriter: &buf,\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:               \"my-command\",\n\t\t\t\t\t\tCustomHelpTemplate: tt.template,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), []string{\"my-app\", \"help\", tt.command})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tgot := buf.String()\n\t\t\tassert.Equal(t, tt.wantOutput, got)\n\t\t})\n\t}\n}\n\nfunc TestShowCommandHelp_HelpPrinterCustom(t *testing.T) {\n\tdoublecho := func(text string) string {\n\t\treturn text + \" \" + text\n\t}\n\n\ttestCases := []struct {\n\t\tname         string\n\t\ttemplate     string\n\t\tprinter      helpPrinterCustom\n\t\targuments    []string\n\t\twantTemplate string\n\t\twantOutput   string\n\t}{\n\t\t{\n\t\t\tname: \"no command\",\n\t\t\tprinter: func(w io.Writer, _ string, _ any, _ map[string]any) {\n\t\t\t\tfmt.Fprint(w, \"yo\")\n\t\t\t},\n\t\t\targuments:    []string{\"my-app\", \"help\"},\n\t\t\twantTemplate: RootCommandHelpTemplate,\n\t\t\twantOutput:   \"yo\",\n\t\t},\n\t\t{\n\t\t\tname: \"standard command\",\n\t\t\tprinter: func(w io.Writer, _ string, _ any, _ map[string]any) {\n\t\t\t\tfmt.Fprint(w, \"yo\")\n\t\t\t},\n\t\t\targuments:    []string{\"my-app\", \"help\", \"my-command\"},\n\t\t\twantTemplate: SubcommandHelpTemplate,\n\t\t\twantOutput:   \"yo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"custom template command\",\n\t\t\ttemplate: \"{{doublecho .Name}}\",\n\t\t\tprinter: func(w io.Writer, templ string, data any, _ map[string]any) {\n\t\t\t\t// Pass a custom function to ensure it gets used\n\t\t\t\tfm := map[string]any{\"doublecho\": doublecho}\n\t\t\t\tprintHelpCustom(w, templ, data, fm)\n\t\t\t},\n\t\t\targuments:    []string{\"my-app\", \"help\", \"my-command\"},\n\t\t\twantTemplate: \"{{doublecho .Name}}\",\n\t\t\twantOutput:   \"my-command my-command\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tr := require.New(t)\n\n\t\t\tdefer func(old helpPrinterCustom) {\n\t\t\t\tHelpPrinterCustom = old\n\t\t\t}(HelpPrinterCustom)\n\n\t\t\tHelpPrinterCustom = func(w io.Writer, tmpl string, data any, fm map[string]any) {\n\t\t\t\tr.Nil(fm)\n\t\t\t\tr.Equal(tc.wantTemplate, tmpl)\n\n\t\t\t\ttc.printer(w, tmpl, data, fm)\n\t\t\t}\n\n\t\t\tout := &bytes.Buffer{}\n\t\t\tcmd := &Command{\n\t\t\t\tName:   \"my-app\",\n\t\t\t\tWriter: out,\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:               \"my-command\",\n\t\t\t\t\t\tCustomHelpTemplate: tc.template,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tt.Logf(\"cmd.Run(ctx, %+[1]v)\", tc.arguments)\n\n\t\t\tr.NoError(cmd.Run(buildTestContext(t), tc.arguments))\n\t\t\tr.Equal(tc.wantOutput, out.String())\n\t\t})\n\t}\n}\n\nfunc TestShowCommandHelp_CommandAliases(t *testing.T) {\n\tout := &bytes.Buffer{}\n\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:    \"frobbly\",\n\t\t\t\tAliases: []string{\"fr\", \"frob\", \"bork\"},\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tWriter: out,\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"help\", \"fr\"})\n\trequire.Contains(t, out.String(), \"frobbly\")\n}\n\nfunc TestShowSubcommandHelp_CommandAliases(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:    \"frobbly\",\n\t\t\t\tAliases: []string{\"fr\", \"frob\", \"bork\"},\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"help\"})\n\n\tassert.Contains(t, output.String(), \"frobbly, fr, frob, bork\", \"expected output to include all command aliases\")\n}\n\nfunc TestShowCommandHelp_Customtemplate(t *testing.T) {\n\tcmd := &Command{\n\t\tName: \"foo\",\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tCustomHelpTemplate: `NAME:\n   {{.FullName}} - {{.Usage}}\n\nUSAGE:\n   {{.FullName}} [FLAGS] TARGET [TARGET ...]\n\nFLAGS:\n  {{range .VisibleFlags}}{{.}}\n  {{end}}\nEXAMPLES:\n   1. Frobbly runs with this param locally.\n      $ {{.FullName}} wobbly\n`,\n\t\t\t},\n\t\t},\n\t}\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"help\", \"frobbly\"})\n\n\tassert.NotContains(t, output.String(), \"2. Frobbly runs without this param locally.\",\n\t\t\"expected output to exclude \\\"2. Frobbly runs without this param locally.\\\";\")\n\n\tassert.Contains(t, output.String(), \"1. Frobbly runs with this param locally.\",\n\t\t\"expected output to include \\\"1. Frobbly runs with this param locally.\\\"\")\n\n\tassert.Contains(t, output.String(), \"$ foo frobbly wobbly\",\n\t\t\"expected output to include \\\"$ foo frobbly wobbly\\\"\")\n}\n\nfunc TestShowSubcommandHelp_CommandUsageText(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:      \"frobbly\",\n\t\t\t\tUsageText: \"this is usage text\",\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"frobbly\", \"--help\"})\n\n\tassert.Contains(t, output.String(), \"this is usage text\",\n\t\t\"expected output to include usage text\")\n}\n\nfunc TestShowSubcommandHelp_MultiLine_CommandUsageText(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t\tUsageText: `This is a\nmulti\nline\nUsageText`,\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"frobbly\", \"--help\"})\n\n\texpected := `USAGE:\n   This is a\n   multi\n   line\n   UsageText\n`\n\n\tassert.Contains(t, output.String(), expected,\n\t\t\"expected output to include usage text\")\n}\n\nfunc TestShowSubcommandHelp_GlobalOptions(t *testing.T) {\n\tcmd := &Command{\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName: \"foo\",\n\t\t\t},\n\t\t},\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\tName:  \"bar\",\n\t\t\t\t\t\tLocal: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"frobbly\", \"--help\"})\n\n\texpected := `NAME:\n   foo frobbly\n\nUSAGE:\n   foo frobbly [command [command options]]\n\nOPTIONS:\n   --bar value  \n   --help, -h   show help\n\nGLOBAL OPTIONS:\n   --foo value  \n`\n\n\tassert.Contains(t, output.String(), expected, \"expected output to include global options\")\n}\n\nfunc TestShowSubcommandHelp_SubcommandUsageText(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:      \"bobbly\",\n\t\t\t\t\t\tUsageText: \"this is usage text\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"frobbly\", \"bobbly\", \"--help\"})\n\n\tassert.Contains(t, output.String(), \"this is usage text\",\n\t\t\"expected output to include usage text\")\n}\n\nfunc TestShowSubcommandHelp_MultiLine_SubcommandUsageText(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"bobbly\",\n\t\t\t\t\t\tUsageText: `This is a\nmulti\nline\nUsageText`,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"frobbly\", \"bobbly\", \"--help\"})\n\n\texpected := `USAGE:\n   This is a\n   multi\n   line\n   UsageText\n`\n\n\tassert.Contains(t, output.String(), expected,\n\t\t\"expected output to include usage text\")\n}\n\nfunc TestShowAppHelp_HiddenCommand(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"secretfrob\",\n\t\t\t\tHidden: true,\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"app\", \"--help\"})\n\n\tassert.NotContains(t, output.String(), \"secretfrob\",\n\t\t\"expected output to exclude \\\"secretfrob\\\"\")\n\n\tassert.Contains(t, output.String(), \"frobbly\",\n\t\t\"expected output to include \\\"frobbly\\\"\")\n}\n\nfunc TestShowAppHelp_HelpPrinter(t *testing.T) {\n\tdoublecho := func(text string) string {\n\t\treturn text + \" \" + text\n\t}\n\n\ttests := []struct {\n\t\tname         string\n\t\ttemplate     string\n\t\tprinter      helpPrinter\n\t\twantTemplate string\n\t\twantOutput   string\n\t}{\n\t\t{\n\t\t\tname:     \"standard-command\",\n\t\t\ttemplate: \"\",\n\t\t\tprinter: func(w io.Writer, _ string, _ interface{}) {\n\t\t\t\tfmt.Fprint(w, \"yo\")\n\t\t\t},\n\t\t\twantTemplate: RootCommandHelpTemplate,\n\t\t\twantOutput:   \"yo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"custom-template-command\",\n\t\t\ttemplate: \"{{doublecho .Name}}\",\n\t\t\tprinter: func(w io.Writer, templ string, data interface{}) {\n\t\t\t\t// Pass a custom function to ensure it gets used\n\t\t\t\tfm := map[string]interface{}{\"doublecho\": doublecho}\n\t\t\t\tprintHelpCustom(w, templ, data, fm)\n\t\t\t},\n\t\t\twantTemplate: \"{{doublecho .Name}}\",\n\t\t\twantOutput:   \"my-app my-app\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func(old helpPrinter) {\n\t\t\t\tHelpPrinter = old\n\t\t\t}(HelpPrinter)\n\t\t\tHelpPrinter = func(w io.Writer, templ string, data interface{}) {\n\t\t\t\tassert.Equal(t, tt.wantTemplate, templ, \"unexpected template\")\n\t\t\t\ttt.printer(w, templ, data)\n\t\t\t}\n\n\t\t\tvar buf bytes.Buffer\n\t\t\tcmd := &Command{\n\t\t\t\tName:                          \"my-app\",\n\t\t\t\tWriter:                        &buf,\n\t\t\t\tCustomRootCommandHelpTemplate: tt.template,\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), []string{\"my-app\", \"help\"})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Equal(t, tt.wantOutput, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestShowAppHelp_HelpPrinterCustom(t *testing.T) {\n\tdoublecho := func(text string) string {\n\t\treturn text + \" \" + text\n\t}\n\n\ttests := []struct {\n\t\tname         string\n\t\ttemplate     string\n\t\tprinter      helpPrinterCustom\n\t\twantTemplate string\n\t\twantOutput   string\n\t}{\n\t\t{\n\t\t\tname:     \"standard-command\",\n\t\t\ttemplate: \"\",\n\t\t\tprinter: func(w io.Writer, _ string, _ interface{}, _ map[string]interface{}) {\n\t\t\t\tfmt.Fprint(w, \"yo\")\n\t\t\t},\n\t\t\twantTemplate: RootCommandHelpTemplate,\n\t\t\twantOutput:   \"yo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"custom-template-command\",\n\t\t\ttemplate: \"{{doublecho .Name}}\",\n\t\t\tprinter: func(w io.Writer, templ string, data interface{}, _ map[string]interface{}) {\n\t\t\t\t// Pass a custom function to ensure it gets used\n\t\t\t\tfm := map[string]interface{}{\"doublecho\": doublecho}\n\t\t\t\tprintHelpCustom(w, templ, data, fm)\n\t\t\t},\n\t\t\twantTemplate: \"{{doublecho .Name}}\",\n\t\t\twantOutput:   \"my-app my-app\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tdefer func(old helpPrinterCustom) {\n\t\t\t\tHelpPrinterCustom = old\n\t\t\t}(HelpPrinterCustom)\n\t\t\tHelpPrinterCustom = func(w io.Writer, templ string, data interface{}, fm map[string]interface{}) {\n\t\t\t\tassert.Nil(t, fm, \"unexpected function map passed\")\n\t\t\t\tassert.Equal(t, tt.wantTemplate, templ, \"unexpected template\")\n\t\t\t\ttt.printer(w, templ, data, fm)\n\t\t\t}\n\n\t\t\tvar buf bytes.Buffer\n\t\t\tcmd := &Command{\n\t\t\t\tName:                          \"my-app\",\n\t\t\t\tWriter:                        &buf,\n\t\t\t\tCustomRootCommandHelpTemplate: tt.template,\n\t\t\t}\n\n\t\t\terr := cmd.Run(buildTestContext(t), []string{\"my-app\", \"help\"})\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, tt.wantOutput, buf.String())\n\t\t})\n\t}\n}\n\nfunc TestShowAppHelp_CustomAppTemplate(t *testing.T) {\n\tcmd := &Command{\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:   \"secretfrob\",\n\t\t\t\tHidden: true,\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tExtraInfo: func() map[string]string {\n\t\t\tplatform := fmt.Sprintf(\"OS: %s | Arch: %s\", runtime.GOOS, runtime.GOARCH)\n\t\t\tgoruntime := fmt.Sprintf(\"Version: %s | CPUs: %d\", runtime.Version(), runtime.NumCPU())\n\t\t\treturn map[string]string{\n\t\t\t\t\"PLATFORM\": platform,\n\t\t\t\t\"RUNTIME\":  goruntime,\n\t\t\t}\n\t\t},\n\t\tCustomRootCommandHelpTemplate: `NAME:\n  {{.Name}} - {{.Usage}}\n\nUSAGE:\n  {{.Name}} {{if .VisibleFlags}}[FLAGS] {{end}}COMMAND{{if .VisibleFlags}} [COMMAND FLAGS | -h]{{end}} [ARGUMENTS...]\n\nCOMMANDS:\n  {{range .VisibleCommands}}{{join .Names \", \"}}{{ \"\\t\" }}{{.Usage}}\n  {{end}}{{if .VisibleFlags}}\nGLOBAL FLAGS:\n  {{range .VisibleFlags}}{{.}}\n  {{end}}{{end}}\nVERSION:\n  2.0.0\n{{\"\\n\"}}{{range $key, $value := ExtraInfo}}\n{{$key}}:\n  {{$value}}\n{{end}}`,\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"app\", \"--help\"})\n\n\tassert.NotContains(t, output.String(), \"secretfrob\", \"expected output to exclude \\\"secretfrob\\\"\")\n\tassert.Contains(t, output.String(), \"frobbly\", \"expected output to include \\\"frobbly\\\"\")\n\n\tif !strings.Contains(output.String(), \"PLATFORM:\") ||\n\t\t!strings.Contains(output.String(), \"OS:\") ||\n\t\t!strings.Contains(output.String(), \"Arch:\") {\n\t\tt.Errorf(\"expected output to include \\\"PLATFORM:, OS: and Arch:\\\"; got: %q\", output.String())\n\t}\n\n\tif !strings.Contains(output.String(), \"RUNTIME:\") ||\n\t\t!strings.Contains(output.String(), \"Version:\") ||\n\t\t!strings.Contains(output.String(), \"CPUs:\") {\n\t\tt.Errorf(\"expected output to include \\\"RUNTIME:, Version: and CPUs:\\\"; got: %q\", output.String())\n\t}\n\n\tif !strings.Contains(output.String(), \"VERSION:\") ||\n\t\t!strings.Contains(output.String(), \"2.0.0\") {\n\t\tt.Errorf(\"expected output to include \\\"VERSION:, 2.0.0\\\"; got: %q\", output.String())\n\t}\n}\n\nfunc TestShowAppHelp_UsageText(t *testing.T) {\n\tcmd := &Command{\n\t\tUsageText: \"This is a single line of UsageText\",\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\"})\n\n\tassert.Contains(t, output.String(), \"This is a single line of UsageText\", \"expected output to include usage text\")\n}\n\nfunc TestShowAppHelp_MultiLine_UsageText(t *testing.T) {\n\tcmd := &Command{\n\t\tUsageText: `This is a\nmulti\nline\nApp UsageText`,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"frobbly\",\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\"})\n\n\texpected := `USAGE:\n   This is a\n   multi\n   line\n   App UsageText\n`\n\n\tassert.Contains(t, output.String(), expected, \"expected output to include usage text\")\n}\n\nfunc TestShowAppHelp_CommandMultiLine_UsageText(t *testing.T) {\n\tcmd := &Command{\n\t\tUsageText: `This is a\nmulti\nline\nApp UsageText`,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:    \"frobbly\",\n\t\t\t\tAliases: []string{\"frb1\", \"frbb2\", \"frl2\"},\n\t\t\t\tUsage:   \"this is a long help output for the run command, long usage \\noutput, long usage output, long usage output, long usage output\\noutput, long usage output, long usage output\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"grobbly\",\n\t\t\t\tAliases: []string{\"grb1\", \"grbb2\"},\n\t\t\t\tUsage:   \"this is another long help output for the run command, long usage \\noutput, long usage output\",\n\t\t\t},\n\t\t},\n\t}\n\n\toutput := &bytes.Buffer{}\n\tcmd.Writer = output\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\"})\n\n\texpected := \"COMMANDS:\\n\" +\n\t\t\"   frobbly, frb1, frbb2, frl2  this is a long help output for the run command, long usage \\n\" +\n\t\t\"                               output, long usage output, long usage output, long usage output\\n\" +\n\t\t\"                               output, long usage output, long usage output\\n\" +\n\t\t\"   grobbly, grb1, grbb2        this is another long help output for the run command, long usage \\n\" +\n\t\t\"                               output, long usage output\"\n\tassert.Contains(t, output.String(), expected, \"expected output to include usage text\")\n}\n\nfunc TestHideHelpCommand(t *testing.T) {\n\tcmd := &Command{\n\t\tHideHelpCommand: true,\n\t\tWriter:          io.Discard,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"help\"})\n\trequire.ErrorContains(t, err, \"No help topic for 'help'\")\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"--help\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestHideHelpCommand_False(t *testing.T) {\n\tcmd := &Command{\n\t\tHideHelpCommand: false,\n\t\tWriter:          io.Discard,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"help\"})\n\tassert.NoError(t, err)\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"--help\"})\n\tassert.NoError(t, err)\n}\n\nfunc TestHideHelpCommand_WithHideHelp(t *testing.T) {\n\tcmd := &Command{\n\t\tHideHelp:        true, // effective (hides both command and flag)\n\t\tHideHelpCommand: true, // ignored\n\t\tWriter:          io.Discard,\n\t}\n\n\terr := cmd.Run(buildTestContext(t), []string{\"foo\", \"help\"})\n\trequire.ErrorContains(t, err, \"No help topic for 'help'\")\n\n\terr = cmd.Run(buildTestContext(t), []string{\"foo\", \"--help\"})\n\trequire.ErrorContains(t, err, \"flag: help requested\")\n}\n\nfunc TestHideHelpCommand_WithSubcommands(t *testing.T) {\n\tcmd := &Command{\n\t\tHideHelpCommand: true,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"nully\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"nully2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tr := require.New(t)\n\n\tr.ErrorContains(cmd.Run(buildTestContext(t), []string{\"cli.test\", \"help\"}), \"No help topic for 'help'\")\n\tr.NoError(cmd.Run(buildTestContext(t), []string{\"cli.test\", \"--help\"}))\n}\n\nfunc TestDefaultCompleteWithFlags(t *testing.T) {\n\torigArgv := os.Args\n\tt.Cleanup(func() { os.Args = origArgv })\n\n\tfor _, tc := range []struct {\n\t\tname     string\n\t\tcmd      *Command\n\t\targv     []string\n\t\tenv      map[string]string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"empty\",\n\t\t\tcmd:      &Command{},\n\t\t\targv:     []string{\"prog\", \"cmd\"},\n\t\t\tenv:      map[string]string{\"SHELL\": \"bash\"},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"typical-flag-suggestion\",\n\t\t\tcmd: &Command{\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"excitement\"},\n\t\t\t\t\t&StringFlag{Name: \"hat-shape\"},\n\t\t\t\t},\n\t\t\t\tparent: &Command{\n\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"happiness\"},\n\t\t\t\t\t\t&IntFlag{Name: \"everybody-jump-on\"},\n\t\t\t\t\t},\n\t\t\t\t\tCommands: []*Command{\n\t\t\t\t\t\t{Name: \"putz\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targv:     []string{\"cmd\", \"--e\", completionFlag},\n\t\t\tenv:      map[string]string{\"SHELL\": \"bash\"},\n\t\t\texpected: \"--excitement\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"typical-flag-suggestion-hidden-bool\",\n\t\t\tcmd: &Command{\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"excitement\", Hidden: true},\n\t\t\t\t\t&StringFlag{Name: \"hat-shape\"},\n\t\t\t\t},\n\t\t\t\tparent: &Command{\n\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"happiness\"},\n\t\t\t\t\t\t&IntFlag{Name: \"everybody-jump-on\"},\n\t\t\t\t\t},\n\t\t\t\t\tCommands: []*Command{\n\t\t\t\t\t\t{Name: \"putz\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targv:     []string{\"cmd\", \"--e\", completionFlag},\n\t\t\tenv:      map[string]string{\"SHELL\": \"bash\"},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"flag-suggestion-end-args\",\n\t\t\tcmd: &Command{\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"excitement\"},\n\t\t\t\t\t&StringFlag{Name: \"hat-shape\"},\n\t\t\t\t},\n\t\t\t\tparent: &Command{\n\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"happiness\"},\n\t\t\t\t\t\t&IntFlag{Name: \"everybody-jump-on\"},\n\t\t\t\t\t},\n\t\t\t\t\tCommands: []*Command{\n\t\t\t\t\t\t{Name: \"putz\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targv:     []string{\"cmd\", \"--e\", \"--\", completionFlag},\n\t\t\tenv:      map[string]string{\"SHELL\": \"bash\"},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"typical-command-suggestion\",\n\t\t\tcmd: &Command{\n\t\t\t\tName: \"putz\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{Name: \"futz\"},\n\t\t\t\t},\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"excitement\"},\n\t\t\t\t\t&StringFlag{Name: \"hat-shape\"},\n\t\t\t\t},\n\t\t\t\tparent: &Command{\n\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"happiness\"},\n\t\t\t\t\t\t&IntFlag{Name: \"everybody-jump-on\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targv:     []string{\"cmd\", completionFlag},\n\t\t\tenv:      map[string]string{\"SHELL\": \"bash\"},\n\t\t\texpected: \"futz\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"autocomplete-with-spaces\",\n\t\t\tcmd: &Command{\n\t\t\t\tName: \"putz\",\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{Name: \"help\"},\n\t\t\t\t},\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"excitement\"},\n\t\t\t\t\t&StringFlag{Name: \"hat-shape\"},\n\t\t\t\t},\n\t\t\t\tparent: &Command{\n\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"happiness\"},\n\t\t\t\t\t\t&IntFlag{Name: \"everybody-jump-on\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targv:     []string{\"cmd\", \"--url\", \"http://localhost:8000\", \"h\", completionFlag},\n\t\t\tenv:      map[string]string{\"SHELL\": \"bash\"},\n\t\t\texpected: \"help\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"zsh-autocomplete-with-flag-descriptions\",\n\t\t\tcmd: &Command{\n\t\t\t\tName: \"putz\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"excitement\", Usage: \"an exciting flag\"},\n\t\t\t\t\t&StringFlag{Name: \"hat-shape\"},\n\t\t\t\t},\n\t\t\t\tparent: &Command{\n\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"happiness\"},\n\t\t\t\t\t\t&IntFlag{Name: \"everybody-jump-on\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targv:     []string{\"cmd\", \"putz\", \"-e\", completionFlag},\n\t\t\tenv:      map[string]string{\"SHELL\": \"zsh\"},\n\t\t\texpected: \"--excitement:an exciting flag\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"zsh-autocomplete-with-empty-flag-descriptions\",\n\t\t\tcmd: &Command{\n\t\t\t\tName: \"putz\",\n\t\t\t\tFlags: []Flag{\n\t\t\t\t\t&BoolFlag{Name: \"excitement\"},\n\t\t\t\t\t&StringFlag{Name: \"hat-shape\"},\n\t\t\t\t},\n\t\t\t\tparent: &Command{\n\t\t\t\t\tName: \"cmd\",\n\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t&BoolFlag{Name: \"happiness\"},\n\t\t\t\t\t\t&IntFlag{Name: \"everybody-jump-on\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\targv:     []string{\"cmd\", \"putz\", \"-e\", completionFlag},\n\t\t\tenv:      map[string]string{\"SHELL\": \"zsh\"},\n\t\t\texpected: \"--excitement\\n\",\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(ct *testing.T) {\n\t\t\twriter := &bytes.Buffer{}\n\t\t\trootCmd := tc.cmd.Root()\n\t\t\trootCmd.Writer = writer\n\n\t\t\tos.Args = tc.argv\n\t\t\tfor k, v := range tc.env {\n\t\t\t\tt.Setenv(k, v)\n\t\t\t}\n\t\t\tf := DefaultCompleteWithFlags\n\t\t\tf(context.Background(), tc.cmd)\n\n\t\t\twritten := writer.String()\n\n\t\t\tassert.Equal(t, tc.expected, written, \"written help does not match\")\n\t\t})\n\t}\n}\n\nfunc TestMutuallyExclusiveFlags(t *testing.T) {\n\twriter := &bytes.Buffer{}\n\tcmd := &Command{\n\t\tName:   \"cmd\",\n\t\tWriter: writer,\n\t\tMutuallyExclusiveFlags: []MutuallyExclusiveFlags{\n\t\t\t{\n\t\t\t\tFlags: [][]Flag{\n\t\t\t\t\t{\n\t\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\t\tName: \"s1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t_ = ShowAppHelp(cmd)\n\n\tassert.Contains(t, writer.String(), \"--s1\", \"written help does not include mutex flag\")\n}\n\nfunc TestWrap(t *testing.T) {\n\temptywrap := wrap(\"\", 4, 16)\n\tassert.Empty(t, emptywrap, \"Wrapping empty line should return empty line\")\n}\n\nfunc TestWrappedHelp(t *testing.T) {\n\t// Reset HelpPrinter after this test.\n\tdefer func(old helpPrinter) {\n\t\tHelpPrinter = old\n\t}(HelpPrinter)\n\n\toutput := new(bytes.Buffer)\n\tcmd := &Command{\n\t\tWriter: output,\n\t\tFlags: []Flag{\n\t\t\t&BoolFlag{\n\t\t\t\tName:    \"foo\",\n\t\t\t\tAliases: []string{\"h\"},\n\t\t\t\tUsage:   \"here's a really long help text line, let's see where it wraps. blah blah blah and so on.\",\n\t\t\t},\n\t\t},\n\t\tUsage:     \"here's a sample App.Usage string long enough that it should be wrapped in this test\",\n\t\tUsageText: \"i'm not sure how App.UsageText differs from App.Usage, but this should also be wrapped in this test\",\n\t\t// TODO: figure out how to make ArgsUsage appear in the help text, and test that\n\t\tDescription: `here's a sample App.Description string long enough that it should be wrapped in this test\n\nwith a newline\n   and an indented line`,\n\t\tCopyright: `Here's a sample copyright text string long enough that it should be wrapped.\nIncluding newlines.\n   And also indented lines.\n\n\nAnd then another long line. Blah blah blah does anybody ever read these things?`,\n\t}\n\n\tHelpPrinter = func(w io.Writer, templ string, data interface{}) {\n\t\tfuncMap := map[string]interface{}{\n\t\t\t\"wrapAt\": func() int {\n\t\t\t\treturn 30\n\t\t\t},\n\t\t}\n\n\t\tHelpPrinterCustom(w, templ, data, funcMap)\n\t}\n\n\t_ = ShowAppHelp(cmd)\n\n\texpected := `NAME:\n    - here's a sample\n      App.Usage string long\n      enough that it should be\n      wrapped in this test\n\nUSAGE:\n   i'm not sure how\n   App.UsageText differs from\n   App.Usage, but this should\n   also be wrapped in this\n   test\n\nDESCRIPTION:\n   here's a sample\n   App.Description string long\n   enough that it should be\n   wrapped in this test\n\n   with a newline\n      and an indented line\n\nGLOBAL OPTIONS:\n   --foo, -h here's a\n      really long help text\n      line, let's see where it\n      wraps. blah blah blah\n      and so on. (default:\n      false)\n\nCOPYRIGHT:\n   Here's a sample copyright\n   text string long enough\n   that it should be wrapped.\n   Including newlines.\n      And also indented lines.\n\n\n   And then another long line.\n   Blah blah blah does anybody\n   ever read these things?\n`\n\n\tassert.Equal(t, expected, output.String(), \"Unexpected wrapping\")\n}\n\nfunc TestWrappedCommandHelp(t *testing.T) {\n\t// Reset HelpPrinter after this test.\n\tdefer func(old helpPrinter) {\n\t\tHelpPrinter = old\n\t}(HelpPrinter)\n\n\toutput := &bytes.Buffer{}\n\tcmd := &Command{\n\t\tWriter:    output,\n\t\tErrWriter: output,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:        \"add\",\n\t\t\t\tAliases:     []string{\"a\"},\n\t\t\t\tUsage:       \"add a task to the list\",\n\t\t\t\tUsageText:   \"this is an even longer way of describing adding a task to the list\",\n\t\t\t\tDescription: \"and a description long enough to wrap in this test case\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tcmd.setupDefaults([]string{\"cli.test\"})\n\tcmd.setupCommandGraph()\n\n\tHelpPrinter = func(w io.Writer, templ string, data interface{}) {\n\t\tfuncMap := map[string]interface{}{\n\t\t\t\"wrapAt\": func() int {\n\t\t\t\treturn 30\n\t\t\t},\n\t\t}\n\n\t\tHelpPrinterCustom(w, templ, data, funcMap)\n\t}\n\n\tr := require.New(t)\n\n\tr.NoError(ShowCommandHelp(context.Background(), cmd, \"add\"))\n\tr.Equal(`NAME:\n   cli.test add - add a task\n                  to the list\n\nUSAGE:\n   this is an even longer way\n   of describing adding a task\n   to the list\n\nDESCRIPTION:\n   and a description long\n   enough to wrap in this test\n   case\n\nOPTIONS:\n   --help, -h  show help\n`,\n\t\toutput.String(),\n\t)\n}\n\nfunc TestWrappedSubcommandHelp(t *testing.T) {\n\t// Reset HelpPrinter after this test.\n\tdefer func(old helpPrinter) {\n\t\tHelpPrinter = old\n\t}(HelpPrinter)\n\n\toutput := new(bytes.Buffer)\n\tcmd := &Command{\n\t\tName:   \"cli.test\",\n\t\tWriter: output,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:        \"bar\",\n\t\t\t\tAliases:     []string{\"a\"},\n\t\t\t\tUsage:       \"add a task to the list\",\n\t\t\t\tUsageText:   \"this is an even longer way of describing adding a task to the list\",\n\t\t\t\tDescription: \"and a description long enough to wrap in this test case\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:      \"grok\",\n\t\t\t\t\t\tUsage:     \"remove an existing template\",\n\t\t\t\t\t\tUsageText: \"longer usage text goes here, la la la, hopefully this is long enough to wrap even more\",\n\t\t\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tHelpPrinter = func(w io.Writer, templ string, data interface{}) {\n\t\tfuncMap := map[string]interface{}{\n\t\t\t\"wrapAt\": func() int {\n\t\t\t\treturn 30\n\t\t\t},\n\t\t}\n\n\t\tHelpPrinterCustom(w, templ, data, funcMap)\n\t}\n\n\t_ = cmd.Run(buildTestContext(t), []string{\"foo\", \"bar\", \"grok\", \"--help\"})\n\n\texpected := `NAME:\n   cli.test bar grok - remove\n                       an\n                       existing\n                       template\n\nUSAGE:\n   longer usage text goes\n   here, la la la, hopefully\n   this is long enough to wrap\n   even more\n\nOPTIONS:\n   --help, -h  show help\n`\n\n\tassert.Equal(t, expected, output.String(), \"Unexpected wrapping\")\n}\n\nfunc TestWrappedHelpSubcommand(t *testing.T) {\n\t// Reset HelpPrinter after this test.\n\tdefer func(old helpPrinter) {\n\t\tHelpPrinter = old\n\t}(HelpPrinter)\n\n\toutput := &bytes.Buffer{}\n\tcmd := &Command{\n\t\tName:      \"cli.test\",\n\t\tWriter:    output,\n\t\tErrWriter: output,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName:        \"bar\",\n\t\t\t\tAliases:     []string{\"a\"},\n\t\t\t\tUsage:       \"add a task to the list\",\n\t\t\t\tUsageText:   \"this is an even longer way of describing adding a task to the list\",\n\t\t\t\tDescription: \"and a description long enough to wrap in this test case\",\n\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\treturn nil\n\t\t\t\t},\n\t\t\t\tCommands: []*Command{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:      \"grok\",\n\t\t\t\t\t\tUsage:     \"remove an existing template\",\n\t\t\t\t\t\tUsageText: \"longer usage text goes here, la la la, hopefully this is long enough to wrap even more\",\n\t\t\t\t\t\tAction: func(context.Context, *Command) error {\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t},\n\t\t\t\t\t\tFlags: []Flag{\n\t\t\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\t\t\tName:  \"test-f\",\n\t\t\t\t\t\t\t\tUsage: \"my test usage\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tHelpPrinter = func(w io.Writer, templ string, data interface{}) {\n\t\tfuncMap := map[string]interface{}{\n\t\t\t\"wrapAt\": func() int {\n\t\t\t\treturn 30\n\t\t\t},\n\t\t}\n\n\t\tHelpPrinterCustom(w, templ, data, funcMap)\n\t}\n\n\tr := require.New(t)\n\n\tr.NoError(cmd.Run(buildTestContext(t), []string{\"cli.test\", \"bar\", \"help\", \"grok\"}))\n\tr.Equal(`NAME:\n   cli.test bar grok - remove\n                       an\n                       existing\n                       template\n\nUSAGE:\n   longer usage text goes\n   here, la la la, hopefully\n   this is long enough to wrap\n   even more\n\nOPTIONS:\n   --test-f value my test\n      usage\n   --help, -h  show help\n`,\n\t\toutput.String(),\n\t)\n}\n\nfunc TestCategorizedHelp(t *testing.T) {\n\t// Reset HelpPrinter after this test.\n\tdefer func(old helpPrinter) {\n\t\tHelpPrinter = old\n\t}(HelpPrinter)\n\n\toutput := new(bytes.Buffer)\n\tcmd := &Command{\n\t\tName:   \"cli.test\",\n\t\tWriter: output,\n\t\tAction: func(context.Context, *Command) error { return nil },\n\t\tFlags: []Flag{\n\t\t\t&StringFlag{\n\t\t\t\tName: \"strd\", // no category set\n\t\t\t},\n\t\t\t&IntFlag{\n\t\t\t\tName:     \"intd\",\n\t\t\t\tAliases:  []string{\"altd1\", \"altd2\"},\n\t\t\t\tCategory: \"cat1\",\n\t\t\t},\n\t\t},\n\t\tMutuallyExclusiveFlags: []MutuallyExclusiveFlags{\n\t\t\t{\n\t\t\t\tCategory: \"cat1\",\n\t\t\t\tFlags: [][]Flag{\n\t\t\t\t\t{\n\t\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\t\tName:     \"m1\",\n\t\t\t\t\t\t\tCategory: \"overridden\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tFlags: [][]Flag{\n\t\t\t\t\t{\n\t\t\t\t\t\t&StringFlag{\n\t\t\t\t\t\t\tName:     \"m2\",\n\t\t\t\t\t\t\tCategory: \"ignored\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tHelpPrinter = func(w io.Writer, templ string, data interface{}) {\n\t\tfuncMap := map[string]interface{}{\n\t\t\t\"wrapAt\": func() int {\n\t\t\t\treturn 30\n\t\t\t},\n\t\t}\n\n\t\tHelpPrinterCustom(w, templ, data, funcMap)\n\t}\n\n\tr := require.New(t)\n\tr.NoError(cmd.Run(buildTestContext(t), []string{\"cli.test\", \"help\"}))\n\n\tr.Equal(`NAME:\n   cli.test - A new cli\n              application\n\nUSAGE:\n   cli.test [global options]\n\nGLOBAL OPTIONS:\n   --help, -h    show help\n   --m2 value    \n   --strd value  \n\n   cat1\n\n   --intd value, --altd1 value, --altd2 value  (default: 0)\n   --m1 value                                  \n\n`, output.String())\n}\n\nfunc Test_checkShellCompleteFlag(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tname                string\n\t\tcmd                 *Command\n\t\targuments           []string\n\t\twantShellCompletion bool\n\t\twantArgs            []string\n\t}{\n\t\t{\n\t\t\tname:                \"disable-shell-completion\",\n\t\t\targuments:           []string{completionFlag},\n\t\t\tcmd:                 &Command{},\n\t\t\twantShellCompletion: false,\n\t\t\twantArgs:            []string{completionFlag},\n\t\t},\n\t\t{\n\t\t\tname:      \"child-disable-shell-completion\",\n\t\t\targuments: []string{completionFlag},\n\t\t\tcmd: &Command{\n\t\t\t\tparent: &Command{},\n\t\t\t},\n\t\t\twantShellCompletion: false,\n\t\t\twantArgs:            []string{completionFlag},\n\t\t},\n\t\t{\n\t\t\tname:      \"last argument isn't --generate-shell-completion\",\n\t\t\targuments: []string{\"foo\"},\n\t\t\tcmd: &Command{\n\t\t\t\tEnableShellCompletion: true,\n\t\t\t},\n\t\t\twantShellCompletion: false,\n\t\t\twantArgs:            []string{\"foo\"},\n\t\t},\n\t\t{\n\t\t\tname:      \"arguments include double dash\",\n\t\t\targuments: []string{\"--\", \"foo\", completionFlag},\n\t\t\tcmd: &Command{\n\t\t\t\tEnableShellCompletion: true,\n\t\t\t},\n\t\t\twantShellCompletion: false,\n\t\t\twantArgs:            []string{\"--\", \"foo\"},\n\t\t},\n\t\t{\n\t\t\tname:      \"shell completion\",\n\t\t\targuments: []string{\"foo\", completionFlag},\n\t\t\tcmd: &Command{\n\t\t\t\tEnableShellCompletion: true,\n\t\t\t},\n\t\t\twantShellCompletion: true,\n\t\t\twantArgs:            []string{\"foo\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tshellCompletion, args := checkShellCompleteFlag(tt.cmd, tt.arguments)\n\t\t\tassert.Equal(t, tt.wantShellCompletion, shellCompletion)\n\t\t\tassert.Equal(t, tt.wantArgs, args)\n\t\t})\n\t}\n}\n\nfunc TestNIndent(t *testing.T) {\n\tt.Parallel()\n\ttests := []struct {\n\t\tnumSpaces int\n\t\tstr       string\n\t\texpected  string\n\t}{\n\t\t{\n\t\t\tnumSpaces: 0,\n\t\t\tstr:       \"foo\",\n\t\t\texpected:  \"\\nfoo\",\n\t\t},\n\t\t{\n\t\t\tnumSpaces: 0,\n\t\t\tstr:       \"foo\\n\",\n\t\t\texpected:  \"\\nfoo\\n\",\n\t\t},\n\t\t{\n\t\t\tnumSpaces: 2,\n\t\t\tstr:       \"foo\",\n\t\t\texpected:  \"\\n  foo\",\n\t\t},\n\t\t{\n\t\t\tnumSpaces: 3,\n\t\t\tstr:       \"foo\\n\",\n\t\t\texpected:  \"\\n   foo\\n   \",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tassert.Equal(t, test.expected, nindent(test.numSpaces, test.str))\n\t}\n}\n\nfunc TestTemplateError(t *testing.T) {\n\toldew := ErrWriter\n\tdefer func() { ErrWriter = oldew }()\n\n\tvar buf bytes.Buffer\n\tErrWriter = &buf\n\terr := errors.New(\"some error\")\n\n\thandleTemplateError(err)\n\tassert.Equal(t, []byte(nil), buf.Bytes())\n\n\tt.Setenv(\"CLI_TEMPLATE_ERROR_DEBUG\", \"true\")\n\thandleTemplateError(err)\n\tassert.Contains(t, buf.String(), \"CLI TEMPLATE ERROR\")\n\tassert.Contains(t, buf.String(), err.Error())\n}\n\nfunc TestCliArgContainsFlag(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\targs     []string\n\t\tcontains bool\n\t}{\n\t\t{\n\t\t\tname: \"\",\n\t\t\targs: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"f\",\n\t\t\targs: []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"f\",\n\t\t\targs: []string{\"g\", \"foo\", \"f\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"f\",\n\t\t\targs:     []string{\"-f\", \"foo\", \"f\"},\n\t\t\tcontains: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"f\",\n\t\t\targs:     []string{\"g\", \"-f\", \"f\"},\n\t\t\tcontains: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"fh\",\n\t\t\targs:     []string{\"g\", \"f\", \"--fh\"},\n\t\t\tcontains: true,\n\t\t},\n\t\t{\n\t\t\tname: \"fhg\",\n\t\t\targs: []string{\"-fhg\", \"f\", \"fh\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"fhg\",\n\t\t\targs:     []string{\"--fhg\", \"f\", \"fh\"},\n\t\t\tcontains: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tif test.contains {\n\t\t\tassert.True(t, cliArgContains(test.name, test.args))\n\t\t} else {\n\t\t\tassert.False(t, cliArgContains(test.name, test.args))\n\t\t}\n\t}\n}\n\nfunc TestCommandHelpSuggest(t *testing.T) {\n\tcmd := &Command{\n\t\tSuggest: true,\n\t\tCommands: []*Command{\n\t\t\t{\n\t\t\t\tName: \"putz\",\n\t\t\t},\n\t\t},\n\t}\n\n\tcmd.setupDefaults([]string{\"foo\"})\n\n\terr := ShowCommandHelp(context.Background(), cmd, \"put\")\n\tassert.ErrorContains(t, err, \"No help topic for 'put'. putz\")\n}\n\nfunc TestWrapLine(t *testing.T) {\n\tassert.Equal(t, \"    \", wrapLine(\"    \", 0, 3, \" \"))\n}\n\nfunc TestPrintHelpCustomTemplateError(t *testing.T) {\n\ttmpls := []*string{\n\t\t&helpNameTemplate,\n\t\t&argsTemplate,\n\t\t&usageTemplate,\n\t\t&descriptionTemplate,\n\t\t&visibleCommandTemplate,\n\t\t&copyrightTemplate,\n\t\t&versionTemplate,\n\t\t&visibleFlagCategoryTemplate,\n\t\t&visibleFlagTemplate,\n\t\t&visiblePersistentFlagTemplate,\n\t\t&visibleFlagCategoryTemplate,\n\t\t&authorsTemplate,\n\t\t&visibleCommandCategoryTemplate,\n\t}\n\n\toldErrWriter := ErrWriter\n\tdefer func() { ErrWriter = oldErrWriter }()\n\n\tt.Setenv(\"CLI_TEMPLATE_ERROR_DEBUG\", \"true\")\n\n\tfor _, tmpl := range tmpls {\n\t\toldtmpl := *tmpl\n\t\t// safety mechanism in case something fails\n\t\tdefer func(stmpl *string) { *stmpl = oldtmpl }(tmpl)\n\n\t\terrBuf := &bytes.Buffer{}\n\t\tErrWriter = errBuf\n\t\tbuf := &bytes.Buffer{}\n\n\t\t*tmpl = \"{{junk\"\n\t\tprintHelpCustom(buf, \"\", \"\", nil)\n\n\t\tassert.Contains(t, errBuf.String(), \"CLI TEMPLATE ERROR\")\n\n\t\t// reset template back.\n\t\t*tmpl = oldtmpl\n\t}\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 0.0888671875,
          "content": "package cli\n\nimport (\n\t\"os\"\n)\n\nfunc init() {\n\t_ = os.Setenv(\"CLI_TEMPLATE_REPANIC\", \"1\")\n}\n"
        },
        {
          "name": "mkdocs-reqs.txt",
          "type": "blob",
          "size": 0.0927734375,
          "content": "mkdocs-git-revision-date-localized-plugin~=1.2\nmkdocs-material~=9.5\nmkdocs~=1.6\npygments~=2.18\n"
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 4.318359375,
          "content": "# NOTE: the mkdocs dependencies will need to be installed out of\n# band until this whole thing gets more automated:\n#\n#     pip install -r mkdocs-reqs.txt\n#\n\nsite_name: urfave/cli\nsite_url: https://cli.urfave.org/\nrepo_url: https://github.com/urfave/cli\nedit_uri: edit/main/docs/\nnav:\n  - Home:\n      - Welcome: index.md\n      - Contributing: CONTRIBUTING.md\n      - Code of Conduct: CODE_OF_CONDUCT.md\n      - Releasing: RELEASING.md\n      - Security: SECURITY.md\n      - Migrate v2 to v3: migrate-v2-to-v3.md\n      - Migrate v1 to v2: migrate-v1-to-v2.md\n  - v3 Manual:\n      - Getting Started: v3/getting-started.md\n      - Migrating From Older Releases: v3/migrating-from-older-releases.md\n      - Examples:\n          - Greet: v3/examples/greet.md\n          - Arguments: v3/examples/arguments.md\n          - Flags: v3/examples/flags.md\n          - Subcommands: v3/examples/subcommands.md\n          - Subcommands Categories: v3/examples/subcommands-categories.md\n          - Exit Codes: v3/examples/exit-codes.md\n          - Combining Short Options: v3/examples/combining-short-options.md\n          - Bash Completions: v3/examples/bash-completions.md\n          - Generated Help Text: v3/examples/generated-help-text.md\n          - Version Flag: v3/examples/version-flag.md\n          - Timestamp Flag: v3/examples/timestamp-flag.md\n          - Suggestions: v3/examples/suggestions.md\n          - Full API Example: v3/examples/full-api-example.md\n  - v2 Manual:\n      - Getting Started: v2/getting-started.md\n      - Migrating From Older Releases: v2/migrating-from-older-releases.md\n      - Examples:\n          - Greet: v2/examples/greet.md\n          - Arguments: v2/examples/arguments.md\n          - Flags: v2/examples/flags.md\n          - Subcommands: v2/examples/subcommands.md\n          - Subcommands Categories: v2/examples/subcommands-categories.md\n          - Exit Codes: v2/examples/exit-codes.md\n          - Combining Short Options: v2/examples/combining-short-options.md\n          - Bash Completions: v2/examples/bash-completions.md\n          - Generated Help Text: v2/examples/generated-help-text.md\n          - Version Flag: v2/examples/version-flag.md\n          - Timestamp Flag: v2/examples/timestamp-flag.md\n          - Suggestions: v2/examples/suggestions.md\n          - Full API Example: v2/examples/full-api-example.md\n  - v1 Manual:\n      - Getting Started: v1/getting-started.md\n      - Migrating to v2: v1/migrating-to-v2.md\n      - Examples:\n          - Greet: v1/examples/greet.md\n          - Arguments: v1/examples/arguments.md\n          - Flags: v1/examples/flags.md\n          - Subcommands: v1/examples/subcommands.md\n          - Subcommands (Categories): v1/examples/subcommands-categories.md\n          - Exit Codes: v1/examples/exit-codes.md\n          - Combining Short Options: v1/examples/combining-short-options.md\n          - Bash Completions: v1/examples/bash-completions.md\n          - Generated Help Text: v1/examples/generated-help-text.md\n          - Version Flag: v1/examples/version-flag.md\n\ntheme:\n  name: material\n  palette:\n    - media: \"(prefers-color-scheme: light)\"\n      scheme: default\n      toggle:\n        icon: material/brightness-4\n        name: dark mode\n    - media: \"(prefers-color-scheme: dark)\"\n      scheme: slate\n      toggle:\n        icon: material/brightness-7\n        name: light mode\n  features:\n    - content.code.annotate\n    - navigation.top\n    - navigation.instant\n    - navigation.expand\n    - navigation.sections\n    - navigation.tabs\n    - navigation.tabs.sticky\nplugins:\n  - git-revision-date-localized\n  - search\n  - tags\n# NOTE: this is the recommended configuration from\n# https://squidfunk.github.io/mkdocs-material/setup/extensions/#recommended-configuration\nmarkdown_extensions:\n  - abbr\n  - admonition\n  - attr_list\n  - def_list\n  - footnotes\n  - meta\n  - md_in_html\n  - toc:\n      permalink: true\n  - pymdownx.arithmatex:\n      generic: true\n  - pymdownx.betterem:\n      smart_enable: all\n  - pymdownx.caret\n  - pymdownx.details\n  - pymdownx.emoji:\n      emoji_index: !!python/name:material.extensions.emoji.twemoji\n      emoji_generator: !!python/name:material.extensions.emoji.to_svg\n  - pymdownx.highlight\n  - pymdownx.inlinehilite\n  - pymdownx.keys\n  - pymdownx.mark\n  - pymdownx.smartsymbols\n  - pymdownx.superfences\n  - pymdownx.tabbed:\n      alternate_style: true\n  - pymdownx.tasklist:\n      custom_checkbox: true\n  - pymdownx.tilde\n"
        },
        {
          "name": "parse.go",
          "type": "blob",
          "size": 3.201171875,
          "content": "package cli\n\nimport (\n\t\"flag\"\n\t\"strings\"\n)\n\ntype iterativeParser interface {\n\tuseShortOptionHandling() bool\n}\n\n// To enable short-option handling (e.g., \"-it\" vs \"-i -t\") we have to\n// iteratively catch parsing errors. This way we achieve LR parsing without\n// transforming any arguments. Otherwise, there is no way we can discriminate\n// combined short options from common arguments that should be left untouched.\n// Pass `shellComplete` to continue parsing options on failure during shell\n// completion when, the user-supplied options may be incomplete.\nfunc parseIter(set *flag.FlagSet, ip iterativeParser, args []string, shellComplete bool) error {\n\tfor {\n\t\ttracef(\"parsing args %[1]q with %[2]T (name=%[3]q)\", args, set, set.Name())\n\n\t\terr := set.Parse(args)\n\t\tif !ip.useShortOptionHandling() || err == nil {\n\t\t\tif shellComplete {\n\t\t\t\ttracef(\"returning nil due to shellComplete=true\")\n\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\ttracef(\"returning err %[1]q\", err)\n\n\t\t\treturn err\n\t\t}\n\n\t\ttracef(\"finding flag from error %[1]q\", err)\n\n\t\ttrimmed, trimErr := flagFromError(err)\n\t\tif trimErr != nil {\n\t\t\treturn err\n\t\t}\n\n\t\ttracef(\"regenerating the initial args with the split short opts\")\n\n\t\targsWereSplit := false\n\t\tfor i, arg := range args {\n\t\t\ttracef(\"skipping args that are not part of the error message (i=%[1]v arg=%[2]q)\", i, arg)\n\n\t\t\tif name := strings.TrimLeft(arg, \"-\"); name != trimmed {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\ttracef(\"trying to split short option (arg=%[1]q)\", arg)\n\n\t\t\tshortOpts := splitShortOptions(set, arg)\n\t\t\tif len(shortOpts) == 1 {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\ttracef(\n\t\t\t\t\"swapping current argument with the split version (shortOpts=%[1]q args=%[2]q)\",\n\t\t\t\tshortOpts, args,\n\t\t\t)\n\n\t\t\t// do not include args that parsed correctly so far as it would\n\t\t\t// trigger Value.Set() on those args and would result in\n\t\t\t// duplicates for slice type flags\n\t\t\targs = append(shortOpts, args[i+1:]...)\n\t\t\targsWereSplit = true\n\t\t\tbreak\n\t\t}\n\n\t\ttracef(\"this should be an impossible to reach code path\")\n\t\t// but in case the arg splitting failed to happen, this\n\t\t// will prevent infinite loops\n\t\tif !argsWereSplit {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nconst providedButNotDefinedErrMsg = \"flag provided but not defined: -\"\n\n// flagFromError tries to parse a provided flag from an error message. If the\n// parsing fails, it returns the input error and an empty string\nfunc flagFromError(err error) (string, error) {\n\terrStr := err.Error()\n\ttrimmed := strings.TrimPrefix(errStr, providedButNotDefinedErrMsg)\n\tif errStr == trimmed {\n\t\treturn \"\", err\n\t}\n\treturn trimmed, nil\n}\n\nfunc splitShortOptions(set *flag.FlagSet, arg string) []string {\n\tshortFlagsExist := func(s string) bool {\n\t\tfor index, c := range s[1:] {\n\t\t\tif index == (len(s[1:])-1) && c == '-' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif f := set.Lookup(string(c)); f == nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tif !isSplittable(arg) || !shortFlagsExist(arg) {\n\t\treturn []string{arg}\n\t}\n\n\tseparated := make([]string, 0, len(arg)-1)\n\tfor _, flagChar := range arg[1:] {\n\t\tif flagChar != '-' {\n\t\t\tseparated = append(separated, \"-\"+string(flagChar))\n\t\t} else {\n\t\t\tseparated = append(separated, \"-\")\n\t\t}\n\t}\n\n\treturn separated\n}\n\nfunc isSplittable(flagArg string) bool {\n\treturn strings.HasPrefix(flagArg, \"-\") && !strings.HasPrefix(flagArg, \"--\") && len(flagArg) > 2\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "sort.go",
          "type": "blob",
          "size": 0.5078125,
          "content": "package cli\n\nimport \"unicode\"\n\n// lexicographicLess compares strings alphabetically considering case.\nfunc lexicographicLess(i, j string) bool {\n\tiRunes := []rune(i)\n\tjRunes := []rune(j)\n\n\tlenShared := len(iRunes)\n\tif lenShared > len(jRunes) {\n\t\tlenShared = len(jRunes)\n\t}\n\n\tfor index := 0; index < lenShared; index++ {\n\t\tir := iRunes[index]\n\t\tjr := jRunes[index]\n\n\t\tif lir, ljr := unicode.ToLower(ir), unicode.ToLower(jr); lir != ljr {\n\t\t\treturn lir < ljr\n\t\t}\n\n\t\tif ir != jr {\n\t\t\treturn ir < jr\n\t\t}\n\t}\n\n\treturn i < j\n}\n"
        },
        {
          "name": "sort_test.go",
          "type": "blob",
          "size": 0.5517578125,
          "content": "package cli\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar lexicographicLessTests = []struct {\n\ti        string\n\tj        string\n\texpected bool\n}{\n\t{\"\", \"a\", true},\n\t{\"a\", \"\", false},\n\t{\"a\", \"a\", false},\n\t{\"a\", \"A\", false},\n\t{\"A\", \"a\", true},\n\t{\"aa\", \"a\", false},\n\t{\"a\", \"aa\", true},\n\t{\"a\", \"b\", true},\n\t{\"a\", \"B\", true},\n\t{\"A\", \"b\", true},\n\t{\"A\", \"B\", true},\n}\n\nfunc TestLexicographicLess(t *testing.T) {\n\tfor _, test := range lexicographicLessTests {\n\t\tactual := lexicographicLess(test.i, test.j)\n\t\tassert.Equal(t, test.expected, actual)\n\t}\n}\n"
        },
        {
          "name": "staticcheck.conf",
          "type": "blob",
          "size": 0.0146484375,
          "content": "checks=[\"all\"]\n"
        },
        {
          "name": "suggestions.go",
          "type": "blob",
          "size": 3.3564453125,
          "content": "package cli\n\nimport (\n\t\"math\"\n)\n\nconst suggestDidYouMeanTemplate = \"Did you mean %q?\"\n\nvar (\n\tSuggestFlag               SuggestFlagFunc    = suggestFlag\n\tSuggestCommand            SuggestCommandFunc = suggestCommand\n\tSuggestDidYouMeanTemplate string             = suggestDidYouMeanTemplate\n)\n\ntype SuggestFlagFunc func(flags []Flag, provided string, hideHelp bool) string\n\ntype SuggestCommandFunc func(commands []*Command, provided string) string\n\n// jaroDistance is the measure of similarity between two strings. It returns a\n// value between 0 and 1, where 1 indicates identical strings and 0 indicates\n// completely different strings.\n//\n// Adapted from https://github.com/xrash/smetrics/blob/5f08fbb34913bc8ab95bb4f2a89a0637ca922666/jaro.go.\nfunc jaroDistance(a, b string) float64 {\n\tif len(a) == 0 && len(b) == 0 {\n\t\treturn 1\n\t}\n\tif len(a) == 0 || len(b) == 0 {\n\t\treturn 0\n\t}\n\n\tlenA := float64(len(a))\n\tlenB := float64(len(b))\n\thashA := make([]bool, len(a))\n\thashB := make([]bool, len(b))\n\tmaxDistance := int(math.Max(0, math.Floor(math.Max(lenA, lenB)/2.0)-1))\n\n\tvar matches float64\n\tfor i := 0; i < len(a); i++ {\n\t\tstart := int(math.Max(0, float64(i-maxDistance)))\n\t\tend := int(math.Min(lenB-1, float64(i+maxDistance)))\n\n\t\tfor j := start; j <= end; j++ {\n\t\t\tif hashB[j] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif a[i] == b[j] {\n\t\t\t\thashA[i] = true\n\t\t\t\thashB[j] = true\n\t\t\t\tmatches++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tif matches == 0 {\n\t\treturn 0\n\t}\n\n\tvar transpositions float64\n\tvar j int\n\tfor i := 0; i < len(a); i++ {\n\t\tif !hashA[i] {\n\t\t\tcontinue\n\t\t}\n\t\tfor !hashB[j] {\n\t\t\tj++\n\t\t}\n\t\tif a[i] != b[j] {\n\t\t\ttranspositions++\n\t\t}\n\t\tj++\n\t}\n\n\ttranspositions /= 2\n\treturn ((matches / lenA) + (matches / lenB) + ((matches - transpositions) / matches)) / 3.0\n}\n\n// jaroWinkler is more accurate when strings have a common prefix up to a\n// defined maximum length.\n//\n// Adapted from https://github.com/xrash/smetrics/blob/5f08fbb34913bc8ab95bb4f2a89a0637ca922666/jaro-winkler.go.\nfunc jaroWinkler(a, b string) float64 {\n\tconst (\n\t\tboostThreshold = 0.7\n\t\tprefixSize     = 4\n\t)\n\tjaroDist := jaroDistance(a, b)\n\tif jaroDist <= boostThreshold {\n\t\treturn jaroDist\n\t}\n\n\tprefix := int(math.Min(float64(len(a)), math.Min(float64(prefixSize), float64(len(b)))))\n\n\tvar prefixMatch float64\n\tfor i := 0; i < prefix; i++ {\n\t\tif a[i] == b[i] {\n\t\t\tprefixMatch++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn jaroDist + 0.1*prefixMatch*(1.0-jaroDist)\n}\n\nfunc suggestFlag(flags []Flag, provided string, hideHelp bool) string {\n\tdistance := 0.0\n\tsuggestion := \"\"\n\n\tfor _, flag := range flags {\n\t\tflagNames := flag.Names()\n\t\tif !hideHelp && HelpFlag != nil {\n\t\t\tflagNames = append(flagNames, HelpFlag.Names()...)\n\t\t}\n\t\tfor _, name := range flagNames {\n\t\t\tnewDistance := jaroWinkler(name, provided)\n\t\t\tif newDistance > distance {\n\t\t\t\tdistance = newDistance\n\t\t\t\tsuggestion = name\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(suggestion) == 1 {\n\t\tsuggestion = \"-\" + suggestion\n\t} else if len(suggestion) > 1 {\n\t\tsuggestion = \"--\" + suggestion\n\t}\n\n\treturn suggestion\n}\n\n// suggestCommand takes a list of commands and a provided string to suggest a\n// command name\nfunc suggestCommand(commands []*Command, provided string) (suggestion string) {\n\tdistance := 0.0\n\tfor _, command := range commands {\n\t\tfor _, name := range append(command.Names(), helpName, helpAlias) {\n\t\t\tnewDistance := jaroWinkler(name, provided)\n\t\t\tif newDistance > distance {\n\t\t\t\tdistance = newDistance\n\t\t\t\tsuggestion = name\n\t\t\t}\n\t\t}\n\t}\n\n\treturn suggestion\n}\n"
        },
        {
          "name": "suggestions_test.go",
          "type": "blob",
          "size": 2.751953125,
          "content": "package cli\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestJaroWinkler(t *testing.T) {\n\t// Given\n\tfor _, testCase := range []struct {\n\t\ta, b     string\n\t\texpected float64\n\t}{\n\t\t{\"\", \"\", 1},\n\t\t{\"a\", \"\", 0},\n\t\t{\"\", \"a\", 0},\n\t\t{\"a\", \"a\", 1},\n\t\t{\"a\", \"b\", 0},\n\t\t{\"aa\", \"aa\", 1},\n\t\t{\"aa\", \"bb\", 0},\n\t\t{\"aaa\", \"aaa\", 1},\n\t\t{\"aa\", \"ab\", 0.6666666666666666},\n\t\t{\"aa\", \"ba\", 0.6666666666666666},\n\t\t{\"ba\", \"aa\", 0.6666666666666666},\n\t\t{\"ab\", \"aa\", 0.6666666666666666},\n\t} {\n\t\t// When\n\t\tres := jaroWinkler(testCase.a, testCase.b)\n\n\t\t// Then\n\t\tassert.Equal(t, testCase.expected, res)\n\t}\n}\n\nfunc TestSuggestFlag(t *testing.T) {\n\t// Given\n\tapp := buildExtendedTestCommand()\n\n\tfor _, testCase := range []struct {\n\t\tprovided, expected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"a\", \"--another-flag\"},\n\t\t{\"hlp\", \"--help\"},\n\t\t{\"k\", \"\"},\n\t\t{\"s\", \"-s\"},\n\t} {\n\t\t// When\n\t\tres := suggestFlag(app.Flags, testCase.provided, false)\n\n\t\t// Then\n\t\tassert.Equal(t, testCase.expected, res)\n\t}\n}\n\nfunc TestSuggestFlagHideHelp(t *testing.T) {\n\t// Given\n\tapp := buildExtendedTestCommand()\n\n\t// When\n\tres := suggestFlag(app.Flags, \"hlp\", true)\n\n\t// Then\n\tassert.Equal(t, \"--fl\", res)\n}\n\nfunc TestSuggestFlagFromError(t *testing.T) {\n\t// Given\n\tapp := buildExtendedTestCommand()\n\n\tfor _, testCase := range []struct {\n\t\tcommand, provided, expected string\n\t}{\n\t\t{\"\", \"hel\", \"--help\"},\n\t\t{\"\", \"soccer\", \"--socket\"},\n\t\t{\"config\", \"anot\", \"--another-flag\"},\n\t} {\n\t\t// When\n\t\tres, _ := app.suggestFlagFromError(\n\t\t\terrors.New(providedButNotDefinedErrMsg+testCase.provided),\n\t\t\ttestCase.command,\n\t\t)\n\n\t\t// Then\n\t\tassert.Equal(t, fmt.Sprintf(SuggestDidYouMeanTemplate+\"\\n\\n\", testCase.expected), res)\n\t}\n}\n\nfunc TestSuggestFlagFromErrorWrongError(t *testing.T) {\n\t// Given\n\tapp := buildExtendedTestCommand()\n\n\t// When\n\t_, err := app.suggestFlagFromError(errors.New(\"invalid\"), \"\")\n\n\t// Then\n\tassert.Error(t, err)\n}\n\nfunc TestSuggestFlagFromErrorWrongCommand(t *testing.T) {\n\t// Given\n\tapp := buildExtendedTestCommand()\n\n\t// When\n\t_, err := app.suggestFlagFromError(\n\t\terrors.New(providedButNotDefinedErrMsg+\"flag\"),\n\t\t\"invalid\",\n\t)\n\n\t// Then\n\tassert.Error(t, err)\n}\n\nfunc TestSuggestFlagFromErrorNoSuggestion(t *testing.T) {\n\t// Given\n\tapp := buildExtendedTestCommand()\n\n\t// When\n\t_, err := app.suggestFlagFromError(\n\t\terrors.New(providedButNotDefinedErrMsg+\"\"),\n\t\t\"\",\n\t)\n\n\t// Then\n\tassert.Error(t, err)\n}\n\nfunc TestSuggestCommand(t *testing.T) {\n\t// Given\n\tapp := buildExtendedTestCommand()\n\n\tfor _, testCase := range []struct {\n\t\tprovided, expected string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"conf\", \"config\"},\n\t\t{\"i\", \"i\"},\n\t\t{\"information\", \"info\"},\n\t\t{\"inf\", \"info\"},\n\t\t{\"con\", \"config\"},\n\t\t{\"not-existing\", \"info\"},\n\t} {\n\t\t// When\n\t\tres := suggestCommand(app.Commands, testCase.provided)\n\n\t\t// Then\n\t\tassert.Equal(t, testCase.expected, res)\n\t}\n}\n"
        },
        {
          "name": "template.go",
          "type": "blob",
          "size": 4.681640625,
          "content": "package cli\n\nvar (\n\thelpNameTemplate    = `{{$v := offset .FullName 6}}{{wrap .FullName 3}}{{if .Usage}} - {{wrap .Usage $v}}{{end}}`\n\targsTemplate        = `{{if .Arguments}}{{range .Arguments}}{{.Usage}}{{end}}{{end}}`\n\tusageTemplate       = `{{if .UsageText}}{{wrap .UsageText 3}}{{else}}{{.FullName}}{{if .VisibleFlags}} [command [command options]]{{end}}{{if .ArgsUsage}} {{.ArgsUsage}}{{else}}{{if .Arguments}} {{template \"argsTemplate\" .}}{{end}}{{end}}{{end}}`\n\tdescriptionTemplate = `{{wrap .Description 3}}`\n\tauthorsTemplate     = `{{with $length := len .Authors}}{{if ne 1 $length}}S{{end}}{{end}}:\n   {{range $index, $author := .Authors}}{{if $index}}\n   {{end}}{{$author}}{{end}}`\n)\n\nvar visibleCommandTemplate = `{{ $cv := offsetCommands .VisibleCommands 5}}{{range .VisibleCommands}}\n   {{$s := join .Names \", \"}}{{$s}}{{ $sp := subtract $cv (offset $s 3) }}{{ indent $sp \"\"}}{{wrap .Usage $cv}}{{end}}`\n\nvar visibleCommandCategoryTemplate = `{{range .VisibleCategories}}{{if .Name}}\n\n   {{.Name}}:{{range .VisibleCommands}}\n     {{join .Names \", \"}}{{\"\\t\"}}{{.Usage}}{{end}}{{else}}{{template \"visibleCommandTemplate\" .}}{{end}}{{end}}`\n\nvar visibleFlagCategoryTemplate = `{{range .VisibleFlagCategories}}\n   {{if .Name}}{{.Name}}\n\n   {{end}}{{$flglen := len .Flags}}{{range $i, $e := .Flags}}{{if eq (subtract $flglen $i) 1}}{{$e}}\n{{else}}{{$e}}\n   {{end}}{{end}}{{end}}`\n\nvar visibleFlagTemplate = `{{range $i, $e := .VisibleFlags}}\n   {{wrap $e.String 6}}{{end}}`\n\nvar visiblePersistentFlagTemplate = `{{range $i, $e := .VisiblePersistentFlags}}\n   {{wrap $e.String 6}}{{end}}`\n\nvar versionTemplate = `{{if .Version}}{{if not .HideVersion}}\n\nVERSION:\n   {{.Version}}{{end}}{{end}}`\n\nvar copyrightTemplate = `{{wrap .Copyright 3}}`\n\n// RootCommandHelpTemplate is the text template for the Default help topic.\n// cli.go uses text/template to render templates. You can\n// render custom help text by setting this variable.\nvar RootCommandHelpTemplate = `NAME:\n   {{template \"helpNameTemplate\" .}}\n\nUSAGE:\n   {{if .UsageText}}{{wrap .UsageText 3}}{{else}}{{.FullName}} {{if .VisibleFlags}}[global options]{{end}}{{if .VisibleCommands}} [command [command options]]{{end}}{{if .ArgsUsage}} {{.ArgsUsage}}{{else}}{{if .Arguments}} [arguments...]{{end}}{{end}}{{end}}{{if .Version}}{{if not .HideVersion}}\n\nVERSION:\n   {{.Version}}{{end}}{{end}}{{if .Description}}\n\nDESCRIPTION:\n   {{template \"descriptionTemplate\" .}}{{end}}\n{{- if len .Authors}}\n\nAUTHOR{{template \"authorsTemplate\" .}}{{end}}{{if .VisibleCommands}}\n\nCOMMANDS:{{template \"visibleCommandCategoryTemplate\" .}}{{end}}{{if .VisibleFlagCategories}}\n\nGLOBAL OPTIONS:{{template \"visibleFlagCategoryTemplate\" .}}{{else if .VisibleFlags}}\n\nGLOBAL OPTIONS:{{template \"visibleFlagTemplate\" .}}{{end}}{{if .Copyright}}\n\nCOPYRIGHT:\n   {{template \"copyrightTemplate\" .}}{{end}}\n`\n\n// CommandHelpTemplate is the text template for the command help topic.\n// cli.go uses text/template to render templates. You can\n// render custom help text by setting this variable.\nvar CommandHelpTemplate = `NAME:\n   {{template \"helpNameTemplate\" .}}\n\nUSAGE:\n   {{template \"usageTemplate\" .}}{{if .Category}}\n\nCATEGORY:\n   {{.Category}}{{end}}{{if .Description}}\n\nDESCRIPTION:\n   {{template \"descriptionTemplate\" .}}{{end}}{{if .VisibleFlagCategories}}\n\nOPTIONS:{{template \"visibleFlagCategoryTemplate\" .}}{{else if .VisibleFlags}}\n\nOPTIONS:{{template \"visibleFlagTemplate\" .}}{{end}}{{if .VisiblePersistentFlags}}\n\nGLOBAL OPTIONS:{{template \"visiblePersistentFlagTemplate\" .}}{{end}}\n`\n\n// SubcommandHelpTemplate is the text template for the subcommand help topic.\n// cli.go uses text/template to render templates. You can\n// render custom help text by setting this variable.\nvar SubcommandHelpTemplate = `NAME:\n   {{template \"helpNameTemplate\" .}}\n\nUSAGE:\n   {{if .UsageText}}{{wrap .UsageText 3}}{{else}}{{.FullName}}{{if .VisibleCommands}} [command [command options]] {{end}}{{if .ArgsUsage}} {{.ArgsUsage}}{{else}}{{if .Arguments}} [arguments...]{{end}}{{end}}{{end}}{{if .Category}}\n\nCATEGORY:\n   {{.Category}}{{end}}{{if .Description}}\n\nDESCRIPTION:\n   {{template \"descriptionTemplate\" .}}{{end}}{{if .VisibleCommands}}\n\nCOMMANDS:{{template \"visibleCommandTemplate\" .}}{{end}}{{if .VisibleFlagCategories}}\n\nOPTIONS:{{template \"visibleFlagCategoryTemplate\" .}}{{else if .VisibleFlags}}\n\nOPTIONS:{{template \"visibleFlagTemplate\" .}}{{end}}\n`\n\nvar FishCompletionTemplate = `# {{ .Command.Name }} fish shell completion\n\nfunction __fish_{{ .Command.Name }}_no_subcommand --description 'Test if there has been any subcommand yet'\n    for i in (commandline -opc)\n        if contains -- $i{{ range $v := .AllCommands }} {{ $v }}{{ end }}\n            return 1\n        end\n    end\n    return 0\nend\n\n{{ range $v := .Completions }}{{ $v }}\n{{ end }}`\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "value_source.go",
          "type": "blob",
          "size": 5.4970703125,
          "content": "package cli\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\n// ValueSource is a source which can be used to look up a value,\n// typically for use with a cli.Flag\ntype ValueSource interface {\n\tfmt.Stringer\n\tfmt.GoStringer\n\n\t// Lookup returns the value from the source and if it was found\n\t// or returns an empty string and false\n\tLookup() (string, bool)\n}\n\n// EnvValueSource is to specifically detect env sources when\n// printing help text\ntype EnvValueSource interface {\n\tIsFromEnv() bool\n\tKey() string\n}\n\n// MapSource is a source which can be used to look up a value\n// based on a key\n// typically for use with a cli.Flag\ntype MapSource interface {\n\tfmt.Stringer\n\tfmt.GoStringer\n\n\t// Lookup returns the value from the source based on key\n\t// and if it was found\n\t// or returns an empty string and false\n\tLookup(string) (any, bool)\n}\n\n// ValueSourceChain contains an ordered series of ValueSource that\n// allows for lookup where the first ValueSource to resolve is\n// returned\ntype ValueSourceChain struct {\n\tChain []ValueSource\n}\n\nfunc NewValueSourceChain(src ...ValueSource) ValueSourceChain {\n\treturn ValueSourceChain{\n\t\tChain: src,\n\t}\n}\n\nfunc (vsc *ValueSourceChain) Append(other ValueSourceChain) {\n\tvsc.Chain = append(vsc.Chain, other.Chain...)\n}\n\nfunc (vsc *ValueSourceChain) EnvKeys() []string {\n\tvals := []string{}\n\n\tfor _, src := range vsc.Chain {\n\t\tif v, ok := src.(EnvValueSource); ok && v.IsFromEnv() {\n\t\t\tvals = append(vals, v.Key())\n\t\t}\n\t}\n\n\treturn vals\n}\n\nfunc (vsc *ValueSourceChain) String() string {\n\ts := []string{}\n\n\tfor _, vs := range vsc.Chain {\n\t\ts = append(s, vs.String())\n\t}\n\n\treturn strings.Join(s, \",\")\n}\n\nfunc (vsc *ValueSourceChain) GoString() string {\n\ts := []string{}\n\n\tfor _, vs := range vsc.Chain {\n\t\ts = append(s, vs.GoString())\n\t}\n\n\treturn fmt.Sprintf(\"&ValueSourceChain{Chain:{%[1]s}}\", strings.Join(s, \",\"))\n}\n\nfunc (vsc *ValueSourceChain) Lookup() (string, bool) {\n\ts, _, ok := vsc.LookupWithSource()\n\treturn s, ok\n}\n\nfunc (vsc *ValueSourceChain) LookupWithSource() (string, ValueSource, bool) {\n\tfor _, src := range vsc.Chain {\n\t\tif value, found := src.Lookup(); found {\n\t\t\treturn value, src, true\n\t\t}\n\t}\n\n\treturn \"\", nil, false\n}\n\n// envVarValueSource encapsulates a ValueSource from an environment variable\ntype envVarValueSource struct {\n\tkey string\n}\n\nfunc (e *envVarValueSource) Lookup() (string, bool) {\n\treturn os.LookupEnv(strings.TrimSpace(string(e.key)))\n}\n\nfunc (e *envVarValueSource) IsFromEnv() bool {\n\treturn true\n}\n\nfunc (e *envVarValueSource) Key() string {\n\treturn e.key\n}\n\nfunc (e *envVarValueSource) String() string { return fmt.Sprintf(\"environment variable %[1]q\", e.key) }\nfunc (e *envVarValueSource) GoString() string {\n\treturn fmt.Sprintf(\"&envVarValueSource{Key:%[1]q}\", e.key)\n}\n\nfunc EnvVar(key string) ValueSource {\n\treturn &envVarValueSource{\n\t\tkey: key,\n\t}\n}\n\n// EnvVars is a helper function to encapsulate a number of\n// envVarValueSource together as a ValueSourceChain\nfunc EnvVars(keys ...string) ValueSourceChain {\n\tvsc := ValueSourceChain{Chain: []ValueSource{}}\n\n\tfor _, key := range keys {\n\t\tvsc.Chain = append(vsc.Chain, EnvVar(key))\n\t}\n\n\treturn vsc\n}\n\n// fileValueSource encapsulates a ValueSource from a file\ntype fileValueSource struct {\n\tPath string\n}\n\nfunc (f *fileValueSource) Lookup() (string, bool) {\n\tdata, err := os.ReadFile(f.Path)\n\treturn string(data), err == nil\n}\n\nfunc (f *fileValueSource) String() string { return fmt.Sprintf(\"file %[1]q\", f.Path) }\nfunc (f *fileValueSource) GoString() string {\n\treturn fmt.Sprintf(\"&fileValueSource{Path:%[1]q}\", f.Path)\n}\n\nfunc File(path string) ValueSource {\n\treturn &fileValueSource{Path: path}\n}\n\n// Files is a helper function to encapsulate a number of\n// fileValueSource together as a ValueSourceChain\nfunc Files(paths ...string) ValueSourceChain {\n\tvsc := ValueSourceChain{Chain: []ValueSource{}}\n\n\tfor _, path := range paths {\n\t\tvsc.Chain = append(vsc.Chain, File(path))\n\t}\n\n\treturn vsc\n}\n\ntype mapSource struct {\n\tname string\n\tm    map[any]any\n}\n\nfunc NewMapSource(name string, m map[any]any) MapSource {\n\treturn &mapSource{\n\t\tname: name,\n\t\tm:    m,\n\t}\n}\n\nfunc (ms *mapSource) String() string { return fmt.Sprintf(\"map source %[1]q\", ms.name) }\nfunc (ms *mapSource) GoString() string {\n\treturn fmt.Sprintf(\"&mapSource{name:%[1]q}\", ms.name)\n}\n\nfunc (ms *mapSource) Lookup(name string) (any, bool) {\n\t// nestedVal checks if the name has '.' delimiters.\n\t// If so, it tries to traverse the tree by the '.' delimited sections to find\n\t// a nested value for the key.\n\tif sections := strings.Split(name, \".\"); len(sections) > 1 {\n\t\tnode := ms.m\n\t\tfor _, section := range sections[:len(sections)-1] {\n\t\t\tchild, ok := node[section]\n\t\t\tif !ok {\n\t\t\t\treturn nil, false\n\t\t\t}\n\n\t\t\tswitch child := child.(type) {\n\t\t\tcase map[string]any:\n\t\t\t\tnode = make(map[any]any, len(child))\n\t\t\t\tfor k, v := range child {\n\t\t\t\t\tnode[k] = v\n\t\t\t\t}\n\t\t\tcase map[any]any:\n\t\t\t\tnode = child\n\t\t\tdefault:\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t}\n\t\tif val, ok := node[sections[len(sections)-1]]; ok {\n\t\t\treturn val, true\n\t\t}\n\t}\n\n\treturn nil, false\n}\n\ntype mapValueSource struct {\n\tkey string\n\tms  MapSource\n}\n\nfunc NewMapValueSource(key string, ms MapSource) ValueSource {\n\treturn &mapValueSource{\n\t\tkey: key,\n\t\tms:  ms,\n\t}\n}\n\nfunc (mvs *mapValueSource) String() string {\n\treturn fmt.Sprintf(\"key %[1]q from %[2]s\", mvs.key, mvs.ms.String())\n}\n\nfunc (mvs *mapValueSource) GoString() string {\n\treturn fmt.Sprintf(\"&mapValueSource{key:%[1]q, src:%[2]s}\", mvs.key, mvs.ms.GoString())\n}\n\nfunc (mvs *mapValueSource) Lookup() (string, bool) {\n\tif v, ok := mvs.ms.Lookup(mvs.key); !ok {\n\t\treturn \"\", false\n\t} else {\n\t\treturn fmt.Sprintf(\"%+v\", v), true\n\t}\n}\n"
        },
        {
          "name": "value_source_test.go",
          "type": "blob",
          "size": 6.7919921875,
          "content": "package cli\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestZeroValueSourceChain(t *testing.T) {\n\tvar vc ValueSourceChain\n\tassert.Empty(t, vc.EnvKeys())\n\tassert.NotEmpty(t, vc.GoString())\n\tassert.Empty(t, vc.Chain)\n\tassert.Empty(t, vc.String())\n}\n\nfunc TestEnvVarValueSource(t *testing.T) {\n\tt.Run(\"implements ValueSource\", func(t *testing.T) {\n\t\tsrc := EnvVar(\"foo\")\n\t\trequire.Implements(t, (*ValueSource)(nil), src)\n\n\t\tt.Run(\"not found\", func(t *testing.T) {\n\t\t\tt.Setenv(\"foo\", \"bar\")\n\n\t\t\tsrc := EnvVar(\"foo_1\")\n\t\t\t_, ok := src.Lookup()\n\t\t\trequire.False(t, ok)\n\t\t})\n\n\t\tt.Run(\"found\", func(t *testing.T) {\n\t\t\tt.Setenv(\"foo\", \"bar\")\n\n\t\t\tr := require.New(t)\n\t\t\tsrc := EnvVar(\"foo\")\n\n\t\t\tstr, ok := src.Lookup()\n\t\t\tr.True(ok)\n\t\t\tr.Equal(str, \"bar\")\n\t\t})\n\t})\n\n\tt.Run(\"implements fmt.Stringer\", func(t *testing.T) {\n\t\tsrc := EnvVar(\"foo\")\n\t\tr := require.New(t)\n\n\t\tr.Implements((*fmt.Stringer)(nil), src)\n\t\tr.Equal(\"environment variable \\\"foo\\\"\", src.String())\n\t})\n\n\tt.Run(\"implements fmt.GoStringer\", func(t *testing.T) {\n\t\tsrc := EnvVar(\"foo\")\n\t\tr := require.New(t)\n\n\t\tr.Implements((*fmt.GoStringer)(nil), src)\n\t\tr.Equal(\"&envVarValueSource{Key:\\\"foo\\\"}\", src.GoString())\n\t})\n}\n\nfunc TestEnvVars(t *testing.T) {\n\tt.Setenv(\"myfoo\", \"mybar\")\n\n\tsource := EnvVars(\"foo1\", \"myfoo\")\n\tstr, src, ok := source.LookupWithSource()\n\n\tr := require.New(t)\n\tr.True(ok)\n\tr.Equal(str, \"mybar\")\n\tr.Contains(src.String(), \"\\\"myfoo\\\"\")\n}\n\nfunc TestFileValueSource(t *testing.T) {\n\tt.Run(\"implements ValueSource\", func(t *testing.T) {\n\t\tr := require.New(t)\n\n\t\tr.Implements((*ValueSource)(nil), &fileValueSource{})\n\n\t\tt.Run(\"not found\", func(t *testing.T) {\n\t\t\tsrc := File(fmt.Sprintf(\"junk_file_name-%[1]v\", rand.Int()))\n\t\t\t_, ok := src.Lookup()\n\t\t\tr.False(ok)\n\t\t})\n\n\t\tfileName := filepath.Join(os.TempDir(), fmt.Sprintf(\"urfave-cli-testing-existing_file-%[1]v\", rand.Int()))\n\t\tt.Cleanup(func() { _ = os.Remove(fileName) })\n\n\t\tr.Nil(os.WriteFile(fileName, []byte(\"pita\"), 0o644))\n\n\t\tt.Run(\"found\", func(t *testing.T) {\n\t\t\tsrc := File(fileName)\n\t\t\tstr, ok := src.Lookup()\n\t\t\tr.True(ok)\n\t\t\tr.Equal(\"pita\", str)\n\t\t})\n\t})\n\n\tt.Run(\"implements fmt.Stringer\", func(t *testing.T) {\n\t\tsrc := File(\"/dev/null\")\n\t\tr := require.New(t)\n\n\t\tr.Implements((*ValueSource)(nil), src)\n\t\tr.Equal(\"file \\\"/dev/null\\\"\", src.String())\n\t})\n\n\tt.Run(\"implements fmt.GoStringer\", func(t *testing.T) {\n\t\tsrc := File(\"/dev/null\")\n\t\tr := require.New(t)\n\n\t\tr.Implements((*ValueSource)(nil), src)\n\t\tr.Equal(\"&fileValueSource{Path:\\\"/dev/null\\\"}\", src.GoString())\n\t})\n}\n\nfunc TestFilePaths(t *testing.T) {\n\tr := require.New(t)\n\n\tfileName := filepath.Join(os.TempDir(), fmt.Sprintf(\"urfave-cli-tests-some_file_name_%[1]v\", rand.Int()))\n\tt.Cleanup(func() { _ = os.Remove(fileName) })\n\n\tr.Nil(os.WriteFile(fileName, []byte(\"Hello\"), 0o644))\n\n\tsources := Files(\"junk_file_name\", fileName)\n\tstr, src, ok := sources.LookupWithSource()\n\tr.True(ok)\n\tr.Equal(str, \"Hello\")\n\tr.Contains(src.String(), fmt.Sprintf(\"%[1]q\", fileName))\n}\n\nfunc TestValueSourceChainEnvKeys(t *testing.T) {\n\tchain := NewValueSourceChain(\n\t\t&staticValueSource{\"hello\"},\n\t)\n\tchain.Append(EnvVars(\"foo\", \"bar\"))\n\n\tr := require.New(t)\n\tr.Equal([]string{\"foo\", \"bar\"}, chain.EnvKeys())\n}\n\nfunc TestValueSourceChain(t *testing.T) {\n\tt.Run(\"implements ValueSource\", func(t *testing.T) {\n\t\tvsc := &ValueSourceChain{}\n\t\tr := require.New(t)\n\n\t\tr.Implements((*ValueSource)(nil), vsc)\n\n\t\t_, ok := vsc.Lookup()\n\t\tr.False(ok)\n\t})\n\n\tt.Run(\"implements fmt.GoStringer\", func(t *testing.T) {\n\t\tvsc := &ValueSourceChain{}\n\t\tr := require.New(t)\n\n\t\tr.Implements((*fmt.GoStringer)(nil), vsc)\n\t\tr.Equal(\"&ValueSourceChain{Chain:{}}\", vsc.GoString())\n\n\t\tvsc1 := NewValueSourceChain(&staticValueSource{v: \"yahtzee\"},\n\t\t\t&staticValueSource{v: \"matzoh\"},\n\t\t)\n\t\tr.Equal(\"&ValueSourceChain{Chain:{&staticValueSource{v:\\\"yahtzee\\\"},&staticValueSource{v:\\\"matzoh\\\"}}}\", vsc1.GoString())\n\t})\n\n\tt.Run(\"implements fmt.Stringer\", func(t *testing.T) {\n\t\tvsc := &ValueSourceChain{}\n\t\tr := require.New(t)\n\n\t\tr.Implements((*fmt.Stringer)(nil), vsc)\n\t\tr.Equal(\"\", vsc.String())\n\n\t\tvsc1 := NewValueSourceChain(\n\t\t\t&staticValueSource{v: \"soup\"},\n\t\t\t&staticValueSource{v: \"salad\"},\n\t\t\t&staticValueSource{v: \"pumpkins\"},\n\t\t)\n\t\tr.Equal(\"soup,salad,pumpkins\", vsc1.String())\n\t})\n}\n\ntype staticValueSource struct {\n\tv string\n}\n\nfunc (svs *staticValueSource) GoString() string {\n\treturn fmt.Sprintf(\"&staticValueSource{v:%[1]q}\", svs.v)\n}\nfunc (svs *staticValueSource) String() string         { return svs.v }\nfunc (svs *staticValueSource) Lookup() (string, bool) { return svs.v, true }\n\nfunc TestMapValueSource(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\tm     map[any]any\n\t\tkey   string\n\t\tval   string\n\t\tfound bool\n\t}{\n\t\t{\n\t\t\tname: \"No map no key\",\n\t\t},\n\t\t{\n\t\t\tname: \"No map with key\",\n\t\t\tkey:  \"foo\",\n\t\t},\n\t\t{\n\t\t\tname: \"Empty map no key\",\n\t\t\tm:    map[any]any{},\n\t\t},\n\t\t{\n\t\t\tname: \"Empty map with key\",\n\t\t\tkey:  \"foo\",\n\t\t\tm:    map[any]any{},\n\t\t},\n\t\t{\n\t\t\tname: \"Level 1 no key\",\n\t\t\tkey:  \".foob\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": 10,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Level 2\",\n\t\t\tkey:  \"foo.bar\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": map[any]any{\n\t\t\t\t\t\"bar\": 10,\n\t\t\t\t},\n\t\t\t},\n\t\t\tval:   \"10\",\n\t\t\tfound: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Level 2 invalid key\",\n\t\t\tkey:  \"foo.bar1\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": map[any]any{\n\t\t\t\t\t\"bar\": \"10\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Level 3 no entry\",\n\t\t\tkey:  \"foo.bar.t\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": map[any]any{\n\t\t\t\t\t\"bar\": \"sss\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Level 3\",\n\t\t\tkey:  \"foo.bar.t\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": map[any]any{\n\t\t\t\t\t\"bar\": map[any]any{\n\t\t\t\t\t\t\"t\": \"sss\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tval:   \"sss\",\n\t\t\tfound: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Level 3 invalid key\",\n\t\t\tkey:  \"foo.bar.t\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": map[any]any{\n\t\t\t\t\t\"bar\": map[any]any{\n\t\t\t\t\t\t\"t1\": 10,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Level 4 no entry\",\n\t\t\tkey:  \"foo.bar.t.gh\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": map[any]any{\n\t\t\t\t\t\"bar\": map[any]any{\n\t\t\t\t\t\t\"t1\": 10,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Level 4 slice entry\",\n\t\t\tkey:  \"foo.bar.t.gh\",\n\t\t\tm: map[any]any{\n\t\t\t\t\"foo\": map[any]any{\n\t\t\t\t\t\"bar\": map[string]any{\n\t\t\t\t\t\t\"t\": map[any]any{\n\t\t\t\t\t\t\t\"gh\": []int{10},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tval:   \"[10]\",\n\t\t\tfound: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.key, func(t *testing.T) {\n\t\t\tms := NewMapSource(\"test\", test.m)\n\t\t\tm := NewMapValueSource(test.key, ms)\n\t\t\tval, b := m.Lookup()\n\t\t\tif !test.found {\n\t\t\t\tassert.False(t, b)\n\t\t\t} else {\n\t\t\t\tassert.True(t, b)\n\t\t\t\tassert.Equal(t, val, test.val)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMapValueSourceStringer(t *testing.T) {\n\tm := map[any]any{\n\t\t\"foo\": map[any]any{\n\t\t\t\"bar\": 10,\n\t\t},\n\t}\n\tmvs := NewMapValueSource(\"bar\", NewMapSource(\"test\", m))\n\n\tassert.Equal(t, `&mapValueSource{key:\"bar\", src:&mapSource{name:\"test\"}}`, mvs.GoString())\n\tassert.Equal(t, `key \"bar\" from map source \"test\"`, mvs.String())\n}\n"
        }
      ]
    }
  ]
}