{
  "metadata": {
    "timestamp": 1736567988114,
    "page": 126,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "PuerkitoBio/goquery",
      "stars": 14182,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0283203125,
          "content": "testdata/* linguist-vendored\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1474609375,
          "content": "# editor temporary files\n*.sublime-*\n.DS_Store\n*.swp\n#*.*#\ntags\n\n# direnv config\n.env*\n\n# test binaries\n*.test\n\n# coverage and profilte outputs\n*.out\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4560546875,
          "content": "Copyright (c) 2012-2021, Martin Angers & Contributors\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n* Neither the name of the author nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.70703125,
          "content": "# goquery - a little like that j-thing, only in Go\n\n[![Build Status](https://github.com/PuerkitoBio/goquery/actions/workflows/test.yml/badge.svg?branch=master)](https://github.com/PuerkitoBio/goquery/actions)\n[![Go Reference](https://pkg.go.dev/badge/github.com/PuerkitoBio/goquery.svg)](https://pkg.go.dev/github.com/PuerkitoBio/goquery)\n[![Sourcegraph Badge](https://sourcegraph.com/github.com/PuerkitoBio/goquery/-/badge.svg)](https://sourcegraph.com/github.com/PuerkitoBio/goquery?badge)\n\ngoquery brings a syntax and a set of features similar to [jQuery][] to the [Go language][go]. It is based on Go's [net/html package][html] and the CSS Selector library [cascadia][]. Since the net/html parser returns nodes, and not a full-featured DOM tree, jQuery's stateful manipulation functions (like height(), css(), detach()) have been left off.\n\nAlso, because the net/html parser requires UTF-8 encoding, so does goquery: it is the caller's responsibility to ensure that the source document provides UTF-8 encoded HTML. See the [wiki][] for various options to do this.\n\nSyntax-wise, it is as close as possible to jQuery, with the same function names when possible, and that warm and fuzzy chainable interface. jQuery being the ultra-popular library that it is, I felt that writing a similar HTML-manipulating library was better to follow its API than to start anew (in the same spirit as Go's `fmt` package), even though some of its methods are less than intuitive (looking at you, [index()][index]...).\n\n## Table of Contents\n\n* [Installation](#installation)\n* [Changelog](#changelog)\n* [API](#api)\n* [Examples](#examples)\n* [Related Projects](#related-projects)\n* [Support](#support)\n* [License](#license)\n\n## Installation\n\nRequired Go version:\n\n* Starting with version `v1.10.0` of goquery, Go 1.23+ is required due to the use of function-based iterators. \n* For `v1.9.0` of goquery, Go 1.18+ is required due to the use of generics. \n* For previous goquery versions, a Go version of 1.1+ was required because of the `net/html` dependency. \n\nOngoing goquery development is tested on the latest 2 versions of Go.\n\n    $ go get github.com/PuerkitoBio/goquery\n\n(optional) To run unit tests:\n\n    $ cd $GOPATH/src/github.com/PuerkitoBio/goquery\n    $ go test\n\n(optional) To run benchmarks (warning: it runs for a few minutes):\n\n    $ cd $GOPATH/src/github.com/PuerkitoBio/goquery\n    $ go test -bench=\".*\"\n\n## Changelog\n\n**Note that goquery's API is now stable, and will not break.**\n\n*    **2024-12-26 (v1.10.1)** : Update `go.mod` dependencies.\n*    **2024-09-06 (v1.10.0)** : Add `EachIter` which provides an iterator that can be used in `for..range` loops on the `*Selection` object. **goquery now requires Go version 1.23+** (thanks [@amikai](https://github.com/amikai)).\n*    **2024-09-06 (v1.9.3)** : Update `go.mod` dependencies.\n*    **2024-04-29 (v1.9.2)** : Update `go.mod` dependencies.\n*    **2024-02-29 (v1.9.1)** : Improve allocation and performance of the `Map` function and `Selection.Map` method, better document the cascadia differences (thanks [@jwilsson](https://github.com/jwilsson)).\n*    **2024-02-22 (v1.9.0)** : Add a generic `Map` function, **goquery now requires Go version 1.18+** (thanks [@Fesaa](https://github.com/Fesaa)).\n*    **2023-02-18 (v1.8.1)** : Update `go.mod` dependencies, update CI workflow.\n*    **2021-10-25 (v1.8.0)** : Add `Render` function to render a `Selection` to an `io.Writer` (thanks [@anthonygedeon](https://github.com/anthonygedeon)).\n*    **2021-07-11 (v1.7.1)** : Update go.mod dependencies and add dependabot config (thanks [@jauderho](https://github.com/jauderho)).\n*    **2021-06-14 (v1.7.0)** : Add `Single` and `SingleMatcher` functions to optimize first-match selection (thanks [@gdollardollar](https://github.com/gdollardollar)).\n*    **2021-01-11 (v1.6.1)** : Fix panic when calling `{Prepend,Append,Set}Html` on a `Selection` that contains non-Element nodes.\n*    **2020-10-08 (v1.6.0)** : Parse html in context of the container node for all functions that deal with html strings (`AfterHtml`, `AppendHtml`, etc.). Thanks to [@thiemok][thiemok] and [@davidjwilkins][djw] for their work on this.\n*    **2020-02-04 (v1.5.1)** : Update module dependencies.\n*    **2018-11-15 (v1.5.0)** : Go module support (thanks @Zaba505).\n*    **2018-06-07 (v1.4.1)** : Add `NewDocumentFromReader` examples.\n*    **2018-03-24 (v1.4.0)** : Deprecate `NewDocument(url)` and `NewDocumentFromResponse(response)`.\n*    **2018-01-28 (v1.3.0)** : Add `ToEnd` constant to `Slice` until the end of the selection (thanks to @davidjwilkins for raising the issue).\n*    **2018-01-11 (v1.2.0)** : Add `AddBack*` and deprecate `AndSelf` (thanks to @davidjwilkins).\n*    **2017-02-12 (v1.1.0)** : Add `SetHtml` and `SetText` (thanks to @glebtv).\n*    **2016-12-29 (v1.0.2)** : Optimize allocations for `Selection.Text` (thanks to @radovskyb).\n*    **2016-08-28 (v1.0.1)** : Optimize performance for large documents.\n*    **2016-07-27 (v1.0.0)** : Tag version 1.0.0.\n*    **2016-06-15** : Invalid selector strings internally compile to a `Matcher` implementation that never matches any node (instead of a panic). So for example, `doc.Find(\"~\")` returns an empty `*Selection` object.\n*    **2016-02-02** : Add `NodeName` utility function similar to the DOM's `nodeName` property. It returns the tag name of the first element in a selection, and other relevant values of non-element nodes (see [doc][] for details). Add `OuterHtml` utility function similar to the DOM's `outerHTML` property (named `OuterHtml` in small caps for consistency with the existing `Html` method on the `Selection`).\n*    **2015-04-20** : Add `AttrOr` helper method to return the attribute's value or a default value if absent. Thanks to [piotrkowalczuk][piotr].\n*    **2015-02-04** : Add more manipulation functions - Prepend* - thanks again to [Andrew Stone][thatguystone].\n*    **2014-11-28** : Add more manipulation functions - ReplaceWith*, Wrap* and Unwrap - thanks again to [Andrew Stone][thatguystone].\n*    **2014-11-07** : Add manipulation functions (thanks to [Andrew Stone][thatguystone]) and `*Matcher` functions, that receive compiled cascadia selectors instead of selector strings, thus avoiding potential panics thrown by goquery via `cascadia.MustCompile` calls. This results in better performance (selectors can be compiled once and reused) and more idiomatic error handling (you can handle cascadia's compilation errors, instead of recovering from panics, which had been bugging me for a long time). Note that the actual type expected is a `Matcher` interface, that `cascadia.Selector` implements. Other matcher implementations could be used.\n*    **2014-11-06** : Change import paths of net/html to golang.org/x/net/html (see https://groups.google.com/forum/#!topic/golang-nuts/eD8dh3T9yyA). Make sure to update your code to use the new import path too when you call goquery with `html.Node`s.\n*    **v0.3.2** : Add `NewDocumentFromReader()` (thanks jweir) which allows creating a goquery document from an io.Reader.\n*    **v0.3.1** : Add `NewDocumentFromResponse()` (thanks assassingj) which allows creating a goquery document from an http response.\n*    **v0.3.0** : Add `EachWithBreak()` which allows to break out of an `Each()` loop by returning false. This function was added instead of changing the existing `Each()` to avoid breaking compatibility.\n*    **v0.2.1** : Make go-getable, now that [go.net/html is Go1.0-compatible][gonet] (thanks to @matrixik for pointing this out).\n*    **v0.2.0** : Add support for negative indices in Slice(). **BREAKING CHANGE** `Document.Root` is removed, `Document` is now a `Selection` itself (a selection of one, the root element, just like `Document.Root` was before). Add jQuery's Closest() method.\n*    **v0.1.1** : Add benchmarks to use as baseline for refactorings, refactor Next...() and Prev...() methods to use the new html package's linked list features (Next/PrevSibling, FirstChild). Good performance boost (40+% in some cases).\n*    **v0.1.0** : Initial release.\n\n## API\n\ngoquery exposes two structs, `Document` and `Selection`, and the `Matcher` interface. Unlike jQuery, which is loaded as part of a DOM document, and thus acts on its containing document, goquery doesn't know which HTML document to act upon. So it needs to be told, and that's what the `Document` type is for. It holds the root document node as the initial Selection value to manipulate.\n\njQuery often has many variants for the same function (no argument, a selector string argument, a jQuery object argument, a DOM element argument, ...). Instead of exposing the same features in goquery as a single method with variadic empty interface arguments, statically-typed signatures are used following this naming convention:\n\n*    When the jQuery equivalent can be called with no argument, it has the same name as jQuery for the no argument signature (e.g.: `Prev()`), and the version with a selector string argument is called `XxxFiltered()` (e.g.: `PrevFiltered()`)\n*    When the jQuery equivalent **requires** one argument, the same name as jQuery is used for the selector string version (e.g.: `Is()`)\n*    The signatures accepting a jQuery object as argument are defined in goquery as `XxxSelection()` and take a `*Selection` object as argument (e.g.: `FilterSelection()`)\n*    The signatures accepting a DOM element as argument in jQuery are defined in goquery as `XxxNodes()` and take a variadic argument of type `*html.Node` (e.g.: `FilterNodes()`)\n*    The signatures accepting a function as argument in jQuery are defined in goquery as `XxxFunction()` and take a function as argument (e.g.: `FilterFunction()`)\n*    The goquery methods that can be called with a selector string have a corresponding version that take a `Matcher` interface and are defined as `XxxMatcher()` (e.g.: `IsMatcher()`)\n\nUtility functions that are not in jQuery but are useful in Go are implemented as functions (that take a `*Selection` as parameter), to avoid a potential naming clash on the `*Selection`'s methods (reserved for jQuery-equivalent behaviour).\n\nThe complete [package reference documentation can be found here][doc].\n\nPlease note that Cascadia's selectors do not necessarily match all supported selectors of jQuery (Sizzle). See the [cascadia project][cascadia] for details. Also, the selectors work more like the DOM's `querySelectorAll`, than jQuery's matchers - they have no concept of contextual matching (for some concrete examples of what that means, see [this ticket](https://github.com/andybalholm/cascadia/issues/61)). In practice, it doesn't matter very often but it's something worth mentioning. Invalid selector strings compile to a `Matcher` that fails to match any node. Behaviour of the various functions that take a selector string as argument follows from that fact, e.g. (where `~` is an invalid selector string):\n\n* `Find(\"~\")` returns an empty selection because the selector string doesn't match anything.\n* `Add(\"~\")` returns a new selection that holds the same nodes as the original selection, because it didn't add any node (selector string didn't match anything).\n* `ParentsFiltered(\"~\")` returns an empty selection because the selector string doesn't match anything.\n* `ParentsUntil(\"~\")` returns all parents of the selection because the selector string didn't match any element to stop before the top element.\n\n## Examples\n\nSee some tips and tricks in the [wiki][].\n\nAdapted from example_test.go:\n\n```Go\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"net/http\"\n\n  \"github.com/PuerkitoBio/goquery\"\n)\n\nfunc ExampleScrape() {\n  // Request the HTML page.\n  res, err := http.Get(\"http://metalsucks.net\")\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer res.Body.Close()\n  if res.StatusCode != 200 {\n    log.Fatalf(\"status code error: %d %s\", res.StatusCode, res.Status)\n  }\n\n  // Load the HTML document\n  doc, err := goquery.NewDocumentFromReader(res.Body)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  // Find the review items\n  doc.Find(\".left-content article .post-title\").Each(func(i int, s *goquery.Selection) {\n\t\t// For each item found, get the title\n\t\ttitle := s.Find(\"a\").Text()\n\t\tfmt.Printf(\"Review %d: %s\\n\", i, title)\n\t})\n}\n\nfunc main() {\n  ExampleScrape()\n}\n```\n\n## Related Projects\n\n- [Goq][goq], an HTML deserialization and scraping library based on goquery and struct tags.\n- [andybalholm/cascadia][cascadia], the CSS selector library used by goquery.\n- [suntong/cascadia][cascadiacli], a command-line interface to the cascadia CSS selector library, useful to test selectors.\n- [gocolly/colly](https://github.com/gocolly/colly), a lightning fast and elegant Scraping Framework\n- [gnulnx/goperf](https://github.com/gnulnx/goperf), a website performance test tool that also fetches static assets.\n- [MontFerret/ferret](https://github.com/MontFerret/ferret), declarative web scraping.\n- [tacusci/berrycms](https://github.com/tacusci/berrycms), a modern simple to use CMS with easy to write plugins\n- [Dataflow kit](https://github.com/slotix/dataflowkit), Web Scraping framework for Gophers.\n- [Geziyor](https://github.com/geziyor/geziyor), a fast web crawling & scraping framework for Go. Supports JS rendering.\n- [Pagser](https://github.com/foolin/pagser), a simple, easy, extensible, configurable HTML parser to struct based on goquery and struct tags.\n- [stitcherd](https://github.com/vhodges/stitcherd), A server for doing server side includes using css selectors and DOM updates.\n- [goskyr](https://github.com/jakopako/goskyr), an easily configurable command-line scraper written in Go.\n- [goGetJS](https://github.com/davemolk/goGetJS), a tool for extracting, searching, and saving JavaScript files (with optional headless browser).\n- [fitter](https://github.com/PxyUp/fitter), a tool for selecting values from JSON, XML, HTML and XPath formatted pages.\n- [seltabl](github.com/conneroisu/seltabl), an orm-like package and supporting language server for extracting values from HTML\n\n## Support\n\nThere are a number of ways you can support the project:\n\n* Use it, star it, build something with it, spread the word!\n  - If you do build something open-source or otherwise publicly-visible, let me know so I can add it to the [Related Projects](#related-projects) section!\n* Raise issues to improve the project (note: doc typos and clarifications are issues too!)\n  - Please search existing issues before opening a new one - it may have already been addressed.\n* Pull requests: please discuss new code in an issue first, unless the fix is really trivial.\n  - Make sure new code is tested.\n  - Be mindful of existing code - PRs that break existing code have a high probability of being declined, unless it fixes a serious issue.\n* Sponsor the developer\n  - See the Github Sponsor button at the top of the repo on github\n  - or via BuyMeACoffee.com, below\n\n<a href=\"https://www.buymeacoffee.com/mna\" target=\"_blank\"><img src=\"https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png\" alt=\"Buy Me A Coffee\" style=\"height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;\" ></a>\n\n## License\n\nThe [BSD 3-Clause license][bsd], the same as the [Go language][golic]. Cascadia's license is [here][caslic].\n\n[jquery]: https://jquery.com/\n[go]: https://go.dev/\n[cascadia]: https://github.com/andybalholm/cascadia\n[cascadiacli]: https://github.com/suntong/cascadia\n[bsd]: https://opensource.org/licenses/BSD-3-Clause\n[golic]: https://go.dev/LICENSE\n[caslic]: https://github.com/andybalholm/cascadia/blob/master/LICENSE\n[doc]: https://pkg.go.dev/github.com/PuerkitoBio/goquery\n[index]: https://api.jquery.com/index/\n[gonet]: https://github.com/golang/net/\n[html]: https://pkg.go.dev/golang.org/x/net/html\n[wiki]: https://github.com/PuerkitoBio/goquery/wiki/Tips-and-tricks\n[thatguystone]: https://github.com/thatguystone\n[piotr]: https://github.com/piotrkowalczuk\n[goq]: https://github.com/andrewstuart/goq\n[thiemok]: https://github.com/thiemok\n[djw]: https://github.com/davidjwilkins\n"
        },
        {
          "name": "array.go",
          "type": "blob",
          "size": 3.7587890625,
          "content": "package goquery\n\nimport (\n\t\"golang.org/x/net/html\"\n)\n\nconst (\n\tmaxUint = ^uint(0)\n\tmaxInt  = int(maxUint >> 1)\n\n\t// ToEnd is a special index value that can be used as end index in a call\n\t// to Slice so that all elements are selected until the end of the Selection.\n\t// It is equivalent to passing (*Selection).Length().\n\tToEnd = maxInt\n)\n\n// First reduces the set of matched elements to the first in the set.\n// It returns a new Selection object, and an empty Selection object if the\n// the selection is empty.\nfunc (s *Selection) First() *Selection {\n\treturn s.Eq(0)\n}\n\n// Last reduces the set of matched elements to the last in the set.\n// It returns a new Selection object, and an empty Selection object if\n// the selection is empty.\nfunc (s *Selection) Last() *Selection {\n\treturn s.Eq(-1)\n}\n\n// Eq reduces the set of matched elements to the one at the specified index.\n// If a negative index is given, it counts backwards starting at the end of the\n// set. It returns a new Selection object, and an empty Selection object if the\n// index is invalid.\nfunc (s *Selection) Eq(index int) *Selection {\n\tif index < 0 {\n\t\tindex += len(s.Nodes)\n\t}\n\n\tif index >= len(s.Nodes) || index < 0 {\n\t\treturn newEmptySelection(s.document)\n\t}\n\n\treturn s.Slice(index, index+1)\n}\n\n// Slice reduces the set of matched elements to a subset specified by a range\n// of indices. The start index is 0-based and indicates the index of the first\n// element to select. The end index is 0-based and indicates the index at which\n// the elements stop being selected (the end index is not selected).\n//\n// The indices may be negative, in which case they represent an offset from the\n// end of the selection.\n//\n// The special value ToEnd may be specified as end index, in which case all elements\n// until the end are selected. This works both for a positive and negative start\n// index.\nfunc (s *Selection) Slice(start, end int) *Selection {\n\tif start < 0 {\n\t\tstart += len(s.Nodes)\n\t}\n\tif end == ToEnd {\n\t\tend = len(s.Nodes)\n\t} else if end < 0 {\n\t\tend += len(s.Nodes)\n\t}\n\treturn pushStack(s, s.Nodes[start:end])\n}\n\n// Get retrieves the underlying node at the specified index.\n// Get without parameter is not implemented, since the node array is available\n// on the Selection object.\nfunc (s *Selection) Get(index int) *html.Node {\n\tif index < 0 {\n\t\tindex += len(s.Nodes) // Negative index gets from the end\n\t}\n\treturn s.Nodes[index]\n}\n\n// Index returns the position of the first element within the Selection object\n// relative to its sibling elements.\nfunc (s *Selection) Index() int {\n\tif len(s.Nodes) > 0 {\n\t\treturn newSingleSelection(s.Nodes[0], s.document).PrevAll().Length()\n\t}\n\treturn -1\n}\n\n// IndexSelector returns the position of the first element within the\n// Selection object relative to the elements matched by the selector, or -1 if\n// not found.\nfunc (s *Selection) IndexSelector(selector string) int {\n\tif len(s.Nodes) > 0 {\n\t\tsel := s.document.Find(selector)\n\t\treturn indexInSlice(sel.Nodes, s.Nodes[0])\n\t}\n\treturn -1\n}\n\n// IndexMatcher returns the position of the first element within the\n// Selection object relative to the elements matched by the matcher, or -1 if\n// not found.\nfunc (s *Selection) IndexMatcher(m Matcher) int {\n\tif len(s.Nodes) > 0 {\n\t\tsel := s.document.FindMatcher(m)\n\t\treturn indexInSlice(sel.Nodes, s.Nodes[0])\n\t}\n\treturn -1\n}\n\n// IndexOfNode returns the position of the specified node within the Selection\n// object, or -1 if not found.\nfunc (s *Selection) IndexOfNode(node *html.Node) int {\n\treturn indexInSlice(s.Nodes, node)\n}\n\n// IndexOfSelection returns the position of the first node in the specified\n// Selection object within this Selection object, or -1 if not found.\nfunc (s *Selection) IndexOfSelection(sel *Selection) int {\n\tif sel != nil && len(sel.Nodes) > 0 {\n\t\treturn indexInSlice(s.Nodes, sel.Nodes[0])\n\t}\n\treturn -1\n}\n"
        },
        {
          "name": "array_test.go",
          "type": "blob",
          "size": 5.28125,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFirst(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").First()\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestFirstEmpty(t *testing.T) {\n\tsel := Doc().Find(\".pvk-zzcontentzz\").First()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestFirstInvalid(t *testing.T) {\n\tsel := Doc().Find(\"\").First()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestFirstRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.First().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestLast(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Last()\n\tassertLength(t, sel.Nodes, 1)\n\n\t// Should contain Footer\n\tfoot := Doc().Find(\".footer\")\n\tif !sel.Contains(foot.Nodes[0]) {\n\t\tt.Error(\"Last .pvk-content should contain .footer.\")\n\t}\n}\n\nfunc TestLastEmpty(t *testing.T) {\n\tsel := Doc().Find(\".pvk-zzcontentzz\").Last()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestLastInvalid(t *testing.T) {\n\tsel := Doc().Find(\"\").Last()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestLastRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Last().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestEq(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Eq(1)\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestEqNegative(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Eq(-1)\n\tassertLength(t, sel.Nodes, 1)\n\n\t// Should contain Footer\n\tfoot := Doc().Find(\".footer\")\n\tif !sel.Contains(foot.Nodes[0]) {\n\t\tt.Error(\"Index -1 of .pvk-content should contain .footer.\")\n\t}\n}\n\nfunc TestEqEmpty(t *testing.T) {\n\tsel := Doc().Find(\"something_random_that_does_not_exists\").Eq(0)\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestEqInvalid(t *testing.T) {\n\tsel := Doc().Find(\"\").Eq(0)\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestEqInvalidPositive(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Eq(3)\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestEqInvalidNegative(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Eq(-4)\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestEqRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Eq(1).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestSlice(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Slice(0, 2)\n\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel, \"#pc1\", \"#pc2\")\n}\n\nfunc TestSliceToEnd(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Slice(1, ToEnd)\n\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel.Eq(0), \"#pc2\")\n\tif _, ok := sel.Eq(1).Attr(\"id\"); ok {\n\t\tt.Error(\"Want no attribute ID, got one\")\n\t}\n}\n\nfunc TestSliceEmpty(t *testing.T) {\n\tdefer assertPanic(t)\n\tDoc().Find(\"x\").Slice(0, 2)\n}\n\nfunc TestSliceInvalid(t *testing.T) {\n\tdefer assertPanic(t)\n\tDoc().Find(\"\").Slice(0, 2)\n}\n\nfunc TestSliceInvalidToEnd(t *testing.T) {\n\tdefer assertPanic(t)\n\tDoc().Find(\"\").Slice(2, ToEnd)\n}\n\nfunc TestSliceOutOfBounds(t *testing.T) {\n\tdefer assertPanic(t)\n\tDoc().Find(\".pvk-content\").Slice(2, 12)\n}\n\nfunc TestNegativeSliceStart(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Slice(-2, 3)\n\tassertLength(t, sel.Nodes, 1)\n\tassertSelectionIs(t, sel.Eq(0), \"#cf3\")\n}\n\nfunc TestNegativeSliceEnd(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Slice(1, -1)\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel.Eq(0), \"#cf2\")\n\tassertSelectionIs(t, sel.Eq(1), \"#cf3\")\n}\n\nfunc TestNegativeSliceBoth(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Slice(-3, -1)\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel.Eq(0), \"#cf2\")\n\tassertSelectionIs(t, sel.Eq(1), \"#cf3\")\n}\n\nfunc TestNegativeSliceToEnd(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Slice(-3, ToEnd)\n\tassertLength(t, sel.Nodes, 3)\n\tassertSelectionIs(t, sel, \"#cf2\", \"#cf3\", \"#cf4\")\n}\n\nfunc TestNegativeSliceOutOfBounds(t *testing.T) {\n\tdefer assertPanic(t)\n\tDoc().Find(\".container-fluid\").Slice(-12, -7)\n}\n\nfunc TestSliceRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Slice(0, 2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestGet(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tnode := sel.Get(1)\n\tif sel.Nodes[1] != node {\n\t\tt.Errorf(\"Expected node %v to be %v.\", node, sel.Nodes[1])\n\t}\n}\n\nfunc TestGetNegative(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tnode := sel.Get(-3)\n\tif sel.Nodes[0] != node {\n\t\tt.Errorf(\"Expected node %v to be %v.\", node, sel.Nodes[0])\n\t}\n}\n\nfunc TestGetInvalid(t *testing.T) {\n\tdefer assertPanic(t)\n\tsel := Doc().Find(\".pvk-content\")\n\tsel.Get(129)\n}\n\nfunc TestIndex(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tif i := sel.Index(); i != 1 {\n\t\tt.Errorf(\"Expected index of 1, got %v.\", i)\n\t}\n}\n\nfunc TestIndexSelector(t *testing.T) {\n\tsel := Doc().Find(\".hero-unit\")\n\tif i := sel.IndexSelector(\"div\"); i != 4 {\n\t\tt.Errorf(\"Expected index of 4, got %v.\", i)\n\t}\n}\n\nfunc TestIndexSelectorInvalid(t *testing.T) {\n\tsel := Doc().Find(\".hero-unit\")\n\tif i := sel.IndexSelector(\"\"); i != -1 {\n\t\tt.Errorf(\"Expected index of -1, got %v.\", i)\n\t}\n}\n\nfunc TestIndexOfNode(t *testing.T) {\n\tsel := Doc().Find(\"div.pvk-gutter\")\n\tif i := sel.IndexOfNode(sel.Nodes[1]); i != 1 {\n\t\tt.Errorf(\"Expected index of 1, got %v.\", i)\n\t}\n}\n\nfunc TestIndexOfNilNode(t *testing.T) {\n\tsel := Doc().Find(\"div.pvk-gutter\")\n\tif i := sel.IndexOfNode(nil); i != -1 {\n\t\tt.Errorf(\"Expected index of -1, got %v.\", i)\n\t}\n}\n\nfunc TestIndexOfSelection(t *testing.T) {\n\tsel := Doc().Find(\"div\")\n\tsel2 := Doc().Find(\".hero-unit\")\n\tif i := sel.IndexOfSelection(sel2); i != 4 {\n\t\tt.Errorf(\"Expected index of 4, got %v.\", i)\n\t}\n}\n"
        },
        {
          "name": "bench",
          "type": "tree",
          "content": null
        },
        {
          "name": "bench_array_test.go",
          "type": "blob",
          "size": 1.876953125,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkFirst(b *testing.B) {\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.First()\n\t}\n}\n\nfunc BenchmarkLast(b *testing.B) {\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.Last()\n\t}\n}\n\nfunc BenchmarkEq(b *testing.B) {\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tj := 0\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.Eq(j)\n\t\tif j++; j >= sel.Length() {\n\t\t\tj = 0\n\t\t}\n\t}\n}\n\nfunc BenchmarkSlice(b *testing.B) {\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tj := 0\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.Slice(j, j+4)\n\t\tif j++; j >= (sel.Length() - 4) {\n\t\t\tj = 0\n\t\t}\n\t}\n}\n\nfunc BenchmarkGet(b *testing.B) {\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tj := 0\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.Get(j)\n\t\tif j++; j >= sel.Length() {\n\t\t\tj = 0\n\t\t}\n\t}\n}\n\nfunc BenchmarkIndex(b *testing.B) {\n\tvar j int\n\n\tb.StopTimer()\n\tsel := DocB().Find(\"#Main\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj = sel.Index()\n\t}\n\tif j != 3 {\n\t\tb.Fatalf(\"want 3, got %d\", j)\n\t}\n}\n\nfunc BenchmarkIndexSelector(b *testing.B) {\n\tvar j int\n\n\tb.StopTimer()\n\tsel := DocB().Find(\"#manual-nav dl dd:nth-child(1)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj = sel.IndexSelector(\"dd\")\n\t}\n\tif j != 4 {\n\t\tb.Fatalf(\"want 4, got %d\", j)\n\t}\n}\n\nfunc BenchmarkIndexOfNode(b *testing.B) {\n\tvar j int\n\n\tb.StopTimer()\n\tsel := DocB().Find(\"span a\")\n\tsel2 := DocB().Find(\"span a:nth-child(3)\")\n\tn := sel2.Get(0)\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj = sel.IndexOfNode(n)\n\t}\n\tif j != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", j)\n\t}\n}\n\nfunc BenchmarkIndexOfSelection(b *testing.B) {\n\tvar j int\n\tb.StopTimer()\n\tsel := DocB().Find(\"span a\")\n\tsel2 := DocB().Find(\"span a:nth-child(3)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tj = sel.IndexOfSelection(sel2)\n\t}\n\tif j != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", j)\n\t}\n}\n"
        },
        {
          "name": "bench_example_test.go",
          "type": "blob",
          "size": 0.900390625,
          "content": "package goquery\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc BenchmarkMetalReviewExample(b *testing.B) {\n\tvar n int\n\tvar buf bytes.Buffer\n\n\tb.StopTimer()\n\tdoc := loadDoc(\"metalreview.html\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tdoc.Find(\".slider-row:nth-child(1) .slider-item\").Each(func(i int, s *Selection) {\n\t\t\tvar band, title string\n\t\t\tvar score float64\n\t\t\tvar e error\n\n\t\t\tn++\n\t\t\t// For each item found, get the band, title and score, and print it\n\t\t\tband = s.Find(\"strong\").Text()\n\t\t\ttitle = s.Find(\"em\").Text()\n\t\t\tif score, e = strconv.ParseFloat(s.Find(\".score\").Text(), 64); e != nil {\n\t\t\t\t// Not a valid float, ignore score\n\t\t\t\tif n <= 4 {\n\t\t\t\t\tbuf.WriteString(fmt.Sprintf(\"Review %d: %s - %s.\\n\", i, band, title))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Print all, including score\n\t\t\t\tif n <= 4 {\n\t\t\t\t\tbuf.WriteString(fmt.Sprintf(\"Review %d: %s - %s (%2.1f).\\n\", i, band, title, score))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "bench_expand_test.go",
          "type": "blob",
          "size": 1.6376953125,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkAdd(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Add(\"h2[title]\").Length()\n\t\t} else {\n\t\t\tsel.Add(\"h2[title]\")\n\t\t}\n\t}\n\tif n != 43 {\n\t\tb.Fatalf(\"want 43, got %d\", n)\n\t}\n}\n\nfunc BenchmarkAddSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tsel2 := DocB().Find(\"h2[title]\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.AddSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.AddSelection(sel2)\n\t\t}\n\t}\n\tif n != 43 {\n\t\tb.Fatalf(\"want 43, got %d\", n)\n\t}\n}\n\nfunc BenchmarkAddNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\")\n\tsel2 := DocB().Find(\"h2[title]\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.AddNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.AddNodes(nodes...)\n\t\t}\n\t}\n\tif n != 43 {\n\t\tb.Fatalf(\"want 43, got %d\", n)\n\t}\n}\n\nfunc BenchmarkAddNodesBig(b *testing.B) {\n\tvar n int\n\n\tdoc := DocW()\n\tsel := doc.Find(\"li\")\n\t// make nodes > 1000\n\tnodes := sel.Nodes\n\tnodes = append(nodes, nodes...)\n\tnodes = append(nodes, nodes...)\n\tsel = doc.Find(\"xyz\")\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.AddNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.AddNodes(nodes...)\n\t\t}\n\t}\n\tif n != 373 {\n\t\tb.Fatalf(\"want 373, got %d\", n)\n\t}\n}\n\nfunc BenchmarkAndSelf(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocB().Find(\"dd\").Parent()\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.AndSelf().Length()\n\t\t} else {\n\t\t\tsel.AndSelf()\n\t\t}\n\t}\n\tif n != 44 {\n\t\tb.Fatalf(\"want 44, got %d\", n)\n\t}\n}\n"
        },
        {
          "name": "bench_filter_test.go",
          "type": "blob",
          "size": 3.8271484375,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkFilter(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Filter(\".toclevel-1\").Length()\n\t\t} else {\n\t\t\tsel.Filter(\".toclevel-1\")\n\t\t}\n\t}\n\tif n != 13 {\n\t\tb.Fatalf(\"want 13, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNot(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Not(\".toclevel-2\").Length()\n\t\t} else {\n\t\t\tsel.Filter(\".toclevel-2\")\n\t\t}\n\t}\n\tif n != 371 {\n\t\tb.Fatalf(\"want 371, got %d\", n)\n\t}\n}\n\nfunc BenchmarkFilterFunction(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tf := func(i int, s *Selection) bool {\n\t\treturn len(s.Get(0).Attr) > 0\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.FilterFunction(f).Length()\n\t\t} else {\n\t\t\tsel.FilterFunction(f)\n\t\t}\n\t}\n\tif n != 112 {\n\t\tb.Fatalf(\"want 112, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNotFunction(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tf := func(i int, s *Selection) bool {\n\t\treturn len(s.Get(0).Attr) > 0\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NotFunction(f).Length()\n\t\t} else {\n\t\t\tsel.NotFunction(f)\n\t\t}\n\t}\n\tif n != 261 {\n\t\tb.Fatalf(\"want 261, got %d\", n)\n\t}\n}\n\nfunc BenchmarkFilterNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".toclevel-2\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.FilterNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.FilterNodes(nodes...)\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNotNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".toclevel-1\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NotNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.NotNodes(nodes...)\n\t\t}\n\t}\n\tif n != 360 {\n\t\tb.Fatalf(\"want 360, got %d\", n)\n\t}\n}\n\nfunc BenchmarkFilterSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".toclevel-2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.FilterSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.FilterSelection(sel2)\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNotSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".toclevel-1\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NotSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.NotSelection(sel2)\n\t\t}\n\t}\n\tif n != 360 {\n\t\tb.Fatalf(\"want 360, got %d\", n)\n\t}\n}\n\nfunc BenchmarkHas(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Has(\".editsection\").Length()\n\t\t} else {\n\t\t\tsel.Has(\".editsection\")\n\t\t}\n\t}\n\tif n != 13 {\n\t\tb.Fatalf(\"want 13, got %d\", n)\n\t}\n}\n\nfunc BenchmarkHasNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".tocnumber\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.HasNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.HasNodes(nodes...)\n\t\t}\n\t}\n\tif n != 15 {\n\t\tb.Fatalf(\"want 15, got %d\", n)\n\t}\n}\n\nfunc BenchmarkHasSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".tocnumber\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.HasSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.HasSelection(sel2)\n\t\t}\n\t}\n\tif n != 15 {\n\t\tb.Fatalf(\"want 15, got %d\", n)\n\t}\n}\n\nfunc BenchmarkEnd(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\").Has(\".tocnumber\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.End().Length()\n\t\t} else {\n\t\t\tsel.End()\n\t\t}\n\t}\n\tif n != 373 {\n\t\tb.Fatalf(\"want 373, got %d\", n)\n\t}\n}\n"
        },
        {
          "name": "bench_iteration_test.go",
          "type": "blob",
          "size": 1.52734375,
          "content": "package goquery\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc BenchmarkEach(b *testing.B) {\n\tvar tmp, n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"td\")\n\tf := func(i int, s *Selection) {\n\t\ttmp++\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.Each(f)\n\t\tif n == 0 {\n\t\t\tn = tmp\n\t\t}\n\t}\n\tif n != 59 {\n\t\tb.Fatalf(\"want 59, got %d\", n)\n\t}\n}\n\nfunc BenchmarkEachIter(b *testing.B) {\n\tvar tmp, n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"td\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tfor range sel.EachIter() {\n\t\t\ttmp++\n\t\t}\n\t\tif n == 0 {\n\t\t\tn = tmp\n\t\t}\n\t}\n\tif n != 59 {\n\t\tb.Fatalf(\"want 59, got %d\", n)\n\t}\n}\n\nfunc BenchmarkEachIterWithBreak(b *testing.B) {\n\tvar tmp, n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"td\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttmp = 0\n\t\tfor range sel.EachIter() {\n\t\t\ttmp++\n\t\t\tif tmp >= 10 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif n == 0 {\n\t\t\tn = tmp\n\t\t}\n\t}\n\tif n != 10 {\n\t\tb.Fatalf(\"want 10, got %d\", n)\n\t}\n}\n\nfunc BenchmarkMap(b *testing.B) {\n\tvar tmp, n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"td\")\n\tf := func(i int, s *Selection) string {\n\t\ttmp++\n\t\treturn strconv.Itoa(tmp)\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.Map(f)\n\t\tif n == 0 {\n\t\t\tn = tmp\n\t\t}\n\t}\n\tif n != 59 {\n\t\tb.Fatalf(\"want 59, got %d\", n)\n\t}\n}\n\nfunc BenchmarkEachWithBreak(b *testing.B) {\n\tvar tmp, n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"td\")\n\tf := func(i int, s *Selection) bool {\n\t\ttmp++\n\t\treturn tmp < 10\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttmp = 0\n\t\tsel.EachWithBreak(f)\n\t\tif n == 0 {\n\t\t\tn = tmp\n\t\t}\n\t}\n\tif n != 10 {\n\t\tb.Fatalf(\"want 10, got %d\", n)\n\t}\n}\n"
        },
        {
          "name": "bench_property_test.go",
          "type": "blob",
          "size": 0.751953125,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkAttr(b *testing.B) {\n\tvar s string\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h1\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ts, _ = sel.Attr(\"id\")\n\t}\n\tif s != \"firstHeading\" {\n\t\tb.Fatalf(\"want firstHeading, got %q\", s)\n\t}\n}\n\nfunc BenchmarkText(b *testing.B) {\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tsel.Text()\n\t}\n}\n\nfunc BenchmarkLength(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tn = sel.Length()\n\t}\n\tif n != 14 {\n\t\tb.Fatalf(\"want 14, got %d\", n)\n\t}\n}\n\nfunc BenchmarkHtml(b *testing.B) {\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = sel.Html()\n\t}\n}\n"
        },
        {
          "name": "bench_query_test.go",
          "type": "blob",
          "size": 1.677734375,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkIs(b *testing.B) {\n\tvar y bool\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ty = sel.Is(\".toclevel-2\")\n\t}\n\tif !y {\n\t\tb.Fatal(\"want true\")\n\t}\n}\n\nfunc BenchmarkIsPositional(b *testing.B) {\n\tvar y bool\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ty = sel.Is(\"li:nth-child(2)\")\n\t}\n\tif !y {\n\t\tb.Fatal(\"want true\")\n\t}\n}\n\nfunc BenchmarkIsFunction(b *testing.B) {\n\tvar y bool\n\n\tb.StopTimer()\n\tsel := DocW().Find(\".toclevel-1\")\n\tf := func(i int, s *Selection) bool {\n\t\treturn i == 8\n\t}\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ty = sel.IsFunction(f)\n\t}\n\tif !y {\n\t\tb.Fatal(\"want true\")\n\t}\n}\n\nfunc BenchmarkIsSelection(b *testing.B) {\n\tvar y bool\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".toclevel-2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ty = sel.IsSelection(sel2)\n\t}\n\tif !y {\n\t\tb.Fatal(\"want true\")\n\t}\n}\n\nfunc BenchmarkIsNodes(b *testing.B) {\n\tvar y bool\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tsel2 := DocW().Find(\".toclevel-2\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ty = sel.IsNodes(nodes...)\n\t}\n\tif !y {\n\t\tb.Fatal(\"want true\")\n\t}\n}\n\nfunc BenchmarkHasClass(b *testing.B) {\n\tvar y bool\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"span\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ty = sel.HasClass(\"official\")\n\t}\n\tif !y {\n\t\tb.Fatal(\"want true\")\n\t}\n}\n\nfunc BenchmarkContains(b *testing.B) {\n\tvar y bool\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"span.url\")\n\tsel2 := DocW().Find(\"a[rel=\\\"nofollow\\\"]\")\n\tnode := sel2.Nodes[0]\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ty = sel.Contains(node)\n\t}\n\tif !y {\n\t\tb.Fatal(\"want true\")\n\t}\n}\n"
        },
        {
          "name": "bench_traversal_test.go",
          "type": "blob",
          "size": 14.1044921875,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n\n\t\"github.com/andybalholm/cascadia\"\n)\n\nfunc BenchmarkFind(b *testing.B) {\n\tvar n int\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = DocB().Find(\"dd\").Length()\n\n\t\t} else {\n\t\t\tDocB().Find(\"dd\")\n\t\t}\n\t}\n\tif n != 41 {\n\t\tb.Fatalf(\"want 41, got %d\", n)\n\t}\n}\n\nfunc BenchmarkFindWithinSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"ul\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Find(\"a[class]\").Length()\n\t\t} else {\n\t\t\tsel.Find(\"a[class]\")\n\t\t}\n\t}\n\tif n != 39 {\n\t\tb.Fatalf(\"want 39, got %d\", n)\n\t}\n}\n\nfunc BenchmarkFindSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"ul\")\n\tsel2 := DocW().Find(\"span\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.FindSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.FindSelection(sel2)\n\t\t}\n\t}\n\tif n != 73 {\n\t\tb.Fatalf(\"want 73, got %d\", n)\n\t}\n}\n\nfunc BenchmarkFindNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"ul\")\n\tsel2 := DocW().Find(\"span\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.FindNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.FindNodes(nodes...)\n\t\t}\n\t}\n\tif n != 73 {\n\t\tb.Fatalf(\"want 73, got %d\", n)\n\t}\n}\n\nfunc BenchmarkContents(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\".toclevel-1\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Contents().Length()\n\t\t} else {\n\t\t\tsel.Contents()\n\t\t}\n\t}\n\tif n != 16 {\n\t\tb.Fatalf(\"want 16, got %d\", n)\n\t}\n}\n\nfunc BenchmarkContentsFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\".toclevel-1\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ContentsFiltered(\"a[href=\\\"#Examples\\\"]\").Length()\n\t\t} else {\n\t\t\tsel.ContentsFiltered(\"a[href=\\\"#Examples\\\"]\")\n\t\t}\n\t}\n\tif n != 1 {\n\t\tb.Fatalf(\"want 1, got %d\", n)\n\t}\n}\n\nfunc BenchmarkChildren(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\".toclevel-2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Children().Length()\n\t\t} else {\n\t\t\tsel.Children()\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkChildrenFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h3\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ChildrenFiltered(\".editsection\").Length()\n\t\t} else {\n\t\t\tsel.ChildrenFiltered(\".editsection\")\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParent(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Parent().Length()\n\t\t} else {\n\t\t\tsel.Parent()\n\t\t}\n\t}\n\tif n != 55 {\n\t\tb.Fatalf(\"want 55, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentFiltered(\"ul[id]\").Length()\n\t\t} else {\n\t\t\tsel.ParentFiltered(\"ul[id]\")\n\t\t}\n\t}\n\tif n != 4 {\n\t\tb.Fatalf(\"want 4, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParents(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"th a\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Parents().Length()\n\t\t} else {\n\t\t\tsel.Parents()\n\t\t}\n\t}\n\tif n != 73 {\n\t\tb.Fatalf(\"want 73, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentsFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"th a\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentsFiltered(\"tr\").Length()\n\t\t} else {\n\t\t\tsel.ParentsFiltered(\"tr\")\n\t\t}\n\t}\n\tif n != 18 {\n\t\tb.Fatalf(\"want 18, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentsUntil(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"th a\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentsUntil(\"table\").Length()\n\t\t} else {\n\t\t\tsel.ParentsUntil(\"table\")\n\t\t}\n\t}\n\tif n != 52 {\n\t\tb.Fatalf(\"want 52, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentsUntilSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"th a\")\n\tsel2 := DocW().Find(\"#content\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentsUntilSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.ParentsUntilSelection(sel2)\n\t\t}\n\t}\n\tif n != 70 {\n\t\tb.Fatalf(\"want 70, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentsUntilNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"th a\")\n\tsel2 := DocW().Find(\"#content\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentsUntilNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.ParentsUntilNodes(nodes...)\n\t\t}\n\t}\n\tif n != 70 {\n\t\tb.Fatalf(\"want 70, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentsFilteredUntil(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\".toclevel-1 a\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentsFilteredUntil(\":nth-child(1)\", \"ul\").Length()\n\t\t} else {\n\t\t\tsel.ParentsFilteredUntil(\":nth-child(1)\", \"ul\")\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentsFilteredUntilSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\".toclevel-1 a\")\n\tsel2 := DocW().Find(\"ul\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentsFilteredUntilSelection(\":nth-child(1)\", sel2).Length()\n\t\t} else {\n\t\t\tsel.ParentsFilteredUntilSelection(\":nth-child(1)\", sel2)\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkParentsFilteredUntilNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\".toclevel-1 a\")\n\tsel2 := DocW().Find(\"ul\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ParentsFilteredUntilNodes(\":nth-child(1)\", nodes...).Length()\n\t\t} else {\n\t\t\tsel.ParentsFilteredUntilNodes(\":nth-child(1)\", nodes...)\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkSiblings(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"ul li:nth-child(1)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Siblings().Length()\n\t\t} else {\n\t\t\tsel.Siblings()\n\t\t}\n\t}\n\tif n != 293 {\n\t\tb.Fatalf(\"want 293, got %d\", n)\n\t}\n}\n\nfunc BenchmarkSiblingsFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"ul li:nth-child(1)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.SiblingsFiltered(\"[class]\").Length()\n\t\t} else {\n\t\t\tsel.SiblingsFiltered(\"[class]\")\n\t\t}\n\t}\n\tif n != 46 {\n\t\tb.Fatalf(\"want 46, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNext(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:nth-child(1)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Next().Length()\n\t\t} else {\n\t\t\tsel.Next()\n\t\t}\n\t}\n\tif n != 49 {\n\t\tb.Fatalf(\"want 49, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:nth-child(1)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextFiltered(\"[class]\").Length()\n\t\t} else {\n\t\t\tsel.NextFiltered(\"[class]\")\n\t\t}\n\t}\n\tif n != 6 {\n\t\tb.Fatalf(\"want 6, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextAll(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:nth-child(3)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextAll().Length()\n\t\t} else {\n\t\t\tsel.NextAll()\n\t\t}\n\t}\n\tif n != 234 {\n\t\tb.Fatalf(\"want 234, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextAllFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:nth-child(3)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextAllFiltered(\"[class]\").Length()\n\t\t} else {\n\t\t\tsel.NextAllFiltered(\"[class]\")\n\t\t}\n\t}\n\tif n != 33 {\n\t\tb.Fatalf(\"want 33, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrev(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:last-child\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Prev().Length()\n\t\t} else {\n\t\t\tsel.Prev()\n\t\t}\n\t}\n\tif n != 49 {\n\t\tb.Fatalf(\"want 49, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:last-child\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevFiltered(\"[class]\").Length()\n\t\t} else {\n\t\t\tsel.PrevFiltered(\"[class]\")\n\t\t}\n\t}\n\t// There is one more Prev li with a class, compared to Next li with a class\n\t// (confirmed by looking at the HTML, this is ok)\n\tif n != 7 {\n\t\tb.Fatalf(\"want 7, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevAll(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:nth-child(4)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevAll().Length()\n\t\t} else {\n\t\t\tsel.PrevAll()\n\t\t}\n\t}\n\tif n != 78 {\n\t\tb.Fatalf(\"want 78, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevAllFiltered(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:nth-child(4)\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevAllFiltered(\"[class]\").Length()\n\t\t} else {\n\t\t\tsel.PrevAllFiltered(\"[class]\")\n\t\t}\n\t}\n\tif n != 6 {\n\t\tb.Fatalf(\"want 6, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextUntil(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:first-child\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextUntil(\":nth-child(4)\").Length()\n\t\t} else {\n\t\t\tsel.NextUntil(\":nth-child(4)\")\n\t\t}\n\t}\n\tif n != 84 {\n\t\tb.Fatalf(\"want 84, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextUntilSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"ul\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextUntilSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.NextUntilSelection(sel2)\n\t\t}\n\t}\n\tif n != 42 {\n\t\tb.Fatalf(\"want 42, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextUntilNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"p\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextUntilNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.NextUntilNodes(nodes...)\n\t\t}\n\t}\n\tif n != 12 {\n\t\tb.Fatalf(\"want 12, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevUntil(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"li:last-child\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevUntil(\":nth-child(4)\").Length()\n\t\t} else {\n\t\t\tsel.PrevUntil(\":nth-child(4)\")\n\t\t}\n\t}\n\tif n != 238 {\n\t\tb.Fatalf(\"want 238, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevUntilSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"ul\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevUntilSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.PrevUntilSelection(sel2)\n\t\t}\n\t}\n\tif n != 49 {\n\t\tb.Fatalf(\"want 49, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevUntilNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"p\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevUntilNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.PrevUntilNodes(nodes...)\n\t\t}\n\t}\n\tif n != 11 {\n\t\tb.Fatalf(\"want 11, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextFilteredUntil(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextFilteredUntil(\"p\", \"div\").Length()\n\t\t} else {\n\t\t\tsel.NextFilteredUntil(\"p\", \"div\")\n\t\t}\n\t}\n\tif n != 22 {\n\t\tb.Fatalf(\"want 22, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextFilteredUntilSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"div\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextFilteredUntilSelection(\"p\", sel2).Length()\n\t\t} else {\n\t\t\tsel.NextFilteredUntilSelection(\"p\", sel2)\n\t\t}\n\t}\n\tif n != 22 {\n\t\tb.Fatalf(\"want 22, got %d\", n)\n\t}\n}\n\nfunc BenchmarkNextFilteredUntilNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"div\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.NextFilteredUntilNodes(\"p\", nodes...).Length()\n\t\t} else {\n\t\t\tsel.NextFilteredUntilNodes(\"p\", nodes...)\n\t\t}\n\t}\n\tif n != 22 {\n\t\tb.Fatalf(\"want 22, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevFilteredUntil(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevFilteredUntil(\"p\", \"div\").Length()\n\t\t} else {\n\t\t\tsel.PrevFilteredUntil(\"p\", \"div\")\n\t\t}\n\t}\n\tif n != 20 {\n\t\tb.Fatalf(\"want 20, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevFilteredUntilSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"div\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevFilteredUntilSelection(\"p\", sel2).Length()\n\t\t} else {\n\t\t\tsel.PrevFilteredUntilSelection(\"p\", sel2)\n\t\t}\n\t}\n\tif n != 20 {\n\t\tb.Fatalf(\"want 20, got %d\", n)\n\t}\n}\n\nfunc BenchmarkPrevFilteredUntilNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := DocW().Find(\"h2\")\n\tsel2 := DocW().Find(\"div\")\n\tnodes := sel2.Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.PrevFilteredUntilNodes(\"p\", nodes...).Length()\n\t\t} else {\n\t\t\tsel.PrevFilteredUntilNodes(\"p\", nodes...)\n\t\t}\n\t}\n\tif n != 20 {\n\t\tb.Fatalf(\"want 20, got %d\", n)\n\t}\n}\n\nfunc BenchmarkClosest(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := Doc().Find(\".container-fluid\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.Closest(\".pvk-content\").Length()\n\t\t} else {\n\t\t\tsel.Closest(\".pvk-content\")\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkClosestSelection(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".pvk-content\")\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ClosestSelection(sel2).Length()\n\t\t} else {\n\t\t\tsel.ClosestSelection(sel2)\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkClosestNodes(b *testing.B) {\n\tvar n int\n\n\tb.StopTimer()\n\tsel := Doc().Find(\".container-fluid\")\n\tnodes := Doc().Find(\".pvk-content\").Nodes\n\tb.StartTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif n == 0 {\n\t\t\tn = sel.ClosestNodes(nodes...).Length()\n\t\t} else {\n\t\t\tsel.ClosestNodes(nodes...)\n\t\t}\n\t}\n\tif n != 2 {\n\t\tb.Fatalf(\"want 2, got %d\", n)\n\t}\n}\n\nfunc BenchmarkSingleMatcher(b *testing.B) {\n\tdoc := Doc()\n\tmulti := cascadia.MustCompile(`div`)\n\tsingle := SingleMatcher(multi)\n\tb.ResetTimer()\n\n\tb.Run(\"multi\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = doc.FindMatcher(multi)\n\t\t}\n\t})\n\tb.Run(\"single\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\t_ = doc.FindMatcher(single)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 4.5966796875,
          "content": "// Copyright (c) 2012-2016, Martin Angers & Contributors\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright notice,\n// this list of conditions and the following disclaimer in the documentation and/or\n// other materials provided with the distribution.\n// * Neither the name of the author nor the names of its contributors may be used to\n// endorse or promote products derived from this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\n// OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n// AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n// WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n/*\nPackage goquery implements features similar to jQuery, including the chainable\nsyntax, to manipulate and query an HTML document.\n\nIt brings a syntax and a set of features similar to jQuery to the Go language.\nIt is based on Go's net/html package and the CSS Selector library cascadia.\nSince the net/html parser returns nodes, and not a full-featured DOM\ntree, jQuery's stateful manipulation functions (like height(), css(), detach())\nhave been left off.\n\nAlso, because the net/html parser requires UTF-8 encoding, so does goquery: it is\nthe caller's responsibility to ensure that the source document provides UTF-8 encoded HTML.\nSee the repository's wiki for various options on how to do this.\n\nSyntax-wise, it is as close as possible to jQuery, with the same method names when\npossible, and that warm and fuzzy chainable interface. jQuery being the\nultra-popular library that it is, writing a similar HTML-manipulating\nlibrary was better to follow its API than to start anew (in the same spirit as\nGo's fmt package), even though some of its methods are less than intuitive (looking\nat you, index()...).\n\nIt is hosted on GitHub, along with additional documentation in the README.md\nfile: https://github.com/puerkitobio/goquery\n\nPlease note that because of the net/html dependency, goquery requires Go1.1+.\n\nThe various methods are split into files based on the category of behavior.\nThe three dots (...) indicate that various \"overloads\" are available.\n\n* array.go : array-like positional manipulation of the selection.\n    - Eq()\n    - First()\n    - Get()\n    - Index...()\n    - Last()\n    - Slice()\n\n* expand.go : methods that expand or augment the selection's set.\n    - Add...()\n    - AndSelf()\n    - Union(), which is an alias for AddSelection()\n\n* filter.go : filtering methods, that reduce the selection's set.\n    - End()\n    - Filter...()\n    - Has...()\n    - Intersection(), which is an alias of FilterSelection()\n    - Not...()\n\n* iteration.go : methods to loop over the selection's nodes.\n    - Each()\n    - EachWithBreak()\n    - Map()\n\n* manipulation.go : methods for modifying the document\n    - After...()\n    - Append...()\n    - Before...()\n    - Clone()\n    - Empty()\n    - Prepend...()\n    - Remove...()\n    - ReplaceWith...()\n    - Unwrap()\n    - Wrap...()\n    - WrapAll...()\n    - WrapInner...()\n\n* property.go : methods that inspect and get the node's properties values.\n    - Attr*(), RemoveAttr(), SetAttr()\n    - AddClass(), HasClass(), RemoveClass(), ToggleClass()\n    - Html()\n    - Length()\n    - Size(), which is an alias for Length()\n    - Text()\n\n* query.go : methods that query, or reflect, a node's identity.\n    - Contains()\n    - Is...()\n\n* traversal.go : methods to traverse the HTML document tree.\n    - Children...()\n    - Contents()\n    - Find...()\n    - Next...()\n    - Parent[s]...()\n    - Prev...()\n    - Siblings...()\n\n* type.go : definition of the types exposed by goquery.\n    - Document\n    - Selection\n    - Matcher\n\n* utilities.go : definition of helper functions (and not methods on a *Selection)\nthat are not part of jQuery, but are useful to goquery.\n    - NodeName\n    - OuterHtml\n*/\npackage goquery\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 2.3779296875,
          "content": "package goquery_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/PuerkitoBio/goquery\"\n)\n\n// This example scrapes the reviews shown on the home page of metalsucks.net.\nfunc Example() {\n\t// Request the HTML page.\n\tres, err := http.Get(\"http://metalsucks.net\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer res.Body.Close()\n\tif res.StatusCode != 200 {\n\t\tlog.Fatalf(\"status code error: %d %s\", res.StatusCode, res.Status)\n\t}\n\n\t// Load the HTML document\n\tdoc, err := goquery.NewDocumentFromReader(res.Body)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Find the review items\n\tdoc.Find(\".sidebar-reviews article .content-block\").Each(func(i int, s *goquery.Selection) {\n\t\t// For each item found, get the band and title\n\t\tband := s.Find(\"a\").Text()\n\t\ttitle := s.Find(\"i\").Text()\n\t\tfmt.Printf(\"Review %d: %s - %s\\n\", i, band, title)\n\t})\n\t// To see the output of the Example while running the test suite (go test), simply\n\t// remove the leading \"x\" before Output on the next line. This will cause the\n\t// example to fail (all the \"real\" tests should pass).\n\n\t// xOutput: voluntarily fail the Example output.\n}\n\n// This example shows how to use NewDocumentFromReader from a file.\nfunc ExampleNewDocumentFromReader_file() {\n\t// create from a file\n\tf, err := os.Open(\"some/file.html\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer f.Close()\n\tdoc, err := goquery.NewDocumentFromReader(f)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// use the goquery document...\n\t_ = doc.Find(\"h1\")\n}\n\n// This example shows how to use NewDocumentFromReader from a string.\nfunc ExampleNewDocumentFromReader_string() {\n\t// create from a string\n\tdata := `\n<html>\n\t<head>\n\t\t<title>My document</title>\n\t</head>\n\t<body>\n\t\t<h1>Header</h1>\n\t</body>\n</html>`\n\n\tdoc, err := goquery.NewDocumentFromReader(strings.NewReader(data))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\theader := doc.Find(\"h1\").Text()\n\tfmt.Println(header)\n\n\t// Output: Header\n}\n\nfunc ExampleSingle() {\n\thtml := `\n<html>\n  <body>\n    <div>1</div>\n    <div>2</div>\n    <div>3</div>\n  </body>\n</html>\n`\n\tdoc, err := goquery.NewDocumentFromReader(strings.NewReader(html))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// By default, the selector string selects all matching nodes\n\tmultiSel := doc.Find(\"div\")\n\tfmt.Println(multiSel.Text())\n\n\t// Using goquery.Single, only the first match is selected\n\tsingleSel := doc.FindMatcher(goquery.Single(\"div\"))\n\tfmt.Println(singleSel.Text())\n\n\t// Output:\n\t// 123\n\t// 1\n}\n"
        },
        {
          "name": "expand.go",
          "type": "blob",
          "size": 2.685546875,
          "content": "package goquery\n\nimport \"golang.org/x/net/html\"\n\n// Add adds the selector string's matching nodes to those in the current\n// selection and returns a new Selection object.\n// The selector string is run in the context of the document of the current\n// Selection object.\nfunc (s *Selection) Add(selector string) *Selection {\n\treturn s.AddNodes(findWithMatcher([]*html.Node{s.document.rootNode}, compileMatcher(selector))...)\n}\n\n// AddMatcher adds the matcher's matching nodes to those in the current\n// selection and returns a new Selection object.\n// The matcher is run in the context of the document of the current\n// Selection object.\nfunc (s *Selection) AddMatcher(m Matcher) *Selection {\n\treturn s.AddNodes(findWithMatcher([]*html.Node{s.document.rootNode}, m)...)\n}\n\n// AddSelection adds the specified Selection object's nodes to those in the\n// current selection and returns a new Selection object.\nfunc (s *Selection) AddSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.AddNodes()\n\t}\n\treturn s.AddNodes(sel.Nodes...)\n}\n\n// Union is an alias for AddSelection.\nfunc (s *Selection) Union(sel *Selection) *Selection {\n\treturn s.AddSelection(sel)\n}\n\n// AddNodes adds the specified nodes to those in the\n// current selection and returns a new Selection object.\nfunc (s *Selection) AddNodes(nodes ...*html.Node) *Selection {\n\treturn pushStack(s, appendWithoutDuplicates(s.Nodes, nodes, nil))\n}\n\n// AndSelf adds the previous set of elements on the stack to the current set.\n// It returns a new Selection object containing the current Selection combined\n// with the previous one.\n// Deprecated: This function has been deprecated and is now an alias for AddBack().\nfunc (s *Selection) AndSelf() *Selection {\n\treturn s.AddBack()\n}\n\n// AddBack adds the previous set of elements on the stack to the current set.\n// It returns a new Selection object containing the current Selection combined\n// with the previous one.\nfunc (s *Selection) AddBack() *Selection {\n\treturn s.AddSelection(s.prevSel)\n}\n\n// AddBackFiltered reduces the previous set of elements on the stack to those that\n// match the selector string, and adds them to the current set.\n// It returns a new Selection object containing the current Selection combined\n// with the filtered previous one\nfunc (s *Selection) AddBackFiltered(selector string) *Selection {\n\treturn s.AddSelection(s.prevSel.Filter(selector))\n}\n\n// AddBackMatcher reduces the previous set of elements on the stack to those that match\n// the matcher, and adds them to the current set.\n// It returns a new Selection object containing the current Selection combined\n// with the filtered previous one\nfunc (s *Selection) AddBackMatcher(m Matcher) *Selection {\n\treturn s.AddSelection(s.prevSel.FilterMatcher(m))\n}\n"
        },
        {
          "name": "expand_test.go",
          "type": "blob",
          "size": 2.75390625,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAdd(t *testing.T) {\n\tsel := Doc().Find(\"div.row-fluid\").Add(\"a\")\n\tassertLength(t, sel.Nodes, 19)\n}\n\nfunc TestAddInvalid(t *testing.T) {\n\tsel1 := Doc().Find(\"div.row-fluid\")\n\tsel2 := sel1.Add(\"\")\n\tassertLength(t, sel1.Nodes, 9)\n\tassertLength(t, sel2.Nodes, 9)\n\tif sel1 == sel2 {\n\t\tt.Errorf(\"selections should not be the same\")\n\t}\n}\n\nfunc TestAddRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Add(\"a\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestAddSelection(t *testing.T) {\n\tsel := Doc().Find(\"div.row-fluid\")\n\tsel2 := Doc().Find(\"a\")\n\tsel = sel.AddSelection(sel2)\n\tassertLength(t, sel.Nodes, 19)\n}\n\nfunc TestAddSelectionNil(t *testing.T) {\n\tsel := Doc().Find(\"div.row-fluid\")\n\tassertLength(t, sel.Nodes, 9)\n\n\tsel = sel.AddSelection(nil)\n\tassertLength(t, sel.Nodes, 9)\n}\n\nfunc TestAddSelectionRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Find(\"a\")\n\tsel2 = sel.AddSelection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestAddNodes(t *testing.T) {\n\tsel := Doc().Find(\"div.pvk-gutter\")\n\tsel2 := Doc().Find(\".pvk-content\")\n\tsel = sel.AddNodes(sel2.Nodes...)\n\tassertLength(t, sel.Nodes, 9)\n}\n\nfunc TestAddNodesNone(t *testing.T) {\n\tsel := Doc().Find(\"div.pvk-gutter\").AddNodes()\n\tassertLength(t, sel.Nodes, 6)\n}\n\nfunc TestAddNodesRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Find(\"a\")\n\tsel2 = sel.AddNodes(sel2.Nodes...).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestAddNodesBig(t *testing.T) {\n\tdoc := DocW()\n\tsel := doc.Find(\"li\")\n\tassertLength(t, sel.Nodes, 373)\n\tsel2 := doc.Find(\"xyz\")\n\tassertLength(t, sel2.Nodes, 0)\n\n\tnodes := sel.Nodes\n\tsel2 = sel2.AddNodes(nodes...)\n\tassertLength(t, sel2.Nodes, 373)\n\tnodes2 := append(nodes, nodes...)\n\tsel2 = sel2.End().AddNodes(nodes2...)\n\tassertLength(t, sel2.Nodes, 373)\n\tnodes3 := append(nodes2, nodes...)\n\tsel2 = sel2.End().AddNodes(nodes3...)\n\tassertLength(t, sel2.Nodes, 373)\n}\n\nfunc TestAndSelf(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Last().AndSelf()\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestAndSelfRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Find(\"a\").AndSelf().End().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestAddBack(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Last().AddBack()\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestAddBackRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Find(\"a\").AddBack().End().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestAddBackFiltered(t *testing.T) {\n\tsel := Doc().Find(\".span12, .footer\").Find(\"h1\").AddBackFiltered(\".footer\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestAddBackFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".span12, .footer\")\n\tsel2 := sel.Find(\"h1\").AddBackFiltered(\".footer\").End().End()\n\tassertEqual(t, sel, sel2)\n}\n"
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 5.783203125,
          "content": "package goquery\n\nimport \"golang.org/x/net/html\"\n\n// Filter reduces the set of matched elements to those that match the selector string.\n// It returns a new Selection object for this subset of matching elements.\nfunc (s *Selection) Filter(selector string) *Selection {\n\treturn s.FilterMatcher(compileMatcher(selector))\n}\n\n// FilterMatcher reduces the set of matched elements to those that match\n// the given matcher. It returns a new Selection object for this subset\n// of matching elements.\nfunc (s *Selection) FilterMatcher(m Matcher) *Selection {\n\treturn pushStack(s, winnow(s, m, true))\n}\n\n// Not removes elements from the Selection that match the selector string.\n// It returns a new Selection object with the matching elements removed.\nfunc (s *Selection) Not(selector string) *Selection {\n\treturn s.NotMatcher(compileMatcher(selector))\n}\n\n// NotMatcher removes elements from the Selection that match the given matcher.\n// It returns a new Selection object with the matching elements removed.\nfunc (s *Selection) NotMatcher(m Matcher) *Selection {\n\treturn pushStack(s, winnow(s, m, false))\n}\n\n// FilterFunction reduces the set of matched elements to those that pass the function's test.\n// It returns a new Selection object for this subset of elements.\nfunc (s *Selection) FilterFunction(f func(int, *Selection) bool) *Selection {\n\treturn pushStack(s, winnowFunction(s, f, true))\n}\n\n// NotFunction removes elements from the Selection that pass the function's test.\n// It returns a new Selection object with the matching elements removed.\nfunc (s *Selection) NotFunction(f func(int, *Selection) bool) *Selection {\n\treturn pushStack(s, winnowFunction(s, f, false))\n}\n\n// FilterNodes reduces the set of matched elements to those that match the specified nodes.\n// It returns a new Selection object for this subset of elements.\nfunc (s *Selection) FilterNodes(nodes ...*html.Node) *Selection {\n\treturn pushStack(s, winnowNodes(s, nodes, true))\n}\n\n// NotNodes removes elements from the Selection that match the specified nodes.\n// It returns a new Selection object with the matching elements removed.\nfunc (s *Selection) NotNodes(nodes ...*html.Node) *Selection {\n\treturn pushStack(s, winnowNodes(s, nodes, false))\n}\n\n// FilterSelection reduces the set of matched elements to those that match a\n// node in the specified Selection object.\n// It returns a new Selection object for this subset of elements.\nfunc (s *Selection) FilterSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn pushStack(s, winnowNodes(s, nil, true))\n\t}\n\treturn pushStack(s, winnowNodes(s, sel.Nodes, true))\n}\n\n// NotSelection removes elements from the Selection that match a node in the specified\n// Selection object. It returns a new Selection object with the matching elements removed.\nfunc (s *Selection) NotSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn pushStack(s, winnowNodes(s, nil, false))\n\t}\n\treturn pushStack(s, winnowNodes(s, sel.Nodes, false))\n}\n\n// Intersection is an alias for FilterSelection.\nfunc (s *Selection) Intersection(sel *Selection) *Selection {\n\treturn s.FilterSelection(sel)\n}\n\n// Has reduces the set of matched elements to those that have a descendant\n// that matches the selector.\n// It returns a new Selection object with the matching elements.\nfunc (s *Selection) Has(selector string) *Selection {\n\treturn s.HasSelection(s.document.Find(selector))\n}\n\n// HasMatcher reduces the set of matched elements to those that have a descendant\n// that matches the matcher.\n// It returns a new Selection object with the matching elements.\nfunc (s *Selection) HasMatcher(m Matcher) *Selection {\n\treturn s.HasSelection(s.document.FindMatcher(m))\n}\n\n// HasNodes reduces the set of matched elements to those that have a\n// descendant that matches one of the nodes.\n// It returns a new Selection object with the matching elements.\nfunc (s *Selection) HasNodes(nodes ...*html.Node) *Selection {\n\treturn s.FilterFunction(func(_ int, sel *Selection) bool {\n\t\t// Add all nodes that contain one of the specified nodes\n\t\tfor _, n := range nodes {\n\t\t\tif sel.Contains(n) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\n// HasSelection reduces the set of matched elements to those that have a\n// descendant that matches one of the nodes of the specified Selection object.\n// It returns a new Selection object with the matching elements.\nfunc (s *Selection) HasSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.HasNodes()\n\t}\n\treturn s.HasNodes(sel.Nodes...)\n}\n\n// End ends the most recent filtering operation in the current chain and\n// returns the set of matched elements to its previous state.\nfunc (s *Selection) End() *Selection {\n\tif s.prevSel != nil {\n\t\treturn s.prevSel\n\t}\n\treturn newEmptySelection(s.document)\n}\n\n// Filter based on the matcher, and the indicator to keep (Filter) or\n// to get rid of (Not) the matching elements.\nfunc winnow(sel *Selection, m Matcher, keep bool) []*html.Node {\n\t// Optimize if keep is requested\n\tif keep {\n\t\treturn m.Filter(sel.Nodes)\n\t}\n\t// Use grep\n\treturn grep(sel, func(i int, s *Selection) bool {\n\t\treturn !m.Match(s.Get(0))\n\t})\n}\n\n// Filter based on an array of nodes, and the indicator to keep (Filter) or\n// to get rid of (Not) the matching elements.\nfunc winnowNodes(sel *Selection, nodes []*html.Node, keep bool) []*html.Node {\n\tif len(nodes)+len(sel.Nodes) < minNodesForSet {\n\t\treturn grep(sel, func(i int, s *Selection) bool {\n\t\t\treturn isInSlice(nodes, s.Get(0)) == keep\n\t\t})\n\t}\n\n\tset := make(map[*html.Node]bool)\n\tfor _, n := range nodes {\n\t\tset[n] = true\n\t}\n\treturn grep(sel, func(i int, s *Selection) bool {\n\t\treturn set[s.Get(0)] == keep\n\t})\n}\n\n// Filter based on a function test, and the indicator to keep (Filter) or\n// to get rid of (Not) the matching elements.\nfunc winnowFunction(sel *Selection, f func(int, *Selection) bool, keep bool) []*html.Node {\n\treturn grep(sel, func(i int, s *Selection) bool {\n\t\treturn f(i, s) == keep\n\t})\n}\n"
        },
        {
          "name": "filter_test.go",
          "type": "blob",
          "size": 4.9208984375,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFilter(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Filter(\".alert\")\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestFilterNone(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Filter(\".zzalert\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestFilterInvalid(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Filter(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestFilterRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Filter(\".alert\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestFilterFunction(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").FilterFunction(func(i int, s *Selection) bool {\n\t\treturn i > 0\n\t})\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestFilterFunctionRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.FilterFunction(func(i int, s *Selection) bool {\n\t\treturn i > 0\n\t}).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestFilterNode(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.FilterNodes(sel.Nodes[2])\n\tassertLength(t, sel2.Nodes, 1)\n}\n\nfunc TestFilterNodeRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.FilterNodes(sel.Nodes[2]).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestFilterSelection(t *testing.T) {\n\tsel := Doc().Find(\".link\")\n\tsel2 := Doc().Find(\"a[ng-click]\")\n\tsel3 := sel.FilterSelection(sel2)\n\tassertLength(t, sel3.Nodes, 1)\n}\n\nfunc TestFilterSelectionRollback(t *testing.T) {\n\tsel := Doc().Find(\".link\")\n\tsel2 := Doc().Find(\"a[ng-click]\")\n\tsel2 = sel.FilterSelection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestFilterSelectionNil(t *testing.T) {\n\tvar sel2 *Selection\n\n\tsel := Doc().Find(\".link\")\n\tsel3 := sel.FilterSelection(sel2)\n\tassertLength(t, sel3.Nodes, 0)\n}\n\nfunc TestNot(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Not(\".alert\")\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestNotInvalid(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Not(\"\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestNotRollback(t *testing.T) {\n\tsel := Doc().Find(\".span12\")\n\tsel2 := sel.Not(\".alert\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNotNone(t *testing.T) {\n\tsel := Doc().Find(\".span12\").Not(\".zzalert\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestNotFunction(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").NotFunction(func(i int, s *Selection) bool {\n\t\treturn i > 0\n\t})\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestNotFunctionRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.NotFunction(func(i int, s *Selection) bool {\n\t\treturn i > 0\n\t}).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNotNode(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.NotNodes(sel.Nodes[2])\n\tassertLength(t, sel2.Nodes, 2)\n}\n\nfunc TestNotNodeRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.NotNodes(sel.Nodes[2]).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNotSelection(t *testing.T) {\n\tsel := Doc().Find(\".link\")\n\tsel2 := Doc().Find(\"a[ng-click]\")\n\tsel3 := sel.NotSelection(sel2)\n\tassertLength(t, sel3.Nodes, 6)\n}\n\nfunc TestNotSelectionRollback(t *testing.T) {\n\tsel := Doc().Find(\".link\")\n\tsel2 := Doc().Find(\"a[ng-click]\")\n\tsel2 = sel.NotSelection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestIntersection(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\")\n\tsel2 := Doc().Find(\"div\").Intersection(sel)\n\tassertLength(t, sel2.Nodes, 6)\n}\n\nfunc TestIntersectionRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\")\n\tsel2 := Doc().Find(\"div\")\n\tsel2 = sel.Intersection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestHas(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Has(\".center-content\")\n\tassertLength(t, sel.Nodes, 2)\n\t// Has() returns the high-level .container-fluid div, and the one that is the immediate parent of center-content\n}\n\nfunc TestHasInvalid(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Has(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestHasRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.Has(\".center-content\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestHasNodes(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".center-content\")\n\tsel = sel.HasNodes(sel2.Nodes...)\n\tassertLength(t, sel.Nodes, 2)\n\t// Has() returns the high-level .container-fluid div, and the one that is the immediate parent of center-content\n}\n\nfunc TestHasNodesRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".center-content\")\n\tsel2 = sel.HasNodes(sel2.Nodes...).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestHasSelection(t *testing.T) {\n\tsel := Doc().Find(\"p\")\n\tsel2 := Doc().Find(\"small\")\n\tsel = sel.HasSelection(sel2)\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestHasSelectionRollback(t *testing.T) {\n\tsel := Doc().Find(\"p\")\n\tsel2 := Doc().Find(\"small\")\n\tsel2 = sel.HasSelection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestEnd(t *testing.T) {\n\tsel := Doc().Find(\"p\").Has(\"small\").End()\n\tassertLength(t, sel.Nodes, 4)\n}\n\nfunc TestEndToTop(t *testing.T) {\n\tsel := Doc().Find(\"p\").Has(\"small\").End().End().End()\n\tassertLength(t, sel.Nodes, 0)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.123046875,
          "content": "module github.com/PuerkitoBio/goquery\n\nrequire (\n\tgithub.com/andybalholm/cascadia v1.3.3\n\tgolang.org/x/net v0.33.0\n)\n\ngo 1.23\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.923828125,
          "content": "github.com/andybalholm/cascadia v1.3.3 h1:AG2YHrzJIm4BZ19iwJ/DAua6Btl3IwJX+VI4kktS1LM=\ngithub.com/andybalholm/cascadia v1.3.3/go.mod h1:xNd9bqTn98Ln4DwST8/nG+H0yuB8Hmgu1YHNnWw0GeA=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "iteration.go",
          "type": "blob",
          "size": 1.982421875,
          "content": "package goquery\n\nimport \"iter\"\n\n// Each iterates over a Selection object, executing a function for each\n// matched element. It returns the current Selection object. The function\n// f is called for each element in the selection with the index of the\n// element in that selection starting at 0, and a *Selection that contains\n// only that element.\nfunc (s *Selection) Each(f func(int, *Selection)) *Selection {\n\tfor i, n := range s.Nodes {\n\t\tf(i, newSingleSelection(n, s.document))\n\t}\n\treturn s\n}\n\n// EachIter returns an iterator that yields the Selection object in order.\n// The implementation is similar to Each, but it returns an iterator instead.\nfunc (s *Selection) EachIter() iter.Seq2[int, *Selection] {\n\treturn func(yield func(int, *Selection) bool) {\n\t\tfor i, n := range s.Nodes {\n\t\t\tif !yield(i, newSingleSelection(n, s.document)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// EachWithBreak iterates over a Selection object, executing a function for each\n// matched element. It is identical to Each except that it is possible to break\n// out of the loop by returning false in the callback function. It returns the\n// current Selection object.\nfunc (s *Selection) EachWithBreak(f func(int, *Selection) bool) *Selection {\n\tfor i, n := range s.Nodes {\n\t\tif !f(i, newSingleSelection(n, s.document)) {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn s\n}\n\n// Map passes each element in the current matched set through a function,\n// producing a slice of string holding the returned values. The function\n// f is called for each element in the selection with the index of the\n// element in that selection starting at 0, and a *Selection that contains\n// only that element.\nfunc (s *Selection) Map(f func(int, *Selection) string) (result []string) {\n\treturn Map(s, f)\n}\n\n// Map is the generic version of Selection.Map, allowing any type to be\n// returned.\nfunc Map[E any](s *Selection, f func(int, *Selection) E) (result []E) {\n\tresult = make([]E, len(s.Nodes))\n\n\tfor i, n := range s.Nodes {\n\t\tresult[i] = f(i, newSingleSelection(n, s.document))\n\t}\n\n\treturn result\n}\n"
        },
        {
          "name": "iteration_test.go",
          "type": "blob",
          "size": 3.017578125,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n\n\t\"golang.org/x/net/html\"\n)\n\nfunc TestEach(t *testing.T) {\n\tvar cnt int\n\n\tsel := Doc().Find(\".hero-unit .row-fluid\").Each(func(i int, n *Selection) {\n\t\tcnt++\n\t\tt.Logf(\"At index %v, node %v\", i, n.Nodes[0].Data)\n\t}).Find(\"a\")\n\n\tif cnt != 4 {\n\t\tt.Errorf(\"Expected Each() to call function 4 times, got %v times.\", cnt)\n\t}\n\tassertLength(t, sel.Nodes, 6)\n}\n\nfunc TestEachWithBreak(t *testing.T) {\n\tvar cnt int\n\n\tsel := Doc().Find(\".hero-unit .row-fluid\").EachWithBreak(func(i int, n *Selection) bool {\n\t\tcnt++\n\t\tt.Logf(\"At index %v, node %v\", i, n.Nodes[0].Data)\n\t\treturn false\n\t}).Find(\"a\")\n\n\tif cnt != 1 {\n\t\tt.Errorf(\"Expected Each() to call function 1 time, got %v times.\", cnt)\n\t}\n\tassertLength(t, sel.Nodes, 6)\n}\n\nfunc TestEachEmptySelection(t *testing.T) {\n\tvar cnt int\n\n\tsel := Doc().Find(\"zzzz\")\n\tsel.Each(func(i int, n *Selection) {\n\t\tcnt++\n\t})\n\tif cnt > 0 {\n\t\tt.Error(\"Expected Each() to not be called on empty Selection.\")\n\t}\n\tsel2 := sel.Find(\"div\")\n\tassertLength(t, sel2.Nodes, 0)\n}\n\nfunc TestMap(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tvals := sel.Map(func(i int, s *Selection) string {\n\t\tn := s.Get(0)\n\t\tif n.Type == html.ElementNode {\n\t\t\treturn n.Data\n\t\t}\n\t\treturn \"\"\n\t})\n\tfor _, v := range vals {\n\t\tif v != \"div\" {\n\t\t\tt.Error(\"Expected Map array result to be all 'div's.\")\n\t\t}\n\t}\n\tif len(vals) != 3 {\n\t\tt.Errorf(\"Expected Map array result to have a length of 3, found %v.\", len(vals))\n\t}\n}\n\nfunc TestForRange(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tinitLen := sel.Length()\n\tfor i := range sel.Nodes {\n\t\tsingle := sel.Eq(i)\n\t\t//h, err := single.Html()\n\t\t//if err != nil {\n\t\t//\tt.Fatal(err)\n\t\t//}\n\t\t//fmt.Println(i, h)\n\t\tif single.Length() != 1 {\n\t\t\tt.Errorf(\"%d: expected length of 1, got %d\", i, single.Length())\n\t\t}\n\t}\n\tif sel.Length() != initLen {\n\t\tt.Errorf(\"expected initial selection to still have length %d, got %d\", initLen, sel.Length())\n\t}\n}\n\nfunc TestGenericMap(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tvals := Map(sel, func(i int, s *Selection) *html.NodeType {\n\t\tn := s.Get(0)\n\t\tif n.Type == html.ElementNode {\n\t\t\treturn &n.Type\n\t\t}\n\t\treturn nil\n\t})\n\tfor _, v := range vals {\n\t\tif v == nil || *v != html.ElementNode {\n\t\t\tt.Error(\"Expected Map array result to be all 'div's.\")\n\t\t}\n\t}\n\tif len(vals) != 3 {\n\t\tt.Errorf(\"Expected Map array result to have a length of 3, found %v.\", len(vals))\n\t}\n}\n\nfunc TestEachIter(t *testing.T) {\n\tvar cnt int\n\n\tsel := Doc().Find(\".hero-unit .row-fluid\")\n\n\tfor i, s := range sel.EachIter() {\n\t\tcnt++\n\t\tt.Logf(\"At index %v, node %v\", i, s.Nodes[0].Data)\n\t}\n\n\tsel = sel.Find(\"a\")\n\n\tif cnt != 4 {\n\t\tt.Errorf(\"Expected Each() to call function 4 times, got %v times.\", cnt)\n\t}\n\tassertLength(t, sel.Nodes, 6)\n}\n\nfunc TestEachIterWithBreak(t *testing.T) {\n\tvar cnt int\n\n\tsel := Doc().Find(\".hero-unit .row-fluid\")\n\tfor i, s := range sel.EachIter() {\n\t\tcnt++\n\t\tt.Logf(\"At index %v, node %v\", i, s.Nodes[0].Data)\n\t\tbreak\n\t}\n\n\tsel = sel.Find(\"a\")\n\n\tif cnt != 1 {\n\t\tt.Errorf(\"Expected Each() to call function 1 time, got %v times.\", cnt)\n\t}\n\tassertLength(t, sel.Nodes, 6)\n}\n"
        },
        {
          "name": "manipulation.go",
          "type": "blob",
          "size": 21.2724609375,
          "content": "package goquery\n\nimport (\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n)\n\n// After applies the selector from the root document and inserts the matched elements\n// after the elements in the set of matched elements.\n//\n// If one of the matched elements in the selection is not currently in the\n// document, it's impossible to insert nodes after it, so it will be ignored.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) After(selector string) *Selection {\n\treturn s.AfterMatcher(compileMatcher(selector))\n}\n\n// AfterMatcher applies the matcher from the root document and inserts the matched elements\n// after the elements in the set of matched elements.\n//\n// If one of the matched elements in the selection is not currently in the\n// document, it's impossible to insert nodes after it, so it will be ignored.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) AfterMatcher(m Matcher) *Selection {\n\treturn s.AfterNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// AfterSelection inserts the elements in the selection after each element in the set of matched\n// elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) AfterSelection(sel *Selection) *Selection {\n\treturn s.AfterNodes(sel.Nodes...)\n}\n\n// AfterHtml parses the html and inserts it after the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) AfterHtml(htmlStr string) *Selection {\n\treturn s.eachNodeHtml(htmlStr, true, func(node *html.Node, nodes []*html.Node) {\n\t\tnextSibling := node.NextSibling\n\t\tfor _, n := range nodes {\n\t\t\tif node.Parent != nil {\n\t\t\t\tnode.Parent.InsertBefore(n, nextSibling)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// AfterNodes inserts the nodes after each element in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) AfterNodes(ns ...*html.Node) *Selection {\n\treturn s.manipulateNodes(ns, true, func(sn *html.Node, n *html.Node) {\n\t\tif sn.Parent != nil {\n\t\t\tsn.Parent.InsertBefore(n, sn.NextSibling)\n\t\t}\n\t})\n}\n\n// Append appends the elements specified by the selector to the end of each element\n// in the set of matched elements, following those rules:\n//\n// 1) The selector is applied to the root document.\n//\n// 2) Elements that are part of the document will be moved to the new location.\n//\n// 3) If there are multiple locations to append to, cloned nodes will be\n// appended to all target locations except the last one, which will be moved\n// as noted in (2).\nfunc (s *Selection) Append(selector string) *Selection {\n\treturn s.AppendMatcher(compileMatcher(selector))\n}\n\n// AppendMatcher appends the elements specified by the matcher to the end of each element\n// in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) AppendMatcher(m Matcher) *Selection {\n\treturn s.AppendNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// AppendSelection appends the elements in the selection to the end of each element\n// in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) AppendSelection(sel *Selection) *Selection {\n\treturn s.AppendNodes(sel.Nodes...)\n}\n\n// AppendHtml parses the html and appends it to the set of matched elements.\nfunc (s *Selection) AppendHtml(htmlStr string) *Selection {\n\treturn s.eachNodeHtml(htmlStr, false, func(node *html.Node, nodes []*html.Node) {\n\t\tfor _, n := range nodes {\n\t\t\tnode.AppendChild(n)\n\t\t}\n\t})\n}\n\n// AppendNodes appends the specified nodes to each node in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) AppendNodes(ns ...*html.Node) *Selection {\n\treturn s.manipulateNodes(ns, false, func(sn *html.Node, n *html.Node) {\n\t\tsn.AppendChild(n)\n\t})\n}\n\n// Before inserts the matched elements before each element in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) Before(selector string) *Selection {\n\treturn s.BeforeMatcher(compileMatcher(selector))\n}\n\n// BeforeMatcher inserts the matched elements before each element in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) BeforeMatcher(m Matcher) *Selection {\n\treturn s.BeforeNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// BeforeSelection inserts the elements in the selection before each element in the set of matched\n// elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) BeforeSelection(sel *Selection) *Selection {\n\treturn s.BeforeNodes(sel.Nodes...)\n}\n\n// BeforeHtml parses the html and inserts it before the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) BeforeHtml(htmlStr string) *Selection {\n\treturn s.eachNodeHtml(htmlStr, true, func(node *html.Node, nodes []*html.Node) {\n\t\tfor _, n := range nodes {\n\t\t\tif node.Parent != nil {\n\t\t\t\tnode.Parent.InsertBefore(n, node)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// BeforeNodes inserts the nodes before each element in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) BeforeNodes(ns ...*html.Node) *Selection {\n\treturn s.manipulateNodes(ns, false, func(sn *html.Node, n *html.Node) {\n\t\tif sn.Parent != nil {\n\t\t\tsn.Parent.InsertBefore(n, sn)\n\t\t}\n\t})\n}\n\n// Clone creates a deep copy of the set of matched nodes. The new nodes will not be\n// attached to the document.\nfunc (s *Selection) Clone() *Selection {\n\tns := newEmptySelection(s.document)\n\tns.Nodes = cloneNodes(s.Nodes)\n\treturn ns\n}\n\n// Empty removes all children nodes from the set of matched elements.\n// It returns the children nodes in a new Selection.\nfunc (s *Selection) Empty() *Selection {\n\tvar nodes []*html.Node\n\n\tfor _, n := range s.Nodes {\n\t\tfor c := n.FirstChild; c != nil; c = n.FirstChild {\n\t\t\tn.RemoveChild(c)\n\t\t\tnodes = append(nodes, c)\n\t\t}\n\t}\n\n\treturn pushStack(s, nodes)\n}\n\n// Prepend prepends the elements specified by the selector to each element in\n// the set of matched elements, following the same rules as Append.\nfunc (s *Selection) Prepend(selector string) *Selection {\n\treturn s.PrependMatcher(compileMatcher(selector))\n}\n\n// PrependMatcher prepends the elements specified by the matcher to each\n// element in the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) PrependMatcher(m Matcher) *Selection {\n\treturn s.PrependNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// PrependSelection prepends the elements in the selection to each element in\n// the set of matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) PrependSelection(sel *Selection) *Selection {\n\treturn s.PrependNodes(sel.Nodes...)\n}\n\n// PrependHtml parses the html and prepends it to the set of matched elements.\nfunc (s *Selection) PrependHtml(htmlStr string) *Selection {\n\treturn s.eachNodeHtml(htmlStr, false, func(node *html.Node, nodes []*html.Node) {\n\t\tfirstChild := node.FirstChild\n\t\tfor _, n := range nodes {\n\t\t\tnode.InsertBefore(n, firstChild)\n\t\t}\n\t})\n}\n\n// PrependNodes prepends the specified nodes to each node in the set of\n// matched elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) PrependNodes(ns ...*html.Node) *Selection {\n\treturn s.manipulateNodes(ns, true, func(sn *html.Node, n *html.Node) {\n\t\t// sn.FirstChild may be nil, in which case this functions like\n\t\t// sn.AppendChild()\n\t\tsn.InsertBefore(n, sn.FirstChild)\n\t})\n}\n\n// Remove removes the set of matched elements from the document.\n// It returns the same selection, now consisting of nodes not in the document.\nfunc (s *Selection) Remove() *Selection {\n\tfor _, n := range s.Nodes {\n\t\tif n.Parent != nil {\n\t\t\tn.Parent.RemoveChild(n)\n\t\t}\n\t}\n\n\treturn s\n}\n\n// RemoveFiltered removes from the current set of matched elements those that\n// match the selector filter. It returns the Selection of removed nodes.\n//\n// For example if the selection s contains \"<h1>\", \"<h2>\" and \"<h3>\"\n// and s.RemoveFiltered(\"h2\") is called, only the \"<h2>\" node is removed\n// (and returned), while \"<h1>\" and \"<h3>\" are kept in the document.\nfunc (s *Selection) RemoveFiltered(selector string) *Selection {\n\treturn s.RemoveMatcher(compileMatcher(selector))\n}\n\n// RemoveMatcher removes from the current set of matched elements those that\n// match the Matcher filter. It returns the Selection of removed nodes.\n// See RemoveFiltered for additional information.\nfunc (s *Selection) RemoveMatcher(m Matcher) *Selection {\n\treturn s.FilterMatcher(m).Remove()\n}\n\n// ReplaceWith replaces each element in the set of matched elements with the\n// nodes matched by the given selector.\n// It returns the removed elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) ReplaceWith(selector string) *Selection {\n\treturn s.ReplaceWithMatcher(compileMatcher(selector))\n}\n\n// ReplaceWithMatcher replaces each element in the set of matched elements with\n// the nodes matched by the given Matcher.\n// It returns the removed elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) ReplaceWithMatcher(m Matcher) *Selection {\n\treturn s.ReplaceWithNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// ReplaceWithSelection replaces each element in the set of matched elements with\n// the nodes from the given Selection.\n// It returns the removed elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) ReplaceWithSelection(sel *Selection) *Selection {\n\treturn s.ReplaceWithNodes(sel.Nodes...)\n}\n\n// ReplaceWithHtml replaces each element in the set of matched elements with\n// the parsed HTML.\n// It returns the removed elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) ReplaceWithHtml(htmlStr string) *Selection {\n\ts.eachNodeHtml(htmlStr, true, func(node *html.Node, nodes []*html.Node) {\n\t\tnextSibling := node.NextSibling\n\t\tfor _, n := range nodes {\n\t\t\tif node.Parent != nil {\n\t\t\t\tnode.Parent.InsertBefore(n, nextSibling)\n\t\t\t}\n\t\t}\n\t})\n\treturn s.Remove()\n}\n\n// ReplaceWithNodes replaces each element in the set of matched elements with\n// the given nodes.\n// It returns the removed elements.\n//\n// This follows the same rules as Selection.Append.\nfunc (s *Selection) ReplaceWithNodes(ns ...*html.Node) *Selection {\n\ts.AfterNodes(ns...)\n\treturn s.Remove()\n}\n\n// SetHtml sets the html content of each element in the selection to\n// specified html string.\nfunc (s *Selection) SetHtml(htmlStr string) *Selection {\n\tfor _, context := range s.Nodes {\n\t\tfor c := context.FirstChild; c != nil; c = context.FirstChild {\n\t\t\tcontext.RemoveChild(c)\n\t\t}\n\t}\n\treturn s.eachNodeHtml(htmlStr, false, func(node *html.Node, nodes []*html.Node) {\n\t\tfor _, n := range nodes {\n\t\t\tnode.AppendChild(n)\n\t\t}\n\t})\n}\n\n// SetText sets the content of each element in the selection to specified content.\n// The provided text string is escaped.\nfunc (s *Selection) SetText(text string) *Selection {\n\treturn s.SetHtml(html.EscapeString(text))\n}\n\n// Unwrap removes the parents of the set of matched elements, leaving the matched\n// elements (and their siblings, if any) in their place.\n// It returns the original selection.\nfunc (s *Selection) Unwrap() *Selection {\n\ts.Parent().Each(func(i int, ss *Selection) {\n\t\t// For some reason, jquery allows unwrap to remove the <head> element, so\n\t\t// allowing it here too. Same for <html>. Why it allows those elements to\n\t\t// be unwrapped while not allowing body is a mystery to me.\n\t\tif ss.Nodes[0].Data != \"body\" {\n\t\t\tss.ReplaceWithSelection(ss.Contents())\n\t\t}\n\t})\n\n\treturn s\n}\n\n// Wrap wraps each element in the set of matched elements inside the first\n// element matched by the given selector. The matched child is cloned before\n// being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) Wrap(selector string) *Selection {\n\treturn s.WrapMatcher(compileMatcher(selector))\n}\n\n// WrapMatcher wraps each element in the set of matched elements inside the\n// first element matched by the given matcher. The matched child is cloned\n// before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapMatcher(m Matcher) *Selection {\n\treturn s.wrapNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// WrapSelection wraps each element in the set of matched elements inside the\n// first element in the given Selection. The element is cloned before being\n// inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapSelection(sel *Selection) *Selection {\n\treturn s.wrapNodes(sel.Nodes...)\n}\n\n// WrapHtml wraps each element in the set of matched elements inside the inner-\n// most child of the given HTML.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapHtml(htmlStr string) *Selection {\n\tnodesMap := make(map[string][]*html.Node)\n\tfor _, context := range s.Nodes {\n\t\tvar parent *html.Node\n\t\tif context.Parent != nil {\n\t\t\tparent = context.Parent\n\t\t} else {\n\t\t\tparent = &html.Node{Type: html.ElementNode}\n\t\t}\n\t\tnodes, found := nodesMap[nodeName(parent)]\n\t\tif !found {\n\t\t\tnodes = parseHtmlWithContext(htmlStr, parent)\n\t\t\tnodesMap[nodeName(parent)] = nodes\n\t\t}\n\t\tnewSingleSelection(context, s.document).wrapAllNodes(cloneNodes(nodes)...)\n\t}\n\treturn s\n}\n\n// WrapNode wraps each element in the set of matched elements inside the inner-\n// most child of the given node. The given node is copied before being inserted\n// into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapNode(n *html.Node) *Selection {\n\treturn s.wrapNodes(n)\n}\n\nfunc (s *Selection) wrapNodes(ns ...*html.Node) *Selection {\n\ts.Each(func(i int, ss *Selection) {\n\t\tss.wrapAllNodes(ns...)\n\t})\n\n\treturn s\n}\n\n// WrapAll wraps a single HTML structure, matched by the given selector, around\n// all elements in the set of matched elements. The matched child is cloned\n// before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapAll(selector string) *Selection {\n\treturn s.WrapAllMatcher(compileMatcher(selector))\n}\n\n// WrapAllMatcher wraps a single HTML structure, matched by the given Matcher,\n// around all elements in the set of matched elements. The matched child is\n// cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapAllMatcher(m Matcher) *Selection {\n\treturn s.wrapAllNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// WrapAllSelection wraps a single HTML structure, the first node of the given\n// Selection, around all elements in the set of matched elements. The matched\n// child is cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapAllSelection(sel *Selection) *Selection {\n\treturn s.wrapAllNodes(sel.Nodes...)\n}\n\n// WrapAllHtml wraps the given HTML structure around all elements in the set of\n// matched elements. The matched child is cloned before being inserted into the\n// document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapAllHtml(htmlStr string) *Selection {\n\tvar context *html.Node\n\tvar nodes []*html.Node\n\tif len(s.Nodes) > 0 {\n\t\tcontext = s.Nodes[0]\n\t\tif context.Parent != nil {\n\t\t\tnodes = parseHtmlWithContext(htmlStr, context)\n\t\t} else {\n\t\t\tnodes = parseHtml(htmlStr)\n\t\t}\n\t}\n\treturn s.wrapAllNodes(nodes...)\n}\n\nfunc (s *Selection) wrapAllNodes(ns ...*html.Node) *Selection {\n\tif len(ns) > 0 {\n\t\treturn s.WrapAllNode(ns[0])\n\t}\n\treturn s\n}\n\n// WrapAllNode wraps the given node around the first element in the Selection,\n// making all other nodes in the Selection children of the given node. The node\n// is cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapAllNode(n *html.Node) *Selection {\n\tif s.Size() == 0 {\n\t\treturn s\n\t}\n\n\twrap := cloneNode(n)\n\n\tfirst := s.Nodes[0]\n\tif first.Parent != nil {\n\t\tfirst.Parent.InsertBefore(wrap, first)\n\t\tfirst.Parent.RemoveChild(first)\n\t}\n\n\tfor c := getFirstChildEl(wrap); c != nil; c = getFirstChildEl(wrap) {\n\t\twrap = c\n\t}\n\n\tnewSingleSelection(wrap, s.document).AppendSelection(s)\n\n\treturn s\n}\n\n// WrapInner wraps an HTML structure, matched by the given selector, around the\n// content of element in the set of matched elements. The matched child is\n// cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapInner(selector string) *Selection {\n\treturn s.WrapInnerMatcher(compileMatcher(selector))\n}\n\n// WrapInnerMatcher wraps an HTML structure, matched by the given selector,\n// around the content of element in the set of matched elements. The matched\n// child is cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapInnerMatcher(m Matcher) *Selection {\n\treturn s.wrapInnerNodes(m.MatchAll(s.document.rootNode)...)\n}\n\n// WrapInnerSelection wraps an HTML structure, matched by the given selector,\n// around the content of element in the set of matched elements. The matched\n// child is cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapInnerSelection(sel *Selection) *Selection {\n\treturn s.wrapInnerNodes(sel.Nodes...)\n}\n\n// WrapInnerHtml wraps an HTML structure, matched by the given selector, around\n// the content of element in the set of matched elements. The matched child is\n// cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapInnerHtml(htmlStr string) *Selection {\n\tnodesMap := make(map[string][]*html.Node)\n\tfor _, context := range s.Nodes {\n\t\tnodes, found := nodesMap[nodeName(context)]\n\t\tif !found {\n\t\t\tnodes = parseHtmlWithContext(htmlStr, context)\n\t\t\tnodesMap[nodeName(context)] = nodes\n\t\t}\n\t\tnewSingleSelection(context, s.document).wrapInnerNodes(cloneNodes(nodes)...)\n\t}\n\treturn s\n}\n\n// WrapInnerNode wraps an HTML structure, matched by the given selector, around\n// the content of element in the set of matched elements. The matched child is\n// cloned before being inserted into the document.\n//\n// It returns the original set of elements.\nfunc (s *Selection) WrapInnerNode(n *html.Node) *Selection {\n\treturn s.wrapInnerNodes(n)\n}\n\nfunc (s *Selection) wrapInnerNodes(ns ...*html.Node) *Selection {\n\tif len(ns) == 0 {\n\t\treturn s\n\t}\n\n\ts.Each(func(i int, s *Selection) {\n\t\tcontents := s.Contents()\n\n\t\tif contents.Size() > 0 {\n\t\t\tcontents.wrapAllNodes(ns...)\n\t\t} else {\n\t\t\ts.AppendNodes(cloneNode(ns[0]))\n\t\t}\n\t})\n\n\treturn s\n}\n\nfunc parseHtml(h string) []*html.Node {\n\t// Errors are only returned when the io.Reader returns any error besides\n\t// EOF, but strings.Reader never will\n\tnodes, err := html.ParseFragment(strings.NewReader(h), &html.Node{Type: html.ElementNode})\n\tif err != nil {\n\t\tpanic(\"goquery: failed to parse HTML: \" + err.Error())\n\t}\n\treturn nodes\n}\n\nfunc parseHtmlWithContext(h string, context *html.Node) []*html.Node {\n\t// Errors are only returned when the io.Reader returns any error besides\n\t// EOF, but strings.Reader never will\n\tnodes, err := html.ParseFragment(strings.NewReader(h), context)\n\tif err != nil {\n\t\tpanic(\"goquery: failed to parse HTML: \" + err.Error())\n\t}\n\treturn nodes\n}\n\n// Get the first child that is an ElementNode\nfunc getFirstChildEl(n *html.Node) *html.Node {\n\tc := n.FirstChild\n\tfor c != nil && c.Type != html.ElementNode {\n\t\tc = c.NextSibling\n\t}\n\treturn c\n}\n\n// Deep copy a slice of nodes.\nfunc cloneNodes(ns []*html.Node) []*html.Node {\n\tcns := make([]*html.Node, 0, len(ns))\n\n\tfor _, n := range ns {\n\t\tcns = append(cns, cloneNode(n))\n\t}\n\n\treturn cns\n}\n\n// Deep copy a node. The new node has clones of all the original node's\n// children but none of its parents or siblings.\nfunc cloneNode(n *html.Node) *html.Node {\n\tnn := &html.Node{\n\t\tType:     n.Type,\n\t\tDataAtom: n.DataAtom,\n\t\tData:     n.Data,\n\t\tAttr:     make([]html.Attribute, len(n.Attr)),\n\t}\n\n\tcopy(nn.Attr, n.Attr)\n\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\tnn.AppendChild(cloneNode(c))\n\t}\n\n\treturn nn\n}\n\nfunc (s *Selection) manipulateNodes(ns []*html.Node, reverse bool,\n\tf func(sn *html.Node, n *html.Node)) *Selection {\n\n\tlasti := s.Size() - 1\n\n\t// net.Html doesn't provide document fragments for insertion, so to get\n\t// things in the correct order with After() and Prepend(), the callback\n\t// needs to be called on the reverse of the nodes.\n\tif reverse {\n\t\tfor i, j := 0, len(ns)-1; i < j; i, j = i+1, j-1 {\n\t\t\tns[i], ns[j] = ns[j], ns[i]\n\t\t}\n\t}\n\n\tfor i, sn := range s.Nodes {\n\t\tfor _, n := range ns {\n\t\t\tif i != lasti {\n\t\t\t\tf(sn, cloneNode(n))\n\t\t\t} else {\n\t\t\t\tif n.Parent != nil {\n\t\t\t\t\tn.Parent.RemoveChild(n)\n\t\t\t\t}\n\t\t\t\tf(sn, n)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s\n}\n\n// eachNodeHtml parses the given html string and inserts the resulting nodes in the dom with the mergeFn.\n// The parsed nodes are inserted for each element of the selection.\n// isParent can be used to indicate that the elements of the selection should be treated as the parent for the parsed html.\n// A cache is used to avoid parsing the html multiple times should the elements of the selection result in the same context.\nfunc (s *Selection) eachNodeHtml(htmlStr string, isParent bool, mergeFn func(n *html.Node, nodes []*html.Node)) *Selection {\n\t// cache to avoid parsing the html for the same context multiple times\n\tnodeCache := make(map[string][]*html.Node)\n\tvar context *html.Node\n\tfor _, n := range s.Nodes {\n\t\tif isParent {\n\t\t\tcontext = n.Parent\n\t\t} else {\n\t\t\tif n.Type != html.ElementNode {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcontext = n\n\t\t}\n\t\tif context != nil {\n\t\t\tnodes, found := nodeCache[nodeName(context)]\n\t\t\tif !found {\n\t\t\t\tnodes = parseHtmlWithContext(htmlStr, context)\n\t\t\t\tnodeCache[nodeName(context)] = nodes\n\t\t\t}\n\t\t\tmergeFn(n, cloneNodes(nodes))\n\t\t}\n\t}\n\treturn s\n}\n"
        },
        {
          "name": "manipulation_test.go",
          "type": "blob",
          "size": 17.5546875,
          "content": "package goquery\n\nimport (\n\t\"log\"\n\t\"testing\"\n)\n\nconst (\n\twrapHtml = \"<div id=\\\"ins\\\">test string<div><p><em><b></b></em></p></div></div>\"\n)\n\nfunc TestAfter(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").After(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#main #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#foot #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main + #nf6\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAfterMany(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\".one\").After(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#foot #nf6\").Nodes, 1)\n\tassertLength(t, doc.Find(\"#main #nf6\").Nodes, 1)\n\tassertLength(t, doc.Find(\".one + #nf6\").Nodes, 2)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAfterWithRemoved(t *testing.T) {\n\tdoc := Doc2Clone()\n\ts := doc.Find(\"#main\").Remove()\n\ts.After(\"#nf6\")\n\n\tassertLength(t, s.Find(\"#nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#nf6\").Nodes, 0)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAfterSelection(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").AfterSelection(doc.Find(\"#nf1, #nf2\"))\n\n\tassertLength(t, doc.Find(\"#main #nf1, #main #nf2\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#foot #nf1, #foot #nf2\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main + #nf1, #nf1 + #nf2\").Nodes, 2)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAfterHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").AfterHtml(\"<strong>new node</strong>\")\n\n\tassertLength(t, doc.Find(\"#main + strong\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAfterHtmlContext(t *testing.T) {\n\tdoc := loadString(t, `\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before1</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before2</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</body>\n\t\t</html>`)\n\tdoc.Find(\"table tr td\").AfterHtml(\"<td class='c1'>Test</td><td class='c2'>Again</td>\")\n\tassertLength(t, doc.Find(\"table tr td\").Nodes, 6)\n\tassertClass(t, doc.Find(\"table tr td\").Last(), \"c2\")\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAppend(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").Append(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#foot #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main #nf6\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAppendBody(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"body\").Append(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#foot #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"body > #nf6\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAppendSelection(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").AppendSelection(doc.Find(\"#nf1, #nf2\"))\n\n\tassertLength(t, doc.Find(\"#foot #nf1\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#foot #nf2\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main #nf1\").Nodes, 1)\n\tassertLength(t, doc.Find(\"#main #nf2\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAppendSelectionExisting(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").AppendSelection(doc.Find(\"#n1, #n2\"))\n\n\tassertClass(t, doc.Find(\"#main :nth-child(1)\"), \"three\")\n\tassertClass(t, doc.Find(\"#main :nth-child(5)\"), \"one\")\n\tassertClass(t, doc.Find(\"#main :nth-child(6)\"), \"two\")\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAppendClone(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#n1\").AppendSelection(doc.Find(\"#nf1\").Clone())\n\n\tassertLength(t, doc.Find(\"#foot #nf1\").Nodes, 1)\n\tassertLength(t, doc.Find(\"#main #nf1\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAppendHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"div\").AppendHtml(\"<strong>new node</strong>\")\n\n\tassertLength(t, doc.Find(\"strong\").Nodes, 14)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestAppendHtmlContext(t *testing.T) {\n\tdoc := loadString(t, `\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before1</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before2</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</body>\n\t\t</html>`)\n\tdoc.Find(\"table tr\").AppendHtml(\"<td class='c1'>new1</td><td class='c2'>new2</td>\")\n\n\tassertLength(t, doc.Find(\"table td\").Nodes, 6)\n\tassertClass(t, doc.Find(\"table td\").Last(), \"c2\")\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestBefore(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").Before(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#main #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#foot #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"body > #nf6:first-child\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestBeforeWithRemoved(t *testing.T) {\n\tdoc := Doc2Clone()\n\ts := doc.Find(\"#main\").Remove()\n\ts.Before(\"#nf6\")\n\n\tassertLength(t, s.Find(\"#nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#nf6\").Nodes, 0)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestBeforeSelection(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").BeforeSelection(doc.Find(\"#nf1, #nf2\"))\n\n\tassertLength(t, doc.Find(\"#main #nf1, #main #nf2\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#foot #nf1, #foot #nf2\").Nodes, 0)\n\tassertLength(t, doc.Find(\"body > #nf1:first-child, #nf1 + #nf2\").Nodes, 2)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestBeforeHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").BeforeHtml(\"<strong>new node</strong>\")\n\n\tassertLength(t, doc.Find(\"body > strong:first-child\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestBeforeHtmlContext(t *testing.T) {\n\tdoc := loadString(t, `\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before1</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before2</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</body>\n\t\t</html>`)\n\tdoc.Find(\"table tr td:first-child\").BeforeHtml(\"<td class='c1'>new1</td><td class='c2'>new2</td>\")\n\n\tassertLength(t, doc.Find(\"table td\").Nodes, 6)\n\tassertClass(t, doc.Find(\"table td\").First(), \"c1\")\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestEmpty(t *testing.T) {\n\tdoc := Doc2Clone()\n\ts := doc.Find(\"#main\").Empty()\n\n\tassertLength(t, doc.Find(\"#main\").Children().Nodes, 0)\n\tassertLength(t, s.Filter(\"div\").Nodes, 6)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestPrepend(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").Prepend(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#foot #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main #nf6:first-child\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestPrependBody(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"body\").Prepend(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#foot #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main #nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"body > #nf6:first-child\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestPrependSelection(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").PrependSelection(doc.Find(\"#nf1, #nf2\"))\n\n\tassertLength(t, doc.Find(\"#foot #nf1\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#foot #nf2\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main #nf1:first-child\").Nodes, 1)\n\tassertLength(t, doc.Find(\"#main #nf2:nth-child(2)\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestPrependSelectionExisting(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main\").PrependSelection(doc.Find(\"#n5, #n6\"))\n\n\tassertClass(t, doc.Find(\"#main :nth-child(1)\"), \"five\")\n\tassertClass(t, doc.Find(\"#main :nth-child(2)\"), \"six\")\n\tassertClass(t, doc.Find(\"#main :nth-child(5)\"), \"three\")\n\tassertClass(t, doc.Find(\"#main :nth-child(6)\"), \"four\")\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestPrependClone(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#n1\").PrependSelection(doc.Find(\"#nf1\").Clone())\n\n\tassertLength(t, doc.Find(\"#foot #nf1:first-child\").Nodes, 1)\n\tassertLength(t, doc.Find(\"#main #nf1:first-child\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestPrependHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"div\").PrependHtml(\"<strong>new node</strong>\")\n\n\tassertLength(t, doc.Find(\"strong:first-child\").Nodes, 14)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestPrependHtmlContext(t *testing.T) {\n\tdoc := loadString(t, `\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before1</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>Before2</td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</body>\n\t\t</html>`)\n\tdoc.Find(\"table tr\").PrependHtml(\"<td class='c1'>new node</td><td class='c2'>other new node</td>\")\n\n\tassertLength(t, doc.Find(\"table td\").Nodes, 6)\n\tassertClass(t, doc.Find(\"table tr td\").First(), \"c1\")\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestRemove(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#nf1\").Remove()\n\n\tassertLength(t, doc.Find(\"#foot #nf1\").Nodes, 0)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestRemoveAll(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"*\").Remove()\n\n\tassertLength(t, doc.Find(\"*\").Nodes, 0)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestRemoveRoot(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"html\").Remove()\n\n\tassertLength(t, doc.Find(\"html\").Nodes, 0)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestRemoveFiltered(t *testing.T) {\n\tdoc := Doc2Clone()\n\tnf6 := doc.Find(\"#nf6\")\n\ts := doc.Find(\"div\").RemoveFiltered(\"#nf6\")\n\n\tassertLength(t, doc.Find(\"#nf6\").Nodes, 0)\n\tassertLength(t, s.Nodes, 1)\n\tif nf6.Nodes[0] != s.Nodes[0] {\n\t\tt.Error(\"Removed node does not match original\")\n\t}\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestReplaceWith(t *testing.T) {\n\tdoc := Doc2Clone()\n\n\tdoc.Find(\"#nf6\").ReplaceWith(\"#main\")\n\tassertLength(t, doc.Find(\"#foot #main:last-child\").Nodes, 1)\n\tprintSel(t, doc.Selection)\n\n\tdoc.Find(\"#foot\").ReplaceWith(\"#main\")\n\tassertLength(t, doc.Find(\"#foot\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main\").Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestReplaceWithHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#main, #foot\").ReplaceWithHtml(\"<div id=\\\"replace\\\"></div>\")\n\n\tassertLength(t, doc.Find(\"#replace\").Nodes, 2)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestReplaceWithHtmlContext(t *testing.T) {\n\tdoc := loadString(t, `\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>Before1</th>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>Before2</th>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</body>\n\t\t</html>`)\n\tdoc.Find(\"table th\").ReplaceWithHtml(\"<td class='c1'>Test</td><td class='c2'>Replace</td>\")\n\n\tassertLength(t, doc.Find(\"table th\").Nodes, 0)\n\tassertLength(t, doc.Find(\"table tr td\").Nodes, 4)\n\tassertClass(t, doc.Find(\"table tr td\").First(), \"c1\")\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestSetHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tq := doc.Find(\"#main, #foot\")\n\tq.SetHtml(`<div id=\"replace\">test</div>`)\n\n\tassertLength(t, doc.Find(\"#replace\").Nodes, 2)\n\tassertLength(t, doc.Find(\"#main, #foot\").Nodes, 2)\n\n\tif q.Text() != \"testtest\" {\n\t\tt.Errorf(\"Expected text to be %v, found %v\", \"testtest\", q.Text())\n\t}\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestSetHtmlNoMatch(t *testing.T) {\n\tdoc := Doc2Clone()\n\tq := doc.Find(\"#notthere\")\n\tq.SetHtml(`<div id=\"replace\">test</div>`)\n\n\tassertLength(t, doc.Find(\"#replace\").Nodes, 0)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestSetHtmlEmpty(t *testing.T) {\n\tdoc := Doc2Clone()\n\tq := doc.Find(\"#main\")\n\tq.SetHtml(``)\n\n\tassertLength(t, doc.Find(\"#main\").Nodes, 1)\n\tassertLength(t, doc.Find(\"#main\").Children().Nodes, 0)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestSetHtmlContext(t *testing.T) {\n\tdoc := loadString(t, `\n\t\t<html>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>Before1</th>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>Before2</th>\n\t\t\t\t\t</tr>\n\t\t\t\t</table>\n\t\t\t</body>\n\t\t</html>`)\n\tdoc.Find(\"table tr\").SetHtml(\"<td class='c1'>Test</td><td class='c2'>Again</td>\")\n\n\tassertLength(t, doc.Find(\"table th\").Nodes, 0)\n\tassertLength(t, doc.Find(\"table td\").Nodes, 4)\n\tassertLength(t, doc.Find(\"table tr\").Nodes, 2)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestSetText(t *testing.T) {\n\tdoc := Doc2Clone()\n\tq := doc.Find(\"#main, #foot\")\n\trepl := \"<div id=\\\"replace\\\">test</div>\"\n\tq.SetText(repl)\n\n\tassertLength(t, doc.Find(\"#replace\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main, #foot\").Nodes, 2)\n\n\tif q.Text() != (repl + repl) {\n\t\tt.Errorf(\"Expected text to be %v, found %v\", (repl + repl), q.Text())\n\t}\n\n\th, err := q.Html()\n\tif err != nil {\n\t\tt.Errorf(\"Error: %v\", err)\n\t}\n\tesc := \"&lt;div id=&#34;replace&#34;&gt;test&lt;/div&gt;\"\n\tif h != esc {\n\t\tt.Errorf(\"Expected html to be %v, found %v\", esc, h)\n\t}\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestReplaceWithSelection(t *testing.T) {\n\tdoc := Doc2Clone()\n\tsel := doc.Find(\"#nf6\").ReplaceWithSelection(doc.Find(\"#nf5\"))\n\n\tassertSelectionIs(t, sel, \"#nf6\")\n\tassertLength(t, doc.Find(\"#nf6\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#nf5\").Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestUnwrap(t *testing.T) {\n\tdoc := Doc2Clone()\n\n\tdoc.Find(\"#nf5\").Unwrap()\n\tassertLength(t, doc.Find(\"#foot\").Nodes, 0)\n\tassertLength(t, doc.Find(\"body > #nf1\").Nodes, 1)\n\tassertLength(t, doc.Find(\"body > #nf5\").Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n\n\tdoc = Doc2Clone()\n\n\tdoc.Find(\"#nf5, #n1\").Unwrap()\n\tassertLength(t, doc.Find(\"#foot\").Nodes, 0)\n\tassertLength(t, doc.Find(\"#main\").Nodes, 0)\n\tassertLength(t, doc.Find(\"body > #n1\").Nodes, 1)\n\tassertLength(t, doc.Find(\"body > #nf5\").Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestUnwrapBody(t *testing.T) {\n\tdoc := Doc2Clone()\n\n\tdoc.Find(\"#main\").Unwrap()\n\tassertLength(t, doc.Find(\"body\").Nodes, 1)\n\tassertLength(t, doc.Find(\"body > #main\").Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestUnwrapHead(t *testing.T) {\n\tdoc := Doc2Clone()\n\n\tdoc.Find(\"title\").Unwrap()\n\tassertLength(t, doc.Find(\"head\").Nodes, 0)\n\tassertLength(t, doc.Find(\"head > title\").Nodes, 0)\n\tassertLength(t, doc.Find(\"title\").Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestUnwrapHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\n\tdoc.Find(\"head\").Unwrap()\n\tassertLength(t, doc.Find(\"html\").Nodes, 0)\n\tassertLength(t, doc.Find(\"html head\").Nodes, 0)\n\tassertLength(t, doc.Find(\"head\").Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrap(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#nf1\").Wrap(\"#nf2\")\n\tnf1 := doc.Find(\"#foot #nf2 #nf1\")\n\tassertLength(t, nf1.Nodes, 1)\n\n\tnf2 := doc.Find(\"#nf2\")\n\tassertLength(t, nf2.Nodes, 2)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapEmpty(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#nf1\").Wrap(\"#doesnt-exist\")\n\n\torigHtml, _ := Doc2().Html()\n\tnewHtml, _ := doc.Html()\n\n\tif origHtml != newHtml {\n\t\tt.Error(\"Expected the two documents to be identical.\")\n\t}\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\".odd\").WrapHtml(wrapHtml)\n\tnf2 := doc.Find(\"#ins #nf2\")\n\tassertLength(t, nf2.Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapSelection(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#nf1\").WrapSelection(doc.Find(\"#nf2\"))\n\tnf1 := doc.Find(\"#foot #nf2 #nf1\")\n\tassertLength(t, nf1.Nodes, 1)\n\n\tnf2 := doc.Find(\"#nf2\")\n\tassertLength(t, nf2.Nodes, 2)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapAll(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\".odd\").WrapAll(\"#nf1\")\n\tnf1 := doc.Find(\"#main #nf1\")\n\tassertLength(t, nf1.Nodes, 1)\n\n\tsel := nf1.Find(\"#n2 ~ #n4 ~ #n6 ~ #nf2 ~ #nf4 ~ #nf6\")\n\tassertLength(t, sel.Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapAllHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\".odd\").WrapAllHtml(wrapHtml)\n\tnf1 := doc.Find(\"#main div#ins div p em b #n2 ~ #n4 ~ #n6 ~ #nf2 ~ #nf4 ~ #nf6\")\n\tassertLength(t, nf1.Nodes, 1)\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapInnerNoContent(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\".one\").WrapInner(\".two\")\n\n\ttwos := doc.Find(\".two\")\n\tassertLength(t, twos.Nodes, 4)\n\tassertLength(t, doc.Find(\".one .two\").Nodes, 2)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapInnerWithContent(t *testing.T) {\n\tdoc := Doc3Clone()\n\tdoc.Find(\".one\").WrapInner(\".two\")\n\n\ttwos := doc.Find(\".two\")\n\tassertLength(t, twos.Nodes, 4)\n\tassertLength(t, doc.Find(\".one .two\").Nodes, 2)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapInnerNoWrapper(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\".one\").WrapInner(\".not-exist\")\n\n\ttwos := doc.Find(\".two\")\n\tassertLength(t, twos.Nodes, 2)\n\tassertLength(t, doc.Find(\".one\").Nodes, 2)\n\tassertLength(t, doc.Find(\".one .two\").Nodes, 0)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestWrapInnerHtml(t *testing.T) {\n\tdoc := Doc2Clone()\n\tdoc.Find(\"#foot\").WrapInnerHtml(wrapHtml)\n\n\tfoot := doc.Find(\"#foot div#ins div p em b #nf1 ~ #nf2 ~ #nf3\")\n\tassertLength(t, foot.Nodes, 1)\n\n\tprintSel(t, doc.Selection)\n}\n\nfunc TestParsingRespectsVaryingContext(t *testing.T) {\n\tdocA := loadString(t, `\n\t<html>\n\t\t<body>\n\t\t\t<a class=\"x\"></a>\n\t\t</body>\n\t</html>`)\n\tdocTable := loadString(t, `\n\t<html>\n\t\t<body>\n\t\t\t<table class=\"x\"></table>\n\t\t</body>\n\t</html>`)\n\tdocBoth := loadString(t, `\n\t<html>\n\t\t<body>\n\t\t\t<table class=\"x\"></table>\n\t\t\t<a class=\"x\"></a>\n\t\t</body>\n\t</html>`)\n\n\tsA := docA.Find(\".x\").AppendHtml(\"<tr><td>Hello</td></tr>\")\n\tsTable := docTable.Find(\".x\").AppendHtml(\"<tr><td>Hello</td></tr>\")\n\tsBoth := docBoth.Find(\".x\").AppendHtml(\"<tr><td>Hello</td></tr>\")\n\n\tprintSel(t, docA.Selection)\n\tprintSel(t, docTable.Selection)\n\tprintSel(t, docBoth.Selection)\n\n\toA, _ := sA.Html()\n\toTable, _ := sTable.Html()\n\n\tif oA == oTable {\n\t\tt.Errorf(\"Expected inner html of <a> and <table> to not be equal, but got %s and %s\", oA, oTable)\n\t}\n\n\toBothTable, _ := sBoth.First().Html()\n\tif oBothTable != oTable {\n\t\tt.Errorf(\"Expected inner html of <table> and <table> in doc containing both tags to be equal, but got %s and %s\",\n\t\t\toTable,\n\t\t\toBothTable)\n\t}\n\n\toBothA, _ := sBoth.Last().Html()\n\tif oBothA != oA {\n\t\tt.Errorf(\"Expected inner html of <a> and <a> in doc containing both tags to be equal, but got %s and %s\",\n\t\t\toA,\n\t\t\toBothA)\n\t}\n}\n\nfunc TestHtmlWithNonElementNode(t *testing.T) {\n\tconst data = `\n<html>\n  <head>\n  </head>\n  <body>\n    <p>\n      This is <span>some</span><b>text</b>.\n    </p>\n  </body>\n</html>\n`\n\n\tcases := map[string]func(*Selection, string) *Selection{\n\t\t\"AfterHtml\":       (*Selection).AfterHtml,\n\t\t\"AppendHtml\":      (*Selection).AppendHtml,\n\t\t\"BeforeHtml\":      (*Selection).BeforeHtml,\n\t\t\"PrependHtml\":     (*Selection).PrependHtml,\n\t\t\"ReplaceWithHtml\": (*Selection).ReplaceWithHtml,\n\t\t\"SetHtml\":         (*Selection).SetHtml,\n\t}\n\tfor nm, fn := range cases {\n\t\t// this test is only to make sure that the HTML parsing/manipulation\n\t\t// methods do not raise panics when executed over Selections that contain\n\t\t// non-Element nodes.\n\t\tt.Run(nm, func(t *testing.T) {\n\t\t\tdoc := loadString(t, data)\n\t\t\tsel := doc.Find(\"p\").Contents()\n\t\t\tfunc() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif err := recover(); err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tfn(sel, \"<div></div>\")\n\t\t\t}()\n\n\t\t\t// print the resulting document in verbose mode\n\t\t\th, err := OuterHtml(doc.Selection)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tt.Log(h)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "property.go",
          "type": "blob",
          "size": 6.408203125,
          "content": "package goquery\n\nimport (\n\t\"bytes\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"golang.org/x/net/html\"\n)\n\nvar rxClassTrim = regexp.MustCompile(\"[\\t\\r\\n]\")\n\n// Attr gets the specified attribute's value for the first element in the\n// Selection. To get the value for each element individually, use a looping\n// construct such as Each or Map method.\nfunc (s *Selection) Attr(attrName string) (val string, exists bool) {\n\tif len(s.Nodes) == 0 {\n\t\treturn\n\t}\n\treturn getAttributeValue(attrName, s.Nodes[0])\n}\n\n// AttrOr works like Attr but returns default value if attribute is not present.\nfunc (s *Selection) AttrOr(attrName, defaultValue string) string {\n\tif len(s.Nodes) == 0 {\n\t\treturn defaultValue\n\t}\n\n\tval, exists := getAttributeValue(attrName, s.Nodes[0])\n\tif !exists {\n\t\treturn defaultValue\n\t}\n\n\treturn val\n}\n\n// RemoveAttr removes the named attribute from each element in the set of matched elements.\nfunc (s *Selection) RemoveAttr(attrName string) *Selection {\n\tfor _, n := range s.Nodes {\n\t\tremoveAttr(n, attrName)\n\t}\n\n\treturn s\n}\n\n// SetAttr sets the given attribute on each element in the set of matched elements.\nfunc (s *Selection) SetAttr(attrName, val string) *Selection {\n\tfor _, n := range s.Nodes {\n\t\tattr := getAttributePtr(attrName, n)\n\t\tif attr == nil {\n\t\t\tn.Attr = append(n.Attr, html.Attribute{Key: attrName, Val: val})\n\t\t} else {\n\t\t\tattr.Val = val\n\t\t}\n\t}\n\n\treturn s\n}\n\n// Text gets the combined text contents of each element in the set of matched\n// elements, including their descendants.\nfunc (s *Selection) Text() string {\n\tvar buf bytes.Buffer\n\n\t// Slightly optimized vs calling Each: no single selection object created\n\tvar f func(*html.Node)\n\tf = func(n *html.Node) {\n\t\tif n.Type == html.TextNode {\n\t\t\t// Keep newlines and spaces, like jQuery\n\t\t\tbuf.WriteString(n.Data)\n\t\t}\n\t\tif n.FirstChild != nil {\n\t\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\t\tf(c)\n\t\t\t}\n\t\t}\n\t}\n\tfor _, n := range s.Nodes {\n\t\tf(n)\n\t}\n\n\treturn buf.String()\n}\n\n// Size is an alias for Length.\nfunc (s *Selection) Size() int {\n\treturn s.Length()\n}\n\n// Length returns the number of elements in the Selection object.\nfunc (s *Selection) Length() int {\n\treturn len(s.Nodes)\n}\n\n// Html gets the HTML contents of the first element in the set of matched\n// elements. It includes text and comment nodes.\nfunc (s *Selection) Html() (ret string, e error) {\n\t// Since there is no .innerHtml, the HTML content must be re-created from\n\t// the nodes using html.Render.\n\tvar buf bytes.Buffer\n\n\tif len(s.Nodes) > 0 {\n\t\tfor c := s.Nodes[0].FirstChild; c != nil; c = c.NextSibling {\n\t\t\te = html.Render(&buf, c)\n\t\t\tif e != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tret = buf.String()\n\t}\n\n\treturn\n}\n\n// AddClass adds the given class(es) to each element in the set of matched elements.\n// Multiple class names can be specified, separated by a space or via multiple arguments.\nfunc (s *Selection) AddClass(class ...string) *Selection {\n\tclassStr := strings.TrimSpace(strings.Join(class, \" \"))\n\n\tif classStr == \"\" {\n\t\treturn s\n\t}\n\n\ttcls := getClassesSlice(classStr)\n\tfor _, n := range s.Nodes {\n\t\tcurClasses, attr := getClassesAndAttr(n, true)\n\t\tfor _, newClass := range tcls {\n\t\t\tif !strings.Contains(curClasses, \" \"+newClass+\" \") {\n\t\t\t\tcurClasses += newClass + \" \"\n\t\t\t}\n\t\t}\n\n\t\tsetClasses(n, attr, curClasses)\n\t}\n\n\treturn s\n}\n\n// HasClass determines whether any of the matched elements are assigned the\n// given class.\nfunc (s *Selection) HasClass(class string) bool {\n\tclass = \" \" + class + \" \"\n\tfor _, n := range s.Nodes {\n\t\tclasses, _ := getClassesAndAttr(n, false)\n\t\tif strings.Contains(classes, class) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// RemoveClass removes the given class(es) from each element in the set of matched elements.\n// Multiple class names can be specified, separated by a space or via multiple arguments.\n// If no class name is provided, all classes are removed.\nfunc (s *Selection) RemoveClass(class ...string) *Selection {\n\tvar rclasses []string\n\n\tclassStr := strings.TrimSpace(strings.Join(class, \" \"))\n\tremove := classStr == \"\"\n\n\tif !remove {\n\t\trclasses = getClassesSlice(classStr)\n\t}\n\n\tfor _, n := range s.Nodes {\n\t\tif remove {\n\t\t\tremoveAttr(n, \"class\")\n\t\t} else {\n\t\t\tclasses, attr := getClassesAndAttr(n, true)\n\t\t\tfor _, rcl := range rclasses {\n\t\t\t\tclasses = strings.Replace(classes, \" \"+rcl+\" \", \" \", -1)\n\t\t\t}\n\n\t\t\tsetClasses(n, attr, classes)\n\t\t}\n\t}\n\n\treturn s\n}\n\n// ToggleClass adds or removes the given class(es) for each element in the set of matched elements.\n// Multiple class names can be specified, separated by a space or via multiple arguments.\nfunc (s *Selection) ToggleClass(class ...string) *Selection {\n\tclassStr := strings.TrimSpace(strings.Join(class, \" \"))\n\n\tif classStr == \"\" {\n\t\treturn s\n\t}\n\n\ttcls := getClassesSlice(classStr)\n\n\tfor _, n := range s.Nodes {\n\t\tclasses, attr := getClassesAndAttr(n, true)\n\t\tfor _, tcl := range tcls {\n\t\t\tif strings.Contains(classes, \" \"+tcl+\" \") {\n\t\t\t\tclasses = strings.Replace(classes, \" \"+tcl+\" \", \" \", -1)\n\t\t\t} else {\n\t\t\t\tclasses += tcl + \" \"\n\t\t\t}\n\t\t}\n\n\t\tsetClasses(n, attr, classes)\n\t}\n\n\treturn s\n}\n\nfunc getAttributePtr(attrName string, n *html.Node) *html.Attribute {\n\tif n == nil {\n\t\treturn nil\n\t}\n\n\tfor i, a := range n.Attr {\n\t\tif a.Key == attrName {\n\t\t\treturn &n.Attr[i]\n\t\t}\n\t}\n\treturn nil\n}\n\n// Private function to get the specified attribute's value from a node.\nfunc getAttributeValue(attrName string, n *html.Node) (val string, exists bool) {\n\tif a := getAttributePtr(attrName, n); a != nil {\n\t\tval = a.Val\n\t\texists = true\n\t}\n\treturn\n}\n\n// Get and normalize the \"class\" attribute from the node.\nfunc getClassesAndAttr(n *html.Node, create bool) (classes string, attr *html.Attribute) {\n\t// Applies only to element nodes\n\tif n.Type == html.ElementNode {\n\t\tattr = getAttributePtr(\"class\", n)\n\t\tif attr == nil && create {\n\t\t\tn.Attr = append(n.Attr, html.Attribute{\n\t\t\t\tKey: \"class\",\n\t\t\t\tVal: \"\",\n\t\t\t})\n\t\t\tattr = &n.Attr[len(n.Attr)-1]\n\t\t}\n\t}\n\n\tif attr == nil {\n\t\tclasses = \" \"\n\t} else {\n\t\tclasses = rxClassTrim.ReplaceAllString(\" \"+attr.Val+\" \", \" \")\n\t}\n\n\treturn\n}\n\nfunc getClassesSlice(classes string) []string {\n\treturn strings.Split(rxClassTrim.ReplaceAllString(\" \"+classes+\" \", \" \"), \" \")\n}\n\nfunc removeAttr(n *html.Node, attrName string) {\n\tfor i, a := range n.Attr {\n\t\tif a.Key == attrName {\n\t\t\tn.Attr[i], n.Attr[len(n.Attr)-1], n.Attr =\n\t\t\t\tn.Attr[len(n.Attr)-1], html.Attribute{}, n.Attr[:len(n.Attr)-1]\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc setClasses(n *html.Node, attr *html.Attribute, classes string) {\n\tclasses = strings.TrimSpace(classes)\n\tif classes == \"\" {\n\t\tremoveAttr(n, \"class\")\n\t\treturn\n\t}\n\n\tattr.Val = classes\n}\n"
        },
        {
          "name": "property_test.go",
          "type": "blob",
          "size": 5.8759765625,
          "content": "package goquery\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestAttrExists(t *testing.T) {\n\tif val, ok := Doc().Find(\"a\").Attr(\"href\"); !ok {\n\t\tt.Error(\"Expected a value for the href attribute.\")\n\t} else {\n\t\tt.Logf(\"Href of first anchor: %v.\", val)\n\t}\n}\n\nfunc TestAttrOr(t *testing.T) {\n\tif val := Doc().Find(\"a\").AttrOr(\"fake-attribute\", \"alternative\"); val != \"alternative\" {\n\t\tt.Error(\"Expected an alternative value for 'fake-attribute' attribute.\")\n\t} else {\n\t\tt.Logf(\"Value returned for not existing attribute: %v.\", val)\n\t}\n\tif val := Doc().Find(\"zz\").AttrOr(\"fake-attribute\", \"alternative\"); val != \"alternative\" {\n\t\tt.Error(\"Expected an alternative value for 'fake-attribute' on an empty selection.\")\n\t} else {\n\t\tt.Logf(\"Value returned for empty selection: %v.\", val)\n\t}\n}\n\nfunc TestAttrNotExist(t *testing.T) {\n\tif val, ok := Doc().Find(\"div.row-fluid\").Attr(\"href\"); ok {\n\t\tt.Errorf(\"Expected no value for the href attribute, got %v.\", val)\n\t}\n}\n\nfunc TestRemoveAttr(t *testing.T) {\n\tsel := Doc2Clone().Find(\"div\")\n\n\tsel.RemoveAttr(\"id\")\n\n\t_, ok := sel.Attr(\"id\")\n\tif ok {\n\t\tt.Error(\"Expected there to be no id attributes set\")\n\t}\n}\n\nfunc TestSetAttr(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#main\")\n\n\tsel.SetAttr(\"id\", \"not-main\")\n\n\tval, ok := sel.Attr(\"id\")\n\tif !ok {\n\t\tt.Error(\"Expected an id attribute on main\")\n\t}\n\n\tif val != \"not-main\" {\n\t\tt.Errorf(\"Expected an attribute id to be not-main, got %s\", val)\n\t}\n}\n\nfunc TestSetAttr2(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#main\")\n\n\tsel.SetAttr(\"foo\", \"bar\")\n\n\tval, ok := sel.Attr(\"foo\")\n\tif !ok {\n\t\tt.Error(\"Expected an 'foo' attribute on main\")\n\t}\n\n\tif val != \"bar\" {\n\t\tt.Errorf(\"Expected an attribute 'foo' to be 'bar', got '%s'\", val)\n\t}\n}\n\nfunc TestText(t *testing.T) {\n\ttxt := Doc().Find(\"h1\").Text()\n\tif strings.Trim(txt, \" \\n\\r\\t\") != \"Provok.in\" {\n\t\tt.Errorf(\"Expected text to be Provok.in, found %s.\", txt)\n\t}\n}\n\nfunc TestText2(t *testing.T) {\n\ttxt := Doc().Find(\".hero-unit .container-fluid .row-fluid:nth-child(1)\").Text()\n\tif ok, e := regexp.MatchString(`^\\s+Provok\\.in\\s+Prove your point.\\s+$`, txt); !ok || e != nil {\n\t\tt.Errorf(\"Expected text to be Provok.in Prove your point., found %s.\", txt)\n\t\tif e != nil {\n\t\t\tt.Logf(\"Error: %s.\", e.Error())\n\t\t}\n\t}\n}\n\nfunc TestText3(t *testing.T) {\n\ttxt := Doc().Find(\".pvk-gutter\").First().Text()\n\t// There's an &nbsp; character in there...\n\tif ok, e := regexp.MatchString(`^[\\s\\x{00A0}]+$`, txt); !ok || e != nil {\n\t\tt.Errorf(\"Expected spaces, found <%v>.\", txt)\n\t\tif e != nil {\n\t\t\tt.Logf(\"Error: %s.\", e.Error())\n\t\t}\n\t}\n}\n\nfunc TestHtml(t *testing.T) {\n\ttxt, e := Doc().Find(\"h1\").Html()\n\tif e != nil {\n\t\tt.Errorf(\"Error: %s.\", e)\n\t}\n\n\tif ok, e := regexp.MatchString(`^\\s*<a href=\"/\">Provok<span class=\"green\">\\.</span><span class=\"red\">i</span>n</a>\\s*$`, txt); !ok || e != nil {\n\t\tt.Errorf(\"Unexpected HTML content, found %s.\", txt)\n\t\tif e != nil {\n\t\t\tt.Logf(\"Error: %s.\", e.Error())\n\t\t}\n\t}\n}\n\nfunc TestNbsp(t *testing.T) {\n\tsrc := `<p>Some&nbsp;text</p>`\n\td, err := NewDocumentFromReader(strings.NewReader(src))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttxt := d.Find(\"p\").Text()\n\tix := strings.Index(txt, \"\\u00a0\")\n\tif ix != 4 {\n\t\tt.Errorf(\"Text: expected a non-breaking space at index 4, got %d\", ix)\n\t}\n\n\th, err := d.Find(\"p\").Html()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tix = strings.Index(h, \"\\u00a0\")\n\tif ix != 4 {\n\t\tt.Errorf(\"Html: expected a non-breaking space at index 4, got %d\", ix)\n\t}\n}\n\nfunc TestAddClass(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#main\")\n\tsel.AddClass(\"main main main\")\n\n\t// Make sure that class was only added once\n\tif a, ok := sel.Attr(\"class\"); !ok || a != \"main\" {\n\t\tt.Error(\"Expected #main to have class main\")\n\t}\n}\n\nfunc TestAddClassSimilar(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#nf5\")\n\tsel.AddClass(\"odd\")\n\n\tassertClass(t, sel, \"odd\")\n\tassertClass(t, sel, \"odder\")\n\tprintSel(t, sel.Parent())\n}\n\nfunc TestAddEmptyClass(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#main\")\n\tsel.AddClass(\"\")\n\n\t// Make sure that class was only added once\n\tif a, ok := sel.Attr(\"class\"); ok {\n\t\tt.Errorf(\"Expected #main to not to have a class, have: %s\", a)\n\t}\n}\n\nfunc TestAddClasses(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#main\")\n\tsel.AddClass(\"a b\")\n\n\t// Make sure that class was only added once\n\tif !sel.HasClass(\"a\") || !sel.HasClass(\"b\") {\n\t\tt.Errorf(\"#main does not have classes\")\n\t}\n}\n\nfunc TestHasClass(t *testing.T) {\n\tsel := Doc().Find(\"div\")\n\tif !sel.HasClass(\"span12\") {\n\t\tt.Error(\"Expected at least one div to have class span12.\")\n\t}\n}\n\nfunc TestHasClassNone(t *testing.T) {\n\tsel := Doc().Find(\"h2\")\n\tif sel.HasClass(\"toto\") {\n\t\tt.Error(\"Expected h1 to have no class.\")\n\t}\n}\n\nfunc TestHasClassNotFirst(t *testing.T) {\n\tsel := Doc().Find(\".alert\")\n\tif !sel.HasClass(\"alert-error\") {\n\t\tt.Error(\"Expected .alert to also have class .alert-error.\")\n\t}\n}\n\nfunc TestRemoveClass(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#nf1\")\n\tsel.RemoveClass(\"one row\")\n\n\tif !sel.HasClass(\"even\") || sel.HasClass(\"one\") || sel.HasClass(\"row\") {\n\t\tclasses, _ := sel.Attr(\"class\")\n\t\tt.Error(\"Expected #nf1 to have class even, has \", classes)\n\t}\n}\n\nfunc TestRemoveClassSimilar(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#nf5, #nf6\")\n\tassertLength(t, sel.Nodes, 2)\n\n\tsel.RemoveClass(\"odd\")\n\tassertClass(t, sel.Eq(0), \"odder\")\n\tprintSel(t, sel)\n}\n\nfunc TestRemoveAllClasses(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#nf1\")\n\tsel.RemoveClass()\n\n\tif a, ok := sel.Attr(\"class\"); ok {\n\t\tt.Error(\"All classes were not removed, has \", a)\n\t}\n\n\tsel = Doc2Clone().Find(\"#main\")\n\tsel.RemoveClass()\n\tif a, ok := sel.Attr(\"class\"); ok {\n\t\tt.Error(\"All classes were not removed, has \", a)\n\t}\n}\n\nfunc TestToggleClass(t *testing.T) {\n\tsel := Doc2Clone().Find(\"#nf1\")\n\n\tsel.ToggleClass(\"one\")\n\tif sel.HasClass(\"one\") {\n\t\tt.Error(\"Expected #nf1 to not have class one\")\n\t}\n\n\tsel.ToggleClass(\"one\")\n\tif !sel.HasClass(\"one\") {\n\t\tt.Error(\"Expected #nf1 to have class one\")\n\t}\n\n\tsel.ToggleClass(\"one even row\")\n\tif a, ok := sel.Attr(\"class\"); ok {\n\t\tt.Errorf(\"Expected #nf1 to have no classes, have %q\", a)\n\t}\n}\n"
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 1.689453125,
          "content": "package goquery\n\nimport \"golang.org/x/net/html\"\n\n// Is checks the current matched set of elements against a selector and\n// returns true if at least one of these elements matches.\nfunc (s *Selection) Is(selector string) bool {\n\treturn s.IsMatcher(compileMatcher(selector))\n}\n\n// IsMatcher checks the current matched set of elements against a matcher and\n// returns true if at least one of these elements matches.\nfunc (s *Selection) IsMatcher(m Matcher) bool {\n\tif len(s.Nodes) > 0 {\n\t\tif len(s.Nodes) == 1 {\n\t\t\treturn m.Match(s.Nodes[0])\n\t\t}\n\t\treturn len(m.Filter(s.Nodes)) > 0\n\t}\n\n\treturn false\n}\n\n// IsFunction checks the current matched set of elements against a predicate and\n// returns true if at least one of these elements matches.\nfunc (s *Selection) IsFunction(f func(int, *Selection) bool) bool {\n\treturn s.FilterFunction(f).Length() > 0\n}\n\n// IsSelection checks the current matched set of elements against a Selection object\n// and returns true if at least one of these elements matches.\nfunc (s *Selection) IsSelection(sel *Selection) bool {\n\treturn s.FilterSelection(sel).Length() > 0\n}\n\n// IsNodes checks the current matched set of elements against the specified nodes\n// and returns true if at least one of these elements matches.\nfunc (s *Selection) IsNodes(nodes ...*html.Node) bool {\n\treturn s.FilterNodes(nodes...).Length() > 0\n}\n\n// Contains returns true if the specified Node is within,\n// at any depth, one of the nodes in the Selection object.\n// It is NOT inclusive, to behave like jQuery's implementation, and\n// unlike Javascript's .contains, so if the contained\n// node is itself in the selection, it returns false.\nfunc (s *Selection) Contains(n *html.Node) bool {\n\treturn sliceContains(s.Nodes, n)\n}\n"
        },
        {
          "name": "query_test.go",
          "type": "blob",
          "size": 2.2607421875,
          "content": "package goquery\n\nimport (\n\t\"testing\"\n)\n\nfunc TestIs(t *testing.T) {\n\tsel := Doc().Find(\".footer p:nth-child(1)\")\n\tif !sel.Is(\"p\") {\n\t\tt.Error(\"Expected .footer p:nth-child(1) to be p.\")\n\t}\n}\n\nfunc TestIsInvalid(t *testing.T) {\n\tsel := Doc().Find(\".footer p:nth-child(1)\")\n\tif sel.Is(\"\") {\n\t\tt.Error(\"Is should not succeed with invalid selector string\")\n\t}\n}\n\nfunc TestIsPositional(t *testing.T) {\n\tsel := Doc().Find(\".footer p:nth-child(2)\")\n\tif !sel.Is(\"p:nth-child(2)\") {\n\t\tt.Error(\"Expected .footer p:nth-child(2) to be p:nth-child(2).\")\n\t}\n}\n\nfunc TestIsPositionalNot(t *testing.T) {\n\tsel := Doc().Find(\".footer p:nth-child(1)\")\n\tif sel.Is(\"p:nth-child(2)\") {\n\t\tt.Error(\"Expected .footer p:nth-child(1) NOT to be p:nth-child(2).\")\n\t}\n}\n\nfunc TestIsFunction(t *testing.T) {\n\tok := Doc().Find(\"div\").IsFunction(func(i int, s *Selection) bool {\n\t\treturn s.HasClass(\"container-fluid\")\n\t})\n\n\tif !ok {\n\t\tt.Error(\"Expected some div to have a container-fluid class.\")\n\t}\n}\n\nfunc TestIsFunctionRollback(t *testing.T) {\n\tok := Doc().Find(\"div\").IsFunction(func(i int, s *Selection) bool {\n\t\treturn s.HasClass(\"container-fluid\")\n\t})\n\n\tif !ok {\n\t\tt.Error(\"Expected some div to have a container-fluid class.\")\n\t}\n}\n\nfunc TestIsSelection(t *testing.T) {\n\tsel := Doc().Find(\"div\")\n\tsel2 := Doc().Find(\".pvk-gutter\")\n\n\tif !sel.IsSelection(sel2) {\n\t\tt.Error(\"Expected some div to have a pvk-gutter class.\")\n\t}\n}\n\nfunc TestIsSelectionNot(t *testing.T) {\n\tsel := Doc().Find(\"div\")\n\tsel2 := Doc().Find(\"a\")\n\n\tif sel.IsSelection(sel2) {\n\t\tt.Error(\"Expected some div NOT to be an anchor.\")\n\t}\n}\n\nfunc TestIsNodes(t *testing.T) {\n\tsel := Doc().Find(\"div\")\n\tsel2 := Doc().Find(\".footer\")\n\n\tif !sel.IsNodes(sel2.Nodes[0]) {\n\t\tt.Error(\"Expected some div to have a footer class.\")\n\t}\n}\n\nfunc TestDocContains(t *testing.T) {\n\tsel := Doc().Find(\"h1\")\n\tif !Doc().Contains(sel.Nodes[0]) {\n\t\tt.Error(\"Expected document to contain H1 tag.\")\n\t}\n}\n\nfunc TestSelContains(t *testing.T) {\n\tsel := Doc().Find(\".row-fluid\")\n\tsel2 := Doc().Find(\"a[ng-click]\")\n\tif !sel.Contains(sel2.Nodes[0]) {\n\t\tt.Error(\"Expected .row-fluid to contain a[ng-click] tag.\")\n\t}\n}\n\nfunc TestSelNotContains(t *testing.T) {\n\tsel := Doc().Find(\"a.link\")\n\tsel2 := Doc().Find(\"span\")\n\tif sel.Contains(sel2.Nodes[0]) {\n\t\tt.Error(\"Expected a.link to NOT contain span tag.\")\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "traversal.go",
          "type": "blob",
          "size": 27.9326171875,
          "content": "package goquery\n\nimport \"golang.org/x/net/html\"\n\ntype siblingType int\n\n// Sibling type, used internally when iterating over children at the same\n// level (siblings) to specify which nodes are requested.\nconst (\n\tsiblingPrevUntil siblingType = iota - 3\n\tsiblingPrevAll\n\tsiblingPrev\n\tsiblingAll\n\tsiblingNext\n\tsiblingNextAll\n\tsiblingNextUntil\n\tsiblingAllIncludingNonElements\n)\n\n// Find gets the descendants of each element in the current set of matched\n// elements, filtered by a selector. It returns a new Selection object\n// containing these matched elements.\n//\n// Note that as for all methods accepting a selector string, the selector is\n// compiled and applied by the cascadia package and inherits its behavior and\n// constraints regarding supported selectors. See the note on cascadia in\n// the goquery documentation here:\n// https://github.com/PuerkitoBio/goquery?tab=readme-ov-file#api\nfunc (s *Selection) Find(selector string) *Selection {\n\treturn pushStack(s, findWithMatcher(s.Nodes, compileMatcher(selector)))\n}\n\n// FindMatcher gets the descendants of each element in the current set of matched\n// elements, filtered by the matcher. It returns a new Selection object\n// containing these matched elements.\nfunc (s *Selection) FindMatcher(m Matcher) *Selection {\n\treturn pushStack(s, findWithMatcher(s.Nodes, m))\n}\n\n// FindSelection gets the descendants of each element in the current\n// Selection, filtered by a Selection. It returns a new Selection object\n// containing these matched elements.\nfunc (s *Selection) FindSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn pushStack(s, nil)\n\t}\n\treturn s.FindNodes(sel.Nodes...)\n}\n\n// FindNodes gets the descendants of each element in the current\n// Selection, filtered by some nodes. It returns a new Selection object\n// containing these matched elements.\nfunc (s *Selection) FindNodes(nodes ...*html.Node) *Selection {\n\treturn pushStack(s, mapNodes(nodes, func(i int, n *html.Node) []*html.Node {\n\t\tif sliceContains(s.Nodes, n) {\n\t\t\treturn []*html.Node{n}\n\t\t}\n\t\treturn nil\n\t}))\n}\n\n// Contents gets the children of each element in the Selection,\n// including text and comment nodes. It returns a new Selection object\n// containing these elements.\nfunc (s *Selection) Contents() *Selection {\n\treturn pushStack(s, getChildrenNodes(s.Nodes, siblingAllIncludingNonElements))\n}\n\n// ContentsFiltered gets the children of each element in the Selection,\n// filtered by the specified selector. It returns a new Selection\n// object containing these elements. Since selectors only act on Element nodes,\n// this function is an alias to ChildrenFiltered unless the selector is empty,\n// in which case it is an alias to Contents.\nfunc (s *Selection) ContentsFiltered(selector string) *Selection {\n\tif selector != \"\" {\n\t\treturn s.ChildrenFiltered(selector)\n\t}\n\treturn s.Contents()\n}\n\n// ContentsMatcher gets the children of each element in the Selection,\n// filtered by the specified matcher. It returns a new Selection\n// object containing these elements. Since matchers only act on Element nodes,\n// this function is an alias to ChildrenMatcher.\nfunc (s *Selection) ContentsMatcher(m Matcher) *Selection {\n\treturn s.ChildrenMatcher(m)\n}\n\n// Children gets the child elements of each element in the Selection.\n// It returns a new Selection object containing these elements.\nfunc (s *Selection) Children() *Selection {\n\treturn pushStack(s, getChildrenNodes(s.Nodes, siblingAll))\n}\n\n// ChildrenFiltered gets the child elements of each element in the Selection,\n// filtered by the specified selector. It returns a new\n// Selection object containing these elements.\nfunc (s *Selection) ChildrenFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getChildrenNodes(s.Nodes, siblingAll), compileMatcher(selector))\n}\n\n// ChildrenMatcher gets the child elements of each element in the Selection,\n// filtered by the specified matcher. It returns a new\n// Selection object containing these elements.\nfunc (s *Selection) ChildrenMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getChildrenNodes(s.Nodes, siblingAll), m)\n}\n\n// Parent gets the parent of each element in the Selection. It returns a\n// new Selection object containing the matched elements.\nfunc (s *Selection) Parent() *Selection {\n\treturn pushStack(s, getParentNodes(s.Nodes))\n}\n\n// ParentFiltered gets the parent of each element in the Selection filtered by a\n// selector. It returns a new Selection object containing the matched elements.\nfunc (s *Selection) ParentFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getParentNodes(s.Nodes), compileMatcher(selector))\n}\n\n// ParentMatcher gets the parent of each element in the Selection filtered by a\n// matcher. It returns a new Selection object containing the matched elements.\nfunc (s *Selection) ParentMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getParentNodes(s.Nodes), m)\n}\n\n// Closest gets the first element that matches the selector by testing the\n// element itself and traversing up through its ancestors in the DOM tree.\nfunc (s *Selection) Closest(selector string) *Selection {\n\tcs := compileMatcher(selector)\n\treturn s.ClosestMatcher(cs)\n}\n\n// ClosestMatcher gets the first element that matches the matcher by testing the\n// element itself and traversing up through its ancestors in the DOM tree.\nfunc (s *Selection) ClosestMatcher(m Matcher) *Selection {\n\treturn pushStack(s, mapNodes(s.Nodes, func(i int, n *html.Node) []*html.Node {\n\t\t// For each node in the selection, test the node itself, then each parent\n\t\t// until a match is found.\n\t\tfor ; n != nil; n = n.Parent {\n\t\t\tif m.Match(n) {\n\t\t\t\treturn []*html.Node{n}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}))\n}\n\n// ClosestNodes gets the first element that matches one of the nodes by testing the\n// element itself and traversing up through its ancestors in the DOM tree.\nfunc (s *Selection) ClosestNodes(nodes ...*html.Node) *Selection {\n\tset := make(map[*html.Node]bool)\n\tfor _, n := range nodes {\n\t\tset[n] = true\n\t}\n\treturn pushStack(s, mapNodes(s.Nodes, func(i int, n *html.Node) []*html.Node {\n\t\t// For each node in the selection, test the node itself, then each parent\n\t\t// until a match is found.\n\t\tfor ; n != nil; n = n.Parent {\n\t\t\tif set[n] {\n\t\t\t\treturn []*html.Node{n}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}))\n}\n\n// ClosestSelection gets the first element that matches one of the nodes in the\n// Selection by testing the element itself and traversing up through its ancestors\n// in the DOM tree.\nfunc (s *Selection) ClosestSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn pushStack(s, nil)\n\t}\n\treturn s.ClosestNodes(sel.Nodes...)\n}\n\n// Parents gets the ancestors of each element in the current Selection. It\n// returns a new Selection object with the matched elements.\nfunc (s *Selection) Parents() *Selection {\n\treturn pushStack(s, getParentsNodes(s.Nodes, nil, nil))\n}\n\n// ParentsFiltered gets the ancestors of each element in the current\n// Selection. It returns a new Selection object with the matched elements.\nfunc (s *Selection) ParentsFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getParentsNodes(s.Nodes, nil, nil), compileMatcher(selector))\n}\n\n// ParentsMatcher gets the ancestors of each element in the current\n// Selection. It returns a new Selection object with the matched elements.\nfunc (s *Selection) ParentsMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getParentsNodes(s.Nodes, nil, nil), m)\n}\n\n// ParentsUntil gets the ancestors of each element in the Selection, up to but\n// not including the element matched by the selector. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) ParentsUntil(selector string) *Selection {\n\treturn pushStack(s, getParentsNodes(s.Nodes, compileMatcher(selector), nil))\n}\n\n// ParentsUntilMatcher gets the ancestors of each element in the Selection, up to but\n// not including the element matched by the matcher. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) ParentsUntilMatcher(m Matcher) *Selection {\n\treturn pushStack(s, getParentsNodes(s.Nodes, m, nil))\n}\n\n// ParentsUntilSelection gets the ancestors of each element in the Selection,\n// up to but not including the elements in the specified Selection. It returns a\n// new Selection object containing the matched elements.\nfunc (s *Selection) ParentsUntilSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.Parents()\n\t}\n\treturn s.ParentsUntilNodes(sel.Nodes...)\n}\n\n// ParentsUntilNodes gets the ancestors of each element in the Selection,\n// up to but not including the specified nodes. It returns a\n// new Selection object containing the matched elements.\nfunc (s *Selection) ParentsUntilNodes(nodes ...*html.Node) *Selection {\n\treturn pushStack(s, getParentsNodes(s.Nodes, nil, nodes))\n}\n\n// ParentsFilteredUntil is like ParentsUntil, with the option to filter the\n// results based on a selector string. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) ParentsFilteredUntil(filterSelector, untilSelector string) *Selection {\n\treturn filterAndPush(s, getParentsNodes(s.Nodes, compileMatcher(untilSelector), nil), compileMatcher(filterSelector))\n}\n\n// ParentsFilteredUntilMatcher is like ParentsUntilMatcher, with the option to filter the\n// results based on a matcher. It returns a new Selection object containing the matched elements.\nfunc (s *Selection) ParentsFilteredUntilMatcher(filter, until Matcher) *Selection {\n\treturn filterAndPush(s, getParentsNodes(s.Nodes, until, nil), filter)\n}\n\n// ParentsFilteredUntilSelection is like ParentsUntilSelection, with the\n// option to filter the results based on a selector string. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) ParentsFilteredUntilSelection(filterSelector string, sel *Selection) *Selection {\n\treturn s.ParentsMatcherUntilSelection(compileMatcher(filterSelector), sel)\n}\n\n// ParentsMatcherUntilSelection is like ParentsUntilSelection, with the\n// option to filter the results based on a matcher. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) ParentsMatcherUntilSelection(filter Matcher, sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.ParentsMatcher(filter)\n\t}\n\treturn s.ParentsMatcherUntilNodes(filter, sel.Nodes...)\n}\n\n// ParentsFilteredUntilNodes is like ParentsUntilNodes, with the\n// option to filter the results based on a selector string. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) ParentsFilteredUntilNodes(filterSelector string, nodes ...*html.Node) *Selection {\n\treturn filterAndPush(s, getParentsNodes(s.Nodes, nil, nodes), compileMatcher(filterSelector))\n}\n\n// ParentsMatcherUntilNodes is like ParentsUntilNodes, with the\n// option to filter the results based on a matcher. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) ParentsMatcherUntilNodes(filter Matcher, nodes ...*html.Node) *Selection {\n\treturn filterAndPush(s, getParentsNodes(s.Nodes, nil, nodes), filter)\n}\n\n// Siblings gets the siblings of each element in the Selection. It returns\n// a new Selection object containing the matched elements.\nfunc (s *Selection) Siblings() *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingAll, nil, nil))\n}\n\n// SiblingsFiltered gets the siblings of each element in the Selection\n// filtered by a selector. It returns a new Selection object containing the\n// matched elements.\nfunc (s *Selection) SiblingsFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingAll, nil, nil), compileMatcher(selector))\n}\n\n// SiblingsMatcher gets the siblings of each element in the Selection\n// filtered by a matcher. It returns a new Selection object containing the\n// matched elements.\nfunc (s *Selection) SiblingsMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingAll, nil, nil), m)\n}\n\n// Next gets the immediately following sibling of each element in the\n// Selection. It returns a new Selection object containing the matched elements.\nfunc (s *Selection) Next() *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingNext, nil, nil))\n}\n\n// NextFiltered gets the immediately following sibling of each element in the\n// Selection filtered by a selector. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) NextFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNext, nil, nil), compileMatcher(selector))\n}\n\n// NextMatcher gets the immediately following sibling of each element in the\n// Selection filtered by a matcher. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) NextMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNext, nil, nil), m)\n}\n\n// NextAll gets all the following siblings of each element in the\n// Selection. It returns a new Selection object containing the matched elements.\nfunc (s *Selection) NextAll() *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingNextAll, nil, nil))\n}\n\n// NextAllFiltered gets all the following siblings of each element in the\n// Selection filtered by a selector. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) NextAllFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNextAll, nil, nil), compileMatcher(selector))\n}\n\n// NextAllMatcher gets all the following siblings of each element in the\n// Selection filtered by a matcher. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) NextAllMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNextAll, nil, nil), m)\n}\n\n// Prev gets the immediately preceding sibling of each element in the\n// Selection. It returns a new Selection object containing the matched elements.\nfunc (s *Selection) Prev() *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingPrev, nil, nil))\n}\n\n// PrevFiltered gets the immediately preceding sibling of each element in the\n// Selection filtered by a selector. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) PrevFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrev, nil, nil), compileMatcher(selector))\n}\n\n// PrevMatcher gets the immediately preceding sibling of each element in the\n// Selection filtered by a matcher. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) PrevMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrev, nil, nil), m)\n}\n\n// PrevAll gets all the preceding siblings of each element in the\n// Selection. It returns a new Selection object containing the matched elements.\nfunc (s *Selection) PrevAll() *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingPrevAll, nil, nil))\n}\n\n// PrevAllFiltered gets all the preceding siblings of each element in the\n// Selection filtered by a selector. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) PrevAllFiltered(selector string) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrevAll, nil, nil), compileMatcher(selector))\n}\n\n// PrevAllMatcher gets all the preceding siblings of each element in the\n// Selection filtered by a matcher. It returns a new Selection object\n// containing the matched elements.\nfunc (s *Selection) PrevAllMatcher(m Matcher) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrevAll, nil, nil), m)\n}\n\n// NextUntil gets all following siblings of each element up to but not\n// including the element matched by the selector. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) NextUntil(selector string) *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingNextUntil,\n\t\tcompileMatcher(selector), nil))\n}\n\n// NextUntilMatcher gets all following siblings of each element up to but not\n// including the element matched by the matcher. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) NextUntilMatcher(m Matcher) *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingNextUntil,\n\t\tm, nil))\n}\n\n// NextUntilSelection gets all following siblings of each element up to but not\n// including the element matched by the Selection. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) NextUntilSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.NextAll()\n\t}\n\treturn s.NextUntilNodes(sel.Nodes...)\n}\n\n// NextUntilNodes gets all following siblings of each element up to but not\n// including the element matched by the nodes. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) NextUntilNodes(nodes ...*html.Node) *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingNextUntil,\n\t\tnil, nodes))\n}\n\n// PrevUntil gets all preceding siblings of each element up to but not\n// including the element matched by the selector. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) PrevUntil(selector string) *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingPrevUntil,\n\t\tcompileMatcher(selector), nil))\n}\n\n// PrevUntilMatcher gets all preceding siblings of each element up to but not\n// including the element matched by the matcher. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) PrevUntilMatcher(m Matcher) *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingPrevUntil,\n\t\tm, nil))\n}\n\n// PrevUntilSelection gets all preceding siblings of each element up to but not\n// including the element matched by the Selection. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) PrevUntilSelection(sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.PrevAll()\n\t}\n\treturn s.PrevUntilNodes(sel.Nodes...)\n}\n\n// PrevUntilNodes gets all preceding siblings of each element up to but not\n// including the element matched by the nodes. It returns a new Selection\n// object containing the matched elements.\nfunc (s *Selection) PrevUntilNodes(nodes ...*html.Node) *Selection {\n\treturn pushStack(s, getSiblingNodes(s.Nodes, siblingPrevUntil,\n\t\tnil, nodes))\n}\n\n// NextFilteredUntil is like NextUntil, with the option to filter\n// the results based on a selector string.\n// It returns a new Selection object containing the matched elements.\nfunc (s *Selection) NextFilteredUntil(filterSelector, untilSelector string) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNextUntil,\n\t\tcompileMatcher(untilSelector), nil), compileMatcher(filterSelector))\n}\n\n// NextFilteredUntilMatcher is like NextUntilMatcher, with the option to filter\n// the results based on a matcher.\n// It returns a new Selection object containing the matched elements.\nfunc (s *Selection) NextFilteredUntilMatcher(filter, until Matcher) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNextUntil,\n\t\tuntil, nil), filter)\n}\n\n// NextFilteredUntilSelection is like NextUntilSelection, with the\n// option to filter the results based on a selector string. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) NextFilteredUntilSelection(filterSelector string, sel *Selection) *Selection {\n\treturn s.NextMatcherUntilSelection(compileMatcher(filterSelector), sel)\n}\n\n// NextMatcherUntilSelection is like NextUntilSelection, with the\n// option to filter the results based on a matcher. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) NextMatcherUntilSelection(filter Matcher, sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.NextMatcher(filter)\n\t}\n\treturn s.NextMatcherUntilNodes(filter, sel.Nodes...)\n}\n\n// NextFilteredUntilNodes is like NextUntilNodes, with the\n// option to filter the results based on a selector string. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) NextFilteredUntilNodes(filterSelector string, nodes ...*html.Node) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNextUntil,\n\t\tnil, nodes), compileMatcher(filterSelector))\n}\n\n// NextMatcherUntilNodes is like NextUntilNodes, with the\n// option to filter the results based on a matcher. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) NextMatcherUntilNodes(filter Matcher, nodes ...*html.Node) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingNextUntil,\n\t\tnil, nodes), filter)\n}\n\n// PrevFilteredUntil is like PrevUntil, with the option to filter\n// the results based on a selector string.\n// It returns a new Selection object containing the matched elements.\nfunc (s *Selection) PrevFilteredUntil(filterSelector, untilSelector string) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrevUntil,\n\t\tcompileMatcher(untilSelector), nil), compileMatcher(filterSelector))\n}\n\n// PrevFilteredUntilMatcher is like PrevUntilMatcher, with the option to filter\n// the results based on a matcher.\n// It returns a new Selection object containing the matched elements.\nfunc (s *Selection) PrevFilteredUntilMatcher(filter, until Matcher) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrevUntil,\n\t\tuntil, nil), filter)\n}\n\n// PrevFilteredUntilSelection is like PrevUntilSelection, with the\n// option to filter the results based on a selector string. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) PrevFilteredUntilSelection(filterSelector string, sel *Selection) *Selection {\n\treturn s.PrevMatcherUntilSelection(compileMatcher(filterSelector), sel)\n}\n\n// PrevMatcherUntilSelection is like PrevUntilSelection, with the\n// option to filter the results based on a matcher. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) PrevMatcherUntilSelection(filter Matcher, sel *Selection) *Selection {\n\tif sel == nil {\n\t\treturn s.PrevMatcher(filter)\n\t}\n\treturn s.PrevMatcherUntilNodes(filter, sel.Nodes...)\n}\n\n// PrevFilteredUntilNodes is like PrevUntilNodes, with the\n// option to filter the results based on a selector string. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) PrevFilteredUntilNodes(filterSelector string, nodes ...*html.Node) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrevUntil,\n\t\tnil, nodes), compileMatcher(filterSelector))\n}\n\n// PrevMatcherUntilNodes is like PrevUntilNodes, with the\n// option to filter the results based on a matcher. It returns a new\n// Selection object containing the matched elements.\nfunc (s *Selection) PrevMatcherUntilNodes(filter Matcher, nodes ...*html.Node) *Selection {\n\treturn filterAndPush(s, getSiblingNodes(s.Nodes, siblingPrevUntil,\n\t\tnil, nodes), filter)\n}\n\n// Filter and push filters the nodes based on a matcher, and pushes the results\n// on the stack, with the srcSel as previous selection.\nfunc filterAndPush(srcSel *Selection, nodes []*html.Node, m Matcher) *Selection {\n\t// Create a temporary Selection with the specified nodes to filter using winnow\n\tsel := &Selection{nodes, srcSel.document, nil}\n\t// Filter based on matcher and push on stack\n\treturn pushStack(srcSel, winnow(sel, m, true))\n}\n\n// Internal implementation of Find that return raw nodes.\nfunc findWithMatcher(nodes []*html.Node, m Matcher) []*html.Node {\n\t// Map nodes to find the matches within the children of each node\n\treturn mapNodes(nodes, func(i int, n *html.Node) (result []*html.Node) {\n\t\t// Go down one level, becausejQuery's Find selects only within descendants\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tif c.Type == html.ElementNode {\n\t\t\t\tresult = append(result, m.MatchAll(c)...)\n\t\t\t}\n\t\t}\n\t\treturn\n\t})\n}\n\n// Internal implementation to get all parent nodes, stopping at the specified\n// node (or nil if no stop).\nfunc getParentsNodes(nodes []*html.Node, stopm Matcher, stopNodes []*html.Node) []*html.Node {\n\treturn mapNodes(nodes, func(i int, n *html.Node) (result []*html.Node) {\n\t\tfor p := n.Parent; p != nil; p = p.Parent {\n\t\t\tsel := newSingleSelection(p, nil)\n\t\t\tif stopm != nil {\n\t\t\t\tif sel.IsMatcher(stopm) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else if len(stopNodes) > 0 {\n\t\t\t\tif sel.IsNodes(stopNodes...) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif p.Type == html.ElementNode {\n\t\t\t\tresult = append(result, p)\n\t\t\t}\n\t\t}\n\t\treturn\n\t})\n}\n\n// Internal implementation of sibling nodes that return a raw slice of matches.\nfunc getSiblingNodes(nodes []*html.Node, st siblingType, untilm Matcher, untilNodes []*html.Node) []*html.Node {\n\tvar f func(*html.Node) bool\n\n\t// If the requested siblings are ...Until, create the test function to\n\t// determine if the until condition is reached (returns true if it is)\n\tif st == siblingNextUntil || st == siblingPrevUntil {\n\t\tf = func(n *html.Node) bool {\n\t\t\tif untilm != nil {\n\t\t\t\t// Matcher-based condition\n\t\t\t\tsel := newSingleSelection(n, nil)\n\t\t\t\treturn sel.IsMatcher(untilm)\n\t\t\t} else if len(untilNodes) > 0 {\n\t\t\t\t// Nodes-based condition\n\t\t\t\tsel := newSingleSelection(n, nil)\n\t\t\t\treturn sel.IsNodes(untilNodes...)\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn mapNodes(nodes, func(i int, n *html.Node) []*html.Node {\n\t\treturn getChildrenWithSiblingType(n.Parent, st, n, f)\n\t})\n}\n\n// Gets the children nodes of each node in the specified slice of nodes,\n// based on the sibling type request.\nfunc getChildrenNodes(nodes []*html.Node, st siblingType) []*html.Node {\n\treturn mapNodes(nodes, func(i int, n *html.Node) []*html.Node {\n\t\treturn getChildrenWithSiblingType(n, st, nil, nil)\n\t})\n}\n\n// Gets the children of the specified parent, based on the requested sibling\n// type, skipping a specified node if required.\nfunc getChildrenWithSiblingType(parent *html.Node, st siblingType, skipNode *html.Node,\n\tuntilFunc func(*html.Node) bool) (result []*html.Node) {\n\n\t// Create the iterator function\n\tvar iter = func(cur *html.Node) (ret *html.Node) {\n\t\t// Based on the sibling type requested, iterate the right way\n\t\tfor {\n\t\t\tswitch st {\n\t\t\tcase siblingAll, siblingAllIncludingNonElements:\n\t\t\t\tif cur == nil {\n\t\t\t\t\t// First iteration, start with first child of parent\n\t\t\t\t\t// Skip node if required\n\t\t\t\t\tif ret = parent.FirstChild; ret == skipNode && skipNode != nil {\n\t\t\t\t\t\tret = skipNode.NextSibling\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Skip node if required\n\t\t\t\t\tif ret = cur.NextSibling; ret == skipNode && skipNode != nil {\n\t\t\t\t\t\tret = skipNode.NextSibling\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase siblingPrev, siblingPrevAll, siblingPrevUntil:\n\t\t\t\tif cur == nil {\n\t\t\t\t\t// Start with previous sibling of the skip node\n\t\t\t\t\tret = skipNode.PrevSibling\n\t\t\t\t} else {\n\t\t\t\t\tret = cur.PrevSibling\n\t\t\t\t}\n\t\t\tcase siblingNext, siblingNextAll, siblingNextUntil:\n\t\t\t\tif cur == nil {\n\t\t\t\t\t// Start with next sibling of the skip node\n\t\t\t\t\tret = skipNode.NextSibling\n\t\t\t\t} else {\n\t\t\t\t\tret = cur.NextSibling\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tpanic(\"Invalid sibling type.\")\n\t\t\t}\n\t\t\tif ret == nil || ret.Type == html.ElementNode || st == siblingAllIncludingNonElements {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Not a valid node, try again from this one\n\t\t\tcur = ret\n\t\t}\n\t}\n\n\tfor c := iter(nil); c != nil; c = iter(c) {\n\t\t// If this is an ...Until case, test before append (returns true\n\t\t// if the until condition is reached)\n\t\tif st == siblingNextUntil || st == siblingPrevUntil {\n\t\t\tif untilFunc(c) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tresult = append(result, c)\n\t\tif st == siblingNext || st == siblingPrev {\n\t\t\t// Only one node was requested (immediate next or previous), so exit\n\t\t\treturn\n\t\t}\n\t}\n\treturn\n}\n\n// Internal implementation of parent nodes that return a raw slice of Nodes.\nfunc getParentNodes(nodes []*html.Node) []*html.Node {\n\treturn mapNodes(nodes, func(i int, n *html.Node) []*html.Node {\n\t\tif n.Parent != nil && n.Parent.Type == html.ElementNode {\n\t\t\treturn []*html.Node{n.Parent}\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// Internal map function used by many traversing methods. Takes the source nodes\n// to iterate on and the mapping function that returns an array of nodes.\n// Returns an array of nodes mapped by calling the callback function once for\n// each node in the source nodes.\nfunc mapNodes(nodes []*html.Node, f func(int, *html.Node) []*html.Node) (result []*html.Node) {\n\tset := make(map[*html.Node]bool)\n\tfor i, n := range nodes {\n\t\tif vals := f(i, n); len(vals) > 0 {\n\t\t\tresult = appendWithoutDuplicates(result, vals, set)\n\t\t}\n\t}\n\treturn result\n}\n"
        },
        {
          "name": "traversal_test.go",
          "type": "blob",
          "size": 20.3818359375,
          "content": "package goquery\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestFind(t *testing.T) {\n\tsel := Doc().Find(\"div.row-fluid\")\n\tassertLength(t, sel.Nodes, 9)\n}\n\nfunc TestFindRollback(t *testing.T) {\n\tsel := Doc().Find(\"div.row-fluid\")\n\tsel2 := sel.Find(\"a\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestFindNotSelf(t *testing.T) {\n\tsel := Doc().Find(\"h1\").Find(\"h1\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestFindInvalid(t *testing.T) {\n\tsel := Doc().Find(\":+ ^\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestFindBig(t *testing.T) {\n\tdoc := DocW()\n\tsel := doc.Find(\"li\")\n\tassertLength(t, sel.Nodes, 373)\n\tsel2 := doc.Find(\"span\")\n\tassertLength(t, sel2.Nodes, 448)\n\tsel3 := sel.FindSelection(sel2)\n\tassertLength(t, sel3.Nodes, 248)\n}\n\nfunc TestChainedFind(t *testing.T) {\n\tsel := Doc().Find(\"div.hero-unit\").Find(\".row-fluid\")\n\tassertLength(t, sel.Nodes, 4)\n}\n\nfunc TestChainedFindInvalid(t *testing.T) {\n\tsel := Doc().Find(\"div.hero-unit\").Find(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestChildren(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Children()\n\tassertLength(t, sel.Nodes, 5)\n}\n\nfunc TestChildrenRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Children().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestContents(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").Contents()\n\tassertLength(t, sel.Nodes, 13)\n}\n\nfunc TestContentsRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.Contents().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestChildrenFiltered(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").ChildrenFiltered(\".hero-unit\")\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestChildrenFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").ChildrenFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestChildrenFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.ChildrenFiltered(\".hero-unit\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestContentsFiltered(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").ContentsFiltered(\".hero-unit\")\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestContentsFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").ContentsFiltered(\"~\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestContentsFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\")\n\tsel2 := sel.ContentsFiltered(\".hero-unit\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestChildrenFilteredNone(t *testing.T) {\n\tsel := Doc().Find(\".pvk-content\").ChildrenFiltered(\"a.btn\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestParent(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Parent()\n\tassertLength(t, sel.Nodes, 3)\n}\n\nfunc TestParentRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.Parent().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentBody(t *testing.T) {\n\tsel := Doc().Find(\"body\").Parent()\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestParentFiltered(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentFiltered(\".hero-unit\")\n\tassertLength(t, sel.Nodes, 1)\n\tassertClass(t, sel, \"hero-unit\")\n}\n\nfunc TestParentFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestParentFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ParentFiltered(\".hero-unit\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParents(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").Parents()\n\tassertLength(t, sel.Nodes, 8)\n}\n\nfunc TestParentsOrder(t *testing.T) {\n\tsel := Doc().Find(\"#cf2\").Parents()\n\tassertLength(t, sel.Nodes, 6)\n\tassertSelectionIs(t, sel, \".hero-unit\", \".pvk-content\", \"div.row-fluid\", \"#cf1\", \"body\", \"html\")\n}\n\nfunc TestParentsRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.Parents().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentsFiltered(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentsFiltered(\"body\")\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestParentsFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentsFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestParentsFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ParentsFiltered(\"body\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentsUntil(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentsUntil(\"body\")\n\tassertLength(t, sel.Nodes, 6)\n}\n\nfunc TestParentsUntilInvalid(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentsUntil(\"\")\n\tassertLength(t, sel.Nodes, 8)\n}\n\nfunc TestParentsUntilRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ParentsUntil(\"body\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentsUntilSelection(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".pvk-content\")\n\tsel = sel.ParentsUntilSelection(sel2)\n\tassertLength(t, sel.Nodes, 3)\n}\n\nfunc TestParentsUntilSelectionRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".pvk-content\")\n\tsel2 = sel.ParentsUntilSelection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentsUntilNodes(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".pvk-content, .hero-unit\")\n\tsel = sel.ParentsUntilNodes(sel2.Nodes...)\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestParentsUntilNodesRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".pvk-content, .hero-unit\")\n\tsel2 = sel.ParentsUntilNodes(sel2.Nodes...).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentsFilteredUntil(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentsFilteredUntil(\".pvk-content\", \"body\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestParentsFilteredUntilInvalid(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").ParentsFilteredUntil(\"\", \"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestParentsFilteredUntilRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ParentsFilteredUntil(\".pvk-content\", \"body\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentsFilteredUntilSelection(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".row-fluid\")\n\tsel = sel.ParentsFilteredUntilSelection(\"div\", sel2)\n\tassertLength(t, sel.Nodes, 3)\n}\n\nfunc TestParentsFilteredUntilSelectionRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".row-fluid\")\n\tsel2 = sel.ParentsFilteredUntilSelection(\"div\", sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestParentsFilteredUntilNodes(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".row-fluid\")\n\tsel = sel.ParentsFilteredUntilNodes(\"body\", sel2.Nodes...)\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestParentsFilteredUntilNodesRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := Doc().Find(\".row-fluid\")\n\tsel2 = sel.ParentsFilteredUntilNodes(\"body\", sel2.Nodes...).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestSiblings(t *testing.T) {\n\tsel := Doc().Find(\"h1\").Siblings()\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestSiblingsRollback(t *testing.T) {\n\tsel := Doc().Find(\"h1\")\n\tsel2 := sel.Siblings().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestSiblings2(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\").Siblings()\n\tassertLength(t, sel.Nodes, 9)\n}\n\nfunc TestSiblings3(t *testing.T) {\n\tsel := Doc().Find(\"body>.container-fluid\").Siblings()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestSiblingsFiltered(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\").SiblingsFiltered(\".pvk-content\")\n\tassertLength(t, sel.Nodes, 3)\n}\n\nfunc TestSiblingsFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\").SiblingsFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestSiblingsFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\")\n\tsel2 := sel.SiblingsFiltered(\".pvk-content\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNext(t *testing.T) {\n\tsel := Doc().Find(\"h1\").Next()\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestNextRollback(t *testing.T) {\n\tsel := Doc().Find(\"h1\")\n\tsel2 := sel.Next().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNext2(t *testing.T) {\n\tsel := Doc().Find(\".close\").Next()\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestNextNone(t *testing.T) {\n\tsel := Doc().Find(\"small\").Next()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestNextFiltered(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").NextFiltered(\"div\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestNextFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").NextFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestNextFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.NextFiltered(\"div\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextFiltered2(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\").NextFiltered(\"[ng-view]\")\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestPrev(t *testing.T) {\n\tsel := Doc().Find(\".red\").Prev()\n\tassertLength(t, sel.Nodes, 1)\n\tassertClass(t, sel, \"green\")\n}\n\nfunc TestPrevRollback(t *testing.T) {\n\tsel := Doc().Find(\".red\")\n\tsel2 := sel.Prev().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestPrev2(t *testing.T) {\n\tsel := Doc().Find(\".row-fluid\").Prev()\n\tassertLength(t, sel.Nodes, 5)\n}\n\nfunc TestPrevNone(t *testing.T) {\n\tsel := Doc().Find(\"h2\").Prev()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestPrevFiltered(t *testing.T) {\n\tsel := Doc().Find(\".row-fluid\").PrevFiltered(\".row-fluid\")\n\tassertLength(t, sel.Nodes, 5)\n}\n\nfunc TestPrevFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".row-fluid\").PrevFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestPrevFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".row-fluid\")\n\tsel2 := sel.PrevFiltered(\".row-fluid\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextAll(t *testing.T) {\n\tsel := Doc().Find(\"#cf2 div:nth-child(1)\").NextAll()\n\tassertLength(t, sel.Nodes, 3)\n}\n\nfunc TestNextAllRollback(t *testing.T) {\n\tsel := Doc().Find(\"#cf2 div:nth-child(1)\")\n\tsel2 := sel.NextAll().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextAll2(t *testing.T) {\n\tsel := Doc().Find(\"div[ng-cloak]\").NextAll()\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestNextAllNone(t *testing.T) {\n\tsel := Doc().Find(\".footer\").NextAll()\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestNextAllFiltered(t *testing.T) {\n\tsel := Doc().Find(\"#cf2 .row-fluid\").NextAllFiltered(\"[ng-cloak]\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestNextAllFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\"#cf2 .row-fluid\").NextAllFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestNextAllFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\"#cf2 .row-fluid\")\n\tsel2 := sel.NextAllFiltered(\"[ng-cloak]\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextAllFiltered2(t *testing.T) {\n\tsel := Doc().Find(\".close\").NextAllFiltered(\"h4\")\n\tassertLength(t, sel.Nodes, 1)\n}\n\nfunc TestPrevAll(t *testing.T) {\n\tsel := Doc().Find(\"[ng-view]\").PrevAll()\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestPrevAllOrder(t *testing.T) {\n\tsel := Doc().Find(\"[ng-view]\").PrevAll()\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel, \"#cf4\", \"#cf3\")\n}\n\nfunc TestPrevAllRollback(t *testing.T) {\n\tsel := Doc().Find(\"[ng-view]\")\n\tsel2 := sel.PrevAll().End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestPrevAll2(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\").PrevAll()\n\tassertLength(t, sel.Nodes, 6)\n}\n\nfunc TestPrevAllFiltered(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\").PrevAllFiltered(\".pvk-content\")\n\tassertLength(t, sel.Nodes, 3)\n}\n\nfunc TestPrevAllFilteredInvalid(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\").PrevAllFiltered(\"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestPrevAllFilteredRollback(t *testing.T) {\n\tsel := Doc().Find(\".pvk-gutter\")\n\tsel2 := sel.PrevAllFiltered(\".pvk-content\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextUntil(t *testing.T) {\n\tsel := Doc().Find(\".alert a\").NextUntil(\"p\")\n\tassertLength(t, sel.Nodes, 1)\n\tassertSelectionIs(t, sel, \"h4\")\n}\n\nfunc TestNextUntilInvalid(t *testing.T) {\n\tsel := Doc().Find(\".alert a\").NextUntil(\"\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestNextUntil2(t *testing.T) {\n\tsel := Doc().Find(\"#cf2-1\").NextUntil(\"[ng-cloak]\")\n\tassertLength(t, sel.Nodes, 1)\n\tassertSelectionIs(t, sel, \"#cf2-2\")\n}\n\nfunc TestNextUntilOrder(t *testing.T) {\n\tsel := Doc().Find(\"#cf2-1\").NextUntil(\"#cf2-4\")\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel, \"#cf2-2\", \"#cf2-3\")\n}\n\nfunc TestNextUntilRollback(t *testing.T) {\n\tsel := Doc().Find(\"#cf2-1\")\n\tsel2 := sel.PrevUntil(\"#cf2-4\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextUntilSelection(t *testing.T) {\n\tsel := Doc2().Find(\"#n2\")\n\tsel2 := Doc2().Find(\"#n4\")\n\tsel2 = sel.NextUntilSelection(sel2)\n\tassertLength(t, sel2.Nodes, 1)\n\tassertSelectionIs(t, sel2, \"#n3\")\n}\n\nfunc TestNextUntilSelectionRollback(t *testing.T) {\n\tsel := Doc2().Find(\"#n2\")\n\tsel2 := Doc2().Find(\"#n4\")\n\tsel2 = sel.NextUntilSelection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextUntilNodes(t *testing.T) {\n\tsel := Doc2().Find(\"#n2\")\n\tsel2 := Doc2().Find(\"#n5\")\n\tsel2 = sel.NextUntilNodes(sel2.Nodes...)\n\tassertLength(t, sel2.Nodes, 2)\n\tassertSelectionIs(t, sel2, \"#n3\", \"#n4\")\n}\n\nfunc TestNextUntilNodesRollback(t *testing.T) {\n\tsel := Doc2().Find(\"#n2\")\n\tsel2 := Doc2().Find(\"#n5\")\n\tsel2 = sel.NextUntilNodes(sel2.Nodes...).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestPrevUntil(t *testing.T) {\n\tsel := Doc().Find(\".alert p\").PrevUntil(\"a\")\n\tassertLength(t, sel.Nodes, 1)\n\tassertSelectionIs(t, sel, \"h4\")\n}\n\nfunc TestPrevUntilInvalid(t *testing.T) {\n\tsel := Doc().Find(\".alert p\").PrevUntil(\"\")\n\tassertLength(t, sel.Nodes, 2)\n}\n\nfunc TestPrevUntil2(t *testing.T) {\n\tsel := Doc().Find(\"[ng-cloak]\").PrevUntil(\":not([ng-cloak])\")\n\tassertLength(t, sel.Nodes, 1)\n\tassertSelectionIs(t, sel, \"[ng-cloak]\")\n}\n\nfunc TestPrevUntilOrder(t *testing.T) {\n\tsel := Doc().Find(\"#cf2-4\").PrevUntil(\"#cf2-1\")\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel, \"#cf2-3\", \"#cf2-2\")\n}\n\nfunc TestPrevUntilRollback(t *testing.T) {\n\tsel := Doc().Find(\"#cf2-4\")\n\tsel2 := sel.PrevUntil(\"#cf2-1\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestPrevUntilSelection(t *testing.T) {\n\tsel := Doc2().Find(\"#n4\")\n\tsel2 := Doc2().Find(\"#n2\")\n\tsel2 = sel.PrevUntilSelection(sel2)\n\tassertLength(t, sel2.Nodes, 1)\n\tassertSelectionIs(t, sel2, \"#n3\")\n}\n\nfunc TestPrevUntilSelectionRollback(t *testing.T) {\n\tsel := Doc2().Find(\"#n4\")\n\tsel2 := Doc2().Find(\"#n2\")\n\tsel2 = sel.PrevUntilSelection(sel2).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestPrevUntilNodes(t *testing.T) {\n\tsel := Doc2().Find(\"#n5\")\n\tsel2 := Doc2().Find(\"#n2\")\n\tsel2 = sel.PrevUntilNodes(sel2.Nodes...)\n\tassertLength(t, sel2.Nodes, 2)\n\tassertSelectionIs(t, sel2, \"#n4\", \"#n3\")\n}\n\nfunc TestPrevUntilNodesRollback(t *testing.T) {\n\tsel := Doc2().Find(\"#n5\")\n\tsel2 := Doc2().Find(\"#n2\")\n\tsel2 = sel.PrevUntilNodes(sel2.Nodes...).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextFilteredUntil(t *testing.T) {\n\tsel := Doc2().Find(\".two\").NextFilteredUntil(\".even\", \".six\")\n\tassertLength(t, sel.Nodes, 4)\n\tassertSelectionIs(t, sel, \"#n3\", \"#n5\", \"#nf3\", \"#nf5\")\n}\n\nfunc TestNextFilteredUntilInvalid(t *testing.T) {\n\tsel := Doc2().Find(\".two\").NextFilteredUntil(\"\", \"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestNextFilteredUntilRollback(t *testing.T) {\n\tsel := Doc2().Find(\".two\")\n\tsel2 := sel.NextFilteredUntil(\".even\", \".six\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestNextFilteredUntilSelection(t *testing.T) {\n\tsel := Doc2().Find(\".even\")\n\tsel2 := Doc2().Find(\".five\")\n\tsel = sel.NextFilteredUntilSelection(\".even\", sel2)\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel, \"#n3\", \"#nf3\")\n}\n\nfunc TestNextFilteredUntilSelectionRollback(t *testing.T) {\n\tsel := Doc2().Find(\".even\")\n\tsel2 := Doc2().Find(\".five\")\n\tsel3 := sel.NextFilteredUntilSelection(\".even\", sel2).End()\n\tassertEqual(t, sel, sel3)\n}\n\nfunc TestNextFilteredUntilNodes(t *testing.T) {\n\tsel := Doc2().Find(\".even\")\n\tsel2 := Doc2().Find(\".four\")\n\tsel = sel.NextFilteredUntilNodes(\".odd\", sel2.Nodes...)\n\tassertLength(t, sel.Nodes, 4)\n\tassertSelectionIs(t, sel, \"#n2\", \"#n6\", \"#nf2\", \"#nf6\")\n}\n\nfunc TestNextFilteredUntilNodesRollback(t *testing.T) {\n\tsel := Doc2().Find(\".even\")\n\tsel2 := Doc2().Find(\".four\")\n\tsel3 := sel.NextFilteredUntilNodes(\".odd\", sel2.Nodes...).End()\n\tassertEqual(t, sel, sel3)\n}\n\nfunc TestPrevFilteredUntil(t *testing.T) {\n\tsel := Doc2().Find(\".five\").PrevFilteredUntil(\".odd\", \".one\")\n\tassertLength(t, sel.Nodes, 4)\n\tassertSelectionIs(t, sel, \"#n4\", \"#n2\", \"#nf4\", \"#nf2\")\n}\n\nfunc TestPrevFilteredUntilInvalid(t *testing.T) {\n\tsel := Doc2().Find(\".five\").PrevFilteredUntil(\"\", \"\")\n\tassertLength(t, sel.Nodes, 0)\n}\n\nfunc TestPrevFilteredUntilRollback(t *testing.T) {\n\tsel := Doc2().Find(\".four\")\n\tsel2 := sel.PrevFilteredUntil(\".odd\", \".one\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestPrevFilteredUntilSelection(t *testing.T) {\n\tsel := Doc2().Find(\".odd\")\n\tsel2 := Doc2().Find(\".two\")\n\tsel = sel.PrevFilteredUntilSelection(\".odd\", sel2)\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel, \"#n4\", \"#nf4\")\n}\n\nfunc TestPrevFilteredUntilSelectionRollback(t *testing.T) {\n\tsel := Doc2().Find(\".even\")\n\tsel2 := Doc2().Find(\".five\")\n\tsel3 := sel.PrevFilteredUntilSelection(\".even\", sel2).End()\n\tassertEqual(t, sel, sel3)\n}\n\nfunc TestPrevFilteredUntilNodes(t *testing.T) {\n\tsel := Doc2().Find(\".even\")\n\tsel2 := Doc2().Find(\".four\")\n\tsel = sel.PrevFilteredUntilNodes(\".odd\", sel2.Nodes...)\n\tassertLength(t, sel.Nodes, 2)\n\tassertSelectionIs(t, sel, \"#n2\", \"#nf2\")\n}\n\nfunc TestPrevFilteredUntilNodesRollback(t *testing.T) {\n\tsel := Doc2().Find(\".even\")\n\tsel2 := Doc2().Find(\".four\")\n\tsel3 := sel.PrevFilteredUntilNodes(\".odd\", sel2.Nodes...).End()\n\tassertEqual(t, sel, sel3)\n}\n\nfunc TestClosestItself(t *testing.T) {\n\tsel := Doc2().Find(\".three\")\n\tsel2 := sel.Closest(\".row\")\n\tassertLength(t, sel2.Nodes, sel.Length())\n\tassertSelectionIs(t, sel2, \"#n3\", \"#nf3\")\n}\n\nfunc TestClosestNoDupes(t *testing.T) {\n\tsel := Doc().Find(\".span12\")\n\tsel2 := sel.Closest(\".pvk-content\")\n\tassertLength(t, sel2.Nodes, 1)\n\tassertClass(t, sel2, \"pvk-content\")\n}\n\nfunc TestClosestNone(t *testing.T) {\n\tsel := Doc().Find(\"h4\")\n\tsel2 := sel.Closest(\"a\")\n\tassertLength(t, sel2.Nodes, 0)\n}\n\nfunc TestClosestInvalid(t *testing.T) {\n\tsel := Doc().Find(\"h4\")\n\tsel2 := sel.Closest(\"\")\n\tassertLength(t, sel2.Nodes, 0)\n}\n\nfunc TestClosestMany(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.Closest(\".pvk-content\")\n\tassertLength(t, sel2.Nodes, 2)\n\tassertSelectionIs(t, sel2, \"#pc1\", \"#pc2\")\n}\n\nfunc TestClosestRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.Closest(\".pvk-content\").End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestClosestSelectionItself(t *testing.T) {\n\tsel := Doc2().Find(\".three\")\n\tsel2 := sel.ClosestSelection(Doc2().Find(\".row\"))\n\tassertLength(t, sel2.Nodes, sel.Length())\n}\n\nfunc TestClosestSelectionNoDupes(t *testing.T) {\n\tsel := Doc().Find(\".span12\")\n\tsel2 := sel.ClosestSelection(Doc().Find(\".pvk-content\"))\n\tassertLength(t, sel2.Nodes, 1)\n\tassertClass(t, sel2, \"pvk-content\")\n}\n\nfunc TestClosestSelectionNone(t *testing.T) {\n\tsel := Doc().Find(\"h4\")\n\tsel2 := sel.ClosestSelection(Doc().Find(\"a\"))\n\tassertLength(t, sel2.Nodes, 0)\n}\n\nfunc TestClosestSelectionMany(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ClosestSelection(Doc().Find(\".pvk-content\"))\n\tassertLength(t, sel2.Nodes, 2)\n\tassertSelectionIs(t, sel2, \"#pc1\", \"#pc2\")\n}\n\nfunc TestClosestSelectionRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ClosestSelection(Doc().Find(\".pvk-content\")).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestClosestNodesItself(t *testing.T) {\n\tsel := Doc2().Find(\".three\")\n\tsel2 := sel.ClosestNodes(Doc2().Find(\".row\").Nodes...)\n\tassertLength(t, sel2.Nodes, sel.Length())\n}\n\nfunc TestClosestNodesNoDupes(t *testing.T) {\n\tsel := Doc().Find(\".span12\")\n\tsel2 := sel.ClosestNodes(Doc().Find(\".pvk-content\").Nodes...)\n\tassertLength(t, sel2.Nodes, 1)\n\tassertClass(t, sel2, \"pvk-content\")\n}\n\nfunc TestClosestNodesNone(t *testing.T) {\n\tsel := Doc().Find(\"h4\")\n\tsel2 := sel.ClosestNodes(Doc().Find(\"a\").Nodes...)\n\tassertLength(t, sel2.Nodes, 0)\n}\n\nfunc TestClosestNodesMany(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ClosestNodes(Doc().Find(\".pvk-content\").Nodes...)\n\tassertLength(t, sel2.Nodes, 2)\n\tassertSelectionIs(t, sel2, \"#pc1\", \"#pc2\")\n}\n\nfunc TestClosestNodesRollback(t *testing.T) {\n\tsel := Doc().Find(\".container-fluid\")\n\tsel2 := sel.ClosestNodes(Doc().Find(\".pvk-content\").Nodes...).End()\n\tassertEqual(t, sel, sel2)\n}\n\nfunc TestIssue26(t *testing.T) {\n\timg1 := `<img src=\"assets/images/gallery/thumb-1.jpg\" alt=\"150x150\" />`\n\timg2 := `<img alt=\"150x150\" src=\"assets/images/gallery/thumb-1.jpg\" />`\n\tcases := []struct {\n\t\ts string\n\t\tl int\n\t}{\n\t\t{s: img1 + img2, l: 2},\n\t\t{s: img1, l: 1},\n\t\t{s: img2, l: 1},\n\t}\n\tfor _, c := range cases {\n\t\tdoc, err := NewDocumentFromReader(strings.NewReader(c.s))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tsel := doc.Find(\"img[src]\")\n\t\tassertLength(t, sel.Nodes, c.l)\n\t}\n}\n"
        },
        {
          "name": "type.go",
          "type": "blob",
          "size": 6.4482421875,
          "content": "package goquery\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/andybalholm/cascadia\"\n\t\"golang.org/x/net/html\"\n)\n\n// Document represents an HTML document to be manipulated. Unlike jQuery, which\n// is loaded as part of a DOM document, and thus acts upon its containing\n// document, GoQuery doesn't know which HTML document to act upon. So it needs\n// to be told, and that's what the Document class is for. It holds the root\n// document node to manipulate, and can make selections on this document.\ntype Document struct {\n\t*Selection\n\tUrl      *url.URL\n\trootNode *html.Node\n}\n\n// NewDocumentFromNode is a Document constructor that takes a root html Node\n// as argument.\nfunc NewDocumentFromNode(root *html.Node) *Document {\n\treturn newDocument(root, nil)\n}\n\n// NewDocument is a Document constructor that takes a string URL as argument.\n// It loads the specified document, parses it, and stores the root Document\n// node, ready to be manipulated.\n//\n// Deprecated: Use the net/http standard library package to make the request\n// and validate the response before calling goquery.NewDocumentFromReader\n// with the response's body.\nfunc NewDocument(url string) (*Document, error) {\n\t// Load the URL\n\tres, e := http.Get(url)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\treturn NewDocumentFromResponse(res)\n}\n\n// NewDocumentFromReader returns a Document from an io.Reader.\n// It returns an error as second value if the reader's data cannot be parsed\n// as html. It does not check if the reader is also an io.Closer, the\n// provided reader is never closed by this call. It is the responsibility\n// of the caller to close it if required.\nfunc NewDocumentFromReader(r io.Reader) (*Document, error) {\n\troot, e := html.Parse(r)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\treturn newDocument(root, nil), nil\n}\n\n// NewDocumentFromResponse is another Document constructor that takes an http response as argument.\n// It loads the specified response's document, parses it, and stores the root Document\n// node, ready to be manipulated. The response's body is closed on return.\n//\n// Deprecated: Use goquery.NewDocumentFromReader with the response's body.\nfunc NewDocumentFromResponse(res *http.Response) (*Document, error) {\n\tif res == nil {\n\t\treturn nil, errors.New(\"Response is nil\")\n\t}\n\tdefer res.Body.Close()\n\tif res.Request == nil {\n\t\treturn nil, errors.New(\"Response.Request is nil\")\n\t}\n\n\t// Parse the HTML into nodes\n\troot, e := html.Parse(res.Body)\n\tif e != nil {\n\t\treturn nil, e\n\t}\n\n\t// Create and fill the document\n\treturn newDocument(root, res.Request.URL), nil\n}\n\n// CloneDocument creates a deep-clone of a document.\nfunc CloneDocument(doc *Document) *Document {\n\treturn newDocument(cloneNode(doc.rootNode), doc.Url)\n}\n\n// Private constructor, make sure all fields are correctly filled.\nfunc newDocument(root *html.Node, url *url.URL) *Document {\n\t// Create and fill the document\n\td := &Document{nil, url, root}\n\td.Selection = newSingleSelection(root, d)\n\treturn d\n}\n\n// Selection represents a collection of nodes matching some criteria. The\n// initial Selection can be created by using Document.Find, and then\n// manipulated using the jQuery-like chainable syntax and methods.\ntype Selection struct {\n\tNodes    []*html.Node\n\tdocument *Document\n\tprevSel  *Selection\n}\n\n// Helper constructor to create an empty selection\nfunc newEmptySelection(doc *Document) *Selection {\n\treturn &Selection{nil, doc, nil}\n}\n\n// Helper constructor to create a selection of only one node\nfunc newSingleSelection(node *html.Node, doc *Document) *Selection {\n\treturn &Selection{[]*html.Node{node}, doc, nil}\n}\n\n// Matcher is an interface that defines the methods to match\n// HTML nodes against a compiled selector string. Cascadia's\n// Selector implements this interface.\ntype Matcher interface {\n\tMatch(*html.Node) bool\n\tMatchAll(*html.Node) []*html.Node\n\tFilter([]*html.Node) []*html.Node\n}\n\n// Single compiles a selector string to a Matcher that stops after the first\n// match is found.\n//\n// By default, Selection.Find and other functions that accept a selector string\n// to select nodes will use all matches corresponding to that selector. By\n// using the Matcher returned by Single, at most the first match will be\n// selected.\n//\n// For example, those two statements are semantically equivalent:\n//\n//     sel1 := doc.Find(\"a\").First()\n//     sel2 := doc.FindMatcher(goquery.Single(\"a\"))\n//\n// The one using Single is optimized to be potentially much faster on large\n// documents.\n//\n// Only the behaviour of the MatchAll method of the Matcher interface is\n// altered compared to standard Matchers. This means that the single-selection\n// property of the Matcher only applies for Selection methods where the Matcher\n// is used to select nodes, not to filter or check if a node matches the\n// Matcher - in those cases, the behaviour of the Matcher is unchanged (e.g.\n// FilterMatcher(Single(\"div\")) will still result in a Selection with multiple\n// \"div\"s if there were many \"div\"s in the Selection to begin with).\nfunc Single(selector string) Matcher {\n\treturn singleMatcher{compileMatcher(selector)}\n}\n\n// SingleMatcher returns a Matcher matches the same nodes as m, but that stops\n// after the first match is found.\n//\n// See the documentation of function Single for more details.\nfunc SingleMatcher(m Matcher) Matcher {\n\tif _, ok := m.(singleMatcher); ok {\n\t\t// m is already a singleMatcher\n\t\treturn m\n\t}\n\treturn singleMatcher{m}\n}\n\n// compileMatcher compiles the selector string s and returns\n// the corresponding Matcher. If s is an invalid selector string,\n// it returns a Matcher that fails all matches.\nfunc compileMatcher(s string) Matcher {\n\tcs, err := cascadia.Compile(s)\n\tif err != nil {\n\t\treturn invalidMatcher{}\n\t}\n\treturn cs\n}\n\ntype singleMatcher struct {\n\tMatcher\n}\n\nfunc (m singleMatcher) MatchAll(n *html.Node) []*html.Node {\n\t// Optimized version - stops finding at the first match (cascadia-compiled\n\t// matchers all use this code path).\n\tif mm, ok := m.Matcher.(interface{ MatchFirst(*html.Node) *html.Node }); ok {\n\t\tnode := mm.MatchFirst(n)\n\t\tif node == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn []*html.Node{node}\n\t}\n\n\t// Fallback version, for e.g. test mocks that don't provide the MatchFirst\n\t// method.\n\tnodes := m.Matcher.MatchAll(n)\n\tif len(nodes) > 0 {\n\t\treturn nodes[:1:1]\n\t}\n\treturn nil\n}\n\n// invalidMatcher is a Matcher that always fails to match.\ntype invalidMatcher struct{}\n\nfunc (invalidMatcher) Match(n *html.Node) bool             { return false }\nfunc (invalidMatcher) MatchAll(n *html.Node) []*html.Node  { return nil }\nfunc (invalidMatcher) Filter(ns []*html.Node) []*html.Node { return nil }\n"
        },
        {
          "name": "type_test.go",
          "type": "blob",
          "size": 4.884765625,
          "content": "package goquery\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/andybalholm/cascadia\"\n\t\"golang.org/x/net/html\"\n)\n\n// Test helper functions and members\nvar doc *Document\nvar doc2 *Document\nvar doc3 *Document\nvar docB *Document\nvar docW *Document\n\nfunc Doc() *Document {\n\tif doc == nil {\n\t\tdoc = loadDoc(\"page.html\")\n\t}\n\treturn doc\n}\n\nfunc Doc2() *Document {\n\tif doc2 == nil {\n\t\tdoc2 = loadDoc(\"page2.html\")\n\t}\n\treturn doc2\n}\n\nfunc Doc2Clone() *Document {\n\treturn CloneDocument(Doc2())\n}\n\nfunc Doc3() *Document {\n\tif doc3 == nil {\n\t\tdoc3 = loadDoc(\"page3.html\")\n\t}\n\treturn doc3\n}\n\nfunc Doc3Clone() *Document {\n\treturn CloneDocument(Doc3())\n}\n\nfunc DocB() *Document {\n\tif docB == nil {\n\t\tdocB = loadDoc(\"gotesting.html\")\n\t}\n\treturn docB\n}\n\nfunc DocW() *Document {\n\tif docW == nil {\n\t\tdocW = loadDoc(\"gowiki.html\")\n\t}\n\treturn docW\n}\n\nfunc assertLength(t *testing.T, nodes []*html.Node, length int) {\n\tif len(nodes) != length {\n\t\tt.Errorf(\"Expected %d nodes, found %d.\", length, len(nodes))\n\t\tfor i, n := range nodes {\n\t\t\tt.Logf(\"Node %d: %+v.\", i, n)\n\t\t}\n\t}\n}\n\nfunc assertClass(t *testing.T, sel *Selection, class string) {\n\tif !sel.HasClass(class) {\n\t\tt.Errorf(\"Expected node to have class %s, found %+v.\", class, sel.Get(0))\n\t}\n}\n\nfunc assertPanic(t *testing.T) {\n\tif e := recover(); e == nil {\n\t\tt.Error(\"Expected a panic.\")\n\t}\n}\n\nfunc assertEqual(t *testing.T, s1 *Selection, s2 *Selection) {\n\tif s1 != s2 {\n\t\tt.Error(\"Expected selection objects to be the same.\")\n\t}\n}\n\nfunc assertSelectionIs(t *testing.T, sel *Selection, is ...string) {\n\tfor i := 0; i < sel.Length(); i++ {\n\t\tif !sel.Eq(i).Is(is[i]) {\n\t\t\tt.Errorf(\"Expected node %d to be %s, found %+v\", i, is[i], sel.Get(i))\n\t\t}\n\t}\n}\n\nfunc printSel(t *testing.T, sel *Selection) {\n\tif testing.Verbose() {\n\t\th, err := sel.Html()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Log(h)\n\t}\n}\n\nfunc loadDoc(page string) *Document {\n\tvar f *os.File\n\tvar e error\n\n\tif f, e = os.Open(fmt.Sprintf(\"./testdata/%s\", page)); e != nil {\n\t\tpanic(e.Error())\n\t}\n\tdefer f.Close()\n\n\tvar node *html.Node\n\tif node, e = html.Parse(f); e != nil {\n\t\tpanic(e.Error())\n\t}\n\treturn NewDocumentFromNode(node)\n}\n\nfunc loadString(t *testing.T, doc string) *Document {\n\td, err := NewDocumentFromReader(strings.NewReader(doc))\n\tif err != nil {\n\t\tt.Error(\"Failed to parse test document\")\n\t}\n\treturn d\n}\n\nfunc TestNewDocument(t *testing.T) {\n\tif f, e := os.Open(\"./testdata/page.html\"); e != nil {\n\t\tt.Error(e.Error())\n\t} else {\n\t\tdefer f.Close()\n\t\tif node, e := html.Parse(f); e != nil {\n\t\t\tt.Error(e.Error())\n\t\t} else {\n\t\t\tdoc = NewDocumentFromNode(node)\n\t\t}\n\t}\n}\n\nfunc TestNewDocumentFromReader(t *testing.T) {\n\tcases := []struct {\n\t\tsrc string\n\t\terr bool\n\t\tsel string\n\t\tcnt int\n\t}{\n\t\t0: {\n\t\t\tsrc: `\n<html>\n<head>\n<title>Test</title>\n<body>\n<h1>Hi</h1>\n</body>\n</html>`,\n\t\t\tsel: \"h1\",\n\t\t\tcnt: 1,\n\t\t},\n\t\t1: {\n\t\t\t// Actually pretty hard to make html.Parse return an error\n\t\t\t// based on content...\n\t\t\tsrc: `<html><body><aef<eqf>>>qq></body></ht>`,\n\t\t},\n\t}\n\tbuf := bytes.NewBuffer(nil)\n\n\tfor i, c := range cases {\n\t\tbuf.Reset()\n\t\tbuf.WriteString(c.src)\n\n\t\td, e := NewDocumentFromReader(buf)\n\t\tif (e != nil) != c.err {\n\t\t\tif c.err {\n\t\t\t\tt.Errorf(\"[%d] - expected error, got none\", i)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"[%d] - expected no error, got %s\", i, e)\n\t\t\t}\n\t\t}\n\t\tif c.sel != \"\" {\n\t\t\ts := d.Find(c.sel)\n\t\t\tif s.Length() != c.cnt {\n\t\t\t\tt.Errorf(\"[%d] - expected %d nodes, found %d\", i, c.cnt, s.Length())\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNewDocumentFromResponseNil(t *testing.T) {\n\t_, e := NewDocumentFromResponse(nil)\n\tif e == nil {\n\t\tt.Error(\"Expected error, got none\")\n\t}\n}\n\nfunc TestIssue103(t *testing.T) {\n\td, err := NewDocumentFromReader(strings.NewReader(\"<html><title>Scientists Stored These Images in DNA—Then Flawlessly Retrieved Them</title></html>\"))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\ttext := d.Find(\"title\").Text()\n\tfor i, r := range text {\n\t\tt.Logf(\"%d: %d - %q\\n\", i, r, string(r))\n\t}\n\tt.Log(text)\n}\n\nfunc TestSingle(t *testing.T) {\n\tdata := `\n<html>\n  <body>\n    <div class=\"b\">1</div>\n    <div class=\"a\">2</div>\n    <div class=\"a\">3</div>\n    <p class=\"b\">4</p>\n  </body>\n</html>\n`\n\tdoc, err := NewDocumentFromReader(strings.NewReader(data))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttext := doc.FindMatcher(Single(\"div\")).Text()\n\tif text != \"1\" {\n\t\tt.Fatalf(\"want %q, got %q\", \"1\", text)\n\t}\n\n\t// Verify semantic equivalence\n\tsel1 := doc.Find(\"div\").First()\n\tsel2 := doc.FindMatcher(Single(\"div\"))\n\tif sel1.Text() != sel2.Text() {\n\t\tt.Fatalf(\"want sel1 to equal sel2\")\n\t}\n\n\t// Here, the Single has no effect as the selector is used to filter\n\t// from the existing selection, not to find nodes in the document.\n\tdivs := doc.Find(\"div\")\n\ttext = divs.FilterMatcher(Single(\".a\")).Text()\n\tif text != \"23\" {\n\t\tt.Fatalf(\"want %q, got %q\", \"23\", text)\n\t}\n\n\tclassA := cascadia.MustCompile(\".a\")\n\tclassB := cascadia.MustCompile(\".b\")\n\ttext = doc.FindMatcher(classB).AddMatcher(SingleMatcher(classA)).Text()\n\tif text != \"142\" {\n\t\tt.Fatalf(\"want %q, got %q\", \"142\", text)\n\t}\n}\n"
        },
        {
          "name": "utilities.go",
          "type": "blob",
          "size": 5.0546875,
          "content": "package goquery\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\n\t\"golang.org/x/net/html\"\n)\n\n// used to determine if a set (map[*html.Node]bool) should be used\n// instead of iterating over a slice. The set uses more memory and\n// is slower than slice iteration for small N.\nconst minNodesForSet = 1000\n\nvar nodeNames = []string{\n\thtml.ErrorNode:    \"#error\",\n\thtml.TextNode:     \"#text\",\n\thtml.DocumentNode: \"#document\",\n\thtml.CommentNode:  \"#comment\",\n}\n\n// NodeName returns the node name of the first element in the selection.\n// It tries to behave in a similar way as the DOM's nodeName property\n// (https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName).\n//\n// Go's net/html package defines the following node types, listed with\n// the corresponding returned value from this function:\n//\n//     ErrorNode : #error\n//     TextNode : #text\n//     DocumentNode : #document\n//     ElementNode : the element's tag name\n//     CommentNode : #comment\n//     DoctypeNode : the name of the document type\n//\nfunc NodeName(s *Selection) string {\n\tif s.Length() == 0 {\n\t\treturn \"\"\n\t}\n\treturn nodeName(s.Get(0))\n}\n\n// nodeName returns the node name of the given html node.\n// See NodeName for additional details on behaviour.\nfunc nodeName(node *html.Node) string {\n\tif node == nil {\n\t\treturn \"\"\n\t}\n\n\tswitch node.Type {\n\tcase html.ElementNode, html.DoctypeNode:\n\t\treturn node.Data\n\tdefault:\n\t\tif int(node.Type) < len(nodeNames) {\n\t\t\treturn nodeNames[node.Type]\n\t\t}\n\t\treturn \"\"\n\t}\n}\n\n// Render renders the HTML of the first item in the selection and writes it to\n// the writer. It behaves the same as OuterHtml but writes to w instead of\n// returning the string.\nfunc Render(w io.Writer, s *Selection) error {\n\tif s.Length() == 0 {\n\t\treturn nil\n\t}\n\tn := s.Get(0)\n\treturn html.Render(w, n)\n}\n\n// OuterHtml returns the outer HTML rendering of the first item in\n// the selection - that is, the HTML including the first element's\n// tag and attributes.\n//\n// Unlike Html, this is a function and not a method on the Selection,\n// because this is not a jQuery method (in javascript-land, this is\n// a property provided by the DOM).\nfunc OuterHtml(s *Selection) (string, error) {\n\tvar buf bytes.Buffer\n\tif err := Render(&buf, s); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn buf.String(), nil\n}\n\n// Loop through all container nodes to search for the target node.\nfunc sliceContains(container []*html.Node, contained *html.Node) bool {\n\tfor _, n := range container {\n\t\tif nodeContains(n, contained) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Checks if the contained node is within the container node.\nfunc nodeContains(container *html.Node, contained *html.Node) bool {\n\t// Check if the parent of the contained node is the container node, traversing\n\t// upward until the top is reached, or the container is found.\n\tfor contained = contained.Parent; contained != nil; contained = contained.Parent {\n\t\tif container == contained {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Checks if the target node is in the slice of nodes.\nfunc isInSlice(slice []*html.Node, node *html.Node) bool {\n\treturn indexInSlice(slice, node) > -1\n}\n\n// Returns the index of the target node in the slice, or -1.\nfunc indexInSlice(slice []*html.Node, node *html.Node) int {\n\tif node != nil {\n\t\tfor i, n := range slice {\n\t\t\tif n == node {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n\n// Appends the new nodes to the target slice, making sure no duplicate is added.\n// There is no check to the original state of the target slice, so it may still\n// contain duplicates. The target slice is returned because append() may create\n// a new underlying array. If targetSet is nil, a local set is created with the\n// target if len(target) + len(nodes) is greater than minNodesForSet.\nfunc appendWithoutDuplicates(target []*html.Node, nodes []*html.Node, targetSet map[*html.Node]bool) []*html.Node {\n\t// if there are not that many nodes, don't use the map, faster to just use nested loops\n\t// (unless a non-nil targetSet is passed, in which case the caller knows better).\n\tif targetSet == nil && len(target)+len(nodes) < minNodesForSet {\n\t\tfor _, n := range nodes {\n\t\t\tif !isInSlice(target, n) {\n\t\t\t\ttarget = append(target, n)\n\t\t\t}\n\t\t}\n\t\treturn target\n\t}\n\n\t// if a targetSet is passed, then assume it is reliable, otherwise create one\n\t// and initialize it with the current target contents.\n\tif targetSet == nil {\n\t\ttargetSet = make(map[*html.Node]bool, len(target))\n\t\tfor _, n := range target {\n\t\t\ttargetSet[n] = true\n\t\t}\n\t}\n\tfor _, n := range nodes {\n\t\tif !targetSet[n] {\n\t\t\ttarget = append(target, n)\n\t\t\ttargetSet[n] = true\n\t\t}\n\t}\n\n\treturn target\n}\n\n// Loop through a selection, returning only those nodes that pass the predicate\n// function.\nfunc grep(sel *Selection, predicate func(i int, s *Selection) bool) (result []*html.Node) {\n\tfor i, n := range sel.Nodes {\n\t\tif predicate(i, newSingleSelection(n, sel.document)) {\n\t\t\tresult = append(result, n)\n\t\t}\n\t}\n\treturn result\n}\n\n// Creates a new Selection object based on the specified nodes, and keeps the\n// source Selection object on the stack (linked list).\nfunc pushStack(fromSel *Selection, nodes []*html.Node) *Selection {\n\tresult := &Selection{nodes, fromSel.document, fromSel}\n\treturn result\n}\n"
        },
        {
          "name": "utilities_test.go",
          "type": "blob",
          "size": 2.6162109375,
          "content": "package goquery\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"golang.org/x/net/html\"\n)\n\nvar allNodes = `<!doctype html>\n<html>\n\t<head>\n\t\t<meta a=\"b\">\n\t</head>\n\t<body>\n\t\t<p><!-- this is a comment -->\n\t\tThis is some text.\n\t\t</p>\n\t\t<div></div>\n\t\t<h1 class=\"header\"></h1>\n\t\t<h2 class=\"header\"></h2>\n\t</body>\n</html>`\n\nfunc TestNodeName(t *testing.T) {\n\tdoc, err := NewDocumentFromReader(strings.NewReader(allNodes))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tn0 := doc.Nodes[0]\n\tnDT := n0.FirstChild\n\tsMeta := doc.Find(\"meta\")\n\tnMeta := sMeta.Get(0)\n\tsP := doc.Find(\"p\")\n\tnP := sP.Get(0)\n\tnComment := nP.FirstChild\n\tnText := nComment.NextSibling\n\n\tcases := []struct {\n\t\tnode *html.Node\n\t\ttyp  html.NodeType\n\t\twant string\n\t}{\n\t\t{n0, html.DocumentNode, nodeNames[html.DocumentNode]},\n\t\t{nDT, html.DoctypeNode, \"html\"},\n\t\t{nMeta, html.ElementNode, \"meta\"},\n\t\t{nP, html.ElementNode, \"p\"},\n\t\t{nComment, html.CommentNode, nodeNames[html.CommentNode]},\n\t\t{nText, html.TextNode, nodeNames[html.TextNode]},\n\t}\n\tfor i, c := range cases {\n\t\tgot := NodeName(newSingleSelection(c.node, doc))\n\t\tif c.node.Type != c.typ {\n\t\t\tt.Errorf(\"%d: want type %v, got %v\", i, c.typ, c.node.Type)\n\t\t}\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"%d: want %q, got %q\", i, c.want, got)\n\t\t}\n\t}\n}\n\nfunc TestNodeNameMultiSel(t *testing.T) {\n\tdoc, err := NewDocumentFromReader(strings.NewReader(allNodes))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tin := []string{\"p\", \"h1\", \"div\"}\n\tvar out []string\n\tdoc.Find(strings.Join(in, \", \")).Each(func(i int, s *Selection) {\n\t\tgot := NodeName(s)\n\t\tout = append(out, got)\n\t})\n\tsort.Strings(in)\n\tsort.Strings(out)\n\tif !reflect.DeepEqual(in, out) {\n\t\tt.Errorf(\"want %v, got %v\", in, out)\n\t}\n}\n\nfunc TestOuterHtml(t *testing.T) {\n\tdoc, err := NewDocumentFromReader(strings.NewReader(allNodes))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tn0 := doc.Nodes[0]\n\tnDT := n0.FirstChild\n\tsMeta := doc.Find(\"meta\")\n\tsP := doc.Find(\"p\")\n\tnP := sP.Get(0)\n\tnComment := nP.FirstChild\n\tnText := nComment.NextSibling\n\tsHeaders := doc.Find(\".header\")\n\n\tcases := []struct {\n\t\tnode *html.Node\n\t\tsel  *Selection\n\t\twant string\n\t}{\n\t\t{nDT, nil, \"<!DOCTYPE html>\"}, // render makes DOCTYPE all caps\n\t\t{nil, sMeta, `<meta a=\"b\"/>`}, // and auto-closes the meta\n\t\t{nil, sP, `<p><!-- this is a comment -->\n\t\tThis is some text.\n\t\t</p>`},\n\t\t{nComment, nil, \"<!-- this is a comment -->\"},\n\t\t{nText, nil, `\n\t\tThis is some text.\n\t\t`},\n\t\t{nil, sHeaders, `<h1 class=\"header\"></h1>`},\n\t}\n\tfor i, c := range cases {\n\t\tif c.sel == nil {\n\t\t\tc.sel = newSingleSelection(c.node, doc)\n\t\t}\n\t\tgot, err := OuterHtml(c.sel)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"%d: want %q, got %q\", i, c.want, got)\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}