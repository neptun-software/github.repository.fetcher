{
  "metadata": {
    "timestamp": 1736567911620,
    "page": 56,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjYw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "samber/lo",
      "stars": 18399,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7392578125,
          "content": "\n# Created by https://www.toptal.com/developers/gitignore/api/go\n# Edit at https://www.toptal.com/developers/gitignore?templates=go\n\n### Go ###\n# If you prefer the allow list template instead of the deny list, see community template:\n# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore\n#\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n# Go workspace file\ngo.work\n\n### Go Patch ###\n/vendor/\n/Godeps/\n\n# End of https://www.toptal.com/developers/gitignore/api/go\n\ncover.out\ncover.html\n.vscode\n\n.idea/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0947265625,
          "content": "language: go\nbefore_install:\n  - go mod download\n  - make tools\ngo:\n  - \"1.18\"\nscript: make test\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.0947265625,
          "content": "\nFROM golang:1.23.1\n\nWORKDIR /go/src/github.com/samber/lo\n\nCOPY Makefile go.* ./\n\nRUN make tools\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "MIT License\n\nCopyright (c) 2022-2025 Samuel Berthe\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.033203125,
          "content": "\nbuild:\n\tgo build -v ./...\n\ntest:\n\tgo test -race -v ./...\nwatch-test:\n\treflex -t 50ms -s -- sh -c 'gotest -race -v ./...'\n\nbench:\n\tgo test -benchmem -count 3 -bench ./...\nwatch-bench:\n\treflex -t 50ms -s -- sh -c 'go test -benchmem -count 3 -bench ./...'\n\ncoverage:\n\tgo test -v -coverprofile=cover.out -covermode=atomic ./...\n\tgo tool cover -html=cover.out -o cover.html\n\n# tools\ntools:\n\tgo install github.com/cespare/reflex@latest\n\tgo install github.com/rakyll/gotest@latest\n\tgo install github.com/psampaz/go-mod-outdated@latest\n\tgo install github.com/jondot/goweight@latest\n\tgo install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\tgo get -t -u golang.org/x/tools/cmd/cover\n\tgo install github.com/sonatype-nexus-community/nancy@latest\n\tgo mod tidy\n\nlint:\n\tgolangci-lint run --timeout 60s --max-same-issues 50 ./...\nlint-fix:\n\tgolangci-lint run --timeout 60s --max-same-issues 50 --fix ./...\n\naudit: tools\n\tgo list -json -m all | nancy sleuth\n\noutdated: tools\n\tgo list -u -m -json all | go-mod-outdated -update -direct\n\nweight: tools\n\tgoweight\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 75.4912109375,
          "content": "# lo - Iterate over slices, maps, channels...\n\n[![tag](https://img.shields.io/github/tag/samber/lo.svg)](https://github.com/samber/lo/releases)\n![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.18-%23007d9c)\n[![GoDoc](https://godoc.org/github.com/samber/lo?status.svg)](https://pkg.go.dev/github.com/samber/lo)\n![Build Status](https://github.com/samber/lo/actions/workflows/test.yml/badge.svg)\n[![Go report](https://goreportcard.com/badge/github.com/samber/lo)](https://goreportcard.com/report/github.com/samber/lo)\n[![Coverage](https://img.shields.io/codecov/c/github/samber/lo)](https://codecov.io/gh/samber/lo)\n[![Contributors](https://img.shields.io/github/contributors/samber/lo)](https://github.com/samber/lo/graphs/contributors)\n[![License](https://img.shields.io/github/license/samber/lo)](./LICENSE)\n\n✨ **`samber/lo` is a Lodash-style Go library based on Go 1.18+ Generics.**\n\nThis project started as an experiment with the new generics implementation. It may look like [Lodash](https://github.com/lodash/lodash) in some aspects. I used to code with the fantastic [\"go-funk\"](https://github.com/thoas/go-funk) package, but \"go-funk\" uses reflection and therefore is not typesafe.\n\nAs expected, benchmarks demonstrate that generics are much faster than implementations based on the \"reflect\" package. Benchmarks also show similar performance gains compared to pure `for` loops. [See below](#-benchmark).\n\nIn the future, 5 to 10 helpers will overlap with those coming into the Go standard library (under package names `slices` and `maps`). I feel this library is legitimate and offers many more valuable abstractions.\n\n**See also:**\n\n- [samber/do](https://github.com/samber/do): A dependency injection toolkit based on Go 1.18+ Generics\n- [samber/mo](https://github.com/samber/mo): Monads based on Go 1.18+ Generics (Option, Result, Either...)\n\n**Why this name?**\n\nI wanted a **short name**, similar to \"Lodash\" and no Go package uses this name.\n\n![lo](img/logo-full.png)\n\n## 🚀 Install\n\n```sh\ngo get github.com/samber/lo@v1\n```\n\nThis library is v1 and follows SemVer strictly.\n\nNo breaking changes will be made to exported APIs before v2.0.0.\n\nThis library has no dependencies outside the Go standard library.\n\n## 💡 Usage\n\nYou can import `lo` using:\n\n```go\nimport (\n    \"github.com/samber/lo\"\n    lop \"github.com/samber/lo/parallel\"\n)\n```\n\nThen use one of the helpers below:\n\n```go\nnames := lo.Uniq([]string{\"Samuel\", \"John\", \"Samuel\"})\n// []string{\"Samuel\", \"John\"}\n```\n\nMost of the time, the compiler will be able to infer the type so that you can call: `lo.Uniq([]string{...})`.\n\n### Tips for lazy developers\n\nI cannot recommend it, but in case you are too lazy for repeating `lo.` everywhere, you can import the entire library into the namespace.\n\n```go\nimport (\n    . \"github.com/samber/lo\"\n)\n```\n\nI take no responsibility on this junk. 😁 💩\n\n## 🤠 Spec\n\nGoDoc: [https://godoc.org/github.com/samber/lo](https://godoc.org/github.com/samber/lo)\n\nSupported helpers for slices:\n\n- [Filter](#filter)\n- [Map](#map)\n- [FilterMap](#filtermap)\n- [FlatMap](#flatmap)\n- [Reduce](#reduce)\n- [ReduceRight](#reduceright)\n- [ForEach](#foreach)\n- [ForEachWhile](#foreachwhile)\n- [Times](#times)\n- [Uniq](#uniq)\n- [UniqBy](#uniqby)\n- [GroupBy](#groupby)\n- [Chunk](#chunk)\n- [PartitionBy](#partitionby)\n- [Flatten](#flatten)\n- [Interleave](#interleave)\n- [Shuffle](#shuffle)\n- [Reverse](#reverse)\n- [Fill](#fill)\n- [Repeat](#repeat)\n- [RepeatBy](#repeatby)\n- [KeyBy](#keyby)\n- [Associate / SliceToMap](#associate-alias-slicetomap)\n- [Drop](#drop)\n- [DropRight](#dropright)\n- [DropWhile](#dropwhile)\n- [DropRightWhile](#droprightwhile)\n- [DropByIndex](#DropByIndex)\n- [Reject](#reject)\n- [RejectMap](#rejectmap)\n- [FilterReject](#filterreject)\n- [Count](#count)\n- [CountBy](#countby)\n- [CountValues](#countvalues)\n- [CountValuesBy](#countvaluesby)\n- [Subset](#subset)\n- [Slice](#slice)\n- [Replace](#replace)\n- [ReplaceAll](#replaceall)\n- [Compact](#compact)\n- [IsSorted](#issorted)\n- [IsSortedByKey](#issortedbykey)\n- [Splice](#Splice)\n\nSupported helpers for maps:\n\n- [Keys](#keys)\n- [UniqKeys](#uniqkeys)\n- [HasKey](#haskey)\n- [ValueOr](#valueor)\n- [Values](#values)\n- [UniqValues](#uniqvalues)\n- [PickBy](#pickby)\n- [PickByKeys](#pickbykeys)\n- [PickByValues](#pickbyvalues)\n- [OmitBy](#omitby)\n- [OmitByKeys](#omitbykeys)\n- [OmitByValues](#omitbyvalues)\n- [Entries / ToPairs](#entries-alias-topairs)\n- [FromEntries / FromPairs](#fromentries-alias-frompairs)\n- [Invert](#invert)\n- [Assign (merge of maps)](#assign)\n- [MapKeys](#mapkeys)\n- [MapValues](#mapvalues)\n- [MapEntries](#mapentries)\n- [MapToSlice](#maptoslice)\n\nSupported math helpers:\n\n- [Range / RangeFrom / RangeWithSteps](#range--rangefrom--rangewithsteps)\n- [Clamp](#clamp)\n- [Sum](#sum)\n- [SumBy](#sumby)\n- [Mean](#mean)\n- [MeanBy](#meanby)\n\nSupported helpers for strings:\n\n- [RandomString](#randomstring)\n- [Substring](#substring)\n- [ChunkString](#chunkstring)\n- [RuneLength](#runelength)\n- [PascalCase](#pascalcase)\n- [CamelCase](#camelcase)\n- [KebabCase](#kebabcase)\n- [SnakeCase](#snakecase)\n- [Words](#words)\n- [Capitalize](#capitalize)\n- [Ellipsis](#ellipsis)\n\nSupported helpers for tuples:\n\n- [T2 -> T9](#t2---t9)\n- [Unpack2 -> Unpack9](#unpack2---unpack9)\n- [Zip2 -> Zip9](#zip2---zip9)\n- [ZipBy2 -> ZipBy9](#zipby2---zipby9)\n- [Unzip2 -> Unzip9](#unzip2---unzip9)\n- [UnzipBy2 -> UnzipBy9](#unzipby2---unzipby9)\n\nSupported helpers for time and duration:\n\n- [Duration](#duration)\n- [Duration0 -> Duration10](#duration0---duration10)\n\nSupported helpers for channels:\n\n- [ChannelDispatcher](#channeldispatcher)\n- [SliceToChannel](#slicetochannel)\n- [Generator](#generator)\n- [Buffer](#buffer)\n- [BufferWithTimeout](#bufferwithtimeout)\n- [FanIn](#fanin)\n- [FanOut](#fanout)\n\nSupported intersection helpers:\n\n- [Contains](#contains)\n- [ContainsBy](#containsby)\n- [Every](#every)\n- [EveryBy](#everyby)\n- [Some](#some)\n- [SomeBy](#someby)\n- [None](#none)\n- [NoneBy](#noneby)\n- [Intersect](#intersect)\n- [Difference](#difference)\n- [Union](#union)\n- [Without](#without)\n- [WithoutEmpty](#withoutempty)\n\nSupported search helpers:\n\n- [IndexOf](#indexof)\n- [LastIndexOf](#lastindexof)\n- [Find](#find)\n- [FindIndexOf](#findindexof)\n- [FindLastIndexOf](#findlastindexof)\n- [FindOrElse](#findorelse)\n- [FindKey](#findkey)\n- [FindKeyBy](#findkeyby)\n- [FindUniques](#finduniques)\n- [FindUniquesBy](#finduniquesby)\n- [FindDuplicates](#findduplicates)\n- [FindDuplicatesBy](#findduplicatesby)\n- [Min](#min)\n- [MinBy](#minby)\n- [Earliest](#earliest)\n- [EarliestBy](#earliestby)\n- [Max](#max)\n- [MaxBy](#maxby)\n- [Latest](#latest)\n- [LatestBy](#latestby)\n- [First](#first)\n- [FirstOrEmpty](#FirstOrEmpty)\n- [FirstOr](#FirstOr)\n- [Last](#last)\n- [LastOrEmpty](#LastOrEmpty)\n- [LastOr](#LastOr)\n- [Nth](#nth)\n- [Sample](#sample)\n- [Samples](#samples)\n\nConditional helpers:\n\n- [Ternary](#ternary)\n- [TernaryF](#ternaryf)\n- [If / ElseIf / Else](#if--elseif--else)\n- [Switch / Case / Default](#switch--case--default)\n\nType manipulation helpers:\n\n- [IsNil](#isnil)\n- [ToPtr](#toptr)\n- [Nil](#nil)\n- [EmptyableToPtr](#emptyabletoptr)\n- [FromPtr](#fromptr)\n- [FromPtrOr](#fromptror)\n- [ToSlicePtr](#tosliceptr)\n- [FromSlicePtr](#fromsliceptr)\n- [FromSlicePtrOr](#fromsliceptror)\n- [ToAnySlice](#toanyslice)\n- [FromAnySlice](#fromanyslice)\n- [Empty](#empty)\n- [IsEmpty](#isempty)\n- [IsNotEmpty](#isnotempty)\n- [Coalesce](#coalesce)\n- [CoalesceOrEmpty](#coalesceorempty)\n\nFunction helpers:\n\n- [Partial](#partial)\n- [Partial2 -> Partial5](#partial2---partial5)\n\nConcurrency helpers:\n\n- [Attempt](#attempt)\n- [AttemptWhile](#attemptwhile)\n- [AttemptWithDelay](#attemptwithdelay)\n- [AttemptWhileWithDelay](#attemptwhilewithdelay)\n- [Debounce](#debounce)\n- [DebounceBy](#debounceby)\n- [Synchronize](#synchronize)\n- [Async](#async)\n- [Transaction](#transaction)\n- [WaitFor](#waitfor)\n- [WaitForWithContext](#waitforwithcontext)\n\nError handling:\n\n- [Validate](#validate)\n- [Must](#must)\n- [Try](#try)\n- [Try1 -> Try6](#try0-6)\n- [TryOr](#tryor)\n- [TryOr1 -> TryOr6](#tryor0-6)\n- [TryCatch](#trycatch)\n- [TryWithErrorValue](#trywitherrorvalue)\n- [TryCatchWithErrorValue](#trycatchwitherrorvalue)\n- [ErrorsAs](#errorsas)\n\nConstraints:\n\n- Clonable\n\n### Filter\n\nIterates over a collection and returns an array of all the elements the predicate function returns `true` for.\n\n```go\neven := lo.Filter([]int{1, 2, 3, 4}, func(x int, index int) bool {\n    return x%2 == 0\n})\n// []int{2, 4}\n```\n\n[[play](https://go.dev/play/p/Apjg3WeSi7K)]\n\n### Map\n\nManipulates a slice of one type and transforms it into a slice of another type:\n\n```go\nimport \"github.com/samber/lo\"\n\nlo.Map([]int64{1, 2, 3, 4}, func(x int64, index int) string {\n    return strconv.FormatInt(x, 10)\n})\n// []string{\"1\", \"2\", \"3\", \"4\"}\n```\n\n[[play](https://go.dev/play/p/OkPcYAhBo0D)]\n\nParallel processing: like `lo.Map()`, but the mapper function is called in a goroutine. Results are returned in the same order.\n\n```go\nimport lop \"github.com/samber/lo/parallel\"\n\nlop.Map([]int64{1, 2, 3, 4}, func(x int64, _ int) string {\n    return strconv.FormatInt(x, 10)\n})\n// []string{\"1\", \"2\", \"3\", \"4\"}\n```\n\n### FilterMap\n\nReturns a slice which obtained after both filtering and mapping using the given callback function.\n\nThe callback function should return two values: the result of the mapping operation and whether the result element should be included or not.\n\n```go\nmatching := lo.FilterMap([]string{\"cpu\", \"gpu\", \"mouse\", \"keyboard\"}, func(x string, _ int) (string, bool) {\n    if strings.HasSuffix(x, \"pu\") {\n        return \"xpu\", true\n    }\n    return \"\", false\n})\n// []string{\"xpu\", \"xpu\"}\n```\n\n[[play](https://go.dev/play/p/-AuYXfy7opz)]\n\n### FlatMap\n\nManipulates a slice and transforms and flattens it to a slice of another type. The transform function can either return a slice or a `nil`, and in the `nil` case no value is added to the final slice.\n\n```go\nlo.FlatMap([]int64{0, 1, 2}, func(x int64, _ int) []string {\n    return []string{\n        strconv.FormatInt(x, 10),\n        strconv.FormatInt(x, 10),\n    }\n})\n// []string{\"0\", \"0\", \"1\", \"1\", \"2\", \"2\"}\n```\n\n[[play](https://go.dev/play/p/YSoYmQTA8-U)]\n\n### Reduce\n\nReduces a collection to a single value. The value is calculated by accumulating the result of running each element in the collection through an accumulator function. Each successive invocation is supplied with the return value returned by the previous call.\n\n```go\nsum := lo.Reduce([]int{1, 2, 3, 4}, func(agg int, item int, _ int) int {\n    return agg + item\n}, 0)\n// 10\n```\n\n[[play](https://go.dev/play/p/R4UHXZNaaUG)]\n\n### ReduceRight\n\nLike `lo.Reduce` except that it iterates over elements of collection from right to left.\n\n```go\nresult := lo.ReduceRight([][]int{{0, 1}, {2, 3}, {4, 5}}, func(agg []int, item []int, _ int) []int {\n    return append(agg, item...)\n}, []int{})\n// []int{4, 5, 2, 3, 0, 1}\n```\n\n[[play](https://go.dev/play/p/Fq3W70l7wXF)]\n\n### ForEach\n\nIterates over elements of a collection and invokes the function over each element.\n\n```go\nimport \"github.com/samber/lo\"\n\nlo.ForEach([]string{\"hello\", \"world\"}, func(x string, _ int) {\n    println(x)\n})\n// prints \"hello\\nworld\\n\"\n```\n\n[[play](https://go.dev/play/p/oofyiUPRf8t)]\n\nParallel processing: like `lo.ForEach()`, but the callback is called as a goroutine.\n\n```go\nimport lop \"github.com/samber/lo/parallel\"\n\nlop.ForEach([]string{\"hello\", \"world\"}, func(x string, _ int) {\n    println(x)\n})\n// prints \"hello\\nworld\\n\" or \"world\\nhello\\n\"\n```\n\n### ForEachWhile\n\nIterates over collection elements and invokes iteratee for each element collection return value decide to continue or break, like do while().\n\n```go\nlist := []int64{1, 2, -42, 4}\n\nlo.ForEachWhile(list, func(x int64, _ int) bool {\n\tif x < 0 {\n\t\treturn false\n\t}\n\tfmt.Println(x)\n\treturn true\n})\n// 1\n// 2\n```\n\n[[play](https://go.dev/play/p/QnLGt35tnow)]\n\n### Times\n\nTimes invokes the iteratee n times, returning an array of the results of each invocation. The iteratee is invoked with index as argument.\n\n```go\nimport \"github.com/samber/lo\"\n\nlo.Times(3, func(i int) string {\n    return strconv.FormatInt(int64(i), 10)\n})\n// []string{\"0\", \"1\", \"2\"}\n```\n\n[[play](https://go.dev/play/p/vgQj3Glr6lT)]\n\nParallel processing: like `lo.Times()`, but callback is called in goroutine.\n\n```go\nimport lop \"github.com/samber/lo/parallel\"\n\nlop.Times(3, func(i int) string {\n    return strconv.FormatInt(int64(i), 10)\n})\n// []string{\"0\", \"1\", \"2\"}\n```\n\n### Uniq\n\nReturns a duplicate-free version of an array, in which only the first occurrence of each element is kept. The order of result values is determined by the order they occur in the array.\n\n```go\nuniqValues := lo.Uniq([]int{1, 2, 2, 1})\n// []int{1, 2}\n```\n\n[[play](https://go.dev/play/p/DTzbeXZ6iEN)]\n\n### UniqBy\n\nReturns a duplicate-free version of an array, in which only the first occurrence of each element is kept. The order of result values is determined by the order they occur in the array. It accepts `iteratee` which is invoked for each element in array to generate the criterion by which uniqueness is computed.\n\n```go\nuniqValues := lo.UniqBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {\n    return i%3\n})\n// []int{0, 1, 2}\n```\n\n[[play](https://go.dev/play/p/g42Z3QSb53u)]\n\n### GroupBy\n\nReturns an object composed of keys generated from the results of running each element of collection through iteratee.\n\n```go\nimport lo \"github.com/samber/lo\"\n\ngroups := lo.GroupBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {\n    return i%3\n})\n// map[int][]int{0: []int{0, 3}, 1: []int{1, 4}, 2: []int{2, 5}}\n```\n\n[[play](https://go.dev/play/p/XnQBd_v6brd)]\n\nParallel processing: like `lo.GroupBy()`, but callback is called in goroutine.\n\n```go\nimport lop \"github.com/samber/lo/parallel\"\n\nlop.GroupBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {\n    return i%3\n})\n// map[int][]int{0: []int{0, 3}, 1: []int{1, 4}, 2: []int{2, 5}}\n```\n\n### Chunk\n\nReturns an array of elements split into groups the length of size. If array can't be split evenly, the final chunk will be the remaining elements.\n\n```go\nlo.Chunk([]int{0, 1, 2, 3, 4, 5}, 2)\n// [][]int{{0, 1}, {2, 3}, {4, 5}}\n\nlo.Chunk([]int{0, 1, 2, 3, 4, 5, 6}, 2)\n// [][]int{{0, 1}, {2, 3}, {4, 5}, {6}}\n\nlo.Chunk([]int{}, 2)\n// [][]int{}\n\nlo.Chunk([]int{0}, 2)\n// [][]int{{0}}\n```\n\n[[play](https://go.dev/play/p/EeKl0AuTehH)]\n\n### PartitionBy\n\nReturns an array of elements split into groups. The order of grouped values is determined by the order they occur in collection. The grouping is generated from the results of running each element of collection through iteratee.\n\n```go\nimport lo \"github.com/samber/lo\"\n\npartitions := lo.PartitionBy([]int{-2, -1, 0, 1, 2, 3, 4, 5}, func(x int) string {\n    if x < 0 {\n        return \"negative\"\n    } else if x%2 == 0 {\n        return \"even\"\n    }\n    return \"odd\"\n})\n// [][]int{{-2, -1}, {0, 2, 4}, {1, 3, 5}}\n```\n\n[[play](https://go.dev/play/p/NfQ_nGjkgXW)]\n\nParallel processing: like `lo.PartitionBy()`, but callback is called in goroutine. Results are returned in the same order.\n\n```go\nimport lop \"github.com/samber/lo/parallel\"\n\npartitions := lop.PartitionBy([]int{-2, -1, 0, 1, 2, 3, 4, 5}, func(x int) string {\n    if x < 0 {\n        return \"negative\"\n    } else if x%2 == 0 {\n        return \"even\"\n    }\n    return \"odd\"\n})\n// [][]int{{-2, -1}, {0, 2, 4}, {1, 3, 5}}\n```\n\n### Flatten\n\nReturns an array a single level deep.\n\n```go\nflat := lo.Flatten([][]int{{0, 1}, {2, 3, 4, 5}})\n// []int{0, 1, 2, 3, 4, 5}\n```\n\n[[play](https://go.dev/play/p/rbp9ORaMpjw)]\n\n### Interleave\n\nRound-robin alternating input slices and sequentially appending value at index into result.\n\n```go\ninterleaved := lo.Interleave([]int{1, 4, 7}, []int{2, 5, 8}, []int{3, 6, 9})\n// []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\n\ninterleaved := lo.Interleave([]int{1}, []int{2, 5, 8}, []int{3, 6}, []int{4, 7, 9, 10})\n// []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n```\n\n[[play](https://go.dev/play/p/-RJkTLQEDVt)]\n\n### Shuffle\n\nReturns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.\n\n```go\nrandomOrder := lo.Shuffle([]int{0, 1, 2, 3, 4, 5})\n// []int{1, 4, 0, 3, 5, 2}\n```\n\n[[play](https://go.dev/play/p/Qp73bnTDnc7)]\n\n### Reverse\n\nReverses array so that the first element becomes the last, the second element becomes the second to last, and so on.\n\n⚠️ This helper is **mutable**. This behavior might change in `v2.0.0`. See [#160](https://github.com/samber/lo/issues/160).\n\n```go\nreverseOrder := lo.Reverse([]int{0, 1, 2, 3, 4, 5})\n// []int{5, 4, 3, 2, 1, 0}\n```\n\n[[play](https://go.dev/play/p/fhUMLvZ7vS6)]\n\n### Fill\n\nFills elements of array with `initial` value.\n\n```go\ntype foo struct {\n  bar string\n}\n\nfunc (f foo) Clone() foo {\n  return foo{f.bar}\n}\n\ninitializedSlice := lo.Fill([]foo{foo{\"a\"}, foo{\"a\"}}, foo{\"b\"})\n// []foo{foo{\"b\"}, foo{\"b\"}}\n```\n\n[[play](https://go.dev/play/p/VwR34GzqEub)]\n\n### Repeat\n\nBuilds a slice with N copies of initial value.\n\n```go\ntype foo struct {\n  bar string\n}\n\nfunc (f foo) Clone() foo {\n  return foo{f.bar}\n}\n\nslice := lo.Repeat(2, foo{\"a\"})\n// []foo{foo{\"a\"}, foo{\"a\"}}\n```\n\n[[play](https://go.dev/play/p/g3uHXbmc3b6)]\n\n### RepeatBy\n\nBuilds a slice with values returned by N calls of callback.\n\n```go\nslice := lo.RepeatBy(0, func (i int) string {\n    return strconv.FormatInt(int64(math.Pow(float64(i), 2)), 10)\n})\n// []string{}\n\nslice := lo.RepeatBy(5, func(i int) string {\n    return strconv.FormatInt(int64(math.Pow(float64(i), 2)), 10)\n})\n// []string{\"0\", \"1\", \"4\", \"9\", \"16\"}\n```\n\n[[play](https://go.dev/play/p/ozZLCtX_hNU)]\n\n### KeyBy\n\nTransforms a slice or an array of structs to a map based on a pivot callback.\n\n```go\nm := lo.KeyBy([]string{\"a\", \"aa\", \"aaa\"}, func(str string) int {\n    return len(str)\n})\n// map[int]string{1: \"a\", 2: \"aa\", 3: \"aaa\"}\n\ntype Character struct {\n  dir  string\n  code int\n}\ncharacters := []Character{\n    {dir: \"left\", code: 97},\n    {dir: \"right\", code: 100},\n}\nresult := lo.KeyBy(characters, func(char Character) string {\n    return string(rune(char.code))\n})\n//map[a:{dir:left code:97} d:{dir:right code:100}]\n```\n\n[[play](https://go.dev/play/p/mdaClUAT-zZ)]\n\n### Associate (alias: SliceToMap)\n\nReturns a map containing key-value pairs provided by transform function applied to elements of the given slice.\nIf any of two pairs would have the same key the last one gets added to the map.\n\nThe order of keys in returned map is not specified and is not guaranteed to be the same from the original array.\n\n```go\nin := []*foo{{baz: \"apple\", bar: 1}, {baz: \"banana\", bar: 2}}\n\naMap := lo.Associate(in, func (f *foo) (string, int) {\n    return f.baz, f.bar\n})\n// map[string][int]{ \"apple\":1, \"banana\":2 }\n```\n\n[[play](https://go.dev/play/p/WHa2CfMO3Lr)]\n\n### Drop\n\nDrops n elements from the beginning of a slice or array.\n\n```go\nl := lo.Drop([]int{0, 1, 2, 3, 4, 5}, 2)\n// []int{2, 3, 4, 5}\n```\n\n[[play](https://go.dev/play/p/JswS7vXRJP2)]\n\n### DropRight\n\nDrops n elements from the end of a slice or array.\n\n```go\nl := lo.DropRight([]int{0, 1, 2, 3, 4, 5}, 2)\n// []int{0, 1, 2, 3}\n```\n\n[[play](https://go.dev/play/p/GG0nXkSJJa3)]\n\n### DropWhile\n\nDrop elements from the beginning of a slice or array while the predicate returns true.\n\n```go\nl := lo.DropWhile([]string{\"a\", \"aa\", \"aaa\", \"aa\", \"aa\"}, func(val string) bool {\n    return len(val) <= 2\n})\n// []string{\"aaa\", \"aa\", \"aa\"}\n```\n\n[[play](https://go.dev/play/p/7gBPYw2IK16)]\n\n### DropRightWhile\n\nDrop elements from the end of a slice or array while the predicate returns true.\n\n```go\nl := lo.DropRightWhile([]string{\"a\", \"aa\", \"aaa\", \"aa\", \"aa\"}, func(val string) bool {\n    return len(val) <= 2\n})\n// []string{\"a\", \"aa\", \"aaa\"}\n```\n\n[[play](https://go.dev/play/p/3-n71oEC0Hz)]\n\n### DropByIndex\n\nDrops elements from a slice or array by the index. A negative index will drop elements from the end of the slice.\n\n```go\nl := lo.DropByIndex([]int{0, 1, 2, 3, 4, 5}, 2, 4, -1)\n// []int{0, 1, 3}\n```\n\n[[play](https://go.dev/play/p/JswS7vXRJP2)]\n\n\n### Reject\n\nThe opposite of Filter, this method returns the elements of collection that predicate does not return truthy for.\n\n```go\nodd := lo.Reject([]int{1, 2, 3, 4}, func(x int, _ int) bool {\n    return x%2 == 0\n})\n// []int{1, 3}\n```\n\n[[play](https://go.dev/play/p/YkLMODy1WEL)]\n\n### RejectMap\n\nThe opposite of FilterMap, this method returns a slice which obtained after both filtering and mapping using the given callback function.\n\nThe callback function should return two values:\n- the result of the mapping operation and\n- whether the result element should be included or not.\n\n```go\nitems := lo.RejectMap([]int{1, 2, 3, 4}, func(x int, _ int) (int, bool) {\n    return x*10, x%2 == 0\n})\n// []int{10, 30}\n```\n\n### FilterReject\n\nMixes Filter and Reject, this method returns two slices, one for the elements of collection that predicate returns truthy for and one for the elements that predicate does not return truthy for.\n\n```go\nkept, rejected := lo.FilterReject([]int{1, 2, 3, 4}, func(x int, _ int) bool {\n    return x%2 == 0\n})\n// []int{2, 4}\n// []int{1, 3}\n```\n\n### Count\n\nCounts the number of elements in the collection that compare equal to value.\n\n```go\ncount := lo.Count([]int{1, 5, 1}, 1)\n// 2\n```\n\n[[play](https://go.dev/play/p/Y3FlK54yveC)]\n\n### CountBy\n\nCounts the number of elements in the collection for which predicate is true.\n\n```go\ncount := lo.CountBy([]int{1, 5, 1}, func(i int) bool {\n    return i < 4\n})\n// 2\n```\n\n[[play](https://go.dev/play/p/ByQbNYQQi4X)]\n\n### CountValues\n\nCounts the number of each element in the collection.\n\n```go\nlo.CountValues([]int{})\n// map[int]int{}\n\nlo.CountValues([]int{1, 2})\n// map[int]int{1: 1, 2: 1}\n\nlo.CountValues([]int{1, 2, 2})\n// map[int]int{1: 1, 2: 2}\n\nlo.CountValues([]string{\"foo\", \"bar\", \"\"})\n// map[string]int{\"\": 1, \"foo\": 1, \"bar\": 1}\n\nlo.CountValues([]string{\"foo\", \"bar\", \"bar\"})\n// map[string]int{\"foo\": 1, \"bar\": 2}\n```\n\n[[play](https://go.dev/play/p/-p-PyLT4dfy)]\n\n### CountValuesBy\n\nCounts the number of each element in the collection. It ss equivalent to chaining lo.Map and lo.CountValues.\n\n```go\nisEven := func(v int) bool {\n    return v%2==0\n}\n\nlo.CountValuesBy([]int{}, isEven)\n// map[bool]int{}\n\nlo.CountValuesBy([]int{1, 2}, isEven)\n// map[bool]int{false: 1, true: 1}\n\nlo.CountValuesBy([]int{1, 2, 2}, isEven)\n// map[bool]int{false: 1, true: 2}\n\nlength := func(v string) int {\n    return len(v)\n}\n\nlo.CountValuesBy([]string{\"foo\", \"bar\", \"\"}, length)\n// map[int]int{0: 1, 3: 2}\n\nlo.CountValuesBy([]string{\"foo\", \"bar\", \"bar\"}, length)\n// map[int]int{3: 3}\n```\n\n[[play](https://go.dev/play/p/2U0dG1SnOmS)]\n\n### Subset\n\nReturns a copy of a slice from `offset` up to `length` elements. Like `slice[start:start+length]`, but does not panic on overflow.\n\n```go\nin := []int{0, 1, 2, 3, 4}\n\nsub := lo.Subset(in, 2, 3)\n// []int{2, 3, 4}\n\nsub := lo.Subset(in, -4, 3)\n// []int{1, 2, 3}\n\nsub := lo.Subset(in, -2, math.MaxUint)\n// []int{3, 4}\n```\n\n[[play](https://go.dev/play/p/tOQu1GhFcog)]\n\n### Slice\n\nReturns a copy of a slice from `start` up to, but not including `end`. Like `slice[start:end]`, but does not panic on overflow.\n\n```go\nin := []int{0, 1, 2, 3, 4}\n\nslice := lo.Slice(in, 0, 5)\n// []int{0, 1, 2, 3, 4}\n\nslice := lo.Slice(in, 2, 3)\n// []int{2}\n\nslice := lo.Slice(in, 2, 6)\n// []int{2, 3, 4}\n\nslice := lo.Slice(in, 4, 3)\n// []int{}\n```\n\n[[play](https://go.dev/play/p/8XWYhfMMA1h)]\n\n### Replace\n\nReturns a copy of the slice with the first n non-overlapping instances of old replaced by new.\n\n```go\nin := []int{0, 1, 0, 1, 2, 3, 0}\n\nslice := lo.Replace(in, 0, 42, 1)\n// []int{42, 1, 0, 1, 2, 3, 0}\n\nslice := lo.Replace(in, -1, 42, 1)\n// []int{0, 1, 0, 1, 2, 3, 0}\n\nslice := lo.Replace(in, 0, 42, 2)\n// []int{42, 1, 42, 1, 2, 3, 0}\n\nslice := lo.Replace(in, 0, 42, -1)\n// []int{42, 1, 42, 1, 2, 3, 42}\n```\n\n[[play](https://go.dev/play/p/XfPzmf9gql6)]\n\n### ReplaceAll\n\nReturns a copy of the slice with all non-overlapping instances of old replaced by new.\n\n```go\nin := []int{0, 1, 0, 1, 2, 3, 0}\n\nslice := lo.ReplaceAll(in, 0, 42)\n// []int{42, 1, 42, 1, 2, 3, 42}\n\nslice := lo.ReplaceAll(in, -1, 42)\n// []int{0, 1, 0, 1, 2, 3, 0}\n```\n\n[[play](https://go.dev/play/p/a9xZFUHfYcV)]\n\n### Compact\n\nReturns a slice of all non-zero elements.\n\n```go\nin := []string{\"\", \"foo\", \"\", \"bar\", \"\"}\n\nslice := lo.Compact(in)\n// []string{\"foo\", \"bar\"}\n```\n\n[[play](https://go.dev/play/p/tXiy-iK6PAc)]\n\n### IsSorted\n\nChecks if a slice is sorted.\n\n```go\nslice := lo.IsSorted([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9})\n// true\n```\n\n[[play](https://go.dev/play/p/mc3qR-t4mcx)]\n\n### IsSortedByKey\n\nChecks if a slice is sorted by iteratee.\n\n```go\nslice := lo.IsSortedByKey([]string{\"a\", \"bb\", \"ccc\"}, func(s string) int {\n    return len(s)\n})\n// true\n```\n\n[[play](https://go.dev/play/p/wiG6XyBBu49)]\n\n### Splice\n\nSplice inserts multiple elements at index i. A negative index counts back from the end of the slice. The helper is protected against overflow errors.\n\n```go\nresult := lo.Splice([]string{\"a\", \"b\"}, 1, \"1\", \"2\")\n// []string{\"a\", \"1\", \"2\", \"b\"}\n\n// negative\nresult = lo.Splice([]string{\"a\", \"b\"}, -1, \"1\", \"2\")\n// []string{\"a\", \"1\", \"2\", \"b\"}\n\n// overflow\nresult = lo.Splice([]string{\"a\", \"b\"}, 42, \"1\", \"2\")\n// []string{\"a\", \"b\", \"1\", \"2\"}\n```\n\n[[play](https://go.dev/play/p/G5_GhkeSUBA)]\n\n### Keys\n\nCreates a slice of the map keys.\n\nUse the UniqKeys variant to deduplicate common keys.\n\n```go\nkeys := lo.Keys(map[string]int{\"foo\": 1, \"bar\": 2})\n// []string{\"foo\", \"bar\"}\n\nkeys := lo.Keys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n// []string{\"foo\", \"bar\", \"baz\"}\n\nkeys := lo.Keys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"bar\": 3})\n// []string{\"foo\", \"bar\", \"bar\"}\n```\n\n[[play](https://go.dev/play/p/Uu11fHASqrU)]\n\n### UniqKeys\n\nCreates an array of unique map keys. \n\n```go\nkeys := lo.UniqKeys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n// []string{\"foo\", \"bar\", \"baz\"}\n\nkeys := lo.UniqKeys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"bar\": 3})\n// []string{\"foo\", \"bar\"}\n```\n\n[[play](https://go.dev/play/p/TPKAb6ILdHk)]\n\n### HasKey\n\nReturns whether the given key exists.\n\n```go\nexists := lo.HasKey(map[string]int{\"foo\": 1, \"bar\": 2}, \"foo\")\n// true\n\nexists := lo.HasKey(map[string]int{\"foo\": 1, \"bar\": 2}, \"baz\")\n// false\n```\n\n[[play](https://go.dev/play/p/aVwubIvECqS)]\n\n### Values\n\nCreates an array of the map values.\n\nUse the UniqValues variant to deduplicate common values.\n\n```go\nvalues := lo.Values(map[string]int{\"foo\": 1, \"bar\": 2})\n// []int{1, 2}\n\nvalues := lo.Values(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n// []int{1, 2, 3}\n\nvalues := lo.Values(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"bar\": 2})\n// []int{1, 2, 2}\n```\n\n[[play](https://go.dev/play/p/nnRTQkzQfF6)]\n\n### UniqValues\n\nCreates an array of unique map values.\n\n```go\nvalues := lo.UniqValues(map[string]int{\"foo\": 1, \"bar\": 2})\n// []int{1, 2}\n\nvalues := lo.UniqValues(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n// []int{1, 2, 3}\n\nvalues := lo.UniqValues(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"bar\": 2})\n// []int{1, 2}\n```\n\n[[play](https://go.dev/play/p/nf6bXMh7rM3)]\n\n### ValueOr\n\nReturns the value of the given key or the fallback value if the key is not present.\n\n```go\nvalue := lo.ValueOr(map[string]int{\"foo\": 1, \"bar\": 2}, \"foo\", 42)\n// 1\n\nvalue := lo.ValueOr(map[string]int{\"foo\": 1, \"bar\": 2}, \"baz\", 42)\n// 42\n```\n\n[[play](https://go.dev/play/p/bAq9mHErB4V)]\n\n### PickBy\n\nReturns same map type filtered by given predicate.\n\n```go\nm := lo.PickBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(key string, value int) bool {\n    return value%2 == 1\n})\n// map[string]int{\"foo\": 1, \"baz\": 3}\n```\n\n[[play](https://go.dev/play/p/kdg8GR_QMmf)]\n\n### PickByKeys\n\nReturns same map type filtered by given keys.\n\n```go\nm := lo.PickByKeys(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []string{\"foo\", \"baz\"})\n// map[string]int{\"foo\": 1, \"baz\": 3}\n```\n\n[[play](https://go.dev/play/p/R1imbuci9qU)]\n\n### PickByValues\n\nReturns same map type filtered by given values.\n\n```go\nm := lo.PickByValues(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []int{1, 3})\n// map[string]int{\"foo\": 1, \"baz\": 3}\n```\n\n[[play](https://go.dev/play/p/1zdzSvbfsJc)]\n\n### OmitBy\n\nReturns same map type filtered by given predicate.\n\n```go\nm := lo.OmitBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(key string, value int) bool {\n    return value%2 == 1\n})\n// map[string]int{\"bar\": 2}\n```\n\n[[play](https://go.dev/play/p/EtBsR43bdsd)]\n\n### OmitByKeys\n\nReturns same map type filtered by given keys.\n\n```go\nm := lo.OmitByKeys(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []string{\"foo\", \"baz\"})\n// map[string]int{\"bar\": 2}\n```\n\n[[play](https://go.dev/play/p/t1QjCrs-ysk)]\n\n### OmitByValues\n\nReturns same map type filtered by given values.\n\n```go\nm := lo.OmitByValues(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []int{1, 3})\n// map[string]int{\"bar\": 2}\n```\n\n[[play](https://go.dev/play/p/9UYZi-hrs8j)]\n\n### Entries (alias: ToPairs)\n\nTransforms a map into array of key/value pairs.\n\n```go\nentries := lo.Entries(map[string]int{\"foo\": 1, \"bar\": 2})\n// []lo.Entry[string, int]{\n//     {\n//         Key: \"foo\",\n//         Value: 1,\n//     },\n//     {\n//         Key: \"bar\",\n//         Value: 2,\n//     },\n// }\n```\n\n[[play](https://go.dev/play/p/3Dhgx46gawJ)]\n\n### FromEntries (alias: FromPairs)\n\nTransforms an array of key/value pairs into a map.\n\n```go\nm := lo.FromEntries([]lo.Entry[string, int]{\n    {\n        Key: \"foo\",\n        Value: 1,\n    },\n    {\n        Key: \"bar\",\n        Value: 2,\n    },\n})\n// map[string]int{\"foo\": 1, \"bar\": 2}\n```\n\n[[play](https://go.dev/play/p/oIr5KHFGCEN)]\n\n### Invert\n\nCreates a map composed of the inverted keys and values. If map contains duplicate values, subsequent values overwrite property assignments of previous values.\n\n```go\nm1 := lo.Invert(map[string]int{\"a\": 1, \"b\": 2})\n// map[int]string{1: \"a\", 2: \"b\"}\n\nm2 := lo.Invert(map[string]int{\"a\": 1, \"b\": 2, \"c\": 1})\n// map[int]string{1: \"c\", 2: \"b\"}\n```\n\n[[play](https://go.dev/play/p/rFQ4rak6iA1)]\n\n### Assign\n\nMerges multiple maps from left to right.\n\n```go\nmergedMaps := lo.Assign(\n    map[string]int{\"a\": 1, \"b\": 2},\n    map[string]int{\"b\": 3, \"c\": 4},\n)\n// map[string]int{\"a\": 1, \"b\": 3, \"c\": 4}\n```\n\n[[play](https://go.dev/play/p/VhwfJOyxf5o)]\n\n### MapKeys\n\nManipulates a map keys and transforms it to a map of another type.\n\n```go\nm2 := lo.MapKeys(map[int]int{1: 1, 2: 2, 3: 3, 4: 4}, func(_ int, v int) string {\n    return strconv.FormatInt(int64(v), 10)\n})\n// map[string]int{\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4}\n```\n\n[[play](https://go.dev/play/p/9_4WPIqOetJ)]\n\n### MapValues\n\nManipulates a map values and transforms it to a map of another type.\n\n```go\nm1 := map[int]int64{1: 1, 2: 2, 3: 3}\n\nm2 := lo.MapValues(m1, func(x int64, _ int) string {\n    return strconv.FormatInt(x, 10)\n})\n// map[int]string{1: \"1\", 2: \"2\", 3: \"3\"}\n```\n\n[[play](https://go.dev/play/p/T_8xAfvcf0W)]\n\n### MapEntries\n\nManipulates a map entries and transforms it to a map of another type.\n\n```go\nin := map[string]int{\"foo\": 1, \"bar\": 2}\n\nout := lo.MapEntries(in, func(k string, v int) (int, string) {\n    return v,k\n})\n// map[int]string{1: \"foo\", 2: \"bar\"}\n```\n\n[[play](https://go.dev/play/p/VuvNQzxKimT)]\n\n### MapToSlice\n\nTransforms a map into a slice based on specific iteratee.\n\n```go\nm := map[int]int64{1: 4, 2: 5, 3: 6}\n\ns := lo.MapToSlice(m, func(k int, v int64) string {\n    return fmt.Sprintf(\"%d_%d\", k, v)\n})\n// []string{\"1_4\", \"2_5\", \"3_6\"}\n```\n\n[[play](https://go.dev/play/p/ZuiCZpDt6LD)]\n\n### Range / RangeFrom / RangeWithSteps\n\nCreates an array of numbers (positive and/or negative) progressing from start up to, but not including end.\n\n```go\nresult := lo.Range(4)\n// [0, 1, 2, 3]\n\nresult := lo.Range(-4)\n// [0, -1, -2, -3]\n\nresult := lo.RangeFrom(1, 5)\n// [1, 2, 3, 4, 5]\n\nresult := lo.RangeFrom[float64](1.0, 5)\n// [1.0, 2.0, 3.0, 4.0, 5.0]\n\nresult := lo.RangeWithSteps(0, 20, 5)\n// [0, 5, 10, 15]\n\nresult := lo.RangeWithSteps[float32](-1.0, -4.0, -1.0)\n// [-1.0, -2.0, -3.0]\n\nresult := lo.RangeWithSteps(1, 4, -1)\n// []\n\nresult := lo.Range(0)\n// []\n```\n\n[[play](https://go.dev/play/p/0r6VimXAi9H)]\n\n### Clamp\n\nClamps number within the inclusive lower and upper bounds.\n\n```go\nr1 := lo.Clamp(0, -10, 10)\n// 0\n\nr2 := lo.Clamp(-42, -10, 10)\n// -10\n\nr3 := lo.Clamp(42, -10, 10)\n// 10\n```\n\n[[play](https://go.dev/play/p/RU4lJNC2hlI)]\n\n### Sum\n\nSums the values in a collection.\n\nIf collection is empty 0 is returned.\n\n```go\nlist := []int{1, 2, 3, 4, 5}\nsum := lo.Sum(list)\n// 15\n```\n\n[[play](https://go.dev/play/p/upfeJVqs4Bt)]\n\n### SumBy\n\nSummarizes the values in a collection using the given return value from the iteration function.\n\nIf collection is empty 0 is returned.\n\n```go\nstrings := []string{\"foo\", \"bar\"}\nsum := lo.SumBy(strings, func(item string) int {\n    return len(item)\n})\n// 6\n```\n\n[[play](https://go.dev/play/p/Dz_a_7jN_ca)]\n\n### Mean\n\nCalculates the mean of a collection of numbers.\n\nIf collection is empty 0 is returned.\n\n```go\nmean := lo.Mean([]int{2, 3, 4, 5})\n// 3\n\nmean := lo.Mean([]float64{2, 3, 4, 5})\n// 3.5\n\nmean := lo.Mean([]float64{})\n// 0\n```\n\n### MeanBy\n\nCalculates the mean of a collection of numbers using the given return value from the iteration function.\n\nIf collection is empty 0 is returned.\n\n```go\nlist := []string{\"aa\", \"bbb\", \"cccc\", \"ddddd\"}\nmapper := func(item string) float64 {\n    return float64(len(item))\n}\n\nmean := lo.MeanBy(list, mapper)\n// 3.5\n\nmean := lo.MeanBy([]float64{}, mapper)\n// 0\n```\n\n### RandomString\n\nReturns a random string of the specified length and made of the specified charset.\n\n```go\nstr := lo.RandomString(5, lo.LettersCharset)\n// example: \"eIGbt\"\n```\n\n[[play](https://go.dev/play/p/rRseOQVVum4)]\n\n### Substring\n\nReturn part of a string.\n\n```go\nsub := lo.Substring(\"hello\", 2, 3)\n// \"llo\"\n\nsub := lo.Substring(\"hello\", -4, 3)\n// \"ell\"\n\nsub := lo.Substring(\"hello\", -2, math.MaxUint)\n// \"lo\"\n```\n\n[[play](https://go.dev/play/p/TQlxQi82Lu1)]\n\n### ChunkString\n\nReturns an array of strings split into groups the length of size. If array can't be split evenly, the final chunk will be the remaining elements.\n\n```go\nlo.ChunkString(\"123456\", 2)\n// []string{\"12\", \"34\", \"56\"}\n\nlo.ChunkString(\"1234567\", 2)\n// []string{\"12\", \"34\", \"56\", \"7\"}\n\nlo.ChunkString(\"\", 2)\n// []string{\"\"}\n\nlo.ChunkString(\"1\", 2)\n// []string{\"1\"}\n```\n\n[[play](https://go.dev/play/p/__FLTuJVz54)]\n\n### RuneLength\n\nAn alias to utf8.RuneCountInString which returns the number of runes in string.\n\n```go\nsub := lo.RuneLength(\"hellô\")\n// 5\n\nsub := len(\"hellô\")\n// 6\n```\n\n[[play](https://go.dev/play/p/tuhgW_lWY8l)]\n\n### PascalCase\n\nConverts string to pascal case.\n\n```go\nstr := lo.PascalCase(\"hello_world\")\n// HelloWorld\n```\n\n[[play](https://go.dev/play/p/iZkdeLP9oiB)]\n\n### CamelCase\n\nConverts string to camel case.\n\n```go\nstr := lo.CamelCase(\"hello_world\")\n// helloWorld\n```\n\n[[play](https://go.dev/play/p/dtyFB58MBRp)]\n\n### KebabCase\n\nConverts string to kebab case.\n\n```go\nstr := lo.KebabCase(\"helloWorld\")\n// hello-world\n```\n\n[[play](https://go.dev/play/p/2YTuPafwECA)]\n\n### SnakeCase\n\nConverts string to snake case.\n\n```go\nstr := lo.SnakeCase(\"HelloWorld\")\n// hello_world\n```\n\n[[play](https://go.dev/play/p/QVKJG9nOnDg)]\n\n### Words\n\nSplits string into an array of its words.\n\n```go\nstr := lo.Words(\"helloWorld\")\n// []string{\"hello\", \"world\"}\n```\n\n[[play](https://go.dev/play/p/2P4zhqqq61g)]\n\n### Capitalize\n\nConverts the first character of string to upper case and the remaining to lower case.\n\n```go\nstr := lo.Capitalize(\"heLLO\")\n// Hello\n```\n\n### Ellipsis\n\nTrims and truncates a string to a specified length and appends an ellipsis if truncated.\n\n```go\nstr := lo.Ellipsis(\"  Lorem Ipsum  \", 5)\n// Lo...\n\nstr := lo.Ellipsis(\"Lorem Ipsum\", 100)\n// Lorem Ipsum\n\nstr := lo.Ellipsis(\"Lorem Ipsum\", 3)\n// ...\n```\n\n### T2 -> T9\n\nCreates a tuple from a list of values.\n\n```go\ntuple1 := lo.T2(\"x\", 1)\n// Tuple2[string, int]{A: \"x\", B: 1}\n\nfunc example() (string, int) { return \"y\", 2 }\ntuple2 := lo.T2(example())\n// Tuple2[string, int]{A: \"y\", B: 2}\n```\n\n[[play](https://go.dev/play/p/IllL3ZO4BQm)]\n\n### Unpack2 -> Unpack9\n\nReturns values contained in tuple.\n\n```go\nr1, r2 := lo.Unpack2(lo.Tuple2[string, int]{\"a\", 1})\n// \"a\", 1\n```\n\nUnpack is also available as a method of TupleX.\n\n```go\ntuple2 := lo.T2(\"a\", 1)\na, b := tuple2.Unpack()\n// \"a\", 1\n```\n\n[[play](https://go.dev/play/p/xVP_k0kJ96W)]\n\n### Zip2 -> Zip9\n\nZip creates a slice of grouped elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n\nWhen collections have different size, the Tuple attributes are filled with zero value.\n\n```go\ntuples := lo.Zip2([]string{\"a\", \"b\"}, []int{1, 2})\n// []Tuple2[string, int]{{A: \"a\", B: 1}, {A: \"b\", B: 2}}\n```\n\n[[play](https://go.dev/play/p/jujaA6GaJTp)]\n\n### ZipBy2 -> ZipBy9\n\nZipBy creates a slice of transformed elements, the first of which contains the first elements of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n\nWhen collections have different size, the Tuple attributes are filled with zero value.\n\n```go\nitems := lo.ZipBy2([]string{\"a\", \"b\"}, []int{1, 2}, func(a string, b int) string {\n    return fmt.Sprintf(\"%s-%d\", a, b)\n})\n// []string{\"a-1\", \"b-2\"}\n```\n\n### Unzip2 -> Unzip9\n\nUnzip accepts an array of grouped elements and creates an array regrouping the elements to their pre-zip configuration.\n\n```go\na, b := lo.Unzip2([]Tuple2[string, int]{{A: \"a\", B: 1}, {A: \"b\", B: 2}})\n// []string{\"a\", \"b\"}\n// []int{1, 2}\n```\n\n[[play](https://go.dev/play/p/ciHugugvaAW)]\n\n### UnzipBy2 -> UnzipBy9\n\nUnzipBy2 iterates over a collection and creates an array regrouping the elements to their pre-zip configuration.\n\n```go\na, b := lo.UnzipBy2([]string{\"hello\", \"john\", \"doe\"}, func(str string) (string, int) {\n    return str, len(str)\n})\n// []string{\"hello\", \"john\", \"doe\"}\n// []int{5, 4, 3}\n```\n\n### Duration\n\nReturns the time taken to execute a function.\n\n```go\nduration := lo.Duration(func() {\n    // very long job\n})\n// 3s\n```\n\n### Duration0 -> Duration10\n\nReturns the time taken to execute a function.\n\n```go\nduration := lo.Duration0(func() {\n    // very long job\n})\n// 3s\n\nerr, duration := lo.Duration1(func() error {\n    // very long job\n    return fmt.Errorf(\"an error\")\n})\n// an error\n// 3s\n\nstr, nbr, err, duration := lo.Duration3(func() (string, int, error) {\n    // very long job\n    return \"hello\", 42, nil\n})\n// hello\n// 42\n// nil\n// 3s\n```\n\n### ChannelDispatcher\n\nDistributes messages from input channels into N child channels. Close events are propagated to children.\n\nUnderlying channels can have a fixed buffer capacity or be unbuffered when cap is 0.\n\n```go\nch := make(chan int, 42)\nfor i := 0; i <= 10; i++ {\n    ch <- i\n}\n\nchildren := lo.ChannelDispatcher(ch, 5, 10, DispatchingStrategyRoundRobin[int])\n// []<-chan int{...}\n\nconsumer := func(c <-chan int) {\n    for {\n        msg, ok := <-c\n        if !ok {\n            println(\"closed\")\n\n            break\n        }\n\n        println(msg)\n    }\n}\n\nfor i := range children {\n    go consumer(children[i])\n}\n```\n\nMany distributions strategies are available:\n\n- [lo.DispatchingStrategyRoundRobin](./channel.go): Distributes messages in a rotating sequential manner.\n- [lo.DispatchingStrategyRandom](./channel.go): Distributes messages in a random manner.\n- [lo.DispatchingStrategyWeightedRandom](./channel.go): Distributes messages in a weighted manner.\n- [lo.DispatchingStrategyFirst](./channel.go): Distributes messages in the first non-full channel.\n- [lo.DispatchingStrategyLeast](./channel.go): Distributes messages in the emptiest channel.\n- [lo.DispatchingStrategyMost](./channel.go): Distributes to the fullest channel.\n\nSome strategies bring fallback, in order to favor non-blocking behaviors. See implementations.\n\nFor custom strategies, just implement the `lo.DispatchingStrategy` prototype:\n\n```go\ntype DispatchingStrategy[T any] func(message T, messageIndex uint64, channels []<-chan T) int\n```\n\nEg:\n\n```go\ntype Message struct {\n    TenantID uuid.UUID\n}\n\nfunc hash(id uuid.UUID) int {\n    h := fnv.New32a()\n    h.Write([]byte(id.String()))\n    return int(h.Sum32())\n}\n\n// Routes messages per TenantID.\ncustomStrategy := func(message string, messageIndex uint64, channels []<-chan string) int {\n    destination := hash(message) % len(channels)\n\n    // check if channel is full\n    if len(channels[destination]) < cap(channels[destination]) {\n        return destination\n    }\n\n    // fallback when child channel is full\n    return utils.DispatchingStrategyRoundRobin(message, uint64(destination), channels)\n}\n\nchildren := lo.ChannelDispatcher(ch, 5, 10, customStrategy)\n...\n```\n\n### SliceToChannel\n\nReturns a read-only channels of collection elements. Channel is closed after last element. Channel capacity can be customized.\n\n```go\nlist := []int{1, 2, 3, 4, 5}\n\nfor v := range lo.SliceToChannel(2, list) {\n    println(v)\n}\n// prints 1, then 2, then 3, then 4, then 5\n```\n\n### ChannelToSlice\n\nReturns a slice built from channels items. Blocks until channel closes.\n\n```go\nlist := []int{1, 2, 3, 4, 5}\nch := lo.SliceToChannel(2, list)\n\nitems := ChannelToSlice(ch)\n// []int{1, 2, 3, 4, 5}\n```\n\n### Generator\n\nImplements the generator design pattern. Channel is closed after last element. Channel capacity can be customized.\n\n```go\ngenerator := func(yield func(int)) {\n    yield(1)\n    yield(2)\n    yield(3)\n}\n\nfor v := range lo.Generator(2, generator) {\n    println(v)\n}\n// prints 1, then 2, then 3\n```\n\n### Buffer\n\nCreates a slice of n elements from a channel. Returns the slice, the slice length, the read time and the channel status (opened/closed).\n\n```go\nch := lo.SliceToChannel(2, []int{1, 2, 3, 4, 5})\n\nitems1, length1, duration1, ok1 := lo.Buffer(ch, 3)\n// []int{1, 2, 3}, 3, 0s, true\nitems2, length2, duration2, ok2 := lo.Buffer(ch, 3)\n// []int{4, 5}, 2, 0s, false\n```\n\nExample: RabbitMQ consumer 👇\n\n```go\nch := readFromQueue()\n\nfor {\n    // read 1k items\n    items, length, _, ok := lo.Buffer(ch, 1000)\n\n    // do batching stuff\n\n    if !ok {\n        break\n    }\n}\n```\n\n### BufferWithTimeout\n\nCreates a slice of n elements from a channel, with timeout. Returns the slice, the slice length, the read time and the channel status (opened/closed).\n\n```go\ngenerator := func(yield func(int)) {\n    for i := 0; i < 5; i++ {\n        yield(i)\n        time.Sleep(35*time.Millisecond)\n    }\n}\n\nch := lo.Generator(0, generator)\n\nitems1, length1, duration1, ok1 := lo.BufferWithTimeout(ch, 3, 100*time.Millisecond)\n// []int{1, 2}, 2, 100ms, true\nitems2, length2, duration2, ok2 := lo.BufferWithTimeout(ch, 3, 100*time.Millisecond)\n// []int{3, 4, 5}, 3, 75ms, true\nitems3, length3, duration2, ok3 := lo.BufferWithTimeout(ch, 3, 100*time.Millisecond)\n// []int{}, 0, 10ms, false\n```\n\nExample: RabbitMQ consumer 👇\n\n```go\nch := readFromQueue()\n\nfor {\n    // read 1k items\n    // wait up to 1 second\n    items, length, _, ok := lo.BufferWithTimeout(ch, 1000, 1*time.Second)\n\n    // do batching stuff\n\n    if !ok {\n        break\n    }\n}\n```\n\nExample: Multithreaded RabbitMQ consumer 👇\n\n```go\nch := readFromQueue()\n\n// 5 workers\n// prefetch 1k messages per worker\nchildren := lo.ChannelDispatcher(ch, 5, 1000, lo.DispatchingStrategyFirst[int])\n\nconsumer := func(c <-chan int) {\n    for {\n        // read 1k items\n        // wait up to 1 second\n        items, length, _, ok := lo.BufferWithTimeout(ch, 1000, 1*time.Second)\n\n        // do batching stuff\n\n        if !ok {\n            break\n        }\n    }\n}\n\nfor i := range children {\n    go consumer(children[i])\n}\n```\n\n### FanIn\n\nMerge messages from multiple input channels into a single buffered channel. Output messages has no priority. When all upstream channels reach EOF, downstream channel closes.\n\n```go\nstream1 := make(chan int, 42)\nstream2 := make(chan int, 42)\nstream3 := make(chan int, 42)\n\nall := lo.FanIn(100, stream1, stream2, stream3)\n// <-chan int\n```\n\n### FanOut\n\nBroadcasts all the upstream messages to multiple downstream channels. When upstream channel reach EOF, downstream channels close. If any downstream channels is full, broadcasting is paused.\n\n```go\nstream := make(chan int, 42)\n\nall := lo.FanOut(5, 100, stream)\n// [5]<-chan int\n```\n\n### Contains\n\nReturns true if an element is present in a collection.\n\n```go\npresent := lo.Contains([]int{0, 1, 2, 3, 4, 5}, 5)\n// true\n```\n\n### ContainsBy\n\nReturns true if the predicate function returns `true`.\n\n```go\npresent := lo.ContainsBy([]int{0, 1, 2, 3, 4, 5}, func(x int) bool {\n    return x == 3\n})\n// true\n```\n\n### Every\n\nReturns true if all elements of a subset are contained into a collection or if the subset is empty.\n\n```go\nok := lo.Every([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})\n// true\n\nok := lo.Every([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})\n// false\n```\n\n### EveryBy\n\nReturns true if the predicate returns true for all elements in the collection or if the collection is empty.\n\n```go\nb := EveryBy([]int{1, 2, 3, 4}, func(x int) bool {\n    return x < 5\n})\n// true\n```\n\n### Some\n\nReturns true if at least 1 element of a subset is contained into a collection.\nIf the subset is empty Some returns false.\n\n```go\nok := lo.Some([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})\n// true\n\nok := lo.Some([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})\n// false\n```\n\n### SomeBy\n\nReturns true if the predicate returns true for any of the elements in the collection.\nIf the collection is empty SomeBy returns false.\n\n```go\nb := SomeBy([]int{1, 2, 3, 4}, func(x int) bool {\n    return x < 3\n})\n// true\n```\n\n### None\n\nReturns true if no element of a subset are contained into a collection or if the subset is empty.\n\n```go\nb := None([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})\n// false\nb := None([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})\n// true\n```\n\n### NoneBy\n\nReturns true if the predicate returns true for none of the elements in the collection or if the collection is empty.\n\n```go\nb := NoneBy([]int{1, 2, 3, 4}, func(x int) bool {\n    return x < 0\n})\n// true\n```\n\n### Intersect\n\nReturns the intersection between two collections.\n\n```go\nresult1 := lo.Intersect([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})\n// []int{0, 2}\n\nresult2 := lo.Intersect([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})\n// []int{0}\n\nresult3 := lo.Intersect([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})\n// []int{}\n```\n\n### Difference\n\nReturns the difference between two collections.\n\n- The first value is the collection of element absent of list2.\n- The second value is the collection of element absent of list1.\n\n```go\nleft, right := lo.Difference([]int{0, 1, 2, 3, 4, 5}, []int{0, 2, 6})\n// []int{1, 3, 4, 5}, []int{6}\n\nleft, right := lo.Difference([]int{0, 1, 2, 3, 4, 5}, []int{0, 1, 2, 3, 4, 5})\n// []int{}, []int{}\n```\n\n### Union\n\nReturns all distinct elements from given collections. Result will not change the order of elements relatively.\n\n```go\nunion := lo.Union([]int{0, 1, 2, 3, 4, 5}, []int{0, 2}, []int{0, 10})\n// []int{0, 1, 2, 3, 4, 5, 10}\n```\n\n### Without\n\nReturns slice excluding all given values.\n\n```go\nsubset := lo.Without([]int{0, 2, 10}, 2)\n// []int{0, 10}\n\nsubset := lo.Without([]int{0, 2, 10}, 0, 1, 2, 3, 4, 5)\n// []int{10}\n```\n\n### WithoutEmpty\n\nReturns slice excluding empty values.\n\n```go\nsubset := lo.WithoutEmpty([]int{0, 2, 10})\n// []int{2, 10}\n```\n\n### IndexOf\n\nReturns the index at which the first occurrence of a value is found in an array or return -1 if the value cannot be found.\n\n```go\nfound := lo.IndexOf([]int{0, 1, 2, 1, 2, 3}, 2)\n// 2\n\nnotFound := lo.IndexOf([]int{0, 1, 2, 1, 2, 3}, 6)\n// -1\n```\n\n### LastIndexOf\n\nReturns the index at which the last occurrence of a value is found in an array or return -1 if the value cannot be found.\n\n```go\nfound := lo.LastIndexOf([]int{0, 1, 2, 1, 2, 3}, 2)\n// 4\n\nnotFound := lo.LastIndexOf([]int{0, 1, 2, 1, 2, 3}, 6)\n// -1\n```\n\n### Find\n\nSearch an element in a slice based on a predicate. It returns element and true if element was found.\n\n```go\nstr, ok := lo.Find([]string{\"a\", \"b\", \"c\", \"d\"}, func(i string) bool {\n    return i == \"b\"\n})\n// \"b\", true\n\nstr, ok := lo.Find([]string{\"foobar\"}, func(i string) bool {\n    return i == \"b\"\n})\n// \"\", false\n```\n\n### FindIndexOf\n\nFindIndexOf searches an element in a slice based on a predicate and returns the index and true. It returns -1 and false if the element is not found.\n\n```go\nstr, index, ok := lo.FindIndexOf([]string{\"a\", \"b\", \"a\", \"b\"}, func(i string) bool {\n    return i == \"b\"\n})\n// \"b\", 1, true\n\nstr, index, ok := lo.FindIndexOf([]string{\"foobar\"}, func(i string) bool {\n    return i == \"b\"\n})\n// \"\", -1, false\n```\n\n### FindLastIndexOf\n\nFindLastIndexOf searches an element in a slice based on a predicate and returns the index and true. It returns -1 and false if the element is not found.\n\n```go\nstr, index, ok := lo.FindLastIndexOf([]string{\"a\", \"b\", \"a\", \"b\"}, func(i string) bool {\n    return i == \"b\"\n})\n// \"b\", 4, true\n\nstr, index, ok := lo.FindLastIndexOf([]string{\"foobar\"}, func(i string) bool {\n    return i == \"b\"\n})\n// \"\", -1, false\n```\n\n### FindOrElse\n\nSearch an element in a slice based on a predicate. It returns the element if found or a given fallback value otherwise.\n\n```go\nstr := lo.FindOrElse([]string{\"a\", \"b\", \"c\", \"d\"}, \"x\", func(i string) bool {\n    return i == \"b\"\n})\n// \"b\"\n\nstr := lo.FindOrElse([]string{\"foobar\"}, \"x\", func(i string) bool {\n    return i == \"b\"\n})\n// \"x\"\n```\n\n### FindKey\n\nReturns the key of the first value matching.\n\n```go\nresult1, ok1 := lo.FindKey(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, 2)\n// \"bar\", true\n\nresult2, ok2 := lo.FindKey(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, 42)\n// \"\", false\n\ntype test struct {\n    foobar string\n}\nresult3, ok3 := lo.FindKey(map[string]test{\"foo\": test{\"foo\"}, \"bar\": test{\"bar\"}, \"baz\": test{\"baz\"}}, test{\"foo\"})\n// \"foo\", true\n```\n\n### FindKeyBy\n\nReturns the key of the first element predicate returns truthy for.\n\n```go\nresult1, ok1 := lo.FindKeyBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(k string, v int) bool {\n    return k == \"foo\"\n})\n// \"foo\", true\n\nresult2, ok2 := lo.FindKeyBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(k string, v int) bool {\n    return false\n})\n// \"\", false\n```\n\n### FindUniques\n\nReturns a slice with all the unique elements of the collection. The order of result values is determined by the order they occur in the array.\n\n```go\nuniqueValues := lo.FindUniques([]int{1, 2, 2, 1, 2, 3})\n// []int{3}\n```\n\n### FindUniquesBy\n\nReturns a slice with all the unique elements of the collection. The order of result values is determined by the order they occur in the array. It accepts `iteratee` which is invoked for each element in array to generate the criterion by which uniqueness is computed.\n\n```go\nuniqueValues := lo.FindUniquesBy([]int{3, 4, 5, 6, 7}, func(i int) int {\n    return i%3\n})\n// []int{5}\n```\n\n### FindDuplicates\n\nReturns a slice with the first occurrence of each duplicated elements of the collection. The order of result values is determined by the order they occur in the array.\n\n```go\nduplicatedValues := lo.FindDuplicates([]int{1, 2, 2, 1, 2, 3})\n// []int{1, 2}\n```\n\n### FindDuplicatesBy\n\nReturns a slice with the first occurrence of each duplicated elements of the collection. The order of result values is determined by the order they occur in the array. It accepts `iteratee` which is invoked for each element in array to generate the criterion by which uniqueness is computed.\n\n```go\nduplicatedValues := lo.FindDuplicatesBy([]int{3, 4, 5, 6, 7}, func(i int) int {\n    return i%3\n})\n// []int{3, 4}\n```\n\n### Min\n\nSearch the minimum value of a collection.\n\nReturns zero value when the collection is empty.\n\n```go\nmin := lo.Min([]int{1, 2, 3})\n// 1\n\nmin := lo.Min([]int{})\n// 0\n\nmin := lo.Min([]time.Duration{time.Second, time.Hour})\n// 1s\n```\n\n### MinBy\n\nSearch the minimum value of a collection using the given comparison function.\n\nIf several values of the collection are equal to the smallest value, returns the first such value.\n\nReturns zero value when the collection is empty.\n\n```go\nmin := lo.MinBy([]string{\"s1\", \"string2\", \"s3\"}, func(item string, min string) bool {\n    return len(item) < len(min)\n})\n// \"s1\"\n\nmin := lo.MinBy([]string{}, func(item string, min string) bool {\n    return len(item) < len(min)\n})\n// \"\"\n```\n\n### Earliest\n\nSearch the minimum time.Time of a collection.\n\nReturns zero value when the collection is empty.\n\n```go\nearliest := lo.Earliest(time.Now(), time.Time{})\n// 0001-01-01 00:00:00 +0000 UTC\n```\n\n### EarliestBy\n\nSearch the minimum time.Time of a collection using the given iteratee function.\n\nReturns zero value when the collection is empty.\n\n```go\ntype foo struct {\n    bar time.Time\n}\n\nearliest := lo.EarliestBy([]foo{{time.Now()}, {}}, func(i foo) time.Time {\n    return i.bar\n})\n// {bar:{2023-04-01 01:02:03 +0000 UTC}}\n```\n\n### Max\n\nSearch the maximum value of a collection.\n\nReturns zero value when the collection is empty.\n\n```go\nmax := lo.Max([]int{1, 2, 3})\n// 3\n\nmax := lo.Max([]int{})\n// 0\n\nmax := lo.Max([]time.Duration{time.Second, time.Hour})\n// 1h\n```\n\n### MaxBy\n\nSearch the maximum value of a collection using the given comparison function.\n\nIf several values of the collection are equal to the greatest value, returns the first such value.\n\nReturns zero value when the collection is empty.\n\n```go\nmax := lo.MaxBy([]string{\"string1\", \"s2\", \"string3\"}, func(item string, max string) bool {\n    return len(item) > len(max)\n})\n// \"string1\"\n\nmax := lo.MaxBy([]string{}, func(item string, max string) bool {\n    return len(item) > len(max)\n})\n// \"\"\n```\n\n### Latest\n\nSearch the maximum time.Time of a collection.\n\nReturns zero value when the collection is empty.\n\n```go\nlatest := lo.Latest([]time.Time{time.Now(), time.Time{}})\n// 2023-04-01 01:02:03 +0000 UTC\n```\n\n### LatestBy\n\nSearch the maximum time.Time of a collection using the given iteratee function.\n\nReturns zero value when the collection is empty.\n\n```go\ntype foo struct {\n    bar time.Time\n}\n\nlatest := lo.LatestBy([]foo{{time.Now()}, {}}, func(i foo) time.Time {\n    return i.bar\n})\n// {bar:{2023-04-01 01:02:03 +0000 UTC}}\n```\n\n### First\n\nReturns the first element of a collection and check for availability of the first element.\n\n```go\nfirst, ok := lo.First([]int{1, 2, 3})\n// 1, true\n\nfirst, ok := lo.First([]int{})\n// 0, false\n```\n\n### FirstOrEmpty\n\nReturns the first element of a collection or zero value if empty.\n\n```go\nfirst := lo.FirstOrEmpty([]int{1, 2, 3})\n// 1\n\nfirst := lo.FirstOrEmpty([]int{})\n// 0\n```\n### FirstOr\n\nReturns the first element of a collection or the fallback value if empty.\n\n```go\nfirst := lo.FirstOr([]int{1, 2, 3}, 245)\n// 1\n\nfirst := lo.FirstOr([]int{}, 31)\n// 31\n```\n\n### Last\n\nReturns the last element of a collection or error if empty.\n\n```go\nlast, ok := lo.Last([]int{1, 2, 3})\n// 3\n// true\n\nlast, ok := lo.Last([]int{})\n// 0\n// false\n```\n\n### LastOrEmpty\n\nReturns the first element of a collection or zero value if empty.\n\n```go\nlast := lo.LastOrEmpty([]int{1, 2, 3})\n// 3\n\nlast := lo.LastOrEmpty([]int{})\n// 0\n```\n### LastOr\n\nReturns the first element of a collection or the fallback value if empty.\n\n```go\nlast := lo.LastOr([]int{1, 2, 3}, 245)\n// 3\n\nlast := lo.LastOr([]int{}, 31)\n// 31\n```\n\n### Nth\n\nReturns the element at index `nth` of collection. If `nth` is negative, the nth element from the end is returned. An error is returned when nth is out of slice bounds.\n\n```go\nnth, err := lo.Nth([]int{0, 1, 2, 3}, 2)\n// 2\n\nnth, err := lo.Nth([]int{0, 1, 2, 3}, -2)\n// 2\n```\n\n### Sample\n\nReturns a random item from collection.\n\n```go\nlo.Sample([]string{\"a\", \"b\", \"c\"})\n// a random string from []string{\"a\", \"b\", \"c\"}\n\nlo.Sample([]string{})\n// \"\"\n```\n\n### Samples\n\nReturns N random unique items from collection.\n\n```go\nlo.Samples([]string{\"a\", \"b\", \"c\"}, 3)\n// []string{\"a\", \"b\", \"c\"} in random order\n```\n\n### Ternary\n\nA 1 line if/else statement.\n\n```go\nresult := lo.Ternary(true, \"a\", \"b\")\n// \"a\"\n\nresult := lo.Ternary(false, \"a\", \"b\")\n// \"b\"\n```\n\n[[play](https://go.dev/play/p/t-D7WBL44h2)]\n\n### TernaryF\n\nA 1 line if/else statement whose options are functions.\n\n```go\nresult := lo.TernaryF(true, func() string { return \"a\" }, func() string { return \"b\" })\n// \"a\"\n\nresult := lo.TernaryF(false, func() string { return \"a\" }, func() string { return \"b\" })\n// \"b\"\n```\n\nUseful to avoid nil-pointer dereferencing in initializations, or avoid running unnecessary code\n\n```go\nvar s *string\n\nsomeStr := TernaryF(s == nil, func() string { return uuid.New().String() }, func() string { return *s })\n// ef782193-c30c-4e2e-a7ae-f8ab5e125e02\n```\n\n[[play](https://go.dev/play/p/AO4VW20JoqM)]\n\n### If / ElseIf / Else\n\n```go\nresult := lo.If(true, 1).\n    ElseIf(false, 2).\n    Else(3)\n// 1\n\nresult := lo.If(false, 1).\n    ElseIf(true, 2).\n    Else(3)\n// 2\n\nresult := lo.If(false, 1).\n    ElseIf(false, 2).\n    Else(3)\n// 3\n```\n\nUsing callbacks:\n\n```go\nresult := lo.IfF(true, func () int {\n        return 1\n    }).\n    ElseIfF(false, func () int {\n        return 2\n    }).\n    ElseF(func () int {\n        return 3\n    })\n// 1\n```\n\nMixed:\n\n```go\nresult := lo.IfF(true, func () int {\n        return 1\n    }).\n    Else(42)\n// 1\n```\n\n[[play](https://go.dev/play/p/WSw3ApMxhyW)]\n\n### Switch / Case / Default\n\n```go\nresult := lo.Switch(1).\n    Case(1, \"1\").\n    Case(2, \"2\").\n    Default(\"3\")\n// \"1\"\n\nresult := lo.Switch(2).\n    Case(1, \"1\").\n    Case(2, \"2\").\n    Default(\"3\")\n// \"2\"\n\nresult := lo.Switch(42).\n    Case(1, \"1\").\n    Case(2, \"2\").\n    Default(\"3\")\n// \"3\"\n```\n\nUsing callbacks:\n\n```go\nresult := lo.Switch(1).\n    CaseF(1, func() string {\n        return \"1\"\n    }).\n    CaseF(2, func() string {\n        return \"2\"\n    }).\n    DefaultF(func() string {\n        return \"3\"\n    })\n// \"1\"\n```\n\nMixed:\n\n```go\nresult := lo.Switch(1).\n    CaseF(1, func() string {\n        return \"1\"\n    }).\n    Default(\"42\")\n// \"1\"\n```\n\n[[play](https://go.dev/play/p/TGbKUMAeRUd)]\n\n### IsNil\n\nChecks if a value is nil or if it's a reference type with a nil underlying value.\n\n```go\nvar x int\nlo.IsNil(x)\n// false\n\nvar k struct{}\nlo.IsNil(k)\n// false\n\nvar i *int\nlo.IsNil(i)\n// true\n\nvar ifaceWithNilValue any = (*string)(nil)\nlo.IsNil(ifaceWithNilValue)\n// true\nifaceWithNilValue == nil\n// false\n```\n\n### ToPtr\n\nReturns a pointer copy of the value.\n\n```go\nptr := lo.ToPtr(\"hello world\")\n// *string{\"hello world\"}\n```\n\n### Nil\n\nReturns a nil pointer of type.\n\n```go\nptr := lo.Nil[float64]()\n// nil\n```\n\n### EmptyableToPtr\n\nReturns a pointer copy of value if it's nonzero.\nOtherwise, returns nil pointer.\n\n```go\nptr := lo.EmptyableToPtr(nil)\n// nil\n\nptr := lo.EmptyableToPtr(\"\")\n// nil\n\nptr := lo.EmptyableToPtr([]int{})\n// *[]int{}\n\nptr := lo.EmptyableToPtr(\"hello world\")\n// *string{\"hello world\"}\n```\n\n### FromPtr\n\nReturns the pointer value or empty.\n\n```go\nstr := \"hello world\"\nvalue := lo.FromPtr(&str)\n// \"hello world\"\n\nvalue := lo.FromPtr(nil)\n// \"\"\n```\n\n### FromPtrOr\n\nReturns the pointer value or the fallback value.\n\n```go\nstr := \"hello world\"\nvalue := lo.FromPtrOr(&str, \"empty\")\n// \"hello world\"\n\nvalue := lo.FromPtrOr(nil, \"empty\")\n// \"empty\"\n```\n\n### ToSlicePtr\n\nReturns a slice of pointer copy of value.\n\n```go\nptr := lo.ToSlicePtr([]string{\"hello\", \"world\"})\n// []*string{\"hello\", \"world\"}\n```\n\n### FromSlicePtr\n\nReturns a slice with the pointer values.\nReturns a zero value in case of a nil pointer element.\n\n```go\nstr1 := \"hello\"\nstr2 := \"world\"\n\nptr := lo.FromSlicePtr[string]([]*string{&str1, &str2, nil})\n// []string{\"hello\", \"world\", \"\"}\n\nptr := lo.Compact(\n    lo.FromSlicePtr[string]([]*string{&str1, &str2, nil}),\n)\n// []string{\"hello\", \"world\"}\n```\n\n### FromSlicePtrOr\n\nReturns a slice with the pointer values or the fallback value.\n\n```go\nstr1 := \"hello\"\nstr2 := \"world\"\n\nptr := lo.FromSlicePtrOr([]*string{&str1, nil, &str2}, \"fallback value\")\n// []string{\"hello\", \"world\", \"fallback value\"}\n```\n\n[[play](https://go.dev/play/p/lbunFvzlUDX)]\n\n### ToAnySlice\n\nReturns a slice with all elements mapped to `any` type.\n\n```go\nelements := lo.ToAnySlice([]int{1, 5, 1})\n// []any{1, 5, 1}\n```\n\n### FromAnySlice\n\nReturns an `any` slice with all elements mapped to a type. Returns false in case of type conversion failure.\n\n```go\nelements, ok := lo.FromAnySlice([]any{\"foobar\", 42})\n// []string{}, false\n\nelements, ok := lo.FromAnySlice([]any{\"foobar\", \"42\"})\n// []string{\"foobar\", \"42\"}, true\n```\n\n### Empty\n\nReturns an empty value.\n\n```go\nlo.Empty[int]()\n// 0\nlo.Empty[string]()\n// \"\"\nlo.Empty[bool]()\n// false\n```\n\n### IsEmpty\n\nReturns true if argument is a zero value.\n\n```go\nlo.IsEmpty(0)\n// true\nlo.IsEmpty(42)\n// false\n\nlo.IsEmpty(\"\")\n// true\nlo.IsEmpty(\"foobar\")\n// false\n\ntype test struct {\n    foobar string\n}\n\nlo.IsEmpty(test{foobar: \"\"})\n// true\nlo.IsEmpty(test{foobar: \"foobar\"})\n// false\n```\n\n### IsNotEmpty\n\nReturns true if argument is a zero value.\n\n```go\nlo.IsNotEmpty(0)\n// false\nlo.IsNotEmpty(42)\n// true\n\nlo.IsNotEmpty(\"\")\n// false\nlo.IsNotEmpty(\"foobar\")\n// true\n\ntype test struct {\n    foobar string\n}\n\nlo.IsNotEmpty(test{foobar: \"\"})\n// false\nlo.IsNotEmpty(test{foobar: \"foobar\"})\n// true\n```\n\n### Coalesce\n\nReturns the first non-empty arguments. Arguments must be comparable.\n\n```go\nresult, ok := lo.Coalesce(0, 1, 2, 3)\n// 1 true\n\nresult, ok := lo.Coalesce(\"\")\n// \"\" false\n\nvar nilStr *string\nstr := \"foobar\"\nresult, ok := lo.Coalesce(nil, nilStr, &str)\n// &\"foobar\" true\n```\n\n### CoalesceOrEmpty\n\nReturns the first non-empty arguments. Arguments must be comparable.\n\n```go\nresult := lo.CoalesceOrEmpty(0, 1, 2, 3)\n// 1\n\nresult := lo.CoalesceOrEmpty(\"\")\n// \"\"\n\nvar nilStr *string\nstr := \"foobar\"\nresult := lo.CoalesceOrEmpty(nil, nilStr, &str)\n// &\"foobar\"\n```\n\n### Partial\n\nReturns new function that, when called, has its first argument set to the provided value.\n\n```go\nadd := func(x, y int) int { return x + y }\nf := lo.Partial(add, 5)\n\nf(10)\n// 15\n\nf(42)\n// 47\n```\n\n### Partial2 -> Partial5\n\nReturns new function that, when called, has its first argument set to the provided value.\n\n```go\nadd := func(x, y, z int) int { return x + y + z }\nf := lo.Partial2(add, 42)\n\nf(10, 5)\n// 57\n\nf(42, -4)\n// 80\n```\n\n### Attempt\n\nInvokes a function N times until it returns valid output. Returns either the caught error or nil.\n\nWhen the first argument is less than `1`, the function runs until a successful response is returned.\n\n```go\niter, err := lo.Attempt(42, func(i int) error {\n    if i == 5 {\n        return nil\n    }\n\n    return fmt.Errorf(\"failed\")\n})\n// 6\n// nil\n\niter, err := lo.Attempt(2, func(i int) error {\n    if i == 5 {\n        return nil\n    }\n\n    return fmt.Errorf(\"failed\")\n})\n// 2\n// error \"failed\"\n\niter, err := lo.Attempt(0, func(i int) error {\n    if i < 42 {\n        return fmt.Errorf(\"failed\")\n    }\n\n    return nil\n})\n// 43\n// nil\n```\n\nFor more advanced retry strategies (delay, exponential backoff...), please take a look on [cenkalti/backoff](https://github.com/cenkalti/backoff).\n\n[[play](https://go.dev/play/p/3ggJZ2ZKcMj)]\n\n### AttemptWithDelay\n\nInvokes a function N times until it returns valid output, with a pause between each call. Returns either the caught error or nil.\n\nWhen the first argument is less than `1`, the function runs until a successful response is returned.\n\n```go\niter, duration, err := lo.AttemptWithDelay(5, 2*time.Second, func(i int, duration time.Duration) error {\n    if i == 2 {\n        return nil\n    }\n\n    return fmt.Errorf(\"failed\")\n})\n// 3\n// ~ 4 seconds\n// nil\n```\n\nFor more advanced retry strategies (delay, exponential backoff...), please take a look on [cenkalti/backoff](https://github.com/cenkalti/backoff).\n\n[[play](https://go.dev/play/p/tVs6CygC7m1)]\n\n### AttemptWhile\n\nInvokes a function N times until it returns valid output. Returns either the caught error or nil, along with a bool value to determine whether the function should be invoked again. It will terminate the invoke immediately if the second return value is false.\n\nWhen the first argument is less than `1`, the function runs until a successful response is returned.\n\n```go\ncount1, err1 := lo.AttemptWhile(5, func(i int) (error, bool) {\n    err := doMockedHTTPRequest(i)\n    if err != nil {\n        if errors.Is(err, ErrBadRequest) { // lets assume ErrBadRequest is a critical error that needs to terminate the invoke\n            return err, false // flag the second return value as false to terminate the invoke\n        }\n\n        return err, true\n    }\n\n    return nil, false\n})\n```\n\nFor more advanced retry strategies (delay, exponential backoff...), please take a look on [cenkalti/backoff](https://github.com/cenkalti/backoff).\n\n[[play](https://go.dev/play/p/M2wVq24PaZM)]\n\n### AttemptWhileWithDelay\n\nInvokes a function N times until it returns valid output, with a pause between each call. Returns either the caught error or nil, along with a bool value to determine whether the function should be invoked again. It will terminate the invoke immediately if the second return value is false.\n\nWhen the first argument is less than `1`, the function runs until a successful response is returned.\n\n```go\ncount1, time1, err1 := lo.AttemptWhileWithDelay(5, time.Millisecond, func(i int, d time.Duration) (error, bool) {\n    err := doMockedHTTPRequest(i)\n    if err != nil {\n        if errors.Is(err, ErrBadRequest) { // lets assume ErrBadRequest is a critical error that needs to terminate the invoke\n            return err, false // flag the second return value as false to terminate the invoke\n        }\n\n        return err, true\n    }\n\n    return nil, false\n})\n```\n\nFor more advanced retry strategies (delay, exponential backoff...), please take a look on [cenkalti/backoff](https://github.com/cenkalti/backoff).\n\n[[play](https://go.dev/play/p/cfcmhvLO-nv)]\n\n### Debounce\n\n`NewDebounce` creates a debounced instance that delays invoking functions given until after wait milliseconds have elapsed, until `cancel` is called.\n\n```go\nf := func() {\n    println(\"Called once after 100ms when debounce stopped invoking!\")\n}\n\ndebounce, cancel := lo.NewDebounce(100 * time.Millisecond, f)\nfor j := 0; j < 10; j++ {\n    debounce()\n}\n\ntime.Sleep(1 * time.Second)\ncancel()\n```\n\n[[play](https://go.dev/play/p/mz32VMK2nqe)]\n\n### DebounceBy\n\n`NewDebounceBy` creates a debounced instance for each distinct key, that delays invoking functions given until after wait milliseconds have elapsed, until `cancel` is called.\n\n```go\nf := func(key string, count int) {\n    println(key + \": Called once after 100ms when debounce stopped invoking!\")\n}\n\ndebounce, cancel := lo.NewDebounceBy(100 * time.Millisecond, f)\nfor j := 0; j < 10; j++ {\n    debounce(\"first key\")\n    debounce(\"second key\")\n}\n\ntime.Sleep(1 * time.Second)\ncancel(\"first key\")\ncancel(\"second key\")\n```\n\n[[play](https://go.dev/play/p/d3Vpt6pxhY8)]\n\n### Synchronize\n\nWraps the underlying callback in a mutex. It receives an optional mutex.\n\n```go\ns := lo.Synchronize()\n\nfor i := 0; i < 10; i++ {\n    go s.Do(func () {\n        println(\"will be called sequentially\")\n    })\n}\n```\n\nIt is equivalent to:\n\n```go\nmu := sync.Mutex{}\n\nfunc foobar() {\n    mu.Lock()\n    defer mu.Unlock()\n\n    // ...\n}\n```\n\n### Async\n\nExecutes a function in a goroutine and returns the result in a channel.\n\n```go\nch := lo.Async(func() error { time.Sleep(10 * time.Second); return nil })\n// chan error (nil)\n```\n\n### Async{0->6}\n\nExecutes a function in a goroutine and returns the result in a channel.\nFor function with multiple return values, the results will be returned as a tuple inside the channel.\nFor function without return, struct{} will be returned in the channel.\n\n```go\nch := lo.Async0(func() { time.Sleep(10 * time.Second) })\n// chan struct{}\n\nch := lo.Async1(func() int {\n  time.Sleep(10 * time.Second);\n  return 42\n})\n// chan int (42)\n\nch := lo.Async2(func() (int, string) {\n  time.Sleep(10 * time.Second);\n  return 42, \"Hello\"\n})\n// chan lo.Tuple2[int, string] ({42, \"Hello\"})\n```\n\n### Transaction\n\nImplements a Saga pattern.\n\n```go\ntransaction := NewTransaction().\n    Then(\n        func(state int) (int, error) {\n            fmt.Println(\"step 1\")\n            return state + 10, nil\n        },\n        func(state int) int {\n            fmt.Println(\"rollback 1\")\n            return state - 10\n        },\n    ).\n    Then(\n        func(state int) (int, error) {\n            fmt.Println(\"step 2\")\n            return state + 15, nil\n        },\n        func(state int) int {\n            fmt.Println(\"rollback 2\")\n            return state - 15\n        },\n    ).\n    Then(\n        func(state int) (int, error) {\n            fmt.Println(\"step 3\")\n\n            if true {\n                return state, fmt.Errorf(\"error\")\n            }\n\n            return state + 42, nil\n        },\n        func(state int) int {\n            fmt.Println(\"rollback 3\")\n            return state - 42\n        },\n    )\n\n_, _ = transaction.Process(-5)\n\n// Output:\n// step 1\n// step 2\n// step 3\n// rollback 2\n// rollback 1\n```\n\n### WaitFor\n\nRuns periodically until a condition is validated.\n\n```go\nalwaysTrue := func(i int) bool { return true }\nalwaysFalse := func(i int) bool { return false }\nlaterTrue := func(i int) bool {\n    return i > 5\n}\n\niterations, duration, ok := lo.WaitFor(alwaysTrue, 10*time.Millisecond, 2 * time.Millisecond)\n// 1\n// 1ms\n// true\n\niterations, duration, ok := lo.WaitFor(alwaysFalse, 10*time.Millisecond, time.Millisecond)\n// 10\n// 10ms\n// false\n\niterations, duration, ok := lo.WaitFor(laterTrue, 10*time.Millisecond, time.Millisecond)\n// 7\n// 7ms\n// true\n\niterations, duration, ok := lo.WaitFor(laterTrue, 10*time.Millisecond, 5*time.Millisecond)\n// 2\n// 10ms\n// false\n```\n\n\n### WaitForWithContext\n\nRuns periodically until a condition is validated or context is invalid.\n\nThe condition receives also the context, so it can invalidate the process in the condition checker\n\n```go\nctx := context.Background()\n\nalwaysTrue := func(_ context.Context, i int) bool { return true }\nalwaysFalse := func(_ context.Context, i int) bool { return false }\nlaterTrue := func(_ context.Context, i int) bool {\n    return i >= 5\n}\n\niterations, duration, ok := lo.WaitForWithContext(ctx, alwaysTrue, 10*time.Millisecond, 2 * time.Millisecond)\n// 1\n// 1ms\n// true\n\niterations, duration, ok := lo.WaitForWithContext(ctx, alwaysFalse, 10*time.Millisecond, time.Millisecond)\n// 10\n// 10ms\n// false\n\niterations, duration, ok := lo.WaitForWithContext(ctx, laterTrue, 10*time.Millisecond, time.Millisecond)\n// 5\n// 5ms\n// true\n\niterations, duration, ok := lo.WaitForWithContext(ctx, laterTrue, 10*time.Millisecond, 5*time.Millisecond)\n// 2\n// 10ms\n// false\n\nexpiringCtx, cancel := context.WithTimeout(ctx, 5*time.Millisecond)\niterations, duration, ok := lo.WaitForWithContext(expiringCtx, alwaysFalse, 100*time.Millisecond, time.Millisecond)\n// 5\n// 5.1ms\n// false\n```\n\n### Validate\n\nHelper function that creates an error when a condition is not met.\n\n```go\nslice := []string{\"a\"}\nval := lo.Validate(len(slice) == 0, \"Slice should be empty but contains %v\", slice)\n// error(\"Slice should be empty but contains [a]\")\n\nslice := []string{}\nval := lo.Validate(len(slice) == 0, \"Slice should be empty but contains %v\", slice)\n// nil\n```\n\n[[play](https://go.dev/play/p/vPyh51XpCBt)]\n\n### Must\n\nWraps a function call to panics if second argument is `error` or `false`, returns the value otherwise.\n\n```go\nval := lo.Must(time.Parse(\"2006-01-02\", \"2022-01-15\"))\n// 2022-01-15\n\nval := lo.Must(time.Parse(\"2006-01-02\", \"bad-value\"))\n// panics\n```\n\n[[play](https://go.dev/play/p/TMoWrRp3DyC)]\n\n### Must{0->6}\n\nMust\\* has the same behavior as Must, but returns multiple values.\n\n```go\nfunc example0() (error)\nfunc example1() (int, error)\nfunc example2() (int, string, error)\nfunc example3() (int, string, time.Date, error)\nfunc example4() (int, string, time.Date, bool, error)\nfunc example5() (int, string, time.Date, bool, float64, error)\nfunc example6() (int, string, time.Date, bool, float64, byte, error)\n\nlo.Must0(example0())\nval1 := lo.Must1(example1())    // alias to Must\nval1, val2 := lo.Must2(example2())\nval1, val2, val3 := lo.Must3(example3())\nval1, val2, val3, val4 := lo.Must4(example4())\nval1, val2, val3, val4, val5 := lo.Must5(example5())\nval1, val2, val3, val4, val5, val6 := lo.Must6(example6())\n```\n\nYou can wrap functions like `func (...) (..., ok bool)`.\n\n```go\n// math.Signbit(float64) bool\nlo.Must0(math.Signbit(v))\n\n// bytes.Cut([]byte,[]byte) ([]byte, []byte, bool)\nbefore, after := lo.Must2(bytes.Cut(s, sep))\n```\n\nYou can give context to the panic message by adding some printf-like arguments.\n\n```go\nval, ok := lo.Find(myString, func(i string) bool {\n    return i == requiredChar\n})\nlo.Must0(ok, \"'%s' must always contain '%s'\", myString, requiredChar)\n\nlist := []int{0, 1, 2}\nitem := 5\nlo.Must0(lo.Contains(list, item), \"'%s' must always contain '%s'\", list, item)\n...\n```\n\n[[play](https://go.dev/play/p/TMoWrRp3DyC)]\n\n### Try\n\nCalls the function and returns false in case of error and panic.\n\n```go\nok := lo.Try(func() error {\n    panic(\"error\")\n    return nil\n})\n// false\n\nok := lo.Try(func() error {\n    return nil\n})\n// true\n\nok := lo.Try(func() error {\n    return fmt.Errorf(\"error\")\n})\n// false\n```\n\n[[play](https://go.dev/play/p/mTyyWUvn9u4)]\n\n### Try{0->6}\n\nThe same behavior as `Try`, but the callback returns 2 variables.\n\n```go\nok := lo.Try2(func() (string, error) {\n    panic(\"error\")\n    return \"\", nil\n})\n// false\n```\n\n[[play](https://go.dev/play/p/mTyyWUvn9u4)]\n\n### TryOr\n\nCalls the function and return a default value in case of error and on panic.\n\n```go\nstr, ok := lo.TryOr(func() (string, error) {\n    panic(\"error\")\n    return \"hello\", nil\n}, \"world\")\n// world\n// false\n\nstr, ok := lo.TryOr(func() error {\n    return \"hello\", nil\n}, \"world\")\n// hello\n// true\n\nstr, ok := lo.TryOr(func() error {\n    return \"hello\", fmt.Errorf(\"error\")\n}, \"world\")\n// world\n// false\n```\n\n[[play](https://go.dev/play/p/B4F7Wg2Zh9X)]\n\n### TryOr{0->6}\n\nThe same behavior as `TryOr`, but the callback returns `X` variables.\n\n```go\nstr, nbr, ok := lo.TryOr2(func() (string, int, error) {\n    panic(\"error\")\n    return \"hello\", 42, nil\n}, \"world\", 21)\n// world\n// 21\n// false\n```\n\n[[play](https://go.dev/play/p/B4F7Wg2Zh9X)]\n\n### TryWithErrorValue\n\nThe same behavior as `Try`, but also returns the value passed to panic.\n\n```go\nerr, ok := lo.TryWithErrorValue(func() error {\n    panic(\"error\")\n    return nil\n})\n// \"error\", false\n```\n\n[[play](https://go.dev/play/p/Kc7afQIT2Fs)]\n\n### TryCatch\n\nThe same behavior as `Try`, but calls the catch function in case of error.\n\n```go\ncaught := false\n\nok := lo.TryCatch(func() error {\n    panic(\"error\")\n    return nil\n}, func() {\n    caught = true\n})\n// false\n// caught == true\n```\n\n[[play](https://go.dev/play/p/PnOON-EqBiU)]\n\n### TryCatchWithErrorValue\n\nThe same behavior as `TryWithErrorValue`, but calls the catch function in case of error.\n\n```go\ncaught := false\n\nok := lo.TryCatchWithErrorValue(func() error {\n    panic(\"error\")\n    return nil\n}, func(val any) {\n    caught = val == \"error\"\n})\n// false\n// caught == true\n```\n\n[[play](https://go.dev/play/p/8Pc9gwX_GZO)]\n\n### ErrorsAs\n\nA shortcut for:\n\n```go\nerr := doSomething()\n\nvar rateLimitErr *RateLimitError\nif ok := errors.As(err, &rateLimitErr); ok {\n    // retry later\n}\n```\n\n1 line `lo` helper:\n\n```go\nerr := doSomething()\n\nif rateLimitErr, ok := lo.ErrorsAs[*RateLimitError](err); ok {\n    // retry later\n}\n```\n\n[[play](https://go.dev/play/p/8wk5rH8UfrE)]\n\n## 🛩 Benchmark\n\nWe executed a simple benchmark with a dead-simple `lo.Map` loop:\n\nSee the full implementation [here](./map_benchmark_test.go).\n\n```go\n_ = lo.Map[int64](arr, func(x int64, i int) string {\n    return strconv.FormatInt(x, 10)\n})\n```\n\n**Result:**\n\nHere is a comparison between `lo.Map`, `lop.Map`, `go-funk` library and a simple Go `for` loop.\n\n```shell\n$ go test -benchmem -bench ./...\ngoos: linux\ngoarch: amd64\npkg: github.com/samber/lo\ncpu: Intel(R) Core(TM) i5-7267U CPU @ 3.10GHz\ncpu: Intel(R) Core(TM) i7 CPU         920  @ 2.67GHz\nBenchmarkMap/lo.Map-8         \t       8\t 132728237 ns/op\t39998945 B/op\t 1000002 allocs/op\nBenchmarkMap/lop.Map-8        \t       2\t 503947830 ns/op\t119999956 B/op\t 3000007 allocs/op\nBenchmarkMap/reflect-8        \t       2\t 826400560 ns/op\t170326512 B/op\t 4000042 allocs/op\nBenchmarkMap/for-8            \t       9\t 126252954 ns/op\t39998674 B/op\t 1000001 allocs/op\nPASS\nok  \tgithub.com/samber/lo\t6.657s\n```\n\n- `lo.Map` is way faster (x7) than `go-funk`, a reflection-based Map implementation.\n- `lo.Map` have the same allocation profile than `for`.\n- `lo.Map` is 4% slower than `for`.\n- `lop.Map` is slower than `lo.Map` because it implies more memory allocation and locks. `lop.Map` will be useful for long-running callbacks, such as i/o bound processing.\n- `for` beats other implementations for memory and CPU.\n\n## 🤝 Contributing\n\n- Ping me on Twitter [@samuelberthe](https://twitter.com/samuelberthe) (DMs, mentions, whatever :))\n- Fork the [project](https://github.com/samber/lo)\n- Fix [open issues](https://github.com/samber/lo/issues) or request new features\n\nDon't hesitate ;)\n\nHelper naming: helpers must be self-explanatory and respect standards (other languages, libraries...). Feel free to suggest many names in your contributions.\n\n### With Docker\n\n```bash\ndocker-compose run --rm dev\n```\n\n### Without Docker\n\n```bash\n# Install some dev dependencies\nmake tools\n\n# Run tests\nmake test\n# or\nmake watch-test\n```\n\n## 👤 Contributors\n\n![Contributors](https://contrib.rocks/image?repo=samber/lo)\n\n## 💫 Show your support\n\nGive a ⭐️ if this project helped you!\n\n[![GitHub Sponsors](https://img.shields.io/github/sponsors/samber?style=for-the-badge)](https://github.com/sponsors/samber)\n\n## 📝 License\n\nCopyright © 2022 [Samuel Berthe](https://github.com/samber).\n\nThis project is under [MIT](./LICENSE) license.\n"
        },
        {
          "name": "channel.go",
          "type": "blob",
          "size": 8.3642578125,
          "content": "package lo\n\nimport (\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/samber/lo/internal/rand\"\n)\n\ntype DispatchingStrategy[T any] func(msg T, index uint64, channels []<-chan T) int\n\n// ChannelDispatcher distributes messages from input channels into N child channels.\n// Close events are propagated to children.\n// Underlying channels can have a fixed buffer capacity or be unbuffered when cap is 0.\nfunc ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n\tchildren := createChannels[T](count, channelBufferCap)\n\n\troChildren := channelsToReadOnly(children)\n\n\tgo func() {\n\t\t// propagate channel closing to children\n\t\tdefer closeChannels(children)\n\n\t\tvar i uint64 = 0\n\n\t\tfor {\n\t\t\tmsg, ok := <-stream\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdestination := strategy(msg, i, roChildren) % count\n\t\t\tchildren[destination] <- msg\n\n\t\t\ti++\n\t\t}\n\t}()\n\n\treturn roChildren\n}\n\nfunc createChannels[T any](count int, channelBufferCap int) []chan T {\n\tchildren := make([]chan T, 0, count)\n\n\tfor i := 0; i < count; i++ {\n\t\tchildren = append(children, make(chan T, channelBufferCap))\n\t}\n\n\treturn children\n}\n\nfunc channelsToReadOnly[T any](children []chan T) []<-chan T {\n\troChildren := make([]<-chan T, 0, len(children))\n\n\tfor i := range children {\n\t\troChildren = append(roChildren, children[i])\n\t}\n\n\treturn roChildren\n}\n\nfunc closeChannels[T any](children []chan T) {\n\tfor i := 0; i < len(children); i++ {\n\t\tclose(children[i])\n\t}\n}\n\nfunc channelIsNotFull[T any](ch <-chan T) bool {\n\treturn cap(ch) == 0 || len(ch) < cap(ch)\n}\n\n// DispatchingStrategyRoundRobin distributes messages in a rotating sequential manner.\n// If the channel capacity is exceeded, the next channel will be selected and so on.\nfunc DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n\tfor {\n\t\ti := int(index % uint64(len(channels)))\n\t\tif channelIsNotFull(channels[i]) {\n\t\t\treturn i\n\t\t}\n\n\t\tindex++\n\t\ttime.Sleep(10 * time.Microsecond) // prevent CPU from burning 🔥\n\t}\n}\n\n// DispatchingStrategyRandom distributes messages in a random manner.\n// If the channel capacity is exceeded, another random channel will be selected and so on.\nfunc DispatchingStrategyRandom[T any](msg T, index uint64, channels []<-chan T) int {\n\tfor {\n\t\ti := rand.IntN(len(channels))\n\t\tif channelIsNotFull(channels[i]) {\n\t\t\treturn i\n\t\t}\n\n\t\ttime.Sleep(10 * time.Microsecond) // prevent CPU from burning 🔥\n\t}\n}\n\n// DispatchingStrategyWeightedRandom distributes messages in a weighted manner.\n// If the channel capacity is exceeded, another random channel will be selected and so on.\nfunc DispatchingStrategyWeightedRandom[T any](weights []int) DispatchingStrategy[T] {\n\tseq := []int{}\n\n\tfor i := 0; i < len(weights); i++ {\n\t\tfor j := 0; j < weights[i]; j++ {\n\t\t\tseq = append(seq, i)\n\t\t}\n\t}\n\n\treturn func(msg T, index uint64, channels []<-chan T) int {\n\t\tfor {\n\t\t\ti := seq[rand.IntN(len(seq))]\n\t\t\tif channelIsNotFull(channels[i]) {\n\t\t\t\treturn i\n\t\t\t}\n\n\t\t\ttime.Sleep(10 * time.Microsecond) // prevent CPU from burning 🔥\n\t\t}\n\t}\n}\n\n// DispatchingStrategyFirst distributes messages in the first non-full channel.\n// If the capacity of the first channel is exceeded, the second channel will be selected and so on.\nfunc DispatchingStrategyFirst[T any](msg T, index uint64, channels []<-chan T) int {\n\tfor {\n\t\tfor i := range channels {\n\t\t\tif channelIsNotFull(channels[i]) {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(10 * time.Microsecond) // prevent CPU from burning 🔥\n\t}\n}\n\n// DispatchingStrategyLeast distributes messages in the emptiest channel.\nfunc DispatchingStrategyLeast[T any](msg T, index uint64, channels []<-chan T) int {\n\tseq := Range(len(channels))\n\n\treturn MinBy(seq, func(item int, min int) bool {\n\t\treturn len(channels[item]) < len(channels[min])\n\t})\n}\n\n// DispatchingStrategyMost distributes messages in the fullest channel.\n// If the channel capacity is exceeded, the next channel will be selected and so on.\nfunc DispatchingStrategyMost[T any](msg T, index uint64, channels []<-chan T) int {\n\tseq := Range(len(channels))\n\n\treturn MaxBy(seq, func(item int, max int) bool {\n\t\treturn len(channels[item]) > len(channels[max]) && channelIsNotFull(channels[item])\n\t})\n}\n\n// SliceToChannel returns a read-only channels of collection elements.\nfunc SliceToChannel[T any](bufferSize int, collection []T) <-chan T {\n\tch := make(chan T, bufferSize)\n\n\tgo func() {\n\t\tfor i := range collection {\n\t\t\tch <- collection[i]\n\t\t}\n\n\t\tclose(ch)\n\t}()\n\n\treturn ch\n}\n\n// ChannelToSlice returns a slice built from channels items. Blocks until channel closes.\nfunc ChannelToSlice[T any](ch <-chan T) []T {\n\tcollection := []T{}\n\n\tfor item := range ch {\n\t\tcollection = append(collection, item)\n\t}\n\n\treturn collection\n}\n\n// Generator implements the generator design pattern.\nfunc Generator[T any](bufferSize int, generator func(yield func(T))) <-chan T {\n\tch := make(chan T, bufferSize)\n\n\tgo func() {\n\t\t// WARNING: infinite loop\n\t\tgenerator(func(t T) {\n\t\t\tch <- t\n\t\t})\n\n\t\tclose(ch)\n\t}()\n\n\treturn ch\n}\n\n// Buffer creates a slice of n elements from a channel. Returns the slice and the slice length.\n// @TODO: we should probably provide an helper that reuse the same buffer.\nfunc Buffer[T any](ch <-chan T, size int) (collection []T, length int, readTime time.Duration, ok bool) {\n\tbuffer := make([]T, 0, size)\n\tindex := 0\n\tnow := time.Now()\n\n\tfor ; index < size; index++ {\n\t\titem, ok := <-ch\n\t\tif !ok {\n\t\t\treturn buffer, index, time.Since(now), false\n\t\t}\n\n\t\tbuffer = append(buffer, item)\n\t}\n\n\treturn buffer, index, time.Since(now), true\n}\n\n// Batch creates a slice of n elements from a channel. Returns the slice and the slice length.\n//\n// Deprecated: Use [Buffer] instead.\nfunc Batch[T any](ch <-chan T, size int) (collection []T, length int, readTime time.Duration, ok bool) {\n\treturn Buffer(ch, size)\n}\n\n// BufferWithTimeout creates a slice of n elements from a channel, with timeout. Returns the slice and the slice length.\n// @TODO: we should probably provide an helper that reuse the same buffer.\nfunc BufferWithTimeout[T any](ch <-chan T, size int, timeout time.Duration) (collection []T, length int, readTime time.Duration, ok bool) {\n\texpire := time.NewTimer(timeout)\n\tdefer expire.Stop()\n\n\tbuffer := make([]T, 0, size)\n\tindex := 0\n\tnow := time.Now()\n\n\tfor ; index < size; index++ {\n\t\tselect {\n\t\tcase item, ok := <-ch:\n\t\t\tif !ok {\n\t\t\t\treturn buffer, index, time.Since(now), false\n\t\t\t}\n\n\t\t\tbuffer = append(buffer, item)\n\n\t\tcase <-expire.C:\n\t\t\treturn buffer, index, time.Since(now), true\n\t\t}\n\t}\n\n\treturn buffer, index, time.Since(now), true\n}\n\n// BatchWithTimeout creates a slice of n elements from a channel, with timeout. Returns the slice and the slice length.\n//\n// Deprecated: Use [BufferWithTimeout] instead.\nfunc BatchWithTimeout[T any](ch <-chan T, size int, timeout time.Duration) (collection []T, length int, readTime time.Duration, ok bool) {\n\treturn BufferWithTimeout(ch, size, timeout)\n}\n\n// FanIn collects messages from multiple input channels into a single buffered channel.\n// Output messages has no priority. When all upstream channels reach EOF, downstream channel closes.\nfunc FanIn[T any](channelBufferCap int, upstreams ...<-chan T) <-chan T {\n\tout := make(chan T, channelBufferCap)\n\tvar wg sync.WaitGroup\n\n\t// Start an output goroutine for each input channel in upstreams.\n\twg.Add(len(upstreams))\n\tfor i := range upstreams {\n\t\tgo func(index int) {\n\t\t\tfor n := range upstreams[index] {\n\t\t\t\tout <- n\n\t\t\t}\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\t// Start a goroutine to close out once all the output goroutines are done.\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\n// ChannelMerge collects messages from multiple input channels into a single buffered channel.\n// Output messages has no priority. When all upstream channels reach EOF, downstream channel closes.\n//\n// Deprecated: Use [FanIn] instead.\nfunc ChannelMerge[T any](channelBufferCap int, upstreams ...<-chan T) <-chan T {\n\treturn FanIn(channelBufferCap, upstreams...)\n}\n\n// FanOut broadcasts all the upstream messages to multiple downstream channels.\n// When upstream channel reach EOF, downstream channels close. If any downstream\n// channels is full, broadcasting is paused.\nfunc FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n\tdownstreams := createChannels[T](count, channelsBufferCap)\n\n\tgo func() {\n\t\tfor msg := range upstream {\n\t\t\tfor i := range downstreams {\n\t\t\t\tdownstreams[i] <- msg\n\t\t\t}\n\t\t}\n\n\t\t// Close out once all the output goroutines are done.\n\t\tfor i := range downstreams {\n\t\t\tclose(downstreams[i])\n\t\t}\n\t}()\n\n\treturn channelsToReadOnly(downstreams)\n}\n"
        },
        {
          "name": "channel_test.go",
          "type": "blob",
          "size": 8.5380859375,
          "content": "package lo\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestChannelDispatcher(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 100*time.Millisecond)\n\tis := assert.New(t)\n\n\tch := make(chan int, 10)\n\n\tch <- 0\n\tch <- 1\n\tch <- 2\n\tch <- 3\n\n\tis.Equal(4, len(ch))\n\n\tchildren := ChannelDispatcher(ch, 5, 10, DispatchingStrategyRoundRobin[int])\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// check channels allocation\n\tis.Equal(5, len(children))\n\n\tis.Equal(10, cap(children[0]))\n\tis.Equal(10, cap(children[1]))\n\tis.Equal(10, cap(children[2]))\n\tis.Equal(10, cap(children[3]))\n\tis.Equal(10, cap(children[4]))\n\n\tis.Equal(1, len(children[0]))\n\tis.Equal(1, len(children[1]))\n\tis.Equal(1, len(children[2]))\n\tis.Equal(1, len(children[3]))\n\tis.Equal(0, len(children[4]))\n\n\t// check channels content\n\tis.Equal(0, len(ch))\n\n\tmsg0, ok0 := <-children[0]\n\tis.Equal(ok0, true)\n\tis.Equal(msg0, 0)\n\n\tmsg1, ok1 := <-children[1]\n\tis.Equal(ok1, true)\n\tis.Equal(msg1, 1)\n\n\tmsg2, ok2 := <-children[2]\n\tis.Equal(ok2, true)\n\tis.Equal(msg2, 2)\n\n\tmsg3, ok3 := <-children[3]\n\tis.Equal(ok3, true)\n\tis.Equal(msg3, 3)\n\n\t// msg4, ok4 := <-children[4]\n\t// is.Equal(ok4, false)\n\t// is.Equal(msg4, 0)\n\t// is.Nil(children[4])\n\n\t// check it is closed\n\tclose(ch)\n\ttime.Sleep(10 * time.Millisecond)\n\tis.Panics(func() {\n\t\tch <- 42\n\t})\n\n\tmsg0, ok0 = <-children[0]\n\tis.Equal(ok0, false)\n\tis.Equal(msg0, 0)\n\n\tmsg1, ok1 = <-children[1]\n\tis.Equal(ok1, false)\n\tis.Equal(msg1, 0)\n\n\tmsg2, ok2 = <-children[2]\n\tis.Equal(ok2, false)\n\tis.Equal(msg2, 0)\n\n\tmsg3, ok3 = <-children[3]\n\tis.Equal(ok3, false)\n\tis.Equal(msg3, 0)\n\n\tmsg4, ok4 := <-children[4]\n\tis.Equal(ok4, false)\n\tis.Equal(msg4, 0)\n\n\t// unbuffered channels\n\tchildren = ChannelDispatcher(ch, 5, 0, DispatchingStrategyRoundRobin[int])\n\tis.Equal(0, cap(children[0]))\n}\n\nfunc TestDispatchingStrategyRoundRobin(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tchildren := createChannels[int](3, 2)\n\trochildren := channelsToReadOnly(children)\n\tdefer closeChannels(children)\n\n\tis.Equal(0, DispatchingStrategyRoundRobin(42, 0, rochildren))\n\tis.Equal(1, DispatchingStrategyRoundRobin(42, 1, rochildren))\n\tis.Equal(2, DispatchingStrategyRoundRobin(42, 2, rochildren))\n\tis.Equal(0, DispatchingStrategyRoundRobin(42, 3, rochildren))\n}\n\nfunc TestDispatchingStrategyRandom(t *testing.T) {\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\t// with this seed, the order of random channels are: 1 - 0\n\trand.Seed(14)\n\n\tchildren := createChannels[int](2, 2)\n\trochildren := channelsToReadOnly(children)\n\tdefer closeChannels(children)\n\n\tfor i := 0; i < 2; i++ {\n\t\tchildren[1] <- i\n\t}\n\n\tis.Equal(0, DispatchingStrategyRandom(42, 0, rochildren))\n}\n\nfunc TestDispatchingStrategyWeightedRandom(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tchildren := createChannels[int](2, 2)\n\trochildren := channelsToReadOnly(children)\n\tdefer closeChannels(children)\n\n\tdispatcher := DispatchingStrategyWeightedRandom[int]([]int{0, 42})\n\n\tis.Equal(1, dispatcher(42, 0, rochildren))\n\tchildren[0] <- 0\n\tis.Equal(1, dispatcher(42, 0, rochildren))\n\tchildren[1] <- 1\n\tis.Equal(1, dispatcher(42, 0, rochildren))\n}\n\nfunc TestDispatchingStrategyFirst(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tchildren := createChannels[int](2, 2)\n\trochildren := channelsToReadOnly(children)\n\tdefer closeChannels(children)\n\n\tis.Equal(0, DispatchingStrategyFirst(42, 0, rochildren))\n\tchildren[0] <- 0\n\tis.Equal(0, DispatchingStrategyFirst(42, 0, rochildren))\n\tchildren[0] <- 1\n\tis.Equal(1, DispatchingStrategyFirst(42, 0, rochildren))\n}\n\nfunc TestDispatchingStrategyLeast(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tchildren := createChannels[int](2, 2)\n\trochildren := channelsToReadOnly(children)\n\tdefer closeChannels(children)\n\n\tis.Equal(0, DispatchingStrategyLeast(42, 0, rochildren))\n\tchildren[0] <- 0\n\tis.Equal(1, DispatchingStrategyLeast(42, 0, rochildren))\n\tchildren[1] <- 0\n\tis.Equal(0, DispatchingStrategyLeast(42, 0, rochildren))\n\tchildren[0] <- 1\n\tis.Equal(1, DispatchingStrategyLeast(42, 0, rochildren))\n\tchildren[1] <- 1\n\tis.Equal(0, DispatchingStrategyLeast(42, 0, rochildren))\n}\n\nfunc TestDispatchingStrategyMost(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tchildren := createChannels[int](2, 2)\n\trochildren := channelsToReadOnly(children)\n\tdefer closeChannels(children)\n\n\tis.Equal(0, DispatchingStrategyMost(42, 0, rochildren))\n\tchildren[0] <- 0\n\tis.Equal(0, DispatchingStrategyMost(42, 0, rochildren))\n\tchildren[1] <- 0\n\tis.Equal(0, DispatchingStrategyMost(42, 0, rochildren))\n\tchildren[0] <- 1\n\tis.Equal(0, DispatchingStrategyMost(42, 0, rochildren))\n\tchildren[1] <- 1\n\tis.Equal(0, DispatchingStrategyMost(42, 0, rochildren))\n}\n\nfunc TestSliceToChannel(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tch := SliceToChannel(2, []int{1, 2, 3})\n\n\tr1, ok1 := <-ch\n\tr2, ok2 := <-ch\n\tr3, ok3 := <-ch\n\tis.True(ok1)\n\tis.Equal(1, r1)\n\tis.True(ok2)\n\tis.Equal(2, r2)\n\tis.True(ok3)\n\tis.Equal(3, r3)\n\n\t_, ok4 := <-ch\n\tis.False(ok4)\n}\n\nfunc TestChannelToSlice(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tch := SliceToChannel(2, []int{1, 2, 3})\n\titems := ChannelToSlice(ch)\n\n\tis.Equal([]int{1, 2, 3}, items)\n}\n\nfunc TestGenerate(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tgenerator := func(yield func(int)) {\n\t\tyield(0)\n\t\tyield(1)\n\t\tyield(2)\n\t\tyield(3)\n\t}\n\n\ti := 0\n\n\tfor v := range Generator(2, generator) {\n\t\tis.Equal(i, v)\n\t\ti++\n\t}\n\n\tis.Equal(i, 4)\n}\n\nfunc TestBuffer(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 10*time.Millisecond)\n\tis := assert.New(t)\n\n\tch := SliceToChannel(2, []int{1, 2, 3})\n\n\titems1, length1, _, ok1 := Buffer(ch, 2)\n\titems2, length2, _, ok2 := Buffer(ch, 2)\n\titems3, length3, _, ok3 := Buffer(ch, 2)\n\n\tis.Equal([]int{1, 2}, items1)\n\tis.Equal(2, length1)\n\tis.True(ok1)\n\tis.Equal([]int{3}, items2)\n\tis.Equal(1, length2)\n\tis.False(ok2)\n\tis.Equal([]int{}, items3)\n\tis.Equal(0, length3)\n\tis.False(ok3)\n}\n\nfunc TestBufferWithTimeout(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 200*time.Millisecond)\n\tis := assert.New(t)\n\n\tgenerator := func(yield func(int)) {\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tyield(i)\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n\tch := Generator(0, generator)\n\n\titems1, length1, _, ok1 := BufferWithTimeout(ch, 20, 15*time.Millisecond)\n\tis.Equal([]int{0, 1}, items1)\n\tis.Equal(2, length1)\n\tis.True(ok1)\n\n\titems2, length2, _, ok2 := BufferWithTimeout(ch, 20, 2*time.Millisecond)\n\tis.Equal([]int{}, items2)\n\tis.Equal(0, length2)\n\tis.True(ok2)\n\n\titems3, length3, _, ok3 := BufferWithTimeout(ch, 1, 30*time.Millisecond)\n\tis.Equal([]int{2}, items3)\n\tis.Equal(1, length3)\n\tis.True(ok3)\n\n\titems4, length4, _, ok4 := BufferWithTimeout(ch, 2, 25*time.Millisecond)\n\tis.Equal([]int{3, 4}, items4)\n\tis.Equal(2, length4)\n\tis.True(ok4)\n\n\titems5, length5, _, ok5 := BufferWithTimeout(ch, 3, 25*time.Millisecond)\n\tis.Equal([]int{}, items5)\n\tis.Equal(0, length5)\n\tis.False(ok5)\n}\n\nfunc TestFanIn(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 100*time.Millisecond)\n\tis := assert.New(t)\n\n\tupstreams := createChannels[int](3, 10)\n\troupstreams := channelsToReadOnly(upstreams)\n\tfor i := range roupstreams {\n\t\tgo func(i int) {\n\t\t\tupstreams[i] <- 1\n\t\t\tupstreams[i] <- 1\n\t\t\tclose(upstreams[i])\n\t\t}(i)\n\t}\n\tout := FanIn(10, roupstreams...)\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// check input channels\n\tis.Equal(0, len(roupstreams[0]))\n\tis.Equal(0, len(roupstreams[1]))\n\tis.Equal(0, len(roupstreams[2]))\n\n\t// check channels allocation\n\tis.Equal(6, len(out))\n\tis.Equal(10, cap(out))\n\n\t// check channels content\n\tfor i := 0; i < 6; i++ {\n\t\tmsg0, ok0 := <-out\n\t\tis.Equal(true, ok0)\n\t\tis.Equal(1, msg0)\n\t}\n\n\t// check it is closed\n\ttime.Sleep(10 * time.Millisecond)\n\tmsg0, ok0 := <-out\n\tis.Equal(false, ok0)\n\tis.Equal(0, msg0)\n}\n\nfunc TestFanOut(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 100*time.Millisecond)\n\tis := assert.New(t)\n\n\tupstream := SliceToChannel(10, []int{0, 1, 2, 3, 4, 5})\n\trodownstreams := FanOut(3, 10, upstream)\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// check output channels\n\tis.Equal(3, len(rodownstreams))\n\n\t// check channels allocation\n\tfor i := range rodownstreams {\n\t\tis.Equal(6, len(rodownstreams[i]))\n\t\tis.Equal(10, cap(rodownstreams[i]))\n\t\tis.Equal([]int{0, 1, 2, 3, 4, 5}, ChannelToSlice(rodownstreams[i]))\n\t}\n\n\t// check it is closed\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// check channels allocation\n\tfor i := range rodownstreams {\n\t\tmsg, ok := <-rodownstreams[i]\n\t\tis.Equal(false, ok)\n\t\tis.Equal(0, msg)\n\t}\n}\n"
        },
        {
          "name": "concurrency.go",
          "type": "blob",
          "size": 3.4951171875,
          "content": "package lo\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype synchronize struct {\n\tlocker sync.Locker\n}\n\nfunc (s *synchronize) Do(cb func()) {\n\ts.locker.Lock()\n\tTry0(cb)\n\ts.locker.Unlock()\n}\n\n// Synchronize wraps the underlying callback in a mutex. It receives an optional mutex.\nfunc Synchronize(opt ...sync.Locker) *synchronize {\n\tif len(opt) > 1 {\n\t\tpanic(\"unexpected arguments\")\n\t} else if len(opt) == 0 {\n\t\topt = append(opt, &sync.Mutex{})\n\t}\n\n\treturn &synchronize{\n\t\tlocker: opt[0],\n\t}\n}\n\n// Async executes a function in a goroutine and returns the result in a channel.\nfunc Async[A any](f func() A) <-chan A {\n\tch := make(chan A, 1)\n\tgo func() {\n\t\tch <- f()\n\t}()\n\treturn ch\n}\n\n// Async0 executes a function in a goroutine and returns a channel set once the function finishes.\nfunc Async0(f func()) <-chan struct{} {\n\tch := make(chan struct{}, 1)\n\tgo func() {\n\t\tf()\n\t\tch <- struct{}{}\n\t}()\n\treturn ch\n}\n\n// Async1 is an alias to Async.\nfunc Async1[A any](f func() A) <-chan A {\n\treturn Async(f)\n}\n\n// Async2 has the same behavior as Async, but returns the 2 results as a tuple inside the channel.\nfunc Async2[A, B any](f func() (A, B)) <-chan Tuple2[A, B] {\n\tch := make(chan Tuple2[A, B], 1)\n\tgo func() {\n\t\tch <- T2(f())\n\t}()\n\treturn ch\n}\n\n// Async3 has the same behavior as Async, but returns the 3 results as a tuple inside the channel.\nfunc Async3[A, B, C any](f func() (A, B, C)) <-chan Tuple3[A, B, C] {\n\tch := make(chan Tuple3[A, B, C], 1)\n\tgo func() {\n\t\tch <- T3(f())\n\t}()\n\treturn ch\n}\n\n// Async4 has the same behavior as Async, but returns the 4 results as a tuple inside the channel.\nfunc Async4[A, B, C, D any](f func() (A, B, C, D)) <-chan Tuple4[A, B, C, D] {\n\tch := make(chan Tuple4[A, B, C, D], 1)\n\tgo func() {\n\t\tch <- T4(f())\n\t}()\n\treturn ch\n}\n\n// Async5 has the same behavior as Async, but returns the 5 results as a tuple inside the channel.\nfunc Async5[A, B, C, D, E any](f func() (A, B, C, D, E)) <-chan Tuple5[A, B, C, D, E] {\n\tch := make(chan Tuple5[A, B, C, D, E], 1)\n\tgo func() {\n\t\tch <- T5(f())\n\t}()\n\treturn ch\n}\n\n// Async6 has the same behavior as Async, but returns the 6 results as a tuple inside the channel.\nfunc Async6[A, B, C, D, E, F any](f func() (A, B, C, D, E, F)) <-chan Tuple6[A, B, C, D, E, F] {\n\tch := make(chan Tuple6[A, B, C, D, E, F], 1)\n\tgo func() {\n\t\tch <- T6(f())\n\t}()\n\treturn ch\n}\n\n// WaitFor runs periodically until a condition is validated.\nfunc WaitFor(condition func(i int) bool, timeout time.Duration, heartbeatDelay time.Duration) (totalIterations int, elapsed time.Duration, conditionFound bool) {\n\tconditionWithContext := func(_ context.Context, currentIteration int) bool {\n\t\treturn condition(currentIteration)\n\t}\n\treturn WaitForWithContext(context.Background(), conditionWithContext, timeout, heartbeatDelay)\n}\n\n// WaitForWithContext runs periodically until a condition is validated or context is canceled.\nfunc WaitForWithContext(ctx context.Context, condition func(ctx context.Context, currentIteration int) bool, timeout time.Duration, heartbeatDelay time.Duration) (totalIterations int, elapsed time.Duration, conditionFound bool) {\n\tstart := time.Now()\n\n\tif ctx.Err() != nil {\n\t\treturn totalIterations, time.Since(start), false\n\t}\n\n\tctx, cleanCtx := context.WithTimeout(ctx, timeout)\n\tticker := time.NewTicker(heartbeatDelay)\n\n\tdefer func() {\n\t\tcleanCtx()\n\t\tticker.Stop()\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn totalIterations, time.Since(start), false\n\t\tcase <-ticker.C:\n\t\t\ttotalIterations++\n\t\t\tif condition(ctx, totalIterations-1) {\n\t\t\t\treturn totalIterations, time.Since(start), true\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "concurrency_test.go",
          "type": "blob",
          "size": 9.140625,
          "content": "package lo\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestSynchronize(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 100*time.Millisecond)\n\tis := assert.New(t)\n\n\t// check that callbacks are not executed concurrently\n\t{\n\t\tstart := time.Now()\n\n\t\twg := sync.WaitGroup{}\n\t\twg.Add(10)\n\n\t\ts := Synchronize()\n\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tgo s.Do(func() {\n\t\t\t\ttime.Sleep(5 * time.Millisecond)\n\t\t\t\twg.Done()\n\t\t\t})\n\t\t}\n\n\t\twg.Wait()\n\n\t\tduration := time.Since(start)\n\n\t\tis.Greater(duration, 50*time.Millisecond)\n\t\tis.Less(duration, 60*time.Millisecond)\n\t}\n\n\t// check locker is locked\n\t{\n\t\tmu := &sync.Mutex{}\n\t\ts := Synchronize(mu)\n\n\t\ts.Do(func() {\n\t\t\tis.False(mu.TryLock())\n\t\t})\n\t\tis.True(mu.TryLock())\n\n\t\tTry0(func() {\n\t\t\tmu.Unlock()\n\t\t})\n\t}\n\n\t// check we don't accept multiple arguments\n\t{\n\t\tis.PanicsWithValue(\"unexpected arguments\", func() {\n\t\t\tmu := &sync.Mutex{}\n\t\t\tSynchronize(mu, mu, mu)\n\t\t})\n\t}\n}\n\nfunc TestAsync(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 100*time.Millisecond)\n\tis := assert.New(t)\n\n\tsync := make(chan struct{})\n\n\tch := Async(func() int {\n\t\t<-sync\n\t\treturn 10\n\t})\n\n\tsync <- struct{}{}\n\n\tselect {\n\tcase result := <-ch:\n\t\tis.Equal(result, 10)\n\tcase <-time.After(time.Millisecond):\n\t\tis.Fail(\"Async should not block\")\n\t}\n}\n\nfunc TestAsyncX(t *testing.T) {\n\tt.Parallel()\n\ttestWithTimeout(t, 100*time.Millisecond)\n\tis := assert.New(t)\n\n\t{\n\t\tsync := make(chan struct{})\n\n\t\tch := Async0(func() {\n\t\t\t<-sync\n\t\t})\n\n\t\tsync <- struct{}{}\n\n\t\tselect {\n\t\tcase <-ch:\n\t\tcase <-time.After(time.Millisecond):\n\t\t\tis.Fail(\"Async0 should not block\")\n\t\t}\n\t}\n\n\t{\n\t\tsync := make(chan struct{})\n\n\t\tch := Async1(func() int {\n\t\t\t<-sync\n\t\t\treturn 10\n\t\t})\n\n\t\tsync <- struct{}{}\n\n\t\tselect {\n\t\tcase result := <-ch:\n\t\t\tis.Equal(result, 10)\n\t\tcase <-time.After(time.Millisecond):\n\t\t\tis.Fail(\"Async1 should not block\")\n\t\t}\n\t}\n\n\t{\n\t\tsync := make(chan struct{})\n\n\t\tch := Async2(func() (int, string) {\n\t\t\t<-sync\n\t\t\treturn 10, \"Hello\"\n\t\t})\n\n\t\tsync <- struct{}{}\n\n\t\tselect {\n\t\tcase result := <-ch:\n\t\t\tis.Equal(result, Tuple2[int, string]{10, \"Hello\"})\n\t\tcase <-time.After(time.Millisecond):\n\t\t\tis.Fail(\"Async2 should not block\")\n\t\t}\n\t}\n\n\t{\n\t\tsync := make(chan struct{})\n\n\t\tch := Async3(func() (int, string, bool) {\n\t\t\t<-sync\n\t\t\treturn 10, \"Hello\", true\n\t\t})\n\n\t\tsync <- struct{}{}\n\n\t\tselect {\n\t\tcase result := <-ch:\n\t\t\tis.Equal(result, Tuple3[int, string, bool]{10, \"Hello\", true})\n\t\tcase <-time.After(time.Millisecond):\n\t\t\tis.Fail(\"Async3 should not block\")\n\t\t}\n\t}\n\n\t{\n\t\tsync := make(chan struct{})\n\n\t\tch := Async4(func() (int, string, bool, float64) {\n\t\t\t<-sync\n\t\t\treturn 10, \"Hello\", true, 3.14\n\t\t})\n\n\t\tsync <- struct{}{}\n\n\t\tselect {\n\t\tcase result := <-ch:\n\t\t\tis.Equal(result, Tuple4[int, string, bool, float64]{10, \"Hello\", true, 3.14})\n\t\tcase <-time.After(time.Millisecond):\n\t\t\tis.Fail(\"Async4 should not block\")\n\t\t}\n\t}\n\n\t{\n\t\tsync := make(chan struct{})\n\n\t\tch := Async5(func() (int, string, bool, float64, string) {\n\t\t\t<-sync\n\t\t\treturn 10, \"Hello\", true, 3.14, \"World\"\n\t\t})\n\n\t\tsync <- struct{}{}\n\n\t\tselect {\n\t\tcase result := <-ch:\n\t\t\tis.Equal(result, Tuple5[int, string, bool, float64, string]{10, \"Hello\", true, 3.14, \"World\"})\n\t\tcase <-time.After(time.Millisecond):\n\t\t\tis.Fail(\"Async5 should not block\")\n\t\t}\n\t}\n\n\t{\n\t\tsync := make(chan struct{})\n\n\t\tch := Async6(func() (int, string, bool, float64, string, int) {\n\t\t\t<-sync\n\t\t\treturn 10, \"Hello\", true, 3.14, \"World\", 100\n\t\t})\n\n\t\tsync <- struct{}{}\n\n\t\tselect {\n\t\tcase result := <-ch:\n\t\t\tis.Equal(result, Tuple6[int, string, bool, float64, string, int]{10, \"Hello\", true, 3.14, \"World\", 100})\n\t\tcase <-time.After(time.Millisecond):\n\t\t\tis.Fail(\"Async6 should not block\")\n\t\t}\n\t}\n}\n\nfunc TestWaitFor(t *testing.T) {\n\tt.Parallel()\n\n\ttestTimeout := 100 * time.Millisecond\n\tlongTimeout := 2 * testTimeout\n\tshortTimeout := 4 * time.Millisecond\n\n\tt.Run(\"exist condition works\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\tlaterTrue := func(i int) bool {\n\t\t\treturn i >= 5\n\t\t}\n\n\t\titer, duration, ok := WaitFor(laterTrue, longTimeout, time.Millisecond)\n\t\tis.Equal(6, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(6*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.True(ok)\n\t})\n\n\tt.Run(\"counter is incremented\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\tcounter := 0\n\t\talwaysFalse := func(i int) bool {\n\t\t\tis.Equal(counter, i)\n\t\t\tcounter++\n\t\t\treturn false\n\t\t}\n\n\t\titer, duration, ok := WaitFor(alwaysFalse, shortTimeout, 1050*time.Microsecond)\n\t\tis.Equal(counter, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(10*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.False(ok)\n\t})\n\n\talwaysTrue := func(_ int) bool { return true }\n\talwaysFalse := func(_ int) bool { return false }\n\n\tt.Run(\"short timeout works\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\titer, duration, ok := WaitFor(alwaysFalse, shortTimeout, 10*time.Millisecond)\n\t\tis.Equal(0, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(10*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.False(ok)\n\t})\n\n\tt.Run(\"timeout works\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\tshortTimeout := 4 * time.Millisecond\n\t\titer, duration, ok := WaitFor(alwaysFalse, shortTimeout, 10*time.Millisecond)\n\t\tis.Equal(0, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(10*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.False(ok)\n\t})\n\n\tt.Run(\"exist on first condition\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\titer, duration, ok := WaitFor(alwaysTrue, 10*time.Millisecond, time.Millisecond)\n\t\tis.Equal(1, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(time.Millisecond, duration, float64(5*time.Microsecond))\n\t\tis.True(ok)\n\t})\n}\n\nfunc TestWaitForWithContext(t *testing.T) {\n\tt.Parallel()\n\n\ttestTimeout := 100 * time.Millisecond\n\tlongTimeout := 2 * testTimeout\n\tshortTimeout := 4 * time.Millisecond\n\n\tt.Run(\"exist condition works\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\tlaterTrue := func(_ context.Context, i int) bool {\n\t\t\treturn i >= 5\n\t\t}\n\n\t\titer, duration, ok := WaitForWithContext(context.Background(), laterTrue, longTimeout, time.Millisecond)\n\t\tis.Equal(6, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(6*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.True(ok)\n\t})\n\n\tt.Run(\"counter is incremented\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\tcounter := 0\n\t\talwaysFalse := func(_ context.Context, i int) bool {\n\t\t\tis.Equal(counter, i)\n\t\t\tcounter++\n\t\t\treturn false\n\t\t}\n\n\t\titer, duration, ok := WaitForWithContext(context.Background(), alwaysFalse, shortTimeout, 1050*time.Microsecond)\n\t\tis.Equal(counter, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(10*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.False(ok)\n\t})\n\n\talwaysTrue := func(_ context.Context, _ int) bool { return true }\n\talwaysFalse := func(_ context.Context, _ int) bool { return false }\n\n\tt.Run(\"short timeout works\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\titer, duration, ok := WaitForWithContext(context.Background(), alwaysFalse, shortTimeout, 10*time.Millisecond)\n\t\tis.Equal(0, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(10*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.False(ok)\n\t})\n\n\tt.Run(\"timeout works\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\tshortTimeout := 4 * time.Millisecond\n\t\titer, duration, ok := WaitForWithContext(context.Background(), alwaysFalse, shortTimeout, 10*time.Millisecond)\n\t\tis.Equal(0, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(10*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.False(ok)\n\t})\n\n\tt.Run(\"exist on first condition\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\titer, duration, ok := WaitForWithContext(context.Background(), alwaysTrue, 10*time.Millisecond, time.Millisecond)\n\t\tis.Equal(1, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(time.Millisecond, duration, float64(5*time.Microsecond))\n\t\tis.True(ok)\n\t})\n\n\tt.Run(\"context cancellation stops everything\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\texpiringCtx, clean := context.WithTimeout(context.Background(), 8*time.Millisecond)\n\t\tt.Cleanup(func() {\n\t\t\tclean()\n\t\t})\n\n\t\titer, duration, ok := WaitForWithContext(expiringCtx, alwaysFalse, 100*time.Millisecond, 3*time.Millisecond)\n\t\tis.Equal(2, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(10*time.Millisecond, duration, float64(500*time.Microsecond))\n\t\tis.False(ok)\n\t})\n\n\tt.Run(\"canceled context stops everything\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\ttestWithTimeout(t, testTimeout)\n\t\tis := assert.New(t)\n\n\t\tcanceledCtx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\n\t\titer, duration, ok := WaitForWithContext(canceledCtx, alwaysFalse, 100*time.Millisecond, 1050*time.Microsecond)\n\t\tis.Equal(0, iter, \"unexpected iteration count\")\n\t\tis.InEpsilon(1*time.Millisecond, duration, float64(5*time.Microsecond))\n\t\tis.False(ok)\n\t})\n}\n"
        },
        {
          "name": "condition.go",
          "type": "blob",
          "size": 2.6787109375,
          "content": "package lo\n\n// Ternary is a 1 line if/else statement.\n// Play: https://go.dev/play/p/t-D7WBL44h2\nfunc Ternary[T any](condition bool, ifOutput T, elseOutput T) T {\n\tif condition {\n\t\treturn ifOutput\n\t}\n\n\treturn elseOutput\n}\n\n// TernaryF is a 1 line if/else statement whose options are functions\n// Play: https://go.dev/play/p/AO4VW20JoqM\nfunc TernaryF[T any](condition bool, ifFunc func() T, elseFunc func() T) T {\n\tif condition {\n\t\treturn ifFunc()\n\t}\n\n\treturn elseFunc()\n}\n\ntype ifElse[T any] struct {\n\tresult T\n\tdone   bool\n}\n\n// If.\n// Play: https://go.dev/play/p/WSw3ApMxhyW\nfunc If[T any](condition bool, result T) *ifElse[T] {\n\tif condition {\n\t\treturn &ifElse[T]{result, true}\n\t}\n\n\tvar t T\n\treturn &ifElse[T]{t, false}\n}\n\n// IfF.\n// Play: https://go.dev/play/p/WSw3ApMxhyW\nfunc IfF[T any](condition bool, resultF func() T) *ifElse[T] {\n\tif condition {\n\t\treturn &ifElse[T]{resultF(), true}\n\t}\n\n\tvar t T\n\treturn &ifElse[T]{t, false}\n}\n\n// ElseIf.\n// Play: https://go.dev/play/p/WSw3ApMxhyW\nfunc (i *ifElse[T]) ElseIf(condition bool, result T) *ifElse[T] {\n\tif !i.done && condition {\n\t\ti.result = result\n\t\ti.done = true\n\t}\n\n\treturn i\n}\n\n// ElseIfF.\n// Play: https://go.dev/play/p/WSw3ApMxhyW\nfunc (i *ifElse[T]) ElseIfF(condition bool, resultF func() T) *ifElse[T] {\n\tif !i.done && condition {\n\t\ti.result = resultF()\n\t\ti.done = true\n\t}\n\n\treturn i\n}\n\n// Else.\n// Play: https://go.dev/play/p/WSw3ApMxhyW\nfunc (i *ifElse[T]) Else(result T) T {\n\tif i.done {\n\t\treturn i.result\n\t}\n\n\treturn result\n}\n\n// ElseF.\n// Play: https://go.dev/play/p/WSw3ApMxhyW\nfunc (i *ifElse[T]) ElseF(resultF func() T) T {\n\tif i.done {\n\t\treturn i.result\n\t}\n\n\treturn resultF()\n}\n\ntype switchCase[T comparable, R any] struct {\n\tpredicate T\n\tresult    R\n\tdone      bool\n}\n\n// Switch is a pure functional switch/case/default statement.\n// Play: https://go.dev/play/p/TGbKUMAeRUd\nfunc Switch[T comparable, R any](predicate T) *switchCase[T, R] {\n\tvar result R\n\n\treturn &switchCase[T, R]{\n\t\tpredicate,\n\t\tresult,\n\t\tfalse,\n\t}\n}\n\n// Case.\n// Play: https://go.dev/play/p/TGbKUMAeRUd\nfunc (s *switchCase[T, R]) Case(val T, result R) *switchCase[T, R] {\n\tif !s.done && s.predicate == val {\n\t\ts.result = result\n\t\ts.done = true\n\t}\n\n\treturn s\n}\n\n// CaseF.\n// Play: https://go.dev/play/p/TGbKUMAeRUd\nfunc (s *switchCase[T, R]) CaseF(val T, cb func() R) *switchCase[T, R] {\n\tif !s.done && s.predicate == val {\n\t\ts.result = cb()\n\t\ts.done = true\n\t}\n\n\treturn s\n}\n\n// Default.\n// Play: https://go.dev/play/p/TGbKUMAeRUd\nfunc (s *switchCase[T, R]) Default(result R) R {\n\tif !s.done {\n\t\ts.result = result\n\t}\n\n\treturn s.result\n}\n\n// DefaultF.\n// Play: https://go.dev/play/p/TGbKUMAeRUd\nfunc (s *switchCase[T, R]) DefaultF(cb func() R) R {\n\tif !s.done {\n\t\ts.result = cb()\n\t}\n\n\treturn s.result\n}\n"
        },
        {
          "name": "condition_example_test.go",
          "type": "blob",
          "size": 9.8212890625,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n)\n\nfunc ExampleTernary() {\n\tresult := Ternary(true, \"a\", \"b\")\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: a\n}\n\nfunc ExampleTernaryF() {\n\tresult := TernaryF(true, func() string { return \"a\" }, func() string { return \"b\" })\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: a\n}\n\nfunc ExampleIf() {\n\tresult1 := If(true, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult2 := If(false, 1).\n\t\tElseIf(true, 2).\n\t\tElse(3)\n\n\tresult3 := If(false, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult4 := IfF(true, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult5 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(true, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult6 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc ExampleIfF() {\n\tresult1 := If(true, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult2 := If(false, 1).\n\t\tElseIf(true, 2).\n\t\tElse(3)\n\n\tresult3 := If(false, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult4 := IfF(true, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult5 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(true, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult6 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_ifElse_ElseIf() {\n\tresult1 := If(true, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult2 := If(false, 1).\n\t\tElseIf(true, 2).\n\t\tElse(3)\n\n\tresult3 := If(false, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult4 := IfF(true, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult5 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(true, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult6 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_ifElse_ElseIfF() {\n\tresult1 := If(true, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult2 := If(false, 1).\n\t\tElseIf(true, 2).\n\t\tElse(3)\n\n\tresult3 := If(false, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult4 := IfF(true, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult5 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(true, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult6 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_ifElse_Else() {\n\tresult1 := If(true, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult2 := If(false, 1).\n\t\tElseIf(true, 2).\n\t\tElse(3)\n\n\tresult3 := If(false, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult4 := IfF(true, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult5 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(true, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult6 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_ifElse_ElseF() {\n\tresult1 := If(true, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult2 := If(false, 1).\n\t\tElseIf(true, 2).\n\t\tElse(3)\n\n\tresult3 := If(false, 1).\n\t\tElseIf(false, 2).\n\t\tElse(3)\n\n\tresult4 := IfF(true, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult5 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(true, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tresult6 := IfF(false, func() int { return 1 }).\n\t\tElseIfF(false, func() int { return 2 }).\n\t\tElseF(func() int { return 3 })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc ExampleSwitch() {\n\tresult1 := Switch[int, string](1).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult2 := Switch[int, string](2).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult3 := Switch[int, string](42).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult4 := Switch[int, string](1).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult5 := Switch[int, string](2).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult6 := Switch[int, string](42).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_switchCase_Case() {\n\tresult1 := Switch[int, string](1).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult2 := Switch[int, string](2).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult3 := Switch[int, string](42).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult4 := Switch[int, string](1).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult5 := Switch[int, string](2).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult6 := Switch[int, string](42).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_switchCase_CaseF() {\n\tresult1 := Switch[int, string](1).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult2 := Switch[int, string](2).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult3 := Switch[int, string](42).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult4 := Switch[int, string](1).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult5 := Switch[int, string](2).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult6 := Switch[int, string](42).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_switchCase_Default() {\n\tresult1 := Switch[int, string](1).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult2 := Switch[int, string](2).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult3 := Switch[int, string](42).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult4 := Switch[int, string](1).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult5 := Switch[int, string](2).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult6 := Switch[int, string](42).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n\nfunc Example_switchCase_DefaultF() {\n\tresult1 := Switch[int, string](1).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult2 := Switch[int, string](2).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult3 := Switch[int, string](42).\n\t\tCase(1, \"1\").\n\t\tCase(2, \"2\").\n\t\tDefault(\"3\")\n\n\tresult4 := Switch[int, string](1).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult5 := Switch[int, string](2).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tresult6 := Switch[int, string](42).\n\t\tCaseF(1, func() string { return \"1\" }).\n\t\tCaseF(2, func() string { return \"2\" }).\n\t\tDefaultF(func() string { return \"3\" })\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 1\n\t// 2\n\t// 3\n}\n"
        },
        {
          "name": "condition_test.go",
          "type": "blob",
          "size": 2.6181640625,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTernary(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Ternary(true, \"a\", \"b\")\n\tresult2 := Ternary(false, \"a\", \"b\")\n\n\tis.Equal(result1, \"a\")\n\tis.Equal(result2, \"b\")\n}\n\nfunc TestTernaryF(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult1 := TernaryF(true, func() string { return \"a\" }, func() string { return \"b\" })\n\tresult2 := TernaryF(false, func() string { return \"a\" }, func() string { return \"b\" })\n\n\tis.Equal(result1, \"a\")\n\tis.Equal(result2, \"b\")\n}\n\nfunc TestIfElse(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := If(true, 1).ElseIf(false, 2).Else(3)\n\tresult2 := If(true, 1).ElseIf(true, 2).Else(3)\n\tresult3 := If(false, 1).ElseIf(true, 2).Else(3)\n\tresult4 := If(false, 1).ElseIf(false, 2).Else(3)\n\n\tis.Equal(result1, 1)\n\tis.Equal(result2, 1)\n\tis.Equal(result3, 2)\n\tis.Equal(result4, 3)\n}\n\nfunc TestIfFElseF(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := IfF(true, func() int { return 1 }).ElseIfF(false, func() int { return 2 }).ElseF(func() int { return 3 })\n\tresult2 := IfF(true, func() int { return 1 }).ElseIfF(true, func() int { return 2 }).ElseF(func() int { return 3 })\n\tresult3 := IfF(false, func() int { return 1 }).ElseIfF(true, func() int { return 2 }).ElseF(func() int { return 3 })\n\tresult4 := IfF(false, func() int { return 1 }).ElseIfF(false, func() int { return 2 }).ElseF(func() int { return 3 })\n\n\tis.Equal(result1, 1)\n\tis.Equal(result2, 1)\n\tis.Equal(result3, 2)\n\tis.Equal(result4, 3)\n}\n\nfunc TestSwitchCase(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Switch[int, int](42).Case(42, 1).Case(1, 2).Default(3)\n\tresult2 := Switch[int, int](42).Case(42, 1).Case(42, 2).Default(3)\n\tresult3 := Switch[int, int](42).Case(1, 1).Case(42, 2).Default(3)\n\tresult4 := Switch[int, int](42).Case(1, 1).Case(1, 2).Default(3)\n\n\tis.Equal(result1, 1)\n\tis.Equal(result2, 1)\n\tis.Equal(result3, 2)\n\tis.Equal(result4, 3)\n}\n\nfunc TestSwitchCaseF(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Switch[int, int](42).CaseF(42, func() int { return 1 }).CaseF(1, func() int { return 2 }).DefaultF(func() int { return 3 })\n\tresult2 := Switch[int, int](42).CaseF(42, func() int { return 1 }).CaseF(42, func() int { return 2 }).DefaultF(func() int { return 3 })\n\tresult3 := Switch[int, int](42).CaseF(1, func() int { return 1 }).CaseF(42, func() int { return 2 }).DefaultF(func() int { return 3 })\n\tresult4 := Switch[int, int](42).CaseF(1, func() int { return 1 }).CaseF(1, func() int { return 2 }).DefaultF(func() int { return 3 })\n\n\tis.Equal(result1, 1)\n\tis.Equal(result2, 1)\n\tis.Equal(result3, 2)\n\tis.Equal(result4, 3)\n}\n"
        },
        {
          "name": "constraints.go",
          "type": "blob",
          "size": 0.1220703125,
          "content": "package lo\n\n// Clonable defines a constraint of types having Clone() T method.\ntype Clonable[T any] interface {\n\tClone() T\n}\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.1865234375,
          "content": "version: '3'\n\nservices:\n  dev:\n    image: golang:1.18-bullseye\n    volumes:\n      - ./:/go/src/github.com/samber/lo\n    working_dir: /go/src/github.com/samber/lo\n    command: make watch-test\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 9.0712890625,
          "content": "package lo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Validate is a helper that creates an error when a condition is not met.\n// Play: https://go.dev/play/p/vPyh51XpCBt\nfunc Validate(ok bool, format string, args ...any) error {\n\tif !ok {\n\t\treturn fmt.Errorf(format, args...)\n\t}\n\treturn nil\n}\n\nfunc messageFromMsgAndArgs(msgAndArgs ...any) string {\n\tif len(msgAndArgs) == 1 {\n\t\tif msgAsStr, ok := msgAndArgs[0].(string); ok {\n\t\t\treturn msgAsStr\n\t\t}\n\t\treturn fmt.Sprintf(\"%+v\", msgAndArgs[0])\n\t}\n\tif len(msgAndArgs) > 1 {\n\t\treturn fmt.Sprintf(msgAndArgs[0].(string), msgAndArgs[1:]...)\n\t}\n\treturn \"\"\n}\n\n// must panics if err is error or false.\nfunc must(err any, messageArgs ...any) {\n\tif err == nil {\n\t\treturn\n\t}\n\n\tswitch e := err.(type) {\n\tcase bool:\n\t\tif !e {\n\t\t\tmessage := messageFromMsgAndArgs(messageArgs...)\n\t\t\tif message == \"\" {\n\t\t\t\tmessage = \"not ok\"\n\t\t\t}\n\n\t\t\tpanic(message)\n\t\t}\n\n\tcase error:\n\t\tmessage := messageFromMsgAndArgs(messageArgs...)\n\t\tif message != \"\" {\n\t\t\tpanic(message + \": \" + e.Error())\n\t\t} else {\n\t\t\tpanic(e.Error())\n\t\t}\n\n\tdefault:\n\t\tpanic(\"must: invalid err type '\" + reflect.TypeOf(err).Name() + \"', should either be a bool or an error\")\n\t}\n}\n\n// Must is a helper that wraps a call to a function returning a value and an error\n// and panics if err is error or false.\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must[T any](val T, err any, messageArgs ...any) T {\n\tmust(err, messageArgs...)\n\treturn val\n}\n\n// Must0 has the same behavior as Must, but callback returns no variable.\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must0(err any, messageArgs ...any) {\n\tmust(err, messageArgs...)\n}\n\n// Must1 is an alias to Must\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must1[T any](val T, err any, messageArgs ...any) T {\n\treturn Must(val, err, messageArgs...)\n}\n\n// Must2 has the same behavior as Must, but callback returns 2 variables.\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must2[T1, T2 any](val1 T1, val2 T2, err any, messageArgs ...any) (T1, T2) {\n\tmust(err, messageArgs...)\n\treturn val1, val2\n}\n\n// Must3 has the same behavior as Must, but callback returns 3 variables.\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must3[T1, T2, T3 any](val1 T1, val2 T2, val3 T3, err any, messageArgs ...any) (T1, T2, T3) {\n\tmust(err, messageArgs...)\n\treturn val1, val2, val3\n}\n\n// Must4 has the same behavior as Must, but callback returns 4 variables.\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must4[T1, T2, T3, T4 any](val1 T1, val2 T2, val3 T3, val4 T4, err any, messageArgs ...any) (T1, T2, T3, T4) {\n\tmust(err, messageArgs...)\n\treturn val1, val2, val3, val4\n}\n\n// Must5 has the same behavior as Must, but callback returns 5 variables.\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must5[T1, T2, T3, T4, T5 any](val1 T1, val2 T2, val3 T3, val4 T4, val5 T5, err any, messageArgs ...any) (T1, T2, T3, T4, T5) {\n\tmust(err, messageArgs...)\n\treturn val1, val2, val3, val4, val5\n}\n\n// Must6 has the same behavior as Must, but callback returns 6 variables.\n// Play: https://go.dev/play/p/TMoWrRp3DyC\nfunc Must6[T1, T2, T3, T4, T5, T6 any](val1 T1, val2 T2, val3 T3, val4 T4, val5 T5, val6 T6, err any, messageArgs ...any) (T1, T2, T3, T4, T5, T6) {\n\tmust(err, messageArgs...)\n\treturn val1, val2, val3, val4, val5, val6\n}\n\n// Try calls the function and return false in case of error.\nfunc Try(callback func() error) (ok bool) {\n\tok = true\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tok = false\n\t\t}\n\t}()\n\n\terr := callback()\n\tif err != nil {\n\t\tok = false\n\t}\n\n\treturn\n}\n\n// Try0 has the same behavior as Try, but callback returns no variable.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nfunc Try0(callback func()) bool {\n\treturn Try(func() error {\n\t\tcallback()\n\t\treturn nil\n\t})\n}\n\n// Try1 is an alias to Try.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nfunc Try1(callback func() error) bool {\n\treturn Try(callback)\n}\n\n// Try2 has the same behavior as Try, but callback returns 2 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nfunc Try2[T any](callback func() (T, error)) bool {\n\treturn Try(func() error {\n\t\t_, err := callback()\n\t\treturn err\n\t})\n}\n\n// Try3 has the same behavior as Try, but callback returns 3 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nfunc Try3[T, R any](callback func() (T, R, error)) bool {\n\treturn Try(func() error {\n\t\t_, _, err := callback()\n\t\treturn err\n\t})\n}\n\n// Try4 has the same behavior as Try, but callback returns 4 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nfunc Try4[T, R, S any](callback func() (T, R, S, error)) bool {\n\treturn Try(func() error {\n\t\t_, _, _, err := callback()\n\t\treturn err\n\t})\n}\n\n// Try5 has the same behavior as Try, but callback returns 5 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nfunc Try5[T, R, S, Q any](callback func() (T, R, S, Q, error)) bool {\n\treturn Try(func() error {\n\t\t_, _, _, _, err := callback()\n\t\treturn err\n\t})\n}\n\n// Try6 has the same behavior as Try, but callback returns 6 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nfunc Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error)) bool {\n\treturn Try(func() error {\n\t\t_, _, _, _, _, err := callback()\n\t\treturn err\n\t})\n}\n\n// TryOr has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nfunc TryOr[A any](callback func() (A, error), fallbackA A) (A, bool) {\n\treturn TryOr1(callback, fallbackA)\n}\n\n// TryOr1 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nfunc TryOr1[A any](callback func() (A, error), fallbackA A) (A, bool) {\n\tok := false\n\n\tTry0(func() {\n\t\ta, err := callback()\n\t\tif err == nil {\n\t\t\tfallbackA = a\n\t\t\tok = true\n\t\t}\n\t})\n\n\treturn fallbackA, ok\n}\n\n// TryOr2 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nfunc TryOr2[A, B any](callback func() (A, B, error), fallbackA A, fallbackB B) (A, B, bool) {\n\tok := false\n\n\tTry0(func() {\n\t\ta, b, err := callback()\n\t\tif err == nil {\n\t\t\tfallbackA = a\n\t\t\tfallbackB = b\n\t\t\tok = true\n\t\t}\n\t})\n\n\treturn fallbackA, fallbackB, ok\n}\n\n// TryOr3 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nfunc TryOr3[A, B, C any](callback func() (A, B, C, error), fallbackA A, fallbackB B, fallbackC C) (A, B, C, bool) {\n\tok := false\n\n\tTry0(func() {\n\t\ta, b, c, err := callback()\n\t\tif err == nil {\n\t\t\tfallbackA = a\n\t\t\tfallbackB = b\n\t\t\tfallbackC = c\n\t\t\tok = true\n\t\t}\n\t})\n\n\treturn fallbackA, fallbackB, fallbackC, ok\n}\n\n// TryOr4 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nfunc TryOr4[A, B, C, D any](callback func() (A, B, C, D, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D) (A, B, C, D, bool) {\n\tok := false\n\n\tTry0(func() {\n\t\ta, b, c, d, err := callback()\n\t\tif err == nil {\n\t\t\tfallbackA = a\n\t\t\tfallbackB = b\n\t\t\tfallbackC = c\n\t\t\tfallbackD = d\n\t\t\tok = true\n\t\t}\n\t})\n\n\treturn fallbackA, fallbackB, fallbackC, fallbackD, ok\n}\n\n// TryOr5 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nfunc TryOr5[A, B, C, D, E any](callback func() (A, B, C, D, E, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E) (A, B, C, D, E, bool) {\n\tok := false\n\n\tTry0(func() {\n\t\ta, b, c, d, e, err := callback()\n\t\tif err == nil {\n\t\t\tfallbackA = a\n\t\t\tfallbackB = b\n\t\t\tfallbackC = c\n\t\t\tfallbackD = d\n\t\t\tfallbackE = e\n\t\t\tok = true\n\t\t}\n\t})\n\n\treturn fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, ok\n}\n\n// TryOr6 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nfunc TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n\tok := false\n\n\tTry0(func() {\n\t\ta, b, c, d, e, f, err := callback()\n\t\tif err == nil {\n\t\t\tfallbackA = a\n\t\t\tfallbackB = b\n\t\t\tfallbackC = c\n\t\t\tfallbackD = d\n\t\t\tfallbackE = e\n\t\t\tfallbackF = f\n\t\t\tok = true\n\t\t}\n\t})\n\n\treturn fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF, ok\n}\n\n// TryWithErrorValue has the same behavior as Try, but also returns value passed to panic.\n// Play: https://go.dev/play/p/Kc7afQIT2Fs\nfunc TryWithErrorValue(callback func() error) (errorValue any, ok bool) {\n\tok = true\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tok = false\n\t\t\terrorValue = r\n\t\t}\n\t}()\n\n\terr := callback()\n\tif err != nil {\n\t\tok = false\n\t\terrorValue = err\n\t}\n\n\treturn\n}\n\n// TryCatch has the same behavior as Try, but calls the catch function in case of error.\n// Play: https://go.dev/play/p/PnOON-EqBiU\nfunc TryCatch(callback func() error, catch func()) {\n\tif !Try(callback) {\n\t\tcatch()\n\t}\n}\n\n// TryCatchWithErrorValue has the same behavior as TryWithErrorValue, but calls the catch function in case of error.\n// Play: https://go.dev/play/p/8Pc9gwX_GZO\nfunc TryCatchWithErrorValue(callback func() error, catch func(any)) {\n\tif err, ok := TryWithErrorValue(callback); !ok {\n\t\tcatch(err)\n\t}\n}\n\n// ErrorsAs is a shortcut for errors.As(err, &&T).\n// Play: https://go.dev/play/p/8wk5rH8UfrE\nfunc ErrorsAs[T error](err error) (T, bool) {\n\tvar t T\n\tok := errors.As(err, &t)\n\treturn t, ok\n}\n"
        },
        {
          "name": "errors_example_test.go",
          "type": "blob",
          "size": 8.1767578125,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n)\n\nfunc ExampleValidate() {\n\ti := 42\n\n\terr1 := Validate(i < 0, \"expected %d < 0\", i)\n\terr2 := Validate(i > 0, \"expected %d > 0\", i)\n\n\tfmt.Printf(\"%v\\n%v\", err1, err2)\n\t// Output:\n\t// expected 42 < 0\n\t// <nil>\n}\n\nfunc ExampleMust() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust(42, nil)\n\n\t// won't panic\n\tcb := func() (int, error) {\n\t\treturn 42, nil\n\t}\n\tMust(cb())\n\n\t// will panic\n\tMust(42, fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust(42, fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleMust0() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust0(nil)\n\n\t// will panic\n\tMust0(fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust0(fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleMust1() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust1(42, nil)\n\n\t// won't panic\n\tcb := func() (int, error) {\n\t\treturn 42, nil\n\t}\n\tMust1(cb())\n\n\t// will panic\n\tMust1(42, fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust1(42, fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleMust2() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust2(42, \"hello\", nil)\n\n\t// will panic\n\tMust2(42, \"hello\", fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust2(42, \"hello\", fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleMust3() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust3(42, \"hello\", 4.2, nil)\n\n\t// will panic\n\tMust3(42, \"hello\", 4.2, fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust3(42, \"hello\", 4.2, fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleMust4() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust4(42, \"hello\", 4.2, true, nil)\n\n\t// will panic\n\tMust4(42, \"hello\", 4.2, true, fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust4(42, \"hello\", 4.2, true, fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleMust5() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust5(42, \"hello\", 4.2, true, foo{}, nil)\n\n\t// will panic\n\tMust5(42, \"hello\", 4.2, true, foo{}, fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust5(42, \"hello\", 4.2, true, foo{}, fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleMust6() {\n\tdefer func() {\n\t\t_ = recover()\n\t}()\n\n\t// won't panic\n\tMust5(42, \"hello\", 4.2, true, foo{}, \"foobar\", nil)\n\n\t// will panic\n\tMust5(42, \"hello\", 4.2, true, foo{}, \"foobar\", fmt.Errorf(\"my error\"))\n\n\t// will panic with error message\n\tMust5(42, \"hello\", 4.2, true, foo{}, \"foobar\", fmt.Errorf(\"world\"), \"hello\")\n}\n\nfunc ExampleTry() {\n\tok1 := Try(func() error {\n\t\treturn nil\n\t})\n\tok2 := Try(func() error {\n\t\treturn fmt.Errorf(\"my error\")\n\t})\n\tok3 := Try(func() error {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v\\n\", ok1)\n\tfmt.Printf(\"%v\\n\", ok2)\n\tfmt.Printf(\"%v\\n\", ok3)\n\t// Output:\n\t// true\n\t// false\n\t// false\n}\n\nfunc ExampleTry1() {\n\tok1 := Try1(func() error {\n\t\treturn nil\n\t})\n\tok2 := Try1(func() error {\n\t\treturn fmt.Errorf(\"my error\")\n\t})\n\tok3 := Try1(func() error {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v\\n\", ok1)\n\tfmt.Printf(\"%v\\n\", ok2)\n\tfmt.Printf(\"%v\\n\", ok3)\n\t// Output:\n\t// true\n\t// false\n\t// false\n}\n\nfunc ExampleTry2() {\n\tok1 := Try2(func() (int, error) {\n\t\treturn 42, nil\n\t})\n\tok2 := Try2(func() (int, error) {\n\t\treturn 42, fmt.Errorf(\"my error\")\n\t})\n\tok3 := Try2(func() (int, error) {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v\\n\", ok1)\n\tfmt.Printf(\"%v\\n\", ok2)\n\tfmt.Printf(\"%v\\n\", ok3)\n\t// Output:\n\t// true\n\t// false\n\t// false\n}\n\nfunc ExampleTry3() {\n\tok1 := Try3(func() (int, string, error) {\n\t\treturn 42, \"foobar\", nil\n\t})\n\tok2 := Try3(func() (int, string, error) {\n\t\treturn 42, \"foobar\", fmt.Errorf(\"my error\")\n\t})\n\tok3 := Try3(func() (int, string, error) {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v\\n\", ok1)\n\tfmt.Printf(\"%v\\n\", ok2)\n\tfmt.Printf(\"%v\\n\", ok3)\n\t// Output:\n\t// true\n\t// false\n\t// false\n}\n\nfunc ExampleTry4() {\n\tok1 := Try4(func() (int, string, float64, error) {\n\t\treturn 42, \"foobar\", 4.2, nil\n\t})\n\tok2 := Try4(func() (int, string, float64, error) {\n\t\treturn 42, \"foobar\", 4.2, fmt.Errorf(\"my error\")\n\t})\n\tok3 := Try4(func() (int, string, float64, error) {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v\\n\", ok1)\n\tfmt.Printf(\"%v\\n\", ok2)\n\tfmt.Printf(\"%v\\n\", ok3)\n\t// Output:\n\t// true\n\t// false\n\t// false\n}\n\nfunc ExampleTry5() {\n\tok1 := Try5(func() (int, string, float64, bool, error) {\n\t\treturn 42, \"foobar\", 4.2, true, nil\n\t})\n\tok2 := Try5(func() (int, string, float64, bool, error) {\n\t\treturn 42, \"foobar\", 4.2, true, fmt.Errorf(\"my error\")\n\t})\n\tok3 := Try5(func() (int, string, float64, bool, error) {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v\\n\", ok1)\n\tfmt.Printf(\"%v\\n\", ok2)\n\tfmt.Printf(\"%v\\n\", ok3)\n\t// Output:\n\t// true\n\t// false\n\t// false\n}\n\nfunc ExampleTry6() {\n\tok1 := Try6(func() (int, string, float64, bool, foo, error) {\n\t\treturn 42, \"foobar\", 4.2, true, foo{}, nil\n\t})\n\tok2 := Try6(func() (int, string, float64, bool, foo, error) {\n\t\treturn 42, \"foobar\", 4.2, true, foo{}, fmt.Errorf(\"my error\")\n\t})\n\tok3 := Try6(func() (int, string, float64, bool, foo, error) {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v\\n\", ok1)\n\tfmt.Printf(\"%v\\n\", ok2)\n\tfmt.Printf(\"%v\\n\", ok3)\n\t// Output:\n\t// true\n\t// false\n\t// false\n}\n\nfunc ExampleTryOr() {\n\tvalue1, ok1 := TryOr(func() (int, error) {\n\t\treturn 42, nil\n\t}, 21)\n\tvalue2, ok2 := TryOr(func() (int, error) {\n\t\treturn 42, fmt.Errorf(\"my error\")\n\t}, 21)\n\tvalue3, ok3 := TryOr(func() (int, error) {\n\t\tpanic(\"my error\")\n\t}, 21)\n\n\tfmt.Printf(\"%v %v\\n\", value1, ok1)\n\tfmt.Printf(\"%v %v\\n\", value2, ok2)\n\tfmt.Printf(\"%v %v\\n\", value3, ok3)\n\t// Output:\n\t// 42 true\n\t// 21 false\n\t// 21 false\n}\n\nfunc ExampleTryOr1() {\n\tvalue1, ok1 := TryOr1(func() (int, error) {\n\t\treturn 42, nil\n\t}, 21)\n\tvalue2, ok2 := TryOr1(func() (int, error) {\n\t\treturn 42, fmt.Errorf(\"my error\")\n\t}, 21)\n\tvalue3, ok3 := TryOr1(func() (int, error) {\n\t\tpanic(\"my error\")\n\t}, 21)\n\n\tfmt.Printf(\"%v %v\\n\", value1, ok1)\n\tfmt.Printf(\"%v %v\\n\", value2, ok2)\n\tfmt.Printf(\"%v %v\\n\", value3, ok3)\n\t// Output:\n\t// 42 true\n\t// 21 false\n\t// 21 false\n}\n\nfunc ExampleTryOr2() {\n\tvalue1, value2, ok3 := TryOr2(func() (int, string, error) {\n\t\tpanic(\"my error\")\n\t}, 21, \"hello\")\n\n\tfmt.Printf(\"%v %v %v\\n\", value1, value2, ok3)\n\t// Output: 21 hello false\n}\n\nfunc ExampleTryOr3() {\n\tvalue1, value2, value3, ok3 := TryOr3(func() (int, string, bool, error) {\n\t\tpanic(\"my error\")\n\t}, 21, \"hello\", false)\n\n\tfmt.Printf(\"%v %v %v %v\\n\", value1, value2, value3, ok3)\n\t// Output: 21 hello false false\n}\n\nfunc ExampleTryOr4() {\n\tvalue1, value2, value3, value4, ok3 := TryOr4(func() (int, string, bool, foo, error) {\n\t\tpanic(\"my error\")\n\t}, 21, \"hello\", false, foo{bar: \"bar\"})\n\n\tfmt.Printf(\"%v %v %v %v %v\\n\", value1, value2, value3, value4, ok3)\n\t// Output: 21 hello false {bar} false\n}\n\nfunc ExampleTryOr5() {\n\tvalue1, value2, value3, value4, value5, ok3 := TryOr5(func() (int, string, bool, foo, float64, error) {\n\t\tpanic(\"my error\")\n\t}, 21, \"hello\", false, foo{bar: \"bar\"}, 4.2)\n\n\tfmt.Printf(\"%v %v %v %v %v %v\\n\", value1, value2, value3, value4, value5, ok3)\n\t// Output: 21 hello false {bar} 4.2 false\n}\n\nfunc ExampleTryOr6() {\n\tvalue1, value2, value3, value4, value5, value6, ok3 := TryOr6(func() (int, string, bool, foo, float64, string, error) {\n\t\tpanic(\"my error\")\n\t}, 21, \"hello\", false, foo{bar: \"bar\"}, 4.2, \"world\")\n\n\tfmt.Printf(\"%v %v %v %v %v %v %v\\n\", value1, value2, value3, value4, value5, value6, ok3)\n\t// Output: 21 hello false {bar} 4.2 world false\n}\n\nfunc ExampleTryWithErrorValue() {\n\terr1, ok1 := TryWithErrorValue(func() error {\n\t\treturn nil\n\t})\n\terr2, ok2 := TryWithErrorValue(func() error {\n\t\treturn fmt.Errorf(\"my error\")\n\t})\n\terr3, ok3 := TryWithErrorValue(func() error {\n\t\tpanic(\"my error\")\n\t})\n\n\tfmt.Printf(\"%v %v\\n\", err1, ok1)\n\tfmt.Printf(\"%v %v\\n\", err2, ok2)\n\tfmt.Printf(\"%v %v\\n\", err3, ok3)\n\t// Output:\n\t// <nil> true\n\t// my error false\n\t// my error false\n}\n\nfunc ExampleTryCatchWithErrorValue() {\n\tTryCatchWithErrorValue(\n\t\tfunc() error {\n\t\t\tpanic(\"trigger an error\")\n\t\t},\n\t\tfunc(err any) {\n\t\t\tfmt.Printf(\"catch: %s\", err)\n\t\t},\n\t)\n\n\t// Output: catch: trigger an error\n}\n\ntype myError struct{}\n\nfunc (e myError) Error() string {\n\treturn \"my error\"\n}\n\nfunc ExampleErrorsAs() {\n\tdoSomething := func() error {\n\t\treturn &myError{}\n\t}\n\n\terr := doSomething()\n\n\tif rateLimitErr, ok := ErrorsAs[*myError](err); ok {\n\t\tfmt.Printf(\"is type myError, err: %s\", rateLimitErr.Error())\n\t} else {\n\t\tfmt.Printf(\"is not type myError\")\n\t}\n\n\t// Output: is type myError, err: my error\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 14.34375,
          "content": "package lo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestValidate(t *testing.T) {\n\tis := assert.New(t)\n\n\tslice := []string{\"a\"}\n\tresult1 := Validate(len(slice) == 0, \"Slice should be empty but contains %v\", slice)\n\n\tslice = []string{}\n\tresult2 := Validate(len(slice) == 0, \"Slice should be empty but contains %v\", slice)\n\n\tis.Error(result1)\n\tis.NoError(result2)\n}\n\nfunc TestMust(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal(\"foo\", Must(\"foo\", nil))\n\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\tMust(\"\", errors.New(\"something went wrong\"))\n\t})\n\tis.PanicsWithValue(\"operation shouldn't fail: something went wrong\", func() {\n\t\tMust(\"\", errors.New(\"something went wrong\"), \"operation shouldn't fail\")\n\t})\n\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\tMust(\"\", errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t})\n\n\tis.Equal(1, Must(1, true))\n\tis.PanicsWithValue(\"not ok\", func() {\n\t\tMust(1, false)\n\t})\n\tis.PanicsWithValue(\"operation shouldn't fail\", func() {\n\t\tMust(1, false, \"operation shouldn't fail\")\n\t})\n\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\tMust(1, false, \"operation shouldn't fail with %s\", \"foo\")\n\t})\n\n\tcb := func() error {\n\t\treturn assert.AnError\n\t}\n\tis.PanicsWithValue(\"operation should fail: assert.AnError general error for testing\", func() {\n\t\tMust0(cb(), \"operation should fail\")\n\t})\n\n\tis.PanicsWithValue(\"must: invalid err type 'int', should either be a bool or an error\", func() {\n\t\tMust0(0)\n\t})\n\tis.PanicsWithValue(\"must: invalid err type 'string', should either be a bool or an error\", func() {\n\t\tMust0(\"error\")\n\t})\n}\n\nfunc TestMustX(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t{\n\t\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\t\tMust0(errors.New(\"something went wrong\"))\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\t\tMust0(errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t\tis.NotPanics(func() {\n\t\t\tMust0(nil)\n\t\t})\n\t}\n\n\t{\n\t\tval1 := Must1(1, nil)\n\t\tis.Equal(1, val1)\n\t\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\t\tMust1(1, errors.New(\"something went wrong\"))\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\t\tMust1(1, errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2 := Must2(1, 2, nil)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\t\tMust2(1, 2, errors.New(\"something went wrong\"))\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\t\tMust2(1, 2, errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3 := Must3(1, 2, 3, nil)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\t\tMust3(1, 2, 3, errors.New(\"something went wrong\"))\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\t\tMust3(1, 2, 3, errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3, val4 := Must4(1, 2, 3, 4, nil)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.Equal(4, val4)\n\t\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\t\tMust4(1, 2, 3, 4, errors.New(\"something went wrong\"))\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\t\tMust4(1, 2, 3, 4, errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3, val4, val5 := Must5(1, 2, 3, 4, 5, nil)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.Equal(4, val4)\n\t\tis.Equal(5, val5)\n\t\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\t\tMust5(1, 2, 3, 4, 5, errors.New(\"something went wrong\"))\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\t\tMust5(1, 2, 3, 4, 5, errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3, val4, val5, val6 := Must6(1, 2, 3, 4, 5, 6, nil)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.Equal(4, val4)\n\t\tis.Equal(5, val5)\n\t\tis.Equal(6, val6)\n\t\tis.PanicsWithValue(\"something went wrong\", func() {\n\t\t\tMust6(1, 2, 3, 4, 5, 6, errors.New(\"something went wrong\"))\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo: something went wrong\", func() {\n\t\t\tMust6(1, 2, 3, 4, 5, 6, errors.New(\"something went wrong\"), \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tis.PanicsWithValue(\"not ok\", func() {\n\t\t\tMust0(false)\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\t\tMust0(false, \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t\tis.NotPanics(func() {\n\t\t\tMust0(true)\n\t\t})\n\t}\n\n\t{\n\t\tval1 := Must1(1, true)\n\t\tis.Equal(1, val1)\n\t\tis.PanicsWithValue(\"not ok\", func() {\n\t\t\tMust1(1, false)\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\t\tMust1(1, false, \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2 := Must2(1, 2, true)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.PanicsWithValue(\"not ok\", func() {\n\t\t\tMust2(1, 2, false)\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\t\tMust2(1, 2, false, \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3 := Must3(1, 2, 3, true)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.PanicsWithValue(\"not ok\", func() {\n\t\t\tMust3(1, 2, 3, false)\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\t\tMust3(1, 2, 3, false, \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3, val4 := Must4(1, 2, 3, 4, true)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.Equal(4, val4)\n\t\tis.PanicsWithValue(\"not ok\", func() {\n\t\t\tMust4(1, 2, 3, 4, false)\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\t\tMust4(1, 2, 3, 4, false, \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3, val4, val5 := Must5(1, 2, 3, 4, 5, true)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.Equal(4, val4)\n\t\tis.Equal(5, val5)\n\t\tis.PanicsWithValue(\"not ok\", func() {\n\t\t\tMust5(1, 2, 3, 4, 5, false)\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\t\tMust5(1, 2, 3, 4, 5, false, \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n\n\t{\n\t\tval1, val2, val3, val4, val5, val6 := Must6(1, 2, 3, 4, 5, 6, true)\n\t\tis.Equal(1, val1)\n\t\tis.Equal(2, val2)\n\t\tis.Equal(3, val3)\n\t\tis.Equal(4, val4)\n\t\tis.Equal(5, val5)\n\t\tis.Equal(6, val6)\n\t\tis.PanicsWithValue(\"not ok\", func() {\n\t\t\tMust6(1, 2, 3, 4, 5, 6, false)\n\t\t})\n\t\tis.PanicsWithValue(\"operation shouldn't fail with foo\", func() {\n\t\t\tMust6(1, 2, 3, 4, 5, 6, false, \"operation shouldn't fail with %s\", \"foo\")\n\t\t})\n\t}\n}\n\nfunc TestTry(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.False(Try(func() error {\n\t\tpanic(\"error\")\n\t}))\n\tis.True(Try(func() error {\n\t\treturn nil\n\t}))\n\tis.False(Try(func() error {\n\t\treturn fmt.Errorf(\"fail\")\n\t}))\n}\n\nfunc TestTryX(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.True(Try1(func() error {\n\t\treturn nil\n\t}))\n\n\tis.True(Try2(func() (string, error) {\n\t\treturn \"\", nil\n\t}))\n\n\tis.True(Try3(func() (string, string, error) {\n\t\treturn \"\", \"\", nil\n\t}))\n\n\tis.True(Try4(func() (string, string, string, error) {\n\t\treturn \"\", \"\", \"\", nil\n\t}))\n\n\tis.True(Try5(func() (string, string, string, string, error) {\n\t\treturn \"\", \"\", \"\", \"\", nil\n\t}))\n\n\tis.True(Try6(func() (string, string, string, string, string, error) {\n\t\treturn \"\", \"\", \"\", \"\", \"\", nil\n\t}))\n\n\tis.False(Try1(func() error {\n\t\tpanic(\"error\")\n\t}))\n\n\tis.False(Try2(func() (string, error) {\n\t\tpanic(\"error\")\n\t}))\n\n\tis.False(Try3(func() (string, string, error) {\n\t\tpanic(\"error\")\n\t}))\n\n\tis.False(Try4(func() (string, string, string, error) {\n\t\tpanic(\"error\")\n\t}))\n\n\tis.False(Try5(func() (string, string, string, string, error) {\n\t\tpanic(\"error\")\n\t}))\n\n\tis.False(Try6(func() (string, string, string, string, string, error) {\n\t\tpanic(\"error\")\n\t}))\n\n\tis.False(Try1(func() error {\n\t\treturn errors.New(\"foo\")\n\t}))\n\n\tis.False(Try2(func() (string, error) {\n\t\treturn \"\", errors.New(\"foo\")\n\t}))\n\n\tis.False(Try3(func() (string, string, error) {\n\t\treturn \"\", \"\", errors.New(\"foo\")\n\t}))\n\n\tis.False(Try4(func() (string, string, string, error) {\n\t\treturn \"\", \"\", \"\", errors.New(\"foo\")\n\t}))\n\n\tis.False(Try5(func() (string, string, string, string, error) {\n\t\treturn \"\", \"\", \"\", \"\", errors.New(\"foo\")\n\t}))\n\n\tis.False(Try6(func() (string, string, string, string, string, error) {\n\t\treturn \"\", \"\", \"\", \"\", \"\", errors.New(\"foo\")\n\t}))\n}\n\nfunc TestTryOr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\ta1, ok1 := TryOr(func() (int, error) { panic(\"error\") }, 42)\n\ta2, ok2 := TryOr(func() (int, error) { return 21, assert.AnError }, 42)\n\ta3, ok3 := TryOr(func() (int, error) { return 21, nil }, 42)\n\n\tis.Equal(42, a1)\n\tis.False(ok1)\n\n\tis.Equal(42, a2)\n\tis.False(ok2)\n\n\tis.Equal(21, a3)\n\tis.True(ok3)\n}\n\nfunc TestTryOrX(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t{\n\t\ta1, ok1 := TryOr1(func() (int, error) { panic(\"error\") }, 42)\n\t\ta2, ok2 := TryOr1(func() (int, error) { return 21, assert.AnError }, 42)\n\t\ta3, ok3 := TryOr1(func() (int, error) { return 21, nil }, 42)\n\n\t\tis.Equal(42, a1)\n\t\tis.False(ok1)\n\n\t\tis.Equal(42, a2)\n\t\tis.False(ok2)\n\n\t\tis.Equal(21, a3)\n\t\tis.True(ok3)\n\t}\n\n\t{\n\t\ta1, b1, ok1 := TryOr2(func() (int, string, error) { panic(\"error\") }, 42, \"hello\")\n\t\ta2, b2, ok2 := TryOr2(func() (int, string, error) { return 21, \"world\", assert.AnError }, 42, \"hello\")\n\t\ta3, b3, ok3 := TryOr2(func() (int, string, error) { return 21, \"world\", nil }, 42, \"hello\")\n\n\t\tis.Equal(42, a1)\n\t\tis.Equal(\"hello\", b1)\n\t\tis.False(ok1)\n\n\t\tis.Equal(42, a2)\n\t\tis.Equal(\"hello\", b2)\n\t\tis.False(ok2)\n\n\t\tis.Equal(21, a3)\n\t\tis.Equal(\"world\", b3)\n\t\tis.True(ok3)\n\t}\n\n\t{\n\t\ta1, b1, c1, ok1 := TryOr3(func() (int, string, bool, error) { panic(\"error\") }, 42, \"hello\", false)\n\t\ta2, b2, c2, ok2 := TryOr3(func() (int, string, bool, error) { return 21, \"world\", true, assert.AnError }, 42, \"hello\", false)\n\t\ta3, b3, c3, ok3 := TryOr3(func() (int, string, bool, error) { return 21, \"world\", true, nil }, 42, \"hello\", false)\n\n\t\tis.Equal(42, a1)\n\t\tis.Equal(\"hello\", b1)\n\t\tis.Equal(false, c1)\n\t\tis.False(ok1)\n\n\t\tis.Equal(42, a2)\n\t\tis.Equal(\"hello\", b2)\n\t\tis.Equal(false, c2)\n\t\tis.False(ok2)\n\n\t\tis.Equal(21, a3)\n\t\tis.Equal(\"world\", b3)\n\t\tis.Equal(true, c3)\n\t\tis.True(ok3)\n\t}\n\n\t{\n\t\ta1, b1, c1, d1, ok1 := TryOr4(func() (int, string, bool, int, error) { panic(\"error\") }, 42, \"hello\", false, 42)\n\t\ta2, b2, c2, d2, ok2 := TryOr4(func() (int, string, bool, int, error) { return 21, \"world\", true, 21, assert.AnError }, 42, \"hello\", false, 42)\n\t\ta3, b3, c3, d3, ok3 := TryOr4(func() (int, string, bool, int, error) { return 21, \"world\", true, 21, nil }, 42, \"hello\", false, 42)\n\n\t\tis.Equal(42, a1)\n\t\tis.Equal(\"hello\", b1)\n\t\tis.Equal(false, c1)\n\t\tis.Equal(42, d1)\n\t\tis.False(ok1)\n\n\t\tis.Equal(42, a2)\n\t\tis.Equal(\"hello\", b2)\n\t\tis.Equal(false, c2)\n\t\tis.Equal(42, d2)\n\t\tis.False(ok2)\n\n\t\tis.Equal(21, a3)\n\t\tis.Equal(\"world\", b3)\n\t\tis.Equal(true, c3)\n\t\tis.Equal(21, d3)\n\t\tis.True(ok3)\n\t}\n\n\t{\n\t\ta1, b1, c1, d1, e1, ok1 := TryOr5(func() (int, string, bool, int, int, error) { panic(\"error\") }, 42, \"hello\", false, 42, 42)\n\t\ta2, b2, c2, d2, e2, ok2 := TryOr5(func() (int, string, bool, int, int, error) { return 21, \"world\", true, 21, 21, assert.AnError }, 42, \"hello\", false, 42, 42)\n\t\ta3, b3, c3, d3, e3, ok3 := TryOr5(func() (int, string, bool, int, int, error) { return 21, \"world\", true, 21, 21, nil }, 42, \"hello\", false, 42, 42)\n\n\t\tis.Equal(42, a1)\n\t\tis.Equal(\"hello\", b1)\n\t\tis.Equal(false, c1)\n\t\tis.Equal(42, d1)\n\t\tis.Equal(42, e1)\n\t\tis.False(ok1)\n\n\t\tis.Equal(42, a2)\n\t\tis.Equal(\"hello\", b2)\n\t\tis.Equal(false, c2)\n\t\tis.Equal(42, d2)\n\t\tis.Equal(42, e2)\n\t\tis.False(ok2)\n\n\t\tis.Equal(21, a3)\n\t\tis.Equal(\"world\", b3)\n\t\tis.Equal(true, c3)\n\t\tis.Equal(21, d3)\n\t\tis.Equal(21, e3)\n\t\tis.True(ok3)\n\t}\n\n\t{\n\t\ta1, b1, c1, d1, e1, f1, ok1 := TryOr6(func() (int, string, bool, int, int, int, error) { panic(\"error\") }, 42, \"hello\", false, 42, 42, 42)\n\t\ta2, b2, c2, d2, e2, f2, ok2 := TryOr6(func() (int, string, bool, int, int, int, error) { return 21, \"world\", true, 21, 21, 21, assert.AnError }, 42, \"hello\", false, 42, 42, 42)\n\t\ta3, b3, c3, d3, e3, f3, ok3 := TryOr6(func() (int, string, bool, int, int, int, error) { return 21, \"world\", true, 21, 21, 21, nil }, 42, \"hello\", false, 42, 42, 42)\n\n\t\tis.Equal(42, a1)\n\t\tis.Equal(\"hello\", b1)\n\t\tis.Equal(false, c1)\n\t\tis.Equal(42, d1)\n\t\tis.Equal(42, e1)\n\t\tis.Equal(42, f1)\n\t\tis.False(ok1)\n\n\t\tis.Equal(42, a2)\n\t\tis.Equal(\"hello\", b2)\n\t\tis.Equal(false, c2)\n\t\tis.Equal(42, d2)\n\t\tis.Equal(42, e2)\n\t\tis.Equal(42, f2)\n\t\tis.False(ok2)\n\n\t\tis.Equal(21, a3)\n\t\tis.Equal(\"world\", b3)\n\t\tis.Equal(true, c3)\n\t\tis.Equal(21, d3)\n\t\tis.Equal(21, e3)\n\t\tis.Equal(21, f3)\n\t\tis.True(ok3)\n\t}\n}\n\nfunc TestTryWithErrorValue(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\terr, ok := TryWithErrorValue(func() error {\n\t\t// getting error in case of panic, using recover function\n\t\tpanic(\"error\")\n\t})\n\tis.False(ok)\n\tis.Equal(\"error\", err)\n\n\terr, ok = TryWithErrorValue(func() error {\n\t\treturn errors.New(\"foo\")\n\t})\n\tis.False(ok)\n\tis.EqualError(err.(error), \"foo\")\n\n\terr, ok = TryWithErrorValue(func() error {\n\t\treturn nil\n\t})\n\tis.True(ok)\n\tis.Equal(nil, err)\n}\n\nfunc TestTryCatch(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tcaught := false\n\tTryCatch(func() error {\n\t\tpanic(\"error\")\n\t}, func() {\n\t\t// error was caught\n\t\tcaught = true\n\t})\n\tis.True(caught)\n\n\tcaught = false\n\tTryCatch(func() error {\n\t\treturn nil\n\t}, func() {\n\t\t// no error to be caught\n\t\tcaught = true\n\t})\n\tis.False(caught)\n}\n\nfunc TestTryCatchWithErrorValue(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tcaught := false\n\tTryCatchWithErrorValue(func() error {\n\t\tpanic(\"error\")\n\t}, func(val any) {\n\t\t// error was caught\n\t\tcaught = val == \"error\"\n\t})\n\tis.True(caught)\n\n\tcaught = false\n\tTryCatchWithErrorValue(func() error {\n\t\treturn nil\n\t}, func(val any) {\n\t\t// no error to be caught\n\t\tcaught = true\n\t})\n\tis.False(caught)\n}\n\ntype internalError struct {\n\tfoobar string\n}\n\nfunc (e *internalError) Error() string {\n\treturn \"internal error\"\n}\n\nfunc TestErrorsAs(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\terr, ok := ErrorsAs[*internalError](fmt.Errorf(\"hello world\"))\n\tis.False(ok)\n\tis.Nil(nil, err)\n\n\terr, ok = ErrorsAs[*internalError](&internalError{foobar: \"foobar\"})\n\tis.True(ok)\n\tis.Equal(&internalError{foobar: \"foobar\"}, err)\n\n\terr, ok = ErrorsAs[*internalError](nil)\n\tis.False(ok)\n\tis.Nil(nil, err)\n}\n"
        },
        {
          "name": "find.go",
          "type": "blob",
          "size": 11.5732421875,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/samber/lo/internal/constraints\"\n\t\"github.com/samber/lo/internal/rand\"\n)\n\n// IndexOf returns the index at which the first occurrence of a value is found in an array or return -1\n// if the value cannot be found.\nfunc IndexOf[T comparable](collection []T, element T) int {\n\tfor i := range collection {\n\t\tif collection[i] == element {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n\n// LastIndexOf returns the index at which the last occurrence of a value is found in an array or return -1\n// if the value cannot be found.\nfunc LastIndexOf[T comparable](collection []T, element T) int {\n\tlength := len(collection)\n\n\tfor i := length - 1; i >= 0; i-- {\n\t\tif collection[i] == element {\n\t\t\treturn i\n\t\t}\n\t}\n\n\treturn -1\n}\n\n// Find search an element in a slice based on a predicate. It returns element and true if element was found.\nfunc Find[T any](collection []T, predicate func(item T) bool) (T, bool) {\n\tfor i := range collection {\n\t\tif predicate(collection[i]) {\n\t\t\treturn collection[i], true\n\t\t}\n\t}\n\n\tvar result T\n\treturn result, false\n}\n\n// FindIndexOf searches an element in a slice based on a predicate and returns the index and true.\n// It returns -1 and false if the element is not found.\nfunc FindIndexOf[T any](collection []T, predicate func(item T) bool) (T, int, bool) {\n\tfor i := range collection {\n\t\tif predicate(collection[i]) {\n\t\t\treturn collection[i], i, true\n\t\t}\n\t}\n\n\tvar result T\n\treturn result, -1, false\n}\n\n// FindLastIndexOf searches last element in a slice based on a predicate and returns the index and true.\n// It returns -1 and false if the element is not found.\nfunc FindLastIndexOf[T any](collection []T, predicate func(item T) bool) (T, int, bool) {\n\tlength := len(collection)\n\n\tfor i := length - 1; i >= 0; i-- {\n\t\tif predicate(collection[i]) {\n\t\t\treturn collection[i], i, true\n\t\t}\n\t}\n\n\tvar result T\n\treturn result, -1, false\n}\n\n// FindOrElse search an element in a slice based on a predicate. It returns the element if found or a given fallback value otherwise.\nfunc FindOrElse[T any](collection []T, fallback T, predicate func(item T) bool) T {\n\tfor i := range collection {\n\t\tif predicate(collection[i]) {\n\t\t\treturn collection[i]\n\t\t}\n\t}\n\n\treturn fallback\n}\n\n// FindKey returns the key of the first value matching.\nfunc FindKey[K comparable, V comparable](object map[K]V, value V) (K, bool) {\n\tfor k := range object {\n\t\tif object[k] == value {\n\t\t\treturn k, true\n\t\t}\n\t}\n\n\treturn Empty[K](), false\n}\n\n// FindKeyBy returns the key of the first element predicate returns truthy for.\nfunc FindKeyBy[K comparable, V any](object map[K]V, predicate func(key K, value V) bool) (K, bool) {\n\tfor k := range object {\n\t\tif predicate(k, object[k]) {\n\t\t\treturn k, true\n\t\t}\n\t}\n\n\treturn Empty[K](), false\n}\n\n// FindUniques returns a slice with all the unique elements of the collection.\n// The order of result values is determined by the order they occur in the collection.\nfunc FindUniques[T comparable, Slice ~[]T](collection Slice) Slice {\n\tisDupl := make(map[T]bool, len(collection))\n\n\tfor i := range collection {\n\t\tduplicated, ok := isDupl[collection[i]]\n\t\tif !ok {\n\t\t\tisDupl[collection[i]] = false\n\t\t} else if !duplicated {\n\t\t\tisDupl[collection[i]] = true\n\t\t}\n\t}\n\n\tresult := make(Slice, 0, len(collection)-len(isDupl))\n\n\tfor i := range collection {\n\t\tif duplicated := isDupl[collection[i]]; !duplicated {\n\t\t\tresult = append(result, collection[i])\n\t\t}\n\t}\n\n\treturn result\n}\n\n// FindUniquesBy returns a slice with all the unique elements of the collection.\n// The order of result values is determined by the order they occur in the array. It accepts `iteratee` which is\n// invoked for each element in array to generate the criterion by which uniqueness is computed.\nfunc FindUniquesBy[T any, U comparable, Slice ~[]T](collection Slice, iteratee func(item T) U) Slice {\n\tisDupl := make(map[U]bool, len(collection))\n\n\tfor i := range collection {\n\t\tkey := iteratee(collection[i])\n\n\t\tduplicated, ok := isDupl[key]\n\t\tif !ok {\n\t\t\tisDupl[key] = false\n\t\t} else if !duplicated {\n\t\t\tisDupl[key] = true\n\t\t}\n\t}\n\n\tresult := make(Slice, 0, len(collection)-len(isDupl))\n\n\tfor i := range collection {\n\t\tkey := iteratee(collection[i])\n\n\t\tif duplicated := isDupl[key]; !duplicated {\n\t\t\tresult = append(result, collection[i])\n\t\t}\n\t}\n\n\treturn result\n}\n\n// FindDuplicates returns a slice with the first occurrence of each duplicated elements of the collection.\n// The order of result values is determined by the order they occur in the collection.\nfunc FindDuplicates[T comparable, Slice ~[]T](collection Slice) Slice {\n\tisDupl := make(map[T]bool, len(collection))\n\n\tfor i := range collection {\n\t\tduplicated, ok := isDupl[collection[i]]\n\t\tif !ok {\n\t\t\tisDupl[collection[i]] = false\n\t\t} else if !duplicated {\n\t\t\tisDupl[collection[i]] = true\n\t\t}\n\t}\n\n\tresult := make(Slice, 0, len(collection)-len(isDupl))\n\n\tfor i := range collection {\n\t\tif duplicated := isDupl[collection[i]]; duplicated {\n\t\t\tresult = append(result, collection[i])\n\t\t\tisDupl[collection[i]] = false\n\t\t}\n\t}\n\n\treturn result\n}\n\n// FindDuplicatesBy returns a slice with the first occurrence of each duplicated elements of the collection.\n// The order of result values is determined by the order they occur in the array. It accepts `iteratee` which is\n// invoked for each element in array to generate the criterion by which uniqueness is computed.\nfunc FindDuplicatesBy[T any, U comparable, Slice ~[]T](collection Slice, iteratee func(item T) U) Slice {\n\tisDupl := make(map[U]bool, len(collection))\n\n\tfor i := range collection {\n\t\tkey := iteratee(collection[i])\n\n\t\tduplicated, ok := isDupl[key]\n\t\tif !ok {\n\t\t\tisDupl[key] = false\n\t\t} else if !duplicated {\n\t\t\tisDupl[key] = true\n\t\t}\n\t}\n\n\tresult := make(Slice, 0, len(collection)-len(isDupl))\n\n\tfor i := range collection {\n\t\tkey := iteratee(collection[i])\n\n\t\tif duplicated := isDupl[key]; duplicated {\n\t\t\tresult = append(result, collection[i])\n\t\t\tisDupl[key] = false\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Min search the minimum value of a collection.\n// Returns zero value when the collection is empty.\nfunc Min[T constraints.Ordered](collection []T) T {\n\tvar min T\n\n\tif len(collection) == 0 {\n\t\treturn min\n\t}\n\n\tmin = collection[0]\n\n\tfor i := 1; i < len(collection); i++ {\n\t\titem := collection[i]\n\n\t\tif item < min {\n\t\t\tmin = item\n\t\t}\n\t}\n\n\treturn min\n}\n\n// MinBy search the minimum value of a collection using the given comparison function.\n// If several values of the collection are equal to the smallest value, returns the first such value.\n// Returns zero value when the collection is empty.\nfunc MinBy[T any](collection []T, comparison func(a T, b T) bool) T {\n\tvar min T\n\n\tif len(collection) == 0 {\n\t\treturn min\n\t}\n\n\tmin = collection[0]\n\n\tfor i := 1; i < len(collection); i++ {\n\t\titem := collection[i]\n\n\t\tif comparison(item, min) {\n\t\t\tmin = item\n\t\t}\n\t}\n\n\treturn min\n}\n\n// Earliest search the minimum time.Time of a collection.\n// Returns zero value when the collection is empty.\nfunc Earliest(times ...time.Time) time.Time {\n\tvar min time.Time\n\n\tif len(times) == 0 {\n\t\treturn min\n\t}\n\n\tmin = times[0]\n\n\tfor i := 1; i < len(times); i++ {\n\t\titem := times[i]\n\n\t\tif item.Before(min) {\n\t\t\tmin = item\n\t\t}\n\t}\n\n\treturn min\n}\n\n// EarliestBy search the minimum time.Time of a collection using the given iteratee function.\n// Returns zero value when the collection is empty.\nfunc EarliestBy[T any](collection []T, iteratee func(item T) time.Time) T {\n\tvar earliest T\n\n\tif len(collection) == 0 {\n\t\treturn earliest\n\t}\n\n\tearliest = collection[0]\n\tearliestTime := iteratee(collection[0])\n\n\tfor i := 1; i < len(collection); i++ {\n\t\titemTime := iteratee(collection[i])\n\n\t\tif itemTime.Before(earliestTime) {\n\t\t\tearliest = collection[i]\n\t\t\tearliestTime = itemTime\n\t\t}\n\t}\n\n\treturn earliest\n}\n\n// Max searches the maximum value of a collection.\n// Returns zero value when the collection is empty.\nfunc Max[T constraints.Ordered](collection []T) T {\n\tvar max T\n\n\tif len(collection) == 0 {\n\t\treturn max\n\t}\n\n\tmax = collection[0]\n\n\tfor i := 1; i < len(collection); i++ {\n\t\titem := collection[i]\n\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\n\treturn max\n}\n\n// MaxBy search the maximum value of a collection using the given comparison function.\n// If several values of the collection are equal to the greatest value, returns the first such value.\n// Returns zero value when the collection is empty.\nfunc MaxBy[T any](collection []T, comparison func(a T, b T) bool) T {\n\tvar max T\n\n\tif len(collection) == 0 {\n\t\treturn max\n\t}\n\n\tmax = collection[0]\n\n\tfor i := 1; i < len(collection); i++ {\n\t\titem := collection[i]\n\n\t\tif comparison(item, max) {\n\t\t\tmax = item\n\t\t}\n\t}\n\n\treturn max\n}\n\n// Latest search the maximum time.Time of a collection.\n// Returns zero value when the collection is empty.\nfunc Latest(times ...time.Time) time.Time {\n\tvar max time.Time\n\n\tif len(times) == 0 {\n\t\treturn max\n\t}\n\n\tmax = times[0]\n\n\tfor i := 1; i < len(times); i++ {\n\t\titem := times[i]\n\n\t\tif item.After(max) {\n\t\t\tmax = item\n\t\t}\n\t}\n\n\treturn max\n}\n\n// LatestBy search the maximum time.Time of a collection using the given iteratee function.\n// Returns zero value when the collection is empty.\nfunc LatestBy[T any](collection []T, iteratee func(item T) time.Time) T {\n\tvar latest T\n\n\tif len(collection) == 0 {\n\t\treturn latest\n\t}\n\n\tlatest = collection[0]\n\tlatestTime := iteratee(collection[0])\n\n\tfor i := 1; i < len(collection); i++ {\n\t\titemTime := iteratee(collection[i])\n\n\t\tif itemTime.After(latestTime) {\n\t\t\tlatest = collection[i]\n\t\t\tlatestTime = itemTime\n\t\t}\n\t}\n\n\treturn latest\n}\n\n// First returns the first element of a collection and check for availability of the first element.\nfunc First[T any](collection []T) (T, bool) {\n\tlength := len(collection)\n\n\tif length == 0 {\n\t\tvar t T\n\t\treturn t, false\n\t}\n\n\treturn collection[0], true\n}\n\n// FirstOrEmpty returns the first element of a collection or zero value if empty.\nfunc FirstOrEmpty[T any](collection []T) T {\n\ti, _ := First(collection)\n\treturn i\n}\n\n// FirstOr returns the first element of a collection or the fallback value if empty.\nfunc FirstOr[T any](collection []T, fallback T) T {\n\ti, ok := First(collection)\n\tif !ok {\n\t\treturn fallback\n\t}\n\n\treturn i\n}\n\n// Last returns the last element of a collection or error if empty.\nfunc Last[T any](collection []T) (T, bool) {\n\tlength := len(collection)\n\n\tif length == 0 {\n\t\tvar t T\n\t\treturn t, false\n\t}\n\n\treturn collection[length-1], true\n}\n\n// LastOrEmpty returns the last element of a collection or zero value if empty.\nfunc LastOrEmpty[T any](collection []T) T {\n\ti, _ := Last(collection)\n\treturn i\n}\n\n// LastOr returns the last element of a collection or the fallback value if empty.\nfunc LastOr[T any](collection []T, fallback T) T {\n\ti, ok := Last(collection)\n\tif !ok {\n\t\treturn fallback\n\t}\n\n\treturn i\n}\n\n// Nth returns the element at index `nth` of collection. If `nth` is negative, the nth element\n// from the end is returned. An error is returned when nth is out of slice bounds.\nfunc Nth[T any, N constraints.Integer](collection []T, nth N) (T, error) {\n\tn := int(nth)\n\tl := len(collection)\n\tif n >= l || -n > l {\n\t\tvar t T\n\t\treturn t, fmt.Errorf(\"nth: %d out of slice bounds\", n)\n\t}\n\n\tif n >= 0 {\n\t\treturn collection[n], nil\n\t}\n\treturn collection[l+n], nil\n}\n\n// Sample returns a random item from collection.\nfunc Sample[T any](collection []T) T {\n\tsize := len(collection)\n\tif size == 0 {\n\t\treturn Empty[T]()\n\t}\n\n\treturn collection[rand.IntN(size)]\n}\n\n// Samples returns N random unique items from collection.\nfunc Samples[T any, Slice ~[]T](collection Slice, count int) Slice {\n\tsize := len(collection)\n\n\tcopy := append(Slice{}, collection...)\n\n\tresults := Slice{}\n\n\tfor i := 0; i < size && i < count; i++ {\n\t\tcopyLength := size - i\n\n\t\tindex := rand.IntN(size - i)\n\t\tresults = append(results, copy[index])\n\n\t\t// Removes element.\n\t\t// It is faster to swap with last element and remove it.\n\t\tcopy[index] = copy[copyLength-1]\n\t\tcopy = copy[:copyLength-1]\n\t}\n\n\treturn results\n}\n"
        },
        {
          "name": "find_test.go",
          "type": "blob",
          "size": 11.9013671875,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIndexOf(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := IndexOf([]int{0, 1, 2, 1, 2, 3}, 2)\n\tresult2 := IndexOf([]int{0, 1, 2, 1, 2, 3}, 6)\n\n\tis.Equal(result1, 2)\n\tis.Equal(result2, -1)\n}\n\nfunc TestLastIndexOf(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := LastIndexOf([]int{0, 1, 2, 1, 2, 3}, 2)\n\tresult2 := LastIndexOf([]int{0, 1, 2, 1, 2, 3}, 6)\n\n\tis.Equal(result1, 4)\n\tis.Equal(result2, -1)\n}\n\nfunc TestFind(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tindex := 0\n\tresult1, ok1 := Find([]string{\"a\", \"b\", \"c\", \"d\"}, func(item string) bool {\n\t\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\"}[index], item)\n\t\tindex++\n\t\treturn item == \"b\"\n\t})\n\n\tresult2, ok2 := Find([]string{\"foobar\"}, func(item string) bool {\n\t\tis.Equal(\"foobar\", item)\n\t\treturn item == \"b\"\n\t})\n\n\tis.Equal(ok1, true)\n\tis.Equal(result1, \"b\")\n\tis.Equal(ok2, false)\n\tis.Equal(result2, \"\")\n}\n\nfunc TestFindIndexOf(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tindex := 0\n\titem1, index1, ok1 := FindIndexOf([]string{\"a\", \"b\", \"c\", \"d\", \"b\"}, func(item string) bool {\n\t\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\", \"b\"}[index], item)\n\t\tindex++\n\t\treturn item == \"b\"\n\t})\n\titem2, index2, ok2 := FindIndexOf([]string{\"foobar\"}, func(item string) bool {\n\t\tis.Equal(\"foobar\", item)\n\t\treturn item == \"b\"\n\t})\n\n\tis.Equal(item1, \"b\")\n\tis.Equal(ok1, true)\n\tis.Equal(index1, 1)\n\tis.Equal(item2, \"\")\n\tis.Equal(ok2, false)\n\tis.Equal(index2, -1)\n}\n\nfunc TestFindLastIndexOf(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tindex := 0\n\titem1, index1, ok1 := FindLastIndexOf([]string{\"a\", \"b\", \"c\", \"d\", \"b\"}, func(item string) bool {\n\t\tis.Equal([]string{\"b\", \"d\", \"c\", \"b\", \"a\"}[index], item)\n\t\tindex++\n\t\treturn item == \"b\"\n\t})\n\titem2, index2, ok2 := FindLastIndexOf([]string{\"foobar\"}, func(item string) bool {\n\t\tis.Equal(\"foobar\", item)\n\t\treturn item == \"b\"\n\t})\n\n\tis.Equal(item1, \"b\")\n\tis.Equal(ok1, true)\n\tis.Equal(index1, 4)\n\tis.Equal(item2, \"\")\n\tis.Equal(ok2, false)\n\tis.Equal(index2, -1)\n}\n\nfunc TestFindOrElse(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tindex := 0\n\tresult1 := FindOrElse([]string{\"a\", \"b\", \"c\", \"d\"}, \"x\", func(item string) bool {\n\t\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\"}[index], item)\n\t\tindex++\n\t\treturn item == \"b\"\n\t})\n\tresult2 := FindOrElse([]string{\"foobar\"}, \"x\", func(item string) bool {\n\t\tis.Equal(\"foobar\", item)\n\t\treturn item == \"b\"\n\t})\n\n\tis.Equal(result1, \"b\")\n\tis.Equal(result2, \"x\")\n}\n\nfunc TestFindKey(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1, ok1 := FindKey(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, 2)\n\tis.Equal(\"bar\", result1)\n\tis.True(ok1)\n\n\tresult2, ok2 := FindKey(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, 42)\n\tis.Equal(\"\", result2)\n\tis.False(ok2)\n\n\ttype test struct {\n\t\tfoobar string\n\t}\n\n\tresult3, ok3 := FindKey(map[string]test{\"foo\": {\"foo\"}, \"bar\": {\"bar\"}, \"baz\": {\"baz\"}}, test{\"foo\"})\n\tis.Equal(\"foo\", result3)\n\tis.True(ok3)\n\n\tresult4, ok4 := FindKey(map[string]test{\"foo\": {\"foo\"}, \"bar\": {\"bar\"}, \"baz\": {\"baz\"}}, test{\"hello world\"})\n\tis.Equal(\"\", result4)\n\tis.False(ok4)\n}\n\nfunc TestFindKeyBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1, ok1 := FindKeyBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(k string, v int) bool {\n\t\treturn k == \"foo\"\n\t})\n\tis.Equal(\"foo\", result1)\n\tis.True(ok1)\n\n\tresult2, ok2 := FindKeyBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(k string, v int) bool {\n\t\treturn false\n\t})\n\tis.Equal(\"\", result2)\n\tis.False(ok2)\n}\n\nfunc TestFindUniques(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := FindUniques([]int{1, 2, 3})\n\n\tis.Equal(3, len(result1))\n\tis.Equal([]int{1, 2, 3}, result1)\n\n\tresult2 := FindUniques([]int{1, 2, 2, 3, 1, 2})\n\n\tis.Equal(1, len(result2))\n\tis.Equal([]int{3}, result2)\n\n\tresult3 := FindUniques([]int{1, 2, 2, 1})\n\n\tis.Equal(0, len(result3))\n\tis.Equal([]int{}, result3)\n\n\tresult4 := FindUniques([]int{})\n\n\tis.Equal(0, len(result4))\n\tis.Equal([]int{}, result4)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := FindUniques(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestFindUniquesBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := FindUniquesBy([]int{0, 1, 2}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(3, len(result1))\n\tis.Equal([]int{0, 1, 2}, result1)\n\n\tresult2 := FindUniquesBy([]int{0, 1, 2, 3, 4}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(1, len(result2))\n\tis.Equal([]int{2}, result2)\n\n\tresult3 := FindUniquesBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(0, len(result3))\n\tis.Equal([]int{}, result3)\n\n\tresult4 := FindUniquesBy([]int{}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(0, len(result4))\n\tis.Equal([]int{}, result4)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := FindUniquesBy(allStrings, func(i string) string {\n\t\treturn i\n\t})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestFindDuplicates(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := FindDuplicates([]int{1, 2, 2, 1, 2, 3})\n\n\tis.Equal(2, len(result1))\n\tis.Equal([]int{1, 2}, result1)\n\n\tresult2 := FindDuplicates([]int{1, 2, 3})\n\n\tis.Equal(0, len(result2))\n\tis.Equal([]int{}, result2)\n\n\tresult3 := FindDuplicates([]int{})\n\n\tis.Equal(0, len(result3))\n\tis.Equal([]int{}, result3)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := FindDuplicates(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestFindDuplicatesBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := FindDuplicatesBy([]int{3, 4, 5, 6, 7}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(2, len(result1))\n\tis.Equal([]int{3, 4}, result1)\n\n\tresult2 := FindDuplicatesBy([]int{0, 1, 2, 3, 4}, func(i int) int {\n\t\treturn i % 5\n\t})\n\n\tis.Equal(0, len(result2))\n\tis.Equal([]int{}, result2)\n\n\tresult3 := FindDuplicatesBy([]int{}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(0, len(result3))\n\tis.Equal([]int{}, result3)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := FindDuplicatesBy(allStrings, func(i string) string {\n\t\treturn i\n\t})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestMin(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Min([]int{1, 2, 3})\n\tresult2 := Min([]int{3, 2, 1})\n\tresult3 := Min([]time.Duration{time.Second, time.Minute, time.Hour})\n\tresult4 := Min([]int{})\n\n\tis.Equal(result1, 1)\n\tis.Equal(result2, 1)\n\tis.Equal(result3, time.Second)\n\tis.Equal(result4, 0)\n}\n\nfunc TestMinBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := MinBy([]string{\"s1\", \"string2\", \"s3\"}, func(item string, min string) bool {\n\t\treturn len(item) < len(min)\n\t})\n\tresult2 := MinBy([]string{\"string1\", \"string2\", \"s3\"}, func(item string, min string) bool {\n\t\treturn len(item) < len(min)\n\t})\n\tresult3 := MinBy([]string{}, func(item string, min string) bool {\n\t\treturn len(item) < len(min)\n\t})\n\n\tis.Equal(result1, \"s1\")\n\tis.Equal(result2, \"s3\")\n\tis.Equal(result3, \"\")\n}\n\nfunc TestEarliest(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\ta := time.Now()\n\tb := a.Add(time.Hour)\n\tresult1 := Earliest(a, b)\n\tresult2 := Earliest()\n\n\tis.Equal(result1, a)\n\tis.Equal(result2, time.Time{})\n}\n\nfunc TestEarliestBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar time.Time\n\t}\n\n\tt1 := time.Now()\n\tt2 := t1.Add(time.Hour)\n\tt3 := t1.Add(-time.Hour)\n\tresult1 := EarliestBy([]foo{{t1}, {t2}, {t3}}, func(i foo) time.Time {\n\t\treturn i.bar\n\t})\n\tresult2 := EarliestBy([]foo{{t1}}, func(i foo) time.Time {\n\t\treturn i.bar\n\t})\n\tresult3 := EarliestBy([]foo{}, func(i foo) time.Time {\n\t\treturn i.bar\n\t})\n\n\tis.Equal(result1, foo{t3})\n\tis.Equal(result2, foo{t1})\n\tis.Equal(result3, foo{})\n}\n\nfunc TestMax(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Max([]int{1, 2, 3})\n\tresult2 := Max([]int{3, 2, 1})\n\tresult3 := Max([]time.Duration{time.Second, time.Minute, time.Hour})\n\tresult4 := Max([]int{})\n\n\tis.Equal(result1, 3)\n\tis.Equal(result2, 3)\n\tis.Equal(result3, time.Hour)\n\tis.Equal(result4, 0)\n}\n\nfunc TestMaxBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := MaxBy([]string{\"s1\", \"string2\", \"s3\"}, func(item string, max string) bool {\n\t\treturn len(item) > len(max)\n\t})\n\tresult2 := MaxBy([]string{\"string1\", \"string2\", \"s3\"}, func(item string, max string) bool {\n\t\treturn len(item) > len(max)\n\t})\n\tresult3 := MaxBy([]string{}, func(item string, max string) bool {\n\t\treturn len(item) > len(max)\n\t})\n\n\tis.Equal(result1, \"string2\")\n\tis.Equal(result2, \"string1\")\n\tis.Equal(result3, \"\")\n}\n\nfunc TestLatest(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\ta := time.Now()\n\tb := a.Add(time.Hour)\n\tresult1 := Latest(a, b)\n\tresult2 := Latest()\n\n\tis.Equal(result1, b)\n\tis.Equal(result2, time.Time{})\n}\n\nfunc TestLatestBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\ttype foo struct {\n\t\tbar time.Time\n\t}\n\n\tt1 := time.Now()\n\tt2 := t1.Add(time.Hour)\n\tt3 := t1.Add(-time.Hour)\n\tresult1 := LatestBy([]foo{{t1}, {t2}, {t3}}, func(i foo) time.Time {\n\t\treturn i.bar\n\t})\n\tresult2 := LatestBy([]foo{{t1}}, func(i foo) time.Time {\n\t\treturn i.bar\n\t})\n\tresult3 := LatestBy([]foo{}, func(i foo) time.Time {\n\t\treturn i.bar\n\t})\n\n\tis.Equal(result1, foo{t2})\n\tis.Equal(result2, foo{t1})\n\tis.Equal(result3, foo{})\n}\n\nfunc TestFirst(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1, ok1 := First([]int{1, 2, 3})\n\tresult2, ok2 := First([]int{})\n\n\tis.Equal(result1, 1)\n\tis.Equal(ok1, true)\n\tis.Equal(result2, 0)\n\tis.Equal(ok2, false)\n}\n\nfunc TestFirstOrEmpty(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := FirstOrEmpty([]int{1, 2, 3})\n\tresult2 := FirstOrEmpty([]int{})\n\tresult3 := FirstOrEmpty([]string{})\n\n\tis.Equal(result1, 1)\n\tis.Equal(result2, 0)\n\tis.Equal(result3, \"\")\n}\n\nfunc TestFirstOr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := FirstOr([]int{1, 2, 3}, 63)\n\tresult2 := FirstOr([]int{}, 23)\n\tresult3 := FirstOr([]string{}, \"test\")\n\n\tis.Equal(result1, 1)\n\tis.Equal(result2, 23)\n\tis.Equal(result3, \"test\")\n}\n\nfunc TestLast(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1, ok1 := Last([]int{1, 2, 3})\n\tresult2, ok2 := Last([]int{})\n\n\tis.Equal(result1, 3)\n\tis.True(ok1)\n\tis.Equal(result2, 0)\n\tis.False(ok2)\n}\n\nfunc TestLastOrEmpty(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := LastOrEmpty([]int{1, 2, 3})\n\tresult2 := LastOrEmpty([]int{})\n\tresult3 := LastOrEmpty([]string{})\n\n\tis.Equal(result1, 3)\n\tis.Equal(result2, 0)\n\tis.Equal(result3, \"\")\n}\n\nfunc TestLastOr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := LastOr([]int{1, 2, 3}, 63)\n\tresult2 := LastOr([]int{}, 23)\n\tresult3 := LastOr([]string{}, \"test\")\n\n\tis.Equal(result1, 3)\n\tis.Equal(result2, 23)\n\tis.Equal(result3, \"test\")\n}\n\nfunc TestNth(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1, err1 := Nth([]int{0, 1, 2, 3}, 2)\n\tresult2, err2 := Nth([]int{0, 1, 2, 3}, -2)\n\tresult3, err3 := Nth([]int{0, 1, 2, 3}, 42)\n\tresult4, err4 := Nth([]int{}, 0)\n\tresult5, err5 := Nth([]int{42}, 0)\n\tresult6, err6 := Nth([]int{42}, -1)\n\n\tis.Equal(result1, 2)\n\tis.Equal(err1, nil)\n\tis.Equal(result2, 2)\n\tis.Equal(err2, nil)\n\tis.Equal(result3, 0)\n\tis.Equal(err3, fmt.Errorf(\"nth: 42 out of slice bounds\"))\n\tis.Equal(result4, 0)\n\tis.Equal(err4, fmt.Errorf(\"nth: 0 out of slice bounds\"))\n\tis.Equal(result5, 42)\n\tis.Equal(err5, nil)\n\tis.Equal(result6, 42)\n\tis.Equal(err6, nil)\n}\n\nfunc TestSample(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\trand.Seed(time.Now().UnixNano())\n\n\tresult1 := Sample([]string{\"a\", \"b\", \"c\"})\n\tresult2 := Sample([]string{})\n\n\tis.True(Contains([]string{\"a\", \"b\", \"c\"}, result1))\n\tis.Equal(result2, \"\")\n}\n\nfunc TestSamples(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\trand.Seed(time.Now().UnixNano())\n\n\tresult1 := Samples([]string{\"a\", \"b\", \"c\"}, 3)\n\tresult2 := Samples([]string{}, 3)\n\n\tsort.Strings(result1)\n\n\tis.Equal(result1, []string{\"a\", \"b\", \"c\"})\n\tis.Equal(result2, []string{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Samples(allStrings, 2)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n"
        },
        {
          "name": "func.go",
          "type": "blob",
          "size": 1.5146484375,
          "content": "package lo\n\n// Partial returns new function that, when called, has its first argument set to the provided value.\nfunc Partial[T1, T2, R any](f func(a T1, b T2) R, arg1 T1) func(T2) R {\n\treturn func(t2 T2) R {\n\t\treturn f(arg1, t2)\n\t}\n}\n\n// Partial1 returns new function that, when called, has its first argument set to the provided value.\nfunc Partial1[T1, T2, R any](f func(T1, T2) R, arg1 T1) func(T2) R {\n\treturn Partial(f, arg1)\n}\n\n// Partial2 returns new function that, when called, has its first argument set to the provided value.\nfunc Partial2[T1, T2, T3, R any](f func(T1, T2, T3) R, arg1 T1) func(T2, T3) R {\n\treturn func(t2 T2, t3 T3) R {\n\t\treturn f(arg1, t2, t3)\n\t}\n}\n\n// Partial3 returns new function that, when called, has its first argument set to the provided value.\nfunc Partial3[T1, T2, T3, T4, R any](f func(T1, T2, T3, T4) R, arg1 T1) func(T2, T3, T4) R {\n\treturn func(t2 T2, t3 T3, t4 T4) R {\n\t\treturn f(arg1, t2, t3, t4)\n\t}\n}\n\n// Partial4 returns new function that, when called, has its first argument set to the provided value.\nfunc Partial4[T1, T2, T3, T4, T5, R any](f func(T1, T2, T3, T4, T5) R, arg1 T1) func(T2, T3, T4, T5) R {\n\treturn func(t2 T2, t3 T3, t4 T4, t5 T5) R {\n\t\treturn f(arg1, t2, t3, t4, t5)\n\t}\n}\n\n// Partial5 returns new function that, when called, has its first argument set to the provided value\nfunc Partial5[T1, T2, T3, T4, T5, T6, R any](f func(T1, T2, T3, T4, T5, T6) R, arg1 T1) func(T2, T3, T4, T5, T6) R {\n\treturn func(t2 T2, t3 T3, t4 T4, t5 T5, t6 T6) R {\n\t\treturn f(arg1, t2, t3, t4, t5, t6)\n\t}\n}\n"
        },
        {
          "name": "func_test.go",
          "type": "blob",
          "size": 1.5712890625,
          "content": "package lo\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestPartial(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tadd := func(x float64, y int) string {\n\t\treturn strconv.Itoa(int(x) + y)\n\t}\n\tf := Partial(add, 5)\n\tis.Equal(\"15\", f(10))\n\tis.Equal(\"0\", f(-5))\n}\n\nfunc TestPartial1(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tadd := func(x float64, y int) string {\n\t\treturn strconv.Itoa(int(x) + y)\n\t}\n\tf := Partial1(add, 5)\n\tis.Equal(\"15\", f(10))\n\tis.Equal(\"0\", f(-5))\n}\n\nfunc TestPartial2(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tadd := func(x float64, y int, z int) string {\n\t\treturn strconv.Itoa(int(x) + y + z)\n\t}\n\tf := Partial2(add, 5)\n\tis.Equal(\"24\", f(10, 9))\n\tis.Equal(\"8\", f(-5, 8))\n}\n\nfunc TestPartial3(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tadd := func(x float64, y int, z int, a float32) string {\n\t\treturn strconv.Itoa(int(x) + y + z + int(a))\n\t}\n\tf := Partial3(add, 5)\n\tis.Equal(\"21\", f(10, 9, -3))\n\tis.Equal(\"15\", f(-5, 8, 7))\n}\n\nfunc TestPartial4(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tadd := func(x float64, y int, z int, a float32, b int32) string {\n\t\treturn strconv.Itoa(int(x) + y + z + int(a) + int(b))\n\t}\n\tf := Partial4(add, 5)\n\tis.Equal(\"21\", f(10, 9, -3, 0))\n\tis.Equal(\"14\", f(-5, 8, 7, -1))\n}\n\nfunc TestPartial5(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tadd := func(x float64, y int, z int, a float32, b int32, c int) string {\n\t\treturn strconv.Itoa(int(x) + y + z + int(a) + int(b) + c)\n\t}\n\tf := Partial5(add, 5)\n\tis.Equal(\"26\", f(10, 9, -3, 0, 5))\n\tis.Equal(\"21\", f(-5, 8, 7, -1, 7))\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5595703125,
          "content": "module github.com/samber/lo\n\ngo 1.18\n\n//\n// Dev dependencies are excluded from releases. Please check CI.\n//\n\nrequire (\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/thoas/go-funk v0.9.3\n\tgo.uber.org/goleak v1.2.1\n\tgolang.org/x/text v0.21.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/kr/text v0.2.0 // indirect\n\tgithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.3828125,
          "content": "github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/thoas/go-funk v0.9.3 h1:7+nAEx3kn5ZJcnDm2Bh23N2yOtweO14bi//dvRtgLpw=\ngithub.com/thoas/go-funk v0.9.3/go.mod h1:+IWnUfUmFO1+WVYQWQtIJHeRRdaIyyYglZN7xzUPe4Q=\ngo.uber.org/goleak v1.2.1 h1:NBol2c7O1ZokfZ0LEU9K6Whx/KnwvepVetCUhtKja4A=\ngo.uber.org/goleak v1.2.1/go.mod h1:qlT2yGI9QafXHhZZLxlSuNsMw3FFLxBr+tBRlmO1xH4=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "intersect.go",
          "type": "blob",
          "size": 4.275390625,
          "content": "package lo\n\n// Contains returns true if an element is present in a collection.\nfunc Contains[T comparable](collection []T, element T) bool {\n\tfor i := range collection {\n\t\tif collection[i] == element {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// ContainsBy returns true if predicate function return true.\nfunc ContainsBy[T any](collection []T, predicate func(item T) bool) bool {\n\tfor i := range collection {\n\t\tif predicate(collection[i]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// Every returns true if all elements of a subset are contained into a collection or if the subset is empty.\nfunc Every[T comparable](collection []T, subset []T) bool {\n\tfor i := range subset {\n\t\tif !Contains(collection, subset[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// EveryBy returns true if the predicate returns true for all elements in the collection or if the collection is empty.\nfunc EveryBy[T any](collection []T, predicate func(item T) bool) bool {\n\tfor i := range collection {\n\t\tif !predicate(collection[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// Some returns true if at least 1 element of a subset is contained into a collection.\n// If the subset is empty Some returns false.\nfunc Some[T comparable](collection []T, subset []T) bool {\n\tfor i := range subset {\n\t\tif Contains(collection, subset[i]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// SomeBy returns true if the predicate returns true for any of the elements in the collection.\n// If the collection is empty SomeBy returns false.\nfunc SomeBy[T any](collection []T, predicate func(item T) bool) bool {\n\tfor i := range collection {\n\t\tif predicate(collection[i]) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// None returns true if no element of a subset are contained into a collection or if the subset is empty.\nfunc None[T comparable](collection []T, subset []T) bool {\n\tfor i := range subset {\n\t\tif Contains(collection, subset[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// NoneBy returns true if the predicate returns true for none of the elements in the collection or if the collection is empty.\nfunc NoneBy[T any](collection []T, predicate func(item T) bool) bool {\n\tfor i := range collection {\n\t\tif predicate(collection[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// Intersect returns the intersection between two collections.\nfunc Intersect[T comparable, Slice ~[]T](list1 Slice, list2 Slice) Slice {\n\tresult := Slice{}\n\tseen := map[T]struct{}{}\n\n\tfor i := range list1 {\n\t\tseen[list1[i]] = struct{}{}\n\t}\n\n\tfor i := range list2 {\n\t\tif _, ok := seen[list2[i]]; ok {\n\t\t\tresult = append(result, list2[i])\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Difference returns the difference between two collections.\n// The first value is the collection of element absent of list2.\n// The second value is the collection of element absent of list1.\nfunc Difference[T comparable, Slice ~[]T](list1 Slice, list2 Slice) (Slice, Slice) {\n\tleft := Slice{}\n\tright := Slice{}\n\n\tseenLeft := map[T]struct{}{}\n\tseenRight := map[T]struct{}{}\n\n\tfor i := range list1 {\n\t\tseenLeft[list1[i]] = struct{}{}\n\t}\n\n\tfor i := range list2 {\n\t\tseenRight[list2[i]] = struct{}{}\n\t}\n\n\tfor i := range list1 {\n\t\tif _, ok := seenRight[list1[i]]; !ok {\n\t\t\tleft = append(left, list1[i])\n\t\t}\n\t}\n\n\tfor i := range list2 {\n\t\tif _, ok := seenLeft[list2[i]]; !ok {\n\t\t\tright = append(right, list2[i])\n\t\t}\n\t}\n\n\treturn left, right\n}\n\n// Union returns all distinct elements from given collections.\n// result returns will not change the order of elements relatively.\nfunc Union[T comparable, Slice ~[]T](lists ...Slice) Slice {\n\tvar capLen int\n\n\tfor _, list := range lists {\n\t\tcapLen += len(list)\n\t}\n\n\tresult := make(Slice, 0, capLen)\n\tseen := make(map[T]struct{}, capLen)\n\n\tfor i := range lists {\n\t\tfor j := range lists[i] {\n\t\t\tif _, ok := seen[lists[i][j]]; !ok {\n\t\t\t\tseen[lists[i][j]] = struct{}{}\n\t\t\t\tresult = append(result, lists[i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Without returns slice excluding all given values.\nfunc Without[T comparable, Slice ~[]T](collection Slice, exclude ...T) Slice {\n\tresult := make(Slice, 0, len(collection))\n\tfor i := range collection {\n\t\tif !Contains(exclude, collection[i]) {\n\t\t\tresult = append(result, collection[i])\n\t\t}\n\t}\n\treturn result\n}\n\n// WithoutEmpty returns slice excluding empty values.\n//\n// Deprecated: Use lo.Compact instead.\nfunc WithoutEmpty[T comparable, Slice ~[]T](collection Slice) Slice {\n\treturn Compact(collection)\n}\n"
        },
        {
          "name": "intersect_test.go",
          "type": "blob",
          "size": 6.818359375,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestContains(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Contains([]int{0, 1, 2, 3, 4, 5}, 5)\n\tresult2 := Contains([]int{0, 1, 2, 3, 4, 5}, 6)\n\n\tis.Equal(result1, true)\n\tis.Equal(result2, false)\n}\n\nfunc TestContainsBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\ttype a struct {\n\t\tA int\n\t\tB string\n\t}\n\n\ta1 := []a{{A: 1, B: \"1\"}, {A: 2, B: \"2\"}, {A: 3, B: \"3\"}}\n\tresult1 := ContainsBy(a1, func(t a) bool { return t.A == 1 && t.B == \"2\" })\n\tresult2 := ContainsBy(a1, func(t a) bool { return t.A == 2 && t.B == \"2\" })\n\n\ta2 := []string{\"aaa\", \"bbb\", \"ccc\"}\n\tresult3 := ContainsBy(a2, func(t string) bool { return t == \"ccc\" })\n\tresult4 := ContainsBy(a2, func(t string) bool { return t == \"ddd\" })\n\n\tis.Equal(result1, false)\n\tis.Equal(result2, true)\n\tis.Equal(result3, true)\n\tis.Equal(result4, false)\n}\n\nfunc TestEvery(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Every([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})\n\tresult2 := Every([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})\n\tresult3 := Every([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})\n\tresult4 := Every([]int{0, 1, 2, 3, 4, 5}, []int{})\n\n\tis.True(result1)\n\tis.False(result2)\n\tis.False(result3)\n\tis.True(result4)\n}\n\nfunc TestEveryBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := EveryBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 5\n\t})\n\n\tis.True(result1)\n\n\tresult2 := EveryBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 3\n\t})\n\n\tis.False(result2)\n\n\tresult3 := EveryBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 0\n\t})\n\n\tis.False(result3)\n\n\tresult4 := EveryBy([]int{}, func(x int) bool {\n\t\treturn x < 5\n\t})\n\n\tis.True(result4)\n}\n\nfunc TestSome(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Some([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})\n\tresult2 := Some([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})\n\tresult3 := Some([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})\n\tresult4 := Some([]int{0, 1, 2, 3, 4, 5}, []int{})\n\n\tis.True(result1)\n\tis.True(result2)\n\tis.False(result3)\n\tis.False(result4)\n}\n\nfunc TestSomeBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := SomeBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 5\n\t})\n\n\tis.True(result1)\n\n\tresult2 := SomeBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 3\n\t})\n\n\tis.True(result2)\n\n\tresult3 := SomeBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 0\n\t})\n\n\tis.False(result3)\n\n\tresult4 := SomeBy([]int{}, func(x int) bool {\n\t\treturn x < 5\n\t})\n\n\tis.False(result4)\n}\n\nfunc TestNone(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := None([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})\n\tresult2 := None([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})\n\tresult3 := None([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})\n\tresult4 := None([]int{0, 1, 2, 3, 4, 5}, []int{})\n\n\tis.False(result1)\n\tis.False(result2)\n\tis.True(result3)\n\tis.True(result4)\n}\n\nfunc TestNoneBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := NoneBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 5\n\t})\n\n\tis.False(result1)\n\n\tresult2 := NoneBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 3\n\t})\n\n\tis.False(result2)\n\n\tresult3 := NoneBy([]int{1, 2, 3, 4}, func(x int) bool {\n\t\treturn x < 0\n\t})\n\n\tis.True(result3)\n\n\tresult4 := NoneBy([]int{}, func(x int) bool {\n\t\treturn x < 5\n\t})\n\n\tis.True(result4)\n}\n\nfunc TestIntersect(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Intersect([]int{0, 1, 2, 3, 4, 5}, []int{0, 2})\n\tresult2 := Intersect([]int{0, 1, 2, 3, 4, 5}, []int{0, 6})\n\tresult3 := Intersect([]int{0, 1, 2, 3, 4, 5}, []int{-1, 6})\n\tresult4 := Intersect([]int{0, 6}, []int{0, 1, 2, 3, 4, 5})\n\tresult5 := Intersect([]int{0, 6, 0}, []int{0, 1, 2, 3, 4, 5})\n\n\tis.Equal(result1, []int{0, 2})\n\tis.Equal(result2, []int{0})\n\tis.Equal(result3, []int{})\n\tis.Equal(result4, []int{0})\n\tis.Equal(result5, []int{0})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Intersect(allStrings, allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestDifference(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tleft1, right1 := Difference([]int{0, 1, 2, 3, 4, 5}, []int{0, 2, 6})\n\tis.Equal(left1, []int{1, 3, 4, 5})\n\tis.Equal(right1, []int{6})\n\n\tleft2, right2 := Difference([]int{1, 2, 3, 4, 5}, []int{0, 6})\n\tis.Equal(left2, []int{1, 2, 3, 4, 5})\n\tis.Equal(right2, []int{0, 6})\n\n\tleft3, right3 := Difference([]int{0, 1, 2, 3, 4, 5}, []int{0, 1, 2, 3, 4, 5})\n\tis.Equal(left3, []int{})\n\tis.Equal(right3, []int{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\ta, b := Difference(allStrings, allStrings)\n\tis.IsType(a, allStrings, \"type preserved\")\n\tis.IsType(b, allStrings, \"type preserved\")\n}\n\nfunc TestUnion(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Union([]int{0, 1, 2, 3, 4, 5}, []int{0, 2, 10})\n\tresult2 := Union([]int{0, 1, 2, 3, 4, 5}, []int{6, 7})\n\tresult3 := Union([]int{0, 1, 2, 3, 4, 5}, []int{})\n\tresult4 := Union([]int{0, 1, 2}, []int{0, 1, 2})\n\tresult5 := Union([]int{}, []int{})\n\tis.Equal(result1, []int{0, 1, 2, 3, 4, 5, 10})\n\tis.Equal(result2, []int{0, 1, 2, 3, 4, 5, 6, 7})\n\tis.Equal(result3, []int{0, 1, 2, 3, 4, 5})\n\tis.Equal(result4, []int{0, 1, 2})\n\tis.Equal(result5, []int{})\n\n\tresult11 := Union([]int{0, 1, 2, 3, 4, 5}, []int{0, 2, 10}, []int{0, 1, 11})\n\tresult12 := Union([]int{0, 1, 2, 3, 4, 5}, []int{6, 7}, []int{8, 9})\n\tresult13 := Union([]int{0, 1, 2, 3, 4, 5}, []int{}, []int{})\n\tresult14 := Union([]int{0, 1, 2}, []int{0, 1, 2}, []int{0, 1, 2})\n\tresult15 := Union([]int{}, []int{}, []int{})\n\tis.Equal(result11, []int{0, 1, 2, 3, 4, 5, 10, 11})\n\tis.Equal(result12, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9})\n\tis.Equal(result13, []int{0, 1, 2, 3, 4, 5})\n\tis.Equal(result14, []int{0, 1, 2})\n\tis.Equal(result15, []int{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Union(allStrings, allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestWithout(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Without([]int{0, 2, 10}, 0, 1, 2, 3, 4, 5)\n\tresult2 := Without([]int{0, 7}, 0, 1, 2, 3, 4, 5)\n\tresult3 := Without([]int{}, 0, 1, 2, 3, 4, 5)\n\tresult4 := Without([]int{0, 1, 2}, 0, 1, 2)\n\tresult5 := Without([]int{})\n\tis.Equal(result1, []int{10})\n\tis.Equal(result2, []int{7})\n\tis.Equal(result3, []int{})\n\tis.Equal(result4, []int{})\n\tis.Equal(result5, []int{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Without(allStrings, \"\")\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestWithoutEmpty(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := WithoutEmpty([]int{0, 1, 2})\n\tresult2 := WithoutEmpty([]int{1, 2})\n\tresult3 := WithoutEmpty([]int{})\n\tis.Equal(result1, []int{1, 2})\n\tis.Equal(result2, []int{1, 2})\n\tis.Equal(result3, []int{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := WithoutEmpty(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n"
        },
        {
          "name": "lo_test.go",
          "type": "blob",
          "size": 0.5166015625,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\n// https://github.com/stretchr/testify/issues/1101\nfunc testWithTimeout(t *testing.T, timeout time.Duration) {\n\tt.Helper()\n\n\ttestFinished := make(chan struct{})\n\tt.Cleanup(func() { close(testFinished) })\n\n\tgo func() { //nolint:staticcheck\n\t\tselect {\n\t\tcase <-testFinished:\n\t\tcase <-time.After(timeout):\n\t\t\tt.Errorf(\"test timed out after %s\", timeout)\n\t\t\tt.FailNow() //nolint:govet,staticcheck\n\t\t}\n\t}()\n}\n\ntype foo struct {\n\tbar string\n}\n\nfunc (f foo) Clone() foo {\n\treturn foo{f.bar}\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 0.11328125,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\n\t\"go.uber.org/goleak\"\n)\n\nfunc TestMain(m *testing.M) {\n\tgoleak.VerifyTestMain(m)\n}\n"
        },
        {
          "name": "map.go",
          "type": "blob",
          "size": 6.814453125,
          "content": "package lo\n\n// Keys creates an array of the map keys.\n// Play: https://go.dev/play/p/Uu11fHASqrU\nfunc Keys[K comparable, V any](in ...map[K]V) []K {\n\tsize := 0\n\tfor i := range in {\n\t\tsize += len(in[i])\n\t}\n\tresult := make([]K, 0, size)\n\n\tfor i := range in {\n\t\tfor k := range in[i] {\n\t\t\tresult = append(result, k)\n\t\t}\n\t}\n\n\treturn result\n}\n\n// UniqKeys creates an array of unique keys in the map.\n// Play: https://go.dev/play/p/TPKAb6ILdHk\nfunc UniqKeys[K comparable, V any](in ...map[K]V) []K {\n\tsize := 0\n\tfor i := range in {\n\t\tsize += len(in[i])\n\t}\n\n\tseen := make(map[K]struct{}, size)\n\tresult := make([]K, 0)\n\n\tfor i := range in {\n\t\tfor k := range in[i] {\n\t\t\tif _, exists := seen[k]; exists {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tseen[k] = struct{}{}\n\t\t\tresult = append(result, k)\n\t\t}\n\t}\n\n\treturn result\n}\n\n// HasKey returns whether the given key exists.\n// Play: https://go.dev/play/p/aVwubIvECqS\nfunc HasKey[K comparable, V any](in map[K]V, key K) bool {\n\t_, ok := in[key]\n\treturn ok\n}\n\n// Values creates an array of the map values.\n// Play: https://go.dev/play/p/nnRTQkzQfF6\nfunc Values[K comparable, V any](in ...map[K]V) []V {\n\tsize := 0\n\tfor i := range in {\n\t\tsize += len(in[i])\n\t}\n\tresult := make([]V, 0, size)\n\n\tfor i := range in {\n\t\tfor k := range in[i] {\n\t\t\tresult = append(result, in[i][k])\n\t\t}\n\t}\n\n\treturn result\n}\n\n// UniqValues creates an array of unique values in the map.\n// Play: https://go.dev/play/p/nf6bXMh7rM3\nfunc UniqValues[K comparable, V comparable](in ...map[K]V) []V {\n\tsize := 0\n\tfor i := range in {\n\t\tsize += len(in[i])\n\t}\n\n\tseen := make(map[V]struct{}, size)\n\tresult := make([]V, 0)\n\n\tfor i := range in {\n\t\tfor k := range in[i] {\n\t\t\tval := in[i][k]\n\t\t\tif _, exists := seen[val]; exists {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tseen[val] = struct{}{}\n\t\t\tresult = append(result, val)\n\t\t}\n\t}\n\n\treturn result\n}\n\n// ValueOr returns the value of the given key or the fallback value if the key is not present.\n// Play: https://go.dev/play/p/bAq9mHErB4V\nfunc ValueOr[K comparable, V any](in map[K]V, key K, fallback V) V {\n\tif v, ok := in[key]; ok {\n\t\treturn v\n\t}\n\treturn fallback\n}\n\n// PickBy returns same map type filtered by given predicate.\n// Play: https://go.dev/play/p/kdg8GR_QMmf\nfunc PickBy[K comparable, V any, Map ~map[K]V](in Map, predicate func(key K, value V) bool) Map {\n\tr := Map{}\n\tfor k := range in {\n\t\tif predicate(k, in[k]) {\n\t\t\tr[k] = in[k]\n\t\t}\n\t}\n\treturn r\n}\n\n// PickByKeys returns same map type filtered by given keys.\n// Play: https://go.dev/play/p/R1imbuci9qU\nfunc PickByKeys[K comparable, V any, Map ~map[K]V](in Map, keys []K) Map {\n\tr := Map{}\n\tfor i := range keys {\n\t\tif v, ok := in[keys[i]]; ok {\n\t\t\tr[keys[i]] = v\n\t\t}\n\t}\n\treturn r\n}\n\n// PickByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/1zdzSvbfsJc\nfunc PickByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n\tr := Map{}\n\tfor k := range in {\n\t\tif Contains(values, in[k]) {\n\t\t\tr[k] = in[k]\n\t\t}\n\t}\n\treturn r\n}\n\n// OmitBy returns same map type filtered by given predicate.\n// Play: https://go.dev/play/p/EtBsR43bdsd\nfunc OmitBy[K comparable, V any, Map ~map[K]V](in Map, predicate func(key K, value V) bool) Map {\n\tr := Map{}\n\tfor k := range in {\n\t\tif !predicate(k, in[k]) {\n\t\t\tr[k] = in[k]\n\t\t}\n\t}\n\treturn r\n}\n\n// OmitByKeys returns same map type filtered by given keys.\n// Play: https://go.dev/play/p/t1QjCrs-ysk\nfunc OmitByKeys[K comparable, V any, Map ~map[K]V](in Map, keys []K) Map {\n\tr := Map{}\n\tfor k := range in {\n\t\tr[k] = in[k]\n\t}\n\tfor i := range keys {\n\t\tdelete(r, keys[i])\n\t}\n\treturn r\n}\n\n// OmitByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/9UYZi-hrs8j\nfunc OmitByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n\tr := Map{}\n\tfor k := range in {\n\t\tif !Contains(values, in[k]) {\n\t\t\tr[k] = in[k]\n\t\t}\n\t}\n\treturn r\n}\n\n// Entries transforms a map into array of key/value pairs.\n// Play:\nfunc Entries[K comparable, V any](in map[K]V) []Entry[K, V] {\n\tentries := make([]Entry[K, V], 0, len(in))\n\n\tfor k := range in {\n\t\tentries = append(entries, Entry[K, V]{\n\t\t\tKey:   k,\n\t\t\tValue: in[k],\n\t\t})\n\t}\n\n\treturn entries\n}\n\n// ToPairs transforms a map into array of key/value pairs.\n// Alias of Entries().\n// Play: https://go.dev/play/p/3Dhgx46gawJ\nfunc ToPairs[K comparable, V any](in map[K]V) []Entry[K, V] {\n\treturn Entries(in)\n}\n\n// FromEntries transforms an array of key/value pairs into a map.\n// Play: https://go.dev/play/p/oIr5KHFGCEN\nfunc FromEntries[K comparable, V any](entries []Entry[K, V]) map[K]V {\n\tout := make(map[K]V, len(entries))\n\n\tfor i := range entries {\n\t\tout[entries[i].Key] = entries[i].Value\n\t}\n\n\treturn out\n}\n\n// FromPairs transforms an array of key/value pairs into a map.\n// Alias of FromEntries().\n// Play: https://go.dev/play/p/oIr5KHFGCEN\nfunc FromPairs[K comparable, V any](entries []Entry[K, V]) map[K]V {\n\treturn FromEntries(entries)\n}\n\n// Invert creates a map composed of the inverted keys and values. If map\n// contains duplicate values, subsequent values overwrite property assignments\n// of previous values.\n// Play: https://go.dev/play/p/rFQ4rak6iA1\nfunc Invert[K comparable, V comparable](in map[K]V) map[V]K {\n\tout := make(map[V]K, len(in))\n\n\tfor k := range in {\n\t\tout[in[k]] = k\n\t}\n\n\treturn out\n}\n\n// Assign merges multiple maps from left to right.\n// Play: https://go.dev/play/p/VhwfJOyxf5o\nfunc Assign[K comparable, V any, Map ~map[K]V](maps ...Map) Map {\n\tcount := 0\n\tfor i := range maps {\n\t\tcount += len(maps[i])\n\t}\n\n\tout := make(Map, count)\n\tfor i := range maps {\n\t\tfor k := range maps[i] {\n\t\t\tout[k] = maps[i][k]\n\t\t}\n\t}\n\n\treturn out\n}\n\n// MapKeys manipulates a map keys and transforms it to a map of another type.\n// Play: https://go.dev/play/p/9_4WPIqOetJ\nfunc MapKeys[K comparable, V any, R comparable](in map[K]V, iteratee func(value V, key K) R) map[R]V {\n\tresult := make(map[R]V, len(in))\n\n\tfor k := range in {\n\t\tresult[iteratee(in[k], k)] = in[k]\n\t}\n\n\treturn result\n}\n\n// MapValues manipulates a map values and transforms it to a map of another type.\n// Play: https://go.dev/play/p/T_8xAfvcf0W\nfunc MapValues[K comparable, V any, R any](in map[K]V, iteratee func(value V, key K) R) map[K]R {\n\tresult := make(map[K]R, len(in))\n\n\tfor k := range in {\n\t\tresult[k] = iteratee(in[k], k)\n\t}\n\n\treturn result\n}\n\n// MapEntries manipulates a map entries and transforms it to a map of another type.\n// Play: https://go.dev/play/p/VuvNQzxKimT\nfunc MapEntries[K1 comparable, V1 any, K2 comparable, V2 any](in map[K1]V1, iteratee func(key K1, value V1) (K2, V2)) map[K2]V2 {\n\tresult := make(map[K2]V2, len(in))\n\n\tfor k1 := range in {\n\t\tk2, v2 := iteratee(k1, in[k1])\n\t\tresult[k2] = v2\n\t}\n\n\treturn result\n}\n\n// MapToSlice transforms a map into a slice based on specific iteratee\n// Play: https://go.dev/play/p/ZuiCZpDt6LD\nfunc MapToSlice[K comparable, V any, R any](in map[K]V, iteratee func(key K, value V) R) []R {\n\tresult := make([]R, 0, len(in))\n\n\tfor k := range in {\n\t\tresult = append(result, iteratee(k, in[k]))\n\t}\n\n\treturn result\n}\n"
        },
        {
          "name": "map_benchmark_test.go",
          "type": "blob",
          "size": 2.2861328125,
          "content": "package lo\n\nimport (\n\t\"math/rand\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\tlop \"github.com/samber/lo/parallel\"\n\t\"github.com/thoas/go-funk\"\n)\n\nfunc sliceGenerator(size uint) []int64 {\n\tr := rand.New(rand.NewSource(time.Now().Unix()))\n\n\tresult := make([]int64, size)\n\n\tfor i := uint(0); i < size; i++ {\n\t\tresult[i] = r.Int63()\n\t}\n\n\treturn result\n}\n\nfunc mapGenerator(size uint) map[int64]int64 {\n\tr := rand.New(rand.NewSource(time.Now().Unix()))\n\n\tresult := make(map[int64]int64, size)\n\n\tfor i := uint(0); i < size; i++ {\n\t\tresult[int64(i)] = r.Int63()\n\t}\n\n\treturn result\n}\n\nfunc BenchmarkMap(b *testing.B) {\n\tarr := sliceGenerator(1000000)\n\n\tb.Run(\"lo.Map\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\t_ = Map(arr, func(x int64, i int) string {\n\t\t\t\treturn strconv.FormatInt(x, 10)\n\t\t\t})\n\t\t}\n\t})\n\n\tb.Run(\"lop.Map\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\t_ = lop.Map(arr, func(x int64, i int) string {\n\t\t\t\treturn strconv.FormatInt(x, 10)\n\t\t\t})\n\t\t}\n\t})\n\n\tb.Run(\"reflect\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\t_ = funk.Map(arr, func(x int64) string {\n\t\t\t\treturn strconv.FormatInt(x, 10)\n\t\t\t})\n\t\t}\n\t})\n\n\tb.Run(\"for\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tresults := make([]string, len(arr))\n\n\t\t\tfor i, item := range arr {\n\t\t\t\tresult := strconv.FormatInt(item, 10)\n\t\t\t\tresults[i] = result\n\t\t\t}\n\t\t}\n\t})\n}\n\n// also apply to UniqValues\nfunc BenchmarkUniqKeys(b *testing.B) {\n\tm := []map[int64]int64{\n\t\tmapGenerator(100000),\n\t\tmapGenerator(100000),\n\t\tmapGenerator(100000),\n\t}\n\n\t// allocate just in time + ordered\n\tb.Run(\"lo.UniqKeys.jit-alloc\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tseen := make(map[int64]struct{})\n\t\t\tresult := make([]int64, 0)\n\n\t\t\tfor i := range m {\n\t\t\t\tfor k := range m[i] {\n\t\t\t\t\tif _, exists := seen[k]; exists {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tseen[k] = struct{}{}\n\t\t\t\t\tresult = append(result, k) //nolint:staticcheck\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\t// preallocate + unordered\n\tb.Run(\"lo.UniqKeys.preallocate\", func(b *testing.B) {\n\t\tfor n := 0; n < b.N; n++ {\n\t\t\tsize := 0\n\t\t\tfor i := range m {\n\t\t\t\tsize += len(m[i])\n\t\t\t}\n\t\t\tseen := make(map[int64]struct{}, size)\n\n\t\t\tfor i := range m {\n\t\t\t\tfor k := range m[i] {\n\t\t\t\t\tseen[k] = struct{}{}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresult := make([]int64, 0, len(seen))\n\n\t\t\tfor k := range seen {\n\t\t\t\tresult = append(result, k) //nolint:staticcheck\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "map_example_test.go",
          "type": "blob",
          "size": 4.2451171875,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc ExampleKeys() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2}\n\tkv2 := map[string]int{\"baz\": 3}\n\n\tresult := Keys(kv, kv2)\n\tsort.Strings(result)\n\tfmt.Printf(\"%v\", result)\n\t// Output: [bar baz foo]\n}\n\nfunc ExampleUniqKeys() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2}\n\tkv2 := map[string]int{\"bar\": 3}\n\n\tresult := UniqKeys(kv, kv2)\n\tsort.Strings(result)\n\tfmt.Printf(\"%v\", result)\n\t// Output: [bar foo]\n}\n\nfunc ExampleValues() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2}\n\tkv2 := map[string]int{\"baz\": 3}\n\n\tresult := Values(kv, kv2)\n\n\tsort.Ints(result)\n\tfmt.Printf(\"%v\", result)\n\t// Output: [1 2 3]\n}\n\nfunc ExampleUniqValues() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2}\n\tkv2 := map[string]int{\"baz\": 2}\n\n\tresult := UniqValues(kv, kv2)\n\n\tsort.Ints(result)\n\tfmt.Printf(\"%v\", result)\n\t// Output: [1 2]\n}\n\nfunc ExampleValueOr() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2}\n\n\tresult1 := ValueOr(kv, \"foo\", 42)\n\tresult2 := ValueOr(kv, \"baz\", 42)\n\n\tfmt.Printf(\"%v %v\", result1, result2)\n\t// Output: 1 42\n}\n\nfunc ExamplePickBy() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := PickBy(kv, func(key string, value int) bool {\n\t\treturn value%2 == 1\n\t})\n\n\tfmt.Printf(\"%v %v %v\", len(result), result[\"foo\"], result[\"baz\"])\n\t// Output: 2 1 3\n}\n\nfunc ExamplePickByKeys() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := PickByKeys(kv, []string{\"foo\", \"baz\"})\n\n\tfmt.Printf(\"%v %v %v\", len(result), result[\"foo\"], result[\"baz\"])\n\t// Output: 2 1 3\n}\n\nfunc ExamplePickByValues() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := PickByValues(kv, []int{1, 3})\n\n\tfmt.Printf(\"%v %v %v\", len(result), result[\"foo\"], result[\"baz\"])\n\t// Output: 2 1 3\n}\n\nfunc ExampleOmitBy() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := OmitBy(kv, func(key string, value int) bool {\n\t\treturn value%2 == 1\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: map[bar:2]\n}\n\nfunc ExampleOmitByKeys() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := OmitByKeys(kv, []string{\"foo\", \"baz\"})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: map[bar:2]\n}\n\nfunc ExampleOmitByValues() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := OmitByValues(kv, []int{1, 3})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: map[bar:2]\n}\n\nfunc ExampleEntries() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := Entries(kv)\n\n\tsort.Slice(result, func(i, j int) bool {\n\t\treturn strings.Compare(result[i].Key, result[j].Key) < 0\n\t})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{bar 2} {baz 3} {foo 1}]\n}\n\nfunc ExampleFromEntries() {\n\tresult := FromEntries([]Entry[string, int]{\n\t\t{\n\t\t\tKey:   \"foo\",\n\t\t\tValue: 1,\n\t\t},\n\t\t{\n\t\t\tKey:   \"bar\",\n\t\t\tValue: 2,\n\t\t},\n\t\t{\n\t\t\tKey:   \"baz\",\n\t\t\tValue: 3,\n\t\t},\n\t})\n\n\tfmt.Printf(\"%v %v %v %v\", len(result), result[\"foo\"], result[\"bar\"], result[\"baz\"])\n\t// Output: 3 1 2 3\n}\n\nfunc ExampleInvert() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}\n\n\tresult := Invert(kv)\n\n\tfmt.Printf(\"%v %v %v %v\", len(result), result[1], result[2], result[3])\n\t// Output: 3 foo bar baz\n}\n\nfunc ExampleAssign() {\n\tresult := Assign(\n\t\tmap[string]int{\"a\": 1, \"b\": 2},\n\t\tmap[string]int{\"b\": 3, \"c\": 4},\n\t)\n\n\tfmt.Printf(\"%v %v %v %v\", len(result), result[\"a\"], result[\"b\"], result[\"c\"])\n\t// Output: 3 1 3 4\n}\n\nfunc ExampleMapKeys() {\n\tkv := map[int]int{1: 1, 2: 2, 3: 3, 4: 4}\n\n\tresult := MapKeys(kv, func(_ int, k int) string {\n\t\treturn strconv.FormatInt(int64(k), 10)\n\t})\n\n\tfmt.Printf(\"%v %v %v %v %v\", len(result), result[\"1\"], result[\"2\"], result[\"3\"], result[\"4\"])\n\t// Output: 4 1 2 3 4\n}\n\nfunc ExampleMapValues() {\n\tkv := map[int]int{1: 1, 2: 2, 3: 3, 4: 4}\n\n\tresult := MapValues(kv, func(v int, _ int) string {\n\t\treturn strconv.FormatInt(int64(v), 10)\n\t})\n\n\tfmt.Printf(\"%v %q %q %q %q\", len(result), result[1], result[2], result[3], result[4])\n\t// Output: 4 \"1\" \"2\" \"3\" \"4\"\n}\n\nfunc ExampleMapEntries() {\n\tkv := map[string]int{\"foo\": 1, \"bar\": 2}\n\n\tresult := MapEntries(kv, func(k string, v int) (int, string) {\n\t\treturn v, k\n\t})\n\n\tfmt.Printf(\"%v\\n\", result)\n\t// Output: map[1:foo 2:bar]\n}\n\nfunc ExampleMapToSlice() {\n\tkv := map[int]int64{1: 1, 2: 2, 3: 3, 4: 4}\n\n\tresult := MapToSlice(kv, func(k int, v int64) string {\n\t\treturn fmt.Sprintf(\"%d_%d\", k, v)\n\t})\n\n\tsort.StringSlice(result).Sort()\n\tfmt.Printf(\"%v\", result)\n\t// Output: [1_1 2_2 3_3 4_4]\n}\n"
        },
        {
          "name": "map_test.go",
          "type": "blob",
          "size": 12.8427734375,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestKeys(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Keys(map[string]int{\"foo\": 1, \"bar\": 2})\n\tsort.Strings(r1)\n\tis.Equal(r1, []string{\"bar\", \"foo\"})\n\n\tr2 := Keys(map[string]int{})\n\tis.Empty(r2)\n\n\tr3 := Keys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n\tsort.Strings(r3)\n\tis.Equal(r3, []string{\"bar\", \"baz\", \"foo\"})\n\n\tr4 := Keys[string, int]()\n\tis.Equal(r4, []string{})\n\n\tr5 := Keys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"bar\": 3})\n\tsort.Strings(r5)\n\tis.Equal(r5, []string{\"bar\", \"bar\", \"foo\"})\n}\n\nfunc TestUniqKeys(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := UniqKeys(map[string]int{\"foo\": 1, \"bar\": 2})\n\tsort.Strings(r1)\n\tis.Equal(r1, []string{\"bar\", \"foo\"})\n\n\tr2 := UniqKeys(map[string]int{})\n\tis.Empty(r2)\n\n\tr3 := UniqKeys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n\tsort.Strings(r3)\n\tis.Equal(r3, []string{\"bar\", \"baz\", \"foo\"})\n\n\tr4 := UniqKeys[string, int]()\n\tis.Equal(r4, []string{})\n\n\tr5 := UniqKeys(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"foo\": 1, \"bar\": 3})\n\tsort.Strings(r5)\n\tis.Equal(r5, []string{\"bar\", \"foo\"})\n\n\t// check order\n\tr6 := UniqKeys(map[string]int{\"foo\": 1}, map[string]int{\"bar\": 3})\n\tis.Equal(r6, []string{\"foo\", \"bar\"})\n}\n\nfunc TestHasKey(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := HasKey(map[string]int{\"foo\": 1}, \"bar\")\n\tis.False(r1)\n\n\tr2 := HasKey(map[string]int{\"foo\": 1}, \"foo\")\n\tis.True(r2)\n}\n\nfunc TestValues(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Values(map[string]int{\"foo\": 1, \"bar\": 2})\n\tsort.Ints(r1)\n\tis.Equal(r1, []int{1, 2})\n\n\tr2 := Values(map[string]int{})\n\tis.Empty(r2)\n\n\tr3 := Values(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n\tsort.Ints(r3)\n\tis.Equal(r3, []int{1, 2, 3})\n\n\tr4 := Values[string, int]()\n\tis.Equal(r4, []int{})\n\n\tr5 := Values(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"foo\": 1, \"bar\": 3})\n\tsort.Ints(r5)\n\tis.Equal(r5, []int{1, 1, 2, 3})\n}\n\nfunc TestUniqValues(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := UniqValues(map[string]int{\"foo\": 1, \"bar\": 2})\n\tsort.Ints(r1)\n\tis.Equal(r1, []int{1, 2})\n\n\tr2 := UniqValues(map[string]int{})\n\tis.Empty(r2)\n\n\tr3 := UniqValues(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"baz\": 3})\n\tsort.Ints(r3)\n\tis.Equal(r3, []int{1, 2, 3})\n\n\tr4 := UniqValues[string, int]()\n\tis.Equal(r4, []int{})\n\n\tr5 := UniqValues(map[string]int{\"foo\": 1, \"bar\": 2}, map[string]int{\"foo\": 1, \"bar\": 3})\n\tsort.Ints(r5)\n\tis.Equal(r5, []int{1, 2, 3})\n\n\tr6 := UniqValues(map[string]int{\"foo\": 1, \"bar\": 1}, map[string]int{\"foo\": 1, \"bar\": 3})\n\tsort.Ints(r6)\n\tis.Equal(r6, []int{1, 3})\n\n\t// check order\n\tr7 := UniqValues(map[string]int{\"foo\": 1}, map[string]int{\"bar\": 3})\n\tis.Equal(r7, []int{1, 3})\n}\n\nfunc TestValueOr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := ValueOr(map[string]int{\"foo\": 1}, \"bar\", 2)\n\tis.Equal(r1, 2)\n\n\tr2 := ValueOr(map[string]int{\"foo\": 1}, \"foo\", 2)\n\tis.Equal(r2, 1)\n}\n\nfunc TestPickBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := PickBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(key string, value int) bool {\n\t\treturn value%2 == 1\n\t})\n\n\tis.Equal(r1, map[string]int{\"foo\": 1, \"baz\": 3})\n\n\ttype myMap map[string]int\n\tbefore := myMap{\"\": 0, \"foobar\": 6, \"baz\": 3}\n\tafter := PickBy(before, func(key string, value int) bool { return true })\n\tis.IsType(after, before, \"type preserved\")\n}\n\nfunc TestPickByKeys(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := PickByKeys(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []string{\"foo\", \"baz\", \"qux\"})\n\n\tis.Equal(r1, map[string]int{\"foo\": 1, \"baz\": 3})\n\n\ttype myMap map[string]int\n\tbefore := myMap{\"\": 0, \"foobar\": 6, \"baz\": 3}\n\tafter := PickByKeys(before, []string{\"foobar\", \"baz\"})\n\tis.IsType(after, before, \"type preserved\")\n}\n\nfunc TestPickByValues(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := PickByValues(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []int{1, 3})\n\n\tis.Equal(r1, map[string]int{\"foo\": 1, \"baz\": 3})\n\n\ttype myMap map[string]int\n\tbefore := myMap{\"\": 0, \"foobar\": 6, \"baz\": 3}\n\tafter := PickByValues(before, []int{0, 3})\n\tis.IsType(after, before, \"type preserved\")\n}\n\nfunc TestOmitBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := OmitBy(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, func(key string, value int) bool {\n\t\treturn value%2 == 1\n\t})\n\n\tis.Equal(r1, map[string]int{\"bar\": 2})\n\n\ttype myMap map[string]int\n\tbefore := myMap{\"\": 0, \"foobar\": 6, \"baz\": 3}\n\tafter := PickBy(before, func(key string, value int) bool { return true })\n\tis.IsType(after, before, \"type preserved\")\n}\n\nfunc TestOmitByKeys(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := OmitByKeys(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []string{\"foo\", \"baz\", \"qux\"})\n\n\tis.Equal(r1, map[string]int{\"bar\": 2})\n\n\ttype myMap map[string]int\n\tbefore := myMap{\"\": 0, \"foobar\": 6, \"baz\": 3}\n\tafter := OmitByKeys(before, []string{\"foobar\", \"baz\"})\n\tis.IsType(after, before, \"type preserved\")\n}\n\nfunc TestOmitByValues(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := OmitByValues(map[string]int{\"foo\": 1, \"bar\": 2, \"baz\": 3}, []int{1, 3})\n\n\tis.Equal(r1, map[string]int{\"bar\": 2})\n\n\ttype myMap map[string]int\n\tbefore := myMap{\"\": 0, \"foobar\": 6, \"baz\": 3}\n\tafter := OmitByValues(before, []int{0, 3})\n\tis.IsType(after, before, \"type preserved\")\n}\n\nfunc TestEntries(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Entries(map[string]int{\"foo\": 1, \"bar\": 2})\n\n\tsort.Slice(r1, func(i, j int) bool {\n\t\treturn r1[i].Value < r1[j].Value\n\t})\n\tis.EqualValues(r1, []Entry[string, int]{\n\t\t{\n\t\t\tKey:   \"foo\",\n\t\t\tValue: 1,\n\t\t},\n\t\t{\n\t\t\tKey:   \"bar\",\n\t\t\tValue: 2,\n\t\t},\n\t})\n}\n\nfunc TestToPairs(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := ToPairs(map[string]int{\"baz\": 3, \"qux\": 4})\n\n\tsort.Slice(r1, func(i, j int) bool {\n\t\treturn r1[i].Value < r1[j].Value\n\t})\n\tis.EqualValues(r1, []Entry[string, int]{\n\t\t{\n\t\t\tKey:   \"baz\",\n\t\t\tValue: 3,\n\t\t},\n\t\t{\n\t\t\tKey:   \"qux\",\n\t\t\tValue: 4,\n\t\t},\n\t})\n}\n\nfunc TestFromEntries(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := FromEntries([]Entry[string, int]{\n\t\t{\n\t\t\tKey:   \"foo\",\n\t\t\tValue: 1,\n\t\t},\n\t\t{\n\t\t\tKey:   \"bar\",\n\t\t\tValue: 2,\n\t\t},\n\t})\n\n\tis.Len(r1, 2)\n\tis.Equal(r1[\"foo\"], 1)\n\tis.Equal(r1[\"bar\"], 2)\n}\n\nfunc TestFromPairs(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := FromPairs([]Entry[string, int]{\n\t\t{\n\t\t\tKey:   \"baz\",\n\t\t\tValue: 3,\n\t\t},\n\t\t{\n\t\t\tKey:   \"qux\",\n\t\t\tValue: 4,\n\t\t},\n\t})\n\n\tis.Len(r1, 2)\n\tis.Equal(r1[\"baz\"], 3)\n\tis.Equal(r1[\"qux\"], 4)\n}\n\nfunc TestInvert(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Invert(map[string]int{\"a\": 1, \"b\": 2})\n\tr2 := Invert(map[string]int{\"a\": 1, \"b\": 2, \"c\": 1})\n\n\tis.Len(r1, 2)\n\tis.EqualValues(map[int]string{1: \"a\", 2: \"b\"}, r1)\n\tis.Len(r2, 2)\n}\n\nfunc TestAssign(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Assign(map[string]int{\"a\": 1, \"b\": 2}, map[string]int{\"b\": 3, \"c\": 4})\n\n\tis.Len(result1, 3)\n\tis.Equal(result1, map[string]int{\"a\": 1, \"b\": 3, \"c\": 4})\n\n\ttype myMap map[string]int\n\tbefore := myMap{\"\": 0, \"foobar\": 6, \"baz\": 3}\n\tafter := Assign(before, before)\n\tis.IsType(after, before, \"type preserved\")\n}\n\nfunc TestMapKeys(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := MapKeys(map[int]int{1: 1, 2: 2, 3: 3, 4: 4}, func(x int, _ int) string {\n\t\treturn \"Hello\"\n\t})\n\tresult2 := MapKeys(map[int]int{1: 1, 2: 2, 3: 3, 4: 4}, func(_ int, v int) string {\n\t\treturn strconv.FormatInt(int64(v), 10)\n\t})\n\n\tis.Equal(len(result1), 1)\n\tis.Equal(len(result2), 4)\n\tis.Equal(result2, map[string]int{\"1\": 1, \"2\": 2, \"3\": 3, \"4\": 4})\n}\n\nfunc TestMapValues(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := MapValues(map[int]int{1: 1, 2: 2, 3: 3, 4: 4}, func(x int, _ int) string {\n\t\treturn \"Hello\"\n\t})\n\tresult2 := MapValues(map[int]int{1: 1, 2: 2, 3: 3, 4: 4}, func(x int, _ int) string {\n\t\treturn strconv.FormatInt(int64(x), 10)\n\t})\n\n\tis.Equal(len(result1), 4)\n\tis.Equal(len(result2), 4)\n\tis.Equal(result1, map[int]string{1: \"Hello\", 2: \"Hello\", 3: \"Hello\", 4: \"Hello\"})\n\tis.Equal(result2, map[int]string{1: \"1\", 2: \"2\", 3: \"3\", 4: \"4\"})\n}\n\nfunc mapEntriesTest[I any, O any](t *testing.T, in map[string]I, iteratee func(string, I) (string, O), expected map[string]O) {\n\tis := assert.New(t)\n\tresult := MapEntries(in, iteratee)\n\tis.Equal(result, expected)\n}\n\nfunc TestMapEntries(t *testing.T) {\n\tmapEntriesTest(t, map[string]int{\"foo\": 1, \"bar\": 2}, func(k string, v int) (string, int) {\n\t\treturn k, v + 1\n\t}, map[string]int{\"foo\": 2, \"bar\": 3})\n\tmapEntriesTest(t, map[string]int{\"foo\": 1, \"bar\": 2}, func(k string, v int) (string, string) {\n\t\treturn k, k + strconv.Itoa(v)\n\t}, map[string]string{\"foo\": \"foo1\", \"bar\": \"bar2\"})\n\tmapEntriesTest(t, map[string]int{\"foo\": 1, \"bar\": 2}, func(k string, v int) (string, string) {\n\t\treturn k, strconv.Itoa(v) + k\n\t}, map[string]string{\"foo\": \"1foo\", \"bar\": \"2bar\"})\n\n\t// NoMutation\n\t{\n\t\tis := assert.New(t)\n\t\tr1 := map[string]int{\"foo\": 1, \"bar\": 2}\n\t\tMapEntries(r1, func(k string, v int) (string, string) {\n\t\t\treturn k, strconv.Itoa(v) + \"!!\"\n\t\t})\n\t\tis.Equal(r1, map[string]int{\"foo\": 1, \"bar\": 2})\n\t}\n\t// EmptyInput\n\t{\n\t\tmapEntriesTest(t, map[string]int{}, func(k string, v int) (string, string) {\n\t\t\treturn k, strconv.Itoa(v) + \"!!\"\n\t\t}, map[string]string{})\n\n\t\tmapEntriesTest(t, map[string]any{}, func(k string, v any) (string, any) {\n\t\t\treturn k, v\n\t\t}, map[string]any{})\n\t}\n\t// Identity\n\t{\n\t\tmapEntriesTest(t, map[string]int{\"foo\": 1, \"bar\": 2}, func(k string, v int) (string, int) {\n\t\t\treturn k, v\n\t\t}, map[string]int{\"foo\": 1, \"bar\": 2})\n\t\tmapEntriesTest(t, map[string]any{\"foo\": 1, \"bar\": \"2\", \"ccc\": true}, func(k string, v any) (string, any) {\n\t\t\treturn k, v\n\t\t}, map[string]any{\"foo\": 1, \"bar\": \"2\", \"ccc\": true})\n\t}\n\t// ToConstantEntry\n\t{\n\t\tmapEntriesTest(t, map[string]any{\"foo\": 1, \"bar\": \"2\", \"ccc\": true}, func(k string, v any) (string, any) {\n\t\t\treturn \"key\", \"value\"\n\t\t}, map[string]any{\"key\": \"value\"})\n\t\tmapEntriesTest(t, map[string]any{\"foo\": 1, \"bar\": \"2\", \"ccc\": true}, func(k string, v any) (string, any) {\n\t\t\treturn \"b\", 5\n\t\t}, map[string]any{\"b\": 5})\n\t}\n\n\t//// OverlappingKeys\n\t//// because using range over map, the order is not guaranteed\n\t//// this test is not deterministic\n\t//{\n\t//\tmapEntriesTest(t, map[string]any{\"foo\": 1, \"foo2\": 2, \"Foo\": 2, \"Foo2\": \"2\", \"bar\": \"2\", \"ccc\": true}, func(k string, v any) (string, any) {\n\t//\t\treturn string(k[0]), v\n\t//\t}, map[string]any{\"F\": \"2\", \"b\": \"2\", \"c\": true, \"f\": 2})\n\t//\tmapEntriesTest(t, map[string]string{\"foo\": \"1\", \"foo2\": \"2\", \"Foo\": \"2\", \"Foo2\": \"2\", \"bar\": \"2\", \"ccc\": \"true\"}, func(k string, v string) (string, string) {\n\t//\t\treturn v, k\n\t//\t}, map[string]string{\"1\": \"foo\", \"2\": \"bar\", \"true\": \"ccc\"})\n\t//}\n\t//NormalMappers\n\t{\n\t\tmapEntriesTest(t, map[string]string{\"foo\": \"1\", \"foo2\": \"2\", \"Foo\": \"2\", \"Foo2\": \"2\", \"bar\": \"2\", \"ccc\": \"true\"}, func(k string, v string) (string, string) {\n\t\t\treturn k, k + v\n\t\t}, map[string]string{\"Foo\": \"Foo2\", \"Foo2\": \"Foo22\", \"bar\": \"bar2\", \"ccc\": \"ccctrue\", \"foo\": \"foo1\", \"foo2\": \"foo22\"})\n\n\t\tmapEntriesTest(t, map[string]struct {\n\t\t\tname string\n\t\t\tage  int\n\t\t}{\"1-11-1\": {name: \"foo\", age: 1}, \"2-22-2\": {name: \"bar\", age: 2}}, func(k string, v struct {\n\t\t\tname string\n\t\t\tage  int\n\t\t},\n\t\t) (string, string) {\n\t\t\treturn v.name, k\n\t\t}, map[string]string{\"bar\": \"2-22-2\", \"foo\": \"1-11-1\"})\n\t}\n}\n\nfunc TestMapToSlice(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := MapToSlice(map[int]int{1: 5, 2: 6, 3: 7, 4: 8}, func(k int, v int) string {\n\t\treturn fmt.Sprintf(\"%d_%d\", k, v)\n\t})\n\tresult2 := MapToSlice(map[int]int{1: 5, 2: 6, 3: 7, 4: 8}, func(k int, _ int) string {\n\t\treturn strconv.FormatInt(int64(k), 10)\n\t})\n\n\tis.Equal(len(result1), 4)\n\tis.Equal(len(result2), 4)\n\tis.ElementsMatch(result1, []string{\"1_5\", \"2_6\", \"3_7\", \"4_8\"})\n\tis.ElementsMatch(result2, []string{\"1\", \"2\", \"3\", \"4\"})\n}\n\nfunc BenchmarkAssign(b *testing.B) {\n\tcounts := []int{32768, 1024, 128, 32, 2}\n\n\tallDifferentMap := func(b *testing.B, n int) []map[string]int {\n\t\tdefer b.ResetTimer()\n\t\tm := make([]map[string]int, 0)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tm = append(m, map[string]int{\n\t\t\t\tstrconv.Itoa(i): i,\n\t\t\t\tstrconv.Itoa(i): i,\n\t\t\t\tstrconv.Itoa(i): i,\n\t\t\t\tstrconv.Itoa(i): i,\n\t\t\t\tstrconv.Itoa(i): i,\n\t\t\t\tstrconv.Itoa(i): i,\n\t\t\t},\n\t\t\t)\n\t\t}\n\t\treturn m\n\t}\n\n\tallTheSameMap := func(b *testing.B, n int) []map[string]int {\n\t\tdefer b.ResetTimer()\n\t\tm := make([]map[string]int, 0)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tm = append(m, map[string]int{\n\t\t\t\t\"a\": 1,\n\t\t\t\t\"b\": 2,\n\t\t\t\t\"c\": 3,\n\t\t\t\t\"d\": 4,\n\t\t\t\t\"e\": 5,\n\t\t\t\t\"f\": 6,\n\t\t\t},\n\t\t\t)\n\t\t}\n\t\treturn m\n\t}\n\n\tfor _, count := range counts {\n\t\tdifferentMap := allDifferentMap(b, count)\n\t\tsameMap := allTheSameMap(b, count)\n\n\t\tb.Run(fmt.Sprintf(\"%d\", count), func(b *testing.B) {\n\t\t\ttestcase := []struct {\n\t\t\t\tname string\n\t\t\t\tmaps []map[string]int\n\t\t\t}{\n\t\t\t\t{\"different\", differentMap},\n\t\t\t\t{\"same\", sameMap},\n\t\t\t}\n\n\t\t\tfor _, tc := range testcase {\n\t\t\t\tb.Run(tc.name, func(b *testing.B) {\n\t\t\t\t\tb.ResetTimer()\n\t\t\t\t\tfor n := 0; n < b.N; n++ {\n\t\t\t\t\t\tresult := Assign(tc.maps...)\n\t\t\t\t\t\t_ = result\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\n\t}\n}\n"
        },
        {
          "name": "math.go",
          "type": "blob",
          "size": 3.0185546875,
          "content": "package lo\n\nimport (\n\t\"github.com/samber/lo/internal/constraints\"\n)\n\n// Range creates an array of numbers (positive and/or negative) with given length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nfunc Range(elementNum int) []int {\n\tlength := If(elementNum < 0, -elementNum).Else(elementNum)\n\tresult := make([]int, length)\n\tstep := If(elementNum < 0, -1).Else(1)\n\tfor i, j := 0, 0; i < length; i, j = i+1, j+step {\n\t\tresult[i] = j\n\t}\n\treturn result\n}\n\n// RangeFrom creates an array of numbers from start with specified length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nfunc RangeFrom[T constraints.Integer | constraints.Float](start T, elementNum int) []T {\n\tlength := If(elementNum < 0, -elementNum).Else(elementNum)\n\tresult := make([]T, length)\n\tstep := If(elementNum < 0, -1).Else(1)\n\tfor i, j := 0, start; i < length; i, j = i+1, j+T(step) {\n\t\tresult[i] = j\n\t}\n\treturn result\n}\n\n// RangeWithSteps creates an array of numbers (positive and/or negative) progressing from start up to, but not including end.\n// step set to zero will return empty array.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nfunc RangeWithSteps[T constraints.Integer | constraints.Float](start, end, step T) []T {\n\tresult := []T{}\n\tif start == end || step == 0 {\n\t\treturn result\n\t}\n\tif start < end {\n\t\tif step < 0 {\n\t\t\treturn result\n\t\t}\n\t\tfor i := start; i < end; i += step {\n\t\t\tresult = append(result, i)\n\t\t}\n\t\treturn result\n\t}\n\tif step > 0 {\n\t\treturn result\n\t}\n\tfor i := start; i > end; i += step {\n\t\tresult = append(result, i)\n\t}\n\treturn result\n}\n\n// Clamp clamps number within the inclusive lower and upper bounds.\n// Play: https://go.dev/play/p/RU4lJNC2hlI\nfunc Clamp[T constraints.Ordered](value T, min T, max T) T {\n\tif value < min {\n\t\treturn min\n\t} else if value > max {\n\t\treturn max\n\t}\n\treturn value\n}\n\n// Sum sums the values in a collection. If collection is empty 0 is returned.\n// Play: https://go.dev/play/p/upfeJVqs4Bt\nfunc Sum[T constraints.Float | constraints.Integer | constraints.Complex](collection []T) T {\n\tvar sum T = 0\n\tfor i := range collection {\n\t\tsum += collection[i]\n\t}\n\treturn sum\n}\n\n// SumBy summarizes the values in a collection using the given return value from the iteration function. If collection is empty 0 is returned.\n// Play: https://go.dev/play/p/Dz_a_7jN_ca\nfunc SumBy[T any, R constraints.Float | constraints.Integer | constraints.Complex](collection []T, iteratee func(item T) R) R {\n\tvar sum R = 0\n\tfor i := range collection {\n\t\tsum = sum + iteratee(collection[i])\n\t}\n\treturn sum\n}\n\n// Mean calculates the mean of a collection of numbers.\nfunc Mean[T constraints.Float | constraints.Integer](collection []T) T {\n\tvar length = T(len(collection))\n\tif length == 0 {\n\t\treturn 0\n\t}\n\tvar sum = Sum(collection)\n\treturn sum / length\n}\n\n// MeanBy calculates the mean of a collection of numbers using the given return value from the iteration function.\nfunc MeanBy[T any, R constraints.Float | constraints.Integer](collection []T, iteratee func(item T) R) R {\n\tvar length = R(len(collection))\n\tif length == 0 {\n\t\treturn 0\n\t}\n\tvar sum = SumBy(collection, iteratee)\n\treturn sum / length\n}\n"
        },
        {
          "name": "math_example_test.go",
          "type": "blob",
          "size": 1.404296875,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n)\n\nfunc ExampleRange() {\n\tresult1 := Range(4)\n\tresult2 := Range(-4)\n\tresult3 := RangeFrom(1, 5)\n\tresult4 := RangeFrom(1.0, 5)\n\tresult5 := RangeWithSteps(0, 20, 5)\n\tresult6 := RangeWithSteps[float32](-1.0, -4.0, -1.0)\n\tresult7 := RangeWithSteps(1, 4, -1)\n\tresult8 := Range(0)\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\tfmt.Printf(\"%v\\n\", result6)\n\tfmt.Printf(\"%v\\n\", result7)\n\tfmt.Printf(\"%v\\n\", result8)\n\t// Output:\n\t// [0 1 2 3]\n\t// [0 -1 -2 -3]\n\t// [1 2 3 4 5]\n\t// [1 2 3 4 5]\n\t// [0 5 10 15]\n\t// [-1 -2 -3]\n\t// []\n\t// []\n}\n\nfunc ExampleClamp() {\n\tresult1 := Clamp(0, -10, 10)\n\tresult2 := Clamp(-42, -10, 10)\n\tresult3 := Clamp(42, -10, 10)\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\t// Output:\n\t// 0\n\t// -10\n\t// 10\n}\n\nfunc ExampleSum() {\n\tlist := []int{1, 2, 3, 4, 5}\n\n\tsum := Sum(list)\n\n\tfmt.Printf(\"%v\", sum)\n\t// Output: 15\n}\n\nfunc ExampleSumBy() {\n\tlist := []string{\"foo\", \"bar\"}\n\n\tresult := SumBy(list, func(item string) int {\n\t\treturn len(item)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: 6\n}\n\nfunc ExampleMean() {\n\tlist := []int{1, 2, 3, 4, 5}\n\n\tresult := Mean(list)\n\n\tfmt.Printf(\"%v\", result)\n}\n\nfunc ExampleMeanBy() {\n\tlist := []string{\"foo\", \"bar\"}\n\n\tresult := MeanBy(list, func(item string) int {\n\t\treturn len(item)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n}\n"
        },
        {
          "name": "math_test.go",
          "type": "blob",
          "size": 3.3134765625,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRange(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Range(4)\n\tresult2 := Range(-4)\n\tresult3 := Range(0)\n\tis.Equal(result1, []int{0, 1, 2, 3})\n\tis.Equal(result2, []int{0, -1, -2, -3})\n\tis.Equal(result3, []int{})\n}\n\nfunc TestRangeFrom(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := RangeFrom(1, 5)\n\tresult2 := RangeFrom(-1, -5)\n\tresult3 := RangeFrom(10, 0)\n\tresult4 := RangeFrom(2.0, 3)\n\tresult5 := RangeFrom(-2.0, -3)\n\tis.Equal(result1, []int{1, 2, 3, 4, 5})\n\tis.Equal(result2, []int{-1, -2, -3, -4, -5})\n\tis.Equal(result3, []int{})\n\tis.Equal(result4, []float64{2.0, 3.0, 4.0})\n\tis.Equal(result5, []float64{-2.0, -3.0, -4.0})\n}\n\nfunc TestRangeClose(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := RangeWithSteps(0, 20, 6)\n\tresult2 := RangeWithSteps(0, 3, -5)\n\tresult3 := RangeWithSteps(1, 1, 0)\n\tresult4 := RangeWithSteps(3, 2, 1)\n\tresult5 := RangeWithSteps(1.0, 4.0, 2.0)\n\tresult6 := RangeWithSteps[float32](-1.0, -4.0, -1.0)\n\tis.Equal([]int{0, 6, 12, 18}, result1)\n\tis.Equal([]int{}, result2)\n\tis.Equal([]int{}, result3)\n\tis.Equal([]int{}, result4)\n\tis.Equal([]float64{1.0, 3.0}, result5)\n\tis.Equal([]float32{-1.0, -2.0, -3.0}, result6)\n}\n\nfunc TestClamp(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Clamp(0, -10, 10)\n\tresult2 := Clamp(-42, -10, 10)\n\tresult3 := Clamp(42, -10, 10)\n\n\tis.Equal(result1, 0)\n\tis.Equal(result2, -10)\n\tis.Equal(result3, 10)\n}\n\nfunc TestSum(t *testing.T) {\n\tis := assert.New(t)\n\n\tresult1 := Sum([]float32{2.3, 3.3, 4, 5.3})\n\tresult2 := Sum([]int32{2, 3, 4, 5})\n\tresult3 := Sum([]uint32{2, 3, 4, 5})\n\tresult4 := Sum([]uint32{})\n\tresult5 := Sum([]complex128{4_4, 2_2})\n\n\tis.Equal(result1, float32(14.900001))\n\tis.Equal(result2, int32(14))\n\tis.Equal(result3, uint32(14))\n\tis.Equal(result4, uint32(0))\n\tis.Equal(result5, complex128(6_6))\n}\n\nfunc TestSumBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := SumBy([]float32{2.3, 3.3, 4, 5.3}, func(n float32) float32 { return n })\n\tresult2 := SumBy([]int32{2, 3, 4, 5}, func(n int32) int32 { return n })\n\tresult3 := SumBy([]uint32{2, 3, 4, 5}, func(n uint32) uint32 { return n })\n\tresult4 := SumBy([]uint32{}, func(n uint32) uint32 { return n })\n\tresult5 := SumBy([]complex128{4_4, 2_2}, func(n complex128) complex128 { return n })\n\n\tis.Equal(result1, float32(14.900001))\n\tis.Equal(result2, int32(14))\n\tis.Equal(result3, uint32(14))\n\tis.Equal(result4, uint32(0))\n\tis.Equal(result5, complex128(6_6))\n}\n\nfunc TestMean(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Mean([]float32{2.3, 3.3, 4, 5.3})\n\tresult2 := Mean([]int32{2, 3, 4, 5})\n\tresult3 := Mean([]uint32{2, 3, 4, 5})\n\tresult4 := Mean([]uint32{})\n\n\tis.Equal(result1, float32(3.7250001))\n\tis.Equal(result2, int32(3))\n\tis.Equal(result3, uint32(3))\n\tis.Equal(result4, uint32(0))\n}\n\nfunc TestMeanBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := MeanBy([]float32{2.3, 3.3, 4, 5.3}, func(n float32) float32 { return n })\n\tresult2 := MeanBy([]int32{2, 3, 4, 5}, func(n int32) int32 { return n })\n\tresult3 := MeanBy([]uint32{2, 3, 4, 5}, func(n uint32) uint32 { return n })\n\tresult4 := MeanBy([]uint32{}, func(n uint32) uint32 { return n })\n\n\tis.Equal(result1, float32(3.7250001))\n\tis.Equal(result2, int32(3))\n\tis.Equal(result3, uint32(3))\n\tis.Equal(result4, uint32(0))\n}\n"
        },
        {
          "name": "parallel",
          "type": "tree",
          "content": null
        },
        {
          "name": "retry.go",
          "type": "blob",
          "size": 6.5068359375,
          "content": "package lo\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype debounce struct {\n\tafter     time.Duration\n\tmu        *sync.Mutex\n\ttimer     *time.Timer\n\tdone      bool\n\tcallbacks []func()\n}\n\nfunc (d *debounce) reset() {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tif d.done {\n\t\treturn\n\t}\n\n\tif d.timer != nil {\n\t\td.timer.Stop()\n\t}\n\n\td.timer = time.AfterFunc(d.after, func() {\n\t\tfor i := range d.callbacks {\n\t\t\td.callbacks[i]()\n\t\t}\n\t})\n}\n\nfunc (d *debounce) cancel() {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tif d.timer != nil {\n\t\td.timer.Stop()\n\t\td.timer = nil\n\t}\n\n\td.done = true\n}\n\n// NewDebounce creates a debounced instance that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/mz32VMK2nqe\nfunc NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n\td := &debounce{\n\t\tafter:     duration,\n\t\tmu:        new(sync.Mutex),\n\t\ttimer:     nil,\n\t\tdone:      false,\n\t\tcallbacks: f,\n\t}\n\n\treturn func() {\n\t\td.reset()\n\t}, d.cancel\n}\n\ntype debounceByItem struct {\n\tmu    *sync.Mutex\n\ttimer *time.Timer\n\tcount int\n}\n\ntype debounceBy[T comparable] struct {\n\tafter     time.Duration\n\tmu        *sync.Mutex\n\titems     map[T]*debounceByItem\n\tcallbacks []func(key T, count int)\n}\n\nfunc (d *debounceBy[T]) reset(key T) {\n\td.mu.Lock()\n\tif _, ok := d.items[key]; !ok {\n\t\td.items[key] = &debounceByItem{\n\t\t\tmu:    new(sync.Mutex),\n\t\t\ttimer: nil,\n\t\t}\n\t}\n\n\titem := d.items[key]\n\n\td.mu.Unlock()\n\n\titem.mu.Lock()\n\tdefer item.mu.Unlock()\n\n\titem.count++\n\n\tif item.timer != nil {\n\t\titem.timer.Stop()\n\t}\n\n\titem.timer = time.AfterFunc(d.after, func() {\n\t\titem.mu.Lock()\n\t\tcount := item.count\n\t\titem.count = 0\n\t\titem.mu.Unlock()\n\n\t\tfor i := range d.callbacks {\n\t\t\td.callbacks[i](key, count)\n\t\t}\n\t})\n}\n\nfunc (d *debounceBy[T]) cancel(key T) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\n\tif item, ok := d.items[key]; ok {\n\t\titem.mu.Lock()\n\n\t\tif item.timer != nil {\n\t\t\titem.timer.Stop()\n\t\t\titem.timer = nil\n\t\t}\n\n\t\titem.mu.Unlock()\n\n\t\tdelete(d.items, key)\n\t}\n}\n\n// NewDebounceBy creates a debounced instance for each distinct key, that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/d3Vpt6pxhY8\nfunc NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n\td := &debounceBy[T]{\n\t\tafter:     duration,\n\t\tmu:        new(sync.Mutex),\n\t\titems:     map[T]*debounceByItem{},\n\t\tcallbacks: f,\n\t}\n\n\treturn func(key T) {\n\t\td.reset(key)\n\t}, d.cancel\n}\n\n// Attempt invokes a function N times until it returns valid output. Returns either the caught error or nil.\n// When the first argument is less than `1`, the function runs until a successful response is returned.\n// Play: https://go.dev/play/p/3ggJZ2ZKcMj\nfunc Attempt(maxIteration int, f func(index int) error) (int, error) {\n\tvar err error\n\n\tfor i := 0; maxIteration <= 0 || i < maxIteration; i++ {\n\t\t// for retries >= 0 {\n\t\terr = f(i)\n\t\tif err == nil {\n\t\t\treturn i + 1, nil\n\t\t}\n\t}\n\n\treturn maxIteration, err\n}\n\n// AttemptWithDelay invokes a function N times until it returns valid output,\n// with a pause between each call. Returns either the caught error or nil.\n// When the first argument is less than `1`, the function runs until a successful\n// response is returned.\n// Play: https://go.dev/play/p/tVs6CygC7m1\nfunc AttemptWithDelay(maxIteration int, delay time.Duration, f func(index int, duration time.Duration) error) (int, time.Duration, error) {\n\tvar err error\n\n\tstart := time.Now()\n\n\tfor i := 0; maxIteration <= 0 || i < maxIteration; i++ {\n\t\terr = f(i, time.Since(start))\n\t\tif err == nil {\n\t\t\treturn i + 1, time.Since(start), nil\n\t\t}\n\n\t\tif maxIteration <= 0 || i+1 < maxIteration {\n\t\t\ttime.Sleep(delay)\n\t\t}\n\t}\n\n\treturn maxIteration, time.Since(start), err\n}\n\n// AttemptWhile invokes a function N times until it returns valid output.\n// Returns either the caught error or nil, along with a bool value to determine\n// whether the function should be invoked again. It will terminate the invoke\n// immediately if the second return value is false. When the first\n// argument is less than `1`, the function runs until a successful response is\n// returned.\nfunc AttemptWhile(maxIteration int, f func(int) (error, bool)) (int, error) {\n\tvar err error\n\tvar shouldContinueInvoke bool\n\n\tfor i := 0; maxIteration <= 0 || i < maxIteration; i++ {\n\t\t// for retries >= 0 {\n\t\terr, shouldContinueInvoke = f(i)\n\t\tif !shouldContinueInvoke { // if shouldContinueInvoke is false, then return immediately\n\t\t\treturn i + 1, err\n\t\t}\n\t\tif err == nil {\n\t\t\treturn i + 1, nil\n\t\t}\n\t}\n\n\treturn maxIteration, err\n}\n\n// AttemptWhileWithDelay invokes a function N times until it returns valid output,\n// with a pause between each call. Returns either the caught error or nil, along\n// with a bool value to determine whether the function should be invoked again.\n// It will terminate the invoke immediately if the second return value is false.\n// When the first argument is less than `1`, the function runs until a successful\n// response is returned.\nfunc AttemptWhileWithDelay(maxIteration int, delay time.Duration, f func(int, time.Duration) (error, bool)) (int, time.Duration, error) {\n\tvar err error\n\tvar shouldContinueInvoke bool\n\n\tstart := time.Now()\n\n\tfor i := 0; maxIteration <= 0 || i < maxIteration; i++ {\n\t\terr, shouldContinueInvoke = f(i, time.Since(start))\n\t\tif !shouldContinueInvoke { // if shouldContinueInvoke is false, then return immediately\n\t\t\treturn i + 1, time.Since(start), err\n\t\t}\n\t\tif err == nil {\n\t\t\treturn i + 1, time.Since(start), nil\n\t\t}\n\n\t\tif maxIteration <= 0 || i+1 < maxIteration {\n\t\t\ttime.Sleep(delay)\n\t\t}\n\t}\n\n\treturn maxIteration, time.Since(start), err\n}\n\ntype transactionStep[T any] struct {\n\texec       func(T) (T, error)\n\tonRollback func(T) T\n}\n\n// NewTransaction instantiate a new transaction.\nfunc NewTransaction[T any]() *Transaction[T] {\n\treturn &Transaction[T]{\n\t\tsteps: []transactionStep[T]{},\n\t}\n}\n\n// Transaction implements a Saga pattern\ntype Transaction[T any] struct {\n\tsteps []transactionStep[T]\n}\n\n// Then adds a step to the chain of callbacks. It returns the same Transaction.\nfunc (t *Transaction[T]) Then(exec func(T) (T, error), onRollback func(T) T) *Transaction[T] {\n\tt.steps = append(t.steps, transactionStep[T]{\n\t\texec:       exec,\n\t\tonRollback: onRollback,\n\t})\n\n\treturn t\n}\n\n// Process runs the Transaction steps and rollbacks in case of errors.\nfunc (t *Transaction[T]) Process(state T) (T, error) {\n\tvar i int\n\tvar err error\n\n\tfor i < len(t.steps) {\n\t\tstate, err = t.steps[i].exec(state)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\ti++\n\t}\n\n\tif err == nil {\n\t\treturn state, nil\n\t}\n\n\tfor i > 0 {\n\t\ti--\n\t\tstate = t.steps[i].onRollback(state)\n\t}\n\n\treturn state, err\n}\n\n// throttle ?\n"
        },
        {
          "name": "retry_example_test.go",
          "type": "blob",
          "size": 4.12109375,
          "content": "//go:build !race\n// +build !race\n\npackage lo\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nfunc ExampleNewDebounce() {\n\ti := int32(0)\n\tcalls := []int32{}\n\tmu := sync.Mutex{}\n\n\tdebounce, cancel := NewDebounce(time.Millisecond, func() {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tcalls = append(calls, atomic.LoadInt32(&i))\n\t})\n\n\tdebounce()\n\tatomic.AddInt32(&i, 1)\n\n\ttime.Sleep(5 * time.Millisecond)\n\n\tdebounce()\n\tatomic.AddInt32(&i, 1)\n\tdebounce()\n\tatomic.AddInt32(&i, 1)\n\tdebounce()\n\tatomic.AddInt32(&i, 1)\n\n\ttime.Sleep(5 * time.Millisecond)\n\n\tcancel()\n\n\tmu.Lock()\n\tfmt.Printf(\"%v\", calls)\n\tmu.Unlock()\n\t// Output: [1 4]\n}\n\nfunc ExampleNewDebounceBy() {\n\tcalls := map[string][]int{}\n\tmu := sync.Mutex{}\n\n\tdebounce, cancel := NewDebounceBy(time.Millisecond, func(userID string, count int) {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\n\t\tif _, ok := calls[userID]; !ok {\n\t\t\tcalls[userID] = []int{}\n\t\t}\n\n\t\tcalls[userID] = append(calls[userID], count)\n\t})\n\n\tdebounce(\"samuel\")\n\tdebounce(\"john\")\n\n\ttime.Sleep(5 * time.Millisecond)\n\n\tdebounce(\"john\")\n\tdebounce(\"john\")\n\tdebounce(\"samuel\")\n\tdebounce(\"john\")\n\n\ttime.Sleep(5 * time.Millisecond)\n\n\tcancel(\"samuel\")\n\tcancel(\"john\")\n\n\tmu.Lock()\n\tfmt.Printf(\"samuel: %v\\n\", calls[\"samuel\"])\n\tfmt.Printf(\"john: %v\\n\", calls[\"john\"])\n\tmu.Unlock()\n\t// Output:\n\t// samuel: [1 1]\n\t// john: [1 3]\n}\n\nfunc ExampleAttempt() {\n\tcount1, err1 := Attempt(2, func(i int) error {\n\t\tif i == 0 {\n\t\t\treturn fmt.Errorf(\"error\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tcount2, err2 := Attempt(2, func(i int) error {\n\t\tif i < 10 {\n\t\t\treturn fmt.Errorf(\"error\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tfmt.Printf(\"%v %v\\n\", count1, err1)\n\tfmt.Printf(\"%v %v\\n\", count2, err2)\n\t// Output:\n\t// 2 <nil>\n\t// 2 error\n}\n\nfunc ExampleAttemptWithDelay() {\n\tcount1, time1, err1 := AttemptWithDelay(2, time.Millisecond, func(i int, _ time.Duration) error {\n\t\tif i == 0 {\n\t\t\treturn fmt.Errorf(\"error\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tcount2, time2, err2 := AttemptWithDelay(2, time.Millisecond, func(i int, _ time.Duration) error {\n\t\tif i < 10 {\n\t\t\treturn fmt.Errorf(\"error\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tfmt.Printf(\"%v %v %v\\n\", count1, time1.Truncate(time.Millisecond), err1)\n\tfmt.Printf(\"%v %v %v\\n\", count2, time2.Truncate(time.Millisecond), err2)\n\t// Output:\n\t// 2 1ms <nil>\n\t// 2 1ms error\n}\n\nfunc ExampleTransaction() {\n\ttransaction := NewTransaction[int]().\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\tfmt.Println(\"step 1\")\n\t\t\t\treturn state + 10, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\tfmt.Println(\"rollback 1\")\n\t\t\t\treturn state - 10\n\t\t\t},\n\t\t).\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\tfmt.Println(\"step 2\")\n\t\t\t\treturn state + 15, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\tfmt.Println(\"rollback 2\")\n\t\t\t\treturn state - 15\n\t\t\t},\n\t\t).\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\tfmt.Println(\"step 3\")\n\n\t\t\t\tif true {\n\t\t\t\t\treturn state, fmt.Errorf(\"error\")\n\t\t\t\t}\n\n\t\t\t\treturn state + 42, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\tfmt.Println(\"rollback 3\")\n\t\t\t\treturn state - 42\n\t\t\t},\n\t\t)\n\n\t_, _ = transaction.Process(-5)\n\n\t// Output:\n\t// step 1\n\t// step 2\n\t// step 3\n\t// rollback 2\n\t// rollback 1\n}\n\nfunc ExampleTransaction_ok() {\n\ttransaction := NewTransaction[int]().\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\treturn state + 10, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\treturn state - 10\n\t\t\t},\n\t\t).\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\treturn state + 15, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\treturn state - 15\n\t\t\t},\n\t\t).\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\treturn state + 42, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\treturn state - 42\n\t\t\t},\n\t\t)\n\n\tstate, err := transaction.Process(-5)\n\n\tfmt.Println(state)\n\tfmt.Println(err)\n\t// Output:\n\t// 62\n\t// <nil>\n}\n\nfunc ExampleTransaction_error() {\n\ttransaction := NewTransaction[int]().\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\treturn state + 10, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\treturn state - 10\n\t\t\t},\n\t\t).\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\treturn state, fmt.Errorf(\"error\")\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\treturn state - 15\n\t\t\t},\n\t\t).\n\t\tThen(\n\t\t\tfunc(state int) (int, error) {\n\t\t\t\treturn state + 42, nil\n\t\t\t},\n\t\t\tfunc(state int) int {\n\t\t\t\treturn state - 42\n\t\t\t},\n\t\t)\n\n\tstate, err := transaction.Process(-5)\n\n\tfmt.Println(state)\n\tfmt.Println(err)\n\t// Output:\n\t// -5\n\t// error\n}\n"
        },
        {
          "name": "retry_test.go",
          "type": "blob",
          "size": 9.4091796875,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestAttempt(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\terr := fmt.Errorf(\"failed\")\n\n\titer1, err1 := Attempt(42, func(i int) error {\n\t\treturn nil\n\t})\n\titer2, err2 := Attempt(42, func(i int) error {\n\t\tif i == 5 {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t})\n\titer3, err3 := Attempt(2, func(i int) error {\n\t\tif i == 5 {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t})\n\titer4, err4 := Attempt(0, func(i int) error {\n\t\tif i < 42 {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tis.Equal(iter1, 1)\n\tis.Equal(err1, nil)\n\tis.Equal(iter2, 6)\n\tis.Equal(err2, nil)\n\tis.Equal(iter3, 2)\n\tis.Equal(err3, err)\n\tis.Equal(iter4, 43)\n\tis.Equal(err4, nil)\n}\n\nfunc TestAttemptWithDelay(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\terr := fmt.Errorf(\"failed\")\n\n\titer1, dur1, err1 := AttemptWithDelay(42, 10*time.Millisecond, func(i int, d time.Duration) error {\n\t\treturn nil\n\t})\n\titer2, dur2, err2 := AttemptWithDelay(42, 10*time.Millisecond, func(i int, d time.Duration) error {\n\t\tif i == 5 {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t})\n\titer3, dur3, err3 := AttemptWithDelay(2, 10*time.Millisecond, func(i int, d time.Duration) error {\n\t\tif i == 5 {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t})\n\titer4, dur4, err4 := AttemptWithDelay(0, 10*time.Millisecond, func(i int, d time.Duration) error {\n\t\tif i < 10 {\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t})\n\n\tis.Equal(iter1, 1)\n\tis.GreaterOrEqual(dur1, 0*time.Millisecond)\n\tis.Less(dur1, 1*time.Millisecond)\n\tis.Equal(err1, nil)\n\tis.Equal(iter2, 6)\n\tis.Greater(dur2, 50*time.Millisecond)\n\tis.Less(dur2, 60*time.Millisecond)\n\tis.Equal(err2, nil)\n\tis.Equal(iter3, 2)\n\tis.Greater(dur3, 10*time.Millisecond)\n\tis.Less(dur3, 20*time.Millisecond)\n\tis.Equal(err3, err)\n\tis.Equal(iter4, 11)\n\tis.Greater(dur4, 100*time.Millisecond)\n\tis.Less(dur4, 115*time.Millisecond)\n\tis.Equal(err4, nil)\n}\n\nfunc TestAttemptWhile(t *testing.T) {\n\tis := assert.New(t)\n\n\terr := fmt.Errorf(\"failed\")\n\n\titer1, err1 := AttemptWhile(42, func(i int) (error, bool) {\n\t\treturn nil, true\n\t})\n\n\tis.Equal(iter1, 1)\n\tis.Nil(err1)\n\n\titer2, err2 := AttemptWhile(42, func(i int) (error, bool) {\n\t\tif i == 5 {\n\t\t\treturn nil, true\n\t\t}\n\n\t\treturn err, true\n\t})\n\n\tis.Equal(iter2, 6)\n\tis.Nil(err2)\n\n\titer3, err3 := AttemptWhile(2, func(i int) (error, bool) {\n\t\tif i == 5 {\n\t\t\treturn nil, true\n\t\t}\n\n\t\treturn err, true\n\t})\n\n\tis.Equal(iter3, 2)\n\tis.Equal(err3, err)\n\n\titer4, err4 := AttemptWhile(0, func(i int) (error, bool) {\n\t\tif i < 42 {\n\t\t\treturn err, true\n\t\t}\n\n\t\treturn nil, true\n\t})\n\n\tis.Equal(iter4, 43)\n\tis.Nil(err4)\n\n\titer5, err5 := AttemptWhile(0, func(i int) (error, bool) {\n\t\tif i == 5 {\n\t\t\treturn nil, false\n\t\t}\n\n\t\treturn err, true\n\t})\n\n\tis.Equal(iter5, 6)\n\tis.Nil(err5)\n\n\titer6, err6 := AttemptWhile(0, func(i int) (error, bool) {\n\t\treturn nil, false\n\t})\n\n\tis.Equal(iter6, 1)\n\tis.Nil(err6)\n\n\titer7, err7 := AttemptWhile(42, func(i int) (error, bool) {\n\t\tif i == 42 {\n\t\t\treturn nil, false\n\t\t}\n\t\tif i < 41 {\n\t\t\treturn err, true\n\t\t}\n\n\t\treturn nil, true\n\t})\n\n\tis.Equal(iter7, 42)\n\tis.Nil(err7)\n}\n\nfunc TestAttemptWhileWithDelay(t *testing.T) {\n\tis := assert.New(t)\n\n\terr := fmt.Errorf(\"failed\")\n\n\titer1, dur1, err1 := AttemptWhileWithDelay(42, 10*time.Millisecond, func(i int, d time.Duration) (error, bool) {\n\t\treturn nil, true\n\t})\n\n\tis.Equal(iter1, 1)\n\tis.GreaterOrEqual(dur1, 0*time.Millisecond)\n\tis.Less(dur1, 1*time.Millisecond)\n\tis.Nil(err1)\n\n\titer2, dur2, err2 := AttemptWhileWithDelay(42, 10*time.Millisecond, func(i int, d time.Duration) (error, bool) {\n\t\tif i == 5 {\n\t\t\treturn nil, true\n\t\t}\n\n\t\treturn err, true\n\t})\n\n\tis.Equal(iter2, 6)\n\tis.Greater(dur2, 50*time.Millisecond)\n\tis.Less(dur2, 60*time.Millisecond)\n\tis.Nil(err2)\n\n\titer3, dur3, err3 := AttemptWhileWithDelay(2, 10*time.Millisecond, func(i int, d time.Duration) (error, bool) {\n\t\tif i == 5 {\n\t\t\treturn nil, true\n\t\t}\n\n\t\treturn err, true\n\t})\n\n\tis.Equal(iter3, 2)\n\tis.Greater(dur3, 10*time.Millisecond)\n\tis.Less(dur3, 20*time.Millisecond)\n\tis.Equal(err3, err)\n\n\titer4, dur4, err4 := AttemptWhileWithDelay(0, 10*time.Millisecond, func(i int, d time.Duration) (error, bool) {\n\t\tif i < 10 {\n\t\t\treturn err, true\n\t\t}\n\n\t\treturn nil, true\n\t})\n\n\tis.Equal(iter4, 11)\n\tis.Greater(dur4, 100*time.Millisecond)\n\tis.Less(dur4, 115*time.Millisecond)\n\tis.Nil(err4)\n\n\titer5, dur5, err5 := AttemptWhileWithDelay(0, 10*time.Millisecond, func(i int, d time.Duration) (error, bool) {\n\t\tif i == 5 {\n\t\t\treturn nil, false\n\t\t}\n\n\t\treturn err, true\n\t})\n\n\tis.Equal(iter5, 6)\n\tis.Greater(dur5, 10*time.Millisecond)\n\tis.Less(dur5, 115*time.Millisecond)\n\tis.Nil(err5)\n\n\titer6, dur6, err6 := AttemptWhileWithDelay(0, 10*time.Millisecond, func(i int, d time.Duration) (error, bool) {\n\t\treturn nil, false\n\t})\n\n\tis.Equal(iter6, 1)\n\tis.Less(dur6, 10*time.Millisecond)\n\tis.Less(dur6, 115*time.Millisecond)\n\tis.Nil(err6)\n\n\titer7, dur7, err7 := AttemptWhileWithDelay(42, 10*time.Millisecond, func(i int, d time.Duration) (error, bool) {\n\t\tif i == 42 {\n\t\t\treturn nil, false\n\t\t}\n\t\tif i < 41 {\n\t\t\treturn err, true\n\t\t}\n\n\t\treturn nil, true\n\t})\n\n\tis.Equal(iter7, 42)\n\tis.Less(dur7, 500*time.Millisecond)\n\tis.Nil(err7)\n}\n\nfunc TestDebounce(t *testing.T) {\n\tt.Parallel()\n\n\tf1 := func() {\n\t\tprintln(\"1. Called once after 10ms when func stopped invoking!\")\n\t}\n\tf2 := func() {\n\t\tprintln(\"2. Called once after 10ms when func stopped invoking!\")\n\t}\n\tf3 := func() {\n\t\tprintln(\"3. Called once after 10ms when func stopped invoking!\")\n\t}\n\n\td1, _ := NewDebounce(10*time.Millisecond, f1)\n\n\t// execute 3 times\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 10; j++ {\n\t\t\td1()\n\t\t}\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\n\td2, _ := NewDebounce(10*time.Millisecond, f2)\n\n\t// execute once because it is always invoked and only last invoke is worked after 100ms\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 5; j++ {\n\t\t\td2()\n\t\t}\n\t\ttime.Sleep(5 * time.Millisecond)\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\t// execute once because it is canceled after 200ms.\n\td3, cancel := NewDebounce(10*time.Millisecond, f3)\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 10; j++ {\n\t\t\td3()\n\t\t}\n\t\ttime.Sleep(20 * time.Millisecond)\n\t\tif i == 0 {\n\t\t\tcancel()\n\t\t}\n\t}\n}\n\nfunc TestDebounceBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tmu := sync.Mutex{}\n\toutput := map[int]int{0: 0, 1: 0, 2: 0}\n\n\tf1 := func(key int, count int) {\n\t\tmu.Lock()\n\t\toutput[key] += count\n\t\tmu.Unlock()\n\t\t// fmt.Printf(\"[key=%d] 1. Called once after 10ms when func stopped invoking!\\n\", key)\n\t}\n\tf2 := func(key int, count int) {\n\t\tmu.Lock()\n\t\toutput[key] += count\n\t\tmu.Unlock()\n\t\t// fmt.Printf(\"[key=%d] 2. Called once after 10ms when func stopped invoking!\\n\", key)\n\t}\n\tf3 := func(key int, count int) {\n\t\tmu.Lock()\n\t\toutput[key] += count\n\t\tmu.Unlock()\n\t\t// fmt.Printf(\"[key=%d] 3. Called once after 10ms when func stopped invoking!\\n\", key)\n\t}\n\n\td1, _ := NewDebounceBy(10*time.Millisecond, f1)\n\n\t// execute 3 times\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 10; j++ {\n\t\t\tfor k := 0; k < 3; k++ {\n\t\t\t\td1(k)\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\n\tmu.Lock()\n\tis.EqualValues(output[0], 30)\n\tis.EqualValues(output[1], 30)\n\tis.EqualValues(output[2], 30)\n\tmu.Unlock()\n\n\td2, _ := NewDebounceBy(10*time.Millisecond, f2)\n\n\t// execute once because it is always invoked and only last invoke is worked after 100ms\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 5; j++ {\n\t\t\tfor k := 0; k < 3; k++ {\n\t\t\t\td2(k)\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(5 * time.Millisecond)\n\t}\n\n\ttime.Sleep(10 * time.Millisecond)\n\n\tmu.Lock()\n\tis.EqualValues(output[0], 45)\n\tis.EqualValues(output[1], 45)\n\tis.EqualValues(output[2], 45)\n\tmu.Unlock()\n\n\t// execute once because it is canceled after 200ms.\n\td3, cancel := NewDebounceBy(10*time.Millisecond, f3)\n\tfor i := 0; i < 3; i++ {\n\t\tfor j := 0; j < 10; j++ {\n\t\t\tfor k := 0; k < 3; k++ {\n\t\t\t\td3(k)\n\t\t\t}\n\t\t}\n\n\t\ttime.Sleep(20 * time.Millisecond)\n\t\tif i == 0 {\n\t\t\tfor k := 0; k < 3; k++ {\n\t\t\t\tcancel(k)\n\t\t\t}\n\t\t}\n\t}\n\n\tmu.Lock()\n\tis.EqualValues(output[0], 75)\n\tis.EqualValues(output[1], 75)\n\tis.EqualValues(output[2], 75)\n\tmu.Unlock()\n}\n\nfunc TestTransaction(t *testing.T) {\n\tis := assert.New(t)\n\n\t// no error\n\t{\n\t\ttransaction := NewTransaction[int]().\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state + 100, nil\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 100\n\t\t\t\t},\n\t\t\t).\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state + 21, nil\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 21\n\t\t\t\t},\n\t\t\t)\n\n\t\tstate, err := transaction.Process(21)\n\t\tis.Equal(142, state)\n\t\tis.Equal(nil, err)\n\t}\n\n\t// with error\n\t{\n\t\ttransaction := NewTransaction[int]().\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state + 100, nil\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 100\n\t\t\t\t},\n\t\t\t).\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state, assert.AnError\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 21\n\t\t\t\t},\n\t\t\t).\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state + 42, nil\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 42\n\t\t\t\t},\n\t\t\t)\n\n\t\tstate, err := transaction.Process(21)\n\t\tis.Equal(21, state)\n\t\tis.Equal(assert.AnError, err)\n\t}\n\n\t// with error + update value\n\t{\n\t\ttransaction := NewTransaction[int]().\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state + 100, nil\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 100\n\t\t\t\t},\n\t\t\t).\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state + 21, assert.AnError\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 21\n\t\t\t\t},\n\t\t\t).\n\t\t\tThen(\n\t\t\t\tfunc(state int) (int, error) {\n\t\t\t\t\treturn state + 42, nil\n\t\t\t\t},\n\t\t\t\tfunc(state int) int {\n\t\t\t\t\treturn state - 42\n\t\t\t\t},\n\t\t\t)\n\n\t\tstate, err := transaction.Process(21)\n\t\tis.Equal(42, state)\n\t\tis.Equal(assert.AnError, err)\n\t}\n}\n"
        },
        {
          "name": "slice.go",
          "type": "blob",
          "size": 19.3994140625,
          "content": "package lo\n\nimport (\n\t\"sort\"\n\n\t\"github.com/samber/lo/internal/constraints\"\n\t\"github.com/samber/lo/internal/rand\"\n)\n\n// Filter iterates over elements of collection, returning an array of all elements predicate returns truthy for.\n// Play: https://go.dev/play/p/Apjg3WeSi7K\nfunc Filter[T any, Slice ~[]T](collection Slice, predicate func(item T, index int) bool) Slice {\n\tresult := make(Slice, 0, len(collection))\n\n\tfor i := range collection {\n\t\tif predicate(collection[i], i) {\n\t\t\tresult = append(result, collection[i])\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Map manipulates a slice and transforms it to a slice of another type.\n// Play: https://go.dev/play/p/OkPcYAhBo0D\nfunc Map[T any, R any](collection []T, iteratee func(item T, index int) R) []R {\n\tresult := make([]R, len(collection))\n\n\tfor i := range collection {\n\t\tresult[i] = iteratee(collection[i], i)\n\t}\n\n\treturn result\n}\n\n// FilterMap returns a slice which obtained after both filtering and mapping using the given callback function.\n// The callback function should return two values:\n//   - the result of the mapping operation and\n//   - whether the result element should be included or not.\n//\n// Play: https://go.dev/play/p/-AuYXfy7opz\nfunc FilterMap[T any, R any](collection []T, callback func(item T, index int) (R, bool)) []R {\n\tresult := []R{}\n\n\tfor i := range collection {\n\t\tif r, ok := callback(collection[i], i); ok {\n\t\t\tresult = append(result, r)\n\t\t}\n\t}\n\n\treturn result\n}\n\n// FlatMap manipulates a slice and transforms and flattens it to a slice of another type.\n// The transform function can either return a slice or a `nil`, and in the `nil` case\n// no value is added to the final slice.\n// Play: https://go.dev/play/p/YSoYmQTA8-U\nfunc FlatMap[T any, R any](collection []T, iteratee func(item T, index int) []R) []R {\n\tresult := make([]R, 0, len(collection))\n\n\tfor i := range collection {\n\t\tresult = append(result, iteratee(collection[i], i)...)\n\t}\n\n\treturn result\n}\n\n// Reduce reduces collection to a value which is the accumulated result of running each element in collection\n// through accumulator, where each successive invocation is supplied the return value of the previous.\n// Play: https://go.dev/play/p/R4UHXZNaaUG\nfunc Reduce[T any, R any](collection []T, accumulator func(agg R, item T, index int) R, initial R) R {\n\tfor i := range collection {\n\t\tinitial = accumulator(initial, collection[i], i)\n\t}\n\n\treturn initial\n}\n\n// ReduceRight helper is like Reduce except that it iterates over elements of collection from right to left.\n// Play: https://go.dev/play/p/Fq3W70l7wXF\nfunc ReduceRight[T any, R any](collection []T, accumulator func(agg R, item T, index int) R, initial R) R {\n\tfor i := len(collection) - 1; i >= 0; i-- {\n\t\tinitial = accumulator(initial, collection[i], i)\n\t}\n\n\treturn initial\n}\n\n// ForEach iterates over elements of collection and invokes iteratee for each element.\n// Play: https://go.dev/play/p/oofyiUPRf8t\nfunc ForEach[T any](collection []T, iteratee func(item T, index int)) {\n\tfor i := range collection {\n\t\titeratee(collection[i], i)\n\t}\n}\n\n// ForEachWhile iterates over elements of collection and invokes iteratee for each element\n// collection return value decide to continue or break, like do while().\n// Play: https://go.dev/play/p/QnLGt35tnow\nfunc ForEachWhile[T any](collection []T, iteratee func(item T, index int) (goon bool)) {\n\tfor i := range collection {\n\t\tif !iteratee(collection[i], i) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Times invokes the iteratee n times, returning an array of the results of each invocation.\n// The iteratee is invoked with index as argument.\n// Play: https://go.dev/play/p/vgQj3Glr6lT\nfunc Times[T any](count int, iteratee func(index int) T) []T {\n\tresult := make([]T, count)\n\n\tfor i := 0; i < count; i++ {\n\t\tresult[i] = iteratee(i)\n\t}\n\n\treturn result\n}\n\n// Uniq returns a duplicate-free version of an array, in which only the first occurrence of each element is kept.\n// The order of result values is determined by the order they occur in the array.\n// Play: https://go.dev/play/p/DTzbeXZ6iEN\nfunc Uniq[T comparable, Slice ~[]T](collection Slice) Slice {\n\tresult := make(Slice, 0, len(collection))\n\tseen := make(map[T]struct{}, len(collection))\n\n\tfor i := range collection {\n\t\tif _, ok := seen[collection[i]]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[collection[i]] = struct{}{}\n\t\tresult = append(result, collection[i])\n\t}\n\n\treturn result\n}\n\n// UniqBy returns a duplicate-free version of an array, in which only the first occurrence of each element is kept.\n// The order of result values is determined by the order they occur in the array. It accepts `iteratee` which is\n// invoked for each element in array to generate the criterion by which uniqueness is computed.\n// Play: https://go.dev/play/p/g42Z3QSb53u\nfunc UniqBy[T any, U comparable, Slice ~[]T](collection Slice, iteratee func(item T) U) Slice {\n\tresult := make(Slice, 0, len(collection))\n\tseen := make(map[U]struct{}, len(collection))\n\n\tfor i := range collection {\n\t\tkey := iteratee(collection[i])\n\n\t\tif _, ok := seen[key]; ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tseen[key] = struct{}{}\n\t\tresult = append(result, collection[i])\n\t}\n\n\treturn result\n}\n\n// GroupBy returns an object composed of keys generated from the results of running each element of collection through iteratee.\n// Play: https://go.dev/play/p/XnQBd_v6brd\nfunc GroupBy[T any, U comparable, Slice ~[]T](collection Slice, iteratee func(item T) U) map[U]Slice {\n\tresult := map[U]Slice{}\n\n\tfor i := range collection {\n\t\tkey := iteratee(collection[i])\n\n\t\tresult[key] = append(result[key], collection[i])\n\t}\n\n\treturn result\n}\n\n// Chunk returns an array of elements split into groups the length of size. If array can't be split evenly,\n// the final chunk will be the remaining elements.\n// Play: https://go.dev/play/p/EeKl0AuTehH\nfunc Chunk[T any, Slice ~[]T](collection Slice, size int) []Slice {\n\tif size <= 0 {\n\t\tpanic(\"Second parameter must be greater than 0\")\n\t}\n\n\tchunksNum := len(collection) / size\n\tif len(collection)%size != 0 {\n\t\tchunksNum += 1\n\t}\n\n\tresult := make([]Slice, 0, chunksNum)\n\n\tfor i := 0; i < chunksNum; i++ {\n\t\tlast := (i + 1) * size\n\t\tif last > len(collection) {\n\t\t\tlast = len(collection)\n\t\t}\n\t\tresult = append(result, collection[i*size:last:last])\n\t}\n\n\treturn result\n}\n\n// PartitionBy returns an array of elements split into groups. The order of grouped values is\n// determined by the order they occur in collection. The grouping is generated from the results\n// of running each element of collection through iteratee.\n// Play: https://go.dev/play/p/NfQ_nGjkgXW\nfunc PartitionBy[T any, K comparable, Slice ~[]T](collection Slice, iteratee func(item T) K) []Slice {\n\tresult := []Slice{}\n\tseen := map[K]int{}\n\n\tfor i := range collection {\n\t\tkey := iteratee(collection[i])\n\n\t\tresultIndex, ok := seen[key]\n\t\tif !ok {\n\t\t\tresultIndex = len(result)\n\t\t\tseen[key] = resultIndex\n\t\t\tresult = append(result, Slice{})\n\t\t}\n\n\t\tresult[resultIndex] = append(result[resultIndex], collection[i])\n\t}\n\n\treturn result\n\n\t// unordered:\n\t// groups := GroupBy[T, K](collection, iteratee)\n\t// return Values[K, []T](groups)\n}\n\n// Flatten returns an array a single level deep.\n// Play: https://go.dev/play/p/rbp9ORaMpjw\nfunc Flatten[T any, Slice ~[]T](collection []Slice) Slice {\n\ttotalLen := 0\n\tfor i := range collection {\n\t\ttotalLen += len(collection[i])\n\t}\n\n\tresult := make(Slice, 0, totalLen)\n\tfor i := range collection {\n\t\tresult = append(result, collection[i]...)\n\t}\n\n\treturn result\n}\n\n// Interleave round-robin alternating input slices and sequentially appending value at index into result\n// Play: https://go.dev/play/p/-RJkTLQEDVt\nfunc Interleave[T any, Slice ~[]T](collections ...Slice) Slice {\n\tif len(collections) == 0 {\n\t\treturn Slice{}\n\t}\n\n\tmaxSize := 0\n\ttotalSize := 0\n\tfor i := range collections {\n\t\tsize := len(collections[i])\n\t\ttotalSize += size\n\t\tif size > maxSize {\n\t\t\tmaxSize = size\n\t\t}\n\t}\n\n\tif maxSize == 0 {\n\t\treturn Slice{}\n\t}\n\n\tresult := make(Slice, totalSize)\n\n\tresultIdx := 0\n\tfor i := 0; i < maxSize; i++ {\n\t\tfor j := range collections {\n\t\t\tif len(collections[j])-1 < i {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tresult[resultIdx] = collections[j][i]\n\t\t\tresultIdx++\n\t\t}\n\t}\n\n\treturn result\n}\n\n// Shuffle returns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.\n// Play: https://go.dev/play/p/Qp73bnTDnc7\nfunc Shuffle[T any, Slice ~[]T](collection Slice) Slice {\n\trand.Shuffle(len(collection), func(i, j int) {\n\t\tcollection[i], collection[j] = collection[j], collection[i]\n\t})\n\n\treturn collection\n}\n\n// Reverse reverses array so that the first element becomes the last, the second element becomes the second to last, and so on.\n// Play: https://go.dev/play/p/fhUMLvZ7vS6\nfunc Reverse[T any, Slice ~[]T](collection Slice) Slice {\n\tlength := len(collection)\n\thalf := length / 2\n\n\tfor i := 0; i < half; i = i + 1 {\n\t\tj := length - 1 - i\n\t\tcollection[i], collection[j] = collection[j], collection[i]\n\t}\n\n\treturn collection\n}\n\n// Fill fills elements of array with `initial` value.\n// Play: https://go.dev/play/p/VwR34GzqEub\nfunc Fill[T Clonable[T]](collection []T, initial T) []T {\n\tresult := make([]T, 0, len(collection))\n\n\tfor range collection {\n\t\tresult = append(result, initial.Clone())\n\t}\n\n\treturn result\n}\n\n// Repeat builds a slice with N copies of initial value.\n// Play: https://go.dev/play/p/g3uHXbmc3b6\nfunc Repeat[T Clonable[T]](count int, initial T) []T {\n\tresult := make([]T, 0, count)\n\n\tfor i := 0; i < count; i++ {\n\t\tresult = append(result, initial.Clone())\n\t}\n\n\treturn result\n}\n\n// RepeatBy builds a slice with values returned by N calls of callback.\n// Play: https://go.dev/play/p/ozZLCtX_hNU\nfunc RepeatBy[T any](count int, predicate func(index int) T) []T {\n\tresult := make([]T, 0, count)\n\n\tfor i := 0; i < count; i++ {\n\t\tresult = append(result, predicate(i))\n\t}\n\n\treturn result\n}\n\n// KeyBy transforms a slice or an array of structs to a map based on a pivot callback.\n// Play: https://go.dev/play/p/mdaClUAT-zZ\nfunc KeyBy[K comparable, V any](collection []V, iteratee func(item V) K) map[K]V {\n\tresult := make(map[K]V, len(collection))\n\n\tfor i := range collection {\n\t\tk := iteratee(collection[i])\n\t\tresult[k] = collection[i]\n\t}\n\n\treturn result\n}\n\n// Associate returns a map containing key-value pairs provided by transform function applied to elements of the given slice.\n// If any of two pairs would have the same key the last one gets added to the map.\n// The order of keys in returned map is not specified and is not guaranteed to be the same from the original array.\n// Play: https://go.dev/play/p/WHa2CfMO3Lr\nfunc Associate[T any, K comparable, V any](collection []T, transform func(item T) (K, V)) map[K]V {\n\tresult := make(map[K]V, len(collection))\n\n\tfor i := range collection {\n\t\tk, v := transform(collection[i])\n\t\tresult[k] = v\n\t}\n\n\treturn result\n}\n\n// SliceToMap returns a map containing key-value pairs provided by transform function applied to elements of the given slice.\n// If any of two pairs would have the same key the last one gets added to the map.\n// The order of keys in returned map is not specified and is not guaranteed to be the same from the original array.\n// Alias of Associate().\n// Play: https://go.dev/play/p/WHa2CfMO3Lr\nfunc SliceToMap[T any, K comparable, V any](collection []T, transform func(item T) (K, V)) map[K]V {\n\treturn Associate(collection, transform)\n}\n\n// Drop drops n elements from the beginning of a slice or array.\n// Play: https://go.dev/play/p/JswS7vXRJP2\nfunc Drop[T any, Slice ~[]T](collection Slice, n int) Slice {\n\tif len(collection) <= n {\n\t\treturn make(Slice, 0)\n\t}\n\n\tresult := make(Slice, 0, len(collection)-n)\n\n\treturn append(result, collection[n:]...)\n}\n\n// DropRight drops n elements from the end of a slice or array.\n// Play: https://go.dev/play/p/GG0nXkSJJa3\nfunc DropRight[T any, Slice ~[]T](collection Slice, n int) Slice {\n\tif len(collection) <= n {\n\t\treturn Slice{}\n\t}\n\n\tresult := make(Slice, 0, len(collection)-n)\n\treturn append(result, collection[:len(collection)-n]...)\n}\n\n// DropWhile drops elements from the beginning of a slice or array while the predicate returns true.\n// Play: https://go.dev/play/p/7gBPYw2IK16\nfunc DropWhile[T any, Slice ~[]T](collection Slice, predicate func(item T) bool) Slice {\n\ti := 0\n\tfor ; i < len(collection); i++ {\n\t\tif !predicate(collection[i]) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tresult := make(Slice, 0, len(collection)-i)\n\treturn append(result, collection[i:]...)\n}\n\n// DropRightWhile drops elements from the end of a slice or array while the predicate returns true.\n// Play: https://go.dev/play/p/3-n71oEC0Hz\nfunc DropRightWhile[T any, Slice ~[]T](collection Slice, predicate func(item T) bool) Slice {\n\ti := len(collection) - 1\n\tfor ; i >= 0; i-- {\n\t\tif !predicate(collection[i]) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tresult := make(Slice, 0, i+1)\n\treturn append(result, collection[:i+1]...)\n}\n\n// DropByIndex drops elements from a slice or array by the index.\n// A negative index will drop elements from the end of the slice.\n// Play: https://go.dev/play/p/bPIH4npZRxS\nfunc DropByIndex[T any](collection []T, indexes ...int) []T {\n\tinitialSize := len(collection)\n\tif initialSize == 0 {\n\t\treturn make([]T, 0)\n\t}\n\n\tfor i := range indexes {\n\t\tif indexes[i] < 0 {\n\t\t\tindexes[i] = initialSize + indexes[i]\n\t\t}\n\t}\n\n\tindexes = Uniq(indexes)\n\tsort.Ints(indexes)\n\n\tresult := make([]T, 0, initialSize)\n\tresult = append(result, collection...)\n\n\tfor i := range indexes {\n\t\tif indexes[i]-i < 0 || indexes[i]-i >= initialSize-i {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result[:indexes[i]-i], result[indexes[i]-i+1:]...)\n\t}\n\n\treturn result\n}\n\n// Reject is the opposite of Filter, this method returns the elements of collection that predicate does not return truthy for.\n// Play: https://go.dev/play/p/YkLMODy1WEL\nfunc Reject[T any, Slice ~[]T](collection Slice, predicate func(item T, index int) bool) Slice {\n\tresult := Slice{}\n\n\tfor i := range collection {\n\t\tif !predicate(collection[i], i) {\n\t\t\tresult = append(result, collection[i])\n\t\t}\n\t}\n\n\treturn result\n}\n\n// RejectMap is the opposite of FilterMap, this method returns a slice which obtained after both filtering and mapping using the given callback function.\n// The callback function should return two values:\n//   - the result of the mapping operation and\n//   - whether the result element should be included or not.\nfunc RejectMap[T any, R any](collection []T, callback func(item T, index int) (R, bool)) []R {\n\tresult := []R{}\n\n\tfor i := range collection {\n\t\tif r, ok := callback(collection[i], i); !ok {\n\t\t\tresult = append(result, r)\n\t\t}\n\t}\n\n\treturn result\n}\n\n// FilterReject mixes Filter and Reject, this method returns two slices, one for the elements of collection that\n// predicate returns truthy for and one for the elements that predicate does not return truthy for.\nfunc FilterReject[T any, Slice ~[]T](collection Slice, predicate func(T, int) bool) (kept Slice, rejected Slice) {\n\tkept = make(Slice, 0, len(collection))\n\trejected = make(Slice, 0, len(collection))\n\n\tfor i := range collection {\n\t\tif predicate(collection[i], i) {\n\t\t\tkept = append(kept, collection[i])\n\t\t} else {\n\t\t\trejected = append(rejected, collection[i])\n\t\t}\n\t}\n\n\treturn kept, rejected\n}\n\n// Count counts the number of elements in the collection that compare equal to value.\n// Play: https://go.dev/play/p/Y3FlK54yveC\nfunc Count[T comparable](collection []T, value T) (count int) {\n\tfor i := range collection {\n\t\tif collection[i] == value {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// CountBy counts the number of elements in the collection for which predicate is true.\n// Play: https://go.dev/play/p/ByQbNYQQi4X\nfunc CountBy[T any](collection []T, predicate func(item T) bool) (count int) {\n\tfor i := range collection {\n\t\tif predicate(collection[i]) {\n\t\t\tcount++\n\t\t}\n\t}\n\n\treturn count\n}\n\n// CountValues counts the number of each element in the collection.\n// Play: https://go.dev/play/p/-p-PyLT4dfy\nfunc CountValues[T comparable](collection []T) map[T]int {\n\tresult := make(map[T]int)\n\n\tfor i := range collection {\n\t\tresult[collection[i]]++\n\t}\n\n\treturn result\n}\n\n// CountValuesBy counts the number of each element return from mapper function.\n// Is equivalent to chaining lo.Map and lo.CountValues.\n// Play: https://go.dev/play/p/2U0dG1SnOmS\nfunc CountValuesBy[T any, U comparable](collection []T, mapper func(item T) U) map[U]int {\n\tresult := make(map[U]int)\n\n\tfor i := range collection {\n\t\tresult[mapper(collection[i])]++\n\t}\n\n\treturn result\n}\n\n// Subset returns a copy of a slice from `offset` up to `length` elements. Like `slice[start:start+length]`, but does not panic on overflow.\n// Play: https://go.dev/play/p/tOQu1GhFcog\nfunc Subset[T any, Slice ~[]T](collection Slice, offset int, length uint) Slice {\n\tsize := len(collection)\n\n\tif offset < 0 {\n\t\toffset = size + offset\n\t\tif offset < 0 {\n\t\t\toffset = 0\n\t\t}\n\t}\n\n\tif offset > size {\n\t\treturn Slice{}\n\t}\n\n\tif length > uint(size)-uint(offset) {\n\t\tlength = uint(size - offset)\n\t}\n\n\treturn collection[offset : offset+int(length)]\n}\n\n// Slice returns a copy of a slice from `start` up to, but not including `end`. Like `slice[start:end]`, but does not panic on overflow.\n// Play: https://go.dev/play/p/8XWYhfMMA1h\nfunc Slice[T any, Slice ~[]T](collection Slice, start int, end int) Slice {\n\tsize := len(collection)\n\n\tif start >= end {\n\t\treturn Slice{}\n\t}\n\n\tif start > size {\n\t\tstart = size\n\t}\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\n\tif end > size {\n\t\tend = size\n\t}\n\tif end < 0 {\n\t\tend = 0\n\t}\n\n\treturn collection[start:end]\n}\n\n// Replace returns a copy of the slice with the first n non-overlapping instances of old replaced by new.\n// Play: https://go.dev/play/p/XfPzmf9gql6\nfunc Replace[T comparable, Slice ~[]T](collection Slice, old T, new T, n int) Slice {\n\tresult := make(Slice, len(collection))\n\tcopy(result, collection)\n\n\tfor i := range result {\n\t\tif result[i] == old && n != 0 {\n\t\t\tresult[i] = new\n\t\t\tn--\n\t\t}\n\t}\n\n\treturn result\n}\n\n// ReplaceAll returns a copy of the slice with all non-overlapping instances of old replaced by new.\n// Play: https://go.dev/play/p/a9xZFUHfYcV\nfunc ReplaceAll[T comparable, Slice ~[]T](collection Slice, old T, new T) Slice {\n\treturn Replace(collection, old, new, -1)\n}\n\n// Compact returns a slice of all non-zero elements.\n// Play: https://go.dev/play/p/tXiy-iK6PAc\nfunc Compact[T comparable, Slice ~[]T](collection Slice) Slice {\n\tvar zero T\n\n\tresult := make(Slice, 0, len(collection))\n\n\tfor i := range collection {\n\t\tif collection[i] != zero {\n\t\t\tresult = append(result, collection[i])\n\t\t}\n\t}\n\n\treturn result\n}\n\n// IsSorted checks if a slice is sorted.\n// Play: https://go.dev/play/p/mc3qR-t4mcx\nfunc IsSorted[T constraints.Ordered](collection []T) bool {\n\tfor i := 1; i < len(collection); i++ {\n\t\tif collection[i-1] > collection[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// IsSortedByKey checks if a slice is sorted by iteratee.\n// Play: https://go.dev/play/p/wiG6XyBBu49\nfunc IsSortedByKey[T any, K constraints.Ordered](collection []T, iteratee func(item T) K) bool {\n\tsize := len(collection)\n\n\tfor i := 0; i < size-1; i++ {\n\t\tif iteratee(collection[i]) > iteratee(collection[i+1]) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// Splice inserts multiple elements at index i. A negative index counts back\n// from the end of the slice. The helper is protected against overflow errors.\n// Play: https://go.dev/play/p/G5_GhkeSUBA\nfunc Splice[T any, Slice ~[]T](collection Slice, i int, elements ...T) Slice {\n\tsizeCollection := len(collection)\n\tsizeElements := len(elements)\n\toutput := make(Slice, 0, sizeCollection+sizeElements) // preallocate memory for the output slice\n\n\tif sizeElements == 0 {\n\t\treturn append(output, collection...) // simple copy\n\t} else if i > sizeCollection {\n\t\t// positive overflow\n\t\treturn append(append(output, collection...), elements...)\n\t} else if i < -sizeCollection {\n\t\t// negative overflow\n\t\treturn append(append(output, elements...), collection...)\n\t} else if i < 0 {\n\t\t// backward\n\t\ti = sizeCollection + i\n\t}\n\n\treturn append(append(append(output, collection[:i]...), elements...), collection[i:]...)\n}\n"
        },
        {
          "name": "slice_benchmark_test.go",
          "type": "blob",
          "size": 4.1044921875,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nvar lengths = []int{10, 100, 1000}\n\nfunc BenchmarkChunk(b *testing.B) {\n\tfor _, n := range lengths {\n\t\tstrs := genSliceString(n)\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Chunk(strs, 5)\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tints := genSliceInt(n)\n\t\tb.Run(fmt.Sprintf(\"ints%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Chunk(ints, 5)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc genSliceString(n int) []string {\n\tres := make([]string, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tres = append(res, strconv.Itoa(rand.Intn(100_000)))\n\t}\n\treturn res\n}\n\nfunc genSliceInt(n int) []int {\n\tres := make([]int, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tres = append(res, rand.Intn(100_000))\n\t}\n\treturn res\n}\n\nfunc BenchmarkFlatten(b *testing.B) {\n\tfor _, n := range lengths {\n\t\tints := make([][]int, 0, n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tints = append(ints, genSliceInt(n))\n\t\t}\n\t\tb.Run(fmt.Sprintf(\"ints_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Flatten(ints)\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tstrs := make([][]string, 0, n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tstrs = append(strs, genSliceString(n))\n\t\t}\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Flatten(strs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkDrop(b *testing.B) {\n\tfor _, n := range lengths {\n\t\tstrs := genSliceString(n)\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Drop(strs, n/4)\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tints := genSliceInt(n)\n\t\tb.Run(fmt.Sprintf(\"ints%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Drop(ints, n/4)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkDropRight(b *testing.B) {\n\tfor _, n := range lengths {\n\t\tstrs := genSliceString(n)\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropRight(strs, n/4)\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tints := genSliceInt(n)\n\t\tb.Run(fmt.Sprintf(\"ints%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropRight(ints, n/4)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkDropWhile(b *testing.B) {\n\tfor _, n := range lengths {\n\t\tstrs := genSliceString(n)\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropWhile(strs, func(v string) bool { return len(v) < 4 })\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tints := genSliceInt(n)\n\t\tb.Run(fmt.Sprintf(\"ints%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropWhile(ints, func(v int) bool { return i < 10_000 })\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkDropRightWhile(b *testing.B) {\n\tfor _, n := range lengths {\n\t\tstrs := genSliceString(n)\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropRightWhile(strs, func(v string) bool { return len(v) < 4 })\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tints := genSliceInt(n)\n\t\tb.Run(fmt.Sprintf(\"ints%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropRightWhile(ints, func(v int) bool { return i < 10_000 })\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkDropByIndex(b *testing.B) {\n\tfor _, n := range lengths {\n\t\tstrs := genSliceString(n)\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropByIndex(strs, n/4)\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tints := genSliceInt(n)\n\t\tb.Run(fmt.Sprintf(\"ints%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = DropByIndex(ints, n/4)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkReplace(b *testing.B) {\n\tlengths := []int{1_000, 10_000, 100_000}\n\tfor _, n := range lengths {\n\t\tstrs := genSliceString(n)\n\t\tb.Run(fmt.Sprintf(\"strings_%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Replace(strs, strs[n/4], \"123123\", 10)\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, n := range lengths {\n\t\tints := genSliceInt(n)\n\t\tb.Run(fmt.Sprintf(\"ints%d\", n), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\t_ = Replace(ints, ints[n/4], 123123, 10)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkToSlicePtr(b *testing.B) {\n\tpreallocated := make([]int, 100000)\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = ToSlicePtr(preallocated)\n\t}\n}\n"
        },
        {
          "name": "slice_example_test.go",
          "type": "blob",
          "size": 8.0751953125,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc ExampleFilter() {\n\tlist := []int64{1, 2, 3, 4}\n\n\tresult := Filter(list, func(nbr int64, index int) bool {\n\t\treturn nbr%2 == 0\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [2 4]\n}\n\nfunc ExampleMap() {\n\tlist := []int64{1, 2, 3, 4}\n\n\tresult := Map(list, func(nbr int64, index int) string {\n\t\treturn strconv.FormatInt(nbr*2, 10)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [2 4 6 8]\n}\n\nfunc ExampleFilterMap() {\n\tlist := []int64{1, 2, 3, 4}\n\n\tresult := FilterMap(list, func(nbr int64, index int) (string, bool) {\n\t\treturn strconv.FormatInt(nbr*2, 10), nbr%2 == 0\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [4 8]\n}\n\nfunc ExampleFlatMap() {\n\tlist := []int64{1, 2, 3, 4}\n\n\tresult := FlatMap(list, func(nbr int64, index int) []string {\n\t\treturn []string{\n\t\t\tstrconv.FormatInt(nbr, 10), // base 10\n\t\t\tstrconv.FormatInt(nbr, 2),  // base 2\n\t\t}\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [1 1 2 10 3 11 4 100]\n}\n\nfunc ExampleReduce() {\n\tlist := []int64{1, 2, 3, 4}\n\n\tresult := Reduce(list, func(agg int64, item int64, index int) int64 {\n\t\treturn agg + item\n\t}, 0)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: 10\n}\n\nfunc ExampleReduceRight() {\n\tlist := [][]int{{0, 1}, {2, 3}, {4, 5}}\n\n\tresult := ReduceRight(list, func(agg []int, item []int, index int) []int {\n\t\treturn append(agg, item...)\n\t}, []int{})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [4 5 2 3 0 1]\n}\n\nfunc ExampleForEach() {\n\tlist := []int64{1, 2, 3, 4}\n\n\tForEach(list, func(x int64, _ int) {\n\t\tfmt.Println(x)\n\t})\n\n\t// Output:\n\t// 1\n\t// 2\n\t// 3\n\t// 4\n}\n\nfunc ExampleForEachWhile() {\n\tlist := []int64{1, 2, -math.MaxInt, 4}\n\n\tForEachWhile(list, func(x int64, _ int) bool {\n\t\tif x < 0 {\n\t\t\treturn false\n\t\t}\n\t\tfmt.Println(x)\n\t\treturn true\n\t})\n\n\t// Output:\n\t// 1\n\t// 2\n}\n\nfunc ExampleTimes() {\n\tresult := Times(3, func(i int) string {\n\t\treturn strconv.FormatInt(int64(i), 10)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [0 1 2]\n}\n\nfunc ExampleUniq() {\n\tlist := []int{1, 2, 2, 1}\n\n\tresult := Uniq(list)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [1 2]\n}\n\nfunc ExampleUniqBy() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := UniqBy(list, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [0 1 2]\n}\n\nfunc ExampleGroupBy() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := GroupBy(list, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tfmt.Printf(\"%v\\n\", result[0])\n\tfmt.Printf(\"%v\\n\", result[1])\n\tfmt.Printf(\"%v\\n\", result[2])\n\t// Output:\n\t// [0 3]\n\t// [1 4]\n\t// [2 5]\n}\n\nfunc ExampleChunk() {\n\tlist := []int{0, 1, 2, 3, 4}\n\n\tresult := Chunk(list, 2)\n\n\tfor _, item := range result {\n\t\tfmt.Printf(\"%v\\n\", item)\n\t}\n\t// Output:\n\t// [0 1]\n\t// [2 3]\n\t// [4]\n}\n\nfunc ExamplePartitionBy() {\n\tlist := []int{-2, -1, 0, 1, 2, 3, 4}\n\n\tresult := PartitionBy(list, func(x int) string {\n\t\tif x < 0 {\n\t\t\treturn \"negative\"\n\t\t} else if x%2 == 0 {\n\t\t\treturn \"even\"\n\t\t}\n\t\treturn \"odd\"\n\t})\n\n\tfor _, item := range result {\n\t\tfmt.Printf(\"%v\\n\", item)\n\t}\n\t// Output:\n\t// [-2 -1]\n\t// [0 2 4]\n\t// [1 3]\n}\n\nfunc ExampleFlatten() {\n\tlist := [][]int{{0, 1, 2}, {3, 4, 5}}\n\n\tresult := Flatten(list)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [0 1 2 3 4 5]\n}\n\nfunc ExampleInterleave() {\n\tlist1 := [][]int{{1, 4, 7}, {2, 5, 8}, {3, 6, 9}}\n\tlist2 := [][]int{{1}, {2, 5, 8}, {3, 6}, {4, 7, 9, 10}}\n\n\tresult1 := Interleave(list1...)\n\tresult2 := Interleave(list2...)\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\t// Output:\n\t// [1 2 3 4 5 6 7 8 9]\n\t// [1 2 3 4 5 6 7 8 9 10]\n}\n\nfunc ExampleShuffle() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := Shuffle(list)\n\n\tfmt.Printf(\"%v\", result)\n}\n\nfunc ExampleReverse() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := Reverse(list)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [5 4 3 2 1 0]\n}\n\nfunc ExampleFill() {\n\tlist := []foo{{\"a\"}, {\"a\"}}\n\n\tresult := Fill(list, foo{\"b\"})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{b} {b}]\n}\n\nfunc ExampleRepeat() {\n\tresult := Repeat(2, foo{\"a\"})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{a} {a}]\n}\n\nfunc ExampleRepeatBy() {\n\tresult := RepeatBy(5, func(i int) string {\n\t\treturn strconv.FormatInt(int64(math.Pow(float64(i), 2)), 10)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [0 1 4 9 16]\n}\n\nfunc ExampleKeyBy() {\n\tlist := []string{\"a\", \"aa\", \"aaa\"}\n\n\tresult := KeyBy(list, func(str string) int {\n\t\treturn len(str)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: map[1:a 2:aa 3:aaa]\n}\n\nfunc ExampleAssociate() {\n\tlist := []string{\"a\", \"aa\", \"aaa\"}\n\n\tresult := Associate(list, func(str string) (string, int) {\n\t\treturn str, len(str)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: map[a:1 aa:2 aaa:3]\n}\n\nfunc ExampleDrop() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := Drop(list, 2)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [2 3 4 5]\n}\n\nfunc ExampleDropRight() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := DropRight(list, 2)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [0 1 2 3]\n}\n\nfunc ExampleDropWhile() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := DropWhile(list, func(val int) bool {\n\t\treturn val < 2\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [2 3 4 5]\n}\n\nfunc ExampleDropRightWhile() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := DropRightWhile(list, func(val int) bool {\n\t\treturn val > 2\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [0 1 2]\n}\n\nfunc ExampleDropByIndex() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := DropByIndex(list, 2)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [0 1 3 4 5]\n}\n\nfunc ExampleReject() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := Reject(list, func(x int, _ int) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [1 3 5]\n}\n\nfunc ExampleCount() {\n\tlist := []int{0, 1, 2, 3, 4, 5, 0, 1, 2, 3}\n\n\tresult := Count(list, 2)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: 2\n}\n\nfunc ExampleCountBy() {\n\tlist := []int{0, 1, 2, 3, 4, 5, 0, 1, 2, 3}\n\n\tresult := CountBy(list, func(i int) bool {\n\t\treturn i < 4\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: 8\n}\n\nfunc ExampleCountValues() {\n\tresult1 := CountValues([]int{})\n\tresult2 := CountValues([]int{1, 2})\n\tresult3 := CountValues([]int{1, 2, 2})\n\tresult4 := CountValues([]string{\"foo\", \"bar\", \"\"})\n\tresult5 := CountValues([]string{\"foo\", \"bar\", \"bar\"})\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\t// Output:\n\t// map[]\n\t// map[1:1 2:1]\n\t// map[1:1 2:2]\n\t// map[:1 bar:1 foo:1]\n\t// map[bar:2 foo:1]\n}\n\nfunc ExampleCountValuesBy() {\n\tisEven := func(v int) bool {\n\t\treturn v%2 == 0\n\t}\n\n\tresult1 := CountValuesBy([]int{}, isEven)\n\tresult2 := CountValuesBy([]int{1, 2}, isEven)\n\tresult3 := CountValuesBy([]int{1, 2, 2}, isEven)\n\n\tlength := func(v string) int {\n\t\treturn len(v)\n\t}\n\n\tresult4 := CountValuesBy([]string{\"foo\", \"bar\", \"\"}, length)\n\tresult5 := CountValuesBy([]string{\"foo\", \"bar\", \"bar\"}, length)\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\t// Output:\n\t// map[]\n\t// map[false:1 true:1]\n\t// map[false:1 true:2]\n\t// map[0:1 3:2]\n\t// map[3:3]\n}\n\nfunc ExampleSubset() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := Subset(list, 2, 3)\n\n\tfmt.Printf(\"%v\", result)\n\t// Output: [2 3 4]\n}\n\nfunc ExampleSlice() {\n\tlist := []int{0, 1, 2, 3, 4, 5}\n\n\tresult := Slice(list, 1, 4)\n\tfmt.Printf(\"%v\\n\", result)\n\n\tresult = Slice(list, 4, 1)\n\tfmt.Printf(\"%v\\n\", result)\n\n\tresult = Slice(list, 4, 5)\n\tfmt.Printf(\"%v\\n\", result)\n\n\t// Output:\n\t// [1 2 3]\n\t// []\n\t// [4]\n}\n\nfunc ExampleReplace() {\n\tlist := []int{0, 1, 0, 1, 2, 3, 0}\n\n\tresult := Replace(list, 0, 42, 1)\n\tfmt.Printf(\"%v\\n\", result)\n\n\tresult = Replace(list, -1, 42, 1)\n\tfmt.Printf(\"%v\\n\", result)\n\n\tresult = Replace(list, 0, 42, 2)\n\tfmt.Printf(\"%v\\n\", result)\n\n\tresult = Replace(list, 0, 42, -1)\n\tfmt.Printf(\"%v\\n\", result)\n\n\t// Output:\n\t// [42 1 0 1 2 3 0]\n\t// [0 1 0 1 2 3 0]\n\t// [42 1 42 1 2 3 0]\n\t// [42 1 42 1 2 3 42]\n}\n\nfunc ExampleReplaceAll() {\n\tlist := []string{\"\", \"foo\", \"\", \"bar\", \"\"}\n\n\tresult := Compact(list)\n\n\tfmt.Printf(\"%v\", result)\n\n\t// Output: [foo bar]\n}\n\nfunc ExampleIsSorted() {\n\tlist := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n\tresult := IsSorted(list)\n\n\tfmt.Printf(\"%v\", result)\n\n\t// Output: true\n}\n\nfunc ExampleIsSortedByKey() {\n\tlist := []string{\"a\", \"bb\", \"ccc\"}\n\n\tresult := IsSortedByKey(list, func(s string) int {\n\t\treturn len(s)\n\t})\n\n\tfmt.Printf(\"%v\", result)\n\n\t// Output: true\n}\n"
        },
        {
          "name": "slice_test.go",
          "type": "blob",
          "size": 25.291015625,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestFilter(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Filter([]int{1, 2, 3, 4}, func(x int, _ int) bool {\n\t\treturn x%2 == 0\n\t})\n\tis.Equal(r1, []int{2, 4})\n\n\tr2 := Filter([]string{\"\", \"foo\", \"\", \"bar\", \"\"}, func(x string, _ int) bool {\n\t\treturn len(x) > 0\n\t})\n\tis.Equal(r2, []string{\"foo\", \"bar\"})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Filter(allStrings, func(x string, _ int) bool {\n\t\treturn len(x) > 0\n\t})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestMap(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Map([]int{1, 2, 3, 4}, func(x int, _ int) string {\n\t\treturn \"Hello\"\n\t})\n\tresult2 := Map([]int64{1, 2, 3, 4}, func(x int64, _ int) string {\n\t\treturn strconv.FormatInt(x, 10)\n\t})\n\n\tis.Equal(len(result1), 4)\n\tis.Equal(len(result2), 4)\n\tis.Equal(result1, []string{\"Hello\", \"Hello\", \"Hello\", \"Hello\"})\n\tis.Equal(result2, []string{\"1\", \"2\", \"3\", \"4\"})\n}\n\nfunc TestFilterMap(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := FilterMap([]int64{1, 2, 3, 4}, func(x int64, _ int) (string, bool) {\n\t\tif x%2 == 0 {\n\t\t\treturn strconv.FormatInt(x, 10), true\n\t\t}\n\t\treturn \"\", false\n\t})\n\tr2 := FilterMap([]string{\"cpu\", \"gpu\", \"mouse\", \"keyboard\"}, func(x string, _ int) (string, bool) {\n\t\tif strings.HasSuffix(x, \"pu\") {\n\t\t\treturn \"xpu\", true\n\t\t}\n\t\treturn \"\", false\n\t})\n\n\tis.Equal(len(r1), 2)\n\tis.Equal(len(r2), 2)\n\tis.Equal(r1, []string{\"2\", \"4\"})\n\tis.Equal(r2, []string{\"xpu\", \"xpu\"})\n}\n\nfunc TestFlatMap(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := FlatMap([]int{0, 1, 2, 3, 4}, func(x int, _ int) []string {\n\t\treturn []string{\"Hello\"}\n\t})\n\tresult2 := FlatMap([]int64{0, 1, 2, 3, 4}, func(x int64, _ int) []string {\n\t\tresult := make([]string, 0, x)\n\t\tfor i := int64(0); i < x; i++ {\n\t\t\tresult = append(result, strconv.FormatInt(x, 10))\n\t\t}\n\t\treturn result\n\t})\n\n\tis.Equal(len(result1), 5)\n\tis.Equal(len(result2), 10)\n\tis.Equal(result1, []string{\"Hello\", \"Hello\", \"Hello\", \"Hello\", \"Hello\"})\n\tis.Equal(result2, []string{\"1\", \"2\", \"2\", \"3\", \"3\", \"3\", \"4\", \"4\", \"4\", \"4\"})\n}\n\nfunc TestTimes(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Times(3, func(i int) string {\n\t\treturn strconv.FormatInt(int64(i), 10)\n\t})\n\n\tis.Equal(len(result1), 3)\n\tis.Equal(result1, []string{\"0\", \"1\", \"2\"})\n}\n\nfunc TestReduce(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Reduce([]int{1, 2, 3, 4}, func(agg int, item int, _ int) int {\n\t\treturn agg + item\n\t}, 0)\n\tresult2 := Reduce([]int{1, 2, 3, 4}, func(agg int, item int, _ int) int {\n\t\treturn agg + item\n\t}, 10)\n\n\tis.Equal(result1, 10)\n\tis.Equal(result2, 20)\n}\n\nfunc TestReduceRight(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := ReduceRight([][]int{{0, 1}, {2, 3}, {4, 5}}, func(agg []int, item []int, _ int) []int {\n\t\treturn append(agg, item...)\n\t}, []int{})\n\n\tis.Equal(result1, []int{4, 5, 2, 3, 0, 1})\n\n\ttype collection []int\n\tresult3 := ReduceRight(collection{1, 2, 3, 4}, func(agg int, item int, _ int) int {\n\t\treturn agg + item\n\t}, 10)\n\tis.Equal(result3, 20)\n}\n\nfunc TestForEach(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t// check of callback is called for every element and in proper order\n\n\tcallParams1 := []string{}\n\tcallParams2 := []int{}\n\n\tForEach([]string{\"a\", \"b\", \"c\"}, func(item string, i int) {\n\t\tcallParams1 = append(callParams1, item)\n\t\tcallParams2 = append(callParams2, i)\n\t})\n\n\tis.ElementsMatch([]string{\"a\", \"b\", \"c\"}, callParams1)\n\tis.ElementsMatch([]int{0, 1, 2}, callParams2)\n\tis.IsIncreasing(callParams2)\n}\n\nfunc TestForEachWhile(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t// check of callback is called for every element and in proper order\n\n\tvar callParams1 []string\n\tvar callParams2 []int\n\n\tForEachWhile([]string{\"a\", \"b\", \"c\"}, func(item string, i int) bool {\n\t\tif item == \"c\" {\n\t\t\treturn false\n\t\t}\n\t\tcallParams1 = append(callParams1, item)\n\t\tcallParams2 = append(callParams2, i)\n\t\treturn true\n\t})\n\n\tis.ElementsMatch([]string{\"a\", \"b\"}, callParams1)\n\tis.ElementsMatch([]int{0, 1}, callParams2)\n\tis.IsIncreasing(callParams2)\n}\n\nfunc TestUniq(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Uniq([]int{1, 2, 2, 1})\n\n\tis.Equal(len(result1), 2)\n\tis.Equal(result1, []int{1, 2})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Uniq(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestUniqBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := UniqBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(len(result1), 3)\n\tis.Equal(result1, []int{0, 1, 2})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := UniqBy(allStrings, func(i string) string {\n\t\treturn i\n\t})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestGroupBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := GroupBy([]int{0, 1, 2, 3, 4, 5}, func(i int) int {\n\t\treturn i % 3\n\t})\n\n\tis.Equal(len(result1), 3)\n\tis.Equal(result1, map[int][]int{\n\t\t0: {0, 3},\n\t\t1: {1, 4},\n\t\t2: {2, 5},\n\t})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := GroupBy(allStrings, func(i string) int {\n\t\treturn 42\n\t})\n\tis.IsType(nonempty[42], allStrings, \"type preserved\")\n}\n\nfunc TestChunk(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Chunk([]int{0, 1, 2, 3, 4, 5}, 2)\n\tresult2 := Chunk([]int{0, 1, 2, 3, 4, 5, 6}, 2)\n\tresult3 := Chunk([]int{}, 2)\n\tresult4 := Chunk([]int{0}, 2)\n\n\tis.Equal(result1, [][]int{{0, 1}, {2, 3}, {4, 5}})\n\tis.Equal(result2, [][]int{{0, 1}, {2, 3}, {4, 5}, {6}})\n\tis.Equal(result3, [][]int{})\n\tis.Equal(result4, [][]int{{0}})\n\tis.PanicsWithValue(\"Second parameter must be greater than 0\", func() {\n\t\tChunk([]int{0}, 0)\n\t})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Chunk(allStrings, 2)\n\tis.IsType(nonempty[0], allStrings, \"type preserved\")\n\n\t// appending to a chunk should not affect original array\n\toriginalArray := []int{0, 1, 2, 3, 4, 5}\n\tresult5 := Chunk(originalArray, 2)\n\tresult5[0] = append(result5[0], 6)\n\tis.Equal(originalArray, []int{0, 1, 2, 3, 4, 5})\n}\n\nfunc TestPartitionBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\toddEven := func(x int) string {\n\t\tif x < 0 {\n\t\t\treturn \"negative\"\n\t\t} else if x%2 == 0 {\n\t\t\treturn \"even\"\n\t\t}\n\t\treturn \"odd\"\n\t}\n\n\tresult1 := PartitionBy([]int{-2, -1, 0, 1, 2, 3, 4, 5}, oddEven)\n\tresult2 := PartitionBy([]int{}, oddEven)\n\n\tis.Equal(result1, [][]int{{-2, -1}, {0, 2, 4}, {1, 3, 5}})\n\tis.Equal(result2, [][]int{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := PartitionBy(allStrings, func(item string) int {\n\t\treturn len(item)\n\t})\n\tis.IsType(nonempty[0], allStrings, \"type preserved\")\n}\n\nfunc TestFlatten(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Flatten([][]int{{0, 1}, {2, 3, 4, 5}})\n\n\tis.Equal(result1, []int{0, 1, 2, 3, 4, 5})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Flatten([]myStrings{allStrings})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestInterleave(t *testing.T) {\n\tis := assert.New(t)\n\n\ttests := []struct {\n\t\tname        string\n\t\tcollections [][]int\n\t\twant        []int\n\t}{\n\t\t{\n\t\t\t\"nil\",\n\t\t\t[][]int{nil},\n\t\t\t[]int{},\n\t\t},\n\t\t{\n\t\t\t\"empty\",\n\t\t\t[][]int{},\n\t\t\t[]int{},\n\t\t},\n\t\t{\n\t\t\t\"empties\",\n\t\t\t[][]int{{}, {}},\n\t\t\t[]int{},\n\t\t},\n\t\t{\n\t\t\t\"same length\",\n\t\t\t[][]int{{1, 3, 5}, {2, 4, 6}},\n\t\t\t[]int{1, 2, 3, 4, 5, 6},\n\t\t},\n\t\t{\n\t\t\t\"different length\",\n\t\t\t[][]int{{1, 3, 5, 6}, {2, 4}},\n\t\t\t[]int{1, 2, 3, 4, 5, 6},\n\t\t},\n\t\t{\n\t\t\t\"many slices\",\n\t\t\t[][]int{{1}, {2, 5, 8}, {3, 6}, {4, 7, 9, 10}},\n\t\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := Interleave(tt.collections...); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Interleave() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Interleave(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestShuffle(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Shuffle([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n\tresult2 := Shuffle([]int{})\n\n\tis.NotEqual(result1, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n\tis.Equal(result2, []int{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Shuffle(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestReverse(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Reverse([]int{0, 1, 2, 3, 4, 5})\n\tresult2 := Reverse([]int{0, 1, 2, 3, 4, 5, 6})\n\tresult3 := Reverse([]int{})\n\n\tis.Equal(result1, []int{5, 4, 3, 2, 1, 0})\n\tis.Equal(result2, []int{6, 5, 4, 3, 2, 1, 0})\n\tis.Equal(result3, []int{})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Reverse(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestFill(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Fill([]foo{{\"a\"}, {\"a\"}}, foo{\"b\"})\n\tresult2 := Fill([]foo{}, foo{\"a\"})\n\n\tis.Equal(result1, []foo{{\"b\"}, {\"b\"}})\n\tis.Equal(result2, []foo{})\n}\n\nfunc TestRepeat(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := Repeat(2, foo{\"a\"})\n\tresult2 := Repeat(0, foo{\"a\"})\n\n\tis.Equal(result1, []foo{{\"a\"}, {\"a\"}})\n\tis.Equal(result2, []foo{})\n}\n\nfunc TestRepeatBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tcb := func(i int) int {\n\t\treturn int(math.Pow(float64(i), 2))\n\t}\n\n\tresult1 := RepeatBy(0, cb)\n\tresult2 := RepeatBy(2, cb)\n\tresult3 := RepeatBy(5, cb)\n\n\tis.Equal([]int{}, result1)\n\tis.Equal([]int{0, 1}, result2)\n\tis.Equal([]int{0, 1, 4, 9, 16}, result3)\n}\n\nfunc TestKeyBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := KeyBy([]string{\"a\", \"aa\", \"aaa\"}, func(str string) int {\n\t\treturn len(str)\n\t})\n\n\tis.Equal(result1, map[int]string{1: \"a\", 2: \"aa\", 3: \"aaa\"})\n}\n\nfunc TestAssociate(t *testing.T) {\n\tt.Parallel()\n\n\ttype foo struct {\n\t\tbaz string\n\t\tbar int\n\t}\n\ttransform := func(f *foo) (string, int) {\n\t\treturn f.baz, f.bar\n\t}\n\ttestCases := []struct {\n\t\tin     []*foo\n\t\texpect map[string]int\n\t}{\n\t\t{\n\t\t\tin:     []*foo{{baz: \"apple\", bar: 1}},\n\t\t\texpect: map[string]int{\"apple\": 1},\n\t\t},\n\t\t{\n\t\t\tin:     []*foo{{baz: \"apple\", bar: 1}, {baz: \"banana\", bar: 2}},\n\t\t\texpect: map[string]int{\"apple\": 1, \"banana\": 2},\n\t\t},\n\t\t{\n\t\t\tin:     []*foo{{baz: \"apple\", bar: 1}, {baz: \"apple\", bar: 2}},\n\t\t\texpect: map[string]int{\"apple\": 2},\n\t\t},\n\t}\n\tfor i, testCase := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\tis.Equal(Associate(testCase.in, transform), testCase.expect)\n\t\t})\n\t}\n}\n\nfunc TestSliceToMap(t *testing.T) {\n\tt.Parallel()\n\n\ttype foo struct {\n\t\tbaz string\n\t\tbar int\n\t}\n\ttransform := func(f *foo) (string, int) {\n\t\treturn f.baz, f.bar\n\t}\n\ttestCases := []struct {\n\t\tin     []*foo\n\t\texpect map[string]int\n\t}{\n\t\t{\n\t\t\tin:     []*foo{{baz: \"apple\", bar: 1}},\n\t\t\texpect: map[string]int{\"apple\": 1},\n\t\t},\n\t\t{\n\t\t\tin:     []*foo{{baz: \"apple\", bar: 1}, {baz: \"banana\", bar: 2}},\n\t\t\texpect: map[string]int{\"apple\": 1, \"banana\": 2},\n\t\t},\n\t\t{\n\t\t\tin:     []*foo{{baz: \"apple\", bar: 1}, {baz: \"apple\", bar: 2}},\n\t\t\texpect: map[string]int{\"apple\": 2},\n\t\t},\n\t}\n\tfor i, testCase := range testCases {\n\t\tt.Run(fmt.Sprintf(\"test_%d\", i), func(t *testing.T) {\n\t\t\tis := assert.New(t)\n\t\t\tis.Equal(SliceToMap(testCase.in, transform), testCase.expect)\n\t\t})\n\t}\n}\n\nfunc TestDrop(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal([]int{1, 2, 3, 4}, Drop([]int{0, 1, 2, 3, 4}, 1))\n\tis.Equal([]int{2, 3, 4}, Drop([]int{0, 1, 2, 3, 4}, 2))\n\tis.Equal([]int{3, 4}, Drop([]int{0, 1, 2, 3, 4}, 3))\n\tis.Equal([]int{4}, Drop([]int{0, 1, 2, 3, 4}, 4))\n\tis.Equal([]int{}, Drop([]int{0, 1, 2, 3, 4}, 5))\n\tis.Equal([]int{}, Drop([]int{0, 1, 2, 3, 4}, 6))\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Drop(allStrings, 2)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestDropRight(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal([]int{0, 1, 2, 3}, DropRight([]int{0, 1, 2, 3, 4}, 1))\n\tis.Equal([]int{0, 1, 2}, DropRight([]int{0, 1, 2, 3, 4}, 2))\n\tis.Equal([]int{0, 1}, DropRight([]int{0, 1, 2, 3, 4}, 3))\n\tis.Equal([]int{0}, DropRight([]int{0, 1, 2, 3, 4}, 4))\n\tis.Equal([]int{}, DropRight([]int{0, 1, 2, 3, 4}, 5))\n\tis.Equal([]int{}, DropRight([]int{0, 1, 2, 3, 4}, 6))\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := DropRight(allStrings, 2)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestDropWhile(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal([]int{4, 5, 6}, DropWhile([]int{0, 1, 2, 3, 4, 5, 6}, func(t int) bool {\n\t\treturn t != 4\n\t}))\n\n\tis.Equal([]int{}, DropWhile([]int{0, 1, 2, 3, 4, 5, 6}, func(t int) bool {\n\t\treturn true\n\t}))\n\n\tis.Equal([]int{0, 1, 2, 3, 4, 5, 6}, DropWhile([]int{0, 1, 2, 3, 4, 5, 6}, func(t int) bool {\n\t\treturn t == 10\n\t}))\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := DropWhile(allStrings, func(t string) bool {\n\t\treturn t != \"foo\"\n\t})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestDropRightWhile(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal([]int{0, 1, 2, 3}, DropRightWhile([]int{0, 1, 2, 3, 4, 5, 6}, func(t int) bool {\n\t\treturn t != 3\n\t}))\n\n\tis.Equal([]int{0, 1}, DropRightWhile([]int{0, 1, 2, 3, 4, 5, 6}, func(t int) bool {\n\t\treturn t != 1\n\t}))\n\n\tis.Equal([]int{0, 1, 2, 3, 4, 5, 6}, DropRightWhile([]int{0, 1, 2, 3, 4, 5, 6}, func(t int) bool {\n\t\treturn t == 10\n\t}))\n\n\tis.Equal([]int{}, DropRightWhile([]int{0, 1, 2, 3, 4, 5, 6}, func(t int) bool {\n\t\treturn t != 10\n\t}))\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := DropRightWhile(allStrings, func(t string) bool {\n\t\treturn t != \"foo\"\n\t})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestDropByIndex(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal([]int{1, 2, 3, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, 0))\n\tis.Equal([]int{3, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, 0, 1, 2))\n\tis.Equal([]int{0, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, -4, -2, -3))\n\tis.Equal([]int{0, 2, 3, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, -4, -4))\n\tis.Equal([]int{2, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, 3, 1, 0))\n\tis.Equal([]int{0, 1, 3, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, 2))\n\tis.Equal([]int{0, 1, 2, 3}, DropByIndex([]int{0, 1, 2, 3, 4}, 4))\n\tis.Equal([]int{0, 1, 2, 3, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, 5))\n\tis.Equal([]int{0, 1, 2, 3, 4}, DropByIndex([]int{0, 1, 2, 3, 4}, 100))\n\tis.Equal([]int{0, 1, 2, 3}, DropByIndex([]int{0, 1, 2, 3, 4}, -1))\n\tis.Equal([]int{}, DropByIndex([]int{}, 0, 1))\n\tis.Equal([]int{}, DropByIndex([]int{42}, 0, 1))\n\tis.Equal([]int{}, DropByIndex([]int{42}, 1, 0))\n\tis.Equal([]int{}, DropByIndex([]int{}, 1))\n\tis.Equal([]int{}, DropByIndex([]int{1}, 0))\n}\n\nfunc TestReject(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Reject([]int{1, 2, 3, 4}, func(x int, _ int) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(r1, []int{1, 3})\n\n\tr2 := Reject([]string{\"Smith\", \"foo\", \"Domin\", \"bar\", \"Olivia\"}, func(x string, _ int) bool {\n\t\treturn len(x) > 3\n\t})\n\n\tis.Equal(r2, []string{\"foo\", \"bar\"})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Reject(allStrings, func(x string, _ int) bool {\n\t\treturn len(x) > 0\n\t})\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestRejectMap(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := RejectMap([]int64{1, 2, 3, 4}, func(x int64, _ int) (string, bool) {\n\t\tif x%2 == 0 {\n\t\t\treturn strconv.FormatInt(x, 10), false\n\t\t}\n\t\treturn \"\", true\n\t})\n\tr2 := RejectMap([]string{\"cpu\", \"gpu\", \"mouse\", \"keyboard\"}, func(x string, _ int) (string, bool) {\n\t\tif strings.HasSuffix(x, \"pu\") {\n\t\t\treturn \"xpu\", false\n\t\t}\n\t\treturn \"\", true\n\t})\n\n\tis.Equal(len(r1), 2)\n\tis.Equal(len(r2), 2)\n\tis.Equal(r1, []string{\"2\", \"4\"})\n\tis.Equal(r2, []string{\"xpu\", \"xpu\"})\n}\n\nfunc TestFilterReject(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tleft1, right1 := FilterReject([]int{1, 2, 3, 4}, func(x int, _ int) bool {\n\t\treturn x%2 == 0\n\t})\n\n\tis.Equal(left1, []int{2, 4})\n\tis.Equal(right1, []int{1, 3})\n\n\tleft2, right2 := FilterReject([]string{\"Smith\", \"foo\", \"Domin\", \"bar\", \"Olivia\"}, func(x string, _ int) bool {\n\t\treturn len(x) > 3\n\t})\n\n\tis.Equal(left2, []string{\"Smith\", \"Domin\", \"Olivia\"})\n\tis.Equal(right2, []string{\"foo\", \"bar\"})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\ta, b := FilterReject(allStrings, func(x string, _ int) bool {\n\t\treturn len(x) > 0\n\t})\n\tis.IsType(a, allStrings, \"type preserved\")\n\tis.IsType(b, allStrings, \"type preserved\")\n}\n\nfunc TestCount(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tcount1 := Count([]int{1, 2, 1}, 1)\n\tcount2 := Count([]int{1, 2, 1}, 3)\n\tcount3 := Count([]int{}, 1)\n\n\tis.Equal(count1, 2)\n\tis.Equal(count2, 0)\n\tis.Equal(count3, 0)\n}\n\nfunc TestCountBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tcount1 := CountBy([]int{1, 2, 1}, func(i int) bool {\n\t\treturn i < 2\n\t})\n\n\tcount2 := CountBy([]int{1, 2, 1}, func(i int) bool {\n\t\treturn i > 2\n\t})\n\n\tcount3 := CountBy([]int{}, func(i int) bool {\n\t\treturn i <= 2\n\t})\n\n\tis.Equal(count1, 2)\n\tis.Equal(count2, 0)\n\tis.Equal(count3, 0)\n}\n\nfunc TestCountValues(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal(map[int]int{}, CountValues([]int{}))\n\tis.Equal(map[int]int{1: 1, 2: 1}, CountValues([]int{1, 2}))\n\tis.Equal(map[int]int{1: 1, 2: 2}, CountValues([]int{1, 2, 2}))\n\tis.Equal(map[string]int{\"\": 1, \"foo\": 1, \"bar\": 1}, CountValues([]string{\"foo\", \"bar\", \"\"}))\n\tis.Equal(map[string]int{\"foo\": 1, \"bar\": 2}, CountValues([]string{\"foo\", \"bar\", \"bar\"}))\n}\n\nfunc TestCountValuesBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\toddEven := func(v int) bool {\n\t\treturn v%2 == 0\n\t}\n\tlength := func(v string) int {\n\t\treturn len(v)\n\t}\n\n\tresult1 := CountValuesBy([]int{}, oddEven)\n\tresult2 := CountValuesBy([]int{1, 2}, oddEven)\n\tresult3 := CountValuesBy([]int{1, 2, 2}, oddEven)\n\tresult4 := CountValuesBy([]string{\"foo\", \"bar\", \"\"}, length)\n\tresult5 := CountValuesBy([]string{\"foo\", \"bar\", \"bar\"}, length)\n\n\tis.Equal(map[bool]int{}, result1)\n\tis.Equal(map[bool]int{true: 1, false: 1}, result2)\n\tis.Equal(map[bool]int{true: 2, false: 1}, result3)\n\tis.Equal(map[int]int{0: 1, 3: 2}, result4)\n\tis.Equal(map[int]int{3: 3}, result5)\n}\n\nfunc TestSubset(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tin := []int{0, 1, 2, 3, 4}\n\n\tout1 := Subset(in, 0, 0)\n\tout2 := Subset(in, 10, 2)\n\tout3 := Subset(in, -10, 2)\n\tout4 := Subset(in, 0, 10)\n\tout5 := Subset(in, 0, 2)\n\tout6 := Subset(in, 2, 2)\n\tout7 := Subset(in, 2, 5)\n\tout8 := Subset(in, 2, 3)\n\tout9 := Subset(in, 2, 4)\n\tout10 := Subset(in, -2, 4)\n\tout11 := Subset(in, -4, 1)\n\tout12 := Subset(in, -4, math.MaxUint)\n\n\tis.Equal([]int{}, out1)\n\tis.Equal([]int{}, out2)\n\tis.Equal([]int{0, 1}, out3)\n\tis.Equal([]int{0, 1, 2, 3, 4}, out4)\n\tis.Equal([]int{0, 1}, out5)\n\tis.Equal([]int{2, 3}, out6)\n\tis.Equal([]int{2, 3, 4}, out7)\n\tis.Equal([]int{2, 3, 4}, out8)\n\tis.Equal([]int{2, 3, 4}, out9)\n\tis.Equal([]int{3, 4}, out10)\n\tis.Equal([]int{1}, out11)\n\tis.Equal([]int{1, 2, 3, 4}, out12)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Subset(allStrings, 0, 2)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestSlice(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tin := []int{0, 1, 2, 3, 4}\n\n\tout1 := Slice(in, 0, 0)\n\tout2 := Slice(in, 0, 1)\n\tout3 := Slice(in, 0, 5)\n\tout4 := Slice(in, 0, 6)\n\tout5 := Slice(in, 1, 1)\n\tout6 := Slice(in, 1, 5)\n\tout7 := Slice(in, 1, 6)\n\tout8 := Slice(in, 4, 5)\n\tout9 := Slice(in, 5, 5)\n\tout10 := Slice(in, 6, 5)\n\tout11 := Slice(in, 6, 6)\n\tout12 := Slice(in, 1, 0)\n\tout13 := Slice(in, 5, 0)\n\tout14 := Slice(in, 6, 4)\n\tout15 := Slice(in, 6, 7)\n\tout16 := Slice(in, -10, 1)\n\tout17 := Slice(in, -1, 3)\n\tout18 := Slice(in, -10, 7)\n\n\tis.Equal([]int{}, out1)\n\tis.Equal([]int{0}, out2)\n\tis.Equal([]int{0, 1, 2, 3, 4}, out3)\n\tis.Equal([]int{0, 1, 2, 3, 4}, out4)\n\tis.Equal([]int{}, out5)\n\tis.Equal([]int{1, 2, 3, 4}, out6)\n\tis.Equal([]int{1, 2, 3, 4}, out7)\n\tis.Equal([]int{4}, out8)\n\tis.Equal([]int{}, out9)\n\tis.Equal([]int{}, out10)\n\tis.Equal([]int{}, out11)\n\tis.Equal([]int{}, out12)\n\tis.Equal([]int{}, out13)\n\tis.Equal([]int{}, out14)\n\tis.Equal([]int{}, out15)\n\tis.Equal([]int{0}, out16)\n\tis.Equal([]int{0, 1, 2}, out17)\n\tis.Equal([]int{0, 1, 2, 3, 4}, out18)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Slice(allStrings, 0, 2)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestReplace(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tin := []int{0, 1, 0, 1, 2, 3, 0}\n\n\tout1 := Replace(in, 0, 42, 2)\n\tout2 := Replace(in, 0, 42, 1)\n\tout3 := Replace(in, 0, 42, 0)\n\tout4 := Replace(in, 0, 42, -1)\n\tout5 := Replace(in, 0, 42, -1)\n\tout6 := Replace(in, -1, 42, 2)\n\tout7 := Replace(in, -1, 42, 1)\n\tout8 := Replace(in, -1, 42, 0)\n\tout9 := Replace(in, -1, 42, -1)\n\tout10 := Replace(in, -1, 42, -1)\n\n\tis.Equal([]int{42, 1, 42, 1, 2, 3, 0}, out1)\n\tis.Equal([]int{42, 1, 0, 1, 2, 3, 0}, out2)\n\tis.Equal([]int{0, 1, 0, 1, 2, 3, 0}, out3)\n\tis.Equal([]int{42, 1, 42, 1, 2, 3, 42}, out4)\n\tis.Equal([]int{42, 1, 42, 1, 2, 3, 42}, out5)\n\tis.Equal([]int{0, 1, 0, 1, 2, 3, 0}, out6)\n\tis.Equal([]int{0, 1, 0, 1, 2, 3, 0}, out7)\n\tis.Equal([]int{0, 1, 0, 1, 2, 3, 0}, out8)\n\tis.Equal([]int{0, 1, 0, 1, 2, 3, 0}, out9)\n\tis.Equal([]int{0, 1, 0, 1, 2, 3, 0}, out10)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Replace(allStrings, \"0\", \"2\", 1)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestReplaceAll(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tin := []int{0, 1, 0, 1, 2, 3, 0}\n\n\tout1 := ReplaceAll(in, 0, 42)\n\tout2 := ReplaceAll(in, -1, 42)\n\n\tis.Equal([]int{42, 1, 42, 1, 2, 3, 42}, out1)\n\tis.Equal([]int{0, 1, 0, 1, 2, 3, 0}, out2)\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := ReplaceAll(allStrings, \"0\", \"2\")\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestCompact(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Compact([]int{2, 0, 4, 0})\n\n\tis.Equal(r1, []int{2, 4})\n\n\tr2 := Compact([]string{\"\", \"foo\", \"\", \"bar\", \"\"})\n\n\tis.Equal(r2, []string{\"foo\", \"bar\"})\n\n\tr3 := Compact([]bool{true, false, true, false})\n\n\tis.Equal(r3, []bool{true, true})\n\n\ttype foo struct {\n\t\tbar int\n\t\tbaz string\n\t}\n\n\t// slice of structs\n\t// If all fields of an element are zero values, Compact removes it.\n\n\tr4 := Compact([]foo{\n\t\t{bar: 1, baz: \"a\"}, // all fields are non-zero values\n\t\t{bar: 0, baz: \"\"},  // all fields are zero values\n\t\t{bar: 2, baz: \"\"},  // bar is non-zero\n\t})\n\n\tis.Equal(r4, []foo{{bar: 1, baz: \"a\"}, {bar: 2, baz: \"\"}})\n\n\t// slice of pointers to structs\n\t// If an element is nil, Compact removes it.\n\n\te1, e2, e3 := foo{bar: 1, baz: \"a\"}, foo{bar: 0, baz: \"\"}, foo{bar: 2, baz: \"\"}\n\t// NOTE: e2 is a zero value of foo, but its pointer &e2 is not a zero value of *foo.\n\tr5 := Compact([]*foo{&e1, &e2, nil, &e3})\n\n\tis.Equal(r5, []*foo{&e1, &e2, &e3})\n\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Compact(allStrings)\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n\nfunc TestIsSorted(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.True(IsSorted([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tis.True(IsSorted([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"}))\n\n\tis.False(IsSorted([]int{0, 1, 4, 3, 2, 5, 6, 7, 8, 9, 10}))\n\tis.False(IsSorted([]string{\"a\", \"b\", \"d\", \"c\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"}))\n}\n\nfunc TestIsSortedByKey(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.True(IsSortedByKey([]string{\"a\", \"bb\", \"ccc\"}, func(s string) int {\n\t\treturn len(s)\n\t}))\n\n\tis.False(IsSortedByKey([]string{\"aa\", \"b\", \"ccc\"}, func(s string) int {\n\t\treturn len(s)\n\t}))\n\n\tis.True(IsSortedByKey([]string{\"1\", \"2\", \"3\", \"11\"}, func(s string) int {\n\t\tret, _ := strconv.Atoi(s)\n\t\treturn ret\n\t}))\n}\n\nfunc TestSplice(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tsample := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}\n\n\t// normal case\n\tresults := Splice(sample, 1, \"1\", \"2\")\n\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}, sample)\n\tis.Equal([]string{\"a\", \"1\", \"2\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}, results)\n\n\t// check there is no side effect\n\tresults = Splice(sample, 1)\n\tresults[0] = \"b\"\n\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}, sample)\n\n\t// positive overflow\n\tresults = Splice(sample, 42, \"1\", \"2\")\n\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}, sample)\n\tis.Equal(results, []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"1\", \"2\"})\n\n\t// negative overflow\n\tresults = Splice(sample, -42, \"1\", \"2\")\n\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}, sample)\n\tis.Equal(results, []string{\"1\", \"2\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"})\n\n\t// backward\n\tresults = Splice(sample, -2, \"1\", \"2\")\n\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}, sample)\n\tis.Equal(results, []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"1\", \"2\", \"f\", \"g\"})\n\n\tresults = Splice(sample, -7, \"1\", \"2\")\n\tis.Equal([]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"}, sample)\n\tis.Equal(results, []string{\"1\", \"2\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"})\n\n\t// other\n\tis.Equal([]string{\"1\", \"2\"}, Splice([]string{}, 0, \"1\", \"2\"))\n\tis.Equal([]string{\"1\", \"2\"}, Splice([]string{}, 1, \"1\", \"2\"))\n\tis.Equal([]string{\"1\", \"2\"}, Splice([]string{}, -1, \"1\", \"2\"))\n\tis.Equal([]string{\"1\", \"2\", \"0\"}, Splice([]string{\"0\"}, 0, \"1\", \"2\"))\n\tis.Equal([]string{\"0\", \"1\", \"2\"}, Splice([]string{\"0\"}, 1, \"1\", \"2\"))\n\tis.Equal([]string{\"1\", \"2\", \"0\"}, Splice([]string{\"0\"}, -1, \"1\", \"2\"))\n\n\t// type preserved\n\ttype myStrings []string\n\tallStrings := myStrings{\"\", \"foo\", \"bar\"}\n\tnonempty := Splice(allStrings, 1, \"1\", \"2\")\n\tis.IsType(nonempty, allStrings, \"type preserved\")\n}\n"
        },
        {
          "name": "string.go",
          "type": "blob",
          "size": 6.287109375,
          "content": "package lo\n\nimport (\n\t\"github.com/samber/lo/internal/rand\"\n\t\"math\"\n\t\"regexp\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"golang.org/x/text/cases\"\n\t\"golang.org/x/text/language\"\n)\n\nvar (\n\tLowerCaseLettersCharset = []rune(\"abcdefghijklmnopqrstuvwxyz\")\n\tUpperCaseLettersCharset = []rune(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\tLettersCharset          = append(LowerCaseLettersCharset, UpperCaseLettersCharset...)\n\tNumbersCharset          = []rune(\"0123456789\")\n\tAlphanumericCharset     = append(LettersCharset, NumbersCharset...)\n\tSpecialCharset          = []rune(\"!@#$%^&*()_+-=[]{}|;':\\\",./<>?\")\n\tAllCharset              = append(AlphanumericCharset, SpecialCharset...)\n\n\t// bearer:disable go_lang_permissive_regex_validation\n\tsplitWordReg = regexp.MustCompile(`([a-z])([A-Z0-9])|([a-zA-Z])([0-9])|([0-9])([a-zA-Z])|([A-Z])([A-Z])([a-z])`)\n\t// bearer:disable go_lang_permissive_regex_validation\n\tsplitNumberLetterReg = regexp.MustCompile(`([0-9])([a-zA-Z])`)\n\tmaximumCapacity      = math.MaxInt>>1 + 1\n)\n\n// RandomString return a random string.\n// Play: https://go.dev/play/p/rRseOQVVum4\nfunc RandomString(size int, charset []rune) string {\n\tif size <= 0 {\n\t\tpanic(\"lo.RandomString: Size parameter must be greater than 0\")\n\t}\n\tif len(charset) <= 0 {\n\t\tpanic(\"lo.RandomString: Charset parameter must not be empty\")\n\t}\n\n\t// see https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go\n\tsb := strings.Builder{}\n\tsb.Grow(size)\n\t// Calculate the number of bits required to represent the charset,\n\t// e.g., for 62 characters, it would need 6 bits (since 62 -> 64 = 2^6)\n\tletterIdBits := int(math.Log2(float64(nearestPowerOfTwo(len(charset)))))\n\t// Determine the corresponding bitmask,\n\t// e.g., for 62 characters, the bitmask would be 111111.\n\tvar letterIdMask int64 = 1<<letterIdBits - 1\n\t// Available count, since rand.Int64() returns a non-negative number, the first bit is fixed, so there are 63 random bits\n\t// e.g., for 62 characters, this value is 10 (63 / 6).\n\tletterIdMax := 63 / letterIdBits\n\t// Generate the random string in a loop.\n\tfor i, cache, remain := size-1, rand.Int64(), letterIdMax; i >= 0; {\n\t\t// Regenerate the random number if all available bits have been used\n\t\tif remain == 0 {\n\t\t\tcache, remain = rand.Int64(), letterIdMax\n\t\t}\n\t\t// Select a character from the charset\n\t\tif idx := int(cache & letterIdMask); idx < len(charset) {\n\t\t\tsb.WriteRune(charset[idx])\n\t\t\ti--\n\t\t}\n\t\t// Shift the bits to the right to prepare for the next character selection,\n\t\t// e.g., for 62 characters, shift by 6 bits.\n\t\tcache >>= letterIdBits\n\t\t// Decrease the remaining number of uses for the current random number.\n\t\tremain--\n\t}\n\treturn sb.String()\n}\n\n// nearestPowerOfTwo returns the nearest power of two.\nfunc nearestPowerOfTwo(cap int) int {\n\tn := cap - 1\n\tn |= n >> 1\n\tn |= n >> 2\n\tn |= n >> 4\n\tn |= n >> 8\n\tn |= n >> 16\n\tif n < 0 {\n\t\treturn 1\n\t}\n\tif n >= maximumCapacity {\n\t\treturn maximumCapacity\n\t}\n\treturn n + 1\n}\n\n// Substring return part of a string.\n// Play: https://go.dev/play/p/TQlxQi82Lu1\nfunc Substring[T ~string](str T, offset int, length uint) T {\n\trs := []rune(str)\n\tsize := len(rs)\n\n\tif offset < 0 {\n\t\toffset = size + offset\n\t\tif offset < 0 {\n\t\t\toffset = 0\n\t\t}\n\t}\n\n\tif offset >= size {\n\t\treturn Empty[T]()\n\t}\n\n\tif length > uint(size)-uint(offset) {\n\t\tlength = uint(size - offset)\n\t}\n\n\treturn T(strings.Replace(string(rs[offset:offset+int(length)]), \"\\x00\", \"\", -1))\n}\n\n// ChunkString returns an array of strings split into groups the length of size. If array can't be split evenly,\n// the final chunk will be the remaining elements.\n// Play: https://go.dev/play/p/__FLTuJVz54\nfunc ChunkString[T ~string](str T, size int) []T {\n\tif size <= 0 {\n\t\tpanic(\"lo.ChunkString: Size parameter must be greater than 0\")\n\t}\n\n\tif len(str) == 0 {\n\t\treturn []T{\"\"}\n\t}\n\n\tif size >= len(str) {\n\t\treturn []T{str}\n\t}\n\n\tvar chunks = make([]T, 0, ((len(str)-1)/size)+1)\n\tcurrentLen := 0\n\tcurrentStart := 0\n\tfor i := range str {\n\t\tif currentLen == size {\n\t\t\tchunks = append(chunks, str[currentStart:i])\n\t\t\tcurrentLen = 0\n\t\t\tcurrentStart = i\n\t\t}\n\t\tcurrentLen++\n\t}\n\tchunks = append(chunks, str[currentStart:])\n\treturn chunks\n}\n\n// RuneLength is an alias to utf8.RuneCountInString which returns the number of runes in string.\n// Play: https://go.dev/play/p/tuhgW_lWY8l\nfunc RuneLength(str string) int {\n\treturn utf8.RuneCountInString(str)\n}\n\n// PascalCase converts string to pascal case.\nfunc PascalCase(str string) string {\n\titems := Words(str)\n\tfor i := range items {\n\t\titems[i] = Capitalize(items[i])\n\t}\n\treturn strings.Join(items, \"\")\n}\n\n// CamelCase converts string to camel case.\nfunc CamelCase(str string) string {\n\titems := Words(str)\n\tfor i, item := range items {\n\t\titem = strings.ToLower(item)\n\t\tif i > 0 {\n\t\t\titem = Capitalize(item)\n\t\t}\n\t\titems[i] = item\n\t}\n\treturn strings.Join(items, \"\")\n}\n\n// KebabCase converts string to kebab case.\nfunc KebabCase(str string) string {\n\titems := Words(str)\n\tfor i := range items {\n\t\titems[i] = strings.ToLower(items[i])\n\t}\n\treturn strings.Join(items, \"-\")\n}\n\n// SnakeCase converts string to snake case.\nfunc SnakeCase(str string) string {\n\titems := Words(str)\n\tfor i := range items {\n\t\titems[i] = strings.ToLower(items[i])\n\t}\n\treturn strings.Join(items, \"_\")\n}\n\n// Words splits string into an array of its words.\nfunc Words(str string) []string {\n\tstr = splitWordReg.ReplaceAllString(str, `$1$3$5$7 $2$4$6$8$9`)\n\t// example: Int8Value => Int 8Value => Int 8 Value\n\tstr = splitNumberLetterReg.ReplaceAllString(str, \"$1 $2\")\n\tvar result strings.Builder\n\tfor _, r := range str {\n\t\tif unicode.IsLetter(r) || unicode.IsDigit(r) {\n\t\t\tresult.WriteRune(r)\n\t\t} else {\n\t\t\tresult.WriteRune(' ')\n\t\t}\n\t}\n\treturn strings.Fields(result.String())\n}\n\n// Capitalize converts the first character of string to upper case and the remaining to lower case.\nfunc Capitalize(str string) string {\n\treturn cases.Title(language.English).String(str)\n}\n\n// Ellipsis trims and truncates a string to a specified length and appends an ellipsis if truncated.\nfunc Ellipsis(str string, length int) string {\n\tstr = strings.TrimSpace(str)\n\n\tif len(str) > length {\n\t\tif len(str) < 3 || length < 3 {\n\t\t\treturn \"...\"\n\t\t}\n\t\treturn strings.TrimSpace(str[0:length-3]) + \"...\"\n\t}\n\n\treturn str\n}\n\n// Elipse trims and truncates a string to a specified length and appends an ellipsis if truncated.\n//\n// Deprecated: Use Ellipsis instead.\nfunc Elipse(str string, length int) string {\n\treturn Ellipsis(str, length)\n}\n"
        },
        {
          "name": "string_example_test.go",
          "type": "blob",
          "size": 1.056640625,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc ExampleSubstring() {\n\tresult1 := Substring(\"hello\", 2, 3)\n\tresult2 := Substring(\"hello\", -4, 3)\n\tresult3 := Substring(\"hello\", -2, math.MaxUint)\n\tresult4 := Substring(\"🏠🐶🐱\", 0, 2)\n\tresult5 := Substring(\"你好，世界\", 0, 3)\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\tfmt.Printf(\"%v\\n\", result5)\n\t// Output:\n\t// llo\n\t// ell\n\t// lo\n\t// 🏠🐶\n\t// 你好，\n}\n\nfunc ExampleChunkString() {\n\tresult1 := ChunkString(\"123456\", 2)\n\tresult2 := ChunkString(\"1234567\", 2)\n\tresult3 := ChunkString(\"\", 2)\n\tresult4 := ChunkString(\"1\", 2)\n\n\tfmt.Printf(\"%v\\n\", result1)\n\tfmt.Printf(\"%v\\n\", result2)\n\tfmt.Printf(\"%v\\n\", result3)\n\tfmt.Printf(\"%v\\n\", result4)\n\t// Output:\n\t// [12 34 56]\n\t// [12 34 56 7]\n\t// []\n\t// [1]\n}\n\nfunc ExampleRuneLength() {\n\tresult1, chars1 := RuneLength(\"hellô\"), len(\"hellô\")\n\tresult2, chars2 := RuneLength(\"🤘\"), len(\"🤘\")\n\n\tfmt.Printf(\"%v %v\\n\", result1, chars1)\n\tfmt.Printf(\"%v %v\\n\", result2, chars2)\n\t// Output:\n\t// 5 6\n\t// 1 4\n}\n"
        },
        {
          "name": "string_test.go",
          "type": "blob",
          "size": 15.564453125,
          "content": "package lo\n\nimport (\n\t\"math\"\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRandomString(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\trand.Seed(time.Now().UnixNano())\n\n\tstr1 := RandomString(100, LowerCaseLettersCharset)\n\tis.Equal(100, RuneLength(str1))\n\tis.Subset(LowerCaseLettersCharset, []rune(str1))\n\n\tstr2 := RandomString(100, LowerCaseLettersCharset)\n\tis.NotEqual(str1, str2)\n\n\tnoneUtf8Charset := []rune(\"明1好休2林森\")\n\tstr3 := RandomString(100, noneUtf8Charset)\n\tis.Equal(100, RuneLength(str3))\n\tis.Subset(noneUtf8Charset, []rune(str3))\n\n\tis.PanicsWithValue(\"lo.RandomString: Charset parameter must not be empty\", func() { RandomString(100, []rune{}) })\n\tis.PanicsWithValue(\"lo.RandomString: Size parameter must be greater than 0\", func() { RandomString(0, LowerCaseLettersCharset) })\n}\n\nfunc TestChunkString(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := ChunkString(\"12345\", 2)\n\tis.Equal([]string{\"12\", \"34\", \"5\"}, result1)\n\n\tresult2 := ChunkString(\"123456\", 2)\n\tis.Equal([]string{\"12\", \"34\", \"56\"}, result2)\n\n\tresult3 := ChunkString(\"123456\", 6)\n\tis.Equal([]string{\"123456\"}, result3)\n\n\tresult4 := ChunkString(\"123456\", 10)\n\tis.Equal([]string{\"123456\"}, result4)\n\n\tresult5 := ChunkString(\"\", 2)\n\tis.Equal([]string{\"\"}, result5)\n\n\tresult6 := ChunkString(\"明1好休2林森\", 2)\n\tis.Equal([]string{\"明1\", \"好休\", \"2林\", \"森\"}, result6)\n\n\tis.Panics(func() {\n\t\tChunkString(\"12345\", 0)\n\t})\n}\n\nfunc TestSubstring(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tstr1 := Substring(\"hello\", 0, 0)\n\tstr2 := Substring(\"hello\", 10, 2)\n\tstr3 := Substring(\"hello\", -10, 2)\n\tstr4 := Substring(\"hello\", 0, 10)\n\tstr5 := Substring(\"hello\", 0, 2)\n\tstr6 := Substring(\"hello\", 2, 2)\n\tstr7 := Substring(\"hello\", 2, 5)\n\tstr8 := Substring(\"hello\", 2, 3)\n\tstr9 := Substring(\"hello\", 2, 4)\n\tstr10 := Substring(\"hello\", -2, 4)\n\tstr11 := Substring(\"hello\", -4, 1)\n\tstr12 := Substring(\"hello\", -4, math.MaxUint)\n\tstr13 := Substring(\"🏠🐶🐱\", 0, 2)\n\tstr14 := Substring(\"你好，世界\", 0, 3)\n\tstr15 := Substring(\"hello\", 5, 1)\n\n\tis.Equal(\"\", str1)\n\tis.Equal(\"\", str2)\n\tis.Equal(\"he\", str3)\n\tis.Equal(\"hello\", str4)\n\tis.Equal(\"he\", str5)\n\tis.Equal(\"ll\", str6)\n\tis.Equal(\"llo\", str7)\n\tis.Equal(\"llo\", str8)\n\tis.Equal(\"llo\", str9)\n\tis.Equal(\"lo\", str10)\n\tis.Equal(\"e\", str11)\n\tis.Equal(\"ello\", str12)\n\tis.Equal(\"🏠🐶\", str13)\n\tis.Equal(\"你好，\", str14)\n\tis.Equal(\"\", str15)\n}\n\nfunc TestRuneLength(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal(5, RuneLength(\"hellô\"))\n\tis.Equal(6, len(\"hellô\"))\n}\n\nfunc TestAllCase(t *testing.T) {\n\ttype output struct {\n\t\tPascalCase string\n\t\tCamelCase  string\n\t\tKebabCase  string\n\t\tSnakeCase  string\n\t}\n\tname := \"\"\n\ttests := []struct {\n\t\tname   string\n\t\tinput  string\n\t\toutput output\n\t}{\n\t\t{name: name, output: output{}},\n\t\t{name: name, input: \".\", output: output{}},\n\t\t{name: name, input: \"Hello world!\", output: output{\n\t\t\tPascalCase: \"HelloWorld\",\n\t\t\tCamelCase:  \"helloWorld\",\n\t\t\tKebabCase:  \"hello-world\",\n\t\t\tSnakeCase:  \"hello_world\",\n\t\t}},\n\t\t{name: name, input: \"A\", output: output{\n\t\t\tPascalCase: \"A\",\n\t\t\tCamelCase:  \"a\",\n\t\t\tKebabCase:  \"a\",\n\t\t\tSnakeCase:  \"a\",\n\t\t}},\n\t\t{name: name, input: \"a\", output: output{\n\t\t\tPascalCase: \"A\",\n\t\t\tCamelCase:  \"a\",\n\t\t\tKebabCase:  \"a\",\n\t\t\tSnakeCase:  \"a\",\n\t\t}},\n\t\t{name: name, input: \"foo\", output: output{\n\t\t\tPascalCase: \"Foo\",\n\t\t\tCamelCase:  \"foo\",\n\t\t\tKebabCase:  \"foo\",\n\t\t\tSnakeCase:  \"foo\",\n\t\t}},\n\t\t{name: name, input: \"snake_case\", output: output{\n\t\t\tPascalCase: \"SnakeCase\",\n\t\t\tCamelCase:  \"snakeCase\",\n\t\t\tKebabCase:  \"snake-case\",\n\t\t\tSnakeCase:  \"snake_case\",\n\t\t}},\n\t\t{name: name, input: \"SNAKE_CASE\", output: output{\n\t\t\tPascalCase: \"SnakeCase\",\n\t\t\tCamelCase:  \"snakeCase\",\n\t\t\tKebabCase:  \"snake-case\",\n\t\t\tSnakeCase:  \"snake_case\",\n\t\t}},\n\t\t{name: name, input: \"kebab-case\", output: output{\n\t\t\tPascalCase: \"KebabCase\",\n\t\t\tCamelCase:  \"kebabCase\",\n\t\t\tKebabCase:  \"kebab-case\",\n\t\t\tSnakeCase:  \"kebab_case\",\n\t\t}},\n\t\t{name: name, input: \"PascalCase\", output: output{\n\t\t\tPascalCase: \"PascalCase\",\n\t\t\tCamelCase:  \"pascalCase\",\n\t\t\tKebabCase:  \"pascal-case\",\n\t\t\tSnakeCase:  \"pascal_case\",\n\t\t}},\n\t\t{name: name, input: \"camelCase\", output: output{\n\t\t\tPascalCase: \"CamelCase\",\n\t\t\tCamelCase:  \"camelCase\",\n\t\t\tKebabCase:  `camel-case`,\n\t\t\tSnakeCase:  \"camel_case\",\n\t\t}},\n\t\t{name: name, input: \"Title Case\", output: output{\n\t\t\tPascalCase: \"TitleCase\",\n\t\t\tCamelCase:  \"titleCase\",\n\t\t\tKebabCase:  \"title-case\",\n\t\t\tSnakeCase:  \"title_case\",\n\t\t}},\n\t\t{name: name, input: \"point.case\", output: output{\n\t\t\tPascalCase: \"PointCase\",\n\t\t\tCamelCase:  \"pointCase\",\n\t\t\tKebabCase:  \"point-case\",\n\t\t\tSnakeCase:  \"point_case\",\n\t\t}},\n\t\t{name: name, input: \"snake_case_with_more_words\", output: output{\n\t\t\tPascalCase: \"SnakeCaseWithMoreWords\",\n\t\t\tCamelCase:  \"snakeCaseWithMoreWords\",\n\t\t\tKebabCase:  \"snake-case-with-more-words\",\n\t\t\tSnakeCase:  \"snake_case_with_more_words\",\n\t\t}},\n\t\t{name: name, input: \"SNAKE_CASE_WITH_MORE_WORDS\", output: output{\n\t\t\tPascalCase: \"SnakeCaseWithMoreWords\",\n\t\t\tCamelCase:  \"snakeCaseWithMoreWords\",\n\t\t\tKebabCase:  \"snake-case-with-more-words\",\n\t\t\tSnakeCase:  \"snake_case_with_more_words\",\n\t\t}},\n\t\t{name: name, input: \"kebab-case-with-more-words\", output: output{\n\t\t\tPascalCase: \"KebabCaseWithMoreWords\",\n\t\t\tCamelCase:  \"kebabCaseWithMoreWords\",\n\t\t\tKebabCase:  \"kebab-case-with-more-words\",\n\t\t\tSnakeCase:  \"kebab_case_with_more_words\",\n\t\t}},\n\t\t{name: name, input: \"PascalCaseWithMoreWords\", output: output{\n\t\t\tPascalCase: \"PascalCaseWithMoreWords\",\n\t\t\tCamelCase:  \"pascalCaseWithMoreWords\",\n\t\t\tKebabCase:  \"pascal-case-with-more-words\",\n\t\t\tSnakeCase:  \"pascal_case_with_more_words\",\n\t\t}},\n\t\t{name: name, input: \"camelCaseWithMoreWords\", output: output{\n\t\t\tPascalCase: \"CamelCaseWithMoreWords\",\n\t\t\tCamelCase:  \"camelCaseWithMoreWords\",\n\t\t\tKebabCase:  \"camel-case-with-more-words\",\n\t\t\tSnakeCase:  \"camel_case_with_more_words\",\n\t\t}},\n\t\t{name: name, input: \"Title Case With More Words\", output: output{\n\t\t\tPascalCase: \"TitleCaseWithMoreWords\",\n\t\t\tCamelCase:  \"titleCaseWithMoreWords\",\n\t\t\tKebabCase:  \"title-case-with-more-words\",\n\t\t\tSnakeCase:  \"title_case_with_more_words\",\n\t\t}},\n\t\t{name: name, input: \"point.case.with.more.words\", output: output{\n\t\t\tPascalCase: \"PointCaseWithMoreWords\",\n\t\t\tCamelCase:  \"pointCaseWithMoreWords\",\n\t\t\tKebabCase:  \"point-case-with-more-words\",\n\t\t\tSnakeCase:  \"point_case_with_more_words\",\n\t\t}},\n\t\t{name: name, input: \"snake_case__with___multiple____delimiters\", output: output{\n\t\t\tPascalCase: \"SnakeCaseWithMultipleDelimiters\",\n\t\t\tCamelCase:  \"snakeCaseWithMultipleDelimiters\",\n\t\t\tKebabCase:  \"snake-case-with-multiple-delimiters\",\n\t\t\tSnakeCase:  \"snake_case_with_multiple_delimiters\",\n\t\t}},\n\t\t{name: name, input: \"SNAKE_CASE__WITH___multiple____DELIMITERS\", output: output{\n\t\t\tPascalCase: \"SnakeCaseWithMultipleDelimiters\",\n\t\t\tCamelCase:  \"snakeCaseWithMultipleDelimiters\",\n\t\t\tKebabCase:  \"snake-case-with-multiple-delimiters\",\n\t\t\tSnakeCase:  \"snake_case_with_multiple_delimiters\",\n\t\t}},\n\t\t{name: name, input: \"kebab-case--with---multiple----delimiters\", output: output{\n\t\t\tPascalCase: \"KebabCaseWithMultipleDelimiters\",\n\t\t\tCamelCase:  \"kebabCaseWithMultipleDelimiters\",\n\t\t\tKebabCase:  \"kebab-case-with-multiple-delimiters\",\n\t\t\tSnakeCase:  \"kebab_case_with_multiple_delimiters\",\n\t\t}},\n\t\t{name: name, input: \"Title Case  With   Multiple    Delimiters\", output: output{\n\t\t\tPascalCase: \"TitleCaseWithMultipleDelimiters\",\n\t\t\tCamelCase:  \"titleCaseWithMultipleDelimiters\",\n\t\t\tKebabCase:  \"title-case-with-multiple-delimiters\",\n\t\t\tSnakeCase:  \"title_case_with_multiple_delimiters\",\n\t\t}},\n\t\t{name: name, input: \"point.case..with...multiple....delimiters\", output: output{\n\t\t\tPascalCase: \"PointCaseWithMultipleDelimiters\",\n\t\t\tCamelCase:  \"pointCaseWithMultipleDelimiters\",\n\t\t\tKebabCase:  \"point-case-with-multiple-delimiters\",\n\t\t\tSnakeCase:  \"point_case_with_multiple_delimiters\",\n\t\t}},\n\t\t{name: name, input: \" leading space\", output: output{\n\t\t\tPascalCase: \"LeadingSpace\",\n\t\t\tCamelCase:  \"leadingSpace\",\n\t\t\tKebabCase:  \"leading-space\",\n\t\t\tSnakeCase:  \"leading_space\",\n\t\t}},\n\t\t{name: name, input: \"   leading spaces\", output: output{\n\t\t\tPascalCase: \"LeadingSpaces\",\n\t\t\tCamelCase:  \"leadingSpaces\",\n\t\t\tKebabCase:  \"leading-spaces\",\n\t\t\tSnakeCase:  \"leading_spaces\",\n\t\t}},\n\t\t{name: name, input: \"\\t\\t\\r\\n leading whitespaces\", output: output{\n\t\t\tPascalCase: \"LeadingWhitespaces\",\n\t\t\tCamelCase:  \"leadingWhitespaces\",\n\t\t\tKebabCase:  \"leading-whitespaces\",\n\t\t\tSnakeCase:  \"leading_whitespaces\",\n\t\t}},\n\t\t{name: name, input: \"trailing space \", output: output{\n\t\t\tPascalCase: \"TrailingSpace\",\n\t\t\tCamelCase:  \"trailingSpace\",\n\t\t\tKebabCase:  \"trailing-space\",\n\t\t\tSnakeCase:  \"trailing_space\",\n\t\t}},\n\t\t{name: name, input: \"trailing spaces   \", output: output{\n\t\t\tPascalCase: \"TrailingSpaces\",\n\t\t\tCamelCase:  \"trailingSpaces\",\n\t\t\tKebabCase:  \"trailing-spaces\",\n\t\t\tSnakeCase:  \"trailing_spaces\",\n\t\t}},\n\t\t{name: name, input: \"trailing whitespaces\\t\\t\\r\\n\", output: output{\n\t\t\tPascalCase: \"TrailingWhitespaces\",\n\t\t\tCamelCase:  \"trailingWhitespaces\",\n\t\t\tKebabCase:  \"trailing-whitespaces\",\n\t\t\tSnakeCase:  \"trailing_whitespaces\",\n\t\t}},\n\t\t{name: name, input: \" on both sides \", output: output{\n\t\t\tPascalCase: \"OnBothSides\",\n\t\t\tCamelCase:  \"onBothSides\",\n\t\t\tKebabCase:  \"on-both-sides\",\n\t\t\tSnakeCase:  \"on_both_sides\",\n\t\t}},\n\t\t{name: name, input: \"    many on both sides  \", output: output{\n\t\t\tPascalCase: \"ManyOnBothSides\",\n\t\t\tCamelCase:  \"manyOnBothSides\",\n\t\t\tKebabCase:  \"many-on-both-sides\",\n\t\t\tSnakeCase:  \"many_on_both_sides\",\n\t\t}},\n\t\t{name: name, input: \"\\r whitespaces on both sides\\t\\t\\r\\n\", output: output{\n\t\t\tPascalCase: \"WhitespacesOnBothSides\",\n\t\t\tCamelCase:  \"whitespacesOnBothSides\",\n\t\t\tKebabCase:  \"whitespaces-on-both-sides\",\n\t\t\tSnakeCase:  \"whitespaces_on_both_sides\",\n\t\t}},\n\t\t{name: name, input: \"  extraSpaces in_This TestCase Of MIXED_CASES\\t\", output: output{\n\t\t\tPascalCase: \"ExtraSpacesInThisTestCaseOfMixedCases\",\n\t\t\tCamelCase:  \"extraSpacesInThisTestCaseOfMixedCases\",\n\t\t\tKebabCase:  \"extra-spaces-in-this-test-case-of-mixed-cases\",\n\t\t\tSnakeCase:  \"extra_spaces_in_this_test_case_of_mixed_cases\",\n\t\t}},\n\t\t{name: name, input: \"CASEBreak\", output: output{\n\t\t\tPascalCase: \"CaseBreak\",\n\t\t\tCamelCase:  \"caseBreak\",\n\t\t\tKebabCase:  \"case-break\",\n\t\t\tSnakeCase:  \"case_break\",\n\t\t}},\n\t\t{name: name, input: \"ID\", output: output{\n\t\t\tPascalCase: \"Id\",\n\t\t\tCamelCase:  \"id\",\n\t\t\tKebabCase:  \"id\",\n\t\t\tSnakeCase:  \"id\",\n\t\t}},\n\t\t{name: name, input: \"userID\", output: output{\n\t\t\tPascalCase: \"UserId\",\n\t\t\tCamelCase:  \"userId\",\n\t\t\tKebabCase:  \"user-id\",\n\t\t\tSnakeCase:  \"user_id\",\n\t\t}},\n\t\t{name: name, input: \"JSON_blob\", output: output{\n\t\t\tPascalCase: \"JsonBlob\",\n\t\t\tCamelCase:  \"jsonBlob\",\n\t\t\tKebabCase:  \"json-blob\",\n\t\t\tSnakeCase:  \"json_blob\",\n\t\t}},\n\t\t{name: name, input: \"HTTPStatusCode\", output: output{\n\t\t\tPascalCase: \"HttpStatusCode\",\n\t\t\tCamelCase:  \"httpStatusCode\",\n\t\t\tKebabCase:  \"http-status-code\",\n\t\t\tSnakeCase:  \"http_status_code\",\n\t\t}},\n\t\t{name: name, input: \"FreeBSD and SSLError are not golang initialisms\", output: output{\n\t\t\tPascalCase: \"FreeBsdAndSslErrorAreNotGolangInitialisms\",\n\t\t\tCamelCase:  \"freeBsdAndSslErrorAreNotGolangInitialisms\",\n\t\t\tKebabCase:  \"free-bsd-and-ssl-error-are-not-golang-initialisms\",\n\t\t\tSnakeCase:  \"free_bsd_and_ssl_error_are_not_golang_initialisms\",\n\t\t}},\n\t\t{name: name, input: \"David's Computer\", output: output{\n\t\t\tPascalCase: \"DavidSComputer\",\n\t\t\tCamelCase:  \"davidSComputer\",\n\t\t\tKebabCase:  \"david-s-computer\",\n\t\t\tSnakeCase:  \"david_s_computer\",\n\t\t}},\n\t\t{name: name, input: \"http200\", output: output{\n\t\t\tPascalCase: \"Http200\",\n\t\t\tCamelCase:  \"http200\",\n\t\t\tKebabCase:  \"http-200\",\n\t\t\tSnakeCase:  \"http_200\",\n\t\t}},\n\t\t{name: name, input: \"NumberSplittingVersion1.0r3\", output: output{\n\t\t\tPascalCase: \"NumberSplittingVersion10R3\",\n\t\t\tCamelCase:  \"numberSplittingVersion10R3\",\n\t\t\tKebabCase:  \"number-splitting-version-1-0-r3\",\n\t\t\tSnakeCase:  \"number_splitting_version_1_0_r3\",\n\t\t}},\n\t\t{name: name, input: \"When you have a comma, odd results\", output: output{\n\t\t\tPascalCase: \"WhenYouHaveACommaOddResults\",\n\t\t\tCamelCase:  \"whenYouHaveACommaOddResults\",\n\t\t\tKebabCase:  \"when-you-have-a-comma-odd-results\",\n\t\t\tSnakeCase:  \"when_you_have_a_comma_odd_results\",\n\t\t}},\n\t\t{name: name, input: \"Ordinal numbers work: 1st 2nd and 3rd place\", output: output{\n\t\t\tPascalCase: \"OrdinalNumbersWork1St2NdAnd3RdPlace\",\n\t\t\tCamelCase:  \"ordinalNumbersWork1St2NdAnd3RdPlace\",\n\t\t\tKebabCase:  \"ordinal-numbers-work-1-st-2-nd-and-3-rd-place\",\n\t\t\tSnakeCase:  \"ordinal_numbers_work_1_st_2_nd_and_3_rd_place\",\n\t\t}},\n\t\t{name: name, input: \"BadUTF8\\xe2\\xe2\\xa1\", output: output{\n\t\t\tPascalCase: \"BadUtf8\",\n\t\t\tCamelCase:  \"badUtf8\",\n\t\t\tKebabCase:  \"bad-utf-8\",\n\t\t\tSnakeCase:  \"bad_utf_8\",\n\t\t}},\n\t\t{name: name, input: \"IDENT3\", output: output{\n\t\t\tPascalCase: \"Ident3\",\n\t\t\tCamelCase:  \"ident3\",\n\t\t\tKebabCase:  \"ident-3\",\n\t\t\tSnakeCase:  \"ident_3\",\n\t\t}},\n\t\t{name: name, input: \"LogRouterS3BucketName\", output: output{\n\t\t\tPascalCase: \"LogRouterS3BucketName\",\n\t\t\tCamelCase:  \"logRouterS3BucketName\",\n\t\t\tKebabCase:  \"log-router-s3-bucket-name\",\n\t\t\tSnakeCase:  \"log_router_s3_bucket_name\",\n\t\t}},\n\t\t{name: name, input: \"PINEAPPLE\", output: output{\n\t\t\tPascalCase: \"Pineapple\",\n\t\t\tCamelCase:  \"pineapple\",\n\t\t\tKebabCase:  \"pineapple\",\n\t\t\tSnakeCase:  \"pineapple\",\n\t\t}},\n\t\t{name: name, input: \"Int8Value\", output: output{\n\t\t\tPascalCase: \"Int8Value\",\n\t\t\tCamelCase:  \"int8Value\",\n\t\t\tKebabCase:  \"int-8-value\",\n\t\t\tSnakeCase:  \"int_8_value\",\n\t\t}},\n\t\t{name: name, input: \"first.last\", output: output{\n\t\t\tPascalCase: \"FirstLast\",\n\t\t\tCamelCase:  \"firstLast\",\n\t\t\tKebabCase:  \"first-last\",\n\t\t\tSnakeCase:  \"first_last\",\n\t\t}},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tpascal := PascalCase(test.input)\n\t\t\tif pascal != test.output.PascalCase {\n\t\t\t\tt.Errorf(\"PascalCase(%q) = %q; expected %q\", test.input, pascal, test.output.PascalCase)\n\t\t\t}\n\t\t\tcamel := CamelCase(test.input)\n\t\t\tif camel != test.output.CamelCase {\n\t\t\t\tt.Errorf(\"CamelCase(%q) = %q; expected %q\", test.input, camel, test.output.CamelCase)\n\t\t\t}\n\t\t\tkebab := KebabCase(test.input)\n\t\t\tif kebab != test.output.KebabCase {\n\t\t\t\tt.Errorf(\"KebabCase(%q) = %q; expected %q\", test.input, kebab, test.output.KebabCase)\n\t\t\t}\n\t\t\tsnake := SnakeCase(test.input)\n\t\t\tif snake != test.output.SnakeCase {\n\t\t\t\tt.Errorf(\"SnakeCase(%q) = %q; expected %q\", test.input, snake, test.output.SnakeCase)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWords(t *testing.T) {\n\ttype args struct {\n\t\tstr string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []string\n\t}{\n\t\t{\"\", args{\"PascalCase\"}, []string{\"Pascal\", \"Case\"}},\n\t\t{\"\", args{\"camelCase\"}, []string{\"camel\", \"Case\"}},\n\t\t{\"\", args{\"snake_case\"}, []string{\"snake\", \"case\"}},\n\t\t{\"\", args{\"kebab_case\"}, []string{\"kebab\", \"case\"}},\n\t\t{\"\", args{\"_test text_\"}, []string{\"test\", \"text\"}},\n\t\t{\"\", args{\"UPPERCASE\"}, []string{\"UPPERCASE\"}},\n\t\t{\"\", args{\"HTTPCode\"}, []string{\"HTTP\", \"Code\"}},\n\t\t{\"\", args{\"Int8Value\"}, []string{\"Int\", \"8\", \"Value\"}},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tassert.Equalf(t, tt.want, Words(tt.args.str), \"words(%v)\", tt.args.str)\n\t\t})\n\t}\n}\n\nfunc TestCapitalize(t *testing.T) {\n\ttype args struct {\n\t\tword string\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\"\", args{\"hello\"}, \"Hello\"},\n\t\t{\"\", args{\"heLLO\"}, \"Hello\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tassert.Equalf(t, tt.want, Capitalize(tt.args.word), \"Capitalize(%v)\", tt.args.word)\n\t\t})\n\t}\n}\n\nfunc TestEllipsis(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Equal(\"12345\", Ellipsis(\"12345\", 5))\n\tis.Equal(\"1...\", Ellipsis(\"12345\", 4))\n\tis.Equal(\"1...\", Ellipsis(\"\t12345  \", 4))\n\tis.Equal(\"12345\", Ellipsis(\"12345\", 6))\n\tis.Equal(\"12345\", Ellipsis(\"12345\", 10))\n\tis.Equal(\"12345\", Ellipsis(\"  12345  \", 10))\n\tis.Equal(\"...\", Ellipsis(\"12345\", 3))\n\tis.Equal(\"...\", Ellipsis(\"12345\", 2))\n\tis.Equal(\"...\", Ellipsis(\"12345\", -1))\n\tis.Equal(\"hello...\", Ellipsis(\" hello   world \", 9))\n}\n"
        },
        {
          "name": "time.go",
          "type": "blob",
          "size": 2.7265625,
          "content": "package lo\n\nimport \"time\"\n\n// Duration returns the time taken to execute a function.\nfunc Duration(cb func()) time.Duration {\n\treturn Duration0(cb)\n}\n\n// Duration0 returns the time taken to execute a function.\nfunc Duration0(cb func()) time.Duration {\n\tstart := time.Now()\n\tcb()\n\treturn time.Since(start)\n}\n\n// Duration1 returns the time taken to execute a function.\nfunc Duration1[A any](cb func() A) (A, time.Duration) {\n\tstart := time.Now()\n\ta := cb()\n\treturn a, time.Since(start)\n}\n\n// Duration2 returns the time taken to execute a function.\nfunc Duration2[A, B any](cb func() (A, B)) (A, B, time.Duration) {\n\tstart := time.Now()\n\ta, b := cb()\n\treturn a, b, time.Since(start)\n}\n\n// Duration3 returns the time taken to execute a function.\nfunc Duration3[A, B, C any](cb func() (A, B, C)) (A, B, C, time.Duration) {\n\tstart := time.Now()\n\ta, b, c := cb()\n\treturn a, b, c, time.Since(start)\n}\n\n// Duration4 returns the time taken to execute a function.\nfunc Duration4[A, B, C, D any](cb func() (A, B, C, D)) (A, B, C, D, time.Duration) {\n\tstart := time.Now()\n\ta, b, c, d := cb()\n\treturn a, b, c, d, time.Since(start)\n}\n\n// Duration5 returns the time taken to execute a function.\nfunc Duration5[A, B, C, D, E any](cb func() (A, B, C, D, E)) (A, B, C, D, E, time.Duration) {\n\tstart := time.Now()\n\ta, b, c, d, e := cb()\n\treturn a, b, c, d, e, time.Since(start)\n}\n\n// Duration6 returns the time taken to execute a function.\nfunc Duration6[A, B, C, D, E, F any](cb func() (A, B, C, D, E, F)) (A, B, C, D, E, F, time.Duration) {\n\tstart := time.Now()\n\ta, b, c, d, e, f := cb()\n\treturn a, b, c, d, e, f, time.Since(start)\n}\n\n// Duration7 returns the time taken to execute a function.\nfunc Duration7[A, B, C, D, E, F, G any](cb func() (A, B, C, D, E, F, G)) (A, B, C, D, E, F, G, time.Duration) {\n\tstart := time.Now()\n\ta, b, c, d, e, f, g := cb()\n\treturn a, b, c, d, e, f, g, time.Since(start)\n}\n\n// Duration8 returns the time taken to execute a function.\nfunc Duration8[A, B, C, D, E, F, G, H any](cb func() (A, B, C, D, E, F, G, H)) (A, B, C, D, E, F, G, H, time.Duration) {\n\tstart := time.Now()\n\ta, b, c, d, e, f, g, h := cb()\n\treturn a, b, c, d, e, f, g, h, time.Since(start)\n}\n\n// Duration9 returns the time taken to execute a function.\nfunc Duration9[A, B, C, D, E, F, G, H, I any](cb func() (A, B, C, D, E, F, G, H, I)) (A, B, C, D, E, F, G, H, I, time.Duration) {\n\tstart := time.Now()\n\ta, b, c, d, e, f, g, h, i := cb()\n\treturn a, b, c, d, e, f, g, h, i, time.Since(start)\n}\n\n// Duration10 returns the time taken to execute a function.\nfunc Duration10[A, B, C, D, E, F, G, H, I, J any](cb func() (A, B, C, D, E, F, G, H, I, J)) (A, B, C, D, E, F, G, H, I, J, time.Duration) {\n\tstart := time.Now()\n\ta, b, c, d, e, f, g, h, i, j := cb()\n\treturn a, b, c, d, e, f, g, h, i, j, time.Since(start)\n}\n"
        },
        {
          "name": "time_test.go",
          "type": "blob",
          "size": 3.9443359375,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDuration(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult := Duration(func() { time.Sleep(10 * time.Millisecond) })\n\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n}\n\nfunc TestDurationX(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t{\n\t\tresult := Duration0(func() { time.Sleep(10 * time.Millisecond) })\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t}\n\n\t{\n\t\ta, result := Duration1(func() string { time.Sleep(10 * time.Millisecond); return \"a\" })\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t}\n\n\t{\n\t\ta, b, result := Duration2(func() (string, string) { time.Sleep(10 * time.Millisecond); return \"a\", \"b\" })\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t}\n\n\t{\n\t\ta, b, c, result := Duration3(func() (string, string, string) { time.Sleep(10 * time.Millisecond); return \"a\", \"b\", \"c\" })\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t}\n\n\t{\n\t\ta, b, c, d, result := Duration4(func() (string, string, string, string) { time.Sleep(10 * time.Millisecond); return \"a\", \"b\", \"c\", \"d\" })\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t\tis.Equal(\"d\", d)\n\t}\n\n\t{\n\t\ta, b, c, d, e, result := Duration5(func() (string, string, string, string, string) {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\treturn \"a\", \"b\", \"c\", \"d\", \"e\"\n\t\t})\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t\tis.Equal(\"d\", d)\n\t\tis.Equal(\"e\", e)\n\t}\n\n\t{\n\t\ta, b, c, d, e, f, result := Duration6(func() (string, string, string, string, string, string) {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\treturn \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"\n\t\t})\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t\tis.Equal(\"d\", d)\n\t\tis.Equal(\"e\", e)\n\t\tis.Equal(\"f\", f)\n\t}\n\n\t{\n\t\ta, b, c, d, e, f, g, result := Duration7(func() (string, string, string, string, string, string, string) {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\treturn \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n\t\t})\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t\tis.Equal(\"d\", d)\n\t\tis.Equal(\"e\", e)\n\t\tis.Equal(\"f\", f)\n\t\tis.Equal(\"g\", g)\n\t}\n\n\t{\n\t\ta, b, c, d, e, f, g, h, result := Duration8(func() (string, string, string, string, string, string, string, string) {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\treturn \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"\n\t\t})\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t\tis.Equal(\"d\", d)\n\t\tis.Equal(\"e\", e)\n\t\tis.Equal(\"f\", f)\n\t\tis.Equal(\"g\", g)\n\t\tis.Equal(\"h\", h)\n\t}\n\n\t{\n\t\ta, b, c, d, e, f, g, h, i, result := Duration9(func() (string, string, string, string, string, string, string, string, string) {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\treturn \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"\n\t\t})\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t\tis.Equal(\"d\", d)\n\t\tis.Equal(\"e\", e)\n\t\tis.Equal(\"f\", f)\n\t\tis.Equal(\"g\", g)\n\t\tis.Equal(\"h\", h)\n\t\tis.Equal(\"i\", i)\n\t}\n\n\t{\n\t\ta, b, c, d, e, f, g, h, i, j, result := Duration10(func() (string, string, string, string, string, string, string, string, string, string) {\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\treturn \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"\n\t\t})\n\t\tis.InEpsilon(10*time.Millisecond, result, float64(2*time.Millisecond))\n\t\tis.Equal(\"a\", a)\n\t\tis.Equal(\"b\", b)\n\t\tis.Equal(\"c\", c)\n\t\tis.Equal(\"d\", d)\n\t\tis.Equal(\"e\", e)\n\t\tis.Equal(\"f\", f)\n\t\tis.Equal(\"g\", g)\n\t\tis.Equal(\"h\", h)\n\t\tis.Equal(\"i\", i)\n\t\tis.Equal(\"j\", j)\n\t}\n}\n"
        },
        {
          "name": "tuples.go",
          "type": "blob",
          "size": 26.8662109375,
          "content": "package lo\n\n// T2 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T2[A, B any](a A, b B) Tuple2[A, B] {\n\treturn Tuple2[A, B]{A: a, B: b}\n}\n\n// T3 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T3[A, B, C any](a A, b B, c C) Tuple3[A, B, C] {\n\treturn Tuple3[A, B, C]{A: a, B: b, C: c}\n}\n\n// T4 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T4[A, B, C, D any](a A, b B, c C, d D) Tuple4[A, B, C, D] {\n\treturn Tuple4[A, B, C, D]{A: a, B: b, C: c, D: d}\n}\n\n// T5 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T5[A, B, C, D, E any](a A, b B, c C, d D, e E) Tuple5[A, B, C, D, E] {\n\treturn Tuple5[A, B, C, D, E]{A: a, B: b, C: c, D: d, E: e}\n}\n\n// T6 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T6[A, B, C, D, E, F any](a A, b B, c C, d D, e E, f F) Tuple6[A, B, C, D, E, F] {\n\treturn Tuple6[A, B, C, D, E, F]{A: a, B: b, C: c, D: d, E: e, F: f}\n}\n\n// T7 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T7[A, B, C, D, E, F, G any](a A, b B, c C, d D, e E, f F, g G) Tuple7[A, B, C, D, E, F, G] {\n\treturn Tuple7[A, B, C, D, E, F, G]{A: a, B: b, C: c, D: d, E: e, F: f, G: g}\n}\n\n// T8 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T8[A, B, C, D, E, F, G, H any](a A, b B, c C, d D, e E, f F, g G, h H) Tuple8[A, B, C, D, E, F, G, H] {\n\treturn Tuple8[A, B, C, D, E, F, G, H]{A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h}\n}\n\n// T9 creates a tuple from a list of values.\n// Play: https://go.dev/play/p/IllL3ZO4BQm\nfunc T9[A, B, C, D, E, F, G, H, I any](a A, b B, c C, d D, e E, f F, g G, h H, i I) Tuple9[A, B, C, D, E, F, G, H, I] {\n\treturn Tuple9[A, B, C, D, E, F, G, H, I]{A: a, B: b, C: c, D: d, E: e, F: f, G: g, H: h, I: i}\n}\n\n// Unpack2 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack2[A, B any](tuple Tuple2[A, B]) (A, B) {\n\treturn tuple.A, tuple.B\n}\n\n// Unpack3 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack3[A, B, C any](tuple Tuple3[A, B, C]) (A, B, C) {\n\treturn tuple.A, tuple.B, tuple.C\n}\n\n// Unpack4 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack4[A, B, C, D any](tuple Tuple4[A, B, C, D]) (A, B, C, D) {\n\treturn tuple.A, tuple.B, tuple.C, tuple.D\n}\n\n// Unpack5 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack5[A, B, C, D, E any](tuple Tuple5[A, B, C, D, E]) (A, B, C, D, E) {\n\treturn tuple.A, tuple.B, tuple.C, tuple.D, tuple.E\n}\n\n// Unpack6 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack6[A, B, C, D, E, F any](tuple Tuple6[A, B, C, D, E, F]) (A, B, C, D, E, F) {\n\treturn tuple.A, tuple.B, tuple.C, tuple.D, tuple.E, tuple.F\n}\n\n// Unpack7 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack7[A, B, C, D, E, F, G any](tuple Tuple7[A, B, C, D, E, F, G]) (A, B, C, D, E, F, G) {\n\treturn tuple.A, tuple.B, tuple.C, tuple.D, tuple.E, tuple.F, tuple.G\n}\n\n// Unpack8 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack8[A, B, C, D, E, F, G, H any](tuple Tuple8[A, B, C, D, E, F, G, H]) (A, B, C, D, E, F, G, H) {\n\treturn tuple.A, tuple.B, tuple.C, tuple.D, tuple.E, tuple.F, tuple.G, tuple.H\n}\n\n// Unpack9 returns values contained in tuple.\n// Play: https://go.dev/play/p/xVP_k0kJ96W\nfunc Unpack9[A, B, C, D, E, F, G, H, I any](tuple Tuple9[A, B, C, D, E, F, G, H, I]) (A, B, C, D, E, F, G, H, I) {\n\treturn tuple.A, tuple.B, tuple.C, tuple.D, tuple.E, tuple.F, tuple.G, tuple.H, tuple.I\n}\n\n// Zip2 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip2[A, B any](a []A, b []B) []Tuple2[A, B] {\n\tsize := Max([]int{len(a), len(b)})\n\n\tresult := make([]Tuple2[A, B], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\n\t\tresult = append(result, Tuple2[A, B]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// Zip3 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip3[A, B, C any](a []A, b []B, c []C) []Tuple3[A, B, C] {\n\tsize := Max([]int{len(a), len(b), len(c)})\n\n\tresult := make([]Tuple3[A, B, C], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\n\t\tresult = append(result, Tuple3[A, B, C]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t\tC: _c,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// Zip4 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip4[A, B, C, D any](a []A, b []B, c []C, d []D) []Tuple4[A, B, C, D] {\n\tsize := Max([]int{len(a), len(b), len(c), len(d)})\n\n\tresult := make([]Tuple4[A, B, C, D], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\n\t\tresult = append(result, Tuple4[A, B, C, D]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t\tC: _c,\n\t\t\tD: _d,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// Zip5 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip5[A, B, C, D, E any](a []A, b []B, c []C, d []D, e []E) []Tuple5[A, B, C, D, E] {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e)})\n\n\tresult := make([]Tuple5[A, B, C, D, E], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\n\t\tresult = append(result, Tuple5[A, B, C, D, E]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t\tC: _c,\n\t\t\tD: _d,\n\t\t\tE: _e,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// Zip6 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip6[A, B, C, D, E, F any](a []A, b []B, c []C, d []D, e []E, f []F) []Tuple6[A, B, C, D, E, F] {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f)})\n\n\tresult := make([]Tuple6[A, B, C, D, E, F], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\n\t\tresult = append(result, Tuple6[A, B, C, D, E, F]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t\tC: _c,\n\t\t\tD: _d,\n\t\t\tE: _e,\n\t\t\tF: _f,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// Zip7 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip7[A, B, C, D, E, F, G any](a []A, b []B, c []C, d []D, e []E, f []F, g []G) []Tuple7[A, B, C, D, E, F, G] {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f), len(g)})\n\n\tresult := make([]Tuple7[A, B, C, D, E, F, G], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\t\t_g, _ := Nth(g, index)\n\n\t\tresult = append(result, Tuple7[A, B, C, D, E, F, G]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t\tC: _c,\n\t\t\tD: _d,\n\t\t\tE: _e,\n\t\t\tF: _f,\n\t\t\tG: _g,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// Zip8 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip8[A, B, C, D, E, F, G, H any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H) []Tuple8[A, B, C, D, E, F, G, H] {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h)})\n\n\tresult := make([]Tuple8[A, B, C, D, E, F, G, H], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\t\t_g, _ := Nth(g, index)\n\t\t_h, _ := Nth(h, index)\n\n\t\tresult = append(result, Tuple8[A, B, C, D, E, F, G, H]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t\tC: _c,\n\t\t\tD: _d,\n\t\t\tE: _e,\n\t\t\tF: _f,\n\t\t\tG: _g,\n\t\t\tH: _h,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// Zip9 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nfunc Zip9[A, B, C, D, E, F, G, H, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []Tuple9[A, B, C, D, E, F, G, H, I] {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i)})\n\n\tresult := make([]Tuple9[A, B, C, D, E, F, G, H, I], 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\t\t_g, _ := Nth(g, index)\n\t\t_h, _ := Nth(h, index)\n\t\t_i, _ := Nth(i, index)\n\n\t\tresult = append(result, Tuple9[A, B, C, D, E, F, G, H, I]{\n\t\t\tA: _a,\n\t\t\tB: _b,\n\t\t\tC: _c,\n\t\t\tD: _d,\n\t\t\tE: _e,\n\t\t\tF: _f,\n\t\t\tG: _g,\n\t\t\tH: _h,\n\t\t\tI: _i,\n\t\t})\n\t}\n\n\treturn result\n}\n\n// ZipBy2 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy2[A any, B any, Out any](a []A, b []B, iteratee func(a A, b B) Out) []Out {\n\tsize := Max([]int{len(a), len(b)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\n\t\tresult = append(result, iteratee(_a, _b))\n\t}\n\n\treturn result\n}\n\n// ZipBy3 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy3[A any, B any, C any, Out any](a []A, b []B, c []C, iteratee func(a A, b B, c C) Out) []Out {\n\tsize := Max([]int{len(a), len(b), len(c)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\n\t\tresult = append(result, iteratee(_a, _b, _c))\n\t}\n\n\treturn result\n}\n\n// ZipBy4 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy4[A any, B any, C any, D any, Out any](a []A, b []B, c []C, d []D, iteratee func(a A, b B, c C, d D) Out) []Out {\n\tsize := Max([]int{len(a), len(b), len(c), len(d)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\n\t\tresult = append(result, iteratee(_a, _b, _c, _d))\n\t}\n\n\treturn result\n}\n\n// ZipBy5 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy5[A any, B any, C any, D any, E any, Out any](a []A, b []B, c []C, d []D, e []E, iteratee func(a A, b B, c C, d D, e E) Out) []Out {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\n\t\tresult = append(result, iteratee(_a, _b, _c, _d, _e))\n\t}\n\n\treturn result\n}\n\n// ZipBy6 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy6[A any, B any, C any, D any, E any, F any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, iteratee func(a A, b B, c C, d D, e E, f F) Out) []Out {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\n\t\tresult = append(result, iteratee(_a, _b, _c, _d, _e, _f))\n\t}\n\n\treturn result\n}\n\n// ZipBy7 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy7[A any, B any, C any, D any, E any, F any, G any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, iteratee func(a A, b B, c C, d D, e E, f F, g G) Out) []Out {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\t\t_g, _ := Nth(g, index)\n\n\t\tresult = append(result, iteratee(_a, _b, _c, _d, _e, _f, _g))\n\t}\n\n\treturn result\n}\n\n// ZipBy8 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy8[A any, B any, C any, D any, E any, F any, G any, H any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H) Out) []Out {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f), len(g)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\t\t_g, _ := Nth(g, index)\n\t\t_h, _ := Nth(h, index)\n\n\t\tresult = append(result, iteratee(_a, _b, _c, _d, _e, _f, _g, _h))\n\t}\n\n\treturn result\n}\n\n// ZipBy9 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nfunc ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n\tsize := Max([]int{len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i)})\n\n\tresult := make([]Out, 0, size)\n\n\tfor index := 0; index < size; index++ {\n\t\t_a, _ := Nth(a, index)\n\t\t_b, _ := Nth(b, index)\n\t\t_c, _ := Nth(c, index)\n\t\t_d, _ := Nth(d, index)\n\t\t_e, _ := Nth(e, index)\n\t\t_f, _ := Nth(f, index)\n\t\t_g, _ := Nth(g, index)\n\t\t_h, _ := Nth(h, index)\n\t\t_i, _ := Nth(i, index)\n\n\t\tresult = append(result, iteratee(_a, _b, _c, _d, _e, _f, _g, _h, _i))\n\t}\n\n\treturn result\n}\n\n// Unzip2 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip2[A, B any](tuples []Tuple2[A, B]) ([]A, []B) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t}\n\n\treturn r1, r2\n}\n\n// Unzip3 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip3[A, B, C any](tuples []Tuple3[A, B, C]) ([]A, []B, []C) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t\tr3 = append(r3, tuples[i].C)\n\t}\n\n\treturn r1, r2, r3\n}\n\n// Unzip4 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip4[A, B, C, D any](tuples []Tuple4[A, B, C, D]) ([]A, []B, []C, []D) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t\tr3 = append(r3, tuples[i].C)\n\t\tr4 = append(r4, tuples[i].D)\n\t}\n\n\treturn r1, r2, r3, r4\n}\n\n// Unzip5 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip5[A, B, C, D, E any](tuples []Tuple5[A, B, C, D, E]) ([]A, []B, []C, []D, []E) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t\tr3 = append(r3, tuples[i].C)\n\t\tr4 = append(r4, tuples[i].D)\n\t\tr5 = append(r5, tuples[i].E)\n\t}\n\n\treturn r1, r2, r3, r4, r5\n}\n\n// Unzip6 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip6[A, B, C, D, E, F any](tuples []Tuple6[A, B, C, D, E, F]) ([]A, []B, []C, []D, []E, []F) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t\tr3 = append(r3, tuples[i].C)\n\t\tr4 = append(r4, tuples[i].D)\n\t\tr5 = append(r5, tuples[i].E)\n\t\tr6 = append(r6, tuples[i].F)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6\n}\n\n// Unzip7 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip7[A, B, C, D, E, F, G any](tuples []Tuple7[A, B, C, D, E, F, G]) ([]A, []B, []C, []D, []E, []F, []G) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\tr7 := make([]G, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t\tr3 = append(r3, tuples[i].C)\n\t\tr4 = append(r4, tuples[i].D)\n\t\tr5 = append(r5, tuples[i].E)\n\t\tr6 = append(r6, tuples[i].F)\n\t\tr7 = append(r7, tuples[i].G)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6, r7\n}\n\n// Unzip8 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip8[A, B, C, D, E, F, G, H any](tuples []Tuple8[A, B, C, D, E, F, G, H]) ([]A, []B, []C, []D, []E, []F, []G, []H) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\tr7 := make([]G, 0, size)\n\tr8 := make([]H, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t\tr3 = append(r3, tuples[i].C)\n\t\tr4 = append(r4, tuples[i].D)\n\t\tr5 = append(r5, tuples[i].E)\n\t\tr6 = append(r6, tuples[i].F)\n\t\tr7 = append(r7, tuples[i].G)\n\t\tr8 = append(r8, tuples[i].H)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6, r7, r8\n}\n\n// Unzip9 accepts an array of grouped elements and creates an array regrouping the elements\n// to their pre-zip configuration.\n// Play: https://go.dev/play/p/ciHugugvaAW\nfunc Unzip9[A, B, C, D, E, F, G, H, I any](tuples []Tuple9[A, B, C, D, E, F, G, H, I]) ([]A, []B, []C, []D, []E, []F, []G, []H, []I) {\n\tsize := len(tuples)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\tr7 := make([]G, 0, size)\n\tr8 := make([]H, 0, size)\n\tr9 := make([]I, 0, size)\n\n\tfor i := range tuples {\n\t\tr1 = append(r1, tuples[i].A)\n\t\tr2 = append(r2, tuples[i].B)\n\t\tr3 = append(r3, tuples[i].C)\n\t\tr4 = append(r4, tuples[i].D)\n\t\tr5 = append(r5, tuples[i].E)\n\t\tr6 = append(r6, tuples[i].F)\n\t\tr7 = append(r7, tuples[i].G)\n\t\tr8 = append(r8, tuples[i].H)\n\t\tr9 = append(r9, tuples[i].I)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6, r7, r8, r9\n}\n\n// UnzipBy2 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy2[In any, A any, B any](items []In, iteratee func(In) (a A, b B)) ([]A, []B) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\n\tfor i := range items {\n\t\ta, b := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t}\n\n\treturn r1, r2\n}\n\n// UnzipBy3 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy3[In any, A any, B any, C any](items []In, iteratee func(In) (a A, b B, c C)) ([]A, []B, []C) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\n\tfor i := range items {\n\t\ta, b, c := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t\tr3 = append(r3, c)\n\t}\n\n\treturn r1, r2, r3\n}\n\n// UnzipBy4 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy4[In any, A any, B any, C any, D any](items []In, iteratee func(In) (a A, b B, c C, d D)) ([]A, []B, []C, []D) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\n\tfor i := range items {\n\t\ta, b, c, d := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t\tr3 = append(r3, c)\n\t\tr4 = append(r4, d)\n\t}\n\n\treturn r1, r2, r3, r4\n}\n\n// UnzipBy5 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy5[In any, A any, B any, C any, D any, E any](items []In, iteratee func(In) (a A, b B, c C, d D, e E)) ([]A, []B, []C, []D, []E) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\n\tfor i := range items {\n\t\ta, b, c, d, e := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t\tr3 = append(r3, c)\n\t\tr4 = append(r4, d)\n\t\tr5 = append(r5, e)\n\t}\n\n\treturn r1, r2, r3, r4, r5\n}\n\n// UnzipBy6 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy6[In any, A any, B any, C any, D any, E any, F any](items []In, iteratee func(In) (a A, b B, c C, d D, e E, f F)) ([]A, []B, []C, []D, []E, []F) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\n\tfor i := range items {\n\t\ta, b, c, d, e, f := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t\tr3 = append(r3, c)\n\t\tr4 = append(r4, d)\n\t\tr5 = append(r5, e)\n\t\tr6 = append(r6, f)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6\n}\n\n// UnzipBy7 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy7[In any, A any, B any, C any, D any, E any, F any, G any](items []In, iteratee func(In) (a A, b B, c C, d D, e E, f F, g G)) ([]A, []B, []C, []D, []E, []F, []G) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\tr7 := make([]G, 0, size)\n\n\tfor i := range items {\n\t\ta, b, c, d, e, f, g := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t\tr3 = append(r3, c)\n\t\tr4 = append(r4, d)\n\t\tr5 = append(r5, e)\n\t\tr6 = append(r6, f)\n\t\tr7 = append(r7, g)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6, r7\n}\n\n// UnzipBy8 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy8[In any, A any, B any, C any, D any, E any, F any, G any, H any](items []In, iteratee func(In) (a A, b B, c C, d D, e E, f F, g G, h H)) ([]A, []B, []C, []D, []E, []F, []G, []H) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\tr7 := make([]G, 0, size)\n\tr8 := make([]H, 0, size)\n\n\tfor i := range items {\n\t\ta, b, c, d, e, f, g, h := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t\tr3 = append(r3, c)\n\t\tr4 = append(r4, d)\n\t\tr5 = append(r5, e)\n\t\tr6 = append(r6, f)\n\t\tr7 = append(r7, g)\n\t\tr8 = append(r8, h)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6, r7, r8\n}\n\n// UnzipBy9 iterates over a collection and creates an array regrouping the elements\n// to their pre-zip configuration.\nfunc UnzipBy9[In any, A any, B any, C any, D any, E any, F any, G any, H any, I any](items []In, iteratee func(In) (a A, b B, c C, d D, e E, f F, g G, h H, i I)) ([]A, []B, []C, []D, []E, []F, []G, []H, []I) {\n\tsize := len(items)\n\tr1 := make([]A, 0, size)\n\tr2 := make([]B, 0, size)\n\tr3 := make([]C, 0, size)\n\tr4 := make([]D, 0, size)\n\tr5 := make([]E, 0, size)\n\tr6 := make([]F, 0, size)\n\tr7 := make([]G, 0, size)\n\tr8 := make([]H, 0, size)\n\tr9 := make([]I, 0, size)\n\n\tfor i := range items {\n\t\ta, b, c, d, e, f, g, h, i := iteratee(items[i])\n\t\tr1 = append(r1, a)\n\t\tr2 = append(r2, b)\n\t\tr3 = append(r3, c)\n\t\tr4 = append(r4, d)\n\t\tr5 = append(r5, e)\n\t\tr6 = append(r6, f)\n\t\tr7 = append(r7, g)\n\t\tr8 = append(r8, h)\n\t\tr9 = append(r9, i)\n\t}\n\n\treturn r1, r2, r3, r4, r5, r6, r7, r8, r9\n}\n"
        },
        {
          "name": "tuples_example_test.go",
          "type": "blob",
          "size": 6.509765625,
          "content": "package lo\n\nimport (\n\t\"fmt\"\n)\n\nfunc ExampleT2() {\n\tresult := T2(\"hello\", 2)\n\tfmt.Printf(\"%v %v\", result.A, result.B)\n\t// Output: hello 2\n}\n\nfunc ExampleT3() {\n\tresult := T3(\"hello\", 2, true)\n\tfmt.Printf(\"%v %v %v\", result.A, result.B, result.C)\n\t// Output: hello 2 true\n}\n\nfunc ExampleT4() {\n\tresult := T4(\"hello\", 2, true, foo{bar: \"bar\"})\n\tfmt.Printf(\"%v %v %v %v\", result.A, result.B, result.C, result.D)\n\t// Output: hello 2 true {bar}\n}\n\nfunc ExampleT5() {\n\tresult := T5(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2)\n\tfmt.Printf(\"%v %v %v %v %v\", result.A, result.B, result.C, result.D, result.E)\n\t// Output: hello 2 true {bar} 4.2\n}\n\nfunc ExampleT6() {\n\tresult := T6(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\")\n\tfmt.Printf(\"%v %v %v %v %v %v\", result.A, result.B, result.C, result.D, result.E, result.F)\n\t// Output: hello 2 true {bar} 4.2 plop\n}\n\nfunc ExampleT7() {\n\tresult := T7(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false)\n\tfmt.Printf(\"%v %v %v %v %v %v %v\", result.A, result.B, result.C, result.D, result.E, result.F, result.G)\n\t// Output: hello 2 true {bar} 4.2 plop false\n}\n\nfunc ExampleT8() {\n\tresult := T8(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false, 42)\n\tfmt.Printf(\"%v %v %v %v %v %v %v %v\", result.A, result.B, result.C, result.D, result.E, result.F, result.G, result.H)\n\t// Output: hello 2 true {bar} 4.2 plop false 42\n}\n\nfunc ExampleT9() {\n\tresult := T9(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false, 42, \"hello world\")\n\tfmt.Printf(\"%v %v %v %v %v %v %v %v %v\", result.A, result.B, result.C, result.D, result.E, result.F, result.G, result.H, result.I)\n\t// Output: hello 2 true {bar} 4.2 plop false 42 hello world\n}\n\nfunc ExampleUnpack2() {\n\ta, b := Unpack2(T2(\"hello\", 2))\n\tfmt.Printf(\"%v %v\", a, b)\n\t// Output: hello 2\n}\n\nfunc ExampleUnpack3() {\n\ta, b, c := Unpack3(T3(\"hello\", 2, true))\n\tfmt.Printf(\"%v %v %v\", a, b, c)\n\t// Output: hello 2 true\n}\n\nfunc ExampleUnpack4() {\n\ta, b, c, d := Unpack4(T4(\"hello\", 2, true, foo{bar: \"bar\"}))\n\tfmt.Printf(\"%v %v %v %v\", a, b, c, d)\n\t// Output: hello 2 true {bar}\n}\n\nfunc ExampleUnpack5() {\n\ta, b, c, d, e := Unpack5(T5(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2))\n\tfmt.Printf(\"%v %v %v %v %v\", a, b, c, d, e)\n\t// Output: hello 2 true {bar} 4.2\n}\n\nfunc ExampleUnpack6() {\n\ta, b, c, d, e, f := Unpack6(T6(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\"))\n\tfmt.Printf(\"%v %v %v %v %v %v\", a, b, c, d, e, f)\n\t// Output: hello 2 true {bar} 4.2 plop\n}\n\nfunc ExampleUnpack7() {\n\ta, b, c, d, e, f, g := Unpack7(T7(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false))\n\tfmt.Printf(\"%v %v %v %v %v %v %v\", a, b, c, d, e, f, g)\n\t// Output: hello 2 true {bar} 4.2 plop false\n}\n\nfunc ExampleUnpack8() {\n\ta, b, c, d, e, f, g, h := Unpack8(T8(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false, 42))\n\tfmt.Printf(\"%v %v %v %v %v %v %v %v\", a, b, c, d, e, f, g, h)\n\t// Output: hello 2 true {bar} 4.2 plop false 42\n}\n\nfunc ExampleUnpack9() {\n\ta, b, c, d, e, f, g, h, i := Unpack9(T9(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false, 42, \"hello world\"))\n\tfmt.Printf(\"%v %v %v %v %v %v %v %v %v\", a, b, c, d, e, f, g, h, i)\n\t// Output: hello 2 true {bar} 4.2 plop false 42 hello world\n}\n\nfunc ExampleZip2() {\n\tresult := Zip2([]string{\"hello\"}, []int{2})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2}]\n}\n\nfunc ExampleZip3() {\n\tresult := Zip3([]string{\"hello\"}, []int{2}, []bool{true})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2 true}]\n}\n\nfunc ExampleZip4() {\n\tresult := Zip4([]string{\"hello\"}, []int{2}, []bool{true}, []foo{{bar: \"bar\"}})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2 true {bar}}]\n}\n\nfunc ExampleZip5() {\n\tresult := Zip5([]string{\"hello\"}, []int{2}, []bool{true}, []foo{{bar: \"bar\"}}, []float64{4.2})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2 true {bar} 4.2}]\n}\n\nfunc ExampleZip6() {\n\tresult := Zip6([]string{\"hello\"}, []int{2}, []bool{true}, []foo{{bar: \"bar\"}}, []float64{4.2}, []string{\"plop\"})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2 true {bar} 4.2 plop}]\n}\n\nfunc ExampleZip7() {\n\tresult := Zip7([]string{\"hello\"}, []int{2}, []bool{true}, []foo{{bar: \"bar\"}}, []float64{4.2}, []string{\"plop\"}, []bool{false})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2 true {bar} 4.2 plop false}]\n}\n\nfunc ExampleZip8() {\n\tresult := Zip8([]string{\"hello\"}, []int{2}, []bool{true}, []foo{{bar: \"bar\"}}, []float64{4.2}, []string{\"plop\"}, []bool{false}, []int{42})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2 true {bar} 4.2 plop false 42}]\n}\n\nfunc ExampleZip9() {\n\tresult := Zip9([]string{\"hello\"}, []int{2}, []bool{true}, []foo{{bar: \"bar\"}}, []float64{4.2}, []string{\"plop\"}, []bool{false}, []int{42}, []string{\"hello world\"})\n\tfmt.Printf(\"%v\", result)\n\t// Output: [{hello 2 true {bar} 4.2 plop false 42 hello world}]\n}\n\nfunc ExampleUnzip2() {\n\ta, b := Unzip2([]Tuple2[string, int]{T2(\"hello\", 2)})\n\tfmt.Printf(\"%v %v\", a, b)\n\t// Output: [hello] [2]\n}\n\nfunc ExampleUnzip3() {\n\ta, b, c := Unzip3([]Tuple3[string, int, bool]{T3(\"hello\", 2, true)})\n\tfmt.Printf(\"%v %v %v\", a, b, c)\n\t// Output: [hello] [2] [true]\n}\n\nfunc ExampleUnzip4() {\n\ta, b, c, d := Unzip4([]Tuple4[string, int, bool, foo]{T4(\"hello\", 2, true, foo{bar: \"bar\"})})\n\tfmt.Printf(\"%v %v %v %v\", a, b, c, d)\n\t// Output: [hello] [2] [true] [{bar}]\n}\n\nfunc ExampleUnzip5() {\n\ta, b, c, d, e := Unzip5([]Tuple5[string, int, bool, foo, float64]{T5(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2)})\n\tfmt.Printf(\"%v %v %v %v %v\", a, b, c, d, e)\n\t// Output: [hello] [2] [true] [{bar}] [4.2]\n}\n\nfunc ExampleUnzip6() {\n\ta, b, c, d, e, f := Unzip6([]Tuple6[string, int, bool, foo, float64, string]{T6(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\")})\n\tfmt.Printf(\"%v %v %v %v %v %v\", a, b, c, d, e, f)\n\t// Output: [hello] [2] [true] [{bar}] [4.2] [plop]\n}\n\nfunc ExampleUnzip7() {\n\ta, b, c, d, e, f, g := Unzip7([]Tuple7[string, int, bool, foo, float64, string, bool]{T7(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false)})\n\tfmt.Printf(\"%v %v %v %v %v %v %v\", a, b, c, d, e, f, g)\n\t// Output: [hello] [2] [true] [{bar}] [4.2] [plop] [false]\n}\n\nfunc ExampleUnzip8() {\n\ta, b, c, d, e, f, g, h := Unzip8([]Tuple8[string, int, bool, foo, float64, string, bool, int]{T8(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false, 42)})\n\tfmt.Printf(\"%v %v %v %v %v %v %v %v\", a, b, c, d, e, f, g, h)\n\t// Output: [hello] [2] [true] [{bar}] [4.2] [plop] [false] [42]\n}\n\nfunc ExampleUnzip9() {\n\ta, b, c, d, e, f, g, h, i := Unzip9([]Tuple9[string, int, bool, foo, float64, string, bool, int, string]{T9(\"hello\", 2, true, foo{bar: \"bar\"}, 4.2, \"plop\", false, 42, \"hello world\")})\n\tfmt.Printf(\"%v %v %v %v %v %v %v %v %v\", a, b, c, d, e, f, g, h, i)\n\t// Output: [hello] [2] [true] [{bar}] [4.2] [plop] [false] [42] [hello world]\n}\n"
        },
        {
          "name": "tuples_test.go",
          "type": "blob",
          "size": 15.263671875,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestT(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := T2(\"a\", 1)\n\tr2 := T3[string, int, float32](\"b\", 2, 3.0)\n\tr3 := T4[string, int, float32](\"c\", 3, 4.0, true)\n\tr4 := T5[string, int, float32](\"d\", 4, 5.0, false, \"e\")\n\tr5 := T6[string, int, float32](\"f\", 5, 6.0, true, \"g\", 7)\n\tr6 := T7[string, int, float32](\"h\", 6, 7.0, false, \"i\", 8, 9.0)\n\tr7 := T8[string, int, float32](\"j\", 7, 8.0, true, \"k\", 9, 10.0, false)\n\tr8 := T9[string, int, float32](\"l\", 8, 9.0, false, \"m\", 10, 11.0, true, \"n\")\n\n\tis.Equal(r1, Tuple2[string, int]{A: \"a\", B: 1})\n\tis.Equal(r2, Tuple3[string, int, float32]{A: \"b\", B: 2, C: 3.0})\n\tis.Equal(r3, Tuple4[string, int, float32, bool]{A: \"c\", B: 3, C: 4.0, D: true})\n\tis.Equal(r4, Tuple5[string, int, float32, bool, string]{A: \"d\", B: 4, C: 5.0, D: false, E: \"e\"})\n\tis.Equal(r5, Tuple6[string, int, float32, bool, string, int]{A: \"f\", B: 5, C: 6.0, D: true, E: \"g\", F: 7})\n\tis.Equal(r6, Tuple7[string, int, float32, bool, string, int, float64]{A: \"h\", B: 6, C: 7.0, D: false, E: \"i\", F: 8, G: 9.0})\n\tis.Equal(r7, Tuple8[string, int, float32, bool, string, int, float64, bool]{A: \"j\", B: 7, C: 8.0, D: true, E: \"k\", F: 9, G: 10.0, H: false})\n\tis.Equal(r8, Tuple9[string, int, float32, bool, string, int, float64, bool, string]{A: \"l\", B: 8, C: 9.0, D: false, E: \"m\", F: 10, G: 11.0, H: true, I: \"n\"})\n}\n\nfunc TestUnpack(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t{\n\t\ttuple := Tuple2[string, int]{\"a\", 1}\n\n\t\tr1, r2 := Unpack2(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\n\t\tr1, r2 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t}\n\n\t{\n\t\ttuple := Tuple3[string, int, float64]{\"a\", 1, 1.0}\n\n\t\tr1, r2, r3 := Unpack3(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\n\t\tr1, r2, r3 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t}\n\n\t{\n\t\ttuple := Tuple4[string, int, float64, bool]{\"a\", 1, 1.0, true}\n\n\t\tr1, r2, r3, r4 := Unpack4(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\n\t\tr1, r2, r3, r4 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t}\n\n\t{\n\t\ttuple := Tuple5[string, int, float64, bool, string]{\"a\", 1, 1.0, true, \"b\"}\n\n\t\tr1, r2, r3, r4, r5 := Unpack5(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\n\t\tr1, r2, r3, r4, r5 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t}\n\n\t{\n\t\ttuple := Tuple6[string, int, float64, bool, string, int]{\"a\", 1, 1.0, true, \"b\", 2}\n\n\t\tr1, r2, r3, r4, r5, r6 := Unpack6(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\n\t\tr1, r2, r3, r4, r5, r6 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\t}\n\n\t{\n\t\ttuple := Tuple7[string, int, float64, bool, string, int, float64]{\"a\", 1, 1.0, true, \"b\", 2, 3.0}\n\n\t\tr1, r2, r3, r4, r5, r6, r7 := Unpack7(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\t\tis.Equal(3.0, r7)\n\n\t\tr1, r2, r3, r4, r5, r6, r7 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\t\tis.Equal(3.0, r7)\n\t}\n\n\t{\n\t\ttuple := Tuple8[string, int, float64, bool, string, int, float64, bool]{\"a\", 1, 1.0, true, \"b\", 2, 3.0, true}\n\n\t\tr1, r2, r3, r4, r5, r6, r7, r8 := Unpack8(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\t\tis.Equal(3.0, r7)\n\t\tis.Equal(true, r8)\n\n\t\tr1, r2, r3, r4, r5, r6, r7, r8 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\t\tis.Equal(3.0, r7)\n\t\tis.Equal(true, r8)\n\t}\n\n\t{\n\t\ttuple := Tuple9[string, int, float64, bool, string, int, float64, bool, string]{\"a\", 1, 1.0, true, \"b\", 2, 3.0, true, \"c\"}\n\n\t\tr1, r2, r3, r4, r5, r6, r7, r8, r9 := Unpack9(tuple)\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\t\tis.Equal(3.0, r7)\n\t\tis.Equal(true, r8)\n\t\tis.Equal(\"c\", r9)\n\n\t\tr1, r2, r3, r4, r5, r6, r7, r8, r9 = tuple.Unpack()\n\n\t\tis.Equal(\"a\", r1)\n\t\tis.Equal(1, r2)\n\t\tis.Equal(1.0, r3)\n\t\tis.Equal(true, r4)\n\t\tis.Equal(\"b\", r5)\n\t\tis.Equal(2, r6)\n\t\tis.Equal(3.0, r7)\n\t\tis.Equal(true, r8)\n\t\tis.Equal(\"c\", r9)\n\t}\n}\n\nfunc TestZip(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := Zip2(\n\t\t[]string{\"a\", \"b\"},\n\t\t[]int{1, 2},\n\t)\n\n\tr2 := Zip3(\n\t\t[]string{\"a\", \"b\", \"c\"},\n\t\t[]int{1, 2, 3},\n\t\t[]int{4, 5, 6},\n\t)\n\n\tr3 := Zip4(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\"},\n\t\t[]int{1, 2, 3, 4},\n\t\t[]int{5, 6, 7, 8},\n\t\t[]bool{true, true, true, true},\n\t)\n\n\tr4 := Zip5(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\"},\n\t\t[]int{1, 2, 3, 4, 5},\n\t\t[]int{6, 7, 8, 9, 10},\n\t\t[]bool{true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5},\n\t)\n\n\tr5 := Zip6(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"},\n\t\t[]int{1, 2, 3, 4, 5, 6},\n\t\t[]int{7, 8, 9, 10, 11, 12},\n\t\t[]bool{true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06},\n\t)\n\n\tr6 := Zip7(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7},\n\t\t[]int{8, 9, 10, 11, 12, 13, 14},\n\t\t[]bool{true, true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07},\n\t\t[]int8{1, 2, 3, 4, 5, 6, 7},\n\t)\n\n\tr7 := Zip8(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8},\n\t\t[]int{9, 10, 11, 12, 13, 14, 15, 16},\n\t\t[]bool{true, true, true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08},\n\t\t[]int8{1, 2, 3, 4, 5, 6, 7, 8},\n\t\t[]int16{1, 2, 3, 4, 5, 6, 7, 8},\n\t)\n\n\tr8 := Zip9(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t[]int{10, 11, 12, 13, 14, 15, 16, 17, 18},\n\t\t[]bool{true, true, true, true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09},\n\t\t[]int8{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t[]int16{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t[]int32{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t)\n\n\tis.Equal(r1, []Tuple2[string, int]{\n\t\t{A: \"a\", B: 1},\n\t\t{A: \"b\", B: 2},\n\t})\n\n\tis.Equal(r2, []Tuple3[string, int, int]{\n\t\t{A: \"a\", B: 1, C: 4},\n\t\t{A: \"b\", B: 2, C: 5},\n\t\t{A: \"c\", B: 3, C: 6},\n\t})\n\n\tis.Equal(r3, []Tuple4[string, int, int, bool]{\n\t\t{A: \"a\", B: 1, C: 5, D: true},\n\t\t{A: \"b\", B: 2, C: 6, D: true},\n\t\t{A: \"c\", B: 3, C: 7, D: true},\n\t\t{A: \"d\", B: 4, C: 8, D: true},\n\t})\n\n\tis.Equal(r4, []Tuple5[string, int, int, bool, float32]{\n\t\t{A: \"a\", B: 1, C: 6, D: true, E: 0.1},\n\t\t{A: \"b\", B: 2, C: 7, D: true, E: 0.2},\n\t\t{A: \"c\", B: 3, C: 8, D: true, E: 0.3},\n\t\t{A: \"d\", B: 4, C: 9, D: true, E: 0.4},\n\t\t{A: \"e\", B: 5, C: 10, D: true, E: 0.5},\n\t})\n\n\tis.Equal(r5, []Tuple6[string, int, int, bool, float32, float64]{\n\t\t{A: \"a\", B: 1, C: 7, D: true, E: 0.1, F: 0.01},\n\t\t{A: \"b\", B: 2, C: 8, D: true, E: 0.2, F: 0.02},\n\t\t{A: \"c\", B: 3, C: 9, D: true, E: 0.3, F: 0.03},\n\t\t{A: \"d\", B: 4, C: 10, D: true, E: 0.4, F: 0.04},\n\t\t{A: \"e\", B: 5, C: 11, D: true, E: 0.5, F: 0.05},\n\t\t{A: \"f\", B: 6, C: 12, D: true, E: 0.6, F: 0.06},\n\t})\n\n\tis.Equal(r6, []Tuple7[string, int, int, bool, float32, float64, int8]{\n\t\t{A: \"a\", B: 1, C: 8, D: true, E: 0.1, F: 0.01, G: 1},\n\t\t{A: \"b\", B: 2, C: 9, D: true, E: 0.2, F: 0.02, G: 2},\n\t\t{A: \"c\", B: 3, C: 10, D: true, E: 0.3, F: 0.03, G: 3},\n\t\t{A: \"d\", B: 4, C: 11, D: true, E: 0.4, F: 0.04, G: 4},\n\t\t{A: \"e\", B: 5, C: 12, D: true, E: 0.5, F: 0.05, G: 5},\n\t\t{A: \"f\", B: 6, C: 13, D: true, E: 0.6, F: 0.06, G: 6},\n\t\t{A: \"g\", B: 7, C: 14, D: true, E: 0.7, F: 0.07, G: 7},\n\t})\n\n\tis.Equal(r7, []Tuple8[string, int, int, bool, float32, float64, int8, int16]{\n\t\t{A: \"a\", B: 1, C: 9, D: true, E: 0.1, F: 0.01, G: 1, H: 1},\n\t\t{A: \"b\", B: 2, C: 10, D: true, E: 0.2, F: 0.02, G: 2, H: 2},\n\t\t{A: \"c\", B: 3, C: 11, D: true, E: 0.3, F: 0.03, G: 3, H: 3},\n\t\t{A: \"d\", B: 4, C: 12, D: true, E: 0.4, F: 0.04, G: 4, H: 4},\n\t\t{A: \"e\", B: 5, C: 13, D: true, E: 0.5, F: 0.05, G: 5, H: 5},\n\t\t{A: \"f\", B: 6, C: 14, D: true, E: 0.6, F: 0.06, G: 6, H: 6},\n\t\t{A: \"g\", B: 7, C: 15, D: true, E: 0.7, F: 0.07, G: 7, H: 7},\n\t\t{A: \"h\", B: 8, C: 16, D: true, E: 0.8, F: 0.08, G: 8, H: 8},\n\t})\n\n\tis.Equal(r8, []Tuple9[string, int, int, bool, float32, float64, int8, int16, int32]{\n\t\t{A: \"a\", B: 1, C: 10, D: true, E: 0.1, F: 0.01, G: 1, H: 1, I: 1},\n\t\t{A: \"b\", B: 2, C: 11, D: true, E: 0.2, F: 0.02, G: 2, H: 2, I: 2},\n\t\t{A: \"c\", B: 3, C: 12, D: true, E: 0.3, F: 0.03, G: 3, H: 3, I: 3},\n\t\t{A: \"d\", B: 4, C: 13, D: true, E: 0.4, F: 0.04, G: 4, H: 4, I: 4},\n\t\t{A: \"e\", B: 5, C: 14, D: true, E: 0.5, F: 0.05, G: 5, H: 5, I: 5},\n\t\t{A: \"f\", B: 6, C: 15, D: true, E: 0.6, F: 0.06, G: 6, H: 6, I: 6},\n\t\t{A: \"g\", B: 7, C: 16, D: true, E: 0.7, F: 0.07, G: 7, H: 7, I: 7},\n\t\t{A: \"h\", B: 8, C: 17, D: true, E: 0.8, F: 0.08, G: 8, H: 8, I: 8},\n\t\t{A: \"i\", B: 9, C: 18, D: true, E: 0.9, F: 0.09, G: 9, H: 9, I: 9},\n\t})\n}\n\nfunc TestZipBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1 := ZipBy2(\n\t\t[]string{\"a\", \"b\"},\n\t\t[]int{1, 2},\n\t\tfunc(a string, b int) Tuple2[string, int] {\n\t\t\treturn T2(a, b)\n\t\t},\n\t)\n\n\tr2 := ZipBy3(\n\t\t[]string{\"a\", \"b\", \"c\"},\n\t\t[]int{1, 2, 3},\n\t\t[]int{4, 5, 6},\n\t\tfunc(a string, b int, c int) Tuple3[string, int, int] {\n\t\t\treturn T3(a, b, c)\n\t\t},\n\t)\n\n\tr3 := ZipBy4(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\"},\n\t\t[]int{1, 2, 3, 4},\n\t\t[]int{5, 6, 7, 8},\n\t\t[]bool{true, true, true, true},\n\t\tfunc(a string, b int, c int, d bool) Tuple4[string, int, int, bool] {\n\t\t\treturn T4(a, b, c, d)\n\t\t},\n\t)\n\n\tr4 := ZipBy5(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\"},\n\t\t[]int{1, 2, 3, 4, 5},\n\t\t[]int{6, 7, 8, 9, 10},\n\t\t[]bool{true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5},\n\t\tfunc(a string, b int, c int, d bool, e float32) Tuple5[string, int, int, bool, float32] {\n\t\t\treturn T5(a, b, c, d, e)\n\t\t},\n\t)\n\n\tr5 := ZipBy6(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"},\n\t\t[]int{1, 2, 3, 4, 5, 6},\n\t\t[]int{7, 8, 9, 10, 11, 12},\n\t\t[]bool{true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06},\n\t\tfunc(a string, b int, c int, d bool, e float32, f float64) Tuple6[string, int, int, bool, float32, float64] {\n\t\t\treturn T6(a, b, c, d, e, f)\n\t\t},\n\t)\n\n\tr6 := ZipBy7(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7},\n\t\t[]int{8, 9, 10, 11, 12, 13, 14},\n\t\t[]bool{true, true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07},\n\t\t[]int8{1, 2, 3, 4, 5, 6, 7},\n\t\tfunc(a string, b int, c int, d bool, e float32, f float64, g int8) Tuple7[string, int, int, bool, float32, float64, int8] {\n\t\t\treturn T7(a, b, c, d, e, f, g)\n\t\t},\n\t)\n\n\tr7 := ZipBy8(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\"},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8},\n\t\t[]int{9, 10, 11, 12, 13, 14, 15, 16},\n\t\t[]bool{true, true, true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08},\n\t\t[]int8{1, 2, 3, 4, 5, 6, 7, 8},\n\t\t[]int16{1, 2, 3, 4, 5, 6, 7, 8},\n\t\tfunc(a string, b int, c int, d bool, e float32, f float64, g int8, h int16) Tuple8[string, int, int, bool, float32, float64, int8, int16] {\n\t\t\treturn T8(a, b, c, d, e, f, g, h)\n\t\t},\n\t)\n\n\tr8 := ZipBy9(\n\t\t[]string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\"},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t[]int{10, 11, 12, 13, 14, 15, 16, 17, 18},\n\t\t[]bool{true, true, true, true, true, true, true, true, true},\n\t\t[]float32{0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9},\n\t\t[]float64{0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09},\n\t\t[]int8{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t[]int16{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\t[]int32{1, 2, 3, 4, 5, 6, 7, 8, 9},\n\t\tfunc(a string, b int, c int, d bool, e float32, f float64, g int8, h int16, i int32) Tuple9[string, int, int, bool, float32, float64, int8, int16, int32] {\n\t\t\treturn T9(a, b, c, d, e, f, g, h, i)\n\t\t},\n\t)\n\n\tis.Equal(r1, []Tuple2[string, int]{\n\t\t{A: \"a\", B: 1},\n\t\t{A: \"b\", B: 2},\n\t})\n\n\tis.Equal(r2, []Tuple3[string, int, int]{\n\t\t{A: \"a\", B: 1, C: 4},\n\t\t{A: \"b\", B: 2, C: 5},\n\t\t{A: \"c\", B: 3, C: 6},\n\t})\n\n\tis.Equal(r3, []Tuple4[string, int, int, bool]{\n\t\t{A: \"a\", B: 1, C: 5, D: true},\n\t\t{A: \"b\", B: 2, C: 6, D: true},\n\t\t{A: \"c\", B: 3, C: 7, D: true},\n\t\t{A: \"d\", B: 4, C: 8, D: true},\n\t})\n\n\tis.Equal(r4, []Tuple5[string, int, int, bool, float32]{\n\t\t{A: \"a\", B: 1, C: 6, D: true, E: 0.1},\n\t\t{A: \"b\", B: 2, C: 7, D: true, E: 0.2},\n\t\t{A: \"c\", B: 3, C: 8, D: true, E: 0.3},\n\t\t{A: \"d\", B: 4, C: 9, D: true, E: 0.4},\n\t\t{A: \"e\", B: 5, C: 10, D: true, E: 0.5},\n\t})\n\n\tis.Equal(r5, []Tuple6[string, int, int, bool, float32, float64]{\n\t\t{A: \"a\", B: 1, C: 7, D: true, E: 0.1, F: 0.01},\n\t\t{A: \"b\", B: 2, C: 8, D: true, E: 0.2, F: 0.02},\n\t\t{A: \"c\", B: 3, C: 9, D: true, E: 0.3, F: 0.03},\n\t\t{A: \"d\", B: 4, C: 10, D: true, E: 0.4, F: 0.04},\n\t\t{A: \"e\", B: 5, C: 11, D: true, E: 0.5, F: 0.05},\n\t\t{A: \"f\", B: 6, C: 12, D: true, E: 0.6, F: 0.06},\n\t})\n\n\tis.Equal(r6, []Tuple7[string, int, int, bool, float32, float64, int8]{\n\t\t{A: \"a\", B: 1, C: 8, D: true, E: 0.1, F: 0.01, G: 1},\n\t\t{A: \"b\", B: 2, C: 9, D: true, E: 0.2, F: 0.02, G: 2},\n\t\t{A: \"c\", B: 3, C: 10, D: true, E: 0.3, F: 0.03, G: 3},\n\t\t{A: \"d\", B: 4, C: 11, D: true, E: 0.4, F: 0.04, G: 4},\n\t\t{A: \"e\", B: 5, C: 12, D: true, E: 0.5, F: 0.05, G: 5},\n\t\t{A: \"f\", B: 6, C: 13, D: true, E: 0.6, F: 0.06, G: 6},\n\t\t{A: \"g\", B: 7, C: 14, D: true, E: 0.7, F: 0.07, G: 7},\n\t})\n\n\tis.Equal(r7, []Tuple8[string, int, int, bool, float32, float64, int8, int16]{\n\t\t{A: \"a\", B: 1, C: 9, D: true, E: 0.1, F: 0.01, G: 1, H: 1},\n\t\t{A: \"b\", B: 2, C: 10, D: true, E: 0.2, F: 0.02, G: 2, H: 2},\n\t\t{A: \"c\", B: 3, C: 11, D: true, E: 0.3, F: 0.03, G: 3, H: 3},\n\t\t{A: \"d\", B: 4, C: 12, D: true, E: 0.4, F: 0.04, G: 4, H: 4},\n\t\t{A: \"e\", B: 5, C: 13, D: true, E: 0.5, F: 0.05, G: 5, H: 5},\n\t\t{A: \"f\", B: 6, C: 14, D: true, E: 0.6, F: 0.06, G: 6, H: 6},\n\t\t{A: \"g\", B: 7, C: 15, D: true, E: 0.7, F: 0.07, G: 7, H: 7},\n\t\t{A: \"h\", B: 8, C: 16, D: true, E: 0.8, F: 0.08, G: 8, H: 8},\n\t})\n\n\tis.Equal(r8, []Tuple9[string, int, int, bool, float32, float64, int8, int16, int32]{\n\t\t{A: \"a\", B: 1, C: 10, D: true, E: 0.1, F: 0.01, G: 1, H: 1, I: 1},\n\t\t{A: \"b\", B: 2, C: 11, D: true, E: 0.2, F: 0.02, G: 2, H: 2, I: 2},\n\t\t{A: \"c\", B: 3, C: 12, D: true, E: 0.3, F: 0.03, G: 3, H: 3, I: 3},\n\t\t{A: \"d\", B: 4, C: 13, D: true, E: 0.4, F: 0.04, G: 4, H: 4, I: 4},\n\t\t{A: \"e\", B: 5, C: 14, D: true, E: 0.5, F: 0.05, G: 5, H: 5, I: 5},\n\t\t{A: \"f\", B: 6, C: 15, D: true, E: 0.6, F: 0.06, G: 6, H: 6, I: 6},\n\t\t{A: \"g\", B: 7, C: 16, D: true, E: 0.7, F: 0.07, G: 7, H: 7, I: 7},\n\t\t{A: \"h\", B: 8, C: 17, D: true, E: 0.8, F: 0.08, G: 8, H: 8, I: 8},\n\t\t{A: \"i\", B: 9, C: 18, D: true, E: 0.9, F: 0.09, G: 9, H: 9, I: 9},\n\t})\n}\n\nfunc TestUnzip(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1, r2 := Unzip2([]Tuple2[string, int]{{A: \"a\", B: 1}, {A: \"b\", B: 2}})\n\n\tis.Equal(r1, []string{\"a\", \"b\"})\n\tis.Equal(r2, []int{1, 2})\n}\n\nfunc TestUnzipBy(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tr1, r2 := UnzipBy2([]Tuple2[string, int]{{A: \"a\", B: 1}, {A: \"b\", B: 2}}, func(i Tuple2[string, int]) (a string, b int) {\n\t\treturn i.A + i.A, i.B + i.B\n\t})\n\n\tis.Equal(r1, []string{\"aa\", \"bb\"})\n\tis.Equal(r2, []int{2, 4})\n}\n"
        },
        {
          "name": "type_manipulation.go",
          "type": "blob",
          "size": 3.03125,
          "content": "package lo\n\nimport \"reflect\"\n\n// IsNil checks if a value is nil or if it's a reference type with a nil underlying value.\nfunc IsNil(x any) bool {\n\tdefer func() { recover() }() // nolint:errcheck\n\treturn x == nil || reflect.ValueOf(x).IsNil()\n}\n\n// ToPtr returns a pointer copy of value.\nfunc ToPtr[T any](x T) *T {\n\treturn &x\n}\n\n// Nil returns a nil pointer of type.\nfunc Nil[T any]() *T {\n\treturn nil\n}\n\n// EmptyableToPtr returns a pointer copy of value if it's nonzero.\n// Otherwise, returns nil pointer.\nfunc EmptyableToPtr[T any](x T) *T {\n\t// 🤮\n\tisZero := reflect.ValueOf(&x).Elem().IsZero()\n\tif isZero {\n\t\treturn nil\n\t}\n\n\treturn &x\n}\n\n// FromPtr returns the pointer value or empty.\nfunc FromPtr[T any](x *T) T {\n\tif x == nil {\n\t\treturn Empty[T]()\n\t}\n\n\treturn *x\n}\n\n// FromPtrOr returns the pointer value or the fallback value.\nfunc FromPtrOr[T any](x *T, fallback T) T {\n\tif x == nil {\n\t\treturn fallback\n\t}\n\n\treturn *x\n}\n\n// ToSlicePtr returns a slice of pointer copy of value.\nfunc ToSlicePtr[T any](collection []T) []*T {\n\tresult := make([]*T, len(collection))\n\n\tfor i := range collection {\n\t\tresult[i] = &collection[i]\n\t}\n\treturn result\n}\n\n// FromSlicePtr returns a slice with the pointer values.\n// Returns a zero value in case of a nil pointer element.\nfunc FromSlicePtr[T any](collection []*T) []T {\n\treturn Map(collection, func(x *T, _ int) T {\n\t\tif x == nil {\n\t\t\treturn Empty[T]()\n\t\t}\n\t\treturn *x\n\t})\n}\n\n// FromSlicePtrOr returns a slice with the pointer values or the fallback value.\n// Play: https://go.dev/play/p/lbunFvzlUDX\nfunc FromSlicePtrOr[T any](collection []*T, fallback T) []T {\n\treturn Map(collection, func(x *T, _ int) T {\n\t\tif x == nil {\n\t\t\treturn fallback\n\t\t}\n\t\treturn *x\n\t})\n}\n\n// ToAnySlice returns a slice with all elements mapped to `any` type\nfunc ToAnySlice[T any](collection []T) []any {\n\tresult := make([]any, len(collection))\n\tfor i := range collection {\n\t\tresult[i] = collection[i]\n\t}\n\treturn result\n}\n\n// FromAnySlice returns an `any` slice with all elements mapped to a type.\n// Returns false in case of type conversion failure.\nfunc FromAnySlice[T any](in []any) (out []T, ok bool) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tout = []T{}\n\t\t\tok = false\n\t\t}\n\t}()\n\n\tresult := make([]T, len(in))\n\tfor i := range in {\n\t\tresult[i] = in[i].(T)\n\t}\n\treturn result, true\n}\n\n// Empty returns an empty value.\nfunc Empty[T any]() T {\n\tvar zero T\n\treturn zero\n}\n\n// IsEmpty returns true if argument is a zero value.\nfunc IsEmpty[T comparable](v T) bool {\n\tvar zero T\n\treturn zero == v\n}\n\n// IsNotEmpty returns true if argument is not a zero value.\nfunc IsNotEmpty[T comparable](v T) bool {\n\tvar zero T\n\treturn zero != v\n}\n\n// Coalesce returns the first non-empty arguments. Arguments must be comparable.\nfunc Coalesce[T comparable](values ...T) (result T, ok bool) {\n\tfor i := range values {\n\t\tif values[i] != result {\n\t\t\tresult = values[i]\n\t\t\tok = true\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn\n}\n\n// CoalesceOrEmpty returns the first non-empty arguments. Arguments must be comparable.\nfunc CoalesceOrEmpty[T comparable](v ...T) T {\n\tresult, _ := Coalesce(v...)\n\treturn result\n}\n"
        },
        {
          "name": "type_manipulation_test.go",
          "type": "blob",
          "size": 6.240234375,
          "content": "package lo\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIsNil(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tvar x int\n\tis.False(IsNil(x))\n\n\tvar k struct{}\n\tis.False(IsNil(k))\n\n\tvar s *string\n\tis.True(IsNil(s))\n\n\tvar i *int\n\tis.True(IsNil(i))\n\n\tvar b *bool\n\tis.True(IsNil(b))\n\n\tvar ifaceWithNilValue any = (*string)(nil) //nolint:staticcheck\n\tis.True(IsNil(ifaceWithNilValue))\n\tis.False(ifaceWithNilValue == nil) //nolint:staticcheck\n}\n\nfunc TestToPtr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tresult1 := ToPtr([]int{1, 2})\n\n\tis.Equal(*result1, []int{1, 2})\n}\n\nfunc TestNil(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tnilFloat64 := Nil[float64]()\n\tvar expNilFloat64 *float64\n\n\tnilString := Nil[string]()\n\tvar expNilString *string\n\n\tis.Equal(expNilFloat64, nilFloat64)\n\tis.Nil(nilFloat64)\n\tis.NotEqual(nil, nilFloat64)\n\n\tis.Equal(expNilString, nilString)\n\tis.Nil(nilString)\n\tis.NotEqual(nil, nilString)\n\n\tis.NotEqual(nilString, nilFloat64)\n}\n\nfunc TestEmptyableToPtr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.Nil(EmptyableToPtr(0))\n\tis.Nil(EmptyableToPtr(\"\"))\n\tis.Nil(EmptyableToPtr[[]int](nil))\n\tis.Nil(EmptyableToPtr[map[int]int](nil))\n\tis.Nil(EmptyableToPtr[error](nil))\n\n\tis.Equal(*EmptyableToPtr(42), 42)\n\tis.Equal(*EmptyableToPtr(\"nonempty\"), \"nonempty\")\n\tis.Equal(*EmptyableToPtr([]int{}), []int{})\n\tis.Equal(*EmptyableToPtr([]int{1, 2}), []int{1, 2})\n\tis.Equal(*EmptyableToPtr(map[int]int{}), map[int]int{})\n\tis.Equal(*EmptyableToPtr(assert.AnError), assert.AnError)\n}\n\nfunc TestFromPtr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tstr1 := \"foo\"\n\tptr := &str1\n\n\tis.Equal(\"foo\", FromPtr(ptr))\n\tis.Equal(\"\", FromPtr[string](nil))\n\tis.Equal(0, FromPtr[int](nil))\n\tis.Nil(FromPtr[*string](nil))\n\tis.EqualValues(ptr, FromPtr(&ptr))\n}\n\nfunc TestFromPtrOr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tconst fallbackStr = \"fallback\"\n\tstr := \"foo\"\n\tptrStr := &str\n\n\tconst fallbackInt = -1\n\ti := 9\n\tptrInt := &i\n\n\tis.Equal(str, FromPtrOr(ptrStr, fallbackStr))\n\tis.Equal(fallbackStr, FromPtrOr(nil, fallbackStr))\n\tis.Equal(i, FromPtrOr(ptrInt, fallbackInt))\n\tis.Equal(fallbackInt, FromPtrOr(nil, fallbackInt))\n}\n\nfunc TestToSlicePtr(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tstr1 := \"foo\"\n\tstr2 := \"bar\"\n\tresult1 := ToSlicePtr([]string{str1, str2})\n\n\tis.Equal(result1, []*string{&str1, &str2})\n}\n\nfunc TestFromSlicePtr(t *testing.T) {\n\tis := assert.New(t)\n\n\tstr1 := \"foo\"\n\tstr2 := \"bar\"\n\tresult1 := FromSlicePtr([]*string{&str1, &str2, nil})\n\n\tis.Equal(result1, []string{str1, str2, \"\"})\n}\n\nfunc TestFromSlicePtrOr(t *testing.T) {\n\tis := assert.New(t)\n\n\tstr1 := \"foo\"\n\tstr2 := \"bar\"\n\tresult1 := FromSlicePtrOr([]*string{&str1, &str2, nil}, \"fallback\")\n\n\tis.Equal(result1, []string{str1, str2, \"fallback\"})\n}\n\nfunc TestToAnySlice(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tin1 := []int{0, 1, 2, 3}\n\tin2 := []int{}\n\tout1 := ToAnySlice(in1)\n\tout2 := ToAnySlice(in2)\n\n\tis.Equal([]any{0, 1, 2, 3}, out1)\n\tis.Equal([]any{}, out2)\n}\n\nfunc TestFromAnySlice(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tis.NotPanics(func() {\n\t\tout1, ok1 := FromAnySlice[string]([]any{\"foobar\", 42})\n\t\tout2, ok2 := FromAnySlice[string]([]any{\"foobar\", \"42\"})\n\n\t\tis.Equal([]string{}, out1)\n\t\tis.False(ok1)\n\t\tis.Equal([]string{\"foobar\", \"42\"}, out2)\n\t\tis.True(ok2)\n\t})\n}\n\nfunc TestEmpty(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t//nolint:unused\n\ttype test struct{}\n\n\tis.Empty(Empty[string]())\n\tis.Empty(Empty[int64]())\n\tis.Empty(Empty[test]())\n\tis.Empty(Empty[chan string]())\n}\n\nfunc TestIsEmpty(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t//nolint:unused\n\ttype test struct {\n\t\tfoobar string\n\t}\n\n\tis.True(IsEmpty(\"\"))\n\tis.False(IsEmpty(\"foo\"))\n\tis.True(IsEmpty[int64](0))\n\tis.False(IsEmpty[int64](42))\n\tis.True(IsEmpty(test{foobar: \"\"}))\n\tis.False(IsEmpty(test{foobar: \"foo\"}))\n}\n\nfunc TestIsNotEmpty(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\t//nolint:unused\n\ttype test struct {\n\t\tfoobar string\n\t}\n\n\tis.False(IsNotEmpty(\"\"))\n\tis.True(IsNotEmpty(\"foo\"))\n\tis.False(IsNotEmpty[int64](0))\n\tis.True(IsNotEmpty[int64](42))\n\tis.False(IsNotEmpty(test{foobar: \"\"}))\n\tis.True(IsNotEmpty(test{foobar: \"foo\"}))\n}\n\nfunc TestCoalesce(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tnewStr := func(v string) *string { return &v }\n\tvar nilStr *string\n\tstr1 := newStr(\"str1\")\n\tstr2 := newStr(\"str2\")\n\n\ttype structType struct {\n\t\tfield1 int\n\t\tfield2 float64\n\t}\n\tvar zeroStruct structType\n\tstruct1 := structType{1, 1.0}\n\tstruct2 := structType{2, 2.0}\n\n\tresult1, ok1 := Coalesce[int]()\n\tresult2, ok2 := Coalesce(3)\n\tresult3, ok3 := Coalesce(nil, nilStr)\n\tresult4, ok4 := Coalesce(nilStr, str1)\n\tresult5, ok5 := Coalesce(nilStr, str1, str2)\n\tresult6, ok6 := Coalesce(str1, str2, nilStr)\n\tresult7, ok7 := Coalesce(0, 1, 2, 3)\n\tresult8, ok8 := Coalesce(zeroStruct)\n\tresult9, ok9 := Coalesce(zeroStruct, struct1)\n\tresult10, ok10 := Coalesce(zeroStruct, struct1, struct2)\n\n\tis.Equal(0, result1)\n\tis.False(ok1)\n\n\tis.Equal(3, result2)\n\tis.True(ok2)\n\n\tis.Nil(result3)\n\tis.False(ok3)\n\n\tis.Equal(str1, result4)\n\tis.True(ok4)\n\n\tis.Equal(str1, result5)\n\tis.True(ok5)\n\n\tis.Equal(str1, result6)\n\tis.True(ok6)\n\n\tis.Equal(result7, 1)\n\tis.True(ok7)\n\n\tis.Equal(result8, zeroStruct)\n\tis.False(ok8)\n\n\tis.Equal(result9, struct1)\n\tis.True(ok9)\n\n\tis.Equal(result10, struct1)\n\tis.True(ok10)\n}\n\nfunc TestCoalesceOrEmpty(t *testing.T) {\n\tt.Parallel()\n\tis := assert.New(t)\n\n\tnewStr := func(v string) *string { return &v }\n\tvar nilStr *string\n\tstr1 := newStr(\"str1\")\n\tstr2 := newStr(\"str2\")\n\n\ttype structType struct {\n\t\tfield1 int\n\t\tfield2 float64\n\t}\n\tvar zeroStruct structType\n\tstruct1 := structType{1, 1.0}\n\tstruct2 := structType{2, 2.0}\n\n\tresult1 := CoalesceOrEmpty[int]()\n\tresult2 := CoalesceOrEmpty(3)\n\tresult3 := CoalesceOrEmpty(nil, nilStr)\n\tresult4 := CoalesceOrEmpty(nilStr, str1)\n\tresult5 := CoalesceOrEmpty(nilStr, str1, str2)\n\tresult6 := CoalesceOrEmpty(str1, str2, nilStr)\n\tresult7 := CoalesceOrEmpty(0, 1, 2, 3)\n\tresult8 := CoalesceOrEmpty(zeroStruct)\n\tresult9 := CoalesceOrEmpty(zeroStruct, struct1)\n\tresult10 := CoalesceOrEmpty(zeroStruct, struct1, struct2)\n\n\tis.Equal(0, result1)\n\tis.Equal(3, result2)\n\tis.Nil(result3)\n\tis.Equal(str1, result4)\n\tis.Equal(str1, result5)\n\tis.Equal(str1, result6)\n\tis.Equal(result7, 1)\n\tis.Equal(result8, zeroStruct)\n\tis.Equal(result9, struct1)\n\tis.Equal(result10, struct1)\n}\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 2.078125,
          "content": "package lo\n\n// Entry defines a key/value pairs.\ntype Entry[K comparable, V any] struct {\n\tKey   K\n\tValue V\n}\n\n// Tuple2 is a group of 2 elements (pair).\ntype Tuple2[A, B any] struct {\n\tA A\n\tB B\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple2[A, B]) Unpack() (A, B) {\n\treturn t.A, t.B\n}\n\n// Tuple3 is a group of 3 elements.\ntype Tuple3[A, B, C any] struct {\n\tA A\n\tB B\n\tC C\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple3[A, B, C]) Unpack() (A, B, C) {\n\treturn t.A, t.B, t.C\n}\n\n// Tuple4 is a group of 4 elements.\ntype Tuple4[A, B, C, D any] struct {\n\tA A\n\tB B\n\tC C\n\tD D\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple4[A, B, C, D]) Unpack() (A, B, C, D) {\n\treturn t.A, t.B, t.C, t.D\n}\n\n// Tuple5 is a group of 5 elements.\ntype Tuple5[A, B, C, D, E any] struct {\n\tA A\n\tB B\n\tC C\n\tD D\n\tE E\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple5[A, B, C, D, E]) Unpack() (A, B, C, D, E) {\n\treturn t.A, t.B, t.C, t.D, t.E\n}\n\n// Tuple6 is a group of 6 elements.\ntype Tuple6[A, B, C, D, E, F any] struct {\n\tA A\n\tB B\n\tC C\n\tD D\n\tE E\n\tF F\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple6[A, B, C, D, E, F]) Unpack() (A, B, C, D, E, F) {\n\treturn t.A, t.B, t.C, t.D, t.E, t.F\n}\n\n// Tuple7 is a group of 7 elements.\ntype Tuple7[A, B, C, D, E, F, G any] struct {\n\tA A\n\tB B\n\tC C\n\tD D\n\tE E\n\tF F\n\tG G\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple7[A, B, C, D, E, F, G]) Unpack() (A, B, C, D, E, F, G) {\n\treturn t.A, t.B, t.C, t.D, t.E, t.F, t.G\n}\n\n// Tuple8 is a group of 8 elements.\ntype Tuple8[A, B, C, D, E, F, G, H any] struct {\n\tA A\n\tB B\n\tC C\n\tD D\n\tE E\n\tF F\n\tG G\n\tH H\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple8[A, B, C, D, E, F, G, H]) Unpack() (A, B, C, D, E, F, G, H) {\n\treturn t.A, t.B, t.C, t.D, t.E, t.F, t.G, t.H\n}\n\n// Tuple9 is a group of 9 elements.\ntype Tuple9[A, B, C, D, E, F, G, H, I any] struct {\n\tA A\n\tB B\n\tC C\n\tD D\n\tE E\n\tF F\n\tG G\n\tH H\n\tI I\n}\n\n// Unpack returns values contained in tuple.\nfunc (t Tuple9[A, B, C, D, E, F, G, H, I]) Unpack() (A, B, C, D, E, F, G, H, I) {\n\treturn t.A, t.B, t.C, t.D, t.E, t.F, t.G, t.H, t.I\n}\n"
        }
      ]
    }
  ]
}