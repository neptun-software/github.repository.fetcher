{
  "metadata": {
    "timestamp": 1736568094083,
    "page": 233,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-resty/resty",
      "stars": 10361,
      "defaultBranch": "v2",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.326171875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\ncoverage.out\ncoverage.txt\n\n# Exclude IDE folders\n.idea/*\n.vscode/*\n"
        },
        {
          "name": ".testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "BUILD.bazel",
          "type": "blob",
          "size": 1.35546875,
          "content": "load(\"@bazel_gazelle//:def.bzl\", \"gazelle\")\nload(\"@io_bazel_rules_go//go:def.bzl\", \"go_library\", \"go_test\")\n\n# gazelle:prefix github.com/go-resty/resty/v2\n# gazelle:go_naming_convention import_alias\ngazelle(name = \"gazelle\")\n\ngo_library(\n    name = \"resty\",\n    srcs = [\n        \"client.go\",\n        \"digest.go\",\n        \"middleware.go\",\n        \"redirect.go\",\n        \"request.go\",\n        \"response.go\",\n        \"resty.go\",\n        \"retry.go\",\n        \"trace.go\",\n        \"transport.go\",\n        \"transport112.go\",\n        \"transport_js.go\",\n        \"transport_other.go\",\n        \"util.go\",\n        \"util_curl.go\",\n    ],\n    importpath = \"github.com/go-resty/resty/v2\",\n    visibility = [\"//visibility:public\"],\n    deps = [\n        \"//shellescape\",\n        \"@org_golang_x_net//publicsuffix:go_default_library\",\n    ],\n)\n\ngo_test(\n    name = \"resty_test\",\n    srcs = [\n        \"client_test.go\",\n        \"context_test.go\",\n        \"example_test.go\",\n        \"middleware_test.go\",\n        \"request_test.go\",\n        \"resty_test.go\",\n        \"retry_test.go\",\n        \"util_test.go\",\n    ],\n    data = glob([\".testdata/*\"]),\n    embed = [\":resty\"],\n    deps = [\n        \"@org_golang_x_net//proxy:go_default_library\",\n        \"@org_golang_x_time//rate:go_default_library\",\n    ],\n)\n\nalias(\n    name = \"go_default_library\",\n    actual = \":resty\",\n    visibility = [\"//visibility:public\"],\n)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1005859375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015-2024 Jeevanandam M., https://myjeeva.com <jeeva@myjeeva.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 34.193359375,
          "content": "<p align=\"center\">\n<h1 align=\"center\">Resty</h1>\n<p align=\"center\">Simple HTTP and REST client library for Go (inspired by Ruby rest-client)</p>\n<p align=\"center\"><a href=\"#features\">Features</a> section describes in detail about Resty capabilities</p>\n</p>\n<p align=\"center\">\n<p align=\"center\"><a href=\"https://github.com/go-resty/resty/actions/workflows/ci.yml?query=branch%3Av2\"><img src=\"https://github.com/go-resty/resty/actions/workflows/ci.yml/badge.svg?branch=v2\" alt=\"Build Status\"></a> <a href=\"https://app.codecov.io/gh/go-resty/resty/tree/v2\"><img src=\"https://codecov.io/gh/go-resty/resty/branch/v2/graph/badge.svg\" alt=\"Code Coverage\"></a> <a href=\"https://goreportcard.com/report/go-resty/resty\"><img src=\"https://goreportcard.com/badge/go-resty/resty\" alt=\"Go Report Card\"></a> <a href=\"https://github.com/go-resty/resty/releases/latest\"><img src=\"https://img.shields.io/badge/version-2.16.3-blue.svg\" alt=\"Release Version\"></a> <a href=\"https://pkg.go.dev/github.com/go-resty/resty/v2\"><img src=\"https://pkg.go.dev/badge/github.com/go-resty/resty\" alt=\"GoDoc\"></a> <a href=\"LICENSE\"><img src=\"https://img.shields.io/github/license/go-resty/resty.svg\" alt=\"License\"></a> <a href=\"https://github.com/avelino/awesome-go\"><img src=\"https://awesome.re/mentioned-badge.svg\" alt=\"Mentioned in Awesome Go\"></a></p>\n</p>\n\n## News\n\n  * v2.16.3 [released](https://github.com/go-resty/resty/releases/tag/v2.16.3) and tagged on Jan 08, 2025.\n  * v2.0.0 [released](https://github.com/go-resty/resty/releases/tag/v2.0.0) and tagged on Jul 16, 2019.\n  * v1.12.0 [released](https://github.com/go-resty/resty/releases/tag/v1.12.0) and tagged on Feb 27, 2019.\n  * v1.0 released and tagged on Sep 25, 2017. - Resty's first version was released on Sep 15, 2015 then it grew gradually as a very handy and helpful library. Its been a two years since first release. I'm very thankful to Resty users and its [contributors](https://github.com/go-resty/resty/graphs/contributors).\n\n## Features\n\n  * GET, POST, PUT, DELETE, HEAD, PATCH, OPTIONS, etc.\n  * Simple and chainable methods for settings and request\n  * [Request](https://pkg.go.dev/github.com/go-resty/resty/v2#Request) Body can be `string`, `[]byte`, `struct`, `map`, `slice` and `io.Reader` too\n    * Auto detects `Content-Type`\n    * Buffer less processing for `io.Reader`\n    * Native `*http.Request` instance may be accessed during middleware and request execution via `Request.RawRequest`\n    * Request Body can be read multiple times via `Request.RawRequest.GetBody()`\n  * [Response](https://pkg.go.dev/github.com/go-resty/resty/v2#Response) object gives you more possibility\n    * Access as `[]byte` array - `response.Body()` OR Access as `string` - `response.String()`\n    * Know your `response.Time()` and when we `response.ReceivedAt()`\n  * Automatic marshal and unmarshal for `JSON` and `XML` content type\n    * Default is `JSON`, if you supply `struct/map` without header `Content-Type`\n    * For auto-unmarshal, refer to -\n        - Success scenario [Request.SetResult()](https://pkg.go.dev/github.com/go-resty/resty/v2#Request.SetResult) and [Response.Result()](https://pkg.go.dev/github.com/go-resty/resty/v2#Response.Result).\n        - Error scenario [Request.SetError()](https://pkg.go.dev/github.com/go-resty/resty/v2#Request.SetError) and [Response.Error()](https://pkg.go.dev/github.com/go-resty/resty/v2#Response.Error).\n        - Supports [RFC7807](https://tools.ietf.org/html/rfc7807) - `application/problem+json` & `application/problem+xml`\n    * Resty provides an option to override [JSON Marshal/Unmarshal and XML Marshal/Unmarshal](#override-json--xml-marshalunmarshal)\n  * Easy to upload one or more file(s) via `multipart/form-data`\n    * Auto detects file content type\n  * Request URL [Path Params (aka URI Params)](https://pkg.go.dev/github.com/go-resty/resty/v2#Request.SetPathParams)\n  * Backoff Retry Mechanism with retry condition function [reference](retry_test.go)\n  * Resty client HTTP & REST [Request](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.OnBeforeRequest) and [Response](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.OnAfterResponse) middlewares\n  * `Request.SetContext` supported\n  * Authorization option of `BasicAuth` and `Bearer` token\n  * Set request `ContentLength` value for all request or particular request\n  * Custom [Root Certificates](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.SetRootCertificate) and Client [Certificates](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.SetCertificates)\n  * Download/Save HTTP response directly into File, like `curl -o` flag. See [SetOutputDirectory](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.SetOutputDirectory) & [SetOutput](https://pkg.go.dev/github.com/go-resty/resty/v2#Request.SetOutput).\n  * Cookies for your request and CookieJar support\n  * SRV Record based request instead of Host URL\n  * Client settings like `Timeout`, `RedirectPolicy`, `Proxy`, `TLSClientConfig`, `Transport`, etc.\n  * Optionally allows GET request with payload, see [SetAllowGetMethodPayload](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.SetAllowGetMethodPayload)\n  * Supports registering external JSON library into resty, see [how to use](https://github.com/go-resty/resty/issues/76#issuecomment-314015250)\n  * Exposes Response reader without reading response (no auto-unmarshaling) if need be, see [how to use](https://github.com/go-resty/resty/issues/87#issuecomment-322100604)\n  * Option to specify expected `Content-Type` when response `Content-Type` header missing. Refer to [#92](https://github.com/go-resty/resty/issues/92)\n  * Resty design\n    * Have client level settings & options and also override at Request level if you want to\n    * Request and Response middleware\n    * Create Multiple clients if you want to `resty.New()`\n    * Supports `http.RoundTripper` implementation, see [SetTransport](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.SetTransport)\n    * goroutine concurrent safe\n    * Resty Client trace, see [Client.EnableTrace](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.EnableTrace) and [Request.EnableTrace](https://pkg.go.dev/github.com/go-resty/resty/v2#Request.EnableTrace)\n      * Since v2.4.0, trace info contains a `RequestAttempt` value, and the `Request` object contains an `Attempt` attribute\n    * Supports on-demand CURL command generation, see [Client.EnableGenerateCurlOnDebug](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.EnableGenerateCurlOnDebug), [Request.EnableGenerateCurlOnDebug](https://pkg.go.dev/github.com/go-resty/resty/v2#Request.EnableGenerateCurlOnDebug). It requires debug mode to be enabled.\n    * Debug mode - clean and informative logging presentation\n    * Gzip - Go does it automatically also resty has fallback handling too\n    * Works fine with `HTTP/2` and `HTTP/1.1`, also `HTTP/3` can be used with Resty, see this [comment](https://github.com/go-resty/resty/issues/846#issuecomment-2329696110)\n  * [Bazel support](#bazel-support)\n  * Easily mock Resty for testing, [for e.g.](#mocking-http-requests-using-httpmock-library)\n  * Well tested client library\n\n### Included Batteries\n\n  * Redirect Policies - see [how to use](#redirect-policy)\n    * NoRedirectPolicy\n    * FlexibleRedirectPolicy\n    * DomainCheckRedirectPolicy\n    * etc. [more info](redirect.go)\n  * Retry Mechanism [how to use](#retries)\n    * Backoff Retry\n    * Conditional Retry\n    * Since v2.6.0, Retry Hooks - [Client](https://pkg.go.dev/github.com/go-resty/resty/v2#Client.AddRetryHook), [Request](https://pkg.go.dev/github.com/go-resty/resty/v2#Request.AddRetryHook)\n  * SRV Record based request instead of Host URL [how to use](resty_test.go#L1412)\n  * etc (upcoming - throw your idea's [here](https://github.com/go-resty/resty/issues)).\n\n\n#### Supported Go Versions\n\nRecommended to use `go1.20` and above.\n\nInitially Resty started supporting `go modules` since `v1.10.0` release.\n\nStarting Resty v2 and higher versions, it fully embraces [go modules](https://github.com/golang/go/wiki/Modules) package release. It requires a Go version capable of understanding `/vN` suffixed imports:\n\n- 1.9.7+\n- 1.10.3+\n- 1.11+\n\n\n## It might be beneficial for your project :smile:\n\nResty author also published following projects for Go Community.\n\n  * [go-model](https://github.com/jeevatkm/go-model) - Robust & Easy to use model mapper and utility methods for Go `struct`.\n\n\n## Installation\n\n```bash\n# Go Modules\nrequire github.com/go-resty/resty/v2 v2.16.3\n```\n\n## Usage\n\nThe following samples will assist you to become as comfortable as possible with resty library.\n\n```go\n// Import resty into your code and refer it as `resty`.\nimport \"github.com/go-resty/resty/v2\"\n```\n\n#### Simple GET\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\nresp, err := client.R().\n    EnableTrace().\n    Get(\"https://httpbin.org/get\")\n\n// Explore response object\nfmt.Println(\"Response Info:\")\nfmt.Println(\"  Error      :\", err)\nfmt.Println(\"  Status Code:\", resp.StatusCode())\nfmt.Println(\"  Status     :\", resp.Status())\nfmt.Println(\"  Proto      :\", resp.Proto())\nfmt.Println(\"  Time       :\", resp.Time())\nfmt.Println(\"  Received At:\", resp.ReceivedAt())\nfmt.Println(\"  Body       :\\n\", resp)\nfmt.Println()\n\n// Explore trace info\nfmt.Println(\"Request Trace Info:\")\nti := resp.Request.TraceInfo()\nfmt.Println(\"  DNSLookup     :\", ti.DNSLookup)\nfmt.Println(\"  ConnTime      :\", ti.ConnTime)\nfmt.Println(\"  TCPConnTime   :\", ti.TCPConnTime)\nfmt.Println(\"  TLSHandshake  :\", ti.TLSHandshake)\nfmt.Println(\"  ServerTime    :\", ti.ServerTime)\nfmt.Println(\"  ResponseTime  :\", ti.ResponseTime)\nfmt.Println(\"  TotalTime     :\", ti.TotalTime)\nfmt.Println(\"  IsConnReused  :\", ti.IsConnReused)\nfmt.Println(\"  IsConnWasIdle :\", ti.IsConnWasIdle)\nfmt.Println(\"  ConnIdleTime  :\", ti.ConnIdleTime)\nfmt.Println(\"  RequestAttempt:\", ti.RequestAttempt)\nfmt.Println(\"  RemoteAddr    :\", ti.RemoteAddr.String())\n\n/* Output\nResponse Info:\n  Error      : <nil>\n  Status Code: 200\n  Status     : 200 OK\n  Proto      : HTTP/2.0\n  Time       : 457.034718ms\n  Received At: 2020-09-14 15:35:29.784681 -0700 PDT m=+0.458137045\n  Body       :\n  {\n    \"args\": {},\n    \"headers\": {\n      \"Accept-Encoding\": \"gzip\",\n      \"Host\": \"httpbin.org\",\n      \"User-Agent\": \"go-resty/2.4.0 (https://github.com/go-resty/resty)\",\n      \"X-Amzn-Trace-Id\": \"Root=1-5f5ff031-000ff6292204aa6898e4de49\"\n    },\n    \"origin\": \"0.0.0.0\",\n    \"url\": \"https://httpbin.org/get\"\n  }\n\nRequest Trace Info:\n  DNSLookup     : 4.074657ms\n  ConnTime      : 381.709936ms\n  TCPConnTime   : 77.428048ms\n  TLSHandshake  : 299.623597ms\n  ServerTime    : 75.414703ms\n  ResponseTime  : 79.337µs\n  TotalTime     : 457.034718ms\n  IsConnReused  : false\n  IsConnWasIdle : false\n  ConnIdleTime  : 0s\n  RequestAttempt: 1\n  RemoteAddr    : 3.221.81.55:443\n*/\n```\n\n#### Enhanced GET\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\nresp, err := client.R().\n      SetQueryParams(map[string]string{\n          \"page_no\": \"1\",\n          \"limit\": \"20\",\n          \"sort\":\"name\",\n          \"order\": \"asc\",\n          \"random\":strconv.FormatInt(time.Now().Unix(), 10),\n      }).\n      SetHeader(\"Accept\", \"application/json\").\n      SetAuthToken(\"BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\").\n      Get(\"/search_result\")\n\n\n// Sample of using Request.SetQueryString method\nresp, err := client.R().\n      SetQueryString(\"productId=232&template=fresh-sample&cat=resty&source=google&kw=buy a lot more\").\n      SetHeader(\"Accept\", \"application/json\").\n      SetAuthToken(\"BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\").\n      Get(\"/show_product\")\n\n\n// If necessary, you can force response content type to tell Resty to parse a JSON response into your struct\nresp, err := client.R().\n      SetResult(result).\n      ForceContentType(\"application/json\").\n      Get(\"v2/alpine/manifests/latest\")\n```\n\n#### Various POST method combinations\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// POST JSON string\n// No need to set content type, if you have client level setting\nresp, err := client.R().\n      SetHeader(\"Content-Type\", \"application/json\").\n      SetBody(`{\"username\":\"testuser\", \"password\":\"testpass\"}`).\n      SetResult(&AuthSuccess{}).    // or SetResult(AuthSuccess{}).\n      Post(\"https://myapp.com/login\")\n\n// POST []byte array\n// No need to set content type, if you have client level setting\nresp, err := client.R().\n      SetHeader(\"Content-Type\", \"application/json\").\n      SetBody([]byte(`{\"username\":\"testuser\", \"password\":\"testpass\"}`)).\n      SetResult(&AuthSuccess{}).    // or SetResult(AuthSuccess{}).\n      Post(\"https://myapp.com/login\")\n\n// POST Struct, default is JSON content type. No need to set one\nresp, err := client.R().\n      SetBody(User{Username: \"testuser\", Password: \"testpass\"}).\n      SetResult(&AuthSuccess{}).    // or SetResult(AuthSuccess{}).\n      SetError(&AuthError{}).       // or SetError(AuthError{}).\n      Post(\"https://myapp.com/login\")\n\n// POST Map, default is JSON content type. No need to set one\nresp, err := client.R().\n      SetBody(map[string]interface{}{\"username\": \"testuser\", \"password\": \"testpass\"}).\n      SetResult(&AuthSuccess{}).    // or SetResult(AuthSuccess{}).\n      SetError(&AuthError{}).       // or SetError(AuthError{}).\n      Post(\"https://myapp.com/login\")\n\n// POST of raw bytes for file upload. For example: upload file to Dropbox\nfileBytes, _ := os.ReadFile(\"/Users/jeeva/mydocument.pdf\")\n\n// See we are not setting content-type header, since go-resty automatically detects Content-Type for you\nresp, err := client.R().\n      SetBody(fileBytes).\n      SetContentLength(true).          // Dropbox expects this value\n      SetAuthToken(\"<your-auth-token>\").\n      SetError(&DropboxError{}).       // or SetError(DropboxError{}).\n      Post(\"https://content.dropboxapi.com/1/files_put/auto/resty/mydocument.pdf\") // for upload Dropbox supports PUT too\n\n// Note: resty detects Content-Type for request body/payload if content type header is not set.\n//   * For struct and map data type defaults to 'application/json'\n//   * Fallback is plain text content type\n```\n\n#### Sample PUT\n\nYou can use various combinations of `PUT` method call like demonstrated for `POST`.\n\n```go\n// Note: This is one sample of PUT method usage, refer POST for more combination\n\n// Create a Resty Client\nclient := resty.New()\n\n// Request goes as JSON content type\n// No need to set auth token, error, if you have client level settings\nresp, err := client.R().\n      SetBody(Article{\n        Title: \"go-resty\",\n        Content: \"This is my article content, oh ya!\",\n        Author: \"Jeevanandam M\",\n        Tags: []string{\"article\", \"sample\", \"resty\"},\n      }).\n      SetAuthToken(\"C6A79608-782F-4ED0-A11D-BD82FAD829CD\").\n      SetError(&Error{}).       // or SetError(Error{}).\n      Put(\"https://myapp.com/article/1234\")\n```\n\n#### Sample PATCH\n\nYou can use various combinations of `PATCH` method call like demonstrated for `POST`.\n\n```go\n// Note: This is one sample of PUT method usage, refer POST for more combination\n\n// Create a Resty Client\nclient := resty.New()\n\n// Request goes as JSON content type\n// No need to set auth token, error, if you have client level settings\nresp, err := client.R().\n      SetBody(Article{\n        Tags: []string{\"new tag1\", \"new tag2\"},\n      }).\n      SetAuthToken(\"C6A79608-782F-4ED0-A11D-BD82FAD829CD\").\n      SetError(&Error{}).       // or SetError(Error{}).\n      Patch(\"https://myapp.com/articles/1234\")\n```\n\n#### Sample DELETE, HEAD, OPTIONS\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// DELETE a article\n// No need to set auth token, error, if you have client level settings\nresp, err := client.R().\n      SetAuthToken(\"C6A79608-782F-4ED0-A11D-BD82FAD829CD\").\n      SetError(&Error{}).       // or SetError(Error{}).\n      Delete(\"https://myapp.com/articles/1234\")\n\n// DELETE a articles with payload/body as a JSON string\n// No need to set auth token, error, if you have client level settings\nresp, err := client.R().\n      SetAuthToken(\"C6A79608-782F-4ED0-A11D-BD82FAD829CD\").\n      SetError(&Error{}).       // or SetError(Error{}).\n      SetHeader(\"Content-Type\", \"application/json\").\n      SetBody(`{article_ids: [1002, 1006, 1007, 87683, 45432] }`).\n      Delete(\"https://myapp.com/articles\")\n\n// HEAD of resource\n// No need to set auth token, if you have client level settings\nresp, err := client.R().\n      SetAuthToken(\"C6A79608-782F-4ED0-A11D-BD82FAD829CD\").\n      Head(\"https://myapp.com/videos/hi-res-video\")\n\n// OPTIONS of resource\n// No need to set auth token, if you have client level settings\nresp, err := client.R().\n      SetAuthToken(\"C6A79608-782F-4ED0-A11D-BD82FAD829CD\").\n      Options(\"https://myapp.com/servers/nyc-dc-01\")\n```\n\n#### Override JSON & XML Marshal/Unmarshal\n\nUser could register choice of JSON/XML library into resty or write your own. By default resty registers standard `encoding/json` and `encoding/xml` respectively.\n```go\n// Example of registering json-iterator\nimport jsoniter \"github.com/json-iterator/go\"\n\njson := jsoniter.ConfigCompatibleWithStandardLibrary\n\nclient := resty.New().\n    SetJSONMarshaler(json.Marshal).\n    SetJSONUnmarshaler(json.Unmarshal)\n\n// similarly user could do for XML too with -\nclient.SetXMLMarshaler(xml.Marshal).\n    SetXMLUnmarshaler(xml.Unmarshal)\n```\n\n### Multipart File(s) upload\n\n#### Using io.Reader\n\n```go\nprofileImgBytes, _ := os.ReadFile(\"/Users/jeeva/test-img.png\")\nnotesBytes, _ := os.ReadFile(\"/Users/jeeva/text-file.txt\")\n\n// Create a Resty Client\nclient := resty.New()\n\nresp, err := client.R().\n      SetFileReader(\"profile_img\", \"test-img.png\", bytes.NewReader(profileImgBytes)).\n      SetFileReader(\"notes\", \"text-file.txt\", bytes.NewReader(notesBytes)).\n      SetFormData(map[string]string{\n          \"first_name\": \"Jeevanandam\",\n          \"last_name\": \"M\",\n      }).\n      Post(\"http://myapp.com/upload\")\n```\n\n#### Using File directly from Path\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Single file scenario\nresp, err := client.R().\n      SetFile(\"profile_img\", \"/Users/jeeva/test-img.png\").\n      Post(\"http://myapp.com/upload\")\n\n// Multiple files scenario\nresp, err := client.R().\n      SetFiles(map[string]string{\n        \"profile_img\": \"/Users/jeeva/test-img.png\",\n        \"notes\": \"/Users/jeeva/text-file.txt\",\n      }).\n      Post(\"http://myapp.com/upload\")\n\n// Multipart of form fields and files\nresp, err := client.R().\n      SetFiles(map[string]string{\n        \"profile_img\": \"/Users/jeeva/test-img.png\",\n        \"notes\": \"/Users/jeeva/text-file.txt\",\n      }).\n      SetFormData(map[string]string{\n        \"first_name\": \"Jeevanandam\",\n        \"last_name\": \"M\",\n        \"zip_code\": \"00001\",\n        \"city\": \"my city\",\n        \"access_token\": \"C6A79608-782F-4ED0-A11D-BD82FAD829CD\",\n      }).\n      Post(\"http://myapp.com/profile\")\n```\n\n#### Sample Form submission\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// just mentioning about POST as an example with simple flow\n// User Login\nresp, err := client.R().\n      SetFormData(map[string]string{\n        \"username\": \"jeeva\",\n        \"password\": \"mypass\",\n      }).\n      Post(\"http://myapp.com/login\")\n\n// Followed by profile update\nresp, err := client.R().\n      SetFormData(map[string]string{\n        \"first_name\": \"Jeevanandam\",\n        \"last_name\": \"M\",\n        \"zip_code\": \"00001\",\n        \"city\": \"new city update\",\n      }).\n      Post(\"http://myapp.com/profile\")\n\n// Multi value form data\ncriteria := url.Values{\n  \"search_criteria\": []string{\"book\", \"glass\", \"pencil\"},\n}\nresp, err := client.R().\n      SetFormDataFromValues(criteria).\n      Post(\"http://myapp.com/search\")\n```\n\n#### Save HTTP Response into File\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Setting output directory path, If directory not exists then resty creates one!\n// This is optional one, if you're planning using absolute path in\n// `Request.SetOutput` and can used together.\nclient.SetOutputDirectory(\"/Users/jeeva/Downloads\")\n\n// HTTP response gets saved into file, similar to curl -o flag\n_, err := client.R().\n          SetOutput(\"plugin/ReplyWithHeader-v5.1-beta.zip\").\n          Get(\"http://bit.ly/1LouEKr\")\n\n// OR using absolute path\n// Note: output directory path is not used for absolute path\n_, err := client.R().\n          SetOutput(\"/MyDownloads/plugin/ReplyWithHeader-v5.1-beta.zip\").\n          Get(\"http://bit.ly/1LouEKr\")\n```\n\n#### Request URL Path Params\n\nResty provides easy to use dynamic request URL path params. Params can be set at client and request level. Client level params value can be overridden at request level.\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\nclient.R().SetPathParams(map[string]string{\n   \"userId\": \"sample@sample.com\",\n   \"subAccountId\": \"100002\",\n}).\nGet(\"/v1/users/{userId}/{subAccountId}/details\")\n\n// Result:\n//   Composed URL - /v1/users/sample@sample.com/100002/details\n```\n\n#### Request and Response Middleware\n\nResty provides middleware ability to manipulate for Request and Response. It is more flexible than callback approach.\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Registering Request Middleware\nclient.OnBeforeRequest(func(c *resty.Client, req *resty.Request) error {\n    // Now you have access to Client and current Request object\n    // manipulate it as per your need\n\n    return nil  // if its success otherwise return error\n  })\n\n// Registering Response Middleware\nclient.OnAfterResponse(func(c *resty.Client, resp *resty.Response) error {\n    // Now you have access to Client and current Response object\n    // manipulate it as per your need\n\n    return nil  // if its success otherwise return error\n  })\n```\n\n#### OnError Hooks\n\nResty provides OnError hooks that may be called because:\n\n- The client failed to send the request due to connection timeout, TLS handshake failure, etc...\n- The request was retried the maximum amount of times, and still failed.\n\nIf there was a response from the server, the original error will be wrapped in `*resty.ResponseError` which contains the last response received.\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\nclient.OnError(func(req *resty.Request, err error) {\n  if v, ok := err.(*resty.ResponseError); ok {\n    // v.Response contains the last response from the server\n    // v.Err contains the original error\n  }\n  // Log the error, increment a metric, etc...\n})\n```\n\n#### Generate CURL Command\n>Refer: [curl_cmd_test.go](https://github.com/go-resty/resty/blob/v2/curl_cmd_test.go)\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\nresp, err := client.R().\n    SetDebug(true).\n    EnableGenerateCurlOnDebug(). // CURL command generated when debug mode enabled with this option\n    SetBody(map[string]string{\"name\": \"Alex\"}).\n    Post(\"https://httpbin.org/post\")\n\ncurlCmdExecuted := resp.Request.GenerateCurlCommand()\n\n// Explore curl command\nfmt.Println(\"Curl Command:\\n  \", curlCmdExecuted+\"\\n\")\n\n/* Output\nCurl Command:\n   curl -X POST -H 'Content-Type: application/json' -H 'User-Agent: go-resty/2.14.0 (https://github.com/go-resty/resty)' -d '{\"name\":\"Alex\"}' https://httpbin.org/post\n*/\n```\n\n#### Redirect Policy\n\nResty provides few ready to use redirect policy(s) also it supports multiple policies together.\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Assign Client Redirect Policy. Create one as per you need\nclient.SetRedirectPolicy(resty.FlexibleRedirectPolicy(15))\n\n// Wanna multiple policies such as redirect count, domain name check, etc\nclient.SetRedirectPolicy(resty.FlexibleRedirectPolicy(20),\n                        resty.DomainCheckRedirectPolicy(\"host1.com\", \"host2.org\", \"host3.net\"))\n```\n\n##### Custom Redirect Policy\n\nImplement [RedirectPolicy](redirect.go#L20) interface and register it with resty client. Have a look [redirect.go](redirect.go) for more information.\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Using raw func into resty.SetRedirectPolicy\nclient.SetRedirectPolicy(resty.RedirectPolicyFunc(func(req *http.Request, via []*http.Request) error {\n  // Implement your logic here\n\n  // return nil for continue redirect otherwise return error to stop/prevent redirect\n  return nil\n}))\n\n//---------------------------------------------------\n\n// Using struct create more flexible redirect policy\ntype CustomRedirectPolicy struct {\n  // variables goes here\n}\n\nfunc (c *CustomRedirectPolicy) Apply(req *http.Request, via []*http.Request) error {\n  // Implement your logic here\n\n  // return nil for continue redirect otherwise return error to stop/prevent redirect\n  return nil\n}\n\n// Registering in resty\nclient.SetRedirectPolicy(CustomRedirectPolicy{/* initialize variables */})\n```\n\n#### Custom Root Certificates and Client Certificates\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Custom Root certificates, just supply .pem file.\n// you can add one or more root certificates, its get appended\nclient.SetRootCertificate(\"/path/to/root/pemFile1.pem\")\nclient.SetRootCertificate(\"/path/to/root/pemFile2.pem\")\n// ... and so on!\n\n// Adding Client Certificates, you add one or more certificates\n// Sample for creating certificate object\n// Parsing public/private key pair from a pair of files. The files must contain PEM encoded data.\ncert1, err := tls.LoadX509KeyPair(\"certs/client.pem\", \"certs/client.key\")\nif err != nil {\n  log.Fatalf(\"ERROR client certificate: %s\", err)\n}\n// ...\n\n// You add one or more certificates\nclient.SetCertificates(cert1, cert2, cert3)\n```\n\n#### Custom Root Certificates and Client Certificates from string\n\n```go\n// Custom Root certificates from string\n// You can pass you certificates through env variables as strings\n// you can add one or more root certificates, its get appended\nclient.SetRootCertificateFromString(\"-----BEGIN CERTIFICATE-----content-----END CERTIFICATE-----\")\nclient.SetRootCertificateFromString(\"-----BEGIN CERTIFICATE-----content-----END CERTIFICATE-----\")\n// ... and so on!\n\n// Adding Client Certificates, you add one or more certificates\n// Sample for creating certificate object\n// Parsing public/private key pair from a pair of files. The files must contain PEM encoded data.\ncert1, err := tls.X509KeyPair([]byte(\"-----BEGIN CERTIFICATE-----content-----END CERTIFICATE-----\"), []byte(\"-----BEGIN CERTIFICATE-----content-----END CERTIFICATE-----\"))\nif err != nil {\n  log.Fatalf(\"ERROR client certificate: %s\", err)\n}\n// ...\n\n// You add one or more certificates\nclient.SetCertificates(cert1, cert2, cert3)\n```\n\n#### Proxy Settings\n\nDefault `Go` supports Proxy via environment variable `HTTP_PROXY`. Resty provides support via `SetProxy` & `RemoveProxy`.\nChoose as per your need.\n\n**Client Level Proxy** settings applied to all the request\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Setting a Proxy URL and Port\nclient.SetProxy(\"http://proxyserver:8888\")\n\n// Want to remove proxy setting\nclient.RemoveProxy()\n```\n\n#### Retries\n\nResty uses [backoff](http://www.awsarchitectureblog.com/2015/03/backoff.html)\nto increase retry intervals after each attempt.\n\nUsage example:\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Retries are configured per client\nclient.\n    // Set retry count to non zero to enable retries\n    SetRetryCount(3).\n    // You can override initial retry wait time.\n    // Default is 100 milliseconds.\n    SetRetryWaitTime(5 * time.Second).\n    // MaxWaitTime can be overridden as well.\n    // Default is 2 seconds.\n    SetRetryMaxWaitTime(20 * time.Second).\n    // SetRetryAfter sets callback to calculate wait time between retries.\n    // Default (nil) implies exponential backoff with jitter\n    SetRetryAfter(func(client *resty.Client, resp *resty.Response) (time.Duration, error) {\n        return 0, errors.New(\"quota exceeded\")\n    })\n```\n\nBy default, resty will retry requests that return a non-nil error during execution.\nTherefore, the above setup will result in resty retrying requests with non-nil errors up to 3 times,\nwith the delay increasing after each attempt.\n\nYou can optionally provide client with [custom retry conditions](https://pkg.go.dev/github.com/go-resty/resty/v2#RetryConditionFunc):\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\nclient.AddRetryCondition(\n    // RetryConditionFunc type is for retry condition function\n    // input: non-nil Response OR request execution error\n    func(r *resty.Response, err error) bool {\n        return r.StatusCode() == http.StatusTooManyRequests\n    },\n)\n```\n\nThe above example will make resty retry requests that end with a `429 Too Many Requests` status code.\nIt's important to note that when you specify conditions using `AddRetryCondition`,\nit will override the default retry behavior, which retries on errors encountered during the request.\nIf you want to retry on errors encountered during the request, similar to the default behavior,\nyou'll need to configure it as follows:\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\nclient.AddRetryCondition(\n    func(r *resty.Response, err error) bool {\n        // Including \"err != nil\" emulates the default retry behavior for errors encountered during the request.\n        return err != nil || r.StatusCode() == http.StatusTooManyRequests\n    },\n)\n```\n\nMultiple retry conditions can be added.\nNote that if multiple conditions are specified, a retry will occur if any of the conditions are met.\n\nIt is also possible to use `resty.Backoff(...)` to get arbitrary retry scenarios\nimplemented. [Reference](retry_test.go).\n\n#### Allow GET request with Payload\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Allow GET request with Payload. This is disabled by default.\nclient.SetAllowGetMethodPayload(true)\n```\n\n#### Wanna Multiple Clients\n\n```go\n// Here you go!\n// Client 1\nclient1 := resty.New()\nclient1.R().Get(\"http://httpbin.org\")\n// ...\n\n// Client 2\nclient2 := resty.New()\nclient2.R().Head(\"http://httpbin.org\")\n// ...\n\n// Bend it as per your need!!!\n```\n\n#### Remaining Client Settings & its Options\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Unique settings at Client level\n//--------------------------------\n// Enable debug mode\nclient.SetDebug(true)\n\n// Assign Client TLSClientConfig\n// One can set custom root-certificate. Refer: http://golang.org/pkg/crypto/tls/#example_Dial\nclient.SetTLSClientConfig(&tls.Config{ RootCAs: roots })\n\n// or One can disable security check (https)\nclient.SetTLSClientConfig(&tls.Config{ InsecureSkipVerify: true })\n\n// Set client timeout as per your need\nclient.SetTimeout(1 * time.Minute)\n\n\n// You can override all below settings and options at request level if you want to\n//--------------------------------------------------------------------------------\n// Host URL for all request. So you can use relative URL in the request\nclient.SetBaseURL(\"http://httpbin.org\")\n\n// Headers for all request\nclient.SetHeader(\"Accept\", \"application/json\")\nclient.SetHeaders(map[string]string{\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": \"My custom User Agent String\",\n      })\n\n// Cookies for all request\nclient.SetCookie(&http.Cookie{\n      Name:\"go-resty\",\n      Value:\"This is cookie value\",\n      Path: \"/\",\n      Domain: \"sample.com\",\n      MaxAge: 36000,\n      HttpOnly: true,\n      Secure: false,\n    })\nclient.SetCookies(cookies)\n\n// URL query parameters for all request\nclient.SetQueryParam(\"user_id\", \"00001\")\nclient.SetQueryParams(map[string]string{ // sample of those who use this manner\n      \"api_key\": \"api-key-here\",\n      \"api_secret\": \"api-secret\",\n    })\nclient.R().SetQueryString(\"productId=232&template=fresh-sample&cat=resty&source=google&kw=buy a lot more\")\n\n// Form data for all request. Typically used with POST and PUT\nclient.SetFormData(map[string]string{\n    \"access_token\": \"BC594900-518B-4F7E-AC75-BD37F019E08F\",\n  })\n\n// Basic Auth for all request\nclient.SetBasicAuth(\"myuser\", \"mypass\")\n\n// Bearer Auth Token for all request\nclient.SetAuthToken(\"BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\")\n\n// Enabling Content length value for all request\nclient.SetContentLength(true)\n\n// Registering global Error object structure for JSON/XML request\nclient.SetError(&Error{})    // or resty.SetError(Error{})\n```\n\n#### Unix Socket\n\n```go\nunixSocket := \"/var/run/my_socket.sock\"\n\n// Create a Go's http.Transport so we can set it in resty.\ntransport := http.Transport{\n\tDial: func(_, _ string) (net.Conn, error) {\n\t\treturn net.Dial(\"unix\", unixSocket)\n\t},\n}\n\n// Create a Resty Client\nclient := resty.New()\n\n// Set the previous transport that we created, set the scheme of the communication to the\n// socket and set the unixSocket as the HostURL.\nclient.SetTransport(&transport).SetScheme(\"http\").SetBaseURL(unixSocket)\n\n// No need to write the host's URL on the request, just the path.\nclient.R().Get(\"http://localhost/index.html\")\n```\n\n#### Bazel Support\n\nResty can be built, tested and depended upon via [Bazel](https://bazel.build).\nFor example, to run all tests:\n\n```shell\nbazel test :resty_test\n```\n\n#### Mocking http requests using [httpmock](https://github.com/jarcoal/httpmock) library\n\nIn order to mock the http requests when testing your application you\ncould use the `httpmock` library.\n\nWhen using the default resty client, you should pass the client to the library as follow:\n\n```go\n// Create a Resty Client\nclient := resty.New()\n\n// Get the underlying HTTP Client and set it to Mock\nhttpmock.ActivateNonDefault(client.GetClient())\n```\n\nMore detailed example of mocking resty http requests using ginko could be found [here](https://github.com/jarcoal/httpmock#ginkgo--resty-example).\n\n## Versioning\n\nResty releases versions according to [Semantic Versioning](http://semver.org)\n\n  * Resty v2 does not use `gopkg.in` service for library versioning.\n  * Resty fully adapted to `go mod` capabilities since `v1.10.0` release.\n  * Resty v1 series was using `gopkg.in` to provide versioning. `gopkg.in/resty.vX` points to appropriate tagged versions; `X` denotes version series number and it's a stable release for production use. For e.g. `gopkg.in/resty.v0`.\n  * Development takes place at the master branch. Although the code in master should always compile and test successfully, it might break API's. I aim to maintain backwards compatibility, but sometimes API's and behavior might be changed to fix a bug.\n\n## Contribution\n\nI would welcome your contribution! If you find any improvement or issue you want to fix, feel free to send a pull request, I like pull requests that include test cases for fix/enhancement. I have done my best to bring pretty good code coverage. Feel free to write tests.\n\nBTW, I'd like to know what you think about `Resty`. Kindly open an issue or send me an email; it'd mean a lot to me.\n\n## Creator\n\n[Jeevanandam M.](https://github.com/jeevatkm) (jeeva@myjeeva.com)\n\n## Core Team\n\nHave a look on [Members](https://github.com/orgs/go-resty/people) page.\n\n## Contributors\n\nHave a look on [Contributors](https://github.com/go-resty/resty/graphs/contributors) page.\n\n## License\n\nResty released under MIT license, refer [LICENSE](LICENSE) file.\n"
        },
        {
          "name": "WORKSPACE",
          "type": "blob",
          "size": 1.060546875,
          "content": "workspace(name = \"resty\")\n\nload(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\n\nhttp_archive(\n    name = \"io_bazel_rules_go\",\n    sha256 = \"80a98277ad1311dacd837f9b16db62887702e9f1d1c4c9f796d0121a46c8e184\",\n    urls = [\n        \"https://mirror.bazel.build/github.com/bazelbuild/rules_go/releases/download/v0.46.0/rules_go-v0.46.0.zip\",\n        \"https://github.com/bazelbuild/rules_go/releases/download/v0.46.0/rules_go-v0.46.0.zip\",\n    ],\n)\n\nhttp_archive(\n    name = \"bazel_gazelle\",\n    sha256 = \"62ca106be173579c0a167deb23358fdfe71ffa1e4cfdddf5582af26520f1c66f\",\n    urls = [\n        \"https://mirror.bazel.build/github.com/bazelbuild/bazel-gazelle/releases/download/v0.23.0/bazel-gazelle-v0.23.0.tar.gz\",\n        \"https://github.com/bazelbuild/bazel-gazelle/releases/download/v0.23.0/bazel-gazelle-v0.23.0.tar.gz\",\n    ],\n)\n\nload(\"@io_bazel_rules_go//go:deps.bzl\", \"go_register_toolchains\", \"go_rules_dependencies\")\n\ngo_rules_dependencies()\n\ngo_register_toolchains(version = \"1.19\")\n\nload(\"@bazel_gazelle//:deps.bzl\", \"gazelle_dependencies\")\n\ngazelle_dependencies()\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 46.546875,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\t// MethodGet HTTP method\n\tMethodGet = \"GET\"\n\n\t// MethodPost HTTP method\n\tMethodPost = \"POST\"\n\n\t// MethodPut HTTP method\n\tMethodPut = \"PUT\"\n\n\t// MethodDelete HTTP method\n\tMethodDelete = \"DELETE\"\n\n\t// MethodPatch HTTP method\n\tMethodPatch = \"PATCH\"\n\n\t// MethodHead HTTP method\n\tMethodHead = \"HEAD\"\n\n\t// MethodOptions HTTP method\n\tMethodOptions = \"OPTIONS\"\n)\n\nvar (\n\thdrUserAgentKey       = http.CanonicalHeaderKey(\"User-Agent\")\n\thdrAcceptKey          = http.CanonicalHeaderKey(\"Accept\")\n\thdrContentTypeKey     = http.CanonicalHeaderKey(\"Content-Type\")\n\thdrContentLengthKey   = http.CanonicalHeaderKey(\"Content-Length\")\n\thdrContentEncodingKey = http.CanonicalHeaderKey(\"Content-Encoding\")\n\thdrLocationKey        = http.CanonicalHeaderKey(\"Location\")\n\thdrAuthorizationKey   = http.CanonicalHeaderKey(\"Authorization\")\n\thdrWwwAuthenticateKey = http.CanonicalHeaderKey(\"WWW-Authenticate\")\n\n\tplainTextType   = \"text/plain; charset=utf-8\"\n\tjsonContentType = \"application/json\"\n\tformContentType = \"application/x-www-form-urlencoded\"\n\n\tjsonCheck = regexp.MustCompile(`(?i:(application|text)/(.*json.*)(;|$))`)\n\txmlCheck  = regexp.MustCompile(`(?i:(application|text)/(.*xml.*)(;|$))`)\n\n\thdrUserAgentValue = \"go-resty/\" + Version + \" (https://github.com/go-resty/resty)\"\n\tbufPool           = &sync.Pool{New: func() interface{} { return &bytes.Buffer{} }}\n)\n\ntype (\n\t// RequestMiddleware type is for request middleware, called before a request is sent\n\tRequestMiddleware func(*Client, *Request) error\n\n\t// ResponseMiddleware type is for response middleware, called after a response has been received\n\tResponseMiddleware func(*Client, *Response) error\n\n\t// PreRequestHook type is for the request hook, called right before the request is sent\n\tPreRequestHook func(*Client, *http.Request) error\n\n\t// RequestLogCallback type is for request logs, called before the request is logged\n\tRequestLogCallback func(*RequestLog) error\n\n\t// ResponseLogCallback type is for response logs, called before the response is logged\n\tResponseLogCallback func(*ResponseLog) error\n\n\t// ErrorHook type is for reacting to request errors, called after all retries were attempted\n\tErrorHook func(*Request, error)\n\n\t// SuccessHook type is for reacting to request success\n\tSuccessHook func(*Client, *Response)\n)\n\n// Client struct is used to create a Resty client with client-level settings,\n// these settings apply to all the requests raised from the client.\n//\n// Resty also provides an option to override most of the client settings\n// at [Request] level.\ntype Client struct {\n\tBaseURL               string\n\tHostURL               string // Deprecated: use BaseURL instead. To be removed in v3.0.0 release.\n\tQueryParam            url.Values\n\tFormData              url.Values\n\tPathParams            map[string]string\n\tRawPathParams         map[string]string\n\tHeader                http.Header\n\tUserInfo              *User\n\tToken                 string\n\tAuthScheme            string\n\tCookies               []*http.Cookie\n\tError                 reflect.Type\n\tDebug                 bool\n\tDisableWarn           bool\n\tAllowGetMethodPayload bool\n\tRetryCount            int\n\tRetryWaitTime         time.Duration\n\tRetryMaxWaitTime      time.Duration\n\tRetryConditions       []RetryConditionFunc\n\tRetryHooks            []OnRetryFunc\n\tRetryAfter            RetryAfterFunc\n\tRetryResetReaders     bool\n\tJSONMarshal           func(v interface{}) ([]byte, error)\n\tJSONUnmarshal         func(data []byte, v interface{}) error\n\tXMLMarshal            func(v interface{}) ([]byte, error)\n\tXMLUnmarshal          func(data []byte, v interface{}) error\n\n\t// HeaderAuthorizationKey is used to set/access Request Authorization header\n\t// value when `SetAuthToken` option is used.\n\tHeaderAuthorizationKey string\n\tResponseBodyLimit      int\n\n\tjsonEscapeHTML      bool\n\tsetContentLength    bool\n\tcloseConnection     bool\n\tnotParseResponse    bool\n\ttrace               bool\n\tdebugBodySizeLimit  int64\n\toutputDirectory     string\n\tscheme              string\n\tlog                 Logger\n\thttpClient          *http.Client\n\tproxyURL            *url.URL\n\tbeforeRequest       []RequestMiddleware\n\tudBeforeRequest     []RequestMiddleware\n\tudBeforeRequestLock *sync.RWMutex\n\tpreReqHook          PreRequestHook\n\tsuccessHooks        []SuccessHook\n\tafterResponse       []ResponseMiddleware\n\tafterResponseLock   *sync.RWMutex\n\trequestLog          RequestLogCallback\n\tresponseLog         ResponseLogCallback\n\terrorHooks          []ErrorHook\n\tinvalidHooks        []ErrorHook\n\tpanicHooks          []ErrorHook\n\trateLimiter         RateLimiter\n\tgenerateCurlOnDebug bool\n\tunescapeQueryParams bool\n}\n\n// User type is to hold an username and password information\ntype User struct {\n\tUsername, Password string\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Client methods\n//___________________________________\n\n// SetHostURL method sets the Host URL in the client instance. It will be used with a request\n// raised from this client with a relative URL\n//\n//\t// Setting HTTP address\n//\tclient.SetHostURL(\"http://myjeeva.com\")\n//\n//\t// Setting HTTPS address\n//\tclient.SetHostURL(\"https://myjeeva.com\")\n//\n// Deprecated: use [Client.SetBaseURL] instead. To be removed in the v3.0.0 release.\nfunc (c *Client) SetHostURL(url string) *Client {\n\tc.SetBaseURL(url)\n\treturn c\n}\n\n// SetBaseURL method sets the Base URL in the client instance. It will be used with a request\n// raised from this client with a relative URL\n//\n//\t// Setting HTTP address\n//\tclient.SetBaseURL(\"http://myjeeva.com\")\n//\n//\t// Setting HTTPS address\n//\tclient.SetBaseURL(\"https://myjeeva.com\")\nfunc (c *Client) SetBaseURL(url string) *Client {\n\tc.BaseURL = strings.TrimRight(url, \"/\")\n\tc.HostURL = c.BaseURL\n\treturn c\n}\n\n// SetHeader method sets a single header field and its value in the client instance.\n// These headers will be applied to all requests from this client instance.\n// Also, it can be overridden by request-level header options.\n//\n// See [Request.SetHeader] or [Request.SetHeaders].\n//\n// For Example: To set `Content-Type` and `Accept` as `application/json`\n//\n//\tclient.\n//\t\tSetHeader(\"Content-Type\", \"application/json\").\n//\t\tSetHeader(\"Accept\", \"application/json\")\nfunc (c *Client) SetHeader(header, value string) *Client {\n\tc.Header.Set(header, value)\n\treturn c\n}\n\n// SetHeaders method sets multiple header fields and their values at one go in the client instance.\n// These headers will be applied to all requests from this client instance. Also, it can be\n// overridden at request level headers options.\n//\n// See [Request.SetHeaders] or [Request.SetHeader].\n//\n// For Example: To set `Content-Type` and `Accept` as `application/json`\n//\n//\tclient.SetHeaders(map[string]string{\n//\t\t\t\"Content-Type\": \"application/json\",\n//\t\t\t\"Accept\": \"application/json\",\n//\t\t})\nfunc (c *Client) SetHeaders(headers map[string]string) *Client {\n\tfor h, v := range headers {\n\t\tc.Header.Set(h, v)\n\t}\n\treturn c\n}\n\n// SetHeaderVerbatim method sets a single header field and its value verbatim in the current request.\n//\n// For Example: To set `all_lowercase` and `UPPERCASE` as `available`.\n//\n//\tclient.\n//\t\tSetHeaderVerbatim(\"all_lowercase\", \"available\").\n//\t\tSetHeaderVerbatim(\"UPPERCASE\", \"available\")\nfunc (c *Client) SetHeaderVerbatim(header, value string) *Client {\n\tc.Header[header] = []string{value}\n\treturn c\n}\n\n// SetCookieJar method sets custom [http.CookieJar] in the resty client. It's a way to override the default.\n//\n// For Example, sometimes we don't want to save cookies in API mode so that we can remove the default\n// CookieJar in resty client.\n//\n//\tclient.SetCookieJar(nil)\nfunc (c *Client) SetCookieJar(jar http.CookieJar) *Client {\n\tc.httpClient.Jar = jar\n\treturn c\n}\n\n// SetCookie method appends a single cookie to the client instance.\n// These cookies will be added to all the requests from this client instance.\n//\n//\tclient.SetCookie(&http.Cookie{\n//\t\t\t\tName:\"go-resty\",\n//\t\t\t\tValue:\"This is cookie value\",\n//\t\t\t})\nfunc (c *Client) SetCookie(hc *http.Cookie) *Client {\n\tc.Cookies = append(c.Cookies, hc)\n\treturn c\n}\n\n// SetCookies method sets an array of cookies in the client instance.\n// These cookies will be added to all the requests from this client instance.\n//\n//\tcookies := []*http.Cookie{\n//\t\t&http.Cookie{\n//\t\t\tName:\"go-resty-1\",\n//\t\t\tValue:\"This is cookie 1 value\",\n//\t\t},\n//\t\t&http.Cookie{\n//\t\t\tName:\"go-resty-2\",\n//\t\t\tValue:\"This is cookie 2 value\",\n//\t\t},\n//\t}\n//\n//\t// Setting a cookies into resty\n//\tclient.SetCookies(cookies)\nfunc (c *Client) SetCookies(cs []*http.Cookie) *Client {\n\tc.Cookies = append(c.Cookies, cs...)\n\treturn c\n}\n\n// SetQueryParam method sets a single parameter and its value in the client instance.\n// It will be formed as a query string for the request.\n//\n//\tFor Example: `search=kitchen%20papers&size=large`\n//\n// In the URL after the `?` mark. These query params will be added to all the requests raised from\n// this client instance. Also, it can be overridden at the request level.\n//\n// See [Request.SetQueryParam] or [Request.SetQueryParams].\n//\n//\tclient.\n//\t\tSetQueryParam(\"search\", \"kitchen papers\").\n//\t\tSetQueryParam(\"size\", \"large\")\nfunc (c *Client) SetQueryParam(param, value string) *Client {\n\tc.QueryParam.Set(param, value)\n\treturn c\n}\n\n// SetQueryParams method sets multiple parameters and their values at one go in the client instance.\n// It will be formed as a query string for the request.\n//\n//\tFor Example: `search=kitchen%20papers&size=large`\n//\n// In the URL after the `?` mark. These query params will be added to all the requests raised from this\n// client instance. Also, it can be overridden at the request level.\n//\n// See [Request.SetQueryParams] or [Request.SetQueryParam].\n//\n//\tclient.SetQueryParams(map[string]string{\n//\t\t\t\"search\": \"kitchen papers\",\n//\t\t\t\"size\": \"large\",\n//\t\t})\nfunc (c *Client) SetQueryParams(params map[string]string) *Client {\n\tfor p, v := range params {\n\t\tc.SetQueryParam(p, v)\n\t}\n\treturn c\n}\n\n// SetUnescapeQueryParams method sets the unescape query parameters choice for request URL.\n// To prevent broken URL, resty replaces space (\" \") with \"+\" in the query parameters.\n//\n// See [Request.SetUnescapeQueryParams]\n//\n// NOTE: Request failure is possible due to non-standard usage of Unescaped Query Parameters.\nfunc (c *Client) SetUnescapeQueryParams(unescape bool) *Client {\n\tc.unescapeQueryParams = unescape\n\treturn c\n}\n\n// SetFormData method sets Form parameters and their values in the client instance.\n// It applies only to HTTP methods `POST` and `PUT`, and the request content type would be set as\n// `application/x-www-form-urlencoded`. These form data will be added to all the requests raised from\n// this client instance. Also, it can be overridden at the request level.\n//\n// See [Request.SetFormData].\n//\n//\tclient.SetFormData(map[string]string{\n//\t\t\t\"access_token\": \"BC594900-518B-4F7E-AC75-BD37F019E08F\",\n//\t\t\t\"user_id\": \"3455454545\",\n//\t\t})\nfunc (c *Client) SetFormData(data map[string]string) *Client {\n\tfor k, v := range data {\n\t\tc.FormData.Set(k, v)\n\t}\n\treturn c\n}\n\n// SetBasicAuth method sets the basic authentication header in the HTTP request. For Example:\n//\n//\tAuthorization: Basic <base64-encoded-value>\n//\n// For Example: To set the header for username \"go-resty\" and password \"welcome\"\n//\n//\tclient.SetBasicAuth(\"go-resty\", \"welcome\")\n//\n// This basic auth information is added to all requests from this client instance.\n// It can also be overridden at the request level.\n//\n// See [Request.SetBasicAuth].\nfunc (c *Client) SetBasicAuth(username, password string) *Client {\n\tc.UserInfo = &User{Username: username, Password: password}\n\treturn c\n}\n\n// SetAuthToken method sets the auth token of the `Authorization` header for all HTTP requests.\n// The default auth scheme is `Bearer`; it can be customized with the method [Client.SetAuthScheme]. For Example:\n//\n//\tAuthorization: <auth-scheme> <auth-token-value>\n//\n// For Example: To set auth token BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\n//\n//\tclient.SetAuthToken(\"BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\")\n//\n// This auth token gets added to all the requests raised from this client instance.\n// Also, it can be overridden at the request level.\n//\n// See [Request.SetAuthToken].\nfunc (c *Client) SetAuthToken(token string) *Client {\n\tc.Token = token\n\treturn c\n}\n\n// SetAuthScheme method sets the auth scheme type in the HTTP request. For Example:\n//\n//\tAuthorization: <auth-scheme-value> <auth-token-value>\n//\n// For Example: To set the scheme to use OAuth\n//\n//\tclient.SetAuthScheme(\"OAuth\")\n//\n// This auth scheme gets added to all the requests raised from this client instance.\n// Also, it can be overridden at the request level.\n//\n// Information about auth schemes can be found in [RFC 7235], IANA [HTTP Auth schemes].\n//\n// See [Request.SetAuthToken].\n//\n// [RFC 7235]: https://tools.ietf.org/html/rfc7235\n// [HTTP Auth schemes]: https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml#authschemes\nfunc (c *Client) SetAuthScheme(scheme string) *Client {\n\tc.AuthScheme = scheme\n\treturn c\n}\n\n// SetDigestAuth method sets the Digest Access auth scheme for the client. If a server responds with 401 and sends\n// a Digest challenge in the WWW-Authenticate Header, requests will be resent with the appropriate Authorization Header.\n//\n// For Example: To set the Digest scheme with user \"Mufasa\" and password \"Circle Of Life\"\n//\n//\tclient.SetDigestAuth(\"Mufasa\", \"Circle Of Life\")\n//\n// Information about Digest Access Authentication can be found in [RFC 7616].\n//\n// See [Request.SetDigestAuth].\n//\n// [RFC 7616]: https://datatracker.ietf.org/doc/html/rfc7616\nfunc (c *Client) SetDigestAuth(username, password string) *Client {\n\toldTransport := c.httpClient.Transport\n\tc.OnBeforeRequest(func(c *Client, _ *Request) error {\n\t\tc.httpClient.Transport = &digestTransport{\n\t\t\tdigestCredentials: digestCredentials{username, password},\n\t\t\ttransport:         oldTransport,\n\t\t}\n\t\treturn nil\n\t})\n\tc.OnAfterResponse(func(c *Client, _ *Response) error {\n\t\tc.httpClient.Transport = oldTransport\n\t\treturn nil\n\t})\n\treturn c\n}\n\n// R method creates a new request instance; it's used for Get, Post, Put, Delete, Patch, Head, Options, etc.\nfunc (c *Client) R() *Request {\n\tr := &Request{\n\t\tQueryParam:    url.Values{},\n\t\tFormData:      url.Values{},\n\t\tHeader:        http.Header{},\n\t\tCookies:       make([]*http.Cookie, 0),\n\t\tPathParams:    map[string]string{},\n\t\tRawPathParams: map[string]string{},\n\t\tDebug:         c.Debug,\n\n\t\tclient:              c,\n\t\tmultipartFiles:      []*File{},\n\t\tmultipartFields:     []*MultipartField{},\n\t\tjsonEscapeHTML:      c.jsonEscapeHTML,\n\t\tlog:                 c.log,\n\t\tresponseBodyLimit:   c.ResponseBodyLimit,\n\t\tgenerateCurlOnDebug: c.generateCurlOnDebug,\n\t\tunescapeQueryParams: c.unescapeQueryParams,\n\t}\n\treturn r\n}\n\n// NewRequest method is an alias for method `R()`.\nfunc (c *Client) NewRequest() *Request {\n\treturn c.R()\n}\n\n// OnBeforeRequest method appends a request middleware to the before request chain.\n// The user-defined middlewares are applied before the default Resty request middlewares.\n// After all middlewares have been applied, the request is sent from Resty to the host server.\n//\n//\tclient.OnBeforeRequest(func(c *resty.Client, r *resty.Request) error {\n//\t\t\t// Now you have access to the Client and Request instance\n//\t\t\t// manipulate it as per your need\n//\n//\t\t\treturn nil \t// if its successful otherwise return error\n//\t\t})\nfunc (c *Client) OnBeforeRequest(m RequestMiddleware) *Client {\n\tc.udBeforeRequestLock.Lock()\n\tdefer c.udBeforeRequestLock.Unlock()\n\n\tc.udBeforeRequest = append(c.udBeforeRequest, m)\n\n\treturn c\n}\n\n// OnAfterResponse method appends response middleware to the after-response chain.\n// Once we receive a response from the host server, the default Resty response middleware\n// gets applied, and then the user-assigned response middleware is applied.\n//\n//\tclient.OnAfterResponse(func(c *resty.Client, r *resty.Response) error {\n//\t\t\t// Now you have access to the Client and Response instance\n//\t\t\t// manipulate it as per your need\n//\n//\t\t\treturn nil \t// if its successful otherwise return error\n//\t\t})\nfunc (c *Client) OnAfterResponse(m ResponseMiddleware) *Client {\n\tc.afterResponseLock.Lock()\n\tdefer c.afterResponseLock.Unlock()\n\n\tc.afterResponse = append(c.afterResponse, m)\n\n\treturn c\n}\n\n// OnError method adds a callback that will be run whenever a request execution fails.\n// This is called after all retries have been attempted (if any).\n// If there was a response from the server, the error will be wrapped in [ResponseError]\n// which has the last response received from the server.\n//\n//\tclient.OnError(func(req *resty.Request, err error) {\n//\t\tif v, ok := err.(*resty.ResponseError); ok {\n//\t\t\t// Do something with v.Response\n//\t\t}\n//\t\t// Log the error, increment a metric, etc...\n//\t})\n//\n// Out of the [Client.OnSuccess], [Client.OnError], [Client.OnInvalid], [Client.OnPanic]\n// callbacks, exactly one set will be invoked for each call to [Request.Execute] that completes.\nfunc (c *Client) OnError(h ErrorHook) *Client {\n\tc.errorHooks = append(c.errorHooks, h)\n\treturn c\n}\n\n// OnSuccess method adds a callback that will be run whenever a request execution\n// succeeds.  This is called after all retries have been attempted (if any).\n//\n// Out of the [Client.OnSuccess], [Client.OnError], [Client.OnInvalid], [Client.OnPanic]\n// callbacks, exactly one set will be invoked for each call to [Request.Execute] that completes.\nfunc (c *Client) OnSuccess(h SuccessHook) *Client {\n\tc.successHooks = append(c.successHooks, h)\n\treturn c\n}\n\n// OnInvalid method adds a callback that will be run whenever a request execution\n// fails before it starts because the request is invalid.\n//\n// Out of the [Client.OnSuccess], [Client.OnError], [Client.OnInvalid], [Client.OnPanic]\n// callbacks, exactly one set will be invoked for each call to [Request.Execute] that completes.\nfunc (c *Client) OnInvalid(h ErrorHook) *Client {\n\tc.invalidHooks = append(c.invalidHooks, h)\n\treturn c\n}\n\n// OnPanic method adds a callback that will be run whenever a request execution\n// panics.\n//\n// Out of the [Client.OnSuccess], [Client.OnError], [Client.OnInvalid], [Client.OnPanic]\n// callbacks, exactly one set will be invoked for each call to [Request.Execute] that completes.\n//\n// If an [Client.OnSuccess], [Client.OnError], or [Client.OnInvalid] callback panics,\n// then exactly one rule can be violated.\nfunc (c *Client) OnPanic(h ErrorHook) *Client {\n\tc.panicHooks = append(c.panicHooks, h)\n\treturn c\n}\n\n// SetPreRequestHook method sets the given pre-request function into a resty client.\n// It is called right before the request is fired.\n//\n// NOTE: Only one pre-request hook can be registered. Use [Client.OnBeforeRequest] for multiple.\nfunc (c *Client) SetPreRequestHook(h PreRequestHook) *Client {\n\tif c.preReqHook != nil {\n\t\tc.log.Warnf(\"Overwriting an existing pre-request hook: %s\", functionName(h))\n\t}\n\tc.preReqHook = h\n\treturn c\n}\n\n// SetDebug method enables the debug mode on the Resty client. The client logs details\n// of every request and response.\n//\n//\tclient.SetDebug(true)\n//\n// Also, it can be enabled at the request level for a particular request; see [Request.SetDebug].\n//   - For [Request], it logs information such as HTTP verb, Relative URL path,\n//     Host, Headers, and Body if it has one.\n//   - For [Response], it logs information such as Status, Response Time, Headers,\n//     and Body if it has one.\nfunc (c *Client) SetDebug(d bool) *Client {\n\tc.Debug = d\n\treturn c\n}\n\n// SetDebugBodyLimit sets the maximum size in bytes for which the response and\n// request body will be logged in debug mode.\n//\n//\tclient.SetDebugBodyLimit(1000000)\nfunc (c *Client) SetDebugBodyLimit(sl int64) *Client {\n\tc.debugBodySizeLimit = sl\n\treturn c\n}\n\n// OnRequestLog method sets the request log callback to Resty. Registered callback gets\n// called before the resty logs the information.\nfunc (c *Client) OnRequestLog(rl RequestLogCallback) *Client {\n\tif c.requestLog != nil {\n\t\tc.log.Warnf(\"Overwriting an existing on-request-log callback from=%s to=%s\",\n\t\t\tfunctionName(c.requestLog), functionName(rl))\n\t}\n\tc.requestLog = rl\n\treturn c\n}\n\n// OnResponseLog method sets the response log callback to Resty. Registered callback gets\n// called before the resty logs the information.\nfunc (c *Client) OnResponseLog(rl ResponseLogCallback) *Client {\n\tif c.responseLog != nil {\n\t\tc.log.Warnf(\"Overwriting an existing on-response-log callback from=%s to=%s\",\n\t\t\tfunctionName(c.responseLog), functionName(rl))\n\t}\n\tc.responseLog = rl\n\treturn c\n}\n\n// SetDisableWarn method disables the warning log message on the Resty client.\n//\n// For example, Resty warns users when BasicAuth is used in non-TLS mode.\n//\n//\tclient.SetDisableWarn(true)\nfunc (c *Client) SetDisableWarn(d bool) *Client {\n\tc.DisableWarn = d\n\treturn c\n}\n\n// SetAllowGetMethodPayload method allows the GET method with payload on the Resty client.\n//\n// For example, Resty allows the user to send a request with a payload using the HTTP GET method.\n//\n//\tclient.SetAllowGetMethodPayload(true)\nfunc (c *Client) SetAllowGetMethodPayload(a bool) *Client {\n\tc.AllowGetMethodPayload = a\n\treturn c\n}\n\n// SetLogger method sets given writer for logging Resty request and response details.\n//\n// Compliant to interface [resty.Logger]\nfunc (c *Client) SetLogger(l Logger) *Client {\n\tc.log = l\n\treturn c\n}\n\n// SetContentLength method enables the HTTP header `Content-Length` value for every request.\n// By default, Resty won't set `Content-Length`.\n//\n//\tclient.SetContentLength(true)\n//\n// Also, you have the option to enable a particular request. See [Request.SetContentLength]\nfunc (c *Client) SetContentLength(l bool) *Client {\n\tc.setContentLength = l\n\treturn c\n}\n\n// SetTimeout method sets the timeout for a request raised by the client.\n//\n//\tclient.SetTimeout(time.Duration(1 * time.Minute))\nfunc (c *Client) SetTimeout(timeout time.Duration) *Client {\n\tc.httpClient.Timeout = timeout\n\treturn c\n}\n\n// SetError method registers the global or client common `Error` object into Resty.\n// It is used for automatic unmarshalling if the response status code is greater than 399 and\n// content type is JSON or XML. It can be a pointer or a non-pointer.\n//\n//\tclient.SetError(&Error{})\n//\t// OR\n//\tclient.SetError(Error{})\nfunc (c *Client) SetError(err interface{}) *Client {\n\tc.Error = typeOf(err)\n\treturn c\n}\n\n// SetRedirectPolicy method sets the redirect policy for the client. Resty provides ready-to-use\n// redirect policies. Wanna create one for yourself, refer to `redirect.go`.\n//\n//\tclient.SetRedirectPolicy(FlexibleRedirectPolicy(20))\n//\n//\t// Need multiple redirect policies together\n//\tclient.SetRedirectPolicy(FlexibleRedirectPolicy(20), DomainCheckRedirectPolicy(\"host1.com\", \"host2.net\"))\nfunc (c *Client) SetRedirectPolicy(policies ...interface{}) *Client {\n\tfor _, p := range policies {\n\t\tif _, ok := p.(RedirectPolicy); !ok {\n\t\t\tc.log.Errorf(\"%v does not implement resty.RedirectPolicy (missing Apply method)\",\n\t\t\t\tfunctionName(p))\n\t\t}\n\t}\n\n\tc.httpClient.CheckRedirect = func(req *http.Request, via []*http.Request) error {\n\t\tfor _, p := range policies {\n\t\t\tif err := p.(RedirectPolicy).Apply(req, via); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil // looks good, go ahead\n\t}\n\n\treturn c\n}\n\n// SetRetryCount method enables retry on Resty client and allows you\n// to set no. of retry count. Resty uses a Backoff mechanism.\nfunc (c *Client) SetRetryCount(count int) *Client {\n\tc.RetryCount = count\n\treturn c\n}\n\n// SetRetryWaitTime method sets the default wait time for sleep before retrying\n// request.\n//\n// Default is 100 milliseconds.\nfunc (c *Client) SetRetryWaitTime(waitTime time.Duration) *Client {\n\tc.RetryWaitTime = waitTime\n\treturn c\n}\n\n// SetRetryMaxWaitTime method sets the max wait time for sleep before retrying\n// request.\n//\n// Default is 2 seconds.\nfunc (c *Client) SetRetryMaxWaitTime(maxWaitTime time.Duration) *Client {\n\tc.RetryMaxWaitTime = maxWaitTime\n\treturn c\n}\n\n// SetRetryAfter sets a callback to calculate the wait time between retries.\n// Default (nil) implies exponential backoff with jitter\nfunc (c *Client) SetRetryAfter(callback RetryAfterFunc) *Client {\n\tc.RetryAfter = callback\n\treturn c\n}\n\n// SetJSONMarshaler method sets the JSON marshaler function to marshal the request body.\n// By default, Resty uses [encoding/json] package to marshal the request body.\nfunc (c *Client) SetJSONMarshaler(marshaler func(v interface{}) ([]byte, error)) *Client {\n\tc.JSONMarshal = marshaler\n\treturn c\n}\n\n// SetJSONUnmarshaler method sets the JSON unmarshaler function to unmarshal the response body.\n// By default, Resty uses [encoding/json] package to unmarshal the response body.\nfunc (c *Client) SetJSONUnmarshaler(unmarshaler func(data []byte, v interface{}) error) *Client {\n\tc.JSONUnmarshal = unmarshaler\n\treturn c\n}\n\n// SetXMLMarshaler method sets the XML marshaler function to marshal the request body.\n// By default, Resty uses [encoding/xml] package to marshal the request body.\nfunc (c *Client) SetXMLMarshaler(marshaler func(v interface{}) ([]byte, error)) *Client {\n\tc.XMLMarshal = marshaler\n\treturn c\n}\n\n// SetXMLUnmarshaler method sets the XML unmarshaler function to unmarshal the response body.\n// By default, Resty uses [encoding/xml] package to unmarshal the response body.\nfunc (c *Client) SetXMLUnmarshaler(unmarshaler func(data []byte, v interface{}) error) *Client {\n\tc.XMLUnmarshal = unmarshaler\n\treturn c\n}\n\n// AddRetryCondition method adds a retry condition function to an array of functions\n// that are checked to determine if the request is retried. The request will\n// retry if any functions return true and the error is nil.\n//\n// NOTE: These retry conditions are applied on all requests made using this Client.\n// For [Request] specific retry conditions, check [Request.AddRetryCondition]\nfunc (c *Client) AddRetryCondition(condition RetryConditionFunc) *Client {\n\tc.RetryConditions = append(c.RetryConditions, condition)\n\treturn c\n}\n\n// AddRetryAfterErrorCondition adds the basic condition of retrying after encountering\n// an error from the HTTP response\nfunc (c *Client) AddRetryAfterErrorCondition() *Client {\n\tc.AddRetryCondition(func(response *Response, err error) bool {\n\t\treturn response.IsError()\n\t})\n\treturn c\n}\n\n// AddRetryHook adds a side-effecting retry hook to an array of hooks\n// that will be executed on each retry.\nfunc (c *Client) AddRetryHook(hook OnRetryFunc) *Client {\n\tc.RetryHooks = append(c.RetryHooks, hook)\n\treturn c\n}\n\n// SetRetryResetReaders method enables the Resty client to seek the start of all\n// file readers are given as multipart files if the object implements [io.ReadSeeker].\nfunc (c *Client) SetRetryResetReaders(b bool) *Client {\n\tc.RetryResetReaders = b\n\treturn c\n}\n\n// SetTLSClientConfig method sets TLSClientConfig for underlying client Transport.\n//\n// For Example:\n//\n//\t// One can set a custom root certificate. Refer: http://golang.org/pkg/crypto/tls/#example_Dial\n//\tclient.SetTLSClientConfig(&tls.Config{ RootCAs: roots })\n//\n//\t// or One can disable security check (https)\n//\tclient.SetTLSClientConfig(&tls.Config{ InsecureSkipVerify: true })\n//\n// NOTE: This method overwrites existing [http.Transport.TLSClientConfig]\nfunc (c *Client) SetTLSClientConfig(config *tls.Config) *Client {\n\ttransport, err := c.Transport()\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn c\n\t}\n\ttransport.TLSClientConfig = config\n\treturn c\n}\n\n// SetProxy method sets the Proxy URL and Port for the Resty client.\n//\n//\tclient.SetProxy(\"http://proxyserver:8888\")\n//\n// OR you could also set Proxy via environment variable, refer to [http.ProxyFromEnvironment]\nfunc (c *Client) SetProxy(proxyURL string) *Client {\n\ttransport, err := c.Transport()\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn c\n\t}\n\n\tpURL, err := url.Parse(proxyURL)\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn c\n\t}\n\n\tc.proxyURL = pURL\n\ttransport.Proxy = http.ProxyURL(c.proxyURL)\n\treturn c\n}\n\n// RemoveProxy method removes the proxy configuration from the Resty client\n//\n//\tclient.RemoveProxy()\nfunc (c *Client) RemoveProxy() *Client {\n\ttransport, err := c.Transport()\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn c\n\t}\n\tc.proxyURL = nil\n\ttransport.Proxy = nil\n\treturn c\n}\n\n// SetCertificates method helps to conveniently set client certificates into Resty.\nfunc (c *Client) SetCertificates(certs ...tls.Certificate) *Client {\n\tconfig, err := c.tlsConfig()\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn c\n\t}\n\tconfig.Certificates = append(config.Certificates, certs...)\n\treturn c\n}\n\n// SetRootCertificate method helps to add one or more root certificates into the Resty client\n//\n//\tclient.SetRootCertificate(\"/path/to/root/pemFile.pem\")\nfunc (c *Client) SetRootCertificate(pemFilePath string) *Client {\n\trootPemData, err := os.ReadFile(pemFilePath)\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn c\n\t}\n\tc.handleCAs(\"root\", rootPemData)\n\treturn c\n}\n\n// SetRootCertificateFromString method helps to add one or more root certificates\n// into the Resty client\n//\n//\tclient.SetRootCertificateFromString(\"pem certs content\")\nfunc (c *Client) SetRootCertificateFromString(pemCerts string) *Client {\n\tc.handleCAs(\"root\", []byte(pemCerts))\n\treturn c\n}\n\n// SetClientRootCertificate method helps to add one or more client's root\n// certificates into the Resty client\n//\n//\tclient.SetClientRootCertificate(\"/path/to/root/pemFile.pem\")\nfunc (c *Client) SetClientRootCertificate(pemFilePath string) *Client {\n\trootPemData, err := os.ReadFile(pemFilePath)\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn c\n\t}\n\tc.handleCAs(\"client\", rootPemData)\n\treturn c\n}\n\n// SetClientRootCertificateFromString method helps to add one or more clients\n// root certificates into the Resty client\n//\n//\tclient.SetClientRootCertificateFromString(\"pem certs content\")\nfunc (c *Client) SetClientRootCertificateFromString(pemCerts string) *Client {\n\tc.handleCAs(\"client\", []byte(pemCerts))\n\treturn c\n}\n\nfunc (c *Client) handleCAs(scope string, permCerts []byte) {\n\tconfig, err := c.tlsConfig()\n\tif err != nil {\n\t\tc.log.Errorf(\"%v\", err)\n\t\treturn\n\t}\n\n\tswitch scope {\n\tcase \"root\":\n\t\tif config.RootCAs == nil {\n\t\t\tconfig.RootCAs = x509.NewCertPool()\n\t\t}\n\t\tconfig.RootCAs.AppendCertsFromPEM(permCerts)\n\tcase \"client\":\n\t\tif config.ClientCAs == nil {\n\t\t\tconfig.ClientCAs = x509.NewCertPool()\n\t\t}\n\t\tconfig.ClientCAs.AppendCertsFromPEM(permCerts)\n\t}\n}\n\n// SetOutputDirectory method sets the output directory for saving HTTP responses in a file.\n// Resty creates one if the output directory does not exist. This setting is optional,\n// if you plan to use the absolute path in [Request.SetOutput] and can used together.\n//\n//\tclient.SetOutputDirectory(\"/save/http/response/here\")\nfunc (c *Client) SetOutputDirectory(dirPath string) *Client {\n\tc.outputDirectory = dirPath\n\treturn c\n}\n\n// SetRateLimiter sets an optional [RateLimiter]. If set, the rate limiter will control\n// all requests were made by this client.\nfunc (c *Client) SetRateLimiter(rl RateLimiter) *Client {\n\tc.rateLimiter = rl\n\treturn c\n}\n\n// SetTransport method sets custom [http.Transport] or any [http.RoundTripper]\n// compatible interface implementation in the Resty client.\n//\n//\ttransport := &http.Transport{\n//\t\t// something like Proxying to httptest.Server, etc...\n//\t\tProxy: func(req *http.Request) (*url.URL, error) {\n//\t\t\treturn url.Parse(server.URL)\n//\t\t},\n//\t}\n//\tclient.SetTransport(transport)\n//\n// NOTE:\n//   - If transport is not the type of `*http.Transport`, then you may not be able to\n//     take advantage of some of the Resty client settings.\n//   - It overwrites the Resty client transport instance and its configurations.\nfunc (c *Client) SetTransport(transport http.RoundTripper) *Client {\n\tif transport != nil {\n\t\tc.httpClient.Transport = transport\n\t}\n\treturn c\n}\n\n// SetScheme method sets a custom scheme for the Resty client. It's a way to override the default.\n//\n//\tclient.SetScheme(\"http\")\nfunc (c *Client) SetScheme(scheme string) *Client {\n\tif !IsStringEmpty(scheme) {\n\t\tc.scheme = strings.TrimSpace(scheme)\n\t}\n\treturn c\n}\n\n// SetCloseConnection method sets variable `Close` in HTTP request struct with the given\n// value. More info: https://golang.org/src/net/http/request.go\nfunc (c *Client) SetCloseConnection(close bool) *Client {\n\tc.closeConnection = close\n\treturn c\n}\n\n// SetDoNotParseResponse method instructs Resty not to parse the response body automatically.\n// Resty exposes the raw response body as [io.ReadCloser]. If you use it, do not\n// forget to close the body, otherwise, you might get into connection leaks, and connection\n// reuse may not happen.\n//\n// NOTE: [Response] middlewares are not executed using this option. You have\n// taken over the control of response parsing from Resty.\nfunc (c *Client) SetDoNotParseResponse(notParse bool) *Client {\n\tc.notParseResponse = notParse\n\treturn c\n}\n\n// SetPathParam method sets a single URL path key-value pair in the\n// Resty client instance.\n//\n//\tclient.SetPathParam(\"userId\", \"sample@sample.com\")\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/details\n//\t   Composed URL - /v1/users/sample@sample.com/details\n//\n// It replaces the value of the key while composing the request URL.\n// The value will be escaped using [url.PathEscape] function.\n//\n// It can be overridden at the request level,\n// see [Request.SetPathParam] or [Request.SetPathParams]\nfunc (c *Client) SetPathParam(param, value string) *Client {\n\tc.PathParams[param] = value\n\treturn c\n}\n\n// SetPathParams method sets multiple URL path key-value pairs at one go in the\n// Resty client instance.\n//\n//\tclient.SetPathParams(map[string]string{\n//\t\t\"userId\":       \"sample@sample.com\",\n//\t\t\"subAccountId\": \"100002\",\n//\t\t\"path\":         \"groups/developers\",\n//\t})\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/{subAccountId}/{path}/details\n//\t   Composed URL - /v1/users/sample@sample.com/100002/groups%2Fdevelopers/details\n//\n// It replaces the value of the key while composing the request URL.\n// The values will be escaped using [url.PathEscape] function.\n//\n// It can be overridden at the request level,\n// see [Request.SetPathParam] or [Request.SetPathParams]\nfunc (c *Client) SetPathParams(params map[string]string) *Client {\n\tfor p, v := range params {\n\t\tc.SetPathParam(p, v)\n\t}\n\treturn c\n}\n\n// SetRawPathParam method sets a single URL path key-value pair in the\n// Resty client instance.\n//\n//\tclient.SetPathParam(\"userId\", \"sample@sample.com\")\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/details\n//\t   Composed URL - /v1/users/sample@sample.com/details\n//\n//\tclient.SetPathParam(\"path\", \"groups/developers\")\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/details\n//\t   Composed URL - /v1/users/groups%2Fdevelopers/details\n//\n// It replaces the value of the key while composing the request URL.\n// The value will be used as it is and will not be escaped.\n//\n// It can be overridden at the request level,\n// see [Request.SetRawPathParam] or [Request.SetRawPathParams]\nfunc (c *Client) SetRawPathParam(param, value string) *Client {\n\tc.RawPathParams[param] = value\n\treturn c\n}\n\n// SetRawPathParams method sets multiple URL path key-value pairs at one go in the\n// Resty client instance.\n//\n//\tclient.SetPathParams(map[string]string{\n//\t\t\"userId\":       \"sample@sample.com\",\n//\t\t\"subAccountId\": \"100002\",\n//\t\t\"path\":         \"groups/developers\",\n//\t})\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/{subAccountId}/{path}/details\n//\t   Composed URL - /v1/users/sample@sample.com/100002/groups/developers/details\n//\n// It replaces the value of the key while composing the request URL.\n// The values will be used as they are and will not be escaped.\n//\n// It can be overridden at the request level,\n// see [Request.SetRawPathParam] or [Request.SetRawPathParams]\nfunc (c *Client) SetRawPathParams(params map[string]string) *Client {\n\tfor p, v := range params {\n\t\tc.SetRawPathParam(p, v)\n\t}\n\treturn c\n}\n\n// SetJSONEscapeHTML method enables or disables the HTML escape on JSON marshal.\n// By default, escape HTML is false.\n//\n// NOTE: This option only applies to the standard JSON Marshaller used by Resty.\n//\n// It can be overridden at the request level, see [Client.SetJSONEscapeHTML]\nfunc (c *Client) SetJSONEscapeHTML(b bool) *Client {\n\tc.jsonEscapeHTML = b\n\treturn c\n}\n\n// SetResponseBodyLimit method sets a maximum body size limit in bytes on response,\n// avoid reading too much data to memory.\n//\n// Client will return [resty.ErrResponseBodyTooLarge] if the body size of the body\n// in the uncompressed response is larger than the limit.\n// Body size limit will not be enforced in the following cases:\n//   - ResponseBodyLimit <= 0, which is the default behavior.\n//   - [Request.SetOutput] is called to save response data to the file.\n//   - \"DoNotParseResponse\" is set for client or request.\n//\n// It can be overridden at the request level; see [Request.SetResponseBodyLimit]\nfunc (c *Client) SetResponseBodyLimit(v int) *Client {\n\tc.ResponseBodyLimit = v\n\treturn c\n}\n\n// EnableTrace method enables the Resty client trace for the requests fired from\n// the client using [httptrace.ClientTrace] and provides insights.\n//\n//\tclient := resty.New().EnableTrace()\n//\n//\tresp, err := client.R().Get(\"https://httpbin.org/get\")\n//\tfmt.Println(\"Error:\", err)\n//\tfmt.Println(\"Trace Info:\", resp.Request.TraceInfo())\n//\n// The method [Request.EnableTrace] is also available to get trace info for a single request.\nfunc (c *Client) EnableTrace() *Client {\n\tc.trace = true\n\treturn c\n}\n\n// DisableTrace method disables the Resty client trace. Refer to [Client.EnableTrace].\nfunc (c *Client) DisableTrace() *Client {\n\tc.trace = false\n\treturn c\n}\n\n// EnableGenerateCurlOnDebug method enables the generation of CURL commands in the debug log.\n// It works in conjunction with debug mode.\n//\n// NOTE: Use with care.\n//   - Potential to leak sensitive data from [Request] and [Response] in the debug log.\n//   - Beware of memory usage since the request body is reread.\nfunc (c *Client) EnableGenerateCurlOnDebug() *Client {\n\tc.generateCurlOnDebug = true\n\treturn c\n}\n\n// DisableGenerateCurlOnDebug method disables the option set by [Client.EnableGenerateCurlOnDebug].\nfunc (c *Client) DisableGenerateCurlOnDebug() *Client {\n\tc.generateCurlOnDebug = false\n\treturn c\n}\n\n// IsProxySet method returns the true is proxy is set from the Resty client; otherwise\n// false. By default, the proxy is set from the environment variable; refer to [http.ProxyFromEnvironment].\nfunc (c *Client) IsProxySet() bool {\n\treturn c.proxyURL != nil\n}\n\n// GetClient method returns the underlying [http.Client] used by the Resty.\nfunc (c *Client) GetClient() *http.Client {\n\treturn c.httpClient\n}\n\n// Clone returns a clone of the original client.\n//\n// NOTE: Use with care:\n//   - Interface values are not deeply cloned. Thus, both the original and the\n//     clone will use the same value.\n//   - This function is not safe for concurrent use. You should only use this method\n//     when you are sure that any other goroutine is not using the client.\nfunc (c *Client) Clone() *Client {\n\t// dereference the pointer and copy the value\n\tcc := *c\n\n\t// lock values should not be copied - thus new values are used.\n\tcc.afterResponseLock = &sync.RWMutex{}\n\tcc.udBeforeRequestLock = &sync.RWMutex{}\n\treturn &cc\n}\n\nfunc (c *Client) executeBefore(req *Request) error {\n\t// Lock the user-defined pre-request hooks.\n\tc.udBeforeRequestLock.RLock()\n\tdefer c.udBeforeRequestLock.RUnlock()\n\n\t// Lock the post-request hooks.\n\tc.afterResponseLock.RLock()\n\tdefer c.afterResponseLock.RUnlock()\n\n\t// Apply Request middleware\n\tvar err error\n\n\t// user defined on before request methods\n\t// to modify the *resty.Request object\n\tfor _, f := range c.udBeforeRequest {\n\t\tif err = f(c, req); err != nil {\n\t\t\treturn wrapNoRetryErr(err)\n\t\t}\n\t}\n\n\t// If there is a rate limiter set for this client, the Execute call\n\t// will return an error if the rate limit is exceeded.\n\tif req.client.rateLimiter != nil {\n\t\tif !req.client.rateLimiter.Allow() {\n\t\t\treturn wrapNoRetryErr(ErrRateLimitExceeded)\n\t\t}\n\t}\n\n\t// resty middlewares\n\tfor _, f := range c.beforeRequest {\n\t\tif err = f(c, req); err != nil {\n\t\t\treturn wrapNoRetryErr(err)\n\t\t}\n\t}\n\n\tif hostHeader := req.Header.Get(\"Host\"); hostHeader != \"\" {\n\t\treq.RawRequest.Host = hostHeader\n\t}\n\n\t// call pre-request if defined\n\tif c.preReqHook != nil {\n\t\tif err = c.preReqHook(c, req.RawRequest); err != nil {\n\t\t\treturn wrapNoRetryErr(err)\n\t\t}\n\t}\n\n\tif err = requestLogger(c, req); err != nil {\n\t\treturn wrapNoRetryErr(err)\n\t}\n\n\treturn nil\n}\n\n// Executes method executes the given `Request` object and returns\n// response or error.\nfunc (c *Client) execute(req *Request) (*Response, error) {\n\tif err := c.executeBefore(req); err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Time = time.Now()\n\tresp, err := c.httpClient.Do(req.RawRequest)\n\n\tresponse := &Response{\n\t\tRequest:     req,\n\t\tRawResponse: resp,\n\t}\n\n\tif err != nil || req.notParseResponse || c.notParseResponse {\n\t\tresponse.setReceivedAt()\n\t\tif logErr := responseLogger(c, response); logErr != nil {\n\t\t\treturn response, wrapErrors(logErr, err)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn response, err\n\t\t}\n\t\treturn response, nil\n\t}\n\n\tif !req.isSaveResponse {\n\t\tdefer closeq(resp.Body)\n\t\tbody := resp.Body\n\n\t\t// GitHub #142 & #187\n\t\tif strings.EqualFold(resp.Header.Get(hdrContentEncodingKey), \"gzip\") && resp.ContentLength != 0 {\n\t\t\tif _, ok := body.(*gzip.Reader); !ok {\n\t\t\t\tbody, err = gzip.NewReader(body)\n\t\t\t\tif err != nil {\n\t\t\t\t\terr = wrapErrors(responseLogger(c, response), err)\n\t\t\t\t\tresponse.setReceivedAt()\n\t\t\t\t\treturn response, err\n\t\t\t\t}\n\t\t\t\tdefer closeq(body)\n\t\t\t}\n\t\t}\n\n\t\tif response.body, err = readAllWithLimit(body, req.responseBodyLimit); err != nil {\n\t\t\terr = wrapErrors(responseLogger(c, response), err)\n\t\t\tresponse.setReceivedAt()\n\t\t\treturn response, err\n\t\t}\n\n\t\tresponse.size = int64(len(response.body))\n\t}\n\n\tresponse.setReceivedAt() // after we read the body\n\n\t// Apply Response middleware\n\terr = responseLogger(c, response)\n\tif err != nil {\n\t\treturn response, wrapNoRetryErr(err)\n\t}\n\n\tfor _, f := range c.afterResponse {\n\t\tif err = f(c, response); err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn response, wrapNoRetryErr(err)\n}\n\nvar ErrResponseBodyTooLarge = errors.New(\"resty: response body too large\")\n\n// https://github.com/golang/go/issues/51115\n// [io.LimitedReader] can only return [io.EOF]\nfunc readAllWithLimit(r io.Reader, maxSize int) ([]byte, error) {\n\tif maxSize <= 0 {\n\t\treturn io.ReadAll(r)\n\t}\n\n\tvar buf [512]byte // make buf stack allocated\n\tresult := make([]byte, 0, 512)\n\ttotal := 0\n\tfor {\n\t\tn, err := r.Read(buf[:])\n\t\ttotal += n\n\t\tif total > maxSize {\n\t\t\treturn nil, ErrResponseBodyTooLarge\n\t\t}\n\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tresult = append(result, buf[:n]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresult = append(result, buf[:n]...)\n\t}\n\n\treturn result, nil\n}\n\n// getting TLS client config if not exists then create one\nfunc (c *Client) tlsConfig() (*tls.Config, error) {\n\ttransport, err := c.Transport()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif transport.TLSClientConfig == nil {\n\t\ttransport.TLSClientConfig = &tls.Config{}\n\t}\n\treturn transport.TLSClientConfig, nil\n}\n\n// Transport method returns [http.Transport] currently in use or error\n// in case the currently used `transport` is not a [http.Transport].\n//\n// Since v2.8.0 has become exported method.\nfunc (c *Client) Transport() (*http.Transport, error) {\n\tif transport, ok := c.httpClient.Transport.(*http.Transport); ok {\n\t\treturn transport, nil\n\t}\n\treturn nil, errors.New(\"current transport is not an *http.Transport instance\")\n}\n\n// just an internal helper method\nfunc (c *Client) outputLogTo(w io.Writer) *Client {\n\tc.log.(*logger).l.SetOutput(w)\n\treturn c\n}\n\n// ResponseError is a wrapper that includes the server response with an error.\n// Neither the err nor the response should be nil.\ntype ResponseError struct {\n\tResponse *Response\n\tErr      error\n}\n\nfunc (e *ResponseError) Error() string {\n\treturn e.Err.Error()\n}\n\nfunc (e *ResponseError) Unwrap() error {\n\treturn e.Err\n}\n\n// Helper to run errorHooks hooks.\n// It wraps the error in a [ResponseError] if the resp is not nil\n// so hooks can access it.\nfunc (c *Client) onErrorHooks(req *Request, resp *Response, err error) {\n\tif err != nil {\n\t\tif resp != nil { // wrap with ResponseError\n\t\t\terr = &ResponseError{Response: resp, Err: err}\n\t\t}\n\t\tfor _, h := range c.errorHooks {\n\t\t\th(req, err)\n\t\t}\n\t} else {\n\t\tfor _, h := range c.successHooks {\n\t\t\th(c, resp)\n\t\t}\n\t}\n}\n\n// Helper to run panicHooks hooks.\nfunc (c *Client) onPanicHooks(req *Request, err error) {\n\tfor _, h := range c.panicHooks {\n\t\th(req, err)\n\t}\n}\n\n// Helper to run invalidHooks hooks.\nfunc (c *Client) onInvalidHooks(req *Request, err error) {\n\tfor _, h := range c.invalidHooks {\n\t\th(req, err)\n\t}\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// File struct and its methods\n//_______________________________________________________________________\n\n// File struct represents file information for multipart request\ntype File struct {\n\tName      string\n\tParamName string\n\tio.Reader\n}\n\n// String method returns the string value of current file details\nfunc (f *File) String() string {\n\treturn fmt.Sprintf(\"ParamName: %v; FileName: %v\", f.ParamName, f.Name)\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// MultipartField struct\n//_______________________________________________________________________\n\n// MultipartField struct represents the custom data part for a multipart request\ntype MultipartField struct {\n\tParam       string\n\tFileName    string\n\tContentType string\n\tio.Reader\n}\n\nfunc createClient(hc *http.Client) *Client {\n\tif hc.Transport == nil {\n\t\thc.Transport = createTransport(nil)\n\t}\n\n\tc := &Client{ // not setting lang default values\n\t\tQueryParam:             url.Values{},\n\t\tFormData:               url.Values{},\n\t\tHeader:                 http.Header{},\n\t\tCookies:                make([]*http.Cookie, 0),\n\t\tRetryWaitTime:          defaultWaitTime,\n\t\tRetryMaxWaitTime:       defaultMaxWaitTime,\n\t\tPathParams:             make(map[string]string),\n\t\tRawPathParams:          make(map[string]string),\n\t\tJSONMarshal:            json.Marshal,\n\t\tJSONUnmarshal:          json.Unmarshal,\n\t\tXMLMarshal:             xml.Marshal,\n\t\tXMLUnmarshal:           xml.Unmarshal,\n\t\tHeaderAuthorizationKey: http.CanonicalHeaderKey(\"Authorization\"),\n\n\t\tjsonEscapeHTML:      true,\n\t\thttpClient:          hc,\n\t\tdebugBodySizeLimit:  math.MaxInt32,\n\t\tudBeforeRequestLock: &sync.RWMutex{},\n\t\tafterResponseLock:   &sync.RWMutex{},\n\t}\n\n\t// Logger\n\tc.SetLogger(createLogger())\n\n\t// default before request middlewares\n\tc.beforeRequest = []RequestMiddleware{\n\t\tparseRequestURL,\n\t\tparseRequestHeader,\n\t\tparseRequestBody,\n\t\tcreateHTTPRequest,\n\t\taddCredentials,\n\t\tcreateCurlCmd,\n\t}\n\n\t// user defined request middlewares\n\tc.udBeforeRequest = []RequestMiddleware{}\n\n\t// default after response middlewares\n\tc.afterResponse = []ResponseMiddleware{\n\t\tparseResponseBody,\n\t\tsaveResponseIntoFile,\n\t}\n\n\treturn c\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 31.7109375,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestClientBasicAuth(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetBasicAuth(\"myuser\", \"basicauth\").\n\t\tSetHostURL(ts.URL).\n\t\tSetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})\n\n\tresp, err := c.R().\n\t\tSetResult(&AuthSuccess{}).\n\t\tPost(\"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\tlogResponse(t, resp)\n}\n\nfunc TestClientAuthToken(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF\").\n\t\tSetHostURL(ts.URL + \"/\")\n\n\tresp, err := c.R().Get(\"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestClientAuthScheme(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\t// Ensure default Bearer\n\tc.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF\").\n\t\tSetHostURL(ts.URL + \"/\")\n\n\tresp, err := c.R().Get(\"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\t// Ensure setting the scheme works as well\n\tc.SetAuthScheme(\"Bearer\")\n\n\tresp2, err2 := c.R().Get(\"/profile\")\n\tassertError(t, err2)\n\tassertEqual(t, http.StatusOK, resp2.StatusCode())\n\n}\n\nfunc TestClientDigestAuth(t *testing.T) {\n\tconf := defaultDigestServerConf()\n\tts := createDigestServer(t, conf)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetBaseURL(ts.URL+\"/\").\n\t\tSetDigestAuth(conf.username, conf.password)\n\n\tresp, err := c.R().\n\t\tSetResult(&AuthSuccess{}).\n\t\tGet(conf.uri)\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\tlogResponse(t, resp)\n}\n\nfunc TestClientDigestSession(t *testing.T) {\n\tconf := defaultDigestServerConf()\n\tconf.algo = \"MD5-sess\"\n\tconf.qop = \"auth, auth-int\"\n\tts := createDigestServer(t, conf)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetBaseURL(ts.URL+\"/\").\n\t\tSetDigestAuth(conf.username, conf.password)\n\n\tresp, err := c.R().\n\t\tSetResult(&AuthSuccess{}).\n\t\tGet(conf.uri)\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\tlogResponse(t, resp)\n}\n\nfunc TestClientDigestErrors(t *testing.T) {\n\ttype test struct {\n\t\tmutateConf func(*digestServerConfig)\n\t\texpect     error\n\t}\n\ttests := []test{\n\t\t{mutateConf: func(c *digestServerConfig) { c.algo = \"BAD_ALGO\" }, expect: ErrDigestAlgNotSupported},\n\t\t{mutateConf: func(c *digestServerConfig) { c.qop = \"bad-qop\" }, expect: ErrDigestQopNotSupported},\n\t\t{mutateConf: func(c *digestServerConfig) { c.qop = \"\" }, expect: ErrDigestNoQop},\n\t\t{mutateConf: func(c *digestServerConfig) { c.charset = \"utf-16\" }, expect: ErrDigestCharset},\n\t\t{mutateConf: func(c *digestServerConfig) { c.uri = \"/bad\" }, expect: ErrDigestBadChallenge},\n\t\t{mutateConf: func(c *digestServerConfig) { c.uri = \"/unknown_param\" }, expect: ErrDigestBadChallenge},\n\t\t{mutateConf: func(c *digestServerConfig) { c.uri = \"/missing_value\" }, expect: ErrDigestBadChallenge},\n\t\t{mutateConf: func(c *digestServerConfig) { c.uri = \"/unclosed_quote\" }, expect: ErrDigestBadChallenge},\n\t\t{mutateConf: func(c *digestServerConfig) { c.uri = \"/no_challenge\" }, expect: ErrDigestBadChallenge},\n\t\t{mutateConf: func(c *digestServerConfig) { c.uri = \"/status_500\" }, expect: nil},\n\t}\n\n\tfor _, tc := range tests {\n\t\tconf := defaultDigestServerConf()\n\t\ttc.mutateConf(conf)\n\t\tts := createDigestServer(t, conf)\n\n\t\tc := dc().\n\t\t\tSetBaseURL(ts.URL+\"/\").\n\t\t\tSetDigestAuth(conf.username, conf.password)\n\n\t\t_, err := c.R().Get(conf.uri)\n\t\tassertErrorIs(t, tc.expect, err)\n\t\tts.Close()\n\t}\n}\n\nfunc TestOnAfterMiddleware(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.OnAfterResponse(func(c *Client, res *Response) error {\n\t\tt.Logf(\"Request sent at: %v\", res.Request.Time)\n\t\tt.Logf(\"Response Received at: %v\", res.ReceivedAt())\n\n\t\treturn nil\n\t})\n\n\tresp, err := c.R().\n\t\tSetBody(\"OnAfterResponse: This is plain text body to server\").\n\t\tPut(ts.URL + \"/plaintext\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"TestPut: plain text response\", resp.String())\n}\n\nfunc TestClientRedirectPolicy(t *testing.T) {\n\tts := createRedirectServer(t)\n\tdefer ts.Close()\n\n\tc := dc().SetRedirectPolicy(FlexibleRedirectPolicy(20))\n\t_, err := c.R().Get(ts.URL + \"/redirect-1\")\n\n\tassertEqual(t, true, (err.Error() == \"Get /redirect-21: stopped after 20 redirects\" ||\n\t\terr.Error() == \"Get \\\"/redirect-21\\\": stopped after 20 redirects\"))\n\n\tc.SetRedirectPolicy(NoRedirectPolicy())\n\t_, err = c.R().Get(ts.URL + \"/redirect-1\")\n\tassertEqual(t, true, (err.Error() == \"Get /redirect-2: auto redirect is disabled\" ||\n\t\terr.Error() == \"Get \\\"/redirect-2\\\": auto redirect is disabled\"))\n}\n\nfunc TestClientTimeout(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().SetTimeout(time.Second * 3)\n\t_, err := c.R().Get(ts.URL + \"/set-timeout-test\")\n\n\tassertEqual(t, true, strings.Contains(strings.ToLower(err.Error()), \"timeout\"))\n}\n\nfunc TestClientTimeoutWithinThreshold(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().SetTimeout(time.Second * 3)\n\tresp, err := c.R().Get(ts.URL + \"/set-timeout-test-with-sequence\")\n\n\tassertError(t, err)\n\n\tseq1, _ := strconv.ParseInt(resp.String(), 10, 32)\n\n\tresp, err = c.R().Get(ts.URL + \"/set-timeout-test-with-sequence\")\n\tassertError(t, err)\n\n\tseq2, _ := strconv.ParseInt(resp.String(), 10, 32)\n\n\tassertEqual(t, seq1+1, seq2)\n}\n\nfunc TestClientTimeoutInternalError(t *testing.T) {\n\tc := dc().SetTimeout(time.Second * 1)\n\t_, _ = c.R().Get(\"http://localhost:9000/set-timeout-test\")\n}\n\nfunc TestClientProxy(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetTimeout(1 * time.Second)\n\tc.SetProxy(\"http://sampleproxy:8888\")\n\n\tresp, err := c.R().Get(ts.URL)\n\tassertNotNil(t, resp)\n\tassertNotNil(t, err)\n\n\t// Error\n\tc.SetProxy(\"//not.a.user@%66%6f%6f.com:8888\")\n\n\tresp, err = c.R().\n\t\tGet(ts.URL)\n\tassertNotNil(t, err)\n\tassertNotNil(t, resp)\n}\n\nfunc TestClientSetCertificates(t *testing.T) {\n\tclient := dc()\n\tclient.SetCertificates(tls.Certificate{})\n\n\ttransport, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertEqual(t, 1, len(transport.TLSClientConfig.Certificates))\n}\n\nfunc TestClientSetRootCertificate(t *testing.T) {\n\tclient := dc()\n\tclient.SetRootCertificate(filepath.Join(getTestDataPath(), \"sample-root.pem\"))\n\n\ttransport, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertNotNil(t, transport.TLSClientConfig.RootCAs)\n}\n\nfunc TestClientSetRootCertificateNotExists(t *testing.T) {\n\tclient := dc()\n\tclient.SetRootCertificate(filepath.Join(getTestDataPath(), \"not-exists-sample-root.pem\"))\n\n\ttransport, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertNil(t, transport.TLSClientConfig)\n}\n\nfunc TestClientSetRootCertificateFromString(t *testing.T) {\n\tclient := dc()\n\trootPemData, err := os.ReadFile(filepath.Join(getTestDataPath(), \"sample-root.pem\"))\n\tassertNil(t, err)\n\n\tclient.SetRootCertificateFromString(string(rootPemData))\n\n\ttransport, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertNotNil(t, transport.TLSClientConfig.RootCAs)\n}\n\nfunc TestClientSetRootCertificateFromStringErrorTls(t *testing.T) {\n\tclient := NewWithClient(&http.Client{})\n\tclient.outputLogTo(io.Discard)\n\n\trootPemData, err := os.ReadFile(filepath.Join(getTestDataPath(), \"sample-root.pem\"))\n\tassertNil(t, err)\n\trt := &CustomRoundTripper{}\n\tclient.SetTransport(rt)\n\ttransport, err := client.Transport()\n\n\tclient.SetRootCertificateFromString(string(rootPemData))\n\n\tassertNotNil(t, rt)\n\tassertNotNil(t, err)\n\tassertNil(t, transport)\n}\n\nfunc TestClientSetClientRootCertificate(t *testing.T) {\n\tclient := dc()\n\tclient.SetClientRootCertificate(filepath.Join(getTestDataPath(), \"sample-root.pem\"))\n\n\ttransport, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertNotNil(t, transport.TLSClientConfig.ClientCAs)\n}\n\nfunc TestClientSetClientRootCertificateNotExists(t *testing.T) {\n\tclient := dc()\n\tclient.SetClientRootCertificate(filepath.Join(getTestDataPath(), \"not-exists-sample-root.pem\"))\n\n\ttransport, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertNil(t, transport.TLSClientConfig)\n}\n\nfunc TestClientSetClientRootCertificateFromString(t *testing.T) {\n\tclient := dc()\n\trootPemData, err := os.ReadFile(filepath.Join(getTestDataPath(), \"sample-root.pem\"))\n\tassertNil(t, err)\n\n\tclient.SetClientRootCertificateFromString(string(rootPemData))\n\n\ttransport, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertNotNil(t, transport.TLSClientConfig.ClientCAs)\n}\n\nfunc TestClientSetClientRootCertificateFromStringErrorTls(t *testing.T) {\n\tclient := NewWithClient(&http.Client{})\n\tclient.outputLogTo(io.Discard)\n\n\trootPemData, err := os.ReadFile(filepath.Join(getTestDataPath(), \"sample-root.pem\"))\n\tassertNil(t, err)\n\trt := &CustomRoundTripper{}\n\tclient.SetTransport(rt)\n\ttransport, err := client.Transport()\n\n\tclient.SetClientRootCertificateFromString(string(rootPemData))\n\n\tassertNotNil(t, rt)\n\tassertNotNil(t, err)\n\tassertNil(t, transport)\n}\n\nfunc TestClientOnBeforeRequestModification(t *testing.T) {\n\ttc := dc()\n\ttc.OnBeforeRequest(func(c *Client, r *Request) error {\n\t\tr.SetAuthToken(\"This is test auth token\")\n\t\treturn nil\n\t})\n\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := tc.R().Get(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestClientSetHeaderVerbatim(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetHeaderVerbatim(\"header-lowercase\", \"value_lowercase\").\n\t\tSetHeader(\"header-lowercase\", \"value_standard\")\n\n\t//lint:ignore SA1008 valid one, so ignore this!\n\tunConventionHdrValue := strings.Join(c.Header[\"header-lowercase\"], \"\")\n\tassertEqual(t, \"value_lowercase\", unConventionHdrValue)\n\tassertEqual(t, \"value_standard\", c.Header.Get(\"Header-Lowercase\"))\n}\n\nfunc TestClientSetTransport(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\tclient := dc()\n\n\ttransport := &http.Transport{\n\t\t// something like Proxying to httptest.Server, etc...\n\t\tProxy: func(req *http.Request) (*url.URL, error) {\n\t\t\treturn url.Parse(ts.URL)\n\t\t},\n\t}\n\tclient.SetTransport(transport)\n\ttransportInUse, err := client.Transport()\n\n\tassertNil(t, err)\n\tassertEqual(t, true, transport == transportInUse)\n}\n\nfunc TestClientSetScheme(t *testing.T) {\n\tclient := dc()\n\n\tclient.SetScheme(\"http\")\n\n\tassertEqual(t, true, client.scheme == \"http\")\n}\n\nfunc TestClientSetCookieJar(t *testing.T) {\n\tclient := dc()\n\tbackupJar := client.httpClient.Jar\n\n\tclient.SetCookieJar(nil)\n\tassertNil(t, client.httpClient.Jar)\n\n\tclient.SetCookieJar(backupJar)\n\tassertEqual(t, true, client.httpClient.Jar == backupJar)\n}\n\nfunc TestClientOptions(t *testing.T) {\n\tclient := dc()\n\tclient.SetContentLength(true)\n\tassertEqual(t, client.setContentLength, true)\n\n\tclient.SetHostURL(\"http://httpbin.org\")\n\tassertEqual(t, \"http://httpbin.org\", client.HostURL)\n\n\tclient.SetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\tclient.SetHeaders(map[string]string{\n\t\thdrUserAgentKey: \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) go-resty v0.1\",\n\t\t\"X-Request-Id\":  strconv.FormatInt(time.Now().UnixNano(), 10),\n\t})\n\tassertEqual(t, \"application/json; charset=utf-8\", client.Header.Get(hdrContentTypeKey))\n\n\tclient.SetCookie(&http.Cookie{\n\t\tName:  \"default-cookie\",\n\t\tValue: \"This is cookie default-cookie value\",\n\t})\n\tassertEqual(t, \"default-cookie\", client.Cookies[0].Name)\n\n\tcookies := []*http.Cookie{\n\t\t{\n\t\t\tName:  \"default-cookie-1\",\n\t\t\tValue: \"This is default-cookie 1 value\",\n\t\t}, {\n\t\t\tName:  \"default-cookie-2\",\n\t\t\tValue: \"This is default-cookie 2 value\",\n\t\t},\n\t}\n\tclient.SetCookies(cookies)\n\tassertEqual(t, \"default-cookie-1\", client.Cookies[1].Name)\n\tassertEqual(t, \"default-cookie-2\", client.Cookies[2].Name)\n\n\tclient.SetQueryParam(\"test_param_1\", \"Param_1\")\n\tclient.SetQueryParams(map[string]string{\"test_param_2\": \"Param_2\", \"test_param_3\": \"Param_3\"})\n\tassertEqual(t, \"Param_3\", client.QueryParam.Get(\"test_param_3\"))\n\n\trTime := strconv.FormatInt(time.Now().UnixNano(), 10)\n\tclient.SetFormData(map[string]string{\"r_time\": rTime})\n\tassertEqual(t, rTime, client.FormData.Get(\"r_time\"))\n\n\tclient.SetBasicAuth(\"myuser\", \"mypass\")\n\tassertEqual(t, \"myuser\", client.UserInfo.Username)\n\n\tclient.SetAuthToken(\"AC75BD37F019E08FBC594900518B4F7E\")\n\tassertEqual(t, \"AC75BD37F019E08FBC594900518B4F7E\", client.Token)\n\n\tclient.SetDisableWarn(true)\n\tassertEqual(t, client.DisableWarn, true)\n\n\tclient.SetRetryCount(3)\n\tassertEqual(t, 3, client.RetryCount)\n\n\trwt := time.Duration(1000) * time.Millisecond\n\tclient.SetRetryWaitTime(rwt)\n\tassertEqual(t, rwt, client.RetryWaitTime)\n\n\tmrwt := time.Duration(2) * time.Second\n\tclient.SetRetryMaxWaitTime(mrwt)\n\tassertEqual(t, mrwt, client.RetryMaxWaitTime)\n\n\tclient.AddRetryAfterErrorCondition()\n\tequal(client.RetryConditions[0], func(response *Response, err error) bool {\n\t\treturn response.IsError()\n\t})\n\n\terr := &AuthError{}\n\tclient.SetError(err)\n\tif reflect.TypeOf(err) == client.Error {\n\t\tt.Error(\"SetError failed\")\n\t}\n\n\tclient.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})\n\ttransport, transportErr := client.Transport()\n\n\tassertNil(t, transportErr)\n\tassertEqual(t, true, transport.TLSClientConfig.InsecureSkipVerify)\n\n\tclient.OnBeforeRequest(func(c *Client, r *Request) error {\n\t\tc.log.Debugf(\"I'm in Request middleware\")\n\t\treturn nil // if it success\n\t})\n\tclient.OnAfterResponse(func(c *Client, r *Response) error {\n\t\tc.log.Debugf(\"I'm in Response middleware\")\n\t\treturn nil // if it success\n\t})\n\n\tclient.SetTimeout(5 * time.Second)\n\tclient.SetRedirectPolicy(FlexibleRedirectPolicy(10), func(req *http.Request, via []*http.Request) error {\n\t\treturn errors.New(\"sample test redirect\")\n\t})\n\tclient.SetContentLength(true)\n\n\tclient.SetDebug(true)\n\tassertEqual(t, client.Debug, true)\n\n\tvar sl int64 = 1000000\n\tclient.SetDebugBodyLimit(sl)\n\tassertEqual(t, client.debugBodySizeLimit, sl)\n\n\tclient.SetAllowGetMethodPayload(true)\n\tassertEqual(t, client.AllowGetMethodPayload, true)\n\n\tclient.SetScheme(\"http\")\n\tassertEqual(t, client.scheme, \"http\")\n\n\tclient.SetCloseConnection(true)\n\tassertEqual(t, client.closeConnection, true)\n}\n\nfunc TestContentLengthWhenBodyIsNil(t *testing.T) {\n\tclient := dc()\n\n\tclient.SetPreRequestHook(func(c *Client, r *http.Request) error {\n\t\tassertEqual(t, \"0\", r.Header.Get(hdrContentLengthKey))\n\t\treturn nil\n\t})\n\n\tclient.R().SetContentLength(true).SetBody(nil).Get(\"http://localhost\")\n}\n\nfunc TestClientPreRequestHook(t *testing.T) {\n\tclient := dc()\n\tclient.SetPreRequestHook(func(c *Client, r *http.Request) error {\n\t\tc.log.Debugf(\"I'm in Pre-Request Hook\")\n\t\treturn nil\n\t})\n\n\tclient.SetPreRequestHook(func(c *Client, r *http.Request) error {\n\t\tc.log.Debugf(\"I'm Overwriting existing Pre-Request Hook\")\n\n\t\t// Reading Request `N` no of times\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tb, _ := r.GetBody()\n\t\t\trb, _ := io.ReadAll(b)\n\t\t\tc.log.Debugf(\"%s %v\", string(rb), len(rb))\n\t\t\tassertEqual(t, true, len(rb) >= 45)\n\t\t}\n\t\treturn nil\n\t})\n\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\t// Regular bodybuf use case\n\tresp, _ := client.R().\n\t\tSetBody(map[string]interface{}{\"username\": \"testuser\", \"password\": \"testpass\"}).\n\t\tPost(ts.URL + \"/login\")\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, `{ \"id\": \"success\", \"message\": \"login successful\" }`, resp.String())\n\n\t// io.Reader body use case\n\tresp, _ = client.R().\n\t\tSetHeader(hdrContentTypeKey, jsonContentType).\n\t\tSetBody(bytes.NewReader([]byte(`{\"username\":\"testuser\", \"password\":\"testpass\"}`))).\n\t\tPost(ts.URL + \"/login\")\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, `{ \"id\": \"success\", \"message\": \"login successful\" }`, resp.String())\n}\n\nfunc TestClientAllowsGetMethodPayload(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetAllowGetMethodPayload(true)\n\tc.SetPreRequestHook(func(*Client, *http.Request) error { return nil }) // for coverage\n\n\tpayload := \"test-payload\"\n\tresp, err := c.R().SetBody(payload).Get(ts.URL + \"/get-method-payload-test\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, payload, resp.String())\n}\n\nfunc TestClientAllowsGetMethodPayloadIoReader(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetAllowGetMethodPayload(true)\n\n\tpayload := \"test-payload\"\n\tbody := bytes.NewReader([]byte(payload))\n\tresp, err := c.R().SetBody(body).Get(ts.URL + \"/get-method-payload-test\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, payload, resp.String())\n}\n\nfunc TestClientAllowsGetMethodPayloadDisabled(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetAllowGetMethodPayload(false)\n\n\tpayload := bytes.NewReader([]byte(\"test-payload\"))\n\tresp, err := c.R().SetBody(payload).Get(ts.URL + \"/get-method-payload-test\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"\", resp.String())\n}\n\nfunc TestClientRoundTripper(t *testing.T) {\n\tc := NewWithClient(&http.Client{})\n\tc.outputLogTo(io.Discard)\n\n\trt := &CustomRoundTripper{}\n\tc.SetTransport(rt)\n\n\tct, err := c.Transport()\n\tassertNotNil(t, err)\n\tassertNil(t, ct)\n\tassertEqual(t, \"current transport is not an *http.Transport instance\", err.Error())\n\n\tc.SetTLSClientConfig(&tls.Config{})\n\tc.SetProxy(\"http://localhost:9090\")\n\tc.RemoveProxy()\n\tc.SetCertificates(tls.Certificate{})\n\tc.SetRootCertificate(filepath.Join(getTestDataPath(), \"sample-root.pem\"))\n}\n\nfunc TestClientNewRequest(t *testing.T) {\n\tc := New()\n\trequest := c.NewRequest()\n\tassertNotNil(t, request)\n}\n\nfunc TestClientSetJSONMarshaler(t *testing.T) {\n\tm := func(v interface{}) ([]byte, error) { return nil, nil }\n\tc := New().SetJSONMarshaler(m)\n\tp1 := fmt.Sprintf(\"%p\", c.JSONMarshal)\n\tp2 := fmt.Sprintf(\"%p\", m)\n\tassertEqual(t, p1, p2) // functions can not be compared, we only can compare pointers\n}\n\nfunc TestClientSetJSONUnmarshaler(t *testing.T) {\n\tm := func([]byte, interface{}) error { return nil }\n\tc := New().SetJSONUnmarshaler(m)\n\tp1 := fmt.Sprintf(\"%p\", c.JSONUnmarshal)\n\tp2 := fmt.Sprintf(\"%p\", m)\n\tassertEqual(t, p1, p2) // functions can not be compared, we only can compare pointers\n}\n\nfunc TestClientSetXMLMarshaler(t *testing.T) {\n\tm := func(v interface{}) ([]byte, error) { return nil, nil }\n\tc := New().SetXMLMarshaler(m)\n\tp1 := fmt.Sprintf(\"%p\", c.XMLMarshal)\n\tp2 := fmt.Sprintf(\"%p\", m)\n\tassertEqual(t, p1, p2) // functions can not be compared, we only can compare pointers\n}\n\nfunc TestClientSetXMLUnmarshaler(t *testing.T) {\n\tm := func([]byte, interface{}) error { return nil }\n\tc := New().SetXMLUnmarshaler(m)\n\tp1 := fmt.Sprintf(\"%p\", c.XMLUnmarshal)\n\tp2 := fmt.Sprintf(\"%p\", m)\n\tassertEqual(t, p1, p2) // functions can not be compared, we only can compare pointers\n}\n\nfunc TestDebugBodySizeLimit(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tvar lgr bytes.Buffer\n\tc := dc()\n\tc.SetDebug(true)\n\tc.SetDebugBodyLimit(30)\n\tc.outputLogTo(&lgr)\n\n\ttestcases := []struct{ url, want string }{\n\t\t// Text, does not exceed limit.\n\t\t{ts.URL, \"TestGet: text response\"},\n\t\t// Empty response.\n\t\t{ts.URL + \"/no-content\", \"***** NO CONTENT *****\"},\n\t\t// JSON, does not exceed limit.\n\t\t{ts.URL + \"/json\", \"{\\n   \\\"TestGet\\\": \\\"JSON response\\\"\\n}\"},\n\t\t// Invalid JSON, does not exceed limit.\n\t\t{ts.URL + \"/json-invalid\", \"TestGet: Invalid JSON\"},\n\t\t// Text, exceeds limit.\n\t\t{ts.URL + \"/long-text\", \"RESPONSE TOO LARGE\"},\n\t\t// JSON, exceeds limit.\n\t\t{ts.URL + \"/long-json\", \"RESPONSE TOO LARGE\"},\n\t}\n\n\tfor _, tc := range testcases {\n\t\t_, err := c.R().Get(tc.url)\n\t\tassertError(t, err)\n\t\tdebugLog := lgr.String()\n\t\tif !strings.Contains(debugLog, tc.want) {\n\t\t\tt.Errorf(\"Expected logs to contain [%v], got [\\n%v]\", tc.want, debugLog)\n\t\t}\n\t\tlgr.Reset()\n\t}\n}\n\n// CustomRoundTripper just for test\ntype CustomRoundTripper struct {\n}\n\n// RoundTrip just for test\nfunc (rt *CustomRoundTripper) RoundTrip(_ *http.Request) (*http.Response, error) {\n\treturn &http.Response{}, nil\n}\n\nfunc TestAutoGzip(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tc := New()\n\ttestcases := []struct{ url, want string }{\n\t\t{ts.URL + \"/gzip-test\", \"This is Gzip response testing\"},\n\t\t{ts.URL + \"/gzip-test-gziped-empty-body\", \"\"},\n\t\t{ts.URL + \"/gzip-test-no-gziped-body\", \"\"},\n\t}\n\tfor _, tc := range testcases {\n\t\tresp, err := c.R().\n\t\t\tSetHeader(\"Accept-Encoding\", \"gzip\").\n\t\t\tGet(tc.url)\n\n\t\tassertError(t, err)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\t\tassertEqual(t, \"200 OK\", resp.Status())\n\t\tassertNotNil(t, resp.Body())\n\t\tassertEqual(t, tc.want, resp.String())\n\n\t\tlogResponse(t, resp)\n\t}\n}\n\nfunc TestLogCallbacks(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := New().SetDebug(true)\n\n\tvar lgr bytes.Buffer\n\tc.outputLogTo(&lgr)\n\n\tc.OnRequestLog(func(r *RequestLog) error {\n\t\t// masking authorization header\n\t\tr.Header.Set(\"Authorization\", \"Bearer *******************************\")\n\t\treturn nil\n\t})\n\tc.OnResponseLog(func(r *ResponseLog) error {\n\t\tr.Header.Add(\"X-Debug-Response-Log\", \"Modified :)\")\n\t\tr.Body += \"\\nModified the response body content\"\n\t\treturn nil\n\t})\n\n\tc.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF\")\n\n\tresp, err := c.R().\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF-Request\").\n\t\tGet(ts.URL + \"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\t// Validating debug log updates\n\tlogInfo := lgr.String()\n\tassertEqual(t, true, strings.Contains(logInfo, \"Bearer *******************************\"))\n\tassertEqual(t, true, strings.Contains(logInfo, \"X-Debug-Response-Log\"))\n\tassertEqual(t, true, strings.Contains(logInfo, \"Modified the response body content\"))\n\n\t// Error scenario\n\tc.OnRequestLog(func(r *RequestLog) error { return errors.New(\"request test error\") })\n\tresp, err = c.R().\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF-Request\").\n\t\tGet(ts.URL + \"/profile\")\n\tassertEqual(t, errors.New(\"request test error\"), err)\n\tassertNil(t, resp)\n\tassertNotNil(t, err)\n\n\tc.OnRequestLog(nil)\n\tc.OnResponseLog(func(r *ResponseLog) error { return errors.New(\"response test error\") })\n\tresp, err = c.R().\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF-Request\").\n\t\tGet(ts.URL + \"/profile\")\n\tassertEqual(t, errors.New(\"response test error\"), err)\n\tassertNotNil(t, resp)\n}\n\nfunc TestDebugLogSimultaneously(t *testing.T) {\n\tts := createGetServer(t)\n\n\tc := New().\n\t\tSetDebug(true).\n\t\tSetBaseURL(ts.URL).\n\t\toutputLogTo(io.Discard)\n\n\tt.Cleanup(ts.Close)\n\tfor i := 0; i < 50; i++ {\n\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tresp, err := c.R().\n\t\t\t\tSetBody([]int{1, 2, 3}).\n\t\t\t\tSetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\t\t\tPost(\"/\")\n\n\t\t\tassertError(t, err)\n\t\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\t\t})\n\t}\n}\n\nfunc TestNewWithLocalAddr(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tlocalAddress, _ := net.ResolveTCPAddr(\"tcp\", \"127.0.0.1\")\n\tclient := NewWithLocalAddr(localAddress)\n\tclient.SetHostURL(ts.URL)\n\n\tresp, err := client.R().Get(\"/\")\n\tassertNil(t, err)\n\tassertEqual(t, resp.String(), \"TestGet: text response\")\n}\n\nfunc TestClientOnResponseError(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tsetup       func(*Client)\n\t\tisError     bool\n\t\thasResponse bool\n\t\tpanics      bool\n\t}{\n\t\t{\n\t\t\tname: \"successful_request\",\n\t\t},\n\t\t{\n\t\t\tname: \"http_status_error\",\n\t\t\tsetup: func(client *Client) {\n\t\t\t\tclient.SetAuthToken(\"BAD\")\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"before_request_error\",\n\t\t\tsetup: func(client *Client) {\n\t\t\t\tclient.OnBeforeRequest(func(client *Client, request *Request) error {\n\t\t\t\t\treturn fmt.Errorf(\"before request\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"before_request_error_retry\",\n\t\t\tsetup: func(client *Client) {\n\t\t\t\tclient.SetRetryCount(3).OnBeforeRequest(func(client *Client, request *Request) error {\n\t\t\t\t\treturn fmt.Errorf(\"before request\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tisError: true,\n\t\t},\n\t\t{\n\t\t\tname: \"after_response_error\",\n\t\t\tsetup: func(client *Client) {\n\t\t\t\tclient.OnAfterResponse(func(client *Client, response *Response) error {\n\t\t\t\t\treturn fmt.Errorf(\"after response\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tisError:     true,\n\t\t\thasResponse: true,\n\t\t},\n\t\t{\n\t\t\tname: \"after_response_error_retry\",\n\t\t\tsetup: func(client *Client) {\n\t\t\t\tclient.SetRetryCount(3).OnAfterResponse(func(client *Client, response *Response) error {\n\t\t\t\t\treturn fmt.Errorf(\"after response\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tisError:     true,\n\t\t\thasResponse: true,\n\t\t},\n\t\t{\n\t\t\tname: \"panic with error\",\n\t\t\tsetup: func(client *Client) {\n\t\t\t\tclient.OnBeforeRequest(func(client *Client, request *Request) error {\n\t\t\t\t\tpanic(fmt.Errorf(\"before request\"))\n\t\t\t\t})\n\t\t\t},\n\t\t\tisError:     false,\n\t\t\thasResponse: false,\n\t\t\tpanics:      true,\n\t\t},\n\t\t{\n\t\t\tname: \"panic with string\",\n\t\t\tsetup: func(client *Client) {\n\t\t\t\tclient.OnBeforeRequest(func(client *Client, request *Request) error {\n\t\t\t\t\tpanic(\"before request\")\n\t\t\t\t})\n\t\t\t},\n\t\t\tisError:     false,\n\t\t\thasResponse: false,\n\t\t\tpanics:      true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tts := createAuthServer(t)\n\t\t\tdefer ts.Close()\n\n\t\t\tvar assertErrorHook = func(r *Request, err error) {\n\t\t\t\tassertNotNil(t, r)\n\t\t\t\tv, ok := err.(*ResponseError)\n\t\t\t\tassertEqual(t, test.hasResponse, ok)\n\t\t\t\tif ok {\n\t\t\t\t\tassertNotNil(t, v.Response)\n\t\t\t\t\tassertNotNil(t, v.Err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar hook1, hook2, hook3, hook4, hook5, hook6 int\n\t\t\tdefer func() {\n\t\t\t\tif rec := recover(); rec != nil {\n\t\t\t\t\tassertEqual(t, true, test.panics)\n\t\t\t\t\tassertEqual(t, 0, hook1)\n\t\t\t\t\tassertEqual(t, 0, hook3)\n\t\t\t\t\tassertEqual(t, 1, hook5)\n\t\t\t\t\tassertEqual(t, 1, hook6)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tc := New().outputLogTo(io.Discard).\n\t\t\t\tSetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\t\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF\").\n\t\t\t\tSetRetryCount(0).\n\t\t\t\tSetRetryMaxWaitTime(time.Microsecond).\n\t\t\t\tAddRetryCondition(func(response *Response, err error) bool {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t\treturn response.IsError()\n\t\t\t\t}).\n\t\t\t\tOnError(func(r *Request, err error) {\n\t\t\t\t\tassertErrorHook(r, err)\n\t\t\t\t\thook1++\n\t\t\t\t}).\n\t\t\t\tOnError(func(r *Request, err error) {\n\t\t\t\t\tassertErrorHook(r, err)\n\t\t\t\t\thook2++\n\t\t\t\t}).\n\t\t\t\tOnPanic(func(r *Request, err error) {\n\t\t\t\t\tassertErrorHook(r, err)\n\t\t\t\t\thook5++\n\t\t\t\t}).\n\t\t\t\tOnPanic(func(r *Request, err error) {\n\t\t\t\t\tassertErrorHook(r, err)\n\t\t\t\t\thook6++\n\t\t\t\t}).\n\t\t\t\tOnSuccess(func(c *Client, resp *Response) {\n\t\t\t\t\tassertNotNil(t, c)\n\t\t\t\t\tassertNotNil(t, resp)\n\t\t\t\t\thook3++\n\t\t\t\t}).\n\t\t\t\tOnSuccess(func(c *Client, resp *Response) {\n\t\t\t\t\tassertNotNil(t, c)\n\t\t\t\t\tassertNotNil(t, resp)\n\t\t\t\t\thook4++\n\t\t\t\t})\n\t\t\tif test.setup != nil {\n\t\t\t\ttest.setup(c)\n\t\t\t}\n\t\t\t_, err := c.R().Get(ts.URL + \"/profile\")\n\t\t\tif test.isError {\n\t\t\t\tassertNotNil(t, err)\n\t\t\t\tassertEqual(t, 1, hook1)\n\t\t\t\tassertEqual(t, 1, hook2)\n\t\t\t\tassertEqual(t, 0, hook3)\n\t\t\t\tassertEqual(t, 0, hook5)\n\t\t\t} else {\n\t\t\t\tassertError(t, err)\n\t\t\t\tassertEqual(t, 0, hook1)\n\t\t\t\tassertEqual(t, 1, hook3)\n\t\t\t\tassertEqual(t, 1, hook4)\n\t\t\t\tassertEqual(t, 0, hook5)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestResponseError(t *testing.T) {\n\terr := errors.New(\"error message\")\n\tre := &ResponseError{\n\t\tResponse: &Response{},\n\t\tErr:      err,\n\t}\n\tassertNotNil(t, re.Unwrap())\n\tassertEqual(t, err.Error(), re.Error())\n}\n\nfunc TestHostURLForGH318AndGH407(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\ttargetURL, _ := url.Parse(ts.URL)\n\tt.Log(\"ts.URL:\", ts.URL)\n\tt.Log(\"targetURL.Host:\", targetURL.Host)\n\t// Sample output\n\t// ts.URL: http://127.0.0.1:55967\n\t// targetURL.Host: 127.0.0.1:55967\n\n\t// Unable use the local http test server for this\n\t// use case testing\n\t//\n\t// using `targetURL.Host` value or test case yield to ERROR\n\t// \"parse \"127.0.0.1:55967\": first path segment in URL cannot contain colon\"\n\n\t// test the functionality with httpbin.org locally\n\t// will figure out later\n\n\tc := dc()\n\t// c.SetScheme(\"http\")\n\t// c.SetHostURL(targetURL.Host + \"/\")\n\n\t// t.Log(\"with leading `/`\")\n\t// resp, err := c.R().Post(\"/login\")\n\t// assertNil(t, err)\n\t// assertNotNil(t, resp)\n\n\t// t.Log(\"\\nwithout leading `/`\")\n\t// resp, err = c.R().Post(\"login\")\n\t// assertNil(t, err)\n\t// assertNotNil(t, resp)\n\n\tt.Log(\"with leading `/` on request & with trailing `/` on host url\")\n\tc.SetHostURL(ts.URL + \"/\")\n\tresp, err := c.R().\n\t\tSetBody(map[string]interface{}{\"username\": \"testuser\", \"password\": \"testpass\"}).\n\t\tPost(\"/login\")\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n}\n\nfunc TestPostRedirectWithBody(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\ttargetURL, _ := url.Parse(ts.URL)\n\tt.Log(\"ts.URL:\", ts.URL)\n\tt.Log(\"targetURL.Host:\", targetURL.Host)\n\n\tc := dc()\n\twg := sync.WaitGroup{}\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tresp, err := c.R().\n\t\t\t\tSetBody([]byte(strconv.Itoa(newRnd().Int()))).\n\t\t\t\tPost(targetURL.String() + \"/redirect-with-body\")\n\t\t\tassertError(t, err)\n\t\t\tassertNotNil(t, resp)\n\t\t}()\n\t}\n\twg.Wait()\n}\n\nfunc TestUnixSocket(t *testing.T) {\n\tunixSocketAddr := createUnixSocketEchoServer(t)\n\tdefer os.Remove(unixSocketAddr)\n\n\t// Create a Go's http.Transport so we can set it in resty.\n\ttransport := http.Transport{\n\t\tDial: func(_, _ string) (net.Conn, error) {\n\t\t\treturn net.Dial(\"unix\", unixSocketAddr)\n\t\t},\n\t}\n\n\t// Create a Resty Client\n\tclient := New()\n\n\t// Set the previous transport that we created, set the scheme of the communication to the\n\t// socket and set the unixSocket as the HostURL.\n\tclient.SetTransport(&transport).SetScheme(\"http\").SetHostURL(unixSocketAddr)\n\n\t// No need to write the host's URL on the request, just the path.\n\tres, err := client.R().Get(\"http://localhost/\")\n\tassertNil(t, err)\n\tassertEqual(t, \"Hi resty client from a server running on Unix domain socket!\", res.String())\n\n\tres, err = client.R().Get(\"http://localhost/hello\")\n\tassertNil(t, err)\n\tassertEqual(t, \"Hello resty client from a server running on endpoint /hello!\", res.String())\n}\n\nfunc TestClone(t *testing.T) {\n\tparent := New()\n\n\t// set a non-interface field\n\tparent.SetBaseURL(\"http://localhost\")\n\n\t// set an interface field\n\tparent.UserInfo = &User{\n\t\tUsername: \"parent\",\n\t}\n\n\tclone := parent.Clone()\n\t// update value of non-interface type - change will only happen on clone\n\tclone.SetBaseURL(\"https://local.host\")\n\t// update value of interface type - change will also happen on parent\n\tclone.UserInfo.Username = \"clone\"\n\n\t// asert non-interface type\n\tassertEqual(t, \"http://localhost\", parent.BaseURL)\n\tassertEqual(t, \"https://local.host\", clone.BaseURL)\n\n\t// assert interface type\n\tassertEqual(t, \"clone\", parent.UserInfo.Username)\n\tassertEqual(t, \"clone\", clone.UserInfo.Username)\n}\n\nfunc TestResponseBodyLimit(t *testing.T) {\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tio.CopyN(w, rand.Reader, 100*800)\n\t})\n\tdefer ts.Close()\n\n\tt.Run(\"Client body limit\", func(t *testing.T) {\n\t\tc := dc().SetResponseBodyLimit(1024)\n\n\t\t_, err := c.R().Get(ts.URL + \"/\")\n\t\tassertNotNil(t, err)\n\t\tassertErrorIs(t, ErrResponseBodyTooLarge, err)\n\t})\n\n\tt.Run(\"request body limit\", func(t *testing.T) {\n\t\tc := dc()\n\n\t\t_, err := c.R().SetResponseBodyLimit(1024).Get(ts.URL + \"/\")\n\t\tassertNotNil(t, err)\n\t\tassertErrorIs(t, ErrResponseBodyTooLarge, err)\n\t})\n\n\tt.Run(\"body less than limit\", func(t *testing.T) {\n\t\tc := dc()\n\n\t\tres, err := c.R().SetResponseBodyLimit(800*100 + 10).Get(ts.URL + \"/\")\n\t\tassertNil(t, err)\n\t\tassertEqual(t, 800*100, len(res.body))\n\t})\n\n\tt.Run(\"no body limit\", func(t *testing.T) {\n\t\tc := dc()\n\n\t\tres, err := c.R().Get(ts.URL + \"/\")\n\t\tassertNil(t, err)\n\t\tassertEqual(t, 800*100, len(res.body))\n\t})\n\n\tt.Run(\"read error\", func(t *testing.T) {\n\t\ttse := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Header().Set(hdrContentEncodingKey, \"gzip\")\n\t\t\tvar buf [1024]byte\n\t\t\tw.Write(buf[:])\n\t\t})\n\t\tdefer tse.Close()\n\n\t\tc := dc()\n\n\t\t_, err := c.R().SetResponseBodyLimit(10240).Get(tse.URL + \"/\")\n\t\tassertErrorIs(t, gzip.ErrHeader, err)\n\t})\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 5.1142578125,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com)\n// 2016 Andrew Grigorev (https://github.com/ei-grad)\n// All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSetContext(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().R().\n\t\tSetContext(context.Background()).\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertEqual(t, true, resp.Body() != nil)\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestSetContextWithError(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dcr().\n\t\tSetContext(context.Background()).\n\t\tGet(ts.URL + \"/mypage\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusBadRequest, resp.StatusCode())\n\tassertEqual(t, \"\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestSetContextCancel(t *testing.T) {\n\tch := make(chan struct{})\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tch <- struct{}{} // tell test request is finished\n\t\t}()\n\t\tt.Logf(\"Server: %v %v\", r.Method, r.URL.Path)\n\t\tch <- struct{}{}\n\t\t<-ch // wait for client to finish request\n\t\tn, err := w.Write([]byte(\"TestSetContextCancel: response\"))\n\t\t// FIXME? test server doesn't handle request cancellation\n\t\tt.Logf(\"Server: wrote %d bytes\", n)\n\t\tt.Logf(\"Server: err is %v \", err)\n\t})\n\tdefer ts.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\t<-ch // wait for server to start request handling\n\t\tcancel()\n\t}()\n\n\t_, err := dc().R().\n\t\tSetContext(ctx).\n\t\tGet(ts.URL + \"/\")\n\n\tch <- struct{}{} // tell server to continue request handling\n\n\t<-ch // wait for server to finish request handling\n\n\tt.Logf(\"Error: %v\", err)\n\tif !errIsContextCanceled(err) {\n\t\tt.Errorf(\"Got unexpected error: %v\", err)\n\t}\n}\n\nfunc TestSetContextCancelRetry(t *testing.T) {\n\treqCount := 0\n\tch := make(chan struct{})\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\treqCount++\n\t\tdefer func() {\n\t\t\tch <- struct{}{} // tell test request is finished\n\t\t}()\n\t\tt.Logf(\"Server: %v %v\", r.Method, r.URL.Path)\n\t\tch <- struct{}{}\n\t\t<-ch // wait for client to finish request\n\t\tn, err := w.Write([]byte(\"TestSetContextCancel: response\"))\n\t\t// FIXME? test server doesn't handle request cancellation\n\t\tt.Logf(\"Server: wrote %d bytes\", n)\n\t\tt.Logf(\"Server: err is %v \", err)\n\t})\n\tdefer ts.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\t<-ch // wait for server to start request handling\n\t\tcancel()\n\t}()\n\n\tc := dc().\n\t\tSetTimeout(time.Second * 3).\n\t\tSetRetryCount(3)\n\n\t_, err := c.R().\n\t\tSetContext(ctx).\n\t\tGet(ts.URL + \"/\")\n\n\tch <- struct{}{} // tell server to continue request handling\n\n\t<-ch // wait for server to finish request handling\n\n\tt.Logf(\"Error: %v\", err)\n\tif !errIsContextCanceled(err) {\n\t\tt.Errorf(\"Got unexpected error: %v\", err)\n\t}\n\n\tif reqCount != 1 {\n\t\tt.Errorf(\"Request was retried %d times instead of 1\", reqCount)\n\t}\n}\n\nfunc TestSetContextCancelWithError(t *testing.T) {\n\tch := make(chan struct{})\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tdefer func() {\n\t\t\tch <- struct{}{} // tell test request is finished\n\t\t}()\n\t\tt.Logf(\"Server: %v %v\", r.Method, r.URL.Path)\n\t\tt.Log(\"Server: sending StatusBadRequest response\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tch <- struct{}{}\n\t\t<-ch // wait for client to finish request\n\t\tn, err := w.Write([]byte(\"TestSetContextCancelWithError: response\"))\n\t\t// FIXME? test server doesn't handle request cancellation\n\t\tt.Logf(\"Server: wrote %d bytes\", n)\n\t\tt.Logf(\"Server: err is %v \", err)\n\t})\n\tdefer ts.Close()\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\tgo func() {\n\t\t<-ch // wait for server to start request handling\n\t\tcancel()\n\t}()\n\n\t_, err := dc().R().\n\t\tSetContext(ctx).\n\t\tGet(ts.URL + \"/\")\n\n\tch <- struct{}{} // tell server to continue request handling\n\n\t<-ch // wait for server to finish request handling\n\n\tt.Logf(\"Error: %v\", err)\n\tif !errIsContextCanceled(err) {\n\t\tt.Errorf(\"Got unexpected error: %v\", err)\n\t}\n}\n\nfunc TestClientRetryWithSetContext(t *testing.T) {\n\tvar attemptctx int32\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\t\tattp := atomic.AddInt32(&attemptctx, 1)\n\t\tif attp <= 4 {\n\t\t\ttime.Sleep(time.Second * 2)\n\t\t}\n\t\t_, _ = w.Write([]byte(\"TestClientRetry page\"))\n\t})\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetTimeout(time.Second * 1).\n\t\tSetRetryCount(3)\n\n\t_, err := c.R().\n\t\tSetContext(context.Background()).\n\t\tGet(ts.URL + \"/\")\n\n\tassertNotNil(t, ts)\n\tassertNotNil(t, err)\n\tassertEqual(t, true, (strings.HasPrefix(err.Error(), \"Get \"+ts.URL+\"/\") ||\n\t\tstrings.HasPrefix(err.Error(), \"Get \\\"\"+ts.URL+\"/\\\"\")))\n}\n\nfunc TestRequestContext(t *testing.T) {\n\tclient := dc()\n\tr := client.NewRequest()\n\tassertNotNil(t, r.Context())\n\n\tr.SetContext(context.Background())\n\tassertNotNil(t, r.Context())\n}\n\nfunc errIsContextCanceled(err error) bool {\n\treturn errors.Is(err, context.Canceled)\n}\n"
        },
        {
          "name": "curl_cmd_test.go",
          "type": "blob",
          "size": 5.84765625,
          "content": "package resty\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// 1. Generate curl for unexecuted request(dry-run)\nfunc TestGenerateUnexecutedCurl(t *testing.T) {\n\treq := dclr().\n\t\tSetBody(map[string]string{\n\t\t\t\"name\": \"Alex\",\n\t\t}).\n\t\tSetCookies(\n\t\t\t[]*http.Cookie{\n\t\t\t\t{Name: \"count\", Value: \"1\"},\n\t\t\t},\n\t\t)\n\n\tcurlCmdUnexecuted := req.EnableGenerateCurlOnDebug().GenerateCurlCommand()\n\treq.DisableGenerateCurlOnDebug()\n\n\tif !strings.Contains(curlCmdUnexecuted, \"Cookie: count=1\") ||\n\t\t!strings.Contains(curlCmdUnexecuted, \"curl -X GET\") ||\n\t\t!strings.Contains(curlCmdUnexecuted, `-d '{\"name\":\"Alex\"}'`) {\n\t\tt.Fatal(\"Incomplete curl:\", curlCmdUnexecuted)\n\t} else {\n\t\tt.Log(\"curlCmdUnexecuted: \\n\", curlCmdUnexecuted)\n\t}\n\n}\n\n// 2. Generate curl for executed request\nfunc TestGenerateExecutedCurl(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tdata := map[string]string{\n\t\t\"name\": \"Alex\",\n\t}\n\tc := dcl()\n\treq := c.R().\n\t\tSetBody(data).\n\t\tSetCookies(\n\t\t\t[]*http.Cookie{\n\t\t\t\t{Name: \"count\", Value: \"1\"},\n\t\t\t},\n\t\t)\n\n\turl := ts.URL + \"/curl-cmd-post\"\n\tresp, err := req.\n\t\tEnableGenerateCurlOnDebug().\n\t\tPost(url)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcurlCmdExecuted := resp.Request.GenerateCurlCommand()\n\n\tc.DisableGenerateCurlOnDebug()\n\treq.DisableGenerateCurlOnDebug()\n\tif !strings.Contains(curlCmdExecuted, \"Cookie: count=1\") ||\n\t\t!strings.Contains(curlCmdExecuted, \"curl -X POST\") ||\n\t\t!strings.Contains(curlCmdExecuted, `-d '{\"name\":\"Alex\"}'`) ||\n\t\t!strings.Contains(curlCmdExecuted, url) {\n\t\tt.Fatal(\"Incomplete curl:\", curlCmdExecuted)\n\t} else {\n\t\tt.Log(\"curlCmdExecuted: \\n\", curlCmdExecuted)\n\t}\n}\n\n// 3. Generate curl in debug mode\nfunc TestDebugModeCurl(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\t// 1. Capture stderr\n\tgetOutput, restore := captureStderr()\n\tdefer restore()\n\n\t// 2. Build request\n\tc := New()\n\treq := c.EnableGenerateCurlOnDebug().R().\n\t\tSetBody(map[string]string{\n\t\t\t\"name\": \"Alex\",\n\t\t}).\n\t\tSetCookies(\n\t\t\t[]*http.Cookie{\n\t\t\t\t{Name: \"count\", Value: \"1\"},\n\t\t\t},\n\t\t)\n\n\t// 3. Execute request: set debug mode\n\turl := ts.URL + \"/curl-cmd-post\"\n\t_, err := req.SetDebug(true).Post(url)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tc.DisableGenerateCurlOnDebug()\n\treq.DisableGenerateCurlOnDebug()\n\n\t// 4. test output curl\n\toutput := getOutput()\n\tif !strings.Contains(output, \"Cookie: count=1\") ||\n\t\t!strings.Contains(output, `-d '{\"name\":\"Alex\"}'`) {\n\t\tt.Fatal(\"Incomplete debug curl info:\", output)\n\t} else {\n\t\tt.Log(\"Normal debug curl info: \\n\", output)\n\t}\n}\n\nfunc captureStderr() (getOutput func() string, restore func()) {\n\told := os.Stderr\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tos.Stderr = w\n\tgetOutput = func() string {\n\t\tw.Close()\n\t\tbuf := make([]byte, 2048)\n\t\tn, err := r.Read(buf)\n\t\tif err != nil && err != io.EOF {\n\t\t\tpanic(err)\n\t\t}\n\t\treturn string(buf[:n])\n\t}\n\trestore = func() {\n\t\tos.Stderr = old\n\t\tw.Close()\n\t}\n\treturn getOutput, restore\n}\n\nfunc TestBuildCurlCommand(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tmethod   string\n\t\turl      string\n\t\theaders  map[string]string\n\t\tbody     string\n\t\tcookies  []*http.Cookie\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"With Headers\",\n\t\t\tmethod:   \"GET\",\n\t\t\turl:      \"http://example.com\",\n\t\t\theaders:  map[string]string{\"Content-Type\": \"application/json\", \"Authorization\": \"Bearer token\"},\n\t\t\texpected: \"curl -X GET -H 'Authorization: Bearer token' -H 'Content-Type: application/json' http://example.com\",\n\t\t},\n\t\t{\n\t\t\tname:     \"With Body\",\n\t\t\tmethod:   \"POST\",\n\t\t\turl:      \"http://example.com\",\n\t\t\theaders:  map[string]string{\"Content-Type\": \"application/json\"},\n\t\t\tbody:     `{\"key\":\"value\"}`,\n\t\t\texpected: \"curl -X POST -H 'Content-Type: application/json' -d '{\\\"key\\\":\\\"value\\\"}' http://example.com\",\n\t\t},\n\t\t{\n\t\t\tname:     \"With Empty Body\",\n\t\t\tmethod:   \"POST\",\n\t\t\turl:      \"http://example.com\",\n\t\t\theaders:  map[string]string{\"Content-Type\": \"application/json\"},\n\t\t\texpected: \"curl -X POST -H 'Content-Type: application/json' http://example.com\",\n\t\t},\n\t\t{\n\t\t\tname:     \"With Query Params\",\n\t\t\tmethod:   \"GET\",\n\t\t\turl:      \"http://example.com?param1=value1&param2=value2\",\n\t\t\texpected: \"curl -X GET 'http://example.com?param1=value1&param2=value2'\",\n\t\t},\n\t\t{\n\t\t\tname:     \"With Special Characters in URL\",\n\t\t\tmethod:   \"GET\",\n\t\t\turl:      \"http://example.com/path with spaces\",\n\t\t\texpected: \"curl -X GET http://example.com/path%20with%20spaces\",\n\t\t},\n\t\t{\n\t\t\tname:     \"With Cookies\",\n\t\t\tmethod:   \"GET\",\n\t\t\turl:      \"http://example.com\",\n\t\t\tcookies:  []*http.Cookie{{Name: \"session_id\", Value: \"abc123\"}},\n\t\t\texpected: \"curl -X GET -H 'Cookie: session_id=abc123' http://example.com\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Without Cookies\",\n\t\t\tmethod:   \"GET\",\n\t\t\turl:      \"http://example.com\",\n\t\t\texpected: \"curl -X GET http://example.com\",\n\t\t},\n\t\t{\n\t\t\tname:     \"With Multiple Cookies\",\n\t\t\tmethod:   \"GET\",\n\t\t\turl:      \"http://example.com\",\n\t\t\tcookies:  []*http.Cookie{{Name: \"session_id\", Value: \"abc123\"}, {Name: \"user_id\", Value: \"user456\"}},\n\t\t\texpected: \"curl -X GET -H 'Cookie: session_id=abc123&user_id=user456' http://example.com\",\n\t\t},\n\t\t{\n\t\t\tname:     \"With Empty Cookie Jar\",\n\t\t\tmethod:   \"GET\",\n\t\t\turl:      \"http://example.com\",\n\t\t\texpected: \"curl -X GET http://example.com\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// Setup request\n\t\t\tvar (\n\t\t\t\treq *http.Request\n\t\t\t\terr error\n\t\t\t)\n\n\t\t\tif tt.body != \"\" {\n\t\t\t\treq, err = http.NewRequest(tt.method, tt.url, bytes.NewBufferString(tt.body))\n\t\t\t} else {\n\t\t\t\treq, err = http.NewRequest(tt.method, tt.url, nil)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"failed to create request: %v\", err)\n\t\t\t}\n\n\t\t\tfor k, v := range tt.headers {\n\t\t\t\treq.Header.Set(k, v)\n\t\t\t}\n\n\t\t\t// Setup cookie jar\n\t\t\tcookieJar, _ := cookiejar.New(nil)\n\t\t\tif len(tt.cookies) > 0 {\n\t\t\t\tcookieJar.SetCookies(req.URL, tt.cookies)\n\t\t\t}\n\n\t\t\t// Generate curl command\n\t\t\tcurl := buildCurlRequest(req, cookieJar)\n\n\t\t\t// Assert\n\t\t\tassertEqual(t, tt.expected, curl)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "digest.go",
          "type": "blob",
          "size": 7.37890625,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com)\n// 2023 Segev Dagan (https://github.com/segevda)\n// 2024 Philipp Wolfer (https://github.com/phw)\n// All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar (\n\tErrDigestBadChallenge    = errors.New(\"digest: challenge is bad\")\n\tErrDigestCharset         = errors.New(\"digest: unsupported charset\")\n\tErrDigestAlgNotSupported = errors.New(\"digest: algorithm is not supported\")\n\tErrDigestQopNotSupported = errors.New(\"digest: no supported qop in list\")\n\tErrDigestNoQop           = errors.New(\"digest: qop must be specified\")\n)\n\nvar hashFuncs = map[string]func() hash.Hash{\n\t\"\":                 md5.New,\n\t\"MD5\":              md5.New,\n\t\"MD5-sess\":         md5.New,\n\t\"SHA-256\":          sha256.New,\n\t\"SHA-256-sess\":     sha256.New,\n\t\"SHA-512-256\":      sha512.New,\n\t\"SHA-512-256-sess\": sha512.New,\n}\n\ntype digestCredentials struct {\n\tusername, password string\n}\n\ntype digestTransport struct {\n\tdigestCredentials\n\ttransport http.RoundTripper\n}\n\nfunc (dt *digestTransport) RoundTrip(req *http.Request) (*http.Response, error) {\n\t// Copy the request, so we don't modify the input.\n\treq2 := new(http.Request)\n\t*req2 = *req\n\treq2.Header = make(http.Header)\n\tfor k, s := range req.Header {\n\t\treq2.Header[k] = s\n\t}\n\n\t// Fix http: ContentLength=xxx with Body length 0\n\tif req2.Body == nil {\n\t\treq2.ContentLength = 0\n\t} else if req2.GetBody != nil {\n\t\tvar err error\n\t\treq2.Body, err = req2.GetBody()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Make a request to get the 401 that contains the challenge.\n\tresp, err := dt.transport.RoundTrip(req)\n\tif err != nil || resp.StatusCode != http.StatusUnauthorized {\n\t\treturn resp, err\n\t}\n\tchal := resp.Header.Get(hdrWwwAuthenticateKey)\n\tif chal == \"\" {\n\t\treturn resp, ErrDigestBadChallenge\n\t}\n\n\tc, err := parseChallenge(chal)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\n\t// Form credentials based on the challenge\n\tcr := dt.newCredentials(req2, c)\n\tauth, err := cr.authorize()\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\terr = resp.Body.Close()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Make authenticated request\n\treq2.Header.Set(hdrAuthorizationKey, auth)\n\treturn dt.transport.RoundTrip(req2)\n}\n\nfunc (dt *digestTransport) newCredentials(req *http.Request, c *challenge) *credentials {\n\treturn &credentials{\n\t\tusername:   dt.username,\n\t\tuserhash:   c.userhash,\n\t\trealm:      c.realm,\n\t\tnonce:      c.nonce,\n\t\tdigestURI:  req.URL.RequestURI(),\n\t\talgorithm:  c.algorithm,\n\t\tsessionAlg: strings.HasSuffix(c.algorithm, \"-sess\"),\n\t\topaque:     c.opaque,\n\t\tmessageQop: c.qop,\n\t\tnc:         0,\n\t\tmethod:     req.Method,\n\t\tpassword:   dt.password,\n\t}\n}\n\ntype challenge struct {\n\trealm     string\n\tdomain    string\n\tnonce     string\n\topaque    string\n\tstale     string\n\talgorithm string\n\tqop       string\n\tuserhash  string\n}\n\nfunc (c *challenge) setValue(k, v string) error {\n\tswitch k {\n\tcase \"realm\":\n\t\tc.realm = v\n\tcase \"domain\":\n\t\tc.domain = v\n\tcase \"nonce\":\n\t\tc.nonce = v\n\tcase \"opaque\":\n\t\tc.opaque = v\n\tcase \"stale\":\n\t\tc.stale = v\n\tcase \"algorithm\":\n\t\tc.algorithm = v\n\tcase \"qop\":\n\t\tc.qop = v\n\tcase \"charset\":\n\t\tif strings.ToUpper(v) != \"UTF-8\" {\n\t\t\treturn ErrDigestCharset\n\t\t}\n\tcase \"userhash\":\n\t\tc.userhash = v\n\tdefault:\n\t\treturn ErrDigestBadChallenge\n\t}\n\treturn nil\n}\n\nfunc parseChallenge(input string) (*challenge, error) {\n\tconst ws = \" \\n\\r\\t\"\n\ts := strings.Trim(input, ws)\n\tif !strings.HasPrefix(s, \"Digest \") {\n\t\treturn nil, ErrDigestBadChallenge\n\t}\n\ts = strings.Trim(s[7:], ws)\n\tc := &challenge{}\n\tb := strings.Builder{}\n\tkey := \"\"\n\tquoted := false\n\tfor _, r := range s {\n\t\tswitch r {\n\t\tcase '\"':\n\t\t\tquoted = !quoted\n\t\tcase ',':\n\t\t\tif quoted {\n\t\t\t\tb.WriteRune(r)\n\t\t\t} else {\n\t\t\t\tval := strings.Trim(b.String(), ws)\n\t\t\t\tb.Reset()\n\t\t\t\tif err := c.setValue(key, val); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tkey = \"\"\n\t\t\t}\n\t\tcase '=':\n\t\t\tif quoted {\n\t\t\t\tb.WriteRune(r)\n\t\t\t} else {\n\t\t\t\tkey = strings.Trim(b.String(), ws)\n\t\t\t\tb.Reset()\n\t\t\t}\n\t\tdefault:\n\t\t\tb.WriteRune(r)\n\t\t}\n\t}\n\tif quoted || (key == \"\" && b.Len() > 0) {\n\t\treturn nil, ErrDigestBadChallenge\n\t}\n\tif key != \"\" {\n\t\tval := strings.Trim(b.String(), ws)\n\t\tif err := c.setValue(key, val); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn c, nil\n}\n\ntype credentials struct {\n\tusername   string\n\tuserhash   string\n\trealm      string\n\tnonce      string\n\tdigestURI  string\n\talgorithm  string\n\tsessionAlg bool\n\tcNonce     string\n\topaque     string\n\tmessageQop string\n\tnc         int\n\tmethod     string\n\tpassword   string\n}\n\nfunc (c *credentials) authorize() (string, error) {\n\tif _, ok := hashFuncs[c.algorithm]; !ok {\n\t\treturn \"\", ErrDigestAlgNotSupported\n\t}\n\n\tif err := c.validateQop(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\tresp, err := c.resp()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tsl := make([]string, 0, 10)\n\tif c.userhash == \"true\" {\n\t\t// RFC 7616 3.4.4\n\t\tc.username = c.h(fmt.Sprintf(\"%s:%s\", c.username, c.realm))\n\t\tsl = append(sl, fmt.Sprintf(`userhash=%s`, c.userhash))\n\t}\n\tsl = append(sl, fmt.Sprintf(`username=\"%s\"`, c.username))\n\tsl = append(sl, fmt.Sprintf(`realm=\"%s\"`, c.realm))\n\tsl = append(sl, fmt.Sprintf(`nonce=\"%s\"`, c.nonce))\n\tsl = append(sl, fmt.Sprintf(`uri=\"%s\"`, c.digestURI))\n\tsl = append(sl, fmt.Sprintf(`response=\"%s\"`, resp))\n\tsl = append(sl, fmt.Sprintf(`algorithm=%s`, c.algorithm))\n\tif c.opaque != \"\" {\n\t\tsl = append(sl, fmt.Sprintf(`opaque=\"%s\"`, c.opaque))\n\t}\n\tif c.messageQop != \"\" {\n\t\tsl = append(sl, fmt.Sprintf(\"qop=%s\", c.messageQop))\n\t\tsl = append(sl, fmt.Sprintf(\"nc=%08x\", c.nc))\n\t\tsl = append(sl, fmt.Sprintf(`cnonce=\"%s\"`, c.cNonce))\n\t}\n\n\treturn fmt.Sprintf(\"Digest %s\", strings.Join(sl, \", \")), nil\n}\n\nfunc (c *credentials) validateQop() error {\n\t// Currently only supporting auth quality of protection. TODO: add auth-int support\n\t// NOTE: cURL support auth-int qop for requests other than POST and PUT (i.e. w/o body) by hashing an empty string\n\t// is this applicable for resty? see: https://github.com/curl/curl/blob/307b7543ea1e73ab04e062bdbe4b5bb409eaba3a/lib/vauth/digest.c#L774\n\tif c.messageQop == \"\" {\n\t\treturn ErrDigestNoQop\n\t}\n\tpossibleQops := strings.Split(c.messageQop, \",\")\n\tvar authSupport bool\n\tfor _, qop := range possibleQops {\n\t\tqop = strings.TrimSpace(qop)\n\t\tif qop == \"auth\" {\n\t\t\tauthSupport = true\n\t\t\tbreak\n\t\t}\n\t}\n\tif !authSupport {\n\t\treturn ErrDigestQopNotSupported\n\t}\n\n\tc.messageQop = \"auth\"\n\n\treturn nil\n}\n\nfunc (c *credentials) h(data string) string {\n\thfCtor := hashFuncs[c.algorithm]\n\thf := hfCtor()\n\t_, _ = hf.Write([]byte(data)) // Hash.Write never returns an error\n\treturn fmt.Sprintf(\"%x\", hf.Sum(nil))\n}\n\nfunc (c *credentials) resp() (string, error) {\n\tc.nc++\n\n\tb := make([]byte, 16)\n\t_, err := io.ReadFull(rand.Reader, b)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tc.cNonce = fmt.Sprintf(\"%x\", b)[:32]\n\n\tha1 := c.ha1()\n\tha2 := c.ha2()\n\n\treturn c.kd(ha1, fmt.Sprintf(\"%s:%08x:%s:%s:%s\",\n\t\tc.nonce, c.nc, c.cNonce, c.messageQop, ha2)), nil\n}\n\nfunc (c *credentials) kd(secret, data string) string {\n\treturn c.h(fmt.Sprintf(\"%s:%s\", secret, data))\n}\n\n// RFC 7616 3.4.2\nfunc (c *credentials) ha1() string {\n\tret := c.h(fmt.Sprintf(\"%s:%s:%s\", c.username, c.realm, c.password))\n\tif c.sessionAlg {\n\t\treturn c.h(fmt.Sprintf(\"%s:%s:%s\", ret, c.nonce, c.cNonce))\n\t}\n\n\treturn ret\n}\n\n// RFC 7616 3.4.3\nfunc (c *credentials) ha2() string {\n\t// currently no auth-int support\n\treturn c.h(fmt.Sprintf(\"%s:%s\", c.method, c.digestURI))\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 6.0810546875,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M. (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty_test\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"golang.org/x/net/proxy\"\n\n\t\"github.com/go-resty/resty/v2\"\n)\n\ntype DropboxError struct {\n\tError string\n}\ntype AuthSuccess struct {\n\t/* variables */\n}\ntype AuthError struct {\n\t/* variables */\n}\ntype Article struct {\n\tTitle   string\n\tContent string\n\tAuthor  string\n\tTags    []string\n}\ntype Error struct {\n\t/* variables */\n}\n\n//\n// Package Level examples\n//\n\nfunc Example_get() {\n\t// Create a resty client\n\tclient := resty.New()\n\n\tresp, err := client.R().Get(\"http://httpbin.org/get\")\n\n\tfmt.Printf(\"\\nError: %v\", err)\n\tfmt.Printf(\"\\nResponse Status Code: %v\", resp.StatusCode())\n\tfmt.Printf(\"\\nResponse Status: %v\", resp.Status())\n\tfmt.Printf(\"\\nResponse Body: %v\", resp)\n\tfmt.Printf(\"\\nResponse Time: %v\", resp.Time())\n\tfmt.Printf(\"\\nResponse Received At: %v\", resp.ReceivedAt())\n}\n\nfunc Example_enhancedGet() {\n\t// Create a resty client\n\tclient := resty.New()\n\n\tresp, err := client.R().\n\t\tSetQueryParams(map[string]string{\n\t\t\t\"page_no\": \"1\",\n\t\t\t\"limit\":   \"20\",\n\t\t\t\"sort\":    \"name\",\n\t\t\t\"order\":   \"asc\",\n\t\t\t\"random\":  strconv.FormatInt(time.Now().Unix(), 10),\n\t\t}).\n\t\tSetHeader(\"Accept\", \"application/json\").\n\t\tSetAuthToken(\"BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\").\n\t\tGet(\"/search_result\")\n\n\tprintOutput(resp, err)\n}\n\nfunc Example_post() {\n\t// Create a resty client\n\tclient := resty.New()\n\n\t// POST JSON string\n\t// No need to set content type, if you have client level setting\n\tresp, err := client.R().\n\t\tSetHeader(\"Content-Type\", \"application/json\").\n\t\tSetBody(`{\"username\":\"testuser\", \"password\":\"testpass\"}`).\n\t\tSetResult(AuthSuccess{}). // or SetResult(&AuthSuccess{}).\n\t\tPost(\"https://myapp.com/login\")\n\n\tprintOutput(resp, err)\n\n\t// POST []byte array\n\t// No need to set content type, if you have client level setting\n\tresp1, err1 := client.R().\n\t\tSetHeader(\"Content-Type\", \"application/json\").\n\t\tSetBody([]byte(`{\"username\":\"testuser\", \"password\":\"testpass\"}`)).\n\t\tSetResult(AuthSuccess{}). // or SetResult(&AuthSuccess{}).\n\t\tPost(\"https://myapp.com/login\")\n\n\tprintOutput(resp1, err1)\n\n\t// POST Struct, default is JSON content type. No need to set one\n\tresp2, err2 := client.R().\n\t\tSetBody(resty.User{Username: \"testuser\", Password: \"testpass\"}).\n\t\tSetResult(&AuthSuccess{}). // or SetResult(AuthSuccess{}).\n\t\tSetError(&AuthError{}).    // or SetError(AuthError{}).\n\t\tPost(\"https://myapp.com/login\")\n\n\tprintOutput(resp2, err2)\n\n\t// POST Map, default is JSON content type. No need to set one\n\tresp3, err3 := client.R().\n\t\tSetBody(map[string]interface{}{\"username\": \"testuser\", \"password\": \"testpass\"}).\n\t\tSetResult(&AuthSuccess{}). // or SetResult(AuthSuccess{}).\n\t\tSetError(&AuthError{}).    // or SetError(AuthError{}).\n\t\tPost(\"https://myapp.com/login\")\n\n\tprintOutput(resp3, err3)\n}\n\nfunc Example_dropboxUpload() {\n\t// For example: upload file to Dropbox\n\t// POST of raw bytes for file upload.\n\tfileBytes, _ := os.ReadFile(\"/Users/jeeva/mydocument.pdf\")\n\n\t// Create a resty client\n\tclient := resty.New()\n\n\t// See we are not setting content-type header, since go-resty automatically detects Content-Type for you\n\tresp, err := client.R().\n\t\tSetBody(fileBytes).     // resty autodetects content type\n\t\tSetContentLength(true). // Dropbox expects this value\n\t\tSetAuthToken(\"<your-auth-token>\").\n\t\tSetError(DropboxError{}).\n\t\tPost(\"https://content.dropboxapi.com/1/files_put/auto/resty/mydocument.pdf\") // you can use PUT method too dropbox supports it\n\n\t// Output print\n\tfmt.Printf(\"\\nError: %v\\n\", err)\n\tfmt.Printf(\"Time: %v\\n\", resp.Time())\n\tfmt.Printf(\"Body: %v\\n\", resp)\n}\n\nfunc Example_put() {\n\t// Create a resty client\n\tclient := resty.New()\n\n\t// Just one sample of PUT, refer POST for more combination\n\t// request goes as JSON content type\n\t// No need to set auth token, error, if you have client level settings\n\tresp, err := client.R().\n\t\tSetBody(Article{\n\t\t\tTitle:   \"go-resty\",\n\t\t\tContent: \"This is my article content, oh ya!\",\n\t\t\tAuthor:  \"Jeevanandam M\",\n\t\t\tTags:    []string{\"article\", \"sample\", \"resty\"},\n\t\t}).\n\t\tSetAuthToken(\"C6A79608-782F-4ED0-A11D-BD82FAD829CD\").\n\t\tSetError(&Error{}). // or SetError(Error{}).\n\t\tPut(\"https://myapp.com/article/1234\")\n\n\tprintOutput(resp, err)\n}\n\nfunc Example_clientCertificates() {\n\t// Parsing public/private key pair from a pair of files. The files must contain PEM encoded data.\n\tcert, err := tls.LoadX509KeyPair(\"certs/client.pem\", \"certs/client.key\")\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR client certificate: %s\", err)\n\t}\n\n\t// Create a resty client\n\tclient := resty.New()\n\n\tclient.SetCertificates(cert)\n}\n\nfunc Example_customRootCertificate() {\n\t// Create a resty client\n\tclient := resty.New()\n\tclient.SetRootCertificate(\"/path/to/root/pemFile.pem\")\n}\n\n//\n// top level method examples\n//\n\nfunc ExampleNew() {\n\t// Creating client1\n\tclient1 := resty.New()\n\tresp1, err1 := client1.R().Get(\"http://httpbin.org/get\")\n\tfmt.Println(resp1, err1)\n\n\t// Creating client2\n\tclient2 := resty.New()\n\tresp2, err2 := client2.R().Get(\"http://httpbin.org/get\")\n\tfmt.Println(resp2, err2)\n}\n\n//\n// Client object methods\n//\n\nfunc ExampleClient_SetCertificates() {\n\t// Parsing public/private key pair from a pair of files. The files must contain PEM encoded data.\n\tcert, err := tls.LoadX509KeyPair(\"certs/client.pem\", \"certs/client.key\")\n\tif err != nil {\n\t\tlog.Fatalf(\"ERROR client certificate: %s\", err)\n\t}\n\n\t// Create a resty client\n\tclient := resty.New()\n\n\tclient.SetCertificates(cert)\n}\n\n//\n// Resty Socks5 Proxy request\n//\n\nfunc Example_socks5Proxy() {\n\t// create a dialer\n\tdialer, err := proxy.SOCKS5(\"tcp\", \"127.0.0.1:9150\", nil, proxy.Direct)\n\tif err != nil {\n\t\tlog.Fatalf(\"Unable to obtain proxy dialer: %v\\n\", err)\n\t}\n\n\t// create a transport\n\tptransport := &http.Transport{Dial: dialer.Dial}\n\n\t// Create a resty client\n\tclient := resty.New()\n\n\t// set transport into resty\n\tclient.SetTransport(ptransport)\n\n\tresp, err := client.R().Get(\"http://check.torproject.org\")\n\tfmt.Println(err, resp)\n}\n\nfunc printOutput(resp *resty.Response, err error) {\n\tfmt.Println(resp, err)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.107421875,
          "content": "module github.com/go-resty/resty/v2\n\ngo 1.20\n\nrequire (\n\tgolang.org/x/net v0.33.0\n\tgolang.org/x/time v0.6.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.298828125,
          "content": "golang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/time v0.6.0 h1:eTDhh4ZXt5Qf0augr54TN6suAUudPcawVZeIAPU7D4U=\ngolang.org/x/time v0.6.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\n"
        },
        {
          "name": "middleware.go",
          "type": "blob",
          "size": 16.130859375,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst debugRequestLogKey = \"__restyDebugRequestLog\"\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Request Middleware(s)\n//_______________________________________________________________________\n\nfunc parseRequestURL(c *Client, r *Request) error {\n\tif l := len(c.PathParams) + len(c.RawPathParams) + len(r.PathParams) + len(r.RawPathParams); l > 0 {\n\t\tparams := make(map[string]string, l)\n\n\t\t// GitHub #103 Path Params\n\t\tfor p, v := range r.PathParams {\n\t\t\tparams[p] = url.PathEscape(v)\n\t\t}\n\t\tfor p, v := range c.PathParams {\n\t\t\tif _, ok := params[p]; !ok {\n\t\t\t\tparams[p] = url.PathEscape(v)\n\t\t\t}\n\t\t}\n\n\t\t// GitHub #663 Raw Path Params\n\t\tfor p, v := range r.RawPathParams {\n\t\t\tif _, ok := params[p]; !ok {\n\t\t\t\tparams[p] = v\n\t\t\t}\n\t\t}\n\t\tfor p, v := range c.RawPathParams {\n\t\t\tif _, ok := params[p]; !ok {\n\t\t\t\tparams[p] = v\n\t\t\t}\n\t\t}\n\n\t\tif len(params) > 0 {\n\t\t\tvar prev int\n\t\t\tbuf := acquireBuffer()\n\t\t\tdefer releaseBuffer(buf)\n\t\t\t// search for the next or first opened curly bracket\n\t\t\tfor curr := strings.Index(r.URL, \"{\"); curr == 0 || curr > prev; curr = prev + strings.Index(r.URL[prev:], \"{\") {\n\t\t\t\t// write everything from the previous position up to the current\n\t\t\t\tif curr > prev {\n\t\t\t\t\tbuf.WriteString(r.URL[prev:curr])\n\t\t\t\t}\n\t\t\t\t// search for the closed curly bracket from current position\n\t\t\t\tnext := curr + strings.Index(r.URL[curr:], \"}\")\n\t\t\t\t// if not found, then write the remainder and exit\n\t\t\t\tif next < curr {\n\t\t\t\t\tbuf.WriteString(r.URL[curr:])\n\t\t\t\t\tprev = len(r.URL)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t// special case for {}, without parameter's name\n\t\t\t\tif next == curr+1 {\n\t\t\t\t\tbuf.WriteString(\"{}\")\n\t\t\t\t} else {\n\t\t\t\t\t// check for the replacement\n\t\t\t\t\tkey := r.URL[curr+1 : next]\n\t\t\t\t\tvalue, ok := params[key]\n\t\t\t\t\t/// keep the original string if the replacement not found\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tvalue = r.URL[curr : next+1]\n\t\t\t\t\t}\n\t\t\t\t\tbuf.WriteString(value)\n\t\t\t\t}\n\n\t\t\t\t// set the previous position after the closed curly bracket\n\t\t\t\tprev = next + 1\n\t\t\t\tif prev >= len(r.URL) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif buf.Len() > 0 {\n\t\t\t\t// write remainder\n\t\t\t\tif prev < len(r.URL) {\n\t\t\t\t\tbuf.WriteString(r.URL[prev:])\n\t\t\t\t}\n\t\t\t\tr.URL = buf.String()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Parsing request URL\n\treqURL, err := url.Parse(r.URL)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If Request.URL is relative path then added c.HostURL into\n\t// the request URL otherwise Request.URL will be used as-is\n\tif !reqURL.IsAbs() {\n\t\tr.URL = reqURL.String()\n\t\tif len(r.URL) > 0 && r.URL[0] != '/' {\n\t\t\tr.URL = \"/\" + r.URL\n\t\t}\n\n\t\t// TODO: change to use c.BaseURL only in v3.0.0\n\t\tbaseURL := c.BaseURL\n\t\tif len(baseURL) == 0 {\n\t\t\tbaseURL = c.HostURL\n\t\t}\n\t\treqURL, err = url.Parse(baseURL + r.URL)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// GH #407 && #318\n\tif reqURL.Scheme == \"\" && len(c.scheme) > 0 {\n\t\treqURL.Scheme = c.scheme\n\t}\n\n\t// Adding Query Param\n\tif len(c.QueryParam)+len(r.QueryParam) > 0 {\n\t\tfor k, v := range c.QueryParam {\n\t\t\t// skip query parameter if it was set in request\n\t\t\tif _, ok := r.QueryParam[k]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tr.QueryParam[k] = v[:]\n\t\t}\n\n\t\t// GitHub #123 Preserve query string order partially.\n\t\t// Since not feasible in `SetQuery*` resty methods, because\n\t\t// standard package `url.Encode(...)` sorts the query params\n\t\t// alphabetically\n\t\tif len(r.QueryParam) > 0 {\n\t\t\tif IsStringEmpty(reqURL.RawQuery) {\n\t\t\t\treqURL.RawQuery = r.QueryParam.Encode()\n\t\t\t} else {\n\t\t\t\treqURL.RawQuery = reqURL.RawQuery + \"&\" + r.QueryParam.Encode()\n\t\t\t}\n\t\t}\n\t}\n\n\t// GH#797 Unescape query parameters\n\tif r.unescapeQueryParams && len(reqURL.RawQuery) > 0 {\n\t\t// at this point, all errors caught up in the above operations\n\t\t// so ignore the return error on query unescape; I realized\n\t\t// while writing the unit test\n\t\tunescapedQuery, _ := url.QueryUnescape(reqURL.RawQuery)\n\t\treqURL.RawQuery = strings.ReplaceAll(unescapedQuery, \" \", \"+\") // otherwise request becomes bad request\n\t}\n\n\tr.URL = reqURL.String()\n\n\treturn nil\n}\n\nfunc parseRequestHeader(c *Client, r *Request) error {\n\tfor k, v := range c.Header {\n\t\tif _, ok := r.Header[k]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tr.Header[k] = v[:]\n\t}\n\n\tif IsStringEmpty(r.Header.Get(hdrUserAgentKey)) {\n\t\tr.Header.Set(hdrUserAgentKey, hdrUserAgentValue)\n\t}\n\n\tif ct := r.Header.Get(hdrContentTypeKey); IsStringEmpty(r.Header.Get(hdrAcceptKey)) && !IsStringEmpty(ct) && (IsJSONType(ct) || IsXMLType(ct)) {\n\t\tr.Header.Set(hdrAcceptKey, r.Header.Get(hdrContentTypeKey))\n\t}\n\n\treturn nil\n}\n\nfunc parseRequestBody(c *Client, r *Request) error {\n\tif isPayloadSupported(r.Method, c.AllowGetMethodPayload) {\n\t\tswitch {\n\t\tcase r.isMultiPart: // Handling Multipart\n\t\t\tif err := handleMultipart(c, r); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase len(c.FormData) > 0 || len(r.FormData) > 0: // Handling Form Data\n\t\t\thandleFormData(c, r)\n\t\tcase r.Body != nil: // Handling Request body\n\t\t\thandleContentType(c, r)\n\n\t\t\tif err := handleRequestBody(c, r); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\t// by default resty won't set content length, you can if you want to :)\n\tif c.setContentLength || r.setContentLength {\n\t\tif r.bodyBuf == nil {\n\t\t\tr.Header.Set(hdrContentLengthKey, \"0\")\n\t\t} else {\n\t\t\tr.Header.Set(hdrContentLengthKey, strconv.Itoa(r.bodyBuf.Len()))\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc createHTTPRequest(c *Client, r *Request) (err error) {\n\tif r.bodyBuf == nil {\n\t\tif reader, ok := r.Body.(io.Reader); ok && isPayloadSupported(r.Method, c.AllowGetMethodPayload) {\n\t\t\tr.RawRequest, err = http.NewRequest(r.Method, r.URL, reader)\n\t\t} else if c.setContentLength || r.setContentLength {\n\t\t\tr.RawRequest, err = http.NewRequest(r.Method, r.URL, http.NoBody)\n\t\t} else {\n\t\t\tr.RawRequest, err = http.NewRequest(r.Method, r.URL, nil)\n\t\t}\n\t} else {\n\t\t// fix data race: must deep copy.\n\t\tbodyBuf := bytes.NewBuffer(append([]byte{}, r.bodyBuf.Bytes()...))\n\t\tr.RawRequest, err = http.NewRequest(r.Method, r.URL, bodyBuf)\n\t}\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// Assign close connection option\n\tr.RawRequest.Close = c.closeConnection\n\n\t// Add headers into http request\n\tr.RawRequest.Header = r.Header\n\n\t// Add cookies from client instance into http request\n\tfor _, cookie := range c.Cookies {\n\t\tr.RawRequest.AddCookie(cookie)\n\t}\n\n\t// Add cookies from request instance into http request\n\tfor _, cookie := range r.Cookies {\n\t\tr.RawRequest.AddCookie(cookie)\n\t}\n\n\t// Enable trace\n\tif c.trace || r.trace {\n\t\tr.clientTrace = &clientTrace{}\n\t\tr.ctx = r.clientTrace.createContext(r.Context())\n\t}\n\n\t// Use context if it was specified\n\tif r.ctx != nil {\n\t\tr.RawRequest = r.RawRequest.WithContext(r.ctx)\n\t}\n\n\t// assign get body func for the underlying raw request instance\n\tif r.RawRequest.GetBody == nil {\n\t\tbodyCopy, err := getBodyCopy(r)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif bodyCopy != nil {\n\t\t\tbuf := bodyCopy.Bytes()\n\t\t\tr.RawRequest.GetBody = func() (io.ReadCloser, error) {\n\t\t\t\tb := bytes.NewReader(buf)\n\t\t\t\treturn io.NopCloser(b), nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc addCredentials(c *Client, r *Request) error {\n\tvar isBasicAuth bool\n\t// Basic Auth\n\tif r.UserInfo != nil { // takes precedence\n\t\tr.RawRequest.SetBasicAuth(r.UserInfo.Username, r.UserInfo.Password)\n\t\tisBasicAuth = true\n\t} else if c.UserInfo != nil {\n\t\tr.RawRequest.SetBasicAuth(c.UserInfo.Username, c.UserInfo.Password)\n\t\tisBasicAuth = true\n\t}\n\n\tif !c.DisableWarn {\n\t\tif isBasicAuth && !strings.HasPrefix(r.URL, \"https\") {\n\t\t\tr.log.Warnf(\"Using Basic Auth in HTTP mode is not secure, use HTTPS\")\n\t\t}\n\t}\n\n\t// Set the Authorization Header Scheme\n\tvar authScheme string\n\tif !IsStringEmpty(r.AuthScheme) {\n\t\tauthScheme = r.AuthScheme\n\t} else if !IsStringEmpty(c.AuthScheme) {\n\t\tauthScheme = c.AuthScheme\n\t} else {\n\t\tauthScheme = \"Bearer\"\n\t}\n\n\t// Build the Token Auth header\n\tif !IsStringEmpty(r.Token) { // takes precedence\n\t\tr.RawRequest.Header.Set(c.HeaderAuthorizationKey, authScheme+\" \"+r.Token)\n\t} else if !IsStringEmpty(c.Token) {\n\t\tr.RawRequest.Header.Set(c.HeaderAuthorizationKey, authScheme+\" \"+c.Token)\n\t}\n\n\treturn nil\n}\n\nfunc createCurlCmd(c *Client, r *Request) (err error) {\n\tif r.Debug && r.generateCurlOnDebug {\n\t\tif r.resultCurlCmd == nil {\n\t\t\tr.resultCurlCmd = new(string)\n\t\t}\n\t\t*r.resultCurlCmd = buildCurlRequest(r.RawRequest, c.httpClient.Jar)\n\t}\n\treturn nil\n}\n\nfunc requestLogger(c *Client, r *Request) error {\n\tif r.Debug {\n\t\trr := r.RawRequest\n\t\trh := copyHeaders(rr.Header)\n\t\tif c.GetClient().Jar != nil {\n\t\t\tfor _, cookie := range c.GetClient().Jar.Cookies(r.RawRequest.URL) {\n\t\t\t\ts := fmt.Sprintf(\"%s=%s\", cookie.Name, cookie.Value)\n\t\t\t\tif c := rh.Get(\"Cookie\"); c != \"\" {\n\t\t\t\t\trh.Set(\"Cookie\", c+\"; \"+s)\n\t\t\t\t} else {\n\t\t\t\t\trh.Set(\"Cookie\", s)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trl := &RequestLog{Header: rh, Body: r.fmtBodyString(c.debugBodySizeLimit)}\n\t\tif c.requestLog != nil {\n\t\t\tif err := c.requestLog(rl); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treqLog := \"\\n==============================================================================\\n\"\n\n\t\tif r.Debug && r.generateCurlOnDebug {\n\t\t\treqLog += \"~~~ REQUEST(CURL) ~~~\\n\" +\n\t\t\t\tfmt.Sprintf(\"\t%v\\n\", *r.resultCurlCmd)\n\t\t}\n\n\t\treqLog += \"~~~ REQUEST ~~~\\n\" +\n\t\t\tfmt.Sprintf(\"%s  %s  %s\\n\", r.Method, rr.URL.RequestURI(), rr.Proto) +\n\t\t\tfmt.Sprintf(\"HOST   : %s\\n\", rr.URL.Host) +\n\t\t\tfmt.Sprintf(\"HEADERS:\\n%s\\n\", composeHeaders(c, r, rl.Header)) +\n\t\t\tfmt.Sprintf(\"BODY   :\\n%v\\n\", rl.Body) +\n\t\t\t\"------------------------------------------------------------------------------\\n\"\n\n\t\tr.initValuesMap()\n\t\tr.values[debugRequestLogKey] = reqLog\n\t}\n\n\treturn nil\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Response Middleware(s)\n//_______________________________________________________________________\n\nfunc responseLogger(c *Client, res *Response) error {\n\tif res.Request.Debug {\n\t\trl := &ResponseLog{Header: copyHeaders(res.Header()), Body: res.fmtBodyString(c.debugBodySizeLimit)}\n\t\tif c.responseLog != nil {\n\t\t\tif err := c.responseLog(rl); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tdebugLog := res.Request.values[debugRequestLogKey].(string)\n\t\tdebugLog += \"~~~ RESPONSE ~~~\\n\" +\n\t\t\tfmt.Sprintf(\"STATUS       : %s\\n\", res.Status()) +\n\t\t\tfmt.Sprintf(\"PROTO        : %s\\n\", res.Proto()) +\n\t\t\tfmt.Sprintf(\"RECEIVED AT  : %v\\n\", res.ReceivedAt().Format(time.RFC3339Nano)) +\n\t\t\tfmt.Sprintf(\"TIME DURATION: %v\\n\", res.Time()) +\n\t\t\t\"HEADERS      :\\n\" +\n\t\t\tcomposeHeaders(c, res.Request, rl.Header) + \"\\n\"\n\t\tif res.Request.isSaveResponse {\n\t\t\tdebugLog += \"BODY         :\\n***** RESPONSE WRITTEN INTO FILE *****\\n\"\n\t\t} else {\n\t\t\tdebugLog += fmt.Sprintf(\"BODY         :\\n%v\\n\", rl.Body)\n\t\t}\n\t\tdebugLog += \"==============================================================================\\n\"\n\n\t\tres.Request.log.Debugf(\"%s\", debugLog)\n\t}\n\n\treturn nil\n}\n\nfunc parseResponseBody(c *Client, res *Response) (err error) {\n\tif res.StatusCode() == http.StatusNoContent {\n\t\tres.Request.Error = nil\n\t\treturn\n\t}\n\t// Handles only JSON or XML content type\n\tct := firstNonEmpty(res.Request.forceContentType, res.Header().Get(hdrContentTypeKey), res.Request.fallbackContentType)\n\tif IsJSONType(ct) || IsXMLType(ct) {\n\t\t// HTTP status code > 199 and < 300, considered as Result\n\t\tif res.IsSuccess() {\n\t\t\tres.Request.Error = nil\n\t\t\tif res.Request.Result != nil {\n\t\t\t\terr = Unmarshalc(c, ct, res.body, res.Request.Result)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// HTTP status code > 399, considered as Error\n\t\tif res.IsError() {\n\t\t\t// global error interface\n\t\t\tif res.Request.Error == nil && c.Error != nil {\n\t\t\t\tres.Request.Error = reflect.New(c.Error).Interface()\n\t\t\t}\n\n\t\t\tif res.Request.Error != nil {\n\t\t\t\tunmarshalErr := Unmarshalc(c, ct, res.body, res.Request.Error)\n\t\t\t\tif unmarshalErr != nil {\n\t\t\t\t\tc.log.Warnf(\"Cannot unmarshal response body: %s\", unmarshalErr)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc handleMultipart(c *Client, r *Request) error {\n\tr.bodyBuf = acquireBuffer()\n\tw := multipart.NewWriter(r.bodyBuf)\n\n\t// Set boundary if not set by user\n\tif r.multipartBoundary != \"\" {\n\t\tif err := w.SetBoundary(r.multipartBoundary); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor k, v := range c.FormData {\n\t\tfor _, iv := range v {\n\t\t\tif err := w.WriteField(k, iv); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tfor k, v := range r.FormData {\n\t\tfor _, iv := range v {\n\t\t\tif strings.HasPrefix(k, \"@\") { // file\n\t\t\t\tif err := addFile(w, k[1:], iv); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t} else { // form value\n\t\t\t\tif err := w.WriteField(k, iv); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// #21 - adding io.Reader support\n\tfor _, f := range r.multipartFiles {\n\t\tif err := addFileReader(w, f); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// GitHub #130 adding multipart field support with content type\n\tfor _, mf := range r.multipartFields {\n\t\tif err := addMultipartFormField(w, mf); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tr.Header.Set(hdrContentTypeKey, w.FormDataContentType())\n\treturn w.Close()\n}\n\nfunc handleFormData(c *Client, r *Request) {\n\tfor k, v := range c.FormData {\n\t\tif _, ok := r.FormData[k]; ok {\n\t\t\tcontinue\n\t\t}\n\t\tr.FormData[k] = v[:]\n\t}\n\n\tr.bodyBuf = acquireBuffer()\n\tr.bodyBuf.WriteString(r.FormData.Encode())\n\tr.Header.Set(hdrContentTypeKey, formContentType)\n\tr.isFormData = true\n}\n\nfunc handleContentType(c *Client, r *Request) {\n\tcontentType := r.Header.Get(hdrContentTypeKey)\n\tif IsStringEmpty(contentType) {\n\t\tcontentType = DetectContentType(r.Body)\n\t\tr.Header.Set(hdrContentTypeKey, contentType)\n\t}\n}\n\nfunc handleRequestBody(c *Client, r *Request) error {\n\tvar bodyBytes []byte\n\tr.bodyBuf = nil\n\n\tswitch body := r.Body.(type) {\n\tcase io.Reader:\n\t\tif c.setContentLength || r.setContentLength { // keep backward compatibility\n\t\t\tr.bodyBuf = acquireBuffer()\n\t\t\tif _, err := r.bodyBuf.ReadFrom(body); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tr.Body = nil\n\t\t} else {\n\t\t\t// Otherwise buffer less processing for `io.Reader`, sounds good.\n\t\t\treturn nil\n\t\t}\n\tcase []byte:\n\t\tbodyBytes = body\n\tcase string:\n\t\tbodyBytes = []byte(body)\n\tdefault:\n\t\tcontentType := r.Header.Get(hdrContentTypeKey)\n\t\tkind := kindOf(r.Body)\n\t\tvar err error\n\t\tif IsJSONType(contentType) && (kind == reflect.Struct || kind == reflect.Map || kind == reflect.Slice) {\n\t\t\tr.bodyBuf, err = jsonMarshal(c, r, r.Body)\n\t\t} else if IsXMLType(contentType) && (kind == reflect.Struct) {\n\t\t\tbodyBytes, err = c.XMLMarshal(r.Body)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif bodyBytes == nil && r.bodyBuf == nil {\n\t\treturn errors.New(\"unsupported 'Body' type/value\")\n\t}\n\n\t// []byte into Buffer\n\tif bodyBytes != nil && r.bodyBuf == nil {\n\t\tr.bodyBuf = acquireBuffer()\n\t\t_, _ = r.bodyBuf.Write(bodyBytes)\n\t}\n\n\treturn nil\n}\n\nfunc saveResponseIntoFile(c *Client, res *Response) error {\n\tif res.Request.isSaveResponse {\n\t\tfile := \"\"\n\n\t\tif len(c.outputDirectory) > 0 && !filepath.IsAbs(res.Request.outputFile) {\n\t\t\tfile += c.outputDirectory + string(filepath.Separator)\n\t\t}\n\n\t\tfile = filepath.Clean(file + res.Request.outputFile)\n\t\tif err := createDirectory(filepath.Dir(file)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\toutFile, err := os.Create(file)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer closeq(outFile)\n\n\t\t// io.Copy reads maximum 32kb size, it is perfect for large file download too\n\t\tdefer closeq(res.RawResponse.Body)\n\n\t\twritten, err := io.Copy(outFile, res.RawResponse.Body)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tres.size = written\n\t}\n\n\treturn nil\n}\n\nfunc getBodyCopy(r *Request) (*bytes.Buffer, error) {\n\t// If r.bodyBuf present, return the copy\n\tif r.bodyBuf != nil {\n\t\tbodyCopy := acquireBuffer()\n\t\tif _, err := io.Copy(bodyCopy, bytes.NewReader(r.bodyBuf.Bytes())); err != nil {\n\t\t\t// cannot use io.Copy(bodyCopy, r.bodyBuf) because io.Copy reset r.bodyBuf\n\t\t\treturn nil, err\n\t\t}\n\t\treturn bodyCopy, nil\n\t}\n\n\t// Maybe body is `io.Reader`.\n\t// Note: Resty user have to watchout for large body size of `io.Reader`\n\tif r.RawRequest.Body != nil {\n\t\tb, err := io.ReadAll(r.RawRequest.Body)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Restore the Body\n\t\tcloseq(r.RawRequest.Body)\n\t\tr.RawRequest.Body = io.NopCloser(bytes.NewBuffer(b))\n\n\t\t// Return the Body bytes\n\t\treturn bytes.NewBuffer(b), nil\n\t}\n\treturn nil, nil\n}\n"
        },
        {
          "name": "middleware_test.go",
          "type": "blob",
          "size": 29.2041015625,
          "content": "package resty\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc Test_parseRequestURL(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname        string\n\t\tinit        func(c *Client, r *Request)\n\t\texpectedURL string\n\t}{\n\t\t{\n\t\t\tname: \"apply client path parameters\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2/3\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/1/2%2F3\",\n\t\t},\n\t\t{\n\t\t\tname: \"apply request path parameters\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"4\",\n\t\t\t\t\t\"bar\": \"5/6\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/4/5%2F6\",\n\t\t},\n\t\t{\n\t\t\tname: \"apply request and client path parameters\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\", // ignored, because of the request's \"foo\"\n\t\t\t\t\t\"bar\": \"2/3\",\n\t\t\t\t})\n\t\t\t\tr.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"4/5\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/4%2F5/2%2F3\",\n\t\t},\n\t\t{\n\t\t\tname: \"apply client raw path parameters\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetRawPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1/2\",\n\t\t\t\t\t\"bar\": \"3\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/1/2/3\",\n\t\t},\n\t\t{\n\t\t\tname: \"apply request raw path parameters\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetRawPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"4\",\n\t\t\t\t\t\"bar\": \"5/6\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/4/5/6\",\n\t\t},\n\t\t{\n\t\t\tname: \"apply request and client raw path parameters\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetRawPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\", // ignored, because of the request's \"foo\"\n\t\t\t\t\t\"bar\": \"2/3\",\n\t\t\t\t})\n\t\t\t\tr.SetRawPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"4/5\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/4/5/2/3\",\n\t\t},\n\t\t{\n\t\t\tname: \"apply request path and raw path parameters\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"4/5\",\n\t\t\t\t}).SetRawPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"4/5\", // ignored, because the PathParams takes precedence over the RawPathParams\n\t\t\t\t\t\"bar\": \"6/7\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/4%2F5/6/7\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty path parameter in URL\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetPathParams(map[string]string{\n\t\t\t\t\t\"bar\": \"4\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/%7B%7D/4\",\n\t\t},\n\t\t{\n\t\t\tname: \"not closed path parameter in URL\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"4\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar/1\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/4/%7Bbar/1\",\n\t\t},\n\t\t{\n\t\t\tname: \"extra path parameter in URL\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/{bar}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/1/%7Bbar%7D\",\n\t\t},\n\t\t{\n\t\t\tname: \" path parameter with remainder\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetPathParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/{foo}/2\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/1/2\",\n\t\t},\n\t\t{\n\t\t\tname: \"using base url with path param at index 0\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetBaseURL(\"https://example.com/prefix\")\n\t\t\t\tr.SetPathParam(\"first\", \"1\").\n\t\t\t\t\tSetPathParam(\"second\", \"2\")\n\t\t\t\tr.URL = \"{first}/{second}\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/prefix/1/2\",\n\t\t},\n\t\t{\n\t\t\tname: \"using BaseURL with absolute URL in request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetBaseURL(\"https://foo.bar\") // ignored\n\t\t\t\tr.URL = \"https://example.com/\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/\",\n\t\t},\n\t\t{\n\t\t\tname: \"using BaseURL with relative path in request URL without leading slash\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetBaseURL(\"https://example.com\")\n\t\t\t\tr.URL = \"foo/bar\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"using BaseURL with relative path in request URL wit leading slash\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetBaseURL(\"https://example.com\")\n\t\t\t\tr.URL = \"/foo/bar\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"using deprecated HostURL with relative path in request URL\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.HostURL = \"https://example.com\"\n\t\t\t\tr.URL = \"foo/bar\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"request URL without scheme\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.URL = \"example.com/foo/bar\"\n\t\t\t},\n\t\t\texpectedURL: \"/example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"BaseURL without scheme\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetBaseURL(\"example.com\")\n\t\t\t\tr.URL = \"foo/bar\"\n\t\t\t},\n\t\t\texpectedURL: \"example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"using SetScheme and BaseURL without scheme\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetBaseURL(\"example.com\").SetScheme(\"https\")\n\t\t\t\tr.URL = \"foo/bar\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/foo/bar\",\n\t\t},\n\t\t{\n\t\t\tname: \"adding query parameters by client\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetQueryParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/?foo=1&bar=2\",\n\t\t},\n\t\t{\n\t\t\tname: \"adding query parameters by request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetQueryParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/?foo=1&bar=2\",\n\t\t},\n\t\t{\n\t\t\tname: \"adding query parameters by client and request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetQueryParams(map[string]string{\n\t\t\t\t\t\"foo\": \"1\", // ignored, because of the \"foo\" parameter in request\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t\tr.SetQueryParams(map[string]string{\n\t\t\t\t\t\"foo\": \"3\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/?foo=3&bar=2\",\n\t\t},\n\t\t{\n\t\t\tname: \"adding query parameters by request to URL with existent\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetQueryParams(map[string]string{\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t\tr.URL = \"https://example.com/?foo=1\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/?foo=1&bar=2\",\n\t\t},\n\t\t{\n\t\t\tname: \"adding query parameters by request with multiple values\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.QueryParam.Add(\"foo\", \"1\")\n\t\t\t\tr.QueryParam.Add(\"foo\", \"2\")\n\t\t\t\tr.URL = \"https://example.com/\"\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com/?foo=1&foo=2\",\n\t\t},\n\t\t{\n\t\t\tname: \"unescape query params\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetBaseURL(\"https://example.com/\").\n\t\t\t\t\tSetUnescapeQueryParams(true). // this line is just code coverage; I will restructure this test in v3 for the client and request the respective init method\n\t\t\t\t\tSetQueryParam(\"fromclient\", \"hey unescape\").\n\t\t\t\t\tSetQueryParam(\"initone\", \"cáfe\")\n\n\t\t\t\tr.SetUnescapeQueryParams(true) // this line takes effect\n\t\t\t\tr.SetQueryParams(\n\t\t\t\t\tmap[string]string{\n\t\t\t\t\t\t\"registry\": \"nacos://test:6801\", // GH #797\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t},\n\t\t\texpectedURL: \"https://example.com?initone=cáfe&fromclient=hey+unescape&registry=nacos://test:6801\",\n\t\t},\n\t} {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := New()\n\t\t\tr := c.R()\n\t\t\ttt.init(c, r)\n\t\t\tif err := parseRequestURL(c, r); err != nil {\n\t\t\t\tt.Errorf(\"parseRequestURL() error = %v\", err)\n\t\t\t}\n\n\t\t\t// compare URLs without query parameters first\n\t\t\t// then compare query parameters, because the order of the items in a map is not guarantied\n\t\t\texpectedURL, _ := url.Parse(tt.expectedURL)\n\t\t\texpectedQuery := expectedURL.Query()\n\t\t\texpectedURL.RawQuery = \"\"\n\t\t\tactualURL, _ := url.Parse(r.URL)\n\t\t\tactualQuery := actualURL.Query()\n\t\t\tactualURL.RawQuery = \"\"\n\t\t\tif expectedURL.String() != actualURL.String() {\n\t\t\t\tt.Errorf(\"r.URL = %q does not match expected %q\", r.URL, tt.expectedURL)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(expectedQuery, actualQuery) {\n\t\t\t\tt.Errorf(\"r.URL = %q does not match expected %q\", r.URL, tt.expectedURL)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRequestURL_GH797(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetBaseURL(ts.URL).\n\t\tSetUnescapeQueryParams(true). // this line is just code coverage; I will restructure this test in v3 for the client and request the respective init method\n\t\tSetQueryParam(\"fromclient\", \"hey unescape\").\n\t\tSetQueryParam(\"initone\", \"cáfe\")\n\n\tresp, err := c.R().\n\t\tSetUnescapeQueryParams(true). // this line takes effect\n\t\tSetQueryParams(\n\t\t\tmap[string]string{\n\t\t\t\t\"registry\": \"nacos://test:6801\", // GH #797\n\t\t\t},\n\t\t).\n\t\tGet(\"/unescape-query-params\")\n\n\tassertError(t, err)\n\tassertEqual(t, \"query params looks good\", resp.String())\n}\n\nfunc Benchmark_parseRequestURL_PathParams(b *testing.B) {\n\tc := New().SetPathParams(map[string]string{\n\t\t\"foo\": \"1\",\n\t\t\"bar\": \"2\",\n\t}).SetRawPathParams(map[string]string{\n\t\t\"foo\": \"3\",\n\t\t\"xyz\": \"4\",\n\t})\n\tr := c.R().SetPathParams(map[string]string{\n\t\t\"foo\": \"5\",\n\t\t\"qwe\": \"6\",\n\t}).SetRawPathParams(map[string]string{\n\t\t\"foo\": \"7\",\n\t\t\"asd\": \"8\",\n\t})\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr.URL = \"https://example.com/{foo}/{bar}/{xyz}/{qwe}/{asd}\"\n\t\tif err := parseRequestURL(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestURL() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestURL_QueryParams(b *testing.B) {\n\tc := New().SetQueryParams(map[string]string{\n\t\t\"foo\": \"1\",\n\t\t\"bar\": \"2\",\n\t})\n\tr := c.R().SetQueryParams(map[string]string{\n\t\t\"foo\": \"5\",\n\t\t\"qwe\": \"6\",\n\t})\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tr.URL = \"https://example.com/\"\n\t\tif err := parseRequestURL(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestURL() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Test_parseRequestHeader(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname           string\n\t\tinit           func(c *Client, r *Request)\n\t\texpectedHeader http.Header\n\t}{\n\t\t{\n\t\t\tname: \"headers in request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetHeaders(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectedHeader: http.Header{\n\t\t\t\thttp.CanonicalHeaderKey(\"foo\"):           []string{\"1\"},\n\t\t\t\thttp.CanonicalHeaderKey(\"bar\"):           []string{\"2\"},\n\t\t\t\thttp.CanonicalHeaderKey(hdrUserAgentKey): []string{hdrUserAgentValue},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"headers in client\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetHeaders(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectedHeader: http.Header{\n\t\t\t\thttp.CanonicalHeaderKey(\"foo\"):           []string{\"1\"},\n\t\t\t\thttp.CanonicalHeaderKey(\"bar\"):           []string{\"2\"},\n\t\t\t\thttp.CanonicalHeaderKey(hdrUserAgentKey): []string{hdrUserAgentValue},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"headers in client and request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetHeaders(map[string]string{\n\t\t\t\t\t\"foo\": \"1\", // ignored, because of the same header in the request\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t\tr.SetHeaders(map[string]string{\n\t\t\t\t\t\"foo\": \"3\",\n\t\t\t\t\t\"xyz\": \"4\",\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectedHeader: http.Header{\n\t\t\t\thttp.CanonicalHeaderKey(\"foo\"):           []string{\"3\"},\n\t\t\t\thttp.CanonicalHeaderKey(\"bar\"):           []string{\"2\"},\n\t\t\t\thttp.CanonicalHeaderKey(\"xyz\"):           []string{\"4\"},\n\t\t\t\thttp.CanonicalHeaderKey(hdrUserAgentKey): []string{hdrUserAgentValue},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"no headers\",\n\t\t\tinit: func(c *Client, r *Request) {},\n\t\t\texpectedHeader: http.Header{\n\t\t\t\thttp.CanonicalHeaderKey(hdrUserAgentKey): []string{hdrUserAgentValue},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"user agent\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetHeader(hdrUserAgentKey, \"foo bar\")\n\t\t\t},\n\t\t\texpectedHeader: http.Header{\n\t\t\t\thttp.CanonicalHeaderKey(hdrUserAgentKey): []string{\"foo bar\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"json content type\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetHeader(hdrContentTypeKey, \"application/json\")\n\t\t\t},\n\t\t\texpectedHeader: http.Header{\n\t\t\t\thttp.CanonicalHeaderKey(hdrContentTypeKey): []string{\"application/json\"},\n\t\t\t\thttp.CanonicalHeaderKey(hdrAcceptKey):      []string{\"application/json\"},\n\t\t\t\thttp.CanonicalHeaderKey(hdrUserAgentKey):   []string{hdrUserAgentValue},\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := New()\n\t\t\tr := c.R()\n\t\t\ttt.init(c, r)\n\t\t\tif err := parseRequestHeader(c, r); err != nil {\n\t\t\t\tt.Errorf(\"parseRequestHeader() error = %v\", err)\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(tt.expectedHeader, r.Header) {\n\t\t\t\tt.Errorf(\"r.Header = %#+v does not match expected %#+v\", r.Header, tt.expectedHeader)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Benchmark_parseRequestHeader(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tc.SetHeaders(map[string]string{\n\t\t\"foo\": \"1\", // ignored, because of the same header in the request\n\t\t\"bar\": \"2\",\n\t})\n\tr.SetHeaders(map[string]string{\n\t\t\"foo\": \"3\",\n\t\t\"xyz\": \"4\",\n\t})\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestHeader(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestHeader() error = %v\", err)\n\t\t}\n\t}\n}\n\ntype errorReader struct{}\n\nfunc (errorReader) Read(p []byte) (n int, err error) {\n\treturn 0, errors.New(\"fake\")\n}\n\nfunc Test_parseRequestBody(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname                  string\n\t\tinit                  func(c *Client, r *Request)\n\t\texpectedBodyBuf       []byte\n\t\texpectedContentLength string\n\t\texpectedContentType   string\n\t\twantErr               bool\n\t}{\n\t\t{\n\t\t\tname: \"empty body\",\n\t\t\tinit: func(c *Client, r *Request) {},\n\t\t},\n\t\t{\n\t\t\tname: \"empty body with SetContentLength by request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetContentLength(true)\n\t\t\t},\n\t\t\texpectedContentLength: \"0\",\n\t\t},\n\t\t{\n\t\t\tname: \"empty body with SetContentLength by client\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetContentLength(true)\n\t\t\t},\n\t\t\texpectedContentLength: \"0\",\n\t\t},\n\t\t{\n\t\t\tname: \"string body\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with GET method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodGet\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string body with GET method and AllowGetMethodPayload\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetAllowGetMethodPayload(true)\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodGet\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with HEAD method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodHead\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string body with OPTIONS method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodOptions\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"string body with POST method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodPost\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with PATCH method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodPatch\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with PUT method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodPut\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with DELETE method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodDelete\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with CONNECT method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodConnect\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with TRACE method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = http.MethodTrace\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"string body with BAR method\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(\"foo\")\n\t\t\t\tr.Method = \"BAR\"\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"byte body\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody([]byte(\"foo\"))\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo\"),\n\t\t\texpectedContentType: plainTextType,\n\t\t},\n\t\t{\n\t\t\tname: \"io.Reader body, no bodyBuf\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(bytes.NewBufferString(\"foo\"))\n\t\t\t},\n\t\t\texpectedContentType: jsonContentType,\n\t\t},\n\t\t{\n\t\t\tname: \"io.Reader body with SetContentLength by request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(bytes.NewBufferString(\"foo\")).\n\t\t\t\t\tSetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(\"foo\"),\n\t\t\texpectedContentLength: \"3\",\n\t\t\texpectedContentType:   jsonContentType,\n\t\t},\n\t\t{\n\t\t\tname: \"io.Reader body with SetContentLength by client\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetContentLength(true)\n\t\t\t\tr.SetBody(bytes.NewBufferString(\"foo\"))\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(\"foo\"),\n\t\t\texpectedContentLength: \"3\",\n\t\t\texpectedContentType:   jsonContentType,\n\t\t},\n\t\t{\n\t\t\tname: \"form data by request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetFormData(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo=1&bar=2\"),\n\t\t\texpectedContentType: formContentType,\n\t\t},\n\t\t{\n\t\t\tname: \"form data by client\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetFormData(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo=1&bar=2\"),\n\t\t\texpectedContentType: formContentType,\n\t\t},\n\t\t{\n\t\t\tname: \"form data by client and request\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetFormData(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t\tr.SetFormData(map[string]string{\n\t\t\t\t\t\"foo\": \"3\",\n\t\t\t\t\t\"baz\": \"4\",\n\t\t\t\t})\n\t\t\t},\n\t\t\texpectedBodyBuf:     []byte(\"foo=3&bar=2&baz=4\"),\n\t\t\texpectedContentType: formContentType,\n\t\t},\n\t\t{\n\t\t\tname: \"json from struct\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(struct {\n\t\t\t\t\tFoo string `json:\"foo\"`\n\t\t\t\t\tBar string `json:\"bar\"`\n\t\t\t\t}{\n\t\t\t\t\tFoo: \"1\",\n\t\t\t\t\tBar: \"2\",\n\t\t\t\t}).SetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`{\"foo\":\"1\",\"bar\":\"2\"}`),\n\t\t\texpectedContentType:   jsonContentType,\n\t\t\texpectedContentLength: \"21\",\n\t\t},\n\t\t{\n\t\t\tname: \"json from slice\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody([]string{\"foo\", \"bar\"}).SetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`[\"foo\",\"bar\"]`),\n\t\t\texpectedContentType:   jsonContentType,\n\t\t\texpectedContentLength: \"13\",\n\t\t},\n\t\t{\n\t\t\tname: \"json from map\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(map[string]interface{}{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": []int{1, 2, 3},\n\t\t\t\t\t\"baz\": map[string]string{\n\t\t\t\t\t\t\"qux\": \"4\",\n\t\t\t\t\t},\n\t\t\t\t\t\"xyz\": nil,\n\t\t\t\t}).SetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`{\"bar\":[1,2,3],\"baz\":{\"qux\":\"4\"},\"foo\":\"1\",\"xyz\":null}`),\n\t\t\texpectedContentType:   jsonContentType,\n\t\t\texpectedContentLength: \"54\",\n\t\t},\n\t\t{\n\t\t\tname: \"json from map\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(map[string]interface{}{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": []int{1, 2, 3},\n\t\t\t\t\t\"baz\": map[string]string{\n\t\t\t\t\t\t\"qux\": \"4\",\n\t\t\t\t\t},\n\t\t\t\t\t\"xyz\": nil,\n\t\t\t\t}).SetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`{\"bar\":[1,2,3],\"baz\":{\"qux\":\"4\"},\"foo\":\"1\",\"xyz\":null}`),\n\t\t\texpectedContentType:   jsonContentType,\n\t\t\texpectedContentLength: \"54\",\n\t\t},\n\t\t{\n\t\t\tname: \"json from map\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(map[string]interface{}{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": []int{1, 2, 3},\n\t\t\t\t\t\"baz\": map[string]string{\n\t\t\t\t\t\t\"qux\": \"4\",\n\t\t\t\t\t},\n\t\t\t\t\t\"xyz\": nil,\n\t\t\t\t}).SetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`{\"bar\":[1,2,3],\"baz\":{\"qux\":\"4\"},\"foo\":\"1\",\"xyz\":null}`),\n\t\t\texpectedContentType:   jsonContentType,\n\t\t\texpectedContentLength: \"54\",\n\t\t},\n\t\t{\n\t\t\tname: \"xml from struct\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\ttype FooBar struct {\n\t\t\t\t\tFoo string `xml:\"foo\"`\n\t\t\t\t\tBar string `xml:\"bar\"`\n\t\t\t\t}\n\t\t\t\tr.SetBody(FooBar{\n\t\t\t\t\tFoo: \"1\",\n\t\t\t\t\tBar: \"2\",\n\t\t\t\t}).\n\t\t\t\t\tSetContentLength(true).\n\t\t\t\t\tSetHeader(hdrContentTypeKey, \"text/xml\")\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`<FooBar><foo>1</foo><bar>2</bar></FooBar>`),\n\t\t\texpectedContentType:   \"text/xml\",\n\t\t\texpectedContentLength: \"41\",\n\t\t},\n\t\t{\n\t\t\tname: \"mulipart form data\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tc.SetFormData(map[string]string{\n\t\t\t\t\t\"foo\": \"1\",\n\t\t\t\t\t\"bar\": \"2\",\n\t\t\t\t})\n\t\t\t\tr.SetFormData(map[string]string{\n\t\t\t\t\t\"foo\": \"3\",\n\t\t\t\t\t\"baz\": \"4\",\n\t\t\t\t})\n\t\t\t\tr.SetMultipartFormData(map[string]string{\n\t\t\t\t\t\"foo\": \"5\",\n\t\t\t\t\t\"xyz\": \"6\",\n\t\t\t\t}).SetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`{\"bar\":\"2\", \"baz\":\"4\", \"foo\":\"5\", \"xyz\":\"6\"}`),\n\t\t\texpectedContentType:   \"multipart/form-data; boundary=\",\n\t\t\texpectedContentLength: \"744\",\n\t\t},\n\t\t{\n\t\t\tname: \"multipart fields\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetMultipartFields(\n\t\t\t\t\t&MultipartField{\n\t\t\t\t\t\tParam:       \"foo\",\n\t\t\t\t\t\tContentType: \"text/plain\",\n\t\t\t\t\t\tReader:      strings.NewReader(\"1\"),\n\t\t\t\t\t},\n\t\t\t\t\t&MultipartField{\n\t\t\t\t\t\tParam:       \"bar\",\n\t\t\t\t\t\tContentType: \"text/plain\",\n\t\t\t\t\t\tReader:      strings.NewReader(\"2\"),\n\t\t\t\t\t},\n\t\t\t\t).SetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`{\"bar\":\"2\",\"foo\":\"1\"}`),\n\t\t\texpectedContentType:   \"multipart/form-data; boundary=\",\n\t\t\texpectedContentLength: \"344\",\n\t\t},\n\t\t{\n\t\t\tname: \"multipart files\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetFileReader(\"foo\", \"foo.txt\", strings.NewReader(\"1\")).\n\t\t\t\t\tSetFileReader(\"bar\", \"bar.txt\", strings.NewReader(\"2\")).\n\t\t\t\t\tSetContentLength(true)\n\t\t\t},\n\t\t\texpectedBodyBuf:       []byte(`{\"bar\":\"2\",\"foo\":\"1\"}`),\n\t\t\texpectedContentType:   \"multipart/form-data; boundary=\",\n\t\t\texpectedContentLength: \"414\",\n\t\t},\n\t\t{\n\t\t\tname: \"body with errorReader\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(&errorReader{}).SetContentLength(true)\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported type\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(1)\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported xml\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetBody(struct {\n\t\t\t\t\tFoo string `xml:\"foo\"`\n\t\t\t\t\tBar string `xml:\"bar\"`\n\t\t\t\t}{\n\t\t\t\t\tFoo: \"1\",\n\t\t\t\t\tBar: \"2\",\n\t\t\t\t}).Header.Set(hdrContentTypeKey, \"text/xml\")\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multipart fields with errorReader\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetMultipartFields(&MultipartField{\n\t\t\t\t\tParam:       \"foo\",\n\t\t\t\t\tContentType: \"text/plain\",\n\t\t\t\t\tReader:      &errorReader{},\n\t\t\t\t})\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multipart files with errorReader\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetFileReader(\"foo\", \"foo.txt\", &errorReader{})\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"multipart with file not found\",\n\t\t\tinit: func(c *Client, r *Request) {\n\t\t\t\tr.SetFormData(map[string]string{\n\t\t\t\t\t\"@foo\": \"foo.txt\",\n\t\t\t\t})\n\t\t\t\tr.isMultiPart = true\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t} {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := New()\n\t\t\tr := c.R()\n\t\t\ttt.init(c, r)\n\t\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\t\tif tt.wantErr {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tt.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t\t} else if tt.wantErr {\n\t\t\t\tt.Errorf(\"wanted error, but got nil\")\n\t\t\t}\n\t\t\tswitch {\n\t\t\tcase r.bodyBuf == nil && tt.expectedBodyBuf != nil:\n\t\t\t\tt.Errorf(\"bodyBuf is nil, but expected: %s\", string(tt.expectedBodyBuf))\n\t\t\tcase r.bodyBuf != nil && tt.expectedBodyBuf == nil:\n\t\t\t\tt.Errorf(\"bodyBuf is not nil, but expected nil: %s\", r.bodyBuf.String())\n\t\t\tcase r.bodyBuf != nil && tt.expectedBodyBuf != nil:\n\t\t\t\tvar actual, expected interface{} = r.bodyBuf.Bytes(), tt.expectedBodyBuf\n\t\t\t\tif r.isFormData {\n\t\t\t\t\tvar err error\n\t\t\t\t\tactual, err = url.ParseQuery(r.bodyBuf.String())\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Errorf(\"ParseQuery(r.bodyBuf) error = %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\texpected, err = url.ParseQuery(string(tt.expectedBodyBuf))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Errorf(\"ParseQuery(tt.expectedBodyBuf) error = %v\", err)\n\t\t\t\t\t}\n\t\t\t\t} else if r.isMultiPart {\n\t\t\t\t\t_, params, err := mime.ParseMediaType(r.Header.Get(hdrContentTypeKey))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Errorf(\"ParseMediaType(hdrContentTypeKey) error = %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tboundary, ok := params[\"boundary\"]\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tt.Errorf(\"boundary not found in Content-Type header\")\n\t\t\t\t\t}\n\t\t\t\t\treader := multipart.NewReader(r.bodyBuf, boundary)\n\t\t\t\t\tbody := make(map[string]interface{})\n\t\t\t\t\tfor part, perr := reader.NextPart(); perr != io.EOF; part, perr = reader.NextPart() {\n\t\t\t\t\t\tif perr != nil {\n\t\t\t\t\t\t\tt.Errorf(\"NextPart() error = %v\", perr)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tname := part.FormName()\n\t\t\t\t\t\tif name == \"\" {\n\t\t\t\t\t\t\tname = part.FileName()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdata, err := io.ReadAll(part)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Errorf(\"ReadAll(part) error = %v\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbody[name] = string(data)\n\t\t\t\t\t}\n\t\t\t\t\tactual = body\n\t\t\t\t\texpected = nil\n\t\t\t\t\tif err := json.Unmarshal(tt.expectedBodyBuf, &expected); err != nil {\n\t\t\t\t\t\tt.Errorf(\"json.Unmarshal(tt.expectedBodyBuf) error = %v\", err)\n\t\t\t\t\t}\n\t\t\t\t\tt.Logf(`in case of an error, the expected body should be set as json for object: %#+v`, actual)\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(actual, expected) {\n\t\t\t\t\tt.Errorf(\"bodyBuf = %q does not match expected %q\", r.bodyBuf.String(), string(tt.expectedBodyBuf))\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tt.expectedContentLength != r.Header.Get(hdrContentLengthKey) {\n\t\t\t\tt.Errorf(\"Content-Length header = %q does not match expected %q\", r.Header.Get(hdrContentLengthKey), tt.expectedContentLength)\n\t\t\t}\n\t\t\tif ct := r.Header.Get(hdrContentTypeKey); !((tt.expectedContentType == \"\" && ct != \"\") || strings.Contains(ct, tt.expectedContentType)) {\n\t\t\t\tt.Errorf(\"Content-Type header = %q does not match expected %q\", r.Header.Get(hdrContentTypeKey), tt.expectedContentType)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Benchmark_parseRequestBody_string(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tr.SetBody(\"foo\").SetContentLength(true)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_byte(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tr.SetBody([]byte(\"foo\")).SetContentLength(true)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_reader_with_SetContentLength(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tr.SetBody(bytes.NewBufferString(\"foo\")).SetContentLength(true)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_reader_without_SetContentLength(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tr.SetBody(bytes.NewBufferString(\"foo\"))\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_struct(b *testing.B) {\n\ttype FooBar struct {\n\t\tFoo string `json:\"foo\"`\n\t\tBar string `json:\"bar\"`\n\t}\n\tc := New()\n\tr := c.R()\n\tr.SetBody(FooBar{Foo: \"1\", Bar: \"2\"}).SetContentLength(true).SetHeader(hdrContentTypeKey, jsonContentType)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_struct_xml(b *testing.B) {\n\ttype FooBar struct {\n\t\tFoo string `xml:\"foo\"`\n\t\tBar string `xml:\"bar\"`\n\t}\n\tc := New()\n\tr := c.R()\n\tr.SetBody(FooBar{Foo: \"1\", Bar: \"2\"}).SetContentLength(true).SetHeader(hdrContentTypeKey, \"text/xml\")\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_map(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tr.SetBody(map[string]string{\n\t\t\"foo\": \"1\",\n\t\t\"bar\": \"2\",\n\t}).SetContentLength(true).SetHeader(hdrContentTypeKey, jsonContentType)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_slice(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tr.SetBody([]string{\"1\", \"2\"}).SetContentLength(true).SetHeader(hdrContentTypeKey, jsonContentType)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_FormData(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tc.SetFormData(map[string]string{\"foo\": \"1\", \"bar\": \"2\"})\n\tr.SetFormData(map[string]string{\"foo\": \"3\", \"baz\": \"4\"}).SetContentLength(true)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n\nfunc Benchmark_parseRequestBody_MultiPart(b *testing.B) {\n\tc := New()\n\tr := c.R()\n\tc.SetFormData(map[string]string{\"foo\": \"1\", \"bar\": \"2\"})\n\tr.SetFormData(map[string]string{\"foo\": \"3\", \"baz\": \"4\"}).\n\t\tSetMultipartFormData(map[string]string{\"foo\": \"5\", \"xyz\": \"6\"}).\n\t\tSetFileReader(\"qwe\", \"qwe.txt\", strings.NewReader(\"7\")).\n\t\tSetMultipartFields(\n\t\t\t&MultipartField{\n\t\t\t\tParam:       \"sdj\",\n\t\t\t\tContentType: \"text/plain\",\n\t\t\t\tReader:      strings.NewReader(\"8\"),\n\t\t\t},\n\t\t).\n\t\tSetContentLength(true)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := parseRequestBody(c, r); err != nil {\n\t\t\tb.Errorf(\"parseRequestBody() error = %v\", err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "redirect.go",
          "type": "blob",
          "size": 3.3427734375,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nvar (\n\tErrAutoRedirectDisabled = errors.New(\"auto redirect is disabled\")\n)\n\ntype (\n\t// RedirectPolicy to regulate the redirects in the Resty client.\n\t// Objects implementing the [RedirectPolicy] interface can be registered as\n\t//\n\t// Apply function should return nil to continue the redirect journey; otherwise\n\t// return error to stop the redirect.\n\tRedirectPolicy interface {\n\t\tApply(req *http.Request, via []*http.Request) error\n\t}\n\n\t// The [RedirectPolicyFunc] type is an adapter to allow the use of ordinary\n\t// functions as [RedirectPolicy]. If `f` is a function with the appropriate\n\t// signature, RedirectPolicyFunc(f) is a RedirectPolicy object that calls `f`.\n\tRedirectPolicyFunc func(*http.Request, []*http.Request) error\n)\n\n// Apply calls f(req, via).\nfunc (f RedirectPolicyFunc) Apply(req *http.Request, via []*http.Request) error {\n\treturn f(req, via)\n}\n\n// NoRedirectPolicy is used to disable redirects in the Resty client\n//\n//\tresty.SetRedirectPolicy(NoRedirectPolicy())\nfunc NoRedirectPolicy() RedirectPolicy {\n\treturn RedirectPolicyFunc(func(req *http.Request, via []*http.Request) error {\n\t\treturn ErrAutoRedirectDisabled\n\t})\n}\n\n// FlexibleRedirectPolicy method is convenient for creating several redirect policies for Resty clients.\n//\n//\tresty.SetRedirectPolicy(FlexibleRedirectPolicy(20))\nfunc FlexibleRedirectPolicy(noOfRedirect int) RedirectPolicy {\n\treturn RedirectPolicyFunc(func(req *http.Request, via []*http.Request) error {\n\t\tif len(via) >= noOfRedirect {\n\t\t\treturn fmt.Errorf(\"stopped after %d redirects\", noOfRedirect)\n\t\t}\n\t\tcheckHostAndAddHeaders(req, via[0])\n\t\treturn nil\n\t})\n}\n\n// DomainCheckRedirectPolicy method is convenient for defining domain name redirect rules in Resty clients.\n// Redirect is allowed only for the host mentioned in the policy.\n//\n//\tresty.SetRedirectPolicy(DomainCheckRedirectPolicy(\"host1.com\", \"host2.org\", \"host3.net\"))\nfunc DomainCheckRedirectPolicy(hostnames ...string) RedirectPolicy {\n\thosts := make(map[string]bool)\n\tfor _, h := range hostnames {\n\t\thosts[strings.ToLower(h)] = true\n\t}\n\n\tfn := RedirectPolicyFunc(func(req *http.Request, via []*http.Request) error {\n\t\tif ok := hosts[getHostname(req.URL.Host)]; !ok {\n\t\t\treturn errors.New(\"redirect is not allowed as per DomainCheckRedirectPolicy\")\n\t\t}\n\n\t\treturn nil\n\t})\n\n\treturn fn\n}\n\nfunc getHostname(host string) (hostname string) {\n\tif strings.Index(host, \":\") > 0 {\n\t\thost, _, _ = net.SplitHostPort(host)\n\t}\n\thostname = strings.ToLower(host)\n\treturn\n}\n\n// By default, Golang will not redirect request headers.\n// After reading through the various discussion comments from the thread -\n// https://github.com/golang/go/issues/4800\n// Resty will add all the headers during a redirect for the same host and\n// adds library user-agent if the Host is different.\nfunc checkHostAndAddHeaders(cur *http.Request, pre *http.Request) {\n\tcurHostname := getHostname(cur.URL.Host)\n\tpreHostname := getHostname(pre.URL.Host)\n\tif strings.EqualFold(curHostname, preHostname) {\n\t\tfor key, val := range pre.Header {\n\t\t\tcur.Header[key] = val\n\t\t}\n\t} else { // only library User-Agent header is added\n\t\tcur.Header.Set(hdrUserAgentKey, hdrUserAgentValue)\n\t}\n}\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 36.498046875,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n)\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Request struct and methods\n//_______________________________________________________________________\n\n// Request struct is used to compose and fire individual requests from\n// Resty client. The [Request] provides an option to override client-level\n// settings and also an option for the request composition.\ntype Request struct {\n\tURL           string\n\tMethod        string\n\tToken         string\n\tAuthScheme    string\n\tQueryParam    url.Values\n\tFormData      url.Values\n\tPathParams    map[string]string\n\tRawPathParams map[string]string\n\tHeader        http.Header\n\tTime          time.Time\n\tBody          interface{}\n\tResult        interface{}\n\tresultCurlCmd *string\n\tError         interface{}\n\tRawRequest    *http.Request\n\tSRV           *SRVRecord\n\tUserInfo      *User\n\tCookies       []*http.Cookie\n\tDebug         bool\n\n\t// Attempt is to represent the request attempt made during a Resty\n\t// request execution flow, including retry count.\n\tAttempt int\n\n\tisMultiPart         bool\n\tisFormData          bool\n\tsetContentLength    bool\n\tisSaveResponse      bool\n\tnotParseResponse    bool\n\tjsonEscapeHTML      bool\n\ttrace               bool\n\toutputFile          string\n\tfallbackContentType string\n\tforceContentType    string\n\tctx                 context.Context\n\tvalues              map[string]interface{}\n\tclient              *Client\n\tbodyBuf             *bytes.Buffer\n\tclientTrace         *clientTrace\n\tlog                 Logger\n\tmultipartBoundary   string\n\tmultipartFiles      []*File\n\tmultipartFields     []*MultipartField\n\tretryConditions     []RetryConditionFunc\n\tresponseBodyLimit   int\n\tgenerateCurlOnDebug bool\n\tunescapeQueryParams bool\n}\n\n// GenerateCurlCommand method generates the CURL command for the request.\nfunc (r *Request) GenerateCurlCommand() string {\n\tif !(r.Debug && r.generateCurlOnDebug) {\n\t\treturn \"\"\n\t}\n\n\tif r.resultCurlCmd != nil {\n\t\treturn *r.resultCurlCmd\n\t}\n\n\tif r.RawRequest == nil {\n\t\tr.client.executeBefore(r) // mock with r.Get(\"/\")\n\t}\n\tif r.resultCurlCmd == nil {\n\t\tr.resultCurlCmd = new(string)\n\t}\n\t*r.resultCurlCmd = buildCurlRequest(r.RawRequest, r.client.httpClient.Jar)\n\treturn *r.resultCurlCmd\n}\n\n// Context method returns the Context if it is already set in the [Request]\n// otherwise, it creates a new one using [context.Background].\nfunc (r *Request) Context() context.Context {\n\tif r.ctx == nil {\n\t\treturn context.Background()\n\t}\n\treturn r.ctx\n}\n\n// SetContext method sets the [context.Context] for current [Request]. It allows\n// to interrupt the request execution if `ctx.Done()` channel is closed.\n// See https://blog.golang.org/context article and the package [context]\n// documentation.\nfunc (r *Request) SetContext(ctx context.Context) *Request {\n\tr.ctx = ctx\n\treturn r\n}\n\n// SetHeader method sets a single header field and its value in the current request.\n//\n// For Example: To set `Content-Type` and `Accept` as `application/json`.\n//\n//\tclient.R().\n//\t\tSetHeader(\"Content-Type\", \"application/json\").\n//\t\tSetHeader(\"Accept\", \"application/json\")\n//\n// It overrides the header value set at the client instance level.\nfunc (r *Request) SetHeader(header, value string) *Request {\n\tr.Header.Set(header, value)\n\treturn r\n}\n\n// SetHeaders method sets multiple header fields and their values at one go in the current request.\n//\n// For Example: To set `Content-Type` and `Accept` as `application/json`\n//\n//\tclient.R().\n//\t\tSetHeaders(map[string]string{\n//\t\t\t\"Content-Type\": \"application/json\",\n//\t\t\t\"Accept\": \"application/json\",\n//\t\t})\n//\n// It overrides the header value set at the client instance level.\nfunc (r *Request) SetHeaders(headers map[string]string) *Request {\n\tfor h, v := range headers {\n\t\tr.SetHeader(h, v)\n\t}\n\treturn r\n}\n\n// SetHeaderMultiValues sets multiple header fields and their values as a list of strings in the current request.\n//\n// For Example: To set `Accept` as `text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8`\n//\n//\tclient.R().\n//\t\tSetHeaderMultiValues(map[string][]string{\n//\t\t\t\"Accept\": []string{\"text/html\", \"application/xhtml+xml\", \"application/xml;q=0.9\", \"image/webp\", \"*/*;q=0.8\"},\n//\t\t})\n//\n// It overrides the header value set at the client instance level.\nfunc (r *Request) SetHeaderMultiValues(headers map[string][]string) *Request {\n\tfor key, values := range headers {\n\t\tr.SetHeader(key, strings.Join(values, \", \"))\n\t}\n\treturn r\n}\n\n// SetHeaderVerbatim method sets a single header field and its value verbatim in the current request.\n//\n// For Example: To set `all_lowercase` and `UPPERCASE` as `available`.\n//\n//\tclient.R().\n//\t\tSetHeaderVerbatim(\"all_lowercase\", \"available\").\n//\t\tSetHeaderVerbatim(\"UPPERCASE\", \"available\")\n//\n// It overrides the header value set at the client instance level.\nfunc (r *Request) SetHeaderVerbatim(header, value string) *Request {\n\tr.Header[header] = []string{value}\n\treturn r\n}\n\n// SetQueryParam method sets a single parameter and its value in the current request.\n// It will be formed as a query string for the request.\n//\n// For Example: `search=kitchen%20papers&size=large` in the URL after the `?` mark.\n//\n//\tclient.R().\n//\t\tSetQueryParam(\"search\", \"kitchen papers\").\n//\t\tSetQueryParam(\"size\", \"large\")\n//\n// It overrides the query parameter value set at the client instance level.\nfunc (r *Request) SetQueryParam(param, value string) *Request {\n\tr.QueryParam.Set(param, value)\n\treturn r\n}\n\n// SetQueryParams method sets multiple parameters and their values at one go in the current request.\n// It will be formed as a query string for the request.\n//\n// For Example: `search=kitchen%20papers&size=large` in the URL after the `?` mark.\n//\n//\tclient.R().\n//\t\tSetQueryParams(map[string]string{\n//\t\t\t\"search\": \"kitchen papers\",\n//\t\t\t\"size\": \"large\",\n//\t\t})\n//\n// It overrides the query parameter value set at the client instance level.\nfunc (r *Request) SetQueryParams(params map[string]string) *Request {\n\tfor p, v := range params {\n\t\tr.SetQueryParam(p, v)\n\t}\n\treturn r\n}\n\n// SetUnescapeQueryParams method sets the unescape query parameters choice for request URL.\n// To prevent broken URL, resty replaces space (\" \") with \"+\" in the query parameters.\n//\n// This method overrides the value set by [Client.SetUnescapeQueryParams]\n//\n// NOTE: Request failure is possible due to non-standard usage of Unescaped Query Parameters.\nfunc (r *Request) SetUnescapeQueryParams(unescape bool) *Request {\n\tr.unescapeQueryParams = unescape\n\treturn r\n}\n\n// SetQueryParamsFromValues method appends multiple parameters with multi-value\n// ([url.Values]) at one go in the current request. It will be formed as\n// query string for the request.\n//\n// For Example: `status=pending&status=approved&status=open` in the URL after the `?` mark.\n//\n//\tclient.R().\n//\t\tSetQueryParamsFromValues(url.Values{\n//\t\t\t\"status\": []string{\"pending\", \"approved\", \"open\"},\n//\t\t})\n//\n// It overrides the query parameter value set at the client instance level.\nfunc (r *Request) SetQueryParamsFromValues(params url.Values) *Request {\n\tfor p, v := range params {\n\t\tfor _, pv := range v {\n\t\t\tr.QueryParam.Add(p, pv)\n\t\t}\n\t}\n\treturn r\n}\n\n// SetQueryString method provides the ability to use string as an input to set URL query string for the request.\n//\n//\tclient.R().\n//\t\tSetQueryString(\"productId=232&template=fresh-sample&cat=resty&source=google&kw=buy a lot more\")\n//\n// It overrides the query parameter value set at the client instance level.\nfunc (r *Request) SetQueryString(query string) *Request {\n\tparams, err := url.ParseQuery(strings.TrimSpace(query))\n\tif err == nil {\n\t\tfor p, v := range params {\n\t\t\tfor _, pv := range v {\n\t\t\t\tr.QueryParam.Add(p, pv)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tr.log.Errorf(\"%v\", err)\n\t}\n\treturn r\n}\n\n// SetFormData method sets Form parameters and their values for the current request.\n// It applies only to HTTP methods `POST` and `PUT`, and by default requests\n// content type would be set as `application/x-www-form-urlencoded`.\n//\n//\tclient.R().\n//\t\tSetFormData(map[string]string{\n//\t\t\t\"access_token\": \"BC594900-518B-4F7E-AC75-BD37F019E08F\",\n//\t\t\t\"user_id\": \"3455454545\",\n//\t\t})\n//\n// It overrides the form data value set at the client instance level.\nfunc (r *Request) SetFormData(data map[string]string) *Request {\n\tfor k, v := range data {\n\t\tr.FormData.Set(k, v)\n\t}\n\treturn r\n}\n\n// SetFormDataFromValues method appends multiple form parameters with multi-value\n// ([url.Values]) at one go in the current request.\n//\n//\tclient.R().\n//\t\tSetFormDataFromValues(url.Values{\n//\t\t\t\"search_criteria\": []string{\"book\", \"glass\", \"pencil\"},\n//\t\t})\n//\n// It overrides the form data value set at the client instance level.\nfunc (r *Request) SetFormDataFromValues(data url.Values) *Request {\n\tfor k, v := range data {\n\t\tfor _, kv := range v {\n\t\t\tr.FormData.Add(k, kv)\n\t\t}\n\t}\n\treturn r\n}\n\n// SetBody method sets the request body for the request. It supports various practical needs as easy.\n// It's quite handy and powerful. Supported request body data types are `string`,\n// `[]byte`, `struct`, `map`, `slice` and [io.Reader].\n//\n// Body value can be pointer or non-pointer. Automatic marshalling for JSON and XML content type, if it is `struct`, `map`, or `slice`.\n//\n// NOTE: [io.Reader] is processed in bufferless mode while sending a request.\n//\n// For Example:\n//\n// `struct` gets marshaled based on the request header `Content-Type`.\n//\n//\tclient.R().\n//\t\tSetBody(User{\n//\t\t\tUsername: \"jeeva@myjeeva.com\",\n//\t\t\tPassword: \"welcome2resty\",\n//\t\t})\n//\n// 'map` gets marshaled based on the request header `Content-Type`.\n//\n//\tclient.R().\n//\t\tSetBody(map[string]interface{}{\n//\t\t\t\"username\": \"jeeva@myjeeva.com\",\n//\t\t\t\"password\": \"welcome2resty\",\n//\t\t\t\"address\": &Address{\n//\t\t\t\tAddress1: \"1111 This is my street\",\n//\t\t\t\tAddress2: \"Apt 201\",\n//\t\t\t\tCity: \"My City\",\n//\t\t\t\tState: \"My State\",\n//\t\t\t\tZipCode: 00000,\n//\t\t\t},\n//\t\t})\n//\n// `string` as a body input. Suitable for any need as a string input.\n//\n//\tclient.R().\n//\t\tSetBody(`{\n//\t\t\t\"username\": \"jeeva@getrightcare.com\",\n//\t\t\t\"password\": \"admin\"\n//\t\t}`)\n//\n// `[]byte` as a body input. Suitable for raw requests such as file upload, serialize & deserialize, etc.\n//\n//\tclient.R().\n//\t\tSetBody([]byte(\"This is my raw request, sent as-is\"))\n//\n// and so on.\nfunc (r *Request) SetBody(body interface{}) *Request {\n\tr.Body = body\n\treturn r\n}\n\n// SetResult method is to register the response `Result` object for automatic\n// unmarshalling of the HTTP response if the response status code is\n// between 200 and 299, and the content type is JSON or XML.\n//\n// Note: [Request.SetResult] input can be a pointer or non-pointer.\n//\n// The pointer with handle\n//\n//\tauthToken := &AuthToken{}\n//\tclient.R().SetResult(authToken)\n//\n//\t// Can be accessed via -\n//\tfmt.Println(authToken) OR fmt.Println(response.Result().(*AuthToken))\n//\n// OR -\n//\n// The pointer without handle or non-pointer\n//\n//\tclient.R().SetResult(&AuthToken{})\n//\t// OR\n//\tclient.R().SetResult(AuthToken{})\n//\n//\t// Can be accessed via -\n//\tfmt.Println(response.Result().(*AuthToken))\nfunc (r *Request) SetResult(res interface{}) *Request {\n\tif res != nil {\n\t\tr.Result = getPointer(res)\n\t}\n\treturn r\n}\n\n// SetError method is to register the request `Error` object for automatic unmarshalling for the request,\n// if the response status code is greater than 399 and the content type is either JSON or XML.\n//\n// NOTE: [Request.SetError] input can be a pointer or non-pointer.\n//\n//\tclient.R().SetError(&AuthError{})\n//\t// OR\n//\tclient.R().SetError(AuthError{})\n//\n// Accessing an error value from response instance.\n//\n//\tresponse.Error().(*AuthError)\n//\n// If this request Error object is nil, Resty will use the client-level error object Type if it is set.\nfunc (r *Request) SetError(err interface{}) *Request {\n\tr.Error = getPointer(err)\n\treturn r\n}\n\n// SetFile method sets a single file field name and its path for multipart upload.\n//\n//\tclient.R().\n//\t\tSetFile(\"my_file\", \"/Users/jeeva/Gas Bill - Sep.pdf\")\nfunc (r *Request) SetFile(param, filePath string) *Request {\n\tr.isMultiPart = true\n\tr.FormData.Set(\"@\"+param, filePath)\n\treturn r\n}\n\n// SetFiles method sets multiple file field names and their paths for multipart uploads.\n//\n//\tclient.R().\n//\t\tSetFiles(map[string]string{\n//\t\t\t\t\"my_file1\": \"/Users/jeeva/Gas Bill - Sep.pdf\",\n//\t\t\t\t\"my_file2\": \"/Users/jeeva/Electricity Bill - Sep.pdf\",\n//\t\t\t\t\"my_file3\": \"/Users/jeeva/Water Bill - Sep.pdf\",\n//\t\t\t})\nfunc (r *Request) SetFiles(files map[string]string) *Request {\n\tr.isMultiPart = true\n\tfor f, fp := range files {\n\t\tr.FormData.Set(\"@\"+f, fp)\n\t}\n\treturn r\n}\n\n// SetFileReader method is to set a file using [io.Reader] for multipart upload.\n//\n//\tclient.R().\n//\t\tSetFileReader(\"profile_img\", \"my-profile-img.png\", bytes.NewReader(profileImgBytes)).\n//\t\tSetFileReader(\"notes\", \"user-notes.txt\", bytes.NewReader(notesBytes))\nfunc (r *Request) SetFileReader(param, fileName string, reader io.Reader) *Request {\n\tr.isMultiPart = true\n\tr.multipartFiles = append(r.multipartFiles, &File{\n\t\tName:      fileName,\n\t\tParamName: param,\n\t\tReader:    reader,\n\t})\n\treturn r\n}\n\n// SetMultipartFormData method allows simple form data to be attached to the request\n// as `multipart:form-data`\nfunc (r *Request) SetMultipartFormData(data map[string]string) *Request {\n\tfor k, v := range data {\n\t\tr = r.SetMultipartField(k, \"\", \"\", strings.NewReader(v))\n\t}\n\n\treturn r\n}\n\n// SetMultipartField method sets custom data with Content-Type using [io.Reader] for multipart upload.\nfunc (r *Request) SetMultipartField(param, fileName, contentType string, reader io.Reader) *Request {\n\tr.isMultiPart = true\n\tr.multipartFields = append(r.multipartFields, &MultipartField{\n\t\tParam:       param,\n\t\tFileName:    fileName,\n\t\tContentType: contentType,\n\t\tReader:      reader,\n\t})\n\treturn r\n}\n\n// SetMultipartFields method sets multiple data fields using [io.Reader] for multipart upload.\n//\n// For Example:\n//\n//\tclient.R().SetMultipartFields(\n//\t\t&resty.MultipartField{\n//\t\t\tParam:       \"uploadManifest1\",\n//\t\t\tFileName:    \"upload-file-1.json\",\n//\t\t\tContentType: \"application/json\",\n//\t\t\tReader:      strings.NewReader(`{\"input\": {\"name\": \"Uploaded document 1\", \"_filename\" : [\"file1.txt\"]}}`),\n//\t\t},\n//\t\t&resty.MultipartField{\n//\t\t\tParam:       \"uploadManifest2\",\n//\t\t\tFileName:    \"upload-file-2.json\",\n//\t\t\tContentType: \"application/json\",\n//\t\t\tReader:      strings.NewReader(`{\"input\": {\"name\": \"Uploaded document 2\", \"_filename\" : [\"file2.txt\"]}}`),\n//\t\t})\n//\n// If you have a `slice` of fields already, then call-\n//\n//\tclient.R().SetMultipartFields(fields...)\nfunc (r *Request) SetMultipartFields(fields ...*MultipartField) *Request {\n\tr.isMultiPart = true\n\tr.multipartFields = append(r.multipartFields, fields...)\n\treturn r\n}\n\n// SetMultipartBoundary method sets the custom multipart boundary for the multipart request.\n// Typically, the `mime/multipart` package generates a random multipart boundary if not provided.\nfunc (r *Request) SetMultipartBoundary(boundary string) *Request {\n\tr.multipartBoundary = boundary\n\treturn r\n}\n\n// SetContentLength method sets the current request's HTTP header `Content-Length` value.\n// By default, Resty won't set `Content-Length`.\n//\n// See [Client.SetContentLength]\n//\n//\tclient.R().SetContentLength(true)\n//\n// It overrides the value set at the client instance level.\nfunc (r *Request) SetContentLength(l bool) *Request {\n\tr.setContentLength = l\n\treturn r\n}\n\n// SetBasicAuth method sets the basic authentication header in the current HTTP request.\n//\n// For Example:\n//\n//\tAuthorization: Basic <base64-encoded-value>\n//\n// To set the header for username \"go-resty\" and password \"welcome\"\n//\n//\tclient.R().SetBasicAuth(\"go-resty\", \"welcome\")\n//\n// It overrides the credentials set by method [Client.SetBasicAuth].\nfunc (r *Request) SetBasicAuth(username, password string) *Request {\n\tr.UserInfo = &User{Username: username, Password: password}\n\treturn r\n}\n\n// SetAuthToken method sets the auth token header(Default Scheme: Bearer) in the current HTTP request. Header example:\n//\n//\tAuthorization: Bearer <auth-token-value-comes-here>\n//\n// For Example: To set auth token BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\n//\n//\tclient.R().SetAuthToken(\"BC594900518B4F7EAC75BD37F019E08FBC594900518B4F7EAC75BD37F019E08F\")\n//\n// It overrides the Auth token set by method [Client.SetAuthToken].\nfunc (r *Request) SetAuthToken(token string) *Request {\n\tr.Token = token\n\treturn r\n}\n\n// SetAuthScheme method sets the auth token scheme type in the HTTP request.\n//\n// Example Header value structure:\n//\n//\tAuthorization: <auth-scheme-value-set-here> <auth-token-value>\n//\n// For Example: To set the scheme to use OAuth\n//\n//\tclient.R().SetAuthScheme(\"OAuth\")\n//\n//\t// The outcome will be -\n//\tAuthorization: OAuth <auth-token-value>\n//\n// Information about Auth schemes can be found in [RFC 7235], IANA [HTTP Auth schemes]\n//\n// It overrides the `Authorization` scheme set by method [Client.SetAuthScheme].\n//\n// [RFC 7235]: https://tools.ietf.org/html/rfc7235\n// [HTTP Auth schemes]: https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml#authschemes\nfunc (r *Request) SetAuthScheme(scheme string) *Request {\n\tr.AuthScheme = scheme\n\treturn r\n}\n\n// SetDigestAuth method sets the Digest Access auth scheme for the HTTP request.\n// If a server responds with 401 and sends a Digest challenge in the WWW-Authenticate Header,\n// the request will be resent with the appropriate Authorization Header.\n//\n// For Example: To set the Digest scheme with username \"Mufasa\" and password \"Circle Of Life\"\n//\n//\tclient.R().SetDigestAuth(\"Mufasa\", \"Circle Of Life\")\n//\n// Information about Digest Access Authentication can be found in [RFC 7616]\n//\n// It overrides the digest username and password set by method [Client.SetDigestAuth].\n//\n// [RFC 7616]: https://datatracker.ietf.org/doc/html/rfc7616\nfunc (r *Request) SetDigestAuth(username, password string) *Request {\n\toldTransport := r.client.httpClient.Transport\n\tr.client.OnBeforeRequest(func(c *Client, _ *Request) error {\n\t\tc.httpClient.Transport = &digestTransport{\n\t\t\tdigestCredentials: digestCredentials{username, password},\n\t\t\ttransport:         oldTransport,\n\t\t}\n\t\treturn nil\n\t})\n\tr.client.OnAfterResponse(func(c *Client, _ *Response) error {\n\t\tc.httpClient.Transport = oldTransport\n\t\treturn nil\n\t})\n\n\treturn r\n}\n\n// SetOutput method sets the output file for the current HTTP request. The current\n// HTTP response will be saved in the given file. It is similar to the `curl -o` flag.\n//\n// Absolute path or relative path can be used.\n//\n// If it is a relative path, then the output file goes under the output directory, as mentioned\n// in the [Client.SetOutputDirectory].\n//\n//\tclient.R().\n//\t\tSetOutput(\"/Users/jeeva/Downloads/ReplyWithHeader-v5.1-beta.zip\").\n//\t\tGet(\"http://bit.ly/1LouEKr\")\n//\n// NOTE: In this scenario [Response.Body] might be nil.\nfunc (r *Request) SetOutput(file string) *Request {\n\tr.outputFile = file\n\tr.isSaveResponse = true\n\treturn r\n}\n\n// SetSRV method sets the details to query the service SRV record and execute the\n// request.\n//\n//\tclient.R().\n//\t\tSetSRV(SRVRecord{\"web\", \"testservice.com\"}).\n//\t\tGet(\"/get\")\nfunc (r *Request) SetSRV(srv *SRVRecord) *Request {\n\tr.SRV = srv\n\treturn r\n}\n\n// SetDoNotParseResponse method instructs Resty not to parse the response body automatically.\n// Resty exposes the raw response body as [io.ReadCloser]. If you use it, do not\n// forget to close the body, otherwise, you might get into connection leaks, and connection\n// reuse may not happen.\n//\n// NOTE: [Response] middlewares are not executed using this option. You have\n// taken over the control of response parsing from Resty.\nfunc (r *Request) SetDoNotParseResponse(parse bool) *Request {\n\tr.notParseResponse = parse\n\treturn r\n}\n\n// SetResponseBodyLimit method sets a maximum body size limit in bytes on response,\n// avoid reading too much data to memory.\n//\n// Client will return [resty.ErrResponseBodyTooLarge] if the body size of the body\n// in the uncompressed response is larger than the limit.\n// Body size limit will not be enforced in the following cases:\n//   - ResponseBodyLimit <= 0, which is the default behavior.\n//   - [Request.SetOutput] is called to save response data to the file.\n//   - \"DoNotParseResponse\" is set for client or request.\n//\n// It overrides the value set at the client instance level. see [Client.SetResponseBodyLimit]\nfunc (r *Request) SetResponseBodyLimit(v int) *Request {\n\tr.responseBodyLimit = v\n\treturn r\n}\n\n// SetPathParam method sets a single URL path key-value pair in the\n// Resty current request instance.\n//\n//\tclient.R().SetPathParam(\"userId\", \"sample@sample.com\")\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/details\n//\t   Composed URL - /v1/users/sample@sample.com/details\n//\n//\tclient.R().SetPathParam(\"path\", \"groups/developers\")\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/details\n//\t   Composed URL - /v1/users/groups%2Fdevelopers/details\n//\n// It replaces the value of the key while composing the request URL.\n// The values will be escaped using function [url.PathEscape].\n//\n// It overrides the path parameter set at the client instance level.\nfunc (r *Request) SetPathParam(param, value string) *Request {\n\tr.PathParams[param] = value\n\treturn r\n}\n\n// SetPathParams method sets multiple URL path key-value pairs at one go in the\n// Resty current request instance.\n//\n//\tclient.R().SetPathParams(map[string]string{\n//\t\t\"userId\":       \"sample@sample.com\",\n//\t\t\"subAccountId\": \"100002\",\n//\t\t\"path\":         \"groups/developers\",\n//\t})\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/{subAccountId}/{path}/details\n//\t   Composed URL - /v1/users/sample@sample.com/100002/groups%2Fdevelopers/details\n//\n// It replaces the value of the key while composing the request URL.\n// The values will be escaped using function [url.PathEscape].\n//\n// It overrides the path parameter set at the client instance level.\nfunc (r *Request) SetPathParams(params map[string]string) *Request {\n\tfor p, v := range params {\n\t\tr.SetPathParam(p, v)\n\t}\n\treturn r\n}\n\n// SetRawPathParam method sets a single URL path key-value pair in the\n// Resty current request instance.\n//\n//\tclient.R().SetPathParam(\"userId\", \"sample@sample.com\")\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/details\n//\t   Composed URL - /v1/users/sample@sample.com/details\n//\n//\tclient.R().SetPathParam(\"path\", \"groups/developers\")\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/details\n//\t   Composed URL - /v1/users/groups/developers/details\n//\n// It replaces the value of the key while composing the request URL.\n// The value will be used as-is and has not been escaped.\n//\n// It overrides the raw path parameter set at the client instance level.\nfunc (r *Request) SetRawPathParam(param, value string) *Request {\n\tr.RawPathParams[param] = value\n\treturn r\n}\n\n// SetRawPathParams method sets multiple URL path key-value pairs at one go in the\n// Resty current request instance.\n//\n//\tclient.R().SetPathParams(map[string]string{\n//\t\t\"userId\": \"sample@sample.com\",\n//\t\t\"subAccountId\": \"100002\",\n//\t\t\"path\":         \"groups/developers\",\n//\t})\n//\n//\tResult:\n//\t   URL - /v1/users/{userId}/{subAccountId}/{path}/details\n//\t   Composed URL - /v1/users/sample@sample.com/100002/groups/developers/details\n//\n// It replaces the value of the key while composing the request URL.\n// The value will be used as-is and has not been escaped.\n//\n// It overrides the raw path parameter set at the client instance level.\nfunc (r *Request) SetRawPathParams(params map[string]string) *Request {\n\tfor p, v := range params {\n\t\tr.SetRawPathParam(p, v)\n\t}\n\treturn r\n}\n\n// ExpectContentType method allows to provide fallback `Content-Type` for automatic unmarshalling\n// when the `Content-Type` response header is unavailable.\nfunc (r *Request) ExpectContentType(contentType string) *Request {\n\tr.fallbackContentType = contentType\n\treturn r\n}\n\n// ForceContentType method provides a strong sense of response `Content-Type` for\n// automatic unmarshalling. Resty gives this a higher priority than the `Content-Type`\n// response header.\n//\n// This means that if both [Request.ForceContentType] is set and\n// the response `Content-Type` is available, `ForceContentType` will win.\nfunc (r *Request) ForceContentType(contentType string) *Request {\n\tr.forceContentType = contentType\n\treturn r\n}\n\n// SetJSONEscapeHTML method enables or disables the HTML escape on JSON marshal.\n// By default, escape HTML is false.\n//\n// NOTE: This option only applies to the standard JSON Marshaller used by Resty.\n//\n// It overrides the value set at the client instance level, see [Client.SetJSONEscapeHTML]\nfunc (r *Request) SetJSONEscapeHTML(b bool) *Request {\n\tr.jsonEscapeHTML = b\n\treturn r\n}\n\n// SetCookie method appends a single cookie in the current request instance.\n//\n//\tclient.R().SetCookie(&http.Cookie{\n//\t\t\t\tName:\"go-resty\",\n//\t\t\t\tValue:\"This is cookie value\",\n//\t\t\t})\n//\n// NOTE: Method appends the Cookie value into existing Cookie even if its already existing.\nfunc (r *Request) SetCookie(hc *http.Cookie) *Request {\n\tr.Cookies = append(r.Cookies, hc)\n\treturn r\n}\n\n// SetCookies method sets an array of cookies in the current request instance.\n//\n//\tcookies := []*http.Cookie{\n//\t\t&http.Cookie{\n//\t\t\tName:\"go-resty-1\",\n//\t\t\tValue:\"This is cookie 1 value\",\n//\t\t},\n//\t\t&http.Cookie{\n//\t\t\tName:\"go-resty-2\",\n//\t\t\tValue:\"This is cookie 2 value\",\n//\t\t},\n//\t}\n//\n//\t// Setting a cookies into resty's current request\n//\tclient.R().SetCookies(cookies)\n//\n// NOTE: Method appends the Cookie value into existing Cookie even if its already existing.\nfunc (r *Request) SetCookies(rs []*http.Cookie) *Request {\n\tr.Cookies = append(r.Cookies, rs...)\n\treturn r\n}\n\n// SetLogger method sets given writer for logging Resty request and response details.\n// By default, requests and responses inherit their logger from the client.\n//\n// Compliant to interface [resty.Logger].\n//\n// It overrides the logger value set at the client instance level.\nfunc (r *Request) SetLogger(l Logger) *Request {\n\tr.log = l\n\treturn r\n}\n\n// SetDebug method enables the debug mode on the current request. It logs\n// the details current request and response.\n//\n//\tclient.SetDebug(true)\n//\n// Also, it can be enabled at the request level for a particular request; see [Request.SetDebug].\n//   - For [Request], it logs information such as HTTP verb, Relative URL path,\n//     Host, Headers, and Body if it has one.\n//   - For [Response], it logs information such as Status, Response Time, Headers,\n//     and Body if it has one.\nfunc (r *Request) SetDebug(d bool) *Request {\n\tr.Debug = d\n\treturn r\n}\n\n// AddRetryCondition method adds a retry condition function to the request's\n// array of functions is checked to determine if the request can be retried.\n// The request will retry if any functions return true and the error is nil.\n//\n// NOTE: The request level retry conditions are checked before all retry\n// conditions from the client instance.\nfunc (r *Request) AddRetryCondition(condition RetryConditionFunc) *Request {\n\tr.retryConditions = append(r.retryConditions, condition)\n\treturn r\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// HTTP request tracing\n//_______________________________________________________________________\n\n// EnableTrace method enables trace for the current request\n// using [httptrace.ClientTrace] and provides insights.\n//\n//\tclient := resty.New()\n//\n//\tresp, err := client.R().EnableTrace().Get(\"https://httpbin.org/get\")\n//\tfmt.Println(\"Error:\", err)\n//\tfmt.Println(\"Trace Info:\", resp.Request.TraceInfo())\n//\n// See [Client.EnableTrace] is also available to get trace info for all requests.\nfunc (r *Request) EnableTrace() *Request {\n\tr.trace = true\n\treturn r\n}\n\n// EnableGenerateCurlOnDebug method enables the generation of CURL commands in the debug log.\n// It works in conjunction with debug mode. It overrides the options set by the [Client].\n//\n// NOTE: Use with care.\n//   - Potential to leak sensitive data from [Request] and [Response] in the debug log.\n//   - Beware of memory usage since the request body is reread.\nfunc (r *Request) EnableGenerateCurlOnDebug() *Request {\n\tr.generateCurlOnDebug = true\n\treturn r\n}\n\n// DisableGenerateCurlOnDebug method disables the option set by [Request.EnableGenerateCurlOnDebug].\n// It overrides the options set by the [Client].\nfunc (r *Request) DisableGenerateCurlOnDebug() *Request {\n\tr.generateCurlOnDebug = false\n\treturn r\n}\n\n// TraceInfo method returns the trace info for the request.\n// If either the [Client.EnableTrace] or [Request.EnableTrace] function has not been called\n// before the request is made, an empty [resty.TraceInfo] object is returned.\nfunc (r *Request) TraceInfo() TraceInfo {\n\tct := r.clientTrace\n\n\tif ct == nil {\n\t\treturn TraceInfo{}\n\t}\n\n\tti := TraceInfo{\n\t\tDNSLookup:      ct.dnsDone.Sub(ct.dnsStart),\n\t\tTLSHandshake:   ct.tlsHandshakeDone.Sub(ct.tlsHandshakeStart),\n\t\tServerTime:     ct.gotFirstResponseByte.Sub(ct.gotConn),\n\t\tIsConnReused:   ct.gotConnInfo.Reused,\n\t\tIsConnWasIdle:  ct.gotConnInfo.WasIdle,\n\t\tConnIdleTime:   ct.gotConnInfo.IdleTime,\n\t\tRequestAttempt: r.Attempt,\n\t}\n\n\t// Calculate the total time accordingly,\n\t// when connection is reused\n\tif ct.gotConnInfo.Reused {\n\t\tti.TotalTime = ct.endTime.Sub(ct.getConn)\n\t} else {\n\t\tti.TotalTime = ct.endTime.Sub(ct.dnsStart)\n\t}\n\n\t// Only calculate on successful connections\n\tif !ct.connectDone.IsZero() {\n\t\tti.TCPConnTime = ct.connectDone.Sub(ct.dnsDone)\n\t}\n\n\t// Only calculate on successful connections\n\tif !ct.gotConn.IsZero() {\n\t\tti.ConnTime = ct.gotConn.Sub(ct.getConn)\n\t}\n\n\t// Only calculate on successful connections\n\tif !ct.gotFirstResponseByte.IsZero() {\n\t\tti.ResponseTime = ct.endTime.Sub(ct.gotFirstResponseByte)\n\t}\n\n\t// Capture remote address info when connection is non-nil\n\tif ct.gotConnInfo.Conn != nil {\n\t\tti.RemoteAddr = ct.gotConnInfo.Conn.RemoteAddr()\n\t}\n\n\treturn ti\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// HTTP verb method starts here\n//_______________________________________________________________________\n\n// Get method does GET HTTP request. It's defined in section 4.3.1 of RFC7231.\nfunc (r *Request) Get(url string) (*Response, error) {\n\treturn r.Execute(MethodGet, url)\n}\n\n// Head method does HEAD HTTP request. It's defined in section 4.3.2 of RFC7231.\nfunc (r *Request) Head(url string) (*Response, error) {\n\treturn r.Execute(MethodHead, url)\n}\n\n// Post method does POST HTTP request. It's defined in section 4.3.3 of RFC7231.\nfunc (r *Request) Post(url string) (*Response, error) {\n\treturn r.Execute(MethodPost, url)\n}\n\n// Put method does PUT HTTP request. It's defined in section 4.3.4 of RFC7231.\nfunc (r *Request) Put(url string) (*Response, error) {\n\treturn r.Execute(MethodPut, url)\n}\n\n// Delete method does DELETE HTTP request. It's defined in section 4.3.5 of RFC7231.\nfunc (r *Request) Delete(url string) (*Response, error) {\n\treturn r.Execute(MethodDelete, url)\n}\n\n// Options method does OPTIONS HTTP request. It's defined in section 4.3.7 of RFC7231.\nfunc (r *Request) Options(url string) (*Response, error) {\n\treturn r.Execute(MethodOptions, url)\n}\n\n// Patch method does PATCH HTTP request. It's defined in section 2 of RFC5789.\nfunc (r *Request) Patch(url string) (*Response, error) {\n\treturn r.Execute(MethodPatch, url)\n}\n\n// Send method performs the HTTP request using the method and URL already defined\n// for current [Request].\n//\n//\treq := client.R()\n//\treq.Method = resty.MethodGet\n//\treq.URL = \"http://httpbin.org/get\"\n//\tresp, err := req.Send()\nfunc (r *Request) Send() (*Response, error) {\n\treturn r.Execute(r.Method, r.URL)\n}\n\n// Execute method performs the HTTP request with the given HTTP method and URL\n// for current [Request].\n//\n//\tresp, err := client.R().Execute(resty.MethodGet, \"http://httpbin.org/get\")\nfunc (r *Request) Execute(method, url string) (*Response, error) {\n\tvar addrs []*net.SRV\n\tvar resp *Response\n\tvar err error\n\n\tdefer func() {\n\t\tif rec := recover(); rec != nil {\n\t\t\tif err, ok := rec.(error); ok {\n\t\t\t\tr.client.onPanicHooks(r, err)\n\t\t\t} else {\n\t\t\t\tr.client.onPanicHooks(r, fmt.Errorf(\"panic %v\", rec))\n\t\t\t}\n\t\t\tpanic(rec)\n\t\t}\n\t}()\n\n\tif r.isMultiPart && !(method == MethodPost || method == MethodPut || method == MethodPatch) {\n\t\t// No OnError hook here since this is a request validation error\n\t\terr := fmt.Errorf(\"multipart content is not allowed in HTTP verb [%v]\", method)\n\t\tr.client.onInvalidHooks(r, err)\n\t\treturn nil, err\n\t}\n\n\tif r.SRV != nil {\n\t\t_, addrs, err = net.LookupSRV(r.SRV.Service, \"tcp\", r.SRV.Domain)\n\t\tif err != nil {\n\t\t\tr.client.onErrorHooks(r, nil, err)\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tr.Method = method\n\tr.URL = r.selectAddr(addrs, url, 0)\n\n\tif r.client.RetryCount == 0 {\n\t\tr.Attempt = 1\n\t\tresp, err = r.client.execute(r)\n\t\tr.client.onErrorHooks(r, resp, unwrapNoRetryErr(err))\n\t\tbackToBufPool(r.bodyBuf)\n\t\treturn resp, unwrapNoRetryErr(err)\n\t}\n\n\terr = Backoff(\n\t\tfunc() (*Response, error) {\n\t\t\tr.Attempt++\n\n\t\t\tr.URL = r.selectAddr(addrs, url, r.Attempt)\n\n\t\t\tresp, err = r.client.execute(r)\n\t\t\tif err != nil {\n\t\t\t\tr.log.Warnf(\"%v, Attempt %v\", err, r.Attempt)\n\t\t\t}\n\n\t\t\treturn resp, err\n\t\t},\n\t\tRetries(r.client.RetryCount),\n\t\tWaitTime(r.client.RetryWaitTime),\n\t\tMaxWaitTime(r.client.RetryMaxWaitTime),\n\t\tRetryConditions(append(r.retryConditions, r.client.RetryConditions...)),\n\t\tRetryHooks(r.client.RetryHooks),\n\t\tResetMultipartReaders(r.client.RetryResetReaders),\n\t)\n\n\tif err != nil {\n\t\tr.log.Errorf(\"%v\", err)\n\t}\n\n\tr.client.onErrorHooks(r, resp, unwrapNoRetryErr(err))\n\tbackToBufPool(r.bodyBuf)\n\treturn resp, unwrapNoRetryErr(err)\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// SRVRecord struct\n//_______________________________________________________________________\n\n// SRVRecord struct holds the data to query the SRV record for the\n// following service.\ntype SRVRecord struct {\n\tService string\n\tDomain  string\n}\n\nfunc (r *Request) fmtBodyString(sl int64) (body string) {\n\tbody = \"***** NO CONTENT *****\"\n\tif !isPayloadSupported(r.Method, r.client.AllowGetMethodPayload) {\n\t\treturn\n\t}\n\n\tif _, ok := r.Body.(io.Reader); ok {\n\t\tbody = \"***** BODY IS io.Reader *****\"\n\t\treturn\n\t}\n\n\t// multipart or form-data\n\tif r.isMultiPart || r.isFormData {\n\t\tbodySize := int64(r.bodyBuf.Len())\n\t\tif bodySize > sl {\n\t\t\tbody = fmt.Sprintf(\"***** REQUEST TOO LARGE (size - %d) *****\", bodySize)\n\t\t\treturn\n\t\t}\n\t\tbody = r.bodyBuf.String()\n\t\treturn\n\t}\n\n\t// request body data\n\tif r.Body == nil {\n\t\treturn\n\t}\n\tvar prtBodyBytes []byte\n\tvar err error\n\n\tcontentType := r.Header.Get(hdrContentTypeKey)\n\tkind := kindOf(r.Body)\n\tif canJSONMarshal(contentType, kind) {\n\t\tvar bodyBuf *bytes.Buffer\n\t\tbodyBuf, err = noescapeJSONMarshalIndent(&r.Body)\n\t\tif err == nil {\n\t\t\tprtBodyBytes = bodyBuf.Bytes()\n\t\t\tdefer releaseBuffer(bodyBuf)\n\t\t}\n\t} else if IsXMLType(contentType) && (kind == reflect.Struct) {\n\t\tprtBodyBytes, err = xml.MarshalIndent(&r.Body, \"\", \"   \")\n\t} else if b, ok := r.Body.(string); ok {\n\t\tif IsJSONType(contentType) {\n\t\t\tbodyBytes := []byte(b)\n\t\t\tout := acquireBuffer()\n\t\t\tdefer releaseBuffer(out)\n\t\t\tif err = json.Indent(out, bodyBytes, \"\", \"   \"); err == nil {\n\t\t\t\tprtBodyBytes = out.Bytes()\n\t\t\t}\n\t\t} else {\n\t\t\tbody = b\n\t\t}\n\t} else if b, ok := r.Body.([]byte); ok {\n\t\tbody = fmt.Sprintf(\"***** BODY IS byte(s) (size - %d) *****\", len(b))\n\t\treturn\n\t}\n\n\tif prtBodyBytes != nil && err == nil {\n\t\tbody = string(prtBodyBytes)\n\t}\n\n\tif len(body) > 0 {\n\t\tbodySize := int64(len([]byte(body)))\n\t\tif bodySize > sl {\n\t\t\tbody = fmt.Sprintf(\"***** REQUEST TOO LARGE (size - %d) *****\", bodySize)\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (r *Request) selectAddr(addrs []*net.SRV, path string, attempt int) string {\n\tif addrs == nil {\n\t\treturn path\n\t}\n\n\tidx := attempt % len(addrs)\n\tdomain := strings.TrimRight(addrs[idx].Target, \".\")\n\tpath = strings.TrimLeft(path, \"/\")\n\n\treturn fmt.Sprintf(\"%s://%s:%d/%s\", r.client.scheme, domain, addrs[idx].Port, path)\n}\n\nfunc (r *Request) initValuesMap() {\n\tif r.values == nil {\n\t\tr.values = make(map[string]interface{})\n\t}\n}\n\nvar noescapeJSONMarshal = func(v interface{}) (*bytes.Buffer, error) {\n\tbuf := acquireBuffer()\n\tencoder := json.NewEncoder(buf)\n\tencoder.SetEscapeHTML(false)\n\tif err := encoder.Encode(v); err != nil {\n\t\treleaseBuffer(buf)\n\t\treturn nil, err\n\t}\n\n\treturn buf, nil\n}\n\nvar noescapeJSONMarshalIndent = func(v interface{}) (*bytes.Buffer, error) {\n\tbuf := acquireBuffer()\n\tencoder := json.NewEncoder(buf)\n\tencoder.SetEscapeHTML(false)\n\tencoder.SetIndent(\"\", \"   \")\n\n\tif err := encoder.Encode(v); err != nil {\n\t\treleaseBuffer(buf)\n\t\treturn nil, err\n\t}\n\n\treturn buf, nil\n}\n"
        },
        {
          "name": "request_test.go",
          "type": "blob",
          "size": 58.7294921875,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/time/rate\"\n)\n\ntype AuthSuccess struct {\n\tID, Message string\n}\n\ntype AuthError struct {\n\tID, Message string\n}\n\nfunc TestGet(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().R().\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"HTTP/1.1\", resp.Proto())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestGetGH524(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().R().\n\t\tSetPathParams((map[string]string{\n\t\t\t\"userId\":       \"sample@sample.com\",\n\t\t\t\"subAccountId\": \"100002\",\n\t\t\t\"path\":         \"groups/developers\",\n\t\t})).\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tSetDebug(true).\n\t\tGet(ts.URL + \"/v1/users/{userId}/{subAccountId}/{path}/details\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, resp.Request.Header.Get(\"Content-Type\"), \"\") //  unable to reproduce reported issue\n}\n\nfunc TestRateLimiter(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\t// Test a burst with a valid capacity and then a consecutive request that must fail.\n\n\t// Allow a rate of 1 every 100 ms but also allow bursts of 10 requests.\n\tclient := dc().SetRateLimiter(rate.NewLimiter(rate.Every(100*time.Millisecond), 10))\n\n\t// Execute a burst of 10 requests.\n\tfor i := 0; i < 10; i++ {\n\t\tresp, err := client.R().\n\t\t\tSetQueryParam(\"request_no\", strconv.Itoa(i)).Get(ts.URL + \"/\")\n\t\tassertError(t, err)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\t}\n\t// Next request issued directly should fail because burst of 10 has been consumed.\n\t{\n\t\t_, err := client.R().\n\t\t\tSetQueryParam(\"request_no\", strconv.Itoa(11)).Get(ts.URL + \"/\")\n\t\tassertErrorIs(t, ErrRateLimitExceeded, err)\n\t}\n\n\t// Test continues request at a valid rate\n\n\t// Allow a rate of 1 every ms with no burst.\n\tclient = dc().SetRateLimiter(rate.NewLimiter(rate.Every(1*time.Millisecond), 1))\n\n\t// Sending requests every ms+tiny delta must succeed.\n\tfor i := 0; i < 100; i++ {\n\t\tresp, err := client.R().\n\t\t\tSetQueryParam(\"request_no\", strconv.Itoa(i)).Get(ts.URL + \"/\")\n\t\tassertError(t, err)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\t\ttime.Sleep(1*time.Millisecond + 100*time.Microsecond)\n\t}\n}\n\nfunc TestIllegalRetryCount(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().SetRetryCount(-1).R().Get(ts.URL + \"/\")\n\n\tassertNil(t, err)\n\tassertNil(t, resp)\n}\n\nfunc TestGetCustomUserAgent(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dcr().\n\t\tSetHeader(hdrUserAgentKey, \"Test Custom User agent\").\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"HTTP/1.1\", resp.Proto())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestGetClientParamRequestParam(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetQueryParam(\"client_param\", \"true\").\n\t\tSetQueryParams(map[string]string{\"req_1\": \"jeeva\", \"req_3\": \"jeeva3\"}).\n\t\tSetDebug(true)\n\tc.outputLogTo(io.Discard)\n\n\tresp, err := c.R().\n\t\tSetQueryParams(map[string]string{\"req_1\": \"req 1 value\", \"req_2\": \"req 2 value\"}).\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tSetHeader(hdrUserAgentKey, \"Test Custom User agent\").\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"HTTP/1.1\", resp.Proto())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestGetRelativePath(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetHostURL(ts.URL)\n\n\tresp, err := c.R().Get(\"mypage2\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"TestGet: text response from mypage2\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestGet400Error(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dcr().Get(ts.URL + \"/mypage\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusBadRequest, resp.StatusCode())\n\tassertEqual(t, \"\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONStringSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\tSetHeaders(map[string]string{hdrUserAgentKey: \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) go-resty v0.1\", hdrAcceptKey: \"application/json; charset=utf-8\"})\n\n\tresp, err := c.R().\n\t\tSetBody(`{\"username\":\"testuser\", \"password\":\"testpass\"}`).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tlogResponse(t, resp)\n\n\t// PostJSONStringError\n\tresp, err = c.R().\n\t\tSetBody(`{\"username\":\"testuser\" \"password\":\"testpass\"}`).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusBadRequest, resp.StatusCode())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONBytesSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\tSetHeaders(map[string]string{hdrUserAgentKey: \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) go-resty v0.7\", hdrAcceptKey: \"application/json; charset=utf-8\"})\n\n\tresp, err := c.R().\n\t\tSetBody([]byte(`{\"username\":\"testuser\", \"password\":\"testpass\"}`)).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONBytesIoReader(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\n\tbodyBytes := []byte(`{\"username\":\"testuser\", \"password\":\"testpass\"}`)\n\n\tresp, err := c.R().\n\t\tSetBody(bytes.NewReader(bodyBytes)).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONStructSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tuser := &User{Username: \"testuser\", Password: \"testpass\"}\n\n\tc := dc().SetJSONEscapeHTML(false)\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\tSetBody(user).\n\t\tSetResult(&AuthSuccess{}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONRPCStructSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tuser := &User{Username: \"testuser\", Password: \"testpass\"}\n\n\tc := dc().SetJSONEscapeHTML(false)\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/json-rpc\").\n\t\tSetBody(user).\n\t\tSetResult(&AuthSuccess{}).\n\t\tSetQueryParam(\"ct\", \"rpc\").\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONStructInvalidLogin(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetDebug(false)\n\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\tSetBody(User{Username: \"testuser\", Password: \"testpass1\"}).\n\t\tSetError(AuthError{}).\n\t\tSetJSONEscapeHTML(false).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusUnauthorized, resp.StatusCode())\n\n\tauthError := resp.Error().(*AuthError)\n\tassertEqual(t, \"unauthorized\", authError.ID)\n\tassertEqual(t, \"Invalid credentials\", authError.Message)\n\tt.Logf(\"Result Error: %q\", resp.Error().(*AuthError))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONErrorRFC7807(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\tSetBody(User{Username: \"testuser\", Password: \"testpass1\"}).\n\t\tSetError(AuthError{}).\n\t\tPost(ts.URL + \"/login?ct=problem\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusUnauthorized, resp.StatusCode())\n\n\tauthError := resp.Error().(*AuthError)\n\tassertEqual(t, \"unauthorized\", authError.ID)\n\tassertEqual(t, \"Invalid credentials\", authError.Message)\n\tt.Logf(\"Result Error: %q\", resp.Error().(*AuthError))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONMapSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetDebug(false)\n\n\tresp, err := c.R().\n\t\tSetBody(map[string]interface{}{\"username\": \"testuser\", \"password\": \"testpass\"}).\n\t\tSetResult(AuthSuccess{}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostJSONMapInvalidResponseJson(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetBody(map[string]interface{}{\"username\": \"testuser\", \"password\": \"invalidjson\"}).\n\t\tSetResult(&AuthSuccess{}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertEqual(t, \"invalid character '}' looking for beginning of object key string\", err.Error())\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tauthSuccess := resp.Result().(*AuthSuccess)\n\tassertEqual(t, \"\", authSuccess.ID)\n\tassertEqual(t, \"\", authSuccess.Message)\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\ntype brokenMarshalJSON struct{}\n\nfunc (b brokenMarshalJSON) MarshalJSON() ([]byte, error) {\n\treturn nil, errors.New(\"b0rk3d\")\n}\n\nfunc TestPostJSONMarshalError(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tb := brokenMarshalJSON{}\n\texp := \"b0rk3d\"\n\n\t_, err := dclr().\n\t\tSetHeader(hdrContentTypeKey, \"application/json\").\n\t\tSetBody(b).\n\t\tPost(ts.URL + \"/login\")\n\tif err == nil {\n\t\tt.Fatalf(\"expected error but got %v\", err)\n\t}\n\n\tif !strings.Contains(err.Error(), exp) {\n\t\tt.Errorf(\"expected error string %q to contain %q\", err, exp)\n\t}\n}\n\nfunc TestForceContentTypeForGH276andGH240(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tretried := 0\n\tc := dc()\n\tc.SetDebug(false)\n\tc.SetRetryCount(3)\n\tc.SetRetryAfter(RetryAfterFunc(func(*Client, *Response) (time.Duration, error) {\n\t\tretried++\n\t\treturn 0, nil\n\t}))\n\n\tresp, err := c.R().\n\t\tSetBody(map[string]interface{}{\"username\": \"testuser\", \"password\": \"testpass\"}).\n\t\tSetResult(AuthSuccess{}).\n\t\tForceContentType(\"application/json\").\n\t\tPost(ts.URL + \"/login-json-html\")\n\n\tassertNotNil(t, err) // expecting error due to incorrect content type from server end\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, 0, retried)\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostXMLStringSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetDebug(false)\n\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><User><Username>testuser</Username><Password>testpass</Password></User>`).\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tlogResponse(t, resp)\n}\n\ntype brokenMarshalXML struct{}\n\nfunc (b brokenMarshalXML) MarshalXML(e *xml.Encoder, start xml.StartElement) error {\n\treturn errors.New(\"b0rk3d\")\n}\n\nfunc TestPostXMLMarshalError(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tb := brokenMarshalXML{}\n\texp := \"b0rk3d\"\n\n\t_, err := dclr().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody(b).\n\t\tPost(ts.URL + \"/login\")\n\tif err == nil {\n\t\tt.Fatalf(\"expected error but got %v\", err)\n\t}\n\n\tif !strings.Contains(err.Error(), exp) {\n\t\tt.Errorf(\"expected error string %q to contain %q\", err, exp)\n\t}\n}\n\nfunc TestPostXMLStringError(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><User><Username>testuser</Username>testpass</Password></User>`).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusBadRequest, resp.StatusCode())\n\tassertEqual(t, `<?xml version=\"1.0\" encoding=\"UTF-8\"?><AuthError><Id>bad_request</Id><Message>Unable to read user info</Message></AuthError>`, resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostXMLBytesSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetDebug(false)\n\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody([]byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><User><Username>testuser</Username><Password>testpass</Password></User>`)).\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tSetContentLength(true).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostXMLStructSuccess(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody(User{Username: \"testuser\", Password: \"testpass\"}).\n\t\tSetContentLength(true).\n\t\tSetResult(&AuthSuccess{}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostXMLStructInvalidLogin(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetError(&AuthError{})\n\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody(User{Username: \"testuser\", Password: \"testpass1\"}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusUnauthorized, resp.StatusCode())\n\tassertEqual(t, resp.Header().Get(\"Www-Authenticate\"), \"Protected Realm\")\n\n\tt.Logf(\"Result Error: %q\", resp.Error().(*AuthError))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostXMLStructInvalidResponseXml(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody(User{Username: \"testuser\", Password: \"invalidxml\"}).\n\t\tSetResult(&AuthSuccess{}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertEqual(t, \"XML syntax error on line 1: element <Message> closed by </AuthSuccess>\", err.Error())\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPostXMLMapNotSupported(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\t_, err := dclr().\n\t\tSetHeader(hdrContentTypeKey, \"application/xml\").\n\t\tSetBody(map[string]interface{}{\"Username\": \"testuser\", \"Password\": \"testpass\"}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertEqual(t, \"unsupported 'Body' type/value\", err.Error())\n}\n\nfunc TestRequestBasicAuth(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetHostURL(ts.URL).\n\t\tSetTLSClientConfig(&tls.Config{InsecureSkipVerify: true})\n\n\tresp, err := c.R().\n\t\tSetBasicAuth(\"myuser\", \"basicauth\").\n\t\tSetResult(&AuthSuccess{}).\n\t\tPost(\"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\tlogResponse(t, resp)\n}\n\nfunc TestRequestInsecureBasicAuth(t *testing.T) {\n\tts := createAuthServerTLSOptional(t, false)\n\tdefer ts.Close()\n\n\tvar logBuf bytes.Buffer\n\tlogger := createLogger()\n\tlogger.l.SetOutput(&logBuf)\n\n\tc := dc()\n\tc.SetHostURL(ts.URL)\n\n\tresp, err := c.R().\n\t\tSetBasicAuth(\"myuser\", \"basicauth\").\n\t\tSetResult(&AuthSuccess{}).\n\t\tSetLogger(logger).\n\t\tPost(\"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(logBuf.String(), \"WARN RESTY Using Basic Auth in HTTP mode is not secure, use HTTPS\"))\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\tlogResponse(t, resp)\n\tt.Logf(\"captured request-level logs: %s\", logBuf.String())\n}\n\nfunc TestRequestBasicAuthFail(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\tSetError(AuthError{})\n\n\tresp, err := c.R().\n\t\tSetBasicAuth(\"myuser\", \"basicauth1\").\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusUnauthorized, resp.StatusCode())\n\n\tt.Logf(\"Result Error: %q\", resp.Error().(*AuthError))\n\tlogResponse(t, resp)\n}\n\nfunc TestRequestAuthToken(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF\")\n\n\tresp, err := c.R().\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF-Request\").\n\t\tGet(ts.URL + \"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestRequestAuthScheme(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\tSetAuthScheme(\"OAuth\").\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF\")\n\n\tresp, err := c.R().\n\t\tSetAuthScheme(\"Bearer\").\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF-Request\").\n\t\tGet(ts.URL + \"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestRequestDigestAuth(t *testing.T) {\n\tconf := defaultDigestServerConf()\n\tts := createDigestServer(t, nil)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetDigestAuth(conf.username, conf.password).\n\t\tSetResult(&AuthSuccess{}).\n\t\tGet(ts.URL + conf.uri)\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\tlogResponse(t, resp)\n}\n\nfunc TestRequestDigestAuthFail(t *testing.T) {\n\tconf := defaultDigestServerConf()\n\tts := createDigestServer(t, nil)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetDigestAuth(conf.username, \"wrongPassword\").\n\t\tSetError(AuthError{}).\n\t\tGet(ts.URL + conf.uri)\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusUnauthorized, resp.StatusCode())\n\n\tt.Logf(\"Result Error: %q\", resp.Error().(*AuthError))\n\tlogResponse(t, resp)\n}\n\nfunc TestRequestDigestAuthWithBody(t *testing.T) {\n\tconf := defaultDigestServerConf()\n\tts := createDigestServer(t, nil)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetDigestAuth(conf.username, conf.password).\n\t\tSetResult(&AuthSuccess{}).\n\t\tSetHeader(hdrContentTypeKey, \"application/json\").\n\t\tSetBody(map[string]interface{}{\"zip_code\": \"00000\", \"city\": \"Los Angeles\"}).\n\t\tPost(ts.URL + conf.uri)\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\tlogResponse(t, resp)\n}\n\nfunc TestFormData(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetFormData(map[string]string{\"zip_code\": \"00000\", \"city\": \"Los Angeles\"}).\n\t\tSetContentLength(true).\n\t\tSetDebug(true)\n\tc.outputLogTo(io.Discard)\n\n\tresp, err := c.R().\n\t\tSetFormData(map[string]string{\"first_name\": \"Jeevanandam\", \"last_name\": \"M\", \"zip_code\": \"00001\"}).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(ts.URL + \"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"Success\", resp.String())\n}\n\nfunc TestMultiValueFormData(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\n\tv := url.Values{\n\t\t\"search_criteria\": []string{\"book\", \"glass\", \"pencil\"},\n\t}\n\n\tc := dc()\n\tc.SetContentLength(true).SetDebug(true)\n\tc.outputLogTo(io.Discard)\n\n\tresp, err := c.R().\n\t\tSetQueryParamsFromValues(v).\n\t\tPost(ts.URL + \"/search\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"Success\", resp.String())\n}\n\nfunc TestFormDataDisableWarn(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetFormData(map[string]string{\"zip_code\": \"00000\", \"city\": \"Los Angeles\"}).\n\t\tSetContentLength(true).\n\t\tSetDisableWarn(true)\n\tc.outputLogTo(io.Discard)\n\n\tresp, err := c.R().\n\t\tSetDebug(true).\n\t\tSetFormData(map[string]string{\"first_name\": \"Jeevanandam\", \"last_name\": \"M\", \"zip_code\": \"00001\"}).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(ts.URL + \"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"Success\", resp.String())\n}\n\nfunc TestMultiPartUploadFile(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tbasePath := getTestDataPath()\n\n\tc := dc()\n\tc.SetFormData(map[string]string{\"zip_code\": \"00001\", \"city\": \"Los Angeles\"})\n\n\tresp, err := c.R().\n\t\tSetFile(\"profile_img\", filepath.Join(basePath, \"test-img.png\")).\n\t\tSetContentLength(true).\n\t\tPost(ts.URL + \"/upload\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestMultiPartUploadFileViaPatch(t *testing.T) {\n\tts := createFormPatchServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tbasePath := getTestDataPath()\n\n\tc := dc()\n\tc.SetFormData(map[string]string{\"zip_code\": \"00001\", \"city\": \"Los Angeles\"})\n\n\tresp, err := c.R().\n\t\tSetFile(\"profile_img\", filepath.Join(basePath, \"test-img.png\")).\n\t\tSetContentLength(true).\n\t\tPatch(ts.URL + \"/upload\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestMultiPartUploadFileError(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tbasePath := getTestDataPath()\n\n\tc := dc()\n\tc.SetFormData(map[string]string{\"zip_code\": \"00001\", \"city\": \"Los Angeles\"})\n\n\tresp, err := c.R().\n\t\tSetFile(\"profile_img\", filepath.Join(basePath, \"test-img-not-exists.png\")).\n\t\tPost(ts.URL + \"/upload\")\n\n\tif err == nil {\n\t\tt.Errorf(\"Expected [%v], got [%v]\", nil, err)\n\t}\n\tif resp != nil {\n\t\tt.Errorf(\"Expected [%v], got [%v]\", nil, resp)\n\t}\n}\n\nfunc TestMultiPartUploadFiles(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tbasePath := getTestDataPath()\n\n\tresp, err := dclr().\n\t\tSetFormDataFromValues(url.Values{\n\t\t\t\"first_name\": []string{\"Jeevanandam\"},\n\t\t\t\"last_name\":  []string{\"M\"},\n\t\t}).\n\t\tSetFiles(map[string]string{\"profile_img\": filepath.Join(basePath, \"test-img.png\"), \"notes\": filepath.Join(basePath, \"text-file.txt\")}).\n\t\tPost(ts.URL + \"/upload\")\n\n\tresponseStr := resp.String()\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(responseStr, \"test-img.png\"))\n\tassertEqual(t, true, strings.Contains(responseStr, \"text-file.txt\"))\n}\n\nfunc TestMultiPartIoReaderFiles(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tbasePath := getTestDataPath()\n\tprofileImgBytes, _ := os.ReadFile(filepath.Join(basePath, \"test-img.png\"))\n\tnotesBytes, _ := os.ReadFile(filepath.Join(basePath, \"text-file.txt\"))\n\n\t// Just info values\n\tfile := File{\n\t\tName:      \"test_file_name.jpg\",\n\t\tParamName: \"test_param\",\n\t\tReader:    bytes.NewBuffer([]byte(\"test bytes\")),\n\t}\n\tt.Logf(\"File Info: %v\", file.String())\n\n\tresp, err := dclr().\n\t\tSetFormData(map[string]string{\"first_name\": \"Jeevanandam\", \"last_name\": \"M\"}).\n\t\tSetFileReader(\"profile_img\", \"test-img.png\", bytes.NewReader(profileImgBytes)).\n\t\tSetFileReader(\"notes\", \"text-file.txt\", bytes.NewReader(notesBytes)).\n\t\tPost(ts.URL + \"/upload\")\n\n\tresponseStr := resp.String()\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(responseStr, \"test-img.png\"))\n\tassertEqual(t, true, strings.Contains(responseStr, \"text-file.txt\"))\n}\n\nfunc TestMultiPartUploadFileNotOnGetOrDelete(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tbasePath := getTestDataPath()\n\n\t_, err := dclr().\n\t\tSetFile(\"profile_img\", filepath.Join(basePath, \"test-img.png\")).\n\t\tGet(ts.URL + \"/upload\")\n\n\tassertEqual(t, \"multipart content is not allowed in HTTP verb [GET]\", err.Error())\n\n\t_, err = dclr().\n\t\tSetFile(\"profile_img\", filepath.Join(basePath, \"test-img.png\")).\n\t\tDelete(ts.URL + \"/upload\")\n\n\tassertEqual(t, \"multipart content is not allowed in HTTP verb [DELETE]\", err.Error())\n\n\tvar hook1Count int\n\tvar hook2Count int\n\t_, err = dc().\n\t\tOnInvalid(func(r *Request, err error) {\n\t\t\tassertEqual(t, \"multipart content is not allowed in HTTP verb [HEAD]\", err.Error())\n\t\t\tassertNotNil(t, r)\n\t\t\thook1Count++\n\t\t}).\n\t\tOnInvalid(func(r *Request, err error) {\n\t\t\tassertEqual(t, \"multipart content is not allowed in HTTP verb [HEAD]\", err.Error())\n\t\t\tassertNotNil(t, r)\n\t\t\thook2Count++\n\t\t}).\n\t\tR().\n\t\tSetFile(\"profile_img\", filepath.Join(basePath, \"test-img.png\")).\n\t\tHead(ts.URL + \"/upload\")\n\n\tassertEqual(t, \"multipart content is not allowed in HTTP verb [HEAD]\", err.Error())\n\tassertEqual(t, 1, hook1Count)\n\tassertEqual(t, 1, hook2Count)\n}\n\nfunc TestMultiPartFormData(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tresp, err := dclr().\n\t\tSetMultipartFormData(map[string]string{\"first_name\": \"Jeevanandam\", \"last_name\": \"M\", \"zip_code\": \"00001\"}).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(ts.URL + \"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"Success\", resp.String())\n}\n\nfunc TestMultiPartMultipartField(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tjsonBytes := []byte(`{\"input\": {\"name\": \"Uploaded document\", \"_filename\" : [\"file.txt\"]}}`)\n\n\tresp, err := dclr().\n\t\tSetFormDataFromValues(url.Values{\n\t\t\t\"first_name\": []string{\"Jeevanandam\"},\n\t\t\t\"last_name\":  []string{\"M\"},\n\t\t}).\n\t\tSetMultipartField(\"uploadManifest\", \"upload-file.json\", \"application/json\", bytes.NewReader(jsonBytes)).\n\t\tPost(ts.URL + \"/upload\")\n\n\tresponseStr := resp.String()\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(responseStr, \"upload-file.json\"))\n}\n\nfunc TestMultiPartMultipartFields(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\tjsonStr1 := `{\"input\": {\"name\": \"Uploaded document 1\", \"_filename\" : [\"file1.txt\"]}}`\n\tjsonStr2 := `{\"input\": {\"name\": \"Uploaded document 2\", \"_filename\" : [\"file2.txt\"]}}`\n\n\tfields := []*MultipartField{\n\t\t{\n\t\t\tParam:       \"uploadManifest1\",\n\t\t\tFileName:    \"upload-file-1.json\",\n\t\t\tContentType: \"application/json\",\n\t\t\tReader:      strings.NewReader(jsonStr1),\n\t\t},\n\t\t{\n\t\t\tParam:       \"uploadManifest2\",\n\t\t\tFileName:    \"upload-file-2.json\",\n\t\t\tContentType: \"application/json\",\n\t\t\tReader:      strings.NewReader(jsonStr2),\n\t\t},\n\t\t{\n\t\t\tParam:       \"uploadManifest3\",\n\t\t\tContentType: \"application/json\",\n\t\t\tReader:      strings.NewReader(jsonStr2),\n\t\t},\n\t}\n\n\tresp, err := dclr().\n\t\tSetFormData(map[string]string{\"first_name\": \"Jeevanandam\", \"last_name\": \"M\"}).\n\t\tSetMultipartFields(fields...).\n\t\tPost(ts.URL + \"/upload\")\n\n\tresponseStr := resp.String()\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(responseStr, \"upload-file-1.json\"))\n\tassertEqual(t, true, strings.Contains(responseStr, \"upload-file-2.json\"))\n}\n\nfunc TestMultiPartCustomBoundary(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/upload\")\n\n\t_, err := dclr().\n\t\tSetMultipartFormData(map[string]string{\"first_name\": \"Jeevanandam\", \"last_name\": \"M\", \"zip_code\": \"00001\"}).\n\t\tSetMultipartBoundary(`\"my-custom-boundary\"`).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(ts.URL + \"/profile\")\n\n\tassertEqual(t, \"mime: invalid boundary character\", err.Error())\n\n\tresp, err := dclr().\n\t\tSetMultipartFormData(map[string]string{\"first_name\": \"Jeevanandam\", \"last_name\": \"M\", \"zip_code\": \"00001\"}).\n\t\tSetMultipartBoundary(\"my-custom-boundary\").\n\t\tPost(ts.URL + \"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"Success\", resp.String())\n}\n\nfunc TestGetWithCookie(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dcl()\n\tc.SetHostURL(ts.URL)\n\tc.SetCookie(&http.Cookie{\n\t\tName:  \"go-resty-1\",\n\t\tValue: \"This is cookie 1 value\",\n\t})\n\n\tresp, err := c.R().\n\t\tSetCookie(&http.Cookie{\n\t\t\tName:  \"go-resty-2\",\n\t\t\tValue: \"This is cookie 2 value\",\n\t\t}).\n\t\tSetCookies([]*http.Cookie{\n\t\t\t{\n\t\t\t\tName:  \"go-resty-1\",\n\t\t\t\tValue: \"This is cookie 1 value additional append\",\n\t\t\t},\n\t\t}).\n\t\tGet(\"mypage2\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"TestGet: text response from mypage2\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestGetWithCookies(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetHostURL(ts.URL).SetDebug(true)\n\n\ttu, _ := url.Parse(ts.URL)\n\tc.GetClient().Jar.SetCookies(tu, []*http.Cookie{\n\t\t{\n\t\t\tName:  \"jar-go-resty-1\",\n\t\t\tValue: \"From Jar - This is cookie 1 value\",\n\t\t},\n\t\t{\n\t\t\tName:  \"jar-go-resty-2\",\n\t\t\tValue: \"From Jar - This is cookie 2 value\",\n\t\t},\n\t})\n\n\tresp, err := c.R().SetHeader(\"Cookie\", \"\").Get(\"mypage2\")\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\t// Client cookies\n\tc.SetCookies([]*http.Cookie{\n\t\t{\n\t\t\tName:  \"go-resty-1\",\n\t\t\tValue: \"This is cookie 1 value\",\n\t\t},\n\t\t{\n\t\t\tName:  \"go-resty-2\",\n\t\t\tValue: \"This is cookie 2 value\",\n\t\t},\n\t})\n\n\tresp, err = c.R().\n\t\tSetCookie(&http.Cookie{\n\t\t\tName:  \"req-go-resty-1\",\n\t\t\tValue: \"This is request cookie 1 value additional append\",\n\t\t}).\n\t\tGet(\"mypage2\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"TestGet: text response from mypage2\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPutPlainString(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().R().\n\t\tSetBody(\"This is plain text body to server\").\n\t\tPut(ts.URL + \"/plaintext\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"TestPut: plain text response\", resp.String())\n}\n\nfunc TestPutJSONString(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tclient := dc()\n\n\tclient.OnBeforeRequest(func(c *Client, r *Request) error {\n\t\tr.SetHeader(\"X-Custom-Request-Middleware\", \"OnBeforeRequest middleware\")\n\t\treturn nil\n\t})\n\tclient.OnBeforeRequest(func(c *Client, r *Request) error {\n\t\tc.SetContentLength(true)\n\t\tr.SetHeader(\"X-ContentLength\", \"OnBeforeRequest ContentLength set\")\n\t\treturn nil\n\t})\n\n\tclient.SetDebug(true)\n\tclient.outputLogTo(io.Discard)\n\n\tresp, err := client.R().\n\t\tSetHeaders(map[string]string{hdrContentTypeKey: \"application/json; charset=utf-8\", hdrAcceptKey: \"application/json; charset=utf-8\"}).\n\t\tSetBody(`{\"content\":\"json content sending to server\"}`).\n\t\tPut(ts.URL + \"/json\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, `{\"response\":\"json response\"}`, resp.String())\n}\n\nfunc TestPutXMLString(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().R().\n\t\tSetHeaders(map[string]string{hdrContentTypeKey: \"application/xml\", hdrAcceptKey: \"application/xml\"}).\n\t\tSetBody(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><Request>XML Content sending to server</Request>`).\n\t\tPut(ts.URL + \"/xml\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, `<?xml version=\"1.0\" encoding=\"UTF-8\"?><Response>XML response</Response>`, resp.String())\n}\n\nfunc TestOnBeforeMiddleware(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.OnBeforeRequest(func(c *Client, r *Request) error {\n\t\tr.SetHeader(\"X-Custom-Request-Middleware\", \"OnBeforeRequest middleware\")\n\t\treturn nil\n\t})\n\tc.OnBeforeRequest(func(c *Client, r *Request) error {\n\t\tc.SetContentLength(true)\n\t\tr.SetHeader(\"X-ContentLength\", \"OnBeforeRequest ContentLength set\")\n\t\treturn nil\n\t})\n\n\tresp, err := c.R().\n\t\tSetBody(\"OnBeforeRequest: This is plain text body to server\").\n\t\tPut(ts.URL + \"/plaintext\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"TestPut: plain text response\", resp.String())\n}\n\nfunc TestHTTPAutoRedirectUpTo10(t *testing.T) {\n\tts := createRedirectServer(t)\n\tdefer ts.Close()\n\n\t_, err := dc().R().Get(ts.URL + \"/redirect-1\")\n\n\tassertEqual(t, true, (err.Error() == \"Get /redirect-11: stopped after 10 redirects\" ||\n\t\terr.Error() == \"Get \\\"/redirect-11\\\": stopped after 10 redirects\"))\n}\n\nfunc TestHostCheckRedirectPolicy(t *testing.T) {\n\tts := createRedirectServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetRedirectPolicy(DomainCheckRedirectPolicy(\"127.0.0.1\"))\n\n\t_, err := c.R().Get(ts.URL + \"/redirect-host-check-1\")\n\n\tassertNotNil(t, err)\n\tassertEqual(t, true, strings.Contains(err.Error(), \"redirect is not allowed as per DomainCheckRedirectPolicy\"))\n}\n\nfunc TestHeadMethod(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().Head(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestOptionsMethod(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().Options(ts.URL + \"/options\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, resp.Header().Get(\"Access-Control-Expose-Headers\"), \"x-go-resty-id\")\n}\n\nfunc TestPatchMethod(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().Patch(ts.URL + \"/patch\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tresp.SetBody(nil)\n\tassertEqual(t, \"\", resp.String())\n}\n\nfunc TestSendMethod(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tt.Run(\"send-get\", func(t *testing.T) {\n\t\treq := dclr()\n\t\treq.Method = http.MethodGet\n\t\treq.URL = ts.URL + \"/gzip-test\"\n\n\t\tresp, err := req.Send()\n\n\t\tassertError(t, err)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\t\tassertEqual(t, \"This is Gzip response testing\", resp.String())\n\t})\n\n\tt.Run(\"send-options\", func(t *testing.T) {\n\t\treq := dclr()\n\t\treq.Method = http.MethodOptions\n\t\treq.URL = ts.URL + \"/options\"\n\n\t\tresp, err := req.Send()\n\n\t\tassertError(t, err)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\t\tassertEqual(t, \"\", resp.String())\n\t\tassertEqual(t, \"x-go-resty-id\", resp.Header().Get(\"Access-Control-Expose-Headers\"))\n\t})\n\n\tt.Run(\"send-patch\", func(t *testing.T) {\n\t\treq := dclr()\n\t\treq.Method = http.MethodPatch\n\t\treq.URL = ts.URL + \"/patch\"\n\n\t\tresp, err := req.Send()\n\n\t\tassertError(t, err)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\t\tassertEqual(t, \"\", resp.String())\n\t})\n\n\tt.Run(\"send-put\", func(t *testing.T) {\n\t\treq := dclr()\n\t\treq.Method = http.MethodPut\n\t\treq.URL = ts.URL + \"/plaintext\"\n\n\t\tresp, err := req.Send()\n\n\t\tassertError(t, err)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\t\tassertEqual(t, \"TestPut: plain text response\", resp.String())\n\t})\n}\n\nfunc TestRawFileUploadByBody(t *testing.T) {\n\tts := createFormPostServer(t)\n\tdefer ts.Close()\n\n\tfileBytes, err := os.ReadFile(filepath.Join(getTestDataPath(), \"test-img.png\"))\n\tassertNil(t, err)\n\n\tresp, err := dclr().\n\t\tSetBody(fileBytes).\n\t\tSetContentLength(true).\n\t\tSetAuthToken(\"004DDB79-6801-4587-B976-F093E6AC44FF\").\n\t\tPut(ts.URL + \"/raw-upload\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"image/png\", resp.Request.Header.Get(hdrContentTypeKey))\n}\n\nfunc TestProxySetting(t *testing.T) {\n\tc := dc()\n\n\ttransport, err := c.Transport()\n\n\tassertNil(t, err)\n\n\tassertEqual(t, false, c.IsProxySet())\n\tassertNotNil(t, transport.Proxy)\n\n\tc.SetProxy(\"http://sampleproxy:8888\")\n\tassertEqual(t, true, c.IsProxySet())\n\tassertNotNil(t, transport.Proxy)\n\n\tc.SetProxy(\"//not.a.user@%66%6f%6f.com:8888\")\n\tassertEqual(t, true, c.IsProxySet())\n\tassertNotNil(t, transport.Proxy)\n\n\tc.SetProxy(\"http://sampleproxy:8888\")\n\tassertEqual(t, true, c.IsProxySet())\n\tc.RemoveProxy()\n\tassertNil(t, c.proxyURL)\n\tassertNil(t, transport.Proxy)\n}\n\nfunc TestGetClient(t *testing.T) {\n\tclient := New()\n\tcustom := New()\n\tcustomClient := custom.GetClient()\n\n\tassertNotNil(t, customClient)\n\tassertNotEqual(t, client, http.DefaultClient)\n\tassertNotEqual(t, customClient, http.DefaultClient)\n\tassertNotEqual(t, client, customClient)\n}\n\nfunc TestIncorrectURL(t *testing.T) {\n\tc := dc()\n\t_, err := c.R().Get(\"//not.a.user@%66%6f%6f.com/just/a/path/also\")\n\tassertEqual(t, true, (strings.Contains(err.Error(), \"parse //not.a.user@%66%6f%6f.com/just/a/path/also\") ||\n\t\tstrings.Contains(err.Error(), \"parse \\\"//not.a.user@%66%6f%6f.com/just/a/path/also\\\"\")))\n\n\tc.SetHostURL(\"//not.a.user@%66%6f%6f.com\")\n\t_, err1 := c.R().Get(\"/just/a/path/also\")\n\tassertEqual(t, true, (strings.Contains(err1.Error(), \"parse //not.a.user@%66%6f%6f.com/just/a/path/also\") ||\n\t\tstrings.Contains(err1.Error(), \"parse \\\"//not.a.user@%66%6f%6f.com/just/a/path/also\\\"\")))\n}\n\nfunc TestDetectContentTypeForPointer(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tuser := &User{Username: \"testuser\", Password: \"testpass\"}\n\n\tresp, err := dclr().\n\t\tSetBody(user).\n\t\tSetResult(AuthSuccess{}).\n\t\tPost(ts.URL + \"/login\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp.Result().(*AuthSuccess))\n\n\tlogResponse(t, resp)\n}\n\ntype ExampleUser struct {\n\tFirstName string `json:\"first_name\"`\n\tLastName  string `json:\"last_name\"`\n\tZipCode   string `json:\"zip_code\"`\n}\n\nfunc TestDetectContentTypeForPointerWithSlice(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tusers := &[]ExampleUser{\n\t\t{FirstName: \"firstname1\", LastName: \"lastname1\", ZipCode: \"10001\"},\n\t\t{FirstName: \"firstname2\", LastName: \"lastname3\", ZipCode: \"10002\"},\n\t\t{FirstName: \"firstname3\", LastName: \"lastname3\", ZipCode: \"10003\"},\n\t}\n\n\tresp, err := dclr().\n\t\tSetBody(users).\n\t\tPost(ts.URL + \"/users\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusAccepted, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp)\n\n\tlogResponse(t, resp)\n}\n\nfunc TestDetectContentTypeForPointerWithSliceMap(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tusersmap := map[string]interface{}{\n\t\t\"user1\": ExampleUser{FirstName: \"firstname1\", LastName: \"lastname1\", ZipCode: \"10001\"},\n\t\t\"user2\": &ExampleUser{FirstName: \"firstname2\", LastName: \"lastname3\", ZipCode: \"10002\"},\n\t\t\"user3\": ExampleUser{FirstName: \"firstname3\", LastName: \"lastname3\", ZipCode: \"10003\"},\n\t}\n\n\tvar users []map[string]interface{}\n\tusers = append(users, usersmap)\n\n\tresp, err := dclr().\n\t\tSetBody(&users).\n\t\tPost(ts.URL + \"/usersmap\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusAccepted, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp)\n\n\tlogResponse(t, resp)\n}\n\nfunc TestDetectContentTypeForSlice(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tusers := []ExampleUser{\n\t\t{FirstName: \"firstname1\", LastName: \"lastname1\", ZipCode: \"10001\"},\n\t\t{FirstName: \"firstname2\", LastName: \"lastname3\", ZipCode: \"10002\"},\n\t\t{FirstName: \"firstname3\", LastName: \"lastname3\", ZipCode: \"10003\"},\n\t}\n\n\tresp, err := dclr().\n\t\tSetBody(users).\n\t\tPost(ts.URL + \"/users\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusAccepted, resp.StatusCode())\n\n\tt.Logf(\"Result Success: %q\", resp)\n\n\tlogResponse(t, resp)\n}\n\nfunc TestMultiParamsQueryString(t *testing.T) {\n\tts1 := createGetServer(t)\n\tdefer ts1.Close()\n\n\tclient := dc()\n\treq1 := client.R()\n\n\tclient.SetQueryParam(\"status\", \"open\")\n\n\t_, _ = req1.SetQueryParam(\"status\", \"pending\").\n\t\tGet(ts1.URL)\n\n\tassertEqual(t, true, strings.Contains(req1.URL, \"status=pending\"))\n\t// pending overrides open\n\tassertEqual(t, false, strings.Contains(req1.URL, \"status=open\"))\n\n\t_, _ = req1.SetQueryParam(\"status\", \"approved\").\n\t\tGet(ts1.URL)\n\n\tassertEqual(t, true, strings.Contains(req1.URL, \"status=approved\"))\n\t// approved overrides pending\n\tassertEqual(t, false, strings.Contains(req1.URL, \"status=pending\"))\n\n\tts2 := createGetServer(t)\n\tdefer ts2.Close()\n\n\treq2 := client.R()\n\n\tv := url.Values{\n\t\t\"status\": []string{\"pending\", \"approved\", \"reject\"},\n\t}\n\n\t_, _ = req2.SetQueryParamsFromValues(v).Get(ts2.URL)\n\n\tassertEqual(t, true, strings.Contains(req2.URL, \"status=pending\"))\n\tassertEqual(t, true, strings.Contains(req2.URL, \"status=approved\"))\n\tassertEqual(t, true, strings.Contains(req2.URL, \"status=reject\"))\n\n\t// because it's removed by key\n\tassertEqual(t, false, strings.Contains(req2.URL, \"status=open\"))\n}\n\nfunc TestSetQueryStringTypical(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dclr().\n\t\tSetQueryString(\"productId=232&template=fresh-sample&cat=resty&source=google&kw=buy a lot more\").\n\t\tGet(ts.URL)\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\n\tresp, err = dclr().\n\t\tSetQueryString(\"&%%amp;\").\n\t\tGet(ts.URL)\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n}\n\nfunc TestSetHeaderVerbatim(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tr := dclr().\n\t\tSetHeaderVerbatim(\"header-lowercase\", \"value_lowercase\").\n\t\tSetHeader(\"header-lowercase\", \"value_standard\")\n\n\t//lint:ignore SA1008 valid one ignore this!\n\tassertEqual(t, \"value_lowercase\", strings.Join(r.Header[\"header-lowercase\"], \"\"))\n\tassertEqual(t, \"value_standard\", r.Header.Get(\"Header-Lowercase\"))\n}\n\nfunc TestSetHeaderMultipleValue(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tr := dclr().\n\t\tSetHeaderMultiValues(map[string][]string{\n\t\t\t\"Content\":       {\"text/*\", \"text/html\", \"*\"},\n\t\t\t\"Authorization\": {\"Bearer xyz\"},\n\t\t})\n\tassertEqual(t, \"text/*, text/html, *\", r.Header.Get(\"content\"))\n\tassertEqual(t, \"Bearer xyz\", r.Header.Get(\"authorization\"))\n}\n\nfunc TestOutputFileWithBaseDirAndRelativePath(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(\".testdata/dir-sample\")\n\n\tclient := dc().\n\t\tSetRedirectPolicy(FlexibleRedirectPolicy(10)).\n\t\tSetOutputDirectory(filepath.Join(getTestDataPath(), \"dir-sample\")).\n\t\tSetDebug(true)\n\tclient.outputLogTo(io.Discard)\n\n\tresp, err := client.R().\n\t\tSetOutput(\"go-resty/test-img-success.png\").\n\t\tGet(ts.URL + \"/my-image.png\")\n\n\tassertError(t, err)\n\tassertEqual(t, true, resp.Size() != 0)\n\tassertEqual(t, true, resp.Time() > 0)\n}\n\nfunc TestOutputFileWithBaseDirError(t *testing.T) {\n\tc := dc().SetRedirectPolicy(FlexibleRedirectPolicy(10)).\n\t\tSetOutputDirectory(filepath.Join(getTestDataPath(), `go-resty\\0`))\n\n\t_ = c\n}\n\nfunc TestOutputPathDirNotExists(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(filepath.Join(\".testdata\", \"not-exists-dir\"))\n\n\tclient := dc().\n\t\tSetRedirectPolicy(FlexibleRedirectPolicy(10)).\n\t\tSetOutputDirectory(filepath.Join(getTestDataPath(), \"not-exists-dir\"))\n\n\tresp, err := client.R().\n\t\tSetOutput(\"test-img-success.png\").\n\t\tGet(ts.URL + \"/my-image.png\")\n\n\tassertError(t, err)\n\tassertEqual(t, true, resp.Size() != 0)\n\tassertEqual(t, true, resp.Time() > 0)\n}\n\nfunc TestOutputFileAbsPath(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\tdefer cleanupFiles(filepath.Join(\".testdata\", \"go-resty\"))\n\n\t_, err := dcr().\n\t\tSetOutput(filepath.Join(getTestDataPath(), \"go-resty\", \"test-img-success-2.png\")).\n\t\tGet(ts.URL + \"/my-image.png\")\n\n\tassertError(t, err)\n}\n\nfunc TestContextInternal(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tr := dc().R().\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10))\n\n\tresp, err := r.Get(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestSRV(t *testing.T) {\n\tc := dc().\n\t\tSetRedirectPolicy(FlexibleRedirectPolicy(20)).\n\t\tSetScheme(\"http\")\n\n\tr := c.R().\n\t\tSetSRV(&SRVRecord{\"xmpp-server\", \"google.com\"})\n\n\tassertEqual(t, \"xmpp-server\", r.SRV.Service)\n\tassertEqual(t, \"google.com\", r.SRV.Domain)\n\n\tresp, err := r.Get(\"/\")\n\tif err == nil {\n\t\tassertError(t, err)\n\t\tassertNotNil(t, resp)\n\t\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\t}\n}\n\nfunc TestSRVInvalidService(t *testing.T) {\n\t_, err := dc().R().\n\t\tSetSRV(&SRVRecord{\"nonexistantservice\", \"sampledomain\"}).\n\t\tGet(\"/\")\n\n\tassertNotNil(t, err)\n\tassertType(t, net.DNSError{}, err)\n}\n\nfunc TestRequestDoNotParseResponse(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tclient := dc().SetDoNotParseResponse(true)\n\tresp, err := client.R().\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\n\tbuf := acquireBuffer()\n\tdefer releaseBuffer(buf)\n\t_, _ = io.Copy(buf, resp.RawBody())\n\n\tassertEqual(t, \"TestGet: text response\", buf.String())\n\t_ = resp.RawBody().Close()\n\n\t// Manually setting RawResponse as nil\n\tresp, err = dc().R().\n\t\tSetDoNotParseResponse(true).\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\n\tresp.RawResponse = nil\n\tassertNil(t, resp.RawBody())\n}\n\nfunc TestRequestDoNotParseResponseDebugLog(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tt.Run(\"do not parse response debug log client level\", func(t *testing.T) {\n\t\tc := dc().\n\t\t\tSetDoNotParseResponse(true).\n\t\t\tSetDebug(true)\n\n\t\tvar lgr bytes.Buffer\n\t\tc.outputLogTo(&lgr)\n\n\t\t_, err := c.R().\n\t\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\t\tGet(ts.URL + \"/\")\n\n\t\tassertError(t, err)\n\t\tassertEqual(t, true, strings.Contains(lgr.String(), \"***** DO NOT PARSE RESPONSE - Enabled *****\"))\n\t})\n\n\tt.Run(\"do not parse response debug log request level\", func(t *testing.T) {\n\t\tc := dc()\n\n\t\tvar lgr bytes.Buffer\n\t\tc.outputLogTo(&lgr)\n\n\t\t_, err := c.R().\n\t\t\tSetDebug(true).\n\t\t\tSetDoNotParseResponse(true).\n\t\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\t\tGet(ts.URL + \"/\")\n\n\t\tassertError(t, err)\n\t\tassertEqual(t, true, strings.Contains(lgr.String(), \"***** DO NOT PARSE RESPONSE - Enabled *****\"))\n\t})\n}\n\ntype noCtTest struct {\n\tResponse string `json:\"response\"`\n}\n\nfunc TestRequestExpectContentTypeTest(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tresp, err := c.R().\n\t\tSetResult(noCtTest{}).\n\t\tExpectContentType(\"application/json\").\n\t\tGet(ts.URL + \"/json-no-set\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertNotNil(t, resp.Result())\n\tassertEqual(t, \"json response no content type set\", resp.Result().(*noCtTest).Response)\n\n\tassertEqual(t, \"\", firstNonEmpty(\"\", \"\"))\n}\n\nfunc TestGetPathParamAndPathParams(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetBaseURL(ts.URL).\n\t\tSetPathParam(\"userId\", \"sample@sample.com\")\n\n\tresp, err := c.R().SetPathParam(\"subAccountId\", \"100002\").\n\t\tGet(\"/v1/users/{userId}/{subAccountId}/details\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(resp.String(), \"TestGetPathParams: text response\"))\n\tassertEqual(t, true, strings.Contains(resp.String(), \"/v1/users/sample@sample.com/100002/details\"))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestReportMethodSupportsPayload(t *testing.T) {\n\tts := createGenServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tresp, err := c.R().\n\t\tSetBody(\"body\").\n\t\tExecute(\"REPORT\", ts.URL+\"/report\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestRequestQueryStringOrder(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := New().R().\n\t\tSetQueryString(\"productId=232&template=fresh-sample&cat=resty&source=google&kw=buy a lot more\").\n\t\tGet(ts.URL + \"/?UniqueId=ead1d0ed-XXX-XXX-XXX-abb7612b3146&Translate=false&tempauth=eyJ0eXAiOiJKV1QiLC...HZEhwVnJ1d0NSUGVLaUpSaVNLRG5scz0&ApiVersion=2.0\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\nfunc TestRequestOverridesClientAuthorizationHeader(t *testing.T) {\n\tts := createAuthServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tc.SetTLSClientConfig(&tls.Config{InsecureSkipVerify: true}).\n\t\tSetHeader(\"Authorization\", \"some token\").\n\t\tSetHostURL(ts.URL + \"/\")\n\n\tresp, err := c.R().\n\t\tSetHeader(\"Authorization\", \"Bearer 004DDB79-6801-4587-B976-F093E6AC44FF\").\n\t\tGet(\"/profile\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\nfunc TestRequestFileUploadAsReader(t *testing.T) {\n\tts := createFilePostServer(t)\n\tdefer ts.Close()\n\n\tfile, _ := os.Open(filepath.Join(getTestDataPath(), \"test-img.png\"))\n\tdefer file.Close()\n\n\tresp, err := dclr().\n\t\tSetBody(file).\n\t\tSetHeader(\"Content-Type\", \"image/png\").\n\t\tPost(ts.URL + \"/upload\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(resp.String(), \"File Uploaded successfully\"))\n\n\tfile, _ = os.Open(filepath.Join(getTestDataPath(), \"test-img.png\"))\n\tdefer file.Close()\n\n\tresp, err = dclr().\n\t\tSetBody(file).\n\t\tSetHeader(\"Content-Type\", \"image/png\").\n\t\tSetContentLength(true).\n\t\tPost(ts.URL + \"/upload\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(resp.String(), \"File Uploaded successfully\"))\n}\n\nfunc TestHostHeaderOverride(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().R().\n\t\tSetHeader(\"Host\", \"myhostname\").\n\t\tGet(ts.URL + \"/host-header\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, \"myhostname\", resp.String())\n\n\tlogResponse(t, resp)\n}\n\ntype HTTPErrorResponse struct {\n\tError string `json:\"error,omitempty\"`\n}\n\nfunc TestNotFoundWithError(t *testing.T) {\n\tvar httpError HTTPErrorResponse\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tresp, err := dc().R().\n\t\tSetHeader(hdrContentTypeKey, \"application/json\").\n\t\tSetError(&httpError).\n\t\tGet(ts.URL + \"/not-found-with-error\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusNotFound, resp.StatusCode())\n\tassertEqual(t, \"404 Not Found\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, \"{\\\"error\\\": \\\"Not found\\\"}\", resp.String())\n\tassertNotNil(t, httpError)\n\tassertEqual(t, \"Not found\", httpError.Error)\n\n\tlogResponse(t, resp)\n}\n\nfunc TestNotFoundWithoutError(t *testing.T) {\n\tvar httpError HTTPErrorResponse\n\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().outputLogTo(os.Stdout)\n\tresp, err := c.R().\n\t\tSetError(&httpError).\n\t\tSetHeader(hdrContentTypeKey, \"application/json\").\n\t\tGet(ts.URL + \"/not-found-no-error\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusNotFound, resp.StatusCode())\n\tassertEqual(t, \"404 Not Found\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, 0, len(resp.Body()))\n\tassertNotNil(t, httpError)\n\tassertEqual(t, \"\", httpError.Error)\n\n\tlogResponse(t, resp)\n}\n\nfunc TestPathParamURLInput(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetBaseURL(ts.URL).\n\t\tSetPathParams(map[string]string{\n\t\t\t\"userId\": \"sample@sample.com\",\n\t\t\t\"path\":   \"users/developers\",\n\t\t})\n\n\tresp, err := c.R().\n\t\tSetDebug(true).\n\t\tSetPathParams(map[string]string{\n\t\t\t\"subAccountId\": \"100002\",\n\t\t\t\"website\":      \"https://example.com\",\n\t\t}).Get(\"/v1/users/{userId}/{subAccountId}/{path}/{website}\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(resp.String(), \"TestPathParamURLInput: text response\"))\n\tassertEqual(t, true, strings.Contains(resp.String(), \"/v1/users/sample@sample.com/100002/users%2Fdevelopers/https:%2F%2Fexample.com\"))\n\n\tlogResponse(t, resp)\n}\n\nfunc TestRawPathParamURLInput(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().SetDebug(true).\n\t\tSetBaseURL(ts.URL).\n\t\tSetRawPathParams(map[string]string{\n\t\t\t\"userId\": \"sample@sample.com\",\n\t\t\t\"path\":   \"users/developers\",\n\t\t})\n\n\tresp, err := c.R().\n\t\tSetRawPathParams(map[string]string{\n\t\t\t\"subAccountId\": \"100002\",\n\t\t\t\"website\":      \"https://example.com\",\n\t\t}).Get(\"/v1/users/{userId}/{subAccountId}/{path}/{website}\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, true, strings.Contains(resp.String(), \"TestPathParamURLInput: text response\"))\n\tassertEqual(t, true, strings.Contains(resp.String(), \"/v1/users/sample@sample.com/100002/users/developers/https://example.com\"))\n\n\tlogResponse(t, resp)\n}\n\n// This test case is kind of pass always\nfunc TestTraceInfo(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tserverAddr := ts.URL[strings.LastIndex(ts.URL, \"/\")+1:]\n\n\tclient := dc()\n\tclient.SetHostURL(ts.URL).EnableTrace()\n\tfor _, u := range []string{\"/\", \"/json\", \"/long-text\", \"/long-json\"} {\n\t\tresp, err := client.R().Get(u)\n\t\tassertNil(t, err)\n\t\tassertNotNil(t, resp)\n\n\t\ttr := resp.Request.TraceInfo()\n\t\tassertEqual(t, true, tr.DNSLookup >= 0)\n\t\tassertEqual(t, true, tr.ConnTime >= 0)\n\t\tassertEqual(t, true, tr.TLSHandshake >= 0)\n\t\tassertEqual(t, true, tr.ServerTime >= 0)\n\t\tassertEqual(t, true, tr.ResponseTime >= 0)\n\t\tassertEqual(t, true, tr.TotalTime >= 0)\n\t\tassertEqual(t, true, tr.TotalTime < time.Hour)\n\t\tassertEqual(t, true, tr.TotalTime == resp.Time())\n\t\tassertEqual(t, tr.RemoteAddr.String(), serverAddr)\n\t}\n\n\tclient.DisableTrace()\n\n\tfor _, u := range []string{\"/\", \"/json\", \"/long-text\", \"/long-json\"} {\n\t\tresp, err := client.R().EnableTrace().Get(u)\n\t\tassertNil(t, err)\n\t\tassertNotNil(t, resp)\n\n\t\ttr := resp.Request.TraceInfo()\n\t\tassertEqual(t, true, tr.DNSLookup >= 0)\n\t\tassertEqual(t, true, tr.ConnTime >= 0)\n\t\tassertEqual(t, true, tr.TLSHandshake >= 0)\n\t\tassertEqual(t, true, tr.ServerTime >= 0)\n\t\tassertEqual(t, true, tr.ResponseTime >= 0)\n\t\tassertEqual(t, true, tr.TotalTime >= 0)\n\t\tassertEqual(t, true, tr.TotalTime == resp.Time())\n\t\tassertEqual(t, tr.RemoteAddr.String(), serverAddr)\n\t}\n\n\t// for sake of hook funcs\n\t_, _ = client.R().EnableTrace().Get(\"https://httpbin.org/get\")\n}\n\nfunc TestTraceInfoWithoutEnableTrace(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tclient := dc()\n\tclient.SetHostURL(ts.URL)\n\tfor _, u := range []string{\"/\", \"/json\", \"/long-text\", \"/long-json\"} {\n\t\tresp, err := client.R().Get(u)\n\t\tassertNil(t, err)\n\t\tassertNotNil(t, resp)\n\n\t\ttr := resp.Request.TraceInfo()\n\t\tassertEqual(t, true, tr.DNSLookup == 0)\n\t\tassertEqual(t, true, tr.ConnTime == 0)\n\t\tassertEqual(t, true, tr.TLSHandshake == 0)\n\t\tassertEqual(t, true, tr.ServerTime == 0)\n\t\tassertEqual(t, true, tr.ResponseTime == 0)\n\t\tassertEqual(t, true, tr.TotalTime == 0)\n\t}\n}\n\nfunc TestTraceInfoOnTimeout(t *testing.T) {\n\tclient := dc()\n\tclient.SetHostURL(\"http://resty-nowhere.local\").EnableTrace()\n\n\tresp, err := client.R().Get(\"/\")\n\tassertNotNil(t, err)\n\tassertNotNil(t, resp)\n\n\ttr := resp.Request.TraceInfo()\n\tassertEqual(t, true, tr.DNSLookup >= 0)\n\tassertEqual(t, true, tr.ConnTime == 0)\n\tassertEqual(t, true, tr.TLSHandshake == 0)\n\tassertEqual(t, true, tr.TCPConnTime == 0)\n\tassertEqual(t, true, tr.ServerTime == 0)\n\tassertEqual(t, true, tr.ResponseTime == 0)\n\tassertEqual(t, true, tr.TotalTime > 0)\n\tassertEqual(t, true, tr.TotalTime == resp.Time())\n}\n\nfunc TestDebugLoggerRequestBodyTooLarge(t *testing.T) {\n\tts := createFilePostServer(t)\n\tdefer ts.Close()\n\n\tdebugBodySizeLimit := int64(512)\n\n\t// upload an image with more than 512 bytes\n\toutput := bytes.NewBufferString(\"\")\n\tresp, err := New().SetDebug(true).outputLogTo(output).SetDebugBodyLimit(debugBodySizeLimit).R().\n\t\tSetFile(\"file\", filepath.Join(getTestDataPath(), \"test-img.png\")).\n\t\tSetHeader(\"Content-Type\", \"image/png\").\n\t\tPost(ts.URL + \"/upload\")\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n\tassertEqual(t, true, strings.Contains(output.String(), \"REQUEST TOO LARGE\"))\n\n\t// upload a text file with no more than 512 bytes\n\toutput = bytes.NewBufferString(\"\")\n\tresp, err = New().outputLogTo(output).SetDebugBodyLimit(debugBodySizeLimit).R().\n\t\tSetDebug(true).\n\t\tSetFile(\"file\", filepath.Join(getTestDataPath(), \"text-file.txt\")).\n\t\tSetHeader(\"Content-Type\", \"text/plain\").\n\t\tPost(ts.URL + \"/upload\")\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n\tassertEqual(t, true, strings.Contains(output.String(), \" THIS IS TEXT FILE FOR MULTIPART UPLOAD TEST \"))\n\n\tformTs := createFormPostServer(t)\n\tdefer formTs.Close()\n\n\t// post form with more than 512 bytes data\n\toutput = bytes.NewBufferString(\"\")\n\tresp, err = New().SetDebug(true).outputLogTo(output).SetDebugBodyLimit(debugBodySizeLimit).R().\n\t\tSetFormData(map[string]string{\n\t\t\t\"first_name\": \"Alex\",\n\t\t\t\"last_name\":  strings.Repeat(\"C\", int(debugBodySizeLimit)),\n\t\t\t\"zip_code\":   \"00001\",\n\t\t}).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(formTs.URL + \"/profile\")\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n\tassertEqual(t, true, strings.Contains(output.String(), \"REQUEST TOO LARGE\"))\n\n\t// post form with no more than 512 bytes data\n\toutput = bytes.NewBufferString(\"\")\n\tresp, err = New().outputLogTo(output).SetDebugBodyLimit(debugBodySizeLimit).R().\n\t\tSetDebug(true).\n\t\tSetFormData(map[string]string{\n\t\t\t\"first_name\": \"Alex\",\n\t\t\t\"last_name\":  \"C\",\n\t\t\t\"zip_code\":   \"00001\",\n\t\t}).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(formTs.URL + \"/profile\")\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n\tassertEqual(t, true, strings.Contains(output.String(), \"Alex\"))\n\n\t// post string with more than 512 bytes data\n\toutput = bytes.NewBufferString(\"\")\n\tresp, err = New().SetDebug(true).outputLogTo(output).SetDebugBodyLimit(debugBodySizeLimit).R().\n\t\tSetBody(`{\n\t\t\t\"first_name\": \"Alex\",\n\t\t\t\"last_name\": \"`+strings.Repeat(\"C\", int(debugBodySizeLimit))+`C\",\n\t\t\t\"zip_code\": \"00001\"}`).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(formTs.URL + \"/profile\")\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n\tassertEqual(t, true, strings.Contains(output.String(), \"REQUEST TOO LARGE\"))\n\n\t// post slice with more than 512 bytes data\n\toutput = bytes.NewBufferString(\"\")\n\tresp, err = New().outputLogTo(output).SetDebugBodyLimit(debugBodySizeLimit).R().\n\t\tSetDebug(true).\n\t\tSetBody([]string{strings.Repeat(\"C\", int(debugBodySizeLimit))}).\n\t\tSetBasicAuth(\"myuser\", \"mypass\").\n\t\tPost(formTs.URL + \"/profile\")\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n\tassertEqual(t, true, strings.Contains(output.String(), \"REQUEST TOO LARGE\"))\n}\n\nfunc TestPostMapTemporaryRedirect(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tresp, err := c.R().SetBody(map[string]string{\"username\": \"testuser\", \"password\": \"testpass\"}).\n\t\tPost(ts.URL + \"/redirect\")\n\n\tassertNil(t, err)\n\tassertNotNil(t, resp)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n}\n\ntype brokenReadCloser struct{}\n\nfunc (b brokenReadCloser) Read(p []byte) (n int, err error) {\n\treturn 0, errors.New(\"read error\")\n}\n\nfunc (b brokenReadCloser) Close() error {\n\treturn nil\n}\n\nfunc TestPostBodyError(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tc := dc()\n\tresp, err := c.R().SetBody(brokenReadCloser{}).Post(ts.URL + \"/redirect\")\n\tassertNotNil(t, err)\n\tassertEqual(t, \"read error\", err.Error())\n\tassertNil(t, resp)\n}\n\nfunc TestSetResultMustNotPanicOnNil(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Errorf(\"must not panic\")\n\t\t}\n\t}()\n\tdc().R().SetResult(nil)\n}\n\nfunc TestRequestGH917(t *testing.T) {\n\t// Mock server returns 500 status code to cause client retries.\n\tsrv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tb, err := io.ReadAll(r.Body)\n\t\tassertError(t, err)\n\t\tassertEqual(t, \"test\", string(b))\n\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t}))\n\n\tclient := New().AddRetryCondition(\n\t\tfunc(r *Response, err error) bool {\n\t\t\treturn err != nil || r.StatusCode() > 499\n\t\t},\n\t).SetRetryCount(3)\n\n\twg := sync.WaitGroup{}\n\t// Run tests concurrently to make the issue easily to observe.\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor j := 0; j < 10; j++ {\n\t\t\t\tbuf := bytes.NewBufferString(\"test\")\n\t\t\t\t// Trigger some retries\n\t\t\t\tresp, err := client.R().SetBody(buf).SetContentLength(true).Execute(http.MethodPost, srv.URL)\n\t\t\t\tassertNil(t, err)\n\t\t\t\tassertEqual(t, http.StatusInternalServerError, resp.StatusCode())\n\t\t\t\tassertEqual(t, \"\", string(resp.Body()))\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 5.5341796875,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Response struct and methods\n//_______________________________________________________________________\n\n// Response struct holds response values of executed requests.\ntype Response struct {\n\tRequest     *Request\n\tRawResponse *http.Response\n\n\tbody       []byte\n\tsize       int64\n\treceivedAt time.Time\n}\n\n// Body method returns the HTTP response as `[]byte` slice for the executed request.\n//\n// NOTE: [Response.Body] might be nil if [Request.SetOutput] is used.\n// Also see [Request.SetDoNotParseResponse], [Client.SetDoNotParseResponse]\nfunc (r *Response) Body() []byte {\n\tif r.RawResponse == nil {\n\t\treturn []byte{}\n\t}\n\treturn r.body\n}\n\n// SetBody method sets [Response] body in byte slice. Typically,\n// It is helpful for test cases.\n//\n//\tresp.SetBody([]byte(\"This is test body content\"))\n//\tresp.SetBody(nil)\nfunc (r *Response) SetBody(b []byte) *Response {\n\tr.body = b\n\treturn r\n}\n\n// Status method returns the HTTP status string for the executed request.\n//\n//\tExample: 200 OK\nfunc (r *Response) Status() string {\n\tif r.RawResponse == nil {\n\t\treturn \"\"\n\t}\n\treturn r.RawResponse.Status\n}\n\n// StatusCode method returns the HTTP status code for the executed request.\n//\n//\tExample: 200\nfunc (r *Response) StatusCode() int {\n\tif r.RawResponse == nil {\n\t\treturn 0\n\t}\n\treturn r.RawResponse.StatusCode\n}\n\n// Proto method returns the HTTP response protocol used for the request.\nfunc (r *Response) Proto() string {\n\tif r.RawResponse == nil {\n\t\treturn \"\"\n\t}\n\treturn r.RawResponse.Proto\n}\n\n// Result method returns the response value as an object if it has one\n//\n// See [Request.SetResult]\nfunc (r *Response) Result() interface{} {\n\treturn r.Request.Result\n}\n\n// Error method returns the error object if it has one\n//\n// See [Request.SetError], [Client.SetError]\nfunc (r *Response) Error() interface{} {\n\treturn r.Request.Error\n}\n\n// Header method returns the response headers\nfunc (r *Response) Header() http.Header {\n\tif r.RawResponse == nil {\n\t\treturn http.Header{}\n\t}\n\treturn r.RawResponse.Header\n}\n\n// Cookies method to returns all the response cookies\nfunc (r *Response) Cookies() []*http.Cookie {\n\tif r.RawResponse == nil {\n\t\treturn make([]*http.Cookie, 0)\n\t}\n\treturn r.RawResponse.Cookies()\n}\n\n// String method returns the body of the HTTP response as a `string`.\n// It returns an empty string if it is nil or the body is zero length.\nfunc (r *Response) String() string {\n\tif len(r.body) == 0 {\n\t\treturn \"\"\n\t}\n\treturn strings.TrimSpace(string(r.body))\n}\n\n// Time method returns the duration of HTTP response time from the request we sent\n// and received a request.\n//\n// See [Response.ReceivedAt] to know when the client received a response and see\n// `Response.Request.Time` to know when the client sent a request.\nfunc (r *Response) Time() time.Duration {\n\tif r.Request.clientTrace != nil {\n\t\treturn r.Request.TraceInfo().TotalTime\n\t}\n\treturn r.receivedAt.Sub(r.Request.Time)\n}\n\n// ReceivedAt method returns the time we received a response from the server for the request.\nfunc (r *Response) ReceivedAt() time.Time {\n\treturn r.receivedAt\n}\n\n// Size method returns the HTTP response size in bytes. Yeah, you can rely on HTTP `Content-Length`\n// header, however it won't be available for chucked transfer/compressed response.\n// Since Resty captures response size details when processing the response body\n// when possible. So that users get the actual size of response bytes.\nfunc (r *Response) Size() int64 {\n\treturn r.size\n}\n\n// RawBody method exposes the HTTP raw response body. Use this method in conjunction with\n// [Client.SetDoNotParseResponse] or [Request.SetDoNotParseResponse]\n// option; otherwise, you get an error as `read err: http: read on closed response body.`\n//\n// Do not forget to close the body, otherwise you might get into connection leaks, no connection reuse.\n// You have taken over the control of response parsing from Resty.\nfunc (r *Response) RawBody() io.ReadCloser {\n\tif r.RawResponse == nil {\n\t\treturn nil\n\t}\n\treturn r.RawResponse.Body\n}\n\n// IsSuccess method returns true if HTTP status `code >= 200 and <= 299` otherwise false.\nfunc (r *Response) IsSuccess() bool {\n\treturn r.StatusCode() > 199 && r.StatusCode() < 300\n}\n\n// IsError method returns true if HTTP status `code >= 400` otherwise false.\nfunc (r *Response) IsError() bool {\n\treturn r.StatusCode() > 399\n}\n\nfunc (r *Response) setReceivedAt() {\n\tr.receivedAt = time.Now()\n\tif r.Request.clientTrace != nil {\n\t\tr.Request.clientTrace.endTime = r.receivedAt\n\t}\n}\n\nfunc (r *Response) fmtBodyString(sl int64) string {\n\tif r.Request.client.notParseResponse || r.Request.notParseResponse {\n\t\treturn \"***** DO NOT PARSE RESPONSE - Enabled *****\"\n\t}\n\tif len(r.body) > 0 {\n\t\tif int64(len(r.body)) > sl {\n\t\t\treturn fmt.Sprintf(\"***** RESPONSE TOO LARGE (size - %d) *****\", len(r.body))\n\t\t}\n\t\tct := r.Header().Get(hdrContentTypeKey)\n\t\tif IsJSONType(ct) {\n\t\t\tout := acquireBuffer()\n\t\t\tdefer releaseBuffer(out)\n\t\t\terr := json.Indent(out, r.body, \"\", \"   \")\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Sprintf(\"*** Error: Unable to format response body - \\\"%s\\\" ***\\n\\nLog Body as-is:\\n%s\", err, r.String())\n\t\t\t}\n\t\t\treturn out.String()\n\t\t}\n\t\treturn r.String()\n\t}\n\n\treturn \"***** NO CONTENT *****\"\n}\n"
        },
        {
          "name": "resty.go",
          "type": "blob",
          "size": 1.0947265625,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\n// Package resty provides Simple HTTP and REST client library for Go.\npackage resty\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\n\t\"golang.org/x/net/publicsuffix\"\n)\n\n// Version # of resty\nconst Version = \"2.16.3\"\n\n// New method creates a new Resty client.\nfunc New() *Client {\n\tcookieJar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})\n\treturn createClient(&http.Client{\n\t\tJar: cookieJar,\n\t})\n}\n\n// NewWithClient method creates a new Resty client with given [http.Client].\nfunc NewWithClient(hc *http.Client) *Client {\n\treturn createClient(hc)\n}\n\n// NewWithLocalAddr method creates a new Resty client with the given Local Address.\n// to dial from.\nfunc NewWithLocalAddr(localAddr net.Addr) *Client {\n\tcookieJar, _ := cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})\n\treturn createClient(&http.Client{\n\t\tJar:       cookieJar,\n\t\tTransport: createTransport(localAddr),\n\t})\n}\n"
        },
        {
          "name": "resty_test.go",
          "type": "blob",
          "size": 26.525390625,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"compress/gzip\"\n\t\"crypto/md5\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Testing Unexported methods\n//___________________________________\n\nfunc getTestDataPath() string {\n\tpwd, _ := os.Getwd()\n\treturn filepath.Join(pwd, \".testdata\")\n}\n\nfunc createGetServer(t *testing.T) *httptest.Server {\n\tvar attempt int32\n\tvar sequence int32\n\tvar lastRequest time.Time\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\n\t\tif r.Method == MethodGet {\n\t\t\tswitch r.URL.Path {\n\t\t\tcase \"/\":\n\t\t\t\t_, _ = w.Write([]byte(\"TestGet: text response\"))\n\t\t\tcase \"/no-content\":\n\t\t\t\t_, _ = w.Write([]byte(\"\"))\n\t\t\tcase \"/json\":\n\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\t_, _ = w.Write([]byte(`{\"TestGet\": \"JSON response\"}`))\n\t\t\tcase \"/json-invalid\":\n\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\t_, _ = w.Write([]byte(\"TestGet: Invalid JSON\"))\n\t\t\tcase \"/long-text\":\n\t\t\t\t_, _ = w.Write([]byte(\"TestGet: text response with size > 30\"))\n\t\t\tcase \"/long-json\":\n\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\t_, _ = w.Write([]byte(`{\"TestGet\": \"JSON response with size > 30\"}`))\n\t\t\tcase \"/mypage\":\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tcase \"/mypage2\":\n\t\t\t\t_, _ = w.Write([]byte(\"TestGet: text response from mypage2\"))\n\t\t\tcase \"/set-retrycount-test\":\n\t\t\t\tattp := atomic.AddInt32(&attempt, 1)\n\t\t\t\tif attp <= 4 {\n\t\t\t\t\ttime.Sleep(time.Second * 6)\n\t\t\t\t}\n\t\t\t\t_, _ = w.Write([]byte(\"TestClientRetry page\"))\n\t\t\tcase \"/set-retrywaittime-test\":\n\t\t\t\t// Returns time.Duration since last request here\n\t\t\t\t// or 0 for the very first request\n\t\t\t\tif atomic.LoadInt32(&attempt) == 0 {\n\t\t\t\t\tlastRequest = time.Now()\n\t\t\t\t\t_, _ = fmt.Fprint(w, \"0\")\n\t\t\t\t} else {\n\t\t\t\t\tnow := time.Now()\n\t\t\t\t\tsinceLastRequest := now.Sub(lastRequest)\n\t\t\t\t\tlastRequest = now\n\t\t\t\t\t_, _ = fmt.Fprintf(w, \"%d\", uint64(sinceLastRequest))\n\t\t\t\t}\n\t\t\t\tatomic.AddInt32(&attempt, 1)\n\n\t\t\tcase \"/set-retry-error-recover\":\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\t\t\t\tif atomic.LoadInt32(&attempt) == 0 {\n\t\t\t\t\tw.WriteHeader(http.StatusTooManyRequests)\n\t\t\t\t\t_, _ = w.Write([]byte(`{ \"message\": \"too many\" }`))\n\t\t\t\t} else {\n\t\t\t\t\t_, _ = w.Write([]byte(`{ \"message\": \"hello\" }`))\n\t\t\t\t}\n\t\t\t\tatomic.AddInt32(&attempt, 1)\n\t\t\tcase \"/set-timeout-test-with-sequence\":\n\t\t\t\tseq := atomic.AddInt32(&sequence, 1)\n\t\t\t\ttime.Sleep(time.Second * 2)\n\t\t\t\t_, _ = fmt.Fprintf(w, \"%d\", seq)\n\t\t\tcase \"/set-timeout-test\":\n\t\t\t\ttime.Sleep(time.Second * 6)\n\t\t\t\t_, _ = w.Write([]byte(\"TestClientTimeout page\"))\n\t\t\tcase \"/my-image.png\":\n\t\t\t\tfileBytes, _ := os.ReadFile(filepath.Join(getTestDataPath(), \"test-img.png\"))\n\t\t\t\tw.Header().Set(\"Content-Type\", \"image/png\")\n\t\t\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(fileBytes)))\n\t\t\t\t_, _ = w.Write(fileBytes)\n\t\t\tcase \"/get-method-payload-test\":\n\t\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Error: could not read get body: %s\", err.Error())\n\t\t\t\t}\n\t\t\t\t_, _ = w.Write(body)\n\t\t\tcase \"/host-header\":\n\t\t\t\t_, _ = w.Write([]byte(r.Host))\n\t\t\tcase \"/not-found-with-error\":\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json\")\n\t\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\t\t_, _ = w.Write([]byte(`{\"error\": \"Not found\"}`))\n\t\t\tcase \"/not-found-no-error\":\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json\")\n\t\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\tcase \"/unescape-query-params\":\n\t\t\t\tinitOne := r.URL.Query().Get(\"initone\")\n\t\t\t\tfromClient := r.URL.Query().Get(\"fromclient\")\n\t\t\t\tregistry := r.URL.Query().Get(\"registry\")\n\t\t\t\tassertEqual(t, \"cáfe\", initOne)\n\t\t\t\tassertEqual(t, \"hey unescape\", fromClient)\n\t\t\t\tassertEqual(t, \"nacos://test:6801\", registry)\n\t\t\t\t_, _ = w.Write([]byte(`query params looks good`))\n\t\t\t}\n\n\t\t\tswitch {\n\t\t\tcase strings.HasPrefix(r.URL.Path, \"/v1/users/sample@sample.com/100002\"):\n\t\t\t\tif strings.HasSuffix(r.URL.Path, \"details\") {\n\t\t\t\t\t_, _ = w.Write([]byte(\"TestGetPathParams: text response: \" + r.URL.String()))\n\t\t\t\t} else {\n\t\t\t\t\t_, _ = w.Write([]byte(\"TestPathParamURLInput: text response: \" + r.URL.String()))\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc handleLoginEndpoint(t *testing.T, w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Path == \"/login\" {\n\t\tuser := &User{}\n\n\t\t// JSON\n\t\tif IsJSONType(r.Header.Get(hdrContentTypeKey)) {\n\t\t\tjd := json.NewDecoder(r.Body)\n\t\t\terr := jd.Decode(user)\n\t\t\tif r.URL.Query().Get(\"ct\") == \"problem\" {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/problem+json; charset=utf-8\")\n\t\t\t} else if r.URL.Query().Get(\"ct\") == \"rpc\" {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json-rpc\")\n\t\t\t} else {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json\")\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tt.Logf(\"Error: %#v\", err)\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"bad_request\", \"message\": \"Unable to read user info\" }`))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif user.Username == \"testuser\" && user.Password == \"testpass\" {\n\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"success\", \"message\": \"login successful\" }`))\n\t\t\t} else if user.Username == \"testuser\" && user.Password == \"invalidjson\" {\n\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"success\", \"message\": \"login successful\", }`))\n\t\t\t} else {\n\t\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"unauthorized\", \"message\": \"Invalid credentials\" }`))\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\t// XML\n\t\tif IsXMLType(r.Header.Get(hdrContentTypeKey)) {\n\t\t\txd := xml.NewDecoder(r.Body)\n\t\t\terr := xd.Decode(user)\n\n\t\t\tw.Header().Set(hdrContentTypeKey, \"application/xml\")\n\t\t\tif err != nil {\n\t\t\t\tt.Logf(\"Error: %v\", err)\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t_, _ = w.Write([]byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`))\n\t\t\t\t_, _ = w.Write([]byte(`<AuthError><Id>bad_request</Id><Message>Unable to read user info</Message></AuthError>`))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif user.Username == \"testuser\" && user.Password == \"testpass\" {\n\t\t\t\t_, _ = w.Write([]byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`))\n\t\t\t\t_, _ = w.Write([]byte(`<AuthSuccess><Id>success</Id><Message>login successful</Message></AuthSuccess>`))\n\t\t\t} else if user.Username == \"testuser\" && user.Password == \"invalidxml\" {\n\t\t\t\t_, _ = w.Write([]byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`))\n\t\t\t\t_, _ = w.Write([]byte(`<AuthSuccess><Id>success</Id><Message>login successful</AuthSuccess>`))\n\t\t\t} else {\n\t\t\t\tw.Header().Set(\"Www-Authenticate\", \"Protected Realm\")\n\t\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t\t_, _ = w.Write([]byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?>`))\n\t\t\t\t_, _ = w.Write([]byte(`<AuthError><Id>unauthorized</Id><Message>Invalid credentials</Message></AuthError>`))\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc handleUsersEndpoint(t *testing.T, w http.ResponseWriter, r *http.Request) {\n\tif r.URL.Path == \"/users\" {\n\t\t// JSON\n\t\tif IsJSONType(r.Header.Get(hdrContentTypeKey)) {\n\t\t\tvar users []ExampleUser\n\t\t\tjd := json.NewDecoder(r.Body)\n\t\t\terr := jd.Decode(&users)\n\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json\")\n\t\t\tif err != nil {\n\t\t\t\tt.Logf(\"Error: %v\", err)\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"bad_request\", \"message\": \"Unable to read user info\" }`))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// logic check, since we are excepting to reach 3 records\n\t\t\tif len(users) != 3 {\n\t\t\t\tt.Log(\"Error: Excepted count of 3 records\")\n\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"bad_request\", \"message\": \"Expected record count doesn't match\" }`))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\teu := users[2]\n\t\t\tif eu.FirstName == \"firstname3\" && eu.ZipCode == \"10003\" {\n\t\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t\t\t_, _ = w.Write([]byte(`{ \"message\": \"Accepted\" }`))\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc createPostServer(t *testing.T) *httptest.Server {\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\t\tt.Logf(\"RawQuery: %v\", r.URL.RawQuery)\n\t\tt.Logf(\"Content-Type: %v\", r.Header.Get(hdrContentTypeKey))\n\n\t\tif r.Method == MethodPost {\n\t\t\thandleLoginEndpoint(t, w, r)\n\n\t\t\thandleUsersEndpoint(t, w, r)\n\t\t\tswitch r.URL.Path {\n\t\t\tcase \"/login-json-html\":\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"text/html\")\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\t_, _ = w.Write([]byte(`<htm><body>Test JSON request with HTML response</body></html>`))\n\t\t\t\treturn\n\t\t\tcase \"/usersmap\":\n\t\t\t\t// JSON\n\t\t\t\tif IsJSONType(r.Header.Get(hdrContentTypeKey)) {\n\t\t\t\t\tif r.URL.Query().Get(\"status\") == \"500\" {\n\t\t\t\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Errorf(\"Error: could not read post body: %s\", err.Error())\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt.Logf(\"Got query param: status=500 so we're returning the post body as response and a 500 status code. body: %s\", string(body))\n\t\t\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\t\t\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\t\t\t_, _ = w.Write(body)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tvar users []map[string]interface{}\n\t\t\t\t\tjd := json.NewDecoder(r.Body)\n\t\t\t\t\terr := jd.Decode(&users)\n\t\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Logf(\"Error: %v\", err)\n\t\t\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"bad_request\", \"message\": \"Unable to read user info\" }`))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\t// logic check, since we are excepting to reach 1 map records\n\t\t\t\t\tif len(users) != 1 {\n\t\t\t\t\t\tt.Log(\"Error: Excepted count of 1 map records\")\n\t\t\t\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"bad_request\", \"message\": \"Expected record count doesn't match\" }`))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t\t\t\t_, _ = w.Write([]byte(`{ \"message\": \"Accepted\" }`))\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase \"/redirect\":\n\t\t\t\tw.Header().Set(hdrLocationKey, \"/login\")\n\t\t\t\tw.WriteHeader(http.StatusTemporaryRedirect)\n\t\t\tcase \"/redirect-with-body\":\n\t\t\t\tbody, _ := io.ReadAll(r.Body)\n\t\t\t\tquery := url.Values{}\n\t\t\t\tquery.Add(\"body\", string(body))\n\t\t\t\tw.Header().Set(hdrLocationKey, \"/redirected-with-body?\"+query.Encode())\n\t\t\t\tw.WriteHeader(http.StatusTemporaryRedirect)\n\t\t\tcase \"/redirected-with-body\":\n\t\t\t\tbody, _ := io.ReadAll(r.Body)\n\t\t\t\tassertEqual(t, r.URL.Query().Get(\"body\"), string(body))\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\tcase \"/curl-cmd-post\":\n\t\t\t\tcookie := http.Cookie{\n\t\t\t\t\tName:    \"testserver\",\n\t\t\t\t\tDomain:  \"localhost\",\n\t\t\t\t\tPath:    \"/\",\n\t\t\t\t\tExpires: time.Now().AddDate(0, 0, 1),\n\t\t\t\t\tValue:   \"yes\",\n\t\t\t\t}\n\t\t\t\thttp.SetCookie(w, &cookie)\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t}\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc createFormPostServer(t *testing.T) *httptest.Server {\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\t\tt.Logf(\"Content-Type: %v\", r.Header.Get(hdrContentTypeKey))\n\n\t\tif r.Method == MethodPost {\n\t\t\t_ = r.ParseMultipartForm(10e6)\n\n\t\t\tif r.URL.Path == \"/profile\" {\n\t\t\t\tt.Logf(\"FirstName: %v\", r.FormValue(\"first_name\"))\n\t\t\t\tt.Logf(\"LastName: %v\", r.FormValue(\"last_name\"))\n\t\t\t\tt.Logf(\"City: %v\", r.FormValue(\"city\"))\n\t\t\t\tt.Logf(\"Zip Code: %v\", r.FormValue(\"zip_code\"))\n\n\t\t\t\t_, _ = w.Write([]byte(\"Success\"))\n\t\t\t\treturn\n\t\t\t} else if r.URL.Path == \"/search\" {\n\t\t\t\tformEncodedData := r.Form.Encode()\n\t\t\t\tt.Logf(\"Received Form Encoded values: %v\", formEncodedData)\n\n\t\t\t\tassertEqual(t, true, strings.Contains(formEncodedData, \"search_criteria=pencil\"))\n\t\t\t\tassertEqual(t, true, strings.Contains(formEncodedData, \"search_criteria=glass\"))\n\n\t\t\t\t_, _ = w.Write([]byte(\"Success\"))\n\t\t\t\treturn\n\t\t\t} else if r.URL.Path == \"/upload\" {\n\t\t\t\tt.Logf(\"FirstName: %v\", r.FormValue(\"first_name\"))\n\t\t\t\tt.Logf(\"LastName: %v\", r.FormValue(\"last_name\"))\n\n\t\t\t\ttargetPath := filepath.Join(getTestDataPath(), \"upload\")\n\t\t\t\t_ = os.MkdirAll(targetPath, 0700)\n\n\t\t\t\tfor _, fhdrs := range r.MultipartForm.File {\n\t\t\t\t\tfor _, hdr := range fhdrs {\n\t\t\t\t\t\tt.Logf(\"Name: %v\", hdr.Filename)\n\t\t\t\t\t\tt.Logf(\"Header: %v\", hdr.Header)\n\t\t\t\t\t\tdotPos := strings.LastIndex(hdr.Filename, \".\")\n\n\t\t\t\t\t\tfname := fmt.Sprintf(\"%s-%v%s\", hdr.Filename[:dotPos], time.Now().Unix(), hdr.Filename[dotPos:])\n\t\t\t\t\t\tt.Logf(\"Write name: %v\", fname)\n\n\t\t\t\t\t\tinfile, _ := hdr.Open()\n\t\t\t\t\t\tf, err := os.OpenFile(filepath.Join(targetPath, fname), os.O_WRONLY|os.O_CREATE, 0666)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Logf(\"Error: %v\", err)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t_ = f.Close()\n\t\t\t\t\t\t}()\n\t\t\t\t\t\t_, _ = io.Copy(f, infile)\n\n\t\t\t\t\t\t_, _ = w.Write([]byte(fmt.Sprintf(\"File: %v, uploaded as: %v\\n\", hdr.Filename, fname)))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc createFormPatchServer(t *testing.T) *httptest.Server {\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\t\tt.Logf(\"Content-Type: %v\", r.Header.Get(hdrContentTypeKey))\n\n\t\tif r.Method == MethodPatch {\n\t\t\t_ = r.ParseMultipartForm(10e6)\n\n\t\t\tif r.URL.Path == \"/upload\" {\n\t\t\t\tt.Logf(\"FirstName: %v\", r.FormValue(\"first_name\"))\n\t\t\t\tt.Logf(\"LastName: %v\", r.FormValue(\"last_name\"))\n\n\t\t\t\ttargetPath := filepath.Join(getTestDataPath(), \"upload\")\n\t\t\t\t_ = os.MkdirAll(targetPath, 0700)\n\n\t\t\t\tfor _, fhdrs := range r.MultipartForm.File {\n\t\t\t\t\tfor _, hdr := range fhdrs {\n\t\t\t\t\t\tt.Logf(\"Name: %v\", hdr.Filename)\n\t\t\t\t\t\tt.Logf(\"Header: %v\", hdr.Header)\n\t\t\t\t\t\tdotPos := strings.LastIndex(hdr.Filename, \".\")\n\n\t\t\t\t\t\tfname := fmt.Sprintf(\"%s-%v%s\", hdr.Filename[:dotPos], time.Now().Unix(), hdr.Filename[dotPos:])\n\t\t\t\t\t\tt.Logf(\"Write name: %v\", fname)\n\n\t\t\t\t\t\tinfile, _ := hdr.Open()\n\t\t\t\t\t\tf, err := os.OpenFile(filepath.Join(targetPath, fname), os.O_WRONLY|os.O_CREATE, 0666)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tt.Logf(\"Error: %v\", err)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefer func() {\n\t\t\t\t\t\t\t_ = f.Close()\n\t\t\t\t\t\t}()\n\t\t\t\t\t\t_, _ = io.Copy(f, infile)\n\n\t\t\t\t\t\t_, _ = w.Write([]byte(fmt.Sprintf(\"File: %v, uploaded as: %v\\n\", hdr.Filename, fname)))\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc createFilePostServer(t *testing.T) *httptest.Server {\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\t\tt.Logf(\"Content-Type: %v\", r.Header.Get(hdrContentTypeKey))\n\n\t\tif r.Method != MethodPost {\n\t\t\tt.Log(\"createPostServer:: Not a Post request\")\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tfmt.Fprint(w, http.StatusText(http.StatusBadRequest))\n\t\t\treturn\n\t\t}\n\n\t\ttargetPath := filepath.Join(getTestDataPath(), \"upload-large\")\n\t\t_ = os.MkdirAll(targetPath, 0700)\n\t\tdefer cleanupFiles(targetPath)\n\n\t\tswitch r.URL.Path {\n\t\tcase \"/upload\":\n\t\t\tf, err := os.OpenFile(filepath.Join(targetPath, \"large-file.png\"),\n\t\t\t\tos.O_WRONLY|os.O_CREATE, 0666)\n\t\t\tif err != nil {\n\t\t\t\tt.Logf(\"Error: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\t_ = f.Close()\n\t\t\t}()\n\t\t\tsize, _ := io.Copy(f, r.Body)\n\n\t\t\tfmt.Fprintf(w, \"File Uploaded successfully, file size: %v\", size)\n\t\tcase \"/set-reset-multipart-readers-test\":\n\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t_, _ = fmt.Fprintf(w, `{ \"message\": \"error\" }`)\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc createAuthServer(t *testing.T) *httptest.Server {\n\treturn createAuthServerTLSOptional(t, true)\n}\n\nfunc createAuthServerTLSOptional(t *testing.T, useTLS bool) *httptest.Server {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\t\tt.Logf(\"Content-Type: %v\", r.Header.Get(hdrContentTypeKey))\n\n\t\tif r.Method == MethodGet {\n\t\t\tif r.URL.Path == \"/profile\" {\n\t\t\t\t// 004DDB79-6801-4587-B976-F093E6AC44FF\n\t\t\t\tauth := r.Header.Get(\"Authorization\")\n\t\t\t\tt.Logf(\"Bearer Auth: %v\", auth)\n\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\n\t\t\t\tif !strings.HasPrefix(auth, \"Bearer \") {\n\t\t\t\t\tw.Header().Set(\"Www-Authenticate\", \"Protected Realm\")\n\t\t\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"unauthorized\", \"message\": \"Invalid credentials\" }`))\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif auth[7:] == \"004DDB79-6801-4587-B976-F093E6AC44FF\" || auth[7:] == \"004DDB79-6801-4587-B976-F093E6AC44FF-Request\" {\n\t\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"success\", \"message\": \"login successful\" }`))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == MethodPost {\n\t\t\tif r.URL.Path == \"/login\" {\n\t\t\t\tauth := r.Header.Get(\"Authorization\")\n\t\t\t\tt.Logf(\"Basic Auth: %v\", auth)\n\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\n\t\t\t\tpassword, err := base64.StdEncoding.DecodeString(auth[6:])\n\t\t\t\tif err != nil || string(password) != \"myuser:basicauth\" {\n\t\t\t\t\tw.Header().Set(\"Www-Authenticate\", \"Protected Realm\")\n\t\t\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"unauthorized\", \"message\": \"Invalid credentials\" }`))\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"success\", \"message\": \"login successful\" }`))\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t})\n\tif useTLS {\n\t\treturn httptest.NewTLSServer(handler)\n\t}\n\treturn httptest.NewServer(handler)\n}\n\nfunc createGenServer(t *testing.T) *httptest.Server {\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\n\t\tif r.Method == MethodGet {\n\t\t\tif r.URL.Path == \"/json-no-set\" {\n\t\t\t\t// Set empty header value for testing, since Go server sets to\n\t\t\t\t// text/plain; charset=utf-8\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"\")\n\t\t\t\t_, _ = w.Write([]byte(`{\"response\":\"json response no content type set\"}`))\n\t\t\t} else if r.URL.Path == \"/gzip-test\" {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, plainTextType)\n\t\t\t\tw.Header().Set(hdrContentEncodingKey, \"gzip\")\n\t\t\t\tzw := gzip.NewWriter(w)\n\t\t\t\t_, _ = zw.Write([]byte(\"This is Gzip response testing\"))\n\t\t\t\tzw.Close()\n\t\t\t} else if r.URL.Path == \"/gzip-test-gziped-empty-body\" {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, plainTextType)\n\t\t\t\tw.Header().Set(hdrContentEncodingKey, \"gzip\")\n\t\t\t\tzw := gzip.NewWriter(w)\n\t\t\t\t// write gziped empty body\n\t\t\t\t_, _ = zw.Write([]byte(\"\"))\n\t\t\t\tzw.Close()\n\t\t\t} else if r.URL.Path == \"/gzip-test-no-gziped-body\" {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, plainTextType)\n\t\t\t\tw.Header().Set(hdrContentEncodingKey, \"gzip\")\n\t\t\t\t// don't write body\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == MethodPut {\n\t\t\tif r.URL.Path == \"/plaintext\" {\n\t\t\t\t_, _ = w.Write([]byte(\"TestPut: plain text response\"))\n\t\t\t} else if r.URL.Path == \"/json\" {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\t\t\t\t_, _ = w.Write([]byte(`{\"response\":\"json response\"}`))\n\t\t\t} else if r.URL.Path == \"/xml\" {\n\t\t\t\tw.Header().Set(hdrContentTypeKey, \"application/xml\")\n\t\t\t\t_, _ = w.Write([]byte(`<?xml version=\"1.0\" encoding=\"UTF-8\"?><Response>XML response</Response>`))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == MethodOptions && r.URL.Path == \"/options\" {\n\t\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"localhost\")\n\t\t\tw.Header().Set(\"Access-Control-Allow-Methods\", \"PUT, PATCH\")\n\t\t\tw.Header().Set(\"Access-Control-Expose-Headers\", \"x-go-resty-id\")\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == MethodPatch && r.URL.Path == \"/patch\" {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\treturn\n\t\t}\n\n\t\tif r.Method == \"REPORT\" && r.URL.Path == \"/report\" {\n\t\t\tbody, _ := io.ReadAll(r.Body)\n\t\t\tif len(body) == 0 {\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc createRedirectServer(t *testing.T) *httptest.Server {\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\n\t\tif r.Method == MethodGet {\n\t\t\tif strings.HasPrefix(r.URL.Path, \"/redirect-host-check-\") {\n\t\t\t\tcntStr := strings.SplitAfter(r.URL.Path, \"-\")[3]\n\t\t\t\tcnt, _ := strconv.Atoi(cntStr)\n\n\t\t\t\tif cnt != 7 { // Testing hard stop via logical\n\t\t\t\t\tif cnt >= 5 {\n\t\t\t\t\t\thttp.Redirect(w, r, \"http://httpbin.org/get\", http.StatusTemporaryRedirect)\n\t\t\t\t\t} else {\n\t\t\t\t\t\thttp.Redirect(w, r, fmt.Sprintf(\"/redirect-host-check-%d\", cnt+1), http.StatusTemporaryRedirect)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(r.URL.Path, \"/redirect-\") {\n\t\t\t\tcntStr := strings.SplitAfter(r.URL.Path, \"-\")[1]\n\t\t\t\tcnt, _ := strconv.Atoi(cntStr)\n\n\t\t\t\thttp.Redirect(w, r, fmt.Sprintf(\"/redirect-%d\", cnt+1), http.StatusTemporaryRedirect)\n\t\t\t}\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc createUnixSocketEchoServer(t *testing.T) string {\n\tsocketPath := filepath.Join(os.TempDir(), strconv.FormatInt(time.Now().Unix(), 10)) + \".sock\"\n\n\t// Create a Unix domain socket and listen for incoming connections.\n\tsocket, err := net.Listen(\"unix\", socketPath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tm := http.NewServeMux()\n\tm.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hi resty client from a server running on Unix domain socket!\\n\"))\n\t})\n\n\tm.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"Hello resty client from a server running on endpoint /hello!\\n\"))\n\t})\n\n\tgo func(t *testing.T) {\n\t\tserver := http.Server{Handler: m}\n\t\tif err := server.Serve(socket); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}(t)\n\n\treturn socketPath\n}\n\ntype digestServerConfig struct {\n\trealm, qop, nonce, opaque, algo, uri, charset, username, password string\n}\n\nfunc defaultDigestServerConf() *digestServerConfig {\n\treturn &digestServerConfig{\n\t\trealm:    \"testrealm@host.com\",\n\t\tqop:      \"auth\",\n\t\tnonce:    \"dcd98b7102dd2f0e8b11d0f600bfb0c093\",\n\t\topaque:   \"5ccc069c403ebaf9f0171e9517f40e41\",\n\t\talgo:     \"MD5\",\n\t\turi:      \"/dir/index.html\",\n\t\tcharset:  \"utf-8\",\n\t\tusername: \"Mufasa\",\n\t\tpassword: \"Circle Of Life\",\n\t}\n}\n\nfunc createDigestServer(t *testing.T, conf *digestServerConfig) *httptest.Server {\n\tif conf == nil {\n\t\tconf = defaultDigestServerConf()\n\t}\n\n\tsetWWWAuthHeader := func(w http.ResponseWriter, v string) {\n\t\tw.Header().Set(\"WWW-Authenticate\", v)\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t}\n\tts := createTestServer(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Logf(\"Method: %v\", r.Method)\n\t\tt.Logf(\"Path: %v\", r.URL.Path)\n\n\t\tswitch r.URL.Path {\n\t\tcase \"/bad\":\n\t\t\tsetWWWAuthHeader(w, \"Bad Challenge\")\n\t\t\treturn\n\t\tcase \"/unknown_param\":\n\t\t\tsetWWWAuthHeader(w, \"Digest unknown_param=true\")\n\t\t\treturn\n\t\tcase \"/missing_value\":\n\t\t\tsetWWWAuthHeader(w, `Digest realm=\"hello\", domain`)\n\t\t\treturn\n\t\tcase \"/unclosed_quote\":\n\t\t\tsetWWWAuthHeader(w, `Digest realm=\"hello, qop=auth`)\n\t\t\treturn\n\t\tcase \"/no_challenge\":\n\t\t\tsetWWWAuthHeader(w, \"\")\n\t\t\treturn\n\t\tcase \"/status_500\":\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(hdrContentTypeKey, \"application/json; charset=utf-8\")\n\n\t\tif !authorizationHeaderValid(t, r, conf) {\n\t\t\tsetWWWAuthHeader(w,\n\t\t\t\tfmt.Sprintf(`Digest realm=\"%s\", domain=\"%s\", qop=\"%s\", algorithm=%s, nonce=\"%s\", opaque=\"%s\", userhash=true, charset=%s, stale=FALSE`,\n\t\t\t\t\tconf.realm, conf.uri, conf.qop, conf.algo, conf.nonce, conf.opaque, conf.charset))\n\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"unauthorized\", \"message\": \"Invalid credentials\" }`))\n\t\t} else {\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t_, _ = w.Write([]byte(`{ \"id\": \"success\", \"message\": \"login successful\" }`))\n\t\t}\n\t})\n\n\treturn ts\n}\n\nfunc authorizationHeaderValid(t *testing.T, r *http.Request, conf *digestServerConfig) bool {\n\th := func(data string) (string, error) {\n\t\thf := md5.New()\n\n\t\t_, err := io.WriteString(hf, data)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn fmt.Sprintf(\"%x\", hf.Sum(nil)), nil\n\t}\n\tinput := r.Header.Get(hdrAuthorizationKey)\n\tif input == \"\" {\n\t\treturn false\n\t}\n\tconst ws = \" \\n\\r\\t\"\n\tconst qs = `\"`\n\ts := strings.Trim(input, ws)\n\tassertEqual(t, true, strings.HasPrefix(s, \"Digest \"))\n\ts = strings.Trim(s[7:], ws)\n\tsl := strings.Split(s, \", \")\n\n\tpairs := make(map[string]string, len(sl))\n\tfor i := range sl {\n\t\tpair := strings.SplitN(sl[i], \"=\", 2)\n\t\tpairs[pair[0]] = strings.Trim(pair[1], qs)\n\t}\n\n\tassertEqual(t, conf.opaque, pairs[\"opaque\"])\n\tassertEqual(t, conf.algo, pairs[\"algorithm\"])\n\tassertEqual(t, \"true\", pairs[\"userhash\"])\n\n\tuserhash, err := h(fmt.Sprintf(\"%s:%s\", conf.username, conf.realm))\n\tassertError(t, err)\n\tassertEqual(t, userhash, pairs[\"username\"])\n\n\tha1, err := h(fmt.Sprintf(\"%s:%s:%s\", conf.username, conf.realm, conf.password))\n\tassertError(t, err)\n\tif strings.HasSuffix(conf.algo, \"-sess\") {\n\t\tha1, err = h(fmt.Sprintf(\"%s:%s:%s\", ha1, pairs[\"nonce\"], pairs[\"cnonce\"]))\n\t\tassertError(t, err)\n\t}\n\tha2, err := h(fmt.Sprintf(\"%s:%s\", r.Method, conf.uri))\n\tassertError(t, err)\n\tnonceCount, err := strconv.Atoi(pairs[\"nc\"])\n\tassertError(t, err)\n\tkd, err := h(fmt.Sprintf(\"%s:%s\", ha1, fmt.Sprintf(\"%s:%08x:%s:%s:%s\",\n\t\tpairs[\"nonce\"], nonceCount, pairs[\"cnonce\"], pairs[\"qop\"], ha2)))\n\tassertError(t, err)\n\n\treturn kd == pairs[\"response\"]\n}\n\nfunc createTestServer(fn func(w http.ResponseWriter, r *http.Request)) *httptest.Server {\n\treturn httptest.NewServer(http.HandlerFunc(fn))\n}\n\nfunc dc() *Client {\n\tc := New().\n\t\toutputLogTo(io.Discard)\n\treturn c\n}\n\nfunc dcl() *Client {\n\tc := New().\n\t\tSetDebug(true).\n\t\toutputLogTo(io.Discard)\n\treturn c\n}\n\nfunc dcr() *Request {\n\treturn dc().R()\n}\n\nfunc dclr() *Request {\n\tc := dc().\n\t\tSetDebug(true).\n\t\toutputLogTo(io.Discard)\n\treturn c.R()\n}\n\nfunc assertNil(t *testing.T, v interface{}) {\n\tt.Helper()\n\tif !isNil(v) {\n\t\tt.Errorf(\"[%v] was expected to be nil\", v)\n\t}\n}\n\nfunc assertNotNil(t *testing.T, v interface{}) {\n\tif isNil(v) {\n\t\tt.Errorf(\"[%v] was expected to be non-nil\", v)\n\t}\n}\n\nfunc assertType(t *testing.T, typ, v interface{}) {\n\tif reflect.DeepEqual(reflect.TypeOf(typ), reflect.TypeOf(v)) {\n\t\tt.Errorf(\"Expected type %t, got %t\", typ, v)\n\t}\n}\n\nfunc assertError(t *testing.T, err error) {\n\tif err != nil {\n\t\tt.Errorf(\"Error occurred [%v]\", err)\n\t}\n}\n\nfunc assertErrorIs(t *testing.T, e, g error) (r bool) {\n\tif !errors.Is(g, e) {\n\t\tt.Errorf(\"Expected [%v], got [%v]\", e, g)\n\t}\n\n\treturn true\n}\n\nfunc assertEqual(t *testing.T, e, g interface{}) (r bool) {\n\tt.Helper()\n\tif !equal(e, g) {\n\t\tt.Errorf(\"Expected [%v], got [%v]\", e, g)\n\t}\n\n\treturn\n}\n\nfunc assertNotEqual(t *testing.T, e, g interface{}) (r bool) {\n\tif equal(e, g) {\n\t\tt.Errorf(\"Expected [%v], got [%v]\", e, g)\n\t} else {\n\t\tr = true\n\t}\n\n\treturn\n}\n\nfunc equal(expected, got interface{}) bool {\n\treturn reflect.DeepEqual(expected, got)\n}\n\nfunc isNil(v interface{}) bool {\n\tif v == nil {\n\t\treturn true\n\t}\n\n\trv := reflect.ValueOf(v)\n\tkind := rv.Kind()\n\tif kind >= reflect.Chan && kind <= reflect.Slice && rv.IsNil() {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc logResponse(t *testing.T, resp *Response) {\n\tt.Logf(\"Response Status: %v\", resp.Status())\n\tt.Logf(\"Response Time: %v\", resp.Time())\n\tt.Logf(\"Response Headers: %v\", resp.Header())\n\tt.Logf(\"Response Cookies: %v\", resp.Cookies())\n\tt.Logf(\"Response Body: %v\", resp)\n}\n\nfunc cleanupFiles(files ...string) {\n\tpwd, _ := os.Getwd()\n\n\tfor _, f := range files {\n\t\tif filepath.IsAbs(f) {\n\t\t\t_ = os.RemoveAll(f)\n\t\t} else {\n\t\t\t_ = os.RemoveAll(filepath.Join(pwd, f))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "retry.go",
          "type": "blob",
          "size": 5.8486328125,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"sync\"\n\t\"time\"\n)\n\nconst (\n\tdefaultMaxRetries  = 3\n\tdefaultWaitTime    = time.Duration(100) * time.Millisecond\n\tdefaultMaxWaitTime = time.Duration(2000) * time.Millisecond\n)\n\ntype (\n\t// Option is to create convenient retry options like wait time, max retries, etc.\n\tOption func(*Options)\n\n\t// RetryConditionFunc type is for the retry condition function\n\t// input: non-nil Response OR request execution error\n\tRetryConditionFunc func(*Response, error) bool\n\n\t// OnRetryFunc is for side-effecting functions triggered on retry\n\tOnRetryFunc func(*Response, error)\n\n\t// RetryAfterFunc returns time to wait before retry\n\t// For example, it can parse HTTP Retry-After header\n\t// https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\n\t// Non-nil error is returned if it is found that the request is not retryable\n\t// (0, nil) is a special result that means 'use default algorithm'\n\tRetryAfterFunc func(*Client, *Response) (time.Duration, error)\n\n\t// Options struct is used to hold retry settings.\n\tOptions struct {\n\t\tmaxRetries      int\n\t\twaitTime        time.Duration\n\t\tmaxWaitTime     time.Duration\n\t\tretryConditions []RetryConditionFunc\n\t\tretryHooks      []OnRetryFunc\n\t\tresetReaders    bool\n\t}\n)\n\n// Retries sets the max number of retries\nfunc Retries(value int) Option {\n\treturn func(o *Options) {\n\t\to.maxRetries = value\n\t}\n}\n\n// WaitTime sets the default wait time to sleep between requests\nfunc WaitTime(value time.Duration) Option {\n\treturn func(o *Options) {\n\t\to.waitTime = value\n\t}\n}\n\n// MaxWaitTime sets the max wait time to sleep between requests\nfunc MaxWaitTime(value time.Duration) Option {\n\treturn func(o *Options) {\n\t\to.maxWaitTime = value\n\t}\n}\n\n// RetryConditions sets the conditions that will be checked for retry\nfunc RetryConditions(conditions []RetryConditionFunc) Option {\n\treturn func(o *Options) {\n\t\to.retryConditions = conditions\n\t}\n}\n\n// RetryHooks sets the hooks that will be executed after each retry\nfunc RetryHooks(hooks []OnRetryFunc) Option {\n\treturn func(o *Options) {\n\t\to.retryHooks = hooks\n\t}\n}\n\n// ResetMultipartReaders sets a boolean value which will lead the start being seeked out\n// on all multipart file readers if they implement [io.ReadSeeker]\nfunc ResetMultipartReaders(value bool) Option {\n\treturn func(o *Options) {\n\t\to.resetReaders = value\n\t}\n}\n\n// Backoff retries with increasing timeout duration up until X amount of retries\n// (Default is 3 attempts, Override with option Retries(n))\nfunc Backoff(operation func() (*Response, error), options ...Option) error {\n\t// Defaults\n\topts := Options{\n\t\tmaxRetries:      defaultMaxRetries,\n\t\twaitTime:        defaultWaitTime,\n\t\tmaxWaitTime:     defaultMaxWaitTime,\n\t\tretryConditions: []RetryConditionFunc{},\n\t}\n\n\tfor _, o := range options {\n\t\to(&opts)\n\t}\n\n\tvar (\n\t\tresp *Response\n\t\terr  error\n\t)\n\n\tfor attempt := 0; attempt <= opts.maxRetries; attempt++ {\n\t\tresp, err = operation()\n\t\tctx := context.Background()\n\t\tif resp != nil && resp.Request.ctx != nil {\n\t\t\tctx = resp.Request.ctx\n\t\t}\n\t\tif ctx.Err() != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr1 := unwrapNoRetryErr(err)           // raw error, it used for return users callback.\n\t\tneedsRetry := err != nil && err == err1 // retry on a few operation errors by default\n\n\t\tfor _, condition := range opts.retryConditions {\n\t\t\tneedsRetry = condition(resp, err1)\n\t\t\tif needsRetry {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !needsRetry {\n\t\t\treturn err\n\t\t}\n\n\t\tif opts.resetReaders {\n\t\t\tif err := resetFileReaders(resp.Request.multipartFiles); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tfor _, hook := range opts.retryHooks {\n\t\t\thook(resp, err)\n\t\t}\n\n\t\t// Don't need to wait when no retries left.\n\t\t// Still run retry hooks even on last retry to keep compatibility.\n\t\tif attempt == opts.maxRetries {\n\t\t\treturn err\n\t\t}\n\n\t\twaitTime, err2 := sleepDuration(resp, opts.waitTime, opts.maxWaitTime, attempt)\n\t\tif err2 != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = err2\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tselect {\n\t\tcase <-time.After(waitTime):\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\t}\n\n\treturn err\n}\n\nfunc sleepDuration(resp *Response, min, max time.Duration, attempt int) (time.Duration, error) {\n\tconst maxInt = 1<<31 - 1 // max int for arch 386\n\tif max < 0 {\n\t\tmax = maxInt\n\t}\n\tif resp == nil {\n\t\treturn jitterBackoff(min, max, attempt), nil\n\t}\n\n\tretryAfterFunc := resp.Request.client.RetryAfter\n\n\t// Check for custom callback\n\tif retryAfterFunc == nil {\n\t\treturn jitterBackoff(min, max, attempt), nil\n\t}\n\n\tresult, err := retryAfterFunc(resp.Request.client, resp)\n\tif err != nil {\n\t\treturn 0, err // i.e. 'API quota exceeded'\n\t}\n\tif result == 0 {\n\t\treturn jitterBackoff(min, max, attempt), nil\n\t}\n\tif result < 0 || max < result {\n\t\tresult = max\n\t}\n\tif result < min {\n\t\tresult = min\n\t}\n\treturn result, nil\n}\n\n// Return capped exponential backoff with jitter\n// https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\nfunc jitterBackoff(min, max time.Duration, attempt int) time.Duration {\n\tbase := float64(min)\n\tcapLevel := float64(max)\n\n\ttemp := math.Min(capLevel, base*math.Exp2(float64(attempt)))\n\tri := time.Duration(temp / 2)\n\tif ri == 0 {\n\t\tri = time.Nanosecond\n\t}\n\tresult := randDuration(ri)\n\n\tif result < min {\n\t\tresult = min\n\t}\n\n\treturn result\n}\n\nvar rnd = newRnd()\nvar rndMu sync.Mutex\n\nfunc randDuration(center time.Duration) time.Duration {\n\trndMu.Lock()\n\tdefer rndMu.Unlock()\n\n\tvar ri = int64(center)\n\tvar jitter = rnd.Int63n(ri)\n\treturn time.Duration(math.Abs(float64(ri + jitter)))\n}\n\nfunc newRnd() *rand.Rand {\n\tvar seed = time.Now().UnixNano()\n\tvar src = rand.NewSource(seed)\n\treturn rand.New(src)\n}\n\nfunc resetFileReaders(files []*File) error {\n\tfor _, f := range files {\n\t\tif rs, ok := f.Reader.(io.ReadSeeker); ok {\n\t\t\tif _, err := rs.Seek(0, io.SeekStart); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "retry_test.go",
          "type": "blob",
          "size": 21.158203125,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestBackoffSuccess(t *testing.T) {\n\tattempts := 3\n\texternalCounter := 0\n\tretryErr := Backoff(func() (*Response, error) {\n\t\texternalCounter++\n\t\tif externalCounter < attempts {\n\t\t\treturn nil, errors.New(\"not yet got the number we're after\")\n\t\t}\n\n\t\treturn nil, nil\n\t})\n\n\tassertError(t, retryErr)\n\tassertEqual(t, externalCounter, attempts)\n}\n\nfunc TestBackoffNoWaitForLastRetry(t *testing.T) {\n\tattempts := 1\n\texternalCounter := 0\n\tnumRetries := 1\n\n\tcanceledCtx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\tresp := &Response{\n\t\tRequest: &Request{\n\t\t\tctx: canceledCtx,\n\t\t\tclient: &Client{\n\t\t\t\tRetryAfter: func(*Client, *Response) (time.Duration, error) {\n\t\t\t\t\treturn 6, nil\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tretryErr := Backoff(func() (*Response, error) {\n\t\texternalCounter++\n\t\treturn resp, nil\n\t}, RetryConditions([]RetryConditionFunc{func(response *Response, err error) bool {\n\t\tif externalCounter == attempts+numRetries {\n\t\t\t// Backoff returns context canceled if goes to sleep after last retry.\n\t\t\tcancel()\n\t\t}\n\t\treturn true\n\t}}), Retries(numRetries))\n\n\tassertNil(t, retryErr)\n}\n\nfunc TestBackoffTenAttemptsSuccess(t *testing.T) {\n\tattempts := 10\n\texternalCounter := 0\n\tretryErr := Backoff(func() (*Response, error) {\n\t\texternalCounter++\n\t\tif externalCounter < attempts {\n\t\t\treturn nil, errors.New(\"not yet got the number we're after\")\n\t\t}\n\t\treturn nil, nil\n\t}, Retries(attempts), WaitTime(5), MaxWaitTime(500))\n\n\tassertError(t, retryErr)\n\tassertEqual(t, externalCounter, attempts)\n}\n\n// Check to make sure the conditional of the retry condition is being used\nfunc TestConditionalBackoffCondition(t *testing.T) {\n\tattempts := 3\n\tcounter := 0\n\tcheck := RetryConditionFunc(func(*Response, error) bool {\n\t\treturn attempts != counter\n\t})\n\tretryErr := Backoff(func() (*Response, error) {\n\t\tcounter++\n\t\treturn nil, nil\n\t}, RetryConditions([]RetryConditionFunc{check}))\n\n\tassertError(t, retryErr)\n\tassertEqual(t, counter, attempts)\n}\n\n// Check to make sure that if the conditional is false we don't retry\nfunc TestConditionalBackoffConditionNonExecution(t *testing.T) {\n\tattempts := 3\n\tcounter := 0\n\n\tretryErr := Backoff(func() (*Response, error) {\n\t\tcounter++\n\t\treturn nil, nil\n\t}, RetryConditions([]RetryConditionFunc{filler}))\n\n\tassertError(t, retryErr)\n\tassertNotEqual(t, counter, attempts)\n}\n\n// Check to make sure that RetryHooks are executed\nfunc TestOnRetryBackoff(t *testing.T) {\n\tattempts := 3\n\tcounter := 0\n\n\thook := func(r *Response, err error) {\n\t\tcounter++\n\t}\n\n\tretryErr := Backoff(func() (*Response, error) {\n\t\treturn nil, nil\n\t}, RetryHooks([]OnRetryFunc{hook}))\n\n\tassertError(t, retryErr)\n\tassertNotEqual(t, counter, attempts)\n}\n\n// Check to make sure the functions added to add conditionals work\nfunc TestConditionalGet(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\tattemptCount := 1\n\texternalCounter := 0\n\n\t// This check should pass on first run, and let the response through\n\tcheck := RetryConditionFunc(func(*Response, error) bool {\n\t\texternalCounter++\n\t\treturn attemptCount != externalCounter\n\t})\n\n\tclient := dc().AddRetryCondition(check).SetRetryCount(1)\n\tresp, err := client.R().\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\tassertEqual(t, externalCounter, attemptCount)\n\n\tlogResponse(t, resp)\n}\n\n// Check to make sure the package Function works.\nfunc TestConditionalGetDefaultClient(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\tattemptCount := 1\n\texternalCounter := 0\n\n\t// This check should pass on first run, and let the response through\n\tcheck := RetryConditionFunc(func(*Response, error) bool {\n\t\texternalCounter++\n\t\treturn attemptCount != externalCounter\n\t})\n\n\t// Clear the default client.\n\tclient := dc()\n\t// Proceed to check.\n\tclient.AddRetryCondition(check).SetRetryCount(1)\n\tresp, err := client.R().\n\t\tSetQueryParam(\"request_no\", strconv.FormatInt(time.Now().Unix(), 10)).\n\t\tGet(ts.URL + \"/\")\n\n\tassertError(t, err)\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"200 OK\", resp.Status())\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, \"TestGet: text response\", resp.String())\n\tassertEqual(t, externalCounter, attemptCount)\n\n\tlogResponse(t, resp)\n}\n\nfunc TestClientRetryGet(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetTimeout(time.Second * 3).\n\t\tSetRetryCount(3)\n\n\tresp, err := c.R().Get(ts.URL + \"/set-retrycount-test\")\n\tassertEqual(t, \"\", resp.Status())\n\tassertEqual(t, \"\", resp.Proto())\n\tassertEqual(t, 0, resp.StatusCode())\n\tassertEqual(t, 0, len(resp.Cookies()))\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, 0, len(resp.Header()))\n\n\tassertEqual(t, true, strings.HasPrefix(err.Error(), \"Get \"+ts.URL+\"/set-retrycount-test\") ||\n\t\tstrings.HasPrefix(err.Error(), \"Get \\\"\"+ts.URL+\"/set-retrycount-test\\\"\"))\n}\n\nfunc TestClientRetryWait(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := time.Duration(50) * time.Millisecond\n\tretryMaxWaitTime := time.Duration(150) * time.Millisecond\n\n\tc := dc().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\t_, _ = c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 6 attempts were made\n\tassertEqual(t, attempt, 6)\n\n\t// Initial attempt has 0 time slept since last request\n\tassertEqual(t, retryIntervals[0], uint64(0))\n\n\tfor i := 1; i < len(retryIntervals); i++ {\n\t\tslept := time.Duration(retryIntervals[i])\n\t\t// Ensure that client has slept some duration between\n\t\t// waitTime and maxWaitTime for consequent requests\n\t\tif slept < retryWaitTime || slept > retryMaxWaitTime {\n\t\t\tt.Errorf(\"Client has slept %f seconds before retry %d\", slept.Seconds(), i)\n\t\t}\n\t}\n}\n\nfunc TestClientRetryWaitMaxInfinite(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := time.Duration(100) * time.Millisecond\n\tretryMaxWaitTime := time.Duration(-1.0) // negative value\n\n\tc := dc().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\t_, _ = c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 6 attempts were made\n\tassertEqual(t, attempt, 6)\n\n\t// Initial attempt has 0 time slept since last request\n\tassertEqual(t, retryIntervals[0], uint64(0))\n\n\tfor i := 1; i < len(retryIntervals); i++ {\n\t\tslept := time.Duration(retryIntervals[i])\n\t\t// Ensure that client has slept some duration between\n\t\t// waitTime and maxWaitTime for consequent requests\n\t\tif slept < retryWaitTime {\n\t\t\tt.Errorf(\"Client has slept %f seconds before retry %d\", slept.Seconds(), i)\n\t\t}\n\t}\n}\n\nfunc TestClientRetryWaitMaxMinimum(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tconst retryMaxWaitTime = time.Nanosecond // minimal duration value\n\n\tc := dc().\n\t\tSetRetryCount(1).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tAddRetryCondition(func(*Response, error) bool { return true })\n\t_, err := c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\tassertError(t, err)\n}\n\nfunc TestClientRetryWaitCallbackError(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := 50 * time.Millisecond\n\tretryMaxWaitTime := 150 * time.Millisecond\n\n\tretryAfter := func(client *Client, resp *Response) (time.Duration, error) {\n\t\treturn 0, errors.New(\"quota exceeded\")\n\t}\n\n\tc := dc().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tSetRetryAfter(retryAfter).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\n\t_, err := c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 1 attempts were made\n\tassertEqual(t, attempt, 1)\n\n\t// non-nil error was returned\n\tassertNotEqual(t, nil, err)\n}\n\nfunc TestClientRetryWaitCallback(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := 50 * time.Millisecond\n\tretryMaxWaitTime := 150 * time.Millisecond\n\n\tretryAfter := func(client *Client, resp *Response) (time.Duration, error) {\n\t\treturn 50 * time.Millisecond, nil\n\t}\n\n\tc := dc().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tSetRetryAfter(retryAfter).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\t_, _ = c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 6 attempts were made\n\tassertEqual(t, attempt, 6)\n\n\t// Initial attempt has 0 time slept since last request\n\tassertEqual(t, retryIntervals[0], uint64(0))\n\n\tfor i := 1; i < len(retryIntervals); i++ {\n\t\tslept := time.Duration(retryIntervals[i])\n\t\t// Ensure that client has slept some duration between\n\t\t// waitTime and maxWaitTime for consequent requests\n\t\tif slept < 5*time.Second-5*time.Millisecond || 5*time.Second+5*time.Millisecond < slept {\n\t\t\tt.Logf(\"Client has slept %f seconds before retry %d\", slept.Seconds(), i)\n\t\t}\n\t}\n}\n\nfunc TestClientRetryWaitCallbackTooShort(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := 50 * time.Millisecond\n\tretryMaxWaitTime := 150 * time.Millisecond\n\n\tretryAfter := func(client *Client, resp *Response) (time.Duration, error) {\n\t\treturn 10 * time.Millisecond, nil // too short duration\n\t}\n\n\tc := dc().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tSetRetryAfter(retryAfter).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\t_, _ = c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 6 attempts were made\n\tassertEqual(t, attempt, 6)\n\n\t// Initial attempt has 0 time slept since last request\n\tassertEqual(t, retryIntervals[0], uint64(0))\n\n\tfor i := 1; i < len(retryIntervals); i++ {\n\t\tslept := time.Duration(retryIntervals[i])\n\t\t// Ensure that client has slept some duration between\n\t\t// waitTime and maxWaitTime for consequent requests\n\t\tif slept < retryWaitTime-5*time.Millisecond || retryWaitTime+5*time.Millisecond < slept {\n\t\t\tt.Logf(\"Client has slept %f seconds before retry %d\", slept.Seconds(), i)\n\t\t}\n\t}\n}\n\nfunc TestClientRetryWaitCallbackTooLong(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := 10 * time.Millisecond\n\tretryMaxWaitTime := 100 * time.Millisecond\n\n\tretryAfter := func(client *Client, resp *Response) (time.Duration, error) {\n\t\treturn 150 * time.Millisecond, nil // too long duration\n\t}\n\n\tc := dc().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tSetRetryAfter(retryAfter).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\t_, _ = c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 6 attempts were made\n\tassertEqual(t, attempt, 6)\n\n\t// Initial attempt has 0 time slept since last request\n\tassertEqual(t, retryIntervals[0], uint64(0))\n\n\tfor i := 1; i < len(retryIntervals); i++ {\n\t\tslept := time.Duration(retryIntervals[i])\n\t\t// Ensure that client has slept some duration between\n\t\t// waitTime and maxWaitTime for consequent requests\n\t\tif slept < retryMaxWaitTime-5*time.Millisecond || retryMaxWaitTime+5*time.Millisecond < slept {\n\t\t\tt.Logf(\"Client has slept %f seconds before retry %d\", slept.Seconds(), i)\n\t\t}\n\t}\n}\n\nfunc TestClientRetryWaitCallbackSwitchToDefault(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := 1 * time.Second\n\tretryMaxWaitTime := 3 * time.Second\n\n\tretryAfter := func(client *Client, resp *Response) (time.Duration, error) {\n\t\treturn 0, nil // use default algorithm to determine retry-after time\n\t}\n\n\tc := dc().\n\t\tEnableTrace().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tSetRetryAfter(retryAfter).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\tresp, _ := c.R().Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 6 attempts were made\n\tassertEqual(t, attempt, 6)\n\tassertEqual(t, resp.Request.Attempt, 6)\n\tassertEqual(t, resp.Request.TraceInfo().RequestAttempt, 6)\n\n\t// Initial attempt has 0 time slept since last request\n\tassertEqual(t, retryIntervals[0], uint64(0))\n\n\tfor i := 1; i < len(retryIntervals); i++ {\n\t\tslept := time.Duration(retryIntervals[i])\n\t\texpected := (1 << (uint(i - 1))) * time.Second\n\t\tif expected > retryMaxWaitTime {\n\t\t\texpected = retryMaxWaitTime\n\t\t}\n\n\t\t// Ensure that client has slept some duration between\n\t\t// waitTime and maxWaitTime for consequent requests\n\t\tif slept < expected/2-5*time.Millisecond || expected+5*time.Millisecond < slept {\n\t\t\tt.Errorf(\"Client has slept %f seconds before retry %d\", slept.Seconds(), i)\n\t\t}\n\t}\n}\n\nfunc TestClientRetryCancel(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tretryCount := 5\n\tretryIntervals := make([]uint64, retryCount+1)\n\n\t// Set retry wait times that do not intersect with default ones\n\tretryWaitTime := time.Duration(10) * time.Second\n\tretryMaxWaitTime := time.Duration(20) * time.Second\n\n\tc := dc().\n\t\tSetRetryCount(retryCount).\n\t\tSetRetryWaitTime(retryWaitTime).\n\t\tSetRetryMaxWaitTime(retryMaxWaitTime).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\ttimeSlept, _ := strconv.ParseUint(string(r.Body()), 10, 64)\n\t\t\t\tretryIntervals[attempt] = timeSlept\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\n\ttimeout := 2 * time.Second\n\n\tctx, cancelFunc := context.WithTimeout(context.Background(), timeout)\n\t_, _ = c.R().SetContext(ctx).Get(ts.URL + \"/set-retrywaittime-test\")\n\n\t// 1 attempts were made\n\tassertEqual(t, attempt, 1)\n\n\t// Initial attempt has 0 time slept since last request\n\tassertEqual(t, retryIntervals[0], uint64(0))\n\n\t// Second attempt should be interrupted on context timeout\n\tif time.Duration(retryIntervals[1]) > timeout {\n\t\tt.Errorf(\"Client didn't awake on context cancel\")\n\t}\n\tcancelFunc()\n}\n\nfunc TestClientRetryPost(t *testing.T) {\n\tts := createPostServer(t)\n\tdefer ts.Close()\n\n\tusersmap := map[string]interface{}{\n\t\t\"user1\": map[string]interface{}{\"FirstName\": \"firstname1\", \"LastName\": \"lastname1\", \"ZipCode\": \"10001\"},\n\t}\n\n\tvar users []map[string]interface{}\n\tusers = append(users, usersmap)\n\n\tc := dc()\n\tc.SetRetryCount(3)\n\tc.AddRetryCondition(RetryConditionFunc(func(r *Response, _ error) bool {\n\t\treturn r.StatusCode() >= http.StatusInternalServerError\n\t}))\n\n\tresp, _ := c.R().\n\t\tSetBody(&users).\n\t\tPost(ts.URL + \"/usersmap?status=500\")\n\n\tif resp != nil {\n\t\tif resp.StatusCode() == http.StatusInternalServerError {\n\t\t\tt.Logf(\"Got response body: %s\", resp.String())\n\t\t\tvar usersResponse []map[string]interface{}\n\t\t\terr := json.Unmarshal(resp.body, &usersResponse)\n\t\t\tassertError(t, err)\n\n\t\t\tif !reflect.DeepEqual(users, usersResponse) {\n\t\t\t\tt.Errorf(\"Expected request body to be echoed back as response body. Instead got: %s\", resp.String())\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t\tt.Errorf(\"Got unexpected response code: %d with body: %s\", resp.StatusCode(), resp.String())\n\t}\n}\n\nfunc TestClientRetryErrorRecover(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetRetryCount(2).\n\t\tSetError(AuthError{}).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\terr, ok := r.Error().(*AuthError)\n\t\t\t\tretry := ok && r.StatusCode() == 429 && err.Message == \"too many\"\n\t\t\t\treturn retry\n\t\t\t},\n\t\t)\n\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\tSetJSONEscapeHTML(false).\n\t\tSetResult(AuthSuccess{}).\n\t\tGet(ts.URL + \"/set-retry-error-recover\")\n\n\tassertError(t, err)\n\n\tauthSuccess := resp.Result().(*AuthSuccess)\n\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"hello\", authSuccess.Message)\n\n\tassertNil(t, resp.Error())\n}\n\nfunc TestClientRetryCount(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tc := dc().\n\t\tSetTimeout(time.Second * 3).\n\t\tSetRetryCount(1).\n\t\tAddRetryCondition(\n\t\t\tfunc(r *Response, _ error) bool {\n\t\t\t\tattempt++\n\t\t\t\treturn true\n\t\t\t},\n\t\t)\n\n\tresp, err := c.R().Get(ts.URL + \"/set-retrycount-test\")\n\tassertEqual(t, \"\", resp.Status())\n\tassertEqual(t, \"\", resp.Proto())\n\tassertEqual(t, 0, resp.StatusCode())\n\tassertEqual(t, 0, len(resp.Cookies()))\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, 0, len(resp.Header()))\n\n\t// 2 attempts were made\n\tassertEqual(t, attempt, 2)\n\n\tassertEqual(t, true, strings.HasPrefix(err.Error(), \"Get \"+ts.URL+\"/set-retrycount-test\") ||\n\t\tstrings.HasPrefix(err.Error(), \"Get \\\"\"+ts.URL+\"/set-retrycount-test\\\"\"))\n}\n\nfunc TestClientErrorRetry(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tc := dc().\n\t\tSetTimeout(time.Second * 3).\n\t\tSetRetryCount(1).\n\t\tAddRetryAfterErrorCondition()\n\n\tresp, err := c.R().\n\t\tSetHeader(hdrContentTypeKey, \"application/json; charset=utf-8\").\n\t\tSetJSONEscapeHTML(false).\n\t\tSetResult(AuthSuccess{}).\n\t\tGet(ts.URL + \"/set-retry-error-recover\")\n\n\tassertError(t, err)\n\n\tauthSuccess := resp.Result().(*AuthSuccess)\n\n\tassertEqual(t, http.StatusOK, resp.StatusCode())\n\tassertEqual(t, \"hello\", authSuccess.Message)\n\n\tassertNil(t, resp.Error())\n}\n\nfunc TestClientRetryHook(t *testing.T) {\n\tts := createGetServer(t)\n\tdefer ts.Close()\n\n\tattempt := 0\n\n\tc := dc().\n\t\tSetRetryCount(2).\n\t\tSetTimeout(time.Second * 3).\n\t\tAddRetryHook(\n\t\t\tfunc(r *Response, _ error) {\n\t\t\t\tattempt++\n\t\t\t},\n\t\t)\n\n\tresp, err := c.R().Get(ts.URL + \"/set-retrycount-test\")\n\tassertEqual(t, \"\", resp.Status())\n\tassertEqual(t, \"\", resp.Proto())\n\tassertEqual(t, 0, resp.StatusCode())\n\tassertEqual(t, 0, len(resp.Cookies()))\n\tassertNotNil(t, resp.Body())\n\tassertEqual(t, 0, len(resp.Header()))\n\n\tassertEqual(t, 3, attempt)\n\n\tassertEqual(t, true, strings.HasPrefix(err.Error(), \"Get \"+ts.URL+\"/set-retrycount-test\") ||\n\t\tstrings.HasPrefix(err.Error(), \"Get \\\"\"+ts.URL+\"/set-retrycount-test\\\"\"))\n}\n\nfunc filler(*Response, error) bool {\n\treturn false\n}\n\nvar errSeekFailure = fmt.Errorf(\"failing seek test\")\n\ntype failingSeeker struct {\n\treader *bytes.Reader\n}\n\nfunc (f failingSeeker) Read(b []byte) (n int, err error) {\n\treturn f.reader.Read(b)\n}\n\nfunc (f failingSeeker) Seek(offset int64, whence int) (int64, error) {\n\tif offset == 0 && whence == io.SeekStart {\n\t\treturn 0, errSeekFailure\n\t}\n\n\treturn f.reader.Seek(offset, whence)\n}\n\nfunc TestResetMultipartReaderSeekStartError(t *testing.T) {\n\tts := createFilePostServer(t)\n\tdefer ts.Close()\n\n\ttestSeeker := &failingSeeker{\n\t\tbytes.NewReader([]byte(\"test\")),\n\t}\n\n\tc := dc().\n\t\tSetRetryCount(2).\n\t\tSetTimeout(time.Second * 3).\n\t\tSetRetryResetReaders(true).\n\t\tAddRetryAfterErrorCondition()\n\n\tresp, err := c.R().\n\t\tSetFileReader(\"name\", \"filename\", testSeeker).\n\t\tPost(ts.URL + \"/set-reset-multipart-readers-test\")\n\n\tassertEqual(t, 500, resp.StatusCode())\n\tassertEqual(t, err.Error(), errSeekFailure.Error())\n}\n\nfunc TestResetMultipartReaders(t *testing.T) {\n\tts := createFilePostServer(t)\n\tdefer ts.Close()\n\n\tstr := \"test\"\n\tbuf := []byte(str)\n\n\tbufReader := bytes.NewReader(buf)\n\tbufCpy := make([]byte, len(buf))\n\n\tc := dc().\n\t\tSetRetryCount(2).\n\t\tSetTimeout(time.Second * 3).\n\t\tSetRetryResetReaders(true).\n\t\tAddRetryAfterErrorCondition().\n\t\tAddRetryHook(\n\t\t\tfunc(response *Response, _ error) {\n\t\t\t\tread, err := bufReader.Read(bufCpy)\n\n\t\t\t\tassertNil(t, err)\n\t\t\t\tassertEqual(t, len(buf), read)\n\t\t\t\tassertEqual(t, str, string(bufCpy))\n\t\t\t},\n\t\t)\n\n\tresp, err := c.R().\n\t\tSetFileReader(\"name\", \"filename\", bufReader).\n\t\tPost(ts.URL + \"/set-reset-multipart-readers-test\")\n\n\tassertEqual(t, 500, resp.StatusCode())\n\tassertNil(t, err)\n}\n"
        },
        {
          "name": "shellescape",
          "type": "tree",
          "content": null
        },
        {
          "name": "trace.go",
          "type": "blob",
          "size": 3.814453125,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http/httptrace\"\n\t\"time\"\n)\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// TraceInfo struct\n//_______________________________________________________________________\n\n// TraceInfo struct is used to provide request trace info such as DNS lookup\n// duration, Connection obtain duration, Server processing duration, etc.\ntype TraceInfo struct {\n\t// DNSLookup is the duration that transport took to perform\n\t// DNS lookup.\n\tDNSLookup time.Duration\n\n\t// ConnTime is the duration it took to obtain a successful connection.\n\tConnTime time.Duration\n\n\t// TCPConnTime is the duration it took to obtain the TCP connection.\n\tTCPConnTime time.Duration\n\n\t// TLSHandshake is the duration of the TLS handshake.\n\tTLSHandshake time.Duration\n\n\t// ServerTime is the server's duration for responding to the first byte.\n\tServerTime time.Duration\n\n\t// ResponseTime is the duration since the first response byte from the server to\n\t// request completion.\n\tResponseTime time.Duration\n\n\t// TotalTime is the duration of the total time request taken end-to-end.\n\tTotalTime time.Duration\n\n\t// IsConnReused is whether this connection has been previously\n\t// used for another HTTP request.\n\tIsConnReused bool\n\n\t// IsConnWasIdle is whether this connection was obtained from an\n\t// idle pool.\n\tIsConnWasIdle bool\n\n\t// ConnIdleTime is the duration how long the connection that was previously\n\t// idle, if IsConnWasIdle is true.\n\tConnIdleTime time.Duration\n\n\t// RequestAttempt is to represent the request attempt made during a Resty\n\t// request execution flow, including retry count.\n\tRequestAttempt int\n\n\t// RemoteAddr returns the remote network address.\n\tRemoteAddr net.Addr\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// ClientTrace struct and its methods\n//_______________________________________________________________________\n\n// clientTrace struct maps the [httptrace.ClientTrace] hooks into Fields\n// with the same naming for easy understanding. Plus additional insights\n// [Request].\ntype clientTrace struct {\n\tgetConn              time.Time\n\tdnsStart             time.Time\n\tdnsDone              time.Time\n\tconnectDone          time.Time\n\ttlsHandshakeStart    time.Time\n\ttlsHandshakeDone     time.Time\n\tgotConn              time.Time\n\tgotFirstResponseByte time.Time\n\tendTime              time.Time\n\tgotConnInfo          httptrace.GotConnInfo\n}\n\nfunc (t *clientTrace) createContext(ctx context.Context) context.Context {\n\treturn httptrace.WithClientTrace(\n\t\tctx,\n\t\t&httptrace.ClientTrace{\n\t\t\tDNSStart: func(_ httptrace.DNSStartInfo) {\n\t\t\t\tt.dnsStart = time.Now()\n\t\t\t},\n\t\t\tDNSDone: func(_ httptrace.DNSDoneInfo) {\n\t\t\t\tt.dnsDone = time.Now()\n\t\t\t},\n\t\t\tConnectStart: func(_, _ string) {\n\t\t\t\tif t.dnsDone.IsZero() {\n\t\t\t\t\tt.dnsDone = time.Now()\n\t\t\t\t}\n\t\t\t\tif t.dnsStart.IsZero() {\n\t\t\t\t\tt.dnsStart = t.dnsDone\n\t\t\t\t}\n\t\t\t},\n\t\t\tConnectDone: func(net, addr string, err error) {\n\t\t\t\tt.connectDone = time.Now()\n\t\t\t},\n\t\t\tGetConn: func(_ string) {\n\t\t\t\tt.getConn = time.Now()\n\t\t\t},\n\t\t\tGotConn: func(ci httptrace.GotConnInfo) {\n\t\t\t\tt.gotConn = time.Now()\n\t\t\t\tt.gotConnInfo = ci\n\t\t\t},\n\t\t\tGotFirstResponseByte: func() {\n\t\t\t\tt.gotFirstResponseByte = time.Now()\n\t\t\t},\n\t\t\tTLSHandshakeStart: func() {\n\t\t\t\tt.tlsHandshakeStart = time.Now()\n\t\t\t},\n\t\t\tTLSHandshakeDone: func(_ tls.ConnectionState, _ error) {\n\t\t\t\tt.tlsHandshakeDone = time.Now()\n\t\t\t},\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "transport.go",
          "type": "blob",
          "size": 0.8740234375,
          "content": "//go:build go1.13\n// +build go1.13\n\n// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"runtime\"\n\t\"time\"\n)\n\nfunc createTransport(localAddr net.Addr) *http.Transport {\n\tdialer := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t\tDualStack: true,\n\t}\n\tif localAddr != nil {\n\t\tdialer.LocalAddr = localAddr\n\t}\n\treturn &http.Transport{\n\t\tProxy:                 http.ProxyFromEnvironment,\n\t\tDialContext:           transportDialContext(dialer),\n\t\tForceAttemptHTTP2:     true,\n\t\tMaxIdleConns:          100,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t\tMaxIdleConnsPerHost:   runtime.GOMAXPROCS(0) + 1,\n\t}\n}\n"
        },
        {
          "name": "transport112.go",
          "type": "blob",
          "size": 0.8359375,
          "content": "//go:build !go1.13\n// +build !go1.13\n\n// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"runtime\"\n\t\"time\"\n)\n\nfunc createTransport(localAddr net.Addr) *http.Transport {\n\tdialer := &net.Dialer{\n\t\tTimeout:   30 * time.Second,\n\t\tKeepAlive: 30 * time.Second,\n\t\tDualStack: true,\n\t}\n\tif localAddr != nil {\n\t\tdialer.LocalAddr = localAddr\n\t}\n\treturn &http.Transport{\n\t\tProxy:                 http.ProxyFromEnvironment,\n\t\tDialContext:           dialer.DialContext,\n\t\tMaxIdleConns:          100,\n\t\tIdleConnTimeout:       90 * time.Second,\n\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\tExpectContinueTimeout: 1 * time.Second,\n\t\tMaxIdleConnsPerHost:   runtime.GOMAXPROCS(0) + 1,\n\t}\n}\n"
        },
        {
          "name": "transport_js.go",
          "type": "blob",
          "size": 0.35546875,
          "content": "// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build js && wasm\n// +build js,wasm\n\npackage resty\n\nimport (\n\t\"context\"\n\t\"net\"\n)\n\nfunc transportDialContext(dialer *net.Dialer) func(context.Context, string, string) (net.Conn, error) {\n\treturn nil\n}\n"
        },
        {
          "name": "transport_other.go",
          "type": "blob",
          "size": 0.375,
          "content": "// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !(js && wasm)\n// +build !js !wasm\n\npackage resty\n\nimport (\n\t\"context\"\n\t\"net\"\n)\n\nfunc transportDialContext(dialer *net.Dialer) func(context.Context, string, string) (net.Conn, error) {\n\treturn dialer.DialContext\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 9.169921875,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/textproto\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n)\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Logger interface\n//_______________________________________________________________________\n\n// Logger interface is to abstract the logging from Resty. Gives control to\n// the Resty users, choice of the logger.\ntype Logger interface {\n\tErrorf(format string, v ...interface{})\n\tWarnf(format string, v ...interface{})\n\tDebugf(format string, v ...interface{})\n}\n\nfunc createLogger() *logger {\n\tl := &logger{l: log.New(os.Stderr, \"\", log.Ldate|log.Lmicroseconds)}\n\treturn l\n}\n\nvar _ Logger = (*logger)(nil)\n\ntype logger struct {\n\tl *log.Logger\n}\n\nfunc (l *logger) Errorf(format string, v ...interface{}) {\n\tl.output(\"ERROR RESTY \"+format, v...)\n}\n\nfunc (l *logger) Warnf(format string, v ...interface{}) {\n\tl.output(\"WARN RESTY \"+format, v...)\n}\n\nfunc (l *logger) Debugf(format string, v ...interface{}) {\n\tl.output(\"DEBUG RESTY \"+format, v...)\n}\n\nfunc (l *logger) output(format string, v ...interface{}) {\n\tif len(v) == 0 {\n\t\tl.l.Print(format)\n\t\treturn\n\t}\n\tl.l.Printf(format, v...)\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Rate Limiter interface\n//_______________________________________________________________________\n\ntype RateLimiter interface {\n\tAllow() bool\n}\n\nvar ErrRateLimitExceeded = errors.New(\"rate limit exceeded\")\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// Package Helper methods\n//_______________________________________________________________________\n\n// IsStringEmpty method tells whether given string is empty or not\nfunc IsStringEmpty(str string) bool {\n\treturn len(strings.TrimSpace(str)) == 0\n}\n\n// DetectContentType method is used to figure out `Request.Body` content type for request header\nfunc DetectContentType(body interface{}) string {\n\tcontentType := plainTextType\n\tkind := kindOf(body)\n\tswitch kind {\n\tcase reflect.Struct, reflect.Map:\n\t\tcontentType = jsonContentType\n\tcase reflect.String:\n\t\tcontentType = plainTextType\n\tdefault:\n\t\tif b, ok := body.([]byte); ok {\n\t\t\tcontentType = http.DetectContentType(b)\n\t\t} else if kind == reflect.Slice {\n\t\t\tcontentType = jsonContentType\n\t\t}\n\t}\n\n\treturn contentType\n}\n\n// IsJSONType method is to check JSON content type or not\nfunc IsJSONType(ct string) bool {\n\treturn jsonCheck.MatchString(ct)\n}\n\n// IsXMLType method is to check XML content type or not\nfunc IsXMLType(ct string) bool {\n\treturn xmlCheck.MatchString(ct)\n}\n\n// Unmarshalc content into object from JSON or XML\nfunc Unmarshalc(c *Client, ct string, b []byte, d interface{}) (err error) {\n\tif IsJSONType(ct) {\n\t\terr = c.JSONUnmarshal(b, d)\n\t} else if IsXMLType(ct) {\n\t\terr = c.XMLUnmarshal(b, d)\n\t}\n\n\treturn\n}\n\n//‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\n// RequestLog and ResponseLog type\n//_______________________________________________________________________\n\n// RequestLog struct is used to collected information from resty request\n// instance for debug logging. It sent to request log callback before resty\n// actually logs the information.\ntype RequestLog struct {\n\tHeader http.Header\n\tBody   string\n}\n\n// ResponseLog struct is used to collected information from resty response\n// instance for debug logging. It sent to response log callback before resty\n// actually logs the information.\ntype ResponseLog struct {\n\tHeader http.Header\n\tBody   string\n}\n\n// way to disable the HTML escape as opt-in\nfunc jsonMarshal(c *Client, r *Request, d interface{}) (*bytes.Buffer, error) {\n\tif !r.jsonEscapeHTML || !c.jsonEscapeHTML {\n\t\treturn noescapeJSONMarshal(d)\n\t}\n\n\tdata, err := c.JSONMarshal(d)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := acquireBuffer()\n\t_, _ = buf.Write(data)\n\treturn buf, nil\n}\n\nfunc firstNonEmpty(v ...string) string {\n\tfor _, s := range v {\n\t\tif !IsStringEmpty(s) {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn \"\"\n}\n\nvar quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\")\n\nfunc escapeQuotes(s string) string {\n\treturn quoteEscaper.Replace(s)\n}\n\nfunc createMultipartHeader(param, fileName, contentType string) textproto.MIMEHeader {\n\thdr := make(textproto.MIMEHeader)\n\n\tvar contentDispositionValue string\n\tif IsStringEmpty(fileName) {\n\t\tcontentDispositionValue = fmt.Sprintf(`form-data; name=\"%s\"`, param)\n\t} else {\n\t\tcontentDispositionValue = fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`,\n\t\t\tparam, escapeQuotes(fileName))\n\t}\n\thdr.Set(\"Content-Disposition\", contentDispositionValue)\n\n\tif !IsStringEmpty(contentType) {\n\t\thdr.Set(hdrContentTypeKey, contentType)\n\t}\n\treturn hdr\n}\n\nfunc addMultipartFormField(w *multipart.Writer, mf *MultipartField) error {\n\tpartWriter, err := w.CreatePart(createMultipartHeader(mf.Param, mf.FileName, mf.ContentType))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(partWriter, mf.Reader)\n\treturn err\n}\n\nfunc writeMultipartFormFile(w *multipart.Writer, fieldName, fileName string, r io.Reader) error {\n\t// Auto detect actual multipart content type\n\tcbuf := make([]byte, 512)\n\tsize, err := r.Read(cbuf)\n\tif err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\tpartWriter, err := w.CreatePart(createMultipartHeader(fieldName, fileName, http.DetectContentType(cbuf[:size])))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = partWriter.Write(cbuf[:size]); err != nil {\n\t\treturn err\n\t}\n\n\t_, err = io.Copy(partWriter, r)\n\treturn err\n}\n\nfunc addFile(w *multipart.Writer, fieldName, path string) error {\n\tfile, err := os.Open(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer closeq(file)\n\treturn writeMultipartFormFile(w, fieldName, filepath.Base(path), file)\n}\n\nfunc addFileReader(w *multipart.Writer, f *File) error {\n\treturn writeMultipartFormFile(w, f.ParamName, f.Name, f.Reader)\n}\n\nfunc getPointer(v interface{}) interface{} {\n\tvv := valueOf(v)\n\tif vv.Kind() == reflect.Ptr {\n\t\treturn v\n\t}\n\treturn reflect.New(vv.Type()).Interface()\n}\n\nfunc isPayloadSupported(m string, allowMethodGet bool) bool {\n\treturn !(m == MethodHead || m == MethodOptions || (m == MethodGet && !allowMethodGet))\n}\n\nfunc typeOf(i interface{}) reflect.Type {\n\treturn indirect(valueOf(i)).Type()\n}\n\nfunc valueOf(i interface{}) reflect.Value {\n\treturn reflect.ValueOf(i)\n}\n\nfunc indirect(v reflect.Value) reflect.Value {\n\treturn reflect.Indirect(v)\n}\n\nfunc kindOf(v interface{}) reflect.Kind {\n\treturn typeOf(v).Kind()\n}\n\nfunc createDirectory(dir string) (err error) {\n\tif _, err = os.Stat(dir); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif err = os.MkdirAll(dir, 0755); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc canJSONMarshal(contentType string, kind reflect.Kind) bool {\n\treturn IsJSONType(contentType) && (kind == reflect.Struct || kind == reflect.Map || kind == reflect.Slice)\n}\n\nfunc functionName(i interface{}) string {\n\treturn runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()\n}\n\nfunc acquireBuffer() *bytes.Buffer {\n\tbuf := bufPool.Get().(*bytes.Buffer)\n\tif buf.Len() == 0 {\n\t\tbuf.Reset()\n\t\treturn buf\n\t}\n\tbufPool.Put(buf)\n\treturn new(bytes.Buffer)\n}\n\nfunc releaseBuffer(buf *bytes.Buffer) {\n\tif buf != nil {\n\t\tbuf.Reset()\n\t\tbufPool.Put(buf)\n\t}\n}\n\nfunc backToBufPool(buf *bytes.Buffer) {\n\tif buf != nil {\n\t\tbufPool.Put(buf)\n\t}\n}\n\nfunc closeq(v interface{}) {\n\tif c, ok := v.(io.Closer); ok {\n\t\tsilently(c.Close())\n\t}\n}\n\nfunc silently(_ ...interface{}) {}\n\nfunc composeHeaders(c *Client, r *Request, hdrs http.Header) string {\n\tstr := make([]string, 0, len(hdrs))\n\tfor _, k := range sortHeaderKeys(hdrs) {\n\t\tstr = append(str, \"\\t\"+strings.TrimSpace(fmt.Sprintf(\"%25s: %s\", k, strings.Join(hdrs[k], \", \"))))\n\t}\n\treturn strings.Join(str, \"\\n\")\n}\n\nfunc sortHeaderKeys(hdrs http.Header) []string {\n\tkeys := make([]string, 0, len(hdrs))\n\tfor key := range hdrs {\n\t\tkeys = append(keys, key)\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}\n\nfunc copyHeaders(hdrs http.Header) http.Header {\n\tnh := http.Header{}\n\tfor k, v := range hdrs {\n\t\tnh[k] = v\n\t}\n\treturn nh\n}\n\nfunc wrapErrors(n error, inner error) error {\n\tif inner == nil {\n\t\treturn n\n\t}\n\tif n == nil {\n\t\treturn inner\n\t}\n\treturn &restyError{\n\t\terr:   n,\n\t\tinner: inner,\n\t}\n}\n\ntype restyError struct {\n\terr   error\n\tinner error\n}\n\nfunc (e *restyError) Error() string {\n\treturn e.err.Error()\n}\n\nfunc (e *restyError) Unwrap() error {\n\treturn e.inner\n}\n\ntype noRetryErr struct {\n\terr error\n}\n\nfunc (e *noRetryErr) Error() string {\n\treturn e.err.Error()\n}\n\nfunc wrapNoRetryErr(err error) error {\n\tif err != nil {\n\t\terr = &noRetryErr{err: err}\n\t}\n\treturn err\n}\n\nfunc unwrapNoRetryErr(err error) error {\n\tif e, ok := err.(*noRetryErr); ok {\n\t\terr = e.err\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "util_curl.go",
          "type": "blob",
          "size": 1.93359375,
          "content": "package resty\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\n\t\"net/url\"\n\t\"strings\"\n\n\t\"github.com/go-resty/resty/v2/shellescape\"\n)\n\nfunc buildCurlRequest(req *http.Request, httpCookiejar http.CookieJar) (curl string) {\n\t// 1. Generate curl raw headers\n\n\tcurl = \"curl -X \" + req.Method + \" \"\n\t// req.Host + req.URL.Path + \"?\" + req.URL.RawQuery + \" \" + req.Proto + \" \"\n\theaders := dumpCurlHeaders(req)\n\tfor _, kv := range *headers {\n\t\tcurl += `-H ` + shellescape.Quote(kv[0]+\": \"+kv[1]) + ` `\n\t}\n\n\t// 2. Generate curl cookies\n\t// TODO validate this block of code, I think its not required since cookie captured via Headers\n\tif cookieJar, ok := httpCookiejar.(*cookiejar.Jar); ok {\n\t\tcookies := cookieJar.Cookies(req.URL)\n\t\tif len(cookies) > 0 {\n\t\t\tcurl += `-H ` + shellescape.Quote(dumpCurlCookies(cookies)) + \" \"\n\t\t}\n\t}\n\n\t// 3. Generate curl body\n\tif req.Body != nil {\n\t\tbuf, _ := io.ReadAll(req.Body)\n\t\treq.Body = io.NopCloser(bytes.NewBuffer(buf)) // important!!\n\t\tcurl += `-d ` + shellescape.Quote(string(buf)) + \" \"\n\t}\n\n\turlString := shellescape.Quote(req.URL.String())\n\tif urlString == \"''\" {\n\t\turlString = \"'http://unexecuted-request'\"\n\t}\n\tcurl += urlString\n\treturn curl\n}\n\n// dumpCurlCookies dumps cookies to curl format\nfunc dumpCurlCookies(cookies []*http.Cookie) string {\n\tsb := strings.Builder{}\n\tsb.WriteString(\"Cookie: \")\n\tfor _, cookie := range cookies {\n\t\tsb.WriteString(cookie.Name + \"=\" + url.QueryEscape(cookie.Value) + \"&\")\n\t}\n\treturn strings.TrimRight(sb.String(), \"&\")\n}\n\n// dumpCurlHeaders dumps headers to curl format\nfunc dumpCurlHeaders(req *http.Request) *[][2]string {\n\theaders := [][2]string{}\n\tfor k, vs := range req.Header {\n\t\tfor _, v := range vs {\n\t\t\theaders = append(headers, [2]string{k, v})\n\t\t}\n\t}\n\tn := len(headers)\n\tfor i := 0; i < n; i++ {\n\t\tfor j := n - 1; j > i; j-- {\n\t\t\tjj := j - 1\n\t\t\th1, h2 := headers[j], headers[jj]\n\t\t\tif h1[0] < h2[0] {\n\t\t\t\theaders[jj], headers[j] = headers[j], headers[jj]\n\t\t\t}\n\t\t}\n\t}\n\treturn &headers\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 2.607421875,
          "content": "// Copyright (c) 2015-2024 Jeevanandam M (jeeva@myjeeva.com), All rights reserved.\n// resty source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage resty\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"mime/multipart\"\n\t\"testing\"\n)\n\nfunc TestIsJSONType(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tinput  string\n\t\texpect bool\n\t}{\n\t\t{\"application/json\", true},\n\t\t{\"application/xml+json\", true},\n\t\t{\"application/vnd.foo+json\", true},\n\n\t\t{\"application/json; charset=utf-8\", true},\n\t\t{\"application/vnd.foo+json; charset=utf-8\", true},\n\n\t\t{\"text/json\", true},\n\t\t{\"text/vnd.foo+json\", true},\n\n\t\t{\"application/foo-json\", true},\n\t\t{\"application/foo.json\", true},\n\t\t{\"application/vnd.foo-json\", true},\n\t\t{\"application/vnd.foo.json\", true},\n\t\t{\"application/x-amz-json-1.1\", true},\n\n\t\t{\"text/foo-json\", true},\n\t\t{\"text/foo.json\", true},\n\t\t{\"text/vnd.foo-json\", true},\n\t\t{\"text/vnd.foo.json\", true},\n\t} {\n\t\tresult := IsJSONType(test.input)\n\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"failed on %q: want %v, got %v\", test.input, test.expect, result)\n\t\t}\n\t}\n}\n\nfunc TestIsXMLType(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tinput  string\n\t\texpect bool\n\t}{\n\t\t{\"application/xml\", true},\n\t\t{\"application/vnd.foo+xml\", true},\n\n\t\t{\"application/xml; charset=utf-8\", true},\n\t\t{\"application/vnd.foo+xml; charset=utf-8\", true},\n\n\t\t{\"text/xml\", true},\n\t\t{\"text/vnd.foo+xml\", true},\n\n\t\t{\"application/foo-xml\", true},\n\t\t{\"application/foo.xml\", true},\n\t\t{\"application/vnd.foo-xml\", true},\n\t\t{\"application/vnd.foo.xml\", true},\n\n\t\t{\"text/foo-xml\", true},\n\t\t{\"text/foo.xml\", true},\n\t\t{\"text/vnd.foo-xml\", true},\n\t\t{\"text/vnd.foo.xml\", true},\n\t} {\n\t\tresult := IsXMLType(test.input)\n\n\t\tif result != test.expect {\n\t\t\tt.Errorf(\"failed on %q: want %v, got %v\", test.input, test.expect, result)\n\t\t}\n\t}\n}\n\nfunc TestWriteMultipartFormFileReaderEmpty(t *testing.T) {\n\tw := multipart.NewWriter(bytes.NewBuffer(nil))\n\tdefer func() { _ = w.Close() }()\n\tif err := writeMultipartFormFile(w, \"foo\", \"bar\", bytes.NewReader(nil)); err != nil {\n\t\tt.Errorf(\"Got unexpected error: %v\", err)\n\t}\n}\n\nfunc TestWriteMultipartFormFileReaderError(t *testing.T) {\n\terr := writeMultipartFormFile(nil, \"\", \"\", &brokenReadCloser{})\n\tassertNotNil(t, err)\n\tassertEqual(t, \"read error\", err.Error())\n}\n\nfunc TestRestyErrorFuncs(t *testing.T) {\n\tne1 := errors.New(\"new error 1\")\n\tnie1 := errors.New(\"inner error 1\")\n\n\te := wrapErrors(ne1, nie1)\n\tassertEqual(t, \"new error 1\", e.Error())\n\tassertEqual(t, \"inner error 1\", errors.Unwrap(e).Error())\n\n\te = wrapErrors(ne1, nil)\n\tassertEqual(t, \"new error 1\", e.Error())\n\n\te = wrapErrors(nil, nie1)\n\tassertEqual(t, \"inner error 1\", e.Error())\n}\n"
        }
      ]
    }
  ]
}