{
  "metadata": {
    "timestamp": 1736567934085,
    "page": 80,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "emirpasic/gods",
      "stars": 16563,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.265625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n.idea"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 2.09765625,
          "content": "Copyright (c) 2015, Emir Pasic\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n-------------------------------------------------------------------------------\n\nAVL Tree:\n\nCopyright (c) 2017 Benjamin Scher Purcell <benjapurcell@gmail.com>\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 54.904296875,
          "content": "[![GoDoc](https://godoc.org/github.com/emirpasic/gods?status.svg)](https://godoc.org/github.com/emirpasic/gods)\n[![Build Status](https://circleci.com/gh/emirpasic/gods/tree/master.svg?style=shield)](https://circleci.com/gh/emirpasic/gods?branch=master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/emirpasic/gods)](https://goreportcard.com/report/github.com/emirpasic/gods)\n[![codecov](https://codecov.io/gh/emirpasic/gods/branch/master/graph/badge.svg)](https://codecov.io/gh/emirpasic/gods)\n[![Sourcegraph](https://sourcegraph.com/github.com/emirpasic/gods/-/badge.svg)](https://sourcegraph.com/github.com/emirpasic/gods?badge)\n[![Release](https://img.shields.io/github/release/emirpasic/gods.svg?style=flat-square)](https://github.com/emirpasic/gods/releases)\n[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=gods&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=gods)\n[![PyPI](https://img.shields.io/badge/License-BSD_2--Clause-green.svg)](https://github.com/emirpasic/gods/blob/master/LICENSE)\n\n# GoDS (Go Data Structures)\n\nImplementation of various data structures and algorithms in Go.\n\n## Data Structures\n\n- [Containers](#containers)\n  - [Lists](#lists)\n    - [ArrayList](#arraylist)\n    - [SinglyLinkedList](#singlylinkedlist)\n    - [DoublyLinkedList](#doublylinkedlist)\n  - [Sets](#sets)\n    - [HashSet](#hashset)\n    - [TreeSet](#treeset)\n    - [LinkedHashSet](#linkedhashset)\n  - [Stacks](#stacks)\n    - [LinkedListStack](#linkedliststack)\n    - [ArrayStack](#arraystack)\n  - [Maps](#maps)\n    - [HashMap](#hashmap)\n    - [TreeMap](#treemap)\n    - [LinkedHashMap](#linkedhashmap)\n    - [HashBidiMap](#hashbidimap)\n    - [TreeBidiMap](#treebidimap)\n  - [Trees](#trees)\n    - [RedBlackTree](#redblacktree)\n    - [AVLTree](#avltree)\n    - [BTree](#btree)\n    - [BinaryHeap](#binaryheap)\n  - [Queues](#queues)\n    - [LinkedListQueue](#linkedlistqueue)\n    - [ArrayQueue](#arrayqueue)\n    - [CircularBuffer](#circularbuffer)\n    - [PriorityQueue](#priorityqueue)\n- [Functions](#functions)\n    - [Comparator](#comparator)\n    - [Iterator](#iterator)\n      - [IteratorWithIndex](#iteratorwithindex)\n      - [IteratorWithKey](#iteratorwithkey)\n      - [ReverseIteratorWithIndex](#reverseiteratorwithindex)\n      - [ReverseIteratorWithKey](#reverseiteratorwithkey)\n    - [Enumerable](#enumerable)\n      - [EnumerableWithIndex](#enumerablewithindex)\n      - [EnumerableWithKey](#enumerablewithkey)\n    - [Serialization](#serialization)\n      - [JSONSerializer](#jsonserializer)\n      - [JSONDeserializer](#jsondeserializer)\n    - [Sort](#sort)\n    - [Container](#container)\n- [Appendix](#appendix)\n\n\n## Containers\n\nAll data structures implement the container interface with the following methods:\n\n```go\ntype Container interface {\n\tEmpty() bool\n\tSize() int\n\tClear()\n\tValues() []interface{}\n\tString() string\n}\n```\n\nContainers are either ordered or unordered. All ordered containers provide [stateful iterators](#iterator) and some of them allow [enumerable functions](#enumerable).\n\n| **Data** | **Structure**                         | **Ordered** | **[Iterator](#iterator)** | **[Enumerable](#enumerable)** | **Referenced by** |\n| :--- |:--------------------------------------| :---: | :---: | :---: | :---: |\n| [Lists](#lists) |\n|   | [ArrayList](#arraylist)               | yes | yes* | yes | index |\n|   | [SinglyLinkedList](#singlylinkedlist) | yes | yes | yes | index |\n|   | [DoublyLinkedList](#doublylinkedlist) | yes | yes* | yes | index |\n| [Sets](#sets) |\n|   | [HashSet](#hashset)                   | no | no | no | index |\n|   | [TreeSet](#treeset)                   | yes | yes* | yes | index |\n|   | [LinkedHashSet](#linkedhashset)       | yes | yes* | yes | index |\n| [Stacks](#stacks) |\n|   | [LinkedListStack](#linkedliststack)   | yes | yes | no | index |\n|   | [ArrayStack](#arraystack)             | yes | yes* | no | index |\n| [Maps](#maps) |\n|   | [HashMap](#hashmap)                   | no | no | no | key |\n|   | [TreeMap](#treemap)                   | yes | yes* | yes | key |\n|   | [LinkedHashMap](#linkedhashmap)       | yes | yes* | yes | key |\n|   | [HashBidiMap](#hashbidimap)           | no | no | no | key* |\n|   | [TreeBidiMap](#treebidimap)           | yes | yes* | yes | key* |\n| [Trees](#trees) |\n|   | [RedBlackTree](#redblacktree)         | yes | yes* | no | key |\n|   | [AVLTree](#avltree)                   | yes | yes* | no | key |\n|   | [BTree](#btree)                       | yes | yes* | no | key |\n|   | [BinaryHeap](#binaryheap)             | yes | yes* | no | index |\n| [Queues](#queues) |\n|   | [LinkedListQueue](#linkedlistqueue)   | yes | yes | no | index |\n|   | [ArrayQueue](#arrayqueue)             | yes | yes* | no | index |\n|   | [CircularBuffer](#circularbuffer)     | yes | yes* | no | index |\n|   | [PriorityQueue](#priorityqueue)       | yes | yes* | no | index |\n|   |                                       |  | <sub><sup>*reversible</sup></sub> |  | <sub><sup>*bidirectional</sup></sub> |\n\n### Lists\n\nA list is a data structure that stores values and may have repeated values.\n\nImplements [Container](#containers) interface.\n\n```go\ntype List interface {\n\tGet(index int) (interface{}, bool)\n\tRemove(index int)\n\tAdd(values ...interface{})\n\tContains(values ...interface{}) bool\n\tSort(comparator utils.Comparator)\n\tSwap(index1, index2 int)\n\tInsert(index int, values ...interface{})\n\tSet(index int, value interface{})\n\n\tcontainers.Container\n\t// Empty() bool\n\t// Size() int\n\t// Clear()\n\t// Values() []interface{}\n    // String() string\n}\n```\n\n#### ArrayList\n\nA [list](#lists) backed by a dynamic array that grows and shrinks implicitly.\n\nImplements [List](#lists), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [EnumerableWithIndex](#enumerablewithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport (\n\t\"github.com/emirpasic/gods/lists/arraylist\"\n\t\"github.com/emirpasic/gods/utils\"\n)\n\nfunc main() {\n\tlist := arraylist.New()\n\tlist.Add(\"a\")                         // [\"a\"]\n\tlist.Add(\"c\", \"b\")                    // [\"a\",\"c\",\"b\"]\n\tlist.Sort(utils.StringComparator)     // [\"a\",\"b\",\"c\"]\n\t_, _ = list.Get(0)                    // \"a\",true\n\t_, _ = list.Get(100)                  // nil,false\n\t_ = list.Contains(\"a\", \"b\", \"c\")      // true\n\t_ = list.Contains(\"a\", \"b\", \"c\", \"d\") // false\n\tlist.Swap(0, 1)                       // [\"b\",\"a\",c\"]\n\tlist.Remove(2)                        // [\"b\",\"a\"]\n\tlist.Remove(1)                        // [\"b\"]\n\tlist.Remove(0)                        // []\n\tlist.Remove(0)                        // [] (ignored)\n\t_ = list.Empty()                      // true\n\t_ = list.Size()                       // 0\n\tlist.Add(\"a\")                         // [\"a\"]\n\tlist.Clear()                          // []\n\tlist.Insert(0, \"b\")                   // [\"b\"]\n\tlist.Insert(0, \"a\")                   // [\"a\",\"b\"]\n}\n```\n\n#### SinglyLinkedList\n\nA [list](#lists) where each element points to the next element in the list.\n\nImplements [List](#lists), [IteratorWithIndex](#iteratorwithindex), [EnumerableWithIndex](#enumerablewithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport (\n\tsll \"github.com/emirpasic/gods/lists/singlylinkedlist\"\n\t\"github.com/emirpasic/gods/utils\"\n)\n\nfunc main() {\n\tlist := sll.New()\n\tlist.Add(\"a\")                         // [\"a\"]\n\tlist.Add(\"c\", \"b\")                    // [\"a\",\"c\",\"b\"]\n\tlist.Sort(utils.StringComparator)     // [\"a\",\"b\",\"c\"]\n\t_, _ = list.Get(0)                    // \"a\",true\n\t_, _ = list.Get(100)                  // nil,false\n\t_ = list.Contains(\"a\", \"b\", \"c\")      // true\n\t_ = list.Contains(\"a\", \"b\", \"c\", \"d\") // false\n\tlist.Swap(0, 1)                       // [\"b\",\"a\",c\"]\n\tlist.Remove(2)                        // [\"b\",\"a\"]\n\tlist.Remove(1)                        // [\"b\"]\n\tlist.Remove(0)                        // []\n\tlist.Remove(0)                        // [] (ignored)\n\t_ = list.Empty()                      // true\n\t_ = list.Size()                       // 0\n\tlist.Add(\"a\")                         // [\"a\"]\n\tlist.Clear()                          // []\n\tlist.Insert(0, \"b\")                   // [\"b\"]\n\tlist.Insert(0, \"a\")                   // [\"a\",\"b\"]\n}\n```\n\n#### DoublyLinkedList\n\nA [list](#lists) where each element points to the next and previous elements in the list.\n\nImplements [List](#lists), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [EnumerableWithIndex](#enumerablewithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport (\n\tdll \"github.com/emirpasic/gods/lists/doublylinkedlist\"\n\t\"github.com/emirpasic/gods/utils\"\n)\n\nfunc main() {\n\tlist := dll.New()\n\tlist.Add(\"a\")                         // [\"a\"]\n\tlist.Add(\"c\", \"b\")                    // [\"a\",\"c\",\"b\"]\n\tlist.Sort(utils.StringComparator)     // [\"a\",\"b\",\"c\"]\n\t_, _ = list.Get(0)                    // \"a\",true\n\t_, _ = list.Get(100)                  // nil,false\n\t_ = list.Contains(\"a\", \"b\", \"c\")      // true\n\t_ = list.Contains(\"a\", \"b\", \"c\", \"d\") // false\n\tlist.Swap(0, 1)                       // [\"b\",\"a\",c\"]\n\tlist.Remove(2)                        // [\"b\",\"a\"]\n\tlist.Remove(1)                        // [\"b\"]\n\tlist.Remove(0)                        // []\n\tlist.Remove(0)                        // [] (ignored)\n\t_ = list.Empty()                      // true\n\t_ = list.Size()                       // 0\n\tlist.Add(\"a\")                         // [\"a\"]\n\tlist.Clear()                          // []\n\tlist.Insert(0, \"b\")                   // [\"b\"]\n\tlist.Insert(0, \"a\")                   // [\"a\",\"b\"]\n}\n```\n\n### Sets\n\nA set is a data structure that can store elements and has no repeated values. It is a computer implementation of the mathematical concept of a finite set. Unlike most other collection types, rather than retrieving a specific element from a set, one typically tests an element for membership in a set. This structure is often used to ensure that no duplicates are present in a container.\n\nSet additionally allow set operations such as [intersection](https://en.wikipedia.org/wiki/Intersection_(set_theory)), [union](https://en.wikipedia.org/wiki/Union_(set_theory)), [difference](https://proofwiki.org/wiki/Definition:Set_Difference), etc.\n\nImplements [Container](#containers) interface.\n\n```go\ntype Set interface {\n\tAdd(elements ...interface{})\n\tRemove(elements ...interface{})\n\tContains(elements ...interface{}) bool\n    // Intersection(another *Set) *Set\n    // Union(another *Set) *Set\n    // Difference(another *Set) *Set\n\t\n\tcontainers.Container\n\t// Empty() bool\n\t// Size() int\n\t// Clear()\n\t// Values() []interface{}\n\t// String() string\n}\n```\n\n#### HashSet\n\nA [set](#sets) backed by a hash table (actually a Go's map). It makes no guarantees as to the iteration order of the set.\n\nImplements [Set](#sets), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/sets/hashset\"\n\nfunc main() {\n\tset := hashset.New()   // empty\n\tset.Add(1)             // 1\n\tset.Add(2, 2, 3, 4, 5) // 3, 1, 2, 4, 5 (random order, duplicates ignored)\n\tset.Remove(4)          // 5, 3, 2, 1 (random order)\n\tset.Remove(2, 3)       // 1, 5 (random order)\n\tset.Contains(1)        // true\n\tset.Contains(1, 5)     // true\n\tset.Contains(1, 6)     // false\n\t_ = set.Values()       // []int{5,1} (random order)\n\tset.Clear()            // empty\n\tset.Empty()            // true\n\tset.Size()             // 0\n}\n```\n\n#### TreeSet\n\nA [set](#sets) backed by a [red-black tree](#redblacktree) to keep the elements ordered with respect to the [comparator](#comparator).\n\nImplements [Set](#sets), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [EnumerableWithIndex](#enumerablewithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/sets/treeset\"\n\nfunc main() {\n\tset := treeset.NewWithIntComparator() // empty (keys are of type int)\n\tset.Add(1)                            // 1\n\tset.Add(2, 2, 3, 4, 5)                // 1, 2, 3, 4, 5 (in order, duplicates ignored)\n\tset.Remove(4)                         // 1, 2, 3, 5 (in order)\n\tset.Remove(2, 3)                      // 1, 5 (in order)\n\tset.Contains(1)                       // true\n\tset.Contains(1, 5)                    // true\n\tset.Contains(1, 6)                    // false\n\t_ = set.Values()                      // []int{1,5} (in order)\n\tset.Clear()                           // empty\n\tset.Empty()                           // true\n\tset.Size()                            // 0\n}\n```\n\n#### LinkedHashSet\n\nA [set](#sets) that preserves insertion-order. Data structure is backed by a hash table to store values and [doubly-linked list](#doublylinkedlist) to store insertion ordering.\n\nImplements [Set](#sets), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [EnumerableWithIndex](#enumerablewithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/sets/linkedhashset\"\n\nfunc main() {\n\tset := linkedhashset.New() // empty\n\tset.Add(5)                 // 5\n\tset.Add(4, 4, 3, 2, 1)     // 5, 4, 3, 2, 1 (in insertion-order, duplicates ignored)\n\tset.Add(4)                 // 5, 4, 3, 2, 1 (duplicates ignored, insertion-order unchanged)\n\tset.Remove(4)              // 5, 3, 2, 1 (in insertion-order)\n\tset.Remove(2, 3)           // 5, 1 (in insertion-order)\n\tset.Contains(1)            // true\n\tset.Contains(1, 5)         // true\n\tset.Contains(1, 6)         // false\n\t_ = set.Values()           // []int{5, 1} (in insertion-order)\n\tset.Clear()                // empty\n\tset.Empty()                // true\n\tset.Size()                 // 0\n}\n```\n\n### Stacks\n\nA stack that represents a last-in-first-out (LIFO) data structure. The usual push and pop operations are provided, as well as a method to peek at the top item on the stack.\n\nImplements [Container](#containers) interface.\n\n```go\ntype Stack interface {\n\tPush(value interface{})\n\tPop() (value interface{}, ok bool)\n\tPeek() (value interface{}, ok bool)\n\n\tcontainers.Container\n\t// Empty() bool\n\t// Size() int\n\t// Clear()\n\t// Values() []interface{}\n\t// String() string\n}\n```\n\n#### LinkedListStack\n\nA [stack](#stacks) based on a [linked list](#singlylinkedlist).\n\nImplements [Stack](#stacks), [IteratorWithIndex](#iteratorwithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport lls \"github.com/emirpasic/gods/stacks/linkedliststack\"\n\nfunc main() {\n\tstack := lls.New()  // empty\n\tstack.Push(1)       // 1\n\tstack.Push(2)       // 1, 2\n\tstack.Values()      // 2, 1 (LIFO order)\n\t_, _ = stack.Peek() // 2,true\n\t_, _ = stack.Pop()  // 2, true\n\t_, _ = stack.Pop()  // 1, true\n\t_, _ = stack.Pop()  // nil, false (nothing to pop)\n\tstack.Push(1)       // 1\n\tstack.Clear()       // empty\n\tstack.Empty()       // true\n\tstack.Size()        // 0\n}\n```\n\n#### ArrayStack\n\nA [stack](#stacks) based on a [array list](#arraylist).\n\nImplements [Stack](#stacks), [IteratorWithIndex](#iteratorwithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/stacks/arraystack\"\n\nfunc main() {\n\tstack := arraystack.New() // empty\n\tstack.Push(1)             // 1\n\tstack.Push(2)             // 1, 2\n\tstack.Values()            // 2, 1 (LIFO order)\n\t_, _ = stack.Peek()       // 2,true\n\t_, _ = stack.Pop()        // 2, true\n\t_, _ = stack.Pop()        // 1, true\n\t_, _ = stack.Pop()        // nil, false (nothing to pop)\n\tstack.Push(1)             // 1\n\tstack.Clear()             // empty\n\tstack.Empty()             // true\n\tstack.Size()              // 0\n}\n```\n\n### Maps\n\nA Map is a data structure that maps keys to values. A map cannot contain duplicate keys and each key can map to at most one value.\n\nImplements [Container](#containers) interface.\n\n```go\ntype Map interface {\n\tPut(key interface{}, value interface{})\n\tGet(key interface{}) (value interface{}, found bool)\n\tRemove(key interface{})\n\tKeys() []interface{}\n\n\tcontainers.Container\n\t// Empty() bool\n\t// Size() int\n\t// Clear()\n\t// Values() []interface{}\n\t// String() string\n}\n```\n\nA BidiMap is an extension to the Map. A bidirectional map (BidiMap), also called a hash bag, is an associative data structure in which the key-value pairs form a one-to-one relation. This relation works in both directions by allow the value to also act as a key to key, e.g. a pair (a,b) thus provides a coupling between 'a' and 'b' so that 'b' can be found when 'a' is used as a key and 'a' can be found when 'b' is used as a key.\n\n```go\ntype BidiMap interface {\n\tGetKey(value interface{}) (key interface{}, found bool)\n\n\tMap\n}\n```\n\n#### HashMap\n\nA [map](#maps) based on hash tables. Keys are unordered.\n\nImplements [Map](#maps), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/maps/hashmap\"\n\nfunc main() {\n\tm := hashmap.New() // empty\n\tm.Put(1, \"x\")      // 1->x\n\tm.Put(2, \"b\")      // 2->b, 1->x (random order)\n\tm.Put(1, \"a\")      // 2->b, 1->a (random order)\n\t_, _ = m.Get(2)    // b, true\n\t_, _ = m.Get(3)    // nil, false\n\t_ = m.Values()     // []interface {}{\"b\", \"a\"} (random order)\n\t_ = m.Keys()       // []interface {}{1, 2} (random order)\n\tm.Remove(1)        // 2->b\n\tm.Clear()          // empty\n\tm.Empty()          // true\n\tm.Size()           // 0\n}\n```\n\n#### TreeMap\n\nA [map](#maps) based on [red-black tree](#redblacktree). Keys are ordered with respect to the [comparator](#comparator).\n\nImplements [Map](#maps), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [EnumerableWithKey](#enumerablewithkey), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/maps/treemap\"\n\nfunc main() {\n\tm := treemap.NewWithIntComparator() // empty (keys are of type int)\n\tm.Put(1, \"x\")                       // 1->x\n\tm.Put(2, \"b\")                       // 1->x, 2->b (in order)\n\tm.Put(1, \"a\")                       // 1->a, 2->b (in order)\n\t_, _ = m.Get(2)                     // b, true\n\t_, _ = m.Get(3)                     // nil, false\n\t_ = m.Values()                      // []interface {}{\"a\", \"b\"} (in order)\n\t_ = m.Keys()                        // []interface {}{1, 2} (in order)\n\tm.Remove(1)                         // 2->b\n\tm.Clear()                           // empty\n\tm.Empty()                           // true\n\tm.Size()                            // 0\n\n\t// Other:\n\tm.Min() // Returns the minimum key and its value from map.\n\tm.Max() // Returns the maximum key and its value from map.\n}\n```\n\n#### LinkedHashMap\n\nA [map](#maps) that preserves insertion-order. It is backed by a hash table to store values and [doubly-linked list](doublylinkedlist) to store ordering.\n\nImplements [Map](#maps), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [EnumerableWithKey](#enumerablewithkey), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/maps/linkedhashmap\"\n\nfunc main() {\n\tm := linkedhashmap.New() // empty (keys are of type int)\n\tm.Put(2, \"b\")            // 2->b\n\tm.Put(1, \"x\")            // 2->b, 1->x (insertion-order)\n\tm.Put(1, \"a\")            // 2->b, 1->a (insertion-order)\n\t_, _ = m.Get(2)          // b, true\n\t_, _ = m.Get(3)          // nil, false\n\t_ = m.Values()           // []interface {}{\"b\", \"a\"} (insertion-order)\n\t_ = m.Keys()             // []interface {}{2, 1} (insertion-order)\n\tm.Remove(1)              // 2->b\n\tm.Clear()                // empty\n\tm.Empty()                // true\n\tm.Size()                 // 0\n}\n\n```\n\n#### HashBidiMap\n\nA [map](#maps) based on two hashmaps. Keys are unordered.\n\nImplements [BidiMap](#maps), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/maps/hashbidimap\"\n\nfunc main() {\n\tm := hashbidimap.New() // empty\n\tm.Put(1, \"x\")          // 1->x\n\tm.Put(3, \"b\")          // 1->x, 3->b (random order)\n\tm.Put(1, \"a\")          // 1->a, 3->b (random order)\n\tm.Put(2, \"b\")          // 1->a, 2->b (random order)\n\t_, _ = m.GetKey(\"a\")   // 1, true\n\t_, _ = m.Get(2)        // b, true\n\t_, _ = m.Get(3)        // nil, false\n\t_ = m.Values()         // []interface {}{\"a\", \"b\"} (random order)\n\t_ = m.Keys()           // []interface {}{1, 2} (random order)\n\tm.Remove(1)            // 2->b\n\tm.Clear()              // empty\n\tm.Empty()              // true\n\tm.Size()               // 0\n}\n```\n\n#### TreeBidiMap\n\nA [map](#maps) based on red-black tree. This map guarantees that the map will be in both ascending key and value order.  Other than key and value ordering, the goal with this structure is to avoid duplication of elements (unlike in [HashBidiMap](#hashbidimap)), which can be significant if contained elements are large.\n\nImplements [BidiMap](#maps), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [EnumerableWithKey](#enumerablewithkey), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport (\n\t\"github.com/emirpasic/gods/maps/treebidimap\"\n\t\"github.com/emirpasic/gods/utils\"\n)\n\nfunc main() {\n\tm := treebidimap.NewWith(utils.IntComparator, utils.StringComparator)\n\tm.Put(1, \"x\")        // 1->x\n\tm.Put(3, \"b\")        // 1->x, 3->b (ordered)\n\tm.Put(1, \"a\")        // 1->a, 3->b (ordered)\n\tm.Put(2, \"b\")        // 1->a, 2->b (ordered)\n\t_, _ = m.GetKey(\"a\") // 1, true\n\t_, _ = m.Get(2)      // b, true\n\t_, _ = m.Get(3)      // nil, false\n\t_ = m.Values()       // []interface {}{\"a\", \"b\"} (ordered)\n\t_ = m.Keys()         // []interface {}{1, 2} (ordered)\n\tm.Remove(1)          // 2->b\n\tm.Clear()            // empty\n\tm.Empty()            // true\n\tm.Size()             // 0\n}\n```\n\n### Trees\n\nA tree is a widely used data data structure that simulates a hierarchical tree structure, with a root value and subtrees of children, represented as a set of linked nodes; thus no cyclic links.\n\nImplements [Container](#containers) interface.\n\n```go\ntype Tree interface {\n\tcontainers.Container\n\t// Empty() bool\n\t// Size() int\n\t// Clear()\n\t// Values() []interface{}\n\t// String() string\n}\n```\n\n#### RedBlackTree\n\nA red–black [tree](#trees) is a binary search tree with an extra bit of data per node, its color, which can be either red or black. The extra bit of storage ensures an approximately balanced tree by constraining how nodes are colored from any path from the root to the leaf. Thus, it is a data structure which is a type of self-balancing binary search tree.\n\nThe balancing of the tree is not perfect but it is good enough to allow it to guarantee searching in O(log n) time, where n is the total number of elements in the tree. The insertion and deletion operations, along with the tree rearrangement and recoloring, are also performed in O(log n) time. <sub><sup>[Wikipedia](http://en.wikipedia.org/wiki/Red%E2%80%93black_tree)</sup></sub>\n\nImplements [Tree](#trees), [ReverseIteratorWithKey](#reverseiteratorwithkey), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n<p align=\"center\"><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png\" width=\"400px\" height=\"200px\" /></p>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\trbt \"github.com/emirpasic/gods/trees/redblacktree\"\n)\n\nfunc main() {\n\ttree := rbt.NewWithIntComparator() // empty (keys are of type int)\n\n\ttree.Put(1, \"x\") // 1->x\n\ttree.Put(2, \"b\") // 1->x, 2->b (in order)\n\ttree.Put(1, \"a\") // 1->a, 2->b (in order, replacement)\n\ttree.Put(3, \"c\") // 1->a, 2->b, 3->c (in order)\n\ttree.Put(4, \"d\") // 1->a, 2->b, 3->c, 4->d (in order)\n\ttree.Put(5, \"e\") // 1->a, 2->b, 3->c, 4->d, 5->e (in order)\n\ttree.Put(6, \"f\") // 1->a, 2->b, 3->c, 4->d, 5->e, 6->f (in order)\n\n\tfmt.Println(tree)\n\t//\n\t//  RedBlackTree\n\t//  │           ┌── 6\n\t//\t│       ┌── 5\n\t//\t│   ┌── 4\n\t//\t│   │   └── 3\n\t//\t└── 2\n\t//\t\t└── 1\n\n\t_ = tree.Values() // []interface {}{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"} (in order)\n\t_ = tree.Keys()   // []interface {}{1, 2, 3, 4, 5, 6} (in order)\n\n\ttree.Remove(2) // 1->a, 3->c, 4->d, 5->e, 6->f (in order)\n\tfmt.Println(tree)\n\t//\n\t//  RedBlackTree\n\t//  │       ┌── 6\n\t//  │   ┌── 5\n\t//  └── 4\n\t//      │   ┌── 3\n\t//      └── 1\n\n\ttree.Clear() // empty\n\ttree.Empty() // true\n\ttree.Size()  // 0\n\n\t// Other:\n\ttree.Left() // gets the left-most (min) node\n\ttree.Right() // get the right-most (max) node\n\ttree.Floor(1) // get the floor node\n\ttree.Ceiling(1) // get the ceiling node\n}\n```\n\nExtending the red-black tree's functionality  has been demonstrated in the following [example](https://github.com/emirpasic/gods/blob/master/examples/redblacktreeextended/redblacktreeextended.go).\n\n#### AVLTree\n\nAVL [tree](#trees) is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations.\n\nAVL trees are often compared with red–black trees because both support the same set of operations and take O(log n) time for the basic operations. For lookup-intensive applications, AVL trees are faster than red–black trees because they are more strictly balanced. <sub><sup>[Wikipedia](https://en.wikipedia.org/wiki/AVL_tree)</sup></sub>\n\nImplements [Tree](#trees), [ReverseIteratorWithKey](#reverseiteratorwithkey), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n<p align=\"center\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/AVL-tree-wBalance_K.svg/262px-AVL-tree-wBalance_K.svg.png\" width=\"300px\" height=\"180px\" /><br/><sub>AVL tree with balance factors (green)</sub></p>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\tavl \"github.com/emirpasic/gods/trees/avltree\"\n)\n\nfunc main() {\n\ttree := avl.NewWithIntComparator() // empty(keys are of type int)\n\n\ttree.Put(1, \"x\") // 1->x\n\ttree.Put(2, \"b\") // 1->x, 2->b (in order)\n\ttree.Put(1, \"a\") // 1->a, 2->b (in order, replacement)\n\ttree.Put(3, \"c\") // 1->a, 2->b, 3->c (in order)\n\ttree.Put(4, \"d\") // 1->a, 2->b, 3->c, 4->d (in order)\n\ttree.Put(5, \"e\") // 1->a, 2->b, 3->c, 4->d, 5->e (in order)\n\ttree.Put(6, \"f\") // 1->a, 2->b, 3->c, 4->d, 5->e, 6->f (in order)\n\n\tfmt.Println(tree)\n\t//\n\t//  AVLTree\n\t//  │       ┌── 6\n\t//  │   ┌── 5\n\t//  └── 4\n\t//      │   ┌── 3\n\t//      └── 2\n\t//          └── 1\n\n\n\t_ = tree.Values() // []interface {}{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"} (in order)\n\t_ = tree.Keys()   // []interface {}{1, 2, 3, 4, 5, 6} (in order)\n\n\ttree.Remove(2) // 1->a, 3->c, 4->d, 5->e, 6->f (in order)\n\tfmt.Println(tree)\n\t//\n\t//  AVLTree\n\t//  │       ┌── 6\n\t//  │   ┌── 5\n\t//  └── 4\n\t//      └── 3\n\t//          └── 1\n\n\ttree.Clear() // empty\n\ttree.Empty() // true\n\ttree.Size()  // 0\n}\n```\n\n#### BTree\n\nB-tree is a self-balancing tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time. The B-tree is a generalization of a binary search tree in that a node can have more than two children.\n\nAccording to Knuth's definition, a B-tree of order m is a tree which satisfies the following properties:\n\n- Every node has at most m children.\n- Every non-leaf node (except root) has at least ⌈m/2⌉ children.\n- The root has at least two children if it is not a leaf node.\n- A non-leaf node with k children contains k−1 keys.\n- All leaves appear in the same level\n\nEach internal node’s keys act as separation values which divide its subtrees. For example, if an internal node has 3 child nodes (or subtrees) then it must have 2 keys: a1 and a2. All values in the leftmost subtree will be less than a1, all values in the middle subtree will be between a1 and a2, and all values in the rightmost subtree will be greater than a2.<sub><sup>[Wikipedia](http://en.wikipedia.org/wiki/Red%E2%80%93black_tree)</sub></sup>\n\nImplements [Tree](#trees), [ReverseIteratorWithKey](#reverseiteratorwithkey), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n<p align=\"center\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/831px-B-tree.svg.png\" width=\"400px\" height=\"111px\" /></p>\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/trees/btree\"\n)\n\nfunc main() {\n\ttree := btree.NewWithIntComparator(3) // empty (keys are of type int)\n\n\ttree.Put(1, \"x\") // 1->x\n\ttree.Put(2, \"b\") // 1->x, 2->b (in order)\n\ttree.Put(1, \"a\") // 1->a, 2->b (in order, replacement)\n\ttree.Put(3, \"c\") // 1->a, 2->b, 3->c (in order)\n\ttree.Put(4, \"d\") // 1->a, 2->b, 3->c, 4->d (in order)\n\ttree.Put(5, \"e\") // 1->a, 2->b, 3->c, 4->d, 5->e (in order)\n\ttree.Put(6, \"f\") // 1->a, 2->b, 3->c, 4->d, 5->e, 6->f (in order)\n\ttree.Put(7, \"g\") // 1->a, 2->b, 3->c, 4->d, 5->e, 6->f, 7->g (in order)\n\n\tfmt.Println(tree)\n\t// BTree\n\t//         1\n\t//     2\n\t//         3\n\t// 4\n\t//         5\n\t//     6\n\t//         7\n\n\t_ = tree.Values() // []interface {}{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"} (in order)\n\t_ = tree.Keys()   // []interface {}{1, 2, 3, 4, 5, 6, 7} (in order)\n\n\ttree.Remove(2) // 1->a, 3->c, 4->d, 5->e, 6->f, 7->g (in order)\n\tfmt.Println(tree)\n\t// BTree\n\t//     1\n\t//     3\n\t// 4\n\t//     5\n\t// 6\n\t//     7\n\n\ttree.Clear() // empty\n\ttree.Empty() // true\n\ttree.Size()  // 0\n\n\t// Other:\n\ttree.Height() // gets the height of the tree\n\ttree.Left() // gets the left-most (min) node\n\ttree.LeftKey() // get the left-most (min) node's key\n\ttree.LeftValue() // get the left-most (min) node's value\n\ttree.Right() // get the right-most (max) node\n\ttree.RightKey() // get the right-most (max) node's key\n\ttree.RightValue() // get the right-most (max) node's value\n}\n```\n\n#### BinaryHeap\n\nA binary heap is a [tree](#trees) created using a binary tree. It can be seen as a binary tree with two additional constraints:\n\n- Shape property:\n\n  A binary heap is a complete binary tree; that is, all levels of the tree, except possibly the last one (deepest) are fully filled, and, if the last level of the tree is not complete, the nodes of that level are filled from left to right.\n- Heap property:\n\n  All nodes are either greater than or equal to or less than or equal to each of its children, according to a comparison predicate defined for the heap. <sub><sup>[Wikipedia](http://en.wikipedia.org/wiki/Binary_heap)</sub></sup>\n\nImplements [Tree](#trees), [ReverseIteratorWithIndex](#reverseiteratorwithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n<p align=\"center\"><img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/3/38/Max-Heap.svg/501px-Max-Heap.svg.png\" width=\"300px\" height=\"200px\" /></p>\n\n```go\npackage main\n\nimport (\n\t\"github.com/emirpasic/gods/trees/binaryheap\"\n\t\"github.com/emirpasic/gods/utils\"\n)\n\nfunc main() {\n\n\t// Min-heap\n\theap := binaryheap.NewWithIntComparator() // empty (min-heap)\n\theap.Push(2)                              // 2\n\theap.Push(3)                              // 2, 3\n\theap.Push(1)                              // 1, 3, 2\n\theap.Values()                             // 1, 3, 2\n\t_, _ = heap.Peek()                        // 1,true\n\t_, _ = heap.Pop()                         // 1, true\n\t_, _ = heap.Pop()                         // 2, true\n\t_, _ = heap.Pop()                         // 3, true\n\t_, _ = heap.Pop()                         // nil, false (nothing to pop)\n\theap.Push(1)                              // 1\n\theap.Clear()                              // empty\n\theap.Empty()                              // true\n\theap.Size()                               // 0\n\n\t// Max-heap\n\tinverseIntComparator := func(a, b interface{}) int {\n\t\treturn -utils.IntComparator(a, b)\n\t}\n\theap = binaryheap.NewWith(inverseIntComparator) // empty (min-heap)\n\theap.Push(2, 3, 1)                              // 3, 2, 1 (bulk optimized)\n\theap.Values()                                   // 3, 2, 1\n}\n```\n\n### Queues\n\nA queue that represents a first-in-first-out (FIFO) data structure. The usual enqueue and dequeue operations are provided, as well as a method to peek at the first item in the queue.\n\n<p align=\"center\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Data_Queue.svg/300px-Data_Queue.svg.png\" width=\"200px\" height=\"120px\" /></p>\n\nImplements [Container](#containers) interface.\n\n```go\ntype Queue interface {\n\tEnqueue(value interface{})\n\tDequeue() (value interface{}, ok bool)\n\tPeek() (value interface{}, ok bool)\n\n\tcontainers.Container\n\t// Empty() bool\n\t// Size() int\n\t// Clear()\n\t// Values() []interface{}\n\t// String() string\n}\n```\n\n#### LinkedListQueue\n\nA [queue](#queues) based on a [linked list](#singlylinkedlist).\n\nImplements [Queue](#queues), [IteratorWithIndex](#iteratorwithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport llq \"github.com/emirpasic/gods/queues/linkedlistqueue\"\n\n// LinkedListQueueExample to demonstrate basic usage of LinkedListQueue\nfunc main() {\n    queue := llq.New()     // empty\n    queue.Enqueue(1)       // 1\n    queue.Enqueue(2)       // 1, 2\n    _ = queue.Values()     // 1, 2 (FIFO order)\n    _, _ = queue.Peek()    // 1,true\n    _, _ = queue.Dequeue() // 1, true\n    _, _ = queue.Dequeue() // 2, true\n    _, _ = queue.Dequeue() // nil, false (nothing to deque)\n    queue.Enqueue(1)       // 1\n    queue.Clear()          // empty\n    queue.Empty()          // true\n    _ = queue.Size()       // 0\n}\n```\n\n#### ArrayQueue\n\nA [queue](#queues) based on a [array list](#arraylist).\n\nImplements [Queue](#queues), [ReverseIteratorWithIndex](#iteratorwithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport aq \"github.com/emirpasic/gods/queues/arrayqueue\"\n\n// ArrayQueueExample to demonstrate basic usage of ArrayQueue\nfunc main() {\n    queue := aq.New()      // empty\n    queue.Enqueue(1)       // 1\n    queue.Enqueue(2)       // 1, 2\n    _ = queue.Values()     // 1, 2 (FIFO order)\n    _, _ = queue.Peek()    // 1,true\n    _, _ = queue.Dequeue() // 1, true\n    _, _ = queue.Dequeue() // 2, true\n    _, _ = queue.Dequeue() // nil, false (nothing to deque)\n    queue.Enqueue(1)       // 1\n    queue.Clear()          // empty\n    queue.Empty()          // true\n    _ = queue.Size()       // 0\n}\n```\n\n#### CircularBuffer\n\nA circular buffer, circular [queue](#queues), cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure lends itself easily to buffering data streams.\n\n<p align=\"center\"><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/f/fd/Circular_Buffer_Animation.gif/400px-Circular_Buffer_Animation.gif\" width=\"300px\" height=\"300px\" /></p>\n\nImplements [Queue](#queues), [ReverseIteratorWithIndex](#iteratorwithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport cb \"github.com/emirpasic/gods/queues/circularbuffer\"\n\n// CircularBufferExample to demonstrate basic usage of CircularBuffer\nfunc main() {\n    queue := cb.New(3)     // empty (max size is 3)\n    queue.Enqueue(1)       // 1\n    queue.Enqueue(2)       // 1, 2\n    queue.Enqueue(3)       // 1, 2, 3\n    _ = queue.Values()     // 1, 2, 3\n    queue.Enqueue(3)       // 4, 2, 3\n    _, _ = queue.Peek()    // 4,true\n    _, _ = queue.Dequeue() // 4, true\n    _, _ = queue.Dequeue() // 2, true\n    _, _ = queue.Dequeue() // 3, true\n    _, _ = queue.Dequeue() // nil, false (nothing to deque)\n    queue.Enqueue(1)       // 1\n    queue.Clear()          // empty\n    queue.Empty()          // true\n    _ = queue.Size()       // 0\n}\n```\n\n#### PriorityQueue\n\nA priority queue is a special type of [queue](#queues) in which each element is associated with a priority value. And, elements are served on the basis of their priority. That is, higher priority elements are served first. However, if elements with the same priority occur, they are served according to their order in the queue.\n\nImplements [Queue](#queues), [ReverseIteratorWithIndex](#iteratorwithindex), [JSONSerializer](#jsonserializer) and [JSONDeserializer](#jsondeserializer) interfaces.\n\n```go\npackage main\n\nimport (\n  pq \"github.com/emirpasic/gods/queues/priorityqueue\"\n  \"github.com/emirpasic/gods/utils\"\n)\n\n// Element is an entry in the priority queue\ntype Element struct {\n    name     string\n    priority int\n}\n\n// Comparator function (sort by element's priority value in descending order)\nfunc byPriority(a, b interface{}) int {\n    priorityA := a.(Element).priority\n    priorityB := b.(Element).priority\n    return -utils.IntComparator(priorityA, priorityB) // \"-\" descending order\n}\n\n// PriorityQueueExample to demonstrate basic usage of BinaryHeap\nfunc main() {\n    a := Element{name: \"a\", priority: 1}\n    b := Element{name: \"b\", priority: 2}\n    c := Element{name: \"c\", priority: 3}\n    \n    queue := pq.NewWith(byPriority) // empty\n    queue.Enqueue(a)                // {a 1}\n    queue.Enqueue(c)                // {c 3}, {a 1}\n    queue.Enqueue(b)                // {c 3}, {b 2}, {a 1}\n    _ = queue.Values()              // [{c 3} {b 2} {a 1}]\n    _, _ = queue.Peek()             // {c 3} true\n    _, _ = queue.Dequeue()          // {c 3} true\n    _, _ = queue.Dequeue()          // {b 2} true\n    _, _ = queue.Dequeue()          // {a 1} true\n    _, _ = queue.Dequeue()          // <nil> false (nothing to dequeue)\n    queue.Clear()                   // empty\n    _ = queue.Empty()               // true\n    _ = queue.Size()                // 0\n}\n```\n\n## Functions\n\nVarious helper functions used throughout the library.\n\n### Comparator\n\nSome data structures (e.g. TreeMap, TreeSet) require a comparator function to automatically keep their elements sorted upon insertion. This comparator is necessary during the initalization.\n\nComparator is defined as:\n\nReturn values (int):\n\n```go\nnegative , if a < b\nzero     , if a == b\npositive , if a > b\n```\n\nComparator signature:\n\n```go\ntype Comparator func(a, b interface{}) int\n```\n\nAll common comparators for builtin types are included in the library:\n\n```go\nfunc StringComparator(a, b interface{}) int\n\nfunc IntComparator(a, b interface{}) int\n\nfunc Int8Comparator(a, b interface{}) int\n\nfunc Int16Comparator(a, b interface{}) int\n\nfunc Int32Comparator(a, b interface{}) int\n\nfunc Int64Comparator(a, b interface{}) int\n\nfunc UIntComparator(a, b interface{}) int\n\nfunc UInt8Comparator(a, b interface{}) int\n\nfunc UInt16Comparator(a, b interface{}) int\n\nfunc UInt32Comparator(a, b interface{}) int\n\nfunc UInt64Comparator(a, b interface{}) int\n\nfunc Float32Comparator(a, b interface{}) int\n\nfunc Float64Comparator(a, b interface{}) int\n\nfunc ByteComparator(a, b interface{}) int\n\nfunc RuneComparator(a, b interface{}) int\n\nfunc TimeComparator(a, b interface{}) int\n```\n\nWriting custom comparators is easy:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/sets/treeset\"\n)\n\ntype User struct {\n\tid   int\n\tname string\n}\n\n// Custom comparator (sort by IDs)\nfunc byID(a, b interface{}) int {\n\n\t// Type assertion, program will panic if this is not respected\n\tc1 := a.(User)\n\tc2 := b.(User)\n\n\tswitch {\n\tcase c1.id > c2.id:\n\t\treturn 1\n\tcase c1.id < c2.id:\n\t\treturn -1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\nfunc main() {\n\tset := treeset.NewWith(byID)\n\n\tset.Add(User{2, \"Second\"})\n\tset.Add(User{3, \"Third\"})\n\tset.Add(User{1, \"First\"})\n\tset.Add(User{4, \"Fourth\"})\n\n\tfmt.Println(set) // {1 First}, {2 Second}, {3 Third}, {4 Fourth}\n}\n```\n\n### Iterator\n\nAll ordered containers have stateful iterators. Typically an iterator is obtained by _Iterator()_ function of an ordered container. Once obtained, iterator's _Next()_ function moves the iterator to the next element and returns true if there was a next element. If there was an element, then element's can be obtained by iterator's _Value()_ function. Depending on the ordering type, it's position can be obtained by iterator's _Index()_ or _Key()_ functions. Some containers even provide reversible iterators, essentially the same, but provide another extra _Prev()_ function that moves the iterator to the previous element and returns true if there was a previous element.\n\nNote: it is unsafe to remove elements from container while iterating.\n\n#### IteratorWithIndex\n\nAn [iterator](#iterator) whose elements are referenced by an index.\n\nTypical usage:\n```go\nit := list.Iterator()\nfor it.Next() {\n\tindex, value := it.Index(), it.Value()\n\t...\n}\n```\n\nOther usages:\n```go\nif it.First() {\n\tfirstIndex, firstValue := it.Index(), it.Value()\n\t...\n}\n```\n\n```go\nfor it.Begin(); it.Next(); {\n\t...\n}\n```\n\nSeeking to a specific element:\n\n```go\n// Seek function, i.e. find element starting with \"b\"\nseek := func(index int, value interface{}) bool {\n    return strings.HasSuffix(value.(string), \"b\")\n}\n\n// Seek to the condition and continue traversal from that point (forward).\n// assumes it.Begin() was called.\nfor found := it.NextTo(seek); found; found = it.Next() {\n    index, value := it.Index(), it.Value()\n    ...\n}\n```\n\n#### IteratorWithKey\n\nAn [iterator](#iterator) whose elements are referenced by a key.\n\nTypical usage:\n```go\nit := tree.Iterator()\nfor it.Next() {\n\tkey, value := it.Key(), it.Value()\n\t...\n}\n```\n\nOther usages:\n```go\nif it.First() {\n\tfirstKey, firstValue := it.Key(), it.Value()\n\t...\n}\n```\n\n```go\nfor it.Begin(); it.Next(); {\n\t...\n}\n```\n\nSeeking to a specific element from the current iterator position:\n\n```go\n// Seek function, i.e. find element starting with \"b\"\nseek := func(key interface{}, value interface{}) bool {\n    return strings.HasSuffix(value.(string), \"b\")\n}\n\n// Seek to the condition and continue traversal from that point (forward).\n// assumes it.Begin() was called.\nfor found := it.NextTo(seek); found; found = it.Next() {\n    key, value := it.Key(), it.Value()\n    ...\n}\n```\n\n#### ReverseIteratorWithIndex\n\nAn [iterator](#iterator) whose elements are referenced by an index. Provides all functions as [IteratorWithIndex](#iteratorwithindex), but can also be used for reverse iteration.\n\nTypical usage of iteration in reverse:\n```go\nit := list.Iterator()\nfor it.End(); it.Prev(); {\n\tindex, value := it.Index(), it.Value()\n\t...\n}\n```\n\nOther usages:\n```go\nif it.Last() {\n\tlastIndex, lastValue := it.Index(), it.Value()\n\t...\n}\n```\n\nSeeking to a specific element:\n\n```go\n// Seek function, i.e. find element starting with \"b\"\nseek := func(index int, value interface{}) bool {\n    return strings.HasSuffix(value.(string), \"b\")\n}\n\n// Seek to the condition and continue traversal from that point (in reverse).\n// assumes it.End() was called.\nfor found := it.PrevTo(seek); found; found = it.Prev() {\n    index, value := it.Index(), it.Value()\n\t...\n}\n```\n\n#### ReverseIteratorWithKey\n\nAn [iterator](#iterator) whose elements are referenced by a key. Provides all functions as [IteratorWithKey](#iteratorwithkey), but can also be used for reverse iteration.\n\nTypical usage of iteration in reverse:\n```go\nit := tree.Iterator()\nfor it.End(); it.Prev(); {\n\tkey, value := it.Key(), it.Value()\n\t...\n}\n```\n\nOther usages:\n```go\nif it.Last() {\n\tlastKey, lastValue := it.Key(), it.Value()\n\t...\n}\n```\n\n```go\n// Seek function, i.e. find element starting with \"b\"\nseek := func(key interface{}, value interface{}) bool {\n    return strings.HasSuffix(value.(string), \"b\")\n}\n\n// Seek to the condition and continue traversal from that point (in reverse).\n// assumes it.End() was called.\nfor found := it.PrevTo(seek); found; found = it.Prev() {\n    key, value := it.Key(), it.Value()\n\t...\n}\n```\n\n### Enumerable\n\nEnumerable functions for ordered containers that implement [EnumerableWithIndex](#enumerablewithindex) or [EnumerableWithKey](#enumerablewithkey) interfaces.\n\n#### EnumerableWithIndex\n\n[Enumerable](#enumerable) functions for ordered containers whose values can be fetched by an index.\n\n**Each**\n\nCalls the given function once for each element, passing that element's index and value.\n\n```go\nEach(func(index int, value interface{}))\n```\n\n**Map**\n\nInvokes the given function once for each element and returns a container containing the values returned by the given function.\n\n```go\nMap(func(index int, value interface{}) interface{}) Container\n```\n\n**Select**\n\nReturns a new container containing all elements for which the given function returns a true value.\n\n```go\nSelect(func(index int, value interface{}) bool) Container\n```\n\n**Any**\n\nPasses each element of the container to the given function and returns true if the function ever returns true for any element.\n\n```go\nAny(func(index int, value interface{}) bool) bool\n```\n\n**All**\n\nPasses each element of the container to the given function and returns true if the function returns true for all elements.\n\n```go\nAll(func(index int, value interface{}) bool) bool\n```\n\n**Find**\n\nPasses each element of the container to the given function and returns the first (index,value) for which the function is true or -1,nil otherwise if no element matches the criteria.\n\n```go\nFind(func(index int, value interface{}) bool) (int, interface{})}\n```\n\n**Example:**\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/sets/treeset\"\n)\n\nfunc printSet(txt string, set *treeset.Set) {\n\tfmt.Print(txt, \"[ \")\n\tset.Each(func(index int, value interface{}) {\n\t\tfmt.Print(value, \" \")\n\t})\n\tfmt.Println(\"]\")\n}\n\nfunc main() {\n\tset := treeset.NewWithIntComparator()\n\tset.Add(2, 3, 4, 2, 5, 6, 7, 8)\n\tprintSet(\"Initial\", set) // [ 2 3 4 5 6 7 8 ]\n\n\teven := set.Select(func(index int, value interface{}) bool {\n\t\treturn value.(int)%2 == 0\n\t})\n\tprintSet(\"Even numbers\", even) // [ 2 4 6 8 ]\n\n\tfoundIndex, foundValue := set.Find(func(index int, value interface{}) bool {\n\t\treturn value.(int)%2 == 0 && value.(int)%3 == 0\n\t})\n\tif foundIndex != -1 {\n\t\tfmt.Println(\"Number divisible by 2 and 3 found is\", foundValue, \"at index\", foundIndex) // value: 6, index: 4\n\t}\n\n\tsquare := set.Map(func(index int, value interface{}) interface{} {\n\t\treturn value.(int) * value.(int)\n\t})\n\tprintSet(\"Numbers squared\", square) // [ 4 9 16 25 36 49 64 ]\n\n\tbigger := set.Any(func(index int, value interface{}) bool {\n\t\treturn value.(int) > 5\n\t})\n\tfmt.Println(\"Set contains a number bigger than 5 is \", bigger) // true\n\n\tpositive := set.All(func(index int, value interface{}) bool {\n\t\treturn value.(int) > 0\n\t})\n\tfmt.Println(\"All numbers are positive is\", positive) // true\n\n\tevenNumbersSquared := set.Select(func(index int, value interface{}) bool {\n\t\treturn value.(int)%2 == 0\n\t}).Map(func(index int, value interface{}) interface{} {\n\t\treturn value.(int) * value.(int)\n\t})\n\tprintSet(\"Chaining\", evenNumbersSquared) // [ 4 16 36 64 ]\n}\n```\n\n#### EnumerableWithKey\n\nEnumerable functions for ordered containers whose values whose elements are key/value pairs.\n\n**Each**\n\nCalls the given function once for each element, passing that element's key and value.\n\n```go\nEach(func(key interface{}, value interface{}))\n```\n\n**Map**\n\nInvokes the given function once for each element and returns a container containing the values returned by the given function as key/value pairs.\n\n```go\nMap(func(key interface{}, value interface{}) (interface{}, interface{})) Container\n```\n\n**Select**\n\nReturns a new container containing all elements for which the given function returns a true value.\n\n```go\nSelect(func(key interface{}, value interface{}) bool) Container\n```\n\n**Any**\n\nPasses each element of the container to the given function and returns true if the function ever returns true for any element.\n\n```go\nAny(func(key interface{}, value interface{}) bool) bool\n```\n\n**All**\n\nPasses each element of the container to the given function and returns true if the function returns true for all elements.\n\n```go\nAll(func(key interface{}, value interface{}) bool) bool\n```\n\n**Find**\n\nPasses each element of the container to the given function and returns the first (key,value) for which the function is true or nil,nil otherwise if no element matches the criteria.\n\n```go\nFind(func(key interface{}, value interface{}) bool) (interface{}, interface{})\n```\n\n**Example:**\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/maps/treemap\"\n)\n\nfunc printMap(txt string, m *treemap.Map) {\n\tfmt.Print(txt, \" { \")\n\tm.Each(func(key interface{}, value interface{}) {\n\t\tfmt.Print(key, \":\", value, \" \")\n\t})\n\tfmt.Println(\"}\")\n}\n\nfunc main() {\n\tm := treemap.NewWithStringComparator()\n\tm.Put(\"g\", 7)\n\tm.Put(\"f\", 6)\n\tm.Put(\"e\", 5)\n\tm.Put(\"d\", 4)\n\tm.Put(\"c\", 3)\n\tm.Put(\"b\", 2)\n\tm.Put(\"a\", 1)\n\tprintMap(\"Initial\", m) // { a:1 b:2 c:3 d:4 e:5 f:6 g:7 }\n\n\teven := m.Select(func(key interface{}, value interface{}) bool {\n\t\treturn value.(int) % 2 == 0\n\t})\n\tprintMap(\"Elements with even values\", even) // { b:2 d:4 f:6 }\n\n\tfoundKey, foundValue := m.Find(func(key interface{}, value interface{}) bool {\n\t\treturn value.(int) % 2 == 0 && value.(int) % 3 == 0\n\t})\n\tif foundKey != nil {\n\t\tfmt.Println(\"Element with value divisible by 2 and 3 found is\", foundValue, \"with key\", foundKey) // value: 6, index: 4\n\t}\n\n\tsquare := m.Map(func(key interface{}, value interface{}) (interface{}, interface{}) {\n\t\treturn key.(string) + key.(string), value.(int) * value.(int)\n\t})\n\tprintMap(\"Elements' values squared and letters duplicated\", square) // { aa:1 bb:4 cc:9 dd:16 ee:25 ff:36 gg:49 }\n\n\tbigger := m.Any(func(key interface{}, value interface{}) bool {\n\t\treturn value.(int) > 5\n\t})\n\tfmt.Println(\"Map contains element whose value is bigger than 5 is\", bigger) // true\n\n\tpositive := m.All(func(key interface{}, value interface{}) bool {\n\t\treturn value.(int) > 0\n\t})\n\tfmt.Println(\"All map's elements have positive values is\", positive) // true\n\n\tevenNumbersSquared := m.Select(func(key interface{}, value interface{}) bool {\n\t\treturn value.(int) % 2 == 0\n\t}).Map(func(key interface{}, value interface{}) (interface{}, interface{}) {\n\t\treturn key, value.(int) * value.(int)\n\t})\n\tprintMap(\"Chaining\", evenNumbersSquared) // { b:4 d:16 f:36 }\n}\n```\n\n### Serialization\n\nAll data structures can be serialized (marshalled) and deserialized (unmarshalled). Currently, only JSON support is available.\n\n#### JSONSerializer\n\nOutputs the container into its JSON representation.\n\nTypical usage for key-value structures:\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/maps/hashmap\"\n)\n\nfunc main() {\n\tm := hashmap.New()\n\tm.Put(\"a\", \"1\")\n\tm.Put(\"b\", \"2\")\n\tm.Put(\"c\", \"3\")\n\n\tbytes, err := json.Marshal(m) // Same as \"m.ToJSON(m)\"\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(string(bytes)) // {\"a\":\"1\",\"b\":\"2\",\"c\":\"3\"}\n}\n```\n\nTypical usage for value-only structures:\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/lists/arraylist\"\n)\n\nfunc main() {\n\tlist := arraylist.New()\n\tlist.Add(\"a\", \"b\", \"c\")\n\n\tbytes, err := json.Marshal(list) // Same as \"list.ToJSON(list)\"\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(string(bytes)) // [\"a\",\"b\",\"c\"]\n}\n```\n\n#### JSONDeserializer\n\nPopulates the container with elements from the input JSON representation.\n\nTypical usage for key-value structures:\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/maps/hashmap\"\n)\n\nfunc main() {\n\thm := hashmap.New()\n\n\tbytes := []byte(`{\"a\":\"1\",\"b\":\"2\"}`)\n\terr := json.Unmarshal(bytes, &hm) // Same as \"hm.FromJSON(bytes)\"\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(hm) // HashMap map[b:2 a:1]\n}\n```\n\nTypical usage for value-only structures:\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/emirpasic/gods/lists/arraylist\"\n)\n\nfunc main() {\n\tlist := arraylist.New()\n\n\tbytes := []byte(`[\"a\",\"b\"]`)\n\terr := json.Unmarshal(bytes, &list) // Same as \"list.FromJSON(bytes)\"\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(list) // ArrayList [\"a\",\"b\"]\n}\n```\n\n### Sort\n\nSort is a general purpose sort function.\n\nLists have an in-place _Sort()_ function and all containers can return their sorted elements via _containers.GetSortedValues()_ function.\n\nInternally these all use the _utils.Sort()_ method:\n\n```go\npackage main\n\nimport \"github.com/emirpasic/gods/utils\"\n\nfunc main() {\n\tstrings := []interface{}{}                  // []\n\tstrings = append(strings, \"d\")              // [\"d\"]\n\tstrings = append(strings, \"a\")              // [\"d\",\"a\"]\n\tstrings = append(strings, \"b\")              // [\"d\",\"a\",b\"\n\tstrings = append(strings, \"c\")              // [\"d\",\"a\",b\",\"c\"]\n\tutils.Sort(strings, utils.StringComparator) // [\"a\",\"b\",\"c\",\"d\"]\n}\n```\n\n### Container\n\nContainer specific operations:\n\n```go\n// Returns sorted container''s elements with respect to the passed comparator.\n// Does not affect the ordering of elements within the container.\nfunc GetSortedValues(container Container, comparator utils.Comparator) []interface{}\n```\n\nUsage:\n\n```go\npackage main\n\nimport (\n\t\"github.com/emirpasic/gods/lists/arraylist\"\n\t\"github.com/emirpasic/gods/utils\"\n)\n\nfunc main() {\n\tlist := arraylist.New()\n\tlist.Add(2, 1, 3)\n\tvalues := GetSortedValues(container, utils.StringComparator) // [1, 2, 3]\n}\n```\n\n## Appendix\n\n### Motivation\n\nCollections and data structures found in other languages: Java Collections, C++ Standard Template Library (STL) containers, Qt Containers, Ruby Enumerable etc.\n\n### Goals\n\n**Fast algorithms**:\n\n  - Based on decades of knowledge and experiences of other libraries mentioned above.\n\n**Memory efficient algorithms**:\n\n  - Avoiding to consume memory by using optimal algorithms and data structures for the given set of problems, e.g. red-black tree in case of TreeMap to avoid keeping redundant sorted array of keys in memory.\n\n**Easy to use library**:\n\n  - Well-structured library with minimalistic set of atomic operations from which more complex operations can be crafted.\n\n**Stable library**:\n\n  - Only additions are permitted keeping the library backward compatible.\n\n**Solid documentation and examples**:\n\n  - Learning by example.\n\n**Production ready**:\n\n  - Used in production.\n\n**No dependencies**:\n\n  - No external imports.\n\nThere is often a tug of war between speed and memory when crafting algorithms. We choose to optimize for speed in most cases within reasonable limits on memory consumption.\n\nThread safety is not a concern of this project, this should be handled at a higher level.\n\n### Testing and Benchmarking\n\nThis takes a while, so test within sub-packages:\n\n`go test -run=NO_TEST -bench . -benchmem  -benchtime 1s ./...`\n\n<p align=\"center\"><img src=\"https://cloud.githubusercontent.com/assets/3115942/16892979/5e698d46-4b27-11e6-864b-cb2b865327b6.png\" /></p>\n\n### Contributing\n\nBiggest contribution towards this library is to use it and give us feedback for further improvements and additions.\n\nFor direct contributions, _pull request_ into master branch or ask to become a contributor.\n\nCoding style:\n\n```shell\n# Install tooling and set path:\ngo install gotest.tools/gotestsum@latest\ngo install golang.org/x/lint/golint@latest\ngo install github.com/kisielk/errcheck@latest\nexport PATH=$PATH:$GOPATH/bin\n\n# Fix errors and warnings:\ngo fmt ./... &&\ngo test -v ./... && \ngolint -set_exit_status ./... && \n! go fmt ./... 2>&1 | read &&\ngo vet -v ./... &&\ngocyclo -avg -over 15 ../gods &&\nerrcheck ./...\n```\n\n### License\n\nThis library is distributed under the BSD-style license found in the [LICENSE](https://github.com/emirpasic/gods/blob/master/LICENSE) file.\n\n### Sponsors\n\n## <a href=\"https://www.browserstack.com/?ref=gods\"><img src=\"http://www.hajdarevic.net/browserstack.svg\" alt=\"BrowserStack\" width=\"250\"/></a>\n[BrowserStack](https://www.browserstack.com/?ref=webhook) is a cloud-based cross-browser testing tool that enables developers to test their websites across various browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.\n"
        },
        {
          "name": "containers",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0439453125,
          "content": "module github.com/emirpasic/gods/v2\n\ngo 1.21\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.1669921875,
          "content": "github.com/emirpasic/gods v1.18.1 h1:FXtiHYKDGKCW2KzwZKx0iC0PQmdlorYgdFG9jPXJ1Bc=\ngithub.com/emirpasic/gods v1.18.1/go.mod h1:8tpGGwCnJ5H4r6BWwaV6OrWmMoPhUl5jm/FMNAnJvWQ=\n"
        },
        {
          "name": "lists",
          "type": "tree",
          "content": null
        },
        {
          "name": "maps",
          "type": "tree",
          "content": null
        },
        {
          "name": "queues",
          "type": "tree",
          "content": null
        },
        {
          "name": "sets",
          "type": "tree",
          "content": null
        },
        {
          "name": "stacks",
          "type": "tree",
          "content": null
        },
        {
          "name": "testutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "trees",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}