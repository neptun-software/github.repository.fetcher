{
  "metadata": {
    "timestamp": 1736568104094,
    "page": 242,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjI0OA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "oauth2-proxy/oauth2-proxy",
      "stars": 10180,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.0546875,
          "content": "Dockerfile.dev\nDockerfile\ndocs\nvendor\n.git\noauth2-proxy\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.583984375,
          "content": "oauth2-proxy\nvendor\ndist\nrelease\n.godeps\n*.exe\n.env\n.bundle\nc.out\n\n# Go.gitignore\n# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n.idea/\n.vscode/*\n!/.vscode/tasks.json\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n# Editor swap/temp files\n.*.swp\n\n# Dockerfile.dev is ignored by both git and docker\n# for faster development cycle of docker build\n# cp Dockerfile Dockerfile.dev\n# vi Dockerfile.dev\n# docker build -f Dockerfile.dev .\nDockerfile.dev\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.8076171875,
          "content": "run:\n  deadline: 120s\nlinters:\n  enable:\n    - govet\n    - ineffassign\n    - goconst\n    - gofmt\n    - goimports\n    - gosec\n    - gosimple\n    - staticcheck\n    - typecheck\n    - unused\n    - bodyclose\n    - dogsled\n    - goprintffuncname\n    - misspell\n    - prealloc\n    - copyloopvar\n    - stylecheck\n    - unconvert\n    - gocritic\n    - revive\n  disable-all: true\nissues:\n  exclude-rules:\n    - path: _test\\.go\n      linters:\n        - scopelint\n        - bodyclose\n        - unconvert\n        - gocritic\n        - gosec\n        - goconst\n        - revive\n    - path: _test\\.go\n      linters:\n        - revive\n      text: \"dot-imports:\"\n    # If we have tests in shared test folders, these can be less strictly linted\n    - path: tests/.*_tests\\.go\n      linters:\n        - revive\n        - bodyclose\n        - stylecheck\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.3291015625,
          "content": "repos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.3.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n  - repo: https://github.com/dnephin/pre-commit-golang\n    rev: v0.5.0\n    hooks:\n    - id: golangci-lint\n    - id: go-build\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "ADOPTERS.md",
          "type": "blob",
          "size": 1.02734375,
          "content": "# Adopters\n\nThis list showcases organizations that leverage OAuth2-Proxy within their\ninfrastructure. If your organization uses OAuth2-Proxy and isn't yet listed, we\nencourage you to add it!\n\nThis list aims to be a comprehensive and trusted resource for the OAuth2-Proxy\ncommunity, demonstrating successful adoption across all kinds of industries.\n\nContributing to this list is a simple way to impact the project's growth,\nmaturity, and momentum. Thank you to all adopters and contributors of the\nOAuth2-Proxy project!\n\n## Updating this list\n\nTo add your organization to this list, you can just [open a PR](https://github.com/oauth2-proxy/oauth2-proxy/pulls)\nto directly update this list.\n\nAdd your organization name, your github username and if you desire a short\ndescription on how you utilize oauth2-proxy.\n\n## OAuth2-Proxy Adopters\n\nThis list is sorted in the order that organizations were added to it.\n\n| Organization | Contact | Description of Use |\n| ------------ | ------- | ------------------ |\n|              |         |                    |\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 90.44140625,
          "content": "# Vx.x.x (Pre-release)\n\n## Release Highlights\n\n## Important Notes\n\n## Breaking Changes\n\n## Changes since v7.7.1\n\n- [#2800](https://github.com/oauth2-proxy/oauth2-proxy/pull/2800) Add some opencontainer labels to docker image (@halkeye)\n- [#2755](https://github.com/oauth2-proxy/oauth2-proxy/pull/2755) feat: add X-Envoy-External-Address as supported header (@bjencks)\n- [#1985](https://github.com/oauth2-proxy/oauth2-proxy/pull/1985) Add support for systemd socket (@isodude)\n- [#2300](https://github.com/oauth2-proxy/oauth2-proxy/pull/2300) Add fix for websocket path rewrite (@rekup)\n- [#2821](https://github.com/oauth2-proxy/oauth2-proxy/pull/2821) feat: add CF-Connecting-IP as supported real ip header (@ondrejsika)\n- [#2620](https://github.com/oauth2-proxy/oauth2-proxy/pull/2620) fix: update code_verifier to use recommended method (@vishvananda)\n- [#2392](https://github.com/oauth2-proxy/oauth2-proxy/pull/2392) chore: extend test cases for oidc provider and documentation regarding implicit setting of the groups scope when no scope was specified in the config (@jjlakis / @tuunit)\n\n# V7.7.1\n\n## Release Highlights\n\n- üêõ Several bugs have been squashed\n\n## Important Notes\n\n## Breaking Changes\n\n## Changes since v7.7.0\n\n- [#2803](https://github.com/oauth2-proxy/oauth2-proxy/pull/2803) fix: self signed certificate handling in v7.7.0 (@tuunit)\n- [#2619](https://github.com/oauth2-proxy/oauth2-proxy/pull/2619) fix: unable to use hyphen in JSON path for oidc-groups-claim option (@rd-danny-fleer)\n- [#2311](https://github.com/oauth2-proxy/oauth2-proxy/pull/2311) fix: runtime error: index out of range (0) with length 0 (@miguelborges99 / @tuunit)\n\n# V7.7.0\n\n## Release Highlights\n\n- üåê Custom user agent \"oauth2-proxy/<version>\"\n- üíæ Added s390x architecture support\n- üïµÔ∏è‚Äç‚ôÄÔ∏è Vulnerabilities have been addressed\n  - CVE-2024-24786\n  - CVE-2024-24791\n  - CVE-2024-24790\n  - CVE-2024-24784\n- üìñ Improved docs\n\n## Important Notes\n- Remove support of arm/v6 for distroless image runtime. Alpine tags still support arm/v6.\n\n## Breaking Changes\n\n## Changes since v7.6.0\n\n- [#2539](https://github.com/oauth2-proxy/oauth2-proxy/pull/2539) pkg/http: Fix leaky test (@isodude)\n- [#4917](https://github.com/oauth2-proxy/oauth2-proxy/pull/4917) Upgraded all modules to the latest version (@pierluigilenoci)\n- [#2570](https://github.com/oauth2-proxy/oauth2-proxy/pull/2570) Set default user agent to oauth2-proxy/$version (from default Golang one)\n- [#2674](https://github.com/oauth2-proxy/oauth2-proxy/pull/2674) docs: additional notes about available claims for HeaderValue (@vegetablest)\n- [#2459](https://github.com/oauth2-proxy/oauth2-proxy/pull/2459) chore(deps): Updated to ginkgo v2 (@kvanzuijlen, @tuunit)\n- [#2112](https://github.com/oauth2-proxy/oauth2-proxy/pull/2112) docs: update list of providers which support refresh tokens (@mikefab-msf)\n- [#2734](https://github.com/oauth2-proxy/oauth2-proxy/pull/2734) Added s390x architecture option support (@priby05)\n- [#2589](https://github.com/oauth2-proxy/oauth2-proxy/pull/2589) Added support for regex path matching and rewriting when using a static `file:` upstream (@ianroberts)\n- [#2790](https://github.com/oauth2-proxy/oauth2-proxy/pull/2790) chore(deps): update all golang dependencies (@tuunit)\n- [#2607](https://github.com/oauth2-proxy/oauth2-proxy/pull/2607) fix(csrf): fix possible infinite loop (@Primexz)\n\n# V7.6.0\n\n## Release Highlights\n\n## Important Notes\n\n## Breaking Changes\n\n## Changes since v7.5.1\n\n- [#2381](https://github.com/oauth2-proxy/oauth2-proxy/pull/2381) Allow username authentication to Redis cluster (@rossigee)\n- [#2345](https://github.com/oauth2-proxy/oauth2-proxy/pull/2345) Log error details when failed loading CSRF cookie (@charvadzo)\n- [#2128](https://github.com/oauth2-proxy/oauth2-proxy/pull/2128) Update dependencies (@vllvll)\n- [#2269](https://github.com/oauth2-proxy/oauth2-proxy/pull/2269) Added Azure China (and other air gaped cloud) support (@mblaschke)\n- [#2237](https://github.com/oauth2-proxy/oauth2-proxy/pull/2237) adds an option to append CA certificates (@emsixteeen)\n- [#2128](https://github.com/oauth2-proxy/oauth2-proxy/pull/2128) Update dependencies (@vllvll)\n- [#2239](https://github.com/oauth2-proxy/oauth2-proxy/pull/2312) Add possibility to encode the state param as UrlEncodedBase64 (@brezinajn)\n- [#2274](https://github.com/oauth2-proxy/oauth2-proxy/pull/2274) Upgrade golang.org/x/net to v0.17.0 (@pierluigilenoci)\n- [#2278](https://github.com/oauth2-proxy/oauth2-proxy/pull/2278) Improve the Nginx auth_request example (@akunzai)\n- [#2282](https://github.com/oauth2-proxy/oauth2-proxy/pull/2282) Fixed checking Google Groups membership using Google Application Credentials (@kvanzuijlen)\n- [#2183](https://github.com/oauth2-proxy/oauth2-proxy/pull/2183) Allowing relative redirect url though an option (@axel7083)\n- [#1866](https://github.com/oauth2-proxy/oauth2-proxy/pull/1866) Add support for unix socker as upstream (@babs)\n- [#1876](https://github.com/oauth2-proxy/oauth2-proxy/pull/1876) Add `--backend-logout-url` with `{id_token}` placeholder (@babs)\n- [#1949](https://github.com/oauth2-proxy/oauth2-proxy/pull/1949) Allow cookie names with dots in redis sessions (@miguelborges99)\n- [#2297](https://github.com/oauth2-proxy/oauth2-proxy/pull/2297) Add nightly build and push (@tuunit)\n- [#2329](https://github.com/oauth2-proxy/oauth2-proxy/pull/2329) Add an option to skip request to profile URL for resolving missing claims in id_token (@nilsgstrabo)\n- [#2299](https://github.com/oauth2-proxy/oauth2-proxy/pull/2299) bugfix: OIDCConfig based providers are not respecting flags and configs (@tuunit)\n- [#2343](https://github.com/oauth2-proxy/oauth2-proxy/pull/2343) chore: Added checksums for .tar.gz (@kvanzuijlen)\n- [#2248](https://github.com/oauth2-proxy/oauth2-proxy/pull/2248) Added support for semicolons in query strings. (@timwsuqld)\n- [#2196](https://github.com/oauth2-proxy/oauth2-proxy/pull/2196) Add GitHub groups (orgs/teams) support. Including `X-Forwarded-Groups` header (@tuunit)\n- [#2371](https://github.com/oauth2-proxy/oauth2-proxy/pull/2371) Remove nsswitch DNS resolution workaround (@tuunit)\n- [#2295](https://github.com/oauth2-proxy/oauth2-proxy/pull/2295) Change base-image to [GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless) (@kvanzuijlen)\n- [#2356](https://github.com/oauth2-proxy/oauth2-proxy/pull/2356) Update go-jose dependency (@dasvh)\n- [#2357](https://github.com/oauth2-proxy/oauth2-proxy/pull/2357) Update ojg to latest release (@bitfehler)\n- [#1922](https://github.com/oauth2-proxy/oauth2-proxy/pull/1922) Added support for env variables in the alpha struct (@hevans-dglcom)\n- [#2235](https://github.com/oauth2-proxy/oauth2-proxy/pull/2235) Bump golang to 1.21 and min allowed version to 1.20 (@tuunit)\n\n# V7.5.1\n\n## Release Highlights\n- üêõ Several bugs have been squashed\n- üïµÔ∏è‚Äç‚ôÄÔ∏è Vulnerabilities have been addressed\n- üìñImproved docs\n\n## Important Notes\n\n- This release includes fixes for a number of CVEs, we recommend to upgrade as soon as possible.\n- The environment variable OAUTH2_PROXY_GOOGLE_GROUP has been deprecated in favor of OAUTH2_PROXY_GOOGLE_GROUPS. Next major release\nwill remove this option. This change makes sure that the configuration options follow the documentation.\n\n## Breaking Changes\n\nN/A\n\n## Changes since v7.5.0\n- [#2220](https://github.com/oauth2-proxy/oauth2-proxy/pull/2220) Added binary and docker release platforms (@kvanzuijlen)\n- [#2221](https://github.com/oauth2-proxy/oauth2-proxy/pull/2221) Backwards compatible fix for wrong environment variable name (OAUTH2_PROXY_GOOGLE_GROUPS) (@kvanzuijlen)\n- [#1989](https://github.com/oauth2-proxy/oauth2-proxy/pull/1989) Fix default scope for keycloak-oidc provider (@tuunit)\n- [#2217](https://github.com/oauth2-proxy/oauth2-proxy/pull/2217) Upgrade alpine to version 3.18 (@polarctos)\n- [#2208](https://github.com/oauth2-proxy/oauth2-proxy/pull/2208) Improved session documentation (@lathspell)\n- [#2229](https://github.com/oauth2-proxy/oauth2-proxy/pull/2229) bugfix: default scopes for OIDCProvider based providers (@tuunit)\n- [#2194](https://github.com/oauth2-proxy/oauth2-proxy/pull/2194) Fix Gitea token validation (@tuunit)\n\n# V7.5.0\n\n## Release Highlights\n- üêõ Several bugs have been squashed\n- üïµÔ∏è‚Äç‚ôÄÔ∏è Vulnerabilities have been addressed\n- ‚≠êÔ∏è Added a readiness endpoint to check if the application is ready to receive traffic\n- ‚≠êÔ∏è Google Application Default Credentials support (i.e. for running on Google Cloud Platform)\n- ‚≠ê Session cookie support\n\n## Important Notes\n\n- This release includes fixes for a number of CVEs, we recommend to upgrade as soon as possible.\n- This release was pushed with the wrong Docker platform type for arm64/armv8. Use v7.5.1 instead.\n- This release introduced a bug with the Keycloak OIDC provider causing no scopes to be send along with the request. Use v7.5.1 instead.\n\n## Breaking Changes\nThe following PR introduces a change to how auth routes are evaluated using the flags `skip-auth-route`/`skip-auth-regex`. The new behaviour uses the regex you specify to evaluate the full path including query parameters. For more details please read the detailed description [#2271](https://github.com/oauth2-proxy/oauth2-proxy/issues/2271)\n- [#2192](https://github.com/oauth2-proxy/oauth2-proxy/pull/2192) Use X-Forwarded-Uri if it exists for pathRegex match (@mzndr / @jawys)\n\n## Changes since v7.4.0\n- [#2028](https://github.com/oauth2-proxy/oauth2-proxy/pull/2028) Update golang.org/x/net to v0.7.0 ato address GHSA-vvpx-j8f3-3w6h (@amrmahdi)\n- [#1873](https://github.com/oauth2-proxy/oauth2-proxy/pull/1873) Fix empty users with some OIDC providers (@babs)\n- [#1882](https://github.com/oauth2-proxy/oauth2-proxy/pull/1882) Make `htpasswd.GetUsers` racecondition safe (@babs)\n- [#1883](https://github.com/oauth2-proxy/oauth2-proxy/pull/1883) Ensure v8 manifest variant is set on docker images (@braunsonm)\n- [#1906](https://github.com/oauth2-proxy/oauth2-proxy/pull/1906) Fix PKCE code verifier generation to never use UTF-8 characters (@braunsonm)\n- [#1839](https://github.com/oauth2-proxy/oauth2-proxy/pull/1839) Add readiness checks for deeper health checks (@kobim)\n- [#1927](https://github.com/oauth2-proxy/oauth2-proxy/pull/1927) Fix default scope settings for none oidc providers (@tuunit)\n- [#1713](https://github.com/oauth2-proxy/oauth2-proxy/pull/1713) Add session cookie support (@t-katsumura @tanuki884)\n- [#1951](https://github.com/oauth2-proxy/oauth2-proxy/pull/1951) Fix validate URL, check if query string marker (?) or separator (&) needs to be appended (@miguelborges99)\n- [#1920](https://github.com/oauth2-proxy/oauth2-proxy/pull/1920) Make sure emailClaim is not overriden if userIDClaim is not set (@mdreem)\n- [#2010](https://github.com/oauth2-proxy/oauth2-proxy/pull/2010) Log the difference between invalid email and not authorized session (@omBratteng)\n- [#1988](https://github.com/oauth2-proxy/oauth2-proxy/pull/1988) Ensure sign-in page background is uniform throughout the page (@corybolar)\n- [#2013](https://github.com/oauth2-proxy/oauth2-proxy/pull/2013) Upgrade alpine to version 3.17.2 and library dependencies (@miguelborges99)\n- [#2047](https://github.com/oauth2-proxy/oauth2-proxy/pull/2047) CVE-2022-41717: DoS in Go net/http may lead to DoS (@miguelborges99)\n- [#2126](https://github.com/oauth2-proxy/oauth2-proxy/pull/2126) Added support for GKE Workload Identity (@kvanzuijlen)\n- [#1921](https://github.com/oauth2-proxy/oauth2-proxy/pull/1921) Check jsonpath syntax before interpretation (@eloo-abi)\n- [#2025](https://github.com/oauth2-proxy/oauth2-proxy/pull/2025) Embed static stylesheets and dependencies (@corybolar)\n\n# V7.4.0\n\n## Release Highlights\n\n- New Azure groups support for Azure OAuth2 v2.0\n- Option to configure API routes - paths that will not redirect to login when unauthenticated\n- CSRF and session cookies now have different timeouts\n\n## Important Notes\n\n- [#1708](https://github.com/oauth2-proxy/oauth2-proxy/pull/1708) Enable different CSRF cookies per request (@miguelborges99)\n  - Since the CSRF cookie name is now longer it could potentially break long cookie names (around 1000 characters).\n  - Having a unique CSRF cookie per request can lead to quite a number of cookies, in case an application performs a high number of parallel authentication requests. Each call will redirect to /oauth2/start, if the user is not authenticated, and a new cookie will be set. The successfully authenticated requests will have its CSRF cookies immediatly expired, however the failed ones will mantain its CSRF cookies until they expire (by default in 15 minutes).\n  - The user may redefine the CSRF cookie expiration time using flag \"--cookie-csrf-expire\" (e.g. --cookie-csrf-expire=5m). By default, it is 15 minutes, but you can fine tune to your environment.\n- [#1574](https://github.com/oauth2-proxy/oauth2-proxy/pull/1574) Add Azure groups support and Azure OAuth v2.0 (@adriananeci)\n  - group membership check is now validated while using the the azure provider.\n  - Azure OAuth v2.0 (https://login.microsoftonline.com/{tenant_id}/v2.0) is now available along with Azure OAuth v1.0. See https://github.com/oauth2-proxy/oauth2-proxy/blob/master/docs/docs/configuration/auth.md#azure-auth-provider for more details\n  - When using v2.0 Azure Auth endpoint (`https://login.microsoftonline.com/{tenant-id}/v2.0`) as `--oidc_issuer_url`, in conjunction with `--resource` flag, be sure to append `/.default` at the end of the resource name. See https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#the-default-scope for more details.\n- This release includes fixes for a number of CVEs, we recommend to upgrade as soon as possible.\n\n## Breaking Changes\n\nN/A\n\n## Changes since v7.3.0\n\n- [#1862](https://github.com/oauth2-proxy/oauth2-proxy/pull/1862) Update dependencies (@JoelSpeed)\n- [#1828](https://github.com/oauth2-proxy/oauth2-proxy/pull/1828) call providerData.setProviderDefaults for oidc provider to achieve consistent behaviour (@centzilius)\n  - UserClaim will be set to sub instead of beeing empty from now on.\n- [#1691](https://github.com/oauth2-proxy/oauth2-proxy/pull/1691) Fix Redis IdleTimeout when Redis timeout option is set to non-zero (@dimss)\n- [#1669](https://github.com/oauth2-proxy/oauth2-proxy/pull/1699) Fix method deprecated error in lint (@t-katsumura)\n- [#1701](https://github.com/oauth2-proxy/oauth2-proxy/pull/1701) Watch the htpasswd file for changes and update the htpasswdMap (@aiciobanu)\n- [#1709](https://github.com/oauth2-proxy/oauth2-proxy/pull/1709) Show an alert message when basic auth credentials are invalid (@aiciobanu)\n- [#1723](https://github.com/oauth2-proxy/oauth2-proxy/pull/1723) Added ability to specify allowed TLS cipher suites. (@crbednarz)\n- [#1720](https://github.com/oauth2-proxy/oauth2-proxy/pull/1720) Extract roles from authToken, to allow using allowed roles with Keycloak. (@MrDeerly )\n- [#1774](https://github.com/oauth2-proxy/oauth2-proxy/pull/1774) Fix vulnerabilities CVE-2022-27191, CVE-2021-44716 and CVE-2022-29526. (@felipeconti)\n- [#1667](https://github.com/oauth2-proxy/oauth2-proxy/issues/1667) Rename configuration file flag for PKCE (@ChrisEke)\nto remain consistent with CLI flags. You should specify `code_challenge_method` in your configuration instead of\n`force_code_challenge_method`.\n- [#1708](https://github.com/oauth2-proxy/oauth2-proxy/pull/1708) Enable different CSRF cookies per request (@miguelborges99)\n  - Add flag \"--cookie-csrf-per-request\" which activates an algorithm to name CSRF cookies differently per request.\n    This feature allows parallel callbacks and by default it is disabled.\n  - Add flag \"--cookie-csrf-expire\" to define a different expiration time for the CSRF cookie. By default, it is 15 minutes.\n- [#1762](https://github.com/oauth2-proxy/oauth2-proxy/pull/1762) Support negating for skip auth routes (@ianldge)\n- [#1788](https://github.com/oauth2-proxy/oauth2-proxy/pull/1788) Update base docker image to alpine 3.16 (@tooptoop4)\n- [#1760](https://github.com/oauth2-proxy/oauth2-proxy/pull/1760) Option to configure API routes (@segfault16)\n- [#1825](https://github.com/oauth2-proxy/oauth2-proxy/pull/1825) Fix vulnerabilities CVE-2022-32149 and CVE-2022-27664. (@crbednarz)\n- [#1750](https://github.com/oauth2-proxy/oauth2-proxy/pull/1750) Fix Nextcloud provider (@n1tehawk)\n- [#1574](https://github.com/oauth2-proxy/oauth2-proxy/pull/1574) Add Azure groups support and Azure OAuth v2.0 (@adriananeci)\n- [#1851](https://github.com/oauth2-proxy/oauth2-proxy/pull/1851) Bump golang to 1.19 and min allowed version to 1.18 (@adriananeci)\n- [#1815](https://github.com/oauth2-proxy/oauth2-proxy/pull/1815) Keycloak: save user and preferredUsername in session to populate headers for the backend (@babs)\n- [#1847](https://github.com/oauth2-proxy/oauth2-proxy/pull/1847) Update go-redis/redis to v9 (@arhamGH)\n-\n# V7.3.0\n\n## Release Highlights\n\n- [#1361](https://github.com/oauth2-proxy/oauth2-proxy/pull/1541) PKCE Code Challenge Support - RFC-7636 (@braunsonm)\n  - At this time the `--code-challenge-method` flag can be used to enable it with the method of your choice.\n- Parital support for OAuth2 Authorization Server Metadata for detecting code challenge methods (@braunsonm)\n  - A warning will be displayed when your provider advertises support for PKCE but you have not enabled it.\n- Support for the ARMv8 and ppc64le architectures\n- Configurable upstream request timeouts\n\n## Important Notes\n\n- [oauth2-proxy](https://quay.io/repository/oauth2-proxy/oauth2-proxy?tab=tags&tag=latest) separate image tags for each architecture is deprecated. Instead, images are cross compiled and pushed as the same tag for every platform.\nIf you are using an architecture specific tag (ex: v7.2.1-arm64) you should move to the generic tag instead (ex: v7.2.1 )\n- [#1478](https://github.com/oauth2-proxy/oauth2-proxy/pull/1478) Changes the UID and GID of the runtime user to `65532`.\n  Which also is known as `nonroot` user in [distroless images](https://github.com/GoogleContainerTools/distroless).\n- This release includes fixes for a number of CVEs, we recomend to upgrade as soon as possible.\n\n## Breaking Changes\n\n- [#1666](https://github.com/oauth2-proxy/oauth2-proxy/issues/1666) Azure provider breaks after upgrading to this version. Please see the issue for more details.\n\n## Changes since v7.2.1\n\n- [#1662](https://github.com/oauth2-proxy/oauth2-proxy/pull/1662) Discover signature algorithms from OIDC provider (@JoelSpeed)\n- [#1651](https://github.com/oauth2-proxy/oauth2-proxy/pull/1651) Updated go-lang's text, crypto and prometheus dependencies to fix reported security vulnerabilities. (@rkkris75)\n- [#1595](https://github.com/oauth2-proxy/oauth2-proxy/pull/1595) Add optional `allowed_emails` query parameter to the `auth_request`. (@zv0n)\n- [#1478](https://github.com/oauth2-proxy/oauth2-proxy/pull/1478) Parameterise the runtime image (@omBratteng)\n- [#1583](https://github.com/oauth2-proxy/oauth2-proxy/pull/1583) Add groups to session too when creating session from bearer token (@adriananeci)\n- [#1418](https://github.com/oauth2-proxy/oauth2-proxy/pull/1418) Support for passing arbitrary query parameters through from `/oauth2/start` to the identity provider's login URL. Configuration settings control which parameters are passed by default and precisely which values can be overridden per-request (@ianroberts)\n- [#1559](https://github.com/oauth2-proxy/oauth2-proxy/pull/1559) Introduce ProviderVerifier to clean up OIDC discovery code (@JoelSpeed)\n- [#1561](https://github.com/oauth2-proxy/oauth2-proxy/pull/1561) Add ppc64le support (@mgiessing)\n- [#1563](https://github.com/oauth2-proxy/oauth2-proxy/pull/1563) Ensure claim extractor does not attempt profile call when URL is empty (@JoelSpeed)\n- [#1560](https://github.com/oauth2-proxy/oauth2-proxy/pull/1560) Fix provider data initialisation (@JoelSpeed)\n- [#1555](https://github.com/oauth2-proxy/oauth2-proxy/pull/1555) Refactor provider configuration into providers package (@JoelSpeed)\n- [#1394](https://github.com/oauth2-proxy/oauth2-proxy/pull/1394) Add generic claim extractor to get claims from ID Tokens (@JoelSpeed)\n- [#1468](https://github.com/oauth2-proxy/oauth2-proxy/pull/1468) Implement session locking with session state lock (@JoelSpeed, @Bibob7)\n- [#1489](https://github.com/oauth2-proxy/oauth2-proxy/pull/1489) Fix Docker Buildx push to include build version (@JoelSpeed)\n- [#1477](https://github.com/oauth2-proxy/oauth2-proxy/pull/1477) Remove provider documentation for `Microsoft Azure AD` (@omBratteng)\n- [#1204](https://github.com/oauth2-proxy/oauth2-proxy/pull/1204) Added configuration for audience claim (`--oidc-extra-audience`) and ability to specify extra audiences (`--oidc-extra-audience`) allowed passing audience verification. This enables support for AWS Cognito and other issuers that have custom audience claims. Also, this adds the ability to allow multiple audiences. (@kschu91)\n- [#1509](https://github.com/oauth2-proxy/oauth2-proxy/pull/1509) Update LoginGovProvider ValidateSession to pass access_token in Header (@pksheldon4)\n- [#1474](https://github.com/oauth2-proxy/oauth2-proxy/pull/1474) Support configuration of minimal acceptable TLS version (@polarctos)\n- [#1545](https://github.com/oauth2-proxy/oauth2-proxy/pull/1545) Fix issue with query string allowed group panic on skip methods (@andytson)\n- [#1286](https://github.com/oauth2-proxy/oauth2-proxy/pull/1286) Add the `allowed_email_domains` and the `allowed_groups` on the `auth_request` + support standard wildcard char for validation with sub-domain and email-domain. (@w3st3ry @armandpicard)\n- [#1361](https://github.com/oauth2-proxy/oauth2-proxy/pull/1541) PKCE Code Challenge Support - RFC-7636 (@braunsonm)\n- [#1594](https://github.com/oauth2-proxy/oauth2-proxy/pull/1594) Release ARMv8 docker images (@braunsonm)\n- [#1649](https://github.com/oauth2-proxy/oauth2-proxy/pull/1649) Return a 400 instead of a 500 when a request contains an invalid redirect target (@niksko)\n- [#1638](https://github.com/oauth2-proxy/oauth2-proxy/pull/1638) Implement configurable upstream timeout (@jacksgt)\n- [#1650](https://github.com/oauth2-proxy/oauth2-proxy/pull/1650) Fixed 500 when checking if user has repo (@adamsong)\n- [#1635](https://github.com/oauth2-proxy/oauth2-proxy/pull/1635) Added description and unit tests for ipv6 address (@t-katsumura)\n- [#1502](https://github.com/oauth2-proxy/oauth2-proxy/pull/1502) Unbreak oauth2-proxy for keycloak provider after 2c668a (@ckwalsh)\n\n# V7.2.1\n\n## Release Highlights\n\nThis release contains a number of bug and security fixes, but has no feature additions.\n\n## Important Notes\n\nN/A\n\n## Breaking Changes\n\nN/A\n\n## Changes since v7.2.0\n\n- [#1247](https://github.com/oauth2-proxy/oauth2-proxy/pull/1247) Use `upn` claim consistently in ADFSProvider (@NickMeves)\n- [#1447](https://github.com/oauth2-proxy/oauth2-proxy/pull/1447) Fix docker build/push issues found during last release (@JoelSpeed)\n- [#1433](https://github.com/oauth2-proxy/oauth2-proxy/pull/1433) Let authentication fail when session validation fails (@stippi2)\n- [#1445](https://github.com/oauth2-proxy/oauth2-proxy/pull/1445) Fix docker container multi arch build issue by passing GOARCH details to make build (@jkandasa)\n- [#1444](https://github.com/oauth2-proxy/oauth2-proxy/pull/1444) Update LinkedIn provider validate URL (@jkandasa)\n- [#1471](https://github.com/oauth2-proxy/oauth2-proxy/pull/1471) Update alpine to 3.15 (@AlexanderBabel)\n- [#1479](https://github.com/oauth2-proxy/oauth2-proxy/pull/1479) Update to Go 1.17 (@polarctos)\n\n# V7.2.0\n\n## Release Highlights\n\n- LinkedIn provider updated to support the new v2 API\n- Introduce `--force-json-errors` to allow OAuth2 Proxy to protect JSON APIs and disable authentication redirection\n- Add URL rewrite capabilities to the upstream proxy\n- New ADFS provider integration\n- New Keycloak OIDC provider integration\n- Introduced Multiarch Docker images on the standard image tags\n\n## Important Notes\n\n- [#1086](https://github.com/oauth2-proxy/oauth2-proxy/pull/1086) The extra validation to protect invalid session\n  deserialization from v6.0.0 (only) has been removed to improve performance. If you are on v6.0.0, either upgrade\n  to a version before this first and allow legacy sessions to expire gracefully or change your `cookie-secret`\n  value and force all sessions to reauthenticate.\n- [#1210](https://github.com/oauth2-proxy/oauth2-proxy/pull/1210) A new `keycloak-oidc` provider has been added with support for role based authentication. The existing keycloak auth provider will eventually be deprecated and removed. Please switch to the new provider `keycloak-oidc`.\n\n## Breaking Changes\n\n- [#1239](https://github.com/oauth2-proxy/oauth2-proxy/pull/1239) GitLab groups sent in the `X-Forwarded-Groups` header\n  to the upstream server will no longer be prefixed with `group:`\n\n## Changes since v7.1.3\n\n- [#1391](https://github.com/oauth2-proxy/oauth2-proxy/pull/1391) Improve build times by sharing cache and allowing platform selection (@JoelSpeed)\n- [#1404](https://github.com/oauth2-proxy/oauth2-proxy/pull/1404) Improve error message when no cookie is found (@JoelSpeed)\n- [#1315](https://github.com/oauth2-proxy/oauth2-proxy/pull/1315) linkedin: Update provider to v2 (@wuurrd)\n- [#1348](https://github.com/oauth2-proxy/oauth2-proxy/pull/1348) Using the native httputil proxy code for websockets rather than yhat/wsutil to properly handle HTTP-level failures (@thetrime)\n- [#1379](https://github.com/oauth2-proxy/oauth2-proxy/pull/1379) Fix the manual sign in with --htpasswd-user-group switch (@janrotter)\n- [#1375](https://github.com/oauth2-proxy/oauth2-proxy/pull/1375) Added `--force-json-errors` flag (@bancek)\n- [#1337](https://github.com/oauth2-proxy/oauth2-proxy/pull/1337) Changing user field type to text when using htpasswd (@pburgisser)\n- [#1239](https://github.com/oauth2-proxy/oauth2-proxy/pull/1239) Base GitLab provider implementation on OIDCProvider (@NickMeves)\n- [#1276](https://github.com/oauth2-proxy/oauth2-proxy/pull/1276) Update crypto and switched to new github.com/golang-jwt/jwt (@JVecsei)\n- [#1264](https://github.com/oauth2-proxy/oauth2-proxy/pull/1264) Update go-oidc to v3 (@NickMeves)\n- [#1233](https://github.com/oauth2-proxy/oauth2-proxy/pull/1233) Extend email-domain validation with sub-domain capability (@morarucostel)\n- [#1060](https://github.com/oauth2-proxy/oauth2-proxy/pull/1060) Implement RewriteTarget to allow requests to be rewritten before proxying to upstream servers (@JoelSpeed)\n- [#1086](https://github.com/oauth2-proxy/oauth2-proxy/pull/1086) Refresh sessions before token expiration if configured (@NickMeves)\n- [#1226](https://github.com/oauth2-proxy/oauth2-proxy/pull/1226) Move app redirection logic to its own package (@JoelSpeed)\n- [#1128](https://github.com/oauth2-proxy/oauth2-proxy/pull/1128) Use gorilla mux for OAuth Proxy routing (@JoelSpeed)\n- [#1238](https://github.com/oauth2-proxy/oauth2-proxy/pull/1238) Added ADFS provider (@samirachoadi)\n- [#1227](https://github.com/oauth2-proxy/oauth2-proxy/pull/1227) Fix Refresh Session not working for multiple cookies (@rishi1111)\n- [#1063](https://github.com/oauth2-proxy/oauth2-proxy/pull/1063) Add Redis lock feature to lock persistent sessions (@Bibob7)\n- [#1108](https://github.com/oauth2-proxy/oauth2-proxy/pull/1108) Add alternative ways to generate cookie secrets to docs (@JoelSpeed)\n- [#1142](https://github.com/oauth2-proxy/oauth2-proxy/pull/1142) Add pagewriter to upstream proxy (@JoelSpeed)\n- [#1181](https://github.com/oauth2-proxy/oauth2-proxy/pull/1181) Fix incorrect `cfg` name in show-debug-on-error flag (@iTaybb)\n- [#1207](https://github.com/oauth2-proxy/oauth2-proxy/pull/1207) Fix URI fragment handling on sign-in page, regression introduced in 7.1.0 (@tarvip)\n- [#1210](https://github.com/oauth2-proxy/oauth2-proxy/pull/1210) New Keycloak OIDC Provider (@pb82)\n- [#1244](https://github.com/oauth2-proxy/oauth2-proxy/pull/1244) Update Alpine image version to 3.14 (@ahovgaard)\n- [#1317](https://github.com/oauth2-proxy/oauth2-proxy/pull/1317) Fix incorrect `</form>` tag on the sing_in page when *not* using a custom template (@jord1e)\n- [#1330](https://github.com/oauth2-proxy/oauth2-proxy/pull/1330) Allow specifying URL as input for custom sign in logo (@MaikuMori)\n- [#1357](https://github.com/oauth2-proxy/oauth2-proxy/pull/1357) Fix unsafe access to session variable (@harzallah)\n- [#997](https://github.com/oauth2-proxy/oauth2-proxy/pull/997) Allow passing the raw url path when proxying upstream requests - e.g. /%2F/ (@FStelzer)\n- [#1147](https://github.com/oauth2-proxy/oauth2-proxy/pull/1147) Multiarch support for docker image (@goshlanguage)\n- [#1296](https://github.com/oauth2-proxy/oauth2-proxy/pull/1296) Fixed `panic` when connecting to Redis with TLS (@mstrzele)\n- [#1403](https://github.com/oauth2-proxy/oauth2-proxy/pull/1403) Improve TLS handling for Redis to support non-standalone mode with TLS (@wadahiro)\n\n# V7.1.3\n\n## Release Highlights\n\n- Fixed typos in the metrics server TLS config names\n\n## Important Notes\n\n- [#967](https://github.com/oauth2-proxy/oauth2-proxy/pull/967) `--insecure-oidc-skip-nonce` is currently `true` by default in case\n  any existing OIDC Identity Providers don't support it. The default will switch to `false` in a future version.\n\n## Breaking Changes\n\n## Changes since v7.1.2\n\n- [#1168](https://github.com/oauth2-proxy/oauth2-proxy/pull/1168) Fix incorrect `cfg` name in Metrics TLS flags (@NickMeves)\n- [#967](https://github.com/oauth2-proxy/oauth2-proxy/pull/967) Set & verify a nonce with OIDC providers (@NickMeves)\n- [#1136](https://github.com/oauth2-proxy/oauth2-proxy/pull/1136) Add clock package for better time mocking in tests (@NickMeves)\n- [#947](https://github.com/oauth2-proxy/oauth2-proxy/pull/947) Multiple provider ingestion and validation in alpha options (first stage: [#926](https://github.com/oauth2-proxy/oauth2-proxy/issues/926)) (@yanasega)\n\n# V7.1.2\n\n## Release Highlights\n\n- Metrics bind address initialisation was broken in config files\n\n## Important Notes\n\nN/A\n\n## Breaking Changes\n\nN/A\n\n## Changes since v7.1.1\n\n- [#1129](https://github.com/oauth2-proxy/oauth2-proxy/pull/1129) Rewrite OpenRedirect tests in ginkgo (@JoelSpeed)\n- [#1127](https://github.com/oauth2-proxy/oauth2-proxy/pull/1127) Remove unused fields from OAuthProxy (@JoelSpeed)\n- [#1141](https://github.com/oauth2-proxy/oauth2-proxy/pull/1141) Fix metrics server bind address initialization (@oliver006)\n\n# V7.1.1\n\n## Release Highlights\n\n- The metrics server could not be started in v7.1.0, this is now fixed.\n\n## Important Notes\n\nN/A\n\n## Breaking Changes\n\nN/A\n\n## Changes since v7.1.0\n\n- [#1133](https://github.com/oauth2-proxy/oauth2-proxy/pull/1133) Metrics server should be constructed with secure bind address for TLS (@JoelSpeed)\n\n# V7.1.0\n\n## Release Highlights\n\n- New improved design for sign in and error pages based on bulma framework\n- Refactored templates loading\n  - `robots.txt`, `sign_in.html` and `error.html` can now be provided individually in `--custom-templates-dir`\n  - If any of the above are not provided, defaults are used\n  - Defaults templates be found in [pkg/app/pagewriter](https://github.com/oauth2-proxy/oauth2-proxy/tree/v7.1.0/pkg/app/pagewriter)\n- Introduction of basic prometheus metrics\n- Introduction of Traefik based local testing/example environment\n- Support for request IDs to allow request co-ordination of log lines\n\n## Important Notes\n\n- [GHSA-652x-m2gr-hppm](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-652x-m2gr-hppm) GitLab group authorization stopped working in v7.0.0, the functionality has now been restored, please see the linked advisory for details\n- [#1103](https://github.com/oauth2-proxy/oauth2-proxy/pull/1103) Upstream request signatures via `--signature-key` is\n  deprecated. Support will be removed completely in v8.0.0.\n- [1087](https://github.com/oauth2-proxy/oauth2-proxy/pull/1087) The default logging templates have been updated to include {{.RequestID}}\n- [#1117](https://github.com/oauth2-proxy/oauth2-proxy/pull/1117) The `--gcp-healthchecks` option is now deprecated. It will be removed in a future release.\n  - To migrate, you can change your application health checks for OAuth2 Proxy to point to\n    the `--ping-path` value.\n  - You can also migrate the user agent based health check using the `--ping-user-agent` option. Set it to `GoogleHC/1.0` to allow health checks on the path `/` from the Google health checker.\n\n## Breaking Changes\n\nN/A\n\n## Changes since v7.0.1\n\n- [GHSA-652x-m2gr-hppm](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-652x-m2gr-hppm) `--gitlab-group` GitLab Group Authorization config flag stopped working in v7.0.0 (@NickMeves, @papey)\n- [#1113](https://github.com/oauth2-proxy/oauth2-proxy/pull/1113) Panic with GitLab project repository auth (@piersharding)\n- [#1116](https://github.com/oauth2-proxy/oauth2-proxy/pull/1116) Reinstate preferEmailToUser behaviour for basic auth sessions (@JoelSpeed)\n- [#1115](https://github.com/oauth2-proxy/oauth2-proxy/pull/1115) Fix upstream proxy appending ? to requests (@JoelSpeed)\n- [#1117](https://github.com/oauth2-proxy/oauth2-proxy/pull/1117) Deprecate GCP HealthCheck option (@JoelSpeed)\n- [#1104](https://github.com/oauth2-proxy/oauth2-proxy/pull/1104) Allow custom robots text pages (@JoelSpeed)\n- [#1045](https://github.com/oauth2-proxy/oauth2-proxy/pull/1045) Ensure redirect URI always has a scheme (@JoelSpeed)\n- [#1103](https://github.com/oauth2-proxy/oauth2-proxy/pull/1103) Deprecate upstream request signatures (@NickMeves)\n- [#1087](https://github.com/oauth2-proxy/oauth2-proxy/pull/1087) Support Request ID in logging (@NickMeves)\n- [#914](https://github.com/oauth2-proxy/oauth2-proxy/pull/914) Extract email from id_token for azure provider when oidc is configured (@weinong)\n- [#1047](https://github.com/oauth2-proxy/oauth2-proxy/pull/1047) Refactor HTTP Server and add ServerGroup to handle graceful shutdown of multiple servers (@JoelSpeed)\n- [#1070](https://github.com/oauth2-proxy/oauth2-proxy/pull/1070) Refactor logging middleware to middleware package (@NickMeves)\n- [#1064](https://github.com/oauth2-proxy/oauth2-proxy/pull/1064) Add support for setting groups on session when using basic auth (@stefansedich)\n- [#1056](https://github.com/oauth2-proxy/oauth2-proxy/pull/1056) Add option for custom logos on the sign in page (@JoelSpeed)\n- [#1054](https://github.com/oauth2-proxy/oauth2-proxy/pull/1054) Update to Go 1.16 (@JoelSpeed)\n- [#1052](https://github.com/oauth2-proxy/oauth2-proxy/pull/1052) Update golangci-lint to latest version (v1.36.0) (@JoelSpeed)\n- [#1043](https://github.com/oauth2-proxy/oauth2-proxy/pull/1043) Refactor Sign In Page rendering and capture all page rendering code in pagewriter package (@JoelSpeed)\n- [#1029](https://github.com/oauth2-proxy/oauth2-proxy/pull/1029) Refactor error page rendering and allow debug messages on error (@JoelSpeed)\n- [#1028](https://github.com/oauth2-proxy/oauth2-proxy/pull/1028) Refactor templates, update theme and provide styled error pages (@JoelSpeed)\n- [#1039](https://github.com/oauth2-proxy/oauth2-proxy/pull/1039) Ensure errors in tests are logged to the GinkgoWriter (@JoelSpeed)\n- [#980](https://github.com/oauth2-proxy/oauth2-proxy/pull/980) Add Prometheus metrics endpoint (@neuralsandwich)\n- [#1023](https://github.com/oauth2-proxy/oauth2-proxy/pull/1023) Update docs on Traefik ForwardAuth support without the use of Traefik 'errors' middleware (@pcneo83)\n- [#1091](https://github.com/oauth2-proxy/oauth2-proxy/pull/1091) Add an example with Traefik (configuration without Traefik 'errors' middleware) (@fcollonval)\n\n# V7.0.1\n\n## Release Highlights\n\n- Fixed a bug that meant that flag ordering mattered\n- Fixed a bug where response headers for groups were not being flattened\n\n## Important Notes\n\nN/A\n\n## Breaking Changes\n\nN/A\n\n## Changes since v7.0.0\n\n- [#1020](https://github.com/oauth2-proxy/oauth2-proxy/pull/1020) Flatten array-based response headers (@NickMeves)\n- [#1026](https://github.com/oauth2-proxy/oauth2-proxy/pull/1026) Ensure config flags get parsed correctly when other flags precede them (@JoelSpeed)\n\n# V7.0.0\n\n## Release Highlights\n\n- Major internal improvements to provider interfaces\n- Added group authorization support\n- Improved support for external auth for Traefik\n- Introduced alpha configuration format to allow users to trial new configuration format and alpha features\n- GitLab provider now supports restricting to members of a project\n- Keycloak provider now supports restricting users to members of a set of groups\n- (Alpha) Flexible header configuration allowing user defined mapping of session claims to header values\n\n\n## Important Notes\n\n- [GHSA-4mf2-f3wh-gvf2](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-4mf2-f3wh-gvf2) The whitelist domain feature has been updated to fix a vulnerability that was identified, please see the linked advisory for details\n- [#964](https://github.com/oauth2-proxy/oauth2-proxy/pull/964) Redirect URL generation will attempt secondary strategies\n  in the priority chain if any fail the `IsValidRedirect` security check. Previously any failures fell back to `/`.\n- [#953](https://github.com/oauth2-proxy/oauth2-proxy/pull/953) Keycloak will now use `--profile-url` if set for the userinfo endpoint\n  instead of `--validate-url`. `--validate-url` will still work for backwards compatibility.\n- [#957](https://github.com/oauth2-proxy/oauth2-proxy/pull/957) To use X-Forwarded-{Proto,Host,Uri} on redirect detection, `--reverse-proxy` must be `true`.\n- [#936](https://github.com/oauth2-proxy/oauth2-proxy/pull/936) `--user-id-claim` option is deprecated and replaced by `--oidc-email-claim`\n- [#630](https://github.com/oauth2-proxy/oauth2-proxy/pull/630) Gitlab projects needs a Gitlab application with the extra `read_api` enabled\n- [#849](https://github.com/oauth2-proxy/oauth2-proxy/pull/849) `/oauth2/auth` `allowed_groups` querystring parameter can be paired with the `allowed-groups` configuration option.\n  - The `allowed_groups` querystring parameter can specify multiple comma delimited groups.\n  - In this scenario, the user must have a group (from their multiple groups) present in both lists to not get a 401 or 403 response code.\n  - Example:\n    - OAuth2-Proxy globally sets the `allowed_groups` as `engineering`.\n    - An application using Kubernetes ingress uses the `/oauth2/auth` endpoint with `allowed_groups` querystring set to `backend`.\n    - A user must have a session with the groups `[\"engineering\", \"backend\"]` to pass authorization.\n    - Another user with the groups `[\"engineering\", \"frontend\"]` would fail the querystring authorization portion.\n- [#905](https://github.com/oauth2-proxy/oauth2-proxy/pull/905) Existing sessions from v6.0.0 or earlier are no longer valid. They will trigger a reauthentication.\n- [#826](https://github.com/oauth2-proxy/oauth2-proxy/pull/826) `skip-auth-strip-headers` now applies to all requests, not just those where authentication would be skipped.\n- [#797](https://github.com/oauth2-proxy/oauth2-proxy/pull/797) The behavior of the Google provider Groups restriction changes with this\n  - Either `--google-group` or the new `--allowed-group` will work for Google now (`--google-group` will be used if both are set)\n  - Group membership lists will be passed to the backend with the `X-Forwarded-Groups` header\n  - If you change the list of allowed groups, existing sessions that now don't have a valid group will be logged out immediately.\n    - Previously, group membership was only checked on session creation and refresh.\n- [#789](https://github.com/oauth2-proxy/oauth2-proxy/pull/789) `--skip-auth-route` is (almost) backwards compatible with `--skip-auth-regex`\n  - We are marking `--skip-auth-regex` as DEPRECATED and will remove it in the next major version.\n  - If your regex contains an `=` and you want it for all methods, you will need to add a leading `=` (this is the area where `--skip-auth-regex` doesn't port perfectly)\n- [#575](https://github.com/oauth2-proxy/oauth2-proxy/pull/575) Sessions from v5.1.1 or earlier will no longer validate since they were not signed with SHA1.\n  - Sessions from v6.0.0 or later had a graceful conversion to SHA256 that resulted in no reauthentication\n  - Upgrading from v5.1.1 or earlier will result in a reauthentication\n- [#616](https://github.com/oauth2-proxy/oauth2-proxy/pull/616) Ensure you have configured oauth2-proxy to use the `groups` scope.\n  - The user may be logged out initially as they may not currently have the `groups` claim however after going back through login process wil be authenticated.\n- [#839](https://github.com/oauth2-proxy/oauth2-proxy/pull/839) Enables complex data structures for group claim entries, which are output as Json by default.\n\n## Breaking Changes\n\n- [#964](https://github.com/oauth2-proxy/oauth2-proxy/pull/964) `--reverse-proxy` must be true to trust `X-Forwarded-*` headers as canonical.\n  These are used throughout the application in redirect URLs, cookie domains and host logging logic. These are the headers:\n  - `X-Forwarded-Proto` instead of `req.URL.Scheme`\n  - `X-Forwarded-Host` instead of `req.Host`\n  - `X-Forwarded-Uri` instead of `req.URL.RequestURI()`\n- [#953](https://github.com/oauth2-proxy/oauth2-proxy/pull/953) In config files & envvar configs, `keycloak_group` is now the plural `keycloak_groups`.\n  Flag configs are still `--keycloak-group` but it can be passed multiple times.\n- [#911](https://github.com/oauth2-proxy/oauth2-proxy/pull/911) Specifying a non-existent provider will cause OAuth2-Proxy to fail on startup instead of defaulting to \"google\".\n- [#797](https://github.com/oauth2-proxy/oauth2-proxy/pull/797) Security changes to Google provider group authorization flow\n  - If you change the list of allowed groups, existing sessions that now don't have a valid group will be logged out immediately.\n    - Previously, group membership was only checked on session creation and refresh.\n- [#722](https://github.com/oauth2-proxy/oauth2-proxy/pull/722) When a Redis session store is configured, OAuth2-Proxy will fail to start up unless connection and health checks to Redis pass\n- [#800](https://github.com/oauth2-proxy/oauth2-proxy/pull/800) Fix import path for v7. The import path has changed to support the go get installation.\n  - You can now `go get github.com/oauth2-proxy/oauth2-proxy/v7` to get the latest `v7` version of OAuth2 Proxy\n  - Import paths for package are now under `v7`, eg `github.com/oauth2-proxy/oauth2-proxy/v7/pkg/<module>`\n- [#753](https://github.com/oauth2-proxy/oauth2-proxy/pull/753) A bug in the Azure provider prevented it from properly passing the configured protected `--resource`\n  via the login url. If this option was used in the past, behavior will change with this release as it will\n  affect the tokens returned by Azure. In the past, the tokens were always for `https://graph.microsoft.com` (the default)\n  and will now be for the configured resource (if it exists, otherwise it will run into errors)\n- [#754](https://github.com/oauth2-proxy/oauth2-proxy/pull/754) The Azure provider now has token refresh functionality implemented. This means that there won't\n  be any redirects in the browser anymore when tokens expire, but instead a token refresh is initiated\n  in the background, which leads to new tokens being returned in the cookies.\n  - Please note that `--cookie-refresh` must be 0 (the default) or equal to the token lifespan configured in Azure AD to make\n    Azure token refresh reliable. Setting this value to 0 means that it relies on the provider implementation\n    to decide if a refresh is required.\n\n## Changes since v6.1.1\n\n- [GHSA-4mf2-f3wh-gvf2](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-4mf2-f3wh-gvf2) Subdomain checking of whitelisted domains could allow unintended redirects (@NickMeves)\n- [#1002](https://github.com/oauth2-proxy/oauth2-proxy/pull/1002) Use logger for logging refreshed session in azure and gitlab provider (@Bibob7)\n- [#799](https://github.com/oauth2-proxy/oauth2-proxy/pull/799) Use comma separated multiple values for header (@lilida)\n- [#903](https://github.com/oauth2-proxy/oauth2-proxy/pull/903) Add docs and generated reference for Alpha configuration (@JoelSpeed)\n- [#995](https://github.com/oauth2-proxy/oauth2-proxy/pull/995) Add Security Policy (@JoelSpeed)\n- [#964](https://github.com/oauth2-proxy/oauth2-proxy/pull/964) Require `--reverse-proxy` true to trust `X-Forwareded-*` type headers (@NickMeves)\n- [#970](https://github.com/oauth2-proxy/oauth2-proxy/pull/970) Fix joined cookie name for those containing underline in the suffix (@peppered)\n- [#953](https://github.com/oauth2-proxy/oauth2-proxy/pull/953) Migrate Keycloak to EnrichSession & support multiple groups for authorization (@NickMeves)\n- [#957](https://github.com/oauth2-proxy/oauth2-proxy/pull/957) Use X-Forwarded-{Proto,Host,Uri} on redirect as last resort (@linuxgemini)\n- [#630](https://github.com/oauth2-proxy/oauth2-proxy/pull/630) Add support for Gitlab project based authentication (@factorysh)\n- [#907](https://github.com/oauth2-proxy/oauth2-proxy/pull/907) Introduce alpha configuration option to enable testing of structured configuration (@JoelSpeed)\n- [#938](https://github.com/oauth2-proxy/oauth2-proxy/pull/938) Cleanup missed provider renaming refactor methods (@NickMeves)\n- [#816](https://github.com/oauth2-proxy/oauth2-proxy/pull/816) (via [#936](https://github.com/oauth2-proxy/oauth2-proxy/pull/936)) Support non-list group claims (@loafoe)\n- [#936](https://github.com/oauth2-proxy/oauth2-proxy/pull/936) Refactor OIDC Provider and support groups from Profile URL (@NickMeves)\n- [#869](https://github.com/oauth2-proxy/oauth2-proxy/pull/869) Streamline provider interface method names and signatures (@NickMeves)\n- [#849](https://github.com/oauth2-proxy/oauth2-proxy/pull/849) Support group authorization on `oauth2/auth` endpoint via `allowed_groups` querystring (@NickMeves)\n- [#925](https://github.com/oauth2-proxy/oauth2-proxy/pull/925) Fix basic auth legacy header conversion (@JoelSpeed)\n- [#916](https://github.com/oauth2-proxy/oauth2-proxy/pull/916) Add AlphaOptions struct to prepare for alpha config loading (@JoelSpeed)\n- [#923](https://github.com/oauth2-proxy/oauth2-proxy/pull/923) Support TLS 1.3 (@aajisaka)\n- [#918](https://github.com/oauth2-proxy/oauth2-proxy/pull/918) Fix log header output (@JoelSpeed)\n- [#911](https://github.com/oauth2-proxy/oauth2-proxy/pull/911) Validate provider type on startup. (@arcivanov)\n- [#906](https://github.com/oauth2-proxy/oauth2-proxy/pull/906) Set up v6.1.x versioned documentation as default documentation (@JoelSpeed)\n- [#905](https://github.com/oauth2-proxy/oauth2-proxy/pull/905) Remove v5 legacy sessions support (@NickMeves)\n- [#904](https://github.com/oauth2-proxy/oauth2-proxy/pull/904) Set `skip-auth-strip-headers` to `true` by default (@NickMeves)\n- [#826](https://github.com/oauth2-proxy/oauth2-proxy/pull/826) Integrate new header injectors into project (@JoelSpeed)\n- [#797](https://github.com/oauth2-proxy/oauth2-proxy/pull/797) Create universal Authorization behavior across providers (@NickMeves)\n- [#898](https://github.com/oauth2-proxy/oauth2-proxy/pull/898) Migrate documentation to Docusaurus (@JoelSpeed)\n- [#754](https://github.com/oauth2-proxy/oauth2-proxy/pull/754) Azure token refresh (@codablock)\n- [#850](https://github.com/oauth2-proxy/oauth2-proxy/pull/850) Increase session fields in `/oauth2/userinfo` endpoint (@NickMeves)\n- [#825](https://github.com/oauth2-proxy/oauth2-proxy/pull/825) Fix code coverage reporting on GitHub actions(@JoelSpeed)\n- [#796](https://github.com/oauth2-proxy/oauth2-proxy/pull/796) Deprecate GetUserName & GetEmailAdress for EnrichSessionState (@NickMeves)\n- [#705](https://github.com/oauth2-proxy/oauth2-proxy/pull/705) Add generic Header injectors for upstream request and response headers (@JoelSpeed)\n- [#753](https://github.com/oauth2-proxy/oauth2-proxy/pull/753) Pass resource parameter in login url (@codablock)\n- [#789](https://github.com/oauth2-proxy/oauth2-proxy/pull/789) Add `--skip-auth-route` configuration option for `METHOD=pathRegex` based allowlists (@NickMeves)\n- [#575](https://github.com/oauth2-proxy/oauth2-proxy/pull/575) Stop accepting legacy SHA1 signed cookies (@NickMeves)\n- [#722](https://github.com/oauth2-proxy/oauth2-proxy/pull/722) Validate Redis configuration options at startup (@NickMeves)\n- [#791](https://github.com/oauth2-proxy/oauth2-proxy/pull/791) Remove GetPreferredUsername method from provider interface (@NickMeves)\n- [#764](https://github.com/oauth2-proxy/oauth2-proxy/pull/764) Document bcrypt encryption for htpasswd (and hide SHA) (@lentzi90)\n- [#778](https://github.com/oauth2-proxy/oauth2-proxy/pull/778) Use display-htpasswd-form flag\n- [#616](https://github.com/oauth2-proxy/oauth2-proxy/pull/616) Add support to ensure user belongs in required groups when using the OIDC provider (@stefansedich)\n- [#800](https://github.com/oauth2-proxy/oauth2-proxy/pull/800) Fix import path for v7 (@johejo)\n- [#783](https://github.com/oauth2-proxy/oauth2-proxy/pull/783) Update Go to 1.15 (@johejo)\n- [#813](https://github.com/oauth2-proxy/oauth2-proxy/pull/813) Fix build (@thiagocaiubi)\n- [#801](https://github.com/oauth2-proxy/oauth2-proxy/pull/801) Update go-redis/redis to v8 (@johejo)\n- [#750](https://github.com/oauth2-proxy/oauth2-proxy/pull/750) ci: Migrate to Github Actions (@shinebayar-g)\n- [#829](https://github.com/oauth2-proxy/oauth2-proxy/pull/820) Rename test directory to testdata (@johejo)\n- [#819](https://github.com/oauth2-proxy/oauth2-proxy/pull/819) Improve CI (@johejo)\n- [#989](https://github.com/oauth2-proxy/oauth2-proxy/pull/989) Adapt isAjax to support mimetype lists (@rassie)\n- [#1013](https://github.com/oauth2-proxy/oauth2-proxy/pull/1013) Update alpine version to 3.13 (@nishanth-pinnapareddy)\n\n# v6.1.1\n\n## Release Highlights\n\n- Fixed a bug which prevented static upstreams from being used\n- Fixed a bug which prevented file based upstreams from being used\n- Ensure that X-Forwarded-Host is respected consistently\n\n## Important Notes\n\nN/A\n\n## Breaking\n\nN/A\n\n## Changes since v6.1.0\n\n- [#729](https://github.com/oauth2-proxy/oauth2-proxy/pull/729) Use X-Forwarded-Host consistently when set (@NickMeves)\n- [#746](https://github.com/oauth2-proxy/oauth2-proxy/pull/746) Fix conversion of static responses in upstreams (@JoelSpeed)\n\n# v6.1.0\n\n## Release Highlights\n\n- Redis session stores now support authenticated connections\n- Error logging can now be separated from info logging by directing error logs to stderr\n- Added --session-cookie-minimal flag which helps prevent large session cookies\n- Improvements to force-https behaviour\n- Allow requests to skip authentication based on their source IP\n\n## Important Notes\n\n- [#632](https://github.com/oauth2-proxy/oauth2-proxy/pull/632) There is backwards compatibility to sessions from v5\n  - Any unencrypted sessions from before v5 that only contained a Username & Email will trigger a reauthentication\n\n## Breaking Changes\n\n## Changes since v6.0.0\n\n- [#742](https://github.com/oauth2-proxy/oauth2-proxy/pull/742) Only log no cookie match if cookie domains specified (@JoelSpeed)\n- [#562](https://github.com/oauth2-proxy/oauth2-proxy/pull/562) Create generic Authorization Header constructor (@JoelSpeed)\n- [#715](https://github.com/oauth2-proxy/oauth2-proxy/pull/715) Ensure session times are not nil before printing them (@JoelSpeed)\n- [#714](https://github.com/oauth2-proxy/oauth2-proxy/pull/714) Support passwords with Redis session stores (@NickMeves)\n- [#719](https://github.com/oauth2-proxy/oauth2-proxy/pull/719) Add Gosec fixes to areas that are intermittently flagged on PRs (@NickMeves)\n- [#718](https://github.com/oauth2-proxy/oauth2-proxy/pull/718) Allow Logging to stdout with separate Error Log Channel\n- [#690](https://github.com/oauth2-proxy/oauth2-proxy/pull/690) Address GoSec security findings & remediate (@NickMeves)\n- [#689](https://github.com/oauth2-proxy/oauth2-proxy/pull/689) Fix finicky logging_handler_test from time drift (@NickMeves)\n- [#700](https://github.com/oauth2-proxy/oauth2-proxy/pull/700) Allow OIDC Bearer auth IDTokens to have empty email claim & profile URL (@NickMeves)\n- [#699](https://github.com/oauth2-proxy/oauth2-proxy/pull/699) Align persistence ginkgo tests with conventions (@NickMeves)\n- [#696](https://github.com/oauth2-proxy/oauth2-proxy/pull/696) Preserve query when building redirect\n- [#561](https://github.com/oauth2-proxy/oauth2-proxy/pull/561) Refactor provider URLs to package level vars (@JoelSpeed)\n- [#682](https://github.com/oauth2-proxy/oauth2-proxy/pull/682) Refactor persistent session store session ticket management (@NickMeves)\n- [#688](https://github.com/oauth2-proxy/oauth2-proxy/pull/688) Refactor session loading to make use of middleware pattern (@JoelSpeed)\n- [#593](https://github.com/oauth2-proxy/oauth2-proxy/pull/593) Integrate upstream package with OAuth2 Proxy (@JoelSpeed)\n- [#687](https://github.com/oauth2-proxy/oauth2-proxy/pull/687) Refactor HTPasswd Validator (@JoelSpeed)\n- [#624](https://github.com/oauth2-proxy/oauth2-proxy/pull/624) Allow stripping authentication headers from whitelisted requests with `--skip-auth-strip-headers` (@NickMeves)\n- [#673](https://github.com/oauth2-proxy/oauth2-proxy/pull/673) Add --session-cookie-minimal option to create session cookies with no tokens (@NickMeves)\n- [#632](https://github.com/oauth2-proxy/oauth2-proxy/pull/632) Reduce session size by encoding with MessagePack and using LZ4 compression (@NickMeves)\n- [#675](https://github.com/oauth2-proxy/oauth2-proxy/pull/675) Fix required ruby version and deprecated option for building docs (@mkontani)\n- [#669](https://github.com/oauth2-proxy/oauth2-proxy/pull/669) Reduce docker context to improve build times (@JoelSpeed)\n- [#668](https://github.com/oauth2-proxy/oauth2-proxy/pull/668) Use req.Host in --force-https when req.URL.Host is empty (@zucaritask)\n- [#660](https://github.com/oauth2-proxy/oauth2-proxy/pull/660) Use builder pattern to simplify requests to external endpoints (@JoelSpeed)\n- [#591](https://github.com/oauth2-proxy/oauth2-proxy/pull/591) Introduce upstream package with new reverse proxy implementation (@JoelSpeed)\n- [#576](https://github.com/oauth2-proxy/oauth2-proxy/pull/576) Separate Cookie validation out of main options validation (@JoelSpeed)\n- [#656](https://github.com/oauth2-proxy/oauth2-proxy/pull/656) Split long session cookies more precisely (@NickMeves)\n- [#619](https://github.com/oauth2-proxy/oauth2-proxy/pull/619) Improve Redirect to HTTPs behaviour (@JoelSpeed)\n- [#654](https://github.com/oauth2-proxy/oauth2-proxy/pull/654) Close client connections after each redis test (@JoelSpeed)\n- [#542](https://github.com/oauth2-proxy/oauth2-proxy/pull/542) Move SessionStore tests to independent package (@JoelSpeed)\n- [#577](https://github.com/oauth2-proxy/oauth2-proxy/pull/577) Move Cipher and Session Store initialisation out of Validation (@JoelSpeed)\n- [#635](https://github.com/oauth2-proxy/oauth2-proxy/pull/635) Support specifying alternative provider TLS trust source(s) (@k-wall)\n- [#649](https://github.com/oauth2-proxy/oauth2-proxy/pull/650) Resolve an issue where an empty healthcheck URL and ping-user-agent returns the healthcheck response (@jordancrawfordnz)\n- [#662](https://github.com/oauth2-proxy/oauth2-proxy/pull/662) Do not add Cache-Control header to response from auth only endpoint (@johejo)\n- [#552](https://github.com/oauth2-proxy/oauth2-proxy/pull/522) Implements --trusted-ip option to allow clients behind specified IPs or CIDR ranges to bypass authentication (@Izzette)\n- [#733](https://github.com/oauth2-proxy/oauth2-proxy/pull/733) dist.sh: remove go version from asset links (@syscll)\n\n# v6.0.0\n\n## Release Highlights\n\n- Migrated to an independent GitHub organisation\n- Added local test environment examples using docker-compose and kind\n- Error pages will now be rendered when upstream connections fail\n- Non-Existent options in config files will now return errors on startup\n- Sessions are now always encrypted, independent of configuration\n\n## Important Notes\n\n- (Security) Fix for [open redirect vulnerability](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-5m6c-jp6f-2vcv).\n  - More invalid redirects that lead to open-redirects were reported\n  - An extensive test suite has been added to prevent future regressions\n- [#453](https://github.com/oauth2-proxy/oauth2-proxy/pull/453) Responses to endpoints with a proxy prefix will now return headers for preventing browser caching.\n\n## Breaking Changes\n\n- [#464](https://github.com/oauth2-proxy/oauth2-proxy/pull/464) Migration from Pusher to independent org may have introduced breaking changes for your environment.\n  - See the changes listed below for PR [#464](https://github.com/oauth2-proxy/oauth2-proxy/pull/464) for full details\n  - Binaries renamed from `oauth2_proxy` to `oauth2-proxy`\n- [#440](https://github.com/oauth2-proxy/oauth2-proxy/pull/440) Switch Azure AD Graph API to Microsoft Graph API\n  - The Azure AD Graph API has been [deprecated](https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-graph-api) and is being replaced by the Microsoft Graph API.\n    If your application relies on the access token being passed to it to access the Azure AD Graph API, you should migrate your application to use the Microsoft Graph API.\n    Existing behaviour can be retained by setting `-resource=https://graph.windows.net`.\n- [#484](https://github.com/oauth2-proxy/oauth2-proxy/pull/484) Configuration loading has been replaced with Viper and PFlag\n  - Flags now require a `--` prefix before the option\n  - Previously flags allowed either `-` or `--` to prefix the option name\n  - Eg `-provider` must now be `--provider`\n- [#487](https://github.com/oauth2-proxy/oauth2-proxy/pull/487) Switch flags to StringSlice instead of StringArray\n  - Options that take multiple arguments now split strings on commas if present\n  - Eg `--foo=a,b,c,d` would result in the values `a`, `b`, `c` and `d` instead of a single `a,b,c,d` value as before\n- [#535](https://github.com/oauth2-proxy/oauth2-proxy/pull/535) Drop support for pre v3.1 cookies\n  - The encoding for session cookies was changed starting in v3.1.0, support for the previous encoding is now dropped\n  - If you are upgrading from a version earlier than this, please upgrade via a version between v3.1.0 and v5.1.1\n- [#537](https://github.com/oauth2-proxy/oauth2-proxy/pull/537) Drop Fallback to Email if User not set\n  - Previously, when a session was loaded, if the User was not set, it would be replaced by the Email.\n    This behaviour was inconsistent as it required the session to be stored and then loaded to function properly.\n  - This behaviour has now been removed and the User field will remain empty if it was not set when the session was saved.\n  - In some scenarios `X-Forwarded-User` will now be empty. Use `X-Forwarded-Email` instead.\n  - In some scenarios, this may break setting Basic Auth on upstream or responses.\n    Use `--prefer-email-to-user` to restore falling back to the Email in these cases.\n- [#556](https://github.com/oauth2-proxy/oauth2-proxy/pull/556) Remove unintentional auto-padding of secrets that were too short\n  - Previously, after cookie-secrets were opportunistically base64 decoded to raw bytes,\n    they were padded to have a length divisible by 4.\n  - This led to wrong sized secrets being valid AES lengths of 16, 24, or 32 bytes. Or it led to confusing errors\n    reporting an invalid length of 20 or 28 when the user input cookie-secret was not that length.\n  - Now we will only base64 decode a cookie-secret to raw bytes if it is 16, 24, or 32 bytes long. Otherwise, we will convert\n    the direct cookie-secret to bytes without silent padding added.\n- [#412](https://github.com/oauth2-proxy/oauth2-proxy/pull/412)/[#559](https://github.com/oauth2-proxy/oauth2-proxy/pull/559) Allow multiple cookie domains to be specified\n  - Multiple cookie domains may now be configured. The longest domain that matches will be used.\n  - The config options `cookie_domain` is now `cookie_domains`\n  - The environment variable `OAUTH2_PROXY_COOKIE_DOMAIN` is now `OAUTH2_PROXY_COOKIE_DOMAINS`\n- [#414](https://github.com/oauth2-proxy/oauth2-proxy/pull/414) Always encrypt sessions regardless of config\n  - Previously, sessions were encrypted only when certain options were configured.\n    This lead to confusion and misconfiguration as it was not obvious when a session should be encrypted.\n  - Cookie Secrets must now be 16, 24 or 32 bytes.\n  - If you need to change your secret, this will force users to reauthenticate.\n- [#548](https://github.com/oauth2-proxy/oauth2-proxy/pull/548) Separate logging options out of main options structure\n  - Fixes an inconsistency in the `--exclude-logging-paths` option by renaming it to `--exclude-logging-option`.\n  - This flag may now be given multiple times as with other list options\n  - This flag also accepts comma separated values\n- [#639](https://github.com/oauth2-proxy/oauth2-proxy/pull/639) Change how gitlab-group is parsed on options\n  - Previously, the flag gitlab-group used comma seperated values, while the config option used space seperated values.\n  - This fixes the config value to use slices internally.\n  - The config option `gitlab_group` is now `gitlab_groups`\n  - The environment variable `OAUTH2_PROXY_GITLAB_GROUP` is now `OAUTH2_PROXY_GITLAB_GROUPS`\n\n## Changes since v5.1.1\n\n- [GHSA-5m6c-jp6f-2vcv](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-5m6c-jp6f-2vcv) New OpenRedirect cases have been found (@JoelSpeed)\n- [#639](https://github.com/oauth2-proxy/oauth2-proxy/pull/639) Change how gitlab-group is parsed on options (@linuxgemini)\n- [#615](https://github.com/oauth2-proxy/oauth2-proxy/pull/615) Kubernetes example based on Kind cluster and Nginx ingress (@EvgeniGordeev)\n- [#596](https://github.com/oauth2-proxy/oauth2-proxy/pull/596) Validate Bearer IDTokens in headers with correct provider/extra JWT Verifier (@NickMeves)\n- [#620](https://github.com/oauth2-proxy/oauth2-proxy/pull/620) Add HealthCheck middleware (@JoelSpeed)\n- [#597](https://github.com/oauth2-proxy/oauth2-proxy/pull/597) Don't log invalid redirect if redirect is empty (@JoelSpeed)\n- [#604](https://github.com/oauth2-proxy/oauth2-proxy/pull/604) Add Keycloak local testing environment (@EvgeniGordeev)\n- [#539](https://github.com/oauth2-proxy/oauth2-proxy/pull/539) Refactor encryption ciphers and add AES-GCM support (@NickMeves)\n- [#601](https://github.com/oauth2-proxy/oauth2-proxy/pull/601) Ensure decrypted user/email are valid UTF8 (@JoelSpeed)\n- [#560](https://github.com/oauth2-proxy/oauth2-proxy/pull/560) Fallback to UserInfo is User ID claim not present (@JoelSpeed)\n- [#598](https://github.com/oauth2-proxy/oauth2-proxy/pull/598) acr_values no longer sent to IdP when empty (@ScottGuymer)\n- [#548](https://github.com/oauth2-proxy/oauth2-proxy/pull/548) Separate logging options out of main options structure (@JoelSpeed)\n- [#567](https://github.com/oauth2-proxy/oauth2-proxy/pull/567) Allow health/ping request to be identified via User-Agent (@chkohner)\n- [#536](https://github.com/oauth2-proxy/oauth2-proxy/pull/536) Improvements to Session State code (@JoelSpeed)\n- [#573](https://github.com/oauth2-proxy/oauth2-proxy/pull/573) Properly parse redis urls for cluster and sentinel connections (@amnay-mo)\n- [#574](https://github.com/oauth2-proxy/oauth2-proxy/pull/574) render error page on 502 proxy status (@amnay-mo)\n- [#559](https://github.com/oauth2-proxy/oauth2-proxy/pull/559) Rename cookie-domain config to cookie-domains (@JoelSpeed)\n- [#569](https://github.com/oauth2-proxy/oauth2-proxy/pull/569) Updated autocompletion for `--` long options. (@Izzette)\n- [#489](https://github.com/oauth2-proxy/oauth2-proxy/pull/489) Move Options and Validation to separate packages (@JoelSpeed)\n- [#556](https://github.com/oauth2-proxy/oauth2-proxy/pull/556) Remove unintentional auto-padding of secrets that were too short (@NickMeves)\n- [#538](https://github.com/oauth2-proxy/oauth2-proxy/pull/538) Refactor sessions/utils.go functionality to other areas (@NickMeves)\n- [#503](https://github.com/oauth2-proxy/oauth2-proxy/pull/503) Implements --real-client-ip-header option to select the header from which to obtain a proxied client's IP (@Izzette)\n- [#529](https://github.com/oauth2-proxy/oauth2-proxy/pull/529) Add local test environments for testing changes and new features (@JoelSpeed)\n- [#537](https://github.com/oauth2-proxy/oauth2-proxy/pull/537) Drop Fallback to Email if User not set (@JoelSpeed)\n- [#535](https://github.com/oauth2-proxy/oauth2-proxy/pull/535) Drop support for pre v3.1 cookies (@JoelSpeed)\n- [#533](https://github.com/oauth2-proxy/oauth2-proxy/pull/487) Set up code coverage within Travis for Code Climate (@JoelSpeed)\n- [#514](https://github.com/oauth2-proxy/oauth2-proxy/pull/514) Add basic string functions to templates (@n-i-x)\n- [#524](https://github.com/oauth2-proxy/oauth2-proxy/pull/524) Sign cookies with SHA256 (@NickMeves)\n- [#515](https://github.com/oauth2-proxy/oauth2-proxy/pull/515) Drop configure script in favour of native Makefile env and checks (@JoelSpeed)\n- [#519](https://github.com/oauth2-proxy/oauth2-proxy/pull/519) Support context in providers (@johejo)\n- [#487](https://github.com/oauth2-proxy/oauth2-proxy/pull/487) Switch flags to PFlag to remove StringArray (@JoelSpeed)\n- [#484](https://github.com/oauth2-proxy/oauth2-proxy/pull/484) Replace configuration loading with Viper (@JoelSpeed)\n- [#499](https://github.com/oauth2-proxy/oauth2-proxy/pull/499) Add `-user-id-claim` to support generic claims in addition to email (@holyjak)\n- [#486](https://github.com/oauth2-proxy/oauth2-proxy/pull/486) Add new linters (@johejo)\n- [#440](https://github.com/oauth2-proxy/oauth2-proxy/pull/440) Switch Azure AD Graph API to Microsoft Graph API (@johejo)\n- [#453](https://github.com/oauth2-proxy/oauth2-proxy/pull/453) Prevent browser caching during auth flow (@johejo)\n- [#467](https://github.com/oauth2-proxy/oauth2-proxy/pull/467) Allow OIDC issuer verification to be skipped (@chkohner)\n- [#481](https://github.com/oauth2-proxy/oauth2-proxy/pull/481) Update Okta docs (@trevorbox)\n- [#474](https://github.com/oauth2-proxy/oauth2-proxy/pull/474) Always log hasMember request error object (@jbielick)\n- [#468](https://github.com/oauth2-proxy/oauth2-proxy/pull/468) Implement graceful shutdown and propagate request context (@johejo)\n- [#464](https://github.com/oauth2-proxy/oauth2-proxy/pull/464) Migrate to oauth2-proxy/oauth2-proxy (@JoelSpeed)\n  - Project renamed from `pusher/oauth2_proxy` to `oauth2-proxy`\n  - Move Go import path from `github.com/pusher/oauth2_proxy` to `github.com/oauth2-proxy/oauth2-proxy`\n  - Remove Pusher Cloud Team from CODEOWNERS\n  - Release images moved to `quay.io/oauth2-proxy/oauth2-proxy`\n  - Binaries renamed from `oauth2_proxy` to `oauth2-proxy`\n- [#432](https://github.com/oauth2-proxy/oauth2-proxy/pull/432) Update ruby dependencies for documentation (@theobarberbany)\n- [#471](https://github.com/oauth2-proxy/oauth2-proxy/pull/471) Add logging in case of invalid redirects (@gargath)\n- [#462](https://github.com/oauth2-proxy/oauth2-proxy/pull/462) Allow HTML in banner message (@eritikass)\n- [#412](https://github.com/oauth2-proxy/oauth2-proxy/pull/412) Allow multiple cookie domains to be specified (@edahlseng)\n- [#413](https://github.com/oauth2-proxy/oauth2-proxy/pull/413) Add -set-basic-auth param to set the Basic Authorization header for upstreams (@morarucostel)\n- [#483](https://github.com/oauth2-proxy/oauth2-proxy/pull/483) Warn users when session cookies are split (@JoelSpeed)\n- [#488](https://github.com/oauth2-proxy/oauth2-proxy/pull/488) Set-Basic-Auth should default to false (@JoelSpeed)\n- [#494](https://github.com/oauth2-proxy/oauth2-proxy/pull/494) Upstream websockets TLS certificate validation now depends on ssl-upstream-insecure-skip-verify (@yaroslavros)\n- [#497](https://github.com/oauth2-proxy/oauth2-proxy/pull/497) Restrict access using Github collaborators (@jsclayton)\n- [#414](https://github.com/oauth2-proxy/oauth2-proxy/pull/414) Always encrypt sessions regardless of config (@ti-mo)\n- [#421](https://github.com/oauth2-proxy/oauth2-proxy/pull/421) Allow logins by usernames even if they do not belong to the specified org and team or collaborators (@yyoshiki41)\n\n# v5.1.1\n\n## Release Highlights\n\nN/A\n\n## Important Notes\n\n- (Security) Fix for [open redirect vulnerability](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-j7px-6hwj-hpjg).\n  - A bad actor using encoded whitespace in redirect URIs can redirect a session to another domain\n\n## Breaking Changes\n\nN/A\n\n## Changes since v5.1.0\n\n- [GHSA-j7px-6hwj-hpjg](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-j7px-6hwj-hpjg) Fix Open Redirect Vulnerability with encoded Whitespace characters (@JoelSpeed)\n\n# v5.1.0\n\n## Release Highlights\n\n- Bump to Go 1.14\n- Reduced number of Google API requests for group validation\n- Support for Redis Cluster\n- Support for overriding hosts in hosts file\n\n## Important Notes\n\n- [#335] The session expiry for the OIDC provider is now taken from the Token Response (expires_in) rather than from the id_token (exp)\n\n## Breaking Changes\n\nN/A\n\n## Changes since v5.0.0\n\n- [#450](https://github.com/oauth2-proxy/oauth2-proxy/pull/450) Fix http.Cookie SameSite is not copied (@johejo)\n- [#445](https://github.com/oauth2-proxy/oauth2-proxy/pull/445) Expose `acr_values` to all providers (@holyjak)\n- [#419](https://github.com/oauth2-proxy/oauth2-proxy/pull/419) Support Go 1.14, upgrade dependencies, upgrade golangci-lint to 1.23.6 (@johejo)\n- [#444](https://github.com/oauth2-proxy/oauth2-proxy/pull/444) Support prompt in addition to approval-prompt (@holyjak)\n- [#435](https://github.com/oauth2-proxy/oauth2-proxy/pull/435) Fix issue with group validation calling google directory API on every HTTP request (@ericofusco)\n- [#400](https://github.com/oauth2-proxy/oauth2-proxy/pull/400) Add `nsswitch.conf` to Docker image to allow hosts file to work (@luketainton)\n- [#385](https://github.com/oauth2-proxy/oauth2-proxy/pull/385) Use the `Authorization` header instead of `access_token` for refreshing GitHub Provider sessions (@ibuclaw)\n- [#372](https://github.com/oauth2-proxy/oauth2-proxy/pull/372) Allow fallback to secondary verified email address in GitHub provider (@dmnemec)\n- [#335](https://github.com/oauth2-proxy/oauth2-proxy/pull/335) OIDC Provider support for empty id_tokens in the access token refresh response (@howzat)\n- [#363](https://github.com/oauth2-proxy/oauth2-proxy/pull/363) Extension of Redis Session Store to Support Redis Cluster (@yan-dblinf)\n- [#353](https://github.com/oauth2-proxy/oauth2-proxy/pull/353) Fix login page fragment handling after soft reload on Firefox (@ffdybuster)\n- [#355](https://github.com/oauth2-proxy/oauth2-proxy/pull/355) Add Client Secret File support for providers that rotate client secret via file system (@pasha-r)\n- [#401](https://github.com/oauth2-proxy/oauth2-proxy/pull/401) Give the option to pass email address in the Basic auth header instead of upstream usernames. (@Spindel)\n- [#405](https://github.com/oauth2-proxy/oauth2-proxy/pull/405) The `/sign_in` page now honors the `rd` query parameter, fixing the redirect after a successful authentication (@ti-mo)\n- [#434](https://github.com/oauth2-proxy/oauth2-proxy/pull/434) Give the option to prefer email address in the username header when using the -pass-user-headers option (@jordancrawfordnz)\n\n# v5.0.0\n\n## Release Highlights\n\n- Disabled CGO (binaries will work regardless og glibc/musl)\n- Allow whitelisted redirect ports\n- Nextcloud provider support added\n- DigitalOcean provider support added\n\n## Important Notes\n\n- (Security) Fix for [open redirect vulnerability](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-qqxw-m5fj-f7gv).. a bad actor using `/\\` in redirect URIs can redirect a session to another domain\n\n## Breaking Changes\n\n- [#321](https://github.com/oauth2-proxy/oauth2-proxy/pull/331) Add reverse proxy boolean flag to control whether headers like `X-Real-Ip` are accepted.\n  This defaults to false. **Usage behind a reverse proxy will require this flag to be set to avoid logging the reverse proxy IP address**.\n\n## Changes since v4.1.0\n\n- [#331](https://github.com/oauth2-proxy/oauth2-proxy/pull/331) Add reverse proxy setting (@martin-css)\n- [#365](https://github.com/oauth2-proxy/oauth2-proxy/pull/365) Build with CGO=0 (@tomelliff)\n- [#339](https://github.com/oauth2-proxy/oauth2-proxy/pull/339) Add configuration for cookie 'SameSite' value. (@pgroudas)\n- [#347](https://github.com/oauth2-proxy/oauth2-proxy/pull/347) Update keycloak provider configuration documentation. (@sushiMix)\n- [#325](https://github.com/oauth2-proxy/oauth2-proxy/pull/325) dist.sh: use sha256sum (@syscll)\n- [#179](https://github.com/oauth2-proxy/oauth2-proxy/pull/179) Add Nextcloud provider (@Ramblurr)\n- [#280](https://github.com/oauth2-proxy/oauth2-proxy/pull/280) whitelisted redirect domains: add support for whitelisting specific ports or allowing wildcard ports (@kamaln7)\n- [#351](https://github.com/oauth2-proxy/oauth2-proxy/pull/351) Add DigitalOcean Auth provider (@kamaln7)\n\n# v4.1.0\n\n## Release Highlights\n\n- Added Keycloak provider\n- Build on Go 1.13\n- Upgrade Docker image to use Debian Buster\n- Added support for FreeBSD builds\n- Added new logo\n- Added support for GitHub teams\n\n## Important Notes\n\nN/A\n\n## Breaking Changes\n\nN/A\n\n## Changes since v4.0.0\n\n- [#292](https://github.com/oauth2-proxy/oauth2-proxy/pull/292) Added bash >= 4.0 dependency to configure script (@jmfrank63)\n- [#227](https://github.com/oauth2-proxy/oauth2-proxy/pull/227) Add Keycloak provider (@Ofinka)\n- [#259](https://github.com/oauth2-proxy/oauth2-proxy/pull/259) Redirect to HTTPS (@jmickey)\n- [#273](https://github.com/oauth2-proxy/oauth2-proxy/pull/273) Support Go 1.13 (@dio)\n- [#275](https://github.com/oauth2-proxy/oauth2-proxy/pull/275) docker: build from debian buster (@syscll)\n- [#258](https://github.com/oauth2-proxy/oauth2-proxy/pull/258) Add IDToken for Azure provider (@leyshon)\n  - This PR adds the IDToken into the session for the Azure provider allowing requests to a backend to be identified as a specific user. As a consequence, if you are using a cookie to store the session the cookie will now exceed the 4kb size limit and be split into multiple cookies. This can cause problems when using nginx as a proxy, resulting in no cookie being passed at all. Either increase the proxy_buffer_size in nginx or implement the redis session storage (see https://oauth2-proxy.github.io/oauth2-proxy/configuration#redis-storage)\n- [#286](https://github.com/oauth2-proxy/oauth2-proxy/pull/286) Requests.go updated with useful error messages (@biotom)\n- [#274](https://github.com/oauth2-proxy/oauth2-proxy/pull/274) Supports many github teams with api pagination support (@toshi-miura, @apratina)\n- [#302](https://github.com/oauth2-proxy/oauth2-proxy/pull/302) Rewrite dist script (@syscll)\n- [#304](https://github.com/oauth2-proxy/oauth2-proxy/pull/304) Add new Logo! :tada: (@JoelSpeed)\n- [#300](https://github.com/oauth2-proxy/oauth2-proxy/pull/300) Added userinfo endpoint (@kbabuadze)\n- [#309](https://github.com/oauth2-proxy/oauth2-proxy/pull/309) Added support for custom CA when connecting to Redis cache (@lleszczu)\n- [#248](https://github.com/oauth2-proxy/oauth2-proxy/pull/248) Fix issue with X-Auth-Request-Redirect header being ignored (@webnard)\n- [#314](https://github.com/oauth2-proxy/oauth2-proxy/pull/314) Add redirect capability to sign_out (@costelmoraru)\n- [#265](https://github.com/oauth2-proxy/oauth2-proxy/pull/265) Add upstream with static response (@cgroschupp)\n- [#317](https://github.com/oauth2-proxy/oauth2-proxy/pull/317) Add build for FreeBSD (@fnkr)\n- [#296](https://github.com/oauth2-proxy/oauth2-proxy/pull/296) Allow to override provider's name for sign-in page (@ffdybuster)\n\n# v4.0.0\n\n## Release Highlights\n\n- Documentation is now on a [microsite](https://oauth2-proxy.github.io/oauth2-proxy/)\n- Health check logging can now be disabled for quieter logs\n- Authorization Header JWTs can now be verified by the proxy to skip authentication for machine users\n- Sessions can now be stored in Redis. This reduces refresh failures and uses smaller cookies (Recommended for those using OIDC refreshing)\n- Logging overhaul allows customisable logging formats\n\n## Important Notes\n\n- This release includes a number of breaking changes that will require users to\n  reconfigure their proxies. Please read the Breaking Changes below thoroughly.\n\n## Breaking Changes\n\n- [#231](https://github.com/oauth2-proxy/oauth2-proxy/pull/231) Rework GitLab provider\n  - This PR changes the configuration options for the GitLab provider to use\n    a self-hosted instance. You now need to specify a `-oidc-issuer-url` rather than\n    explicit `-login-url`, `-redeem-url` and `-validate-url` parameters.\n- [#186](https://github.com/oauth2-proxy/oauth2-proxy/pull/186) Make config consistent\n  - This PR changes configuration options so that all flags have a config counterpart\n    of the same name but with underscores (`_`) in place of hyphens (`-`).\n    This change affects the following flags:\n  - The `--tls-key` flag is now `--tls-key-file` to be consistent with existing\n    file flags and the existing config and environment settings\n  - The `--tls-cert` flag is now `--tls-cert-file` to be consistent with existing\n    file flags and the existing config and environment settings\n    This change affects the following existing configuration options:\n  - The `proxy-prefix` option is now `proxy_prefix`.\n    This PR changes environment variables so that all flags have an environment\n    counterpart of the same name but capitalised, with underscores (`_`) in place\n    of hyphens (`-`) and with the prefix `OAUTH2_PROXY_`.\n    This change affects the following existing environment variables:\n  - The `OAUTH2_SKIP_OIDC_DISCOVERY` environment variable is now `OAUTH2_PROXY_SKIP_OIDC_DISCOVERY`.\n  - The `OAUTH2_OIDC_JWKS_URL` environment variable is now `OAUTH2_PROXY_OIDC_JWKS_URL`.\n- [#146](https://github.com/oauth2-proxy/oauth2-proxy/pull/146) Use full email address as `User` if the auth response did not contain a `User` field\n  - This change modifies the contents of the `X-Forwarded-User` header supplied by the proxy for users where the auth response from the IdP did not contain\n    a username.\n    In that case, this header used to only contain the local part of the user's email address (e.g. `john.doe` for `john.doe@example.com`) but now contains\n    the user's full email address instead.\n- [#170](https://github.com/oauth2-proxy/oauth2-proxy/pull/170) Pre-built binary tarballs changed format\n  - The pre-built binary tarballs again match the format of the [bitly](https://github.com/bitly/oauth2_proxy) repository, where the unpacked directory\n    has the same name as the tarball and the binary is always named `oauth2_proxy`. This was done to restore compatibility with third-party automation\n    recipes like https://github.com/jhoblitt/puppet-oauth2_proxy.\n\n## Changes since v3.2.0\n\n- [#234](https://github.com/oauth2-proxy/oauth2-proxy/pull/234) Added option `-ssl-upstream-insecure-skip-validation` to skip validation of upstream SSL certificates (@jansinger)\n- [#224](https://github.com/oauth2-proxy/oauth2-proxy/pull/224) Check Google group membership using hasMember to support nested groups and external users (@jpalpant)\n- [#231](https://github.com/oauth2-proxy/oauth2-proxy/pull/231) Add optional group membership and email domain checks to the GitLab provider (@Overv)\n- [#226](https://github.com/oauth2-proxy/oauth2-proxy/pull/226) Made setting of proxied headers deterministic based on configuration alone (@aeijdenberg)\n- [#178](https://github.com/oauth2-proxy/oauth2-proxy/pull/178) Add Silence Ping Logging and Exclude Logging Paths flags (@kskewes)\n- [#209](https://github.com/oauth2-proxy/oauth2-proxy/pull/209) Improve docker build caching of layers (@dekimsey)\n- [#186](https://github.com/oauth2-proxy/oauth2-proxy/pull/186) Make config consistent (@JoelSpeed)\n- [#187](https://github.com/oauth2-proxy/oauth2-proxy/pull/187) Move root packages to pkg folder (@JoelSpeed)\n- [#65](https://github.com/oauth2-proxy/oauth2-proxy/pull/65) Improvements to authenticate requests with a JWT bearer token in the `Authorization` header via\n  the `-skip-jwt-bearer-token` options. (@brianv0)\n  - Additional verifiers can be configured via the `-extra-jwt-issuers` flag if the JWT issuers is either an OpenID provider or has a JWKS URL\n    (e.g. `https://example.com/.well-known/jwks.json`).\n- [#180](https://github.com/oauth2-proxy/oauth2-proxy/pull/180) Minor refactor of core proxying path (@aeijdenberg).\n- [#175](https://github.com/oauth2-proxy/oauth2-proxy/pull/175) Bump go-oidc to v2.0.0 (@aeijdenberg).\n  - Includes fix for potential signature checking issue when OIDC discovery is skipped.\n- [#155](https://github.com/oauth2-proxy/oauth2-proxy/pull/155) Add RedisSessionStore implementation (@brianv0, @JoelSpeed)\n  - Implement flags to configure the redis session store\n    - `-session-store-type=redis` Sets the store type to redis\n    - `-redis-connection-url` Sets the Redis connection URL\n    - `-redis-use-sentinel=true` Enables Redis Sentinel support\n    - `-redis-sentinel-master-name` Sets the Sentinel master name, if sentinel is enabled\n    - `-redis-sentinel-connection-urls` Defines the Redis Sentinel Connection URLs, if sentinel is enabled\n  - Introduces the concept of a session ticket. Tickets are composed of the cookie name, a session ID, and a secret.\n  - Redis Sessions are stored encrypted with a per-session secret\n  - Added tests for server based session stores\n- [#168](https://github.com/oauth2-proxy/oauth2-proxy/pull/168) Drop Go 1.11 support in Travis (@JoelSpeed)\n- [#169](https://github.com/oauth2-proxy/oauth2-proxy/pull/169) Update Alpine to 3.9 (@kskewes)\n- [#148](https://github.com/oauth2-proxy/oauth2-proxy/pull/148) Implement SessionStore interface within proxy (@JoelSpeed)\n- [#147](https://github.com/oauth2-proxy/oauth2-proxy/pull/147) Add SessionStore interfaces and initial implementation (@JoelSpeed)\n  - Allows for multiple different session storage implementations including client and server side\n  - Adds tests suite for interface to ensure consistency across implementations\n  - Refactor some configuration options (around cookies) into packages\n- [#114](https://github.com/oauth2-proxy/oauth2-proxy/pull/114), [#154](https://github.com/oauth2-proxy/oauth2-proxy/pull/154) Documentation is now available live at our [docs website](https://oauth2-proxy.github.io/oauth2-proxy/) (@JoelSpeed, @icelynjennings)\n- [#146](https://github.com/oauth2-proxy/oauth2-proxy/pull/146) Use full email address as `User` if the auth response did not contain a `User` field (@gargath)\n- [#144](https://github.com/oauth2-proxy/oauth2-proxy/pull/144) Use GO 1.12 for ARM builds (@kskewes)\n- [#142](https://github.com/oauth2-proxy/oauth2-proxy/pull/142) ARM Docker USER fix (@kskewes)\n- [#52](https://github.com/oauth2-proxy/oauth2-proxy/pull/52) Logging Improvements (@MisterWil)\n  - Implement flags to configure file logging\n    - `-logging-filename` Defines the filename to log to\n    - `-logging-max-size` Defines the maximum\n    - `-logging-max-age` Defines the maximum age of backups to retain\n    - `-logging-max-backups` Defines the maximum number of rollover log files to retain\n    - `-logging-compress` Defines if rollover log files should be compressed\n    - `-logging-local-time` Defines if logging date and time should be local or UTC\n  - Implement two new flags to enable or disable specific logging types\n    - `-standard-logging` Enables or disables standard (not request or auth) logging\n    - `-auth-logging` Enables or disables auth logging\n  - Implement two new flags to customize the logging format\n    - `-standard-logging-format` Sets the format for standard logging\n    - `-auth-logging-format` Sets the format for auth logging\n- [#111](https://github.com/oauth2-proxy/oauth2-proxy/pull/111) Add option for telling where to find a login.gov JWT key file (@timothy-spencer)\n- [#170](https://github.com/oauth2-proxy/oauth2-proxy/pull/170) Restore binary tarball contents to be compatible with bitlys original tarballs (@zeha)\n- [#185](https://github.com/oauth2-proxy/oauth2-proxy/pull/185) Fix an unsupported protocol scheme error during token validation when using the Azure provider (@jonas)\n- [#141](https://github.com/oauth2-proxy/oauth2-proxy/pull/141) Check google group membership based on email address (@bchess)\n  - Google Group membership is additionally checked via email address, allowing users outside a GSuite domain to be authorized.\n- [#195](https://github.com/oauth2-proxy/oauth2-proxy/pull/195) Add `-banner` flag for overriding the banner line that is displayed (@steakunderscore)\n- [#198](https://github.com/oauth2-proxy/oauth2-proxy/pull/198) Switch from gometalinter to golangci-lint (@steakunderscore)\n- [#159](https://github.com/oauth2-proxy/oauth2-proxy/pull/159) Add option to skip the OIDC provider verified email check: `--insecure-oidc-allow-unverified-email` (@djfinlay)\n- [#210](https://github.com/oauth2-proxy/oauth2-proxy/pull/210) Update base image from Alpine 3.9 to 3.10 (@steakunderscore)\n- [#201](https://github.com/oauth2-proxy/oauth2-proxy/pull/201) Add Bitbucket as new OAuth2 provider, accepts email, team and repository permissions to determine authorization (@aledeganopix4d)\n  - Implement flags to enable Bitbucket authentication:\n    - `-bitbucket-repository` Restrict authorization to users that can access this repository\n    - `-bitbucket-team` Restrict authorization to users that are part of this Bitbucket team\n- [#211](https://github.com/oauth2-proxy/oauth2-proxy/pull/211) Switch from dep to go modules (@steakunderscore)\n- [#145](https://github.com/oauth2-proxy/oauth2-proxy/pull/145) Add support for OIDC UserInfo endpoint email verification (@rtluckie)\n\n# v3.2.0\n\n## Release highlights\n\n- Internal restructure of session state storage to use JSON rather than proprietary scheme\n- Added health check options for running on GCP behind a load balancer\n- Improved support for protecting websockets\n- Added provider for login.gov\n- Allow manual configuration of OIDC providers\n\n## Important notes\n\n- Dockerfile user is now non-root, this may break your existing deployment\n- In the OIDC provider, when no email is returned, the ID Token subject will be used\n  instead of returning an error\n- GitHub user emails must now be primary and verified before authenticating\n\n## Changes since v3.1.0\n\n- [#96](https://github.com/bitly/oauth2_proxy/pull/96) Check if email is verified on GitHub (@caarlos0)\n- [#110](https://github.com/oauth2-proxy/oauth2-proxy/pull/110) Added GCP healthcheck option (@timothy-spencer)\n- [#112](https://github.com/oauth2-proxy/oauth2-proxy/pull/112) Improve websocket support (@gyson)\n- [#63](https://github.com/oauth2-proxy/oauth2-proxy/pull/63) Use encoding/json for SessionState serialization (@yaegashi)\n  - Use JSON to encode session state to be stored in browser cookies\n  - Implement legacy decode function to support existing cookies generated by older versions\n  - Add detailed table driven tests in session_state_test.go\n- [#120](https://github.com/oauth2-proxy/oauth2-proxy/pull/120) Encrypting user/email from cookie (@costelmoraru)\n- [#55](https://github.com/oauth2-proxy/oauth2-proxy/pull/55) Added login.gov provider (@timothy-spencer)\n- [#55](https://github.com/oauth2-proxy/oauth2-proxy/pull/55) Added environment variables for all config options (@timothy-spencer)\n- [#70](https://github.com/oauth2-proxy/oauth2-proxy/pull/70) Fix handling of splitted cookies (@einfachchr)\n- [#92](https://github.com/oauth2-proxy/oauth2-proxy/pull/92) Merge websocket proxy feature from openshift/oauth-proxy (@butzist)\n- [#57](https://github.com/oauth2-proxy/oauth2-proxy/pull/57) Fall back to using OIDC Subject instead of Email (@aigarius)\n- [#85](https://github.com/oauth2-proxy/oauth2-proxy/pull/85) Use non-root user in docker images (@kskewes)\n- [#68](https://github.com/oauth2-proxy/oauth2-proxy/pull/68) forward X-Auth-Access-Token header (@davidholsgrove)\n- [#41](https://github.com/oauth2-proxy/oauth2-proxy/pull/41) Added option to manually specify OIDC endpoints instead of relying on discovery\n- [#83](https://github.com/oauth2-proxy/oauth2-proxy/pull/83) Add `id_token` refresh to Google provider (@leki75)\n- [#10](https://github.com/oauth2-proxy/oauth2-proxy/pull/10) fix redirect url param handling (@dt-rush)\n- [#122](https://github.com/oauth2-proxy/oauth2-proxy/pull/122) Expose -cookie-path as configuration parameter (@costelmoraru)\n- [#124](https://github.com/oauth2-proxy/oauth2-proxy/pull/124) Use Go 1.12 for testing and build environments (@syscll)\n\n# v3.1.0\n\n## Release highlights\n\n- Introduction of ARM releases and and general improvements to Docker builds\n- Improvements to OIDC provider allowing pass-through of ID Tokens\n- Multiple redirect domains can now be whitelisted\n- Streamed responses are now flushed periodically\n\n## Important notes\n\n- If you have been using [#bitly/621](https://github.com/bitly/oauth2_proxy/pull/621)\n  and have cookies larger than the 4kb limit,\n  the cookie splitting pattern has changed and now uses `_` in place of `-` when\n  indexing cookies.\n  This will force users to reauthenticate the first time they use `v3.1.0`.\n- Streamed responses will now be flushed every 1 second by default.\n  Previously streamed responses were flushed only when the buffer was full.\n  To retain the old behaviour set `--flush-interval=0`.\n  See [#23](https://github.com/oauth2-proxy/oauth2-proxy/pull/23) for further details.\n\n## Changes since v3.0.0\n\n- [#14](https://github.com/oauth2-proxy/oauth2-proxy/pull/14) OIDC ID Token, Authorization Headers, Refreshing and Verification (@joelspeed)\n  - Implement `pass-authorization-header` and `set-authorization-header` flags\n  - Implement token refreshing in OIDC provider\n  - Split cookies larger than 4k limit into multiple cookies\n  - Implement token validation in OIDC provider\n- [#15](https://github.com/oauth2-proxy/oauth2-proxy/pull/15) WhitelistDomains (@joelspeed)\n  - Add `--whitelist-domain` flag to allow redirection to approved domains after OAuth flow\n- [#21](https://github.com/oauth2-proxy/oauth2-proxy/pull/21) Docker Improvement (@yaegashi)\n  - Move Docker base image from debian to alpine\n  - Install ca-certificates in docker image\n- [#23](https://github.com/oauth2-proxy/oauth2-proxy/pull/23) Flushed streaming responses\n  - Long-running upstream responses will get flushed every <timeperiod> (1 second by default)\n- [#24](https://github.com/oauth2-proxy/oauth2-proxy/pull/24) Redirect fix (@agentgonzo)\n  - After a successful login, you will be redirected to your original URL rather than /\n- [#35](https://github.com/oauth2-proxy/oauth2-proxy/pull/35) arm and arm64 binary releases (@kskewes)\n  - Add armv6 and arm64 to Makefile `release` target\n- [#37](https://github.com/oauth2-proxy/oauth2-proxy/pull/37) cross build arm and arm64 docker images (@kskewes)\n\n# v3.0.0\n\nAdoption of OAuth2_Proxy by Pusher.\nProject was hard forked and tidied however no logical changes have occurred since\nv2.2 as released by Bitly.\n\n## Changes since v2.2:\n\n- [#7](https://github.com/oauth2-proxy/oauth2-proxy/pull/7) Migration to Pusher (@joelspeed)\n  - Move automated build to debian base image\n  - Add Makefile\n    - Update CI to run `make test`\n    - Update Dockerfile to use `make clean oauth2_proxy`\n    - Update `VERSION` parameter to be set by `ldflags` from Git Status\n    - Remove lint and test scripts\n  - Remove Go v1.8.x from Travis CI testing\n  - Add CODEOWNERS file\n  - Add CONTRIBUTING guide\n  - Add Issue and Pull Request templates\n  - Add Dockerfile\n  - Fix fsnotify import\n  - Update README to reflect new repository ownership\n  - Update CI scripts to separate linting and testing\n    - Now using `gometalinter` for linting\n  - Move Go import path from `github.com/bitly/oauth2_proxy` to `github.com/pusher/oauth2_proxy`\n  - Repository forked on 27/11/18\n    - README updated to include note that this repository is forked\n    - CHANGLOG created to track changes to repository from original fork\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 5.4501953125,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual\nidentity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the overall\n  community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or advances of\n  any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email address,\n  without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official email address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nhttps://gophers.slack.com/messages/CM2RSS25N or directly contacting one of the\nmaintainers from the MAINTAINERS file.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series of\nactions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or permanent\nban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior, harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within the\ncommunity.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.1, available at\n[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].\n\nCommunity Impact Guidelines were inspired by\n[Mozilla's code of conduct enforcement ladder][Mozilla CoC].\n\nFor answers to common questions about this code of conduct, see the FAQ at\n[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at\n[https://www.contributor-covenant.org/translations][translations].\n\n[homepage]: https://www.contributor-covenant.org\n[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html\n[Mozilla CoC]: https://github.com/mozilla/diversity\n[FAQ]: https://www.contributor-covenant.org/faq\n[translations]: https://www.contributor-covenant.org/translations\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.7001953125,
          "content": "# Contributing\n\nTo develop on this project, please fork the repo and clone into your `$GOPATH`.\n\nDependencies are **not** checked in so please download those separately.\nDownload the dependencies using `go mod download`.\n\n```bash\ncd $GOPATH/src/github.com # Create this directory if it doesn't exist\ngit clone git@github.com:<YOUR_FORK>/oauth2-proxy oauth2-proxy/oauth2-proxy\ncd oauth2-proxy/oauth2-proxy\ngo mod download\n```\n\n## Pull Requests and Issues\n\nWe track bugs and issues using Github.\n\nIf you find a bug, please open an Issue.\n\nIf you want to fix a bug, please fork, create a feature branch, fix the bug and\nopen a PR back to this repo.\nPlease mention the open bug issue number within your PR if applicable.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 2.767578125,
          "content": "# This ARG has to be at the top, otherwise the docker daemon does not known what to do with FROM ${RUNTIME_IMAGE}\nARG RUNTIME_IMAGE=gcr.io/distroless/static:nonroot\n# version is shared between mutiple buildstages\nARG VERSION\n\n# All builds should be done using the platform native to the build node to allow\n#  cache sharing of the go mod download step.\n# Go cross compilation is also faster than emulation the go compilation across\n#  multiple platforms.\nFROM --platform=${BUILDPLATFORM} docker.io/library/golang:1.22-bookworm AS builder\n\n# Copy sources\nWORKDIR $GOPATH/src/github.com/oauth2-proxy/oauth2-proxy\n\n# Fetch dependencies\nCOPY go.mod go.sum ./\nRUN go mod download\n\n# Now pull in our code\nCOPY . .\n\n# Arguments go here so that the previous steps can be cached if no external\n#  sources have changed.\nARG TARGETPLATFORM\nARG BUILDPLATFORM\n\n# Build binary and make sure there is at least an empty key file.\n#  This is useful for GCP App Engine custom runtime builds, because\n#  you cannot use multiline variables in their app.yaml, so you have to\n#  build the key into the container and then tell it where it is\n#  by setting OAUTH2_PROXY_JWT_KEY_FILE=/etc/ssl/private/jwt_signing_key.pem\n#  in app.yaml instead.\n# Set the cross compilation arguments based on the TARGETPLATFORM which is\n#  automatically set by the docker engine.\nRUN case ${TARGETPLATFORM} in \\\n         \"linux/amd64\")  GOARCH=amd64  ;; \\\n         # arm64 and arm64v8 are equivalent in go and do not require a goarm\n         # https://github.com/golang/go/wiki/GoArm\n         \"linux/arm64\" | \"linux/arm/v8\")  GOARCH=arm64  ;; \\\n         \"linux/ppc64le\")  GOARCH=ppc64le  ;; \\\n         \"linux/s390x\")  GOARCH=s390x  ;; \\\n         \"linux/arm/v6\") GOARCH=arm GOARM=6  ;; \\\n         \"linux/arm/v7\") GOARCH=arm GOARM=7 ;; \\\n    esac && \\\n    printf \"Building OAuth2 Proxy for arch ${GOARCH}\\n\" && \\\n    GOARCH=${GOARCH} VERSION=${VERSION} make build && touch jwt_signing_key.pem\n\n# Copy binary to runtime image\nFROM ${RUNTIME_IMAGE}\nARG VERSION\n\nCOPY --from=builder /go/src/github.com/oauth2-proxy/oauth2-proxy/oauth2-proxy /bin/oauth2-proxy\nCOPY --from=builder /go/src/github.com/oauth2-proxy/oauth2-proxy/jwt_signing_key.pem /etc/ssl/private/jwt_signing_key.pem\n\nLABEL org.opencontainers.image.licenses=MIT \\\n      org.opencontainers.image.description=\"A reverse proxy that provides authentication with Google, Azure, OpenID Connect and many more identity providers.\" \\\n      org.opencontainers.image.documentation=https://oauth2-proxy.github.io/oauth2-proxy/ \\\n      org.opencontainers.image.source=https://github.com/oauth2-proxy/oauth2-proxy \\\n      org.opencontainers.image.url=https://quay.io/oauth2-proxy/oauth2-proxy \\\n      org.opencontainers.image.title=oauth2-proxy \\\n      org.opencontainers.image.version=${VERSION}\n\nENTRYPOINT [\"/bin/oauth2-proxy\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.9990234375,
          "content": "Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 0.240234375,
          "content": "Joel Speed <joel@oauth2-proxy.dev> (@JoelSpeed)\nNick Meves <nick@oauth2-proxy.dev> (@NickMeves)\nBraunson <braunson@oauth2-proxy.dev> (@braunsonm)\nJan Larwig <jan@oauth2-proxy.dev> (@tuunit)\nKoen van Zuijlen <koen@oauth2-proxy.dev> (@kvanzuijlen)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 6.0283203125,
          "content": "GO ?= go\nGOLANGCILINT ?= golangci-lint\n\nBINARY := oauth2-proxy\nVERSION ?= $(shell git describe --always --dirty --tags 2>/dev/null || echo \"undefined\")\n# Allow to override image registry.\nREGISTRY   ?= quay.io/oauth2-proxy\nREPOSITORY ?= oauth2-proxy\n\nDATE := $(shell date +\"%Y%m%d\")\n.NOTPARALLEL:\n\nGO_MAJOR_VERSION = $(shell $(GO) version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f1)\nGO_MINOR_VERSION = $(shell $(GO) version | cut -c 14- | cut -d' ' -f1 | cut -d'.' -f2)\nMINIMUM_SUPPORTED_GO_MAJOR_VERSION = 1\nMINIMUM_SUPPORTED_GO_MINOR_VERSION = 20\nGO_VERSION_VALIDATION_ERR_MSG = Golang version is not supported, please update to at least $(MINIMUM_SUPPORTED_GO_MAJOR_VERSION).$(MINIMUM_SUPPORTED_GO_MINOR_VERSION)\n\nifeq ($(COVER),true)\nTESTCOVER ?= -coverprofile c.out\nendif\n\n.PHONY: all\nall: lint $(BINARY)\n\n.PHONY: clean\nclean:\n\t-rm -rf release\n\t-rm -f $(BINARY)\n\n.PHONY: distclean\ndistclean: clean\n\trm -rf vendor\n\n.PHONY: lint\nlint: validate-go-version\n\tGO111MODULE=on $(GOLANGCILINT) run\n\n.PHONY: build\nbuild: validate-go-version clean $(BINARY)\n\n$(BINARY):\n\tCGO_ENABLED=0 $(GO) build -a -installsuffix cgo -ldflags=\"-X github.com/oauth2-proxy/oauth2-proxy/v7/pkg/version.VERSION=${VERSION}\" -o $@ github.com/oauth2-proxy/oauth2-proxy/v7\n\nDOCKER_BUILD_PLATFORM         ?= linux/amd64,linux/arm64,linux/ppc64le,linux/arm/v7,linux/s390x\nDOCKER_BUILD_RUNTIME_IMAGE    ?= gcr.io/distroless/static:nonroot\nDOCKER_BUILDX_ARGS            ?= --build-arg RUNTIME_IMAGE=${DOCKER_BUILD_RUNTIME_IMAGE} --build-arg VERSION=${VERSION}\nDOCKER_BUILDX                 := docker buildx build ${DOCKER_BUILDX_ARGS} --pull\nDOCKER_BUILDX_X_PLATFORM      := $(DOCKER_BUILDX) --platform ${DOCKER_BUILD_PLATFORM}\nDOCKER_BUILDX_PUSH            := $(DOCKER_BUILDX) --push\nDOCKER_BUILDX_PUSH_X_PLATFORM := $(DOCKER_BUILDX_PUSH) --platform ${DOCKER_BUILD_PLATFORM}\n\nDOCKER_BUILD_PLATFORM_ALPINE         ?= linux/amd64,linux/arm64,linux/ppc64le,linux/arm/v6,linux/arm/v7,linux/s390x\nDOCKER_BUILD_RUNTIME_IMAGE_ALPINE    ?= alpine:3.21.0\nDOCKER_BUILDX_ARGS_ALPINE            ?= --build-arg RUNTIME_IMAGE=${DOCKER_BUILD_RUNTIME_IMAGE_ALPINE} --build-arg VERSION=${VERSION}\nDOCKER_BUILDX_X_PLATFORM_ALPINE      := docker buildx build ${DOCKER_BUILDX_ARGS_ALPINE} --platform ${DOCKER_BUILD_PLATFORM_ALPINE}\nDOCKER_BUILDX_PUSH_X_PLATFORM_ALPINE := $(DOCKER_BUILDX_X_PLATFORM_ALPINE) --push\n\n.PHONY: docker\ndocker:\n\t$(DOCKER_BUILDX_X_PLATFORM) -t $(REGISTRY)/$(REPOSITORY):latest -t $(REGISTRY)/$(REPOSITORY):${VERSION} .\n\t$(DOCKER_BUILDX_X_PLATFORM_ALPINE) -t $(REGISTRY)/$(REPOSITORY):latest-alpine -t $(REGISTRY)/$(REPOSITORY):${VERSION}-alpine .\n\n.PHONY: docker-push\ndocker-push:\n\t$(DOCKER_BUILDX_PUSH_X_PLATFORM) -t $(REGISTRY)/$(REPOSITORY):latest -t $(REGISTRY)/$(REPOSITORY):${VERSION} .\n\t$(DOCKER_BUILDX_PUSH_X_PLATFORM_ALPINE) -t $(REGISTRY)/$(REPOSITORY):latest-alpine -t $(REGISTRY)/$(REPOSITORY):${VERSION}-alpine .\n\n.PHONY: docker-all\ndocker-all: docker\n\t$(DOCKER_BUILDX) --platform linux/amd64   -t $(REGISTRY)/$(REPOSITORY):latest-amd64   -t $(REGISTRY)/$(REPOSITORY):${VERSION}-amd64 .\n\t$(DOCKER_BUILDX) --platform linux/arm64   -t $(REGISTRY)/$(REPOSITORY):latest-arm64   -t $(REGISTRY)/$(REPOSITORY):${VERSION}-arm64 .\n\t$(DOCKER_BUILDX) --platform linux/ppc64le -t $(REGISTRY)/$(REPOSITORY):latest-ppc64le -t $(REGISTRY)/$(REPOSITORY):${VERSION}-ppc64le .\n\t$(DOCKER_BUILDX) --platform linux/arm/v7  -t $(REGISTRY)/$(REPOSITORY):latest-armv7   -t $(REGISTRY)/$(REPOSITORY):${VERSION}-armv7 .\n\t$(DOCKER_BUILDX) --platform linux/s390x   -t $(REGISTRY)/$(REPOSITORY):latest-s390x -t $(REGISTRY)/$(REPOSITORY):${VERSION}-s390x .\n\n.PHONY: docker-push-all\ndocker-push-all: docker-push\n\t$(DOCKER_BUILDX_PUSH) --platform linux/amd64   -t $(REGISTRY)/$(REPOSITORY):latest-amd64   -t $(REGISTRY)/$(REPOSITORY):${VERSION}-amd64 .\n\t$(DOCKER_BUILDX_PUSH) --platform linux/arm64   -t $(REGISTRY)/$(REPOSITORY):latest-arm64   -t $(REGISTRY)/$(REPOSITORY):${VERSION}-arm64 .\n\t$(DOCKER_BUILDX_PUSH) --platform linux/ppc64le -t $(REGISTRY)/$(REPOSITORY):latest-ppc64le -t $(REGISTRY)/$(REPOSITORY):${VERSION}-ppc64le .\n\t$(DOCKER_BUILDX_PUSH) --platform linux/arm/v7  -t $(REGISTRY)/$(REPOSITORY):latest-armv7   -t $(REGISTRY)/$(REPOSITORY):${VERSION}-armv7 .\n\t$(DOCKER_BUILDX_PUSH) --platform linux/s390x   -t $(REGISTRY)/$(REPOSITORY):latest-s390x -t $(REGISTRY)/$(REPOSITORY):${VERSION}-s390x .\n\n.PHONY: docker-nightly-build\ndocker-nightly-build:\n\t$(DOCKER_BUILDX_X_PLATFORM) -t $(REGISTRY)/$(REPOSITORY)-nightly:latest -t $(REGISTRY)/$(REPOSITORY)-nightly:${DATE} .\n\t$(DOCKER_BUILDX_X_PLATFORM_ALPINE) -t ${REGISTRY}/$(REPOSITORY)-nightly:latest-alpine -t $(REGISTRY)/$(REPOSITORY)-nightly:${DATE}-alpine .\n\n.PHONY: docker-nightly-push\ndocker-nightly-push:\n\t$(DOCKER_BUILDX_PUSH_X_PLATFORM) -t $(REGISTRY)/$(REPOSITORY)-nightly:latest -t $(REGISTRY)/$(REPOSITORY)-nightly:${DATE} .\n\t$(DOCKER_BUILDX_PUSH_X_PLATFORM_ALPINE) -t ${REGISTRY}/$(REPOSITORY)-nightly:latest-alpine -t $(REGISTRY)/$(REPOSITORY)-nightly:${DATE}-alpine .\n\n.PHONY: generate\ngenerate:\n\tgo generate ./pkg/...\n\n.PHONY: verify-generate\nverify-generate: generate\n\tgit diff --exit-code\n\n.PHONY: test\ntest: lint\n\tGO111MODULE=on $(GO) test $(TESTCOVER) -v -race ./...\n\n.PHONY: release\nrelease: validate-go-version lint test\n\tBINARY=${BINARY} VERSION=${VERSION} ./dist.sh\n\n.PHONY: validate-go-version\nvalidate-go-version:\n\t@if [ $(GO_MAJOR_VERSION) -gt $(MINIMUM_SUPPORTED_GO_MAJOR_VERSION) ]; then \\\n\t\texit 0 ;\\\n\telif [ $(GO_MAJOR_VERSION) -lt $(MINIMUM_SUPPORTED_GO_MAJOR_VERSION) ]; then \\\n\t\techo '$(GO_VERSION_VALIDATION_ERR_MSG)';\\\n\t\texit 1; \\\n\telif [ $(GO_MINOR_VERSION) -lt $(MINIMUM_SUPPORTED_GO_MINOR_VERSION) ] ; then \\\n\t\techo '$(GO_VERSION_VALIDATION_ERR_MSG)';\\\n\t\texit 1; \\\n\tfi\n\n# local-env can be used to interact with the local development environment\n# eg:\n#    make local-env-up          # Bring up a basic test environment\n#    make local-env-down        # Tear down the basic test environment\n#    make local-env-nginx-up    # Bring up an nginx based test environment\n#    make local-env-nginx-down  # Tead down the nginx based test environment\n.PHONY: local-env-%\nlocal-env-%:\n\tmake -C contrib/local-environment $*\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.330078125,
          "content": "[![Continuous Integration](https://github.com/oauth2-proxy/oauth2-proxy/actions/workflows/ci.yaml/badge.svg)](https://github.com/oauth2-proxy/oauth2-proxy/actions/workflows/ci.yaml)\n[![Go Report Card](https://goreportcard.com/badge/github.com/oauth2-proxy/oauth2-proxy)](https://goreportcard.com/report/github.com/oauth2-proxy/oauth2-proxy)\n[![GoDoc](https://godoc.org/github.com/oauth2-proxy/oauth2-proxy?status.svg)](https://godoc.org/github.com/oauth2-proxy/oauth2-proxy)\n[![MIT licensed](https://img.shields.io/badge/license-MIT-blue.svg)](./LICENSE)\n[![Maintainability](https://api.codeclimate.com/v1/badges/a58ff79407212e2beacb/maintainability)](https://codeclimate.com/github/oauth2-proxy/oauth2-proxy/maintainability)\n[![Test Coverage](https://api.codeclimate.com/v1/badges/a58ff79407212e2beacb/test_coverage)](https://codeclimate.com/github/oauth2-proxy/oauth2-proxy/test_coverage)\n\n![OAuth2 Proxy](docs/static/img/logos/OAuth2_Proxy_horizontal.svg)\n\nOAuth2-Proxy is a flexible, open-source tool that can act as either a standalone reverse proxy or a middleware component integrated into existing reverse proxy or load balancer setups. It provides a simple and secure way to protect your web applications with OAuth2 / OIDC authentication. As a reverse proxy, it intercepts requests to your application and redirects users to an OAuth2 provider for authentication. As a middleware, it can be seamlessly integrated into your existing infrastructure to handle authentication for multiple applications.\n\nOAuth2-Proxy supports a lot of OAuth2 as well as OIDC providers. Either through a generic OIDC client or a specific implementation for Google, Microsoft Entra ID, GitHub, login.gov and others. Through specialised provider implementations oauth2-proxy can extract more details about the user like preferred usernames and groups. Those details can then be forwarded as HTTP headers to your upstream applications.\n\n![Simplified Architecture](docs/static/img/simplified-architecture.svg)\n\n## Get Started\n\nOAuth2-Proxy's [Installation Docs](https://oauth2-proxy.github.io/oauth2-proxy/installation) cover how to install and configure your setup. Additionally you can take a further look at the [example setup files](https://github.com/oauth2-proxy/oauth2-proxy/tree/master/contrib/local-environment).\n\n## Releases\n\n### Binaries\nWe publish oauth2-proxy as compiled binaries on GitHub for all major architectures as well as more exotic ones like `ppc64le` as well as `s390x`.\n\nCheck out the [latest release](https://github.com/oauth2-proxy/oauth2-proxy/releases/latest).\n\n### Images\n\nFrom `v7.6.0` and up the base image has been changed from Alpine to [GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless).\nThis image comes with even fewer installed dependencies and thus should improve security. The image therefore is also slightly smaller than Alpine.\nFor debugging purposes (and those who really need it. e.g. `armv6`) we still provide images based on Alpine. The tags of these images are suffixed with `-alpine`.\n\nSince 2023-11-18 we build nightly images directly from the `master` branch and provide them at `quay.io/oauth2-proxy/oauth2-proxy-nightly`.\nThese images are considered unstable and therefore should **NOT** be used for production purposes unless you know what you're doing.\n\n## Sponsors\n\n![Microsoft](https://upload.wikimedia.org/wikipedia/commons/9/96/Microsoft_logo_%282012%29.svg)\nMicrosoft Azure credits for open source projects\n\nWould you like to sponsor the project then please contact us at [sponsors@oauth2-proxy.dev](mailto:sponsors@oauth2-proxy.dev)\n\n## Getting Involved\n[![Slack](https://img.shields.io/badge/slack-Gopher_%23oauth2--proxy-red?logo=slack)](https://gophers.slack.com/archives/CM2RSS25N)\n\nJoin the #oauth2-proxy [Slack channel](https://gophers.slack.com/archives/CM2RSS25N) to chat with other users of oauth2-proxy or reach out to the maintainers directly. Use the [public invite link](https://invite.slack.golangbridge.org/) to get an invite for the Gopher Slack space.\n\nOAuth2-Proxy is a community-driven project. We rely on the contributÔ∏èions of our users to continually improve it. While review times can vary, we appreciate your patience and understanding. As a volunteer-driven project, we strive to keep this project stable and might take longer to merge changes.\n\nIf you want to contribute to the project. Please see our [Contributing](https://oauth2-proxy.github.io/oauth2-proxy/community/contribution) guide.\n\nWho uses OAuth2-Proxy? Have a look at our new [ADOPTERS](ADOPTERS.md) file and\nfeel free to open a PR to add your organisation.\n\nThanks to all the people who already contributed ‚ù§\n\n<a href=\"https://github.com/oauth2-proxy/oauth2-proxy/graphs/contributors\">\n  <img src=\"https://contrib.rocks/image?repo=oauth2-proxy/oauth2-proxy&columns=15&max=75\" />\n  <img src=\"https://img.shields.io/github/contributors/oauth2-proxy/oauth2-proxy\" />\n</a>\n\nMade with [contrib.rocks](https://contrib.rocks).\n\n## Security\n\nIf you believe you have found a vulnerability within OAuth2 Proxy or any of its dependencies, please do **NOT** open an issue or PR on GitHub, please do **NOT** post any details publicly.\n\nSecurity disclosures **MUST** be done in private. If you have found an issue that you would like to bring to the attention of the maintainers, please compose an email and send it to the list of people listed in our [MAINTAINERS](MAINTAINERS) file.\n\nFor more details read our full [Security Docs](https://oauth2-proxy.github.io/oauth2-proxy/community/security#security-disclosures)\n\n### Security Notice for v6.0.0 and older\n\nIf you are running a version older than v6.0.0 we **strongly recommend** to the current version.\n\nSee [open redirect vulnerability](https://github.com/oauth2-proxy/oauth2-proxy/security/advisories/GHSA-5m6c-jp6f-2vcv) for details.\n\n## Repository History\n\n**2018-11-27:** This repository was forked from [bitly/OAuth2_Proxy](https://github.com/bitly/oauth2_proxy). Versions v3.0.0 and up are from this fork and will have diverged from any changes in the original fork. A list of changes can be seen in the [CHANGELOG](CHANGELOG.md).\n\n**2020-03-29:** This project was formerly hosted as `pusher/oauth2_proxy` but has been renamed to `oauth2-proxy/oauth2-proxy`. Going forward, all images shall be available at `quay.io/oauth2-proxy/oauth2-proxy` and binaries will be named `oauth2-proxy`.\n\n## License\n\nOAuth2-Proxy is distributed under [The MIT License](LICENSE).\n"
        },
        {
          "name": "RELEASE.md",
          "type": "blob",
          "size": 1.7412109375,
          "content": "# Release\n\nThe is a legacy document to explain the manual process of creating and publishing a new release of oauth2-proxy. As of now the release process has been automated with GitHub Actions workflows. For more information have a look at the workflows `create-release.yml` and `publish-release.yml`.\n\nHere's how OAuth2 Proxy releases are created.\n\n## Schedule\n\nOur aim is to release once a quarter, but bug fixes will be prioritised and might be released earlier.\n\n## The Process\n\nNote this uses `v4.1.0` as an example release number.\n\n1. Create a draft Github release\n  * Use format `v4.1.0` for both the tag and title\n2. Update [CHANGELOG.md](CHANGELOG.md)\n  * Write the release highlights\n  * Copy in headings ready for the next release\n3. Create release commit\n  ```\n  git checkout -b release-v4.1.0\n  ```\n4. Create pull request getting other maintainers to review\n5. Copy the release notes in to the draft Github release, adding a link to [CHANGELOG.md](CHANGELOG.md)\n6. Update you local master branch\n  ```\n  git checkout master\n  git pull\n  ```\n7. Create & push the tag\n  ```\n  git tag v4.1.0\n  git push --tags\n  ```\n8. Make the release artefacts\n  ```\n  make release\n  ```\n9. Upload all the files (not the folders) from the `/release` folder to Github release as binary artefacts. There should be both the tarballs (`tar.gz`) and the checksum files (`sha256sum.txt`).\n10. Publish release in Github\n11. Make and push docker images to Quay\n  ```\n  make docker-all\n  make docker-push-all\n  ```\n  Note: Ensure the docker tags don't include `-dirty`. This means you have uncommitted changes.\n\n12. Verify everything looks good at [quay](https://quay.io/repository/oauth2-proxy/oauth2-proxy?tag=latest&tab=tags) and [github](https://github.com/oauth2-proxy/oauth2-proxy/releases)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.1416015625,
          "content": "# Security Disclosures\n\nPlease see [our community docs](https://oauth2-proxy.github.io/oauth2-proxy/community/security) for our security policy.\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "dist.sh",
          "type": "blob",
          "size": 1.5732421875,
          "content": "#!/usr/bin/env bash\n\nset -o errexit\n\nif [[ -z ${BINARY} ]] || [[ -z ${VERSION} ]]; then\n\techo \"Missing required env var: BINARY=X VERSION=X $(basename $0)\"\n\texit 1\nfi\n\nARCHS=(\n  darwin-amd64\n  darwin-arm64\n  linux-amd64\n  linux-arm64\n  linux-armv5\n  linux-armv6\n  linux-armv7\n  linux-ppc64le\n  linux-s390x\n  freebsd-amd64\n  windows-amd64\n)\n\nmkdir -p release\n\n# Create architecture specific release dirs\nfor ARCH in \"${ARCHS[@]}\"; do\n\tmkdir -p release/${BINARY}-${VERSION}.${ARCH}\n\n\tGO_OS=$(echo $ARCH | awk -F- '{print $1}')\n\tGO_ARCH=$(echo $ARCH | awk -F- '{print $2}')\n\n\t# Create architecture specific binaries\n\tif [[ ${GO_ARCH} == armv* ]]; then\n\t  GO_ARM=$(echo $GO_ARCH | awk -Fv '{print $2}')\n\t\tGO111MODULE=on GOOS=${GO_OS} GOARCH=arm GOARM=${GO_ARM} CGO_ENABLED=0 go build \\\n\t\t\t-ldflags=\"-X github.com/oauth2-proxy/oauth2-proxy/v7/pkg/version.VERSION=${VERSION}\" \\\n\t\t\t-o release/${BINARY}-${VERSION}.${ARCH}/${BINARY} .\n\telse\n\t\tGO111MODULE=on GOOS=${GO_OS} GOARCH=${GO_ARCH} CGO_ENABLED=0 go build \\\n\t\t\t-ldflags=\"-X github.com/oauth2-proxy/oauth2-proxy/v7/pkg/version.VERSION=${VERSION}\" \\\n\t\t\t-o release/${BINARY}-${VERSION}.${ARCH}/${BINARY} .\n\tfi\n\n\tcd release\n\n\t# Create tar file for architecture specific binary\n\ttar -czvf ${BINARY}-${VERSION}.${ARCH}.tar.gz ${BINARY}-${VERSION}.${ARCH}\n\n\t# Create sha256sum for architecture-specific tar\n\tsha256sum ${BINARY}-${VERSION}.${ARCH}.tar.gz > ${BINARY}-${VERSION}.${ARCH}.tar.gz-sha256sum.txt\n\n\t# Create sha256sum for architecture specific binary\n  sha256sum ${BINARY}-${VERSION}.${ARCH}/${BINARY} > ${BINARY}-${VERSION}.${ARCH}-sha256sum.txt\n\n\tcd ..\ndone\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 4.4619140625,
          "content": "module github.com/oauth2-proxy/oauth2-proxy/v7\n\ngo 1.22.7\n\nrequire (\n\tcloud.google.com/go/compute/metadata v0.5.2\n\tgithub.com/Bose/minisentinel v0.0.0-20200130220412-917c5a9223bb\n\tgithub.com/a8m/envsubst v1.4.2\n\tgithub.com/alicebob/miniredis/v2 v2.33.0\n\tgithub.com/benbjohnson/clock v1.3.5\n\tgithub.com/bitly/go-simplejson v0.5.1\n\tgithub.com/bsm/redislock v0.9.4\n\tgithub.com/coreos/go-oidc/v3 v3.11.0\n\tgithub.com/coreos/go-systemd v0.0.0-20191104093116-d3cd4ed1dbcf\n\tgithub.com/fsnotify/fsnotify v1.8.0\n\tgithub.com/ghodss/yaml v1.0.1-0.20220118164431-d8423dcdf344\n\tgithub.com/go-jose/go-jose/v3 v3.0.3\n\tgithub.com/go-jose/go-jose/v4 v4.0.4\n\tgithub.com/golang-jwt/jwt/v5 v5.2.1\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/google/uuid v1.6.0\n\tgithub.com/gorilla/mux v1.8.1\n\tgithub.com/justinas/alice v1.2.0\n\tgithub.com/mbland/hmacauth v0.0.0-20170912233209-44256dfd4bfa\n\tgithub.com/mitchellh/mapstructure v1.5.0\n\tgithub.com/oauth2-proxy/mockoidc v0.0.0-20240214162133-caebfff84d25\n\tgithub.com/oauth2-proxy/tools/reference-gen v0.0.0-20220223111546-d3b50d1a591a\n\tgithub.com/ohler55/ojg v1.25.0\n\tgithub.com/onsi/ginkgo/v2 v2.21.0\n\tgithub.com/onsi/gomega v1.35.1\n\tgithub.com/pierrec/lz4/v4 v4.1.21\n\tgithub.com/prometheus/client_golang v1.20.5\n\tgithub.com/redis/go-redis/v9 v9.7.0\n\tgithub.com/spf13/cast v1.7.0\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/spf13/viper v1.19.0\n\tgithub.com/stretchr/testify v1.9.0\n\tgithub.com/vmihailenco/msgpack/v5 v5.4.1\n\tgolang.org/x/crypto v0.31.0\n\tgolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f\n\tgolang.org/x/net v0.33.0\n\tgolang.org/x/oauth2 v0.24.0\n\tgolang.org/x/sync v0.10.0\n\tgoogle.golang.org/api v0.205.0\n\tgopkg.in/natefinch/lumberjack.v2 v2.2.1\n\tk8s.io/apimachinery v0.31.2\n)\n\nrequire (\n\tcloud.google.com/go/auth v0.10.1 // indirect\n\tcloud.google.com/go/auth/oauth2adapt v0.2.5 // indirect\n\tgithub.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302 // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc // indirect\n\tgithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect\n\tgithub.com/felixge/httpsnoop v1.0.4 // indirect\n\tgithub.com/go-logr/logr v1.4.2 // indirect\n\tgithub.com/go-logr/stdr v1.2.2 // indirect\n\tgithub.com/go-task/slim-sprig/v3 v3.0.0 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/google/pprof v0.0.0-20241029153458-d1b30febd7db // indirect\n\tgithub.com/google/s2a-go v0.1.8 // indirect\n\tgithub.com/googleapis/enterprise-certificate-proxy v0.3.4 // indirect\n\tgithub.com/googleapis/gax-go/v2 v2.13.0 // indirect\n\tgithub.com/hashicorp/hcl v1.0.0 // indirect\n\tgithub.com/klauspost/compress v1.17.10 // indirect\n\tgithub.com/kylelemons/godebug v1.1.0 // indirect\n\tgithub.com/magiconair/properties v1.8.7 // indirect\n\tgithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect\n\tgithub.com/nxadm/tail v1.4.11 // indirect\n\tgithub.com/onsi/ginkgo v1.16.5 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.2.3 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.59.1 // indirect\n\tgithub.com/prometheus/procfs v0.15.1 // indirect\n\tgithub.com/sagikazarmark/locafero v0.6.0 // indirect\n\tgithub.com/sagikazarmark/slog-shim v0.1.0 // indirect\n\tgithub.com/sourcegraph/conc v0.3.0 // indirect\n\tgithub.com/spf13/afero v1.11.0 // indirect\n\tgithub.com/subosito/gotenv v1.6.0 // indirect\n\tgithub.com/vmihailenco/tagparser/v2 v2.0.0 // indirect\n\tgithub.com/yuin/gopher-lua v1.1.1 // indirect\n\tgo.opencensus.io v0.24.0 // indirect\n\tgo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.55.0 // indirect\n\tgo.opentelemetry.io/otel v1.30.0 // indirect\n\tgo.opentelemetry.io/otel/metric v1.30.0 // indirect\n\tgo.opentelemetry.io/otel/trace v1.30.0 // indirect\n\tgo.uber.org/multierr v1.11.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/tools v0.27.0 // indirect\n\tgoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241021214115-324edc3d5d38 // indirect\n\tgoogle.golang.org/grpc v1.67.1 // indirect\n\tgoogle.golang.org/protobuf v1.35.1 // indirect\n\tgopkg.in/ini.v1 v1.67.0 // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n\tk8s.io/gengo v0.0.0-20240404160639-a0386bf69313 // indirect\n\tk8s.io/klog/v2 v2.130.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 43.3408203125,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go/auth v0.9.4 h1:DxF7imbEbiFu9+zdKC6cKBko1e8XeJnipNqIbWZ+kDI=\ncloud.google.com/go/auth v0.9.4/go.mod h1:SHia8n6//Ya940F1rLimhJCjjx7KE17t0ctFEci3HkA=\ncloud.google.com/go/auth v0.10.0 h1:tWlkvFAh+wwTOzXIjrwM64karR1iTBZ/GRr0S/DULYo=\ncloud.google.com/go/auth v0.10.0/go.mod h1:xxA5AqpDrvS+Gkmo9RqrGGRh6WSNKKOXhY3zNOr38tI=\ncloud.google.com/go/auth v0.10.1 h1:TnK46qldSfHWt2a0b/hciaiVJsmDXWy9FqyUan0uYiI=\ncloud.google.com/go/auth v0.10.1/go.mod h1:xxA5AqpDrvS+Gkmo9RqrGGRh6WSNKKOXhY3zNOr38tI=\ncloud.google.com/go/auth/oauth2adapt v0.2.4 h1:0GWE/FUsXhf6C+jAkWgYm7X9tK8cuEIfy19DBn6B6bY=\ncloud.google.com/go/auth/oauth2adapt v0.2.4/go.mod h1:jC/jOpwFP6JBxhB3P5Rr0a9HLMC/Pe3eaL4NmdvqPtc=\ncloud.google.com/go/auth/oauth2adapt v0.2.5 h1:2p29+dePqsCHPP1bqDJcKj4qxRyYCcbzKpFyKGt3MTk=\ncloud.google.com/go/auth/oauth2adapt v0.2.5/go.mod h1:AlmsELtlEBnaNTL7jCj8VQFLy6mbZv0s4Q7NGBeQ5E8=\ncloud.google.com/go/compute/metadata v0.5.2 h1:UxK4uu/Tn+I3p2dYWTfiX4wva7aYlKixAHn3fyqngqo=\ncloud.google.com/go/compute/metadata v0.5.2/go.mod h1:C66sj2AluDcIqakBq/M8lw8/ybHgOZqin2obFxa/E5k=\ngithub.com/Bose/minisentinel v0.0.0-20200130220412-917c5a9223bb h1:ZVN4Iat3runWOFLaBCDVU5a9X/XikSRBosye++6gojw=\ngithub.com/Bose/minisentinel v0.0.0-20200130220412-917c5a9223bb/go.mod h1:WsAABbY4HQBgd3mGuG4KMNTbHJCPvx9IVBHzysbknss=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/FZambia/sentinel v1.0.0 h1:KJ0ryjKTZk5WMp0dXvSdNqp3lFaW1fNFuEYfrkLOYIc=\ngithub.com/FZambia/sentinel v1.0.0/go.mod h1:ytL1Am/RLlAoAXG6Kj5LNuw/TRRQrv2rt2FT26vP5gI=\ngithub.com/a8m/envsubst v1.4.2 h1:4yWIHXOLEJHQEFd4UjrWDrYeYlV7ncFWJOCBRLOZHQg=\ngithub.com/a8m/envsubst v1.4.2/go.mod h1:MVUTQNGQ3tsjOOtKCNd+fl8RzhsXcDvvAEzkhGtlsbY=\ngithub.com/alicebob/gopher-json v0.0.0-20180125190556-5a6b3ba71ee6/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\ngithub.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302 h1:uvdUDbHQHO85qeSydJtItA4T55Pw6BtAejd0APRJOCE=\ngithub.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\ngithub.com/alicebob/miniredis/v2 v2.11.1/go.mod h1:UA48pmi7aSazcGAvcdKcBB49z521IC9VjTTRz2nIaJE=\ngithub.com/alicebob/miniredis/v2 v2.33.0 h1:uvTF0EDeu9RLnUEG27Db5I68ESoIxTiXbNUiji6lZrA=\ngithub.com/alicebob/miniredis/v2 v2.33.0/go.mod h1:MhP4a3EU7aENRi9aO+tHfTBZicLqQevyi/DJpoj6mi0=\ngithub.com/benbjohnson/clock v1.3.5 h1:VvXlSJBzZpA/zum6Sj74hxwYI2DIxRWuNIoXAzHZz5o=\ngithub.com/benbjohnson/clock v1.3.5/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bitly/go-simplejson v0.5.1 h1:xgwPbetQScXt1gh9BmoJ6j9JMr3TElvuIyjR8pgdoow=\ngithub.com/bitly/go-simplejson v0.5.1/go.mod h1:YOPVLzCfwK14b4Sff3oP1AmGhI9T9Vsg84etUnlyp+Q=\ngithub.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869 h1:DDGfHa7BWjL4YnC6+E63dPcxHo2sUxDIu8g3QgEJdRY=\ngithub.com/bmizerany/assert v0.0.0-20160611221934-b7ed37b82869/go.mod h1:Ekp36dRnpXw/yCqJaO+ZrUyxD+3VXMFFr56k5XYrpB4=\ngithub.com/bsm/ginkgo/v2 v2.12.0 h1:Ny8MWAHyOepLGlLKYmXG4IEkioBysk6GpaRTLC8zwWs=\ngithub.com/bsm/ginkgo/v2 v2.12.0/go.mod h1:SwYbGRRDovPVboqFv0tPTcG1sN61LM1Z4ARdbAV9g4c=\ngithub.com/bsm/gomega v1.27.10 h1:yeMWxP2pV2fG3FgAODIY8EiRE3dy0aeFYt4l7wh6yKA=\ngithub.com/bsm/gomega v1.27.10/go.mod h1:JyEr/xRbxbtgWNi8tIEVPUYZ5Dzef52k01W3YH0H+O0=\ngithub.com/bsm/redislock v0.9.4 h1:X/Wse1DPpiQgHbVYRE9zv6m070UcKoOGekgvpNhiSvw=\ngithub.com/bsm/redislock v0.9.4/go.mod h1:Epf7AJLiSFwLCiZcfi6pWFO/8eAYrYpQXFxEDPoDeAk=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/coreos/go-oidc/v3 v3.11.0 h1:Ia3MxdwpSw702YW0xgfmP1GVCMA9aEFWu12XUZ3/OtI=\ngithub.com/coreos/go-oidc/v3 v3.11.0/go.mod h1:gE3LgjOgFoHi9a4ce4/tJczr0Ai2/BoDhf0r5lltWI0=\ngithub.com/coreos/go-systemd v0.0.0-20191104093116-d3cd4ed1dbcf h1:iW4rZ826su+pqaw19uhpSCzhj44qo35pNgKFGqzDKkU=\ngithub.com/coreos/go-systemd v0.0.0-20191104093116-d3cd4ed1dbcf/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=\ngithub.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=\ngithub.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=\ngithub.com/fsnotify/fsnotify v1.6.0/go.mod h1:sl3t1tCWJFWoRz9R8WJCbQihKKwmorjAbSClcnxKAGw=\ngithub.com/fsnotify/fsnotify v1.7.0 h1:8JEhPFa5W2WU7YfeZzPNqzMP6Lwt7L2715Ggo0nosvA=\ngithub.com/fsnotify/fsnotify v1.7.0/go.mod h1:40Bi/Hjc2AVfZrqy+aj+yEI+/bRxZnMJyTJwOpGvigM=\ngithub.com/fsnotify/fsnotify v1.8.0 h1:dAwr6QBTBZIkG8roQaJjGof0pp0EeF+tNV7YBP3F/8M=\ngithub.com/fsnotify/fsnotify v1.8.0/go.mod h1:8jBTzvmWwFyi3Pb8djgCCO5IBqzKJ/Jwo8TRcHyHii0=\ngithub.com/ghodss/yaml v1.0.1-0.20220118164431-d8423dcdf344 h1:Arcl6UOIS/kgO2nW3A65HN+7CMjSDP/gofXL4CZt1V4=\ngithub.com/ghodss/yaml v1.0.1-0.20220118164431-d8423dcdf344/go.mod h1:GIjDIg/heH5DOkXY3YJ/wNhfHsQHoXGjl8G8amsYQ1I=\ngithub.com/go-git/go-git/v5 v5.4.2 h1:BXyZu9t0VkbiHtqrsvdq39UDhGJTl1h55VW6CSC4aY4=\ngithub.com/go-git/go-git/v5 v5.4.2/go.mod h1:gQ1kArt6d+n+BGd+/B/I74HwRTLhth2+zti4ihgckDc=\ngithub.com/go-jose/go-jose/v3 v3.0.1 h1:pWmKFVtt+Jl0vBZTIpz/eAKwsm6LkIxDVVbFHKkchhA=\ngithub.com/go-jose/go-jose/v3 v3.0.1/go.mod h1:RNkWWRld676jZEYoV3+XK8L2ZnNSvIsxFMht0mSX+u8=\ngithub.com/go-jose/go-jose/v3 v3.0.3 h1:fFKWeig/irsp7XD2zBxvnmA/XaRWp5V3CBsZXJF7G7k=\ngithub.com/go-jose/go-jose/v3 v3.0.3/go.mod h1:5b+7YgP7ZICgJDBdfjZaIt+H/9L9T/YQrVfLAMboGkQ=\ngithub.com/go-jose/go-jose/v4 v4.0.4 h1:VsjPI33J0SB9vQM6PLmNjoHqMQNGPiZ0rHL7Ni7Q6/E=\ngithub.com/go-jose/go-jose/v4 v4.0.4/go.mod h1:NKb5HO1EZccyMpiZNbdUw/14tiXNyUJh188dfnMCAfc=\ngithub.com/go-logr/logr v0.2.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.4.2 h1:6pFjapn8bFcIbiKo3XT4j/BhANplGihG6tvd+8rYgrY=\ngithub.com/go-logr/logr v1.4.2/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=\ngithub.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=\ngithub.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=\ngithub.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/golang-jwt/jwt/v5 v5.2.1 h1:OuVbFODueb089Lh128TAcimifWaLhJwVflnrgM17wHk=\ngithub.com/golang-jwt/jwt/v5 v5.2.1/go.mod h1:pqrtFR0X4osieyHYxtmOUWsAWrfe1Q5UVIyoH402zdk=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/gomodule/redigo v1.7.1-0.20190322064113-39e2c31b7ca3 h1:6amM4HsNPOvMLVc2ZnyqrjeQ92YAVWn7T4WBKK87inY=\ngithub.com/gomodule/redigo v1.7.1-0.20190322064113-39e2c31b7ca3/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/gofuzz v1.1.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/pprof v0.0.0-20240910150728-a0b0bb1d4134 h1:c5FlPPgxOn7kJz3VoPLkQYQXGBS3EklQ4Zfi57uOuqQ=\ngithub.com/google/pprof v0.0.0-20240910150728-a0b0bb1d4134/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/google/pprof v0.0.0-20241029153458-d1b30febd7db h1:097atOisP2aRj7vFgYQBbFN4U4JNXUNYpxael3UzMyo=\ngithub.com/google/pprof v0.0.0-20241029153458-d1b30febd7db/go.mod h1:vavhavw2zAxS5dIdcRluK6cSGGPlZynqzFM8NdvU144=\ngithub.com/google/s2a-go v0.1.8 h1:zZDs9gcbt9ZPLV0ndSyQk6Kacx2g/X+SKYovpnz3SMM=\ngithub.com/google/s2a-go v0.1.8/go.mod h1:6iNWHTpQ+nfNRN5E00MSdfDwVesa8hhS32PhPO8deJA=\ngithub.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=\ngithub.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4 h1:XYIDZApgAnrN1c855gTgghdIA6Stxb52D5RnLI1SLyw=\ngithub.com/googleapis/enterprise-certificate-proxy v0.3.4/go.mod h1:YKe7cfqYXjKGpGvmSg28/fFvhNzinZQm8DGnaburhGA=\ngithub.com/googleapis/gax-go/v2 v2.13.0 h1:yitjD5f7jQHhyDsnhKEBU52NdvvdSeGzlAnDPT0hH1s=\ngithub.com/googleapis/gax-go/v2 v2.13.0/go.mod h1:Z/fvTZXF8/uw7Xu5GuslPw+bplx6SS338j1Is2S+B7A=\ngithub.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=\ngithub.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=\ngithub.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/justinas/alice v1.2.0 h1:+MHSA/vccVCF4Uq37S42jwlkvI2Xzl7zTPCN5BnZNVo=\ngithub.com/justinas/alice v1.2.0/go.mod h1:fN5HRH/reO/zrUflLfTN43t3vXvKzvZIENsNEe7i7qA=\ngithub.com/klauspost/compress v1.17.10 h1:oXAz+Vh0PMUvJczoi+flxpnBEPxoER1IaAnU/NMPtT0=\ngithub.com/klauspost/compress v1.17.10/go.mod h1:pMDklpSncoRMuLFrf1W9Ss9KT+0rH90U12bZKk7uwG0=\ngithub.com/kr/pretty v0.2.0/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=\ngithub.com/magiconair/properties v1.8.7/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=\ngithub.com/matryer/is v1.2.0 h1:92UTHpy8CDwaJ08GqLDzhhuixiBUUD1p3AU6PHddz4A=\ngithub.com/matryer/is v1.2.0/go.mod h1:2fLPjFQM9rhQ15aVEtbuwhJinnOqrmgXPNdZsdwlWXA=\ngithub.com/mbland/hmacauth v0.0.0-20170912233209-44256dfd4bfa h1:hI1uC2A3vJFjwvBn0G0a7QBRdBUp6Y048BtLAHRTKPo=\ngithub.com/mbland/hmacauth v0.0.0-20170912233209-44256dfd4bfa/go.mod h1:8vxFeeg++MqgCHwehSuwTlYCF0ALyDJbYJ1JsKi7v6s=\ngithub.com/mitchellh/mapstructure v1.5.0 h1:jeMsZIYE/09sWLaz43PL7Gy6RuMjD2eJVyuac5Z2hdY=\ngithub.com/mitchellh/mapstructure v1.5.0/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\ngithub.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=\ngithub.com/nxadm/tail v1.4.11 h1:8feyoE3OzPrcshW5/MJ4sGESc5cqmGkGCWlco4l0bqY=\ngithub.com/nxadm/tail v1.4.11/go.mod h1:OTaG3NK980DZzxbRq6lEuzgU+mug70nY11sMd4JXXHc=\ngithub.com/oauth2-proxy/mockoidc v0.0.0-20240214162133-caebfff84d25 h1:9bCMuD3TcnjeqjPT2gSlha4asp8NvgcFRYExCaikCxk=\ngithub.com/oauth2-proxy/mockoidc v0.0.0-20240214162133-caebfff84d25/go.mod h1:eDjgYHYDJbPLBLsyZ6qRaugP0mX8vePOhZ5id1fdzJw=\ngithub.com/oauth2-proxy/tools/reference-gen v0.0.0-20220223111546-d3b50d1a591a h1:2RkJiJXdto2/qHaM7mTUKSR8yxImz0zei8LW0bcbav0=\ngithub.com/oauth2-proxy/tools/reference-gen v0.0.0-20220223111546-d3b50d1a591a/go.mod h1:J9TATNVXZX2MAsXx9J35weO47Fp3FQtx+f48AHLFAug=\ngithub.com/ohler55/ojg v1.24.1 h1:PaVLelrNgT5/0ppPaUtey54tOVp245z33fkhL2jljjY=\ngithub.com/ohler55/ojg v1.24.1/go.mod h1:gQhDVpQLqrmnd2eqGAvJtn+NfKoYJbe/A4Sj3/Vro4o=\ngithub.com/ohler55/ojg v1.25.0/go.mod h1:gQhDVpQLqrmnd2eqGAvJtn+NfKoYJbe/A4Sj3/Vro4o=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\ngithub.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=\ngithub.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=\ngithub.com/onsi/ginkgo/v2 v2.20.2 h1:7NVCeyIWROIAheY21RLS+3j2bb52W0W82tkberYytp4=\ngithub.com/onsi/ginkgo/v2 v2.20.2/go.mod h1:K9gyxPIlb+aIvnZ8bd9Ak+YP18w3APlR+5coaZoE2ag=\ngithub.com/onsi/ginkgo/v2 v2.21.0 h1:7rg/4f3rB88pb5obDgNZrNHrQ4e6WpjonchcpuBRnZM=\ngithub.com/onsi/ginkgo/v2 v2.21.0/go.mod h1:7Du3c42kxCUegi0IImZ1wUQzMBVecgIHjR1C+NkhLQo=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.34.2 h1:pNCwDkzrsv7MS9kpaQvVb1aVLahQXyJ/Tv5oAZMI3i8=\ngithub.com/onsi/gomega v1.34.2/go.mod h1:v1xfxRgk0KIsG+QOdm7p8UosrOzPYRo60fd3B/1Dukc=\ngithub.com/onsi/gomega v1.35.1 h1:Cwbd75ZBPxFSuZ6T+rN/WCb/gOc6YgFBXLlZLhC7Ds4=\ngithub.com/onsi/gomega v1.35.1/go.mod h1:PvZbdDc8J6XJEpDK4HCuRBm8a6Fzp9/DmhC9C7yFlog=\ngithub.com/pelletier/go-toml/v2 v2.2.3 h1:YmeHyLY8mFWbdkNWwpr+qIL2bEqT0o95WSdkNHvL12M=\ngithub.com/pelletier/go-toml/v2 v2.2.3/go.mod h1:MfCQTFTvCcUyyvvwm1+G6H/jORL20Xlb6rzQu9GuUkc=\ngithub.com/pierrec/lz4/v4 v4.1.21 h1:yOVMLb6qSIDP67pl/5F7RepeKYu/VmTyEXvuMI5d9mQ=\ngithub.com/pierrec/lz4/v4 v4.1.21/go.mod h1:gZWDp/Ze/IJXGXf23ltt2EXimqmTUXEy0GFuRQyBid4=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v1.20.4 h1:Tgh3Yr67PaOv/uTqloMsCEdeuFTatm5zIq5+qNN23vI=\ngithub.com/prometheus/client_golang v1.20.4/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_golang v1.20.5 h1:cxppBPuYhUnsO6yo/aoRol4L7q7UFfdm+bR9r+8l63Y=\ngithub.com/prometheus/client_golang v1.20.5/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.59.1 h1:LXb1quJHWm1P6wq/U824uxYi4Sg0oGvNeUm1z5dJoX0=\ngithub.com/prometheus/common v0.59.1/go.mod h1:GpWM7dewqmVYcd7SmRaiWVe9SSqjf0UrwnYnpEZNuT0=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/redis/go-redis/v9 v9.6.1 h1:HHDteefn6ZkTtY5fGUE8tj8uy85AHk6zP7CpzIAM0y4=\ngithub.com/redis/go-redis/v9 v9.6.1/go.mod h1:0C0c6ycQsdpVNQpxb1njEQIqkx5UcsM8FJCQLgE9+RA=\ngithub.com/redis/go-redis/v9 v9.7.0 h1:HhLSs+B6O021gwzl+locl0zEDnyNkxMtf/Z3NNBMa9E=\ngithub.com/redis/go-redis/v9 v9.7.0/go.mod h1:f6zhXITC7JUJIlPEiBOTXxJgPLdZcA93GewI7inzyWw=\ngithub.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=\ngithub.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=\ngithub.com/sagikazarmark/locafero v0.6.0 h1:ON7AQg37yzcRPU69mt7gwhFEBwxI6P9T4Qu3N51bwOk=\ngithub.com/sagikazarmark/locafero v0.6.0/go.mod h1:77OmuIc6VTraTXKXIs/uvUxKGUXjE1GbemJYHqdNjX0=\ngithub.com/sagikazarmark/slog-shim v0.1.0 h1:diDBnUNK9N/354PgrxMywXnAwEr1QZcOr6gto+ugjYE=\ngithub.com/sagikazarmark/slog-shim v0.1.0/go.mod h1:SrcSrq8aKtyuqEI1uvTDTK1arOWRIczQRv+GVI1AkeQ=\ngithub.com/sergi/go-diff v1.1.0 h1:we8PVUC3FE2uYfodKH/nBHMSetSfHDR6scGdBi+erh0=\ngithub.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\ngithub.com/sourcegraph/conc v0.3.0 h1:OQTbbt6P72L20UqAkXXuLOj79LfEanQ+YQFNpLA9ySo=\ngithub.com/sourcegraph/conc v0.3.0/go.mod h1:Sdozi7LEKbFPqYX2/J+iBAM6HpqSLTASQIKqDmF7Mt0=\ngithub.com/spf13/afero v1.11.0 h1:WJQKhtpdm3v2IzqG8VMqrr6Rf3UYpEF239Jy9wNepM8=\ngithub.com/spf13/afero v1.11.0/go.mod h1:GH9Y3pIexgf1MTIWtNGyogA5MwRIDXGUr+hbWNoBjkY=\ngithub.com/spf13/cast v1.7.0 h1:ntdiHjuueXFgm5nzDRdOS4yfT43P5Fnud6DH50rz/7w=\ngithub.com/spf13/cast v1.7.0/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/spf13/viper v1.19.0 h1:RWq5SEjt8o25SROyN3z2OrDB9l7RPd3lwTWU8EcEdcI=\ngithub.com/spf13/viper v1.19.0/go.mod h1:GQUN9bilAbhU/jgc1bKs99f/suXKeUMct8Adx5+Ntkg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/subosito/gotenv v1.6.0 h1:9NlTDc1FTs4qu0DDq7AEtTPNw6SVm7uBMsUCUjABIf8=\ngithub.com/subosito/gotenv v1.6.0/go.mod h1:Dk4QP5c2W3ibzajGcXpNraDfq2IrhjMIvMSWPKKo0FU=\ngithub.com/vmihailenco/msgpack/v5 v5.4.1 h1:cQriyiUvjTwOHg8QZaPihLWeRAAVoCpE00IUPn0Bjt8=\ngithub.com/vmihailenco/msgpack/v5 v5.4.1/go.mod h1:GaZTsDaehaPpQVyxrf5mtQlH+pc21PIudVV/E3rRQok=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0 h1:y09buUbR+b5aycVFQs/g70pqKVZNBmxwAhO7/IwNM9g=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0/go.mod h1:Wri+At7QHww0WTrCBeu4J6bNtoV6mEfg5OIWRZA9qds=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngithub.com/yuin/gopher-lua v0.0.0-20190206043414-8bfc7677f583/go.mod h1:gqRgreBUhTSL0GeU64rtZ3Uq3wtjOa/TB2YfrtkCbVQ=\ngithub.com/yuin/gopher-lua v0.0.0-20191213034115-f46add6fdb5c/go.mod h1:gqRgreBUhTSL0GeU64rtZ3Uq3wtjOa/TB2YfrtkCbVQ=\ngithub.com/yuin/gopher-lua v1.1.1 h1:kYKnWBjvbNP4XLT3+bPEwAXJx262OhaHDWDVOPjL46M=\ngithub.com/yuin/gopher-lua v1.1.1/go.mod h1:GBR0iDaNXjAgGg9zfCvksxSRnQx76gclCIb7kdAd1Pw=\ngo.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=\ngo.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0 h1:r6I7RJCN86bpD/FQwedZ0vSixDpwuWREjW9oRMsmqDc=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.54.0/go.mod h1:B9yO6b04uB80CzjedvewuqDhxJxi11s7/GtiGa8bAjI=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.55.0 h1:ZIg3ZT/aQ7AfKqdwp7ECpOK6vHqquXXuyTjIO8ZdmPs=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.55.0/go.mod h1:DQAwmETtZV00skUwgD6+0U89g80NKsJE3DCKeLLPQMI=\ngo.opentelemetry.io/otel v1.30.0 h1:F2t8sK4qf1fAmY9ua4ohFS/K+FUuOPemHUIXHtktrts=\ngo.opentelemetry.io/otel v1.30.0/go.mod h1:tFw4Br9b7fOS+uEao81PJjVMjW/5fvNCbpsDIXqP0pc=\ngo.opentelemetry.io/otel/metric v1.30.0 h1:4xNulvn9gjzo4hjg+wzIKG7iNFEaBMX00Qd4QIZs7+w=\ngo.opentelemetry.io/otel/metric v1.30.0/go.mod h1:aXTfST94tswhWEb+5QjlSqG+cZlmyXy/u8jFpor3WqQ=\ngo.opentelemetry.io/otel/trace v1.30.0 h1:7UBkkYzeg3C7kQX8VAidWh2biiQbtAKjyIML8dQ9wmc=\ngo.opentelemetry.io/otel/trace v1.30.0/go.mod h1:5EyKqTzzmyqB9bwtCCq6pDLktPK6fmGf/Dph+8VI02o=\ngo.uber.org/multierr v1.11.0 h1:blXXJkSxSSfBVBlC76pxqeO+LN3aDfLQo+309xJstO0=\ngo.uber.org/multierr v1.11.0/go.mod h1:20+QtiLqy0Nd6FdQB9TLXag12DsQkrbs3htMFfDN80Y=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190911031432-227b76d455e7/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.27.0 h1:GXm2NjJrPaiv/h1tb2UH8QfgC/hOf/+z0p6PT8o1w7A=\ngolang.org/x/crypto v0.27.0/go.mod h1:1Xngt8kV6Dvbssa53Ziq6Eqn0HqbZi5Z6R0ZpwQzt70=\ngolang.org/x/crypto v0.28.0 h1:GBDwsMXVQi34v5CCYUm2jkJvu4cbtru2U4TN2PSyQnw=\ngolang.org/x/crypto v0.28.0/go.mod h1:rmgy+3RHxRZMyY0jjAJShp2zgEdOqj2AO7U0pYmeQ7U=\ngolang.org/x/crypto v0.29.0 h1:L5SG1JTTXupVV3n6sUqMTeWbjAyfPwoda2DLX8J8FrQ=\ngolang.org/x/crypto v0.29.0/go.mod h1:+F4F4N5hv6v38hfeYwTdx20oUvLLc+QfrE9Ax9HtgRg=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20240909161429-701f63a606c0 h1:e66Fs6Z+fZTbFBAxKfP3PALWBtpfqks2bwGcexMxgtk=\ngolang.org/x/exp v0.0.0-20240909161429-701f63a606c0/go.mod h1:2TbTHSBQa924w8M6Xs1QcRcFwyucIwBGpK1p2f1YFFY=\ngolang.org/x/exp v0.0.0-20241009180824-f66d83c29e7c h1:7dEasQXItcW1xKJ2+gg5VOiBnqWrJc+rq0DPKyvvdbY=\ngolang.org/x/exp v0.0.0-20241009180824-f66d83c29e7c/go.mod h1:NQtJDoLvd6faHhE7m4T/1IY708gDefGGjR/iUW8yQQ8=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f h1:XdNn9LlyWAhLVp6P/i8QYBW+hlyhrhei9uErw2B5GJo=\ngolang.org/x/exp v0.0.0-20241108190413-2d47ceb2692f/go.mod h1:D5SMRVC3C2/4+F/DB1wZsLRnSNimn2Sp/NPsCrsv8ak=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.21.0 h1:vvrHzRwRfVKSiLrG+d4FMl/Qi4ukBCE6kZlTUkDYRT0=\ngolang.org/x/mod v0.21.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.29.0 h1:5ORfpBpCs4HzDYoodCDBbwHzdR5UrLBZ3sOnUJmFoHo=\ngolang.org/x/net v0.29.0/go.mod h1:gLkgy8jTGERgjzMic6DS9+SP0ajcu6Xu3Orq/SpETg0=\ngolang.org/x/net v0.30.0 h1:AcW1SDZMkb8IpzCdQUaIq2sP4sZ4zw+55h6ynffypl4=\ngolang.org/x/net v0.30.0/go.mod h1:2wGyMJ5iFasEhkwi13ChkO/t1ECNC4X4eBKkVFyYFlU=\ngolang.org/x/net v0.31.0 h1:68CPQngjLL0r2AlUKiSxtQFKvzRVbnzLwMUn5SzcLHo=\ngolang.org/x/net v0.31.0/go.mod h1:P4fl1q7dY2hnZFxEk4pPSkDHF+QqjitcnDjUQyMM+pM=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.23.0 h1:PbgcYx2W7i4LvjJWEbf0ngHV6qJYr86PkAV3bXdLEbs=\ngolang.org/x/oauth2 v0.23.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=\ngolang.org/x/oauth2 v0.24.0 h1:KTBBxWqUa0ykRPLtV69rRto9TLXcqYkeswu48x/gvNE=\ngolang.org/x/oauth2 v0.24.0/go.mod h1:XYTD2NtWslqkgxebSiOHnXEap4TF09sJSc7H1sXbhtI=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=\ngolang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.9.0 h1:fEo0HyrW1GIgZdpbhCRO0PkJajUS5H9IFUztCgEo2jQ=\ngolang.org/x/sync v0.9.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190204203706-41f3e6584952/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220908164124-27713097b956/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=\ngolang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=\ngolang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.27.0 h1:wBqf8DvsY9Y/2P8gAfPDEYNuS30J4lPHJxXSb/nJZ+s=\ngolang.org/x/sys v0.27.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.18.0 h1:XvMDiNzPAl0jr17s6W9lcaIhGUfUORdGCNsuLmPG224=\ngolang.org/x/text v0.18.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\ngolang.org/x/text v0.19.0 h1:kTxAhCbGbxhK0IwgSKiMO5awPoDQ0RpfiVYBfK860YM=\ngolang.org/x/text v0.19.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\ngolang.org/x/text v0.20.0 h1:gK/Kv2otX8gz+wn7Rmb3vT96ZwuoxnQlY+HlJVj7Qug=\ngolang.org/x/text v0.20.0/go.mod h1:D4IsuqiFMhST5bX19pQ9ikHC2GsaKyk/oF+pn3ducp4=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.6.0 h1:eTDhh4ZXt5Qf0augr54TN6suAUudPcawVZeIAPU7D4U=\ngolang.org/x/time v0.6.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200505023115-26f46d2f7ef8/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.25.0 h1:oFU9pkj/iJgs+0DT+VMHrx+oBKs/LJMV+Uvg78sl+fE=\ngolang.org/x/tools v0.25.0/go.mod h1:/vtpO8WL1N9cQC3FN5zPqb//fRXskFHbLKk4OW1Q7rg=\ngolang.org/x/tools v0.26.0 h1:v/60pFQmzmT9ExmjDv2gGIfi3OqfKoEP6I5+umXlbnQ=\ngolang.org/x/tools v0.26.0/go.mod h1:TPVVj70c7JJ3WCazhD8OdXcZg/og+b9+tH/KxylGwH0=\ngolang.org/x/tools v0.27.0 h1:qEKojBykQkQ4EynWy4S8Weg69NumxKdn40Fce3uc/8o=\ngolang.org/x/tools v0.27.0/go.mod h1:sUi0ZgbwW9ZPAq26Ekut+weQPR5eIM6GQLQ1Yjm1H0Q=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/api v0.198.0 h1:OOH5fZatk57iN0A7tjJQzt6aPfYQ1JiWkt1yGseazks=\ngoogle.golang.org/api v0.198.0/go.mod h1:/Lblzl3/Xqqk9hw/yS97TImKTUwnf1bv89v7+OagJzc=\ngoogle.golang.org/api v0.204.0 h1:3PjmQQEDkR/ENVZZwIYB4W/KzYtN8OrqnNcHWpeR8E4=\ngoogle.golang.org/api v0.204.0/go.mod h1:69y8QSoKIbL9F94bWgWAq6wGqGwyjBgi2y8rAK8zLag=\ngoogle.golang.org/api v0.205.0 h1:LFaxkAIpDb/GsrWV20dMMo5MR0h8UARTbn24LmD+0Pg=\ngoogle.golang.org/api v0.205.0/go.mod h1:NrK1EMqO8Xk6l6QwRAmrXXg2v6dzukhlOyvkYtnvUuc=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20240903143218-8af14fe29dc1 h1:BulPr26Jqjnd4eYDVe+YvyR7Yc2vJGkO5/0UxD0/jZU=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20240814211410-ddb44dafa142 h1:wKguEg1hsxI2/L3hUYrpo1RVi48K+uTyzKqprwLXsb8=\ngoogle.golang.org/genproto/googleapis/api v0.0.0-20240814211410-ddb44dafa142/go.mod h1:d6be+8HhtEtucleCbxpPW9PA9XwISACu8nvpPqF0BVo=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240924160255-9d4c2d233b61 h1:N9BgCIAUvn/M+p4NJccWPWb3BWh88+zyL0ll9HgbEeM=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20240924160255-9d4c2d233b61/go.mod h1:UqMtugtsSgubUsoxbuAoiCXvqvErP7Gf0so0mK9tHxU=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241021214115-324edc3d5d38 h1:zciRKQ4kBpFgpfC5QQCVtnnNAcLIqweL7plyZRQHVpI=\ngoogle.golang.org/genproto/googleapis/rpc v0.0.0-20241021214115-324edc3d5d38/go.mod h1:GX3210XPVPUjJbTUbvwI8f2IpZDMZuPJWDzDuebbviI=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=\ngoogle.golang.org/grpc v1.67.0 h1:IdH9y6PF5MPSdAntIcpjQ+tXO41pcQsfZV2RxtQgVcw=\ngoogle.golang.org/grpc v1.67.0/go.mod h1:1gLDyUQU7CTLJI90u3nXZ9ekeghjeM7pTDZlqFNg2AA=\ngoogle.golang.org/grpc v1.67.1 h1:zWnc1Vrcno+lHZCOofnIMvycFcc0QRGIzm9dhnDX68E=\ngoogle.golang.org/grpc v1.67.1/go.mod h1:1gLDyUQU7CTLJI90u3nXZ9ekeghjeM7pTDZlqFNg2AA=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=\ngoogle.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=\ngoogle.golang.org/protobuf v1.35.1 h1:m3LfL6/Ca+fqnjnlqQXNpFPABW1UD7mjh8KO2mKFytA=\ngoogle.golang.org/protobuf v1.35.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/ini.v1 v1.67.0 h1:Dgnx+6+nfE+IfzjUEISNeydPJh9AXNNsWbGP9KzCsOA=\ngopkg.in/ini.v1 v1.67.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/natefinch/lumberjack.v2 v2.2.1 h1:bBRl1b0OH9s/DuPhuXpNl+VtCaJXFZ5/uEFST95x9zc=\ngopkg.in/natefinch/lumberjack.v2 v2.2.1/go.mod h1:YD8tP3GAjkrDg1eZH7EGmyESg/lsYskCTPBJVb9jqSc=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nk8s.io/apimachinery v0.31.1 h1:mhcUBbj7KUjaVhyXILglcVjuS4nYXiwC+KKFBgIVy7U=\nk8s.io/apimachinery v0.31.1/go.mod h1:rsPdaZJfTfLsNJSQzNHQvYoTmxhoOEofxtOsF3rtsMo=\nk8s.io/apimachinery v0.31.2 h1:i4vUt2hPK56W6mlT7Ry+AO8eEsyxMD1U44NR22CLTYw=\nk8s.io/apimachinery v0.31.2/go.mod h1:rsPdaZJfTfLsNJSQzNHQvYoTmxhoOEofxtOsF3rtsMo=\nk8s.io/gengo v0.0.0-20240404160639-a0386bf69313 h1:wBIDZID8ju9pwOiLlV22YYKjFGtiNSWgHf5CnKLRUuM=\nk8s.io/gengo v0.0.0-20240404160639-a0386bf69313/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=\nk8s.io/klog/v2 v2.2.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=\nk8s.io/klog/v2 v2.130.1 h1:n9Xl7H1Xvksem4KFG4PYbdQCQxqc/tTUyrgXaOhHSzk=\nk8s.io/klog/v2 v2.130.1/go.mod h1:3Jpz1GvMt720eyJH1ckRHK1EDfpxISzJ7I9OYgaDtPE=\nsigs.k8s.io/yaml v1.2.0/go.mod h1:yfXDCHCao9+ENCvLSE62v9VSji2MKu5jeNfTrofGhJc=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 5.24609375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n\n\t\"github.com/ghodss/yaml\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/validation\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/version\"\n\t\"github.com/spf13/pflag\"\n)\n\nfunc main() {\n\tlogger.SetFlags(logger.Lshortfile)\n\n\tconfigFlagSet := pflag.NewFlagSet(\"oauth2-proxy\", pflag.ContinueOnError)\n\n\t// Because we parse early to determine alpha vs legacy config, we have to\n\t// ignore any unknown flags for now\n\tconfigFlagSet.ParseErrorsWhitelist.UnknownFlags = true\n\n\tconfig := configFlagSet.String(\"config\", \"\", \"path to config file\")\n\talphaConfig := configFlagSet.String(\"alpha-config\", \"\", \"path to alpha config file (use at your own risk - the structure in this config file may change between minor releases)\")\n\tconvertConfig := configFlagSet.Bool(\"convert-config-to-alpha\", false, \"if true, the proxy will load configuration as normal and convert existing configuration to the alpha config structure, and print it to stdout\")\n\tshowVersion := configFlagSet.Bool(\"version\", false, \"print version string\")\n\tconfigFlagSet.Parse(os.Args[1:])\n\n\tif *showVersion {\n\t\tfmt.Printf(\"oauth2-proxy %s (built with %s)\\n\", version.VERSION, runtime.Version())\n\t\treturn\n\t}\n\n\tif *convertConfig && *alphaConfig != \"\" {\n\t\tlogger.Fatal(\"cannot use alpha-config and convert-config-to-alpha together\")\n\t}\n\n\topts, err := loadConfiguration(*config, *alphaConfig, configFlagSet, os.Args[1:])\n\tif err != nil {\n\t\tlogger.Fatalf(\"ERROR: %v\", err)\n\t}\n\n\tif *convertConfig {\n\t\tif err := printConvertedConfig(opts); err != nil {\n\t\t\tlogger.Fatalf(\"ERROR: could not convert config: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\n\tif err = validation.Validate(opts); err != nil {\n\t\tlogger.Fatalf(\"%s\", err)\n\t}\n\n\tvalidator := NewValidator(opts.EmailDomains, opts.AuthenticatedEmailsFile)\n\toauthproxy, err := NewOAuthProxy(opts, validator)\n\tif err != nil {\n\t\tlogger.Fatalf(\"ERROR: Failed to initialise OAuth2 Proxy: %v\", err)\n\t}\n\n\tif err := oauthproxy.Start(); err != nil {\n\t\tlogger.Fatalf(\"ERROR: Failed to start OAuth2 Proxy: %v\", err)\n\t}\n}\n\n// loadConfiguration will load in the user's configuration.\n// It will either load the alpha configuration (if alphaConfig is given)\n// or the legacy configuration.\nfunc loadConfiguration(config, alphaConfig string, extraFlags *pflag.FlagSet, args []string) (*options.Options, error) {\n\tif alphaConfig != \"\" {\n\t\tlogger.Printf(\"WARNING: You are using alpha configuration. The structure in this configuration file may change without notice. You MUST remove conflicting options from your existing configuration.\")\n\t\treturn loadAlphaOptions(config, alphaConfig, extraFlags, args)\n\t}\n\treturn loadLegacyOptions(config, extraFlags, args)\n}\n\n// loadLegacyOptions loads the old toml options using the legacy flagset\n// and legacy options struct.\nfunc loadLegacyOptions(config string, extraFlags *pflag.FlagSet, args []string) (*options.Options, error) {\n\toptionsFlagSet := options.NewLegacyFlagSet()\n\toptionsFlagSet.AddFlagSet(extraFlags)\n\tif err := optionsFlagSet.Parse(args); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse flags: %v\", err)\n\t}\n\n\tlegacyOpts := options.NewLegacyOptions()\n\tif err := options.Load(config, optionsFlagSet, legacyOpts); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load config: %v\", err)\n\t}\n\n\topts, err := legacyOpts.ToOptions()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to convert config: %v\", err)\n\t}\n\n\treturn opts, nil\n}\n\n// loadAlphaOptions loads the old style config excluding options converted to\n// the new alpha format, then merges the alpha options, loaded from YAML,\n// into the core configuration.\nfunc loadAlphaOptions(config, alphaConfig string, extraFlags *pflag.FlagSet, args []string) (*options.Options, error) {\n\topts, err := loadOptions(config, extraFlags, args)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load core options: %v\", err)\n\t}\n\n\talphaOpts := &options.AlphaOptions{}\n\tif err := options.LoadYAML(alphaConfig, alphaOpts); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load alpha options: %v\", err)\n\t}\n\n\talphaOpts.MergeInto(opts)\n\treturn opts, nil\n}\n\n// loadOptions loads the configuration using the old style format into the\n// core options.Options struct.\n// This means that none of the options that have been converted to alpha config\n// will be loaded using this method.\nfunc loadOptions(config string, extraFlags *pflag.FlagSet, args []string) (*options.Options, error) {\n\toptionsFlagSet := options.NewFlagSet()\n\toptionsFlagSet.AddFlagSet(extraFlags)\n\tif err := optionsFlagSet.Parse(args); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse flags: %v\", err)\n\t}\n\n\topts := options.NewOptions()\n\tif err := options.Load(config, optionsFlagSet, opts); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load config: %v\", err)\n\t}\n\n\treturn opts, nil\n}\n\n// printConvertedConfig extracts alpha options from the loaded configuration\n// and renders these to stdout in YAML format.\nfunc printConvertedConfig(opts *options.Options) error {\n\talphaConfig := &options.AlphaOptions{}\n\talphaConfig.ExtractFrom(opts)\n\n\tdata, err := yaml.Marshal(alphaConfig)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to marshal config: %v\", err)\n\t}\n\n\tif _, err := os.Stdout.Write(data); err != nil {\n\t\treturn fmt.Errorf(\"unable to write output: %v\", err)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "main_suite_test.go",
          "type": "blob",
          "size": 0.302734375,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc TestMainSuite(t *testing.T) {\n\tlogger.SetOutput(GinkgoWriter)\n\tlogger.SetErrOutput(GinkgoWriter)\n\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Main Suite\")\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 7.4873046875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\t. \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options/testutil\"\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/onsi/gomega/format\"\n\t\"github.com/spf13/pflag\"\n)\n\nvar _ = Describe(\"Configuration Loading Suite\", func() {\n\t// For comparing the full configuration differences of our structs we need to increase the gomega limits\n\tformat.MaxLength = 50000\n\tformat.MaxDepth = 10\n\n\tconst testLegacyConfig = `\nhttp_address=\"127.0.0.1:4180\"\nupstreams=\"http://httpbin\"\nset_basic_auth=\"true\"\nbasic_auth_password=\"super-secret-password\"\nclient_id=\"oauth2-proxy\"\nclient_secret=\"b2F1dGgyLXByb3h5LWNsaWVudC1zZWNyZXQK\"\n`\n\n\tconst testAlphaConfig = `\nupstreamConfig:\n  proxyrawpath: false\n  upstreams:\n  - id: /\n    path: /\n    uri: http://httpbin\n    flushInterval: 1s\n    passHostHeader: true\n    proxyWebSockets: true\n    timeout: 30s\ninjectRequestHeaders:\n- name: Authorization\n  values:\n  - claim: user\n    prefix: \"Basic \"\n    basicAuthPassword:\n      value: c3VwZXItc2VjcmV0LXBhc3N3b3Jk\n- name: X-Forwarded-Groups\n  values:\n  - claim: groups\n- name: X-Forwarded-User\n  values:\n  - claim: user\n- name: X-Forwarded-Email\n  values:\n  - claim: email\n- name: X-Forwarded-Preferred-Username\n  values:\n  - claim: preferred_username\ninjectResponseHeaders:\n- name: Authorization\n  values:\n  - claim: user\n    prefix: \"Basic \"\n    basicAuthPassword:\n      value: c3VwZXItc2VjcmV0LXBhc3N3b3Jk\nserver:\n  bindAddress: \"127.0.0.1:4180\"\nproviders:\n- provider: google\n  ID: google=oauth2-proxy\n  clientSecret: b2F1dGgyLXByb3h5LWNsaWVudC1zZWNyZXQK\n  clientID: oauth2-proxy\n  azureConfig:\n    tenant: common\n  oidcConfig:\n    groupsClaim: groups\n    emailClaim: email\n    userIDClaim: email\n    insecureSkipNonce: true\n    audienceClaims: [aud]\n    extraAudiences: []\n  loginURLParameters:\n  - name: approval_prompt\n    default:\n    - force\n`\n\n\tconst testCoreConfig = `\ncookie_secret=\"OQINaROshtE9TcZkNAm-5Zs2Pv3xaWytBmc5W7sPX7w=\"\nemail_domains=\"example.com\"\ncookie_secure=\"false\"\n\nredirect_url=\"http://localhost:4180/oauth2/callback\"\n`\n\n\tboolPtr := func(b bool) *bool {\n\t\treturn &b\n\t}\n\n\tdurationPtr := func(d time.Duration) *options.Duration {\n\t\tdu := options.Duration(d)\n\t\treturn &du\n\t}\n\n\ttestExpectedOptions := func() *options.Options {\n\t\topts, err := options.NewLegacyOptions().ToOptions()\n\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\topts.Cookie.Secret = \"OQINaROshtE9TcZkNAm-5Zs2Pv3xaWytBmc5W7sPX7w=\"\n\t\topts.EmailDomains = []string{\"example.com\"}\n\t\topts.Cookie.Secure = false\n\t\topts.RawRedirectURL = \"http://localhost:4180/oauth2/callback\"\n\n\t\topts.UpstreamServers = options.UpstreamConfig{\n\t\t\tUpstreams: []options.Upstream{\n\t\t\t\t{\n\t\t\t\t\tID:              \"/\",\n\t\t\t\t\tPath:            \"/\",\n\t\t\t\t\tURI:             \"http://httpbin\",\n\t\t\t\t\tFlushInterval:   durationPtr(options.DefaultUpstreamFlushInterval),\n\t\t\t\t\tPassHostHeader:  boolPtr(true),\n\t\t\t\t\tProxyWebSockets: boolPtr(true),\n\t\t\t\t\tTimeout:         durationPtr(options.DefaultUpstreamTimeout),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\tauthHeader := options.Header{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim:  \"user\",\n\t\t\t\t\t\tPrefix: \"Basic \",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(\"super-secret-password\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\topts.InjectRequestHeaders = append([]options.Header{authHeader}, opts.InjectRequestHeaders...)\n\t\topts.InjectResponseHeaders = append(opts.InjectResponseHeaders, authHeader)\n\n\t\topts.Providers = options.Providers{\n\t\t\toptions.Provider{\n\t\t\t\tID:           \"google=oauth2-proxy\",\n\t\t\t\tType:         \"google\",\n\t\t\t\tClientSecret: \"b2F1dGgyLXByb3h5LWNsaWVudC1zZWNyZXQK\",\n\t\t\t\tClientID:     \"oauth2-proxy\",\n\t\t\t\tAzureConfig: options.AzureOptions{\n\t\t\t\t\tTenant: \"common\",\n\t\t\t\t},\n\t\t\t\tOIDCConfig: options.OIDCOptions{\n\t\t\t\t\tGroupsClaim:       \"groups\",\n\t\t\t\t\tEmailClaim:        \"email\",\n\t\t\t\t\tUserIDClaim:       \"email\",\n\t\t\t\t\tAudienceClaims:    []string{\"aud\"},\n\t\t\t\t\tExtraAudiences:    []string{},\n\t\t\t\t\tInsecureSkipNonce: true,\n\t\t\t\t},\n\t\t\t\tLoginURLParameters: []options.LoginURLParameter{\n\t\t\t\t\t{Name: \"approval_prompt\", Default: []string{\"force\"}},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\treturn opts\n\t}\n\n\ttype loadConfigurationTableInput struct {\n\t\tconfigContent      string\n\t\talphaConfigContent string\n\t\targs               []string\n\t\textraFlags         func() *pflag.FlagSet\n\t\texpectedOptions    func() *options.Options\n\t\texpectedErr        error\n\t}\n\n\tDescribeTable(\"LoadConfiguration\",\n\t\tfunc(in loadConfigurationTableInput) {\n\t\t\tvar configFileName, alphaConfigFileName string\n\n\t\t\tdefer func() {\n\t\t\t\tif configFileName != \"\" {\n\t\t\t\t\tExpect(os.Remove(configFileName)).To(Succeed())\n\t\t\t\t}\n\t\t\t\tif alphaConfigFileName != \"\" {\n\t\t\t\t\tExpect(os.Remove(alphaConfigFileName)).To(Succeed())\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tif in.configContent != \"\" {\n\t\t\t\tBy(\"Writing the config to a temporary file\", func() {\n\t\t\t\t\tfile, err := os.CreateTemp(\"\", \"oauth2-proxy-test-config-XXXX.cfg\")\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tdefer file.Close()\n\n\t\t\t\t\tconfigFileName = file.Name()\n\n\t\t\t\t\t_, err = file.WriteString(in.configContent)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif in.alphaConfigContent != \"\" {\n\t\t\t\tBy(\"Writing the config to a temporary file\", func() {\n\t\t\t\t\tfile, err := os.CreateTemp(\"\", \"oauth2-proxy-test-alpha-config-XXXX.yaml\")\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tdefer file.Close()\n\n\t\t\t\t\talphaConfigFileName = file.Name()\n\n\t\t\t\t\t_, err = file.WriteString(in.alphaConfigContent)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t})\n\t\t\t}\n\n\t\t\textraFlags := pflag.NewFlagSet(\"test-flagset\", pflag.ExitOnError)\n\t\t\tif in.extraFlags != nil {\n\t\t\t\textraFlags = in.extraFlags()\n\t\t\t}\n\n\t\t\topts, err := loadConfiguration(configFileName, alphaConfigFileName, extraFlags, in.args)\n\t\t\tif in.expectedErr != nil {\n\t\t\t\tExpect(err).To(MatchError(in.expectedErr.Error()))\n\t\t\t} else {\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t}\n\t\t\tExpect(in.expectedOptions).ToNot(BeNil())\n\t\t\tExpect(opts).To(EqualOpts(in.expectedOptions()))\n\t\t},\n\t\tEntry(\"with legacy configuration\", loadConfigurationTableInput{\n\t\t\tconfigContent:   testCoreConfig + testLegacyConfig,\n\t\t\texpectedOptions: testExpectedOptions,\n\t\t}),\n\t\tEntry(\"with alpha configuration\", loadConfigurationTableInput{\n\t\t\tconfigContent:      testCoreConfig,\n\t\t\talphaConfigContent: testAlphaConfig,\n\t\t\texpectedOptions:    testExpectedOptions,\n\t\t}),\n\t\tEntry(\"with bad legacy configuration\", loadConfigurationTableInput{\n\t\t\tconfigContent:   testCoreConfig + \"unknown_field=\\\"something\\\"\",\n\t\t\texpectedOptions: func() *options.Options { return nil },\n\t\t\texpectedErr:     errors.New(\"failed to load config: error unmarshalling config: 1 error(s) decoding:\\n\\n* '' has invalid keys: unknown_field\"),\n\t\t}),\n\t\tEntry(\"with bad alpha configuration\", loadConfigurationTableInput{\n\t\t\tconfigContent:      testCoreConfig,\n\t\t\talphaConfigContent: testAlphaConfig + \":\",\n\t\t\texpectedOptions:    func() *options.Options { return nil },\n\t\t\texpectedErr:        fmt.Errorf(\"failed to load alpha options: error unmarshalling config: error converting YAML to JSON: yaml: line %d: did not find expected key\", strings.Count(testAlphaConfig, \"\\n\")),\n\t\t}),\n\t\tEntry(\"with alpha configuration and bad core configuration\", loadConfigurationTableInput{\n\t\t\tconfigContent:      testCoreConfig + \"unknown_field=\\\"something\\\"\",\n\t\t\talphaConfigContent: testAlphaConfig,\n\t\t\texpectedOptions:    func() *options.Options { return nil },\n\t\t\texpectedErr:        errors.New(\"failed to load core options: failed to load config: error unmarshalling config: 1 error(s) decoding:\\n\\n* '' has invalid keys: unknown_field\"),\n\t\t}),\n\t)\n})\n"
        },
        {
          "name": "oauthproxy.go",
          "type": "blob",
          "size": 42.3896484375,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"embed\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/justinas/alice\"\n\tipapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/ip\"\n\tmiddlewareapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/middleware\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\tsessionsapi \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/app/pagewriter\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/app/redirect\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/authentication/basic\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/cookies\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/encryption\"\n\tproxyhttp \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/http\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/util\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/version\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/ip\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/middleware\"\n\trequestutil \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/requests/util\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/upstream\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/providers\"\n)\n\nconst (\n\tschemeHTTP      = \"http\"\n\tschemeHTTPS     = \"https\"\n\tapplicationJSON = \"application/json\"\n\n\trobotsPath        = \"/robots.txt\"\n\tsignInPath        = \"/sign_in\"\n\tsignOutPath       = \"/sign_out\"\n\toauthStartPath    = \"/start\"\n\toauthCallbackPath = \"/callback\"\n\tauthOnlyPath      = \"/auth\"\n\tuserInfoPath      = \"/userinfo\"\n\tstaticPathPrefix  = \"/static/\"\n)\n\nvar (\n\t// ErrNeedsLogin means the user should be redirected to the login page\n\tErrNeedsLogin = errors.New(\"redirect to login page\")\n\n\t// ErrAccessDenied means the user should receive a 401 Unauthorized response\n\tErrAccessDenied = errors.New(\"access denied\")\n\n\t//go:embed static/*\n\tstaticFiles embed.FS\n)\n\n// allowedRoute manages method + path based allowlists\ntype allowedRoute struct {\n\tmethod    string\n\tnegate    bool\n\tpathRegex *regexp.Regexp\n}\n\ntype apiRoute struct {\n\tpathRegex *regexp.Regexp\n}\n\n// OAuthProxy is the main authentication proxy\ntype OAuthProxy struct {\n\tCookieOptions *options.Cookie\n\tValidator     func(string) bool\n\n\tSignInPath string\n\n\tallowedRoutes        []allowedRoute\n\tapiRoutes            []apiRoute\n\tredirectURL          *url.URL // the url to receive requests at\n\trelativeRedirectURL  bool\n\twhitelistDomains     []string\n\tprovider             providers.Provider\n\tsessionStore         sessionsapi.SessionStore\n\tProxyPrefix          string\n\tbasicAuthValidator   basic.Validator\n\tbasicAuthGroups      []string\n\tSkipProviderButton   bool\n\tskipAuthPreflight    bool\n\tskipJwtBearerTokens  bool\n\tforceJSONErrors      bool\n\tallowQuerySemicolons bool\n\trealClientIPParser   ipapi.RealClientIPParser\n\ttrustedIPs           *ip.NetSet\n\n\tsessionChain      alice.Chain\n\theadersChain      alice.Chain\n\tpreAuthChain      alice.Chain\n\tpageWriter        pagewriter.Writer\n\tserver            proxyhttp.Server\n\tupstreamProxy     http.Handler\n\tserveMux          *mux.Router\n\tredirectValidator redirect.Validator\n\tappDirector       redirect.AppDirector\n\n\tencodeState bool\n}\n\n// NewOAuthProxy creates a new instance of OAuthProxy from the options provided\nfunc NewOAuthProxy(opts *options.Options, validator func(string) bool) (*OAuthProxy, error) {\n\tsessionStore, err := sessions.NewSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising session store: %v\", err)\n\t}\n\n\tvar basicAuthValidator basic.Validator\n\tif opts.HtpasswdFile != \"\" {\n\t\tlogger.Printf(\"using htpasswd file: %s\", opts.HtpasswdFile)\n\t\tvar err error\n\t\tbasicAuthValidator, err = basic.NewHTPasswdValidator(opts.HtpasswdFile)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not validate htpasswd: %v\", err)\n\t\t}\n\t}\n\n\tprovider, err := providers.NewProvider(opts.Providers[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising provider: %v\", err)\n\t}\n\n\tpageWriter, err := pagewriter.NewWriter(pagewriter.Opts{\n\t\tTemplatesPath:    opts.Templates.Path,\n\t\tCustomLogo:       opts.Templates.CustomLogo,\n\t\tProxyPrefix:      opts.ProxyPrefix,\n\t\tFooter:           opts.Templates.Footer,\n\t\tVersion:          version.VERSION,\n\t\tDebug:            opts.Templates.Debug,\n\t\tProviderName:     buildProviderName(provider, opts.Providers[0].Name),\n\t\tSignInMessage:    buildSignInMessage(opts),\n\t\tDisplayLoginForm: basicAuthValidator != nil && opts.Templates.DisplayLoginForm,\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising page writer: %v\", err)\n\t}\n\n\tupstreamProxy, err := upstream.NewProxy(opts.UpstreamServers, opts.GetSignatureData(), pageWriter)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error initialising upstream proxy: %v\", err)\n\t}\n\n\tif opts.SkipJwtBearerTokens {\n\t\tlogger.Printf(\"Skipping JWT tokens from configured OIDC issuer: %q\", opts.Providers[0].OIDCConfig.IssuerURL)\n\t\tfor _, issuer := range opts.ExtraJwtIssuers {\n\t\t\tlogger.Printf(\"Skipping JWT tokens from extra JWT issuer: %q\", issuer)\n\t\t}\n\t}\n\tredirectURL := opts.GetRedirectURL()\n\tif redirectURL.Path == \"\" {\n\t\tredirectURL.Path = fmt.Sprintf(\"%s/callback\", opts.ProxyPrefix)\n\t}\n\n\tlogger.Printf(\"OAuthProxy configured for %s Client ID: %s\", provider.Data().ProviderName, opts.Providers[0].ClientID)\n\trefresh := \"disabled\"\n\tif opts.Cookie.Refresh != time.Duration(0) {\n\t\trefresh = fmt.Sprintf(\"after %s\", opts.Cookie.Refresh)\n\t}\n\n\tlogger.Printf(\"Cookie settings: name:%s secure(https):%v httponly:%v expiry:%s domains:%s path:%s samesite:%s refresh:%s\", opts.Cookie.Name, opts.Cookie.Secure, opts.Cookie.HTTPOnly, opts.Cookie.Expire, strings.Join(opts.Cookie.Domains, \",\"), opts.Cookie.Path, opts.Cookie.SameSite, refresh)\n\n\ttrustedIPs := ip.NewNetSet()\n\tfor _, ipStr := range opts.TrustedIPs {\n\t\tif ipNet := ip.ParseIPNet(ipStr); ipNet != nil {\n\t\t\ttrustedIPs.AddIPNet(*ipNet)\n\t\t} else {\n\t\t\treturn nil, fmt.Errorf(\"could not parse IP network (%s)\", ipStr)\n\t\t}\n\t}\n\n\tallowedRoutes, err := buildRoutesAllowlist(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tapiRoutes, err := buildAPIRoutes(opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpreAuthChain, err := buildPreAuthChain(opts, sessionStore)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not build pre-auth chain: %v\", err)\n\t}\n\tsessionChain := buildSessionChain(opts, provider, sessionStore, basicAuthValidator)\n\theadersChain, err := buildHeadersChain(opts)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not build headers chain: %v\", err)\n\t}\n\n\tredirectValidator := redirect.NewValidator(opts.WhitelistDomains)\n\tappDirector := redirect.NewAppDirector(redirect.AppDirectorOpts{\n\t\tProxyPrefix: opts.ProxyPrefix,\n\t\tValidator:   redirectValidator,\n\t})\n\n\tp := &OAuthProxy{\n\t\tCookieOptions: &opts.Cookie,\n\t\tValidator:     validator,\n\n\t\tSignInPath: fmt.Sprintf(\"%s/sign_in\", opts.ProxyPrefix),\n\n\t\tProxyPrefix:          opts.ProxyPrefix,\n\t\tprovider:             provider,\n\t\tsessionStore:         sessionStore,\n\t\tredirectURL:          redirectURL,\n\t\trelativeRedirectURL:  opts.RelativeRedirectURL,\n\t\tapiRoutes:            apiRoutes,\n\t\tallowedRoutes:        allowedRoutes,\n\t\twhitelistDomains:     opts.WhitelistDomains,\n\t\tskipAuthPreflight:    opts.SkipAuthPreflight,\n\t\tskipJwtBearerTokens:  opts.SkipJwtBearerTokens,\n\t\trealClientIPParser:   opts.GetRealClientIPParser(),\n\t\tSkipProviderButton:   opts.SkipProviderButton,\n\t\tforceJSONErrors:      opts.ForceJSONErrors,\n\t\tallowQuerySemicolons: opts.AllowQuerySemicolons,\n\t\ttrustedIPs:           trustedIPs,\n\n\t\tbasicAuthValidator: basicAuthValidator,\n\t\tbasicAuthGroups:    opts.HtpasswdUserGroups,\n\t\tsessionChain:       sessionChain,\n\t\theadersChain:       headersChain,\n\t\tpreAuthChain:       preAuthChain,\n\t\tpageWriter:         pageWriter,\n\t\tupstreamProxy:      upstreamProxy,\n\t\tredirectValidator:  redirectValidator,\n\t\tappDirector:        appDirector,\n\t\tencodeState:        opts.EncodeState,\n\t}\n\tp.buildServeMux(opts.ProxyPrefix)\n\n\tif err := p.setupServer(opts); err != nil {\n\t\treturn nil, fmt.Errorf(\"error setting up server: %v\", err)\n\t}\n\n\treturn p, nil\n}\n\nfunc (p *OAuthProxy) Start() error {\n\tif p.server == nil {\n\t\t// We have to call setupServer before Start is called.\n\t\t// If this doesn't happen it's a programming error.\n\t\tpanic(\"server has not been initialised\")\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\n\t// Observe signals in background goroutine.\n\tgo func() {\n\t\tsigint := make(chan os.Signal, 1)\n\t\tsignal.Notify(sigint, os.Interrupt, syscall.SIGTERM)\n\t\t<-sigint\n\t\tcancel() // cancel the context\n\t}()\n\n\treturn p.server.Start(ctx)\n}\n\nfunc (p *OAuthProxy) setupServer(opts *options.Options) error {\n\tserverOpts := proxyhttp.Opts{\n\t\tHandler:           p,\n\t\tBindAddress:       opts.Server.BindAddress,\n\t\tSecureBindAddress: opts.Server.SecureBindAddress,\n\t\tTLS:               opts.Server.TLS,\n\t}\n\n\t// Option: AllowQuerySemicolons\n\tif opts.AllowQuerySemicolons {\n\t\tserverOpts.Handler = http.AllowQuerySemicolons(serverOpts.Handler)\n\t}\n\n\tappServer, err := proxyhttp.NewServer(serverOpts)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not build app server: %v\", err)\n\t}\n\n\tmetricsServer, err := proxyhttp.NewServer(proxyhttp.Opts{\n\t\tHandler:           middleware.DefaultMetricsHandler,\n\t\tBindAddress:       opts.MetricsServer.BindAddress,\n\t\tSecureBindAddress: opts.MetricsServer.SecureBindAddress,\n\t\tTLS:               opts.MetricsServer.TLS,\n\t})\n\tif err != nil {\n\t\treturn fmt.Errorf(\"could not build metrics server: %v\", err)\n\t}\n\n\tp.server = proxyhttp.NewServerGroup(appServer, metricsServer)\n\treturn nil\n}\n\nfunc (p *OAuthProxy) buildServeMux(proxyPrefix string) {\n\t// Use the encoded path here so we can have the option to pass it on in the upstream mux.\n\t// Otherwise something like /%2F/ would be redirected to / here already.\n\tr := mux.NewRouter().UseEncodedPath()\n\t// Everything served by the router must go through the preAuthChain first.\n\tr.Use(p.preAuthChain.Then)\n\n\t// Register the robots path writer\n\tr.Path(robotsPath).HandlerFunc(p.pageWriter.WriteRobotsTxt)\n\n\t// The authonly path should be registered separately to prevent it from getting no-cache headers.\n\t// We do this to allow users to have a short cache (via nginx) of the response to reduce the\n\t// likelihood of multiple requests trying to refresh sessions simultaneously.\n\tr.Path(proxyPrefix + authOnlyPath).Handler(p.sessionChain.ThenFunc(p.AuthOnly))\n\n\t// This will register all of the paths under the proxy prefix, except the auth only path so that no cache headers\n\t// are not applied.\n\tp.buildProxySubrouter(r.PathPrefix(proxyPrefix).Subrouter())\n\n\t// Register serveHTTP last so it catches anything that isn't already caught earlier.\n\t// Anything that got to this point needs to have a session loaded.\n\tr.PathPrefix(\"/\").Handler(p.sessionChain.ThenFunc(p.Proxy))\n\tp.serveMux = r\n}\n\nfunc (p *OAuthProxy) buildProxySubrouter(s *mux.Router) {\n\ts.Use(prepareNoCacheMiddleware)\n\n\ts.Path(signInPath).HandlerFunc(p.SignIn)\n\ts.Path(oauthStartPath).HandlerFunc(p.OAuthStart)\n\ts.Path(oauthCallbackPath).HandlerFunc(p.OAuthCallback)\n\n\t// Static file paths\n\ts.PathPrefix(staticPathPrefix).Handler(http.StripPrefix(p.ProxyPrefix, http.FileServer(http.FS(staticFiles))))\n\n\t// The userinfo and logout endpoints needs to load sessions before handling the request\n\ts.Path(userInfoPath).Handler(p.sessionChain.ThenFunc(p.UserInfo))\n\ts.Path(signOutPath).Handler(p.sessionChain.ThenFunc(p.SignOut))\n}\n\n// buildPreAuthChain constructs a chain that should process every request before\n// the OAuth2 Proxy authentication logic kicks in.\n// For example forcing HTTPS or health checks.\nfunc buildPreAuthChain(opts *options.Options, sessionStore sessionsapi.SessionStore) (alice.Chain, error) {\n\tchain := alice.New(middleware.NewScope(opts.ReverseProxy, opts.Logging.RequestIDHeader))\n\n\tif opts.ForceHTTPS {\n\t\t_, httpsPort, err := net.SplitHostPort(opts.Server.SecureBindAddress)\n\t\tif err != nil {\n\t\t\treturn alice.Chain{}, fmt.Errorf(\"invalid HTTPS address %q: %v\", opts.Server.SecureBindAddress, err)\n\t\t}\n\t\tchain = chain.Append(middleware.NewRedirectToHTTPS(httpsPort))\n\t}\n\n\thealthCheckPaths := []string{opts.PingPath}\n\thealthCheckUserAgents := []string{opts.PingUserAgent}\n\tif opts.GCPHealthChecks {\n\t\tlogger.Printf(\"WARNING: GCP HealthChecks are now deprecated: Reconfigure apps to use the ping path for liveness and readiness checks, set the ping user agent to \\\"GoogleHC/1.0\\\" to preserve existing behaviour\")\n\t\thealthCheckPaths = append(healthCheckPaths, \"/liveness_check\", \"/readiness_check\")\n\t\thealthCheckUserAgents = append(healthCheckUserAgents, \"GoogleHC/1.0\")\n\t}\n\n\t// To silence logging of health checks, register the health check handler before\n\t// the logging handler\n\tif opts.Logging.SilencePing {\n\t\tchain = chain.Append(\n\t\t\tmiddleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents),\n\t\t\tmiddleware.NewReadynessCheck(opts.ReadyPath, sessionStore),\n\t\t\tmiddleware.NewRequestLogger(),\n\t\t)\n\t} else {\n\t\tchain = chain.Append(\n\t\t\tmiddleware.NewRequestLogger(),\n\t\t\tmiddleware.NewHealthCheck(healthCheckPaths, healthCheckUserAgents),\n\t\t\tmiddleware.NewReadynessCheck(opts.ReadyPath, sessionStore),\n\t\t)\n\t}\n\n\tchain = chain.Append(middleware.NewRequestMetricsWithDefaultRegistry())\n\n\treturn chain, nil\n}\n\nfunc buildSessionChain(opts *options.Options, provider providers.Provider, sessionStore sessionsapi.SessionStore, validator basic.Validator) alice.Chain {\n\tchain := alice.New()\n\n\tif opts.SkipJwtBearerTokens {\n\t\tsessionLoaders := []middlewareapi.TokenToSessionFunc{\n\t\t\tprovider.CreateSessionFromToken,\n\t\t}\n\n\t\tfor _, verifier := range opts.GetJWTBearerVerifiers() {\n\t\t\tsessionLoaders = append(sessionLoaders,\n\t\t\t\tmiddlewareapi.CreateTokenToSessionFunc(verifier.Verify))\n\t\t}\n\n\t\tchain = chain.Append(middleware.NewJwtSessionLoader(sessionLoaders))\n\t}\n\n\tif validator != nil {\n\t\tchain = chain.Append(middleware.NewBasicAuthSessionLoader(validator, opts.HtpasswdUserGroups, opts.LegacyPreferEmailToUser))\n\t}\n\n\tchain = chain.Append(middleware.NewStoredSessionLoader(&middleware.StoredSessionLoaderOptions{\n\t\tSessionStore:    sessionStore,\n\t\tRefreshPeriod:   opts.Cookie.Refresh,\n\t\tRefreshSession:  provider.RefreshSession,\n\t\tValidateSession: provider.ValidateSession,\n\t}))\n\n\treturn chain\n}\n\nfunc buildHeadersChain(opts *options.Options) (alice.Chain, error) {\n\trequestInjector, err := middleware.NewRequestHeaderInjector(opts.InjectRequestHeaders)\n\tif err != nil {\n\t\treturn alice.Chain{}, fmt.Errorf(\"error constructing request header injector: %v\", err)\n\t}\n\n\tresponseInjector, err := middleware.NewResponseHeaderInjector(opts.InjectResponseHeaders)\n\tif err != nil {\n\t\treturn alice.Chain{}, fmt.Errorf(\"error constructing request header injector: %v\", err)\n\t}\n\n\treturn alice.New(requestInjector, responseInjector), nil\n}\n\nfunc buildSignInMessage(opts *options.Options) string {\n\tvar msg string\n\tif len(opts.Templates.Banner) >= 1 {\n\t\tif opts.Templates.Banner == \"-\" {\n\t\t\tmsg = \"\"\n\t\t} else {\n\t\t\tmsg = opts.Templates.Banner\n\t\t}\n\t} else if len(opts.EmailDomains) != 0 && opts.AuthenticatedEmailsFile == \"\" {\n\t\tif len(opts.EmailDomains) > 1 {\n\t\t\tmsg = fmt.Sprintf(\"Authenticate using one of the following domains: %v\", strings.Join(opts.EmailDomains, \", \"))\n\t\t} else if opts.EmailDomains[0] != \"*\" {\n\t\t\tmsg = fmt.Sprintf(\"Authenticate using %v\", opts.EmailDomains[0])\n\t\t}\n\t}\n\treturn msg\n}\n\nfunc buildProviderName(p providers.Provider, override string) string {\n\tif override != \"\" {\n\t\treturn override\n\t}\n\treturn p.Data().ProviderName\n}\n\n// buildRoutesAllowlist builds an []allowedRoute  list from either the legacy\n// SkipAuthRegex option (paths only support) or newer SkipAuthRoutes option\n// (method=path support)\nfunc buildRoutesAllowlist(opts *options.Options) ([]allowedRoute, error) {\n\troutes := make([]allowedRoute, 0, len(opts.SkipAuthRegex)+len(opts.SkipAuthRoutes))\n\n\tfor _, path := range opts.SkipAuthRegex {\n\t\tcompiledRegex, err := regexp.Compile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Printf(\"Skipping auth - Method: ALL | Path: %s\", path)\n\t\troutes = append(routes, allowedRoute{\n\t\t\tmethod:    \"\",\n\t\t\tpathRegex: compiledRegex,\n\t\t})\n\t}\n\n\tfor _, methodPath := range opts.SkipAuthRoutes {\n\t\tvar (\n\t\t\tmethod string\n\t\t\tpath   string\n\t\t\tnegate = strings.Contains(methodPath, \"!=\")\n\t\t)\n\n\t\tparts := regexp.MustCompile(\"!?=\").Split(methodPath, 2)\n\t\tif len(parts) == 1 {\n\t\t\tmethod = \"\"\n\t\t\tpath = parts[0]\n\t\t} else {\n\t\t\tmethod = strings.ToUpper(parts[0])\n\t\t\tpath = parts[1]\n\t\t}\n\n\t\tcompiledRegex, err := regexp.Compile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Printf(\"Skipping auth - Method: %s | Path: %s\", method, path)\n\t\troutes = append(routes, allowedRoute{\n\t\t\tmethod:    method,\n\t\t\tnegate:    negate,\n\t\t\tpathRegex: compiledRegex,\n\t\t})\n\t}\n\n\treturn routes, nil\n}\n\n// buildAPIRoutes builds an []apiRoute from ApiRoutes option\nfunc buildAPIRoutes(opts *options.Options) ([]apiRoute, error) {\n\troutes := make([]apiRoute, 0, len(opts.APIRoutes))\n\n\tfor _, path := range opts.APIRoutes {\n\t\tcompiledRegex, err := regexp.Compile(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlogger.Printf(\"API route - Path: %s\", path)\n\t\troutes = append(routes, apiRoute{\n\t\t\tpathRegex: compiledRegex,\n\t\t})\n\t}\n\n\treturn routes, nil\n}\n\n// ClearSessionCookie creates a cookie to unset the user's authentication cookie\n// stored in the user's session\nfunc (p *OAuthProxy) ClearSessionCookie(rw http.ResponseWriter, req *http.Request) error {\n\treturn p.sessionStore.Clear(rw, req)\n}\n\n// LoadCookiedSession reads the user's authentication details from the request\nfunc (p *OAuthProxy) LoadCookiedSession(req *http.Request) (*sessionsapi.SessionState, error) {\n\treturn p.sessionStore.Load(req)\n}\n\n// SaveSession creates a new session cookie value and sets this on the response\nfunc (p *OAuthProxy) SaveSession(rw http.ResponseWriter, req *http.Request, s *sessionsapi.SessionState) error {\n\treturn p.sessionStore.Save(rw, req, s)\n}\n\nfunc (p *OAuthProxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tp.serveMux.ServeHTTP(rw, req)\n}\n\n// ErrorPage writes an error response\nfunc (p *OAuthProxy) ErrorPage(rw http.ResponseWriter, req *http.Request, code int, appError string, messages ...interface{}) {\n\tredirectURL, err := p.appDirector.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t}\n\tif redirectURL == p.SignInPath || redirectURL == \"\" {\n\t\tredirectURL = \"/\"\n\t}\n\n\tscope := middlewareapi.GetRequestScope(req)\n\tp.pageWriter.WriteErrorPage(rw, pagewriter.ErrorPageOpts{\n\t\tStatus:      code,\n\t\tRedirectURL: redirectURL,\n\t\tRequestID:   scope.RequestID,\n\t\tAppError:    appError,\n\t\tMessages:    messages,\n\t})\n}\n\n// IsAllowedRequest is used to check if auth should be skipped for this request\nfunc (p *OAuthProxy) IsAllowedRequest(req *http.Request) bool {\n\tisPreflightRequestAllowed := p.skipAuthPreflight && req.Method == \"OPTIONS\"\n\treturn isPreflightRequestAllowed || p.isAllowedRoute(req) || p.isTrustedIP(req)\n}\n\nfunc isAllowedMethod(req *http.Request, route allowedRoute) bool {\n\treturn route.method == \"\" || req.Method == route.method\n}\n\nfunc isAllowedPath(req *http.Request, route allowedRoute) bool {\n\tmatches := route.pathRegex.MatchString(requestutil.GetRequestURI(req))\n\n\tif route.negate {\n\t\treturn !matches\n\t}\n\n\treturn matches\n}\n\n// IsAllowedRoute is used to check if the request method & path is allowed without auth\nfunc (p *OAuthProxy) isAllowedRoute(req *http.Request) bool {\n\tfor _, route := range p.allowedRoutes {\n\t\tif isAllowedMethod(req, route) && isAllowedPath(req, route) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p *OAuthProxy) isAPIPath(req *http.Request) bool {\n\tfor _, route := range p.apiRoutes {\n\t\tif route.pathRegex.MatchString(requestutil.GetRequestURI(req)) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isTrustedIP is used to check if a request comes from a trusted client IP address.\nfunc (p *OAuthProxy) isTrustedIP(req *http.Request) bool {\n\t// RemoteAddr @ means unix socket\n\t// https://github.com/golang/go/blob/0fa53e41f122b1661d0678a6d36d71b7b5ad031d/src/syscall/syscall_linux.go#L506-L511\n\tif p.trustedIPs == nil && req.RemoteAddr != \"@\" {\n\t\treturn false\n\t}\n\n\tremoteAddr, err := ip.GetClientIP(p.realClientIPParser, req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining real IP for trusted IP list: %v\", err)\n\t\t// Possibly spoofed X-Real-IP header\n\t\treturn false\n\t}\n\n\tif remoteAddr == nil {\n\t\treturn false\n\t}\n\n\treturn p.trustedIPs.Has(remoteAddr)\n}\n\n// SignInPage writes the sign in template to the response\nfunc (p *OAuthProxy) SignInPage(rw http.ResponseWriter, req *http.Request, code int) {\n\tprepareNoCache(rw)\n\terr := p.ClearSessionCookie(rw, req)\n\tif err != nil {\n\t\tlogger.Printf(\"Error clearing session cookie: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\trw.WriteHeader(code)\n\n\tredirectURL, err := p.appDirector.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tif redirectURL == p.SignInPath {\n\t\tredirectURL = \"/\"\n\t}\n\n\tp.pageWriter.WriteSignInPage(rw, req, redirectURL, code)\n}\n\n// ManualSignIn handles basic auth logins to the proxy\nfunc (p *OAuthProxy) ManualSignIn(req *http.Request) (string, bool, int) {\n\tif req.Method != \"POST\" || p.basicAuthValidator == nil {\n\t\treturn \"\", false, http.StatusOK\n\t}\n\tuser := req.FormValue(\"username\")\n\tpasswd := req.FormValue(\"password\")\n\tif user == \"\" {\n\t\treturn \"\", false, http.StatusBadRequest\n\t}\n\t// check auth\n\tif p.basicAuthValidator.Validate(user, passwd) {\n\t\tlogger.PrintAuthf(user, req, logger.AuthSuccess, \"Authenticated via HtpasswdFile\")\n\t\treturn user, true, http.StatusOK\n\t}\n\tlogger.PrintAuthf(user, req, logger.AuthFailure, \"Invalid authentication via HtpasswdFile\")\n\treturn \"\", false, http.StatusUnauthorized\n}\n\n// SignIn serves a page prompting users to sign in\nfunc (p *OAuthProxy) SignIn(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.appDirector.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tuser, ok, statusCode := p.ManualSignIn(req)\n\tif ok {\n\t\tsession := &sessionsapi.SessionState{User: user, Groups: p.basicAuthGroups}\n\t\terr = p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Printf(\"Error saving session: %v\", err)\n\t\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, redirect, http.StatusFound)\n\t} else {\n\t\tif p.SkipProviderButton {\n\t\t\tp.OAuthStart(rw, req)\n\t\t} else {\n\t\t\t// TODO - should we pass on /oauth2/sign_in query params to /oauth2/start?\n\t\t\tp.SignInPage(rw, req, statusCode)\n\t\t}\n\t}\n}\n\n// UserInfo endpoint outputs session email and preferred username in JSON format\nfunc (p *OAuthProxy) UserInfo(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\trw.Header().Set(\"Content-Type\", \"application/json\")\n\trw.WriteHeader(http.StatusOK)\n\tif session == nil {\n\t\tif _, err := rw.Write([]byte(\"{}\")); err != nil {\n\t\t\tlogger.Printf(\"Error encoding empty user info: %v\", err)\n\t\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\t}\n\t\treturn\n\t}\n\n\tuserInfo := struct {\n\t\tUser              string   `json:\"user\"`\n\t\tEmail             string   `json:\"email\"`\n\t\tGroups            []string `json:\"groups,omitempty\"`\n\t\tPreferredUsername string   `json:\"preferredUsername,omitempty\"`\n\t}{\n\t\tUser:              session.User,\n\t\tEmail:             session.Email,\n\t\tGroups:            session.Groups,\n\t\tPreferredUsername: session.PreferredUsername,\n\t}\n\n\tif err := json.NewEncoder(rw).Encode(userInfo); err != nil {\n\t\tlogger.Printf(\"Error encoding user info: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t}\n}\n\n// SignOut sends a response to clear the authentication cookie\nfunc (p *OAuthProxy) SignOut(rw http.ResponseWriter, req *http.Request) {\n\tredirect, err := p.appDirector.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining redirect: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\terr = p.ClearSessionCookie(rw, req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error clearing session cookie: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tp.backendLogout(rw, req)\n\n\thttp.Redirect(rw, req, redirect, http.StatusFound)\n}\n\nfunc (p *OAuthProxy) backendLogout(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\tlogger.Errorf(\"error getting authenticated session during backend logout: %v\", err)\n\t\treturn\n\t}\n\n\tif session == nil {\n\t\treturn\n\t}\n\n\tproviderData := p.provider.Data()\n\tif providerData.BackendLogoutURL == \"\" {\n\t\treturn\n\t}\n\n\tbackendLogoutURL := strings.ReplaceAll(providerData.BackendLogoutURL, \"{id_token}\", session.IDToken)\n\t// security exception because URL is dynamic ({id_token} replacement) but\n\t// base is not end-user provided but comes from configuration somewhat secure\n\tresp, err := http.Get(backendLogoutURL) // #nosec G107\n\tif err != nil {\n\t\tlogger.Errorf(\"error while calling backend logout: %v\", err)\n\t\treturn\n\t}\n\n\tdefer resp.Body.Close()\n\tif resp.StatusCode != 200 {\n\t\tlogger.Errorf(\"error while calling backend logout url, returned error code %v\", resp.StatusCode)\n\t}\n}\n\n// OAuthStart starts the OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthStart(rw http.ResponseWriter, req *http.Request) {\n\t// start the flow permitting login URL query parameters to be overridden from the request URL\n\tp.doOAuthStart(rw, req, req.URL.Query())\n}\n\nfunc (p *OAuthProxy) doOAuthStart(rw http.ResponseWriter, req *http.Request, overrides url.Values) {\n\textraParams := p.provider.Data().LoginURLParams(overrides)\n\tprepareNoCache(rw)\n\n\tvar (\n\t\terr                                              error\n\t\tcodeChallenge, codeVerifier, codeChallengeMethod string\n\t)\n\tif p.provider.Data().CodeChallengeMethod != \"\" {\n\t\tcodeChallengeMethod = p.provider.Data().CodeChallengeMethod\n\t\tcodeVerifier, err = encryption.GenerateCodeVerifierString(96)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Unable to build random ASCII string for code verifier: %v\", err)\n\t\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tcodeChallenge, err = encryption.GenerateCodeChallenge(p.provider.Data().CodeChallengeMethod, codeVerifier)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Error creating code challenge: %v\", err)\n\t\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\n\t\textraParams.Add(\"code_challenge\", codeChallenge)\n\t\textraParams.Add(\"code_challenge_method\", codeChallengeMethod)\n\t}\n\n\tcsrf, err := cookies.NewCSRF(p.CookieOptions, codeVerifier)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error creating CSRF nonce: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tappRedirect, err := p.appDirector.GetRedirect(req)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error obtaining application redirect: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusBadRequest, err.Error())\n\t\treturn\n\t}\n\n\tcallbackRedirect := p.getOAuthRedirectURI(req)\n\tloginURL := p.provider.GetLoginURL(\n\t\tcallbackRedirect,\n\t\tencodeState(csrf.HashOAuthState(), appRedirect, p.encodeState),\n\t\tcsrf.HashOIDCNonce(),\n\t\textraParams,\n\t)\n\n\tif _, err := csrf.SetCookie(rw, req); err != nil {\n\t\tlogger.Errorf(\"Error setting CSRF cookie: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\thttp.Redirect(rw, req, loginURL, http.StatusFound)\n}\n\n// OAuthCallback is the OAuth2 authentication flow callback that finishes the\n// OAuth2 authentication flow\nfunc (p *OAuthProxy) OAuthCallback(rw http.ResponseWriter, req *http.Request) {\n\tremoteAddr := ip.GetClientString(p.realClientIPParser, req, true)\n\n\t// finish the oauth cycle\n\terr := req.ParseForm()\n\tif err != nil {\n\t\tlogger.Errorf(\"Error while parsing OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\terrorString := req.Form.Get(\"error\")\n\tif errorString != \"\" {\n\t\tlogger.Errorf(\"Error while parsing OAuth2 callback: %s\", errorString)\n\t\tmessage := fmt.Sprintf(\"Login Failed: The upstream identity provider returned an error: %s\", errorString)\n\t\t// Set the debug message and override the non debug message to be the same for this case\n\t\tp.ErrorPage(rw, req, http.StatusForbidden, message, message)\n\t\treturn\n\t}\n\n\tnonce, appRedirect, err := decodeState(req.Form.Get(\"state\"), p.encodeState)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error while parsing OAuth2 state: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\t// calculate the cookie name\n\tcookieName := cookies.GenerateCookieName(p.CookieOptions, nonce)\n\t// Try to find the CSRF cookie and decode it\n\tcsrf, err := cookies.LoadCSRFCookie(req, cookieName, p.CookieOptions)\n\tif err != nil {\n\t\t// There are a lot of issues opened complaining about missing CSRF cookies.\n\t\t// Try to log the INs and OUTs of OAuthProxy, to be easier to analyse these issues.\n\t\tLoggingCSRFCookiesInOAuthCallback(req, cookieName)\n\t\tlogger.Println(req, logger.AuthFailure, \"Invalid authentication via OAuth2: unable to obtain CSRF cookie: %s (state=%s)\", err, nonce)\n\t\tp.ErrorPage(rw, req, http.StatusForbidden, err.Error(), \"Login Failed: Unable to find a valid CSRF token. Please try again.\")\n\t\treturn\n\t}\n\n\tsession, err := p.redeemCode(req, csrf.GetCodeVerifier())\n\tif err != nil {\n\t\tlogger.Errorf(\"Error redeeming code during OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\terr = p.enrichSessionState(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error creating session during OAuth2 callback: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\treturn\n\t}\n\n\tcsrf.ClearCookie(rw, req)\n\n\tif !csrf.CheckOAuthState(nonce) {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: CSRF token mismatch, potential attack\")\n\t\tp.ErrorPage(rw, req, http.StatusForbidden, \"CSRF token mismatch, potential attack\", \"Login Failed: Unable to find a valid CSRF token. Please try again.\")\n\t\treturn\n\t}\n\n\tcsrf.SetSessionNonce(session)\n\tif !p.provider.ValidateSession(req.Context(), session) {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Session validation failed: %s\", session)\n\t\tp.ErrorPage(rw, req, http.StatusForbidden, \"Session validation failed\")\n\t\treturn\n\t}\n\n\tif !p.redirectValidator.IsValidRedirect(appRedirect) {\n\t\tappRedirect = \"/\"\n\t}\n\n\t// set cookie, or deny\n\tauthorized, err := p.provider.Authorize(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error with authorization: %v\", err)\n\t}\n\tif p.Validator(session.Email) && authorized {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthSuccess, \"Authenticated via OAuth2: %s\", session)\n\t\terr := p.SaveSession(rw, req, session)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Error saving session state for %s: %v\", remoteAddr, err)\n\t\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t\t\treturn\n\t\t}\n\t\thttp.Redirect(rw, req, appRedirect, http.StatusFound)\n\t} else {\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authentication via OAuth2: unauthorized\")\n\t\tp.ErrorPage(rw, req, http.StatusForbidden, \"Invalid session: unauthorized\")\n\t}\n}\n\nfunc (p *OAuthProxy) redeemCode(req *http.Request, codeVerifier string) (*sessionsapi.SessionState, error) {\n\tcode := req.Form.Get(\"code\")\n\tif code == \"\" {\n\t\treturn nil, providers.ErrMissingCode\n\t}\n\n\tredirectURI := p.getOAuthRedirectURI(req)\n\ts, err := p.provider.Redeem(req.Context(), redirectURI, code, codeVerifier)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Force setting these in case the Provider didn't\n\tif s.CreatedAt == nil {\n\t\ts.CreatedAtNow()\n\t}\n\tif s.ExpiresOn == nil {\n\t\ts.ExpiresIn(p.CookieOptions.Expire)\n\t}\n\n\treturn s, nil\n}\n\nfunc (p *OAuthProxy) enrichSessionState(ctx context.Context, s *sessionsapi.SessionState) error {\n\tvar err error\n\tif s.Email == \"\" {\n\t\t// TODO(@NickMeves): Remove once all provider are updated to implement EnrichSession\n\t\t// nolint:staticcheck\n\t\ts.Email, err = p.provider.GetEmailAddress(ctx, s)\n\t\tif err != nil && !errors.Is(err, providers.ErrNotImplemented) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn p.provider.EnrichSession(ctx, s)\n}\n\n// AuthOnly checks whether the user is currently logged in (both authentication\n// and optional authorization).\nfunc (p *OAuthProxy) AuthOnly(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tif err != nil {\n\t\thttp.Error(rw, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\t// Unauthorized cases need to return 403 to prevent infinite redirects with\n\t// subrequest architectures\n\tif !authOnlyAuthorize(req, session) {\n\t\thttp.Error(rw, http.StatusText(http.StatusForbidden), http.StatusForbidden)\n\t\treturn\n\t}\n\n\t// we are authenticated\n\tp.addHeadersForProxying(rw, session)\n\tp.headersChain.Then(http.HandlerFunc(func(rw http.ResponseWriter, _ *http.Request) {\n\t\trw.WriteHeader(http.StatusAccepted)\n\t})).ServeHTTP(rw, req)\n}\n\n// Proxy proxies the user request if the user is authenticated else it prompts\n// them to authenticate\nfunc (p *OAuthProxy) Proxy(rw http.ResponseWriter, req *http.Request) {\n\tsession, err := p.getAuthenticatedSession(rw, req)\n\tswitch err {\n\tcase nil:\n\t\t// we are authenticated\n\t\tp.addHeadersForProxying(rw, session)\n\t\tp.headersChain.Then(p.upstreamProxy).ServeHTTP(rw, req)\n\tcase ErrNeedsLogin:\n\t\t// we need to send the user to a login screen\n\t\tif p.forceJSONErrors || isAjax(req) || p.isAPIPath(req) {\n\t\t\tlogger.Printf(\"No valid authentication in request. Access Denied.\")\n\t\t\t// no point redirecting an AJAX request\n\t\t\tp.errorJSON(rw, http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tlogger.Printf(\"No valid authentication in request. Initiating login.\")\n\t\tif p.SkipProviderButton {\n\t\t\t// start OAuth flow, but only with the default login URL params - do not\n\t\t\t// consider this request's query params as potential overrides, since\n\t\t\t// the user did not explicitly start the login flow\n\t\t\tp.doOAuthStart(rw, req, nil)\n\t\t} else {\n\t\t\tp.SignInPage(rw, req, http.StatusForbidden)\n\t\t}\n\n\tcase ErrAccessDenied:\n\t\tif p.forceJSONErrors {\n\t\t\tp.errorJSON(rw, http.StatusForbidden)\n\t\t} else {\n\t\t\tp.ErrorPage(rw, req, http.StatusForbidden, \"The session failed authorization checks\")\n\t\t}\n\n\tdefault:\n\t\t// unknown error\n\t\tlogger.Errorf(\"Unexpected internal error: %v\", err)\n\t\tp.ErrorPage(rw, req, http.StatusInternalServerError, err.Error())\n\t}\n}\n\n// See https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=en\nvar noCacheHeaders = map[string]string{\n\t\"Expires\":         time.Unix(0, 0).Format(time.RFC1123),\n\t\"Cache-Control\":   \"no-cache, no-store, must-revalidate, max-age=0\",\n\t\"X-Accel-Expires\": \"0\", // https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/\n}\n\n// prepareNoCache prepares headers for preventing browser caching.\nfunc prepareNoCache(w http.ResponseWriter) {\n\t// Set NoCache headers\n\tfor k, v := range noCacheHeaders {\n\t\tw.Header().Set(k, v)\n\t}\n}\n\nfunc prepareNoCacheMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n\t\tprepareNoCache(rw)\n\t\tnext.ServeHTTP(rw, req)\n\t})\n}\n\n// getOAuthRedirectURI returns the redirectURL that the upstream OAuth Provider will\n// redirect clients to once authenticated.\n// This is usually the OAuthProxy callback URL.\nfunc (p *OAuthProxy) getOAuthRedirectURI(req *http.Request) string {\n\t// if `p.redirectURL` already has a host, return it\n\tif p.relativeRedirectURL || p.redirectURL.Host != \"\" {\n\t\treturn p.redirectURL.String()\n\t}\n\n\t// Otherwise figure out the scheme + host from the request\n\trd := *p.redirectURL\n\trd.Host = requestutil.GetRequestHost(req)\n\trd.Scheme = requestutil.GetRequestProto(req)\n\n\t// If there's no scheme in the request, we should still include one\n\tif rd.Scheme == \"\" {\n\t\trd.Scheme = schemeHTTP\n\t}\n\n\t// If CookieSecure is true, return `https` no matter what\n\t// Not all reverse proxies set X-Forwarded-Proto\n\tif p.CookieOptions.Secure {\n\t\trd.Scheme = schemeHTTPS\n\t}\n\treturn rd.String()\n}\n\n// getAuthenticatedSession checks whether a user is authenticated and returns a session object and nil error if so\n// Returns:\n// - `nil, ErrNeedsLogin` if user needs to login.\n// - `nil, ErrAccessDenied` if the authenticated user is not authorized\n// Set-Cookie headers may be set on the response as a side-effect of calling this method.\nfunc (p *OAuthProxy) getAuthenticatedSession(rw http.ResponseWriter, req *http.Request) (*sessionsapi.SessionState, error) {\n\tsession := middlewareapi.GetRequestScope(req).Session\n\n\t// Check this after loading the session so that if a valid session exists, we can add headers from it\n\tif p.IsAllowedRequest(req) {\n\t\treturn session, nil\n\t}\n\n\tif session == nil {\n\t\treturn nil, ErrNeedsLogin\n\t}\n\n\tinvalidEmail := session.Email != \"\" && !p.Validator(session.Email)\n\tauthorized, err := p.provider.Authorize(req.Context(), session)\n\tif err != nil {\n\t\tlogger.Errorf(\"Error with authorization: %v\", err)\n\t}\n\n\tif invalidEmail || !authorized {\n\t\tcause := \"unauthorized\"\n\t\tif invalidEmail {\n\t\t\tcause = \"invalid email\"\n\t\t}\n\n\t\tlogger.PrintAuthf(session.Email, req, logger.AuthFailure, \"Invalid authorization via session (%s): removing session %s\", cause, session)\n\t\t// Invalid session, clear it\n\t\terr := p.ClearSessionCookie(rw, req)\n\t\tif err != nil {\n\t\t\tlogger.Errorf(\"Error clearing session cookie: %v\", err)\n\t\t}\n\t\treturn nil, ErrAccessDenied\n\t}\n\n\treturn session, nil\n}\n\n// authOnlyAuthorize handles special authorization logic that is only done\n// on the AuthOnly endpoint for use with Nginx subrequest architectures.\nfunc authOnlyAuthorize(req *http.Request, s *sessionsapi.SessionState) bool {\n\t// Allow requests previously allowed to be bypassed\n\tif s == nil {\n\t\treturn true\n\t}\n\n\tconstraints := []func(*http.Request, *sessionsapi.SessionState) bool{\n\t\tcheckAllowedGroups,\n\t\tcheckAllowedEmailDomains,\n\t\tcheckAllowedEmails,\n\t}\n\n\tfor _, constraint := range constraints {\n\t\tif !constraint(req, s) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// extractAllowedEntities aims to extract and split allowed entities linked by a key,\n// from an HTTP request query. Output is a map[string]struct{} where keys are valuable,\n// the goal is to avoid time complexity O(N^2) while finding matches during membership checks.\nfunc extractAllowedEntities(req *http.Request, key string) map[string]struct{} {\n\tentities := map[string]struct{}{}\n\n\tquery := req.URL.Query()\n\tfor _, allowedEntities := range query[key] {\n\t\tfor _, entity := range strings.Split(allowedEntities, \",\") {\n\t\t\tif entity != \"\" {\n\t\t\t\tentities[entity] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn entities\n}\n\n// checkAllowedEmailDomains allow email domain restrictions based on the `allowed_email_domains`\n// querystring parameter\nfunc checkAllowedEmailDomains(req *http.Request, s *sessionsapi.SessionState) bool {\n\tallowedEmailDomains := extractAllowedEntities(req, \"allowed_email_domains\")\n\tif len(allowedEmailDomains) == 0 {\n\t\treturn true\n\t}\n\n\tsplitEmail := strings.Split(s.Email, \"@\")\n\tif len(splitEmail) != 2 {\n\t\treturn false\n\t}\n\n\tendpoint, _ := url.Parse(\"\")\n\tendpoint.Host = splitEmail[1]\n\n\tallowedEmailDomainsList := []string{}\n\tfor ed := range allowedEmailDomains {\n\t\tallowedEmailDomainsList = append(allowedEmailDomainsList, ed)\n\t}\n\n\treturn util.IsEndpointAllowed(endpoint, allowedEmailDomainsList)\n}\n\n// checkAllowedGroups allow secondary group restrictions based on the `allowed_groups`\n// querystring parameter\nfunc checkAllowedGroups(req *http.Request, s *sessionsapi.SessionState) bool {\n\tallowedGroups := extractAllowedEntities(req, \"allowed_groups\")\n\tif len(allowedGroups) == 0 {\n\t\treturn true\n\t}\n\n\tfor _, group := range s.Groups {\n\t\tif _, ok := allowedGroups[group]; ok {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// checkAllowedEmails allow email restrictions based on the `allowed_emails`\n// querystring parameter\nfunc checkAllowedEmails(req *http.Request, s *sessionsapi.SessionState) bool {\n\tallowedEmails := extractAllowedEntities(req, \"allowed_emails\")\n\tif len(allowedEmails) == 0 {\n\t\treturn true\n\t}\n\n\tallowed := false\n\n\tfor email := range allowedEmails {\n\t\tif email == s.Email {\n\t\t\tallowed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn allowed\n}\n\n// encodeState builds the OAuth state param out of our nonce and\n// original application redirect\nfunc encodeState(nonce string, redirect string, encode bool) string {\n\trawString := fmt.Sprintf(\"%v:%v\", nonce, redirect)\n\tif encode {\n\t\treturn base64.RawURLEncoding.EncodeToString([]byte(rawString))\n\t}\n\treturn rawString\n}\n\n// decodeState splits the reflected OAuth state response back into\n// the nonce and original application redirect\nfunc decodeState(state string, encode bool) (string, string, error) {\n\ttoParse := state\n\tif encode {\n\t\tdecoded, _ := base64.RawURLEncoding.DecodeString(state)\n\t\ttoParse = string(decoded)\n\t}\n\n\tparsedState := strings.SplitN(toParse, \":\", 2)\n\tif len(parsedState) != 2 {\n\t\treturn \"\", \"\", errors.New(\"invalid length\")\n\t}\n\treturn parsedState[0], parsedState[1], nil\n}\n\n// addHeadersForProxying adds the appropriate headers the request / response for proxying\nfunc (p *OAuthProxy) addHeadersForProxying(rw http.ResponseWriter, session *sessionsapi.SessionState) {\n\tif session == nil {\n\t\treturn\n\t}\n\tif session.Email == \"\" {\n\t\trw.Header().Set(\"GAP-Auth\", session.User)\n\t} else {\n\t\trw.Header().Set(\"GAP-Auth\", session.Email)\n\t}\n}\n\n// isAjax checks if a request is an ajax request\nfunc isAjax(req *http.Request) bool {\n\tacceptValues := req.Header.Values(\"Accept\")\n\tconst ajaxReq = applicationJSON\n\t// Iterate over multiple Accept headers, i.e.\n\t// Accept: application/json\n\t// Accept: text/plain\n\tfor _, mimeTypes := range acceptValues {\n\t\t// Iterate over multiple mimetypes in a single header, i.e.\n\t\t// Accept: application/json, text/plain, */*\n\t\tfor _, mimeType := range strings.Split(mimeTypes, \",\") {\n\t\t\tmimeType = strings.TrimSpace(mimeType)\n\t\t\tif mimeType == ajaxReq {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\n// errorJSON returns the error code with an application/json mime type\nfunc (p *OAuthProxy) errorJSON(rw http.ResponseWriter, code int) {\n\trw.Header().Set(\"Content-Type\", applicationJSON)\n\trw.WriteHeader(code)\n\t// we need to send some JSON response because we set the Content-Type to\n\t// application/json\n\trw.Write([]byte(\"{}\"))\n}\n\n// LoggingCSRFCookiesInOAuthCallback Log all CSRF cookies found in HTTP request OAuth callback,\n// which were successfully parsed\nfunc LoggingCSRFCookiesInOAuthCallback(req *http.Request, cookieName string) {\n\tcookies := req.Cookies()\n\tif len(cookies) == 0 {\n\t\tlogger.Println(req, logger.AuthFailure, \"No cookies were found in OAuth callback.\")\n\t\treturn\n\t}\n\n\tfor _, c := range cookies {\n\t\tif cookieName == c.Name {\n\t\t\tlogger.Println(req, logger.AuthFailure, \"CSRF cookie %s was found in OAuth callback.\", c.Name)\n\t\t\treturn\n\t\t}\n\n\t\tif strings.HasSuffix(c.Name, \"_csrf\") {\n\t\t\tlogger.Println(req, logger.AuthFailure, \"CSRF cookie %s was found in OAuth callback, but it is not the expected one (%s).\", c.Name, cookieName)\n\t\t\treturn\n\t\t}\n\t}\n\n\tlogger.Println(req, logger.AuthFailure, \"Cookies were found in OAuth callback, but none was a CSRF cookie.\")\n}\n"
        },
        {
          "name": "oauthproxy_test.go",
          "type": "blob",
          "size": 87.00390625,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"crypto\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/coreos/go-oidc/v3/oidc\"\n\t\"github.com/mbland/hmacauth\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/options\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/apis/sessions\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/cookies\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\tinternaloidc \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/providers/oidc\"\n\tsessionscookie \"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/sessions/cookie\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/upstream\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/validation\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/providers\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nconst (\n\t// The rawCookieSecret is 32 bytes and the base64CookieSecret is the base64\n\t// encoded version of this.\n\trawCookieSecret    = \"secretthirtytwobytes+abcdefghijk\"\n\tbase64CookieSecret = \"c2VjcmV0dGhpcnR5dHdvYnl0ZXMrYWJjZGVmZ2hpams\"\n\tclientID           = \"3984n253984d7348dm8234yf982t\"\n\tclientSecret       = \"gv3498mfc9t23y23974dm2394dm9\"\n)\n\nfunc init() {\n\tlogger.SetFlags(logger.Lshortfile)\n}\n\nfunc TestRobotsTxt(t *testing.T) {\n\topts := baseTestOptions()\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/robots.txt\", nil)\n\tproxy.ServeHTTP(rw, req)\n\tassert.Equal(t, 200, rw.Code)\n\tassert.Equal(t, \"User-agent: *\\nDisallow: /\\n\", rw.Body.String())\n}\n\ntype TestProvider struct {\n\t*providers.ProviderData\n\tEmailAddress   string\n\tValidToken     bool\n\tGroupValidator func(string) bool\n}\n\nvar _ providers.Provider = (*TestProvider)(nil)\n\nfunc NewTestProvider(providerURL *url.URL, emailAddress string) *TestProvider {\n\treturn &TestProvider{\n\t\tProviderData: &providers.ProviderData{\n\t\t\tProviderName: \"Test Provider\",\n\t\t\tLoginURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/oauth/authorize\",\n\t\t\t},\n\t\t\tRedeemURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/oauth/token\",\n\t\t\t},\n\t\t\tProfileURL: &url.URL{\n\t\t\t\tScheme: \"http\",\n\t\t\t\tHost:   providerURL.Host,\n\t\t\t\tPath:   \"/api/v1/profile\",\n\t\t\t},\n\t\t\tScope: \"profile.email\",\n\t\t},\n\t\tEmailAddress: emailAddress,\n\t\tGroupValidator: func(s string) bool {\n\t\t\treturn true\n\t\t},\n\t}\n}\n\nfunc (tp *TestProvider) GetEmailAddress(_ context.Context, _ *sessions.SessionState) (string, error) {\n\treturn tp.EmailAddress, nil\n}\n\nfunc (tp *TestProvider) ValidateSession(_ context.Context, _ *sessions.SessionState) bool {\n\treturn tp.ValidToken\n}\n\nfunc Test_redeemCode(t *testing.T) {\n\topts := baseTestOptions()\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\t_, err = proxy.redeemCode(req, \"\")\n\tassert.Equal(t, providers.ErrMissingCode, err)\n}\n\nfunc Test_enrichSession(t *testing.T) {\n\tconst (\n\t\tsessionUser   = \"Mr Session\"\n\t\tsessionEmail  = \"session@example.com\"\n\t\tproviderEmail = \"provider@example.com\"\n\t)\n\n\ttestCases := map[string]struct {\n\t\tsession       *sessions.SessionState\n\t\texpectedUser  string\n\t\texpectedEmail string\n\t}{\n\t\t\"Session already has enrichable fields\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:  sessionUser,\n\t\t\t\tEmail: sessionEmail,\n\t\t\t},\n\t\t\texpectedUser:  sessionUser,\n\t\t\texpectedEmail: sessionEmail,\n\t\t},\n\t\t\"Session is missing Email and GetEmailAddress is implemented\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser: sessionUser,\n\t\t\t},\n\t\t\texpectedUser:  sessionUser,\n\t\t\texpectedEmail: providerEmail,\n\t\t},\n\t\t\"Session is missing User and GetUserName is not implemented\": {\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tEmail: sessionEmail,\n\t\t\t},\n\t\t\texpectedUser:  \"\",\n\t\t\texpectedEmail: sessionEmail,\n\t\t},\n\t}\n\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\topts := baseTestOptions()\n\t\t\terr := validation.Validate(opts)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tproxy.provider = NewTestProvider(&url.URL{Host: \"www.example.com\"}, providerEmail)\n\n\t\t\terr = proxy.enrichSessionState(context.Background(), tc.session)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.expectedUser, tc.session.User)\n\t\t\tassert.Equal(t, tc.expectedEmail, tc.session.Email)\n\t\t})\n\t}\n}\n\nfunc TestBasicAuthPassword(t *testing.T) {\n\tproviderServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tlogger.Printf(\"%#v\", r)\n\t\tvar payload string\n\t\tswitch r.URL.Path {\n\t\tcase \"/oauth/token\":\n\t\t\tpayload = `{\"access_token\": \"my_auth_token\"}`\n\t\tdefault:\n\t\t\tpayload = r.Header.Get(\"Authorization\")\n\t\t\tif payload == \"\" {\n\t\t\t\tpayload = \"No Authorization header found.\"\n\t\t\t}\n\t\t}\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(payload))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\n\tbasicAuthPassword := \"This is a secure password\"\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   providerServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  providerServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\n\topts.Cookie.Secure = false\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(basicAuthPassword),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tproviderURL, _ := url.Parse(providerServer.URL)\n\tconst emailAddress = \"john.doe@example.com\"\n\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tproxy.provider = NewTestProvider(providerURL, emailAddress)\n\n\t// Save the required session\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\terr = proxy.sessionStore.Save(rw, req, &sessions.SessionState{\n\t\tEmail: emailAddress,\n\t})\n\tassert.NoError(t, err)\n\n\t// Extract the cookie value to inject into the test request\n\tcookie := rw.Header().Values(\"Set-Cookie\")[0]\n\n\treq, _ = http.NewRequest(\"GET\", \"/\", nil)\n\treq.Header.Set(\"Cookie\", cookie)\n\trw = httptest.NewRecorder()\n\tproxy.ServeHTTP(rw, req)\n\n\t// The username in the basic auth credentials is expected to be equal to the email address from the\n\t// auth response, so we use the same variable here.\n\texpectedHeader := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(emailAddress+\":\"+basicAuthPassword))\n\tassert.Equal(t, expectedHeader, rw.Body.String())\n\tproviderServer.Close()\n}\n\nfunc TestPassGroupsHeadersWithGroups(t *testing.T) {\n\topts := baseTestOptions()\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Forwarded-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tconst emailAddress = \"john.doe@example.com\"\n\tconst userName = \"9fcab5c9b889a557\"\n\n\tgroups := []string{\"a\", \"b\"}\n\tcreated := time.Now()\n\tsession := &sessions.SessionState{\n\t\tUser:        userName,\n\t\tGroups:      groups,\n\t\tEmail:       emailAddress,\n\t\tAccessToken: \"oauth_token\",\n\t\tCreatedAt:   &created,\n\t}\n\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tassert.NoError(t, err)\n\n\t// Save the required session\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\terr = proxy.sessionStore.Save(rw, req, session)\n\tassert.NoError(t, err)\n\n\t// Extract the cookie value to inject into the test request\n\tcookie := rw.Header().Values(\"Set-Cookie\")[0]\n\n\treq, _ = http.NewRequest(\"GET\", \"/\", nil)\n\treq.Header.Set(\"Cookie\", cookie)\n\trw = httptest.NewRecorder()\n\tproxy.ServeHTTP(rw, req)\n\n\tassert.Equal(t, []string{\"a,b\"}, req.Header[\"X-Forwarded-Groups\"])\n}\n\ntype PassAccessTokenTest struct {\n\tproviderServer *httptest.Server\n\tproxy          *OAuthProxy\n\topts           *options.Options\n}\n\ntype PassAccessTokenTestOptions struct {\n\tPassAccessToken bool\n\tValidToken      bool\n\tProxyUpstream   options.Upstream\n}\n\nfunc NewPassAccessTokenTest(opts PassAccessTokenTestOptions) (*PassAccessTokenTest, error) {\n\tpatt := &PassAccessTokenTest{}\n\n\tpatt.providerServer = httptest.NewServer(\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tvar payload string\n\t\t\tswitch r.URL.Path {\n\t\t\tcase \"/oauth/token\":\n\t\t\t\tpayload = `{\"access_token\": \"my_auth_token\"}`\n\t\t\tdefault:\n\t\t\t\tpayload = r.Header.Get(\"X-Forwarded-Access-Token\")\n\t\t\t\tif payload == \"\" {\n\t\t\t\t\tpayload = \"No access token found.\"\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.WriteHeader(200)\n\t\t\t_, err := w.Write([]byte(payload))\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}))\n\n\tpatt.opts = baseTestOptions()\n\tpatt.opts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   patt.providerServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  patt.providerServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\tif opts.ProxyUpstream.ID != \"\" {\n\t\tpatt.opts.UpstreamServers.Upstreams = append(patt.opts.UpstreamServers.Upstreams, opts.ProxyUpstream)\n\t}\n\n\tpatt.opts.Cookie.Secure = false\n\tif opts.PassAccessToken {\n\t\tpatt.opts.InjectRequestHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-Access-Token\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"access_token\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\terr := validation.Validate(patt.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproviderURL, _ := url.Parse(patt.providerServer.URL)\n\tconst emailAddress = \"michael.bland@gsa.gov\"\n\n\ttestProvider := NewTestProvider(providerURL, emailAddress)\n\ttestProvider.ValidToken = opts.ValidToken\n\tpatt.proxy, err = NewOAuthProxy(patt.opts, func(email string) bool {\n\t\treturn email == emailAddress\n\t})\n\tpatt.proxy.provider = testProvider\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn patt, nil\n}\n\nfunc (patTest *PassAccessTokenTest) Close() {\n\tpatTest.providerServer.Close()\n}\n\nfunc (patTest *PassAccessTokenTest) getCallbackEndpoint() (httpCode int, cookie string) {\n\trw := httptest.NewRecorder()\n\n\tcsrf, err := cookies.NewCSRF(patTest.proxy.CookieOptions, \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treq, err := http.NewRequest(\n\t\thttp.MethodGet,\n\t\tfmt.Sprintf(\n\t\t\t\"/oauth2/callback?code=callback_code&state=%s\",\n\t\t\tencodeState(csrf.HashOAuthState(), \"%2F\", false),\n\t\t),\n\t\tstrings.NewReader(\"\"),\n\t)\n\tif err != nil {\n\t\treturn 0, \"\"\n\t}\n\n\t// rw is a dummy here, we just want the csrfCookie to add to our req\n\tcsrfCookie, err := csrf.SetCookie(httptest.NewRecorder(), req)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treq.AddCookie(csrfCookie)\n\n\tpatTest.proxy.ServeHTTP(rw, req)\n\n\tif len(rw.Header().Values(\"Set-Cookie\")) >= 2 {\n\t\tcookie = rw.Header().Values(\"Set-Cookie\")[1]\n\t}\n\n\treturn rw.Code, cookie\n}\n\n// getEndpointWithCookie makes a requests againt the oauthproxy with passed requestPath\n// and cookie and returns body and status code.\nfunc (patTest *PassAccessTokenTest) getEndpointWithCookie(cookie string, endpoint string) (httpCode int, accessToken string) {\n\tcookieName := patTest.proxy.CookieOptions.Name\n\tvar value string\n\tkeyPrefix := cookieName + \"=\"\n\n\tfor _, field := range strings.Split(cookie, \"; \") {\n\t\tvalue = strings.TrimPrefix(field, keyPrefix)\n\t\tif value != field {\n\t\t\tbreak\n\t\t}\n\t\tvalue = \"\"\n\t}\n\tif value == \"\" {\n\t\treturn 0, \"\"\n\t}\n\n\treq, err := http.NewRequest(\"GET\", endpoint, strings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, \"\"\n\t}\n\treq.AddCookie(&http.Cookie{\n\t\tName:     cookieName,\n\t\tValue:    value,\n\t\tPath:     \"/\",\n\t\tExpires:  time.Now().Add(time.Duration(24)),\n\t\tHttpOnly: true,\n\t})\n\n\trw := httptest.NewRecorder()\n\tpatTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Body.String()\n}\n\nfunc TestForwardAccessTokenUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: true,\n\t\tValidToken:      true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotNil(t, cookie)\n\n\t// Now we make a regular request; the access_token from the cookie is\n\t// forwarded as the \"X-Forwarded-Access-Token\" header. The token is\n\t// read by the test provider server and written in the response body.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"my_auth_token\", payload)\n}\n\nfunc TestStaticProxyUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: true,\n\t\tValidToken:      true,\n\t\tProxyUpstream: options.Upstream{\n\t\t\tID:     \"static-proxy\",\n\t\t\tPath:   \"/static-proxy\",\n\t\t\tStatic: true,\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotEqual(t, nil, cookie)\n\n\t// Now we make a regular request against the upstream proxy; And validate\n\t// the returned status code through the static proxy.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/static-proxy\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"Authenticated\", payload)\n}\n\nfunc TestDoNotForwardAccessTokenUpstream(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tPassAccessToken: false,\n\t\tValidToken:      true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tt.Cleanup(patTest.Close)\n\n\t// A successful validation will redirect and set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tif code != 302 {\n\t\tt.Fatalf(\"expected 302; got %d\", code)\n\t}\n\tassert.NotEqual(t, nil, cookie)\n\n\t// Now we make a regular request, but the access token header should\n\t// not be present.\n\tcode, payload := patTest.getEndpointWithCookie(cookie, \"/\")\n\tif code != 200 {\n\t\tt.Fatalf(\"expected 200; got %d\", code)\n\t}\n\tassert.Equal(t, \"No access token found.\", payload)\n}\n\nfunc TestSessionValidationFailure(t *testing.T) {\n\tpatTest, err := NewPassAccessTokenTest(PassAccessTokenTestOptions{\n\t\tValidToken: false,\n\t})\n\trequire.NoError(t, err)\n\tt.Cleanup(patTest.Close)\n\n\t// An unsuccessful validation will return 403 and not set the auth cookie.\n\tcode, cookie := patTest.getCallbackEndpoint()\n\tassert.Equal(t, http.StatusForbidden, code)\n\tassert.Equal(t, \"\", cookie)\n}\n\ntype SignInPageTest struct {\n\topts                 *options.Options\n\tproxy                *OAuthProxy\n\tsignInRegexp         *regexp.Regexp\n\tsignInProviderRegexp *regexp.Regexp\n}\n\nconst (\n\tsignInRedirectPattern = `<input type=\"hidden\" name=\"rd\" value=\"(.*)\">`\n\tsignInSkipProvider    = `>Found<`\n\tpatternNotFound       = \"Did not find pattern in body: \"\n)\n\nfunc NewSignInPageTest(skipProvider bool) (*SignInPageTest, error) {\n\tvar sipTest SignInPageTest\n\n\tsipTest.opts = baseTestOptions()\n\tsipTest.opts.SkipProviderButton = skipProvider\n\terr := validation.Validate(sipTest.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsipTest.proxy, err = NewOAuthProxy(sipTest.opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tsipTest.signInRegexp = regexp.MustCompile(signInRedirectPattern)\n\tsipTest.signInProviderRegexp = regexp.MustCompile(signInSkipProvider)\n\n\treturn &sipTest, nil\n}\n\nfunc (sipTest *SignInPageTest) GetEndpoint(endpoint string) (int, string) {\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"GET\", endpoint, strings.NewReader(\"\"))\n\tsipTest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Body.String()\n}\n\ntype AlwaysSuccessfulValidator struct {\n}\n\nfunc (AlwaysSuccessfulValidator) Validate(_, _ string) bool {\n\treturn true\n}\n\nfunc TestManualSignInStoresUserGroupsInTheSession(t *testing.T) {\n\tuserGroups := []string{\"somegroup\", \"someothergroup\"}\n\n\topts := baseTestOptions()\n\topts.HtpasswdUserGroups = userGroups\n\terr := validation.Validate(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tproxy.basicAuthValidator = AlwaysSuccessfulValidator{}\n\n\trw := httptest.NewRecorder()\n\tformData := url.Values{}\n\tformData.Set(\"username\", \"someuser\")\n\tformData.Set(\"password\", \"somepass\")\n\tsignInReq, _ := http.NewRequest(http.MethodPost, \"/oauth2/sign_in\", strings.NewReader(formData.Encode()))\n\tsignInReq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tproxy.ServeHTTP(rw, signInReq)\n\n\tassert.Equal(t, http.StatusFound, rw.Code)\n\n\treq, _ := http.NewRequest(http.MethodGet, \"/something\", strings.NewReader(formData.Encode()))\n\tfor _, c := range rw.Result().Cookies() {\n\t\treq.AddCookie(c)\n\t}\n\n\ts, err := proxy.sessionStore.Load(req)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassert.Equal(t, userGroups, s.Groups)\n}\n\ntype ManualSignInValidator struct{}\n\nfunc (ManualSignInValidator) Validate(user, password string) bool {\n\tswitch {\n\tcase user == \"admin\" && password == \"adminPass\":\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc ManualSignInWithCredentials(t *testing.T, user, pass string) int {\n\topts := baseTestOptions()\n\terr := validation.Validate(opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproxy, err := NewOAuthProxy(opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tproxy.basicAuthValidator = ManualSignInValidator{}\n\n\trw := httptest.NewRecorder()\n\tformData := url.Values{}\n\tformData.Set(\"username\", user)\n\tformData.Set(\"password\", pass)\n\tsignInReq, _ := http.NewRequest(http.MethodPost, \"/oauth2/sign_in\", strings.NewReader(formData.Encode()))\n\tsignInReq.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\tproxy.ServeHTTP(rw, signInReq)\n\n\treturn rw.Code\n}\n\nfunc TestManualSignInEmptyUsernameAlert(t *testing.T) {\n\tstatusCode := ManualSignInWithCredentials(t, \"\", \"\")\n\tassert.Equal(t, http.StatusBadRequest, statusCode)\n}\n\nfunc TestManualSignInInvalidCredentialsAlert(t *testing.T) {\n\tstatusCode := ManualSignInWithCredentials(t, \"admin\", \"\")\n\tassert.Equal(t, http.StatusUnauthorized, statusCode)\n}\n\nfunc TestManualSignInCorrectCredentials(t *testing.T) {\n\tstatusCode := ManualSignInWithCredentials(t, \"admin\", \"adminPass\")\n\tassert.Equal(t, http.StatusFound, statusCode)\n}\n\nfunc TestSignInPageIncludesTargetRedirect(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconst endpoint = \"/some/random/endpoint\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 403, code)\n\n\tmatch := sipTest.signInRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(patternNotFound +\n\t\t\tsignInRedirectPattern + \"\\nBody:\\n\" + body)\n\t}\n\tif match[1] != endpoint {\n\t\tt.Fatal(`expected redirect to \"` + endpoint +\n\t\t\t`\", but was \"` + match[1] + `\"`)\n\t}\n}\n\nfunc TestSignInPageInvalidQueryStringReturnsBadRequest(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tconst endpoint = \"/?q=%va\"\n\n\tcode, _ := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 400, code)\n}\n\nfunc TestSignInPageDirectAccessRedirectsToRoot(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, body := sipTest.GetEndpoint(\"/oauth2/sign_in\")\n\tassert.Equal(t, 200, code)\n\n\tmatch := sipTest.signInRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(patternNotFound +\n\t\t\tsignInRedirectPattern + \"\\nBody:\\n\" + body)\n\t}\n\tif match[1] != \"/\" {\n\t\tt.Fatal(`expected redirect to \"/\", but was \"` + match[1] + `\"`)\n\t}\n}\n\nfunc TestSignInPageSkipProvider(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tendpoint := \"/some/random/endpoint\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 302, code)\n\n\tmatch := sipTest.signInProviderRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(patternNotFound +\n\t\t\tsignInSkipProvider + \"\\nBody:\\n\" + body)\n\t}\n}\n\nfunc TestSignInPageSkipProviderDirect(t *testing.T) {\n\tsipTest, err := NewSignInPageTest(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tendpoint := \"/sign_in\"\n\n\tcode, body := sipTest.GetEndpoint(endpoint)\n\tassert.Equal(t, 302, code)\n\n\tmatch := sipTest.signInProviderRegexp.FindStringSubmatch(body)\n\tif match == nil {\n\t\tt.Fatal(patternNotFound +\n\t\t\tsignInSkipProvider + \"\\nBody:\\n\" + body)\n\t}\n}\n\ntype ProcessCookieTest struct {\n\topts         *options.Options\n\tproxy        *OAuthProxy\n\trw           *httptest.ResponseRecorder\n\treq          *http.Request\n\tvalidateUser bool\n}\n\ntype ProcessCookieTestOpts struct {\n\tproviderValidateCookieResponse bool\n}\n\ntype OptionsModifier func(*options.Options)\n\nfunc NewProcessCookieTest(opts ProcessCookieTestOpts, modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tfor _, modifier := range modifiers {\n\t\tmodifier(pcTest.opts)\n\t}\n\t// First, set the CookieRefresh option so proxy.AesCipher is created,\n\t// needed to encrypt the access_token.\n\tpcTest.opts.Cookie.Refresh = time.Hour\n\terr := validation.Validate(pcTest.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttestProvider := &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   opts.providerValidateCookieResponse,\n\t}\n\n\tgroups := pcTest.opts.Providers[0].AllowedGroups\n\ttestProvider.ProviderData.AllowedGroups = make(map[string]struct{}, len(groups))\n\tfor _, group := range groups {\n\t\ttestProvider.ProviderData.AllowedGroups[group] = struct{}{}\n\t}\n\tpcTest.proxy.provider = testProvider\n\n\t// Now, zero-out proxy.CookieRefresh for the cases that don't involve\n\t// access_token validation.\n\tpcTest.proxy.CookieOptions.Refresh = time.Duration(0)\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\", \"/\", strings.NewReader(\"\"))\n\tpcTest.validateUser = true\n\treturn &pcTest, nil\n}\n\nfunc NewProcessCookieTestWithDefaults() (*ProcessCookieTest, error) {\n\treturn NewProcessCookieTest(ProcessCookieTestOpts{\n\t\tproviderValidateCookieResponse: true,\n\t})\n}\n\nfunc NewProcessCookieTestWithOptionsModifiers(modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\treturn NewProcessCookieTest(ProcessCookieTestOpts{\n\t\tproviderValidateCookieResponse: true,\n\t}, modifiers...)\n}\n\nfunc (p *ProcessCookieTest) SaveSession(s *sessions.SessionState) error {\n\terr := p.proxy.SaveSession(p.rw, p.req, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, cookie := range p.rw.Result().Cookies() {\n\t\tp.req.AddCookie(cookie)\n\t}\n\treturn nil\n}\n\nfunc (p *ProcessCookieTest) LoadCookiedSession() (*sessions.SessionState, error) {\n\treturn p.proxy.LoadCookiedSession(p.req)\n}\n\nfunc TestLoadCookiedSession(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{Email: \"john.doe@example.com\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tassert.Equal(t, startSession.Email, session.Email)\n\tassert.Equal(t, \"\", session.User)\n\tassert.Equal(t, startSession.AccessToken, session.AccessToken)\n}\n\nfunc TestProcessCookieNoCookieError(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.Error(t, err, \"cookie \\\"_oauth2_proxy\\\" not present\")\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session. got %#v\", session)\n\t}\n}\n\nfunc TestProcessCookieRefreshNotSet(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(23) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(-2) * time.Hour)\n\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.Equal(t, nil, err)\n\tif session.Age() < time.Duration(-2)*time.Hour {\n\t\tt.Errorf(\"cookie too young %v\", session.Age())\n\t}\n\tassert.Equal(t, startSession.Email, session.Email)\n}\n\nfunc TestProcessCookieFailIfCookieExpired(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.NotEqual(t, nil, err)\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session %#v\", session)\n\t}\n}\n\nfunc TestProcessCookieFailIfRefreshSetAndCookieExpired(t *testing.T) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{Email: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.CookieOptions.Refresh = time.Hour\n\tsession, err := pcTest.LoadCookiedSession()\n\tassert.NotEqual(t, nil, err)\n\tif session != nil {\n\t\tt.Errorf(\"expected nil session %#v\", session)\n\t}\n}\n\nfunc NewUserInfoEndpointTest() (*ProcessCookieTest, error) {\n\tpcTest, err := NewProcessCookieTestWithDefaults()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+\"/userinfo\", nil)\n\treturn pcTest, nil\n}\n\nfunc TestUserInfoEndpointAccepted(t *testing.T) {\n\ttestCases := []struct {\n\t\tname             string\n\t\tsession          *sessions.SessionState\n\t\texpectedResponse string\n\t}{\n\t\t{\n\t\t\tname: \"Full session\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:        \"john.doe\",\n\t\t\t\tEmail:       \"john.doe@example.com\",\n\t\t\t\tGroups:      []string{\"example\", \"groups\"},\n\t\t\t\tAccessToken: \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"]}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"Minimal session\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:   \"john.doe\",\n\t\t\t\tEmail:  \"john.doe@example.com\",\n\t\t\t\tGroups: []string{\"example\", \"groups\"},\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"]}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"No groups\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:        \"john.doe\",\n\t\t\t\tEmail:       \"john.doe@example.com\",\n\t\t\t\tAccessToken: \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\"}\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"With Preferred Username\",\n\t\t\tsession: &sessions.SessionState{\n\t\t\t\tUser:              \"john.doe\",\n\t\t\t\tPreferredUsername: \"john\",\n\t\t\t\tEmail:             \"john.doe@example.com\",\n\t\t\t\tGroups:            []string{\"example\", \"groups\"},\n\t\t\t\tAccessToken:       \"my_access_token\",\n\t\t\t},\n\t\t\texpectedResponse: \"{\\\"user\\\":\\\"john.doe\\\",\\\"email\\\":\\\"john.doe@example.com\\\",\\\"groups\\\":[\\\"example\\\",\\\"groups\\\"],\\\"preferredUsername\\\":\\\"john\\\"}\\n\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttest, err := NewUserInfoEndpointTest()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\terr = test.SaveSession(tc.session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\t\t\tassert.Equal(t, http.StatusOK, test.rw.Code)\n\t\t\tbodyBytes, _ := io.ReadAll(test.rw.Body)\n\t\t\tassert.Equal(t, tc.expectedResponse, string(bodyBytes))\n\t\t})\n\t}\n}\n\nfunc TestUserInfoEndpointUnauthorizedOnNoCookieSetError(t *testing.T) {\n\ttest, err := NewUserInfoEndpointTest()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n}\n\nfunc TestEncodedUrlsStayEncoded(t *testing.T) {\n\tencodeTest, err := NewSignInPageTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tcode, _ := encodeTest.GetEndpoint(\"/%2F/test1/%2F/test2\")\n\tassert.Equal(t, 403, code)\n}\n\nfunc NewAuthOnlyEndpointTest(querystring string, modifiers ...OptionsModifier) (*ProcessCookieTest, error) {\n\tpcTest, err := NewProcessCookieTestWithOptionsModifiers(modifiers...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpcTest.req, _ = http.NewRequest(\n\t\t\"GET\",\n\t\tfmt.Sprintf(\"%s/auth%s\", pcTest.opts.ProxyPrefix, querystring),\n\t\tnil)\n\treturn pcTest, nil\n}\n\nfunc TestAuthOnlyEndpointAccepted(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusAccepted, test.rw.Code)\n\tbodyBytes, _ := io.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnNoCookieSetError(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := io.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnExpiration(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\", func(opts *options.Options) {\n\t\topts.Cookie.Expire = time.Duration(24) * time.Hour\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treference := time.Now().Add(time.Duration(25) * time.Hour * -1)\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &reference}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := io.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointUnauthorizedOnEmailValidationFailure(t *testing.T) {\n\ttest, err := NewAuthOnlyEndpointTest(\"\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tEmail: \"michael.bland@gsa.gov\", AccessToken: \"my_access_token\", CreatedAt: &created}\n\terr = test.SaveSession(startSession)\n\tassert.NoError(t, err)\n\ttest.validateUser = false\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tassert.Equal(t, http.StatusUnauthorized, test.rw.Code)\n\tbodyBytes, _ := io.ReadAll(test.rw.Body)\n\tassert.Equal(t, \"Unauthorized\\n\", string(bodyBytes))\n}\n\nfunc TestAuthOnlyEndpointSetXAuthRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tpcTest.opts.Providers[0].AllowedGroups = []string{\"oauth_groups\"}\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+authOnlyPath, nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Groups: []string{\"oauth_groups\"}, Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Get(\"X-Auth-Request-User\"))\n\tassert.Equal(t, startSession.Groups, pcTest.rw.Header().Values(\"X-Auth-Request-Groups\"))\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Get(\"X-Auth-Request-Email\"))\n}\n\nfunc TestAuthOnlyEndpointSetBasicAuthTrueRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(\"This is a secure password\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+authOnlyPath, nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Values(\"X-Auth-Request-User\")[0])\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Values(\"X-Auth-Request-Email\")[0])\n\texpectedHeader := \"Basic \" + base64.StdEncoding.EncodeToString([]byte(\"oauth_user:This is a secure password\"))\n\tassert.Equal(t, expectedHeader, pcTest.rw.Header().Values(\"Authorization\")[0])\n}\n\nfunc TestAuthOnlyEndpointSetBasicAuthFalseRequestHeaders(t *testing.T) {\n\tvar pcTest ProcessCookieTest\n\n\tpcTest.opts = baseTestOptions()\n\tpcTest.opts.InjectResponseHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"X-Auth-Request-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Auth-Request-Groups\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"groups\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Preferred-Username\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"preferred_username\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\terr := validation.Validate(pcTest.opts)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy, err = NewOAuthProxy(pcTest.opts, func(email string) bool {\n\t\treturn pcTest.validateUser\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpcTest.proxy.provider = &TestProvider{\n\t\tProviderData: &providers.ProviderData{},\n\t\tValidToken:   true,\n\t}\n\n\tpcTest.validateUser = true\n\n\tpcTest.rw = httptest.NewRecorder()\n\tpcTest.req, _ = http.NewRequest(\"GET\",\n\t\tpcTest.opts.ProxyPrefix+authOnlyPath, nil)\n\n\tcreated := time.Now()\n\tstartSession := &sessions.SessionState{\n\t\tUser: \"oauth_user\", Email: \"oauth_user@example.com\", AccessToken: \"oauth_token\", CreatedAt: &created}\n\terr = pcTest.SaveSession(startSession)\n\tassert.NoError(t, err)\n\n\tpcTest.proxy.ServeHTTP(pcTest.rw, pcTest.req)\n\tassert.Equal(t, http.StatusAccepted, pcTest.rw.Code)\n\tassert.Equal(t, \"oauth_user\", pcTest.rw.Header().Values(\"X-Auth-Request-User\")[0])\n\tassert.Equal(t, \"oauth_user@example.com\", pcTest.rw.Header().Values(\"X-Auth-Request-Email\")[0])\n\tassert.Equal(t, 0, len(pcTest.rw.Header().Values(\"Authorization\")), \"should not have Authorization header entries\")\n}\n\nfunc TestAuthSkippedForPreflightRequests(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"response\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\topts.SkipAuthPreflight = true\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tupstreamURL, _ := url.Parse(upstreamServer.URL)\n\n\tproxy, err := NewOAuthProxy(opts, func(string) bool { return false })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tproxy.provider = NewTestProvider(upstreamURL, \"\")\n\trw := httptest.NewRecorder()\n\treq, _ := http.NewRequest(\"OPTIONS\", \"/preflight-request\", nil)\n\tproxy.ServeHTTP(rw, req)\n\n\tassert.Equal(t, 200, rw.Code)\n\tassert.Equal(t, \"response\", rw.Body.String())\n}\n\ntype SignatureAuthenticator struct {\n\tauth hmacauth.HmacAuth\n}\n\nfunc (v *SignatureAuthenticator) Authenticate(w http.ResponseWriter, r *http.Request) {\n\tresult, headerSig, computedSig := v.auth.AuthenticateRequest(r)\n\n\tvar msg string\n\tswitch result {\n\tcase hmacauth.ResultNoSignature:\n\t\tmsg = \"no signature received\"\n\tcase hmacauth.ResultMatch:\n\t\tmsg = \"signatures match\"\n\tcase hmacauth.ResultMismatch:\n\t\tmsg = fmt.Sprintf(\n\t\t\t\"signatures do not match:\\n  received: %s\\n  computed: %s\",\n\t\t\theaderSig,\n\t\t\tcomputedSig)\n\tdefault:\n\t\tpanic(\"unknown result value: \" + result.String())\n\t}\n\n\t_, err := w.Write([]byte(msg))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\ntype SignatureTest struct {\n\topts          *options.Options\n\tupstream      *httptest.Server\n\tupstreamHost  string\n\tprovider      *httptest.Server\n\theader        http.Header\n\trw            *httptest.ResponseRecorder\n\tauthenticator *SignatureAuthenticator\n\tauthProvider  providers.Provider\n}\n\nfunc NewSignatureTest() (*SignatureTest, error) {\n\topts := baseTestOptions()\n\topts.EmailDomains = []string{\"acm.org\"}\n\n\tauthenticator := &SignatureAuthenticator{}\n\tupstreamServer := httptest.NewServer(\n\t\thttp.HandlerFunc(authenticator.Authenticate))\n\tupstreamURL, err := url.Parse(upstreamServer.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\n\tproviderHandler := func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := w.Write([]byte(`{\"access_token\": \"my_auth_token\"}`))\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\tprovider := httptest.NewServer(http.HandlerFunc(providerHandler))\n\tproviderURL, err := url.Parse(provider.URL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttestProvider := NewTestProvider(providerURL, \"mbland@acm.org\")\n\n\treturn &SignatureTest{\n\t\topts,\n\t\tupstreamServer,\n\t\tupstreamURL.Host,\n\t\tprovider,\n\t\tmake(http.Header),\n\t\thttptest.NewRecorder(),\n\t\tauthenticator,\n\t\ttestProvider,\n\t}, nil\n}\n\nfunc (st *SignatureTest) Close() {\n\tst.provider.Close()\n\tst.upstream.Close()\n}\n\n// fakeNetConn simulates an http.Request.Body buffer that will be consumed\n// when it is read by the hmacauth.HmacAuth if not handled properly. See:\n//\n//\thttps://github.com/18F/hmacauth/pull/4\ntype fakeNetConn struct {\n\treqBody string\n}\n\nfunc (fnc *fakeNetConn) Read(p []byte) (n int, err error) {\n\tif bodyLen := len(fnc.reqBody); bodyLen != 0 {\n\t\tcopy(p, fnc.reqBody)\n\t\tfnc.reqBody = \"\"\n\t\treturn bodyLen, io.EOF\n\t}\n\treturn 0, io.EOF\n}\n\nfunc (st *SignatureTest) MakeRequestWithExpectedKey(method, body, key string) error {\n\terr := validation.Validate(st.opts)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy, err := NewOAuthProxy(st.opts, func(email string) bool { return true })\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.provider = st.authProvider\n\n\tvar bodyBuf io.ReadCloser\n\tif body != \"\" {\n\t\tbodyBuf = io.NopCloser(&fakeNetConn{reqBody: body})\n\t}\n\treq := httptest.NewRequest(method, \"/foo/bar\", bodyBuf)\n\treq.Header = st.header\n\n\tstate := &sessions.SessionState{\n\t\tEmail: \"mbland@acm.org\", AccessToken: \"my_access_token\"}\n\terr = proxy.SaveSession(st.rw, req, state)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, c := range st.rw.Result().Cookies() {\n\t\treq.AddCookie(c)\n\t}\n\t// This is used by the upstream to validate the signature.\n\tst.authenticator.auth = hmacauth.NewHmacAuth(\n\t\tcrypto.SHA1, []byte(key), upstream.SignatureHeader, upstream.SignatureHeaders)\n\tproxy.ServeHTTP(st.rw, req)\n\n\treturn nil\n}\n\nfunc TestRequestSignature(t *testing.T) {\n\ttestCases := map[string]struct {\n\t\tmethod string\n\t\tbody   string\n\t\tkey    string\n\t\tresp   string\n\t}{\n\t\t\"No request signature\": {\n\t\t\tmethod: \"GET\",\n\t\t\tbody:   \"\",\n\t\t\tkey:    \"\",\n\t\t\tresp:   \"no signature received\",\n\t\t},\n\t\t\"Get request\": {\n\t\t\tmethod: \"GET\",\n\t\t\tbody:   \"\",\n\t\t\tkey:    \"7d9e1aa87a5954e6f9fc59266b3af9d7c35fda2d\",\n\t\t\tresp:   \"signatures match\",\n\t\t},\n\t\t\"Post request\": {\n\t\t\tmethod: \"POST\",\n\t\t\tbody:   `{ \"hello\": \"world!\" }`,\n\t\t\tkey:    \"d90df39e2d19282840252612dd7c81421a372f61\",\n\t\t\tresp:   \"signatures match\",\n\t\t},\n\t}\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tst, err := NewSignatureTest()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tt.Cleanup(st.Close)\n\t\t\tif tc.key != \"\" {\n\t\t\t\tst.opts.SignatureKey = fmt.Sprintf(\"sha1:%s\", tc.key)\n\t\t\t}\n\t\t\terr = st.MakeRequestWithExpectedKey(tc.method, tc.body, tc.key)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, 200, st.rw.Code)\n\t\t\tassert.Equal(t, tc.resp, st.rw.Body.String())\n\t\t})\n\t}\n}\n\ntype ajaxRequestTest struct {\n\topts  *options.Options\n\tproxy *OAuthProxy\n}\n\nfunc newAjaxRequestTest(forceJSONErrors bool) (*ajaxRequestTest, error) {\n\ttest := &ajaxRequestTest{}\n\ttest.opts = baseTestOptions()\n\ttest.opts.ForceJSONErrors = forceJSONErrors\n\terr := validation.Validate(test.opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttest.proxy, err = NewOAuthProxy(test.opts, func(email string) bool {\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn test, nil\n}\n\nfunc (test *ajaxRequestTest) getEndpoint(endpoint string, header http.Header) (int, http.Header, []byte, error) {\n\trw := httptest.NewRecorder()\n\treq, err := http.NewRequest(http.MethodGet, endpoint, strings.NewReader(\"\"))\n\tif err != nil {\n\t\treturn 0, nil, nil, err\n\t}\n\treq.Header = header\n\ttest.proxy.ServeHTTP(rw, req)\n\treturn rw.Code, rw.Header(), rw.Body.Bytes(), nil\n}\n\nfunc testAjaxUnauthorizedRequest(t *testing.T, header http.Header, forceJSONErrors bool) {\n\ttest, err := newAjaxRequestTest(forceJSONErrors)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tendpoint := \"/test\"\n\n\tcode, rh, body, err := test.getEndpoint(endpoint, header)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusUnauthorized, code)\n\tmime := rh.Get(\"Content-Type\")\n\tassert.Equal(t, applicationJSON, mime)\n\tassert.Equal(t, []byte(\"{}\"), body)\n}\nfunc TestAjaxUnauthorizedRequest1(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"accept\", applicationJSON)\n\n\ttestAjaxUnauthorizedRequest(t, header, false)\n}\n\nfunc TestAjaxUnauthorizedRequest2(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"Accept\", applicationJSON)\n\n\ttestAjaxUnauthorizedRequest(t, header, false)\n}\n\nfunc TestAjaxUnauthorizedRequestAccept1(t *testing.T) {\n\theader := make(http.Header)\n\theader.Add(\"Accept\", \"application/json, text/plain, */*\")\n\n\ttestAjaxUnauthorizedRequest(t, header, false)\n}\n\nfunc TestForceJSONErrorsUnauthorizedRequest(t *testing.T) {\n\ttestAjaxUnauthorizedRequest(t, nil, true)\n}\n\nfunc TestAjaxForbiddendRequest(t *testing.T) {\n\ttest, err := newAjaxRequestTest(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tendpoint := \"/test\"\n\theader := make(http.Header)\n\tcode, rh, _, err := test.getEndpoint(endpoint, header)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusForbidden, code)\n\tmime := rh.Get(\"Content-Type\")\n\tassert.NotEqual(t, applicationJSON, mime)\n}\n\nfunc TestClearSplitCookie(t *testing.T) {\n\topts := baseTestOptions()\n\topts.Cookie.Secret = base64CookieSecret\n\topts.Cookie.Name = \"oauth2\"\n\topts.Cookie.Domains = []string{\"abc\"}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\n\tstore, err := sessionscookie.NewCookieSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp := OAuthProxy{CookieOptions: &opts.Cookie, sessionStore: store}\n\tvar rw = httptest.NewRecorder()\n\treq := httptest.NewRequest(\"get\", \"/\", nil)\n\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"test1\",\n\t\tValue: \"test1\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2_0\",\n\t\tValue: \"oauth2_0\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2_1\",\n\t\tValue: \"oauth2_1\",\n\t})\n\n\terr = p.ClearSessionCookie(rw, req)\n\tassert.NoError(t, err)\n\theader := rw.Header()\n\n\tassert.Equal(t, 2, len(header[\"Set-Cookie\"]), \"should have 3 set-cookie header entries\")\n}\n\nfunc TestClearSingleCookie(t *testing.T) {\n\topts := baseTestOptions()\n\topts.Cookie.Name = \"oauth2\"\n\topts.Cookie.Domains = []string{\"abc\"}\n\tstore, err := sessionscookie.NewCookieSessionStore(&opts.Session, &opts.Cookie)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tp := OAuthProxy{CookieOptions: &opts.Cookie, sessionStore: store}\n\tvar rw = httptest.NewRecorder()\n\treq := httptest.NewRequest(\"get\", \"/\", nil)\n\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"test1\",\n\t\tValue: \"test1\",\n\t})\n\treq.AddCookie(&http.Cookie{\n\t\tName:  \"oauth2\",\n\t\tValue: \"oauth2\",\n\t})\n\n\terr = p.ClearSessionCookie(rw, req)\n\tassert.NoError(t, err)\n\theader := rw.Header()\n\n\tassert.Equal(t, 1, len(header[\"Set-Cookie\"]), \"should have 1 set-cookie header entries\")\n}\n\ntype NoOpKeySet struct {\n}\n\nfunc (NoOpKeySet) VerifySignature(_ context.Context, jwt string) (payload []byte, err error) {\n\tsplitStrings := strings.Split(jwt, \".\")\n\tpayloadString := splitStrings[1]\n\treturn base64.RawURLEncoding.DecodeString(payloadString)\n}\n\nfunc TestGetJwtSession(t *testing.T) {\n\t/* token payload:\n\t{\n\t  \"sub\": \"1234567890\",\n\t  \"aud\": \"https://test.myapp.com\",\n\t  \"name\": \"John Doe\",\n\t  \"email\": \"john@example.com\",\n\t  \"iss\": \"https://issuer.example.com\",\n\t  \"iat\": 1553691215,\n\t  \"exp\": 1912151821\n\t}\n\t*/\n\tgoodJwt := \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\" +\n\t\t\"eyJzdWIiOiIxMjM0NTY3ODkwIiwiYXVkIjoiaHR0cHM6Ly90ZXN0Lm15YXBwLmNvbSIsIm5hbWUiOiJKb2huIERvZSIsImVtY\" +\n\t\t\"WlsIjoiam9obkBleGFtcGxlLmNvbSIsImlzcyI6Imh0dHBzOi8vaXNzdWVyLmV4YW1wbGUuY29tIiwiaWF0IjoxNTUzNjkxMj\" +\n\t\t\"E1LCJleHAiOjE5MTIxNTE4MjF9.\" +\n\t\t\"rLVyzOnEldUq_pNkfa-WiV8TVJYWyZCaM2Am_uo8FGg11zD7l-qmz3x1seTvqpH6Y0Ty00fmv6dJnGnC8WMnPXQiodRTfhBSe\" +\n\t\t\"OKZMu0HkMD2sg52zlKkbfLTO6ic5VnbVgwjjrB8am_Ta6w7kyFUaB5C1BsIrrLMldkWEhynbb8\"\n\n\tkeyset := NoOpKeySet{}\n\tverifier := oidc.NewVerifier(\"https://issuer.example.com\", keyset,\n\t\t&oidc.Config{ClientID: \"https://test.myapp.com\", SkipExpiryCheck: true,\n\t\t\tSkipClientIDCheck: true})\n\tverificationOptions := internaloidc.IDTokenVerificationOptions{\n\t\tAudienceClaims: []string{\"aud\"},\n\t\tClientID:       \"https://test.myapp.com\",\n\t\tExtraAudiences: []string{},\n\t}\n\tinternalVerifier := internaloidc.NewVerifier(verifier, verificationOptions)\n\n\ttest, err := NewAuthOnlyEndpointTest(\"\", func(opts *options.Options) {\n\t\topts.InjectRequestHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"Authorization\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim:  \"id_token\",\n\t\t\t\t\t\t\tPrefix: \"Bearer \",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-User\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Forwarded-Email\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\n\t\topts.InjectResponseHeaders = []options.Header{\n\t\t\t{\n\t\t\t\tName: \"Authorization\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim:  \"id_token\",\n\t\t\t\t\t\t\tPrefix: \"Bearer \",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Auth-Request-User\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"X-Auth-Request-Email\",\n\t\t\t\tValues: []options.HeaderValue{\n\t\t\t\t\t{\n\t\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\topts.SkipJwtBearerTokens = true\n\t\topts.SetJWTBearerVerifiers(append(opts.GetJWTBearerVerifiers(), internalVerifier))\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttp, _ := test.proxy.provider.(*TestProvider)\n\ttp.GroupValidator = func(s string) bool {\n\t\treturn true\n\t}\n\n\tauthHeader := fmt.Sprintf(\"Bearer %s\", goodJwt)\n\ttest.req.Header = map[string][]string{\n\t\t\"Authorization\": {authHeader},\n\t}\n\n\ttest.proxy.ServeHTTP(test.rw, test.req)\n\tif test.rw.Code >= 400 {\n\t\tt.Fatalf(\"expected 3xx got %d\", test.rw.Code)\n\t}\n\n\t// Check PassAuthorization, should overwrite Basic header\n\tassert.Equal(t, test.req.Header.Get(\"Authorization\"), authHeader)\n\tassert.Equal(t, test.req.Header.Get(\"X-Forwarded-User\"), \"1234567890\")\n\tassert.Equal(t, test.req.Header.Get(\"X-Forwarded-Email\"), \"john@example.com\")\n\n\t// SetAuthorization and SetXAuthRequest\n\tassert.Equal(t, test.rw.Header().Get(\"Authorization\"), authHeader)\n\tassert.Equal(t, test.rw.Header().Get(\"X-Auth-Request-User\"), \"1234567890\")\n\tassert.Equal(t, test.rw.Header().Get(\"X-Auth-Request-Email\"), \"john@example.com\")\n}\n\nfunc Test_prepareNoCache(t *testing.T) {\n\thandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tprepareNoCache(w)\n\t})\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/\", handler)\n\n\trec := httptest.NewRecorder()\n\treq := httptest.NewRequest(http.MethodGet, \"/\", nil)\n\tmux.ServeHTTP(rec, req)\n\n\tfor k, v := range noCacheHeaders {\n\t\tassert.Equal(t, rec.Header().Get(k), v)\n\t}\n}\n\nfunc Test_noCacheHeaders(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t_, err := w.Write([]byte(\"upstream\"))\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\topts.SkipAuthRegex = []string{\".*\"}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tt.Run(\"not exist in response from upstream\", func(t *testing.T) {\n\t\trec := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodGet, \"/upstream\", nil)\n\t\tproxy.ServeHTTP(rec, req)\n\n\t\tassert.Equal(t, http.StatusOK, rec.Code)\n\t\tassert.Equal(t, \"upstream\", rec.Body.String())\n\n\t\t// checking noCacheHeaders does not exists in response headers from upstream\n\t\tfor k := range noCacheHeaders {\n\t\t\tassert.Equal(t, \"\", rec.Header().Get(k))\n\t\t}\n\t})\n\n\tt.Run(\"has no-cache\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tpath       string\n\t\t\thasNoCache bool\n\t\t}{\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/sign_in\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/sign_out\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/start\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/callback\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/auth\",\n\t\t\t\thasNoCache: false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/oauth2/userinfo\",\n\t\t\t\thasNoCache: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpath:       \"/upstream\",\n\t\t\t\thasNoCache: false,\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.path, func(t *testing.T) {\n\t\t\t\trec := httptest.NewRecorder()\n\t\t\t\treq := httptest.NewRequest(http.MethodGet, tt.path, nil)\n\t\t\t\tproxy.ServeHTTP(rec, req)\n\t\t\t\tcacheControl := rec.Result().Header.Get(\"Cache-Control\")\n\t\t\t\tif tt.hasNoCache != (strings.Contains(cacheControl, \"no-cache\")) {\n\t\t\t\t\tt.Errorf(`unexpected \"Cache-Control\" header: %s`, cacheControl)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t})\n}\n\nfunc baseTestOptions() *options.Options {\n\topts := options.NewOptions()\n\topts.Cookie.Secret = rawCookieSecret\n\topts.Providers[0].ID = \"providerID\"\n\topts.Providers[0].ClientID = clientID\n\topts.Providers[0].ClientSecret = clientSecret\n\topts.EmailDomains = []string{\"*\"}\n\n\t// Default injected headers for legacy configuration\n\topts.InjectRequestHeaders = []options.Header{\n\t\t{\n\t\t\tName: \"Authorization\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t\tBasicAuthPassword: &options.SecretSource{\n\t\t\t\t\t\t\tValue: []byte(base64.StdEncoding.EncodeToString([]byte(\"This is a secure password\"))),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-User\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"user\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"X-Forwarded-Email\",\n\t\t\tValues: []options.HeaderValue{\n\t\t\t\t{\n\t\t\t\t\tClaimSource: &options.ClaimSource{\n\t\t\t\t\t\tClaim: \"email\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\treturn opts\n}\n\nfunc TestTrustedIPs(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\ttrustedIPs         []string\n\t\treverseProxy       bool\n\t\trealClientIPHeader string\n\t\treq                *http.Request\n\t\texpectTrusted      bool\n\t}{\n\t\t// Check unconfigured behavior.\n\t\t{\n\t\t\tname:               \"Default\",\n\t\t\ttrustedIPs:         nil,\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check using req.RemoteAddr (Options.ReverseProxy == false).\n\t\t{\n\t\t\tname:               \"WithRemoteAddr\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.1\"},\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"127.0.0.1:43670\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check ignores req.RemoteAddr match when behind a reverse proxy / missing header.\n\t\t{\n\t\t\tname:               \"IgnoresRemoteAddrInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Real-IP\", // Default value\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"127.0.0.1:44324\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check successful trusting of localhost in IPv4.\n\t\t{\n\t\t\tname:               \"TrustsLocalhostInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"127.0.0.1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check successful trusting of localhost in IPv6.\n\t\t{\n\t\t\tname:               \"TrustsIP6LocalostInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"::1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: true,\n\t\t},\n\t\t// Check does not trust random IPv4 address.\n\t\t{\n\t\t\tname:               \"DoesNotTrustRandomIP4Address\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"12.34.56.78\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check does not trust random IPv6 address.\n\t\t{\n\t\t\tname:               \"DoesNotTrustRandomIP6Address\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"::2\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check respects correct header.\n\t\t{\n\t\t\tname:               \"RespectsCorrectHeaderInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Real-IP\", \"::1\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check doesn't trust if garbage is provided.\n\t\t{\n\t\t\tname:               \"DoesNotTrustGarbageInReverseProxyMode\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       true,\n\t\t\trealClientIPHeader: \"X-Forwarded-For\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.Header.Add(\"X-Forwarded-For\", \"adsfljk29242as!!\")\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t\t// Check doesn't trust if garbage is provided (no reverse-proxy).\n\t\t{\n\t\t\tname:               \"DoesNotTrustGarbage\",\n\t\t\ttrustedIPs:         []string{\"127.0.0.0/8\", \"::1\"},\n\t\t\treverseProxy:       false,\n\t\t\trealClientIPHeader: \"X-Real-IP\",\n\t\t\treq: func() *http.Request {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\treq.RemoteAddr = \"adsfljk29242as!!\"\n\t\t\t\treturn req\n\t\t\t}(),\n\t\t\texpectTrusted: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\topts := baseTestOptions()\n\t\t\topts.UpstreamServers = options.UpstreamConfig{\n\t\t\t\tUpstreams: []options.Upstream{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:     \"static\",\n\t\t\t\t\t\tPath:   \"/\",\n\t\t\t\t\t\tStatic: true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\topts.TrustedIPs = tt.trustedIPs\n\t\t\topts.ReverseProxy = tt.reverseProxy\n\t\t\topts.RealClientIPHeader = tt.realClientIPHeader\n\t\t\terr := validation.Validate(opts)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tproxy, err := NewOAuthProxy(opts, func(string) bool { return true })\n\t\t\tassert.NoError(t, err)\n\t\t\trw := httptest.NewRecorder()\n\n\t\t\tproxy.ServeHTTP(rw, tt.req)\n\t\t\tif tt.expectTrusted {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_buildRoutesAllowlist(t *testing.T) {\n\ttype expectedAllowedRoute struct {\n\t\tmethod      string\n\t\tnegate      bool\n\t\tregexString string\n\t}\n\n\ttestCases := []struct {\n\t\tname           string\n\t\tskipAuthRegex  []string\n\t\tskipAuthRoutes []string\n\t\texpectedRoutes []expectedAllowedRoute\n\t\tshouldError    bool\n\t}{\n\t\t{\n\t\t\tname:           \"No skip auth configured\",\n\t\t\tskipAuthRegex:  []string{},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"Only skipAuthRegex configured\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar\",\n\t\t\t\t\"^/baz/[0-9]+/thing\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tnegate:      false,\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tnegate:      false,\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname:          \"Only skipAuthRoutes configured\",\n\t\t\tskipAuthRegex: []string{},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t\t\"WEIRD=^/methods/are/allowed\",\n\t\t\t\t\"PATCH=/second/equals?are=handled&just=fine\",\n\t\t\t\t\"!=^/api\",\n\t\t\t\t\"METHOD!=^/api\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"GET\",\n\t\t\t\t\tnegate:      false,\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"POST\",\n\t\t\t\t\tnegate:      false,\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tnegate:      false,\n\t\t\t\t\tregexString: \"^/all/methods$\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"WEIRD\",\n\t\t\t\t\tnegate:      false,\n\t\t\t\t\tregexString: \"^/methods/are/allowed\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"PATCH\",\n\t\t\t\t\tnegate:      false,\n\t\t\t\t\tregexString: \"/second/equals?are=handled&just=fine\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tnegate:      true,\n\t\t\t\t\tregexString: \"^/api\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"METHOD\",\n\t\t\t\t\tnegate:      true,\n\t\t\t\t\tregexString: \"^/api\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Both skipAuthRegexes and skipAuthRoutes configured\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar/regex\",\n\t\t\t\t\"^/baz/[0-9]+/thing/regex\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/foo/bar/regex\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing/regex\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"GET\",\n\t\t\t\t\tregexString: \"^/foo/bar\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"POST\",\n\t\t\t\t\tregexString: \"^/baz/[0-9]+/thing\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tmethod:      \"\",\n\t\t\t\t\tregexString: \"^/all/methods$\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tshouldError: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid skipAuthRegex entry\",\n\t\t\tskipAuthRegex: []string{\n\t\t\t\t\"^/foo/bar\",\n\t\t\t\t\"^/baz/[0-9]+/thing\",\n\t\t\t\t\"(bad[regex\",\n\t\t\t},\n\t\t\tskipAuthRoutes: []string{},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    true,\n\t\t},\n\t\t{\n\t\t\tname:          \"Invalid skipAuthRoutes entry\",\n\t\t\tskipAuthRegex: []string{},\n\t\t\tskipAuthRoutes: []string{\n\t\t\t\t\"GET=^/foo/bar\",\n\t\t\t\t\"POST=^/baz/[0-9]+/thing\",\n\t\t\t\t\"^/all/methods$\",\n\t\t\t\t\"PUT=(bad[regex\",\n\t\t\t},\n\t\t\texpectedRoutes: []expectedAllowedRoute{},\n\t\t\tshouldError:    true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\topts := &options.Options{\n\t\t\t\tSkipAuthRegex:  tc.skipAuthRegex,\n\t\t\t\tSkipAuthRoutes: tc.skipAuthRoutes,\n\t\t\t}\n\t\t\troutes, err := buildRoutesAllowlist(opts)\n\t\t\tif tc.shouldError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.NoError(t, err)\n\n\t\t\tfor i, route := range routes {\n\t\t\t\tassert.Greater(t, len(tc.expectedRoutes), i)\n\t\t\t\tassert.Equal(t, route.method, tc.expectedRoutes[i].method)\n\t\t\t\tassert.Equal(t, route.negate, tc.expectedRoutes[i].negate)\n\t\t\t\tassert.Equal(t, route.pathRegex.String(), tc.expectedRoutes[i].regexString)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestApiRoutes(t *testing.T) {\n\n\tajaxAPIServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"AJAX API Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(ajaxAPIServer.Close)\n\n\tapiServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"API Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(apiServer.Close)\n\n\tuiServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"API Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(uiServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   apiServer.URL,\n\t\t\t\tPath: \"/api\",\n\t\t\t\tURI:  apiServer.URL,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:   ajaxAPIServer.URL,\n\t\t\t\tPath: \"/ajaxapi\",\n\t\t\t\tURI:  ajaxAPIServer.URL,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:   uiServer.URL,\n\t\t\t\tPath: \"/ui\",\n\t\t\t\tURI:  uiServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\topts.APIRoutes = []string{\n\t\t\"^/api\",\n\t}\n\topts.SkipProviderButton = true\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tname           string\n\t\tcontentType    string\n\t\turl            string\n\t\tshouldRedirect bool\n\t}{\n\t\t{\n\t\t\tname:           \"AJAX request matching API regex\",\n\t\t\tcontentType:    \"application/json\",\n\t\t\turl:            \"/api/v1/UserInfo\",\n\t\t\tshouldRedirect: false,\n\t\t},\n\t\t{\n\t\t\tname:           \"AJAX request not matching API regex\",\n\t\t\tcontentType:    \"application/json\",\n\t\t\turl:            \"/ajaxapi/v1/UserInfo\",\n\t\t\tshouldRedirect: false,\n\t\t},\n\t\t{\n\t\t\tname:           \"Other Request matching API regex\",\n\t\t\tcontentType:    \"application/grpcwebtext\",\n\t\t\turl:            \"/api/v1/UserInfo\",\n\t\t\tshouldRedirect: false,\n\t\t},\n\t\t{\n\t\t\tname:           \"UI request\",\n\t\t\tcontentType:    \"html\",\n\t\t\turl:            \"/ui/index.html\",\n\t\t\tshouldRedirect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq, err := http.NewRequest(\"GET\", tc.url, nil)\n\t\t\treq.Header.Set(\"Accept\", tc.contentType)\n\t\t\tassert.NoError(t, err)\n\n\t\t\trw := httptest.NewRecorder()\n\t\t\tproxy.ServeHTTP(rw, req)\n\n\t\t\tif tc.shouldRedirect {\n\t\t\t\tassert.Equal(t, 302, rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 401, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllowedRequest(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"Allowed Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\topts.SkipAuthRegex = []string{\n\t\t\"^/skip/auth/regex$\",\n\t}\n\topts.SkipAuthRoutes = []string{\n\t\t\"GET=^/skip/auth/routes/get\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tmethod  string\n\t\turl     string\n\t\tallowed bool\n\t}{\n\t\t{\n\t\t\tname:    \"Regex GET allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST allowed \",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex denied\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/wrong/denied\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong method\",\n\t\t\tmethod:  \"PATCH\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong path\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/wrong/path\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong path and method\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/skip/auth/routes/wrong/path\",\n\t\t\tallowed: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq, err := http.NewRequest(tc.method, tc.url, nil)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.allowed, proxy.isAllowedRoute(req))\n\n\t\t\trw := httptest.NewRecorder()\n\t\t\tproxy.ServeHTTP(rw, req)\n\n\t\t\tif tc.allowed {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t\tassert.Equal(t, \"Allowed Request\", rw.Body.String())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllowedRequestWithForwardedUriHeader(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.ReverseProxy = true\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\topts.SkipAuthRegex = []string{\n\t\t\"^/skip/auth/regex$\",\n\t}\n\topts.SkipAuthRoutes = []string{\n\t\t\"GET=^/skip/auth/routes/get\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tmethod  string\n\t\turl     string\n\t\tallowed bool\n\t}{\n\t\t{\n\t\t\tname:    \"Regex GET allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST allowed \",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/skip/auth/regex\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex denied\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/wrong/denied\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong method\",\n\t\t\tmethod:  \"PATCH\",\n\t\t\turl:     \"/skip/auth/routes/get\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong path\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/skip/auth/routes/wrong/path\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Route denied with wrong path and method\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/skip/auth/routes/wrong/path\",\n\t\t\tallowed: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq, err := http.NewRequest(tc.method, opts.ProxyPrefix+authOnlyPath, nil)\n\t\t\treq.Header.Set(\"X-Forwarded-Uri\", tc.url)\n\t\t\tassert.NoError(t, err)\n\n\t\t\trw := httptest.NewRecorder()\n\t\t\tproxy.ServeHTTP(rw, req)\n\n\t\t\tif tc.allowed {\n\t\t\t\tassert.Equal(t, 202, rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 401, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllowedRequestNegateWithoutMethod(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"Allowed Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\topts.SkipAuthRoutes = []string{\n\t\t\"!=^/api\", // any non-api routes\n\t\t\"POST=^/api/public-entity/?$\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tmethod  string\n\t\turl     string\n\t\tallowed bool\n\t}{\n\t\t{\n\t\t\tname:    \"Some static file allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/static/file.txt\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"POST to contact form allowed\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/contact\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST allowed\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/api/public-entity\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST with trailing slash allowed\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/api/public-entity/\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex GET api route denied\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/api/users\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST api route denied\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/api/users\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex DELETE api route denied\",\n\t\t\tmethod:  \"DELETE\",\n\t\t\turl:     \"/api/users/1\",\n\t\t\tallowed: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq, err := http.NewRequest(tc.method, tc.url, nil)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.allowed, proxy.isAllowedRoute(req))\n\n\t\t\trw := httptest.NewRecorder()\n\t\t\tproxy.ServeHTTP(rw, req)\n\n\t\t\tif tc.allowed {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t\tassert.Equal(t, \"Allowed Request\", rw.Body.String())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllowedRequestNegateWithMethod(t *testing.T) {\n\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t\t_, err := w.Write([]byte(\"Allowed Request\"))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}))\n\tt.Cleanup(upstreamServer.Close)\n\n\topts := baseTestOptions()\n\topts.UpstreamServers = options.UpstreamConfig{\n\t\tUpstreams: []options.Upstream{\n\t\t\t{\n\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\tPath: \"/\",\n\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t},\n\t\t},\n\t}\n\topts.SkipAuthRoutes = []string{\n\t\t\"GET!=^/api\", // any non-api routes\n\t\t\"POST=^/api/public-entity/?$\",\n\t}\n\terr := validation.Validate(opts)\n\tassert.NoError(t, err)\n\tproxy, err := NewOAuthProxy(opts, func(_ string) bool { return true })\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := []struct {\n\t\tname    string\n\t\tmethod  string\n\t\turl     string\n\t\tallowed bool\n\t}{\n\t\t{\n\t\t\tname:    \"Some static file allowed\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/static/file.txt\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"POST to contact form not allowed\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/contact\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST allowed\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/api/public-entity\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST with trailing slash allowed\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/api/public-entity/\",\n\t\t\tallowed: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex GET api route denied\",\n\t\t\tmethod:  \"GET\",\n\t\t\turl:     \"/api/users\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex POST api route denied\",\n\t\t\tmethod:  \"POST\",\n\t\t\turl:     \"/api/users\",\n\t\t\tallowed: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"Regex DELETE api route denied\",\n\t\t\tmethod:  \"DELETE\",\n\t\t\turl:     \"/api/users/1\",\n\t\t\tallowed: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\treq, err := http.NewRequest(tc.method, tc.url, nil)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, tc.allowed, proxy.isAllowedRoute(req))\n\n\t\t\trw := httptest.NewRecorder()\n\t\t\tproxy.ServeHTTP(rw, req)\n\n\t\t\tif tc.allowed {\n\t\t\t\tassert.Equal(t, 200, rw.Code)\n\t\t\t\tassert.Equal(t, \"Allowed Request\", rw.Body.String())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 403, rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProxyAllowedGroups(t *testing.T) {\n\ttests := []struct {\n\t\tname               string\n\t\tallowedGroups      []string\n\t\tgroups             []string\n\t\texpectUnauthorized bool\n\t}{\n\t\t{\"NoAllowedGroups\", []string{}, []string{}, false},\n\t\t{\"NoAllowedGroupsUserHasGroups\", []string{}, []string{\"a\", \"b\"}, false},\n\t\t{\"UserInAllowedGroup\", []string{\"a\"}, []string{\"a\", \"b\"}, false},\n\t\t{\"UserNotInAllowedGroup\", []string{\"a\"}, []string{\"c\"}, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\temailAddress := \"test\"\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      tt.groups,\n\t\t\t\tEmail:       emailAddress,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\tupstreamServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.WriteHeader(200)\n\t\t\t}))\n\t\t\tt.Cleanup(upstreamServer.Close)\n\n\t\t\ttest, err := NewProcessCookieTestWithOptionsModifiers(func(opts *options.Options) {\n\t\t\t\topts.Providers[0].AllowedGroups = tt.allowedGroups\n\t\t\t\topts.UpstreamServers = options.UpstreamConfig{\n\t\t\t\t\tUpstreams: []options.Upstream{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tID:   upstreamServer.URL,\n\t\t\t\t\t\t\tPath: \"/\",\n\t\t\t\t\t\t\tURI:  upstreamServer.URL,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\ttest.req, _ = http.NewRequest(\"GET\", \"/\", nil)\n\n\t\t\ttest.req.Header.Add(\"accept\", applicationJSON)\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tif tt.expectUnauthorized {\n\t\t\t\tassert.Equal(t, http.StatusForbidden, test.rw.Code)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, http.StatusOK, test.rw.Code)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAuthOnlyAllowedGroups(t *testing.T) {\n\ttestCases := []struct {\n\t\tname               string\n\t\tallowedGroups      []string\n\t\tgroups             []string\n\t\tquerystring        string\n\t\texpectedStatusCode int\n\t}{\n\t\t{\n\t\t\tname:               \"NoAllowedGroups\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"NoAllowedGroupsUserHasGroups\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"a\", \"b\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedGroup\",\n\t\t\tallowedGroups:      []string{\"a\"},\n\t\t\tgroups:             []string{\"a\", \"b\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedGroup\",\n\t\t\tallowedGroups:      []string{\"a\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusUnauthorized,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInMultiParamQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"b\"},\n\t\t\tquerystring:        \"?allowed_groups=a&allowed_groups=b,d\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInOnlyQuerystringGroup\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInDelimitedQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\", \"c\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,c\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInConfigGroupNotInQuerystringGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\", \"c\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=a,b\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInQuerystringGroupNotInConfigGroup\",\n\t\t\tallowedGroups:      []string{\"a\", \"b\"},\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tquerystring:        \"?allowed_groups=b,c\",\n\t\t\texpectedStatusCode: http.StatusUnauthorized,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\temailAddress := \"test\"\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      tc.groups,\n\t\t\t\tEmail:       emailAddress,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\ttest, err := NewAuthOnlyEndpointTest(tc.querystring, func(opts *options.Options) {\n\t\t\t\topts.Providers[0].AllowedGroups = tc.allowedGroups\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tassert.Equal(t, tc.expectedStatusCode, test.rw.Code)\n\t\t})\n\t}\n}\n\nfunc TestAuthOnlyAllowedGroupsWithSkipMethods(t *testing.T) {\n\ttestCases := []struct {\n\t\tname               string\n\t\tgroups             []string\n\t\tmethod             string\n\t\tip                 string\n\t\twithSession        bool\n\t\texpectedStatusCode int\n\t}{\n\t\t{\n\t\t\tname:               \"UserWithGroupSkipAuthPreflight\",\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tmethod:             \"OPTIONS\",\n\t\t\tip:                 \"1.2.3.5:43670\",\n\t\t\twithSession:        true,\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserWithGroupTrustedIp\",\n\t\t\tgroups:             []string{\"a\", \"c\"},\n\t\t\tmethod:             \"GET\",\n\t\t\tip:                 \"1.2.3.4:43670\",\n\t\t\twithSession:        true,\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserWithoutGroupSkipAuthPreflight\",\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tmethod:             \"OPTIONS\",\n\t\t\tip:                 \"1.2.3.5:43670\",\n\t\t\twithSession:        true,\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserWithoutGroupTrustedIp\",\n\t\t\tgroups:             []string{\"c\"},\n\t\t\tmethod:             \"GET\",\n\t\t\tip:                 \"1.2.3.4:43670\",\n\t\t\twithSession:        true,\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserWithoutSessionSkipAuthPreflight\",\n\t\t\tmethod:             \"OPTIONS\",\n\t\t\tip:                 \"1.2.3.5:43670\",\n\t\t\twithSession:        false,\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserWithoutSessionTrustedIp\",\n\t\t\tmethod:             \"GET\",\n\t\t\tip:                 \"1.2.3.4:43670\",\n\t\t\twithSession:        false,\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttest, err := NewAuthOnlyEndpointTest(\"?allowed_groups=a,b\", func(opts *options.Options) {\n\t\t\t\topts.SkipAuthPreflight = true\n\t\t\t\topts.TrustedIPs = []string{\"1.2.3.4\"}\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\ttest.req.Method = tc.method\n\t\t\ttest.req.RemoteAddr = tc.ip\n\n\t\t\tif tc.withSession {\n\t\t\t\tcreated := time.Now()\n\t\t\t\tsession := &sessions.SessionState{\n\t\t\t\t\tGroups:      tc.groups,\n\t\t\t\t\tEmail:       \"test\",\n\t\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\t\tCreatedAt:   &created,\n\t\t\t\t}\n\t\t\t\terr = test.SaveSession(session)\n\t\t\t}\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tassert.Equal(t, tc.expectedStatusCode, test.rw.Code)\n\t\t})\n\t}\n}\n\nfunc TestAuthOnlyAllowedEmailDomains(t *testing.T) {\n\ttestCases := []struct {\n\t\tname               string\n\t\temail              string\n\t\tquerystring        string\n\t\texpectedStatusCode int\n\t}{\n\t\t{\n\t\t\tname:               \"NotEmailRestriction\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedEmailDomain\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=example.com\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedEmailDomain\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=a.example.com\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedEmailDomains\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=a.example.com,b.example.com\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedEmailDomains\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=a.example.com,example.com\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedEmailDomainWildcard\",\n\t\t\temail:              \"toto@foo.example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=*.example.com\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedEmailDomainWildcard\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=*.a.example.com\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedEmailDomainsWildcard\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=*.a.example.com,*.b.example.com\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedEmailDomainsWildcard\",\n\t\t\temail:              \"toto@c.example.com\",\n\t\t\tquerystring:        \"?allowed_email_domains=a.b.c.example.com,*.c.example.com\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgroups := []string{}\n\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      groups,\n\t\t\t\tEmail:       tc.email,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\ttest, err := NewAuthOnlyEndpointTest(tc.querystring, func(opts *options.Options) {})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tassert.Equal(t, tc.expectedStatusCode, test.rw.Code)\n\t\t})\n\t}\n}\n\nfunc TestStateEncodesCorrectly(t *testing.T) {\n\tstate := \"some_state_to_test\"\n\tnonce := \"some_nonce_to_test\"\n\n\tencodedResult := encodeState(nonce, state, true)\n\tassert.Equal(t, \"c29tZV9ub25jZV90b190ZXN0OnNvbWVfc3RhdGVfdG9fdGVzdA\", encodedResult)\n\n\tnotEncodedResult := encodeState(nonce, state, false)\n\tassert.Equal(t, \"some_nonce_to_test:some_state_to_test\", notEncodedResult)\n}\n\nfunc TestStateDecodesCorrectly(t *testing.T) {\n\tnonce, redirect, _ := decodeState(\"c29tZV9ub25jZV90b190ZXN0OnNvbWVfc3RhdGVfdG9fdGVzdA\", true)\n\n\tassert.Equal(t, \"some_nonce_to_test\", nonce)\n\tassert.Equal(t, \"some_state_to_test\", redirect)\n\n\tnonce2, redirect2, _ := decodeState(\"some_nonce_to_test:some_state_to_test\", false)\n\n\tassert.Equal(t, \"some_nonce_to_test\", nonce2)\n\tassert.Equal(t, \"some_state_to_test\", redirect2)\n}\n\nfunc TestAuthOnlyAllowedEmails(t *testing.T) {\n\ttestCases := []struct {\n\t\tname               string\n\t\temail              string\n\t\tquerystring        string\n\t\texpectedStatusCode int\n\t}{\n\t\t{\n\t\t\tname:               \"NotEmailRestriction\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedEmail\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_emails=toto@example.com\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedEmail\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_emails=tete@example.com\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserNotInAllowedEmails\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_emails=tete@example.com,tutu@example.com\",\n\t\t\texpectedStatusCode: http.StatusForbidden,\n\t\t},\n\t\t{\n\t\t\tname:               \"UserInAllowedEmails\",\n\t\t\temail:              \"toto@example.com\",\n\t\t\tquerystring:        \"?allowed_emails=tete@example.com,toto@example.com\",\n\t\t\texpectedStatusCode: http.StatusAccepted,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgroups := []string{}\n\n\t\t\tcreated := time.Now()\n\n\t\t\tsession := &sessions.SessionState{\n\t\t\t\tGroups:      groups,\n\t\t\t\tEmail:       tc.email,\n\t\t\t\tAccessToken: \"oauth_token\",\n\t\t\t\tCreatedAt:   &created,\n\t\t\t}\n\n\t\t\ttest, err := NewAuthOnlyEndpointTest(tc.querystring, func(opts *options.Options) {})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terr = test.SaveSession(session)\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.proxy.ServeHTTP(test.rw, test.req)\n\n\t\t\tassert.Equal(t, tc.expectedStatusCode, test.rw.Code)\n\t\t})\n\t}\n}\n\nfunc TestGetOAuthRedirectURI(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tsetupOpts func(*options.Options) *options.Options\n\t\treq       *http.Request\n\t\twant      string\n\t}{\n\t\t{\n\t\t\tname: \"redirect with https schema\",\n\t\t\tsetupOpts: func(baseOpts *options.Options) *options.Options {\n\t\t\t\treturn baseOpts\n\t\t\t},\n\t\t\treq: &http.Request{\n\t\t\t\tHost: \"example\",\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tScheme: schemeHTTPS,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"https://example/oauth2/callback\",\n\t\t},\n\t\t{\n\t\t\tname: \"redirect with http schema\",\n\t\t\tsetupOpts: func(baseOpts *options.Options) *options.Options {\n\t\t\t\tbaseOpts.Cookie.Secure = false\n\t\t\t\treturn baseOpts\n\t\t\t},\n\t\t\treq: &http.Request{\n\t\t\t\tHost: \"example\",\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tScheme: schemeHTTP,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"http://example/oauth2/callback\",\n\t\t},\n\t\t{\n\t\t\tname: \"relative redirect url\",\n\t\t\tsetupOpts: func(baseOpts *options.Options) *options.Options {\n\t\t\t\tbaseOpts.RelativeRedirectURL = true\n\t\t\t\treturn baseOpts\n\t\t\t},\n\t\t\treq:  &http.Request{},\n\t\t\twant: \"/oauth2/callback\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxy prefix\",\n\t\t\tsetupOpts: func(baseOpts *options.Options) *options.Options {\n\t\t\t\tbaseOpts.ProxyPrefix = \"/prefix\"\n\t\t\t\treturn baseOpts\n\t\t\t},\n\t\t\treq: &http.Request{\n\t\t\t\tHost: \"example\",\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tScheme: schemeHTTP,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"https://example/prefix/callback\",\n\t\t},\n\t\t{\n\t\t\tname: \"proxy prefix with relative redirect\",\n\t\t\tsetupOpts: func(baseOpts *options.Options) *options.Options {\n\t\t\t\tbaseOpts.ProxyPrefix = \"/prefix\"\n\t\t\t\tbaseOpts.RelativeRedirectURL = true\n\t\t\t\treturn baseOpts\n\t\t\t},\n\t\t\treq: &http.Request{\n\t\t\t\tHost: \"example\",\n\t\t\t\tURL: &url.URL{\n\t\t\t\t\tScheme: schemeHTTP,\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: \"/prefix/callback\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tbaseOpts := baseTestOptions()\n\t\t\terr := validation.Validate(baseOpts)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tproxy, err := NewOAuthProxy(tt.setupOpts(baseOpts), func(string) bool { return true })\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Equalf(t, tt.want, proxy.getOAuthRedirectURI(tt.req), \"getOAuthRedirectURI(%v)\", tt.req)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "providers",
          "type": "tree",
          "content": null
        },
        {
          "name": "static",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "validator.go",
          "type": "blob",
          "size": 3.5166015625,
          "content": "package main\n\nimport (\n\t\"encoding/csv\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"unsafe\"\n\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/logger\"\n\t\"github.com/oauth2-proxy/oauth2-proxy/v7/pkg/watcher\"\n)\n\n// UserMap holds information from the authenticated emails file\ntype UserMap struct {\n\tusersFile string\n\tm         unsafe.Pointer\n}\n\n// NewUserMap parses the authenticated emails file into a new UserMap\n//\n// TODO (@NickMeves): Audit usage of `unsafe.Pointer` and potentially refactor\nfunc NewUserMap(usersFile string, done <-chan bool, onUpdate func()) *UserMap {\n\tum := &UserMap{usersFile: usersFile}\n\tm := make(map[string]bool)\n\tatomic.StorePointer(&um.m, unsafe.Pointer(&m)) // #nosec G103\n\tif usersFile != \"\" {\n\t\tlogger.Printf(\"using authenticated emails file %s\", usersFile)\n\t\twatcher.WatchFileForUpdates(usersFile, done, func() {\n\t\t\tum.LoadAuthenticatedEmailsFile()\n\t\t\tonUpdate()\n\t\t})\n\t\tum.LoadAuthenticatedEmailsFile()\n\t}\n\treturn um\n}\n\n// IsValid checks if an email is allowed\nfunc (um *UserMap) IsValid(email string) (result bool) {\n\tm := *(*map[string]bool)(atomic.LoadPointer(&um.m))\n\t_, result = m[email]\n\treturn\n}\n\n// LoadAuthenticatedEmailsFile loads the authenticated emails file from disk\n// and parses the contents as CSV\nfunc (um *UserMap) LoadAuthenticatedEmailsFile() {\n\tr, err := os.Open(um.usersFile)\n\tif err != nil {\n\t\tlogger.Fatalf(\"failed opening authenticated-emails-file=%q, %s\", um.usersFile, err)\n\t}\n\tdefer func(c io.Closer) {\n\t\tcerr := c.Close()\n\t\tif cerr != nil {\n\t\t\tlogger.Fatalf(\"Error closing authenticated emails file: %s\", cerr)\n\t\t}\n\t}(r)\n\tcsvReader := csv.NewReader(r)\n\tcsvReader.Comma = ','\n\tcsvReader.Comment = '#'\n\tcsvReader.TrimLeadingSpace = true\n\trecords, err := csvReader.ReadAll()\n\tif err != nil {\n\t\tlogger.Errorf(\"error reading authenticated-emails-file=%q, %s\", um.usersFile, err)\n\t\treturn\n\t}\n\tupdated := make(map[string]bool)\n\tfor _, r := range records {\n\t\taddress := strings.ToLower(strings.TrimSpace(r[0]))\n\t\tupdated[address] = true\n\t}\n\tatomic.StorePointer(&um.m, unsafe.Pointer(&updated)) // #nosec G103\n}\n\nfunc newValidatorImpl(domains []string, usersFile string,\n\tdone <-chan bool, onUpdate func()) func(string) bool {\n\tvalidUsers := NewUserMap(usersFile, done, onUpdate)\n\n\tvar allowAll bool\n\tfor i, domain := range domains {\n\t\tif domain == \"*\" {\n\t\t\tallowAll = true\n\t\t\tcontinue\n\t\t}\n\t\tdomains[i] = strings.ToLower(domain)\n\t}\n\n\tvalidator := func(email string) (valid bool) {\n\t\tif email == \"\" {\n\t\t\treturn\n\t\t}\n\t\temail = strings.ToLower(email)\n\t\tvalid = isEmailValidWithDomains(email, domains)\n\t\tif !valid {\n\t\t\tvalid = validUsers.IsValid(email)\n\t\t}\n\t\tif allowAll {\n\t\t\tvalid = true\n\t\t}\n\t\treturn valid\n\t}\n\treturn validator\n}\n\n// NewValidator constructs a function to validate email addresses\nfunc NewValidator(domains []string, usersFile string) func(string) bool {\n\treturn newValidatorImpl(domains, usersFile, nil, func() {})\n}\n\n// isEmailValidWithDomains checks if the authenticated email is validated against the provided domain\nfunc isEmailValidWithDomains(email string, allowedDomains []string) bool {\n\tfor _, domain := range allowedDomains {\n\t\t// allow if the domain is perfect suffix match with the email\n\t\tif strings.HasSuffix(email, \"@\"+domain) {\n\t\t\treturn true\n\t\t}\n\n\t\t// allow if the domain is prefixed with . or *. and\n\t\t// the last element (split on @) has the suffix as the domain\n\t\tatoms := strings.Split(email, \"@\")\n\n\t\tif (strings.HasPrefix(domain, \".\") && strings.HasSuffix(atoms[len(atoms)-1], domain)) ||\n\t\t\t(strings.HasPrefix(domain, \"*.\") && strings.HasSuffix(atoms[len(atoms)-1], domain[1:])) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "validator_test.go",
          "type": "blob",
          "size": 12.017578125,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/onsi/gomega\"\n)\n\ntype ValidatorTest struct {\n\tauthEmailFileName string\n\tdone              chan bool\n\tupdateSeen        bool\n}\n\nfunc NewValidatorTest(t *testing.T) *ValidatorTest {\n\tvt := &ValidatorTest{}\n\tvar err error\n\tf, err := os.CreateTemp(\"\", \"test_auth_emails_\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create temp file: %v\", err)\n\t}\n\tif err := f.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close temp file: %v\", err)\n\t}\n\tvt.authEmailFileName = f.Name()\n\tvt.done = make(chan bool, 1)\n\treturn vt\n}\n\nfunc (vt *ValidatorTest) TearDown() {\n\tvt.done <- true\n\tos.Remove(vt.authEmailFileName)\n}\n\nfunc (vt *ValidatorTest) NewValidator(domains []string,\n\tupdated chan<- bool) func(string) bool {\n\treturn newValidatorImpl(domains, vt.authEmailFileName,\n\t\tvt.done, func() {\n\t\t\tif vt.updateSeen == false {\n\t\t\t\tupdated <- true\n\t\t\t\tvt.updateSeen = true\n\t\t\t}\n\t\t})\n}\n\nfunc (vt *ValidatorTest) WriteEmails(t *testing.T, emails []string) {\n\tf, err := os.OpenFile(vt.authEmailFileName, os.O_WRONLY, 0600)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open auth email file: %v\", err)\n\t}\n\n\tif _, err := f.WriteString(strings.Join(emails, \"\\n\")); err != nil {\n\t\tt.Fatalf(\"failed to write emails to auth email file: %v\", err)\n\t}\n\n\tif err := f.Close(); err != nil {\n\t\tt.Fatalf(\"failed to close auth email file: %v\", err)\n\t}\n}\n\nfunc TestValidatorOverwriteEmailListDirectly(t *testing.T) {\n\ttestCasesPreUpdate := []struct {\n\t\tname          string\n\t\temail         string\n\t\texpectedAuthZ bool\n\t}{\n\t\t{\n\t\t\tname:          \"FirstEmailInList\",\n\t\t\temail:         \"xyzzy@example.com\",\n\t\t\texpectedAuthZ: true,\n\t\t},\n\t\t{\n\t\t\tname:          \"SecondEmailInList\",\n\t\t\temail:         \"plugh@example.com\",\n\t\t\texpectedAuthZ: true,\n\t\t},\n\t\t{\n\t\t\tname:          \"EmailNotInListThatMatchesNoDomains\",\n\t\t\temail:         \"xyzzy.plugh@example.com\",\n\t\t\texpectedAuthZ: false,\n\t\t},\n\t}\n\ttestCasesPostUpdate := []struct {\n\t\tname          string\n\t\temail         string\n\t\texpectedAuthZ bool\n\t}{\n\t\t{\n\t\t\tname:          \"email removed from list\",\n\t\t\temail:         \"xyzzy@example.com\",\n\t\t\texpectedAuthZ: false,\n\t\t},\n\t\t{\n\t\t\tname:          \"email retained in list\",\n\t\t\temail:         \"plugh@example.com\",\n\t\t\texpectedAuthZ: true,\n\t\t},\n\t\t{\n\t\t\tname:          \"email added to list\",\n\t\t\temail:         \"xyzzy.plugh@example.com\",\n\t\t\texpectedAuthZ: true,\n\t\t},\n\t}\n\n\tvt := NewValidatorTest(t)\n\tdefer vt.TearDown()\n\n\tvt.WriteEmails(t, []string{\n\t\t\"xyzzy@example.com\",\n\t\t\"plugh@example.com\",\n\t})\n\tupdated := make(chan bool)\n\tvalidator := vt.NewValidator([]string(nil), updated)\n\n\tfor _, tc := range testCasesPreUpdate {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tg := NewWithT(t)\n\t\t\tauthorized := validator(tc.email)\n\t\t\tg.Expect(authorized).To(Equal(tc.expectedAuthZ))\n\t\t})\n\t}\n\n\tvt.WriteEmails(t, []string{\n\t\t\"xyzzy.plugh@example.com\",\n\t\t\"plugh@example.com\",\n\t})\n\t<-updated\n\n\tfor _, tc := range testCasesPostUpdate {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tg := NewWithT(t)\n\t\t\tauthorized := validator(tc.email)\n\t\t\tg.Expect(authorized).To(Equal(tc.expectedAuthZ))\n\t\t})\n\t}\n}\n\nfunc TestValidatorCases(t *testing.T) {\n\ttestCases := []struct {\n\t\tname           string\n\t\tallowedEmails  []string\n\t\tallowedDomains []string\n\t\temail          string\n\t\texpectedAuthZ  bool\n\t}{\n\t\t{\n\t\t\tname:           \"EmailNotInCorrect1stSubDomainsNotInEmails\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\".example0.com\", \".example1.com\"},\n\t\t\temail:          \"foo.bar@example0.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailNotInCorrect1stSubDomainsNotInEmailsWildcard\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\"*.example0.com\", \"*.example1.com\"},\n\t\t\temail:          \"foo.bar@example0.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInFirstDomain\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\".example0.com\", \".example1.com\"},\n\t\t\temail:          \"foo@bar.example0.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInFirstDomainWildcard\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\"*.example0.com\", \"*.example1.com\"},\n\t\t\temail:          \"foo@bar.example0.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailNotInCorrect2ndSubDomainsNotInEmails\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\".example0.com\", \".example1.com\"},\n\t\t\temail:          \"baz.quux@example1.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInSecondDomain\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\".example0.com\", \".example1.com\"},\n\t\t\temail:          \"baz@quux.example1.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInSecondDomainWildcard\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\"*.example0.com\", \"*.example1.com\"},\n\t\t\temail:          \"baz@quux.example1.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInFirstEmailList\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\".example0.com\", \".example1.com\"},\n\t\t\temail:          \"xyzzy@example.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInFirstEmailListWildcard\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\"*.example0.com\", \"*.example1.com\"},\n\t\t\temail:          \"xyzzy@example.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailNotInDomainsNotInEmails\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\".example0.com\", \".example1.com\"},\n\t\t\temail:          \"xyzzy.plugh@example.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInLastEmailList\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\".example0.com\", \".example1.com\"},\n\t\t\temail:          \"plugh@example.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailIn1stSubdomain\",\n\t\t\tallowedEmails:  nil,\n\t\t\tallowedDomains: []string{\"us.example.com\", \"de.example.com\", \"example.com\"},\n\t\t\temail:          \"xyzzy@us.example.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailIn2ndSubdomain\",\n\t\t\tallowedEmails:  nil,\n\t\t\tallowedDomains: []string{\"us.example.com\", \"de.example.com\", \"example.com\"},\n\t\t\temail:          \"xyzzy@de.example.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailNotInAnySubdomain\",\n\t\t\tallowedEmails:  nil,\n\t\t\tallowedDomains: []string{\"us.example.com\", \"de.example.com\", \"example.com\"},\n\t\t\temail:          \"global@au.example.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailInLastSubdomain\",\n\t\t\tallowedEmails:  nil,\n\t\t\tallowedDomains: []string{\"us.example.com\", \"de.example.com\", \"example.com\"},\n\t\t\temail:          \"xyzzy@example.com\",\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailDomainNotCompletelyMatch\",\n\t\t\tallowedEmails:  nil,\n\t\t\tallowedDomains: []string{\".example.com\", \".example1.com\"},\n\t\t\temail:          \"something@fooexample.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"HackerExtraDomainPrefix1\",\n\t\t\tallowedEmails:  nil,\n\t\t\tallowedDomains: []string{\".mycompany.com\"},\n\t\t\temail:          \"something@evilhackmycompany.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"HackerExtraDomainPrefix2\",\n\t\t\tallowedEmails:  nil,\n\t\t\tallowedDomains: []string{\".mycompany.com\"},\n\t\t\temail:          \"something@ext.evilhackmycompany.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmptyDomainAndEmailList\",\n\t\t\tallowedEmails:  []string(nil),\n\t\t\tallowedDomains: []string(nil),\n\t\t\temail:          \"foo.bar@example.com\",\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailMatchWithAllowedEmails\",\n\t\t\temail:          \"foo.bar@example.com\",\n\t\t\tallowedEmails:  []string{\"foo.bar@example.com\"},\n\t\t\tallowedDomains: []string{\"example.com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailFromSameDomainButNotInList\",\n\t\t\temail:          \"baz.quux@example.com\",\n\t\t\tallowedEmails:  []string{\"foo.bar@example.com\"},\n\t\t\tallowedDomains: []string(nil),\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailMatchOnDomain\",\n\t\t\temail:          \"foo.bar@example.com\",\n\t\t\tallowedEmails:  []string(nil),\n\t\t\tallowedDomains: []string{\"example.com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailMatchOnDomain2\",\n\t\t\temail:          \"baz.quux@example.com\",\n\t\t\tallowedEmails:  []string(nil),\n\t\t\tallowedDomains: []string{\"example.com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailFromFirstDomainShouldValidate\",\n\t\t\temail:          \"foo.bar@example0.com\",\n\t\t\tallowedEmails:  []string{\"Foo.Bar@Example.Com\"},\n\t\t\tallowedDomains: []string{\"example0.com\", \"example1.com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailFromSecondDomainShouldValidate\",\n\t\t\temail:          \"baz.quux@example1.com\",\n\t\t\tallowedEmails:  []string{\"Foo.Bar@Example.Com\"},\n\t\t\tallowedDomains: []string{\"example0.com\", \"example1.com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"FirstEmailInListShouldValidate\",\n\t\t\temail:          \"xyzzy@example.com\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\"example0.com\", \"example1.com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"SecondEmailInListShouldValidate\",\n\t\t\temail:          \"plugh@example.com\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\"example0.com\", \"example1.com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"EmailNotInListThatMatchesNoDomains \",\n\t\t\temail:          \"xyzzy.plugh@example.com\",\n\t\t\tallowedEmails:  []string{\"xyzzy@example.com\", \"plugh@example.com\"},\n\t\t\tallowedDomains: []string{\"example0.com\", \"example1.com\"},\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"LoadedEmailAddressesAreNotLowerCased\",\n\t\t\temail:          \"foo.bar@example.com\",\n\t\t\tallowedEmails:  []string{\"Foo.Bar@Example.Com\"},\n\t\t\tallowedDomains: []string{\"Frobozz.Com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"ValidatedEmailAddressesAreNotLowerCased\",\n\t\t\temail:          \"Foo.Bar@Example.Com\",\n\t\t\tallowedEmails:  []string{\"Foo.Bar@Example.Com\"},\n\t\t\tallowedDomains: []string{\"Frobozz.Com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"LoadedDomainsAreNotLowerCased\",\n\t\t\temail:          \"foo.bar@frobozz.com\",\n\t\t\tallowedEmails:  []string{\"Foo.Bar@Example.Com\"},\n\t\t\tallowedDomains: []string{\"Frobozz.Com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"ValidatedDomainsAreNotLowerCased\",\n\t\t\temail:          \"foo.bar@Frobozz.Com\",\n\t\t\tallowedEmails:  []string{\"Foo.Bar@Example.Com\"},\n\t\t\tallowedDomains: []string{\"Frobozz.Com\"},\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"IgnoreSpacesInAuthEmails\",\n\t\t\temail:          \"foo.bar@example.com\",\n\t\t\tallowedEmails:  []string{\"   foo.bar@example.com   \"},\n\t\t\tallowedDomains: []string(nil),\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"IgnorePrefixSpacesInAuthEmails\",\n\t\t\temail:          \"foo.bar@example.com\",\n\t\t\tallowedEmails:  []string{\"   foo.bar@example.com\"},\n\t\t\tallowedDomains: []string(nil),\n\t\t\texpectedAuthZ:  true,\n\t\t},\n\t\t{\n\t\t\tname:           \"CheckForEqualityNotSuffix\",\n\t\t\temail:          \"foo@evilcompany.com\",\n\t\t\tallowedEmails:  []string(nil),\n\t\t\tallowedDomains: []string{\".company.com\"},\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"CheckForEqualityNotSuffix2\",\n\t\t\temail:          \"foo@evilcompany.com\",\n\t\t\tallowedEmails:  []string(nil),\n\t\t\tallowedDomains: []string{\"company.com\"},\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t\t{\n\t\t\tname:           \"CheckForEqualityNotSuffixWildcard\",\n\t\t\temail:          \"foo@evilcompany.com\",\n\t\t\tallowedEmails:  []string(nil),\n\t\t\tallowedDomains: []string{\"*.company.com\"},\n\t\t\texpectedAuthZ:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tvt := NewValidatorTest(t)\n\t\t\tdefer vt.TearDown()\n\n\t\t\tg := NewWithT(t)\n\t\t\tvt.WriteEmails(t, tc.allowedEmails)\n\t\t\tvalidator := vt.NewValidator(tc.allowedDomains, nil)\n\t\t\tauthorized := validator(tc.email)\n\t\t\tg.Expect(authorized).To(Equal(tc.expectedAuthZ))\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}