{
  "metadata": {
    "timestamp": 1736567957352,
    "page": 100,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tinygo-org/tinygo",
      "stars": 15668,
      "defaultBranch": "release",
      "files": [
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "build/\nllvm-*/\n.github\n.circleci\n\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.6328125,
          "content": ".DS_Store\n.vscode\ngo.work\ngo.work.sum\n\ndocs/_build\nsrc/device/avr/*.go\nsrc/device/avr/*.ld\nsrc/device/avr/*.s\nsrc/device/esp/*.go\nsrc/device/nrf/*.go\nsrc/device/nrf/*.s\nsrc/device/nxp/*.go\nsrc/device/nxp/*.s\nsrc/device/sam/*.go\nsrc/device/sam/*.s\nsrc/device/sifive/*.go\nsrc/device/sifive/*.s\nsrc/device/stm32/*.go\nsrc/device/stm32/*.s\nsrc/device/kendryte/*.go\nsrc/device/kendryte/*.s\nsrc/device/renesas/*.go\nsrc/device/renesas/*.s\nsrc/device/rp/*.go\nsrc/device/rp/*.s\n./vendor\nllvm-build\nllvm-project\nbuild/*\n\n# Ignore files generated by smoketest\ntest\ntest.bin\ntest.elf\ntest.exe\ntest.gba\ntest.hex\ntest.nro\ntest.uf2\ntest.wasm\nwasm.wasm\n\n*.uf2\n*.elf"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 1.2451171875,
          "content": "[submodule \"lib/nrfx\"]\n\tpath = lib/nrfx\n\turl = https://github.com/NordicSemiconductor/nrfx.git\n[submodule \"lib/CMSIS\"]\n\tpath = lib/CMSIS\n\turl = https://github.com/ARM-software/CMSIS.git\n[submodule \"lib/avr\"]\n\tpath = lib/avr\n\turl = https://github.com/avr-rust/avr-mcu.git\n[submodule \"lib/cmsis-svd\"]\n\tpath = lib/cmsis-svd\n\turl = https://github.com/cmsis-svd/cmsis-svd-data.git\n\tbranch = main\n[submodule \"lib/wasi-libc\"]\n\tpath = lib/wasi-libc\n\turl = https://github.com/WebAssembly/wasi-libc\n[submodule \"lib/picolibc\"]\n\tpath = lib/picolibc\n\turl = https://github.com/keith-packard/picolibc.git\n[submodule \"lib/stm32-svd\"]\n\tpath = lib/stm32-svd\n\turl = https://github.com/tinygo-org/stm32-svd\n[submodule \"lib/musl\"]\n\tpath = lib/musl\n\turl = git://git.musl-libc.org/musl\n[submodule \"lib/binaryen\"]\n\tpath = lib/binaryen\n\turl = https://github.com/WebAssembly/binaryen.git\n[submodule \"lib/mingw-w64\"]\n\tpath = lib/mingw-w64\n\turl = https://github.com/mingw-w64/mingw-w64.git\n[submodule \"lib/macos-minimal-sdk\"]\n\tpath = lib/macos-minimal-sdk\n\turl = https://github.com/aykevl/macos-minimal-sdk.git\n[submodule \"src/net\"]\n\tpath = src/net\n\turl = https://github.com/tinygo-org/net.git\n\tbranch = dev\n[submodule \"lib/wasi-cli\"]\n\tpath = lib/wasi-cli\n\turl = https://github.com/WebAssembly/wasi-cli\n"
        },
        {
          "name": "BUILDING.md",
          "type": "blob",
          "size": 3.771484375,
          "content": "# Building TinyGo\n\nTinyGo depends on LLVM and libclang, which are both big C++ libraries. It can\nalso optionally use a built-in lld to ease cross compiling. There are two ways\nthese can be linked: dynamically and statically. An install with `go install` is\ndynamic linking because it is fast and works almost out of the box on\nDebian-based systems with the right packages installed.\n\nThis guide describes how to statically link TinyGo against LLVM, libclang and\nlld so that the binary can be easily moved between systems. It also shows how to\nbuild a release tarball that includes this binary and all necessary extra files.\n\n**Note**: this documentation describes how to build a statically linked release\ntarball. If you want to help with development of TinyGo itself, you should follow the guide located at https://tinygo.org/docs/guides/build/\n\n## Dependencies\n\nLLVM, Clang and LLD are quite light on dependencies, requiring only standard\nbuild tools to be built. Go is of course necessary to build TinyGo itself.\n\n  * Go (1.19+)\n  * GNU Make\n  * Standard build tools (gcc/clang)\n  * git\n  * CMake\n  * [Ninja](https://ninja-build.org/)\n\nThe rest of this guide assumes you're running Linux, but it should be equivalent\non a different system like Mac.\n\n## Using GNU Make\n\nThe static build of TinyGo is driven by GNUmakefile, which provides a help target for quick reference:\n\n    % make help\n    clean                           Remove build directory\n    fmt                             Reformat source\n    fmt-check                       Warn if any source needs reformatting\n    gen-device                      Generate microcontroller-specific sources\n    llvm-source                     Get LLVM sources\n    llvm-build                      Build LLVM\n    tinygo                          Build the TinyGo compiler\n    lint                            Lint source tree\n    spell                           Spellcheck source tree\n\n## Download the source\n\nThe first step is to download the TinyGo sources (use `--recursive` if you clone\nthe git repository). Then, inside the directory, download the LLVM source:\n\n    make llvm-source\n\nYou can also store LLVM outside of the TinyGo root directory by setting the\n`LLVM_BUILDDIR`, `CLANG_SRC` and `LLD_SRC` make variables, but that is not\ncovered by this guide.\n\n## Build LLVM, Clang, LLD\n\nBefore starting the build, you may want to set the following environment\nvariables to speed up the build. Most Linux distributions ship with GCC as the\ndefault compiler, but Clang is significantly faster and uses much less memory\nwhile producing binaries that are about as fast.\n\n    export CC=clang\n    export CXX=clang++\n\nThe Makefile includes a default configuration that is good for most users. It\nbuilds a release version of LLVM (optimized, no asserts) and includes all\ntargets supported by TinyGo:\n\n    make llvm-build\n\nThis can take over an hour depending on the speed of your system.\n\n## Build TinyGo\n\nThe last step of course is to build TinyGo itself. This can again be done with\nmake:\n\n    make\n\n## Verify TinyGo\n\nTry running TinyGo:\n\n    ./build/tinygo help\n\nAlso, make sure the `tinygo` binary really is statically linked. Check this\nusing `ldd` (not to be confused with `lld`):\n\n    ldd ./build/tinygo\n\nThe result should not contain libclang or libLLVM.\n\n## Make a release tarball\n\nNow that we have a working static build, it's time to make a release tarball:\n\n    make release\n\nIf you did not clone the repository with the `--recursive` option, you will get errors until you initialize the project submodules:\n\n    git submodule update --init\n\nThe release tarball is stored in build/release.tar.gz, and can be extracted with\nthe following command (for example in ~/lib):\n\n    tar -xvf path/to/release.tar.gz\n\nTinyGo will get extracted to a `tinygo` directory. You can then call it with:\n\n    ./tinygo/bin/tinygo\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 101.392578125,
          "content": "0.35.0\n---\n* **general**\n  - update cmsis-svd library\n  - use default UART settings in the echo example\n  - `goenv`: also show git hash with custom build of TinyGo\n  - `goenv`: support parsing development versions of Go\n  - `main`: parse extldflags early so we can report the error message\n* **compiler**\n  - `builder`: whitelist temporary directory env var for Clang invocation to fix Windows bug\n  - `builder`: fix cache paths in `-size=full` output\n  - `builder`: work around incorrectly escaped DWARF paths on Windows (Clang bug)\n  - `builder`: fix wasi-libc path names on Windows with `-size=full`\n  - `builder`: write HTML size report\n  - `cgo`: support C identifiers only referred to from within macros\n  - `cgo`: support function-like macros\n  - `cgo`: support errno value as second return parameter\n  - `cgo`: add support for `#cgo noescape` lines\n  - `compiler`: fix bug in interrupt lowering\n  - `compiler`: allow panic directly in `defer`\n  - `compiler`: fix wasmimport -> wasmexport in error message\n  - `compiler`: support `//go:noescape` pragma\n  - `compiler`: report error instead of crashing when instantiating a generic function without body\n  - `interp`: align created globals\n* **standard library**\n  - `machine`: modify i2s interface/implementation to better match specification\n  - `os`: implement `StartProcess`\n  - `reflect`: add `Value.Clear`\n  - `reflect`: add interface support to `NumMethods`\n  - `reflect`: fix `AssignableTo` for named + non-named types\n  - `reflect`: implement `CanConvert`\n  - `reflect`: handle more cases in `Convert`\n  - `reflect`: fix Copy of non-pointer array with size > 64bits\n  - `runtime`: don't call sleepTicks with a negative duration\n  - `runtime`: optimize GC scanning (findHead)\n  - `runtime`: move constants into shared package\n  - `runtime`: add `runtime.fcntl` function for internal/syscall/unix\n  - `runtime`: heapptr only needs to be initialized once\n  - `runtime`: refactor scheduler (this fixes a few bugs with `-scheduler=none`)\n  - `runtime`: rewrite channel implementation to be smaller and more flexible\n  - `runtime`: use `SA_RESTART` when registering a signal for os/signal\n  - `runtime`: implement race-free signals using futexes\n  - `runtime`: run deferred functions in `Goexit`\n  - `runtime`: remove `Cond` which seems to be unused\n  - `runtime`: properly handle unix read on directory\n  - `runtime/trace`: stub all public methods\n  - `sync`: don't use volatile in `Mutex`\n  - `sync`: implement `WaitGroup` using a (pseudo)futex\n  - `sync`: make `Cond` parallelism-safe\n  - `syscall`: use wasi-libc tables for wasm/js target\n* **targets**\n  - `mips`: fix a bug when scanning the stack\n  - `nintendoswitch`: get this target to compile again\n  - `rp2350`: add support for the new RP2350\n  - `rp2040/rp2350` : make I2C implementation shared for rp2040/rp2350\n  - `rp2040/rp2350` : make SPI implementation shared for rp2040/rp2350\n  - `rp2040/rp2350` : make RNG implementation shared for rp2040/rp2350\n  - `wasm`: revise and simplify wasmtime argument handling\n  - `wasm`: support `//go:wasmexport` functions after a call to `time.Sleep`\n  - `wasm`: correctly return from run() in wasm_exec.js\n  - `wasm`: call process.exit() when go.run() returns\n  - `windows`: don't return, exit via exit(0) instead to flush stdout buffer\n* **boards**\n  - add support for the Tillitis TKey\n  - add support for the Raspberry Pi Pico2 (based on the RP2040)\n  - add support for Pimoroni Tiny2350\n\n\n0.34.0\n---\n* **general**\n  - fix `GOOS=wasip1` for `tinygo test`\n  - add `-C DIR` flag\n  - add initial documentation for project governance\n  - add `-ldflags='-extldflags=...'` support\n  - improve usage message with `tinygo help` and when passing invalid parameters\n* **compiler**\n  - `builder`: remove environment variables when invoking Clang, to avoid the environment changing the behavior\n  - `builder`: check for the Go toolchain version used to compile TinyGo\n  - `cgo`: add `C.CBytes` implementation\n  - `compiler`: fix passing weirdly-padded structs as parameters to new goroutines\n  - `compiler`: support pragmas on generic functions\n  - `compiler`: do not let the slice buffer escape when casting a `[]byte` or `[]rune` to a string, to help escape analysis\n  - `compiler`: conform to the latest iteration of the wasm types proposal\n  - `loader`: don't panic when main package is not named 'main'\n  - `loader`: make sure we always return type checker errors even without type errors\n  - `transform`: optimize range over `[]byte(string)`\n* **standard library**\n  - `crypto/x509`: add package stub to build crypto/x509 on macOS\n  - `machine/usb/adc/midi`: fix `PitchBend`\n  - `os`: add `Truncate` stub for baremetal\n  - `os`: add stubs for `os.File` deadlines\n  - `os`: add internal `net.newUnixFile` for the net package\n  - `runtime`: stub runtime_{Before,After}Exec for linkage\n  - `runtime`: randomize map accesses\n  - `runtime`: support `maps.Clone`\n  - `runtime`: add more fields to `MemStats`\n  - `runtime`: implement newcoro, coroswitch to support package iter\n  - `runtime`: disallow defer in interrupts\n  - `runtime`: add support for os/signal on Linux and MacOS\n  - `runtime`: add gc layout info for some basic types to help the precise GC\n  - `runtime`: bump GC mark stack size to avoid excessive heap rescans\n* **targets**\n  - `darwin`: use Go standard library syscall package instead of a custom one\n  - `fe310`: support GPIO `PinInput`\n  - `mips`: fix compiler crash with GOMIPS=softfloat and defer\n  - `mips`: add big-endian (GOARCH=mips) support\n  - `mips`: use MIPS32 (instead of MIPS32R2) as the instruction set for wider compatibility\n  - `wasi`: add relative and absolute --dir options to wasmtime args\n  - `wasip2`: add wasmtime -S args to support network interfaces\n  - `wasm`: add `//go:wasmexport` support (for all WebAssembly targets)\n  - `wasm`: use precise instead of conservative GC for WebAssembly (including WASI)\n  - `wasm-unknown`: add bulk memory flags since basically every runtime has it now\n* **boards**\n  - add RAKwireless RAK4631\n  - add WaveShare ESP-C3-32S-Kit\n\n\n0.33.0\n---\n\n* **general**\n  - use latest version of x/tools\n  - add chromeos 9p support for flashing\n  - sort compiler error messages by source position in a package\n  - don't include prebuilt libraries in the release to simplify packaging and reduce the release tarball size\n  - show runtime panic addresses for `tinygo run`\n  - support Go 1.23 (including all new language features)\n  - `test`: support GOOS/GOARCH pairs in the `-target` flag\n  - `test`: remove message after test binary built\n* **compiler**\n  - remove unused registers for x86_64 linux syscalls\n  - remove old atomics workaround for AVR (not necessary in modern LLVM versions)\n  - support `golang.org/x/sys/unix` syscalls\n  - `builder`: remove workaround for generics race condition\n  - `builder`: add package ID to compiler and optimization error messages\n  - `builder`: show better error messages for some common linker errors\n  - `cgo`: support preprocessor macros passed on the command line\n  - `cgo`: use absolute paths for error messages\n  - `cgo`: add support for printf\n  - `loader`: handle `go list` errors inside TinyGo (for better error messages)\n  - `transform`: fix incorrect alignment of heap-to-stack transform\n  - `transform`: use thinlto-pre-link passes (instead of the full pipeline) to speed up compilation speed slightly\n* **standard library**\n  - `crypto/tls`: add CipherSuiteName and some extra fields to ConnectionSTate\n  - `internal/abi`: implement initial version of this package\n  - `machine`: use new `internal/binary` package\n  - `machine`: rewrite Reply() to fix sending long replies in I2C Target Mode\n  - `machine/usb/descriptor`: Reset joystick physical\n  - `machine/usb/descriptor`: Drop second joystick hat\n  - `machine/usb/descriptor`: Add more HID... functions\n  - `machine/usb/descriptor`: Fix encoding of values\n  - `machine/usb/hid/joystick`: Allow more hat switches\n  - `os`: add `Chown`, `Truncate`\n  - `os/user`: use stdlib version of this package\n  - `reflect`: return correct name for the `unsafe.Pointer` type\n  - `reflect`: implement `Type.Overflow*` functions\n  - `runtime`: implement dummy `getAuxv` to satisfy golang.org/x/sys/\n  - `runtime`: don't zero out new allocations for `-gc=leaking` when they are already zeroed\n  - `runtime`: simplify slice growing/appending code\n  - `runtime`: print a message when a fatal signal like SIGSEGV happens\n  - `runtime/debug`: add `GoVersion` to `debug.BuildInfo`\n  - `sync`: add `Map.Clear()`\n  - `sync/atomic`: add And* and Or* compiler intrinsics needed for Go 1.23\n  - `syscall`: add `Fork` and `Execve`\n  - `syscall`: add all MacOS errno values\n  - `testing`: stub out `T.Deadline`\n  - `unique`: implement custom (naive) version of the unique package\n* **targets**\n  - `arm`: support `GOARM=*,softfloat` (softfloat support for ARM v5, v6, and v7)\n  - `mips`: add linux/mipsle (and experimental linux/mips) support\n  - `mips`: add `GOMIPS=softfloat` support\n  - `wasip2`: add WASI preview 2 support\n  - `wasm/js`: add `node:` prefix in `require()` call of wasm_exec.js\n  - `wasm-unknown`: make sure the `os` package can be imported\n  - `wasm-unknown`: remove import-memory flag\n\n\n0.32.0\n---\n\n* **general**\n  - fix wasi-libc include headers on Nix\n  - apply OpenOCD commands after target configuration\n  - fix a minor race condition when determining the build tags\n  - support UF2 drives with a space in their name on Linux\n  - add LLVM 18 support\n  - drop support for Go 1.18 to be able to stay up to date\n\n* **compiler**\n  - move `-panic=trap` support to the compiler/runtime\n  - fix symbol table index for WebAssembly archives\n  - fix ed25519 build errors by adjusting the alias names\n  - add aliases to generic AES functions\n  - fix race condition by temporarily applying a proposed patch\n  - `builder`: keep un-wasm-opt'd .wasm if -work was passed\n  - `builder`: make sure wasm-opt command line is printed if asked\n  - `cgo`: implement shift operations in preprocessor macros\n  - `interp`: checking for methodset existence\n\n* **standard library**\n  - `machine`: add `__tinygo_spi_tx` function to simulator\n  - `machine`: fix simulator I2C support\n  - `machine`: add GetRNG support to simulator\n  - `machine`: add `TxFifoFreeLevel` for CAN\n  - `os`: add `Link`\n  - `os`: add `FindProcess` for posix\n  - `os`: add `Process.Release` for unix\n  - `os`: add `SetReadDeadline` stub\n  - `os`, `os/signal`: add signal stubs\n  - `os/user`: add stubs for `Lookup{,Group}` and `Group`\n  - `reflect`: use int in `StringHeader` and `SliceHeader` on non-AVR platforms\n  - `reflect`: fix `NumMethods` for Interface type\n  - `runtime`: skip negative sleep durations in sleepTicks\n\n* **targets**\n  - `esp32`: add I2C support\n  - `rp2040`: move UART0 and UART1 to common file\n  - `rp2040`: make all RP2040 boards available for simulation\n  - `rp2040`: fix timeUnit type\n  - `stm32`: add i2c `Frequency` and `SetBaudRate` function for chips that were missing implementation\n  - `wasm-unknown`: add math and memory builtins that LLVM needs\n  - `wasip1`: replace existing `-target=wasi` support with wasip1 as supported in Go 1.21+\n\n* **boards**\n  - `adafruit-esp32-feather-v2`: add the Adafruit ESP32 Feather V2\n  - `badger2040-w`: add support for the Badger2040 W\n  - `feather-nrf52840-sense`: fix lack of LXFO\n  - `m5paper`: add support for the M5 Paper\n  - `mksnanov3`: limit programming speed to 1800 kHz\n  - `nucleol476rg`: add stm32 nucleol476rg support\n  - `pico-w`: add the Pico W (which is near-idential to the pico target)\n  - `thingplus-rp2040`, `waveshare-rp2040-zero`: add WS2812 definition\n  - `pca10059-s140v7`: add this variant to the PCA10059 board\n\n\n0.31.2\n---\n\n* **general**\n  * update the `net` submodule to updated version with `Buffers` implementation\n\n* **compiler**\n  * `syscall`: add wasm_unknown tag to some additional files so it can compile more code\n\n* **standard library**\n  * `runtime`: add Frame.Entry field\n\n\n0.31.1\n---\n\n* **general**\n  * fix Binaryen build in make task\n  * update final build stage of Docker `dev` image to go1.22\n  * only use GHA cache for building Docker `dev` image\n  * update the `net` submodule to latest version\n\n* **compiler**\n  * `interp`: make getelementptr offsets signed\n  * `interp`: return a proper error message when indexing out of range\n\n\n0.31.0\n---\n\n* **general**\n  * remove LLVM 14 support\n  * add LLVM 17 support, and use it by default\n  * add Nix flake support\n  * update bundled Binaryen to version 116\n  * add `ports` subcommand that lists available serial ports for `-port` and `-monitor`\n  * support wasmtime version 14\n  * add `-serial=rtt` for serial output over SWD\n  * add Go 1.22 support and use it by default\n  * change minimum Node.js version from 16 to 18\n* **compiler**\n  * use the new LLVM pass manager\n  * allow systems with more stack space to allocate larger values on the stack\n  * `build`: fix a crash due to sharing GlobalValues between build instances\n  * `cgo`: add `C._Bool` type\n  * `cgo`: fix calling CGo callback inside generic function\n  * `compileopts`: set `purego` build tag by default so that more packages can be built\n  * `compileopts`: force-enable CGo to avoid build issues\n  * `compiler`: fix crash on type assert on interfaces with no methods\n  * `interp`: print LLVM instruction in traceback\n  * `interp`: support runtime times by running them at runtime\n  * `loader`: enforce Go language version in the type checker (this may break existing programs with an incorrect Go version in go.mod)\n  * `transform`: fix bug in StringToBytes optimization pass\n* **standard library**\n  * `crypto/tls`: stub out a lot of functions\n  * `internal/task`, `machine`: make TinyGo code usable with \"big Go\" CGo\n  * `machine`: implement `I2C.SetBaudRate` consistently across chips\n  * `machine`: implement `SPI.Configure` consistently across chips\n  * `machine`: add `DeviceID` for nrf, rp2040, sam, stm32\n  * `machine`: use smaller UART buffer size on atmega chips\n  * `machine/usb`: allow setting a serial number using a linker flag\n  * `math`: support more math functions on baremetal (picolibc) systems\n  * `net`: replace entire net package with a new one based on the netdev driver\n  * `os/user`: add bare-bones implementation of this package\n  * `reflect`: stub `CallSlice` and `FuncOf`\n  * `reflect`: add `TypeFor[T]`\n  * `reflect`: update `IsZero` to Go 1.22 semantics\n  * `reflect`: move indirect values into interface when setting interfaces\n  * `runtime`: stub `Breakpoint`\n  * `sync`: implement trylock\n* **targets**\n  * `atmega`: use UART double speed mode for fewer errors and higher throughput\n  * `atmega328pb`: refactor to enable extra uart\n  * `avr`: don't compile large parts of picolibc (math, stdio) for LLVM 17 support\n  * `esp32`: switch over to the official SVD file\n  * `esp32c3`: implement USB_SERIAL for USBCDC communication\n  * `esp32c3`: implement I2C\n  * `esp32c3`: implement RNG\n  * `esp32c3`: add more ROM functions and update linker script for the in-progress wifi support\n  * `esp32c3`: update to newer SVD files\n  * `rp2040`: add support for UART hardware flow control\n  * `rp2040`: add definition for `machine.PinToggle`\n  * `rp2040`: set XOSC startup delay multiplier\n  * `samd21`: add support for UART hardware flow control\n  * `samd51`: add support for UART hardware flow control\n  * `wasm`: increase default stack size to 64k for wasi/wasm targets\n  * `wasm`: bump wasi-libc version to SDK 20\n  * `wasm`: remove line of dead code in wasm_exec.js\n* **new targets/boards**\n  * `qtpy-esp32c3`: add Adafruit QT Py ESP32-C3 board\n  * `mksnanov3`: add support for the MKS Robin Nano V3.x\n  * `nrf52840-generic`: add generic nrf52840 chip support\n  * `thumby`: add support for Thumby\n  * `wasm`: add new `wasm-unknown` target that doesn't depend on WASI or a browser\n* **boards**\n  * `arduino-mkrwifi1010`, `arduino-nano33`, `nano-rp2040`, `matrixportal-m4`, `metro-m4-airlift`, `pybadge`, `pyportal`: add `ninafw` build tag and some constants for BLE support\n  * `gopher-badge`: fix typo in USB product name\n  * `nano-rp2040`: add UART1 and correct mappings for NINA via UART\n  * `pico`: bump default stack size from 2kB to 8kB\n  * `wioterminal`: expose UART4\n\n\n0.30.0\n---\n\n* **general**\n  - add LLVM 16 support, use it by default\n* **compiler**\n  - `build`: work around a race condition by building Go SSA serially\n  - `compiler`: fix a crash by not using the LLVM global context types\n  - `interp`: don't copy unknown values in `runtime.sliceCopy` to fix miscompile\n  - `interp`: fix crash in error report by not returning raw LLVM values\n* **standard library**\n  - `machine/usb/adc/midi`: various improvements and API changes\n  - `reflect`: add support for `[...]T` → `[]T` in reflect\n* **targets**\n  - `atsamd21`, `atsamd51`: add support for USB INTERRUPT OUT\n  - `rp2040`: always use the USB device enumeration fix, even in chips that supposedly have the HW fix\n  - `wasm`: increase default stack size to 32k for wasi/wasm\n* **boards**\n  - `gobadge`: add GoBadge target as alias for PyBadge :)\n  - `gemma-m0`: add support for the Adafruit Gemma M0\n\n\n0.29.0\n---\n\n* **general**\n  - Go 1.21 support\n  - use https for renesas submodule #3856\n  - ci: rename release-double-zipped to something more useful\n  - ci: update Node.js from version 14 to version 16\n  - ci: switch GH actions builds to use Go 1.21 final release\n  - docker: update clang to version 15\n  - docker: use Go 1.21 for Docker dev container build\n  - `main`: add target JSON file in `tinygo info` output\n  - `main`: improve detection of filesystems\n  - `main`: use `go env` instead of doing all detection manually\n  - make: add make task to generate Renesas device wrappers\n  - make: add task to check NodeJS version before running tests\n  - add submodule for Renesas SVD file mirror repo\n  - update to go-serial package v1.6.0\n  - `testing`: add Testing function\n  - `tools/gen-device-svd`: small changes needed for Renesas MCUs\n* **compiler**\n  - `builder`: update message for max supported Go version\n  - `compiler,reflect`: NumMethods reports exported methods only\n  - `compiler`: add compiler-rt and wasm symbols to table\n  - `compiler`: add compiler-rt to wasm.json\n  - `compiler`: add min and max builtin support\n  - `compiler`: implement clear builtin for maps\n  - `compiler`: implement clear builtin for slices\n  - `compiler`: improve panic message when a runtime call is unavailable\n  - `compiler`: update .ll test output\n  - `loader`: merge go.env file which is now required starting in Go 1.21 to correctly get required packages\n* **standard library**\n  - `os`: define ErrNoDeadline\n  - `reflect`: Add FieldByNameFunc\n  - `reflect`: add SetZero\n  - `reflect`: fix iterating over maps with interface{} keys\n  - `reflect`: implement Value.Grow\n  - `reflect`: remove unnecessary heap allocations\n  - `reflect`: use .key() instead of a type assert\n  - `sync`: add implementation from upstream Go for OnceFunc, OnceValue, and OnceValues\n* **targets**\n  - `machine`: UART refactor (#3832)\n  - `machine/avr`: pin change interrupt\n  - `machine/macropad_rp2040`: add machine.BUTTON\n  - `machine/nrf`: add I2C timeout\n  - `machine/nrf`: wait for stop condition after reading from the I2C bus\n  - `machine/nRF52`: set SPI TX/RX lengths even data is empty. Fixes #3868 (#3877)\n  - `machine/rp2040`: add missing suffix to CMD_READ_STATUS\n  - `machine/rp2040`: add NoPin support\n  - `machine/rp2040`: move flash related functions into separate file from C imports for correct  - LSP. Fixes #3852\n  - `machine/rp2040`: wait for 1000 us after flash reset to avoid issues with busy USB bus\n  - `machine/samd51,rp2040,nrf528xx,stm32`: implement watchdog\n  - `machine/samd51`: fix i2cTimeout was decreasing due to cache activation\n  - `machine/usb`: Add support for HID Keyboard LEDs\n  - `machine/usb`: allow USB Endpoint settings to be changed externally\n  - `machine/usb`: refactor endpoint configuration\n  - `machine/usb`: remove usbDescriptorConfig\n  - `machine/usb/hid,joystick`: fix hidreport (3) (#3802)\n  - `machine/usb/hid`: add RxHandler interface\n  - `machine/usb/hid`: rename Handler() to TxHandler()\n  - `wasi`: allow zero inodes when reading directories\n  - `wasm`: add support for GOOS=wasip1\n  - `wasm`: fix functions exported through //export\n  - `wasm`: remove i64 workaround, use BigInt instead\n  - `example`: adjust time offset\n  - `example`: simplify pininterrupt\n* **boards**\n  - `targets`: add AKIZUKI DENSHI AE-RP2040\n  - `targets`: adding new uf2 target for PCA10056 (#3765)\n\n\n0.28.0\n---\n\n* **general**\n  - fix parallelism in the compiler on Windows by building LLVM with thread support\n  - support qemu-user debugging\n  - make target JSON msd-volume-name an array\n  - print source location when a panic happens in -monitor\n  - `test`: don't print `ok` for a successful compile-only\n* **compiler**\n  - `builder`: remove non-ThinLTO build mode\n  - `builder`: fail earlier if Go is not available\n  - `builder`: improve `-size=full` in a number of ways\n  - `builder`: implement Nordic DFU file writer in Go\n  - `cgo`: allow `LDFLAGS: --export=...`\n  - `compiler`: support recursive slice types\n  - `compiler`: zero struct padding during map operations\n  - `compiler`: add llvm.ident metadata\n  - `compiler`: remove `unsafe.Pointer(uintptr(v) + idx)` optimization (use `unsafe.Add` instead)\n  - `compiler`: add debug info to `//go:embed` data structures for better `-size` output\n  - `compiler`: add debug info to string constants\n  - `compiler`: fix a minor race condition\n  - `compiler`: emit correct alignment in debug info for global variables\n  - `compiler`: correctly generate reflect data for local named types\n  - `compiler`: add alloc attributes to `runtime.alloc`, reducing flash usage slightly\n  - `compiler`: for interface maps, use the original named type if available\n  - `compiler`: implement most math/bits functions as LLVM intrinsics\n  - `compiler`: ensure all defers have been seen before creating rundefers\n* **standard library**\n  - `internal/task`: disallow blocking inside an interrupt\n  - `machine`: add `CPUReset`\n  - `machine/usb/hid`: add MediaKey support\n  - `machine/usb/hid/joystick`: move joystick under HID\n  - `machine/usb/hid/joystick`: allow joystick settings override\n  - `machine/usb/hid/joystick`: handle case where we cannot find the correct HID descriptor\n  - `machine/usb/hid/mouse`: add support for mouse back and forward\n  - `machine/usb`: add ability to override default VID, PID, manufacturer name, and product name\n  - `net`: added missing `TCPAddr` and `UDPAddr` implementations\n  - `os`: add IsTimeout function\n  - `os`: fix resource leak in `(*File).Close`\n  - `os`: add `(*File).Sync`\n  - `os`: implement `(*File).ReadDir` for wasi\n  - `os`: implement `(*File).WriteAt`\n  - `reflect`: make sure null bytes are supported in tags\n  - `reflect`: refactor this package to enable many new features\n  - `reflect`: add map type methods: `Elem` and `Key`\n  - `reflect`: add map methods: `MapIndex`, `MapRange`/`MapIter`, `SetMapIndex`, `MakeMap`, `MapKeys`\n  - `reflect`: add slice methods: `Append`, `MakeSlice`, `Slice`, `Slice3`, `Copy`, `Bytes`, `SetLen`\n  - `reflect`: add misc methods: `Zero`, `Addr`, `UnsafeAddr`, `OverflowFloat`, `OverflowInt`, `OverflowUint`, `SetBytes`, `Convert`, `CanInt`, `CanFloat`, `CanComplex`, `Comparable`\n  - `reflect`: add type methods: `String`, `PkgPath`, `FieldByName`, `FieldByIndex`, `NumMethod`\n  - `reflect`: add stubs for `Type.Method`, `CanConvert`, `ArrayOf`, `StructOf`, `MapOf`\n  - `reflect`: add stubs for channel select routines/types\n  - `reflect`: allow nil rawType to call Kind()\n  - `reflect`: ensure all ValueError panics have Kind fields\n  - `reflect`: add support for named types\n  - `reflect`: improve `Value.String()`\n  - `reflect`: set `Index` and `PkgPath` field in `Type.Field`\n  - `reflect`: `Type.AssignableTo`: you can assign anything to `interface{}`\n  - `reflect`: add type check to `Value.Field`\n  - `reflect`: let `TypeOf(nil)` return nil\n  - `reflect`: move `StructField.Anonymous` field to match upstream location\n  - `reflect`: add `UnsafePointer` for Func types\n  - `reflect`: `MapIter.Next` needs to allocate new keys/values every time\n  - `reflect`: fix `IsNil` for interfaces\n  - `reflect`: fix `Type.Name` to return an empty string for non-named types\n  - `reflect`: add `VisibleFields`\n  - `reflect`: properly handle embedded structs\n  - `reflect`: make sure `PointerTo` works for named types\n  - `reflect`: `Set`: convert non-interface to interface\n  - `reflect`: `Set`: fix direction of assignment check\n  - `reflect`: support channel directions\n  - `reflect`: print struct tags in Type.String()\n  - `reflect`: properly handle read-only values\n  - `runtime`: allow custom-gc SetFinalizer and clarify KeepAlive\n  - `runtime`: implement KeepAlive using inline assembly\n  - `runtime`: check for heap allocations inside interrupts\n  - `runtime`: properly turn pointer into empty interface when hashing\n  - `runtime`: improve map size hint usage\n  - `runtime`: zero map key/value on deletion to so GC doesn't see them\n  - `runtime`: print the address where a panic happened\n  - `runtime/debug`: stub `SetGCPercent`, `BuildInfo.Settings`\n  - `runtime/metrics`: add this package as a stub\n  - `syscall`: `Stat_t` timespec fields are Atimespec on darwin\n  - `syscall`: add `Timespec.Unix()` for wasi\n  - `syscall`: add fsync using libc\n  - `testing`: support -test.count\n  - `testing`: make test output unbuffered when verbose\n  - `testing`: add -test.skip\n  - `testing`: move runtime.GC() call to runN to match upstream\n  - `testing`: add -test.shuffle to order randomize test and benchmark order\n* **targets**\n  - `arm64`: fix register save/restore to include vector registers\n  - `attiny1616`: add support for this chip\n  - `cortexm`: refactor EnableInterrupts and DisableInterrupts to avoid `arm.AsmFull`\n  - `cortexm`: enable functions in RAM for go & cgo\n  - `cortexm`: convert SystemStack from `AsmFull` to C inline assembly\n  - `cortexm`: fix crash due to wrong stack size offset\n  - `nrf`: samd21, stm32: add flash API\n  - `nrf`: fix memory issue in ADC read\n  - `nrf`: new peripheral type for nrf528xx chips\n  - `nrf`: implement target mode\n  - `nrf`: improve ADC and add oversampling, longer sample time, and reference voltage\n  - `rp2040`: change calling order for device enumeration fix to do first\n  - `rp2040`: rtc delayed interrupt\n  - `rp2040`: provide better errors for invalid pins on I2C and SPI\n  - `rp2040`: change uart to allow for a single pin\n  - `rp2040`: implement Flash interface\n  - `rp2040`: remove SPI `DataBits` property\n  - `rp2040`: unify all linker scripts using LDFLAGS\n  - `rp2040`: remove SPI deadline for improved performance\n  - `rp2040`: use 4MHz as default frequency for SPI\n  - `rp2040`: implement target mode\n  - `rp2040`: use DMA for send-only SPI transfers\n  - `samd21`: rearrange switch case for get pin cfg\n  - `samd21`: fix issue with WS2812 driver by making pin accesses faster\n  - `samd51`: enable CMCC cache for greatly improved performance\n  - `samd51`: remove extra BK0RDY clear\n  - `samd51`: implement Flash interface\n  - `samd51`: use correct SPI frequency\n  - `samd51`: remove extra BK0RDY clear\n  - `samd51`: fix ADC multisampling\n  - `wasi`: allow users to set the `runtime_memhash_tsip` or `runtime_memhash_fnv` build tags\n  - `wasi`: set `WASMTIME_BACKTRACE_DETAILS` when running in wasmtime.\n  - `wasm`: implement the `//go:wasmimport` directive\n* **boards**\n  - `gameboy-advance`: switch to use register definitions in device/gba\n  - `gameboy-advance`: rename display and make pointer receivers\n  - `gopher-badge`: Added Gopher Badge support\n  - `lorae5`: add needed definition for UART2\n  - `lorae5`: correct mapping for I2C bus, add pin mapping to enable power\n  - `pinetime`: update the target file (rename from pinetime-devkit0)\n  - `qtpy`: fix bad pin assignment\n  - `wioterminal`: fix pin definition of BCM13\n  - `xiao`: Pins D4 & D5 are I2C1. Use pins D2 & D3 for I2C0.\n  - `xiao`: add DefaultUART\n\n\n0.27.0\n---\n\n* **general**\n  - all: update musl\n  - all: remove \"acm:\"` prefix for USB vid/pid pair\n  - all: add support for LLVM 15\n  - all: use DWARF version 4\n  - all: add initial (incomplete) support for Go 1.20\n  - all: add `-gc=custom` option\n  - `main`: print ldflags including ThinLTO flags with -x\n  - `main`: fix error message when a serial port can't be accessed\n  - `main`: add `-timeout` flag to allow setting how long TinyGo will try looking for a MSD volume for flashing\n  - `test`: print PASS on pass when running standalone test binaries\n  - `test`: fix printing of benchmark output\n  - `test`: print package name when compilation failed (not just when the test failed)\n* **compiler**\n  - refactor to support LLVM 15\n  - `builder`: print compiler commands while building a library\n  - `compiler`: fix stack overflow when creating recursive pointer types (fix for LLVM 15+ only)\n  - `compiler`: allow map keys and values of ≥256 bytes\n  - `cgo`: add support for `C.float` and `C.double`\n  - `cgo`: support anonymous enums included in multiple Go files\n  - `cgo`: add support for bitwise operators\n  - `interp`: add support for constant icmp instructions\n  - `transform`: fix memory corruption issues\n* **standard library**\n  - `machine/usb`: remove allocs in USB ISR\n  - `machine/usb`: add `Port()` and deprecate `New()` to have the API better match the singleton that is actually being returned\n  - `machine/usb`: change HID usage-maximum to 0xFF\n  - `machine/usb`: add USB HID joystick support\n  - `machine/usb`: change to not send before endpoint initialization\n  - `net`: implement `Pipe`\n  - `os`: add stub for `os.Chtimes`\n  - `reflect`: stub out `Type.FieldByIndex`\n  - `reflect`: add `Value.IsZero` method\n  - `reflect`: fix bug in `.Field` method when the field fits in a pointer but the parent doesn't\n  - `runtime`: switch some `panic()` calls in the gc to `runtimePanic()` for consistency\n  - `runtime`: add xorshift-based fastrand64\n  - `runtime`: fix alignment for arm64, arm, xtensa, riscv\n  - `runtime`: implement precise GC\n  - `runtime/debug`: stub `PrintStack`\n  - `sync`: implement simple pooling in `sync.Pool`\n  - `syscall`: stubbed `Setuid`, Exec and friends\n  - `syscall`: add more stubs as needed for Go 1.20 support\n  - `testing`: implement `t.Setenv`\n  - `unsafe`: add support for Go 1.20 slice/string functions\n* **targets**\n  - `all`: do not set stack size per board\n  - `all`: update picolibc to v1.7.9\n  - `atsame5x`: fix CAN extendedID handling\n  - `atsame5x`: reduce heap allocation\n  - `avr`: drop GNU toolchain dependency\n  - `avr`: fix .data initialization for binaries over 64kB\n  - `avr`: support ThinLTO\n  - `baremetal`: implements calloc\n  - `darwin`: fix `syscall.Open` on darwin/arm64\n  - `darwin`: fix error with `tinygo lldb`\n  - `esp`: use LLVM Xtensa linker instead of Espressif toolchain\n  - `esp`: use ThinLTO for Xtensa\n  - `esp32c3`: add SPI support\n  - `linux`: include musl `getpagesize` function in release\n  - `nrf51`: add ADC implementation\n  - `nrf52840`: add PDM support\n  - `riscv`: add \"target-abi\" metadata flag\n  - `rp2040`: remove mem allocation in GPIO ISR\n  - `rp2040`: avoid allocating clock on heap\n  - `rp2040`: add basic GPIO support for PIO\n  - `rp2040`: fix USB interrupt issue\n  - `rp2040`: fix RP2040-E5 USB errata\n  - `stm32`: always set ADC pins to pullups floating\n  - `stm32f1`, `stm32f4`: fix ADC by clearing the correct bit for rank after each read\n  - `stm32wl`: Fix incomplete RNG initialisation\n  - `stm32wlx`: change order for init so clock speeds are set before peripheral start\n  - `wasi`: makes wasmtime \"run\" explicit\n  - `wasm`: fix GC scanning of allocas\n  - `wasm`: allow custom malloc implementation\n  - `wasm`: remove `-wasm-abi=` flag (use `-target` instead)\n  - `wasm`: fix scanning of the stack\n  - `wasm`: fix panic when allocating 0 bytes using malloc\n  - `wasm`: always run wasm-opt even with `-scheduler=none`\n  - `wasm`: avoid miscompile with ThinLTO\n  - `wasm`: allow the emulator to expand `{tmpDir}`\n  - `wasm`: support ThinLTO\n  - `windows`: update mingw-w64 version to avoid linker warning\n  - `windows`: add ARM64 support\n* **boards**\n  - Add Waveshare RP2040 Zero\n  - Add Arduino Leonardo support\n  - Add Adafruit KB2040\n  - Add Adafruit Feather M0 Express\n  - Add Makerfabs ESP32C3SPI35 TFT Touchscreen board\n  - Add Espressif ESP32-C3-DevKit-RUST-1 board\n  - `lgt92`: fix OpenOCD configuration\n  - `xiao-rp2040`: fix D9 and D10 constants\n  - `xiao-rp2040`: add pin definitions\n\n0.26.0\n---\n\n* **general**\n  - remove support for LLVM 13\n  - remove calls to deprecated ioutil package\n  - move from `os.IsFoo` to `errors.Is(err, ErrFoo)`\n  - fix for builds using an Android host\n  - make interp timeout configurable from command line\n  - ignore ports with VID/PID if there is no candidates\n  - drop support for Go 1.16 and Go 1.17\n  - update serial package to v1.3.5 for latest bugfixes\n  - remove GOARM from `tinygo info`\n  - add flag for setting the goroutine stack size\n  - add serial port monitoring functionality\n* **compiler**\n  - `cgo`: implement support for static functions\n  - `cgo`: fix panic when FuncType.Results is nil\n  - `compiler`: add aliases for `edwards25519/field.feMul` and `field.feSquare`\n  - `compiler`: fix incorrect DWARF type in some generic parameters\n  - `compiler`: use LLVM math builtins everywhere\n  - `compiler`: replace some math operation bodies with LLVM intrinsics\n  - `compiler`: replace math aliases with intrinsics\n  - `compiler`: fix `unsafe.Sizeof` for chan and map values\n  - `compileopts`: use tags parser from buildutil\n  - `compileopts`: use backticks for regexp to avoid extra escapes\n  - `compileopts`: fail fast on duplicate values in target field slices\n  - `compileopts`: fix windows/arm target triple\n  - `compileopts`: improve error handling when loading target/*.json\n  - `compileopts`: add support for stlink-dap programmer\n  - `compileopts`: do not complain about `-no-debug` on MacOS\n  - `goenv`: support `GOOS=android`\n  - `interp`: fix reading from external global\n  - `loader`: fix link error for `crypto/internal/boring/sig.StandardCrypto`\n* **standard library**\n  - rename assembly files to .S extension\n  - `machine`: add PWM peripheral comments to pins\n  - `machine`: improve UARTParity slightly\n  - `machine`: do not export DFU_MAGIC_* constants on nrf52840\n  - `machine`: rename `PinInputPullUp`/`PinInputPullDown`\n  - `machine`: add `KHz`, `MHz`, `GHz` constants, deprecate `TWI_FREQ_*` constants\n  - `machine`: remove level triggered pin interrupts\n  - `machine`: do not expose `RESET_MAGIC_VALUE`\n  - `machine`: use `NoPin` constant where appropriate (instead of `0` for example)\n  - `net`: sync net.go with Go 1.18 stdlib\n  - `os`: add `SyscallError.Timeout`\n  - `os`: add `ErrProcessDone` error\n  - `reflect`: implement `CanInterface` and fix string `Index`\n  - `runtime`: make `MemStats` available to leaking collector\n  - `runtime`: add `MemStats.TotalAlloc`\n  - `runtime`: add `MemStats.Mallocs` and `Frees`\n  - `runtime`: add support for `time.NewTimer` and `time.NewTicker`\n  - `runtime`: implement `resetTimer`\n  - `runtime`: ensure some headroom for the GC to run\n  - `runtime`: make gc and scheduler asserts settable with build tags\n  - `runtime/pprof`: add `WriteHeapProfile`\n  - `runtime/pprof`: `runtime/trace`: stub some additional functions\n  - `sync`: implement `Map.LoadAndDelete`\n  - `syscall`: group WASI consts by purpose\n  - `syscall`: add WASI `{D,R}SYNC`, `NONBLOCK` FD flags\n  - `syscall`: add ENOTCONN on darwin\n  - `testing`: add support for -benchmem\n* **targets**\n  - remove USB vid/pid pair of bootloader\n  - `esp32c3`: remove unused `UARTStopBits` constants\n  - `nrf`: implement `GetRNG` function\n  - `nrf`: `rp2040`: add `machine.ReadTemperature`\n  - `nrf52`: cleanup s140v6 and s140v7 uf2 targets\n  - `rp2040`: implement semi-random RNG based on ROSC based on pico-sdk\n  - `wasm`: add summary of wasm examples and fix callback bug\n  - `wasm`: do not allow undefined symbols (`--allow-undefined`)\n  - `wasm`: make sure buffers returned by `malloc` are kept until `free` is called\n  - `windows`: save and restore xmm registers when switching goroutines\n* **boards**\n  - add Pimoroni's Tufty2040\n  - add XIAO ESP32C3\n  - add Adafruit QT2040\n  - add Adafruit QT Py RP2040\n  - `esp32c3-12f`: `matrixportal-m4`: `p1am-100`: remove duplicate build tags\n  - `hifive1-qemu`: remove this emulated board\n  - `wioterminal`: add UART3 for RTL8720DN\n  - `xiao-ble`: fix usbpid\n\n\n0.25.0\n---\n\n* **command line**\n  - change to ignore PortReset failures\n* **compiler**\n  - `compiler`: darwin/arm64 is aarch64, not arm\n  - `compiler`: don't clobber X18 and FP registers on darwin/arm64\n  - `compiler`: fix issue with methods on generic structs\n  - `compiler`: do not try to build generic functions\n  - `compiler`: fix type names for generic named structs\n  - `compiler`: fix multiple defined function issue for generic functions\n  - `compiler`: implement `unsafe.Alignof` and `unsafe.Sizeof` for generic code\n* **standard library**\n  - `machine`: add DTR and RTS to Serialer interface\n  - `machine`: reorder pin definitions to improve pin list on tinygo.org\n  - `machine/usb`: add support for MIDI\n  - `machine/usb`: adjust buffer alignment (samd21, samd51, nrf52840)\n  - `machine/usb/midi`: add `NoteOn`, `NoteOff`, and `SendCC` methods\n  - `machine/usb/midi`: add definition of MIDI note number\n  - `runtime`: add benchmarks for memhash\n  - `runtime`: add support for printing slices via print/println\n* **targets**\n  - `avr`: fix some apparent mistake in atmega1280/atmega2560 pin constants\n  - `esp32`: provide hardware pin constants\n  - `esp32`: fix WDT reset on the MCH2022 badge\n  - `esp32`: optimize SPI transmit\n  - `esp32c3`: provide hardware pin constants\n  - `esp8266`: provide hardware pin constants like `GPIO2`\n  - `nrf51`: define and use `P0_xx` constants\n  - `nrf52840`, `samd21`, `samd51`: unify bootloader entry process\n  - `nrf52840`, `samd21`, `samd51`: change usbSetup and sendZlp to public\n  - `nrf52840`, `samd21`, `samd51`: refactor handleStandardSetup and initEndpoint\n  - `nrf52840`, `samd21`, `samd51`: improve usb-device initialization\n  - `nrf52840`, `samd21`, `samd51`: move usbcdc to machine/usb/cdc\n  - `rp2040`: add usb serial vendor/product ID\n  - `rp2040`: add support for usb\n  - `rp2040`: change default for serial to usb\n  - `rp2040`: add support for `machine.EnterBootloader`\n  - `rp2040`: turn off pullup/down when input type is not specified\n  - `rp2040`: make picoprobe default openocd interface\n  - `samd51`: add support for `DAC1`\n  - `samd51`: improve TRNG\n  - `wasm`: stub `runtime.buffered`, `runtime.getchar`\n  - `wasi`: make leveldb runtime hash the default\n* **boards**\n  - add Challenger RP2040 LoRa\n  - add MCH2022 badge\n  - add XIAO RP2040\n  - `clue`: remove pins `D21`..`D28`\n  - `feather-rp2040`, `macropad-rp2040`: fix qspi-flash settings\n  - `xiao-ble`: add support for flash-1200-bps-reset\n  - `gopherbot`, `gopherbot2`: add these aliases to simplify for newer users\n\n\n0.24.0\n---\n\n* **command line**\n  - remove support for go 1.15\n  - remove support for LLVM 11 and LLVM 12\n  - add initial Go 1.19 beta support\n  - `test`: fix package/... syntax\n* **compiler**\n  - add support for the embed package\n  - `builder`: improve error message for \"command not found\"\n  - `builder`: add support for ThinLTO on MacOS and Windows\n  - `builder`: free LLVM objects after use, to reduce memory leaking\n  - `builder`: improve `-no-debug` error messages\n  - `cgo`: be more strict: CGo now requires every Go file to import the headers it needs\n  - `compiler`: alignof(func) is 1 pointer, not 2\n  - `compiler`: add support for type parameters (aka generics)\n  - `compiler`: implement `recover()` built-in function\n  - `compiler`: support atomic, volatile, and LLVM memcpy-like functions in defer\n  - `compiler`: drop support for macos syscalls via inline assembly\n  - `interp`: do not try to interpret past task.Pause()\n  - `interp`: fix some buggy localValue handling\n  - `interp`: do not unroll loops\n  - `transform`: fix MakeGCStackSlots that caused a possible GC bug on WebAssembly\n* **standard library**\n  - `os`: enable os.Stdin for baremetal target\n  - `reflect`: add `Value.UnsafePointer` method\n  - `runtime`: scan GC globals conservatively on Windows, MacOS, Linux and Nintendo Switch\n  - `runtime`: add per-map hash seeds\n  - `runtime`: handle nil map write panics\n  - `runtime`: add stronger hash functions\n  - `syscall`: implement `Getpagesize`\n* **targets**\n  - `atmega2560`: support UART1-3 + example for uart\n  - `avr`: use compiler-rt for improved float64 support\n  - `avr`: simplify timer-based time\n  - `avr`: fix race condition in stack write\n  - `darwin`: add support for `GOARCH=arm64` (aka Apple Silicon)\n  - `darwin`: support `-size=short` and `-size=full` flag\n  - `rp2040`: replace sleep 'busy loop' with timer alarm\n  - `rp2040`: align api for `PortMaskSet`, `PortMaskClear`\n  - `rp2040`: fix GPIO interrupts\n  - `samd21`, `samd51`, `nrf52840`: add support for USBHID (keyboard / mouse)\n  - `wasm`: update wasi-libc version\n  - `wasm`: use newer WebAssembly features\n* **boards**\n  - add Badger 2040\n  - `matrixportal-m4`: attach USB DP to the correct pin\n  - `teensy40`: add I2C support\n  - `wioterminal`: fix I2C definition\n\n\n0.23.0\n---\n\n* **command line**\n  - add `-work` flag\n  - add Go 1.18 support\n  - add LLVM 14 support\n  - `run`: add support for command-line parameters\n  - `build`: calculate default output path if `-o` is not specified\n  - `build`: add JSON output\n  - `test`: support multiple test binaries with `-c`\n  - `test`: support flags like `-v` on all targets (including emulated firmware)\n* **compiler**\n  - add support for ThinLTO\n  - use compiler-rt from LLVM\n  - `builder`: prefer GNU build ID over Go build ID for caching\n  - `builder`: add support for cross compiling to Darwin\n  - `builder`: support machine outlining pass in stacksize calculation\n  - `builder`: disable asynchronous unwind tables\n  - `compileopts`: fix emulator configuration on non-amd64 Linux architectures\n  - `compiler`: move allocations > 256  bytes to the heap\n  - `compiler`: fix incorrect `unsafe.Alignof` on some 32-bit architectures\n  - `compiler`: accept alias for slice `cap` builtin\n  - `compiler`: allow slices of empty structs\n  - `compiler`: fix difference in aliases in interface methods\n  - `compiler`: make `RawSyscall` an alias for `Syscall`\n  - `compiler`: remove support for memory references in `AsmFull`\n  - `loader`: only add Clang header path for CGo\n  - `transform`: fix poison value in heap-to-stack transform\n* **standard library**\n  - `internal/fuzz`: add this package as a shim\n  - `os`: implement readdir for darwin and linux\n  - `os`: add `DirFS`, which is used by many programs to access readdir.\n  - `os`: isWine: be compatible with older versions of wine, too\n  - `os`: implement `RemoveAll`\n  - `os`: Use a `uintptr` for `NewFile`\n  - `os`: add stubs for `exec.ExitError` and `ProcessState.ExitCode`\n  - `os`: export correct values for `DevNull` for each OS\n  - `os`: improve support for `Signal` by fixing various bugs\n  - `os`: implement `File.Fd` method\n  - `os`: implement `UserHomeDir`\n  - `os`: add `exec.ProcessState` stub\n  - `os`: implement `Pipe` for darwin\n  - `os`: define stub `ErrDeadlineExceeded`\n  - `reflect`: add stubs for more missing methods\n  - `reflect`: rename `reflect.Ptr` to `reflect.Pointer`\n  - `reflect`: add `Value.FieldByIndexErr` stub\n  - `runtime`: fix various small GC bugs\n  - `runtime`: use memzero for leaking collector instead of manually zeroing objects\n  - `runtime`: implement `memhash`\n  - `runtime`: implement `fastrand`\n  - `runtime`: add stub for `debug.ReadBuildInfo`\n  - `runtime`: add stub for `NumCPU`\n  - `runtime`: don't inline `runtime.alloc` with `-gc=leaking`\n  - `runtime`: add `Version`\n  - `runtime`: add stubs for `NumCgoCall` and `NumGoroutine`\n  - `runtime`: stub {Lock,Unlock}OSThread on Windows\n  - `runtime`: be able to deal with a very small heap\n  - `syscall`: make `Environ` return a copy of the environment\n  - `syscall`: implement getpagesize and munmap\n  - `syscall`: `wasi`: define `MAP_SHARED` and `PROT_READ`\n  - `syscall`: stub mmap(), munmap(), MAP_SHARED, PROT_READ, SIGBUS, etc. on nonhosted targets\n  - `syscall`: darwin: more complete list of signals\n  - `syscall`: `wasi`: more complete list of signals\n  - `syscall`: stub `WaitStatus`\n  - `syscall/js`: allow copyBytesTo(Go|JS) to use `Uint8ClampedArray`\n  - `testing`: implement `TempDir`\n  - `testing`: nudge type TB closer to upstream; should be a no-op change.\n  - `testing`: on baremetal platforms, use simpler test matcher\n* **targets**\n  - `atsamd`: fix usbcdc initialization when `-serial=uart`\n  - `atsamd51`: allow higher frequency when using SPI\n  - `esp`: support CGo\n  - `esp32c3`: add support for input pin\n  - `esp32c3`: add support for GPIO interrupts\n  - `esp32c3`: add support to receive UART data\n  - `rp2040`: fix PWM bug at high frequency\n  - `rp2040`: fix some minor I2C bugs\n  - `rp2040`: fix incorrect inline assembly\n  - `rp2040`: fix spurious i2c STOP during write+read transaction\n  - `rp2040`: improve ADC support\n  - `wasi`: remove `--export-dynamic` linker flag\n  - `wasm`: remove heap allocator from wasi-libc\n* **boards**\n  - `circuitplay-bluefruit`: move pin mappings so board can be compiled for WASM use in Playground\n  - `esp32-c3-12f`: add the ESP32-C3-12f Kit\n  - `m5stamp-c3`: add pin setting of UART\n  - `macropad-rp2040`: add the Adafruit MacroPad RP2040 board\n  - `nano-33-ble`: typo in LPS22HB peripheral definition and documentation (#2579)\n  - `teensy41`: add the Teensy 4.1 board\n  - `teensy40`: add ADC support\n  - `teensy40`: add SPI support\n  - `thingplus-rp2040`: add the SparkFun Thing Plus RP2040 board\n  - `wioterminal`: add DefaultUART\n  - `wioterminal`: verify written data when flashing through OpenOCD\n  - `xiao-ble`: add XIAO BLE nRF52840 support\n\n\n0.22.0\n---\n\n* **command line**\n  - add asyncify to scheduler flag help\n  - support -run for tests\n  - remove FreeBSD target support\n  - add LLVM 12 and LLVM 13 support, use LLVM 13 by default\n  - add support for ARM64 MacOS\n  - improve help\n  - check /run/media as well as /media on Linux for non-debian-based distros\n  - `test`: set cmd.Dir even when running emulators\n  - `info`: add JSON output using the `-json` flag\n* **compiler**\n  - `builder`: fix off-by-one in size calculation\n  - `builder`: handle concurrent library header rename\n  - `builder`: use flock to avoid double-compiles\n  - `builder`: use build ID as cache key\n  - `builder`: add -fno-stack-protector to musl build\n  - `builder`: update clang header search path to look in /usr/lib\n  - `builder`: explicitly disable unwind tables for ARM\n  - `cgo`: add support for `C.CString` and related functions\n  - `compiler`: fix ranging over maps with particular map types\n  - `compiler`: add correct debug location to init instructions\n  - `compiler`: fix emission of large object layouts\n  - `compiler`: work around AVR atomics bugs\n  - `compiler`: predeclare runtime.trackPointer\n  - `interp`: work around AVR function pointers in globals\n  - `interp`: run goroutine starts and checks at runtime\n  - `interp`: always run atomic and volatile loads/stores at runtime\n  - `interp`: bump timeout to 180 seconds\n  - `interp`: handle type assertions on nil interfaces\n  - `loader`: eliminate goroot cache inconsistency\n  - `loader`: respect $GOROOT when running `go list`\n  - `transform`: allocate the correct amount of bytes in an alloca\n  - `transform`: remove switched func lowering\n* **standard library**\n  - `crypto/rand`: show error if platform has no rng\n  - `device/*`: add `*_Msk` field for each bit field and avoid duplicates\n  - `device/*`: provide Set/Get for each register field described in the SVD files\n  - `internal/task`: swap stack chain when switching goroutines\n  - `internal/task`: remove `-scheduler=coroutines`\n  - `machine`: add `Device` string constant\n  - `net`: add bare Interface implementation\n  - `net`: add net.Buffers\n  - `os`: stub out support for some features\n  - `os`: obey TMPDIR on unix, TMP on Windows, etc\n  - `os`: implement `ReadAt`, `Mkdir`, `Remove`, `Stat`, `Lstat`, `CreateTemp`, `MkdirAll`, `Chdir`, `Chmod`, `Clearenv`, `Unsetenv`, `Setenv`, `MkdirTemp`, `Rename`, `Seek`, `ExpandEnv`, `Symlink`, `Readlink`\n  - `os`: implement `File.Stat`\n  - `os`: fix `IsNotExist` on nonexistent path\n  - `os`: fix opening files on WASI in read-only mode\n  - `os`: work around lack of `syscall.seek` on 386 and arm\n  - `reflect`: make sure indirect pointers are handled correctly\n  - `runtime`: allow comparing interfaces\n  - `runtime`: use LLVM intrinsic to read the stack pointer\n  - `runtime`: strengthen hashmap hash function for structs and arrays\n  - `runtime`: fix float/complex hashing\n  - `runtime`: fix nil map dereference\n  - `runtime`: add realloc implementation to GCs\n  - `runtime`: handle negative sleep times\n  - `runtime`: correct GC scan bounds\n  - `runtime`: remove extalloc GC\n  - `rumtime`: implement `__sync` libcalls as critical sections for most microcontrollers\n  - `runtime`: add stubs for `Func.FileLine` and `Frame.PC`\n  - `sync`: fix concurrent read-lock on write-locked RWMutex\n  - `sync`: add a package doc\n  - `sync`: add tests\n  - `syscall`: add support for `Mmap` and `Mprotect`\n  - `syscall`: fix array size for mmap slice creation\n  - `syscall`: enable `Getwd` in wasi\n  - `testing`: add a stub for `CoverMode`\n  - `testing`: support -bench option to run benchmarks matching the given pattern.\n  - `testing`: support b.SetBytes(); implement sub-benchmarks.\n  - `testing`: replace spaces with underscores in test/benchmark names, as upstream does\n  - `testing`: implement testing.Cleanup\n  - `testing`: allow filtering subbenchmarks with the `-bench` flag\n  - `testing`: implement `-benchtime` flag\n  - `testing`: print duration\n  - `testing`: allow filtering of subtests using `-run`\n* **targets**\n  - `all`: change LLVM features to match vanilla Clang\n  - `avr`: use interrupt-based timer which is much more accurate\n  - `nrf`: fix races in I2C\n  - `samd51`: implement TRNG for randomness\n  - `stm32`: pull-up on I2C lines\n  - `stm32`: fix timeout for i2c comms\n  - `stm32f4`, `stm32f103`: initial implementation for ADC\n  - `stm32f4`, `stm32f7`, `stm32l0x2`, `stm32l4`, `stm32l5`, `stm32wl`: TRNG implementation in crypto/rand\n  - `stm32wl`: add I2C support\n  - `windows`: add support for the `-size=` flag\n  - `wasm`: add support for `tinygo test`\n  - `wasi`, `wasm`: raise default stack size to 16 KiB\n* **boards**\n  - add M5Stack\n  - add lorae5 (stm32wle) support\n  - add Generic Node Sensor Edition\n  - add STM32F469 Discovery\n  - add M5Stamp C3\n  - add Blues Wireless Swan\n  - `bluepill`: add definitions for ADC pins\n  - `stm32f4disco`: add definitions for ADC pins\n  - `stm32l552ze`: use supported stlink interface\n  - `microbit-v2`: add some pin definitions\n\n\n0.21.0\n---\n\n* **command line**\n  - drop support for LLVM 10\n  - `build`: drop support for LLVM targets in the -target flag\n  - `build`: fix paths in error messages on Windows\n  - `build`: add -p flag to set parallelism\n  - `lldb`: implement `tinygo lldb` subcommand\n  - `test`: use emulator exit code instead of parsing test output\n  - `test`: pass testing arguments to wasmtime\n* **compiler**\n  - use -opt flag for optimization level in CFlags (-Os, etc)\n  - `builder`: improve accuracy of the -size=full flag\n  - `builder`: hardcode some more frame sizes for __aeabi_* functions\n  - `builder`: add support for -size= flag for WebAssembly\n  - `cgo`: fix line/column reporting in syntax error messages\n  - `cgo`: support function definitions in CGo headers\n  - `cgo`: implement rudimentary C array decaying\n  - `cgo`: add support for stdio in picolibc and wasi-libc\n  - `cgo`: run CGo parser per file, not per CGo fragment\n  - `compiler`: fix unintentionally exported math functions\n  - `compiler`: properly implement div and rem operations\n  - `compiler`: add support for recursive function types\n  - `compiler`: add support for the `go` keyword on interface methods\n  - `compiler`: add minsize attribute for -Oz\n  - `compiler`: add \"target-cpu\" and \"target-features\" attributes\n  - `compiler`: fix indices into strings and arrays\n  - `compiler`: fix string compare functions\n  - `interp`: simplify some code to avoid some errors\n  - `interp`: support recursive globals (like linked lists) in globals\n  - `interp`: support constant globals\n  - `interp`: fix reverting of extractvalue/insertvalue with multiple indices\n  - `transform`: work around renamed return type after merging LLVM modules\n* **standard library**\n  - `internal/bytealg`: fix indexing error in Compare()\n  - `machine`: support Pin.Get() function when the pin is configured as output\n  - `net`, `syscall`: Reduce code duplication by switching to internal/itoa.\n  - `os`: don't try to read executable path on baremetal\n  - `os`: implement Getwd\n  - `os`: add File.WriteString and File.WriteAt\n  - `reflect`: fix type.Size() to account for struct padding\n  - `reflect`: don't construct an interface-in-interface value\n  - `reflect`: implement Value.Elem() for interface values\n  - `reflect`: fix Value.Index() in a specific case\n  - `reflect`: add support for DeepEqual\n  - `runtime`: add another set of invalid unicode runes to encodeUTF8()\n  - `runtime`: only initialize os.runtime_args when needed\n  - `runtime`: only use CRLF on baremetal systems for println\n  - `runtime/debug`: stub `debug.SetMaxStack`\n  - `runtime/debug`: stub `debug.Stack`\n  - `testing`: add a stub for t.Parallel()\n  - `testing`: add support for -test.short flag\n  - `testing`: stub B.ReportAllocs()\n  - `testing`: add `testing.Verbose`\n  - `testing`: stub `testing.AllocsPerRun`\n* **targets**\n  - fix gen-device-svd to handle 64-bit values\n  - add CPU and Features property to all targets\n  - match LLVM triple to the one Clang uses\n  - `atsam`: simplify definition of SERCOM UART, I2C and SPI peripherals\n  - `atsam`: move I2S0 to machine file\n  - `esp32`: fix SPI configuration\n  - `esp32c3`: add support for GDB debugging\n  - `esp32c3`: add support for CPU interrupts\n  - `esp32c3`: use tasks scheduler by default\n  - `fe310`: increase CPU frequency from 16MHz to 320MHz\n  - `fe310`: add support for bit banging drivers\n  - `linux`: build static binaries using musl\n  - `linux`: reduce binary size by calling `write` instead of `putchar`\n  - `linux`: add support for GOARM\n  - `riscv`: implement 32-bit atomic operations\n  - `riscv`: align the heap to 16 bytes\n  - `riscv`: switch to tasks-based scheduler\n  - `rp2040`: add CPUFrequency()\n  - `rp2040`: improve I2C baud rate configuration\n  - `rp2040`: add pin interrupt API\n  - `rp2040`: refactor PWM code and fix Period calculation\n  - `stm32f103`: fix SPI\n  - `stm32f103`: make SPI frequency selection more flexible\n  - `qemu`: signal correct exit code to QEMU\n  - `wasi`: run C/C++ constructors at startup\n  - `wasm`: ensure heapptr is aligned\n  - `wasm`: update wasi-libc dependency\n  - `wasm`: wasi: use asyncify\n  - `wasm`: support `-scheduler=none`\n  - `windows`: add support for Windows (amd64 only for now)\n* **boards**\n  - `feather-stm32f405`, `feather-rp2040`: add I2C pin names\n  - `m5stack-core2`: add M5Stack Core2\n  - `nano-33-ble`: SoftDevice s140v7 support\n  - `nano-33-ble`: add constants for more on-board pins\n\n\n0.20.0\n---\n\n* **command line**\n  - add support for Go 1.17\n  - improve Go version detection\n  - add support for the Black Magic Probe (BMP)\n  - add a flag for creating cpu profiles\n* **compiler**\n  - `builder:` list libraries at the end of the linker command\n  - `builder:` strip debug information at link time instead of at compile time\n  - `builder:` add missing error check for `ioutil.TempFile()`\n  - `builder:` simplify running of jobs\n  - `compiler:` move LLVM math builtin support into the compiler\n  - `compiler:` move math aliases from the runtime to the compiler\n  - `compiler:` add aliases for many hashing packages\n  - `compiler:` add `*ssa.MakeSlice` bounds tests\n  - `compiler:` fix max possible slice\n  - `compiler:` add support for new language features of Go 1.17\n  - `compiler:` fix equally named structs in different scopes\n  - `compiler:` avoid zero-sized alloca in channel operations\n  - `interp:` don't ignore array indices for untyped objects\n  - `interp:` keep reverted package initializers in order\n  - `interp:` fix bug in compiler-time/run-time package initializers\n  - `loader:` fix panic in CGo files with syntax errors\n  - `transform:` improve GC stack slot pass to work around a bug\n* **standard library**\n  - `crypto/rand`: switch to `arc4random_buf`\n  - `math:` fix `math.Max` and `math.Min`\n  - `math/big`: fix undefined symbols error\n  - `net:` add MAC address implementation\n  - `os:` implement `os.Executable`\n  - `os:` add `SEEK_SET`, `SEEK_CUR`, and `SEEK_END`\n  - `reflect:` add StructField.IsExported method\n  - `runtime:` reset heapptr to heapStart after preinit()\n  - `runtime:` add `subsections_via_symbols` to assembly files on darwin\n  - `testing:` add subset implementation of Benchmark\n  - `testing:` test testing package using `tinygo test`\n  - `testing:` add support for the `-test.v` flag\n* **targets**\n  - `386:` bump minimum requirement to the Pentium 4\n  - `arm:` switch to Thumb instruction set on ARM\n  - `atsamd:` fix copy-paste error for atsamd21/51 calibTrim block\n  - `baremetal`,`wasm`: support command line params and environment variables\n  - `cortexm:` fix stack overflow because of unaligned stacks\n  - `esp32c3:` add support for the ESP32-C3 from Espressif\n  - `nrf52840:` fix ram size\n  - `nxpmk66f18:` fix a suspicious bitwise operation\n  - `rp2040:` add SPI support\n  - `rp2040:` add I2C support\n  - `rp2040:` add PWM implementation\n  - `rp2040:` add openocd configuration\n  - `stm32:` add support for PortMask* functions for WS2812 support\n  - `unix:` fix time base for time.Now()\n  - `unix:` check for mmap error and act accordingly\n  - `wasm:` override dlmalloc heap implementation from wasi-libc\n  - `wasm:` align heap to 16 bytes\n  - `wasm:` add support for the crypto/rand package\n* **boards**\n  - add `DefaultUART` to adafruit boards\n  - `arduino-mkrwifi1010:` add board definition for Arduino MKR WiFi 1010\n  - `arduino-mkrwifi1010:` fix pin definition of `NINA_RESETN`\n  - `feather-nrf52:` fix pin definition of uart\n  - `feather-rp2040:` add pin name definition\n  - `gameboy-advance:` fix ROM header\n  - `mdbt50qrx-uf2:` add Raytac MDBT50Q-RX Dongle with TinyUF2\n  - `nano-rp2040:` define `NINA_SPI` and fix wifinina pins\n  - `teensy40:` enable hardware UART reconfiguration, fix receive watermark interrupt\n\n\n0.19.0\n---\n\n* **command line**\n  - don't consider compile-only tests as failing\n  - add -test flag for `tinygo list`\n  - escape commands while printing them with the -x flag\n  - make flash-command portable and safer to use\n  - use `extended-remote` instead of `remote` in GDB\n  - detect specific serial port IDs based on USB vid/pid\n  - add a flag to the command line to select the serial implementation\n* **compiler**\n  - `cgo`: improve constant parser\n  - `compiler`: support chained interrupt handlers\n  - `compiler`: add support for running a builtin in a goroutine\n  - `compiler`: do not emit nil checks for loading closure variables\n  - `compiler`: skip context parameter when starting regular goroutine\n  - `compiler`: refactor method names\n  - `compiler`: add function and global section pragmas\n  - `compiler`: implement `syscall.rawSyscallNoError` in inline assembly\n  - `interp`: ignore inline assembly in markExternal\n  - `interp`: fix a bug in pointer cast workaround\n  - `loader`: fix testing a main package\n* **standard library**\n  - `crypto/rand`: replace this package with a TinyGo version\n  - `machine`: make USBCDC global a pointer\n  - `machine`: make UART objects pointer receivers\n  - `machine`: define Serial as the default output\n  - `net`: add initial support for net.IP\n  - `net`: add more net compatibility\n  - `os`: add stub for os.ReadDir\n  - `os`: add FileMode constants from Go 1.16\n  - `os`: add stubs required for net/http\n  - `os`: implement process related functions\n  - `reflect`: implement AppendSlice\n  - `reflect`: add stubs required for net/http\n  - `runtime`: make task.Data a 64-bit integer to avoid overflow\n  - `runtime`: expose memory stats\n  - `sync`: implement NewCond\n  - `syscall`: fix int type in libc version\n* **targets**\n  - `cortexm`: do not disable interrupts on abort\n  - `cortexm`: bump default stack size to 2048 bytes\n  - `nrf`: avoid heap allocation in waitForEvent\n  - `nrf`: don't trigger a heap allocation in SPI.Transfer\n  - `nrf52840`: add support for flashing with the BOSSA tool\n  - `rp2040`: add support for GPIO input\n  - `rp2040`: add basic support for ADC\n  - `rp2040`: gpio and adc pin definitions\n  - `rp2040`: implement UART\n  - `rp2040`: patch elf to checksum 2nd stage boot\n  - `stm32`: add PWM for most chips\n  - `stm32`: add support for pin interrupts\n  - `stm32f103`: add support for PinInputPullup / PinInputPulldown\n  - `wasi`: remove wasm build tag\n* **boards**\n  - `feather-rp2040`: add support for this board\n  - `feather-nrf52840-sense`: add board definition for this board\n  - `pca10059`: support flashing from Windows\n  - `nano-rp2040`: add this board\n  - `nano-33-ble`: add support for this board\n  - `pico`: add the Raspberry Pi Pico board with the new RP2040 chip\n  - `qtpy`: add pin for neopixels\n  - all: add definition for ws2812 for supported boards\n\n\n0.18.0\n---\n\n* **command line**\n  - drop support for Go 1.11 and 1.12\n  - throw an error when no target is specified on Windows\n  - improve error messages in `getDefaultPort()`, support for multiple ports\n  - remove `-cflags` and `-ldflags` flags\n  - implement `-ldflags=\"-X ...\"`\n  - add `-print-allocs` flag that lets you print all heap allocations\n  - openocd commands in tinygo command line\n  - add `-llvm-features` parameter\n  - match `go test` output\n  - discover USB ports only, this will ignore f.ex. bluetooth\n  - use physicmal path instead of cached GOROOT in function getGoroot\n  - add goroot for snap installs\n* **compiler**\n  - `builder`: add support for `-opt=0`\n  - `builder`, `compiler`: compile and cache packages in parallel\n  - `builder`: run interp per package\n  - `builder`: cache C and assembly file outputs\n  - `builder`: add support for `-x` flag to print commands\n  - `builder`: add optsize attribute while building the package\n  - `builder`: run function passes per package\n  - `builder`: hard code Clang compiler\n  - `compiler`: do not use `llvm.GlobalContext()`\n  - `compiler`: remove SimpleDCE pass\n  - `compiler`: do not emit nil checks for `*ssa.Alloc` instructions\n  - `compiler`: merge `runtime.typecodeID` and runtime.typeInInterface\n  - `compiler`: do not check for impossible type asserts\n  - `compiler`: fix use of global context: `llvm.Int32Type()`\n  - `compiler`: add interface IR test\n  - `compiler`: fix lack of method name in interface matching\n  - `compiler`: fix \"fragment covers entire variable\" bug\n  - `compiler`: optimize string literals and globals\n  - `compiler`: decouple func lowering from interface type codes\n  - `compiler`: add function attributes to some runtime calls\n  - `compiler`: improve position information in error messages\n  - `cgo`: add support for CFLAGS in .c files\n  - `interp`: support GEP on fixed (MMIO) addresses\n  - `interp`: handle `(reflect.Type).Elem()`\n  - `interp`: add support for runtime.interfaceMethod\n  - `interp`: make toLLVMValue return an error instead of panicking\n  - `interp`: add support for switch statement\n  - `interp`: fix phi instruction\n  - `interp`: remove map support\n  - `interp`: support extractvalue/insertvalue with multiple operands\n  - `transform`: optimize string comparisons against \"\"\n  - `transform`: optimize `reflect.Type` `Implements()` method\n  - `transform`: fix bug in interface lowering when signatures are renamed\n  - `transform`: don't rely on struct name of `runtime.typecodeID`\n  - `transform`: use IPSCCP pass instead of the constant propagation pass\n  - `transform`: fix func lowering assertion failure\n  - `transform`: do not lower zero-sized alloc to alloca\n  - `transform`: split interface and reflect lowering\n* **standard library**\n  - `runtime`: add dummy debug package\n  - `machine`: fix data shift/mask in newUSBSetup\n  - `machine`: make `machine.I2C0` and similar objects pointers\n  - `machine`: unify usbcdc code\n  - `machine`: refactor PWM support\n  - `machine`: avoid heap allocations in USB code\n  - `reflect`: let `reflect.Type` be of interface type\n  - `reflect`: implement a number of stub functions\n  - `reflect`: check for access in the `Interface` method call\n  - `reflect`: fix `AssignableTo` and `Implements` methods\n  - `reflect`: implement `Value.CanAddr`\n  - `reflect`: implement `Sizeof` and `Alignof` for func values\n  - `reflect`: implement `New` function\n  - `runtime`: implement command line arguments in hosted environments\n  - `runtime`: implement environment variables for Linux\n  - `runtime`: improve timers on nrf, and samd chips\n* **targets**\n  - all: use -Qunused-arguments only for assembly files\n  - `atmega1280`: add PWM support\n  - `attiny`: remove dummy UART\n  - `atsamd21`: improve SPI\n  - `atsamd51`: fix PWM support in atsamd51p20\n  - `atsamd5x`: improve SPI\n  - `atsamd51`, `atsame5x`: unify samd51 and same5x\n  - `atsamd51`, `atsamd21`: fix `ADC.Get()` value at 8bit and 10bit\n  - `atsame5x`: add support for CAN\n  - `avr`: remove I2C stubs from attiny support\n  - `cortexm`: check for `arm-none-eabi-gdb` and `gdb-multiarch` commands\n  - `cortexm`: add `__isr_vector` symbol\n  - `cortexm`: disable FPU on Cortex-M4\n  - `cortexm`: clean up Cortex-M target files\n  - `fe310`: fix SPI read\n  - `gameboy-advance`: Fix RGBA color interpretation\n  - `nrf52833`: add PWM support\n  - `stm32l0`: use unified UART logic\n  - `stm32`: move f103 (bluepill) to common i2c code\n  - `stm32`: separate altfunc selection for UART Tx/Rx\n  - `stm32`: i2c implementation for F7, L5 and L4 MCUs\n  - `stm32`: make SPI CLK fast to fix data issue\n  - `stm32`: support SPI on L4 series\n  - `unix`: avoid possible heap allocation with `-opt=0`\n  - `unix`: use conservative GC by default\n  - `unix`: use the tasks scheduler instead of coroutines\n  - `wasi`: upgrade WASI version to wasi_snapshot_preview1\n  - `wasi`: darwin: support basic file io based on libc\n  - `wasm`: only export explicitly exported functions\n  - `wasm`: use WASI ABI for exit function\n  - `wasm`: scan globals conservatively\n* **boards**\n  - `arduino-mega1280`: add support for the Arduino Mega 1280\n  - `arduino-nano-new`: Add Arduino Nano w/ New Bootloader target\n  - `atsame54-xpro`: add initial support this board\n  - `feather-m4-can`: add initial support for this board\n  - `grandcentral-m4`: add board support for Adafruit Grand Central M4 (SAMD51)\n  - `lgt92`: update to new UART structure\n  - `microbit`: remove LED constant\n  - `microbit-v2`: add support for S113 SoftDevice\n  - `nucleol432`: add support for this board\n  - `nucleo-l031k6`: add this board\n  - `pca10059`: initial support for this board\n  - `qtpy`: fix msd-volume-name\n  - `qtpy`: fix i2c setting\n  - `teensy40`: move txBuffer allocation to UART declaration\n  - `teensy40`: add UART0 as alias for UART1\n\n\n0.17.0\n\n---\n* **command line**\n  - switch to LLVM 11 for static builds\n  - support gdb debugging with AVR\n  - add support for additional openocd commands\n  - add `-x` flag to print commands\n  - use LLVM 11 by default when linking LLVM dynamically\n  - update go-llvm to use LLVM 11 on macOS\n  - bump go.bug.st/serial to version 1.1.2\n  - do not build LLVM with libxml to work around a bugo on macOS\n  - add support for Go 1.16\n  - support gdb daemonization on Windows\n  - remove support for LLVM 9, to fix CI\n  - kill OpenOCD if it does not exit with a regular quit signal\n  - support `-ocd-output` on Windows\n* **compiler**\n  - `builder`: parallelize most of the build\n  - `builder`: remove unused cacheKey parameter\n  - `builder`: add -mcpu flag while building libraries\n  - `builder`: wait for running jobs to finish\n  - `cgo`: add support for variadic functions\n  - `compiler`: fix undefined behavior in wordpack\n  - `compiler`: fix incorrect \"exported function\" panic\n  - `compiler`: fix non-int integer constants (fixing a crash)\n  - `compiler`: refactor and add tests\n  - `compiler`: emit a nil check when slicing an array pointer\n  - `compiler`: saturate float-to-int conversions\n  - `compiler`: test float to int conversions and fix upper-bound calculation\n  - `compiler`: support all kinds of deferred builtins\n  - `compiler`: remove ir package\n  - `compiler`: remove unnecessary main.main call workaround\n  - `compiler`: move the setting of attributes to getFunction\n  - `compiler`: create runtime types lazily when needed\n  - `compiler`: move settings to a separate Config struct\n  - `compiler`: work around an ARM backend bug in LLVM\n  - `interp`: rewrite entire package\n  - `interp`: fix alignment of untyped globals\n  - `loader`: use name \"main\" for the main package\n  - `loader`: support imports from vendor directories\n  - `stacksize`: add support for DW_CFA_offset_extended\n  - `transform`: show better error message in coroutines lowering\n* **standard library**\n  - `machine`: accept configuration struct for ADC parameters\n  - `machine`: make I2C.Configure signature consistent\n  - `reflect`: implement PtrTo\n  - `runtime`: refactor to simplify stack switching\n  - `runtime`: put metadata at the top end of the heap\n* **targets**\n  - `atsam`: add a length check to findPinPadMapping\n  - `atsam`: improve USBCDC\n  - `atsam`: avoid infinite loop when USBCDC is disconnected\n  - `avr`: add SPI support for Atmega based chips\n  - `avr`: use Clang for compiling C and assembly files\n  - `esp32`: implement task based scheduler\n  - `esp32`: enable the FPU\n  - `esp8266`: implement task based scheduler\n  - `esp`: add compiler-rt library\n  - `esp`: add picolibc\n  - `nrf`: refactor code a bit to reduce duplication\n  - `nrf`: use SPIM peripheral instead of the legacy SPI peripheral\n  - `nrf`: update nrfx submodule to latest commit\n  - `nrf52840`: ensure that USB CDC interface is only initialized once\n  - `nrf52840`: improve USBCDC\n  - `stm32`: use stm32-rs SVDs which are of much higher quality\n  - `stm32`: harmonization of UART logic\n  - `stm32`: replace I2C addressable interface with simpler type\n  - `stm32`: fix i2c and add stm32f407 i2c\n  - `stm32`: revert change that adds support for channels in interrupts\n  - `wasm`: implement a growable heap\n  - `wasm`: fix typo in wasm_exec.js, syscall/js.valueLoadString()\n  - `wasm`: Namespaced Wasm Imports so they don't conflict across modules, or reserved LLVM IR\n  - `wasi`: support env variables based on libc\n  - `wasi`: specify wasi-libc in a different way, to improve error message\n* **boards**\n  - `matrixportal-m4`: add support for board Adafruit Matrix Portal M4\n  - `mkr1000`: add this board\n  - `nucleo-f722ze`: add this board\n  - `clue`: correct volume name and add alias for release version of Adafruit Clue board\n  - `p1am-100`: add support for the P1AM-100 (similar to Arduino MKR)\n  - `microbit-v2`: add initial support based on work done by @alankrantas thank you!\n  - `lgt92`: support for STM32L0 MCUs and Dragino LGT92 device\n  - `nicenano`: nice!nano board support\n  - `circuitplay-bluefruit`: correct internal I2C pin mapping\n  - `clue`: correct for lack of low frequency crystal\n  - `digispark`: split off attiny85 target\n  - `nucleo-l552ze`: implementation with CLOCK, LED, and UART\n  - `nrf52840-mdk-usb-dongle`: add this board\n\n0.16.0\n---\n\n* **command-line**\n  - add initial support for LLVM 11\n  - make lib64 clang include path check more robust\n  - `build`: improve support for GOARCH=386 and add tests\n  - `gdb`: add support for qemu-user targets\n  - `test`: support non-host tests\n  - `test`: add support for -c and -o flags\n  - `test`: implement some benchmark stubs\n* **compiler**\n  - `builder`: improve detection of clang on Fedora\n  - `compiler`: fix floating point comparison bugs\n  - `compiler`: implement negate for complex numbers\n  - `loader`: fix linkname in test binaries\n  - `transform`: add missing return pointer restore for regular coroutine tail\n    calls\n* **standard library**\n  - `machine`: switch default frequency to 4MHz\n  - `machine`: clarify caller's responsibility in `SetInterrupt`\n  - `os`: add `LookupEnv()` stub\n  - `reflect`: implement `Swapper`\n  - `runtime`: fix UTF-8 decoding\n  - `runtime`: gc: use raw stack access whenever possible\n  - `runtime`: use dedicated printfloat32\n  - `runtime`: allow ranging over a nil map\n  - `runtime`: avoid device/nxp dependency in HardFault handler\n  - `testing`: implement dummy Helper method\n  - `testing`: add Run method\n* **targets**\n  - `arm64`: add support for SVCall intrinsic\n  - `atsamd51`: avoid panic when configuring SPI with SDI=NoPin\n  - `avr`: properly support the `.rodata` section\n  - `esp8266`: implement `Pin.Get` function\n  - `nintendoswitch`: fix crash when printing long lines (> 120)\n  - `nintendoswitch`: add env parser and removed unused stuff\n  - `nrf`: add I2C error checking\n  - `nrf`: give more flexibility in picking SPI speeds\n  - `nrf`: fix nrf52832 flash size\n  - `stm32f103`: support wakeups from interrupts\n  - `stm32f405`: add SPI support\n  - `stm32f405`: add I2C support\n  - `wasi`: add support for this target\n  - `wasi`: use 'generic' ABI by default\n  - `wasi`: remove --no-threads flag from wasm-ld\n  - `wasm`: add instanceof support for WebAssembly\n  - `wasm`: use fixed length buffer for putchar\n* **boards**\n  - `d1mini`: add this ESP8266 based board\n  - `esp32`: use board definitions instead of chip names\n  - `qtpy`: add board definition for Adafruit QTPy\n  - `teensy40`: add this board\n\n0.15.0\n---\n\n* **command-line**\n  - add cached GOROOT to info subcommand\n  - embed git-hash in tinygo-dev executable\n  - implement tinygo targets to list usable targets\n  - use simpler file copy instead of file renaming to avoid issues on nrf52840 UF2 bootloaders\n  - use ToSlash() to specify program path\n  - support flashing esp32/esp8266 directly from tinygo\n  - when flashing call PortReset only on other than openocd\n* **compiler**\n  - `compileopts`: add support for custom binary formats\n  - `compiler`: improve display of goroutine wrappers\n  - `interp`: don't panic in the Store method\n  - `interp`: replace some panics with error messages\n  - `interp`: show error line in first line of the traceback\n  - `loader`: be more robust when creating the cached GOROOT\n  - `loader`: rewrite/refactor much of the code to use go list directly\n  - `loader`: use ioutil.TempDir to create a temporary directory\n  - `stacksize`: deal with DW_CFA_advance_loc1\n* **standard library**\n  - `runtime`: use waitForEvents when appropriate\n* **wasm**\n  - `wasm`: Remove --no-threads from wasm-ld calls.\n  - `wasm`: update wasi-libc dependency\n* **targets**\n  - `arduino-mega2560`: fix flashing on Windows\n  - `arm`: automatically determine stack sizes\n  - `arm64`: make dynamic loader structs and constants private\n  - `avr`: configure emulator in board files\n  - `cortexm`: fix stack size calculation with interrupts\n  - `flash`: add openocd settings to atsamd21 / atsamd51\n  - `flash`: add openocd settings to nrf5\n  - `microbit`: reelboard: flash using OpenOCD when needed\n  - `nintendoswitch`: Add dynamic loader for runtime loading PIE sections\n  - `nintendoswitch`: fix import cycle on dynamic_arm64.go\n  - `nintendoswitch`: Fix invalid memory read / write in print calls\n  - `nintendoswitch`: simplified assembly code\n  - `nintendoswitch`: support outputting .nro files directly\n* **boards**\n  - `arduino-zero`: Adding support for the Arduino Zero (#1365)\n  - `atsamd2x`: fix BAUD value\n  - `atsamd5x`: fix BAUD value\n  - `bluepill`: Enable stm32's USART2 for the board and map it to UART1 tinygo's device\n  - `device/atsamd51x`: add all remaining bitfield values for PCHCTRLm Mapping\n  - `esp32`: add libgcc ROM functions to linker script\n  - `esp32`: add SPI support\n  - `esp32`: add support for basic GPIO\n  - `esp32`: add support for the Espressif ESP32 chip\n  - `esp32`: configure the I/O matrix for GPIO pins\n  - `esp32`: export machine.PortMask* for bitbanging implementations\n  - `esp8266`: add support for this chip\n  - `machine/atsamd51x,runtime/atsamd51x`: fixes needed for full support for all PWM pins. Also adds some useful constants to clarify peripheral clock usage\n  - `machine/itsybitsy-nrf52840`: add support for Adafruit Itsybitsy nrf52840 (#1243)\n  - `machine/stm32f4`: refactor common code and add new build tag stm32f4 (#1332)\n  - `nrf`: add SoftDevice support for the Circuit Playground Bluefruit\n  - `nrf`: call sd_app_evt_wait when the SoftDevice is enabled\n  - `nrf52840`: add build tags for SoftDevice support\n  - `nrf52840`: use higher priority for USB-CDC code\n  - `runtime/atsamd51x`: use PCHCTRL_GCLK_SERCOMX_SLOW for setting clocks on all SERCOM ports\n  - `stm32f405`: add basic UART handler\n  - `stm32f405`: add STM32F405 machine/runtime, and new board/target feather-stm32f405\n* **build**\n  - `all`: run test binaries in the correct directory\n  - `build`: Fix arch release job\n  - `ci`: run `tinygo test` for known-working packages\n  - `ci`: set git-fetch-depth to 1\n  - `docker`: fix the problem with the wasm build (#1357)\n  - `Makefile`: check whether submodules have been downloaded in some common cases\n* **docs**\n  - add ESP32, ESP8266, and Adafruit Feather STM32F405 to list of supported boards\n\n0.14.1\n---\n* **command-line**\n  - support for Go 1.15\n* **compiler**\n  - loader:  work around Windows symlink limitation\n\n0.14.0\n---\n* **command-line**\n  - fix `getDefaultPort()` on non-English Windows locales\n  - compileopts: improve error reporting of unsupported flags\n  - fix test subcommand\n  - use auto-retry to locate MSD for UF2 and HEX flashing\n  - fix touchSerialPortAt1200bps on Windows\n  - support package names with backslashes on Windows\n* **compiler**\n  - fix a few crashes due to named types\n  - add support for atomic operations\n  - move the channel blocked list onto the stack\n  - fix -gc=none\n  - fix named string to `[]byte` slice conversion\n  - implement func value and builtin defers\n  - add proper parameter names to runtime.initAll, to fix a panic\n  - builder: fix picolibc include path\n  - builder: use newer version of gohex\n  - builder: try to determine stack size information at compile time\n  - builder: remove -opt=0\n  - interp: fix sync/atomic.Value load/store methods\n  - loader: add Go module support\n  - transform: fix debug information in func lowering pass\n  - transform: do not special-case zero or one implementations of a method call\n  - transform: introduce check for method calls on nil interfaces\n  - transform: gc: track 0-index GEPs to fix miscompilation\n* **cgo**\n  - Add LDFlags support\n* **standard library**\n  - extend stdlib to allow import of more packages\n  - replace master/slave terminology with appropriate alternatives (MOSI->SDO\n    etc)\n  - `internal/bytealg`: reimplement bytealg in pure Go\n  - `internal/task`: fix nil panic in (*internal/task.Stack).Pop\n  - `os`: add Args and stub it with mock data\n  - `os`: implement virtual filesystem support\n  - `reflect`: add Cap and Len support for map and chan\n  - `runtime`: fix return address in scheduler on RISC-V\n  - `runtime`: avoid recursion in printuint64 function\n  - `runtime`: replace ReadRegister with AsmFull inline assembly\n  - `runtime`: fix compilation errors when using gc.extalloc\n  - `runtime`: add cap and len support for chans\n  - `runtime`: refactor time handling (improving accuracy)\n  - `runtime`: make channels work in interrupts\n  - `runtime/interrupt`: add cross-chip disable/restore interrupt support\n  - `sync`: implement `sync.Cond`\n  - `sync`: add WaitGroup\n* **targets**\n  - `arm`: allow nesting in DisableInterrupts and EnableInterrupts\n  - `arm`: make FPU configuration consistent\n  - `arm`: do not mask fault handlers in critical sections\n  - `atmega2560`: fix pin mapping for pins D2, D5 and the L port\n  - `atsamd`: return an error when an incorrect PWM pin is used\n  - `atsamd`: add support for pin change interrupts\n  - `atsamd`: add DAC support\n  - `atsamd21`: add more ADC pins\n  - `atsamd51`: fix ROM / RAM size on atsamd51j20\n  - `atsamd51`: add more pins\n  - `atsamd51`: add more ADC pins\n  - `atsamd51`: add pin change interrupt settings\n  - `atsamd51`: extend pinPadMapping\n  - `arduino-nano33`: use (U)SB flag to ensure that device can be found when\n     not on default port\n  - `arduino-nano33`: remove (d)ebug flag to reduce console noise when flashing\n  - `avr`: use standard pin numbering\n  - `avr`: unify GPIO pin/port code\n  - `avr`: add support for PinInputPullup\n  - `avr`: work around codegen bug in LLVM 10\n  - `avr`: fix target triple\n  - `fe310`: remove extra println left in by mistake\n  - `feather-nrf52840`: add support for the Feather nRF52840\n  - `maixbit`: add board definition and dummy runtime\n  - `nintendoswitch`: Add experimental Nintendo Switch support without CRT\n  - `nrf`: expose the RAM base address\n  - `nrf`: add support for pin change interrupts\n  - `nrf`: add microbit-s110v8 target\n  - `nrf`: fix bug in SPI.Tx\n  - `nrf`: support debugging the PCA10056\n  - `pygamer`: add Adafruit PyGamer support\n  - `riscv`: fix interrupt configuration bug\n  - `riscv`: disable linker relaxations during gp init\n  - `stm32f4disco`: add new target with ST-Link v2.1 debugger\n  - `teensy36`: add Teensy 3.6 support\n  - `wasm`: fix event handling\n  - `wasm`: add --no-demangle linker option\n  - `wioterminal`: add support for the Seeed Wio Terminal\n  - `xiao`: add support for the Seeed XIAO\n\n0.13.1\n---\n* **standard library**\n  - `runtime`: do not put scheduler and GC code in the same section\n  - `runtime`: copy stack scan assembly for GBA\n* **boards**\n  - `gameboy-advance`: always use ARM mode instead of Thumb mode\n\n\n0.13.0\n---\n* **command line**\n  - use `gdb-multiarch` for debugging Cortex-M chips\n  - support `tinygo run` with simavr\n  - support LLVM 10\n  - support Go 1.14\n  - retry 3 times when attempting to do a 1200-baud reset\n* **compiler**\n  - mark the `abort` function as noreturn\n  - fix deferred calls to exported functions\n  - add debug info for local variables\n  - check for channel size limit\n  - refactor coroutine lowering\n  - add `dereferenceable_or_null` attribute to pointer parameters\n  - do not perform nil checking when indexing slices and on `unsafe.Pointer`\n  - remove `runtime.isnil` hack\n  - use LLVM builtins for runtime `memcpy`/`memmove`/`memzero` functions\n  - implement spec-compliant shifts on negative/overflow\n  - support anonymous type asserts\n  - track pointer result of string concatenation for GC\n  - track PHI nodes for GC\n  - add debug info to goroutine start wrappers\n  - optimize comparing interface values against nil\n  - fix miscompilation when deferring an interface call\n  - builder: include picolibc for most baremetal targets\n  - builder: run tools (clang, lld) as separate processes\n  - builder: use `-fshort-enums` consistently\n  - interp: add support for constant type asserts\n  - interp: better support for interface operations\n  - interp: include backtrace with error\n  - transform: do not track const globals for GC\n  - transform: replace panics with source locations\n  - transform: fix error in interface lowering pass\n  - transform: make coroutine lowering deterministic\n  - transform: fix miscompilation in func lowering\n* **cgo**\n  - make `-I` and `-L` paths absolute\n* **standard library**\n  - `machine`: set the USB VID and PID to the manufacturer values\n  - `machine`: correct USB CDC composite descriptors\n  - `machine`: move `errors.New` calls to globals\n  - `runtime`: support operations on nil maps\n  - `runtime`: fix copy builtin return value on AVR\n  - `runtime`: refactor goroutines\n  - `runtime`: support `-scheduler=none` on most platforms\n  - `runtime`: run package initialization in the main goroutine\n  - `runtime`: export `malloc` / `free` for use from C\n  - `runtime`: add garbage collector that uses an external allocator\n  - `runtime`: scan callee-saved registers while marking the stack\n  - `runtime`: remove recursion from conservative GC\n  - `runtime`: fix blocking select on nil channel\n  - `runtime/volatile`: include `ReplaceBits` method\n  - `sync`: implement trivial `sync.Map`\n* **targets**\n  - `arm`: use `-fomit-frame-pointer`\n  - `atmega1284`: support this chip for testing purposes\n  - `atsamd51`: make QSPI available on all boards\n  - `atsamd51`: add support for ADC1\n  - `atsamd51`: use new interrupt registration in UART code\n  - `attiny`: clean up pin definitions\n  - `avr`: use the correct RAM start address\n  - `avr`: pass the correct `-mmcu` flag to the linker\n  - `avr`: add support for tasks scheduler (disabled by default)\n  - `avr`: fix linker problem with overlapping program/data areas\n  - `nrf`: fix typo in pin configuration options\n  - `nrf`: add lib/nrfx/mdk to include dirs\n  - `nrf52840`: implement USB-CDC\n  - `riscv`: implement VirtIO target and add RISC-V integration test\n  - `riscv`: add I2C support for the HiFive1 rev B board\n  - `stm32`: refactor GPIO pin handling\n  - `stm32`: refactor UART code\n  - `stm32f4`: add SPI\n  - `wasm`: support Go 1.14 (breaking previous versions)\n  - `wasm`: support `syscall/js.CopyBytesToJS`\n  - `wasm`: sync polyfills from Go 1.14.\n* **boards**\n  - `arduino-mega2560`: add the Arduino Mega 2560\n  - `clue-alpha`: add the Adafruit CLUE Alpha\n  - `gameboy-advance`: enable debugging with GDB\n  - `particle-argon`: add the Particle Argon board\n  - `particle-boron`: add the Particle Boron board\n  - `particle-xenon`: add the Particle Xenon board\n  - `reelboard`: add `reelboard-s140v7` SoftDevice target\n\n0.12.0\n---\n* **command line**\n  - add initial FreeBSD support\n  - remove getting a serial port in gdb subcommand\n  - add support for debugging through JLinkGDBServer\n  - fix CGo when cross compiling\n  - remove default port check for Digispark as micronucleus communicates directly using HID\n  - differentiate between various serial/USB error messages\n* **builder**\n  - improve detection of Clang headers\n* **compiler**\n  - fix assertion on empty interface\n  - don't crash when encountering `types.Invalid`\n  - revise defer to use heap allocations when running a variable number of times\n  - improve error messages for failed imports\n  - improve \"function redeclared\" error\n  - add globaldce pass to start of optimization pipeline\n  - add support for debugging globals\n  - implement RISC-V CSR operations as intrinsics\n  - add support for CGO_ENABLED environment variable\n  - do not emit debug info for extern globals (bugfix)\n  - add support for interrupts\n  - implement maps for arbitrary keys\n  - interp: error location for \"unknown GEP\" error\n  - wasm-abi: create temporary allocas in the entry block\n* **cgo**\n  - add support for symbols in `#define`\n  - fix a bug in number tokenization\n* **standard library**\n  - `machine`: avoid bytes package in USB logic\n  - `runtime`: fix external address declarations\n  - `runtime`: provide implementation for `internal/bytealg.IndexByte`\n* **targets**\n  - `atsamd51`: fix volatile usage\n  - `atsamd51`: fix ADC, updating to 12-bits precision\n  - `atsamd51`: refactor SPI pin configuration to only look at pin numbers\n  - `atsamd51`: switch UART to use new pin configuration\n  - `atsamd51`: fix obvious bug in I2C code\n  - `atsamd51`: use only the necessary UART interrupts\n  - `atsamd51`: refactor I2C pin handling to auto-detect pin mode\n  - `avr`: use a garbage collector\n  - `fe310`: use CLINT peripheral for timekeeping\n  - `fe310`: add support for PLIC interrupts\n  - `fe310`: implement UART receive interrupts\n  - `riscv`: support sleeping in QEMU\n  - `riscv`: add bare-bones interrupt support\n  - `riscv`: print exception PC and code\n  - `wasm`: implement memcpy and memset\n  - `wasm`: include wasi-libc\n  - `wasm`: use wasi ABI for basic startup/stdout\n* **boards**\n  - `arduino`: make avrdude command line compatible with Windows\n  - `arduino-nano`: add this board\n  - `arduino-nano33`: fix UART1 and UART2\n  - `circuitplay-bluefruit`: add this board\n  - `digispark`: add clock speed and pin mappings\n  - `gameboy-advance`: include compiler-rt in build\n  - `gameboy-advance`: implement interrupt handler\n  - `hifive1b`: add support for gdb subcommand\n  - `pyportal`: add this board\n  - `pyportal`: remove manual SPI pin mapping as now handled by default\n\n\n0.11.0\n---\n* **command line**\n  - add support for QEMU in `gdb` subcommand\n  - use builtin Clang when building statically, dropping the clang-9 dependency\n  - search for default serial port on both macOS and Linux\n  - windows: support `tinygo flash` directly by using win32 wmi\n* **compiler**\n  - add location information to the IR checker\n  - make reflection sidetables constant globals\n  - improve error locations in goroutine lowering\n  - interp: improve support for maps with string keys\n  - interp: add runtime fallback for mapassign operations\n* **standard library**\n  - `machine`: add support for `SPI.Tx()` on play.tinygo.org\n  - `machine`: rename `CPU_FREQUENCY` to `CPUFrequency()`\n* **targets**\n  - `adafruit-pybadge`: add Adafruit Pybadge\n  - `arduino-nano33`: allow simulation on play.tinygo.org\n  - `arduino-nano33`: fix default SPI pin numbers to be D13/D11/D12\n  - `circuitplay-express`: allow simulation on play.tinygo.org\n  - `hifive1-qemu`: add target for testing RISC-V bare metal in QEMU\n  - `riscv`: fix heap corruption due to changes in LLVM 9\n  - `riscv`: add support for compiler-rt\n  - `qemu`: rename to `cortex-m-qemu`\n\n0.10.0\n---\n* **command line**\n  - halt GDB after flashing with `gdb` subcommand\n  - fix a crash when using `-ocd-output`\n  - add `info` subcommand\n  - add `-programmer` flag\n* **builder**\n  - macos: use llvm@8 instead of just llvm in paths\n  - add `linkerscript` key to target JSON files\n  - write a symbol table when writing out the compiler-rt lib\n  - make Clang header detection more robust\n  - switch to LLVM 9\n* **compiler**\n  - fix interface miscompilation with reflect\n  - fix miscompile of static goroutine calls to closures\n  - fix `todo: store` panic\n  - fix incorrect starting value for optimized allocations in a loop\n  - optimize coroutines on non-Cortex-M targets\n  - fix crash for programs which have heap allocations but never hit the GC\n  - add support for async interface calls\n  - fix inserting non-const values in a const global\n  - interp: improve error reporting\n  - interp: implement comparing ptrtoint to 0\n* **cgo**\n  - improve diagnostics\n  - implement the constant parser (for `#define`) as a real parser\n  - rename reserved field names such as `type`\n  - avoid `\"unsafe\" imported but not used` error\n  - include all enums in the CGo Go AST\n  - add support for nested structs and unions\n  - implement `#cgo CFLAGS`\n* **standard library**\n  - `reflect`: add implementation of array alignment\n  - `runtime`: improve scheduler performance when no goroutines are queued\n  - `runtime`: add blocking select\n  - `runtime`: implement interface equality in non-trivial cases\n  - `runtime`: add AdjustTimeOffset to update current time\n  - `runtime`: only implement CountString for required platforms\n  - `runtime`: use MSP/PSP registers for scheduling on Cortex-M\n* **targets**\n  - `arm`: add system timer registers\n  - `atmega`: add port C GPIO support\n  - `atsamd21`: correct handling of pins >= 32\n  - `atsamd21`: i2s initialization fixes\n  - `atsamd51`: fix clock init code\n  - `atsamd51`: correct initialization for RTC\n  - `atsamd51`: fix pin function selection\n  - `atsamd51`: pin method cleanup\n  - `atsamd51`: allow setting pin mode for each of the SPI pins\n  - `atsamd51`: correct channel init and pin map for ADC based on ItsyBitsy-M4\n  - `feather-m4`: add Adafruit Feather M4 board\n  - `hifive1b`: add support for SPI1\n  - `hifive1b`: fix compiling in simulation\n  - `linux`: fix time on arm32\n  - `metro-m4`: add support for Adafruit Metro M4 Express Airlift board\n  - `metro-m4`: fixes for UART2\n  - `pinetime-devkit0`: add support for the PineTime dev kit\n  - `x9pro`: add support for this smartwatch\n  - `pca10040-s132v6`: add support for SoftDevice\n  - `pca10056-s140v7`: add support for SoftDevice\n  - `arduino-nano33`: added SPI1 connected to NINA-W102 chip on Arduino Nano 33 IOT\n\n0.9.0\n---\n* **command line**\n  - implement 1200-baud UART bootloader reset when flashing boards that support\n    it\n  - flash using mass-storage device for boards that support it\n  - implement `tinygo env`\n  - add support for Windows (but not yet producing Windows binaries)\n  - add Go version to `tinygo env`\n  - update SVD files for up-to-date peripheral interfaces\n* **compiler**\n  - add `//go:align` pragma\n  - fix bug related to type aliases\n  - add support for buffered channels\n  - remove incorrect reflect optimization\n  - implement copying slices in init interpretation\n  - add support for constant indices with a named type\n  - add support for recursive types like linked lists\n  - fix miscompile of function nil panics\n  - fix bug related to goroutines\n* **standard library**\n  - `machine`: do not check for nil slices in `SPI.Tx`\n  - `reflectlite`: add support for Go 1.13\n  - `runtime`: implement `internal/bytealg.CountString`\n  - `sync`: properly handle nil `New` func in `sync.Pool`\n* **targets**\n  - `arduino`: fix .bss section initialization\n  - `fe310`: implement `Pin.Get`\n  - `gameboy-advance`: support directly outputting .gba files\n  - `samd`: reduce code size by avoiding reflection\n  - `samd21`: do not hardcode pin numbers for peripherals\n  - `stm32f103`: avoid issue with `time.Sleep` less than 200µs\n\n0.8.0\n---\n* **command line**\n  - fix parsing of beta Go versions\n  - check the major/minor installed version of Go before compiling\n  - validate `-target` flag better to not panic on an invalid target\n* **compiler**\n  - implement full slice expression: `s[:2:4]`\n  - fix a crash when storing a linked list in an interface\n  - fix comparing struct types by making type IDs more unique\n  - fix some bugs in IR generation\n  - add support for linked lists in reflect data\n  - implement `[]rune` to string conversion\n  - implement support for `go` on func values\n* **standard library**\n  - `reflect`: add support for named types\n  - `reflect`: add support for `t.Bits()`\n  - `reflect`: add basic support for `t.AssignableTo()`\n  - `reflect`: implement `t.Align()`\n  - `reflect`: add support for struct types\n  - `reflect`: fix bug in `v.IsNil` and `v.Pointer` for addressable values\n  - `reflect`: implement support for array types\n  - `reflect`: implement `t.Comparable()`\n  - `runtime`: implement stack-based scheduler\n  - `runtime`: fix bug in the sleep queue of the scheduler\n  - `runtime`: implement `memcpy` for Cortex-M\n  - `testing`: implement stub `testing.B` struct\n  - `testing`: add common test logging methods such as Errorf/Fatalf/Printf\n* **targets**\n  - `386`: add support for linux/386 syscalls\n  - `atsamd21`: make SPI pins configurable so that multiple SPI ports can be\n    used\n  - `atsamd21`: correct issue with invalid first reading coming from ADC\n  - `atsamd21`: add support for reset-to-bootloader using 1200baud over USB-CDC\n  - `atsamd21`: make pin selection more flexible for peripherals\n  - `atsamd21`: fix minimum delay in `time.Sleep`\n  - `atsamd51`: fix minimum delay in `time.Sleep`\n  - `nrf`: improve SPI write-only speed, by making use of double buffering\n  - `stm32f103`: fix SPI frequency selection\n  - `stm32f103`: add machine.Pin.Get method for reading GPIO values\n  - `stm32f103`: allow board specific UART usage\n  - `nucleo-f103rb`: add support for NUCLEO-F103RB board\n  - `itsybitsy-m4`: add support for this board with a SAMD51 family chip\n  - `cortex-m`: add support for `arm.SystemReset()`\n  - `gameboy-advance`: add initial support for the GameBoy Advance\n  - `wasm`: add `//go:wasm-module` magic comment to set the wasm module name\n  - `wasm`: add syscall/js.valueSetIndex support\n  - `wasm`: add syscall/js.valueInvoke support\n\n0.7.1\n---\n* **targets**\n  - `atsamd21`: add support for the `-port` flag in the flash subcommand\n\n0.7.0\n---\n* **command line**\n  - try more locations to find Clang built-in headers\n  - add support for `tinygo test`\n  - build current directory if no package is specified\n  - support custom .json target spec with `-target` flag\n  - use zversion.go to detect version of GOROOT version\n  - make initial heap size configurable for some targets (currently WebAssembly\n    only)\n* **cgo**\n  - add support for bitfields using generated getters and setters\n  - add support for anonymous structs\n* **compiler**\n  - show an error instead of panicking on duplicate function definitions\n  - allow packages like github.com/tinygo-org/tinygo/src/\\* by aliasing it\n  - remove `//go:volatile` support  \n    It has been replaced with the runtime/volatile package.\n  - allow pointers in map keys\n  - support non-constant syscall numbers\n  - implement non-blocking selects\n  - add support for the `-tags` flag\n  - add support for `string` to `[]rune` conversion\n  - implement a portable conservative garbage collector (with support for wasm)\n  - add the `//go:noinline` pragma\n* **standard library**\n  - `os`: add `os.Exit` and `syscall.Exit`\n  - `os`: add several stubs\n  - `runtime`: fix heap corruption in conservative GC\n  - `runtime`: add support for math intrinsics where supported, massively\n    speeding up some benchmarks\n  - `testing`: add basic support for testing\n* **targets**\n  - add support for a generic target that calls `__tinygo_*` functions for\n    peripheral access\n  - `arduino-nano33`: add support for this board\n  - `hifive1`: add support for this RISC-V board\n  - `reelboard`: add e-paper pins\n  - `reelboard`: add `PowerSupplyActive` to enable voltage for on-board devices\n  - `wasm`: put the stack at the start of linear memory, to detect stack\n    overflows\n\n0.6.0\n---\n* **command line**\n  - some portability improvements\n  - make `$GOROOT` more robust and configurable\n  - check for Clang at the Homebrew install location as fallback\n* **compiler driver**\n  - support multiple variations of LLVM commands, for non-Debian distributions\n* **compiler**\n  - improve code quality in multiple ways\n  - make panic configurable, adding trap on panic\n  - refactor many internal parts of the compiler\n  - print all errors encountered during compilation\n  - implement calling function values of a named type\n  - implement returning values from blocking functions\n  - allow larger-than-int values to be sent across a channel\n  - implement complex arithmetic\n  - improve hashmap support\n  - add debuginfo for function arguments\n  - insert nil checks on stores (increasing code size)\n  - implement volatile operations as compiler builtins\n  - add `//go:inline` pragma\n  - add build tags for the Go stdlib version\n* **cgo**\n  - implement `char`, `enum` and `void*` types\n  - support `#include` for builtin headers\n  - improve typedef/struct/enum support\n  - only include symbols that are necessary, for broader support\n  - mark external function args as `nocapture`\n  - implement support for some `#define` constants\n  - implement support for multiple CGo files in a single package\n- **standard library**\n  - `machine`: remove microbit matrix (moved to drivers repository)\n  - `machine`: refactor pins to use `Pin` type instead of `GPIO`\n  - `runtime`: print more interface types on panic, including `error`\n* **targets**\n  - `arm`: print an error on HardFault (including stack overflows)\n  - `atsamd21`: fix a bug in the ADC peripheral\n  - `atsamd21`: add support for I2S\n  - `feather-m0`: add support for this board\n  - `nrf51`: fix a bug in I2C\n  - `stm32f103xx`: fix a bug in I2C\n  - `syscall`: implement `Exit` on unix\n  - `trinket-m0`: add support for this board\n  - `wasm`: make _main_ example smaller\n  - `wasm`: don't cache wasm file in the server, for ease of debugging\n  - `wasm`: work around bug #41508 that caused a deadlock while linking\n  - `wasm`: add support for `js.FuncOf`\n\n0.5.0\n---\n- **compiler driver**\n  - use `wasm-ld` instead of `wasm-ld-8` on macOS\n  - drop dependency on `llvm-ar`\n  - fix linker script includes when running outside `TINYGOROOT`\n- **compiler**\n  - switch to LLVM 8\n  - add support for the Go 1.12 standard library (Go 1.11 is still supported)\n  - work around lack of escape analysis due to nil checks\n  - implement casting named structs and pointers to them\n  - fix int casting to use the source signedness\n  - fix some bugs around `make([]T, …)` with uncommon index types\n  - some other optimizations\n  - support interface asserts in interp for \"math/rand\" support\n  - resolve all func value targets at compile time (wasm-only at the moment)\n- **cgo**\n  - improve diagnostics\n  - implement C `struct`, `union`, and arrays\n  - fix CGo-related crash in libclang\n  - implement `C.struct_` types\n- **targets**\n  - all baremetal: pretend to be linux/arm instead of js/wasm\n  - `avr`: improve `uintptr` support\n  - `cortexm`: implement memmove intrinsic generated by LLVM\n  - `cortexm`: use the lld linker instead of `arm-none-eabi-ld`\n  - `darwin`: use custom syscall package that links to libSystem.dylib\n  - `microbit`: add blink example\n  - `samd21`: support I2C1\n  - `samd21`: machine/atsamd21: correct pad/pin handling when using both UART\n     and USBCDC interfaces at same time\n  - `stm32f4discovery`: add support for this board\n  - `wasm`: support async func values\n  - `wasm`: improve documentation and add extra example\n\n0.4.1\n---\n- **compiler**\n  - fix `objcopy` replacement to include the .data section in the firmware image\n  - use `llvm-ar-7` on Linux to fix the Docker image\n\n0.4.0\n---\n- **compiler**\n  - switch to the hardfloat ABI on ARM, which is more widely used\n  - avoid a dependency on `objcopy` (`arm-none-eabi-objcopy` etc.)\n  - fix a bug in `make([]T, n)` where `n` is 64-bits on a 32-bit platform\n  - adapt to a change in the AVR backend in LLVM 8\n  - directly support the .uf2 firmware format as used on Adafruit boards\n  - fix a bug when calling `panic()` at init time outside of the main package\n  - implement nil checks, which results in a ~5% increase in code size\n  - inline slice bounds checking, which results in a ~1% decrease in code size\n- **targets**\n  - `samd21`: fix a bug in port B pins\n  - `samd21`: implement SPI peripheral\n  - `samd21`: implement ADC peripheral\n  - `stm32`: fix a bug in timekeeping\n  - `wasm`: fix a bug in `wasm_exec.js` that caused corruption in linear memory\n     when running on Node.js.\n\n0.3.0\n---\n- **compiler**\n  - remove old `-initinterp` flag\n  - add support for macOS\n- **cgo**\n  - add support for bool/float/complex types\n- **standard library**\n  - `device/arm`: add support to disable/enable hardware interrupts\n  - `machine`: add CPU frequency for nrf-based boards\n  - `syscall`: add support for darwin/amd64\n- **targets**\n  - `circuitplay_express`: add support for this board\n  - `microbit`: add regular pin constants\n  - `samd21`: fix time function for goroutine support\n  - `samd21`: add support for USB-CDC (serial over USB)\n  - `samd21`: add support for pins in port B\n  - `samd21`: add support for pullup and pulldown pins\n  - `wasm`: add support for Safari in example\n\n\n0.2.0\n---\n- **command line**\n  - add version subcommand\n- **compiler**\n  - fix a bug in floating point comparisons with NaN values\n  - fix a bug when calling `panic` in package initialization code\n  - add support for comparing `complex64` and `complex128`\n- **cgo**\n  - add support for external globals\n  - add support for pointers and function pointers\n- **standard library**\n  - `fmt`: initial support, `fmt.Println` works\n  - `math`: support for most/all functions\n  - `os`: initial support (only stdin/stdout/stderr)\n  - `reflect`: initial support\n  - `syscall`: add support for amd64, arm, and arm64\n"
        },
        {
          "name": "CODE-OF-CONDUCT.md",
          "type": "blob",
          "size": 3.31640625,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to make participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, sex characteristics, gender identity and expression,\nlevel of experience, education, socio-economic status, nationality, personal\nappearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies within all project spaces, and it also applies when\nan individual is representing the project or its community in public spaces.\nExamples of representing a project or community include using an official\nproject e-mail address, posting via an official social media account, or acting\nas an appointed representative at an online or offline event. Representation of\na project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at [conduct@tinygo.org](mailto:conduct@tinygo.org). All\ncomplaints will be reviewed and investigated and will result in a response that\nis deemed necessary and appropriate to the circumstances. The project team is\nobligated to maintain confidentiality with regard to the reporter of an incident.\nFurther details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,\navailable at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see\nhttps://www.contributor-covenant.org/faq\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.12890625,
          "content": "Please take a look at our [Contributing](https://tinygo.org/docs/guides/contributing/) page on our web site for details. Thank you.\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.583984375,
          "content": "# This is the official list of TinyGo authors for copyright purposes.\n#\n# This file is not actively maintained.\n# To be included, send a change adding the individual or\n# company who owns a contribution's copyright.\n#\n# Names should be added to this file as one of\n#     Organization's name\n#     Individual's name <submission email address>\n#     Individual's name <submission email address> <email2> <emailN>\n#\n# Please keep the list sorted.\n\nAyke van Laethem <aykevanlaethem@gmail.com>\nDaniel Esteban <conejo@conejo.me>\nLoon, LLC.\nRon Evans <ron@hybridgroup.com>\nNia Weiss <niaow1234@gmail.com>\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.06640625,
          "content": "# tinygo-llvm stage obtains the llvm source for TinyGo\nFROM golang:1.23 AS tinygo-llvm\n\nRUN apt-get update && \\\n    apt-get install -y apt-utils make cmake clang-15 ninja-build && \\\n    rm -rf \\\n        /var/lib/apt/lists/* \\\n        /var/log/* \\\n        /var/tmp/* \\\n        /tmp/*\n\nCOPY ./GNUmakefile /tinygo/GNUmakefile\n\nRUN cd /tinygo/ && \\\n    make llvm-source\n\n# tinygo-llvm-build stage build the custom llvm with xtensa support\nFROM tinygo-llvm AS tinygo-llvm-build\n\nRUN cd /tinygo/ && \\\n    make llvm-build\n\n# tinygo-compiler-build stage builds the compiler itself\nFROM tinygo-llvm-build AS tinygo-compiler-build\n\nCOPY . /tinygo\n\n# build the compiler and tools\nRUN cd /tinygo/ && \\\n    git submodule update --init && \\\n    make gen-device -j4 && \\\n    make build/release\n\n# tinygo-compiler copies the compiler build over to a base Go container (without\n# all the build tools etc).\nFROM golang:1.23 AS tinygo-compiler\n\n# Copy tinygo build.\nCOPY --from=tinygo-compiler-build /tinygo/build/release/tinygo /tinygo\n\n# Configure the container.\nENV PATH=\"${PATH}:/tinygo/bin\"\nCMD [\"tinygo\"]\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 49.4501953125,
          "content": "\n# aliases\nall: tinygo\n\n# Default build and source directories, as created by `make llvm-build`.\nLLVM_BUILDDIR ?= llvm-build\nLLVM_PROJECTDIR ?= llvm-project\nCLANG_SRC ?= $(LLVM_PROJECTDIR)/clang\nLLD_SRC ?= $(LLVM_PROJECTDIR)/lld\n\n# Try to autodetect LLVM build tools.\n# Versions are listed here in descending priority order.\nLLVM_VERSIONS = 18 17 16 15\nerrifempty = $(if $(1),$(1),$(error $(2)))\ndetect = $(shell which $(call errifempty,$(firstword $(foreach p,$(2),$(shell command -v $(p) 2> /dev/null && echo $(p)))),failed to locate $(1) at any of: $(2)))\ntoolSearchPathsVersion = $(1)-$(2)\nifeq ($(shell uname -s),Darwin)\n\t# Also explicitly search Brew's copy, which is not in PATH by default.\n\tBREW_PREFIX := $(shell brew --prefix)\n\ttoolSearchPathsVersion += $(BREW_PREFIX)/opt/llvm@$(2)/bin/$(1)-$(2) $(BREW_PREFIX)/opt/llvm@$(2)/bin/$(1)\nendif\n# First search for a custom built copy, then move on to explicitly version-tagged binaries, then just see if the tool is in path with its normal name.\nfindLLVMTool = $(call detect,$(1),$(abspath llvm-build/bin/$(1)) $(foreach ver,$(LLVM_VERSIONS),$(call toolSearchPathsVersion,$(1),$(ver))) $(1))\nCLANG ?= $(call findLLVMTool,clang)\nLLVM_AR ?= $(call findLLVMTool,llvm-ar)\nLLVM_NM ?= $(call findLLVMTool,llvm-nm)\n\n# Go binary and GOROOT to select\nGO ?= go\nexport GOROOT = $(shell $(GO) env GOROOT)\n\n# Flags to pass to go test.\nGOTESTFLAGS ?=\nGOTESTPKGS ?= ./builder ./cgo ./compileopts ./compiler ./interp ./transform .\n\n# tinygo binary for tests\nTINYGO ?= $(call detect,tinygo,tinygo $(CURDIR)/build/tinygo)\n\n# Check for ccache if the user hasn't set it to on or off.\nifeq (, $(CCACHE))\n    # Use CCACHE for LLVM if possible\n    ifneq (, $(shell command -v ccache 2> /dev/null))\n        CCACHE := ON\n    else\n        CCACHE := OFF\n    endif\nendif\nLLVM_OPTION += '-DLLVM_CCACHE_BUILD=$(CCACHE)'\n\n# Allow enabling LLVM assertions\nifeq (1, $(ASSERT))\n    LLVM_OPTION += '-DLLVM_ENABLE_ASSERTIONS=ON'\nelse\n    LLVM_OPTION += '-DLLVM_ENABLE_ASSERTIONS=OFF'\nendif\n\n# Enable AddressSanitizer\nifeq (1, $(ASAN))\n    LLVM_OPTION += -DLLVM_USE_SANITIZER=Address\n    CGO_LDFLAGS += -fsanitize=address\nendif\n\nifeq (1, $(STATIC))\n    # Build TinyGo as a fully statically linked binary (no dynamically loaded\n    # libraries such as a libc). This is not supported with glibc which is used\n    # on most major Linux distributions. However, it is supported in Alpine\n    # Linux with musl.\n    CGO_LDFLAGS += -static\n    # Also set the thread stack size to 1MB. This is necessary on musl as the\n    # default stack size is 128kB and LLVM uses more than that.\n    # For more information, see:\n    # https://wiki.musl-libc.org/functional-differences-from-glibc.html#Thread-stack-size\n    CGO_LDFLAGS += -Wl,-z,stack-size=1048576\n    # Build wasm-opt with static linking.\n    # For details, see:\n    # https://github.com/WebAssembly/binaryen/blob/version_102/.github/workflows/ci.yml#L181\n    BINARYEN_OPTION += -DCMAKE_CXX_FLAGS=\"-static\" -DCMAKE_C_FLAGS=\"-static\"\nendif\n\n# Cross compiling support.\nifneq ($(CROSS),)\n    CC = $(CROSS)-gcc\n    CXX = $(CROSS)-g++\n    LLVM_OPTION += \\\n        -DCMAKE_C_COMPILER=$(CC) \\\n        -DCMAKE_CXX_COMPILER=$(CXX) \\\n        -DLLVM_DEFAULT_TARGET_TRIPLE=$(CROSS) \\\n        -DCROSS_TOOLCHAIN_FLAGS_NATIVE=\"-UCMAKE_C_COMPILER;-UCMAKE_CXX_COMPILER\"\n    ifeq ($(CROSS), arm-linux-gnueabihf)\n        # Assume we're building on a Debian-like distro, with QEMU installed.\n        LLVM_CONFIG_PREFIX = qemu-arm -L /usr/arm-linux-gnueabihf/\n        # The CMAKE_SYSTEM_NAME flag triggers cross compilation mode.\n        LLVM_OPTION += \\\n            -DCMAKE_SYSTEM_NAME=Linux \\\n            -DLLVM_TARGET_ARCH=ARM\n        GOENVFLAGS = GOARCH=arm CC=$(CC) CXX=$(CXX) CGO_ENABLED=1\n        BINARYEN_OPTION += -DCMAKE_C_COMPILER=$(CC) -DCMAKE_CXX_COMPILER=$(CXX)\n    else ifeq ($(CROSS), aarch64-linux-gnu)\n        # Assume we're building on a Debian-like distro, with QEMU installed.\n        LLVM_CONFIG_PREFIX = qemu-aarch64 -L /usr/aarch64-linux-gnu/\n        # The CMAKE_SYSTEM_NAME flag triggers cross compilation mode.\n        LLVM_OPTION += \\\n            -DCMAKE_SYSTEM_NAME=Linux \\\n            -DLLVM_TARGET_ARCH=AArch64\n        GOENVFLAGS = GOARCH=arm64 CC=$(CC) CXX=$(CXX) CGO_ENABLED=1\n        BINARYEN_OPTION += -DCMAKE_C_COMPILER=$(CC) -DCMAKE_CXX_COMPILER=$(CXX)\n    else\n        $(error Unknown cross compilation target: $(CROSS))\n    endif\nendif\n\n.PHONY: all tinygo test $(LLVM_BUILDDIR) llvm-source clean fmt gen-device gen-device-nrf gen-device-nxp gen-device-avr gen-device-rp\n\nLLVM_COMPONENTS = all-targets analysis asmparser asmprinter bitreader bitwriter codegen core coroutines coverage debuginfodwarf debuginfopdb executionengine frontenddriver frontendhlsl frontendopenmp instrumentation interpreter ipo irreader libdriver linker lto mc mcjit objcarcopts option profiledata scalaropts support target windowsdriver windowsmanifest\n\nifeq ($(OS),Windows_NT)\n    EXE = .exe\n    START_GROUP = -Wl,--start-group\n    END_GROUP = -Wl,--end-group\n\n    # PIC needs to be disabled for libclang to work.\n    LLVM_OPTION += -DLLVM_ENABLE_PIC=OFF\n\n    CGO_CPPFLAGS += -DCINDEX_NO_EXPORTS\n    CGO_LDFLAGS += -static -static-libgcc -static-libstdc++\n    CGO_LDFLAGS_EXTRA += -lversion\n\n    USE_SYSTEM_BINARYEN ?= 1\n\nelse ifeq ($(shell uname -s),Darwin)\n    MD5SUM ?= md5\n\n    CGO_LDFLAGS += -lxar\n\n    USE_SYSTEM_BINARYEN ?= 1\n\nelse ifeq ($(shell uname -s),FreeBSD)\n    MD5SUM ?= md5\n    START_GROUP = -Wl,--start-group\n    END_GROUP = -Wl,--end-group\nelse\n    START_GROUP = -Wl,--start-group\n    END_GROUP = -Wl,--end-group\nendif\n\n# md5sum binary default, can be overridden by an environment variable\nMD5SUM ?= md5sum\n\n# Libraries that should be linked in for the statically linked Clang.\nCLANG_LIB_NAMES = clangAnalysis clangAPINotes clangAST clangASTMatchers clangBasic clangCodeGen clangCrossTU clangDriver clangDynamicASTMatchers clangEdit clangExtractAPI clangFormat clangFrontend clangFrontendTool clangHandleCXX clangHandleLLVM clangIndex clangLex clangParse clangRewrite clangRewriteFrontend clangSema clangSerialization clangSupport clangTooling clangToolingASTDiff clangToolingCore clangToolingInclusions\nCLANG_LIBS = $(START_GROUP) $(addprefix -l,$(CLANG_LIB_NAMES)) $(END_GROUP) -lstdc++\n\n# Libraries that should be linked in for the statically linked LLD.\nLLD_LIB_NAMES = lldCOFF lldCommon lldELF lldMachO lldMinGW lldWasm\nLLD_LIBS = $(START_GROUP) $(addprefix -l,$(LLD_LIB_NAMES)) $(END_GROUP)\n\n# Other libraries that are needed to link TinyGo.\nEXTRA_LIB_NAMES = LLVMInterpreter LLVMMCA LLVMRISCVTargetMCA LLVMX86TargetMCA\n\n# All libraries to be built and linked with the tinygo binary (lib/lib*.a).\nLIB_NAMES = clang $(CLANG_LIB_NAMES) $(LLD_LIB_NAMES) $(EXTRA_LIB_NAMES)\n\n# These build targets appear to be the only ones necessary to build all TinyGo\n# dependencies. Only building a subset significantly speeds up rebuilding LLVM.\n# The Makefile rules convert a name like lldELF to lib/liblldELF.a to match the\n# library path (for ninja).\n# This list also includes a few tools that are necessary as part of the full\n# TinyGo build.\nNINJA_BUILD_TARGETS = clang llvm-config llvm-ar llvm-nm lld $(addprefix lib/lib,$(addsuffix .a,$(LIB_NAMES)))\n\n# For static linking.\nifneq (\"$(wildcard $(LLVM_BUILDDIR)/bin/llvm-config*)\",\"\")\n    CGO_CPPFLAGS+=$(shell $(LLVM_CONFIG_PREFIX) $(LLVM_BUILDDIR)/bin/llvm-config --cppflags) -I$(abspath $(LLVM_BUILDDIR))/tools/clang/include -I$(abspath $(CLANG_SRC))/include -I$(abspath $(LLD_SRC))/include\n    CGO_CXXFLAGS=-std=c++17\n    CGO_LDFLAGS+=-L$(abspath $(LLVM_BUILDDIR)/lib) -lclang $(CLANG_LIBS) $(LLD_LIBS) $(shell $(LLVM_CONFIG_PREFIX) $(LLVM_BUILDDIR)/bin/llvm-config --ldflags --libs --system-libs $(LLVM_COMPONENTS)) -lstdc++ $(CGO_LDFLAGS_EXTRA)\nendif\n\nclean: ## Remove build directory\n\t@rm -rf build\n\nFMT_PATHS = ./*.go builder cgo/*.go compiler interp loader src transform\nfmt: ## Reformat source\n\t@gofmt -l -w $(FMT_PATHS)\nfmt-check: ## Warn if any source needs reformatting\n\t@unformatted=$$(gofmt -l $(FMT_PATHS)); [ -z \"$$unformatted\" ] && exit 0; echo \"Unformatted:\"; for fn in $$unformatted; do echo \"  $$fn\"; done; exit 1\n\n\ngen-device: gen-device-avr gen-device-esp gen-device-nrf gen-device-sam gen-device-sifive gen-device-kendryte gen-device-nxp gen-device-rp gen-device-renesas ## Generate microcontroller-specific sources\nifneq ($(STM32), 0)\ngen-device: gen-device-stm32\nendif\n\ngen-device-avr:\n\t@if [ ! -e lib/avr/README.md ]; then echo \"Submodules have not been downloaded. Please download them using:\\n  git submodule update --init\"; exit 1; fi\n\t$(GO) build -o ./build/gen-device-avr ./tools/gen-device-avr/\n\t./build/gen-device-avr lib/avr/packs/atmega src/device/avr/\n\t./build/gen-device-avr lib/avr/packs/tiny src/device/avr/\n\t@GO111MODULE=off $(GO) fmt ./src/device/avr\n\nbuild/gen-device-svd: ./tools/gen-device-svd/*.go\n\t$(GO) build -o $@ ./tools/gen-device-svd/\n\ngen-device-esp: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/posborne/cmsis-svd/tree/master/data/Espressif-Community -interrupts=software lib/cmsis-svd/data/Espressif-Community/ src/device/esp/\n\t./build/gen-device-svd -source=https://github.com/posborne/cmsis-svd/tree/master/data/Espressif -interrupts=software lib/cmsis-svd/data/Espressif/ src/device/esp/\n\tGO111MODULE=off $(GO) fmt ./src/device/esp\n\ngen-device-nrf: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/NordicSemiconductor/nrfx/tree/master/mdk lib/nrfx/mdk/ src/device/nrf/\n\tGO111MODULE=off $(GO) fmt ./src/device/nrf\n\ngen-device-nxp: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/posborne/cmsis-svd/tree/master/data/NXP lib/cmsis-svd/data/NXP/ src/device/nxp/\n\tGO111MODULE=off $(GO) fmt ./src/device/nxp\n\ngen-device-sam: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/posborne/cmsis-svd/tree/master/data/Atmel lib/cmsis-svd/data/Atmel/ src/device/sam/\n\tGO111MODULE=off $(GO) fmt ./src/device/sam\n\ngen-device-sifive: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/posborne/cmsis-svd/tree/master/data/SiFive-Community -interrupts=software lib/cmsis-svd/data/SiFive-Community/ src/device/sifive/\n\tGO111MODULE=off $(GO) fmt ./src/device/sifive\n\ngen-device-kendryte: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/posborne/cmsis-svd/tree/master/data/Kendryte-Community -interrupts=software lib/cmsis-svd/data/Kendryte-Community/ src/device/kendryte/\n\tGO111MODULE=off $(GO) fmt ./src/device/kendryte\n\ngen-device-stm32: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/tinygo-org/stm32-svd lib/stm32-svd/svd src/device/stm32/\n\tGO111MODULE=off $(GO) fmt ./src/device/stm32\n\ngen-device-rp: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/posborne/cmsis-svd/tree/master/data/RaspberryPi lib/cmsis-svd/data/RaspberryPi/ src/device/rp/\n\tGO111MODULE=off $(GO) fmt ./src/device/rp\n\ngen-device-renesas: build/gen-device-svd\n\t./build/gen-device-svd -source=https://github.com/cmsis-svd/cmsis-svd-data/tree/master/data/Renesas lib/cmsis-svd/data/Renesas/ src/device/renesas/\n\tGO111MODULE=off $(GO) fmt ./src/device/renesas\n\n$(LLVM_PROJECTDIR)/llvm:\n\tgit clone -b tinygo_xtensa_release_18.1.2 --depth=1 https://github.com/tinygo-org/llvm-project $(LLVM_PROJECTDIR)\nllvm-source: $(LLVM_PROJECTDIR)/llvm ## Get LLVM sources\n\n# Configure LLVM.\nTINYGO_SOURCE_DIR=$(shell pwd)\n$(LLVM_BUILDDIR)/build.ninja:\n\tmkdir -p $(LLVM_BUILDDIR) && cd $(LLVM_BUILDDIR) && cmake -G Ninja $(TINYGO_SOURCE_DIR)/$(LLVM_PROJECTDIR)/llvm \"-DLLVM_TARGETS_TO_BUILD=X86;ARM;AArch64;AVR;Mips;RISCV;WebAssembly\" \"-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=Xtensa\" -DCMAKE_BUILD_TYPE=Release -DLIBCLANG_BUILD_STATIC=ON -DLLVM_ENABLE_TERMINFO=OFF -DLLVM_ENABLE_ZLIB=OFF -DLLVM_ENABLE_ZSTD=OFF -DLLVM_ENABLE_LIBEDIT=OFF -DLLVM_ENABLE_Z3_SOLVER=OFF -DLLVM_ENABLE_OCAMLDOC=OFF -DLLVM_ENABLE_LIBXML2=OFF -DLLVM_ENABLE_PROJECTS=\"clang;lld\" -DLLVM_TOOL_CLANG_TOOLS_EXTRA_BUILD=OFF -DCLANG_ENABLE_STATIC_ANALYZER=OFF -DCLANG_ENABLE_ARCMT=OFF $(LLVM_OPTION)\n\n$(LLVM_BUILDDIR): $(LLVM_BUILDDIR)/build.ninja ## Build LLVM\n\tcd $(LLVM_BUILDDIR) && ninja $(NINJA_BUILD_TARGETS)\n\nifneq ($(USE_SYSTEM_BINARYEN),1)\n# Build Binaryen\n.PHONY: binaryen\nbinaryen: build/wasm-opt$(EXE)\nbuild/wasm-opt$(EXE):\n\tmkdir -p build\n\tcd lib/binaryen && cmake -G Ninja . -DBUILD_STATIC_LIB=ON -DBUILD_TESTS=OFF -DENABLE_WERROR=OFF $(BINARYEN_OPTION) && ninja bin/wasm-opt$(EXE)\n\tcp lib/binaryen/bin/wasm-opt$(EXE) build/wasm-opt$(EXE)\nendif\n\n# Build wasi-libc sysroot\n.PHONY: wasi-libc\nwasi-libc: lib/wasi-libc/sysroot/lib/wasm32-wasi/libc.a\nlib/wasi-libc/sysroot/lib/wasm32-wasi/libc.a:\n\t@if [ ! -e lib/wasi-libc/Makefile ]; then echo \"Submodules have not been downloaded. Please download them using:\\n  git submodule update --init\"; exit 1; fi\n\tcd lib/wasi-libc && $(MAKE) -j4 EXTRA_CFLAGS=\"-O2 -g -DNDEBUG -mnontrapping-fptoint -msign-ext\" MALLOC_IMPL=none CC=\"$(CLANG)\" AR=$(LLVM_AR) NM=$(LLVM_NM)\n\n# Generate WASI syscall bindings\nWASM_TOOLS_MODULE=github.com/bytecodealliance/wasm-tools-go\n.PHONY: wasi-syscall\nwasi-syscall: wasi-cm\n\tgo run -modfile ./internal/wasm-tools/go.mod $(WASM_TOOLS_MODULE)/cmd/wit-bindgen-go generate --versioned -o ./src/internal -p internal --cm internal/cm ./lib/wasi-cli/wit\n\n# Copy package cm into src/internal/cm\n.PHONY: wasi-cm\nwasi-cm:\n\t# rm -rf ./src/internal/cm\n\trsync -rv --delete --exclude '*_test.go' $(shell go list -modfile ./internal/wasm-tools/go.mod -m -f {{.Dir}} $(WASM_TOOLS_MODULE))/cm ./src/internal/\n\n# Check for Node.js used during WASM tests.\nNODEJS_VERSION := $(word 1,$(subst ., ,$(shell node -v | cut -c 2-)))\nMIN_NODEJS_VERSION=18\n\n.PHONY: check-nodejs-version\ncheck-nodejs-version:\nifeq (, $(shell which node))\n\t@echo \"Install NodeJS version 18+ to run tests.\"; exit 1;\nendif\n\t@if [ $(NODEJS_VERSION) -lt $(MIN_NODEJS_VERSION) ]; then echo \"Install NodeJS version 18+ to run tests.\"; exit 1; fi\n\ntinygo: ## Build the TinyGo compiler\n\t@if [ ! -f \"$(LLVM_BUILDDIR)/bin/llvm-config\" ]; then echo \"Fetch and build LLVM first by running:\"; echo \"  $(MAKE) llvm-source\"; echo \"  $(MAKE) $(LLVM_BUILDDIR)\"; exit 1; fi\n\tCGO_CPPFLAGS=\"$(CGO_CPPFLAGS)\" CGO_CXXFLAGS=\"$(CGO_CXXFLAGS)\" CGO_LDFLAGS=\"$(CGO_LDFLAGS)\" $(GOENVFLAGS) $(GO) build -buildmode exe -o build/tinygo$(EXE) -tags \"byollvm osusergo\" .\ntest: wasi-libc check-nodejs-version\n\tCGO_CPPFLAGS=\"$(CGO_CPPFLAGS)\" CGO_CXXFLAGS=\"$(CGO_CXXFLAGS)\" CGO_LDFLAGS=\"$(CGO_LDFLAGS)\" $(GO) test $(GOTESTFLAGS) -timeout=1h -buildmode exe -tags \"byollvm osusergo\" $(GOTESTPKGS)\n\n# Standard library packages that pass tests on darwin, linux, wasi, and windows, but take over a minute in wasi\nTEST_PACKAGES_SLOW = \\\n\tcompress/bzip2 \\\n\tcrypto/dsa \\\n\tindex/suffixarray \\\n\n# Standard library packages that pass tests quickly on darwin, linux, wasi, and windows\nTEST_PACKAGES_FAST = \\\n\tcmp \\\n\tcompress/lzw \\\n\tcompress/zlib \\\n\tcontainer/heap \\\n\tcontainer/list \\\n\tcontainer/ring \\\n\tcrypto/des \\\n\tcrypto/ecdsa \\\n\tcrypto/elliptic \\\n\tcrypto/md5 \\\n\tcrypto/rc4 \\\n\tcrypto/sha1 \\\n\tcrypto/sha256 \\\n\tcrypto/sha512 \\\n\tdatabase/sql/driver \\\n\tdebug/macho \\\n\tembed/internal/embedtest \\\n\tencoding \\\n\tencoding/ascii85 \\\n\tencoding/asn1 \\\n\tencoding/base32 \\\n\tencoding/base64 \\\n\tencoding/csv \\\n\tencoding/hex \\\n\tgo/ast \\\n\tgo/format \\\n\tgo/scanner \\\n\tgo/version \\\n\thash \\\n\thash/adler32 \\\n\thash/crc64 \\\n\thash/fnv \\\n\thtml \\\n\tinternal/itoa \\\n\tinternal/profile \\\n\tmath \\\n\tmath/cmplx \\\n\tnet/http/internal/ascii \\\n\tnet/mail \\\n\tos \\\n\tpath \\\n\treflect \\\n\tsync \\\n\ttesting \\\n\ttesting/iotest \\\n\ttext/scanner \\\n\tunicode \\\n\tunicode/utf16 \\\n\tunicode/utf8 \\\n\tunique \\\n\t$(nil)\n\n# Assume this will go away before Go2, so only check minor version.\nifeq ($(filter $(shell $(GO) env GOVERSION | cut -f 2 -d.), 16 17 18), )\nTEST_PACKAGES_FAST += crypto/internal/nistec/fiat\nelse\nTEST_PACKAGES_FAST += crypto/elliptic/internal/fiat\nendif\n\n# archive/zip requires os.ReadAt, which is not yet supported on windows\n# bytes requires mmap\n# compress/flate appears to hang on wasi\n# crypto/aes fails on wasi, needs panic()/recover()\n# crypto/hmac fails on wasi, it exits with a \"slice out of range\" panic\n# debug/plan9obj requires os.ReadAt, which is not yet supported on windows\n# image requires recover(), which is not yet supported on wasi\n# io/ioutil requires os.ReadDir, which is not yet supported on windows or wasi\n# mime: fail on wasi; neds panic()/recover()\n# mime/multipart: needs wasip1 syscall.FDFLAG_NONBLOCK\n# mime/quotedprintable requires syscall.Faccessat\n# net/mail: needs wasip1  syscall.FDFLAG_NONBLOCK\n# net/ntextproto: needs wasip1 syscall.FDFLAG_NONBLOCK\n# regexp/syntax: fails on wasip1; needs panic()/recover()\n# strconv requires recover() which is not yet supported on wasi\n# text/tabwriter requires recover(), which is not yet supported on wasi\n# text/template/parse requires recover(), which is not yet supported on wasi\n# testing/fstest requires os.ReadDir, which is not yet supported on windows or wasi\n\n# Additional standard library packages that pass tests on individual platforms\nTEST_PACKAGES_LINUX := \\\n\tarchive/zip \\\n\tcompress/flate \\\n\tcrypto/aes \\\n\tcrypto/hmac \\\n\tdebug/dwarf \\\n\tdebug/plan9obj \\\n\timage \\\n\tio/ioutil \\\n\tmime \\\n\tmime/multipart \\\n\tmime/quotedprintable \\\n\tnet \\\n\tnet/mail \\\n\tnet/textproto \\\n\tos/user \\\n\tregexp/syntax \\\n\tstrconv \\\n\ttext/tabwriter \\\n\ttext/template/parse\n\nTEST_PACKAGES_DARWIN := $(TEST_PACKAGES_LINUX)\n\nTEST_PACKAGES_WINDOWS := \\\n\tcompress/flate \\\n\tcrypto/hmac \\\n\tos/user \\\n\tstrconv \\\n\ttext/template/parse \\\n\t$(nil)\n\n# Report platforms on which each standard library package is known to pass tests\njointmp := $(shell echo /tmp/join.$$$$)\nreport-stdlib-tests-pass:\n\t@for t in $(TEST_PACKAGES_DARWIN); do echo \"$$t darwin\"; done | sort > $(jointmp).darwin\n\t@for t in $(TEST_PACKAGES_LINUX); do echo \"$$t linux\"; done | sort > $(jointmp).linux\n\t@for t in $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_SLOW); do echo \"$$t darwin linux wasi windows\"; done | sort > $(jointmp).portable\n\t@join -a1 -a2 $(jointmp).darwin $(jointmp).linux | \\\n\tjoin -a1 -a2 - $(jointmp).portable\n\t@rm $(jointmp).*\n\n# Standard library packages that pass tests quickly on the current platform\nifeq ($(shell uname),Darwin)\nTEST_PACKAGES_HOST := $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_DARWIN)\nTEST_IOFS := true\nendif\nifeq ($(shell uname),Linux)\nTEST_PACKAGES_HOST := $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_LINUX)\nTEST_IOFS := true\nendif\nifeq ($(OS),Windows_NT)\nTEST_PACKAGES_HOST := $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_WINDOWS)\nTEST_IOFS := false\nendif\n\n# Test known-working standard library packages.\n# TODO: parallelize, and only show failing tests (no implied -v flag).\n.PHONY: tinygo-test\ntinygo-test:\n\t$(TINYGO) test $(TEST_PACKAGES_HOST) $(TEST_PACKAGES_SLOW)\n\t@# io/fs requires os.ReadDir, not yet supported on windows or wasi. It also\n\t@# requires a large stack-size. Hence, io/fs is only run conditionally.\n\t@# For more details, see the comments on issue #3143.\nifeq ($(TEST_IOFS),true)\n\t$(TINYGO) test -stack-size=6MB io/fs\nendif\ntinygo-test-fast:\n\t$(TINYGO) test $(TEST_PACKAGES_HOST)\ntinygo-bench:\n\t$(TINYGO) test -bench . $(TEST_PACKAGES_HOST) $(TEST_PACKAGES_SLOW)\ntinygo-bench-fast:\n\t$(TINYGO) test -bench . $(TEST_PACKAGES_HOST)\n\n# Same thing, except for wasi rather than the current platform.\ntinygo-test-wasi:\n\t$(TINYGO) test -target wasip1 $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_SLOW) ./tests/runtime_wasi\ntinygo-test-wasip1:\n\tGOOS=wasip1 GOARCH=wasm $(TINYGO) test $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_SLOW) ./tests/runtime_wasi\ntinygo-test-wasip1-fast:\n\t$(TINYGO) test -target=wasip1 $(TEST_PACKAGES_FAST) ./tests/runtime_wasi\n\ntinygo-test-wasip2-slow:\n\t$(TINYGO) test -target=wasip2 $(TEST_PACKAGES_SLOW)\ntinygo-test-wasip2-fast:\n\t$(TINYGO) test -target=wasip2 $(TEST_PACKAGES_FAST) ./tests/runtime_wasi\n\ntinygo-test-wasip2-sum-slow:\n\tTINYGO=$(TINYGO) \\\n\tTARGET=wasip2 \\\n\tTESTOPTS=\"-x -work\" \\\n\tPACKAGES=\"$(TEST_PACKAGES_SLOW)\" \\\n\tgotestsum --raw-command -- ./tools/tgtestjson.sh\ntinygo-test-wasip2-sum-fast:\n\tTINYGO=$(TINYGO) \\\n\tTARGET=wasip2 \\\n\tTESTOPTS=\"-x -work\" \\\n\tPACKAGES=\"$(TEST_PACKAGES_FAST)\" \\\n\tgotestsum --raw-command -- ./tools/tgtestjson.sh\ntinygo-bench-wasip1:\n\t$(TINYGO) test -target wasip1 -bench . $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_SLOW)\ntinygo-bench-wasip1-fast:\n\t$(TINYGO) test -target wasip1 -bench . $(TEST_PACKAGES_FAST)\n\ntinygo-bench-wasip2:\n\t$(TINYGO) test -target wasip2 -bench . $(TEST_PACKAGES_FAST) $(TEST_PACKAGES_SLOW)\ntinygo-bench-wasip2-fast:\n\t$(TINYGO) test -target wasip2 -bench . $(TEST_PACKAGES_FAST)\n\n# Test external packages in a large corpus.\ntest-corpus:\n\tCGO_CPPFLAGS=\"$(CGO_CPPFLAGS)\" CGO_CXXFLAGS=\"$(CGO_CXXFLAGS)\" CGO_LDFLAGS=\"$(CGO_LDFLAGS)\" $(GO) test $(GOTESTFLAGS) -timeout=1h -buildmode exe -tags byollvm -run TestCorpus . -corpus=testdata/corpus.yaml\ntest-corpus-fast:\n\tCGO_CPPFLAGS=\"$(CGO_CPPFLAGS)\" CGO_CXXFLAGS=\"$(CGO_CXXFLAGS)\" CGO_LDFLAGS=\"$(CGO_LDFLAGS)\" $(GO) test $(GOTESTFLAGS) -timeout=1h -buildmode exe -tags byollvm -run TestCorpus -short . -corpus=testdata/corpus.yaml\ntest-corpus-wasi: wasi-libc\n\tCGO_CPPFLAGS=\"$(CGO_CPPFLAGS)\" CGO_CXXFLAGS=\"$(CGO_CXXFLAGS)\" CGO_LDFLAGS=\"$(CGO_LDFLAGS)\" $(GO) test $(GOTESTFLAGS) -timeout=1h -buildmode exe -tags byollvm -run TestCorpus . -corpus=testdata/corpus.yaml -target=wasip1\n\ntinygo-baremetal:\n\t# Regression tests that run on a baremetal target and don't fit in either main_test.go or smoketest.\n\t# regression test for #2666: e.g. encoding/hex must pass on baremetal\n\t$(TINYGO) test -target cortex-m-qemu encoding/hex\n\n.PHONY: testchdir\ntestchdir:\n\t# test 'build' command with{,out} -C argument\n\t$(TINYGO) build -C tests/testing/chdir chdir.go && rm tests/testing/chdir/chdir\n\t$(TINYGO) build ./tests/testing/chdir/chdir.go && rm chdir\n\t# test 'run' command with{,out} -C argument\n\tEXPECT_DIR=$(PWD)/tests/testing/chdir $(TINYGO) run -C tests/testing/chdir chdir.go\n\tEXPECT_DIR=$(PWD) $(TINYGO) run ./tests/testing/chdir/chdir.go\n\n.PHONY: smoketest\nsmoketest: testchdir\n\t$(TINYGO) version\n\t$(TINYGO) targets > /dev/null\n\t# regression test for #2892\n\tcd tests/testing/recurse && ($(TINYGO) test ./... > recurse.log && cat recurse.log && test $$(wc -l < recurse.log) = 2 && rm recurse.log)\n\t# compile-only platform-independent examples\n\tcd tests/text/template/smoke && $(TINYGO) test -c && rm -f smoke.test\n\t# regression test for #2563\n\tcd tests/os/smoke && $(TINYGO) test -c -target=pybadge && rm smoke.test\n\t# test all examples (except pwm)\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/adc\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/blinkm\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/blinky2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/button\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/button2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/echo2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=circuitplay-express examples/i2s\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/mcp3008\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/memstats\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=microbit            examples/microbit-blink\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/pininterrupt\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nano-rp2040         examples/rtcinterrupt\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/machinetest\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/systick\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/test\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040            examples/time-offset\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=wioterminal         examples/hid-mouse\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=wioterminal         examples/hid-keyboard\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-rp2040      examples/i2c-target\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-rp2040      examples/watchdog\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-rp2040      examples/device-id\n\t@$(MD5SUM) test.hex\n\t# test simulated boards on play.tinygo.org\nifneq ($(WASM), 0)\n\t$(TINYGO) build -size short -o test.wasm -tags=arduino              examples/blinky1\n\t@$(MD5SUM) test.wasm\n\t$(TINYGO) build -size short -o test.wasm -tags=hifive1b             examples/blinky1\n\t@$(MD5SUM) test.wasm\n\t$(TINYGO) build -size short -o test.wasm -tags=reelboard            examples/blinky1\n\t@$(MD5SUM) test.wasm\n\t$(TINYGO) build -size short -o test.wasm -tags=microbit             examples/microbit-blink\n\t@$(MD5SUM) test.wasm\n\t$(TINYGO) build -size short -o test.wasm -tags=circuitplay_express  examples/blinky1\n\t@$(MD5SUM) test.wasm\n\t$(TINYGO) build -size short -o test.wasm -tags=circuitplay_bluefruit examples/blinky1\n\t@$(MD5SUM) test.wasm\n\t$(TINYGO) build -size short -o test.wasm -tags=mch2022              examples/machinetest\n\t@$(MD5SUM) test.wasm\n\t$(TINYGO) build -size short -o test.wasm -tags=gopher_badge         examples/blinky1\n\t@$(MD5SUM) test.wasm\nendif\n\t# test all targets/boards\n\t$(TINYGO) build -size short -o test.hex -target=pca10040-s132v6     examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=microbit            examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=microbit-s110v8     examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=microbit-v2         examples/microbit-blink\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=microbit-v2-s113v7  examples/microbit-blink\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nrf52840-mdk        examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10031            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=reelboard           examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=reelboard           examples/blinky2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10056            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10056            examples/blinky2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10059            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10059            examples/blinky2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=bluemicro840        examples/blinky2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=itsybitsy-m0        examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-m0          examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=trinket-m0          examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=gemma-m0            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=circuitplay-express examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=circuitplay-bluefruit examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=circuitplay-express examples/i2s\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=clue-alpha          examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.gba -target=gameboy-advance     examples/gba-display\n\t@$(MD5SUM) test.gba\n\t$(TINYGO) build -size short -o test.hex -target=grandcentral-m4     examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=itsybitsy-m4        examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-m4          examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=matrixportal-m4     examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pybadge             examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=metro-m4-airlift    examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pyportal            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=particle-argon      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=particle-boron      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=particle-xenon      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pinetime            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=x9pro               examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10056-s140v7     examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10059-s140v7     examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=reelboard-s140v7    examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=wioterminal         examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pygamer             examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=xiao                examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=rak4631             examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=circuitplay-express examples/dac\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pyportal            examples/dac\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-nrf52840  \texamples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-nrf52840-sense examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=itsybitsy-nrf52840  examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=qtpy                examples/machinetest\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=teensy41            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=teensy40            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=teensy36            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=p1am-100            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=atsame54-xpro       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=atsame54-xpro       examples/can\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-m4-can      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-m4-can      examples/caninterrupt\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino-nano33      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino-mkrwifi1010 examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pico                examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nano-33-ble         examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nano-rp2040         examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-rp2040 \t\texamples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=qtpy-rp2040         examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=kb2040              examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=macropad-rp2040 \texamples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=badger2040          examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=badger2040-w        examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=tufty2040           examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=thingplus-rp2040    examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=xiao-rp2040         examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=waveshare-rp2040-zero examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=challenger-rp2040    examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=trinkey-qt2040      examples/temp\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=gopher-badge      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=ae-rp2040           examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=thumby              examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pico2               examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=tiny2350            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t# test pwm\n\t$(TINYGO) build -size short -o test.hex -target=itsybitsy-m0        examples/pwm\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=itsybitsy-m4        examples/pwm\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-m4          examples/pwm\n\t@$(MD5SUM) test.hex\n\t# test usb\n\t$(TINYGO) build -size short -o test.hex -target=feather-nrf52840    examples/hid-keyboard\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=circuitplay-express examples/hid-keyboard\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-nrf52840    examples/usb-midi\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nrf52840-s140v6-uf2-generic\texamples/machinetest\n\t@$(MD5SUM) test.hex\nifneq ($(STM32), 0)\n\t$(TINYGO) build -size short -o test.hex -target=bluepill            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=feather-stm32f405   examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=lgt92               examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nucleo-f103rb       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nucleo-f722ze       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nucleo-l031k6       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nucleo-l432kc       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nucleo-l476rg       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nucleo-l552ze       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=nucleo-wl55jc       examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=stm32f4disco        examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=stm32f4disco        examples/blinky2\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=stm32f4disco-1      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=stm32f4disco-1      examples/pwm\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=stm32f469disco      examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=lorae5              examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=swan                examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=mksnanov3           examples/blinky1\n\t@$(MD5SUM) test.hex\nendif\n\t$(TINYGO) build -size short -o test.hex -target=atmega328pb         examples/blinkm\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=atmega1284p         examples/machinetest\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino             examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino-leonardo    examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino             examples/pwm\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino -scheduler=tasks  examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino-mega1280    examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino-mega1280    examples/pwm\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=arduino-nano        examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=attiny1616          examples/empty\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=digispark           examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=digispark -gc=leaking examples/blinky1\n\t@$(MD5SUM) test.hex\nifneq ($(XTENSA), 0)\n\t$(TINYGO) build -size short -o test.bin -target=esp32-mini32      \texamples/blinky1\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target=nodemcu             examples/blinky1\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target m5stack-core2       examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target m5stack             examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target m5stick-c           examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target m5paper             examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target mch2022             examples/machinetest\n\t@$(MD5SUM) test.bin\nendif\n\t$(TINYGO) build -size short -o test.bin -target=esp-c3-32s-kit      examples/blinky1\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target=qtpy-esp32c3        examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target=m5stamp-c3          examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target=xiao-esp32c3        examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target=esp32-c3-devkit-rust-1 examples/blinky1\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target=esp32c3-12f         examples/blinky1\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.bin -target=makerfabs-esp32c3spi35 examples/machinetest\n\t@$(MD5SUM) test.bin\n\t$(TINYGO) build -size short -o test.hex -target=hifive1b            examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=maixbit             examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=tkey                examples/blinky1\n\t@$(MD5SUM) test.hex\nifneq ($(WASM), 0)\n\t$(TINYGO) build -size short -o wasm.wasm -target=wasm               examples/wasm/export\n\t$(TINYGO) build -size short -o wasm.wasm -target=wasm               examples/wasm/main\n\t$(TINYGO) build -size short -o wasm.wasm -target=wasm-unknown       examples/hello-wasm-unknown\nendif\n\t# test various compiler flags\n\t$(TINYGO) build -size short -o test.hex -target=pca10040 -gc=none -scheduler=none examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040 -opt=1     examples/blinky1\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040 -serial=none examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build -size short -o test.hex -target=pca10040 -serial=rtt examples/echo\n\t@$(MD5SUM) test.hex\n\t$(TINYGO) build             -o test.nro -target=nintendoswitch      examples/echo2\n\t@$(MD5SUM) test.nro\n\t$(TINYGO) build -size short -o test.hex -target=pca10040 -opt=0     ./testdata/stdlib.go\n\t@$(MD5SUM) test.hex\n\tGOOS=linux GOARCH=arm $(TINYGO) build -size short -o test.elf       ./testdata/cgo\n\tGOOS=linux GOARCH=mips    $(TINYGO) build -size short -o test.elf   ./testdata/cgo\n\tGOOS=windows GOARCH=amd64 $(TINYGO) build -size short -o test.exe   ./testdata/cgo\n\tGOOS=windows GOARCH=arm64 $(TINYGO) build -size short -o test.exe   ./testdata/cgo\n\tGOOS=darwin GOARCH=amd64 $(TINYGO) build  -size short -o test       ./testdata/cgo\n\tGOOS=darwin GOARCH=arm64 $(TINYGO) build  -size short -o test       ./testdata/cgo\nifneq ($(OS),Windows_NT)\n\t# TODO: this does not yet work on Windows. Somehow, unused functions are\n\t# not garbage collected.\n\t$(TINYGO) build -o test.elf -gc=leaking -scheduler=none examples/serial\nendif\n\n\nwasmtest:\n\t$(GO) test ./tests/wasm\n\nbuild/release: tinygo gen-device wasi-libc $(if $(filter 1,$(USE_SYSTEM_BINARYEN)),,binaryen)\n\t@mkdir -p build/release/tinygo/bin\n\t@mkdir -p build/release/tinygo/lib/clang/include\n\t@mkdir -p build/release/tinygo/lib/CMSIS/CMSIS\n\t@mkdir -p build/release/tinygo/lib/macos-minimal-sdk\n\t@mkdir -p build/release/tinygo/lib/mingw-w64/mingw-w64-crt/lib-common\n\t@mkdir -p build/release/tinygo/lib/mingw-w64/mingw-w64-crt/stdio\n\t@mkdir -p build/release/tinygo/lib/mingw-w64/mingw-w64-headers/defaults\n\t@mkdir -p build/release/tinygo/lib/musl/arch\n\t@mkdir -p build/release/tinygo/lib/musl/crt\n\t@mkdir -p build/release/tinygo/lib/musl/src\n\t@mkdir -p build/release/tinygo/lib/nrfx\n\t@mkdir -p build/release/tinygo/lib/picolibc/newlib/libc\n\t@mkdir -p build/release/tinygo/lib/picolibc/newlib/libm\n\t@mkdir -p build/release/tinygo/lib/wasi-libc/libc-bottom-half/headers\n\t@mkdir -p build/release/tinygo/lib/wasi-libc/libc-top-half/musl/arch\n\t@mkdir -p build/release/tinygo/lib/wasi-libc/libc-top-half/musl/src\n\t@mkdir -p build/release/tinygo/lib/wasi-cli/\n\t@echo copying source files\n\t@cp -p  build/tinygo$(EXE)           build/release/tinygo/bin\nifneq ($(USE_SYSTEM_BINARYEN),1)\n\t@cp -p  build/wasm-opt$(EXE)         build/release/tinygo/bin\nendif\n\t@cp -p $(abspath $(CLANG_SRC))/lib/Headers/*.h build/release/tinygo/lib/clang/include\n\t@cp -rp lib/CMSIS/CMSIS/Include      build/release/tinygo/lib/CMSIS/CMSIS\n\t@cp -rp lib/CMSIS/README.md          build/release/tinygo/lib/CMSIS\n\t@cp -rp lib/macos-minimal-sdk/*      build/release/tinygo/lib/macos-minimal-sdk\n\t@cp -rp lib/musl/arch/aarch64        build/release/tinygo/lib/musl/arch\n\t@cp -rp lib/musl/arch/arm            build/release/tinygo/lib/musl/arch\n\t@cp -rp lib/musl/arch/generic        build/release/tinygo/lib/musl/arch\n\t@cp -rp lib/musl/arch/i386           build/release/tinygo/lib/musl/arch\n\t@cp -rp lib/musl/arch/mips           build/release/tinygo/lib/musl/arch\n\t@cp -rp lib/musl/arch/x86_64         build/release/tinygo/lib/musl/arch\n\t@cp -rp lib/musl/crt/crt1.c          build/release/tinygo/lib/musl/crt\n\t@cp -rp lib/musl/COPYRIGHT           build/release/tinygo/lib/musl\n\t@cp -rp lib/musl/include             build/release/tinygo/lib/musl\n\t@cp -rp lib/musl/src/env             build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/errno           build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/exit            build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/fcntl           build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/include         build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/internal        build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/legacy          build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/locale          build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/linux           build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/malloc          build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/mman            build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/math            build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/misc            build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/multibyte       build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/signal          build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/stdio           build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/string          build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/thread          build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/time            build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/unistd          build/release/tinygo/lib/musl/src\n\t@cp -rp lib/musl/src/process         build/release/tinygo/lib/musl/src\n\t@cp -rp lib/mingw-w64/mingw-w64-crt/def-include                 build/release/tinygo/lib/mingw-w64/mingw-w64-crt\n\t@cp -rp lib/mingw-w64/mingw-w64-crt/lib-common/api-ms-win-crt-* build/release/tinygo/lib/mingw-w64/mingw-w64-crt/lib-common\n\t@cp -rp lib/mingw-w64/mingw-w64-crt/lib-common/kernel32.def.in  build/release/tinygo/lib/mingw-w64/mingw-w64-crt/lib-common\n\t@cp -rp lib/mingw-w64/mingw-w64-crt/stdio/ucrt_*                build/release/tinygo/lib/mingw-w64/mingw-w64-crt/stdio\n\t@cp -rp lib/mingw-w64/mingw-w64-headers/crt/                    build/release/tinygo/lib/mingw-w64/mingw-w64-headers\n\t@cp -rp lib/mingw-w64/mingw-w64-headers/defaults/include        build/release/tinygo/lib/mingw-w64/mingw-w64-headers/defaults\n\t@cp -rp lib/nrfx/*                   build/release/tinygo/lib/nrfx\n\t@cp -rp lib/picolibc/newlib/libc/ctype       build/release/tinygo/lib/picolibc/newlib/libc\n\t@cp -rp lib/picolibc/newlib/libc/include     build/release/tinygo/lib/picolibc/newlib/libc\n\t@cp -rp lib/picolibc/newlib/libc/locale      build/release/tinygo/lib/picolibc/newlib/libc\n\t@cp -rp lib/picolibc/newlib/libc/string      build/release/tinygo/lib/picolibc/newlib/libc\n\t@cp -rp lib/picolibc/newlib/libc/tinystdio   build/release/tinygo/lib/picolibc/newlib/libc\n\t@cp -rp lib/picolibc/newlib/libm/common      build/release/tinygo/lib/picolibc/newlib/libm\n\t@cp -rp lib/picolibc/newlib/libm/math        build/release/tinygo/lib/picolibc/newlib/libm\n\t@cp -rp lib/picolibc-stdio.c         build/release/tinygo/lib\n\t@cp -rp lib/wasi-libc/libc-bottom-half/headers/public           build/release/tinygo/lib/wasi-libc/libc-bottom-half/headers\n\t@cp -rp lib/wasi-libc/libc-top-half/musl/arch/generic           build/release/tinygo/lib/wasi-libc/libc-top-half/musl/arch\n\t@cp -rp lib/wasi-libc/libc-top-half/musl/arch/wasm32            build/release/tinygo/lib/wasi-libc/libc-top-half/musl/arch\n\t@cp -rp lib/wasi-libc/libc-top-half/musl/src/include            build/release/tinygo/lib/wasi-libc/libc-top-half/musl/src\n\t@cp -rp lib/wasi-libc/libc-top-half/musl/src/internal           build/release/tinygo/lib/wasi-libc/libc-top-half/musl/src\n\t@cp -rp lib/wasi-libc/libc-top-half/musl/src/math               build/release/tinygo/lib/wasi-libc/libc-top-half/musl/src\n\t@cp -rp lib/wasi-libc/libc-top-half/musl/src/string             build/release/tinygo/lib/wasi-libc/libc-top-half/musl/src\n\t@cp -rp lib/wasi-libc/libc-top-half/musl/include                build/release/tinygo/lib/wasi-libc/libc-top-half/musl\n\t@cp -rp lib/wasi-libc/sysroot                                   build/release/tinygo/lib/wasi-libc/sysroot\n\t@cp -rp lib/wasi-cli/wit                                        build/release/tinygo/lib/wasi-cli/wit\n\t@cp -rp llvm-project/compiler-rt/lib/builtins build/release/tinygo/lib/compiler-rt-builtins\n\t@cp -rp llvm-project/compiler-rt/LICENSE.TXT  build/release/tinygo/lib/compiler-rt-builtins\n\t@cp -rp src                          build/release/tinygo/src\n\t@cp -rp targets                      build/release/tinygo/targets\n\nrelease:\n\ttar -czf build/release.tar.gz -C build/release tinygo\n\nDEB_ARCH ?= native\ndeb:\n\t@mkdir -p build/release-deb/usr/local/bin\n\t@mkdir -p build/release-deb/usr/local/lib\n\tcp -ar build/release/tinygo build/release-deb/usr/local/lib/tinygo\n\tln -sf ../lib/tinygo/bin/tinygo build/release-deb/usr/local/bin/tinygo\n\tfpm -f -s dir -t deb -n tinygo -a $(DEB_ARCH) -v $(shell grep \"const version = \" goenv/version.go | awk '{print $$NF}') -m '@tinygo-org' --description='TinyGo is a Go compiler for small places.' --license='BSD 3-Clause' --url=https://tinygo.org/ --deb-changelog CHANGELOG.md -p build/release.deb -C ./build/release-deb\n\nifneq ($(RELEASEONLY), 1)\nrelease: build/release\ndeb: build/release\nendif\n\n.PHONY: tools\ntools:\n\tcd internal/tools && go generate -tags tools ./\n\n.PHONY: lint\nlint: tools ## Lint source tree\n\trevive -version\n\t# TODO: lint more directories!\n\t# revive.toml isn't flexible enough to filter out just one kind of error from a checker, so do it with grep here.\n\t# Can't use grep with friendly formatter.  Plain output isn't too bad, though.\n\t# Use 'grep .' to get rid of stray blank line\n\trevive -config revive.toml compiler/... src/{os,reflect}/*.go | grep -v \"should have comment or be unexported\" | grep '.' | awk '{print}; END {exit NR>0}'\n\nSPELLDIRSCMD=find . -depth 1 -type d  | egrep -wv '.git|lib|llvm|src'; find src -depth 1 | egrep -wv 'device|internal|net|vendor'; find src/internal -depth 1 -type d | egrep -wv src/internal/wasi\n.PHONY: spell\nspell: tools ## Spellcheck source tree\n\tmisspell -error --dict misspell.csv -i 'ackward,devided,extint,rela' $$( $(SPELLDIRSCMD) ) *.go *.md\n\n.PHONY: spellfix\nspellfix: tools ## Same as spell, but fixes what it finds\n\tmisspell -w --dict misspell.csv -i 'ackward,devided,extint,rela' $$( $(SPELLDIRSCMD) ) *.go *.md\n\n# https://www.client9.com/self-documenting-makefiles/\n.PHONY: help\nhelp:\n\t@awk -F ':|##' '/^[^\\t].+?:.*?##/ {\\\n\tgsub(/\\$$\\(LLVM_BUILDDIR\\)/, \"$(LLVM_BUILDDIR)\"); \\\n        printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$NF \\\n        }' $(MAKEFILE_LIST)\n#.DEFAULT_GOAL=help\n"
        },
        {
          "name": "GOVERNANCE.md",
          "type": "blob",
          "size": 1.4423828125,
          "content": "TinyGo Team Members\n===================\n\nThe team of humans who maintain TinyGo.\n\n*   **Purpose**: To maintain the community, code, documentation, and tools for the TinyGo compiler.\n*   **Board**: The group of people who share responsibility for key decisions for the TinyGo organization.  \n    *   **Majority Voting**: The board makes decisions by majority vote.\n    *   **Membership**: The board elects its own members.\n*   **Do-ocracy**: Those who step forward to do a given task propose how it should be done. Then other interested people can make comments.\n*   **Proof of Work**: Power in decision-making is slightly weighted based on a participant's labor for the community.\n*   **Initiation**: We need to establish a procedure for how people join the team of maintainers.\n*   **Transparency**: Important information should be made publicly available, ideally in a way that allows for public comment.\n*   **Code of Conduct**: Participants agree to abide by the current project Code of Conduct.\n\n## Members\n\n* Ayke van Laethem (@aykevl)\n* Daniel Esteban (@conejoninja)\n* Ron Evans (@deadprogram)\n* Damian Gryski (@dgryski)\n* Masaaki Takasago (@sago35)\n* Patricio Whittingslow (@soypat)\n* Yurii Soldak (@ysoldak)\n\n## Experimental\n\n*   **Monthly Meeting**: A monthly meeting for the team and any other interested participants.  \n    Duration: 1 hour  \n    Facilitation: @deadprogram\n    Schedule: See https://github.com/tinygo-org/tinygo/wiki/Meetings for more information\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.724609375,
          "content": "Copyright (c) 2018-2023 The TinyGo Authors. All rights reserved.\n\nTinyGo includes portions of the Go standard library.\nCopyright (c) 2009-2023 The Go Authors. All rights reserved.\n\nTinyGo includes portions of LLVM, which is under the Apache License v2.0 with\nLLVM Exceptions. See https://llvm.org/LICENSE.txt for license information.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of the copyright holder nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.642578125,
          "content": "# TinyGo - Go compiler for small places\n\n[![Linux](https://github.com/tinygo-org/tinygo/actions/workflows/linux.yml/badge.svg?branch=dev)](https://github.com/tinygo-org/tinygo/actions/workflows/linux.yml) [![macOS](https://github.com/tinygo-org/tinygo/actions/workflows/build-macos.yml/badge.svg?branch=dev)](https://github.com/tinygo-org/tinygo/actions/workflows/build-macos.yml) [![Windows](https://github.com/tinygo-org/tinygo/actions/workflows/windows.yml/badge.svg?branch=dev)](https://github.com/tinygo-org/tinygo/actions/workflows/windows.yml) [![Docker](https://github.com/tinygo-org/tinygo/actions/workflows/docker.yml/badge.svg?branch=dev)](https://github.com/tinygo-org/tinygo/actions/workflows/docker.yml) [![Nix](https://github.com/tinygo-org/tinygo/actions/workflows/nix.yml/badge.svg?branch=dev)](https://github.com/tinygo-org/tinygo/actions/workflows/nix.yml) [![CircleCI](https://circleci.com/gh/tinygo-org/tinygo/tree/dev.svg?style=svg)](https://circleci.com/gh/tinygo-org/tinygo/tree/dev)\n\nTinyGo is a Go compiler intended for use in small places such as microcontrollers, WebAssembly (wasm/wasi), and command-line tools.\n\nIt reuses libraries used by the [Go language tools](https://golang.org/pkg/go/) alongside [LLVM](http://llvm.org) to provide an alternative way to compile programs written in the Go programming language.\n\n## Embedded\n\nHere is an example program that blinks the built-in LED when run directly on any supported board with onboard LED:\n\n```go\npackage main\n\nimport (\n    \"machine\"\n    \"time\"\n)\n\nfunc main() {\n    led := machine.LED\n    led.Configure(machine.PinConfig{Mode: machine.PinOutput})\n    for {\n        led.Low()\n        time.Sleep(time.Millisecond * 1000)\n\n        led.High()\n        time.Sleep(time.Millisecond * 1000)\n    }\n}\n```\n\nThe above program can be compiled and run without modification on an Arduino Uno, an Adafruit ItsyBitsy M0, or any of the supported boards that have a built-in LED, just by setting the correct TinyGo compiler target. For example, this compiles and flashes an Arduino Uno:\n\n```shell\ntinygo flash -target arduino examples/blinky1\n```\n\n## WebAssembly\n\nTinyGo is very useful for compiling programs both for use in browsers (WASM) as well as for use on servers and other edge devices (WASI).\n\nTinyGo programs can run in [Fastly Compute](https://www.fastly.com/documentation/guides/compute/go/), [Fermyon Spin](https://developer.fermyon.com/spin/go-components), [wazero](https://wazero.io/languages/tinygo/) and many other WebAssembly runtimes.\n\nHere is a small TinyGo program for use by a WASI host application:\n\n```go\npackage main\n\n//go:wasm-module yourmodulename\n//export add\nfunc add(x, y uint32) uint32 {\n\treturn x + y\n}\n\n// main is required for the `wasip1` target, even if it isn't used.\nfunc main() {}\n```\n\nThis compiles the above TinyGo program for use on any WASI runtime:\n\n```shell\ntinygo build -o main.wasm -target=wasip1 main.go\n```\n\n## Installation\n\nSee the [getting started instructions](https://tinygo.org/getting-started/) for information on how to install TinyGo, as well as how to run the TinyGo compiler using our Docker container.\n\n## Supported targets\n\n### Embedded\n\nYou can compile TinyGo programs for over 94 different microcontroller boards.\n\nFor more information, please see https://tinygo.org/docs/reference/microcontrollers/\n\n### WebAssembly\n\nTinyGo programs can be compiled for both WASM and WASI targets.\n\nFor more information, see https://tinygo.org/docs/guides/webassembly/\n\n### Operating Systems\n\nYou can also compile programs for Linux, macOS, and Windows targets.\n\nFor more information:\n\n- Linux https://tinygo.org/docs/guides/linux/\n\n- macOS https://tinygo.org/docs/guides/macos/\n\n- Windows https://tinygo.org/docs/guides/windows/\n\n## Currently supported features:\n\nFor a description of currently supported Go language features, please see [https://tinygo.org/lang-support/](https://tinygo.org/lang-support/).\n\n## Documentation\n\nDocumentation is located on our web site at [https://tinygo.org/](https://tinygo.org/).\n\nYou can find the web site code at [https://github.com/tinygo-org/tinygo-site](https://github.com/tinygo-org/tinygo-site).\n\n## Getting help\n\nIf you're looking for a more interactive way to discuss TinyGo usage or\ndevelopment, we have a [#TinyGo channel](https://gophers.slack.com/messages/CDJD3SUP6/)\non the [Gophers Slack](https://gophers.slack.com).\n\nIf you need an invitation for the Gophers Slack, you can generate one here which\nshould arrive fairly quickly (under 1 min): https://invite.slack.golangbridge.org\n\n## Contributing\n\nYour contributions are welcome!\n\nPlease take a look at our [Contributing](https://tinygo.org/docs/guides/contributing/) page on our web site for details.\n\n## Project Scope\n\nGoals:\n\n* Have very small binary sizes. Don't pay for what you don't use.\n* Support for most common microcontroller boards.\n* Be usable on the web using WebAssembly.\n* Good CGo support, with no more overhead than a regular function call.\n* Support most standard library packages and compile most Go code without modification.\n\nNon-goals:\n\n* Be efficient while using zillions of goroutines. However, good goroutine support is certainly a goal.\n* Be as fast as `gc`. However, LLVM will probably be better at optimizing certain things so TinyGo might actually turn out to be faster for number crunching.\n* Be able to compile every Go program out there.\n\n## Why this project exists\n\n> We never expected Go to be an embedded language and so its got serious problems...\n\n-- Rob Pike, [GopherCon 2014 Opening Keynote](https://www.youtube.com/watch?v=VoS7DsT1rdM&feature=youtu.be&t=2799)\n\nTinyGo is a project to bring Go to microcontrollers and small systems with a single processor core. It is similar to [emgo](https://github.com/ziutek/emgo) but a major difference is that we want to keep the Go memory model (which implies garbage collection of some sort). Another difference is that TinyGo uses LLVM internally instead of emitting C, which hopefully leads to smaller and more efficient code and certainly leads to more flexibility.\n\nThe original reasoning was: if [Python](https://micropython.org/) can run on microcontrollers, then certainly [Go](https://golang.org/) should be able to run on even lower level micros.\n\n## License\n\nThis project is licensed under the BSD 3-clause license, just like the [Go project](https://golang.org/LICENSE) itself.\n\nSome code has been copied from the LLVM project and is therefore licensed under [a variant of the Apache 2.0 license](http://releases.llvm.org/11.0.0/LICENSE.TXT). This has been clearly indicated in the header of these files.\n\nSome code has been copied and/or ported from Paul Stoffregen's Teensy libraries and is therefore licensed under PJRC's license. This has been clearly indicated in the header of these files.\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "builder",
          "type": "tree",
          "content": null
        },
        {
          "name": "cgo",
          "type": "tree",
          "content": null
        },
        {
          "name": "colorwriter.go",
          "type": "blob",
          "size": 0.7998046875,
          "content": "package main\n\nimport (\n\t\"io\"\n)\n\n// ANSI escape codes for terminal colors.\nconst (\n\tTermColorReset  = \"\\x1b[0m\"\n\tTermColorYellow = \"\\x1b[93m\"\n)\n\n// ColorWriter wraps an io.Writer but adds a prefix and a terminal color.\ntype ColorWriter struct {\n\tOut    io.Writer\n\tColor  string\n\tPrefix string\n\tline   []byte\n}\n\n// Write implements io.Writer, but with an added prefix and terminal color.\nfunc (w *ColorWriter) Write(p []byte) (n int, err error) {\n\tfor _, c := range p {\n\t\tif c == '\\n' {\n\t\t\tw.line = append(w.line, []byte(TermColorReset)...)\n\t\t\tw.line = append(w.line, '\\n')\n\t\t\t// Write this line.\n\t\t\t_, err := w.Out.Write(w.line)\n\t\t\tw.line = w.line[:0]\n\t\t\tw.line = append(w.line, []byte(w.Color+w.Prefix)...)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t} else {\n\t\t\tw.line = append(w.line, c)\n\t\t}\n\t}\n\treturn len(p), nil\n}\n"
        },
        {
          "name": "compileopts",
          "type": "tree",
          "content": null
        },
        {
          "name": "compiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "corpus_test.go",
          "type": "blob",
          "size": 3.943359375,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"golang.org/x/tools/go/buildutil\"\n\tyaml \"gopkg.in/yaml.v2\"\n)\n\n/*\nThis contains code from https://github.com/dgryski/tinygo-test-corpus\n\nThe MIT License (MIT)\n\nCopyright (c) 2020 Damian Gryski <damian@gryski.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar corpus = flag.String(\"corpus\", \"\", \"path to test corpus\")\n\nfunc TestCorpus(t *testing.T) {\n\tt.Parallel()\n\tif *corpus == \"\" {\n\t\tt.Skip()\n\t}\n\n\tvar target string\n\tif *testTarget != \"\" {\n\t\ttarget = *testTarget\n\t}\n\tisWASI := strings.HasPrefix(target, \"wasi\")\n\n\trepos, err := loadRepos(*corpus)\n\tif err != nil {\n\t\tt.Fatalf(\"loading corpus: %v\", err)\n\t}\n\n\tfor _, repo := range repos {\n\t\trepo := repo\n\t\tname := repo.Repo\n\t\tif repo.Tags != \"\" {\n\t\t\tname += \"(\" + strings.ReplaceAll(repo.Tags, \" \", \"-\") + \")\"\n\t\t}\n\t\tif repo.Version != \"\" {\n\t\t\tname += \"@\" + repo.Version\n\t\t}\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tif isWASI && repo.SkipWASI {\n\t\t\t\tt.Skip(\"skip wasi\")\n\t\t\t}\n\t\t\tif repo.Slow && testing.Short() {\n\t\t\t\tt.Skip(\"slow test\")\n\t\t\t}\n\n\t\t\tvar wg sync.WaitGroup\n\t\t\tdefer wg.Wait()\n\t\t\tout := ioLogger(t, &wg)\n\t\t\tdefer out.Close()\n\n\t\t\tdir := t.TempDir()\n\t\t\tcmd := exec.Command(\"go\", \"mod\", \"init\", \"github.com/tinygo/tinygo-corpus-test\")\n\t\t\tcmd.Dir = dir\n\t\t\tcmd.Stdout, cmd.Stderr = out, out\n\t\t\terr := cmd.Run()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to init: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar ver string\n\t\t\tif repo.Version != \"\" {\n\t\t\t\tver = \"@\" + repo.Version\n\t\t\t}\n\t\t\tcmd = exec.Command(\"go\", \"get\", \"-t\", \"-d\", repo.Repo+\"/...\"+ver)\n\t\t\tcmd.Dir = dir\n\t\t\tcmd.Stdout, cmd.Stderr = out, out\n\t\t\terr = cmd.Run()\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"failed to get: %s\", err.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdoTest := func(t *testing.T, path string) {\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\tdefer wg.Wait()\n\t\t\t\tout := ioLogger(t, &wg)\n\t\t\t\tdefer out.Close()\n\n\t\t\t\topts := optionsFromTarget(target, sema)\n\t\t\t\topts.Directory = dir\n\t\t\t\tvar tags buildutil.TagsFlag\n\t\t\t\ttags.Set(repo.Tags)\n\t\t\t\topts.Tags = []string(tags)\n\t\t\t\topts.TestConfig.Verbose = testing.Verbose()\n\n\t\t\t\tpassed, err := Test(path, out, out, &opts, \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"test error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif !passed {\n\t\t\t\t\tt.Error(\"test failed\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(repo.Subdirs) == 0 {\n\t\t\t\tdoTest(t, repo.Repo)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfor _, dir := range repo.Subdirs {\n\t\t\t\tdir := dir\n\t\t\t\tt.Run(dir.Pkg, func(t *testing.T) {\n\t\t\t\t\tt.Parallel()\n\n\t\t\t\t\tif isWASI && dir.SkipWASI {\n\t\t\t\t\t\tt.Skip(\"skip wasi\")\n\t\t\t\t\t}\n\t\t\t\t\tif dir.Slow && testing.Short() {\n\t\t\t\t\t\tt.Skip(\"slow test\")\n\t\t\t\t\t}\n\n\t\t\t\t\tdoTest(t, repo.Repo+\"/\"+dir.Pkg)\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype T struct {\n\tRepo     string\n\tTags     string\n\tSubdirs  []Subdir\n\tSkipWASI bool\n\tSlow     bool\n\tVersion  string\n}\n\ntype Subdir struct {\n\tPkg      string\n\tSkipWASI bool\n\tSlow     bool\n}\n\nfunc loadRepos(f string) ([]T, error) {\n\n\tyf, err := os.ReadFile(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar repos []T\n\terr = yaml.Unmarshal(yf, &repos)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn repos, nil\n}\n"
        },
        {
          "name": "diagnostics",
          "type": "tree",
          "content": null
        },
        {
          "name": "diff.go",
          "type": "blob",
          "size": 7.544921875,
          "content": "// Copyright 2022 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// A pair is a pair of values tracked for both the x and y side of a diff.\n// It is typically a pair of line indexes.\ntype pair struct{ x, y int }\n\n// Diff returns an anchored diff of the two texts old and new\n// in the “unified diff” format. If old and new are identical,\n// Diff returns a nil slice (no output).\n//\n// Unix diff implementations typically look for a diff with\n// the smallest number of lines inserted and removed,\n// which can in the worst case take time quadratic in the\n// number of lines in the texts. As a result, many implementations\n// either can be made to run for a long time or cut off the search\n// after a predetermined amount of work.\n//\n// In contrast, this implementation looks for a diff with the\n// smallest number of “unique” lines inserted and removed,\n// where unique means a line that appears just once in both old and new.\n// We call this an “anchored diff” because the unique lines anchor\n// the chosen matching regions. An anchored diff is usually clearer\n// than a standard diff, because the algorithm does not try to\n// reuse unrelated blank lines or closing braces.\n// The algorithm also guarantees to run in O(n log n) time\n// instead of the standard O(n²) time.\n//\n// Some systems call this approach a “patience diff,” named for\n// the “patience sorting” algorithm, itself named for a solitaire card game.\n// We avoid that name for two reasons. First, the name has been used\n// for a few different variants of the algorithm, so it is imprecise.\n// Second, the name is frequently interpreted as meaning that you have\n// to wait longer (to be patient) for the diff, meaning that it is a slower algorithm,\n// when in fact the algorithm is faster than the standard one.\nfunc Diff(oldName string, old []byte, newName string, new []byte) []byte {\n\tif bytes.Equal(old, new) {\n\t\treturn nil\n\t}\n\tx := lines(old)\n\ty := lines(new)\n\n\t// Print diff header.\n\tvar out bytes.Buffer\n\tfmt.Fprintf(&out, \"diff %s %s\\n\", oldName, newName)\n\tfmt.Fprintf(&out, \"--- %s\\n\", oldName)\n\tfmt.Fprintf(&out, \"+++ %s\\n\", newName)\n\n\t// Loop over matches to consider,\n\t// expanding each match to include surrounding lines,\n\t// and then printing diff chunks.\n\t// To avoid setup/teardown cases outside the loop,\n\t// tgs returns a leading {0,0} and trailing {len(x), len(y)} pair\n\t// in the sequence of matches.\n\tvar (\n\t\tdone  pair     // printed up to x[:done.x] and y[:done.y]\n\t\tchunk pair     // start lines of current chunk\n\t\tcount pair     // number of lines from each side in current chunk\n\t\tctext []string // lines for current chunk\n\t)\n\tfor _, m := range tgs(x, y) {\n\t\tif m.x < done.x {\n\t\t\t// Already handled scanning forward from earlier match.\n\t\t\tcontinue\n\t\t}\n\n\t\t// Expand matching lines as far as possible,\n\t\t// establishing that x[start.x:end.x] == y[start.y:end.y].\n\t\t// Note that on the first (or last) iteration we may (or definitely do)\n\t\t// have an empty match: start.x==end.x and start.y==end.y.\n\t\tstart := m\n\t\tfor start.x > done.x && start.y > done.y && x[start.x-1] == y[start.y-1] {\n\t\t\tstart.x--\n\t\t\tstart.y--\n\t\t}\n\t\tend := m\n\t\tfor end.x < len(x) && end.y < len(y) && x[end.x] == y[end.y] {\n\t\t\tend.x++\n\t\t\tend.y++\n\t\t}\n\n\t\t// Emit the mismatched lines before start into this chunk.\n\t\t// (No effect on first sentinel iteration, when start = {0,0}.)\n\t\tfor _, s := range x[done.x:start.x] {\n\t\t\tctext = append(ctext, \"-\"+s)\n\t\t\tcount.x++\n\t\t}\n\t\tfor _, s := range y[done.y:start.y] {\n\t\t\tctext = append(ctext, \"+\"+s)\n\t\t\tcount.y++\n\t\t}\n\n\t\t// If we're not at EOF and have too few common lines,\n\t\t// the chunk includes all the common lines and continues.\n\t\tconst C = 3 // number of context lines\n\t\tif (end.x < len(x) || end.y < len(y)) &&\n\t\t\t(end.x-start.x < C || (len(ctext) > 0 && end.x-start.x < 2*C)) {\n\t\t\tfor _, s := range x[start.x:end.x] {\n\t\t\t\tctext = append(ctext, \" \"+s)\n\t\t\t\tcount.x++\n\t\t\t\tcount.y++\n\t\t\t}\n\t\t\tdone = end\n\t\t\tcontinue\n\t\t}\n\n\t\t// End chunk with common lines for context.\n\t\tif len(ctext) > 0 {\n\t\t\tn := end.x - start.x\n\t\t\tif n > C {\n\t\t\t\tn = C\n\t\t\t}\n\t\t\tfor _, s := range x[start.x : start.x+n] {\n\t\t\t\tctext = append(ctext, \" \"+s)\n\t\t\t\tcount.x++\n\t\t\t\tcount.y++\n\t\t\t}\n\t\t\tdone = pair{start.x + n, start.y + n}\n\n\t\t\t// Format and emit chunk.\n\t\t\t// Convert line numbers to 1-indexed.\n\t\t\t// Special case: empty file shows up as 0,0 not 1,0.\n\t\t\tif count.x > 0 {\n\t\t\t\tchunk.x++\n\t\t\t}\n\t\t\tif count.y > 0 {\n\t\t\t\tchunk.y++\n\t\t\t}\n\t\t\tfmt.Fprintf(&out, \"@@ -%d,%d +%d,%d @@\\n\", chunk.x, count.x, chunk.y, count.y)\n\t\t\tfor _, s := range ctext {\n\t\t\t\tout.WriteString(s)\n\t\t\t}\n\t\t\tcount.x = 0\n\t\t\tcount.y = 0\n\t\t\tctext = ctext[:0]\n\t\t}\n\n\t\t// If we reached EOF, we're done.\n\t\tif end.x >= len(x) && end.y >= len(y) {\n\t\t\tbreak\n\t\t}\n\n\t\t// Otherwise start a new chunk.\n\t\tchunk = pair{end.x - C, end.y - C}\n\t\tfor _, s := range x[chunk.x:end.x] {\n\t\t\tctext = append(ctext, \" \"+s)\n\t\t\tcount.x++\n\t\t\tcount.y++\n\t\t}\n\t\tdone = end\n\t}\n\n\treturn out.Bytes()\n}\n\n// lines returns the lines in the file x, including newlines.\n// If the file does not end in a newline, one is supplied\n// along with a warning about the missing newline.\nfunc lines(x []byte) []string {\n\tl := strings.SplitAfter(string(x), \"\\n\")\n\tif l[len(l)-1] == \"\" {\n\t\tl = l[:len(l)-1]\n\t} else {\n\t\t// Treat last line as having a message about the missing newline attached,\n\t\t// using the same text as BSD/GNU diff (including the leading backslash).\n\t\tl[len(l)-1] += \"\\n\\\\ No newline at end of file\\n\"\n\t}\n\treturn l\n}\n\n// tgs returns the pairs of indexes of the longest common subsequence\n// of unique lines in x and y, where a unique line is one that appears\n// once in x and once in y.\n//\n// The longest common subsequence algorithm is as described in\n// Thomas G. Szymanski, “A Special Case of the Maximal Common\n// Subsequence Problem,” Princeton TR #170 (January 1975),\n// available at https://research.swtch.com/tgs170.pdf.\nfunc tgs(x, y []string) []pair {\n\t// Count the number of times each string appears in a and b.\n\t// We only care about 0, 1, many, counted as 0, -1, -2\n\t// for the x side and 0, -4, -8 for the y side.\n\t// Using negative numbers now lets us distinguish positive line numbers later.\n\tm := make(map[string]int)\n\tfor _, s := range x {\n\t\tif c := m[s]; c > -2 {\n\t\t\tm[s] = c - 1\n\t\t}\n\t}\n\tfor _, s := range y {\n\t\tif c := m[s]; c > -8 {\n\t\t\tm[s] = c - 4\n\t\t}\n\t}\n\n\t// Now unique strings can be identified by m[s] = -1+-4.\n\t//\n\t// Gather the indexes of those strings in x and y, building:\n\t//\txi[i] = increasing indexes of unique strings in x.\n\t//\tyi[i] = increasing indexes of unique strings in y.\n\t//\tinv[i] = index j such that x[xi[i]] = y[yi[j]].\n\tvar xi, yi, inv []int\n\tfor i, s := range y {\n\t\tif m[s] == -1+-4 {\n\t\t\tm[s] = len(yi)\n\t\t\tyi = append(yi, i)\n\t\t}\n\t}\n\tfor i, s := range x {\n\t\tif j, ok := m[s]; ok && j >= 0 {\n\t\t\txi = append(xi, i)\n\t\t\tinv = append(inv, j)\n\t\t}\n\t}\n\n\t// Apply Algorithm A from Szymanski's paper.\n\t// In those terms, A = J = inv and B = [0, n).\n\t// We add sentinel pairs {0,0}, and {len(x),len(y)}\n\t// to the returned sequence, to help the processing loop.\n\tJ := inv\n\tn := len(xi)\n\tT := make([]int, n)\n\tL := make([]int, n)\n\tfor i := range T {\n\t\tT[i] = n + 1\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tk := sort.Search(n, func(k int) bool {\n\t\t\treturn T[k] >= J[i]\n\t\t})\n\t\tT[k] = J[i]\n\t\tL[i] = k + 1\n\t}\n\tk := 0\n\tfor _, v := range L {\n\t\tif k < v {\n\t\t\tk = v\n\t\t}\n\t}\n\tseq := make([]pair, 2+k)\n\tseq[1+k] = pair{len(x), len(y)} // sentinel at end\n\tlastj := n\n\tfor i := n - 1; i >= 0; i-- {\n\t\tif L[i] == k && J[i] < lastj {\n\t\t\tseq[k] = pair{xi[i], yi[J[i]]}\n\t\t\tk--\n\t\t}\n\t}\n\tseq[0] = pair{0, 0} // sentinel at start\n\treturn seq\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 3.888671875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/tinygo-org/tinygo/compileopts\"\n\t\"github.com/tinygo-org/tinygo/diagnostics\"\n)\n\n// Test the error messages of the TinyGo compiler.\nfunc TestErrors(t *testing.T) {\n\t// TODO: nicely formatted error messages for:\n\t//   - duplicate symbols in ld.lld (currently only prints bitcode file)\n\ttype errorTest struct {\n\t\tname   string\n\t\ttarget string\n\t}\n\tfor _, tc := range []errorTest{\n\t\t{name: \"cgo\"},\n\t\t{name: \"compiler\"},\n\t\t{name: \"interp\"},\n\t\t{name: \"invalidmain\"},\n\t\t{name: \"invalidname\"},\n\t\t{name: \"linker-flashoverflow\", target: \"cortex-m-qemu\"},\n\t\t{name: \"linker-ramoverflow\", target: \"cortex-m-qemu\"},\n\t\t{name: \"linker-undefined\", target: \"darwin/arm64\"},\n\t\t{name: \"linker-undefined\", target: \"linux/amd64\"},\n\t\t//{name: \"linker-undefined\", target: \"windows/amd64\"}, // TODO: no source location\n\t\t{name: \"linker-undefined\", target: \"cortex-m-qemu\"},\n\t\t//{name: \"linker-undefined\", target: \"wasip1\"}, // TODO: no source location\n\t\t{name: \"loader-importcycle\"},\n\t\t{name: \"loader-invaliddep\"},\n\t\t{name: \"loader-invalidpackage\"},\n\t\t{name: \"loader-nopackage\"},\n\t\t{name: \"optimizer\"},\n\t\t{name: \"syntax\"},\n\t\t{name: \"types\"},\n\t} {\n\t\tname := tc.name\n\t\tif tc.target != \"\" {\n\t\t\tname += \"#\" + tc.target\n\t\t}\n\t\ttarget := tc.target\n\t\tif target == \"\" {\n\t\t\ttarget = \"wasip1\"\n\t\t}\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\toptions := optionsFromTarget(target, sema)\n\t\t\ttestErrorMessages(t, \"./testdata/errors/\"+tc.name+\".go\", &options)\n\t\t})\n\t}\n}\n\nfunc testErrorMessages(t *testing.T, filename string, options *compileopts.Options) {\n\tt.Parallel()\n\n\t// Parse expected error messages.\n\texpected := readErrorMessages(t, filename)\n\n\t// Try to build a binary (this should fail with an error).\n\ttmpdir := t.TempDir()\n\terr := Build(filename, tmpdir+\"/out\", options)\n\tif err == nil {\n\t\tt.Fatal(\"expected to get a compiler error\")\n\t}\n\n\t// Get the full ./testdata/errors directory.\n\twd, absErr := filepath.Abs(\"testdata/errors\")\n\tif absErr != nil {\n\t\tt.Fatal(absErr)\n\t}\n\n\t// Write error message out as plain text.\n\tvar buf bytes.Buffer\n\tdiagnostics.CreateDiagnostics(err).WriteTo(&buf, wd)\n\tactual := strings.TrimRight(buf.String(), \"\\n\")\n\n\t// Check whether the error is as expected.\n\tif !matchErrors(t, expected, actual) {\n\t\tt.Errorf(\"expected error:\\n%s\\ngot:\\n%s\", indentText(expected, \"> \"), indentText(actual, \"> \"))\n\t}\n}\n\nfunc matchErrors(t *testing.T, pattern, actual string) bool {\n\tpatternLines := strings.Split(pattern, \"\\n\")\n\tactualLines := strings.Split(actual, \"\\n\")\n\tif len(patternLines) != len(actualLines) {\n\t\treturn false\n\t}\n\tfor i, patternLine := range patternLines {\n\t\tindices := regexp.MustCompile(`\\{\\{.*?\\}\\}`).FindAllStringIndex(patternLine, -1)\n\t\tpatternParts := []string{\"^\"}\n\t\tlastStop := 0\n\t\tfor _, startstop := range indices {\n\t\t\tstart := startstop[0]\n\t\t\tstop := startstop[1]\n\t\t\tpatternParts = append(patternParts,\n\t\t\t\tregexp.QuoteMeta(patternLine[lastStop:start]),\n\t\t\t\tpatternLine[start+2:stop-2])\n\t\t\tlastStop = stop\n\t\t}\n\t\tpatternParts = append(patternParts, regexp.QuoteMeta(patternLine[lastStop:]), \"$\")\n\t\tpattern := strings.Join(patternParts, \"\")\n\t\tre, err := regexp.Compile(pattern)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not compile regexp for %#v: %v\", patternLine, err)\n\t\t}\n\t\tif !re.MatchString(actualLines[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Indent the given text with a given indentation string.\nfunc indentText(text, indent string) string {\n\treturn indent + strings.ReplaceAll(text, \"\\n\", \"\\n\"+indent)\n}\n\n// Read \"// ERROR:\" prefixed messages from the given file.\nfunc readErrorMessages(t *testing.T, file string) string {\n\tdata, err := os.ReadFile(file)\n\tif err != nil {\n\t\tt.Fatal(\"could not read input file:\", err)\n\t}\n\n\tvar errors []string\n\tfor _, line := range strings.Split(string(data), \"\\n\") {\n\t\tif strings.HasPrefix(line, \"// ERROR: \") {\n\t\t\terrors = append(errors, strings.TrimRight(line[len(\"// ERROR: \"):], \"\\r\\n\"))\n\t\t}\n\t}\n\treturn strings.Join(errors, \"\\n\")\n}\n"
        },
        {
          "name": "flake.lock",
          "type": "blob",
          "size": 1.43359375,
          "content": "{\n  \"nodes\": {\n    \"flake-utils\": {\n      \"inputs\": {\n        \"systems\": \"systems\"\n      },\n      \"locked\": {\n        \"lastModified\": 1694529238,\n        \"narHash\": \"sha256-zsNZZGTGnMOf9YpHKJqMSsa0dXbfmxeoJ7xHlrt+xmY=\",\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"rev\": \"ff7b65b44d01cf9ba6a71320833626af21126384\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"numtide\",\n        \"repo\": \"flake-utils\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1728500571,\n        \"narHash\": \"sha256-dOymOQ3AfNI4Z337yEwHGohrVQb4yPODCW9MDUyAc4w=\",\n        \"owner\": \"NixOS\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"d51c28603def282a24fa034bcb007e2bcb5b5dd0\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"id\": \"nixpkgs\",\n        \"ref\": \"nixos-24.05\",\n        \"type\": \"indirect\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"flake-utils\": \"flake-utils\",\n        \"nixpkgs\": \"nixpkgs\"\n      }\n    },\n    \"systems\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"
        },
        {
          "name": "flake.nix",
          "type": "blob",
          "size": 3.2880859375,
          "content": "# A Nix flake file, mainly intended for developing TinyGo.\n# You can download Nix here, for use on your Linux or macOS system:\n#   https://nixos.org/download.html\n# After you have installed Nix, you can enter the development environment as\n# follows:\n#\n#   nix develop\n#\n# This drops you into a bash shell, where you can install TinyGo simply using\n# the following command:\n#\n#   go install\n#\n# That's all! Assuming you've set up your $PATH correctly, you can now use the\n# tinygo command as usual:\n#\n#   tinygo version\n#\n# But you'll need a bit more to make TinyGo actually able to compile code:\n#\n#   make llvm-source            # fetch compiler-rt\n#   git submodule update --init # fetch lots of other libraries and SVD files\n#   make gen-device -j4         # build src/device/*/*.go files\n#   make wasi-libc              # build support for wasi/wasm\n#\n# With this, you should have an environment that can compile anything - except\n# for the Xtensa architecture (ESP8266/ESP32) because support for that lives in\n# a separate LLVM fork.\n#\n# You can also do many other things from this environment. Building and flashing\n# should work as you're used to: it's not a VM or container so there are no\n# access restrictions and you're running in the same host environment - just\n# with a slightly different set of tools available.\n{\n  inputs = {\n    # Use a recent stable release, but fix the version to make it reproducible.\n    # This version should be updated from time to time.\n    nixpkgs.url = \"nixpkgs/nixos-24.05\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n  };\n  outputs = { self, nixpkgs, flake-utils }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let\n        pkgs = nixpkgs.legacyPackages.${system};\n      in\n      with pkgs;\n      {\n        devShells.default = mkShell {\n          buildInputs = [\n            # These dependencies are required for building tinygo (go install).\n            go\n            llvmPackages_18.llvm\n            llvmPackages_18.libclang\n            # Additional dependencies needed at runtime, for building and/or\n            # flashing.\n            llvmPackages_18.lld\n            avrdude\n            binaryen\n            # Additional dependencies needed for on-chip debugging.\n            # These tools are rather big (especially GDB) and not frequently\n            # used, so are commented out. On-chip debugging is still possible if\n            # these tools are available in the host environment.\n            #gdb\n            #openocd\n          ];\n          shellHook= ''\n            # Configure CLANG, LLVM_AR, and LLVM_NM for `make wasi-libc`.\n            # Without setting these explicitly, Homebrew versions might be used\n            # or the default `ar` and `nm` tools might be used (which don't\n            # support wasi).\n            export CLANG=\"clang-18 -resource-dir ${llvmPackages_18.clang.cc.lib}/lib/clang/18\"\n            export LLVM_AR=llvm-ar\n            export LLVM_NM=llvm-nm\n\n            # Make `make smoketest` work (the default is `md5`, while Nix only\n            # has `md5sum`).\n            export MD5SUM=md5sum\n\n            # Ugly hack to make the Clang resources directory available.\n            export GOFLAGS=\"\\\"-ldflags=-X github.com/tinygo-org/tinygo/goenv.clangResourceDir=${llvmPackages_18.clang.cc.lib}/lib/clang/18\\\" -tags=llvm18\"\n          '';\n        };\n      }\n    );\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.3291015625,
          "content": "module github.com/tinygo-org/tinygo\n\ngo 1.19\n\nrequire (\n\tgithub.com/aykevl/go-wasm v0.0.2-0.20240312204833-50275154210c\n\tgithub.com/blakesmith/ar v0.0.0-20150311145944-8bd4349a67f2\n\tgithub.com/chromedp/cdproto v0.0.0-20220113222801-0725d94bb6ee\n\tgithub.com/chromedp/chromedp v0.7.6\n\tgithub.com/gofrs/flock v0.8.1\n\tgithub.com/google/shlex v0.0.0-20181106134648-c34317bd91bf\n\tgithub.com/inhies/go-bytesize v0.0.0-20220417184213-4913239db9cf\n\tgithub.com/marcinbor85/gohex v0.0.0-20200531091804-343a4b548892\n\tgithub.com/mattn/go-colorable v0.1.13\n\tgithub.com/mattn/go-tty v0.0.4\n\tgithub.com/sigurn/crc16 v0.0.0-20211026045750-20ab5afb07e3\n\tgithub.com/tetratelabs/wazero v1.6.0\n\tgo.bug.st/serial v1.6.0\n\tgolang.org/x/net v0.26.0\n\tgolang.org/x/sys v0.21.0\n\tgolang.org/x/tools v0.22.1-0.20240621165957-db513b091504\n\tgopkg.in/yaml.v2 v2.4.0\n\ttinygo.org/x/go-llvm v0.0.0-20240627184919-3b50c76783a8\n)\n\nrequire (\n\tgithub.com/chromedp/sysutil v1.0.0 // indirect\n\tgithub.com/creack/goselect v0.1.2 // indirect\n\tgithub.com/gobwas/httphead v0.1.0 // indirect\n\tgithub.com/gobwas/pool v0.2.1 // indirect\n\tgithub.com/gobwas/ws v1.1.0 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/mailru/easyjson v0.7.7 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/stretchr/testify v1.8.4 // indirect\n\tgolang.org/x/text v0.16.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 7.1162109375,
          "content": "github.com/aykevl/go-wasm v0.0.2-0.20240312204833-50275154210c h1:4T0Vj1UkGgcpkRrmn7SbokebnlfxJcMZPgWtOYACAAA=\ngithub.com/aykevl/go-wasm v0.0.2-0.20240312204833-50275154210c/go.mod h1:7sXyiaA0WtSogCu67R2252fQpVmJMh9JWJ9ddtGkpWw=\ngithub.com/blakesmith/ar v0.0.0-20150311145944-8bd4349a67f2 h1:oMCHnXa6CCCafdPDbMh/lWRhRByN0VFLvv+g+ayx1SI=\ngithub.com/blakesmith/ar v0.0.0-20150311145944-8bd4349a67f2/go.mod h1:PkYb9DJNAwrSvRx5DYA+gUcOIgTGVMNkfSCbZM8cWpI=\ngithub.com/chromedp/cdproto v0.0.0-20211126220118-81fa0469ad77/go.mod h1:At5TxYYdxkbQL0TSefRjhLE3Q0lgvqKKMSFUglJ7i1U=\ngithub.com/chromedp/cdproto v0.0.0-20220113222801-0725d94bb6ee h1:+SFdIVfQpG0s0DHYzou0kgfE0n0ZjKPwbiRJsXrZegU=\ngithub.com/chromedp/cdproto v0.0.0-20220113222801-0725d94bb6ee/go.mod h1:At5TxYYdxkbQL0TSefRjhLE3Q0lgvqKKMSFUglJ7i1U=\ngithub.com/chromedp/chromedp v0.7.6 h1:2juGaktzjwULlsn+DnvIZXFUckEp5xs+GOBroaea+jA=\ngithub.com/chromedp/chromedp v0.7.6/go.mod h1:ayT4YU/MGAALNfOg9gNrpGSAdnU51PMx+FCeuT1iXzo=\ngithub.com/chromedp/sysutil v1.0.0 h1:+ZxhTpfpZlmchB58ih/LBHX52ky7w2VhQVKQMucy3Ic=\ngithub.com/chromedp/sysutil v1.0.0/go.mod h1:kgWmDdq8fTzXYcKIBqIYvRRTnYb9aNS9moAV0xufSww=\ngithub.com/creack/goselect v0.1.2 h1:2DNy14+JPjRBgPzAd1thbQp4BSIihxcBf0IXhQXDRa0=\ngithub.com/creack/goselect v0.1.2/go.mod h1:a/NhLweNvqIYMuxcMOuWY516Cimucms3DglDzQP3hKY=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/gobwas/httphead v0.1.0 h1:exrUm0f4YX0L7EBwZHuCF4GDp8aJfVeBrlLQrs6NqWU=\ngithub.com/gobwas/httphead v0.1.0/go.mod h1:O/RXo79gxV8G+RqlR/otEwx4Q36zl9rqC5u12GKvMCM=\ngithub.com/gobwas/pool v0.2.1 h1:xfeeEhW7pwmX8nuLVlqbzVc7udMDrwetjEv+TZIz1og=\ngithub.com/gobwas/pool v0.2.1/go.mod h1:q8bcK0KcYlCgd9e7WYLm9LpyS+YeLd8JVDW6WezmKEw=\ngithub.com/gobwas/ws v1.1.0 h1:7RFti/xnNkMJnrK7D1yQ/iCIB5OrrY/54/H930kIbHA=\ngithub.com/gobwas/ws v1.1.0/go.mod h1:nzvNcVha5eUziGrbxFCo6qFIojQHjJV5cLYIbezhfL0=\ngithub.com/gofrs/flock v0.8.1 h1:+gYjHKf32LDeiEEFhQaotPbLuUXjY5ZqxKgXy7n59aw=\ngithub.com/gofrs/flock v0.8.1/go.mod h1:F1TvTiK9OcQqauNUHlbJvyl9Qa1QvF/gOUDKA14jxHU=\ngithub.com/google/shlex v0.0.0-20181106134648-c34317bd91bf h1:7+FW5aGwISbqUtkfmIpZJGRgNFg2ioYPvFaUxdqpDsg=\ngithub.com/google/shlex v0.0.0-20181106134648-c34317bd91bf/go.mod h1:RpwtwJQFrIEPstU94h88MWPXP2ektJZ8cZ0YntAmXiE=\ngithub.com/inhies/go-bytesize v0.0.0-20220417184213-4913239db9cf h1:FtEj8sfIcaaBfAKrE1Cwb61YDtYq9JxChK1c7AKce7s=\ngithub.com/inhies/go-bytesize v0.0.0-20220417184213-4913239db9cf/go.mod h1:yrqSXGoD/4EKfF26AOGzscPOgTTJcyAwM2rpixWT+t4=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=\ngithub.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/marcinbor85/gohex v0.0.0-20200531091804-343a4b548892 h1:6J+qramlHVLmiBOgRiBOnQkno8uprqG6YFFQTt6uYIw=\ngithub.com/marcinbor85/gohex v0.0.0-20200531091804-343a4b548892/go.mod h1:Pb6XcsXyropB9LNHhnqaknG/vEwYztLkQzVCHv8sQ3M=\ngithub.com/mattn/go-colorable v0.1.4/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.10/go.mod h1:qgIWMr58cqv1PHHyhnkY9lrL7etaEgOFcMEpPG5Rm84=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.7/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-tty v0.0.4 h1:NVikla9X8MN0SQAqCYzpGyXv0jY7MNl3HOWD2dkle7E=\ngithub.com/mattn/go-tty v0.0.4/go.mod h1:u5GGXBtZU6RQoKV8gY5W6UhMudbR5vXnUe7j3pxse28=\ngithub.com/orisano/pixelmatch v0.0.0-20210112091706-4fa4c7ba91d5 h1:1SoBaSPudixRecmlHXb/GxmaD3fLMtHIDN13QujwQuc=\ngithub.com/orisano/pixelmatch v0.0.0-20210112091706-4fa4c7ba91d5/go.mod h1:nZgzbfBr3hhjoZnS66nKrHmduYNpc34ny7RK4z5/HM0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/sigurn/crc16 v0.0.0-20211026045750-20ab5afb07e3 h1:aQKxg3+2p+IFXXg97McgDGT5zcMrQoi0EICZs8Pgchs=\ngithub.com/sigurn/crc16 v0.0.0-20211026045750-20ab5afb07e3/go.mod h1:9/etS5gpQq9BJsJMWg1wpLbfuSnkm8dPF6FdW2JXVhA=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/tetratelabs/wazero v1.6.0 h1:z0H1iikCdP8t+q341xqepY4EWvHEw8Es7tlqiVzlP3g=\ngithub.com/tetratelabs/wazero v1.6.0/go.mod h1:0U0G41+ochRKoPKCJlh0jMg1CHkyfK8kDqiirMmKY8A=\ngo.bug.st/serial v1.6.0 h1:mAbRGN4cKE2J5gMwsMHC2KQisdLRQssO9WSM+rbZJ8A=\ngo.bug.st/serial v1.6.0/go.mod h1:UABfsluHAiaNI+La2iESysd9Vetq7VRdpxvjx7CmmOE=\ngolang.org/x/mod v0.18.0 h1:5+9lSbEzPSdWkH32vYPBwEpX8KwDbM52Ud9xBUvNlb0=\ngolang.org/x/net v0.26.0 h1:soB7SVo0PWrY4vPW/+ay0jKDNScG2X9wFeYlXIvJsOQ=\ngolang.org/x/net v0.26.0/go.mod h1:5YKkiSynbBIh3p6iOc/vibscux0x38BZDkn8sCUPxHE=\ngolang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20191008105621-543471e840be/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201207223542-d4d67f95c62d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20211124211545-fe61309f8881/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.21.0 h1:rF+pYz3DAGSQAxAu1CbC7catZg4ebC4UIeIhKxBZvws=\ngolang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngolang.org/x/tools v0.22.1-0.20240621165957-db513b091504 h1:MMsD8mMfluf/578+3wrTn22pjI/Xkzm+gPW47SYfspY=\ngolang.org/x/tools v0.22.1-0.20240621165957-db513b091504/go.mod h1:aCwcsjqvq7Yqt6TNyX7QMU2enbQ/Gt0bo6krSeEri+c=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ntinygo.org/x/go-llvm v0.0.0-20240627184919-3b50c76783a8 h1:bLsZXRUBavt++CJlMN7sppNziqu3LyamESLhFJcpqFQ=\ntinygo.org/x/go-llvm v0.0.0-20240627184919-3b50c76783a8/go.mod h1:GFbusT2VTA4I+l4j80b17KFK+6whv69Wtny5U+T8RR0=\n"
        },
        {
          "name": "goenv",
          "type": "tree",
          "content": null
        },
        {
          "name": "hooks",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "interp",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "loader",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 63.0634765625,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/pprof\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/google/shlex\"\n\t\"github.com/inhies/go-bytesize\"\n\t\"github.com/mattn/go-colorable\"\n\t\"github.com/tinygo-org/tinygo/builder\"\n\t\"github.com/tinygo-org/tinygo/compileopts\"\n\t\"github.com/tinygo-org/tinygo/diagnostics\"\n\t\"github.com/tinygo-org/tinygo/goenv\"\n\t\"github.com/tinygo-org/tinygo/loader\"\n\t\"golang.org/x/tools/go/buildutil\"\n\t\"tinygo.org/x/go-llvm\"\n\n\t\"go.bug.st/serial\"\n\t\"go.bug.st/serial/enumerator\"\n)\n\n// commandError is an error type to wrap os/exec.Command errors. This provides\n// some more information regarding what went wrong while running a command.\ntype commandError struct {\n\tMsg  string\n\tFile string\n\tErr  error\n}\n\nfunc (e *commandError) Error() string {\n\treturn e.Msg + \" \" + e.File + \": \" + e.Err.Error()\n}\n\n// moveFile renames the file from src to dst. If renaming doesn't work (for\n// example, the rename crosses a filesystem boundary), the file is copied and\n// the old file is removed.\nfunc moveFile(src, dst string) error {\n\terr := os.Rename(src, dst)\n\tif err == nil {\n\t\t// Success!\n\t\treturn nil\n\t}\n\t// Failed to move, probably a different filesystem.\n\t// Do a copy + remove.\n\terr = copyFile(src, dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(src)\n}\n\n// copyFile copies the given file or directory from src to dst. It can copy over\n// a possibly already existing file (but not directory) at the destination.\nfunc copyFile(src, dst string) error {\n\tsource, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer source.Close()\n\n\tst, err := source.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif st.IsDir() {\n\t\terr := os.Mkdir(dst, st.Mode().Perm())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnames, err := source.Readdirnames(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, name := range names {\n\t\t\terr := copyFile(filepath.Join(src, name), filepath.Join(dst, name))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t} else {\n\t\tdestination, err := os.OpenFile(dst, os.O_RDWR|os.O_CREATE|os.O_TRUNC, st.Mode())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer destination.Close()\n\n\t\t_, err = io.Copy(destination, source)\n\t\treturn err\n\t}\n}\n\n// executeCommand is a simple wrapper to exec.Cmd\nfunc executeCommand(options *compileopts.Options, name string, arg ...string) *exec.Cmd {\n\tif options.PrintCommands != nil {\n\t\toptions.PrintCommands(name, arg...)\n\t}\n\treturn exec.Command(name, arg...)\n}\n\n// printCommand prints a command to stdout while formatting it like a real\n// command (escaping characters etc). The resulting command should be easy to\n// run directly in a shell, although it is not guaranteed to be a safe shell\n// escape. That's not a problem as the primary use case is printing the command,\n// not running it.\nfunc printCommand(cmd string, args ...string) {\n\tcommand := append([]string{cmd}, args...)\n\tfor i, arg := range command {\n\t\t// Source: https://www.oreilly.com/library/view/learning-the-bash/1565923472/ch01s09.html\n\t\tconst specialChars = \"~`#$&*()\\\\|[]{};'\\\"<>?! \"\n\t\tif strings.ContainsAny(arg, specialChars) {\n\t\t\t// See: https://stackoverflow.com/questions/15783701/which-characters-need-to-be-escaped-when-using-bash\n\t\t\targ = \"'\" + strings.ReplaceAll(arg, `'`, `'\\''`) + \"'\"\n\t\t\tcommand[i] = arg\n\t\t}\n\t}\n\tfmt.Fprintln(os.Stderr, strings.Join(command, \" \"))\n}\n\n// Build compiles and links the given package and writes it to outpath.\nfunc Build(pkgName, outpath string, options *compileopts.Options) error {\n\tconfig, err := builder.NewConfig(options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif options.PrintJSON {\n\t\tb, err := json.MarshalIndent(config, \"\", \"  \")\n\t\tif err != nil {\n\t\t\thandleCompilerError(err)\n\t\t}\n\t\tfmt.Printf(\"%s\\n\", string(b))\n\t\treturn nil\n\t}\n\n\t// Create a temporary directory for intermediary files.\n\ttmpdir, err := os.MkdirTemp(\"\", \"tinygo\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !options.Work {\n\t\tdefer os.RemoveAll(tmpdir)\n\t}\n\n\t// Do the build.\n\tresult, err := builder.Build(pkgName, outpath, tmpdir, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif result.Binary != \"\" {\n\t\t// If result.Binary is set, it means there is a build output (elf, hex,\n\t\t// etc) that we need to move to the outpath. If it isn't set, it means\n\t\t// the build output was a .ll, .bc or .o file that has already been\n\t\t// written to outpath and so we don't need to do anything.\n\n\t\tif outpath == \"\" {\n\t\t\tif strings.HasSuffix(pkgName, \".go\") {\n\t\t\t\t// A Go file was specified directly on the command line.\n\t\t\t\t// Base the binary name off of it.\n\t\t\t\toutpath = filepath.Base(pkgName[:len(pkgName)-3]) + config.DefaultBinaryExtension()\n\t\t\t} else {\n\t\t\t\t// Pick a default output path based on the main directory.\n\t\t\t\toutpath = filepath.Base(result.MainDir) + config.DefaultBinaryExtension()\n\t\t\t}\n\t\t}\n\n\t\tif err := os.Rename(result.Binary, outpath); err != nil {\n\t\t\t// Moving failed. Do a file copy.\n\t\t\tinf, err := os.Open(result.Binary)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer inf.Close()\n\t\t\toutf, err := os.OpenFile(outpath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0777)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Copy data to output file.\n\t\t\t_, err = io.Copy(outf, inf)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Check whether file writing was successful.\n\t\t\treturn outf.Close()\n\t\t}\n\t}\n\n\t// Move was successful.\n\treturn nil\n}\n\n// Test runs the tests in the given package. Returns whether the test passed and\n// possibly an error if the test failed to run.\nfunc Test(pkgName string, stdout, stderr io.Writer, options *compileopts.Options, outpath string) (bool, error) {\n\toptions.TestConfig.CompileTestBinary = true\n\tconfig, err := builder.NewConfig(options)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\ttestConfig := &options.TestConfig\n\n\t// Pass test flags to the test binary.\n\tvar flags []string\n\tif testConfig.Verbose {\n\t\tflags = append(flags, \"-test.v\")\n\t}\n\tif testConfig.Short {\n\t\tflags = append(flags, \"-test.short\")\n\t}\n\tif testConfig.RunRegexp != \"\" {\n\t\tflags = append(flags, \"-test.run=\"+testConfig.RunRegexp)\n\t}\n\tif testConfig.SkipRegexp != \"\" {\n\t\tflags = append(flags, \"-test.skip=\"+testConfig.SkipRegexp)\n\t}\n\tif testConfig.BenchRegexp != \"\" {\n\t\tflags = append(flags, \"-test.bench=\"+testConfig.BenchRegexp)\n\t}\n\tif testConfig.BenchTime != \"\" {\n\t\tflags = append(flags, \"-test.benchtime=\"+testConfig.BenchTime)\n\t}\n\tif testConfig.BenchMem {\n\t\tflags = append(flags, \"-test.benchmem\")\n\t}\n\tif testConfig.Count != nil && *testConfig.Count != 1 {\n\t\tflags = append(flags, \"-test.count=\"+strconv.Itoa(*testConfig.Count))\n\t}\n\tif testConfig.Shuffle != \"\" {\n\t\tflags = append(flags, \"-test.shuffle=\"+testConfig.Shuffle)\n\t}\n\n\tlogToStdout := testConfig.Verbose || testConfig.BenchRegexp != \"\"\n\n\tvar buf bytes.Buffer\n\tvar output io.Writer = &buf\n\t// Send the test output to stdout if -v or -bench\n\tif logToStdout {\n\t\toutput = os.Stdout\n\t}\n\n\tpassed := false\n\tvar duration time.Duration\n\tresult, err := buildAndRun(pkgName, config, output, flags, nil, 0, func(cmd *exec.Cmd, result builder.BuildResult) error {\n\t\tif testConfig.CompileOnly || outpath != \"\" {\n\t\t\t// Write test binary to the specified file name.\n\t\t\tif outpath == \"\" {\n\t\t\t\t// No -o path was given, so create one now.\n\t\t\t\t// This matches the behavior of go test.\n\t\t\t\toutpath = filepath.Base(result.MainDir) + \".test\"\n\t\t\t}\n\t\t\tcopyFile(result.Binary, outpath)\n\t\t}\n\t\tif testConfig.CompileOnly {\n\t\t\t// Do not run the test.\n\t\t\tpassed = true\n\t\t\treturn nil\n\t\t}\n\n\t\t// Tests are always run in the package directory.\n\t\tcmd.Dir = result.MainDir\n\n\t\t// Run the test.\n\t\tstart := time.Now()\n\t\terr = cmd.Run()\n\t\tduration = time.Since(start)\n\t\tpassed = err == nil\n\n\t\t// if verbose or benchmarks, then output is already going to stdout\n\t\t// However, if we failed and weren't printing to stdout, print the output we accumulated.\n\t\tif !passed && !logToStdout {\n\t\t\tbuf.WriteTo(stdout)\n\t\t}\n\n\t\tif _, ok := err.(*exec.ExitError); ok {\n\t\t\t// Binary exited with a non-zero exit code, which means the test\n\t\t\t// failed. Return nil to avoid printing a useless \"exited with\n\t\t\t// error\" error message.\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t})\n\n\tif testConfig.CompileOnly {\n\t\treturn true, nil\n\t}\n\n\timportPath := strings.TrimSuffix(result.ImportPath, \".test\")\n\n\tvar w io.Writer = stdout\n\tif logToStdout {\n\t\tw = os.Stdout\n\t}\n\tif err, ok := err.(loader.NoTestFilesError); ok {\n\t\tfmt.Fprintf(w, \"?   \\t%s\\t[no test files]\\n\", err.ImportPath)\n\t\t// Pretend the test passed - it at least didn't fail.\n\t\treturn true, nil\n\t} else if passed {\n\t\tfmt.Fprintf(w, \"ok  \\t%s\\t%.3fs\\n\", importPath, duration.Seconds())\n\t} else {\n\t\tfmt.Fprintf(w, \"FAIL\\t%s\\t%.3fs\\n\", importPath, duration.Seconds())\n\t}\n\treturn passed, err\n}\n\nfunc dirsToModuleRootRel(maindir, modroot string) []string {\n\tvar dirs []string\n\tlast := \"..\"\n\t// strip off path elements until we hit the module root\n\t// adding `..`, `../..`, `../../..` until we're done\n\tfor maindir != modroot {\n\t\tdirs = append(dirs, last)\n\t\tlast = filepath.Join(last, \"..\")\n\t\tmaindir = filepath.Dir(maindir)\n\t}\n\tdirs = append(dirs, \".\")\n\treturn dirs\n}\n\nfunc dirsToModuleRootAbs(maindir, modroot string) []string {\n\tvar dirs = []string{maindir}\n\tlast := filepath.Join(maindir, \"..\")\n\t// strip off path elements until we hit the module root\n\t// adding `..`, `../..`, `../../..` until we're done\n\tfor maindir != modroot {\n\t\tdirs = append(dirs, last)\n\t\tlast = filepath.Join(last, \"..\")\n\t\tmaindir = filepath.Dir(maindir)\n\t}\n\treturn dirs\n}\n\n// Flash builds and flashes the built binary to the given serial port.\nfunc Flash(pkgName, port string, options *compileopts.Options) error {\n\tconfig, err := builder.NewConfig(options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// determine the type of file to compile\n\tvar fileExt string\n\n\tflashMethod, _ := config.Programmer()\n\tswitch flashMethod {\n\tcase \"command\", \"\":\n\t\tswitch {\n\t\tcase strings.Contains(config.Target.FlashCommand, \"{hex}\"):\n\t\t\tfileExt = \".hex\"\n\t\tcase strings.Contains(config.Target.FlashCommand, \"{elf}\"):\n\t\t\tfileExt = \".elf\"\n\t\tcase strings.Contains(config.Target.FlashCommand, \"{bin}\"):\n\t\t\tfileExt = \".bin\"\n\t\tcase strings.Contains(config.Target.FlashCommand, \"{uf2}\"):\n\t\t\tfileExt = \".uf2\"\n\t\tcase strings.Contains(config.Target.FlashCommand, \"{zip}\"):\n\t\t\tfileExt = \".zip\"\n\t\tdefault:\n\t\t\treturn errors.New(\"invalid target file - did you forget the {hex} token in the 'flash-command' section?\")\n\t\t}\n\tcase \"msd\":\n\t\tif config.Target.FlashFilename == \"\" {\n\t\t\treturn errors.New(\"invalid target file: flash-method was set to \\\"msd\\\" but no msd-firmware-name was set\")\n\t\t}\n\t\tfileExt = filepath.Ext(config.Target.FlashFilename)\n\tcase \"openocd\":\n\t\tfileExt = \".hex\"\n\tcase \"bmp\":\n\t\tfileExt = \".elf\"\n\tcase \"native\":\n\t\treturn errors.New(\"unknown flash method \\\"native\\\" - did you miss a -target flag?\")\n\tdefault:\n\t\treturn errors.New(\"unknown flash method: \" + flashMethod)\n\t}\n\n\t// Create a temporary directory for intermediary files.\n\ttmpdir, err := os.MkdirTemp(\"\", \"tinygo\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !options.Work {\n\t\tdefer os.RemoveAll(tmpdir)\n\t}\n\n\t// Build the binary.\n\tresult, err := builder.Build(pkgName, fileExt, tmpdir, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// do we need port reset to put MCU into bootloader mode?\n\tif config.Target.PortReset == \"true\" && flashMethod != \"openocd\" {\n\t\tport, err := getDefaultPort(port, config.Target.SerialPort)\n\t\tif err == nil {\n\t\t\terr = touchSerialPortAt1200bps(port)\n\t\t\tif err != nil {\n\t\t\t\treturn &commandError{\"failed to reset port\", port, err}\n\t\t\t}\n\t\t\t// give the target MCU a chance to restart into bootloader\n\t\t\ttime.Sleep(3 * time.Second)\n\t\t}\n\t}\n\n\t// Flash the binary to the MCU.\n\tswitch flashMethod {\n\tcase \"\", \"command\":\n\t\t// Create the command.\n\t\tflashCmd := config.Target.FlashCommand\n\t\tflashCmdList, err := shlex.Split(flashCmd)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not parse flash command %#v: %w\", flashCmd, err)\n\t\t}\n\n\t\tif strings.Contains(flashCmd, \"{port}\") {\n\t\t\tvar err error\n\t\t\tport, err = getDefaultPort(port, config.Target.SerialPort)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Fill in fields in the command template.\n\t\tfileToken := \"{\" + fileExt[1:] + \"}\"\n\t\tfor i, arg := range flashCmdList {\n\t\t\targ = strings.ReplaceAll(arg, fileToken, result.Binary)\n\t\t\targ = strings.ReplaceAll(arg, \"{port}\", port)\n\t\t\tflashCmdList[i] = arg\n\t\t}\n\n\t\t// Execute the command.\n\t\tif len(flashCmdList) < 2 {\n\t\t\treturn fmt.Errorf(\"invalid flash command: %#v\", flashCmd)\n\t\t}\n\t\tcmd := executeCommand(config.Options, flashCmdList[0], flashCmdList[1:]...)\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\tcmd.Dir = goenv.Get(\"TINYGOROOT\")\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\treturn &commandError{\"failed to flash\", result.Binary, err}\n\t\t}\n\tcase \"msd\":\n\t\t// this flashing method copies the binary data to a Mass Storage Device (msd)\n\t\tswitch fileExt {\n\t\tcase \".uf2\":\n\t\t\terr := flashUF2UsingMSD(config.Target.FlashVolume, result.Binary, config.Options)\n\t\t\tif err != nil {\n\t\t\t\treturn &commandError{\"failed to flash\", result.Binary, err}\n\t\t\t}\n\t\tcase \".hex\":\n\t\t\terr := flashHexUsingMSD(config.Target.FlashVolume, result.Binary, config.Options)\n\t\t\tif err != nil {\n\t\t\t\treturn &commandError{\"failed to flash\", result.Binary, err}\n\t\t\t}\n\t\tdefault:\n\t\t\treturn errors.New(\"mass storage device flashing currently only supports uf2 and hex\")\n\t\t}\n\tcase \"openocd\":\n\t\targs, err := config.OpenOCDConfiguration()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texit := \" reset exit\"\n\t\tif config.Target.OpenOCDVerify != nil && *config.Target.OpenOCDVerify {\n\t\t\texit = \" verify\" + exit\n\t\t}\n\t\targs = append(args, \"-c\", \"program \"+filepath.ToSlash(result.Binary)+exit)\n\t\tcmd := executeCommand(config.Options, \"openocd\", args...)\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\treturn &commandError{\"failed to flash\", result.Binary, err}\n\t\t}\n\tcase \"bmp\":\n\t\tgdb, err := config.Target.LookupGDB()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar bmpGDBPort string\n\t\tbmpGDBPort, _, err = getBMPPorts()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\targs := []string{\"-ex\", \"target extended-remote \" + bmpGDBPort, \"-ex\", \"monitor swdp_scan\", \"-ex\", \"attach 1\", \"-ex\", \"load\", filepath.ToSlash(result.Binary)}\n\t\tcmd := executeCommand(config.Options, gdb, args...)\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\treturn &commandError{\"failed to flash\", result.Binary, err}\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown flash method: %s\", flashMethod)\n\t}\n\tif options.Monitor {\n\t\treturn Monitor(result.Executable, \"\", config)\n\t}\n\treturn nil\n}\n\n// Debug compiles and flashes a program to a microcontroller (just like Flash)\n// but instead of resetting the target, it will drop into a debug shell like GDB\n// or LLDB. You can then set breakpoints, run the `continue` command to start,\n// hit Ctrl+C to break the running program, etc.\n//\n// Note: this command is expected to execute just before exiting, as it\n// modifies global state.\nfunc Debug(debugger, pkgName string, ocdOutput bool, options *compileopts.Options) error {\n\tconfig, err := builder.NewConfig(options)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar cmdName string\n\tswitch debugger {\n\tcase \"gdb\":\n\t\tcmdName, err = config.Target.LookupGDB()\n\tcase \"lldb\":\n\t\tcmdName, err = builder.LookupCommand(\"lldb\")\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a temporary directory for intermediary files.\n\ttmpdir, err := os.MkdirTemp(\"\", \"tinygo\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !options.Work {\n\t\tdefer os.RemoveAll(tmpdir)\n\t}\n\n\t// Build the binary to debug.\n\tformat, fileExt := config.EmulatorFormat()\n\tresult, err := builder.Build(pkgName, fileExt, tmpdir, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Find a good way to run GDB.\n\tgdbInterface, openocdInterface := config.Programmer()\n\tswitch gdbInterface {\n\tcase \"msd\", \"command\", \"\":\n\t\temulator := config.EmulatorName()\n\t\tif emulator != \"\" {\n\t\t\tif emulator == \"mgba\" {\n\t\t\t\tgdbInterface = \"mgba\"\n\t\t\t} else if emulator == \"simavr\" {\n\t\t\t\tgdbInterface = \"simavr\"\n\t\t\t} else if strings.HasPrefix(emulator, \"qemu-system-\") {\n\t\t\t\tgdbInterface = \"qemu\"\n\t\t\t} else {\n\t\t\t\t// Assume QEMU as an emulator.\n\t\t\t\tgdbInterface = \"qemu-user\"\n\t\t\t}\n\t\t} else if openocdInterface != \"\" && config.Target.OpenOCDTarget != \"\" {\n\t\t\tgdbInterface = \"openocd\"\n\t\t} else if config.Target.JLinkDevice != \"\" {\n\t\t\tgdbInterface = \"jlink\"\n\t\t} else {\n\t\t\tgdbInterface = \"native\"\n\t\t}\n\t}\n\n\t// Run the GDB server, if necessary.\n\tport := \"\"\n\tvar gdbCommands []string\n\tvar daemon *exec.Cmd\n\temulator, err := config.Emulator(format, result.Binary)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch gdbInterface {\n\tcase \"native\":\n\t\t// Run GDB directly.\n\tcase \"bmp\":\n\t\tvar bmpGDBPort string\n\t\tbmpGDBPort, _, err = getBMPPorts()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tport = bmpGDBPort\n\t\tgdbCommands = append(gdbCommands, \"monitor swdp_scan\", \"compare-sections\", \"attach 1\", \"load\")\n\tcase \"openocd\":\n\t\tport = \":3333\"\n\t\tgdbCommands = append(gdbCommands, \"monitor halt\", \"load\", \"monitor reset halt\")\n\n\t\t// We need a separate debugging daemon for on-chip debugging.\n\t\targs, err := config.OpenOCDConfiguration()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdaemon = executeCommand(config.Options, \"openocd\", args...)\n\t\tif ocdOutput {\n\t\t\t// Make it clear which output is from the daemon.\n\t\t\tw := &ColorWriter{\n\t\t\t\tOut:    colorable.NewColorableStderr(),\n\t\t\t\tPrefix: \"openocd: \",\n\t\t\t\tColor:  TermColorYellow,\n\t\t\t}\n\t\t\tdaemon.Stdout = w\n\t\t\tdaemon.Stderr = w\n\t\t}\n\tcase \"jlink\":\n\t\tport = \":2331\"\n\t\tgdbCommands = append(gdbCommands, \"load\", \"monitor reset halt\")\n\n\t\t// We need a separate debugging daemon for on-chip debugging.\n\t\tdaemon = executeCommand(config.Options, \"JLinkGDBServer\", \"-device\", config.Target.JLinkDevice)\n\t\tif ocdOutput {\n\t\t\t// Make it clear which output is from the daemon.\n\t\t\tw := &ColorWriter{\n\t\t\t\tOut:    colorable.NewColorableStderr(),\n\t\t\t\tPrefix: \"jlink: \",\n\t\t\t\tColor:  TermColorYellow,\n\t\t\t}\n\t\t\tdaemon.Stdout = w\n\t\t\tdaemon.Stderr = w\n\t\t}\n\tcase \"qemu\":\n\t\tport = \":1234\"\n\t\t// Run in an emulator.\n\t\targs := append(emulator[1:], \"-s\", \"-S\")\n\t\tdaemon = executeCommand(config.Options, emulator[0], args...)\n\t\tdaemon.Stdout = os.Stdout\n\t\tdaemon.Stderr = os.Stderr\n\tcase \"qemu-user\":\n\t\tport = \":1234\"\n\t\t// Run in an emulator.\n\t\targs := append([]string{\"-g\", \"1234\"}, emulator[1:]...)\n\t\tdaemon = executeCommand(config.Options, emulator[0], args...)\n\t\tdaemon.Stdout = os.Stdout\n\t\tdaemon.Stderr = os.Stderr\n\tcase \"mgba\":\n\t\tport = \":2345\"\n\t\t// Run in an emulator.\n\t\targs := append(emulator[1:], \"-g\")\n\t\tdaemon = executeCommand(config.Options, emulator[0], args...)\n\t\tdaemon.Stdout = os.Stdout\n\t\tdaemon.Stderr = os.Stderr\n\tcase \"simavr\":\n\t\tport = \":1234\"\n\t\t// Run in an emulator.\n\t\targs := append(emulator[1:], \"-g\")\n\t\tdaemon = executeCommand(config.Options, emulator[0], args...)\n\t\tdaemon.Stdout = os.Stdout\n\t\tdaemon.Stderr = os.Stderr\n\tcase \"msd\":\n\t\treturn errors.New(\"gdb is not supported for drag-and-drop programmable devices\")\n\tdefault:\n\t\treturn fmt.Errorf(\"gdb is not supported with interface %#v\", gdbInterface)\n\t}\n\n\tif daemon != nil {\n\t\t// Make sure the daemon doesn't receive Ctrl-C that is intended for\n\t\t// GDB (to break the currently executing program).\n\t\tsetCommandAsDaemon(daemon)\n\n\t\t// Start now, and kill it on exit.\n\t\terr = daemon.Start()\n\t\tif err != nil {\n\t\t\treturn &commandError{\"failed to run\", daemon.Path, err}\n\t\t}\n\t\tdefer func() {\n\t\t\tdaemon.Process.Signal(os.Interrupt)\n\t\t\tvar stopped uint32\n\t\t\tgo func() {\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\tif atomic.LoadUint32(&stopped) == 0 {\n\t\t\t\t\tdaemon.Process.Kill()\n\t\t\t\t}\n\t\t\t}()\n\t\t\tdaemon.Wait()\n\t\t\tatomic.StoreUint32(&stopped, 1)\n\t\t}()\n\t}\n\n\t// Ignore Ctrl-C, it must be passed on to GDB.\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt)\n\tgo func() {\n\t\tfor range c {\n\t\t}\n\t}()\n\n\t// Construct and execute a gdb or lldb command.\n\t// By default: gdb -ex run <binary>\n\t// Exit the debugger with Ctrl-D.\n\tparams := []string{result.Executable}\n\tswitch debugger {\n\tcase \"gdb\":\n\t\tif port != \"\" {\n\t\t\tparams = append(params, \"-ex\", \"target extended-remote \"+port)\n\t\t}\n\t\tfor _, cmd := range gdbCommands {\n\t\t\tparams = append(params, \"-ex\", cmd)\n\t\t}\n\tcase \"lldb\":\n\t\tparams = append(params, \"--arch\", config.Triple())\n\t\tif port != \"\" {\n\t\t\tif strings.HasPrefix(port, \":\") {\n\t\t\t\tparams = append(params, \"-o\", \"gdb-remote \"+port[1:])\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"cannot use LLDB over a gdb-remote that isn't a TCP port: %s\", port)\n\t\t\t}\n\t\t}\n\t\tfor _, cmd := range gdbCommands {\n\t\t\tif strings.HasPrefix(cmd, \"monitor \") {\n\t\t\t\tparams = append(params, \"-o\", \"process plugin packet \"+cmd)\n\t\t\t} else if cmd == \"load\" {\n\t\t\t\tparams = append(params, \"-o\", \"target modules load --load --slide 0\")\n\t\t\t} else {\n\t\t\t\treturn fmt.Errorf(\"don't know how to convert GDB command %#v to LLDB\", cmd)\n\t\t\t}\n\t\t}\n\t}\n\tcmd := executeCommand(config.Options, cmdName, params...)\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\terr = cmd.Run()\n\tif err != nil {\n\t\treturn &commandError{\"failed to run \" + cmdName + \" with\", result.Executable, err}\n\t}\n\treturn nil\n}\n\n// Run compiles and runs the given program. Depending on the target provided in\n// the options, it will run the program directly on the host or will run it in\n// an emulator. For example, -target=wasm will cause the binary to be run inside\n// of a WebAssembly VM.\nfunc Run(pkgName string, options *compileopts.Options, cmdArgs []string) error {\n\tconfig, err := builder.NewConfig(options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = buildAndRun(pkgName, config, os.Stdout, cmdArgs, nil, 0, func(cmd *exec.Cmd, result builder.BuildResult) error {\n\t\treturn cmd.Run()\n\t})\n\treturn err\n}\n\n// buildAndRun builds and runs the given program, writing output to stdout and\n// errors to os.Stderr. It takes care of emulators (qemu, wasmtime, etc) and\n// passes command line arguments and environment variables in a way appropriate\n// for the given emulator.\nfunc buildAndRun(pkgName string, config *compileopts.Config, stdout io.Writer, cmdArgs, environmentVars []string, timeout time.Duration, run func(cmd *exec.Cmd, result builder.BuildResult) error) (builder.BuildResult, error) {\n\t// Determine whether we're on a system that supports environment variables\n\t// and command line parameters (operating systems, WASI) or not (baremetal,\n\t// WebAssembly in the browser). If we're on a system without an environment,\n\t// we need to pass command line arguments and environment variables through\n\t// global variables (built into the binary directly) instead of the\n\t// conventional way.\n\tneedsEnvInVars := config.GOOS() == \"js\"\n\tfor _, tag := range config.BuildTags() {\n\t\tif tag == \"baremetal\" {\n\t\t\tneedsEnvInVars = true\n\t\t}\n\t}\n\tvar args, env []string\n\tvar extraCmdEnv []string\n\tif needsEnvInVars {\n\t\truntimeGlobals := make(map[string]string)\n\t\tif len(cmdArgs) != 0 {\n\t\t\truntimeGlobals[\"osArgs\"] = strings.Join(cmdArgs, \"\\x00\")\n\t\t}\n\t\tif len(environmentVars) != 0 {\n\t\t\truntimeGlobals[\"osEnv\"] = strings.Join(environmentVars, \"\\x00\")\n\t\t}\n\t\tif len(runtimeGlobals) != 0 {\n\t\t\t// This sets the global variables like they would be set with\n\t\t\t// `-ldflags=\"-X=runtime.osArgs=first\\x00second`.\n\t\t\t// The runtime package has two variables (osArgs and osEnv) that are\n\t\t\t// both strings, from which the parameters and environment variables\n\t\t\t// are read.\n\t\t\tconfig.Options.GlobalValues = map[string]map[string]string{\n\t\t\t\t\"runtime\": runtimeGlobals,\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Pass environment variables and command line parameters as usual.\n\t\t// This also works on qemu-aarch64 etc.\n\t\targs = cmdArgs\n\t\tenv = environmentVars\n\t}\n\n\t// Create a temporary directory for intermediary files.\n\ttmpdir, err := os.MkdirTemp(\"\", \"tinygo\")\n\tif err != nil {\n\t\treturn builder.BuildResult{}, err\n\t}\n\tif !config.Options.Work {\n\t\tdefer os.RemoveAll(tmpdir)\n\t}\n\n\t// Build the binary to be run.\n\tformat, fileExt := config.EmulatorFormat()\n\tresult, err := builder.Build(pkgName, fileExt, tmpdir, config)\n\tif err != nil {\n\t\treturn result, err\n\t}\n\n\t// If needed, set a timeout on the command. This is done in tests so\n\t// they don't waste resources on a stalled test.\n\tvar ctx context.Context\n\tif timeout != 0 {\n\t\tvar cancel context.CancelFunc\n\t\tctx, cancel = context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\t}\n\n\t// Set up the command.\n\tvar name string\n\tif config.Target.Emulator == \"\" {\n\t\tname = result.Binary\n\t} else {\n\t\temulator, err := config.Emulator(format, result.Binary)\n\t\tif err != nil {\n\t\t\treturn result, err\n\t\t}\n\n\t\tname, emulator = emulator[0], emulator[1:]\n\n\t\t// wasmtime is a WebAssembly runtime CLI with WASI enabled by default.\n\t\t// By default, only stdio is allowed. For example, while STDOUT routes\n\t\t// to the host, other files don't. It also does not inherit environment\n\t\t// variables from the host. Some tests read testdata files, often from\n\t\t// outside the package directory. Other tests require temporary\n\t\t// writeable directories. We allow this by adding wasmtime flags below.\n\t\tif name == \"wasmtime\" {\n\t\t\tvar emuArgs []string\n\n\t\t\t// Extract the wasmtime subcommand (e.g. \"run\" or \"serve\")\n\t\t\tif len(emulator) > 1 {\n\t\t\t\temuArgs = append(emuArgs, emulator[0])\n\t\t\t\temulator = emulator[1:]\n\t\t\t}\n\n\t\t\twd, _ := os.Getwd()\n\n\t\t\t// Below adds additional wasmtime flags in case a test reads files\n\t\t\t// outside its directory, like \"../testdata/e.txt\". This allows any\n\t\t\t// relative directory up to the module root, even if the test never\n\t\t\t// reads any files.\n\t\t\tif config.TestConfig.CompileTestBinary {\n\t\t\t\t// Set working directory to package dir\n\t\t\t\twd = result.MainDir\n\n\t\t\t\t// Add relative dirs (../, ../..) up to module root (for wasip1)\n\t\t\t\tdirs := dirsToModuleRootRel(result.MainDir, result.ModuleRoot)\n\n\t\t\t\t// Add absolute dirs up to module root (for wasip2)\n\t\t\t\tdirs = append(dirs, dirsToModuleRootAbs(result.MainDir, result.ModuleRoot)...)\n\n\t\t\t\tfor _, d := range dirs {\n\t\t\t\t\temuArgs = append(emuArgs, \"--dir=\"+d)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\temuArgs = append(emuArgs, \"--dir=.\")\n\t\t\t}\n\n\t\t\temuArgs = append(emuArgs, \"--dir=\"+wd)\n\t\t\temuArgs = append(emuArgs, \"--env=PWD=\"+wd)\n\t\t\tfor _, v := range environmentVars {\n\t\t\t\temuArgs = append(emuArgs, \"--env\", v)\n\t\t\t}\n\n\t\t\t// Set this for nicer backtraces during tests, but don't override the user.\n\t\t\tif _, ok := os.LookupEnv(\"WASMTIME_BACKTRACE_DETAILS\"); !ok {\n\t\t\t\textraCmdEnv = append(extraCmdEnv, \"WASMTIME_BACKTRACE_DETAILS=1\")\n\t\t\t}\n\n\t\t\temulator = append(emuArgs, emulator...)\n\t\t}\n\n\t\targs = append(emulator, args...)\n\t}\n\tvar cmd *exec.Cmd\n\tif ctx != nil {\n\t\tcmd = exec.CommandContext(ctx, name, args...)\n\t} else {\n\t\tcmd = exec.Command(name, args...)\n\t}\n\tcmd.Env = append(cmd.Env, env...)\n\tcmd.Env = append(cmd.Env, extraCmdEnv...)\n\n\t// Configure stdout/stderr. The stdout may go to a buffer, not a real\n\t// stdout.\n\tcmd.Stdout = newOutputWriter(stdout, result.Executable)\n\tcmd.Stderr = os.Stderr\n\tif config.EmulatorName() == \"simavr\" {\n\t\tcmd.Stdout = nil // don't print initial load commands\n\t\tcmd.Stderr = stdout\n\t}\n\n\t// If this is a test, reserve CPU time for it so that increased\n\t// parallelism doesn't blow up memory usage. If this isn't a test but\n\t// simply `tinygo run`, then it is practically a no-op.\n\tconfig.Options.Semaphore <- struct{}{}\n\tdefer func() {\n\t\t<-config.Options.Semaphore\n\t}()\n\n\t// Run binary.\n\tif config.Options.PrintCommands != nil {\n\t\tconfig.Options.PrintCommands(cmd.Path, cmd.Args[1:]...)\n\t}\n\terr = run(cmd, result)\n\tif err != nil {\n\t\tif ctx != nil && ctx.Err() == context.DeadlineExceeded {\n\t\t\tfmt.Fprintf(stdout, \"--- timeout of %s exceeded, terminating...\\n\", timeout)\n\t\t\terr = ctx.Err()\n\t\t}\n\t\treturn result, &commandError{\"failed to run compiled binary\", result.Binary, err}\n\t}\n\treturn result, nil\n}\n\nfunc touchSerialPortAt1200bps(port string) (err error) {\n\tretryCount := 3\n\tfor i := 0; i < retryCount; i++ {\n\t\t// Open port\n\t\tp, e := serial.Open(port, &serial.Mode{BaudRate: 1200})\n\t\tif e != nil {\n\t\t\tif runtime.GOOS == `windows` {\n\t\t\t\tse, ok := e.(*serial.PortError)\n\t\t\t\tif ok && se.Code() == serial.InvalidSerialPort {\n\t\t\t\t\t// InvalidSerialPort error occurs when transitioning to boot\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\terr = e\n\t\t\tcontinue\n\t\t}\n\t\tdefer p.Close()\n\n\t\tp.SetDTR(false)\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"opening port: %s\", err)\n}\n\nfunc flashUF2UsingMSD(volumes []string, tmppath string, options *compileopts.Options) error {\n\tfor start := time.Now(); time.Since(start) < options.Timeout; {\n\t\t// Find a UF2 mount point.\n\t\tmounts, err := findFATMounts(options)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, mount := range mounts {\n\t\t\tfor _, volume := range volumes {\n\t\t\t\tif mount.name != volume {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif _, err := os.Stat(filepath.Join(mount.path, \"INFO_UF2.TXT\")); err != nil {\n\t\t\t\t\t// No INFO_UF2.TXT found, which is expected on a UF2\n\t\t\t\t\t// filesystem.\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Found the filesystem, so flash the device!\n\t\t\t\treturn moveFile(tmppath, filepath.Join(mount.path, \"flash.uf2\"))\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n\treturn errors.New(\"unable to locate any volume: [\" + strings.Join(volumes, \",\") + \"]\")\n}\n\nfunc flashHexUsingMSD(volumes []string, tmppath string, options *compileopts.Options) error {\n\tfor start := time.Now(); time.Since(start) < options.Timeout; {\n\t\t// Find all mount points.\n\t\tmounts, err := findFATMounts(options)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, mount := range mounts {\n\t\t\tfor _, volume := range volumes {\n\t\t\t\tif mount.name != volume {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Found the filesystem, so flash the device!\n\t\t\t\treturn moveFile(tmppath, filepath.Join(mount.path, \"flash.hex\"))\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n\treturn errors.New(\"unable to locate any volume: [\" + strings.Join(volumes, \",\") + \"]\")\n}\n\ntype mountPoint struct {\n\tname string\n\tpath string\n}\n\n// Find all the mount points on the system that use the FAT filesystem.\nfunc findFATMounts(options *compileopts.Options) ([]mountPoint, error) {\n\tvar points []mountPoint\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tlist, err := os.ReadDir(\"/Volumes\")\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not list mount points: %w\", err)\n\t\t}\n\t\tfor _, elem := range list {\n\t\t\t// TODO: find a way to check for the filesystem type.\n\t\t\t// (Only return FAT filesystems).\n\t\t\tpoints = append(points, mountPoint{\n\t\t\t\tname: elem.Name(),\n\t\t\t\tpath: filepath.Join(\"/Volumes\", elem.Name()),\n\t\t\t})\n\t\t}\n\t\tsort.Slice(points, func(i, j int) bool {\n\t\t\treturn points[i].path < points[j].name\n\t\t})\n\t\treturn points, nil\n\tcase \"linux\":\n\t\ttab, err := os.ReadFile(\"/proc/mounts\") // symlink to /proc/self/mounts on my system\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not list mount points: %w\", err)\n\t\t}\n\t\tfor _, line := range strings.Split(string(tab), \"\\n\") {\n\t\t\tfields := strings.Fields(line)\n\t\t\tif len(fields) <= 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfstype := fields[2]\n\t\t\t// chromeos bind mounts use 9p\n\t\t\tif !(fstype == \"vfat\" || fstype == \"9p\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfspath := strings.ReplaceAll(fields[1], \"\\\\040\", \" \")\n\t\t\tpoints = append(points, mountPoint{\n\t\t\t\tname: filepath.Base(fspath),\n\t\t\t\tpath: fspath,\n\t\t\t})\n\t\t}\n\t\treturn points, nil\n\tcase \"windows\":\n\t\t// Obtain a list of all currently mounted volumes.\n\t\tcmd := executeCommand(options, \"wmic\",\n\t\t\t\"PATH\", \"Win32_LogicalDisk\",\n\t\t\t\"get\", \"DeviceID,VolumeName,FileSystem,DriveType\")\n\t\tvar out bytes.Buffer\n\t\tcmd.Stdout = &out\n\t\terr := cmd.Run()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"could not list mount points: %w\", err)\n\t\t}\n\n\t\t// Extract data to convert to a []mountPoint slice.\n\t\tfor _, line := range strings.Split(out.String(), \"\\n\") {\n\t\t\twords := strings.Fields(line)\n\t\t\tif len(words) < 3 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif words[1] != \"2\" || words[2] != \"FAT\" {\n\t\t\t\t// - DriveType 2 is removable (which we're looking for).\n\t\t\t\t// - We only want to return FAT filesystems.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpoints = append(points, mountPoint{\n\t\t\t\tname: words[3],\n\t\t\t\tpath: words[0],\n\t\t\t})\n\t\t}\n\t\treturn points, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown GOOS for listing mount points: %s\", runtime.GOOS)\n\t}\n}\n\n// getDefaultPort returns the default serial port depending on the operating system.\nfunc getDefaultPort(portFlag string, usbInterfaces []string) (port string, err error) {\n\tportCandidates := strings.FieldsFunc(portFlag, func(c rune) bool { return c == ',' })\n\tif len(portCandidates) == 1 {\n\t\treturn portCandidates[0], nil\n\t}\n\n\tvar ports []string\n\tswitch runtime.GOOS {\n\tcase \"freebsd\":\n\t\tports, err = filepath.Glob(\"/dev/cuaU*\")\n\tcase \"darwin\", \"linux\", \"windows\":\n\t\tvar portsList []*enumerator.PortDetails\n\t\tportsList, err = enumerator.GetDetailedPortsList()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tvar preferredPortIDs [][2]uint16\n\t\tfor _, s := range usbInterfaces {\n\t\t\tparts := strings.Split(s, \":\")\n\t\t\tif len(parts) != 2 {\n\t\t\t\treturn \"\", fmt.Errorf(\"could not parse USB VID/PID pair %q\", s)\n\t\t\t}\n\t\t\tvid, err := strconv.ParseUint(parts[0], 16, 16)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"could not parse USB vendor ID %q: %w\", parts[1], err)\n\t\t\t}\n\t\t\tpid, err := strconv.ParseUint(parts[1], 16, 16)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"could not parse USB product ID %q: %w\", parts[1], err)\n\t\t\t}\n\t\t\tpreferredPortIDs = append(preferredPortIDs, [2]uint16{uint16(vid), uint16(pid)})\n\t\t}\n\n\t\tvar primaryPorts []string   // ports picked from preferred USB VID/PID\n\t\tvar secondaryPorts []string // other ports (as a fallback)\n\t\tfor _, p := range portsList {\n\t\t\tif !p.IsUSB {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif p.VID != \"\" && p.PID != \"\" {\n\t\t\t\tfoundPort := false\n\t\t\t\tvid, vidErr := strconv.ParseUint(p.VID, 16, 16)\n\t\t\t\tpid, pidErr := strconv.ParseUint(p.PID, 16, 16)\n\t\t\t\tif vidErr == nil && pidErr == nil {\n\t\t\t\t\tfor _, id := range preferredPortIDs {\n\t\t\t\t\t\tif uint16(vid) == id[0] && uint16(pid) == id[1] {\n\t\t\t\t\t\t\tprimaryPorts = append(primaryPorts, p.Name)\n\t\t\t\t\t\t\tfoundPort = true\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif foundPort {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsecondaryPorts = append(secondaryPorts, p.Name)\n\t\t}\n\t\tif len(primaryPorts) == 1 {\n\t\t\t// There is exactly one match in the set of preferred ports. Use\n\t\t\t// this port, even if there may be others available. This allows\n\t\t\t// flashing a specific board even if there are multiple available.\n\t\t\treturn primaryPorts[0], nil\n\t\t} else if len(primaryPorts) > 1 {\n\t\t\t// There are multiple preferred ports, probably because more than\n\t\t\t// one device of the same type are connected (e.g. two Arduino\n\t\t\t// Unos).\n\t\t\tports = primaryPorts\n\t\t} else {\n\t\t\t// No preferred ports found. Fall back to other serial ports\n\t\t\t// available in the system.\n\t\t\tports = secondaryPorts\n\t\t}\n\tdefault:\n\t\treturn \"\", errors.New(\"unable to search for a default USB device to be flashed on this OS\")\n\t}\n\n\tif err != nil {\n\t\treturn \"\", err\n\t} else if ports == nil {\n\t\treturn \"\", errors.New(\"unable to locate a serial port\")\n\t} else if len(ports) == 0 {\n\t\treturn \"\", errors.New(\"no serial ports available\")\n\t}\n\n\tif len(portCandidates) == 0 {\n\t\tif len(usbInterfaces) > 0 {\n\t\t\treturn \"\", errors.New(\"unable to search for a default USB device - use -port flag, available ports are \" + strings.Join(ports, \", \"))\n\t\t} else if len(ports) == 1 {\n\t\t\treturn ports[0], nil\n\t\t} else {\n\t\t\treturn \"\", errors.New(\"multiple serial ports available - use -port flag, available ports are \" + strings.Join(ports, \", \"))\n\t\t}\n\t}\n\n\tfor _, ps := range portCandidates {\n\t\tfor _, p := range ports {\n\t\t\tif p == ps {\n\t\t\t\treturn p, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", errors.New(\"port you specified '\" + strings.Join(portCandidates, \",\") + \"' does not exist, available ports are \" + strings.Join(ports, \", \"))\n}\n\n// getBMPPorts returns BlackMagicProbe's serial ports if any\nfunc getBMPPorts() (gdbPort, uartPort string, err error) {\n\tvar portsList []*enumerator.PortDetails\n\tportsList, err = enumerator.GetDetailedPortsList()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tvar ports []string\n\tfor _, p := range portsList {\n\t\tif !p.IsUSB {\n\t\t\tcontinue\n\t\t}\n\t\tif p.VID != \"\" && p.PID != \"\" {\n\t\t\tvid, vidErr := strconv.ParseUint(p.VID, 16, 16)\n\t\t\tpid, pidErr := strconv.ParseUint(p.PID, 16, 16)\n\t\t\tif vidErr == nil && pidErr == nil && vid == 0x1d50 && pid == 0x6018 {\n\t\t\t\tports = append(ports, p.Name)\n\t\t\t}\n\t\t}\n\t}\n\tif len(ports) == 2 {\n\t\treturn ports[0], ports[1], nil\n\t} else if len(ports) == 0 {\n\t\treturn \"\", \"\", errors.New(\"no BMP detected\")\n\t} else {\n\t\treturn \"\", \"\", fmt.Errorf(\"expected 2 BMP serial ports, found %d - did you perhaps connect more than one BMP?\", len(ports))\n\t}\n}\n\nconst (\n\tusageBuild = `Build compiles the packages named by the import paths, along with their\ndependencies, but it does not install the results. The output binary is\nspecified using the -o parameter. The generated file type depends on the\nextension:\n\n\t.o:\n\t\t\tCreate a relocatable object file. You can use this option if you\n\t\t\tdon't want to use the TinyGo build system or want to do other custom\n\t\t\tthings.\n\n\t.ll:\n\t\t\tCreate textual LLVM IR, after optimization. This is mainly useful\n\t\t\tfor debugging.\n\n\t.bc:\n\t\t\tCreate LLVM bitcode, after optimization. This may be useful for\n\t\t\tdebugging or for linking into other programs using LTO.\n\n\t.hex:\n\t\t\tCreate an Intel HEX file to flash it to a microcontroller.\n\n\t.bin:\n\t\t\tSimilar, but create a binary file.\n\n\t.wasm:\n\t\t\tCompile and link a WebAssembly file.\n\n(all other) Compile and link the program into a regular executable. For\nmicrocontrollers, it is common to use the .elf file extension to indicate a\nlinked ELF file is generated. For Linux, it is common to build binaries with no\nextension at all.`\n\n\tusageRun = `Run the program, either directly on the host or in an emulated environment \n(depending on -target).`\n\n\tusageFlash = `Flash the program to a microcontroller. Some common flags are described below.\n\n\t-target={name}: \n\t\t\tSpecifies the type of microcontroller that is used. The name of the\n\t\t\tmicrocontroller is given on the individual pages for each board type\n\t\t\tlisted under Microcontrollers\n\t\t\t(https://tinygo.org/docs/reference/microcontrollers/).\n\t\t\tExamples: \"arduino-nano\", \"d1mini\", \"xiao\".\n\n\t-monitor: \n\t\t\tStart the serial monitor (see below) immediately after\n\t\t\tflashing. However, some microcontrollers need a split second\n\t\t\tor two to configure the serial port after flashing, and\n\t\t\tusing the \"-monitor\" flag can fail because the serial\n\t\t\tmonitor starts too quickly. In that case, use the \"tinygo\n\t\t\tmonitor\" command explicitly.`\n\n\tusageMonitor = `Start the serial monitor on the serial port that is connected to the\nmicrocontroller. If there is only a single board attached to the host computer,\nthe default values for various options should be sufficient. In other\nsituations, particularly if you have multiple microcontrollers attached, some\nparameters may need to be overridden using the following flags:\n\n\t-port={port}:\n\t\t\tIf there are multiple microcontroller attached, an error\n\t\t\tmessage will display a list of potential serial ports. The\n\t\t\tappropriate port can be specified by this flag. On Linux,\n\t\t\tthe port will be something like /dev/ttyUSB0 or /dev/ttyACM1.\n\t\t\tOn MacOS, the port will look like /dev/cu.usbserial-1420. On\n\t\t\tWindows, the port will be something like COM1 or COM31.\n\n\t-baudrate={rate}:\n\t\t\tThe default baud rate is 115200. Boards using the AVR\n\t\t\tprocessor (e.g. Arduino Nano, Arduino Mega 2560) use 9600\n\t\t\tinstead.\n\n\t-target={name}:\n\t\t\tIf you have more than one microcontrollers attached, you can\n\t\t\tsometimes just specify the target name and let tinygo\n\t\t\tmonitor figure out the port. Sometimes, this does not work\n\t\t\tand you have to explicitly use the -port flag.\n\nThe serial monitor intercepts several control characters for its own use instead of sending them\nto the microcontroller:\n\n\tControl-C: terminates the tinygo monitor\n\tControl-Z: suspends the tinygo monitor and drops back into shell\n\tControl-\\: terminates the tinygo monitor with a stack trace\n\tControl-S: flow control, suspends output to the console\n\tControl-Q: flow control, resumes output to the console\n\tControl-@: thrown away by tinygo monitor\n\nNote: If you are using os.Stdin on the microcontroller, you may find that a CR\ncharacter on the host computer (also known as Enter, ^M, or \\r) is transmitted\nto the microcontroller without conversion, so os.Stdin returns a \\r character\ninstead of the expected \\n (also known as ^J, NL, or LF) to indicate\nend-of-line. You may be able to get around this problem by hitting Control-J in\ntinygo monitor to transmit the \\n end-of-line character.`\n\n\tusageGdb = `Build the program, optionally flash it to a microcontroller if it is a remote \ntarget, and drop into a GDB shell. From there you can set breakpoints, start the\nprogram with \"run\" or \"continue\" (\"run\" for a local program, continue for\non-chip debugging), single-step, show a backtrace, break and resume the program\nwith Ctrl-C/\"continue\", etc. You may need to install extra tools (like openocd\nand arm-none-eabi-gdb) to be able to do this. Also, you may need a dedicated\ndebugger to be able to debug certain boards if no debugger is integrated. Some\nboards (like the BBC micro:bit and most professional evaluation boards) have an\nintegrated debugger.`\n\n\tusageClean = `Clean the cache directory, normally stored in $HOME/.cache/tinygo. This is not\nnormally needed.`\n\n\tusageHelp    = `Print a short summary of the available commands, plus a list of command flags.`\n\tusageVersion = `Print the version of the command and the version of the used $GOROOT.`\n\tusageEnv     = `Print a list of environment variables that affect TinyGo (as a shell script).\nIf one or more variable names are given as arguments, env prints the value of\neach on a new line.`\n\n\tusageDefault = `TinyGo is a Go compiler for small places.\nversion: %s\nusage: %s <command> [arguments]\ncommands:\n\t\tbuild:\t\tcompile packages and dependencies\n\t\trun:\t\tcompile and run immediately\n\t\ttest:\t\ttest packages\n\t\tflash:\t\tcompile and flash to the device\n\t\tgdb:\t\trun/flash and immediately enter GDB\n\t\tlldb:\t\trun/flash and immediately enter LLDB\n\t\tmonitor:\topen communication port\n\t\tports:\t\tlist available serial ports\n\t\tenv:\t\tlist environment variables used during build\n\t\tlist:\t\trun go list using the TinyGo root\n\t\tclean:\t\tempty cache directory (%s)\n\t\ttargets:\tlist targets\n\t\tinfo:\t\tshow info for specified target\n\t\tversion:\tshow version\n\t\thelp:\t\tprint this help text`\n)\n\nvar (\n\tcommandHelp = map[string]string{\n\t\t\"build\":   usageBuild,\n\t\t\"run\":     usageRun,\n\t\t\"flash\":   usageFlash,\n\t\t\"monitor\": usageMonitor,\n\t\t\"gdb\":     usageGdb,\n\t\t\"clean\":   usageClean,\n\t\t\"help\":    usageHelp,\n\t\t\"version\": usageVersion,\n\t\t\"env\":     usageEnv,\n\t}\n)\n\nfunc usage(command string) {\n\tval, ok := commandHelp[command]\n\tif !ok {\n\t\tfmt.Fprintf(os.Stderr, usageDefault, goenv.Version(), os.Args[0], goenv.Get(\"GOCACHE\"))\n\t\tif flag.Parsed() {\n\t\t\tfmt.Fprintln(os.Stderr, \"\\nflags:\")\n\t\t\tflag.PrintDefaults()\n\t\t}\n\n\t\tfmt.Fprintln(os.Stderr, \"\\nfor more details, see https://tinygo.org/docs/reference/usage/\")\n\t} else {\n\t\tfmt.Fprintln(os.Stderr, val)\n\t}\n\n}\n\nfunc handleCompilerError(err error) {\n\tif err != nil {\n\t\twd, getwdErr := os.Getwd()\n\t\tif getwdErr != nil {\n\t\t\twd = \"\"\n\t\t}\n\t\tdiagnostics.CreateDiagnostics(err).WriteTo(os.Stderr, wd)\n\t\tos.Exit(1)\n\t}\n}\n\n// This is a special type for the -X flag to parse the pkgpath.Var=stringVal\n// format. It has to be a special type to allow multiple variables to be defined\n// this way.\ntype globalValuesFlag map[string]map[string]string\n\nfunc (m globalValuesFlag) String() string {\n\treturn \"pkgpath.Var=value\"\n}\n\nfunc (m globalValuesFlag) Set(value string) error {\n\tequalsIndex := strings.IndexByte(value, '=')\n\tif equalsIndex < 0 {\n\t\treturn errors.New(\"expected format pkgpath.Var=value\")\n\t}\n\tpathAndName := value[:equalsIndex]\n\tpointIndex := strings.LastIndexByte(pathAndName, '.')\n\tif pointIndex < 0 {\n\t\treturn errors.New(\"expected format pkgpath.Var=value\")\n\t}\n\tpath := pathAndName[:pointIndex]\n\tname := pathAndName[pointIndex+1:]\n\tstringValue := value[equalsIndex+1:]\n\tif m[path] == nil {\n\t\tm[path] = make(map[string]string)\n\t}\n\tm[path][name] = stringValue\n\treturn nil\n}\n\n// parseGoLinkFlag parses the -ldflags parameter. Its primary purpose right now\n// is the -X flag, for setting the value of global string variables.\nfunc parseGoLinkFlag(flagsString string) (map[string]map[string]string, string, error) {\n\tset := flag.NewFlagSet(\"link\", flag.ExitOnError)\n\tglobalVarValues := make(globalValuesFlag)\n\tset.Var(globalVarValues, \"X\", \"Set the value of the string variable to the given value.\")\n\textLDFlags := set.String(\"extldflags\", \"\", \"additional flags to pass to external linker\")\n\tflags, err := shlex.Split(flagsString)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\terr = set.Parse(flags)\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\treturn map[string]map[string]string(globalVarValues), *extLDFlags, nil\n}\n\n// getListOfPackages returns a standard list of packages for a given list that might\n// include wildards using `go list`.\n// For example [./...] => [\"pkg1\", \"pkg1/pkg12\", \"pkg2\"]\nfunc getListOfPackages(pkgs []string, options *compileopts.Options) ([]string, error) {\n\tconfig, err := builder.NewConfig(options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcmd, err := loader.List(config, nil, pkgs)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to run `go list`: %w\", err)\n\t}\n\toutputBuf := bytes.NewBuffer(nil)\n\tcmd.Stdout = outputBuf\n\tcmd.Stderr = os.Stderr\n\terr = cmd.Run()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar pkgNames []string\n\tsc := bufio.NewScanner(outputBuf)\n\tfor sc.Scan() {\n\t\tpkgNames = append(pkgNames, sc.Text())\n\t}\n\n\treturn pkgNames, nil\n}\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tfmt.Fprintln(os.Stderr, \"No command-line arguments supplied.\")\n\t\tusage(\"\")\n\t\tos.Exit(1)\n\t}\n\tcommand := os.Args[1]\n\n\topt := flag.String(\"opt\", \"z\", \"optimization level: 0, 1, 2, s, z\")\n\tgc := flag.String(\"gc\", \"\", \"garbage collector to use (none, leaking, conservative)\")\n\tpanicStrategy := flag.String(\"panic\", \"print\", \"panic strategy (print, trap)\")\n\tscheduler := flag.String(\"scheduler\", \"\", \"which scheduler to use (none, tasks, asyncify)\")\n\tserial := flag.String(\"serial\", \"\", \"which serial output to use (none, uart, usb, rtt)\")\n\twork := flag.Bool(\"work\", false, \"print the name of the temporary build directory and do not delete this directory on exit\")\n\tinterpTimeout := flag.Duration(\"interp-timeout\", 180*time.Second, \"interp optimization pass timeout\")\n\tvar tags buildutil.TagsFlag\n\tflag.Var(&tags, \"tags\", \"a space-separated list of extra build tags\")\n\ttarget := flag.String(\"target\", \"\", \"chip/board name or JSON target specification file\")\n\tbuildMode := flag.String(\"buildmode\", \"\", \"build mode to use (default, c-shared)\")\n\tvar stackSize uint64\n\tflag.Func(\"stack-size\", \"goroutine stack size (if unknown at compile time)\", func(s string) error {\n\t\tsize, err := bytesize.Parse(s)\n\t\tstackSize = uint64(size)\n\t\treturn err\n\t})\n\tprintSize := flag.String(\"size\", \"\", \"print sizes (none, short, full, html)\")\n\tprintStacks := flag.Bool(\"print-stacks\", false, \"print stack sizes of goroutines\")\n\tprintAllocsString := flag.String(\"print-allocs\", \"\", \"regular expression of functions for which heap allocations should be printed\")\n\tprintCommands := flag.Bool(\"x\", false, \"Print commands\")\n\tparallelism := flag.Int(\"p\", runtime.GOMAXPROCS(0), \"the number of build jobs that can run in parallel\")\n\tnodebug := flag.Bool(\"no-debug\", false, \"strip debug information\")\n\tocdCommandsString := flag.String(\"ocd-commands\", \"\", \"OpenOCD commands, overriding target spec (can specify multiple separated by commas)\")\n\tocdOutput := flag.Bool(\"ocd-output\", false, \"print OCD daemon output during debug\")\n\tport := flag.String(\"port\", \"\", \"flash port (can specify multiple candidates separated by commas)\")\n\ttimeout := flag.Duration(\"timeout\", 20*time.Second, \"the length of time to retry locating the MSD volume to be used for flashing\")\n\tprogrammer := flag.String(\"programmer\", \"\", \"which hardware programmer to use\")\n\tldflags := flag.String(\"ldflags\", \"\", \"Go link tool compatible ldflags\")\n\tllvmFeatures := flag.String(\"llvm-features\", \"\", \"comma separated LLVM features to enable\")\n\tcpuprofile := flag.String(\"cpuprofile\", \"\", \"cpuprofile output\")\n\tmonitor := flag.Bool(\"monitor\", false, \"enable serial monitor\")\n\tbaudrate := flag.Int(\"baudrate\", 115200, \"baudrate of serial monitor\")\n\n\t// Internal flags, that are only intended for TinyGo development.\n\tprintIR := flag.Bool(\"internal-printir\", false, \"print LLVM IR\")\n\tdumpSSA := flag.Bool(\"internal-dumpssa\", false, \"dump internal Go SSA\")\n\tverifyIR := flag.Bool(\"internal-verifyir\", false, \"run extra verification steps on LLVM IR\")\n\t// Don't generate debug information in the IR, to make IR more readable.\n\t// You generally want debug information in IR for various features, like\n\t// stack size calculation and features like -size=short, -print-allocs=,\n\t// etc. The -no-debug flag is used to strip it at link time. But for TinyGo\n\t// development it can be useful to not emit debug information at all.\n\tskipDwarf := flag.Bool(\"internal-nodwarf\", false, \"internal flag, use -no-debug instead\")\n\n\tvar flagJSON, flagDeps, flagTest bool\n\tif command == \"help\" || command == \"list\" || command == \"info\" || command == \"build\" {\n\t\tflag.BoolVar(&flagJSON, \"json\", false, \"print data in JSON format\")\n\t}\n\tif command == \"help\" || command == \"list\" {\n\t\tflag.BoolVar(&flagDeps, \"deps\", false, \"supply -deps flag to go list\")\n\t\tflag.BoolVar(&flagTest, \"test\", false, \"supply -test flag to go list\")\n\t}\n\tvar outpath string\n\tif command == \"help\" || command == \"build\" || command == \"test\" {\n\t\tflag.StringVar(&outpath, \"o\", \"\", \"output filename\")\n\t}\n\n\tvar witPackage, witWorld string\n\tif command == \"help\" || command == \"build\" || command == \"test\" || command == \"run\" {\n\t\tflag.StringVar(&witPackage, \"wit-package\", \"\", \"wit package for wasm component embedding\")\n\t\tflag.StringVar(&witWorld, \"wit-world\", \"\", \"wit world for wasm component embedding\")\n\t}\n\n\tvar testConfig compileopts.TestConfig\n\tif command == \"help\" || command == \"test\" {\n\t\tflag.BoolVar(&testConfig.CompileOnly, \"c\", false, \"compile the test binary but do not run it\")\n\t\tflag.BoolVar(&testConfig.Verbose, \"v\", false, \"verbose: print additional output\")\n\t\tflag.BoolVar(&testConfig.Short, \"short\", false, \"short: run smaller test suite to save time\")\n\t\tflag.StringVar(&testConfig.RunRegexp, \"run\", \"\", \"run: regexp of tests to run\")\n\t\tflag.StringVar(&testConfig.SkipRegexp, \"skip\", \"\", \"skip: regexp of tests to skip\")\n\t\ttestConfig.Count = flag.Int(\"count\", 1, \"count: number of times to run tests/benchmarks `count` times\")\n\t\tflag.StringVar(&testConfig.BenchRegexp, \"bench\", \"\", \"bench: regexp of benchmarks to run\")\n\t\tflag.StringVar(&testConfig.BenchTime, \"benchtime\", \"\", \"run each benchmark for duration `d`\")\n\t\tflag.BoolVar(&testConfig.BenchMem, \"benchmem\", false, \"show memory stats for benchmarks\")\n\t\tflag.StringVar(&testConfig.Shuffle, \"shuffle\", \"\", \"shuffle the order the tests and benchmarks run\")\n\t}\n\n\t// Early command processing, before commands are interpreted by the Go flag\n\t// library.\n\thandleChdirFlag()\n\tswitch command {\n\tcase \"clang\", \"ld.lld\", \"wasm-ld\":\n\t\terr := builder.RunTool(command, os.Args[2:]...)\n\t\tif err != nil {\n\t\t\t// The tool should have printed an error message already.\n\t\t\t// Don't print another error message here.\n\t\t\tos.Exit(1)\n\t\t}\n\t\tos.Exit(0)\n\t}\n\n\tflag.CommandLine.Parse(os.Args[2:])\n\tglobalVarValues, extLDFlags, err := parseGoLinkFlag(*ldflags)\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n\n\tvar printAllocs *regexp.Regexp\n\tif *printAllocsString != \"\" {\n\t\tprintAllocs, err = regexp.Compile(*printAllocsString)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\tvar ocdCommands []string\n\tif *ocdCommandsString != \"\" {\n\t\tocdCommands = strings.Split(*ocdCommandsString, \",\")\n\t}\n\n\toptions := &compileopts.Options{\n\t\tGOOS:            goenv.Get(\"GOOS\"),\n\t\tGOARCH:          goenv.Get(\"GOARCH\"),\n\t\tGOARM:           goenv.Get(\"GOARM\"),\n\t\tGOMIPS:          goenv.Get(\"GOMIPS\"),\n\t\tTarget:          *target,\n\t\tBuildMode:       *buildMode,\n\t\tStackSize:       stackSize,\n\t\tOpt:             *opt,\n\t\tGC:              *gc,\n\t\tPanicStrategy:   *panicStrategy,\n\t\tScheduler:       *scheduler,\n\t\tSerial:          *serial,\n\t\tWork:            *work,\n\t\tInterpTimeout:   *interpTimeout,\n\t\tPrintIR:         *printIR,\n\t\tDumpSSA:         *dumpSSA,\n\t\tVerifyIR:        *verifyIR,\n\t\tSkipDWARF:       *skipDwarf,\n\t\tSemaphore:       make(chan struct{}, *parallelism),\n\t\tDebug:           !*nodebug,\n\t\tPrintSizes:      *printSize,\n\t\tPrintStacks:     *printStacks,\n\t\tPrintAllocs:     printAllocs,\n\t\tTags:            []string(tags),\n\t\tTestConfig:      testConfig,\n\t\tGlobalValues:    globalVarValues,\n\t\tProgrammer:      *programmer,\n\t\tOpenOCDCommands: ocdCommands,\n\t\tLLVMFeatures:    *llvmFeatures,\n\t\tPrintJSON:       flagJSON,\n\t\tMonitor:         *monitor,\n\t\tBaudRate:        *baudrate,\n\t\tTimeout:         *timeout,\n\t\tWITPackage:      witPackage,\n\t\tWITWorld:        witWorld,\n\t}\n\tif *printCommands {\n\t\toptions.PrintCommands = printCommand\n\t}\n\n\tif extLDFlags != \"\" {\n\t\toptions.ExtLDFlags, err = shlex.Split(extLDFlags)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"could not parse -extldflags:\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n\n\terr = options.Verify()\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err.Error())\n\t\tusage(command)\n\t\tos.Exit(1)\n\t}\n\n\tif *cpuprofile != \"\" {\n\t\tf, err := os.Create(*cpuprofile)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"could not create CPU profile: \", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tdefer f.Close()\n\t\tif err := pprof.StartCPUProfile(f); err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"could not start CPU profile: \", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tdefer pprof.StopCPUProfile()\n\t}\n\n\tswitch command {\n\tcase \"build\":\n\t\tpkgName := \".\"\n\t\tif flag.NArg() == 1 {\n\t\t\tpkgName = filepath.ToSlash(flag.Arg(0))\n\t\t} else if flag.NArg() > 1 {\n\t\t\tfmt.Fprintln(os.Stderr, \"build only accepts a single positional argument: package name, but multiple were specified\")\n\t\t\tusage(command)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif options.Target == \"\" && filepath.Ext(outpath) == \".wasm\" {\n\t\t\toptions.Target = \"wasm\"\n\t\t}\n\n\t\terr := Build(pkgName, outpath, options)\n\t\thandleCompilerError(err)\n\tcase \"flash\", \"gdb\", \"lldb\":\n\t\tpkgName := filepath.ToSlash(flag.Arg(0))\n\t\tif command == \"flash\" {\n\t\t\terr := Flash(pkgName, *port, options)\n\t\t\thandleCompilerError(err)\n\t\t} else {\n\t\t\tif !options.Debug {\n\t\t\t\tfmt.Fprintln(os.Stderr, \"Debug disabled while running debugger?\")\n\t\t\t\tusage(command)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\terr := Debug(command, pkgName, *ocdOutput, options)\n\t\t\thandleCompilerError(err)\n\t\t}\n\tcase \"run\":\n\t\tif flag.NArg() < 1 {\n\t\t\tfmt.Fprintln(os.Stderr, \"No package specified.\")\n\t\t\tusage(command)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tpkgName := filepath.ToSlash(flag.Arg(0))\n\t\terr := Run(pkgName, options, flag.Args()[1:])\n\t\thandleCompilerError(err)\n\tcase \"test\":\n\t\tvar pkgNames []string\n\t\tfor i := 0; i < flag.NArg(); i++ {\n\t\t\tpkgNames = append(pkgNames, filepath.ToSlash(flag.Arg(i)))\n\t\t}\n\t\tif len(pkgNames) == 0 {\n\t\t\tpkgNames = []string{\".\"}\n\t\t}\n\n\t\texplicitPkgNames, err := getListOfPackages(pkgNames, options)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"cannot resolve packages: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tif outpath != \"\" && len(explicitPkgNames) > 1 {\n\t\t\tfmt.Println(\"cannot use -o flag with multiple packages\")\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tfail := make(chan struct{}, 1)\n\t\tvar wg sync.WaitGroup\n\t\tbufs := make([]testOutputBuf, len(explicitPkgNames))\n\t\tfor i := range bufs {\n\t\t\tbufs[i].done = make(chan struct{})\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Flush the output one test at a time.\n\t\t\t// This ensures that outputs from different tests are not mixed together.\n\t\t\tfor i := range bufs {\n\t\t\t\terr := bufs[i].flush(os.Stdout, os.Stderr)\n\t\t\t\tif err != nil {\n\t\t\t\t\t// There was an error writing to stdout or stderr, so we probably cannot print this.\n\t\t\t\t\tselect {\n\t\t\t\t\tcase fail <- struct{}{}:\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// Build and run the tests concurrently.\n\t\t// This uses an additional semaphore to reduce the memory usage.\n\t\ttestSema := make(chan struct{}, cap(options.Semaphore))\n\t\tfor i, pkgName := range explicitPkgNames {\n\t\t\tpkgName := pkgName\n\t\t\tbuf := &bufs[i]\n\t\t\ttestSema <- struct{}{}\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tdefer func() { <-testSema }()\n\t\t\t\tdefer close(buf.done)\n\t\t\t\tstdout := (*testStdout)(buf)\n\t\t\t\tstderr := (*testStderr)(buf)\n\t\t\t\tpassed, err := Test(pkgName, stdout, stderr, options, outpath)\n\t\t\t\tif err != nil {\n\t\t\t\t\twd, getwdErr := os.Getwd()\n\t\t\t\t\tif getwdErr != nil {\n\t\t\t\t\t\twd = \"\"\n\t\t\t\t\t}\n\t\t\t\t\tdiagnostics.CreateDiagnostics(err).WriteTo(os.Stderr, wd)\n\t\t\t\t}\n\t\t\t\tif !passed {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase fail <- struct{}{}:\n\t\t\t\t\tdefault:\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\t// Wait for all tests to finish.\n\t\twg.Wait()\n\t\tclose(fail)\n\t\tif _, fail := <-fail; fail {\n\t\t\tos.Exit(1)\n\t\t}\n\tcase \"monitor\":\n\t\tconfig, err := builder.NewConfig(options)\n\t\thandleCompilerError(err)\n\t\terr = Monitor(\"\", *port, config)\n\t\thandleCompilerError(err)\n\tcase \"ports\":\n\t\tserialPortInfo, err := ListSerialPorts()\n\t\thandleCompilerError(err)\n\t\tif len(serialPortInfo) == 0 {\n\t\t\tfmt.Println(\"No serial ports found.\")\n\t\t}\n\t\tfmt.Printf(\"%-20s %-9s %s\\n\", \"Port\", \"ID\", \"Boards\")\n\t\tfor _, s := range serialPortInfo {\n\t\t\tfmt.Printf(\"%-20s %4s:%4s %s\\n\", s.Name, s.VID, s.PID, s.Target)\n\t\t}\n\tcase \"targets\":\n\t\tspecs, err := compileopts.GetTargetSpecs()\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"could not list targets:\", err)\n\t\t\tos.Exit(1)\n\t\t\treturn\n\t\t}\n\t\tnames := []string{}\n\t\tfor key := range specs {\n\t\t\tnames = append(names, key)\n\t\t}\n\t\tsort.Strings(names)\n\t\tfor _, name := range names {\n\t\t\tfmt.Println(name)\n\t\t}\n\tcase \"info\":\n\t\tif flag.NArg() == 1 {\n\t\t\toptions.Target = flag.Arg(0)\n\t\t} else if flag.NArg() > 1 {\n\t\t\tfmt.Fprintln(os.Stderr, \"only one target name is accepted\")\n\t\t\tusage(command)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tconfig, err := builder.NewConfig(options)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tusage(command)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tconfig.GoMinorVersion = 0 // this avoids creating the list of Go1.x build tags.\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcachedGOROOT, err := loader.GetCachedGoroot(config)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tif flagJSON {\n\t\t\tjson, _ := json.MarshalIndent(struct {\n\t\t\t\tTarget     *compileopts.TargetSpec `json:\"target\"`\n\t\t\t\tGOROOT     string                  `json:\"goroot\"`\n\t\t\t\tGOOS       string                  `json:\"goos\"`\n\t\t\t\tGOARCH     string                  `json:\"goarch\"`\n\t\t\t\tGOARM      string                  `json:\"goarm\"`\n\t\t\t\tGOMIPS     string                  `json:\"gomips\"`\n\t\t\t\tBuildTags  []string                `json:\"build_tags\"`\n\t\t\t\tGC         string                  `json:\"garbage_collector\"`\n\t\t\t\tScheduler  string                  `json:\"scheduler\"`\n\t\t\t\tLLVMTriple string                  `json:\"llvm_triple\"`\n\t\t\t}{\n\t\t\t\tTarget:     config.Target,\n\t\t\t\tGOROOT:     cachedGOROOT,\n\t\t\t\tGOOS:       config.GOOS(),\n\t\t\t\tGOARCH:     config.GOARCH(),\n\t\t\t\tGOARM:      config.GOARM(),\n\t\t\t\tGOMIPS:     config.GOMIPS(),\n\t\t\t\tBuildTags:  config.BuildTags(),\n\t\t\t\tGC:         config.GC(),\n\t\t\t\tScheduler:  config.Scheduler(),\n\t\t\t\tLLVMTriple: config.Triple(),\n\t\t\t}, \"\", \"  \")\n\t\t\tfmt.Println(string(json))\n\t\t} else {\n\t\t\tfmt.Printf(\"LLVM triple:       %s\\n\", config.Triple())\n\t\t\tfmt.Printf(\"GOOS:              %s\\n\", config.GOOS())\n\t\t\tfmt.Printf(\"GOARCH:            %s\\n\", config.GOARCH())\n\t\t\tfmt.Printf(\"build tags:        %s\\n\", strings.Join(config.BuildTags(), \" \"))\n\t\t\tfmt.Printf(\"garbage collector: %s\\n\", config.GC())\n\t\t\tfmt.Printf(\"scheduler:         %s\\n\", config.Scheduler())\n\t\t\tfmt.Printf(\"cached GOROOT:     %s\\n\", cachedGOROOT)\n\t\t}\n\tcase \"list\":\n\t\tconfig, err := builder.NewConfig(options)\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\tusage(command)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tvar extraArgs []string\n\t\tif flagJSON {\n\t\t\textraArgs = append(extraArgs, \"-json\")\n\t\t}\n\t\tif flagDeps {\n\t\t\textraArgs = append(extraArgs, \"-deps\")\n\t\t}\n\t\tif flagTest {\n\t\t\textraArgs = append(extraArgs, \"-test\")\n\t\t}\n\t\tcmd, err := loader.List(config, extraArgs, flag.Args())\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"failed to run `go list`:\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t\terr = cmd.Run()\n\t\tif err != nil {\n\t\t\tif exitErr, ok := err.(*exec.ExitError); ok {\n\t\t\t\tos.Exit(exitErr.ExitCode())\n\t\t\t}\n\t\t\tfmt.Fprintln(os.Stderr, \"failed to run `go list`:\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\tcase \"clean\":\n\t\t// remove cache directory\n\t\terr := os.RemoveAll(goenv.Get(\"GOCACHE\"))\n\t\tif err != nil {\n\t\t\tfmt.Fprintln(os.Stderr, \"cannot clean cache:\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\tcase \"help\":\n\t\tcommand := \"\"\n\t\tif flag.NArg() >= 1 {\n\t\t\tcommand = flag.Arg(0)\n\t\t}\n\t\tusage(command)\n\tcase \"version\":\n\t\tgoversion := \"<unknown>\"\n\t\tif s, err := goenv.GorootVersionString(); err == nil {\n\t\t\tgoversion = s\n\t\t}\n\t\tfmt.Printf(\"tinygo version %s %s/%s (using go version %s and LLVM version %s)\\n\", goenv.Version(), runtime.GOOS, runtime.GOARCH, goversion, llvm.Version)\n\tcase \"env\":\n\t\tif flag.NArg() == 0 {\n\t\t\t// Show all environment variables.\n\t\t\tfor _, key := range goenv.Keys {\n\t\t\t\tfmt.Printf(\"%s=%#v\\n\", key, goenv.Get(key))\n\t\t\t}\n\t\t} else {\n\t\t\t// Show only one (or a few) environment variables.\n\t\t\tfor i := 0; i < flag.NArg(); i++ {\n\t\t\t\tfmt.Println(goenv.Get(flag.Arg(i)))\n\t\t\t}\n\t\t}\n\tdefault:\n\t\tfmt.Fprintln(os.Stderr, \"Unknown command:\", command)\n\t\tusage(\"\")\n\t\tos.Exit(1)\n\t}\n}\n\n// testOutputBuf is used to buffer the output of concurrent tests.\ntype testOutputBuf struct {\n\tmu             sync.Mutex\n\toutput         []outputEntry\n\tstdout, stderr io.Writer\n\touterr, errerr error\n\tdone           chan struct{}\n}\n\n// flush the output to stdout and stderr.\n// This waits until done is closed.\nfunc (b *testOutputBuf) flush(stdout, stderr io.Writer) error {\n\tb.mu.Lock()\n\n\tvar err error\n\tb.stdout = stdout\n\tb.stderr = stderr\n\tfor _, e := range b.output {\n\t\tvar w io.Writer\n\t\tvar errDst *error\n\t\tif e.stderr {\n\t\t\tw = stderr\n\t\t\terrDst = &b.errerr\n\t\t} else {\n\t\t\tw = stdout\n\t\t\terrDst = &b.outerr\n\t\t}\n\t\tif *errDst != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t_, werr := w.Write(e.data)\n\t\tif werr != nil {\n\t\t\tif err == nil {\n\t\t\t\terr = werr\n\t\t\t}\n\t\t\t*errDst = err\n\t\t}\n\t}\n\n\tb.mu.Unlock()\n\n\t<-b.done\n\n\treturn err\n}\n\n// testStdout writes stdout from a test to the output buffer.\ntype testStdout testOutputBuf\n\nfunc (out *testStdout) Write(data []byte) (int, error) {\n\tbuf := (*testOutputBuf)(out)\n\tbuf.mu.Lock()\n\n\tif buf.stdout != nil {\n\t\t// Write the output directly.\n\t\terr := out.outerr\n\t\tbuf.mu.Unlock()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn buf.stdout.Write(data)\n\t}\n\n\tdefer buf.mu.Unlock()\n\n\t// Append the output.\n\tif len(buf.output) == 0 || buf.output[len(buf.output)-1].stderr {\n\t\tbuf.output = append(buf.output, outputEntry{\n\t\t\tstderr: false,\n\t\t})\n\t}\n\tlast := &buf.output[len(buf.output)-1]\n\tlast.data = append(last.data, data...)\n\n\treturn len(data), nil\n}\n\n// testStderr writes stderr from a test to the output buffer.\ntype testStderr testOutputBuf\n\nfunc (out *testStderr) Write(data []byte) (int, error) {\n\tbuf := (*testOutputBuf)(out)\n\tbuf.mu.Lock()\n\n\tif buf.stderr != nil {\n\t\t// Write the output directly.\n\t\terr := out.errerr\n\t\tbuf.mu.Unlock()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn buf.stderr.Write(data)\n\t}\n\n\tdefer buf.mu.Unlock()\n\n\t// Append the output.\n\tif len(buf.output) == 0 || !buf.output[len(buf.output)-1].stderr {\n\t\tbuf.output = append(buf.output, outputEntry{\n\t\t\tstderr: true,\n\t\t})\n\t}\n\tlast := &buf.output[len(buf.output)-1]\n\tlast.data = append(last.data, data...)\n\n\treturn len(data), nil\n}\n\ntype outputEntry struct {\n\tstderr bool\n\tdata   []byte\n}\n\n// handleChdirFlag handles the -C flag before doing anything else.\n// The -C flag must be the first flag on the command line, to make it easy to find\n// even with commands that have custom flag parsing.\n// handleChdirFlag handles the flag by chdir'ing to the directory\n// and then removing that flag from the command line entirely.\n//\n// We have to handle the -C flag this way for two reasons:\n//\n//  1. Toolchain selection needs to be in the right directory to look for go.mod and go.work.\n//\n//  2. A toolchain switch later on reinvokes the new go command with the same arguments.\n//     The parent toolchain has already done the chdir; the child must not try to do it again.\n\nfunc handleChdirFlag() {\n\tused := 2 // b.c. command at os.Args[1]\n\tif used >= len(os.Args) {\n\t\treturn\n\t}\n\n\tvar dir string\n\tswitch a := os.Args[used]; {\n\tdefault:\n\t\treturn\n\n\tcase a == \"-C\", a == \"--C\":\n\t\tif used+1 >= len(os.Args) {\n\t\t\treturn\n\t\t}\n\t\tdir = os.Args[used+1]\n\t\tos.Args = slicesDelete(os.Args, used, used+2)\n\n\tcase strings.HasPrefix(a, \"-C=\"), strings.HasPrefix(a, \"--C=\"):\n\t\t_, dir, _ = strings.Cut(a, \"=\")\n\t\tos.Args = slicesDelete(os.Args, used, used+1)\n\t}\n\n\tif err := os.Chdir(dir); err != nil {\n\t\tfmt.Fprintln(os.Stderr, \"cannot chdir:\", err)\n\t\tos.Exit(1)\n\t}\n}\n\n// go1.19 compatibility: lacks slices package\nfunc slicesDelete[S ~[]E, E any](s S, i, j int) S {\n\t_ = s[i:j:len(s)] // bounds check\n\n\tif i == j {\n\t\treturn s\n\t}\n\n\treturn append(s[:i], s[j:]...)\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 28.3671875,
          "content": "package main\n\n// This file tests the compiler by running Go files in testdata/*.go and\n// comparing their output with the expected output in testdata/*.txt.\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"flag\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aykevl/go-wasm\"\n\t\"github.com/tetratelabs/wazero\"\n\t\"github.com/tetratelabs/wazero/api\"\n\t\"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1\"\n\t\"github.com/tetratelabs/wazero/sys\"\n\t\"github.com/tinygo-org/tinygo/builder\"\n\t\"github.com/tinygo-org/tinygo/compileopts\"\n\t\"github.com/tinygo-org/tinygo/diagnostics\"\n\t\"github.com/tinygo-org/tinygo/goenv\"\n)\n\nconst TESTDATA = \"testdata\"\n\nvar testTarget = flag.String(\"target\", \"\", \"override test target\")\n\nvar supportedLinuxArches = map[string]string{\n\t\"AMD64Linux\": \"linux/amd64\",\n\t\"X86Linux\":   \"linux/386\",\n\t\"ARMLinux\":   \"linux/arm/6\",\n\t\"ARM64Linux\": \"linux/arm64\",\n\t\"MIPSLinux\":  \"linux/mips/hardfloat\",\n\t\"WASIp1\":     \"wasip1/wasm\",\n}\n\nfunc init() {\n\tmajor, _, _ := goenv.GetGorootVersion()\n\tif major < 21 {\n\t\t// Go 1.20 backwards compatibility.\n\t\t// Should be removed once we drop support for Go 1.20.\n\t\tdelete(supportedLinuxArches, \"WASIp1\")\n\t}\n}\n\nvar sema = make(chan struct{}, runtime.NumCPU())\n\nfunc TestBuild(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []string{\n\t\t\"alias.go\",\n\t\t\"atomic.go\",\n\t\t\"binop.go\",\n\t\t\"calls.go\",\n\t\t\"cgo/\",\n\t\t\"channel.go\",\n\t\t\"embed/\",\n\t\t\"float.go\",\n\t\t\"gc.go\",\n\t\t\"generics.go\",\n\t\t\"goroutines.go\",\n\t\t\"init.go\",\n\t\t\"init_multi.go\",\n\t\t\"interface.go\",\n\t\t\"json.go\",\n\t\t\"map.go\",\n\t\t\"math.go\",\n\t\t\"oldgo/\",\n\t\t\"print.go\",\n\t\t\"reflect.go\",\n\t\t\"signal.go\",\n\t\t\"slice.go\",\n\t\t\"sort.go\",\n\t\t\"stdlib.go\",\n\t\t\"string.go\",\n\t\t\"structs.go\",\n\t\t\"testing.go\",\n\t\t\"timers.go\",\n\t\t\"zeroalloc.go\",\n\t}\n\n\t// Go 1.21 made some changes to the language, which we can only test when\n\t// we're actually on Go 1.21.\n\t_, minor, err := goenv.GetGorootVersion()\n\tif err != nil {\n\t\tt.Fatal(\"could not get version:\", minor)\n\t}\n\tif minor >= 21 {\n\t\ttests = append(tests, \"go1.21.go\")\n\t}\n\tif minor >= 22 {\n\t\ttests = append(tests, \"go1.22/\")\n\t}\n\tif minor >= 23 {\n\t\ttests = append(tests, \"go1.23/\")\n\t}\n\n\tif *testTarget != \"\" {\n\t\t// This makes it possible to run one specific test (instead of all),\n\t\t// which is especially useful to quickly check whether some changes\n\t\t// affect a particular target architecture.\n\t\trunPlatTests(optionsFromTarget(*testTarget, sema), tests, t)\n\t\treturn\n\t}\n\n\tt.Run(\"Host\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trunPlatTests(optionsFromTarget(\"\", sema), tests, t)\n\t})\n\n\t// Test a few build options.\n\tt.Run(\"build-options\", func(t *testing.T) {\n\t\tt.Parallel()\n\n\t\t// Test with few optimizations enabled (no inlining, etc).\n\t\tt.Run(\"opt=1\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\topts := optionsFromTarget(\"\", sema)\n\t\t\topts.Opt = \"1\"\n\t\t\trunTestWithConfig(\"stdlib.go\", t, opts, nil, nil)\n\t\t})\n\n\t\t// Test with only the bare minimum of optimizations enabled.\n\t\t// TODO: fix this for stdlib.go, which currently fails.\n\t\tt.Run(\"opt=0\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\topts := optionsFromTarget(\"\", sema)\n\t\t\topts.Opt = \"0\"\n\t\t\trunTestWithConfig(\"print.go\", t, opts, nil, nil)\n\t\t})\n\n\t\tt.Run(\"ldflags\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\topts := optionsFromTarget(\"\", sema)\n\t\t\topts.GlobalValues = map[string]map[string]string{\n\t\t\t\t\"main\": {\n\t\t\t\t\t\"someGlobal\": \"foobar\",\n\t\t\t\t},\n\t\t\t}\n\t\t\trunTestWithConfig(\"ldflags.go\", t, opts, nil, nil)\n\t\t})\n\t})\n\n\tif testing.Short() {\n\t\t// Don't test other targets when the -short flag is used. Only test the\n\t\t// host system.\n\t\treturn\n\t}\n\n\tt.Run(\"EmulatedCortexM3\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trunPlatTests(optionsFromTarget(\"cortex-m-qemu\", sema), tests, t)\n\t})\n\n\tt.Run(\"EmulatedRISCV\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trunPlatTests(optionsFromTarget(\"riscv-qemu\", sema), tests, t)\n\t})\n\n\tt.Run(\"AVR\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\trunPlatTests(optionsFromTarget(\"simavr\", sema), tests, t)\n\t})\n\n\tif runtime.GOOS == \"linux\" {\n\t\tfor name, osArch := range supportedLinuxArches {\n\t\t\toptions := optionsFromOSARCH(osArch, sema)\n\t\t\tif options.GOARCH != runtime.GOARCH { // Native architecture already run above.\n\t\t\t\tt.Run(name, func(t *testing.T) {\n\t\t\t\t\trunPlatTests(options, tests, t)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tt.Run(\"MIPS little-endian\", func(t *testing.T) {\n\t\t\t// Run a single test for GOARCH=mipsle to see whether it works at\n\t\t\t// all. It is already mostly tested because GOARCH=mips and\n\t\t\t// GOARCH=mipsle are so similar, but it's good to have an extra test\n\t\t\t// to be sure.\n\t\t\tt.Parallel()\n\t\t\toptions := optionsFromOSARCH(\"linux/mipsle/softfloat\", sema)\n\t\t\trunTest(\"cgo/\", options, t, nil, nil)\n\t\t})\n\t\tt.Run(\"WebAssembly\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunPlatTests(optionsFromTarget(\"wasm\", sema), tests, t)\n\t\t})\n\t\tt.Run(\"WASI\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunPlatTests(optionsFromTarget(\"wasip1\", sema), tests, t)\n\t\t})\n\t\tt.Run(\"WASIp2\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunPlatTests(optionsFromTarget(\"wasip2\", sema), tests, t)\n\t\t})\n\t}\n}\n\nfunc runPlatTests(options compileopts.Options, tests []string, t *testing.T) {\n\temuCheck(t, options)\n\n\tspec, err := compileopts.LoadTarget(&options)\n\tif err != nil {\n\t\tt.Fatal(\"failed to load target spec:\", err)\n\t}\n\n\t// FIXME: this should really be:\n\t// isWebAssembly := strings.HasPrefix(spec.Triple, \"wasm\")\n\tisWASI := strings.HasPrefix(options.Target, \"wasi\")\n\tisWebAssembly := isWASI || strings.HasPrefix(options.Target, \"wasm\") || (options.Target == \"\" && strings.HasPrefix(options.GOARCH, \"wasm\"))\n\tisBaremetal := options.Target == \"simavr\" || options.Target == \"cortex-m-qemu\" || options.Target == \"riscv-qemu\"\n\n\tfor _, name := range tests {\n\t\tif options.GOOS == \"linux\" && (options.GOARCH == \"arm\" || options.GOARCH == \"386\") {\n\t\t\tswitch name {\n\t\t\tcase \"timers.go\":\n\t\t\t\t// Timer tests do not work because syscall.seek is implemented\n\t\t\t\t// as Assembly in mainline Go and causes linker failure\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif options.GOOS == \"linux\" && (options.GOARCH == \"mips\" || options.GOARCH == \"mipsle\") {\n\t\t\tif name == \"atomic.go\" || name == \"timers.go\" {\n\t\t\t\t// 64-bit atomic operations aren't currently supported on MIPS.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif options.GOOS == \"linux\" && options.GOARCH == \"mips\" {\n\t\t\tif name == \"cgo/\" {\n\t\t\t\t// CGo isn't supported yet on big-endian systems (needs updates\n\t\t\t\t// to bitfield access methods).\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif options.Target == \"simavr\" {\n\t\t\t// Not all tests are currently supported on AVR.\n\t\t\t// Skip the ones that aren't.\n\t\t\tswitch name {\n\t\t\tcase \"reflect.go\":\n\t\t\t\t// Reflect tests do not run correctly, probably because of the\n\t\t\t\t// limited amount of memory.\n\t\t\t\tcontinue\n\n\t\t\tcase \"gc.go\":\n\t\t\t\t// Does not pass due to high mark false positive rate.\n\t\t\t\tcontinue\n\n\t\t\tcase \"json.go\", \"stdlib.go\", \"testing.go\":\n\t\t\t\t// Too big for AVR. Doesn't fit in flash/RAM.\n\t\t\t\tcontinue\n\n\t\t\tcase \"math.go\":\n\t\t\t\t// Needs newer picolibc version (for sqrt).\n\t\t\t\tcontinue\n\n\t\t\tcase \"cgo/\":\n\t\t\t\t// CGo function pointers don't work on AVR (needs LLVM 16 and\n\t\t\t\t// some compiler changes).\n\t\t\t\tcontinue\n\n\t\t\tcase \"timers.go\":\n\t\t\t\t// Crashes starting with Go 1.23.\n\t\t\t\t// Bug: https://github.com/llvm/llvm-project/issues/104032\n\t\t\t\tcontinue\n\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\tif options.Target == \"wasip2\" {\n\t\t\tswitch name {\n\t\t\tcase \"cgo/\":\n\t\t\t\t// waisp2 use our own libc; cgo tests fail\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tif isWebAssembly || isBaremetal || options.GOOS == \"windows\" {\n\t\t\tswitch name {\n\t\t\tcase \"signal.go\":\n\t\t\t\t// Signals only work on POSIX-like systems.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tname := name // redefine to avoid race condition\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunTest(name, options, t, nil, nil)\n\t\t})\n\t}\n\tif !strings.HasPrefix(spec.Emulator, \"simavr \") {\n\t\tt.Run(\"env.go\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunTest(\"env.go\", options, t, []string{\"first\", \"second\"}, []string{\"ENV1=VALUE1\", \"ENV2=VALUE2\"})\n\t\t})\n\t}\n\tif isWebAssembly {\n\t\tt.Run(\"alias.go-scheduler-none\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\toptions := compileopts.Options(options)\n\t\t\toptions.Scheduler = \"none\"\n\t\t\trunTest(\"alias.go\", options, t, nil, nil)\n\t\t})\n\t}\n\tif options.Target == \"\" || isWASI {\n\t\tt.Run(\"filesystem.go\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunTest(\"filesystem.go\", options, t, nil, nil)\n\t\t})\n\t}\n\tif options.Target == \"\" || options.Target == \"wasm\" || isWASI {\n\t\tt.Run(\"rand.go\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunTest(\"rand.go\", options, t, nil, nil)\n\t\t})\n\t}\n\tif !isWebAssembly {\n\t\t// The recover() builtin isn't supported yet on WebAssembly and Windows.\n\t\tt.Run(\"recover.go\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trunTest(\"recover.go\", options, t, nil, nil)\n\t\t})\n\t}\n}\n\nfunc emuCheck(t *testing.T, options compileopts.Options) {\n\t// Check if the emulator is installed.\n\tspec, err := compileopts.LoadTarget(&options)\n\tif err != nil {\n\t\tt.Fatal(\"failed to load target spec:\", err)\n\t}\n\tif spec.Emulator != \"\" {\n\t\temulatorCommand := strings.SplitN(spec.Emulator, \" \", 2)[0]\n\t\t_, err := exec.LookPath(emulatorCommand)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, exec.ErrNotFound) {\n\t\t\t\tt.Skipf(\"emulator not installed: %q\", emulatorCommand)\n\t\t\t}\n\n\t\t\tt.Errorf(\"searching for emulator: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc optionsFromTarget(target string, sema chan struct{}) compileopts.Options {\n\tseparators := strings.Count(target, \"/\")\n\tif (separators == 1 || separators == 2) && !strings.HasSuffix(target, \".json\") {\n\t\treturn optionsFromOSARCH(target, sema)\n\t}\n\treturn compileopts.Options{\n\t\t// GOOS/GOARCH are only used if target == \"\"\n\t\tGOOS:          goenv.Get(\"GOOS\"),\n\t\tGOARCH:        goenv.Get(\"GOARCH\"),\n\t\tGOARM:         goenv.Get(\"GOARM\"),\n\t\tGOMIPS:        goenv.Get(\"GOMIPS\"),\n\t\tTarget:        target,\n\t\tSemaphore:     sema,\n\t\tInterpTimeout: 180 * time.Second,\n\t\tDebug:         true,\n\t\tVerifyIR:      true,\n\t\tOpt:           \"z\",\n\t}\n}\n\n// optionsFromOSARCH returns a set of options based on the \"osarch\" string. This\n// string is in the form of \"os/arch/subarch\", with the subarch only sometimes\n// being necessary. Examples are \"darwin/amd64\" or \"linux/arm/7\".\nfunc optionsFromOSARCH(osarch string, sema chan struct{}) compileopts.Options {\n\tparts := strings.Split(osarch, \"/\")\n\toptions := compileopts.Options{\n\t\tGOOS:          parts[0],\n\t\tGOARCH:        parts[1],\n\t\tSemaphore:     sema,\n\t\tInterpTimeout: 180 * time.Second,\n\t\tDebug:         true,\n\t\tVerifyIR:      true,\n\t\tOpt:           \"z\",\n\t}\n\tswitch options.GOARCH {\n\tcase \"arm\":\n\t\toptions.GOARM = parts[2]\n\tcase \"mips\", \"mipsle\":\n\t\toptions.GOMIPS = parts[2]\n\t}\n\treturn options\n}\n\nfunc runTest(name string, options compileopts.Options, t *testing.T, cmdArgs, environmentVars []string) {\n\trunTestWithConfig(name, t, options, cmdArgs, environmentVars)\n}\n\nfunc runTestWithConfig(name string, t *testing.T, options compileopts.Options, cmdArgs, environmentVars []string) {\n\t// Get the expected output for this test.\n\t// Note: not using filepath.Join as it strips the path separator at the end\n\t// of the path.\n\tpath := TESTDATA + \"/\" + name\n\t// Get the expected output for this test.\n\texpectedOutputPath := path[:len(path)-3] + \".txt\"\n\tpkgName := \"./\" + path\n\tif path[len(path)-1] == '/' {\n\t\texpectedOutputPath = path + \"out.txt\"\n\t\toptions.Directory = path\n\t\tpkgName = \".\"\n\t}\n\n\tconfig, err := builder.NewConfig(&options)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Build the test binary.\n\tstdout := &bytes.Buffer{}\n\t_, err = buildAndRun(pkgName, config, stdout, cmdArgs, environmentVars, time.Minute, func(cmd *exec.Cmd, result builder.BuildResult) error {\n\t\treturn cmd.Run()\n\t})\n\tif err != nil {\n\t\tw := &bytes.Buffer{}\n\t\tdiagnostics.CreateDiagnostics(err).WriteTo(w, \"\")\n\t\tfor _, line := range strings.Split(strings.TrimRight(w.String(), \"\\n\"), \"\\n\") {\n\t\t\tt.Log(line)\n\t\t}\n\t\tif stdout.Len() != 0 {\n\t\t\tt.Logf(\"output:\\n%s\", stdout.String())\n\t\t}\n\t\tt.Fail()\n\t\treturn\n\t}\n\n\tactual := stdout.Bytes()\n\tif config.EmulatorName() == \"simavr\" {\n\t\t// Strip simavr log formatting.\n\t\tactual = bytes.Replace(actual, []byte{0x1b, '[', '3', '2', 'm'}, nil, -1)\n\t\tactual = bytes.Replace(actual, []byte{0x1b, '[', '0', 'm'}, nil, -1)\n\t\tactual = bytes.Replace(actual, []byte{'.', '.', '\\n'}, []byte{'\\n'}, -1)\n\t\tactual = bytes.Replace(actual, []byte{'\\n', '.', '\\n'}, []byte{'\\n', '\\n'}, -1)\n\t}\n\tif name == \"testing.go\" {\n\t\t// Strip actual time.\n\t\tre := regexp.MustCompile(`\\([0-9]\\.[0-9][0-9]s\\)`)\n\t\tactual = re.ReplaceAllLiteral(actual, []byte{'(', '0', '.', '0', '0', 's', ')'})\n\t}\n\n\t// Check whether the command ran successfully.\n\tif err != nil {\n\t\tt.Error(\"failed to run:\", err)\n\t}\n\tcheckOutput(t, expectedOutputPath, actual)\n\n\tif t.Failed() {\n\t\tr := bufio.NewReader(bytes.NewReader(actual))\n\t\tfor {\n\t\t\tline, err := r.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tt.Log(\"stdout:\", line[:len(line)-1])\n\t\t}\n\t\tt.Fail()\n\t}\n}\n\n// Test WebAssembly files for certain properties.\nfunc TestWebAssembly(t *testing.T) {\n\tt.Parallel()\n\ttype testCase struct {\n\t\tname          string\n\t\ttarget        string\n\t\tpanicStrategy string\n\t\timports       []string\n\t}\n\tfor _, tc := range []testCase{\n\t\t// Test whether there really are no imports when using -panic=trap. This\n\t\t// tests the bugfix for https://github.com/tinygo-org/tinygo/issues/4161.\n\t\t{name: \"panic-default\", target: \"wasip1\", imports: []string{\"wasi_snapshot_preview1.fd_write\", \"wasi_snapshot_preview1.random_get\"}},\n\t\t{name: \"panic-trap\", target: \"wasm-unknown\", panicStrategy: \"trap\", imports: []string{}},\n\t} {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\ttmpdir := t.TempDir()\n\t\t\toptions := optionsFromTarget(tc.target, sema)\n\t\t\toptions.PanicStrategy = tc.panicStrategy\n\t\t\tconfig, err := builder.NewConfig(&options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tresult, err := builder.Build(\"testdata/trivialpanic.go\", \".wasm\", tmpdir, config)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"failed to build binary:\", err)\n\t\t\t}\n\t\t\tf, err := os.Open(result.Binary)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"could not open output binary:\", err)\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\tmodule, err := wasm.Parse(f)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"could not parse output binary:\", err)\n\t\t\t}\n\n\t\t\t// Test the list of imports.\n\t\t\tif tc.imports != nil {\n\t\t\t\tvar imports []string\n\t\t\t\tfor _, section := range module.Sections {\n\t\t\t\t\tswitch section := section.(type) {\n\t\t\t\t\tcase *wasm.SectionImport:\n\t\t\t\t\t\tfor _, symbol := range section.Entries {\n\t\t\t\t\t\t\timports = append(imports, symbol.Module+\".\"+symbol.Field)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !stringSlicesEqual(imports, tc.imports) {\n\t\t\t\t\tt.Errorf(\"import list not as expected!\\nexpected: %v\\nactual:   %v\", tc.imports, imports)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc stringSlicesEqual(s1, s2 []string) bool {\n\t// We can use slices.Equal once we drop support for Go 1.20 (it was added in\n\t// Go 1.21).\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i, s := range s1 {\n\t\tif s != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc TestWasmExport(t *testing.T) {\n\tt.Parallel()\n\n\ttype testCase struct {\n\t\tname      string\n\t\ttarget    string\n\t\tbuildMode string\n\t\tscheduler string\n\t\tfile      string\n\t\tnoOutput  bool\n\t\tcommand   bool // call _start (command mode) instead of _initialize\n\t}\n\n\ttests := []testCase{\n\t\t// \"command mode\" WASI\n\t\t{\n\t\t\tname:    \"WASIp1-command\",\n\t\t\ttarget:  \"wasip1\",\n\t\t\tcommand: true,\n\t\t},\n\t\t// \"reactor mode\" WASI (with -buildmode=c-shared)\n\t\t{\n\t\t\tname:      \"WASIp1-reactor\",\n\t\t\ttarget:    \"wasip1\",\n\t\t\tbuildMode: \"c-shared\",\n\t\t},\n\t\t// Make sure reactor mode also works without a scheduler.\n\t\t{\n\t\t\tname:      \"WASIp1-reactor-noscheduler\",\n\t\t\ttarget:    \"wasip1\",\n\t\t\tbuildMode: \"c-shared\",\n\t\t\tscheduler: \"none\",\n\t\t\tfile:      \"wasmexport-noscheduler.go\",\n\t\t},\n\t\t// Test -target=wasm-unknown with the default build mode (which is\n\t\t// c-shared).\n\t\t{\n\t\t\tname:     \"wasm-unknown-reactor\",\n\t\t\ttarget:   \"wasm-unknown\",\n\t\t\tfile:     \"wasmexport-noscheduler.go\",\n\t\t\tnoOutput: true, // wasm-unknown cannot produce output\n\t\t},\n\t\t// Test -target=wasm-unknown with -buildmode=default, which makes it run\n\t\t// in command mode.\n\t\t{\n\t\t\tname:      \"wasm-unknown-command\",\n\t\t\ttarget:    \"wasm-unknown\",\n\t\t\tbuildMode: \"default\",\n\t\t\tfile:      \"wasmexport-noscheduler.go\",\n\t\t\tnoOutput:  true, // wasm-unknown cannot produce output\n\t\t\tcommand:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// Build the wasm binary.\n\t\t\ttmpdir := t.TempDir()\n\t\t\toptions := optionsFromTarget(tc.target, sema)\n\t\t\toptions.BuildMode = tc.buildMode\n\t\t\toptions.Scheduler = tc.scheduler\n\t\t\tbuildConfig, err := builder.NewConfig(&options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tfilename := \"wasmexport.go\"\n\t\t\tif tc.file != \"\" {\n\t\t\t\tfilename = tc.file\n\t\t\t}\n\t\t\tresult, err := builder.Build(\"testdata/\"+filename, \".wasm\", tmpdir, buildConfig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"failed to build binary:\", err)\n\t\t\t}\n\n\t\t\t// Read the wasm binary back into memory.\n\t\t\tdata, err := os.ReadFile(result.Binary)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"could not read wasm binary: \", err)\n\t\t\t}\n\n\t\t\t// Set up the wazero runtime.\n\t\t\toutput := &bytes.Buffer{}\n\t\t\tctx := context.Background()\n\t\t\tr := wazero.NewRuntimeWithConfig(ctx, wazero.NewRuntimeConfigInterpreter())\n\t\t\tdefer r.Close(ctx)\n\t\t\tconfig := wazero.NewModuleConfig().\n\t\t\t\tWithStdout(output).WithStderr(output).\n\t\t\t\tWithStartFunctions()\n\n\t\t\t// Prepare for testing.\n\t\t\tvar mod api.Module\n\t\t\tmustCall := func(results []uint64, err error) []uint64 {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(\"failed to run function:\", err)\n\t\t\t\t}\n\t\t\t\treturn results\n\t\t\t}\n\t\t\tcheckResult := func(name string, results []uint64, expected []uint64) {\n\t\t\t\tif len(results) != len(expected) {\n\t\t\t\t\tt.Errorf(\"%s: expected %v but got %v\", name, expected, results)\n\t\t\t\t}\n\t\t\t\tfor i, result := range results {\n\t\t\t\t\tif result != expected[i] {\n\t\t\t\t\t\tt.Errorf(\"%s: expected %v but got %v\", name, expected, results)\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trunTests := func() {\n\t\t\t\t// Test an exported function without params or return value.\n\t\t\t\tcheckResult(\"hello()\", mustCall(mod.ExportedFunction(\"hello\").Call(ctx)), nil)\n\n\t\t\t\t// Test that we can call an exported function more than once.\n\t\t\t\tcheckResult(\"add(3, 5)\", mustCall(mod.ExportedFunction(\"add\").Call(ctx, 3, 5)), []uint64{8})\n\t\t\t\tcheckResult(\"add(7, 9)\", mustCall(mod.ExportedFunction(\"add\").Call(ctx, 7, 9)), []uint64{16})\n\t\t\t\tcheckResult(\"add(6, 1)\", mustCall(mod.ExportedFunction(\"add\").Call(ctx, 6, 1)), []uint64{7})\n\n\t\t\t\t// Test that imported functions can call exported functions\n\t\t\t\t// again.\n\t\t\t\tcheckResult(\"reentrantCall(2, 3)\", mustCall(mod.ExportedFunction(\"reentrantCall\").Call(ctx, 2, 3)), []uint64{5})\n\t\t\t\tcheckResult(\"reentrantCall(1, 8)\", mustCall(mod.ExportedFunction(\"reentrantCall\").Call(ctx, 1, 8)), []uint64{9})\n\t\t\t}\n\n\t\t\t// Add wasip1 module.\n\t\t\twasi_snapshot_preview1.MustInstantiate(ctx, r)\n\n\t\t\t// Add custom \"tester\" module.\n\t\t\tcallOutside := func(a, b int32) int32 {\n\t\t\t\tresults, err := mod.ExportedFunction(\"add\").Call(ctx, uint64(a), uint64(b))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(\"could not call exported add function:\", err)\n\t\t\t\t}\n\t\t\t\treturn int32(results[0])\n\t\t\t}\n\t\t\tcallTestMain := func() {\n\t\t\t\trunTests()\n\t\t\t}\n\t\t\tbuilder := r.NewHostModuleBuilder(\"tester\")\n\t\t\tbuilder.NewFunctionBuilder().WithFunc(callOutside).Export(\"callOutside\")\n\t\t\tbuilder.NewFunctionBuilder().WithFunc(callTestMain).Export(\"callTestMain\")\n\t\t\t_, err = builder.Instantiate(ctx)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\t// Parse and instantiate the wasm.\n\t\t\tmod, err = r.InstantiateWithConfig(ctx, data, config)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"could not instantiate wasm module:\", err)\n\t\t\t}\n\n\t\t\t// Initialize the module and run the tests.\n\t\t\tif tc.command {\n\t\t\t\t// Call _start (the entry point), which calls\n\t\t\t\t// tester.callTestMain, which then runs all the tests.\n\t\t\t\t_, err := mod.ExportedFunction(\"_start\").Call(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif exitErr, ok := err.(*sys.ExitError); ok && exitErr.ExitCode() == 0 {\n\t\t\t\t\t\t// Exited with code 0. Nothing to worry about.\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.Error(\"failed to run _start:\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Run the _initialize call, because this is reactor mode wasm.\n\t\t\t\tmustCall(mod.ExportedFunction(\"_initialize\").Call(ctx))\n\t\t\t\trunTests()\n\t\t\t}\n\n\t\t\t// Check that the output matches the expected output.\n\t\t\t// (Skip this for wasm-unknown because it can't produce output).\n\t\t\tif !tc.noOutput {\n\t\t\t\tcheckOutput(t, \"testdata/wasmexport.txt\", output.Bytes())\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Test js.FuncOf (for syscall/js).\n// This test might be extended in the future to cover more cases in syscall/js.\nfunc TestWasmFuncOf(t *testing.T) {\n\t// Build the wasm binary.\n\ttmpdir := t.TempDir()\n\toptions := optionsFromTarget(\"wasm\", sema)\n\tbuildConfig, err := builder.NewConfig(&options)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tresult, err := builder.Build(\"testdata/wasmfunc.go\", \".wasm\", tmpdir, buildConfig)\n\tif err != nil {\n\t\tt.Fatal(\"failed to build binary:\", err)\n\t}\n\n\t// Test the resulting binary using NodeJS.\n\toutput := &bytes.Buffer{}\n\tcmd := exec.Command(\"node\", \"testdata/wasmfunc.js\", result.Binary, buildConfig.BuildMode())\n\tcmd.Stdout = output\n\tcmd.Stderr = output\n\terr = cmd.Run()\n\tif err != nil {\n\t\tt.Error(\"failed to run node:\", err)\n\t}\n\tcheckOutput(t, \"testdata/wasmfunc.txt\", output.Bytes())\n}\n\n// Test //go:wasmexport in JavaScript (using NodeJS).\nfunc TestWasmExportJS(t *testing.T) {\n\tt.Parallel()\n\ttype testCase struct {\n\t\tname      string\n\t\tbuildMode string\n\t}\n\n\ttests := []testCase{\n\t\t{name: \"default\"},\n\t\t{name: \"c-shared\", buildMode: \"c-shared\"},\n\t}\n\tfor _, tc := range tests {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// Build the wasm binary.\n\t\t\ttmpdir := t.TempDir()\n\t\t\toptions := optionsFromTarget(\"wasm\", sema)\n\t\t\toptions.BuildMode = tc.buildMode\n\t\t\tbuildConfig, err := builder.NewConfig(&options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tresult, err := builder.Build(\"testdata/wasmexport-noscheduler.go\", \".wasm\", tmpdir, buildConfig)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"failed to build binary:\", err)\n\t\t\t}\n\n\t\t\t// Test the resulting binary using NodeJS.\n\t\t\toutput := &bytes.Buffer{}\n\t\t\tcmd := exec.Command(\"node\", \"testdata/wasmexport.js\", result.Binary, buildConfig.BuildMode())\n\t\t\tcmd.Stdout = output\n\t\t\tcmd.Stderr = output\n\t\t\terr = cmd.Run()\n\t\t\tif err != nil {\n\t\t\t\tt.Error(\"failed to run node:\", err)\n\t\t\t}\n\t\t\tcheckOutput(t, \"testdata/wasmexport.txt\", output.Bytes())\n\t\t})\n\t}\n}\n\n// Test whether Go.run() (in wasm_exec.js) normally returns and returns the\n// right exit code.\nfunc TestWasmExit(t *testing.T) {\n\tt.Parallel()\n\n\ttype testCase struct {\n\t\tname   string\n\t\toutput string\n\t}\n\n\ttests := []testCase{\n\t\t{name: \"normal\", output: \"exit code: 0\\n\"},\n\t\t{name: \"exit-0\", output: \"exit code: 0\\n\"},\n\t\t{name: \"exit-0-sleep\", output: \"slept\\nexit code: 0\\n\"},\n\t\t{name: \"exit-1\", output: \"exit code: 1\\n\"},\n\t\t{name: \"exit-1-sleep\", output: \"slept\\nexit code: 1\\n\"},\n\t}\n\tfor _, tc := range tests {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\toptions := optionsFromTarget(\"wasm\", sema)\n\t\t\tbuildConfig, err := builder.NewConfig(&options)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tbuildConfig.Target.Emulator = \"node testdata/wasmexit.js {}\"\n\t\t\toutput := &bytes.Buffer{}\n\t\t\t_, err = buildAndRun(\"testdata/wasmexit.go\", buildConfig, output, []string{tc.name}, nil, time.Minute, func(cmd *exec.Cmd, result builder.BuildResult) error {\n\t\t\t\treturn cmd.Run()\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\texpected := \"wasmexit test: \" + tc.name + \"\\n\" + tc.output\n\t\t\tcheckOutputData(t, []byte(expected), output.Bytes())\n\t\t})\n\t}\n}\n\n// Check whether the output of a test equals the expected output.\nfunc checkOutput(t *testing.T, filename string, actual []byte) {\n\texpectedOutput, err := os.ReadFile(filename)\n\tif err != nil {\n\t\tt.Fatal(\"could not read output file:\", err)\n\t}\n\tcheckOutputData(t, expectedOutput, actual)\n}\n\nfunc checkOutputData(t *testing.T, expectedOutput, actual []byte) {\n\texpectedOutput = bytes.ReplaceAll(expectedOutput, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n\tactual = bytes.ReplaceAll(actual, []byte(\"\\r\\n\"), []byte(\"\\n\"))\n\n\tif !bytes.Equal(actual, expectedOutput) {\n\t\tt.Errorf(\"output did not match (expected %d bytes, got %d bytes):\", len(expectedOutput), len(actual))\n\t\tt.Error(string(Diff(\"expected\", expectedOutput, \"actual\", actual)))\n\t}\n}\n\nfunc TestTest(t *testing.T) {\n\tt.Parallel()\n\n\ttype targ struct {\n\t\tname string\n\t\topts compileopts.Options\n\t}\n\ttargs := []targ{\n\t\t// Host\n\t\t{\"Host\", optionsFromTarget(\"\", sema)},\n\t}\n\tif !testing.Short() {\n\t\tif runtime.GOOS == \"linux\" {\n\t\t\tfor name, osArch := range supportedLinuxArches {\n\t\t\t\toptions := optionsFromOSARCH(osArch, sema)\n\t\t\t\tif options.GOARCH != runtime.GOARCH { // Native architecture already run above.\n\t\t\t\t\ttargs = append(targs, targ{name, options})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttargs = append(targs,\n\t\t\t// QEMU microcontrollers\n\t\t\ttarg{\"EmulatedCortexM3\", optionsFromTarget(\"cortex-m-qemu\", sema)},\n\t\t\ttarg{\"EmulatedRISCV\", optionsFromTarget(\"riscv-qemu\", sema)},\n\n\t\t\t// Node/Wasmtime\n\t\t\ttarg{\"WASM\", optionsFromTarget(\"wasm\", sema)},\n\t\t\ttarg{\"WASI\", optionsFromTarget(\"wasip1\", sema)},\n\t\t)\n\t}\n\tfor _, targ := range targs {\n\t\ttarg := targ\n\t\tt.Run(targ.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\temuCheck(t, targ.opts)\n\n\t\t\tt.Run(\"Pass\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\t// Test a package which builds and passes normally.\n\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\tdefer wg.Wait()\n\n\t\t\t\tout := ioLogger(t, &wg)\n\t\t\t\tdefer out.Close()\n\n\t\t\t\topts := targ.opts\n\t\t\t\tpassed, err := Test(\"github.com/tinygo-org/tinygo/tests/testing/pass\", out, out, &opts, \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"test error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif !passed {\n\t\t\t\t\tt.Error(\"test failed\")\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"Fail\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\t// Test a package which builds fine but fails.\n\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\tdefer wg.Wait()\n\n\t\t\t\tout := ioLogger(t, &wg)\n\t\t\t\tdefer out.Close()\n\n\t\t\t\topts := targ.opts\n\t\t\t\tpassed, err := Test(\"github.com/tinygo-org/tinygo/tests/testing/fail\", out, out, &opts, \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"test error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif passed {\n\t\t\t\t\tt.Error(\"test passed\")\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tif targ.name != \"Host\" {\n\t\t\t\t// Emulated tests are somewhat slow, and these do not need to be run across every platform.\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tt.Run(\"Nothing\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\t// Test a package with no test files.\n\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\tdefer wg.Wait()\n\n\t\t\t\tout := ioLogger(t, &wg)\n\t\t\t\tdefer out.Close()\n\n\t\t\t\tvar output bytes.Buffer\n\t\t\t\topts := targ.opts\n\t\t\t\tpassed, err := Test(\"github.com/tinygo-org/tinygo/tests/testing/nothing\", io.MultiWriter(&output, out), out, &opts, \"\")\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"test error: %v\", err)\n\t\t\t\t}\n\t\t\t\tif !passed {\n\t\t\t\t\tt.Error(\"test failed\")\n\t\t\t\t}\n\t\t\t\tif !strings.Contains(output.String(), \"[no test files]\") {\n\t\t\t\t\tt.Error(\"missing [no test files] in output\")\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"BuildErr\", func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\t// Test a package which fails to build.\n\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\tdefer wg.Wait()\n\n\t\t\t\tout := ioLogger(t, &wg)\n\t\t\t\tdefer out.Close()\n\n\t\t\t\topts := targ.opts\n\t\t\t\tpassed, err := Test(\"github.com/tinygo-org/tinygo/tests/testing/builderr\", out, out, &opts, \"\")\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Error(\"test did not error\")\n\t\t\t\t}\n\t\t\t\tif passed {\n\t\t\t\t\tt.Error(\"test passed\")\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc ioLogger(t *testing.T, wg *sync.WaitGroup) io.WriteCloser {\n\tr, w := io.Pipe()\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tdefer r.Close()\n\n\t\tscanner := bufio.NewScanner(r)\n\t\tfor scanner.Scan() {\n\t\t\tt.Log(scanner.Text())\n\t\t}\n\t}()\n\n\treturn w\n}\n\nfunc TestGetListOfPackages(t *testing.T) {\n\topts := optionsFromTarget(\"\", sema)\n\ttests := []struct {\n\t\tpkgs          []string\n\t\texpectedPkgs  []string\n\t\texpectesError bool\n\t}{\n\t\t{\n\t\t\tpkgs: []string{\"./tests/testing/recurse/...\"},\n\t\t\texpectedPkgs: []string{\n\t\t\t\t\"github.com/tinygo-org/tinygo/tests/testing/recurse\",\n\t\t\t\t\"github.com/tinygo-org/tinygo/tests/testing/recurse/subdir\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tpkgs: []string{\"./tests/testing/pass\"},\n\t\t\texpectedPkgs: []string{\n\t\t\t\t\"github.com/tinygo-org/tinygo/tests/testing/pass\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tpkgs:          []string{\"./tests/testing\"},\n\t\t\texpectesError: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tactualPkgs, err := getListOfPackages(test.pkgs, &opts)\n\t\tif err != nil && !test.expectesError {\n\t\t\tt.Errorf(\"unexpected error: %v\", err)\n\t\t} else if err == nil && test.expectesError {\n\t\t\tt.Error(\"expected error, but got none\")\n\t\t}\n\n\t\tif !reflect.DeepEqual(test.expectedPkgs, actualPkgs) {\n\t\t\tt.Errorf(\"expected two slices to be equal, expected %v got %v\", test.expectedPkgs, actualPkgs)\n\t\t}\n\t}\n}\n\n// This TestMain is necessary because TinyGo may also be invoked to run certain\n// LLVM tools in a separate process. Not capturing these invocations would lead\n// to recursive tests.\nfunc TestMain(m *testing.M) {\n\tif len(os.Args) >= 2 {\n\t\tswitch os.Args[1] {\n\t\tcase \"clang\", \"ld.lld\", \"wasm-ld\":\n\t\t\t// Invoke a specific tool.\n\t\t\terr := builder.RunTool(os.Args[1], os.Args[2:]...)\n\t\t\tif err != nil {\n\t\t\t\t// The tool should have printed an error message already.\n\t\t\t\t// Don't print another error message here.\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t\tos.Exit(0)\n\t\t}\n\t}\n\n\t// Run normal tests.\n\tos.Exit(m.Run())\n}\n"
        },
        {
          "name": "misspell.csv",
          "type": "blob",
          "size": 0.77734375,
          "content": "acces,access\nacuire,acquire\naddess,address\nadust,adjust\nallcoate,allocate\nalloated,allocated\narchtecture,architecture\narcive,archive\nardiuno,arduino\nbeconfigured,be configured\ncalcluate,calculate\ncolum,column\nconfigration,configuration\ncontants,constants\ncricital,critical\ndeffered,deferred\nevaulator,evaluator\nevironment,environment\nfreqency,frequency\nfrquency,frequency\nimplmented,implemented\ninterrput,interrupt\ninterrut,interrupt\ninterupt,interrupt\nmeasuing,measuring\nnumer of,number of\norignal,original\noverrided,overridden\npoiners,pointers\npoitner,pointer\nprobbably,probably\nrecogized,recognized\nrefection,reflection\nrequries,requires\nsatisifying,satisfying\nsimulataneously,simultaneously\nsuggets,suggests\ntransmition,transmission\nundefied,undefined\nunecessary,unnecessary\nunsiged,unsigned\n"
        },
        {
          "name": "monitor.go",
          "type": "blob",
          "size": 9.9931640625,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"debug/dwarf\"\n\t\"debug/elf\"\n\t\"debug/macho\"\n\t\"debug/pe\"\n\t\"errors\"\n\t\"fmt\"\n\t\"go/token\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/mattn/go-tty\"\n\t\"github.com/tinygo-org/tinygo/compileopts\"\n\n\t\"go.bug.st/serial\"\n\t\"go.bug.st/serial/enumerator\"\n)\n\n// Monitor connects to the given port and reads/writes the serial port.\nfunc Monitor(executable, port string, config *compileopts.Config) error {\n\tconst timeout = time.Second * 3\n\tvar exit func() // function to be called before exiting\n\tvar serialConn io.ReadWriter\n\n\tif config.Options.Serial == \"rtt\" {\n\t\t// Use the RTT interface, which is documented (in part) here:\n\t\t// https://wiki.segger.com/RTT\n\n\t\t// Try to find the \"machine.rttSerialInstance\" symbol, which is the RTT\n\t\t// control block.\n\t\tfile, err := elf.Open(executable)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not open ELF file to determine RTT control block: %w\", err)\n\t\t}\n\t\tdefer file.Close()\n\t\tsymbols, err := file.Symbols()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"could not read ELF symbol table to determine RTT control block: %w\", err)\n\t\t}\n\t\tvar address uint64\n\t\tfor _, symbol := range symbols {\n\t\t\tif symbol.Name == \"machine.rttSerialInstance\" {\n\t\t\t\taddress = symbol.Value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif address == 0 {\n\t\t\treturn fmt.Errorf(\"could not find RTT control block in ELF file\")\n\t\t}\n\n\t\t// Start an openocd process in the background.\n\t\targs, err := config.OpenOCDConfiguration()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\targs = append(args,\n\t\t\t\"-c\", fmt.Sprintf(\"rtt setup 0x%x 16 \\\"SEGGER RTT\\\"\", address),\n\t\t\t\"-c\", \"init\",\n\t\t\t\"-c\", \"rtt server start 0 0\")\n\t\tcmd := executeCommand(config.Options, \"openocd\", args...)\n\t\tstderr, err := cmd.StderrPipe()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.Stdout = os.Stdout\n\t\terr = cmd.Start()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer cmd.Process.Kill()\n\t\texit = func() {\n\t\t\t// Make sure the openocd process is terminated at exit.\n\t\t\t// This does not happen through the defer above when exiting through\n\t\t\t// os.Exit.\n\t\t\tcmd.Process.Kill()\n\t\t}\n\n\t\t// Read the stderr, which logs various important messages we need.\n\t\tr := bufio.NewReader(stderr)\n\t\tvar telnet net.Conn\n\t\tvar timeoutAt time.Time\n\t\tfor {\n\t\t\t// Read the next line from the openocd process.\n\t\t\tlineBytes, err := r.ReadBytes('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tline := string(lineBytes)\n\n\t\t\tif line == \"Info : rtt: No control block found\\n\" {\n\t\t\t\t// Message that is sent back when OpenOCD can't find the control\n\t\t\t\t// block after a 'rtt start' message.\n\t\t\t\tif time.Now().After(timeoutAt) {\n\t\t\t\t\treturn fmt.Errorf(\"RTT timeout (could not locate RTT control block at 0x%08x)\", address)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond * 100)\n\t\t\t\ttelnet.Write([]byte(\"rtt start\\r\\n\"))\n\t\t\t} else if strings.HasPrefix(line, \"Info : Listening on port\") {\n\t\t\t\t// We need two different ports for controlling OpenOCD\n\t\t\t\t// (typically port 4444) and the RTT channel 0 socket (arbitrary\n\t\t\t\t// port).\n\t\t\t\tvar port int\n\t\t\t\tvar protocol string\n\t\t\t\tfmt.Sscanf(line, \"Info : Listening on port %d for %s connections\\n\", &port, &protocol)\n\t\t\t\tif protocol == \"telnet\" && telnet == nil {\n\t\t\t\t\t// Connect to the \"telnet\" command line interface.\n\t\t\t\t\ttelnet, err = net.Dial(\"tcp4\", fmt.Sprintf(\"localhost:%d\", port))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\t// Tell OpenOCD to start scanning for the RTT control block.\n\t\t\t\t\ttelnet.Write([]byte(\"rtt start\\r\\n\"))\n\t\t\t\t\t// Also make sure we will time out if the control block just\n\t\t\t\t\t// can't be found.\n\t\t\t\t\ttimeoutAt = time.Now().Add(timeout)\n\t\t\t\t} else if protocol == \"rtt\" {\n\t\t\t\t\t// Connect to the RTT channel, for both stdin and stdout.\n\t\t\t\t\tconn, err := net.Dial(\"tcp4\", fmt.Sprintf(\"localhost:%d\", port))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tserialConn = conn\n\t\t\t\t}\n\t\t\t} else if strings.HasPrefix(line, \"Info : rtt: Control block found at\") {\n\t\t\t\t// Connection established!\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t} else { // -serial=uart or -serial=usb\n\t\tvar err error\n\t\twait := 300\n\t\tfor i := 0; i <= wait; i++ {\n\t\t\tport, err = getDefaultPort(port, config.Target.SerialPort)\n\t\t\tif err != nil {\n\t\t\t\tif i < wait {\n\t\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tbr := config.Options.BaudRate\n\t\tif br <= 0 {\n\t\t\tbr = 115200\n\t\t}\n\n\t\twait = 300\n\t\tvar p serial.Port\n\t\tfor i := 0; i <= wait; i++ {\n\t\t\tp, err = serial.Open(port, &serial.Mode{BaudRate: br})\n\t\t\tif err != nil {\n\t\t\t\tif i < wait {\n\t\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tserialConn = p\n\t\t\tbreak\n\t\t}\n\t\tdefer p.Close()\n\t}\n\n\ttty, err := tty.Open()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer tty.Close()\n\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, os.Interrupt)\n\tdefer signal.Stop(sig)\n\n\tgo func() {\n\t\t<-sig\n\t\ttty.Close()\n\t\tif exit != nil {\n\t\t\texit()\n\t\t}\n\t\tos.Exit(0)\n\t}()\n\n\tfmt.Printf(\"Connected to %s. Press Ctrl-C to exit.\\n\", port)\n\n\terrCh := make(chan error, 1)\n\n\tgo func() {\n\t\tbuf := make([]byte, 100*1024)\n\t\twriter := newOutputWriter(os.Stdout, executable)\n\t\tfor {\n\t\t\tn, err := serialConn.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- fmt.Errorf(\"read error: %w\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\twriter.Write(buf[:n])\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\tr, err := tty.ReadRune()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif r == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tserialConn.Write([]byte(string(r)))\n\t\t}\n\t}()\n\n\treturn <-errCh\n}\n\n// SerialPortInfo is a structure that holds information about the port and its\n// associated TargetSpec.\ntype SerialPortInfo struct {\n\tName   string\n\tIsUSB  bool\n\tVID    string\n\tPID    string\n\tTarget string\n\tSpec   *compileopts.TargetSpec\n}\n\n// ListSerialPort returns serial port information and any detected TinyGo\n// target.\nfunc ListSerialPorts() ([]SerialPortInfo, error) {\n\tmaps, err := compileopts.GetTargetSpecs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tportsList, err := enumerator.GetDetailedPortsList()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tserialPortInfo := []SerialPortInfo{}\n\tfor _, p := range portsList {\n\t\tinfo := SerialPortInfo{\n\t\t\tName:  p.Name,\n\t\t\tIsUSB: p.IsUSB,\n\t\t\tVID:   p.VID,\n\t\t\tPID:   p.PID,\n\t\t}\n\t\tvid := strings.ToLower(p.VID)\n\t\tpid := strings.ToLower(p.PID)\n\t\tfor k, v := range maps {\n\t\t\tusbInterfaces := v.SerialPort\n\t\t\tfor _, s := range usbInterfaces {\n\t\t\t\tparts := strings.Split(s, \":\")\n\t\t\t\tif len(parts) != 2 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif vid == strings.ToLower(parts[0]) && pid == strings.ToLower(parts[1]) {\n\t\t\t\t\tinfo.Target = k\n\t\t\t\t\tinfo.Spec = v\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tserialPortInfo = append(serialPortInfo, info)\n\t}\n\n\treturn serialPortInfo, nil\n}\n\nvar addressMatch = regexp.MustCompile(`^panic: runtime error at 0x([0-9a-f]+): `)\n\n// Extract the address from the \"panic: runtime error at\" message.\nfunc extractPanicAddress(line []byte) uint64 {\n\tmatches := addressMatch.FindSubmatch(line)\n\tif matches != nil {\n\t\taddress, err := strconv.ParseUint(string(matches[1]), 16, 64)\n\t\tif err == nil {\n\t\t\treturn address\n\t\t}\n\t}\n\treturn 0\n}\n\n// Convert an address in the binary to a source address location.\nfunc addressToLine(executable string, address uint64) (token.Position, error) {\n\tdata, err := readDWARF(executable)\n\tif err != nil {\n\t\treturn token.Position{}, err\n\t}\n\tr := data.Reader()\n\n\tfor {\n\t\te, err := r.Next()\n\t\tif err != nil {\n\t\t\treturn token.Position{}, err\n\t\t}\n\t\tif e == nil {\n\t\t\tbreak\n\t\t}\n\t\tswitch e.Tag {\n\t\tcase dwarf.TagCompileUnit:\n\t\t\tr.SkipChildren()\n\t\t\tlr, err := data.LineReader(e)\n\t\t\tif err != nil {\n\t\t\t\treturn token.Position{}, err\n\t\t\t}\n\t\t\tvar lineEntry = dwarf.LineEntry{\n\t\t\t\tEndSequence: true,\n\t\t\t}\n\t\t\tfor {\n\t\t\t\t// Read the next .debug_line entry.\n\t\t\t\tprevLineEntry := lineEntry\n\t\t\t\terr := lr.Next(&lineEntry)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\treturn token.Position{}, err\n\t\t\t\t}\n\n\t\t\t\tif prevLineEntry.EndSequence && lineEntry.Address == 0 {\n\t\t\t\t\t// Tombstone value. This symbol has been removed, for\n\t\t\t\t\t// example by the --gc-sections linker flag. It is still\n\t\t\t\t\t// here in the debug information because the linker can't\n\t\t\t\t\t// just remove this reference.\n\t\t\t\t\t// Read until the next EndSequence so that this sequence is\n\t\t\t\t\t// skipped.\n\t\t\t\t\t// For more details, see (among others):\n\t\t\t\t\t// https://reviews.llvm.org/D84825\n\t\t\t\t\tfor {\n\t\t\t\t\t\terr := lr.Next(&lineEntry)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn token.Position{}, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif lineEntry.EndSequence {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif !prevLineEntry.EndSequence {\n\t\t\t\t\t// The chunk describes the code from prevLineEntry to\n\t\t\t\t\t// lineEntry.\n\t\t\t\t\tif prevLineEntry.Address <= address && lineEntry.Address > address {\n\t\t\t\t\t\treturn token.Position{\n\t\t\t\t\t\t\tFilename: prevLineEntry.File.Name,\n\t\t\t\t\t\t\tLine:     prevLineEntry.Line,\n\t\t\t\t\t\t\tColumn:   prevLineEntry.Column,\n\t\t\t\t\t\t}, nil\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn token.Position{}, nil // location not found\n}\n\n// Read the DWARF debug information from a given file (in various formats).\nfunc readDWARF(executable string) (*dwarf.Data, error) {\n\tf, err := os.Open(executable)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif file, err := elf.NewFile(f); err == nil {\n\t\treturn file.DWARF()\n\t} else if file, err := macho.NewFile(f); err == nil {\n\t\treturn file.DWARF()\n\t} else if file, err := pe.NewFile(f); err == nil {\n\t\treturn file.DWARF()\n\t} else {\n\t\treturn nil, errors.New(\"unknown binary format\")\n\t}\n}\n\ntype outputWriter struct {\n\tout        io.Writer\n\texecutable string\n\tline       []byte\n}\n\n// newOutputWriter returns an io.Writer that will intercept panic addresses and\n// will try to insert a source location in the output if the source location can\n// be found in the executable.\nfunc newOutputWriter(out io.Writer, executable string) *outputWriter {\n\treturn &outputWriter{\n\t\tout:        out,\n\t\texecutable: executable,\n\t}\n}\n\nfunc (w *outputWriter) Write(p []byte) (n int, err error) {\n\tstart := 0\n\tfor i, c := range p {\n\t\tif c == '\\n' {\n\t\t\tw.out.Write(p[start : i+1])\n\t\t\tstart = i + 1\n\t\t\taddress := extractPanicAddress(w.line)\n\t\t\tif address != 0 {\n\t\t\t\tloc, err := addressToLine(w.executable, address)\n\t\t\t\tif err == nil && loc.Filename != \"\" {\n\t\t\t\t\tfmt.Printf(\"[tinygo: panic at %s]\\n\", loc.String())\n\t\t\t\t}\n\t\t\t}\n\t\t\tw.line = w.line[:0]\n\t\t} else {\n\t\t\tw.line = append(w.line, c)\n\t\t}\n\t}\n\tw.out.Write(p[start:])\n\tn = len(p)\n\treturn\n}\n"
        },
        {
          "name": "monitor_test.go",
          "type": "blob",
          "size": 1.6796875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/tinygo-org/tinygo/builder\"\n\t\"github.com/tinygo-org/tinygo/compileopts\"\n)\n\nfunc TestTraceback(t *testing.T) {\n\tif runtime.GOOS != \"linux\" {\n\t\t// We care about testing the ELF format, which is only used on Linux\n\t\t// (not on MacOS or Windows).\n\t\tt.Skip(\"Test only works on Linux\")\n\t}\n\n\t// Build a small binary that only panics.\n\ttmpdir := t.TempDir()\n\tconfig, err := builder.NewConfig(&compileopts.Options{\n\t\tGOOS:          runtime.GOOS,\n\t\tGOARCH:        runtime.GOARCH,\n\t\tOpt:           \"z\",\n\t\tInterpTimeout: time.Minute,\n\t\tDebug:         true,\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tresult, err := builder.Build(\"testdata/trivialpanic.go\", \".elf\", tmpdir, config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Run this binary, and capture the output.\n\tbuf := &bytes.Buffer{}\n\tcmd := exec.Command(result.Binary)\n\tcmd.Stdout = buf\n\tcmd.Stderr = buf\n\tcmd.Run() // this will return an error because of the panic, ignore it\n\n\t// Extract the \"runtime error at\" address.\n\tline := bytes.TrimSpace(buf.Bytes())\n\taddress := extractPanicAddress(line)\n\tif address == 0 {\n\t\tt.Fatalf(\"could not extract panic address from %#v\", string(line))\n\t}\n\n\t// Look up the source location for this address.\n\tlocation, err := addressToLine(result.Executable, address)\n\tif err != nil {\n\t\tt.Fatal(\"could not read source location:\", err)\n\t}\n\n\t// Verify that the source location is as expected.\n\tif filepath.Base(location.Filename) != \"trivialpanic.go\" {\n\t\tt.Errorf(\"expected path to end with trivialpanic.go, got %#v\", location.Filename)\n\t}\n\tif location.Line != 6 {\n\t\tt.Errorf(\"expected panic location to be line 6, got line %d\", location.Line)\n\t}\n}\n"
        },
        {
          "name": "revive.toml",
          "type": "blob",
          "size": 0.8076171875,
          "content": "ignoreGeneratedHeader = false\nseverity = \"warning\"\nconfidence = 0.8\nerrorCode = 0\nwarningCode = 0\n\n# Enable these as we fix them\n[rule.blank-imports]\n  Exclude=[\"src/os/file_other.go\"]\n[rule.context-as-argument]\n[rule.context-keys-type]\n[rule.dot-imports]\n  Exclude=[\"**/*_test.go\"]\n[rule.error-return]\n[rule.error-strings]\n[rule.error-naming]\n[rule.exported]\n  Exclude=[\"src/reflect/*.go\"]\n[rule.increment-decrement]\n[rule.var-naming]\n  Exclude=[\"src/os/*.go\"]\n[rule.var-declaration]\n#[rule.package-comments]\n[rule.range]\n[rule.receiver-naming]\n[rule.time-naming]\n[rule.unexported-return]\n#[rule.indent-error-flow]\n[rule.errorf]\n#[rule.empty-block]\n[rule.superfluous-else]\n#[rule.unused-parameter]\n[rule.unreachable-code]\n  Exclude=[\"src/reflect/visiblefields_test.go\", \"src/reflect/all_test.go\"]\n#[rule.redefines-builtin-id]\n"
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        },
        {
          "name": "stacksize",
          "type": "tree",
          "content": null
        },
        {
          "name": "targets",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "transform",
          "type": "tree",
          "content": null
        },
        {
          "name": "util_unix.go",
          "type": "blob",
          "size": 0.40234375,
          "content": "//go:build !windows\n\npackage main\n\n// This file contains utility functions for Unix-like systems (e.g. Linux).\n\nimport (\n\t\"os/exec\"\n\t\"syscall\"\n)\n\n// setCommandAsDaemon makes sure this command does not receive signals sent to\n// the parent.\nfunc setCommandAsDaemon(daemon *exec.Cmd) {\n\t// https://stackoverflow.com/a/35435038/559350\n\tdaemon.SysProcAttr = &syscall.SysProcAttr{\n\t\tSetpgid: true,\n\t\tPgid:    0,\n\t}\n}\n"
        },
        {
          "name": "util_windows.go",
          "type": "blob",
          "size": 0.3525390625,
          "content": "package main\n\n// This file contains utility functions for Windows.\n\nimport (\n\t\"os/exec\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\n// setCommandAsDaemon makes sure this command does not receive signals sent to\n// the parent.\nfunc setCommandAsDaemon(daemon *exec.Cmd) {\n\tdaemon.SysProcAttr = &syscall.SysProcAttr{\n\t\tCreationFlags: windows.DETACHED_PROCESS,\n\t}\n}\n"
        }
      ]
    }
  ]
}