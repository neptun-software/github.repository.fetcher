{
  "metadata": {
    "timestamp": 1736567921783,
    "page": 66,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "FiloSottile/age",
      "stars": 17855,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0380859375,
          "content": "*.age binary\ntestdata/testkit/* binary\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.1953125,
          "content": "# This is the official list of age authors for copyright purposes.\n# To be included, send a change adding the individual or company\n# who owns a contribution's copyright.\n\nGoogle LLC\nFilippo Valsorda\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.423828125,
          "content": "Copyright 2019 The age Authors\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of the age project nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.986328125,
          "content": "<p align=\"center\">\n    <picture>\n        <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://github.com/FiloSottile/age/blob/main/logo/logo_white.svg\">\n        <source media=\"(prefers-color-scheme: light)\" srcset=\"https://github.com/FiloSottile/age/blob/main/logo/logo.svg\">\n        <img alt=\"The age logo, a wireframe of St. Peters dome in Rome, with the text: age, file encryption\" width=\"600\" src=\"https://github.com/FiloSottile/age/blob/main/logo/logo.svg\">\n    </picture>\n</p>\n\n[![Go Reference](https://pkg.go.dev/badge/filippo.io/age.svg)](https://pkg.go.dev/filippo.io/age)\n[![man page](<https://img.shields.io/badge/age(1)-man%20page-lightgrey>)](https://filippo.io/age/age.1)\n[![C2SP specification](https://img.shields.io/badge/%C2%A7%23-specification-blueviolet)](https://age-encryption.org/v1)\n\nage is a simple, modern and secure file encryption tool, format, and Go library.\n\nIt features small explicit keys, no config options, and UNIX-style composability.\n\n```\n$ age-keygen -o key.txt\nPublic key: age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p\n$ tar cvz ~/data | age -r age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p > data.tar.gz.age\n$ age --decrypt -i key.txt data.tar.gz.age > data.tar.gz\n```\n\nðŸ“œ The format specification is at [age-encryption.org/v1](https://age-encryption.org/v1). age was designed by [@Benjojo12](https://twitter.com/Benjojo12) and [@FiloSottile](https://twitter.com/FiloSottile).\n\nðŸ“¬ Follow the maintenance of this project by subscribing to [Maintainer Dispatches](https://filippo.io/newsletter)!\n\nðŸ¦€ An alternative interoperable Rust implementation is available at [github.com/str4d/rage](https://github.com/str4d/rage).\n\nðŸ”‘ Hardware PIV tokens such as YubiKeys are supported through the [age-plugin-yubikey](https://github.com/str4d/age-plugin-yubikey) plugin.\n\nâœ¨ For more plugins, implementations, tools, and integrations, check out the [awesome age](https://github.com/FiloSottile/awesome-age) list.\n\nðŸ’¬ The author pronounces it `[aÉ¡eÌž]` [with a hard *g*](https://translate.google.com/?sl=it&text=aghe), like GIF, and is always spelled lowercase.\n\n## Installation\n\n<table>\n    <tr>\n        <td>Homebrew (macOS or Linux)</td>\n        <td>\n            <code>brew install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>MacPorts</td>\n        <td>\n            <code>port install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Alpine Linux v3.15+</td>\n        <td>\n            <code>apk add age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Arch Linux</td>\n        <td>\n            <code>pacman -S age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Debian 12+ (Bookworm)</td>\n        <td>\n            <code>apt install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Debian 11 (Bullseye)</td>\n        <td>\n            <code>apt install age/bullseye-backports</code>\n            (<a href=\"https://backports.debian.org/Instructions/#index2h2\">enable backports</a> for age v1.0.0+)\n        </td>\n    </tr>\n    <tr>\n        <td>Fedora 33+</td>\n        <td>\n            <code>dnf install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Gentoo Linux</td>\n        <td>\n            <code>emerge app-crypt/age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>NixOS / Nix</td>\n        <td>\n            <code>nix-env -i age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>openSUSE Tumbleweed</td>\n        <td>\n            <code>zypper install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Ubuntu 22.04+</td>\n        <td>\n            <code>apt install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Void Linux</td>\n        <td>\n            <code>xbps-install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>FreeBSD</td>\n        <td>\n            <code>pkg install age</code> (security/age)\n        </td>\n    </tr>\n    <tr>\n        <td>OpenBSD 6.7+</td>\n        <td>\n            <code>pkg_add age</code> (security/age)\n        </td>\n    </tr>\n    <tr>\n        <td>Chocolatey (Windows)</td>\n        <td>\n            <code>choco install age.portable</code>\n        </td>\n    </tr>\n    <tr>\n        <td>Scoop (Windows)</td>\n        <td>\n            <code>scoop bucket add extras && scoop install age</code>\n        </td>\n    </tr>\n    <tr>\n        <td>pkgx</td>\n        <td>\n            <code>pkgx install age</code>\n        </td>\n    </tr>\n</table>\n\nOn Windows, Linux, macOS, and FreeBSD you can use the pre-built binaries.\n\n```\nhttps://dl.filippo.io/age/latest?for=linux/amd64\nhttps://dl.filippo.io/age/v1.1.1?for=darwin/arm64\n...\n```\n\nIf your system has [a supported version of Go](https://go.dev/dl/), you can build from source.\n\n```\ngo install filippo.io/age/cmd/...@latest\n```\n\nHelp from new packagers is very welcome.\n\n### Verifying the release signatures\n\nIf you download the pre-built binaries, you can check their\n[Sigsum](https://www.sigsum.org) proofs, which are like signatures with extra\ntransparency: you can cryptographically verify that every proof is logged in a\npublic append-only log, so you can hold the age project accountable for every\nbinary release we ever produced. This is similar to what the [Go Checksum\nDatabase](https://go.dev/blog/module-mirror-launch) provides.\n\n```\ncat << EOF > age-sigsum-key.pub\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIM1WpnEswJLPzvXJDiswowy48U+G+G1kmgwUE2eaRHZG\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAz2WM5CyPLqiNjk7CLl4roDXwKhQ0QExXLebukZEZFS\nEOF\ncat << EOF > sigsum-trust-policy.txt\nlog 154f49976b59ff09a123675f58cb3e346e0455753c3c3b15d465dcb4f6512b0b https://poc.sigsum.org/jellyfish\nwitness poc.sigsum.org/nisse 1c25f8a44c635457e2e391d1efbca7d4c2951a0aef06225a881e46b98962ac6c\nwitness rgdd.se/poc-witness  28c92a5a3a054d317c86fc2eeb6a7ab2054d6217100d0be67ded5b74323c5806\ngroup  demo-quorum-rule all poc.sigsum.org/nisse rgdd.se/poc-witness\nquorum demo-quorum-rule\nEOF\n\ncurl -JLO \"https://dl.filippo.io/age/v1.2.0?for=darwin/arm64\"\ncurl -JLO \"https://dl.filippo.io/age/v1.2.0?for=darwin/arm64&proof\"\n\ngo install sigsum.org/sigsum-go/cmd/sigsum-verify@v0.8.0\nsigsum-verify -k age-sigsum-key.pub -p sigsum-trust-policy.txt \\\n    age-v1.2.0-darwin-arm64.tar.gz.proof < age-v1.2.0-darwin-arm64.tar.gz\n```\n\nYou can learn more about what's happening above in the [Sigsum\ndocs](https://www.sigsum.org/getting-started/).\n\n## Usage\n\nFor the full documentation, read [the age(1) man page](https://filippo.io/age/age.1).\n\n```\nUsage:\n    age [--encrypt] (-r RECIPIENT | -R PATH)... [--armor] [-o OUTPUT] [INPUT]\n    age [--encrypt] --passphrase [--armor] [-o OUTPUT] [INPUT]\n    age --decrypt [-i PATH]... [-o OUTPUT] [INPUT]\n\nOptions:\n    -e, --encrypt               Encrypt the input to the output. Default if omitted.\n    -d, --decrypt               Decrypt the input to the output.\n    -o, --output OUTPUT         Write the result to the file at path OUTPUT.\n    -a, --armor                 Encrypt to a PEM encoded format.\n    -p, --passphrase            Encrypt with a passphrase.\n    -r, --recipient RECIPIENT   Encrypt to the specified RECIPIENT. Can be repeated.\n    -R, --recipients-file PATH  Encrypt to recipients listed at PATH. Can be repeated.\n    -i, --identity PATH         Use the identity file at PATH. Can be repeated.\n\nINPUT defaults to standard input, and OUTPUT defaults to standard output.\nIf OUTPUT exists, it will be overwritten.\n\nRECIPIENT can be an age public key generated by age-keygen (\"age1...\")\nor an SSH public key (\"ssh-ed25519 AAAA...\", \"ssh-rsa AAAA...\").\n\nRecipient files contain one or more recipients, one per line. Empty lines\nand lines starting with \"#\" are ignored as comments. \"-\" may be used to\nread recipients from standard input.\n\nIdentity files contain one or more secret keys (\"AGE-SECRET-KEY-1...\"),\none per line, or an SSH key. Empty lines and lines starting with \"#\" are\nignored as comments. Passphrase encrypted age files can be used as\nidentity files. Multiple key files can be provided, and any unused ones\nwill be ignored. \"-\" may be used to read identities from standard input.\n\nWhen --encrypt is specified explicitly, -i can also be used to encrypt to an\nidentity file symmetrically, instead or in addition to normal recipients.\n```\n\n### Multiple recipients\n\nFiles can be encrypted to multiple recipients by repeating `-r/--recipient`. Every recipient will be able to decrypt the file.\n\n```\n$ age -o example.jpg.age -r age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p \\\n    -r age1lggyhqrw2nlhcxprm67z43rta597azn8gknawjehu9d9dl0jq3yqqvfafg example.jpg\n```\n\n#### Recipient files\n\nMultiple recipients can also be listed one per line in one or more files passed with the `-R/--recipients-file` flag.\n\n```\n$ cat recipients.txt\n# Alice\nage1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p\n# Bob\nage1lggyhqrw2nlhcxprm67z43rta597azn8gknawjehu9d9dl0jq3yqqvfafg\n$ age -R recipients.txt example.jpg > example.jpg.age\n```\n\nIf the argument to `-R` (or `-i`) is `-`, the file is read from standard input.\n\n### Passphrases\n\nFiles can be encrypted with a passphrase by using `-p/--passphrase`. By default age will automatically generate a secure passphrase. Passphrase protected files are automatically detected at decrypt time.\n\n```\n$ age -p secrets.txt > secrets.txt.age\nEnter passphrase (leave empty to autogenerate a secure one):\nUsing the autogenerated passphrase \"release-response-step-brand-wrap-ankle-pair-unusual-sword-train\".\n$ age -d secrets.txt.age > secrets.txt\nEnter passphrase:\n```\n\n### Passphrase-protected key files\n\nIf an identity file passed to `-i` is a passphrase encrypted age file, it will be automatically decrypted.\n\n```\n$ age-keygen | age -p > key.age\nPublic key: age1yhm4gctwfmrpz87tdslm550wrx6m79y9f2hdzt0lndjnehwj0ukqrjpyx5\nEnter passphrase (leave empty to autogenerate a secure one):\nUsing the autogenerated passphrase \"hip-roast-boring-snake-mention-east-wasp-honey-input-actress\".\n$ age -r age1yhm4gctwfmrpz87tdslm550wrx6m79y9f2hdzt0lndjnehwj0ukqrjpyx5 secrets.txt > secrets.txt.age\n$ age -d -i key.age secrets.txt.age > secrets.txt\nEnter passphrase for identity file \"key.age\":\n```\n\nPassphrase-protected identity files are not necessary for most use cases, where access to the encrypted identity file implies access to the whole system. However, they can be useful if the identity file is stored remotely.\n\n### SSH keys\n\nAs a convenience feature, age also supports encrypting to `ssh-rsa` and `ssh-ed25519` SSH public keys, and decrypting with the respective private key file. (`ssh-agent` is not supported.)\n\n```\n$ age -R ~/.ssh/id_ed25519.pub example.jpg > example.jpg.age\n$ age -d -i ~/.ssh/id_ed25519 example.jpg.age > example.jpg\n```\n\nNote that SSH key support employs more complex cryptography, and embeds a public key tag in the encrypted file, making it possible to track files that are encrypted to a specific public key.\n\n#### Encrypting to a GitHub user\n\nCombining SSH key support and `-R`, you can easily encrypt a file to the SSH keys listed on a GitHub profile.\n\n```\n$ curl https://github.com/benjojo.keys | age -R - example.jpg > example.jpg.age\n```\n\nKeep in mind that people might not protect SSH keys long-term, since they are revokable when used only for authentication, and that SSH keys held on YubiKeys can't be used to decrypt files.\n"
        },
        {
          "name": "age.go",
          "type": "blob",
          "size": 8.73828125,
          "content": "// Copyright 2019 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package age implements file encryption according to the age-encryption.org/v1\n// specification.\n//\n// For most use cases, use the Encrypt and Decrypt functions with\n// X25519Recipient and X25519Identity. If passphrase encryption is required, use\n// ScryptRecipient and ScryptIdentity. For compatibility with existing SSH keys\n// use the filippo.io/age/agessh package.\n//\n// age encrypted files are binary and not malleable. For encoding them as text,\n// use the filippo.io/age/armor package.\n//\n// # Key management\n//\n// age does not have a global keyring. Instead, since age keys are small,\n// textual, and cheap, you are encouraged to generate dedicated keys for each\n// task and application.\n//\n// Recipient public keys can be passed around as command line flags and in\n// config files, while secret keys should be stored in dedicated files, through\n// secret management systems, or as environment variables.\n//\n// There is no default path for age keys. Instead, they should be stored at\n// application-specific paths. The CLI supports files where private keys are\n// listed one per line, ignoring empty lines and lines starting with \"#\". These\n// files can be parsed with ParseIdentities.\n//\n// When integrating age into a new system, it's recommended that you only\n// support X25519 keys, and not SSH keys. The latter are supported for manual\n// encryption operations. If you need to tie into existing key management\n// infrastructure, you might want to consider implementing your own Recipient\n// and Identity.\n//\n// # Backwards compatibility\n//\n// Files encrypted with a stable version (not alpha, beta, or release candidate)\n// of age, or with any v1.0.0 beta or release candidate, will decrypt with any\n// later versions of the v1 API. This might change in v2, in which case v1 will\n// be maintained with security fixes for compatibility with older files.\n//\n// If decrypting an older file poses a security risk, doing so might require an\n// explicit opt-in in the API.\npackage age\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"sort\"\n\n\t\"filippo.io/age/internal/format\"\n\t\"filippo.io/age/internal/stream\"\n)\n\n// An Identity is passed to Decrypt to unwrap an opaque file key from a\n// recipient stanza. It can be for example a secret key like X25519Identity, a\n// plugin, or a custom implementation.\n//\n// Unwrap must return an error wrapping ErrIncorrectIdentity if none of the\n// recipient stanzas match the identity, any other error will be considered\n// fatal.\n//\n// Most age API users won't need to interact with this directly, and should\n// instead pass Recipient implementations to Encrypt and Identity\n// implementations to Decrypt.\ntype Identity interface {\n\tUnwrap(stanzas []*Stanza) (fileKey []byte, err error)\n}\n\nvar ErrIncorrectIdentity = errors.New(\"incorrect identity for recipient block\")\n\n// A Recipient is passed to Encrypt to wrap an opaque file key to one or more\n// recipient stanza(s). It can be for example a public key like X25519Recipient,\n// a plugin, or a custom implementation.\n//\n// Most age API users won't need to interact with this directly, and should\n// instead pass Recipient implementations to Encrypt and Identity\n// implementations to Decrypt.\ntype Recipient interface {\n\tWrap(fileKey []byte) ([]*Stanza, error)\n}\n\n// RecipientWithLabels can be optionally implemented by a Recipient, in which\n// case Encrypt will use WrapWithLabels instead of Wrap.\n//\n// Encrypt will succeed only if the labels returned by all the recipients\n// (assuming the empty set for those that don't implement RecipientWithLabels)\n// are the same.\n//\n// This can be used to ensure a recipient is only used with other recipients\n// with equivalent properties (for example by setting a \"postquantum\" label) or\n// to ensure a recipient is always used alone (by returning a random label, for\n// example to preserve its authentication properties).\ntype RecipientWithLabels interface {\n\tWrapWithLabels(fileKey []byte) (s []*Stanza, labels []string, err error)\n}\n\n// A Stanza is a section of the age header that encapsulates the file key as\n// encrypted to a specific recipient.\n//\n// Most age API users won't need to interact with this directly, and should\n// instead pass Recipient implementations to Encrypt and Identity\n// implementations to Decrypt.\ntype Stanza struct {\n\tType string\n\tArgs []string\n\tBody []byte\n}\n\nconst fileKeySize = 16\nconst streamNonceSize = 16\n\n// Encrypt encrypts a file to one or more recipients.\n//\n// Writes to the returned WriteCloser are encrypted and written to dst as an age\n// file. Every recipient will be able to decrypt the file.\n//\n// The caller must call Close on the WriteCloser when done for the last chunk to\n// be encrypted and flushed to dst.\nfunc Encrypt(dst io.Writer, recipients ...Recipient) (io.WriteCloser, error) {\n\tif len(recipients) == 0 {\n\t\treturn nil, errors.New(\"no recipients specified\")\n\t}\n\n\tfileKey := make([]byte, fileKeySize)\n\tif _, err := rand.Read(fileKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\thdr := &format.Header{}\n\tvar labels []string\n\tfor i, r := range recipients {\n\t\tstanzas, l, err := wrapWithLabels(r, fileKey)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to wrap key for recipient #%d: %v\", i, err)\n\t\t}\n\t\tsort.Strings(l)\n\t\tif i == 0 {\n\t\t\tlabels = l\n\t\t} else if !slicesEqual(labels, l) {\n\t\t\treturn nil, fmt.Errorf(\"incompatible recipients\")\n\t\t}\n\t\tfor _, s := range stanzas {\n\t\t\thdr.Recipients = append(hdr.Recipients, (*format.Stanza)(s))\n\t\t}\n\t}\n\tif mac, err := headerMAC(fileKey, hdr); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to compute header MAC: %v\", err)\n\t} else {\n\t\thdr.MAC = mac\n\t}\n\tif err := hdr.Marshal(dst); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write header: %v\", err)\n\t}\n\n\tnonce := make([]byte, streamNonceSize)\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := dst.Write(nonce); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to write nonce: %v\", err)\n\t}\n\n\treturn stream.NewWriter(streamKey(fileKey, nonce), dst)\n}\n\nfunc wrapWithLabels(r Recipient, fileKey []byte) (s []*Stanza, labels []string, err error) {\n\tif r, ok := r.(RecipientWithLabels); ok {\n\t\treturn r.WrapWithLabels(fileKey)\n\t}\n\ts, err = r.Wrap(fileKey)\n\treturn\n}\n\nfunc slicesEqual(s1, s2 []string) bool {\n\tif len(s1) != len(s2) {\n\t\treturn false\n\t}\n\tfor i := range s1 {\n\t\tif s1[i] != s2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// NoIdentityMatchError is returned by Decrypt when none of the supplied\n// identities match the encrypted file.\ntype NoIdentityMatchError struct {\n\t// Errors is a slice of all the errors returned to Decrypt by the Unwrap\n\t// calls it made. They all wrap ErrIncorrectIdentity.\n\tErrors []error\n}\n\nfunc (*NoIdentityMatchError) Error() string {\n\treturn \"no identity matched any of the recipients\"\n}\n\n// Decrypt decrypts a file encrypted to one or more identities.\n//\n// It returns a Reader reading the decrypted plaintext of the age file read\n// from src. All identities will be tried until one successfully decrypts the file.\nfunc Decrypt(src io.Reader, identities ...Identity) (io.Reader, error) {\n\tif len(identities) == 0 {\n\t\treturn nil, errors.New(\"no identities specified\")\n\t}\n\n\thdr, payload, err := format.Parse(src)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read header: %w\", err)\n\t}\n\n\tstanzas := make([]*Stanza, 0, len(hdr.Recipients))\n\tfor _, s := range hdr.Recipients {\n\t\tstanzas = append(stanzas, (*Stanza)(s))\n\t}\n\terrNoMatch := &NoIdentityMatchError{}\n\tvar fileKey []byte\n\tfor _, id := range identities {\n\t\tfileKey, err = id.Unwrap(stanzas)\n\t\tif errors.Is(err, ErrIncorrectIdentity) {\n\t\t\terrNoMatch.Errors = append(errNoMatch.Errors, err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbreak\n\t}\n\tif fileKey == nil {\n\t\treturn nil, errNoMatch\n\t}\n\n\tif mac, err := headerMAC(fileKey, hdr); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to compute header MAC: %v\", err)\n\t} else if !hmac.Equal(mac, hdr.MAC) {\n\t\treturn nil, errors.New(\"bad header MAC\")\n\t}\n\n\tnonce := make([]byte, streamNonceSize)\n\tif _, err := io.ReadFull(payload, nonce); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read nonce: %w\", err)\n\t}\n\n\treturn stream.NewReader(streamKey(fileKey, nonce), payload)\n}\n\n// multiUnwrap is a helper that implements Identity.Unwrap in terms of a\n// function that unwraps a single recipient stanza.\nfunc multiUnwrap(unwrap func(*Stanza) ([]byte, error), stanzas []*Stanza) ([]byte, error) {\n\tfor _, s := range stanzas {\n\t\tfileKey, err := unwrap(s)\n\t\tif errors.Is(err, ErrIncorrectIdentity) {\n\t\t\t// If we ever start returning something interesting wrapping\n\t\t\t// ErrIncorrectIdentity, we should let it make its way up through\n\t\t\t// Decrypt into NoIdentityMatchError.Errors.\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn fileKey, nil\n\t}\n\treturn nil, ErrIncorrectIdentity\n}\n"
        },
        {
          "name": "age_test.go",
          "type": "blob",
          "size": 7.4287109375,
          "content": "// Copyright 2019 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage age_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"filippo.io/age\"\n)\n\nfunc ExampleEncrypt() {\n\tpublicKey := \"age1cy0su9fwf3gf9mw868g5yut09p6nytfmmnktexz2ya5uqg9vl9sss4euqm\"\n\trecipient, err := age.ParseX25519Recipient(publicKey)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse public key %q: %v\", publicKey, err)\n\t}\n\n\tout := &bytes.Buffer{}\n\n\tw, err := age.Encrypt(out, recipient)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create encrypted file: %v\", err)\n\t}\n\tif _, err := io.WriteString(w, \"Black lives matter.\"); err != nil {\n\t\tlog.Fatalf(\"Failed to write to encrypted file: %v\", err)\n\t}\n\tif err := w.Close(); err != nil {\n\t\tlog.Fatalf(\"Failed to close encrypted file: %v\", err)\n\t}\n\n\tfmt.Printf(\"Encrypted file size: %d\\n\", out.Len())\n\t// Output:\n\t// Encrypted file size: 219\n}\n\n// DO NOT hardcode the private key. Store it in a secret storage solution,\n// on disk if the local machine is trusted, or have the user provide it.\nvar privateKey string\n\nfunc init() {\n\tprivateKey = \"AGE-SECRET-KEY-184JMZMVQH3E6U0PSL869004Y3U2NYV7R30EU99CSEDNPH02YUVFSZW44VU\"\n}\n\nfunc ExampleDecrypt() {\n\tidentity, err := age.ParseX25519Identity(privateKey)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse private key: %v\", err)\n\t}\n\n\tf, err := os.Open(\"testdata/example.age\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file: %v\", err)\n\t}\n\n\tr, err := age.Decrypt(f, identity)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open encrypted file: %v\", err)\n\t}\n\tout := &bytes.Buffer{}\n\tif _, err := io.Copy(out, r); err != nil {\n\t\tlog.Fatalf(\"Failed to read encrypted file: %v\", err)\n\t}\n\n\tfmt.Printf(\"File contents: %q\\n\", out.Bytes())\n\t// Output:\n\t// File contents: \"Black lives matter.\"\n}\n\nfunc ExampleParseIdentities() {\n\tkeyFile, err := os.Open(\"testdata/example_keys.txt\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open private keys file: %v\", err)\n\t}\n\tidentities, err := age.ParseIdentities(keyFile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse private key: %v\", err)\n\t}\n\n\tf, err := os.Open(\"testdata/example.age\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open file: %v\", err)\n\t}\n\n\tr, err := age.Decrypt(f, identities...)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open encrypted file: %v\", err)\n\t}\n\tout := &bytes.Buffer{}\n\tif _, err := io.Copy(out, r); err != nil {\n\t\tlog.Fatalf(\"Failed to read encrypted file: %v\", err)\n\t}\n\n\tfmt.Printf(\"File contents: %q\\n\", out.Bytes())\n\t// Output:\n\t// File contents: \"Black lives matter.\"\n}\n\nfunc ExampleGenerateX25519Identity() {\n\tidentity, err := age.GenerateX25519Identity()\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to generate key pair: %v\", err)\n\t}\n\n\tfmt.Printf(\"Public key: %s...\\n\", identity.Recipient().String()[:4])\n\tfmt.Printf(\"Private key: %s...\\n\", identity.String()[:16])\n\t// Output:\n\t// Public key: age1...\n\t// Private key: AGE-SECRET-KEY-1...\n}\n\nconst helloWorld = \"Hello, Twitch!\"\n\nfunc TestEncryptDecryptX25519(t *testing.T) {\n\ta, err := age.GenerateX25519Identity()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tb, err := age.GenerateX25519Identity()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbuf := &bytes.Buffer{}\n\tw, err := age.Encrypt(buf, a.Recipient(), b.Recipient())\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := io.WriteString(w, helloWorld); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := w.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tout, err := age.Decrypt(buf, b)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\toutBytes, err := io.ReadAll(out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(outBytes) != helloWorld {\n\t\tt.Errorf(\"wrong data: %q, excepted %q\", outBytes, helloWorld)\n\t}\n}\n\nfunc TestEncryptDecryptScrypt(t *testing.T) {\n\tpassword := \"twitch.tv/filosottile\"\n\n\tr, err := age.NewScryptRecipient(password)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr.SetWorkFactor(15)\n\tbuf := &bytes.Buffer{}\n\tw, err := age.Encrypt(buf, r)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := io.WriteString(w, helloWorld); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := w.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ti, err := age.NewScryptIdentity(password)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tout, err := age.Decrypt(buf, i)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\toutBytes, err := io.ReadAll(out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif string(outBytes) != helloWorld {\n\t\tt.Errorf(\"wrong data: %q, excepted %q\", outBytes, helloWorld)\n\t}\n}\n\nfunc TestParseIdentities(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\twantCount int\n\t\twantErr   bool\n\t\tfile      string\n\t}{\n\t\t{\"valid\", 2, false, `\n# this is a comment\n# AGE-SECRET-KEY-1705XN76M8EYQ8M9PY4E2G3KA8DN7NSCGT3V4HMN20H3GCX4AS6HSSTG8D3\n#\n\nAGE-SECRET-KEY-1D6K0SGAX3NU66R4GYFZY0UQWCLM3UUSF3CXLW4KXZM342WQSJ82QKU59QJ\nAGE-SECRET-KEY-19WUMFE89H3928FRJ5U3JYRNHM6CERQGKSQ584AQ8QY7T7R09D32SWE4DYH`},\n\t\t{\"invalid\", 0, true, `\nAGE-SECRET-KEY-1705XN76M8EYQ8M9PY4E2G3KA8DN7NSCGT3V4HMN20H3GCX4AS6HSSTG8D3\nAGE-SECRET-KEY--1D6K0SGAX3NU66R4GYFZY0UQWCLM3UUSF3CXLW4KXZM342WQSJ82QKU59Q`},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := age.ParseIdentities(strings.NewReader(tt.file))\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"ParseIdentities() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(got) != tt.wantCount {\n\t\t\t\tt.Errorf(\"ParseIdentities() returned %d identities, want %d\", len(got), tt.wantCount)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype testRecipient struct {\n\tlabels []string\n}\n\nfunc (testRecipient) Wrap(fileKey []byte) ([]*age.Stanza, error) {\n\tpanic(\"expected WrapWithLabels instead\")\n}\n\nfunc (t testRecipient) WrapWithLabels(fileKey []byte) (s []*age.Stanza, labels []string, err error) {\n\treturn []*age.Stanza{{Type: \"test\"}}, t.labels, nil\n}\n\nfunc TestLabels(t *testing.T) {\n\tscrypt, err := age.NewScryptRecipient(\"xxx\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ti, err := age.GenerateX25519Identity()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tx25519 := i.Recipient()\n\tpqc := testRecipient{[]string{\"postquantum\"}}\n\tpqcAndFoo := testRecipient{[]string{\"postquantum\", \"foo\"}}\n\tfooAndPQC := testRecipient{[]string{\"foo\", \"postquantum\"}}\n\n\tif _, err := age.Encrypt(io.Discard, scrypt, scrypt); err == nil {\n\t\tt.Error(\"expected two scrypt recipients to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, scrypt, x25519); err == nil {\n\t\tt.Error(\"expected x25519 mixed with scrypt to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, x25519, scrypt); err == nil {\n\t\tt.Error(\"expected x25519 mixed with scrypt to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqc, x25519); err == nil {\n\t\tt.Error(\"expected x25519 mixed with pqc to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, x25519, pqc); err == nil {\n\t\tt.Error(\"expected x25519 mixed with pqc to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqc, pqc); err != nil {\n\t\tt.Errorf(\"expected two pqc to work, got %v\", err)\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqc); err != nil {\n\t\tt.Errorf(\"expected one pqc to work, got %v\", err)\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqcAndFoo, pqc); err == nil {\n\t\tt.Error(\"expected pqc+foo mixed with pqc to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqc, pqcAndFoo); err == nil {\n\t\tt.Error(\"expected pqc+foo mixed with pqc to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqc, pqc, pqcAndFoo); err == nil {\n\t\tt.Error(\"expected pqc+foo mixed with pqc to fail\")\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqcAndFoo, pqcAndFoo); err != nil {\n\t\tt.Errorf(\"expected two pqc+foo to work, got %v\", err)\n\t}\n\tif _, err := age.Encrypt(io.Discard, pqcAndFoo, fooAndPQC); err != nil {\n\t\tt.Errorf(\"expected pqc+foo mixed with foo+pqc to work, got %v\", err)\n\t}\n}\n"
        },
        {
          "name": "agessh",
          "type": "tree",
          "content": null
        },
        {
          "name": "armor",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3203125,
          "content": "module filippo.io/age\n\ngo 1.19\n\nrequire (\n\tfilippo.io/edwards25519 v1.1.0\n\tgolang.org/x/crypto v0.24.0\n\tgolang.org/x/sys v0.21.0\n\tgolang.org/x/term v0.21.0\n)\n\n// Test dependencies.\nrequire (\n\tc2sp.org/CCTV/age v0.0.0-20240306222714-3ec4d716e805\n\tgithub.com/rogpeppe/go-internal v1.12.0\n\tgolang.org/x/tools v0.22.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.1533203125,
          "content": "c2sp.org/CCTV/age v0.0.0-20240306222714-3ec4d716e805 h1:u2qwJeEvnypw+OCPUHmoZE3IqwfuN5kgDfo5MLzpNM0=\nc2sp.org/CCTV/age v0.0.0-20240306222714-3ec4d716e805/go.mod h1:FomMrUJ2Lxt5jCLmZkG3FHa72zUprnhd3v/Z18Snm4w=\nfilippo.io/edwards25519 v1.1.0 h1:FNf4tywRC1HmFuKW5xopWpigGjJKiJSV0Cqo0cJWDaA=\nfilippo.io/edwards25519 v1.1.0/go.mod h1:BxyFTGdWcka3PhytdK4V28tE5sGfRvvvRV7EaN4VDT4=\ngithub.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=\ngithub.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=\ngolang.org/x/crypto v0.24.0 h1:mnl8DM0o513X8fdIkmyFE/5hTYxbwYOjDS/+rK6qpRI=\ngolang.org/x/crypto v0.24.0/go.mod h1:Z1PMYSOR5nyMcyAVAIQSKCDwalqy85Aqn1x3Ws4L5DM=\ngolang.org/x/sys v0.21.0 h1:rF+pYz3DAGSQAxAu1CbC7catZg4ebC4UIeIhKxBZvws=\ngolang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.21.0 h1:WVXCp+/EBEHOj53Rvu+7KiT/iElMrO8ACK16SMZ3jaA=\ngolang.org/x/term v0.21.0/go.mod h1:ooXLefLobQVslOqselCNF4SxFAaoS6KujMbsGzSDmX0=\ngolang.org/x/tools v0.22.0 h1:gqSGLZqv+AI9lIQzniJ0nZDRG5GBPsSi+DRNHWNz6yA=\ngolang.org/x/tools v0.22.0/go.mod h1:aCwcsjqvq7Yqt6TNyX7QMU2enbQ/Gt0bo6krSeEri+c=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logo",
          "type": "tree",
          "content": null
        },
        {
          "name": "parse.go",
          "type": "blob",
          "size": 2.5048828125,
          "content": "// Copyright 2021 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage age\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\n// ParseIdentities parses a file with one or more private key encodings, one per\n// line. Empty lines and lines starting with \"#\" are ignored.\n//\n// This is the same syntax as the private key files accepted by the CLI, except\n// the CLI also accepts SSH private keys, which are not recommended for the\n// average application.\n//\n// Currently, all returned values are of type *X25519Identity, but different\n// types might be returned in the future.\nfunc ParseIdentities(f io.Reader) ([]Identity, error) {\n\tconst privateKeySizeLimit = 1 << 24 // 16 MiB\n\tvar ids []Identity\n\tscanner := bufio.NewScanner(io.LimitReader(f, privateKeySizeLimit))\n\tvar n int\n\tfor scanner.Scan() {\n\t\tn++\n\t\tline := scanner.Text()\n\t\tif strings.HasPrefix(line, \"#\") || line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\ti, err := ParseX25519Identity(line)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error at line %d: %v\", n, err)\n\t\t}\n\t\tids = append(ids, i)\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read secret keys file: %v\", err)\n\t}\n\tif len(ids) == 0 {\n\t\treturn nil, fmt.Errorf(\"no secret keys found\")\n\t}\n\treturn ids, nil\n}\n\n// ParseRecipients parses a file with one or more public key encodings, one per\n// line. Empty lines and lines starting with \"#\" are ignored.\n//\n// This is the same syntax as the recipients files accepted by the CLI, except\n// the CLI also accepts SSH recipients, which are not recommended for the\n// average application.\n//\n// Currently, all returned values are of type *X25519Recipient, but different\n// types might be returned in the future.\nfunc ParseRecipients(f io.Reader) ([]Recipient, error) {\n\tconst recipientFileSizeLimit = 1 << 24 // 16 MiB\n\tvar recs []Recipient\n\tscanner := bufio.NewScanner(io.LimitReader(f, recipientFileSizeLimit))\n\tvar n int\n\tfor scanner.Scan() {\n\t\tn++\n\t\tline := scanner.Text()\n\t\tif strings.HasPrefix(line, \"#\") || line == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tr, err := ParseX25519Recipient(line)\n\t\tif err != nil {\n\t\t\t// Hide the error since it might unintentionally leak the contents\n\t\t\t// of confidential files.\n\t\t\treturn nil, fmt.Errorf(\"malformed recipient at line %d\", n)\n\t\t}\n\t\trecs = append(recs, r)\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to read recipients file: %v\", err)\n\t}\n\tif len(recs) == 0 {\n\t\treturn nil, fmt.Errorf(\"no recipients found\")\n\t}\n\treturn recs, nil\n}\n"
        },
        {
          "name": "plugin",
          "type": "tree",
          "content": null
        },
        {
          "name": "primitives.go",
          "type": "blob",
          "size": 2.3017578125,
          "content": "// Copyright 2019 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage age\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"errors\"\n\t\"io\"\n\n\t\"filippo.io/age/internal/format\"\n\t\"golang.org/x/crypto/chacha20poly1305\"\n\t\"golang.org/x/crypto/hkdf\"\n)\n\n// aeadEncrypt encrypts a message with a one-time key.\nfunc aeadEncrypt(key, plaintext []byte) ([]byte, error) {\n\taead, err := chacha20poly1305.New(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// The nonce is fixed because this function is only used in places where the\n\t// spec guarantees each key is only used once (by deriving it from values\n\t// that include fresh randomness), allowing us to save the overhead.\n\t// For the code that encrypts the actual payload, look at the\n\t// filippo.io/age/internal/stream package.\n\tnonce := make([]byte, chacha20poly1305.NonceSize)\n\treturn aead.Seal(nil, nonce, plaintext, nil), nil\n}\n\nvar errIncorrectCiphertextSize = errors.New(\"encrypted value has unexpected length\")\n\n// aeadDecrypt decrypts a message of an expected fixed size.\n//\n// The message size is limited to mitigate multi-key attacks, where a ciphertext\n// can be crafted that decrypts successfully under multiple keys. Short\n// ciphertexts can only target two keys, which has limited impact.\nfunc aeadDecrypt(key []byte, size int, ciphertext []byte) ([]byte, error) {\n\taead, err := chacha20poly1305.New(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(ciphertext) != size+aead.Overhead() {\n\t\treturn nil, errIncorrectCiphertextSize\n\t}\n\tnonce := make([]byte, chacha20poly1305.NonceSize)\n\treturn aead.Open(nil, nonce, ciphertext, nil)\n}\n\nfunc headerMAC(fileKey []byte, hdr *format.Header) ([]byte, error) {\n\th := hkdf.New(sha256.New, fileKey, nil, []byte(\"header\"))\n\thmacKey := make([]byte, 32)\n\tif _, err := io.ReadFull(h, hmacKey); err != nil {\n\t\treturn nil, err\n\t}\n\thh := hmac.New(sha256.New, hmacKey)\n\tif err := hdr.MarshalWithoutMAC(hh); err != nil {\n\t\treturn nil, err\n\t}\n\treturn hh.Sum(nil), nil\n}\n\nfunc streamKey(fileKey, nonce []byte) []byte {\n\th := hkdf.New(sha256.New, fileKey, nonce, []byte(\"payload\"))\n\tstreamKey := make([]byte, chacha20poly1305.KeySize)\n\tif _, err := io.ReadFull(h, streamKey); err != nil {\n\t\tpanic(\"age: internal error: failed to read from HKDF: \" + err.Error())\n\t}\n\treturn streamKey\n}\n"
        },
        {
          "name": "recipients_test.go",
          "type": "blob",
          "size": 1.66796875,
          "content": "// Copyright 2019 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage age_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"testing\"\n\n\t\"filippo.io/age\"\n)\n\nfunc TestX25519RoundTrip(t *testing.T) {\n\ti, err := age.GenerateX25519Identity()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr := i.Recipient()\n\n\tif r1, err := age.ParseX25519Recipient(r.String()); err != nil {\n\t\tt.Fatal(err)\n\t} else if r1.String() != r.String() {\n\t\tt.Errorf(\"recipient did not round-trip through parsing: got %q, want %q\", r1, r)\n\t}\n\tif i1, err := age.ParseX25519Identity(i.String()); err != nil {\n\t\tt.Fatal(err)\n\t} else if i1.String() != i.String() {\n\t\tt.Errorf(\"identity did not round-trip through parsing: got %q, want %q\", i1, i)\n\t}\n\n\tfileKey := make([]byte, 16)\n\tif _, err := rand.Read(fileKey); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tstanzas, err := r.Wrap(fileKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tout, err := i.Unwrap(stanzas)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !bytes.Equal(fileKey, out) {\n\t\tt.Errorf(\"invalid output: %x, expected %x\", out, fileKey)\n\t}\n}\n\nfunc TestScryptRoundTrip(t *testing.T) {\n\tpassword := \"twitch.tv/filosottile\"\n\n\tr, err := age.NewScryptRecipient(password)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tr.SetWorkFactor(15)\n\ti, err := age.NewScryptIdentity(password)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfileKey := make([]byte, 16)\n\tif _, err := rand.Read(fileKey); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tstanzas, err := r.Wrap(fileKey)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tout, err := i.Unwrap(stanzas)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !bytes.Equal(fileKey, out) {\n\t\tt.Errorf(\"invalid output: %x, expected %x\", out, fileKey)\n\t}\n}\n"
        },
        {
          "name": "scrypt.go",
          "type": "blob",
          "size": 6.3408203125,
          "content": "// Copyright 2019 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage age\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\n\t\"filippo.io/age/internal/format\"\n\t\"golang.org/x/crypto/chacha20poly1305\"\n\t\"golang.org/x/crypto/scrypt\"\n)\n\nconst scryptLabel = \"age-encryption.org/v1/scrypt\"\n\n// ScryptRecipient is a password-based recipient. Anyone with the password can\n// decrypt the message.\n//\n// If a ScryptRecipient is used, it must be the only recipient for the file: it\n// can't be mixed with other recipient types and can't be used multiple times\n// for the same file.\n//\n// Its use is not recommended for automated systems, which should prefer\n// X25519Recipient.\ntype ScryptRecipient struct {\n\tpassword   []byte\n\tworkFactor int\n}\n\nvar _ Recipient = &ScryptRecipient{}\n\n// NewScryptRecipient returns a new ScryptRecipient with the provided password.\nfunc NewScryptRecipient(password string) (*ScryptRecipient, error) {\n\tif len(password) == 0 {\n\t\treturn nil, errors.New(\"passphrase can't be empty\")\n\t}\n\tr := &ScryptRecipient{\n\t\tpassword: []byte(password),\n\t\t// TODO: automatically scale this to 1s (with a min) in the CLI.\n\t\tworkFactor: 18, // 1s on a modern machine\n\t}\n\treturn r, nil\n}\n\n// SetWorkFactor sets the scrypt work factor to 2^logN.\n// It must be called before Wrap.\n//\n// If SetWorkFactor is not called, a reasonable default is used.\nfunc (r *ScryptRecipient) SetWorkFactor(logN int) {\n\tif logN > 30 || logN < 1 {\n\t\tpanic(\"age: SetWorkFactor called with illegal value\")\n\t}\n\tr.workFactor = logN\n}\n\nconst scryptSaltSize = 16\n\nfunc (r *ScryptRecipient) Wrap(fileKey []byte) ([]*Stanza, error) {\n\tsalt := make([]byte, scryptSaltSize)\n\tif _, err := rand.Read(salt[:]); err != nil {\n\t\treturn nil, err\n\t}\n\n\tlogN := r.workFactor\n\tl := &Stanza{\n\t\tType: \"scrypt\",\n\t\tArgs: []string{format.EncodeToString(salt), strconv.Itoa(logN)},\n\t}\n\n\tsalt = append([]byte(scryptLabel), salt...)\n\tk, err := scrypt.Key(r.password, salt, 1<<logN, 8, 1, chacha20poly1305.KeySize)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to generate scrypt hash: %v\", err)\n\t}\n\n\twrappedKey, err := aeadEncrypt(k, fileKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tl.Body = wrappedKey\n\n\treturn []*Stanza{l}, nil\n}\n\n// WrapWithLabels implements [age.RecipientWithLabels], returning a random\n// label. This ensures a ScryptRecipient can't be mixed with other recipients\n// (including other ScryptRecipients).\n//\n// Users reasonably expect files encrypted to a passphrase to be [authenticated]\n// by that passphrase, i.e. for it to be impossible to produce a file that\n// decrypts successfully with a passphrase without knowing it. If a file is\n// encrypted to other recipients, those parties can produce different files that\n// would break that expectation.\n//\n// [authenticated]: https://words.filippo.io/dispatches/age-authentication/\nfunc (r *ScryptRecipient) WrapWithLabels(fileKey []byte) (stanzas []*Stanza, labels []string, err error) {\n\tstanzas, err = r.Wrap(fileKey)\n\n\trandom := make([]byte, 16)\n\tif _, err := rand.Read(random); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlabels = []string{hex.EncodeToString(random)}\n\n\treturn\n}\n\n// ScryptIdentity is a password-based identity.\ntype ScryptIdentity struct {\n\tpassword      []byte\n\tmaxWorkFactor int\n}\n\nvar _ Identity = &ScryptIdentity{}\n\n// NewScryptIdentity returns a new ScryptIdentity with the provided password.\nfunc NewScryptIdentity(password string) (*ScryptIdentity, error) {\n\tif len(password) == 0 {\n\t\treturn nil, errors.New(\"passphrase can't be empty\")\n\t}\n\ti := &ScryptIdentity{\n\t\tpassword:      []byte(password),\n\t\tmaxWorkFactor: 22, // 15s on a modern machine\n\t}\n\treturn i, nil\n}\n\n// SetMaxWorkFactor sets the maximum accepted scrypt work factor to 2^logN.\n// It must be called before Unwrap.\n//\n// This caps the amount of work that Decrypt might have to do to process\n// received files. If SetMaxWorkFactor is not called, a fairly high default is\n// used, which might not be suitable for systems processing untrusted files.\nfunc (i *ScryptIdentity) SetMaxWorkFactor(logN int) {\n\tif logN > 30 || logN < 1 {\n\t\tpanic(\"age: SetMaxWorkFactor called with illegal value\")\n\t}\n\ti.maxWorkFactor = logN\n}\n\nfunc (i *ScryptIdentity) Unwrap(stanzas []*Stanza) ([]byte, error) {\n\tfor _, s := range stanzas {\n\t\tif s.Type == \"scrypt\" && len(stanzas) != 1 {\n\t\t\treturn nil, errors.New(\"an scrypt recipient must be the only one\")\n\t\t}\n\t}\n\treturn multiUnwrap(i.unwrap, stanzas)\n}\n\nvar digitsRe = regexp.MustCompile(`^[1-9][0-9]*$`)\n\nfunc (i *ScryptIdentity) unwrap(block *Stanza) ([]byte, error) {\n\tif block.Type != \"scrypt\" {\n\t\treturn nil, ErrIncorrectIdentity\n\t}\n\tif len(block.Args) != 2 {\n\t\treturn nil, errors.New(\"invalid scrypt recipient block\")\n\t}\n\tsalt, err := format.DecodeString(block.Args[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse scrypt salt: %v\", err)\n\t}\n\tif len(salt) != scryptSaltSize {\n\t\treturn nil, errors.New(\"invalid scrypt recipient block\")\n\t}\n\tif w := block.Args[1]; !digitsRe.MatchString(w) {\n\t\treturn nil, fmt.Errorf(\"scrypt work factor encoding invalid: %q\", w)\n\t}\n\tlogN, err := strconv.Atoi(block.Args[1])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse scrypt work factor: %v\", err)\n\t}\n\tif logN > i.maxWorkFactor {\n\t\treturn nil, fmt.Errorf(\"scrypt work factor too large: %v\", logN)\n\t}\n\tif logN <= 0 { // unreachable\n\t\treturn nil, fmt.Errorf(\"invalid scrypt work factor: %v\", logN)\n\t}\n\n\tsalt = append([]byte(scryptLabel), salt...)\n\tk, err := scrypt.Key(i.password, salt, 1<<logN, 8, 1, chacha20poly1305.KeySize)\n\tif err != nil { // unreachable\n\t\treturn nil, fmt.Errorf(\"failed to generate scrypt hash: %v\", err)\n\t}\n\n\t// This AEAD is not robust, so an attacker could craft a message that\n\t// decrypts under two different keys (meaning two different passphrases) and\n\t// then use an error side-channel in an online decryption oracle to learn if\n\t// either key is correct. This is deemed acceptable because the use case (an\n\t// online decryption oracle) is not recommended, and the security loss is\n\t// only one bit. This also does not bypass any scrypt work, although that work\n\t// can be precomputed in an online oracle scenario.\n\tfileKey, err := aeadDecrypt(k, fileKeySize, block.Body)\n\tif err == errIncorrectCiphertextSize {\n\t\treturn nil, errors.New(\"invalid scrypt recipient block: incorrect file key size\")\n\t} else if err != nil {\n\t\treturn nil, ErrIncorrectIdentity\n\t}\n\treturn fileKey, nil\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "testkit_test.go",
          "type": "blob",
          "size": 6.431640625,
          "content": "// Copyright 2022 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build go1.18\n// +build go1.18\n\npackage age_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"io\"\n\t\"io/fs\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"filippo.io/age\"\n\t\"filippo.io/age/armor\"\n\t\"filippo.io/age/internal/format\"\n\t\"filippo.io/age/internal/stream\"\n\t\"golang.org/x/crypto/chacha20poly1305\"\n\t\"golang.org/x/crypto/hkdf\"\n\n\tagetest \"c2sp.org/CCTV/age\"\n)\n\nfunc forEachVector(t *testing.T, f func(t *testing.T, v *vector)) {\n\ttests, err := fs.ReadDir(agetest.Vectors, \".\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, test := range tests {\n\t\tname := test.Name()\n\t\tcontents, err := fs.ReadFile(agetest.Vectors, name)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tf(t, parseVector(t, contents))\n\t\t})\n\t}\n}\n\ntype vector struct {\n\texpect      string\n\tpayloadHash *[32]byte\n\tfileKey     *[16]byte\n\tidentities  []age.Identity\n\tarmored     bool\n\tfile        []byte\n}\n\nfunc parseVector(t *testing.T, test []byte) *vector {\n\tv := &vector{file: test}\n\tfor {\n\t\tline, rest, ok := bytes.Cut(v.file, []byte(\"\\n\"))\n\t\tif !ok {\n\t\t\tt.Fatal(\"invalid test file: no payload\")\n\t\t}\n\t\tv.file = rest\n\t\tif len(line) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tkey, value, _ := strings.Cut(string(line), \": \")\n\t\tswitch key {\n\t\tcase \"expect\":\n\t\t\tswitch value {\n\t\t\tcase \"success\":\n\t\t\tcase \"HMAC failure\":\n\t\t\tcase \"header failure\":\n\t\t\tcase \"armor failure\":\n\t\t\tcase \"payload failure\":\n\t\t\tcase \"no match\":\n\t\t\tdefault:\n\t\t\t\tt.Fatal(\"invalid test file: unknown expect value:\", value)\n\t\t\t}\n\t\t\tv.expect = value\n\t\tcase \"payload\":\n\t\t\th, err := hex.DecodeString(value)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tv.payloadHash = (*[32]byte)(h)\n\t\tcase \"file key\":\n\t\t\th, err := hex.DecodeString(value)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tv.fileKey = (*[16]byte)(h)\n\t\tcase \"identity\":\n\t\t\ti, err := age.ParseX25519Identity(value)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tv.identities = append(v.identities, i)\n\t\tcase \"passphrase\":\n\t\t\ti, err := age.NewScryptIdentity(value)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tv.identities = append(v.identities, i)\n\t\tcase \"armored\":\n\t\t\tv.armored = true\n\t\tcase \"comment\":\n\t\t\tt.Log(value)\n\t\tdefault:\n\t\t\tt.Fatal(\"invalid test file: unknown header key:\", key)\n\t\t}\n\t}\n\treturn v\n}\n\nfunc TestVectors(t *testing.T) {\n\tforEachVector(t, testVector)\n}\n\nfunc testVector(t *testing.T, v *vector) {\n\tvar in io.Reader = bytes.NewReader(v.file)\n\tif v.armored {\n\t\tin = armor.NewReader(in)\n\t}\n\tr, err := age.Decrypt(in, v.identities...)\n\tif err != nil && strings.HasSuffix(err.Error(), \"bad header MAC\") {\n\t\tif v.expect == \"HMAC failure\" {\n\t\t\tt.Log(err)\n\t\t\treturn\n\t\t}\n\t\tt.Fatalf(\"expected %s, got HMAC error\", v.expect)\n\t} else if e := new(armor.Error); errors.As(err, &e) {\n\t\tif v.expect == \"armor failure\" {\n\t\t\tt.Log(err)\n\t\t\treturn\n\t\t}\n\t\tt.Fatalf(\"expected %s, got: %v\", v.expect, err)\n\t} else if _, ok := err.(*age.NoIdentityMatchError); ok {\n\t\tif v.expect == \"no match\" {\n\t\t\tt.Log(err)\n\t\t\treturn\n\t\t}\n\t\tt.Fatalf(\"expected %s, got: %v\", v.expect, err)\n\t} else if err != nil {\n\t\tif v.expect == \"header failure\" {\n\t\t\tt.Log(err)\n\t\t\treturn\n\t\t}\n\t\tt.Fatalf(\"expected %s, got: %v\", v.expect, err)\n\t} else if v.expect != \"success\" && v.expect != \"payload failure\" &&\n\t\tv.expect != \"armor failure\" {\n\t\tt.Fatalf(\"expected %s, got success\", v.expect)\n\t}\n\tout, err := io.ReadAll(r)\n\tif err != nil && v.expect == \"success\" {\n\t\tt.Fatalf(\"expected %s, got: %v\", v.expect, err)\n\t} else if err != nil {\n\t\tt.Log(err)\n\t\tif v.expect == \"armor failure\" {\n\t\t\tif e := new(armor.Error); !errors.As(err, &e) {\n\t\t\t\tt.Errorf(\"expected armor.Error, got %T\", err)\n\t\t\t}\n\t\t}\n\t\tif v.payloadHash != nil && sha256.Sum256(out) != *v.payloadHash {\n\t\t\tt.Error(\"partial payload hash mismatch\")\n\t\t}\n\t\treturn\n\t} else if v.expect != \"success\" {\n\t\tt.Fatalf(\"expected %s, got success\", v.expect)\n\t}\n\tif sha256.Sum256(out) != *v.payloadHash {\n\t\tt.Error(\"payload hash mismatch\")\n\t}\n}\n\n// TestVectorsRoundTrip checks that any (valid) armor, header, and/or STREAM\n// payload in the test vectors re-encodes identically.\nfunc TestVectorsRoundTrip(t *testing.T) {\n\tforEachVector(t, testVectorRoundTrip)\n}\n\nfunc testVectorRoundTrip(t *testing.T, v *vector) {\n\tif v.armored {\n\t\tif v.expect == \"armor failure\" {\n\t\t\tt.SkipNow()\n\t\t}\n\t\tt.Run(\"armor\", func(t *testing.T) {\n\t\t\tpayload, err := io.ReadAll(armor.NewReader(bytes.NewReader(v.file)))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tbuf := &bytes.Buffer{}\n\t\t\tw := armor.NewWriter(buf)\n\t\t\tif _, err := w.Write(payload); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\t// Armor format is not perfectly strict: CRLF â†” LF and trailing and\n\t\t\t// leading spaces are allowed and won't round-trip.\n\t\t\texpect := bytes.Replace(v.file, []byte(\"\\r\\n\"), []byte(\"\\n\"), -1)\n\t\t\texpect = bytes.TrimSpace(expect)\n\t\t\texpect = append(expect, '\\n')\n\t\t\tif !bytes.Equal(buf.Bytes(), expect) {\n\t\t\t\tt.Error(\"got a different armor encoding\")\n\t\t\t}\n\t\t})\n\t\t// Armor tests are not interesting beyond their armor encoding.\n\t\treturn\n\t}\n\n\tif v.expect == \"header failure\" {\n\t\tt.SkipNow()\n\t}\n\thdr, p, err := format.Parse(bytes.NewReader(v.file))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tpayload, err := io.ReadAll(p)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tt.Run(\"header\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tif err := hdr.Marshal(buf); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tbuf.Write(payload)\n\t\tif !bytes.Equal(buf.Bytes(), v.file) {\n\t\t\tt.Error(\"got a different header+payload encoding\")\n\t\t}\n\t})\n\n\tif v.expect == \"success\" {\n\t\tt.Run(\"STREAM\", func(t *testing.T) {\n\t\t\tnonce, payload := payload[:16], payload[16:]\n\t\t\tkey := streamKey(v.fileKey[:], nonce)\n\t\t\tr, err := stream.NewReader(key, bytes.NewReader(payload))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tplaintext, err := io.ReadAll(r)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tbuf := &bytes.Buffer{}\n\t\t\tw, err := stream.NewWriter(key, buf)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif _, err := w.Write(plaintext); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif !bytes.Equal(buf.Bytes(), payload) {\n\t\t\t\tt.Error(\"got a different STREAM ciphertext\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc streamKey(fileKey, nonce []byte) []byte {\n\th := hkdf.New(sha256.New, fileKey, nonce, []byte(\"payload\"))\n\tstreamKey := make([]byte, chacha20poly1305.KeySize)\n\tif _, err := io.ReadFull(h, streamKey); err != nil {\n\t\tpanic(\"age: internal error: failed to read from HKDF: \" + err.Error())\n\t}\n\treturn streamKey\n}\n"
        },
        {
          "name": "x25519.go",
          "type": "blob",
          "size": 6.0927734375,
          "content": "// Copyright 2019 The age Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage age\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"filippo.io/age/internal/bech32\"\n\t\"filippo.io/age/internal/format\"\n\t\"golang.org/x/crypto/chacha20poly1305\"\n\t\"golang.org/x/crypto/curve25519\"\n\t\"golang.org/x/crypto/hkdf\"\n)\n\nconst x25519Label = \"age-encryption.org/v1/X25519\"\n\n// X25519Recipient is the standard age public key. Messages encrypted to this\n// recipient can be decrypted with the corresponding X25519Identity.\n//\n// This recipient is anonymous, in the sense that an attacker can't tell from\n// the message alone if it is encrypted to a certain recipient.\ntype X25519Recipient struct {\n\ttheirPublicKey []byte\n}\n\nvar _ Recipient = &X25519Recipient{}\n\n// newX25519RecipientFromPoint returns a new X25519Recipient from a raw Curve25519 point.\nfunc newX25519RecipientFromPoint(publicKey []byte) (*X25519Recipient, error) {\n\tif len(publicKey) != curve25519.PointSize {\n\t\treturn nil, errors.New(\"invalid X25519 public key\")\n\t}\n\tr := &X25519Recipient{\n\t\ttheirPublicKey: make([]byte, curve25519.PointSize),\n\t}\n\tcopy(r.theirPublicKey, publicKey)\n\treturn r, nil\n}\n\n// ParseX25519Recipient returns a new X25519Recipient from a Bech32 public key\n// encoding with the \"age1\" prefix.\nfunc ParseX25519Recipient(s string) (*X25519Recipient, error) {\n\tt, k, err := bech32.Decode(s)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"malformed recipient %q: %v\", s, err)\n\t}\n\tif t != \"age\" {\n\t\treturn nil, fmt.Errorf(\"malformed recipient %q: invalid type %q\", s, t)\n\t}\n\tr, err := newX25519RecipientFromPoint(k)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"malformed recipient %q: %v\", s, err)\n\t}\n\treturn r, nil\n}\n\nfunc (r *X25519Recipient) Wrap(fileKey []byte) ([]*Stanza, error) {\n\tephemeral := make([]byte, curve25519.ScalarSize)\n\tif _, err := rand.Read(ephemeral); err != nil {\n\t\treturn nil, err\n\t}\n\tourPublicKey, err := curve25519.X25519(ephemeral, curve25519.Basepoint)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsharedSecret, err := curve25519.X25519(ephemeral, r.theirPublicKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tl := &Stanza{\n\t\tType: \"X25519\",\n\t\tArgs: []string{format.EncodeToString(ourPublicKey)},\n\t}\n\n\tsalt := make([]byte, 0, len(ourPublicKey)+len(r.theirPublicKey))\n\tsalt = append(salt, ourPublicKey...)\n\tsalt = append(salt, r.theirPublicKey...)\n\th := hkdf.New(sha256.New, sharedSecret, salt, []byte(x25519Label))\n\twrappingKey := make([]byte, chacha20poly1305.KeySize)\n\tif _, err := io.ReadFull(h, wrappingKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\twrappedKey, err := aeadEncrypt(wrappingKey, fileKey)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tl.Body = wrappedKey\n\n\treturn []*Stanza{l}, nil\n}\n\n// String returns the Bech32 public key encoding of r.\nfunc (r *X25519Recipient) String() string {\n\ts, _ := bech32.Encode(\"age\", r.theirPublicKey)\n\treturn s\n}\n\n// X25519Identity is the standard age private key, which can decrypt messages\n// encrypted to the corresponding X25519Recipient.\ntype X25519Identity struct {\n\tsecretKey, ourPublicKey []byte\n}\n\nvar _ Identity = &X25519Identity{}\n\n// newX25519IdentityFromScalar returns a new X25519Identity from a raw Curve25519 scalar.\nfunc newX25519IdentityFromScalar(secretKey []byte) (*X25519Identity, error) {\n\tif len(secretKey) != curve25519.ScalarSize {\n\t\treturn nil, errors.New(\"invalid X25519 secret key\")\n\t}\n\ti := &X25519Identity{\n\t\tsecretKey: make([]byte, curve25519.ScalarSize),\n\t}\n\tcopy(i.secretKey, secretKey)\n\ti.ourPublicKey, _ = curve25519.X25519(i.secretKey, curve25519.Basepoint)\n\treturn i, nil\n}\n\n// GenerateX25519Identity randomly generates a new X25519Identity.\nfunc GenerateX25519Identity() (*X25519Identity, error) {\n\tsecretKey := make([]byte, curve25519.ScalarSize)\n\tif _, err := rand.Read(secretKey); err != nil {\n\t\treturn nil, fmt.Errorf(\"internal error: %v\", err)\n\t}\n\treturn newX25519IdentityFromScalar(secretKey)\n}\n\n// ParseX25519Identity returns a new X25519Identity from a Bech32 private key\n// encoding with the \"AGE-SECRET-KEY-1\" prefix.\nfunc ParseX25519Identity(s string) (*X25519Identity, error) {\n\tt, k, err := bech32.Decode(s)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"malformed secret key: %v\", err)\n\t}\n\tif t != \"AGE-SECRET-KEY-\" {\n\t\treturn nil, fmt.Errorf(\"malformed secret key: unknown type %q\", t)\n\t}\n\tr, err := newX25519IdentityFromScalar(k)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"malformed secret key: %v\", err)\n\t}\n\treturn r, nil\n}\n\nfunc (i *X25519Identity) Unwrap(stanzas []*Stanza) ([]byte, error) {\n\treturn multiUnwrap(i.unwrap, stanzas)\n}\n\nfunc (i *X25519Identity) unwrap(block *Stanza) ([]byte, error) {\n\tif block.Type != \"X25519\" {\n\t\treturn nil, ErrIncorrectIdentity\n\t}\n\tif len(block.Args) != 1 {\n\t\treturn nil, errors.New(\"invalid X25519 recipient block\")\n\t}\n\tpublicKey, err := format.DecodeString(block.Args[0])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse X25519 recipient: %v\", err)\n\t}\n\tif len(publicKey) != curve25519.PointSize {\n\t\treturn nil, errors.New(\"invalid X25519 recipient block\")\n\t}\n\n\tsharedSecret, err := curve25519.X25519(i.secretKey, publicKey)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid X25519 recipient: %v\", err)\n\t}\n\n\tsalt := make([]byte, 0, len(publicKey)+len(i.ourPublicKey))\n\tsalt = append(salt, publicKey...)\n\tsalt = append(salt, i.ourPublicKey...)\n\th := hkdf.New(sha256.New, sharedSecret, salt, []byte(x25519Label))\n\twrappingKey := make([]byte, chacha20poly1305.KeySize)\n\tif _, err := io.ReadFull(h, wrappingKey); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfileKey, err := aeadDecrypt(wrappingKey, fileKeySize, block.Body)\n\tif err == errIncorrectCiphertextSize {\n\t\treturn nil, errors.New(\"invalid X25519 recipient block: incorrect file key size\")\n\t} else if err != nil {\n\t\treturn nil, ErrIncorrectIdentity\n\t}\n\treturn fileKey, nil\n}\n\n// Recipient returns the public X25519Recipient value corresponding to i.\nfunc (i *X25519Identity) Recipient() *X25519Recipient {\n\tr := &X25519Recipient{}\n\tr.theirPublicKey = i.ourPublicKey\n\treturn r\n}\n\n// String returns the Bech32 private key encoding of i.\nfunc (i *X25519Identity) String() string {\n\ts, _ := bech32.Encode(\"AGE-SECRET-KEY-\", i.secretKey)\n\treturn strings.ToUpper(s)\n}\n"
        }
      ]
    }
  ]
}