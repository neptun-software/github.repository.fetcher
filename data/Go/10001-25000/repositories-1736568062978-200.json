{
  "metadata": {
    "timestamp": 1736568062978,
    "page": 200,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rivo/tview",
      "stars": 11350,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.154296875,
          "content": "# Contributing to tview\n\nFirst of all, thank you for taking the time to contribute.\n\nThe following provides you with some guidance on how to contribute to this project. Mainly, it is meant to save us all some time so please read it, it's not long.\n\nPlease note that this document is work in progress so I might add to it in the future.\n\n## Issues\n\n- Please include enough information so everybody understands your request.\n- Screenshots or code that illustrates your point always helps.\n- It's fine to ask for help. But you should have checked out the [documentation](https://godoc.org/github.com/rivo/tview) first in any case.\n- If you request a new feature, state your motivation and share a use case that you faced where you needed that new feature. It should be something that others will also need.\n\n## Pull Requests\n\nIn my limited time I can spend on this project, I will always go through issues first before looking at pull requests. It takes a _lot_ of time to look at code that you submitted and I may not have that time. So be prepared to have your pull requests lying around for a long time.\n\nTherefore, if you have a feature request, open an issue first before sending me a pull request, and allow for some discussion. It may save you from writing code that will get rejected. If your case is strong, there is a good chance that I will add the feature for you.\n\nI'm very picky about the code that goes into this repo. So if you violate any of the following guidelines, there is a good chance I won't merge your pull request.\n\n- There must be a strong case for your additions/changes, such as:\n  - Bug fixes\n  - Features that are needed (see \"Issues\" above; state your motivation)\n  - Improvements in stability or performance (if readability does not suffer)\n- Your code must follow the structure of the existing code. Don't just patch something on. Try to understand how `tview` is currently designed and follow that design. Your code needs to be consistent with existing code.\n- If you're adding code that increases the work required to maintain the project, you must be willing to take responsibility for that extra work. I will ask you to maintain your part of the code in the long run.\n- Function/type/variable/constant names must be as descriptive as they are right now. Follow the conventions of the package.\n- All functions/types/variables/constants, even private ones, must have comments in good English. These comments must be elaborate enough so that new users of the package understand them and can follow them. Provide examples if you have to. Start all sentences upper-case, as is common in English, and end them with a period. Comments in their own lines must not exceed the 80 character border. Break over if necessary.\n- A new function should be located close to related functions in the file. For example, `GetColor()` should come after (or before) `SetColor()`.\n- Your changes must not decrease the project's [Go Report](https://goreportcard.com/report/github.com/rivo/tview) rating.\n- No breaking changes unless there is absolutely no other way.\n- If an issue accompanies your pull request, reference it in the PR's comments, e.g. \"Fixes #123\", so it is closed automatically when the PR is closed.\n"
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2018 Oliver Kuederle\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 10.015625,
          "content": "# Rich Interactive Widgets for Terminal UIs\n\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/rivo/tview)](https://pkg.go.dev/github.com/rivo/tview)\n[![Go Report](https://img.shields.io/badge/go%20report-A%2B-brightgreen.svg)](https://goreportcard.com/report/github.com/rivo/tview)\n\nThis Go package provides commonly used components for terminal based user interfaces.\n\n![Screenshot](tview.gif)\n\nAmong these components are:\n\n- __Input forms__ (including __text input__, __selections__, __checkboxes__, and __buttons__)\n- Navigable multi-color __text views__\n- Editable multi-line __text areas__\n- Sophisticated navigable __table views__\n- Flexible __tree views__\n- Selectable __lists__\n- __Images__\n- __Grid__, __Flexbox__ and __page layouts__\n- Modal __message windows__\n- An __application__ wrapper\n\nThey come with lots of customization options and can be easily extended to fit your needs.\n\n## Usage\n\nTo add this package to your project:\n\n```bash\ngo get github.com/rivo/tview@master\n```\n\n## Hello World\n\nThis basic example creates a box titled \"Hello, World!\" and displays it in your terminal:\n\n```go\npackage main\n\nimport (\n\t\"github.com/rivo/tview\"\n)\n\nfunc main() {\n\tbox := tview.NewBox().SetBorder(true).SetTitle(\"Hello, world!\")\n\tif err := tview.NewApplication().SetRoot(box, true).Run(); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n\nCheck out the [GitHub Wiki](https://github.com/rivo/tview/wiki) for more examples along with screenshots. Or try the examples in the \"demos\" subdirectory.\n\nFor a presentation highlighting this package, compile and run the program found in the \"demos/presentation\" subdirectory.\n\n## Projects using `tview`\n\n- [K9s - Kubernetes CLI](https://github.com/derailed/k9s)\n- [IRCCloud Terminal Client](https://github.com/termoose/irccloud)\n- [Window manager for `tview`](https://github.com/epiclabs-io/winman)\n- [CLI bookmark manager](https://github.com/Endi1/drawer)\n- [A caving database interface written in Go](https://github.com/IdlePhysicist/cave-logger)\n- [Interactive file browse and exec any command.](https://github.com/bannzai/itree)\n- [A complete TUI for LDAP](https://github.com/Macmod/godap)\n- [A simple CRM](https://github.com/broadcastle/crm)\n- [Terminal UI for todist](https://github.com/cyberdummy/todoista)\n- [Graphical kubectl wrapper](https://github.com/dcaiafa/kpick)\n- [Decred Decentralized Exchange ](https://github.com/decred/dcrdex)\n- [A CLI file browser for Raspberry PI](https://github.com/destinmoulton/pixi)\n- [A tool to manage projects.](https://github.com/divramod/dp)\n- [A simple app for BMI monitoring](https://github.com/erleene/go-bmi)\n- [Stream TIDAL from command line](https://github.com/godsic/vibe)\n- [Secure solution for fully decentralized password management](https://github.com/guillaumemichel/passtor/)\n- [A growing collection of convenient little tools to work with systemd services](https://github.com/muesli/service-tools/)\n- [A terminal based browser for Redis written in Go](https://github.com/nitishm/redis-terminal)\n- [First project for the Computer Networks course.](https://github.com/pablogadhi/XMPPClient)\n- [Test your typing speed in the terminal!](https://github.com/shilangyu/typer-go)\n- [TUI Client for Docker](https://github.com/skanehira/docui)\n- [SSH client using certificates signed by HashiCorp Vault](https://github.com/stephane-martin/vssh)\n- [VMware vCenter Text UI](https://github.com/thebsdbox/vctui)\n- [Bookmarks on terminal](https://github.com/tryffel/bookmarker)\n- [A UDP testing utility](https://github.com/vaelen/udp-tester)\n- [A simple Kanban board for your terminal](https://github.com/witchard/toukan)\n- [The personal information dashboard for your terminal. ](https://github.com/wtfutil/wtf)\n- [MySQL database to Golang struct](https://github.com/xxjwxc/gormt)\n- [Discord, TUI and SIXEL.](https://gitlab.com/diamondburned/6cord)\n- [A CLI Audio Player](https://www.github.com/dhulihan/grump)\n- [GLab, a GitLab CLI tool](https://gitlab.com/profclems/glab)\n- [Browse your AWS ECS Clusters in the Terminal](https://github.com/swartzrock/ecsview)\n- [The CLI Task Manager for Geeks](https://github.com/ajaxray/geek-life)\n- [Fast disk usage analyzer written in Go](https://github.com/dundee/gdu)\n- [Multiplayer Chess On Terminal](https://github.com/qnkhuat/gochess)\n- [Scriptable TUI music player](https://github.com/issadarkthing/gomu)\n- [MangaDesk : TUI Client for downloading manga to your computer](https://github.com/darylhjd/mangadesk)\n- [Go How Much? a Crypto coin price tracking from terminal](https://github.com/ledongthuc/gohowmuch)\n- [dbui: Universal CLI for Database Connections](https://github.com/KenanBek/dbui)\n- [ssmbrowse: Simple and elegant cli AWS SSM parameter browser](https://github.com/bnaydenov/ssmbrowse)\n- [gobit: binance intelligence terminal](https://github.com/infl00p/gobit)\n- [viddy: A modern watch command](https://github.com/sachaos/viddy)\n- [s3surfer: CLI tool for browsing S3 bucket and download objects interactively](https://github.com/hirose31/s3surfer)\n- [libgen-tui: A terminal UI for downloading books from Library Genesis](https://github.com/audstanley/libgen-tui)\n- [kubectl-lazy: kubectl plugin to easy to view pod](https://github.com/togettoyou/kubectl-lazy)\n- [podman-tui: podman user interface](https://github.com/containers/podman-tui)\n- [tvxwidgets: tview extra widgets](https://github.com/navidys/tvxwidgets)\n- [Domino card game on terminal](https://github.com/gusti-andika/card-domino.git)\n- [goaround: Query stackoverflow API and get results on terminal](https://github.com/glendsoza/goaround)\n- [resto: a CLI app can send pretty HTTP & API requests with TUI](https://github.com/abdfnx/resto)\n- [twad: a WAD launcher for the terminal](https://github.com/zmnpl/twad)\n- [pacseek: A TUI for searching and installing Arch Linux packages](https://github.com/moson-mo/pacseek)\n- [7GUIs demo](https://github.com/letientai299/7guis/tree/master/tui)\n- [tuihub: A utility hub/dashboard for personal use](https://github.com/ashis0013/tuihub)\n- [l'oggo: A terminal app for structured log streaming (GCP stack driver, k8s, local streaming)](https://github.com/aurc/loggo)\n- [reminder: Terminal based interactive app for organising tasks with minimal efforts.](https://github.com/goyalmunish/reminder)\n- [tufw: A terminal UI for ufw.](https://github.com/peltho/tufw)\n- [gh: the GitHub CLI](https://github.com/cli/cli)\n- [piptui: Terminal UI to manage pip packages](https://github.com/glendsoza/piptui/)\n- [cross-clipboard: A cross-platform clipboard sharing](https://github.com/ntsd/cross-clipboard)\n- [tui-deck: nextcloud deck frontend](https://github.com/mebitek/tui-deck)\n- [ktop: A top-like tool for your Kubernetes clusters](https://github.com/vladimirvivien/ktop)\n- [blimp: UI for weather, network latency, application status, & more](https://github.com/merlinfuchs/blimp)\n- [Curly - A simple TUI leveraging curl to test endpoints](https://github.com/migcaraballo/curly)\n- [amtui: Alertmanager TUI](https://github.com/pehlicd/amtui)\n- [A TUI CLI manager](https://github.com/costa86/cli-manager)\n- [PrivateBTC](https://github.com/adrianbrad/privatebtc)\n- [play: A TUI playground to experiment with your favorite programs, such as grep, sed, awk, jq and yq](https://github.com/paololazzari/play)\n- [gorest: Enjoy making HTTP requests in your terminal, just like you do in Insomnia.](https://github.com/NathanFirmo/gorest)\n- [Terminal-based application to listen Radio Stations around the world!](https://github.com/vergonha/garden-tui)\n- [ntui: A TUI to manage Hashicorp Nomad clusters](https://github.com/SHAPPY0/ntui)\n- [lazysql: A cross-platform TUI database management tool written in Go](https://github.com/jorgerojas26/lazysql)\n- [redis-tui: A Redis Text-based UI client in CLI](https://github.com/mylxsw/redis-tui)\n- [fen: File manager](https://github.com/kivattt/fen)\n- [sqltui: A terminal UI to operate sql and nosql databases](https://github.com/LinPr/sqltui)\n- [DBee: Simple database browser](https://github.com/murat-cileli/dbee)\n- [oddshub: A TUI for sports betting odds](https://github.com/dos-2/oddshub)\n- [envolve: Terminal based interactive app for manage enviroment variables](https://github.com/erdemkosk/envolve)\n- [zfs-file-history: Terminal UI for inspecting and restoring file history on ZFS snapshots](https://github.com/markusressel/zfs-file-history)\n- [fan2go-tui: Terminal UI for fan2go](https://github.com/markusressel/fan2go-tui)\n\n## Documentation\n\nRefer to https://pkg.go.dev/github.com/rivo/tview for the package's documentation. Also check out the [Wiki](https://github.com/rivo/tview/wiki).\n\n## Dependencies\n\nThis package is based on [github.com/gdamore/tcell](https://github.com/gdamore/tcell) (and its dependencies) as well as on [github.com/rivo/uniseg](https://github.com/rivo/uniseg).\n\n## Sponsor this Project\n\n[Become a Sponsor on GitHub](https://github.com/sponsors/rivo?metadata_source=tview_readme) to further this project!\n\n## Versioning and Backwards-Compatibility\n\nI try really hard to keep this project backwards compatible. Your software should not break when you upgrade `tview`. But this also means that some of its shortcomings that were present in the initial versions will remain. In addition, at least for the time being, you won't find any version tags in this repo. The newest version should be the one to upgrade to. It has all the bugfixes and latest features. Having said that, backwards compatibility may still break when:\n\n- a new version of an imported package (most likely [`tcell`](https://github.com/gdamore/tcell)) changes in such a way that forces me to make changes in `tview` as well,\n- I fix something that I consider a bug, rather than a feature, something that does not work as originally intended,\n- I make changes to \"internal\" interfaces such as [`Primitive`](https://pkg.go.dev/github.com/rivo/tview#Primitive). You shouldn't need these interfaces unless you're writing your own primitives for `tview`. (Yes, I realize these are public interfaces. This has advantages as well as disadvantages. For the time being, it is what it is.)\n\n## Your Feedback\n\nAdd your issue here on GitHub. Feel free to get in touch if you have any questions.\n\n## Code of Conduct\n\nWe follow Golang's Code of Conduct which you can find [here](https://golang.org/conduct).\n"
        },
        {
          "name": "ansi.go",
          "type": "blob",
          "size": 8.1318359375,
          "content": "package tview\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// The states of the ANSI escape code parser.\nconst (\n\tansiText = iota\n\tansiEscape\n\tansiSubstring\n\tansiControlSequence\n)\n\n// ansi is a io.Writer which translates ANSI escape codes into tview color\n// tags.\ntype ansi struct {\n\tio.Writer\n\n\t// Reusable buffers.\n\tbuffer                        *bytes.Buffer // The entire output text of one Write().\n\tcsiParameter, csiIntermediate *bytes.Buffer // Partial CSI strings.\n\tattributes                    string        // The buffer's current text attributes (a tview attribute string).\n\n\t// The current state of the parser. One of the ansi constants.\n\tstate int\n}\n\n// ANSIWriter returns an io.Writer which translates any ANSI escape codes\n// written to it into tview style tags. Other escape codes don't have an effect\n// and are simply removed. The translated text is written to the provided\n// writer.\nfunc ANSIWriter(writer io.Writer) io.Writer {\n\treturn &ansi{\n\t\tWriter:          writer,\n\t\tbuffer:          new(bytes.Buffer),\n\t\tcsiParameter:    new(bytes.Buffer),\n\t\tcsiIntermediate: new(bytes.Buffer),\n\t\tstate:           ansiText,\n\t}\n}\n\n// Write parses the given text as a string of runes, translates ANSI escape\n// codes to style tags and writes them to the output writer.\nfunc (a *ansi) Write(text []byte) (int, error) {\n\tdefer func() {\n\t\ta.buffer.Reset()\n\t}()\n\n\tfor _, r := range string(text) {\n\t\tswitch a.state {\n\n\t\t// We just entered an escape sequence.\n\t\tcase ansiEscape:\n\t\t\tswitch r {\n\t\t\tcase '[': // Control Sequence Introducer.\n\t\t\t\ta.csiParameter.Reset()\n\t\t\t\ta.csiIntermediate.Reset()\n\t\t\t\ta.state = ansiControlSequence\n\t\t\tcase 'c': // Reset.\n\t\t\t\tfmt.Fprint(a.buffer, \"[-:-:-]\")\n\t\t\t\ta.state = ansiText\n\t\t\tcase 'P', ']', 'X', '^', '_': // Substrings and commands.\n\t\t\t\ta.state = ansiSubstring\n\t\t\tdefault: // Ignore.\n\t\t\t\ta.state = ansiText\n\t\t\t}\n\n\t\t// CSI Sequences.\n\t\tcase ansiControlSequence:\n\t\t\tswitch {\n\t\t\tcase r >= 0x30 && r <= 0x3f: // Parameter bytes.\n\t\t\t\tif _, err := a.csiParameter.WriteRune(r); err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\tcase r >= 0x20 && r <= 0x2f: // Intermediate bytes.\n\t\t\t\tif _, err := a.csiIntermediate.WriteRune(r); err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\tcase r >= 0x40 && r <= 0x7e: // Final byte.\n\t\t\t\tswitch r {\n\t\t\t\tcase 'E': // Next line.\n\t\t\t\t\tcount, _ := strconv.Atoi(a.csiParameter.String())\n\t\t\t\t\tif count == 0 {\n\t\t\t\t\t\tcount = 1\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Fprint(a.buffer, strings.Repeat(\"\\n\", count))\n\t\t\t\tcase 'm': // Select Graphic Rendition.\n\t\t\t\t\tvar background, foreground string\n\t\t\t\t\tparams := a.csiParameter.String()\n\t\t\t\t\tfields := strings.Split(params, \";\")\n\t\t\t\t\tif len(params) == 0 || fields[0] == \"\" || fields[0] == \"0\" {\n\t\t\t\t\t\t// Reset.\n\t\t\t\t\t\ta.attributes = \"\"\n\t\t\t\t\t\tif _, err := a.buffer.WriteString(\"[-:-:-]\"); err != nil {\n\t\t\t\t\t\t\treturn 0, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tlookupColor := func(colorNumber int) string {\n\t\t\t\t\t\tif colorNumber < 0 || colorNumber > 15 {\n\t\t\t\t\t\t\treturn \"black\"\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn []string{\n\t\t\t\t\t\t\t\"black\",\n\t\t\t\t\t\t\t\"maroon\",\n\t\t\t\t\t\t\t\"green\",\n\t\t\t\t\t\t\t\"olive\",\n\t\t\t\t\t\t\t\"navy\",\n\t\t\t\t\t\t\t\"purple\",\n\t\t\t\t\t\t\t\"teal\",\n\t\t\t\t\t\t\t\"silver\",\n\t\t\t\t\t\t\t\"gray\",\n\t\t\t\t\t\t\t\"red\",\n\t\t\t\t\t\t\t\"lime\",\n\t\t\t\t\t\t\t\"yellow\",\n\t\t\t\t\t\t\t\"blue\",\n\t\t\t\t\t\t\t\"fuchsia\",\n\t\t\t\t\t\t\t\"aqua\",\n\t\t\t\t\t\t\t\"white\",\n\t\t\t\t\t\t}[colorNumber]\n\t\t\t\t\t}\n\t\t\t\tFieldLoop:\n\t\t\t\t\tfor index, field := range fields {\n\t\t\t\t\t\tswitch field {\n\t\t\t\t\t\tcase \"1\", \"01\":\n\t\t\t\t\t\t\tif !strings.ContainsRune(a.attributes, 'b') {\n\t\t\t\t\t\t\t\ta.attributes += \"b\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"2\", \"02\":\n\t\t\t\t\t\t\tif !strings.ContainsRune(a.attributes, 'd') {\n\t\t\t\t\t\t\t\ta.attributes += \"d\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"3\", \"03\":\n\t\t\t\t\t\t\tif !strings.ContainsRune(a.attributes, 'i') {\n\t\t\t\t\t\t\t\ta.attributes += \"i\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"4\", \"04\":\n\t\t\t\t\t\t\tif !strings.ContainsRune(a.attributes, 'u') {\n\t\t\t\t\t\t\t\ta.attributes += \"u\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"5\", \"05\":\n\t\t\t\t\t\t\tif !strings.ContainsRune(a.attributes, 'l') {\n\t\t\t\t\t\t\t\ta.attributes += \"l\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"7\", \"07\":\n\t\t\t\t\t\t\tif !strings.ContainsRune(a.attributes, 'r') {\n\t\t\t\t\t\t\t\ta.attributes += \"r\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"9\", \"09\":\n\t\t\t\t\t\t\tif !strings.ContainsRune(a.attributes, 's') {\n\t\t\t\t\t\t\t\ta.attributes += \"s\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"22\":\n\t\t\t\t\t\t\tif i := strings.IndexRune(a.attributes, 'b'); i >= 0 {\n\t\t\t\t\t\t\t\ta.attributes = a.attributes[:i] + a.attributes[i+1:]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif i := strings.IndexRune(a.attributes, 'd'); i >= 0 {\n\t\t\t\t\t\t\t\ta.attributes = a.attributes[:i] + a.attributes[i+1:]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"23\":\n\t\t\t\t\t\t\tif i := strings.IndexRune(a.attributes, 'i'); i >= 0 {\n\t\t\t\t\t\t\t\ta.attributes = a.attributes[:i] + a.attributes[i+1:]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"24\":\n\t\t\t\t\t\t\tif i := strings.IndexRune(a.attributes, 'u'); i >= 0 {\n\t\t\t\t\t\t\t\ta.attributes = a.attributes[:i] + a.attributes[i+1:]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"25\":\n\t\t\t\t\t\t\tif i := strings.IndexRune(a.attributes, 'l'); i >= 0 {\n\t\t\t\t\t\t\t\ta.attributes = a.attributes[:i] + a.attributes[i+1:]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"27\":\n\t\t\t\t\t\t\tif i := strings.IndexRune(a.attributes, 'r'); i >= 0 {\n\t\t\t\t\t\t\t\ta.attributes = a.attributes[:i] + a.attributes[i+1:]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"29\":\n\t\t\t\t\t\t\tif i := strings.IndexRune(a.attributes, 's'); i >= 0 {\n\t\t\t\t\t\t\t\ta.attributes = a.attributes[:i] + a.attributes[i+1:]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\":\n\t\t\t\t\t\t\tcolorNumber, _ := strconv.Atoi(field)\n\t\t\t\t\t\t\tforeground = lookupColor(colorNumber - 30)\n\t\t\t\t\t\tcase \"39\":\n\t\t\t\t\t\t\tforeground = \"-\"\n\t\t\t\t\t\tcase \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\":\n\t\t\t\t\t\t\tcolorNumber, _ := strconv.Atoi(field)\n\t\t\t\t\t\t\tbackground = lookupColor(colorNumber - 40)\n\t\t\t\t\t\tcase \"49\":\n\t\t\t\t\t\t\tbackground = \"-\"\n\t\t\t\t\t\tcase \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\":\n\t\t\t\t\t\t\tcolorNumber, _ := strconv.Atoi(field)\n\t\t\t\t\t\t\tforeground = lookupColor(colorNumber - 82)\n\t\t\t\t\t\tcase \"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\":\n\t\t\t\t\t\t\tcolorNumber, _ := strconv.Atoi(field)\n\t\t\t\t\t\t\tbackground = lookupColor(colorNumber - 92)\n\t\t\t\t\t\tcase \"38\", \"48\":\n\t\t\t\t\t\t\tvar color string\n\t\t\t\t\t\t\tif len(fields) > index+1 {\n\t\t\t\t\t\t\t\tif fields[index+1] == \"5\" && len(fields) > index+2 { // 8-bit colors.\n\t\t\t\t\t\t\t\t\tcolorNumber, _ := strconv.Atoi(fields[index+2])\n\t\t\t\t\t\t\t\t\tif colorNumber <= 15 {\n\t\t\t\t\t\t\t\t\t\tcolor = lookupColor(colorNumber)\n\t\t\t\t\t\t\t\t\t} else if colorNumber <= 231 {\n\t\t\t\t\t\t\t\t\t\tred := (colorNumber - 16) / 36\n\t\t\t\t\t\t\t\t\t\tgreen := ((colorNumber - 16) / 6) % 6\n\t\t\t\t\t\t\t\t\t\tblue := (colorNumber - 16) % 6\n\t\t\t\t\t\t\t\t\t\tcolor = fmt.Sprintf(\"#%02x%02x%02x\", 255*red/5, 255*green/5, 255*blue/5)\n\t\t\t\t\t\t\t\t\t} else if colorNumber <= 255 {\n\t\t\t\t\t\t\t\t\t\tgrey := 255 * (colorNumber - 232) / 23\n\t\t\t\t\t\t\t\t\t\tcolor = fmt.Sprintf(\"#%02x%02x%02x\", grey, grey, grey)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if fields[index+1] == \"2\" && len(fields) > index+4 { // 24-bit colors.\n\t\t\t\t\t\t\t\t\tred, _ := strconv.Atoi(fields[index+2])\n\t\t\t\t\t\t\t\t\tgreen, _ := strconv.Atoi(fields[index+3])\n\t\t\t\t\t\t\t\t\tblue, _ := strconv.Atoi(fields[index+4])\n\t\t\t\t\t\t\t\t\tcolor = fmt.Sprintf(\"#%02x%02x%02x\", red, green, blue)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif len(color) > 0 {\n\t\t\t\t\t\t\t\tif field == \"38\" {\n\t\t\t\t\t\t\t\t\tforeground = color\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbackground = color\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak FieldLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar colon string\n\t\t\t\t\tif len(a.attributes) > 0 {\n\t\t\t\t\t\tcolon = \":\"\n\t\t\t\t\t}\n\t\t\t\t\tif len(foreground) > 0 || len(background) > 0 || len(a.attributes) > 0 {\n\t\t\t\t\t\tfmt.Fprintf(a.buffer, \"[%s:%s%s%s]\", foreground, background, colon, a.attributes)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta.state = ansiText\n\t\t\tdefault: // Undefined byte.\n\t\t\t\ta.state = ansiText // Abort CSI.\n\t\t\t}\n\n\t\t\t// We just entered a substring/command sequence.\n\t\tcase ansiSubstring:\n\t\t\tif r == 27 { // Most likely the end of the substring.\n\t\t\t\ta.state = ansiEscape\n\t\t\t} // Ignore all other characters.\n\n\t\t\t// \"ansiText\" and all others.\n\t\tdefault:\n\t\t\tif r == 27 {\n\t\t\t\t// This is the start of an escape sequence.\n\t\t\t\ta.state = ansiEscape\n\t\t\t} else {\n\t\t\t\t// Just a regular rune. Send to buffer.\n\t\t\t\tif _, err := a.buffer.WriteRune(r); err != nil {\n\t\t\t\t\treturn 0, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write buffer to target writer.\n\tn, err := a.buffer.WriteTo(a.Writer)\n\tif err != nil {\n\t\treturn int(n), err\n\t}\n\treturn len(text), nil\n}\n\n// TranslateANSI replaces ANSI escape sequences found in the provided string\n// with tview's style tags and returns the resulting string.\nfunc TranslateANSI(text string) string {\n\tvar buffer bytes.Buffer\n\twriter := ANSIWriter(&buffer)\n\twriter.Write([]byte(text))\n\treturn buffer.String()\n}\n"
        },
        {
          "name": "application.go",
          "type": "blob",
          "size": 23.85546875,
          "content": "package tview\n\nimport (\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\nconst (\n\t// The size of the event/update/redraw channels.\n\tqueueSize = 100\n\n\t// The minimum time between two consecutive redraws.\n\tredrawPause = 50 * time.Millisecond\n)\n\n// DoubleClickInterval specifies the maximum time between clicks to register a\n// double click rather than click.\nvar DoubleClickInterval = 500 * time.Millisecond\n\n// MouseAction indicates one of the actions the mouse is logically doing.\ntype MouseAction int16\n\n// Available mouse actions.\nconst (\n\tMouseMove MouseAction = iota\n\tMouseLeftDown\n\tMouseLeftUp\n\tMouseLeftClick\n\tMouseLeftDoubleClick\n\tMouseMiddleDown\n\tMouseMiddleUp\n\tMouseMiddleClick\n\tMouseMiddleDoubleClick\n\tMouseRightDown\n\tMouseRightUp\n\tMouseRightClick\n\tMouseRightDoubleClick\n\tMouseScrollUp\n\tMouseScrollDown\n\tMouseScrollLeft\n\tMouseScrollRight\n\n\t// The following special value will not be provided as a mouse action but\n\t// indicate that an overridden mouse event was consumed. See\n\t// [Box.SetMouseCapture] for details.\n\tMouseConsumed\n)\n\n// queuedUpdate represented the execution of f queued by\n// Application.QueueUpdate(). If \"done\" is not nil, it receives exactly one\n// element after f has executed.\ntype queuedUpdate struct {\n\tf    func()\n\tdone chan struct{}\n}\n\n// Application represents the top node of an application.\n//\n// It is not strictly required to use this class as none of the other classes\n// depend on it. However, it provides useful tools to set up an application and\n// plays nicely with all widgets.\n//\n// The following command displays a primitive p on the screen until Ctrl-C is\n// pressed:\n//\n//\tif err := tview.NewApplication().SetRoot(p, true).Run(); err != nil {\n//\t    panic(err)\n//\t}\ntype Application struct {\n\tsync.RWMutex\n\n\t// The application's screen. Apart from Run(), this variable should never be\n\t// set directly. Always use the screenReplacement channel after calling\n\t// Fini(), to set a new screen (or nil to stop the application).\n\tscreen tcell.Screen\n\n\t// The primitive which currently has the keyboard focus.\n\tfocus Primitive\n\n\t// The root primitive to be seen on the screen.\n\troot Primitive\n\n\t// Whether or not the application resizes the root primitive.\n\trootFullscreen bool\n\n\t// Set to true if mouse events are enabled.\n\tenableMouse bool\n\n\t// Set to true if paste events are enabled.\n\tenablePaste bool\n\n\t// An optional capture function which receives a key event and returns the\n\t// event to be forwarded to the default input handler (nil if nothing should\n\t// be forwarded).\n\tinputCapture func(event *tcell.EventKey) *tcell.EventKey\n\n\t// An optional callback function which is invoked just before the root\n\t// primitive is drawn.\n\tbeforeDraw func(screen tcell.Screen) bool\n\n\t// An optional callback function which is invoked after the root primitive\n\t// was drawn.\n\tafterDraw func(screen tcell.Screen)\n\n\t// Used to send screen events from separate goroutine to main event loop\n\tevents chan tcell.Event\n\n\t// Functions queued from goroutines, used to serialize updates to primitives.\n\tupdates chan queuedUpdate\n\n\t// An object that the screen variable will be set to after Fini() was called.\n\t// Use this channel to set a new screen object for the application\n\t// (screen.Init() and draw() will be called implicitly). A value of nil will\n\t// stop the application.\n\tscreenReplacement chan tcell.Screen\n\n\t// An optional capture function which receives a mouse event and returns the\n\t// event to be forwarded to the default mouse handler (nil if nothing should\n\t// be forwarded).\n\tmouseCapture func(event *tcell.EventMouse, action MouseAction) (*tcell.EventMouse, MouseAction)\n\n\tmouseCapturingPrimitive Primitive        // A Primitive returned by a MouseHandler which will capture future mouse events.\n\tlastMouseX, lastMouseY  int              // The last position of the mouse.\n\tmouseDownX, mouseDownY  int              // The position of the mouse when its button was last pressed.\n\tlastMouseClick          time.Time        // The time when a mouse button was last clicked.\n\tlastMouseButtons        tcell.ButtonMask // The last mouse button state.\n}\n\n// NewApplication creates and returns a new application.\nfunc NewApplication() *Application {\n\treturn &Application{\n\t\tevents:            make(chan tcell.Event, queueSize),\n\t\tupdates:           make(chan queuedUpdate, queueSize),\n\t\tscreenReplacement: make(chan tcell.Screen, 1),\n\t}\n}\n\n// SetInputCapture sets a function which captures all key events before they are\n// forwarded to the key event handler of the primitive which currently has\n// focus. This function can then choose to forward that key event (or a\n// different one) by returning it or stop the key event processing by returning\n// nil.\n//\n// The only default global key event is Ctrl-C which stops the application. It\n// requires special handling:\n//\n//   - If you do not wish to change the default behavior, return the original\n//     event object passed to your input capture function.\n//   - If you wish to block Ctrl-C from any functionality, return nil.\n//   - If you do not wish Ctrl-C to stop the application but still want to\n//     forward the Ctrl-C event to primitives down the hierarchy, return a new\n//     key event with the same key and modifiers, e.g.\n//     tcell.NewEventKey(tcell.KeyCtrlC, 0, tcell.ModNone).\n//\n// Pasted key events are not forwarded to the input capture function if pasting\n// is enabled (see [Application.EnablePaste]).\nfunc (a *Application) SetInputCapture(capture func(event *tcell.EventKey) *tcell.EventKey) *Application {\n\ta.inputCapture = capture\n\treturn a\n}\n\n// GetInputCapture returns the function installed with SetInputCapture() or nil\n// if no such function has been installed.\nfunc (a *Application) GetInputCapture() func(event *tcell.EventKey) *tcell.EventKey {\n\treturn a.inputCapture\n}\n\n// SetMouseCapture sets a function which captures mouse events (consisting of\n// the original tcell mouse event and the semantic mouse action) before they are\n// forwarded to the appropriate mouse event handler. This function can then\n// choose to forward that event (or a different one) by returning it or stop\n// the event processing by returning a nil mouse event. In such a case, the\n// event is considered consumed and the screen will be redrawn.\nfunc (a *Application) SetMouseCapture(capture func(event *tcell.EventMouse, action MouseAction) (*tcell.EventMouse, MouseAction)) *Application {\n\ta.mouseCapture = capture\n\treturn a\n}\n\n// GetMouseCapture returns the function installed with SetMouseCapture() or nil\n// if no such function has been installed.\nfunc (a *Application) GetMouseCapture() func(event *tcell.EventMouse, action MouseAction) (*tcell.EventMouse, MouseAction) {\n\treturn a.mouseCapture\n}\n\n// SetScreen allows you to provide your own tcell.Screen object. For most\n// applications, this is not needed and you should be familiar with\n// tcell.Screen when using this function.\n//\n// This function is typically called before the first call to Run(). Init() need\n// not be called on the screen.\nfunc (a *Application) SetScreen(screen tcell.Screen) *Application {\n\tif screen == nil {\n\t\treturn a // Invalid input. Do nothing.\n\t}\n\n\ta.Lock()\n\tif a.screen == nil {\n\t\t// Run() has not been called yet.\n\t\ta.screen = screen\n\t\ta.Unlock()\n\t\tscreen.Init()\n\t\treturn a\n\t}\n\n\t// Run() is already in progress. Exchange screen.\n\toldScreen := a.screen\n\ta.Unlock()\n\toldScreen.Fini()\n\ta.screenReplacement <- screen\n\n\treturn a\n}\n\n// EnableMouse enables mouse events or disables them (if \"false\" is provided).\nfunc (a *Application) EnableMouse(enable bool) *Application {\n\ta.Lock()\n\tdefer a.Unlock()\n\tif enable != a.enableMouse && a.screen != nil {\n\t\tif enable {\n\t\t\ta.screen.EnableMouse()\n\t\t} else {\n\t\t\ta.screen.DisableMouse()\n\t\t}\n\t}\n\ta.enableMouse = enable\n\treturn a\n}\n\n// EnablePaste enables the capturing of paste events or disables them (if\n// \"false\" is provided). This must be supported by the terminal.\n//\n// Widgets won't interpret paste events for navigation or selection purposes.\n// Paste events are typically only used to insert a block of text into an\n// [InputField] or a [TextArea].\nfunc (a *Application) EnablePaste(enable bool) *Application {\n\ta.Lock()\n\tdefer a.Unlock()\n\tif enable != a.enablePaste && a.screen != nil {\n\t\tif enable {\n\t\t\ta.screen.EnablePaste()\n\t\t} else {\n\t\t\ta.screen.DisablePaste()\n\t\t}\n\t}\n\ta.enablePaste = enable\n\treturn a\n}\n\n// Run starts the application and thus the event loop. This function returns\n// when [Application.Stop] was called.\n//\n// Note that while an application is running, it fully claims stdin, stdout, and\n// stderr. If you use these standard streams, they may not work as expected.\n// Consider stopping the application first or suspending it (using\n// [Application.Suspend]) if you have to interact with the standard streams, for\n// example when needing to print a call stack during a panic.\nfunc (a *Application) Run() error {\n\tvar (\n\t\terr, appErr error\n\t\tlastRedraw  time.Time   // The time the screen was last redrawn.\n\t\tredrawTimer *time.Timer // A timer to schedule the next redraw.\n\t)\n\ta.Lock()\n\n\t// Make a screen if there is none yet.\n\tif a.screen == nil {\n\t\ta.screen, err = tcell.NewScreen()\n\t\tif err != nil {\n\t\t\ta.Unlock()\n\t\t\treturn err\n\t\t}\n\t\tif err = a.screen.Init(); err != nil {\n\t\t\ta.Unlock()\n\t\t\treturn err\n\t\t}\n\t\tif a.enableMouse {\n\t\t\ta.screen.EnableMouse()\n\t\t} else {\n\t\t\ta.screen.DisableMouse()\n\t\t}\n\t\tif a.enablePaste {\n\t\t\ta.screen.EnablePaste()\n\t\t} else {\n\t\t\ta.screen.DisablePaste()\n\t\t}\n\t}\n\n\t// We catch panics to clean up because they mess up the terminal.\n\tdefer func() {\n\t\tif p := recover(); p != nil {\n\t\t\tif a.screen != nil {\n\t\t\t\ta.screen.Fini()\n\t\t\t}\n\t\t\tpanic(p)\n\t\t}\n\t}()\n\n\t// Draw the screen for the first time.\n\ta.Unlock()\n\ta.draw()\n\n\t// Separate loop to wait for screen events.\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tfor {\n\t\t\ta.RLock()\n\t\t\tscreen := a.screen\n\t\t\ta.RUnlock()\n\t\t\tif screen == nil {\n\t\t\t\t// We have no screen. Let's stop.\n\t\t\t\ta.QueueEvent(nil)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Wait for next event and queue it.\n\t\t\tevent := screen.PollEvent()\n\t\t\tif event != nil {\n\t\t\t\t// Regular event. Queue.\n\t\t\t\ta.QueueEvent(event)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// A screen was finalized (event is nil). Wait for a new screen.\n\t\t\tscreen = <-a.screenReplacement\n\t\t\tif screen == nil {\n\t\t\t\t// No new screen. We're done.\n\t\t\t\ta.QueueEvent(nil) // Stop the event loop.\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// We have a new screen. Keep going.\n\t\t\ta.Lock()\n\t\t\ta.screen = screen\n\t\t\tenableMouse := a.enableMouse\n\t\t\tenablePaste := a.enablePaste\n\t\t\ta.Unlock()\n\n\t\t\t// Initialize and draw this screen.\n\t\t\tif err := screen.Init(); err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif enableMouse {\n\t\t\t\tscreen.EnableMouse()\n\t\t\t} else {\n\t\t\t\tscreen.DisableMouse()\n\t\t\t}\n\t\t\tif enablePaste {\n\t\t\t\tscreen.EnablePaste()\n\t\t\t} else {\n\t\t\t\tscreen.DisablePaste()\n\t\t\t}\n\t\t\ta.draw()\n\t\t}\n\t}()\n\n\t// Start event loop.\n\tvar (\n\t\tpasteBuffer strings.Builder\n\t\tpasting     bool // Set to true while we receive paste key events.\n\t)\nEventLoop:\n\tfor {\n\t\tselect {\n\t\t// If we received an event, handle it.\n\t\tcase event := <-a.events:\n\t\t\tif event == nil {\n\t\t\t\tbreak EventLoop\n\t\t\t}\n\n\t\t\tswitch event := event.(type) {\n\t\t\tcase *tcell.EventKey:\n\t\t\t\t// If we are pasting, collect runes, nothing else.\n\t\t\t\tif pasting {\n\t\t\t\t\tswitch event.Key() {\n\t\t\t\t\tcase tcell.KeyRune:\n\t\t\t\t\t\tpasteBuffer.WriteRune(event.Rune())\n\t\t\t\t\tcase tcell.KeyEnter:\n\t\t\t\t\t\tpasteBuffer.WriteRune('\\n')\n\t\t\t\t\tcase tcell.KeyTab:\n\t\t\t\t\t\tpasteBuffer.WriteRune('\\t')\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\ta.RLock()\n\t\t\t\troot := a.root\n\t\t\t\tinputCapture := a.inputCapture\n\t\t\t\ta.RUnlock()\n\n\t\t\t\t// Intercept keys.\n\t\t\t\tvar draw bool\n\t\t\t\toriginalEvent := event\n\t\t\t\tif inputCapture != nil {\n\t\t\t\t\tevent = inputCapture(event)\n\t\t\t\t\tif event == nil {\n\t\t\t\t\t\ta.draw()\n\t\t\t\t\t\tbreak // Don't forward event.\n\t\t\t\t\t}\n\t\t\t\t\tdraw = true\n\t\t\t\t}\n\n\t\t\t\t// Ctrl-C closes the application.\n\t\t\t\tif event == originalEvent && event.Key() == tcell.KeyCtrlC {\n\t\t\t\t\ta.Stop()\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\t// Pass other key events to the root primitive.\n\t\t\t\tif root != nil && root.HasFocus() {\n\t\t\t\t\tif handler := root.InputHandler(); handler != nil {\n\t\t\t\t\t\thandler(event, func(p Primitive) {\n\t\t\t\t\t\t\ta.SetFocus(p)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tdraw = true\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Redraw.\n\t\t\t\tif draw {\n\t\t\t\t\ta.draw()\n\t\t\t\t}\n\t\t\tcase *tcell.EventPaste:\n\t\t\t\tif !a.enablePaste {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif event.Start() {\n\t\t\t\t\tpasting = true\n\t\t\t\t\tpasteBuffer.Reset()\n\t\t\t\t} else if event.End() {\n\t\t\t\t\tpasting = false\n\t\t\t\t\ta.RLock()\n\t\t\t\t\troot := a.root\n\t\t\t\t\ta.RUnlock()\n\t\t\t\t\tif root != nil && root.HasFocus() && pasteBuffer.Len() > 0 {\n\t\t\t\t\t\t// Pass paste event to the root primitive.\n\t\t\t\t\t\tif handler := root.PasteHandler(); handler != nil {\n\t\t\t\t\t\t\thandler(pasteBuffer.String(), func(p Primitive) {\n\t\t\t\t\t\t\t\ta.SetFocus(p)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Redraw.\n\t\t\t\t\t\ta.draw()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase *tcell.EventResize:\n\t\t\t\tif time.Since(lastRedraw) < redrawPause {\n\t\t\t\t\tif redrawTimer != nil {\n\t\t\t\t\t\tredrawTimer.Stop()\n\t\t\t\t\t}\n\t\t\t\t\tredrawTimer = time.AfterFunc(redrawPause, func() {\n\t\t\t\t\t\ta.events <- event\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\ta.RLock()\n\t\t\t\tscreen := a.screen\n\t\t\t\ta.RUnlock()\n\t\t\t\tif screen == nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tlastRedraw = time.Now()\n\t\t\t\tscreen.Clear()\n\t\t\t\ta.draw()\n\t\t\tcase *tcell.EventMouse:\n\t\t\t\tconsumed, isMouseDownAction := a.fireMouseActions(event)\n\t\t\t\tif consumed {\n\t\t\t\t\ta.draw()\n\t\t\t\t}\n\t\t\t\ta.lastMouseButtons = event.Buttons()\n\t\t\t\tif isMouseDownAction {\n\t\t\t\t\ta.mouseDownX, a.mouseDownY = event.Position()\n\t\t\t\t}\n\t\t\tcase *tcell.EventError:\n\t\t\t\tappErr = event\n\t\t\t\ta.Stop()\n\t\t\t}\n\n\t\t// If we have updates, now is the time to execute them.\n\t\tcase update := <-a.updates:\n\t\t\tupdate.f()\n\t\t\tif update.done != nil {\n\t\t\t\tupdate.done <- struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Wait for the event loop to finish.\n\twg.Wait()\n\ta.screen = nil\n\n\treturn appErr\n}\n\n// fireMouseActions analyzes the provided mouse event, derives mouse actions\n// from it and then forwards them to the corresponding primitives.\nfunc (a *Application) fireMouseActions(event *tcell.EventMouse) (consumed, isMouseDownAction bool) {\n\t// We want to relay follow-up events to the same target primitive.\n\tvar targetPrimitive Primitive\n\n\t// Helper function to fire a mouse action.\n\tfire := func(action MouseAction) {\n\t\tswitch action {\n\t\tcase MouseLeftDown, MouseMiddleDown, MouseRightDown:\n\t\t\tisMouseDownAction = true\n\t\t}\n\n\t\t// Intercept event.\n\t\tif a.mouseCapture != nil {\n\t\t\tevent, action = a.mouseCapture(event, action)\n\t\t\tif event == nil {\n\t\t\t\tconsumed = true\n\t\t\t\treturn // Don't forward event.\n\t\t\t}\n\t\t}\n\n\t\t// Determine the target primitive.\n\t\tvar primitive, capturingPrimitive Primitive\n\t\tif a.mouseCapturingPrimitive != nil {\n\t\t\tprimitive = a.mouseCapturingPrimitive\n\t\t\ttargetPrimitive = a.mouseCapturingPrimitive\n\t\t} else if targetPrimitive != nil {\n\t\t\tprimitive = targetPrimitive\n\t\t} else {\n\t\t\tprimitive = a.root\n\t\t}\n\t\tif primitive != nil {\n\t\t\tif handler := primitive.MouseHandler(); handler != nil {\n\t\t\t\tvar wasConsumed bool\n\t\t\t\twasConsumed, capturingPrimitive = handler(action, event, func(p Primitive) {\n\t\t\t\t\ta.SetFocus(p)\n\t\t\t\t})\n\t\t\t\tif wasConsumed {\n\t\t\t\t\tconsumed = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ta.mouseCapturingPrimitive = capturingPrimitive\n\t}\n\n\tx, y := event.Position()\n\tbuttons := event.Buttons()\n\tclickMoved := x != a.mouseDownX || y != a.mouseDownY\n\tbuttonChanges := buttons ^ a.lastMouseButtons\n\n\tif x != a.lastMouseX || y != a.lastMouseY {\n\t\tfire(MouseMove)\n\t\ta.lastMouseX = x\n\t\ta.lastMouseY = y\n\t}\n\n\tfor _, buttonEvent := range []struct {\n\t\tbutton                  tcell.ButtonMask\n\t\tdown, up, click, dclick MouseAction\n\t}{\n\t\t{tcell.ButtonPrimary, MouseLeftDown, MouseLeftUp, MouseLeftClick, MouseLeftDoubleClick},\n\t\t{tcell.ButtonMiddle, MouseMiddleDown, MouseMiddleUp, MouseMiddleClick, MouseMiddleDoubleClick},\n\t\t{tcell.ButtonSecondary, MouseRightDown, MouseRightUp, MouseRightClick, MouseRightDoubleClick},\n\t} {\n\t\tif buttonChanges&buttonEvent.button != 0 {\n\t\t\tif buttons&buttonEvent.button != 0 {\n\t\t\t\tfire(buttonEvent.down)\n\t\t\t} else {\n\t\t\t\tfire(buttonEvent.up) // A user override might set event to nil.\n\t\t\t\tif !clickMoved && event != nil {\n\t\t\t\t\tif a.lastMouseClick.Add(DoubleClickInterval).Before(time.Now()) {\n\t\t\t\t\t\tfire(buttonEvent.click)\n\t\t\t\t\t\ta.lastMouseClick = time.Now()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire(buttonEvent.dclick)\n\t\t\t\t\t\ta.lastMouseClick = time.Time{} // reset\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, wheelEvent := range []struct {\n\t\tbutton tcell.ButtonMask\n\t\taction MouseAction\n\t}{\n\t\t{tcell.WheelUp, MouseScrollUp},\n\t\t{tcell.WheelDown, MouseScrollDown},\n\t\t{tcell.WheelLeft, MouseScrollLeft},\n\t\t{tcell.WheelRight, MouseScrollRight}} {\n\t\tif buttons&wheelEvent.button != 0 {\n\t\t\tfire(wheelEvent.action)\n\t\t}\n\t}\n\n\treturn consumed, isMouseDownAction\n}\n\n// Stop stops the application, causing Run() to return.\nfunc (a *Application) Stop() {\n\ta.Lock()\n\tdefer a.Unlock()\n\tscreen := a.screen\n\tif screen == nil {\n\t\treturn\n\t}\n\ta.screen = nil\n\tscreen.Fini()\n\ta.screenReplacement <- nil\n}\n\n// Suspend temporarily suspends the application by exiting terminal UI mode and\n// invoking the provided function \"f\". When \"f\" returns, terminal UI mode is\n// entered again and the application resumes.\n//\n// A return value of true indicates that the application was suspended and \"f\"\n// was called. If false is returned, the application was already suspended,\n// terminal UI mode was not exited, and \"f\" was not called.\nfunc (a *Application) Suspend(f func()) bool {\n\ta.RLock()\n\tscreen := a.screen\n\ta.RUnlock()\n\tif screen == nil {\n\t\treturn false // Screen has not yet been initialized.\n\t}\n\n\t// Enter suspended mode.\n\tif err := screen.Suspend(); err != nil {\n\t\treturn false // Suspension failed.\n\t}\n\n\t// Wait for \"f\" to return.\n\tf()\n\n\t// If the screen object has changed in the meantime, we need to do more.\n\ta.RLock()\n\tdefer a.RUnlock()\n\tif a.screen != screen {\n\t\t// Calling Stop() while in suspend mode currently still leads to a\n\t\t// panic, see https://github.com/gdamore/tcell/issues/440.\n\t\tscreen.Fini()\n\t\tif a.screen == nil {\n\t\t\treturn true // If stop was called (a.screen is nil), we're done already.\n\t\t}\n\t} else {\n\t\t// It hasn't changed. Resume.\n\t\tscreen.Resume() // Not much we can do in case of an error.\n\t}\n\n\t// Continue application loop.\n\treturn true\n}\n\n// Draw refreshes the screen (during the next update cycle). It calls the Draw()\n// function of the application's root primitive and then syncs the screen\n// buffer. It is almost never necessary to call this function. It can actually\n// deadlock your application if you call it from the main thread (e.g. in a\n// callback function of a widget). Please see\n// https://github.com/rivo/tview/wiki/Concurrency for details.\nfunc (a *Application) Draw() *Application {\n\ta.QueueUpdate(func() {\n\t\ta.draw()\n\t})\n\treturn a\n}\n\n// ForceDraw refreshes the screen immediately. Use this function with caution as\n// it may lead to race conditions with updates to primitives in other\n// goroutines. It is always preferable to call [Application.Draw] instead.\n// Never call this function from a goroutine.\n//\n// It is safe to call this function during queued updates and direct event\n// handling.\nfunc (a *Application) ForceDraw() *Application {\n\treturn a.draw()\n}\n\n// draw actually does what Draw() promises to do.\nfunc (a *Application) draw() *Application {\n\ta.Lock()\n\tdefer a.Unlock()\n\n\tscreen := a.screen\n\troot := a.root\n\tfullscreen := a.rootFullscreen\n\tbefore := a.beforeDraw\n\tafter := a.afterDraw\n\n\t// Maybe we're not ready yet or not anymore.\n\tif screen == nil || root == nil {\n\t\treturn a\n\t}\n\n\t// Resize if requested.\n\tif fullscreen { // root is not nil here.\n\t\twidth, height := screen.Size()\n\t\troot.SetRect(0, 0, width, height)\n\t}\n\n\t// Clear screen to remove unwanted artifacts from the previous cycle.\n\tscreen.Clear()\n\n\t// Call before handler if there is one.\n\tif before != nil {\n\t\tif before(screen) {\n\t\t\tscreen.Show()\n\t\t\treturn a\n\t\t}\n\t}\n\n\t// Draw all primitives.\n\troot.Draw(screen)\n\n\t// Call after handler if there is one.\n\tif after != nil {\n\t\tafter(screen)\n\t}\n\n\t// Sync screen.\n\tscreen.Show()\n\n\treturn a\n}\n\n// Sync forces a full re-sync of the screen buffer with the actual screen during\n// the next event cycle. This is useful for when the terminal screen is\n// corrupted so you may want to offer your users a keyboard shortcut to refresh\n// the screen.\nfunc (a *Application) Sync() *Application {\n\ta.updates <- queuedUpdate{f: func() {\n\t\ta.RLock()\n\t\tscreen := a.screen\n\t\ta.RUnlock()\n\t\tif screen == nil {\n\t\t\treturn\n\t\t}\n\t\tscreen.Sync()\n\t}}\n\treturn a\n}\n\n// SetBeforeDrawFunc installs a callback function which is invoked just before\n// the root primitive is drawn during screen updates. If the function returns\n// true, drawing will not continue, i.e. the root primitive will not be drawn\n// (and an after-draw-handler will not be called).\n//\n// Note that the screen is not cleared by the application. To clear the screen,\n// you may call screen.Clear().\n//\n// Provide nil to uninstall the callback function.\nfunc (a *Application) SetBeforeDrawFunc(handler func(screen tcell.Screen) bool) *Application {\n\ta.beforeDraw = handler\n\treturn a\n}\n\n// GetBeforeDrawFunc returns the callback function installed with\n// SetBeforeDrawFunc() or nil if none has been installed.\nfunc (a *Application) GetBeforeDrawFunc() func(screen tcell.Screen) bool {\n\treturn a.beforeDraw\n}\n\n// SetAfterDrawFunc installs a callback function which is invoked after the root\n// primitive was drawn during screen updates.\n//\n// Provide nil to uninstall the callback function.\nfunc (a *Application) SetAfterDrawFunc(handler func(screen tcell.Screen)) *Application {\n\ta.afterDraw = handler\n\treturn a\n}\n\n// GetAfterDrawFunc returns the callback function installed with\n// SetAfterDrawFunc() or nil if none has been installed.\nfunc (a *Application) GetAfterDrawFunc() func(screen tcell.Screen) {\n\treturn a.afterDraw\n}\n\n// SetRoot sets the root primitive for this application. If \"fullscreen\" is set\n// to true, the root primitive's position will be changed to fill the screen.\n//\n// This function must be called at least once or nothing will be displayed when\n// the application starts.\n//\n// It also calls SetFocus() on the primitive.\nfunc (a *Application) SetRoot(root Primitive, fullscreen bool) *Application {\n\ta.Lock()\n\ta.root = root\n\ta.rootFullscreen = fullscreen\n\tif a.screen != nil {\n\t\ta.screen.Clear()\n\t}\n\ta.Unlock()\n\n\ta.SetFocus(root)\n\n\treturn a\n}\n\n// ResizeToFullScreen resizes the given primitive such that it fills the entire\n// screen.\nfunc (a *Application) ResizeToFullScreen(p Primitive) *Application {\n\ta.RLock()\n\twidth, height := a.screen.Size()\n\ta.RUnlock()\n\tp.SetRect(0, 0, width, height)\n\treturn a\n}\n\n// SetFocus sets the focus to a new primitive. All key events will be directed\n// down the hierarchy (starting at the root) until a primitive handles them,\n// which per default goes towards the focused primitive.\n//\n// Blur() will be called on the previously focused primitive. Focus() will be\n// called on the new primitive.\nfunc (a *Application) SetFocus(p Primitive) *Application {\n\ta.Lock()\n\tif a.focus != nil {\n\t\ta.focus.Blur()\n\t}\n\ta.focus = p\n\tif a.screen != nil {\n\t\ta.screen.HideCursor()\n\t}\n\ta.Unlock()\n\tif p != nil {\n\t\tp.Focus(func(p Primitive) {\n\t\t\ta.SetFocus(p)\n\t\t})\n\t}\n\n\treturn a\n}\n\n// GetFocus returns the primitive which has the current focus. If none has it,\n// nil is returned.\nfunc (a *Application) GetFocus() Primitive {\n\ta.RLock()\n\tdefer a.RUnlock()\n\treturn a.focus\n}\n\n// QueueUpdate is used to synchronize access to primitives from non-main\n// goroutines. The provided function will be executed as part of the event loop\n// and thus will not cause race conditions with other such update functions or\n// the Draw() function.\n//\n// Note that Draw() is not implicitly called after the execution of f as that\n// may not be desirable. You can call Draw() from f if the screen should be\n// refreshed after each update. Alternatively, use QueueUpdateDraw() to follow\n// up with an immediate refresh of the screen.\n//\n// This function returns after f has executed.\nfunc (a *Application) QueueUpdate(f func()) *Application {\n\tch := make(chan struct{})\n\ta.updates <- queuedUpdate{f: f, done: ch}\n\t<-ch\n\treturn a\n}\n\n// QueueUpdateDraw works like QueueUpdate() except it refreshes the screen\n// immediately after executing f.\nfunc (a *Application) QueueUpdateDraw(f func()) *Application {\n\ta.QueueUpdate(func() {\n\t\tf()\n\t\ta.draw()\n\t})\n\treturn a\n}\n\n// QueueEvent sends an event to the Application event loop.\n//\n// It is not recommended for event to be nil.\nfunc (a *Application) QueueEvent(event tcell.Event) *Application {\n\ta.events <- event\n\treturn a\n}\n"
        },
        {
          "name": "borders.go",
          "type": "blob",
          "size": 1.23046875,
          "content": "package tview\n\n// Borders defines various borders used when primitives are drawn.\n// These may be changed to accommodate a different look and feel.\nvar Borders = struct {\n\tHorizontal  rune\n\tVertical    rune\n\tTopLeft     rune\n\tTopRight    rune\n\tBottomLeft  rune\n\tBottomRight rune\n\n\tLeftT   rune\n\tRightT  rune\n\tTopT    rune\n\tBottomT rune\n\tCross   rune\n\n\tHorizontalFocus  rune\n\tVerticalFocus    rune\n\tTopLeftFocus     rune\n\tTopRightFocus    rune\n\tBottomLeftFocus  rune\n\tBottomRightFocus rune\n}{\n\tHorizontal:  BoxDrawingsLightHorizontal,\n\tVertical:    BoxDrawingsLightVertical,\n\tTopLeft:     BoxDrawingsLightDownAndRight,\n\tTopRight:    BoxDrawingsLightDownAndLeft,\n\tBottomLeft:  BoxDrawingsLightUpAndRight,\n\tBottomRight: BoxDrawingsLightUpAndLeft,\n\n\tLeftT:   BoxDrawingsLightVerticalAndRight,\n\tRightT:  BoxDrawingsLightVerticalAndLeft,\n\tTopT:    BoxDrawingsLightDownAndHorizontal,\n\tBottomT: BoxDrawingsLightUpAndHorizontal,\n\tCross:   BoxDrawingsLightVerticalAndHorizontal,\n\n\tHorizontalFocus:  BoxDrawingsDoubleHorizontal,\n\tVerticalFocus:    BoxDrawingsDoubleVertical,\n\tTopLeftFocus:     BoxDrawingsDoubleDownAndRight,\n\tTopRightFocus:    BoxDrawingsDoubleDownAndLeft,\n\tBottomLeftFocus:  BoxDrawingsDoubleUpAndRight,\n\tBottomRightFocus: BoxDrawingsDoubleUpAndLeft,\n}\n"
        },
        {
          "name": "box.go",
          "type": "blob",
          "size": 16.0380859375,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Box implements the Primitive interface with an empty background and optional\n// elements such as a border and a title. Box itself does not hold any content\n// but serves as the superclass of all other primitives. Subclasses add their\n// own content, typically (but not necessarily) keeping their content within the\n// box's rectangle.\n//\n// Box provides a number of utility functions available to all primitives.\n//\n// See https://github.com/rivo/tview/wiki/Box for an example.\ntype Box struct {\n\t// The position of the rect.\n\tx, y, width, height int\n\n\t// The inner rect reserved for the box's content.\n\tinnerX, innerY, innerWidth, innerHeight int\n\n\t// Border padding.\n\tpaddingTop, paddingBottom, paddingLeft, paddingRight int\n\n\t// The box's background color.\n\tbackgroundColor tcell.Color\n\n\t// If set to true, the background of this box is not cleared while drawing.\n\tdontClear bool\n\n\t// Whether or not a border is drawn, reducing the box's space for content by\n\t// two in width and height.\n\tborder bool\n\n\t// The border style.\n\tborderStyle tcell.Style\n\n\t// The title. Only visible if there is a border, too.\n\ttitle string\n\n\t// The color of the title.\n\ttitleColor tcell.Color\n\n\t// The alignment of the title.\n\ttitleAlign int\n\n\t// Whether or not this box has focus. This is typically ignored for\n\t// container primitives (e.g. Flex, Grid, Pages), as they will delegate\n\t// focus to their children.\n\thasFocus bool\n\n\t// Optional callback functions invoked when the primitive receives or loses\n\t// focus.\n\tfocus, blur func()\n\n\t// An optional capture function which receives a key event and returns the\n\t// event to be forwarded to the primitive's default input handler (nil if\n\t// nothing should be forwarded).\n\tinputCapture func(event *tcell.EventKey) *tcell.EventKey\n\n\t// An optional function which is called before the box is drawn.\n\tdraw func(screen tcell.Screen, x, y, width, height int) (int, int, int, int)\n\n\t// An optional capture function which receives a mouse event and returns the\n\t// event to be forwarded to the primitive's default mouse event handler (at\n\t// least one nil if nothing should be forwarded).\n\tmouseCapture func(action MouseAction, event *tcell.EventMouse) (MouseAction, *tcell.EventMouse)\n}\n\n// NewBox returns a Box without a border.\nfunc NewBox() *Box {\n\tb := &Box{\n\t\twidth:           15,\n\t\theight:          10,\n\t\tinnerX:          -1, // Mark as uninitialized.\n\t\tbackgroundColor: Styles.PrimitiveBackgroundColor,\n\t\tborderStyle:     tcell.StyleDefault.Foreground(Styles.BorderColor).Background(Styles.PrimitiveBackgroundColor),\n\t\ttitleColor:      Styles.TitleColor,\n\t\ttitleAlign:      AlignCenter,\n\t}\n\treturn b\n}\n\n// SetBorderPadding sets the size of the borders around the box content.\nfunc (b *Box) SetBorderPadding(top, bottom, left, right int) *Box {\n\tb.paddingTop, b.paddingBottom, b.paddingLeft, b.paddingRight = top, bottom, left, right\n\treturn b\n}\n\n// GetRect returns the current position of the rectangle, x, y, width, and\n// height.\nfunc (b *Box) GetRect() (int, int, int, int) {\n\treturn b.x, b.y, b.width, b.height\n}\n\n// GetInnerRect returns the position of the inner rectangle (x, y, width,\n// height), without the border and without any padding. Width and height values\n// will clamp to 0 and thus never be negative.\nfunc (b *Box) GetInnerRect() (int, int, int, int) {\n\tif b.innerX >= 0 {\n\t\treturn b.innerX, b.innerY, b.innerWidth, b.innerHeight\n\t}\n\tx, y, width, height := b.GetRect()\n\tif b.border {\n\t\tx++\n\t\ty++\n\t\twidth -= 2\n\t\theight -= 2\n\t}\n\tx, y, width, height = x+b.paddingLeft,\n\t\ty+b.paddingTop,\n\t\twidth-b.paddingLeft-b.paddingRight,\n\t\theight-b.paddingTop-b.paddingBottom\n\tif width < 0 {\n\t\twidth = 0\n\t}\n\tif height < 0 {\n\t\theight = 0\n\t}\n\treturn x, y, width, height\n}\n\n// SetRect sets a new position of the primitive. Note that this has no effect\n// if this primitive is part of a layout (e.g. Flex, Grid) or if it was added\n// like this:\n//\n//\tapplication.SetRoot(p, true)\nfunc (b *Box) SetRect(x, y, width, height int) {\n\tb.x = x\n\tb.y = y\n\tb.width = width\n\tb.height = height\n\tb.innerX = -1 // Mark inner rect as uninitialized.\n}\n\n// SetDrawFunc sets a callback function which is invoked after the box primitive\n// has been drawn. This allows you to add a more individual style to the box\n// (and all primitives which extend it).\n//\n// The function is provided with the box's dimensions (set via SetRect()). It\n// must return the box's inner dimensions (x, y, width, height) which will be\n// returned by GetInnerRect(), used by descendent primitives to draw their own\n// content.\nfunc (b *Box) SetDrawFunc(handler func(screen tcell.Screen, x, y, width, height int) (int, int, int, int)) *Box {\n\tb.draw = handler\n\treturn b\n}\n\n// GetDrawFunc returns the callback function which was installed with\n// SetDrawFunc() or nil if no such function has been installed.\nfunc (b *Box) GetDrawFunc() func(screen tcell.Screen, x, y, width, height int) (int, int, int, int) {\n\treturn b.draw\n}\n\n// WrapInputHandler wraps an input handler (see [Box.InputHandler]) with the\n// functionality to capture input (see [Box.SetInputCapture]) before passing it\n// on to the provided (default) input handler.\n//\n// This is only meant to be used by subclassing primitives.\nfunc (b *Box) WrapInputHandler(inputHandler func(*tcell.EventKey, func(p Primitive))) func(*tcell.EventKey, func(p Primitive)) {\n\treturn func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif b.inputCapture != nil {\n\t\t\tevent = b.inputCapture(event)\n\t\t}\n\t\tif event != nil && inputHandler != nil {\n\t\t\tinputHandler(event, setFocus)\n\t\t}\n\t}\n}\n\n// InputHandler returns nil. Box has no default input handling.\nfunc (b *Box) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn b.WrapInputHandler(nil)\n}\n\n// WrapPasteHandler wraps a paste handler (see [Box.PasteHandler]).\nfunc (b *Box) WrapPasteHandler(pasteHandler func(string, func(p Primitive))) func(string, func(p Primitive)) {\n\treturn func(text string, setFocus func(p Primitive)) {\n\t\tif pasteHandler != nil {\n\t\t\tpasteHandler(text, setFocus)\n\t\t}\n\t}\n}\n\n// PasteHandler returns nil. Box has no default paste handling.\nfunc (b *Box) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn b.WrapPasteHandler(nil)\n}\n\n// SetInputCapture installs a function which captures key events before they are\n// forwarded to the primitive's default key event handler. This function can\n// then choose to forward that key event (or a different one) to the default\n// handler by returning it. If nil is returned, the default handler will not\n// be called.\n//\n// Providing a nil handler will remove a previously existing handler.\n//\n// This function can also be used on container primitives (like Flex, Grid, or\n// Form) as keyboard events will be handed down until they are handled.\n//\n// Pasted key events are not forwarded to the input capture function if pasting\n// is enabled (see [Application.EnablePaste]).\nfunc (b *Box) SetInputCapture(capture func(event *tcell.EventKey) *tcell.EventKey) *Box {\n\tb.inputCapture = capture\n\treturn b\n}\n\n// GetInputCapture returns the function installed with SetInputCapture() or nil\n// if no such function has been installed.\nfunc (b *Box) GetInputCapture() func(event *tcell.EventKey) *tcell.EventKey {\n\treturn b.inputCapture\n}\n\n// WrapMouseHandler wraps a mouse event handler (see [Box.MouseHandler]) with the\n// functionality to capture mouse events (see [Box.SetMouseCapture]) before passing\n// them on to the provided (default) event handler.\n//\n// This is only meant to be used by subclassing primitives.\nfunc (b *Box) WrapMouseHandler(mouseHandler func(MouseAction, *tcell.EventMouse, func(p Primitive)) (bool, Primitive)) func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif b.mouseCapture != nil {\n\t\t\taction, event = b.mouseCapture(action, event)\n\t\t}\n\t\tif event == nil {\n\t\t\tif action == MouseConsumed {\n\t\t\t\tconsumed = true\n\t\t\t}\n\t\t} else if mouseHandler != nil {\n\t\t\tconsumed, capture = mouseHandler(action, event, setFocus)\n\t\t}\n\t\treturn\n\t}\n}\n\n// MouseHandler returns nil. Box has no default mouse handling.\nfunc (b *Box) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn b.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif action == MouseLeftDown && b.InRect(event.Position()) {\n\t\t\tsetFocus(b)\n\t\t\tconsumed = true\n\t\t}\n\t\treturn\n\t})\n}\n\n// SetMouseCapture sets a function which captures mouse events (consisting of\n// the original tcell mouse event and the semantic mouse action) before they are\n// forwarded to the primitive's default mouse event handler. This function can\n// then choose to forward that event (or a different one) by returning it or\n// returning a nil mouse event, in which case the default handler will not be\n// called.\n//\n// When a nil event is returned, the returned mouse action value may be set to\n// [MouseConsumed] to indicate that the event was consumed and the screen should\n// be redrawn. Any other value will not cause a redraw.\n//\n// Providing a nil handler will remove a previously existing handler.\n//\n// Note that mouse events are ignored completely if the application has not been\n// enabled for mouse events (see [Application.EnableMouse]), which is the\n// default.\nfunc (b *Box) SetMouseCapture(capture func(action MouseAction, event *tcell.EventMouse) (MouseAction, *tcell.EventMouse)) *Box {\n\tb.mouseCapture = capture\n\treturn b\n}\n\n// InRect returns true if the given coordinate is within the bounds of the box's\n// rectangle.\nfunc (b *Box) InRect(x, y int) bool {\n\trectX, rectY, width, height := b.GetRect()\n\treturn x >= rectX && x < rectX+width && y >= rectY && y < rectY+height\n}\n\n// InInnerRect returns true if the given coordinate is within the bounds of the\n// box's inner rectangle (within the border and padding).\nfunc (b *Box) InInnerRect(x, y int) bool {\n\trectX, rectY, width, height := b.GetInnerRect()\n\treturn x >= rectX && x < rectX+width && y >= rectY && y < rectY+height\n}\n\n// GetMouseCapture returns the function installed with SetMouseCapture() or nil\n// if no such function has been installed.\nfunc (b *Box) GetMouseCapture() func(action MouseAction, event *tcell.EventMouse) (MouseAction, *tcell.EventMouse) {\n\treturn b.mouseCapture\n}\n\n// SetBackgroundColor sets the box's background color.\nfunc (b *Box) SetBackgroundColor(color tcell.Color) *Box {\n\tb.backgroundColor = color\n\tb.borderStyle = b.borderStyle.Background(color)\n\treturn b\n}\n\n// SetBorder sets the flag indicating whether or not the box should have a\n// border.\nfunc (b *Box) SetBorder(show bool) *Box {\n\tb.border = show\n\treturn b\n}\n\n// SetBorderStyle sets the box's border style.\nfunc (b *Box) SetBorderStyle(style tcell.Style) *Box {\n\tb.borderStyle = style\n\treturn b\n}\n\n// SetBorderColor sets the box's border color.\nfunc (b *Box) SetBorderColor(color tcell.Color) *Box {\n\tb.borderStyle = b.borderStyle.Foreground(color)\n\treturn b\n}\n\n// SetBorderAttributes sets the border's style attributes. You can combine\n// different attributes using bitmask operations:\n//\n//\tbox.SetBorderAttributes(tcell.AttrUnderline | tcell.AttrBold)\nfunc (b *Box) SetBorderAttributes(attr tcell.AttrMask) *Box {\n\tb.borderStyle = b.borderStyle.Attributes(attr)\n\treturn b\n}\n\n// GetBorderAttributes returns the border's style attributes.\nfunc (b *Box) GetBorderAttributes() tcell.AttrMask {\n\t_, _, attr := b.borderStyle.Decompose()\n\treturn attr\n}\n\n// GetBorderColor returns the box's border color.\nfunc (b *Box) GetBorderColor() tcell.Color {\n\tcolor, _, _ := b.borderStyle.Decompose()\n\treturn color\n}\n\n// GetBackgroundColor returns the box's background color.\nfunc (b *Box) GetBackgroundColor() tcell.Color {\n\treturn b.backgroundColor\n}\n\n// SetTitle sets the box's title.\nfunc (b *Box) SetTitle(title string) *Box {\n\tb.title = title\n\treturn b\n}\n\n// GetTitle returns the box's current title.\nfunc (b *Box) GetTitle() string {\n\treturn b.title\n}\n\n// SetTitleColor sets the box's title color.\nfunc (b *Box) SetTitleColor(color tcell.Color) *Box {\n\tb.titleColor = color\n\treturn b\n}\n\n// SetTitleAlign sets the alignment of the title, one of AlignLeft, AlignCenter,\n// or AlignRight.\nfunc (b *Box) SetTitleAlign(align int) *Box {\n\tb.titleAlign = align\n\treturn b\n}\n\n// Draw draws this primitive onto the screen.\nfunc (b *Box) Draw(screen tcell.Screen) {\n\tb.DrawForSubclass(screen, b)\n}\n\n// DrawForSubclass draws this box under the assumption that primitive p is a\n// subclass of this box. This is needed e.g. to draw proper box frames which\n// depend on the subclass's focus.\n//\n// Only call this function from your own custom primitives. It is not needed in\n// applications that have no custom primitives.\nfunc (b *Box) DrawForSubclass(screen tcell.Screen, p Primitive) {\n\t// Don't draw anything if there is no space.\n\tif b.width <= 0 || b.height <= 0 {\n\t\treturn\n\t}\n\n\t// Fill background.\n\tbackground := tcell.StyleDefault.Background(b.backgroundColor)\n\tif !b.dontClear {\n\t\tfor y := b.y; y < b.y+b.height; y++ {\n\t\t\tfor x := b.x; x < b.x+b.width; x++ {\n\t\t\t\tscreen.SetContent(x, y, ' ', nil, background)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Draw border.\n\tif b.border && b.width >= 2 && b.height >= 2 {\n\t\tvar vertical, horizontal, topLeft, topRight, bottomLeft, bottomRight rune\n\t\tif p.HasFocus() {\n\t\t\thorizontal = Borders.HorizontalFocus\n\t\t\tvertical = Borders.VerticalFocus\n\t\t\ttopLeft = Borders.TopLeftFocus\n\t\t\ttopRight = Borders.TopRightFocus\n\t\t\tbottomLeft = Borders.BottomLeftFocus\n\t\t\tbottomRight = Borders.BottomRightFocus\n\t\t} else {\n\t\t\thorizontal = Borders.Horizontal\n\t\t\tvertical = Borders.Vertical\n\t\t\ttopLeft = Borders.TopLeft\n\t\t\ttopRight = Borders.TopRight\n\t\t\tbottomLeft = Borders.BottomLeft\n\t\t\tbottomRight = Borders.BottomRight\n\t\t}\n\t\tfor x := b.x + 1; x < b.x+b.width-1; x++ {\n\t\t\tscreen.SetContent(x, b.y, horizontal, nil, b.borderStyle)\n\t\t\tscreen.SetContent(x, b.y+b.height-1, horizontal, nil, b.borderStyle)\n\t\t}\n\t\tfor y := b.y + 1; y < b.y+b.height-1; y++ {\n\t\t\tscreen.SetContent(b.x, y, vertical, nil, b.borderStyle)\n\t\t\tscreen.SetContent(b.x+b.width-1, y, vertical, nil, b.borderStyle)\n\t\t}\n\t\tscreen.SetContent(b.x, b.y, topLeft, nil, b.borderStyle)\n\t\tscreen.SetContent(b.x+b.width-1, b.y, topRight, nil, b.borderStyle)\n\t\tscreen.SetContent(b.x, b.y+b.height-1, bottomLeft, nil, b.borderStyle)\n\t\tscreen.SetContent(b.x+b.width-1, b.y+b.height-1, bottomRight, nil, b.borderStyle)\n\n\t\t// Draw title.\n\t\tif b.title != \"\" && b.width >= 4 {\n\t\t\tprinted, _ := Print(screen, b.title, b.x+1, b.y, b.width-2, b.titleAlign, b.titleColor)\n\t\t\tif len(b.title)-printed > 0 && printed > 0 {\n\t\t\t\txEllipsis := b.x + b.width - 2\n\t\t\t\tif b.titleAlign == AlignRight {\n\t\t\t\t\txEllipsis = b.x + 1\n\t\t\t\t}\n\t\t\t\t_, _, style, _ := screen.GetContent(xEllipsis, b.y)\n\t\t\t\tfg, _, _ := style.Decompose()\n\t\t\t\tPrint(screen, string(SemigraphicsHorizontalEllipsis), xEllipsis, b.y, 1, AlignLeft, fg)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Call custom draw function.\n\tif b.draw != nil {\n\t\tb.innerX, b.innerY, b.innerWidth, b.innerHeight = b.draw(screen, b.x, b.y, b.width, b.height)\n\t} else {\n\t\t// Remember the inner rect.\n\t\tb.innerX = -1\n\t\tb.innerX, b.innerY, b.innerWidth, b.innerHeight = b.GetInnerRect()\n\t}\n}\n\n// SetFocusFunc sets a callback function which is invoked when this primitive\n// receives focus. Container primitives such as [Flex] or [Grid] may not be\n// notified if one of their descendents receive focus directly.\n//\n// Set to nil to remove the callback function.\nfunc (b *Box) SetFocusFunc(callback func()) *Box {\n\tb.focus = callback\n\treturn b\n}\n\n// SetBlurFunc sets a callback function which is invoked when this primitive\n// loses focus. This does not apply to container primitives such as [Flex] or\n// [Grid].\n//\n// Set to nil to remove the callback function.\nfunc (b *Box) SetBlurFunc(callback func()) *Box {\n\tb.blur = callback\n\treturn b\n}\n\n// Focus is called when this primitive receives focus.\nfunc (b *Box) Focus(delegate func(p Primitive)) {\n\tb.hasFocus = true\n\tif b.focus != nil {\n\t\tb.focus()\n\t}\n}\n\n// Blur is called when this primitive loses focus.\nfunc (b *Box) Blur() {\n\tif b.blur != nil {\n\t\tb.blur()\n\t}\n\tb.hasFocus = false\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (b *Box) HasFocus() bool {\n\treturn b.hasFocus\n}\n"
        },
        {
          "name": "button.go",
          "type": "blob",
          "size": 5.4482421875,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Button is labeled box that triggers an action when selected.\n//\n// See https://github.com/rivo/tview/wiki/Button for an example.\ntype Button struct {\n\t*Box\n\n\t// If set to true, the button cannot be activated.\n\tdisabled bool\n\n\t// The text to be displayed inside the button.\n\ttext string\n\n\t// The button's style (when deactivated).\n\tstyle tcell.Style\n\n\t// The button's style (when activated).\n\tactivatedStyle tcell.Style\n\n\t// The button's style (when disabled).\n\tdisabledStyle tcell.Style\n\n\t// An optional function which is called when the button was selected.\n\tselected func()\n\n\t// An optional function which is called when the user leaves the button. A\n\t// key is provided indicating which key was pressed to leave (tab or\n\t// backtab).\n\texit func(tcell.Key)\n}\n\n// NewButton returns a new input field.\nfunc NewButton(label string) *Button {\n\tbox := NewBox()\n\tbox.SetRect(0, 0, TaggedStringWidth(label)+4, 1)\n\treturn &Button{\n\t\tBox:            box,\n\t\ttext:           label,\n\t\tstyle:          tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\tactivatedStyle: tcell.StyleDefault.Background(Styles.PrimaryTextColor).Foreground(Styles.InverseTextColor),\n\t\tdisabledStyle:  tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.ContrastSecondaryTextColor),\n\t}\n}\n\n// SetLabel sets the button text.\nfunc (b *Button) SetLabel(label string) *Button {\n\tb.text = label\n\treturn b\n}\n\n// GetLabel returns the button text.\nfunc (b *Button) GetLabel() string {\n\treturn b.text\n}\n\n// SetLabelColor sets the color of the button text.\nfunc (b *Button) SetLabelColor(color tcell.Color) *Button {\n\tb.style = b.style.Foreground(color)\n\treturn b\n}\n\n// SetStyle sets the style of the button used when it is not focused.\nfunc (b *Button) SetStyle(style tcell.Style) *Button {\n\tb.style = style\n\treturn b\n}\n\n// SetLabelColorActivated sets the color of the button text when the button is\n// in focus.\nfunc (b *Button) SetLabelColorActivated(color tcell.Color) *Button {\n\tb.activatedStyle = b.activatedStyle.Foreground(color)\n\treturn b\n}\n\n// SetBackgroundColorActivated sets the background color of the button text when\n// the button is in focus.\nfunc (b *Button) SetBackgroundColorActivated(color tcell.Color) *Button {\n\tb.activatedStyle = b.activatedStyle.Background(color)\n\treturn b\n}\n\n// SetActivatedStyle sets the style of the button used when it is focused.\nfunc (b *Button) SetActivatedStyle(style tcell.Style) *Button {\n\tb.activatedStyle = style\n\treturn b\n}\n\n// SetDisabledStyle sets the style of the button used when it is disabled.\nfunc (b *Button) SetDisabledStyle(style tcell.Style) *Button {\n\tb.disabledStyle = style\n\treturn b\n}\n\n// SetDisabled sets whether or not the button is disabled. Disabled buttons\n// cannot be activated.\n//\n// If the button is part of a form, you should set focus to the form itself\n// after calling this function to set focus to the next non-disabled form item.\nfunc (b *Button) SetDisabled(disabled bool) *Button {\n\tb.disabled = disabled\n\treturn b\n}\n\n// IsDisabled returns whether or not the button is disabled.\nfunc (b *Button) IsDisabled() bool {\n\treturn b.disabled\n}\n\n// SetSelectedFunc sets a handler which is called when the button was selected.\nfunc (b *Button) SetSelectedFunc(handler func()) *Button {\n\tb.selected = handler\n\treturn b\n}\n\n// SetExitFunc sets a handler which is called when the user leaves the button.\n// The callback function is provided with the key that was pressed, which is one\n// of the following:\n//\n//   - KeyEscape: Leaving the button with no specific direction.\n//   - KeyTab: Move to the next field.\n//   - KeyBacktab: Move to the previous field.\nfunc (b *Button) SetExitFunc(handler func(key tcell.Key)) *Button {\n\tb.exit = handler\n\treturn b\n}\n\n// Draw draws this primitive onto the screen.\nfunc (b *Button) Draw(screen tcell.Screen) {\n\t// Draw the box.\n\tstyle := b.style\n\tif b.disabled {\n\t\tstyle = b.disabledStyle\n\t}\n\tif b.HasFocus() && !b.disabled {\n\t\tstyle = b.activatedStyle\n\t}\n\t_, backgroundColor, _ := style.Decompose()\n\tb.SetBackgroundColor(backgroundColor)\n\tb.Box.DrawForSubclass(screen, b)\n\n\t// Draw label.\n\tx, y, width, height := b.GetInnerRect()\n\tif width > 0 && height > 0 {\n\t\ty = y + height/2\n\t\tprintWithStyle(screen, b.text, x, y, 0, width, AlignCenter, style, true)\n\t}\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (b *Button) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn b.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif b.disabled {\n\t\t\treturn\n\t\t}\n\n\t\t// Process key event.\n\t\tswitch key := event.Key(); key {\n\t\tcase tcell.KeyEnter: // Selected.\n\t\t\tif b.selected != nil {\n\t\t\t\tb.selected()\n\t\t\t}\n\t\tcase tcell.KeyBacktab, tcell.KeyTab, tcell.KeyEscape: // Leave. No action.\n\t\t\tif b.exit != nil {\n\t\t\t\tb.exit(key)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (b *Button) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn b.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif b.disabled {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tif !b.InRect(event.Position()) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Process mouse event.\n\t\tif action == MouseLeftDown {\n\t\t\tsetFocus(b)\n\t\t\tconsumed = true\n\t\t} else if action == MouseLeftClick {\n\t\t\tif b.selected != nil {\n\t\t\t\tb.selected()\n\t\t\t}\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n"
        },
        {
          "name": "checkbox.go",
          "type": "blob",
          "size": 9.4677734375,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Checkbox implements a simple box for boolean values which can be checked and\n// unchecked.\n//\n// See https://github.com/rivo/tview/wiki/Checkbox for an example.\ntype Checkbox struct {\n\t*Box\n\n\t// Whether or not this checkbox is disabled/read-only.\n\tdisabled bool\n\n\t// Whether or not this box is checked.\n\tchecked bool\n\n\t// The text to be displayed before the input area.\n\tlabel string\n\n\t// The screen width of the label area. A value of 0 means use the width of\n\t// the label text.\n\tlabelWidth int\n\n\t// The label style.\n\tlabelStyle tcell.Style\n\n\t// The style of the unchecked checkbox.\n\tuncheckedStyle tcell.Style\n\n\t// The style of the checked checkbox.\n\tcheckedStyle tcell.Style\n\n\t// Teh style of the checkbox when it is currently focused.\n\tfocusStyle tcell.Style\n\n\t// The string used to display an unchecked box.\n\tuncheckedString string\n\n\t// The string used to display a checked box.\n\tcheckedString string\n\n\t// An optional function which is called when the user changes the checked\n\t// state of this checkbox.\n\tchanged func(checked bool)\n\n\t// An optional function which is called when the user indicated that they\n\t// are done entering text. The key which was pressed is provided (tab,\n\t// shift-tab, or escape).\n\tdone func(tcell.Key)\n\n\t// A callback function set by the Form class and called when the user leaves\n\t// this form item.\n\tfinished func(tcell.Key)\n}\n\n// NewCheckbox returns a new input field.\nfunc NewCheckbox() *Checkbox {\n\treturn &Checkbox{\n\t\tBox:             NewBox(),\n\t\tlabelStyle:      tcell.StyleDefault.Foreground(Styles.SecondaryTextColor),\n\t\tuncheckedStyle:  tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\tcheckedStyle:    tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\tfocusStyle:      tcell.StyleDefault.Background(Styles.PrimaryTextColor).Foreground(Styles.ContrastBackgroundColor),\n\t\tuncheckedString: \" \",\n\t\tcheckedString:   \"X\",\n\t}\n}\n\n// SetChecked sets the state of the checkbox. This also triggers the \"changed\"\n// callback if the state changes with this call.\nfunc (c *Checkbox) SetChecked(checked bool) *Checkbox {\n\tif c.checked != checked {\n\t\tif c.changed != nil {\n\t\t\tc.changed(checked)\n\t\t}\n\t\tc.checked = checked\n\t}\n\treturn c\n}\n\n// IsChecked returns whether or not the box is checked.\nfunc (c *Checkbox) IsChecked() bool {\n\treturn c.checked\n}\n\n// SetLabel sets the text to be displayed before the input area.\nfunc (c *Checkbox) SetLabel(label string) *Checkbox {\n\tc.label = label\n\treturn c\n}\n\n// GetLabel returns the text to be displayed before the input area.\nfunc (c *Checkbox) GetLabel() string {\n\treturn c.label\n}\n\n// SetLabelWidth sets the screen width of the label. A value of 0 will cause the\n// primitive to use the width of the label string.\nfunc (c *Checkbox) SetLabelWidth(width int) *Checkbox {\n\tc.labelWidth = width\n\treturn c\n}\n\n// SetLabelColor sets the color of the label.\nfunc (c *Checkbox) SetLabelColor(color tcell.Color) *Checkbox {\n\tc.labelStyle = c.labelStyle.Foreground(color)\n\treturn c\n}\n\n// SetLabelStyle sets the style of the label.\nfunc (c *Checkbox) SetLabelStyle(style tcell.Style) *Checkbox {\n\tc.labelStyle = style\n\treturn c\n}\n\n// SetFieldBackgroundColor sets the background color of the input area.\nfunc (c *Checkbox) SetFieldBackgroundColor(color tcell.Color) *Checkbox {\n\tc.uncheckedStyle = c.uncheckedStyle.Background(color)\n\tc.checkedStyle = c.checkedStyle.Background(color)\n\tc.focusStyle = c.focusStyle.Foreground(color)\n\treturn c\n}\n\n// SetFieldTextColor sets the text color of the input area.\nfunc (c *Checkbox) SetFieldTextColor(color tcell.Color) *Checkbox {\n\tc.uncheckedStyle = c.uncheckedStyle.Foreground(color)\n\tc.checkedStyle = c.checkedStyle.Foreground(color)\n\tc.focusStyle = c.focusStyle.Background(color)\n\treturn c\n}\n\n// SetUncheckedStyle sets the style of the unchecked checkbox.\nfunc (c *Checkbox) SetUncheckedStyle(style tcell.Style) *Checkbox {\n\tc.uncheckedStyle = style\n\treturn c\n}\n\n// SetCheckedStyle sets the style of the checked checkbox.\nfunc (c *Checkbox) SetCheckedStyle(style tcell.Style) *Checkbox {\n\tc.checkedStyle = style\n\treturn c\n}\n\n// SetActivatedStyle sets the style of the checkbox when it is currently\n// focused.\nfunc (c *Checkbox) SetActivatedStyle(style tcell.Style) *Checkbox {\n\tc.focusStyle = style\n\treturn c\n}\n\n// SetCheckedString sets the string to be displayed when the checkbox is\n// checked (defaults to \"X\"). The string may contain color tags (consider\n// adapting the checkbox's various styles accordingly). See [Escape] in\n// case you want to display square brackets.\nfunc (c *Checkbox) SetCheckedString(checked string) *Checkbox {\n\tc.checkedString = checked\n\treturn c\n}\n\n// SetUncheckedString sets the string to be displayed when the checkbox is\n// not checked (defaults to the empty space \" \"). The string may contain color\n// tags (consider adapting the checkbox's various styles accordingly). See\n// [Escape] in case you want to display square brackets.\nfunc (c *Checkbox) SetUncheckedString(unchecked string) *Checkbox {\n\tc.uncheckedString = unchecked\n\treturn c\n}\n\n// SetFormAttributes sets attributes shared by all form items.\nfunc (c *Checkbox) SetFormAttributes(labelWidth int, labelColor, bgColor, fieldTextColor, fieldBgColor tcell.Color) FormItem {\n\tc.labelWidth = labelWidth\n\tc.SetLabelColor(labelColor)\n\tc.backgroundColor = bgColor\n\tc.SetFieldTextColor(fieldTextColor)\n\tc.SetFieldBackgroundColor(fieldBgColor)\n\treturn c\n}\n\n// GetFieldWidth returns this primitive's field width.\nfunc (c *Checkbox) GetFieldWidth() int {\n\treturn 1\n}\n\n// GetFieldHeight returns this primitive's field height.\nfunc (c *Checkbox) GetFieldHeight() int {\n\treturn 1\n}\n\n// SetDisabled sets whether or not the item is disabled / read-only.\nfunc (c *Checkbox) SetDisabled(disabled bool) FormItem {\n\tc.disabled = disabled\n\tif c.finished != nil {\n\t\tc.finished(-1)\n\t}\n\treturn c\n}\n\n// SetChangedFunc sets a handler which is called when the checked state of this\n// checkbox was changed. The handler function receives the new state.\nfunc (c *Checkbox) SetChangedFunc(handler func(checked bool)) *Checkbox {\n\tc.changed = handler\n\treturn c\n}\n\n// SetDoneFunc sets a handler which is called when the user is done using the\n// checkbox. The callback function is provided with the key that was pressed,\n// which is one of the following:\n//\n//   - KeyEscape: Abort text input.\n//   - KeyTab: Move to the next field.\n//   - KeyBacktab: Move to the previous field.\nfunc (c *Checkbox) SetDoneFunc(handler func(key tcell.Key)) *Checkbox {\n\tc.done = handler\n\treturn c\n}\n\n// SetFinishedFunc sets a callback invoked when the user leaves this form item.\nfunc (c *Checkbox) SetFinishedFunc(handler func(key tcell.Key)) FormItem {\n\tc.finished = handler\n\treturn c\n}\n\n// Focus is called when this primitive receives focus.\nfunc (c *Checkbox) Focus(delegate func(p Primitive)) {\n\t// If we're part of a form and this item is disabled, there's nothing the\n\t// user can do here so we're finished.\n\tif c.finished != nil && c.disabled {\n\t\tc.finished(-1)\n\t\treturn\n\t}\n\n\tc.Box.Focus(delegate)\n}\n\n// Draw draws this primitive onto the screen.\nfunc (c *Checkbox) Draw(screen tcell.Screen) {\n\tc.Box.DrawForSubclass(screen, c)\n\n\t// Prepare\n\tx, y, width, height := c.GetInnerRect()\n\trightLimit := x + width\n\tif height < 1 || rightLimit <= x {\n\t\treturn\n\t}\n\n\t// Draw label.\n\t_, labelBg, _ := c.labelStyle.Decompose()\n\tif c.labelWidth > 0 {\n\t\tlabelWidth := c.labelWidth\n\t\tif labelWidth > width {\n\t\t\tlabelWidth = width\n\t\t}\n\t\tprintWithStyle(screen, c.label, x, y, 0, labelWidth, AlignLeft, c.labelStyle, labelBg == tcell.ColorDefault)\n\t\tx += labelWidth\n\t\twidth -= labelWidth\n\t} else {\n\t\t_, _, drawnWidth := printWithStyle(screen, c.label, x, y, 0, width, AlignLeft, c.labelStyle, labelBg == tcell.ColorDefault)\n\t\tx += drawnWidth\n\t\twidth -= drawnWidth\n\t}\n\n\t// Draw checkbox.\n\tstr := c.uncheckedString\n\tstyle := c.uncheckedStyle\n\tif c.checked {\n\t\tstr = c.checkedString\n\t\tstyle = c.checkedStyle\n\t}\n\tif c.disabled {\n\t\tstyle = style.Background(c.backgroundColor)\n\t}\n\tif c.HasFocus() {\n\t\tstyle = c.focusStyle\n\t}\n\tprintWithStyle(screen, str, x, y, 0, width, AlignLeft, style, c.disabled)\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (c *Checkbox) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn c.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif c.disabled {\n\t\t\treturn\n\t\t}\n\n\t\t// Process key event.\n\t\tswitch key := event.Key(); key {\n\t\tcase tcell.KeyRune, tcell.KeyEnter: // Check.\n\t\t\tif key == tcell.KeyRune && event.Rune() != ' ' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc.checked = !c.checked\n\t\t\tif c.changed != nil {\n\t\t\t\tc.changed(c.checked)\n\t\t\t}\n\t\tcase tcell.KeyTab, tcell.KeyBacktab, tcell.KeyEscape: // We're done.\n\t\t\tif c.done != nil {\n\t\t\t\tc.done(key)\n\t\t\t}\n\t\t\tif c.finished != nil {\n\t\t\t\tc.finished(key)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (c *Checkbox) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn c.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif c.disabled {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tx, y := event.Position()\n\t\t_, rectY, _, _ := c.GetInnerRect()\n\t\tif !c.InRect(x, y) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Process mouse event.\n\t\tif y == rectY {\n\t\t\tif action == MouseLeftDown {\n\t\t\t\tsetFocus(c)\n\t\t\t\tconsumed = true\n\t\t\t} else if action == MouseLeftClick {\n\t\t\t\tc.checked = !c.checked\n\t\t\t\tif c.changed != nil {\n\t\t\t\t\tc.changed(c.checked)\n\t\t\t\t}\n\t\t\t\tconsumed = true\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t})\n}\n"
        },
        {
          "name": "demos",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 8.4970703125,
          "content": "/*\nPackage tview implements rich widgets for terminal based user interfaces. The\nwidgets provided with this package are useful for data exploration and data\nentry.\n\n# Widgets\n\nThe package implements the following widgets:\n\n  - [TextView]: A scrollable window that display multi-colored text. Text may\n    also be highlighted.\n  - [TextArea]: An editable multi-line text area.\n  - [Table]: A scrollable display of tabular data. Table cells, rows, or columns\n    may also be highlighted.\n  - [TreeView]: A scrollable display for hierarchical data. Tree nodes can be\n    highlighted, collapsed, expanded, and more.\n  - [List]: A navigable text list with optional keyboard shortcuts.\n  - [InputField]: One-line input fields to enter text.\n  - [DropDown]: Drop-down selection fields.\n  - [Checkbox]: Selectable checkbox for boolean values.\n  - [Image]: Displays images.\n  - [Button]: Buttons which get activated when the user selects them.\n  - [Form]: Forms composed of input fields, drop down selections, checkboxes,\n    and buttons.\n  - [Modal]: A centered window with a text message and one or more buttons.\n  - [Grid]: A grid based layout manager.\n  - [Flex]: A Flexbox based layout manager.\n  - [Pages]: A page based layout manager.\n\nThe package also provides Application which is used to poll the event queue and\ndraw widgets on screen.\n\n# Hello World\n\nThe following is a very basic example showing a box with the title \"Hello,\nworld!\":\n\n\tpackage main\n\n\timport (\n\t\t\"github.com/rivo/tview\"\n\t)\n\n\tfunc main() {\n\t\tbox := tview.NewBox().SetBorder(true).SetTitle(\"Hello, world!\")\n\t\tif err := tview.NewApplication().SetRoot(box, true).Run(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\nFirst, we create a box primitive with a border and a title. Then we create an\napplication, set the box as its root primitive, and run the event loop. The\napplication exits when the application's [Application.Stop] function is called\nor when Ctrl-C is pressed.\n\n# More Demos\n\nYou will find more demos in the \"demos\" subdirectory. It also contains a\npresentation (written using tview) which gives an overview of the different\nwidgets and how they can be used.\n\n# Styles, Colors, and Hyperlinks\n\nThroughout this package, styles are specified using the [tcell.Style] type.\nStyles specify colors with the [tcell.Color] type. Functions such as\n[tcell.GetColor], [tcell.NewHexColor], and [tcell.NewRGBColor] can be used to\ncreate colors from W3C color names or RGB values. The [tcell.Style] type also\nallows you to specify text attributes such as \"bold\" or \"underline\" or a URL\nwhich some terminals use to display hyperlinks.\n\nAlmost all strings which are displayed may contain style tags. A style tag's\ncontent is always wrapped in square brackets. In its simplest form, a style tag\nspecifies the foreground color of the text. Colors in these tags are W3C color\nnames or six hexadecimal digits following a hash tag. Examples:\n\n\tThis is a [red]warning[white]!\n\tThe sky is [#8080ff]blue[#ffffff].\n\nA style tag changes the style of the characters following that style tag. There\nis no style stack and no nesting of style tags.\n\nStyle tags are used in almost everything from box titles, list text, form item\nlabels, to table cells. In a [TextView], this functionality has to be switched\non explicitly. See the [TextView] documentation for more information.\n\nA style tag's full format looks like this:\n\n\t[<foreground>:<background>:<attribute flags>:<url>]\n\nEach of the four fields can be left blank and trailing fields can be omitted.\n(Empty square brackets \"[]\", however, are not considered style tags.) Fields\nthat are not specified will be left unchanged. A field with just a dash (\"-\")\nmeans \"reset to default\".\n\nYou can specify the following flags to turn on certain attributes (some flags\nmay not be supported by your terminal):\n\n\tl: blink\n\tb: bold\n\ti: italic\n\td: dim\n\tr: reverse (switch foreground and background color)\n\tu: underline\n\ts: strike-through\n\nUse uppercase letters to turn off the corresponding attribute, for example,\n\"B\" to turn off bold. Uppercase letters have no effect if the attribute was not\npreviously set.\n\nSetting a URL allows you to turn a piece of text into a hyperlink in some\nterminals. Specify a dash (\"-\") to specify the end of the hyperlink. Hyperlinks\nmust only contain single-byte characters (e.g. ASCII) and they may not contain\nbracket characters (\"[\" or \"]\").\n\nExamples:\n\n\t[yellow]Yellow text\n\t[yellow:red]Yellow text on red background\n\t[:red]Red background, text color unchanged\n\t[yellow::u]Yellow text underlined\n\t[::bl]Bold, blinking text\n\t[::-]Colors unchanged, flags reset\n\t[-]Reset foreground color\n\t[::i]Italic and [::I]not italic\n\tClick [:::https://example.com]here[:::-] for example.com.\n\tSend an email to [:::mailto:her@example.com]her/[:::mail:him@example.com]him/[:::mail:them@example.com]them[:::-].\n\t[-:-:-:-]Reset everything\n\t[:]No effect\n\t[]Not a valid style tag, will print square brackets as they are\n\nIn the rare event that you want to display a string such as \"[red]\" or\n\"[#00ff1a]\" without applying its effect, you need to put an opening square\nbracket before the closing square bracket. Note that the text inside the\nbrackets will be matched less strictly than region or colors tags. I.e. any\ncharacter that may be used in color or region tags will be recognized. Examples:\n\n\t[red[]      will be output as [red]\n\t[\"123\"[]    will be output as [\"123\"]\n\t[#6aff00[[] will be output as [#6aff00[]\n\t[a#\"[[[]    will be output as [a#\"[[]\n\t[]          will be output as [] (see style tags above)\n\t[[]         will be output as [[] (not an escaped tag)\n\nYou can use the Escape() function to insert brackets automatically where needed.\n\n# Styles\n\nWhen primitives are instantiated, they are initialized with colors taken from\nthe global [Styles] variable. You may change this variable to adapt the look and\nfeel of the primitives to your preferred style.\n\nNote that most terminals will not report information about their color theme.\nThis package therefore does not support using the terminal's color theme. The\ndefault style is a dark theme and you must change the [Styles] variable to\nswitch to a light (or other) theme.\n\n# Unicode Support\n\nThis package supports all unicode characters supported by your terminal.\n\n# Mouse Support\n\nIf your terminal supports mouse events, you can enable mouse support for your\napplication by calling [Application.EnableMouse]. Note that this may interfere\nwith your terminal's default mouse behavior. Mouse support is disabled by\ndefault.\n\n# Concurrency\n\nMany functions in this package are not thread-safe. For many applications, this\nis not an issue: If your code makes changes in response to key events, the\ncorresponding callback function will execute in the main goroutine and thus will\nnot cause any race conditions. (Exceptions to this are documented.)\n\nIf you access your primitives from other goroutines, however, you will need to\nsynchronize execution. The easiest way to do this is to call\n[Application.QueueUpdate] or [Application.QueueUpdateDraw] (see the function\ndocumentation for details):\n\n\tgo func() {\n\t  app.QueueUpdateDraw(func() {\n\t    table.SetCellSimple(0, 0, \"Foo bar\")\n\t  })\n\t}()\n\nOne exception to this is the io.Writer interface implemented by [TextView]. You\ncan safely write to a [TextView] from any goroutine. See the [TextView]\ndocumentation for details.\n\nYou can also call [Application.Draw] from any goroutine without having to wrap\nit in [Application.QueueUpdate]. And, as mentioned above, key event callbacks\nare executed in the main goroutine and thus should not use\n[Application.QueueUpdate] as that may lead to deadlocks. It is also not\nnecessary to call [Application.Draw] from such callbacks as it will be called\nautomatically.\n\n# Type Hierarchy\n\nAll widgets listed above contain the [Box] type. All of [Box]'s functions are\ntherefore available for all widgets, too. Please note that if you are using the\nfunctions of [Box] on a subclass, they will return a *Box, not the subclass.\nThis is a Golang limitation. So while tview supports method chaining in many\nplaces, these chains must be broken when using [Box]'s functions. Example:\n\n\t// This will cause \"textArea\" to be an empty Box.\n\ttextArea := tview.NewTextArea().\n\t\tSetMaxLength(256).\n\t\tSetPlaceholder(\"Enter text here\").\n\t\tSetBorder(true)\n\nYou will need to call [Box.SetBorder] separately:\n\n\ttextArea := tview.NewTextArea().\n\t\tSetMaxLength(256).\n\t\tSetPlaceholder(\"Enter text here\")\n\ttexArea.SetBorder(true)\n\nAll widgets also implement the [Primitive] interface.\n\nThe tview package's rendering is based on version 2 of\nhttps://github.com/gdamore/tcell. It uses types and constants from that package\n(e.g. colors, styles, and keyboard values).\n*/\npackage tview\n"
        },
        {
          "name": "dropdown.go",
          "type": "blob",
          "size": 18.44921875,
          "content": "package tview\n\nimport (\n\t\"strings\"\n\n\t\"github.com/gdamore/tcell/v2\"\n\t\"github.com/rivo/uniseg\"\n)\n\n// dropDownOption is one option that can be selected in a drop-down primitive.\ntype dropDownOption struct {\n\tText     string // The text to be displayed in the drop-down.\n\tSelected func() // The (optional) callback for when this option was selected.\n}\n\n// DropDown implements a selection widget whose options become visible in a\n// drop-down list when activated.\n//\n// See https://github.com/rivo/tview/wiki/DropDown for an example.\ntype DropDown struct {\n\t*Box\n\n\t// Whether or not this drop-down is disabled/read-only.\n\tdisabled bool\n\n\t// The options from which the user can choose.\n\toptions []*dropDownOption\n\n\t// Strings to be placed before and after each drop-down option.\n\toptionPrefix, optionSuffix string\n\n\t// The index of the currently selected option. Negative if no option is\n\t// currently selected.\n\tcurrentOption int\n\n\t// Strings to be placed before and after the current option.\n\tcurrentOptionPrefix, currentOptionSuffix string\n\n\t// The text to be displayed when no option has yet been selected.\n\tnoSelection string\n\n\t// Set to true if the options are visible and selectable.\n\topen bool\n\n\t// The runes typed so far to directly access one of the list items.\n\tprefix string\n\n\t// The list element for the options.\n\tlist *List\n\n\t// The text to be displayed before the input area.\n\tlabel string\n\n\t// The label color.\n\tlabelColor tcell.Color\n\n\t// The background color of the input area.\n\tfieldBackgroundColor tcell.Color\n\n\t// The text color of the input area.\n\tfieldTextColor tcell.Color\n\n\t// The color for prefixes.\n\tprefixTextColor tcell.Color\n\n\t// The screen width of the label area. A value of 0 means use the width of\n\t// the label text.\n\tlabelWidth int\n\n\t// The screen width of the input area. A value of 0 means extend as much as\n\t// possible.\n\tfieldWidth int\n\n\t// An optional function which is called when the user indicated that they\n\t// are done selecting options. The key which was pressed is provided (tab,\n\t// shift-tab, or escape).\n\tdone func(tcell.Key)\n\n\t// A callback function set by the Form class and called when the user leaves\n\t// this form item.\n\tfinished func(tcell.Key)\n\n\t// A callback function which is called when the user changes the drop-down's\n\t// selection.\n\tselected func(text string, index int)\n\n\tdragging bool // Set to true when mouse dragging is in progress.\n}\n\n// NewDropDown returns a new drop-down.\nfunc NewDropDown() *DropDown {\n\tlist := NewList()\n\tlist.ShowSecondaryText(false).\n\t\tSetMainTextStyle(tcell.StyleDefault.Background(Styles.MoreContrastBackgroundColor).Foreground(Styles.PrimitiveBackgroundColor)).\n\t\tSetSelectedStyle(tcell.StyleDefault.Background(Styles.PrimaryTextColor).Foreground(Styles.PrimitiveBackgroundColor)).\n\t\tSetHighlightFullLine(true).\n\t\tSetBackgroundColor(Styles.MoreContrastBackgroundColor)\n\n\td := &DropDown{\n\t\tBox:                  NewBox(),\n\t\tcurrentOption:        -1,\n\t\tlist:                 list,\n\t\tlabelColor:           Styles.SecondaryTextColor,\n\t\tfieldBackgroundColor: Styles.ContrastBackgroundColor,\n\t\tfieldTextColor:       Styles.PrimaryTextColor,\n\t\tprefixTextColor:      Styles.ContrastSecondaryTextColor,\n\t}\n\n\treturn d\n}\n\n// SetCurrentOption sets the index of the currently selected option. This may\n// be a negative value to indicate that no option is currently selected. Calling\n// this function will also trigger the \"selected\" callback (if there is one).\nfunc (d *DropDown) SetCurrentOption(index int) *DropDown {\n\tif index >= 0 && index < len(d.options) {\n\t\td.currentOption = index\n\t\td.list.SetCurrentItem(index)\n\t\tif d.selected != nil {\n\t\t\td.selected(d.options[index].Text, index)\n\t\t}\n\t\tif d.options[index].Selected != nil {\n\t\t\td.options[index].Selected()\n\t\t}\n\t} else {\n\t\td.currentOption = -1\n\t\td.list.SetCurrentItem(0) // Set to 0 because -1 means \"last item\".\n\t\tif d.selected != nil {\n\t\t\td.selected(\"\", -1)\n\t\t}\n\t}\n\treturn d\n}\n\n// GetCurrentOption returns the index of the currently selected option as well\n// as its text. If no option was selected, -1 and an empty string is returned.\nfunc (d *DropDown) GetCurrentOption() (int, string) {\n\tvar text string\n\tif d.currentOption >= 0 && d.currentOption < len(d.options) {\n\t\ttext = d.options[d.currentOption].Text\n\t}\n\treturn d.currentOption, text\n}\n\n// SetTextOptions sets the text to be placed before and after each drop-down\n// option (prefix/suffix), the text placed before and after the currently\n// selected option (currentPrefix/currentSuffix) as well as the text to be\n// displayed when no option is currently selected. Per default, all of these\n// strings are empty.\nfunc (d *DropDown) SetTextOptions(prefix, suffix, currentPrefix, currentSuffix, noSelection string) *DropDown {\n\td.currentOptionPrefix = currentPrefix\n\td.currentOptionSuffix = currentSuffix\n\td.noSelection = noSelection\n\td.optionPrefix = prefix\n\td.optionSuffix = suffix\n\tfor index := 0; index < d.list.GetItemCount(); index++ {\n\t\td.list.SetItemText(index, prefix+d.options[index].Text+suffix, \"\")\n\t}\n\treturn d\n}\n\n// SetLabel sets the text to be displayed before the input area.\nfunc (d *DropDown) SetLabel(label string) *DropDown {\n\td.label = label\n\treturn d\n}\n\n// GetLabel returns the text to be displayed before the input area.\nfunc (d *DropDown) GetLabel() string {\n\treturn d.label\n}\n\n// SetLabelWidth sets the screen width of the label. A value of 0 will cause the\n// primitive to use the width of the label string.\nfunc (d *DropDown) SetLabelWidth(width int) *DropDown {\n\td.labelWidth = width\n\treturn d\n}\n\n// SetLabelColor sets the color of the label.\nfunc (d *DropDown) SetLabelColor(color tcell.Color) *DropDown {\n\td.labelColor = color\n\treturn d\n}\n\n// SetFieldBackgroundColor sets the background color of the options area.\nfunc (d *DropDown) SetFieldBackgroundColor(color tcell.Color) *DropDown {\n\td.fieldBackgroundColor = color\n\treturn d\n}\n\n// SetFieldTextColor sets the text color of the options area.\nfunc (d *DropDown) SetFieldTextColor(color tcell.Color) *DropDown {\n\td.fieldTextColor = color\n\treturn d\n}\n\n// SetPrefixTextColor sets the color of the prefix string. The prefix string is\n// shown when the user starts typing text, which directly selects the first\n// option that starts with the typed string.\nfunc (d *DropDown) SetPrefixTextColor(color tcell.Color) *DropDown {\n\td.prefixTextColor = color\n\treturn d\n}\n\n// SetListStyles sets the styles of the items in the drop-down list (unselected\n// as well as selected items). Style attributes are currently ignored but may be\n// used in the future.\nfunc (d *DropDown) SetListStyles(unselected, selected tcell.Style) *DropDown {\n\td.list.SetMainTextStyle(unselected).SetSelectedStyle(selected)\n\t_, bg, _ := unselected.Decompose()\n\td.list.SetBackgroundColor(bg)\n\treturn d\n}\n\n// SetFormAttributes sets attributes shared by all form items.\nfunc (d *DropDown) SetFormAttributes(labelWidth int, labelColor, bgColor, fieldTextColor, fieldBgColor tcell.Color) FormItem {\n\td.labelWidth = labelWidth\n\td.labelColor = labelColor\n\td.backgroundColor = bgColor\n\td.fieldTextColor = fieldTextColor\n\td.fieldBackgroundColor = fieldBgColor\n\treturn d\n}\n\n// SetFieldWidth sets the screen width of the options area. A value of 0 means\n// extend to as long as the longest option text.\nfunc (d *DropDown) SetFieldWidth(width int) *DropDown {\n\td.fieldWidth = width\n\treturn d\n}\n\n// GetFieldWidth returns this primitive's field screen width.\nfunc (d *DropDown) GetFieldWidth() int {\n\tif d.fieldWidth > 0 {\n\t\treturn d.fieldWidth\n\t}\n\tfieldWidth := 0\n\tfor _, option := range d.options {\n\t\twidth := TaggedStringWidth(option.Text)\n\t\tif width > fieldWidth {\n\t\t\tfieldWidth = width\n\t\t}\n\t}\n\treturn fieldWidth\n}\n\n// GetFieldHeight returns this primitive's field height.\nfunc (d *DropDown) GetFieldHeight() int {\n\treturn 1\n}\n\n// SetDisabled sets whether or not the item is disabled / read-only.\nfunc (d *DropDown) SetDisabled(disabled bool) FormItem {\n\td.disabled = disabled\n\tif d.finished != nil {\n\t\td.finished(-1)\n\t}\n\treturn d\n}\n\n// AddOption adds a new selectable option to this drop-down. The \"selected\"\n// callback is called when this option was selected. It may be nil.\nfunc (d *DropDown) AddOption(text string, selected func()) *DropDown {\n\td.options = append(d.options, &dropDownOption{Text: text, Selected: selected})\n\td.list.AddItem(d.optionPrefix+text+d.optionSuffix, \"\", 0, nil)\n\treturn d\n}\n\n// SetOptions replaces all current options with the ones provided and installs\n// one callback function which is called when one of the options is selected.\n// It will be called with the option's text and its index into the options\n// slice. The \"selected\" parameter may be nil.\nfunc (d *DropDown) SetOptions(texts []string, selected func(text string, index int)) *DropDown {\n\td.list.Clear()\n\td.options = nil\n\tfor _, text := range texts {\n\t\td.AddOption(text, nil)\n\t}\n\td.selected = selected\n\treturn d\n}\n\n// GetOptionCount returns the number of options in the drop-down.\nfunc (d *DropDown) GetOptionCount() int {\n\treturn len(d.options)\n}\n\n// RemoveOption removes the specified option from the drop-down. Panics if the\n// index is out of range. If the currently selected option is removed, no option\n// will be selected.\nfunc (d *DropDown) RemoveOption(index int) *DropDown {\n\tif index == d.currentOption {\n\t\td.currentOption = -1\n\t}\n\td.options = append(d.options[:index], d.options[index+1:]...)\n\td.list.RemoveItem(index)\n\treturn d\n}\n\n// SetSelectedFunc sets a handler which is called when the user changes the\n// drop-down's option. This handler will be called in addition and prior to\n// an option's optional individual handler. The handler is provided with the\n// selected option's text and index. If \"no option\" was selected, these values\n// are an empty string and -1.\nfunc (d *DropDown) SetSelectedFunc(handler func(text string, index int)) *DropDown {\n\td.selected = handler\n\treturn d\n}\n\n// SetDoneFunc sets a handler which is called when the user is done selecting\n// options. The callback function is provided with the key that was pressed,\n// which is one of the following:\n//\n//   - KeyEscape: Abort selection.\n//   - KeyTab: Move to the next field.\n//   - KeyBacktab: Move to the previous field.\nfunc (d *DropDown) SetDoneFunc(handler func(key tcell.Key)) *DropDown {\n\td.done = handler\n\treturn d\n}\n\n// SetFinishedFunc sets a callback invoked when the user leaves this form item.\nfunc (d *DropDown) SetFinishedFunc(handler func(key tcell.Key)) FormItem {\n\td.finished = handler\n\treturn d\n}\n\n// Draw draws this primitive onto the screen.\nfunc (d *DropDown) Draw(screen tcell.Screen) {\n\td.Box.DrawForSubclass(screen, d)\n\n\t// Prepare.\n\tx, y, width, height := d.GetInnerRect()\n\trightLimit := x + width\n\tif height < 1 || rightLimit <= x {\n\t\treturn\n\t}\n\n\t// Draw label.\n\tif d.labelWidth > 0 {\n\t\tlabelWidth := d.labelWidth\n\t\tif labelWidth > rightLimit-x {\n\t\t\tlabelWidth = rightLimit - x\n\t\t}\n\t\tPrint(screen, d.label, x, y, labelWidth, AlignLeft, d.labelColor)\n\t\tx += labelWidth\n\t} else {\n\t\t_, drawnWidth := Print(screen, d.label, x, y, rightLimit-x, AlignLeft, d.labelColor)\n\t\tx += drawnWidth\n\t}\n\n\t// What's the longest option text?\n\tmaxWidth := 0\n\toptionWrapWidth := TaggedStringWidth(d.optionPrefix + d.optionSuffix)\n\tfor _, option := range d.options {\n\t\tstrWidth := TaggedStringWidth(option.Text) + optionWrapWidth\n\t\tif strWidth > maxWidth {\n\t\t\tmaxWidth = strWidth\n\t\t}\n\t}\n\n\t// Draw selection area.\n\tfieldWidth := d.fieldWidth\n\tif fieldWidth == 0 {\n\t\tfieldWidth = maxWidth\n\t\tif d.currentOption < 0 {\n\t\t\tnoSelectionWidth := TaggedStringWidth(d.noSelection)\n\t\t\tif noSelectionWidth > fieldWidth {\n\t\t\t\tfieldWidth = noSelectionWidth\n\t\t\t}\n\t\t} else if d.currentOption < len(d.options) {\n\t\t\tcurrentOptionWidth := TaggedStringWidth(d.currentOptionPrefix + d.options[d.currentOption].Text + d.currentOptionSuffix)\n\t\t\tif currentOptionWidth > fieldWidth {\n\t\t\t\tfieldWidth = currentOptionWidth\n\t\t\t}\n\t\t}\n\t}\n\tif rightLimit-x < fieldWidth {\n\t\tfieldWidth = rightLimit - x\n\t}\n\tfieldStyle := tcell.StyleDefault.Background(d.fieldBackgroundColor)\n\tif d.disabled {\n\t\tfieldStyle = fieldStyle.Background(d.backgroundColor)\n\t}\n\tfor index := 0; index < fieldWidth; index++ {\n\t\tscreen.SetContent(x+index, y, ' ', nil, fieldStyle)\n\t}\n\n\t// Draw selected text.\n\tif d.open && len(d.prefix) > 0 {\n\t\t// Show the prefix.\n\t\tcurrentOptionPrefixWidth := TaggedStringWidth(d.currentOptionPrefix)\n\t\tprefixWidth := uniseg.StringWidth(d.prefix)\n\t\tlistItemText := d.options[d.list.GetCurrentItem()].Text\n\t\tPrint(screen, d.currentOptionPrefix, x, y, fieldWidth, AlignLeft, d.fieldTextColor)\n\t\tPrint(screen, d.prefix, x+currentOptionPrefixWidth, y, fieldWidth-currentOptionPrefixWidth, AlignLeft, d.prefixTextColor)\n\t\tif len(d.prefix) < len(listItemText) {\n\t\t\tPrint(screen, listItemText[len(d.prefix):]+d.currentOptionSuffix, x+prefixWidth+currentOptionPrefixWidth, y, fieldWidth-prefixWidth-currentOptionPrefixWidth, AlignLeft, d.fieldTextColor)\n\t\t}\n\t} else {\n\t\tcolor := d.fieldTextColor\n\t\ttext := d.noSelection\n\t\tif d.currentOption >= 0 && d.currentOption < len(d.options) {\n\t\t\ttext = d.currentOptionPrefix + d.options[d.currentOption].Text + d.currentOptionSuffix\n\t\t}\n\t\t// Just show the current selection.\n\t\tPrint(screen, text, x, y, fieldWidth, AlignLeft, color)\n\t}\n\n\t// Draw options list.\n\tif d.HasFocus() && d.open {\n\t\tlx := x\n\t\tly := y + 1\n\t\tlwidth := maxWidth\n\t\tlheight := len(d.options)\n\t\tswidth, sheight := screen.Size()\n\t\t// We prefer to align the left sides of the list and the main widget, but\n\t\t// if there is no space to the right, then shift the list to the left.\n\t\tif lx+lwidth >= swidth {\n\t\t\tlx = swidth - lwidth\n\t\t\tif lx < 0 {\n\t\t\t\tlx = 0\n\t\t\t}\n\t\t}\n\t\t// We prefer to drop down but if there is no space, maybe drop up?\n\t\tif ly+lheight >= sheight && ly-2 > lheight-ly {\n\t\t\tly = y - lheight\n\t\t\tif ly < 0 {\n\t\t\t\tly = 0\n\t\t\t}\n\t\t}\n\t\tif ly+lheight >= sheight {\n\t\t\tlheight = sheight - ly\n\t\t}\n\t\td.list.SetRect(lx, ly, lwidth, lheight)\n\t\td.list.Draw(screen)\n\t}\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (d *DropDown) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn d.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif d.disabled {\n\t\t\treturn\n\t\t}\n\n\t\t// If the list has focus, let it process its own key events.\n\t\tif d.list.HasFocus() {\n\t\t\tif handler := d.list.InputHandler(); handler != nil {\n\t\t\t\thandler(event, setFocus)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// Process key event.\n\t\tswitch key := event.Key(); key {\n\t\tcase tcell.KeyEnter, tcell.KeyRune, tcell.KeyDown:\n\t\t\td.prefix = \"\"\n\n\t\t\t// If the first key was a letter already, it becomes part of the prefix.\n\t\t\tif r := event.Rune(); key == tcell.KeyRune && r != ' ' {\n\t\t\t\td.prefix += string(r)\n\t\t\t\td.evalPrefix()\n\t\t\t}\n\n\t\t\td.openList(setFocus)\n\t\tcase tcell.KeyEscape, tcell.KeyTab, tcell.KeyBacktab:\n\t\t\tif d.done != nil {\n\t\t\t\td.done(key)\n\t\t\t}\n\t\t\tif d.finished != nil {\n\t\t\t\td.finished(key)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// evalPrefix selects an item in the drop-down list based on the current prefix.\nfunc (d *DropDown) evalPrefix() {\n\tif len(d.prefix) > 0 {\n\t\tfor index, option := range d.options {\n\t\t\tif strings.HasPrefix(strings.ToLower(option.Text), d.prefix) {\n\t\t\t\td.list.SetCurrentItem(index)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Prefix does not match any item. Remove last rune.\n\t\tr := []rune(d.prefix)\n\t\td.prefix = string(r[:len(r)-1])\n\t}\n}\n\n// openList hands control over to the embedded List primitive.\nfunc (d *DropDown) openList(setFocus func(Primitive)) {\n\td.open = true\n\toptionBefore := d.currentOption\n\n\td.list.SetSelectedFunc(func(index int, mainText, secondaryText string, shortcut rune) {\n\t\tif d.dragging {\n\t\t\treturn // If we're dragging the mouse, we don't want to trigger any events.\n\t\t}\n\n\t\t// An option was selected. Close the list again.\n\t\td.currentOption = index\n\t\td.closeList(setFocus)\n\n\t\t// Trigger \"selected\" event.\n\t\tcurrentOption := d.options[d.currentOption]\n\t\tif d.selected != nil {\n\t\t\td.selected(currentOption.Text, d.currentOption)\n\t\t}\n\t\tif currentOption.Selected != nil {\n\t\t\tcurrentOption.Selected()\n\t\t}\n\t}).SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {\n\t\tif event.Key() == tcell.KeyRune {\n\t\t\td.prefix += string(event.Rune())\n\t\t\td.evalPrefix()\n\t\t} else if event.Key() == tcell.KeyBackspace || event.Key() == tcell.KeyBackspace2 {\n\t\t\tif len(d.prefix) > 0 {\n\t\t\t\tr := []rune(d.prefix)\n\t\t\t\td.prefix = string(r[:len(r)-1])\n\t\t\t}\n\t\t\td.evalPrefix()\n\t\t} else if event.Key() == tcell.KeyEscape {\n\t\t\td.currentOption = optionBefore\n\t\t\td.closeList(setFocus)\n\t\t} else {\n\t\t\td.prefix = \"\"\n\t\t}\n\n\t\treturn event\n\t})\n\n\tsetFocus(d.list)\n}\n\n// closeList closes the embedded List element by hiding it and removing focus\n// from it.\nfunc (d *DropDown) closeList(setFocus func(Primitive)) {\n\td.open = false\n\tif d.list.HasFocus() {\n\t\tsetFocus(d)\n\t}\n}\n\n// IsOpen returns true if the drop-down list is currently open.\nfunc (d *DropDown) IsOpen() bool {\n\treturn d.open\n}\n\n// Focus is called by the application when the primitive receives focus.\nfunc (d *DropDown) Focus(delegate func(p Primitive)) {\n\t// If we're part of a form and this item is disabled, there's nothing the\n\t// user can do here so we're finished.\n\tif d.finished != nil && d.disabled {\n\t\td.finished(-1)\n\t\treturn\n\t}\n\n\tif d.open {\n\t\tdelegate(d.list)\n\t} else {\n\t\td.Box.Focus(delegate)\n\t}\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (d *DropDown) HasFocus() bool {\n\tif d.open {\n\t\treturn d.list.HasFocus()\n\t}\n\treturn d.Box.HasFocus()\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (d *DropDown) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn d.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif d.disabled {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Was the mouse event in the drop-down box itself (or on its label)?\n\t\tx, y := event.Position()\n\t\trectX, rectY, rectWidth, _ := d.GetInnerRect()\n\t\tinRect := y == rectY && x >= rectX && x < rectX+rectWidth\n\t\tif !d.open && !inRect {\n\t\t\treturn d.InRect(x, y), nil // No, and it's not expanded either. Ignore.\n\t\t}\n\n\t\t// As long as the drop-down is open, we capture all mouse events.\n\t\tif d.open {\n\t\t\tcapture = d\n\t\t}\n\n\t\tswitch action {\n\t\tcase MouseLeftDown:\n\t\t\tconsumed = d.open || inRect\n\t\t\tcapture = d\n\t\t\tif !d.open {\n\t\t\t\td.openList(setFocus)\n\t\t\t\td.dragging = true\n\t\t\t} else if consumed, _ := d.list.MouseHandler()(MouseLeftClick, event, setFocus); !consumed {\n\t\t\t\td.closeList(setFocus) // Close drop-down if clicked outside of it.\n\t\t\t}\n\t\tcase MouseMove:\n\t\t\tif d.dragging {\n\t\t\t\t// We pretend it's a left click so we can see the selection during\n\t\t\t\t// dragging. Because we don't act upon it, it's not a problem.\n\t\t\t\td.list.MouseHandler()(MouseLeftClick, event, setFocus)\n\t\t\t\tconsumed = true\n\t\t\t}\n\t\tcase MouseLeftUp:\n\t\t\tif d.dragging {\n\t\t\t\td.dragging = false\n\t\t\t\td.list.MouseHandler()(MouseLeftClick, event, setFocus)\n\t\t\t\tconsumed = true\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t})\n}\n"
        },
        {
          "name": "flex.go",
          "type": "blob",
          "size": 7.9296875,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Flex directions.\nconst (\n\t// One item per row.\n\tFlexRow = 0\n\t// One item per column.\n\tFlexColumn = 1\n\t// As defined in CSS, items distributed along a row.\n\tFlexRowCSS = 1\n\t// As defined in CSS, items distributed within a column.\n\tFlexColumnCSS = 0\n)\n\n// flexItem holds layout options for one item.\ntype flexItem struct {\n\tItem       Primitive // The item to be positioned. May be nil for an empty item.\n\tFixedSize  int       // The item's fixed size which may not be changed, 0 if it has no fixed size.\n\tProportion int       // The item's proportion.\n\tFocus      bool      // Whether or not this item attracts the layout's focus.\n}\n\n// Flex is a basic implementation of the Flexbox layout. The contained\n// primitives are arranged horizontally or vertically. The way they are\n// distributed along that dimension depends on their layout settings, which is\n// either a fixed length or a proportional length. See AddItem() for details.\n//\n// See https://github.com/rivo/tview/wiki/Flex for an example.\ntype Flex struct {\n\t*Box\n\n\t// The items to be positioned.\n\titems []*flexItem\n\n\t// FlexRow or FlexColumn.\n\tdirection int\n\n\t// If set to true, Flex will use the entire screen as its available space\n\t// instead its box dimensions.\n\tfullScreen bool\n}\n\n// NewFlex returns a new flexbox layout container with no primitives and its\n// direction set to FlexColumn. To add primitives to this layout, see AddItem().\n// To change the direction, see SetDirection().\n//\n// Note that Box, the superclass of Flex, will not clear its contents so that\n// any nil flex items will leave their background unchanged. To clear a Flex's\n// background before any items are drawn, set it to a box with the desired\n// color:\n//\n//\tflex.Box = NewBox()\nfunc NewFlex() *Flex {\n\tf := &Flex{\n\t\tdirection: FlexColumn,\n\t}\n\tf.Box = NewBox()\n\tf.Box.dontClear = true\n\treturn f\n}\n\n// SetDirection sets the direction in which the contained primitives are\n// distributed. This can be either FlexColumn (default) or FlexRow. Note that\n// these are the opposite of what you would expect coming from CSS. You may also\n// use FlexColumnCSS or FlexRowCSS, to remain in line with the CSS definition.\nfunc (f *Flex) SetDirection(direction int) *Flex {\n\tf.direction = direction\n\treturn f\n}\n\n// SetFullScreen sets the flag which, when true, causes the flex layout to use\n// the entire screen space instead of whatever size it is currently assigned to.\nfunc (f *Flex) SetFullScreen(fullScreen bool) *Flex {\n\tf.fullScreen = fullScreen\n\treturn f\n}\n\n// AddItem adds a new item to the container. The \"fixedSize\" argument is a width\n// or height that may not be changed by the layout algorithm. A value of 0 means\n// that its size is flexible and may be changed. The \"proportion\" argument\n// defines the relative size of the item compared to other flexible-size items.\n// For example, items with a proportion of 2 will be twice as large as items\n// with a proportion of 1. The proportion must be at least 1 if fixedSize == 0\n// (ignored otherwise).\n//\n// If \"focus\" is set to true, the item will receive focus when the Flex\n// primitive receives focus. If multiple items have the \"focus\" flag set to\n// true, the first one will receive focus.\n//\n// You can provide a nil value for the primitive. This will still consume screen\n// space but nothing will be drawn.\nfunc (f *Flex) AddItem(item Primitive, fixedSize, proportion int, focus bool) *Flex {\n\tf.items = append(f.items, &flexItem{Item: item, FixedSize: fixedSize, Proportion: proportion, Focus: focus})\n\treturn f\n}\n\n// RemoveItem removes all items for the given primitive from the container,\n// keeping the order of the remaining items intact.\nfunc (f *Flex) RemoveItem(p Primitive) *Flex {\n\tfor index := len(f.items) - 1; index >= 0; index-- {\n\t\tif f.items[index].Item == p {\n\t\t\tf.items = append(f.items[:index], f.items[index+1:]...)\n\t\t}\n\t}\n\treturn f\n}\n\n// GetItemCount returns the number of items in this container.\nfunc (f *Flex) GetItemCount() int {\n\treturn len(f.items)\n}\n\n// GetItem returns the primitive at the given index, starting with 0 for the\n// first primitive in this container.\n//\n// This function will panic for out of range indices.\nfunc (f *Flex) GetItem(index int) Primitive {\n\treturn f.items[index].Item\n}\n\n// Clear removes all items from the container.\nfunc (f *Flex) Clear() *Flex {\n\tf.items = nil\n\treturn f\n}\n\n// ResizeItem sets a new size for the item(s) with the given primitive. If there\n// are multiple Flex items with the same primitive, they will all receive the\n// same size. For details regarding the size parameters, see AddItem().\nfunc (f *Flex) ResizeItem(p Primitive, fixedSize, proportion int) *Flex {\n\tfor _, item := range f.items {\n\t\tif item.Item == p {\n\t\t\titem.FixedSize = fixedSize\n\t\t\titem.Proportion = proportion\n\t\t}\n\t}\n\treturn f\n}\n\n// Draw draws this primitive onto the screen.\nfunc (f *Flex) Draw(screen tcell.Screen) {\n\tf.Box.DrawForSubclass(screen, f)\n\n\t// Calculate size and position of the items.\n\n\t// Do we use the entire screen?\n\tif f.fullScreen {\n\t\twidth, height := screen.Size()\n\t\tf.SetRect(0, 0, width, height)\n\t}\n\n\t// How much space can we distribute?\n\tx, y, width, height := f.GetInnerRect()\n\tvar proportionSum int\n\tdistSize := width\n\tif f.direction == FlexRow {\n\t\tdistSize = height\n\t}\n\tfor _, item := range f.items {\n\t\tif item.FixedSize > 0 {\n\t\t\tdistSize -= item.FixedSize\n\t\t} else {\n\t\t\tproportionSum += item.Proportion\n\t\t}\n\t}\n\n\t// Calculate positions and draw items.\n\tpos := x\n\tif f.direction == FlexRow {\n\t\tpos = y\n\t}\n\tfor _, item := range f.items {\n\t\tsize := item.FixedSize\n\t\tif size <= 0 {\n\t\t\tif proportionSum > 0 {\n\t\t\t\tsize = distSize * item.Proportion / proportionSum\n\t\t\t\tdistSize -= size\n\t\t\t\tproportionSum -= item.Proportion\n\t\t\t} else {\n\t\t\t\tsize = 0\n\t\t\t}\n\t\t}\n\t\tif item.Item != nil {\n\t\t\tif f.direction == FlexColumn {\n\t\t\t\titem.Item.SetRect(pos, y, size, height)\n\t\t\t} else {\n\t\t\t\titem.Item.SetRect(x, pos, width, size)\n\t\t\t}\n\t\t}\n\t\tpos += size\n\n\t\tif item.Item != nil {\n\t\t\tif item.Item.HasFocus() {\n\t\t\t\tdefer item.Item.Draw(screen)\n\t\t\t} else {\n\t\t\t\titem.Item.Draw(screen)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Focus is called when this primitive receives focus.\nfunc (f *Flex) Focus(delegate func(p Primitive)) {\n\tfor _, item := range f.items {\n\t\tif item.Item != nil && item.Focus {\n\t\t\tdelegate(item.Item)\n\t\t\treturn\n\t\t}\n\t}\n\tf.Box.Focus(delegate)\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (f *Flex) HasFocus() bool {\n\tfor _, item := range f.items {\n\t\tif item.Item != nil && item.Item.HasFocus() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn f.Box.HasFocus()\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (f *Flex) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn f.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif !f.InRect(event.Position()) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Pass mouse events along to the first child item that takes it.\n\t\tfor _, item := range f.items {\n\t\t\tif item.Item == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconsumed, capture = item.Item.MouseHandler()(action, event, setFocus)\n\t\t\tif consumed {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t})\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (f *Flex) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn f.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tfor _, item := range f.items {\n\t\t\tif item.Item != nil && item.Item.HasFocus() {\n\t\t\t\tif handler := item.Item.InputHandler(); handler != nil {\n\t\t\t\t\thandler(event, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\n// PasteHandler returns the handler for this primitive.\nfunc (f *Flex) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn f.WrapPasteHandler(func(pastedText string, setFocus func(p Primitive)) {\n\t\tfor _, item := range f.items {\n\t\t\tif item.Item != nil && item.Item.HasFocus() {\n\t\t\t\tif handler := item.Item.PasteHandler(); handler != nil {\n\t\t\t\t\thandler(pastedText, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "form.go",
          "type": "blob",
          "size": 26.2724609375,
          "content": "package tview\n\nimport (\n\t\"image\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\nvar (\n\t// DefaultFormFieldWidth is the default field screen width of form elements\n\t// whose field width is flexible (0). This is used in the Form class for\n\t// horizontal layouts.\n\tDefaultFormFieldWidth = 10\n\n\t// DefaultFormFieldHeight is the default field height of multi-line form\n\t// elements whose field height is flexible (0).\n\tDefaultFormFieldHeight = 5\n)\n\n// FormItem is the interface all form items must implement to be able to be\n// included in a form.\ntype FormItem interface {\n\tPrimitive\n\n\t// GetLabel returns the item's label text.\n\tGetLabel() string\n\n\t// SetFormAttributes sets a number of item attributes at once.\n\tSetFormAttributes(labelWidth int, labelColor, bgColor, fieldTextColor, fieldBgColor tcell.Color) FormItem\n\n\t// GetFieldWidth returns the width of the form item's field (the area which\n\t// is manipulated by the user) in number of screen cells. A value of 0\n\t// indicates the field width is flexible and may use as much space as\n\t// required.\n\tGetFieldWidth() int\n\n\t// GetFieldHeight returns the height of the form item's field (the area which\n\t// is manipulated by the user). This value must be greater than 0.\n\tGetFieldHeight() int\n\n\t// SetFinishedFunc sets the handler function for when the user finished\n\t// entering data into the item. The handler may receive events for the\n\t// Enter key (we're done), the Escape key (cancel input), the Tab key (move\n\t// to next field), the Backtab key (move to previous field), or a negative\n\t// value, indicating that the action for the last known key should be\n\t// repeated.\n\tSetFinishedFunc(handler func(key tcell.Key)) FormItem\n\n\t// SetDisabled sets whether or not the item is disabled / read-only. A form\n\t// must have at least one item that is not disabled.\n\tSetDisabled(disabled bool) FormItem\n}\n\n// Form allows you to combine multiple one-line form elements into a vertical\n// or horizontal layout. Form elements include types such as InputField or\n// Checkbox. These elements can be optionally followed by one or more buttons\n// for which you can define form-wide actions (e.g. Save, Clear, Cancel).\n//\n// See https://github.com/rivo/tview/wiki/Form for an example.\ntype Form struct {\n\t*Box\n\n\t// The items of the form (one row per item).\n\titems []FormItem\n\n\t// The buttons of the form.\n\tbuttons []*Button\n\n\t// If set to true, instead of position items and buttons from top to bottom,\n\t// they are positioned from left to right.\n\thorizontal bool\n\n\t// The alignment of the buttons.\n\tbuttonsAlign int\n\n\t// The number of empty cells between items.\n\titemPadding int\n\n\t// The index of the item or button which has focus. (Items are counted first,\n\t// buttons are counted last.) This is only used when the form itself receives\n\t// focus so that the last element that had focus keeps it.\n\tfocusedElement int\n\n\t// The label color.\n\tlabelColor tcell.Color\n\n\t// The style of the input area.\n\tfieldStyle tcell.Style\n\n\t// The style of the buttons when they are not focused.\n\tbuttonStyle tcell.Style\n\n\t// The style of the buttons when they are focused.\n\tbuttonActivatedStyle tcell.Style\n\n\t// The style of the buttons when they are disabled.\n\tbuttonDisabledStyle tcell.Style\n\n\t// The last (valid) key that wsa sent to a \"finished\" handler or -1 if no\n\t// such key is known yet.\n\tlastFinishedKey tcell.Key\n\n\t// An optional function which is called when the user hits Escape.\n\tcancel func()\n}\n\n// NewForm returns a new form.\nfunc NewForm() *Form {\n\tbox := NewBox().SetBorderPadding(1, 1, 1, 1)\n\n\tf := &Form{\n\t\tBox:                  box,\n\t\titemPadding:          1,\n\t\tlabelColor:           Styles.SecondaryTextColor,\n\t\tfieldStyle:           tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\tbuttonStyle:          tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\tbuttonActivatedStyle: tcell.StyleDefault.Background(Styles.PrimaryTextColor).Foreground(Styles.ContrastBackgroundColor),\n\t\tbuttonDisabledStyle:  tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.ContrastSecondaryTextColor),\n\t\tlastFinishedKey:      tcell.KeyTab, // To skip over inactive elements at the beginning of the form.\n\t}\n\n\treturn f\n}\n\n// SetItemPadding sets the number of empty rows between form items for vertical\n// layouts and the number of empty cells between form items for horizontal\n// layouts.\nfunc (f *Form) SetItemPadding(padding int) *Form {\n\tf.itemPadding = padding\n\treturn f\n}\n\n// SetHorizontal sets the direction the form elements are laid out. If set to\n// true, instead of positioning them from top to bottom (the default), they are\n// positioned from left to right, moving into the next row if there is not\n// enough space.\nfunc (f *Form) SetHorizontal(horizontal bool) *Form {\n\tf.horizontal = horizontal\n\treturn f\n}\n\n// SetLabelColor sets the color of the labels.\nfunc (f *Form) SetLabelColor(color tcell.Color) *Form {\n\tf.labelColor = color\n\treturn f\n}\n\n// SetFieldBackgroundColor sets the background color of the input areas.\nfunc (f *Form) SetFieldBackgroundColor(color tcell.Color) *Form {\n\tf.fieldStyle = f.fieldStyle.Background(color)\n\treturn f\n}\n\n// SetFieldTextColor sets the text color of the input areas.\nfunc (f *Form) SetFieldTextColor(color tcell.Color) *Form {\n\tf.fieldStyle = f.fieldStyle.Foreground(color)\n\treturn f\n}\n\n// SetFieldStyle sets the style of the input areas. Attributes are currently\n// still ignored to maintain backwards compatibility.\nfunc (f *Form) SetFieldStyle(style tcell.Style) *Form {\n\tf.fieldStyle = style\n\treturn f\n}\n\n// SetButtonsAlign sets how the buttons align horizontally, one of AlignLeft\n// (the default), AlignCenter, and AlignRight. This is only\nfunc (f *Form) SetButtonsAlign(align int) *Form {\n\tf.buttonsAlign = align\n\treturn f\n}\n\n// SetButtonBackgroundColor sets the background color of the buttons. This is\n// also the text color of the buttons when they are focused.\nfunc (f *Form) SetButtonBackgroundColor(color tcell.Color) *Form {\n\tf.buttonStyle = f.buttonStyle.Background(color)\n\tf.buttonActivatedStyle = f.buttonActivatedStyle.Foreground(color)\n\treturn f\n}\n\n// SetButtonTextColor sets the color of the button texts. This is also the\n// background of the buttons when they are focused.\nfunc (f *Form) SetButtonTextColor(color tcell.Color) *Form {\n\tf.buttonStyle = f.buttonStyle.Foreground(color)\n\tf.buttonActivatedStyle = f.buttonActivatedStyle.Background(color)\n\treturn f\n}\n\n// SetButtonStyle sets the style of the buttons when they are not focused.\nfunc (f *Form) SetButtonStyle(style tcell.Style) *Form {\n\tf.buttonStyle = style\n\treturn f\n}\n\n// SetButtonActivatedStyle sets the style of the buttons when they are focused.\nfunc (f *Form) SetButtonActivatedStyle(style tcell.Style) *Form {\n\tf.buttonActivatedStyle = style\n\treturn f\n}\n\n// SetButtonDisabledStyle sets the style of the buttons when they are disabled.\nfunc (f *Form) SetButtonDisabledStyle(style tcell.Style) *Form {\n\tf.buttonDisabledStyle = style\n\treturn f\n}\n\n// SetFocus shifts the focus to the form element with the given index, counting\n// non-button items first and buttons last. Note that this index is only used\n// when the form itself receives focus.\nfunc (f *Form) SetFocus(index int) *Form {\n\tvar current, future int\n\tfor itemIndex, item := range f.items {\n\t\tif itemIndex == index {\n\t\t\tfuture = itemIndex\n\t\t}\n\t\tif item.HasFocus() {\n\t\t\tcurrent = itemIndex\n\t\t}\n\t}\n\tfor buttonIndex, button := range f.buttons {\n\t\tif buttonIndex+len(f.items) == index {\n\t\t\tfuture = buttonIndex + len(f.items)\n\t\t}\n\t\tif button.HasFocus() {\n\t\t\tcurrent = buttonIndex + len(f.items)\n\t\t}\n\t}\n\tvar focus func(p Primitive)\n\tfocus = func(p Primitive) {\n\t\tp.Focus(focus)\n\t}\n\tif current != future {\n\t\tif current >= 0 && current < len(f.items) {\n\t\t\tf.items[current].Blur()\n\t\t} else if current >= len(f.items) && current < len(f.items)+len(f.buttons) {\n\t\t\tf.buttons[current-len(f.items)].Blur()\n\t\t}\n\t\tif future >= 0 && future < len(f.items) {\n\t\t\tfocus(f.items[future])\n\t\t} else if future >= len(f.items) && future < len(f.items)+len(f.buttons) {\n\t\t\tfocus(f.buttons[future-len(f.items)])\n\t\t}\n\t}\n\tf.focusedElement = future\n\treturn f\n}\n\n// AddTextArea adds a text area to the form. It has a label, an optional initial\n// text, a size (width and height) referring to the actual input area (a\n// fieldWidth of 0 extends it as far right as possible, a fieldHeight of 0 will\n// cause it to be [DefaultFormFieldHeight]), and a maximum number of bytes of\n// text allowed (0 means no limit).\n//\n// The optional callback function is invoked when the content of the text area\n// has changed. Note that especially for larger texts, this is an expensive\n// operation due to technical constraints of the [TextArea] primitive (every key\n// stroke leads to a new reallocation of the entire text).\nfunc (f *Form) AddTextArea(label, text string, fieldWidth, fieldHeight, maxLength int, changed func(text string)) *Form {\n\tif fieldHeight == 0 {\n\t\tfieldHeight = DefaultFormFieldHeight\n\t}\n\ttextArea := NewTextArea().\n\t\tSetLabel(label).\n\t\tSetSize(fieldHeight, fieldWidth).\n\t\tSetMaxLength(maxLength)\n\tif text != \"\" {\n\t\ttextArea.SetText(text, true)\n\t}\n\tif changed != nil {\n\t\ttextArea.SetChangedFunc(func() {\n\t\t\tchanged(textArea.GetText())\n\t\t})\n\t}\n\tf.items = append(f.items, textArea)\n\treturn f\n}\n\n// AddTextView adds a text view to the form. It has a label and text, a size\n// (width and height) referring to the actual text element (a fieldWidth of 0\n// extends it as far right as possible, a fieldHeight of 0 will cause it to be\n// [DefaultFormFieldHeight]), a flag to turn on/off dynamic colors, and a flag\n// to turn on/off scrolling. If scrolling is turned off, the text view will not\n// receive focus.\nfunc (f *Form) AddTextView(label, text string, fieldWidth, fieldHeight int, dynamicColors, scrollable bool) *Form {\n\tif fieldHeight == 0 {\n\t\tfieldHeight = DefaultFormFieldHeight\n\t}\n\ttextArea := NewTextView().\n\t\tSetLabel(label).\n\t\tSetSize(fieldHeight, fieldWidth).\n\t\tSetDynamicColors(dynamicColors).\n\t\tSetScrollable(scrollable).\n\t\tSetText(text)\n\tf.items = append(f.items, textArea)\n\treturn f\n}\n\n// AddInputField adds an input field to the form. It has a label, an optional\n// initial value, a field width (a value of 0 extends it as far as possible),\n// an optional accept function to validate the item's value (set to nil to\n// accept any text), and an (optional) callback function which is invoked when\n// the input field's text has changed.\nfunc (f *Form) AddInputField(label, value string, fieldWidth int, accept func(textToCheck string, lastChar rune) bool, changed func(text string)) *Form {\n\tf.items = append(f.items, NewInputField().\n\t\tSetLabel(label).\n\t\tSetText(value).\n\t\tSetFieldWidth(fieldWidth).\n\t\tSetAcceptanceFunc(accept).\n\t\tSetChangedFunc(changed))\n\treturn f\n}\n\n// AddPasswordField adds a password field to the form. This is similar to an\n// input field except that the user's input not shown. Instead, a \"mask\"\n// character is displayed. The password field has a label, an optional initial\n// value, a field width (a value of 0 extends it as far as possible), and an\n// (optional) callback function which is invoked when the input field's text has\n// changed.\nfunc (f *Form) AddPasswordField(label, value string, fieldWidth int, mask rune, changed func(text string)) *Form {\n\tif mask == 0 {\n\t\tmask = '*'\n\t}\n\tf.items = append(f.items, NewInputField().\n\t\tSetLabel(label).\n\t\tSetText(value).\n\t\tSetFieldWidth(fieldWidth).\n\t\tSetMaskCharacter(mask).\n\t\tSetChangedFunc(changed))\n\treturn f\n}\n\n// AddDropDown adds a drop-down element to the form. It has a label, options,\n// and an (optional) callback function which is invoked when an option was\n// selected. The initial option may be a negative value to indicate that no\n// option is currently selected.\nfunc (f *Form) AddDropDown(label string, options []string, initialOption int, selected func(option string, optionIndex int)) *Form {\n\tf.items = append(f.items, NewDropDown().\n\t\tSetLabel(label).\n\t\tSetOptions(options, selected).\n\t\tSetCurrentOption(initialOption))\n\treturn f\n}\n\n// AddCheckbox adds a checkbox to the form. It has a label, an initial state,\n// and an (optional) callback function which is invoked when the state of the\n// checkbox was changed by the user.\nfunc (f *Form) AddCheckbox(label string, checked bool, changed func(checked bool)) *Form {\n\tf.items = append(f.items, NewCheckbox().\n\t\tSetLabel(label).\n\t\tSetChecked(checked).\n\t\tSetChangedFunc(changed))\n\treturn f\n}\n\n// AddImage adds an image to the form. It has a label and the image will fit in\n// the specified width and height (its aspect ratio is preserved). See\n// [Image.SetColors] for a description of the \"colors\" parameter. Images are not\n// interactive and are skipped over in a form. The \"width\" value may be 0\n// (adjust dynamically) but \"height\" should generally be a positive value.\nfunc (f *Form) AddImage(label string, image image.Image, width, height, colors int) *Form {\n\tf.items = append(f.items, NewImage().\n\t\tSetLabel(label).\n\t\tSetImage(image).\n\t\tSetSize(height, width).\n\t\tSetAlign(AlignTop, AlignLeft).\n\t\tSetColors(colors))\n\treturn f\n}\n\n// AddButton adds a new button to the form. The \"selected\" function is called\n// when the user selects this button. It may be nil.\nfunc (f *Form) AddButton(label string, selected func()) *Form {\n\tf.buttons = append(f.buttons, NewButton(label).SetSelectedFunc(selected))\n\treturn f\n}\n\n// GetButton returns the button at the specified 0-based index. Note that\n// buttons have been specially prepared for this form and modifying some of\n// their attributes may have unintended side effects.\nfunc (f *Form) GetButton(index int) *Button {\n\treturn f.buttons[index]\n}\n\n// RemoveButton removes the button at the specified position, starting with 0\n// for the button that was added first.\nfunc (f *Form) RemoveButton(index int) *Form {\n\tf.buttons = append(f.buttons[:index], f.buttons[index+1:]...)\n\treturn f\n}\n\n// GetButtonCount returns the number of buttons in this form.\nfunc (f *Form) GetButtonCount() int {\n\treturn len(f.buttons)\n}\n\n// GetButtonIndex returns the index of the button with the given label, starting\n// with 0 for the button that was added first. If no such label was found, -1\n// is returned.\nfunc (f *Form) GetButtonIndex(label string) int {\n\tfor index, button := range f.buttons {\n\t\tif button.GetLabel() == label {\n\t\t\treturn index\n\t\t}\n\t}\n\treturn -1\n}\n\n// Clear removes all input elements from the form, including the buttons if\n// specified.\nfunc (f *Form) Clear(includeButtons bool) *Form {\n\tf.items = nil\n\tif includeButtons {\n\t\tf.ClearButtons()\n\t}\n\tf.focusedElement = 0\n\treturn f\n}\n\n// ClearButtons removes all buttons from the form.\nfunc (f *Form) ClearButtons() *Form {\n\tf.buttons = nil\n\treturn f\n}\n\n// AddFormItem adds a new item to the form. This can be used to add your own\n// objects to the form. Note, however, that the Form class will override some\n// of its attributes to make it work in the form context. Specifically, these\n// are:\n//\n//   - The label width\n//   - The label color\n//   - The background color\n//   - The field text color\n//   - The field background color\nfunc (f *Form) AddFormItem(item FormItem) *Form {\n\tf.items = append(f.items, item)\n\treturn f\n}\n\n// GetFormItemCount returns the number of items in the form (not including the\n// buttons).\nfunc (f *Form) GetFormItemCount() int {\n\treturn len(f.items)\n}\n\n// GetFormItem returns the form item at the given position, starting with index\n// 0. Elements are referenced in the order they were added. Buttons are not\n// included.\nfunc (f *Form) GetFormItem(index int) FormItem {\n\treturn f.items[index]\n}\n\n// RemoveFormItem removes the form element at the given position, starting with\n// index 0. Elements are referenced in the order they were added. Buttons are\n// not included.\nfunc (f *Form) RemoveFormItem(index int) *Form {\n\tf.items = append(f.items[:index], f.items[index+1:]...)\n\treturn f\n}\n\n// GetFormItemByLabel returns the first form element with the given label. If\n// no such element is found, nil is returned. Buttons are not searched and will\n// therefore not be returned.\nfunc (f *Form) GetFormItemByLabel(label string) FormItem {\n\tfor _, item := range f.items {\n\t\tif item.GetLabel() == label {\n\t\t\treturn item\n\t\t}\n\t}\n\treturn nil\n}\n\n// GetFormItemIndex returns the index of the first form element with the given\n// label. If no such element is found, -1 is returned. Buttons are not searched\n// and will therefore not be returned.\nfunc (f *Form) GetFormItemIndex(label string) int {\n\tfor index, item := range f.items {\n\t\tif item.GetLabel() == label {\n\t\t\treturn index\n\t\t}\n\t}\n\treturn -1\n}\n\n// GetFocusedItemIndex returns the indices of the form element or button which\n// currently has focus. If they don't, -1 is returned respectively.\nfunc (f *Form) GetFocusedItemIndex() (formItem, button int) {\n\tindex := f.focusIndex()\n\tif index < 0 {\n\t\treturn -1, -1\n\t}\n\tif index < len(f.items) {\n\t\treturn index, -1\n\t}\n\treturn -1, index - len(f.items)\n}\n\n// SetCancelFunc sets a handler which is called when the user hits the Escape\n// key.\nfunc (f *Form) SetCancelFunc(callback func()) *Form {\n\tf.cancel = callback\n\treturn f\n}\n\n// Draw draws this primitive onto the screen.\nfunc (f *Form) Draw(screen tcell.Screen) {\n\tf.Box.DrawForSubclass(screen, f)\n\n\t// Determine the actual item that has focus.\n\tif index := f.focusIndex(); index >= 0 {\n\t\tf.focusedElement = index\n\t}\n\n\t// Determine the dimensions.\n\tx, y, width, height := f.GetInnerRect()\n\ttopLimit := y\n\tbottomLimit := y + height\n\trightLimit := x + width\n\tstartX := x\n\n\t// Find the longest label.\n\tvar maxLabelWidth int\n\tfor _, item := range f.items {\n\t\tlabelWidth := TaggedStringWidth(item.GetLabel())\n\t\tif labelWidth > maxLabelWidth {\n\t\t\tmaxLabelWidth = labelWidth\n\t\t}\n\t}\n\tmaxLabelWidth++ // Add one space.\n\n\t// Calculate positions of form items.\n\ttype position struct{ x, y, width, height int }\n\tpositions := make([]position, len(f.items)+len(f.buttons))\n\tvar (\n\t\tfocusedPosition position\n\t\tlineHeight      = 1\n\t)\n\tfor index, item := range f.items {\n\t\t// Calculate the space needed.\n\t\tlabelWidth := TaggedStringWidth(item.GetLabel())\n\t\tvar itemWidth int\n\t\tif f.horizontal {\n\t\t\tfieldWidth := item.GetFieldWidth()\n\t\t\tif fieldWidth <= 0 {\n\t\t\t\tfieldWidth = DefaultFormFieldWidth\n\t\t\t}\n\t\t\tlabelWidth++\n\t\t\titemWidth = labelWidth + fieldWidth\n\t\t} else {\n\t\t\t// We want all fields to align vertically.\n\t\t\tlabelWidth = maxLabelWidth\n\t\t\titemWidth = width\n\t\t}\n\t\titemHeight := item.GetFieldHeight()\n\t\tif itemHeight <= 0 {\n\t\t\titemHeight = DefaultFormFieldHeight\n\t\t}\n\n\t\t// Advance to next line if there is no space.\n\t\tif f.horizontal && x+labelWidth+1 >= rightLimit {\n\t\t\tx = startX\n\t\t\ty += lineHeight + 1\n\t\t\tlineHeight = itemHeight\n\t\t}\n\n\t\t// Update line height.\n\t\tif itemHeight > lineHeight {\n\t\t\tlineHeight = itemHeight\n\t\t}\n\n\t\t// Adjust the item's attributes.\n\t\tif x+itemWidth >= rightLimit {\n\t\t\titemWidth = rightLimit - x\n\t\t}\n\t\tfieldTextColor, fieldBackgroundColor, _ := f.fieldStyle.Decompose()\n\t\titem.SetFormAttributes(\n\t\t\tlabelWidth,\n\t\t\tf.labelColor,\n\t\t\tf.backgroundColor,\n\t\t\tfieldTextColor,\n\t\t\tfieldBackgroundColor,\n\t\t)\n\n\t\t// Save position.\n\t\tpositions[index].x = x\n\t\tpositions[index].y = y\n\t\tpositions[index].width = itemWidth\n\t\tpositions[index].height = itemHeight\n\t\tif item.HasFocus() {\n\t\t\tfocusedPosition = positions[index]\n\t\t}\n\n\t\t// Advance to next item.\n\t\tif f.horizontal {\n\t\t\tx += itemWidth + f.itemPadding\n\t\t} else {\n\t\t\ty += itemHeight + f.itemPadding\n\t\t}\n\t}\n\n\t// How wide are the buttons?\n\tbuttonWidths := make([]int, len(f.buttons))\n\tbuttonsWidth := 0\n\tfor index, button := range f.buttons {\n\t\tw := TaggedStringWidth(button.GetLabel()) + 4\n\t\tbuttonWidths[index] = w\n\t\tbuttonsWidth += w + 1\n\t}\n\tbuttonsWidth--\n\n\t// Where do we place them?\n\tif !f.horizontal && x+buttonsWidth < rightLimit {\n\t\tif f.buttonsAlign == AlignRight {\n\t\t\tx = rightLimit - buttonsWidth\n\t\t} else if f.buttonsAlign == AlignCenter {\n\t\t\tx = (x + rightLimit - buttonsWidth) / 2\n\t\t}\n\n\t\t// In vertical layouts, buttons always appear after an empty line.\n\t\tif f.itemPadding == 0 {\n\t\t\ty++\n\t\t}\n\t}\n\n\t// Calculate positions of buttons.\n\tfor index, button := range f.buttons {\n\t\tspace := rightLimit - x\n\t\tbuttonWidth := buttonWidths[index]\n\t\tif f.horizontal {\n\t\t\tif space < buttonWidth-4 {\n\t\t\t\tx = startX\n\t\t\t\ty += lineHeight + 1\n\t\t\t\tspace = width\n\t\t\t\tlineHeight = 1\n\t\t\t}\n\t\t} else {\n\t\t\tif space < 1 {\n\t\t\t\tbreak // No space for this button anymore.\n\t\t\t}\n\t\t}\n\t\tif buttonWidth > space {\n\t\t\tbuttonWidth = space\n\t\t}\n\t\tbutton.SetStyle(f.buttonStyle).\n\t\t\tSetActivatedStyle(f.buttonActivatedStyle).\n\t\t\tSetDisabledStyle(f.buttonDisabledStyle)\n\n\t\tbuttonIndex := index + len(f.items)\n\t\tpositions[buttonIndex].x = x\n\t\tpositions[buttonIndex].y = y\n\t\tpositions[buttonIndex].width = buttonWidth\n\t\tpositions[buttonIndex].height = 1\n\n\t\tif button.HasFocus() {\n\t\t\tfocusedPosition = positions[buttonIndex]\n\t\t}\n\n\t\tx += buttonWidth + 1\n\t}\n\n\t// Determine vertical offset based on the position of the focused item.\n\tvar offset int\n\tif focusedPosition.y+focusedPosition.height > bottomLimit {\n\t\toffset = focusedPosition.y + focusedPosition.height - bottomLimit\n\t\tif focusedPosition.y-offset < topLimit {\n\t\t\toffset = focusedPosition.y - topLimit\n\t\t}\n\t}\n\n\t// Draw items.\n\tfor index, item := range f.items {\n\t\t// Set position.\n\t\ty := positions[index].y - offset\n\t\theight := positions[index].height\n\t\titem.SetRect(positions[index].x, y, positions[index].width, height)\n\n\t\t// Is this item visible?\n\t\tif y+height <= topLimit || y >= bottomLimit {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Draw items with focus last (in case of overlaps).\n\t\tif item.HasFocus() {\n\t\t\tdefer item.Draw(screen)\n\t\t} else {\n\t\t\titem.Draw(screen)\n\t\t}\n\t}\n\n\t// Draw buttons.\n\tfor index, button := range f.buttons {\n\t\t// Set position.\n\t\tbuttonIndex := index + len(f.items)\n\t\ty := positions[buttonIndex].y - offset\n\t\theight := positions[buttonIndex].height\n\t\tbutton.SetRect(positions[buttonIndex].x, y, positions[buttonIndex].width, height)\n\n\t\t// Is this button visible?\n\t\tif y+height <= topLimit || y >= bottomLimit {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Draw button.\n\t\tbutton.Draw(screen)\n\t}\n}\n\n// Focus is called by the application when the primitive receives focus.\nfunc (f *Form) Focus(delegate func(p Primitive)) {\n\t// Hand on the focus to one of our child elements.\n\tif f.focusedElement < 0 || f.focusedElement >= len(f.items)+len(f.buttons) {\n\t\tf.focusedElement = 0\n\t}\n\tvar handler func(key tcell.Key)\n\thandler = func(key tcell.Key) {\n\t\tif key >= 0 {\n\t\t\tf.lastFinishedKey = key\n\t\t}\n\t\tswitch key {\n\t\tcase tcell.KeyTab, tcell.KeyEnter:\n\t\t\tf.focusedElement++\n\t\t\tf.Focus(delegate)\n\t\tcase tcell.KeyBacktab:\n\t\t\tf.focusedElement--\n\t\t\tif f.focusedElement < 0 {\n\t\t\t\tf.focusedElement = len(f.items) + len(f.buttons) - 1\n\t\t\t}\n\t\t\tf.Focus(delegate)\n\t\tcase tcell.KeyEscape:\n\t\t\tif f.cancel != nil {\n\t\t\t\tf.cancel()\n\t\t\t} else {\n\t\t\t\tf.focusedElement = 0\n\t\t\t\tf.Focus(delegate)\n\t\t\t}\n\t\tdefault:\n\t\t\tif key < 0 && f.lastFinishedKey >= 0 {\n\t\t\t\t// Repeat the last action.\n\t\t\t\thandler(f.lastFinishedKey)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Track whether a form item has focus.\n\tvar itemFocused bool\n\tf.hasFocus = false\n\n\t// Set the handler and focus for all items and buttons.\n\tfor index, button := range f.buttons {\n\t\tbutton.SetExitFunc(handler)\n\t\tif f.focusedElement == index+len(f.items) {\n\t\t\tif button.IsDisabled() {\n\t\t\t\tf.focusedElement++\n\t\t\t\tif f.focusedElement >= len(f.items)+len(f.buttons) {\n\t\t\t\t\tf.focusedElement = 0\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\titemFocused = true\n\t\t\tfunc(b *Button) { // Wrapping might not be necessary anymore in future Go versions.\n\t\t\t\tdefer delegate(b)\n\t\t\t}(button)\n\t\t}\n\t}\n\tfor index, item := range f.items {\n\t\titem.SetFinishedFunc(handler)\n\t\tif f.focusedElement == index {\n\t\t\titemFocused = true\n\t\t\tfunc(i FormItem) { // Wrapping might not be necessary anymore in future Go versions.\n\t\t\t\tdefer delegate(i)\n\t\t\t}(item)\n\t\t}\n\t}\n\n\t// If no item was focused, focus the form itself.\n\tif !itemFocused {\n\t\tf.Box.Focus(delegate)\n\t}\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (f *Form) HasFocus() bool {\n\tif f.focusIndex() >= 0 {\n\t\treturn true\n\t}\n\treturn f.Box.HasFocus()\n}\n\n// focusIndex returns the index of the currently focused item, counting form\n// items first, then buttons. A negative value indicates that no containeed item\n// has focus.\nfunc (f *Form) focusIndex() int {\n\tfor index, item := range f.items {\n\t\tif item.HasFocus() {\n\t\t\treturn index\n\t\t}\n\t}\n\tfor index, button := range f.buttons {\n\t\tif button.HasFocus() {\n\t\t\treturn len(f.items) + index\n\t\t}\n\t}\n\treturn -1\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (f *Form) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn f.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\t// At the end, update f.focusedElement and prepare current item/button.\n\t\tdefer func() {\n\t\t\tif consumed {\n\t\t\t\tindex := f.focusIndex()\n\t\t\t\tif index >= 0 {\n\t\t\t\t\tf.focusedElement = index\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// Determine items to pass mouse events to.\n\t\tfor _, item := range f.items {\n\t\t\t// Exclude TextView items from mouse-down events as they are\n\t\t\t// read-only items and thus should not be focused.\n\t\t\tif _, ok := item.(*TextView); ok && action == MouseLeftDown {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconsumed, capture = item.MouseHandler()(action, event, setFocus)\n\t\t\tif consumed {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tfor _, button := range f.buttons {\n\t\t\tconsumed, capture = button.MouseHandler()(action, event, setFocus)\n\t\t\tif consumed {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// A mouse down anywhere else will return the focus to the last selected\n\t\t// element.\n\t\tif action == MouseLeftDown && f.InRect(event.Position()) {\n\t\t\tf.Focus(setFocus)\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (f *Form) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn f.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tfor _, item := range f.items {\n\t\t\tif item != nil && item.HasFocus() {\n\t\t\t\tif handler := item.InputHandler(); handler != nil {\n\t\t\t\t\thandler(event, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor _, button := range f.buttons {\n\t\t\tif button.HasFocus() {\n\t\t\t\tif handler := button.InputHandler(); handler != nil {\n\t\t\t\t\thandler(event, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\n// PasteHandler returns the handler for this primitive.\nfunc (f *Form) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn f.WrapPasteHandler(func(pastedText string, setFocus func(p Primitive)) {\n\t\tfor _, item := range f.items {\n\t\t\tif item != nil && item.HasFocus() {\n\t\t\t\tif handler := item.PasteHandler(); handler != nil {\n\t\t\t\t\thandler(pastedText, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor _, button := range f.buttons {\n\t\t\tif button.HasFocus() {\n\t\t\t\tif handler := button.PasteHandler(); handler != nil {\n\t\t\t\t\thandler(pastedText, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "frame.go",
          "type": "blob",
          "size": 6.10546875,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// frameText holds information about a line of text shown in the frame.\ntype frameText struct {\n\tText   string      // The text to be displayed.\n\tHeader bool        // true = place in header, false = place in footer.\n\tAlign  int         // One of the Align constants.\n\tColor  tcell.Color // The text color.\n}\n\n// Frame is a wrapper which adds space around another primitive. In addition,\n// the top area (header) and the bottom area (footer) may also contain text.\n//\n// See https://github.com/rivo/tview/wiki/Frame for an example.\ntype Frame struct {\n\t*Box\n\n\t// The contained primitive. May be nil.\n\tprimitive Primitive\n\n\t// The lines of text to be displayed.\n\ttext []*frameText\n\n\t// Border spacing.\n\ttop, bottom, header, footer, left, right int\n\n\t// Keep a reference in case we need it when we change the primitive.\n\tsetFocus func(p Primitive)\n}\n\n// NewFrame returns a new frame around the given primitive. The primitive's\n// size will be changed to fit within this frame. The primitive may be nil, in\n// which case no other primitive is embedded in the frame.\nfunc NewFrame(primitive Primitive) *Frame {\n\tbox := NewBox()\n\n\tf := &Frame{\n\t\tBox:       box,\n\t\tprimitive: primitive,\n\t\ttop:       1,\n\t\tbottom:    1,\n\t\theader:    1,\n\t\tfooter:    1,\n\t\tleft:      1,\n\t\tright:     1,\n\t}\n\n\treturn f\n}\n\n// SetPrimitive replaces the contained primitive with the given one. To remove\n// a primitive, set it to nil.\nfunc (f *Frame) SetPrimitive(p Primitive) *Frame {\n\tvar hasFocus bool\n\tif f.primitive != nil {\n\t\thasFocus = f.primitive.HasFocus()\n\t}\n\tf.primitive = p\n\tif hasFocus && f.setFocus != nil {\n\t\tf.setFocus(p) // Restore focus.\n\t}\n\treturn f\n}\n\n// GetPrimitive returns the primitive contained in this frame.\nfunc (f *Frame) GetPrimitive() Primitive {\n\treturn f.primitive\n}\n\n// AddText adds text to the frame. Set \"header\" to true if the text is to appear\n// in the header, above the contained primitive. Set it to false for it to\n// appear in the footer, below the contained primitive. \"align\" must be one of\n// the Align constants. Rows in the header are printed top to bottom, rows in\n// the footer are printed bottom to top. Note that long text can overlap as\n// different alignments will be placed on the same row.\nfunc (f *Frame) AddText(text string, header bool, align int, color tcell.Color) *Frame {\n\tf.text = append(f.text, &frameText{\n\t\tText:   text,\n\t\tHeader: header,\n\t\tAlign:  align,\n\t\tColor:  color,\n\t})\n\treturn f\n}\n\n// Clear removes all text from the frame.\nfunc (f *Frame) Clear() *Frame {\n\tf.text = nil\n\treturn f\n}\n\n// SetBorders sets the width of the frame borders as well as \"header\" and\n// \"footer\", the vertical space between the header and footer text and the\n// contained primitive (does not apply if there is no text).\nfunc (f *Frame) SetBorders(top, bottom, header, footer, left, right int) *Frame {\n\tf.top, f.bottom, f.header, f.footer, f.left, f.right = top, bottom, header, footer, left, right\n\treturn f\n}\n\n// Draw draws this primitive onto the screen.\nfunc (f *Frame) Draw(screen tcell.Screen) {\n\tf.Box.DrawForSubclass(screen, f)\n\n\t// Calculate start positions.\n\tx, top, width, height := f.GetInnerRect()\n\tbottom := top + height - 1\n\tx += f.left\n\ttop += f.top\n\tbottom -= f.bottom\n\twidth -= f.left + f.right\n\tif width <= 0 || top >= bottom {\n\t\treturn // No space left.\n\t}\n\n\t// Draw text.\n\tvar rows [6]int // top-left, top-center, top-right, bottom-left, bottom-center, bottom-right.\n\ttopMax := top\n\tbottomMin := bottom\n\tfor _, text := range f.text {\n\t\t// Where do we place this text?\n\t\tvar y int\n\t\tif text.Header {\n\t\t\ty = top + rows[text.Align]\n\t\t\trows[text.Align]++\n\t\t\tif y >= bottomMin {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif y+1 > topMax {\n\t\t\t\ttopMax = y + 1\n\t\t\t}\n\t\t} else {\n\t\t\ty = bottom - rows[3+text.Align]\n\t\t\trows[3+text.Align]++\n\t\t\tif y <= topMax {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif y-1 < bottomMin {\n\t\t\t\tbottomMin = y - 1\n\t\t\t}\n\t\t}\n\n\t\t// Draw text.\n\t\tPrint(screen, text.Text, x, y, width, text.Align, text.Color)\n\t}\n\n\t// Set the size of the contained primitive.\n\tif f.primitive != nil {\n\t\tif topMax > top {\n\t\t\ttop = topMax + f.header\n\t\t}\n\t\tif bottomMin < bottom {\n\t\t\tbottom = bottomMin - f.footer\n\t\t}\n\t\tif top > bottom {\n\t\t\treturn // No space for the primitive.\n\t\t}\n\t\tf.primitive.SetRect(x, top, width, bottom+1-top)\n\n\t\t// Finally, draw the contained primitive.\n\t\tf.primitive.Draw(screen)\n\t}\n}\n\n// Focus is called when this primitive receives focus.\nfunc (f *Frame) Focus(delegate func(p Primitive)) {\n\tf.setFocus = delegate\n\tif f.primitive != nil {\n\t\tdelegate(f.primitive)\n\t} else {\n\t\tf.Box.Focus(delegate)\n\t}\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (f *Frame) HasFocus() bool {\n\tif f.primitive == nil {\n\t\treturn f.Box.HasFocus()\n\t}\n\treturn f.primitive.HasFocus()\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (f *Frame) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn f.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif !f.InRect(event.Position()) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Pass mouse events on to contained primitive.\n\t\tif f.primitive != nil {\n\t\t\tconsumed, capture = f.primitive.MouseHandler()(action, event, setFocus)\n\t\t\tif consumed {\n\t\t\t\treturn true, capture\n\t\t\t}\n\t\t}\n\n\t\t// Clicking on the frame parts.\n\t\tif action == MouseLeftDown {\n\t\t\tsetFocus(f)\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (f *Frame) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn f.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif f.primitive == nil {\n\t\t\treturn\n\t\t}\n\t\tif handler := f.primitive.InputHandler(); handler != nil {\n\t\t\thandler(event, setFocus)\n\t\t\treturn\n\t\t}\n\t})\n}\n\n// PasteHandler returns the handler for this primitive.\nfunc (f *Frame) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn f.WrapPasteHandler(func(pastedText string, setFocus func(p Primitive)) {\n\t\tif f.primitive == nil {\n\t\t\treturn\n\t\t}\n\t\tif handler := f.primitive.PasteHandler(); handler != nil {\n\t\t\thandler(pastedText, setFocus)\n\t\t\treturn\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.3798828125,
          "content": "module github.com/rivo/tview\n\ngo 1.18\n\nrequire (\n\tgithub.com/gdamore/tcell/v2 v2.7.1\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0\n\tgithub.com/rivo/uniseg v0.4.7\n)\n\nrequire (\n\tgithub.com/gdamore/encoding v1.0.0 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.15 // indirect\n\tgolang.org/x/sys v0.17.0 // indirect\n\tgolang.org/x/term v0.17.0 // indirect\n\tgolang.org/x/text v0.14.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.322265625,
          "content": "github.com/gdamore/encoding v1.0.0 h1:+7OoQ1Bc6eTm5niUzBa0Ctsh6JbMW6Ra+YNuAtDBdko=\ngithub.com/gdamore/encoding v1.0.0/go.mod h1:alR0ol34c49FCSBLjhosxzcPHQbf2trDkoo5dl+VrEg=\ngithub.com/gdamore/tcell/v2 v2.7.1 h1:TiCcmpWHiAU7F0rA2I3S2Y4mmLmO9KHxJ7E1QhYzQbc=\ngithub.com/gdamore/tcell/v2 v2.7.1/go.mod h1:dSXtXTSK0VsW1biw65DZLZ2NKr7j0qP/0J7ONmsraWg=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.3/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0 h1:25cE3gD+tdBA7lp7QfhuV+rJiE9YXTcS3VG1SqssI/Y=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.17.0 h1:mkTF7LCd6WGJNL3K1Ad7kwxNfYAW6a8a8QqtMblp/4U=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "grid.go",
          "type": "blob",
          "size": 20.3427734375,
          "content": "package tview\n\nimport (\n\t\"math\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// gridItem represents one primitive and its possible position on a grid.\ntype gridItem struct {\n\tItem                        Primitive // The item to be positioned. May be nil for an empty item.\n\tRow, Column                 int       // The top-left grid cell where the item is placed.\n\tWidth, Height               int       // The number of rows and columns the item occupies.\n\tMinGridWidth, MinGridHeight int       // The minimum grid width/height for which this item is visible.\n\tFocus                       bool      // Whether or not this item attracts the layout's focus.\n\n\tvisible    bool // Whether or not this item was visible the last time the grid was drawn.\n\tx, y, w, h int  // The last position of the item relative to the top-left corner of the grid. Undefined if visible is false.\n}\n\n// Grid is an implementation of a grid-based layout. It works by defining the\n// size of the rows and columns, then placing primitives into the grid.\n//\n// Some settings can lead to the grid exceeding its available space. SetOffset()\n// can then be used to scroll in steps of rows and columns. These offset values\n// can also be controlled with the arrow keys (or the \"g\",\"G\", \"j\", \"k\", \"h\",\n// and \"l\" keys) while the grid has focus and none of its contained primitives\n// do.\n//\n// See https://github.com/rivo/tview/wiki/Grid for an example.\ntype Grid struct {\n\t*Box\n\n\t// The items to be positioned.\n\titems []*gridItem\n\n\t// The definition of the rows and columns of the grid. See\n\t// [Grid.SetRows] / [Grid.SetColumns] for details.\n\trows, columns []int\n\n\t// The minimum sizes for rows and columns.\n\tminWidth, minHeight int\n\n\t// The size of the gaps between neighboring primitives. This is automatically\n\t// set to 1 if borders is true.\n\tgapRows, gapColumns int\n\n\t// The number of rows and columns skipped before drawing the top-left corner\n\t// of the grid.\n\trowOffset, columnOffset int\n\n\t// Whether or not borders are drawn around grid items. If this is set to true,\n\t// a gap size of 1 is automatically assumed (which is filled with the border\n\t// graphics).\n\tborders bool\n\n\t// The color of the borders around grid items.\n\tbordersColor tcell.Color\n}\n\n// NewGrid returns a new grid-based layout container with no initial primitives.\n//\n// Note that Box, the superclass of Grid, will be transparent so that any grid\n// areas not covered by any primitives will leave their background unchanged. To\n// clear a Grid's background before any items are drawn, reset its Box to one\n// with the desired color:\n//\n//\tgrid.Box = NewBox()\nfunc NewGrid() *Grid {\n\tg := &Grid{\n\t\tbordersColor: Styles.GraphicsColor,\n\t}\n\tg.Box = NewBox()\n\tg.Box.dontClear = true\n\treturn g\n}\n\n// SetColumns defines how the columns of the grid are distributed. Each value\n// defines the size of one column, starting with the leftmost column. Values\n// greater than 0 represent absolute column widths (gaps not included). Values\n// less than or equal to 0 represent proportional column widths or fractions of\n// the remaining free space, where 0 is treated the same as -1. That is, a\n// column with a value of -3 will have three times the width of a column with a\n// value of -1 (or 0). The minimum width set with SetMinSize() is always\n// observed.\n//\n// Primitives may extend beyond the columns defined explicitly with this\n// function. A value of 0 is assumed for any undefined column. In fact, if you\n// never call this function, all columns occupied by primitives will have the\n// same width. On the other hand, unoccupied columns defined with this function\n// will always take their place.\n//\n// Assuming a total width of the grid of 100 cells and a minimum width of 0, the\n// following call will result in columns with widths of 30, 10, 15, 15, and 30\n// cells:\n//\n//\tgrid.SetColumns(30, 10, -1, -1, -2)\n//\n// If a primitive were then placed in the 6th and 7th column, the resulting\n// widths would be: 30, 10, 10, 10, 20, 10, and 10 cells.\n//\n// If you then called SetMinSize() as follows:\n//\n//\tgrid.SetMinSize(15, 20)\n//\n// The resulting widths would be: 30, 15, 15, 15, 20, 15, and 15 cells, a total\n// of 125 cells, 25 cells wider than the available grid width.\nfunc (g *Grid) SetColumns(columns ...int) *Grid {\n\tg.columns = columns\n\treturn g\n}\n\n// SetRows defines how the rows of the grid are distributed. These values behave\n// the same as the column values provided with [Grid.SetColumns], see there\n// for a definition and examples.\n//\n// The provided values correspond to row heights, the first value defining\n// the height of the topmost row.\nfunc (g *Grid) SetRows(rows ...int) *Grid {\n\tg.rows = rows\n\treturn g\n}\n\n// SetSize is a shortcut for [Grid.SetRows] and [Grid.SetColumns] where\n// all row and column values are set to the given size values. See\n// [Grid.SetColumns] for details on sizes.\nfunc (g *Grid) SetSize(numRows, numColumns, rowSize, columnSize int) *Grid {\n\tg.rows = make([]int, numRows)\n\tfor index := range g.rows {\n\t\tg.rows[index] = rowSize\n\t}\n\tg.columns = make([]int, numColumns)\n\tfor index := range g.columns {\n\t\tg.columns[index] = columnSize\n\t}\n\treturn g\n}\n\n// SetMinSize sets an absolute minimum width for rows and an absolute minimum\n// height for columns. Panics if negative values are provided.\nfunc (g *Grid) SetMinSize(row, column int) *Grid {\n\tif row < 0 || column < 0 {\n\t\tpanic(\"Invalid minimum row/column size\")\n\t}\n\tg.minHeight, g.minWidth = row, column\n\treturn g\n}\n\n// SetGap sets the size of the gaps between neighboring primitives on the grid.\n// If borders are drawn (see SetBorders()), these values are ignored and a gap\n// of 1 is assumed. Panics if negative values are provided.\nfunc (g *Grid) SetGap(row, column int) *Grid {\n\tif row < 0 || column < 0 {\n\t\tpanic(\"Invalid gap size\")\n\t}\n\tg.gapRows, g.gapColumns = row, column\n\treturn g\n}\n\n// SetBorders sets whether or not borders are drawn around grid items. Setting\n// this value to true will cause the gap values (see SetGap()) to be ignored and\n// automatically assumed to be 1 where the border graphics are drawn.\nfunc (g *Grid) SetBorders(borders bool) *Grid {\n\tg.borders = borders\n\treturn g\n}\n\n// SetBordersColor sets the color of the item borders.\nfunc (g *Grid) SetBordersColor(color tcell.Color) *Grid {\n\tg.bordersColor = color\n\treturn g\n}\n\n// AddItem adds a primitive and its position to the grid. The top-left corner\n// of the primitive will be located in the top-left corner of the grid cell at\n// the given row and column and will span \"rowSpan\" rows and \"colSpan\" columns.\n// For example, for a primitive to occupy rows 2, 3, and 4 and columns 5 and 6:\n//\n//\tgrid.AddItem(p, 2, 5, 3, 2, 0, 0, true)\n//\n// If rowSpan or colSpan is 0, the primitive will not be drawn.\n//\n// You can add the same primitive multiple times with different grid positions.\n// The minGridWidth and minGridHeight values will then determine which of those\n// positions will be used. This is similar to CSS media queries. These minimum\n// values refer to the overall size of the grid. If multiple items for the same\n// primitive apply, the one with the highest minimum value (width or height,\n// whatever is higher) will be used, or the primitive added last if those values\n// are the same. Example:\n//\n//\tgrid.AddItem(p, 0, 0, 0, 0, 0, 0, true). // Hide in small grids.\n//\t  AddItem(p, 0, 0, 1, 2, 100, 0, true).  // One-column layout for medium grids.\n//\t  AddItem(p, 1, 1, 3, 2, 300, 0, true)   // Multi-column layout for large grids.\n//\n// To use the same grid layout for all sizes, simply set minGridWidth and\n// minGridHeight to 0.\n//\n// If the item's focus is set to true, it will receive focus when the grid\n// receives focus. If there are multiple items with a true focus flag, the last\n// visible one that was added will receive focus.\nfunc (g *Grid) AddItem(p Primitive, row, column, rowSpan, colSpan, minGridHeight, minGridWidth int, focus bool) *Grid {\n\tg.items = append(g.items, &gridItem{\n\t\tItem:          p,\n\t\tRow:           row,\n\t\tColumn:        column,\n\t\tHeight:        rowSpan,\n\t\tWidth:         colSpan,\n\t\tMinGridHeight: minGridHeight,\n\t\tMinGridWidth:  minGridWidth,\n\t\tFocus:         focus,\n\t})\n\treturn g\n}\n\n// RemoveItem removes all items for the given primitive from the grid, keeping\n// the order of the remaining items intact.\nfunc (g *Grid) RemoveItem(p Primitive) *Grid {\n\tfor index := len(g.items) - 1; index >= 0; index-- {\n\t\tif g.items[index].Item == p {\n\t\t\tg.items = append(g.items[:index], g.items[index+1:]...)\n\t\t}\n\t}\n\treturn g\n}\n\n// Clear removes all items from the grid.\nfunc (g *Grid) Clear() *Grid {\n\tg.items = nil\n\treturn g\n}\n\n// SetOffset sets the number of rows and columns which are skipped before\n// drawing the first grid cell in the top-left corner. As the grid will never\n// completely move off the screen, these values may be adjusted the next time\n// the grid is drawn. The actual position of the grid may also be adjusted such\n// that contained primitives that have focus remain visible.\nfunc (g *Grid) SetOffset(rows, columns int) *Grid {\n\tg.rowOffset, g.columnOffset = rows, columns\n\treturn g\n}\n\n// GetOffset returns the current row and column offset (see SetOffset() for\n// details).\nfunc (g *Grid) GetOffset() (rows, columns int) {\n\treturn g.rowOffset, g.columnOffset\n}\n\n// Focus is called when this primitive receives focus.\nfunc (g *Grid) Focus(delegate func(p Primitive)) {\n\tfor _, item := range g.items {\n\t\tif item.Focus {\n\t\t\tdelegate(item.Item)\n\t\t\treturn\n\t\t}\n\t}\n\tg.Box.Focus(delegate)\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (g *Grid) HasFocus() bool {\n\tfor _, item := range g.items {\n\t\tif item.visible && item.Item.HasFocus() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn g.Box.HasFocus()\n}\n\n// Draw draws this primitive onto the screen.\nfunc (g *Grid) Draw(screen tcell.Screen) {\n\tg.Box.DrawForSubclass(screen, g)\n\tx, y, width, height := g.GetInnerRect()\n\tscreenWidth, screenHeight := screen.Size()\n\n\t// Make a list of items which apply.\n\titems := make([]*gridItem, 0, len(g.items))\nItemLoop:\n\tfor _, item := range g.items {\n\t\titem.visible = false\n\t\tif item.Item == nil || item.Width <= 0 || item.Height <= 0 || width < item.MinGridWidth || height < item.MinGridHeight {\n\t\t\tcontinue // Disqualified.\n\t\t}\n\n\t\t// Check for overlaps and multiple layouts of the same item.\n\t\tfor index, existing := range items {\n\t\t\t// Do they overlap or are identical?\n\t\t\tif item.Item != existing.Item &&\n\t\t\t\t(item.Row >= existing.Row+existing.Height || item.Row+item.Height <= existing.Row ||\n\t\t\t\t\titem.Column >= existing.Column+existing.Width || item.Column+item.Width <= existing.Column) {\n\t\t\t\tcontinue // They don't and aren't.\n\t\t\t}\n\n\t\t\t// What's their minimum size?\n\t\t\titemMin := item.MinGridWidth\n\t\t\tif item.MinGridHeight > itemMin {\n\t\t\t\titemMin = item.MinGridHeight\n\t\t\t}\n\t\t\texistingMin := existing.MinGridWidth\n\t\t\tif existing.MinGridHeight > existingMin {\n\t\t\t\texistingMin = existing.MinGridHeight\n\t\t\t}\n\n\t\t\t// Which one is more important?\n\t\t\tif itemMin < existingMin {\n\t\t\t\tcontinue ItemLoop // This one isn't. Drop it.\n\t\t\t}\n\t\t\titems[index] = item // This one is. Replace the other.\n\t\t\tcontinue ItemLoop\n\t\t}\n\n\t\t// This item will be visible.\n\t\titems = append(items, item)\n\t}\n\n\t// How many rows and columns do we have?\n\trows := len(g.rows)\n\tcolumns := len(g.columns)\n\tfor _, item := range items {\n\t\trowEnd := item.Row + item.Height\n\t\tif rowEnd > rows {\n\t\t\trows = rowEnd\n\t\t}\n\t\tcolumnEnd := item.Column + item.Width\n\t\tif columnEnd > columns {\n\t\t\tcolumns = columnEnd\n\t\t}\n\t}\n\tif rows == 0 || columns == 0 {\n\t\treturn // No content.\n\t}\n\n\t// Where are they located?\n\trowPos := make([]int, rows)\n\trowHeight := make([]int, rows)\n\tcolumnPos := make([]int, columns)\n\tcolumnWidth := make([]int, columns)\n\n\t// How much space do we distribute?\n\tremainingWidth := width\n\tremainingHeight := height\n\tproportionalWidth := 0\n\tproportionalHeight := 0\n\tfor index, row := range g.rows {\n\t\tif row > 0 {\n\t\t\tif row < g.minHeight {\n\t\t\t\trow = g.minHeight\n\t\t\t}\n\t\t\tremainingHeight -= row\n\t\t\trowHeight[index] = row\n\t\t} else if row == 0 {\n\t\t\tproportionalHeight++\n\t\t} else {\n\t\t\tproportionalHeight += -row\n\t\t}\n\t}\n\tfor index, column := range g.columns {\n\t\tif column > 0 {\n\t\t\tif column < g.minWidth {\n\t\t\t\tcolumn = g.minWidth\n\t\t\t}\n\t\t\tremainingWidth -= column\n\t\t\tcolumnWidth[index] = column\n\t\t} else if column == 0 {\n\t\t\tproportionalWidth++\n\t\t} else {\n\t\t\tproportionalWidth += -column\n\t\t}\n\t}\n\tif g.borders {\n\t\tremainingHeight -= rows + 1\n\t\tremainingWidth -= columns + 1\n\t} else {\n\t\tremainingHeight -= (rows - 1) * g.gapRows\n\t\tremainingWidth -= (columns - 1) * g.gapColumns\n\t}\n\tif rows > len(g.rows) {\n\t\tproportionalHeight += rows - len(g.rows)\n\t}\n\tif columns > len(g.columns) {\n\t\tproportionalWidth += columns - len(g.columns)\n\t}\n\n\t// Distribute proportional rows/columns.\n\tfor index := 0; index < rows; index++ {\n\t\trow := 0\n\t\tif index < len(g.rows) {\n\t\t\trow = g.rows[index]\n\t\t}\n\t\tif row > 0 {\n\t\t\tcontinue // Not proportional. We already know the width.\n\t\t} else if row == 0 {\n\t\t\trow = 1\n\t\t} else {\n\t\t\trow = -row\n\t\t}\n\t\trowAbs := row * remainingHeight / proportionalHeight\n\t\tremainingHeight -= rowAbs\n\t\tproportionalHeight -= row\n\t\tif rowAbs < g.minHeight {\n\t\t\trowAbs = g.minHeight\n\t\t}\n\t\trowHeight[index] = rowAbs\n\t}\n\tfor index := 0; index < columns; index++ {\n\t\tcolumn := 0\n\t\tif index < len(g.columns) {\n\t\t\tcolumn = g.columns[index]\n\t\t}\n\t\tif column > 0 {\n\t\t\tcontinue // Not proportional. We already know the height.\n\t\t} else if column == 0 {\n\t\t\tcolumn = 1\n\t\t} else {\n\t\t\tcolumn = -column\n\t\t}\n\t\tcolumnAbs := column * remainingWidth / proportionalWidth\n\t\tremainingWidth -= columnAbs\n\t\tproportionalWidth -= column\n\t\tif columnAbs < g.minWidth {\n\t\t\tcolumnAbs = g.minWidth\n\t\t}\n\t\tcolumnWidth[index] = columnAbs\n\t}\n\n\t// Calculate row/column positions.\n\tvar columnX, rowY int\n\tif g.borders {\n\t\tcolumnX++\n\t\trowY++\n\t}\n\tfor index, row := range rowHeight {\n\t\trowPos[index] = rowY\n\t\tgap := g.gapRows\n\t\tif g.borders {\n\t\t\tgap = 1\n\t\t}\n\t\trowY += row + gap\n\t}\n\tfor index, column := range columnWidth {\n\t\tcolumnPos[index] = columnX\n\t\tgap := g.gapColumns\n\t\tif g.borders {\n\t\t\tgap = 1\n\t\t}\n\t\tcolumnX += column + gap\n\t}\n\n\t// Calculate primitive positions.\n\tvar focus *gridItem // The item which has focus.\n\tfor _, item := range items {\n\t\tpx := columnPos[item.Column]\n\t\tpy := rowPos[item.Row]\n\t\tvar pw, ph int\n\t\tfor index := 0; index < item.Height; index++ {\n\t\t\tph += rowHeight[item.Row+index]\n\t\t}\n\t\tfor index := 0; index < item.Width; index++ {\n\t\t\tpw += columnWidth[item.Column+index]\n\t\t}\n\t\tif g.borders {\n\t\t\tpw += item.Width - 1\n\t\t\tph += item.Height - 1\n\t\t} else {\n\t\t\tpw += (item.Width - 1) * g.gapColumns\n\t\t\tph += (item.Height - 1) * g.gapRows\n\t\t}\n\t\titem.x, item.y, item.w, item.h = px, py, pw, ph\n\t\titem.visible = true\n\t\tif item.Item.HasFocus() {\n\t\t\tfocus = item\n\t\t}\n\t}\n\n\t// Calculate screen offsets.\n\tvar offsetX, offsetY int\n\tadd := 1\n\tif !g.borders {\n\t\tadd = g.gapRows\n\t}\n\tfor index, height := range rowHeight {\n\t\tif index >= g.rowOffset {\n\t\t\tbreak\n\t\t}\n\t\toffsetY += height + add\n\t}\n\tif !g.borders {\n\t\tadd = g.gapColumns\n\t}\n\tfor index, width := range columnWidth {\n\t\tif index >= g.columnOffset {\n\t\t\tbreak\n\t\t}\n\t\toffsetX += width + add\n\t}\n\n\t// The focused item must be within the visible area.\n\tif focus != nil {\n\t\tif focus.y+focus.h-offsetY >= height {\n\t\t\toffsetY = focus.y - height + focus.h\n\t\t}\n\t\tif focus.y-offsetY < 0 {\n\t\t\toffsetY = focus.y\n\t\t}\n\t\tif focus.x+focus.w-offsetX >= width {\n\t\t\toffsetX = focus.x - width + focus.w\n\t\t}\n\t\tif focus.x-offsetX < 0 {\n\t\t\toffsetX = focus.x\n\t\t}\n\t}\n\n\t// Adjust row/column offsets based on this value.\n\tvar from, to int\n\tfor index, pos := range rowPos {\n\t\tif pos-offsetY < 0 {\n\t\t\tfrom = index + 1\n\t\t}\n\t\tif pos-offsetY < height {\n\t\t\tto = index\n\t\t}\n\t}\n\tif g.rowOffset < from {\n\t\tg.rowOffset = from\n\t}\n\tif g.rowOffset > to {\n\t\tg.rowOffset = to\n\t}\n\tfrom, to = 0, 0\n\tfor index, pos := range columnPos {\n\t\tif pos-offsetX < 0 {\n\t\t\tfrom = index + 1\n\t\t}\n\t\tif pos-offsetX < width {\n\t\t\tto = index\n\t\t}\n\t}\n\tif g.columnOffset < from {\n\t\tg.columnOffset = from\n\t}\n\tif g.columnOffset > to {\n\t\tg.columnOffset = to\n\t}\n\n\t// Draw primitives and borders.\n\tborderStyle := tcell.StyleDefault.Background(g.backgroundColor).Foreground(g.bordersColor)\n\tfor _, item := range items {\n\t\t// Final primitive position.\n\t\tif !item.visible {\n\t\t\tcontinue\n\t\t}\n\t\titem.x -= offsetX\n\t\titem.y -= offsetY\n\t\tif item.x >= width || item.x+item.w <= 0 || item.y >= height || item.y+item.h <= 0 {\n\t\t\titem.visible = false\n\t\t\tcontinue\n\t\t}\n\t\tif item.x+item.w > width {\n\t\t\titem.w = width - item.x\n\t\t}\n\t\tif item.y+item.h > height {\n\t\t\titem.h = height - item.y\n\t\t}\n\t\tif item.x < 0 {\n\t\t\titem.w += item.x\n\t\t\titem.x = 0\n\t\t}\n\t\tif item.y < 0 {\n\t\t\titem.h += item.y\n\t\t\titem.y = 0\n\t\t}\n\t\tif item.w <= 0 || item.h <= 0 {\n\t\t\titem.visible = false\n\t\t\tcontinue\n\t\t}\n\t\titem.x += x\n\t\titem.y += y\n\t\titem.Item.SetRect(item.x, item.y, item.w, item.h)\n\n\t\t// Draw primitive.\n\t\tif item == focus {\n\t\t\tdefer item.Item.Draw(screen)\n\t\t} else {\n\t\t\titem.Item.Draw(screen)\n\t\t}\n\n\t\t// Draw border around primitive.\n\t\tif g.borders {\n\t\t\tfor bx := item.x; bx < item.x+item.w; bx++ { // Top/bottom lines.\n\t\t\t\tif bx < 0 || bx >= screenWidth {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tby := item.y - 1\n\t\t\t\tif by >= 0 && by < screenHeight {\n\t\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.Horizontal, borderStyle)\n\t\t\t\t}\n\t\t\t\tby = item.y + item.h\n\t\t\t\tif by >= 0 && by < screenHeight {\n\t\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.Horizontal, borderStyle)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor by := item.y; by < item.y+item.h; by++ { // Left/right lines.\n\t\t\t\tif by < 0 || by >= screenHeight {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbx := item.x - 1\n\t\t\t\tif bx >= 0 && bx < screenWidth {\n\t\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.Vertical, borderStyle)\n\t\t\t\t}\n\t\t\t\tbx = item.x + item.w\n\t\t\t\tif bx >= 0 && bx < screenWidth {\n\t\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.Vertical, borderStyle)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbx, by := item.x-1, item.y-1 // Top-left corner.\n\t\t\tif bx >= 0 && bx < screenWidth && by >= 0 && by < screenHeight {\n\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.TopLeft, borderStyle)\n\t\t\t}\n\t\t\tbx, by = item.x+item.w, item.y-1 // Top-right corner.\n\t\t\tif bx >= 0 && bx < screenWidth && by >= 0 && by < screenHeight {\n\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.TopRight, borderStyle)\n\t\t\t}\n\t\t\tbx, by = item.x-1, item.y+item.h // Bottom-left corner.\n\t\t\tif bx >= 0 && bx < screenWidth && by >= 0 && by < screenHeight {\n\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.BottomLeft, borderStyle)\n\t\t\t}\n\t\t\tbx, by = item.x+item.w, item.y+item.h // Bottom-right corner.\n\t\t\tif bx >= 0 && bx < screenWidth && by >= 0 && by < screenHeight {\n\t\t\t\tPrintJoinedSemigraphics(screen, bx, by, Borders.BottomRight, borderStyle)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (g *Grid) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn g.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif !g.InRect(event.Position()) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Pass mouse events along to the first child item that takes it.\n\t\tfor _, item := range g.items {\n\t\t\tif item.Item == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconsumed, capture = item.Item.MouseHandler()(action, event, setFocus)\n\t\t\tif consumed {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t})\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (g *Grid) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn g.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif !g.hasFocus {\n\t\t\t// Pass event on to child primitive.\n\t\t\tfor _, item := range g.items {\n\t\t\t\tif item != nil && item.Item.HasFocus() {\n\t\t\t\t\tif handler := item.Item.InputHandler(); handler != nil {\n\t\t\t\t\t\thandler(event, setFocus)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// Process our own key events if we have direct focus.\n\t\tswitch event.Key() {\n\t\tcase tcell.KeyRune:\n\t\t\tswitch event.Rune() {\n\t\t\tcase 'g':\n\t\t\t\tg.rowOffset, g.columnOffset = 0, 0\n\t\t\tcase 'G':\n\t\t\t\tg.rowOffset = math.MaxInt32\n\t\t\tcase 'j':\n\t\t\t\tg.rowOffset++\n\t\t\tcase 'k':\n\t\t\t\tg.rowOffset--\n\t\t\tcase 'h':\n\t\t\t\tg.columnOffset--\n\t\t\tcase 'l':\n\t\t\t\tg.columnOffset++\n\t\t\t}\n\t\tcase tcell.KeyHome:\n\t\t\tg.rowOffset, g.columnOffset = 0, 0\n\t\tcase tcell.KeyEnd:\n\t\t\tg.rowOffset = math.MaxInt32\n\t\tcase tcell.KeyUp:\n\t\t\tg.rowOffset--\n\t\tcase tcell.KeyDown:\n\t\t\tg.rowOffset++\n\t\tcase tcell.KeyLeft:\n\t\t\tg.columnOffset--\n\t\tcase tcell.KeyRight:\n\t\t\tg.columnOffset++\n\t\t}\n\t})\n}\n\n// PasteHandler returns the handler for this primitive.\nfunc (g *Grid) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn g.WrapPasteHandler(func(pastedText string, setFocus func(p Primitive)) {\n\t\tfor _, item := range g.items {\n\t\t\tif item != nil && item.Item.HasFocus() {\n\t\t\t\tif handler := item.Item.PasteHandler(); handler != nil {\n\t\t\t\t\thandler(pastedText, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "image.go",
          "type": "blob",
          "size": 24.638671875,
          "content": "package tview\n\nimport (\n\t\"image\"\n\t\"math\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Types of dithering applied to images.\nconst (\n\tDitheringNone           = iota // No dithering.\n\tDitheringFloydSteinberg        // Floyd-Steinberg dithering (the default).\n)\n\n// The number of colors supported by true color terminals (R*G*B = 256*256*256).\nconst TrueColor = 16777216\n\n// This map describes what each block element looks like. A 1 bit represents a\n// pixel that is drawn, a 0 bit represents a pixel that is not drawn. The least\n// significant bit is the top left pixel, the most significant bit is the bottom\n// right pixel, moving row by row from left to right, top to bottom.\nvar blockElements = map[rune]uint64{\n\tBlockLowerOneEighthBlock:            0b1111111100000000000000000000000000000000000000000000000000000000,\n\tBlockLowerOneQuarterBlock:           0b1111111111111111000000000000000000000000000000000000000000000000,\n\tBlockLowerThreeEighthsBlock:         0b1111111111111111111111110000000000000000000000000000000000000000,\n\tBlockLowerHalfBlock:                 0b1111111111111111111111111111111100000000000000000000000000000000,\n\tBlockLowerFiveEighthsBlock:          0b1111111111111111111111111111111111111111000000000000000000000000,\n\tBlockLowerThreeQuartersBlock:        0b1111111111111111111111111111111111111111111111110000000000000000,\n\tBlockLowerSevenEighthsBlock:         0b1111111111111111111111111111111111111111111111111111111100000000,\n\tBlockLeftSevenEighthsBlock:          0b0111111101111111011111110111111101111111011111110111111101111111,\n\tBlockLeftThreeQuartersBlock:         0b0011111100111111001111110011111100111111001111110011111100111111,\n\tBlockLeftFiveEighthsBlock:           0b0001111100011111000111110001111100011111000111110001111100011111,\n\tBlockLeftHalfBlock:                  0b0000111100001111000011110000111100001111000011110000111100001111,\n\tBlockLeftThreeEighthsBlock:          0b0000011100000111000001110000011100000111000001110000011100000111,\n\tBlockLeftOneQuarterBlock:            0b0000001100000011000000110000001100000011000000110000001100000011,\n\tBlockLeftOneEighthBlock:             0b0000000100000001000000010000000100000001000000010000000100000001,\n\tBlockQuadrantLowerLeft:              0b0000111100001111000011110000111100000000000000000000000000000000,\n\tBlockQuadrantLowerRight:             0b1111000011110000111100001111000000000000000000000000000000000000,\n\tBlockQuadrantUpperLeft:              0b0000000000000000000000000000000000001111000011110000111100001111,\n\tBlockQuadrantUpperRight:             0b0000000000000000000000000000000011110000111100001111000011110000,\n\tBlockQuadrantUpperLeftAndLowerRight: 0b1111000011110000111100001111000000001111000011110000111100001111,\n}\n\n// pixel represents a character on screen used to draw part of an image.\ntype pixel struct {\n\tstyle   tcell.Style\n\telement rune // The block element.\n}\n\n// Image implements a widget that displays one image. The original image\n// (specified with [Image.SetImage]) is resized according to the specified size\n// (see [Image.SetSize]), using the specified number of colors (see\n// [Image.SetColors]), while applying dithering if necessary (see\n// [Image.SetDithering]).\n//\n// Images are approximated by graphical characters in the terminal. The\n// resolution is therefore limited by the number and type of characters that can\n// be drawn in the terminal and the colors available in the terminal. The\n// quality of the final image also depends on the terminal's font and spacing\n// settings, none of which are under the control of this package. Results may\n// vary.\ntype Image struct {\n\t*Box\n\n\t// The image to be displayed. If nil, the widget will be empty.\n\timage image.Image\n\n\t// The size of the image. If a value is 0, the corresponding size is chosen\n\t// automatically based on the other size while preserving the image's aspect\n\t// ratio. If both are 0, the image uses as much space as possible. A\n\t// negative value represents a percentage, e.g. -50 means 50% of the\n\t// available space.\n\twidth, height int\n\n\t// The number of colors to use. If 0, the number of colors is chosen based\n\t// on the terminal's capabilities.\n\tcolors int\n\n\t// The dithering algorithm to use, one of the constants starting with\n\t// \"ImageDithering\".\n\tdithering int\n\n\t// The width of a terminal's cell divided by its height.\n\taspectRatio float64\n\n\t// Horizontal and vertical alignment, one of the \"Align\" constants.\n\talignHorizontal, alignVertical int\n\n\t// The text to be displayed before the image.\n\tlabel string\n\n\t// The label style.\n\tlabelStyle tcell.Style\n\n\t// The screen width of the label area. A value of 0 means use the width of\n\t// the label text.\n\tlabelWidth int\n\n\t// The actual image size (in cells) when it was drawn the last time.\n\tlastWidth, lastHeight int\n\n\t// The actual image (in cells) when it was drawn the last time. The size of\n\t// this slice is lastWidth * lastHeight, indexed by y*lastWidth + x.\n\tpixels []pixel\n\n\t// A callback function set by the Form class and called when the user leaves\n\t// this form item.\n\tfinished func(tcell.Key)\n}\n\n// NewImage returns a new image widget with an empty image (use [Image.SetImage]\n// to specify the image to be displayed). The image will use the widget's entire\n// available space. The dithering algorithm is set to Floyd-Steinberg dithering.\n// The terminal's cell aspect ratio defaults to 0.5.\nfunc NewImage() *Image {\n\treturn &Image{\n\t\tBox:             NewBox(),\n\t\tdithering:       DitheringFloydSteinberg,\n\t\taspectRatio:     0.5,\n\t\talignHorizontal: AlignCenter,\n\t\talignVertical:   AlignCenter,\n\t}\n}\n\n// SetImage sets the image to be displayed. If nil, the widget will be empty.\nfunc (i *Image) SetImage(image image.Image) *Image {\n\ti.image = image\n\ti.lastWidth, i.lastHeight = 0, 0\n\treturn i\n}\n\n// SetSize sets the size of the image. Positive values refer to cells in the\n// terminal. Negative values refer to a percentage of the available space (e.g.\n// -50 means 50%). A value of 0 means that the corresponding size is chosen\n// automatically based on the other size while preserving the image's aspect\n// ratio. If both are 0, the image uses as much space as possible while still\n// preserving the aspect ratio.\nfunc (i *Image) SetSize(rows, columns int) *Image {\n\ti.width = columns\n\ti.height = rows\n\treturn i\n}\n\n// SetColors sets the number of colors to use. This should be the number of\n// colors supported by the terminal. If 0, the number of colors is chosen based\n// on the TERM environment variable (which may or may not be reliable).\n//\n// Only the values 0, 2, 8, 256, and 16777216 ([TrueColor]) are supported. Other\n// values will be rounded up to the next supported value, to a maximum of\n// 16777216.\n//\n// The effect of using more colors than supported by the terminal is undefined.\nfunc (i *Image) SetColors(colors int) *Image {\n\ti.colors = colors\n\ti.lastWidth, i.lastHeight = 0, 0\n\treturn i\n}\n\n// GetColors returns the number of colors that will be used while drawing the\n// image. This is one of the values listed in [Image.SetColors], except 0 which\n// will be replaced by the actual number of colors used.\nfunc (i *Image) GetColors() int {\n\tswitch {\n\tcase i.colors == 0:\n\t\treturn availableColors\n\tcase i.colors <= 2:\n\t\treturn 2\n\tcase i.colors <= 8:\n\t\treturn 8\n\tcase i.colors <= 256:\n\t\treturn 256\n\t}\n\treturn TrueColor\n}\n\n// SetDithering sets the dithering algorithm to use, one of the constants\n// starting with \"Dithering\", for example [DitheringFloydSteinberg] (the\n// default). Dithering is not applied when rendering in true-color.\nfunc (i *Image) SetDithering(dithering int) *Image {\n\ti.dithering = dithering\n\ti.lastWidth, i.lastHeight = 0, 0\n\treturn i\n}\n\n// SetAspectRatio sets the width of a terminal's cell divided by its height.\n// You may change the default of 0.5 if your terminal / font has a different\n// aspect ratio. This is used to calculate the size of the image if the\n// specified width or height is 0. The function will panic if the aspect ratio\n// is 0 or less.\nfunc (i *Image) SetAspectRatio(aspectRatio float64) *Image {\n\tif aspectRatio <= 0 {\n\t\tpanic(\"aspect ratio must be greater than 0\")\n\t}\n\ti.aspectRatio = aspectRatio\n\ti.lastWidth, i.lastHeight = 0, 0\n\treturn i\n}\n\n// SetAlign sets the vertical and horizontal alignment of the image within the\n// widget's space. The possible values are [AlignTop], [AlignCenter], and\n// [AlignBottom] for vertical alignment and [AlignLeft], [AlignCenter], and\n// [AlignRight] for horizontal alignment. The default is [AlignCenter] for both\n// (or [AlignTop] and [AlignLeft] if the image is part of a [Form]).\nfunc (i *Image) SetAlign(vertical, horizontal int) *Image {\n\ti.alignHorizontal = horizontal\n\ti.alignVertical = vertical\n\treturn i\n}\n\n// SetLabel sets the text to be displayed before the image.\nfunc (i *Image) SetLabel(label string) *Image {\n\ti.label = label\n\treturn i\n}\n\n// GetLabel returns the text to be displayed before the image.\nfunc (i *Image) GetLabel() string {\n\treturn i.label\n}\n\n// SetLabelWidth sets the screen width of the label. A value of 0 will cause the\n// primitive to use the width of the label string.\nfunc (i *Image) SetLabelWidth(width int) *Image {\n\ti.labelWidth = width\n\treturn i\n}\n\n// GetFieldWidth returns this primitive's field width. This is the image's width\n// or, if the width is 0 or less, the proportional width of the image based on\n// its height as returned by [Image.GetFieldHeight]. If there is no image, 0 is\n// returned.\nfunc (i *Image) GetFieldWidth() int {\n\tif i.width <= 0 {\n\t\tif i.image == nil {\n\t\t\treturn 0\n\t\t}\n\t\tbounds := i.image.Bounds()\n\t\theight := i.GetFieldHeight()\n\t\treturn bounds.Dx() * height / bounds.Dy()\n\t}\n\treturn i.width\n}\n\n// GetFieldHeight returns this primitive's field height. This is the image's\n// height or 8 if the height is 0 or less.\nfunc (i *Image) GetFieldHeight() int {\n\tif i.height <= 0 {\n\t\treturn 8\n\t}\n\treturn i.height\n}\n\n// SetDisabled sets whether or not the item is disabled / read-only.\nfunc (i *Image) SetDisabled(disabled bool) FormItem {\n\treturn i // Images are always read-only.\n}\n\n// SetFormAttributes sets attributes shared by all form items.\nfunc (i *Image) SetFormAttributes(labelWidth int, labelColor, bgColor, fieldTextColor, fieldBgColor tcell.Color) FormItem {\n\ti.labelWidth = labelWidth\n\ti.backgroundColor = bgColor\n\ti.SetLabelStyle(tcell.StyleDefault.Foreground(labelColor).Background(bgColor))\n\ti.lastWidth, i.lastHeight = 0, 0\n\treturn i\n}\n\n// SetLabelStyle sets the style of the label.\nfunc (i *Image) SetLabelStyle(style tcell.Style) *Image {\n\ti.labelStyle = style\n\treturn i\n}\n\n// GetLabelStyle returns the style of the label.\nfunc (i *Image) GetLabelStyle() tcell.Style {\n\treturn i.labelStyle\n}\n\n// SetFinishedFunc sets a callback invoked when the user leaves this form item.\nfunc (i *Image) SetFinishedFunc(handler func(key tcell.Key)) FormItem {\n\ti.finished = handler\n\treturn i\n}\n\n// Focus is called when this primitive receives focus.\nfunc (i *Image) Focus(delegate func(p Primitive)) {\n\t// If we're part of a form, there's nothing the user can do here so we're\n\t// finished.\n\tif i.finished != nil {\n\t\ti.finished(-1)\n\t\treturn\n\t}\n\n\ti.Box.Focus(delegate)\n}\n\n// render re-populates the [Image.pixels] slice based on the current settings,\n// if [Image.lastWidth] and [Image.lastHeight] don't match the current image's\n// size. It also sets the new image size in these two variables.\nfunc (i *Image) render() {\n\t// If there is no image, there are no pixels.\n\tif i.image == nil {\n\t\ti.pixels = nil\n\t\treturn\n\t}\n\n\t// Calculate the new (terminal-space) image size.\n\tbounds := i.image.Bounds()\n\timageWidth, imageHeight := bounds.Dx(), bounds.Dy()\n\tif i.aspectRatio != 1.0 {\n\t\timageWidth = int(float64(imageWidth) / i.aspectRatio)\n\t}\n\twidth, height := i.width, i.height\n\t_, _, innerWidth, innerHeight := i.GetInnerRect()\n\tif i.labelWidth > 0 {\n\t\tinnerWidth -= i.labelWidth\n\t} else {\n\t\tinnerWidth -= TaggedStringWidth(i.label)\n\t}\n\tif innerWidth <= 0 {\n\t\ti.pixels = nil\n\t\treturn\n\t}\n\tif width == 0 && height == 0 {\n\t\t// Use all available space.\n\t\twidth, height = innerWidth, innerHeight\n\t\tif adjustedWidth := imageWidth * height / imageHeight; adjustedWidth < width {\n\t\t\twidth = adjustedWidth\n\t\t} else {\n\t\t\theight = imageHeight * width / imageWidth\n\t\t}\n\t} else {\n\t\t// Turn percentages into absolute values.\n\t\tif width < 0 {\n\t\t\twidth = innerWidth * -width / 100\n\t\t}\n\t\tif height < 0 {\n\t\t\theight = innerHeight * -height / 100\n\t\t}\n\t\tif width == 0 {\n\t\t\t// Adjust the width.\n\t\t\twidth = imageWidth * height / imageHeight\n\t\t} else if height == 0 {\n\t\t\t// Adjust the height.\n\t\t\theight = imageHeight * width / imageWidth\n\t\t}\n\t}\n\tif width <= 0 || height <= 0 {\n\t\ti.pixels = nil\n\t\treturn\n\t}\n\n\t// If nothing has changed, we're done.\n\tif i.lastWidth == width && i.lastHeight == height {\n\t\treturn\n\t}\n\ti.lastWidth, i.lastHeight = width, height // This could still be larger than the available space but that's ok for now.\n\n\t// Generate the initial pixels by resizing the image (8x8 per cell).\n\tpixels := i.resize()\n\n\t// Turn them into block elements with background/foreground colors.\n\ti.stamp(pixels)\n}\n\n// resize resizes the image to the current size and returns the result as a\n// slice of pixels. It is assumed that [Image.lastWidth] (w) and\n// [Image.lastHeight] (h) are positive, non-zero values, and the slice has a\n// size of 64*w*h, with each pixel being represented by 3 float64 values in the\n// range of 0-1. The factor of 64 is due to the fact that we calculate 8x8\n// pixels per cell.\nfunc (i *Image) resize() [][3]float64 {\n\t// Because most of the time, we will be downsizing the image, we don't even\n\t// attempt to do any fancy interpolation. For each target pixel, we\n\t// calculate a weighted average of the source pixels using their coverage\n\t// area.\n\n\tbounds := i.image.Bounds()\n\tsrcWidth, srcHeight := bounds.Dx(), bounds.Dy()\n\ttgtWidth, tgtHeight := i.lastWidth*8, i.lastHeight*8\n\tcoverageWidth, coverageHeight := float64(tgtWidth)/float64(srcWidth), float64(tgtHeight)/float64(srcHeight)\n\tpixels := make([][3]float64, tgtWidth*tgtHeight)\n\tweights := make([]float64, tgtWidth*tgtHeight)\n\tfor srcY := bounds.Min.Y; srcY < bounds.Max.Y; srcY++ {\n\t\tfor srcX := bounds.Min.X; srcX < bounds.Max.X; srcX++ {\n\t\t\tr32, g32, b32, _ := i.image.At(srcX, srcY).RGBA()\n\t\t\tr, g, b := float64(r32)/0xffff, float64(g32)/0xffff, float64(b32)/0xffff\n\n\t\t\t// Iterate over all target pixels. Outer loop is Y.\n\t\t\tstartY := float64(srcY-bounds.Min.Y) * coverageHeight\n\t\t\tendY := startY + coverageHeight\n\t\t\tfromY, toY := int(startY), int(endY)\n\t\t\tfor tgtY := fromY; tgtY <= toY && tgtY < tgtHeight; tgtY++ {\n\t\t\t\tcoverageY := 1.0\n\t\t\t\tif tgtY == fromY {\n\t\t\t\t\tcoverageY -= math.Mod(startY, 1.0)\n\t\t\t\t}\n\t\t\t\tif tgtY == toY {\n\t\t\t\t\tcoverageY -= 1.0 - math.Mod(endY, 1.0)\n\t\t\t\t}\n\n\t\t\t\t// Inner loop is X.\n\t\t\t\tstartX := float64(srcX-bounds.Min.X) * coverageWidth\n\t\t\t\tendX := startX + coverageWidth\n\t\t\t\tfromX, toX := int(startX), int(endX)\n\t\t\t\tfor tgtX := fromX; tgtX <= toX && tgtX < tgtWidth; tgtX++ {\n\t\t\t\t\tcoverageX := 1.0\n\t\t\t\t\tif tgtX == fromX {\n\t\t\t\t\t\tcoverageX -= math.Mod(startX, 1.0)\n\t\t\t\t\t}\n\t\t\t\t\tif tgtX == toX {\n\t\t\t\t\t\tcoverageX -= 1.0 - math.Mod(endX, 1.0)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add a weighted contribution to the target pixel.\n\t\t\t\t\tindex := tgtY*tgtWidth + tgtX\n\t\t\t\t\tcoverage := coverageX * coverageY\n\t\t\t\t\tpixels[index][0] += r * coverage\n\t\t\t\t\tpixels[index][1] += g * coverage\n\t\t\t\t\tpixels[index][2] += b * coverage\n\t\t\t\t\tweights[index] += coverage\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize the pixels.\n\tfor index, weight := range weights {\n\t\tif weight > 0 {\n\t\t\tpixels[index][0] /= weight\n\t\t\tpixels[index][1] /= weight\n\t\t\tpixels[index][2] /= weight\n\t\t}\n\t}\n\n\treturn pixels\n}\n\n// stamp takes the pixels generated by [Image.resize] and populates the\n// [Image.pixels] slice accordingly.\nfunc (i *Image) stamp(resized [][3]float64) {\n\t// For each 8x8 pixel block, we find the best block element to represent it,\n\t// given the available colors.\n\ti.pixels = make([]pixel, i.lastWidth*i.lastHeight)\n\tcolors := i.GetColors()\n\tfor row := 0; row < i.lastHeight; row++ {\n\t\tfor col := 0; col < i.lastWidth; col++ {\n\t\t\t// Calculate an error for each potential block element + color. Keep\n\t\t\t// the one with the lowest error.\n\n\t\t\t// Note that the values in \"resize\" may lie outside [0, 1] due to\n\t\t\t// the error distribution during dithering.\n\n\t\t\tminMSE := math.MaxFloat64 // Mean squared error.\n\t\t\tvar final [64][3]float64  // The final pixel values.\n\t\t\tfor element, bits := range blockElements {\n\t\t\t\t// Calculate the average color for the pixels covered by the set\n\t\t\t\t// bits and unset bits.\n\t\t\t\tvar (\n\t\t\t\t\tbg, fg  [3]float64\n\t\t\t\t\tsetBits float64\n\t\t\t\t\tbit     uint64 = 1\n\t\t\t\t)\n\t\t\t\tfor y := 0; y < 8; y++ {\n\t\t\t\t\tfor x := 0; x < 8; x++ {\n\t\t\t\t\t\tindex := (row*8+y)*i.lastWidth*8 + (col*8 + x)\n\t\t\t\t\t\tif bits&bit != 0 {\n\t\t\t\t\t\t\tfg[0] += resized[index][0]\n\t\t\t\t\t\t\tfg[1] += resized[index][1]\n\t\t\t\t\t\t\tfg[2] += resized[index][2]\n\t\t\t\t\t\t\tsetBits++\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbg[0] += resized[index][0]\n\t\t\t\t\t\t\tbg[1] += resized[index][1]\n\t\t\t\t\t\t\tbg[2] += resized[index][2]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbit <<= 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\t\tfg[ch] /= setBits\n\t\t\t\t\tif fg[ch] < 0 {\n\t\t\t\t\t\tfg[ch] = 0\n\t\t\t\t\t} else if fg[ch] > 1 {\n\t\t\t\t\t\tfg[ch] = 1\n\t\t\t\t\t}\n\t\t\t\t\tbg[ch] /= 64 - setBits\n\t\t\t\t\tif bg[ch] < 0 {\n\t\t\t\t\t\tbg[ch] = 0\n\t\t\t\t\t}\n\t\t\t\t\tif bg[ch] > 1 {\n\t\t\t\t\t\tbg[ch] = 1\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Quantize to the nearest acceptable color.\n\t\t\t\tfor _, color := range []*[3]float64{&fg, &bg} {\n\t\t\t\t\tif colors == 2 {\n\t\t\t\t\t\t// Monochrome. The following weights correspond better\n\t\t\t\t\t\t// to human perception than the arithmetic mean.\n\t\t\t\t\t\tgray := 0.299*color[0] + 0.587*color[1] + 0.114*color[2]\n\t\t\t\t\t\tif gray < 0.5 {\n\t\t\t\t\t\t\t*color = [3]float64{0, 0, 0}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*color = [3]float64{1, 1, 1}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor index, ch := range color {\n\t\t\t\t\t\t\tswitch {\n\t\t\t\t\t\t\tcase colors == 8:\n\t\t\t\t\t\t\t\t// Colors vary wildly for each terminal. Expect\n\t\t\t\t\t\t\t\t// suboptimal results.\n\t\t\t\t\t\t\t\tif ch < 0.5 {\n\t\t\t\t\t\t\t\t\tcolor[index] = 0\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcolor[index] = 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase colors == 256:\n\t\t\t\t\t\t\t\tcolor[index] = math.Round(ch*6) / 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Calculate the error (and the final pixel values).\n\t\t\t\tvar (\n\t\t\t\t\tmse         float64\n\t\t\t\t\tvalues      [64][3]float64\n\t\t\t\t\tvaluesIndex int\n\t\t\t\t)\n\t\t\t\tbit = 1\n\t\t\t\tfor y := 0; y < 8; y++ {\n\t\t\t\t\tfor x := 0; x < 8; x++ {\n\t\t\t\t\t\tif bits&bit != 0 {\n\t\t\t\t\t\t\tvalues[valuesIndex] = fg\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalues[valuesIndex] = bg\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex := (row*8+y)*i.lastWidth*8 + (col*8 + x)\n\t\t\t\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\t\t\t\terr := resized[index][ch] - values[valuesIndex][ch]\n\t\t\t\t\t\t\tmse += err * err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbit <<= 1\n\t\t\t\t\t\tvaluesIndex++\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Do we have a better match?\n\t\t\t\tif mse < minMSE {\n\t\t\t\t\t// Yes. Save it.\n\t\t\t\t\tminMSE = mse\n\t\t\t\t\tfinal = values\n\t\t\t\t\tindex := row*i.lastWidth + col\n\t\t\t\t\ti.pixels[index].element = element\n\t\t\t\t\ti.pixels[index].style = tcell.StyleDefault.\n\t\t\t\t\t\tForeground(tcell.NewRGBColor(int32(math.Min(255, fg[0]*255)), int32(math.Min(255, fg[1]*255)), int32(math.Min(255, fg[2]*255)))).\n\t\t\t\t\t\tBackground(tcell.NewRGBColor(int32(math.Min(255, bg[0]*255)), int32(math.Min(255, bg[1]*255)), int32(math.Min(255, bg[2]*255))))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if there is a shade block which results in a smaller error.\n\n\t\t\t// What's the overall average color?\n\t\t\tvar avg [3]float64\n\t\t\tfor y := 0; y < 8; y++ {\n\t\t\t\tfor x := 0; x < 8; x++ {\n\t\t\t\t\tindex := (row*8+y)*i.lastWidth*8 + (col*8 + x)\n\t\t\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\t\t\tavg[ch] += resized[index][ch] / 64\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\tif avg[ch] < 0 {\n\t\t\t\t\tavg[ch] = 0\n\t\t\t\t} else if avg[ch] > 1 {\n\t\t\t\t\tavg[ch] = 1\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Quantize and choose shade element.\n\t\t\telement := BlockFullBlock\n\t\t\tvar fg, bg tcell.Color\n\t\t\tshades := []rune{' ', BlockLightShade, BlockMediumShade, BlockDarkShade, BlockFullBlock}\n\t\t\tif colors == 2 {\n\t\t\t\t// Monochrome.\n\t\t\t\tgray := 0.299*avg[0] + 0.587*avg[1] + 0.114*avg[2] // See above for details.\n\t\t\t\tshade := int(math.Round(gray * 4))\n\t\t\t\telement = shades[shade]\n\t\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\t\tavg[ch] = float64(shade) / 4\n\t\t\t\t}\n\t\t\t\tbg = tcell.ColorBlack\n\t\t\t\tfg = tcell.ColorWhite\n\t\t\t} else if colors == TrueColor {\n\t\t\t\t// True color.\n\t\t\t\tfg = tcell.NewRGBColor(int32(math.Min(255, avg[0]*255)), int32(math.Min(255, avg[1]*255)), int32(math.Min(255, avg[2]*255)))\n\t\t\t\tbg = fg\n\t\t\t} else {\n\t\t\t\t// 8 or 256 colors.\n\t\t\t\tsteps := 1.0\n\t\t\t\tif colors == 256 {\n\t\t\t\t\tsteps = 6.0\n\t\t\t\t}\n\t\t\t\tvar (\n\t\t\t\t\tlo, hi, pos [3]float64\n\t\t\t\t\tshade       float64\n\t\t\t\t)\n\t\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\t\tlo[ch] = math.Floor(avg[ch]*steps) / steps\n\t\t\t\t\thi[ch] = math.Ceil(avg[ch]*steps) / steps\n\t\t\t\t\tif r := hi[ch] - lo[ch]; r > 0 {\n\t\t\t\t\t\tpos[ch] = (avg[ch] - lo[ch]) / r\n\t\t\t\t\t\tif math.Abs(pos[ch]-0.5) < math.Abs(shade-0.5) {\n\t\t\t\t\t\t\tshade = pos[ch]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshade = math.Round(shade * 4)\n\t\t\t\telement = shades[int(shade)]\n\t\t\t\tshade /= 4\n\t\t\t\tfor ch := 0; ch < 3; ch++ { // Find the closest channel value.\n\t\t\t\t\tbest := math.Abs(avg[ch] - (lo[ch] + (hi[ch]-lo[ch])*shade)) // Start shade from lo to hi.\n\t\t\t\t\tif value := math.Abs(avg[ch] - (hi[ch] - (hi[ch]-lo[ch])*shade)); value < best {\n\t\t\t\t\t\tbest = value // Swap lo and hi.\n\t\t\t\t\t\tlo[ch], hi[ch] = hi[ch], lo[ch]\n\t\t\t\t\t}\n\t\t\t\t\tif value := math.Abs(avg[ch] - lo[ch]); value < best {\n\t\t\t\t\t\tbest = value // Use lo.\n\t\t\t\t\t\thi[ch] = lo[ch]\n\t\t\t\t\t}\n\t\t\t\t\tif value := math.Abs(avg[ch] - hi[ch]); value < best {\n\t\t\t\t\t\tlo[ch] = hi[ch] // Use hi.\n\t\t\t\t\t}\n\t\t\t\t\tavg[ch] = lo[ch] + (hi[ch]-lo[ch])*shade // Quantize.\n\t\t\t\t}\n\t\t\t\tbg = tcell.NewRGBColor(int32(math.Min(255, lo[0]*255)), int32(math.Min(255, lo[1]*255)), int32(math.Min(255, lo[2]*255)))\n\t\t\t\tfg = tcell.NewRGBColor(int32(math.Min(255, hi[0]*255)), int32(math.Min(255, hi[1]*255)), int32(math.Min(255, hi[2]*255)))\n\t\t\t}\n\n\t\t\t// Calculate the error (and the final pixel values).\n\t\t\tvar (\n\t\t\t\tmse         float64\n\t\t\t\tvalues      [64][3]float64\n\t\t\t\tvaluesIndex int\n\t\t\t)\n\t\t\tfor y := 0; y < 8; y++ {\n\t\t\t\tfor x := 0; x < 8; x++ {\n\t\t\t\t\tindex := (row*8+y)*i.lastWidth*8 + (col*8 + x)\n\t\t\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\t\t\terr := resized[index][ch] - avg[ch]\n\t\t\t\t\t\tmse += err * err\n\t\t\t\t\t}\n\t\t\t\t\tvalues[valuesIndex] = avg\n\t\t\t\t\tvaluesIndex++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Is this shade element better than the block element?\n\t\t\tif mse < minMSE {\n\t\t\t\t// Yes. Save it.\n\t\t\t\tfinal = values\n\t\t\t\tindex := row*i.lastWidth + col\n\t\t\t\ti.pixels[index].element = element\n\t\t\t\ti.pixels[index].style = tcell.StyleDefault.Foreground(fg).Background(bg)\n\t\t\t}\n\n\t\t\t// Apply dithering.\n\t\t\tif colors < TrueColor && i.dithering == DitheringFloydSteinberg {\n\t\t\t\t// The dithering mask determines how the error is distributed.\n\t\t\t\t// Each element has three values: dx, dy, and weight (in 16th).\n\t\t\t\tvar mask = [4][3]int{\n\t\t\t\t\t{1, 0, 7},\n\t\t\t\t\t{-1, 1, 3},\n\t\t\t\t\t{0, 1, 5},\n\t\t\t\t\t{1, 1, 1},\n\t\t\t\t}\n\n\t\t\t\t// We dither the 8x8 block as a 2x2 block, transferring errors\n\t\t\t\t// to its 2x2 neighbors.\n\t\t\t\tfor ch := 0; ch < 3; ch++ {\n\t\t\t\t\tfor y := 0; y < 2; y++ {\n\t\t\t\t\t\tfor x := 0; x < 2; x++ {\n\t\t\t\t\t\t\t// What's the error for this 4x4 block?\n\t\t\t\t\t\t\tvar err float64\n\t\t\t\t\t\t\tfor dy := 0; dy < 4; dy++ {\n\t\t\t\t\t\t\t\tfor dx := 0; dx < 4; dx++ {\n\t\t\t\t\t\t\t\t\terr += (final[(y*4+dy)*8+(x*4+dx)][ch] - resized[(row*8+(y*4+dy))*i.lastWidth*8+(col*8+(x*4+dx))][ch]) / 16\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Distribute it to the 2x2 neighbors.\n\t\t\t\t\t\t\tfor _, dist := range mask {\n\t\t\t\t\t\t\t\tfor dy := 0; dy < 4; dy++ {\n\t\t\t\t\t\t\t\t\tfor dx := 0; dx < 4; dx++ {\n\t\t\t\t\t\t\t\t\t\ttargetX, targetY := (x+dist[0])*4+dx, (y+dist[1])*4+dy\n\t\t\t\t\t\t\t\t\t\tif targetX < 0 || col*8+targetX >= i.lastWidth*8 || targetY < 0 || row*8+targetY >= i.lastHeight*8 {\n\t\t\t\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tresized[(row*8+targetY)*i.lastWidth*8+(col*8+targetX)][ch] -= err * float64(dist[2]) / 16\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Draw draws this primitive onto the screen.\nfunc (i *Image) Draw(screen tcell.Screen) {\n\ti.DrawForSubclass(screen, i)\n\n\t// Regenerate image if necessary.\n\ti.render()\n\n\t// Draw label.\n\tviewX, viewY, viewWidth, viewHeight := i.GetInnerRect()\n\t_, labelBg, _ := i.labelStyle.Decompose()\n\tif i.labelWidth > 0 {\n\t\tlabelWidth := i.labelWidth\n\t\tif labelWidth > viewWidth {\n\t\t\tlabelWidth = viewWidth\n\t\t}\n\t\tprintWithStyle(screen, i.label, viewX, viewY, 0, labelWidth, AlignLeft, i.labelStyle, labelBg == tcell.ColorDefault)\n\t\tviewX += labelWidth\n\t\tviewWidth -= labelWidth\n\t} else {\n\t\t_, _, drawnWidth := printWithStyle(screen, i.label, viewX, viewY, 0, viewWidth, AlignLeft, i.labelStyle, labelBg == tcell.ColorDefault)\n\t\tviewX += drawnWidth\n\t\tviewWidth -= drawnWidth\n\t}\n\n\t// Determine image placement.\n\tx, y, width, height := viewX, viewY, i.lastWidth, i.lastHeight\n\tif i.alignHorizontal == AlignCenter {\n\t\tx += (viewWidth - width) / 2\n\t} else if i.alignHorizontal == AlignRight {\n\t\tx += viewWidth - width\n\t}\n\tif i.alignVertical == AlignCenter {\n\t\ty += (viewHeight - height) / 2\n\t} else if i.alignVertical == AlignBottom {\n\t\ty += viewHeight - height\n\t}\n\n\t// Draw the image.\n\tfor row := 0; row < height; row++ {\n\t\tif y+row < viewY || y+row >= viewY+viewHeight {\n\t\t\tcontinue\n\t\t}\n\t\tfor col := 0; col < width; col++ {\n\t\t\tif x+col < viewX || x+col >= viewX+viewWidth {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tindex := row*width + col\n\t\t\tscreen.SetContent(x+col, y+row, i.pixels[index].element, nil, i.pixels[index].style)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "inputfield.go",
          "type": "blob",
          "size": 22.8896484375,
          "content": "package tview\n\nimport (\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gdamore/tcell/v2\"\n\t\"github.com/rivo/uniseg\"\n)\n\nconst (\n\tAutocompletedNavigate = iota // The user navigated the autocomplete list (using the errow keys).\n\tAutocompletedTab             // The user selected an autocomplete entry using the tab key.\n\tAutocompletedEnter           // The user selected an autocomplete entry using the enter key.\n\tAutocompletedClick           // The user selected an autocomplete entry by clicking the mouse button on it.\n)\n\n// Predefined InputField acceptance functions.\nvar (\n\t// InputFieldInteger accepts integers.\n\tInputFieldInteger = func(text string, ch rune) bool {\n\t\tif text == \"-\" {\n\t\t\treturn true\n\t\t}\n\t\t_, err := strconv.Atoi(text)\n\t\treturn err == nil\n\t}\n\n\t// InputFieldFloat accepts floating-point numbers.\n\tInputFieldFloat = func(text string, ch rune) bool {\n\t\tif text == \"-\" || text == \".\" || text == \"-.\" {\n\t\t\treturn true\n\t\t}\n\t\t_, err := strconv.ParseFloat(text, 64)\n\t\treturn err == nil\n\t}\n\n\t// InputFieldMaxLength returns an input field accept handler which accepts\n\t// input strings up to a given length. Use it like this:\n\t//\n\t//   inputField.SetAcceptanceFunc(InputFieldMaxLength(10)) // Accept up to 10 characters.\n\tInputFieldMaxLength = func(maxLength int) func(text string, ch rune) bool {\n\t\treturn func(text string, ch rune) bool {\n\t\t\treturn len([]rune(text)) <= maxLength\n\t\t}\n\t}\n)\n\n// InputField is a one-line box into which the user can enter text. Use\n// [InputField.SetAcceptanceFunc] to accept or reject input,\n// [InputField.SetChangedFunc] to listen for changes, and\n// [InputField.SetMaskCharacter] to hide input from onlookers (e.g. for password\n// input).\n//\n// The input field also has an optional autocomplete feature. It is initialized\n// by the [InputField.SetAutocompleteFunc] function. For more control over the\n// autocomplete drop-down's behavior, you can also set the\n// [InputField.SetAutocompletedFunc].\n//\n// Navigation and editing is the same as for a [TextArea], with the following\n// exceptions:\n//\n//   - Tab, BackTab, Enter, Escape: Finish editing.\n//\n// Note that while pressing Tab or Enter is intercepted by the input field, it\n// is possible to paste such characters into the input field, possibly resulting\n// in multi-line input. You can use [InputField.SetAcceptanceFunc] to prevent\n// this.\n//\n// If autocomplete functionality is configured:\n//\n//   - Down arrow: Open the autocomplete drop-down.\n//   - Tab, Enter: Select the current autocomplete entry.\n//\n// See https://github.com/rivo/tview/wiki/InputField for an example.\ntype InputField struct {\n\t*Box\n\n\t// The text area providing the core functionality of the input field.\n\ttextArea *TextArea\n\n\t// The screen width of the input area. A value of 0 means extend as much as\n\t// possible.\n\tfieldWidth int\n\n\t// An optional autocomplete function which receives the current text of the\n\t// input field and returns a slice of strings to be displayed in a drop-down\n\t// selection.\n\tautocomplete func(text string) []string\n\n\t// The List object which shows the selectable autocomplete entries. If not\n\t// nil, the list's main texts represent the current autocomplete entries.\n\tautocompleteList      *List\n\tautocompleteListMutex sync.Mutex\n\n\t// The styles of the autocomplete entries.\n\tautocompleteStyles struct {\n\t\tmain       tcell.Style\n\t\tselected   tcell.Style\n\t\tbackground tcell.Color\n\t\tuseTags    bool\n\t}\n\n\t// An optional function which is called when the user selects an\n\t// autocomplete entry. The text and index of the selected entry (within the\n\t// list) is provided, as well as the user action causing the selection (one\n\t// of the \"Autocompleted\" values). The function should return true if the\n\t// autocomplete list should be closed. If nil, the input field will be\n\t// updated automatically when the user navigates the autocomplete list.\n\tautocompleted func(text string, index int, source int) bool\n\n\t// An optional function which may reject the last character that was entered.\n\taccept func(text string, ch rune) bool\n\n\t// An optional function which is called when the input has changed.\n\tchanged func(text string)\n\n\t// An optional function which is called when the user indicated that they\n\t// are done entering text. The key which was pressed is provided (tab,\n\t// shift-tab, enter, or escape).\n\tdone func(tcell.Key)\n\n\t// A callback function set by the Form class and called when the user leaves\n\t// this form item.\n\tfinished func(tcell.Key)\n}\n\n// NewInputField returns a new input field.\nfunc NewInputField() *InputField {\n\ti := &InputField{\n\t\tBox:      NewBox(),\n\t\ttextArea: NewTextArea().SetWrap(false),\n\t}\n\ti.textArea.SetChangedFunc(func() {\n\t\tif i.changed != nil {\n\t\t\ti.changed(i.textArea.GetText())\n\t\t}\n\t}).SetFocusFunc(func() {\n\t\t// Forward focus event to the input field.\n\t\tif i.Box.focus != nil {\n\t\t\ti.Box.focus()\n\t\t}\n\t})\n\ti.textArea.textStyle = tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.PrimaryTextColor)\n\ti.textArea.placeholderStyle = tcell.StyleDefault.Background(Styles.ContrastBackgroundColor).Foreground(Styles.ContrastSecondaryTextColor)\n\ti.autocompleteStyles.main = tcell.StyleDefault.Background(Styles.MoreContrastBackgroundColor).Foreground(Styles.PrimitiveBackgroundColor)\n\ti.autocompleteStyles.selected = tcell.StyleDefault.Background(Styles.PrimaryTextColor).Foreground(Styles.PrimitiveBackgroundColor)\n\ti.autocompleteStyles.background = Styles.MoreContrastBackgroundColor\n\ti.autocompleteStyles.useTags = true\n\treturn i\n}\n\n// SetText sets the current text of the input field. This can be undone by the\n// user. Calling this function will also trigger a \"changed\" event.\nfunc (i *InputField) SetText(text string) *InputField {\n\ti.textArea.Replace(0, i.textArea.GetTextLength(), text)\n\treturn i\n}\n\n// GetText returns the current text of the input field.\nfunc (i *InputField) GetText() string {\n\treturn i.textArea.GetText()\n}\n\n// SetLabel sets the text to be displayed before the input area.\nfunc (i *InputField) SetLabel(label string) *InputField {\n\ti.textArea.SetLabel(label)\n\treturn i\n}\n\n// GetLabel returns the text to be displayed before the input area.\nfunc (i *InputField) GetLabel() string {\n\treturn i.textArea.GetLabel()\n}\n\n// SetLabelWidth sets the screen width of the label. A value of 0 will cause the\n// primitive to use the width of the label string.\nfunc (i *InputField) SetLabelWidth(width int) *InputField {\n\ti.textArea.SetLabelWidth(width)\n\treturn i\n}\n\n// SetPlaceholder sets the text to be displayed when the input text is empty.\nfunc (i *InputField) SetPlaceholder(text string) *InputField {\n\ti.textArea.SetPlaceholder(text)\n\treturn i\n}\n\n// SetLabelColor sets the text color of the label.\nfunc (i *InputField) SetLabelColor(color tcell.Color) *InputField {\n\ti.textArea.SetLabelStyle(i.textArea.GetLabelStyle().Foreground(color))\n\treturn i\n}\n\n// SetLabelStyle sets the style of the label.\nfunc (i *InputField) SetLabelStyle(style tcell.Style) *InputField {\n\ti.textArea.SetLabelStyle(style)\n\treturn i\n}\n\n// GetLabelStyle returns the style of the label.\nfunc (i *InputField) GetLabelStyle() tcell.Style {\n\treturn i.textArea.GetLabelStyle()\n}\n\n// SetFieldBackgroundColor sets the background color of the input area.\nfunc (i *InputField) SetFieldBackgroundColor(color tcell.Color) *InputField {\n\ti.textArea.SetTextStyle(i.textArea.GetTextStyle().Background(color))\n\treturn i\n}\n\n// SetFieldTextColor sets the text color of the input area.\nfunc (i *InputField) SetFieldTextColor(color tcell.Color) *InputField {\n\ti.textArea.SetTextStyle(i.textArea.GetTextStyle().Foreground(color))\n\treturn i\n}\n\n// SetFieldStyle sets the style of the input area (when no placeholder is\n// shown).\nfunc (i *InputField) SetFieldStyle(style tcell.Style) *InputField {\n\ti.textArea.SetTextStyle(style)\n\treturn i\n}\n\n// GetFieldStyle returns the style of the input area (when no placeholder is\n// shown).\nfunc (i *InputField) GetFieldStyle() tcell.Style {\n\treturn i.textArea.GetTextStyle()\n}\n\n// SetPlaceholderTextColor sets the text color of placeholder text.\nfunc (i *InputField) SetPlaceholderTextColor(color tcell.Color) *InputField {\n\ti.textArea.SetPlaceholderStyle(i.textArea.GetPlaceholderStyle().Foreground(color))\n\treturn i\n}\n\n// SetPlaceholderStyle sets the style of the input area (when a placeholder is\n// shown).\nfunc (i *InputField) SetPlaceholderStyle(style tcell.Style) *InputField {\n\ti.textArea.SetPlaceholderStyle(style)\n\treturn i\n}\n\n// GetPlaceholderStyle returns the style of the input area (when a placeholder\n// is shown).\nfunc (i *InputField) GetPlaceholderStyle() tcell.Style {\n\treturn i.textArea.GetPlaceholderStyle()\n}\n\n// SetAutocompleteStyles sets the colors and style of the autocomplete entries.\n// For details, see [List.SetMainTextStyle], [List.SetSelectedStyle], and\n// [Box.SetBackgroundColor].\nfunc (i *InputField) SetAutocompleteStyles(background tcell.Color, main, selected tcell.Style) *InputField {\n\ti.autocompleteStyles.background = background\n\ti.autocompleteStyles.main = main\n\ti.autocompleteStyles.selected = selected\n\treturn i\n}\n\n// SetAutocompleteUseTags sets whether or not the autocomplete entries may\n// contain style tags affecting their appearance. The default is true.\nfunc (i *InputField) SetAutocompleteUseTags(useTags bool) *InputField {\n\ti.autocompleteStyles.useTags = useTags\n\treturn i\n}\n\n// SetFormAttributes sets attributes shared by all form items.\nfunc (i *InputField) SetFormAttributes(labelWidth int, labelColor, bgColor, fieldTextColor, fieldBgColor tcell.Color) FormItem {\n\ti.textArea.SetFormAttributes(labelWidth, labelColor, bgColor, fieldTextColor, fieldBgColor)\n\treturn i\n}\n\n// SetFieldWidth sets the screen width of the input area. A value of 0 means\n// extend as much as possible.\nfunc (i *InputField) SetFieldWidth(width int) *InputField {\n\ti.fieldWidth = width\n\treturn i\n}\n\n// GetFieldWidth returns this primitive's field width.\nfunc (i *InputField) GetFieldWidth() int {\n\treturn i.fieldWidth\n}\n\n// GetFieldHeight returns this primitive's field height.\nfunc (i *InputField) GetFieldHeight() int {\n\treturn 1\n}\n\n// SetDisabled sets whether or not the item is disabled / read-only.\nfunc (i *InputField) SetDisabled(disabled bool) FormItem {\n\ti.textArea.SetDisabled(disabled)\n\tif i.finished != nil {\n\t\ti.finished(-1)\n\t}\n\treturn i\n}\n\n// SetMaskCharacter sets a character that masks user input on a screen. A value\n// of 0 disables masking.\nfunc (i *InputField) SetMaskCharacter(mask rune) *InputField {\n\tif mask == 0 {\n\t\ti.textArea.setTransform(nil)\n\t\treturn i\n\t}\n\tmaskStr := string(mask)\n\tmaskWidth := uniseg.StringWidth(maskStr)\n\ti.textArea.setTransform(func(cluster, rest string, boundaries int) (newCluster string, newBoundaries int) {\n\t\treturn maskStr, maskWidth << uniseg.ShiftWidth\n\t})\n\treturn i\n}\n\n// SetAutocompleteFunc sets an autocomplete callback function which may return\n// strings to be selected from a drop-down based on the current text of the\n// input field. The drop-down appears only if len(entries) > 0. The callback is\n// invoked in this function and whenever the current text changes or when\n// [InputField.Autocomplete] is called. Entries are cleared when the user\n// selects an entry or presses Escape.\nfunc (i *InputField) SetAutocompleteFunc(callback func(currentText string) (entries []string)) *InputField {\n\ti.autocomplete = callback\n\ti.Autocomplete()\n\treturn i\n}\n\n// SetAutocompletedFunc sets a callback function which is invoked when the user\n// selects an entry from the autocomplete drop-down list. The function is passed\n// the text of the selected entry (stripped of any style tags), the index of the\n// entry, and the user action that caused the selection, for example\n// [AutocompletedNavigate]. It returns true if the autocomplete drop-down should\n// be closed after the callback returns or false if it should remain open, in\n// which case [InputField.Autocomplete] is called to update the drop-down's\n// contents.\n//\n// If no such callback is set (or nil is provided), the input field will be\n// updated with the selection any time the user navigates the autocomplete\n// drop-down list. So this function essentially gives you more control over the\n// autocomplete functionality.\nfunc (i *InputField) SetAutocompletedFunc(autocompleted func(text string, index int, source int) bool) *InputField {\n\ti.autocompleted = autocompleted\n\treturn i\n}\n\n// Autocomplete invokes the autocomplete callback (if there is one, see\n// [InputField.SetAutocompleteFunc]). If the length of the returned autocomplete\n// entries slice is greater than 0, the input field will present the user with a\n// corresponding drop-down list the next time the input field is drawn.\n//\n// It is safe to call this function from any goroutine. Note that the input\n// field is not redrawn automatically unless called from the main goroutine\n// (e.g. in response to events).\nfunc (i *InputField) Autocomplete() *InputField {\n\ti.autocompleteListMutex.Lock()\n\tdefer i.autocompleteListMutex.Unlock()\n\tif i.autocomplete == nil {\n\t\treturn i\n\t}\n\n\t// Do we have any autocomplete entries?\n\ttext := i.textArea.GetText()\n\tentries := i.autocomplete(text)\n\tif len(entries) == 0 {\n\t\t// No entries, no list.\n\t\ti.autocompleteList = nil\n\t\treturn i\n\t}\n\n\t// Make a list if we have none.\n\tif i.autocompleteList == nil {\n\t\ti.autocompleteList = NewList()\n\t\ti.autocompleteList.ShowSecondaryText(false).\n\t\t\tSetMainTextStyle(i.autocompleteStyles.main).\n\t\t\tSetSelectedStyle(i.autocompleteStyles.selected).\n\t\t\tSetUseStyleTags(i.autocompleteStyles.useTags, i.autocompleteStyles.useTags).\n\t\t\tSetHighlightFullLine(true).\n\t\t\tSetBackgroundColor(i.autocompleteStyles.background)\n\t}\n\n\t// Fill it with the entries.\n\tcurrentEntry := -1\n\tsuffixLength := math.MaxInt\n\ti.autocompleteList.Clear()\n\tfor index, entry := range entries {\n\t\ti.autocompleteList.AddItem(entry, \"\", 0, nil)\n\t\tif strings.HasPrefix(entry, text) && len(entry)-len(text) < suffixLength {\n\t\t\tcurrentEntry = index\n\t\t\tsuffixLength = len(text) - len(entry)\n\t\t}\n\t}\n\n\t// Set the selection if we have one.\n\tif currentEntry >= 0 {\n\t\ti.autocompleteList.SetCurrentItem(currentEntry)\n\t}\n\n\treturn i\n}\n\n// SetAcceptanceFunc sets a handler which may reject the last character that was\n// entered, by returning false. The handler receives the text as it would be\n// after the change and the last character entered. If the handler is nil, all\n// input is accepted. The function is only called when a single rune is inserted\n// at the current cursor position.\n//\n// This package defines a number of variables prefixed with InputField which may\n// be used for common input (e.g. numbers, maximum text length). See for example\n// [InputFieldInteger].\n//\n// When text is pasted, lastChar is 0.\nfunc (i *InputField) SetAcceptanceFunc(handler func(textToCheck string, lastChar rune) bool) *InputField {\n\ti.accept = handler\n\treturn i\n}\n\n// SetChangedFunc sets a handler which is called whenever the text of the input\n// field has changed. It receives the current text (after the change).\nfunc (i *InputField) SetChangedFunc(handler func(text string)) *InputField {\n\ti.changed = handler\n\treturn i\n}\n\n// SetDoneFunc sets a handler which is called when the user is done entering\n// text. The callback function is provided with the key that was pressed, which\n// is one of the following:\n//\n//   - KeyEnter: Done entering text.\n//   - KeyEscape: Abort text input.\n//   - KeyTab: Move to the next field.\n//   - KeyBacktab: Move to the previous field.\nfunc (i *InputField) SetDoneFunc(handler func(key tcell.Key)) *InputField {\n\ti.done = handler\n\treturn i\n}\n\n// SetFinishedFunc sets a callback invoked when the user leaves this form item.\nfunc (i *InputField) SetFinishedFunc(handler func(key tcell.Key)) FormItem {\n\ti.finished = handler\n\treturn i\n}\n\n// Focus is called when this primitive receives focus.\nfunc (i *InputField) Focus(delegate func(p Primitive)) {\n\t// If we're part of a form and this item is disabled, there's nothing the\n\t// user can do here so we're finished.\n\tif i.finished != nil && i.textArea.GetDisabled() {\n\t\ti.finished(-1)\n\t\treturn\n\t}\n\n\ti.Box.Focus(delegate)\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (i *InputField) HasFocus() bool {\n\treturn i.textArea.HasFocus() || i.Box.HasFocus()\n}\n\n// Blur is called when this primitive loses focus.\nfunc (i *InputField) Blur() {\n\ti.textArea.Blur()\n\ti.Box.Blur()\n\ti.autocompleteList = nil // Hide the autocomplete drop-down.\n}\n\n// Draw draws this primitive onto the screen.\nfunc (i *InputField) Draw(screen tcell.Screen) {\n\ti.Box.DrawForSubclass(screen, i)\n\n\t// Prepare\n\tx, y, width, height := i.GetInnerRect()\n\tif height < 1 || width < 1 {\n\t\treturn\n\t}\n\n\t// Resize text area.\n\tlabelWidth := i.textArea.GetLabelWidth()\n\tif labelWidth == 0 {\n\t\tlabelWidth = TaggedStringWidth(i.textArea.GetLabel())\n\t}\n\tfieldWidth := i.fieldWidth\n\tif fieldWidth == 0 {\n\t\tfieldWidth = width - labelWidth\n\t}\n\ti.textArea.SetRect(x, y, labelWidth+fieldWidth, 1)\n\ti.textArea.setMinCursorPadding(fieldWidth-1, 1)\n\n\t// Draw text area.\n\ti.textArea.hasFocus = i.HasFocus() // Force cursor positioning.\n\ti.textArea.Draw(screen)\n\n\t// Draw autocomplete list.\n\ti.autocompleteListMutex.Lock()\n\tdefer i.autocompleteListMutex.Unlock()\n\tif i.autocompleteList != nil && i.HasFocus() {\n\t\t// How much space do we need?\n\t\tlheight := i.autocompleteList.GetItemCount()\n\t\tlwidth := 0\n\t\tfor index := 0; index < lheight; index++ {\n\t\t\tentry, _ := i.autocompleteList.GetItemText(index)\n\t\t\twidth := TaggedStringWidth(entry)\n\t\t\tif width > lwidth {\n\t\t\t\tlwidth = width\n\t\t\t}\n\t\t}\n\n\t\t// We prefer to drop down but if there is no space, maybe drop up?\n\t\tlx := x + labelWidth\n\t\tly := y + 1\n\t\t_, sheight := screen.Size()\n\t\tif ly+lheight >= sheight && ly-2 > lheight-ly {\n\t\t\tly = y - lheight\n\t\t\tif ly < 0 {\n\t\t\t\tly = 0\n\t\t\t}\n\t\t}\n\t\tif ly+lheight >= sheight {\n\t\t\tlheight = sheight - ly\n\t\t}\n\t\ti.autocompleteList.SetRect(lx, ly, lwidth, lheight)\n\t\ti.autocompleteList.Draw(screen)\n\t}\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (i *InputField) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn i.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif i.textArea.GetDisabled() {\n\t\t\treturn\n\t\t}\n\n\t\t// Trigger changed events.\n\t\tvar skipAutocomplete bool\n\t\tcurrentText := i.textArea.GetText()\n\t\tdefer func() {\n\t\t\tnewText := i.textArea.GetText()\n\t\t\tif newText != currentText {\n\t\t\t\tif !skipAutocomplete {\n\t\t\t\t\ti.Autocomplete()\n\t\t\t\t}\n\t\t\t\tif i.changed != nil {\n\t\t\t\t\ti.changed(newText)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// If we have an autocomplete list, there are certain keys we will\n\t\t// forward to it.\n\t\ti.autocompleteListMutex.Lock()\n\t\tdefer i.autocompleteListMutex.Unlock()\n\t\tif i.autocompleteList != nil {\n\t\t\ti.autocompleteList.SetChangedFunc(nil)\n\t\t\ti.autocompleteList.SetSelectedFunc(nil)\n\t\t\tswitch key := event.Key(); key {\n\t\t\tcase tcell.KeyEscape: // Close the list.\n\t\t\t\ti.autocompleteList = nil\n\t\t\t\treturn\n\t\t\tcase tcell.KeyEnter, tcell.KeyTab: // Intentional selection.\n\t\t\t\tindex := i.autocompleteList.GetCurrentItem()\n\t\t\t\ttext, _ := i.autocompleteList.GetItemText(index)\n\t\t\t\tif i.autocompleted != nil {\n\t\t\t\t\tsource := AutocompletedEnter\n\t\t\t\t\tif key == tcell.KeyTab {\n\t\t\t\t\t\tsource = AutocompletedTab\n\t\t\t\t\t}\n\t\t\t\t\tif i.autocompleted(stripTags(text), index, source) {\n\t\t\t\t\t\ti.autocompleteList = nil\n\t\t\t\t\t\tcurrentText = i.GetText()\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti.SetText(text)\n\t\t\t\t\tskipAutocomplete = true\n\t\t\t\t\ti.autocompleteList = nil\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\tcase tcell.KeyDown, tcell.KeyUp, tcell.KeyPgDn, tcell.KeyPgUp:\n\t\t\t\ti.autocompleteList.SetChangedFunc(func(index int, text, secondaryText string, shortcut rune) {\n\t\t\t\t\ttext = stripTags(text)\n\t\t\t\t\tif i.autocompleted != nil {\n\t\t\t\t\t\tif i.autocompleted(text, index, AutocompletedNavigate) {\n\t\t\t\t\t\t\ti.autocompleteList = nil\n\t\t\t\t\t\t\tcurrentText = i.GetText()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti.SetText(text)\n\t\t\t\t\t\tcurrentText = stripTags(text) // We want to keep the autocomplete list open and unchanged.\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\ti.autocompleteList.InputHandler()(event, setFocus)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Finish up.\n\t\tfinish := func(key tcell.Key) {\n\t\t\tif i.done != nil {\n\t\t\t\ti.done(key)\n\t\t\t}\n\t\t\tif i.finished != nil {\n\t\t\t\ti.finished(key)\n\t\t\t}\n\t\t}\n\n\t\t// Process special key events for the input field.\n\t\tswitch key := event.Key(); key {\n\t\tcase tcell.KeyDown:\n\t\t\ti.autocompleteListMutex.Unlock() // We're still holding a lock.\n\t\t\ti.Autocomplete()\n\t\t\ti.autocompleteListMutex.Lock()\n\t\tcase tcell.KeyEnter, tcell.KeyEscape, tcell.KeyTab, tcell.KeyBacktab:\n\t\t\tfinish(key)\n\t\tcase tcell.KeyCtrlV:\n\t\t\tif i.accept != nil && !i.accept(i.textArea.getTextBeforeCursor()+i.textArea.GetClipboardText()+i.textArea.getTextAfterCursor(), 0) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ti.textArea.InputHandler()(event, setFocus)\n\t\tcase tcell.KeyRune:\n\t\t\tif event.Modifiers()&tcell.ModAlt == 0 && i.accept != nil {\n\t\t\t\t// Check if this rune is accepted.\n\t\t\t\tr := event.Rune()\n\t\t\t\tif !i.accept(i.textArea.getTextBeforeCursor()+string(r)+i.textArea.getTextAfterCursor(), r) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\t// Forward other key events to the text area.\n\t\t\ti.textArea.InputHandler()(event, setFocus)\n\t\t}\n\t})\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (i *InputField) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn i.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif i.textArea.GetDisabled() {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tvar skipAutocomplete bool\n\t\tcurrentText := i.GetText()\n\t\tdefer func() {\n\t\t\tnewText := i.GetText()\n\t\t\tif newText != currentText {\n\t\t\t\tif !skipAutocomplete {\n\t\t\t\t\ti.Autocomplete()\n\t\t\t\t}\n\t\t\t\tif i.changed != nil {\n\t\t\t\t\ti.changed(newText)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// If we have an autocomplete list, forward the mouse event to it.\n\t\ti.autocompleteListMutex.Lock()\n\t\tdefer i.autocompleteListMutex.Unlock()\n\t\tif i.autocompleteList != nil {\n\t\t\ti.autocompleteList.SetChangedFunc(nil)\n\t\t\ti.autocompleteList.SetSelectedFunc(func(index int, text, secondaryText string, shortcut rune) {\n\t\t\t\ttext = stripTags(text)\n\t\t\t\tif i.autocompleted != nil {\n\t\t\t\t\tif i.autocompleted(text, index, AutocompletedClick) {\n\t\t\t\t\t\ti.autocompleteList = nil\n\t\t\t\t\t\tcurrentText = i.GetText()\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ti.SetText(text)\n\t\t\t\tskipAutocomplete = true\n\t\t\t\ti.autocompleteList = nil\n\t\t\t})\n\t\t\tif consumed, _ = i.autocompleteList.MouseHandler()(action, event, setFocus); consumed {\n\t\t\t\tsetFocus(i)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// Is mouse event within the input field?\n\t\tx, y := event.Position()\n\t\tif !i.InRect(x, y) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Forward mouse event to the text area.\n\t\tconsumed, capture = i.textArea.MouseHandler()(action, event, setFocus)\n\n\t\treturn\n\t})\n}\n\n// PasteHandler returns the handler for this primitive.\nfunc (i *InputField) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn i.WrapPasteHandler(func(pastedText string, setFocus func(p Primitive)) {\n\t\t// Input field may be disabled.\n\t\tif i.textArea.GetDisabled() {\n\t\t\treturn\n\t\t}\n\n\t\t// The autocomplete drop down may be open.\n\t\ti.autocompleteListMutex.Lock()\n\t\tdefer i.autocompleteListMutex.Unlock()\n\t\tif i.autocompleteList != nil {\n\t\t\treturn\n\t\t}\n\n\t\t// We may not accept this text.\n\t\tif i.accept != nil && !i.accept(i.textArea.getTextBeforeCursor()+pastedText+i.textArea.getTextAfterCursor(), 0) {\n\t\t\treturn\n\t\t}\n\n\t\t// Forward the pasted text to the text area.\n\t\ti.textArea.PasteHandler()(pastedText, setFocus)\n\t})\n}\n"
        },
        {
          "name": "list.go",
          "type": "blob",
          "size": 23.5087890625,
          "content": "package tview\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// listItem represents one item in a List.\ntype listItem struct {\n\tMainText      string // The main text of the list item.\n\tSecondaryText string // A secondary text to be shown underneath the main text.\n\tShortcut      rune   // The key to select the list item directly, 0 if there is no shortcut.\n\tSelected      func() // The optional function which is called when the item is selected.\n}\n\n// List displays rows of items, each of which can be selected. List items can be\n// shown as a single line or as two lines. They can be selected by pressing\n// their assigned shortcut key, navigating to them and pressing Enter, or\n// clicking on them with the mouse. The following key binds are available:\n//\n//   - Down arrow / tab: Move down one item.\n//   - Up arrow / backtab: Move up one item.\n//   - Home: Move to the first item.\n//   - End: Move to the last item.\n//   - Page down: Move down one page.\n//   - Page up: Move up one page.\n//   - Enter / Space: Select the current item.\n//   - Right / left: Scroll horizontally. Only if the list is wider than the\n//     available space.\n//\n// By default, list item texts can contain style tags. Use\n// [List.SetUseStyleTags] to disable this feature.\n//\n// See [List.SetChangedFunc] for a way to be notified when the user navigates\n// to a list item. See [List.SetSelectedFunc] for a way to be notified when a\n// list item was selected.\n//\n// See https://github.com/rivo/tview/wiki/List for an example.\ntype List struct {\n\t*Box\n\n\t// The items of the list.\n\titems []*listItem\n\n\t// The index of the currently selected item.\n\tcurrentItem int\n\n\t// Whether or not to show the secondary item texts.\n\tshowSecondaryText bool\n\n\t// The item main text style.\n\tmainTextStyle tcell.Style\n\n\t// The item secondary text style.\n\tsecondaryTextStyle tcell.Style\n\n\t// The item shortcut text style.\n\tshortcutStyle tcell.Style\n\n\t// The style for selected items.\n\tselectedStyle tcell.Style\n\n\t// If true, the selection is only shown when the list has focus.\n\tselectedFocusOnly bool\n\n\t// If true, the entire row is highlighted when selected.\n\thighlightFullLine bool\n\n\t// Whether or not style tags can be used in the main text.\n\tmainStyleTags bool\n\n\t// Whether or not style tags can be used in the secondary text.\n\tsecondaryStyleTags bool\n\n\t// Whether or not navigating the list will wrap around.\n\twrapAround bool\n\n\t// The number of list items skipped at the top before the first item is\n\t// drawn.\n\titemOffset int\n\n\t// The number of cells skipped on the left side of an item text. Shortcuts\n\t// are not affected.\n\thorizontalOffset int\n\n\t// An optional function which is called when the user has navigated to a\n\t// list item.\n\tchanged func(index int, mainText, secondaryText string, shortcut rune)\n\n\t// An optional function which is called when a list item was selected. This\n\t// function will be called even if the list item defines its own callback.\n\tselected func(index int, mainText, secondaryText string, shortcut rune)\n\n\t// An optional function which is called when the user presses the Escape key.\n\tdone func()\n}\n\n// NewList returns a new list.\nfunc NewList() *List {\n\treturn &List{\n\t\tBox:                NewBox(),\n\t\tshowSecondaryText:  true,\n\t\twrapAround:         true,\n\t\tmainTextStyle:      tcell.StyleDefault.Foreground(Styles.PrimaryTextColor).Background(Styles.PrimitiveBackgroundColor),\n\t\tsecondaryTextStyle: tcell.StyleDefault.Foreground(Styles.TertiaryTextColor).Background(Styles.PrimitiveBackgroundColor),\n\t\tshortcutStyle:      tcell.StyleDefault.Foreground(Styles.SecondaryTextColor).Background(Styles.PrimitiveBackgroundColor),\n\t\tselectedStyle:      tcell.StyleDefault.Foreground(Styles.PrimitiveBackgroundColor).Background(Styles.PrimaryTextColor),\n\t\tmainStyleTags:      true,\n\t\tsecondaryStyleTags: true,\n\t}\n}\n\n// SetCurrentItem sets the currently selected item by its index, starting at 0\n// for the first item. If a negative index is provided, items are referred to\n// from the back (-1 = last item, -2 = second-to-last item, and so on). Out of\n// range indices are clamped to the beginning/end.\n//\n// Calling this function triggers a \"changed\" event if the selection changes.\nfunc (l *List) SetCurrentItem(index int) *List {\n\tif index < 0 {\n\t\tindex = len(l.items) + index\n\t}\n\tif index >= len(l.items) {\n\t\tindex = len(l.items) - 1\n\t}\n\tif index < 0 {\n\t\tindex = 0\n\t}\n\n\tif index != l.currentItem && l.changed != nil {\n\t\titem := l.items[index]\n\t\tl.changed(index, item.MainText, item.SecondaryText, item.Shortcut)\n\t}\n\n\tl.currentItem = index\n\n\tl.adjustOffset()\n\n\treturn l\n}\n\n// GetCurrentItem returns the index of the currently selected list item,\n// starting at 0 for the first item.\nfunc (l *List) GetCurrentItem() int {\n\treturn l.currentItem\n}\n\n// SetOffset sets the number of items to be skipped (vertically) as well as the\n// number of cells skipped horizontally when the list is drawn. Note that one\n// item corresponds to two rows when there are secondary texts. Shortcuts are\n// always drawn.\n//\n// These values may change when the list is drawn to ensure the currently\n// selected item is visible and item texts move out of view. Users can also\n// modify these values by interacting with the list.\nfunc (l *List) SetOffset(items, horizontal int) *List {\n\tl.itemOffset = items\n\tl.horizontalOffset = horizontal\n\treturn l\n}\n\n// GetOffset returns the number of items skipped while drawing, as well as the\n// number of cells item text is moved to the left. See also SetOffset() for more\n// information on these values.\nfunc (l *List) GetOffset() (int, int) {\n\treturn l.itemOffset, l.horizontalOffset\n}\n\n// RemoveItem removes the item with the given index (starting at 0) from the\n// list. If a negative index is provided, items are referred to from the back\n// (-1 = last item, -2 = second-to-last item, and so on). Out of range indices\n// are clamped to the beginning/end, i.e. unless the list is empty, an item is\n// always removed.\n//\n// The currently selected item is shifted accordingly. If it is the one that is\n// removed, a \"changed\" event is fired, unless no items are left.\nfunc (l *List) RemoveItem(index int) *List {\n\tif len(l.items) == 0 {\n\t\treturn l\n\t}\n\n\t// Adjust index.\n\tif index < 0 {\n\t\tindex = len(l.items) + index\n\t}\n\tif index >= len(l.items) {\n\t\tindex = len(l.items) - 1\n\t}\n\tif index < 0 {\n\t\tindex = 0\n\t}\n\n\t// Remove item.\n\tl.items = append(l.items[:index], l.items[index+1:]...)\n\n\t// If there is nothing left, we're done.\n\tif len(l.items) == 0 {\n\t\treturn l\n\t}\n\n\t// Shift current item.\n\tpreviousCurrentItem := l.currentItem\n\tif l.currentItem > index || l.currentItem == len(l.items) {\n\t\tl.currentItem--\n\t}\n\n\t// Fire \"changed\" event for removed items.\n\tif previousCurrentItem == index && l.changed != nil {\n\t\titem := l.items[l.currentItem]\n\t\tl.changed(l.currentItem, item.MainText, item.SecondaryText, item.Shortcut)\n\t}\n\n\treturn l\n}\n\n// SetMainTextColor sets the color of the items' main text.\nfunc (l *List) SetMainTextColor(color tcell.Color) *List {\n\tl.mainTextStyle = l.mainTextStyle.Foreground(color)\n\treturn l\n}\n\n// SetMainTextStyle sets the style of the items' main text. Note that the\n// background color is ignored in order not to override the background color of\n// the list itself.\nfunc (l *List) SetMainTextStyle(style tcell.Style) *List {\n\tl.mainTextStyle = style\n\treturn l\n}\n\n// SetSecondaryTextColor sets the color of the items' secondary text.\nfunc (l *List) SetSecondaryTextColor(color tcell.Color) *List {\n\tl.secondaryTextStyle = l.secondaryTextStyle.Foreground(color)\n\treturn l\n}\n\n// SetSecondaryTextStyle sets the style of the items' secondary text. Note that\n// the background color is ignored in order not to override the background color\n// of the list itself.\nfunc (l *List) SetSecondaryTextStyle(style tcell.Style) *List {\n\tl.secondaryTextStyle = style\n\treturn l\n}\n\n// SetShortcutColor sets the color of the items' shortcut.\nfunc (l *List) SetShortcutColor(color tcell.Color) *List {\n\tl.shortcutStyle = l.shortcutStyle.Foreground(color)\n\treturn l\n}\n\n// SetShortcutStyle sets the style of the items' shortcut. Note that the\n// background color is ignored in order not to override the background color of\n// the list itself.\nfunc (l *List) SetShortcutStyle(style tcell.Style) *List {\n\tl.shortcutStyle = style\n\treturn l\n}\n\n// SetSelectedTextColor sets the text color of selected items. Note that the\n// color of main text characters that are different from the main text color\n// (e.g. style tags) is maintained.\nfunc (l *List) SetSelectedTextColor(color tcell.Color) *List {\n\tl.selectedStyle = l.selectedStyle.Foreground(color)\n\treturn l\n}\n\n// SetSelectedBackgroundColor sets the background color of selected items.\nfunc (l *List) SetSelectedBackgroundColor(color tcell.Color) *List {\n\tl.selectedStyle = l.selectedStyle.Background(color)\n\treturn l\n}\n\n// SetSelectedStyle sets the style of the selected items. Note that the color of\n// main text characters that are different from the main text color (e.g. color\n// tags) is maintained.\nfunc (l *List) SetSelectedStyle(style tcell.Style) *List {\n\tl.selectedStyle = style\n\treturn l\n}\n\n// SetUseStyleTags sets a flag which determines whether style tags are used in\n// the main and secondary texts. The default is true.\nfunc (l *List) SetUseStyleTags(mainStyleTags, secondaryStyleTags bool) *List {\n\tl.mainStyleTags = mainStyleTags\n\tl.secondaryStyleTags = secondaryStyleTags\n\treturn l\n}\n\n// SetSelectedFocusOnly sets a flag which determines when the currently selected\n// list item is highlighted. If set to true, selected items are only highlighted\n// when the list has focus. If set to false, they are always highlighted.\nfunc (l *List) SetSelectedFocusOnly(focusOnly bool) *List {\n\tl.selectedFocusOnly = focusOnly\n\treturn l\n}\n\n// SetHighlightFullLine sets a flag which determines whether the colored\n// background of selected items spans the entire width of the view. If set to\n// true, the highlight spans the entire view. If set to false, only the text of\n// the selected item from beginning to end is highlighted.\nfunc (l *List) SetHighlightFullLine(highlight bool) *List {\n\tl.highlightFullLine = highlight\n\treturn l\n}\n\n// ShowSecondaryText determines whether or not to show secondary item texts.\nfunc (l *List) ShowSecondaryText(show bool) *List {\n\tl.showSecondaryText = show\n\treturn l\n}\n\n// SetWrapAround sets the flag that determines whether navigating the list will\n// wrap around. That is, navigating downwards on the last item will move the\n// selection to the first item (similarly in the other direction). If set to\n// false, the selection won't change when navigating downwards on the last item\n// or navigating upwards on the first item.\nfunc (l *List) SetWrapAround(wrapAround bool) *List {\n\tl.wrapAround = wrapAround\n\treturn l\n}\n\n// SetChangedFunc sets the function which is called when the user navigates to\n// a list item. The function receives the item's index in the list of items\n// (starting with 0), its main text, secondary text, and its shortcut rune.\n//\n// This function is also called when the first item is added or when\n// SetCurrentItem() is called.\nfunc (l *List) SetChangedFunc(handler func(index int, mainText string, secondaryText string, shortcut rune)) *List {\n\tl.changed = handler\n\treturn l\n}\n\n// SetSelectedFunc sets the function which is called when the user selects a\n// list item by pressing Enter on the current selection. The function receives\n// the item's index in the list of items (starting with 0), its main text,\n// secondary text, and its shortcut rune.\nfunc (l *List) SetSelectedFunc(handler func(int, string, string, rune)) *List {\n\tl.selected = handler\n\treturn l\n}\n\n// GetSelectedFunc returns the function set with [List.SetSelectedFunc] or nil\n// if no such function was set.\nfunc (l *List) GetSelectedFunc() func(int, string, string, rune) {\n\treturn l.selected\n}\n\n// SetDoneFunc sets a function which is called when the user presses the Escape\n// key.\nfunc (l *List) SetDoneFunc(handler func()) *List {\n\tl.done = handler\n\treturn l\n}\n\n// AddItem calls [List.InsertItem] with an index of -1.\nfunc (l *List) AddItem(mainText, secondaryText string, shortcut rune, selected func()) *List {\n\tl.InsertItem(-1, mainText, secondaryText, shortcut, selected)\n\treturn l\n}\n\n// InsertItem adds a new item to the list at the specified index. An index of 0\n// will insert the item at the beginning, an index of 1 before the second item,\n// and so on. An index of [List.GetItemCount] or higher will insert the item at\n// the end of the list. Negative indices are also allowed: An index of -1 will\n// insert the item at the end of the list, an index of -2 before the last item,\n// and so on. An index of -GetItemCount()-1 or lower will insert the item at the\n// beginning.\n//\n// An item has a main text which will be highlighted when selected. It also has\n// a secondary text which is shown underneath the main text (if it is set to\n// visible) but which may remain empty.\n//\n// The shortcut is a key binding. If the specified rune is entered, the item\n// is selected immediately. Set to 0 for no binding.\n//\n// The \"selected\" callback will be invoked when the user selects the item. You\n// may provide nil if no such callback is needed or if all events are handled\n// through the selected callback set with [List.SetSelectedFunc].\n//\n// The currently selected item will shift its position accordingly. If the list\n// was previously empty, a \"changed\" event is fired because the new item becomes\n// selected.\nfunc (l *List) InsertItem(index int, mainText, secondaryText string, shortcut rune, selected func()) *List {\n\titem := &listItem{\n\t\tMainText:      mainText,\n\t\tSecondaryText: secondaryText,\n\t\tShortcut:      shortcut,\n\t\tSelected:      selected,\n\t}\n\n\t// Shift index to range.\n\tif index < 0 {\n\t\tindex = len(l.items) + index + 1\n\t}\n\tif index < 0 {\n\t\tindex = 0\n\t} else if index > len(l.items) {\n\t\tindex = len(l.items)\n\t}\n\n\t// Shift current item.\n\tif l.currentItem < len(l.items) && l.currentItem >= index {\n\t\tl.currentItem++\n\t}\n\n\t// Insert item (make space for the new item, then shift and insert).\n\tl.items = append(l.items, nil)\n\tif index < len(l.items)-1 { // -1 because l.items has already grown by one item.\n\t\tcopy(l.items[index+1:], l.items[index:])\n\t}\n\tl.items[index] = item\n\n\t// Fire a \"change\" event for the first item in the list.\n\tif len(l.items) == 1 && l.changed != nil {\n\t\titem := l.items[0]\n\t\tl.changed(0, item.MainText, item.SecondaryText, item.Shortcut)\n\t}\n\n\treturn l\n}\n\n// GetItemCount returns the number of items in the list.\nfunc (l *List) GetItemCount() int {\n\treturn len(l.items)\n}\n\n// GetItemSelectedFunc returns the function which is called when the user\n// selects the item with the given index, if such a function was set. If no\n// function was set, nil is returned. Panics if the index is out of range.\nfunc (l *List) GetItemSelectedFunc(index int) func() {\n\treturn l.items[index].Selected\n}\n\n// GetItemText returns an item's texts (main and secondary). Panics if the index\n// is out of range.\nfunc (l *List) GetItemText(index int) (main, secondary string) {\n\treturn l.items[index].MainText, l.items[index].SecondaryText\n}\n\n// SetItemText sets an item's main and secondary text. Panics if the index is\n// out of range.\nfunc (l *List) SetItemText(index int, main, secondary string) *List {\n\titem := l.items[index]\n\titem.MainText = main\n\titem.SecondaryText = secondary\n\treturn l\n}\n\n// FindItems searches the main and secondary texts for the given strings and\n// returns a list of item indices in which those strings are found. One of the\n// two search strings may be empty, it will then be ignored. Indices are always\n// returned in ascending order.\n//\n// If mustContainBoth is set to true, mainSearch must be contained in the main\n// text AND secondarySearch must be contained in the secondary text. If it is\n// false, only one of the two search strings must be contained.\n//\n// Set ignoreCase to true for case-insensitive search.\nfunc (l *List) FindItems(mainSearch, secondarySearch string, mustContainBoth, ignoreCase bool) (indices []int) {\n\tif mainSearch == \"\" && secondarySearch == \"\" {\n\t\treturn\n\t}\n\n\tif ignoreCase {\n\t\tmainSearch = strings.ToLower(mainSearch)\n\t\tsecondarySearch = strings.ToLower(secondarySearch)\n\t}\n\n\tfor index, item := range l.items {\n\t\tmainText := item.MainText\n\t\tsecondaryText := item.SecondaryText\n\t\tif ignoreCase {\n\t\t\tmainText = strings.ToLower(mainText)\n\t\t\tsecondaryText = strings.ToLower(secondaryText)\n\t\t}\n\n\t\t// strings.Contains() always returns true for a \"\" search.\n\t\tmainContained := strings.Contains(mainText, mainSearch)\n\t\tsecondaryContained := strings.Contains(secondaryText, secondarySearch)\n\t\tif mustContainBoth && mainContained && secondaryContained ||\n\t\t\t!mustContainBoth && (mainSearch != \"\" && mainContained || secondarySearch != \"\" && secondaryContained) {\n\t\t\tindices = append(indices, index)\n\t\t}\n\t}\n\n\treturn\n}\n\n// Clear removes all items from the list.\nfunc (l *List) Clear() *List {\n\tl.items = nil\n\tl.currentItem = 0\n\treturn l\n}\n\n// Draw draws this primitive onto the screen.\nfunc (l *List) Draw(screen tcell.Screen) {\n\tl.Box.DrawForSubclass(screen, l)\n\n\t// Determine the dimensions.\n\tx, y, width, height := l.GetInnerRect()\n\tbottomLimit := y + height\n\t_, totalHeight := screen.Size()\n\tif bottomLimit > totalHeight {\n\t\tbottomLimit = totalHeight\n\t}\n\n\t// Do we show any shortcuts?\n\tvar showShortcuts bool\n\tfor _, item := range l.items {\n\t\tif item.Shortcut != 0 {\n\t\t\tshowShortcuts = true\n\t\t\tx += 4\n\t\t\twidth -= 4\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif l.horizontalOffset < 0 {\n\t\tl.horizontalOffset = 0\n\t}\n\n\t// Draw the list items.\n\tvar maxWidth int // The maximum printed item width.\n\tfor index, item := range l.items {\n\t\tif index < l.itemOffset {\n\t\t\tcontinue\n\t\t}\n\n\t\tif y >= bottomLimit {\n\t\t\tbreak\n\t\t}\n\n\t\t// Shortcuts.\n\t\tif showShortcuts && item.Shortcut != 0 {\n\t\t\tprintWithStyle(screen, fmt.Sprintf(\"(%s)\", string(item.Shortcut)), x-5, y, 0, 4, AlignRight, l.shortcutStyle, false)\n\t\t}\n\n\t\t// Main text.\n\t\tselected := index == l.currentItem && (!l.selectedFocusOnly || l.HasFocus())\n\t\tstyle := l.mainTextStyle\n\t\tif selected {\n\t\t\tstyle = l.selectedStyle\n\t\t}\n\t\tmainText := item.MainText\n\t\tif !l.mainStyleTags {\n\t\t\tmainText = Escape(mainText)\n\t\t}\n\t\t_, _, printedWidth := printWithStyle(screen, mainText, x, y, l.horizontalOffset, width, AlignLeft, style, false)\n\t\tif printedWidth > maxWidth {\n\t\t\tmaxWidth = printedWidth\n\t\t}\n\n\t\t// Draw until the end of the line if requested.\n\t\tif selected && l.highlightFullLine {\n\t\t\tfor bx := printedWidth; bx < width; bx++ {\n\t\t\t\tscreen.SetContent(x+bx, y, ' ', nil, style)\n\t\t\t}\n\t\t}\n\n\t\ty++\n\t\tif y >= bottomLimit {\n\t\t\tbreak\n\t\t}\n\n\t\t// Secondary text.\n\t\tif l.showSecondaryText {\n\t\t\tsecondaryText := item.SecondaryText\n\t\t\tif !l.secondaryStyleTags {\n\t\t\t\tsecondaryText = Escape(secondaryText)\n\t\t\t}\n\t\t\t_, _, printedWidth := printWithStyle(screen, secondaryText, x, y, l.horizontalOffset, width, AlignLeft, l.secondaryTextStyle, false)\n\t\t\tif printedWidth > maxWidth {\n\t\t\t\tmaxWidth = printedWidth\n\t\t\t}\n\t\t\ty++\n\t\t}\n\t}\n\n\t// We don't want the item text to get out of view. If the horizontal offset\n\t// is too high, we reset it and redraw. (That should be about as efficient\n\t// as calculating everything up front.)\n\tif l.horizontalOffset > 0 && maxWidth < width {\n\t\tl.horizontalOffset -= width - maxWidth\n\t\tl.Draw(screen)\n\t}\n}\n\n// adjustOffset adjusts the vertical offset to keep the current selection in\n// view.\nfunc (l *List) adjustOffset() {\n\t_, _, _, height := l.GetInnerRect()\n\tif height == 0 {\n\t\treturn\n\t}\n\tif l.currentItem < l.itemOffset {\n\t\tl.itemOffset = l.currentItem\n\t} else if l.showSecondaryText {\n\t\tif 2*(l.currentItem-l.itemOffset) >= height-1 {\n\t\t\tl.itemOffset = (2*l.currentItem + 3 - height) / 2\n\t\t}\n\t} else {\n\t\tif l.currentItem-l.itemOffset >= height {\n\t\t\tl.itemOffset = l.currentItem + 1 - height\n\t\t}\n\t}\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (l *List) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn l.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif event.Key() == tcell.KeyEscape {\n\t\t\tif l.done != nil {\n\t\t\t\tl.done()\n\t\t\t}\n\t\t\treturn\n\t\t} else if len(l.items) == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tpreviousItem := l.currentItem\n\n\t\tswitch key := event.Key(); key {\n\t\tcase tcell.KeyTab, tcell.KeyDown:\n\t\t\tl.currentItem++\n\t\tcase tcell.KeyBacktab, tcell.KeyUp:\n\t\t\tl.currentItem--\n\t\tcase tcell.KeyRight:\n\t\t\tl.horizontalOffset += 2 // We shift by 2 to account for two-cell characters.\n\t\tcase tcell.KeyLeft:\n\t\t\tl.horizontalOffset -= 2\n\t\tcase tcell.KeyHome:\n\t\t\tl.currentItem = 0\n\t\tcase tcell.KeyEnd:\n\t\t\tl.currentItem = len(l.items) - 1\n\t\tcase tcell.KeyPgDn:\n\t\t\t_, _, _, height := l.GetInnerRect()\n\t\t\tl.currentItem += height\n\t\t\tif l.currentItem >= len(l.items) {\n\t\t\t\tl.currentItem = len(l.items) - 1\n\t\t\t}\n\t\tcase tcell.KeyPgUp:\n\t\t\t_, _, _, height := l.GetInnerRect()\n\t\t\tl.currentItem -= height\n\t\t\tif l.currentItem < 0 {\n\t\t\t\tl.currentItem = 0\n\t\t\t}\n\t\tcase tcell.KeyEnter:\n\t\t\tif l.currentItem >= 0 && l.currentItem < len(l.items) {\n\t\t\t\titem := l.items[l.currentItem]\n\t\t\t\tif item.Selected != nil {\n\t\t\t\t\titem.Selected()\n\t\t\t\t}\n\t\t\t\tif l.selected != nil {\n\t\t\t\t\tl.selected(l.currentItem, item.MainText, item.SecondaryText, item.Shortcut)\n\t\t\t\t}\n\t\t\t}\n\t\tcase tcell.KeyRune:\n\t\t\tch := event.Rune()\n\t\t\tif ch != ' ' {\n\t\t\t\t// It's not a space bar. Is it a shortcut?\n\t\t\t\tvar found bool\n\t\t\t\tfor index, item := range l.items {\n\t\t\t\t\tif item.Shortcut == ch {\n\t\t\t\t\t\t// We have a shortcut.\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tl.currentItem = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !found {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\titem := l.items[l.currentItem]\n\t\t\tif item.Selected != nil {\n\t\t\t\titem.Selected()\n\t\t\t}\n\t\t\tif l.selected != nil {\n\t\t\t\tl.selected(l.currentItem, item.MainText, item.SecondaryText, item.Shortcut)\n\t\t\t}\n\t\t}\n\n\t\tif l.currentItem < 0 {\n\t\t\tif l.wrapAround {\n\t\t\t\tl.currentItem = len(l.items) - 1\n\t\t\t} else {\n\t\t\t\tl.currentItem = 0\n\t\t\t}\n\t\t} else if l.currentItem >= len(l.items) {\n\t\t\tif l.wrapAround {\n\t\t\t\tl.currentItem = 0\n\t\t\t} else {\n\t\t\t\tl.currentItem = len(l.items) - 1\n\t\t\t}\n\t\t}\n\n\t\tif l.currentItem != previousItem && l.currentItem < len(l.items) {\n\t\t\tif l.changed != nil {\n\t\t\t\titem := l.items[l.currentItem]\n\t\t\t\tl.changed(l.currentItem, item.MainText, item.SecondaryText, item.Shortcut)\n\t\t\t}\n\t\t\tl.adjustOffset()\n\t\t}\n\t})\n}\n\n// indexAtPoint returns the index of the list item found at the given position\n// or a negative value if there is no such list item.\nfunc (l *List) indexAtPoint(x, y int) int {\n\trectX, rectY, width, height := l.GetInnerRect()\n\tif rectX < 0 || rectX >= rectX+width || y < rectY || y >= rectY+height {\n\t\treturn -1\n\t}\n\n\tindex := y - rectY\n\tif l.showSecondaryText {\n\t\tindex /= 2\n\t}\n\tindex += l.itemOffset\n\n\tif index >= len(l.items) {\n\t\treturn -1\n\t}\n\treturn index\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (l *List) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn l.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif !l.InRect(event.Position()) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Process mouse event.\n\t\tswitch action {\n\t\tcase MouseLeftClick:\n\t\t\tsetFocus(l)\n\t\t\tindex := l.indexAtPoint(event.Position())\n\t\t\tif index != -1 {\n\t\t\t\titem := l.items[index]\n\t\t\t\tif item.Selected != nil {\n\t\t\t\t\titem.Selected()\n\t\t\t\t}\n\t\t\t\tif l.selected != nil {\n\t\t\t\t\tl.selected(index, item.MainText, item.SecondaryText, item.Shortcut)\n\t\t\t\t}\n\t\t\t\tif index != l.currentItem {\n\t\t\t\t\tif l.changed != nil {\n\t\t\t\t\t\tl.changed(index, item.MainText, item.SecondaryText, item.Shortcut)\n\t\t\t\t\t}\n\t\t\t\t\tl.adjustOffset()\n\t\t\t\t}\n\t\t\t\tl.currentItem = index\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollUp:\n\t\t\tif l.itemOffset > 0 {\n\t\t\t\tl.itemOffset--\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollDown:\n\t\t\tlines := len(l.items) - l.itemOffset\n\t\t\tif l.showSecondaryText {\n\t\t\t\tlines *= 2\n\t\t\t}\n\t\t\tif _, _, _, height := l.GetInnerRect(); lines > height {\n\t\t\t\tl.itemOffset++\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollLeft:\n\t\t\tl.horizontalOffset--\n\t\t\tconsumed = true\n\t\tcase MouseScrollRight:\n\t\t\tl.horizontalOffset++\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n"
        },
        {
          "name": "modal.go",
          "type": "blob",
          "size": 6.3193359375,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Modal is a centered message window used to inform the user or prompt them\n// for an immediate decision. It needs to have at least one button (added via\n// [Modal.AddButtons]) or it will never disappear.\n//\n// See https://github.com/rivo/tview/wiki/Modal for an example.\ntype Modal struct {\n\t*Box\n\n\t// The frame embedded in the modal.\n\tframe *Frame\n\n\t// The form embedded in the modal's frame.\n\tform *Form\n\n\t// The message text (original, not word-wrapped).\n\ttext string\n\n\t// The text color.\n\ttextColor tcell.Color\n\n\t// The optional callback for when the user clicked one of the buttons. It\n\t// receives the index of the clicked button and the button's label.\n\tdone func(buttonIndex int, buttonLabel string)\n}\n\n// NewModal returns a new modal message window.\nfunc NewModal() *Modal {\n\tm := &Modal{\n\t\tBox:       NewBox().SetBorder(true).SetBackgroundColor(Styles.ContrastBackgroundColor),\n\t\ttextColor: Styles.PrimaryTextColor,\n\t}\n\tm.form = NewForm().\n\t\tSetButtonsAlign(AlignCenter).\n\t\tSetButtonBackgroundColor(Styles.PrimitiveBackgroundColor).\n\t\tSetButtonTextColor(Styles.PrimaryTextColor)\n\tm.form.SetBackgroundColor(Styles.ContrastBackgroundColor).SetBorderPadding(0, 0, 0, 0)\n\tm.form.SetCancelFunc(func() {\n\t\tif m.done != nil {\n\t\t\tm.done(-1, \"\")\n\t\t}\n\t})\n\tm.frame = NewFrame(m.form).SetBorders(0, 0, 1, 0, 0, 0)\n\tm.frame.SetBackgroundColor(Styles.ContrastBackgroundColor).\n\t\tSetBorderPadding(1, 1, 1, 1)\n\treturn m\n}\n\n// SetBackgroundColor sets the color of the modal frame background.\nfunc (m *Modal) SetBackgroundColor(color tcell.Color) *Modal {\n\tm.form.SetBackgroundColor(color)\n\tm.frame.SetBackgroundColor(color)\n\treturn m\n}\n\n// SetTextColor sets the color of the message text.\nfunc (m *Modal) SetTextColor(color tcell.Color) *Modal {\n\tm.textColor = color\n\treturn m\n}\n\n// SetButtonBackgroundColor sets the background color of the buttons.\nfunc (m *Modal) SetButtonBackgroundColor(color tcell.Color) *Modal {\n\tm.form.SetButtonBackgroundColor(color)\n\treturn m\n}\n\n// SetButtonTextColor sets the color of the button texts.\nfunc (m *Modal) SetButtonTextColor(color tcell.Color) *Modal {\n\tm.form.SetButtonTextColor(color)\n\treturn m\n}\n\n// SetButtonStyle sets the style of the buttons when they are not focused.\nfunc (m *Modal) SetButtonStyle(style tcell.Style) *Modal {\n\tm.form.SetButtonStyle(style)\n\treturn m\n}\n\n// SetButtonActivatedStyle sets the style of the buttons when they are focused.\nfunc (m *Modal) SetButtonActivatedStyle(style tcell.Style) *Modal {\n\tm.form.SetButtonActivatedStyle(style)\n\treturn m\n}\n\n// SetDoneFunc sets a handler which is called when one of the buttons was\n// pressed. It receives the index of the button as well as its label text. The\n// handler is also called when the user presses the Escape key. The index will\n// then be negative and the label text an empty string.\nfunc (m *Modal) SetDoneFunc(handler func(buttonIndex int, buttonLabel string)) *Modal {\n\tm.done = handler\n\treturn m\n}\n\n// SetText sets the message text of the window. The text may contain line\n// breaks but style tag states will not transfer to following lines. Note that\n// words are wrapped, too, based on the final size of the window.\nfunc (m *Modal) SetText(text string) *Modal {\n\tm.text = text\n\treturn m\n}\n\n// AddButtons adds buttons to the window. There must be at least one button and\n// a \"done\" handler so the window can be closed again.\nfunc (m *Modal) AddButtons(labels []string) *Modal {\n\tfor index, label := range labels {\n\t\tfunc(i int, l string) {\n\t\t\tm.form.AddButton(label, func() {\n\t\t\t\tif m.done != nil {\n\t\t\t\t\tm.done(i, l)\n\t\t\t\t}\n\t\t\t})\n\t\t\tbutton := m.form.GetButton(m.form.GetButtonCount() - 1)\n\t\t\tbutton.SetInputCapture(func(event *tcell.EventKey) *tcell.EventKey {\n\t\t\t\tswitch event.Key() {\n\t\t\t\tcase tcell.KeyDown, tcell.KeyRight:\n\t\t\t\t\treturn tcell.NewEventKey(tcell.KeyTab, 0, tcell.ModNone)\n\t\t\t\tcase tcell.KeyUp, tcell.KeyLeft:\n\t\t\t\t\treturn tcell.NewEventKey(tcell.KeyBacktab, 0, tcell.ModNone)\n\t\t\t\t}\n\t\t\t\treturn event\n\t\t\t})\n\t\t}(index, label)\n\t}\n\treturn m\n}\n\n// ClearButtons removes all buttons from the window.\nfunc (m *Modal) ClearButtons() *Modal {\n\tm.form.ClearButtons()\n\treturn m\n}\n\n// SetFocus shifts the focus to the button with the given index.\nfunc (m *Modal) SetFocus(index int) *Modal {\n\tm.form.SetFocus(index)\n\treturn m\n}\n\n// Focus is called when this primitive receives focus.\nfunc (m *Modal) Focus(delegate func(p Primitive)) {\n\tdelegate(m.form)\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (m *Modal) HasFocus() bool {\n\treturn m.form.HasFocus()\n}\n\n// Draw draws this primitive onto the screen.\nfunc (m *Modal) Draw(screen tcell.Screen) {\n\t// Calculate the width of this modal.\n\tbuttonsWidth := 0\n\tfor _, button := range m.form.buttons {\n\t\tbuttonsWidth += TaggedStringWidth(button.text) + 4 + 2\n\t}\n\tbuttonsWidth -= 2\n\tscreenWidth, screenHeight := screen.Size()\n\twidth := screenWidth / 3\n\tif width < buttonsWidth {\n\t\twidth = buttonsWidth\n\t}\n\t// width is now without the box border.\n\n\t// Reset the text and find out how wide it is.\n\tm.frame.Clear()\n\tlines := WordWrap(m.text, width)\n\tfor _, line := range lines {\n\t\tm.frame.AddText(line, true, AlignCenter, m.textColor)\n\t}\n\n\t// Set the modal's position and size.\n\theight := len(lines) + 6\n\twidth += 4\n\tx := (screenWidth - width) / 2\n\ty := (screenHeight - height) / 2\n\tm.SetRect(x, y, width, height)\n\n\t// Draw the frame.\n\tm.Box.DrawForSubclass(screen, m)\n\tx, y, width, height = m.GetInnerRect()\n\tm.frame.SetRect(x, y, width, height)\n\tm.frame.Draw(screen)\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (m *Modal) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn m.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\t// Pass mouse events on to the form.\n\t\tconsumed, capture = m.form.MouseHandler()(action, event, setFocus)\n\t\tif !consumed && action == MouseLeftDown && m.InRect(event.Position()) {\n\t\t\tsetFocus(m)\n\t\t\tconsumed = true\n\t\t}\n\t\treturn\n\t})\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (m *Modal) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn m.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif m.frame.HasFocus() {\n\t\t\tif handler := m.frame.InputHandler(); handler != nil {\n\t\t\t\thandler(event, setFocus)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "pages.go",
          "type": "blob",
          "size": 8.6748046875,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// page represents one page of a Pages object.\ntype page struct {\n\tName    string    // The page's name.\n\tItem    Primitive // The page's primitive.\n\tResize  bool      // Whether or not to resize the page when it is drawn.\n\tVisible bool      // Whether or not this page is visible.\n}\n\n// Pages is a container for other primitives laid out on top of each other,\n// overlapping or not. It is often used as the application's root primitive. It\n// allows to easily switch the visibility of the contained primitives.\n//\n// See https://github.com/rivo/tview/wiki/Pages for an example.\ntype Pages struct {\n\t*Box\n\n\t// The contained pages. (Visible) pages are drawn from back to front.\n\tpages []*page\n\n\t// We keep a reference to the function which allows us to set the focus to\n\t// a newly visible page.\n\tsetFocus func(p Primitive)\n\n\t// An optional handler which is called whenever the visibility or the order of\n\t// pages changes.\n\tchanged func()\n}\n\n// NewPages returns a new Pages object.\nfunc NewPages() *Pages {\n\tp := &Pages{\n\t\tBox: NewBox(),\n\t}\n\treturn p\n}\n\n// SetChangedFunc sets a handler which is called whenever the visibility or the\n// order of any visible pages changes. This can be used to redraw the pages.\nfunc (p *Pages) SetChangedFunc(handler func()) *Pages {\n\tp.changed = handler\n\treturn p\n}\n\n// GetPageCount returns the number of pages currently stored in this object.\nfunc (p *Pages) GetPageCount() int {\n\treturn len(p.pages)\n}\n\n// GetPageNames returns all page names ordered from front to back,\n// optionally limited to visible pages.\nfunc (p *Pages) GetPageNames(visibleOnly bool) []string {\n\tvar names []string\n\tfor index := len(p.pages) - 1; index >= 0; index-- {\n\t\tif !visibleOnly || p.pages[index].Visible {\n\t\t\tnames = append(names, p.pages[index].Name)\n\t\t}\n\t}\n\treturn names\n}\n\n// AddPage adds a new page with the given name and primitive. If there was\n// previously a page with the same name, it is overwritten. Leaving the name\n// empty may cause conflicts in other functions so always specify a non-empty\n// name.\n//\n// Visible pages will be drawn in the order they were added (unless that order\n// was changed in one of the other functions). If \"resize\" is set to true, the\n// primitive will be set to the size available to the Pages primitive whenever\n// the pages are drawn.\nfunc (p *Pages) AddPage(name string, item Primitive, resize, visible bool) *Pages {\n\thasFocus := p.HasFocus()\n\tfor index, pg := range p.pages {\n\t\tif pg.Name == name {\n\t\t\tp.pages = append(p.pages[:index], p.pages[index+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\tp.pages = append(p.pages, &page{Item: item, Name: name, Resize: resize, Visible: visible})\n\tif p.changed != nil {\n\t\tp.changed()\n\t}\n\tif hasFocus {\n\t\tp.Focus(p.setFocus)\n\t}\n\treturn p\n}\n\n// AddAndSwitchToPage calls AddPage(), then SwitchToPage() on that newly added\n// page.\nfunc (p *Pages) AddAndSwitchToPage(name string, item Primitive, resize bool) *Pages {\n\tp.AddPage(name, item, resize, true)\n\tp.SwitchToPage(name)\n\treturn p\n}\n\n// RemovePage removes the page with the given name. If that page was the only\n// visible page, visibility is assigned to the last page.\nfunc (p *Pages) RemovePage(name string) *Pages {\n\tvar isVisible bool\n\thasFocus := p.HasFocus()\n\tfor index, page := range p.pages {\n\t\tif page.Name == name {\n\t\t\tisVisible = page.Visible\n\t\t\tp.pages = append(p.pages[:index], p.pages[index+1:]...)\n\t\t\tif page.Visible && p.changed != nil {\n\t\t\t\tp.changed()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif isVisible {\n\t\tfor index, page := range p.pages {\n\t\t\tif index < len(p.pages)-1 {\n\t\t\t\tif page.Visible {\n\t\t\t\t\tbreak // There is a remaining visible page.\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpage.Visible = true // We need at least one visible page.\n\t\t\t}\n\t\t}\n\t}\n\tif hasFocus {\n\t\tp.Focus(p.setFocus)\n\t}\n\treturn p\n}\n\n// HasPage returns true if a page with the given name exists in this object.\nfunc (p *Pages) HasPage(name string) bool {\n\tfor _, page := range p.pages {\n\t\tif page.Name == name {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// ShowPage sets a page's visibility to \"true\" (in addition to any other pages\n// which are already visible).\nfunc (p *Pages) ShowPage(name string) *Pages {\n\tfor _, page := range p.pages {\n\t\tif page.Name == name {\n\t\t\tpage.Visible = true\n\t\t\tif p.changed != nil {\n\t\t\t\tp.changed()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif p.HasFocus() {\n\t\tp.Focus(p.setFocus)\n\t}\n\treturn p\n}\n\n// HidePage sets a page's visibility to \"false\".\nfunc (p *Pages) HidePage(name string) *Pages {\n\tfor _, page := range p.pages {\n\t\tif page.Name == name {\n\t\t\tpage.Visible = false\n\t\t\tif p.changed != nil {\n\t\t\t\tp.changed()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif p.HasFocus() {\n\t\tp.Focus(p.setFocus)\n\t}\n\treturn p\n}\n\n// SwitchToPage sets a page's visibility to \"true\" and all other pages'\n// visibility to \"false\".\nfunc (p *Pages) SwitchToPage(name string) *Pages {\n\tfor _, page := range p.pages {\n\t\tif page.Name == name {\n\t\t\tpage.Visible = true\n\t\t} else {\n\t\t\tpage.Visible = false\n\t\t}\n\t}\n\tif p.changed != nil {\n\t\tp.changed()\n\t}\n\tif p.HasFocus() {\n\t\tp.Focus(p.setFocus)\n\t}\n\treturn p\n}\n\n// SendToFront changes the order of the pages such that the page with the given\n// name comes last, causing it to be drawn last with the next update (if\n// visible).\nfunc (p *Pages) SendToFront(name string) *Pages {\n\tfor index, page := range p.pages {\n\t\tif page.Name == name {\n\t\t\tif index < len(p.pages)-1 {\n\t\t\t\tp.pages = append(append(p.pages[:index], p.pages[index+1:]...), page)\n\t\t\t}\n\t\t\tif page.Visible && p.changed != nil {\n\t\t\t\tp.changed()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif p.HasFocus() {\n\t\tp.Focus(p.setFocus)\n\t}\n\treturn p\n}\n\n// SendToBack changes the order of the pages such that the page with the given\n// name comes first, causing it to be drawn first with the next update (if\n// visible).\nfunc (p *Pages) SendToBack(name string) *Pages {\n\tfor index, pg := range p.pages {\n\t\tif pg.Name == name {\n\t\t\tif index > 0 {\n\t\t\t\tp.pages = append(append([]*page{pg}, p.pages[:index]...), p.pages[index+1:]...)\n\t\t\t}\n\t\t\tif pg.Visible && p.changed != nil {\n\t\t\t\tp.changed()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tif p.HasFocus() {\n\t\tp.Focus(p.setFocus)\n\t}\n\treturn p\n}\n\n// GetFrontPage returns the front-most visible page. If there are no visible\n// pages, (\"\", nil) is returned.\nfunc (p *Pages) GetFrontPage() (name string, item Primitive) {\n\tfor index := len(p.pages) - 1; index >= 0; index-- {\n\t\tif p.pages[index].Visible {\n\t\t\treturn p.pages[index].Name, p.pages[index].Item\n\t\t}\n\t}\n\treturn\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (p *Pages) HasFocus() bool {\n\tfor _, page := range p.pages {\n\t\tif page.Item.HasFocus() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn p.Box.HasFocus()\n}\n\n// Focus is called by the application when the primitive receives focus.\nfunc (p *Pages) Focus(delegate func(p Primitive)) {\n\tif delegate == nil {\n\t\treturn // We cannot delegate so we cannot focus.\n\t}\n\tp.setFocus = delegate\n\tvar topItem Primitive\n\tfor _, page := range p.pages {\n\t\tif page.Visible {\n\t\t\ttopItem = page.Item\n\t\t}\n\t}\n\tif topItem != nil {\n\t\tdelegate(topItem)\n\t} else {\n\t\tp.Box.Focus(delegate)\n\t}\n}\n\n// Draw draws this primitive onto the screen.\nfunc (p *Pages) Draw(screen tcell.Screen) {\n\tp.Box.DrawForSubclass(screen, p)\n\tfor _, page := range p.pages {\n\t\tif !page.Visible {\n\t\t\tcontinue\n\t\t}\n\t\tif page.Resize {\n\t\t\tx, y, width, height := p.GetInnerRect()\n\t\t\tpage.Item.SetRect(x, y, width, height)\n\t\t}\n\t\tpage.Item.Draw(screen)\n\t}\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (p *Pages) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn p.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif !p.InRect(event.Position()) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Pass mouse events along to the last visible page item that takes it.\n\t\tfor index := len(p.pages) - 1; index >= 0; index-- {\n\t\t\tpage := p.pages[index]\n\t\t\tif page.Visible {\n\t\t\t\tconsumed, capture = page.Item.MouseHandler()(action, event, setFocus)\n\t\t\t\tif consumed {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t})\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (p *Pages) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn p.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tfor _, page := range p.pages {\n\t\t\tif page.Item.HasFocus() {\n\t\t\t\tif handler := page.Item.InputHandler(); handler != nil {\n\t\t\t\t\thandler(event, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\n// PasteHandler returns the handler for this primitive.\nfunc (p *Pages) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn p.WrapPasteHandler(func(pastedText string, setFocus func(p Primitive)) {\n\t\tfor _, page := range p.pages {\n\t\t\tif page.Item.HasFocus() {\n\t\t\t\tif handler := page.Item.PasteHandler(); handler != nil {\n\t\t\t\t\thandler(pastedText, setFocus)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "primitive.go",
          "type": "blob",
          "size": 2.8369140625,
          "content": "package tview\n\nimport \"github.com/gdamore/tcell/v2\"\n\n// Primitive is the top-most interface for all graphical primitives.\ntype Primitive interface {\n\t// Draw draws this primitive onto the screen. Implementers can call the\n\t// screen's ShowCursor() function but should only do so when they have focus.\n\t// (They will need to keep track of this themselves.)\n\tDraw(screen tcell.Screen)\n\n\t// GetRect returns the current position of the primitive, x, y, width, and\n\t// height.\n\tGetRect() (int, int, int, int)\n\n\t// SetRect sets a new position of the primitive.\n\tSetRect(x, y, width, height int)\n\n\t// InputHandler returns a handler which receives key events when it has focus.\n\t// It is called by the Application class.\n\t//\n\t// A value of nil may also be returned, in which case this primitive cannot\n\t// receive focus and will not process any key events.\n\t//\n\t// The handler will receive the key event and a function that allows it to\n\t// set the focus to a different primitive, so that future key events are sent\n\t// to that primitive.\n\t//\n\t// The Application's Draw() function will be called automatically after the\n\t// handler returns.\n\t//\n\t// The Box class provides functionality to intercept keyboard input. If you\n\t// subclass from Box, it is recommended that you wrap your handler using\n\t// Box.WrapInputHandler() so you inherit that functionality.\n\tInputHandler() func(event *tcell.EventKey, setFocus func(p Primitive))\n\n\t// Focus is called by the application when the primitive receives focus.\n\t// Implementers may call delegate() to pass the focus on to another primitive.\n\tFocus(delegate func(p Primitive))\n\n\t// HasFocus determines if the primitive has focus. This function must return\n\t// true also if one of this primitive's child elements has focus.\n\tHasFocus() bool\n\n\t// Blur is called by the application when the primitive loses focus.\n\tBlur()\n\n\t// MouseHandler returns a handler which receives mouse events.\n\t// It is called by the Application class.\n\t//\n\t// A value of nil may also be returned to stop the downward propagation of\n\t// mouse events.\n\t//\n\t// The Box class provides functionality to intercept mouse events. If you\n\t// subclass from Box, it is recommended that you wrap your handler using\n\t// Box.WrapMouseHandler() so you inherit that functionality.\n\tMouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive)\n\n\t// PasteHandler returns a handler which receives pasted text.\n\t// It is called by the Application class.\n\t//\n\t// A value of nil may also be returned to stop the downward propagation of\n\t// paste events.\n\t//\n\t// The Box class may provide functionality to intercept paste events in the\n\t// future. If you subclass from Box, it is recommended that you wrap your\n\t// handler using Box.WrapPasteHandler() so you inherit that functionality.\n\tPasteHandler() func(text string, setFocus func(p Primitive))\n}\n"
        },
        {
          "name": "semigraphics.go",
          "type": "blob",
          "size": 20.255859375,
          "content": "package tview\n\nimport \"github.com/gdamore/tcell/v2\"\n\n// Semigraphics provides an easy way to access unicode characters for drawing.\n//\n// Named like the unicode characters, 'Semigraphics'-prefix used if unicode block\n// isn't prefixed itself.\nconst (\n\t// Block: General Punctuation U+2000-U+206F (http://unicode.org/charts/PDF/U2000.pdf)\n\tSemigraphicsHorizontalEllipsis rune = '\\u2026' // \n\n\t// Block: Box Drawing U+2500-U+257F (http://unicode.org/charts/PDF/U2500.pdf)\n\tBoxDrawingsLightHorizontal                    rune = '\\u2500' // \n\tBoxDrawingsHeavyHorizontal                    rune = '\\u2501' // \n\tBoxDrawingsLightVertical                      rune = '\\u2502' // \n\tBoxDrawingsHeavyVertical                      rune = '\\u2503' // \n\tBoxDrawingsLightTripleDashHorizontal          rune = '\\u2504' // \n\tBoxDrawingsHeavyTripleDashHorizontal          rune = '\\u2505' // \n\tBoxDrawingsLightTripleDashVertical            rune = '\\u2506' // \n\tBoxDrawingsHeavyTripleDashVertical            rune = '\\u2507' // \n\tBoxDrawingsLightQuadrupleDashHorizontal       rune = '\\u2508' // \n\tBoxDrawingsHeavyQuadrupleDashHorizontal       rune = '\\u2509' // \n\tBoxDrawingsLightQuadrupleDashVertical         rune = '\\u250a' // \n\tBoxDrawingsHeavyQuadrupleDashVertical         rune = '\\u250b' // \n\tBoxDrawingsLightDownAndRight                  rune = '\\u250c' // \n\tBoxDrawingsDownLightAndRightHeavy             rune = '\\u250d' // \n\tBoxDrawingsDownHeavyAndRightLight             rune = '\\u250e' // \n\tBoxDrawingsHeavyDownAndRight                  rune = '\\u250f' // \n\tBoxDrawingsLightDownAndLeft                   rune = '\\u2510' // \n\tBoxDrawingsDownLightAndLeftHeavy              rune = '\\u2511' // \n\tBoxDrawingsDownHeavyAndLeftLight              rune = '\\u2512' // \n\tBoxDrawingsHeavyDownAndLeft                   rune = '\\u2513' // \n\tBoxDrawingsLightUpAndRight                    rune = '\\u2514' // \n\tBoxDrawingsUpLightAndRightHeavy               rune = '\\u2515' // \n\tBoxDrawingsUpHeavyAndRightLight               rune = '\\u2516' // \n\tBoxDrawingsHeavyUpAndRight                    rune = '\\u2517' // \n\tBoxDrawingsLightUpAndLeft                     rune = '\\u2518' // \n\tBoxDrawingsUpLightAndLeftHeavy                rune = '\\u2519' // \n\tBoxDrawingsUpHeavyAndLeftLight                rune = '\\u251a' // \n\tBoxDrawingsHeavyUpAndLeft                     rune = '\\u251b' // \n\tBoxDrawingsLightVerticalAndRight              rune = '\\u251c' // \n\tBoxDrawingsVerticalLightAndRightHeavy         rune = '\\u251d' // \n\tBoxDrawingsUpHeavyAndRightDownLight           rune = '\\u251e' // \n\tBoxDrawingsDownHeavyAndRightUpLight           rune = '\\u251f' // \n\tBoxDrawingsVerticalHeavyAndRightLight         rune = '\\u2520' // \n\tBoxDrawingsDownLightAndRightUpHeavy           rune = '\\u2521' // \n\tBoxDrawingsUpLightAndRightDownHeavy           rune = '\\u2522' // \n\tBoxDrawingsHeavyVerticalAndRight              rune = '\\u2523' // \n\tBoxDrawingsLightVerticalAndLeft               rune = '\\u2524' // \n\tBoxDrawingsVerticalLightAndLeftHeavy          rune = '\\u2525' // \n\tBoxDrawingsUpHeavyAndLeftDownLight            rune = '\\u2526' // \n\tBoxDrawingsDownHeavyAndLeftUpLight            rune = '\\u2527' // \n\tBoxDrawingsVerticalHeavyAndLeftLight          rune = '\\u2528' // \n\tBoxDrawingsDownLightAndLeftUpHeavy            rune = '\\u2529' // \n\tBoxDrawingsUpLightAndLeftDownHeavy            rune = '\\u252a' // \n\tBoxDrawingsHeavyVerticalAndLeft               rune = '\\u252b' // \n\tBoxDrawingsLightDownAndHorizontal             rune = '\\u252c' // \n\tBoxDrawingsLeftHeavyAndRightDownLight         rune = '\\u252d' // \n\tBoxDrawingsRightHeavyAndLeftDownLight         rune = '\\u252e' // \n\tBoxDrawingsDownLightAndHorizontalHeavy        rune = '\\u252f' // \n\tBoxDrawingsDownHeavyAndHorizontalLight        rune = '\\u2530' // \n\tBoxDrawingsRightLightAndLeftDownHeavy         rune = '\\u2531' // \n\tBoxDrawingsLeftLightAndRightDownHeavy         rune = '\\u2532' // \n\tBoxDrawingsHeavyDownAndHorizontal             rune = '\\u2533' // \n\tBoxDrawingsLightUpAndHorizontal               rune = '\\u2534' // \n\tBoxDrawingsLeftHeavyAndRightUpLight           rune = '\\u2535' // \n\tBoxDrawingsRightHeavyAndLeftUpLight           rune = '\\u2536' // \n\tBoxDrawingsUpLightAndHorizontalHeavy          rune = '\\u2537' // \n\tBoxDrawingsUpHeavyAndHorizontalLight          rune = '\\u2538' // \n\tBoxDrawingsRightLightAndLeftUpHeavy           rune = '\\u2539' // \n\tBoxDrawingsLeftLightAndRightUpHeavy           rune = '\\u253a' // \n\tBoxDrawingsHeavyUpAndHorizontal               rune = '\\u253b' // \n\tBoxDrawingsLightVerticalAndHorizontal         rune = '\\u253c' // \n\tBoxDrawingsLeftHeavyAndRightVerticalLight     rune = '\\u253d' // \n\tBoxDrawingsRightHeavyAndLeftVerticalLight     rune = '\\u253e' // \n\tBoxDrawingsVerticalLightAndHorizontalHeavy    rune = '\\u253f' // \n\tBoxDrawingsUpHeavyAndDownHorizontalLight      rune = '\\u2540' // \n\tBoxDrawingsDownHeavyAndUpHorizontalLight      rune = '\\u2541' // \n\tBoxDrawingsVerticalHeavyAndHorizontalLight    rune = '\\u2542' // \n\tBoxDrawingsLeftUpHeavyAndRightDownLight       rune = '\\u2543' // \n\tBoxDrawingsRightUpHeavyAndLeftDownLight       rune = '\\u2544' // \n\tBoxDrawingsLeftDownHeavyAndRightUpLight       rune = '\\u2545' // \n\tBoxDrawingsRightDownHeavyAndLeftUpLight       rune = '\\u2546' // \n\tBoxDrawingsDownLightAndUpHorizontalHeavy      rune = '\\u2547' // \n\tBoxDrawingsUpLightAndDownHorizontalHeavy      rune = '\\u2548' // \n\tBoxDrawingsRightLightAndLeftVerticalHeavy     rune = '\\u2549' // \n\tBoxDrawingsLeftLightAndRightVerticalHeavy     rune = '\\u254a' // \n\tBoxDrawingsHeavyVerticalAndHorizontal         rune = '\\u254b' // \n\tBoxDrawingsLightDoubleDashHorizontal          rune = '\\u254c' // \n\tBoxDrawingsHeavyDoubleDashHorizontal          rune = '\\u254d' // \n\tBoxDrawingsLightDoubleDashVertical            rune = '\\u254e' // \n\tBoxDrawingsHeavyDoubleDashVertical            rune = '\\u254f' // \n\tBoxDrawingsDoubleHorizontal                   rune = '\\u2550' // \n\tBoxDrawingsDoubleVertical                     rune = '\\u2551' // \n\tBoxDrawingsDownSingleAndRightDouble           rune = '\\u2552' // \n\tBoxDrawingsDownDoubleAndRightSingle           rune = '\\u2553' // \n\tBoxDrawingsDoubleDownAndRight                 rune = '\\u2554' // \n\tBoxDrawingsDownSingleAndLeftDouble            rune = '\\u2555' // \n\tBoxDrawingsDownDoubleAndLeftSingle            rune = '\\u2556' // \n\tBoxDrawingsDoubleDownAndLeft                  rune = '\\u2557' // \n\tBoxDrawingsUpSingleAndRightDouble             rune = '\\u2558' // \n\tBoxDrawingsUpDoubleAndRightSingle             rune = '\\u2559' // \n\tBoxDrawingsDoubleUpAndRight                   rune = '\\u255a' // \n\tBoxDrawingsUpSingleAndLeftDouble              rune = '\\u255b' // \n\tBoxDrawingsUpDoubleAndLeftSingle              rune = '\\u255c' // \n\tBoxDrawingsDoubleUpAndLeft                    rune = '\\u255d' // \n\tBoxDrawingsVerticalSingleAndRightDouble       rune = '\\u255e' // \n\tBoxDrawingsVerticalDoubleAndRightSingle       rune = '\\u255f' // \n\tBoxDrawingsDoubleVerticalAndRight             rune = '\\u2560' // \n\tBoxDrawingsVerticalSingleAndLeftDouble        rune = '\\u2561' // \n\tBoxDrawingsVerticalDoubleAndLeftSingle        rune = '\\u2562' // \n\tBoxDrawingsDoubleVerticalAndLeft              rune = '\\u2563' // \n\tBoxDrawingsDownSingleAndHorizontalDouble      rune = '\\u2564' // \n\tBoxDrawingsDownDoubleAndHorizontalSingle      rune = '\\u2565' // \n\tBoxDrawingsDoubleDownAndHorizontal            rune = '\\u2566' // \n\tBoxDrawingsUpSingleAndHorizontalDouble        rune = '\\u2567' // \n\tBoxDrawingsUpDoubleAndHorizontalSingle        rune = '\\u2568' // \n\tBoxDrawingsDoubleUpAndHorizontal              rune = '\\u2569' // \n\tBoxDrawingsVerticalSingleAndHorizontalDouble  rune = '\\u256a' // \n\tBoxDrawingsVerticalDoubleAndHorizontalSingle  rune = '\\u256b' // \n\tBoxDrawingsDoubleVerticalAndHorizontal        rune = '\\u256c' // \n\tBoxDrawingsLightArcDownAndRight               rune = '\\u256d' // \n\tBoxDrawingsLightArcDownAndLeft                rune = '\\u256e' // \n\tBoxDrawingsLightArcUpAndLeft                  rune = '\\u256f' // \n\tBoxDrawingsLightArcUpAndRight                 rune = '\\u2570' // \n\tBoxDrawingsLightDiagonalUpperRightToLowerLeft rune = '\\u2571' // \n\tBoxDrawingsLightDiagonalUpperLeftToLowerRight rune = '\\u2572' // \n\tBoxDrawingsLightDiagonalCross                 rune = '\\u2573' // \n\tBoxDrawingsLightLeft                          rune = '\\u2574' // \n\tBoxDrawingsLightUp                            rune = '\\u2575' // \n\tBoxDrawingsLightRight                         rune = '\\u2576' // \n\tBoxDrawingsLightDown                          rune = '\\u2577' // \n\tBoxDrawingsHeavyLeft                          rune = '\\u2578' // \n\tBoxDrawingsHeavyUp                            rune = '\\u2579' // \n\tBoxDrawingsHeavyRight                         rune = '\\u257a' // \n\tBoxDrawingsHeavyDown                          rune = '\\u257b' // \n\tBoxDrawingsLightLeftAndHeavyRight             rune = '\\u257c' // \n\tBoxDrawingsLightUpAndHeavyDown                rune = '\\u257d' // \n\tBoxDrawingsHeavyLeftAndLightRight             rune = '\\u257e' // \n\tBoxDrawingsHeavyUpAndLightDown                rune = '\\u257f' // \n\n\t// Block Elements.\n\tBlockUpperHalfBlock                              rune = '\\u2580' // \n\tBlockLowerOneEighthBlock                         rune = '\\u2581' // \n\tBlockLowerOneQuarterBlock                        rune = '\\u2582' // \n\tBlockLowerThreeEighthsBlock                      rune = '\\u2583' // \n\tBlockLowerHalfBlock                              rune = '\\u2584' // \n\tBlockLowerFiveEighthsBlock                       rune = '\\u2585' // \n\tBlockLowerThreeQuartersBlock                     rune = '\\u2586' // \n\tBlockLowerSevenEighthsBlock                      rune = '\\u2587' // \n\tBlockFullBlock                                   rune = '\\u2588' // \n\tBlockLeftSevenEighthsBlock                       rune = '\\u2589' // \n\tBlockLeftThreeQuartersBlock                      rune = '\\u258A' // \n\tBlockLeftFiveEighthsBlock                        rune = '\\u258B' // \n\tBlockLeftHalfBlock                               rune = '\\u258C' // \n\tBlockLeftThreeEighthsBlock                       rune = '\\u258D' // \n\tBlockLeftOneQuarterBlock                         rune = '\\u258E' // \n\tBlockLeftOneEighthBlock                          rune = '\\u258F' // \n\tBlockRightHalfBlock                              rune = '\\u2590' // \n\tBlockLightShade                                  rune = '\\u2591' // \n\tBlockMediumShade                                 rune = '\\u2592' // \n\tBlockDarkShade                                   rune = '\\u2593' // \n\tBlockUpperOneEighthBlock                         rune = '\\u2594' // \n\tBlockRightOneEighthBlock                         rune = '\\u2595' // \n\tBlockQuadrantLowerLeft                           rune = '\\u2596' // \n\tBlockQuadrantLowerRight                          rune = '\\u2597' // \n\tBlockQuadrantUpperLeft                           rune = '\\u2598' // \n\tBlockQuadrantUpperLeftAndLowerLeftAndLowerRight  rune = '\\u2599' // \n\tBlockQuadrantUpperLeftAndLowerRight              rune = '\\u259A' // \n\tBlockQuadrantUpperLeftAndUpperRightAndLowerLeft  rune = '\\u259B' // \n\tBlockQuadrantUpperLeftAndUpperRightAndLowerRight rune = '\\u259C' // \n\tBlockQuadrantUpperRight                          rune = '\\u259D' // \n\tBlockQuadrantUpperRightAndLowerLeft              rune = '\\u259E' // \n\tBlockQuadrantUpperRightAndLowerLeftAndLowerRight rune = '\\u259F' // \n)\n\n// SemigraphicJoints is a map for joining semigraphic (or otherwise) runes.\n// So far only light lines are supported but if you want to change the border\n// styling you need to provide the joints, too.\n// The matching will be sorted ascending by rune value, so you don't need to\n// provide all rune combinations,\n// e.g. () + () = () will also match () + () = ()\nvar SemigraphicJoints = map[string]rune{\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightVertical}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightDownAndRight}): BoxDrawingsLightDownAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightDownAndLeft}): BoxDrawingsLightDownAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightUpAndRight}): BoxDrawingsLightUpAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightUpAndLeft}): BoxDrawingsLightUpAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightVerticalAndRight}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightVerticalAndLeft}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightDownAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightUpAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightHorizontal, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightDownAndRight}): BoxDrawingsLightVerticalAndRight,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightDownAndLeft}): BoxDrawingsLightVerticalAndLeft,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightUpAndRight}): BoxDrawingsLightVerticalAndRight,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightUpAndLeft}): BoxDrawingsLightVerticalAndLeft,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightVerticalAndRight}): BoxDrawingsLightVerticalAndRight,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightVerticalAndLeft}): BoxDrawingsLightVerticalAndLeft,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVertical, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightDownAndLeft}): BoxDrawingsLightDownAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightUpAndRight}): BoxDrawingsLightVerticalAndRight,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightUpAndLeft}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightVerticalAndRight}): BoxDrawingsLightVerticalAndRight,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightVerticalAndLeft}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightDownAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndRight, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndLeft, BoxDrawingsLightUpAndRight}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndLeft, BoxDrawingsLightUpAndLeft}): BoxDrawingsLightVerticalAndLeft,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndLeft, BoxDrawingsLightVerticalAndRight}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndLeft, BoxDrawingsLightVerticalAndLeft}): BoxDrawingsLightVerticalAndLeft,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndLeft, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightDownAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndLeft, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndLeft, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndRight, BoxDrawingsLightUpAndLeft}): BoxDrawingsLightUpAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndRight, BoxDrawingsLightVerticalAndRight}): BoxDrawingsLightVerticalAndRight,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndRight, BoxDrawingsLightVerticalAndLeft}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndRight, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndRight, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightUpAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndRight, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndLeft, BoxDrawingsLightVerticalAndRight}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndLeft, BoxDrawingsLightVerticalAndLeft}): BoxDrawingsLightVerticalAndLeft,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndLeft, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndLeft, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightUpAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndLeft, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVerticalAndRight, BoxDrawingsLightVerticalAndLeft}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVerticalAndRight, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVerticalAndRight, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVerticalAndRight, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVerticalAndLeft, BoxDrawingsLightDownAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVerticalAndLeft, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightVerticalAndLeft, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndHorizontal, BoxDrawingsLightUpAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightDownAndHorizontal, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n\n\t// () + () = ()\n\tstring([]rune{BoxDrawingsLightUpAndHorizontal, BoxDrawingsLightVerticalAndHorizontal}): BoxDrawingsLightVerticalAndHorizontal,\n}\n\n// PrintJoinedSemigraphics prints a semigraphics rune into the screen at the given\n// position with the given style, joining it with any existing semigraphics\n// rune.At this point, only regular single line borders are supported.\nfunc PrintJoinedSemigraphics(screen tcell.Screen, x, y int, ch rune, style tcell.Style) {\n\tprevious, _, _, _ := screen.GetContent(x, y)\n\n\t// What's the resulting rune?\n\tvar result rune\n\tif ch == previous {\n\t\tresult = ch\n\t} else {\n\t\tif ch < previous {\n\t\t\tprevious, ch = ch, previous\n\t\t}\n\t\tresult = SemigraphicJoints[string([]rune{previous, ch})]\n\t}\n\tif result == 0 {\n\t\tresult = ch\n\t}\n\n\t// We only print something if we have something.\n\tscreen.SetContent(x, y, result, nil, style)\n}\n"
        },
        {
          "name": "strings.go",
          "type": "blob",
          "size": 18.4267578125,
          "content": "package tview\n\nimport (\n\t\"math/rand\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gdamore/tcell/v2\"\n\t\"github.com/rivo/uniseg\"\n)\n\n// escapedTagPattern matches an escaped tag, e.g. \"[red[]\", at the beginning of\n// a string.\nvar escapedTagPattern = regexp.MustCompile(`^\\[[^\\[\\]]+\\[+\\]`)\n\n// stepOptions is a bit field of options for [step]. A value of 0 results in\n// [step] having the same behavior as uniseg.Step, i.e. no tview-related parsing\n// is performed.\ntype stepOptions int\n\n// Bit fields for [stepOptions].\nconst (\n\tstepOptionsNone   stepOptions = 0\n\tstepOptionsStyle  stepOptions = 1 << iota // Parse style tags.\n\tstepOptionsRegion                         // Parse region tags.\n)\n\n// stepState represents the current state of the parser implemented in [step].\ntype stepState struct {\n\tunisegState     int         // The state of the uniseg parser.\n\tboundaries      int         // Information about boundaries, as returned by uniseg.Step.\n\tstyle           tcell.Style // The current style.\n\tregion          string      // The current region.\n\tescapedTagState int         // States for parsing escaped tags (defined in [step]).\n\tgrossLength     int         // The length of the cluster, including any tags not returned.\n\n\t// The styles for the initial call to [step].\n\tinitialForeground tcell.Color\n\tinitialBackground tcell.Color\n\tinitialAttributes tcell.AttrMask\n}\n\n// IsWordBoundary returns true if the boundary between the returned grapheme\n// cluster and the one following it is a word boundary.\nfunc (s *stepState) IsWordBoundary() bool {\n\treturn s.boundaries&uniseg.MaskWord != 0\n}\n\n// IsSentenceBoundary returns true if the boundary between the returned grapheme\n// cluster and the one following it is a sentence boundary.\nfunc (s *stepState) IsSentenceBoundary() bool {\n\treturn s.boundaries&uniseg.MaskSentence != 0\n}\n\n// LineBreak returns whether the string can be broken into the next line after\n// the returned grapheme cluster. If optional is true, the line break is\n// optional. If false, the line break is mandatory, e.g. after a newline\n// character.\nfunc (s *stepState) LineBreak() (lineBreak, optional bool) {\n\tswitch s.boundaries & uniseg.MaskLine {\n\tcase uniseg.LineCanBreak:\n\t\treturn true, true\n\tcase uniseg.LineMustBreak:\n\t\treturn true, false\n\t}\n\treturn false, false // uniseg.LineDontBreak.\n}\n\n// Width returns the grapheme cluster's width in cells.\nfunc (s *stepState) Width() int {\n\treturn s.boundaries >> uniseg.ShiftWidth\n}\n\n// GrossLength returns the grapheme cluster's length in bytes, including any\n// tags that were parsed but not explicitly returned.\nfunc (s *stepState) GrossLength() int {\n\treturn s.grossLength\n}\n\n// Style returns the style for the grapheme cluster.\nfunc (s *stepState) Style() tcell.Style {\n\treturn s.style\n}\n\n// step uses uniseg.Step to iterate over the grapheme clusters of a string but\n// (optionally) also parses the string for style or region tags.\n//\n// This function can be called consecutively to extract all grapheme clusters\n// from str, without returning any contained (parsed) tags. The return values\n// are the first grapheme cluster, the remaining string, and the new state. Pass\n// the remaining string and the returned state to the next call. If the rest\n// string is empty, parsing is complete. Call the returned state's methods for\n// boundary and cluster width information.\n//\n// The returned cluster may be empty if the given string consists of only\n// (parsed) tags. The boundary and width information will be meaningless in\n// this case but the style will describe the style at the end of the string.\n//\n// Pass nil for state on the first call. This will assume an initial style with\n// [Styles.PrimitiveBackgroundColor] as the background color and\n// [Styles.PrimaryTextColor] as the text color, no current region. If you want\n// to start with a different style or region, you can set the state accordingly\n// but you must then set [state.unisegState] to -1.\n//\n// There is no need to call uniseg.HasTrailingLineBreakInString on the last\n// non-empty cluster as this function will do this for you and adjust the\n// returned boundaries accordingly.\nfunc step(str string, state *stepState, opts stepOptions) (cluster, rest string, newState *stepState) {\n\t// Set up initial state.\n\tif state == nil {\n\t\tstate = &stepState{\n\t\t\tunisegState: -1,\n\t\t\tstyle:       tcell.StyleDefault.Background(Styles.PrimitiveBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\t}\n\t}\n\tif state.unisegState < 0 {\n\t\tstate.initialForeground, state.initialBackground, state.initialAttributes = state.style.Decompose()\n\t}\n\tif len(str) == 0 {\n\t\tnewState = state\n\t\treturn\n\t}\n\n\t// Get a grapheme cluster.\n\tpreState := state.unisegState\n\tcluster, rest, state.boundaries, state.unisegState = uniseg.StepString(str, preState)\n\tstate.grossLength = len(cluster)\n\tif rest == \"\" {\n\t\tif !uniseg.HasTrailingLineBreakInString(cluster) {\n\t\t\tstate.boundaries &^= uniseg.MaskLine\n\t\t}\n\t}\n\n\t// Parse tags.\n\tif opts != 0 {\n\t\tconst (\n\t\t\tetNone int = iota\n\t\t\tetStart\n\t\t\tetChar\n\t\t\tetClosing\n\t\t)\n\n\t\t// Finite state machine for escaped tags.\n\t\tswitch state.escapedTagState {\n\t\tcase etStart:\n\t\t\tif cluster[0] == '[' || cluster[0] == ']' { // Invalid escaped tag.\n\t\t\t\tstate.escapedTagState = etNone\n\t\t\t} else { // Other characters are allowed.\n\t\t\t\tstate.escapedTagState = etChar\n\t\t\t}\n\t\tcase etChar:\n\t\t\tif cluster[0] == ']' { // In theory, this should not happen.\n\t\t\t\tstate.escapedTagState = etNone\n\t\t\t} else if cluster[0] == '[' { // Starting closing sequence.\n\t\t\t\t// Swallow the first one.\n\t\t\t\tcluster, rest, state.boundaries, state.unisegState = uniseg.StepString(rest, preState)\n\t\t\t\tstate.grossLength += len(cluster)\n\t\t\t\tif cluster[0] == ']' {\n\t\t\t\t\tstate.escapedTagState = etNone\n\t\t\t\t} else {\n\t\t\t\t\tstate.escapedTagState = etClosing\n\t\t\t\t}\n\t\t\t} // More characters. Remain in etChar.\n\t\tcase etClosing:\n\t\t\tif cluster[0] != '[' {\n\t\t\t\tstate.escapedTagState = etNone\n\t\t\t}\n\t\t}\n\n\t\t// Regular tags.\n\t\tif state.escapedTagState == etNone {\n\t\t\tif cluster[0] == '[' {\n\t\t\t\t// We've already opened a tag. Parse it.\n\t\t\t\tlength, style, region := parseTag(str, state)\n\t\t\t\tif length > 0 {\n\t\t\t\t\tstate.style = style\n\t\t\t\t\tstate.region = region\n\t\t\t\t\tcluster, rest, state.boundaries, state.unisegState = uniseg.StepString(str[length:], preState)\n\t\t\t\t\tstate.grossLength = len(cluster) + length\n\t\t\t\t\tif rest == \"\" {\n\t\t\t\t\t\tif !uniseg.HasTrailingLineBreakInString(cluster) {\n\t\t\t\t\t\t\tstate.boundaries &^= uniseg.MaskLine\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Is this an escaped tag?\n\t\t\t\tif escapedTagPattern.MatchString(str[length:]) {\n\t\t\t\t\tstate.escapedTagState = etStart\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(rest) > 0 && rest[0] == '[' {\n\t\t\t\t// A tag might follow the cluster. If so, we need to fix the state\n\t\t\t\t// for the boundaries to be correct.\n\t\t\t\tif length, _, _ := parseTag(rest, state); length > 0 {\n\t\t\t\t\tif len(rest) > length {\n\t\t\t\t\t\t_, l := utf8.DecodeRuneInString(rest[length:])\n\t\t\t\t\t\tcluster += rest[length : length+l]\n\t\t\t\t\t}\n\t\t\t\t\tvar taglessRest string\n\t\t\t\t\tcluster, taglessRest, state.boundaries, state.unisegState = uniseg.StepString(cluster, preState)\n\t\t\t\t\tif taglessRest == \"\" {\n\t\t\t\t\t\tif !uniseg.HasTrailingLineBreakInString(cluster) {\n\t\t\t\t\t\t\tstate.boundaries &^= uniseg.MaskLine\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnewState = state\n\treturn\n}\n\n// parseTag parses str for consecutive style and/or region tags, assuming that\n// str starts with the opening bracket for the first tag. It returns the string\n// length of all valid tags (0 if the first tag is not valid) and the updated\n// style and region for valid tags (based on the provided state).\nfunc parseTag(str string, state *stepState) (length int, style tcell.Style, region string) {\n\t// Automata states for parsing tags.\n\tconst (\n\t\ttagStateNone = iota\n\t\ttagStateDoneTag\n\t\ttagStateStart\n\t\ttagStateRegionStart\n\t\ttagStateEndForeground\n\t\ttagStateStartBackground\n\t\ttagStateNumericForeground\n\t\ttagStateNameForeground\n\t\ttagStateEndBackground\n\t\ttagStateStartAttributes\n\t\ttagStateNumericBackground\n\t\ttagStateNameBackground\n\t\ttagStateAttributes\n\t\ttagStateRegionEnd\n\t\ttagStateRegionName\n\t\ttagStateEndAttributes\n\t\ttagStateStartURL\n\t\ttagStateEndURL\n\t\ttagStateURL\n\t)\n\n\t// Helper function which checks if the given byte is one of a list of\n\t// characters, including letters and digits.\n\tisOneOf := func(b byte, chars string) bool {\n\t\tif b >= 'a' && b <= 'z' || b >= 'A' && b <= 'Z' || b >= '0' && b <= '9' {\n\t\t\treturn true\n\t\t}\n\t\treturn strings.IndexByte(chars, b) >= 0\n\t}\n\n\t// Attribute map.\n\tattrs := map[byte]tcell.AttrMask{\n\t\t'B': tcell.AttrBold,\n\t\t'U': tcell.AttrUnderline,\n\t\t'I': tcell.AttrItalic,\n\t\t'L': tcell.AttrBlink,\n\t\t'D': tcell.AttrDim,\n\t\t'S': tcell.AttrStrikeThrough,\n\t\t'R': tcell.AttrReverse,\n\t}\n\n\tvar (\n\t\ttagState, tagLength int\n\t\ttempStr             strings.Builder\n\t)\n\ttStyle := state.style\n\ttRegion := state.region\n\n\t// Process state transitions.\n\tfor len(str) > 0 {\n\t\tch := str[0]\n\t\tstr = str[1:]\n\t\ttagLength++\n\n\t\t// Transition.\n\t\tswitch tagState {\n\t\tcase tagStateNone:\n\t\t\tif ch == '[' { // Start of a tag.\n\t\t\t\ttagState = tagStateStart\n\t\t\t} else { // Not a tag. We're done.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateStart:\n\t\t\tif ch == '\"' { // Start of a region tag.\n\t\t\t\ttempStr.Reset()\n\t\t\t\ttagState = tagStateRegionStart\n\t\t\t} else if !isOneOf(ch, \"#:-\") { // Invalid style tag.\n\t\t\t\treturn\n\t\t\t} else if ch == '-' { // Reset foreground color.\n\t\t\t\ttStyle = tStyle.Foreground(state.initialForeground)\n\t\t\t\ttagState = tagStateEndForeground\n\t\t\t} else if ch == ':' { // No foreground color.\n\t\t\t\ttagState = tagStateStartBackground\n\t\t\t} else {\n\t\t\t\ttempStr.Reset()\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t\tif ch == '#' { // Numeric foreground color.\n\t\t\t\t\ttagState = tagStateNumericForeground\n\t\t\t\t} else { // Letters or numbers.\n\t\t\t\t\ttagState = tagStateNameForeground\n\t\t\t\t}\n\t\t\t}\n\t\tcase tagStateEndForeground:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' {\n\t\t\t\ttagState = tagStateStartBackground\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateNumericForeground:\n\t\t\tif ch == ']' || ch == ':' {\n\t\t\t\tif tempStr.Len() != 7 { // Must be #rrggbb.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttStyle = tStyle.Foreground(tcell.GetColor(tempStr.String()))\n\t\t\t}\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' { // Start of background color.\n\t\t\t\ttagState = tagStateStartBackground\n\t\t\t} else if strings.IndexByte(\"0123456789abcdefABCDEF\", ch) >= 0 { // Hex digit.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t\ttagState = tagStateNumericForeground\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateNameForeground:\n\t\t\tif ch == ']' || ch == ':' {\n\t\t\t\tname := tempStr.String()\n\t\t\t\tif name[0] >= '0' && name[0] <= '9' { // Must not start with a digit.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttStyle = tStyle.Foreground(tcell.ColorNames[name])\n\t\t\t}\n\t\t\tif !isOneOf(ch, \"]:\") { // Invalid tag.\n\t\t\t\treturn\n\t\t\t} else if ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' { // Start of background color.\n\t\t\t\ttagState = tagStateStartBackground\n\t\t\t} else { // Letters or numbers.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t}\n\t\tcase tagStateStartBackground:\n\t\t\tif !isOneOf(ch, \"#:-]\") { // Invalid style tag.\n\t\t\t\treturn\n\t\t\t} else if ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == '-' { // Reset background color.\n\t\t\t\ttStyle = tStyle.Background(state.initialBackground)\n\t\t\t\ttagState = tagStateEndBackground\n\t\t\t} else if ch == ':' { // No background color.\n\t\t\t\ttagState = tagStateStartAttributes\n\t\t\t} else {\n\t\t\t\ttempStr.Reset()\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t\tif ch == '#' { // Numeric background color.\n\t\t\t\t\ttagState = tagStateNumericBackground\n\t\t\t\t} else { // Letters or numbers.\n\t\t\t\t\ttagState = tagStateNameBackground\n\t\t\t\t}\n\t\t\t}\n\t\tcase tagStateEndBackground:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' { // Start of attributes.\n\t\t\t\ttagState = tagStateStartAttributes\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateNumericBackground:\n\t\t\tif ch == ']' || ch == ':' {\n\t\t\t\tif tempStr.Len() != 7 { // Must be #rrggbb.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttStyle = tStyle.Background(tcell.GetColor(tempStr.String()))\n\t\t\t}\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' { // Start of attributes.\n\t\t\t\ttagState = tagStateStartAttributes\n\t\t\t} else if strings.IndexByte(\"0123456789abcdefABCDEF\", ch) >= 0 { // Hex digit.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t\ttagState = tagStateNumericBackground\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateNameBackground:\n\t\t\tif ch == ']' || ch == ':' {\n\t\t\t\tname := tempStr.String()\n\t\t\t\tif name[0] >= '0' && name[0] <= '9' { // Must not start with a digit.\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttStyle = tStyle.Background(tcell.ColorNames[name])\n\t\t\t}\n\t\t\tif !isOneOf(ch, \"]:\") { // Invalid tag.\n\t\t\t\treturn\n\t\t\t} else if ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' { // Start of background color.\n\t\t\t\ttagState = tagStateStartAttributes\n\t\t\t} else { // Letters or numbers.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t}\n\t\tcase tagStateStartAttributes:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == '-' { // Reset attributes.\n\t\t\t\ttStyle = tStyle.Attributes(state.initialAttributes)\n\t\t\t\ttagState = tagStateEndAttributes\n\t\t\t} else if ch == ':' { // Start of URL.\n\t\t\t\ttagState = tagStateStartURL\n\t\t\t} else if strings.IndexByte(\"buildsrBUILDSR\", ch) >= 0 { // Attribute tag.\n\t\t\t\ttempStr.Reset()\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t\ttagState = tagStateAttributes\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateAttributes:\n\t\t\tif ch == ']' || ch == ':' {\n\t\t\t\tflags := tempStr.String()\n\t\t\t\t_, _, a := tStyle.Decompose()\n\t\t\t\tfor index := 0; index < len(flags); index++ {\n\t\t\t\t\tch := flags[index]\n\t\t\t\t\tif ch >= 'a' && ch <= 'z' {\n\t\t\t\t\t\ta |= attrs[ch-('a'-'A')]\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta &^= attrs[ch]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttStyle = tStyle.Attributes(a)\n\t\t\t}\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' { // Start of URL.\n\t\t\t\ttagState = tagStateStartURL\n\t\t\t} else if strings.IndexByte(\"buildsrBUILDSR\", ch) >= 0 { // Attribute tag.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateEndAttributes:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == ':' { // Start of URL.\n\t\t\t\ttagState = tagStateStartURL\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateStartURL:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else if ch == '-' { // Reset URL.\n\t\t\t\ttStyle = tStyle.Url(\"\").UrlId(\"\")\n\t\t\t\ttagState = tagStateEndURL\n\t\t\t} else { // URL character.\n\t\t\t\ttempStr.Reset()\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t\ttStyle = tStyle.UrlId(strconv.Itoa(int(rand.Uint32()))) // Generate a unique ID for this URL.\n\t\t\t\ttagState = tagStateURL\n\t\t\t}\n\t\tcase tagStateEndURL:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateURL:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttStyle = tStyle.Url(tempStr.String())\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else { // URL character.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t}\n\t\tcase tagStateRegionStart:\n\t\t\tif ch == '\"' { // End of region tag.\n\t\t\t\ttagState = tagStateRegionEnd\n\t\t\t} else if isOneOf(ch, \"_,;: -.\") { // Region name.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t\ttagState = tagStateRegionName\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateRegionEnd:\n\t\t\tif ch == ']' { // End of tag.\n\t\t\t\ttRegion = tempStr.String()\n\t\t\t\ttagState = tagStateDoneTag\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tagStateRegionName:\n\t\t\tif ch == '\"' { // End of region tag.\n\t\t\t\ttagState = tagStateRegionEnd\n\t\t\t} else if isOneOf(ch, \"_,;: -.\") { // Region name.\n\t\t\t\ttempStr.WriteByte(ch)\n\t\t\t} else { // Invalid tag.\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\t// The last transition led to a tag end. Make the tag permanent.\n\t\tif tagState == tagStateDoneTag {\n\t\t\tlength, style, region = tagLength, tStyle, tRegion\n\t\t\ttagState = tagStateNone // Reset state.\n\t\t}\n\t}\n\n\treturn\n}\n\n// TaggedStringWidth returns the width of the given string needed to print it on\n// screen. The text may contain style tags which are not counted.\nfunc TaggedStringWidth(text string) (width int) {\n\tvar state *stepState\n\tfor len(text) > 0 {\n\t\t_, text, state = step(text, state, stepOptionsStyle)\n\t\twidth += state.Width()\n\t}\n\treturn\n}\n\n// WordWrap splits a text such that each resulting line does not exceed the\n// given screen width. Split points are determined using the algorithm described\n// in [Unicode Standard Annex #14].\n//\n// This function considers style tags to have no width.\n//\n// [Unicode Standard Annex #14]: https://www.unicode.org/reports/tr14/\nfunc WordWrap(text string, width int) (lines []string) {\n\tif width <= 0 {\n\t\treturn\n\t}\n\n\tvar (\n\t\tstate                                              *stepState\n\t\tlineWidth, lineLength, lastOption, lastOptionWidth int\n\t)\n\tstr := text\n\tfor len(str) > 0 {\n\t\t// Parse the next character.\n\t\t_, str, state = step(str, state, stepOptionsStyle)\n\t\tcWidth := state.Width()\n\n\t\t// Would it exceed the line width?\n\t\tif lineWidth+cWidth > width {\n\t\t\tif lastOptionWidth == 0 {\n\t\t\t\t// No split point so far. Just split at the current position.\n\t\t\t\tlines = append(lines, text[:lineLength])\n\t\t\t\ttext = text[lineLength:]\n\t\t\t\tlineWidth, lineLength, lastOption, lastOptionWidth = 0, 0, 0, 0\n\t\t\t} else {\n\t\t\t\t// Split at the last split point.\n\t\t\t\tlines = append(lines, text[:lastOption])\n\t\t\t\ttext = text[lastOption:]\n\t\t\t\tlineWidth -= lastOptionWidth\n\t\t\t\tlineLength -= lastOption\n\t\t\t\tlastOption, lastOptionWidth = 0, 0\n\t\t\t}\n\t\t}\n\n\t\t// Move ahead.\n\t\tlineWidth += cWidth\n\t\tlineLength += state.GrossLength()\n\n\t\t// Check for split points.\n\t\tif lineBreak, optional := state.LineBreak(); lineBreak {\n\t\t\tif optional {\n\t\t\t\t// Remember this split point.\n\t\t\t\tlastOption = lineLength\n\t\t\t\tlastOptionWidth = lineWidth\n\t\t\t} else {\n\t\t\t\t// We must split here.\n\t\t\t\tlines = append(lines, strings.TrimRight(text[:lineLength], \"\\n\\r\"))\n\t\t\t\ttext = text[lineLength:]\n\t\t\t\tlineWidth, lineLength, lastOption, lastOptionWidth = 0, 0, 0, 0\n\t\t\t}\n\t\t}\n\t}\n\tlines = append(lines, text)\n\n\treturn\n}\n\n// Escape escapes the given text such that color and/or region tags are not\n// recognized and substituted by the print functions of this package. For\n// example, to include a tag-like string in a box title or in a TextView:\n//\n//\tbox.SetTitle(tview.Escape(\"[squarebrackets]\"))\n//\tfmt.Fprint(textView, tview.Escape(`[\"quoted\"]`))\nfunc Escape(text string) string {\n\treturn escapePattern.ReplaceAllString(text, \"$1[]\")\n}\n\n// Unescape unescapes text previously escaped with [Escape].\nfunc Unescape(text string) string {\n\treturn unescapePattern.ReplaceAllString(text, \"$1]\")\n}\n\n// stripTags strips style tags from the given string. (Region tags are not\n// stripped.)\nfunc stripTags(text string) string {\n\tvar (\n\t\tstr   strings.Builder\n\t\tstate *stepState\n\t)\n\tfor len(text) > 0 {\n\t\tvar c string\n\t\tc, text, state = step(text, state, stepOptionsStyle)\n\t\tstr.WriteString(c)\n\t}\n\treturn str.String()\n}\n"
        },
        {
          "name": "styles.go",
          "type": "blob",
          "size": 1.64453125,
          "content": "package tview\n\nimport \"github.com/gdamore/tcell/v2\"\n\n// Theme defines the colors used when primitives are initialized.\ntype Theme struct {\n\tPrimitiveBackgroundColor    tcell.Color // Main background color for primitives.\n\tContrastBackgroundColor     tcell.Color // Background color for contrasting elements.\n\tMoreContrastBackgroundColor tcell.Color // Background color for even more contrasting elements.\n\tBorderColor                 tcell.Color // Box borders.\n\tTitleColor                  tcell.Color // Box titles.\n\tGraphicsColor               tcell.Color // Graphics.\n\tPrimaryTextColor            tcell.Color // Primary text.\n\tSecondaryTextColor          tcell.Color // Secondary text (e.g. labels).\n\tTertiaryTextColor           tcell.Color // Tertiary text (e.g. subtitles, notes).\n\tInverseTextColor            tcell.Color // Text on primary-colored backgrounds.\n\tContrastSecondaryTextColor  tcell.Color // Secondary text on ContrastBackgroundColor-colored backgrounds.\n}\n\n// Styles defines the theme for applications. The default is for a black\n// background and some basic colors: black, white, yellow, green, cyan, and\n// blue.\nvar Styles = Theme{\n\tPrimitiveBackgroundColor:    tcell.ColorBlack,\n\tContrastBackgroundColor:     tcell.ColorBlue,\n\tMoreContrastBackgroundColor: tcell.ColorGreen,\n\tBorderColor:                 tcell.ColorWhite,\n\tTitleColor:                  tcell.ColorWhite,\n\tGraphicsColor:               tcell.ColorWhite,\n\tPrimaryTextColor:            tcell.ColorWhite,\n\tSecondaryTextColor:          tcell.ColorYellow,\n\tTertiaryTextColor:           tcell.ColorGreen,\n\tInverseTextColor:            tcell.ColorBlue,\n\tContrastSecondaryTextColor:  tcell.ColorNavy,\n}\n"
        },
        {
          "name": "table.go",
          "type": "blob",
          "size": 51.59375,
          "content": "package tview\n\nimport (\n\t\"sort\"\n\n\t\"github.com/gdamore/tcell/v2\"\n\tcolorful \"github.com/lucasb-eyer/go-colorful\"\n)\n\n// TableCell represents one cell inside a Table. You can instantiate this type\n// directly but all colors (background and text) will be set to their default\n// which is black.\ntype TableCell struct {\n\t// The reference object.\n\tReference interface{}\n\n\t// The text to be displayed in the table cell.\n\tText string\n\n\t// The alignment of the cell text. One of AlignLeft (default), AlignCenter,\n\t// or AlignRight.\n\tAlign int\n\n\t// The maximum width of the cell in screen space. This is used to give a\n\t// column a maximum width. Any cell text whose screen width exceeds this width\n\t// is cut off. Set to 0 if there is no maximum width.\n\tMaxWidth int\n\n\t// If the total table width is less than the available width, this value is\n\t// used to add extra width to a column. See SetExpansion() for details.\n\tExpansion int\n\n\t// The color of the cell text. You should not use this anymore, it is only\n\t// here for backwards compatibility. Use the Style field instead.\n\tColor tcell.Color\n\n\t// The background color of the cell. You should not use this anymore, it is\n\t// only here for backwards compatibility. Use the Style field instead.\n\tBackgroundColor tcell.Color\n\n\t// The style attributes of the cell. You should not use this anymore, it is\n\t// only here for backwards compatibility. Use the Style field instead.\n\tAttributes tcell.AttrMask\n\n\t// The style of the cell. If this is uninitialized (tcell.StyleDefault), the\n\t// Color and BackgroundColor fields are used instead.\n\tStyle tcell.Style\n\n\t// The style of the cell when it is selected. If this is uninitialized\n\t// (tcell.StyleDefault), the table's selected style is used instead. If that\n\t// is uninitialized as well, the cell's background and text color are\n\t// swapped.\n\tSelectedStyle tcell.Style\n\n\t// If set to true, the BackgroundColor is not used and the cell will have\n\t// the background color of the table.\n\tTransparent bool\n\n\t// If set to true, this cell cannot be selected.\n\tNotSelectable bool\n\n\t// An optional handler for mouse clicks. This also fires if the cell is not\n\t// selectable. If true is returned, no additional \"selected\" event is fired\n\t// on selectable cells.\n\tClicked func() bool\n\n\t// The position and width of the cell the last time table was drawn.\n\tx, y, width int\n}\n\n// NewTableCell returns a new table cell with sensible defaults. That is, left\n// aligned text with the primary text color (see Styles) and a transparent\n// background (using the background of the Table).\nfunc NewTableCell(text string) *TableCell {\n\treturn &TableCell{\n\t\tText:        text,\n\t\tAlign:       AlignLeft,\n\t\tStyle:       tcell.StyleDefault.Foreground(Styles.PrimaryTextColor).Background(Styles.PrimitiveBackgroundColor),\n\t\tTransparent: true,\n\t}\n}\n\n// SetText sets the cell's text.\nfunc (c *TableCell) SetText(text string) *TableCell {\n\tc.Text = text\n\treturn c\n}\n\n// SetAlign sets the cell's text alignment, one of AlignLeft, AlignCenter, or\n// AlignRight.\nfunc (c *TableCell) SetAlign(align int) *TableCell {\n\tc.Align = align\n\treturn c\n}\n\n// SetMaxWidth sets maximum width of the cell in screen space. This is used to\n// give a column a maximum width. Any cell text whose screen width exceeds this\n// width is cut off. Set to 0 if there is no maximum width.\nfunc (c *TableCell) SetMaxWidth(maxWidth int) *TableCell {\n\tc.MaxWidth = maxWidth\n\treturn c\n}\n\n// SetExpansion sets the value by which the column of this cell expands if the\n// available width for the table is more than the table width (prior to applying\n// this expansion value). This is a proportional value. The amount of unused\n// horizontal space is divided into widths to be added to each column. How much\n// extra width a column receives depends on the expansion value: A value of 0\n// (the default) will not cause the column to increase in width. Other values\n// are proportional, e.g. a value of 2 will cause a column to grow by twice\n// the amount of a column with a value of 1.\n//\n// Since this value affects an entire column, the maximum over all visible cells\n// in that column is used.\n//\n// This function panics if a negative value is provided.\nfunc (c *TableCell) SetExpansion(expansion int) *TableCell {\n\tif expansion < 0 {\n\t\tpanic(\"Table cell expansion values may not be negative\")\n\t}\n\tc.Expansion = expansion\n\treturn c\n}\n\n// SetTextColor sets the cell's text color.\nfunc (c *TableCell) SetTextColor(color tcell.Color) *TableCell {\n\tif c.Style == tcell.StyleDefault {\n\t\tc.Color = color\n\t} else {\n\t\tc.Style = c.Style.Foreground(color)\n\t}\n\treturn c\n}\n\n// SetBackgroundColor sets the cell's background color. This will also cause the\n// cell's Transparent flag to be set to \"false\".\nfunc (c *TableCell) SetBackgroundColor(color tcell.Color) *TableCell {\n\tif c.Style == tcell.StyleDefault {\n\t\tc.BackgroundColor = color\n\t} else {\n\t\tc.Style = c.Style.Background(color)\n\t}\n\tc.Transparent = false\n\treturn c\n}\n\n// SetTransparency sets the background transparency of this cell. A value of\n// \"true\" will cause the cell to use the table's background color. A value of\n// \"false\" will cause it to use its own background color.\nfunc (c *TableCell) SetTransparency(transparent bool) *TableCell {\n\tc.Transparent = transparent\n\treturn c\n}\n\n// SetAttributes sets the cell's text attributes. You can combine different\n// attributes using bitmask operations:\n//\n//\tcell.SetAttributes(tcell.AttrUnderline | tcell.AttrBold)\nfunc (c *TableCell) SetAttributes(attr tcell.AttrMask) *TableCell {\n\tif c.Style == tcell.StyleDefault {\n\t\tc.Attributes = attr\n\t} else {\n\t\tc.Style = c.Style.Attributes(attr)\n\t}\n\treturn c\n}\n\n// SetStyle sets the cell's style (foreground color, background color, and\n// attributes) all at once.\nfunc (c *TableCell) SetStyle(style tcell.Style) *TableCell {\n\tc.Style = style\n\treturn c\n}\n\n// SetSelectedStyle sets the cell's style when it is selected. If this is\n// uninitialized (tcell.StyleDefault), the table's selected style is used\n// instead. If that is uninitialized as well, the cell's background and text\n// color are swapped.\nfunc (c *TableCell) SetSelectedStyle(style tcell.Style) *TableCell {\n\tc.SelectedStyle = style\n\treturn c\n}\n\n// SetSelectable sets whether or not this cell can be selected by the user.\nfunc (c *TableCell) SetSelectable(selectable bool) *TableCell {\n\tc.NotSelectable = !selectable\n\treturn c\n}\n\n// SetReference allows you to store a reference of any type in this cell. This\n// will allow you to establish a mapping between the cell and your\n// actual data.\nfunc (c *TableCell) SetReference(reference interface{}) *TableCell {\n\tc.Reference = reference\n\treturn c\n}\n\n// GetReference returns this cell's reference object.\nfunc (c *TableCell) GetReference() interface{} {\n\treturn c.Reference\n}\n\n// GetLastPosition returns the position of the table cell the last time it was\n// drawn on screen. If the cell is not on screen, the return values are\n// undefined.\n//\n// Because the Table class will attempt to keep selected cells on screen, this\n// function is most useful in response to a \"selected\" event (see\n// SetSelectedFunc()) or a \"selectionChanged\" event (see\n// SetSelectionChangedFunc()).\nfunc (c *TableCell) GetLastPosition() (x, y, width int) {\n\treturn c.x, c.y, c.width\n}\n\n// SetClickedFunc sets a handler which fires when this cell is clicked. This is\n// independent of whether the cell is selectable or not. But for selectable\n// cells, if the function returns \"true\", the \"selected\" event is not fired.\nfunc (c *TableCell) SetClickedFunc(clicked func() bool) *TableCell {\n\tc.Clicked = clicked\n\treturn c\n}\n\n// TableContent defines a Table's data. You may replace a Table's default\n// implementation with your own using the Table.SetContent() function. This will\n// allow you to turn Table into a view of your own data structure. The\n// Table.Draw() function, which is called when the screen is updated, will then\n// use the (read-only) functions of this interface to update the table. The\n// write functions are only called when the corresponding functions of Table are\n// called.\n//\n// The interface's read-only functions are not called concurrently by the\n// package (provided that users of the package don't call Table.Draw() in a\n// separate goroutine, which would be uncommon and is not encouraged).\ntype TableContent interface {\n\t// Return the cell at the given position or nil if there is no cell. The\n\t// row and column arguments start at 0 and end at what GetRowCount() and\n\t// GetColumnCount() return, minus 1.\n\tGetCell(row, column int) *TableCell\n\n\t// Return the total number of rows in the table.\n\tGetRowCount() int\n\n\t// Return the total number of columns in the table.\n\tGetColumnCount() int\n\n\t// The following functions are provided for completeness reasons as the\n\t// original Table implementation was not read-only. If you do not wish to\n\t// forward modifying operations to your data, you may opt to leave these\n\t// functions empty. To make this easier, you can include the\n\t// TableContentReadOnly type in your struct. See also the\n\t// demos/table/virtualtable example.\n\n\t// Set the cell at the given position to the provided cell.\n\tSetCell(row, column int, cell *TableCell)\n\n\t// Remove the row at the given position by shifting all following rows up\n\t// by one. Out of range positions may be ignored.\n\tRemoveRow(row int)\n\n\t// Remove the column at the given position by shifting all following columns\n\t// left by one. Out of range positions may be ignored.\n\tRemoveColumn(column int)\n\n\t// Insert a new empty row at the given position by shifting all rows at that\n\t// position and below down by one. Implementers may decide what to do with\n\t// out of range positions.\n\tInsertRow(row int)\n\n\t// Insert a new empty column at the given position by shifting all columns\n\t// at that position and to the right by one to the right. Implementers may\n\t// decide what to do with out of range positions.\n\tInsertColumn(column int)\n\n\t// Remove all table data.\n\tClear()\n}\n\n// TableContentReadOnly is an empty struct which implements the write operations\n// of the TableContent interface. None of the implemented functions do anything.\n// You can embed this struct into your own structs to free yourself from having\n// to implement the empty write functions of TableContent. See\n// demos/table/virtualtable for an example.\ntype TableContentReadOnly struct{}\n\n// SetCell does not do anything.\nfunc (t TableContentReadOnly) SetCell(row, column int, cell *TableCell) {\n\t// nop.\n}\n\n// RemoveRow does not do anything.\nfunc (t TableContentReadOnly) RemoveRow(row int) {\n\t// nop.\n}\n\n// RemoveColumn does not do anything.\nfunc (t TableContentReadOnly) RemoveColumn(column int) {\n\t// nop.\n}\n\n// InsertRow does not do anything.\nfunc (t TableContentReadOnly) InsertRow(row int) {\n\t// nop.\n}\n\n// InsertColumn does not do anything.\nfunc (t TableContentReadOnly) InsertColumn(column int) {\n\t// nop.\n}\n\n// Clear does not do anything.\nfunc (t TableContentReadOnly) Clear() {\n\t// nop.\n}\n\n// tableDefaultContent implements the default TableContent interface for the\n// Table class.\ntype tableDefaultContent struct {\n\t// The cells of the table. Rows first, then columns.\n\tcells [][]*TableCell\n\n\t// The rightmost column in the data set.\n\tlastColumn int\n}\n\n// Clear clears all data.\nfunc (t *tableDefaultContent) Clear() {\n\tt.cells = nil\n\tt.lastColumn = -1\n}\n\n// SetCell sets a cell's content.\nfunc (t *tableDefaultContent) SetCell(row, column int, cell *TableCell) {\n\tif row >= len(t.cells) {\n\t\tt.cells = append(t.cells, make([][]*TableCell, row-len(t.cells)+1)...)\n\t}\n\trowLen := len(t.cells[row])\n\tif column >= rowLen {\n\t\tt.cells[row] = append(t.cells[row], make([]*TableCell, column-rowLen+1)...)\n\t\tfor c := rowLen; c < column; c++ {\n\t\t\tt.cells[row][c] = &TableCell{}\n\t\t}\n\t}\n\tt.cells[row][column] = cell\n\tif column > t.lastColumn {\n\t\tt.lastColumn = column\n\t}\n}\n\n// RemoveRow removes a row from the data.\nfunc (t *tableDefaultContent) RemoveRow(row int) {\n\tif row < 0 || row >= len(t.cells) {\n\t\treturn\n\t}\n\tt.cells = append(t.cells[:row], t.cells[row+1:]...)\n}\n\n// RemoveColumn removes a column from the data.\nfunc (t *tableDefaultContent) RemoveColumn(column int) {\n\tfor row := range t.cells {\n\t\tif column < 0 || column >= len(t.cells[row]) {\n\t\t\tcontinue\n\t\t}\n\t\tt.cells[row] = append(t.cells[row][:column], t.cells[row][column+1:]...)\n\t}\n\tif column >= 0 && column <= t.lastColumn {\n\t\tt.lastColumn--\n\t}\n}\n\n// InsertRow inserts a new row at the given position.\nfunc (t *tableDefaultContent) InsertRow(row int) {\n\tif row >= len(t.cells) {\n\t\treturn\n\t}\n\tt.cells = append(t.cells, nil)       // Extend by one.\n\tcopy(t.cells[row+1:], t.cells[row:]) // Shift down.\n\tt.cells[row] = nil                   // New row is uninitialized.\n}\n\n// InsertColumn inserts a new column at the given position.\nfunc (t *tableDefaultContent) InsertColumn(column int) {\n\tfor row := range t.cells {\n\t\tif column >= len(t.cells[row]) {\n\t\t\tcontinue\n\t\t}\n\t\tt.cells[row] = append(t.cells[row], nil)             // Extend by one.\n\t\tcopy(t.cells[row][column+1:], t.cells[row][column:]) // Shift to the right.\n\t\tt.cells[row][column] = &TableCell{}                  // New element is an uninitialized table cell.\n\t}\n}\n\n// GetCell returns the cell at the given position.\nfunc (t *tableDefaultContent) GetCell(row, column int) *TableCell {\n\tif row < 0 || column < 0 || row >= len(t.cells) || column >= len(t.cells[row]) {\n\t\treturn nil\n\t}\n\treturn t.cells[row][column]\n}\n\n// GetRowCount returns the number of rows in the data set.\nfunc (t *tableDefaultContent) GetRowCount() int {\n\treturn len(t.cells)\n}\n\n// GetColumnCount returns the number of columns in the data set.\nfunc (t *tableDefaultContent) GetColumnCount() int {\n\tif len(t.cells) == 0 {\n\t\treturn 0\n\t}\n\treturn t.lastColumn + 1\n}\n\n// Table visualizes two-dimensional data consisting of rows and columns. Each\n// Table cell is defined via [Table.SetCell] by the [TableCell] type. They can\n// be added dynamically to the table and changed any time.\n//\n// The most compact display of a table is without borders. Each row will then\n// occupy one row on screen and columns are separated by the rune defined via\n// [Table.SetSeparator] (a space character by default).\n//\n// When borders are turned on (via [Table.SetBorders]), each table cell is\n// surrounded by lines. Therefore one table row will require two rows on screen.\n//\n// Columns will use as much horizontal space as they need. You can constrain\n// their size with the [TableCell.MaxWidth] parameter of the [TableCell] type.\n//\n// # Fixed Columns\n//\n// You can define fixed rows and rolumns via [Table.SetFixed]. They will always\n// stay in their place, even when the table is scrolled. Fixed rows are always\n// the top rows. Fixed columns are always the leftmost columns.\n//\n// # Selections\n//\n// You can call [Table.SetSelectable] to set columns and/or rows to\n// \"selectable\". If the flag is set only for columns, entire columns can be\n// selected by the user. If it is set only for rows, entire rows can be\n// selected. If both flags are set, individual cells can be selected. The\n// \"selected\" handler set via [Table.SetSelectedFunc] is invoked when the user\n// presses Enter on a selection.\n//\n// # Navigation\n//\n// If the table extends beyond the available space, it can be navigated with\n// key bindings similar to Vim:\n//\n//   - h, left arrow: Move left by one column.\n//   - l, right arrow: Move right by one column.\n//   - j, down arrow: Move down by one row.\n//   - k, up arrow: Move up by one row.\n//   - g, home: Move to the top.\n//   - G, end: Move to the bottom.\n//   - Ctrl-F, page down: Move down by one page.\n//   - Ctrl-B, page up: Move up by one page.\n//\n// When there is no selection, this affects the entire table (except for fixed\n// rows and columns). When there is a selection, the user moves the selection.\n// The class will attempt to keep the selection from moving out of the screen.\n//\n// Use [Box.SetInputCapture] to override or modify keyboard input.\n//\n// See https://github.com/rivo/tview/wiki/Table for an example.\ntype Table struct {\n\t*Box\n\n\t// Whether or not this table has borders around each cell.\n\tborders bool\n\n\t// The color of the borders or the separator.\n\tbordersColor tcell.Color\n\n\t// If there are no borders, the column separator.\n\tseparator rune\n\n\t// The table's data structure.\n\tcontent TableContent\n\n\t// If true, when calculating the widths of the columns, all rows are evaluated\n\t// instead of only the visible ones.\n\tevaluateAllRows bool\n\n\t// The number of fixed rows / columns.\n\tfixedRows, fixedColumns int\n\n\t// Whether or not rows or columns can be selected. If both are set to true,\n\t// cells can be selected.\n\trowsSelectable, columnsSelectable bool\n\n\t// The currently selected row and column.\n\tselectedRow, selectedColumn int\n\n\t// A temporary flag which causes the next call to Draw() to force the\n\t// current selection to remain visible. It is set to false afterwards.\n\tclampToSelection bool\n\n\t// If set to true, moving the selection will wrap around horizontally (last\n\t// to first column and vice versa) or vertically (last to first row and vice\n\t// versa).\n\twrapHorizontally, wrapVertically bool\n\n\t// The number of rows/columns by which the table is scrolled down/to the\n\t// right.\n\trowOffset, columnOffset int\n\n\t// If set to true, the table's last row will always be visible.\n\ttrackEnd bool\n\n\t// The number of visible rows the last time the table was drawn.\n\tvisibleRows int\n\n\t// The indices of the visible columns as of the last time the table was drawn.\n\tvisibleColumnIndices []int\n\n\t// The net widths of the visible columns as of the last time the table was\n\t// drawn.\n\tvisibleColumnWidths []int\n\n\t// The style of the selected rows. If this value is the empty struct,\n\t// selected rows are simply inverted.\n\tselectedStyle tcell.Style\n\n\t// An optional function which gets called when the user presses Enter on a\n\t// selected cell. If entire rows selected, the column value is undefined.\n\t// Likewise for entire columns.\n\tselected func(row, column int)\n\n\t// An optional function which gets called when the user changes the selection.\n\t// If entire rows selected, the column value is undefined.\n\t// Likewise for entire columns.\n\tselectionChanged func(row, column int)\n\n\t// An optional function which gets called when the user presses Escape, Tab,\n\t// or Backtab. Also when the user presses Enter if nothing is selectable.\n\tdone func(key tcell.Key)\n}\n\n// NewTable returns a new table.\nfunc NewTable() *Table {\n\tt := &Table{\n\t\tBox:          NewBox(),\n\t\tbordersColor: Styles.GraphicsColor,\n\t\tseparator:    ' ',\n\t}\n\tt.SetContent(nil)\n\treturn t\n}\n\n// SetContent sets a new content type for this table. This allows you to back\n// the table by a data structure of your own, for example one that cannot be\n// fully held in memory. For details, see the TableContent interface\n// documentation.\n//\n// A value of nil will return the table to its default implementation where all\n// of its table cells are kept in memory.\nfunc (t *Table) SetContent(content TableContent) *Table {\n\tif content != nil {\n\t\tt.content = content\n\t} else {\n\t\tt.content = &tableDefaultContent{\n\t\t\tlastColumn: -1,\n\t\t}\n\t}\n\treturn t\n}\n\n// Clear removes all table data.\nfunc (t *Table) Clear() *Table {\n\tt.content.Clear()\n\treturn t\n}\n\n// SetBorders sets whether or not each cell in the table is surrounded by a\n// border.\nfunc (t *Table) SetBorders(show bool) *Table {\n\tt.borders = show\n\treturn t\n}\n\n// SetBordersColor sets the color of the cell borders.\nfunc (t *Table) SetBordersColor(color tcell.Color) *Table {\n\tt.bordersColor = color\n\treturn t\n}\n\n// SetSelectedStyle sets a specific style for selected cells. If no such style\n// is set, the cell's background and text color are swapped. If a cell defines\n// its own selected style, that will be used instead.\n//\n// To reset a previous setting to its default, make the following call:\n//\n//\ttable.SetSelectedStyle(tcell.StyleDefault)\nfunc (t *Table) SetSelectedStyle(style tcell.Style) *Table {\n\tt.selectedStyle = style\n\treturn t\n}\n\n// SetSeparator sets the character used to fill the space between two\n// neighboring cells. This is a space character ' ' per default but you may\n// want to set it to Borders.Vertical (or any other rune) if the column\n// separation should be more visible. If cell borders are activated, this is\n// ignored.\n//\n// Separators have the same color as borders.\nfunc (t *Table) SetSeparator(separator rune) *Table {\n\tt.separator = separator\n\treturn t\n}\n\n// SetFixed sets the number of fixed rows and columns which are always visible\n// even when the rest of the cells are scrolled out of view. Rows are always the\n// top-most ones. Columns are always the left-most ones.\nfunc (t *Table) SetFixed(rows, columns int) *Table {\n\tt.fixedRows, t.fixedColumns = rows, columns\n\treturn t\n}\n\n// SetSelectable sets the flags which determine what can be selected in a table.\n// There are three selection modi:\n//\n//   - rows = false, columns = false: Nothing can be selected.\n//   - rows = true, columns = false: Rows can be selected.\n//   - rows = false, columns = true: Columns can be selected.\n//   - rows = true, columns = true: Individual cells can be selected.\nfunc (t *Table) SetSelectable(rows, columns bool) *Table {\n\tt.rowsSelectable, t.columnsSelectable = rows, columns\n\treturn t\n}\n\n// GetSelectable returns what can be selected in a table. Refer to\n// SetSelectable() for details.\nfunc (t *Table) GetSelectable() (rows, columns bool) {\n\treturn t.rowsSelectable, t.columnsSelectable\n}\n\n// GetSelection returns the position of the current selection.\n// If entire rows are selected, the column index is undefined.\n// Likewise for entire columns.\nfunc (t *Table) GetSelection() (row, column int) {\n\treturn t.selectedRow, t.selectedColumn\n}\n\n// Select sets the selected cell. Depending on the selection settings\n// specified via SetSelectable(), this may be an entire row or column, or even\n// ignored completely. The \"selection changed\" event is fired if such a callback\n// is available (even if the selection ends up being the same as before and even\n// if cells are not selectable).\nfunc (t *Table) Select(row, column int) *Table {\n\tt.selectedRow, t.selectedColumn = row, column\n\tt.clampToSelection = true\n\tif t.selectionChanged != nil {\n\t\tt.selectionChanged(row, column)\n\t}\n\treturn t\n}\n\n// SetOffset sets how many rows and columns should be skipped when drawing the\n// table. This is useful for large tables that do not fit on the screen.\n// Navigating a selection can change these values.\n//\n// Fixed rows and columns are never skipped.\nfunc (t *Table) SetOffset(row, column int) *Table {\n\tt.rowOffset, t.columnOffset = row, column\n\tt.trackEnd = false\n\treturn t\n}\n\n// GetOffset returns the current row and column offset. This indicates how many\n// rows and columns the table is scrolled down and to the right.\nfunc (t *Table) GetOffset() (row, column int) {\n\treturn t.rowOffset, t.columnOffset\n}\n\n// SetEvaluateAllRows sets a flag which determines the rows to be evaluated when\n// calculating the widths of the table's columns. When false, only visible rows\n// are evaluated. When true, all rows in the table are evaluated.\n//\n// Set this flag to true to avoid shifting column widths when the table is\n// scrolled. (May come with a performance penalty for large tables.)\n//\n// Use with caution on very large tables, especially those not backed by the\n// default TableContent data structure.\nfunc (t *Table) SetEvaluateAllRows(all bool) *Table {\n\tt.evaluateAllRows = all\n\treturn t\n}\n\n// SetSelectedFunc sets a handler which is called whenever the user presses the\n// Enter key on a selected cell/row/column. The handler receives the position of\n// the selection and its cell contents. If entire rows are selected, the column\n// index is undefined. Likewise for entire columns.\nfunc (t *Table) SetSelectedFunc(handler func(row, column int)) *Table {\n\tt.selected = handler\n\treturn t\n}\n\n// SetSelectionChangedFunc sets a handler which is called whenever the current\n// selection changes. The handler receives the position of the new selection.\n// If entire rows are selected, the column index is undefined. Likewise for\n// entire columns.\nfunc (t *Table) SetSelectionChangedFunc(handler func(row, column int)) *Table {\n\tt.selectionChanged = handler\n\treturn t\n}\n\n// SetDoneFunc sets a handler which is called whenever the user presses the\n// Escape, Tab, or Backtab key. If nothing is selected, it is also called when\n// user presses the Enter key (because pressing Enter on a selection triggers\n// the \"selected\" handler set via SetSelectedFunc()).\nfunc (t *Table) SetDoneFunc(handler func(key tcell.Key)) *Table {\n\tt.done = handler\n\treturn t\n}\n\n// SetCell sets the content of a cell the specified position. It is ok to\n// directly instantiate a TableCell object. If the cell has content, at least\n// the Text and Color fields should be set.\n//\n// Note that setting cells in previously unknown rows and columns will\n// automatically extend the internal table representation with empty TableCell\n// objects, e.g. starting with a row of 100,000 will immediately create 100,000\n// empty rows.\n//\n// To avoid unnecessary garbage collection, fill columns from left to right.\nfunc (t *Table) SetCell(row, column int, cell *TableCell) *Table {\n\tt.content.SetCell(row, column, cell)\n\treturn t\n}\n\n// SetCellSimple calls SetCell() with the given text, left-aligned, in white.\nfunc (t *Table) SetCellSimple(row, column int, text string) *Table {\n\tt.SetCell(row, column, NewTableCell(text))\n\treturn t\n}\n\n// GetCell returns the contents of the cell at the specified position. A valid\n// TableCell object is always returned but it will be uninitialized if the cell\n// was not previously set. Such an uninitialized object will not automatically\n// be inserted. Therefore, repeated calls to this function may return different\n// pointers for uninitialized cells.\nfunc (t *Table) GetCell(row, column int) *TableCell {\n\tcell := t.content.GetCell(row, column)\n\tif cell == nil {\n\t\tcell = &TableCell{}\n\t}\n\treturn cell\n}\n\n// RemoveRow removes the row at the given position from the table. If there is\n// no such row, this has no effect.\nfunc (t *Table) RemoveRow(row int) *Table {\n\tt.content.RemoveRow(row)\n\treturn t\n}\n\n// RemoveColumn removes the column at the given position from the table. If\n// there is no such column, this has no effect.\nfunc (t *Table) RemoveColumn(column int) *Table {\n\tt.content.RemoveColumn(column)\n\treturn t\n}\n\n// InsertRow inserts a row before the row with the given index. Cells on the\n// given row and below will be shifted to the bottom by one row. If \"row\" is\n// equal or larger than the current number of rows, this function has no effect.\nfunc (t *Table) InsertRow(row int) *Table {\n\tt.content.InsertRow(row)\n\treturn t\n}\n\n// InsertColumn inserts a column before the column with the given index. Cells\n// in the given column and to its right will be shifted to the right by one\n// column. Rows that have fewer initialized cells than \"column\" will remain\n// unchanged.\nfunc (t *Table) InsertColumn(column int) *Table {\n\tt.content.InsertColumn(column)\n\treturn t\n}\n\n// GetRowCount returns the number of rows in the table.\nfunc (t *Table) GetRowCount() int {\n\treturn t.content.GetRowCount()\n}\n\n// GetColumnCount returns the (maximum) number of columns in the table.\nfunc (t *Table) GetColumnCount() int {\n\treturn t.content.GetColumnCount()\n}\n\n// CellAt returns the row and column located at the given screen coordinates.\n// Each returned value may be negative if there is no row and/or cell. This\n// function will also process coordinates outside the table's inner rectangle so\n// callers will need to check for bounds themselves.\n//\n// The layout of the table when it was last drawn is used so if anything has\n// changed in the meantime, the results may not be reliable.\nfunc (t *Table) CellAt(x, y int) (row, column int) {\n\trectX, rectY, _, _ := t.GetInnerRect()\n\n\t// Determine row as seen on screen.\n\tif t.borders {\n\t\trow = (y - rectY - 1) / 2\n\t} else {\n\t\trow = y - rectY\n\t}\n\n\t// Respect fixed rows and row offset.\n\tif row >= 0 {\n\t\tif row >= t.fixedRows {\n\t\t\trow += t.rowOffset\n\t\t}\n\t\tif row >= t.content.GetRowCount() {\n\t\t\trow = -1\n\t\t}\n\t}\n\n\t// Saerch for the clicked column.\n\tcolumn = -1\n\tif x >= rectX {\n\t\tcolumnX := rectX\n\t\tif t.borders {\n\t\t\tcolumnX++\n\t\t}\n\t\tfor index, width := range t.visibleColumnWidths {\n\t\t\tcolumnX += width + 1\n\t\t\tif x < columnX {\n\t\t\t\tcolumn = t.visibleColumnIndices[index]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\n}\n\n// ScrollToBeginning scrolls the table to the beginning to that the top left\n// corner of the table is shown. Note that this position may be corrected if\n// there is a selection.\nfunc (t *Table) ScrollToBeginning() *Table {\n\tt.trackEnd = false\n\tt.columnOffset = 0\n\tt.rowOffset = 0\n\treturn t\n}\n\n// ScrollToEnd scrolls the table to the beginning to that the bottom left corner\n// of the table is shown. Adding more rows to the table will cause it to\n// automatically scroll with the new data. Note that this position may be\n// corrected if there is a selection.\nfunc (t *Table) ScrollToEnd() *Table {\n\tt.trackEnd = true\n\tt.columnOffset = 0\n\tt.rowOffset = t.content.GetRowCount()\n\treturn t\n}\n\n// SetWrapSelection determines whether a selection wraps vertically or\n// horizontally when moved. Vertically wrapping selections will jump from the\n// last selectable row to the first selectable row and vice versa. Horizontally\n// wrapping selections will jump from the last selectable column to the first\n// selectable column (on the next selectable row) or from the first selectable\n// column to the last selectable column (on the previous selectable row). If set\n// to false, the selection is not moved when it is already on the first/last\n// selectable row/column.\n//\n// The default is for both values to be false.\nfunc (t *Table) SetWrapSelection(vertical, horizontal bool) *Table {\n\tt.wrapHorizontally = horizontal\n\tt.wrapVertically = vertical\n\treturn t\n}\n\n// Draw draws this primitive onto the screen.\nfunc (t *Table) Draw(screen tcell.Screen) {\n\tt.Box.DrawForSubclass(screen, t)\n\n\t// What's our available screen space?\n\t_, totalHeight := screen.Size()\n\tx, y, width, height := t.GetInnerRect()\n\tnetWidth := width\n\tif t.borders {\n\t\tt.visibleRows = height / 2\n\t\tnetWidth -= 2\n\t} else {\n\t\tt.visibleRows = height\n\t}\n\n\t// If this cell is not selectable, find the next one.\n\trowCount, columnCount := t.content.GetRowCount(), t.content.GetColumnCount()\n\tif t.rowsSelectable || t.columnsSelectable {\n\t\tif t.selectedColumn < 0 {\n\t\t\tt.selectedColumn = 0\n\t\t}\n\t\tif t.selectedRow < 0 {\n\t\t\tt.selectedRow = 0\n\t\t}\n\t\tfor t.selectedRow < rowCount {\n\t\t\tcell := t.content.GetCell(t.selectedRow, t.selectedColumn)\n\t\t\tif cell != nil && !cell.NotSelectable {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tt.selectedColumn++\n\t\t\tif t.selectedColumn > columnCount-1 {\n\t\t\t\tt.selectedColumn = 0\n\t\t\t\tt.selectedRow++\n\t\t\t}\n\t\t}\n\t}\n\n\t// Clamp row offsets if requested.\n\tdefer func() {\n\t\tt.clampToSelection = false // Only once.\n\t}()\n\tif t.clampToSelection && t.rowsSelectable {\n\t\tif t.selectedRow >= t.fixedRows && t.selectedRow < t.fixedRows+t.rowOffset {\n\t\t\tt.rowOffset = t.selectedRow - t.fixedRows\n\t\t\tt.trackEnd = false\n\t\t}\n\t\tif t.borders {\n\t\t\tif t.selectedRow+1-t.rowOffset >= height/2 {\n\t\t\t\tt.rowOffset = t.selectedRow + 1 - height/2\n\t\t\t\tt.trackEnd = false\n\t\t\t}\n\t\t} else {\n\t\t\tif t.selectedRow+1-t.rowOffset >= height {\n\t\t\t\tt.rowOffset = t.selectedRow + 1 - height\n\t\t\t\tt.trackEnd = false\n\t\t\t}\n\t\t}\n\t}\n\tif t.rowOffset < 0 {\n\t\tt.rowOffset = 0\n\t}\n\tif t.borders {\n\t\tif rowCount-t.rowOffset < height/2 {\n\t\t\tt.trackEnd = true\n\t\t}\n\t} else {\n\t\tif rowCount-t.rowOffset < height {\n\t\t\tt.trackEnd = true\n\t\t}\n\t}\n\tif t.trackEnd {\n\t\tif t.borders {\n\t\t\tt.rowOffset = rowCount - height/2\n\t\t} else {\n\t\t\tt.rowOffset = rowCount - height\n\t\t}\n\t}\n\tif t.rowOffset < 0 {\n\t\tt.rowOffset = 0\n\t}\n\n\t// Avoid invalid column offsets.\n\tif t.columnOffset >= columnCount-t.fixedColumns {\n\t\tt.columnOffset = columnCount - t.fixedColumns - 1\n\t}\n\tif t.columnOffset < 0 {\n\t\tt.columnOffset = 0\n\t}\n\n\t// Determine the indices of the rows which fit on the screen.\n\tvar (\n\t\trows, allRows []int\n\t\ttableHeight   int\n\t)\n\trowStep := 1\n\tif t.borders {\n\t\trowStep = 2 // With borders, every table row takes two screen rows.\n\t}\n\tif t.evaluateAllRows {\n\t\tallRows = make([]int, rowCount)\n\t\tfor row := 0; row < rowCount; row++ {\n\t\t\tallRows[row] = row\n\t\t}\n\t}\n\tindexRow := func(row int) bool { // Determine if this row is visible, store its index.\n\t\tif tableHeight >= height {\n\t\t\treturn false\n\t\t}\n\t\trows = append(rows, row)\n\t\ttableHeight += rowStep\n\t\treturn true\n\t}\n\tfor row := 0; row < t.fixedRows && row < rowCount; row++ { // Do the fixed rows first.\n\t\tif !indexRow(row) {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor row := t.fixedRows + t.rowOffset; row < rowCount; row++ { // Then the remaining rows.\n\t\tif !indexRow(row) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Determine the columns' indices, widths, and expansion values that fit on\n\t// the screen.\n\tvar (\n\t\ttableWidth, expansionTotal  int\n\t\tcolumns, widths, expansions []int\n\t)\n\tincludesSelection := !t.clampToSelection || !t.columnsSelectable\n\n\t// Helper function that evaluates one column. Returns true if the column\n\t// didn't fit at all.\n\tindexColumn := func(column int) bool {\n\t\tif netWidth == 0 || tableWidth >= netWidth {\n\t\t\treturn true\n\t\t}\n\n\t\tvar maxWidth, expansion int\n\t\tevaluationRows := rows\n\t\tif t.evaluateAllRows {\n\t\t\tevaluationRows = allRows\n\t\t}\n\t\tfor _, row := range evaluationRows {\n\t\t\tif cell := t.content.GetCell(row, column); cell != nil {\n\t\t\t\tcellWidth := TaggedStringWidth(cell.Text)\n\t\t\t\tif cell.MaxWidth > 0 && cell.MaxWidth < cellWidth {\n\t\t\t\t\tcellWidth = cell.MaxWidth\n\t\t\t\t}\n\t\t\t\tif cellWidth > maxWidth {\n\t\t\t\t\tmaxWidth = cellWidth\n\t\t\t\t}\n\t\t\t\tif cell.Expansion > expansion {\n\t\t\t\t\texpansion = cell.Expansion\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclampedMaxWidth := maxWidth\n\t\tif tableWidth+maxWidth > netWidth {\n\t\t\tclampedMaxWidth = netWidth - tableWidth\n\t\t}\n\t\tcolumns = append(columns, column)\n\t\twidths = append(widths, clampedMaxWidth)\n\t\texpansions = append(expansions, expansion)\n\t\ttableWidth += clampedMaxWidth + 1\n\t\texpansionTotal += expansion\n\t\tif t.columnsSelectable && t.clampToSelection && column == t.selectedColumn {\n\t\t\t// We want selections to appear fully.\n\t\t\tincludesSelection = clampedMaxWidth == maxWidth\n\t\t}\n\n\t\treturn false\n\t}\n\n\t// Helper function that evaluates multiple columns, starting at \"start\" and\n\t// at most ending at \"maxEnd\". Returns first column not included anymore (or\n\t// -1 if all are included).\n\tindexColumns := func(start, maxEnd int) int {\n\t\tif start == maxEnd {\n\t\t\treturn -1\n\t\t}\n\n\t\tif start < maxEnd {\n\t\t\t// Forward-evaluate columns.\n\t\t\tfor column := start; column < maxEnd; column++ {\n\t\t\t\tif indexColumn(column) {\n\t\t\t\t\treturn column\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1\n\t\t}\n\n\t\t// Backward-evaluate columns.\n\t\tstartLen := len(columns)\n\t\tdefer func() {\n\t\t\t// Because we went backwards, we must reverse the partial slices.\n\t\t\tfor i, j := startLen, len(columns)-1; i < j; i, j = i+1, j-1 {\n\t\t\t\tcolumns[i], columns[j] = columns[j], columns[i]\n\t\t\t\twidths[i], widths[j] = widths[j], widths[i]\n\t\t\t\texpansions[i], expansions[j] = expansions[j], expansions[i]\n\t\t\t}\n\t\t}()\n\t\tfor column := start; column >= maxEnd; column-- {\n\t\t\tif indexColumn(column) {\n\t\t\t\treturn column\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n\n\t// Reset the table to only its fixed columns.\n\tvar fixedTableWidth, fixedExpansionTotal int\n\tresetColumns := func() {\n\t\ttableWidth = fixedTableWidth\n\t\texpansionTotal = fixedExpansionTotal\n\t\tcolumns = columns[:t.fixedColumns]\n\t\twidths = widths[:t.fixedColumns]\n\t\texpansions = expansions[:t.fixedColumns]\n\t}\n\n\t// Add fixed columns.\n\tif indexColumns(0, t.fixedColumns) < 0 {\n\t\tfixedTableWidth = tableWidth\n\t\tfixedExpansionTotal = expansionTotal\n\n\t\t// Add unclamped columns.\n\t\tif column := indexColumns(t.fixedColumns+t.columnOffset, columnCount); !includesSelection || column < 0 && t.columnOffset > 0 {\n\t\t\t// Offset is not optimal. Try again.\n\t\t\tif !includesSelection {\n\t\t\t\t// Clamp to selection.\n\t\t\t\tresetColumns()\n\t\t\t\tif t.selectedColumn <= t.fixedColumns+t.columnOffset {\n\t\t\t\t\t// It's on the left. Start with the selection.\n\t\t\t\t\tt.columnOffset = t.selectedColumn - t.fixedColumns\n\t\t\t\t\tindexColumns(t.fixedColumns+t.columnOffset, columnCount)\n\t\t\t\t} else {\n\t\t\t\t\t// It's on the right. End with the selection.\n\t\t\t\t\tif column := indexColumns(t.selectedColumn, t.fixedColumns); column >= 0 {\n\t\t\t\t\t\tt.columnOffset = column + 1 - t.fixedColumns\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if tableWidth < netWidth {\n\t\t\t\t// Don't waste space. Try to fit as much on screen as possible.\n\t\t\t\tresetColumns()\n\t\t\t\tif column := indexColumns(columnCount-1, t.fixedColumns); column >= 0 {\n\t\t\t\t\tt.columnOffset = column + 1 - t.fixedColumns\n\t\t\t\t} else {\n\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// If we have space left, distribute it.\n\tif tableWidth < netWidth {\n\t\ttoDistribute := netWidth - tableWidth\n\t\tfor index, expansion := range expansions {\n\t\t\tif expansionTotal <= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\texpWidth := toDistribute * expansion / expansionTotal\n\t\t\twidths[index] += expWidth\n\t\t\ttoDistribute -= expWidth\n\t\t\texpansionTotal -= expansion\n\t\t}\n\t}\n\n\t// Helper function which draws border runes.\n\tborderStyle := tcell.StyleDefault.Background(t.backgroundColor).Foreground(t.bordersColor)\n\tdrawBorder := func(colX, rowY int, ch rune) {\n\t\tscreen.SetContent(x+colX, y+rowY, ch, nil, borderStyle)\n\t}\n\n\t// Draw the cells (and borders).\n\tvar columnX int\n\tif t.borders {\n\t\tcolumnX++\n\t}\n\tfor columnIndex, column := range columns {\n\t\tcolumnWidth := widths[columnIndex]\n\t\tfor rowY, row := range rows {\n\t\t\tif t.borders {\n\t\t\t\t// Draw borders.\n\t\t\t\trowY *= 2\n\t\t\t\tfor pos := 0; pos < columnWidth && columnX+pos < width; pos++ {\n\t\t\t\t\tdrawBorder(columnX+pos, rowY, Borders.Horizontal)\n\t\t\t\t}\n\t\t\t\tch := Borders.Cross\n\t\t\t\tif row == 0 {\n\t\t\t\t\tif column == 0 {\n\t\t\t\t\t\tch = Borders.TopLeft\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch = Borders.TopT\n\t\t\t\t\t}\n\t\t\t\t} else if column == 0 {\n\t\t\t\t\tch = Borders.LeftT\n\t\t\t\t}\n\t\t\t\tdrawBorder(columnX-1, rowY, ch)\n\t\t\t\trowY++\n\t\t\t\tif rowY >= height || y+rowY >= totalHeight {\n\t\t\t\t\tbreak // No space for the text anymore.\n\t\t\t\t}\n\t\t\t\tdrawBorder(columnX-1, rowY, Borders.Vertical)\n\t\t\t} else if columnIndex < len(columns)-1 {\n\t\t\t\t// Draw separator.\n\t\t\t\tdrawBorder(columnX+columnWidth, rowY, t.separator)\n\t\t\t}\n\n\t\t\t// Get the cell.\n\t\t\tcell := t.content.GetCell(row, column)\n\t\t\tif cell == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Draw text.\n\t\t\tfinalWidth := columnWidth\n\t\t\tif columnX+columnWidth >= width {\n\t\t\t\tfinalWidth = width - columnX\n\t\t\t}\n\t\t\tcell.x, cell.y, cell.width = x+columnX, y+rowY, finalWidth\n\t\t\tstyle := cell.Style\n\t\t\tif style == tcell.StyleDefault {\n\t\t\t\tstyle = tcell.StyleDefault.Background(cell.BackgroundColor).Foreground(cell.Color).Attributes(cell.Attributes)\n\t\t\t}\n\t\t\tstart, end, _ := printWithStyle(screen, cell.Text, x+columnX, y+rowY, 0, finalWidth, cell.Align, style, true)\n\t\t\tprinted := end - start\n\t\t\tif TaggedStringWidth(cell.Text)-printed > 0 && printed > 0 {\n\t\t\t\t_, _, style, _ := screen.GetContent(x+columnX+finalWidth-1, y+rowY)\n\t\t\t\tprintWithStyle(screen, string(SemigraphicsHorizontalEllipsis), x+columnX+finalWidth-1, y+rowY, 0, 1, AlignLeft, style, false)\n\t\t\t}\n\t\t}\n\n\t\t// Draw bottom border.\n\t\tif rowY := 2 * len(rows); t.borders && rowY > 0 && rowY < height {\n\t\t\tfor pos := 0; pos < columnWidth && columnX+1+pos < width; pos++ {\n\t\t\t\tdrawBorder(columnX+pos, rowY, Borders.Horizontal)\n\t\t\t}\n\t\t\tch := Borders.Cross\n\t\t\tif rows[len(rows)-1] == rowCount-1 {\n\t\t\t\tif column == 0 {\n\t\t\t\t\tch = Borders.BottomLeft\n\t\t\t\t} else {\n\t\t\t\t\tch = Borders.BottomT\n\t\t\t\t}\n\t\t\t} else if column == 0 {\n\t\t\t\tch = Borders.BottomLeft\n\t\t\t}\n\t\t\tdrawBorder(columnX-1, rowY, ch)\n\t\t}\n\n\t\tcolumnX += columnWidth + 1\n\t}\n\n\t// Draw right border.\n\tcolumnX--\n\tif t.borders && len(rows) > 0 && len(columns) > 0 && columnX < width {\n\t\tlastColumn := columns[len(columns)-1] == columnCount-1\n\t\tfor rowY := range rows {\n\t\t\trowY *= 2\n\t\t\tif rowY+1 < height {\n\t\t\t\tdrawBorder(columnX, rowY+1, Borders.Vertical)\n\t\t\t}\n\t\t\tch := Borders.Cross\n\t\t\tif rowY == 0 {\n\t\t\t\tif lastColumn {\n\t\t\t\t\tch = Borders.TopRight\n\t\t\t\t} else {\n\t\t\t\t\tch = Borders.TopT\n\t\t\t\t}\n\t\t\t} else if lastColumn {\n\t\t\t\tch = Borders.RightT\n\t\t\t}\n\t\t\tdrawBorder(columnX, rowY, ch)\n\t\t}\n\t\tif rowY := 2 * len(rows); rowY < height {\n\t\t\tch := Borders.BottomT\n\t\t\tif lastColumn {\n\t\t\t\tch = Borders.BottomRight\n\t\t\t}\n\t\t\tdrawBorder(columnX, rowY, ch)\n\t\t}\n\t}\n\n\t// Helper function which colors the background of a box.\n\t// backgroundTransparent == true => Don't modify background color (when invert == false).\n\t// textTransparent == true => Don't modify text color (when invert == false).\n\t// attr == 0 => Don't change attributes.\n\t// invert == true => Ignore attr, set text to backgroundColor or t.backgroundColor;\n\t//                   set background to textColor.\n\tcolorBackground := func(fromX, fromY, w, h int, backgroundColor, textColor tcell.Color, backgroundTransparent, textTransparent bool, attr tcell.AttrMask, invert bool) {\n\t\tfor by := 0; by < h && fromY+by < y+height; by++ {\n\t\t\tfor bx := 0; bx < w && fromX+bx < x+width; bx++ {\n\t\t\t\tm, c, style, _ := screen.GetContent(fromX+bx, fromY+by)\n\t\t\t\tfg, bg, a := style.Decompose()\n\t\t\t\tif invert {\n\t\t\t\t\tstyle = style.Background(textColor).Foreground(backgroundColor)\n\t\t\t\t} else {\n\t\t\t\t\tif !backgroundTransparent {\n\t\t\t\t\t\tbg = backgroundColor\n\t\t\t\t\t}\n\t\t\t\t\tif !textTransparent {\n\t\t\t\t\t\tfg = textColor\n\t\t\t\t\t}\n\t\t\t\t\tif attr != 0 {\n\t\t\t\t\t\ta = attr\n\t\t\t\t\t}\n\t\t\t\t\tstyle = style.Background(bg).Foreground(fg).Attributes(a)\n\t\t\t\t}\n\t\t\t\tscreen.SetContent(fromX+bx, fromY+by, m, c, style)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Color the cell backgrounds. To avoid undesirable artefacts, we combine\n\t// the drawing of a cell by background color, selected cells last.\n\ttype cellInfo struct {\n\t\tx, y, w, h int\n\t\tcell       *TableCell\n\t\tselected   bool\n\t}\n\tcellsByBackgroundColor := make(map[tcell.Color][]*cellInfo)\n\tvar backgroundColors []tcell.Color\n\tfor rowY, row := range rows {\n\t\tcolumnX := 0\n\t\trowSelected := t.rowsSelectable && !t.columnsSelectable && row == t.selectedRow\n\t\tfor columnIndex, column := range columns {\n\t\t\tcolumnWidth := widths[columnIndex]\n\t\t\tcell := t.content.GetCell(row, column)\n\t\t\tif cell == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbx, by, bw, bh := x+columnX, y+rowY, columnWidth+1, 1\n\t\t\tif t.borders {\n\t\t\t\tby = y + rowY*2\n\t\t\t\tbw++\n\t\t\t\tbh = 3\n\t\t\t}\n\t\t\tcolumnSelected := t.columnsSelectable && !t.rowsSelectable && column == t.selectedColumn\n\t\t\tcellSelected := !cell.NotSelectable && (columnSelected || rowSelected || t.rowsSelectable && t.columnsSelectable && column == t.selectedColumn && row == t.selectedRow)\n\t\t\tbackgroundColor := cell.BackgroundColor\n\t\t\tif cell.Style != tcell.StyleDefault {\n\t\t\t\t_, backgroundColor, _ = cell.Style.Decompose()\n\t\t\t}\n\t\t\tentries, ok := cellsByBackgroundColor[backgroundColor]\n\t\t\tcellsByBackgroundColor[backgroundColor] = append(entries, &cellInfo{\n\t\t\t\tx:        bx,\n\t\t\t\ty:        by,\n\t\t\t\tw:        bw,\n\t\t\t\th:        bh,\n\t\t\t\tcell:     cell,\n\t\t\t\tselected: cellSelected,\n\t\t\t})\n\t\t\tif !ok {\n\t\t\t\tbackgroundColors = append(backgroundColors, backgroundColor)\n\t\t\t}\n\t\t\tcolumnX += columnWidth + 1\n\t\t}\n\t}\n\tsort.Slice(backgroundColors, func(i int, j int) bool {\n\t\t// Draw brightest colors last (i.e. on top).\n\t\tr, g, b := backgroundColors[i].RGB()\n\t\tc := colorful.Color{R: float64(r) / 255, G: float64(g) / 255, B: float64(b) / 255}\n\t\t_, _, li := c.Hcl()\n\t\tr, g, b = backgroundColors[j].RGB()\n\t\tc = colorful.Color{R: float64(r) / 255, G: float64(g) / 255, B: float64(b) / 255}\n\t\t_, _, lj := c.Hcl()\n\t\treturn li < lj\n\t})\n\tfor _, bgColor := range backgroundColors {\n\t\tentries := cellsByBackgroundColor[bgColor]\n\t\tfor _, info := range entries {\n\t\t\ttextColor := info.cell.Color\n\t\t\tif info.cell.Style != tcell.StyleDefault {\n\t\t\t\ttextColor, _, _ = info.cell.Style.Decompose()\n\t\t\t}\n\t\t\tif info.selected {\n\t\t\t\tif info.cell.SelectedStyle != tcell.StyleDefault {\n\t\t\t\t\tselFg, selBg, selAttr := info.cell.SelectedStyle.Decompose()\n\t\t\t\t\tdefer colorBackground(info.x, info.y, info.w, info.h, selBg, selFg, false, false, selAttr, false)\n\t\t\t\t} else if t.selectedStyle != tcell.StyleDefault {\n\t\t\t\t\tselFg, selBg, selAttr := t.selectedStyle.Decompose()\n\t\t\t\t\tdefer colorBackground(info.x, info.y, info.w, info.h, selBg, selFg, false, false, selAttr, false)\n\t\t\t\t} else {\n\t\t\t\t\tdefer colorBackground(info.x, info.y, info.w, info.h, bgColor, textColor, false, false, 0, true)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolorBackground(info.x, info.y, info.w, info.h, bgColor, textColor, info.cell.Transparent, true, 0, false)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remember column infos.\n\tt.visibleColumnIndices, t.visibleColumnWidths = columns, widths\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (t *Table) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn t.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tkey := event.Key()\n\n\t\tif (!t.rowsSelectable && !t.columnsSelectable && key == tcell.KeyEnter) ||\n\t\t\tkey == tcell.KeyEscape ||\n\t\t\tkey == tcell.KeyTab ||\n\t\t\tkey == tcell.KeyBacktab {\n\t\t\tif t.done != nil {\n\t\t\t\tt.done(key)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// Movement functions.\n\t\tpreviouslySelectedRow, previouslySelectedColumn := t.selectedRow, t.selectedColumn\n\t\tlastColumn := t.content.GetColumnCount() - 1\n\t\trowCount := t.content.GetRowCount()\n\t\tif rowCount == 0 {\n\t\t\treturn // No movement on empty tables.\n\t\t}\n\t\tvar (\n\t\t\t// Move the selection forward, don't go beyond final cell, return\n\t\t\t// true if a selection was found.\n\t\t\tforward = func(finalRow, finalColumn int) bool {\n\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\tfor {\n\t\t\t\t\t// Stop if the current selection is fine.\n\t\t\t\t\tcell := t.content.GetCell(row, column)\n\t\t\t\t\tif cell != nil && !cell.NotSelectable {\n\t\t\t\t\t\tt.selectedRow, t.selectedColumn = row, column\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the final cell, stop.\n\t\t\t\t\tif row == finalRow && column == finalColumn {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move forward.\n\t\t\t\t\tcolumn++\n\t\t\t\t\tif column > lastColumn {\n\t\t\t\t\t\tcolumn = 0\n\t\t\t\t\t\trow++\n\t\t\t\t\t\tif row >= rowCount {\n\t\t\t\t\t\t\trow = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Move the selection backwards, don't go beyond final cell, return\n\t\t\t// true if a selection was found.\n\t\t\tbackwards = func(finalRow, finalColumn int) bool {\n\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\tfor {\n\t\t\t\t\t// Stop if the current selection is fine.\n\t\t\t\t\tcell := t.content.GetCell(row, column)\n\t\t\t\t\tif cell != nil && !cell.NotSelectable {\n\t\t\t\t\t\tt.selectedRow, t.selectedColumn = row, column\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\n\t\t\t\t\t// If we reached the final cell, stop.\n\t\t\t\t\tif row == finalRow && column == finalColumn {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move backwards.\n\t\t\t\t\tcolumn--\n\t\t\t\t\tif column < 0 {\n\t\t\t\t\t\tcolumn = lastColumn\n\t\t\t\t\t\trow--\n\t\t\t\t\t\tif row < 0 {\n\t\t\t\t\t\t\trow = rowCount - 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thome = func() {\n\t\t\t\tif t.rowsSelectable {\n\t\t\t\t\tt.selectedRow = 0\n\t\t\t\t\tt.selectedColumn = 0\n\t\t\t\t\tforward(rowCount-1, lastColumn)\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.trackEnd = false\n\t\t\t\t\tt.rowOffset = 0\n\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tend = func() {\n\t\t\t\tif t.rowsSelectable {\n\t\t\t\t\tt.selectedRow = rowCount - 1\n\t\t\t\t\tt.selectedColumn = lastColumn\n\t\t\t\t\tbackwards(0, 0)\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.trackEnd = true\n\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdown = func() {\n\t\t\t\tif t.rowsSelectable {\n\t\t\t\t\tt.selectedRow++\n\t\t\t\t\tif t.selectedRow >= rowCount {\n\t\t\t\t\t\tif t.wrapVertically {\n\t\t\t\t\t\t\tt.selectedRow = 0\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.selectedRow = rowCount - 1\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\t\tfinalRow, finalColumn := rowCount-1, lastColumn\n\t\t\t\t\tif t.wrapVertically {\n\t\t\t\t\t\tfinalRow = row\n\t\t\t\t\t\tfinalColumn = column\n\t\t\t\t\t}\n\t\t\t\t\tif !forward(finalRow, finalColumn) {\n\t\t\t\t\t\tbackwards(row, column)\n\t\t\t\t\t}\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.rowOffset++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tup = func() {\n\t\t\t\tif t.rowsSelectable {\n\t\t\t\t\tt.selectedRow--\n\t\t\t\t\tif t.selectedRow < 0 {\n\t\t\t\t\t\tif t.wrapVertically {\n\t\t\t\t\t\t\tt.selectedRow = rowCount - 1\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.selectedRow = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\t\tfinalRow, finalColumn := 0, 0\n\t\t\t\t\tif t.wrapVertically {\n\t\t\t\t\t\tfinalRow = row\n\t\t\t\t\t\tfinalColumn = column\n\t\t\t\t\t}\n\t\t\t\t\tif !backwards(finalRow, finalColumn) {\n\t\t\t\t\t\tforward(row, column)\n\t\t\t\t\t}\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.trackEnd = false\n\t\t\t\t\tt.rowOffset--\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tleft = func() {\n\t\t\t\tif t.columnsSelectable {\n\t\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\t\tt.selectedColumn--\n\t\t\t\t\tif t.selectedColumn < 0 {\n\t\t\t\t\t\tif t.wrapHorizontally {\n\t\t\t\t\t\t\tt.selectedColumn = lastColumn\n\t\t\t\t\t\t\tt.selectedRow--\n\t\t\t\t\t\t\tif t.selectedRow < 0 {\n\t\t\t\t\t\t\t\tif t.wrapVertically {\n\t\t\t\t\t\t\t\t\tt.selectedRow = rowCount - 1\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tt.selectedColumn = 0\n\t\t\t\t\t\t\t\t\tt.selectedRow = 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.selectedColumn = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinalRow, finalColumn := row, column\n\t\t\t\t\tif !t.wrapHorizontally {\n\t\t\t\t\t\tfinalColumn = 0\n\t\t\t\t\t} else if !t.wrapVertically {\n\t\t\t\t\t\tfinalRow = 0\n\t\t\t\t\t\tfinalColumn = 0\n\t\t\t\t\t}\n\t\t\t\t\tif !backwards(finalRow, finalColumn) {\n\t\t\t\t\t\tforward(row, column)\n\t\t\t\t\t}\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.columnOffset--\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tright = func() {\n\t\t\t\tif t.columnsSelectable {\n\t\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\t\tt.selectedColumn++\n\t\t\t\t\tif t.selectedColumn > lastColumn {\n\t\t\t\t\t\tif t.wrapHorizontally {\n\t\t\t\t\t\t\tt.selectedColumn = 0\n\t\t\t\t\t\t\tt.selectedRow++\n\t\t\t\t\t\t\tif t.selectedRow >= rowCount {\n\t\t\t\t\t\t\t\tif t.wrapVertically {\n\t\t\t\t\t\t\t\t\tt.selectedRow = 0\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tt.selectedColumn = lastColumn\n\t\t\t\t\t\t\t\t\tt.selectedRow = rowCount - 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt.selectedColumn = lastColumn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfinalRow, finalColumn := row, column\n\t\t\t\t\tif !t.wrapHorizontally {\n\t\t\t\t\t\tfinalColumn = lastColumn\n\t\t\t\t\t} else if !t.wrapVertically {\n\t\t\t\t\t\tfinalRow = rowCount - 1\n\t\t\t\t\t\tfinalColumn = lastColumn\n\t\t\t\t\t}\n\t\t\t\t\tif !forward(finalRow, finalColumn) {\n\t\t\t\t\t\tbackwards(row, column)\n\t\t\t\t\t}\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.columnOffset++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpageDown = func() {\n\t\t\t\toffsetAmount := t.visibleRows - t.fixedRows\n\t\t\t\tif offsetAmount < 0 {\n\t\t\t\t\toffsetAmount = 0\n\t\t\t\t}\n\t\t\t\tif t.rowsSelectable {\n\t\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\t\tt.selectedRow += offsetAmount\n\t\t\t\t\tif t.selectedRow >= rowCount {\n\t\t\t\t\t\tt.selectedRow = rowCount - 1\n\t\t\t\t\t}\n\t\t\t\t\tfinalRow, finalColumn := rowCount-1, lastColumn\n\t\t\t\t\tif !forward(finalRow, finalColumn) {\n\t\t\t\t\t\tbackwards(row, column)\n\t\t\t\t\t}\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.rowOffset += offsetAmount\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpageUp = func() {\n\t\t\t\toffsetAmount := t.visibleRows - t.fixedRows\n\t\t\t\tif offsetAmount < 0 {\n\t\t\t\t\toffsetAmount = 0\n\t\t\t\t}\n\t\t\t\tif t.rowsSelectable {\n\t\t\t\t\trow, column := t.selectedRow, t.selectedColumn\n\t\t\t\t\tt.selectedRow -= offsetAmount\n\t\t\t\t\tif t.selectedRow < 0 {\n\t\t\t\t\t\tt.selectedRow = 0\n\t\t\t\t\t}\n\t\t\t\t\tfinalRow, finalColumn := 0, 0\n\t\t\t\t\tif !backwards(finalRow, finalColumn) {\n\t\t\t\t\t\tforward(row, column)\n\t\t\t\t\t}\n\t\t\t\t\tt.clampToSelection = true\n\t\t\t\t} else {\n\t\t\t\t\tt.trackEnd = false\n\t\t\t\t\tt.rowOffset -= offsetAmount\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\tswitch key {\n\t\tcase tcell.KeyRune:\n\t\t\tswitch event.Rune() {\n\t\t\tcase 'g':\n\t\t\t\thome()\n\t\t\tcase 'G':\n\t\t\t\tend()\n\t\t\tcase 'j':\n\t\t\t\tdown()\n\t\t\tcase 'k':\n\t\t\t\tup()\n\t\t\tcase 'h':\n\t\t\t\tleft()\n\t\t\tcase 'l':\n\t\t\t\tright()\n\t\t\t}\n\t\tcase tcell.KeyHome:\n\t\t\thome()\n\t\tcase tcell.KeyEnd:\n\t\t\tend()\n\t\tcase tcell.KeyUp:\n\t\t\tup()\n\t\tcase tcell.KeyDown:\n\t\t\tdown()\n\t\tcase tcell.KeyLeft:\n\t\t\tleft()\n\t\tcase tcell.KeyRight:\n\t\t\tright()\n\t\tcase tcell.KeyPgDn, tcell.KeyCtrlF:\n\t\t\tpageDown()\n\t\tcase tcell.KeyPgUp, tcell.KeyCtrlB:\n\t\t\tpageUp()\n\t\tcase tcell.KeyEnter:\n\t\t\tif (t.rowsSelectable || t.columnsSelectable) && t.selected != nil {\n\t\t\t\tt.selected(t.selectedRow, t.selectedColumn)\n\t\t\t}\n\t\t}\n\n\t\t// If the selection has changed, notify the handler.\n\t\tif t.selectionChanged != nil &&\n\t\t\t(t.rowsSelectable && previouslySelectedRow != t.selectedRow ||\n\t\t\t\tt.columnsSelectable && previouslySelectedColumn != t.selectedColumn) {\n\t\t\tt.selectionChanged(t.selectedRow, t.selectedColumn)\n\t\t}\n\t})\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (t *Table) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn t.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tx, y := event.Position()\n\t\tif !t.InRect(x, y) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tswitch action {\n\t\tcase MouseLeftDown:\n\t\t\tsetFocus(t)\n\t\t\tconsumed = true\n\t\tcase MouseLeftClick:\n\t\t\tselectEvent := true\n\t\t\trow, column := t.CellAt(x, y)\n\t\t\tcell := t.content.GetCell(row, column)\n\t\t\tif cell != nil && cell.Clicked != nil {\n\t\t\t\tif noSelect := cell.Clicked(); noSelect {\n\t\t\t\t\tselectEvent = false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif selectEvent && (t.rowsSelectable || t.columnsSelectable) {\n\t\t\t\tt.Select(row, column)\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollUp:\n\t\t\tt.trackEnd = false\n\t\t\tt.rowOffset--\n\t\t\tconsumed = true\n\t\tcase MouseScrollDown:\n\t\t\tt.rowOffset++\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n"
        },
        {
          "name": "textarea.go",
          "type": "blob",
          "size": 78.0673828125,
          "content": "package tview\n\nimport (\n\t\"math\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n\n\t\"github.com/gdamore/tcell/v2\"\n\t\"github.com/rivo/uniseg\"\n)\n\nconst (\n\t// The minimum capacity of the text area's piece chain slice.\n\tpieceChainMinCap = 10\n\n\t// The minimum capacity of the text area's edit buffer.\n\teditBufferMinCap = 200\n\n\t// The maximum number of bytes making up a grapheme cluster. In theory, this\n\t// could be longer but it would be highly unusual.\n\tmaxGraphemeClusterSize = 40\n\n\t// The default value for the [TextArea.minCursorPrefix] variable.\n\tminCursorPrefixDefault = 5\n\n\t// The default value for the [TextArea.minCursorSuffix] variable.\n\tminCursorSuffixDefault = 3\n)\n\n// Types of user actions on a text area.\ntype taAction int\n\nconst (\n\ttaActionOther        taAction = iota\n\ttaActionTypeSpace             // Typing a space character.\n\ttaActionTypeNonSpace          // Typing a non-space character.\n\ttaActionBackspace             // Deleting the previous character.\n\ttaActionDelete                // Deleting the next character.\n)\n\n// NewLine is the string sequence to be inserted when hitting the Enter key in a\n// TextArea. The default is \"\\n\" but you may change it to \"\\r\\n\" if required.\nvar NewLine = \"\\n\"\n\n// textAreaSpan represents a range of text in a text area. The text area widget\n// roughly follows the concept of Piece Chains outlined in\n// http://www.catch22.net/tuts/neatpad/piece-chains with some modifications.\n// This type represents a \"span\" (or \"piece\") and thus refers to a subset of the\n// text in the editor as part of a doubly-linked list.\n//\n// In most places where we reference a position in the text, we use a\n// three-element int array. The first element is the index of the referenced\n// span in the piece chain. The second element is the offset into the span's\n// referenced text (relative to the span's start), its value is always >= 0 and\n// < span.length. The third element is the state of the text parser at that\n// position.\n//\n// A range of text is represented by a span range which is a starting position\n// (3-int array) and an ending position (3-int array). The starting position\n// references the first character of the range, the ending position references\n// the position after the last character of the range. The end of the text is\n// therefore always [3]int{1, 0, 0}, position 0 of the ending sentinel.\n//\n// Sentinel spans are dummy spans not referring to any text. There are always\n// two sentinel spans: the starting span at index 0 of the [TextArea.spans]\n// slice and the ending span at index 1.\ntype textAreaSpan struct {\n\t// Links to the previous and next textAreaSpan objects as indices into the\n\t// [TextArea.spans] slice. The sentinel spans (index 0 and 1) have -1 as\n\t// their previous or next links, respectively.\n\tprevious, next int\n\n\t// The start index and the length of the text segment this span represents.\n\t// If \"length\" is negative, the span represents a substring of\n\t// [TextArea.initialText] and the actual length is its absolute value. If it\n\t// is positive, the span represents a substring of [TextArea.editText]. For\n\t// the sentinel spans (index 0 and 1), both values will be 0. Others will\n\t// never have a zero length.\n\toffset, length int\n}\n\n// textAreaUndoItem represents an undoable edit to the text area. It describes\n// the two spans wrapping a text change.\ntype textAreaUndoItem struct {\n\tbefore, after                 int    // The index of the copied \"before\" and \"after\" spans into the \"spans\" slice.\n\toriginalBefore, originalAfter int    // The original indices of the \"before\" and \"after\" spans.\n\tpos                           [3]int // The cursor position to be assumed after applying an undo.\n\tlength                        int    // The total text length at the time the undo item was created.\n\tcontinuation                  bool   // If true, this item is a continuation of the previous undo item. It is handled together with all other undo items in the same continuation sequence.\n}\n\n// TextArea implements a simple text editor for multi-line text. Multi-color\n// text is not supported. Word-wrapping is enabled by default but can be turned\n// off or be changed to character-wrapping.\n//\n// # Navigation and Editing\n//\n// A text area is always in editing mode and no other mode exists. The following\n// keys can be used to move the cursor (subject to what the user's terminal\n// supports and how it is configured):\n//\n//   - Left arrow: Move left.\n//   - Right arrow: Move right.\n//   - Down arrow: Move down.\n//   - Up arrow: Move up.\n//   - Ctrl-A, Home: Move to the beginning of the current line.\n//   - Ctrl-E, End: Move to the end of the current line.\n//   - Ctrl-F, page down: Move down by one page.\n//   - Ctrl-B, page up: Move up by one page.\n//   - Alt-Up arrow: Scroll the page up, leaving the cursor in its position.\n//   - Alt-Down arrow: Scroll the page down, leaving the cursor in its position.\n//   - Alt-Left arrow: Scroll the page to the left, leaving the cursor in its\n//     position. Ignored if wrapping is enabled.\n//   - Alt-Right arrow:  Scroll the page to the right, leaving the cursor in its\n//     position. Ignored if wrapping is enabled.\n//   - Alt-B, Ctrl-Left arrow: Jump to the beginning of the current or previous\n//     word.\n//   - Alt-F, Ctrl-Right arrow: Jump to the end of the current or next word.\n//\n// Words are defined according to [Unicode Standard Annex #29]. We skip any\n// words that contain only spaces or punctuation.\n//\n// Entering a character will insert it at the current cursor location.\n// Subsequent characters are shifted accordingly. If the cursor is outside the\n// visible area, any changes to the text will move it into the visible area. The\n// following keys can also be used to modify the text:\n//\n//   - Enter: Insert a newline character (see [NewLine]).\n//   - Tab: Insert a tab character (\\t). It will be rendered like [TabSize]\n//     spaces. (This may eventually be changed to behave like regular tabs.)\n//   - Ctrl-H, Backspace: Delete one character to the left of the cursor.\n//   - Ctrl-D, Delete: Delete the character under the cursor (or the first\n//     character on the next line if the cursor is at the end of a line).\n//   - Alt-Backspace: Delete the word to the left of the cursor.\n//   - Ctrl-K: Delete everything under and to the right of the cursor until the\n//     next newline character.\n//   - Ctrl-W: Delete from the start of the current word to the left of the\n//     cursor.\n//   - Ctrl-U: Delete the current line, i.e. everything after the last newline\n//     character before the cursor up until the next newline character. This may\n//     span multiple visible rows if wrapping is enabled.\n//\n// Text can be selected by moving the cursor while holding the Shift key, to the\n// extent that this is supported by the user's terminal. The Ctrl-L key can be\n// used to select the entire text. (Ctrl-A already binds to the \"Home\" key.)\n//\n// When text is selected:\n//\n//   - Entering a character will replace the selected text with the new\n//     character.\n//   - Backspace, delete, Ctrl-H, Ctrl-D: Delete the selected text.\n//   - Ctrl-Q: Copy the selected text into the clipboard, unselect the text.\n//   - Ctrl-X: Copy the selected text into the clipboard and delete it.\n//   - Ctrl-V: Replace the selected text with the clipboard text. If no text is\n//     selected, the clipboard text will be inserted at the cursor location.\n//\n// The Ctrl-Q key was chosen for the \"copy\" function because the Ctrl-C key is\n// the default key to stop the application. If your application frees up the\n// global Ctrl-C key and you want to bind it to the \"copy to clipboard\"\n// function, you may use [Box.SetInputCapture] to override the Ctrl-Q key to\n// implement copying to the clipboard. Note that using your terminal's /\n// operating system's key bindings for copy+paste functionality may not have the\n// expected effect as tview will not be able to handle these keys. Pasting text\n// using your operating system's or terminal's own methods may be very slow as\n// each character will be pasted individually. However, some terminals support\n// pasting text blocks which is supported by the text area, see\n// [Application.EnablePaste] for details.\n//\n// The default clipboard is an internal text buffer local to this text area\n// instance, i.e. the operating system's clipboard is not used. If you want to\n// implement your own clipboard (or make use of your operating system's\n// clipboard), you can use [TextArea.SetClipboard] which  provides all the\n// functionality needed to implement your own clipboard.\n//\n// The text area also supports Undo:\n//\n//   - Ctrl-Z: Undo the last change.\n//   - Ctrl-Y: Redo the last Undo change.\n//\n// Undo does not affect the clipboard.\n//\n// If the mouse is enabled, the following actions are available:\n//\n//   - Left click: Move the cursor to the clicked position or to the end of the\n//     line if past the last character.\n//   - Left double-click: Select the word under the cursor.\n//   - Left click while holding the Shift key: Select text.\n//   - Scroll wheel: Scroll the text.\n//\n// [Unicode Standard Annex #29]: https://unicode.org/reports/tr29/\ntype TextArea struct {\n\t*Box\n\n\t// Whether or not this text area is disabled/read-only.\n\tdisabled bool\n\n\t// The size of the text area. If set to 0, the text area will use the entire\n\t// available space.\n\twidth, height int\n\n\t// The text to be shown in the text area when it is empty.\n\tplaceholder string\n\n\t// The label text shown, usually when part of a form.\n\tlabel string\n\n\t// The width of the text area's label.\n\tlabelWidth int\n\n\t// Styles:\n\n\t// The label style.\n\tlabelStyle tcell.Style\n\n\t// The style of the text. Background colors different from the Box's\n\t// background color may lead to unwanted artefacts.\n\ttextStyle tcell.Style\n\n\t// The style of the selected text.\n\tselectedStyle tcell.Style\n\n\t// The style of the placeholder text.\n\tplaceholderStyle tcell.Style\n\n\t// Text manipulation related fields:\n\n\t// The text area's text prior to any editing. It is referenced by spans with\n\t// a negative length.\n\tinitialText string\n\n\t// Any text that's been added by the user at some point. We only ever append\n\t// to this buffer. It is referenced by spans with a positive length.\n\teditText strings.Builder\n\n\t// The total length of all text in the text area.\n\tlength int\n\n\t// The maximum number of bytes allowed in the text area. If 0, there is no\n\t// limit.\n\tmaxLength int\n\n\t// The piece chain. The first two spans are sentinel spans which don't\n\t// reference anything and always remain in the same place. Spans are never\n\t// deleted from this slice.\n\tspans []textAreaSpan\n\n\t// An optional function which transforms grapheme clusters. This can be used\n\t// to hide characters from the screen while preserving the original text.\n\ttransform func(cluster, rest string, boundaries int) (newCluster string, newBoundaries int)\n\n\t// Display, navigation, and cursor related fields:\n\n\t// If set to true, lines that are longer than the available width are\n\t// wrapped onto the next line. If set to false, any characters beyond the\n\t// available width are discarded.\n\twrap bool\n\n\t// If set to true and if wrap is also true, lines are split at spaces or\n\t// after punctuation characters.\n\twordWrap bool\n\n\t// The index of the first line shown in the text area.\n\trowOffset int\n\n\t// The number of cells to be skipped on each line (not used in wrap mode).\n\tcolumnOffset int\n\n\t// The inner height and width of the text area the last time it was drawn.\n\tlastHeight, lastWidth int\n\n\t// The width of the currently known widest line, as determined by\n\t// [TextArea.extendLines].\n\twidestLine int\n\n\t// Text positions and states of the start of lines. Each element is a span\n\t// position (see [textAreaSpan]). Not all lines of the text may be contained\n\t// at any time, extend as needed with the [TextArea.extendLines] function.\n\tlineStarts [][3]int\n\n\t// The cursor always points to the next position where a new character would\n\t// be placed. The selection start is the same as the cursor as long as there\n\t// is no selection. When there is one, the selection is between\n\t// selectionStart and cursor.\n\tcursor, selectionStart struct {\n\t\t// The row and column in screen space but relative to the start of the\n\t\t// text which may be outside the text area's box. The column value may\n\t\t// be larger than where the cursor actually is if the line the cursor\n\t\t// is on is shorter. The actualColumn is the position as it is seen on\n\t\t// screen. These three values may not be determined yet, in which case\n\t\t// the row is negative.\n\t\trow, column, actualColumn int\n\n\t\t// The textAreaSpan position with state for the actual next character.\n\t\tpos [3]int\n\t}\n\n\t// The minimum width of text (if available) to be shown left of the cursor.\n\tminCursorPrefix int\n\n\t// The minimum width of text (if available) to be shown right of the cursor.\n\tminCursorSuffix int\n\n\t// Set to true when the mouse is dragging to select text.\n\tdragging bool\n\n\t// Clipboard related fields:\n\n\t// The internal clipboard.\n\tclipboard string\n\n\t// The function to call when the user copies/cuts a text selection to the\n\t// clipboard.\n\tcopyToClipboard func(string)\n\n\t// The function to call when the user pastes text from the clipboard.\n\tpasteFromClipboard func() string\n\n\t// Undo/redo related fields:\n\n\t// The last action performed by the user.\n\tlastAction taAction\n\n\t// The undo stack's items. Each item is a copy of the span before the\n\t// modified span range and a copy of the span after the modified span range.\n\t// To undo an action, the two referenced spans are put back into their\n\t// original place. Undos and redos decrease or increase the nextUndo value.\n\t// Thus, the next undo action is not always the last item.\n\tundoStack []textAreaUndoItem\n\n\t// The current undo/redo position on the undo stack. If no undo or redo has\n\t// been performed yet, this is the same as len(undoStack).\n\tnextUndo int\n\n\t// Event handlers:\n\n\t// An optional function which is called when the input has changed.\n\tchanged func()\n\n\t// An optional function which is called when the position of the cursor or\n\t// the selection has changed.\n\tmoved func()\n\n\t// A callback function set by the Form class and called when the user leaves\n\t// this form item.\n\tfinished func(tcell.Key)\n}\n\n// NewTextArea returns a new text area. Use [TextArea.SetText] to set the\n// initial text.\nfunc NewTextArea() *TextArea {\n\tt := &TextArea{\n\t\tBox:              NewBox(),\n\t\twrap:             true,\n\t\twordWrap:         true,\n\t\tplaceholderStyle: tcell.StyleDefault.Background(Styles.PrimitiveBackgroundColor).Foreground(Styles.TertiaryTextColor),\n\t\tlabelStyle:       tcell.StyleDefault.Foreground(Styles.SecondaryTextColor),\n\t\ttextStyle:        tcell.StyleDefault.Background(Styles.PrimitiveBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\tselectedStyle:    tcell.StyleDefault.Background(Styles.PrimaryTextColor).Foreground(Styles.PrimitiveBackgroundColor),\n\t\tspans:            make([]textAreaSpan, 2, pieceChainMinCap), // We reserve some space to avoid reallocations right when editing starts.\n\t\tlastAction:       taActionOther,\n\t\tminCursorPrefix:  minCursorPrefixDefault,\n\t\tminCursorSuffix:  minCursorSuffixDefault,\n\t\tlastWidth:        math.MaxInt / 2, // We need this so some functions work before the first draw.\n\t\tlastHeight:       1,\n\t}\n\tt.editText.Grow(editBufferMinCap)\n\tt.spans[0] = textAreaSpan{previous: -1, next: 1}\n\tt.spans[1] = textAreaSpan{previous: 0, next: -1}\n\tt.cursor.pos = [3]int{1, 0, -1}\n\tt.selectionStart = t.cursor\n\tt.SetClipboard(nil, nil)\n\n\treturn t\n}\n\n// SetText sets the text of the text area. All existing text is deleted and\n// replaced with the new text. Any edits are discarded, no undos are available.\n// This function is typically only used to initialize the text area with a text\n// after it has been created. To clear the text area's text (again, no undos),\n// provide an empty string.\n//\n// If cursorAtTheEnd is false, the cursor is placed at the start of the text. If\n// it is true, it is placed at the end of the text. For very long texts, placing\n// the cursor at the end can be an expensive operation because the entire text\n// needs to be parsed and laid out.\n//\n// If you want to set text and preserve undo functionality, use\n// [TextArea.Replace] instead.\nfunc (t *TextArea) SetText(text string, cursorAtTheEnd bool) *TextArea {\n\tt.spans = t.spans[:2]\n\tt.initialText = text\n\tt.editText.Reset()\n\tt.lineStarts = nil\n\tt.length = len(text)\n\tt.rowOffset = 0\n\tt.columnOffset = 0\n\tt.reset()\n\tt.cursor.row, t.cursor.actualColumn, t.cursor.column = 0, 0, 0\n\tt.cursor.pos = [3]int{1, 0, -1}\n\tt.undoStack = t.undoStack[:0]\n\tt.nextUndo = 0\n\n\tif len(text) > 0 {\n\t\tt.spans = append(t.spans, textAreaSpan{\n\t\t\tprevious: 0,\n\t\t\tnext:     1,\n\t\t\toffset:   0,\n\t\t\tlength:   -len(text),\n\t\t})\n\t\tt.spans[0].next = 2\n\t\tt.spans[1].previous = 2\n\t\tif cursorAtTheEnd {\n\t\t\tt.cursor.row = -1\n\t\t\tif t.lastWidth > 0 {\n\t\t\t\tt.findCursor(true, 0)\n\t\t\t}\n\t\t} else {\n\t\t\tt.cursor.pos = [3]int{2, 0, -1}\n\t\t}\n\t} else {\n\t\tt.spans[0].next = 1\n\t\tt.spans[1].previous = 0\n\t}\n\tt.selectionStart = t.cursor\n\n\tif t.changed != nil {\n\t\tt.changed()\n\t}\n\n\tif t.lastWidth > 0 && t.moved != nil {\n\t\tt.moved()\n\t}\n\n\treturn t\n}\n\n// GetText returns the entire text of the text area. Note that this will newly\n// allocate the entire text.\nfunc (t *TextArea) GetText() string {\n\tif t.length == 0 {\n\t\treturn \"\"\n\t}\n\n\tvar text strings.Builder\n\ttext.Grow(t.length)\n\tspanIndex := t.spans[0].next\n\tfor spanIndex != 1 {\n\t\tspan := &t.spans[spanIndex]\n\t\tif span.length < 0 {\n\t\t\ttext.WriteString(t.initialText[span.offset : span.offset-span.length])\n\t\t} else {\n\t\t\ttext.WriteString(t.editText.String()[span.offset : span.offset+span.length])\n\t\t}\n\t\tspanIndex = t.spans[spanIndex].next\n\t}\n\n\treturn text.String()\n}\n\n// getTextBeforeCursor returns the text of the text area up until the cursor.\n// Note that this will result in a new allocation for the returned text.\nfunc (t *TextArea) getTextBeforeCursor() string {\n\tif t.length == 0 || t.cursor.pos[0] == t.spans[0].next && t.cursor.pos[1] == 0 {\n\t\treturn \"\"\n\t}\n\n\tvar text strings.Builder\n\tspanIndex := t.spans[0].next\n\tfor spanIndex != 1 {\n\t\tspan := &t.spans[spanIndex]\n\t\tlength := span.length\n\t\tif length < 0 {\n\t\t\tif t.cursor.pos[0] == spanIndex {\n\t\t\t\tlength = -t.cursor.pos[1]\n\t\t\t}\n\t\t\ttext.WriteString(t.initialText[span.offset : span.offset-length])\n\t\t} else {\n\t\t\tif t.cursor.pos[0] == spanIndex {\n\t\t\t\tlength = t.cursor.pos[1]\n\t\t\t}\n\t\t\ttext.WriteString(t.editText.String()[span.offset : span.offset+length])\n\t\t}\n\t\tif t.cursor.pos[0] == spanIndex {\n\t\t\tbreak\n\t\t}\n\t\tspanIndex = t.spans[spanIndex].next\n\t}\n\n\treturn text.String()\n}\n\n// getTextAfterCursor returns the text of the text area after the cursor. Note\n// that this will result in a new allocation for the returned text.\nfunc (t *TextArea) getTextAfterCursor() string {\n\tif t.length == 0 || t.cursor.pos[0] == 1 {\n\t\treturn \"\"\n\t}\n\n\tvar text strings.Builder\n\tspanIndex := t.cursor.pos[0]\n\tcursorOffset := t.cursor.pos[1]\n\tfor spanIndex != 1 {\n\t\tspan := &t.spans[spanIndex]\n\t\tlength := span.length\n\t\tif length < 0 {\n\t\t\ttext.WriteString(t.initialText[span.offset+cursorOffset : span.offset-length])\n\t\t} else {\n\t\t\ttext.WriteString(t.editText.String()[span.offset+cursorOffset : span.offset+length])\n\t\t}\n\t\tspanIndex = t.spans[spanIndex].next\n\t\tcursorOffset = 0\n\t}\n\n\treturn text.String()\n}\n\n// HasSelection returns whether the selected text is non-empty.\nfunc (t *TextArea) HasSelection() bool {\n\treturn t.selectionStart != t.cursor\n}\n\n// GetSelection returns the currently selected text and its start and end\n// positions within the entire text as a half-open interval. If the returned\n// text is an empty string, the start and end positions are the same and can be\n// interpreted as the cursor position.\n//\n// Calling this function will result in string allocations as well as a search\n// for text positions. This is expensive if the text has been edited extensively\n// already. Use [TextArea.HasSelection] first if you are only interested in\n// selected text.\nfunc (t *TextArea) GetSelection() (text string, start int, end int) {\n\tfrom, to := t.selectionStart.pos, t.cursor.pos\n\tif t.cursor.row < t.selectionStart.row || (t.cursor.row == t.selectionStart.row && t.cursor.actualColumn < t.selectionStart.actualColumn) {\n\t\tfrom, to = to, from\n\t}\n\n\tif from[0] == 1 {\n\t\tstart = t.length\n\t}\n\tif to[0] == 1 {\n\t\tend = t.length\n\t}\n\n\tvar (\n\t\tindex     int\n\t\tselection strings.Builder\n\t\tinside    bool\n\t)\n\tfor span := t.spans[0].next; span != 1; span = t.spans[span].next {\n\t\tvar spanText string\n\t\tlength := t.spans[span].length\n\t\tif length < 0 {\n\t\t\tlength = -length\n\t\t\tspanText = t.initialText\n\t\t} else {\n\t\t\tspanText = t.editText.String()\n\t\t}\n\t\tspanText = spanText[t.spans[span].offset : t.spans[span].offset+length]\n\n\t\tif from[0] == span && to[0] == span {\n\t\t\tif from != to {\n\t\t\t\tselection.WriteString(spanText[from[1]:to[1]])\n\t\t\t}\n\t\t\tstart = index + from[1]\n\t\t\tend = index + to[1]\n\t\t\tbreak\n\t\t} else if from[0] == span {\n\t\t\tif from != to {\n\t\t\t\tselection.WriteString(spanText[from[1]:])\n\t\t\t}\n\t\t\tstart = index + from[1]\n\t\t\tinside = true\n\t\t} else if to[0] == span {\n\t\t\tif from != to {\n\t\t\t\tselection.WriteString(spanText[:to[1]])\n\t\t\t}\n\t\t\tend = index + to[1]\n\t\t\tbreak\n\t\t} else if inside && from != to {\n\t\t\tselection.WriteString(spanText)\n\t\t}\n\n\t\tindex += length\n\t}\n\n\tif selection.Len() != 0 {\n\t\ttext = selection.String()\n\t}\n\treturn\n}\n\n// GetCursor returns the current cursor position where the first character of\n// the entire text is in row 0, column 0. If the user has selected text, the\n// \"from\" values will refer to the beginning of the selection and the \"to\"\n// values to the end of the selection (exclusive). They are the same if there\n// is no selection.\nfunc (t *TextArea) GetCursor() (fromRow, fromColumn, toRow, toColumn int) {\n\tfromRow, fromColumn = t.selectionStart.row, t.selectionStart.actualColumn\n\ttoRow, toColumn = t.cursor.row, t.cursor.actualColumn\n\tif toRow < fromRow || (toRow == fromRow && toColumn < fromColumn) {\n\t\tfromRow, fromColumn, toRow, toColumn = toRow, toColumn, fromRow, fromColumn\n\t}\n\tif t.length > 0 && t.wrap && fromColumn >= t.lastWidth { // This happens when a row has text all the way until the end, pushing the cursor outside the viewport.\n\t\tfromRow++\n\t\tfromColumn = 0\n\t}\n\tif t.length > 0 && t.wrap && toColumn >= t.lastWidth {\n\t\ttoRow++\n\t\ttoColumn = 0\n\t}\n\treturn\n}\n\n// GetTextLength returns the string length of the text in the text area.\nfunc (t *TextArea) GetTextLength() int {\n\treturn t.length\n}\n\n// Replace replaces a section of the text with new text. The start and end\n// positions refer to index positions within the entire text string (as a\n// half-open interval). They may be the same, in which case text is inserted at\n// the given position. If the text is an empty string, text between start and\n// end is deleted. Index positions will be shifted to line up with character\n// boundaries. A \"changed\" event will be triggered.\n//\n// Previous selections are cleared. The cursor will be located at the end of the\n// replaced text. Scroll offsets will not be changed. A \"moved\" event will be\n// triggered.\n//\n// The effects of this function can be undone (and redone) by the user.\nfunc (t *TextArea) Replace(start, end int, text string) *TextArea {\n\tt.Select(start, end)\n\trow := t.selectionStart.row\n\tt.cursor.pos = t.replace(t.selectionStart.pos, t.cursor.pos, text, false)\n\tt.cursor.row = -1\n\tt.truncateLines(row - 1)\n\tt.findCursor(false, row)\n\tt.selectionStart = t.cursor\n\tif t.moved != nil {\n\t\tt.moved()\n\t}\n\t// The \"changed\" event will have been triggered by the \"replace\" function.\n\treturn t\n}\n\n// Select selects a section of the text. The start and end positions refer to\n// index positions within the entire text string (as a half-open interval). They\n// may be the same, in which case the cursor is placed at the given position.\n// Any previous selection is removed. Scroll offsets will be preserved.\n//\n// Index positions will be shifted to line up with character boundaries.\nfunc (t *TextArea) Select(start, end int) *TextArea {\n\toldFrom, oldTo := t.selectionStart, t.cursor\n\tdefer func() {\n\t\tif (oldFrom != t.selectionStart || oldTo != t.cursor) && t.moved != nil {\n\t\t\tt.moved()\n\t\t}\n\t}()\n\n\t// Clamp input values.\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif start > t.length {\n\t\tstart = t.length\n\t}\n\tif end < 0 {\n\t\tend = 0\n\t}\n\tif end > t.length {\n\t\tend = t.length\n\t}\n\tif end < start {\n\t\tstart, end = end, start\n\t}\n\n\t// Find the cursor positions.\n\tvar row, index int\n\tt.cursor.row, t.cursor.pos = -1, [3]int{1, 0, -1}\n\tt.selectionStart = t.cursor\nRowLoop:\n\tfor {\n\t\tif row >= len(t.lineStarts) {\n\t\t\tt.extendLines(t.lastWidth, row)\n\t\t\tif row >= len(t.lineStarts) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Check the spans of this row.\n\t\tpos := t.lineStarts[row]\n\t\tvar (\n\t\t\tnext      [3]int\n\t\t\tlineIndex int\n\t\t)\n\t\tif row+1 < len(t.lineStarts) {\n\t\t\tnext = t.lineStarts[row+1]\n\t\t} else {\n\t\t\tnext = [3]int{1, 0, -1}\n\t\t}\n\t\tfor {\n\t\t\tif pos[0] == next[0] {\n\t\t\t\tif start >= index+lineIndex && start < index+lineIndex+next[1]-pos[1] ||\n\t\t\t\t\tend >= index+lineIndex && end < index+lineIndex+next[1]-pos[1] ||\n\t\t\t\t\tnext[0] == 1 && (start == t.length || end == t.length) { // Special case for the end of the text.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tindex += lineIndex + next[1] - pos[1]\n\t\t\t\trow++\n\t\t\t\tcontinue RowLoop // Move on to the next row.\n\t\t\t} else {\n\t\t\t\tlength := t.spans[pos[0]].length\n\t\t\t\tif length < 0 {\n\t\t\t\t\tlength = -length\n\t\t\t\t}\n\t\t\t\tif start >= index+lineIndex && start < index+lineIndex+length-pos[1] ||\n\t\t\t\t\tend >= index+lineIndex && end < index+lineIndex+length-pos[1] ||\n\t\t\t\t\tnext[0] == 1 && (start == t.length || end == t.length) { // Special case for the end of the text.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tlineIndex += length - pos[1]\n\t\t\t\tpos[0], pos[1] = t.spans[pos[0]].next, 0\n\t\t\t}\n\t\t}\n\n\t\t// One of the indices is in this row. Step through it.\n\t\tpos = t.lineStarts[row]\n\t\tendPos := pos\n\t\tvar (\n\t\t\tcluster, text string\n\t\t\tcolumn, width int\n\t\t)\n\t\tfor pos != next {\n\t\t\tif t.selectionStart.row < 0 && start <= index {\n\t\t\t\tt.selectionStart.row, t.selectionStart.column, t.selectionStart.actualColumn = row, column, column\n\t\t\t\tt.selectionStart.pos = pos\n\t\t\t}\n\t\t\tif t.cursor.row < 0 && end <= index {\n\t\t\t\tt.cursor.row, t.cursor.column, t.cursor.actualColumn = row, column, column\n\t\t\t\tt.cursor.pos = pos\n\t\t\t\tbreak RowLoop\n\t\t\t}\n\t\t\tcluster, text, _, width, pos, endPos = t.step(text, pos, endPos)\n\t\t\tindex += len(cluster)\n\t\t\tcolumn += width\n\t\t}\n\t\trow++\n\t}\n\n\tif t.cursor.row < 0 {\n\t\tt.findCursor(false, 0) // This only happens if we couldn't find the locations above.\n\t\tt.selectionStart = t.cursor\n\t}\n\n\treturn t\n}\n\n// SetWrap sets the flag that, if true, leads to lines that are longer than the\n// available width being wrapped onto the next line. If false, any characters\n// beyond the available width are not displayed.\nfunc (t *TextArea) SetWrap(wrap bool) *TextArea {\n\tif t.wrap != wrap {\n\t\tt.wrap = wrap\n\t\tt.reset()\n\t}\n\treturn t\n}\n\n// SetWordWrap sets the flag that causes lines that are longer than the\n// available width to be wrapped onto the next line at spaces or after\n// punctuation marks (according to [Unicode Standard Annex #14]). This flag is\n// ignored if the flag set with [TextArea.SetWrap] is false. The text area's\n// default is word-wrapping.\n//\n// [Unicode Standard Annex #14]: https://www.unicode.org/reports/tr14/\nfunc (t *TextArea) SetWordWrap(wrapOnWords bool) *TextArea {\n\tif t.wordWrap != wrapOnWords {\n\t\tt.wordWrap = wrapOnWords\n\t\tt.reset()\n\t}\n\treturn t\n}\n\n// SetPlaceholder sets the text to be displayed when the text area is empty.\nfunc (t *TextArea) SetPlaceholder(placeholder string) *TextArea {\n\tt.placeholder = placeholder\n\treturn t\n}\n\n// SetLabel sets the text to be displayed before the text area.\nfunc (t *TextArea) SetLabel(label string) *TextArea {\n\tt.label = label\n\treturn t\n}\n\n// GetLabel returns the text to be displayed before the text area.\nfunc (t *TextArea) GetLabel() string {\n\treturn t.label\n}\n\n// SetLabelWidth sets the screen width of the label. A value of 0 will cause the\n// primitive to use the width of the label string.\nfunc (t *TextArea) SetLabelWidth(width int) *TextArea {\n\tt.labelWidth = width\n\treturn t\n}\n\n// GetLabelWidth returns the screen width of the label.\nfunc (t *TextArea) GetLabelWidth() int {\n\treturn t.labelWidth\n}\n\n// SetSize sets the screen size of the input element of the text area. The input\n// element is always located next to the label which is always located in the\n// top left corner. If any of the values are 0 or larger than the available\n// space, the available space will be used.\nfunc (t *TextArea) SetSize(rows, columns int) *TextArea {\n\tt.width = columns\n\tt.height = rows\n\treturn t\n}\n\n// GetFieldWidth returns this primitive's field width.\nfunc (t *TextArea) GetFieldWidth() int {\n\treturn t.width\n}\n\n// GetFieldHeight returns this primitive's field height.\nfunc (t *TextArea) GetFieldHeight() int {\n\treturn t.height\n}\n\n// SetDisabled sets whether or not the item is disabled / read-only.\nfunc (t *TextArea) SetDisabled(disabled bool) FormItem {\n\tt.disabled = disabled\n\tif t.finished != nil {\n\t\tt.finished(-1)\n\t}\n\treturn t\n}\n\n// GetDisabled returns whether or not the item is disabled / read-only.\nfunc (t *TextArea) GetDisabled() bool {\n\treturn t.disabled\n}\n\n// SetMaxLength sets the maximum number of bytes allowed in the text area. A\n// value of 0 means there is no limit. If the text area currently contains more\n// bytes than this, it may violate this constraint.\nfunc (t *TextArea) SetMaxLength(maxLength int) *TextArea {\n\tt.maxLength = maxLength\n\treturn t\n}\n\n// setMinCursorPadding sets a minimum width to be reserved left and right of the\n// cursor. This is ignored if wrapping is enabled.\nfunc (t *TextArea) setMinCursorPadding(prefix, suffix int) *TextArea {\n\tt.minCursorPrefix = prefix\n\tt.minCursorSuffix = suffix\n\treturn t\n}\n\n// SetLabelStyle sets the style of the label.\nfunc (t *TextArea) SetLabelStyle(style tcell.Style) *TextArea {\n\tt.labelStyle = style\n\treturn t\n}\n\n// GetLabelStyle returns the style of the label.\nfunc (t *TextArea) GetLabelStyle() tcell.Style {\n\treturn t.labelStyle\n}\n\n// SetTextStyle sets the style of the text.\nfunc (t *TextArea) SetTextStyle(style tcell.Style) *TextArea {\n\tt.textStyle = style\n\treturn t\n}\n\n// GetTextStyle returns the style of the text.\nfunc (t *TextArea) GetTextStyle() tcell.Style {\n\treturn t.textStyle\n}\n\n// SetSelectedStyle sets the style of the selected text.\nfunc (t *TextArea) SetSelectedStyle(style tcell.Style) *TextArea {\n\tt.selectedStyle = style\n\treturn t\n}\n\n// SetPlaceholderStyle sets the style of the placeholder text.\nfunc (t *TextArea) SetPlaceholderStyle(style tcell.Style) *TextArea {\n\tt.placeholderStyle = style\n\treturn t\n}\n\n// GetPlaceholderStyle returns the style of the placeholder text.\nfunc (t *TextArea) GetPlaceholderStyle() tcell.Style {\n\treturn t.placeholderStyle\n}\n\n// GetOffset returns the text's offset, that is, the number of rows and columns\n// skipped during drawing at the top or on the left, respectively. Note that the\n// column offset is ignored if wrapping is enabled.\nfunc (t *TextArea) GetOffset() (row, column int) {\n\treturn t.rowOffset, t.columnOffset\n}\n\n// SetOffset sets the text's offset, that is, the number of rows and columns\n// skipped during drawing at the top or on the left, respectively. If wrapping\n// is enabled, the column offset is ignored. These values may get adjusted\n// automatically to ensure that some text is always visible.\nfunc (t *TextArea) SetOffset(row, column int) *TextArea {\n\tt.rowOffset, t.columnOffset = row, column\n\treturn t\n}\n\n// SetClipboard allows you to implement your own clipboard by providing a\n// function that is called when the user wishes to store text in the clipboard\n// (copyToClipboard) and a function that is called when the user wishes to\n// retrieve text from the clipboard (pasteFromClipboard).\n//\n// Providing nil values will cause the default clipboard implementation to be\n// used. Note that the default clipboard is local to this text area instance.\n// Copying text to other widgets will not work.\nfunc (t *TextArea) SetClipboard(copyToClipboard func(string), pasteFromClipboard func() string) *TextArea {\n\tt.copyToClipboard = copyToClipboard\n\tif t.copyToClipboard == nil {\n\t\tt.copyToClipboard = func(text string) {\n\t\t\tt.clipboard = text\n\t\t}\n\t}\n\n\tt.pasteFromClipboard = pasteFromClipboard\n\tif t.pasteFromClipboard == nil {\n\t\tt.pasteFromClipboard = func() string {\n\t\t\treturn t.clipboard\n\t\t}\n\t}\n\n\treturn t\n}\n\n// GetClipboardText returns the current text of the clipboard by calling the\n// pasteFromClipboard function set with [TextArea.SetClipboard].\nfunc (t *TextArea) GetClipboardText() string {\n\treturn t.pasteFromClipboard()\n}\n\n// SetChangedFunc sets a handler which is called whenever the text of the text\n// area has changed.\nfunc (t *TextArea) SetChangedFunc(handler func()) *TextArea {\n\tt.changed = handler\n\treturn t\n}\n\n// SetMovedFunc sets a handler which is called whenever the cursor position or\n// the text selection has changed.\nfunc (t *TextArea) SetMovedFunc(handler func()) *TextArea {\n\tt.moved = handler\n\treturn t\n}\n\n// SetFinishedFunc sets a callback invoked when the user leaves this form item.\nfunc (t *TextArea) SetFinishedFunc(handler func(key tcell.Key)) FormItem {\n\tt.finished = handler\n\treturn t\n}\n\n// Focus is called when this primitive receives focus.\nfunc (t *TextArea) Focus(delegate func(p Primitive)) {\n\t// If we're part of a form and this item is disabled, there's nothing the\n\t// user can do here so we're finished.\n\tif t.finished != nil && t.disabled {\n\t\tt.finished(-1)\n\t\treturn\n\t}\n\n\tt.Box.Focus(delegate)\n}\n\n// SetFormAttributes sets attributes shared by all form items.\nfunc (t *TextArea) SetFormAttributes(labelWidth int, labelColor, bgColor, fieldTextColor, fieldBgColor tcell.Color) FormItem {\n\tt.labelWidth = labelWidth\n\tt.backgroundColor = bgColor\n\tt.labelStyle = t.labelStyle.Foreground(labelColor)\n\tt.textStyle = tcell.StyleDefault.Foreground(fieldTextColor).Background(fieldBgColor)\n\treturn t\n}\n\n// replace deletes a range of text and inserts the given text at that position.\n// If the resulting text would exceed the maximum length, the function does not\n// do anything. The function returns the end position of the deleted/inserted\n// range.\n//\n// The function can hang if \"deleteStart\" is located after \"deleteEnd\".\n//\n// Undo events are always generated unless continuation is true and text is\n// either appended to the end of a span or a span is shortened at the beginning\n// or the end (and nothing else).\n//\n// This function only modifies [TextArea.lineStarts] to update span references\n// but does not change it to reflect the new layout.\n//\n// A \"changed\" event will be triggered.\nfunc (t *TextArea) replace(deleteStart, deleteEnd [3]int, insert string, continuation bool) [3]int {\n\t// Maybe nothing needs to be done?\n\tif deleteStart == deleteEnd && insert == \"\" || t.maxLength > 0 && len(insert) > 0 && t.length+len(insert) >= t.maxLength {\n\t\treturn deleteEnd\n\t}\n\n\t// Notify at the end.\n\tif t.changed != nil {\n\t\tdefer t.changed()\n\t}\n\n\t// Handle a few cases where we don't put anything onto the undo stack for\n\t// increased efficiency.\n\tif continuation {\n\t\t// Same action as the one before. An undo item was already generated for\n\t\t// this block of (same) actions. We're also only changing one character.\n\t\tswitch {\n\t\tcase insert == \"\" && deleteStart[1] != 0 && deleteEnd[1] == 0:\n\t\t\t// Simple backspace. Just shorten this span.\n\t\t\tlength := t.spans[deleteStart[0]].length\n\t\t\tif length < 0 {\n\t\t\t\tt.length -= -length - deleteStart[1]\n\t\t\t\tlength = -deleteStart[1]\n\t\t\t} else {\n\t\t\t\tt.length -= length - deleteStart[1]\n\t\t\t\tlength = deleteStart[1]\n\t\t\t}\n\t\t\tt.spans[deleteStart[0]].length = length\n\t\t\treturn deleteEnd\n\t\tcase insert == \"\" && deleteStart[1] == 0 && deleteEnd[1] != 0:\n\t\t\t// Simple delete. Just clip the beginning of this span.\n\t\t\tt.spans[deleteEnd[0]].offset += deleteEnd[1]\n\t\t\tif t.spans[deleteEnd[0]].length < 0 {\n\t\t\t\tt.spans[deleteEnd[0]].length += deleteEnd[1]\n\t\t\t} else {\n\t\t\t\tt.spans[deleteEnd[0]].length -= deleteEnd[1]\n\t\t\t}\n\t\t\tt.length -= deleteEnd[1]\n\t\t\tdeleteEnd[1] = 0\n\t\t\treturn deleteEnd\n\t\tcase insert != \"\" && deleteStart == deleteEnd && deleteEnd[1] == 0:\n\t\t\tprevious := t.spans[deleteStart[0]].previous\n\t\t\tbufferSpan := t.spans[previous]\n\t\t\tif bufferSpan.length > 0 && bufferSpan.offset+bufferSpan.length == t.editText.Len() {\n\t\t\t\t// Typing individual characters. Simply extend the edit buffer.\n\t\t\t\tlength, _ := t.editText.WriteString(insert)\n\t\t\t\tt.spans[previous].length += length\n\t\t\t\tt.length += length\n\t\t\t\treturn deleteEnd\n\t\t\t}\n\t\t}\n\t}\n\n\t// All other cases generate an undo item.\n\tbefore := t.spans[deleteStart[0]].previous\n\tafter := deleteEnd[0]\n\tif deleteEnd[1] > 0 {\n\t\tafter = t.spans[deleteEnd[0]].next\n\t}\n\tt.undoStack = t.undoStack[:t.nextUndo]\n\tt.undoStack = append(t.undoStack, textAreaUndoItem{\n\t\tbefore:         len(t.spans),\n\t\tafter:          len(t.spans) + 1,\n\t\toriginalBefore: before,\n\t\toriginalAfter:  after,\n\t\tlength:         t.length,\n\t\tpos:            t.cursor.pos,\n\t\tcontinuation:   continuation,\n\t})\n\tt.spans = append(t.spans, t.spans[before])\n\tt.spans = append(t.spans, t.spans[after])\n\tt.nextUndo++\n\n\t// Adjust total text length by subtracting everything between \"before\" and\n\t// \"after\". Inserted spans will be added back.\n\tfor index := deleteStart[0]; index != after; index = t.spans[index].next {\n\t\tif t.spans[index].length < 0 {\n\t\t\tt.length += t.spans[index].length\n\t\t} else {\n\t\t\tt.length -= t.spans[index].length\n\t\t}\n\t}\n\tt.spans[before].next = after\n\tt.spans[after].previous = before\n\n\t// We go from left to right, connecting new spans as needed. We update\n\t// \"before\" as the span to connect new spans to.\n\n\t// If we start deleting in the middle of a span, connect a partial span.\n\tif deleteStart[1] != 0 {\n\t\tspan := textAreaSpan{\n\t\t\tprevious: before,\n\t\t\tnext:     after,\n\t\t\toffset:   t.spans[deleteStart[0]].offset,\n\t\t\tlength:   deleteStart[1],\n\t\t}\n\t\tif t.spans[deleteStart[0]].length < 0 {\n\t\t\tspan.length = -span.length\n\t\t}\n\t\tt.length += deleteStart[1] // This was previously subtracted.\n\t\tt.spans[before].next = len(t.spans)\n\t\tt.spans[after].previous = len(t.spans)\n\t\tbefore = len(t.spans)\n\t\tfor row, lineStart := range t.lineStarts { // Also redirect line starts until the end of this new span.\n\t\t\tif lineStart[0] == deleteStart[0] {\n\t\t\t\tif lineStart[1] >= deleteStart[1] {\n\t\t\t\t\tt.lineStarts = t.lineStarts[:row] // Everything else is unknown at this point.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tt.lineStarts[row][0] = len(t.spans)\n\t\t\t}\n\t\t}\n\t\tt.spans = append(t.spans, span)\n\t}\n\n\t// If we insert text, connect a new span.\n\tif insert != \"\" {\n\t\tspan := textAreaSpan{\n\t\t\tprevious: before,\n\t\t\tnext:     after,\n\t\t\toffset:   t.editText.Len(),\n\t\t}\n\t\tspan.length, _ = t.editText.WriteString(insert)\n\t\tt.length += span.length\n\t\tt.spans[before].next = len(t.spans)\n\t\tt.spans[after].previous = len(t.spans)\n\t\tbefore = len(t.spans)\n\t\tt.spans = append(t.spans, span)\n\t}\n\n\t// If we stop deleting in the middle of a span, connect a partial span.\n\tif deleteEnd[1] != 0 {\n\t\tspan := textAreaSpan{\n\t\t\tprevious: before,\n\t\t\tnext:     after,\n\t\t\toffset:   t.spans[deleteEnd[0]].offset + deleteEnd[1],\n\t\t}\n\t\tlength := t.spans[deleteEnd[0]].length\n\t\tif length < 0 {\n\t\t\tspan.length = length + deleteEnd[1]\n\t\t\tt.length -= span.length // This was previously subtracted.\n\t\t} else {\n\t\t\tspan.length = length - deleteEnd[1]\n\t\t\tt.length += span.length // This was previously subtracted.\n\t\t}\n\t\tt.spans[before].next = len(t.spans)\n\t\tt.spans[after].previous = len(t.spans)\n\t\tdeleteEnd[0], deleteEnd[1] = len(t.spans), 0\n\t\tt.spans = append(t.spans, span)\n\t}\n\n\treturn deleteEnd\n}\n\n// Draw draws this primitive onto the screen.\nfunc (t *TextArea) Draw(screen tcell.Screen) {\n\tt.Box.DrawForSubclass(screen, t)\n\n\t// Prepare\n\tx, y, width, height := t.GetInnerRect()\n\tif width <= 0 || height <= 0 {\n\t\treturn // We have no space for anything.\n\t}\n\tcolumnOffset := t.columnOffset\n\tif t.wrap {\n\t\tcolumnOffset = 0\n\t}\n\n\t// Draw label.\n\t_, labelBg, _ := t.labelStyle.Decompose()\n\tif t.labelWidth > 0 {\n\t\tlabelWidth := t.labelWidth\n\t\tif labelWidth > width {\n\t\t\tlabelWidth = width\n\t\t}\n\t\tprintWithStyle(screen, t.label, x, y, 0, labelWidth, AlignLeft, t.labelStyle, labelBg == tcell.ColorDefault)\n\t\tx += labelWidth\n\t\twidth -= labelWidth\n\t} else {\n\t\t_, _, drawnWidth := printWithStyle(screen, t.label, x, y, 0, width, AlignLeft, t.labelStyle, labelBg == tcell.ColorDefault)\n\t\tx += drawnWidth\n\t\twidth -= drawnWidth\n\t}\n\n\t// What's the space for the input element?\n\tif t.width > 0 && t.width < width {\n\t\twidth = t.width\n\t}\n\tif t.height > 0 && t.height < height {\n\t\theight = t.height\n\t}\n\tif width <= 0 {\n\t\treturn // No space left for the text area.\n\t}\n\n\t// Draw the input element if necessary.\n\t_, bg, _ := t.textStyle.Decompose()\n\tif t.disabled {\n\t\tbg = t.backgroundColor\n\t}\n\tif bg != t.backgroundColor {\n\t\tfor row := 0; row < height; row++ {\n\t\t\tfor column := 0; column < width; column++ {\n\t\t\t\tscreen.SetContent(x+column, y+row, ' ', nil, t.textStyle)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Show/hide the cursor at the end.\n\tdefer func() {\n\t\tif t.HasFocus() {\n\t\t\trow, column := t.cursor.row, t.cursor.actualColumn\n\t\t\tif t.length > 0 && t.wrap && column >= t.lastWidth { // This happens when a row has text all the way until the end, pushing the cursor outside the viewport.\n\t\t\t\trow++\n\t\t\t\tcolumn = 0\n\t\t\t}\n\t\t\tif row >= 0 &&\n\t\t\t\trow-t.rowOffset >= 0 && row-t.rowOffset < height &&\n\t\t\t\tcolumn-columnOffset >= 0 && column-columnOffset < width {\n\t\t\t\tscreen.ShowCursor(x+column-columnOffset, y+row-t.rowOffset)\n\t\t\t} else {\n\t\t\t\tscreen.HideCursor()\n\t\t\t}\n\t\t}\n\t}()\n\n\t// No text, show placeholder.\n\tif t.length == 0 {\n\t\tt.lastHeight, t.lastWidth = height, width\n\t\tt.cursor.row, t.cursor.column, t.cursor.actualColumn, t.cursor.pos = 0, 0, 0, [3]int{1, 0, -1}\n\t\tt.rowOffset, t.columnOffset = 0, 0\n\t\tif len(t.placeholder) > 0 {\n\t\t\tt.drawPlaceholder(screen, x, y, width, height)\n\t\t}\n\t\treturn // We're done already.\n\t}\n\n\t// Make sure the visible lines are broken over.\n\tfirstDrawing := t.lastWidth == 0\n\tif t.lastWidth != width && t.lineStarts != nil {\n\t\tt.reset()\n\t}\n\tt.lastHeight, t.lastWidth = height, width\n\tt.extendLines(width, t.rowOffset+height)\n\tif len(t.lineStarts) <= t.rowOffset {\n\t\treturn // It's scrolled out of view.\n\t}\n\n\t// If the cursor position is unknown, find it. This usually only happens\n\t// before the screen is drawn for the first time.\n\tif t.cursor.row < 0 {\n\t\tt.findCursor(true, 0)\n\t\tif t.selectionStart.row < 0 {\n\t\t\tt.selectionStart = t.cursor\n\t\t}\n\t\tif firstDrawing && t.moved != nil {\n\t\t\tt.moved()\n\t\t}\n\t}\n\n\t// Print the text.\n\tvar cluster, text string\n\tline := t.rowOffset\n\tpos := t.lineStarts[line]\n\tendPos := pos\n\tposX, posY := 0, 0\n\tfor pos[0] != 1 {\n\t\tvar clusterWidth int\n\t\tcluster, text, _, clusterWidth, pos, endPos = t.step(text, pos, endPos)\n\n\t\t// Prepare drawing.\n\t\trunes := []rune(cluster)\n\t\tstyle := t.selectedStyle\n\t\tfromRow, fromColumn := t.cursor.row, t.cursor.actualColumn\n\t\ttoRow, toColumn := t.selectionStart.row, t.selectionStart.actualColumn\n\t\tif fromRow > toRow || fromRow == toRow && fromColumn > toColumn {\n\t\t\tfromRow, fromColumn, toRow, toColumn = toRow, toColumn, fromRow, fromColumn\n\t\t}\n\t\tif toRow < line ||\n\t\t\ttoRow == line && toColumn <= posX ||\n\t\t\tfromRow > line ||\n\t\t\tfromRow == line && fromColumn > posX {\n\t\t\tstyle = t.textStyle\n\t\t\tif t.disabled {\n\t\t\t\tstyle = style.Background(t.backgroundColor)\n\t\t\t}\n\t\t}\n\n\t\t// Selected tabs are a bit special.\n\t\tif cluster == \"\\t\" && style == t.selectedStyle {\n\t\t\tfor colX := 0; colX < clusterWidth && posX+colX-columnOffset < width; colX++ {\n\t\t\t\tscreen.SetContent(x+posX+colX-columnOffset, y+posY, ' ', nil, style)\n\t\t\t}\n\t\t}\n\n\t\t// Draw character.\n\t\tif posX+clusterWidth-columnOffset <= width && posX-columnOffset >= 0 && clusterWidth > 0 {\n\t\t\tscreen.SetContent(x+posX-columnOffset, y+posY, runes[0], runes[1:], style)\n\t\t}\n\n\t\t// Advance.\n\t\tposX += clusterWidth\n\t\tif line+1 < len(t.lineStarts) && t.lineStarts[line+1] == pos {\n\t\t\t// We must break over.\n\t\t\tposY++\n\t\t\tif posY >= height {\n\t\t\t\tbreak // Done.\n\t\t\t}\n\t\t\tposX = 0\n\t\t\tline++\n\t\t}\n\t}\n}\n\n// drawPlaceholder draws the placeholder text into the given rectangle. It does\n// not do anything if the text area already contains text or if there is no\n// placeholder text.\nfunc (t *TextArea) drawPlaceholder(screen tcell.Screen, x, y, width, height int) {\n\t// We use a TextView to draw the placeholder. It will take care of word\n\t// wrapping etc.\n\ttextView := NewTextView().\n\t\tSetText(t.placeholder).\n\t\tSetTextStyle(t.placeholderStyle)\n\ttextView.SetRect(x, y, width, height)\n\ttextView.Draw(screen)\n}\n\n// reset resets many of the local variables of the text area because they cannot\n// be used anymore and must be recalculated, typically after the text area's\n// size has changed.\nfunc (t *TextArea) reset() {\n\tt.truncateLines(0)\n\tif t.wrap {\n\t\tt.cursor.row = -1\n\t\tt.selectionStart.row = -1\n\t}\n\tt.widestLine = 0\n}\n\n// extendLines traverses the current text and extends [TextArea.lineStarts] such\n// that it describes at least maxLines+1 lines (or less if the text is shorter).\n// Text is laid out for the given width while respecting the wrapping settings.\n// It is assumed that if [TextArea.lineStarts] already has entries, they obey\n// the same rules.\n//\n// If width is 0, nothing happens.\nfunc (t *TextArea) extendLines(width, maxLines int) {\n\tif width <= 0 {\n\t\treturn\n\t}\n\n\t// Start with the first span.\n\tif len(t.lineStarts) == 0 {\n\t\tif len(t.spans) > 2 {\n\t\t\tt.lineStarts = append(t.lineStarts, [3]int{t.spans[0].next, 0, -1})\n\t\t} else {\n\t\t\treturn // No text.\n\t\t}\n\t}\n\n\t// Determine starting positions and starting spans.\n\tpos := t.lineStarts[len(t.lineStarts)-1] // The starting position is the last known line.\n\tendPos := pos\n\tvar (\n\t\tcluster, text                       string\n\t\tlineWidth, clusterWidth, boundaries int\n\t\tlastGraphemeBreak, lastLineBreak    [3]int\n\t\twidthSinceLineBreak                 int\n\t)\n\tfor pos[0] != 1 {\n\t\t// Get the next grapheme cluster.\n\t\tcluster, text, boundaries, clusterWidth, pos, endPos = t.step(text, pos, endPos)\n\t\tlineWidth += clusterWidth\n\t\twidthSinceLineBreak += clusterWidth\n\n\t\t// Any line breaks?\n\t\tif !t.wrap || lineWidth <= width {\n\t\t\tif boundaries&uniseg.MaskLine == uniseg.LineMustBreak && (len(text) > 0 || uniseg.HasTrailingLineBreakInString(cluster)) {\n\t\t\t\t// We must break over.\n\t\t\t\tt.lineStarts = append(t.lineStarts, pos)\n\t\t\t\tif lineWidth > t.widestLine {\n\t\t\t\t\tt.widestLine = lineWidth\n\t\t\t\t}\n\t\t\t\tlineWidth = 0\n\t\t\t\tlastGraphemeBreak = [3]int{}\n\t\t\t\tlastLineBreak = [3]int{}\n\t\t\t\twidthSinceLineBreak = 0\n\t\t\t\tif len(t.lineStarts) > maxLines {\n\t\t\t\t\tbreak // We have enough lines, we can stop.\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t} else { // t.wrap && lineWidth > width\n\t\t\tif !t.wordWrap || lastLineBreak == [3]int{} {\n\t\t\t\tif lastGraphemeBreak != [3]int{} { // We have at least one character on each line.\n\t\t\t\t\t// Break after last grapheme.\n\t\t\t\t\tt.lineStarts = append(t.lineStarts, lastGraphemeBreak)\n\t\t\t\t\tif lineWidth > t.widestLine {\n\t\t\t\t\t\tt.widestLine = lineWidth\n\t\t\t\t\t}\n\t\t\t\t\tlineWidth = clusterWidth\n\t\t\t\t\tlastLineBreak = [3]int{}\n\t\t\t\t}\n\t\t\t} else { // t.wordWrap && lastLineBreak != [3]int{}\n\t\t\t\t// Break after last line break opportunity.\n\t\t\t\tt.lineStarts = append(t.lineStarts, lastLineBreak)\n\t\t\t\tif lineWidth > t.widestLine {\n\t\t\t\t\tt.widestLine = lineWidth\n\t\t\t\t}\n\t\t\t\tlineWidth = widthSinceLineBreak\n\t\t\t\tlastLineBreak = [3]int{}\n\t\t\t}\n\t\t}\n\n\t\t// Analyze break opportunities.\n\t\tif boundaries&uniseg.MaskLine == uniseg.LineCanBreak {\n\t\t\tlastLineBreak = pos\n\t\t\twidthSinceLineBreak = 0\n\t\t}\n\t\tlastGraphemeBreak = pos\n\n\t\t// Can we stop?\n\t\tif len(t.lineStarts) > maxLines {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif lineWidth > t.widestLine {\n\t\tt.widestLine = lineWidth\n\t}\n}\n\n// truncateLines truncates the trailing lines of the [TextArea.lineStarts]\n// slice such that len(lineStarts) <= fromLine. If fromLine is negative, a value\n// of 0 is assumed. If it is greater than the length of lineStarts, nothing\n// happens.\nfunc (t *TextArea) truncateLines(fromLine int) {\n\tif fromLine < 0 {\n\t\tfromLine = 0\n\t}\n\tif fromLine < len(t.lineStarts) {\n\t\tt.lineStarts = t.lineStarts[:fromLine]\n\t}\n}\n\n// findCursor determines the cursor position if its \"row\" value is < 0\n// (=unknown) but only its span position (\"pos\" value) is known. If the cursor\n// position is already known (row >= 0), it can also be used to modify row and\n// column offsets such that the cursor is visible during the next call to\n// [TextArea.Draw], by setting \"clamp\" to true.\n//\n// To determine the cursor position, \"startRow\" helps reduce processing time by\n// indicating the lowest row in which searching should start. Set this to 0 if\n// you don't have any information where the cursor might be (but know that this\n// is expensive for long texts).\n//\n// The cursor's desired column will be set to its actual column.\nfunc (t *TextArea) findCursor(clamp bool, startRow int) {\n\tdefer func() {\n\t\tt.cursor.column = t.cursor.actualColumn\n\t}()\n\n\tif !clamp && t.cursor.row >= 0 || t.lastWidth <= 0 {\n\t\treturn // Nothing to do.\n\t}\n\n\t// Clamp to viewport.\n\tif clamp && t.cursor.row >= 0 {\n\t\tcursorRow := t.cursor.row\n\t\tif t.wrap && t.cursor.actualColumn >= t.lastWidth {\n\t\t\tcursorRow++ // A row can push the cursor just outside the viewport. It will wrap onto the next line.\n\t\t}\n\t\tif cursorRow < t.rowOffset {\n\t\t\t// We're above the viewport.\n\t\t\tt.rowOffset = cursorRow\n\t\t} else if cursorRow >= t.rowOffset+t.lastHeight {\n\t\t\t// We're below the viewport.\n\t\t\tt.rowOffset = cursorRow - t.lastHeight + 1\n\t\t\tif t.rowOffset >= len(t.lineStarts) {\n\t\t\t\tt.extendLines(t.lastWidth, t.rowOffset)\n\t\t\t\tif t.rowOffset >= len(t.lineStarts) {\n\t\t\t\t\tt.rowOffset = len(t.lineStarts) - 1\n\t\t\t\t\tif t.rowOffset < 0 {\n\t\t\t\t\t\tt.rowOffset = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !t.wrap {\n\t\t\tif t.cursor.actualColumn < t.columnOffset+t.minCursorPrefix {\n\t\t\t\t// We're left of the viewport.\n\t\t\t\tt.columnOffset = t.cursor.actualColumn - t.minCursorPrefix\n\t\t\t\tif t.columnOffset < 0 {\n\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t}\n\t\t\t} else if t.cursor.actualColumn >= t.columnOffset+t.lastWidth-t.minCursorSuffix {\n\t\t\t\t// We're right of the viewport.\n\t\t\t\tt.columnOffset = t.cursor.actualColumn - t.lastWidth + t.minCursorSuffix\n\t\t\t\tif t.columnOffset >= t.widestLine {\n\t\t\t\t\tt.columnOffset = t.widestLine - 1\n\t\t\t\t\tif t.columnOffset < 0 {\n\t\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\n\t}\n\n\t// The screen position of the cursor is unknown. Find it. This can be\n\t// expensive. First, find the row.\n\trow := startRow\n\tif row < 0 {\n\t\trow = 0\n\t}\nRowLoop:\n\tfor {\n\t\t// Examine the current row.\n\t\tif row+1 >= len(t.lineStarts) {\n\t\t\tt.extendLines(t.lastWidth, row+1)\n\t\t}\n\t\tif row >= len(t.lineStarts) {\n\t\t\tt.cursor.row, t.cursor.actualColumn, t.cursor.pos = row, 0, [3]int{1, 0, -1}\n\t\t\tbreak // It's the end of the text.\n\t\t}\n\n\t\t// Check this row's spans to see if the cursor is in this row.\n\t\tpos := t.lineStarts[row]\n\t\tfor pos[0] != 1 {\n\t\t\tif row+1 >= len(t.lineStarts) {\n\t\t\t\tbreak // It's the last row so the cursor must be in this row.\n\t\t\t}\n\t\t\tif t.cursor.pos[0] == pos[0] {\n\t\t\t\t// The cursor is in this span.\n\t\t\t\tif t.lineStarts[row+1][0] == pos[0] {\n\t\t\t\t\t// The next row starts with the same span.\n\t\t\t\t\tif t.cursor.pos[1] >= t.lineStarts[row+1][1] {\n\t\t\t\t\t\t// The cursor is not in this row.\n\t\t\t\t\t\trow++\n\t\t\t\t\t\tcontinue RowLoop\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// The cursor is in this row.\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// The next row starts with a different span. The cursor\n\t\t\t\t\t// must be in this row.\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// The cursor is in a different span.\n\t\t\t\tif t.lineStarts[row+1][0] == pos[0] {\n\t\t\t\t\t// The next row starts with the same span. This row is\n\t\t\t\t\t// irrelevant.\n\t\t\t\t\trow++\n\t\t\t\t\tcontinue RowLoop\n\t\t\t\t} else {\n\t\t\t\t\t// The next row starts with a different span. Move towards it.\n\t\t\t\t\tpos = [3]int{t.spans[pos[0]].next, 0, -1}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try to find the screen position in this row.\n\t\tpos = t.lineStarts[row]\n\t\tendPos := pos\n\t\tcolumn := 0\n\t\tvar text string\n\t\tfor {\n\t\t\tif pos[0] == 1 || t.cursor.pos[0] == pos[0] && t.cursor.pos[1] == pos[1] {\n\t\t\t\t// We found the position. We're done.\n\t\t\t\tt.cursor.row, t.cursor.actualColumn, t.cursor.pos = row, column, pos\n\t\t\t\tbreak RowLoop\n\t\t\t}\n\t\t\tvar clusterWidth int\n\t\t\t_, text, _, clusterWidth, pos, endPos = t.step(text, pos, endPos)\n\t\t\tif row+1 < len(t.lineStarts) && t.lineStarts[row+1] == pos {\n\t\t\t\t// We reached the end of the line. Go to the next one.\n\t\t\t\trow++\n\t\t\t\tcontinue RowLoop\n\t\t\t}\n\t\t\tcolumn += clusterWidth\n\t\t}\n\t}\n\n\tif clamp && t.cursor.row >= 0 {\n\t\t// We know the position now. Adapt offsets.\n\t\tt.findCursor(true, startRow)\n\t}\n}\n\n// setTransform sets the transform function to be used when drawing the text.\n// This function is called for each grapheme cluster and can be used to modify\n// the cluster, the cluster's screen width, and the cluster's boundaries. The\n// function is called with the original cluster, the rest of the text, the\n// original cluster's width, and the original cluster's boundaries. The function\n// must return the new cluster, the new width, and the new boundaries. This only\n// affects the drawing of the text, not the text content itself. The boundaries\n// values correspond to the values returned by\n// [github.com/rivo/uniseg.StepString].\nfunc (t *TextArea) setTransform(transform func(cluster, rest string, boundaries int) (newCluster string, newBoundaries int)) {\n\tt.transform = transform\n}\n\n// step is similar to [github.com/rivo/uniseg.StepString] but it iterates over\n// the piece chain, starting with \"pos\", a span position plus state (which may\n// be -1 for the start of the text). The returned \"boundaries\" value is the same\n// value returned by [github.com/rivo/uniseg.StepString], \"width\" is the screen\n// width of the grapheme. The \"pos\" and \"endPos\" positions refer to the start\n// and the end of the \"text\" string, respectively. For the first call, text may\n// be empty and pos/endPos may be the same. For consecutive calls, provide\n// \"rest\" as the text and \"newPos\" and \"newEndPos\" as the new positions/states.\n// An empty \"rest\" string indicates the end of the text. The \"endPos\" state is\n// irrelevant.\nfunc (t *TextArea) step(text string, pos, endPos [3]int) (cluster, rest string, boundaries, width int, newPos, newEndPos [3]int) {\n\tif pos[0] == 1 {\n\t\treturn // We're already past the end.\n\t}\n\n\t// We want to make sure we have a text at least the size of a grapheme\n\t// cluster.\n\tspan := t.spans[pos[0]]\n\tif len(text) < maxGraphemeClusterSize &&\n\t\t(span.length < 0 && -span.length-pos[1] >= maxGraphemeClusterSize ||\n\t\t\tspan.length > 0 && t.spans[pos[0]].length-pos[1] >= maxGraphemeClusterSize) {\n\t\t// We can use a substring of one span.\n\t\tif span.length < 0 {\n\t\t\ttext = t.initialText[span.offset+pos[1] : span.offset-span.length]\n\t\t} else {\n\t\t\ttext = t.editText.String()[span.offset+pos[1] : span.offset+span.length]\n\t\t}\n\t\tendPos = [3]int{span.next, 0, -1}\n\t} else {\n\t\t// We have to compose the text from multiple spans.\n\t\tfor len(text) < maxGraphemeClusterSize && endPos[0] != 1 {\n\t\t\tendSpan := t.spans[endPos[0]]\n\t\t\tvar moreText string\n\t\t\tif endSpan.length < 0 {\n\t\t\t\tmoreText = t.initialText[endSpan.offset+endPos[1] : endSpan.offset-endSpan.length]\n\t\t\t} else {\n\t\t\t\tmoreText = t.editText.String()[endSpan.offset+endPos[1] : endSpan.offset+endSpan.length]\n\t\t\t}\n\t\t\tif len(moreText) > maxGraphemeClusterSize {\n\t\t\t\tmoreText = moreText[:maxGraphemeClusterSize]\n\t\t\t}\n\t\t\ttext += moreText\n\t\t\tendPos[1] += len(moreText)\n\t\t\tif endPos[1] >= endSpan.length {\n\t\t\t\tendPos[0], endPos[1] = endSpan.next, 0\n\t\t\t}\n\t\t}\n\t}\n\n\t// Run the grapheme cluster iterator.\n\tcluster, text, boundaries, pos[2] = uniseg.StepString(text, pos[2])\n\tpos[1] += len(cluster)\n\tfor pos[0] != 1 && (span.length < 0 && pos[1] >= -span.length || span.length >= 0 && pos[1] >= span.length) {\n\t\tpos[0] = span.next\n\t\tif span.length < 0 {\n\t\t\tpos[1] += span.length\n\t\t} else {\n\t\t\tpos[1] -= span.length\n\t\t}\n\t\tspan = t.spans[pos[0]]\n\t}\n\n\tif t.transform != nil {\n\t\tcluster, boundaries = t.transform(cluster, text, boundaries)\n\t}\n\n\tif cluster == \"\\t\" {\n\t\twidth = TabSize\n\t} else {\n\t\twidth = boundaries >> uniseg.ShiftWidth\n\t}\n\n\treturn cluster, text, boundaries, width, pos, endPos\n}\n\n// moveCursor sets the cursor's screen position and span position for the given\n// row and column which are screen space coordinates relative to the top-left\n// corner of the text area's full text (visible or not). The column value may be\n// negative, in which case, the cursor will be placed at the end of the line.\n// The cursor's actual position will be aligned with a grapheme cluster\n// boundary. The next call to [TextArea.Draw] will attempt to keep the cursor in\n// the viewport.\nfunc (t *TextArea) moveCursor(row, column int) {\n\t// Are we within the range of rows?\n\tif len(t.lineStarts) <= row {\n\t\t// No. Extent the line buffer.\n\t\tt.extendLines(t.lastWidth, row)\n\t}\n\tif len(t.lineStarts) == 0 {\n\t\treturn // No lines. Nothing to do.\n\t}\n\tif row < 0 {\n\t\t// We're at the start of the text.\n\t\trow = 0\n\t\tcolumn = 0\n\t} else if row >= len(t.lineStarts) {\n\t\t// We're already past the end.\n\t\trow = len(t.lineStarts) - 1\n\t\tcolumn = -1\n\t}\n\n\t// Iterate through this row until we find the position.\n\tt.cursor.row, t.cursor.actualColumn = row, 0\n\tif t.wrap {\n\t\tt.cursor.actualColumn = 0\n\t}\n\tpos := t.lineStarts[row]\n\tendPos := pos\n\tvar text string\n\tfor pos[0] != 1 {\n\t\tvar clusterWidth int\n\t\toldPos := pos // We may have to revert to this position.\n\t\t_, text, _, clusterWidth, pos, endPos = t.step(text, pos, endPos)\n\t\tif len(t.lineStarts) > row+1 && pos == t.lineStarts[row+1] || // We've reached the end of the line.\n\t\t\tcolumn >= 0 && t.cursor.actualColumn+clusterWidth > column { // We're past the requested column.\n\t\t\tpos = oldPos\n\t\t\tbreak\n\t\t}\n\t\tt.cursor.actualColumn += clusterWidth\n\t}\n\n\tif column < 0 {\n\t\tt.cursor.column = t.cursor.actualColumn\n\t} else {\n\t\tt.cursor.column = column\n\t}\n\tt.cursor.pos = pos\n\tt.findCursor(true, row)\n}\n\n// moveWordRight moves the cursor to the end of the current or next word. If\n// after is set to true, the cursor will be placed after the word. If false, the\n// cursor will be placed on the last character of the word. If clamp is set to\n// true, the cursor will be visible during the next call to [TextArea.Draw].\nfunc (t *TextArea) moveWordRight(after, clamp bool) {\n\t// Because we rely on clampToCursor to calculate the new screen position,\n\t// this is an expensive operation for large texts.\n\tpos := t.cursor.pos\n\tendPos := pos\n\tvar (\n\t\tcluster, text string\n\t\tinWord        bool\n\t)\n\tfor pos[0] != 0 {\n\t\tvar boundaries int\n\t\toldPos := pos\n\t\tcluster, text, boundaries, _, pos, endPos = t.step(text, pos, endPos)\n\t\tif oldPos == t.cursor.pos {\n\t\t\tcontinue // Skip the first character.\n\t\t}\n\t\tfirstRune, _ := utf8.DecodeRuneInString(cluster)\n\t\tif !unicode.IsSpace(firstRune) && !unicode.IsPunct(firstRune) {\n\t\t\tinWord = true\n\t\t}\n\t\tif inWord && boundaries&uniseg.MaskWord != 0 {\n\t\t\tif !after {\n\t\t\t\tpos = oldPos\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\tstartRow := t.cursor.row\n\tt.cursor.row, t.cursor.column, t.cursor.actualColumn = -1, 0, 0\n\tt.cursor.pos = pos\n\tt.findCursor(clamp, startRow)\n}\n\n// moveWordLeft moves the cursor to the beginning of the current or previous\n// word. If clamp is true, the cursor will be visible during the next call to\n// [TextArea.Draw].\nfunc (t *TextArea) moveWordLeft(clamp bool) {\n\t// We go back row by row, trying to find the last word boundary before the\n\t// cursor.\n\trow := t.cursor.row\n\tif row+1 < len(t.lineStarts) {\n\t\tt.extendLines(t.lastWidth, row+1)\n\t}\n\tif row >= len(t.lineStarts) {\n\t\trow = len(t.lineStarts) - 1\n\t}\n\tfor row >= 0 {\n\t\tpos := t.lineStarts[row]\n\t\tendPos := pos\n\t\tvar lastWordBoundary [3]int\n\t\tvar (\n\t\t\tcluster, text string\n\t\t\tinWord        bool\n\t\t\tboundaries    int\n\t\t)\n\t\tfor pos[0] != 1 && pos != t.cursor.pos {\n\t\t\toldBoundaries := boundaries\n\t\t\toldPos := pos\n\t\t\tcluster, text, boundaries, _, pos, endPos = t.step(text, pos, endPos)\n\t\t\tfirstRune, _ := utf8.DecodeRuneInString(cluster)\n\t\t\twordRune := !unicode.IsSpace(firstRune) && !unicode.IsPunct(firstRune)\n\t\t\tif oldBoundaries&uniseg.MaskWord != 0 {\n\t\t\t\tif pos != t.cursor.pos && !inWord && wordRune {\n\t\t\t\t\t// A boundary transitioning from a space/punctuation word to\n\t\t\t\t\t// a letter word.\n\t\t\t\t\tlastWordBoundary = oldPos\n\t\t\t\t}\n\t\t\t\tinWord = false\n\t\t\t}\n\t\t\tif wordRune {\n\t\t\t\tinWord = true\n\t\t\t}\n\t\t}\n\t\tif lastWordBoundary[0] != 0 {\n\t\t\t// We found something.\n\t\t\tt.cursor.pos = lastWordBoundary\n\t\t\tbreak\n\t\t}\n\t\trow--\n\t}\n\tif row < 0 {\n\t\t// We didn't find anything. We're at the start of the text.\n\t\tt.cursor.pos = [3]int{t.spans[0].next, 0, -1}\n\t\trow = 0\n\t}\n\tt.cursor.row, t.cursor.column, t.cursor.actualColumn = -1, 0, 0\n\tt.findCursor(clamp, row)\n}\n\n// deleteLine deletes all characters between the last newline before the cursor\n// and the next newline after the cursor (inclusive).\nfunc (t *TextArea) deleteLine() {\n\t// We go back row by row, trying to find the last mandatory line break\n\t// before the cursor.\n\tstartRow := t.cursor.row\n\tif t.cursor.actualColumn == 0 && t.cursor.pos[0] == 1 {\n\t\tstartRow-- // If we're at the very end, delete the row before.\n\t}\n\tif startRow+1 < len(t.lineStarts) {\n\t\tt.extendLines(t.lastWidth, startRow+1)\n\t}\n\tif len(t.lineStarts) == 0 {\n\t\treturn // Nothing to delete.\n\t}\n\tif startRow >= len(t.lineStarts) {\n\t\tstartRow = len(t.lineStarts) - 1\n\t}\n\tfor startRow >= 0 {\n\t\t// What's the last rune before the start of the line?\n\t\tpos := t.lineStarts[startRow]\n\t\tspan := t.spans[pos[0]]\n\t\tvar text string\n\t\tif pos[1] > 0 {\n\t\t\t// Extract text from this span.\n\t\t\tif span.length < 0 {\n\t\t\t\ttext = t.initialText\n\t\t\t} else {\n\t\t\t\ttext = t.editText.String()\n\t\t\t}\n\t\t\ttext = text[:span.offset+pos[1]]\n\t\t} else {\n\t\t\t// Extract text from the previous span.\n\t\t\tif span.previous != 0 {\n\t\t\t\tspan = t.spans[span.previous]\n\t\t\t\tif span.length < 0 {\n\t\t\t\t\ttext = t.initialText[:span.offset-span.length]\n\t\t\t\t} else {\n\t\t\t\t\ttext = t.editText.String()[:span.offset+span.length]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif uniseg.HasTrailingLineBreakInString(text) {\n\t\t\t// The row before this one ends with a mandatory line break. This is\n\t\t\t// the first line we will delete.\n\t\t\tbreak\n\t\t}\n\t\tstartRow--\n\t}\n\tif startRow < 0 {\n\t\t// We didn't find anything. It'll be the first line.\n\t\tstartRow = 0\n\t}\n\n\t// Find the next line break after the cursor.\n\tpos := t.cursor.pos\n\tendPos := pos\n\tvar cluster, text string\n\tfor pos[0] != 1 {\n\t\tcluster, text, _, _, pos, endPos = t.step(text, pos, endPos)\n\t\tif uniseg.HasTrailingLineBreakInString(cluster) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Delete the text.\n\tt.cursor.pos = t.replace(t.lineStarts[startRow], pos, \"\", false)\n\tt.cursor.row = -1\n\tt.truncateLines(startRow)\n\tt.findCursor(true, startRow)\n}\n\n// getSelection returns the current selection as span locations where the first\n// returned location is always before or the same as the second returned\n// location. This assumes that the cursor and selection positions are known. The\n// third return value is the starting row of the selection.\nfunc (t *TextArea) getSelection() ([3]int, [3]int, int) {\n\tfrom := t.selectionStart.pos\n\tto := t.cursor.pos\n\trow := t.selectionStart.row\n\tif t.cursor.row < t.selectionStart.row ||\n\t\t(t.cursor.row == t.selectionStart.row && t.cursor.actualColumn < t.selectionStart.actualColumn) {\n\t\tfrom, to = to, from\n\t\trow = t.cursor.row\n\t}\n\treturn from, to, row\n}\n\n// getSelectedText returns the text of the current selection.\nfunc (t *TextArea) getSelectedText() string {\n\tvar text strings.Builder\n\n\tfrom, to, _ := t.getSelection()\n\tfor from[0] != to[0] {\n\t\tspan := t.spans[from[0]]\n\t\tif span.length < 0 {\n\t\t\ttext.WriteString(t.initialText[span.offset+from[1] : span.offset-span.length])\n\t\t} else {\n\t\t\ttext.WriteString(t.editText.String()[span.offset+from[1] : span.offset+span.length])\n\t\t}\n\t\tfrom[0], from[1] = span.next, 0\n\t}\n\tif from[0] != 1 && from[1] < to[1] {\n\t\tspan := t.spans[from[0]]\n\t\tif span.length < 0 {\n\t\t\ttext.WriteString(t.initialText[span.offset+from[1] : span.offset+to[1]])\n\t\t} else {\n\t\t\ttext.WriteString(t.editText.String()[span.offset+from[1] : span.offset+to[1]])\n\t\t}\n\t}\n\n\treturn text.String()\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (t *TextArea) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn t.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tif t.disabled {\n\t\t\treturn\n\t\t}\n\n\t\t// All actions except a few specific ones are \"other\" actions.\n\t\tnewLastAction := taActionOther\n\t\tdefer func() {\n\t\t\tt.lastAction = newLastAction\n\t\t}()\n\n\t\t// Trigger a \"moved\" event if requested.\n\t\tif t.moved != nil {\n\t\t\tselectionStart, cursor := t.selectionStart, t.cursor\n\t\t\tdefer func() {\n\t\t\t\tif selectionStart != t.selectionStart || cursor != t.cursor {\n\t\t\t\t\tt.moved()\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\t// Process the different key events.\n\t\tswitch key := event.Key(); key {\n\t\tcase tcell.KeyLeft: // Move one grapheme cluster to the left.\n\t\t\tif event.Modifiers()&tcell.ModAlt == 0 {\n\t\t\t\t// Regular movement.\n\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 && t.selectionStart.pos != t.cursor.pos {\n\t\t\t\t\t// Move to the start of the selection.\n\t\t\t\t\tif t.selectionStart.row < t.cursor.row || (t.selectionStart.row == t.cursor.row && t.selectionStart.actualColumn < t.cursor.actualColumn) {\n\t\t\t\t\t\tt.cursor = t.selectionStart\n\t\t\t\t\t}\n\t\t\t\t\tt.findCursor(true, t.cursor.row)\n\t\t\t\t} else if event.Modifiers()&tcell.ModMeta != 0 || event.Modifiers()&tcell.ModCtrl != 0 {\n\t\t\t\t\t// This captures Ctrl-Left on some systems.\n\t\t\t\t\tt.moveWordLeft(event.Modifiers()&tcell.ModShift != 0)\n\t\t\t\t} else if t.cursor.actualColumn == 0 {\n\t\t\t\t\t// Move to the end of the previous row.\n\t\t\t\t\tif t.cursor.row > 0 {\n\t\t\t\t\t\tt.moveCursor(t.cursor.row-1, -1)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Move one grapheme cluster to the left.\n\t\t\t\t\tt.moveCursor(t.cursor.row, t.cursor.actualColumn-1)\n\t\t\t\t}\n\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\t}\n\t\t\t} else if !t.wrap { // This doesn't work on all terminals.\n\t\t\t\t// Just scroll.\n\t\t\t\tt.columnOffset--\n\t\t\t\tif t.columnOffset < 0 {\n\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t}\n\t\t\t}\n\t\tcase tcell.KeyRight: // Move one grapheme cluster to the right.\n\t\t\tif event.Modifiers()&tcell.ModAlt == 0 {\n\t\t\t\t// Regular movement.\n\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 && t.selectionStart.pos != t.cursor.pos {\n\t\t\t\t\t// Move to the end of the selection.\n\t\t\t\t\tif t.selectionStart.row > t.cursor.row || (t.selectionStart.row == t.cursor.row && t.selectionStart.actualColumn > t.cursor.actualColumn) {\n\t\t\t\t\t\tt.cursor = t.selectionStart\n\t\t\t\t\t}\n\t\t\t\t\tt.findCursor(true, t.cursor.row)\n\t\t\t\t} else if t.cursor.pos[0] != 1 {\n\t\t\t\t\tif event.Modifiers()&tcell.ModMeta != 0 || event.Modifiers()&tcell.ModCtrl != 0 {\n\t\t\t\t\t\t// This captures Ctrl-Right on some systems.\n\t\t\t\t\t\tt.moveWordRight(event.Modifiers()&tcell.ModShift != 0, true)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Move one grapheme cluster to the right.\n\t\t\t\t\t\tvar clusterWidth int\n\t\t\t\t\t\t_, _, _, clusterWidth, t.cursor.pos, _ = t.step(\"\", t.cursor.pos, t.cursor.pos)\n\t\t\t\t\t\tif len(t.lineStarts) <= t.cursor.row+1 {\n\t\t\t\t\t\t\tt.extendLines(t.lastWidth, t.cursor.row+1)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif t.cursor.row+1 < len(t.lineStarts) && t.lineStarts[t.cursor.row+1] == t.cursor.pos {\n\t\t\t\t\t\t\t// We've reached the end of the line.\n\t\t\t\t\t\t\tt.cursor.row++\n\t\t\t\t\t\t\tt.cursor.actualColumn = 0\n\t\t\t\t\t\t\tt.cursor.column = 0\n\t\t\t\t\t\t\tt.findCursor(true, t.cursor.row)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Move one character to the right.\n\t\t\t\t\t\t\tt.moveCursor(t.cursor.row, t.cursor.actualColumn+clusterWidth)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\t}\n\t\t\t} else if !t.wrap { // This doesn't work on all terminals.\n\t\t\t\t// Just scroll.\n\t\t\t\tt.columnOffset++\n\t\t\t\tif t.columnOffset >= t.widestLine {\n\t\t\t\t\tt.columnOffset = t.widestLine - 1\n\t\t\t\t\tif t.columnOffset < 0 {\n\t\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase tcell.KeyDown: // Move one row down.\n\t\t\tif event.Modifiers()&tcell.ModAlt == 0 {\n\t\t\t\t// Regular movement.\n\t\t\t\tcolumn := t.cursor.column\n\t\t\t\tt.moveCursor(t.cursor.row+1, t.cursor.column)\n\t\t\t\tt.cursor.column = column\n\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Just scroll.\n\t\t\t\tt.rowOffset++\n\t\t\t\tif t.rowOffset >= len(t.lineStarts) {\n\t\t\t\t\tt.extendLines(t.lastWidth, t.rowOffset)\n\t\t\t\t\tif t.rowOffset >= len(t.lineStarts) {\n\t\t\t\t\t\tt.rowOffset = len(t.lineStarts) - 1\n\t\t\t\t\t\tif t.rowOffset < 0 {\n\t\t\t\t\t\t\tt.rowOffset = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcase tcell.KeyUp: // Move one row up.\n\t\t\tif event.Modifiers()&tcell.ModAlt == 0 {\n\t\t\t\t// Regular movement.\n\t\t\t\tcolumn := t.cursor.column\n\t\t\t\tt.moveCursor(t.cursor.row-1, t.cursor.column)\n\t\t\t\tt.cursor.column = column\n\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Just scroll.\n\t\t\t\tt.rowOffset--\n\t\t\t\tif t.rowOffset < 0 {\n\t\t\t\t\tt.rowOffset = 0\n\t\t\t\t}\n\t\t\t}\n\t\tcase tcell.KeyHome, tcell.KeyCtrlA: // Move to the start of the line.\n\t\t\tt.moveCursor(t.cursor.row, 0)\n\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\tcase tcell.KeyEnd, tcell.KeyCtrlE: // Move to the end of the line.\n\t\t\tt.moveCursor(t.cursor.row, -1)\n\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\tcase tcell.KeyPgDn, tcell.KeyCtrlF: // Move one page down.\n\t\t\tcolumn := t.cursor.column\n\t\t\tt.moveCursor(t.cursor.row+t.lastHeight, t.cursor.column)\n\t\t\tt.cursor.column = column\n\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\tcase tcell.KeyPgUp, tcell.KeyCtrlB: // Move one page up.\n\t\t\tcolumn := t.cursor.column\n\t\t\tt.moveCursor(t.cursor.row-t.lastHeight, t.cursor.column)\n\t\t\tt.cursor.column = column\n\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\tcase tcell.KeyEnter: // Insert a newline.\n\t\t\tfrom, to, row := t.getSelection()\n\t\t\tt.cursor.pos = t.replace(from, to, NewLine, t.lastAction == taActionTypeSpace)\n\t\t\tt.cursor.row = -1\n\t\t\tt.truncateLines(row - 1)\n\t\t\tt.findCursor(true, row)\n\t\t\tt.selectionStart = t.cursor\n\t\t\tnewLastAction = taActionTypeSpace\n\t\tcase tcell.KeyTab: // Insert a tab character. It will be rendered as TabSize spaces.\n\t\t\t// But forwarding takes precedence.\n\t\t\tif t.finished != nil {\n\t\t\t\tt.finished(key)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfrom, to, row := t.getSelection()\n\t\t\tt.cursor.pos = t.replace(from, to, \"\\t\", t.lastAction == taActionTypeSpace)\n\t\t\tt.cursor.row = -1\n\t\t\tt.truncateLines(row - 1)\n\t\t\tt.findCursor(true, row)\n\t\t\tt.selectionStart = t.cursor\n\t\t\tnewLastAction = taActionTypeSpace\n\t\tcase tcell.KeyBacktab, tcell.KeyEscape: // Only used in forms.\n\t\t\tif t.finished != nil {\n\t\t\t\tt.finished(key)\n\t\t\t\treturn\n\t\t\t}\n\t\tcase tcell.KeyRune:\n\t\t\tif event.Modifiers()&tcell.ModAlt > 0 {\n\t\t\t\t// We accept some Alt- key combinations.\n\t\t\t\tswitch event.Rune() {\n\t\t\t\tcase 'f':\n\t\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\t\t\tt.moveWordRight(false, true)\n\t\t\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\t\t} else {\n\t\t\t\t\t\tt.moveWordRight(true, true)\n\t\t\t\t\t}\n\t\t\t\tcase 'b':\n\t\t\t\t\tt.moveWordLeft(true)\n\t\t\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Other keys are simply accepted as regular characters.\n\t\t\t\tr := event.Rune()\n\t\t\t\tfrom, to, row := t.getSelection()\n\t\t\t\tnewLastAction = taActionTypeNonSpace\n\t\t\t\tif unicode.IsSpace(r) {\n\t\t\t\t\tnewLastAction = taActionTypeSpace\n\t\t\t\t}\n\t\t\t\tt.cursor.pos = t.replace(from, to, string(r), newLastAction == t.lastAction || t.lastAction == taActionTypeNonSpace && newLastAction == taActionTypeSpace)\n\t\t\t\tt.cursor.row = -1\n\t\t\t\tt.truncateLines(row - 1)\n\t\t\t\tt.findCursor(true, row)\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\tcase tcell.KeyBackspace, tcell.KeyBackspace2: // Delete backwards. tcell.KeyBackspace is the same as tcell.CtrlH.\n\t\t\tfrom, to, row := t.getSelection()\n\t\t\tif from != to {\n\t\t\t\t// Simply delete the current selection.\n\t\t\t\tt.cursor.pos = t.replace(from, to, \"\", false)\n\t\t\t\tt.cursor.row = -1\n\t\t\t\tt.truncateLines(row - 1)\n\t\t\t\tt.findCursor(true, row)\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tbeforeCursor := t.cursor\n\t\t\tif event.Modifiers()&tcell.ModAlt == 0 {\n\t\t\t\t// Move the cursor back by one grapheme cluster.\n\t\t\t\tif t.cursor.actualColumn == 0 {\n\t\t\t\t\t// Move to the end of the previous row.\n\t\t\t\t\tif t.cursor.row > 0 {\n\t\t\t\t\t\tt.moveCursor(t.cursor.row-1, -1)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Move one grapheme cluster to the left.\n\t\t\t\t\tt.moveCursor(t.cursor.row, t.cursor.actualColumn-1)\n\t\t\t\t}\n\t\t\t\tnewLastAction = taActionBackspace\n\t\t\t} else {\n\t\t\t\t// Move the cursor back by one word.\n\t\t\t\tt.moveWordLeft(false)\n\t\t\t}\n\n\t\t\t// Remove that last grapheme cluster.\n\t\t\tif t.cursor.pos != beforeCursor.pos {\n\t\t\t\tt.cursor, beforeCursor = beforeCursor, t.cursor                                                 // So we put the right position on the stack.\n\t\t\t\tt.cursor.pos = t.replace(beforeCursor.pos, t.cursor.pos, \"\", t.lastAction == taActionBackspace) // Delete the character.\n\t\t\t\tt.cursor.row = -1\n\t\t\t\tt.truncateLines(beforeCursor.row - 1)\n\t\t\t\tt.findCursor(true, beforeCursor.row-1)\n\t\t\t}\n\t\t\tt.selectionStart = t.cursor\n\t\tcase tcell.KeyDelete, tcell.KeyCtrlD: // Delete forward.\n\t\t\tfrom, to, row := t.getSelection()\n\t\t\tif from != to {\n\t\t\t\t// Simply delete the current selection.\n\t\t\t\tt.cursor.pos = t.replace(from, to, \"\", false)\n\t\t\t\tt.cursor.row = -1\n\t\t\t\tt.truncateLines(row - 1)\n\t\t\t\tt.findCursor(true, row)\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif t.cursor.pos[0] != 1 {\n\t\t\t\t_, _, _, _, endPos, _ := t.step(\"\", t.cursor.pos, t.cursor.pos)\n\t\t\t\tt.cursor.pos = t.replace(t.cursor.pos, endPos, \"\", t.lastAction == taActionDelete) // Delete the character.\n\t\t\t\tt.cursor.pos[2] = endPos[2]\n\t\t\t\tt.truncateLines(t.cursor.row - 1)\n\t\t\t\tt.findCursor(true, t.cursor.row)\n\t\t\t\tnewLastAction = taActionDelete\n\t\t\t}\n\t\t\tt.selectionStart = t.cursor\n\t\tcase tcell.KeyCtrlK: // Delete everything under and to the right of the cursor until before the next newline character.\n\t\t\tpos := t.cursor.pos\n\t\t\tendPos := pos\n\t\t\tvar cluster, text string\n\t\t\tfor pos[0] != 1 {\n\t\t\t\tvar boundaries int\n\t\t\t\toldPos := pos\n\t\t\t\tcluster, text, boundaries, _, pos, endPos = t.step(text, pos, endPos)\n\t\t\t\tif boundaries&uniseg.MaskLine == uniseg.LineMustBreak {\n\t\t\t\t\tif uniseg.HasTrailingLineBreakInString(cluster) {\n\t\t\t\t\t\tpos = oldPos\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.cursor.pos = t.replace(t.cursor.pos, pos, \"\", false)\n\t\t\trow := t.cursor.row\n\t\t\tt.cursor.row = -1\n\t\t\tt.truncateLines(row - 1)\n\t\t\tt.findCursor(true, row)\n\t\t\tt.selectionStart = t.cursor\n\t\tcase tcell.KeyCtrlW: // Delete from the start of the current word to the left of the cursor.\n\t\t\tpos := t.cursor.pos\n\t\t\tt.moveWordLeft(true)\n\t\t\tt.cursor.pos = t.replace(t.cursor.pos, pos, \"\", false)\n\t\t\trow := t.cursor.row - 1\n\t\t\tt.cursor.row = -1\n\t\t\tt.truncateLines(row)\n\t\t\tt.findCursor(true, row)\n\t\t\tt.selectionStart = t.cursor\n\t\tcase tcell.KeyCtrlU: // Delete the current line.\n\t\t\tt.deleteLine()\n\t\t\tt.selectionStart = t.cursor\n\t\tcase tcell.KeyCtrlL: // Select everything.\n\t\t\tt.selectionStart.row, t.selectionStart.column, t.selectionStart.actualColumn = 0, 0, 0\n\t\t\tt.selectionStart.pos = [3]int{t.spans[0].next, 0, -1}\n\t\t\trow := t.cursor.row\n\t\t\tt.cursor.row = -1\n\t\t\tt.cursor.pos = [3]int{1, 0, -1}\n\t\t\tt.findCursor(false, row)\n\t\tcase tcell.KeyCtrlQ: // Copy to clipboard.\n\t\t\tif t.cursor != t.selectionStart {\n\t\t\t\tt.copyToClipboard(t.getSelectedText())\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\tcase tcell.KeyCtrlX: // Cut to clipboard.\n\t\t\tif t.cursor != t.selectionStart {\n\t\t\t\tt.copyToClipboard(t.getSelectedText())\n\t\t\t\tfrom, to, row := t.getSelection()\n\t\t\t\tt.cursor.pos = t.replace(from, to, \"\", false)\n\t\t\t\tt.cursor.row = -1\n\t\t\t\tt.truncateLines(row - 1)\n\t\t\t\tt.findCursor(true, row)\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\tcase tcell.KeyCtrlV: // Paste from clipboard.\n\t\t\tfrom, to, row := t.getSelection()\n\t\t\tt.cursor.pos = t.replace(from, to, t.pasteFromClipboard(), false)\n\t\t\tt.cursor.row = -1\n\t\t\tt.truncateLines(row - 1)\n\t\t\tt.findCursor(true, row)\n\t\t\tt.selectionStart = t.cursor\n\t\tcase tcell.KeyCtrlZ: // Undo.\n\t\t\tif t.nextUndo <= 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfor t.nextUndo > 0 {\n\t\t\t\tt.nextUndo--\n\t\t\t\tundo := t.undoStack[t.nextUndo]\n\t\t\t\tt.spans[undo.originalBefore], t.spans[undo.before] = t.spans[undo.before], t.spans[undo.originalBefore]\n\t\t\t\tt.spans[undo.originalAfter], t.spans[undo.after] = t.spans[undo.after], t.spans[undo.originalAfter]\n\t\t\t\tt.cursor.pos, t.undoStack[t.nextUndo].pos = undo.pos, t.cursor.pos\n\t\t\t\tt.length, t.undoStack[t.nextUndo].length = undo.length, t.length\n\t\t\t\tif !undo.continuation {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.cursor.row = -1\n\t\t\tt.truncateLines(0) // This is why Undo is expensive for large texts. (t.lineStarts can get largely unusable after an undo.)\n\t\t\tt.findCursor(true, 0)\n\t\t\tt.selectionStart = t.cursor\n\t\t\tif t.changed != nil {\n\t\t\t\tdefer t.changed()\n\t\t\t}\n\t\tcase tcell.KeyCtrlY: // Redo.\n\t\t\tif t.nextUndo >= len(t.undoStack) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tfor t.nextUndo < len(t.undoStack) {\n\t\t\t\tundo := t.undoStack[t.nextUndo]\n\t\t\t\tt.spans[undo.originalBefore], t.spans[undo.before] = t.spans[undo.before], t.spans[undo.originalBefore]\n\t\t\t\tt.spans[undo.originalAfter], t.spans[undo.after] = t.spans[undo.after], t.spans[undo.originalAfter]\n\t\t\t\tt.cursor.pos, t.undoStack[t.nextUndo].pos = undo.pos, t.cursor.pos\n\t\t\t\tt.length, t.undoStack[t.nextUndo].length = undo.length, t.length\n\t\t\t\tt.nextUndo++\n\t\t\t\tif t.nextUndo < len(t.undoStack) && !t.undoStack[t.nextUndo].continuation {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tt.cursor.row = -1\n\t\t\tt.truncateLines(0) // This is why Redo is expensive for large texts. (t.lineStarts can get largely unusable after an undo.)\n\t\t\tt.findCursor(true, 0)\n\t\t\tt.selectionStart = t.cursor\n\t\t\tif t.changed != nil {\n\t\t\t\tdefer t.changed()\n\t\t\t}\n\t\t}\n\t})\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (t *TextArea) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn t.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tif t.disabled {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tx, y := event.Position()\n\t\trectX, rectY, _, _ := t.GetInnerRect()\n\t\tif !t.InRect(x, y) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\t// Trigger a \"moved\" event at the end if requested.\n\t\tif t.moved != nil {\n\t\t\tselectionStart, cursor := t.selectionStart, t.cursor\n\t\t\tdefer func() {\n\t\t\t\tif selectionStart != t.selectionStart || cursor != t.cursor {\n\t\t\t\t\tt.moved()\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\t// Turn mouse coordinates into text coordinates.\n\t\tlabelWidth := t.labelWidth\n\t\tif labelWidth == 0 && t.label != \"\" {\n\t\t\tlabelWidth = TaggedStringWidth(t.label)\n\t\t}\n\t\tcolumn := x - rectX - labelWidth\n\t\trow := y - rectY\n\t\tif !t.wrap {\n\t\t\tcolumn += t.columnOffset\n\t\t}\n\t\trow += t.rowOffset\n\n\t\t// Process mouse actions.\n\t\tswitch action {\n\t\tcase MouseLeftDown:\n\t\t\tt.moveCursor(row, column)\n\t\t\tif event.Modifiers()&tcell.ModShift == 0 {\n\t\t\t\tt.selectionStart = t.cursor\n\t\t\t}\n\t\t\tsetFocus(t)\n\t\t\tconsumed = true\n\t\t\tcapture = t\n\t\t\tt.dragging = true\n\t\tcase MouseMove:\n\t\t\tif !t.dragging {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tt.moveCursor(row, column)\n\t\t\tconsumed = true\n\t\tcase MouseLeftUp:\n\t\t\tt.moveCursor(row, column)\n\t\t\tconsumed = true\n\t\t\tcapture = nil\n\t\t\tt.dragging = false\n\t\tcase MouseLeftDoubleClick: // Select word.\n\t\t\t// Left down/up was already triggered so we are at the correct\n\t\t\t// position.\n\t\t\tt.moveWordLeft(false)\n\t\t\tt.selectionStart = t.cursor\n\t\t\tt.moveWordRight(true, false)\n\t\t\tconsumed = true\n\t\tcase MouseScrollUp:\n\t\t\tif t.rowOffset > 0 {\n\t\t\t\tt.rowOffset--\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollDown:\n\t\t\tt.rowOffset++\n\t\t\tif t.rowOffset >= len(t.lineStarts) {\n\t\t\t\tt.rowOffset = len(t.lineStarts) - 1\n\t\t\t\tif t.rowOffset < 0 {\n\t\t\t\t\tt.rowOffset = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollLeft:\n\t\t\tif t.columnOffset > 0 {\n\t\t\t\tt.columnOffset--\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollRight:\n\t\t\tt.columnOffset++\n\t\t\tif t.columnOffset >= t.widestLine {\n\t\t\t\tt.columnOffset = t.widestLine - 1\n\t\t\t\tif t.columnOffset < 0 {\n\t\t\t\t\tt.columnOffset = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n\n// PasteHandler returns the handler for this primitive.\nfunc (t *TextArea) PasteHandler() func(pastedText string, setFocus func(p Primitive)) {\n\treturn t.WrapPasteHandler(func(pastedText string, setFocus func(p Primitive)) {\n\t\tfrom, to, row := t.getSelection()\n\t\tt.cursor.pos = t.replace(from, to, pastedText, false)\n\t\tt.cursor.row = -1\n\t\tt.truncateLines(row - 1)\n\t\tt.findCursor(true, row)\n\t\tt.selectionStart = t.cursor\n\t})\n}\n"
        },
        {
          "name": "textview.go",
          "type": "blob",
          "size": 41.5341796875,
          "content": "package tview\n\nimport (\n\t\"math\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gdamore/tcell/v2\"\n\tcolorful \"github.com/lucasb-eyer/go-colorful\"\n)\n\n// TabSize is the number of spaces with which a tab character will be replaced.\nvar TabSize = 4\n\n// textViewLine contains information about a line displayed in the text view.\ntype textViewLine struct {\n\toffset  int               // The string position in the buffer where this line starts.\n\twidth   int               // The screen width of this line.\n\tlength  int               // The string length (in bytes) of this line.\n\tstate   *stepState        // The parser state at the beginning of the line, before parsing the first character.\n\tregions map[string][2]int // The start and end columns of all regions in this line. Only valid for visible lines. May be nil.\n}\n\n// TextViewWriter is a writer that can be used to write to and clear a TextView\n// in batches, i.e. multiple writes with the lock only being acquired once. Don't\n// instantiated this class directly but use the TextView's BatchWriter method\n// instead.\ntype TextViewWriter struct {\n\tt *TextView\n}\n\n// Close implements io.Closer for the writer by unlocking the original TextView.\nfunc (w TextViewWriter) Close() error {\n\tw.t.Unlock()\n\treturn nil\n}\n\n// Clear removes all text from the buffer.\nfunc (w TextViewWriter) Clear() {\n\tw.t.clear()\n}\n\n// Write implements the io.Writer interface. It behaves like the TextView's\n// Write() method except that it does not acquire the lock.\nfunc (w TextViewWriter) Write(p []byte) (n int, err error) {\n\treturn w.t.write(p)\n}\n\n// HasFocus returns whether the underlying TextView has focus.\nfunc (w TextViewWriter) HasFocus() bool {\n\treturn w.t.hasFocus\n}\n\n// TextView is a component to display read-only text. While the text to be\n// displayed can be changed or appended to, there is no functionality that\n// allows the user to edit it. For that, [TextArea] should be used.\n//\n// TextView implements the io.Writer interface so you can stream text to it,\n// appending to the existing text. This does not trigger a redraw automatically\n// but if a handler is installed via [TextView.SetChangedFunc], you can cause it\n// to be redrawn. (See [TextView.SetChangedFunc] for more details.)\n//\n// Tab characters advance the text to the next tab stop at every [TabSize]\n// screen columns, but only if the text is left-aligned. If the text is centered\n// or right-aligned, tab characters are simply replaced with [TabSize] spaces.\n//\n// Word wrapping is enabled by default. Use [TextView.SetWrap] and\n// [TextView.SetWordWrap] to change this.\n//\n// # Navigation\n//\n// If the text view is set to be scrollable (which is the default), text is kept\n// in a buffer which may be larger than the screen and can be navigated\n// with Vim-like key binds:\n//\n//   - h, left arrow: Move left.\n//   - l, right arrow: Move right.\n//   - j, down arrow: Move down.\n//   - k, up arrow: Move up.\n//   - g, home: Move to the top.\n//   - G, end: Move to the bottom.\n//   - Ctrl-F, page down: Move down by one page.\n//   - Ctrl-B, page up: Move up by one page.\n//\n// If the text is not scrollable, any text above the top visible line is\n// discarded. This can be useful when you want to continuously stream text to\n// the text view and only keep the latest lines.\n//\n// Use [Box.SetInputCapture] to override or modify keyboard input.\n//\n// # Styles / Colors\n//\n// If dynamic colors are enabled via [TextView.SetDynamicColors], text style can\n// be changed dynamically by embedding color strings in square brackets. This\n// works the same way as anywhere else. See the package documentation for more\n// information.\n//\n// # Regions and Highlights\n//\n// If regions are enabled via [TextView.SetRegions], you can define text regions\n// within the text and assign region IDs to them. Text regions start with region\n// tags. Region tags are square brackets that contain a region ID in double\n// quotes, for example:\n//\n//\tWe define a [\"rg\"]region[\"\"] here.\n//\n// A text region ends with the next region tag. Tags with no region ID ([\"\"])\n// don't start new regions. They can therefore be used to mark the end of a\n// region. Region IDs must satisfy the following regular expression:\n//\n//\t[a-zA-Z0-9_,;: \\-\\.]+\n//\n// Regions can be highlighted by calling the [TextView.Highlight] function with\n// one or more region IDs. This can be used to display search results, for\n// example.\n//\n// The [TextView.ScrollToHighlight] function can be used to jump to the\n// currently highlighted region once when the text view is drawn the next time.\n//\n// # Large Texts\n//\n// The text view can handle reasonably large texts. It will parse the text as\n// needed. For optimal performance, it is best to access or display parts of the\n// text very far down only if really needed. For example, call\n// [TextView.ScrollToBeginning] before adding the text to the text view, to\n// avoid scrolling the text all the way to the bottom, forcing a full-text\n// parse.\n//\n// For even larger texts or \"infinite\" streams of text such as log files, you\n// should consider using [TextView.SetMaxLines] to limit the number of lines in\n// the text view buffer. Or disable the text view's scrollability altogether\n// (using [TextView.SetScrollable]). This will cause the text view to discard\n// lines moving out of the visible area at the top.\n//\n// See https://github.com/rivo/tview/wiki/TextView for an example.\ntype TextView struct {\n\tsync.Mutex\n\t*Box\n\n\t// The size of the text area. If set to 0, the text view will use the entire\n\t// available space.\n\twidth, height int\n\n\t// The text buffer.\n\ttext strings.Builder\n\n\t// The line index. It is valid at any time but may not contain trailing\n\t// lines which are not visible.\n\tlineIndex []*textViewLine\n\n\t// The screen width of the longest line in the index.\n\tlongestLine int\n\n\t// Regions mapped by their ID to the line where they start. Regions which\n\t// cannot be found in [TextView.lineIndex] are not contained.\n\tregions map[string]int\n\n\t// The label text shown, usually when part of a form.\n\tlabel string\n\n\t// The width of the text area's label.\n\tlabelWidth int\n\n\t// The label style.\n\tlabelStyle tcell.Style\n\n\t// The text alignment, one of AlignLeft, AlignCenter, or AlignRight.\n\talign int\n\n\t// Currently highlighted regions.\n\thighlights map[string]struct{}\n\n\t// The last width for which the current text view was drawn.\n\tlastWidth int\n\n\t// The height of the content the last time the text view was drawn.\n\tpageSize int\n\n\t// The index of the first line shown in the text view.\n\tlineOffset int\n\n\t// If set to true, the text view will always remain at the end of the\n\t// content when text is added.\n\ttrackEnd bool\n\n\t// The width of the characters to be skipped on each line (not used in wrap\n\t// mode).\n\tcolumnOffset int\n\n\t// The maximum number of lines kept in the line index, effectively the\n\t// latest word-wrapped lines. Ignored if 0.\n\tmaxLines int\n\n\t// If set to true, the text view will keep a buffer of text which can be\n\t// navigated when the text is longer than what fits into the box.\n\tscrollable bool\n\n\t// If set to true, lines that are longer than the available width are\n\t// wrapped onto the next line. If set to false, any characters beyond the\n\t// available width are discarded.\n\twrap bool\n\n\t// If set to true and if wrap is also true, Unicode line breaking is\n\t// applied.\n\twordWrap bool\n\n\t// The (starting) style of the text. This also defines the background color\n\t// of the main text element.\n\ttextStyle tcell.Style\n\n\t// Whether or not style tags are used.\n\tstyleTags bool\n\n\t// Whether or not region tags are used.\n\tregionTags bool\n\n\t// A temporary flag which, when true, will automatically bring the current\n\t// highlight(s) into the visible screen the next time the text view is\n\t// drawn.\n\tscrollToHighlights bool\n\n\t// If true, setting new highlights will be a XOR instead of an overwrite\n\t// operation.\n\ttoggleHighlights bool\n\n\t// An optional function which is called when the content of the text view\n\t// has changed.\n\tchanged func()\n\n\t// An optional function which is called when the user presses one of the\n\t// following keys: Escape, Enter, Tab, Backtab.\n\tdone func(tcell.Key)\n\n\t// An optional function which is called when one or more regions were\n\t// highlighted.\n\thighlighted func(added, removed, remaining []string)\n\n\t// A callback function set by the Form class and called when the user leaves\n\t// this form item.\n\tfinished func(tcell.Key)\n}\n\n// NewTextView returns a new text view.\nfunc NewTextView() *TextView {\n\treturn &TextView{\n\t\tBox:        NewBox(),\n\t\tlabelStyle: tcell.StyleDefault.Foreground(Styles.SecondaryTextColor),\n\t\thighlights: make(map[string]struct{}),\n\t\tlineOffset: -1,\n\t\tscrollable: true,\n\t\talign:      AlignLeft,\n\t\twrap:       true,\n\t\twordWrap:   true,\n\t\ttextStyle:  tcell.StyleDefault.Background(Styles.PrimitiveBackgroundColor).Foreground(Styles.PrimaryTextColor),\n\t\tregionTags: false,\n\t\tstyleTags:  false,\n\t}\n}\n\n// SetLabel sets the text to be displayed before the text view.\nfunc (t *TextView) SetLabel(label string) *TextView {\n\tt.label = label\n\treturn t\n}\n\n// GetLabel returns the text to be displayed before the text view.\nfunc (t *TextView) GetLabel() string {\n\treturn t.label\n}\n\n// SetLabelWidth sets the screen width of the label. A value of 0 will cause the\n// primitive to use the width of the label string.\nfunc (t *TextView) SetLabelWidth(width int) *TextView {\n\tt.labelWidth = width\n\treturn t\n}\n\n// SetSize sets the screen size of the main text element of the text view. This\n// element is always located next to the label which is always located in the\n// top left corner. If any of the values are 0 or larger than the available\n// space, the available space will be used.\nfunc (t *TextView) SetSize(rows, columns int) *TextView {\n\tt.width = columns\n\tt.height = rows\n\treturn t\n}\n\n// GetFieldWidth returns this primitive's field width.\nfunc (t *TextView) GetFieldWidth() int {\n\treturn t.width\n}\n\n// GetFieldHeight returns this primitive's field height.\nfunc (t *TextView) GetFieldHeight() int {\n\treturn t.height\n}\n\n// SetDisabled sets whether or not the item is disabled / read-only.\nfunc (t *TextView) SetDisabled(disabled bool) FormItem {\n\treturn t // Text views are always read-only.\n}\n\n// SetScrollable sets the flag that decides whether or not the text view is\n// scrollable. If false, text that moves above the text view's top row will be\n// permanently deleted.\nfunc (t *TextView) SetScrollable(scrollable bool) *TextView {\n\tt.scrollable = scrollable\n\tif !scrollable {\n\t\tt.trackEnd = true\n\t}\n\treturn t\n}\n\n// SetWrap sets the flag that, if true, leads to lines that are longer than the\n// available width being wrapped onto the next line. If false, any characters\n// beyond the available width are not displayed.\nfunc (t *TextView) SetWrap(wrap bool) *TextView {\n\tif t.wrap != wrap {\n\t\tt.resetIndex() // This invalidates the entire index.\n\t}\n\tt.wrap = wrap\n\treturn t\n}\n\n// SetWordWrap sets the flag that, if true and if the \"wrap\" flag is also true\n// (see [TextView.SetWrap]), wraps according to [Unicode Standard Annex #14].\n//\n// This flag is ignored if the \"wrap\" flag is false.\nfunc (t *TextView) SetWordWrap(wrapOnWords bool) *TextView {\n\tif t.wrap && t.wordWrap != wrapOnWords {\n\t\tt.resetIndex() // This invalidates the entire index.\n\t}\n\tt.wordWrap = wrapOnWords\n\treturn t\n}\n\n// SetMaxLines sets the maximum number of lines for this text view. Lines at the\n// beginning of the text will be discarded when the text view is drawn, so as to\n// remain below this value. Only lines above the first visible line are removed.\n//\n// Broken-over lines via word/character wrapping are counted individually.\n//\n// Note that [TextView.GetText] will return the shortened text.\n//\n// A value of 0 (the default) will keep all lines in place.\nfunc (t *TextView) SetMaxLines(maxLines int) *TextView {\n\tt.maxLines = maxLines\n\treturn t\n}\n\n// SetTextAlign sets the text alignment within the text view. This must be\n// either AlignLeft, AlignCenter, or AlignRight.\nfunc (t *TextView) SetTextAlign(align int) *TextView {\n\tt.align = align\n\treturn t\n}\n\n// SetTextColor sets the initial color of the text.\nfunc (t *TextView) SetTextColor(color tcell.Color) *TextView {\n\tt.textStyle = t.textStyle.Foreground(color)\n\tt.resetIndex()\n\treturn t\n}\n\n// SetBackgroundColor overrides its implementation in Box to set the background\n// color of this primitive. For backwards compatibility reasons, it also sets\n// the background color of the main text element.\nfunc (t *TextView) SetBackgroundColor(color tcell.Color) *Box {\n\tt.Box.SetBackgroundColor(color)\n\tt.textStyle = t.textStyle.Background(color)\n\tt.resetIndex()\n\treturn t.Box\n}\n\n// SetTextStyle sets the initial style of the text. This style's background\n// color also determines the background color of the main text element.\nfunc (t *TextView) SetTextStyle(style tcell.Style) *TextView {\n\tt.textStyle = style\n\tt.resetIndex()\n\treturn t\n}\n\n// SetText sets the text of this text view to the provided string. Previously\n// contained text will be removed. As with writing to the text view io.Writer\n// interface directly, this does not trigger an automatic redraw but it will\n// trigger the \"changed\" callback if one is set.\nfunc (t *TextView) SetText(text string) *TextView {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.text.Reset()\n\tt.text.WriteString(text)\n\tt.resetIndex()\n\tif t.changed != nil {\n\t\tgo t.changed()\n\t}\n\treturn t\n}\n\n// GetText returns the current text of this text view. If \"stripAllTags\" is set\n// to true, any region/style tags are stripped from the text. Note that any text\n// that has been discarded due to [TextView.SetMaxLines] or\n// [TextView.SetScrollable] will not be part of the returned text.\nfunc (t *TextView) GetText(stripAllTags bool) string {\n\tif !stripAllTags || (!t.styleTags && !t.regionTags) {\n\t\treturn t.text.String()\n\t}\n\n\tvar (\n\t\tstr   strings.Builder\n\t\tstate *stepState\n\t\ttext  = t.text.String()\n\t\topts  stepOptions\n\t\tch    string\n\t)\n\tif t.styleTags {\n\t\topts = stepOptionsStyle\n\t}\n\tif t.regionTags {\n\t\topts |= stepOptionsRegion\n\t}\n\tfor len(text) > 0 {\n\t\tch, text, state = step(text, state, opts)\n\t\tstr.WriteString(ch)\n\t}\n\treturn str.String()\n}\n\n// GetOriginalLineCount returns the number of lines in the original text buffer,\n// without applying any wrapping. This is an expensive call as it needs to\n// iterate over the entire text. Note that any text that has been discarded due\n// to [TextView.SetMaxLines] or [TextView.SetScrollable] will not be part of the\n// count.\nfunc (t *TextView) GetOriginalLineCount() int {\n\tif t.text.Len() == 0 {\n\t\treturn 0\n\t}\n\n\tvar (\n\t\tstate *stepState\n\t\tstr       = t.text.String()\n\t\tlines int = 1\n\t)\n\tfor len(str) > 0 {\n\t\t_, str, state = step(str, state, stepOptionsNone)\n\t\tif lineBreak, optional := state.LineBreak(); lineBreak && !optional {\n\t\t\tlines++\n\t\t}\n\t}\n\n\treturn lines\n}\n\n// GetWrappedLineCount returns the number of lines in the text view, taking\n// wrapping into account (if activated). This is an even more expensive call\n// than [TextView.GetOriginalLineCount] as it needs to parse the text until the\n// end and calculate the line breaks. It will also allocate memory for each\n// line. Note that any text that has been discarded due to\n// [TextView.SetMaxLines] or [TextView.SetScrollable] will not be part of the\n// count. Calling this method before the text view was drawn for the first time\n// will assume no wrapping.\nfunc (t *TextView) GetWrappedLineCount() int {\n\tt.parseAhead(t.width, func(int, *textViewLine) bool {\n\t\treturn false\n\t})\n\treturn len(t.lineIndex)\n}\n\n// SetDynamicColors sets the flag that allows the text color to be changed\n// dynamically with style tags. See class description for details.\nfunc (t *TextView) SetDynamicColors(dynamic bool) *TextView {\n\tif t.styleTags != dynamic {\n\t\tt.resetIndex() // This invalidates the entire index.\n\t}\n\tt.styleTags = dynamic\n\treturn t\n}\n\n// SetRegions sets the flag that allows to define regions in the text. See class\n// description for details.\nfunc (t *TextView) SetRegions(regions bool) *TextView {\n\tif t.regionTags != regions {\n\t\tt.resetIndex() // This invalidates the entire index.\n\t}\n\tt.regionTags = regions\n\treturn t\n}\n\n// SetChangedFunc sets a handler function which is called when the text of the\n// text view has changed. This is useful when text is written to this\n// [io.Writer] in a separate goroutine. Doing so does not automatically cause\n// the screen to be refreshed so you may want to use the \"changed\" handler to\n// redraw the screen.\n//\n// Note that to avoid race conditions or deadlocks, there are a few rules you\n// should follow:\n//\n//   - You can call [Application.Draw] from this handler.\n//   - You can call [TextView.HasFocus] from this handler.\n//   - During the execution of this handler, access to any other variables from\n//     this primitive or any other primitive must be queued using\n//     [Application.QueueUpdate].\n//\n// See package description for details on dealing with concurrency.\nfunc (t *TextView) SetChangedFunc(handler func()) *TextView {\n\tt.changed = handler\n\treturn t\n}\n\n// SetDoneFunc sets a handler which is called when the user presses on the\n// following keys: Escape, Enter, Tab, Backtab. The key is passed to the\n// handler.\nfunc (t *TextView) SetDoneFunc(handler func(key tcell.Key)) *TextView {\n\tt.done = handler\n\treturn t\n}\n\n// SetHighlightedFunc sets a handler which is called when the list of currently\n// highlighted regions change. It receives a list of region IDs which were newly\n// highlighted, those that are not highlighted anymore, and those that remain\n// highlighted.\n//\n// Note that because regions are only determined when drawing the text view,\n// this function can only fire for regions that have existed when the text view\n// was last drawn.\nfunc (t *TextView) SetHighlightedFunc(handler func(added, removed, remaining []string)) *TextView {\n\tt.highlighted = handler\n\treturn t\n}\n\n// SetFinishedFunc sets a callback invoked when the user leaves this form item.\nfunc (t *TextView) SetFinishedFunc(handler func(key tcell.Key)) FormItem {\n\tt.finished = handler\n\treturn t\n}\n\n// SetFormAttributes sets attributes shared by all form items.\nfunc (t *TextView) SetFormAttributes(labelWidth int, labelColor, bgColor, fieldTextColor, fieldBgColor tcell.Color) FormItem {\n\tt.labelWidth = labelWidth\n\tt.backgroundColor = bgColor\n\tt.labelStyle = t.labelStyle.Foreground(labelColor)\n\t// We ignore the field background color because this is a read-only element.\n\tt.textStyle = tcell.StyleDefault.Foreground(fieldTextColor).Background(bgColor)\n\treturn t\n}\n\n// ScrollTo scrolls to the specified row and column (both starting with 0).\nfunc (t *TextView) ScrollTo(row, column int) *TextView {\n\tif !t.scrollable {\n\t\treturn t\n\t}\n\tt.lineOffset = row\n\tt.columnOffset = column\n\tt.trackEnd = false\n\treturn t\n}\n\n// ScrollToBeginning scrolls to the top left corner of the text if the text view\n// is scrollable.\nfunc (t *TextView) ScrollToBeginning() *TextView {\n\tif !t.scrollable {\n\t\treturn t\n\t}\n\tt.trackEnd = false\n\tt.lineOffset = 0\n\tt.columnOffset = 0\n\treturn t\n}\n\n// ScrollToEnd scrolls to the bottom left corner of the text if the text view\n// is scrollable. Adding new rows to the end of the text view will cause it to\n// scroll with the new data.\nfunc (t *TextView) ScrollToEnd() *TextView {\n\tif !t.scrollable {\n\t\treturn t\n\t}\n\tt.trackEnd = true\n\tt.columnOffset = 0\n\treturn t\n}\n\n// GetScrollOffset returns the number of rows and columns that are skipped at\n// the top left corner when the text view has been scrolled.\nfunc (t *TextView) GetScrollOffset() (row, column int) {\n\treturn t.lineOffset, t.columnOffset\n}\n\n// Clear removes all text from the buffer. This triggers the \"changed\" callback.\nfunc (t *TextView) Clear() *TextView {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.clear()\n\tif t.changed != nil {\n\t\tgo t.changed()\n\t}\n\treturn t\n}\n\n// clear is the internal implementation of clear. It is used by TextViewWriter\n// and anywhere that we need to perform a write without locking the buffer.\nfunc (t *TextView) clear() {\n\tt.text.Reset()\n\tt.resetIndex()\n}\n\n// Highlight specifies which regions should be highlighted. If highlight\n// toggling is set to true (see [TextView.SetToggleHighlights]), the highlight\n// of the provided regions is toggled (i.e. highlighted regions are\n// un-highlighted and vice versa). If toggling is set to false, the provided\n// regions are highlighted and all other regions will not be highlighted (you\n// may also provide nil to turn off all highlights).\n//\n// For more information on regions, see class description. Empty region strings\n// or regions not contained in the text are ignored.\n//\n// Text in highlighted regions will be drawn inverted, i.e. with their\n// background and foreground colors swapped.\n//\n// If toggling is set to false, clicking outside of any region will remove all\n// highlights.\n//\n// This function is expensive if a specified region is in a part of the text\n// that has not yet been parsed.\nfunc (t *TextView) Highlight(regionIDs ...string) *TextView {\n\t// Make sure we know these regions.\n\tt.parseAhead(t.lastWidth, func(lineNumber int, line *textViewLine) bool {\n\t\tfor _, regionID := range regionIDs {\n\t\t\tif _, ok := t.regions[regionID]; !ok {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n\n\t// Remove unknown regions.\n\tnewRegions := make([]string, 0, len(regionIDs))\n\tfor _, regionID := range regionIDs {\n\t\tif _, ok := t.regions[regionID]; ok {\n\t\t\tnewRegions = append(newRegions, regionID)\n\t\t}\n\t}\n\tregionIDs = newRegions\n\n\t// Toggle highlights.\n\tif t.toggleHighlights {\n\t\tvar newIDs []string\n\tHighlightLoop:\n\t\tfor regionID := range t.highlights {\n\t\t\tfor _, id := range regionIDs {\n\t\t\t\tif regionID == id {\n\t\t\t\t\tcontinue HighlightLoop\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewIDs = append(newIDs, regionID)\n\t\t}\n\t\tfor _, regionID := range regionIDs {\n\t\t\tif _, ok := t.highlights[regionID]; !ok {\n\t\t\t\tnewIDs = append(newIDs, regionID)\n\t\t\t}\n\t\t}\n\t\tregionIDs = newIDs\n\t} // Now we have a list of region IDs that end up being highlighted.\n\n\t// Determine added and removed regions.\n\tvar added, removed, remaining []string\n\tif t.highlighted != nil {\n\t\tfor _, regionID := range regionIDs {\n\t\t\tif _, ok := t.highlights[regionID]; ok {\n\t\t\t\tremaining = append(remaining, regionID)\n\t\t\t\tdelete(t.highlights, regionID)\n\t\t\t} else {\n\t\t\t\tadded = append(added, regionID)\n\t\t\t}\n\t\t}\n\t\tfor regionID := range t.highlights {\n\t\t\tremoved = append(removed, regionID)\n\t\t}\n\t}\n\n\t// Make new selection.\n\tt.highlights = make(map[string]struct{})\n\tfor _, id := range regionIDs {\n\t\tif id == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tt.highlights[id] = struct{}{}\n\t}\n\n\t// Notify.\n\tif t.highlighted != nil && (len(added) > 0 || len(removed) > 0) {\n\t\tt.highlighted(added, removed, remaining)\n\t}\n\n\treturn t\n}\n\n// GetHighlights returns the IDs of all currently highlighted regions.\nfunc (t *TextView) GetHighlights() (regionIDs []string) {\n\tfor id := range t.highlights {\n\t\tregionIDs = append(regionIDs, id)\n\t}\n\treturn\n}\n\n// SetToggleHighlights sets a flag to determine how regions are highlighted.\n// When set to true, the [TextView.Highlight] function (or a mouse click) will\n// toggle the provided/selected regions. When set to false, [TextView.Highlight]\n// (or a mouse click) will simply highlight the provided regions.\nfunc (t *TextView) SetToggleHighlights(toggle bool) *TextView {\n\tt.toggleHighlights = toggle\n\treturn t\n}\n\n// ScrollToHighlight will cause the visible area to be scrolled so that the\n// highlighted regions appear in the visible area of the text view. This\n// repositioning happens the next time the text view is drawn. It happens only\n// once so you will need to call this function repeatedly to always keep\n// highlighted regions in view.\n//\n// Nothing happens if there are no highlighted regions or if the text view is\n// not scrollable.\nfunc (t *TextView) ScrollToHighlight() *TextView {\n\tif len(t.highlights) == 0 || !t.scrollable || !t.regionTags {\n\t\treturn t\n\t}\n\tt.scrollToHighlights = true\n\tt.trackEnd = false\n\treturn t\n}\n\n// GetRegionText returns the text of the first region with the given ID. If\n// dynamic colors are enabled, style tags are stripped from the text.\n//\n// If the region does not exist or if regions are turned off, an empty string\n// is returned.\n//\n// This function can be expensive if the specified region is way beyond the\n// visible area of the text view as the text needs to be parsed until the region\n// can be found, or if the region does not contain any text.\nfunc (t *TextView) GetRegionText(regionID string) string {\n\tif !t.regionTags || regionID == \"\" {\n\t\treturn \"\"\n\t}\n\n\t// Parse until we find the region.\n\tlineNumber, ok := t.regions[regionID]\n\tif !ok {\n\t\tlineNumber = -1\n\t\tt.parseAhead(t.lastWidth, func(number int, line *textViewLine) bool {\n\t\t\tlineNumber, ok = t.regions[regionID]\n\t\t\treturn ok\n\t\t})\n\t\tif lineNumber < 0 {\n\t\t\treturn \"\" // We couldn't find this region.\n\t\t}\n\t}\n\n\t// Extract text from region.\n\tvar (\n\t\tline       = t.lineIndex[lineNumber]\n\t\ttext       = t.text.String()[line.offset:]\n\t\tst         = *line.state\n\t\tstate      = &st\n\t\toptions    = stepOptionsRegion\n\t\tregionText strings.Builder\n\t)\n\tif t.styleTags {\n\t\toptions |= stepOptionsStyle\n\t}\n\tfor len(text) > 0 {\n\t\tvar ch string\n\t\tch, text, state = step(text, state, options)\n\t\tif state.region == regionID {\n\t\t\tregionText.WriteString(ch)\n\t\t} else if regionText.Len() > 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn regionText.String()\n}\n\n// Focus is called when this primitive receives focus.\nfunc (t *TextView) Focus(delegate func(p Primitive)) {\n\t// Implemented here with locking because this is used by layout primitives.\n\tt.Lock()\n\tdefer t.Unlock()\n\n\t// But if we're part of a form and not scrollable, there's nothing the user\n\t// can do here so we're finished.\n\tif t.finished != nil && !t.scrollable {\n\t\tt.finished(-1)\n\t\treturn\n\t}\n\n\tt.Box.Focus(delegate)\n}\n\n// HasFocus returns whether or not this primitive has focus.\nfunc (t *TextView) HasFocus() bool {\n\t// Implemented here with locking because this may be used in the \"changed\"\n\t// callback.\n\tt.Lock()\n\tdefer t.Unlock()\n\treturn t.Box.HasFocus()\n}\n\n// Write lets us implement the io.Writer interface.\nfunc (t *TextView) Write(p []byte) (n int, err error) {\n\tt.Lock()\n\tdefer t.Unlock()\n\n\treturn t.write(p)\n}\n\n// write is the internal implementation of Write. It is used by [TextViewWriter]\n// and anywhere that we need to perform a write without locking the buffer.\nfunc (t *TextView) write(p []byte) (n int, err error) {\n\t// Notify at the end.\n\tchanged := t.changed\n\tif changed != nil {\n\t\tdefer func() {\n\t\t\t// We always call the \"changed\" function in a separate goroutine to avoid\n\t\t\t// deadlocks.\n\t\t\tgo changed()\n\t\t}()\n\t}\n\n\treturn t.text.Write(p)\n}\n\n// BatchWriter returns a new writer that can be used to write into the buffer\n// but without Locking/Unlocking the buffer on every write, as [TextView.Write]\n// and [TextView.Clear] do. The lock will be acquired once when BatchWriter is\n// called, and will be released when the returned writer is closed. Example:\n//\n//\ttv := tview.NewTextView()\n//\tw := tv.BatchWriter()\n//\tdefer w.Close()\n//\tw.Clear()\n//\tfmt.Fprintln(w, \"To sit in solemn silence\")\n//\tfmt.Fprintln(w, \"on a dull, dark, dock\")\n//\tfmt.Println(tv.GetText(false))\n//\n// Note that using the batch writer requires you to manage any issues that may\n// arise from concurrency yourself. See package description for details on\n// dealing with concurrency.\nfunc (t *TextView) BatchWriter() TextViewWriter {\n\tt.Lock()\n\treturn TextViewWriter{\n\t\tt: t,\n\t}\n}\n\n// resetIndex resets all indexed data, including the line index.\nfunc (t *TextView) resetIndex() {\n\tt.lineIndex = nil\n\tt.regions = make(map[string]int)\n\tt.longestLine = 0\n}\n\n// parseAhead parses the text buffer starting at the last line in\n// [TextView.lineIndex] until either the end of the buffer or until stop returns\n// true for the last complete line that was parsed. If wrapping is enabled,\n// width will be used as the available screen width. If width is 0, it is\n// assumed that there is no wrapping. This can happen when this function is\n// called before the first time [TextView.Draw] is called.\n//\n// There is no guarantee that stop will ever be called.\n//\n// The function adds entries to the [TextView.lineIndex] slice and the\n// [TextView.regions] map and adjusts [TextView.longestLine].\nfunc (t *TextView) parseAhead(width int, stop func(lineNumber int, line *textViewLine) bool) {\n\tif t.text.Len() == 0 {\n\t\treturn // No text. Nothing to parse.\n\t}\n\n\t// If width is 0, make it infinite.\n\tif width == 0 {\n\t\twidth = math.MaxInt\n\t}\n\n\t// What kind of tags do we scan for?\n\tvar options stepOptions\n\tif t.styleTags {\n\t\toptions |= stepOptionsStyle\n\t}\n\tif t.regionTags {\n\t\toptions |= stepOptionsRegion\n\t}\n\n\t// Start parsing at the last line in the index.\n\tvar lastLine *textViewLine\n\tstr := t.text.String()\n\tif len(t.lineIndex) == 0 {\n\t\t// Insert the first line.\n\t\tlastLine = &textViewLine{\n\t\t\tstate: &stepState{\n\t\t\t\tunisegState: -1,\n\t\t\t\tstyle:       t.textStyle,\n\t\t\t},\n\t\t}\n\t\tt.lineIndex = append(t.lineIndex, lastLine)\n\t} else {\n\t\t// Reset the last line.\n\t\tlastLine = t.lineIndex[len(t.lineIndex)-1]\n\t\tlastLine.width = 0\n\t\tlastLine.length = 0\n\t\tstr = str[lastLine.offset:]\n\t}\n\n\t// Parse.\n\tvar (\n\t\tlastOption      int               // Text index of the last optional split point.\n\t\tlastOptionWidth int               // Line width at last optional split point.\n\t\tlastOptionState *stepState        // State at last optional split point.\n\t\tleftPos         int               // The current position in the line (only for left-alignment).\n\t\toffset          = lastLine.offset // Text index of the current position.\n\t\tst              = *lastLine.state // Current state.\n\t\tstate           = &st             // Pointer to current state.\n\t)\n\tfor len(str) > 0 {\n\t\tvar c string\n\t\tregion := state.region\n\t\tc, str, state = step(str, state, options)\n\t\tw := state.Width()\n\t\tif c == \"\\t\" {\n\t\t\tif t.align == AlignLeft {\n\t\t\t\tw = TabSize - leftPos%TabSize\n\t\t\t} else {\n\t\t\t\tw = TabSize\n\t\t\t}\n\t\t}\n\t\tlength := state.GrossLength()\n\n\t\t// Would it exceed the line width?\n\t\tif t.wrap && lastLine.width+w > width {\n\t\t\tif lastOptionWidth == 0 {\n\t\t\t\t// No split point so far. Just split at the current position.\n\t\t\t\tif stop(len(t.lineIndex)-1, lastLine) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tst := *state\n\t\t\t\tlastLine = &textViewLine{\n\t\t\t\t\toffset: offset,\n\t\t\t\t\tstate:  &st,\n\t\t\t\t}\n\t\t\t\tlastOption, lastOptionWidth, leftPos = 0, 0, 0\n\t\t\t} else {\n\t\t\t\t// Split at the last split point.\n\t\t\t\tnewLine := &textViewLine{\n\t\t\t\t\toffset: lastLine.offset + lastOption,\n\t\t\t\t\twidth:  lastLine.width - lastOptionWidth,\n\t\t\t\t\tlength: lastLine.length - lastOption,\n\t\t\t\t\tstate:  lastOptionState,\n\t\t\t\t}\n\t\t\t\tlastLine.width = lastOptionWidth\n\t\t\t\tlastLine.length = lastOption\n\t\t\t\tif stop(len(t.lineIndex)-1, lastLine) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlastLine = newLine\n\t\t\t\tlastOption, lastOptionWidth = 0, 0\n\t\t\t\tleftPos -= lastOptionWidth\n\t\t\t}\n\t\t\tt.lineIndex = append(t.lineIndex, lastLine)\n\t\t}\n\n\t\t// Move ahead.\n\t\tlastLine.width += w\n\t\tlastLine.length += length\n\t\toffset += length\n\t\tleftPos += w\n\n\t\t// Do we have a new longest line?\n\t\tif lastLine.width > t.longestLine {\n\t\t\tt.longestLine = lastLine.width\n\t\t}\n\n\t\t// Check for split points.\n\t\tif lineBreak, optional := state.LineBreak(); lineBreak {\n\t\t\tif optional {\n\t\t\t\tif t.wrap && t.wordWrap {\n\t\t\t\t\t// Remember this split point.\n\t\t\t\t\tlastOption = offset - lastLine.offset\n\t\t\t\t\tlastOptionWidth = lastLine.width\n\t\t\t\t\tst := *state\n\t\t\t\t\tlastOptionState = &st\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We must split here.\n\t\t\t\tif stop(len(t.lineIndex)-1, lastLine) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tst := *state\n\t\t\t\tlastLine = &textViewLine{\n\t\t\t\t\toffset: offset,\n\t\t\t\t\tstate:  &st,\n\t\t\t\t}\n\t\t\t\tt.lineIndex = append(t.lineIndex, lastLine)\n\t\t\t\tlastOption, lastOptionWidth, leftPos = 0, 0, 0\n\t\t\t}\n\t\t}\n\n\t\t// Add new regions if any.\n\t\tif t.regionTags && state.region != \"\" && state.region != region {\n\t\t\tif _, ok := t.regions[state.region]; !ok {\n\t\t\t\tt.regions[state.region] = len(t.lineIndex) - 1\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Draw draws this primitive onto the screen.\nfunc (t *TextView) Draw(screen tcell.Screen) {\n\tt.Box.DrawForSubclass(screen, t)\n\tt.Lock()\n\tdefer t.Unlock()\n\n\t// Get the available size.\n\tx, y, width, height := t.GetInnerRect()\n\tt.pageSize = height\n\n\t// Draw label.\n\t_, labelBg, _ := t.labelStyle.Decompose()\n\tif t.labelWidth > 0 {\n\t\tlabelWidth := t.labelWidth\n\t\tif labelWidth > width {\n\t\t\tlabelWidth = width\n\t\t}\n\t\tprintWithStyle(screen, t.label, x, y, 0, labelWidth, AlignLeft, t.labelStyle, labelBg == tcell.ColorDefault)\n\t\tx += labelWidth\n\t\twidth -= labelWidth\n\t} else {\n\t\t_, _, drawnWidth := printWithStyle(screen, t.label, x, y, 0, width, AlignLeft, t.labelStyle, labelBg == tcell.ColorDefault)\n\t\tx += drawnWidth\n\t\twidth -= drawnWidth\n\t}\n\n\t// What's the space for the text element?\n\tif t.width > 0 && t.width < width {\n\t\twidth = t.width\n\t}\n\tif t.height > 0 && t.height < height {\n\t\theight = t.height\n\t}\n\tif width <= 0 {\n\t\treturn // No space left for the text area.\n\t}\n\n\t// Draw the text element if necessary.\n\t_, bg, _ := t.textStyle.Decompose()\n\tif bg != t.backgroundColor {\n\t\tfor row := 0; row < height; row++ {\n\t\t\tfor column := 0; column < width; column++ {\n\t\t\t\tscreen.SetContent(x+column, y+row, ' ', nil, t.textStyle)\n\t\t\t}\n\t\t}\n\t}\n\n\t// If the width has changed, we need to reindex.\n\tif width != t.lastWidth && t.wrap {\n\t\tt.resetIndex()\n\t}\n\tt.lastWidth = width\n\n\t// What are our parse options?\n\tvar options stepOptions\n\tif t.styleTags {\n\t\toptions |= stepOptionsStyle\n\t}\n\tif t.regionTags {\n\t\toptions |= stepOptionsRegion\n\t}\n\n\t// Scroll to highlighted regions.\n\tif t.regionTags && t.scrollToHighlights {\n\t\t// Make sure we know all highlighted regions.\n\t\tt.parseAhead(width, func(lineNumber int, line *textViewLine) bool {\n\t\t\tfor regionID := range t.highlights {\n\t\t\t\tif _, ok := t.regions[regionID]; !ok {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tt.highlights[regionID] = struct{}{}\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t\t// What is the line range for all highlighted regions?\n\t\tvar (\n\t\t\tfirstRegion                string\n\t\t\tfromHighlight, toHighlight int\n\t\t)\n\t\tfor regionID := range t.highlights {\n\t\t\t// We can safely assume that the region is known.\n\t\t\tline := t.regions[regionID]\n\t\t\tif firstRegion == \"\" || line > toHighlight {\n\t\t\t\ttoHighlight = line\n\t\t\t}\n\t\t\tif firstRegion == \"\" || line < fromHighlight {\n\t\t\t\tfromHighlight = line\n\t\t\t\tfirstRegion = regionID\n\t\t\t}\n\t\t}\n\t\tif firstRegion != \"\" {\n\t\t\t// Do we fit the entire height?\n\t\t\tif toHighlight-fromHighlight+1 < height {\n\t\t\t\t// Yes, let's center the highlights.\n\t\t\t\tt.lineOffset = (fromHighlight + toHighlight - height) / 2\n\t\t\t} else {\n\t\t\t\t// No, let's move to the start of the highlights.\n\t\t\t\tt.lineOffset = fromHighlight\n\t\t\t}\n\n\t\t\t// If the highlight is too far to the right, move it to the middle.\n\t\t\tif t.wrap {\n\t\t\t\t// Find the first highlight's column in screen space.\n\t\t\t\tline := t.lineIndex[fromHighlight]\n\t\t\t\tst := *line.state\n\t\t\t\tstate := &st\n\t\t\t\tstr := t.text.String()[line.offset:]\n\t\t\t\tvar posHighlight int\n\t\t\t\tfor len(str) > 0 && posHighlight < line.width && state.region != firstRegion {\n\t\t\t\t\t_, str, state = step(str, state, options)\n\t\t\t\t\tposHighlight += state.Width()\n\t\t\t\t}\n\n\t\t\t\tif posHighlight-t.columnOffset > 3*width/4 {\n\t\t\t\t\tt.columnOffset = posHighlight - width/2\n\t\t\t\t}\n\n\t\t\t\t// If the highlight is off-screen on the left, move it on-screen.\n\t\t\t\tif posHighlight-t.columnOffset < 0 {\n\t\t\t\t\tt.columnOffset = posHighlight - width/4\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tt.scrollToHighlights = false\n\n\t// Make sure our index has enough lines.\n\tt.parseAhead(width, func(lineNumber int, line *textViewLine) bool {\n\t\treturn lineNumber >= t.lineOffset+height\n\t})\n\n\t// Adjust line offset.\n\tif t.trackEnd {\n\t\tt.parseAhead(width, func(lineNumber int, line *textViewLine) bool {\n\t\t\treturn false\n\t\t})\n\t\tt.lineOffset = len(t.lineIndex) - height\n\t}\n\tif t.lineOffset > len(t.lineIndex)-height {\n\t\tt.lineOffset = len(t.lineIndex) - height\n\t}\n\tif t.lineOffset < 0 {\n\t\tt.lineOffset = 0\n\t}\n\n\t// Adjust column offset.\n\tif t.align == AlignLeft || t.align == AlignRight {\n\t\tif t.columnOffset+width > t.longestLine {\n\t\t\tt.columnOffset = t.longestLine - width\n\t\t}\n\t\tif t.columnOffset < 0 {\n\t\t\tt.columnOffset = 0\n\t\t}\n\t} else { // AlignCenter.\n\t\thalf := (t.longestLine - width) / 2\n\t\tif half > 0 {\n\t\t\tif t.columnOffset > half {\n\t\t\t\tt.columnOffset = half\n\t\t\t}\n\t\t\tif t.columnOffset < -half {\n\t\t\t\tt.columnOffset = -half\n\t\t\t}\n\t\t} else {\n\t\t\tt.columnOffset = 0\n\t\t}\n\t}\n\n\t// Draw visible lines.\n\tfor line := t.lineOffset; line < len(t.lineIndex); line++ {\n\t\t// Are we done?\n\t\tif line-t.lineOffset >= height {\n\t\t\tbreak\n\t\t}\n\n\t\tinfo := t.lineIndex[line]\n\t\tinfo.regions = nil\n\n\t\t// Determine starting point of the text and the screen.\n\t\tvar skipWidth, xPos int\n\t\tswitch t.align {\n\t\tcase AlignLeft:\n\t\t\tskipWidth = t.columnOffset\n\t\tcase AlignCenter:\n\t\t\tskipWidth = t.columnOffset + (info.width-width)/2\n\t\t\tif skipWidth < 0 {\n\t\t\t\tskipWidth = 0\n\t\t\t\txPos = (width-info.width)/2 - t.columnOffset\n\t\t\t}\n\t\tcase AlignRight:\n\t\t\tmaxWidth := width\n\t\t\tif t.longestLine > width {\n\t\t\t\tmaxWidth = t.longestLine\n\t\t\t}\n\t\t\tskipWidth = t.columnOffset - (maxWidth - info.width)\n\t\t\tif skipWidth < 0 {\n\t\t\t\tskipWidth = 0\n\t\t\t\txPos = maxWidth - info.width - t.columnOffset\n\t\t\t}\n\t\t}\n\n\t\t// Draw the line text.\n\t\tstr := t.text.String()[info.offset:]\n\t\tst := *info.state\n\t\tstate := &st\n\t\tvar processed int\n\t\tfor len(str) > 0 && xPos < width && processed < info.length {\n\t\t\tvar ch string\n\t\t\tch, str, state = step(str, state, options)\n\t\t\tw := state.Width()\n\t\t\tif ch == \"\\t\" {\n\t\t\t\tif t.align == AlignLeft {\n\t\t\t\t\tw = TabSize - xPos%TabSize\n\t\t\t\t} else {\n\t\t\t\t\tw = TabSize\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessed += state.GrossLength()\n\n\t\t\t// Don't draw anything while we skip characters.\n\t\t\tif skipWidth > 0 {\n\t\t\t\tskipWidth -= w\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Draw this character.\n\t\t\tif w > 0 {\n\t\t\t\tstyle := state.Style()\n\n\t\t\t\t// Do we highlight this character?\n\t\t\t\tvar highlighted bool\n\t\t\t\tif state.region != \"\" {\n\t\t\t\t\tif _, ok := t.highlights[state.region]; ok {\n\t\t\t\t\t\thighlighted = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif highlighted {\n\t\t\t\t\tfg, bg, _ := style.Decompose()\n\t\t\t\t\tif bg == t.backgroundColor {\n\t\t\t\t\t\tr, g, b := fg.RGB()\n\t\t\t\t\t\tc := colorful.Color{R: float64(r) / 255, G: float64(g) / 255, B: float64(b) / 255}\n\t\t\t\t\t\t_, _, li := c.Hcl()\n\t\t\t\t\t\tif li < .5 {\n\t\t\t\t\t\t\tbg = tcell.ColorWhite\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbg = tcell.ColorBlack\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstyle = style.Background(fg).Foreground(bg)\n\t\t\t\t}\n\n\t\t\t\t// Paint on screen.\n\t\t\t\tfor offset := w - 1; offset >= 0; offset-- {\n\t\t\t\t\trunes := []rune(ch)\n\t\t\t\t\tif offset == 0 {\n\t\t\t\t\t\tscreen.SetContent(x+xPos+offset, y+line-t.lineOffset, runes[0], runes[1:], style)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tscreen.SetContent(x+xPos+offset, y+line-t.lineOffset, ' ', nil, style)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Register this region.\n\t\t\t\tif state.region != \"\" {\n\t\t\t\t\tif info.regions == nil {\n\t\t\t\t\t\tinfo.regions = make(map[string][2]int)\n\t\t\t\t\t}\n\t\t\t\t\tfromTo, ok := info.regions[state.region]\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tfromTo = [2]int{xPos, xPos + w}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif xPos < fromTo[0] {\n\t\t\t\t\t\t\tfromTo[0] = xPos\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif xPos+w > fromTo[1] {\n\t\t\t\t\t\t\tfromTo[1] = xPos + w\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tinfo.regions[state.region] = fromTo\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txPos += w\n\t\t}\n\t}\n\n\t// If this view is not scrollable, we'll purge the buffer of lines that have\n\t// scrolled out of view.\n\tvar purgeStart int\n\tif !t.scrollable && t.lineOffset > 0 {\n\t\tpurgeStart = t.lineOffset\n\t}\n\n\t// If we reached the maximum number of lines, we'll purge the buffer of the\n\t// oldest lines.\n\tif t.maxLines > 0 && len(t.lineIndex) > t.maxLines {\n\t\tpurgeStart = len(t.lineIndex) - t.maxLines\n\t}\n\n\t// Purge.\n\tif purgeStart > 0 && purgeStart < len(t.lineIndex) {\n\t\tnewText := t.text.String()[t.lineIndex[purgeStart].offset:]\n\t\tt.text.Reset()\n\t\tt.text.WriteString(newText)\n\t\tt.resetIndex()\n\t\tt.lineOffset = 0\n\t}\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (t *TextView) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn t.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tkey := event.Key()\n\n\t\tif key == tcell.KeyEscape || key == tcell.KeyEnter || key == tcell.KeyTab || key == tcell.KeyBacktab {\n\t\t\tif t.done != nil {\n\t\t\t\tt.done(key)\n\t\t\t}\n\t\t\tif t.finished != nil {\n\t\t\t\tt.finished(key)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif !t.scrollable {\n\t\t\treturn\n\t\t}\n\n\t\tswitch key {\n\t\tcase tcell.KeyRune:\n\t\t\tswitch event.Rune() {\n\t\t\tcase 'g': // Home.\n\t\t\t\tt.trackEnd = false\n\t\t\t\tt.lineOffset = 0\n\t\t\t\tt.columnOffset = 0\n\t\t\tcase 'G': // End.\n\t\t\t\tt.trackEnd = true\n\t\t\t\tt.columnOffset = 0\n\t\t\tcase 'j': // Down.\n\t\t\t\tt.lineOffset++\n\t\t\tcase 'k': // Up.\n\t\t\t\tt.trackEnd = false\n\t\t\t\tt.lineOffset--\n\t\t\tcase 'h': // Left.\n\t\t\t\tt.columnOffset--\n\t\t\tcase 'l': // Right.\n\t\t\t\tt.columnOffset++\n\t\t\t}\n\t\tcase tcell.KeyHome:\n\t\t\tt.trackEnd = false\n\t\t\tt.lineOffset = 0\n\t\t\tt.columnOffset = 0\n\t\tcase tcell.KeyEnd:\n\t\t\tt.trackEnd = true\n\t\t\tt.columnOffset = 0\n\t\tcase tcell.KeyUp:\n\t\t\tt.trackEnd = false\n\t\t\tt.lineOffset--\n\t\tcase tcell.KeyDown:\n\t\t\tt.lineOffset++\n\t\tcase tcell.KeyLeft:\n\t\t\tt.columnOffset--\n\t\tcase tcell.KeyRight:\n\t\t\tt.columnOffset++\n\t\tcase tcell.KeyPgDn, tcell.KeyCtrlF:\n\t\t\tt.lineOffset += t.pageSize\n\t\tcase tcell.KeyPgUp, tcell.KeyCtrlB:\n\t\t\tt.trackEnd = false\n\t\t\tt.lineOffset -= t.pageSize\n\t\t}\n\t})\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (t *TextView) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn t.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tx, y := event.Position()\n\t\tif !t.InRect(x, y) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\trectX, rectY, width, height := t.GetInnerRect()\n\t\tswitch action {\n\t\tcase MouseLeftDown:\n\t\t\tsetFocus(t)\n\t\t\tconsumed = true\n\t\tcase MouseLeftClick:\n\t\t\tif t.regionTags && t.InInnerRect(x, y) {\n\t\t\t\t// Find a region to highlight.\n\t\t\t\tx -= rectX\n\t\t\t\ty -= rectY\n\t\t\t\tvar highlightedID string\n\t\t\t\tif y+t.lineOffset < len(t.lineIndex) {\n\t\t\t\t\tline := t.lineIndex[y+t.lineOffset]\n\t\t\t\t\tfor regionID, fromTo := range line.regions {\n\t\t\t\t\t\tif x >= fromTo[0] && x < fromTo[1] {\n\t\t\t\t\t\t\thighlightedID = regionID\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif highlightedID != \"\" {\n\t\t\t\t\tt.Highlight(highlightedID)\n\t\t\t\t} else if !t.toggleHighlights {\n\t\t\t\t\tt.Highlight()\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollUp:\n\t\t\tif !t.scrollable {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tt.trackEnd = false\n\t\t\tt.lineOffset--\n\t\t\tconsumed = true\n\t\tcase MouseScrollDown:\n\t\t\tif !t.scrollable {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tt.lineOffset++\n\t\t\tif len(t.lineIndex)-t.lineOffset < height {\n\t\t\t\t// If we scroll to the end, turn on tracking.\n\t\t\t\tt.parseAhead(width, func(lineNumber int, line *textViewLine) bool {\n\t\t\t\t\treturn len(t.lineIndex)-t.lineOffset < height\n\t\t\t\t})\n\t\t\t\tif len(t.lineIndex)-t.lineOffset < height {\n\t\t\t\t\tt.trackEnd = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n"
        },
        {
          "name": "treeview.go",
          "type": "blob",
          "size": 25.4609375,
          "content": "package tview\n\nimport (\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Tree navigation events.\nconst (\n\ttreeNone int = iota\n\ttreeHome\n\ttreeEnd\n\ttreeMove\n\ttreeParent\n\ttreeChild\n\ttreeScroll // Move without changing the selection, even when off screen.\n)\n\n// TreeNode represents one node in a tree view.\ntype TreeNode struct {\n\t// The reference object.\n\treference interface{}\n\n\t// This node's child nodes.\n\tchildren []*TreeNode\n\n\t// The item's text.\n\ttext string\n\n\t// The text style.\n\ttextStyle tcell.Style\n\n\t// The style of selected text.\n\tselectedTextStyle tcell.Style\n\n\t// Whether or not this node can be selected.\n\tselectable bool\n\n\t// Whether or not this node's children should be displayed.\n\texpanded bool\n\n\t// The additional horizontal indent of this node's text.\n\tindent int\n\n\t// An optional function which is called when the user selects this node.\n\tselected func()\n\n\t// The hierarchy level (0 for the root, 1 for its children, and so on). This\n\t// is only up to date immediately after a call to process() (e.g. via\n\t// Draw()).\n\tlevel int\n\n\t// Temporary member variables.\n\tparent    *TreeNode // The parent node (nil for the root).\n\tgraphicsX int       // The x-coordinate of the left-most graphics rune.\n\ttextX     int       // The x-coordinate of the first rune of the text.\n}\n\n// NewTreeNode returns a new tree node.\nfunc NewTreeNode(text string) *TreeNode {\n\treturn &TreeNode{\n\t\ttext:              text,\n\t\ttextStyle:         tcell.StyleDefault.Foreground(Styles.PrimaryTextColor).Background(Styles.PrimitiveBackgroundColor),\n\t\tselectedTextStyle: tcell.StyleDefault.Foreground(Styles.PrimitiveBackgroundColor).Background(Styles.PrimaryTextColor),\n\t\tindent:            2,\n\t\texpanded:          true,\n\t\tselectable:        true,\n\t}\n}\n\n// Walk traverses this node's subtree in depth-first, pre-order (NLR) order and\n// calls the provided callback function on each traversed node (which includes\n// this node) with the traversed node and its parent node (nil for this node).\n// The callback returns whether traversal should continue with the traversed\n// node's child nodes (true) or not recurse any deeper (false).\nfunc (n *TreeNode) Walk(callback func(node, parent *TreeNode) bool) *TreeNode {\n\tn.parent = nil\n\tnodes := []*TreeNode{n}\n\tfor len(nodes) > 0 {\n\t\t// Pop the top node and process it.\n\t\tnode := nodes[len(nodes)-1]\n\t\tnodes = nodes[:len(nodes)-1]\n\t\tif !callback(node, node.parent) {\n\t\t\t// Don't add any children.\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add children in reverse order.\n\t\tfor index := len(node.children) - 1; index >= 0; index-- {\n\t\t\tnode.children[index].parent = node\n\t\t\tnodes = append(nodes, node.children[index])\n\t\t}\n\t}\n\n\treturn n\n}\n\n// SetReference allows you to store a reference of any type in this node. This\n// will allow you to establish a mapping between the TreeView hierarchy and your\n// internal tree structure.\nfunc (n *TreeNode) SetReference(reference interface{}) *TreeNode {\n\tn.reference = reference\n\treturn n\n}\n\n// GetReference returns this node's reference object.\nfunc (n *TreeNode) GetReference() interface{} {\n\treturn n.reference\n}\n\n// SetChildren sets this node's child nodes.\nfunc (n *TreeNode) SetChildren(childNodes []*TreeNode) *TreeNode {\n\tn.children = childNodes\n\treturn n\n}\n\n// GetText returns this node's text.\nfunc (n *TreeNode) GetText() string {\n\treturn n.text\n}\n\n// GetChildren returns this node's children.\nfunc (n *TreeNode) GetChildren() []*TreeNode {\n\treturn n.children\n}\n\n// ClearChildren removes all child nodes from this node.\nfunc (n *TreeNode) ClearChildren() *TreeNode {\n\tn.children = nil\n\treturn n\n}\n\n// AddChild adds a new child node to this node.\nfunc (n *TreeNode) AddChild(node *TreeNode) *TreeNode {\n\tn.children = append(n.children, node)\n\treturn n\n}\n\n// RemoveChild removes a child node from this node. If the child node cannot be\n// found, nothing happens.\nfunc (n *TreeNode) RemoveChild(node *TreeNode) *TreeNode {\n\tfor index, child := range n.children {\n\t\tif child == node {\n\t\t\tn.children = append(n.children[:index], n.children[index+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn n\n}\n\n// SetSelectable sets a flag indicating whether this node can be selected by\n// the user.\nfunc (n *TreeNode) SetSelectable(selectable bool) *TreeNode {\n\tn.selectable = selectable\n\treturn n\n}\n\n// SetSelectedFunc sets a function which is called when the user selects this\n// node by hitting Enter when it is selected.\nfunc (n *TreeNode) SetSelectedFunc(handler func()) *TreeNode {\n\tn.selected = handler\n\treturn n\n}\n\n// SetExpanded sets whether or not this node's child nodes should be displayed.\nfunc (n *TreeNode) SetExpanded(expanded bool) *TreeNode {\n\tn.expanded = expanded\n\treturn n\n}\n\n// Expand makes the child nodes of this node appear.\nfunc (n *TreeNode) Expand() *TreeNode {\n\tn.expanded = true\n\treturn n\n}\n\n// Collapse makes the child nodes of this node disappear.\nfunc (n *TreeNode) Collapse() *TreeNode {\n\tn.expanded = false\n\treturn n\n}\n\n// ExpandAll expands this node and all descendent nodes.\nfunc (n *TreeNode) ExpandAll() *TreeNode {\n\tn.Walk(func(node, parent *TreeNode) bool {\n\t\tnode.expanded = true\n\t\treturn true\n\t})\n\treturn n\n}\n\n// CollapseAll collapses this node and all descendent nodes.\nfunc (n *TreeNode) CollapseAll() *TreeNode {\n\tn.Walk(func(node, parent *TreeNode) bool {\n\t\tnode.expanded = false\n\t\treturn true\n\t})\n\treturn n\n}\n\n// IsExpanded returns whether the child nodes of this node are visible.\nfunc (n *TreeNode) IsExpanded() bool {\n\treturn n.expanded\n}\n\n// SetText sets the node's text which is displayed.\nfunc (n *TreeNode) SetText(text string) *TreeNode {\n\tn.text = text\n\treturn n\n}\n\n// GetColor returns the node's text color.\nfunc (n *TreeNode) GetColor() tcell.Color {\n\tcolor, _, _ := n.textStyle.Decompose()\n\treturn color\n}\n\n// SetColor sets the node's text color. For compatibility reasons, this also\n// sets the background color of the selected text style. For more control over\n// styles, use [TreeNode.SetTextStyle] and [TreeNode.SetSelectedTextStyle].\nfunc (n *TreeNode) SetColor(color tcell.Color) *TreeNode {\n\tn.textStyle = n.textStyle.Foreground(color)\n\tn.selectedTextStyle = n.selectedTextStyle.Background(color)\n\treturn n\n}\n\n// SetTextStyle sets the text style for this node.\nfunc (n *TreeNode) SetTextStyle(style tcell.Style) *TreeNode {\n\tn.textStyle = style\n\treturn n\n}\n\n// GetTextStyle returns the text style for this node.\nfunc (n *TreeNode) GetTextStyle() tcell.Style {\n\treturn n.textStyle\n}\n\n// SetSelectedTextStyle sets the text style for this node when it is selected.\nfunc (n *TreeNode) SetSelectedTextStyle(style tcell.Style) *TreeNode {\n\tn.selectedTextStyle = style\n\treturn n\n}\n\n// GetSelectedTextStyle returns the text style for this node when it is\n// selected.\nfunc (n *TreeNode) GetSelectedTextStyle() tcell.Style {\n\treturn n.selectedTextStyle\n}\n\n// SetIndent sets an additional indentation for this node's text. A value of 0\n// keeps the text as far left as possible with a minimum of line graphics. Any\n// value greater than that moves the text to the right.\nfunc (n *TreeNode) SetIndent(indent int) *TreeNode {\n\tn.indent = indent\n\treturn n\n}\n\n// GetLevel returns the node's level within the hierarchy, where 0 corresponds\n// to the root node, 1 corresponds to its children, and so on. This is only\n// guaranteed to be up to date immediately after the tree that contains this\n// node is drawn.\nfunc (n *TreeNode) GetLevel() int {\n\treturn n.level\n}\n\n// TreeView displays tree structures. A tree consists of nodes (TreeNode\n// objects) where each node has zero or more child nodes and exactly one parent\n// node (except for the root node which has no parent node).\n//\n// The SetRoot() function is used to specify the root of the tree. Other nodes\n// are added locally to the root node or any of its descendents. See the\n// TreeNode documentation for details on node attributes. (You can use\n// SetReference() to store a reference to nodes of your own tree structure.)\n//\n// Nodes can be selected by calling SetCurrentNode(). The user can navigate the\n// selection or the tree by using the following keys:\n//\n//   - j, down arrow, right arrow: Move (the selection) down by one node.\n//   - k, up arrow, left arrow: Move (the selection) up by one node.\n//   - g, home: Move (the selection) to the top.\n//   - G, end: Move (the selection) to the bottom.\n//   - J: Move (the selection) up one level (if that node is selectable).\n//   - K: Move (the selection) to the last node one level down (if any).\n//   - Ctrl-F, page down: Move (the selection) down by one page.\n//   - Ctrl-B, page up: Move (the selection) up by one page.\n//\n// Selected nodes can trigger the \"selected\" callback when the user hits Enter.\n//\n// The root node corresponds to level 0, its children correspond to level 1,\n// their children to level 2, and so on. Per default, the first level that is\n// displayed is 0, i.e. the root node. You can call SetTopLevel() to hide\n// levels.\n//\n// If graphics are turned on (see SetGraphics()), lines indicate the tree's\n// hierarchy. Alternative (or additionally), you can set different prefixes\n// using SetPrefixes() for different levels, for example to display hierarchical\n// bullet point lists.\n//\n// See https://github.com/rivo/tview/wiki/TreeView for an example.\ntype TreeView struct {\n\t*Box\n\n\t// The root node.\n\troot *TreeNode\n\n\t// The currently selected node or nil if no node is selected.\n\tcurrentNode *TreeNode\n\n\t// The last note that was selected or nil of there is no such node.\n\tlastNode *TreeNode\n\n\t// The movement to be performed during the call to Draw(), one of the\n\t// constants defined above.\n\tmovement int\n\n\t// The number of nodes to move down or up, when movement is treeMove,\n\t// excluding non-selectable nodes for selection movement, including them for\n\t// scrolling.\n\tstep int\n\n\t// The top hierarchical level shown. (0 corresponds to the root level.)\n\ttopLevel int\n\n\t// Strings drawn before the nodes, based on their level.\n\tprefixes []string\n\n\t// Vertical scroll offset.\n\toffsetY int\n\n\t// If set to true, all node texts will be aligned horizontally.\n\talign bool\n\n\t// If set to true, the tree structure is drawn using lines.\n\tgraphics bool\n\n\t// The color of the lines.\n\tgraphicsColor tcell.Color\n\n\t// An optional function which is called when the user has navigated to a new\n\t// tree node.\n\tchanged func(node *TreeNode)\n\n\t// An optional function which is called when a tree item was selected.\n\tselected func(node *TreeNode)\n\n\t// An optional function which is called when the user moves away from this\n\t// primitive.\n\tdone func(key tcell.Key)\n\n\t// The visible nodes, top-down, as set by process().\n\tnodes []*TreeNode\n\n\t// Temporarily set to true while we know that the tree has not changed and\n\t// therefore does not need to be reprocessed.\n\tstableNodes bool\n}\n\n// NewTreeView returns a new tree view.\nfunc NewTreeView() *TreeView {\n\treturn &TreeView{\n\t\tBox:           NewBox(),\n\t\tgraphics:      true,\n\t\tgraphicsColor: Styles.GraphicsColor,\n\t}\n}\n\n// SetRoot sets the root node of the tree.\nfunc (t *TreeView) SetRoot(root *TreeNode) *TreeView {\n\tt.root = root\n\treturn t\n}\n\n// GetRoot returns the root node of the tree. If no such node was previously\n// set, nil is returned.\nfunc (t *TreeView) GetRoot() *TreeNode {\n\treturn t.root\n}\n\n// SetCurrentNode sets the currently selected node. Provide nil to clear all\n// selections. Selected nodes must be visible and selectable, or else the\n// selection will be changed to the top-most selectable and visible node.\n//\n// This function does NOT trigger the \"changed\" callback because the actual node\n// that will be selected is not known until the tree is drawn. Triggering the\n// \"changed\" callback is thus deferred until the next call to [TreeView.Draw].\nfunc (t *TreeView) SetCurrentNode(node *TreeNode) *TreeView {\n\tt.currentNode = node\n\treturn t\n}\n\n// GetCurrentNode returns the currently selected node or nil of no node is\n// currently selected.\nfunc (t *TreeView) GetCurrentNode() *TreeNode {\n\treturn t.currentNode\n}\n\n// GetPath returns all nodes located on the path from the root to the given\n// node, including the root and the node itself. If there is no root node, nil\n// is returned. If there are multiple paths to the node, a random one is chosen\n// and returned.\nfunc (t *TreeView) GetPath(node *TreeNode) []*TreeNode {\n\tif t.root == nil {\n\t\treturn nil\n\t}\n\n\tvar f func(current *TreeNode, path []*TreeNode) []*TreeNode\n\tf = func(current *TreeNode, path []*TreeNode) []*TreeNode {\n\t\tif current == node {\n\t\t\treturn path\n\t\t}\n\n\t\tfor _, child := range current.children {\n\t\t\tnewPath := make([]*TreeNode, len(path), len(path)+1)\n\t\t\tcopy(newPath, path)\n\t\t\tif p := f(child, append(newPath, child)); p != nil {\n\t\t\t\treturn p\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n\n\treturn f(t.root, []*TreeNode{t.root})\n}\n\n// SetTopLevel sets the first tree level that is visible with 0 referring to the\n// root, 1 to the root's child nodes, and so on. Nodes above the top level are\n// not displayed.\nfunc (t *TreeView) SetTopLevel(topLevel int) *TreeView {\n\tt.topLevel = topLevel\n\treturn t\n}\n\n// SetPrefixes defines the strings drawn before the nodes' texts. This is a\n// slice of strings where each element corresponds to a node's hierarchy level,\n// i.e. 0 for the root, 1 for the root's children, and so on (levels will\n// cycle).\n//\n// For example, to display a hierarchical list with bullet points:\n//\n//\ttreeView.SetGraphics(false).\n//\t  SetPrefixes([]string{\"* \", \"- \", \"x \"})\n//\n// Deeper levels will cycle through the prefixes.\nfunc (t *TreeView) SetPrefixes(prefixes []string) *TreeView {\n\tt.prefixes = prefixes\n\treturn t\n}\n\n// SetAlign controls the horizontal alignment of the node texts. If set to true,\n// all texts except that of top-level nodes will be placed in the same column.\n// If set to false, they will indent with the hierarchy.\nfunc (t *TreeView) SetAlign(align bool) *TreeView {\n\tt.align = align\n\treturn t\n}\n\n// SetGraphics sets a flag which determines whether or not line graphics are\n// drawn to illustrate the tree's hierarchy.\nfunc (t *TreeView) SetGraphics(showGraphics bool) *TreeView {\n\tt.graphics = showGraphics\n\treturn t\n}\n\n// SetGraphicsColor sets the colors of the lines used to draw the tree structure.\nfunc (t *TreeView) SetGraphicsColor(color tcell.Color) *TreeView {\n\tt.graphicsColor = color\n\treturn t\n}\n\n// SetChangedFunc sets the function which is called when the currently selected\n// node changes, for example when the user navigates to a new tree node.\nfunc (t *TreeView) SetChangedFunc(handler func(node *TreeNode)) *TreeView {\n\tt.changed = handler\n\treturn t\n}\n\n// SetSelectedFunc sets the function which is called when the user selects a\n// node by pressing Enter on the current selection.\nfunc (t *TreeView) SetSelectedFunc(handler func(node *TreeNode)) *TreeView {\n\tt.selected = handler\n\treturn t\n}\n\n// GetSelectedFunc returns the function set with [TreeView.SetSelectedFunc]\n// or nil if no such function has been set.\nfunc (t *TreeView) GetSelectedFunc() func(node *TreeNode) {\n\treturn t.selected\n}\n\n// SetDoneFunc sets a handler which is called whenever the user presses the\n// Escape, Tab, or Backtab key.\nfunc (t *TreeView) SetDoneFunc(handler func(key tcell.Key)) *TreeView {\n\tt.done = handler\n\treturn t\n}\n\n// GetScrollOffset returns the number of node rows that were skipped at the top\n// of the tree view. Note that when the user navigates the tree view, this value\n// is only updated after the tree view has been redrawn.\nfunc (t *TreeView) GetScrollOffset() int {\n\treturn t.offsetY\n}\n\n// GetRowCount returns the number of \"visible\" nodes. This includes nodes which\n// fall outside the tree view's box but notably does not include the children\n// of collapsed nodes. Note that this value is only up to date after the tree\n// view has been drawn.\nfunc (t *TreeView) GetRowCount() int {\n\treturn len(t.nodes)\n}\n\n// Move moves the selection (if a node is currently selected) or scrolls the\n// tree view (if there is no selection), by the given offset (positive values to\n// move/scroll down, negative values to move/scroll up). For selection changes,\n// the offset refers to the number selectable, visible nodes. For scrolling, the\n// offset refers to the number of visible nodes.\n//\n// If the offset is 0, nothing happens.\nfunc (t *TreeView) Move(offset int) *TreeView {\n\tif offset == 0 {\n\t\treturn t\n\t}\n\tt.movement = treeMove\n\tt.step = offset\n\tt.process(false)\n\treturn t\n}\n\n// process builds the visible tree, populates the \"nodes\" slice, and processes\n// pending movement actions. Set \"drawingAfter\" to true if you know that\n// [TreeView.Draw] will be called immediately after this function (to avoid\n// having [TreeView.Draw] call it again).\nfunc (t *TreeView) process(drawingAfter bool) {\n\tt.stableNodes = drawingAfter\n\t_, _, _, height := t.GetInnerRect()\n\n\t// Determine visible nodes and their placement.\n\tt.nodes = nil\n\tif t.root == nil {\n\t\treturn\n\t}\n\tparentSelectedIndex, selectedIndex, topLevelGraphicsX := -1, -1, -1\n\tvar graphicsOffset, maxTextX int\n\tif t.graphics {\n\t\tgraphicsOffset = 1\n\t}\n\tt.root.Walk(func(node, parent *TreeNode) bool {\n\t\t// Set node attributes.\n\t\tnode.parent = parent\n\t\tif parent == nil {\n\t\t\tnode.level = 0\n\t\t\tnode.graphicsX = 0\n\t\t\tnode.textX = 0\n\t\t} else {\n\t\t\tnode.level = parent.level + 1\n\t\t\tnode.graphicsX = parent.textX\n\t\t\tnode.textX = node.graphicsX + graphicsOffset + node.indent\n\t\t}\n\t\tif !t.graphics && t.align {\n\t\t\t// Without graphics, we align nodes on the first column.\n\t\t\tnode.textX = 0\n\t\t}\n\t\tif node.level == t.topLevel {\n\t\t\t// No graphics for top level nodes.\n\t\t\tnode.graphicsX = 0\n\t\t\tnode.textX = 0\n\t\t}\n\n\t\t// Add the node to the list.\n\t\tif node.level >= t.topLevel {\n\t\t\t// This node will be visible.\n\t\t\tif node.textX > maxTextX {\n\t\t\t\tmaxTextX = node.textX\n\t\t\t}\n\t\t\tif node == t.currentNode && node.selectable {\n\t\t\t\tselectedIndex = len(t.nodes)\n\n\t\t\t\t// Also find parent node.\n\t\t\t\tfor index := len(t.nodes) - 1; index >= 0; index-- {\n\t\t\t\t\tif t.nodes[index] == parent && t.nodes[index].selectable {\n\t\t\t\t\t\tparentSelectedIndex = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Maybe we want to skip this level.\n\t\t\tif t.topLevel == node.level && (topLevelGraphicsX < 0 || node.graphicsX < topLevelGraphicsX) {\n\t\t\t\ttopLevelGraphicsX = node.graphicsX\n\t\t\t}\n\n\t\t\tt.nodes = append(t.nodes, node)\n\t\t}\n\n\t\t// Recurse if desired.\n\t\treturn node.expanded\n\t})\n\n\t// Post-process positions.\n\tfor _, node := range t.nodes {\n\t\t// If text must align, we correct the positions.\n\t\tif t.align && node.level > t.topLevel {\n\t\t\tnode.textX = maxTextX\n\t\t}\n\n\t\t// If we skipped levels, shift to the left.\n\t\tif topLevelGraphicsX > 0 {\n\t\t\tnode.graphicsX -= topLevelGraphicsX\n\t\t\tnode.textX -= topLevelGraphicsX\n\t\t}\n\t}\n\n\t// Process selection. (Also trigger events if necessary.)\n\tif selectedIndex >= 0 {\n\t\t// Move the selection.\n\t\tswitch t.movement {\n\t\tcase treeMove:\n\t\t\tfor t.step < 0 { // Going up.\n\t\t\t\tindex := selectedIndex\n\t\t\t\tfor index > 0 {\n\t\t\t\t\tindex--\n\t\t\t\t\tif t.nodes[index].selectable {\n\t\t\t\t\t\tselectedIndex = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.step++\n\t\t\t}\n\t\t\tfor t.step > 0 { // Going down.\n\t\t\t\tindex := selectedIndex\n\t\t\t\tfor index < len(t.nodes)-1 {\n\t\t\t\t\tindex++\n\t\t\t\t\tif t.nodes[index].selectable {\n\t\t\t\t\t\tselectedIndex = index\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.step--\n\t\t\t}\n\t\tcase treeParent:\n\t\t\tif parentSelectedIndex >= 0 {\n\t\t\t\tselectedIndex = parentSelectedIndex\n\t\t\t}\n\t\tcase treeChild:\n\t\t\tindex := selectedIndex\n\t\t\tfor index < len(t.nodes)-1 {\n\t\t\t\tindex++\n\t\t\t\tif t.nodes[index].selectable && t.nodes[index].parent == t.nodes[selectedIndex] {\n\t\t\t\t\tselectedIndex = index\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt.currentNode = t.nodes[selectedIndex]\n\n\t\t// Move selection into viewport.\n\t\tif t.movement != treeScroll {\n\t\t\tif selectedIndex-t.offsetY >= height {\n\t\t\t\tt.offsetY = selectedIndex - height + 1\n\t\t\t}\n\t\t\tif selectedIndex < t.offsetY {\n\t\t\t\tt.offsetY = selectedIndex\n\t\t\t}\n\t\t\tif t.movement != treeHome && t.movement != treeEnd {\n\t\t\t\t// treeScroll, treeHome, and treeEnd are handled by Draw().\n\t\t\t\tt.movement = treeNone\n\t\t\t\tt.step = 0\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// If selection is not visible or selectable, select the first candidate.\n\t\tif t.currentNode != nil {\n\t\t\tfor index, node := range t.nodes {\n\t\t\t\tif node.selectable {\n\t\t\t\t\tselectedIndex = index\n\t\t\t\t\tt.currentNode = node\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif selectedIndex < 0 {\n\t\t\tt.currentNode = nil\n\t\t}\n\t}\n\n\t// Trigger \"changed\" callback.\n\tif t.changed != nil && t.currentNode != nil && t.currentNode != t.lastNode {\n\t\tt.changed(t.currentNode)\n\t}\n\tt.lastNode = t.currentNode\n}\n\n// Draw draws this primitive onto the screen.\nfunc (t *TreeView) Draw(screen tcell.Screen) {\n\tt.Box.DrawForSubclass(screen, t)\n\tif t.root == nil {\n\t\treturn\n\t}\n\t_, totalHeight := screen.Size()\n\n\tif !t.stableNodes {\n\t\tt.process(false)\n\t} else {\n\t\tt.stableNodes = false\n\t}\n\n\t// Scroll the tree, t.movement is treeNone after process() when there is a\n\t// selection, except for treeScroll, treeHome, and treeEnd.\n\tx, y, width, height := t.GetInnerRect()\n\tswitch t.movement {\n\tcase treeMove, treeScroll:\n\t\tt.offsetY += t.step\n\tcase treeHome:\n\t\tt.offsetY = 0\n\tcase treeEnd:\n\t\tt.offsetY = len(t.nodes)\n\t}\n\tt.movement = treeNone\n\n\t// Fix invalid offsets.\n\tif t.offsetY >= len(t.nodes)-height {\n\t\tt.offsetY = len(t.nodes) - height\n\t}\n\tif t.offsetY < 0 {\n\t\tt.offsetY = 0\n\t}\n\n\t// Draw the tree.\n\tposY := y\n\tlineStyle := tcell.StyleDefault.Background(t.backgroundColor).Foreground(t.graphicsColor)\n\tfor index, node := range t.nodes {\n\t\t// Skip invisible parts.\n\t\tif posY >= y+height+1 || posY >= totalHeight {\n\t\t\tbreak\n\t\t}\n\t\tif index < t.offsetY {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Draw the graphics.\n\t\tif t.graphics {\n\t\t\t// Draw ancestor branches.\n\t\t\tancestor := node.parent\n\t\t\tfor ancestor != nil && ancestor.parent != nil && ancestor.parent.level >= t.topLevel {\n\t\t\t\tif ancestor.graphicsX >= width {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Draw a branch if this ancestor is not a last child.\n\t\t\t\tif ancestor.parent.children[len(ancestor.parent.children)-1] != ancestor {\n\t\t\t\t\tif posY-1 >= y && ancestor.textX > ancestor.graphicsX {\n\t\t\t\t\t\tPrintJoinedSemigraphics(screen, x+ancestor.graphicsX, posY-1, Borders.Vertical, lineStyle)\n\t\t\t\t\t}\n\t\t\t\t\tif posY < y+height {\n\t\t\t\t\t\tscreen.SetContent(x+ancestor.graphicsX, posY, Borders.Vertical, nil, lineStyle)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tancestor = ancestor.parent\n\t\t\t}\n\n\t\t\tif node.textX > node.graphicsX && node.graphicsX < width {\n\t\t\t\t// Connect to the node above.\n\t\t\t\tif posY-1 >= y && t.nodes[index-1].graphicsX <= node.graphicsX && t.nodes[index-1].textX > node.graphicsX {\n\t\t\t\t\tPrintJoinedSemigraphics(screen, x+node.graphicsX, posY-1, Borders.TopLeft, lineStyle)\n\t\t\t\t}\n\n\t\t\t\t// Join this node.\n\t\t\t\tif posY < y+height {\n\t\t\t\t\tscreen.SetContent(x+node.graphicsX, posY, Borders.BottomLeft, nil, lineStyle)\n\t\t\t\t\tfor pos := node.graphicsX + 1; pos < node.textX && pos < width; pos++ {\n\t\t\t\t\t\tscreen.SetContent(x+pos, posY, Borders.Horizontal, nil, lineStyle)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Draw the prefix and the text.\n\t\tif node.textX < width && posY < y+height {\n\t\t\t// Prefix.\n\t\t\tvar prefixWidth int\n\t\t\tif len(t.prefixes) > 0 {\n\t\t\t\t_, _, prefixWidth = printWithStyle(screen, t.prefixes[(node.level-t.topLevel)%len(t.prefixes)], x+node.textX, posY, 0, width-node.textX, AlignLeft, node.textStyle, true)\n\t\t\t}\n\n\t\t\t// Text.\n\t\t\tif node.textX+prefixWidth < width {\n\t\t\t\tstyle := node.textStyle\n\t\t\t\tif node == t.currentNode {\n\t\t\t\t\tstyle = node.selectedTextStyle\n\t\t\t\t}\n\t\t\t\tprintWithStyle(screen, node.text, x+node.textX+prefixWidth, posY, 0, width-node.textX-prefixWidth, AlignLeft, style, false)\n\t\t\t}\n\t\t}\n\n\t\t// Advance.\n\t\tposY++\n\t}\n}\n\n// InputHandler returns the handler for this primitive.\nfunc (t *TreeView) InputHandler() func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\treturn t.WrapInputHandler(func(event *tcell.EventKey, setFocus func(p Primitive)) {\n\t\tselectNode := func() {\n\t\t\tnode := t.currentNode\n\t\t\tif node != nil {\n\t\t\t\tif t.selected != nil {\n\t\t\t\t\tt.selected(node)\n\t\t\t\t}\n\t\t\t\tif node.selected != nil {\n\t\t\t\t\tnode.selected()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Because the tree is flattened into a list only at drawing time, we also\n\t\t// postpone the (selection) movement to drawing time.\n\t\tswitch key := event.Key(); key {\n\t\tcase tcell.KeyTab, tcell.KeyBacktab, tcell.KeyEscape:\n\t\t\tif t.done != nil {\n\t\t\t\tt.done(key)\n\t\t\t}\n\t\tcase tcell.KeyDown, tcell.KeyRight:\n\t\t\tt.movement = treeMove\n\t\t\tt.step = 1\n\t\tcase tcell.KeyUp, tcell.KeyLeft:\n\t\t\tt.movement = treeMove\n\t\t\tt.step = -1\n\t\tcase tcell.KeyHome:\n\t\t\tt.movement = treeHome\n\t\tcase tcell.KeyEnd:\n\t\t\tt.movement = treeEnd\n\t\tcase tcell.KeyPgDn, tcell.KeyCtrlF:\n\t\t\t_, _, _, height := t.GetInnerRect()\n\t\t\tt.movement = treeMove\n\t\t\tt.step = height\n\t\tcase tcell.KeyPgUp, tcell.KeyCtrlB:\n\t\t\t_, _, _, height := t.GetInnerRect()\n\t\t\tt.movement = treeMove\n\t\t\tt.step = -height\n\t\tcase tcell.KeyRune:\n\t\t\tswitch event.Rune() {\n\t\t\tcase 'g':\n\t\t\t\tt.movement = treeHome\n\t\t\tcase 'G':\n\t\t\t\tt.movement = treeEnd\n\t\t\tcase 'j':\n\t\t\t\tt.movement = treeMove\n\t\t\t\tt.step = 1\n\t\t\tcase 'J':\n\t\t\t\tt.movement = treeChild\n\t\t\tcase 'k':\n\t\t\t\tt.movement = treeMove\n\t\t\t\tt.step = -1\n\t\t\tcase 'K':\n\t\t\t\tt.movement = treeParent\n\t\t\tcase ' ':\n\t\t\t\tselectNode()\n\t\t\t}\n\t\tcase tcell.KeyEnter:\n\t\t\tselectNode()\n\t\t}\n\n\t\tt.process(true)\n\t})\n}\n\n// MouseHandler returns the mouse handler for this primitive.\nfunc (t *TreeView) MouseHandler() func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\treturn t.WrapMouseHandler(func(action MouseAction, event *tcell.EventMouse, setFocus func(p Primitive)) (consumed bool, capture Primitive) {\n\t\tx, y := event.Position()\n\t\tif !t.InRect(x, y) {\n\t\t\treturn false, nil\n\t\t}\n\n\t\tswitch action {\n\t\tcase MouseLeftDown:\n\t\t\tsetFocus(t)\n\t\t\tconsumed = true\n\t\tcase MouseLeftClick:\n\t\t\t_, rectY, _, _ := t.GetInnerRect()\n\t\t\ty += t.offsetY - rectY\n\t\t\tif y >= 0 && y < len(t.nodes) {\n\t\t\t\tnode := t.nodes[y]\n\t\t\t\tif node.selectable {\n\t\t\t\t\tpreviousNode := t.currentNode\n\t\t\t\t\tt.currentNode = node\n\t\t\t\t\tif previousNode != node && t.changed != nil {\n\t\t\t\t\t\tt.changed(node)\n\t\t\t\t\t}\n\t\t\t\t\tif t.selected != nil {\n\t\t\t\t\t\tt.selected(node)\n\t\t\t\t\t}\n\t\t\t\t\tif node.selected != nil {\n\t\t\t\t\t\tnode.selected()\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsumed = true\n\t\tcase MouseScrollUp:\n\t\t\tt.movement = treeScroll\n\t\t\tt.step = -1\n\t\t\tconsumed = true\n\t\tcase MouseScrollDown:\n\t\t\tt.movement = treeScroll\n\t\t\tt.step = 1\n\t\t\tconsumed = true\n\t\t}\n\n\t\treturn\n\t})\n}\n"
        },
        {
          "name": "tview.gif",
          "type": "blob",
          "size": 950.5703125,
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 4.80078125,
          "content": "package tview\n\nimport (\n\t\"math\"\n\t\"os\"\n\t\"regexp\"\n\n\t\"github.com/gdamore/tcell/v2\"\n)\n\n// Text alignment within a box. Also used to align images.\nconst (\n\tAlignLeft = iota\n\tAlignCenter\n\tAlignRight\n\tAlignTop    = 0\n\tAlignBottom = 2\n)\n\nvar (\n\t// Regular expression used to escape style/region tags.\n\tescapePattern = regexp.MustCompile(`(\\[[a-zA-Z0-9_,;: \\-\\.\"#]+\\[*)\\]`)\n\n\t// Regular expression used to unescape escaped style/region tags.\n\tunescapePattern = regexp.MustCompile(`(\\[[a-zA-Z0-9_,;: \\-\\.\"#]+\\[*)\\[\\]`)\n\n\t// The number of colors available in the terminal.\n\tavailableColors = 256\n)\n\n// Package initialization.\nfunc init() {\n\t// Determine the number of colors available in the terminal.\n\tinfo, err := tcell.LookupTerminfo(os.Getenv(\"TERM\"))\n\tif err == nil {\n\t\tavailableColors = info.Colors\n\t}\n}\n\n// Print prints text onto the screen into the given box at (x,y,maxWidth,1),\n// not exceeding that box. \"align\" is one of AlignLeft, AlignCenter, or\n// AlignRight. The screen's background color will not be changed.\n//\n// You can change the colors and text styles mid-text by inserting a style tag.\n// See the package description for details.\n//\n// Returns the number of actual bytes of the text printed (including style tags)\n// and the actual width used for the printed runes.\nfunc Print(screen tcell.Screen, text string, x, y, maxWidth, align int, color tcell.Color) (int, int) {\n\tstart, end, width := printWithStyle(screen, text, x, y, 0, maxWidth, align, tcell.StyleDefault.Foreground(color), true)\n\treturn end - start, width\n}\n\n// printWithStyle works like [Print] but it takes a style instead of just a\n// foreground color. The skipWidth parameter specifies the number of cells\n// skipped at the beginning of the text. It returns the start index, end index\n// (exclusively), and screen width of the text actually printed. If\n// maintainBackground is \"true\", the existing screen background is not changed\n// (i.e. the style's background color is ignored).\nfunc printWithStyle(screen tcell.Screen, text string, x, y, skipWidth, maxWidth, align int, style tcell.Style, maintainBackground bool) (start, end, printedWidth int) {\n\ttotalWidth, totalHeight := screen.Size()\n\tif maxWidth <= 0 || len(text) == 0 || y < 0 || y >= totalHeight {\n\t\treturn 0, 0, 0\n\t}\n\n\t// If we don't overwrite the background, we use the default color.\n\tif maintainBackground {\n\t\tstyle = style.Background(tcell.ColorDefault)\n\t}\n\n\t// Skip beginning and measure width.\n\tvar textWidth int\n\tstate := &stepState{\n\t\tunisegState: -1,\n\t\tstyle:       style,\n\t}\n\tstr := text\n\tfor len(str) > 0 {\n\t\t_, str, state = step(str, state, stepOptionsStyle)\n\t\tif skipWidth > 0 {\n\t\t\tskipWidth -= state.Width()\n\t\t\ttext = str\n\t\t\tstyle = state.Style()\n\t\t\tstart += state.GrossLength()\n\t\t} else {\n\t\t\ttextWidth += state.Width()\n\t\t}\n\t}\n\n\t// Reduce all alignments to AlignLeft.\n\tif align == AlignRight {\n\t\t// Chop off characters on the left until it fits.\n\t\tstate = nil\n\t\tfor len(text) > 0 && textWidth > maxWidth {\n\t\t\t_, text, state = step(text, state, stepOptionsStyle)\n\t\t\ttextWidth -= state.Width()\n\t\t\tstart += state.GrossLength()\n\t\t\tstyle = state.Style()\n\t\t}\n\t\tx, maxWidth = x+maxWidth-textWidth, textWidth\n\t} else if align == AlignCenter {\n\t\t// Chop off characters on the left until it fits.\n\t\tstate = nil\n\t\tsubtracted := (textWidth - maxWidth) / 2\n\t\tfor len(text) > 0 && subtracted > 0 {\n\t\t\t_, text, state = step(text, state, stepOptionsStyle)\n\t\t\tsubtracted -= state.Width()\n\t\t\ttextWidth -= state.Width()\n\t\t\tstart += state.GrossLength()\n\t\t\tstyle = state.Style()\n\t\t}\n\t\tif textWidth < maxWidth {\n\t\t\tx, maxWidth = x+maxWidth/2-textWidth/2, textWidth\n\t\t}\n\t}\n\n\t// Draw left-aligned text.\n\tend = start\n\trightBorder := x + maxWidth\n\tstate = &stepState{\n\t\tunisegState: -1,\n\t\tstyle:       style,\n\t}\n\tfor len(text) > 0 && x < rightBorder && x < totalWidth {\n\t\tvar c string\n\t\tc, text, state = step(text, state, stepOptionsStyle)\n\t\tif c == \"\" {\n\t\t\tbreak // We don't care about the style at the end.\n\t\t}\n\t\twidth := state.Width()\n\n\t\tif width > 0 {\n\t\t\tfinalStyle := state.Style()\n\t\t\tif maintainBackground {\n\t\t\t\t_, backgroundColor, _ := finalStyle.Decompose()\n\t\t\t\tif backgroundColor == tcell.ColorDefault {\n\t\t\t\t\t_, _, existingStyle, _ := screen.GetContent(x, y)\n\t\t\t\t\t_, background, _ := existingStyle.Decompose()\n\t\t\t\t\tfinalStyle = finalStyle.Background(background)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor offset := width - 1; offset >= 0; offset-- {\n\t\t\t\t// To avoid undesired effects, we populate all cells.\n\t\t\t\trunes := []rune(c)\n\t\t\t\tif offset == 0 {\n\t\t\t\t\tscreen.SetContent(x+offset, y, runes[0], runes[1:], finalStyle)\n\t\t\t\t} else {\n\t\t\t\t\tscreen.SetContent(x+offset, y, ' ', nil, finalStyle)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tx += width\n\t\tend += state.GrossLength()\n\t\tprintedWidth += width\n\t}\n\n\treturn\n}\n\n// PrintSimple prints white text to the screen at the given position.\nfunc PrintSimple(screen tcell.Screen, text string, x, y int) {\n\tPrint(screen, text, x, y, math.MaxInt32, AlignLeft, Styles.PrimaryTextColor)\n}\n"
        }
      ]
    }
  ]
}