{
  "metadata": {
    "timestamp": 1736568098471,
    "page": 237,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "quic-go/quic-go",
      "stars": 10324,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clusterfuzzlite",
          "type": "tree",
          "content": null
        },
        {
          "name": ".githooks",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.212890625,
          "content": "debug\ndebug.test\nmain\nmockgen_tmp.go\n*.qtr\n*.qlog\n*.sqlog\n*.txt\nrace.[0-9]*\n\nfuzzing/*/*.zip\nfuzzing/*/coverprofile\nfuzzing/*/crashers\nfuzzing/*/sonarprofile\nfuzzing/*/suppressions\nfuzzing/*/corpus/\n\ngomock_reflect_*/\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.9130859375,
          "content": "linters-settings:\n  misspell:\n    ignore-words:\n      - ect\n  depguard:\n    rules:\n      quicvarint:\n        list-mode: strict\n        files:\n          - \"**/github.com/quic-go/quic-go/quicvarint/*\"\n          - \"!$test\"\n        allow:\n          - $gostd\n\nlinters:\n  disable-all: true\n  enable:\n    - asciicheck\n    - copyloopvar\n    - depguard\n    - exhaustive\n    - goimports\n    - gofmt # redundant, since gofmt *should* be a no-op after gofumpt\n    - gofumpt\n    - gosimple\n    - govet\n    - ineffassign\n    - misspell\n    - prealloc\n    - staticcheck\n    - stylecheck\n    - unconvert\n    - unparam\n    - unused\n\nissues:\n  exclude-files:\n    - internal/handshake/cipher_suite.go\n  exclude-rules:\n    - path: internal/qtls\n      linters:\n        - depguard\n    - path: _test\\.go\n      linters:\n        - exhaustive\n        - prealloc\n        - unparam\n    - path: _test\\.go\n      text: \"SA1029:\"\n      linters:\n        - staticcheck\n"
        },
        {
          "name": "Changelog.md",
          "type": "blob",
          "size": 4.3857421875,
          "content": "# Changelog\n\n## v0.22.0 (2021-07-25)\n\n- Use `ReadBatch` to read multiple UDP packets from the socket with a single syscall\n- Add a config option (`Config.DisableVersionNegotiationPackets`) to disable sending of Version Negotiation packets\n- Drop support for QUIC draft versions 32 and 34\n- Remove the `RetireBugBackwardsCompatibilityMode`, which was intended to mitigate a bug when retiring connection IDs in quic-go in v0.17.2 and ealier\n\n## v0.21.2 (2021-07-15)\n\n- Update qtls (for Go 1.15, 1.16 and 1.17rc1) to include the fix for the crypto/tls panic (see https://groups.google.com/g/golang-dev/c/5LJ2V7rd-Ag/m/YGLHVBZ6AAAJ for details)\n\n## v0.21.0 (2021-06-01)\n\n- quic-go now supports RFC 9000!\n\n## v0.20.0 (2021-03-19)\n\n- Remove the `quic.Config.HandshakeTimeout`. Introduce a `quic.Config.HandshakeIdleTimeout`.\n\n## v0.17.1 (2020-06-20)\n\n- Supports QUIC WG draft-29.\n- Improve bundling of ACK frames (#2543).\n\n## v0.16.0 (2020-05-31)\n\n- Supports QUIC WG draft-28.\n\n## v0.15.0 (2020-03-01)\n\n- Supports QUIC WG draft-27.\n- Add support for 0-RTT.\n- Remove `Session.Close()`. Applications need to pass an application error code to the transport using `Session.CloseWithError()`.\n- Make the TLS Cipher Suites configurable (via `tls.Config.CipherSuites`).\n\n## v0.14.0 (2019-12-04)\n\n- Supports QUIC WG draft-24.\n\n## v0.13.0 (2019-11-05)\n\n- Supports QUIC WG draft-23.\n- Add an `EarlyListener` that allows sending of 0.5-RTT data.\n- Add a `TokenStore` to store address validation tokens.\n- Issue and use new connection IDs during a connection.\n\n## v0.12.0 (2019-08-05)\n\n- Implement HTTP/3.\n- Rename `quic.Cookie` to `quic.Token` and `quic.Config.AcceptCookie` to `quic.Config.AcceptToken`.\n- Distinguish between Retry tokens and tokens sent in NEW_TOKEN frames.\n- Enforce application protocol negotiation (via `tls.Config.NextProtos`).\n- Use a varint for error codes.\n- Add support for [quic-trace](https://github.com/google/quic-trace).\n- Add a context to `Listener.Accept`, `Session.Accept{Uni}Stream` and `Session.Open{Uni}StreamSync`.\n- Implement TLS key updates.\n\n## v0.11.0 (2019-04-05)\n\n- Drop support for gQUIC. For qQUIC support, please switch to the *gquic* branch.\n- Implement QUIC WG draft-19.\n- Use [qtls](https://github.com/marten-seemann/qtls) for TLS 1.3.\n- Return a `tls.ConnectionState` from `quic.Session.ConnectionState()`.\n- Remove the error return values from `quic.Stream.CancelRead()` and `quic.Stream.CancelWrite()`\n\n## v0.10.0 (2018-08-28)\n\n- Add support for QUIC 44, drop support for QUIC 42.\n\n## v0.9.0 (2018-08-15)\n\n- Add a `quic.Config` option for the length of the connection ID (for IETF QUIC).\n- Split Session.Close into one method for regular closing and one for closing with an error.\n\n## v0.8.0 (2018-06-26)\n\n- Add support for unidirectional streams (for IETF QUIC).\n- Add a `quic.Config` option for the maximum number of incoming streams.\n- Add support for QUIC 42 and 43.\n- Add dial functions that use a context.\n- Multiplex clients on a net.PacketConn, when using Dial(conn).\n\n## v0.7.0 (2018-02-03)\n\n- The lower boundary for packets included in ACKs is now derived, and the value sent in STOP_WAITING frames is ignored.\n- Remove `DialNonFWSecure` and `DialAddrNonFWSecure`.\n- Expose the `ConnectionState` in the `Session` (experimental API).\n- Implement packet pacing.\n\n## v0.6.0 (2017-12-12)\n\n- Add support for QUIC 39, drop support for QUIC 35 - 37\n- Added `quic.Config` options for maximal flow control windows\n- Add a `quic.Config` option for QUIC versions\n- Add a `quic.Config` option to request omission of the connection ID from a server\n- Add a `quic.Config` option to configure the source address validation\n- Add a `quic.Config` option to configure the handshake timeout\n- Add a `quic.Config` option to configure the idle timeout\n- Add a `quic.Config` option to configure keep-alive\n- Rename the STK to Cookie\n- Implement `net.Conn`-style deadlines for streams\n- Remove the `tls.Config` from the `quic.Config`. The `tls.Config` must now be passed to the `Dial` and `Listen` functions as a separate parameter. See the [Godoc](https://godoc.org/github.com/quic-go/quic-go) for details.\n- Changed the log level environment variable to only accept strings (\"DEBUG\", \"INFO\", \"ERROR\"), see [the wiki](https://github.com/quic-go/quic-go/wiki/Logging) for more details.\n- Rename the `h2quic.QuicRoundTripper` to `h2quic.RoundTripper`\n- Changed `h2quic.Server.Serve()` to accept a `net.PacketConn`\n- Drop support for Go 1.7 and 1.8.\n- Various bugfixes\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0654296875,
          "content": "MIT License\n\nCopyright (c) 2016 the quic-go authors & Google, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.2109375,
          "content": "# A QUIC implementation in pure Go\n\n<img src=\"docs/quic.png\" width=303 height=124>\n\n[![Documentation](https://img.shields.io/badge/docs-quic--go.net-red?style=flat)](https://quic-go.net/docs/)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/quic-go/quic-go)](https://pkg.go.dev/github.com/quic-go/quic-go)\n[![Code Coverage](https://img.shields.io/codecov/c/github/quic-go/quic-go/master.svg?style=flat-square)](https://codecov.io/gh/quic-go/quic-go/)\n[![Fuzzing Status](https://oss-fuzz-build-logs.storage.googleapis.com/badges/quic-go.svg)](https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&can=1&q=proj:quic-go)\n\nquic-go is an implementation of the QUIC protocol ([RFC 9000](https://datatracker.ietf.org/doc/html/rfc9000), [RFC 9001](https://datatracker.ietf.org/doc/html/rfc9001), [RFC 9002](https://datatracker.ietf.org/doc/html/rfc9002)) in Go. It has support for HTTP/3 ([RFC 9114](https://datatracker.ietf.org/doc/html/rfc9114)), including QPACK ([RFC 9204](https://datatracker.ietf.org/doc/html/rfc9204)) and HTTP Datagrams ([RFC 9297](https://datatracker.ietf.org/doc/html/rfc9297)).\n\nIn addition to these base RFCs, it also implements the following RFCs:\n\n* Unreliable Datagram Extension ([RFC 9221](https://datatracker.ietf.org/doc/html/rfc9221))\n* Datagram Packetization Layer Path MTU Discovery (DPLPMTUD, [RFC 8899](https://datatracker.ietf.org/doc/html/rfc8899))\n* QUIC Version 2 ([RFC 9369](https://datatracker.ietf.org/doc/html/rfc9369))\n* QUIC Event Logging using qlog ([draft-ietf-quic-qlog-main-schema](https://datatracker.ietf.org/doc/draft-ietf-quic-qlog-main-schema/) and [draft-ietf-quic-qlog-quic-events](https://datatracker.ietf.org/doc/draft-ietf-quic-qlog-quic-events/))\n\nSupport for WebTransport over HTTP/3 ([draft-ietf-webtrans-http3](https://datatracker.ietf.org/doc/draft-ietf-webtrans-http3/)) is implemented in [webtransport-go](https://github.com/quic-go/webtransport-go).\n\nDetailed documentation can be found on [quic-go.net](https://quic-go.net/docs/).\n\n## Projects using quic-go\n\n| Project                                                   | Description                                                                                                                                                       | Stars                                                                                               |\n| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| [AdGuardHome](https://github.com/AdguardTeam/AdGuardHome) | Free and open source, powerful network-wide ads & trackers blocking DNS server.                                                                                   | ![GitHub Repo stars](https://img.shields.io/github/stars/AdguardTeam/AdGuardHome?style=flat-square) |\n| [algernon](https://github.com/xyproto/algernon)           | Small self-contained pure-Go web server with Lua, Markdown, HTTP/2, QUIC, Redis and PostgreSQL support                                                            | ![GitHub Repo stars](https://img.shields.io/github/stars/xyproto/algernon?style=flat-square)        |\n| [caddy](https://github.com/caddyserver/caddy/)            | Fast, multi-platform web server with automatic HTTPS                                                                                                              | ![GitHub Repo stars](https://img.shields.io/github/stars/caddyserver/caddy?style=flat-square)       |\n| [cloudflared](https://github.com/cloudflare/cloudflared)  | A tunneling daemon that proxies traffic from the Cloudflare network to your origins                                                                               | ![GitHub Repo stars](https://img.shields.io/github/stars/cloudflare/cloudflared?style=flat-square)  |\n| [frp](https://github.com/fatedier/frp)                    | A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet                                                                   | ![GitHub Repo stars](https://img.shields.io/github/stars/fatedier/frp?style=flat-square)            |\n| [go-libp2p](https://github.com/libp2p/go-libp2p)          | libp2p implementation in Go, powering [Kubo](https://github.com/ipfs/kubo) (IPFS) and [Lotus](https://github.com/filecoin-project/lotus) (Filecoin), among others | ![GitHub Repo stars](https://img.shields.io/github/stars/libp2p/go-libp2p?style=flat-square)     |\n| [gost](https://github.com/go-gost/gost)                   | A simple security tunnel written in Go                                                                                                                        | ![GitHub Repo stars](https://img.shields.io/github/stars/go-gost/gost?style=flat-square)            |\n| [Hysteria](https://github.com/apernet/hysteria)           | A powerful, lightning fast and censorship resistant proxy                                                                                                         | ![GitHub Repo stars](https://img.shields.io/github/stars/apernet/hysteria?style=flat-square)        |\n| [Mercure](https://github.com/dunglas/mercure)             | An open, easy, fast, reliable and battery-efficient solution for real-time communications                                                                         | ![GitHub Repo stars](https://img.shields.io/github/stars/dunglas/mercure?style=flat-square)         |\n| [OONI Probe](https://github.com/ooni/probe-cli)           | Next generation OONI Probe. Library and CLI tool.                                                                                                                 | ![GitHub Repo stars](https://img.shields.io/github/stars/ooni/probe-cli?style=flat-square)          |\n| [reverst](https://github.com/flipt-io/reverst)            | Reverse Tunnels in Go over HTTP/3 and QUIC                                                                                                                        | ![GitHub Repo stars](https://img.shields.io/github/stars/flipt-io/reverst?style=flat-square) |\n| [RoadRunner](https://github.com/roadrunner-server/roadrunner) | High-performance PHP application server, process manager written in Go and powered with plugins | ![GitHub Repo stars](https://img.shields.io/github/stars/roadrunner-server/roadrunner?style=flat-square) |\n| [syncthing](https://github.com/syncthing/syncthing/)      | Open Source Continuous File Synchronization                                                                                                                       | ![GitHub Repo stars](https://img.shields.io/github/stars/syncthing/syncthing?style=flat-square)     |\n| [traefik](https://github.com/traefik/traefik)             | The Cloud Native Application Proxy                                                                                                                                | ![GitHub Repo stars](https://img.shields.io/github/stars/traefik/traefik?style=flat-square)         |\n| [v2ray-core](https://github.com/v2fly/v2ray-core)         | A platform for building proxies to bypass network restrictions                                                                                                    | ![GitHub Repo stars](https://img.shields.io/github/stars/v2fly/v2ray-core?style=flat-square)        |\n| [YoMo](https://github.com/yomorun/yomo)                   | Streaming Serverless Framework for Geo-distributed System                                                                                                         | ![GitHub Repo stars](https://img.shields.io/github/stars/yomorun/yomo?style=flat-square)            |\n\nIf you'd like to see your project added to this list, please send us a PR.\n\n## Release Policy\n\nquic-go always aims to support the latest two Go releases.\n\n## Contributing\n\nWe are always happy to welcome new contributors! We have a number of self-contained issues that are suitable for first-time contributors, they are tagged with [help wanted](https://github.com/quic-go/quic-go/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22). If you have any questions, please feel free to reach out by opening an issue or leaving a comment.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.8193359375,
          "content": "# Security Policy\n\nquic-go still in development. This means that there may be problems in our protocols,\nor there may be mistakes in our implementations.\nWe take security vulnerabilities very seriously. If you discover a security issue,\nplease bring it to our attention right away!\n\n## Reporting a Vulnerability\n\nIf you find a vulnerability that may affect live deployments -- for example, by exposing\na remote execution exploit -- please [**report privately**](https://github.com/quic-go/quic-go/security/advisories/new).\nPlease **DO NOT file a public issue**.\n\nIf the issue is an implementation weakness that cannot be immediately exploited or\nsomething not yet deployed, just discuss it openly.\n\n## Reporting a non security bug\n\nFor non-security bugs, please simply file a GitHub [issue](https://github.com/quic-go/quic-go/issues/new).\n"
        },
        {
          "name": "buffer_pool.go",
          "type": "blob",
          "size": 2.20703125,
          "content": "package quic\n\nimport (\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n)\n\ntype packetBuffer struct {\n\tData []byte\n\n\t// refCount counts how many packets Data is used in.\n\t// It doesn't support concurrent use.\n\t// It is > 1 when used for coalesced packet.\n\trefCount int\n}\n\n// Split increases the refCount.\n// It must be called when a packet buffer is used for more than one packet,\n// e.g. when splitting coalesced packets.\nfunc (b *packetBuffer) Split() {\n\tb.refCount++\n}\n\n// Decrement decrements the reference counter.\n// It doesn't put the buffer back into the pool.\nfunc (b *packetBuffer) Decrement() {\n\tb.refCount--\n\tif b.refCount < 0 {\n\t\tpanic(\"negative packetBuffer refCount\")\n\t}\n}\n\n// MaybeRelease puts the packet buffer back into the pool,\n// if the reference counter already reached 0.\nfunc (b *packetBuffer) MaybeRelease() {\n\t// only put the packetBuffer back if it's not used any more\n\tif b.refCount == 0 {\n\t\tb.putBack()\n\t}\n}\n\n// Release puts back the packet buffer into the pool.\n// It should be called when processing is definitely finished.\nfunc (b *packetBuffer) Release() {\n\tb.Decrement()\n\tif b.refCount != 0 {\n\t\tpanic(\"packetBuffer refCount not zero\")\n\t}\n\tb.putBack()\n}\n\n// Len returns the length of Data\nfunc (b *packetBuffer) Len() protocol.ByteCount { return protocol.ByteCount(len(b.Data)) }\nfunc (b *packetBuffer) Cap() protocol.ByteCount { return protocol.ByteCount(cap(b.Data)) }\n\nfunc (b *packetBuffer) putBack() {\n\tif cap(b.Data) == protocol.MaxPacketBufferSize {\n\t\tbufferPool.Put(b)\n\t\treturn\n\t}\n\tif cap(b.Data) == protocol.MaxLargePacketBufferSize {\n\t\tlargeBufferPool.Put(b)\n\t\treturn\n\t}\n\tpanic(\"putPacketBuffer called with packet of wrong size!\")\n}\n\nvar bufferPool, largeBufferPool sync.Pool\n\nfunc getPacketBuffer() *packetBuffer {\n\tbuf := bufferPool.Get().(*packetBuffer)\n\tbuf.refCount = 1\n\tbuf.Data = buf.Data[:0]\n\treturn buf\n}\n\nfunc getLargePacketBuffer() *packetBuffer {\n\tbuf := largeBufferPool.Get().(*packetBuffer)\n\tbuf.refCount = 1\n\tbuf.Data = buf.Data[:0]\n\treturn buf\n}\n\nfunc init() {\n\tbufferPool.New = func() any {\n\t\treturn &packetBuffer{Data: make([]byte, 0, protocol.MaxPacketBufferSize)}\n\t}\n\tlargeBufferPool.New = func() any {\n\t\treturn &packetBuffer{Data: make([]byte, 0, protocol.MaxLargePacketBufferSize)}\n\t}\n}\n"
        },
        {
          "name": "buffer_pool_test.go",
          "type": "blob",
          "size": 1.0712890625,
          "content": "package quic\n\nimport (\n\t\"testing\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestBufferPoolSizes(t *testing.T) {\n\tbuf1 := getPacketBuffer()\n\trequire.Equal(t, protocol.MaxPacketBufferSize, cap(buf1.Data))\n\trequire.Zero(t, buf1.Len())\n\tbuf1.Data = append(buf1.Data, []byte(\"foobar\")...)\n\trequire.Equal(t, protocol.ByteCount(6), buf1.Len())\n\n\tbuf2 := getLargePacketBuffer()\n\trequire.Equal(t, protocol.MaxLargePacketBufferSize, cap(buf2.Data))\n\trequire.Zero(t, buf2.Len())\n}\n\nfunc TestBufferPoolRelease(t *testing.T) {\n\tbuf1 := getPacketBuffer()\n\tbuf1.Release()\n\t// panics if released twice\n\trequire.Panics(t, func() { buf1.Release() })\n\n\t// panics if wrong-sized buffers are passed\n\tbuf2 := getLargePacketBuffer()\n\tbuf2.Data = make([]byte, 10) // replace the underlying slice\n\trequire.Panics(t, func() { buf2.Release() })\n}\n\nfunc TestBufferPoolSplitting(t *testing.T) {\n\tbuf := getPacketBuffer()\n\tbuf.Split()\n\tbuf.Split()\n\t// now we have 3 parts\n\tbuf.Decrement()\n\tbuf.Decrement()\n\tbuf.Decrement()\n\trequire.Panics(t, func() { buf.Decrement() })\n}\n"
        },
        {
          "name": "client.go",
          "type": "blob",
          "size": 7.0888671875,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\ntype client struct {\n\tsendConn sendConn\n\n\tuse0RTT bool\n\n\tpacketHandlers packetHandlerManager\n\tonClose        func()\n\n\ttlsConf *tls.Config\n\tconfig  *Config\n\n\tconnIDGenerator ConnectionIDGenerator\n\tsrcConnID       protocol.ConnectionID\n\tdestConnID      protocol.ConnectionID\n\n\tinitialPacketNumber  protocol.PacketNumber\n\thasNegotiatedVersion bool\n\tversion              protocol.Version\n\n\thandshakeChan chan struct{}\n\n\tconn quicConn\n\n\ttracer    *logging.ConnectionTracer\n\ttracingID ConnectionTracingID\n\tlogger    utils.Logger\n}\n\n// make it possible to mock connection ID for initial generation in the tests\nvar generateConnectionIDForInitial = protocol.GenerateConnectionIDForInitial\n\n// DialAddr establishes a new QUIC connection to a server.\n// It resolves the address, and then creates a new UDP connection to dial the QUIC server.\n// When the QUIC connection is closed, this UDP connection is closed.\n// See Dial for more details.\nfunc DialAddr(ctx context.Context, addr string, tlsConf *tls.Config, conf *Config) (Connection, error) {\n\tudpConn, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.IPv4zero, Port: 0})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttr, err := setupTransport(udpConn, tlsConf, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tr.dial(ctx, udpAddr, addr, tlsConf, conf, false)\n}\n\n// DialAddrEarly establishes a new 0-RTT QUIC connection to a server.\n// See DialAddr for more details.\nfunc DialAddrEarly(ctx context.Context, addr string, tlsConf *tls.Config, conf *Config) (EarlyConnection, error) {\n\tudpConn, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.IPv4zero, Port: 0})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttr, err := setupTransport(udpConn, tlsConf, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, err := tr.dial(ctx, udpAddr, addr, tlsConf, conf, true)\n\tif err != nil {\n\t\ttr.Close()\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\n// DialEarly establishes a new 0-RTT QUIC connection to a server using a net.PacketConn.\n// See Dial for more details.\nfunc DialEarly(ctx context.Context, c net.PacketConn, addr net.Addr, tlsConf *tls.Config, conf *Config) (EarlyConnection, error) {\n\tdl, err := setupTransport(c, tlsConf, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, err := dl.DialEarly(ctx, addr, tlsConf, conf)\n\tif err != nil {\n\t\tdl.Close()\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\n// Dial establishes a new QUIC connection to a server using a net.PacketConn.\n// If the PacketConn satisfies the OOBCapablePacketConn interface (as a net.UDPConn does),\n// ECN and packet info support will be enabled. In this case, ReadMsgUDP and WriteMsgUDP\n// will be used instead of ReadFrom and WriteTo to read/write packets.\n// The tls.Config must define an application protocol (using NextProtos).\n//\n// This is a convenience function. More advanced use cases should instantiate a Transport,\n// which offers configuration options for a more fine-grained control of the connection establishment,\n// including reusing the underlying UDP socket for multiple QUIC connections.\nfunc Dial(ctx context.Context, c net.PacketConn, addr net.Addr, tlsConf *tls.Config, conf *Config) (Connection, error) {\n\tdl, err := setupTransport(c, tlsConf, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, err := dl.Dial(ctx, addr, tlsConf, conf)\n\tif err != nil {\n\t\tdl.Close()\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\nfunc setupTransport(c net.PacketConn, tlsConf *tls.Config, createdPacketConn bool) (*Transport, error) {\n\tif tlsConf == nil {\n\t\treturn nil, errors.New(\"quic: tls.Config not set\")\n\t}\n\treturn &Transport{\n\t\tConn:        c,\n\t\tcreatedConn: createdPacketConn,\n\t\tisSingleUse: true,\n\t}, nil\n}\n\nfunc dial(\n\tctx context.Context,\n\tconn sendConn,\n\tconnIDGenerator ConnectionIDGenerator,\n\tpacketHandlers packetHandlerManager,\n\ttlsConf *tls.Config,\n\tconfig *Config,\n\tonClose func(),\n\tuse0RTT bool,\n) (quicConn, error) {\n\tc, err := newClient(conn, connIDGenerator, config, tlsConf, onClose, use0RTT)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.packetHandlers = packetHandlers\n\n\tc.tracingID = nextConnTracingID()\n\tif c.config.Tracer != nil {\n\t\tc.tracer = c.config.Tracer(context.WithValue(ctx, ConnectionTracingKey, c.tracingID), protocol.PerspectiveClient, c.destConnID)\n\t}\n\tif c.tracer != nil && c.tracer.StartedConnection != nil {\n\t\tc.tracer.StartedConnection(c.sendConn.LocalAddr(), c.sendConn.RemoteAddr(), c.srcConnID, c.destConnID)\n\t}\n\tif err := c.dial(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.conn, nil\n}\n\nfunc newClient(sendConn sendConn, connIDGenerator ConnectionIDGenerator, config *Config, tlsConf *tls.Config, onClose func(), use0RTT bool) (*client, error) {\n\tsrcConnID, err := connIDGenerator.GenerateConnectionID()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdestConnID, err := generateConnectionIDForInitial()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc := &client{\n\t\tconnIDGenerator: connIDGenerator,\n\t\tsrcConnID:       srcConnID,\n\t\tdestConnID:      destConnID,\n\t\tsendConn:        sendConn,\n\t\tuse0RTT:         use0RTT,\n\t\tonClose:         onClose,\n\t\ttlsConf:         tlsConf,\n\t\tconfig:          config,\n\t\tversion:         config.Versions[0],\n\t\thandshakeChan:   make(chan struct{}),\n\t\tlogger:          utils.DefaultLogger.WithPrefix(\"client\"),\n\t}\n\treturn c, nil\n}\n\nfunc (c *client) dial(ctx context.Context) error {\n\tc.logger.Infof(\"Starting new connection to %s (%s -> %s), source connection ID %s, destination connection ID %s, version %s\", c.tlsConf.ServerName, c.sendConn.LocalAddr(), c.sendConn.RemoteAddr(), c.srcConnID, c.destConnID, c.version)\n\n\tc.conn = newClientConnection(\n\t\tcontext.WithValue(context.WithoutCancel(ctx), ConnectionTracingKey, c.tracingID),\n\t\tc.sendConn,\n\t\tc.packetHandlers,\n\t\tc.destConnID,\n\t\tc.srcConnID,\n\t\tc.connIDGenerator,\n\t\tc.config,\n\t\tc.tlsConf,\n\t\tc.initialPacketNumber,\n\t\tc.use0RTT,\n\t\tc.hasNegotiatedVersion,\n\t\tc.tracer,\n\t\tc.logger,\n\t\tc.version,\n\t)\n\tc.packetHandlers.Add(c.srcConnID, c.conn)\n\n\terrorChan := make(chan error, 1)\n\trecreateChan := make(chan errCloseForRecreating)\n\tgo func() {\n\t\terr := c.conn.run()\n\t\tvar recreateErr *errCloseForRecreating\n\t\tif errors.As(err, &recreateErr) {\n\t\t\trecreateChan <- *recreateErr\n\t\t\treturn\n\t\t}\n\t\tif c.onClose != nil {\n\t\t\tc.onClose()\n\t\t}\n\t\terrorChan <- err // returns as soon as the connection is closed\n\t}()\n\n\t// only set when we're using 0-RTT\n\t// Otherwise, earlyConnChan will be nil. Receiving from a nil chan blocks forever.\n\tvar earlyConnChan <-chan struct{}\n\tif c.use0RTT {\n\t\tearlyConnChan = c.conn.earlyConnReady()\n\t}\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tc.conn.destroy(nil)\n\t\treturn context.Cause(ctx)\n\tcase err := <-errorChan:\n\t\treturn err\n\tcase recreateErr := <-recreateChan:\n\t\tc.initialPacketNumber = recreateErr.nextPacketNumber\n\t\tc.version = recreateErr.nextVersion\n\t\tc.hasNegotiatedVersion = true\n\t\treturn c.dial(ctx)\n\tcase <-earlyConnChan:\n\t\t// ready to send 0-RTT data\n\t\treturn nil\n\tcase <-c.conn.HandshakeComplete():\n\t\t// handshake successfully completed\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "client_test.go",
          "type": "blob",
          "size": 10.453125,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"time\"\n\n\tmocklogging \"github.com/quic-go/quic-go/internal/mocks/logging\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nvar _ = Describe(\"Client\", func() {\n\tvar (\n\t\tcl         *client\n\t\tpacketConn *MockSendConn\n\t\tconnID     protocol.ConnectionID\n\t\ttlsConf    *tls.Config\n\t\ttracer     *mocklogging.MockConnectionTracer\n\t\tconfig     *Config\n\n\t\toriginalClientConnConstructor func(\n\t\t\tctx context.Context,\n\t\t\tconn sendConn,\n\t\t\trunner connRunner,\n\t\t\tdestConnID protocol.ConnectionID,\n\t\t\tsrcConnID protocol.ConnectionID,\n\t\t\tconnIDGenerator ConnectionIDGenerator,\n\t\t\tconf *Config,\n\t\t\ttlsConf *tls.Config,\n\t\t\tinitialPacketNumber protocol.PacketNumber,\n\t\t\tenable0RTT bool,\n\t\t\thasNegotiatedVersion bool,\n\t\t\ttracer *logging.ConnectionTracer,\n\t\t\tlogger utils.Logger,\n\t\t\tv protocol.Version,\n\t\t) quicConn\n\t)\n\n\tBeforeEach(func() {\n\t\ttlsConf = &tls.Config{NextProtos: []string{\"proto1\"}}\n\t\tconnID = protocol.ParseConnectionID([]byte{0, 0, 0, 0, 0, 0, 0x13, 0x37})\n\t\toriginalClientConnConstructor = newClientConnection\n\t\tvar tr *logging.ConnectionTracer\n\t\ttr, tracer = mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\tconfig = &Config{\n\t\t\tTracer: func(ctx context.Context, perspective logging.Perspective, id ConnectionID) *logging.ConnectionTracer {\n\t\t\t\treturn tr\n\t\t\t},\n\t\t\tVersions: []protocol.Version{protocol.Version1},\n\t\t}\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\t\tpacketConn = NewMockSendConn(mockCtrl)\n\t\tpacketConn.EXPECT().LocalAddr().Return(&net.UDPAddr{}).AnyTimes()\n\t\tpacketConn.EXPECT().RemoteAddr().Return(&net.UDPAddr{}).AnyTimes()\n\t\tcl = &client{\n\t\t\tsrcConnID:  connID,\n\t\t\tdestConnID: connID,\n\t\t\tversion:    protocol.Version1,\n\t\t\tsendConn:   packetConn,\n\t\t\ttracer:     tr,\n\t\t\tlogger:     utils.DefaultLogger,\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\tnewClientConnection = originalClientConnConstructor\n\t})\n\n\tAfterEach(func() {\n\t\tif s, ok := cl.conn.(*connection); ok {\n\t\t\ts.destroy(nil)\n\t\t}\n\t\tEventually(areConnsRunning).Should(BeFalse())\n\t})\n\n\tContext(\"Dialing\", func() {\n\t\tvar origGenerateConnectionIDForInitial func() (protocol.ConnectionID, error)\n\n\t\tBeforeEach(func() {\n\t\t\torigGenerateConnectionIDForInitial = generateConnectionIDForInitial\n\t\t\tgenerateConnectionIDForInitial = func() (protocol.ConnectionID, error) {\n\t\t\t\treturn connID, nil\n\t\t\t}\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tgenerateConnectionIDForInitial = origGenerateConnectionIDForInitial\n\t\t})\n\n\t\tIt(\"returns after the handshake is complete\", func() {\n\t\t\tmanager := NewMockPacketHandlerManager(mockCtrl)\n\t\t\tmanager.EXPECT().Add(gomock.Any(), gomock.Any())\n\n\t\t\trun := make(chan struct{})\n\t\t\tnewClientConnection = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ sendConn,\n\t\t\t\t_ connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t_ *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ protocol.PacketNumber,\n\t\t\t\tenable0RTT bool,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\t_ protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tExpect(enable0RTT).To(BeFalse())\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tconn.EXPECT().run().Do(func() error { close(run); return nil })\n\t\t\t\tc := make(chan struct{})\n\t\t\t\tclose(c)\n\t\t\t\tconn.EXPECT().HandshakeComplete().Return(c)\n\t\t\t\treturn conn\n\t\t\t}\n\t\t\tcl, err := newClient(packetConn, &protocol.DefaultConnectionIDGenerator{}, populateConfig(config), tlsConf, nil, false)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tcl.packetHandlers = manager\n\t\t\tExpect(cl).ToNot(BeNil())\n\t\t\tExpect(cl.dial(context.Background())).To(Succeed())\n\t\t\tEventually(run).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"returns early connections\", func() {\n\t\t\tmanager := NewMockPacketHandlerManager(mockCtrl)\n\t\t\tmanager.EXPECT().Add(gomock.Any(), gomock.Any())\n\t\t\treadyChan := make(chan struct{})\n\t\t\tdone := make(chan struct{})\n\t\t\tnewClientConnection = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ sendConn,\n\t\t\t\trunner connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t_ *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ protocol.PacketNumber,\n\t\t\t\tenable0RTT bool,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\t_ protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tExpect(enable0RTT).To(BeTrue())\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tconn.EXPECT().run().Do(func() error { close(done); return nil })\n\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{}))\n\t\t\t\tconn.EXPECT().earlyConnReady().Return(readyChan)\n\t\t\t\treturn conn\n\t\t\t}\n\n\t\t\tcl, err := newClient(packetConn, &protocol.DefaultConnectionIDGenerator{}, populateConfig(config), tlsConf, nil, true)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tcl.packetHandlers = manager\n\t\t\tExpect(cl).ToNot(BeNil())\n\t\t\tExpect(cl.dial(context.Background())).To(Succeed())\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"returns an error that occurs while waiting for the handshake to complete\", func() {\n\t\t\tmanager := NewMockPacketHandlerManager(mockCtrl)\n\t\t\tmanager.EXPECT().Add(gomock.Any(), gomock.Any())\n\n\t\t\ttestErr := errors.New(\"early handshake error\")\n\t\t\tnewClientConnection = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ sendConn,\n\t\t\t\t_ connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t_ *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ protocol.PacketNumber,\n\t\t\t\t_ bool,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\t_ protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tconn.EXPECT().run().Return(testErr)\n\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{}))\n\t\t\t\tconn.EXPECT().earlyConnReady().Return(make(chan struct{}))\n\t\t\t\treturn conn\n\t\t\t}\n\t\t\tvar closed bool\n\t\t\tcl, err := newClient(packetConn, &protocol.DefaultConnectionIDGenerator{}, populateConfig(config), tlsConf, func() { closed = true }, true)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tcl.packetHandlers = manager\n\t\t\tExpect(cl).ToNot(BeNil())\n\t\t\tExpect(cl.dial(context.Background())).To(MatchError(testErr))\n\t\t\tExpect(closed).To(BeTrue())\n\t\t})\n\n\t\tContext(\"quic.Config\", func() {\n\t\t\tIt(\"setups with the right values\", func() {\n\t\t\t\ttokenStore := NewLRUTokenStore(10, 4)\n\t\t\t\tconfig := &Config{\n\t\t\t\t\tHandshakeIdleTimeout:  1337 * time.Minute,\n\t\t\t\t\tMaxIdleTimeout:        42 * time.Hour,\n\t\t\t\t\tMaxIncomingStreams:    1234,\n\t\t\t\t\tMaxIncomingUniStreams: 4321,\n\t\t\t\t\tTokenStore:            tokenStore,\n\t\t\t\t\tEnableDatagrams:       true,\n\t\t\t\t}\n\t\t\t\tc := populateConfig(config)\n\t\t\t\tExpect(c.HandshakeIdleTimeout).To(Equal(1337 * time.Minute))\n\t\t\t\tExpect(c.MaxIdleTimeout).To(Equal(42 * time.Hour))\n\t\t\t\tExpect(c.MaxIncomingStreams).To(BeEquivalentTo(1234))\n\t\t\t\tExpect(c.MaxIncomingUniStreams).To(BeEquivalentTo(4321))\n\t\t\t\tExpect(c.TokenStore).To(Equal(tokenStore))\n\t\t\t\tExpect(c.EnableDatagrams).To(BeTrue())\n\t\t\t})\n\n\t\t\tIt(\"disables bidirectional streams\", func() {\n\t\t\t\tconfig := &Config{\n\t\t\t\t\tMaxIncomingStreams:    -1,\n\t\t\t\t\tMaxIncomingUniStreams: 4321,\n\t\t\t\t}\n\t\t\t\tc := populateConfig(config)\n\t\t\t\tExpect(c.MaxIncomingStreams).To(BeZero())\n\t\t\t\tExpect(c.MaxIncomingUniStreams).To(BeEquivalentTo(4321))\n\t\t\t})\n\n\t\t\tIt(\"disables unidirectional streams\", func() {\n\t\t\t\tconfig := &Config{\n\t\t\t\t\tMaxIncomingStreams:    1234,\n\t\t\t\t\tMaxIncomingUniStreams: -1,\n\t\t\t\t}\n\t\t\t\tc := populateConfig(config)\n\t\t\t\tExpect(c.MaxIncomingStreams).To(BeEquivalentTo(1234))\n\t\t\t\tExpect(c.MaxIncomingUniStreams).To(BeZero())\n\t\t\t})\n\n\t\t\tIt(\"fills in default values if options are not set in the Config\", func() {\n\t\t\t\tc := populateConfig(&Config{})\n\t\t\t\tExpect(c.Versions).To(Equal(protocol.SupportedVersions))\n\t\t\t\tExpect(c.HandshakeIdleTimeout).To(Equal(protocol.DefaultHandshakeIdleTimeout))\n\t\t\t\tExpect(c.MaxIdleTimeout).To(Equal(protocol.DefaultIdleTimeout))\n\t\t\t})\n\t\t})\n\n\t\tIt(\"creates new connections with the right parameters\", func() {\n\t\t\tconfig := &Config{Versions: []protocol.Version{protocol.Version1}}\n\t\t\tc := make(chan struct{})\n\t\t\tvar version protocol.Version\n\t\t\tvar conf *Config\n\t\t\tdone := make(chan struct{})\n\t\t\tnewClientConnection = func(\n\t\t\t\t_ context.Context,\n\t\t\t\tconnP sendConn,\n\t\t\t\t_ connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\tconfigP *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ protocol.PacketNumber,\n\t\t\t\t_ bool,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\tversionP protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tversion = versionP\n\t\t\t\tconf = configP\n\t\t\t\tclose(c)\n\t\t\t\t// TODO: check connection IDs?\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tconn.EXPECT().run()\n\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{}))\n\t\t\t\tconn.EXPECT().destroy(gomock.Any()).MaxTimes(1)\n\t\t\t\tclose(done)\n\t\t\t\treturn conn\n\t\t\t}\n\t\t\tpacketConn := NewMockPacketConn(mockCtrl)\n\t\t\tpacketConn.EXPECT().ReadFrom(gomock.Any()).DoAndReturn(func([]byte) (int, net.Addr, error) {\n\t\t\t\t<-done\n\t\t\t\treturn 0, nil, errors.New(\"closed\")\n\t\t\t})\n\t\t\tpacketConn.EXPECT().LocalAddr()\n\t\t\tpacketConn.EXPECT().SetReadDeadline(gomock.Any()).AnyTimes()\n\t\t\t_, err := Dial(context.Background(), packetConn, &net.UDPAddr{}, tlsConf, config)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tEventually(c).Should(BeClosed())\n\t\t\tExpect(version).To(Equal(config.Versions[0]))\n\t\t\tExpect(conf.Versions).To(Equal(config.Versions))\n\t\t})\n\n\t\tIt(\"creates a new connections after version negotiation\", func() {\n\t\t\tvar counter int\n\t\t\tnewClientConnection = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ sendConn,\n\t\t\t\trunner connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\tconnID protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\tconfigP *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\tpn protocol.PacketNumber,\n\t\t\t\t_ bool,\n\t\t\t\thasNegotiatedVersion bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\tversionP protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{}))\n\t\t\t\tif counter == 0 {\n\t\t\t\t\tExpect(pn).To(BeZero())\n\t\t\t\t\tExpect(hasNegotiatedVersion).To(BeFalse())\n\t\t\t\t\tconn.EXPECT().run().DoAndReturn(func() error {\n\t\t\t\t\t\trunner.Remove(connID)\n\t\t\t\t\t\treturn &errCloseForRecreating{\n\t\t\t\t\t\t\tnextPacketNumber: 109,\n\t\t\t\t\t\t\tnextVersion:      789,\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tExpect(pn).To(Equal(protocol.PacketNumber(109)))\n\t\t\t\t\tExpect(hasNegotiatedVersion).To(BeTrue())\n\t\t\t\t\tconn.EXPECT().run()\n\t\t\t\t\tconn.EXPECT().destroy(gomock.Any())\n\t\t\t\t}\n\t\t\t\tcounter++\n\t\t\t\treturn conn\n\t\t\t}\n\n\t\t\tconfig := &Config{Tracer: config.Tracer, Versions: []protocol.Version{protocol.Version1}}\n\t\t\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\t_, err := DialAddr(context.Background(), \"localhost:7890\", tlsConf, config)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(counter).To(Equal(2))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "closed_conn.go",
          "type": "blob",
          "size": 1.7734375,
          "content": "package quic\n\nimport (\n\t\"math/bits\"\n\t\"net\"\n\t\"sync/atomic\"\n\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\n// A closedLocalConn is a connection that we closed locally.\n// When receiving packets for such a connection, we need to retransmit the packet containing the CONNECTION_CLOSE frame,\n// with an exponential backoff.\ntype closedLocalConn struct {\n\tcounter atomic.Uint32\n\tlogger  utils.Logger\n\n\tsendPacket func(net.Addr, packetInfo)\n}\n\nvar _ packetHandler = &closedLocalConn{}\n\n// newClosedLocalConn creates a new closedLocalConn and runs it.\nfunc newClosedLocalConn(sendPacket func(net.Addr, packetInfo), logger utils.Logger) packetHandler {\n\treturn &closedLocalConn{\n\t\tsendPacket: sendPacket,\n\t\tlogger:     logger,\n\t}\n}\n\nfunc (c *closedLocalConn) handlePacket(p receivedPacket) {\n\tn := c.counter.Add(1)\n\t// exponential backoff\n\t// only send a CONNECTION_CLOSE for the 1st, 2nd, 4th, 8th, 16th, ... packet arriving\n\tif bits.OnesCount32(n) != 1 {\n\t\treturn\n\t}\n\tc.logger.Debugf(\"Received %d packets after sending CONNECTION_CLOSE. Retransmitting.\", n)\n\tc.sendPacket(p.remoteAddr, p.info)\n}\n\nfunc (c *closedLocalConn) destroy(error)                              {}\nfunc (c *closedLocalConn) closeWithTransportError(TransportErrorCode) {}\n\n// A closedRemoteConn is a connection that was closed remotely.\n// For such a connection, we might receive reordered packets that were sent before the CONNECTION_CLOSE.\n// We can just ignore those packets.\ntype closedRemoteConn struct{}\n\nvar _ packetHandler = &closedRemoteConn{}\n\nfunc newClosedRemoteConn() packetHandler {\n\treturn &closedRemoteConn{}\n}\n\nfunc (c *closedRemoteConn) handlePacket(receivedPacket)                {}\nfunc (c *closedRemoteConn) destroy(error)                              {}\nfunc (c *closedRemoteConn) closeWithTransportError(TransportErrorCode) {}\n"
        },
        {
          "name": "closed_conn_test.go",
          "type": "blob",
          "size": 0.84375,
          "content": "package quic\n\nimport (\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestClosedLocalConnection(t *testing.T) {\n\twritten := make(chan net.Addr, 1)\n\tconn := newClosedLocalConn(func(addr net.Addr, _ packetInfo) { written <- addr }, utils.DefaultLogger)\n\taddr := &net.UDPAddr{IP: net.IPv4(127, 1, 2, 3), Port: 1337}\n\tfor i := 1; i <= 20; i++ {\n\t\tconn.handlePacket(receivedPacket{remoteAddr: addr})\n\t\tif i == 1 || i == 2 || i == 4 || i == 8 || i == 16 {\n\t\t\tselect {\n\t\t\tcase gotAddr := <-written:\n\t\t\t\trequire.Equal(t, addr, gotAddr) // receive the CONNECTION_CLOSE\n\t\t\tdefault:\n\t\t\t\tt.Fatal(\"expected to receive address\")\n\t\t\t}\n\t\t} else {\n\t\t\tselect {\n\t\t\tcase gotAddr := <-written:\n\t\t\t\tt.Fatalf(\"unexpected address received: %v\", gotAddr)\n\t\t\tdefault:\n\t\t\t\t// Nothing received, which is expected\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.388671875,
          "content": "coverage:\n  round: nearest\n  ignore:\n    - http3/gzip_reader.go\n    - interop/\n    - internal/handshake/cipher_suite.go\n    - internal/utils/linkedlist/linkedlist.go\n    - internal/testdata\n    - logging/connection_tracer_multiplexer.go\n    - logging/tracer_multiplexer.go\n    - testutils/\n    - fuzzing/\n    - metrics/\n  status:\n    project:\n      default:\n        threshold: 0.5\n    patch: false\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 4.1953125,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/quicvarint\"\n)\n\n// Clone clones a Config\nfunc (c *Config) Clone() *Config {\n\tcopy := *c\n\treturn &copy\n}\n\nfunc (c *Config) handshakeTimeout() time.Duration {\n\treturn 2 * c.HandshakeIdleTimeout\n}\n\nfunc (c *Config) maxRetryTokenAge() time.Duration {\n\treturn c.handshakeTimeout()\n}\n\nfunc validateConfig(config *Config) error {\n\tif config == nil {\n\t\treturn nil\n\t}\n\tconst maxStreams = 1 << 60\n\tif config.MaxIncomingStreams > maxStreams {\n\t\tconfig.MaxIncomingStreams = maxStreams\n\t}\n\tif config.MaxIncomingUniStreams > maxStreams {\n\t\tconfig.MaxIncomingUniStreams = maxStreams\n\t}\n\tif config.MaxStreamReceiveWindow > quicvarint.Max {\n\t\tconfig.MaxStreamReceiveWindow = quicvarint.Max\n\t}\n\tif config.MaxConnectionReceiveWindow > quicvarint.Max {\n\t\tconfig.MaxConnectionReceiveWindow = quicvarint.Max\n\t}\n\tif config.InitialPacketSize > 0 && config.InitialPacketSize < protocol.MinInitialPacketSize {\n\t\tconfig.InitialPacketSize = protocol.MinInitialPacketSize\n\t}\n\tif config.InitialPacketSize > protocol.MaxPacketBufferSize {\n\t\tconfig.InitialPacketSize = protocol.MaxPacketBufferSize\n\t}\n\t// check that all QUIC versions are actually supported\n\tfor _, v := range config.Versions {\n\t\tif !protocol.IsValidVersion(v) {\n\t\t\treturn fmt.Errorf(\"invalid QUIC version: %s\", v)\n\t\t}\n\t}\n\treturn nil\n}\n\n// populateConfig populates fields in the quic.Config with their default values, if none are set\n// it may be called with nil\nfunc populateConfig(config *Config) *Config {\n\tif config == nil {\n\t\tconfig = &Config{}\n\t}\n\tversions := config.Versions\n\tif len(versions) == 0 {\n\t\tversions = protocol.SupportedVersions\n\t}\n\thandshakeIdleTimeout := protocol.DefaultHandshakeIdleTimeout\n\tif config.HandshakeIdleTimeout != 0 {\n\t\thandshakeIdleTimeout = config.HandshakeIdleTimeout\n\t}\n\tidleTimeout := protocol.DefaultIdleTimeout\n\tif config.MaxIdleTimeout != 0 {\n\t\tidleTimeout = config.MaxIdleTimeout\n\t}\n\tinitialStreamReceiveWindow := config.InitialStreamReceiveWindow\n\tif initialStreamReceiveWindow == 0 {\n\t\tinitialStreamReceiveWindow = protocol.DefaultInitialMaxStreamData\n\t}\n\tmaxStreamReceiveWindow := config.MaxStreamReceiveWindow\n\tif maxStreamReceiveWindow == 0 {\n\t\tmaxStreamReceiveWindow = protocol.DefaultMaxReceiveStreamFlowControlWindow\n\t}\n\tinitialConnectionReceiveWindow := config.InitialConnectionReceiveWindow\n\tif initialConnectionReceiveWindow == 0 {\n\t\tinitialConnectionReceiveWindow = protocol.DefaultInitialMaxData\n\t}\n\tmaxConnectionReceiveWindow := config.MaxConnectionReceiveWindow\n\tif maxConnectionReceiveWindow == 0 {\n\t\tmaxConnectionReceiveWindow = protocol.DefaultMaxReceiveConnectionFlowControlWindow\n\t}\n\tmaxIncomingStreams := config.MaxIncomingStreams\n\tif maxIncomingStreams == 0 {\n\t\tmaxIncomingStreams = protocol.DefaultMaxIncomingStreams\n\t} else if maxIncomingStreams < 0 {\n\t\tmaxIncomingStreams = 0\n\t}\n\tmaxIncomingUniStreams := config.MaxIncomingUniStreams\n\tif maxIncomingUniStreams == 0 {\n\t\tmaxIncomingUniStreams = protocol.DefaultMaxIncomingUniStreams\n\t} else if maxIncomingUniStreams < 0 {\n\t\tmaxIncomingUniStreams = 0\n\t}\n\tinitialPacketSize := config.InitialPacketSize\n\tif initialPacketSize == 0 {\n\t\tinitialPacketSize = protocol.InitialPacketSize\n\t}\n\n\treturn &Config{\n\t\tGetConfigForClient:             config.GetConfigForClient,\n\t\tVersions:                       versions,\n\t\tHandshakeIdleTimeout:           handshakeIdleTimeout,\n\t\tMaxIdleTimeout:                 idleTimeout,\n\t\tKeepAlivePeriod:                config.KeepAlivePeriod,\n\t\tInitialStreamReceiveWindow:     initialStreamReceiveWindow,\n\t\tMaxStreamReceiveWindow:         maxStreamReceiveWindow,\n\t\tInitialConnectionReceiveWindow: initialConnectionReceiveWindow,\n\t\tMaxConnectionReceiveWindow:     maxConnectionReceiveWindow,\n\t\tAllowConnectionWindowIncrease:  config.AllowConnectionWindowIncrease,\n\t\tMaxIncomingStreams:             maxIncomingStreams,\n\t\tMaxIncomingUniStreams:          maxIncomingUniStreams,\n\t\tTokenStore:                     config.TokenStore,\n\t\tEnableDatagrams:                config.EnableDatagrams,\n\t\tInitialPacketSize:              initialPacketSize,\n\t\tDisablePathMTUDiscovery:        config.DisablePathMTUDiscovery,\n\t\tAllow0RTT:                      config.Allow0RTT,\n\t\tTracer:                         config.Tracer,\n\t}\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 6.1591796875,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/logging\"\n\t\"github.com/quic-go/quic-go/quicvarint\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestConfigValidation(t *testing.T) {\n\tt.Run(\"nil config\", func(t *testing.T) {\n\t\trequire.NoError(t, validateConfig(nil))\n\t})\n\n\tt.Run(\"config with a few values set\", func(t *testing.T) {\n\t\tconf := populateConfig(&Config{\n\t\t\tMaxIncomingStreams:     5,\n\t\t\tMaxStreamReceiveWindow: 10,\n\t\t})\n\t\trequire.NoError(t, validateConfig(conf))\n\t\trequire.Equal(t, int64(5), conf.MaxIncomingStreams)\n\t\trequire.Equal(t, uint64(10), conf.MaxStreamReceiveWindow)\n\t})\n\n\tt.Run(\"stream limits\", func(t *testing.T) {\n\t\tconf := &Config{\n\t\t\tMaxIncomingStreams:    1<<60 + 1,\n\t\t\tMaxIncomingUniStreams: 1<<60 + 2,\n\t\t}\n\t\trequire.NoError(t, validateConfig(conf))\n\t\trequire.Equal(t, int64(1<<60), conf.MaxIncomingStreams)\n\t\trequire.Equal(t, int64(1<<60), conf.MaxIncomingUniStreams)\n\t})\n\n\tt.Run(\"flow control windows\", func(t *testing.T) {\n\t\tconf := &Config{\n\t\t\tMaxStreamReceiveWindow:     quicvarint.Max + 1,\n\t\t\tMaxConnectionReceiveWindow: quicvarint.Max + 2,\n\t\t}\n\t\trequire.NoError(t, validateConfig(conf))\n\t\trequire.Equal(t, uint64(quicvarint.Max), conf.MaxStreamReceiveWindow)\n\t\trequire.Equal(t, uint64(quicvarint.Max), conf.MaxConnectionReceiveWindow)\n\t})\n\n\tt.Run(\"initial packet size\", func(t *testing.T) {\n\t\t// not set\n\t\tconf := &Config{InitialPacketSize: 0}\n\t\trequire.NoError(t, validateConfig(conf))\n\t\trequire.Zero(t, conf.InitialPacketSize)\n\n\t\t// too small\n\t\tconf = &Config{InitialPacketSize: 10}\n\t\trequire.NoError(t, validateConfig(conf))\n\t\trequire.Equal(t, uint16(1200), conf.InitialPacketSize)\n\n\t\t// too large\n\t\tconf = &Config{InitialPacketSize: protocol.MaxPacketBufferSize + 1}\n\t\trequire.NoError(t, validateConfig(conf))\n\t\trequire.Equal(t, uint16(protocol.MaxPacketBufferSize), conf.InitialPacketSize)\n\t})\n}\n\nfunc TestConfigHandshakeIdleTimeout(t *testing.T) {\n\tc := &Config{HandshakeIdleTimeout: time.Second * 11 / 2}\n\trequire.Equal(t, 11*time.Second, c.handshakeTimeout())\n}\n\nfunc configWithNonZeroNonFunctionFields(t *testing.T) *Config {\n\tt.Helper()\n\tc := &Config{}\n\tv := reflect.ValueOf(c).Elem()\n\n\ttyp := v.Type()\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\tf := v.Field(i)\n\t\tif !f.CanSet() {\n\t\t\t// unexported field; not cloned.\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch fn := typ.Field(i).Name; fn {\n\t\tcase \"GetConfigForClient\", \"RequireAddressValidation\", \"GetLogWriter\", \"AllowConnectionWindowIncrease\", \"Tracer\":\n\t\t\t// Can't compare functions.\n\t\tcase \"Versions\":\n\t\t\tf.Set(reflect.ValueOf([]Version{1, 2, 3}))\n\t\tcase \"ConnectionIDLength\":\n\t\t\tf.Set(reflect.ValueOf(8))\n\t\tcase \"ConnectionIDGenerator\":\n\t\t\tf.Set(reflect.ValueOf(&protocol.DefaultConnectionIDGenerator{ConnLen: protocol.DefaultConnectionIDLength}))\n\t\tcase \"HandshakeIdleTimeout\":\n\t\t\tf.Set(reflect.ValueOf(time.Second))\n\t\tcase \"MaxIdleTimeout\":\n\t\t\tf.Set(reflect.ValueOf(time.Hour))\n\t\tcase \"TokenStore\":\n\t\t\tf.Set(reflect.ValueOf(NewLRUTokenStore(2, 3)))\n\t\tcase \"InitialStreamReceiveWindow\":\n\t\t\tf.Set(reflect.ValueOf(uint64(1234)))\n\t\tcase \"MaxStreamReceiveWindow\":\n\t\t\tf.Set(reflect.ValueOf(uint64(9)))\n\t\tcase \"InitialConnectionReceiveWindow\":\n\t\t\tf.Set(reflect.ValueOf(uint64(4321)))\n\t\tcase \"MaxConnectionReceiveWindow\":\n\t\t\tf.Set(reflect.ValueOf(uint64(10)))\n\t\tcase \"MaxIncomingStreams\":\n\t\t\tf.Set(reflect.ValueOf(int64(11)))\n\t\tcase \"MaxIncomingUniStreams\":\n\t\t\tf.Set(reflect.ValueOf(int64(12)))\n\t\tcase \"StatelessResetKey\":\n\t\t\tf.Set(reflect.ValueOf(&StatelessResetKey{1, 2, 3, 4}))\n\t\tcase \"KeepAlivePeriod\":\n\t\t\tf.Set(reflect.ValueOf(time.Second))\n\t\tcase \"EnableDatagrams\":\n\t\t\tf.Set(reflect.ValueOf(true))\n\t\tcase \"DisableVersionNegotiationPackets\":\n\t\t\tf.Set(reflect.ValueOf(true))\n\t\tcase \"InitialPacketSize\":\n\t\t\tf.Set(reflect.ValueOf(uint16(1350)))\n\t\tcase \"DisablePathMTUDiscovery\":\n\t\t\tf.Set(reflect.ValueOf(true))\n\t\tcase \"Allow0RTT\":\n\t\t\tf.Set(reflect.ValueOf(true))\n\t\tdefault:\n\t\t\tt.Fatalf(\"all fields must be accounted for, but saw unknown field %q\", fn)\n\t\t}\n\t}\n\treturn c\n}\n\nfunc TestConfigCloning(t *testing.T) {\n\tt.Run(\"function fields\", func(t *testing.T) {\n\t\tvar calledAllowConnectionWindowIncrease, calledTracer bool\n\t\tc1 := &Config{\n\t\t\tGetConfigForClient:            func(info *ClientHelloInfo) (*Config, error) { return nil, errors.New(\"nope\") },\n\t\t\tAllowConnectionWindowIncrease: func(Connection, uint64) bool { calledAllowConnectionWindowIncrease = true; return true },\n\t\t\tTracer: func(context.Context, logging.Perspective, ConnectionID) *logging.ConnectionTracer {\n\t\t\t\tcalledTracer = true\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\t\tc2 := c1.Clone()\n\t\tc2.AllowConnectionWindowIncrease(nil, 1234)\n\t\trequire.True(t, calledAllowConnectionWindowIncrease)\n\t\t_, err := c2.GetConfigForClient(&ClientHelloInfo{})\n\t\trequire.EqualError(t, err, \"nope\")\n\t\tc2.Tracer(context.Background(), logging.PerspectiveClient, protocol.ConnectionID{})\n\t\trequire.True(t, calledTracer)\n\t})\n\n\tt.Run(\"clones non-function fields\", func(t *testing.T) {\n\t\tc := configWithNonZeroNonFunctionFields(t)\n\t\trequire.Equal(t, c, c.Clone())\n\t})\n\n\tt.Run(\"returns a copy\", func(t *testing.T) {\n\t\tc1 := &Config{MaxIncomingStreams: 100}\n\t\tc2 := c1.Clone()\n\t\tc2.MaxIncomingStreams = 200\n\t\trequire.EqualValues(t, 100, c1.MaxIncomingStreams)\n\t})\n}\n\nfunc TestConfigDefaultValues(t *testing.T) {\n\t// if set, the values should be copied\n\tc := configWithNonZeroNonFunctionFields(t)\n\trequire.Equal(t, c, populateConfig(c))\n\n\t// if not set, some fields use default values\n\tc = populateConfig(&Config{})\n\trequire.Equal(t, protocol.SupportedVersions, c.Versions)\n\trequire.Equal(t, protocol.DefaultHandshakeIdleTimeout, c.HandshakeIdleTimeout)\n\trequire.EqualValues(t, protocol.DefaultInitialMaxStreamData, c.InitialStreamReceiveWindow)\n\trequire.EqualValues(t, protocol.DefaultMaxReceiveStreamFlowControlWindow, c.MaxStreamReceiveWindow)\n\trequire.EqualValues(t, protocol.DefaultInitialMaxData, c.InitialConnectionReceiveWindow)\n\trequire.EqualValues(t, protocol.DefaultMaxReceiveConnectionFlowControlWindow, c.MaxConnectionReceiveWindow)\n\trequire.EqualValues(t, protocol.DefaultMaxIncomingStreams, c.MaxIncomingStreams)\n\trequire.EqualValues(t, protocol.DefaultMaxIncomingUniStreams, c.MaxIncomingUniStreams)\n\trequire.False(t, c.DisablePathMTUDiscovery)\n\trequire.Nil(t, c.GetConfigForClient)\n}\n"
        },
        {
          "name": "conn_id_generator.go",
          "type": "blob",
          "size": 4.3857421875,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype connIDGenerator struct {\n\tgenerator  ConnectionIDGenerator\n\thighestSeq uint64\n\n\tactiveSrcConnIDs        map[uint64]protocol.ConnectionID\n\tinitialClientDestConnID *protocol.ConnectionID // nil for the client\n\n\taddConnectionID        func(protocol.ConnectionID)\n\tgetStatelessResetToken func(protocol.ConnectionID) protocol.StatelessResetToken\n\tremoveConnectionID     func(protocol.ConnectionID)\n\tretireConnectionID     func(protocol.ConnectionID)\n\treplaceWithClosed      func([]protocol.ConnectionID, []byte)\n\tqueueControlFrame      func(wire.Frame)\n}\n\nfunc newConnIDGenerator(\n\tinitialConnectionID protocol.ConnectionID,\n\tinitialClientDestConnID *protocol.ConnectionID, // nil for the client\n\taddConnectionID func(protocol.ConnectionID),\n\tgetStatelessResetToken func(protocol.ConnectionID) protocol.StatelessResetToken,\n\tremoveConnectionID func(protocol.ConnectionID),\n\tretireConnectionID func(protocol.ConnectionID),\n\treplaceWithClosed func([]protocol.ConnectionID, []byte),\n\tqueueControlFrame func(wire.Frame),\n\tgenerator ConnectionIDGenerator,\n) *connIDGenerator {\n\tm := &connIDGenerator{\n\t\tgenerator:              generator,\n\t\tactiveSrcConnIDs:       make(map[uint64]protocol.ConnectionID),\n\t\taddConnectionID:        addConnectionID,\n\t\tgetStatelessResetToken: getStatelessResetToken,\n\t\tremoveConnectionID:     removeConnectionID,\n\t\tretireConnectionID:     retireConnectionID,\n\t\treplaceWithClosed:      replaceWithClosed,\n\t\tqueueControlFrame:      queueControlFrame,\n\t}\n\tm.activeSrcConnIDs[0] = initialConnectionID\n\tm.initialClientDestConnID = initialClientDestConnID\n\treturn m\n}\n\nfunc (m *connIDGenerator) SetMaxActiveConnIDs(limit uint64) error {\n\tif m.generator.ConnectionIDLen() == 0 {\n\t\treturn nil\n\t}\n\t// The active_connection_id_limit transport parameter is the number of\n\t// connection IDs the peer will store. This limit includes the connection ID\n\t// used during the handshake, and the one sent in the preferred_address\n\t// transport parameter.\n\t// We currently don't send the preferred_address transport parameter,\n\t// so we can issue (limit - 1) connection IDs.\n\tfor i := uint64(len(m.activeSrcConnIDs)); i < min(limit, protocol.MaxIssuedConnectionIDs); i++ {\n\t\tif err := m.issueNewConnID(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *connIDGenerator) Retire(seq uint64, sentWithDestConnID protocol.ConnectionID) error {\n\tif seq > m.highestSeq {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: fmt.Sprintf(\"retired connection ID %d (highest issued: %d)\", seq, m.highestSeq),\n\t\t}\n\t}\n\tconnID, ok := m.activeSrcConnIDs[seq]\n\t// We might already have deleted this connection ID, if this is a duplicate frame.\n\tif !ok {\n\t\treturn nil\n\t}\n\tif connID == sentWithDestConnID {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: fmt.Sprintf(\"retired connection ID %d (%s), which was used as the Destination Connection ID on this packet\", seq, connID),\n\t\t}\n\t}\n\tm.retireConnectionID(connID)\n\tdelete(m.activeSrcConnIDs, seq)\n\t// Don't issue a replacement for the initial connection ID.\n\tif seq == 0 {\n\t\treturn nil\n\t}\n\treturn m.issueNewConnID()\n}\n\nfunc (m *connIDGenerator) issueNewConnID() error {\n\tconnID, err := m.generator.GenerateConnectionID()\n\tif err != nil {\n\t\treturn err\n\t}\n\tm.activeSrcConnIDs[m.highestSeq+1] = connID\n\tm.addConnectionID(connID)\n\tm.queueControlFrame(&wire.NewConnectionIDFrame{\n\t\tSequenceNumber:      m.highestSeq + 1,\n\t\tConnectionID:        connID,\n\t\tStatelessResetToken: m.getStatelessResetToken(connID),\n\t})\n\tm.highestSeq++\n\treturn nil\n}\n\nfunc (m *connIDGenerator) SetHandshakeComplete() {\n\tif m.initialClientDestConnID != nil {\n\t\tm.retireConnectionID(*m.initialClientDestConnID)\n\t\tm.initialClientDestConnID = nil\n\t}\n}\n\nfunc (m *connIDGenerator) RemoveAll() {\n\tif m.initialClientDestConnID != nil {\n\t\tm.removeConnectionID(*m.initialClientDestConnID)\n\t}\n\tfor _, connID := range m.activeSrcConnIDs {\n\t\tm.removeConnectionID(connID)\n\t}\n}\n\nfunc (m *connIDGenerator) ReplaceWithClosed(connClose []byte) {\n\tconnIDs := make([]protocol.ConnectionID, 0, len(m.activeSrcConnIDs)+1)\n\tif m.initialClientDestConnID != nil {\n\t\tconnIDs = append(connIDs, *m.initialClientDestConnID)\n\t}\n\tfor _, connID := range m.activeSrcConnIDs {\n\t\tconnIDs = append(connIDs, connID)\n\t}\n\tm.replaceWithClosed(connIDs, connClose)\n}\n"
        },
        {
          "name": "conn_id_generator_test.go",
          "type": "blob",
          "size": 7.2294921875,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Connection ID Generator\", func() {\n\tvar (\n\t\taddedConnIDs       []protocol.ConnectionID\n\t\tretiredConnIDs     []protocol.ConnectionID\n\t\tremovedConnIDs     []protocol.ConnectionID\n\t\treplacedWithClosed []protocol.ConnectionID\n\t\tqueuedFrames       []wire.Frame\n\t\tg                  *connIDGenerator\n\t)\n\tinitialConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7})\n\tinitialClientDestConnID := protocol.ParseConnectionID([]byte{0xa, 0xb, 0xc, 0xd, 0xe})\n\n\tconnIDToToken := func(c protocol.ConnectionID) protocol.StatelessResetToken {\n\t\tb := c.Bytes()[0]\n\t\treturn protocol.StatelessResetToken{b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b}\n\t}\n\n\tBeforeEach(func() {\n\t\taddedConnIDs = nil\n\t\tretiredConnIDs = nil\n\t\tremovedConnIDs = nil\n\t\tqueuedFrames = nil\n\t\treplacedWithClosed = nil\n\t\tg = newConnIDGenerator(\n\t\t\tinitialConnID,\n\t\t\t&initialClientDestConnID,\n\t\t\tfunc(c protocol.ConnectionID) { addedConnIDs = append(addedConnIDs, c) },\n\t\t\tconnIDToToken,\n\t\t\tfunc(c protocol.ConnectionID) { removedConnIDs = append(removedConnIDs, c) },\n\t\t\tfunc(c protocol.ConnectionID) { retiredConnIDs = append(retiredConnIDs, c) },\n\t\t\tfunc(cs []protocol.ConnectionID, _ []byte) { replacedWithClosed = append(replacedWithClosed, cs...) },\n\t\t\tfunc(f wire.Frame) { queuedFrames = append(queuedFrames, f) },\n\t\t\t&protocol.DefaultConnectionIDGenerator{ConnLen: initialConnID.Len()},\n\t\t)\n\t})\n\n\tIt(\"issues new connection IDs\", func() {\n\t\tExpect(g.SetMaxActiveConnIDs(4)).To(Succeed())\n\t\tExpect(retiredConnIDs).To(BeEmpty())\n\t\tExpect(addedConnIDs).To(HaveLen(3))\n\t\tfor i := 0; i < len(addedConnIDs)-1; i++ {\n\t\t\tExpect(addedConnIDs[i]).ToNot(Equal(addedConnIDs[i+1]))\n\t\t}\n\t\tExpect(queuedFrames).To(HaveLen(3))\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tf := queuedFrames[i]\n\t\t\tExpect(f).To(BeAssignableToTypeOf(&wire.NewConnectionIDFrame{}))\n\t\t\tnf := f.(*wire.NewConnectionIDFrame)\n\t\t\tExpect(nf.SequenceNumber).To(BeEquivalentTo(i + 1))\n\t\t\tExpect(nf.ConnectionID.Len()).To(Equal(7))\n\t\t\tExpect(nf.StatelessResetToken).To(Equal(connIDToToken(nf.ConnectionID)))\n\t\t}\n\t})\n\n\tIt(\"limits the number of connection IDs that it issues\", func() {\n\t\tExpect(g.SetMaxActiveConnIDs(9999999)).To(Succeed())\n\t\tExpect(retiredConnIDs).To(BeEmpty())\n\t\tExpect(addedConnIDs).To(HaveLen(protocol.MaxIssuedConnectionIDs - 1))\n\t\tExpect(queuedFrames).To(HaveLen(protocol.MaxIssuedConnectionIDs - 1))\n\t})\n\n\t// SetMaxActiveConnIDs is called twice when dialing a 0-RTT connection:\n\t// once for the restored from the old connections, once when we receive the transport parameters\n\tContext(\"dealing with 0-RTT\", func() {\n\t\tIt(\"doesn't issue new connection IDs when SetMaxActiveConnIDs is called with the same value\", func() {\n\t\t\tExpect(g.SetMaxActiveConnIDs(4)).To(Succeed())\n\t\t\tExpect(queuedFrames).To(HaveLen(3))\n\t\t\tqueuedFrames = nil\n\t\t\tExpect(g.SetMaxActiveConnIDs(4)).To(Succeed())\n\t\t\tExpect(queuedFrames).To(BeEmpty())\n\t\t})\n\n\t\tIt(\"issues more connection IDs if the server allows a higher limit on the resumed connection\", func() {\n\t\t\tExpect(g.SetMaxActiveConnIDs(3)).To(Succeed())\n\t\t\tExpect(queuedFrames).To(HaveLen(2))\n\t\t\tqueuedFrames = nil\n\t\t\tExpect(g.SetMaxActiveConnIDs(6)).To(Succeed())\n\t\t\tExpect(queuedFrames).To(HaveLen(3))\n\t\t})\n\n\t\tIt(\"issues more connection IDs if the server allows a higher limit on the resumed connection, when connection IDs were retired in between\", func() {\n\t\t\tExpect(g.SetMaxActiveConnIDs(3)).To(Succeed())\n\t\t\tExpect(queuedFrames).To(HaveLen(2))\n\t\t\tqueuedFrames = nil\n\t\t\tg.Retire(1, protocol.ConnectionID{})\n\t\t\tExpect(queuedFrames).To(HaveLen(1))\n\t\t\tqueuedFrames = nil\n\t\t\tExpect(g.SetMaxActiveConnIDs(6)).To(Succeed())\n\t\t\tExpect(queuedFrames).To(HaveLen(3))\n\t\t})\n\t})\n\n\tIt(\"errors if the peers tries to retire a connection ID that wasn't yet issued\", func() {\n\t\tExpect(g.Retire(1, protocol.ConnectionID{})).To(MatchError(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"retired connection ID 1 (highest issued: 0)\",\n\t\t}))\n\t})\n\n\tIt(\"errors if the peers tries to retire a connection ID in a packet with that connection ID\", func() {\n\t\tExpect(g.SetMaxActiveConnIDs(4)).To(Succeed())\n\t\tExpect(queuedFrames).ToNot(BeEmpty())\n\t\tExpect(queuedFrames[0]).To(BeAssignableToTypeOf(&wire.NewConnectionIDFrame{}))\n\t\tf := queuedFrames[0].(*wire.NewConnectionIDFrame)\n\t\tExpect(g.Retire(f.SequenceNumber, f.ConnectionID)).To(MatchError(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: fmt.Sprintf(\"retired connection ID %d (%s), which was used as the Destination Connection ID on this packet\", f.SequenceNumber, f.ConnectionID),\n\t\t}))\n\t})\n\n\tIt(\"issues new connection IDs, when old ones are retired\", func() {\n\t\tExpect(g.SetMaxActiveConnIDs(5)).To(Succeed())\n\t\tqueuedFrames = nil\n\t\tExpect(retiredConnIDs).To(BeEmpty())\n\t\tExpect(g.Retire(3, protocol.ConnectionID{})).To(Succeed())\n\t\tExpect(queuedFrames).To(HaveLen(1))\n\t\tExpect(queuedFrames[0]).To(BeAssignableToTypeOf(&wire.NewConnectionIDFrame{}))\n\t\tnf := queuedFrames[0].(*wire.NewConnectionIDFrame)\n\t\tExpect(nf.SequenceNumber).To(BeEquivalentTo(5))\n\t\tExpect(nf.ConnectionID.Len()).To(Equal(7))\n\t})\n\n\tIt(\"retires the initial connection ID\", func() {\n\t\tExpect(g.Retire(0, protocol.ConnectionID{})).To(Succeed())\n\t\tExpect(removedConnIDs).To(BeEmpty())\n\t\tExpect(retiredConnIDs).To(HaveLen(1))\n\t\tExpect(retiredConnIDs[0]).To(Equal(initialConnID))\n\t\tExpect(addedConnIDs).To(BeEmpty())\n\t})\n\n\tIt(\"handles duplicate retirements\", func() {\n\t\tExpect(g.SetMaxActiveConnIDs(11)).To(Succeed())\n\t\tqueuedFrames = nil\n\t\tExpect(retiredConnIDs).To(BeEmpty())\n\t\tExpect(g.Retire(5, protocol.ConnectionID{})).To(Succeed())\n\t\tExpect(retiredConnIDs).To(HaveLen(1))\n\t\tExpect(queuedFrames).To(HaveLen(1))\n\t\tExpect(g.Retire(5, protocol.ConnectionID{})).To(Succeed())\n\t\tExpect(retiredConnIDs).To(HaveLen(1))\n\t\tExpect(queuedFrames).To(HaveLen(1))\n\t})\n\n\tIt(\"retires the client's initial destination connection ID when the handshake completes\", func() {\n\t\tg.SetHandshakeComplete()\n\t\tExpect(retiredConnIDs).To(HaveLen(1))\n\t\tExpect(retiredConnIDs[0]).To(Equal(initialClientDestConnID))\n\t})\n\n\tIt(\"removes all connection IDs\", func() {\n\t\tExpect(g.SetMaxActiveConnIDs(5)).To(Succeed())\n\t\tExpect(queuedFrames).To(HaveLen(4))\n\t\tg.RemoveAll()\n\t\tExpect(removedConnIDs).To(HaveLen(6)) // initial conn ID, initial client dest conn id, and newly issued ones\n\t\tExpect(removedConnIDs).To(ContainElement(initialConnID))\n\t\tExpect(removedConnIDs).To(ContainElement(initialClientDestConnID))\n\t\tfor _, f := range queuedFrames {\n\t\t\tnf := f.(*wire.NewConnectionIDFrame)\n\t\t\tExpect(removedConnIDs).To(ContainElement(nf.ConnectionID))\n\t\t}\n\t})\n\n\tIt(\"replaces with a closed connection for all connection IDs\", func() {\n\t\tExpect(g.SetMaxActiveConnIDs(5)).To(Succeed())\n\t\tExpect(queuedFrames).To(HaveLen(4))\n\t\tg.ReplaceWithClosed([]byte(\"foobar\"))\n\t\tExpect(replacedWithClosed).To(HaveLen(6)) // initial conn ID, initial client dest conn id, and newly issued ones\n\t\tExpect(replacedWithClosed).To(ContainElement(initialClientDestConnID))\n\t\tExpect(replacedWithClosed).To(ContainElement(initialConnID))\n\t\tfor _, f := range queuedFrames {\n\t\t\tnf := f.(*wire.NewConnectionIDFrame)\n\t\t\tExpect(replacedWithClosed).To(ContainElement(nf.ConnectionID))\n\t\t}\n\t})\n})\n"
        },
        {
          "name": "conn_id_manager.go",
          "type": "blob",
          "size": 6.64453125,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\tlist \"github.com/quic-go/quic-go/internal/utils/linkedlist\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype newConnID struct {\n\tSequenceNumber      uint64\n\tConnectionID        protocol.ConnectionID\n\tStatelessResetToken protocol.StatelessResetToken\n}\n\ntype connIDManager struct {\n\tqueue list.List[newConnID]\n\n\thandshakeComplete         bool\n\tactiveSequenceNumber      uint64\n\thighestRetired            uint64\n\tactiveConnectionID        protocol.ConnectionID\n\tactiveStatelessResetToken *protocol.StatelessResetToken\n\n\t// We change the connection ID after sending on average\n\t// protocol.PacketsPerConnectionID packets. The actual value is randomized\n\t// hide the packet loss rate from on-path observers.\n\trand                   utils.Rand\n\tpacketsSinceLastChange uint32\n\tpacketsPerConnectionID uint32\n\n\taddStatelessResetToken    func(protocol.StatelessResetToken)\n\tremoveStatelessResetToken func(protocol.StatelessResetToken)\n\tqueueControlFrame         func(wire.Frame)\n}\n\nfunc newConnIDManager(\n\tinitialDestConnID protocol.ConnectionID,\n\taddStatelessResetToken func(protocol.StatelessResetToken),\n\tremoveStatelessResetToken func(protocol.StatelessResetToken),\n\tqueueControlFrame func(wire.Frame),\n) *connIDManager {\n\treturn &connIDManager{\n\t\tactiveConnectionID:        initialDestConnID,\n\t\taddStatelessResetToken:    addStatelessResetToken,\n\t\tremoveStatelessResetToken: removeStatelessResetToken,\n\t\tqueueControlFrame:         queueControlFrame,\n\t}\n}\n\nfunc (h *connIDManager) AddFromPreferredAddress(connID protocol.ConnectionID, resetToken protocol.StatelessResetToken) error {\n\treturn h.addConnectionID(1, connID, resetToken)\n}\n\nfunc (h *connIDManager) Add(f *wire.NewConnectionIDFrame) error {\n\tif err := h.add(f); err != nil {\n\t\treturn err\n\t}\n\tif h.queue.Len() >= protocol.MaxActiveConnectionIDs {\n\t\treturn &qerr.TransportError{ErrorCode: qerr.ConnectionIDLimitError}\n\t}\n\treturn nil\n}\n\nfunc (h *connIDManager) add(f *wire.NewConnectionIDFrame) error {\n\t// If the NEW_CONNECTION_ID frame is reordered, such that its sequence number is smaller than the currently active\n\t// connection ID or if it was already retired, send the RETIRE_CONNECTION_ID frame immediately.\n\tif f.SequenceNumber < h.activeSequenceNumber || f.SequenceNumber < h.highestRetired {\n\t\th.queueControlFrame(&wire.RetireConnectionIDFrame{\n\t\t\tSequenceNumber: f.SequenceNumber,\n\t\t})\n\t\treturn nil\n\t}\n\n\t// Retire elements in the queue.\n\t// Doesn't retire the active connection ID.\n\tif f.RetirePriorTo > h.highestRetired {\n\t\tvar next *list.Element[newConnID]\n\t\tfor el := h.queue.Front(); el != nil; el = next {\n\t\t\tif el.Value.SequenceNumber >= f.RetirePriorTo {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tnext = el.Next()\n\t\t\th.queueControlFrame(&wire.RetireConnectionIDFrame{\n\t\t\t\tSequenceNumber: el.Value.SequenceNumber,\n\t\t\t})\n\t\t\th.queue.Remove(el)\n\t\t}\n\t\th.highestRetired = f.RetirePriorTo\n\t}\n\n\tif f.SequenceNumber == h.activeSequenceNumber {\n\t\treturn nil\n\t}\n\n\tif err := h.addConnectionID(f.SequenceNumber, f.ConnectionID, f.StatelessResetToken); err != nil {\n\t\treturn err\n\t}\n\n\t// Retire the active connection ID, if necessary.\n\tif h.activeSequenceNumber < f.RetirePriorTo {\n\t\t// The queue is guaranteed to have at least one element at this point.\n\t\th.updateConnectionID()\n\t}\n\treturn nil\n}\n\nfunc (h *connIDManager) addConnectionID(seq uint64, connID protocol.ConnectionID, resetToken protocol.StatelessResetToken) error {\n\t// insert a new element at the end\n\tif h.queue.Len() == 0 || h.queue.Back().Value.SequenceNumber < seq {\n\t\th.queue.PushBack(newConnID{\n\t\t\tSequenceNumber:      seq,\n\t\t\tConnectionID:        connID,\n\t\t\tStatelessResetToken: resetToken,\n\t\t})\n\t\treturn nil\n\t}\n\t// insert a new element somewhere in the middle\n\tfor el := h.queue.Front(); el != nil; el = el.Next() {\n\t\tif el.Value.SequenceNumber == seq {\n\t\t\tif el.Value.ConnectionID != connID {\n\t\t\t\treturn fmt.Errorf(\"received conflicting connection IDs for sequence number %d\", seq)\n\t\t\t}\n\t\t\tif el.Value.StatelessResetToken != resetToken {\n\t\t\t\treturn fmt.Errorf(\"received conflicting stateless reset tokens for sequence number %d\", seq)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tif el.Value.SequenceNumber > seq {\n\t\t\th.queue.InsertBefore(newConnID{\n\t\t\t\tSequenceNumber:      seq,\n\t\t\t\tConnectionID:        connID,\n\t\t\t\tStatelessResetToken: resetToken,\n\t\t\t}, el)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (h *connIDManager) updateConnectionID() {\n\th.queueControlFrame(&wire.RetireConnectionIDFrame{\n\t\tSequenceNumber: h.activeSequenceNumber,\n\t})\n\th.highestRetired = max(h.highestRetired, h.activeSequenceNumber)\n\tif h.activeStatelessResetToken != nil {\n\t\th.removeStatelessResetToken(*h.activeStatelessResetToken)\n\t}\n\n\tfront := h.queue.Remove(h.queue.Front())\n\th.activeSequenceNumber = front.SequenceNumber\n\th.activeConnectionID = front.ConnectionID\n\th.activeStatelessResetToken = &front.StatelessResetToken\n\th.packetsSinceLastChange = 0\n\th.packetsPerConnectionID = protocol.PacketsPerConnectionID/2 + uint32(h.rand.Int31n(protocol.PacketsPerConnectionID))\n\th.addStatelessResetToken(*h.activeStatelessResetToken)\n}\n\nfunc (h *connIDManager) Close() {\n\tif h.activeStatelessResetToken != nil {\n\t\th.removeStatelessResetToken(*h.activeStatelessResetToken)\n\t}\n}\n\n// is called when the server performs a Retry\n// and when the server changes the connection ID in the first Initial sent\nfunc (h *connIDManager) ChangeInitialConnID(newConnID protocol.ConnectionID) {\n\tif h.activeSequenceNumber != 0 {\n\t\tpanic(\"expected first connection ID to have sequence number 0\")\n\t}\n\th.activeConnectionID = newConnID\n}\n\n// is called when the server provides a stateless reset token in the transport parameters\nfunc (h *connIDManager) SetStatelessResetToken(token protocol.StatelessResetToken) {\n\tif h.activeSequenceNumber != 0 {\n\t\tpanic(\"expected first connection ID to have sequence number 0\")\n\t}\n\th.activeStatelessResetToken = &token\n\th.addStatelessResetToken(token)\n}\n\nfunc (h *connIDManager) SentPacket() {\n\th.packetsSinceLastChange++\n}\n\nfunc (h *connIDManager) shouldUpdateConnID() bool {\n\tif !h.handshakeComplete {\n\t\treturn false\n\t}\n\t// initiate the first change as early as possible (after handshake completion)\n\tif h.queue.Len() > 0 && h.activeSequenceNumber == 0 {\n\t\treturn true\n\t}\n\t// For later changes, only change if\n\t// 1. The queue of connection IDs is filled more than 50%.\n\t// 2. We sent at least PacketsPerConnectionID packets\n\treturn 2*h.queue.Len() >= protocol.MaxActiveConnectionIDs &&\n\t\th.packetsSinceLastChange >= h.packetsPerConnectionID\n}\n\nfunc (h *connIDManager) Get() protocol.ConnectionID {\n\tif h.shouldUpdateConnID() {\n\t\th.updateConnectionID()\n\t}\n\treturn h.activeConnectionID\n}\n\nfunc (h *connIDManager) SetHandshakeComplete() {\n\th.handshakeComplete = true\n}\n"
        },
        {
          "name": "conn_id_manager_test.go",
          "type": "blob",
          "size": 14.5712890625,
          "content": "package quic\n\nimport (\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Connection ID Manager\", func() {\n\tvar (\n\t\tm             *connIDManager\n\t\tframeQueue    []wire.Frame\n\t\ttokenAdded    *protocol.StatelessResetToken\n\t\tremovedTokens []protocol.StatelessResetToken\n\t)\n\tinitialConnID := protocol.ParseConnectionID([]byte{0, 0, 0, 0})\n\n\tBeforeEach(func() {\n\t\tframeQueue = nil\n\t\ttokenAdded = nil\n\t\tremovedTokens = nil\n\t\tm = newConnIDManager(\n\t\t\tinitialConnID,\n\t\t\tfunc(token protocol.StatelessResetToken) { tokenAdded = &token },\n\t\t\tfunc(token protocol.StatelessResetToken) { removedTokens = append(removedTokens, token) },\n\t\t\tfunc(f wire.Frame,\n\t\t\t) {\n\t\t\t\tframeQueue = append(frameQueue, f)\n\t\t\t})\n\t})\n\n\tget := func() (protocol.ConnectionID, protocol.StatelessResetToken) {\n\t\tif m.queue.Len() == 0 {\n\t\t\treturn protocol.ConnectionID{}, protocol.StatelessResetToken{}\n\t\t}\n\t\tval := m.queue.Remove(m.queue.Front())\n\t\treturn val.ConnectionID, val.StatelessResetToken\n\t}\n\n\tIt(\"returns the initial connection ID\", func() {\n\t\tExpect(m.Get()).To(Equal(initialConnID))\n\t})\n\n\tIt(\"changes the initial connection ID\", func() {\n\t\tm.ChangeInitialConnID(protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5}))\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5})))\n\t})\n\n\tIt(\"sets the token for the first connection ID\", func() {\n\t\ttoken := protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\t\tm.SetStatelessResetToken(token)\n\t\tExpect(*m.activeStatelessResetToken).To(Equal(token))\n\t\tExpect(*tokenAdded).To(Equal(token))\n\t})\n\n\tIt(\"adds and gets connection IDs\", func() {\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      10,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{2, 3, 4, 5}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{0xe, 0xd, 0xc, 0xb, 0xa, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},\n\t\t})).To(Succeed())\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      4,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe},\n\t\t})).To(Succeed())\n\t\tc1, rt1 := get()\n\t\tExpect(c1).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t\tExpect(rt1).To(Equal(protocol.StatelessResetToken{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe}))\n\t\tc2, rt2 := get()\n\t\tExpect(c2).To(Equal(protocol.ParseConnectionID([]byte{2, 3, 4, 5})))\n\t\tExpect(rt2).To(Equal(protocol.StatelessResetToken{0xe, 0xd, 0xc, 0xb, 0xa, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}))\n\t\tc3, _ := get()\n\t\tExpect(c3).To(BeZero())\n\t})\n\n\tIt(\"accepts duplicates\", func() {\n\t\tf1 := &wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      1,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe},\n\t\t}\n\t\tf2 := &wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      1,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe},\n\t\t}\n\t\tExpect(m.Add(f1)).To(Succeed())\n\t\tExpect(m.Add(f2)).To(Succeed())\n\t\tc1, rt1 := get()\n\t\tExpect(c1).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t\tExpect(rt1).To(Equal(protocol.StatelessResetToken{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe}))\n\t\tc2, _ := get()\n\t\tExpect(c2).To(BeZero())\n\t})\n\n\tIt(\"ignores duplicates for the currently used connection ID\", func() {\n\t\tf := &wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      1,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe},\n\t\t}\n\t\tm.SetHandshakeComplete()\n\t\tExpect(m.Add(f)).To(Succeed())\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t\tc, _ := get()\n\t\tExpect(c).To(BeZero())\n\t\t// Now send the same connection ID again. It should not be queued.\n\t\tExpect(m.Add(f)).To(Succeed())\n\t\tc, _ = get()\n\t\tExpect(c).To(BeZero())\n\t})\n\n\tIt(\"rejects duplicates with different connection IDs\", func() {\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 42,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t})).To(Succeed())\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 42,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{2, 3, 4, 5}),\n\t\t})).To(MatchError(\"received conflicting connection IDs for sequence number 42\"))\n\t})\n\n\tIt(\"rejects duplicates with different connection IDs\", func() {\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      42,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe},\n\t\t})).To(Succeed())\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      42,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{0xe, 0xd, 0xc, 0xb, 0xa, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0},\n\t\t})).To(MatchError(\"received conflicting stateless reset tokens for sequence number 42\"))\n\t})\n\n\tIt(\"retires connection IDs\", func() {\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 10,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t})).To(Succeed())\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 13,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{2, 3, 4, 5}),\n\t\t})).To(Succeed())\n\t\tExpect(frameQueue).To(BeEmpty())\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tRetirePriorTo:  14,\n\t\t\tSequenceNumber: 17,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{3, 4, 5, 6}),\n\t\t})).To(Succeed())\n\t\tExpect(frameQueue).To(HaveLen(3))\n\t\tExpect(frameQueue[0].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeEquivalentTo(10))\n\t\tExpect(frameQueue[1].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeEquivalentTo(13))\n\t\tExpect(frameQueue[2].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeZero())\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{3, 4, 5, 6})))\n\t})\n\n\tIt(\"ignores reordered connection IDs, if their sequence number was already retired\", func() {\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 10,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tRetirePriorTo:  5,\n\t\t})).To(Succeed())\n\t\tExpect(frameQueue).To(HaveLen(1))\n\t\tExpect(frameQueue[0].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeZero())\n\t\tframeQueue = nil\n\t\t// If this NEW_CONNECTION_ID frame hadn't been reordered, we would have retired it before.\n\t\t// Make sure it gets retired immediately now.\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 4,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{4, 3, 2, 1}),\n\t\t})).To(Succeed())\n\t\tExpect(frameQueue).To(HaveLen(1))\n\t\tExpect(frameQueue[0].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeEquivalentTo(4))\n\t})\n\n\tIt(\"ignores reordered connection IDs, if their sequence number was already retired or less than active\", func() {\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 10,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t\t\tRetirePriorTo:  5,\n\t\t})).To(Succeed())\n\t\tExpect(frameQueue).To(HaveLen(1))\n\t\tExpect(frameQueue[0].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeZero())\n\t\tframeQueue = nil\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})))\n\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 9,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{0xde, 0xca, 0xfb, 0xad}),\n\t\t\tRetirePriorTo:  5,\n\t\t})).To(Succeed())\n\t\tExpect(frameQueue).To(HaveLen(1))\n\t\tExpect(frameQueue[0].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeEquivalentTo(9))\n\t})\n\n\tIt(\"accepts retransmissions for the connection ID that is in use\", func() {\n\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 1,\n\t\t\tConnectionID:   connID,\n\t\t})).To(Succeed())\n\t\tm.SetHandshakeComplete()\n\t\tExpect(frameQueue).To(BeEmpty())\n\t\tExpect(m.Get()).To(Equal(connID))\n\t\tExpect(frameQueue).To(HaveLen(1))\n\t\tExpect(frameQueue[0]).To(BeAssignableToTypeOf(&wire.RetireConnectionIDFrame{}))\n\t\tExpect(frameQueue[0].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeZero())\n\t\tframeQueue = nil\n\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 1,\n\t\t\tConnectionID:   connID,\n\t\t})).To(Succeed())\n\t\tExpect(frameQueue).To(BeEmpty())\n\t})\n\n\tIt(\"errors when the peer sends too connection IDs\", func() {\n\t\tfor i := uint8(1); i < protocol.MaxActiveConnectionIDs; i++ {\n\t\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber:      uint64(i),\n\t\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{i, i, i, i}),\n\t\t\t\tStatelessResetToken: protocol.StatelessResetToken{i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i},\n\t\t\t})).To(Succeed())\n\t\t}\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      uint64(9999),\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16},\n\t\t})).To(MatchError(&qerr.TransportError{ErrorCode: qerr.ConnectionIDLimitError}))\n\t})\n\n\tIt(\"initiates the first connection ID update as soon as possible\", func() {\n\t\tExpect(m.Get()).To(Equal(initialConnID))\n\t\tm.SetHandshakeComplete()\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      1,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n\t\t})).To(Succeed())\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t})\n\n\tIt(\"waits until handshake completion before initiating a connection ID update\", func() {\n\t\tExpect(m.Get()).To(Equal(initialConnID))\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      1,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n\t\t})).To(Succeed())\n\t\tExpect(m.Get()).To(Equal(initialConnID))\n\t\tm.SetHandshakeComplete()\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t})\n\n\tIt(\"initiates subsequent updates when enough packets are sent\", func() {\n\t\tvar s uint8\n\t\tfor s = uint8(1); s < protocol.MaxActiveConnectionIDs; s++ {\n\t\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber:      uint64(s),\n\t\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{s, s, s, s}),\n\t\t\t\tStatelessResetToken: protocol.StatelessResetToken{s, s, s, s, s, s, s, s, s, s, s, s, s, s, s, s},\n\t\t\t})).To(Succeed())\n\t\t}\n\n\t\tm.SetHandshakeComplete()\n\t\tlastConnID := m.Get()\n\t\tExpect(lastConnID).To(Equal(protocol.ParseConnectionID([]byte{1, 1, 1, 1})))\n\n\t\tvar counter int\n\t\tfor i := 0; i < 50*protocol.PacketsPerConnectionID; i++ {\n\t\t\tm.SentPacket()\n\n\t\t\tconnID := m.Get()\n\t\t\tif connID != lastConnID {\n\t\t\t\tcounter++\n\t\t\t\tlastConnID = connID\n\t\t\t\tExpect(removedTokens).To(HaveLen(1))\n\t\t\t\tremovedTokens = nil\n\t\t\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\t\t\tSequenceNumber:      uint64(s),\n\t\t\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{s, s, s, s}),\n\t\t\t\t\tStatelessResetToken: protocol.StatelessResetToken{s, s, s, s, s, s, s, s, s, s, s, s, s, s, s, s},\n\t\t\t\t})).To(Succeed())\n\t\t\t\ts++\n\t\t\t}\n\t\t}\n\t\tExpect(counter).To(BeNumerically(\"~\", 50, 10))\n\t})\n\n\tIt(\"retires delayed connection IDs that arrive after a higher connection ID was already retired\", func() {\n\t\tfor s := uint8(10); s <= 10+protocol.MaxActiveConnectionIDs/2; s++ {\n\t\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber:      uint64(s),\n\t\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{s, s, s, s}),\n\t\t\t\tStatelessResetToken: protocol.StatelessResetToken{s, s, s, s, s, s, s, s, s, s, s, s, s, s, s, s},\n\t\t\t})).To(Succeed())\n\t\t}\n\t\tm.SetHandshakeComplete()\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{10, 10, 10, 10})))\n\t\tfor {\n\t\t\tm.SentPacket()\n\t\t\tif m.Get() == protocol.ParseConnectionID([]byte{11, 11, 11, 11}) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// The active conn ID is now {11, 11, 11, 11}\n\t\tExpect(m.queue.Front().Value.ConnectionID).To(Equal(protocol.ParseConnectionID([]byte{12, 12, 12, 12})))\n\t\t// Add a delayed connection ID. It should just be ignored now.\n\t\tframeQueue = nil\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      uint64(5),\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{5, 5, 5, 5}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},\n\t\t})).To(Succeed())\n\t\tExpect(m.queue.Front().Value.ConnectionID).To(Equal(protocol.ParseConnectionID([]byte{12, 12, 12, 12})))\n\t\tExpect(frameQueue).To(HaveLen(1))\n\t\tExpect(frameQueue[0].(*wire.RetireConnectionIDFrame).SequenceNumber).To(BeEquivalentTo(5))\n\t})\n\n\tIt(\"only initiates subsequent updates when enough if enough connection IDs are queued\", func() {\n\t\tfor i := uint8(1); i <= protocol.MaxActiveConnectionIDs/2; i++ {\n\t\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\t\tSequenceNumber:      uint64(i),\n\t\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{i, i, i, i}),\n\t\t\t\tStatelessResetToken: protocol.StatelessResetToken{i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i},\n\t\t\t})).To(Succeed())\n\t\t}\n\t\tm.SetHandshakeComplete()\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 1, 1, 1})))\n\t\tfor i := 0; i < 2*protocol.PacketsPerConnectionID; i++ {\n\t\t\tm.SentPacket()\n\t\t}\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 1, 1, 1})))\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber: 1337,\n\t\t\tConnectionID:   protocol.ParseConnectionID([]byte{1, 3, 3, 7}),\n\t\t})).To(Succeed())\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{2, 2, 2, 2})))\n\t\tExpect(removedTokens).To(HaveLen(1))\n\t\tExpect(removedTokens[0]).To(Equal(protocol.StatelessResetToken{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n\t})\n\n\tIt(\"removes the currently active stateless reset token when it is closed\", func() {\n\t\tm.Close()\n\t\tExpect(removedTokens).To(BeEmpty())\n\t\tExpect(m.Add(&wire.NewConnectionIDFrame{\n\t\t\tSequenceNumber:      1,\n\t\t\tConnectionID:        protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\tStatelessResetToken: protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n\t\t})).To(Succeed())\n\t\tm.SetHandshakeComplete()\n\t\tExpect(m.Get()).To(Equal(protocol.ParseConnectionID([]byte{1, 2, 3, 4})))\n\t\tm.Close()\n\t\tExpect(removedTokens).To(HaveLen(1))\n\t\tExpect(removedTokens[0]).To(Equal(protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}))\n\t})\n})\n"
        },
        {
          "name": "connection.go",
          "type": "blob",
          "size": 76.44140625,
          "content": "package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\ntype unpacker interface {\n\tUnpackLongHeader(hdr *wire.Header, data []byte) (*unpackedPacket, error)\n\tUnpackShortHeader(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error)\n}\n\ntype streamManager interface {\n\tGetOrOpenSendStream(protocol.StreamID) (sendStreamI, error)\n\tGetOrOpenReceiveStream(protocol.StreamID) (receiveStreamI, error)\n\tOpenStream() (Stream, error)\n\tOpenUniStream() (SendStream, error)\n\tOpenStreamSync(context.Context) (Stream, error)\n\tOpenUniStreamSync(context.Context) (SendStream, error)\n\tAcceptStream(context.Context) (Stream, error)\n\tAcceptUniStream(context.Context) (ReceiveStream, error)\n\tDeleteStream(protocol.StreamID) error\n\tUpdateLimits(*wire.TransportParameters)\n\tHandleMaxStreamsFrame(*wire.MaxStreamsFrame)\n\tCloseWithError(error)\n\tResetFor0RTT()\n\tUseResetMaps()\n}\n\ntype cryptoStreamHandler interface {\n\tStartHandshake(context.Context) error\n\tChangeConnectionID(protocol.ConnectionID)\n\tSetLargest1RTTAcked(protocol.PacketNumber) error\n\tSetHandshakeConfirmed()\n\tGetSessionTicket() ([]byte, error)\n\tNextEvent() handshake.Event\n\tDiscardInitialKeys()\n\tHandleMessage([]byte, protocol.EncryptionLevel) error\n\tio.Closer\n\tConnectionState() handshake.ConnectionState\n}\n\ntype receivedPacket struct {\n\tbuffer *packetBuffer\n\n\tremoteAddr net.Addr\n\trcvTime    time.Time\n\tdata       []byte\n\n\tecn protocol.ECN\n\n\tinfo packetInfo // only valid if the contained IP address is valid\n}\n\nfunc (p *receivedPacket) Size() protocol.ByteCount { return protocol.ByteCount(len(p.data)) }\n\nfunc (p *receivedPacket) Clone() *receivedPacket {\n\treturn &receivedPacket{\n\t\tremoteAddr: p.remoteAddr,\n\t\trcvTime:    p.rcvTime,\n\t\tdata:       p.data,\n\t\tbuffer:     p.buffer,\n\t\tecn:        p.ecn,\n\t\tinfo:       p.info,\n\t}\n}\n\ntype connRunner interface {\n\tAdd(protocol.ConnectionID, packetHandler) bool\n\tGetStatelessResetToken(protocol.ConnectionID) protocol.StatelessResetToken\n\tRetire(protocol.ConnectionID)\n\tRemove(protocol.ConnectionID)\n\tReplaceWithClosed([]protocol.ConnectionID, []byte)\n\tAddResetToken(protocol.StatelessResetToken, packetHandler)\n\tRemoveResetToken(protocol.StatelessResetToken)\n}\n\ntype closeError struct {\n\terr       error\n\tremote    bool\n\timmediate bool\n}\n\ntype errCloseForRecreating struct {\n\tnextPacketNumber protocol.PacketNumber\n\tnextVersion      protocol.Version\n}\n\nfunc (e *errCloseForRecreating) Error() string {\n\treturn \"closing connection in order to recreate it\"\n}\n\nvar connTracingID atomic.Uint64              // to be accessed atomically\nfunc nextConnTracingID() ConnectionTracingID { return ConnectionTracingID(connTracingID.Add(1)) }\n\n// A Connection is a QUIC connection\ntype connection struct {\n\t// Destination connection ID used during the handshake.\n\t// Used to check source connection ID on incoming packets.\n\thandshakeDestConnID protocol.ConnectionID\n\t// Set for the client. Destination connection ID used on the first Initial sent.\n\torigDestConnID protocol.ConnectionID\n\tretrySrcConnID *protocol.ConnectionID // only set for the client (and if a Retry was performed)\n\n\tsrcConnIDLen int\n\n\tperspective protocol.Perspective\n\tversion     protocol.Version\n\tconfig      *Config\n\n\tconn      sendConn\n\tsendQueue sender\n\n\tstreamsMap      streamManager\n\tconnIDManager   *connIDManager\n\tconnIDGenerator *connIDGenerator\n\n\trttStats *utils.RTTStats\n\n\tcryptoStreamManager   *cryptoStreamManager\n\tsentPacketHandler     ackhandler.SentPacketHandler\n\treceivedPacketHandler ackhandler.ReceivedPacketHandler\n\tretransmissionQueue   *retransmissionQueue\n\tframer                *framer\n\tconnFlowController    flowcontrol.ConnectionFlowController\n\ttokenStoreKey         string                    // only set for the client\n\ttokenGenerator        *handshake.TokenGenerator // only set for the server\n\n\tunpacker      unpacker\n\tframeParser   wire.FrameParser\n\tpacker        packer\n\tmtuDiscoverer mtuDiscoverer // initialized when the transport parameters are received\n\n\tmaxPayloadSizeEstimate atomic.Uint32\n\n\tinitialStream       *cryptoStream\n\thandshakeStream     *cryptoStream\n\toneRTTStream        *cryptoStream // only set for the server\n\tcryptoStreamHandler cryptoStreamHandler\n\n\treceivedPackets  chan receivedPacket\n\tsendingScheduled chan struct{}\n\n\tcloseOnce sync.Once\n\t// closeChan is used to notify the run loop that it should terminate\n\tcloseChan chan closeError\n\n\tctx                   context.Context\n\tctxCancel             context.CancelCauseFunc\n\thandshakeCompleteChan chan struct{}\n\n\tundecryptablePackets          []receivedPacket // undecryptable packets, waiting for a change in encryption level\n\tundecryptablePacketsToProcess []receivedPacket\n\n\tearlyConnReadyChan chan struct{}\n\tsentFirstPacket    bool\n\tdroppedInitialKeys bool\n\thandshakeComplete  bool\n\thandshakeConfirmed bool\n\n\treceivedRetry       bool\n\tversionNegotiated   bool\n\treceivedFirstPacket bool\n\n\t// the minimum of the max_idle_timeout values advertised by both endpoints\n\tidleTimeout  time.Duration\n\tcreationTime time.Time\n\t// The idle timeout is set based on the max of the time we received the last packet...\n\tlastPacketReceivedTime time.Time\n\t// ... and the time we sent a new ack-eliciting packet after receiving a packet.\n\tfirstAckElicitingPacketAfterIdleSentTime time.Time\n\t// pacingDeadline is the time when the next packet should be sent\n\tpacingDeadline time.Time\n\n\tpeerParams *wire.TransportParameters\n\n\ttimer connectionTimer\n\t// keepAlivePingSent stores whether a keep alive PING is in flight.\n\t// It is reset as soon as we receive a packet from the peer.\n\tkeepAlivePingSent bool\n\tkeepAliveInterval time.Duration\n\n\tdatagramQueue *datagramQueue\n\n\tconnStateMutex sync.Mutex\n\tconnState      ConnectionState\n\n\tlogID  string\n\ttracer *logging.ConnectionTracer\n\tlogger utils.Logger\n}\n\nvar (\n\t_ Connection      = &connection{}\n\t_ EarlyConnection = &connection{}\n\t_ streamSender    = &connection{}\n)\n\nvar newConnection = func(\n\tctx context.Context,\n\tctxCancel context.CancelCauseFunc,\n\tconn sendConn,\n\trunner connRunner,\n\torigDestConnID protocol.ConnectionID,\n\tretrySrcConnID *protocol.ConnectionID,\n\tclientDestConnID protocol.ConnectionID,\n\tdestConnID protocol.ConnectionID,\n\tsrcConnID protocol.ConnectionID,\n\tconnIDGenerator ConnectionIDGenerator,\n\tstatelessResetToken protocol.StatelessResetToken,\n\tconf *Config,\n\ttlsConf *tls.Config,\n\ttokenGenerator *handshake.TokenGenerator,\n\tclientAddressValidated bool,\n\ttracer *logging.ConnectionTracer,\n\tlogger utils.Logger,\n\tv protocol.Version,\n) quicConn {\n\ts := &connection{\n\t\tctx:                 ctx,\n\t\tctxCancel:           ctxCancel,\n\t\tconn:                conn,\n\t\tconfig:              conf,\n\t\thandshakeDestConnID: destConnID,\n\t\tsrcConnIDLen:        srcConnID.Len(),\n\t\ttokenGenerator:      tokenGenerator,\n\t\toneRTTStream:        newCryptoStream(),\n\t\tperspective:         protocol.PerspectiveServer,\n\t\ttracer:              tracer,\n\t\tlogger:              logger,\n\t\tversion:             v,\n\t}\n\tif origDestConnID.Len() > 0 {\n\t\ts.logID = origDestConnID.String()\n\t} else {\n\t\ts.logID = destConnID.String()\n\t}\n\ts.connIDManager = newConnIDManager(\n\t\tdestConnID,\n\t\tfunc(token protocol.StatelessResetToken) { runner.AddResetToken(token, s) },\n\t\trunner.RemoveResetToken,\n\t\ts.queueControlFrame,\n\t)\n\ts.connIDGenerator = newConnIDGenerator(\n\t\tsrcConnID,\n\t\t&clientDestConnID,\n\t\tfunc(connID protocol.ConnectionID) { runner.Add(connID, s) },\n\t\trunner.GetStatelessResetToken,\n\t\trunner.Remove,\n\t\trunner.Retire,\n\t\trunner.ReplaceWithClosed,\n\t\ts.queueControlFrame,\n\t\tconnIDGenerator,\n\t)\n\ts.preSetup()\n\ts.sentPacketHandler, s.receivedPacketHandler = ackhandler.NewAckHandler(\n\t\t0,\n\t\tprotocol.ByteCount(s.config.InitialPacketSize),\n\t\ts.rttStats,\n\t\tclientAddressValidated,\n\t\ts.conn.capabilities().ECN,\n\t\ts.perspective,\n\t\ts.tracer,\n\t\ts.logger,\n\t)\n\ts.maxPayloadSizeEstimate.Store(uint32(estimateMaxPayloadSize(protocol.ByteCount(s.config.InitialPacketSize))))\n\tparams := &wire.TransportParameters{\n\t\tInitialMaxStreamDataBidiLocal:   protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataBidiRemote:  protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataUni:         protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxData:                  protocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tMaxIdleTimeout:                  s.config.MaxIdleTimeout,\n\t\tMaxBidiStreamNum:                protocol.StreamNum(s.config.MaxIncomingStreams),\n\t\tMaxUniStreamNum:                 protocol.StreamNum(s.config.MaxIncomingUniStreams),\n\t\tMaxAckDelay:                     protocol.MaxAckDelayInclGranularity,\n\t\tAckDelayExponent:                protocol.AckDelayExponent,\n\t\tMaxUDPPayloadSize:               protocol.MaxPacketBufferSize,\n\t\tDisableActiveMigration:          true,\n\t\tStatelessResetToken:             &statelessResetToken,\n\t\tOriginalDestinationConnectionID: origDestConnID,\n\t\t// For interoperability with quic-go versions before May 2023, this value must be set to a value\n\t\t// different from protocol.DefaultActiveConnectionIDLimit.\n\t\t// If set to the default value, it will be omitted from the transport parameters, which will make\n\t\t// old quic-go versions interpret it as 0, instead of the default value of 2.\n\t\t// See https://github.com/quic-go/quic-go/pull/3806.\n\t\tActiveConnectionIDLimit:   protocol.MaxActiveConnectionIDs,\n\t\tInitialSourceConnectionID: srcConnID,\n\t\tRetrySourceConnectionID:   retrySrcConnID,\n\t}\n\tif s.config.EnableDatagrams {\n\t\tparams.MaxDatagramFrameSize = wire.MaxDatagramSize\n\t} else {\n\t\tparams.MaxDatagramFrameSize = protocol.InvalidByteCount\n\t}\n\tif s.tracer != nil && s.tracer.SentTransportParameters != nil {\n\t\ts.tracer.SentTransportParameters(params)\n\t}\n\tcs := handshake.NewCryptoSetupServer(\n\t\tclientDestConnID,\n\t\tconn.LocalAddr(),\n\t\tconn.RemoteAddr(),\n\t\tparams,\n\t\ttlsConf,\n\t\tconf.Allow0RTT,\n\t\ts.rttStats,\n\t\ttracer,\n\t\tlogger,\n\t\ts.version,\n\t)\n\ts.cryptoStreamHandler = cs\n\ts.packer = newPacketPacker(srcConnID, s.connIDManager.Get, s.initialStream, s.handshakeStream, s.sentPacketHandler, s.retransmissionQueue, cs, s.framer, s.receivedPacketHandler, s.datagramQueue, s.perspective)\n\ts.unpacker = newPacketUnpacker(cs, s.srcConnIDLen)\n\ts.cryptoStreamManager = newCryptoStreamManager(s.initialStream, s.handshakeStream, s.oneRTTStream)\n\treturn s\n}\n\n// declare this as a variable, such that we can it mock it in the tests\nvar newClientConnection = func(\n\tctx context.Context,\n\tconn sendConn,\n\trunner connRunner,\n\tdestConnID protocol.ConnectionID,\n\tsrcConnID protocol.ConnectionID,\n\tconnIDGenerator ConnectionIDGenerator,\n\tconf *Config,\n\ttlsConf *tls.Config,\n\tinitialPacketNumber protocol.PacketNumber,\n\tenable0RTT bool,\n\thasNegotiatedVersion bool,\n\ttracer *logging.ConnectionTracer,\n\tlogger utils.Logger,\n\tv protocol.Version,\n) quicConn {\n\ts := &connection{\n\t\tconn:                conn,\n\t\tconfig:              conf,\n\t\torigDestConnID:      destConnID,\n\t\thandshakeDestConnID: destConnID,\n\t\tsrcConnIDLen:        srcConnID.Len(),\n\t\tperspective:         protocol.PerspectiveClient,\n\t\tlogID:               destConnID.String(),\n\t\tlogger:              logger,\n\t\ttracer:              tracer,\n\t\tversionNegotiated:   hasNegotiatedVersion,\n\t\tversion:             v,\n\t}\n\ts.connIDManager = newConnIDManager(\n\t\tdestConnID,\n\t\tfunc(token protocol.StatelessResetToken) { runner.AddResetToken(token, s) },\n\t\trunner.RemoveResetToken,\n\t\ts.queueControlFrame,\n\t)\n\ts.connIDGenerator = newConnIDGenerator(\n\t\tsrcConnID,\n\t\tnil,\n\t\tfunc(connID protocol.ConnectionID) { runner.Add(connID, s) },\n\t\trunner.GetStatelessResetToken,\n\t\trunner.Remove,\n\t\trunner.Retire,\n\t\trunner.ReplaceWithClosed,\n\t\ts.queueControlFrame,\n\t\tconnIDGenerator,\n\t)\n\ts.ctx, s.ctxCancel = context.WithCancelCause(ctx)\n\ts.preSetup()\n\ts.sentPacketHandler, s.receivedPacketHandler = ackhandler.NewAckHandler(\n\t\tinitialPacketNumber,\n\t\tprotocol.ByteCount(s.config.InitialPacketSize),\n\t\ts.rttStats,\n\t\tfalse, // has no effect\n\t\ts.conn.capabilities().ECN,\n\t\ts.perspective,\n\t\ts.tracer,\n\t\ts.logger,\n\t)\n\ts.maxPayloadSizeEstimate.Store(uint32(estimateMaxPayloadSize(protocol.ByteCount(s.config.InitialPacketSize))))\n\toneRTTStream := newCryptoStream()\n\tparams := &wire.TransportParameters{\n\t\tInitialMaxStreamDataBidiRemote: protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataBidiLocal:  protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxStreamDataUni:        protocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tInitialMaxData:                 protocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tMaxIdleTimeout:                 s.config.MaxIdleTimeout,\n\t\tMaxBidiStreamNum:               protocol.StreamNum(s.config.MaxIncomingStreams),\n\t\tMaxUniStreamNum:                protocol.StreamNum(s.config.MaxIncomingUniStreams),\n\t\tMaxAckDelay:                    protocol.MaxAckDelayInclGranularity,\n\t\tMaxUDPPayloadSize:              protocol.MaxPacketBufferSize,\n\t\tAckDelayExponent:               protocol.AckDelayExponent,\n\t\tDisableActiveMigration:         true,\n\t\t// For interoperability with quic-go versions before May 2023, this value must be set to a value\n\t\t// different from protocol.DefaultActiveConnectionIDLimit.\n\t\t// If set to the default value, it will be omitted from the transport parameters, which will make\n\t\t// old quic-go versions interpret it as 0, instead of the default value of 2.\n\t\t// See https://github.com/quic-go/quic-go/pull/3806.\n\t\tActiveConnectionIDLimit:   protocol.MaxActiveConnectionIDs,\n\t\tInitialSourceConnectionID: srcConnID,\n\t}\n\tif s.config.EnableDatagrams {\n\t\tparams.MaxDatagramFrameSize = wire.MaxDatagramSize\n\t} else {\n\t\tparams.MaxDatagramFrameSize = protocol.InvalidByteCount\n\t}\n\tif s.tracer != nil && s.tracer.SentTransportParameters != nil {\n\t\ts.tracer.SentTransportParameters(params)\n\t}\n\tcs := handshake.NewCryptoSetupClient(\n\t\tdestConnID,\n\t\tparams,\n\t\ttlsConf,\n\t\tenable0RTT,\n\t\ts.rttStats,\n\t\ttracer,\n\t\tlogger,\n\t\ts.version,\n\t)\n\ts.cryptoStreamHandler = cs\n\ts.cryptoStreamManager = newCryptoStreamManager(s.initialStream, s.handshakeStream, oneRTTStream)\n\ts.unpacker = newPacketUnpacker(cs, s.srcConnIDLen)\n\ts.packer = newPacketPacker(srcConnID, s.connIDManager.Get, s.initialStream, s.handshakeStream, s.sentPacketHandler, s.retransmissionQueue, cs, s.framer, s.receivedPacketHandler, s.datagramQueue, s.perspective)\n\tif len(tlsConf.ServerName) > 0 {\n\t\ts.tokenStoreKey = tlsConf.ServerName\n\t} else {\n\t\ts.tokenStoreKey = conn.RemoteAddr().String()\n\t}\n\tif s.config.TokenStore != nil {\n\t\tif token := s.config.TokenStore.Pop(s.tokenStoreKey); token != nil {\n\t\t\ts.packer.SetToken(token.data)\n\t\t}\n\t}\n\treturn s\n}\n\nfunc (s *connection) preSetup() {\n\ts.initialStream = newCryptoStream()\n\ts.handshakeStream = newCryptoStream()\n\ts.sendQueue = newSendQueue(s.conn)\n\ts.retransmissionQueue = newRetransmissionQueue()\n\ts.frameParser = *wire.NewFrameParser(s.config.EnableDatagrams)\n\ts.rttStats = &utils.RTTStats{}\n\ts.connFlowController = flowcontrol.NewConnectionFlowController(\n\t\tprotocol.ByteCount(s.config.InitialConnectionReceiveWindow),\n\t\tprotocol.ByteCount(s.config.MaxConnectionReceiveWindow),\n\t\tfunc(size protocol.ByteCount) bool {\n\t\t\tif s.config.AllowConnectionWindowIncrease == nil {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn s.config.AllowConnectionWindowIncrease(s, uint64(size))\n\t\t},\n\t\ts.rttStats,\n\t\ts.logger,\n\t)\n\ts.earlyConnReadyChan = make(chan struct{})\n\ts.streamsMap = newStreamsMap(\n\t\ts.ctx,\n\t\ts,\n\t\ts.queueControlFrame,\n\t\ts.newFlowController,\n\t\tuint64(s.config.MaxIncomingStreams),\n\t\tuint64(s.config.MaxIncomingUniStreams),\n\t\ts.perspective,\n\t)\n\ts.framer = newFramer(s.connFlowController)\n\ts.receivedPackets = make(chan receivedPacket, protocol.MaxConnUnprocessedPackets)\n\ts.closeChan = make(chan closeError, 1)\n\ts.sendingScheduled = make(chan struct{}, 1)\n\ts.handshakeCompleteChan = make(chan struct{})\n\n\tnow := time.Now()\n\ts.lastPacketReceivedTime = now\n\ts.creationTime = now\n\n\ts.datagramQueue = newDatagramQueue(s.scheduleSending, s.logger)\n\ts.connState.Version = s.version\n}\n\n// run the connection main loop\nfunc (s *connection) run() error {\n\tvar closeErr closeError\n\tdefer func() { s.ctxCancel(closeErr.err) }()\n\n\tdefer func() {\n\t\t// Drain queued packets that will never be processed.\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase p, ok := <-s.receivedPackets:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tp.buffer.Decrement()\n\t\t\t\tp.buffer.MaybeRelease()\n\t\t\tdefault:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\ts.timer = *newTimer()\n\n\tif err := s.cryptoStreamHandler.StartHandshake(s.ctx); err != nil {\n\t\treturn err\n\t}\n\tif err := s.handleHandshakeEvents(); err != nil {\n\t\treturn err\n\t}\n\tgo func() {\n\t\tif err := s.sendQueue.Run(); err != nil {\n\t\t\ts.destroyImpl(err)\n\t\t}\n\t}()\n\n\tif s.perspective == protocol.PerspectiveClient {\n\t\ts.scheduleSending() // so the ClientHello actually gets sent\n\t}\n\n\tvar sendQueueAvailable <-chan struct{}\n\nrunLoop:\n\tfor {\n\t\tif s.framer.QueuedTooManyControlFrames() {\n\t\t\ts.closeLocal(&qerr.TransportError{ErrorCode: InternalError})\n\t\t}\n\t\t// Close immediately if requested\n\t\tselect {\n\t\tcase closeErr = <-s.closeChan:\n\t\t\tbreak runLoop\n\t\tdefault:\n\t\t}\n\n\t\ts.maybeResetTimer()\n\n\t\tvar processedUndecryptablePacket bool\n\t\tif len(s.undecryptablePacketsToProcess) > 0 {\n\t\t\tqueue := s.undecryptablePacketsToProcess\n\t\t\ts.undecryptablePacketsToProcess = nil\n\t\t\tfor _, p := range queue {\n\t\t\t\tif processed := s.handlePacketImpl(p); processed {\n\t\t\t\t\tprocessedUndecryptablePacket = true\n\t\t\t\t}\n\t\t\t\t// Don't set timers and send packets if the packet made us close the connection.\n\t\t\t\tselect {\n\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\tbreak runLoop\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If we processed any undecryptable packets, jump to the resetting of the timers directly.\n\t\tif !processedUndecryptablePacket {\n\t\t\tselect {\n\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\tbreak runLoop\n\t\t\tcase <-s.timer.Chan():\n\t\t\t\ts.timer.SetRead()\n\t\t\t\t// We do all the interesting stuff after the switch statement, so\n\t\t\t\t// nothing to see here.\n\t\t\tcase <-s.sendingScheduled:\n\t\t\t\t// We do all the interesting stuff after the switch statement, so\n\t\t\t\t// nothing to see here.\n\t\t\tcase <-sendQueueAvailable:\n\t\t\tcase firstPacket := <-s.receivedPackets:\n\t\t\t\twasProcessed := s.handlePacketImpl(firstPacket)\n\t\t\t\t// Don't set timers and send packets if the packet made us close the connection.\n\t\t\t\tselect {\n\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\tbreak runLoop\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t\tif s.handshakeComplete {\n\t\t\t\t\t// Now process all packets in the receivedPackets channel.\n\t\t\t\t\t// Limit the number of packets to the length of the receivedPackets channel,\n\t\t\t\t\t// so we eventually get a chance to send out an ACK when receiving a lot of packets.\n\t\t\t\t\tnumPackets := len(s.receivedPackets)\n\t\t\t\treceiveLoop:\n\t\t\t\t\tfor i := 0; i < numPackets; i++ {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase p := <-s.receivedPackets:\n\t\t\t\t\t\t\tif processed := s.handlePacketImpl(p); processed {\n\t\t\t\t\t\t\t\twasProcessed = true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tselect {\n\t\t\t\t\t\t\tcase closeErr = <-s.closeChan:\n\t\t\t\t\t\t\t\tbreak runLoop\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak receiveLoop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Only reset the timers if this packet was actually processed.\n\t\t\t\t// This avoids modifying any state when handling undecryptable packets,\n\t\t\t\t// which could be injected by an attacker.\n\t\t\t\tif !wasProcessed {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tnow := time.Now()\n\t\tif timeout := s.sentPacketHandler.GetLossDetectionTimeout(); !timeout.IsZero() && timeout.Before(now) {\n\t\t\t// This could cause packets to be retransmitted.\n\t\t\t// Check it before trying to send packets.\n\t\t\tif err := s.sentPacketHandler.OnLossDetectionTimeout(); err != nil {\n\t\t\t\ts.closeLocal(err)\n\t\t\t}\n\t\t}\n\n\t\tif keepAliveTime := s.nextKeepAliveTime(); !keepAliveTime.IsZero() && !now.Before(keepAliveTime) {\n\t\t\t// send a PING frame since there is no activity in the connection\n\t\t\ts.logger.Debugf(\"Sending a keep-alive PING to keep the connection alive.\")\n\t\t\ts.framer.QueueControlFrame(&wire.PingFrame{})\n\t\t\ts.keepAlivePingSent = true\n\t\t} else if !s.handshakeComplete && now.Sub(s.creationTime) >= s.config.handshakeTimeout() {\n\t\t\ts.destroyImpl(qerr.ErrHandshakeTimeout)\n\t\t\tcontinue\n\t\t} else {\n\t\t\tidleTimeoutStartTime := s.idleTimeoutStartTime()\n\t\t\tif (!s.handshakeComplete && now.Sub(idleTimeoutStartTime) >= s.config.HandshakeIdleTimeout) ||\n\t\t\t\t(s.handshakeComplete && now.After(s.nextIdleTimeoutTime())) {\n\t\t\t\ts.destroyImpl(qerr.ErrIdleTimeout)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\t// The send queue is still busy sending out packets.\n\t\t\t// Wait until there's space to enqueue new packets.\n\t\t\tsendQueueAvailable = s.sendQueue.Available()\n\t\t\tcontinue\n\t\t}\n\t\tif err := s.triggerSending(now); err != nil {\n\t\t\ts.closeLocal(err)\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\tsendQueueAvailable = s.sendQueue.Available()\n\t\t} else {\n\t\t\tsendQueueAvailable = nil\n\t\t}\n\t}\n\n\ts.cryptoStreamHandler.Close()\n\ts.sendQueue.Close() // close the send queue before sending the CONNECTION_CLOSE\n\ts.handleCloseError(&closeErr)\n\tif s.tracer != nil && s.tracer.Close != nil {\n\t\tif e := (&errCloseForRecreating{}); !errors.As(closeErr.err, &e) {\n\t\t\ts.tracer.Close()\n\t\t}\n\t}\n\ts.logger.Infof(\"Connection %s closed.\", s.logID)\n\ts.timer.Stop()\n\treturn closeErr.err\n}\n\n// blocks until the early connection can be used\nfunc (s *connection) earlyConnReady() <-chan struct{} {\n\treturn s.earlyConnReadyChan\n}\n\nfunc (s *connection) HandshakeComplete() <-chan struct{} {\n\treturn s.handshakeCompleteChan\n}\n\nfunc (s *connection) Context() context.Context {\n\treturn s.ctx\n}\n\nfunc (s *connection) supportsDatagrams() bool {\n\treturn s.peerParams.MaxDatagramFrameSize > 0\n}\n\nfunc (s *connection) ConnectionState() ConnectionState {\n\ts.connStateMutex.Lock()\n\tdefer s.connStateMutex.Unlock()\n\tcs := s.cryptoStreamHandler.ConnectionState()\n\ts.connState.TLS = cs.ConnectionState\n\ts.connState.Used0RTT = cs.Used0RTT\n\ts.connState.GSO = s.conn.capabilities().GSO\n\treturn s.connState\n}\n\n// Time when the connection should time out\nfunc (s *connection) nextIdleTimeoutTime() time.Time {\n\tidleTimeout := max(s.idleTimeout, s.rttStats.PTO(true)*3)\n\treturn s.idleTimeoutStartTime().Add(idleTimeout)\n}\n\n// Time when the next keep-alive packet should be sent.\n// It returns a zero time if no keep-alive should be sent.\nfunc (s *connection) nextKeepAliveTime() time.Time {\n\tif s.config.KeepAlivePeriod == 0 || s.keepAlivePingSent {\n\t\treturn time.Time{}\n\t}\n\tkeepAliveInterval := max(s.keepAliveInterval, s.rttStats.PTO(true)*3/2)\n\treturn s.lastPacketReceivedTime.Add(keepAliveInterval)\n}\n\nfunc (s *connection) maybeResetTimer() {\n\tvar deadline time.Time\n\tif !s.handshakeComplete {\n\t\tdeadline = s.creationTime.Add(s.config.handshakeTimeout())\n\t\tif t := s.idleTimeoutStartTime().Add(s.config.HandshakeIdleTimeout); t.Before(deadline) {\n\t\t\tdeadline = t\n\t\t}\n\t} else {\n\t\tif keepAliveTime := s.nextKeepAliveTime(); !keepAliveTime.IsZero() {\n\t\t\tdeadline = keepAliveTime\n\t\t} else {\n\t\t\tdeadline = s.nextIdleTimeoutTime()\n\t\t}\n\t}\n\n\ts.timer.SetTimer(\n\t\tdeadline,\n\t\ts.receivedPacketHandler.GetAlarmTimeout(),\n\t\ts.sentPacketHandler.GetLossDetectionTimeout(),\n\t\ts.pacingDeadline,\n\t)\n}\n\nfunc (s *connection) idleTimeoutStartTime() time.Time {\n\tstartTime := s.lastPacketReceivedTime\n\tif t := s.firstAckElicitingPacketAfterIdleSentTime; t.After(startTime) {\n\t\tstartTime = t\n\t}\n\treturn startTime\n}\n\nfunc (s *connection) handleHandshakeComplete() error {\n\tdefer close(s.handshakeCompleteChan)\n\t// Once the handshake completes, we have derived 1-RTT keys.\n\t// There's no point in queueing undecryptable packets for later decryption anymore.\n\ts.undecryptablePackets = nil\n\n\ts.connIDManager.SetHandshakeComplete()\n\ts.connIDGenerator.SetHandshakeComplete()\n\n\tif s.tracer != nil && s.tracer.ChoseALPN != nil {\n\t\ts.tracer.ChoseALPN(s.cryptoStreamHandler.ConnectionState().NegotiatedProtocol)\n\t}\n\n\t// The server applies transport parameters right away, but the client side has to wait for handshake completion.\n\t// During a 0-RTT connection, the client is only allowed to use the new transport parameters for 1-RTT packets.\n\tif s.perspective == protocol.PerspectiveClient {\n\t\ts.applyTransportParameters()\n\t\treturn nil\n\t}\n\n\t// All these only apply to the server side.\n\tif err := s.handleHandshakeConfirmed(); err != nil {\n\t\treturn err\n\t}\n\n\tticket, err := s.cryptoStreamHandler.GetSessionTicket()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif ticket != nil { // may be nil if session tickets are disabled via tls.Config.SessionTicketsDisabled\n\t\ts.oneRTTStream.Write(ticket)\n\t\tfor s.oneRTTStream.HasData() {\n\t\t\ts.queueControlFrame(s.oneRTTStream.PopCryptoFrame(protocol.MaxPostHandshakeCryptoFrameSize))\n\t\t}\n\t}\n\ttoken, err := s.tokenGenerator.NewToken(s.conn.RemoteAddr())\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.queueControlFrame(&wire.NewTokenFrame{Token: token})\n\ts.queueControlFrame(&wire.HandshakeDoneFrame{})\n\treturn nil\n}\n\nfunc (s *connection) handleHandshakeConfirmed() error {\n\tif err := s.dropEncryptionLevel(protocol.EncryptionHandshake); err != nil {\n\t\treturn err\n\t}\n\n\ts.handshakeConfirmed = true\n\ts.sentPacketHandler.SetHandshakeConfirmed()\n\ts.cryptoStreamHandler.SetHandshakeConfirmed()\n\n\tif !s.config.DisablePathMTUDiscovery && s.conn.capabilities().DF {\n\t\ts.mtuDiscoverer.Start()\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handlePacketImpl(rp receivedPacket) bool {\n\ts.sentPacketHandler.ReceivedBytes(rp.Size())\n\n\tif wire.IsVersionNegotiationPacket(rp.data) {\n\t\ts.handleVersionNegotiationPacket(rp)\n\t\treturn false\n\t}\n\n\tvar counter uint8\n\tvar lastConnID protocol.ConnectionID\n\tvar processed bool\n\tdata := rp.data\n\tp := rp\n\tfor len(data) > 0 {\n\t\tif counter > 0 {\n\t\t\tp = *(p.Clone())\n\t\t\tp.data = data\n\n\t\t\tdestConnID, err := wire.ParseConnectionID(p.data, s.srcConnIDLen)\n\t\t\tif err != nil {\n\t\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), logging.PacketDropHeaderParseError)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"error parsing packet, couldn't parse connection ID: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif destConnID != lastConnID {\n\t\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), logging.PacketDropUnknownConnectionID)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"coalesced packet has different destination connection ID: %s, expected %s\", destConnID, lastConnID)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif wire.IsLongHeaderPacket(p.data[0]) {\n\t\t\thdr, packetData, rest, err := wire.ParsePacket(p.data)\n\t\t\tif err != nil {\n\t\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\t\tdropReason := logging.PacketDropHeaderParseError\n\t\t\t\t\tif err == wire.ErrUnsupportedVersion {\n\t\t\t\t\t\tdropReason = logging.PacketDropUnsupportedVersion\n\t\t\t\t\t}\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), dropReason)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"error parsing packet: %s\", err)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlastConnID = hdr.DestConnectionID\n\n\t\t\tif hdr.Version != s.version {\n\t\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeFromHeader(hdr), protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedVersion)\n\t\t\t\t}\n\t\t\t\ts.logger.Debugf(\"Dropping packet with version %x. Expected %x.\", hdr.Version, s.version)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif counter > 0 {\n\t\t\t\tp.buffer.Split()\n\t\t\t}\n\t\t\tcounter++\n\n\t\t\t// only log if this actually a coalesced packet\n\t\t\tif s.logger.Debug() && (counter > 1 || len(rest) > 0) {\n\t\t\t\ts.logger.Debugf(\"Parsed a coalesced packet. Part %d: %d bytes. Remaining: %d bytes.\", counter, len(packetData), len(rest))\n\t\t\t}\n\n\t\t\tp.data = packetData\n\n\t\t\tif wasProcessed := s.handleLongHeaderPacket(p, hdr); wasProcessed {\n\t\t\t\tprocessed = true\n\t\t\t}\n\t\t\tdata = rest\n\t\t} else {\n\t\t\tif counter > 0 {\n\t\t\t\tp.buffer.Split()\n\t\t\t}\n\t\t\tif wasProcessed := s.handleShortHeaderPacket(p); wasProcessed {\n\t\t\t\tprocessed = true\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tp.buffer.MaybeRelease()\n\treturn processed\n}\n\nfunc (s *connection) handleShortHeaderPacket(p receivedPacket) bool {\n\tvar wasQueued bool\n\n\tdefer func() {\n\t\t// Put back the packet buffer if the packet wasn't queued for later decryption.\n\t\tif !wasQueued {\n\t\t\tp.buffer.Decrement()\n\t\t}\n\t}()\n\n\tdestConnID, err := wire.ParseConnectionID(p.data, s.srcConnIDLen)\n\tif err != nil {\n\t\ts.tracer.DroppedPacket(logging.PacketType1RTT, protocol.InvalidPacketNumber, protocol.ByteCount(len(p.data)), logging.PacketDropHeaderParseError)\n\t\treturn false\n\t}\n\tpn, pnLen, keyPhase, data, err := s.unpacker.UnpackShortHeader(p.rcvTime, p.data)\n\tif err != nil {\n\t\twasQueued = s.handleUnpackError(err, p, logging.PacketType1RTT)\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Reading packet %d (%d bytes) for connection %s, 1-RTT\", pn, p.Size(), destConnID)\n\t\twire.LogShortHeader(s.logger, destConnID, pn, pnLen, keyPhase)\n\t}\n\n\tif s.receivedPacketHandler.IsPotentiallyDuplicate(pn, protocol.Encryption1RTT) {\n\t\ts.logger.Debugf(\"Dropping (potentially) duplicate packet.\")\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketType1RTT, pn, p.Size(), logging.PacketDropDuplicate)\n\t\t}\n\t\treturn false\n\t}\n\n\tvar log func([]logging.Frame)\n\tif s.tracer != nil && s.tracer.ReceivedShortHeaderPacket != nil {\n\t\tlog = func(frames []logging.Frame) {\n\t\t\ts.tracer.ReceivedShortHeaderPacket(\n\t\t\t\t&logging.ShortHeader{\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tPacketNumber:     pn,\n\t\t\t\t\tPacketNumberLen:  pnLen,\n\t\t\t\t\tKeyPhase:         keyPhase,\n\t\t\t\t},\n\t\t\t\tp.Size(),\n\t\t\t\tp.ecn,\n\t\t\t\tframes,\n\t\t\t)\n\t\t}\n\t}\n\tif err := s.handleUnpackedShortHeaderPacket(destConnID, pn, data, p.ecn, p.rcvTime, log); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *connection) handleLongHeaderPacket(p receivedPacket, hdr *wire.Header) bool /* was the packet successfully processed */ {\n\tvar wasQueued bool\n\n\tdefer func() {\n\t\t// Put back the packet buffer if the packet wasn't queued for later decryption.\n\t\tif !wasQueued {\n\t\t\tp.buffer.Decrement()\n\t\t}\n\t}()\n\n\tif hdr.Type == protocol.PacketTypeRetry {\n\t\treturn s.handleRetryPacket(hdr, p.data, p.rcvTime)\n\t}\n\n\t// The server can change the source connection ID with the first Handshake packet.\n\t// After this, all packets with a different source connection have to be ignored.\n\tif s.receivedFirstPacket && hdr.Type == protocol.PacketTypeInitial && hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeInitial, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropUnknownConnectionID)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping Initial packet (%d bytes) with unexpected source connection ID: %s (expected %s)\", p.Size(), hdr.SrcConnectionID, s.handshakeDestConnID)\n\t\treturn false\n\t}\n\t// drop 0-RTT packets, if we are a client\n\tif s.perspective == protocol.PerspectiveClient && hdr.Type == protocol.PacketType0RTT {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketType0RTT, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn false\n\t}\n\n\tpacket, err := s.unpacker.UnpackLongHeader(hdr, p.data)\n\tif err != nil {\n\t\twasQueued = s.handleUnpackError(err, p, logging.PacketTypeFromHeader(hdr))\n\t\treturn false\n\t}\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Reading packet %d (%d bytes) for connection %s, %s\", packet.hdr.PacketNumber, p.Size(), hdr.DestConnectionID, packet.encryptionLevel)\n\t\tpacket.hdr.Log(s.logger)\n\t}\n\n\tif pn := packet.hdr.PacketNumber; s.receivedPacketHandler.IsPotentiallyDuplicate(pn, packet.encryptionLevel) {\n\t\ts.logger.Debugf(\"Dropping (potentially) duplicate packet.\")\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeFromHeader(hdr), pn, p.Size(), logging.PacketDropDuplicate)\n\t\t}\n\t\treturn false\n\t}\n\n\tif err := s.handleUnpackedLongHeaderPacket(packet, p.ecn, p.rcvTime, p.Size()); err != nil {\n\t\ts.closeLocal(err)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *connection) handleUnpackError(err error, p receivedPacket, pt logging.PacketType) (wasQueued bool) {\n\tswitch err {\n\tcase handshake.ErrKeysDropped:\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(pt, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropKeyUnavailable)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) because we already dropped the keys.\", pt, p.Size())\n\tcase handshake.ErrKeysNotYetAvailable:\n\t\t// Sealer for this encryption level not yet available.\n\t\t// Try again later.\n\t\ts.tryQueueingUndecryptablePacket(p, pt)\n\t\treturn true\n\tcase wire.ErrInvalidReservedBits:\n\t\ts.closeLocal(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: err.Error(),\n\t\t})\n\tcase handshake.ErrDecryptionFailed:\n\t\t// This might be a packet injected by an attacker. Drop it.\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(pt, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t}\n\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) that could not be unpacked. Error: %s\", pt, p.Size(), err)\n\tdefault:\n\t\tvar headerErr *headerParseError\n\t\tif errors.As(err, &headerErr) {\n\t\t\t// This might be a packet injected by an attacker. Drop it.\n\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\ts.tracer.DroppedPacket(pt, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropHeaderParseError)\n\t\t\t}\n\t\t\ts.logger.Debugf(\"Dropping %s packet (%d bytes) for which we couldn't unpack the header. Error: %s\", pt, p.Size(), err)\n\t\t} else {\n\t\t\t// This is an error returned by the AEAD (other than ErrDecryptionFailed).\n\t\t\t// For example, a PROTOCOL_VIOLATION due to key updates.\n\t\t\ts.closeLocal(err)\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (s *connection) handleRetryPacket(hdr *wire.Header, data []byte, rcvTime time.Time) bool /* was this a valid Retry */ {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry.\")\n\t\treturn false\n\t}\n\tif s.receivedFirstPacket {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry, since we already received a packet.\")\n\t\treturn false\n\t}\n\tdestConnID := s.connIDManager.Get()\n\tif hdr.SrcConnectionID == destConnID {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring Retry, since the server didn't change the Source Connection ID.\")\n\t\treturn false\n\t}\n\t// If a token is already set, this means that we already received a Retry from the server.\n\t// Ignore this Retry packet.\n\tif s.receivedRetry {\n\t\ts.logger.Debugf(\"Ignoring Retry, since a Retry was already received.\")\n\t\treturn false\n\t}\n\n\ttag := handshake.GetRetryIntegrityTag(data[:len(data)-16], destConnID, hdr.Version)\n\tif !bytes.Equal(data[len(data)-16:], tag[:]) {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeRetry, protocol.InvalidPacketNumber, protocol.ByteCount(len(data)), logging.PacketDropPayloadDecryptError)\n\t\t}\n\t\ts.logger.Debugf(\"Ignoring spoofed Retry. Integrity Tag doesn't match.\")\n\t\treturn false\n\t}\n\n\tnewDestConnID := hdr.SrcConnectionID\n\ts.receivedRetry = true\n\ts.sentPacketHandler.ResetForRetry(rcvTime)\n\ts.handshakeDestConnID = newDestConnID\n\ts.retrySrcConnID = &newDestConnID\n\ts.cryptoStreamHandler.ChangeConnectionID(newDestConnID)\n\ts.packer.SetToken(hdr.Token)\n\ts.connIDManager.ChangeInitialConnID(newDestConnID)\n\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"<- Received Retry:\")\n\t\t(&wire.ExtendedHeader{Header: *hdr}).Log(s.logger)\n\t\ts.logger.Debugf(\"Switching destination connection ID to: %s\", hdr.SrcConnectionID)\n\t}\n\tif s.tracer != nil && s.tracer.ReceivedRetry != nil {\n\t\ts.tracer.ReceivedRetry(hdr)\n\t}\n\n\ts.scheduleSending()\n\treturn true\n}\n\nfunc (s *connection) handleVersionNegotiationPacket(p receivedPacket) {\n\tif s.perspective == protocol.PerspectiveServer || // servers never receive version negotiation packets\n\t\ts.receivedFirstPacket || s.versionNegotiated { // ignore delayed / duplicated version negotiation packets\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn\n\t}\n\n\tsrc, dest, supportedVersions, err := wire.ParseVersionNegotiationPacket(p.data)\n\tif err != nil {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropHeaderParseError)\n\t\t}\n\t\ts.logger.Debugf(\"Error parsing Version Negotiation packet: %s\", err)\n\t\treturn\n\t}\n\n\tfor _, v := range supportedVersions {\n\t\tif v == s.version {\n\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\ts.tracer.DroppedPacket(logging.PacketTypeVersionNegotiation, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropUnexpectedVersion)\n\t\t\t}\n\t\t\t// The Version Negotiation packet contains the version that we offered.\n\t\t\t// This might be a packet sent by an attacker, or it was corrupted.\n\t\t\treturn\n\t\t}\n\t}\n\n\ts.logger.Infof(\"Received a Version Negotiation packet. Supported Versions: %s\", supportedVersions)\n\tif s.tracer != nil && s.tracer.ReceivedVersionNegotiationPacket != nil {\n\t\ts.tracer.ReceivedVersionNegotiationPacket(dest, src, supportedVersions)\n\t}\n\tnewVersion, ok := protocol.ChooseSupportedVersion(s.config.Versions, supportedVersions)\n\tif !ok {\n\t\ts.destroyImpl(&VersionNegotiationError{\n\t\t\tOurs:   s.config.Versions,\n\t\t\tTheirs: supportedVersions,\n\t\t})\n\t\ts.logger.Infof(\"No compatible QUIC version found.\")\n\t\treturn\n\t}\n\tif s.tracer != nil && s.tracer.NegotiatedVersion != nil {\n\t\ts.tracer.NegotiatedVersion(newVersion, s.config.Versions, supportedVersions)\n\t}\n\n\ts.logger.Infof(\"Switching to QUIC version %s.\", newVersion)\n\tnextPN, _ := s.sentPacketHandler.PeekPacketNumber(protocol.EncryptionInitial)\n\ts.destroyImpl(&errCloseForRecreating{\n\t\tnextPacketNumber: nextPN,\n\t\tnextVersion:      newVersion,\n\t})\n}\n\nfunc (s *connection) handleUnpackedLongHeaderPacket(\n\tpacket *unpackedPacket,\n\tecn protocol.ECN,\n\trcvTime time.Time,\n\tpacketSize protocol.ByteCount, // only for logging\n) error {\n\tif !s.receivedFirstPacket {\n\t\ts.receivedFirstPacket = true\n\t\tif !s.versionNegotiated && s.tracer != nil && s.tracer.NegotiatedVersion != nil {\n\t\t\tvar clientVersions, serverVersions []protocol.Version\n\t\t\tswitch s.perspective {\n\t\t\tcase protocol.PerspectiveClient:\n\t\t\t\tclientVersions = s.config.Versions\n\t\t\tcase protocol.PerspectiveServer:\n\t\t\t\tserverVersions = s.config.Versions\n\t\t\t}\n\t\t\ts.tracer.NegotiatedVersion(s.version, clientVersions, serverVersions)\n\t\t}\n\t\t// The server can change the source connection ID with the first Handshake packet.\n\t\tif s.perspective == protocol.PerspectiveClient && packet.hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\t\tcid := packet.hdr.SrcConnectionID\n\t\t\ts.logger.Debugf(\"Received first packet. Switching destination connection ID to: %s\", cid)\n\t\t\ts.handshakeDestConnID = cid\n\t\t\ts.connIDManager.ChangeInitialConnID(cid)\n\t\t}\n\t\t// We create the connection as soon as we receive the first packet from the client.\n\t\t// We do that before authenticating the packet.\n\t\t// That means that if the source connection ID was corrupted,\n\t\t// we might have created a connection with an incorrect source connection ID.\n\t\t// Once we authenticate the first packet, we need to update it.\n\t\tif s.perspective == protocol.PerspectiveServer {\n\t\t\tif packet.hdr.SrcConnectionID != s.handshakeDestConnID {\n\t\t\t\ts.handshakeDestConnID = packet.hdr.SrcConnectionID\n\t\t\t\ts.connIDManager.ChangeInitialConnID(packet.hdr.SrcConnectionID)\n\t\t\t}\n\t\t\tif s.tracer != nil && s.tracer.StartedConnection != nil {\n\t\t\t\ts.tracer.StartedConnection(\n\t\t\t\t\ts.conn.LocalAddr(),\n\t\t\t\t\ts.conn.RemoteAddr(),\n\t\t\t\t\tpacket.hdr.SrcConnectionID,\n\t\t\t\t\tpacket.hdr.DestConnectionID,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\tif s.perspective == protocol.PerspectiveServer && packet.encryptionLevel == protocol.EncryptionHandshake &&\n\t\t!s.droppedInitialKeys {\n\t\t// On the server side, Initial keys are dropped as soon as the first Handshake packet is received.\n\t\t// See Section 4.9.1 of RFC 9001.\n\t\tif err := s.dropEncryptionLevel(protocol.EncryptionInitial); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ts.lastPacketReceivedTime = rcvTime\n\ts.firstAckElicitingPacketAfterIdleSentTime = time.Time{}\n\ts.keepAlivePingSent = false\n\n\tvar log func([]logging.Frame)\n\tif s.tracer != nil && s.tracer.ReceivedLongHeaderPacket != nil {\n\t\tlog = func(frames []logging.Frame) {\n\t\t\ts.tracer.ReceivedLongHeaderPacket(packet.hdr, packetSize, ecn, frames)\n\t\t}\n\t}\n\tisAckEliciting, err := s.handleFrames(packet.data, packet.hdr.DestConnectionID, packet.encryptionLevel, log, rcvTime)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.receivedPacketHandler.ReceivedPacket(packet.hdr.PacketNumber, ecn, packet.encryptionLevel, rcvTime, isAckEliciting)\n}\n\nfunc (s *connection) handleUnpackedShortHeaderPacket(\n\tdestConnID protocol.ConnectionID,\n\tpn protocol.PacketNumber,\n\tdata []byte,\n\tecn protocol.ECN,\n\trcvTime time.Time,\n\tlog func([]logging.Frame),\n) error {\n\ts.lastPacketReceivedTime = rcvTime\n\ts.firstAckElicitingPacketAfterIdleSentTime = time.Time{}\n\ts.keepAlivePingSent = false\n\n\tisAckEliciting, err := s.handleFrames(data, destConnID, protocol.Encryption1RTT, log, rcvTime)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.receivedPacketHandler.ReceivedPacket(pn, ecn, protocol.Encryption1RTT, rcvTime, isAckEliciting)\n}\n\nfunc (s *connection) handleFrames(\n\tdata []byte,\n\tdestConnID protocol.ConnectionID,\n\tencLevel protocol.EncryptionLevel,\n\tlog func([]logging.Frame),\n\trcvTime time.Time,\n) (isAckEliciting bool, _ error) {\n\t// Only used for tracing.\n\t// If we're not tracing, this slice will always remain empty.\n\tvar frames []logging.Frame\n\tif log != nil {\n\t\tframes = make([]logging.Frame, 0, 4)\n\t}\n\thandshakeWasComplete := s.handshakeComplete\n\tvar handleErr error\n\tfor len(data) > 0 {\n\t\tl, frame, err := s.frameParser.ParseNext(data, encLevel, s.version)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tdata = data[l:]\n\t\tif frame == nil {\n\t\t\tbreak\n\t\t}\n\t\tif ackhandler.IsFrameAckEliciting(frame) {\n\t\t\tisAckEliciting = true\n\t\t}\n\t\tif log != nil {\n\t\t\tframes = append(frames, toLoggingFrame(frame))\n\t\t}\n\t\t// An error occurred handling a previous frame.\n\t\t// Don't handle the current frame.\n\t\tif handleErr != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := s.handleFrame(frame, encLevel, destConnID, rcvTime); err != nil {\n\t\t\tif log == nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\t// If we're logging, we need to keep parsing (but not handling) all frames.\n\t\t\thandleErr = err\n\t\t}\n\t}\n\n\tif log != nil {\n\t\tlog(frames)\n\t\tif handleErr != nil {\n\t\t\treturn false, handleErr\n\t\t}\n\t}\n\n\t// Handle completion of the handshake after processing all the frames.\n\t// This ensures that we correctly handle the following case on the server side:\n\t// We receive a Handshake packet that contains the CRYPTO frame that allows us to complete the handshake,\n\t// and an ACK serialized after that CRYPTO frame. In this case, we still want to process the ACK frame.\n\tif !handshakeWasComplete && s.handshakeComplete {\n\t\tif err := s.handleHandshakeComplete(); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\treturn\n}\n\nfunc (s *connection) handleFrame(\n\tf wire.Frame,\n\tencLevel protocol.EncryptionLevel,\n\tdestConnID protocol.ConnectionID,\n\trcvTime time.Time,\n) error {\n\tvar err error\n\twire.LogFrame(s.logger, f, false)\n\tswitch frame := f.(type) {\n\tcase *wire.CryptoFrame:\n\t\terr = s.handleCryptoFrame(frame, encLevel)\n\tcase *wire.StreamFrame:\n\t\terr = s.handleStreamFrame(frame, rcvTime)\n\tcase *wire.AckFrame:\n\t\terr = s.handleAckFrame(frame, encLevel)\n\tcase *wire.ConnectionCloseFrame:\n\t\ts.handleConnectionCloseFrame(frame)\n\tcase *wire.ResetStreamFrame:\n\t\terr = s.handleResetStreamFrame(frame, rcvTime)\n\tcase *wire.MaxDataFrame:\n\t\ts.handleMaxDataFrame(frame)\n\tcase *wire.MaxStreamDataFrame:\n\t\terr = s.handleMaxStreamDataFrame(frame)\n\tcase *wire.MaxStreamsFrame:\n\t\ts.handleMaxStreamsFrame(frame)\n\tcase *wire.DataBlockedFrame:\n\tcase *wire.StreamDataBlockedFrame:\n\t\terr = s.handleStreamDataBlockedFrame(frame)\n\tcase *wire.StreamsBlockedFrame:\n\tcase *wire.StopSendingFrame:\n\t\terr = s.handleStopSendingFrame(frame)\n\tcase *wire.PingFrame:\n\tcase *wire.PathChallengeFrame:\n\t\ts.handlePathChallengeFrame(frame)\n\tcase *wire.PathResponseFrame:\n\t\t// since we don't send PATH_CHALLENGEs, we don't expect PATH_RESPONSEs\n\t\terr = &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"unexpected PATH_RESPONSE frame\",\n\t\t}\n\tcase *wire.NewTokenFrame:\n\t\terr = s.handleNewTokenFrame(frame)\n\tcase *wire.NewConnectionIDFrame:\n\t\terr = s.handleNewConnectionIDFrame(frame)\n\tcase *wire.RetireConnectionIDFrame:\n\t\terr = s.handleRetireConnectionIDFrame(frame, destConnID)\n\tcase *wire.HandshakeDoneFrame:\n\t\terr = s.handleHandshakeDoneFrame()\n\tcase *wire.DatagramFrame:\n\t\terr = s.handleDatagramFrame(frame)\n\tdefault:\n\t\terr = fmt.Errorf(\"unexpected frame type: %s\", reflect.ValueOf(&frame).Elem().Type().Name())\n\t}\n\treturn err\n}\n\n// handlePacket is called by the server with a new packet\nfunc (s *connection) handlePacket(p receivedPacket) {\n\t// Discard packets once the amount of queued packets is larger than\n\t// the channel size, protocol.MaxConnUnprocessedPackets\n\tselect {\n\tcase s.receivedPackets <- p:\n\tdefault:\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t}\n}\n\nfunc (s *connection) handleConnectionCloseFrame(frame *wire.ConnectionCloseFrame) {\n\tif frame.IsApplicationError {\n\t\ts.closeRemote(&qerr.ApplicationError{\n\t\t\tRemote:       true,\n\t\t\tErrorCode:    qerr.ApplicationErrorCode(frame.ErrorCode),\n\t\t\tErrorMessage: frame.ReasonPhrase,\n\t\t})\n\t\treturn\n\t}\n\ts.closeRemote(&qerr.TransportError{\n\t\tRemote:       true,\n\t\tErrorCode:    qerr.TransportErrorCode(frame.ErrorCode),\n\t\tFrameType:    frame.FrameType,\n\t\tErrorMessage: frame.ReasonPhrase,\n\t})\n}\n\nfunc (s *connection) handleCryptoFrame(frame *wire.CryptoFrame, encLevel protocol.EncryptionLevel) error {\n\tif err := s.cryptoStreamManager.HandleCryptoFrame(frame, encLevel); err != nil {\n\t\treturn err\n\t}\n\tfor {\n\t\tdata := s.cryptoStreamManager.GetCryptoData(encLevel)\n\t\tif data == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err := s.cryptoStreamHandler.HandleMessage(data, encLevel); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.handleHandshakeEvents()\n}\n\nfunc (s *connection) handleHandshakeEvents() error {\n\tfor {\n\t\tev := s.cryptoStreamHandler.NextEvent()\n\t\tvar err error\n\t\tswitch ev.Kind {\n\t\tcase handshake.EventNoEvent:\n\t\t\treturn nil\n\t\tcase handshake.EventHandshakeComplete:\n\t\t\t// Don't call handleHandshakeComplete yet.\n\t\t\t// It's advantageous to process ACK frames that might be serialized after the CRYPTO frame first.\n\t\t\ts.handshakeComplete = true\n\t\tcase handshake.EventReceivedTransportParameters:\n\t\t\terr = s.handleTransportParameters(ev.TransportParameters)\n\t\tcase handshake.EventRestoredTransportParameters:\n\t\t\ts.restoreTransportParameters(ev.TransportParameters)\n\t\t\tclose(s.earlyConnReadyChan)\n\t\tcase handshake.EventReceivedReadKeys:\n\t\t\t// Queue all packets for decryption that have been undecryptable so far.\n\t\t\ts.undecryptablePacketsToProcess = s.undecryptablePackets\n\t\t\ts.undecryptablePackets = nil\n\t\tcase handshake.EventDiscard0RTTKeys:\n\t\t\terr = s.dropEncryptionLevel(protocol.Encryption0RTT)\n\t\tcase handshake.EventWriteInitialData:\n\t\t\t_, err = s.initialStream.Write(ev.Data)\n\t\tcase handshake.EventWriteHandshakeData:\n\t\t\t_, err = s.handshakeStream.Write(ev.Data)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\nfunc (s *connection) handleStreamFrame(frame *wire.StreamFrame, rcvTime time.Time) error {\n\tstr, err := s.streamsMap.GetOrOpenReceiveStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil { // stream was already closed and garbage collected\n\t\treturn nil\n\t}\n\treturn str.handleStreamFrame(frame, rcvTime)\n}\n\nfunc (s *connection) handleMaxDataFrame(frame *wire.MaxDataFrame) {\n\ts.connFlowController.UpdateSendWindow(frame.MaximumData)\n}\n\nfunc (s *connection) handleMaxStreamDataFrame(frame *wire.MaxStreamDataFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenSendStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\tstr.updateSendWindow(frame.MaximumStreamData)\n\treturn nil\n}\n\nfunc (s *connection) handleStreamDataBlockedFrame(frame *wire.StreamDataBlockedFrame) error {\n\t// We don't need to do anything in response to a STREAM_DATA_BLOCKED frame,\n\t// but we need to make sure that the stream ID is valid.\n\t_, err := s.streamsMap.GetOrOpenReceiveStream(frame.StreamID)\n\treturn err\n}\n\nfunc (s *connection) handleMaxStreamsFrame(frame *wire.MaxStreamsFrame) {\n\ts.streamsMap.HandleMaxStreamsFrame(frame)\n}\n\nfunc (s *connection) handleResetStreamFrame(frame *wire.ResetStreamFrame, rcvTime time.Time) error {\n\tstr, err := s.streamsMap.GetOrOpenReceiveStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\treturn str.handleResetStreamFrame(frame, rcvTime)\n}\n\nfunc (s *connection) handleStopSendingFrame(frame *wire.StopSendingFrame) error {\n\tstr, err := s.streamsMap.GetOrOpenSendStream(frame.StreamID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif str == nil {\n\t\t// stream is closed and already garbage collected\n\t\treturn nil\n\t}\n\tstr.handleStopSendingFrame(frame)\n\treturn nil\n}\n\nfunc (s *connection) handlePathChallengeFrame(frame *wire.PathChallengeFrame) {\n\ts.queueControlFrame(&wire.PathResponseFrame{Data: frame.Data})\n}\n\nfunc (s *connection) handleNewTokenFrame(frame *wire.NewTokenFrame) error {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"received NEW_TOKEN frame from the client\",\n\t\t}\n\t}\n\tif s.config.TokenStore != nil {\n\t\ts.config.TokenStore.Put(s.tokenStoreKey, &ClientToken{data: frame.Token})\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handleNewConnectionIDFrame(f *wire.NewConnectionIDFrame) error {\n\treturn s.connIDManager.Add(f)\n}\n\nfunc (s *connection) handleRetireConnectionIDFrame(f *wire.RetireConnectionIDFrame, destConnID protocol.ConnectionID) error {\n\treturn s.connIDGenerator.Retire(f.SequenceNumber, destConnID)\n}\n\nfunc (s *connection) handleHandshakeDoneFrame() error {\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"received a HANDSHAKE_DONE frame\",\n\t\t}\n\t}\n\tif !s.handshakeConfirmed {\n\t\treturn s.handleHandshakeConfirmed()\n\t}\n\treturn nil\n}\n\nfunc (s *connection) handleAckFrame(frame *wire.AckFrame, encLevel protocol.EncryptionLevel) error {\n\tacked1RTTPacket, err := s.sentPacketHandler.ReceivedAck(frame, encLevel, s.lastPacketReceivedTime)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !acked1RTTPacket {\n\t\treturn nil\n\t}\n\t// On the client side: If the packet acknowledged a 1-RTT packet, this confirms the handshake.\n\t// This is only possible if the ACK was sent in a 1-RTT packet.\n\t// This is an optimization over simply waiting for a HANDSHAKE_DONE frame, see section 4.1.2 of RFC 9001.\n\tif s.perspective == protocol.PerspectiveClient && !s.handshakeConfirmed {\n\t\tif err := s.handleHandshakeConfirmed(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn s.cryptoStreamHandler.SetLargest1RTTAcked(frame.LargestAcked())\n}\n\nfunc (s *connection) handleDatagramFrame(f *wire.DatagramFrame) error {\n\tif f.Length(s.version) > wire.MaxDatagramSize {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"DATAGRAM frame too large\",\n\t\t}\n\t}\n\ts.datagramQueue.HandleDatagramFrame(f)\n\treturn nil\n}\n\n// closeLocal closes the connection and send a CONNECTION_CLOSE containing the error\nfunc (s *connection) closeLocal(e error) {\n\ts.closeOnce.Do(func() {\n\t\tif e == nil {\n\t\t\ts.logger.Infof(\"Closing connection.\")\n\t\t} else {\n\t\t\ts.logger.Errorf(\"Closing connection with error: %s\", e)\n\t\t}\n\t\ts.closeChan <- closeError{err: e, immediate: false, remote: false}\n\t})\n}\n\n// destroy closes the connection without sending the error on the wire\nfunc (s *connection) destroy(e error) {\n\ts.destroyImpl(e)\n\t<-s.ctx.Done()\n}\n\nfunc (s *connection) destroyImpl(e error) {\n\ts.closeOnce.Do(func() {\n\t\tif nerr, ok := e.(net.Error); ok && nerr.Timeout() {\n\t\t\ts.logger.Errorf(\"Destroying connection: %s\", e)\n\t\t} else {\n\t\t\ts.logger.Errorf(\"Destroying connection with error: %s\", e)\n\t\t}\n\t\ts.closeChan <- closeError{err: e, immediate: true, remote: false}\n\t})\n}\n\nfunc (s *connection) closeRemote(e error) {\n\ts.closeOnce.Do(func() {\n\t\ts.logger.Errorf(\"Peer closed connection with error: %s\", e)\n\t\ts.closeChan <- closeError{err: e, immediate: true, remote: true}\n\t})\n}\n\nfunc (s *connection) CloseWithError(code ApplicationErrorCode, desc string) error {\n\ts.closeLocal(&qerr.ApplicationError{\n\t\tErrorCode:    code,\n\t\tErrorMessage: desc,\n\t})\n\t<-s.ctx.Done()\n\treturn nil\n}\n\nfunc (s *connection) closeWithTransportError(code TransportErrorCode) {\n\ts.closeLocal(&qerr.TransportError{ErrorCode: code})\n\t<-s.ctx.Done()\n}\n\nfunc (s *connection) handleCloseError(closeErr *closeError) {\n\te := closeErr.err\n\tif e == nil {\n\t\te = &qerr.ApplicationError{}\n\t} else {\n\t\tdefer func() {\n\t\t\tcloseErr.err = e\n\t\t}()\n\t}\n\n\tvar (\n\t\tstatelessResetErr     *StatelessResetError\n\t\tversionNegotiationErr *VersionNegotiationError\n\t\trecreateErr           *errCloseForRecreating\n\t\tapplicationErr        *ApplicationError\n\t\ttransportErr          *TransportError\n\t)\n\tswitch {\n\tcase errors.Is(e, qerr.ErrIdleTimeout),\n\t\terrors.Is(e, qerr.ErrHandshakeTimeout),\n\t\terrors.As(e, &statelessResetErr),\n\t\terrors.As(e, &versionNegotiationErr),\n\t\terrors.As(e, &recreateErr),\n\t\terrors.As(e, &applicationErr),\n\t\terrors.As(e, &transportErr):\n\tdefault:\n\t\te = &qerr.TransportError{\n\t\t\tErrorCode:    qerr.InternalError,\n\t\t\tErrorMessage: e.Error(),\n\t\t}\n\t}\n\n\ts.streamsMap.CloseWithError(e)\n\ts.connIDManager.Close()\n\tif s.datagramQueue != nil {\n\t\ts.datagramQueue.CloseWithError(e)\n\t}\n\n\tif s.tracer != nil && s.tracer.ClosedConnection != nil && !errors.As(e, &recreateErr) {\n\t\ts.tracer.ClosedConnection(e)\n\t}\n\n\t// If this is a remote close we're done here\n\tif closeErr.remote {\n\t\ts.connIDGenerator.ReplaceWithClosed(nil)\n\t\treturn\n\t}\n\tif closeErr.immediate {\n\t\ts.connIDGenerator.RemoveAll()\n\t\treturn\n\t}\n\t// Don't send out any CONNECTION_CLOSE if this is an error that occurred\n\t// before we even sent out the first packet.\n\tif s.perspective == protocol.PerspectiveClient && !s.sentFirstPacket {\n\t\ts.connIDGenerator.RemoveAll()\n\t\treturn\n\t}\n\tconnClosePacket, err := s.sendConnectionClose(e)\n\tif err != nil {\n\t\ts.logger.Debugf(\"Error sending CONNECTION_CLOSE: %s\", err)\n\t}\n\ts.connIDGenerator.ReplaceWithClosed(connClosePacket)\n}\n\nfunc (s *connection) dropEncryptionLevel(encLevel protocol.EncryptionLevel) error {\n\tif s.tracer != nil && s.tracer.DroppedEncryptionLevel != nil {\n\t\ts.tracer.DroppedEncryptionLevel(encLevel)\n\t}\n\ts.sentPacketHandler.DropPackets(encLevel)\n\ts.receivedPacketHandler.DropPackets(encLevel)\n\t//nolint:exhaustive // only Initial and 0-RTT need special treatment\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\ts.droppedInitialKeys = true\n\t\ts.cryptoStreamHandler.DiscardInitialKeys()\n\tcase protocol.Encryption0RTT:\n\t\ts.streamsMap.ResetFor0RTT()\n\t\ts.framer.Handle0RTTRejection()\n\t\treturn s.connFlowController.Reset()\n\t}\n\treturn s.cryptoStreamManager.Drop(encLevel)\n}\n\n// is called for the client, when restoring transport parameters saved for 0-RTT\nfunc (s *connection) restoreTransportParameters(params *wire.TransportParameters) {\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Restoring Transport Parameters: %s\", params)\n\t}\n\n\ts.peerParams = params\n\ts.connIDGenerator.SetMaxActiveConnIDs(params.ActiveConnectionIDLimit)\n\ts.connFlowController.UpdateSendWindow(params.InitialMaxData)\n\ts.streamsMap.UpdateLimits(params)\n\ts.connStateMutex.Lock()\n\ts.connState.SupportsDatagrams = s.supportsDatagrams()\n\ts.connStateMutex.Unlock()\n}\n\nfunc (s *connection) handleTransportParameters(params *wire.TransportParameters) error {\n\tif s.tracer != nil && s.tracer.ReceivedTransportParameters != nil {\n\t\ts.tracer.ReceivedTransportParameters(params)\n\t}\n\tif err := s.checkTransportParameters(params); err != nil {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.TransportParameterError,\n\t\t\tErrorMessage: err.Error(),\n\t\t}\n\t}\n\n\tif s.perspective == protocol.PerspectiveClient && s.peerParams != nil && s.ConnectionState().Used0RTT && !params.ValidForUpdate(s.peerParams) {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"server sent reduced limits after accepting 0-RTT data\",\n\t\t}\n\t}\n\n\ts.peerParams = params\n\t// On the client side we have to wait for handshake completion.\n\t// During a 0-RTT connection, we are only allowed to use the new transport parameters for 1-RTT packets.\n\tif s.perspective == protocol.PerspectiveServer {\n\t\ts.applyTransportParameters()\n\t\t// On the server side, the early connection is ready as soon as we processed\n\t\t// the client's transport parameters.\n\t\tclose(s.earlyConnReadyChan)\n\t}\n\n\ts.connStateMutex.Lock()\n\ts.connState.SupportsDatagrams = s.supportsDatagrams()\n\ts.connStateMutex.Unlock()\n\treturn nil\n}\n\nfunc (s *connection) checkTransportParameters(params *wire.TransportParameters) error {\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Processed Transport Parameters: %s\", params)\n\t}\n\n\t// check the initial_source_connection_id\n\tif params.InitialSourceConnectionID != s.handshakeDestConnID {\n\t\treturn fmt.Errorf(\"expected initial_source_connection_id to equal %s, is %s\", s.handshakeDestConnID, params.InitialSourceConnectionID)\n\t}\n\n\tif s.perspective == protocol.PerspectiveServer {\n\t\treturn nil\n\t}\n\t// check the original_destination_connection_id\n\tif params.OriginalDestinationConnectionID != s.origDestConnID {\n\t\treturn fmt.Errorf(\"expected original_destination_connection_id to equal %s, is %s\", s.origDestConnID, params.OriginalDestinationConnectionID)\n\t}\n\tif s.retrySrcConnID != nil { // a Retry was performed\n\t\tif params.RetrySourceConnectionID == nil {\n\t\t\treturn errors.New(\"missing retry_source_connection_id\")\n\t\t}\n\t\tif *params.RetrySourceConnectionID != *s.retrySrcConnID {\n\t\t\treturn fmt.Errorf(\"expected retry_source_connection_id to equal %s, is %s\", s.retrySrcConnID, *params.RetrySourceConnectionID)\n\t\t}\n\t} else if params.RetrySourceConnectionID != nil {\n\t\treturn errors.New(\"received retry_source_connection_id, although no Retry was performed\")\n\t}\n\treturn nil\n}\n\nfunc (s *connection) applyTransportParameters() {\n\tparams := s.peerParams\n\t// Our local idle timeout will always be > 0.\n\ts.idleTimeout = s.config.MaxIdleTimeout\n\t// If the peer advertised an idle timeout, take the minimum of the values.\n\tif params.MaxIdleTimeout > 0 {\n\t\ts.idleTimeout = min(s.idleTimeout, params.MaxIdleTimeout)\n\t}\n\ts.keepAliveInterval = min(s.config.KeepAlivePeriod, s.idleTimeout/2)\n\ts.streamsMap.UpdateLimits(params)\n\ts.frameParser.SetAckDelayExponent(params.AckDelayExponent)\n\ts.connFlowController.UpdateSendWindow(params.InitialMaxData)\n\ts.rttStats.SetMaxAckDelay(params.MaxAckDelay)\n\ts.connIDGenerator.SetMaxActiveConnIDs(params.ActiveConnectionIDLimit)\n\tif params.StatelessResetToken != nil {\n\t\ts.connIDManager.SetStatelessResetToken(*params.StatelessResetToken)\n\t}\n\t// We don't support connection migration yet, so we don't have any use for the preferred_address.\n\tif params.PreferredAddress != nil {\n\t\t// Retire the connection ID.\n\t\ts.connIDManager.AddFromPreferredAddress(params.PreferredAddress.ConnectionID, params.PreferredAddress.StatelessResetToken)\n\t}\n\tmaxPacketSize := protocol.ByteCount(protocol.MaxPacketBufferSize)\n\tif params.MaxUDPPayloadSize > 0 && params.MaxUDPPayloadSize < maxPacketSize {\n\t\tmaxPacketSize = params.MaxUDPPayloadSize\n\t}\n\ts.mtuDiscoverer = newMTUDiscoverer(\n\t\ts.rttStats,\n\t\tprotocol.ByteCount(s.config.InitialPacketSize),\n\t\tmaxPacketSize,\n\t\ts.onMTUIncreased,\n\t\ts.tracer,\n\t)\n}\n\nfunc (s *connection) triggerSending(now time.Time) error {\n\ts.pacingDeadline = time.Time{}\n\n\tsendMode := s.sentPacketHandler.SendMode(now)\n\t//nolint:exhaustive // No need to handle pacing limited here.\n\tswitch sendMode {\n\tcase ackhandler.SendAny:\n\t\treturn s.sendPackets(now)\n\tcase ackhandler.SendNone:\n\t\treturn nil\n\tcase ackhandler.SendPacingLimited:\n\t\tdeadline := s.sentPacketHandler.TimeUntilSend()\n\t\tif deadline.IsZero() {\n\t\t\tdeadline = deadlineSendImmediately\n\t\t}\n\t\ts.pacingDeadline = deadline\n\t\t// Allow sending of an ACK if we're pacing limit.\n\t\t// This makes sure that a peer that is mostly receiving data (and thus has an inaccurate cwnd estimate)\n\t\t// sends enough ACKs to allow its peer to utilize the bandwidth.\n\t\tfallthrough\n\tcase ackhandler.SendAck:\n\t\t// We can at most send a single ACK only packet.\n\t\t// There will only be a new ACK after receiving new packets.\n\t\t// SendAck is only returned when we're congestion limited, so we don't need to set the pacinggs timer.\n\t\treturn s.maybeSendAckOnlyPacket(now)\n\tcase ackhandler.SendPTOInitial:\n\t\tif err := s.sendProbePacket(protocol.EncryptionInitial, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending(now)\n\tcase ackhandler.SendPTOHandshake:\n\t\tif err := s.sendProbePacket(protocol.EncryptionHandshake, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending(now)\n\tcase ackhandler.SendPTOAppData:\n\t\tif err := s.sendProbePacket(protocol.Encryption1RTT, now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\ts.scheduleSending()\n\t\t\treturn nil\n\t\t}\n\t\treturn s.triggerSending(now)\n\tdefault:\n\t\treturn fmt.Errorf(\"BUG: invalid send mode %d\", sendMode)\n\t}\n}\n\nfunc (s *connection) sendPackets(now time.Time) error {\n\t// Path MTU Discovery\n\t// Can't use GSO, since we need to send a single packet that's larger than our current maximum size.\n\t// Performance-wise, this doesn't matter, since we only send a very small (<10) number of\n\t// MTU probe packets per connection.\n\tif s.handshakeConfirmed && s.mtuDiscoverer != nil && s.mtuDiscoverer.ShouldSendProbe(now) {\n\t\tping, size := s.mtuDiscoverer.GetPing()\n\t\tp, buf, err := s.packer.PackMTUProbePacket(ping, size, s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tecn := s.sentPacketHandler.ECNMode(true)\n\t\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, ecn, buf.Len(), false)\n\t\ts.registerPackedShortHeaderPacket(p, ecn, now)\n\t\ts.sendQueue.Send(buf, 0, ecn)\n\t\t// This is kind of a hack. We need to trigger sending again somehow.\n\t\ts.pacingDeadline = deadlineSendImmediately\n\t\treturn nil\n\t}\n\n\tif offset := s.connFlowController.GetWindowUpdate(now); offset > 0 {\n\t\ts.framer.QueueControlFrame(&wire.MaxDataFrame{MaximumData: offset})\n\t}\n\tif cf := s.cryptoStreamManager.GetPostHandshakeData(protocol.MaxPostHandshakeCryptoFrameSize); cf != nil {\n\t\ts.queueControlFrame(cf)\n\t}\n\n\tif !s.handshakeConfirmed {\n\t\tpacket, err := s.packer.PackCoalescedPacket(false, s.maxPacketSize(), now, s.version)\n\t\tif err != nil || packet == nil {\n\t\t\treturn err\n\t\t}\n\t\ts.sentFirstPacket = true\n\t\tif err := s.sendPackedCoalescedPacket(packet, s.sentPacketHandler.ECNMode(packet.IsOnlyShortHeaderPacket()), now); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\ts.resetPacingDeadline()\n\t\t} else if sendMode == ackhandler.SendAny {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t}\n\t\treturn nil\n\t}\n\n\tif s.conn.capabilities().GSO {\n\t\treturn s.sendPacketsWithGSO(now)\n\t}\n\treturn s.sendPacketsWithoutGSO(now)\n}\n\nfunc (s *connection) sendPacketsWithoutGSO(now time.Time) error {\n\tfor {\n\t\tbuf := getPacketBuffer()\n\t\tecn := s.sentPacketHandler.ECNMode(true)\n\t\tif _, err := s.appendOneShortHeaderPacket(buf, s.maxPacketSize(), ecn, now); err != nil {\n\t\t\tif err == errNothingToPack {\n\t\t\t\tbuf.Release()\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\ts.sendQueue.Send(buf, 0, ecn)\n\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\treturn nil\n\t\t}\n\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\ts.resetPacingDeadline()\n\t\t\treturn nil\n\t\t}\n\t\tif sendMode != ackhandler.SendAny {\n\t\t\treturn nil\n\t\t}\n\t\t// Prioritize receiving of packets over sending out more packets.\n\t\tif len(s.receivedPackets) > 0 {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *connection) sendPacketsWithGSO(now time.Time) error {\n\tbuf := getLargePacketBuffer()\n\tmaxSize := s.maxPacketSize()\n\n\tecn := s.sentPacketHandler.ECNMode(true)\n\tfor {\n\t\tvar dontSendMore bool\n\t\tsize, err := s.appendOneShortHeaderPacket(buf, maxSize, ecn, now)\n\t\tif err != nil {\n\t\t\tif err != errNothingToPack {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif buf.Len() == 0 {\n\t\t\t\tbuf.Release()\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tdontSendMore = true\n\t\t}\n\n\t\tif !dontSendMore {\n\t\t\tsendMode := s.sentPacketHandler.SendMode(now)\n\t\t\tif sendMode == ackhandler.SendPacingLimited {\n\t\t\t\ts.resetPacingDeadline()\n\t\t\t}\n\t\t\tif sendMode != ackhandler.SendAny {\n\t\t\t\tdontSendMore = true\n\t\t\t}\n\t\t}\n\n\t\t// Don't send more packets in this batch if they require a different ECN marking than the previous ones.\n\t\tnextECN := s.sentPacketHandler.ECNMode(true)\n\n\t\t// Append another packet if\n\t\t// 1. The congestion controller and pacer allow sending more\n\t\t// 2. The last packet appended was a full-size packet\n\t\t// 3. The next packet will have the same ECN marking\n\t\t// 4. We still have enough space for another full-size packet in the buffer\n\t\tif !dontSendMore && size == maxSize && nextECN == ecn && buf.Len()+maxSize <= buf.Cap() {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.sendQueue.Send(buf, uint16(maxSize), ecn)\n\n\t\tif dontSendMore {\n\t\t\treturn nil\n\t\t}\n\t\tif s.sendQueue.WouldBlock() {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Prioritize receiving of packets over sending out more packets.\n\t\tif len(s.receivedPackets) > 0 {\n\t\t\ts.pacingDeadline = deadlineSendImmediately\n\t\t\treturn nil\n\t\t}\n\n\t\tecn = nextECN\n\t\tbuf = getLargePacketBuffer()\n\t}\n}\n\nfunc (s *connection) resetPacingDeadline() {\n\tdeadline := s.sentPacketHandler.TimeUntilSend()\n\tif deadline.IsZero() {\n\t\tdeadline = deadlineSendImmediately\n\t}\n\ts.pacingDeadline = deadline\n}\n\nfunc (s *connection) maybeSendAckOnlyPacket(now time.Time) error {\n\tif !s.handshakeConfirmed {\n\t\tecn := s.sentPacketHandler.ECNMode(false)\n\t\tpacket, err := s.packer.PackCoalescedPacket(true, s.maxPacketSize(), now, s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif packet == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn s.sendPackedCoalescedPacket(packet, ecn, now)\n\t}\n\n\tecn := s.sentPacketHandler.ECNMode(true)\n\tp, buf, err := s.packer.PackAckOnlyPacket(s.maxPacketSize(), now, s.version)\n\tif err != nil {\n\t\tif err == errNothingToPack {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, ecn, buf.Len(), false)\n\ts.registerPackedShortHeaderPacket(p, ecn, now)\n\ts.sendQueue.Send(buf, 0, ecn)\n\treturn nil\n}\n\nfunc (s *connection) sendProbePacket(encLevel protocol.EncryptionLevel, now time.Time) error {\n\t// Queue probe packets until we actually send out a packet,\n\t// or until there are no more packets to queue.\n\tvar packet *coalescedPacket\n\tfor {\n\t\tif wasQueued := s.sentPacketHandler.QueueProbePacket(encLevel); !wasQueued {\n\t\t\tbreak\n\t\t}\n\t\tvar err error\n\t\tpacket, err = s.packer.MaybePackProbePacket(encLevel, s.maxPacketSize(), now, s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif packet != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\tif packet == nil {\n\t\ts.retransmissionQueue.AddPing(encLevel)\n\t\tvar err error\n\t\tpacket, err = s.packer.MaybePackProbePacket(encLevel, s.maxPacketSize(), now, s.version)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif packet == nil || (len(packet.longHdrPackets) == 0 && packet.shortHdrPacket == nil) {\n\t\treturn fmt.Errorf(\"connection BUG: couldn't pack %s probe packet\", encLevel)\n\t}\n\treturn s.sendPackedCoalescedPacket(packet, s.sentPacketHandler.ECNMode(packet.IsOnlyShortHeaderPacket()), now)\n}\n\n// appendOneShortHeaderPacket appends a new packet to the given packetBuffer.\n// If there was nothing to pack, the returned size is 0.\nfunc (s *connection) appendOneShortHeaderPacket(buf *packetBuffer, maxSize protocol.ByteCount, ecn protocol.ECN, now time.Time) (protocol.ByteCount, error) {\n\tstartLen := buf.Len()\n\tp, err := s.packer.AppendPacket(buf, maxSize, now, s.version)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tsize := buf.Len() - startLen\n\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, ecn, size, false)\n\ts.registerPackedShortHeaderPacket(p, ecn, now)\n\treturn size, nil\n}\n\nfunc (s *connection) registerPackedShortHeaderPacket(p shortHeaderPacket, ecn protocol.ECN, now time.Time) {\n\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && (len(p.StreamFrames) > 0 || ackhandler.HasAckElicitingFrames(p.Frames)) {\n\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t}\n\n\tlargestAcked := protocol.InvalidPacketNumber\n\tif p.Ack != nil {\n\t\tlargestAcked = p.Ack.LargestAcked()\n\t}\n\ts.sentPacketHandler.SentPacket(now, p.PacketNumber, largestAcked, p.StreamFrames, p.Frames, protocol.Encryption1RTT, ecn, p.Length, p.IsPathMTUProbePacket)\n\ts.connIDManager.SentPacket()\n}\n\nfunc (s *connection) sendPackedCoalescedPacket(packet *coalescedPacket, ecn protocol.ECN, now time.Time) error {\n\ts.logCoalescedPacket(packet, ecn)\n\tfor _, p := range packet.longHdrPackets {\n\t\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && p.IsAckEliciting() {\n\t\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t\t}\n\t\tlargestAcked := protocol.InvalidPacketNumber\n\t\tif p.ack != nil {\n\t\t\tlargestAcked = p.ack.LargestAcked()\n\t\t}\n\t\ts.sentPacketHandler.SentPacket(now, p.header.PacketNumber, largestAcked, p.streamFrames, p.frames, p.EncryptionLevel(), ecn, p.length, false)\n\t\tif s.perspective == protocol.PerspectiveClient && p.EncryptionLevel() == protocol.EncryptionHandshake &&\n\t\t\t!s.droppedInitialKeys {\n\t\t\t// On the client side, Initial keys are dropped as soon as the first Handshake packet is sent.\n\t\t\t// See Section 4.9.1 of RFC 9001.\n\t\t\tif err := s.dropEncryptionLevel(protocol.EncryptionInitial); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif p := packet.shortHdrPacket; p != nil {\n\t\tif s.firstAckElicitingPacketAfterIdleSentTime.IsZero() && p.IsAckEliciting() {\n\t\t\ts.firstAckElicitingPacketAfterIdleSentTime = now\n\t\t}\n\t\tlargestAcked := protocol.InvalidPacketNumber\n\t\tif p.Ack != nil {\n\t\t\tlargestAcked = p.Ack.LargestAcked()\n\t\t}\n\t\ts.sentPacketHandler.SentPacket(now, p.PacketNumber, largestAcked, p.StreamFrames, p.Frames, protocol.Encryption1RTT, ecn, p.Length, p.IsPathMTUProbePacket)\n\t}\n\ts.connIDManager.SentPacket()\n\ts.sendQueue.Send(packet.buffer, 0, ecn)\n\treturn nil\n}\n\nfunc (s *connection) sendConnectionClose(e error) ([]byte, error) {\n\tvar packet *coalescedPacket\n\tvar err error\n\tvar transportErr *qerr.TransportError\n\tvar applicationErr *qerr.ApplicationError\n\tif errors.As(e, &transportErr) {\n\t\tpacket, err = s.packer.PackConnectionClose(transportErr, s.maxPacketSize(), s.version)\n\t} else if errors.As(e, &applicationErr) {\n\t\tpacket, err = s.packer.PackApplicationClose(applicationErr, s.maxPacketSize(), s.version)\n\t} else {\n\t\tpacket, err = s.packer.PackConnectionClose(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.InternalError,\n\t\t\tErrorMessage: fmt.Sprintf(\"connection BUG: unspecified error type (msg: %s)\", e.Error()),\n\t\t}, s.maxPacketSize(), s.version)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tecn := s.sentPacketHandler.ECNMode(packet.IsOnlyShortHeaderPacket())\n\ts.logCoalescedPacket(packet, ecn)\n\treturn packet.buffer.Data, s.conn.Write(packet.buffer.Data, 0, ecn)\n}\n\nfunc (s *connection) maxPacketSize() protocol.ByteCount {\n\tif s.mtuDiscoverer == nil {\n\t\t// Use the configured packet size on the client side.\n\t\t// If the server sends a max_udp_payload_size that's smaller than this size, we can ignore this:\n\t\t// Apparently the server still processed the (fully padded) Initial packet anyway.\n\t\tif s.perspective == protocol.PerspectiveClient {\n\t\t\treturn protocol.ByteCount(s.config.InitialPacketSize)\n\t\t}\n\t\t// On the server side, there's no downside to using 1200 bytes until we received the client's transport\n\t\t// parameters:\n\t\t// * If the first packet didn't contain the entire ClientHello, all we can do is ACK that packet. We don't\n\t\t//   need a lot of bytes for that.\n\t\t// * If it did, we will have processed the transport parameters and initialized the MTU discoverer.\n\t\treturn protocol.MinInitialPacketSize\n\t}\n\treturn s.mtuDiscoverer.CurrentSize()\n}\n\n// AcceptStream returns the next stream openend by the peer\nfunc (s *connection) AcceptStream(ctx context.Context) (Stream, error) {\n\treturn s.streamsMap.AcceptStream(ctx)\n}\n\nfunc (s *connection) AcceptUniStream(ctx context.Context) (ReceiveStream, error) {\n\treturn s.streamsMap.AcceptUniStream(ctx)\n}\n\n// OpenStream opens a stream\nfunc (s *connection) OpenStream() (Stream, error) {\n\treturn s.streamsMap.OpenStream()\n}\n\nfunc (s *connection) OpenStreamSync(ctx context.Context) (Stream, error) {\n\treturn s.streamsMap.OpenStreamSync(ctx)\n}\n\nfunc (s *connection) OpenUniStream() (SendStream, error) {\n\treturn s.streamsMap.OpenUniStream()\n}\n\nfunc (s *connection) OpenUniStreamSync(ctx context.Context) (SendStream, error) {\n\treturn s.streamsMap.OpenUniStreamSync(ctx)\n}\n\nfunc (s *connection) newFlowController(id protocol.StreamID) flowcontrol.StreamFlowController {\n\tinitialSendWindow := s.peerParams.InitialMaxStreamDataUni\n\tif id.Type() == protocol.StreamTypeBidi {\n\t\tif id.InitiatedBy() == s.perspective {\n\t\t\tinitialSendWindow = s.peerParams.InitialMaxStreamDataBidiRemote\n\t\t} else {\n\t\t\tinitialSendWindow = s.peerParams.InitialMaxStreamDataBidiLocal\n\t\t}\n\t}\n\treturn flowcontrol.NewStreamFlowController(\n\t\tid,\n\t\ts.connFlowController,\n\t\tprotocol.ByteCount(s.config.InitialStreamReceiveWindow),\n\t\tprotocol.ByteCount(s.config.MaxStreamReceiveWindow),\n\t\tinitialSendWindow,\n\t\ts.rttStats,\n\t\ts.logger,\n\t)\n}\n\n// scheduleSending signals that we have data for sending\nfunc (s *connection) scheduleSending() {\n\tselect {\n\tcase s.sendingScheduled <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// tryQueueingUndecryptablePacket queues a packet for which we're missing the decryption keys.\n// The logging.PacketType is only used for logging purposes.\nfunc (s *connection) tryQueueingUndecryptablePacket(p receivedPacket, pt logging.PacketType) {\n\tif s.handshakeComplete {\n\t\tpanic(\"shouldn't queue undecryptable packets after handshake completion\")\n\t}\n\tif len(s.undecryptablePackets)+1 > protocol.MaxUndecryptablePackets {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(pt, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t\ts.logger.Infof(\"Dropping undecryptable packet (%d bytes). Undecryptable packet queue full.\", p.Size())\n\t\treturn\n\t}\n\ts.logger.Infof(\"Queueing packet (%d bytes) for later decryption\", p.Size())\n\tif s.tracer != nil && s.tracer.BufferedPacket != nil {\n\t\ts.tracer.BufferedPacket(pt, p.Size())\n\t}\n\ts.undecryptablePackets = append(s.undecryptablePackets, p)\n}\n\nfunc (s *connection) queueControlFrame(f wire.Frame) {\n\ts.framer.QueueControlFrame(f)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasConnectionData() { s.scheduleSending() }\n\nfunc (s *connection) onHasStreamData(id protocol.StreamID, str sendStreamI) {\n\ts.framer.AddActiveStream(id, str)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onHasStreamControlFrame(id protocol.StreamID, str streamControlFrameGetter) {\n\ts.framer.AddStreamWithControlFrames(id, str)\n\ts.scheduleSending()\n}\n\nfunc (s *connection) onStreamCompleted(id protocol.StreamID) {\n\tif err := s.streamsMap.DeleteStream(id); err != nil {\n\t\ts.closeLocal(err)\n\t}\n\ts.framer.RemoveActiveStream(id)\n}\n\nfunc (s *connection) onMTUIncreased(mtu protocol.ByteCount) {\n\ts.maxPayloadSizeEstimate.Store(uint32(estimateMaxPayloadSize(mtu)))\n\ts.sentPacketHandler.SetMaxDatagramSize(mtu)\n}\n\nfunc (s *connection) SendDatagram(p []byte) error {\n\tif !s.supportsDatagrams() {\n\t\treturn errors.New(\"datagram support disabled\")\n\t}\n\n\tf := &wire.DatagramFrame{DataLenPresent: true}\n\t// The payload size estimate is conservative.\n\t// Under many circumstances we could send a few more bytes.\n\tmaxDataLen := min(\n\t\tf.MaxDataLen(s.peerParams.MaxDatagramFrameSize, s.version),\n\t\tprotocol.ByteCount(s.maxPayloadSizeEstimate.Load()),\n\t)\n\tif protocol.ByteCount(len(p)) > maxDataLen {\n\t\treturn &DatagramTooLargeError{MaxDatagramPayloadSize: int64(maxDataLen)}\n\t}\n\tf.Data = make([]byte, len(p))\n\tcopy(f.Data, p)\n\treturn s.datagramQueue.Add(f)\n}\n\nfunc (s *connection) ReceiveDatagram(ctx context.Context) ([]byte, error) {\n\tif !s.config.EnableDatagrams {\n\t\treturn nil, errors.New(\"datagram support disabled\")\n\t}\n\treturn s.datagramQueue.Receive(ctx)\n}\n\nfunc (s *connection) LocalAddr() net.Addr  { return s.conn.LocalAddr() }\nfunc (s *connection) RemoteAddr() net.Addr { return s.conn.RemoteAddr() }\n\nfunc (s *connection) NextConnection(ctx context.Context) (Connection, error) {\n\t// The handshake might fail after the server rejected 0-RTT.\n\t// This could happen if the Finished message is malformed or never received.\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, context.Cause(ctx)\n\tcase <-s.Context().Done():\n\tcase <-s.HandshakeComplete():\n\t\ts.streamsMap.UseResetMaps()\n\t}\n\treturn s, nil\n}\n\n// estimateMaxPayloadSize estimates the maximum payload size for short header packets.\n// It is not very sophisticated: it just subtracts the size of header (assuming the maximum\n// connection ID length), and the size of the encryption tag.\nfunc estimateMaxPayloadSize(mtu protocol.ByteCount) protocol.ByteCount {\n\treturn mtu - 1 /* type byte */ - 20 /* maximum connection ID length */ - 16 /* tag size */\n}\n"
        },
        {
          "name": "connection_logging.go",
          "type": "blob",
          "size": 4.8974609375,
          "content": "package quic\n\nimport (\n\t\"slices\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\n// ConvertFrame converts a wire.Frame into a logging.Frame.\n// This makes it possible for external packages to access the frames.\n// Furthermore, it removes the data slices from CRYPTO and STREAM frames.\nfunc toLoggingFrame(frame wire.Frame) logging.Frame {\n\tswitch f := frame.(type) {\n\tcase *wire.AckFrame:\n\t\t// We use a pool for ACK frames.\n\t\t// Implementations of the tracer interface may hold on to frames, so we need to make a copy here.\n\t\treturn toLoggingAckFrame(f)\n\tcase *wire.CryptoFrame:\n\t\treturn &logging.CryptoFrame{\n\t\t\tOffset: f.Offset,\n\t\t\tLength: protocol.ByteCount(len(f.Data)),\n\t\t}\n\tcase *wire.StreamFrame:\n\t\treturn &logging.StreamFrame{\n\t\t\tStreamID: f.StreamID,\n\t\t\tOffset:   f.Offset,\n\t\t\tLength:   f.DataLen(),\n\t\t\tFin:      f.Fin,\n\t\t}\n\tcase *wire.DatagramFrame:\n\t\treturn &logging.DatagramFrame{\n\t\t\tLength: logging.ByteCount(len(f.Data)),\n\t\t}\n\tdefault:\n\t\treturn logging.Frame(frame)\n\t}\n}\n\nfunc toLoggingAckFrame(f *wire.AckFrame) *logging.AckFrame {\n\tack := &logging.AckFrame{\n\t\tAckRanges: slices.Clone(f.AckRanges),\n\t\tDelayTime: f.DelayTime,\n\t\tECNCE:     f.ECNCE,\n\t\tECT0:      f.ECT0,\n\t\tECT1:      f.ECT1,\n\t}\n\treturn ack\n}\n\nfunc (s *connection) logLongHeaderPacket(p *longHeaderPacket, ecn protocol.ECN) {\n\t// quic-go logging\n\tif s.logger.Debug() {\n\t\tp.header.Log(s.logger)\n\t\tif p.ack != nil {\n\t\t\twire.LogFrame(s.logger, p.ack, true)\n\t\t}\n\t\tfor _, frame := range p.frames {\n\t\t\twire.LogFrame(s.logger, frame.Frame, true)\n\t\t}\n\t\tfor _, frame := range p.streamFrames {\n\t\t\twire.LogFrame(s.logger, frame.Frame, true)\n\t\t}\n\t}\n\n\t// tracing\n\tif s.tracer != nil && s.tracer.SentLongHeaderPacket != nil {\n\t\tframes := make([]logging.Frame, 0, len(p.frames))\n\t\tfor _, f := range p.frames {\n\t\t\tframes = append(frames, toLoggingFrame(f.Frame))\n\t\t}\n\t\tfor _, f := range p.streamFrames {\n\t\t\tframes = append(frames, toLoggingFrame(f.Frame))\n\t\t}\n\t\tvar ack *logging.AckFrame\n\t\tif p.ack != nil {\n\t\t\tack = toLoggingAckFrame(p.ack)\n\t\t}\n\t\ts.tracer.SentLongHeaderPacket(p.header, p.length, ecn, ack, frames)\n\t}\n}\n\nfunc (s *connection) logShortHeaderPacket(\n\tdestConnID protocol.ConnectionID,\n\tackFrame *wire.AckFrame,\n\tframes []ackhandler.Frame,\n\tstreamFrames []ackhandler.StreamFrame,\n\tpn protocol.PacketNumber,\n\tpnLen protocol.PacketNumberLen,\n\tkp protocol.KeyPhaseBit,\n\tecn protocol.ECN,\n\tsize protocol.ByteCount,\n\tisCoalesced bool,\n) {\n\tif s.logger.Debug() && !isCoalesced {\n\t\ts.logger.Debugf(\"-> Sending packet %d (%d bytes) for connection %s, 1-RTT (ECN: %s)\", pn, size, s.logID, ecn)\n\t}\n\t// quic-go logging\n\tif s.logger.Debug() {\n\t\twire.LogShortHeader(s.logger, destConnID, pn, pnLen, kp)\n\t\tif ackFrame != nil {\n\t\t\twire.LogFrame(s.logger, ackFrame, true)\n\t\t}\n\t\tfor _, f := range frames {\n\t\t\twire.LogFrame(s.logger, f.Frame, true)\n\t\t}\n\t\tfor _, f := range streamFrames {\n\t\t\twire.LogFrame(s.logger, f.Frame, true)\n\t\t}\n\t}\n\n\t// tracing\n\tif s.tracer != nil && s.tracer.SentShortHeaderPacket != nil {\n\t\tfs := make([]logging.Frame, 0, len(frames)+len(streamFrames))\n\t\tfor _, f := range frames {\n\t\t\tfs = append(fs, toLoggingFrame(f.Frame))\n\t\t}\n\t\tfor _, f := range streamFrames {\n\t\t\tfs = append(fs, toLoggingFrame(f.Frame))\n\t\t}\n\t\tvar ack *logging.AckFrame\n\t\tif ackFrame != nil {\n\t\t\tack = toLoggingAckFrame(ackFrame)\n\t\t}\n\t\ts.tracer.SentShortHeaderPacket(\n\t\t\t&logging.ShortHeader{DestConnectionID: destConnID, PacketNumber: pn, PacketNumberLen: pnLen, KeyPhase: kp},\n\t\t\tsize,\n\t\t\tecn,\n\t\t\tack,\n\t\t\tfs,\n\t\t)\n\t}\n}\n\nfunc (s *connection) logCoalescedPacket(packet *coalescedPacket, ecn protocol.ECN) {\n\tif s.logger.Debug() {\n\t\t// There's a short period between dropping both Initial and Handshake keys and completion of the handshake,\n\t\t// during which we might call PackCoalescedPacket but just pack a short header packet.\n\t\tif len(packet.longHdrPackets) == 0 && packet.shortHdrPacket != nil {\n\t\t\ts.logShortHeaderPacket(\n\t\t\t\tpacket.shortHdrPacket.DestConnID,\n\t\t\t\tpacket.shortHdrPacket.Ack,\n\t\t\t\tpacket.shortHdrPacket.Frames,\n\t\t\t\tpacket.shortHdrPacket.StreamFrames,\n\t\t\t\tpacket.shortHdrPacket.PacketNumber,\n\t\t\t\tpacket.shortHdrPacket.PacketNumberLen,\n\t\t\t\tpacket.shortHdrPacket.KeyPhase,\n\t\t\t\tecn,\n\t\t\t\tpacket.shortHdrPacket.Length,\n\t\t\t\tfalse,\n\t\t\t)\n\t\t\treturn\n\t\t}\n\t\tif len(packet.longHdrPackets) > 1 {\n\t\t\ts.logger.Debugf(\"-> Sending coalesced packet (%d parts, %d bytes) for connection %s\", len(packet.longHdrPackets), packet.buffer.Len(), s.logID)\n\t\t} else {\n\t\t\ts.logger.Debugf(\"-> Sending packet %d (%d bytes) for connection %s, %s\", packet.longHdrPackets[0].header.PacketNumber, packet.buffer.Len(), s.logID, packet.longHdrPackets[0].EncryptionLevel())\n\t\t}\n\t}\n\tfor _, p := range packet.longHdrPackets {\n\t\ts.logLongHeaderPacket(p, ecn)\n\t}\n\tif p := packet.shortHdrPacket; p != nil {\n\t\ts.logShortHeaderPacket(p.DestConnID, p.Ack, p.Frames, p.StreamFrames, p.PacketNumber, p.PacketNumberLen, p.KeyPhase, ecn, p.Length, true)\n\t}\n}\n"
        },
        {
          "name": "connection_logging_test.go",
          "type": "blob",
          "size": 1.6083984375,
          "content": "package quic\n\nimport (\n\t\"testing\"\n\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestConnectionLoggingCryptoFrame(t *testing.T) {\n\tf := toLoggingFrame(&wire.CryptoFrame{\n\t\tOffset: 1234,\n\t\tData:   []byte(\"foobar\"),\n\t})\n\trequire.Equal(t, &logging.CryptoFrame{\n\t\tOffset: 1234,\n\t\tLength: 6,\n\t}, f)\n}\n\nfunc TestConnectionLoggingStreamFrame(t *testing.T) {\n\tf := toLoggingFrame(&wire.StreamFrame{\n\t\tStreamID: 42,\n\t\tOffset:   1234,\n\t\tData:     []byte(\"foo\"),\n\t\tFin:      true,\n\t})\n\trequire.Equal(t, &logging.StreamFrame{\n\t\tStreamID: 42,\n\t\tOffset:   1234,\n\t\tLength:   3,\n\t\tFin:      true,\n\t}, f)\n}\n\nfunc TestConnectionLoggingAckFrame(t *testing.T) {\n\tack := &wire.AckFrame{\n\t\tAckRanges: []wire.AckRange{\n\t\t\t{Smallest: 1, Largest: 3},\n\t\t\t{Smallest: 6, Largest: 7},\n\t\t},\n\t\tDelayTime: 42,\n\t\tECNCE:     123,\n\t\tECT0:      456,\n\t\tECT1:      789,\n\t}\n\tf := toLoggingFrame(ack)\n\t// now modify the ACK range in the original frame\n\tack.AckRanges[0].Smallest = 2\n\trequire.Equal(t, &logging.AckFrame{\n\t\tAckRanges: []wire.AckRange{\n\t\t\t{Smallest: 1, Largest: 3}, // unchanged, since the ACK ranges were cloned\n\t\t\t{Smallest: 6, Largest: 7},\n\t\t},\n\t\tDelayTime: 42,\n\t\tECNCE:     123,\n\t\tECT0:      456,\n\t\tECT1:      789,\n\t}, f)\n}\n\nfunc TestConnectionLoggingDatagramFrame(t *testing.T) {\n\tf := toLoggingFrame(&wire.DatagramFrame{Data: []byte(\"foobar\")})\n\trequire.Equal(t, &logging.DatagramFrame{Length: 6}, f)\n}\n\nfunc TestConnectionLoggingOtherFrames(t *testing.T) {\n\tf := toLoggingFrame(&wire.MaxDataFrame{MaximumData: 1234})\n\trequire.Equal(t, &logging.MaxDataFrame{MaximumData: 1234}, f)\n}\n"
        },
        {
          "name": "connection_test.go",
          "type": "blob",
          "size": 97.525390625,
          "content": "package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"net/netip\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\tmockackhandler \"github.com/quic-go/quic-go/internal/mocks/ackhandler\"\n\tmocklogging \"github.com/quic-go/quic-go/internal/mocks/logging\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\ntype testConnectionOpt func(*connection)\n\nfunc connectionOptCryptoSetup(cs *mocks.MockCryptoSetup) testConnectionOpt {\n\treturn func(conn *connection) { conn.cryptoStreamHandler = cs }\n}\n\nfunc connectionOptStreamManager(sm *MockStreamManager) testConnectionOpt {\n\treturn func(conn *connection) { conn.streamsMap = sm }\n}\n\nfunc connectionOptConnFlowController(cfc *mocks.MockConnectionFlowController) testConnectionOpt {\n\treturn func(conn *connection) { conn.connFlowController = cfc }\n}\n\nfunc connectionOptTracer(tr *logging.ConnectionTracer) testConnectionOpt {\n\treturn func(conn *connection) { conn.tracer = tr }\n}\n\nfunc connectionOptSentPacketHandler(sph ackhandler.SentPacketHandler) testConnectionOpt {\n\treturn func(conn *connection) { conn.sentPacketHandler = sph }\n}\n\nfunc connectionOptReceivedPacketHandler(rph ackhandler.ReceivedPacketHandler) testConnectionOpt {\n\treturn func(conn *connection) { conn.receivedPacketHandler = rph }\n}\n\nfunc connectionOptUnpacker(u unpacker) testConnectionOpt {\n\treturn func(conn *connection) { conn.unpacker = u }\n}\n\nfunc connectionOptSender(s sender) testConnectionOpt {\n\treturn func(conn *connection) { conn.sendQueue = s }\n}\n\nfunc connectionOptHandshakeConfirmed() testConnectionOpt {\n\treturn func(conn *connection) {\n\t\tconn.handshakeComplete = true\n\t\tconn.handshakeConfirmed = true\n\t}\n}\n\nfunc connectionOptRTT(rtt time.Duration) testConnectionOpt {\n\tvar rttStats utils.RTTStats\n\trttStats.UpdateRTT(rtt, 0)\n\treturn func(conn *connection) { conn.rttStats = &rttStats }\n}\n\nfunc connectionOptRetrySrcConnID(rcid protocol.ConnectionID) testConnectionOpt {\n\treturn func(conn *connection) { conn.retrySrcConnID = &rcid }\n}\n\ntype testConnection struct {\n\tconn       *connection\n\tconnRunner *MockConnRunner\n\tsendConn   *MockSendConn\n\tpacker     *MockPacker\n\tdestConnID protocol.ConnectionID\n\tsrcConnID  protocol.ConnectionID\n}\n\nfunc newServerTestConnection(\n\tt *testing.T,\n\tmockCtrl *gomock.Controller,\n\tconfig *Config,\n\tgso bool,\n\topts ...testConnectionOpt,\n) *testConnection {\n\tif mockCtrl == nil {\n\t\tmockCtrl = gomock.NewController(t)\n\t}\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 4321}\n\tlocalAddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1234}\n\tconnRunner := NewMockConnRunner(mockCtrl)\n\tsendConn := NewMockSendConn(mockCtrl)\n\tsendConn.EXPECT().capabilities().Return(connCapabilities{GSO: gso}).AnyTimes()\n\tsendConn.EXPECT().RemoteAddr().Return(remoteAddr).AnyTimes()\n\tsendConn.EXPECT().LocalAddr().Return(localAddr).AnyTimes()\n\tpacker := NewMockPacker(mockCtrl)\n\tb := make([]byte, 12)\n\trand.Read(b)\n\torigDestConnID := protocol.ParseConnectionID(b[:6])\n\tsrcConnID := protocol.ParseConnectionID(b[6:12])\n\tctx, cancel := context.WithCancelCause(context.Background())\n\tif config == nil {\n\t\tconfig = &Config{DisablePathMTUDiscovery: true}\n\t}\n\tconn := newConnection(\n\t\tctx,\n\t\tcancel,\n\t\tsendConn,\n\t\tconnRunner,\n\t\torigDestConnID,\n\t\tnil,\n\t\tprotocol.ConnectionID{},\n\t\tprotocol.ConnectionID{},\n\t\tsrcConnID,\n\t\t&protocol.DefaultConnectionIDGenerator{},\n\t\tprotocol.StatelessResetToken{},\n\t\tpopulateConfig(config),\n\t\t&tls.Config{},\n\t\thandshake.NewTokenGenerator(handshake.TokenProtectorKey{}),\n\t\tfalse,\n\t\tnil,\n\t\tutils.DefaultLogger,\n\t\tprotocol.Version1,\n\t).(*connection)\n\tconn.packer = packer\n\tfor _, opt := range opts {\n\t\topt(conn)\n\t}\n\treturn &testConnection{\n\t\tconn:       conn,\n\t\tconnRunner: connRunner,\n\t\tsendConn:   sendConn,\n\t\tpacker:     packer,\n\t\tdestConnID: origDestConnID,\n\t\tsrcConnID:  srcConnID,\n\t}\n}\n\nfunc newClientTestConnection(\n\tt *testing.T,\n\tmockCtrl *gomock.Controller,\n\tconfig *Config,\n\tenable0RTT bool,\n\topts ...testConnectionOpt,\n) *testConnection {\n\tif mockCtrl == nil {\n\t\tmockCtrl = gomock.NewController(t)\n\t}\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 4321}\n\tlocalAddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1234}\n\tconnRunner := NewMockConnRunner(mockCtrl)\n\tsendConn := NewMockSendConn(mockCtrl)\n\tsendConn.EXPECT().capabilities().Return(connCapabilities{}).AnyTimes()\n\tsendConn.EXPECT().RemoteAddr().Return(remoteAddr).AnyTimes()\n\tsendConn.EXPECT().LocalAddr().Return(localAddr).AnyTimes()\n\tpacker := NewMockPacker(mockCtrl)\n\tb := make([]byte, 12)\n\trand.Read(b)\n\tdestConnID := protocol.ParseConnectionID(b[:6])\n\tsrcConnID := protocol.ParseConnectionID(b[6:12])\n\tif config == nil {\n\t\tconfig = &Config{DisablePathMTUDiscovery: true}\n\t}\n\tconn := newClientConnection(\n\t\tcontext.Background(),\n\t\tsendConn,\n\t\tconnRunner,\n\t\tdestConnID,\n\t\tsrcConnID,\n\t\t&protocol.DefaultConnectionIDGenerator{},\n\t\tpopulateConfig(config),\n\t\t&tls.Config{ServerName: \"quic-go.net\"},\n\t\t0,\n\t\tenable0RTT,\n\t\tfalse,\n\t\tnil,\n\t\tutils.DefaultLogger,\n\t\tprotocol.Version1,\n\t).(*connection)\n\tconn.packer = packer\n\tfor _, opt := range opts {\n\t\topt(conn)\n\t}\n\treturn &testConnection{\n\t\tconn:       conn,\n\t\tconnRunner: connRunner,\n\t\tsendConn:   sendConn,\n\t\tpacker:     packer,\n\t\tdestConnID: destConnID,\n\t\tsrcConnID:  srcConnID,\n\t}\n}\n\nfunc TestConnectionHandleReceiveStreamFrames(t *testing.T) {\n\tconst streamID protocol.StreamID = 5\n\tnow := time.Now()\n\tconnID := protocol.ConnectionID{}\n\tf := &wire.StreamFrame{StreamID: streamID, Data: []byte(\"foobar\")}\n\trsf := &wire.ResetStreamFrame{StreamID: streamID, ErrorCode: 42, FinalSize: 1337}\n\tsdbf := &wire.StreamDataBlockedFrame{StreamID: streamID, MaximumStreamData: 1337}\n\n\tt.Run(\"for existing and new streams\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tstreamsMap := NewMockStreamManager(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\t\tstr := NewMockReceiveStreamI(mockCtrl)\n\t\t// STREAM frame\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(str, nil)\n\t\tstr.EXPECT().handleStreamFrame(f, now)\n\t\trequire.NoError(t, tc.conn.handleFrame(f, protocol.Encryption1RTT, connID, now))\n\t\t// RESET_STREAM frame\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(str, nil)\n\t\tstr.EXPECT().handleResetStreamFrame(rsf, now)\n\t\trequire.NoError(t, tc.conn.handleFrame(rsf, protocol.Encryption1RTT, connID, now))\n\t\t// STREAM_DATA_BLOCKED frames are not passed to the stream\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(str, nil)\n\t\trequire.NoError(t, tc.conn.handleFrame(sdbf, protocol.Encryption1RTT, connID, now))\n\t})\n\n\tt.Run(\"for closed streams\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tstreamsMap := NewMockStreamManager(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\t\t// STREAM frame\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(nil, nil)\n\t\trequire.NoError(t, tc.conn.handleFrame(f, protocol.Encryption1RTT, connID, now))\n\t\t// RESET_STREAM frame\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(nil, nil)\n\t\trequire.NoError(t, tc.conn.handleFrame(rsf, protocol.Encryption1RTT, connID, now))\n\t\t// STREAM_DATA_BLOCKED frames are not passed to the stream\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(nil, nil)\n\t\trequire.NoError(t, tc.conn.handleFrame(sdbf, protocol.Encryption1RTT, connID, now))\n\t})\n\n\tt.Run(\"for invalid streams\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tstreamsMap := NewMockStreamManager(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\t\ttestErr := errors.New(\"test err\")\n\t\t// STREAM frame\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(nil, testErr)\n\t\trequire.ErrorIs(t, tc.conn.handleFrame(f, protocol.Encryption1RTT, connID, now), testErr)\n\t\t// RESET_STREAM frame\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(nil, testErr)\n\t\trequire.ErrorIs(t, tc.conn.handleFrame(rsf, protocol.Encryption1RTT, connID, now), testErr)\n\t\t// STREAM_DATA_BLOCKED frames are not passed to the stream\n\t\tstreamsMap.EXPECT().GetOrOpenReceiveStream(streamID).Return(nil, testErr)\n\t\trequire.ErrorIs(t, tc.conn.handleFrame(sdbf, protocol.Encryption1RTT, connID, now), testErr)\n\t})\n}\n\nfunc TestConnectionHandleSendStreamFrames(t *testing.T) {\n\tconst streamID protocol.StreamID = 3\n\tnow := time.Now()\n\tconnID := protocol.ConnectionID{}\n\tss := &wire.StopSendingFrame{StreamID: streamID, ErrorCode: 42}\n\tmsd := &wire.MaxStreamDataFrame{StreamID: streamID, MaximumStreamData: 1337}\n\n\tt.Run(\"for existing and new streams\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tstreamsMap := NewMockStreamManager(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\t\tstr := NewMockSendStreamI(mockCtrl)\n\t\t// STOP_SENDING frame\n\t\tstreamsMap.EXPECT().GetOrOpenSendStream(streamID).Return(str, nil)\n\t\tstr.EXPECT().handleStopSendingFrame(ss)\n\t\trequire.NoError(t, tc.conn.handleFrame(ss, protocol.Encryption1RTT, connID, now))\n\t\t// MAX_STREAM_DATA frame\n\t\tstreamsMap.EXPECT().GetOrOpenSendStream(streamID).Return(str, nil)\n\t\tstr.EXPECT().updateSendWindow(msd.MaximumStreamData)\n\t\trequire.NoError(t, tc.conn.handleFrame(msd, protocol.Encryption1RTT, connID, now))\n\t})\n\n\tt.Run(\"for closed streams\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tstreamsMap := NewMockStreamManager(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\t\t// STOP_SENDING frame\n\t\tstreamsMap.EXPECT().GetOrOpenSendStream(streamID).Return(nil, nil)\n\t\trequire.NoError(t, tc.conn.handleFrame(ss, protocol.Encryption1RTT, connID, now))\n\t\t// MAX_STREAM_DATA frame\n\t\tstreamsMap.EXPECT().GetOrOpenSendStream(streamID).Return(nil, nil)\n\t\trequire.NoError(t, tc.conn.handleFrame(msd, protocol.Encryption1RTT, connID, now))\n\t})\n\n\tt.Run(\"for invalid streams\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tstreamsMap := NewMockStreamManager(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\t\ttestErr := errors.New(\"test err\")\n\t\t// STOP_SENDING frame\n\t\tstreamsMap.EXPECT().GetOrOpenSendStream(streamID).Return(nil, testErr)\n\t\trequire.ErrorIs(t, tc.conn.handleFrame(ss, protocol.Encryption1RTT, connID, now), testErr)\n\t\t// MAX_STREAM_DATA frame\n\t\tstreamsMap.EXPECT().GetOrOpenSendStream(streamID).Return(nil, testErr)\n\t\trequire.ErrorIs(t, tc.conn.handleFrame(msd, protocol.Encryption1RTT, connID, now), testErr)\n\t})\n}\n\nfunc TestConnectionHandleStreamNumFrames(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tstreamsMap := NewMockStreamManager(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\tnow := time.Now()\n\tconnID := protocol.ConnectionID{}\n\t// MAX_STREAMS frame\n\tmsf := &wire.MaxStreamsFrame{Type: protocol.StreamTypeBidi, MaxStreamNum: 10}\n\tstreamsMap.EXPECT().HandleMaxStreamsFrame(msf)\n\trequire.NoError(t, tc.conn.handleFrame(msf, protocol.Encryption1RTT, connID, now))\n\t// STREAMS_BLOCKED frame\n\ttc.conn.handleFrame(&wire.StreamsBlockedFrame{Type: protocol.StreamTypeBidi, StreamLimit: 1}, protocol.Encryption1RTT, connID, now)\n}\n\nfunc TestConnectionHandleConnectionFlowControlFrames(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tconnFC := mocks.NewMockConnectionFlowController(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptConnFlowController(connFC))\n\tnow := time.Now()\n\tconnID := protocol.ConnectionID{}\n\t// MAX_DATA frame\n\tconnFC.EXPECT().UpdateSendWindow(protocol.ByteCount(1337))\n\trequire.NoError(t, tc.conn.handleFrame(&wire.MaxDataFrame{MaximumData: 1337}, protocol.Encryption1RTT, connID, now))\n\t// DATA_BLOCKED frame\n\trequire.NoError(t, tc.conn.handleFrame(&wire.DataBlockedFrame{MaximumData: 1337}, protocol.Encryption1RTT, connID, now))\n}\n\nfunc TestConnectionOpenStreams(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tstreamsMap := NewMockStreamManager(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\n\t// using OpenStream\n\tmstr := NewMockStreamI(mockCtrl)\n\tstreamsMap.EXPECT().OpenStream().Return(mstr, nil)\n\tstr, err := tc.conn.OpenStream()\n\trequire.NoError(t, err)\n\trequire.Equal(t, mstr, str)\n\n\t// using OpenStreamSync\n\tstreamsMap.EXPECT().OpenStreamSync(context.Background()).Return(mstr, nil)\n\tstr, err = tc.conn.OpenStreamSync(context.Background())\n\trequire.NoError(t, err)\n\trequire.Equal(t, mstr, str)\n\n\t// using OpenUniStream\n\tstreamsMap.EXPECT().OpenUniStream().Return(mstr, nil)\n\tustr, err := tc.conn.OpenUniStream()\n\trequire.NoError(t, err)\n\trequire.Equal(t, mstr, ustr)\n\n\t// using OpenUniStreamSync\n\tstreamsMap.EXPECT().OpenUniStreamSync(context.Background()).Return(mstr, nil)\n\tustr, err = tc.conn.OpenUniStreamSync(context.Background())\n\trequire.NoError(t, err)\n\trequire.Equal(t, mstr, ustr)\n}\n\nfunc TestConnectionAcceptStreams(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tstreamsMap := NewMockStreamManager(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptStreamManager(streamsMap))\n\n\t// bidirectional streams\n\tctx, cancel := context.WithTimeout(context.Background(), time.Minute)\n\tdefer cancel()\n\tmstr := NewMockStreamI(mockCtrl)\n\tstreamsMap.EXPECT().AcceptStream(ctx).Return(mstr, nil)\n\tstr, err := tc.conn.AcceptStream(ctx)\n\trequire.NoError(t, err)\n\trequire.Equal(t, mstr, str)\n\n\t// unidirectional streams\n\tstreamsMap.EXPECT().AcceptUniStream(ctx).Return(mstr, nil)\n\tustr, err := tc.conn.AcceptUniStream(ctx)\n\trequire.NoError(t, err)\n\trequire.Equal(t, mstr, ustr)\n}\n\nfunc TestConnectionServerInvalidFrames(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false)\n\n\tfor _, test := range []struct {\n\t\tName  string\n\t\tFrame wire.Frame\n\t}{\n\t\t{Name: \"NEW_TOKEN\", Frame: &wire.NewTokenFrame{Token: []byte(\"foobar\")}},\n\t\t{Name: \"HANDSHAKE_DONE\", Frame: &wire.HandshakeDoneFrame{}},\n\t\t{Name: \"PATH_RESPONSE\", Frame: &wire.PathResponseFrame{Data: [8]byte{1, 2, 3, 4, 5, 6, 7, 8}}},\n\t} {\n\t\tt.Run(test.Name, func(t *testing.T) {\n\t\t\trequire.ErrorIs(t,\n\t\t\t\ttc.conn.handleFrame(test.Frame, protocol.Encryption1RTT, protocol.ConnectionID{}, time.Now()),\n\t\t\t\t&qerr.TransportError{ErrorCode: qerr.ProtocolViolation},\n\t\t\t)\n\t\t})\n\t}\n}\n\nfunc TestConnectionTransportError(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\terrChan := make(chan error, 1)\n\texpectedErr := &qerr.TransportError{\n\t\tErrorCode:    1337,\n\t\tFrameType:    42,\n\t\tErrorMessage: \"test error\",\n\t}\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\tb := getPacketBuffer()\n\tb.Data = append(b.Data, []byte(\"connection close\")...)\n\ttc.packer.EXPECT().PackConnectionClose(expectedErr, gomock.Any(), protocol.Version1).Return(&coalescedPacket{buffer: b}, nil)\n\ttc.sendConn.EXPECT().Write([]byte(\"connection close\"), gomock.Any(), gomock.Any())\n\ttc.connRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any()).AnyTimes()\n\tgomock.InOrder(\n\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\ttracer.EXPECT().Close(),\n\t)\n\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.closeLocal(expectedErr)\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, expectedErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// further calls to CloseWithError don't do anything\n\ttc.conn.CloseWithError(42, \"another error\")\n}\n\nfunc TestConnectionApplicationClose(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\terrChan := make(chan error, 1)\n\texpectedErr := &qerr.ApplicationError{\n\t\tErrorCode:    1337,\n\t\tErrorMessage: \"test error\",\n\t}\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\tb := getPacketBuffer()\n\tb.Data = append(b.Data, []byte(\"connection close\")...)\n\ttc.packer.EXPECT().PackApplicationClose(expectedErr, gomock.Any(), protocol.Version1).Return(&coalescedPacket{buffer: b}, nil)\n\ttc.sendConn.EXPECT().Write([]byte(\"connection close\"), gomock.Any(), gomock.Any())\n\ttc.connRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any()).AnyTimes()\n\tgomock.InOrder(\n\t\ttracer.EXPECT().ClosedConnection(expectedErr),\n\t\ttracer.EXPECT().Close(),\n\t)\n\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.CloseWithError(1337, \"test error\")\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, expectedErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// further calls to CloseWithError don't do anything\n\ttc.conn.CloseWithError(42, \"another error\")\n}\n\nfunc TestConnectionStatelessReset(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\terrChan := make(chan error, 1)\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\tgomock.InOrder(\n\t\ttracer.EXPECT().ClosedConnection(&StatelessResetError{}),\n\t\ttracer.EXPECT().Close(),\n\t)\n\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.destroy(&StatelessResetError{})\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &StatelessResetError{})\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc getLongHeaderPacket(t *testing.T, extHdr *wire.ExtendedHeader, data []byte) receivedPacket {\n\tt.Helper()\n\tb, err := extHdr.Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\treturn receivedPacket{\n\t\tdata:    append(b, data...),\n\t\tbuffer:  getPacketBuffer(),\n\t\trcvTime: time.Now(),\n\t}\n}\n\nfunc getShortHeaderPacket(t *testing.T, connID protocol.ConnectionID, pn protocol.PacketNumber, data []byte) receivedPacket {\n\tt.Helper()\n\tb, err := wire.AppendShortHeader(nil, connID, pn, protocol.PacketNumberLen2, protocol.KeyPhaseOne)\n\trequire.NoError(t, err)\n\treturn receivedPacket{\n\t\tdata:    append(b, data...),\n\t\tbuffer:  getPacketBuffer(),\n\t\trcvTime: time.Now(),\n\t}\n}\n\nfunc TestConnectionServerInvalidPackets(t *testing.T) {\n\tt.Run(\"Retry\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\n\t\tp := getLongHeaderPacket(t, &wire.ExtendedHeader{Header: wire.Header{\n\t\t\tType:             protocol.PacketTypeRetry,\n\t\t\tDestConnectionID: tc.conn.origDestConnID,\n\t\t\tSrcConnectionID:  tc.srcConnID,\n\t\t\tVersion:          tc.conn.version,\n\t\t\tToken:            []byte(\"foobar\"),\n\t\t}}, make([]byte, 16) /* Retry integrity tag */)\n\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\trequire.False(t, tc.conn.handlePacketImpl(p))\n\t})\n\n\tt.Run(\"version negotiation\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\n\t\tb := wire.ComposeVersionNegotiation(\n\t\t\tprotocol.ArbitraryLenConnectionID(tc.srcConnID.Bytes()),\n\t\t\tprotocol.ArbitraryLenConnectionID(tc.conn.origDestConnID.Bytes()),\n\t\t\t[]Version{Version1},\n\t\t)\n\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, protocol.InvalidPacketNumber, protocol.ByteCount(len(b)), logging.PacketDropUnexpectedPacket)\n\t\trequire.False(t, tc.conn.handlePacketImpl(receivedPacket{data: b, buffer: getPacketBuffer()}))\n\t})\n\n\tt.Run(\"unsupported version\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\n\t\tp := getLongHeaderPacket(t, &wire.ExtendedHeader{\n\t\t\tHeader:          wire.Header{Type: protocol.PacketTypeHandshake, Version: 1234},\n\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t}, nil)\n\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropUnsupportedVersion)\n\t\trequire.False(t, tc.conn.handlePacketImpl(p))\n\t})\n\n\tt.Run(\"invalid header\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\t\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\n\t\tp := getLongHeaderPacket(t, &wire.ExtendedHeader{\n\t\t\tHeader:          wire.Header{Type: protocol.PacketTypeHandshake, Version: Version1},\n\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t}, nil)\n\t\tp.data[0] ^= 0x40 // unset the QUIC bit\n\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropHeaderParseError)\n\t\trequire.False(t, tc.conn.handlePacketImpl(p))\n\t})\n}\n\nfunc TestConnectionClientDrop0RTT(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newClientTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\n\tp := getLongHeaderPacket(t, &wire.ExtendedHeader{\n\t\tHeader:          wire.Header{Type: protocol.PacketType0RTT, Length: 2, Version: protocol.Version1},\n\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t}, nil)\n\ttracer.EXPECT().DroppedPacket(logging.PacketType0RTT, protocol.InvalidPacketNumber, p.Size(), logging.PacketDropUnexpectedPacket)\n\trequire.False(t, tc.conn.handlePacketImpl(p))\n}\n\nfunc TestConnectionUnpacking(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptReceivedPacketHandler(rph),\n\t\tconnectionOptUnpacker(unpacker),\n\t\tconnectionOptTracer(tr),\n\t)\n\n\t// receive a long header packet\n\thdr := &wire.ExtendedHeader{\n\t\tHeader: wire.Header{\n\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\tDestConnectionID: tc.srcConnID,\n\t\t\tVersion:          protocol.Version1,\n\t\t\tLength:           1,\n\t\t},\n\t\tPacketNumber:    0x37,\n\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t}\n\tunpackedHdr := *hdr\n\tunpackedHdr.PacketNumber = 0x1337\n\tpacket := getLongHeaderPacket(t, hdr, nil)\n\tpacket.ecn = protocol.ECNCE\n\trcvTime := time.Now().Add(-10 * time.Second)\n\tpacket.rcvTime = rcvTime\n\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(&unpackedPacket{\n\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\thdr:             &unpackedHdr,\n\t\tdata:            []byte{0}, // one PADDING frame\n\t}, nil)\n\tgomock.InOrder(\n\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.EncryptionInitial),\n\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(0x1337), protocol.ECNCE, protocol.EncryptionInitial, rcvTime, false),\n\t)\n\n\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any())\n\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), logging.ECNCE, []logging.Frame{})\n\trequire.True(t, tc.conn.handlePacketImpl(packet))\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// receive a duplicate of this packet\n\tpacket = getLongHeaderPacket(t, hdr, nil)\n\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.EncryptionInitial).Return(true)\n\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(&unpackedPacket{\n\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\thdr:             &unpackedHdr,\n\t\tdata:            []byte{0}, // one PADDING frame\n\t}, nil)\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeInitial, protocol.PacketNumber(0x1337), protocol.ByteCount(len(packet.data)), logging.PacketDropDuplicate)\n\trequire.False(t, tc.conn.handlePacketImpl(packet))\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// receive a short header packet\n\tpacket = getShortHeaderPacket(t, tc.srcConnID, 0x37, nil)\n\tpacket.ecn = protocol.ECT1\n\tpacket.rcvTime = rcvTime\n\tgomock.InOrder(\n\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(0x1337), protocol.Encryption1RTT),\n\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(0x1337), protocol.ECT1, protocol.Encryption1RTT, rcvTime, false),\n\t)\n\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(\n\t\tprotocol.PacketNumber(0x1337), protocol.PacketNumberLen2, protocol.KeyPhaseZero, []byte{0} /* PADDING */, nil,\n\t)\n\ttracer.EXPECT().ReceivedShortHeaderPacket(gomock.Any(), gomock.Any(), logging.ECT1, []logging.Frame{})\n\trequire.True(t, tc.conn.handlePacketImpl(packet))\n}\n\nfunc TestConnectionUnpackCoalescedPacket(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptReceivedPacketHandler(rph),\n\t\tconnectionOptUnpacker(unpacker),\n\t\tconnectionOptTracer(tr),\n\t)\n\thdr1 := &wire.ExtendedHeader{\n\t\tHeader: wire.Header{\n\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\tDestConnectionID: tc.srcConnID,\n\t\t\tVersion:          protocol.Version1,\n\t\t\tLength:           1,\n\t\t},\n\t\tPacketNumber:    37,\n\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t}\n\thdr2 := &wire.ExtendedHeader{\n\t\tHeader: wire.Header{\n\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\tDestConnectionID: tc.srcConnID,\n\t\t\tVersion:          protocol.Version1,\n\t\t\tLength:           1,\n\t\t},\n\t\tPacketNumber:    38,\n\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t}\n\t// add a packet with a different source connection ID\n\tincorrectSrcConnID := protocol.ParseConnectionID([]byte{0xa, 0xb, 0xc})\n\thdr3 := &wire.ExtendedHeader{\n\t\tHeader: wire.Header{\n\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\tDestConnectionID: incorrectSrcConnID,\n\t\t\tVersion:          protocol.Version1,\n\t\t\tLength:           1,\n\t\t},\n\t\tPacketNumber:    0x42,\n\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t}\n\tunpackedHdr1 := *hdr1\n\tunpackedHdr1.PacketNumber = 1337\n\tunpackedHdr2 := *hdr2\n\tunpackedHdr2.PacketNumber = 1338\n\n\tpacket := getLongHeaderPacket(t, hdr1, nil)\n\tpacket2 := getLongHeaderPacket(t, hdr2, nil)\n\tpacket3 := getLongHeaderPacket(t, hdr3, nil)\n\tpacket.data = append(packet.data, packet2.data...)\n\tpacket.data = append(packet.data, packet3.data...)\n\tpacket.ecn = protocol.ECT1\n\trcvTime := time.Now()\n\tpacket.rcvTime = rcvTime\n\n\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(&unpackedPacket{\n\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\thdr:             &unpackedHdr1,\n\t\tdata:            []byte{0}, // one PADDING frame\n\t}, nil)\n\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(&unpackedPacket{\n\t\tencryptionLevel: protocol.EncryptionHandshake,\n\t\thdr:             &unpackedHdr2,\n\t\tdata:            []byte{1}, // one PING frame\n\t}, nil)\n\tgomock.InOrder(\n\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(1337), protocol.EncryptionInitial),\n\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(1337), protocol.ECT1, protocol.EncryptionInitial, rcvTime, false),\n\t\trph.EXPECT().IsPotentiallyDuplicate(protocol.PacketNumber(1338), protocol.EncryptionHandshake),\n\t\trph.EXPECT().ReceivedPacket(protocol.PacketNumber(1338), protocol.ECT1, protocol.EncryptionHandshake, rcvTime, true),\n\t)\n\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any())\n\ttracer.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\ttracer.EXPECT().DroppedEncryptionLevel(protocol.EncryptionInitial)\n\trph.EXPECT().DropPackets(protocol.EncryptionInitial)\n\tgomock.InOrder(\n\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), logging.ECT1, []logging.Frame{}),\n\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), logging.ECT1, []logging.Frame{&wire.PingFrame{}}),\n\t\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, protocol.ByteCount(len(packet3.data)), logging.PacketDropUnknownConnectionID),\n\t)\n\trequire.True(t, tc.conn.handlePacketImpl(packet))\n}\n\nfunc TestConnectionUnpackFailuresFatal(t *testing.T) {\n\tt.Run(\"other errors\", func(t *testing.T) {\n\t\trequire.ErrorIs(t,\n\t\t\ttestConnectionUnpackFailureFatal(t, &qerr.TransportError{ErrorCode: qerr.ConnectionIDLimitError}),\n\t\t\t&qerr.TransportError{ErrorCode: qerr.ConnectionIDLimitError},\n\t\t)\n\t})\n\n\tt.Run(\"invalid reserved bits\", func(t *testing.T) {\n\t\trequire.ErrorIs(t,\n\t\t\ttestConnectionUnpackFailureFatal(t, wire.ErrInvalidReservedBits),\n\t\t\t&qerr.TransportError{ErrorCode: qerr.ProtocolViolation},\n\t\t)\n\t})\n}\n\nfunc testConnectionUnpackFailureFatal(t *testing.T, unpackErr error) error {\n\tmockCtrl := gomock.NewController(t)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptUnpacker(unpacker),\n\t)\n\n\ttc.connRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any())\n\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, unpackErr)\n\ttc.packer.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), protocol.Version1).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any())\n\ttc.conn.handlePacket(getShortHeaderPacket(t, tc.srcConnID, 0x42, nil))\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.Error(t, err)\n\t\treturn err\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\treturn nil\n}\n\nfunc TestConnectionUnpackFailureDropped(t *testing.T) {\n\tt.Run(\"keys dropped\", func(t *testing.T) {\n\t\ttestConnectionUnpackFailureDropped(t, handshake.ErrKeysDropped, logging.PacketDropKeyUnavailable)\n\t})\n\n\tt.Run(\"decryption failed\", func(t *testing.T) {\n\t\ttestConnectionUnpackFailureDropped(t, handshake.ErrDecryptionFailed, logging.PacketDropPayloadDecryptError)\n\t})\n\n\tt.Run(\"header parse error\", func(t *testing.T) {\n\t\ttestErr := errors.New(\"foo\")\n\t\ttestConnectionUnpackFailureDropped(t, &headerParseError{err: testErr}, logging.PacketDropHeaderParseError)\n\t})\n}\n\nfunc testConnectionUnpackFailureDropped(t *testing.T, unpackErr error, packetDropReason logging.PacketDropReason) {\n\tmockCtrl := gomock.NewController(t)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptUnpacker(unpacker),\n\t\tconnectionOptTracer(tr),\n\t)\n\n\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(0), protocol.PacketNumberLen(0), protocol.KeyPhaseBit(0), nil, unpackErr)\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\tdone := make(chan struct{})\n\ttracer.EXPECT().DroppedPacket(gomock.Any(), protocol.InvalidPacketNumber, gomock.Any(), packetDropReason).Do(\n\t\tfunc(logging.PacketType, protocol.PacketNumber, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\tclose(done)\n\t\t},\n\t)\n\ttc.conn.handlePacket(getShortHeaderPacket(t, tc.srcConnID, 0x42, nil))\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\ttracer.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase <-errChan:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionMaxUnprocessedPackets(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t, mockCtrl, nil, false, connectionOptTracer(tr))\n\tdone := make(chan struct{})\n\n\tfor i := protocol.PacketNumber(0); i < protocol.MaxConnUnprocessedPackets; i++ {\n\t\t// nothing here should block\n\t\ttc.conn.handlePacket(receivedPacket{data: []byte(\"foobar\")})\n\t}\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeNotDetermined, protocol.InvalidPacketNumber, logging.ByteCount(6), logging.PacketDropDOSPrevention).Do(func(logging.PacketType, logging.PacketNumber, logging.ByteCount, logging.PacketDropReason) {\n\t\tclose(done)\n\t})\n\ttc.conn.handlePacket(receivedPacket{data: []byte(\"foobar\")})\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionRemoteClose(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockStreamManager := NewMockStreamManager(mockCtrl)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptStreamManager(mockStreamManager),\n\t\tconnectionOptTracer(tr),\n\t)\n\texpectedErr := &qerr.TransportError{ErrorCode: qerr.StreamLimitError, Remote: true}\n\ttc.connRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any())\n\tstreamErrChan := make(chan error, 1)\n\tmockStreamManager.EXPECT().CloseWithError(gomock.Any()).Do(func(e error) { streamErrChan <- e })\n\ttracerErrChan := make(chan error, 1)\n\ttracer.EXPECT().ClosedConnection(gomock.Any()).Do(func(e error) { tracerErrChan <- e })\n\ttracer.EXPECT().Close()\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\ttc.conn.handleFrame(&wire.ConnectionCloseFrame{\n\t\tErrorCode:    uint64(qerr.StreamLimitError),\n\t\tReasonPhrase: \"foobar\",\n\t}, protocol.Encryption1RTT, protocol.ConnectionID{}, time.Now())\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, expectedErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\tselect {\n\tcase err := <-tracerErrChan:\n\t\trequire.ErrorIs(t, err, expectedErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\tselect {\n\tcase err := <-streamErrChan:\n\t\trequire.ErrorIs(t, err, expectedErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionIdleTimeoutDuringHandshake(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\t&Config{HandshakeIdleTimeout: scaleDuration(25 * time.Millisecond)},\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t)\n\ttc.packer.EXPECT().PackCoalescedPacket(false, gomock.Any(), gomock.Any(), protocol.Version1).AnyTimes()\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\tgomock.InOrder(\n\t\ttracer.EXPECT().ClosedConnection(&IdleTimeoutError{}),\n\t\ttracer.EXPECT().Close(),\n\t)\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &IdleTimeoutError{})\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionHandshakeIdleTimeout(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\t&Config{HandshakeIdleTimeout: scaleDuration(25 * time.Millisecond)},\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t\tfunc(c *connection) { c.creationTime = time.Now().Add(-10 * time.Second) },\n\t)\n\ttc.packer.EXPECT().PackCoalescedPacket(false, gomock.Any(), gomock.Any(), protocol.Version1).AnyTimes()\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\tgomock.InOrder(\n\t\ttracer.EXPECT().ClosedConnection(&HandshakeTimeoutError{}),\n\t\ttracer.EXPECT().Close(),\n\t)\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &HandshakeTimeoutError{})\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionTransportParameters(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\tstreamManager := NewMockStreamManager(mockCtrl)\n\tconnFC := mocks.NewMockConnectionFlowController(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t\tconnectionOptStreamManager(streamManager),\n\t\tconnectionOptConnFlowController(connFC),\n\t)\n\ttracer.EXPECT().ReceivedTransportParameters(gomock.Any())\n\tparams := &wire.TransportParameters{\n\t\tMaxIdleTimeout:                90 * time.Second,\n\t\tInitialMaxStreamDataBidiLocal: 0x5000,\n\t\tInitialMaxData:                0x5000,\n\t\tActiveConnectionIDLimit:       3,\n\t\t// marshaling always sets it to this value\n\t\tMaxUDPPayloadSize:               protocol.MaxPacketBufferSize,\n\t\tOriginalDestinationConnectionID: tc.destConnID,\n\t}\n\tstreamManager.EXPECT().UpdateLimits(params)\n\tconnFC.EXPECT().UpdateSendWindow(params.InitialMaxData)\n\trequire.NoError(t, tc.conn.handleTransportParameters(params))\n}\n\nfunc TestConnectionTransportParameterValidationFailureServer(t *testing.T) {\n\ttc := newServerTestConnection(t, nil, nil, false)\n\terr := tc.conn.handleTransportParameters(&wire.TransportParameters{\n\t\tInitialSourceConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t})\n\tassert.ErrorIs(t, err, &qerr.TransportError{ErrorCode: qerr.TransportParameterError})\n\tassert.ErrorContains(t, err, \"expected initial_source_connection_id to equal\")\n}\n\nfunc TestConnectionTransportParameterValidationFailureClient(t *testing.T) {\n\tt.Run(\"initial_source_connection_id\", func(t *testing.T) {\n\t\ttc := newClientTestConnection(t, nil, nil, false)\n\t\terr := tc.conn.handleTransportParameters(&wire.TransportParameters{\n\t\t\tInitialSourceConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t})\n\t\tassert.ErrorIs(t, err, &qerr.TransportError{ErrorCode: qerr.TransportParameterError})\n\t\tassert.ErrorContains(t, err, \"expected initial_source_connection_id to equal\")\n\t})\n\n\tt.Run(\"original_destination_connection_id\", func(t *testing.T) {\n\t\ttc := newClientTestConnection(t, nil, nil, false)\n\t\terr := tc.conn.handleTransportParameters(&wire.TransportParameters{\n\t\t\tInitialSourceConnectionID:       tc.destConnID,\n\t\t\tOriginalDestinationConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t})\n\t\tassert.ErrorIs(t, err, &qerr.TransportError{ErrorCode: qerr.TransportParameterError})\n\t\tassert.ErrorContains(t, err, \"expected original_destination_connection_id to equal\")\n\t})\n\n\tt.Run(\"retry_source_connection_id if no retry\", func(t *testing.T) {\n\t\ttc := newClientTestConnection(t, nil, nil, false)\n\t\trcid := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\t\tparams := &wire.TransportParameters{\n\t\t\tInitialSourceConnectionID:       tc.destConnID,\n\t\t\tOriginalDestinationConnectionID: tc.destConnID,\n\t\t\tRetrySourceConnectionID:         &rcid,\n\t\t}\n\t\terr := tc.conn.handleTransportParameters(params)\n\t\tassert.ErrorIs(t, err, &qerr.TransportError{ErrorCode: qerr.TransportParameterError})\n\t\tassert.ErrorContains(t, err, \"received retry_source_connection_id, although no Retry was performed\")\n\t})\n\n\tt.Run(\"retry_source_connection_id missing\", func(t *testing.T) {\n\t\ttc := newClientTestConnection(t,\n\t\t\tnil,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t\tconnectionOptRetrySrcConnID(protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})),\n\t\t)\n\t\tparams := &wire.TransportParameters{\n\t\t\tInitialSourceConnectionID:       tc.destConnID,\n\t\t\tOriginalDestinationConnectionID: tc.destConnID,\n\t\t}\n\t\terr := tc.conn.handleTransportParameters(params)\n\t\tassert.ErrorIs(t, err, &qerr.TransportError{ErrorCode: qerr.TransportParameterError})\n\t\tassert.ErrorContains(t, err, \"missing retry_source_connection_id\")\n\t})\n\n\tt.Run(\"retry_source_connection_id incorrect\", func(t *testing.T) {\n\t\ttc := newClientTestConnection(t,\n\t\t\tnil,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t\tconnectionOptRetrySrcConnID(protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})),\n\t\t)\n\t\twrongCID := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\t\tparams := &wire.TransportParameters{\n\t\t\tInitialSourceConnectionID:       tc.destConnID,\n\t\t\tOriginalDestinationConnectionID: tc.destConnID,\n\t\t\tRetrySourceConnectionID:         &wrongCID,\n\t\t}\n\t\terr := tc.conn.handleTransportParameters(params)\n\t\tassert.ErrorIs(t, err, &qerr.TransportError{ErrorCode: qerr.TransportParameterError})\n\t\tassert.ErrorContains(t, err, \"expected retry_source_connection_id to equal\")\n\t})\n}\n\nfunc TestConnectionHandshakeServer(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tcs := mocks.NewMockCryptoSetup(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newServerTestConnection(\n\t\tt,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptCryptoSetup(cs),\n\t\tconnectionOptUnpacker(unpacker),\n\t)\n\n\t// the state transition is driven by processing of a CRYPTO frame\n\thdr := &wire.ExtendedHeader{\n\t\tHeader:          wire.Header{Type: protocol.PacketTypeHandshake, Version: protocol.Version1},\n\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t}\n\tdata, err := (&wire.CryptoFrame{Data: []byte(\"foobar\")}).Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\n\tcs.EXPECT().DiscardInitialKeys()\n\ttc.connRunner.EXPECT().Retire(gomock.Any())\n\tgomock.InOrder(\n\t\tcs.EXPECT().StartHandshake(gomock.Any()),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}),\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(\n\t\t\t&unpackedPacket{hdr: hdr, encryptionLevel: protocol.EncryptionHandshake, data: data}, nil,\n\t\t),\n\t\tcs.EXPECT().HandleMessage([]byte(\"foobar\"), protocol.EncryptionHandshake),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete}),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}),\n\t\tcs.EXPECT().SetHandshakeConfirmed(),\n\t\tcs.EXPECT().GetSessionTicket().Return([]byte(\"session ticket\"), nil),\n\t)\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\tp := getLongHeaderPacket(t, hdr, nil)\n\ttc.conn.handlePacket(receivedPacket{data: p.data, buffer: p.buffer, rcvTime: time.Now()})\n\n\tselect {\n\tcase <-tc.conn.HandshakeComplete():\n\tcase <-tc.conn.Context().Done():\n\t\tt.Fatal(\"connection context done\")\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tvar foundSessionTicket, foundHandshakeDone, foundNewToken bool\n\tframes, _, _ := tc.conn.framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\tfor _, frame := range frames {\n\t\tswitch f := frame.Frame.(type) {\n\t\tcase *wire.CryptoFrame:\n\t\t\tassert.Equal(t, []byte(\"session ticket\"), f.Data)\n\t\t\tfoundSessionTicket = true\n\t\tcase *wire.HandshakeDoneFrame:\n\t\t\tfoundHandshakeDone = true\n\t\tcase *wire.NewTokenFrame:\n\t\t\tassert.NotEmpty(t, f.Token)\n\t\t\tfoundNewToken = true\n\t\t}\n\t}\n\tassert.True(t, foundSessionTicket)\n\tassert.True(t, foundHandshakeDone)\n\tassert.True(t, foundNewToken)\n\n\t// test teardown\n\tcs.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionHandshakeClient(t *testing.T) {\n\tt.Run(\"without preferred address\", func(t *testing.T) {\n\t\ttestConnectionHandshakeClient(t, false)\n\t})\n\tt.Run(\"with preferred address\", func(t *testing.T) {\n\t\ttestConnectionHandshakeClient(t, true)\n\t})\n}\n\nfunc testConnectionHandshakeClient(t *testing.T, usePreferredAddress bool) {\n\tmockCtrl := gomock.NewController(t)\n\tcs := mocks.NewMockCryptoSetup(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newClientTestConnection(t, mockCtrl, nil, false, connectionOptCryptoSetup(cs), connectionOptUnpacker(unpacker))\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\n\t// the state transition is driven by processing of a CRYPTO frame\n\thdr := &wire.ExtendedHeader{\n\t\tHeader:          wire.Header{Type: protocol.PacketTypeHandshake, Version: protocol.Version1},\n\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t}\n\tdata, err := (&wire.CryptoFrame{Data: []byte(\"foobar\")}).Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\n\ttp := &wire.TransportParameters{\n\t\tOriginalDestinationConnectionID: tc.destConnID,\n\t\tMaxIdleTimeout:                  time.Hour,\n\t}\n\tpreferredAddressConnID := protocol.ParseConnectionID([]byte{10, 8, 6, 4})\n\tpreferredAddressResetToken := protocol.StatelessResetToken{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}\n\tif usePreferredAddress {\n\t\ttp.PreferredAddress = &wire.PreferredAddress{\n\t\t\tIPv4:                netip.AddrPortFrom(netip.AddrFrom4([4]byte{127, 0, 0, 1}), 42),\n\t\t\tIPv6:                netip.AddrPortFrom(netip.AddrFrom16([16]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}), 13),\n\t\t\tConnectionID:        preferredAddressConnID,\n\t\t\tStatelessResetToken: preferredAddressResetToken,\n\t\t}\n\t}\n\n\tpackedFirstPacket := make(chan struct{})\n\tgomock.InOrder(\n\t\tcs.EXPECT().StartHandshake(gomock.Any()),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}),\n\t\ttc.packer.EXPECT().PackCoalescedPacket(false, gomock.Any(), gomock.Any(), protocol.Version1).DoAndReturn(\n\t\t\tfunc(b bool, bc protocol.ByteCount, t time.Time, v protocol.Version) (*coalescedPacket, error) {\n\t\t\t\tclose(packedFirstPacket)\n\t\t\t\treturn &coalescedPacket{buffer: getPacketBuffer(), longHdrPackets: []*longHeaderPacket{{header: hdr}}}, nil\n\t\t\t},\n\t\t),\n\t\t// initial keys are dropped when the first handshake packet is sent\n\t\tcs.EXPECT().DiscardInitialKeys(),\n\t\t// no more data to send\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(\n\t\t\t&unpackedPacket{hdr: hdr, encryptionLevel: protocol.EncryptionHandshake, data: data}, nil,\n\t\t),\n\t\tcs.EXPECT().HandleMessage([]byte(\"foobar\"), protocol.EncryptionHandshake),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventReceivedTransportParameters, TransportParameters: tp}),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventHandshakeComplete}),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}),\n\t)\n\ttc.packer.EXPECT().PackCoalescedPacket(false, gomock.Any(), gomock.Any(), protocol.Version1).Return(nil, nil).AnyTimes()\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\tselect {\n\tcase <-packedFirstPacket:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tp := getLongHeaderPacket(t, hdr, nil)\n\ttc.conn.handlePacket(receivedPacket{data: p.data, buffer: p.buffer, rcvTime: time.Now()})\n\n\tselect {\n\tcase <-tc.conn.HandshakeComplete():\n\tcase <-tc.conn.Context().Done():\n\t\tt.Fatal(\"connection context done\")\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\trequire.True(t, mockCtrl.Satisfied())\n\t// the handshake isn't confirmed until we receive a HANDSHAKE_DONE frame from the server\n\n\tdata, err = (&wire.HandshakeDoneFrame{}).Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\tdone := make(chan struct{})\n\ttc.packer.EXPECT().PackCoalescedPacket(false, gomock.Any(), gomock.Any(), protocol.Version1).Return(nil, nil).AnyTimes()\n\tgomock.InOrder(\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(\n\t\t\t&unpackedPacket{hdr: hdr, encryptionLevel: protocol.Encryption1RTT, data: data}, nil,\n\t\t),\n\t\tcs.EXPECT().SetHandshakeConfirmed(),\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buf *packetBuffer, _ protocol.ByteCount, _ time.Time, _ protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tclose(done)\n\t\t\t\treturn shortHeaderPacket{}, errNothingToPack\n\t\t\t},\n\t\t),\n\t)\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack).AnyTimes()\n\tp = getLongHeaderPacket(t, hdr, nil)\n\ttc.conn.handlePacket(receivedPacket{data: p.data, buffer: p.buffer, rcvTime: time.Now()})\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tif usePreferredAddress {\n\t\ttc.connRunner.EXPECT().AddResetToken(preferredAddressResetToken, gomock.Any())\n\t}\n\tnextConnID := tc.conn.connIDManager.Get()\n\tif usePreferredAddress {\n\t\trequire.Equal(t, preferredAddressConnID, nextConnID)\n\t}\n\n\t// test teardown\n\tcs.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\tif usePreferredAddress {\n\t\ttc.connRunner.EXPECT().RemoveResetToken(preferredAddressResetToken)\n\t}\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnection0RTTTransportParameters(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tcs := mocks.NewMockCryptoSetup(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newClientTestConnection(t, mockCtrl, nil, false, connectionOptCryptoSetup(cs), connectionOptUnpacker(unpacker))\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\n\t// the state transition is driven by processing of a CRYPTO frame\n\thdr := &wire.ExtendedHeader{\n\t\tHeader:          wire.Header{Type: protocol.PacketTypeHandshake, Version: protocol.Version1},\n\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t}\n\tdata, err := (&wire.CryptoFrame{Data: []byte(\"foobar\")}).Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\n\trestored := &wire.TransportParameters{\n\t\tActiveConnectionIDLimit:        3,\n\t\tInitialMaxData:                 0x5000,\n\t\tInitialMaxStreamDataBidiLocal:  0x5000,\n\t\tInitialMaxStreamDataBidiRemote: 1000,\n\t\tInitialMaxStreamDataUni:        1000,\n\t\tMaxBidiStreamNum:               500,\n\t\tMaxUniStreamNum:                500,\n\t}\n\tnew := *restored\n\tnew.MaxBidiStreamNum-- // the server is not allowed to reduce the limit\n\tnew.OriginalDestinationConnectionID = tc.destConnID\n\n\tpackedFirstPacket := make(chan struct{})\n\tgomock.InOrder(\n\t\tcs.EXPECT().StartHandshake(gomock.Any()),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventRestoredTransportParameters, TransportParameters: restored}),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}),\n\t\ttc.packer.EXPECT().PackCoalescedPacket(false, gomock.Any(), gomock.Any(), protocol.Version1).DoAndReturn(\n\t\t\tfunc(b bool, bc protocol.ByteCount, t time.Time, v protocol.Version) (*coalescedPacket, error) {\n\t\t\t\tclose(packedFirstPacket)\n\t\t\t\treturn &coalescedPacket{buffer: getPacketBuffer(), longHdrPackets: []*longHeaderPacket{{header: hdr}}}, nil\n\t\t\t},\n\t\t),\n\t\t// initial keys are dropped when the first handshake packet is sent\n\t\tcs.EXPECT().DiscardInitialKeys(),\n\t\t// no more data to send\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(\n\t\t\t&unpackedPacket{hdr: hdr, encryptionLevel: protocol.EncryptionHandshake, data: data}, nil,\n\t\t),\n\t\tcs.EXPECT().HandleMessage([]byte(\"foobar\"), protocol.EncryptionHandshake),\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventReceivedTransportParameters, TransportParameters: &new}),\n\t\tcs.EXPECT().ConnectionState().Return(handshake.ConnectionState{Used0RTT: true}),\n\t\t// cs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}),\n\t\tcs.EXPECT().Close(),\n\t)\n\ttc.packer.EXPECT().PackCoalescedPacket(false, gomock.Any(), gomock.Any(), protocol.Version1).Return(nil, nil).AnyTimes()\n\ttc.packer.EXPECT().PackConnectionClose(gomock.Any(), gomock.Any(), protocol.Version1).Return(&coalescedPacket{buffer: getPacketBuffer()}, nil)\n\ttc.connRunner.EXPECT().ReplaceWithClosed(gomock.Any(), gomock.Any())\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\tselect {\n\tcase <-packedFirstPacket:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tp := getLongHeaderPacket(t, hdr, nil)\n\ttc.conn.handlePacket(receivedPacket{data: p.data, buffer: p.buffer, rcvTime: time.Now()})\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &qerr.TransportError{ErrorCode: qerr.ProtocolViolation})\n\t\trequire.ErrorContains(t, err, \"server sent reduced limits after accepting 0-RTT data\")\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionReceivePrioritization(t *testing.T) {\n\tt.Run(\"handshake complete\", func(t *testing.T) {\n\t\tcounter := testConnectionReceivePrioritization(t, true)\n\t\trequire.Equal(t, 10, counter)\n\t})\n\n\t// before handshake completion, we trigger packing of a new packet every time we receive a packet\n\tt.Run(\"handshake not complete\", func(t *testing.T) {\n\t\tcounter := testConnectionReceivePrioritization(t, false)\n\t\trequire.Equal(t, 1, counter)\n\t})\n}\n\nfunc testConnectionReceivePrioritization(t *testing.T, handshakeComplete bool) int {\n\tmockCtrl := gomock.NewController(t)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\topts := []testConnectionOpt{connectionOptUnpacker(unpacker)}\n\tif handshakeComplete {\n\t\topts = append(opts, connectionOptHandshakeConfirmed())\n\t}\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\topts...,\n\t)\n\n\tvar counter int\n\tvar packedFirst bool\n\tdone := make(chan struct{})\n\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\tif !packedFirst {\n\t\t\t\tcounter++\n\t\t\t}\n\t\t\treturn protocol.PacketNumber(counter), protocol.PacketNumberLen2, protocol.KeyPhaseZero, []byte{0, 1} /* PADDING, PING */, nil\n\t\t},\n\t).AnyTimes()\n\tswitch handshakeComplete {\n\tcase false:\n\t\ttc.packer.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(b bool, bc protocol.ByteCount, t time.Time, v protocol.Version) (*coalescedPacket, error) {\n\t\t\t\tif !packedFirst {\n\t\t\t\t\tpackedFirst = true\n\t\t\t\t\tclose(done)\n\t\t\t\t}\n\t\t\t\treturn nil, nil\n\t\t\t},\n\t\t).AnyTimes()\n\tcase true:\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(b *packetBuffer, bc protocol.ByteCount, t time.Time, v protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tif !packedFirst {\n\t\t\t\t\tpackedFirst = true\n\t\t\t\t\tclose(done)\n\t\t\t\t}\n\t\t\t\treturn shortHeaderPacket{}, errNothingToPack\n\t\t\t},\n\t\t).AnyTimes()\n\t}\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\tfor i := 0; i < 10; i++ {\n\t\ttc.conn.handlePacket(getShortHeaderPacket(t, tc.srcConnID, protocol.PacketNumber(i), []byte(\"foobar\")))\n\t}\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\treturn counter\n}\n\nfunc TestConnectionPacketBuffering(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\tcs := mocks.NewMockCryptoSetup(mockCtrl)\n\ttracer, tr := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptUnpacker(unpacker),\n\t\tconnectionOptCryptoSetup(cs),\n\t\tconnectionOptTracer(tracer),\n\t)\n\n\ttr.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any())\n\ttr.EXPECT().StartedConnection(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\ttr.EXPECT().DroppedEncryptionLevel(gomock.Any())\n\tcs.EXPECT().DiscardInitialKeys()\n\n\thdr1 := wire.ExtendedHeader{\n\t\tHeader: wire.Header{\n\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\tDestConnectionID: tc.srcConnID,\n\t\t\tSrcConnectionID:  tc.destConnID,\n\t\t\tLength:           8,\n\t\t\tVersion:          protocol.Version1,\n\t\t},\n\t\tPacketNumberLen: protocol.PacketNumberLen1,\n\t\tPacketNumber:    1,\n\t}\n\thdr2 := hdr1\n\thdr2.PacketNumber = 2\n\tcs.EXPECT().StartHandshake(gomock.Any())\n\tbuffered := make(chan struct{})\n\tgomock.InOrder(\n\t\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent}),\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(nil, handshake.ErrKeysNotYetAvailable),\n\t\ttr.EXPECT().BufferedPacket(logging.PacketTypeHandshake, gomock.Any()),\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(nil, handshake.ErrKeysNotYetAvailable),\n\t\ttr.EXPECT().BufferedPacket(logging.PacketTypeHandshake, gomock.Any()).Do(\n\t\t\tfunc(logging.PacketType, logging.ByteCount) { close(buffered) },\n\t\t),\n\t)\n\n\ttc.conn.handlePacket(getLongHeaderPacket(t, &hdr1, []byte(\"packet1\")))\n\ttc.conn.handlePacket(getLongHeaderPacket(t, &hdr2, []byte(\"packet2\")))\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\tselect {\n\tcase <-buffered:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// Now send another packet.\n\t// In reality, this packet would contain a CRYPTO frame that advances the TLS handshake\n\t// such that new keys become available.\n\tvar packets []string\n\thdr3 := hdr1\n\thdr3.PacketNumber = 3\n\ttc.packer.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, nil).AnyTimes()\n\tunpacked := make(chan struct{})\n\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventReceivedReadKeys})\n\tcs.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\n\tgomock.InOrder(\n\t\t// packet 3 contains a CRYPTO frame and triggers the keys to become available\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(hdr *wire.Header, data []byte) (*unpackedPacket, error) {\n\t\t\t\tpackets = append(packets, string(data[len(data)-7:]))\n\t\t\t\tcf := &wire.CryptoFrame{Data: []byte(\"foobar\")}\n\t\t\t\tb, _ := cf.Append(nil, protocol.Version1)\n\t\t\t\treturn &unpackedPacket{hdr: &hdr3, encryptionLevel: protocol.EncryptionHandshake, data: b}, nil\n\t\t\t},\n\t\t),\n\t\tcs.EXPECT().HandleMessage(gomock.Any(), gomock.Any()),\n\t\ttr.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t// packet 1 dequeued from the buffer\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(hdr *wire.Header, data []byte) (*unpackedPacket, error) {\n\t\t\t\tpackets = append(packets, string(data[len(data)-7:]))\n\t\t\t\treturn &unpackedPacket{hdr: &hdr1, encryptionLevel: protocol.EncryptionHandshake, data: []byte{0} /* PADDING */}, nil\n\t\t\t},\n\t\t),\n\t\ttr.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t// packet 2 dequeued from the buffer\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(hdr *wire.Header, data []byte) (*unpackedPacket, error) {\n\t\t\t\tpackets = append(packets, string(data[len(data)-7:]))\n\t\t\t\tclose(unpacked)\n\t\t\t\treturn &unpackedPacket{hdr: &hdr2, encryptionLevel: protocol.EncryptionHandshake, data: []byte{0} /* PADDING */}, nil\n\t\t\t},\n\t\t),\n\t\ttr.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t)\n\n\ttc.conn.handlePacket(getLongHeaderPacket(t, &hdr3, []byte(\"packet3\")))\n\n\tselect {\n\tcase <-unpacked:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// packet3 triggered the keys to become available\n\t// packet1 and packet2 are processed from the buffer in order\n\trequire.Equal(t, []string{\"packet3\", \"packet1\", \"packet2\"}, packets)\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\tcs.EXPECT().Close()\n\ttr.EXPECT().ClosedConnection(gomock.Any())\n\ttr.EXPECT().Close()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionPacketPacing(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\tsender := NewMockSender(mockCtrl)\n\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptSentPacketHandler(sph),\n\t\tconnectionOptSender(sender),\n\t\tconnectionOptHandshakeConfirmed(),\n\t\t// set a fixed RTT, so that the idle timeout doesn't interfere with this test\n\t\tconnectionOptRTT(10*time.Second),\n\t)\n\tsender.EXPECT().Run()\n\n\tstep := scaleDuration(50 * time.Millisecond)\n\n\tsph.EXPECT().GetLossDetectionTimeout().Return(time.Now().Add(time.Hour)).AnyTimes()\n\tgomock.InOrder(\n\t\t// 1. allow 2 packets to be sent\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny),\n\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny),\n\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited),\n\t\t// 2. become pacing limited for 25ms\n\t\tsph.EXPECT().TimeUntilSend().DoAndReturn(func() time.Time { return time.Now().Add(step) }),\n\t\t// 3. send another packet\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny),\n\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited),\n\t\t// 4. become pacing limited for 25ms...\n\t\tsph.EXPECT().TimeUntilSend().DoAndReturn(func() time.Time { return time.Now().Add(step) }),\n\t\t// ... but this time we're still pacing limited when waking up.\n\t\t// In this case, we can only send an ACK.\n\t\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendPacingLimited),\n\t\t// 5. stop the test by becoming pacing limited forever\n\t\tsph.EXPECT().TimeUntilSend().Return(time.Now().Add(time.Hour)),\n\t\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()),\n\t)\n\tsph.EXPECT().ECNMode(gomock.Any()).AnyTimes()\n\tfor i := 0; i < 3; i++ {\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), Version1).DoAndReturn(\n\t\t\tfunc(buf *packetBuffer, _ protocol.ByteCount, _ time.Time, _ protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuf.Data = append(buf.Data, []byte(\"packet\"+strconv.Itoa(i+1))...)\n\t\t\t\treturn shortHeaderPacket{PacketNumber: protocol.PacketNumber(i + 1)}, nil\n\t\t\t},\n\t\t)\n\t}\n\ttc.packer.EXPECT().PackAckOnlyPacket(gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(_ protocol.ByteCount, _ time.Time, _ protocol.Version) (shortHeaderPacket, *packetBuffer, error) {\n\t\t\tbuf := getPacketBuffer()\n\t\t\tbuf.Data = []byte(\"ack\")\n\t\t\treturn shortHeaderPacket{PacketNumber: 1}, buf, nil\n\t\t},\n\t)\n\tsender.EXPECT().WouldBlock().AnyTimes()\n\n\ttype sentPacket struct {\n\t\ttime time.Time\n\t\tdata []byte\n\t}\n\tsendChan := make(chan sentPacket, 10)\n\tsender.EXPECT().Send(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(b *packetBuffer, _ uint16, _ protocol.ECN) {\n\t\tsendChan <- sentPacket{time: time.Now(), data: b.Data}\n\t}).Times(4)\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\n\tvar times []time.Time\n\tfor i := 0; i < 3; i++ {\n\t\tselect {\n\t\tcase b := <-sendChan:\n\t\t\trequire.Equal(t, []byte(\"packet\"+strconv.Itoa(i+1)), b.data)\n\t\t\ttimes = append(times, b.time)\n\t\tcase <-time.After(scaleDuration(time.Second)):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t}\n\tselect {\n\tcase b := <-sendChan:\n\t\trequire.Equal(t, []byte(\"ack\"), b.data)\n\t\ttimes = append(times, b.time)\n\tcase <-time.After(scaleDuration(time.Second)):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\trequire.InDelta(t, times[0].Sub(times[1]).Seconds(), 0, scaleDuration(10*time.Millisecond).Seconds())\n\trequire.InDelta(t, times[2].Sub(times[1]).Seconds(), step.Seconds(), scaleDuration(20*time.Millisecond).Seconds())\n\trequire.InDelta(t, times[3].Sub(times[2]).Seconds(), step.Seconds(), scaleDuration(20*time.Millisecond).Seconds())\n\n\ttime.Sleep(scaleDuration(step)) // make sure that no more packets are sent\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// test teardown\n\tsender.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase <-sendChan:\n\t\tt.Fatal(\"should not have sent any more packets\")\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionIdleTimeout(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\t&Config{MaxIdleTimeout: time.Second},\n\t\tfalse,\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptSentPacketHandler(sph),\n\t\tconnectionOptRTT(time.Millisecond),\n\t)\n\t// the idle timeout is set when the transport parameters are received\n\tidleTimeout := scaleDuration(50 * time.Millisecond)\n\trequire.NoError(t, tc.conn.handleTransportParameters(&wire.TransportParameters{\n\t\tMaxIdleTimeout: idleTimeout,\n\t}))\n\n\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\tsph.EXPECT().ECNMode(gomock.Any()).AnyTimes()\n\tvar lastSendTime time.Time\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(buf *packetBuffer, _ protocol.ByteCount, _ time.Time, _ protocol.Version) (shortHeaderPacket, error) {\n\t\t\tbuf.Data = append(buf.Data, []byte(\"foobar\")...)\n\t\t\tlastSendTime = time.Now()\n\t\t\treturn shortHeaderPacket{Frames: []ackhandler.Frame{{Frame: &wire.PingFrame{}}}, Length: 6}, nil\n\t\t},\n\t)\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack)\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any())\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &IdleTimeoutError{})\n\t\trequire.NotZero(t, lastSendTime)\n\t\trequire.InDelta(t,\n\t\t\ttime.Since(lastSendTime).Seconds(),\n\t\t\tidleTimeout.Seconds(),\n\t\t\tscaleDuration(10*time.Millisecond).Seconds(),\n\t\t)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionKeepAlive(t *testing.T) {\n\tt.Run(\"enabled\", func(t *testing.T) {\n\t\ttestConnectionKeepAlive(t, true, true)\n\t})\n\n\tt.Run(\"disabled\", func(t *testing.T) {\n\t\ttestConnectionKeepAlive(t, false, false)\n\t})\n}\n\nfunc testConnectionKeepAlive(t *testing.T, enable, expectKeepAlive bool) {\n\tvar keepAlivePeriod time.Duration\n\tif enable {\n\t\tkeepAlivePeriod = time.Second\n\t}\n\n\tmockCtrl := gomock.NewController(t)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\t&Config{MaxIdleTimeout: time.Second, KeepAlivePeriod: keepAlivePeriod},\n\t\tfalse,\n\t\tconnectionOptUnpacker(unpacker),\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptRTT(time.Millisecond),\n\t)\n\t// the idle timeout is set when the transport parameters are received\n\tidleTimeout := scaleDuration(50 * time.Millisecond)\n\trequire.NoError(t, tc.conn.handleTransportParameters(&wire.TransportParameters{\n\t\tMaxIdleTimeout: idleTimeout,\n\t}))\n\n\t// Receive a packet. This starts the keep-alive timer.\n\tbuf := getPacketBuffer()\n\tvar err error\n\tbuf.Data, err = wire.AppendShortHeader(buf.Data, tc.srcConnID, 1, protocol.PacketNumberLen1, protocol.KeyPhaseZero)\n\trequire.NoError(t, err)\n\tbuf.Data = append(buf.Data, []byte(\"packet\")...)\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\tvar unpackTime, packTime time.Time\n\tdone := make(chan struct{})\n\tunpacker.EXPECT().UnpackShortHeader(gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(t time.Time, bytes []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\t\t\tunpackTime = time.Now()\n\t\t\treturn protocol.PacketNumber(1), protocol.PacketNumberLen1, protocol.KeyPhaseZero, []byte{0} /* PADDING */, nil\n\t\t},\n\t)\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack)\n\n\tswitch expectKeepAlive {\n\tcase true:\n\t\t// record the time of the keep-alive is sent\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buffer *packetBuffer, count protocol.ByteCount, t time.Time, version protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tpackTime = time.Now()\n\t\t\t\tclose(done)\n\t\t\t\treturn shortHeaderPacket{}, errNothingToPack\n\t\t\t},\n\t\t)\n\t\ttc.conn.handlePacket(receivedPacket{data: buf.Data, buffer: buf, rcvTime: time.Now()})\n\t\tselect {\n\t\tcase <-done:\n\t\t\t// the keep-alive packet should be sent after half the idle timeout\n\t\t\tdiff := packTime.Sub(unpackTime)\n\t\t\trequire.InDelta(t, diff.Seconds(), idleTimeout.Seconds()/2, scaleDuration(10*time.Millisecond).Seconds())\n\t\tcase <-time.After(idleTimeout):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\tcase false: // if keep-alives are disabled, the connection will run into an idle timeout\n\t\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\ttc.conn.handlePacket(receivedPacket{data: buf.Data, buffer: buf, rcvTime: time.Now()})\n\t\tselect {\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\tcase <-time.After(idleTimeout):\n\t\t}\n\t}\n\n\t// test teardown\n\tif expectKeepAlive {\n\t\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\ttc.conn.destroy(nil)\n\t}\n\tselect {\n\tcase err := <-errChan:\n\t\tif expectKeepAlive {\n\t\t\trequire.NoError(t, err)\n\t\t} else {\n\t\t\trequire.ErrorIs(t, err, &IdleTimeoutError{})\n\t\t}\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionACKTimer(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\trph := mockackhandler.NewMockReceivedPacketHandler(mockCtrl)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\t&Config{MaxIdleTimeout: time.Second},\n\t\tfalse,\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptReceivedPacketHandler(rph),\n\t\tconnectionOptSentPacketHandler(sph),\n\t\tconnectionOptRTT(10*time.Second),\n\t)\n\talarmTimeout := scaleDuration(50 * time.Millisecond)\n\n\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\tsph.EXPECT().ECNMode(gomock.Any()).AnyTimes()\n\trph.EXPECT().GetAlarmTimeout().Return(time.Now().Add(time.Hour))\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\n\tvar times []time.Time\n\tdone := make(chan struct{}, 5)\n\tvar calls []any\n\tfor i := 0; i < 2; i++ {\n\t\tcalls = append(calls, tc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buf *packetBuffer, _ protocol.ByteCount, _ time.Time, _ protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuf.Data = append(buf.Data, []byte(\"foobar\")...)\n\t\t\t\ttimes = append(times, time.Now())\n\t\t\t\treturn shortHeaderPacket{Frames: []ackhandler.Frame{{Frame: &wire.PingFrame{}}}, Length: 6}, nil\n\t\t\t},\n\t\t))\n\t\tcalls = append(calls, tc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buf *packetBuffer, _ protocol.ByteCount, _ time.Time, _ protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tdone <- struct{}{}\n\t\t\t\treturn shortHeaderPacket{}, errNothingToPack\n\t\t\t},\n\t\t))\n\t\tif i == 0 {\n\t\t\tcalls = append(calls, rph.EXPECT().GetAlarmTimeout().Return(time.Now().Add(alarmTimeout)))\n\t\t} else {\n\t\t\tcalls = append(calls, rph.EXPECT().GetAlarmTimeout().Return(time.Now().Add(time.Hour)).MaxTimes(1))\n\t\t}\n\t}\n\tgomock.InOrder(calls...)\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\n\tfor i := 0; i < 2; i++ {\n\t\tselect {\n\t\tcase <-done:\n\t\tcase <-time.After(3 * time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t}\n\n\tassert.Len(t, times, 2)\n\trequire.InDelta(t, times[1].Sub(times[0]).Seconds(), alarmTimeout.Seconds(), scaleDuration(10*time.Millisecond).Seconds())\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\n// Send a GSO batch, until we have no more data to send.\nfunc TestConnectionGSOBatch(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\ttrue,\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptSentPacketHandler(sph),\n\t)\n\n\t// allow packets to be sent\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\tsph.EXPECT().TimeUntilSend().Return(time.Time{}).AnyTimes()\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\tsph.EXPECT().GetLossDetectionTimeout().Return(time.Time{}).AnyTimes()\n\tsph.EXPECT().ECNMode(gomock.Any()).Return(protocol.ECT1).AnyTimes()\n\n\tmaxPacketSize := tc.conn.maxPacketSize()\n\tvar expectedData []byte\n\tfor i := 0; i < 4; i++ {\n\t\tdata := bytes.Repeat([]byte{byte(i)}, int(maxPacketSize))\n\t\texpectedData = append(expectedData, data...)\n\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buffer *packetBuffer, count protocol.ByteCount, t time.Time, version protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuffer.Data = append(buffer.Data, data...)\n\t\t\t\treturn shortHeaderPacket{PacketNumber: protocol.PacketNumber(i)}, nil\n\t\t\t},\n\t\t)\n\t}\n\tdone := make(chan struct{})\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack)\n\ttc.sendConn.EXPECT().Write(expectedData, uint16(maxPacketSize), protocol.ECT1).DoAndReturn(\n\t\tfunc([]byte, uint16, protocol.ECN) error { close(done); return nil },\n\t)\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\n// Send a GSO batch, until a packet smaller than the maximum size is packed\nfunc TestConnectionGSOBatchPacketSize(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\ttrue,\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptSentPacketHandler(sph),\n\t)\n\n\t// allow packets to be sent\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\tsph.EXPECT().TimeUntilSend().Return(time.Time{}).AnyTimes()\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\tsph.EXPECT().GetLossDetectionTimeout().Return(time.Time{}).AnyTimes()\n\tsph.EXPECT().ECNMode(gomock.Any()).Return(protocol.ECT1).AnyTimes()\n\n\tmaxPacketSize := tc.conn.maxPacketSize()\n\tvar expectedData []byte\n\tvar calls []any\n\tfor i := 0; i < 4; i++ {\n\t\tvar data []byte\n\t\tif i == 3 {\n\t\t\tdata = bytes.Repeat([]byte{byte(i)}, int(maxPacketSize-1))\n\t\t} else {\n\t\t\tdata = bytes.Repeat([]byte{byte(i)}, int(maxPacketSize))\n\t\t}\n\t\texpectedData = append(expectedData, data...)\n\n\t\tcalls = append(calls, tc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buffer *packetBuffer, count protocol.ByteCount, t time.Time, version protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuffer.Data = append(buffer.Data, data...)\n\t\t\t\treturn shortHeaderPacket{PacketNumber: protocol.PacketNumber(10 + i)}, nil\n\t\t\t},\n\t\t))\n\t}\n\t// The smaller (fourth) packet concluded this GSO batch, but the send loop will immediately start composing the next batch.\n\t// We therefore send a \"foobar\", so we can check that we're actually generating two GSO batches.\n\tcalls = append(calls,\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buffer *packetBuffer, count protocol.ByteCount, t time.Time, version protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\t\t\t\treturn shortHeaderPacket{PacketNumber: protocol.PacketNumber(14)}, nil\n\t\t\t},\n\t\t),\n\t)\n\tcalls = append(calls,\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack),\n\t)\n\tgomock.InOrder(calls...)\n\n\tdone := make(chan struct{})\n\tgomock.InOrder(\n\t\ttc.sendConn.EXPECT().Write(expectedData, uint16(maxPacketSize), protocol.ECT1),\n\t\ttc.sendConn.EXPECT().Write([]byte(\"foobar\"), uint16(maxPacketSize), protocol.ECT1).DoAndReturn(\n\t\t\tfunc([]byte, uint16, protocol.ECN) error { close(done); return nil },\n\t\t),\n\t)\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionGSOBatchECN(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\ttrue,\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptSentPacketHandler(sph),\n\t)\n\n\t// allow packets to be sent\n\tecnMode := protocol.ECT1\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\tsph.EXPECT().TimeUntilSend().Return(time.Time{}).AnyTimes()\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\tsph.EXPECT().GetLossDetectionTimeout().Return(time.Time{}).AnyTimes()\n\tsph.EXPECT().ECNMode(gomock.Any()).DoAndReturn(func(bool) protocol.ECN { return ecnMode }).AnyTimes()\n\n\t// 3. Send a GSO batch, until the ECN marking changes.\n\tvar expectedData []byte\n\tvar calls []any\n\tmaxPacketSize := tc.conn.maxPacketSize()\n\tfor i := 0; i < 3; i++ {\n\t\tdata := bytes.Repeat([]byte{byte(i)}, int(maxPacketSize))\n\t\texpectedData = append(expectedData, data...)\n\n\t\tcalls = append(calls, tc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buffer *packetBuffer, count protocol.ByteCount, t time.Time, version protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuffer.Data = append(buffer.Data, data...)\n\t\t\t\tif i == 2 {\n\t\t\t\t\tecnMode = protocol.ECNCE\n\t\t\t\t}\n\t\t\t\treturn shortHeaderPacket{PacketNumber: protocol.PacketNumber(20 + i)}, nil\n\t\t\t},\n\t\t))\n\t}\n\t// The smaller (fourth) packet concluded this GSO batch, but the send loop will immediately start composing the next batch.\n\t// We therefore send a \"foobar\", so we can check that we're actually generating two GSO batches.\n\tcalls = append(calls,\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buffer *packetBuffer, count protocol.ByteCount, t time.Time, version protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\t\t\t\treturn shortHeaderPacket{PacketNumber: protocol.PacketNumber(24)}, nil\n\t\t\t},\n\t\t),\n\t)\n\tcalls = append(calls,\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(shortHeaderPacket{}, errNothingToPack),\n\t)\n\tgomock.InOrder(calls...)\n\n\tdone3 := make(chan struct{})\n\ttc.sendConn.EXPECT().Write(expectedData, uint16(maxPacketSize), protocol.ECT1)\n\ttc.sendConn.EXPECT().Write([]byte(\"foobar\"), uint16(maxPacketSize), protocol.ECNCE).DoAndReturn(\n\t\tfunc([]byte, uint16, protocol.ECN) error { close(done3); return nil },\n\t)\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\n\tselect {\n\tcase <-done3:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionPTOProbePackets(t *testing.T) {\n\tt.Run(\"Initial\", func(t *testing.T) {\n\t\ttestConnectionPTOProbePackets(t, protocol.EncryptionInitial)\n\t})\n\tt.Run(\"Handshake\", func(t *testing.T) {\n\t\ttestConnectionPTOProbePackets(t, protocol.EncryptionHandshake)\n\t})\n\tt.Run(\"1-RTT\", func(t *testing.T) {\n\t\ttestConnectionPTOProbePackets(t, protocol.Encryption1RTT)\n\t})\n}\n\nfunc testConnectionPTOProbePackets(t *testing.T, encLevel protocol.EncryptionLevel) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptSentPacketHandler(sph),\n\t)\n\n\tvar sendMode ackhandler.SendMode\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\tsendMode = ackhandler.SendPTOInitial\n\tcase protocol.EncryptionHandshake:\n\t\tsendMode = ackhandler.SendPTOHandshake\n\tcase protocol.Encryption1RTT:\n\t\tsendMode = ackhandler.SendPTOAppData\n\t}\n\n\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\tsph.EXPECT().SendMode(gomock.Any()).Return(sendMode)\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\tsph.EXPECT().ECNMode(gomock.Any())\n\tsph.EXPECT().QueueProbePacket(encLevel).Return(false)\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\n\ttc.packer.EXPECT().MaybePackProbePacket(encLevel, gomock.Any(), gomock.Any(), protocol.Version1).DoAndReturn(\n\t\tfunc(encLevel protocol.EncryptionLevel, maxSize protocol.ByteCount, t time.Time, version protocol.Version) (*coalescedPacket, error) {\n\t\t\treturn &coalescedPacket{\n\t\t\t\tbuffer:         getPacketBuffer(),\n\t\t\t\tshortHdrPacket: &shortHeaderPacket{PacketNumber: 1},\n\t\t\t}, nil\n\t\t},\n\t)\n\tdone := make(chan struct{})\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).Do(\n\t\tfunc([]byte, uint16, protocol.ECN) error { close(done); return nil },\n\t)\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionCongestionControl(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptSentPacketHandler(sph),\n\t\tconnectionOptRTT(10*time.Second),\n\t)\n\n\tsph.EXPECT().TimeUntilSend().AnyTimes()\n\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\tsph.EXPECT().ECNMode(true).AnyTimes()\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).Times(2)\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAck).MaxTimes(1)\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Times(2)\n\t// Since we're already sending out packets, we don't expect any calls to PackAckOnlyPacket\n\tfor i := 0; i < 2; i++ {\n\t\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\t\tfunc(buffer *packetBuffer, count protocol.ByteCount, t time.Time, version protocol.Version) (shortHeaderPacket, error) {\n\t\t\t\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\t\t\t\treturn shortHeaderPacket{PacketNumber: protocol.PacketNumber(i)}, nil\n\t\t\t},\n\t\t)\n\t}\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any())\n\tdone1 := make(chan struct{})\n\ttc.sendConn.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).Do(\n\t\tfunc([]byte, uint16, protocol.ECN) error { close(done1); return nil },\n\t)\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\tselect {\n\tcase <-done1:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// Now that we're congestion limited, we can only send an ack-only packet\n\tdone2 := make(chan struct{})\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAck)\n\ttc.packer.EXPECT().PackAckOnlyPacket(gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(protocol.ByteCount, time.Time, protocol.Version) (shortHeaderPacket, *packetBuffer, error) {\n\t\t\tclose(done2)\n\t\t\treturn shortHeaderPacket{}, nil, errNothingToPack\n\t\t},\n\t)\n\ttc.conn.scheduleSending()\n\tselect {\n\tcase <-done2:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// If the send mode is \"none\", we can't even send an ack-only packet\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendNone)\n\ttc.conn.scheduleSending()\n\ttime.Sleep(scaleDuration(10 * time.Millisecond)) // make sure there are no calls to the packer\n\n\t// test teardown\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestConnectionSendQueue(t *testing.T) {\n\tt.Run(\"with GSO\", func(t *testing.T) {\n\t\ttestConnectionSendQueue(t, true)\n\t})\n\tt.Run(\"without GSO\", func(t *testing.T) {\n\t\ttestConnectionSendQueue(t, false)\n\t})\n}\n\nfunc testConnectionSendQueue(t *testing.T, enableGSO bool) {\n\tmockCtrl := gomock.NewController(t)\n\tsph := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\tsender := NewMockSender(mockCtrl)\n\ttc := newServerTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tenableGSO,\n\t\tconnectionOptSender(sender),\n\t\tconnectionOptHandshakeConfirmed(),\n\t\tconnectionOptSentPacketHandler(sph),\n\t)\n\n\tsender.EXPECT().Run().MaxTimes(1)\n\tsender.EXPECT().WouldBlock()\n\tsender.EXPECT().WouldBlock().Return(true).Times(2)\n\tavailable := make(chan struct{})\n\tblocked := make(chan struct{})\n\tsender.EXPECT().Available().DoAndReturn(\n\t\tfunc() <-chan struct{} {\n\t\t\tclose(blocked)\n\t\t\treturn available\n\t\t},\n\t)\n\tsph.EXPECT().GetLossDetectionTimeout().AnyTimes()\n\tsph.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\tsph.EXPECT().SendMode(gomock.Any()).Return(ackhandler.SendAny).AnyTimes()\n\tsph.EXPECT().ECNMode(gomock.Any()).AnyTimes()\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(\n\t\tshortHeaderPacket{PacketNumber: protocol.PacketNumber(1)}, nil,\n\t)\n\tsender.EXPECT().Send(gomock.Any(), gomock.Any(), gomock.Any())\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.scheduleSending()\n\n\tselect {\n\tcase <-blocked:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// now make room in the send queue\n\tsender.EXPECT().WouldBlock().AnyTimes()\n\tunblocked := make(chan struct{})\n\ttc.packer.EXPECT().AppendPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(*packetBuffer, protocol.ByteCount, time.Time, protocol.Version) (shortHeaderPacket, error) {\n\t\t\tclose(unblocked)\n\t\t\treturn shortHeaderPacket{}, errNothingToPack\n\t\t},\n\t)\n\tavailable <- struct{}{}\n\tselect {\n\tcase <-unblocked:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\tsender.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any()).AnyTimes()\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc getVersionNegotiationPacket(src, dest protocol.ConnectionID, versions []protocol.Version) receivedPacket {\n\tb := wire.ComposeVersionNegotiation(\n\t\tprotocol.ArbitraryLenConnectionID(src.Bytes()),\n\t\tprotocol.ArbitraryLenConnectionID(dest.Bytes()),\n\t\tversions,\n\t)\n\treturn receivedPacket{\n\t\trcvTime: time.Now(),\n\t\tdata:    b,\n\t\tbuffer:  getPacketBuffer(),\n\t}\n}\n\nfunc TestConnectionVersionNegotiation(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newClientTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t)\n\n\ttc.packer.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, nil).AnyTimes()\n\tvar tracerVersions []logging.Version\n\tgomock.InOrder(\n\t\ttracer.EXPECT().ReceivedVersionNegotiationPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_, _ protocol.ArbitraryLenConnectionID, versions []logging.Version) {\n\t\t\ttracerVersions = versions\n\t\t}),\n\t\ttracer.EXPECT().NegotiatedVersion(protocol.Version2, gomock.Any(), gomock.Any()),\n\t\ttc.connRunner.EXPECT().Remove(gomock.Any()),\n\t)\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.handlePacket(getVersionNegotiationPacket(\n\t\ttc.destConnID,\n\t\ttc.srcConnID,\n\t\t[]protocol.Version{1234, protocol.Version2},\n\t))\n\n\tselect {\n\tcase err := <-errChan:\n\t\tvar rerr *errCloseForRecreating\n\t\trequire.ErrorAs(t, err, &rerr)\n\t\trequire.Equal(t, rerr.nextVersion, protocol.Version2)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\trequire.Contains(t, tracerVersions, protocol.Version(1234))\n\trequire.Contains(t, tracerVersions, protocol.Version2)\n}\n\nfunc TestConnectionVersionNegotiationNoMatch(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newClientTestConnection(t,\n\t\tmockCtrl,\n\t\t&Config{Versions: []protocol.Version{protocol.Version1}},\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t)\n\n\ttc.packer.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, nil).AnyTimes()\n\tvar tracerVersions []logging.Version\n\ttracer.EXPECT().ReceivedVersionNegotiationPacket(gomock.Any(), gomock.Any(), gomock.Any()).Do(\n\t\tfunc(_, _ protocol.ArbitraryLenConnectionID, versions []logging.Version) { tracerVersions = versions },\n\t)\n\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\ttracer.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any())\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\ttc.conn.handlePacket(getVersionNegotiationPacket(\n\t\ttc.destConnID,\n\t\ttc.srcConnID,\n\t\t[]protocol.Version{protocol.Version2},\n\t))\n\n\tselect {\n\tcase err := <-errChan:\n\t\tvar verr *VersionNegotiationError\n\t\trequire.ErrorAs(t, err, &verr)\n\t\trequire.Contains(t, verr.Theirs, protocol.Version2)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\trequire.Contains(t, tracerVersions, protocol.Version2)\n}\n\nfunc TestConnectionVersionNegotiationInvalidPackets(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\ttc := newClientTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t)\n\n\t// offers the current version\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, gomock.Any(), gomock.Any(), logging.PacketDropUnexpectedVersion)\n\tvnp := getVersionNegotiationPacket(\n\t\ttc.destConnID,\n\t\ttc.srcConnID,\n\t\t[]protocol.Version{1234, protocol.Version1},\n\t)\n\trequire.False(t, tc.conn.handlePacketImpl(vnp))\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// unparseable, since it's missing 2 bytes\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeVersionNegotiation, gomock.Any(), gomock.Any(), logging.PacketDropHeaderParseError)\n\tvnp.data = vnp.data[:len(vnp.data)-2]\n\trequire.False(t, tc.conn.handlePacketImpl(vnp))\n}\n\nfunc getRetryPacket(t *testing.T, src, dest, origDest protocol.ConnectionID, token []byte) receivedPacket {\n\thdr := wire.Header{\n\t\tType:             protocol.PacketTypeRetry,\n\t\tSrcConnectionID:  src,\n\t\tDestConnectionID: dest,\n\t\tToken:            token,\n\t\tVersion:          protocol.Version1,\n\t}\n\tb, err := (&wire.ExtendedHeader{Header: hdr}).Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\ttag := handshake.GetRetryIntegrityTag(b, origDest, protocol.Version1)\n\tb = append(b, tag[:]...)\n\treturn receivedPacket{\n\t\trcvTime: time.Now(),\n\t\tdata:    b,\n\t\tbuffer:  getPacketBuffer(),\n\t}\n}\n\nfunc TestConnectionRetryDrops(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newClientTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t\tconnectionOptUnpacker(unpacker),\n\t)\n\n\tnewConnID := protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\n\t// invalid integrity tag\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, gomock.Any(), gomock.Any(), logging.PacketDropPayloadDecryptError)\n\tretry := getRetryPacket(t, newConnID, tc.srcConnID, tc.destConnID, []byte(\"foobar\"))\n\tretry.data[len(retry.data)-1]++\n\trequire.False(t, tc.conn.handlePacketImpl(retry))\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// receive a retry that doesn't change the connection ID\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, gomock.Any(), gomock.Any(), logging.PacketDropUnexpectedPacket)\n\tretry = getRetryPacket(t, tc.destConnID, tc.srcConnID, tc.destConnID, []byte(\"foobar\"))\n\trequire.False(t, tc.conn.handlePacketImpl(retry))\n}\n\nfunc TestConnectionRetryAfterReceivedPacket(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newClientTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t\tconnectionOptUnpacker(unpacker),\n\t)\n\n\t// receive a regular packet\n\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any())\n\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\tregular := getPacketWithPacketType(t, tc.srcConnID, protocol.PacketTypeInitial, 200)\n\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(\n\t\t&unpackedPacket{\n\t\t\thdr:             &wire.ExtendedHeader{Header: wire.Header{Type: protocol.PacketTypeInitial}},\n\t\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\t}, nil,\n\t)\n\trequire.True(t, tc.conn.handlePacketImpl(receivedPacket{\n\t\tdata:    regular,\n\t\tbuffer:  getPacketBuffer(),\n\t\trcvTime: time.Now(),\n\t}))\n\n\t// receive a retry\n\tretry := getRetryPacket(t, tc.destConnID, tc.srcConnID, tc.destConnID, []byte(\"foobar\"))\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeRetry, gomock.Any(), gomock.Any(), logging.PacketDropUnexpectedPacket)\n\trequire.False(t, tc.conn.handlePacketImpl(retry))\n}\n\nfunc TestConnectionConnectionIDChanges(t *testing.T) {\n\tt.Run(\"with retry\", func(t *testing.T) {\n\t\ttestConnectionConnectionIDChanges(t, true)\n\t})\n\tt.Run(\"without retry\", func(t *testing.T) {\n\t\ttestConnectionConnectionIDChanges(t, false)\n\t})\n}\n\nfunc testConnectionConnectionIDChanges(t *testing.T, sendRetry bool) {\n\tmakeInitialPacket := func(t *testing.T, hdr *wire.ExtendedHeader) []byte {\n\t\tt.Helper()\n\t\tdata, err := hdr.Append(nil, protocol.Version1)\n\t\trequire.NoError(t, err)\n\t\tdata = append(data, make([]byte, hdr.Length-protocol.ByteCount(hdr.PacketNumberLen))...)\n\t\treturn data\n\t}\n\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\tunpacker := NewMockUnpacker(mockCtrl)\n\ttc := newClientTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t\tconnectionOptUnpacker(unpacker),\n\t)\n\n\tdstConnID := tc.destConnID\n\tb := make([]byte, 3*10)\n\trand.Read(b)\n\tnewConnID := protocol.ParseConnectionID(b[:11])\n\tnewConnID2 := protocol.ParseConnectionID(b[11:20])\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\ttracer.EXPECT().NegotiatedVersion(gomock.Any(), gomock.Any(), gomock.Any())\n\ttc.packer.EXPECT().PackCoalescedPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, nil).AnyTimes()\n\n\trequire.Equal(t, dstConnID, tc.conn.connIDManager.Get())\n\n\tvar retryConnID protocol.ConnectionID\n\tif sendRetry {\n\t\tretryConnID = protocol.ParseConnectionID(b[20:30])\n\t\thdrChan := make(chan *wire.Header)\n\t\ttracer.EXPECT().ReceivedRetry(gomock.Any()).Do(func(hdr *wire.Header) { hdrChan <- hdr })\n\t\ttc.packer.EXPECT().SetToken([]byte(\"foobar\"))\n\n\t\ttc.conn.handlePacket(getRetryPacket(t, retryConnID, tc.srcConnID, tc.destConnID, []byte(\"foobar\")))\n\t\tselect {\n\t\tcase hdr := <-hdrChan:\n\t\t\tassert.Equal(t, retryConnID, hdr.SrcConnectionID)\n\t\t\tassert.Equal(t, []byte(\"foobar\"), hdr.Token)\n\t\t\trequire.Equal(t, retryConnID, tc.conn.connIDManager.Get())\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t}\n\n\t// Send the first packet. The server changes the connection ID to newConnID.\n\thdr1 := wire.ExtendedHeader{\n\t\tHeader: wire.Header{\n\t\t\tSrcConnectionID:  newConnID,\n\t\t\tDestConnectionID: tc.srcConnID,\n\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\tLength:           200,\n\t\t\tVersion:          protocol.Version1,\n\t\t},\n\t\tPacketNumber:    1,\n\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t}\n\thdr2 := hdr1\n\thdr2.SrcConnectionID = newConnID2\n\n\treceivedFirst := make(chan struct{})\n\tgomock.InOrder(\n\t\tunpacker.EXPECT().UnpackLongHeader(gomock.Any(), gomock.Any()).Return(\n\t\t\t&unpackedPacket{\n\t\t\t\thdr:             &hdr1,\n\t\t\t\tencryptionLevel: protocol.EncryptionInitial,\n\t\t\t}, nil,\n\t\t),\n\t\ttracer.EXPECT().ReceivedLongHeaderPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Do(\n\t\t\tfunc(*wire.ExtendedHeader, protocol.ByteCount, protocol.ECN, []logging.Frame) { close(receivedFirst) },\n\t\t),\n\t)\n\n\ttc.conn.handlePacket(receivedPacket{data: makeInitialPacket(t, &hdr1), buffer: getPacketBuffer(), rcvTime: time.Now()})\n\n\tselect {\n\tcase <-receivedFirst:\n\t\trequire.Equal(t, newConnID, tc.conn.connIDManager.Get())\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// Send the second packet. We refuse to accept it, because the connection ID is changed again.\n\tdropped := make(chan struct{})\n\ttracer.EXPECT().DroppedPacket(logging.PacketTypeInitial, gomock.Any(), gomock.Any(), logging.PacketDropUnknownConnectionID).Do(\n\t\tfunc(logging.PacketType, protocol.PacketNumber, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\tclose(dropped)\n\t\t},\n\t)\n\n\ttc.conn.handlePacket(receivedPacket{data: makeInitialPacket(t, &hdr2), buffer: getPacketBuffer(), rcvTime: time.Now()})\n\tselect {\n\tcase <-dropped:\n\t\t// the connection ID should not have changed\n\t\trequire.Equal(t, newConnID, tc.conn.connIDManager.Get())\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// test teardown\n\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\ttracer.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any())\n\ttc.conn.destroy(nil)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\n// When the connection is closed before sending the first packet,\n// we don't send a CONNECTION_CLOSE.\n// This can happen if there's something wrong the tls.Config, and\n// crypto/tls refuses to start the handshake.\nfunc TestConnectionEarlyClose(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttr, tracer := mocklogging.NewMockConnectionTracer(mockCtrl)\n\tcryptoSetup := mocks.NewMockCryptoSetup(mockCtrl)\n\ttc := newClientTestConnection(t,\n\t\tmockCtrl,\n\t\tnil,\n\t\tfalse,\n\t\tconnectionOptTracer(tr),\n\t\tconnectionOptCryptoSetup(cryptoSetup),\n\t)\n\n\ttc.conn.sentFirstPacket = false\n\ttracer.EXPECT().ClosedConnection(gomock.Any())\n\ttracer.EXPECT().Close()\n\tcryptoSetup.EXPECT().StartHandshake(gomock.Any()).Do(func(context.Context) error {\n\t\ttc.conn.closeLocal(errors.New(\"early error\"))\n\t\treturn nil\n\t})\n\tcryptoSetup.EXPECT().NextEvent().Return(handshake.Event{Kind: handshake.EventNoEvent})\n\tcryptoSetup.EXPECT().Close()\n\ttc.connRunner.EXPECT().Remove(gomock.Any())\n\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- tc.conn.run() }()\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.Error(t, err)\n\t\trequire.ErrorContains(t, err, \"early error\")\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n"
        },
        {
          "name": "connection_timer.go",
          "type": "blob",
          "size": 1.3642578125,
          "content": "package quic\n\nimport (\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\nvar deadlineSendImmediately = time.Time{}.Add(42 * time.Millisecond) // any value > time.Time{} and before time.Now() is fine\n\ntype connectionTimer struct {\n\ttimer *utils.Timer\n\tlast  time.Time\n}\n\nfunc newTimer() *connectionTimer {\n\treturn &connectionTimer{timer: utils.NewTimer()}\n}\n\nfunc (t *connectionTimer) SetRead() {\n\tif deadline := t.timer.Deadline(); deadline != deadlineSendImmediately {\n\t\tt.last = deadline\n\t}\n\tt.timer.SetRead()\n}\n\nfunc (t *connectionTimer) Chan() <-chan time.Time {\n\treturn t.timer.Chan()\n}\n\n// SetTimer resets the timer.\n// It makes sure that the deadline is strictly increasing.\n// This prevents busy-looping in cases where the timer fires, but we can't actually send out a packet.\n// This doesn't apply to the pacing deadline, which can be set multiple times to deadlineSendImmediately.\nfunc (t *connectionTimer) SetTimer(idleTimeoutOrKeepAlive, ackAlarm, lossTime, pacing time.Time) {\n\tdeadline := idleTimeoutOrKeepAlive\n\tif !ackAlarm.IsZero() && ackAlarm.Before(deadline) && ackAlarm.After(t.last) {\n\t\tdeadline = ackAlarm\n\t}\n\tif !lossTime.IsZero() && lossTime.Before(deadline) && lossTime.After(t.last) {\n\t\tdeadline = lossTime\n\t}\n\tif !pacing.IsZero() && pacing.Before(deadline) {\n\t\tdeadline = pacing\n\t}\n\tt.timer.Reset(deadline)\n}\n\nfunc (t *connectionTimer) Stop() {\n\tt.timer.Stop()\n}\n"
        },
        {
          "name": "connection_timer_test.go",
          "type": "blob",
          "size": 1.87109375,
          "content": "package quic\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc (t *connectionTimer) Deadline() time.Time { return t.timer.Deadline() }\n\nfunc TestConnectionTimerModes(t *testing.T) {\n\tnow := time.Now()\n\n\tt.Run(\"idle timeout\", func(t *testing.T) {\n\t\ttimer := newTimer()\n\t\ttimer.SetTimer(now.Add(time.Hour), time.Time{}, time.Time{}, time.Time{})\n\t\trequire.Equal(t, now.Add(time.Hour), timer.Deadline())\n\t})\n\n\tt.Run(\"ACK timer\", func(t *testing.T) {\n\t\ttimer := newTimer()\n\t\ttimer.SetTimer(now.Add(time.Hour), now.Add(time.Minute), time.Time{}, time.Time{})\n\t\trequire.Equal(t, now.Add(time.Minute), timer.Deadline())\n\t})\n\n\tt.Run(\"loss timer\", func(t *testing.T) {\n\t\ttimer := newTimer()\n\t\ttimer.SetTimer(now.Add(time.Hour), now.Add(time.Minute), now.Add(time.Second), time.Time{})\n\t\trequire.Equal(t, now.Add(time.Second), timer.Deadline())\n\t})\n\n\tt.Run(\"pacing timer\", func(t *testing.T) {\n\t\ttimer := newTimer()\n\t\ttimer.SetTimer(now.Add(time.Hour), now.Add(time.Minute), now.Add(time.Second), now.Add(time.Millisecond))\n\t\trequire.Equal(t, now.Add(time.Millisecond), timer.Deadline())\n\t})\n}\n\nfunc TestConnectionTimerReset(t *testing.T) {\n\tnow := time.Now()\n\ttimer := newTimer()\n\ttimer.SetTimer(now.Add(time.Hour), now.Add(time.Minute), time.Time{}, time.Time{})\n\trequire.Equal(t, now.Add(time.Minute), timer.Deadline())\n\ttimer.SetRead()\n\n\ttimer.SetTimer(now.Add(time.Hour), now.Add(time.Minute), time.Time{}, time.Time{})\n\trequire.Equal(t, now.Add(time.Hour), timer.Deadline())\n}\n\nfunc TestConnectionTimerSendImmediately(t *testing.T) {\n\tnow := time.Now()\n\ttimer := newTimer()\n\ttimer.SetTimer(now.Add(time.Hour), now.Add(time.Minute), time.Time{}, time.Time{})\n\trequire.Equal(t, now.Add(time.Minute), timer.Deadline())\n\ttimer.SetRead()\n\n\ttimer.SetTimer(now.Add(time.Hour), now.Add(time.Minute), time.Time{}, deadlineSendImmediately)\n\trequire.Equal(t, deadlineSendImmediately, timer.Deadline())\n}\n"
        },
        {
          "name": "crypto_stream.go",
          "type": "blob",
          "size": 2.2626953125,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype cryptoStream struct {\n\tqueue frameSorter\n\n\thighestOffset protocol.ByteCount\n\tfinished      bool\n\n\twriteOffset protocol.ByteCount\n\twriteBuf    []byte\n}\n\nfunc newCryptoStream() *cryptoStream {\n\treturn &cryptoStream{queue: *newFrameSorter()}\n}\n\nfunc (s *cryptoStream) HandleCryptoFrame(f *wire.CryptoFrame) error {\n\thighestOffset := f.Offset + protocol.ByteCount(len(f.Data))\n\tif maxOffset := highestOffset; maxOffset > protocol.MaxCryptoStreamOffset {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.CryptoBufferExceeded,\n\t\t\tErrorMessage: fmt.Sprintf(\"received invalid offset %d on crypto stream, maximum allowed %d\", maxOffset, protocol.MaxCryptoStreamOffset),\n\t\t}\n\t}\n\tif s.finished {\n\t\tif highestOffset > s.highestOffset {\n\t\t\t// reject crypto data received after this stream was already finished\n\t\t\treturn &qerr.TransportError{\n\t\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\t\tErrorMessage: \"received crypto data after change of encryption level\",\n\t\t\t}\n\t\t}\n\t\t// ignore data with a smaller offset than the highest received\n\t\t// could e.g. be a retransmission\n\t\treturn nil\n\t}\n\ts.highestOffset = max(s.highestOffset, highestOffset)\n\treturn s.queue.Push(f.Data, f.Offset, nil)\n}\n\n// GetCryptoData retrieves data that was received in CRYPTO frames\nfunc (s *cryptoStream) GetCryptoData() []byte {\n\t_, data, _ := s.queue.Pop()\n\treturn data\n}\n\nfunc (s *cryptoStream) Finish() error {\n\tif s.queue.HasMoreData() {\n\t\treturn &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"encryption level changed, but crypto stream has more data to read\",\n\t\t}\n\t}\n\ts.finished = true\n\treturn nil\n}\n\n// Writes writes data that should be sent out in CRYPTO frames\nfunc (s *cryptoStream) Write(p []byte) (int, error) {\n\ts.writeBuf = append(s.writeBuf, p...)\n\treturn len(p), nil\n}\n\nfunc (s *cryptoStream) HasData() bool {\n\treturn len(s.writeBuf) > 0\n}\n\nfunc (s *cryptoStream) PopCryptoFrame(maxLen protocol.ByteCount) *wire.CryptoFrame {\n\tf := &wire.CryptoFrame{Offset: s.writeOffset}\n\tn := min(f.MaxDataLen(maxLen), protocol.ByteCount(len(s.writeBuf)))\n\tf.Data = s.writeBuf[:n]\n\ts.writeBuf = s.writeBuf[n:]\n\ts.writeOffset += n\n\treturn f\n}\n"
        },
        {
          "name": "crypto_stream_manager.go",
          "type": "blob",
          "size": 2.1328125,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype cryptoStreamManager struct {\n\tinitialStream   *cryptoStream\n\thandshakeStream *cryptoStream\n\toneRTTStream    *cryptoStream\n}\n\nfunc newCryptoStreamManager(\n\tinitialStream *cryptoStream,\n\thandshakeStream *cryptoStream,\n\toneRTTStream *cryptoStream,\n) *cryptoStreamManager {\n\treturn &cryptoStreamManager{\n\t\tinitialStream:   initialStream,\n\t\thandshakeStream: handshakeStream,\n\t\toneRTTStream:    oneRTTStream,\n\t}\n}\n\nfunc (m *cryptoStreamManager) HandleCryptoFrame(frame *wire.CryptoFrame, encLevel protocol.EncryptionLevel) error {\n\tvar str *cryptoStream\n\t//nolint:exhaustive // CRYPTO frames cannot be sent in 0-RTT packets.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\tstr = m.initialStream\n\tcase protocol.EncryptionHandshake:\n\t\tstr = m.handshakeStream\n\tcase protocol.Encryption1RTT:\n\t\tstr = m.oneRTTStream\n\tdefault:\n\t\treturn fmt.Errorf(\"received CRYPTO frame with unexpected encryption level: %s\", encLevel)\n\t}\n\treturn str.HandleCryptoFrame(frame)\n}\n\nfunc (m *cryptoStreamManager) GetCryptoData(encLevel protocol.EncryptionLevel) []byte {\n\tvar str *cryptoStream\n\t//nolint:exhaustive // CRYPTO frames cannot be sent in 0-RTT packets.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\tstr = m.initialStream\n\tcase protocol.EncryptionHandshake:\n\t\tstr = m.handshakeStream\n\tcase protocol.Encryption1RTT:\n\t\tstr = m.oneRTTStream\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"received CRYPTO frame with unexpected encryption level: %s\", encLevel))\n\t}\n\treturn str.GetCryptoData()\n}\n\nfunc (m *cryptoStreamManager) GetPostHandshakeData(maxSize protocol.ByteCount) *wire.CryptoFrame {\n\tif !m.oneRTTStream.HasData() {\n\t\treturn nil\n\t}\n\treturn m.oneRTTStream.PopCryptoFrame(maxSize)\n}\n\nfunc (m *cryptoStreamManager) Drop(encLevel protocol.EncryptionLevel) error {\n\t//nolint:exhaustive // 1-RTT keys should never get dropped.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\treturn m.initialStream.Finish()\n\tcase protocol.EncryptionHandshake:\n\t\treturn m.handshakeStream.Finish()\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"dropped unexpected encryption level: %s\", encLevel))\n\t}\n}\n"
        },
        {
          "name": "crypto_stream_manager_test.go",
          "type": "blob",
          "size": 2.7705078125,
          "content": "package quic\n\nimport (\n\t\"testing\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCryptoStreamManager(t *testing.T) {\n\tt.Run(\"Initial\", func(t *testing.T) {\n\t\ttestCryptoStreamManager(t, protocol.EncryptionInitial)\n\t})\n\tt.Run(\"Handshake\", func(t *testing.T) {\n\t\ttestCryptoStreamManager(t, protocol.EncryptionHandshake)\n\t})\n\tt.Run(\"1-RTT\", func(t *testing.T) {\n\t\ttestCryptoStreamManager(t, protocol.Encryption1RTT)\n\t})\n}\n\nfunc testCryptoStreamManager(t *testing.T, encLevel protocol.EncryptionLevel) {\n\tinitialStream := newCryptoStream()\n\thandshakeStream := newCryptoStream()\n\toneRTTStream := newCryptoStream()\n\tcsm := newCryptoStreamManager(initialStream, handshakeStream, oneRTTStream)\n\n\trequire.NoError(t, csm.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"foo\")}, encLevel))\n\trequire.NoError(t, csm.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"bar\"), Offset: 3}, encLevel))\n\tvar data []byte\n\tfor {\n\t\tb := csm.GetCryptoData(encLevel)\n\t\tif len(b) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tdata = append(data, b...)\n\t}\n\trequire.Equal(t, []byte(\"foobar\"), data)\n}\n\nfunc TestCryptoStreamManagerInvalidEncryptionLevel(t *testing.T) {\n\tcsm := newCryptoStreamManager(nil, nil, nil)\n\trequire.ErrorContains(t,\n\t\tcsm.HandleCryptoFrame(&wire.CryptoFrame{}, protocol.Encryption0RTT),\n\t\t\"received CRYPTO frame with unexpected encryption level\",\n\t)\n}\n\nfunc TestCryptoStreamManagerDropEncryptionLevel(t *testing.T) {\n\tt.Run(\"Initial\", func(t *testing.T) {\n\t\ttestCryptoStreamManagerDropEncryptionLevel(t, protocol.EncryptionInitial)\n\t})\n\tt.Run(\"Handshake\", func(t *testing.T) {\n\t\ttestCryptoStreamManagerDropEncryptionLevel(t, protocol.EncryptionHandshake)\n\t})\n}\n\nfunc testCryptoStreamManagerDropEncryptionLevel(t *testing.T, encLevel protocol.EncryptionLevel) {\n\tinitialStream := newCryptoStream()\n\thandshakeStream := newCryptoStream()\n\toneRTTStream := newCryptoStream()\n\tcsm := newCryptoStreamManager(initialStream, handshakeStream, oneRTTStream)\n\n\trequire.NoError(t, csm.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"foo\")}, encLevel))\n\trequire.ErrorContains(t, csm.Drop(encLevel), \"encryption level changed, but crypto stream has more data to read\")\n\n\trequire.Equal(t, []byte(\"foo\"), csm.GetCryptoData(encLevel))\n\trequire.NoError(t, csm.Drop(encLevel))\n}\n\nfunc TestCryptoStreamManagerPostHandshake(t *testing.T) {\n\tinitialStream := newCryptoStream()\n\thandshakeStream := newCryptoStream()\n\toneRTTStream := newCryptoStream()\n\tcsm := newCryptoStreamManager(initialStream, handshakeStream, oneRTTStream)\n\n\t_, err := oneRTTStream.Write([]byte(\"foo\"))\n\trequire.NoError(t, err)\n\t_, err = oneRTTStream.Write([]byte(\"bar\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t,\n\t\t&wire.CryptoFrame{Data: []byte(\"foobar\")},\n\t\tcsm.GetPostHandshakeData(protocol.ByteCount(10)),\n\t)\n}\n"
        },
        {
          "name": "crypto_stream_test.go",
          "type": "blob",
          "size": 3.3125,
          "content": "package quic\n\nimport (\n\t\"testing\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCryptoStreamDataAssembly(t *testing.T) {\n\tstr := newCryptoStream()\n\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"bar\"), Offset: 3}))\n\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"foo\")}))\n\t// receive a retransmission\n\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"bar\"), Offset: 3}))\n\n\tvar data []byte\n\tfor {\n\t\tb := str.GetCryptoData()\n\t\tif b == nil {\n\t\t\tbreak\n\t\t}\n\t\tdata = append(data, b...)\n\t}\n\trequire.Equal(t, []byte(\"foobar\"), data)\n}\n\nfunc TestCryptoStreamMaxOffset(t *testing.T) {\n\tstr := newCryptoStream()\n\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{\n\t\tOffset: protocol.MaxCryptoStreamOffset - 5,\n\t\tData:   []byte(\"foo\"),\n\t}))\n\trequire.ErrorIs(t,\n\t\tstr.HandleCryptoFrame(&wire.CryptoFrame{\n\t\t\tOffset: protocol.MaxCryptoStreamOffset - 2,\n\t\t\tData:   []byte(\"bar\"),\n\t\t}),\n\t\t&qerr.TransportError{ErrorCode: qerr.CryptoBufferExceeded},\n\t)\n}\n\nfunc TestCryptoStreamFinishWithQueuedData(t *testing.T) {\n\tt.Run(\"with data at current offset\", func(t *testing.T) {\n\t\tstr := newCryptoStream()\n\t\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"foo\")}))\n\t\trequire.Equal(t, []byte(\"foo\"), str.GetCryptoData())\n\t\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"bar\"), Offset: 3}))\n\t\trequire.ErrorIs(t, str.Finish(), &qerr.TransportError{ErrorCode: qerr.ProtocolViolation})\n\t})\n\n\tt.Run(\"with data at a higher offset\", func(t *testing.T) {\n\t\tstr := newCryptoStream()\n\t\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"foobar\"), Offset: 20}))\n\t\trequire.ErrorIs(t, str.Finish(), &qerr.TransportError{ErrorCode: qerr.ProtocolViolation})\n\t})\n}\n\nfunc TestCryptoStreamReceiveDataAfterFinish(t *testing.T) {\n\tstr := newCryptoStream()\n\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"foobar\")}))\n\trequire.Equal(t, []byte(\"foobar\"), str.GetCryptoData())\n\trequire.NoError(t, str.Finish())\n\t// receiving a retransmission is ok\n\trequire.NoError(t, str.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"bar\"), Offset: 3}))\n\t// but receiving new data is not\n\trequire.ErrorIs(t,\n\t\tstr.HandleCryptoFrame(&wire.CryptoFrame{Data: []byte(\"baz\"), Offset: 4}),\n\t\t&qerr.TransportError{ErrorCode: qerr.ProtocolViolation},\n\t)\n}\n\nfunc TestCryptoStreamWrite(t *testing.T) {\n\texpectedCryptoFrameLen := func(offset protocol.ByteCount) protocol.ByteCount {\n\t\tf := &wire.CryptoFrame{Offset: offset}\n\t\treturn f.Length(protocol.Version1)\n\t}\n\n\tstr := newCryptoStream()\n\n\trequire.False(t, str.HasData())\n\t_, err := str.Write([]byte(\"foo\"))\n\trequire.NoError(t, err)\n\trequire.True(t, str.HasData())\n\t_, err = str.Write([]byte(\"bar\"))\n\trequire.NoError(t, err)\n\t_, err = str.Write([]byte(\"baz\"))\n\trequire.NoError(t, err)\n\trequire.True(t, str.HasData())\n\n\tf := str.PopCryptoFrame(expectedCryptoFrameLen(0) + 3)\n\trequire.Equal(t, &wire.CryptoFrame{Data: []byte(\"foo\")}, f)\n\trequire.True(t, str.HasData())\n\tf = str.PopCryptoFrame(protocol.MaxByteCount)\n\t// the two write calls were coalesced into a single frame\n\trequire.Equal(t, &wire.CryptoFrame{Offset: 3, Data: []byte(\"barbaz\")}, f)\n\trequire.False(t, str.HasData())\n}\n"
        },
        {
          "name": "datagram_queue.go",
          "type": "blob",
          "size": 2.90625,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/utils/ringbuffer\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\nconst (\n\tmaxDatagramSendQueueLen = 32\n\tmaxDatagramRcvQueueLen  = 128\n)\n\ntype datagramQueue struct {\n\tsendMx    sync.Mutex\n\tsendQueue ringbuffer.RingBuffer[*wire.DatagramFrame]\n\tsent      chan struct{} // used to notify Add that a datagram was dequeued\n\n\trcvMx    sync.Mutex\n\trcvQueue [][]byte\n\trcvd     chan struct{} // used to notify Receive that a new datagram was received\n\n\tcloseErr error\n\tclosed   chan struct{}\n\n\thasData func()\n\n\tlogger utils.Logger\n}\n\nfunc newDatagramQueue(hasData func(), logger utils.Logger) *datagramQueue {\n\treturn &datagramQueue{\n\t\thasData: hasData,\n\t\trcvd:    make(chan struct{}, 1),\n\t\tsent:    make(chan struct{}, 1),\n\t\tclosed:  make(chan struct{}),\n\t\tlogger:  logger,\n\t}\n}\n\n// Add queues a new DATAGRAM frame for sending.\n// Up to 32 DATAGRAM frames will be queued.\n// Once that limit is reached, Add blocks until the queue size has reduced.\nfunc (h *datagramQueue) Add(f *wire.DatagramFrame) error {\n\th.sendMx.Lock()\n\n\tfor {\n\t\tif h.sendQueue.Len() < maxDatagramSendQueueLen {\n\t\t\th.sendQueue.PushBack(f)\n\t\t\th.sendMx.Unlock()\n\t\t\th.hasData()\n\t\t\treturn nil\n\t\t}\n\t\tselect {\n\t\tcase <-h.sent: // drain the queue so we don't loop immediately\n\t\tdefault:\n\t\t}\n\t\th.sendMx.Unlock()\n\t\tselect {\n\t\tcase <-h.closed:\n\t\t\treturn h.closeErr\n\t\tcase <-h.sent:\n\t\t}\n\t\th.sendMx.Lock()\n\t}\n}\n\n// Peek gets the next DATAGRAM frame for sending.\n// If actually sent out, Pop needs to be called before the next call to Peek.\nfunc (h *datagramQueue) Peek() *wire.DatagramFrame {\n\th.sendMx.Lock()\n\tdefer h.sendMx.Unlock()\n\tif h.sendQueue.Empty() {\n\t\treturn nil\n\t}\n\treturn h.sendQueue.PeekFront()\n}\n\nfunc (h *datagramQueue) Pop() {\n\th.sendMx.Lock()\n\tdefer h.sendMx.Unlock()\n\t_ = h.sendQueue.PopFront()\n\tselect {\n\tcase h.sent <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// HandleDatagramFrame handles a received DATAGRAM frame.\nfunc (h *datagramQueue) HandleDatagramFrame(f *wire.DatagramFrame) {\n\tdata := make([]byte, len(f.Data))\n\tcopy(data, f.Data)\n\tvar queued bool\n\th.rcvMx.Lock()\n\tif len(h.rcvQueue) < maxDatagramRcvQueueLen {\n\t\th.rcvQueue = append(h.rcvQueue, data)\n\t\tqueued = true\n\t\tselect {\n\t\tcase h.rcvd <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\th.rcvMx.Unlock()\n\tif !queued && h.logger.Debug() {\n\t\th.logger.Debugf(\"Discarding received DATAGRAM frame (%d bytes payload)\", len(f.Data))\n\t}\n}\n\n// Receive gets a received DATAGRAM frame.\nfunc (h *datagramQueue) Receive(ctx context.Context) ([]byte, error) {\n\tfor {\n\t\th.rcvMx.Lock()\n\t\tif len(h.rcvQueue) > 0 {\n\t\t\tdata := h.rcvQueue[0]\n\t\t\th.rcvQueue = h.rcvQueue[1:]\n\t\t\th.rcvMx.Unlock()\n\t\t\treturn data, nil\n\t\t}\n\t\th.rcvMx.Unlock()\n\t\tselect {\n\t\tcase <-h.rcvd:\n\t\t\tcontinue\n\t\tcase <-h.closed:\n\t\t\treturn nil, h.closeErr\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\t}\n\t}\n}\n\nfunc (h *datagramQueue) CloseWithError(e error) {\n\th.closeErr = e\n\tclose(h.closed)\n}\n"
        },
        {
          "name": "datagram_queue_test.go",
          "type": "blob",
          "size": 4.2431640625,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestDatagramQueuePeekAndPop(t *testing.T) {\n\tvar queued []struct{}\n\tqueue := newDatagramQueue(func() { queued = append(queued, struct{}{}) }, utils.DefaultLogger)\n\trequire.Nil(t, queue.Peek())\n\trequire.Empty(t, queued)\n\trequire.NoError(t, queue.Add(&wire.DatagramFrame{Data: []byte(\"foo\")}))\n\trequire.Len(t, queued, 1)\n\trequire.Equal(t, &wire.DatagramFrame{Data: []byte(\"foo\")}, queue.Peek())\n\t// calling peek again returns the same datagram\n\trequire.Equal(t, &wire.DatagramFrame{Data: []byte(\"foo\")}, queue.Peek())\n\tqueue.Pop()\n\trequire.Nil(t, queue.Peek())\n}\n\nfunc TestDatagramQueueSendQueueLength(t *testing.T) {\n\tqueue := newDatagramQueue(func() {}, utils.DefaultLogger)\n\n\tfor i := 0; i < maxDatagramSendQueueLen; i++ {\n\t\trequire.NoError(t, queue.Add(&wire.DatagramFrame{Data: []byte{0}}))\n\t}\n\terrChan := make(chan error, 1)\n\tgo func() { errChan <- queue.Add(&wire.DatagramFrame{Data: []byte(\"foobar\")}) }()\n\n\tselect {\n\tcase <-errChan:\n\t\tt.Fatal(\"expected to not receive error\")\n\tcase <-time.After(scaleDuration(10 * time.Millisecond)):\n\t}\n\n\t// peeking doesn't remove the datagram from the queue...\n\trequire.NotNil(t, queue.Peek())\n\tselect {\n\tcase <-errChan:\n\t\tt.Fatal(\"expected to not receive error\")\n\tcase <-time.After(scaleDuration(10 * time.Millisecond)):\n\t}\n\n\t// ...but popping does\n\tqueue.Pop()\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\t// pop all the remaining datagrams\n\tfor i := 1; i < maxDatagramSendQueueLen; i++ {\n\t\tqueue.Pop()\n\t}\n\tf := queue.Peek()\n\trequire.NotNil(t, f)\n\trequire.Equal(t, &wire.DatagramFrame{Data: []byte(\"foobar\")}, f)\n}\n\nfunc TestDatagramQueueReceive(t *testing.T) {\n\tqueue := newDatagramQueue(func() {}, utils.DefaultLogger)\n\n\t// receive frames that were received earlier\n\tqueue.HandleDatagramFrame(&wire.DatagramFrame{Data: []byte(\"foo\")})\n\tqueue.HandleDatagramFrame(&wire.DatagramFrame{Data: []byte(\"bar\")})\n\tdata, err := queue.Receive(context.Background())\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"foo\"), data)\n\tdata, err = queue.Receive(context.Background())\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"bar\"), data)\n}\n\nfunc TestDatagramQueueReceiveBlocking(t *testing.T) {\n\tqueue := newDatagramQueue(func() {}, utils.DefaultLogger)\n\n\t// block until a new frame is received\n\ttype result struct {\n\t\tdata []byte\n\t\terr  error\n\t}\n\tresultChan := make(chan result, 1)\n\tgo func() {\n\t\tdata, err := queue.Receive(context.Background())\n\t\tresultChan <- result{data, err}\n\t}()\n\n\tselect {\n\tcase <-resultChan:\n\t\tt.Fatal(\"expected to not receive result\")\n\tcase <-time.After(scaleDuration(10 * time.Millisecond)):\n\t}\n\tqueue.HandleDatagramFrame(&wire.DatagramFrame{Data: []byte(\"foobar\")})\n\tselect {\n\tcase result := <-resultChan:\n\t\trequire.NoError(t, result.err)\n\t\trequire.Equal(t, []byte(\"foobar\"), result.data)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// unblock when the context is canceled\n\tctx, cancel := context.WithCancel(context.Background())\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := queue.Receive(ctx)\n\t\terrChan <- err\n\t}()\n\tselect {\n\tcase <-errChan:\n\t\tt.Fatal(\"expected to not receive error\")\n\tcase <-time.After(scaleDuration(10 * time.Millisecond)):\n\t}\n\tcancel()\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, context.Canceled)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestDatagramQueueClose(t *testing.T) {\n\tqueue := newDatagramQueue(func() {}, utils.DefaultLogger)\n\n\tfor i := 0; i < maxDatagramSendQueueLen; i++ {\n\t\trequire.NoError(t, queue.Add(&wire.DatagramFrame{Data: []byte{0}}))\n\t}\n\terrChan1 := make(chan error, 1)\n\tgo func() { errChan1 <- queue.Add(&wire.DatagramFrame{Data: []byte(\"foobar\")}) }()\n\terrChan2 := make(chan error, 1)\n\tgo func() {\n\t\t_, err := queue.Receive(context.Background())\n\t\terrChan2 <- err\n\t}()\n\n\tqueue.CloseWithError(errors.New(\"test error\"))\n\n\tselect {\n\tcase err := <-errChan1:\n\t\trequire.EqualError(t, err, \"test error\")\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tselect {\n\tcase err := <-errChan2:\n\t\trequire.EqualError(t, err, \"test error\")\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 2.4345703125,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n)\n\ntype (\n\tTransportError          = qerr.TransportError\n\tApplicationError        = qerr.ApplicationError\n\tVersionNegotiationError = qerr.VersionNegotiationError\n\tStatelessResetError     = qerr.StatelessResetError\n\tIdleTimeoutError        = qerr.IdleTimeoutError\n\tHandshakeTimeoutError   = qerr.HandshakeTimeoutError\n)\n\ntype (\n\tTransportErrorCode   = qerr.TransportErrorCode\n\tApplicationErrorCode = qerr.ApplicationErrorCode\n\tStreamErrorCode      = qerr.StreamErrorCode\n)\n\nconst (\n\tNoError                   = qerr.NoError\n\tInternalError             = qerr.InternalError\n\tConnectionRefused         = qerr.ConnectionRefused\n\tFlowControlError          = qerr.FlowControlError\n\tStreamLimitError          = qerr.StreamLimitError\n\tStreamStateError          = qerr.StreamStateError\n\tFinalSizeError            = qerr.FinalSizeError\n\tFrameEncodingError        = qerr.FrameEncodingError\n\tTransportParameterError   = qerr.TransportParameterError\n\tConnectionIDLimitError    = qerr.ConnectionIDLimitError\n\tProtocolViolation         = qerr.ProtocolViolation\n\tInvalidToken              = qerr.InvalidToken\n\tApplicationErrorErrorCode = qerr.ApplicationErrorErrorCode\n\tCryptoBufferExceeded      = qerr.CryptoBufferExceeded\n\tKeyUpdateError            = qerr.KeyUpdateError\n\tAEADLimitReached          = qerr.AEADLimitReached\n\tNoViablePathError         = qerr.NoViablePathError\n)\n\n// A StreamError is used for Stream.CancelRead and Stream.CancelWrite.\n// It is also returned from Stream.Read and Stream.Write if the peer canceled reading or writing.\ntype StreamError struct {\n\tStreamID  StreamID\n\tErrorCode StreamErrorCode\n\tRemote    bool\n}\n\nfunc (e *StreamError) Is(target error) bool {\n\tt, ok := target.(*StreamError)\n\treturn ok && e.StreamID == t.StreamID && e.ErrorCode == t.ErrorCode && e.Remote == t.Remote\n}\n\nfunc (e *StreamError) Error() string {\n\tpers := \"local\"\n\tif e.Remote {\n\t\tpers = \"remote\"\n\t}\n\treturn fmt.Sprintf(\"stream %d canceled by %s with error code %d\", e.StreamID, pers, e.ErrorCode)\n}\n\n// DatagramTooLargeError is returned from Connection.SendDatagram if the payload is too large to be sent.\ntype DatagramTooLargeError struct {\n\tMaxDatagramPayloadSize int64\n}\n\nfunc (e *DatagramTooLargeError) Is(target error) bool {\n\tt, ok := target.(*DatagramTooLargeError)\n\treturn ok && e.MaxDatagramPayloadSize == t.MaxDatagramPayloadSize\n}\n\nfunc (e *DatagramTooLargeError) Error() string { return \"DATAGRAM frame too large\" }\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 1.1455078125,
          "content": "package quic\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestStreamError(t *testing.T) {\n\trequire.True(t, errors.Is(\n\t\t&StreamError{StreamID: 1, ErrorCode: 2, Remote: true},\n\t\t&StreamError{StreamID: 1, ErrorCode: 2, Remote: true},\n\t))\n\trequire.False(t, errors.Is(&StreamError{StreamID: 1}, &StreamError{StreamID: 2}))\n\trequire.False(t, errors.Is(&StreamError{StreamID: 1}, &StreamError{StreamID: 2}))\n\trequire.Equal(t,\n\t\t\"stream 1 canceled by remote with error code 2\",\n\t\t(&StreamError{StreamID: 1, ErrorCode: 2, Remote: true}).Error(),\n\t)\n\trequire.Equal(t,\n\t\t\"stream 42 canceled by local with error code 1337\",\n\t\t(&StreamError{StreamID: 42, ErrorCode: 1337, Remote: false}).Error(),\n\t)\n}\n\nfunc TestDatagramTooLargeError(t *testing.T) {\n\trequire.True(t, errors.Is(\n\t\t&DatagramTooLargeError{MaxDatagramPayloadSize: 1024},\n\t\t&DatagramTooLargeError{MaxDatagramPayloadSize: 1024},\n\t))\n\trequire.False(t, errors.Is(\n\t\t&DatagramTooLargeError{MaxDatagramPayloadSize: 1024},\n\t\t&DatagramTooLargeError{MaxDatagramPayloadSize: 1025},\n\t))\n\trequire.Equal(t, \"DATAGRAM frame too large\", (&DatagramTooLargeError{MaxDatagramPayloadSize: 1024}).Error())\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "frame_sorter.go",
          "type": "blob",
          "size": 6.0517578125,
          "content": "package quic\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\tlist \"github.com/quic-go/quic-go/internal/utils/linkedlist\"\n)\n\n// byteInterval is an interval from one ByteCount to the other\ntype byteInterval struct {\n\tStart protocol.ByteCount\n\tEnd   protocol.ByteCount\n}\n\nvar byteIntervalElementPool sync.Pool\n\nfunc init() {\n\tbyteIntervalElementPool = *list.NewPool[byteInterval]()\n}\n\ntype frameSorterEntry struct {\n\tData   []byte\n\tDoneCb func()\n}\n\ntype frameSorter struct {\n\tqueue   map[protocol.ByteCount]frameSorterEntry\n\treadPos protocol.ByteCount\n\tgaps    *list.List[byteInterval]\n}\n\nvar errDuplicateStreamData = errors.New(\"duplicate stream data\")\n\nfunc newFrameSorter() *frameSorter {\n\ts := frameSorter{\n\t\tgaps:  list.NewWithPool[byteInterval](&byteIntervalElementPool),\n\t\tqueue: make(map[protocol.ByteCount]frameSorterEntry),\n\t}\n\ts.gaps.PushFront(byteInterval{Start: 0, End: protocol.MaxByteCount})\n\treturn &s\n}\n\nfunc (s *frameSorter) Push(data []byte, offset protocol.ByteCount, doneCb func()) error {\n\terr := s.push(data, offset, doneCb)\n\tif err == errDuplicateStreamData {\n\t\tif doneCb != nil {\n\t\t\tdoneCb()\n\t\t}\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc (s *frameSorter) push(data []byte, offset protocol.ByteCount, doneCb func()) error {\n\tif len(data) == 0 {\n\t\treturn errDuplicateStreamData\n\t}\n\n\tstart := offset\n\tend := offset + protocol.ByteCount(len(data))\n\n\tif end <= s.gaps.Front().Value.Start {\n\t\treturn errDuplicateStreamData\n\t}\n\n\tstartGap, startsInGap := s.findStartGap(start)\n\tendGap, endsInGap := s.findEndGap(startGap, end)\n\n\tstartGapEqualsEndGap := startGap == endGap\n\n\tif (startGapEqualsEndGap && end <= startGap.Value.Start) ||\n\t\t(!startGapEqualsEndGap && startGap.Value.End >= endGap.Value.Start && end <= startGap.Value.Start) {\n\t\treturn errDuplicateStreamData\n\t}\n\n\tstartGapNext := startGap.Next()\n\tstartGapEnd := startGap.Value.End // save it, in case startGap is modified\n\tendGapStart := endGap.Value.Start // save it, in case endGap is modified\n\tendGapEnd := endGap.Value.End     // save it, in case endGap is modified\n\tvar adjustedStartGapEnd bool\n\tvar wasCut bool\n\n\tpos := start\n\tvar hasReplacedAtLeastOne bool\n\tfor {\n\t\toldEntry, ok := s.queue[pos]\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\toldEntryLen := protocol.ByteCount(len(oldEntry.Data))\n\t\tif end-pos > oldEntryLen || (hasReplacedAtLeastOne && end-pos == oldEntryLen) {\n\t\t\t// The existing frame is shorter than the new frame. Replace it.\n\t\t\tdelete(s.queue, pos)\n\t\t\tpos += oldEntryLen\n\t\t\thasReplacedAtLeastOne = true\n\t\t\tif oldEntry.DoneCb != nil {\n\t\t\t\toldEntry.DoneCb()\n\t\t\t}\n\t\t} else {\n\t\t\tif !hasReplacedAtLeastOne {\n\t\t\t\treturn errDuplicateStreamData\n\t\t\t}\n\t\t\t// The existing frame is longer than the new frame.\n\t\t\t// Cut the new frame such that the end aligns with the start of the existing frame.\n\t\t\tdata = data[:pos-start]\n\t\t\tend = pos\n\t\t\twasCut = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !startsInGap && !hasReplacedAtLeastOne {\n\t\t// cut the frame, such that it starts at the start of the gap\n\t\tdata = data[startGap.Value.Start-start:]\n\t\tstart = startGap.Value.Start\n\t\twasCut = true\n\t}\n\tif start <= startGap.Value.Start {\n\t\tif end >= startGap.Value.End {\n\t\t\t// The frame covers the whole startGap. Delete the gap.\n\t\t\ts.gaps.Remove(startGap)\n\t\t} else {\n\t\t\tstartGap.Value.Start = end\n\t\t}\n\t} else if !hasReplacedAtLeastOne {\n\t\tstartGap.Value.End = start\n\t\tadjustedStartGapEnd = true\n\t}\n\n\tif !startGapEqualsEndGap {\n\t\ts.deleteConsecutive(startGapEnd)\n\t\tvar nextGap *list.Element[byteInterval]\n\t\tfor gap := startGapNext; gap.Value.End < endGapStart; gap = nextGap {\n\t\t\tnextGap = gap.Next()\n\t\t\ts.deleteConsecutive(gap.Value.End)\n\t\t\ts.gaps.Remove(gap)\n\t\t}\n\t}\n\n\tif !endsInGap && start != endGapEnd && end > endGapEnd {\n\t\t// cut the frame, such that it ends at the end of the gap\n\t\tdata = data[:endGapEnd-start]\n\t\tend = endGapEnd\n\t\twasCut = true\n\t}\n\tif end == endGapEnd {\n\t\tif !startGapEqualsEndGap {\n\t\t\t// The frame covers the whole endGap. Delete the gap.\n\t\t\ts.gaps.Remove(endGap)\n\t\t}\n\t} else {\n\t\tif startGapEqualsEndGap && adjustedStartGapEnd {\n\t\t\t// The frame split the existing gap into two.\n\t\t\ts.gaps.InsertAfter(byteInterval{Start: end, End: startGapEnd}, startGap)\n\t\t} else if !startGapEqualsEndGap {\n\t\t\tendGap.Value.Start = end\n\t\t}\n\t}\n\n\tif wasCut && len(data) < protocol.MinStreamFrameBufferSize {\n\t\tnewData := make([]byte, len(data))\n\t\tcopy(newData, data)\n\t\tdata = newData\n\t\tif doneCb != nil {\n\t\t\tdoneCb()\n\t\t\tdoneCb = nil\n\t\t}\n\t}\n\n\tif s.gaps.Len() > protocol.MaxStreamFrameSorterGaps {\n\t\treturn errors.New(\"too many gaps in received data\")\n\t}\n\n\ts.queue[start] = frameSorterEntry{Data: data, DoneCb: doneCb}\n\treturn nil\n}\n\nfunc (s *frameSorter) findStartGap(offset protocol.ByteCount) (*list.Element[byteInterval], bool) {\n\tfor gap := s.gaps.Front(); gap != nil; gap = gap.Next() {\n\t\tif offset >= gap.Value.Start && offset <= gap.Value.End {\n\t\t\treturn gap, true\n\t\t}\n\t\tif offset < gap.Value.Start {\n\t\t\treturn gap, false\n\t\t}\n\t}\n\tpanic(\"no gap found\")\n}\n\nfunc (s *frameSorter) findEndGap(startGap *list.Element[byteInterval], offset protocol.ByteCount) (*list.Element[byteInterval], bool) {\n\tfor gap := startGap; gap != nil; gap = gap.Next() {\n\t\tif offset >= gap.Value.Start && offset < gap.Value.End {\n\t\t\treturn gap, true\n\t\t}\n\t\tif offset < gap.Value.Start {\n\t\t\treturn gap.Prev(), false\n\t\t}\n\t}\n\tpanic(\"no gap found\")\n}\n\n// deleteConsecutive deletes consecutive frames from the queue, starting at pos\nfunc (s *frameSorter) deleteConsecutive(pos protocol.ByteCount) {\n\tfor {\n\t\toldEntry, ok := s.queue[pos]\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\toldEntryLen := protocol.ByteCount(len(oldEntry.Data))\n\t\tdelete(s.queue, pos)\n\t\tif oldEntry.DoneCb != nil {\n\t\t\toldEntry.DoneCb()\n\t\t}\n\t\tpos += oldEntryLen\n\t}\n}\n\nfunc (s *frameSorter) Pop() (protocol.ByteCount, []byte, func()) {\n\tentry, ok := s.queue[s.readPos]\n\tif !ok {\n\t\treturn s.readPos, nil, nil\n\t}\n\tdelete(s.queue, s.readPos)\n\toffset := s.readPos\n\ts.readPos += protocol.ByteCount(len(entry.Data))\n\tif s.gaps.Front().Value.End <= s.readPos {\n\t\tpanic(\"frame sorter BUG: read position higher than a gap\")\n\t}\n\treturn offset, entry.Data, entry.DoneCb\n}\n\n// HasMoreData says if there is any more data queued at *any* offset.\nfunc (s *frameSorter) HasMoreData() bool {\n\treturn len(s.queue) > 0\n}\n"
        },
        {
          "name": "frame_sorter_test.go",
          "type": "blob",
          "size": 40.6123046875,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\ntype callbackTracker struct {\n\tcalled *bool\n\tcb     func()\n}\n\nfunc (t *callbackTracker) WasCalled() bool { return *t.called }\n\nfunc getFrameSorterTestCallback(t *testing.T) (func(), callbackTracker) {\n\tvar called bool\n\tcb := func() {\n\t\tif called {\n\t\t\tt.Fatal(\"double free\")\n\t\t}\n\t\tcalled = true\n\t}\n\treturn cb, callbackTracker{\n\t\tcb:     cb,\n\t\tcalled: &called,\n\t}\n}\n\nfunc TestFrameSorterSimpleCases(t *testing.T) {\n\ts := newFrameSorter()\n\t_, data, doneCb := s.Pop()\n\trequire.Nil(t, data)\n\trequire.Nil(t, doneCb)\n\n\t// empty frames are ignored\n\trequire.NoError(t, s.Push(nil, 0, nil))\n\t_, data, doneCb = s.Pop()\n\trequire.Nil(t, data)\n\trequire.Nil(t, doneCb)\n\n\tcb1, t1 := getFrameSorterTestCallback(t)\n\tcb2, t2 := getFrameSorterTestCallback(t)\n\trequire.NoError(t, s.Push([]byte(\"bar\"), 3, cb2))\n\trequire.True(t, s.HasMoreData())\n\trequire.NoError(t, s.Push([]byte(\"foo\"), 0, cb1))\n\n\toffset, data, doneCb := s.Pop()\n\trequire.Equal(t, []byte(\"foo\"), data)\n\trequire.Zero(t, offset)\n\trequire.NotNil(t, doneCb)\n\tdoneCb()\n\trequire.True(t, t1.WasCalled())\n\trequire.False(t, t2.WasCalled())\n\trequire.True(t, s.HasMoreData())\n\n\toffset, data, doneCb = s.Pop()\n\trequire.Equal(t, []byte(\"bar\"), data)\n\trequire.Equal(t, protocol.ByteCount(3), offset)\n\trequire.NotNil(t, doneCb)\n\tdoneCb()\n\trequire.True(t, t2.WasCalled())\n\trequire.False(t, s.HasMoreData())\n\n\t// now receive a duplicate\n\tcb3, t3 := getFrameSorterTestCallback(t)\n\trequire.NoError(t, s.Push([]byte(\"foo\"), 0, cb3))\n\trequire.False(t, s.HasMoreData())\n\trequire.True(t, t3.WasCalled())\n\n\t// now receive a later frame that overlaps with the ones we already consumed\n\tcb4, _ := getFrameSorterTestCallback(t)\n\trequire.NoError(t, s.Push([]byte(\"barbaz\"), 3, cb4))\n\trequire.True(t, s.HasMoreData())\n\n\toffset, data, _ = s.Pop()\n\trequire.Equal(t, protocol.ByteCount(6), offset)\n\trequire.Equal(t, []byte(\"baz\"), data)\n\trequire.False(t, s.HasMoreData())\n}\n\n// Usually, it's not a good idea to test the implementation details.\n// However, we need to make sure that the frame sorter handles gaps correctly,\n// in particular when overlapping stream data is received.\n// This also includes returning buffers that are no longer needed.\nfunc TestFrameSorterGapHandling(t *testing.T) {\n\tgetData := func(l protocol.ByteCount) []byte {\n\t\tb := make([]byte, l)\n\t\trand.Read(b)\n\t\treturn b\n\t}\n\n\tcheckQueue := func(t *testing.T, s *frameSorter, m map[protocol.ByteCount][]byte) {\n\t\trequire.Equal(t, len(m), len(s.queue))\n\t\tfor offset, data := range m {\n\t\t\trequire.Contains(t, s.queue, offset)\n\t\t\trequire.Equal(t, data, s.queue[offset].Data)\n\t\t}\n\t}\n\n\tcheckGaps := func(t *testing.T, s *frameSorter, expectedGaps []byteInterval) {\n\t\tif s.gaps.Len() != len(expectedGaps) {\n\t\t\tfmt.Println(\"Gaps:\")\n\t\t\tfor gap := s.gaps.Front(); gap != nil; gap = gap.Next() {\n\t\t\t\tfmt.Printf(\"\\t%d - %d\\n\", gap.Value.Start, gap.Value.End)\n\t\t\t}\n\t\t\trequire.Equal(t, len(expectedGaps), s.gaps.Len())\n\t\t}\n\t\tvar i int\n\t\tfor gap := s.gaps.Front(); gap != nil; gap = gap.Next() {\n\t\t\trequire.Equal(t, expectedGaps[i], gap.Value)\n\t\t\ti++\n\t\t}\n\t}\n\n\t// ---xxx--------------\n\t//       ++++++\n\t// =>\n\t// ---xxx++++++--------\n\tt.Run(\"case 1\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 11\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t6: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 11, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// ---xxx-----------------\n\t//          +++++++\n\t// =>\n\t// ---xxx---+++++++--------\n\tt.Run(\"case 2\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 10, cb2)) // 10 -15\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t10: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 6, End: 10},\n\t\t\t{Start: 15, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// ---xxx----xxxxxx-------\n\t//       ++++\n\t// =>\n\t// ---xxx++++xxxxx--------\n\tt.Run(\"case 3\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f3, 10, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f2, 6, cb3))  // 6 - 10\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t6:  f2,\n\t\t\t10: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 15, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ----xxxx-------\n\t//       ++++\n\t// =>\n\t// ----xxxx++-----\n\tt.Run(\"case 4\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(4)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 7\n\t\trequire.NoError(t, s.Push(f2, 5, cb2)) // 5 - 9\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t7: f2[2:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 9, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\n\tt.Run(\"case 4, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 2))\n\t\tf1 := getData(4 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 7\n\t\trequire.NoError(t, s.Push(f2, 5*mult, cb2)) // 5 - 9\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult: f1,\n\t\t\t7 * mult: f2[2*mult:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 9 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// xxxx-------\n\t//    ++++\n\t// =>\n\t// xxxx+++-----\n\tt.Run(\"case 5\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(4)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 0, cb1)) // 0 - 4\n\t\trequire.NoError(t, s.Push(f2, 3, cb2)) // 3 - 7\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t0: f1,\n\t\t\t4: f2[1:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 7, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\n\tt.Run(\"case 5, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 2))\n\t\tf1 := getData(4 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 0, cb1))      // 0 - 4\n\t\trequire.NoError(t, s.Push(f2, 3*mult, cb2)) // 3 - 7\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t0:        f1,\n\t\t\t4 * mult: f2[mult:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 7 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// ----xxxx-------\n\t//   ++++\n\t// =>\n\t// --++xxxx-------\n\tt.Run(\"case 6\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(4)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 9\n\t\trequire.NoError(t, s.Push(f2, 3, cb2)) // 3 - 7\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f2[:2],\n\t\t\t5: f1,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 9, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\n\tt.Run(\"case 6, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 2))\n\t\tf1 := getData(4 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5*mult, cb1)) // 5 - 9\n\t\trequire.NoError(t, s.Push(f2, 3*mult, cb2)) // 3 - 7\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult: f2[:2*mult],\n\t\t\t5 * mult: f1,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 9 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// ---xxx----xxxxxx-------\n\t//       ++\n\t// =>\n\t// ---xxx++--xxxxx--------\n\tt.Run(\"case 7\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(2)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f3, 10, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f2, 6, cb3))  // 6 - 8\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t6:  f2,\n\t\t\t10: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 8, End: 10},\n\t\t\t{Start: 15, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx---------xxxxxx--\n\t//          ++\n\t// =>\n\t// ---xxx---++----xxxxx--\n\tt.Run(\"case 8\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(2)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f3, 15, cb2)) // 15 - 20\n\t\trequire.NoError(t, s.Push(f2, 10, cb3)) // 10 - 12\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t10: f2,\n\t\t\t15: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 6, End: 10},\n\t\t\t{Start: 12, End: 15},\n\t\t\t{Start: 20, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx----xxxxxx-------\n\t//         ++\n\t// =>\n\t// ---xxx--++xxxxx--------\n\tt.Run(\"case 9\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(2)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f3, 10, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f2, 8, cb3))  // 8 - 10\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t8:  f2,\n\t\t\t10: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 6, End: 8},\n\t\t\t{Start: 15, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx----=====-------\n\t//      +++++++\n\t// =>\n\t// ---xxx++++=====--------\n\tt.Run(\"case 10\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 10, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f3, 5, cb3))  // 5 - 11\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t6:  f3[1:5],\n\t\t\t10: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 15, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\tt.Run(\"case 10, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 4))\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 10*mult, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f3, 5*mult, cb3))  // 5 - 11\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult:  f1,\n\t\t\t6 * mult:  f3[mult : 5*mult],\n\t\t\t10 * mult: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 15 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxxx----=====-------\n\t//      ++++++\n\t// =>\n\t// ---xxx++++=====--------\n\tt.Run(\"case 11\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(4)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 7\n\t\trequire.NoError(t, s.Push(f2, 10, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f3, 5, cb3))  // 5 - 10\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t7:  f3[2:],\n\t\t\t10: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 15, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\t// ---xxxx----=====-------\n\t//      ++++++\n\t// =>\n\t// ---xxx++++=====--------\n\tt.Run(\"case 11, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 3))\n\t\tf1 := getData(4 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1))  // 3 - 7\n\t\trequire.NoError(t, s.Push(f2, 10*mult, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f3, 5*mult, cb3))  // 5 - 10\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult:  f1,\n\t\t\t7 * mult:  f3[2*mult:],\n\t\t\t10 * mult: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 15 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ----xxxx-------\n\t//     +++++++\n\t// =>\n\t// ----+++++++-----\n\tt.Run(\"case 12\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(4)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(7)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 7\n\t\trequire.NoError(t, s.Push(f2, 3, cb2)) // 3 - 10\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// ----xxx===-------\n\t//     +++++++\n\t// =>\n\t// ----+++++++-----\n\tt.Run(\"case 13\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(7)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 9\n\t\trequire.NoError(t, s.Push(f3, 3, cb3)) // 3 - 10\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ----xxx====-------\n\t//     +++++\n\t// =>\n\t// ----+++====-----\n\tt.Run(\"case 14\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 10\n\t\trequire.NoError(t, s.Push(f3, 3, cb3)) // 3 - 8\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f3[:3],\n\t\t\t6: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\tt.Run(\"case 14, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 3))\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6*mult, cb2)) // 6 - 10\n\t\trequire.NoError(t, s.Push(f3, 3*mult, cb3)) // 3 - 8\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult: f3[:3*mult],\n\t\t\t6 * mult: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 10 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ----xxx===-------\n\t//     ++++++\n\t// =>\n\t// ----++++++-----\n\tt.Run(\"case 15\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 9\n\t\trequire.NoError(t, s.Push(f3, 3, cb3)) // 3 - 9\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 9, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxxx-------\n\t//    ++++\n\t// =>\n\t// ---xxxx-----\n\tt.Run(\"case 16\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(4)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 9\n\t\trequire.NoError(t, s.Push(f2, 5, cb2)) // 5 - 9\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t5: f1,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 5},\n\t\t\t{Start: 9, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\n\t// ----xxx===-------\n\t//     +++\n\t// =>\n\t// ----xxx===-----\n\tt.Run(\"case 17\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(3)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 9\n\t\trequire.NoError(t, s.Push(f3, 3, cb3)) // 3 - 6\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t6: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 9, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\t// ---xxxx-------\n\t//    ++\n\t// =>\n\t// ---xxxx-----\n\tt.Run(\"case 18\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(4)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(2)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 9\n\t\trequire.NoError(t, s.Push(f2, 5, cb2)) // 5 - 7\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t5: f1,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 5},\n\t\t\t{Start: 9, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\n\t// ---xxxxx------\n\t//     ++\n\t// =>\n\t// ---xxxxx----\n\tt.Run(\"case 19\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(5)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(2)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 10\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t5: f1,\n\t\t})\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 8\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t5: f1,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 5},\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\n\t// xxxxx------\n\t//  ++\n\t// =>\n\t// xxxxx------\n\tt.Run(\"case 20\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(10)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 0, cb1)) // 0 - 10\n\t\trequire.NoError(t, s.Push(f2, 5, cb2)) // 5 - 9\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t0: f1,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\t// ---xxxxx---\n\t//      +++\n\t// =>\n\t// ---xxxxx---\n\tt.Run(\"case 21\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(5)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 10\n\t\trequire.NoError(t, s.Push(f2, 7, cb2)) // 7 - 10\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 5},\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t5: f1,\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t})\n\n\t// ----xxx------\n\t//   +++++\n\t// =>\n\t// --+++++----\n\tt.Run(\"case 22\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 8\n\t\trequire.NoError(t, s.Push(f2, 3, cb2)) // 3 - 8\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 8, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// ----xxx===------\n\t//   ++++++++\n\t// =>\n\t// --++++++++----\n\tt.Run(\"case 23\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(8)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 8\n\t\trequire.NoError(t, s.Push(f2, 8, cb2)) // 8 - 11\n\t\trequire.NoError(t, s.Push(f3, 3, cb3)) // 3 - 11\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 11, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// --xxx---===---\n\t//      ++++++\n\t// =>\n\t// --xxx++++++----\n\tt.Run(\"case 24\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9, cb2)) // 9 - 12\n\t\trequire.NoError(t, s.Push(f3, 6, cb3)) // 6 - 12\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t6: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 12, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// --xxx---===---###\n\t//      +++++++++\n\t// =>\n\t// --xxx+++++++++###\n\tt.Run(\"case 25\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(3)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\tf4 := getData(9)\n\t\tcb4, t4 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1))  // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9, cb2))  // 9 - 12\n\t\trequire.NoError(t, s.Push(f3, 15, cb3)) // 15 - 18\n\t\trequire.NoError(t, s.Push(f4, 6, cb4))  // 6 - 15\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3:  f1,\n\t\t\t6:  f4,\n\t\t\t15: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 18, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t\trequire.False(t, t4.WasCalled())\n\t})\n\n\t// ----xxx------\n\t//   +++++++\n\t// =>\n\t// --+++++++---\n\tt.Run(\"case 26\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(10)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1)) // 5 - 8\n\t\trequire.NoError(t, s.Push(f2, 3, cb2)) // 3 - 13\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 13, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t})\n\n\t// ---xxx====---\n\t//   ++++\n\t// =>\n\t// --+xxx====---\n\tt.Run(\"case 27\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(4)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 10\n\t\trequire.NoError(t, s.Push(f3, 2, cb3)) // 2 - 6\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t2: f3[:1],\n\t\t\t3: f1,\n\t\t\t6: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 2},\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\tt.Run(\"case 27, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tconst mult = protocol.MinStreamFrameSize\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(4 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6*mult, cb2)) // 6 - 10\n\t\trequire.NoError(t, s.Push(f3, 2*mult, cb3)) // 2 - 6\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t2 * mult: f3[:mult],\n\t\t\t3 * mult: f1,\n\t\t\t6 * mult: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 2 * mult},\n\t\t\t{Start: 10 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx====---\n\t//   ++++++\n\t// =>\n\t// --+xxx====---\n\tt.Run(\"case 28\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 10\n\t\trequire.NoError(t, s.Push(f3, 2, cb3)) // 2 - 8\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t2: f3[:1],\n\t\t\t3: f1,\n\t\t\t6: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 2},\n\t\t\t{Start: 10, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\tt.Run(\"case 28, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tconst mult = protocol.MinStreamFrameSize\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6*mult, cb2)) // 6 - 10\n\t\trequire.NoError(t, s.Push(f3, 2*mult, cb3)) // 2 - 8\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t2 * mult: f3[:mult],\n\t\t\t3 * mult: f1,\n\t\t\t6 * mult: f2,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 2 * mult},\n\t\t\t{Start: 10 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx===-----\n\t//       +++++\n\t// =>\n\t// ---xxx+++++---\n\tt.Run(\"case 29\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(5)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 9\n\t\trequire.NoError(t, s.Push(f3, 6, cb3)) // 6 - 11\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t6: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 11, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx===----\n\t//      ++++++\n\t// =>\n\t// ---xxx===++--\n\tt.Run(\"case 30\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6, cb2)) // 6 - 9\n\t\trequire.NoError(t, s.Push(f3, 5, cb3)) // 5 - 11\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t6: f2,\n\t\t\t9: f3[4:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 11, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\tt.Run(\"case 30, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 2))\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(6 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 6*mult, cb2)) // 6 - 9\n\t\trequire.NoError(t, s.Push(f3, 5*mult, cb3)) // 5 - 11\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult: f1,\n\t\t\t6 * mult: f2,\n\t\t\t9 * mult: f3[4*mult:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 11 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx---===-----\n\t//     ++++++++++\n\t// =>\n\t// ---xxx++++++++---\n\tt.Run(\"case 31\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(10)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9, cb2)) // 9 - 12\n\t\trequire.NoError(t, s.Push(f3, 5, cb3)) // 5 - 15\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t6: f3[1:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 15, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\tt.Run(\"case 31, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 9))\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(10 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9*mult, cb2)) // 9 - 12\n\t\trequire.NoError(t, s.Push(f3, 5*mult, cb3)) // 5 - 15\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult: f1,\n\t\t\t6 * mult: f3[mult:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 15 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx---===-----\n\t//    +++++++++\n\t// =>\n\t// ---+++++++++---\n\tt.Run(\"case 32\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(9)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9, cb2)) // 9 - 12\n\t\trequire.NoError(t, s.Push(f3, 3, cb3)) // 3 - 12\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f3,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 12, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n\n\t// ---xxx---===###-----\n\t//     ++++++++++++\n\t// =>\n\t// ---xxx++++++++++---\n\tt.Run(\"case 33\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(3)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\tf4 := getData(12)\n\t\tcb4, t4 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9, cb2)) // 9 - 12\n\t\trequire.NoError(t, s.Push(f3, 9, cb3)) // 12 - 15\n\t\trequire.NoError(t, s.Push(f4, 5, cb4)) // 5 - 17\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f1,\n\t\t\t6: f4[1:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 17, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t\trequire.True(t, t4.WasCalled())\n\t})\n\n\tt.Run(\"case 33, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 11))\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(3 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(3 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\tf4 := getData(12 * mult)\n\t\tcb4, t4 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9*mult, cb2)) // 9 - 12\n\t\trequire.NoError(t, s.Push(f3, 9*mult, cb3)) // 12 - 15\n\t\trequire.NoError(t, s.Push(f4, 5*mult, cb4)) // 5 - 17\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult: f1,\n\t\t\t6 * mult: f4[mult:],\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 17 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t\trequire.False(t, t4.WasCalled())\n\t})\n\n\t// ---xxx===---###\n\t//       ++++++\n\t// =>\n\t// ---xxx++++++###\n\tt.Run(\"case 34\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(5)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(5)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(10)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\tf4 := getData(5)\n\t\tcb4, t4 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 5, cb1))  // 5 - 10\n\t\trequire.NoError(t, s.Push(f2, 10, cb2)) // 10 - 15\n\t\trequire.NoError(t, s.Push(f4, 20, cb3)) // 20 - 25\n\t\trequire.NoError(t, s.Push(f3, 10, cb4)) // 10 - 20\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t5:  f1,\n\t\t\t10: f3,\n\t\t\t20: f4,\n\t\t})\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 5},\n\t\t\t{Start: 25, End: protocol.MaxByteCount},\n\t\t})\n\t\trequire.False(t, t1.WasCalled())\n\t\trequire.True(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t\trequire.False(t, t4.WasCalled())\n\t})\n\n\t// ---xxx---####---\n\t//    ++++++++\n\t// =>\n\t// ---++++++####---\n\tt.Run(\"case 35\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tf1 := getData(3)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(8)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9, cb2)) // 9 - 13\n\t\trequire.NoError(t, s.Push(f3, 3, cb3)) // 3 - 11\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3},\n\t\t\t{Start: 13, End: protocol.MaxByteCount},\n\t\t})\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3: f3[:6],\n\t\t\t9: f2,\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.True(t, t3.WasCalled())\n\t})\n\n\tt.Run(\"case 35, for long frames\", func(t *testing.T) {\n\t\ts := newFrameSorter()\n\t\tmult := protocol.ByteCount(math.Ceil(float64(protocol.MinStreamFrameSize) / 6))\n\t\tf1 := getData(3 * mult)\n\t\tcb1, t1 := getFrameSorterTestCallback(t)\n\t\tf2 := getData(4 * mult)\n\t\tcb2, t2 := getFrameSorterTestCallback(t)\n\t\tf3 := getData(8 * mult)\n\t\tcb3, t3 := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f1, 3*mult, cb1)) // 3 - 6\n\t\trequire.NoError(t, s.Push(f2, 9*mult, cb2)) // 9 - 13\n\t\trequire.NoError(t, s.Push(f3, 3*mult, cb3)) // 3 - 11\n\t\tcheckGaps(t, s, []byteInterval{\n\t\t\t{Start: 0, End: 3 * mult},\n\t\t\t{Start: 13 * mult, End: protocol.MaxByteCount},\n\t\t})\n\t\tcheckQueue(t, s, map[protocol.ByteCount][]byte{\n\t\t\t3 * mult: f3[:6*mult],\n\t\t\t9 * mult: f2,\n\t\t})\n\t\trequire.True(t, t1.WasCalled())\n\t\trequire.False(t, t2.WasCalled())\n\t\trequire.False(t, t3.WasCalled())\n\t})\n}\n\nfunc TestFrameSorterTooManyGaps(t *testing.T) {\n\ts := newFrameSorter()\n\tfor i := 0; i < protocol.MaxStreamFrameSorterGaps; i++ {\n\t\trequire.NoError(t, s.Push([]byte(\"foobar\"), protocol.ByteCount(i*7), nil))\n\t}\n\trequire.Equal(t, protocol.MaxStreamFrameSorterGaps, s.gaps.Len())\n\terr := s.Push([]byte(\"foobar\"), protocol.ByteCount(protocol.MaxStreamFrameSorterGaps*7)+100, nil)\n\trequire.EqualError(t, err, \"too many gaps in received data\")\n}\n\nfunc TestFrameSorterRandomized(t *testing.T) {\n\tt.Run(\"short\", func(t *testing.T) {\n\t\ttestFrameSorterRandomized(t, 25, false, false)\n\t})\n\tt.Run(\"long\", func(t *testing.T) {\n\t\ttestFrameSorterRandomized(t, 2*protocol.MinStreamFrameSize, false, false)\n\t})\n\tt.Run(\"short, with duplicates\", func(t *testing.T) {\n\t\ttestFrameSorterRandomized(t, 25, true, false)\n\t})\n\tt.Run(\"long, with duplicates\", func(t *testing.T) {\n\t\ttestFrameSorterRandomized(t, 2*protocol.MinStreamFrameSize, true, false)\n\t})\n\tt.Run(\"short, with overlaps\", func(t *testing.T) {\n\t\ttestFrameSorterRandomized(t, 25, false, true)\n\t})\n\tt.Run(\"long, with overlaps\", func(t *testing.T) {\n\t\ttestFrameSorterRandomized(t, 2*protocol.MinStreamFrameSize, false, true)\n\t})\n}\n\nfunc testFrameSorterRandomized(t *testing.T, dataLen protocol.ByteCount, injectDuplicates, injectOverlaps bool) {\n\ttype frame struct {\n\t\toffset protocol.ByteCount\n\t\tdata   []byte\n\t}\n\n\tconst num = 1000\n\n\tdata := make([]byte, num*int(dataLen))\n\trand.Read(data)\n\n\tframes := make([]frame, num)\n\tfor i := 0; i < num; i++ {\n\t\tb := make([]byte, dataLen)\n\t\toffset := i * int(dataLen)\n\t\tcopy(b, data[offset:offset+int(dataLen)])\n\t\tframes[i] = frame{\n\t\t\toffset: protocol.ByteCount(i) * dataLen,\n\t\t\tdata:   b,\n\t\t}\n\t}\n\trand.Shuffle(len(frames), func(i, j int) { frames[i], frames[j] = frames[j], frames[i] })\n\n\ts := newFrameSorter()\n\n\tvar callbacks []callbackTracker\n\tfor _, f := range frames {\n\t\tcb, tr := getFrameSorterTestCallback(t)\n\t\trequire.NoError(t, s.Push(f.data, f.offset, cb))\n\t\tcallbacks = append(callbacks, tr)\n\t}\n\tif injectDuplicates {\n\t\tfor i := 0; i < num/10; i++ {\n\t\t\tcb, tr := getFrameSorterTestCallback(t)\n\t\t\tdf := frames[rand.Intn(len(frames))]\n\t\t\trequire.NoError(t, s.Push(df.data, df.offset, cb))\n\t\t\tcallbacks = append(callbacks, tr)\n\t\t}\n\t}\n\tif injectOverlaps {\n\t\tfinalOffset := num * dataLen\n\t\tfor i := 0; i < num/3; i++ {\n\t\t\tcb, tr := getFrameSorterTestCallback(t)\n\t\t\tstartOffset := protocol.ByteCount(rand.Intn(int(finalOffset)))\n\t\t\tendOffset := startOffset + protocol.ByteCount(rand.Intn(int(finalOffset-startOffset)))\n\t\t\trequire.NoError(t, s.Push(data[startOffset:endOffset], startOffset, cb))\n\t\t\tcallbacks = append(callbacks, tr)\n\t\t}\n\t}\n\trequire.Equal(t, 1, s.gaps.Len())\n\trequire.Equal(t, byteInterval{Start: num * dataLen, End: protocol.MaxByteCount}, s.gaps.Front().Value)\n\n\t// read all data\n\tvar read []byte\n\tfor {\n\t\toffset, b, cb := s.Pop()\n\t\tif b == nil {\n\t\t\tbreak\n\t\t}\n\t\trequire.Equal(t, offset, protocol.ByteCount(len(read)))\n\t\tread = append(read, b...)\n\t\tif cb != nil {\n\t\t\tcb()\n\t\t}\n\t}\n\n\trequire.Equal(t, data, read)\n\trequire.False(t, s.HasMoreData())\n\tfor _, cb := range callbacks {\n\t\trequire.True(t, cb.WasCalled())\n\t}\n}\n"
        },
        {
          "name": "framer.go",
          "type": "blob",
          "size": 8.8701171875,
          "content": "package quic\n\nimport (\n\t\"slices\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils/ringbuffer\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/quicvarint\"\n)\n\nconst (\n\tmaxPathResponses = 256\n\tmaxControlFrames = 16 << 10\n)\n\n// This is the largest possible size of a stream-related control frame\n// (which is the RESET_STREAM frame).\nconst maxStreamControlFrameSize = 25\n\ntype streamControlFrameGetter interface {\n\tgetControlFrame(time.Time) (_ ackhandler.Frame, ok, hasMore bool)\n}\n\ntype framer struct {\n\tmutex sync.Mutex\n\n\tactiveStreams            map[protocol.StreamID]sendStreamI\n\tstreamQueue              ringbuffer.RingBuffer[protocol.StreamID]\n\tstreamsWithControlFrames map[protocol.StreamID]streamControlFrameGetter\n\n\tcontrolFrameMutex          sync.Mutex\n\tcontrolFrames              []wire.Frame\n\tpathResponses              []*wire.PathResponseFrame\n\tconnFlowController         flowcontrol.ConnectionFlowController\n\tqueuedTooManyControlFrames bool\n}\n\nfunc newFramer(connFlowController flowcontrol.ConnectionFlowController) *framer {\n\treturn &framer{\n\t\tactiveStreams:            make(map[protocol.StreamID]sendStreamI),\n\t\tstreamsWithControlFrames: make(map[protocol.StreamID]streamControlFrameGetter),\n\t\tconnFlowController:       connFlowController,\n\t}\n}\n\nfunc (f *framer) HasData() bool {\n\tf.mutex.Lock()\n\thasData := !f.streamQueue.Empty()\n\tf.mutex.Unlock()\n\tif hasData {\n\t\treturn true\n\t}\n\tf.controlFrameMutex.Lock()\n\tdefer f.controlFrameMutex.Unlock()\n\treturn len(f.streamsWithControlFrames) > 0 || len(f.controlFrames) > 0 || len(f.pathResponses) > 0\n}\n\nfunc (f *framer) QueueControlFrame(frame wire.Frame) {\n\tf.controlFrameMutex.Lock()\n\tdefer f.controlFrameMutex.Unlock()\n\n\tif pr, ok := frame.(*wire.PathResponseFrame); ok {\n\t\t// Only queue up to maxPathResponses PATH_RESPONSE frames.\n\t\t// This limit should be high enough to never be hit in practice,\n\t\t// unless the peer is doing something malicious.\n\t\tif len(f.pathResponses) >= maxPathResponses {\n\t\t\treturn\n\t\t}\n\t\tf.pathResponses = append(f.pathResponses, pr)\n\t\treturn\n\t}\n\t// This is a hack.\n\tif len(f.controlFrames) >= maxControlFrames {\n\t\tf.queuedTooManyControlFrames = true\n\t\treturn\n\t}\n\tf.controlFrames = append(f.controlFrames, frame)\n}\n\nfunc (f *framer) Append(\n\tframes []ackhandler.Frame,\n\tstreamFrames []ackhandler.StreamFrame,\n\tmaxLen protocol.ByteCount,\n\tnow time.Time,\n\tv protocol.Version,\n) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount) {\n\tf.controlFrameMutex.Lock()\n\tframes, controlFrameLen := f.appendControlFrames(frames, maxLen, now, v)\n\tmaxLen -= controlFrameLen\n\n\tvar lastFrame ackhandler.StreamFrame\n\tvar streamFrameLen protocol.ByteCount\n\tf.mutex.Lock()\n\t// pop STREAM frames, until less than 128 bytes are left in the packet\n\tnumActiveStreams := f.streamQueue.Len()\n\tfor i := 0; i < numActiveStreams; i++ {\n\t\tif protocol.MinStreamFrameSize > maxLen {\n\t\t\tbreak\n\t\t}\n\t\tsf, blocked := f.getNextStreamFrame(maxLen, v)\n\t\tif sf.Frame != nil {\n\t\t\tstreamFrames = append(streamFrames, sf)\n\t\t\tmaxLen -= sf.Frame.Length(v)\n\t\t\tlastFrame = sf\n\t\t\tstreamFrameLen += sf.Frame.Length(v)\n\t\t}\n\t\t// If the stream just became blocked on stream flow control, attempt to pack the\n\t\t// STREAM_DATA_BLOCKED into the same packet.\n\t\tif blocked != nil {\n\t\t\tl := blocked.Length(v)\n\t\t\t// In case it doesn't fit, queue it for the next packet.\n\t\t\tif maxLen < l {\n\t\t\t\tf.controlFrames = append(f.controlFrames, blocked)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tframes = append(frames, ackhandler.Frame{Frame: blocked})\n\t\t\tmaxLen -= l\n\t\t\tcontrolFrameLen += l\n\t\t}\n\t}\n\n\t// The only way to become blocked on connection-level flow control is by sending STREAM frames.\n\tif isBlocked, offset := f.connFlowController.IsNewlyBlocked(); isBlocked {\n\t\tblocked := &wire.DataBlockedFrame{MaximumData: offset}\n\t\tl := blocked.Length(v)\n\t\t// In case it doesn't fit, queue it for the next packet.\n\t\tif maxLen >= l {\n\t\t\tframes = append(frames, ackhandler.Frame{Frame: blocked})\n\t\t\tcontrolFrameLen += l\n\t\t} else {\n\t\t\tf.controlFrames = append(f.controlFrames, blocked)\n\t\t}\n\t}\n\n\tf.mutex.Unlock()\n\tf.controlFrameMutex.Unlock()\n\n\tif lastFrame.Frame != nil {\n\t\t// account for the smaller size of the last STREAM frame\n\t\tstreamFrameLen -= lastFrame.Frame.Length(v)\n\t\tlastFrame.Frame.DataLenPresent = false\n\t\tstreamFrameLen += lastFrame.Frame.Length(v)\n\t}\n\n\treturn frames, streamFrames, controlFrameLen + streamFrameLen\n}\n\nfunc (f *framer) appendControlFrames(\n\tframes []ackhandler.Frame,\n\tmaxLen protocol.ByteCount,\n\tnow time.Time,\n\tv protocol.Version,\n) ([]ackhandler.Frame, protocol.ByteCount) {\n\tvar length protocol.ByteCount\n\t// add a PATH_RESPONSE first, but only pack a single PATH_RESPONSE per packet\n\tif len(f.pathResponses) > 0 {\n\t\tframe := f.pathResponses[0]\n\t\tframeLen := frame.Length(v)\n\t\tif frameLen <= maxLen {\n\t\t\tframes = append(frames, ackhandler.Frame{Frame: frame})\n\t\t\tlength += frameLen\n\t\t\tf.pathResponses = f.pathResponses[1:]\n\t\t}\n\t}\n\n\t// add stream-related control frames\n\tfor id, str := range f.streamsWithControlFrames {\n\tstart:\n\t\tremainingLen := maxLen - length\n\t\tif remainingLen <= maxStreamControlFrameSize {\n\t\t\tbreak\n\t\t}\n\t\tfr, ok, hasMore := str.getControlFrame(now)\n\t\tif !hasMore {\n\t\t\tdelete(f.streamsWithControlFrames, id)\n\t\t}\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tframes = append(frames, fr)\n\t\tlength += fr.Frame.Length(v)\n\t\tif hasMore {\n\t\t\t// It is rare that a stream has more than one control frame to queue.\n\t\t\t// We don't want to spawn another loop for just to cover that case.\n\t\t\tgoto start\n\t\t}\n\t}\n\n\tfor len(f.controlFrames) > 0 {\n\t\tframe := f.controlFrames[len(f.controlFrames)-1]\n\t\tframeLen := frame.Length(v)\n\t\tif length+frameLen > maxLen {\n\t\t\tbreak\n\t\t}\n\t\tframes = append(frames, ackhandler.Frame{Frame: frame})\n\t\tlength += frameLen\n\t\tf.controlFrames = f.controlFrames[:len(f.controlFrames)-1]\n\t}\n\n\treturn frames, length\n}\n\n// QueuedTooManyControlFrames says if the control frame queue exceeded its maximum queue length.\n// This is a hack.\n// It is easier to implement than propagating an error return value in QueueControlFrame.\n// The correct solution would be to queue frames with their respective structs.\n// See https://github.com/quic-go/quic-go/issues/4271 for the queueing of stream-related control frames.\nfunc (f *framer) QueuedTooManyControlFrames() bool {\n\treturn f.queuedTooManyControlFrames\n}\n\nfunc (f *framer) AddActiveStream(id protocol.StreamID, str sendStreamI) {\n\tf.mutex.Lock()\n\tif _, ok := f.activeStreams[id]; !ok {\n\t\tf.streamQueue.PushBack(id)\n\t\tf.activeStreams[id] = str\n\t}\n\tf.mutex.Unlock()\n}\n\nfunc (f *framer) AddStreamWithControlFrames(id protocol.StreamID, str streamControlFrameGetter) {\n\tf.controlFrameMutex.Lock()\n\tif _, ok := f.streamsWithControlFrames[id]; !ok {\n\t\tf.streamsWithControlFrames[id] = str\n\t}\n\tf.controlFrameMutex.Unlock()\n}\n\n// RemoveActiveStream is called when a stream completes.\nfunc (f *framer) RemoveActiveStream(id protocol.StreamID) {\n\tf.mutex.Lock()\n\tdelete(f.activeStreams, id)\n\t// We don't delete the stream from the streamQueue,\n\t// since we'd have to iterate over the ringbuffer.\n\t// Instead, we check if the stream is still in activeStreams when appending STREAM frames.\n\tf.mutex.Unlock()\n}\n\nfunc (f *framer) getNextStreamFrame(maxLen protocol.ByteCount, v protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame) {\n\tid := f.streamQueue.PopFront()\n\t// This should never return an error. Better check it anyway.\n\t// The stream will only be in the streamQueue, if it enqueued itself there.\n\tstr, ok := f.activeStreams[id]\n\t// The stream might have been removed after being enqueued.\n\tif !ok {\n\t\treturn ackhandler.StreamFrame{}, nil\n\t}\n\t// For the last STREAM frame, we'll remove the DataLen field later.\n\t// Therefore, we can pretend to have more bytes available when popping\n\t// the STREAM frame (which will always have the DataLen set).\n\tmaxLen += protocol.ByteCount(quicvarint.Len(uint64(maxLen)))\n\tframe, blocked, hasMoreData := str.popStreamFrame(maxLen, v)\n\tif hasMoreData { // put the stream back in the queue (at the end)\n\t\tf.streamQueue.PushBack(id)\n\t} else { // no more data to send. Stream is not active\n\t\tdelete(f.activeStreams, id)\n\t}\n\t// Note that the frame.Frame can be nil:\n\t// * if the stream was canceled after it said it had data\n\t// * the remaining size doesn't allow us to add another STREAM frame\n\treturn frame, blocked\n}\n\nfunc (f *framer) Handle0RTTRejection() {\n\tf.mutex.Lock()\n\tdefer f.mutex.Unlock()\n\tf.controlFrameMutex.Lock()\n\tdefer f.controlFrameMutex.Unlock()\n\n\tf.streamQueue.Clear()\n\tfor id := range f.activeStreams {\n\t\tdelete(f.activeStreams, id)\n\t}\n\tvar j int\n\tfor i, frame := range f.controlFrames {\n\t\tswitch frame.(type) {\n\t\tcase *wire.MaxDataFrame, *wire.MaxStreamDataFrame, *wire.MaxStreamsFrame,\n\t\t\t*wire.DataBlockedFrame, *wire.StreamDataBlockedFrame, *wire.StreamsBlockedFrame:\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tf.controlFrames[j] = f.controlFrames[i]\n\t\t\tj++\n\t\t}\n\t}\n\tf.controlFrames = slices.Delete(f.controlFrames, j, len(f.controlFrames))\n}\n"
        },
        {
          "name": "framer_test.go",
          "type": "blob",
          "size": 20.1416015625,
          "content": "package quic\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nfunc TestFramerControlFrames(t *testing.T) {\n\tpc := &wire.PathChallengeFrame{Data: [8]byte{1, 2, 3, 4, 6, 7, 8}}\n\tmsf := &wire.MaxStreamsFrame{MaxStreamNum: 0x1337}\n\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\trequire.False(t, framer.HasData())\n\tframer.QueueControlFrame(pc)\n\trequire.True(t, framer.HasData())\n\tframer.QueueControlFrame(msf)\n\tframes, streamFrames, length := framer.Append(\n\t\t[]ackhandler.Frame{{Frame: &wire.PingFrame{}}},\n\t\tnil,\n\t\tprotocol.MaxByteCount,\n\t\ttime.Now(),\n\t\tprotocol.Version1,\n\t)\n\trequire.Len(t, frames, 3)\n\trequire.Empty(t, streamFrames)\n\trequire.Contains(t, frames, ackhandler.Frame{Frame: &wire.PingFrame{}})\n\trequire.Contains(t, frames, ackhandler.Frame{Frame: pc})\n\trequire.Contains(t, frames, ackhandler.Frame{Frame: msf})\n\trequire.Equal(t, length, pc.Length(protocol.Version1)+msf.Length(protocol.Version1))\n\trequire.False(t, framer.HasData())\n}\n\nfunc TestFramerControlFrameSizing(t *testing.T) {\n\tconst maxSize = protocol.ByteCount(1000)\n\tbf := &wire.DataBlockedFrame{MaximumData: 0x1337}\n\tbfLen := bf.Length(protocol.Version1)\n\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tnumFrames := int(maxSize / bfLen) // max number of frames that fit into maxSize\n\tfor i := 0; i < numFrames+1; i++ {\n\t\tframer.QueueControlFrame(bf)\n\t}\n\tframes, _, length := framer.Append(nil, nil, maxSize, time.Now(), protocol.Version1)\n\trequire.Len(t, frames, numFrames)\n\trequire.Greater(t, length, maxSize-bfLen)\n\t// now make sure that the last frame is also added\n\tframes, _, length = framer.Append(nil, nil, maxSize, time.Now(), protocol.Version1)\n\trequire.Len(t, frames, 1)\n\trequire.Equal(t, length, bfLen)\n}\n\nfunc TestFramerStreamControlFrames(t *testing.T) {\n\tconst streamID = protocol.StreamID(10)\n\tping := &wire.PingFrame{}\n\tmdf1 := &wire.MaxStreamDataFrame{StreamID: streamID, MaximumStreamData: 1337}\n\tmdf2 := &wire.MaxStreamDataFrame{StreamID: streamID, MaximumStreamData: 1338}\n\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tframer.QueueControlFrame(ping)\n\tstr := NewMockStreamControlFrameGetter(gomock.NewController(t))\n\tframer.AddStreamWithControlFrames(streamID, str)\n\tnow := time.Now()\n\tstr.EXPECT().getControlFrame(now).Return(ackhandler.Frame{Frame: mdf1}, true, true)\n\tstr.EXPECT().getControlFrame(now).Return(ackhandler.Frame{Frame: mdf2}, true, false)\n\tframes, streamFrames, l := framer.Append(nil, nil, protocol.MaxByteCount, now, protocol.Version1)\n\trequire.Len(t, frames, 3)\n\trequire.Empty(t, streamFrames)\n\trequire.Equal(t, mdf1, frames[0].Frame)\n\trequire.Equal(t, mdf2, frames[1].Frame)\n\trequire.Equal(t, ping, frames[2].Frame)\n\trequire.Equal(t, ping.Length(protocol.Version1)+mdf1.Length(protocol.Version1)+mdf2.Length(protocol.Version1), l)\n}\n\n// If there are less than 25 bytes left, no more stream-related control frames are enqueued.\n// This avoids dequeueing a frame from the stream that would be too large to fit into the packet.\nfunc TestFramerStreamControlFramesSizing(t *testing.T) {\n\tmdf1 := &wire.MaxStreamDataFrame{MaximumStreamData: 1337}\n\n\tstr := NewMockStreamControlFrameGetter(gomock.NewController(t))\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tframer.AddStreamWithControlFrames(10, str)\n\tstr.EXPECT().getControlFrame(gomock.Any()).Return(ackhandler.Frame{Frame: mdf1}, true, true).AnyTimes()\n\tframes, _, l := framer.Append(nil, nil, 100, time.Now(), protocol.Version1)\n\trequire.Equal(t, protocol.ByteCount(len(frames))*mdf1.Length(protocol.Version1), l)\n\trequire.Greater(t, l, protocol.ByteCount(100-maxStreamControlFrameSize))\n\trequire.LessOrEqual(t, l, protocol.ByteCount(100))\n}\n\nfunc TestFramerStreamDataBlocked(t *testing.T) {\n\tt.Run(\"small STREAM frame\", func(t *testing.T) {\n\t\ttestFramerStreamDataBlocked(t, true)\n\t})\n\n\tt.Run(\"large STREAM frame\", func(t *testing.T) {\n\t\ttestFramerStreamDataBlocked(t, false)\n\t})\n}\n\n// If the stream becomes blocked on stream flow control, we attempt to pack the STREAM_DATA_BLOCKED\n// into the same packet.\n// However, there's the pathological case, where the STREAM frame and the STREAM_DATA_BLOCKED frame\n// don't fit into the same packet. In that case, the STREAM_DATA_BLOCKED frame is queued and sent\n// in the next packet.\nfunc testFramerStreamDataBlocked(t *testing.T, fits bool) {\n\tconst streamID = 5\n\tstr := NewMockSendStreamI(gomock.NewController(t))\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tframer.AddActiveStream(streamID, str)\n\tstr.EXPECT().popStreamFrame(gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(size protocol.ByteCount, v protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\t\t\tdata := []byte(\"foobar\")\n\t\t\tif !fits {\n\t\t\t\t// Leave 3 bytes in the packet.\n\t\t\t\t// This is not enough to fit in the STREAM_DATA_BLOCKED frame.\n\t\t\t\tdata = make([]byte, size-3)\n\t\t\t}\n\t\t\tf := &wire.StreamFrame{StreamID: streamID, DataLenPresent: true, Data: data}\n\t\t\tblocked := &wire.StreamDataBlockedFrame{StreamID: streamID, MaximumStreamData: f.DataLen()}\n\t\t\tif !fits {\n\t\t\t\trequire.Greater(t, blocked.Length(protocol.Version1), protocol.ByteCount(3))\n\t\t\t}\n\t\t\treturn ackhandler.StreamFrame{Frame: f}, blocked, false\n\t\t},\n\t)\n\n\tconst maxSize protocol.ByteCount = 1000\n\tframes, streamFrames, l := framer.Append(nil, nil, maxSize, time.Now(), protocol.Version1)\n\trequire.Len(t, streamFrames, 1)\n\tdataLen := streamFrames[0].Frame.DataLen()\n\tif fits {\n\t\trequire.Len(t, frames, 1)\n\t\trequire.Equal(t, &wire.StreamDataBlockedFrame{StreamID: streamID, MaximumStreamData: dataLen}, frames[0].Frame)\n\t} else {\n\t\trequire.Equal(t, streamFrames[0].Frame.Length(protocol.Version1), l)\n\t\trequire.Empty(t, frames)\n\t\tframes, streamFrames, l2 := framer.Append(nil, nil, maxSize, time.Now(), protocol.Version1)\n\t\trequire.Greater(t, l+l2, maxSize)\n\t\trequire.Empty(t, streamFrames)\n\t\trequire.Len(t, frames, 1)\n\t\trequire.Equal(t, &wire.StreamDataBlockedFrame{StreamID: streamID, MaximumStreamData: dataLen}, frames[0].Frame)\n\t}\n}\n\nfunc TestFramerDataBlocked(t *testing.T) {\n\tt.Run(\"small STREAM frame\", func(t *testing.T) {\n\t\ttestFramerDataBlocked(t, true)\n\t})\n\n\tt.Run(\"large STREAM frame\", func(t *testing.T) {\n\t\ttestFramerDataBlocked(t, false)\n\t})\n}\n\n// If the stream becomes blocked on connection flow control, we attempt to pack the\n// DATA_BLOCKED frame into the same packet.\n// However, there's the pathological case, where the STREAM frame and the DATA_BLOCKED frame\n// don't fit into the same packet. In that case, the DATA_BLOCKED frame is queued and sent\n// in the next packet.\nfunc testFramerDataBlocked(t *testing.T, fits bool) {\n\tconst streamID = 5\n\tconst offset = 100\n\n\tfc := flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil)\n\tfc.UpdateSendWindow(offset)\n\tfc.AddBytesSent(offset)\n\n\tstr := NewMockSendStreamI(gomock.NewController(t))\n\tframer := newFramer(fc)\n\tframer.AddActiveStream(streamID, str)\n\n\tstr.EXPECT().popStreamFrame(gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(size protocol.ByteCount, v protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\t\t\tdata := []byte(\"foobar\")\n\t\t\tif !fits {\n\t\t\t\t// Leave 2 bytes in the packet.\n\t\t\t\t// This is not enough to fit in the DATA_BLOCKED frame.\n\t\t\t\tdata = make([]byte, size-2)\n\t\t\t}\n\t\t\tf := &wire.StreamFrame{StreamID: streamID, DataLenPresent: true, Data: data}\n\t\t\treturn ackhandler.StreamFrame{Frame: f}, nil, false\n\t\t},\n\t)\n\n\tconst maxSize protocol.ByteCount = 1000\n\tframes, streamFrames, l := framer.Append(nil, nil, maxSize, time.Now(), protocol.Version1)\n\trequire.Len(t, streamFrames, 1)\n\tif fits {\n\t\trequire.Len(t, frames, 1)\n\t\trequire.Equal(t, &wire.DataBlockedFrame{MaximumData: offset}, frames[0].Frame)\n\t} else {\n\t\trequire.Equal(t, streamFrames[0].Frame.Length(protocol.Version1), l)\n\t\trequire.Empty(t, frames)\n\t\tframes, streamFrames, l2 := framer.Append(nil, nil, maxSize, time.Now(), protocol.Version1)\n\t\trequire.Greater(t, l+l2, maxSize)\n\t\trequire.Empty(t, streamFrames)\n\t\trequire.Len(t, frames, 1)\n\t\trequire.Equal(t, &wire.DataBlockedFrame{MaximumData: offset}, frames[0].Frame)\n\t}\n}\n\nfunc TestFramerDetectsFrameDoS(t *testing.T) {\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tfor i := 0; i < maxControlFrames-1; i++ {\n\t\tframer.QueueControlFrame(&wire.PingFrame{})\n\t\tframer.QueueControlFrame(&wire.PingFrame{})\n\t\trequire.False(t, framer.QueuedTooManyControlFrames())\n\t\tframes, _, _ := framer.Append([]ackhandler.Frame{}, nil, 1, time.Now(), protocol.Version1)\n\t\trequire.Len(t, frames, 1)\n\t\trequire.Len(t, framer.controlFrames, i+1)\n\t}\n\tframer.QueueControlFrame(&wire.PingFrame{})\n\trequire.False(t, framer.QueuedTooManyControlFrames())\n\trequire.Len(t, framer.controlFrames, maxControlFrames)\n\tframer.QueueControlFrame(&wire.PingFrame{})\n\trequire.True(t, framer.QueuedTooManyControlFrames())\n\trequire.Len(t, framer.controlFrames, maxControlFrames)\n}\n\nfunc TestFramerDetectsFramePathResponseDoS(t *testing.T) {\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tvar pathResponses []*wire.PathResponseFrame\n\tfor i := 0; i < 2*maxPathResponses; i++ {\n\t\tvar f wire.PathResponseFrame\n\t\trand.Read(f.Data[:])\n\t\tpathResponses = append(pathResponses, &f)\n\t\tframer.QueueControlFrame(&f)\n\t}\n\tfor i := 0; i < maxPathResponses; i++ {\n\t\trequire.True(t, framer.HasData())\n\t\tframes, _, length := framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\t\trequire.Len(t, frames, 1)\n\t\trequire.Equal(t, pathResponses[i], frames[0].Frame)\n\t\trequire.Equal(t, pathResponses[i].Length(protocol.Version1), length)\n\t}\n\trequire.False(t, framer.HasData())\n\tframes, _, length := framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Empty(t, frames)\n\trequire.Zero(t, length)\n}\n\nfunc TestFramerPacksSinglePathResponsePerPacket(t *testing.T) {\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tf1 := &wire.PathResponseFrame{Data: [8]byte{1, 2, 3, 4, 5, 6, 7, 8}}\n\tf2 := &wire.PathResponseFrame{Data: [8]byte{2, 3, 4, 5, 6, 7, 8, 9}}\n\tcf1 := &wire.DataBlockedFrame{MaximumData: 1337}\n\tcf2 := &wire.HandshakeDoneFrame{}\n\tframer.QueueControlFrame(f1)\n\tframer.QueueControlFrame(f2)\n\tframer.QueueControlFrame(cf1)\n\tframer.QueueControlFrame(cf2)\n\t// the first packet should contain a single PATH_RESPONSE frame, but all the other control frames\n\tframes, _, _ := framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Len(t, frames, 3)\n\trequire.Equal(t, f1, frames[0].Frame)\n\trequire.Contains(t, []wire.Frame{frames[1].Frame, frames[2].Frame}, cf1)\n\trequire.Contains(t, []wire.Frame{frames[1].Frame, frames[2].Frame}, cf2)\n\t// the second packet should contain the other PATH_RESPONSE frame\n\trequire.True(t, framer.HasData())\n\tframes, _, _ = framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Len(t, frames, 1)\n\trequire.Equal(t, f2, frames[0].Frame)\n\trequire.False(t, framer.HasData())\n}\n\nfunc TestFramerAppendStreamFrames(t *testing.T) {\n\tconst (\n\t\tstr1ID = protocol.StreamID(42)\n\t\tstr2ID = protocol.StreamID(43)\n\t)\n\tf1 := &wire.StreamFrame{StreamID: str1ID, Data: []byte(\"foo\"), DataLenPresent: true}\n\tf2 := &wire.StreamFrame{StreamID: str2ID, Data: []byte(\"bar\"), DataLenPresent: true}\n\ttotalLen := f1.Length(protocol.Version1) + f2.Length(protocol.Version1)\n\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\trequire.False(t, framer.HasData())\n\t// no frames added yet\n\tcontrolFrames, fs, length := framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Empty(t, controlFrames)\n\trequire.Empty(t, fs)\n\trequire.Zero(t, length)\n\n\t// add two streams\n\tmockCtrl := gomock.NewController(t)\n\tstr1 := NewMockSendStreamI(mockCtrl)\n\tstr1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f1}, nil, true)\n\tstr2 := NewMockSendStreamI(mockCtrl)\n\tstr2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f2}, nil, false)\n\tframer.AddActiveStream(str1ID, str1)\n\tframer.AddActiveStream(str1ID, str1) // duplicate calls are ok (they're no-ops)\n\tframer.AddActiveStream(str2ID, str2)\n\trequire.True(t, framer.HasData())\n\n\t// Even though the first stream claimed to have more data,\n\t// we only dequeue a single STREAM frame per call of AppendStreamFrames.\n\tf0 := ackhandler.StreamFrame{Frame: &wire.StreamFrame{StreamID: 9999}}\n\tcontrolFrames, fs, length = framer.Append([]ackhandler.Frame{}, []ackhandler.StreamFrame{f0}, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Empty(t, controlFrames)\n\trequire.Len(t, fs, 3)\n\trequire.Equal(t, f0, fs[0])\n\trequire.Equal(t, str1ID, fs[1].Frame.StreamID)\n\trequire.Equal(t, []byte(\"foo\"), fs[1].Frame.Data)\n\t// since two STREAM frames are sent, the DataLenPresent flag is set on the first frame\n\trequire.True(t, fs[1].Frame.DataLenPresent)\n\trequire.Equal(t, str2ID, fs[2].Frame.StreamID)\n\trequire.Equal(t, []byte(\"bar\"), fs[2].Frame.Data)\n\t// the last frame doesn't have the DataLenPresent flag set\n\trequire.False(t, fs[2].Frame.DataLenPresent)\n\trequire.Equal(t, fs[1].Frame.Length(protocol.Version1)+fs[2].Frame.Length(protocol.Version1), length)\n\trequire.Less(t, length, totalLen) // unsetting DataLenPresent on the last frame reduces the length\n\trequire.True(t, framer.HasData()) // the stream claimed to have more data...\n\n\t// ... but it actually doesn't\n\tstr1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{}, nil, false)\n\t_, fs, length = framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Empty(t, fs)\n\trequire.Zero(t, length)\n\trequire.False(t, framer.HasData())\n}\n\nfunc TestFramerRemoveActiveStream(t *testing.T) {\n\tconst id = protocol.StreamID(42)\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\trequire.False(t, framer.HasData())\n\tframer.AddActiveStream(id, NewMockSendStreamI(gomock.NewController(t)))\n\trequire.True(t, framer.HasData())\n\tframer.RemoveActiveStream(id) // no calls will be issued to the mock stream\n\t// we can't assert on framer.HasData here, since it's not removed from the ringbuffer\n\t_, frames, _ := framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Empty(t, frames)\n\trequire.False(t, framer.HasData())\n}\n\nfunc TestFramerMinStreamFrameSize(t *testing.T) {\n\tconst id = protocol.StreamID(42)\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tstr := NewMockSendStreamI(gomock.NewController(t))\n\tframer.AddActiveStream(id, str)\n\n\trequire.True(t, framer.HasData())\n\t// don't pop frames smaller than the minimum STREAM frame size\n\t_, frames, _ := framer.Append(nil, nil, protocol.MinStreamFrameSize-1, time.Now(), protocol.Version1)\n\trequire.Empty(t, frames)\n\n\t// pop frames of the minimum size\n\tstr.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(\n\t\tfunc(size protocol.ByteCount, v protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\t\t\tf := &wire.StreamFrame{StreamID: id, DataLenPresent: true}\n\t\t\tf.Data = make([]byte, f.MaxDataLen(protocol.MinStreamFrameSize, v))\n\t\t\treturn ackhandler.StreamFrame{Frame: f}, nil, false\n\t\t},\n\t)\n\t_, frames, _ = framer.Append(nil, nil, protocol.MinStreamFrameSize, time.Now(), protocol.Version1)\n\trequire.Len(t, frames, 1)\n\t// unsetting DataLenPresent on the last frame reduced the size slightly beyond the minimum size\n\trequire.Equal(t, protocol.MinStreamFrameSize-2, frames[0].Frame.Length(protocol.Version1))\n}\n\nfunc TestFramerMinStreamFrameSizeMultipleStreamFrames(t *testing.T) {\n\tconst id = protocol.StreamID(42)\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tstr := NewMockSendStreamI(gomock.NewController(t))\n\tframer.AddActiveStream(id, str)\n\n\t// pop a frame such that the remaining size is one byte less than the minimum STREAM frame size\n\tf := &wire.StreamFrame{\n\t\tStreamID:       id,\n\t\tData:           bytes.Repeat([]byte(\"f\"), int(500-protocol.MinStreamFrameSize)),\n\t\tDataLenPresent: true,\n\t}\n\tstr.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).Return(ackhandler.StreamFrame{Frame: f}, nil, false)\n\tframer.AddActiveStream(id, str)\n\t_, fs, length := framer.Append(nil, nil, 500, time.Now(), protocol.Version1)\n\trequire.Len(t, fs, 1)\n\trequire.Equal(t, f, fs[0].Frame)\n\trequire.Equal(t, f.Length(protocol.Version1), length)\n}\n\nfunc TestFramerFillPacketOneStream(t *testing.T) {\n\tconst id = protocol.StreamID(42)\n\tstr := NewMockSendStreamI(gomock.NewController(t))\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\n\tfor i := protocol.MinStreamFrameSize; i < 2000; i++ {\n\t\tstr.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(\n\t\t\tfunc(size protocol.ByteCount, v protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\t\t\t\tf := &wire.StreamFrame{\n\t\t\t\t\tStreamID:       id,\n\t\t\t\t\tDataLenPresent: true,\n\t\t\t\t}\n\t\t\t\tf.Data = make([]byte, f.MaxDataLen(size, v))\n\t\t\t\trequire.Equal(t, size, f.Length(protocol.Version1))\n\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, nil, false\n\t\t\t},\n\t\t)\n\t\tframer.AddActiveStream(id, str)\n\t\t_, frames, _ := framer.Append(nil, nil, i, time.Now(), protocol.Version1)\n\t\trequire.Len(t, frames, 1)\n\t\trequire.False(t, frames[0].Frame.DataLenPresent)\n\t\t// make sure the entire space was filled up\n\t\trequire.Equal(t, i, frames[0].Frame.Length(protocol.Version1))\n\t}\n}\n\nfunc TestFramerFillPacketMultipleStreams(t *testing.T) {\n\tconst (\n\t\tid1 = protocol.StreamID(1000)\n\t\tid2 = protocol.StreamID(11)\n\t)\n\tmockCtrl := gomock.NewController(t)\n\tstream1 := NewMockSendStreamI(mockCtrl)\n\tstream2 := NewMockSendStreamI(mockCtrl)\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\n\tfor i := 2 * protocol.MinStreamFrameSize; i < 2000; i++ {\n\t\tstream1.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(\n\t\t\tfunc(size protocol.ByteCount, v protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\t\t\t\tf := &wire.StreamFrame{StreamID: id1, DataLenPresent: true}\n\t\t\t\tf.Data = make([]byte, f.MaxDataLen(protocol.MinStreamFrameSize, v))\n\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, nil, false\n\t\t\t},\n\t\t)\n\t\tstream2.EXPECT().popStreamFrame(gomock.Any(), protocol.Version1).DoAndReturn(\n\t\t\tfunc(size protocol.ByteCount, v protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\t\t\t\tf := &wire.StreamFrame{StreamID: id2, DataLenPresent: true}\n\t\t\t\tf.Data = make([]byte, f.MaxDataLen(size, v))\n\t\t\t\trequire.Equal(t, size, f.Length(protocol.Version1))\n\t\t\t\treturn ackhandler.StreamFrame{Frame: f}, nil, false\n\t\t\t},\n\t\t)\n\t\tframer.AddActiveStream(id1, stream1)\n\t\tframer.AddActiveStream(id2, stream2)\n\t\t_, frames, _ := framer.Append(nil, nil, i, time.Now(), protocol.Version1)\n\t\trequire.Len(t, frames, 2)\n\t\trequire.True(t, frames[0].Frame.DataLenPresent)\n\t\trequire.False(t, frames[1].Frame.DataLenPresent)\n\t\trequire.Equal(t, i, frames[0].Frame.Length(protocol.Version1)+frames[1].Frame.Length(protocol.Version1))\n\t}\n}\n\nfunc TestFramer0RTTRejection(t *testing.T) {\n\tncid := &wire.NewConnectionIDFrame{\n\t\tSequenceNumber: 10,\n\t\tConnectionID:   protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef}),\n\t}\n\tping := &wire.PingFrame{}\n\tpc := &wire.PathChallengeFrame{Data: [8]byte{1, 2, 3, 4, 6, 7, 8}}\n\n\tframer := newFramer(flowcontrol.NewConnectionFlowController(0, 0, nil, nil, nil))\n\tframer.QueueControlFrame(ncid)\n\tframer.QueueControlFrame(&wire.DataBlockedFrame{MaximumData: 1337})\n\tframer.QueueControlFrame(&wire.StreamDataBlockedFrame{StreamID: 42, MaximumStreamData: 1337})\n\tframer.QueueControlFrame(ping)\n\tframer.QueueControlFrame(&wire.StreamsBlockedFrame{StreamLimit: 13})\n\tframer.QueueControlFrame(pc)\n\n\tframer.AddActiveStream(10, NewMockSendStreamI(gomock.NewController(t)))\n\n\tframer.Handle0RTTRejection()\n\tcontrolFrames, streamFrames, _ := framer.Append(nil, nil, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.Empty(t, streamFrames)\n\trequire.Len(t, controlFrames, 3)\n\trequire.Contains(t, controlFrames, ackhandler.Frame{Frame: pc})\n\trequire.Contains(t, controlFrames, ackhandler.Frame{Frame: ping})\n\trequire.Contains(t, controlFrames, ackhandler.Frame{Frame: ncid})\n}\n"
        },
        {
          "name": "fuzzing",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.2421875,
          "content": "module github.com/quic-go/quic-go\n\ngo 1.22\n\nrequire (\n\tgithub.com/francoispqt/gojay v1.2.13\n\tgithub.com/onsi/ginkgo/v2 v2.9.5\n\tgithub.com/onsi/gomega v1.27.6\n\tgithub.com/prometheus/client_golang v1.19.1\n\tgithub.com/quic-go/qpack v0.5.1\n\tgithub.com/stretchr/testify v1.9.0\n\tgo.uber.org/mock v0.5.0\n\tgolang.org/x/crypto v0.26.0\n\tgolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842\n\tgolang.org/x/net v0.28.0\n\tgolang.org/x/sync v0.8.0\n\tgolang.org/x/sys v0.23.0\n\tgolang.org/x/time v0.5.0\n\tgolang.org/x/tools v0.22.0\n)\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.2.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/go-logr/logr v1.2.4 // indirect\n\tgithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 // indirect\n\tgithub.com/google/go-cmp v0.6.0 // indirect\n\tgithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_model v0.5.0 // indirect\n\tgithub.com/prometheus/common v0.48.0 // indirect\n\tgithub.com/prometheus/procfs v0.12.0 // indirect\n\tgolang.org/x/mod v0.18.0 // indirect\n\tgolang.org/x/text v0.17.0 // indirect\n\tgoogle.golang.org/protobuf v1.33.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 22.79296875,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.31.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.37.0/go.mod h1:TS1dMSSfndXH133OKGwekG838Om/cQT0BUHV3HcBgoo=\ndmitri.shuralyov.com/app/changes v0.0.0-20180602232624-0a106ad413e3/go.mod h1:Yl+fi1br7+Rr3LqpNJf1/uxUdtRUV+Tnj0o93V2B9MU=\ndmitri.shuralyov.com/html/belt v0.0.0-20180602232347-f7d459c86be0/go.mod h1:JLBrvjyP0v+ecvNYvCpyZgu5/xkfAUhi6wJj28eUfSU=\ndmitri.shuralyov.com/service/change v0.0.0-20181023043359-a85b471d5412/go.mod h1:a1inKt/atXimZ4Mv927x+r7UpyzRUf4emIoiiSC2TN4=\ndmitri.shuralyov.com/state v0.0.0-20180228185332-28bcc343414c/go.mod h1:0PRwlb0D6DFvNNtx+9ybjezNCa8XF0xaYcETyp6rHWU=\ngit.apache.org/thrift.git v0.0.0-20180902110319-2566ecd5d999/go.mod h1:fPE2ZNJGynbRyZ4dJvy6G277gSllfV2HJqblrnkyeyg=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/anmitsu/go-shlex v0.0.0-20161002113705-648efa622239/go.mod h1:2FmKhYUyUczH0OGQWaF5ceTx0UBShxjsH6f8oGKYe2c=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bradfitz/go-smtpd v0.0.0-20170404230938-deb6d6237625/go.mod h1:HYsPBTaaSFSlLx/70C2HPIMNZpVV8+vt/A+FMnYP11g=\ngithub.com/buger/jsonparser v0.0.0-20181115193947-bf1c66bbce23/go.mod h1:bbYlZJ7hK1yFx9hf58LP0zeX7UjIGs20ufpu3evjr+s=\ngithub.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=\ngithub.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/coreos/go-systemd v0.0.0-20181012123002-c6f51f82210d/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/flynn/go-shlex v0.0.0-20150515145356-3f9db97f8568/go.mod h1:xEzjJPgXI435gkrCt3MPfRiAkVrwSbHsst4LCFVfpJc=\ngithub.com/francoispqt/gojay v1.2.13 h1:d2m3sFjloqoIUQU3TsHBgj6qg/BVGlTBeHDUmyJnXKk=\ngithub.com/francoispqt/gojay v1.2.13/go.mod h1:ehT5mTG4ua4581f1++1WLG0vPdaA9HaiDsoyrBGkyDY=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/gliderlabs/ssh v0.1.1/go.mod h1:U7qILu1NlMHj9FlMhZLlkCdDnU1DBEAqr0aevW3Awn0=\ngithub.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=\ngithub.com/go-logr/logr v1.2.4 h1:g01GSCwiDw2xSZfjJ2/T9M+S6pFdcNtFYsp+Y43HYDQ=\ngithub.com/go-logr/logr v1.2.4/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572 h1:tfuBGBXKqDEevZMzYi5KSi8KkcZtzBcTgAUUtapy0OI=\ngithub.com/go-task/slim-sprig v0.0.0-20230315185526-52ccab3ef572/go.mod h1:9Pwr4B2jHnOSGXyyzV8ROjYa2ojvAY6HCGYYfMoC3Ls=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:tluoj9z5200jBnyusfRPU2LqT6J+DAorxEvtC7LHB+E=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/go-github v17.0.0+incompatible/go.mod h1:zLgOLi98H3fifZn+44m+umXrS52loVEgC2AApnigrVQ=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38 h1:yAJXTCF9TqKcTiHJAE8dj7HMvPfh66eeA2JYW7eFpSE=\ngithub.com/google/pprof v0.0.0-20210407192527-94a9f03dee38/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/googleapis/gax-go v2.0.0+incompatible/go.mod h1:SFVmujtThgffbyetf+mdk2eWhX2bMyUtNHzFKcPA9HY=\ngithub.com/googleapis/gax-go/v2 v2.0.3/go.mod h1:LLvjysVCY1JZeum8Z6l8qUty8fiNwE08qbEPm1M08qg=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gregjones/httpcache v0.0.0-20180305231024-9cad4c3443a7/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/grpc-ecosystem/grpc-gateway v1.5.0/go.mod h1:RSKVYQBd5MCa4OVpNdGskqpgL2+G+NZTnrVHpWWfpdw=\ngithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/jellevandenhooff/dkim v0.0.0-20150330215556-f50fe3d243e1/go.mod h1:E0B/fFc00Y+Rasa88328GlI/XbtyysCtTHZS8h7IrBU=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/pty v1.1.3/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/lunixbochs/vtclean v1.0.0/go.mod h1:pHhQNgMf3btfWnGBVipUOjRYhoOsdGqdm/+2c2E2WMI=\ngithub.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/microcosm-cc/bluemonday v1.0.1/go.mod h1:hsXNsILzKxV+sX77C5b8FSuKF00vh2OMYv+xgHpAMF4=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/neelance/astrewrite v0.0.0-20160511093645-99348263ae86/go.mod h1:kHJEU3ofeGjhHklVoIGuVj85JJwZ6kWPaJwCIxgnFmo=\ngithub.com/neelance/sourcemap v0.0.0-20151028013722-8c68805598ab/go.mod h1:Qr6/a/Q4r9LP1IltGz7tA7iOK1WonHEYhu1HRBA7ZiM=\ngithub.com/onsi/ginkgo/v2 v2.9.5 h1:+6Hr4uxzP4XIUyAkg61dWBw8lb/gc4/X5luuxN/EC+Q=\ngithub.com/onsi/ginkgo/v2 v2.9.5/go.mod h1:tvAoo1QUJwNEU2ITftXTpR7R1RbCzoZUOs3RonqW57k=\ngithub.com/onsi/gomega v1.27.6 h1:ENqfyGeS5AX/rlXDd/ETokDz93u0YufY1Pgxuy/PvWE=\ngithub.com/onsi/gomega v1.27.6/go.mod h1:PIQNjfQwkP3aQAH7lf7j87O/5FiNr+ZR8+ipb+qQlhg=\ngithub.com/openzipkin/zipkin-go v0.1.1/go.mod h1:NtoC/o8u3JlF1lSlyPNswIbeQH9bJTmOf0Erfk+hxe8=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.8.0/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v1.19.1 h1:wZWJDwK+NameRJuPGDhlnFgx8e8HN3XHQeLaYJFJBOE=\ngithub.com/prometheus/client_golang v1.19.1/go.mod h1:mP78NwGzrVks5S2H6ab8+ZZGJLZUq1hoULYBAYBw1Ho=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.5.0 h1:VQw1hfvPvk3Uv6Qf29VrPF32JB6rtbgI6cYPYQjL0Qw=\ngithub.com/prometheus/client_model v0.5.0/go.mod h1:dTiFglRmd66nLR9Pv9f0mZi7B7fk5Pm3gvsjB5tr+kI=\ngithub.com/prometheus/common v0.0.0-20180801064454-c7de2306084e/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/common v0.48.0 h1:QO8U2CdOzSn1BBsmXJXduaaW+dY/5QLjfB8svtSzKKE=\ngithub.com/prometheus/common v0.48.0/go.mod h1:0/KsvlIEfPQCQ5I2iNSAWKPZziNCvRs5EC6ILDTlAPc=\ngithub.com/prometheus/procfs v0.0.0-20180725123919-05ee40e3a273/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.12.0 h1:jluTpSng7V9hY0O2R9DzzJHYb2xULk9VTR1V1R/k6Bo=\ngithub.com/prometheus/procfs v0.12.0/go.mod h1:pcuDEFsWDnvcgNzo4EEweacyhjeA9Zk3cnaOZAZEfOo=\ngithub.com/quic-go/qpack v0.5.1 h1:giqksBPnT/HDtZ6VhtFKgoLOWmlyo9Ei6u9PqzIMbhI=\ngithub.com/quic-go/qpack v0.5.1/go.mod h1:+PC4XFrEskIVkcLzpEkbLqq1uCoxPhQuvK5rH1ZgaEg=\ngithub.com/rogpeppe/go-internal v1.10.0 h1:TMyTOH3F/DB16zRVcYyreMH6GnZZrwQVAoYjRBZyWFQ=\ngithub.com/rogpeppe/go-internal v1.10.0/go.mod h1:UQnix2H7Ngw/k4C5ijL5+65zddjncjaFoBhdsK/akog=\ngithub.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=\ngithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\ngithub.com/shurcooL/component v0.0.0-20170202220835-f88ec8f54cc4/go.mod h1:XhFIlyj5a1fBNx5aJTbKoIq0mNaPvOagO+HjB3EtxrY=\ngithub.com/shurcooL/events v0.0.0-20181021180414-410e4ca65f48/go.mod h1:5u70Mqkb5O5cxEA8nxTsgrgLehJeAw6Oc4Ab1c/P1HM=\ngithub.com/shurcooL/github_flavored_markdown v0.0.0-20181002035957-2122de532470/go.mod h1:2dOwnU2uBioM+SGy2aZoq1f/Sd1l9OkAeAUvjSyvgU0=\ngithub.com/shurcooL/go v0.0.0-20180423040247-9e1955d9fb6e/go.mod h1:TDJrrUr11Vxrven61rcy3hJMUqaf/CLWYhHNPmT14Lk=\ngithub.com/shurcooL/go-goon v0.0.0-20170922171312-37c2f522c041/go.mod h1:N5mDOmsrJOB+vfqUK+7DmDyjhSLIIBnXo9lvZJj3MWQ=\ngithub.com/shurcooL/gofontwoff v0.0.0-20180329035133-29b52fc0a18d/go.mod h1:05UtEgK5zq39gLST6uB0cf3NEHjETfB4Fgr3Gx5R9Vw=\ngithub.com/shurcooL/gopherjslib v0.0.0-20160914041154-feb6d3990c2c/go.mod h1:8d3azKNyqcHP1GaQE/c6dDgjkgSx2BZ4IoEi4F1reUI=\ngithub.com/shurcooL/highlight_diff v0.0.0-20170515013008-09bb4053de1b/go.mod h1:ZpfEhSmds4ytuByIcDnOLkTHGUI6KNqRNPDLHDk+mUU=\ngithub.com/shurcooL/highlight_go v0.0.0-20181028180052-98c3abbbae20/go.mod h1:UDKB5a1T23gOMUJrI+uSuH0VRDStOiUVSjBTRDVBVag=\ngithub.com/shurcooL/home v0.0.0-20181020052607-80b7ffcb30f9/go.mod h1:+rgNQw2P9ARFAs37qieuu7ohDNQ3gds9msbT2yn85sg=\ngithub.com/shurcooL/htmlg v0.0.0-20170918183704-d01228ac9e50/go.mod h1:zPn1wHpTIePGnXSHpsVPWEktKXHr6+SS6x/IKRb7cpw=\ngithub.com/shurcooL/httperror v0.0.0-20170206035902-86b7830d14cc/go.mod h1:aYMfkZ6DWSJPJ6c4Wwz3QtW22G7mf/PEgaB9k/ik5+Y=\ngithub.com/shurcooL/httpfs v0.0.0-20171119174359-809beceb2371/go.mod h1:ZY1cvUeJuFPAdZ/B6v7RHavJWZn2YPVFQ1OSXhCGOkg=\ngithub.com/shurcooL/httpgzip v0.0.0-20180522190206-b1c53ac65af9/go.mod h1:919LwcH0M7/W4fcZ0/jy0qGght1GIhqyS/EgWGH2j5Q=\ngithub.com/shurcooL/issues v0.0.0-20181008053335-6292fdc1e191/go.mod h1:e2qWDig5bLteJ4fwvDAc2NHzqFEthkqn7aOZAOpj+PQ=\ngithub.com/shurcooL/issuesapp v0.0.0-20180602232740-048589ce2241/go.mod h1:NPpHK2TI7iSaM0buivtFUc9offApnI0Alt/K8hcHy0I=\ngithub.com/shurcooL/notifications v0.0.0-20181007000457-627ab5aea122/go.mod h1:b5uSkrEVM1jQUspwbixRBhaIjIzL2xazXp6kntxYle0=\ngithub.com/shurcooL/octicon v0.0.0-20181028054416-fa4f57f9efb2/go.mod h1:eWdoE5JD4R5UVWDucdOPg1g2fqQRq78IQa9zlOV1vpQ=\ngithub.com/shurcooL/reactions v0.0.0-20181006231557-f2e0b4ca5b82/go.mod h1:TCR1lToEk4d2s07G3XGfz2QrgHXg4RJBvjrOozvoWfk=\ngithub.com/shurcooL/sanitized_anchor_name v0.0.0-20170918181015-86672fcb3f95/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/shurcooL/users v0.0.0-20180125191416-49c67e49c537/go.mod h1:QJTqeLYEDaXHZDBsXlPCDqdhQuJkuw4NOtaxYe3xii4=\ngithub.com/shurcooL/webdavfs v0.0.0-20170829043945-18c3829fa133/go.mod h1:hKmq5kWdCj2z2KEozexVbfEZIWiTjhE0+UjmZgPqehw=\ngithub.com/sourcegraph/annotate v0.0.0-20160123013949-f4cad6c6324d/go.mod h1:UdhH50NIW0fCiwBSr0co2m7BnFLdv4fQTgdqdJTHFeE=\ngithub.com/sourcegraph/syntaxhighlight v0.0.0-20170531221838-bd320f5d308e/go.mod h1:HuIsMU8RRBOtsCgI77wP899iHVBQpCmg4ErYMZB+2IA=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/tarm/serial v0.0.0-20180830185346-98f6abe2eb07/go.mod h1:kDXzergiv9cbyO7IOYJZWg1U88JhDg3PB6klq9Hg2pA=\ngithub.com/viant/assertly v0.4.8/go.mod h1:aGifi++jvCrUaklKEKT0BU95igDNaqkvz+49uaYMPRU=\ngithub.com/viant/toolbox v0.24.0/go.mod h1:OxMCG57V0PXuIP2HNQrtJf2CjqdmbrOx5EkMILuUhzM=\ngo.opencensus.io v0.18.0/go.mod h1:vKdFvxhtzZ9onBp9VKHK8z/sRpBMnKAsufL7wlDrCOA=\ngo.uber.org/mock v0.5.0 h1:KAMbZvZPyBPWgD14IrIQ38QCyjwpvVVV6K/bHl1IwQU=\ngo.uber.org/mock v0.5.0/go.mod h1:ge71pBPLYDk7QIi1LupWxdAykm7KIEFchiOqd6z7qMM=\ngo4.org v0.0.0-20180809161055-417644f6feb5/go.mod h1:MkTOUMDaeVYJUOUsaDXIhWPZYa1yOyC1qaOBpL57BhE=\ngolang.org/x/build v0.0.0-20190111050920-041ab4dc3f9d/go.mod h1:OWs+y06UdEOHN4y+MfF/py+xQ/tYqIWW03b70/CG9Rw=\ngolang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.26.0 h1:RrRspgV4mU+YwB4FYnuBoKsUapNIL5cohGAmSH3azsw=\ngolang.org/x/crypto v0.26.0/go.mod h1:GY7jblb9wI+FOo5y8/S2oY4zWP07AkOJ4+jxCqdqn54=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842 h1:vr/HnozRka3pE4EsMEg1lgkXJkTFJCVUX+S/ZT6wYzM=\ngolang.org/x/exp v0.0.0-20240506185415-9bf2ced13842/go.mod h1:XtvwrStGgqGPLc4cjQfWqZHG1YFdYs6swckp8vpsjnc=\ngolang.org/x/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/mod v0.18.0 h1:5+9lSbEzPSdWkH32vYPBwEpX8KwDbM52Ud9xBUvNlb0=\ngolang.org/x/mod v0.18.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181029044818-c44066c5c816/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181106065722-10aee1819953/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190313220215-9f648a60d977/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.28.0 h1:a9JDOJc5GMUJ0+UDqmLT86WiEy7iWyIhz8gz8E4e5hE=\ngolang.org/x/net v0.28.0/go.mod h1:yqtgsTWOOnlGLG9GFRrK3++bGOUEkNBoHZc8MEDWPNg=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20181017192945-9dcd33a902f4/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20181203162652-d668ce993890/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/perf v0.0.0-20180704124530-6e6d33e29852/go.mod h1:JLpeXjPJfIyPr5TlbXLkXWLhP8nz10XfvxElABhCtcw=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=\ngolang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181029174526-d69651ed3497/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190316082340-a2f829d7f35f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.23.0 h1:YfKFowiIMvtgl1UERQoTPPToxltDeZfbj4H7dVUCwmM=\ngolang.org/x/sys v0.23.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.17.0 h1:XtiM5bkSOt+ewxlOE/aE/AKEHibwj/6gvWMl9Rsh0Qc=\ngolang.org/x/text v0.17.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\ngolang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=\ngolang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180828015842-6cd1fcedba52/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181030000716-a0a13e073c7b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.22.0 h1:gqSGLZqv+AI9lIQzniJ0nZDRG5GBPsSi+DRNHWNz6yA=\ngolang.org/x/tools v0.22.0/go.mod h1:aCwcsjqvq7Yqt6TNyX7QMU2enbQ/Gt0bo6krSeEri+c=\ngoogle.golang.org/api v0.0.0-20180910000450-7ca32eb868bf/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\ngoogle.golang.org/api v0.0.0-20181030000543-1d582fd0359e/go.mod h1:4mhQ8q/RsB7i+udVvVy5NUi08OU8ZlA0gRVgrF7VFY0=\ngoogle.golang.org/api v0.1.0/go.mod h1:UGEZY7KEX120AnNLIHFMKIo4obdJhkp2tPbaPlQx13Y=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.3.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20180831171423-11092d34479b/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20181029155118-b69ba1387ce2/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20181202183823-bd91e49a0898/go.mod h1:7Ep/1NZk928CDR8SjdVbjWNpdIf6nzjE3BTgJDr2Atg=\ngoogle.golang.org/genproto v0.0.0-20190306203927-b5d61aea6440/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/grpc v1.14.0/go.mod h1:yo6s7OP7yaDglbqo1J04qKzAhqBH6lvTonzMVmEdcZw=\ngoogle.golang.org/grpc v1.16.0/go.mod h1:0JHn/cJsOMiMfNA9+DeHDlAU7KAAB5GDlYFpa9MZMio=\ngoogle.golang.org/grpc v1.17.0/go.mod h1:6QZJwpn2B+Zp71q/5VxRsJ6NXXVCE5NRUHRo+f3cWCs=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/protobuf v1.33.0 h1:uNO2rsAINq/JlFpSdYEKIZ0uKD/R9cpdv0T+yoGwGmI=\ngoogle.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngrpc.go4.org v0.0.0-20170609214715-11d0a25b4919/go.mod h1:77eQGdRu53HpSqPFJFmuJdjuHRquDANNeA4x7B8WQ9o=\nhonnef.co/go/tools v0.0.0-20180728063816-88497007e858/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nsourcegraph.com/sourcegraph/go-diff v0.5.0/go.mod h1:kuch7UrkMzY0X+p9CRK03kfuPQ2zzQcaEFbx8wA8rck=\nsourcegraph.com/sqs/pbtypes v0.0.0-20180604144634-d3ebe8f20ae4/go.mod h1:ketZ/q3QxT9HOBeFhu6RdvsftgpsbFHBF5Cas6cDKZ0=\n"
        },
        {
          "name": "http3",
          "type": "tree",
          "content": null
        },
        {
          "name": "integrationtests",
          "type": "tree",
          "content": null
        },
        {
          "name": "interface.go",
          "type": "blob",
          "size": 18.3330078125,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\n// The StreamID is the ID of a QUIC stream.\ntype StreamID = protocol.StreamID\n\n// A Version is a QUIC version number.\ntype Version = protocol.Version\n\nconst (\n\t// Version1 is RFC 9000\n\tVersion1 = protocol.Version1\n\t// Version2 is RFC 9369\n\tVersion2 = protocol.Version2\n)\n\n// A ClientToken is a token received by the client.\n// It can be used to skip address validation on future connection attempts.\ntype ClientToken struct {\n\tdata []byte\n}\n\ntype TokenStore interface {\n\t// Pop searches for a ClientToken associated with the given key.\n\t// Since tokens are not supposed to be reused, it must remove the token from the cache.\n\t// It returns nil when no token is found.\n\tPop(key string) (token *ClientToken)\n\n\t// Put adds a token to the cache with the given key. It might get called\n\t// multiple times in a connection.\n\tPut(key string, token *ClientToken)\n}\n\n// Err0RTTRejected is the returned from:\n// * Open{Uni}Stream{Sync}\n// * Accept{Uni}Stream\n// * Stream.Read and Stream.Write\n// when the server rejects a 0-RTT connection attempt.\nvar Err0RTTRejected = errors.New(\"0-RTT rejected\")\n\n// ConnectionTracingKey can be used to associate a ConnectionTracer with a Connection.\n// It is set on the Connection.Context() context,\n// as well as on the context passed to logging.Tracer.NewConnectionTracer.\n// Deprecated: Applications can set their own tracing key using Transport.ConnContext.\nvar ConnectionTracingKey = connTracingCtxKey{}\n\n// ConnectionTracingID is the type of the context value saved under the ConnectionTracingKey.\n// Deprecated: Applications can set their own tracing key using Transport.ConnContext.\ntype ConnectionTracingID uint64\n\ntype connTracingCtxKey struct{}\n\n// QUICVersionContextKey can be used to find out the QUIC version of a TLS handshake from the\n// context returned by tls.Config.ClientHelloInfo.Context.\nvar QUICVersionContextKey = handshake.QUICVersionContextKey\n\n// Stream is the interface implemented by QUIC streams\n// In addition to the errors listed on the Connection,\n// calls to stream functions can return a StreamError if the stream is canceled.\ntype Stream interface {\n\tReceiveStream\n\tSendStream\n\t// SetDeadline sets the read and write deadlines associated\n\t// with the connection. It is equivalent to calling both\n\t// SetReadDeadline and SetWriteDeadline.\n\tSetDeadline(t time.Time) error\n}\n\n// A ReceiveStream is a unidirectional Receive Stream.\ntype ReceiveStream interface {\n\t// StreamID returns the stream ID.\n\tStreamID() StreamID\n\t// Read reads data from the stream.\n\t// Read can be made to time out and return a net.Error with Timeout() == true\n\t// after a fixed time limit; see SetDeadline and SetReadDeadline.\n\t// If the stream was canceled by the peer, the error is a StreamError and\n\t// Remote == true.\n\t// If the connection was closed due to a timeout, the error satisfies\n\t// the net.Error interface, and Timeout() will be true.\n\tio.Reader\n\t// CancelRead aborts receiving on this stream.\n\t// It will ask the peer to stop transmitting stream data.\n\t// Read will unblock immediately, and future Read calls will fail.\n\t// When called multiple times or after reading the io.EOF it is a no-op.\n\tCancelRead(StreamErrorCode)\n\t// SetReadDeadline sets the deadline for future Read calls and\n\t// any currently-blocked Read call.\n\t// A zero value for t means Read will not time out.\n\tSetReadDeadline(t time.Time) error\n}\n\n// A SendStream is a unidirectional Send Stream.\ntype SendStream interface {\n\t// StreamID returns the stream ID.\n\tStreamID() StreamID\n\t// Write writes data to the stream.\n\t// Write can be made to time out and return a net.Error with Timeout() == true\n\t// after a fixed time limit; see SetDeadline and SetWriteDeadline.\n\t// If the stream was canceled by the peer, the error is a StreamError and\n\t// Remote == true.\n\t// If the connection was closed due to a timeout, the error satisfies\n\t// the net.Error interface, and Timeout() will be true.\n\tio.Writer\n\t// Close closes the write-direction of the stream.\n\t// Future calls to Write are not permitted after calling Close.\n\t// It must not be called concurrently with Write.\n\t// It must not be called after calling CancelWrite.\n\tio.Closer\n\t// CancelWrite aborts sending on this stream.\n\t// Data already written, but not yet delivered to the peer is not guaranteed to be delivered reliably.\n\t// Write will unblock immediately, and future calls to Write will fail.\n\t// When called multiple times it is a no-op.\n\t// When called after Close, it aborts delivery. Note that there is no guarantee if\n\t// the peer will receive the FIN or the reset first.\n\tCancelWrite(StreamErrorCode)\n\t// The Context is canceled as soon as the write-side of the stream is closed.\n\t// This happens when Close() or CancelWrite() is called, or when the peer\n\t// cancels the read-side of their stream.\n\t// The cancellation cause is set to the error that caused the stream to\n\t// close, or `context.Canceled` in case the stream is closed without error.\n\tContext() context.Context\n\t// SetWriteDeadline sets the deadline for future Write calls\n\t// and any currently-blocked Write call.\n\t// Even if write times out, it may return n > 0, indicating that\n\t// some data was successfully written.\n\t// A zero value for t means Write will not time out.\n\tSetWriteDeadline(t time.Time) error\n}\n\n// A Connection is a QUIC connection between two peers.\n// Calls to the connection (and to streams) can return the following types of errors:\n// * ApplicationError: for errors triggered by the application running on top of QUIC\n// * TransportError: for errors triggered by the QUIC transport (in many cases a misbehaving peer)\n// * IdleTimeoutError: when the peer goes away unexpectedly (this is a net.Error timeout error)\n// * HandshakeTimeoutError: when the cryptographic handshake takes too long (this is a net.Error timeout error)\n// * StatelessResetError: when we receive a stateless reset\n// * VersionNegotiationError: returned by the client, when there's no version overlap between the peers\ntype Connection interface {\n\t// AcceptStream returns the next stream opened by the peer, blocking until one is available.\n\t// If the connection was closed due to a timeout, the error satisfies\n\t// the net.Error interface, and Timeout() will be true.\n\tAcceptStream(context.Context) (Stream, error)\n\t// AcceptUniStream returns the next unidirectional stream opened by the peer, blocking until one is available.\n\t// If the connection was closed due to a timeout, the error satisfies\n\t// the net.Error interface, and Timeout() will be true.\n\tAcceptUniStream(context.Context) (ReceiveStream, error)\n\t// OpenStream opens a new bidirectional QUIC stream.\n\t// There is no signaling to the peer about new streams:\n\t// The peer can only accept the stream after data has been sent on the stream,\n\t// or the stream has been reset or closed.\n\t// When reaching the peer's stream limit, it is not possible to open a new stream until the\n\t// peer raises the stream limit. In that case, a StreamLimitReachedError is returned.\n\tOpenStream() (Stream, error)\n\t// OpenStreamSync opens a new bidirectional QUIC stream.\n\t// It blocks until a new stream can be opened.\n\t// There is no signaling to the peer about new streams:\n\t// The peer can only accept the stream after data has been sent on the stream,\n\t// or the stream has been reset or closed.\n\tOpenStreamSync(context.Context) (Stream, error)\n\t// OpenUniStream opens a new outgoing unidirectional QUIC stream.\n\t// There is no signaling to the peer about new streams:\n\t// The peer can only accept the stream after data has been sent on the stream,\n\t// or the stream has been reset or closed.\n\t// When reaching the peer's stream limit, it is not possible to open a new stream until the\n\t// peer raises the stream limit. In that case, a StreamLimitReachedError is returned.\n\tOpenUniStream() (SendStream, error)\n\t// OpenUniStreamSync opens a new outgoing unidirectional QUIC stream.\n\t// It blocks until a new stream can be opened.\n\t// There is no signaling to the peer about new streams:\n\t// The peer can only accept the stream after data has been sent on the stream,\n\t// or the stream has been reset or closed.\n\tOpenUniStreamSync(context.Context) (SendStream, error)\n\t// LocalAddr returns the local address.\n\tLocalAddr() net.Addr\n\t// RemoteAddr returns the address of the peer.\n\tRemoteAddr() net.Addr\n\t// CloseWithError closes the connection with an error.\n\t// The error string will be sent to the peer.\n\tCloseWithError(ApplicationErrorCode, string) error\n\t// Context returns a context that is cancelled when the connection is closed.\n\t// The cancellation cause is set to the error that caused the connection to\n\t// close, or `context.Canceled` in case the listener is closed first.\n\tContext() context.Context\n\t// ConnectionState returns basic details about the QUIC connection.\n\t// Warning: This API should not be considered stable and might change soon.\n\tConnectionState() ConnectionState\n\n\t// SendDatagram sends a message using a QUIC datagram, as specified in RFC 9221.\n\t// There is no delivery guarantee for DATAGRAM frames, they are not retransmitted if lost.\n\t// The payload of the datagram needs to fit into a single QUIC packet.\n\t// In addition, a datagram may be dropped before being sent out if the available packet size suddenly decreases.\n\t// If the payload is too large to be sent at the current time, a DatagramTooLargeError is returned.\n\tSendDatagram(payload []byte) error\n\t// ReceiveDatagram gets a message received in a datagram, as specified in RFC 9221.\n\tReceiveDatagram(context.Context) ([]byte, error)\n}\n\n// An EarlyConnection is a connection that is handshaking.\n// Data sent during the handshake is encrypted using the forward secure keys.\n// When using client certificates, the client's identity is only verified\n// after completion of the handshake.\ntype EarlyConnection interface {\n\tConnection\n\n\t// HandshakeComplete blocks until the handshake completes (or fails).\n\t// For the client, data sent before completion of the handshake is encrypted with 0-RTT keys.\n\t// For the server, data sent before completion of the handshake is encrypted with 1-RTT keys,\n\t// however the client's identity is only verified once the handshake completes.\n\tHandshakeComplete() <-chan struct{}\n\n\tNextConnection(context.Context) (Connection, error)\n}\n\n// StatelessResetKey is a key used to derive stateless reset tokens.\ntype StatelessResetKey [32]byte\n\n// TokenGeneratorKey is a key used to encrypt session resumption tokens.\ntype TokenGeneratorKey = handshake.TokenProtectorKey\n\n// A ConnectionID is a QUIC Connection ID, as defined in RFC 9000.\n// It is not able to handle QUIC Connection IDs longer than 20 bytes,\n// as they are allowed by RFC 8999.\ntype ConnectionID = protocol.ConnectionID\n\n// ConnectionIDFromBytes interprets b as a Connection ID. It panics if b is\n// longer than 20 bytes.\nfunc ConnectionIDFromBytes(b []byte) ConnectionID {\n\treturn protocol.ParseConnectionID(b)\n}\n\n// A ConnectionIDGenerator is an interface that allows clients to implement their own format\n// for the Connection IDs that servers/clients use as SrcConnectionID in QUIC packets.\n//\n// Connection IDs generated by an implementation should always produce IDs of constant size.\ntype ConnectionIDGenerator interface {\n\t// GenerateConnectionID generates a new ConnectionID.\n\t// Generated ConnectionIDs should be unique and observers should not be able to correlate two ConnectionIDs.\n\tGenerateConnectionID() (ConnectionID, error)\n\n\t// ConnectionIDLen tells what is the length of the ConnectionIDs generated by the implementation of\n\t// this interface.\n\t// Effectively, this means that implementations of ConnectionIDGenerator must always return constant-size\n\t// connection IDs. Valid lengths are between 0 and 20 and calls to GenerateConnectionID.\n\t// 0-length ConnectionsIDs can be used when an endpoint (server or client) does not require multiplexing connections\n\t// in the presence of a connection migration environment.\n\tConnectionIDLen() int\n}\n\n// Config contains all configuration data needed for a QUIC server or client.\ntype Config struct {\n\t// GetConfigForClient is called for incoming connections.\n\t// If the error is not nil, the connection attempt is refused.\n\tGetConfigForClient func(info *ClientHelloInfo) (*Config, error)\n\t// The QUIC versions that can be negotiated.\n\t// If not set, it uses all versions available.\n\tVersions []Version\n\t// HandshakeIdleTimeout is the idle timeout before completion of the handshake.\n\t// If we don't receive any packet from the peer within this time, the connection attempt is aborted.\n\t// Additionally, if the handshake doesn't complete in twice this time, the connection attempt is also aborted.\n\t// If this value is zero, the timeout is set to 5 seconds.\n\tHandshakeIdleTimeout time.Duration\n\t// MaxIdleTimeout is the maximum duration that may pass without any incoming network activity.\n\t// The actual value for the idle timeout is the minimum of this value and the peer's.\n\t// This value only applies after the handshake has completed.\n\t// If the timeout is exceeded, the connection is closed.\n\t// If this value is zero, the timeout is set to 30 seconds.\n\tMaxIdleTimeout time.Duration\n\t// The TokenStore stores tokens received from the server.\n\t// Tokens are used to skip address validation on future connection attempts.\n\t// The key used to store tokens is the ServerName from the tls.Config, if set\n\t// otherwise the token is associated with the server's IP address.\n\tTokenStore TokenStore\n\t// InitialStreamReceiveWindow is the initial size of the stream-level flow control window for receiving data.\n\t// If the application is consuming data quickly enough, the flow control auto-tuning algorithm\n\t// will increase the window up to MaxStreamReceiveWindow.\n\t// If this value is zero, it will default to 512 KB.\n\t// Values larger than the maximum varint (quicvarint.Max) will be clipped to that value.\n\tInitialStreamReceiveWindow uint64\n\t// MaxStreamReceiveWindow is the maximum stream-level flow control window for receiving data.\n\t// If this value is zero, it will default to 6 MB.\n\t// Values larger than the maximum varint (quicvarint.Max) will be clipped to that value.\n\tMaxStreamReceiveWindow uint64\n\t// InitialConnectionReceiveWindow is the initial size of the stream-level flow control window for receiving data.\n\t// If the application is consuming data quickly enough, the flow control auto-tuning algorithm\n\t// will increase the window up to MaxConnectionReceiveWindow.\n\t// If this value is zero, it will default to 512 KB.\n\t// Values larger than the maximum varint (quicvarint.Max) will be clipped to that value.\n\tInitialConnectionReceiveWindow uint64\n\t// MaxConnectionReceiveWindow is the connection-level flow control window for receiving data.\n\t// If this value is zero, it will default to 15 MB.\n\t// Values larger than the maximum varint (quicvarint.Max) will be clipped to that value.\n\tMaxConnectionReceiveWindow uint64\n\t// AllowConnectionWindowIncrease is called every time the connection flow controller attempts\n\t// to increase the connection flow control window.\n\t// If set, the caller can prevent an increase of the window. Typically, it would do so to\n\t// limit the memory usage.\n\t// To avoid deadlocks, it is not valid to call other functions on the connection or on streams\n\t// in this callback.\n\tAllowConnectionWindowIncrease func(conn Connection, delta uint64) bool\n\t// MaxIncomingStreams is the maximum number of concurrent bidirectional streams that a peer is allowed to open.\n\t// If not set, it will default to 100.\n\t// If set to a negative value, it doesn't allow any bidirectional streams.\n\t// Values larger than 2^60 will be clipped to that value.\n\tMaxIncomingStreams int64\n\t// MaxIncomingUniStreams is the maximum number of concurrent unidirectional streams that a peer is allowed to open.\n\t// If not set, it will default to 100.\n\t// If set to a negative value, it doesn't allow any unidirectional streams.\n\t// Values larger than 2^60 will be clipped to that value.\n\tMaxIncomingUniStreams int64\n\t// KeepAlivePeriod defines whether this peer will periodically send a packet to keep the connection alive.\n\t// If set to 0, then no keep alive is sent. Otherwise, the keep alive is sent on that period (or at most\n\t// every half of MaxIdleTimeout, whichever is smaller).\n\tKeepAlivePeriod time.Duration\n\t// InitialPacketSize is the initial size of packets sent.\n\t// It is usually not necessary to manually set this value,\n\t// since Path MTU discovery very quickly finds the path's MTU.\n\t// If set too high, the path might not support packets that large, leading to a timeout of the QUIC handshake.\n\t// Values below 1200 are invalid.\n\tInitialPacketSize uint16\n\t// DisablePathMTUDiscovery disables Path MTU Discovery (RFC 8899).\n\t// This allows the sending of QUIC packets that fully utilize the available MTU of the path.\n\t// Path MTU discovery is only available on systems that allow setting of the Don't Fragment (DF) bit.\n\tDisablePathMTUDiscovery bool\n\t// Allow0RTT allows the application to decide if a 0-RTT connection attempt should be accepted.\n\t// Only valid for the server.\n\tAllow0RTT bool\n\t// Enable QUIC datagram support (RFC 9221).\n\tEnableDatagrams bool\n\tTracer          func(context.Context, logging.Perspective, ConnectionID) *logging.ConnectionTracer\n}\n\n// ClientHelloInfo contains information about an incoming connection attempt.\ntype ClientHelloInfo struct {\n\t// RemoteAddr is the remote address on the Initial packet.\n\t// Unless AddrVerified is set, the address is not yet verified, and could be a spoofed IP address.\n\tRemoteAddr net.Addr\n\t// AddrVerified says if the remote address was verified using QUIC's Retry mechanism.\n\t// Note that the Retry mechanism costs one network roundtrip,\n\t// and is not performed unless Transport.MaxUnvalidatedHandshakes is surpassed.\n\tAddrVerified bool\n}\n\n// ConnectionState records basic details about a QUIC connection\ntype ConnectionState struct {\n\t// TLS contains information about the TLS connection state, incl. the tls.ConnectionState.\n\tTLS tls.ConnectionState\n\t// SupportsDatagrams indicates whether the peer advertised support for QUIC datagrams (RFC 9221).\n\t// When true, datagrams can be sent using the Connection's SendDatagram method.\n\t// This is a unilateral declaration by the peer - receiving datagrams is only possible if\n\t// datagram support was enabled locally via Config.EnableDatagrams.\n\tSupportsDatagrams bool\n\t// Used0RTT says if 0-RTT resumption was used.\n\tUsed0RTT bool\n\t// Version is the QUIC version of the QUIC connection.\n\tVersion Version\n\t// GSO says if generic segmentation offload is used\n\tGSO bool\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "interop",
          "type": "tree",
          "content": null
        },
        {
          "name": "logging",
          "type": "tree",
          "content": null
        },
        {
          "name": "metrics",
          "type": "tree",
          "content": null
        },
        {
          "name": "mock_ack_frame_source_test.go",
          "type": "blob",
          "size": 2.6982421875,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: AckFrameSource)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_ack_frame_source_test.go github.com/quic-go/quic-go AckFrameSource\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\twire \"github.com/quic-go/quic-go/internal/wire\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockAckFrameSource is a mock of AckFrameSource interface.\ntype MockAckFrameSource struct {\n\tctrl     *gomock.Controller\n\trecorder *MockAckFrameSourceMockRecorder\n\tisgomock struct{}\n}\n\n// MockAckFrameSourceMockRecorder is the mock recorder for MockAckFrameSource.\ntype MockAckFrameSourceMockRecorder struct {\n\tmock *MockAckFrameSource\n}\n\n// NewMockAckFrameSource creates a new mock instance.\nfunc NewMockAckFrameSource(ctrl *gomock.Controller) *MockAckFrameSource {\n\tmock := &MockAckFrameSource{ctrl: ctrl}\n\tmock.recorder = &MockAckFrameSourceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockAckFrameSource) EXPECT() *MockAckFrameSourceMockRecorder {\n\treturn m.recorder\n}\n\n// GetAckFrame mocks base method.\nfunc (m *MockAckFrameSource) GetAckFrame(encLevel protocol.EncryptionLevel, onlyIfQueued bool) *wire.AckFrame {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAckFrame\", encLevel, onlyIfQueued)\n\tret0, _ := ret[0].(*wire.AckFrame)\n\treturn ret0\n}\n\n// GetAckFrame indicates an expected call of GetAckFrame.\nfunc (mr *MockAckFrameSourceMockRecorder) GetAckFrame(encLevel, onlyIfQueued any) *MockAckFrameSourceGetAckFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAckFrame\", reflect.TypeOf((*MockAckFrameSource)(nil).GetAckFrame), encLevel, onlyIfQueued)\n\treturn &MockAckFrameSourceGetAckFrameCall{Call: call}\n}\n\n// MockAckFrameSourceGetAckFrameCall wrap *gomock.Call\ntype MockAckFrameSourceGetAckFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockAckFrameSourceGetAckFrameCall) Return(arg0 *wire.AckFrame) *MockAckFrameSourceGetAckFrameCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockAckFrameSourceGetAckFrameCall) Do(f func(protocol.EncryptionLevel, bool) *wire.AckFrame) *MockAckFrameSourceGetAckFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockAckFrameSourceGetAckFrameCall) DoAndReturn(f func(protocol.EncryptionLevel, bool) *wire.AckFrame) *MockAckFrameSourceGetAckFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_conn_runner_test.go",
          "type": "blob",
          "size": 9.771484375,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: ConnRunner)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_conn_runner_test.go github.com/quic-go/quic-go ConnRunner\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockConnRunner is a mock of ConnRunner interface.\ntype MockConnRunner struct {\n\tctrl     *gomock.Controller\n\trecorder *MockConnRunnerMockRecorder\n\tisgomock struct{}\n}\n\n// MockConnRunnerMockRecorder is the mock recorder for MockConnRunner.\ntype MockConnRunnerMockRecorder struct {\n\tmock *MockConnRunner\n}\n\n// NewMockConnRunner creates a new mock instance.\nfunc NewMockConnRunner(ctrl *gomock.Controller) *MockConnRunner {\n\tmock := &MockConnRunner{ctrl: ctrl}\n\tmock.recorder = &MockConnRunnerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockConnRunner) EXPECT() *MockConnRunnerMockRecorder {\n\treturn m.recorder\n}\n\n// Add mocks base method.\nfunc (m *MockConnRunner) Add(arg0 protocol.ConnectionID, arg1 packetHandler) bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// Add indicates an expected call of Add.\nfunc (mr *MockConnRunnerMockRecorder) Add(arg0, arg1 any) *MockConnRunnerAddCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockConnRunner)(nil).Add), arg0, arg1)\n\treturn &MockConnRunnerAddCall{Call: call}\n}\n\n// MockConnRunnerAddCall wrap *gomock.Call\ntype MockConnRunnerAddCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockConnRunnerAddCall) Return(arg0 bool) *MockConnRunnerAddCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockConnRunnerAddCall) Do(f func(protocol.ConnectionID, packetHandler) bool) *MockConnRunnerAddCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockConnRunnerAddCall) DoAndReturn(f func(protocol.ConnectionID, packetHandler) bool) *MockConnRunnerAddCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// AddResetToken mocks base method.\nfunc (m *MockConnRunner) AddResetToken(arg0 protocol.StatelessResetToken, arg1 packetHandler) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AddResetToken\", arg0, arg1)\n}\n\n// AddResetToken indicates an expected call of AddResetToken.\nfunc (mr *MockConnRunnerMockRecorder) AddResetToken(arg0, arg1 any) *MockConnRunnerAddResetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddResetToken\", reflect.TypeOf((*MockConnRunner)(nil).AddResetToken), arg0, arg1)\n\treturn &MockConnRunnerAddResetTokenCall{Call: call}\n}\n\n// MockConnRunnerAddResetTokenCall wrap *gomock.Call\ntype MockConnRunnerAddResetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockConnRunnerAddResetTokenCall) Return() *MockConnRunnerAddResetTokenCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockConnRunnerAddResetTokenCall) Do(f func(protocol.StatelessResetToken, packetHandler)) *MockConnRunnerAddResetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockConnRunnerAddResetTokenCall) DoAndReturn(f func(protocol.StatelessResetToken, packetHandler)) *MockConnRunnerAddResetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetStatelessResetToken mocks base method.\nfunc (m *MockConnRunner) GetStatelessResetToken(arg0 protocol.ConnectionID) protocol.StatelessResetToken {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetStatelessResetToken\", arg0)\n\tret0, _ := ret[0].(protocol.StatelessResetToken)\n\treturn ret0\n}\n\n// GetStatelessResetToken indicates an expected call of GetStatelessResetToken.\nfunc (mr *MockConnRunnerMockRecorder) GetStatelessResetToken(arg0 any) *MockConnRunnerGetStatelessResetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetStatelessResetToken\", reflect.TypeOf((*MockConnRunner)(nil).GetStatelessResetToken), arg0)\n\treturn &MockConnRunnerGetStatelessResetTokenCall{Call: call}\n}\n\n// MockConnRunnerGetStatelessResetTokenCall wrap *gomock.Call\ntype MockConnRunnerGetStatelessResetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockConnRunnerGetStatelessResetTokenCall) Return(arg0 protocol.StatelessResetToken) *MockConnRunnerGetStatelessResetTokenCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockConnRunnerGetStatelessResetTokenCall) Do(f func(protocol.ConnectionID) protocol.StatelessResetToken) *MockConnRunnerGetStatelessResetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockConnRunnerGetStatelessResetTokenCall) DoAndReturn(f func(protocol.ConnectionID) protocol.StatelessResetToken) *MockConnRunnerGetStatelessResetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Remove mocks base method.\nfunc (m *MockConnRunner) Remove(arg0 protocol.ConnectionID) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Remove\", arg0)\n}\n\n// Remove indicates an expected call of Remove.\nfunc (mr *MockConnRunnerMockRecorder) Remove(arg0 any) *MockConnRunnerRemoveCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Remove\", reflect.TypeOf((*MockConnRunner)(nil).Remove), arg0)\n\treturn &MockConnRunnerRemoveCall{Call: call}\n}\n\n// MockConnRunnerRemoveCall wrap *gomock.Call\ntype MockConnRunnerRemoveCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockConnRunnerRemoveCall) Return() *MockConnRunnerRemoveCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockConnRunnerRemoveCall) Do(f func(protocol.ConnectionID)) *MockConnRunnerRemoveCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockConnRunnerRemoveCall) DoAndReturn(f func(protocol.ConnectionID)) *MockConnRunnerRemoveCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// RemoveResetToken mocks base method.\nfunc (m *MockConnRunner) RemoveResetToken(arg0 protocol.StatelessResetToken) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"RemoveResetToken\", arg0)\n}\n\n// RemoveResetToken indicates an expected call of RemoveResetToken.\nfunc (mr *MockConnRunnerMockRecorder) RemoveResetToken(arg0 any) *MockConnRunnerRemoveResetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RemoveResetToken\", reflect.TypeOf((*MockConnRunner)(nil).RemoveResetToken), arg0)\n\treturn &MockConnRunnerRemoveResetTokenCall{Call: call}\n}\n\n// MockConnRunnerRemoveResetTokenCall wrap *gomock.Call\ntype MockConnRunnerRemoveResetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockConnRunnerRemoveResetTokenCall) Return() *MockConnRunnerRemoveResetTokenCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockConnRunnerRemoveResetTokenCall) Do(f func(protocol.StatelessResetToken)) *MockConnRunnerRemoveResetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockConnRunnerRemoveResetTokenCall) DoAndReturn(f func(protocol.StatelessResetToken)) *MockConnRunnerRemoveResetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ReplaceWithClosed mocks base method.\nfunc (m *MockConnRunner) ReplaceWithClosed(arg0 []protocol.ConnectionID, arg1 []byte) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"ReplaceWithClosed\", arg0, arg1)\n}\n\n// ReplaceWithClosed indicates an expected call of ReplaceWithClosed.\nfunc (mr *MockConnRunnerMockRecorder) ReplaceWithClosed(arg0, arg1 any) *MockConnRunnerReplaceWithClosedCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReplaceWithClosed\", reflect.TypeOf((*MockConnRunner)(nil).ReplaceWithClosed), arg0, arg1)\n\treturn &MockConnRunnerReplaceWithClosedCall{Call: call}\n}\n\n// MockConnRunnerReplaceWithClosedCall wrap *gomock.Call\ntype MockConnRunnerReplaceWithClosedCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockConnRunnerReplaceWithClosedCall) Return() *MockConnRunnerReplaceWithClosedCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockConnRunnerReplaceWithClosedCall) Do(f func([]protocol.ConnectionID, []byte)) *MockConnRunnerReplaceWithClosedCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockConnRunnerReplaceWithClosedCall) DoAndReturn(f func([]protocol.ConnectionID, []byte)) *MockConnRunnerReplaceWithClosedCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Retire mocks base method.\nfunc (m *MockConnRunner) Retire(arg0 protocol.ConnectionID) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Retire\", arg0)\n}\n\n// Retire indicates an expected call of Retire.\nfunc (mr *MockConnRunnerMockRecorder) Retire(arg0 any) *MockConnRunnerRetireCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Retire\", reflect.TypeOf((*MockConnRunner)(nil).Retire), arg0)\n\treturn &MockConnRunnerRetireCall{Call: call}\n}\n\n// MockConnRunnerRetireCall wrap *gomock.Call\ntype MockConnRunnerRetireCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockConnRunnerRetireCall) Return() *MockConnRunnerRetireCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockConnRunnerRetireCall) Do(f func(protocol.ConnectionID)) *MockConnRunnerRetireCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockConnRunnerRetireCall) DoAndReturn(f func(protocol.ConnectionID)) *MockConnRunnerRetireCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_frame_source_test.go",
          "type": "blob",
          "size": 4.1435546875,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: FrameSource)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_frame_source_test.go github.com/quic-go/quic-go FrameSource\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tackhandler \"github.com/quic-go/quic-go/internal/ackhandler\"\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockFrameSource is a mock of FrameSource interface.\ntype MockFrameSource struct {\n\tctrl     *gomock.Controller\n\trecorder *MockFrameSourceMockRecorder\n\tisgomock struct{}\n}\n\n// MockFrameSourceMockRecorder is the mock recorder for MockFrameSource.\ntype MockFrameSourceMockRecorder struct {\n\tmock *MockFrameSource\n}\n\n// NewMockFrameSource creates a new mock instance.\nfunc NewMockFrameSource(ctrl *gomock.Controller) *MockFrameSource {\n\tmock := &MockFrameSource{ctrl: ctrl}\n\tmock.recorder = &MockFrameSourceMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockFrameSource) EXPECT() *MockFrameSourceMockRecorder {\n\treturn m.recorder\n}\n\n// Append mocks base method.\nfunc (m *MockFrameSource) Append(arg0 []ackhandler.Frame, arg1 []ackhandler.StreamFrame, arg2 protocol.ByteCount, arg3 time.Time, arg4 protocol.Version) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Append\", arg0, arg1, arg2, arg3, arg4)\n\tret0, _ := ret[0].([]ackhandler.Frame)\n\tret1, _ := ret[1].([]ackhandler.StreamFrame)\n\tret2, _ := ret[2].(protocol.ByteCount)\n\treturn ret0, ret1, ret2\n}\n\n// Append indicates an expected call of Append.\nfunc (mr *MockFrameSourceMockRecorder) Append(arg0, arg1, arg2, arg3, arg4 any) *MockFrameSourceAppendCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Append\", reflect.TypeOf((*MockFrameSource)(nil).Append), arg0, arg1, arg2, arg3, arg4)\n\treturn &MockFrameSourceAppendCall{Call: call}\n}\n\n// MockFrameSourceAppendCall wrap *gomock.Call\ntype MockFrameSourceAppendCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockFrameSourceAppendCall) Return(arg0 []ackhandler.Frame, arg1 []ackhandler.StreamFrame, arg2 protocol.ByteCount) *MockFrameSourceAppendCall {\n\tc.Call = c.Call.Return(arg0, arg1, arg2)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockFrameSourceAppendCall) Do(f func([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount, time.Time, protocol.Version) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount)) *MockFrameSourceAppendCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockFrameSourceAppendCall) DoAndReturn(f func([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount, time.Time, protocol.Version) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount)) *MockFrameSourceAppendCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// HasData mocks base method.\nfunc (m *MockFrameSource) HasData() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"HasData\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// HasData indicates an expected call of HasData.\nfunc (mr *MockFrameSourceMockRecorder) HasData() *MockFrameSourceHasDataCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"HasData\", reflect.TypeOf((*MockFrameSource)(nil).HasData))\n\treturn &MockFrameSourceHasDataCall{Call: call}\n}\n\n// MockFrameSourceHasDataCall wrap *gomock.Call\ntype MockFrameSourceHasDataCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockFrameSourceHasDataCall) Return(arg0 bool) *MockFrameSourceHasDataCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockFrameSourceHasDataCall) Do(f func() bool) *MockFrameSourceHasDataCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockFrameSourceHasDataCall) DoAndReturn(f func() bool) *MockFrameSourceHasDataCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_mtu_discoverer_test.go",
          "type": "blob",
          "size": 6.119140625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: MTUDiscoverer)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_mtu_discoverer_test.go github.com/quic-go/quic-go MTUDiscoverer\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tackhandler \"github.com/quic-go/quic-go/internal/ackhandler\"\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockMTUDiscoverer is a mock of MTUDiscoverer interface.\ntype MockMTUDiscoverer struct {\n\tctrl     *gomock.Controller\n\trecorder *MockMTUDiscovererMockRecorder\n\tisgomock struct{}\n}\n\n// MockMTUDiscovererMockRecorder is the mock recorder for MockMTUDiscoverer.\ntype MockMTUDiscovererMockRecorder struct {\n\tmock *MockMTUDiscoverer\n}\n\n// NewMockMTUDiscoverer creates a new mock instance.\nfunc NewMockMTUDiscoverer(ctrl *gomock.Controller) *MockMTUDiscoverer {\n\tmock := &MockMTUDiscoverer{ctrl: ctrl}\n\tmock.recorder = &MockMTUDiscovererMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockMTUDiscoverer) EXPECT() *MockMTUDiscovererMockRecorder {\n\treturn m.recorder\n}\n\n// CurrentSize mocks base method.\nfunc (m *MockMTUDiscoverer) CurrentSize() protocol.ByteCount {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CurrentSize\")\n\tret0, _ := ret[0].(protocol.ByteCount)\n\treturn ret0\n}\n\n// CurrentSize indicates an expected call of CurrentSize.\nfunc (mr *MockMTUDiscovererMockRecorder) CurrentSize() *MockMTUDiscovererCurrentSizeCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CurrentSize\", reflect.TypeOf((*MockMTUDiscoverer)(nil).CurrentSize))\n\treturn &MockMTUDiscovererCurrentSizeCall{Call: call}\n}\n\n// MockMTUDiscovererCurrentSizeCall wrap *gomock.Call\ntype MockMTUDiscovererCurrentSizeCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockMTUDiscovererCurrentSizeCall) Return(arg0 protocol.ByteCount) *MockMTUDiscovererCurrentSizeCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockMTUDiscovererCurrentSizeCall) Do(f func() protocol.ByteCount) *MockMTUDiscovererCurrentSizeCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockMTUDiscovererCurrentSizeCall) DoAndReturn(f func() protocol.ByteCount) *MockMTUDiscovererCurrentSizeCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetPing mocks base method.\nfunc (m *MockMTUDiscoverer) GetPing() (ackhandler.Frame, protocol.ByteCount) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetPing\")\n\tret0, _ := ret[0].(ackhandler.Frame)\n\tret1, _ := ret[1].(protocol.ByteCount)\n\treturn ret0, ret1\n}\n\n// GetPing indicates an expected call of GetPing.\nfunc (mr *MockMTUDiscovererMockRecorder) GetPing() *MockMTUDiscovererGetPingCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetPing\", reflect.TypeOf((*MockMTUDiscoverer)(nil).GetPing))\n\treturn &MockMTUDiscovererGetPingCall{Call: call}\n}\n\n// MockMTUDiscovererGetPingCall wrap *gomock.Call\ntype MockMTUDiscovererGetPingCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockMTUDiscovererGetPingCall) Return(ping ackhandler.Frame, datagramSize protocol.ByteCount) *MockMTUDiscovererGetPingCall {\n\tc.Call = c.Call.Return(ping, datagramSize)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockMTUDiscovererGetPingCall) Do(f func() (ackhandler.Frame, protocol.ByteCount)) *MockMTUDiscovererGetPingCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockMTUDiscovererGetPingCall) DoAndReturn(f func() (ackhandler.Frame, protocol.ByteCount)) *MockMTUDiscovererGetPingCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ShouldSendProbe mocks base method.\nfunc (m *MockMTUDiscoverer) ShouldSendProbe(now time.Time) bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ShouldSendProbe\", now)\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// ShouldSendProbe indicates an expected call of ShouldSendProbe.\nfunc (mr *MockMTUDiscovererMockRecorder) ShouldSendProbe(now any) *MockMTUDiscovererShouldSendProbeCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ShouldSendProbe\", reflect.TypeOf((*MockMTUDiscoverer)(nil).ShouldSendProbe), now)\n\treturn &MockMTUDiscovererShouldSendProbeCall{Call: call}\n}\n\n// MockMTUDiscovererShouldSendProbeCall wrap *gomock.Call\ntype MockMTUDiscovererShouldSendProbeCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockMTUDiscovererShouldSendProbeCall) Return(arg0 bool) *MockMTUDiscovererShouldSendProbeCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockMTUDiscovererShouldSendProbeCall) Do(f func(time.Time) bool) *MockMTUDiscovererShouldSendProbeCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockMTUDiscovererShouldSendProbeCall) DoAndReturn(f func(time.Time) bool) *MockMTUDiscovererShouldSendProbeCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Start mocks base method.\nfunc (m *MockMTUDiscoverer) Start() {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Start\")\n}\n\n// Start indicates an expected call of Start.\nfunc (mr *MockMTUDiscovererMockRecorder) Start() *MockMTUDiscovererStartCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Start\", reflect.TypeOf((*MockMTUDiscoverer)(nil).Start))\n\treturn &MockMTUDiscovererStartCall{Call: call}\n}\n\n// MockMTUDiscovererStartCall wrap *gomock.Call\ntype MockMTUDiscovererStartCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockMTUDiscovererStartCall) Return() *MockMTUDiscovererStartCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockMTUDiscovererStartCall) Do(f func()) *MockMTUDiscovererStartCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockMTUDiscovererStartCall) DoAndReturn(f func()) *MockMTUDiscovererStartCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_packer_test.go",
          "type": "blob",
          "size": 13.59375,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: Packer)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_packer_test.go github.com/quic-go/quic-go Packer\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tackhandler \"github.com/quic-go/quic-go/internal/ackhandler\"\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tqerr \"github.com/quic-go/quic-go/internal/qerr\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockPacker is a mock of Packer interface.\ntype MockPacker struct {\n\tctrl     *gomock.Controller\n\trecorder *MockPackerMockRecorder\n\tisgomock struct{}\n}\n\n// MockPackerMockRecorder is the mock recorder for MockPacker.\ntype MockPackerMockRecorder struct {\n\tmock *MockPacker\n}\n\n// NewMockPacker creates a new mock instance.\nfunc NewMockPacker(ctrl *gomock.Controller) *MockPacker {\n\tmock := &MockPacker{ctrl: ctrl}\n\tmock.recorder = &MockPackerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockPacker) EXPECT() *MockPackerMockRecorder {\n\treturn m.recorder\n}\n\n// AppendPacket mocks base method.\nfunc (m *MockPacker) AppendPacket(buf *packetBuffer, maxPacketSize protocol.ByteCount, now time.Time, v protocol.Version) (shortHeaderPacket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AppendPacket\", buf, maxPacketSize, now, v)\n\tret0, _ := ret[0].(shortHeaderPacket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// AppendPacket indicates an expected call of AppendPacket.\nfunc (mr *MockPackerMockRecorder) AppendPacket(buf, maxPacketSize, now, v any) *MockPackerAppendPacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AppendPacket\", reflect.TypeOf((*MockPacker)(nil).AppendPacket), buf, maxPacketSize, now, v)\n\treturn &MockPackerAppendPacketCall{Call: call}\n}\n\n// MockPackerAppendPacketCall wrap *gomock.Call\ntype MockPackerAppendPacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerAppendPacketCall) Return(arg0 shortHeaderPacket, arg1 error) *MockPackerAppendPacketCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerAppendPacketCall) Do(f func(*packetBuffer, protocol.ByteCount, time.Time, protocol.Version) (shortHeaderPacket, error)) *MockPackerAppendPacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerAppendPacketCall) DoAndReturn(f func(*packetBuffer, protocol.ByteCount, time.Time, protocol.Version) (shortHeaderPacket, error)) *MockPackerAppendPacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// MaybePackProbePacket mocks base method.\nfunc (m *MockPacker) MaybePackProbePacket(arg0 protocol.EncryptionLevel, arg1 protocol.ByteCount, arg2 time.Time, arg3 protocol.Version) (*coalescedPacket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"MaybePackProbePacket\", arg0, arg1, arg2, arg3)\n\tret0, _ := ret[0].(*coalescedPacket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// MaybePackProbePacket indicates an expected call of MaybePackProbePacket.\nfunc (mr *MockPackerMockRecorder) MaybePackProbePacket(arg0, arg1, arg2, arg3 any) *MockPackerMaybePackProbePacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"MaybePackProbePacket\", reflect.TypeOf((*MockPacker)(nil).MaybePackProbePacket), arg0, arg1, arg2, arg3)\n\treturn &MockPackerMaybePackProbePacketCall{Call: call}\n}\n\n// MockPackerMaybePackProbePacketCall wrap *gomock.Call\ntype MockPackerMaybePackProbePacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerMaybePackProbePacketCall) Return(arg0 *coalescedPacket, arg1 error) *MockPackerMaybePackProbePacketCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerMaybePackProbePacketCall) Do(f func(protocol.EncryptionLevel, protocol.ByteCount, time.Time, protocol.Version) (*coalescedPacket, error)) *MockPackerMaybePackProbePacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerMaybePackProbePacketCall) DoAndReturn(f func(protocol.EncryptionLevel, protocol.ByteCount, time.Time, protocol.Version) (*coalescedPacket, error)) *MockPackerMaybePackProbePacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// PackAckOnlyPacket mocks base method.\nfunc (m *MockPacker) PackAckOnlyPacket(maxPacketSize protocol.ByteCount, now time.Time, v protocol.Version) (shortHeaderPacket, *packetBuffer, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PackAckOnlyPacket\", maxPacketSize, now, v)\n\tret0, _ := ret[0].(shortHeaderPacket)\n\tret1, _ := ret[1].(*packetBuffer)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// PackAckOnlyPacket indicates an expected call of PackAckOnlyPacket.\nfunc (mr *MockPackerMockRecorder) PackAckOnlyPacket(maxPacketSize, now, v any) *MockPackerPackAckOnlyPacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PackAckOnlyPacket\", reflect.TypeOf((*MockPacker)(nil).PackAckOnlyPacket), maxPacketSize, now, v)\n\treturn &MockPackerPackAckOnlyPacketCall{Call: call}\n}\n\n// MockPackerPackAckOnlyPacketCall wrap *gomock.Call\ntype MockPackerPackAckOnlyPacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerPackAckOnlyPacketCall) Return(arg0 shortHeaderPacket, arg1 *packetBuffer, arg2 error) *MockPackerPackAckOnlyPacketCall {\n\tc.Call = c.Call.Return(arg0, arg1, arg2)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerPackAckOnlyPacketCall) Do(f func(protocol.ByteCount, time.Time, protocol.Version) (shortHeaderPacket, *packetBuffer, error)) *MockPackerPackAckOnlyPacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerPackAckOnlyPacketCall) DoAndReturn(f func(protocol.ByteCount, time.Time, protocol.Version) (shortHeaderPacket, *packetBuffer, error)) *MockPackerPackAckOnlyPacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// PackApplicationClose mocks base method.\nfunc (m *MockPacker) PackApplicationClose(arg0 *qerr.ApplicationError, arg1 protocol.ByteCount, arg2 protocol.Version) (*coalescedPacket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PackApplicationClose\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*coalescedPacket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// PackApplicationClose indicates an expected call of PackApplicationClose.\nfunc (mr *MockPackerMockRecorder) PackApplicationClose(arg0, arg1, arg2 any) *MockPackerPackApplicationCloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PackApplicationClose\", reflect.TypeOf((*MockPacker)(nil).PackApplicationClose), arg0, arg1, arg2)\n\treturn &MockPackerPackApplicationCloseCall{Call: call}\n}\n\n// MockPackerPackApplicationCloseCall wrap *gomock.Call\ntype MockPackerPackApplicationCloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerPackApplicationCloseCall) Return(arg0 *coalescedPacket, arg1 error) *MockPackerPackApplicationCloseCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerPackApplicationCloseCall) Do(f func(*qerr.ApplicationError, protocol.ByteCount, protocol.Version) (*coalescedPacket, error)) *MockPackerPackApplicationCloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerPackApplicationCloseCall) DoAndReturn(f func(*qerr.ApplicationError, protocol.ByteCount, protocol.Version) (*coalescedPacket, error)) *MockPackerPackApplicationCloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// PackCoalescedPacket mocks base method.\nfunc (m *MockPacker) PackCoalescedPacket(onlyAck bool, maxPacketSize protocol.ByteCount, now time.Time, v protocol.Version) (*coalescedPacket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PackCoalescedPacket\", onlyAck, maxPacketSize, now, v)\n\tret0, _ := ret[0].(*coalescedPacket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// PackCoalescedPacket indicates an expected call of PackCoalescedPacket.\nfunc (mr *MockPackerMockRecorder) PackCoalescedPacket(onlyAck, maxPacketSize, now, v any) *MockPackerPackCoalescedPacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PackCoalescedPacket\", reflect.TypeOf((*MockPacker)(nil).PackCoalescedPacket), onlyAck, maxPacketSize, now, v)\n\treturn &MockPackerPackCoalescedPacketCall{Call: call}\n}\n\n// MockPackerPackCoalescedPacketCall wrap *gomock.Call\ntype MockPackerPackCoalescedPacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerPackCoalescedPacketCall) Return(arg0 *coalescedPacket, arg1 error) *MockPackerPackCoalescedPacketCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerPackCoalescedPacketCall) Do(f func(bool, protocol.ByteCount, time.Time, protocol.Version) (*coalescedPacket, error)) *MockPackerPackCoalescedPacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerPackCoalescedPacketCall) DoAndReturn(f func(bool, protocol.ByteCount, time.Time, protocol.Version) (*coalescedPacket, error)) *MockPackerPackCoalescedPacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// PackConnectionClose mocks base method.\nfunc (m *MockPacker) PackConnectionClose(arg0 *qerr.TransportError, arg1 protocol.ByteCount, arg2 protocol.Version) (*coalescedPacket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PackConnectionClose\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(*coalescedPacket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// PackConnectionClose indicates an expected call of PackConnectionClose.\nfunc (mr *MockPackerMockRecorder) PackConnectionClose(arg0, arg1, arg2 any) *MockPackerPackConnectionCloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PackConnectionClose\", reflect.TypeOf((*MockPacker)(nil).PackConnectionClose), arg0, arg1, arg2)\n\treturn &MockPackerPackConnectionCloseCall{Call: call}\n}\n\n// MockPackerPackConnectionCloseCall wrap *gomock.Call\ntype MockPackerPackConnectionCloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerPackConnectionCloseCall) Return(arg0 *coalescedPacket, arg1 error) *MockPackerPackConnectionCloseCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerPackConnectionCloseCall) Do(f func(*qerr.TransportError, protocol.ByteCount, protocol.Version) (*coalescedPacket, error)) *MockPackerPackConnectionCloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerPackConnectionCloseCall) DoAndReturn(f func(*qerr.TransportError, protocol.ByteCount, protocol.Version) (*coalescedPacket, error)) *MockPackerPackConnectionCloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// PackMTUProbePacket mocks base method.\nfunc (m *MockPacker) PackMTUProbePacket(ping ackhandler.Frame, size protocol.ByteCount, v protocol.Version) (shortHeaderPacket, *packetBuffer, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"PackMTUProbePacket\", ping, size, v)\n\tret0, _ := ret[0].(shortHeaderPacket)\n\tret1, _ := ret[1].(*packetBuffer)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// PackMTUProbePacket indicates an expected call of PackMTUProbePacket.\nfunc (mr *MockPackerMockRecorder) PackMTUProbePacket(ping, size, v any) *MockPackerPackMTUProbePacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"PackMTUProbePacket\", reflect.TypeOf((*MockPacker)(nil).PackMTUProbePacket), ping, size, v)\n\treturn &MockPackerPackMTUProbePacketCall{Call: call}\n}\n\n// MockPackerPackMTUProbePacketCall wrap *gomock.Call\ntype MockPackerPackMTUProbePacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerPackMTUProbePacketCall) Return(arg0 shortHeaderPacket, arg1 *packetBuffer, arg2 error) *MockPackerPackMTUProbePacketCall {\n\tc.Call = c.Call.Return(arg0, arg1, arg2)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerPackMTUProbePacketCall) Do(f func(ackhandler.Frame, protocol.ByteCount, protocol.Version) (shortHeaderPacket, *packetBuffer, error)) *MockPackerPackMTUProbePacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerPackMTUProbePacketCall) DoAndReturn(f func(ackhandler.Frame, protocol.ByteCount, protocol.Version) (shortHeaderPacket, *packetBuffer, error)) *MockPackerPackMTUProbePacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetToken mocks base method.\nfunc (m *MockPacker) SetToken(arg0 []byte) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"SetToken\", arg0)\n}\n\n// SetToken indicates an expected call of SetToken.\nfunc (mr *MockPackerMockRecorder) SetToken(arg0 any) *MockPackerSetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetToken\", reflect.TypeOf((*MockPacker)(nil).SetToken), arg0)\n\treturn &MockPackerSetTokenCall{Call: call}\n}\n\n// MockPackerSetTokenCall wrap *gomock.Call\ntype MockPackerSetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPackerSetTokenCall) Return() *MockPackerSetTokenCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPackerSetTokenCall) Do(f func([]byte)) *MockPackerSetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPackerSetTokenCall) DoAndReturn(f func([]byte)) *MockPackerSetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_packet_handler_manager_test.go",
          "type": "blob",
          "size": 16.369140625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: PacketHandlerManager)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_packet_handler_manager_test.go github.com/quic-go/quic-go PacketHandlerManager\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockPacketHandlerManager is a mock of PacketHandlerManager interface.\ntype MockPacketHandlerManager struct {\n\tctrl     *gomock.Controller\n\trecorder *MockPacketHandlerManagerMockRecorder\n\tisgomock struct{}\n}\n\n// MockPacketHandlerManagerMockRecorder is the mock recorder for MockPacketHandlerManager.\ntype MockPacketHandlerManagerMockRecorder struct {\n\tmock *MockPacketHandlerManager\n}\n\n// NewMockPacketHandlerManager creates a new mock instance.\nfunc NewMockPacketHandlerManager(ctrl *gomock.Controller) *MockPacketHandlerManager {\n\tmock := &MockPacketHandlerManager{ctrl: ctrl}\n\tmock.recorder = &MockPacketHandlerManagerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockPacketHandlerManager) EXPECT() *MockPacketHandlerManagerMockRecorder {\n\treturn m.recorder\n}\n\n// Add mocks base method.\nfunc (m *MockPacketHandlerManager) Add(arg0 protocol.ConnectionID, arg1 packetHandler) bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Add\", arg0, arg1)\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// Add indicates an expected call of Add.\nfunc (mr *MockPacketHandlerManagerMockRecorder) Add(arg0, arg1 any) *MockPacketHandlerManagerAddCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Add\", reflect.TypeOf((*MockPacketHandlerManager)(nil).Add), arg0, arg1)\n\treturn &MockPacketHandlerManagerAddCall{Call: call}\n}\n\n// MockPacketHandlerManagerAddCall wrap *gomock.Call\ntype MockPacketHandlerManagerAddCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerAddCall) Return(arg0 bool) *MockPacketHandlerManagerAddCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerAddCall) Do(f func(protocol.ConnectionID, packetHandler) bool) *MockPacketHandlerManagerAddCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerAddCall) DoAndReturn(f func(protocol.ConnectionID, packetHandler) bool) *MockPacketHandlerManagerAddCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// AddResetToken mocks base method.\nfunc (m *MockPacketHandlerManager) AddResetToken(arg0 protocol.StatelessResetToken, arg1 packetHandler) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"AddResetToken\", arg0, arg1)\n}\n\n// AddResetToken indicates an expected call of AddResetToken.\nfunc (mr *MockPacketHandlerManagerMockRecorder) AddResetToken(arg0, arg1 any) *MockPacketHandlerManagerAddResetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddResetToken\", reflect.TypeOf((*MockPacketHandlerManager)(nil).AddResetToken), arg0, arg1)\n\treturn &MockPacketHandlerManagerAddResetTokenCall{Call: call}\n}\n\n// MockPacketHandlerManagerAddResetTokenCall wrap *gomock.Call\ntype MockPacketHandlerManagerAddResetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerAddResetTokenCall) Return() *MockPacketHandlerManagerAddResetTokenCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerAddResetTokenCall) Do(f func(protocol.StatelessResetToken, packetHandler)) *MockPacketHandlerManagerAddResetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerAddResetTokenCall) DoAndReturn(f func(protocol.StatelessResetToken, packetHandler)) *MockPacketHandlerManagerAddResetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// AddWithConnID mocks base method.\nfunc (m *MockPacketHandlerManager) AddWithConnID(destConnID, newConnID protocol.ConnectionID, h packetHandler) bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AddWithConnID\", destConnID, newConnID, h)\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// AddWithConnID indicates an expected call of AddWithConnID.\nfunc (mr *MockPacketHandlerManagerMockRecorder) AddWithConnID(destConnID, newConnID, h any) *MockPacketHandlerManagerAddWithConnIDCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AddWithConnID\", reflect.TypeOf((*MockPacketHandlerManager)(nil).AddWithConnID), destConnID, newConnID, h)\n\treturn &MockPacketHandlerManagerAddWithConnIDCall{Call: call}\n}\n\n// MockPacketHandlerManagerAddWithConnIDCall wrap *gomock.Call\ntype MockPacketHandlerManagerAddWithConnIDCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerAddWithConnIDCall) Return(arg0 bool) *MockPacketHandlerManagerAddWithConnIDCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerAddWithConnIDCall) Do(f func(protocol.ConnectionID, protocol.ConnectionID, packetHandler) bool) *MockPacketHandlerManagerAddWithConnIDCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerAddWithConnIDCall) DoAndReturn(f func(protocol.ConnectionID, protocol.ConnectionID, packetHandler) bool) *MockPacketHandlerManagerAddWithConnIDCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Close mocks base method.\nfunc (m *MockPacketHandlerManager) Close(arg0 error) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Close\", arg0)\n}\n\n// Close indicates an expected call of Close.\nfunc (mr *MockPacketHandlerManagerMockRecorder) Close(arg0 any) *MockPacketHandlerManagerCloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Close\", reflect.TypeOf((*MockPacketHandlerManager)(nil).Close), arg0)\n\treturn &MockPacketHandlerManagerCloseCall{Call: call}\n}\n\n// MockPacketHandlerManagerCloseCall wrap *gomock.Call\ntype MockPacketHandlerManagerCloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerCloseCall) Return() *MockPacketHandlerManagerCloseCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerCloseCall) Do(f func(error)) *MockPacketHandlerManagerCloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerCloseCall) DoAndReturn(f func(error)) *MockPacketHandlerManagerCloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Get mocks base method.\nfunc (m *MockPacketHandlerManager) Get(arg0 protocol.ConnectionID) (packetHandler, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", arg0)\n\tret0, _ := ret[0].(packetHandler)\n\tret1, _ := ret[1].(bool)\n\treturn ret0, ret1\n}\n\n// Get indicates an expected call of Get.\nfunc (mr *MockPacketHandlerManagerMockRecorder) Get(arg0 any) *MockPacketHandlerManagerGetCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*MockPacketHandlerManager)(nil).Get), arg0)\n\treturn &MockPacketHandlerManagerGetCall{Call: call}\n}\n\n// MockPacketHandlerManagerGetCall wrap *gomock.Call\ntype MockPacketHandlerManagerGetCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerGetCall) Return(arg0 packetHandler, arg1 bool) *MockPacketHandlerManagerGetCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerGetCall) Do(f func(protocol.ConnectionID) (packetHandler, bool)) *MockPacketHandlerManagerGetCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerGetCall) DoAndReturn(f func(protocol.ConnectionID) (packetHandler, bool)) *MockPacketHandlerManagerGetCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetByResetToken mocks base method.\nfunc (m *MockPacketHandlerManager) GetByResetToken(arg0 protocol.StatelessResetToken) (packetHandler, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetByResetToken\", arg0)\n\tret0, _ := ret[0].(packetHandler)\n\tret1, _ := ret[1].(bool)\n\treturn ret0, ret1\n}\n\n// GetByResetToken indicates an expected call of GetByResetToken.\nfunc (mr *MockPacketHandlerManagerMockRecorder) GetByResetToken(arg0 any) *MockPacketHandlerManagerGetByResetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetByResetToken\", reflect.TypeOf((*MockPacketHandlerManager)(nil).GetByResetToken), arg0)\n\treturn &MockPacketHandlerManagerGetByResetTokenCall{Call: call}\n}\n\n// MockPacketHandlerManagerGetByResetTokenCall wrap *gomock.Call\ntype MockPacketHandlerManagerGetByResetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerGetByResetTokenCall) Return(arg0 packetHandler, arg1 bool) *MockPacketHandlerManagerGetByResetTokenCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerGetByResetTokenCall) Do(f func(protocol.StatelessResetToken) (packetHandler, bool)) *MockPacketHandlerManagerGetByResetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerGetByResetTokenCall) DoAndReturn(f func(protocol.StatelessResetToken) (packetHandler, bool)) *MockPacketHandlerManagerGetByResetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetStatelessResetToken mocks base method.\nfunc (m *MockPacketHandlerManager) GetStatelessResetToken(arg0 protocol.ConnectionID) protocol.StatelessResetToken {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetStatelessResetToken\", arg0)\n\tret0, _ := ret[0].(protocol.StatelessResetToken)\n\treturn ret0\n}\n\n// GetStatelessResetToken indicates an expected call of GetStatelessResetToken.\nfunc (mr *MockPacketHandlerManagerMockRecorder) GetStatelessResetToken(arg0 any) *MockPacketHandlerManagerGetStatelessResetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetStatelessResetToken\", reflect.TypeOf((*MockPacketHandlerManager)(nil).GetStatelessResetToken), arg0)\n\treturn &MockPacketHandlerManagerGetStatelessResetTokenCall{Call: call}\n}\n\n// MockPacketHandlerManagerGetStatelessResetTokenCall wrap *gomock.Call\ntype MockPacketHandlerManagerGetStatelessResetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerGetStatelessResetTokenCall) Return(arg0 protocol.StatelessResetToken) *MockPacketHandlerManagerGetStatelessResetTokenCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerGetStatelessResetTokenCall) Do(f func(protocol.ConnectionID) protocol.StatelessResetToken) *MockPacketHandlerManagerGetStatelessResetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerGetStatelessResetTokenCall) DoAndReturn(f func(protocol.ConnectionID) protocol.StatelessResetToken) *MockPacketHandlerManagerGetStatelessResetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Remove mocks base method.\nfunc (m *MockPacketHandlerManager) Remove(arg0 protocol.ConnectionID) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Remove\", arg0)\n}\n\n// Remove indicates an expected call of Remove.\nfunc (mr *MockPacketHandlerManagerMockRecorder) Remove(arg0 any) *MockPacketHandlerManagerRemoveCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Remove\", reflect.TypeOf((*MockPacketHandlerManager)(nil).Remove), arg0)\n\treturn &MockPacketHandlerManagerRemoveCall{Call: call}\n}\n\n// MockPacketHandlerManagerRemoveCall wrap *gomock.Call\ntype MockPacketHandlerManagerRemoveCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerRemoveCall) Return() *MockPacketHandlerManagerRemoveCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerRemoveCall) Do(f func(protocol.ConnectionID)) *MockPacketHandlerManagerRemoveCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerRemoveCall) DoAndReturn(f func(protocol.ConnectionID)) *MockPacketHandlerManagerRemoveCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// RemoveResetToken mocks base method.\nfunc (m *MockPacketHandlerManager) RemoveResetToken(arg0 protocol.StatelessResetToken) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"RemoveResetToken\", arg0)\n}\n\n// RemoveResetToken indicates an expected call of RemoveResetToken.\nfunc (mr *MockPacketHandlerManagerMockRecorder) RemoveResetToken(arg0 any) *MockPacketHandlerManagerRemoveResetTokenCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RemoveResetToken\", reflect.TypeOf((*MockPacketHandlerManager)(nil).RemoveResetToken), arg0)\n\treturn &MockPacketHandlerManagerRemoveResetTokenCall{Call: call}\n}\n\n// MockPacketHandlerManagerRemoveResetTokenCall wrap *gomock.Call\ntype MockPacketHandlerManagerRemoveResetTokenCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerRemoveResetTokenCall) Return() *MockPacketHandlerManagerRemoveResetTokenCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerRemoveResetTokenCall) Do(f func(protocol.StatelessResetToken)) *MockPacketHandlerManagerRemoveResetTokenCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerRemoveResetTokenCall) DoAndReturn(f func(protocol.StatelessResetToken)) *MockPacketHandlerManagerRemoveResetTokenCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ReplaceWithClosed mocks base method.\nfunc (m *MockPacketHandlerManager) ReplaceWithClosed(arg0 []protocol.ConnectionID, arg1 []byte) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"ReplaceWithClosed\", arg0, arg1)\n}\n\n// ReplaceWithClosed indicates an expected call of ReplaceWithClosed.\nfunc (mr *MockPacketHandlerManagerMockRecorder) ReplaceWithClosed(arg0, arg1 any) *MockPacketHandlerManagerReplaceWithClosedCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReplaceWithClosed\", reflect.TypeOf((*MockPacketHandlerManager)(nil).ReplaceWithClosed), arg0, arg1)\n\treturn &MockPacketHandlerManagerReplaceWithClosedCall{Call: call}\n}\n\n// MockPacketHandlerManagerReplaceWithClosedCall wrap *gomock.Call\ntype MockPacketHandlerManagerReplaceWithClosedCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerReplaceWithClosedCall) Return() *MockPacketHandlerManagerReplaceWithClosedCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerReplaceWithClosedCall) Do(f func([]protocol.ConnectionID, []byte)) *MockPacketHandlerManagerReplaceWithClosedCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerReplaceWithClosedCall) DoAndReturn(f func([]protocol.ConnectionID, []byte)) *MockPacketHandlerManagerReplaceWithClosedCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Retire mocks base method.\nfunc (m *MockPacketHandlerManager) Retire(arg0 protocol.ConnectionID) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Retire\", arg0)\n}\n\n// Retire indicates an expected call of Retire.\nfunc (mr *MockPacketHandlerManagerMockRecorder) Retire(arg0 any) *MockPacketHandlerManagerRetireCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Retire\", reflect.TypeOf((*MockPacketHandlerManager)(nil).Retire), arg0)\n\treturn &MockPacketHandlerManagerRetireCall{Call: call}\n}\n\n// MockPacketHandlerManagerRetireCall wrap *gomock.Call\ntype MockPacketHandlerManagerRetireCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerManagerRetireCall) Return() *MockPacketHandlerManagerRetireCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerManagerRetireCall) Do(f func(protocol.ConnectionID)) *MockPacketHandlerManagerRetireCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerManagerRetireCall) DoAndReturn(f func(protocol.ConnectionID)) *MockPacketHandlerManagerRetireCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_packet_handler_test.go",
          "type": "blob",
          "size": 4.8564453125,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: PacketHandler)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_packet_handler_test.go github.com/quic-go/quic-go PacketHandler\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\n\tqerr \"github.com/quic-go/quic-go/internal/qerr\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockPacketHandler is a mock of PacketHandler interface.\ntype MockPacketHandler struct {\n\tctrl     *gomock.Controller\n\trecorder *MockPacketHandlerMockRecorder\n\tisgomock struct{}\n}\n\n// MockPacketHandlerMockRecorder is the mock recorder for MockPacketHandler.\ntype MockPacketHandlerMockRecorder struct {\n\tmock *MockPacketHandler\n}\n\n// NewMockPacketHandler creates a new mock instance.\nfunc NewMockPacketHandler(ctrl *gomock.Controller) *MockPacketHandler {\n\tmock := &MockPacketHandler{ctrl: ctrl}\n\tmock.recorder = &MockPacketHandlerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockPacketHandler) EXPECT() *MockPacketHandlerMockRecorder {\n\treturn m.recorder\n}\n\n// closeWithTransportError mocks base method.\nfunc (m *MockPacketHandler) closeWithTransportError(arg0 qerr.TransportErrorCode) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"closeWithTransportError\", arg0)\n}\n\n// closeWithTransportError indicates an expected call of closeWithTransportError.\nfunc (mr *MockPacketHandlerMockRecorder) closeWithTransportError(arg0 any) *MockPacketHandlercloseWithTransportErrorCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"closeWithTransportError\", reflect.TypeOf((*MockPacketHandler)(nil).closeWithTransportError), arg0)\n\treturn &MockPacketHandlercloseWithTransportErrorCall{Call: call}\n}\n\n// MockPacketHandlercloseWithTransportErrorCall wrap *gomock.Call\ntype MockPacketHandlercloseWithTransportErrorCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlercloseWithTransportErrorCall) Return() *MockPacketHandlercloseWithTransportErrorCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlercloseWithTransportErrorCall) Do(f func(qerr.TransportErrorCode)) *MockPacketHandlercloseWithTransportErrorCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlercloseWithTransportErrorCall) DoAndReturn(f func(qerr.TransportErrorCode)) *MockPacketHandlercloseWithTransportErrorCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// destroy mocks base method.\nfunc (m *MockPacketHandler) destroy(arg0 error) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"destroy\", arg0)\n}\n\n// destroy indicates an expected call of destroy.\nfunc (mr *MockPacketHandlerMockRecorder) destroy(arg0 any) *MockPacketHandlerdestroyCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"destroy\", reflect.TypeOf((*MockPacketHandler)(nil).destroy), arg0)\n\treturn &MockPacketHandlerdestroyCall{Call: call}\n}\n\n// MockPacketHandlerdestroyCall wrap *gomock.Call\ntype MockPacketHandlerdestroyCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerdestroyCall) Return() *MockPacketHandlerdestroyCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerdestroyCall) Do(f func(error)) *MockPacketHandlerdestroyCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerdestroyCall) DoAndReturn(f func(error)) *MockPacketHandlerdestroyCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handlePacket mocks base method.\nfunc (m *MockPacketHandler) handlePacket(arg0 receivedPacket) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"handlePacket\", arg0)\n}\n\n// handlePacket indicates an expected call of handlePacket.\nfunc (mr *MockPacketHandlerMockRecorder) handlePacket(arg0 any) *MockPacketHandlerhandlePacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handlePacket\", reflect.TypeOf((*MockPacketHandler)(nil).handlePacket), arg0)\n\treturn &MockPacketHandlerhandlePacketCall{Call: call}\n}\n\n// MockPacketHandlerhandlePacketCall wrap *gomock.Call\ntype MockPacketHandlerhandlePacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketHandlerhandlePacketCall) Return() *MockPacketHandlerhandlePacketCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketHandlerhandlePacketCall) Do(f func(receivedPacket)) *MockPacketHandlerhandlePacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketHandlerhandlePacketCall) DoAndReturn(f func(receivedPacket)) *MockPacketHandlerhandlePacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_packetconn_test.go",
          "type": "blob",
          "size": 9.39453125,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: net (interfaces: PacketConn)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -package quic -self_package github.com/quic-go/quic-go -self_package github.com/quic-go/quic-go -destination mock_packetconn_test.go net PacketConn\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\tnet \"net\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockPacketConn is a mock of PacketConn interface.\ntype MockPacketConn struct {\n\tctrl     *gomock.Controller\n\trecorder *MockPacketConnMockRecorder\n\tisgomock struct{}\n}\n\n// MockPacketConnMockRecorder is the mock recorder for MockPacketConn.\ntype MockPacketConnMockRecorder struct {\n\tmock *MockPacketConn\n}\n\n// NewMockPacketConn creates a new mock instance.\nfunc NewMockPacketConn(ctrl *gomock.Controller) *MockPacketConn {\n\tmock := &MockPacketConn{ctrl: ctrl}\n\tmock.recorder = &MockPacketConnMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockPacketConn) EXPECT() *MockPacketConnMockRecorder {\n\treturn m.recorder\n}\n\n// Close mocks base method.\nfunc (m *MockPacketConn) Close() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Close\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Close indicates an expected call of Close.\nfunc (mr *MockPacketConnMockRecorder) Close() *MockPacketConnCloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Close\", reflect.TypeOf((*MockPacketConn)(nil).Close))\n\treturn &MockPacketConnCloseCall{Call: call}\n}\n\n// MockPacketConnCloseCall wrap *gomock.Call\ntype MockPacketConnCloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketConnCloseCall) Return(arg0 error) *MockPacketConnCloseCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketConnCloseCall) Do(f func() error) *MockPacketConnCloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketConnCloseCall) DoAndReturn(f func() error) *MockPacketConnCloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// LocalAddr mocks base method.\nfunc (m *MockPacketConn) LocalAddr() net.Addr {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"LocalAddr\")\n\tret0, _ := ret[0].(net.Addr)\n\treturn ret0\n}\n\n// LocalAddr indicates an expected call of LocalAddr.\nfunc (mr *MockPacketConnMockRecorder) LocalAddr() *MockPacketConnLocalAddrCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LocalAddr\", reflect.TypeOf((*MockPacketConn)(nil).LocalAddr))\n\treturn &MockPacketConnLocalAddrCall{Call: call}\n}\n\n// MockPacketConnLocalAddrCall wrap *gomock.Call\ntype MockPacketConnLocalAddrCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketConnLocalAddrCall) Return(arg0 net.Addr) *MockPacketConnLocalAddrCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketConnLocalAddrCall) Do(f func() net.Addr) *MockPacketConnLocalAddrCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketConnLocalAddrCall) DoAndReturn(f func() net.Addr) *MockPacketConnLocalAddrCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ReadFrom mocks base method.\nfunc (m *MockPacketConn) ReadFrom(p []byte) (int, net.Addr, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ReadFrom\", p)\n\tret0, _ := ret[0].(int)\n\tret1, _ := ret[1].(net.Addr)\n\tret2, _ := ret[2].(error)\n\treturn ret0, ret1, ret2\n}\n\n// ReadFrom indicates an expected call of ReadFrom.\nfunc (mr *MockPacketConnMockRecorder) ReadFrom(p any) *MockPacketConnReadFromCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReadFrom\", reflect.TypeOf((*MockPacketConn)(nil).ReadFrom), p)\n\treturn &MockPacketConnReadFromCall{Call: call}\n}\n\n// MockPacketConnReadFromCall wrap *gomock.Call\ntype MockPacketConnReadFromCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketConnReadFromCall) Return(n int, addr net.Addr, err error) *MockPacketConnReadFromCall {\n\tc.Call = c.Call.Return(n, addr, err)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketConnReadFromCall) Do(f func([]byte) (int, net.Addr, error)) *MockPacketConnReadFromCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketConnReadFromCall) DoAndReturn(f func([]byte) (int, net.Addr, error)) *MockPacketConnReadFromCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetDeadline mocks base method.\nfunc (m *MockPacketConn) SetDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetDeadline indicates an expected call of SetDeadline.\nfunc (mr *MockPacketConnMockRecorder) SetDeadline(t any) *MockPacketConnSetDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetDeadline\", reflect.TypeOf((*MockPacketConn)(nil).SetDeadline), t)\n\treturn &MockPacketConnSetDeadlineCall{Call: call}\n}\n\n// MockPacketConnSetDeadlineCall wrap *gomock.Call\ntype MockPacketConnSetDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketConnSetDeadlineCall) Return(arg0 error) *MockPacketConnSetDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketConnSetDeadlineCall) Do(f func(time.Time) error) *MockPacketConnSetDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketConnSetDeadlineCall) DoAndReturn(f func(time.Time) error) *MockPacketConnSetDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetReadDeadline mocks base method.\nfunc (m *MockPacketConn) SetReadDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetReadDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetReadDeadline indicates an expected call of SetReadDeadline.\nfunc (mr *MockPacketConnMockRecorder) SetReadDeadline(t any) *MockPacketConnSetReadDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetReadDeadline\", reflect.TypeOf((*MockPacketConn)(nil).SetReadDeadline), t)\n\treturn &MockPacketConnSetReadDeadlineCall{Call: call}\n}\n\n// MockPacketConnSetReadDeadlineCall wrap *gomock.Call\ntype MockPacketConnSetReadDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketConnSetReadDeadlineCall) Return(arg0 error) *MockPacketConnSetReadDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketConnSetReadDeadlineCall) Do(f func(time.Time) error) *MockPacketConnSetReadDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketConnSetReadDeadlineCall) DoAndReturn(f func(time.Time) error) *MockPacketConnSetReadDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetWriteDeadline mocks base method.\nfunc (m *MockPacketConn) SetWriteDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetWriteDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetWriteDeadline indicates an expected call of SetWriteDeadline.\nfunc (mr *MockPacketConnMockRecorder) SetWriteDeadline(t any) *MockPacketConnSetWriteDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetWriteDeadline\", reflect.TypeOf((*MockPacketConn)(nil).SetWriteDeadline), t)\n\treturn &MockPacketConnSetWriteDeadlineCall{Call: call}\n}\n\n// MockPacketConnSetWriteDeadlineCall wrap *gomock.Call\ntype MockPacketConnSetWriteDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketConnSetWriteDeadlineCall) Return(arg0 error) *MockPacketConnSetWriteDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketConnSetWriteDeadlineCall) Do(f func(time.Time) error) *MockPacketConnSetWriteDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketConnSetWriteDeadlineCall) DoAndReturn(f func(time.Time) error) *MockPacketConnSetWriteDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// WriteTo mocks base method.\nfunc (m *MockPacketConn) WriteTo(p []byte, addr net.Addr) (int, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"WriteTo\", p, addr)\n\tret0, _ := ret[0].(int)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// WriteTo indicates an expected call of WriteTo.\nfunc (mr *MockPacketConnMockRecorder) WriteTo(p, addr any) *MockPacketConnWriteToCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"WriteTo\", reflect.TypeOf((*MockPacketConn)(nil).WriteTo), p, addr)\n\treturn &MockPacketConnWriteToCall{Call: call}\n}\n\n// MockPacketConnWriteToCall wrap *gomock.Call\ntype MockPacketConnWriteToCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockPacketConnWriteToCall) Return(n int, err error) *MockPacketConnWriteToCall {\n\tc.Call = c.Call.Return(n, err)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockPacketConnWriteToCall) Do(f func([]byte, net.Addr) (int, error)) *MockPacketConnWriteToCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockPacketConnWriteToCall) DoAndReturn(f func([]byte, net.Addr) (int, error)) *MockPacketConnWriteToCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_quic_conn_test.go",
          "type": "blob",
          "size": 25.478515625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: QUICConn)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_quic_conn_test.go github.com/quic-go/quic-go QUICConn\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\tcontext \"context\"\n\tnet \"net\"\n\treflect \"reflect\"\n\n\tqerr \"github.com/quic-go/quic-go/internal/qerr\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockQUICConn is a mock of QUICConn interface.\ntype MockQUICConn struct {\n\tctrl     *gomock.Controller\n\trecorder *MockQUICConnMockRecorder\n\tisgomock struct{}\n}\n\n// MockQUICConnMockRecorder is the mock recorder for MockQUICConn.\ntype MockQUICConnMockRecorder struct {\n\tmock *MockQUICConn\n}\n\n// NewMockQUICConn creates a new mock instance.\nfunc NewMockQUICConn(ctrl *gomock.Controller) *MockQUICConn {\n\tmock := &MockQUICConn{ctrl: ctrl}\n\tmock.recorder = &MockQUICConnMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockQUICConn) EXPECT() *MockQUICConnMockRecorder {\n\treturn m.recorder\n}\n\n// AcceptStream mocks base method.\nfunc (m *MockQUICConn) AcceptStream(arg0 context.Context) (Stream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AcceptStream\", arg0)\n\tret0, _ := ret[0].(Stream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// AcceptStream indicates an expected call of AcceptStream.\nfunc (mr *MockQUICConnMockRecorder) AcceptStream(arg0 any) *MockQUICConnAcceptStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AcceptStream\", reflect.TypeOf((*MockQUICConn)(nil).AcceptStream), arg0)\n\treturn &MockQUICConnAcceptStreamCall{Call: call}\n}\n\n// MockQUICConnAcceptStreamCall wrap *gomock.Call\ntype MockQUICConnAcceptStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnAcceptStreamCall) Return(arg0 Stream, arg1 error) *MockQUICConnAcceptStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnAcceptStreamCall) Do(f func(context.Context) (Stream, error)) *MockQUICConnAcceptStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnAcceptStreamCall) DoAndReturn(f func(context.Context) (Stream, error)) *MockQUICConnAcceptStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// AcceptUniStream mocks base method.\nfunc (m *MockQUICConn) AcceptUniStream(arg0 context.Context) (ReceiveStream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AcceptUniStream\", arg0)\n\tret0, _ := ret[0].(ReceiveStream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// AcceptUniStream indicates an expected call of AcceptUniStream.\nfunc (mr *MockQUICConnMockRecorder) AcceptUniStream(arg0 any) *MockQUICConnAcceptUniStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AcceptUniStream\", reflect.TypeOf((*MockQUICConn)(nil).AcceptUniStream), arg0)\n\treturn &MockQUICConnAcceptUniStreamCall{Call: call}\n}\n\n// MockQUICConnAcceptUniStreamCall wrap *gomock.Call\ntype MockQUICConnAcceptUniStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnAcceptUniStreamCall) Return(arg0 ReceiveStream, arg1 error) *MockQUICConnAcceptUniStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnAcceptUniStreamCall) Do(f func(context.Context) (ReceiveStream, error)) *MockQUICConnAcceptUniStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnAcceptUniStreamCall) DoAndReturn(f func(context.Context) (ReceiveStream, error)) *MockQUICConnAcceptUniStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// CloseWithError mocks base method.\nfunc (m *MockQUICConn) CloseWithError(arg0 qerr.ApplicationErrorCode, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"CloseWithError\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// CloseWithError indicates an expected call of CloseWithError.\nfunc (mr *MockQUICConnMockRecorder) CloseWithError(arg0, arg1 any) *MockQUICConnCloseWithErrorCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CloseWithError\", reflect.TypeOf((*MockQUICConn)(nil).CloseWithError), arg0, arg1)\n\treturn &MockQUICConnCloseWithErrorCall{Call: call}\n}\n\n// MockQUICConnCloseWithErrorCall wrap *gomock.Call\ntype MockQUICConnCloseWithErrorCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnCloseWithErrorCall) Return(arg0 error) *MockQUICConnCloseWithErrorCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnCloseWithErrorCall) Do(f func(qerr.ApplicationErrorCode, string) error) *MockQUICConnCloseWithErrorCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnCloseWithErrorCall) DoAndReturn(f func(qerr.ApplicationErrorCode, string) error) *MockQUICConnCloseWithErrorCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ConnectionState mocks base method.\nfunc (m *MockQUICConn) ConnectionState() ConnectionState {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ConnectionState\")\n\tret0, _ := ret[0].(ConnectionState)\n\treturn ret0\n}\n\n// ConnectionState indicates an expected call of ConnectionState.\nfunc (mr *MockQUICConnMockRecorder) ConnectionState() *MockQUICConnConnectionStateCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ConnectionState\", reflect.TypeOf((*MockQUICConn)(nil).ConnectionState))\n\treturn &MockQUICConnConnectionStateCall{Call: call}\n}\n\n// MockQUICConnConnectionStateCall wrap *gomock.Call\ntype MockQUICConnConnectionStateCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnConnectionStateCall) Return(arg0 ConnectionState) *MockQUICConnConnectionStateCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnConnectionStateCall) Do(f func() ConnectionState) *MockQUICConnConnectionStateCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnConnectionStateCall) DoAndReturn(f func() ConnectionState) *MockQUICConnConnectionStateCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Context mocks base method.\nfunc (m *MockQUICConn) Context() context.Context {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Context\")\n\tret0, _ := ret[0].(context.Context)\n\treturn ret0\n}\n\n// Context indicates an expected call of Context.\nfunc (mr *MockQUICConnMockRecorder) Context() *MockQUICConnContextCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Context\", reflect.TypeOf((*MockQUICConn)(nil).Context))\n\treturn &MockQUICConnContextCall{Call: call}\n}\n\n// MockQUICConnContextCall wrap *gomock.Call\ntype MockQUICConnContextCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnContextCall) Return(arg0 context.Context) *MockQUICConnContextCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnContextCall) Do(f func() context.Context) *MockQUICConnContextCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnContextCall) DoAndReturn(f func() context.Context) *MockQUICConnContextCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// HandshakeComplete mocks base method.\nfunc (m *MockQUICConn) HandshakeComplete() <-chan struct{} {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"HandshakeComplete\")\n\tret0, _ := ret[0].(<-chan struct{})\n\treturn ret0\n}\n\n// HandshakeComplete indicates an expected call of HandshakeComplete.\nfunc (mr *MockQUICConnMockRecorder) HandshakeComplete() *MockQUICConnHandshakeCompleteCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"HandshakeComplete\", reflect.TypeOf((*MockQUICConn)(nil).HandshakeComplete))\n\treturn &MockQUICConnHandshakeCompleteCall{Call: call}\n}\n\n// MockQUICConnHandshakeCompleteCall wrap *gomock.Call\ntype MockQUICConnHandshakeCompleteCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnHandshakeCompleteCall) Return(arg0 <-chan struct{}) *MockQUICConnHandshakeCompleteCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnHandshakeCompleteCall) Do(f func() <-chan struct{}) *MockQUICConnHandshakeCompleteCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnHandshakeCompleteCall) DoAndReturn(f func() <-chan struct{}) *MockQUICConnHandshakeCompleteCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// LocalAddr mocks base method.\nfunc (m *MockQUICConn) LocalAddr() net.Addr {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"LocalAddr\")\n\tret0, _ := ret[0].(net.Addr)\n\treturn ret0\n}\n\n// LocalAddr indicates an expected call of LocalAddr.\nfunc (mr *MockQUICConnMockRecorder) LocalAddr() *MockQUICConnLocalAddrCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LocalAddr\", reflect.TypeOf((*MockQUICConn)(nil).LocalAddr))\n\treturn &MockQUICConnLocalAddrCall{Call: call}\n}\n\n// MockQUICConnLocalAddrCall wrap *gomock.Call\ntype MockQUICConnLocalAddrCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnLocalAddrCall) Return(arg0 net.Addr) *MockQUICConnLocalAddrCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnLocalAddrCall) Do(f func() net.Addr) *MockQUICConnLocalAddrCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnLocalAddrCall) DoAndReturn(f func() net.Addr) *MockQUICConnLocalAddrCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// NextConnection mocks base method.\nfunc (m *MockQUICConn) NextConnection(arg0 context.Context) (Connection, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"NextConnection\", arg0)\n\tret0, _ := ret[0].(Connection)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// NextConnection indicates an expected call of NextConnection.\nfunc (mr *MockQUICConnMockRecorder) NextConnection(arg0 any) *MockQUICConnNextConnectionCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"NextConnection\", reflect.TypeOf((*MockQUICConn)(nil).NextConnection), arg0)\n\treturn &MockQUICConnNextConnectionCall{Call: call}\n}\n\n// MockQUICConnNextConnectionCall wrap *gomock.Call\ntype MockQUICConnNextConnectionCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnNextConnectionCall) Return(arg0 Connection, arg1 error) *MockQUICConnNextConnectionCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnNextConnectionCall) Do(f func(context.Context) (Connection, error)) *MockQUICConnNextConnectionCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnNextConnectionCall) DoAndReturn(f func(context.Context) (Connection, error)) *MockQUICConnNextConnectionCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenStream mocks base method.\nfunc (m *MockQUICConn) OpenStream() (Stream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenStream\")\n\tret0, _ := ret[0].(Stream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenStream indicates an expected call of OpenStream.\nfunc (mr *MockQUICConnMockRecorder) OpenStream() *MockQUICConnOpenStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenStream\", reflect.TypeOf((*MockQUICConn)(nil).OpenStream))\n\treturn &MockQUICConnOpenStreamCall{Call: call}\n}\n\n// MockQUICConnOpenStreamCall wrap *gomock.Call\ntype MockQUICConnOpenStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnOpenStreamCall) Return(arg0 Stream, arg1 error) *MockQUICConnOpenStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnOpenStreamCall) Do(f func() (Stream, error)) *MockQUICConnOpenStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnOpenStreamCall) DoAndReturn(f func() (Stream, error)) *MockQUICConnOpenStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenStreamSync mocks base method.\nfunc (m *MockQUICConn) OpenStreamSync(arg0 context.Context) (Stream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenStreamSync\", arg0)\n\tret0, _ := ret[0].(Stream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenStreamSync indicates an expected call of OpenStreamSync.\nfunc (mr *MockQUICConnMockRecorder) OpenStreamSync(arg0 any) *MockQUICConnOpenStreamSyncCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenStreamSync\", reflect.TypeOf((*MockQUICConn)(nil).OpenStreamSync), arg0)\n\treturn &MockQUICConnOpenStreamSyncCall{Call: call}\n}\n\n// MockQUICConnOpenStreamSyncCall wrap *gomock.Call\ntype MockQUICConnOpenStreamSyncCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnOpenStreamSyncCall) Return(arg0 Stream, arg1 error) *MockQUICConnOpenStreamSyncCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnOpenStreamSyncCall) Do(f func(context.Context) (Stream, error)) *MockQUICConnOpenStreamSyncCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnOpenStreamSyncCall) DoAndReturn(f func(context.Context) (Stream, error)) *MockQUICConnOpenStreamSyncCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenUniStream mocks base method.\nfunc (m *MockQUICConn) OpenUniStream() (SendStream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenUniStream\")\n\tret0, _ := ret[0].(SendStream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenUniStream indicates an expected call of OpenUniStream.\nfunc (mr *MockQUICConnMockRecorder) OpenUniStream() *MockQUICConnOpenUniStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenUniStream\", reflect.TypeOf((*MockQUICConn)(nil).OpenUniStream))\n\treturn &MockQUICConnOpenUniStreamCall{Call: call}\n}\n\n// MockQUICConnOpenUniStreamCall wrap *gomock.Call\ntype MockQUICConnOpenUniStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnOpenUniStreamCall) Return(arg0 SendStream, arg1 error) *MockQUICConnOpenUniStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnOpenUniStreamCall) Do(f func() (SendStream, error)) *MockQUICConnOpenUniStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnOpenUniStreamCall) DoAndReturn(f func() (SendStream, error)) *MockQUICConnOpenUniStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenUniStreamSync mocks base method.\nfunc (m *MockQUICConn) OpenUniStreamSync(arg0 context.Context) (SendStream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenUniStreamSync\", arg0)\n\tret0, _ := ret[0].(SendStream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenUniStreamSync indicates an expected call of OpenUniStreamSync.\nfunc (mr *MockQUICConnMockRecorder) OpenUniStreamSync(arg0 any) *MockQUICConnOpenUniStreamSyncCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenUniStreamSync\", reflect.TypeOf((*MockQUICConn)(nil).OpenUniStreamSync), arg0)\n\treturn &MockQUICConnOpenUniStreamSyncCall{Call: call}\n}\n\n// MockQUICConnOpenUniStreamSyncCall wrap *gomock.Call\ntype MockQUICConnOpenUniStreamSyncCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnOpenUniStreamSyncCall) Return(arg0 SendStream, arg1 error) *MockQUICConnOpenUniStreamSyncCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnOpenUniStreamSyncCall) Do(f func(context.Context) (SendStream, error)) *MockQUICConnOpenUniStreamSyncCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnOpenUniStreamSyncCall) DoAndReturn(f func(context.Context) (SendStream, error)) *MockQUICConnOpenUniStreamSyncCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ReceiveDatagram mocks base method.\nfunc (m *MockQUICConn) ReceiveDatagram(arg0 context.Context) ([]byte, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ReceiveDatagram\", arg0)\n\tret0, _ := ret[0].([]byte)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// ReceiveDatagram indicates an expected call of ReceiveDatagram.\nfunc (mr *MockQUICConnMockRecorder) ReceiveDatagram(arg0 any) *MockQUICConnReceiveDatagramCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReceiveDatagram\", reflect.TypeOf((*MockQUICConn)(nil).ReceiveDatagram), arg0)\n\treturn &MockQUICConnReceiveDatagramCall{Call: call}\n}\n\n// MockQUICConnReceiveDatagramCall wrap *gomock.Call\ntype MockQUICConnReceiveDatagramCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnReceiveDatagramCall) Return(arg0 []byte, arg1 error) *MockQUICConnReceiveDatagramCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnReceiveDatagramCall) Do(f func(context.Context) ([]byte, error)) *MockQUICConnReceiveDatagramCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnReceiveDatagramCall) DoAndReturn(f func(context.Context) ([]byte, error)) *MockQUICConnReceiveDatagramCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// RemoteAddr mocks base method.\nfunc (m *MockQUICConn) RemoteAddr() net.Addr {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RemoteAddr\")\n\tret0, _ := ret[0].(net.Addr)\n\treturn ret0\n}\n\n// RemoteAddr indicates an expected call of RemoteAddr.\nfunc (mr *MockQUICConnMockRecorder) RemoteAddr() *MockQUICConnRemoteAddrCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RemoteAddr\", reflect.TypeOf((*MockQUICConn)(nil).RemoteAddr))\n\treturn &MockQUICConnRemoteAddrCall{Call: call}\n}\n\n// MockQUICConnRemoteAddrCall wrap *gomock.Call\ntype MockQUICConnRemoteAddrCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnRemoteAddrCall) Return(arg0 net.Addr) *MockQUICConnRemoteAddrCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnRemoteAddrCall) Do(f func() net.Addr) *MockQUICConnRemoteAddrCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnRemoteAddrCall) DoAndReturn(f func() net.Addr) *MockQUICConnRemoteAddrCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SendDatagram mocks base method.\nfunc (m *MockQUICConn) SendDatagram(payload []byte) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SendDatagram\", payload)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SendDatagram indicates an expected call of SendDatagram.\nfunc (mr *MockQUICConnMockRecorder) SendDatagram(payload any) *MockQUICConnSendDatagramCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SendDatagram\", reflect.TypeOf((*MockQUICConn)(nil).SendDatagram), payload)\n\treturn &MockQUICConnSendDatagramCall{Call: call}\n}\n\n// MockQUICConnSendDatagramCall wrap *gomock.Call\ntype MockQUICConnSendDatagramCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnSendDatagramCall) Return(arg0 error) *MockQUICConnSendDatagramCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnSendDatagramCall) Do(f func([]byte) error) *MockQUICConnSendDatagramCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnSendDatagramCall) DoAndReturn(f func([]byte) error) *MockQUICConnSendDatagramCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// closeWithTransportError mocks base method.\nfunc (m *MockQUICConn) closeWithTransportError(arg0 qerr.TransportErrorCode) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"closeWithTransportError\", arg0)\n}\n\n// closeWithTransportError indicates an expected call of closeWithTransportError.\nfunc (mr *MockQUICConnMockRecorder) closeWithTransportError(arg0 any) *MockQUICConncloseWithTransportErrorCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"closeWithTransportError\", reflect.TypeOf((*MockQUICConn)(nil).closeWithTransportError), arg0)\n\treturn &MockQUICConncloseWithTransportErrorCall{Call: call}\n}\n\n// MockQUICConncloseWithTransportErrorCall wrap *gomock.Call\ntype MockQUICConncloseWithTransportErrorCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConncloseWithTransportErrorCall) Return() *MockQUICConncloseWithTransportErrorCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConncloseWithTransportErrorCall) Do(f func(qerr.TransportErrorCode)) *MockQUICConncloseWithTransportErrorCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConncloseWithTransportErrorCall) DoAndReturn(f func(qerr.TransportErrorCode)) *MockQUICConncloseWithTransportErrorCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// destroy mocks base method.\nfunc (m *MockQUICConn) destroy(arg0 error) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"destroy\", arg0)\n}\n\n// destroy indicates an expected call of destroy.\nfunc (mr *MockQUICConnMockRecorder) destroy(arg0 any) *MockQUICConndestroyCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"destroy\", reflect.TypeOf((*MockQUICConn)(nil).destroy), arg0)\n\treturn &MockQUICConndestroyCall{Call: call}\n}\n\n// MockQUICConndestroyCall wrap *gomock.Call\ntype MockQUICConndestroyCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConndestroyCall) Return() *MockQUICConndestroyCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConndestroyCall) Do(f func(error)) *MockQUICConndestroyCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConndestroyCall) DoAndReturn(f func(error)) *MockQUICConndestroyCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// earlyConnReady mocks base method.\nfunc (m *MockQUICConn) earlyConnReady() <-chan struct{} {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"earlyConnReady\")\n\tret0, _ := ret[0].(<-chan struct{})\n\treturn ret0\n}\n\n// earlyConnReady indicates an expected call of earlyConnReady.\nfunc (mr *MockQUICConnMockRecorder) earlyConnReady() *MockQUICConnearlyConnReadyCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"earlyConnReady\", reflect.TypeOf((*MockQUICConn)(nil).earlyConnReady))\n\treturn &MockQUICConnearlyConnReadyCall{Call: call}\n}\n\n// MockQUICConnearlyConnReadyCall wrap *gomock.Call\ntype MockQUICConnearlyConnReadyCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnearlyConnReadyCall) Return(arg0 <-chan struct{}) *MockQUICConnearlyConnReadyCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnearlyConnReadyCall) Do(f func() <-chan struct{}) *MockQUICConnearlyConnReadyCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnearlyConnReadyCall) DoAndReturn(f func() <-chan struct{}) *MockQUICConnearlyConnReadyCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handlePacket mocks base method.\nfunc (m *MockQUICConn) handlePacket(arg0 receivedPacket) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"handlePacket\", arg0)\n}\n\n// handlePacket indicates an expected call of handlePacket.\nfunc (mr *MockQUICConnMockRecorder) handlePacket(arg0 any) *MockQUICConnhandlePacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handlePacket\", reflect.TypeOf((*MockQUICConn)(nil).handlePacket), arg0)\n\treturn &MockQUICConnhandlePacketCall{Call: call}\n}\n\n// MockQUICConnhandlePacketCall wrap *gomock.Call\ntype MockQUICConnhandlePacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnhandlePacketCall) Return() *MockQUICConnhandlePacketCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnhandlePacketCall) Do(f func(receivedPacket)) *MockQUICConnhandlePacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnhandlePacketCall) DoAndReturn(f func(receivedPacket)) *MockQUICConnhandlePacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// run mocks base method.\nfunc (m *MockQUICConn) run() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"run\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// run indicates an expected call of run.\nfunc (mr *MockQUICConnMockRecorder) run() *MockQUICConnrunCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"run\", reflect.TypeOf((*MockQUICConn)(nil).run))\n\treturn &MockQUICConnrunCall{Call: call}\n}\n\n// MockQUICConnrunCall wrap *gomock.Call\ntype MockQUICConnrunCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockQUICConnrunCall) Return(arg0 error) *MockQUICConnrunCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockQUICConnrunCall) Do(f func() error) *MockQUICConnrunCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockQUICConnrunCall) DoAndReturn(f func() error) *MockQUICConnrunCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_raw_conn_test.go",
          "type": "blob",
          "size": 8.2392578125,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: RawConn)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_raw_conn_test.go github.com/quic-go/quic-go RawConn\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\tnet \"net\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockRawConn is a mock of RawConn interface.\ntype MockRawConn struct {\n\tctrl     *gomock.Controller\n\trecorder *MockRawConnMockRecorder\n\tisgomock struct{}\n}\n\n// MockRawConnMockRecorder is the mock recorder for MockRawConn.\ntype MockRawConnMockRecorder struct {\n\tmock *MockRawConn\n}\n\n// NewMockRawConn creates a new mock instance.\nfunc NewMockRawConn(ctrl *gomock.Controller) *MockRawConn {\n\tmock := &MockRawConn{ctrl: ctrl}\n\tmock.recorder = &MockRawConnMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockRawConn) EXPECT() *MockRawConnMockRecorder {\n\treturn m.recorder\n}\n\n// Close mocks base method.\nfunc (m *MockRawConn) Close() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Close\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Close indicates an expected call of Close.\nfunc (mr *MockRawConnMockRecorder) Close() *MockRawConnCloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Close\", reflect.TypeOf((*MockRawConn)(nil).Close))\n\treturn &MockRawConnCloseCall{Call: call}\n}\n\n// MockRawConnCloseCall wrap *gomock.Call\ntype MockRawConnCloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockRawConnCloseCall) Return(arg0 error) *MockRawConnCloseCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockRawConnCloseCall) Do(f func() error) *MockRawConnCloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockRawConnCloseCall) DoAndReturn(f func() error) *MockRawConnCloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// LocalAddr mocks base method.\nfunc (m *MockRawConn) LocalAddr() net.Addr {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"LocalAddr\")\n\tret0, _ := ret[0].(net.Addr)\n\treturn ret0\n}\n\n// LocalAddr indicates an expected call of LocalAddr.\nfunc (mr *MockRawConnMockRecorder) LocalAddr() *MockRawConnLocalAddrCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LocalAddr\", reflect.TypeOf((*MockRawConn)(nil).LocalAddr))\n\treturn &MockRawConnLocalAddrCall{Call: call}\n}\n\n// MockRawConnLocalAddrCall wrap *gomock.Call\ntype MockRawConnLocalAddrCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockRawConnLocalAddrCall) Return(arg0 net.Addr) *MockRawConnLocalAddrCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockRawConnLocalAddrCall) Do(f func() net.Addr) *MockRawConnLocalAddrCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockRawConnLocalAddrCall) DoAndReturn(f func() net.Addr) *MockRawConnLocalAddrCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ReadPacket mocks base method.\nfunc (m *MockRawConn) ReadPacket() (receivedPacket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ReadPacket\")\n\tret0, _ := ret[0].(receivedPacket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// ReadPacket indicates an expected call of ReadPacket.\nfunc (mr *MockRawConnMockRecorder) ReadPacket() *MockRawConnReadPacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ReadPacket\", reflect.TypeOf((*MockRawConn)(nil).ReadPacket))\n\treturn &MockRawConnReadPacketCall{Call: call}\n}\n\n// MockRawConnReadPacketCall wrap *gomock.Call\ntype MockRawConnReadPacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockRawConnReadPacketCall) Return(arg0 receivedPacket, arg1 error) *MockRawConnReadPacketCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockRawConnReadPacketCall) Do(f func() (receivedPacket, error)) *MockRawConnReadPacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockRawConnReadPacketCall) DoAndReturn(f func() (receivedPacket, error)) *MockRawConnReadPacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetReadDeadline mocks base method.\nfunc (m *MockRawConn) SetReadDeadline(arg0 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetReadDeadline\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetReadDeadline indicates an expected call of SetReadDeadline.\nfunc (mr *MockRawConnMockRecorder) SetReadDeadline(arg0 any) *MockRawConnSetReadDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetReadDeadline\", reflect.TypeOf((*MockRawConn)(nil).SetReadDeadline), arg0)\n\treturn &MockRawConnSetReadDeadlineCall{Call: call}\n}\n\n// MockRawConnSetReadDeadlineCall wrap *gomock.Call\ntype MockRawConnSetReadDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockRawConnSetReadDeadlineCall) Return(arg0 error) *MockRawConnSetReadDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockRawConnSetReadDeadlineCall) Do(f func(time.Time) error) *MockRawConnSetReadDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockRawConnSetReadDeadlineCall) DoAndReturn(f func(time.Time) error) *MockRawConnSetReadDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// WritePacket mocks base method.\nfunc (m *MockRawConn) WritePacket(b []byte, addr net.Addr, packetInfoOOB []byte, gsoSize uint16, ecn protocol.ECN) (int, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"WritePacket\", b, addr, packetInfoOOB, gsoSize, ecn)\n\tret0, _ := ret[0].(int)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// WritePacket indicates an expected call of WritePacket.\nfunc (mr *MockRawConnMockRecorder) WritePacket(b, addr, packetInfoOOB, gsoSize, ecn any) *MockRawConnWritePacketCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"WritePacket\", reflect.TypeOf((*MockRawConn)(nil).WritePacket), b, addr, packetInfoOOB, gsoSize, ecn)\n\treturn &MockRawConnWritePacketCall{Call: call}\n}\n\n// MockRawConnWritePacketCall wrap *gomock.Call\ntype MockRawConnWritePacketCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockRawConnWritePacketCall) Return(arg0 int, arg1 error) *MockRawConnWritePacketCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockRawConnWritePacketCall) Do(f func([]byte, net.Addr, []byte, uint16, protocol.ECN) (int, error)) *MockRawConnWritePacketCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockRawConnWritePacketCall) DoAndReturn(f func([]byte, net.Addr, []byte, uint16, protocol.ECN) (int, error)) *MockRawConnWritePacketCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// capabilities mocks base method.\nfunc (m *MockRawConn) capabilities() connCapabilities {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"capabilities\")\n\tret0, _ := ret[0].(connCapabilities)\n\treturn ret0\n}\n\n// capabilities indicates an expected call of capabilities.\nfunc (mr *MockRawConnMockRecorder) capabilities() *MockRawConncapabilitiesCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"capabilities\", reflect.TypeOf((*MockRawConn)(nil).capabilities))\n\treturn &MockRawConncapabilitiesCall{Call: call}\n}\n\n// MockRawConncapabilitiesCall wrap *gomock.Call\ntype MockRawConncapabilitiesCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockRawConncapabilitiesCall) Return(arg0 connCapabilities) *MockRawConncapabilitiesCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockRawConncapabilitiesCall) Do(f func() connCapabilities) *MockRawConncapabilitiesCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockRawConncapabilitiesCall) DoAndReturn(f func() connCapabilities) *MockRawConncapabilitiesCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_receive_stream_internal_test.go",
          "type": "blob",
          "size": 10.349609375,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: ReceiveStreamI)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_receive_stream_internal_test.go github.com/quic-go/quic-go ReceiveStreamI\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tqerr \"github.com/quic-go/quic-go/internal/qerr\"\n\twire \"github.com/quic-go/quic-go/internal/wire\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockReceiveStreamI is a mock of ReceiveStreamI interface.\ntype MockReceiveStreamI struct {\n\tctrl     *gomock.Controller\n\trecorder *MockReceiveStreamIMockRecorder\n\tisgomock struct{}\n}\n\n// MockReceiveStreamIMockRecorder is the mock recorder for MockReceiveStreamI.\ntype MockReceiveStreamIMockRecorder struct {\n\tmock *MockReceiveStreamI\n}\n\n// NewMockReceiveStreamI creates a new mock instance.\nfunc NewMockReceiveStreamI(ctrl *gomock.Controller) *MockReceiveStreamI {\n\tmock := &MockReceiveStreamI{ctrl: ctrl}\n\tmock.recorder = &MockReceiveStreamIMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockReceiveStreamI) EXPECT() *MockReceiveStreamIMockRecorder {\n\treturn m.recorder\n}\n\n// CancelRead mocks base method.\nfunc (m *MockReceiveStreamI) CancelRead(arg0 qerr.StreamErrorCode) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"CancelRead\", arg0)\n}\n\n// CancelRead indicates an expected call of CancelRead.\nfunc (mr *MockReceiveStreamIMockRecorder) CancelRead(arg0 any) *MockReceiveStreamICancelReadCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelRead\", reflect.TypeOf((*MockReceiveStreamI)(nil).CancelRead), arg0)\n\treturn &MockReceiveStreamICancelReadCall{Call: call}\n}\n\n// MockReceiveStreamICancelReadCall wrap *gomock.Call\ntype MockReceiveStreamICancelReadCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockReceiveStreamICancelReadCall) Return() *MockReceiveStreamICancelReadCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockReceiveStreamICancelReadCall) Do(f func(qerr.StreamErrorCode)) *MockReceiveStreamICancelReadCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockReceiveStreamICancelReadCall) DoAndReturn(f func(qerr.StreamErrorCode)) *MockReceiveStreamICancelReadCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Read mocks base method.\nfunc (m *MockReceiveStreamI) Read(p []byte) (int, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Read\", p)\n\tret0, _ := ret[0].(int)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Read indicates an expected call of Read.\nfunc (mr *MockReceiveStreamIMockRecorder) Read(p any) *MockReceiveStreamIReadCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Read\", reflect.TypeOf((*MockReceiveStreamI)(nil).Read), p)\n\treturn &MockReceiveStreamIReadCall{Call: call}\n}\n\n// MockReceiveStreamIReadCall wrap *gomock.Call\ntype MockReceiveStreamIReadCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockReceiveStreamIReadCall) Return(n int, err error) *MockReceiveStreamIReadCall {\n\tc.Call = c.Call.Return(n, err)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockReceiveStreamIReadCall) Do(f func([]byte) (int, error)) *MockReceiveStreamIReadCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockReceiveStreamIReadCall) DoAndReturn(f func([]byte) (int, error)) *MockReceiveStreamIReadCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetReadDeadline mocks base method.\nfunc (m *MockReceiveStreamI) SetReadDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetReadDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetReadDeadline indicates an expected call of SetReadDeadline.\nfunc (mr *MockReceiveStreamIMockRecorder) SetReadDeadline(t any) *MockReceiveStreamISetReadDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetReadDeadline\", reflect.TypeOf((*MockReceiveStreamI)(nil).SetReadDeadline), t)\n\treturn &MockReceiveStreamISetReadDeadlineCall{Call: call}\n}\n\n// MockReceiveStreamISetReadDeadlineCall wrap *gomock.Call\ntype MockReceiveStreamISetReadDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockReceiveStreamISetReadDeadlineCall) Return(arg0 error) *MockReceiveStreamISetReadDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockReceiveStreamISetReadDeadlineCall) Do(f func(time.Time) error) *MockReceiveStreamISetReadDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockReceiveStreamISetReadDeadlineCall) DoAndReturn(f func(time.Time) error) *MockReceiveStreamISetReadDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// StreamID mocks base method.\nfunc (m *MockReceiveStreamI) StreamID() protocol.StreamID {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"StreamID\")\n\tret0, _ := ret[0].(protocol.StreamID)\n\treturn ret0\n}\n\n// StreamID indicates an expected call of StreamID.\nfunc (mr *MockReceiveStreamIMockRecorder) StreamID() *MockReceiveStreamIStreamIDCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"StreamID\", reflect.TypeOf((*MockReceiveStreamI)(nil).StreamID))\n\treturn &MockReceiveStreamIStreamIDCall{Call: call}\n}\n\n// MockReceiveStreamIStreamIDCall wrap *gomock.Call\ntype MockReceiveStreamIStreamIDCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockReceiveStreamIStreamIDCall) Return(arg0 protocol.StreamID) *MockReceiveStreamIStreamIDCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockReceiveStreamIStreamIDCall) Do(f func() protocol.StreamID) *MockReceiveStreamIStreamIDCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockReceiveStreamIStreamIDCall) DoAndReturn(f func() protocol.StreamID) *MockReceiveStreamIStreamIDCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// closeForShutdown mocks base method.\nfunc (m *MockReceiveStreamI) closeForShutdown(arg0 error) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"closeForShutdown\", arg0)\n}\n\n// closeForShutdown indicates an expected call of closeForShutdown.\nfunc (mr *MockReceiveStreamIMockRecorder) closeForShutdown(arg0 any) *MockReceiveStreamIcloseForShutdownCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"closeForShutdown\", reflect.TypeOf((*MockReceiveStreamI)(nil).closeForShutdown), arg0)\n\treturn &MockReceiveStreamIcloseForShutdownCall{Call: call}\n}\n\n// MockReceiveStreamIcloseForShutdownCall wrap *gomock.Call\ntype MockReceiveStreamIcloseForShutdownCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockReceiveStreamIcloseForShutdownCall) Return() *MockReceiveStreamIcloseForShutdownCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockReceiveStreamIcloseForShutdownCall) Do(f func(error)) *MockReceiveStreamIcloseForShutdownCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockReceiveStreamIcloseForShutdownCall) DoAndReturn(f func(error)) *MockReceiveStreamIcloseForShutdownCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handleResetStreamFrame mocks base method.\nfunc (m *MockReceiveStreamI) handleResetStreamFrame(arg0 *wire.ResetStreamFrame, arg1 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"handleResetStreamFrame\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// handleResetStreamFrame indicates an expected call of handleResetStreamFrame.\nfunc (mr *MockReceiveStreamIMockRecorder) handleResetStreamFrame(arg0, arg1 any) *MockReceiveStreamIhandleResetStreamFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handleResetStreamFrame\", reflect.TypeOf((*MockReceiveStreamI)(nil).handleResetStreamFrame), arg0, arg1)\n\treturn &MockReceiveStreamIhandleResetStreamFrameCall{Call: call}\n}\n\n// MockReceiveStreamIhandleResetStreamFrameCall wrap *gomock.Call\ntype MockReceiveStreamIhandleResetStreamFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockReceiveStreamIhandleResetStreamFrameCall) Return(arg0 error) *MockReceiveStreamIhandleResetStreamFrameCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockReceiveStreamIhandleResetStreamFrameCall) Do(f func(*wire.ResetStreamFrame, time.Time) error) *MockReceiveStreamIhandleResetStreamFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockReceiveStreamIhandleResetStreamFrameCall) DoAndReturn(f func(*wire.ResetStreamFrame, time.Time) error) *MockReceiveStreamIhandleResetStreamFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handleStreamFrame mocks base method.\nfunc (m *MockReceiveStreamI) handleStreamFrame(arg0 *wire.StreamFrame, arg1 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"handleStreamFrame\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// handleStreamFrame indicates an expected call of handleStreamFrame.\nfunc (mr *MockReceiveStreamIMockRecorder) handleStreamFrame(arg0, arg1 any) *MockReceiveStreamIhandleStreamFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handleStreamFrame\", reflect.TypeOf((*MockReceiveStreamI)(nil).handleStreamFrame), arg0, arg1)\n\treturn &MockReceiveStreamIhandleStreamFrameCall{Call: call}\n}\n\n// MockReceiveStreamIhandleStreamFrameCall wrap *gomock.Call\ntype MockReceiveStreamIhandleStreamFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockReceiveStreamIhandleStreamFrameCall) Return(arg0 error) *MockReceiveStreamIhandleStreamFrameCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockReceiveStreamIhandleStreamFrameCall) Do(f func(*wire.StreamFrame, time.Time) error) *MockReceiveStreamIhandleStreamFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockReceiveStreamIhandleStreamFrameCall) DoAndReturn(f func(*wire.StreamFrame, time.Time) error) *MockReceiveStreamIhandleStreamFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_sealing_manager_test.go",
          "type": "blob",
          "size": 6.986328125,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: SealingManager)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_sealing_manager_test.go github.com/quic-go/quic-go SealingManager\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\n\thandshake \"github.com/quic-go/quic-go/internal/handshake\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockSealingManager is a mock of SealingManager interface.\ntype MockSealingManager struct {\n\tctrl     *gomock.Controller\n\trecorder *MockSealingManagerMockRecorder\n\tisgomock struct{}\n}\n\n// MockSealingManagerMockRecorder is the mock recorder for MockSealingManager.\ntype MockSealingManagerMockRecorder struct {\n\tmock *MockSealingManager\n}\n\n// NewMockSealingManager creates a new mock instance.\nfunc NewMockSealingManager(ctrl *gomock.Controller) *MockSealingManager {\n\tmock := &MockSealingManager{ctrl: ctrl}\n\tmock.recorder = &MockSealingManagerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockSealingManager) EXPECT() *MockSealingManagerMockRecorder {\n\treturn m.recorder\n}\n\n// Get0RTTSealer mocks base method.\nfunc (m *MockSealingManager) Get0RTTSealer() (handshake.LongHeaderSealer, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get0RTTSealer\")\n\tret0, _ := ret[0].(handshake.LongHeaderSealer)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Get0RTTSealer indicates an expected call of Get0RTTSealer.\nfunc (mr *MockSealingManagerMockRecorder) Get0RTTSealer() *MockSealingManagerGet0RTTSealerCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get0RTTSealer\", reflect.TypeOf((*MockSealingManager)(nil).Get0RTTSealer))\n\treturn &MockSealingManagerGet0RTTSealerCall{Call: call}\n}\n\n// MockSealingManagerGet0RTTSealerCall wrap *gomock.Call\ntype MockSealingManagerGet0RTTSealerCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSealingManagerGet0RTTSealerCall) Return(arg0 handshake.LongHeaderSealer, arg1 error) *MockSealingManagerGet0RTTSealerCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSealingManagerGet0RTTSealerCall) Do(f func() (handshake.LongHeaderSealer, error)) *MockSealingManagerGet0RTTSealerCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSealingManagerGet0RTTSealerCall) DoAndReturn(f func() (handshake.LongHeaderSealer, error)) *MockSealingManagerGet0RTTSealerCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Get1RTTSealer mocks base method.\nfunc (m *MockSealingManager) Get1RTTSealer() (handshake.ShortHeaderSealer, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get1RTTSealer\")\n\tret0, _ := ret[0].(handshake.ShortHeaderSealer)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Get1RTTSealer indicates an expected call of Get1RTTSealer.\nfunc (mr *MockSealingManagerMockRecorder) Get1RTTSealer() *MockSealingManagerGet1RTTSealerCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get1RTTSealer\", reflect.TypeOf((*MockSealingManager)(nil).Get1RTTSealer))\n\treturn &MockSealingManagerGet1RTTSealerCall{Call: call}\n}\n\n// MockSealingManagerGet1RTTSealerCall wrap *gomock.Call\ntype MockSealingManagerGet1RTTSealerCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSealingManagerGet1RTTSealerCall) Return(arg0 handshake.ShortHeaderSealer, arg1 error) *MockSealingManagerGet1RTTSealerCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSealingManagerGet1RTTSealerCall) Do(f func() (handshake.ShortHeaderSealer, error)) *MockSealingManagerGet1RTTSealerCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSealingManagerGet1RTTSealerCall) DoAndReturn(f func() (handshake.ShortHeaderSealer, error)) *MockSealingManagerGet1RTTSealerCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetHandshakeSealer mocks base method.\nfunc (m *MockSealingManager) GetHandshakeSealer() (handshake.LongHeaderSealer, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetHandshakeSealer\")\n\tret0, _ := ret[0].(handshake.LongHeaderSealer)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetHandshakeSealer indicates an expected call of GetHandshakeSealer.\nfunc (mr *MockSealingManagerMockRecorder) GetHandshakeSealer() *MockSealingManagerGetHandshakeSealerCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetHandshakeSealer\", reflect.TypeOf((*MockSealingManager)(nil).GetHandshakeSealer))\n\treturn &MockSealingManagerGetHandshakeSealerCall{Call: call}\n}\n\n// MockSealingManagerGetHandshakeSealerCall wrap *gomock.Call\ntype MockSealingManagerGetHandshakeSealerCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSealingManagerGetHandshakeSealerCall) Return(arg0 handshake.LongHeaderSealer, arg1 error) *MockSealingManagerGetHandshakeSealerCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSealingManagerGetHandshakeSealerCall) Do(f func() (handshake.LongHeaderSealer, error)) *MockSealingManagerGetHandshakeSealerCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSealingManagerGetHandshakeSealerCall) DoAndReturn(f func() (handshake.LongHeaderSealer, error)) *MockSealingManagerGetHandshakeSealerCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetInitialSealer mocks base method.\nfunc (m *MockSealingManager) GetInitialSealer() (handshake.LongHeaderSealer, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetInitialSealer\")\n\tret0, _ := ret[0].(handshake.LongHeaderSealer)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetInitialSealer indicates an expected call of GetInitialSealer.\nfunc (mr *MockSealingManagerMockRecorder) GetInitialSealer() *MockSealingManagerGetInitialSealerCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetInitialSealer\", reflect.TypeOf((*MockSealingManager)(nil).GetInitialSealer))\n\treturn &MockSealingManagerGetInitialSealerCall{Call: call}\n}\n\n// MockSealingManagerGetInitialSealerCall wrap *gomock.Call\ntype MockSealingManagerGetInitialSealerCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSealingManagerGetInitialSealerCall) Return(arg0 handshake.LongHeaderSealer, arg1 error) *MockSealingManagerGetInitialSealerCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSealingManagerGetInitialSealerCall) Do(f func() (handshake.LongHeaderSealer, error)) *MockSealingManagerGetInitialSealerCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSealingManagerGetInitialSealerCall) DoAndReturn(f func() (handshake.LongHeaderSealer, error)) *MockSealingManagerGetInitialSealerCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_send_conn_test.go",
          "type": "blob",
          "size": 6.6787109375,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: SendConn)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_send_conn_test.go github.com/quic-go/quic-go SendConn\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\tnet \"net\"\n\treflect \"reflect\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockSendConn is a mock of SendConn interface.\ntype MockSendConn struct {\n\tctrl     *gomock.Controller\n\trecorder *MockSendConnMockRecorder\n\tisgomock struct{}\n}\n\n// MockSendConnMockRecorder is the mock recorder for MockSendConn.\ntype MockSendConnMockRecorder struct {\n\tmock *MockSendConn\n}\n\n// NewMockSendConn creates a new mock instance.\nfunc NewMockSendConn(ctrl *gomock.Controller) *MockSendConn {\n\tmock := &MockSendConn{ctrl: ctrl}\n\tmock.recorder = &MockSendConnMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockSendConn) EXPECT() *MockSendConnMockRecorder {\n\treturn m.recorder\n}\n\n// Close mocks base method.\nfunc (m *MockSendConn) Close() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Close\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Close indicates an expected call of Close.\nfunc (mr *MockSendConnMockRecorder) Close() *MockSendConnCloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Close\", reflect.TypeOf((*MockSendConn)(nil).Close))\n\treturn &MockSendConnCloseCall{Call: call}\n}\n\n// MockSendConnCloseCall wrap *gomock.Call\ntype MockSendConnCloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendConnCloseCall) Return(arg0 error) *MockSendConnCloseCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendConnCloseCall) Do(f func() error) *MockSendConnCloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendConnCloseCall) DoAndReturn(f func() error) *MockSendConnCloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// LocalAddr mocks base method.\nfunc (m *MockSendConn) LocalAddr() net.Addr {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"LocalAddr\")\n\tret0, _ := ret[0].(net.Addr)\n\treturn ret0\n}\n\n// LocalAddr indicates an expected call of LocalAddr.\nfunc (mr *MockSendConnMockRecorder) LocalAddr() *MockSendConnLocalAddrCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"LocalAddr\", reflect.TypeOf((*MockSendConn)(nil).LocalAddr))\n\treturn &MockSendConnLocalAddrCall{Call: call}\n}\n\n// MockSendConnLocalAddrCall wrap *gomock.Call\ntype MockSendConnLocalAddrCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendConnLocalAddrCall) Return(arg0 net.Addr) *MockSendConnLocalAddrCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendConnLocalAddrCall) Do(f func() net.Addr) *MockSendConnLocalAddrCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendConnLocalAddrCall) DoAndReturn(f func() net.Addr) *MockSendConnLocalAddrCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// RemoteAddr mocks base method.\nfunc (m *MockSendConn) RemoteAddr() net.Addr {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"RemoteAddr\")\n\tret0, _ := ret[0].(net.Addr)\n\treturn ret0\n}\n\n// RemoteAddr indicates an expected call of RemoteAddr.\nfunc (mr *MockSendConnMockRecorder) RemoteAddr() *MockSendConnRemoteAddrCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"RemoteAddr\", reflect.TypeOf((*MockSendConn)(nil).RemoteAddr))\n\treturn &MockSendConnRemoteAddrCall{Call: call}\n}\n\n// MockSendConnRemoteAddrCall wrap *gomock.Call\ntype MockSendConnRemoteAddrCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendConnRemoteAddrCall) Return(arg0 net.Addr) *MockSendConnRemoteAddrCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendConnRemoteAddrCall) Do(f func() net.Addr) *MockSendConnRemoteAddrCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendConnRemoteAddrCall) DoAndReturn(f func() net.Addr) *MockSendConnRemoteAddrCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Write mocks base method.\nfunc (m *MockSendConn) Write(b []byte, gsoSize uint16, ecn protocol.ECN) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Write\", b, gsoSize, ecn)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Write indicates an expected call of Write.\nfunc (mr *MockSendConnMockRecorder) Write(b, gsoSize, ecn any) *MockSendConnWriteCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Write\", reflect.TypeOf((*MockSendConn)(nil).Write), b, gsoSize, ecn)\n\treturn &MockSendConnWriteCall{Call: call}\n}\n\n// MockSendConnWriteCall wrap *gomock.Call\ntype MockSendConnWriteCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendConnWriteCall) Return(arg0 error) *MockSendConnWriteCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendConnWriteCall) Do(f func([]byte, uint16, protocol.ECN) error) *MockSendConnWriteCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendConnWriteCall) DoAndReturn(f func([]byte, uint16, protocol.ECN) error) *MockSendConnWriteCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// capabilities mocks base method.\nfunc (m *MockSendConn) capabilities() connCapabilities {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"capabilities\")\n\tret0, _ := ret[0].(connCapabilities)\n\treturn ret0\n}\n\n// capabilities indicates an expected call of capabilities.\nfunc (mr *MockSendConnMockRecorder) capabilities() *MockSendConncapabilitiesCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"capabilities\", reflect.TypeOf((*MockSendConn)(nil).capabilities))\n\treturn &MockSendConncapabilitiesCall{Call: call}\n}\n\n// MockSendConncapabilitiesCall wrap *gomock.Call\ntype MockSendConncapabilitiesCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendConncapabilitiesCall) Return(arg0 connCapabilities) *MockSendConncapabilitiesCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendConncapabilitiesCall) Do(f func() connCapabilities) *MockSendConncapabilitiesCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendConncapabilitiesCall) DoAndReturn(f func() connCapabilities) *MockSendConncapabilitiesCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_send_stream_internal_test.go",
          "type": "blob",
          "size": 14.822265625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: SendStreamI)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_send_stream_internal_test.go github.com/quic-go/quic-go SendStreamI\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tackhandler \"github.com/quic-go/quic-go/internal/ackhandler\"\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tqerr \"github.com/quic-go/quic-go/internal/qerr\"\n\twire \"github.com/quic-go/quic-go/internal/wire\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockSendStreamI is a mock of SendStreamI interface.\ntype MockSendStreamI struct {\n\tctrl     *gomock.Controller\n\trecorder *MockSendStreamIMockRecorder\n\tisgomock struct{}\n}\n\n// MockSendStreamIMockRecorder is the mock recorder for MockSendStreamI.\ntype MockSendStreamIMockRecorder struct {\n\tmock *MockSendStreamI\n}\n\n// NewMockSendStreamI creates a new mock instance.\nfunc NewMockSendStreamI(ctrl *gomock.Controller) *MockSendStreamI {\n\tmock := &MockSendStreamI{ctrl: ctrl}\n\tmock.recorder = &MockSendStreamIMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockSendStreamI) EXPECT() *MockSendStreamIMockRecorder {\n\treturn m.recorder\n}\n\n// CancelWrite mocks base method.\nfunc (m *MockSendStreamI) CancelWrite(arg0 qerr.StreamErrorCode) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"CancelWrite\", arg0)\n}\n\n// CancelWrite indicates an expected call of CancelWrite.\nfunc (mr *MockSendStreamIMockRecorder) CancelWrite(arg0 any) *MockSendStreamICancelWriteCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelWrite\", reflect.TypeOf((*MockSendStreamI)(nil).CancelWrite), arg0)\n\treturn &MockSendStreamICancelWriteCall{Call: call}\n}\n\n// MockSendStreamICancelWriteCall wrap *gomock.Call\ntype MockSendStreamICancelWriteCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamICancelWriteCall) Return() *MockSendStreamICancelWriteCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamICancelWriteCall) Do(f func(qerr.StreamErrorCode)) *MockSendStreamICancelWriteCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamICancelWriteCall) DoAndReturn(f func(qerr.StreamErrorCode)) *MockSendStreamICancelWriteCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Close mocks base method.\nfunc (m *MockSendStreamI) Close() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Close\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Close indicates an expected call of Close.\nfunc (mr *MockSendStreamIMockRecorder) Close() *MockSendStreamICloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Close\", reflect.TypeOf((*MockSendStreamI)(nil).Close))\n\treturn &MockSendStreamICloseCall{Call: call}\n}\n\n// MockSendStreamICloseCall wrap *gomock.Call\ntype MockSendStreamICloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamICloseCall) Return(arg0 error) *MockSendStreamICloseCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamICloseCall) Do(f func() error) *MockSendStreamICloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamICloseCall) DoAndReturn(f func() error) *MockSendStreamICloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Context mocks base method.\nfunc (m *MockSendStreamI) Context() context.Context {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Context\")\n\tret0, _ := ret[0].(context.Context)\n\treturn ret0\n}\n\n// Context indicates an expected call of Context.\nfunc (mr *MockSendStreamIMockRecorder) Context() *MockSendStreamIContextCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Context\", reflect.TypeOf((*MockSendStreamI)(nil).Context))\n\treturn &MockSendStreamIContextCall{Call: call}\n}\n\n// MockSendStreamIContextCall wrap *gomock.Call\ntype MockSendStreamIContextCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIContextCall) Return(arg0 context.Context) *MockSendStreamIContextCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIContextCall) Do(f func() context.Context) *MockSendStreamIContextCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIContextCall) DoAndReturn(f func() context.Context) *MockSendStreamIContextCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetWriteDeadline mocks base method.\nfunc (m *MockSendStreamI) SetWriteDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetWriteDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetWriteDeadline indicates an expected call of SetWriteDeadline.\nfunc (mr *MockSendStreamIMockRecorder) SetWriteDeadline(t any) *MockSendStreamISetWriteDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetWriteDeadline\", reflect.TypeOf((*MockSendStreamI)(nil).SetWriteDeadline), t)\n\treturn &MockSendStreamISetWriteDeadlineCall{Call: call}\n}\n\n// MockSendStreamISetWriteDeadlineCall wrap *gomock.Call\ntype MockSendStreamISetWriteDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamISetWriteDeadlineCall) Return(arg0 error) *MockSendStreamISetWriteDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamISetWriteDeadlineCall) Do(f func(time.Time) error) *MockSendStreamISetWriteDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamISetWriteDeadlineCall) DoAndReturn(f func(time.Time) error) *MockSendStreamISetWriteDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// StreamID mocks base method.\nfunc (m *MockSendStreamI) StreamID() protocol.StreamID {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"StreamID\")\n\tret0, _ := ret[0].(protocol.StreamID)\n\treturn ret0\n}\n\n// StreamID indicates an expected call of StreamID.\nfunc (mr *MockSendStreamIMockRecorder) StreamID() *MockSendStreamIStreamIDCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"StreamID\", reflect.TypeOf((*MockSendStreamI)(nil).StreamID))\n\treturn &MockSendStreamIStreamIDCall{Call: call}\n}\n\n// MockSendStreamIStreamIDCall wrap *gomock.Call\ntype MockSendStreamIStreamIDCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIStreamIDCall) Return(arg0 protocol.StreamID) *MockSendStreamIStreamIDCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIStreamIDCall) Do(f func() protocol.StreamID) *MockSendStreamIStreamIDCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIStreamIDCall) DoAndReturn(f func() protocol.StreamID) *MockSendStreamIStreamIDCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Write mocks base method.\nfunc (m *MockSendStreamI) Write(p []byte) (int, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Write\", p)\n\tret0, _ := ret[0].(int)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Write indicates an expected call of Write.\nfunc (mr *MockSendStreamIMockRecorder) Write(p any) *MockSendStreamIWriteCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Write\", reflect.TypeOf((*MockSendStreamI)(nil).Write), p)\n\treturn &MockSendStreamIWriteCall{Call: call}\n}\n\n// MockSendStreamIWriteCall wrap *gomock.Call\ntype MockSendStreamIWriteCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIWriteCall) Return(n int, err error) *MockSendStreamIWriteCall {\n\tc.Call = c.Call.Return(n, err)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIWriteCall) Do(f func([]byte) (int, error)) *MockSendStreamIWriteCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIWriteCall) DoAndReturn(f func([]byte) (int, error)) *MockSendStreamIWriteCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// closeForShutdown mocks base method.\nfunc (m *MockSendStreamI) closeForShutdown(arg0 error) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"closeForShutdown\", arg0)\n}\n\n// closeForShutdown indicates an expected call of closeForShutdown.\nfunc (mr *MockSendStreamIMockRecorder) closeForShutdown(arg0 any) *MockSendStreamIcloseForShutdownCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"closeForShutdown\", reflect.TypeOf((*MockSendStreamI)(nil).closeForShutdown), arg0)\n\treturn &MockSendStreamIcloseForShutdownCall{Call: call}\n}\n\n// MockSendStreamIcloseForShutdownCall wrap *gomock.Call\ntype MockSendStreamIcloseForShutdownCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIcloseForShutdownCall) Return() *MockSendStreamIcloseForShutdownCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIcloseForShutdownCall) Do(f func(error)) *MockSendStreamIcloseForShutdownCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIcloseForShutdownCall) DoAndReturn(f func(error)) *MockSendStreamIcloseForShutdownCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handleStopSendingFrame mocks base method.\nfunc (m *MockSendStreamI) handleStopSendingFrame(arg0 *wire.StopSendingFrame) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"handleStopSendingFrame\", arg0)\n}\n\n// handleStopSendingFrame indicates an expected call of handleStopSendingFrame.\nfunc (mr *MockSendStreamIMockRecorder) handleStopSendingFrame(arg0 any) *MockSendStreamIhandleStopSendingFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handleStopSendingFrame\", reflect.TypeOf((*MockSendStreamI)(nil).handleStopSendingFrame), arg0)\n\treturn &MockSendStreamIhandleStopSendingFrameCall{Call: call}\n}\n\n// MockSendStreamIhandleStopSendingFrameCall wrap *gomock.Call\ntype MockSendStreamIhandleStopSendingFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIhandleStopSendingFrameCall) Return() *MockSendStreamIhandleStopSendingFrameCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIhandleStopSendingFrameCall) Do(f func(*wire.StopSendingFrame)) *MockSendStreamIhandleStopSendingFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIhandleStopSendingFrameCall) DoAndReturn(f func(*wire.StopSendingFrame)) *MockSendStreamIhandleStopSendingFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// hasData mocks base method.\nfunc (m *MockSendStreamI) hasData() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"hasData\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// hasData indicates an expected call of hasData.\nfunc (mr *MockSendStreamIMockRecorder) hasData() *MockSendStreamIhasDataCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"hasData\", reflect.TypeOf((*MockSendStreamI)(nil).hasData))\n\treturn &MockSendStreamIhasDataCall{Call: call}\n}\n\n// MockSendStreamIhasDataCall wrap *gomock.Call\ntype MockSendStreamIhasDataCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIhasDataCall) Return(arg0 bool) *MockSendStreamIhasDataCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIhasDataCall) Do(f func() bool) *MockSendStreamIhasDataCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIhasDataCall) DoAndReturn(f func() bool) *MockSendStreamIhasDataCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// popStreamFrame mocks base method.\nfunc (m *MockSendStreamI) popStreamFrame(arg0 protocol.ByteCount, arg1 protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"popStreamFrame\", arg0, arg1)\n\tret0, _ := ret[0].(ackhandler.StreamFrame)\n\tret1, _ := ret[1].(*wire.StreamDataBlockedFrame)\n\tret2, _ := ret[2].(bool)\n\treturn ret0, ret1, ret2\n}\n\n// popStreamFrame indicates an expected call of popStreamFrame.\nfunc (mr *MockSendStreamIMockRecorder) popStreamFrame(arg0, arg1 any) *MockSendStreamIpopStreamFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"popStreamFrame\", reflect.TypeOf((*MockSendStreamI)(nil).popStreamFrame), arg0, arg1)\n\treturn &MockSendStreamIpopStreamFrameCall{Call: call}\n}\n\n// MockSendStreamIpopStreamFrameCall wrap *gomock.Call\ntype MockSendStreamIpopStreamFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIpopStreamFrameCall) Return(arg0 ackhandler.StreamFrame, arg1 *wire.StreamDataBlockedFrame, hasMore bool) *MockSendStreamIpopStreamFrameCall {\n\tc.Call = c.Call.Return(arg0, arg1, hasMore)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIpopStreamFrameCall) Do(f func(protocol.ByteCount, protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool)) *MockSendStreamIpopStreamFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIpopStreamFrameCall) DoAndReturn(f func(protocol.ByteCount, protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool)) *MockSendStreamIpopStreamFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// updateSendWindow mocks base method.\nfunc (m *MockSendStreamI) updateSendWindow(arg0 protocol.ByteCount) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"updateSendWindow\", arg0)\n}\n\n// updateSendWindow indicates an expected call of updateSendWindow.\nfunc (mr *MockSendStreamIMockRecorder) updateSendWindow(arg0 any) *MockSendStreamIupdateSendWindowCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"updateSendWindow\", reflect.TypeOf((*MockSendStreamI)(nil).updateSendWindow), arg0)\n\treturn &MockSendStreamIupdateSendWindowCall{Call: call}\n}\n\n// MockSendStreamIupdateSendWindowCall wrap *gomock.Call\ntype MockSendStreamIupdateSendWindowCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSendStreamIupdateSendWindowCall) Return() *MockSendStreamIupdateSendWindowCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSendStreamIupdateSendWindowCall) Do(f func(protocol.ByteCount)) *MockSendStreamIupdateSendWindowCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSendStreamIupdateSendWindowCall) DoAndReturn(f func(protocol.ByteCount)) *MockSendStreamIupdateSendWindowCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_sender_test.go",
          "type": "blob",
          "size": 6.15625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: Sender)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_sender_test.go github.com/quic-go/quic-go Sender\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockSender is a mock of Sender interface.\ntype MockSender struct {\n\tctrl     *gomock.Controller\n\trecorder *MockSenderMockRecorder\n\tisgomock struct{}\n}\n\n// MockSenderMockRecorder is the mock recorder for MockSender.\ntype MockSenderMockRecorder struct {\n\tmock *MockSender\n}\n\n// NewMockSender creates a new mock instance.\nfunc NewMockSender(ctrl *gomock.Controller) *MockSender {\n\tmock := &MockSender{ctrl: ctrl}\n\tmock.recorder = &MockSenderMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockSender) EXPECT() *MockSenderMockRecorder {\n\treturn m.recorder\n}\n\n// Available mocks base method.\nfunc (m *MockSender) Available() <-chan struct{} {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Available\")\n\tret0, _ := ret[0].(<-chan struct{})\n\treturn ret0\n}\n\n// Available indicates an expected call of Available.\nfunc (mr *MockSenderMockRecorder) Available() *MockSenderAvailableCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Available\", reflect.TypeOf((*MockSender)(nil).Available))\n\treturn &MockSenderAvailableCall{Call: call}\n}\n\n// MockSenderAvailableCall wrap *gomock.Call\ntype MockSenderAvailableCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSenderAvailableCall) Return(arg0 <-chan struct{}) *MockSenderAvailableCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSenderAvailableCall) Do(f func() <-chan struct{}) *MockSenderAvailableCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSenderAvailableCall) DoAndReturn(f func() <-chan struct{}) *MockSenderAvailableCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Close mocks base method.\nfunc (m *MockSender) Close() {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Close\")\n}\n\n// Close indicates an expected call of Close.\nfunc (mr *MockSenderMockRecorder) Close() *MockSenderCloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Close\", reflect.TypeOf((*MockSender)(nil).Close))\n\treturn &MockSenderCloseCall{Call: call}\n}\n\n// MockSenderCloseCall wrap *gomock.Call\ntype MockSenderCloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSenderCloseCall) Return() *MockSenderCloseCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSenderCloseCall) Do(f func()) *MockSenderCloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSenderCloseCall) DoAndReturn(f func()) *MockSenderCloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Run mocks base method.\nfunc (m *MockSender) Run() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Run\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Run indicates an expected call of Run.\nfunc (mr *MockSenderMockRecorder) Run() *MockSenderRunCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Run\", reflect.TypeOf((*MockSender)(nil).Run))\n\treturn &MockSenderRunCall{Call: call}\n}\n\n// MockSenderRunCall wrap *gomock.Call\ntype MockSenderRunCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSenderRunCall) Return(arg0 error) *MockSenderRunCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSenderRunCall) Do(f func() error) *MockSenderRunCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSenderRunCall) DoAndReturn(f func() error) *MockSenderRunCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Send mocks base method.\nfunc (m *MockSender) Send(p *packetBuffer, gsoSize uint16, ecn protocol.ECN) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Send\", p, gsoSize, ecn)\n}\n\n// Send indicates an expected call of Send.\nfunc (mr *MockSenderMockRecorder) Send(p, gsoSize, ecn any) *MockSenderSendCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Send\", reflect.TypeOf((*MockSender)(nil).Send), p, gsoSize, ecn)\n\treturn &MockSenderSendCall{Call: call}\n}\n\n// MockSenderSendCall wrap *gomock.Call\ntype MockSenderSendCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSenderSendCall) Return() *MockSenderSendCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSenderSendCall) Do(f func(*packetBuffer, uint16, protocol.ECN)) *MockSenderSendCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSenderSendCall) DoAndReturn(f func(*packetBuffer, uint16, protocol.ECN)) *MockSenderSendCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// WouldBlock mocks base method.\nfunc (m *MockSender) WouldBlock() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"WouldBlock\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// WouldBlock indicates an expected call of WouldBlock.\nfunc (mr *MockSenderMockRecorder) WouldBlock() *MockSenderWouldBlockCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"WouldBlock\", reflect.TypeOf((*MockSender)(nil).WouldBlock))\n\treturn &MockSenderWouldBlockCall{Call: call}\n}\n\n// MockSenderWouldBlockCall wrap *gomock.Call\ntype MockSenderWouldBlockCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockSenderWouldBlockCall) Return(arg0 bool) *MockSenderWouldBlockCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockSenderWouldBlockCall) Do(f func() bool) *MockSenderWouldBlockCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockSenderWouldBlockCall) DoAndReturn(f func() bool) *MockSenderWouldBlockCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_stream_control_frame_getter_test.go",
          "type": "blob",
          "size": 3.0537109375,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: StreamControlFrameGetter)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_control_frame_getter_test.go github.com/quic-go/quic-go StreamControlFrameGetter\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tackhandler \"github.com/quic-go/quic-go/internal/ackhandler\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockStreamControlFrameGetter is a mock of StreamControlFrameGetter interface.\ntype MockStreamControlFrameGetter struct {\n\tctrl     *gomock.Controller\n\trecorder *MockStreamControlFrameGetterMockRecorder\n\tisgomock struct{}\n}\n\n// MockStreamControlFrameGetterMockRecorder is the mock recorder for MockStreamControlFrameGetter.\ntype MockStreamControlFrameGetterMockRecorder struct {\n\tmock *MockStreamControlFrameGetter\n}\n\n// NewMockStreamControlFrameGetter creates a new mock instance.\nfunc NewMockStreamControlFrameGetter(ctrl *gomock.Controller) *MockStreamControlFrameGetter {\n\tmock := &MockStreamControlFrameGetter{ctrl: ctrl}\n\tmock.recorder = &MockStreamControlFrameGetterMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockStreamControlFrameGetter) EXPECT() *MockStreamControlFrameGetterMockRecorder {\n\treturn m.recorder\n}\n\n// getControlFrame mocks base method.\nfunc (m *MockStreamControlFrameGetter) getControlFrame(arg0 time.Time) (ackhandler.Frame, bool, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"getControlFrame\", arg0)\n\tret0, _ := ret[0].(ackhandler.Frame)\n\tret1, _ := ret[1].(bool)\n\tret2, _ := ret[2].(bool)\n\treturn ret0, ret1, ret2\n}\n\n// getControlFrame indicates an expected call of getControlFrame.\nfunc (mr *MockStreamControlFrameGetterMockRecorder) getControlFrame(arg0 any) *MockStreamControlFrameGettergetControlFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"getControlFrame\", reflect.TypeOf((*MockStreamControlFrameGetter)(nil).getControlFrame), arg0)\n\treturn &MockStreamControlFrameGettergetControlFrameCall{Call: call}\n}\n\n// MockStreamControlFrameGettergetControlFrameCall wrap *gomock.Call\ntype MockStreamControlFrameGettergetControlFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamControlFrameGettergetControlFrameCall) Return(arg0 ackhandler.Frame, ok, hasMore bool) *MockStreamControlFrameGettergetControlFrameCall {\n\tc.Call = c.Call.Return(arg0, ok, hasMore)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamControlFrameGettergetControlFrameCall) Do(f func(time.Time) (ackhandler.Frame, bool, bool)) *MockStreamControlFrameGettergetControlFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamControlFrameGettergetControlFrameCall) DoAndReturn(f func(time.Time) (ackhandler.Frame, bool, bool)) *MockStreamControlFrameGettergetControlFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_stream_internal_test.go",
          "type": "blob",
          "size": 21.4521484375,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: StreamI)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_internal_test.go github.com/quic-go/quic-go StreamI\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tackhandler \"github.com/quic-go/quic-go/internal/ackhandler\"\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tqerr \"github.com/quic-go/quic-go/internal/qerr\"\n\twire \"github.com/quic-go/quic-go/internal/wire\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockStreamI is a mock of StreamI interface.\ntype MockStreamI struct {\n\tctrl     *gomock.Controller\n\trecorder *MockStreamIMockRecorder\n\tisgomock struct{}\n}\n\n// MockStreamIMockRecorder is the mock recorder for MockStreamI.\ntype MockStreamIMockRecorder struct {\n\tmock *MockStreamI\n}\n\n// NewMockStreamI creates a new mock instance.\nfunc NewMockStreamI(ctrl *gomock.Controller) *MockStreamI {\n\tmock := &MockStreamI{ctrl: ctrl}\n\tmock.recorder = &MockStreamIMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockStreamI) EXPECT() *MockStreamIMockRecorder {\n\treturn m.recorder\n}\n\n// CancelRead mocks base method.\nfunc (m *MockStreamI) CancelRead(arg0 qerr.StreamErrorCode) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"CancelRead\", arg0)\n}\n\n// CancelRead indicates an expected call of CancelRead.\nfunc (mr *MockStreamIMockRecorder) CancelRead(arg0 any) *MockStreamICancelReadCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelRead\", reflect.TypeOf((*MockStreamI)(nil).CancelRead), arg0)\n\treturn &MockStreamICancelReadCall{Call: call}\n}\n\n// MockStreamICancelReadCall wrap *gomock.Call\ntype MockStreamICancelReadCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamICancelReadCall) Return() *MockStreamICancelReadCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamICancelReadCall) Do(f func(qerr.StreamErrorCode)) *MockStreamICancelReadCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamICancelReadCall) DoAndReturn(f func(qerr.StreamErrorCode)) *MockStreamICancelReadCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// CancelWrite mocks base method.\nfunc (m *MockStreamI) CancelWrite(arg0 qerr.StreamErrorCode) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"CancelWrite\", arg0)\n}\n\n// CancelWrite indicates an expected call of CancelWrite.\nfunc (mr *MockStreamIMockRecorder) CancelWrite(arg0 any) *MockStreamICancelWriteCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CancelWrite\", reflect.TypeOf((*MockStreamI)(nil).CancelWrite), arg0)\n\treturn &MockStreamICancelWriteCall{Call: call}\n}\n\n// MockStreamICancelWriteCall wrap *gomock.Call\ntype MockStreamICancelWriteCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamICancelWriteCall) Return() *MockStreamICancelWriteCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamICancelWriteCall) Do(f func(qerr.StreamErrorCode)) *MockStreamICancelWriteCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamICancelWriteCall) DoAndReturn(f func(qerr.StreamErrorCode)) *MockStreamICancelWriteCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Close mocks base method.\nfunc (m *MockStreamI) Close() error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Close\")\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Close indicates an expected call of Close.\nfunc (mr *MockStreamIMockRecorder) Close() *MockStreamICloseCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Close\", reflect.TypeOf((*MockStreamI)(nil).Close))\n\treturn &MockStreamICloseCall{Call: call}\n}\n\n// MockStreamICloseCall wrap *gomock.Call\ntype MockStreamICloseCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamICloseCall) Return(arg0 error) *MockStreamICloseCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamICloseCall) Do(f func() error) *MockStreamICloseCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamICloseCall) DoAndReturn(f func() error) *MockStreamICloseCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Context mocks base method.\nfunc (m *MockStreamI) Context() context.Context {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Context\")\n\tret0, _ := ret[0].(context.Context)\n\treturn ret0\n}\n\n// Context indicates an expected call of Context.\nfunc (mr *MockStreamIMockRecorder) Context() *MockStreamIContextCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Context\", reflect.TypeOf((*MockStreamI)(nil).Context))\n\treturn &MockStreamIContextCall{Call: call}\n}\n\n// MockStreamIContextCall wrap *gomock.Call\ntype MockStreamIContextCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIContextCall) Return(arg0 context.Context) *MockStreamIContextCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIContextCall) Do(f func() context.Context) *MockStreamIContextCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIContextCall) DoAndReturn(f func() context.Context) *MockStreamIContextCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Read mocks base method.\nfunc (m *MockStreamI) Read(p []byte) (int, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Read\", p)\n\tret0, _ := ret[0].(int)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Read indicates an expected call of Read.\nfunc (mr *MockStreamIMockRecorder) Read(p any) *MockStreamIReadCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Read\", reflect.TypeOf((*MockStreamI)(nil).Read), p)\n\treturn &MockStreamIReadCall{Call: call}\n}\n\n// MockStreamIReadCall wrap *gomock.Call\ntype MockStreamIReadCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIReadCall) Return(n int, err error) *MockStreamIReadCall {\n\tc.Call = c.Call.Return(n, err)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIReadCall) Do(f func([]byte) (int, error)) *MockStreamIReadCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIReadCall) DoAndReturn(f func([]byte) (int, error)) *MockStreamIReadCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetDeadline mocks base method.\nfunc (m *MockStreamI) SetDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetDeadline indicates an expected call of SetDeadline.\nfunc (mr *MockStreamIMockRecorder) SetDeadline(t any) *MockStreamISetDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetDeadline\", reflect.TypeOf((*MockStreamI)(nil).SetDeadline), t)\n\treturn &MockStreamISetDeadlineCall{Call: call}\n}\n\n// MockStreamISetDeadlineCall wrap *gomock.Call\ntype MockStreamISetDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamISetDeadlineCall) Return(arg0 error) *MockStreamISetDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamISetDeadlineCall) Do(f func(time.Time) error) *MockStreamISetDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamISetDeadlineCall) DoAndReturn(f func(time.Time) error) *MockStreamISetDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetReadDeadline mocks base method.\nfunc (m *MockStreamI) SetReadDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetReadDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetReadDeadline indicates an expected call of SetReadDeadline.\nfunc (mr *MockStreamIMockRecorder) SetReadDeadline(t any) *MockStreamISetReadDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetReadDeadline\", reflect.TypeOf((*MockStreamI)(nil).SetReadDeadline), t)\n\treturn &MockStreamISetReadDeadlineCall{Call: call}\n}\n\n// MockStreamISetReadDeadlineCall wrap *gomock.Call\ntype MockStreamISetReadDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamISetReadDeadlineCall) Return(arg0 error) *MockStreamISetReadDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamISetReadDeadlineCall) Do(f func(time.Time) error) *MockStreamISetReadDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamISetReadDeadlineCall) DoAndReturn(f func(time.Time) error) *MockStreamISetReadDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// SetWriteDeadline mocks base method.\nfunc (m *MockStreamI) SetWriteDeadline(t time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"SetWriteDeadline\", t)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// SetWriteDeadline indicates an expected call of SetWriteDeadline.\nfunc (mr *MockStreamIMockRecorder) SetWriteDeadline(t any) *MockStreamISetWriteDeadlineCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"SetWriteDeadline\", reflect.TypeOf((*MockStreamI)(nil).SetWriteDeadline), t)\n\treturn &MockStreamISetWriteDeadlineCall{Call: call}\n}\n\n// MockStreamISetWriteDeadlineCall wrap *gomock.Call\ntype MockStreamISetWriteDeadlineCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamISetWriteDeadlineCall) Return(arg0 error) *MockStreamISetWriteDeadlineCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamISetWriteDeadlineCall) Do(f func(time.Time) error) *MockStreamISetWriteDeadlineCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamISetWriteDeadlineCall) DoAndReturn(f func(time.Time) error) *MockStreamISetWriteDeadlineCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// StreamID mocks base method.\nfunc (m *MockStreamI) StreamID() protocol.StreamID {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"StreamID\")\n\tret0, _ := ret[0].(protocol.StreamID)\n\treturn ret0\n}\n\n// StreamID indicates an expected call of StreamID.\nfunc (mr *MockStreamIMockRecorder) StreamID() *MockStreamIStreamIDCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"StreamID\", reflect.TypeOf((*MockStreamI)(nil).StreamID))\n\treturn &MockStreamIStreamIDCall{Call: call}\n}\n\n// MockStreamIStreamIDCall wrap *gomock.Call\ntype MockStreamIStreamIDCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIStreamIDCall) Return(arg0 protocol.StreamID) *MockStreamIStreamIDCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIStreamIDCall) Do(f func() protocol.StreamID) *MockStreamIStreamIDCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIStreamIDCall) DoAndReturn(f func() protocol.StreamID) *MockStreamIStreamIDCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// Write mocks base method.\nfunc (m *MockStreamI) Write(p []byte) (int, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Write\", p)\n\tret0, _ := ret[0].(int)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Write indicates an expected call of Write.\nfunc (mr *MockStreamIMockRecorder) Write(p any) *MockStreamIWriteCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Write\", reflect.TypeOf((*MockStreamI)(nil).Write), p)\n\treturn &MockStreamIWriteCall{Call: call}\n}\n\n// MockStreamIWriteCall wrap *gomock.Call\ntype MockStreamIWriteCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIWriteCall) Return(n int, err error) *MockStreamIWriteCall {\n\tc.Call = c.Call.Return(n, err)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIWriteCall) Do(f func([]byte) (int, error)) *MockStreamIWriteCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIWriteCall) DoAndReturn(f func([]byte) (int, error)) *MockStreamIWriteCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// closeForShutdown mocks base method.\nfunc (m *MockStreamI) closeForShutdown(arg0 error) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"closeForShutdown\", arg0)\n}\n\n// closeForShutdown indicates an expected call of closeForShutdown.\nfunc (mr *MockStreamIMockRecorder) closeForShutdown(arg0 any) *MockStreamIcloseForShutdownCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"closeForShutdown\", reflect.TypeOf((*MockStreamI)(nil).closeForShutdown), arg0)\n\treturn &MockStreamIcloseForShutdownCall{Call: call}\n}\n\n// MockStreamIcloseForShutdownCall wrap *gomock.Call\ntype MockStreamIcloseForShutdownCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIcloseForShutdownCall) Return() *MockStreamIcloseForShutdownCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIcloseForShutdownCall) Do(f func(error)) *MockStreamIcloseForShutdownCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIcloseForShutdownCall) DoAndReturn(f func(error)) *MockStreamIcloseForShutdownCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handleResetStreamFrame mocks base method.\nfunc (m *MockStreamI) handleResetStreamFrame(arg0 *wire.ResetStreamFrame, arg1 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"handleResetStreamFrame\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// handleResetStreamFrame indicates an expected call of handleResetStreamFrame.\nfunc (mr *MockStreamIMockRecorder) handleResetStreamFrame(arg0, arg1 any) *MockStreamIhandleResetStreamFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handleResetStreamFrame\", reflect.TypeOf((*MockStreamI)(nil).handleResetStreamFrame), arg0, arg1)\n\treturn &MockStreamIhandleResetStreamFrameCall{Call: call}\n}\n\n// MockStreamIhandleResetStreamFrameCall wrap *gomock.Call\ntype MockStreamIhandleResetStreamFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIhandleResetStreamFrameCall) Return(arg0 error) *MockStreamIhandleResetStreamFrameCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIhandleResetStreamFrameCall) Do(f func(*wire.ResetStreamFrame, time.Time) error) *MockStreamIhandleResetStreamFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIhandleResetStreamFrameCall) DoAndReturn(f func(*wire.ResetStreamFrame, time.Time) error) *MockStreamIhandleResetStreamFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handleStopSendingFrame mocks base method.\nfunc (m *MockStreamI) handleStopSendingFrame(arg0 *wire.StopSendingFrame) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"handleStopSendingFrame\", arg0)\n}\n\n// handleStopSendingFrame indicates an expected call of handleStopSendingFrame.\nfunc (mr *MockStreamIMockRecorder) handleStopSendingFrame(arg0 any) *MockStreamIhandleStopSendingFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handleStopSendingFrame\", reflect.TypeOf((*MockStreamI)(nil).handleStopSendingFrame), arg0)\n\treturn &MockStreamIhandleStopSendingFrameCall{Call: call}\n}\n\n// MockStreamIhandleStopSendingFrameCall wrap *gomock.Call\ntype MockStreamIhandleStopSendingFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIhandleStopSendingFrameCall) Return() *MockStreamIhandleStopSendingFrameCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIhandleStopSendingFrameCall) Do(f func(*wire.StopSendingFrame)) *MockStreamIhandleStopSendingFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIhandleStopSendingFrameCall) DoAndReturn(f func(*wire.StopSendingFrame)) *MockStreamIhandleStopSendingFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// handleStreamFrame mocks base method.\nfunc (m *MockStreamI) handleStreamFrame(arg0 *wire.StreamFrame, arg1 time.Time) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"handleStreamFrame\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// handleStreamFrame indicates an expected call of handleStreamFrame.\nfunc (mr *MockStreamIMockRecorder) handleStreamFrame(arg0, arg1 any) *MockStreamIhandleStreamFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"handleStreamFrame\", reflect.TypeOf((*MockStreamI)(nil).handleStreamFrame), arg0, arg1)\n\treturn &MockStreamIhandleStreamFrameCall{Call: call}\n}\n\n// MockStreamIhandleStreamFrameCall wrap *gomock.Call\ntype MockStreamIhandleStreamFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIhandleStreamFrameCall) Return(arg0 error) *MockStreamIhandleStreamFrameCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIhandleStreamFrameCall) Do(f func(*wire.StreamFrame, time.Time) error) *MockStreamIhandleStreamFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIhandleStreamFrameCall) DoAndReturn(f func(*wire.StreamFrame, time.Time) error) *MockStreamIhandleStreamFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// hasData mocks base method.\nfunc (m *MockStreamI) hasData() bool {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"hasData\")\n\tret0, _ := ret[0].(bool)\n\treturn ret0\n}\n\n// hasData indicates an expected call of hasData.\nfunc (mr *MockStreamIMockRecorder) hasData() *MockStreamIhasDataCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"hasData\", reflect.TypeOf((*MockStreamI)(nil).hasData))\n\treturn &MockStreamIhasDataCall{Call: call}\n}\n\n// MockStreamIhasDataCall wrap *gomock.Call\ntype MockStreamIhasDataCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIhasDataCall) Return(arg0 bool) *MockStreamIhasDataCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIhasDataCall) Do(f func() bool) *MockStreamIhasDataCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIhasDataCall) DoAndReturn(f func() bool) *MockStreamIhasDataCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// popStreamFrame mocks base method.\nfunc (m *MockStreamI) popStreamFrame(arg0 protocol.ByteCount, arg1 protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"popStreamFrame\", arg0, arg1)\n\tret0, _ := ret[0].(ackhandler.StreamFrame)\n\tret1, _ := ret[1].(*wire.StreamDataBlockedFrame)\n\tret2, _ := ret[2].(bool)\n\treturn ret0, ret1, ret2\n}\n\n// popStreamFrame indicates an expected call of popStreamFrame.\nfunc (mr *MockStreamIMockRecorder) popStreamFrame(arg0, arg1 any) *MockStreamIpopStreamFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"popStreamFrame\", reflect.TypeOf((*MockStreamI)(nil).popStreamFrame), arg0, arg1)\n\treturn &MockStreamIpopStreamFrameCall{Call: call}\n}\n\n// MockStreamIpopStreamFrameCall wrap *gomock.Call\ntype MockStreamIpopStreamFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIpopStreamFrameCall) Return(arg0 ackhandler.StreamFrame, arg1 *wire.StreamDataBlockedFrame, hasMore bool) *MockStreamIpopStreamFrameCall {\n\tc.Call = c.Call.Return(arg0, arg1, hasMore)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIpopStreamFrameCall) Do(f func(protocol.ByteCount, protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool)) *MockStreamIpopStreamFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIpopStreamFrameCall) DoAndReturn(f func(protocol.ByteCount, protocol.Version) (ackhandler.StreamFrame, *wire.StreamDataBlockedFrame, bool)) *MockStreamIpopStreamFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// updateSendWindow mocks base method.\nfunc (m *MockStreamI) updateSendWindow(arg0 protocol.ByteCount) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"updateSendWindow\", arg0)\n}\n\n// updateSendWindow indicates an expected call of updateSendWindow.\nfunc (mr *MockStreamIMockRecorder) updateSendWindow(arg0 any) *MockStreamIupdateSendWindowCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"updateSendWindow\", reflect.TypeOf((*MockStreamI)(nil).updateSendWindow), arg0)\n\treturn &MockStreamIupdateSendWindowCall{Call: call}\n}\n\n// MockStreamIupdateSendWindowCall wrap *gomock.Call\ntype MockStreamIupdateSendWindowCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamIupdateSendWindowCall) Return() *MockStreamIupdateSendWindowCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamIupdateSendWindowCall) Do(f func(protocol.ByteCount)) *MockStreamIupdateSendWindowCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamIupdateSendWindowCall) DoAndReturn(f func(protocol.ByteCount)) *MockStreamIupdateSendWindowCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_stream_manager_test.go",
          "type": "blob",
          "size": 19.734375,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: StreamManager)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_manager_test.go github.com/quic-go/quic-go StreamManager\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\twire \"github.com/quic-go/quic-go/internal/wire\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockStreamManager is a mock of StreamManager interface.\ntype MockStreamManager struct {\n\tctrl     *gomock.Controller\n\trecorder *MockStreamManagerMockRecorder\n\tisgomock struct{}\n}\n\n// MockStreamManagerMockRecorder is the mock recorder for MockStreamManager.\ntype MockStreamManagerMockRecorder struct {\n\tmock *MockStreamManager\n}\n\n// NewMockStreamManager creates a new mock instance.\nfunc NewMockStreamManager(ctrl *gomock.Controller) *MockStreamManager {\n\tmock := &MockStreamManager{ctrl: ctrl}\n\tmock.recorder = &MockStreamManagerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockStreamManager) EXPECT() *MockStreamManagerMockRecorder {\n\treturn m.recorder\n}\n\n// AcceptStream mocks base method.\nfunc (m *MockStreamManager) AcceptStream(arg0 context.Context) (Stream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AcceptStream\", arg0)\n\tret0, _ := ret[0].(Stream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// AcceptStream indicates an expected call of AcceptStream.\nfunc (mr *MockStreamManagerMockRecorder) AcceptStream(arg0 any) *MockStreamManagerAcceptStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AcceptStream\", reflect.TypeOf((*MockStreamManager)(nil).AcceptStream), arg0)\n\treturn &MockStreamManagerAcceptStreamCall{Call: call}\n}\n\n// MockStreamManagerAcceptStreamCall wrap *gomock.Call\ntype MockStreamManagerAcceptStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerAcceptStreamCall) Return(arg0 Stream, arg1 error) *MockStreamManagerAcceptStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerAcceptStreamCall) Do(f func(context.Context) (Stream, error)) *MockStreamManagerAcceptStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerAcceptStreamCall) DoAndReturn(f func(context.Context) (Stream, error)) *MockStreamManagerAcceptStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// AcceptUniStream mocks base method.\nfunc (m *MockStreamManager) AcceptUniStream(arg0 context.Context) (ReceiveStream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"AcceptUniStream\", arg0)\n\tret0, _ := ret[0].(ReceiveStream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// AcceptUniStream indicates an expected call of AcceptUniStream.\nfunc (mr *MockStreamManagerMockRecorder) AcceptUniStream(arg0 any) *MockStreamManagerAcceptUniStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"AcceptUniStream\", reflect.TypeOf((*MockStreamManager)(nil).AcceptUniStream), arg0)\n\treturn &MockStreamManagerAcceptUniStreamCall{Call: call}\n}\n\n// MockStreamManagerAcceptUniStreamCall wrap *gomock.Call\ntype MockStreamManagerAcceptUniStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerAcceptUniStreamCall) Return(arg0 ReceiveStream, arg1 error) *MockStreamManagerAcceptUniStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerAcceptUniStreamCall) Do(f func(context.Context) (ReceiveStream, error)) *MockStreamManagerAcceptUniStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerAcceptUniStreamCall) DoAndReturn(f func(context.Context) (ReceiveStream, error)) *MockStreamManagerAcceptUniStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// CloseWithError mocks base method.\nfunc (m *MockStreamManager) CloseWithError(arg0 error) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"CloseWithError\", arg0)\n}\n\n// CloseWithError indicates an expected call of CloseWithError.\nfunc (mr *MockStreamManagerMockRecorder) CloseWithError(arg0 any) *MockStreamManagerCloseWithErrorCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"CloseWithError\", reflect.TypeOf((*MockStreamManager)(nil).CloseWithError), arg0)\n\treturn &MockStreamManagerCloseWithErrorCall{Call: call}\n}\n\n// MockStreamManagerCloseWithErrorCall wrap *gomock.Call\ntype MockStreamManagerCloseWithErrorCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerCloseWithErrorCall) Return() *MockStreamManagerCloseWithErrorCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerCloseWithErrorCall) Do(f func(error)) *MockStreamManagerCloseWithErrorCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerCloseWithErrorCall) DoAndReturn(f func(error)) *MockStreamManagerCloseWithErrorCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// DeleteStream mocks base method.\nfunc (m *MockStreamManager) DeleteStream(arg0 protocol.StreamID) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"DeleteStream\", arg0)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// DeleteStream indicates an expected call of DeleteStream.\nfunc (mr *MockStreamManagerMockRecorder) DeleteStream(arg0 any) *MockStreamManagerDeleteStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"DeleteStream\", reflect.TypeOf((*MockStreamManager)(nil).DeleteStream), arg0)\n\treturn &MockStreamManagerDeleteStreamCall{Call: call}\n}\n\n// MockStreamManagerDeleteStreamCall wrap *gomock.Call\ntype MockStreamManagerDeleteStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerDeleteStreamCall) Return(arg0 error) *MockStreamManagerDeleteStreamCall {\n\tc.Call = c.Call.Return(arg0)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerDeleteStreamCall) Do(f func(protocol.StreamID) error) *MockStreamManagerDeleteStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerDeleteStreamCall) DoAndReturn(f func(protocol.StreamID) error) *MockStreamManagerDeleteStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetOrOpenReceiveStream mocks base method.\nfunc (m *MockStreamManager) GetOrOpenReceiveStream(arg0 protocol.StreamID) (receiveStreamI, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetOrOpenReceiveStream\", arg0)\n\tret0, _ := ret[0].(receiveStreamI)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetOrOpenReceiveStream indicates an expected call of GetOrOpenReceiveStream.\nfunc (mr *MockStreamManagerMockRecorder) GetOrOpenReceiveStream(arg0 any) *MockStreamManagerGetOrOpenReceiveStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetOrOpenReceiveStream\", reflect.TypeOf((*MockStreamManager)(nil).GetOrOpenReceiveStream), arg0)\n\treturn &MockStreamManagerGetOrOpenReceiveStreamCall{Call: call}\n}\n\n// MockStreamManagerGetOrOpenReceiveStreamCall wrap *gomock.Call\ntype MockStreamManagerGetOrOpenReceiveStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerGetOrOpenReceiveStreamCall) Return(arg0 receiveStreamI, arg1 error) *MockStreamManagerGetOrOpenReceiveStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerGetOrOpenReceiveStreamCall) Do(f func(protocol.StreamID) (receiveStreamI, error)) *MockStreamManagerGetOrOpenReceiveStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerGetOrOpenReceiveStreamCall) DoAndReturn(f func(protocol.StreamID) (receiveStreamI, error)) *MockStreamManagerGetOrOpenReceiveStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// GetOrOpenSendStream mocks base method.\nfunc (m *MockStreamManager) GetOrOpenSendStream(arg0 protocol.StreamID) (sendStreamI, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetOrOpenSendStream\", arg0)\n\tret0, _ := ret[0].(sendStreamI)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetOrOpenSendStream indicates an expected call of GetOrOpenSendStream.\nfunc (mr *MockStreamManagerMockRecorder) GetOrOpenSendStream(arg0 any) *MockStreamManagerGetOrOpenSendStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetOrOpenSendStream\", reflect.TypeOf((*MockStreamManager)(nil).GetOrOpenSendStream), arg0)\n\treturn &MockStreamManagerGetOrOpenSendStreamCall{Call: call}\n}\n\n// MockStreamManagerGetOrOpenSendStreamCall wrap *gomock.Call\ntype MockStreamManagerGetOrOpenSendStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerGetOrOpenSendStreamCall) Return(arg0 sendStreamI, arg1 error) *MockStreamManagerGetOrOpenSendStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerGetOrOpenSendStreamCall) Do(f func(protocol.StreamID) (sendStreamI, error)) *MockStreamManagerGetOrOpenSendStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerGetOrOpenSendStreamCall) DoAndReturn(f func(protocol.StreamID) (sendStreamI, error)) *MockStreamManagerGetOrOpenSendStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// HandleMaxStreamsFrame mocks base method.\nfunc (m *MockStreamManager) HandleMaxStreamsFrame(arg0 *wire.MaxStreamsFrame) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"HandleMaxStreamsFrame\", arg0)\n}\n\n// HandleMaxStreamsFrame indicates an expected call of HandleMaxStreamsFrame.\nfunc (mr *MockStreamManagerMockRecorder) HandleMaxStreamsFrame(arg0 any) *MockStreamManagerHandleMaxStreamsFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"HandleMaxStreamsFrame\", reflect.TypeOf((*MockStreamManager)(nil).HandleMaxStreamsFrame), arg0)\n\treturn &MockStreamManagerHandleMaxStreamsFrameCall{Call: call}\n}\n\n// MockStreamManagerHandleMaxStreamsFrameCall wrap *gomock.Call\ntype MockStreamManagerHandleMaxStreamsFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerHandleMaxStreamsFrameCall) Return() *MockStreamManagerHandleMaxStreamsFrameCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerHandleMaxStreamsFrameCall) Do(f func(*wire.MaxStreamsFrame)) *MockStreamManagerHandleMaxStreamsFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerHandleMaxStreamsFrameCall) DoAndReturn(f func(*wire.MaxStreamsFrame)) *MockStreamManagerHandleMaxStreamsFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenStream mocks base method.\nfunc (m *MockStreamManager) OpenStream() (Stream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenStream\")\n\tret0, _ := ret[0].(Stream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenStream indicates an expected call of OpenStream.\nfunc (mr *MockStreamManagerMockRecorder) OpenStream() *MockStreamManagerOpenStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenStream\", reflect.TypeOf((*MockStreamManager)(nil).OpenStream))\n\treturn &MockStreamManagerOpenStreamCall{Call: call}\n}\n\n// MockStreamManagerOpenStreamCall wrap *gomock.Call\ntype MockStreamManagerOpenStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerOpenStreamCall) Return(arg0 Stream, arg1 error) *MockStreamManagerOpenStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerOpenStreamCall) Do(f func() (Stream, error)) *MockStreamManagerOpenStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerOpenStreamCall) DoAndReturn(f func() (Stream, error)) *MockStreamManagerOpenStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenStreamSync mocks base method.\nfunc (m *MockStreamManager) OpenStreamSync(arg0 context.Context) (Stream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenStreamSync\", arg0)\n\tret0, _ := ret[0].(Stream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenStreamSync indicates an expected call of OpenStreamSync.\nfunc (mr *MockStreamManagerMockRecorder) OpenStreamSync(arg0 any) *MockStreamManagerOpenStreamSyncCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenStreamSync\", reflect.TypeOf((*MockStreamManager)(nil).OpenStreamSync), arg0)\n\treturn &MockStreamManagerOpenStreamSyncCall{Call: call}\n}\n\n// MockStreamManagerOpenStreamSyncCall wrap *gomock.Call\ntype MockStreamManagerOpenStreamSyncCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerOpenStreamSyncCall) Return(arg0 Stream, arg1 error) *MockStreamManagerOpenStreamSyncCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerOpenStreamSyncCall) Do(f func(context.Context) (Stream, error)) *MockStreamManagerOpenStreamSyncCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerOpenStreamSyncCall) DoAndReturn(f func(context.Context) (Stream, error)) *MockStreamManagerOpenStreamSyncCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenUniStream mocks base method.\nfunc (m *MockStreamManager) OpenUniStream() (SendStream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenUniStream\")\n\tret0, _ := ret[0].(SendStream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenUniStream indicates an expected call of OpenUniStream.\nfunc (mr *MockStreamManagerMockRecorder) OpenUniStream() *MockStreamManagerOpenUniStreamCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenUniStream\", reflect.TypeOf((*MockStreamManager)(nil).OpenUniStream))\n\treturn &MockStreamManagerOpenUniStreamCall{Call: call}\n}\n\n// MockStreamManagerOpenUniStreamCall wrap *gomock.Call\ntype MockStreamManagerOpenUniStreamCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerOpenUniStreamCall) Return(arg0 SendStream, arg1 error) *MockStreamManagerOpenUniStreamCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerOpenUniStreamCall) Do(f func() (SendStream, error)) *MockStreamManagerOpenUniStreamCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerOpenUniStreamCall) DoAndReturn(f func() (SendStream, error)) *MockStreamManagerOpenUniStreamCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// OpenUniStreamSync mocks base method.\nfunc (m *MockStreamManager) OpenUniStreamSync(arg0 context.Context) (SendStream, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"OpenUniStreamSync\", arg0)\n\tret0, _ := ret[0].(SendStream)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// OpenUniStreamSync indicates an expected call of OpenUniStreamSync.\nfunc (mr *MockStreamManagerMockRecorder) OpenUniStreamSync(arg0 any) *MockStreamManagerOpenUniStreamSyncCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"OpenUniStreamSync\", reflect.TypeOf((*MockStreamManager)(nil).OpenUniStreamSync), arg0)\n\treturn &MockStreamManagerOpenUniStreamSyncCall{Call: call}\n}\n\n// MockStreamManagerOpenUniStreamSyncCall wrap *gomock.Call\ntype MockStreamManagerOpenUniStreamSyncCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerOpenUniStreamSyncCall) Return(arg0 SendStream, arg1 error) *MockStreamManagerOpenUniStreamSyncCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerOpenUniStreamSyncCall) Do(f func(context.Context) (SendStream, error)) *MockStreamManagerOpenUniStreamSyncCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerOpenUniStreamSyncCall) DoAndReturn(f func(context.Context) (SendStream, error)) *MockStreamManagerOpenUniStreamSyncCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// ResetFor0RTT mocks base method.\nfunc (m *MockStreamManager) ResetFor0RTT() {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"ResetFor0RTT\")\n}\n\n// ResetFor0RTT indicates an expected call of ResetFor0RTT.\nfunc (mr *MockStreamManagerMockRecorder) ResetFor0RTT() *MockStreamManagerResetFor0RTTCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ResetFor0RTT\", reflect.TypeOf((*MockStreamManager)(nil).ResetFor0RTT))\n\treturn &MockStreamManagerResetFor0RTTCall{Call: call}\n}\n\n// MockStreamManagerResetFor0RTTCall wrap *gomock.Call\ntype MockStreamManagerResetFor0RTTCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerResetFor0RTTCall) Return() *MockStreamManagerResetFor0RTTCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerResetFor0RTTCall) Do(f func()) *MockStreamManagerResetFor0RTTCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerResetFor0RTTCall) DoAndReturn(f func()) *MockStreamManagerResetFor0RTTCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// UpdateLimits mocks base method.\nfunc (m *MockStreamManager) UpdateLimits(arg0 *wire.TransportParameters) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"UpdateLimits\", arg0)\n}\n\n// UpdateLimits indicates an expected call of UpdateLimits.\nfunc (mr *MockStreamManagerMockRecorder) UpdateLimits(arg0 any) *MockStreamManagerUpdateLimitsCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UpdateLimits\", reflect.TypeOf((*MockStreamManager)(nil).UpdateLimits), arg0)\n\treturn &MockStreamManagerUpdateLimitsCall{Call: call}\n}\n\n// MockStreamManagerUpdateLimitsCall wrap *gomock.Call\ntype MockStreamManagerUpdateLimitsCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerUpdateLimitsCall) Return() *MockStreamManagerUpdateLimitsCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerUpdateLimitsCall) Do(f func(*wire.TransportParameters)) *MockStreamManagerUpdateLimitsCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerUpdateLimitsCall) DoAndReturn(f func(*wire.TransportParameters)) *MockStreamManagerUpdateLimitsCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// UseResetMaps mocks base method.\nfunc (m *MockStreamManager) UseResetMaps() {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"UseResetMaps\")\n}\n\n// UseResetMaps indicates an expected call of UseResetMaps.\nfunc (mr *MockStreamManagerMockRecorder) UseResetMaps() *MockStreamManagerUseResetMapsCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UseResetMaps\", reflect.TypeOf((*MockStreamManager)(nil).UseResetMaps))\n\treturn &MockStreamManagerUseResetMapsCall{Call: call}\n}\n\n// MockStreamManagerUseResetMapsCall wrap *gomock.Call\ntype MockStreamManagerUseResetMapsCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamManagerUseResetMapsCall) Return() *MockStreamManagerUseResetMapsCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamManagerUseResetMapsCall) Do(f func()) *MockStreamManagerUseResetMapsCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamManagerUseResetMapsCall) DoAndReturn(f func()) *MockStreamManagerUseResetMapsCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_stream_sender_test.go",
          "type": "blob",
          "size": 6.447265625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: StreamSender)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_sender_test.go github.com/quic-go/quic-go StreamSender\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockStreamSender is a mock of StreamSender interface.\ntype MockStreamSender struct {\n\tctrl     *gomock.Controller\n\trecorder *MockStreamSenderMockRecorder\n\tisgomock struct{}\n}\n\n// MockStreamSenderMockRecorder is the mock recorder for MockStreamSender.\ntype MockStreamSenderMockRecorder struct {\n\tmock *MockStreamSender\n}\n\n// NewMockStreamSender creates a new mock instance.\nfunc NewMockStreamSender(ctrl *gomock.Controller) *MockStreamSender {\n\tmock := &MockStreamSender{ctrl: ctrl}\n\tmock.recorder = &MockStreamSenderMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockStreamSender) EXPECT() *MockStreamSenderMockRecorder {\n\treturn m.recorder\n}\n\n// onHasConnectionData mocks base method.\nfunc (m *MockStreamSender) onHasConnectionData() {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"onHasConnectionData\")\n}\n\n// onHasConnectionData indicates an expected call of onHasConnectionData.\nfunc (mr *MockStreamSenderMockRecorder) onHasConnectionData() *MockStreamSenderonHasConnectionDataCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"onHasConnectionData\", reflect.TypeOf((*MockStreamSender)(nil).onHasConnectionData))\n\treturn &MockStreamSenderonHasConnectionDataCall{Call: call}\n}\n\n// MockStreamSenderonHasConnectionDataCall wrap *gomock.Call\ntype MockStreamSenderonHasConnectionDataCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamSenderonHasConnectionDataCall) Return() *MockStreamSenderonHasConnectionDataCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamSenderonHasConnectionDataCall) Do(f func()) *MockStreamSenderonHasConnectionDataCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamSenderonHasConnectionDataCall) DoAndReturn(f func()) *MockStreamSenderonHasConnectionDataCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// onHasStreamControlFrame mocks base method.\nfunc (m *MockStreamSender) onHasStreamControlFrame(arg0 protocol.StreamID, arg1 streamControlFrameGetter) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"onHasStreamControlFrame\", arg0, arg1)\n}\n\n// onHasStreamControlFrame indicates an expected call of onHasStreamControlFrame.\nfunc (mr *MockStreamSenderMockRecorder) onHasStreamControlFrame(arg0, arg1 any) *MockStreamSenderonHasStreamControlFrameCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"onHasStreamControlFrame\", reflect.TypeOf((*MockStreamSender)(nil).onHasStreamControlFrame), arg0, arg1)\n\treturn &MockStreamSenderonHasStreamControlFrameCall{Call: call}\n}\n\n// MockStreamSenderonHasStreamControlFrameCall wrap *gomock.Call\ntype MockStreamSenderonHasStreamControlFrameCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamSenderonHasStreamControlFrameCall) Return() *MockStreamSenderonHasStreamControlFrameCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamSenderonHasStreamControlFrameCall) Do(f func(protocol.StreamID, streamControlFrameGetter)) *MockStreamSenderonHasStreamControlFrameCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamSenderonHasStreamControlFrameCall) DoAndReturn(f func(protocol.StreamID, streamControlFrameGetter)) *MockStreamSenderonHasStreamControlFrameCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// onHasStreamData mocks base method.\nfunc (m *MockStreamSender) onHasStreamData(arg0 protocol.StreamID, arg1 sendStreamI) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"onHasStreamData\", arg0, arg1)\n}\n\n// onHasStreamData indicates an expected call of onHasStreamData.\nfunc (mr *MockStreamSenderMockRecorder) onHasStreamData(arg0, arg1 any) *MockStreamSenderonHasStreamDataCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"onHasStreamData\", reflect.TypeOf((*MockStreamSender)(nil).onHasStreamData), arg0, arg1)\n\treturn &MockStreamSenderonHasStreamDataCall{Call: call}\n}\n\n// MockStreamSenderonHasStreamDataCall wrap *gomock.Call\ntype MockStreamSenderonHasStreamDataCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamSenderonHasStreamDataCall) Return() *MockStreamSenderonHasStreamDataCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamSenderonHasStreamDataCall) Do(f func(protocol.StreamID, sendStreamI)) *MockStreamSenderonHasStreamDataCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamSenderonHasStreamDataCall) DoAndReturn(f func(protocol.StreamID, sendStreamI)) *MockStreamSenderonHasStreamDataCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// onStreamCompleted mocks base method.\nfunc (m *MockStreamSender) onStreamCompleted(arg0 protocol.StreamID) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"onStreamCompleted\", arg0)\n}\n\n// onStreamCompleted indicates an expected call of onStreamCompleted.\nfunc (mr *MockStreamSenderMockRecorder) onStreamCompleted(arg0 any) *MockStreamSenderonStreamCompletedCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"onStreamCompleted\", reflect.TypeOf((*MockStreamSender)(nil).onStreamCompleted), arg0)\n\treturn &MockStreamSenderonStreamCompletedCall{Call: call}\n}\n\n// MockStreamSenderonStreamCompletedCall wrap *gomock.Call\ntype MockStreamSenderonStreamCompletedCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockStreamSenderonStreamCompletedCall) Return() *MockStreamSenderonStreamCompletedCall {\n\tc.Call = c.Call.Return()\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockStreamSenderonStreamCompletedCall) Do(f func(protocol.StreamID)) *MockStreamSenderonStreamCompletedCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockStreamSenderonStreamCompletedCall) DoAndReturn(f func(protocol.StreamID)) *MockStreamSenderonStreamCompletedCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mock_unpacker_test.go",
          "type": "blob",
          "size": 4.4765625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/quic-go/quic-go (interfaces: Unpacker)\n//\n// Generated by this command:\n//\n//\tmockgen -typed -build_flags=-tags=gomock -package quic -self_package github.com/quic-go/quic-go -destination mock_unpacker_test.go github.com/quic-go/quic-go Unpacker\n//\n\n// Package quic is a generated GoMock package.\npackage quic\n\nimport (\n\treflect \"reflect\"\n\ttime \"time\"\n\n\tprotocol \"github.com/quic-go/quic-go/internal/protocol\"\n\twire \"github.com/quic-go/quic-go/internal/wire\"\n\tgomock \"go.uber.org/mock/gomock\"\n)\n\n// MockUnpacker is a mock of Unpacker interface.\ntype MockUnpacker struct {\n\tctrl     *gomock.Controller\n\trecorder *MockUnpackerMockRecorder\n\tisgomock struct{}\n}\n\n// MockUnpackerMockRecorder is the mock recorder for MockUnpacker.\ntype MockUnpackerMockRecorder struct {\n\tmock *MockUnpacker\n}\n\n// NewMockUnpacker creates a new mock instance.\nfunc NewMockUnpacker(ctrl *gomock.Controller) *MockUnpacker {\n\tmock := &MockUnpacker{ctrl: ctrl}\n\tmock.recorder = &MockUnpackerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockUnpacker) EXPECT() *MockUnpackerMockRecorder {\n\treturn m.recorder\n}\n\n// UnpackLongHeader mocks base method.\nfunc (m *MockUnpacker) UnpackLongHeader(hdr *wire.Header, data []byte) (*unpackedPacket, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UnpackLongHeader\", hdr, data)\n\tret0, _ := ret[0].(*unpackedPacket)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// UnpackLongHeader indicates an expected call of UnpackLongHeader.\nfunc (mr *MockUnpackerMockRecorder) UnpackLongHeader(hdr, data any) *MockUnpackerUnpackLongHeaderCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UnpackLongHeader\", reflect.TypeOf((*MockUnpacker)(nil).UnpackLongHeader), hdr, data)\n\treturn &MockUnpackerUnpackLongHeaderCall{Call: call}\n}\n\n// MockUnpackerUnpackLongHeaderCall wrap *gomock.Call\ntype MockUnpackerUnpackLongHeaderCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockUnpackerUnpackLongHeaderCall) Return(arg0 *unpackedPacket, arg1 error) *MockUnpackerUnpackLongHeaderCall {\n\tc.Call = c.Call.Return(arg0, arg1)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockUnpackerUnpackLongHeaderCall) Do(f func(*wire.Header, []byte) (*unpackedPacket, error)) *MockUnpackerUnpackLongHeaderCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockUnpackerUnpackLongHeaderCall) DoAndReturn(f func(*wire.Header, []byte) (*unpackedPacket, error)) *MockUnpackerUnpackLongHeaderCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n\n// UnpackShortHeader mocks base method.\nfunc (m *MockUnpacker) UnpackShortHeader(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"UnpackShortHeader\", rcvTime, data)\n\tret0, _ := ret[0].(protocol.PacketNumber)\n\tret1, _ := ret[1].(protocol.PacketNumberLen)\n\tret2, _ := ret[2].(protocol.KeyPhaseBit)\n\tret3, _ := ret[3].([]byte)\n\tret4, _ := ret[4].(error)\n\treturn ret0, ret1, ret2, ret3, ret4\n}\n\n// UnpackShortHeader indicates an expected call of UnpackShortHeader.\nfunc (mr *MockUnpackerMockRecorder) UnpackShortHeader(rcvTime, data any) *MockUnpackerUnpackShortHeaderCall {\n\tmr.mock.ctrl.T.Helper()\n\tcall := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"UnpackShortHeader\", reflect.TypeOf((*MockUnpacker)(nil).UnpackShortHeader), rcvTime, data)\n\treturn &MockUnpackerUnpackShortHeaderCall{Call: call}\n}\n\n// MockUnpackerUnpackShortHeaderCall wrap *gomock.Call\ntype MockUnpackerUnpackShortHeaderCall struct {\n\t*gomock.Call\n}\n\n// Return rewrite *gomock.Call.Return\nfunc (c *MockUnpackerUnpackShortHeaderCall) Return(arg0 protocol.PacketNumber, arg1 protocol.PacketNumberLen, arg2 protocol.KeyPhaseBit, arg3 []byte, arg4 error) *MockUnpackerUnpackShortHeaderCall {\n\tc.Call = c.Call.Return(arg0, arg1, arg2, arg3, arg4)\n\treturn c\n}\n\n// Do rewrite *gomock.Call.Do\nfunc (c *MockUnpackerUnpackShortHeaderCall) Do(f func(time.Time, []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error)) *MockUnpackerUnpackShortHeaderCall {\n\tc.Call = c.Call.Do(f)\n\treturn c\n}\n\n// DoAndReturn rewrite *gomock.Call.DoAndReturn\nfunc (c *MockUnpackerUnpackShortHeaderCall) DoAndReturn(f func(time.Time, []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error)) *MockUnpackerUnpackShortHeaderCall {\n\tc.Call = c.Call.DoAndReturn(f)\n\treturn c\n}\n"
        },
        {
          "name": "mockgen.go",
          "type": "blob",
          "size": 5.2919921875,
          "content": "//go:build gomock || generate\n\npackage quic\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_send_conn_test.go github.com/quic-go/quic-go SendConn\"\ntype SendConn = sendConn\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_raw_conn_test.go github.com/quic-go/quic-go RawConn\"\ntype RawConn = rawConn\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_sender_test.go github.com/quic-go/quic-go Sender\"\ntype Sender = sender\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_internal_test.go github.com/quic-go/quic-go StreamI\"\ntype StreamI = streamI\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_receive_stream_internal_test.go github.com/quic-go/quic-go ReceiveStreamI\"\ntype ReceiveStreamI = receiveStreamI\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_send_stream_internal_test.go github.com/quic-go/quic-go SendStreamI\"\ntype SendStreamI = sendStreamI\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_sender_test.go github.com/quic-go/quic-go StreamSender\"\ntype StreamSender = streamSender\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_control_frame_getter_test.go github.com/quic-go/quic-go StreamControlFrameGetter\"\ntype StreamControlFrameGetter = streamControlFrameGetter\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_frame_source_test.go github.com/quic-go/quic-go FrameSource\"\ntype FrameSource = frameSource\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_ack_frame_source_test.go github.com/quic-go/quic-go AckFrameSource\"\ntype AckFrameSource = ackFrameSource\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_stream_manager_test.go github.com/quic-go/quic-go StreamManager\"\ntype StreamManager = streamManager\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_sealing_manager_test.go github.com/quic-go/quic-go SealingManager\"\ntype SealingManager = sealingManager\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_unpacker_test.go github.com/quic-go/quic-go Unpacker\"\ntype Unpacker = unpacker\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_packer_test.go github.com/quic-go/quic-go Packer\"\ntype Packer = packer\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_mtu_discoverer_test.go github.com/quic-go/quic-go MTUDiscoverer\"\ntype MTUDiscoverer = mtuDiscoverer\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_conn_runner_test.go github.com/quic-go/quic-go ConnRunner\"\ntype ConnRunner = connRunner\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_quic_conn_test.go github.com/quic-go/quic-go QUICConn\"\ntype QUICConn = quicConn\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_packet_handler_test.go github.com/quic-go/quic-go PacketHandler\"\ntype PacketHandler = packetHandler\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_packet_handler_manager_test.go github.com/quic-go/quic-go PacketHandlerManager\"\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -build_flags=\\\"-tags=gomock\\\" -package quic -self_package github.com/quic-go/quic-go -destination mock_packet_handler_manager_test.go github.com/quic-go/quic-go PacketHandlerManager\"\ntype PacketHandlerManager = packetHandlerManager\n\n//go:generate sh -c \"go run go.uber.org/mock/mockgen -typed -package quic -self_package github.com/quic-go/quic-go -self_package github.com/quic-go/quic-go -destination mock_packetconn_test.go net PacketConn\"\n"
        },
        {
          "name": "mtu_discoverer.go",
          "type": "blob",
          "size": 7.1572265625,
          "content": "package quic\n\nimport (\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\ntype mtuDiscoverer interface {\n\t// Start starts the MTU discovery process.\n\t// It's unnecessary to call ShouldSendProbe before that.\n\tStart()\n\tShouldSendProbe(now time.Time) bool\n\tCurrentSize() protocol.ByteCount\n\tGetPing() (ping ackhandler.Frame, datagramSize protocol.ByteCount)\n}\n\nconst (\n\t// At some point, we have to stop searching for a higher MTU.\n\t// We're happy to send a packet that's 10 bytes smaller than the actual MTU.\n\tmaxMTUDiff = 20\n\t// send a probe packet every mtuProbeDelay RTTs\n\tmtuProbeDelay = 5\n\t// Once maxLostMTUProbes MTU probe packets larger than a certain size are lost,\n\t// MTU discovery won't probe for larger MTUs than this size.\n\t// The algorithm used here is resilient to packet loss of (maxLostMTUProbes - 1) packets.\n\tmaxLostMTUProbes = 3\n)\n\n// The Path MTU is found by sending a larger packet every now and then.\n// If the packet is acknowledged, we conclude that the path supports this larger packet size.\n// If the packet is lost, this can mean one of two things:\n//   1. The path doesn't support this larger packet size, or\n//   2. The packet was lost due to packet loss, independent of its size.\n// The algorithm used here is resilient to packet loss of (maxLostMTUProbes - 1) packets.\n// For simplicty, the following example use maxLostMTUProbes = 2.\n//\n// Initialization:\n//    |------------------------------------------------------------------------------|\n//   min                                                                            max\n//\n// The first MTU probe packet will have size (min+max)/2.\n// Assume that this packet is acknowledged. We can now move the min marker,\n// and continue the search in the resulting interval.\n//\n// If 1st probe packet acknowledged:\n//    |---------------------------------------|--------------------------------------|\n//                                           min                                    max\n//\n// If 1st probe packet lost:\n//    |---------------------------------------|--------------------------------------|\n//   min                                    lost[0]                                 max\n//\n// We can't conclude that the path doesn't support this packet size, since the loss of the probe\n// packet could have been unrelated to the packet size.  A larger probe packet will be sent later on.\n// After a loss, the next probe packet has size (min+lost[0])/2.\n// Now assume this probe packet is acknowledged:\n//\n// 2nd probe packet acknowledged:\n//    |------------------|--------------------|--------------------------------------|\n//                      min                lost[0]                                  max\n//\n// First of all, we conclude that the path supports at least this MTU. That's progress!\n// Second, we probe a bit more aggressively with the next probe packet:\n// After an acknowledgement, the next probe packet has size (min+max)/2.\n// This means we'll send a packet larger than the first probe packet (which was lost).\n//\n// If 3rd probe packet acknowledged:\n//    |-------------------------------------------------|----------------------------|\n//                                                     min                          max\n//\n// We can conclude that the loss of the 1st probe packet was not due to its size, and\n// continue searching in a much smaller interval now.\n//\n// If 3rd probe packet lost:\n//    |------------------|--------------------|---------|----------------------------|\n//                      min                lost[0]     max\n//\n// Since in our example numPTOProbes = 2, and we lost 2 packets smaller than max, we\n// conclude that this packet size is not supported on the path, and reduce the maximum\n// value of the search interval.\n//\n// MTU discovery concludes once the interval min and max has been narrowed down to maxMTUDiff.\n\ntype mtuFinder struct {\n\tlastProbeTime time.Time\n\tmtuIncreased  func(protocol.ByteCount)\n\n\trttStats *utils.RTTStats\n\n\tinFlight protocol.ByteCount // the size of the probe packet currently in flight. InvalidByteCount if none is in flight\n\tmin      protocol.ByteCount\n\tlimit    protocol.ByteCount\n\n\t// on initialization, we treat the maximum size as the first \"lost\" packet\n\tlost             [maxLostMTUProbes]protocol.ByteCount\n\tlastProbeWasLost bool\n\n\ttracer *logging.ConnectionTracer\n}\n\nvar _ mtuDiscoverer = &mtuFinder{}\n\nfunc newMTUDiscoverer(\n\trttStats *utils.RTTStats,\n\tstart, max protocol.ByteCount,\n\tmtuIncreased func(protocol.ByteCount),\n\ttracer *logging.ConnectionTracer,\n) *mtuFinder {\n\tf := &mtuFinder{\n\t\tinFlight:     protocol.InvalidByteCount,\n\t\tmin:          start,\n\t\tlimit:        max,\n\t\trttStats:     rttStats,\n\t\tmtuIncreased: mtuIncreased,\n\t\ttracer:       tracer,\n\t}\n\tfor i := range f.lost {\n\t\tif i == 0 {\n\t\t\tf.lost[i] = max\n\t\t\tcontinue\n\t\t}\n\t\tf.lost[i] = protocol.InvalidByteCount\n\t}\n\treturn f\n}\n\nfunc (f *mtuFinder) done() bool {\n\treturn f.max()-f.min <= maxMTUDiff+1\n}\n\nfunc (f *mtuFinder) max() protocol.ByteCount {\n\tfor i, v := range f.lost {\n\t\tif v == protocol.InvalidByteCount {\n\t\t\treturn f.lost[i-1]\n\t\t}\n\t}\n\treturn f.lost[len(f.lost)-1]\n}\n\nfunc (f *mtuFinder) Start() {\n\tf.lastProbeTime = time.Now() // makes sure the first probe packet is not sent immediately\n}\n\nfunc (f *mtuFinder) ShouldSendProbe(now time.Time) bool {\n\tif f.lastProbeTime.IsZero() {\n\t\treturn false\n\t}\n\tif f.inFlight != protocol.InvalidByteCount || f.done() {\n\t\treturn false\n\t}\n\treturn !now.Before(f.lastProbeTime.Add(mtuProbeDelay * f.rttStats.SmoothedRTT()))\n}\n\nfunc (f *mtuFinder) GetPing() (ackhandler.Frame, protocol.ByteCount) {\n\tvar size protocol.ByteCount\n\tif f.lastProbeWasLost {\n\t\tsize = (f.min + f.lost[0]) / 2\n\t} else {\n\t\tsize = (f.min + f.max()) / 2\n\t}\n\tf.lastProbeTime = time.Now()\n\tf.inFlight = size\n\treturn ackhandler.Frame{\n\t\tFrame:   &wire.PingFrame{},\n\t\tHandler: &mtuFinderAckHandler{f},\n\t}, size\n}\n\nfunc (f *mtuFinder) CurrentSize() protocol.ByteCount {\n\treturn f.min\n}\n\ntype mtuFinderAckHandler struct {\n\t*mtuFinder\n}\n\nvar _ ackhandler.FrameHandler = &mtuFinderAckHandler{}\n\nfunc (h *mtuFinderAckHandler) OnAcked(wire.Frame) {\n\tsize := h.inFlight\n\tif size == protocol.InvalidByteCount {\n\t\tpanic(\"OnAcked callback called although there's no MTU probe packet in flight\")\n\t}\n\th.inFlight = protocol.InvalidByteCount\n\th.min = size\n\th.lastProbeWasLost = false\n\t// remove all values smaller than size from the lost array\n\tvar j int\n\tfor i, v := range h.lost {\n\t\tif size < v {\n\t\t\tj = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif j > 0 {\n\t\tfor i := 0; i < len(h.lost); i++ {\n\t\t\tif i+j < len(h.lost) {\n\t\t\t\th.lost[i] = h.lost[i+j]\n\t\t\t} else {\n\t\t\t\th.lost[i] = protocol.InvalidByteCount\n\t\t\t}\n\t\t}\n\t}\n\tif h.tracer != nil && h.tracer.UpdatedMTU != nil {\n\t\th.tracer.UpdatedMTU(size, h.done())\n\t}\n\th.mtuIncreased(size)\n}\n\nfunc (h *mtuFinderAckHandler) OnLost(wire.Frame) {\n\tsize := h.inFlight\n\tif size == protocol.InvalidByteCount {\n\t\tpanic(\"OnLost callback called although there's no MTU probe packet in flight\")\n\t}\n\th.lastProbeWasLost = true\n\th.inFlight = protocol.InvalidByteCount\n\tfor i, v := range h.lost {\n\t\tif size < v {\n\t\t\tcopy(h.lost[i+1:], h.lost[i:])\n\t\t\th.lost[i] = size\n\t\t\tbreak\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "mtu_discoverer_test.go",
          "type": "blob",
          "size": 5.8779296875,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"MTU Discoverer\", func() {\n\tconst (\n\t\trtt                         = 100 * time.Millisecond\n\t\tstartMTU protocol.ByteCount = 1000\n\t\tmaxMTU   protocol.ByteCount = 2000\n\t)\n\n\tvar (\n\t\td             *mtuFinder\n\t\trttStats      *utils.RTTStats\n\t\tnow           time.Time\n\t\tdiscoveredMTU protocol.ByteCount\n\t)\n\tr := rand.New(rand.NewSource(uint64(GinkgoRandomSeed())))\n\n\tBeforeEach(func() {\n\t\trttStats = &utils.RTTStats{}\n\t\trttStats.SetInitialRTT(rtt)\n\t\tExpect(rttStats.SmoothedRTT()).To(Equal(rtt))\n\t\td = newMTUDiscoverer(\n\t\t\trttStats,\n\t\t\tstartMTU,\n\t\t\tmaxMTU,\n\t\t\tfunc(s protocol.ByteCount) { discoveredMTU = s },\n\t\t\tnil,\n\t\t)\n\t\td.Start()\n\t\tnow = time.Now()\n\t})\n\n\tIt(\"only allows a probe 5 RTTs after the handshake completes\", func() {\n\t\tExpect(d.ShouldSendProbe(now)).To(BeFalse())\n\t\tExpect(d.ShouldSendProbe(now.Add(rtt * 9 / 2))).To(BeFalse())\n\t\tExpect(d.ShouldSendProbe(now.Add(rtt * 5))).To(BeTrue())\n\t})\n\n\tIt(\"doesn't allow a probe if another probe is still in flight\", func() {\n\t\tping, _ := d.GetPing()\n\t\tExpect(d.ShouldSendProbe(now.Add(10 * rtt))).To(BeFalse())\n\t\tping.Handler.OnLost(ping.Frame)\n\t\tExpect(d.ShouldSendProbe(now.Add(10 * rtt))).To(BeTrue())\n\t})\n\n\tIt(\"tries a lower size when a probe is lost\", func() {\n\t\tping, size := d.GetPing()\n\t\tExpect(size).To(Equal(protocol.ByteCount(1500)))\n\t\tping.Handler.OnLost(ping.Frame)\n\t\t_, size = d.GetPing()\n\t\tExpect(size).To(Equal(protocol.ByteCount(1250)))\n\t})\n\n\tIt(\"tries a higher size and calls the callback when a probe is acknowledged\", func() {\n\t\tping, size := d.GetPing()\n\t\tExpect(size).To(Equal(protocol.ByteCount(1500)))\n\t\tping.Handler.OnAcked(ping.Frame)\n\t\tExpect(discoveredMTU).To(Equal(protocol.ByteCount(1500)))\n\t\t_, size = d.GetPing()\n\t\tExpect(size).To(Equal(protocol.ByteCount(1750)))\n\t})\n\n\tIt(\"stops discovery after getting close enough to the MTU\", func() {\n\t\tvar sizes []protocol.ByteCount\n\t\tt := now.Add(5 * rtt)\n\t\tfor d.ShouldSendProbe(t) {\n\t\t\tping, size := d.GetPing()\n\t\t\tfmt.Println(\"sending\", size)\n\t\t\tping.Handler.OnAcked(ping.Frame)\n\t\t\tsizes = append(sizes, size)\n\t\t\tt = t.Add(5 * rtt)\n\t\t}\n\t\tExpect(sizes).To(Equal([]protocol.ByteCount{1500, 1750, 1875, 1937, 1968, 1984}))\n\t\tExpect(d.ShouldSendProbe(t.Add(10 * rtt))).To(BeFalse())\n\t})\n\n\tIt(\"doesn't do discovery before being started\", func() {\n\t\td := newMTUDiscoverer(rttStats, startMTU, protocol.MaxByteCount, func(s protocol.ByteCount) {}, nil)\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tExpect(d.ShouldSendProbe(time.Now())).To(BeFalse())\n\t\t}\n\t})\n\n\tIt(\"finds the MTU\", MustPassRepeatedly(300), func() {\n\t\tmaxMTU := protocol.ByteCount(r.Intn(int(3000-startMTU))) + startMTU + 1\n\t\tcurrentMTU := startMTU\n\t\tvar tracedMTU protocol.ByteCount\n\t\tvar tracerDone bool\n\t\td := newMTUDiscoverer(\n\t\t\trttStats,\n\t\t\tstartMTU,\n\t\t\tmaxMTU,\n\t\t\tfunc(s protocol.ByteCount) { currentMTU = s },\n\t\t\t&logging.ConnectionTracer{\n\t\t\t\tUpdatedMTU: func(mtu logging.ByteCount, done bool) {\n\t\t\t\t\ttracedMTU = mtu\n\t\t\t\t\ttracerDone = done\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\td.Start()\n\t\tnow := time.Now()\n\t\trealMTU := protocol.ByteCount(r.Intn(int(maxMTU-startMTU))) + startMTU\n\t\tfmt.Fprintf(GinkgoWriter, \"MTU: %d, max: %d\\n\", realMTU, maxMTU)\n\t\tt := now.Add(mtuProbeDelay * rtt)\n\t\tvar probes []protocol.ByteCount\n\t\tfor d.ShouldSendProbe(t) {\n\t\t\tif len(probes) > 24 {\n\t\t\t\tFail(fmt.Sprintf(\"too many iterations: %v\", probes))\n\t\t\t}\n\t\t\tping, size := d.GetPing()\n\t\t\tprobes = append(probes, size)\n\t\t\tif size <= realMTU {\n\t\t\t\tping.Handler.OnAcked(ping.Frame)\n\t\t\t} else {\n\t\t\t\tping.Handler.OnLost(ping.Frame)\n\t\t\t}\n\t\t\tt = t.Add(mtuProbeDelay * rtt)\n\t\t}\n\t\tdiff := realMTU - currentMTU\n\t\tExpect(diff).To(BeNumerically(\">=\", 0))\n\t\tif maxMTU > currentMTU+maxMTU {\n\t\t\tExpect(tracedMTU).To(Equal(currentMTU))\n\t\t\tExpect(tracerDone).To(BeTrue())\n\t\t}\n\t\tfmt.Fprintf(GinkgoWriter, \"MTU discovered: %d (diff: %d)\\n\", currentMTU, diff)\n\t\tfmt.Fprintf(GinkgoWriter, \"probes sent (%d): %v\\n\", len(probes), probes)\n\t\tExpect(diff).To(BeNumerically(\"<=\", maxMTUDiff))\n\t})\n\n\tconst maxRandomLoss = maxLostMTUProbes - 1\n\tIt(fmt.Sprintf(\"finds the MTU, with up to %d packets lost\", maxRandomLoss), MustPassRepeatedly(500), func() {\n\t\tmaxMTU := protocol.ByteCount(r.Intn(int(3000-startMTU))) + startMTU + 1\n\t\tcurrentMTU := startMTU\n\t\tvar tracedMTU protocol.ByteCount\n\t\tvar tracerDone bool\n\t\td := newMTUDiscoverer(\n\t\t\trttStats,\n\t\t\tstartMTU,\n\t\t\tmaxMTU,\n\t\t\tfunc(s protocol.ByteCount) { currentMTU = s },\n\t\t\t&logging.ConnectionTracer{\n\t\t\t\tUpdatedMTU: func(mtu logging.ByteCount, done bool) {\n\t\t\t\t\ttracedMTU = mtu\n\t\t\t\t\ttracerDone = done\n\t\t\t\t},\n\t\t\t},\n\t\t)\n\t\td.Start()\n\t\tnow := time.Now()\n\t\trealMTU := protocol.ByteCount(r.Intn(int(maxMTU-startMTU))) + startMTU\n\t\tfmt.Fprintf(GinkgoWriter, \"MTU: %d, max: %d\\n\", realMTU, maxMTU)\n\t\tt := now.Add(mtuProbeDelay * rtt)\n\t\tvar probes, randomLosses []protocol.ByteCount\n\t\tfor d.ShouldSendProbe(t) {\n\t\t\tif len(probes) > 32 {\n\t\t\t\tFail(fmt.Sprintf(\"too many iterations: %v\", probes))\n\t\t\t}\n\t\t\tping, size := d.GetPing()\n\t\t\tprobes = append(probes, size)\n\t\t\tpacketFits := size <= realMTU\n\t\t\tvar acked bool\n\t\t\tif packetFits {\n\t\t\t\trandomLoss := r.Intn(maxLostMTUProbes) == 0 && len(randomLosses) < maxRandomLoss\n\t\t\t\tif randomLoss {\n\t\t\t\t\trandomLosses = append(randomLosses, size)\n\t\t\t\t} else {\n\t\t\t\t\tping.Handler.OnAcked(ping.Frame)\n\t\t\t\t\tacked = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !acked {\n\t\t\t\tping.Handler.OnLost(ping.Frame)\n\t\t\t}\n\t\t\tt = t.Add(mtuProbeDelay * rtt)\n\t\t}\n\t\tdiff := realMTU - currentMTU\n\t\tExpect(diff).To(BeNumerically(\">=\", 0))\n\t\tif maxMTU > currentMTU+maxMTU {\n\t\t\tExpect(tracedMTU).To(Equal(currentMTU))\n\t\t\tExpect(tracerDone).To(BeTrue())\n\t\t}\n\t\tfmt.Fprintf(GinkgoWriter, \"MTU discovered with random losses %v: %d (diff: %d)\\n\", randomLosses, currentMTU, diff)\n\t\tfmt.Fprintf(GinkgoWriter, \"probes sent (%d): %v\\n\", len(probes), probes)\n\t\tExpect(diff).To(BeNumerically(\"<=\", maxMTUDiff))\n\t})\n})\n"
        },
        {
          "name": "oss-fuzz.sh",
          "type": "blob",
          "size": 1.4599609375,
          "content": "#!/bin/bash\n\n# Install Go manually, since oss-fuzz ships with an outdated Go version.\n# See https://github.com/google/oss-fuzz/pull/10643.\nexport CXX=\"${CXX} -lresolv\" # required by Go 1.20\nwget https://go.dev/dl/go1.23.0.linux-amd64.tar.gz \\\n  && mkdir temp-go \\\n  && rm -rf /root/.go/* \\\n  && tar -C temp-go/ -xzf go1.23.0.linux-amd64.tar.gz \\\n  && mv temp-go/go/* /root/.go/ \\\n  && rm -rf temp-go go1.23.0.linux-amd64.tar.gz\n\n(\n# fuzz qpack\ncompile_go_fuzzer github.com/quic-go/qpack/fuzzing Fuzz qpack_fuzzer\n)\n\n(\n# fuzz quic-go\ncompile_go_fuzzer github.com/quic-go/quic-go/fuzzing/frames Fuzz frame_fuzzer\ncompile_go_fuzzer github.com/quic-go/quic-go/fuzzing/header Fuzz header_fuzzer\ncompile_go_fuzzer github.com/quic-go/quic-go/fuzzing/transportparameters Fuzz transportparameter_fuzzer\ncompile_go_fuzzer github.com/quic-go/quic-go/fuzzing/tokens Fuzz token_fuzzer\ncompile_go_fuzzer github.com/quic-go/quic-go/fuzzing/handshake Fuzz handshake_fuzzer\n\nif [ $SANITIZER == \"coverage\" ]; then\n    # no need for corpora if coverage\n    exit 0\nfi\n\n# generate seed corpora\ncd $GOPATH/src/github.com/quic-go/quic-go/\ngo generate -x ./fuzzing/...\n\nzip --quiet -r $OUT/header_fuzzer_seed_corpus.zip fuzzing/header/corpus\nzip --quiet -r $OUT/frame_fuzzer_seed_corpus.zip fuzzing/frames/corpus\nzip --quiet -r $OUT/transportparameter_fuzzer_seed_corpus.zip fuzzing/transportparameters/corpus\nzip --quiet -r $OUT/handshake_fuzzer_seed_corpus.zip fuzzing/handshake/corpus\n)\n\n# for debugging\nls -al $OUT\n"
        },
        {
          "name": "packet_handler_map.go",
          "type": "blob",
          "size": 6.796875,
          "content": "package quic\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\ntype connCapabilities struct {\n\t// This connection has the Don't Fragment (DF) bit set.\n\t// This means it makes to run DPLPMTUD.\n\tDF bool\n\t// GSO (Generic Segmentation Offload) supported\n\tGSO bool\n\t// ECN (Explicit Congestion Notifications) supported\n\tECN bool\n}\n\n// rawConn is a connection that allow reading of a receivedPackeh.\ntype rawConn interface {\n\tReadPacket() (receivedPacket, error)\n\t// WritePacket writes a packet on the wire.\n\t// gsoSize is the size of a single packet, or 0 to disable GSO.\n\t// It is invalid to set gsoSize if capabilities.GSO is not set.\n\tWritePacket(b []byte, addr net.Addr, packetInfoOOB []byte, gsoSize uint16, ecn protocol.ECN) (int, error)\n\tLocalAddr() net.Addr\n\tSetReadDeadline(time.Time) error\n\tio.Closer\n\n\tcapabilities() connCapabilities\n}\n\ntype closePacket struct {\n\tpayload []byte\n\taddr    net.Addr\n\tinfo    packetInfo\n}\n\ntype packetHandlerMap struct {\n\tmutex       sync.Mutex\n\thandlers    map[protocol.ConnectionID]packetHandler\n\tresetTokens map[protocol.StatelessResetToken] /* stateless reset token */ packetHandler\n\n\tclosed    bool\n\tcloseChan chan struct{}\n\n\tenqueueClosePacket func(closePacket)\n\n\tdeleteRetiredConnsAfter time.Duration\n\n\tstatelessResetMutex  sync.Mutex\n\tstatelessResetHasher hash.Hash\n\n\tlogger utils.Logger\n}\n\nvar _ packetHandlerManager = &packetHandlerMap{}\n\nfunc newPacketHandlerMap(key *StatelessResetKey, enqueueClosePacket func(closePacket), logger utils.Logger) *packetHandlerMap {\n\th := &packetHandlerMap{\n\t\tcloseChan:               make(chan struct{}),\n\t\thandlers:                make(map[protocol.ConnectionID]packetHandler),\n\t\tresetTokens:             make(map[protocol.StatelessResetToken]packetHandler),\n\t\tdeleteRetiredConnsAfter: protocol.RetiredConnectionIDDeleteTimeout,\n\t\tenqueueClosePacket:      enqueueClosePacket,\n\t\tlogger:                  logger,\n\t}\n\tif key != nil {\n\t\th.statelessResetHasher = hmac.New(sha256.New, key[:])\n\t}\n\tif h.logger.Debug() {\n\t\tgo h.logUsage()\n\t}\n\treturn h\n}\n\nfunc (h *packetHandlerMap) logUsage() {\n\tticker := time.NewTicker(2 * time.Second)\n\tvar printedZero bool\n\tfor {\n\t\tselect {\n\t\tcase <-h.closeChan:\n\t\t\treturn\n\t\tcase <-ticker.C:\n\t\t}\n\n\t\th.mutex.Lock()\n\t\tnumHandlers := len(h.handlers)\n\t\tnumTokens := len(h.resetTokens)\n\t\th.mutex.Unlock()\n\t\t// If the number tracked handlers and tokens is zero, only print it a single time.\n\t\thasZero := numHandlers == 0 && numTokens == 0\n\t\tif !hasZero || (hasZero && !printedZero) {\n\t\t\th.logger.Debugf(\"Tracking %d connection IDs and %d reset tokens.\\n\", numHandlers, numTokens)\n\t\t\tprintedZero = false\n\t\t\tif hasZero {\n\t\t\t\tprintedZero = true\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (h *packetHandlerMap) Get(id protocol.ConnectionID) (packetHandler, bool) {\n\th.mutex.Lock()\n\tdefer h.mutex.Unlock()\n\n\thandler, ok := h.handlers[id]\n\treturn handler, ok\n}\n\nfunc (h *packetHandlerMap) Add(id protocol.ConnectionID, handler packetHandler) bool /* was added */ {\n\th.mutex.Lock()\n\tdefer h.mutex.Unlock()\n\n\tif _, ok := h.handlers[id]; ok {\n\t\th.logger.Debugf(\"Not adding connection ID %s, as it already exists.\", id)\n\t\treturn false\n\t}\n\th.handlers[id] = handler\n\th.logger.Debugf(\"Adding connection ID %s.\", id)\n\treturn true\n}\n\nfunc (h *packetHandlerMap) AddWithConnID(clientDestConnID, newConnID protocol.ConnectionID, handler packetHandler) bool {\n\th.mutex.Lock()\n\tdefer h.mutex.Unlock()\n\n\tif _, ok := h.handlers[clientDestConnID]; ok {\n\t\th.logger.Debugf(\"Not adding connection ID %s for a new connection, as it already exists.\", clientDestConnID)\n\t\treturn false\n\t}\n\th.handlers[clientDestConnID] = handler\n\th.handlers[newConnID] = handler\n\th.logger.Debugf(\"Adding connection IDs %s and %s for a new connection.\", clientDestConnID, newConnID)\n\treturn true\n}\n\nfunc (h *packetHandlerMap) Remove(id protocol.ConnectionID) {\n\th.mutex.Lock()\n\tdelete(h.handlers, id)\n\th.mutex.Unlock()\n\th.logger.Debugf(\"Removing connection ID %s.\", id)\n}\n\nfunc (h *packetHandlerMap) Retire(id protocol.ConnectionID) {\n\th.logger.Debugf(\"Retiring connection ID %s in %s.\", id, h.deleteRetiredConnsAfter)\n\ttime.AfterFunc(h.deleteRetiredConnsAfter, func() {\n\t\th.mutex.Lock()\n\t\tdelete(h.handlers, id)\n\t\th.mutex.Unlock()\n\t\th.logger.Debugf(\"Removing connection ID %s after it has been retired.\", id)\n\t})\n}\n\n// ReplaceWithClosed is called when a connection is closed.\n// Depending on which side closed the connection, we need to:\n// * remote close: absorb delayed packets\n// * local close: retransmit the CONNECTION_CLOSE packet, in case it was lost\nfunc (h *packetHandlerMap) ReplaceWithClosed(ids []protocol.ConnectionID, connClosePacket []byte) {\n\tvar handler packetHandler\n\tif connClosePacket != nil {\n\t\thandler = newClosedLocalConn(\n\t\t\tfunc(addr net.Addr, info packetInfo) {\n\t\t\t\th.enqueueClosePacket(closePacket{payload: connClosePacket, addr: addr, info: info})\n\t\t\t},\n\t\t\th.logger,\n\t\t)\n\t} else {\n\t\thandler = newClosedRemoteConn()\n\t}\n\n\th.mutex.Lock()\n\tfor _, id := range ids {\n\t\th.handlers[id] = handler\n\t}\n\th.mutex.Unlock()\n\th.logger.Debugf(\"Replacing connection for connection IDs %s with a closed connection.\", ids)\n\n\ttime.AfterFunc(h.deleteRetiredConnsAfter, func() {\n\t\th.mutex.Lock()\n\t\tfor _, id := range ids {\n\t\t\tdelete(h.handlers, id)\n\t\t}\n\t\th.mutex.Unlock()\n\t\th.logger.Debugf(\"Removing connection IDs %s for a closed connection after it has been retired.\", ids)\n\t})\n}\n\nfunc (h *packetHandlerMap) AddResetToken(token protocol.StatelessResetToken, handler packetHandler) {\n\th.mutex.Lock()\n\th.resetTokens[token] = handler\n\th.mutex.Unlock()\n}\n\nfunc (h *packetHandlerMap) RemoveResetToken(token protocol.StatelessResetToken) {\n\th.mutex.Lock()\n\tdelete(h.resetTokens, token)\n\th.mutex.Unlock()\n}\n\nfunc (h *packetHandlerMap) GetByResetToken(token protocol.StatelessResetToken) (packetHandler, bool) {\n\th.mutex.Lock()\n\tdefer h.mutex.Unlock()\n\n\thandler, ok := h.resetTokens[token]\n\treturn handler, ok\n}\n\nfunc (h *packetHandlerMap) Close(e error) {\n\th.mutex.Lock()\n\n\tif h.closed {\n\t\th.mutex.Unlock()\n\t\treturn\n\t}\n\n\tclose(h.closeChan)\n\n\tvar wg sync.WaitGroup\n\tfor _, handler := range h.handlers {\n\t\twg.Add(1)\n\t\tgo func(handler packetHandler) {\n\t\t\thandler.destroy(e)\n\t\t\twg.Done()\n\t\t}(handler)\n\t}\n\th.closed = true\n\th.mutex.Unlock()\n\twg.Wait()\n}\n\nfunc (h *packetHandlerMap) GetStatelessResetToken(connID protocol.ConnectionID) protocol.StatelessResetToken {\n\tvar token protocol.StatelessResetToken\n\tif h.statelessResetHasher == nil {\n\t\t// Return a random stateless reset token.\n\t\t// This token will be sent in the server's transport parameters.\n\t\t// By using a random token, an off-path attacker won't be able to disrupt the connection.\n\t\trand.Read(token[:])\n\t\treturn token\n\t}\n\th.statelessResetMutex.Lock()\n\th.statelessResetHasher.Write(connID.Bytes())\n\tcopy(token[:], h.statelessResetHasher.Sum(nil))\n\th.statelessResetHasher.Reset()\n\th.statelessResetMutex.Unlock()\n\treturn token\n}\n"
        },
        {
          "name": "packet_handler_map_test.go",
          "type": "blob",
          "size": 5.962890625,
          "content": "package quic\n\nimport (\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestPacketHandlerMapAddAndRemove(t *testing.T) {\n\tm := newPacketHandlerMap(nil, nil, utils.DefaultLogger)\n\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\th := &mockPacketHandler{}\n\trequire.True(t, m.Add(connID, h))\n\tgot, ok := m.Get(connID)\n\trequire.True(t, ok)\n\trequire.Equal(t, h, got)\n\n\t// cannot add the same handler twice\n\trequire.False(t, m.Add(connID, h))\n\tgot, ok = m.Get(connID)\n\trequire.True(t, ok)\n\trequire.Equal(t, h, got)\n\n\t// remove the handler\n\tm.Remove(connID)\n\tgot, ok = m.Get(connID)\n\trequire.False(t, ok)\n\trequire.Nil(t, got)\n}\n\nfunc TestPacketHandlerMapAddWithClientChosenConnID(t *testing.T) {\n\tm := newPacketHandlerMap(nil, nil, utils.DefaultLogger)\n\th := &mockPacketHandler{}\n\n\tconnID1 := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\tconnID2 := protocol.ParseConnectionID([]byte{4, 3, 2, 1})\n\trequire.True(t, m.AddWithConnID(connID1, connID2, h))\n\t// collision of the connection ID, this handler should not be added\n\trequire.False(t, m.AddWithConnID(connID1, protocol.ParseConnectionID([]byte{1, 2, 3}), nil))\n\n\tgot, ok := m.Get(connID1)\n\trequire.True(t, ok)\n\trequire.Equal(t, h, got)\n\tgot, ok = m.Get(connID2)\n\trequire.True(t, ok)\n\trequire.Equal(t, h, got)\n}\n\nfunc TestPacketHandlerMapRetire(t *testing.T) {\n\tm := newPacketHandlerMap(nil, nil, utils.DefaultLogger)\n\tdur := scaleDuration(10 * time.Millisecond)\n\tm.deleteRetiredConnsAfter = dur\n\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\th := &mockPacketHandler{}\n\trequire.True(t, m.Add(connID, h))\n\tm.Retire(connID)\n\n\t// immediately after retiring, the handler should still be there\n\tgot, ok := m.Get(connID)\n\trequire.True(t, ok)\n\trequire.Equal(t, h, got)\n\n\t// after the timeout, the handler should be removed\n\ttime.Sleep(dur)\n\trequire.Eventually(t, func() bool {\n\t\t_, ok := m.Get(connID)\n\t\treturn !ok\n\t}, dur, dur/10)\n}\n\nfunc TestPacketHandlerMapAddGetRemoveResetTokens(t *testing.T) {\n\tm := newPacketHandlerMap(nil, nil, utils.DefaultLogger)\n\ttoken := protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf}\n\thandler := &mockPacketHandler{}\n\tm.AddResetToken(token, handler)\n\th, ok := m.GetByResetToken(token)\n\trequire.True(t, ok)\n\trequire.Equal(t, handler, h)\n\tm.RemoveResetToken(token)\n\t_, ok = m.GetByResetToken(token)\n\trequire.False(t, ok)\n}\n\nfunc TestPacketHandlerMapGenerateStatelessResetToken(t *testing.T) {\n\tt.Run(\"no key\", func(t *testing.T) {\n\t\tm := newPacketHandlerMap(nil, nil, utils.DefaultLogger)\n\t\tb := make([]byte, 8)\n\t\trand.Read(b)\n\t\tconnID := protocol.ParseConnectionID(b)\n\t\ttokens := make(map[protocol.StatelessResetToken]struct{})\n\t\tfor i := 0; i < 100; i++ {\n\t\t\ttoken := m.GetStatelessResetToken(connID)\n\t\t\trequire.NotZero(t, token)\n\t\t\tif _, ok := tokens[token]; ok {\n\t\t\t\tt.Fatalf(\"token %s already exists\", token)\n\t\t\t}\n\t\t\ttokens[token] = struct{}{}\n\t\t}\n\t})\n\n\tt.Run(\"with key\", func(t *testing.T) {\n\t\tvar key StatelessResetKey\n\t\trand.Read(key[:])\n\t\tm := newPacketHandlerMap(&key, nil, utils.DefaultLogger)\n\t\tb := make([]byte, 8)\n\t\trand.Read(b)\n\t\tconnID := protocol.ParseConnectionID(b)\n\t\ttoken := m.GetStatelessResetToken(connID)\n\t\trequire.NotZero(t, token)\n\t\trequire.Equal(t, token, m.GetStatelessResetToken(connID))\n\t\t// generate a new connection ID\n\t\trand.Read(b)\n\t\tconnID2 := protocol.ParseConnectionID(b)\n\t\trequire.NotEqual(t, token, m.GetStatelessResetToken(connID2))\n\t})\n}\n\nfunc TestPacketHandlerMapReplaceWithLocalClosed(t *testing.T) {\n\tvar closePackets []closePacket\n\tm := newPacketHandlerMap(nil, func(p closePacket) { closePackets = append(closePackets, p) }, utils.DefaultLogger)\n\tdur := scaleDuration(10 * time.Millisecond)\n\tm.deleteRetiredConnsAfter = dur\n\n\thandler := &mockPacketHandler{}\n\tconnID := protocol.ParseConnectionID([]byte{4, 3, 2, 1})\n\trequire.True(t, m.Add(connID, handler))\n\tm.ReplaceWithClosed([]protocol.ConnectionID{connID}, []byte(\"foobar\"))\n\th, ok := m.Get(connID)\n\trequire.True(t, ok)\n\trequire.NotEqual(t, handler, h)\n\taddr := &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 1234}\n\th.handlePacket(receivedPacket{remoteAddr: addr})\n\trequire.Len(t, closePackets, 1)\n\trequire.Equal(t, addr, closePackets[0].addr)\n\trequire.Equal(t, []byte(\"foobar\"), closePackets[0].payload)\n\n\ttime.Sleep(dur)\n\trequire.Eventually(t, func() bool {\n\t\t_, ok := m.Get(connID)\n\t\treturn !ok\n\t}, time.Second, 10*time.Millisecond)\n}\n\nfunc TestPacketHandlerMapReplaceWithRemoteClosed(t *testing.T) {\n\tvar closePackets []closePacket\n\tm := newPacketHandlerMap(nil, func(p closePacket) { closePackets = append(closePackets, p) }, utils.DefaultLogger)\n\tdur := scaleDuration(50 * time.Millisecond)\n\tm.deleteRetiredConnsAfter = dur\n\n\thandler := &mockPacketHandler{}\n\tconnID := protocol.ParseConnectionID([]byte{4, 3, 2, 1})\n\trequire.True(t, m.Add(connID, handler))\n\tm.ReplaceWithClosed([]protocol.ConnectionID{connID}, nil)\n\th, ok := m.Get(connID)\n\trequire.True(t, ok)\n\trequire.NotEqual(t, handler, h)\n\taddr := &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 1234}\n\th.handlePacket(receivedPacket{remoteAddr: addr})\n\trequire.Empty(t, closePackets)\n\n\ttime.Sleep(dur)\n\trequire.Eventually(t, func() bool {\n\t\t_, ok := m.Get(connID)\n\t\treturn !ok\n\t}, time.Second, 10*time.Millisecond)\n}\n\nfunc TestPacketHandlerMapClose(t *testing.T) {\n\tm := newPacketHandlerMap(nil, nil, utils.DefaultLogger)\n\ttestErr := errors.New(\"shutdown\")\n\tconst numConns = 10\n\tdestroyChan := make(chan error, 2*numConns)\n\tfor i := 0; i < numConns; i++ {\n\t\tconn := &mockPacketHandler{destruction: destroyChan}\n\t\tb := make([]byte, 12)\n\t\trand.Read(b)\n\t\tm.Add(protocol.ParseConnectionID(b), conn)\n\t}\n\tm.Close(testErr)\n\t// check that Close can be called multiple times\n\tm.Close(errors.New(\"close\"))\n\n\tfor i := 0; i < numConns; i++ {\n\t\tselect {\n\t\tcase err := <-destroyChan:\n\t\t\trequire.Equal(t, testErr, err)\n\t\tdefault:\n\t\t\tt.Fatalf(\"connection not destroyed\")\n\t\t}\n\t}\n\tselect {\n\tcase err := <-destroyChan:\n\t\tt.Fatalf(\"connection destroyed more than once: %s\", err)\n\tdefault:\n\t}\n}\n"
        },
        {
          "name": "packet_packer.go",
          "type": "blob",
          "size": 31.765625,
          "content": "package quic\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\nvar errNothingToPack = errors.New(\"nothing to pack\")\n\ntype packer interface {\n\tPackCoalescedPacket(onlyAck bool, maxPacketSize protocol.ByteCount, now time.Time, v protocol.Version) (*coalescedPacket, error)\n\tPackAckOnlyPacket(maxPacketSize protocol.ByteCount, now time.Time, v protocol.Version) (shortHeaderPacket, *packetBuffer, error)\n\tAppendPacket(buf *packetBuffer, maxPacketSize protocol.ByteCount, now time.Time, v protocol.Version) (shortHeaderPacket, error)\n\tMaybePackProbePacket(protocol.EncryptionLevel, protocol.ByteCount, time.Time, protocol.Version) (*coalescedPacket, error)\n\tPackConnectionClose(*qerr.TransportError, protocol.ByteCount, protocol.Version) (*coalescedPacket, error)\n\tPackApplicationClose(*qerr.ApplicationError, protocol.ByteCount, protocol.Version) (*coalescedPacket, error)\n\tPackMTUProbePacket(ping ackhandler.Frame, size protocol.ByteCount, v protocol.Version) (shortHeaderPacket, *packetBuffer, error)\n\n\tSetToken([]byte)\n}\n\ntype sealer interface {\n\thandshake.LongHeaderSealer\n}\n\ntype payload struct {\n\tstreamFrames []ackhandler.StreamFrame\n\tframes       []ackhandler.Frame\n\tack          *wire.AckFrame\n\tlength       protocol.ByteCount\n}\n\ntype longHeaderPacket struct {\n\theader       *wire.ExtendedHeader\n\tack          *wire.AckFrame\n\tframes       []ackhandler.Frame\n\tstreamFrames []ackhandler.StreamFrame // only used for 0-RTT packets\n\n\tlength protocol.ByteCount\n}\n\ntype shortHeaderPacket struct {\n\tPacketNumber         protocol.PacketNumber\n\tFrames               []ackhandler.Frame\n\tStreamFrames         []ackhandler.StreamFrame\n\tAck                  *wire.AckFrame\n\tLength               protocol.ByteCount\n\tIsPathMTUProbePacket bool\n\n\t// used for logging\n\tDestConnID      protocol.ConnectionID\n\tPacketNumberLen protocol.PacketNumberLen\n\tKeyPhase        protocol.KeyPhaseBit\n}\n\nfunc (p *shortHeaderPacket) IsAckEliciting() bool { return ackhandler.HasAckElicitingFrames(p.Frames) }\n\ntype coalescedPacket struct {\n\tbuffer         *packetBuffer\n\tlongHdrPackets []*longHeaderPacket\n\tshortHdrPacket *shortHeaderPacket\n}\n\n// IsOnlyShortHeaderPacket says if this packet only contains a short header packet (and no long header packets).\nfunc (p *coalescedPacket) IsOnlyShortHeaderPacket() bool {\n\treturn len(p.longHdrPackets) == 0 && p.shortHdrPacket != nil\n}\n\nfunc (p *longHeaderPacket) EncryptionLevel() protocol.EncryptionLevel {\n\t//nolint:exhaustive // Will never be called for Retry packets (and they don't have encrypted data).\n\tswitch p.header.Type {\n\tcase protocol.PacketTypeInitial:\n\t\treturn protocol.EncryptionInitial\n\tcase protocol.PacketTypeHandshake:\n\t\treturn protocol.EncryptionHandshake\n\tcase protocol.PacketType0RTT:\n\t\treturn protocol.Encryption0RTT\n\tdefault:\n\t\tpanic(\"can't determine encryption level\")\n\t}\n}\n\nfunc (p *longHeaderPacket) IsAckEliciting() bool { return ackhandler.HasAckElicitingFrames(p.frames) }\n\ntype packetNumberManager interface {\n\tPeekPacketNumber(protocol.EncryptionLevel) (protocol.PacketNumber, protocol.PacketNumberLen)\n\tPopPacketNumber(protocol.EncryptionLevel) protocol.PacketNumber\n}\n\ntype sealingManager interface {\n\tGetInitialSealer() (handshake.LongHeaderSealer, error)\n\tGetHandshakeSealer() (handshake.LongHeaderSealer, error)\n\tGet0RTTSealer() (handshake.LongHeaderSealer, error)\n\tGet1RTTSealer() (handshake.ShortHeaderSealer, error)\n}\n\ntype frameSource interface {\n\tHasData() bool\n\tAppend([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount, time.Time, protocol.Version) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount)\n}\n\ntype ackFrameSource interface {\n\tGetAckFrame(encLevel protocol.EncryptionLevel, onlyIfQueued bool) *wire.AckFrame\n}\n\ntype packetPacker struct {\n\tsrcConnID     protocol.ConnectionID\n\tgetDestConnID func() protocol.ConnectionID\n\n\tperspective protocol.Perspective\n\tcryptoSetup sealingManager\n\n\tinitialStream   *cryptoStream\n\thandshakeStream *cryptoStream\n\n\ttoken []byte\n\n\tpnManager           packetNumberManager\n\tframer              frameSource\n\tacks                ackFrameSource\n\tdatagramQueue       *datagramQueue\n\tretransmissionQueue *retransmissionQueue\n\trand                rand.Rand\n\n\tnumNonAckElicitingAcks int\n}\n\nvar _ packer = &packetPacker{}\n\nfunc newPacketPacker(\n\tsrcConnID protocol.ConnectionID,\n\tgetDestConnID func() protocol.ConnectionID,\n\tinitialStream, handshakeStream *cryptoStream,\n\tpacketNumberManager packetNumberManager,\n\tretransmissionQueue *retransmissionQueue,\n\tcryptoSetup sealingManager,\n\tframer frameSource,\n\tacks ackFrameSource,\n\tdatagramQueue *datagramQueue,\n\tperspective protocol.Perspective,\n) *packetPacker {\n\tvar b [8]byte\n\t_, _ = crand.Read(b[:])\n\n\treturn &packetPacker{\n\t\tcryptoSetup:         cryptoSetup,\n\t\tgetDestConnID:       getDestConnID,\n\t\tsrcConnID:           srcConnID,\n\t\tinitialStream:       initialStream,\n\t\thandshakeStream:     handshakeStream,\n\t\tretransmissionQueue: retransmissionQueue,\n\t\tdatagramQueue:       datagramQueue,\n\t\tperspective:         perspective,\n\t\tframer:              framer,\n\t\tacks:                acks,\n\t\trand:                *rand.New(rand.NewSource(binary.BigEndian.Uint64(b[:]))),\n\t\tpnManager:           packetNumberManager,\n\t}\n}\n\n// PackConnectionClose packs a packet that closes the connection with a transport error.\nfunc (p *packetPacker) PackConnectionClose(e *qerr.TransportError, maxPacketSize protocol.ByteCount, v protocol.Version) (*coalescedPacket, error) {\n\tvar reason string\n\t// don't send details of crypto errors\n\tif !e.ErrorCode.IsCryptoError() {\n\t\treason = e.ErrorMessage\n\t}\n\treturn p.packConnectionClose(false, uint64(e.ErrorCode), e.FrameType, reason, maxPacketSize, v)\n}\n\n// PackApplicationClose packs a packet that closes the connection with an application error.\nfunc (p *packetPacker) PackApplicationClose(e *qerr.ApplicationError, maxPacketSize protocol.ByteCount, v protocol.Version) (*coalescedPacket, error) {\n\treturn p.packConnectionClose(true, uint64(e.ErrorCode), 0, e.ErrorMessage, maxPacketSize, v)\n}\n\nfunc (p *packetPacker) packConnectionClose(\n\tisApplicationError bool,\n\terrorCode uint64,\n\tframeType uint64,\n\treason string,\n\tmaxPacketSize protocol.ByteCount,\n\tv protocol.Version,\n) (*coalescedPacket, error) {\n\tvar sealers [4]sealer\n\tvar hdrs [3]*wire.ExtendedHeader\n\tvar payloads [4]payload\n\tvar size protocol.ByteCount\n\tvar connID protocol.ConnectionID\n\tvar oneRTTPacketNumber protocol.PacketNumber\n\tvar oneRTTPacketNumberLen protocol.PacketNumberLen\n\tvar keyPhase protocol.KeyPhaseBit // only set for 1-RTT\n\tvar numLongHdrPackets uint8\n\tencLevels := [4]protocol.EncryptionLevel{protocol.EncryptionInitial, protocol.EncryptionHandshake, protocol.Encryption0RTT, protocol.Encryption1RTT}\n\tfor i, encLevel := range encLevels {\n\t\tif p.perspective == protocol.PerspectiveServer && encLevel == protocol.Encryption0RTT {\n\t\t\tcontinue\n\t\t}\n\t\tccf := &wire.ConnectionCloseFrame{\n\t\t\tIsApplicationError: isApplicationError,\n\t\t\tErrorCode:          errorCode,\n\t\t\tFrameType:          frameType,\n\t\t\tReasonPhrase:       reason,\n\t\t}\n\t\t// don't send application errors in Initial or Handshake packets\n\t\tif isApplicationError && (encLevel == protocol.EncryptionInitial || encLevel == protocol.EncryptionHandshake) {\n\t\t\tccf.IsApplicationError = false\n\t\t\tccf.ErrorCode = uint64(qerr.ApplicationErrorErrorCode)\n\t\t\tccf.ReasonPhrase = \"\"\n\t\t}\n\t\tpl := payload{\n\t\t\tframes: []ackhandler.Frame{{Frame: ccf}},\n\t\t\tlength: ccf.Length(v),\n\t\t}\n\n\t\tvar sealer sealer\n\t\tvar err error\n\t\tswitch encLevel {\n\t\tcase protocol.EncryptionInitial:\n\t\t\tsealer, err = p.cryptoSetup.GetInitialSealer()\n\t\tcase protocol.EncryptionHandshake:\n\t\t\tsealer, err = p.cryptoSetup.GetHandshakeSealer()\n\t\tcase protocol.Encryption0RTT:\n\t\t\tsealer, err = p.cryptoSetup.Get0RTTSealer()\n\t\tcase protocol.Encryption1RTT:\n\t\t\tvar s handshake.ShortHeaderSealer\n\t\t\ts, err = p.cryptoSetup.Get1RTTSealer()\n\t\t\tif err == nil {\n\t\t\t\tkeyPhase = s.KeyPhase()\n\t\t\t}\n\t\t\tsealer = s\n\t\t}\n\t\tif err == handshake.ErrKeysNotYetAvailable || err == handshake.ErrKeysDropped {\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tsealers[i] = sealer\n\t\tvar hdr *wire.ExtendedHeader\n\t\tif encLevel == protocol.Encryption1RTT {\n\t\t\tconnID = p.getDestConnID()\n\t\t\toneRTTPacketNumber, oneRTTPacketNumberLen = p.pnManager.PeekPacketNumber(protocol.Encryption1RTT)\n\t\t\tsize += p.shortHeaderPacketLength(connID, oneRTTPacketNumberLen, pl)\n\t\t} else {\n\t\t\thdr = p.getLongHeader(encLevel, v)\n\t\t\thdrs[i] = hdr\n\t\t\tsize += p.longHeaderPacketLength(hdr, pl, v) + protocol.ByteCount(sealer.Overhead())\n\t\t\tnumLongHdrPackets++\n\t\t}\n\t\tpayloads[i] = pl\n\t}\n\tbuffer := getPacketBuffer()\n\tpacket := &coalescedPacket{\n\t\tbuffer:         buffer,\n\t\tlongHdrPackets: make([]*longHeaderPacket, 0, numLongHdrPackets),\n\t}\n\tfor i, encLevel := range encLevels {\n\t\tif sealers[i] == nil {\n\t\t\tcontinue\n\t\t}\n\t\tvar paddingLen protocol.ByteCount\n\t\tif encLevel == protocol.EncryptionInitial {\n\t\t\tpaddingLen = p.initialPaddingLen(payloads[i].frames, size, maxPacketSize)\n\t\t}\n\t\tif encLevel == protocol.Encryption1RTT {\n\t\t\tshp, err := p.appendShortHeaderPacket(buffer, connID, oneRTTPacketNumber, oneRTTPacketNumberLen, keyPhase, payloads[i], paddingLen, maxPacketSize, sealers[i], false, v)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpacket.shortHdrPacket = &shp\n\t\t} else {\n\t\t\tlongHdrPacket, err := p.appendLongHeaderPacket(buffer, hdrs[i], payloads[i], paddingLen, encLevel, sealers[i], v)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tpacket.longHdrPackets = append(packet.longHdrPackets, longHdrPacket)\n\t\t}\n\t}\n\treturn packet, nil\n}\n\n// longHeaderPacketLength calculates the length of a serialized long header packet.\n// It takes into account that packets that have a tiny payload need to be padded,\n// such that len(payload) + packet number len >= 4 + AEAD overhead\nfunc (p *packetPacker) longHeaderPacketLength(hdr *wire.ExtendedHeader, pl payload, v protocol.Version) protocol.ByteCount {\n\tvar paddingLen protocol.ByteCount\n\tpnLen := protocol.ByteCount(hdr.PacketNumberLen)\n\tif pl.length < 4-pnLen {\n\t\tpaddingLen = 4 - pnLen - pl.length\n\t}\n\treturn hdr.GetLength(v) + pl.length + paddingLen\n}\n\n// shortHeaderPacketLength calculates the length of a serialized short header packet.\n// It takes into account that packets that have a tiny payload need to be padded,\n// such that len(payload) + packet number len >= 4 + AEAD overhead\nfunc (p *packetPacker) shortHeaderPacketLength(connID protocol.ConnectionID, pnLen protocol.PacketNumberLen, pl payload) protocol.ByteCount {\n\tvar paddingLen protocol.ByteCount\n\tif pl.length < 4-protocol.ByteCount(pnLen) {\n\t\tpaddingLen = 4 - protocol.ByteCount(pnLen) - pl.length\n\t}\n\treturn wire.ShortHeaderLen(connID, pnLen) + pl.length + paddingLen\n}\n\n// size is the expected size of the packet, if no padding was applied.\nfunc (p *packetPacker) initialPaddingLen(frames []ackhandler.Frame, currentSize, maxPacketSize protocol.ByteCount) protocol.ByteCount {\n\t// For the server, only ack-eliciting Initial packets need to be padded.\n\tif p.perspective == protocol.PerspectiveServer && !ackhandler.HasAckElicitingFrames(frames) {\n\t\treturn 0\n\t}\n\tif currentSize >= maxPacketSize {\n\t\treturn 0\n\t}\n\treturn maxPacketSize - currentSize\n}\n\n// PackCoalescedPacket packs a new packet.\n// It packs an Initial / Handshake if there is data to send in these packet number spaces.\n// It should only be called before the handshake is confirmed.\nfunc (p *packetPacker) PackCoalescedPacket(onlyAck bool, maxSize protocol.ByteCount, now time.Time, v protocol.Version) (*coalescedPacket, error) {\n\tvar (\n\t\tinitialHdr, handshakeHdr, zeroRTTHdr                            *wire.ExtendedHeader\n\t\tinitialPayload, handshakePayload, zeroRTTPayload, oneRTTPayload payload\n\t\toneRTTPacketNumber                                              protocol.PacketNumber\n\t\toneRTTPacketNumberLen                                           protocol.PacketNumberLen\n\t)\n\t// Try packing an Initial packet.\n\tinitialSealer, err := p.cryptoSetup.GetInitialSealer()\n\tif err != nil && err != handshake.ErrKeysDropped {\n\t\treturn nil, err\n\t}\n\tvar size protocol.ByteCount\n\tif initialSealer != nil {\n\t\tinitialHdr, initialPayload = p.maybeGetCryptoPacket(maxSize-protocol.ByteCount(initialSealer.Overhead()), protocol.EncryptionInitial, onlyAck, true, v)\n\t\tif initialPayload.length > 0 {\n\t\t\tsize += p.longHeaderPacketLength(initialHdr, initialPayload, v) + protocol.ByteCount(initialSealer.Overhead())\n\t\t}\n\t}\n\n\t// Add a Handshake packet.\n\tvar handshakeSealer sealer\n\tif (onlyAck && size == 0) || (!onlyAck && size < maxSize-protocol.MinCoalescedPacketSize) {\n\t\tvar err error\n\t\thandshakeSealer, err = p.cryptoSetup.GetHandshakeSealer()\n\t\tif err != nil && err != handshake.ErrKeysDropped && err != handshake.ErrKeysNotYetAvailable {\n\t\t\treturn nil, err\n\t\t}\n\t\tif handshakeSealer != nil {\n\t\t\thandshakeHdr, handshakePayload = p.maybeGetCryptoPacket(maxSize-size-protocol.ByteCount(handshakeSealer.Overhead()), protocol.EncryptionHandshake, onlyAck, size == 0, v)\n\t\t\tif handshakePayload.length > 0 {\n\t\t\t\ts := p.longHeaderPacketLength(handshakeHdr, handshakePayload, v) + protocol.ByteCount(handshakeSealer.Overhead())\n\t\t\t\tsize += s\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add a 0-RTT / 1-RTT packet.\n\tvar zeroRTTSealer sealer\n\tvar oneRTTSealer handshake.ShortHeaderSealer\n\tvar connID protocol.ConnectionID\n\tvar kp protocol.KeyPhaseBit\n\tif (onlyAck && size == 0) || (!onlyAck && size < maxSize-protocol.MinCoalescedPacketSize) {\n\t\tvar err error\n\t\toneRTTSealer, err = p.cryptoSetup.Get1RTTSealer()\n\t\tif err != nil && err != handshake.ErrKeysDropped && err != handshake.ErrKeysNotYetAvailable {\n\t\t\treturn nil, err\n\t\t}\n\t\tif err == nil { // 1-RTT\n\t\t\tkp = oneRTTSealer.KeyPhase()\n\t\t\tconnID = p.getDestConnID()\n\t\t\toneRTTPacketNumber, oneRTTPacketNumberLen = p.pnManager.PeekPacketNumber(protocol.Encryption1RTT)\n\t\t\thdrLen := wire.ShortHeaderLen(connID, oneRTTPacketNumberLen)\n\t\t\toneRTTPayload = p.maybeGetShortHeaderPacket(oneRTTSealer, hdrLen, maxSize-size, onlyAck, size == 0, now, v)\n\t\t\tif oneRTTPayload.length > 0 {\n\t\t\t\tsize += p.shortHeaderPacketLength(connID, oneRTTPacketNumberLen, oneRTTPayload) + protocol.ByteCount(oneRTTSealer.Overhead())\n\t\t\t}\n\t\t} else if p.perspective == protocol.PerspectiveClient && !onlyAck { // 0-RTT packets can't contain ACK frames\n\t\t\tvar err error\n\t\t\tzeroRTTSealer, err = p.cryptoSetup.Get0RTTSealer()\n\t\t\tif err != nil && err != handshake.ErrKeysDropped && err != handshake.ErrKeysNotYetAvailable {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif zeroRTTSealer != nil {\n\t\t\t\tzeroRTTHdr, zeroRTTPayload = p.maybeGetAppDataPacketFor0RTT(zeroRTTSealer, maxSize-size, now, v)\n\t\t\t\tif zeroRTTPayload.length > 0 {\n\t\t\t\t\tsize += p.longHeaderPacketLength(zeroRTTHdr, zeroRTTPayload, v) + protocol.ByteCount(zeroRTTSealer.Overhead())\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif initialPayload.length == 0 && handshakePayload.length == 0 && zeroRTTPayload.length == 0 && oneRTTPayload.length == 0 {\n\t\treturn nil, nil\n\t}\n\n\tbuffer := getPacketBuffer()\n\tpacket := &coalescedPacket{\n\t\tbuffer:         buffer,\n\t\tlongHdrPackets: make([]*longHeaderPacket, 0, 3),\n\t}\n\tif initialPayload.length > 0 {\n\t\tpadding := p.initialPaddingLen(initialPayload.frames, size, maxSize)\n\t\tcont, err := p.appendLongHeaderPacket(buffer, initialHdr, initialPayload, padding, protocol.EncryptionInitial, initialSealer, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpacket.longHdrPackets = append(packet.longHdrPackets, cont)\n\t}\n\tif handshakePayload.length > 0 {\n\t\tcont, err := p.appendLongHeaderPacket(buffer, handshakeHdr, handshakePayload, 0, protocol.EncryptionHandshake, handshakeSealer, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpacket.longHdrPackets = append(packet.longHdrPackets, cont)\n\t}\n\tif zeroRTTPayload.length > 0 {\n\t\tlongHdrPacket, err := p.appendLongHeaderPacket(buffer, zeroRTTHdr, zeroRTTPayload, 0, protocol.Encryption0RTT, zeroRTTSealer, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpacket.longHdrPackets = append(packet.longHdrPackets, longHdrPacket)\n\t} else if oneRTTPayload.length > 0 {\n\t\tshp, err := p.appendShortHeaderPacket(buffer, connID, oneRTTPacketNumber, oneRTTPacketNumberLen, kp, oneRTTPayload, 0, maxSize, oneRTTSealer, false, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpacket.shortHdrPacket = &shp\n\t}\n\treturn packet, nil\n}\n\n// PackAckOnlyPacket packs a packet containing only an ACK in the application data packet number space.\n// It should be called after the handshake is confirmed.\nfunc (p *packetPacker) PackAckOnlyPacket(maxSize protocol.ByteCount, now time.Time, v protocol.Version) (shortHeaderPacket, *packetBuffer, error) {\n\tbuf := getPacketBuffer()\n\tpacket, err := p.appendPacket(buf, true, maxSize, now, v)\n\treturn packet, buf, err\n}\n\n// AppendPacket packs a packet in the application data packet number space.\n// It should be called after the handshake is confirmed.\nfunc (p *packetPacker) AppendPacket(buf *packetBuffer, maxSize protocol.ByteCount, now time.Time, v protocol.Version) (shortHeaderPacket, error) {\n\treturn p.appendPacket(buf, false, maxSize, now, v)\n}\n\nfunc (p *packetPacker) appendPacket(\n\tbuf *packetBuffer,\n\tonlyAck bool,\n\tmaxPacketSize protocol.ByteCount,\n\tnow time.Time,\n\tv protocol.Version,\n) (shortHeaderPacket, error) {\n\tsealer, err := p.cryptoSetup.Get1RTTSealer()\n\tif err != nil {\n\t\treturn shortHeaderPacket{}, err\n\t}\n\tpn, pnLen := p.pnManager.PeekPacketNumber(protocol.Encryption1RTT)\n\tconnID := p.getDestConnID()\n\thdrLen := wire.ShortHeaderLen(connID, pnLen)\n\tpl := p.maybeGetShortHeaderPacket(sealer, hdrLen, maxPacketSize, onlyAck, true, now, v)\n\tif pl.length == 0 {\n\t\treturn shortHeaderPacket{}, errNothingToPack\n\t}\n\tkp := sealer.KeyPhase()\n\n\treturn p.appendShortHeaderPacket(buf, connID, pn, pnLen, kp, pl, 0, maxPacketSize, sealer, false, v)\n}\n\nfunc (p *packetPacker) maybeGetCryptoPacket(maxPacketSize protocol.ByteCount, encLevel protocol.EncryptionLevel, onlyAck, ackAllowed bool, v protocol.Version) (*wire.ExtendedHeader, payload) {\n\tif onlyAck {\n\t\tif ack := p.acks.GetAckFrame(encLevel, true); ack != nil {\n\t\t\treturn p.getLongHeader(encLevel, v), payload{\n\t\t\t\tack:    ack,\n\t\t\t\tlength: ack.Length(v),\n\t\t\t}\n\t\t}\n\t\treturn nil, payload{}\n\t}\n\n\tvar s *cryptoStream\n\tvar handler ackhandler.FrameHandler\n\tvar hasRetransmission bool\n\t//nolint:exhaustive // Initial and Handshake are the only two encryption levels here.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\ts = p.initialStream\n\t\thandler = p.retransmissionQueue.InitialAckHandler()\n\t\thasRetransmission = p.retransmissionQueue.HasInitialData()\n\tcase protocol.EncryptionHandshake:\n\t\ts = p.handshakeStream\n\t\thandler = p.retransmissionQueue.HandshakeAckHandler()\n\t\thasRetransmission = p.retransmissionQueue.HasHandshakeData()\n\t}\n\n\thasData := s.HasData()\n\tvar ack *wire.AckFrame\n\tif ackAllowed {\n\t\tack = p.acks.GetAckFrame(encLevel, !hasRetransmission && !hasData)\n\t}\n\tif !hasData && !hasRetransmission && ack == nil {\n\t\t// nothing to send\n\t\treturn nil, payload{}\n\t}\n\n\tvar pl payload\n\tif ack != nil {\n\t\tpl.ack = ack\n\t\tpl.length = ack.Length(v)\n\t\tmaxPacketSize -= pl.length\n\t}\n\thdr := p.getLongHeader(encLevel, v)\n\tmaxPacketSize -= hdr.GetLength(v)\n\tif hasRetransmission {\n\t\tfor {\n\t\t\tvar f ackhandler.Frame\n\t\t\t//nolint:exhaustive // 0-RTT packets can't contain any retransmissions\n\t\t\tswitch encLevel {\n\t\t\tcase protocol.EncryptionInitial:\n\t\t\t\tf.Frame = p.retransmissionQueue.GetInitialFrame(maxPacketSize, v)\n\t\t\t\tf.Handler = p.retransmissionQueue.InitialAckHandler()\n\t\t\tcase protocol.EncryptionHandshake:\n\t\t\t\tf.Frame = p.retransmissionQueue.GetHandshakeFrame(maxPacketSize, v)\n\t\t\t\tf.Handler = p.retransmissionQueue.HandshakeAckHandler()\n\t\t\t}\n\t\t\tif f.Frame == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tpl.frames = append(pl.frames, f)\n\t\t\tframeLen := f.Frame.Length(v)\n\t\t\tpl.length += frameLen\n\t\t\tmaxPacketSize -= frameLen\n\t\t}\n\t} else if s.HasData() {\n\t\tcf := s.PopCryptoFrame(maxPacketSize)\n\t\tpl.frames = []ackhandler.Frame{{Frame: cf, Handler: handler}}\n\t\tpl.length += cf.Length(v)\n\t}\n\treturn hdr, pl\n}\n\nfunc (p *packetPacker) maybeGetAppDataPacketFor0RTT(\n\tsealer sealer,\n\tmaxPacketSize protocol.ByteCount,\n\tnow time.Time,\n\tv protocol.Version,\n) (*wire.ExtendedHeader, payload) {\n\tif p.perspective != protocol.PerspectiveClient {\n\t\treturn nil, payload{}\n\t}\n\n\thdr := p.getLongHeader(protocol.Encryption0RTT, v)\n\tmaxPayloadSize := maxPacketSize - hdr.GetLength(v) - protocol.ByteCount(sealer.Overhead())\n\treturn hdr, p.maybeGetAppDataPacket(maxPayloadSize, false, false, now, v)\n}\n\nfunc (p *packetPacker) maybeGetShortHeaderPacket(\n\tsealer handshake.ShortHeaderSealer,\n\thdrLen, maxPacketSize protocol.ByteCount,\n\tonlyAck, ackAllowed bool,\n\tnow time.Time,\n\tv protocol.Version,\n) payload {\n\tmaxPayloadSize := maxPacketSize - hdrLen - protocol.ByteCount(sealer.Overhead())\n\treturn p.maybeGetAppDataPacket(maxPayloadSize, onlyAck, ackAllowed, now, v)\n}\n\nfunc (p *packetPacker) maybeGetAppDataPacket(\n\tmaxPayloadSize protocol.ByteCount,\n\tonlyAck, ackAllowed bool,\n\tnow time.Time,\n\tv protocol.Version,\n) payload {\n\tpl := p.composeNextPacket(maxPayloadSize, onlyAck, ackAllowed, now, v)\n\n\t// check if we have anything to send\n\tif len(pl.frames) == 0 && len(pl.streamFrames) == 0 {\n\t\tif pl.ack == nil {\n\t\t\treturn payload{}\n\t\t}\n\t\t// the packet only contains an ACK\n\t\tif p.numNonAckElicitingAcks >= protocol.MaxNonAckElicitingAcks {\n\t\t\tping := &wire.PingFrame{}\n\t\t\tpl.frames = append(pl.frames, ackhandler.Frame{Frame: ping})\n\t\t\tpl.length += ping.Length(v)\n\t\t\tp.numNonAckElicitingAcks = 0\n\t\t} else {\n\t\t\tp.numNonAckElicitingAcks++\n\t\t}\n\t} else {\n\t\tp.numNonAckElicitingAcks = 0\n\t}\n\treturn pl\n}\n\nfunc (p *packetPacker) composeNextPacket(\n\tmaxFrameSize protocol.ByteCount,\n\tonlyAck, ackAllowed bool,\n\tnow time.Time,\n\tv protocol.Version,\n) payload {\n\tif onlyAck {\n\t\tif ack := p.acks.GetAckFrame(protocol.Encryption1RTT, true); ack != nil {\n\t\t\treturn payload{ack: ack, length: ack.Length(v)}\n\t\t}\n\t\treturn payload{}\n\t}\n\n\thasData := p.framer.HasData()\n\thasRetransmission := p.retransmissionQueue.HasAppData()\n\n\tvar hasAck bool\n\tvar pl payload\n\tif ackAllowed {\n\t\tif ack := p.acks.GetAckFrame(protocol.Encryption1RTT, !hasRetransmission && !hasData); ack != nil {\n\t\t\tpl.ack = ack\n\t\t\tpl.length += ack.Length(v)\n\t\t\thasAck = true\n\t\t}\n\t}\n\n\tif p.datagramQueue != nil {\n\t\tif f := p.datagramQueue.Peek(); f != nil {\n\t\t\tsize := f.Length(v)\n\t\t\tif size <= maxFrameSize-pl.length { // DATAGRAM frame fits\n\t\t\t\tpl.frames = append(pl.frames, ackhandler.Frame{Frame: f})\n\t\t\t\tpl.length += size\n\t\t\t\tp.datagramQueue.Pop()\n\t\t\t} else if !hasAck {\n\t\t\t\t// The DATAGRAM frame doesn't fit, and the packet doesn't contain an ACK.\n\t\t\t\t// Discard this frame. There's no point in retrying this in the next packet,\n\t\t\t\t// as it's unlikely that the available packet size will increase.\n\t\t\t\tp.datagramQueue.Pop()\n\t\t\t}\n\t\t\t// If the DATAGRAM frame was too large and the packet contained an ACK, we'll try to send it out later.\n\t\t}\n\t}\n\n\tif hasAck && !hasData && !hasRetransmission {\n\t\treturn pl\n\t}\n\n\tif hasRetransmission {\n\t\tfor {\n\t\t\tremainingLen := maxFrameSize - pl.length\n\t\t\tif remainingLen < protocol.MinStreamFrameSize {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tf := p.retransmissionQueue.GetAppDataFrame(remainingLen, v)\n\t\t\tif f == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tpl.frames = append(pl.frames, ackhandler.Frame{Frame: f, Handler: p.retransmissionQueue.AppDataAckHandler()})\n\t\t\tpl.length += f.Length(v)\n\t\t}\n\t}\n\n\tif hasData {\n\t\tvar lengthAdded protocol.ByteCount\n\t\tstartLen := len(pl.frames)\n\t\tpl.frames, pl.streamFrames, lengthAdded = p.framer.Append(pl.frames, pl.streamFrames, maxFrameSize-pl.length, now, v)\n\t\tpl.length += lengthAdded\n\t\t// add handlers for the control frames that were added\n\t\tfor i := startLen; i < len(pl.frames); i++ {\n\t\t\tif pl.frames[i].Handler != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch pl.frames[i].Frame.(type) {\n\t\t\tcase *wire.PathChallengeFrame, *wire.PathResponseFrame:\n\t\t\t\t// Path probing is currently not supported, therefore we don't need to set the OnAcked callback yet.\n\t\t\t\t// PATH_CHALLENGE and PATH_RESPONSE are never retransmitted.\n\t\t\tdefault:\n\t\t\t\tpl.frames[i].Handler = p.retransmissionQueue.AppDataAckHandler()\n\t\t\t}\n\t\t}\n\t}\n\treturn pl\n}\n\nfunc (p *packetPacker) MaybePackProbePacket(\n\tencLevel protocol.EncryptionLevel,\n\tmaxPacketSize protocol.ByteCount,\n\tnow time.Time,\n\tv protocol.Version,\n) (*coalescedPacket, error) {\n\tif encLevel == protocol.Encryption1RTT {\n\t\ts, err := p.cryptoSetup.Get1RTTSealer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkp := s.KeyPhase()\n\t\tconnID := p.getDestConnID()\n\t\tpn, pnLen := p.pnManager.PeekPacketNumber(protocol.Encryption1RTT)\n\t\thdrLen := wire.ShortHeaderLen(connID, pnLen)\n\t\tpl := p.maybeGetAppDataPacket(maxPacketSize-protocol.ByteCount(s.Overhead())-hdrLen, false, true, now, v)\n\t\tif pl.length == 0 {\n\t\t\treturn nil, nil\n\t\t}\n\t\tbuffer := getPacketBuffer()\n\t\tpacket := &coalescedPacket{buffer: buffer}\n\t\tshp, err := p.appendShortHeaderPacket(buffer, connID, pn, pnLen, kp, pl, 0, maxPacketSize, s, false, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpacket.shortHdrPacket = &shp\n\t\treturn packet, nil\n\t}\n\n\tvar sealer handshake.LongHeaderSealer\n\t//nolint:exhaustive // Probe packets are never sent for 0-RTT.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\tvar err error\n\t\tsealer, err = p.cryptoSetup.GetInitialSealer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase protocol.EncryptionHandshake:\n\t\tvar err error\n\t\tsealer, err = p.cryptoSetup.GetHandshakeSealer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\tpanic(\"unknown encryption level\")\n\t}\n\thdr, pl := p.maybeGetCryptoPacket(maxPacketSize-protocol.ByteCount(sealer.Overhead()), encLevel, false, true, v)\n\tif pl.length == 0 {\n\t\treturn nil, nil\n\t}\n\tbuffer := getPacketBuffer()\n\tpacket := &coalescedPacket{buffer: buffer}\n\tsize := p.longHeaderPacketLength(hdr, pl, v) + protocol.ByteCount(sealer.Overhead())\n\tvar padding protocol.ByteCount\n\tif encLevel == protocol.EncryptionInitial {\n\t\tpadding = p.initialPaddingLen(pl.frames, size, maxPacketSize)\n\t}\n\n\tlongHdrPacket, err := p.appendLongHeaderPacket(buffer, hdr, pl, padding, encLevel, sealer, v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpacket.longHdrPackets = []*longHeaderPacket{longHdrPacket}\n\treturn packet, nil\n}\n\nfunc (p *packetPacker) PackMTUProbePacket(ping ackhandler.Frame, size protocol.ByteCount, v protocol.Version) (shortHeaderPacket, *packetBuffer, error) {\n\tpl := payload{\n\t\tframes: []ackhandler.Frame{ping},\n\t\tlength: ping.Frame.Length(v),\n\t}\n\tbuffer := getPacketBuffer()\n\ts, err := p.cryptoSetup.Get1RTTSealer()\n\tif err != nil {\n\t\treturn shortHeaderPacket{}, nil, err\n\t}\n\tconnID := p.getDestConnID()\n\tpn, pnLen := p.pnManager.PeekPacketNumber(protocol.Encryption1RTT)\n\tpadding := size - p.shortHeaderPacketLength(connID, pnLen, pl) - protocol.ByteCount(s.Overhead())\n\tkp := s.KeyPhase()\n\tpacket, err := p.appendShortHeaderPacket(buffer, connID, pn, pnLen, kp, pl, padding, size, s, true, v)\n\treturn packet, buffer, err\n}\n\nfunc (p *packetPacker) getLongHeader(encLevel protocol.EncryptionLevel, v protocol.Version) *wire.ExtendedHeader {\n\tpn, pnLen := p.pnManager.PeekPacketNumber(encLevel)\n\thdr := &wire.ExtendedHeader{\n\t\tPacketNumber:    pn,\n\t\tPacketNumberLen: pnLen,\n\t}\n\thdr.Version = v\n\thdr.SrcConnectionID = p.srcConnID\n\thdr.DestConnectionID = p.getDestConnID()\n\n\t//nolint:exhaustive // 1-RTT packets are not long header packets.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\thdr.Type = protocol.PacketTypeInitial\n\t\thdr.Token = p.token\n\tcase protocol.EncryptionHandshake:\n\t\thdr.Type = protocol.PacketTypeHandshake\n\tcase protocol.Encryption0RTT:\n\t\thdr.Type = protocol.PacketType0RTT\n\t}\n\treturn hdr\n}\n\nfunc (p *packetPacker) appendLongHeaderPacket(buffer *packetBuffer, header *wire.ExtendedHeader, pl payload, padding protocol.ByteCount, encLevel protocol.EncryptionLevel, sealer sealer, v protocol.Version) (*longHeaderPacket, error) {\n\tvar paddingLen protocol.ByteCount\n\tpnLen := protocol.ByteCount(header.PacketNumberLen)\n\tif pl.length < 4-pnLen {\n\t\tpaddingLen = 4 - pnLen - pl.length\n\t}\n\tpaddingLen += padding\n\theader.Length = pnLen + protocol.ByteCount(sealer.Overhead()) + pl.length + paddingLen\n\n\tstartLen := len(buffer.Data)\n\traw := buffer.Data[startLen:]\n\traw, err := header.Append(raw, v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpayloadOffset := protocol.ByteCount(len(raw))\n\n\traw, err = p.appendPacketPayload(raw, pl, paddingLen, v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\traw = p.encryptPacket(raw, sealer, header.PacketNumber, payloadOffset, pnLen)\n\tbuffer.Data = buffer.Data[:len(buffer.Data)+len(raw)]\n\n\tif pn := p.pnManager.PopPacketNumber(encLevel); pn != header.PacketNumber {\n\t\treturn nil, fmt.Errorf(\"packetPacker BUG: Peeked and Popped packet numbers do not match: expected %d, got %d\", pn, header.PacketNumber)\n\t}\n\treturn &longHeaderPacket{\n\t\theader:       header,\n\t\tack:          pl.ack,\n\t\tframes:       pl.frames,\n\t\tstreamFrames: pl.streamFrames,\n\t\tlength:       protocol.ByteCount(len(raw)),\n\t}, nil\n}\n\nfunc (p *packetPacker) appendShortHeaderPacket(\n\tbuffer *packetBuffer,\n\tconnID protocol.ConnectionID,\n\tpn protocol.PacketNumber,\n\tpnLen protocol.PacketNumberLen,\n\tkp protocol.KeyPhaseBit,\n\tpl payload,\n\tpadding, maxPacketSize protocol.ByteCount,\n\tsealer sealer,\n\tisMTUProbePacket bool,\n\tv protocol.Version,\n) (shortHeaderPacket, error) {\n\tvar paddingLen protocol.ByteCount\n\tif pl.length < 4-protocol.ByteCount(pnLen) {\n\t\tpaddingLen = 4 - protocol.ByteCount(pnLen) - pl.length\n\t}\n\tpaddingLen += padding\n\n\tstartLen := len(buffer.Data)\n\traw := buffer.Data[startLen:]\n\traw, err := wire.AppendShortHeader(raw, connID, pn, pnLen, kp)\n\tif err != nil {\n\t\treturn shortHeaderPacket{}, err\n\t}\n\tpayloadOffset := protocol.ByteCount(len(raw))\n\n\traw, err = p.appendPacketPayload(raw, pl, paddingLen, v)\n\tif err != nil {\n\t\treturn shortHeaderPacket{}, err\n\t}\n\tif !isMTUProbePacket {\n\t\tif size := protocol.ByteCount(len(raw) + sealer.Overhead()); size > maxPacketSize {\n\t\t\treturn shortHeaderPacket{}, fmt.Errorf(\"PacketPacker BUG: packet too large (%d bytes, allowed %d bytes)\", size, maxPacketSize)\n\t\t}\n\t}\n\traw = p.encryptPacket(raw, sealer, pn, payloadOffset, protocol.ByteCount(pnLen))\n\tbuffer.Data = buffer.Data[:len(buffer.Data)+len(raw)]\n\n\tif newPN := p.pnManager.PopPacketNumber(protocol.Encryption1RTT); newPN != pn {\n\t\treturn shortHeaderPacket{}, fmt.Errorf(\"packetPacker BUG: Peeked and Popped packet numbers do not match: expected %d, got %d\", pn, newPN)\n\t}\n\treturn shortHeaderPacket{\n\t\tPacketNumber:         pn,\n\t\tPacketNumberLen:      pnLen,\n\t\tKeyPhase:             kp,\n\t\tStreamFrames:         pl.streamFrames,\n\t\tFrames:               pl.frames,\n\t\tAck:                  pl.ack,\n\t\tLength:               protocol.ByteCount(len(raw)),\n\t\tDestConnID:           connID,\n\t\tIsPathMTUProbePacket: isMTUProbePacket,\n\t}, nil\n}\n\n// appendPacketPayload serializes the payload of a packet into the raw byte slice.\n// It modifies the order of payload.frames.\nfunc (p *packetPacker) appendPacketPayload(raw []byte, pl payload, paddingLen protocol.ByteCount, v protocol.Version) ([]byte, error) {\n\tpayloadOffset := len(raw)\n\tif pl.ack != nil {\n\t\tvar err error\n\t\traw, err = pl.ack.Append(raw, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif paddingLen > 0 {\n\t\traw = append(raw, make([]byte, paddingLen)...)\n\t}\n\t// Randomize the order of the control frames.\n\t// This makes sure that the receiver doesn't rely on the order in which frames are packed.\n\tif len(pl.frames) > 1 {\n\t\tp.rand.Shuffle(len(pl.frames), func(i, j int) { pl.frames[i], pl.frames[j] = pl.frames[j], pl.frames[i] })\n\t}\n\tfor _, f := range pl.frames {\n\t\tvar err error\n\t\traw, err = f.Frame.Append(raw, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tfor _, f := range pl.streamFrames {\n\t\tvar err error\n\t\traw, err = f.Frame.Append(raw, v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif payloadSize := protocol.ByteCount(len(raw)-payloadOffset) - paddingLen; payloadSize != pl.length {\n\t\treturn nil, fmt.Errorf(\"PacketPacker BUG: payload size inconsistent (expected %d, got %d bytes)\", pl.length, payloadSize)\n\t}\n\treturn raw, nil\n}\n\nfunc (p *packetPacker) encryptPacket(raw []byte, sealer sealer, pn protocol.PacketNumber, payloadOffset, pnLen protocol.ByteCount) []byte {\n\t_ = sealer.Seal(raw[payloadOffset:payloadOffset], raw[payloadOffset:], pn, raw[:payloadOffset])\n\traw = raw[:len(raw)+sealer.Overhead()]\n\t// apply header protection\n\tpnOffset := payloadOffset - pnLen\n\tsealer.EncryptHeader(raw[pnOffset+4:pnOffset+4+16], &raw[0], raw[pnOffset:payloadOffset])\n\treturn raw\n}\n\nfunc (p *packetPacker) SetToken(token []byte) {\n\tp.token = token\n}\n"
        },
        {
          "name": "packet_packer_test.go",
          "type": "blob",
          "size": 44.12890625,
          "content": "package quic\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\tmockackhandler \"github.com/quic-go/quic-go/internal/mocks/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nconst testPackerConnIDLen = 4\n\ntype testPacketPacker struct {\n\tpacker                         *packetPacker\n\tinitialStream, handshakeStream *cryptoStream\n\tdatagramQueue                  *datagramQueue\n\tpnManager                      *mockackhandler.MockSentPacketHandler\n\tsealingManager                 *MockSealingManager\n\tframer                         *MockFrameSource\n\tackFramer                      *MockAckFrameSource\n\tretransmissionQueue            *retransmissionQueue\n}\n\nfunc newTestPacketPacker(t *testing.T, mockCtrl *gomock.Controller, pers protocol.Perspective) *testPacketPacker {\n\tdestConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4})\n\trequire.Equal(t, testPackerConnIDLen, destConnID.Len())\n\tinitialStream := newCryptoStream()\n\thandshakeStream := newCryptoStream()\n\tpnManager := mockackhandler.NewMockSentPacketHandler(mockCtrl)\n\tframer := NewMockFrameSource(mockCtrl)\n\tackFramer := NewMockAckFrameSource(mockCtrl)\n\tsealingManager := NewMockSealingManager(mockCtrl)\n\tdatagramQueue := newDatagramQueue(func() {}, utils.DefaultLogger)\n\tretransmissionQueue := newRetransmissionQueue()\n\treturn &testPacketPacker{\n\t\tpnManager:           pnManager,\n\t\tinitialStream:       initialStream,\n\t\thandshakeStream:     handshakeStream,\n\t\tsealingManager:      sealingManager,\n\t\tframer:              framer,\n\t\tackFramer:           ackFramer,\n\t\tdatagramQueue:       datagramQueue,\n\t\tretransmissionQueue: retransmissionQueue,\n\t\tpacker: newPacketPacker(\n\t\t\tprotocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}),\n\t\t\tfunc() protocol.ConnectionID { return destConnID },\n\t\t\tinitialStream,\n\t\t\thandshakeStream,\n\t\t\tpnManager,\n\t\t\tretransmissionQueue,\n\t\t\tsealingManager,\n\t\t\tframer,\n\t\t\tackFramer,\n\t\t\tdatagramQueue,\n\t\t\tpers,\n\t\t),\n\t}\n}\n\n// newMockShortHeaderSealer returns a mock short header sealer that seals a short header packet\nfunc newMockShortHeaderSealer(mockCtrl *gomock.Controller) *mocks.MockShortHeaderSealer {\n\tsealer := mocks.NewMockShortHeaderSealer(mockCtrl)\n\tsealer.EXPECT().KeyPhase().Return(protocol.KeyPhaseOne).AnyTimes()\n\tsealer.EXPECT().Overhead().Return(7).AnyTimes()\n\tsealer.EXPECT().EncryptHeader(gomock.Any(), gomock.Any(), gomock.Any()).AnyTimes()\n\tsealer.EXPECT().Seal(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(func(dst, src []byte, pn protocol.PacketNumber, associatedData []byte) []byte {\n\t\treturn append(src, bytes.Repeat([]byte{'s'}, sealer.Overhead())...)\n\t}).AnyTimes()\n\treturn sealer\n}\n\nfunc parsePacket(t *testing.T, data []byte) (hdrs []*wire.ExtendedHeader, more []byte) {\n\tt.Helper()\n\tfor len(data) > 0 {\n\t\tif !wire.IsLongHeaderPacket(data[0]) {\n\t\t\tbreak\n\t\t}\n\t\thdr, _, more, err := wire.ParsePacket(data)\n\t\trequire.NoError(t, err)\n\t\textHdr, err := hdr.ParseExtended(data)\n\t\trequire.NoError(t, err)\n\t\trequire.GreaterOrEqual(t, extHdr.Length+protocol.ByteCount(extHdr.PacketNumberLen), protocol.ByteCount(4))\n\t\tdata = more\n\t\thdrs = append(hdrs, extHdr)\n\t}\n\treturn hdrs, data\n}\n\nfunc parseShortHeaderPacket(t *testing.T, data []byte, connIDLen int) {\n\tt.Helper()\n\tl, _, pnLen, _, err := wire.ParseShortHeader(data, connIDLen)\n\trequire.NoError(t, err)\n\trequire.GreaterOrEqual(t, len(data)-l+int(pnLen), 4)\n}\n\nfunc expectAppendFrames(framer *MockFrameSource, controlFrames []ackhandler.Frame, streamFrames []ackhandler.StreamFrame) {\n\tframer.EXPECT().Append(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(\n\t\tfunc(cf []ackhandler.Frame, sf []ackhandler.StreamFrame, _ protocol.ByteCount, _ time.Time, v protocol.Version) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount) {\n\t\t\tvar length protocol.ByteCount\n\t\t\tfor _, f := range controlFrames {\n\t\t\t\tlength += f.Frame.Length(v)\n\t\t\t}\n\t\t\tfor _, f := range streamFrames {\n\t\t\t\tlength += f.Frame.Length(v)\n\t\t\t}\n\t\t\treturn append(cf, controlFrames...), append(sf, streamFrames...), length\n\t\t},\n\t)\n}\n\nfunc TestPackLongHeaders(t *testing.T) {\n\tconst maxPacketSize protocol.ByteCount = 1234\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveClient)\n\ttoken := make([]byte, 20)\n\trand.Read(token)\n\ttp.packer.SetToken(token)\n\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(0x24), protocol.PacketNumberLen3)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(0x24))\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen4)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().Get0RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionInitial, false)\n\t// don't EXPECT any calls for a Handshake ACK frame\n\ttp.initialStream.Write([]byte(\"initial\"))\n\ttp.packer.retransmissionQueue.addHandshake(&wire.PingFrame{})\n\n\tp, err := tp.packer.PackCoalescedPacket(false, maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, maxPacketSize, p.buffer.Len())\n\trequire.Len(t, p.longHdrPackets, 2)\n\trequire.Nil(t, p.shortHdrPacket)\n\trequire.Equal(t, protocol.EncryptionInitial, p.longHdrPackets[0].EncryptionLevel())\n\trequire.Len(t, p.longHdrPackets[0].frames, 1)\n\trequire.Equal(t, []byte(\"initial\"), p.longHdrPackets[0].frames[0].Frame.(*wire.CryptoFrame).Data)\n\trequire.Equal(t, protocol.EncryptionHandshake, p.longHdrPackets[1].EncryptionLevel())\n\trequire.Len(t, p.longHdrPackets[1].frames, 1)\n\trequire.IsType(t, &wire.PingFrame{}, p.longHdrPackets[1].frames[0].Frame)\n\n\thdrs, more := parsePacket(t, p.buffer.Data)\n\trequire.Len(t, hdrs, 2)\n\trequire.Equal(t, protocol.PacketTypeInitial, hdrs[0].Type)\n\trequire.Equal(t, token, hdrs[0].Token)\n\trequire.Equal(t, protocol.PacketNumber(0x24), hdrs[0].PacketNumber)\n\trequire.Equal(t, protocol.PacketNumberLen3, hdrs[0].PacketNumberLen)\n\trequire.Equal(t, protocol.PacketTypeHandshake, hdrs[1].Type)\n\trequire.Nil(t, hdrs[1].Token)\n\trequire.Equal(t, protocol.PacketNumber(0x42), hdrs[1].PacketNumber)\n\trequire.Equal(t, protocol.PacketNumberLen4, hdrs[1].PacketNumberLen)\n\trequire.Empty(t, more)\n}\n\nfunc TestPackCoalescedAckOnlyPacketNothingToSend(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveClient)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\t// the packet number is not popped\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionInitial, true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionHandshake, true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true)\n\tp, err := tp.packer.PackCoalescedPacket(true, 1234, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Nil(t, p)\n}\n\nfunc TestPackInitialAckOnlyPacket(t *testing.T) {\n\tt.Run(\"client\", func(t *testing.T) { testPackInitialAckOnlyPacket(t, protocol.PerspectiveClient) })\n\tt.Run(\"server\", func(t *testing.T) { testPackInitialAckOnlyPacket(t, protocol.PerspectiveServer) })\n}\n\nfunc testPackInitialAckOnlyPacket(t *testing.T, pers protocol.Perspective) {\n\tconst maxPacketSize protocol.ByteCount = 1234\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, pers)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\tack := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 1, Largest: 10}}}\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionInitial, true).Return(ack)\n\tp, err := tp.packer.PackCoalescedPacket(true, maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, p)\n\trequire.Len(t, p.longHdrPackets, 1)\n\trequire.Equal(t, protocol.EncryptionInitial, p.longHdrPackets[0].EncryptionLevel())\n\trequire.Equal(t, ack, p.longHdrPackets[0].ack)\n\trequire.Empty(t, p.longHdrPackets[0].frames)\n\t// only the client needs to pad Initial packets\n\tswitch pers {\n\tcase protocol.PerspectiveClient:\n\t\trequire.Equal(t, maxPacketSize, p.buffer.Len())\n\tcase protocol.PerspectiveServer:\n\t\trequire.Less(t, p.buffer.Len(), protocol.ByteCount(100))\n\t}\n\thdrs, more := parsePacket(t, p.buffer.Data)\n\trequire.Empty(t, more)\n\trequire.Len(t, hdrs, 1)\n\trequire.Equal(t, protocol.PacketTypeInitial, hdrs[0].Type)\n}\n\nfunc TestPack1RTTAckOnlyPacket(t *testing.T) {\n\tconst maxPacketSize protocol.ByteCount = 1300\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveClient)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\tack := &wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 1, Largest: 10}}}\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true).Return(ack)\n\tp, buffer, err := tp.packer.PackAckOnlyPacket(maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, ack, p.Ack)\n\trequire.Empty(t, p.Frames)\n\tparsePacket(t, buffer.Data)\n}\n\nfunc TestPack0RTTPacket(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveClient)\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().Get0RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionInitial, true)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption0RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption0RTT).Return(protocol.PacketNumber(0x42))\n\tcf := ackhandler.Frame{Frame: &wire.MaxDataFrame{MaximumData: 0x1337}}\n\ttp.framer.EXPECT().HasData().Return(true)\n\t// TODO: check sizes\n\ttp.framer.EXPECT().Append(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(func(fs []ackhandler.Frame, sf []ackhandler.StreamFrame, _ protocol.ByteCount, _ time.Time, _ protocol.Version) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount) {\n\t\treturn append(fs, cf), sf, cf.Frame.Length(protocol.Version1)\n\t})\n\tp, err := tp.packer.PackCoalescedPacket(false, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, p)\n\trequire.Len(t, p.longHdrPackets, 1)\n\trequire.Equal(t, protocol.PacketType0RTT, p.longHdrPackets[0].header.Type)\n\trequire.Equal(t, protocol.Encryption0RTT, p.longHdrPackets[0].EncryptionLevel())\n\trequire.Len(t, p.longHdrPackets[0].frames, 1)\n\trequire.Equal(t, cf.Frame, p.longHdrPackets[0].frames[0].Frame)\n\trequire.NotNil(t, p.longHdrPackets[0].frames[0].Handler)\n}\n\n// ACK frames can't be sent in 0-RTT packets\nfunc TestPack0RTTPacketNoACK(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveClient)\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionInitial, true)\n\t// no further calls to get an ACK frame\n\tp, err := tp.packer.PackCoalescedPacket(true, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Nil(t, p)\n}\n\nfunc TestPackCoalescedAppData(t *testing.T) {\n\tconst maxPacketSize protocol.ByteCount = 1234\n\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x24), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x24))\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(nil, handshake.ErrKeysDropped)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.framer.EXPECT().HasData().Return(true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionHandshake, false)\n\t// don't expect any calls for a 1-RTT ACK frame\n\ttp.handshakeStream.Write([]byte(\"handshake\"))\n\texpectAppendFrames(tp.framer, nil, []ackhandler.StreamFrame{{Frame: &wire.StreamFrame{Data: []byte(\"foobar\")}}})\n\n\tp, err := tp.packer.PackCoalescedPacket(false, maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Less(t, p.buffer.Len(), protocol.ByteCount(100))\n\trequire.Len(t, p.longHdrPackets, 1)\n\trequire.Equal(t, protocol.EncryptionHandshake, p.longHdrPackets[0].EncryptionLevel())\n\trequire.Len(t, p.longHdrPackets[0].frames, 1)\n\trequire.Equal(t, []byte(\"handshake\"), p.longHdrPackets[0].frames[0].Frame.(*wire.CryptoFrame).Data)\n\trequire.NotNil(t, p.shortHdrPacket)\n\trequire.Empty(t, p.shortHdrPacket.Frames)\n\trequire.Len(t, p.shortHdrPacket.StreamFrames, 1)\n\trequire.Equal(t, []byte(\"foobar\"), p.shortHdrPacket.StreamFrames[0].Frame.Data)\n\n\thdrs, more := parsePacket(t, p.buffer.Data)\n\trequire.Len(t, hdrs, 1)\n\trequire.Equal(t, protocol.PacketTypeHandshake, hdrs[0].Type)\n\trequire.NotEmpty(t, more)\n\tparseShortHeaderPacket(t, more, testPackerConnIDLen)\n}\n\nfunc TestPackConnectionCloseCoalesced(t *testing.T) {\n\tt.Run(\"client\", func(t *testing.T) { testPackConnectionCloseCoalesced(t, protocol.PerspectiveClient) })\n\tt.Run(\"server\", func(t *testing.T) { testPackConnectionCloseCoalesced(t, protocol.PerspectiveServer) })\n}\n\nfunc testPackConnectionCloseCoalesced(t *testing.T, pers protocol.Perspective) {\n\tconst maxPacketSize protocol.ByteCount = 1234\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, pers)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(1), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(1))\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(2), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(2))\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\tswitch pers {\n\tcase protocol.PerspectiveClient:\n\t\ttp.sealingManager.EXPECT().Get0RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\t\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\t\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption0RTT).Return(protocol.PacketNumber(3), protocol.PacketNumberLen2)\n\t\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption0RTT).Return(protocol.PacketNumber(3))\n\tcase protocol.PerspectiveServer:\n\t\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\t\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(3), protocol.PacketNumberLen2)\n\t\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(3))\n\t}\n\tp, err := tp.packer.PackApplicationClose(&qerr.ApplicationError{\n\t\tErrorCode:    0x1337,\n\t\tErrorMessage: \"test error\",\n\t}, maxPacketSize, protocol.Version1)\n\trequire.NoError(t, err)\n\tswitch pers {\n\tcase protocol.PerspectiveClient:\n\t\trequire.Len(t, p.longHdrPackets, 3)\n\t\trequire.Nil(t, p.shortHdrPacket)\n\tcase protocol.PerspectiveServer:\n\t\trequire.Len(t, p.longHdrPackets, 2)\n\t\trequire.NotNil(t, p.shortHdrPacket)\n\t}\n\t// for Initial packets, the error code is replace with a transport error of type APPLICATION_ERROR\n\trequire.Equal(t, protocol.PacketTypeInitial, p.longHdrPackets[0].header.Type)\n\trequire.Equal(t, protocol.PacketNumber(1), p.longHdrPackets[0].header.PacketNumber)\n\trequire.Len(t, p.longHdrPackets[0].frames, 1)\n\trequire.IsType(t, &wire.ConnectionCloseFrame{}, p.longHdrPackets[0].frames[0].Frame)\n\tccf := p.longHdrPackets[0].frames[0].Frame.(*wire.ConnectionCloseFrame)\n\trequire.False(t, ccf.IsApplicationError)\n\trequire.Equal(t, uint64(qerr.ApplicationErrorErrorCode), ccf.ErrorCode)\n\trequire.Empty(t, ccf.ReasonPhrase)\n\t// for Handshake packets, the error code is replace with a transport error of type APPLICATION_ERROR\n\trequire.Equal(t, protocol.PacketTypeHandshake, p.longHdrPackets[1].header.Type)\n\trequire.Equal(t, protocol.PacketNumber(2), p.longHdrPackets[1].header.PacketNumber)\n\trequire.Len(t, p.longHdrPackets[1].frames, 1)\n\trequire.IsType(t, &wire.ConnectionCloseFrame{}, p.longHdrPackets[1].frames[0].Frame)\n\tccf = p.longHdrPackets[1].frames[0].Frame.(*wire.ConnectionCloseFrame)\n\trequire.False(t, ccf.IsApplicationError)\n\trequire.Equal(t, uint64(qerr.ApplicationErrorErrorCode), ccf.ErrorCode)\n\trequire.Empty(t, ccf.ReasonPhrase)\n\n\t// for application-data packet number space (1-RTT for the server, 0-RTT for the client),\n\t// the application-level error code is sent\n\n\tswitch pers {\n\tcase protocol.PerspectiveClient:\n\t\trequire.Equal(t, protocol.PacketNumber(3), p.longHdrPackets[2].header.PacketNumber)\n\t\trequire.Len(t, p.longHdrPackets[2].frames, 1)\n\t\trequire.IsType(t, &wire.ConnectionCloseFrame{}, p.longHdrPackets[2].frames[0].Frame)\n\t\tccf = p.longHdrPackets[2].frames[0].Frame.(*wire.ConnectionCloseFrame)\n\tcase protocol.PerspectiveServer:\n\t\trequire.Equal(t, protocol.PacketNumber(3), p.shortHdrPacket.PacketNumber)\n\t\trequire.Len(t, p.shortHdrPacket.Frames, 1)\n\t\trequire.IsType(t, &wire.ConnectionCloseFrame{}, p.shortHdrPacket.Frames[0].Frame)\n\t\tccf = p.shortHdrPacket.Frames[0].Frame.(*wire.ConnectionCloseFrame)\n\t}\n\trequire.True(t, ccf.IsApplicationError)\n\trequire.Equal(t, uint64(0x1337), ccf.ErrorCode)\n\trequire.Equal(t, \"test error\", ccf.ReasonPhrase)\n\n\t// the client needs to pad this packet to the max packet size\n\tswitch pers {\n\tcase protocol.PerspectiveClient:\n\t\trequire.Equal(t, maxPacketSize, p.buffer.Len())\n\tcase protocol.PerspectiveServer:\n\t\trequire.Less(t, p.buffer.Len(), protocol.ByteCount(100))\n\t}\n}\n\nfunc TestPackConnectionCloseCryptoError(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(nil, handshake.ErrKeysDropped)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\tquicErr := qerr.NewLocalCryptoError(0x42, errors.New(\"crypto error\"))\n\tquicErr.FrameType = 0x1234\n\tp, err := tp.packer.PackConnectionClose(quicErr, protocol.MaxByteCount, protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Len(t, p.longHdrPackets, 1)\n\trequire.Equal(t, protocol.PacketTypeHandshake, p.longHdrPackets[0].header.Type)\n\trequire.Len(t, p.longHdrPackets[0].frames, 1)\n\trequire.IsType(t, &wire.ConnectionCloseFrame{}, p.longHdrPackets[0].frames[0].Frame)\n\tccf := p.longHdrPackets[0].frames[0].Frame.(*wire.ConnectionCloseFrame)\n\trequire.False(t, ccf.IsApplicationError)\n\trequire.Equal(t, uint64(0x100+0x42), ccf.ErrorCode)\n\trequire.Equal(t, uint64(0x1234), ccf.FrameType)\n\t// for crypto errors, the reason phrase is cleared\n\trequire.Empty(t, ccf.ReasonPhrase)\n}\n\nfunc TestPackConnectionClose1RTT(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(nil, handshake.ErrKeysDropped)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(nil, handshake.ErrKeysDropped)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\t// expect no framer.PopStreamFrames\n\tp, err := tp.packer.PackConnectionClose(&qerr.TransportError{\n\t\tErrorCode:    qerr.CryptoBufferExceeded,\n\t\tErrorMessage: \"test error\",\n\t}, protocol.MaxByteCount, protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Empty(t, p.longHdrPackets)\n\trequire.Len(t, p.shortHdrPacket.Frames, 1)\n\trequire.IsType(t, &wire.ConnectionCloseFrame{}, p.shortHdrPacket.Frames[0].Frame)\n\tccf := p.shortHdrPacket.Frames[0].Frame.(*wire.ConnectionCloseFrame)\n\trequire.False(t, ccf.IsApplicationError)\n\trequire.Equal(t, uint64(qerr.CryptoBufferExceeded), ccf.ErrorCode)\n\trequire.Equal(t, \"test error\", ccf.ReasonPhrase)\n}\n\nfunc TestPack1RTTPacketNothingToSend(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\t// don't expect any calls to PopPacketNumber\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true)\n\ttp.framer.EXPECT().HasData()\n\t_, err := tp.packer.AppendPacket(getPacketBuffer(), protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.ErrorIs(t, err, errNothingToPack)\n}\n\nfunc TestPack1RTTPacketWithData(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.framer.EXPECT().HasData().Return(true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false)\n\tf := &wire.StreamFrame{\n\t\tStreamID: 5,\n\t\tData:     []byte{0xde, 0xca, 0xfb, 0xad},\n\t}\n\texpectAppendFrames(\n\t\ttp.framer,\n\t\t[]ackhandler.Frame{\n\t\t\t{Frame: &wire.ResetStreamFrame{}, Handler: &mtuFinderAckHandler{}}, // set any non-nil ackhandler.FrameHandler\n\t\t\t{Frame: &wire.MaxDataFrame{}},\n\t\t},\n\t\t[]ackhandler.StreamFrame{{Frame: f}},\n\t)\n\tbuffer := getPacketBuffer()\n\tbuffer.Data = append(buffer.Data, []byte(\"foobar\")...)\n\tp, err := tp.packer.AppendPacket(buffer, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\tb, err := f.Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Len(t, p.StreamFrames, 1)\n\tvar sawResetStream, sawMaxData bool\n\tfor _, frame := range p.Frames {\n\t\tswitch frame.Frame.(type) {\n\t\tcase *wire.ResetStreamFrame:\n\t\t\tsawResetStream = true\n\t\t\trequire.Equal(t, frame.Handler, &mtuFinderAckHandler{})\n\t\tcase *wire.MaxDataFrame:\n\t\t\tsawMaxData = true\n\t\t\trequire.NotNil(t, frame.Handler)\n\t\t\trequire.NotEqual(t, frame.Handler, &mtuFinderAckHandler{})\n\t\t}\n\t}\n\trequire.True(t, sawResetStream)\n\trequire.True(t, sawMaxData)\n\trequire.Equal(t, f.StreamID, p.StreamFrames[0].Frame.StreamID)\n\trequire.Equal(t, buffer.Data[:6], []byte(\"foobar\")) // make sure the packet was actually appended\n\trequire.Contains(t, string(buffer.Data), string(b))\n}\n\nfunc TestPack1RTTPacketWithACK(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\tack := &wire.AckFrame{AckRanges: []wire.AckRange{{Largest: 42, Smallest: 1}}}\n\ttp.framer.EXPECT().HasData()\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true).Return(ack)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\tp, err := tp.packer.AppendPacket(getPacketBuffer(), protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, ack, p.Ack)\n}\n\nfunc TestPackPathChallengeAndPathResponse(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.framer.EXPECT().HasData().Return(true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false)\n\tframes := []ackhandler.Frame{\n\t\t{Frame: &wire.PathChallengeFrame{}},\n\t\t{Frame: &wire.PathResponseFrame{}},\n\t\t{Frame: &wire.DataBlockedFrame{}},\n\t}\n\texpectAppendFrames(tp.framer, frames, nil)\n\tbuffer := getPacketBuffer()\n\tp, err := tp.packer.AppendPacket(buffer, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Len(t, p.Frames, 3)\n\tvar sawPathChallenge, sawPathResponse bool\n\tfor _, f := range p.Frames {\n\t\tswitch f.Frame.(type) {\n\t\tcase *wire.PathChallengeFrame:\n\t\t\tsawPathChallenge = true\n\t\t\t// this means that the frame won't be retransmitted.\n\t\t\trequire.Nil(t, f.Handler)\n\t\tcase *wire.PathResponseFrame:\n\t\t\tsawPathResponse = true\n\t\t\t// this means that the frame won't be retransmitted.\n\t\t\trequire.Nil(t, f.Handler)\n\t\tdefault:\n\t\t\trequire.NotNil(t, f.Handler)\n\t\t}\n\t}\n\trequire.True(t, sawPathChallenge)\n\trequire.True(t, sawPathResponse)\n\trequire.NotZero(t, buffer.Len())\n}\n\nfunc TestPackDatagramFrames(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.datagramQueue.Add(&wire.DatagramFrame{\n\t\tDataLenPresent: true,\n\t\tData:           []byte(\"foobar\"),\n\t})\n\ttp.framer.EXPECT().HasData()\n\tbuffer := getPacketBuffer()\n\tp, err := tp.packer.AppendPacket(buffer, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Len(t, p.Frames, 1)\n\trequire.IsType(t, &wire.DatagramFrame{}, p.Frames[0].Frame)\n\trequire.Equal(t, []byte(\"foobar\"), p.Frames[0].Frame.(*wire.DatagramFrame).Data)\n\trequire.NotEmpty(t, buffer.Data)\n}\n\nfunc TestPackLargeDatagramFrame(t *testing.T) {\n\t// If a packet contains an ACK, and doesn't have enough space for the DATAGRAM frame,\n\t// it should be skipped. It will be packed in the next packet.\n\tconst maxPacketSize = 1000\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true).Return(&wire.AckFrame{AckRanges: []wire.AckRange{{Largest: 100}}})\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\tf := &wire.DatagramFrame{DataLenPresent: true, Data: make([]byte, maxPacketSize-10)}\n\ttp.datagramQueue.Add(f)\n\ttp.framer.EXPECT().HasData()\n\tbuffer := getPacketBuffer()\n\tp, err := tp.packer.AppendPacket(buffer, maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, p.Ack)\n\trequire.Empty(t, p.Frames)\n\trequire.NotEmpty(t, buffer.Data)\n\trequire.Equal(t, f, tp.datagramQueue.Peek()) // make sure the frame is still there\n\n\t// Now try packing again, but with a smaller packet size.\n\t// The DATAGRAM frame should now be dropped, as we can't expect to ever be able tosend it out.\n\tconst newMaxPacketSize = maxPacketSize - 10\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x43), protocol.PacketNumberLen2)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.framer.EXPECT().HasData()\n\tbuffer = getPacketBuffer()\n\tp, err = tp.packer.AppendPacket(buffer, newMaxPacketSize, time.Now(), protocol.Version1)\n\trequire.ErrorIs(t, err, errNothingToPack)\n\trequire.Nil(t, tp.datagramQueue.Peek()) // make sure the frame is gone\n}\n\nfunc TestPackRetransmissions(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\tf := &wire.CryptoFrame{Data: []byte(\"Initial\")}\n\ttp.retransmissionQueue.addInitial(f)\n\ttp.retransmissionQueue.addHandshake(&wire.CryptoFrame{Data: []byte(\"Handshake\")})\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionInitial).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionInitial, false)\n\tp, err := tp.packer.PackCoalescedPacket(false, 1000, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Len(t, p.longHdrPackets, 1)\n\trequire.Equal(t, protocol.EncryptionInitial, p.longHdrPackets[0].EncryptionLevel())\n\trequire.Len(t, p.longHdrPackets[0].frames, 1)\n\trequire.Equal(t, f, p.longHdrPackets[0].frames[0].Frame)\n\trequire.NotNil(t, p.longHdrPackets[0].frames[0].Handler)\n}\n\nfunc packMaxNumNonAckElicitingAcks(t *testing.T, tp *testPacketPacker, mockCtrl *gomock.Controller, maxPacketSize protocol.ByteCount) {\n\tt.Helper()\n\tfor i := 0; i < protocol.MaxNonAckElicitingAcks; i++ {\n\t\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\t\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\t\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\t\ttp.framer.EXPECT().HasData().Return(true)\n\t\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false).Return(&wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 1, Largest: 1}}})\n\t\texpectAppendFrames(tp.framer, nil, nil)\n\t\tp, err := tp.packer.AppendPacket(getPacketBuffer(), maxPacketSize, time.Now(), protocol.Version1)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, p.Ack)\n\t\trequire.Empty(t, p.Frames)\n\t}\n}\n\nfunc TestPackEvery20thPacketAckEliciting(t *testing.T) {\n\tconst maxPacketSize = 1000\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\n\t// send the maximum number of non-ACK-eliciting packets\n\tpackMaxNumNonAckElicitingAcks(t, tp, mockCtrl, maxPacketSize)\n\n\t// Now there's nothing to send, so we shouldn't generate a packet just to send a PING\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false)\n\ttp.framer.EXPECT().HasData().Return(true)\n\texpectAppendFrames(tp.framer, nil, nil)\n\t_, err := tp.packer.AppendPacket(getPacketBuffer(), maxPacketSize, time.Now(), protocol.Version1)\n\trequire.ErrorIs(t, err, errNothingToPack)\n\n\t// Now we have an ACK to send. We should bundle a PING to make the packet ack-eliciting.\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.framer.EXPECT().HasData().Return(true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false).Return(&wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 1, Largest: 1}}})\n\texpectAppendFrames(tp.framer, nil, nil)\n\tp, err := tp.packer.AppendPacket(getPacketBuffer(), maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Len(t, p.Frames, 1)\n\trequire.Equal(t, &wire.PingFrame{}, p.Frames[0].Frame)\n\trequire.Nil(t, p.Frames[0].Handler) // make sure the PING is not retransmitted if lost\n\n\t// make sure the next packet doesn't contain another PING\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.framer.EXPECT().HasData().Return(true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false).Return(&wire.AckFrame{AckRanges: []wire.AckRange{{Smallest: 1, Largest: 1}}})\n\texpectAppendFrames(tp.framer, nil, nil)\n\tp, err = tp.packer.AppendPacket(getPacketBuffer(), maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, p.Ack)\n\trequire.Empty(t, p.Frames)\n}\n\nfunc TestPackLongHeaderPadToAtLeast4Bytes(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen1)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.EncryptionHandshake).Return(protocol.PacketNumber(0x42))\n\n\tsealer := newMockShortHeaderSealer(mockCtrl)\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(nil, handshake.ErrKeysDropped)\n\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(sealer, nil)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(nil, handshake.ErrKeysNotYetAvailable)\n\ttp.retransmissionQueue.addHandshake(&wire.PingFrame{})\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionHandshake, false)\n\n\tpacket, err := tp.packer.PackCoalescedPacket(false, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, packet)\n\trequire.Len(t, packet.longHdrPackets, 1)\n\trequire.Nil(t, packet.shortHdrPacket)\n\n\thdr, _, _, err := wire.ParsePacket(packet.buffer.Data)\n\trequire.NoError(t, err)\n\tdata := packet.buffer.Data\n\textHdr, err := hdr.ParseExtended(data)\n\trequire.NoError(t, err)\n\trequire.Equal(t, protocol.PacketNumberLen1, extHdr.PacketNumberLen)\n\n\tdata = data[extHdr.ParsedLen():]\n\trequire.Len(t, data, 4-1 /* packet number length */ +sealer.Overhead())\n\t// first bytes should be 2 PADDING frames...\n\trequire.Equal(t, []byte{0, 0}, data[:2])\n\t// ...followed by the PING frame\n\tframeParser := wire.NewFrameParser(false)\n\tl, frame, err := frameParser.ParseNext(data[2:], protocol.EncryptionHandshake, protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.IsType(t, &wire.PingFrame{}, frame)\n\trequire.Equal(t, sealer.Overhead(), len(data)-2-l)\n}\n\nfunc TestPackShortHeaderPadToAtLeast4Bytes(t *testing.T) {\n\t// small stream ID, such that only a single byte is consumed\n\tf := &wire.StreamFrame{StreamID: 0x10, Fin: true}\n\trequire.Equal(t, protocol.ByteCount(2), f.Length(protocol.Version1))\n\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen1)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\tsealer := newMockShortHeaderSealer(mockCtrl)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(sealer, nil)\n\ttp.framer.EXPECT().HasData().Return(true)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false)\n\texpectAppendFrames(tp.framer, nil, []ackhandler.StreamFrame{{Frame: f}})\n\n\tbuffer := getPacketBuffer()\n\t_, err := tp.packer.AppendPacket(buffer, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\t// cut off the tag that the mock sealer added\n\tbuffer.Data = buffer.Data[:buffer.Len()-protocol.ByteCount(sealer.Overhead())]\n\tdata := buffer.Data\n\n\tl, _, pnLen, _, err := wire.ParseShortHeader(data, testPackerConnIDLen)\n\trequire.NoError(t, err)\n\tpayload := data[l:]\n\trequire.Equal(t, protocol.PacketNumberLen1, pnLen)\n\trequire.Equal(t, 4-1 /* packet number length */, len(payload))\n\t// the first byte of the payload should be a PADDING frame...\n\trequire.Equal(t, byte(0), payload[0])\n\n\t// ... followed by the STREAM frame\n\tframeParser := wire.NewFrameParser(true)\n\tframeLen, frame, err := frameParser.ParseNext(payload[1:], protocol.Encryption1RTT, protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, f, frame)\n\trequire.Equal(t, len(payload)-1, frameLen)\n}\n\nfunc TestPackInitialProbePacket(t *testing.T) {\n\tt.Run(\"client\", func(t *testing.T) {\n\t\ttestPackProbePacket(t, protocol.EncryptionInitial, protocol.PerspectiveClient)\n\t})\n\tt.Run(\"server\", func(t *testing.T) {\n\t\ttestPackProbePacket(t, protocol.EncryptionInitial, protocol.PerspectiveServer)\n\t})\n}\n\nfunc TestPackHandshakeProbePacket(t *testing.T) {\n\tt.Run(\"client\", func(t *testing.T) {\n\t\ttestPackProbePacket(t, protocol.EncryptionHandshake, protocol.PerspectiveClient)\n\t})\n\tt.Run(\"server\", func(t *testing.T) {\n\t\ttestPackProbePacket(t, protocol.EncryptionHandshake, protocol.PerspectiveServer)\n\t})\n}\n\nfunc testPackProbePacket(t *testing.T, encLevel protocol.EncryptionLevel, perspective protocol.Perspective) {\n\tconst maxPacketSize protocol.ByteCount = 1234\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, perspective)\n\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\t\ttp.packer.initialStream.Write([]byte(\"foobar\"))\n\tcase protocol.EncryptionHandshake:\n\t\ttp.sealingManager.EXPECT().GetHandshakeSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\t\ttp.packer.handshakeStream.Write([]byte(\"foobar\"))\n\t}\n\ttp.ackFramer.EXPECT().GetAckFrame(encLevel, false)\n\ttp.pnManager.EXPECT().PeekPacketNumber(encLevel).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(encLevel).Return(protocol.PacketNumber(0x42))\n\n\tp, err := tp.packer.MaybePackProbePacket(encLevel, maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, p)\n\trequire.Len(t, p.longHdrPackets, 1)\n\tpacket := p.longHdrPackets[0]\n\trequire.Equal(t, encLevel, packet.EncryptionLevel())\n\tif encLevel == protocol.EncryptionInitial {\n\t\trequire.GreaterOrEqual(t, p.buffer.Len(), protocol.ByteCount(protocol.MinInitialPacketSize))\n\t\trequire.Equal(t, maxPacketSize, p.buffer.Len())\n\t}\n\trequire.Len(t, packet.frames, 1)\n\trequire.Equal(t, &wire.CryptoFrame{Data: []byte(\"foobar\")}, packet.frames[0].Frame)\n\thdrs, more := parsePacket(t, p.buffer.Data)\n\trequire.Len(t, hdrs, 1)\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\trequire.Equal(t, protocol.PacketTypeInitial, hdrs[0].Type)\n\tcase protocol.EncryptionHandshake:\n\t\trequire.Equal(t, protocol.PacketTypeHandshake, hdrs[0].Type)\n\t}\n\trequire.Empty(t, more)\n}\n\nfunc TestPackProbePacketNothingToSend(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveClient)\n\ttp.sealingManager.EXPECT().GetInitialSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.EncryptionInitial, true)\n\n\tp, err := tp.packer.MaybePackProbePacket(protocol.EncryptionInitial, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Nil(t, p)\n}\n\nfunc TestPack1RTTProbePacket(t *testing.T) {\n\tconst maxPacketSize protocol.ByteCount = 999\n\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, false)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42))\n\ttp.framer.EXPECT().HasData().Return(true)\n\ttp.framer.EXPECT().Append(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), protocol.Version1).DoAndReturn(func(cf []ackhandler.Frame, sf []ackhandler.StreamFrame, size protocol.ByteCount, _ time.Time, v protocol.Version) ([]ackhandler.Frame, []ackhandler.StreamFrame, protocol.ByteCount) {\n\t\tf, split := (&wire.StreamFrame{Data: make([]byte, 2*maxPacketSize)}).MaybeSplitOffFrame(size, v)\n\t\trequire.True(t, split)\n\t\treturn cf, append(sf, ackhandler.StreamFrame{Frame: f}), f.Length(v)\n\t})\n\n\tp, err := tp.packer.MaybePackProbePacket(protocol.Encryption1RTT, maxPacketSize, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, p)\n\trequire.True(t, p.IsOnlyShortHeaderPacket())\n\trequire.Empty(t, p.longHdrPackets)\n\trequire.NotNil(t, p.shortHdrPacket)\n\tpacket := p.shortHdrPacket\n\trequire.Empty(t, packet.Frames)\n\trequire.Len(t, packet.StreamFrames, 1)\n\trequire.Equal(t, maxPacketSize, packet.Length)\n}\n\nfunc TestPackProbePacketNothingToPack(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveServer)\n\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x42), protocol.PacketNumberLen2)\n\ttp.ackFramer.EXPECT().GetAckFrame(protocol.Encryption1RTT, true)\n\ttp.framer.EXPECT().HasData()\n\n\tpacket, err := tp.packer.MaybePackProbePacket(protocol.Encryption1RTT, protocol.MaxByteCount, time.Now(), protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Nil(t, packet)\n}\n\nfunc TestPackMTUProbePacket(t *testing.T) {\n\tconst (\n\t\tmaxPacketSize   protocol.ByteCount = 1000\n\t\tprobePacketSize                    = maxPacketSize + 42\n\t)\n\n\tmockCtrl := gomock.NewController(t)\n\ttp := newTestPacketPacker(t, mockCtrl, protocol.PerspectiveClient)\n\ttp.sealingManager.EXPECT().Get1RTTSealer().Return(newMockShortHeaderSealer(mockCtrl), nil)\n\ttp.pnManager.EXPECT().PeekPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x43), protocol.PacketNumberLen2)\n\ttp.pnManager.EXPECT().PopPacketNumber(protocol.Encryption1RTT).Return(protocol.PacketNumber(0x43))\n\tping := ackhandler.Frame{Frame: &wire.PingFrame{}}\n\tp, buffer, err := tp.packer.PackMTUProbePacket(ping, probePacketSize, protocol.Version1)\n\trequire.NoError(t, err)\n\trequire.Equal(t, probePacketSize, p.Length)\n\trequire.Equal(t, protocol.PacketNumber(0x43), p.PacketNumber)\n\trequire.Len(t, buffer.Data, int(probePacketSize))\n\trequire.True(t, p.IsPathMTUProbePacket)\n}\n"
        },
        {
          "name": "packet_unpacker.go",
          "type": "blob",
          "size": 7.5205078125,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype headerDecryptor interface {\n\tDecryptHeader(sample []byte, firstByte *byte, pnBytes []byte)\n}\n\ntype headerParseError struct {\n\terr error\n}\n\nfunc (e *headerParseError) Unwrap() error {\n\treturn e.err\n}\n\nfunc (e *headerParseError) Error() string {\n\treturn e.err.Error()\n}\n\ntype unpackedPacket struct {\n\thdr             *wire.ExtendedHeader\n\tencryptionLevel protocol.EncryptionLevel\n\tdata            []byte\n}\n\n// The packetUnpacker unpacks QUIC packets.\ntype packetUnpacker struct {\n\tcs handshake.CryptoSetup\n\n\tshortHdrConnIDLen int\n}\n\nvar _ unpacker = &packetUnpacker{}\n\nfunc newPacketUnpacker(cs handshake.CryptoSetup, shortHdrConnIDLen int) *packetUnpacker {\n\treturn &packetUnpacker{\n\t\tcs:                cs,\n\t\tshortHdrConnIDLen: shortHdrConnIDLen,\n\t}\n}\n\n// UnpackLongHeader unpacks a Long Header packet.\n// If the reserved bits are invalid, the error is wire.ErrInvalidReservedBits.\n// If any other error occurred when parsing the header, the error is of type headerParseError.\n// If decrypting the payload fails for any reason, the error is the error returned by the AEAD.\nfunc (u *packetUnpacker) UnpackLongHeader(hdr *wire.Header, data []byte) (*unpackedPacket, error) {\n\tvar encLevel protocol.EncryptionLevel\n\tvar extHdr *wire.ExtendedHeader\n\tvar decrypted []byte\n\t//nolint:exhaustive // Retry packets can't be unpacked.\n\tswitch hdr.Type {\n\tcase protocol.PacketTypeInitial:\n\t\tencLevel = protocol.EncryptionInitial\n\t\topener, err := u.cs.GetInitialOpener()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\textHdr, decrypted, err = u.unpackLongHeaderPacket(opener, hdr, data)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase protocol.PacketTypeHandshake:\n\t\tencLevel = protocol.EncryptionHandshake\n\t\topener, err := u.cs.GetHandshakeOpener()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\textHdr, decrypted, err = u.unpackLongHeaderPacket(opener, hdr, data)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase protocol.PacketType0RTT:\n\t\tencLevel = protocol.Encryption0RTT\n\t\topener, err := u.cs.Get0RTTOpener()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\textHdr, decrypted, err = u.unpackLongHeaderPacket(opener, hdr, data)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown packet type: %s\", hdr.Type)\n\t}\n\n\tif len(decrypted) == 0 {\n\t\treturn nil, &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"empty packet\",\n\t\t}\n\t}\n\n\treturn &unpackedPacket{\n\t\thdr:             extHdr,\n\t\tencryptionLevel: encLevel,\n\t\tdata:            decrypted,\n\t}, nil\n}\n\nfunc (u *packetUnpacker) UnpackShortHeader(rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\topener, err := u.cs.Get1RTTOpener()\n\tif err != nil {\n\t\treturn 0, 0, 0, nil, err\n\t}\n\tpn, pnLen, kp, decrypted, err := u.unpackShortHeaderPacket(opener, rcvTime, data)\n\tif err != nil {\n\t\treturn 0, 0, 0, nil, err\n\t}\n\tif len(decrypted) == 0 {\n\t\treturn 0, 0, 0, nil, &qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"empty packet\",\n\t\t}\n\t}\n\treturn pn, pnLen, kp, decrypted, nil\n}\n\nfunc (u *packetUnpacker) unpackLongHeaderPacket(opener handshake.LongHeaderOpener, hdr *wire.Header, data []byte) (*wire.ExtendedHeader, []byte, error) {\n\textHdr, parseErr := u.unpackLongHeader(opener, hdr, data)\n\t// If the reserved bits are set incorrectly, we still need to continue unpacking.\n\t// This avoids a timing side-channel, which otherwise might allow an attacker\n\t// to gain information about the header encryption.\n\tif parseErr != nil && parseErr != wire.ErrInvalidReservedBits {\n\t\treturn nil, nil, parseErr\n\t}\n\textHdrLen := extHdr.ParsedLen()\n\textHdr.PacketNumber = opener.DecodePacketNumber(extHdr.PacketNumber, extHdr.PacketNumberLen)\n\tdecrypted, err := opener.Open(data[extHdrLen:extHdrLen], data[extHdrLen:], extHdr.PacketNumber, data[:extHdrLen])\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif parseErr != nil {\n\t\treturn nil, nil, parseErr\n\t}\n\treturn extHdr, decrypted, nil\n}\n\nfunc (u *packetUnpacker) unpackShortHeaderPacket(opener handshake.ShortHeaderOpener, rcvTime time.Time, data []byte) (protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, []byte, error) {\n\tl, pn, pnLen, kp, parseErr := u.unpackShortHeader(opener, data)\n\t// If the reserved bits are set incorrectly, we still need to continue unpacking.\n\t// This avoids a timing side-channel, which otherwise might allow an attacker\n\t// to gain information about the header encryption.\n\tif parseErr != nil && parseErr != wire.ErrInvalidReservedBits {\n\t\treturn 0, 0, 0, nil, &headerParseError{parseErr}\n\t}\n\tpn = opener.DecodePacketNumber(pn, pnLen)\n\tdecrypted, err := opener.Open(data[l:l], data[l:], rcvTime, pn, kp, data[:l])\n\tif err != nil {\n\t\treturn 0, 0, 0, nil, err\n\t}\n\treturn pn, pnLen, kp, decrypted, parseErr\n}\n\nfunc (u *packetUnpacker) unpackShortHeader(hd headerDecryptor, data []byte) (int, protocol.PacketNumber, protocol.PacketNumberLen, protocol.KeyPhaseBit, error) {\n\thdrLen := 1 /* first header byte */ + u.shortHdrConnIDLen\n\tif len(data) < hdrLen+4+16 {\n\t\treturn 0, 0, 0, 0, fmt.Errorf(\"packet too small, expected at least 20 bytes after the header, got %d\", len(data)-hdrLen)\n\t}\n\torigPNBytes := make([]byte, 4)\n\tcopy(origPNBytes, data[hdrLen:hdrLen+4])\n\t// 2. decrypt the header, assuming a 4 byte packet number\n\thd.DecryptHeader(\n\t\tdata[hdrLen+4:hdrLen+4+16],\n\t\t&data[0],\n\t\tdata[hdrLen:hdrLen+4],\n\t)\n\t// 3. parse the header (and learn the actual length of the packet number)\n\tl, pn, pnLen, kp, parseErr := wire.ParseShortHeader(data, u.shortHdrConnIDLen)\n\tif parseErr != nil && parseErr != wire.ErrInvalidReservedBits {\n\t\treturn l, pn, pnLen, kp, parseErr\n\t}\n\t// 4. if the packet number is shorter than 4 bytes, replace the remaining bytes with the copy we saved earlier\n\tif pnLen != protocol.PacketNumberLen4 {\n\t\tcopy(data[hdrLen+int(pnLen):hdrLen+4], origPNBytes[int(pnLen):])\n\t}\n\treturn l, pn, pnLen, kp, parseErr\n}\n\n// The error is either nil, a wire.ErrInvalidReservedBits or of type headerParseError.\nfunc (u *packetUnpacker) unpackLongHeader(hd headerDecryptor, hdr *wire.Header, data []byte) (*wire.ExtendedHeader, error) {\n\textHdr, err := unpackLongHeader(hd, hdr, data)\n\tif err != nil && err != wire.ErrInvalidReservedBits {\n\t\treturn nil, &headerParseError{err: err}\n\t}\n\treturn extHdr, err\n}\n\nfunc unpackLongHeader(hd headerDecryptor, hdr *wire.Header, data []byte) (*wire.ExtendedHeader, error) {\n\thdrLen := hdr.ParsedLen()\n\tif protocol.ByteCount(len(data)) < hdrLen+4+16 {\n\t\t//nolint:stylecheck\n\t\treturn nil, fmt.Errorf(\"Packet too small. Expected at least 20 bytes after the header, got %d\", protocol.ByteCount(len(data))-hdrLen)\n\t}\n\t// The packet number can be up to 4 bytes long, but we won't know the length until we decrypt it.\n\t// 1. save a copy of the 4 bytes\n\torigPNBytes := make([]byte, 4)\n\tcopy(origPNBytes, data[hdrLen:hdrLen+4])\n\t// 2. decrypt the header, assuming a 4 byte packet number\n\thd.DecryptHeader(\n\t\tdata[hdrLen+4:hdrLen+4+16],\n\t\t&data[0],\n\t\tdata[hdrLen:hdrLen+4],\n\t)\n\t// 3. parse the header (and learn the actual length of the packet number)\n\textHdr, parseErr := hdr.ParseExtended(data)\n\tif parseErr != nil && parseErr != wire.ErrInvalidReservedBits {\n\t\treturn nil, parseErr\n\t}\n\t// 4. if the packet number is shorter than 4 bytes, replace the remaining bytes with the copy we saved earlier\n\tif extHdr.PacketNumberLen != protocol.PacketNumberLen4 {\n\t\tcopy(data[extHdr.ParsedLen():hdrLen+4], origPNBytes[int(extHdr.PacketNumberLen):])\n\t}\n\treturn extHdr, parseErr\n}\n"
        },
        {
          "name": "packet_unpacker_test.go",
          "type": "blob",
          "size": 14.17578125,
          "content": "package quic\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nvar _ = Describe(\"Packet Unpacker\", func() {\n\tvar (\n\t\tunpacker *packetUnpacker\n\t\tcs       *mocks.MockCryptoSetup\n\t\tconnID   = protocol.ParseConnectionID([]byte{0xde, 0xad, 0xbe, 0xef})\n\t\tpayload  = []byte(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\")\n\t)\n\n\tgetLongHeader := func(extHdr *wire.ExtendedHeader) (*wire.Header, []byte) {\n\t\tb, err := extHdr.Append(nil, protocol.Version1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpectWithOffset(1, err).ToNot(HaveOccurred())\n\t\thdrLen := len(b)\n\t\tif extHdr.Length > protocol.ByteCount(extHdr.PacketNumberLen) {\n\t\t\tb = append(b, make([]byte, int(extHdr.Length)-int(extHdr.PacketNumberLen))...)\n\t\t}\n\t\thdr, _, _, err := wire.ParsePacket(b)\n\t\tExpectWithOffset(1, err).ToNot(HaveOccurred())\n\t\treturn hdr, b[:hdrLen]\n\t}\n\n\tgetShortHeader := func(connID protocol.ConnectionID, pn protocol.PacketNumber, pnLen protocol.PacketNumberLen, kp protocol.KeyPhaseBit) []byte {\n\t\tb, err := wire.AppendShortHeader(nil, connID, pn, pnLen, kp)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\treturn b\n\t}\n\n\tBeforeEach(func() {\n\t\tcs = mocks.NewMockCryptoSetup(mockCtrl)\n\t\tunpacker = newPacketUnpacker(cs, 4)\n\t})\n\n\tIt(\"errors when the packet is too small to obtain the header decryption sample, for long headers\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          protocol.Version1,\n\t\t\t},\n\t\t\tPacketNumber:    1337,\n\t\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\tdata := append(hdrRaw, make([]byte, 2 /* fill up packet number */ +15 /* need 16 bytes */)...)\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\tcs.EXPECT().GetHandshakeOpener().Return(opener, nil)\n\t\t_, err := unpacker.UnpackLongHeader(hdr, data)\n\t\tExpect(err).To(BeAssignableToTypeOf(&headerParseError{}))\n\t\tvar headerErr *headerParseError\n\t\tExpect(errors.As(err, &headerErr)).To(BeTrue())\n\t\tExpect(err).To(MatchError(\"Packet too small. Expected at least 20 bytes after the header, got 19\"))\n\t})\n\n\tIt(\"errors when the packet is too small to obtain the header decryption sample, for short headers\", func() {\n\t\tb, err := wire.AppendShortHeader(nil, connID, 1337, protocol.PacketNumberLen2, protocol.KeyPhaseOne)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tdata := append(b, make([]byte, 2 /* fill up packet number */ +15 /* need 16 bytes */)...)\n\t\topener := mocks.NewMockShortHeaderOpener(mockCtrl)\n\t\tcs.EXPECT().Get1RTTOpener().Return(opener, nil)\n\t\t_, _, _, _, err = unpacker.UnpackShortHeader(time.Now(), data)\n\t\tExpect(err).To(BeAssignableToTypeOf(&headerParseError{}))\n\t\tExpect(err).To(MatchError(\"packet too small, expected at least 20 bytes after the header, got 19\"))\n\t})\n\n\tIt(\"opens Initial packets\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\tLength:           3 + 6, // packet number len + payload\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          protocol.Version1,\n\t\t\t},\n\t\t\tPacketNumber:    2,\n\t\t\tPacketNumberLen: 3,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\tgomock.InOrder(\n\t\t\tcs.EXPECT().GetInitialOpener().Return(opener, nil),\n\t\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\topener.EXPECT().DecodePacketNumber(protocol.PacketNumber(2), protocol.PacketNumberLen3).Return(protocol.PacketNumber(1234)),\n\t\t\topener.EXPECT().Open(gomock.Any(), payload, protocol.PacketNumber(1234), hdrRaw).Return([]byte(\"decrypted\"), nil),\n\t\t)\n\t\tpacket, err := unpacker.UnpackLongHeader(hdr, append(hdrRaw, payload...))\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(packet.encryptionLevel).To(Equal(protocol.EncryptionInitial))\n\t\tExpect(packet.data).To(Equal([]byte(\"decrypted\")))\n\t})\n\n\tIt(\"opens 0-RTT packets\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tLength:           3 + 6, // packet number len + payload\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          protocol.Version1,\n\t\t\t},\n\t\t\tPacketNumber:    20,\n\t\t\tPacketNumberLen: 2,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\tgomock.InOrder(\n\t\t\tcs.EXPECT().Get0RTTOpener().Return(opener, nil),\n\t\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\topener.EXPECT().DecodePacketNumber(protocol.PacketNumber(20), protocol.PacketNumberLen2).Return(protocol.PacketNumber(321)),\n\t\t\topener.EXPECT().Open(gomock.Any(), payload, protocol.PacketNumber(321), hdrRaw).Return([]byte(\"decrypted\"), nil),\n\t\t)\n\t\tpacket, err := unpacker.UnpackLongHeader(hdr, append(hdrRaw, payload...))\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(packet.encryptionLevel).To(Equal(protocol.Encryption0RTT))\n\t\tExpect(packet.data).To(Equal([]byte(\"decrypted\")))\n\t})\n\n\tIt(\"opens short header packets\", func() {\n\t\thdrRaw := getShortHeader(connID, 99, protocol.PacketNumberLen4, protocol.KeyPhaseOne)\n\t\topener := mocks.NewMockShortHeaderOpener(mockCtrl)\n\t\tnow := time.Now()\n\t\tgomock.InOrder(\n\t\t\tcs.EXPECT().Get1RTTOpener().Return(opener, nil),\n\t\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\topener.EXPECT().DecodePacketNumber(protocol.PacketNumber(99), protocol.PacketNumberLen4).Return(protocol.PacketNumber(321)),\n\t\t\topener.EXPECT().Open(gomock.Any(), payload, now, protocol.PacketNumber(321), protocol.KeyPhaseOne, hdrRaw).Return([]byte(\"decrypted\"), nil),\n\t\t)\n\t\tpn, pnLen, kp, data, err := unpacker.UnpackShortHeader(now, append(hdrRaw, payload...))\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(pn).To(Equal(protocol.PacketNumber(321)))\n\t\tExpect(pnLen).To(Equal(protocol.PacketNumberLen4))\n\t\tExpect(kp).To(Equal(protocol.KeyPhaseOne))\n\t\tExpect(data).To(Equal([]byte(\"decrypted\")))\n\t})\n\n\tIt(\"returns the error when getting the opener fails\", func() {\n\t\thdrRaw := getShortHeader(connID, 0x1337, protocol.PacketNumberLen2, protocol.KeyPhaseOne)\n\t\tcs.EXPECT().Get1RTTOpener().Return(nil, handshake.ErrKeysNotYetAvailable)\n\t\t_, _, _, _, err := unpacker.UnpackShortHeader(time.Now(), append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(handshake.ErrKeysNotYetAvailable))\n\t})\n\n\tIt(\"errors on empty packets, for long header packets\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          Version1,\n\t\t\t},\n\t\t\tKeyPhase:        protocol.KeyPhaseOne,\n\t\t\tPacketNumberLen: protocol.PacketNumberLen4,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\tgomock.InOrder(\n\t\t\tcs.EXPECT().GetHandshakeOpener().Return(opener, nil),\n\t\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\topener.EXPECT().DecodePacketNumber(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(321)),\n\t\t\topener.EXPECT().Open(gomock.Any(), payload, protocol.PacketNumber(321), hdrRaw).Return([]byte(\"\"), nil),\n\t\t)\n\t\t_, err := unpacker.UnpackLongHeader(hdr, append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"empty packet\",\n\t\t}))\n\t})\n\n\tIt(\"errors on empty packets, for short header packets\", func() {\n\t\thdrRaw := getShortHeader(connID, 0x42, protocol.PacketNumberLen4, protocol.KeyPhaseOne)\n\t\topener := mocks.NewMockShortHeaderOpener(mockCtrl)\n\t\tnow := time.Now()\n\t\tgomock.InOrder(\n\t\t\tcs.EXPECT().Get1RTTOpener().Return(opener, nil),\n\t\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any()),\n\t\t\topener.EXPECT().DecodePacketNumber(gomock.Any(), gomock.Any()).Return(protocol.PacketNumber(321)),\n\t\t\topener.EXPECT().Open(gomock.Any(), payload, now, protocol.PacketNumber(321), protocol.KeyPhaseOne, hdrRaw).Return([]byte(\"\"), nil),\n\t\t)\n\t\t_, _, _, _, err := unpacker.UnpackShortHeader(now, append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(&qerr.TransportError{\n\t\t\tErrorCode:    qerr.ProtocolViolation,\n\t\t\tErrorMessage: \"empty packet\",\n\t\t}))\n\t})\n\n\tIt(\"returns the error when unpacking fails\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tLength:           3, // packet number len\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          protocol.Version1,\n\t\t\t},\n\t\t\tPacketNumber:    2,\n\t\t\tPacketNumberLen: 3,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\tcs.EXPECT().GetHandshakeOpener().Return(opener, nil)\n\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any())\n\t\topener.EXPECT().DecodePacketNumber(gomock.Any(), gomock.Any())\n\t\tunpackErr := &qerr.TransportError{ErrorCode: qerr.CryptoBufferExceeded}\n\t\topener.EXPECT().Open(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, unpackErr)\n\t\t_, err := unpacker.UnpackLongHeader(hdr, append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(unpackErr))\n\t})\n\n\tIt(\"defends against the timing side-channel when the reserved bits are wrong, for long header packets\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          protocol.Version1,\n\t\t\t},\n\t\t\tPacketNumber:    0x1337,\n\t\t\tPacketNumberLen: 2,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\thdrRaw[0] |= 0xc\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any())\n\t\tcs.EXPECT().GetHandshakeOpener().Return(opener, nil)\n\t\topener.EXPECT().DecodePacketNumber(gomock.Any(), gomock.Any())\n\t\topener.EXPECT().Open(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return([]byte(\"payload\"), nil)\n\t\t_, err := unpacker.UnpackLongHeader(hdr, append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(wire.ErrInvalidReservedBits))\n\t})\n\n\tIt(\"defends against the timing side-channel when the reserved bits are wrong, for short header packets\", func() {\n\t\thdrRaw := getShortHeader(connID, 0x1337, protocol.PacketNumberLen2, protocol.KeyPhaseZero)\n\t\thdrRaw[0] |= 0x18\n\t\topener := mocks.NewMockShortHeaderOpener(mockCtrl)\n\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any())\n\t\tcs.EXPECT().Get1RTTOpener().Return(opener, nil)\n\t\topener.EXPECT().DecodePacketNumber(gomock.Any(), gomock.Any())\n\t\topener.EXPECT().Open(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return([]byte(\"payload\"), nil)\n\t\t_, _, _, _, err := unpacker.UnpackShortHeader(time.Now(), append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(wire.ErrInvalidReservedBits))\n\t})\n\n\tIt(\"returns the decryption error, when unpacking a packet with wrong reserved bits fails, for long headers\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          protocol.Version1,\n\t\t\t},\n\t\t\tPacketNumber:    0x1337,\n\t\t\tPacketNumberLen: 2,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\thdrRaw[0] |= 0x18\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any())\n\t\tcs.EXPECT().GetHandshakeOpener().Return(opener, nil)\n\t\topener.EXPECT().DecodePacketNumber(gomock.Any(), gomock.Any())\n\t\topener.EXPECT().Open(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, handshake.ErrDecryptionFailed)\n\t\t_, err := unpacker.UnpackLongHeader(hdr, append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(handshake.ErrDecryptionFailed))\n\t})\n\n\tIt(\"returns the decryption error, when unpacking a packet with wrong reserved bits fails, for short headers\", func() {\n\t\thdrRaw := getShortHeader(connID, 0x1337, protocol.PacketNumberLen2, protocol.KeyPhaseZero)\n\t\thdrRaw[0] |= 0x18\n\t\topener := mocks.NewMockShortHeaderOpener(mockCtrl)\n\t\topener.EXPECT().DecryptHeader(gomock.Any(), gomock.Any(), gomock.Any())\n\t\tcs.EXPECT().Get1RTTOpener().Return(opener, nil)\n\t\topener.EXPECT().DecodePacketNumber(gomock.Any(), gomock.Any())\n\t\topener.EXPECT().Open(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, handshake.ErrDecryptionFailed)\n\t\t_, _, _, _, err := unpacker.UnpackShortHeader(time.Now(), append(hdrRaw, payload...))\n\t\tExpect(err).To(MatchError(handshake.ErrDecryptionFailed))\n\t})\n\n\tIt(\"decrypts the header\", func() {\n\t\textHdr := &wire.ExtendedHeader{\n\t\t\tHeader: wire.Header{\n\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\tLength:           3, // packet number len\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          protocol.Version1,\n\t\t\t},\n\t\t\tPacketNumber:    0x1337,\n\t\t\tPacketNumberLen: 2,\n\t\t}\n\t\thdr, hdrRaw := getLongHeader(extHdr)\n\t\torigHdrRaw := append([]byte{}, hdrRaw...) // save a copy of the header\n\t\tfirstHdrByte := hdrRaw[0]\n\t\thdrRaw[0] ^= 0xff             // invert the first byte\n\t\thdrRaw[len(hdrRaw)-2] ^= 0xff // invert the packet number\n\t\thdrRaw[len(hdrRaw)-1] ^= 0xff // invert the packet number\n\t\tExpect(hdrRaw[0]).ToNot(Equal(firstHdrByte))\n\t\topener := mocks.NewMockLongHeaderOpener(mockCtrl)\n\t\tcs.EXPECT().GetHandshakeOpener().Return(opener, nil)\n\t\tgomock.InOrder(\n\t\t\t// we're using a 2 byte packet number, so the sample starts at the 3rd payload byte\n\t\t\topener.EXPECT().DecryptHeader(\n\t\t\t\t[]byte{3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18},\n\t\t\t\t&hdrRaw[0],\n\t\t\t\tappend(hdrRaw[len(hdrRaw)-2:], []byte{1, 2}...)).Do(func(_ []byte, firstByte *byte, pnBytes []byte) {\n\t\t\t\t*firstByte ^= 0xff // invert the first byte back\n\t\t\t\tfor i := range pnBytes {\n\t\t\t\t\tpnBytes[i] ^= 0xff // invert the packet number bytes\n\t\t\t\t}\n\t\t\t}),\n\t\t\topener.EXPECT().DecodePacketNumber(protocol.PacketNumber(0x1337), protocol.PacketNumberLen2).Return(protocol.PacketNumber(0x7331)),\n\t\t\topener.EXPECT().Open(gomock.Any(), gomock.Any(), protocol.PacketNumber(0x7331), origHdrRaw).Return([]byte{0}, nil),\n\t\t)\n\t\tdata := hdrRaw\n\t\tfor i := 1; i <= 100; i++ {\n\t\t\tdata = append(data, uint8(i))\n\t\t}\n\t\tpacket, err := unpacker.UnpackLongHeader(hdr, data)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(packet.hdr.PacketNumber).To(Equal(protocol.PacketNumber(0x7331)))\n\t})\n})\n"
        },
        {
          "name": "qlog",
          "type": "tree",
          "content": null
        },
        {
          "name": "quic_suite_linux_test.go",
          "type": "blob",
          "size": 0.1513671875,
          "content": "//go:build linux\n\npackage quic\n\nimport (\n\t\"fmt\"\n)\n\nfunc init() {\n\tmajor, minor := kernelVersion()\n\tfmt.Printf(\"Kernel Version: %d.%d\\n\\n\", major, minor)\n}\n"
        },
        {
          "name": "quic_suite_test.go",
          "type": "blob",
          "size": 2.1640625,
          "content": "package quic\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"runtime/pprof\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nfunc TestQuicGo(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"QUIC Suite\")\n}\n\nvar mockCtrl *gomock.Controller\n\nvar _ = BeforeEach(func() {\n\tmockCtrl = gomock.NewController(GinkgoT())\n})\n\nvar _ = BeforeSuite(func() {\n\tlog.SetOutput(io.Discard)\n})\n\n// in the tests for the stream deadlines we set a deadline\n// and wait to make an assertion when Read / Write was unblocked\n// on the CIs, the timing is a lot less precise, so scale every duration by this factor\nfunc scaleDuration(t time.Duration) time.Duration {\n\tscaleFactor := 1\n\tif f, err := strconv.Atoi(os.Getenv(\"TIMESCALE_FACTOR\")); err == nil { // parsing \"\" errors, so this works fine if the env is not set\n\t\tscaleFactor = f\n\t}\n\tif scaleFactor == 0 {\n\t\tpanic(\"TIMESCALE_FACTOR is 0\")\n\t}\n\treturn time.Duration(scaleFactor) * t\n}\n\nfunc newUPDConnLocalhost(t testing.TB) *net.UDPConn {\n\tt.Helper()\n\tconn, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0})\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { conn.Close() })\n\treturn conn\n}\n\nfunc areConnsRunning() bool {\n\tvar b bytes.Buffer\n\tpprof.Lookup(\"goroutine\").WriteTo(&b, 1)\n\treturn strings.Contains(b.String(), \"quic-go.(*connection).run\")\n}\n\nfunc areServersRunning() bool {\n\tvar b bytes.Buffer\n\tpprof.Lookup(\"goroutine\").WriteTo(&b, 1)\n\treturn strings.Contains(b.String(), \"quic-go.(*baseServer).run\")\n}\n\nfunc areTransportsRunning() bool {\n\tvar b bytes.Buffer\n\tpprof.Lookup(\"goroutine\").WriteTo(&b, 1)\n\treturn strings.Contains(b.String(), \"quic-go.(*Transport).listen\")\n}\n\nvar _ = AfterEach(func() {\n\tmockCtrl.Finish()\n\tEventually(areServersRunning).Should(BeFalse())\n\tEventually(areTransportsRunning()).Should(BeFalse())\n})\n\nfunc TestMain(m *testing.M) {\n\tstatus := m.Run()\n\tif status != 0 {\n\t\tos.Exit(status)\n\t}\n\tif areConnsRunning() {\n\t\tfmt.Println(\"stray connection goroutines found\")\n\t\tos.Exit(1)\n\t}\n\tif areTransportsRunning() {\n\t\tfmt.Println(\"stray transport goroutines found\")\n\t\tos.Exit(1)\n\t}\n\tos.Exit(status)\n}\n"
        },
        {
          "name": "quicvarint",
          "type": "tree",
          "content": null
        },
        {
          "name": "receive_stream.go",
          "type": "blob",
          "size": 10.3525390625,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype receiveStreamI interface {\n\tReceiveStream\n\n\thandleStreamFrame(*wire.StreamFrame, time.Time) error\n\thandleResetStreamFrame(*wire.ResetStreamFrame, time.Time) error\n\tcloseForShutdown(error)\n}\n\ntype receiveStream struct {\n\tmutex sync.Mutex\n\n\tstreamID protocol.StreamID\n\n\tsender streamSender\n\n\tframeQueue  *frameSorter\n\tfinalOffset protocol.ByteCount\n\n\tcurrentFrame       []byte\n\tcurrentFrameDone   func()\n\treadPosInFrame     int\n\tcurrentFrameIsLast bool // is the currentFrame the last frame on this stream\n\n\tqueuedStopSending   bool\n\tqueuedMaxStreamData bool\n\n\t// Set once we read the io.EOF or the cancellation error.\n\t// Note that for local cancellations, this doesn't necessarily mean that we know the final offset yet.\n\terrorRead           bool\n\tcompleted           bool // set once we've called streamSender.onStreamCompleted\n\tcancelledRemotely   bool\n\tcancelledLocally    bool\n\tcancelErr           *StreamError\n\tcloseForShutdownErr error\n\n\treadChan chan struct{}\n\treadOnce chan struct{} // cap: 1, to protect against concurrent use of Read\n\tdeadline time.Time\n\n\tflowController flowcontrol.StreamFlowController\n}\n\nvar (\n\t_ ReceiveStream            = &receiveStream{}\n\t_ receiveStreamI           = &receiveStream{}\n\t_ streamControlFrameGetter = &receiveStream{}\n)\n\nfunc newReceiveStream(\n\tstreamID protocol.StreamID,\n\tsender streamSender,\n\tflowController flowcontrol.StreamFlowController,\n) *receiveStream {\n\treturn &receiveStream{\n\t\tstreamID:       streamID,\n\t\tsender:         sender,\n\t\tflowController: flowController,\n\t\tframeQueue:     newFrameSorter(),\n\t\treadChan:       make(chan struct{}, 1),\n\t\treadOnce:       make(chan struct{}, 1),\n\t\tfinalOffset:    protocol.MaxByteCount,\n\t}\n}\n\nfunc (s *receiveStream) StreamID() protocol.StreamID {\n\treturn s.streamID\n}\n\n// Read implements io.Reader. It is not thread safe!\nfunc (s *receiveStream) Read(p []byte) (int, error) {\n\t// Concurrent use of Read is not permitted (and doesn't make any sense),\n\t// but sometimes people do it anyway.\n\t// Make sure that we only execute one call at any given time to avoid hard to debug failures.\n\ts.readOnce <- struct{}{}\n\tdefer func() { <-s.readOnce }()\n\n\ts.mutex.Lock()\n\tqueuedStreamWindowUpdate, queuedConnWindowUpdate, n, err := s.readImpl(p)\n\tcompleted := s.isNewlyCompleted()\n\ts.mutex.Unlock()\n\n\tif completed {\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n\tif queuedStreamWindowUpdate {\n\t\ts.sender.onHasStreamControlFrame(s.streamID, s)\n\t}\n\tif queuedConnWindowUpdate {\n\t\ts.sender.onHasConnectionData()\n\t}\n\treturn n, err\n}\n\nfunc (s *receiveStream) isNewlyCompleted() bool {\n\tif s.completed {\n\t\treturn false\n\t}\n\t// We need to know the final offset (either via FIN or RESET_STREAM) for flow control accounting.\n\tif s.finalOffset == protocol.MaxByteCount {\n\t\treturn false\n\t}\n\t// We're done with the stream if it was cancelled locally...\n\tif s.cancelledLocally {\n\t\ts.completed = true\n\t\treturn true\n\t}\n\t// ... or if the error (either io.EOF or the reset error) was read\n\tif s.errorRead {\n\t\ts.completed = true\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *receiveStream) readImpl(p []byte) (hasStreamWindowUpdate bool, hasConnWindowUpdate bool, _ int, _ error) {\n\tif s.currentFrameIsLast && s.currentFrame == nil {\n\t\ts.errorRead = true\n\t\treturn false, false, 0, io.EOF\n\t}\n\tif s.cancelledRemotely || s.cancelledLocally {\n\t\ts.errorRead = true\n\t\treturn false, false, 0, s.cancelErr\n\t}\n\tif s.closeForShutdownErr != nil {\n\t\treturn false, false, 0, s.closeForShutdownErr\n\t}\n\n\tvar bytesRead int\n\tvar deadlineTimer *utils.Timer\n\tfor bytesRead < len(p) {\n\t\tif s.currentFrame == nil || s.readPosInFrame >= len(s.currentFrame) {\n\t\t\ts.dequeueNextFrame()\n\t\t}\n\t\tif s.currentFrame == nil && bytesRead > 0 {\n\t\t\treturn hasStreamWindowUpdate, hasConnWindowUpdate, bytesRead, s.closeForShutdownErr\n\t\t}\n\n\t\tfor {\n\t\t\t// Stop waiting on errors\n\t\t\tif s.closeForShutdownErr != nil {\n\t\t\t\treturn hasStreamWindowUpdate, hasConnWindowUpdate, bytesRead, s.closeForShutdownErr\n\t\t\t}\n\t\t\tif s.cancelledRemotely || s.cancelledLocally {\n\t\t\t\ts.errorRead = true\n\t\t\t\treturn hasStreamWindowUpdate, hasConnWindowUpdate, 0, s.cancelErr\n\t\t\t}\n\n\t\t\tdeadline := s.deadline\n\t\t\tif !deadline.IsZero() {\n\t\t\t\tif !time.Now().Before(deadline) {\n\t\t\t\t\treturn hasStreamWindowUpdate, hasConnWindowUpdate, bytesRead, errDeadline\n\t\t\t\t}\n\t\t\t\tif deadlineTimer == nil {\n\t\t\t\t\tdeadlineTimer = utils.NewTimer()\n\t\t\t\t\tdefer deadlineTimer.Stop()\n\t\t\t\t}\n\t\t\t\tdeadlineTimer.Reset(deadline)\n\t\t\t}\n\n\t\t\tif s.currentFrame != nil || s.currentFrameIsLast {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\ts.mutex.Unlock()\n\t\t\tif deadline.IsZero() {\n\t\t\t\t<-s.readChan\n\t\t\t} else {\n\t\t\t\tselect {\n\t\t\t\tcase <-s.readChan:\n\t\t\t\tcase <-deadlineTimer.Chan():\n\t\t\t\t\tdeadlineTimer.SetRead()\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.mutex.Lock()\n\t\t\tif s.currentFrame == nil {\n\t\t\t\ts.dequeueNextFrame()\n\t\t\t}\n\t\t}\n\n\t\tif bytesRead > len(p) {\n\t\t\treturn hasStreamWindowUpdate, hasConnWindowUpdate, bytesRead, fmt.Errorf(\"BUG: bytesRead (%d) > len(p) (%d) in stream.Read\", bytesRead, len(p))\n\t\t}\n\t\tif s.readPosInFrame > len(s.currentFrame) {\n\t\t\treturn hasStreamWindowUpdate, hasConnWindowUpdate, bytesRead, fmt.Errorf(\"BUG: readPosInFrame (%d) > frame.DataLen (%d) in stream.Read\", s.readPosInFrame, len(s.currentFrame))\n\t\t}\n\n\t\tm := copy(p[bytesRead:], s.currentFrame[s.readPosInFrame:])\n\t\ts.readPosInFrame += m\n\t\tbytesRead += m\n\n\t\t// when a RESET_STREAM was received, the flow controller was already\n\t\t// informed about the final byteOffset for this stream\n\t\tif !s.cancelledRemotely {\n\t\t\thasStream, hasConn := s.flowController.AddBytesRead(protocol.ByteCount(m))\n\t\t\tif hasStream {\n\t\t\t\ts.queuedMaxStreamData = true\n\t\t\t\thasStreamWindowUpdate = true\n\t\t\t}\n\t\t\tif hasConn {\n\t\t\t\thasConnWindowUpdate = true\n\t\t\t}\n\t\t}\n\n\t\tif s.readPosInFrame >= len(s.currentFrame) && s.currentFrameIsLast {\n\t\t\ts.currentFrame = nil\n\t\t\tif s.currentFrameDone != nil {\n\t\t\t\ts.currentFrameDone()\n\t\t\t}\n\t\t\ts.errorRead = true\n\t\t\treturn hasStreamWindowUpdate, hasConnWindowUpdate, bytesRead, io.EOF\n\t\t}\n\t}\n\treturn hasStreamWindowUpdate, hasConnWindowUpdate, bytesRead, nil\n}\n\nfunc (s *receiveStream) dequeueNextFrame() {\n\tvar offset protocol.ByteCount\n\t// We're done with the last frame. Release the buffer.\n\tif s.currentFrameDone != nil {\n\t\ts.currentFrameDone()\n\t}\n\toffset, s.currentFrame, s.currentFrameDone = s.frameQueue.Pop()\n\ts.currentFrameIsLast = offset+protocol.ByteCount(len(s.currentFrame)) >= s.finalOffset\n\ts.readPosInFrame = 0\n}\n\nfunc (s *receiveStream) CancelRead(errorCode StreamErrorCode) {\n\ts.mutex.Lock()\n\tqueuedNewControlFrame := s.cancelReadImpl(errorCode)\n\tcompleted := s.isNewlyCompleted()\n\ts.mutex.Unlock()\n\n\tif queuedNewControlFrame {\n\t\ts.sender.onHasStreamControlFrame(s.streamID, s)\n\t}\n\tif completed {\n\t\ts.flowController.Abandon()\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n}\n\nfunc (s *receiveStream) cancelReadImpl(errorCode qerr.StreamErrorCode) (queuedNewControlFrame bool) {\n\tif s.cancelledLocally { // duplicate call to CancelRead\n\t\treturn false\n\t}\n\tif s.closeForShutdownErr != nil {\n\t\treturn false\n\t}\n\ts.cancelledLocally = true\n\tif s.errorRead || s.cancelledRemotely {\n\t\treturn false\n\t}\n\ts.queuedStopSending = true\n\ts.cancelErr = &StreamError{StreamID: s.streamID, ErrorCode: errorCode, Remote: false}\n\ts.signalRead()\n\treturn true\n}\n\nfunc (s *receiveStream) handleStreamFrame(frame *wire.StreamFrame, now time.Time) error {\n\ts.mutex.Lock()\n\terr := s.handleStreamFrameImpl(frame, now)\n\tcompleted := s.isNewlyCompleted()\n\ts.mutex.Unlock()\n\n\tif completed {\n\t\ts.flowController.Abandon()\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n\treturn err\n}\n\nfunc (s *receiveStream) handleStreamFrameImpl(frame *wire.StreamFrame, now time.Time) error {\n\tmaxOffset := frame.Offset + frame.DataLen()\n\tif err := s.flowController.UpdateHighestReceived(maxOffset, frame.Fin, now); err != nil {\n\t\treturn err\n\t}\n\tif frame.Fin {\n\t\ts.finalOffset = maxOffset\n\t}\n\tif s.cancelledLocally {\n\t\treturn nil\n\t}\n\tif err := s.frameQueue.Push(frame.Data, frame.Offset, frame.PutBack); err != nil {\n\t\treturn err\n\t}\n\ts.signalRead()\n\treturn nil\n}\n\nfunc (s *receiveStream) handleResetStreamFrame(frame *wire.ResetStreamFrame, now time.Time) error {\n\ts.mutex.Lock()\n\terr := s.handleResetStreamFrameImpl(frame, now)\n\tcompleted := s.isNewlyCompleted()\n\ts.mutex.Unlock()\n\n\tif completed {\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n\treturn err\n}\n\nfunc (s *receiveStream) handleResetStreamFrameImpl(frame *wire.ResetStreamFrame, now time.Time) error {\n\tif s.closeForShutdownErr != nil {\n\t\treturn nil\n\t}\n\tif err := s.flowController.UpdateHighestReceived(frame.FinalSize, true, now); err != nil {\n\t\treturn err\n\t}\n\ts.finalOffset = frame.FinalSize\n\n\t// ignore duplicate RESET_STREAM frames for this stream (after checking their final offset)\n\tif s.cancelledRemotely {\n\t\treturn nil\n\t}\n\ts.flowController.Abandon()\n\t// don't save the error if the RESET_STREAM frames was received after CancelRead was called\n\tif s.cancelledLocally {\n\t\treturn nil\n\t}\n\ts.cancelledRemotely = true\n\ts.cancelErr = &StreamError{StreamID: s.streamID, ErrorCode: frame.ErrorCode, Remote: true}\n\ts.signalRead()\n\treturn nil\n}\n\nfunc (s *receiveStream) getControlFrame(now time.Time) (_ ackhandler.Frame, ok, hasMore bool) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tif !s.queuedStopSending && !s.queuedMaxStreamData {\n\t\treturn ackhandler.Frame{}, false, false\n\t}\n\tif s.queuedStopSending {\n\t\ts.queuedStopSending = false\n\t\treturn ackhandler.Frame{\n\t\t\tFrame: &wire.StopSendingFrame{StreamID: s.streamID, ErrorCode: s.cancelErr.ErrorCode},\n\t\t}, true, s.queuedMaxStreamData\n\t}\n\n\ts.queuedMaxStreamData = false\n\treturn ackhandler.Frame{\n\t\tFrame: &wire.MaxStreamDataFrame{\n\t\t\tStreamID:          s.streamID,\n\t\t\tMaximumStreamData: s.flowController.GetWindowUpdate(now),\n\t\t},\n\t}, true, false\n}\n\nfunc (s *receiveStream) SetReadDeadline(t time.Time) error {\n\ts.mutex.Lock()\n\ts.deadline = t\n\ts.mutex.Unlock()\n\ts.signalRead()\n\treturn nil\n}\n\n// CloseForShutdown closes a stream abruptly.\n// It makes Read unblock (and return the error) immediately.\n// The peer will NOT be informed about this: the stream is closed without sending a FIN or RESET.\nfunc (s *receiveStream) closeForShutdown(err error) {\n\ts.mutex.Lock()\n\ts.closeForShutdownErr = err\n\ts.mutex.Unlock()\n\ts.signalRead()\n}\n\n// signalRead performs a non-blocking send on the readChan\nfunc (s *receiveStream) signalRead() {\n\tselect {\n\tcase s.readChan <- struct{}{}:\n\tdefault:\n\t}\n}\n"
        },
        {
          "name": "receive_stream_test.go",
          "type": "blob",
          "size": 22.5732421875,
          "content": "package quic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\ntype readerWithTimeout struct {\n\tio.Reader\n\tTimeout time.Duration\n}\n\nfunc (r *readerWithTimeout) Read(p []byte) (n int, err error) {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\tn, err = r.Reader.Read(p)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn n, err\n\tcase <-time.After(r.Timeout):\n\t\treturn 0, fmt.Errorf(\"read timeout after %s\", r.Timeout)\n\t}\n}\n\nfunc TestReceiveStreamReadData(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tstr := newReceiveStream(42, nil, mockFC)\n\n\t// read an entire frame\n\tnow := time.Now()\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(4), false, now)\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(4))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte{0xde, 0xad, 0xbe, 0xef}}, now))\n\tb := make([]byte, 4)\n\tn, err := (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 4, n)\n\trequire.Equal(t, []byte{0xde, 0xad, 0xbe, 0xef}, b)\n\n\t// split a frame across multiple reads\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(8), false, now)\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(2)).Times(2)\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 4, Data: []byte{0xca, 0xfe, 0xba, 0xbe}}, now))\n\tb = make([]byte, 2)\n\tn, err = (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, n)\n\trequire.Equal(t, []byte{0xca, 0xfe}, b)\n\tn, err = (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, n)\n\trequire.Equal(t, []byte{0xba, 0xbe}, b)\n\n\t// combine two frames\n\tgomock.InOrder(\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(11), false, now),\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(14), false, now),\n\t\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(3)).Times(2),\n\t)\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 8, Data: []byte{'f', 'o', 'o'}}, now))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 11, Data: []byte{'b', 'a', 'r'}}, now))\n\tb = make([]byte, 6)\n\tn, err = (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 6, n)\n\trequire.Equal(t, []byte{'f', 'o', 'o', 'b', 'a', 'r'}, b)\n\n\t// reordered frames\n\tgomock.InOrder(\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(20), false, now),\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(17), false, now),\n\t\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(3)).Times(2),\n\t)\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 17, Data: []byte{'b', 'a', 'z'}}, now))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 14, Data: []byte{'f', 'o', 'o'}}, now))\n\tb = make([]byte, 6)\n\tn, err = (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 6, n)\n\trequire.Equal(t, []byte{'f', 'o', 'o', 'b', 'a', 'z'}, b)\n}\n\nfunc TestReceiveStreamBlockRead(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(2), false, gomock.Any())\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(2))\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\tframe := wire.StreamFrame{Data: []byte{0xDE, 0xAD}}\n\t\ttime.Sleep(scaleDuration(5 * time.Millisecond))\n\t\terrChan <- str.handleStreamFrame(&frame, time.Now())\n\t}()\n\n\tn, err := (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(make([]byte, 2))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, n)\n\trequire.NoError(t, <-errChan)\n}\n\nfunc TestReceiveStreamReadOverlappingData(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tstr := newReceiveStream(42, nil, mockFC)\n\n\t// receive the same frame multiple times\n\tnow := time.Now()\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(4), false, now).Times(3)\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(4))\n\tfor i := 0; i < 3; i++ {\n\t\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte{0xde, 0xad, 0xbe, 0xef}}, now))\n\t}\n\tb := make([]byte, 4)\n\tn, err := (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 4, n)\n\trequire.Equal(t, []byte{0xde, 0xad, 0xbe, 0xef}, b)\n\n\t// receive overlapping data\n\tgomock.InOrder(\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(8), false, now),\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(10), false, now),\n\t\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(4)),\n\t\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(2)),\n\t)\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 4, Data: []byte{'f', 'o', 'o', 'b'}}, now))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 6, Data: []byte{'o', 'b', 'a', 'r'}}, now))\n\tb = make([]byte, 6)\n\tn, err = (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 6, n)\n\trequire.Equal(t, []byte{'f', 'o', 'o', 'b', 'a', 'r'}, b)\n}\n\nfunc TestReceiveStreamFlowControlUpdates(t *testing.T) {\n\tt.Run(\"stream\", func(t *testing.T) {\n\t\ttestReceiveStreamFlowControlUpdates(t, true, false)\n\t})\n\n\tt.Run(\"connection\", func(t *testing.T) {\n\t\ttestReceiveStreamFlowControlUpdates(t, false, true)\n\t})\n}\n\nfunc testReceiveStreamFlowControlUpdates(t *testing.T, hasStreamWindowUpdate, hasConnWindowUpdate bool) {\n\tconst streamID protocol.StreamID = 42\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(streamID, mockSender, mockFC)\n\n\tnow := time.Now()\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(4), false, now)\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte{0xde, 0xad, 0xbe, 0xef}}, now))\n\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(3)).Return(hasStreamWindowUpdate, hasConnWindowUpdate)\n\tif hasStreamWindowUpdate {\n\t\tmockSender.EXPECT().onHasStreamControlFrame(streamID, str)\n\t}\n\tif hasConnWindowUpdate {\n\t\tmockSender.EXPECT().onHasConnectionData()\n\t}\n\tn, err := (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(make([]byte, 3))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 3, n)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\tif hasStreamWindowUpdate {\n\t\tnow = now.Add(time.Second)\n\t\tmockFC.EXPECT().GetWindowUpdate(now).Return(protocol.ByteCount(1337))\n\t\tf, ok, hasMore := str.getControlFrame(now)\n\t\trequire.True(t, ok)\n\t\trequire.Equal(t, &wire.MaxStreamDataFrame{StreamID: streamID, MaximumStreamData: 1337}, f.Frame)\n\t\trequire.False(t, hasMore)\n\t}\n\tif hasConnWindowUpdate {\n\t\t_, ok, hasMore := str.getControlFrame(now)\n\t\trequire.False(t, ok)\n\t\trequire.False(t, hasMore)\n\t}\n}\n\nfunc TestReceiveStreamDeadlineInThePast(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tstr := newReceiveStream(42, nil, mockFC)\n\n\t// no data is read when the deadline is in the past\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), false, gomock.Any()).AnyTimes()\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte(\"foobar\")}, time.Now()))\n\trequire.NoError(t, str.SetReadDeadline(time.Now().Add(-time.Second)))\n\tb := make([]byte, 6)\n\tn, err := (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.Error(t, err)\n\trequire.Zero(t, n)\n\tvar nerr net.Error\n\trequire.ErrorAs(t, err, &nerr)\n\trequire.True(t, nerr.Timeout())\n\n\t// data is read when the deadline is in the future\n\trequire.NoError(t, str.SetReadDeadline(time.Now().Add(time.Second)))\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(6))\n\tn, err = (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 6, n)\n}\n\nfunc TestReceiveStreamDeadlineRemoval(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tstr := newReceiveStream(42, nil, mockFC)\n\n\tdeadline := scaleDuration(20 * time.Millisecond)\n\trequire.NoError(t, str.SetReadDeadline(time.Now().Add(deadline)))\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := (&readerWithTimeout{Reader: str, Timeout: 5 * time.Second}).Read([]byte{0})\n\t\terrChan <- err\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"read should not have returned yet: %v\", err)\n\tcase <-time.After(deadline / 2):\n\t}\n\n\t// remove the deadline after a while (but before it expires)\n\trequire.NoError(t, str.SetReadDeadline(time.Time{}))\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"read should not have returned yet: %v\", err)\n\tcase <-time.After(deadline):\n\t}\n\n\t// now set the deadline to the past to make Read return immediately\n\trequire.NoError(t, str.SetReadDeadline(time.Now().Add(-time.Second)))\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, os.ErrDeadlineExceeded)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestReceiveStreamDeadlineExtension(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tstr := newReceiveStream(42, nil, mockFC)\n\n\tdeadline := scaleDuration(20 * time.Millisecond)\n\trequire.NoError(t, str.SetReadDeadline(time.Now().Add(deadline)))\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := (&readerWithTimeout{Reader: str, Timeout: 5 * time.Second}).Read([]byte{0})\n\t\terrChan <- err\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"read should not have returned yet: %v\", err)\n\tcase <-time.After(deadline / 2):\n\t}\n\n\t// extend the deadline\n\trequire.NoError(t, str.SetReadDeadline(time.Now().Add(deadline)))\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, os.ErrDeadlineExceeded)\n\tcase <-time.After(deadline * 3 / 2):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestReceiveStreamEOFWithData(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\n\tnow := time.Now()\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(4), true, now)\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(2), false, now)\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Offset: 2, Data: []byte{0xbe, 0xef}, Fin: true}, now))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte{0xde, 0xad}}, now))\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(2)).Times(2)\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42))\n\n\tstrWithTimeout := &readerWithTimeout{Reader: str, Timeout: time.Second}\n\tb := make([]byte, 6)\n\tn, err := strWithTimeout.Read(b)\n\trequire.ErrorIs(t, err, io.EOF)\n\trequire.Equal(t, 4, n)\n\trequire.Equal(t, []byte{0xde, 0xad, 0xbe, 0xef}, b[:n])\n\tn, err = strWithTimeout.Read(b)\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, io.EOF)\n}\n\nfunc TestReceiveStreamImmediateFINs(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(0), true, gomock.Any())\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(0))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Fin: true}, time.Now()))\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42))\n\tn, err := (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(make([]byte, 4))\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, io.EOF)\n}\n\nfunc TestReceiveStreamCloseForShutdown(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\tstrWithTimeout := &readerWithTimeout{Reader: str, Timeout: time.Second}\n\n\t// Test immediate return of reads\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := strWithTimeout.Read([]byte{0})\n\t\terrChan <- err\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"read returned before closeForShutdown: %v\", err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)): // short wait to ensure read is blocked\n\t}\n\n\ttestErr := errors.New(\"test error\")\n\tstr.closeForShutdown(testErr)\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, testErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"read did not return after closeForShutdown\")\n\t}\n\n\t// following calls to Read should return the error\n\tn, err := strWithTimeout.Read([]byte{0})\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, testErr)\n\n\t// receiving a RESET_STREAM frame after closeForShutdown does nothing\n\trequire.NoError(t, str.handleResetStreamFrame(&wire.ResetStreamFrame{StreamID: 42, ErrorCode: 1234, FinalSize: 42}, time.Now()))\n\tn, err = strWithTimeout.Read([]byte{0})\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, testErr)\n\n\t// calling CancelRead after closeForShutdown does nothing\n\tstr.CancelRead(1234)\n\tn, err = strWithTimeout.Read([]byte{0})\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, testErr)\n}\n\nfunc TestReceiveStreamCancellation(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\tstrWithTimeout := &readerWithTimeout{Reader: str, Timeout: time.Second}\n\n\tmockSender.EXPECT().onHasStreamControlFrame(str.StreamID(), gomock.Any())\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := strWithTimeout.Read([]byte{0})\n\t\terrChan <- err\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"read returned before CancelRead: %v\", err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)):\n\t}\n\n\tstr.CancelRead(1234)\n\t// this queues a STOP_SENDING frame\n\tf, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\trequire.Equal(t, &wire.StopSendingFrame{StreamID: 42, ErrorCode: 1234}, f.Frame)\n\trequire.False(t, hasMore)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\tselect {\n\tcase err := <-errChan:\n\t\tvar streamErr *StreamError\n\t\trequire.ErrorAs(t, err, &streamErr)\n\t\trequire.Equal(t, StreamError{StreamID: 42, ErrorCode: 1234, Remote: false}, *streamErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"Read was not unblocked\")\n\t}\n\n\t// further Read calls return the error\n\tn, err := strWithTimeout.Read([]byte{0})\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, &StreamError{StreamID: 42, ErrorCode: 1234, Remote: false})\n\n\t// calling CancelRead again does nothing\n\t// especially:\n\t// 1. no more calls to onHasStreamControlFrame\n\t// 2. no changes of the error code returned by Read\n\tstr.CancelRead(1234)\n\tstr.CancelRead(4321)\n\tn, err = strWithTimeout.Read([]byte{0})\n\trequire.Zero(t, n)\n\t// error code unchanged\n\trequire.ErrorIs(t, err, &StreamError{StreamID: 42, ErrorCode: 1234, Remote: false})\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// receiving the FIN bit has no effect\n\tmockFC.EXPECT().Abandon()\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), true, gomock.Any()).Times(2)\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42))\n\t// receive two of them, to make sure onStreamCompleted is not called twice\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte(\"foobar\"), Fin: true}, time.Now()))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte(\"foobar\"), Fin: true}, time.Now()))\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// receiving a RESET_STREAM frame after CancelRead has no effect\n\tmockFC.EXPECT().Abandon()\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(42), true, gomock.Any())\n\trequire.NoError(t, str.handleResetStreamFrame(&wire.ResetStreamFrame{StreamID: 42, ErrorCode: 4321, FinalSize: 42}, time.Now()))\n\tn, err = strWithTimeout.Read([]byte{0})\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, &StreamError{StreamID: 42, ErrorCode: 1234, Remote: false})\n}\n\nfunc TestReceiveStreamCancelReadAfterFINReceived(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), true, gomock.Any())\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte(\"foobar\"), Fin: true}, time.Now()))\n\n\t// if the FIN was received, but not read yet, a STOP_SENDING frame is queued\n\tmockSender.EXPECT().onHasStreamControlFrame(str.StreamID(), str)\n\tmockFC.EXPECT().Abandon()\n\tstr.CancelRead(1337)\n\tf, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\trequire.Equal(t, &wire.StopSendingFrame{StreamID: 42, ErrorCode: 1337}, f.Frame)\n\trequire.False(t, hasMore)\n\n\t// Read returns the error\n\tn, err := str.Read([]byte{0})\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, &StreamError{StreamID: 42, ErrorCode: 1337, Remote: false})\n}\n\nfunc TestReceiveStreamCancelReadAfterFINRead(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), true, gomock.Any())\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(6))\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42))\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte(\"foobar\"), Fin: true}, time.Now()))\n\tn, err := str.Read(make([]byte, 10))\n\trequire.ErrorIs(t, err, io.EOF)\n\trequire.Equal(t, 6, n)\n\n\t// if the EOF was already read, no STOP_SENDING frame is queued\n\tstr.CancelRead(1234)\n\t_, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.False(t, ok)\n\trequire.False(t, hasMore)\n\n\t// Read returns the error\n\tn, err = str.Read([]byte{0})\n\trequire.Zero(t, n)\n\trequire.ErrorIs(t, err, io.EOF)\n}\n\nfunc TestReceiveStreamReset(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\tstrWithTimeout := &readerWithTimeout{Reader: str, Timeout: time.Second}\n\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := strWithTimeout.Read([]byte{0})\n\t\terrChan <- err\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"read returned before reset: %v\", err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)):\n\t}\n\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42))\n\tgomock.InOrder(\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(42), true, gomock.Any()),\n\t\tmockFC.EXPECT().Abandon(),\n\t)\n\trequire.NoError(t, str.handleResetStreamFrame(\n\t\t&wire.ResetStreamFrame{StreamID: 42, ErrorCode: 1234, FinalSize: 42},\n\t\ttime.Now(),\n\t))\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &StreamError{StreamID: 42, ErrorCode: 1234, Remote: true})\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"Read was not unblocked\")\n\t}\n\n\t// Test that further calls to Read return the error\n\t_, err := strWithTimeout.Read([]byte{0})\n\trequire.Equal(t, &StreamError{StreamID: 42, ErrorCode: 1234, Remote: true}, err)\n\n\t// further RESET_STREAM frames have no effect\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(42), true, gomock.Any())\n\trequire.NoError(t, str.handleResetStreamFrame(\n\t\t&wire.ResetStreamFrame{StreamID: 42, ErrorCode: 4321, FinalSize: 42},\n\t\ttime.Now(),\n\t))\n\tn, err := str.Read([]byte{0})\n\trequire.Zero(t, n)\n\t// error code unchanged\n\trequire.ErrorIs(t, err, &StreamError{StreamID: 42, ErrorCode: 1234, Remote: true})\n\n\t// CancelRead after a RESET_STREAM frame has no effect\n\tstr.CancelRead(100)\n\tn, err = str.Read([]byte{0})\n\trequire.Zero(t, n)\n\t// error code and remote flag unchanged\n\trequire.ErrorIs(t, err, &StreamError{StreamID: 42, ErrorCode: 1234, Remote: true})\n}\n\nfunc TestReceiveStreamResetAfterFINRead(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), true, gomock.Any())\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42))\n\trequire.NoError(t, str.handleStreamFrame(\n\t\t&wire.StreamFrame{StreamID: 42, Data: []byte(\"foobar\"), Fin: true},\n\t\ttime.Now(),\n\t))\n\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(6))\n\tn, err := str.Read(make([]byte, 6))\n\trequire.Equal(t, 6, n)\n\trequire.ErrorIs(t, err, io.EOF)\n\t// make sure that onStreamCompleted was called due to the EOF\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// Now receive a RESET_STREAM frame.\n\t// We don't expect any more calls to onStreamCompleted.\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), true, gomock.Any())\n\tmockFC.EXPECT().Abandon()\n\trequire.NoError(t, str.handleResetStreamFrame(\n\t\t&wire.ResetStreamFrame{StreamID: 42, ErrorCode: 1234, FinalSize: 6},\n\t\ttime.Now(),\n\t))\n\t// now read the error\n\tn, err = str.Read([]byte{0})\n\trequire.Error(t, err)\n\trequire.Zero(t, n)\n}\n\n// Calling Read concurrently doesn't make any sense (and is forbidden),\n// but we still want to make sure that we don't complete the stream more than once\n// if the user misuses our API.\n// This would lead to an INTERNAL_ERROR (\"tried to delete unknown outgoing stream\"),\n// which can be hard to debug.\n// Note that even without the protection built into the receiveStream, this test\n// is very timing-dependent, and would need to run a few hundred times to trigger the failure.\nfunc TestReceiveStreamConcurrentReads(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newReceiveStream(42, mockSender, mockFC)\n\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), gomock.Any(), gomock.Any()).AnyTimes()\n\tvar bytesRead protocol.ByteCount\n\tmockFC.EXPECT().AddBytesRead(gomock.Any()).Do(func(n protocol.ByteCount) (bool, bool) {\n\t\tbytesRead += n\n\t\treturn false, false\n\t}).AnyTimes()\n\n\tvar numCompleted atomic.Int32\n\tmockSender.EXPECT().onStreamCompleted(protocol.StreamID(42)).Do(func(protocol.StreamID) {\n\t\tnumCompleted.Add(1)\n\t}).AnyTimes()\n\n\tconst num = 3\n\terrChan := make(chan error, num)\n\tfor i := 0; i < num; i++ {\n\t\tgo func() {\n\t\t\t_, err := str.Read(make([]byte, 8))\n\t\t\terrChan <- err\n\t\t}()\n\t}\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte(\"foobar\"), Fin: true}, time.Now()))\n\tfor i := 0; i < num; i++ {\n\t\tselect {\n\t\tcase err := <-errChan:\n\t\t\trequire.ErrorIs(t, err, io.EOF)\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t}\n\trequire.Equal(t, protocol.ByteCount(6), bytesRead)\n\trequire.Equal(t, int32(1), numCompleted.Load())\n}\n"
        },
        {
          "name": "retransmission_queue.go",
          "type": "blob",
          "size": 4.841796875,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype retransmissionQueue struct {\n\tinitial           []wire.Frame\n\tinitialCryptoData []*wire.CryptoFrame\n\n\thandshake           []wire.Frame\n\thandshakeCryptoData []*wire.CryptoFrame\n\n\tappData []wire.Frame\n}\n\nfunc newRetransmissionQueue() *retransmissionQueue {\n\treturn &retransmissionQueue{}\n}\n\n// AddPing queues a ping.\n// It is used when a probe packet needs to be sent\nfunc (q *retransmissionQueue) AddPing(encLevel protocol.EncryptionLevel) {\n\t//nolint:exhaustive // Cannot send probe packets for 0-RTT.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\tq.addInitial(&wire.PingFrame{})\n\tcase protocol.EncryptionHandshake:\n\t\tq.addHandshake(&wire.PingFrame{})\n\tcase protocol.Encryption1RTT:\n\t\tq.addAppData(&wire.PingFrame{})\n\tdefault:\n\t\tpanic(\"unexpected encryption level\")\n\t}\n}\n\nfunc (q *retransmissionQueue) addInitial(f wire.Frame) {\n\tif cf, ok := f.(*wire.CryptoFrame); ok {\n\t\tq.initialCryptoData = append(q.initialCryptoData, cf)\n\t\treturn\n\t}\n\tq.initial = append(q.initial, f)\n}\n\nfunc (q *retransmissionQueue) addHandshake(f wire.Frame) {\n\tif cf, ok := f.(*wire.CryptoFrame); ok {\n\t\tq.handshakeCryptoData = append(q.handshakeCryptoData, cf)\n\t\treturn\n\t}\n\tq.handshake = append(q.handshake, f)\n}\n\nfunc (q *retransmissionQueue) HasInitialData() bool {\n\treturn len(q.initialCryptoData) > 0 || len(q.initial) > 0\n}\n\nfunc (q *retransmissionQueue) HasHandshakeData() bool {\n\treturn len(q.handshakeCryptoData) > 0 || len(q.handshake) > 0\n}\n\nfunc (q *retransmissionQueue) HasAppData() bool {\n\treturn len(q.appData) > 0\n}\n\nfunc (q *retransmissionQueue) addAppData(f wire.Frame) {\n\tif _, ok := f.(*wire.StreamFrame); ok {\n\t\tpanic(\"STREAM frames are handled with their respective streams.\")\n\t}\n\tq.appData = append(q.appData, f)\n}\n\nfunc (q *retransmissionQueue) GetInitialFrame(maxLen protocol.ByteCount, v protocol.Version) wire.Frame {\n\tif len(q.initialCryptoData) > 0 {\n\t\tf := q.initialCryptoData[0]\n\t\tnewFrame, needsSplit := f.MaybeSplitOffFrame(maxLen, v)\n\t\tif newFrame == nil && !needsSplit { // the whole frame fits\n\t\t\tq.initialCryptoData = q.initialCryptoData[1:]\n\t\t\treturn f\n\t\t}\n\t\tif newFrame != nil { // frame was split. Leave the original frame in the queue.\n\t\t\treturn newFrame\n\t\t}\n\t}\n\tif len(q.initial) == 0 {\n\t\treturn nil\n\t}\n\tf := q.initial[0]\n\tif f.Length(v) > maxLen {\n\t\treturn nil\n\t}\n\tq.initial = q.initial[1:]\n\treturn f\n}\n\nfunc (q *retransmissionQueue) GetHandshakeFrame(maxLen protocol.ByteCount, v protocol.Version) wire.Frame {\n\tif len(q.handshakeCryptoData) > 0 {\n\t\tf := q.handshakeCryptoData[0]\n\t\tnewFrame, needsSplit := f.MaybeSplitOffFrame(maxLen, v)\n\t\tif newFrame == nil && !needsSplit { // the whole frame fits\n\t\t\tq.handshakeCryptoData = q.handshakeCryptoData[1:]\n\t\t\treturn f\n\t\t}\n\t\tif newFrame != nil { // frame was split. Leave the original frame in the queue.\n\t\t\treturn newFrame\n\t\t}\n\t}\n\tif len(q.handshake) == 0 {\n\t\treturn nil\n\t}\n\tf := q.handshake[0]\n\tif f.Length(v) > maxLen {\n\t\treturn nil\n\t}\n\tq.handshake = q.handshake[1:]\n\treturn f\n}\n\nfunc (q *retransmissionQueue) GetAppDataFrame(maxLen protocol.ByteCount, v protocol.Version) wire.Frame {\n\tif len(q.appData) == 0 {\n\t\treturn nil\n\t}\n\tf := q.appData[0]\n\tif f.Length(v) > maxLen {\n\t\treturn nil\n\t}\n\tq.appData = q.appData[1:]\n\treturn f\n}\n\nfunc (q *retransmissionQueue) DropPackets(encLevel protocol.EncryptionLevel) {\n\t//nolint:exhaustive // Can only drop Initial and Handshake packet number space.\n\tswitch encLevel {\n\tcase protocol.EncryptionInitial:\n\t\tq.initial = nil\n\t\tq.initialCryptoData = nil\n\tcase protocol.EncryptionHandshake:\n\t\tq.handshake = nil\n\t\tq.handshakeCryptoData = nil\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unexpected encryption level: %s\", encLevel))\n\t}\n}\n\nfunc (q *retransmissionQueue) InitialAckHandler() ackhandler.FrameHandler {\n\treturn (*retransmissionQueueInitialAckHandler)(q)\n}\n\nfunc (q *retransmissionQueue) HandshakeAckHandler() ackhandler.FrameHandler {\n\treturn (*retransmissionQueueHandshakeAckHandler)(q)\n}\n\nfunc (q *retransmissionQueue) AppDataAckHandler() ackhandler.FrameHandler {\n\treturn (*retransmissionQueueAppDataAckHandler)(q)\n}\n\ntype retransmissionQueueInitialAckHandler retransmissionQueue\n\nfunc (q *retransmissionQueueInitialAckHandler) OnAcked(wire.Frame) {}\nfunc (q *retransmissionQueueInitialAckHandler) OnLost(f wire.Frame) {\n\t(*retransmissionQueue)(q).addInitial(f)\n}\n\ntype retransmissionQueueHandshakeAckHandler retransmissionQueue\n\nfunc (q *retransmissionQueueHandshakeAckHandler) OnAcked(wire.Frame) {}\nfunc (q *retransmissionQueueHandshakeAckHandler) OnLost(f wire.Frame) {\n\t(*retransmissionQueue)(q).addHandshake(f)\n}\n\ntype retransmissionQueueAppDataAckHandler retransmissionQueue\n\nfunc (q *retransmissionQueueAppDataAckHandler) OnAcked(wire.Frame) {}\nfunc (q *retransmissionQueueAppDataAckHandler) OnLost(f wire.Frame) {\n\t(*retransmissionQueue)(q).addAppData(f)\n}\n"
        },
        {
          "name": "retransmission_queue_test.go",
          "type": "blob",
          "size": 8.4033203125,
          "content": "package quic\n\nimport (\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Retransmission queue\", func() {\n\tvar q *retransmissionQueue\n\n\tBeforeEach(func() {\n\t\tq = newRetransmissionQueue()\n\t})\n\n\tContext(\"Initial data\", func() {\n\t\tIt(\"doesn't dequeue anything when it's empty\", func() {\n\t\t\tExpect(q.HasInitialData()).To(BeFalse())\n\t\t\tExpect(q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)).To(BeNil())\n\t\t})\n\n\t\tIt(\"queues and retrieves a control frame\", func() {\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tq.addInitial(f)\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tExpect(q.GetInitialFrame(f.Length(protocol.Version1)-1, protocol.Version1)).To(BeNil())\n\t\t\tExpect(q.GetInitialFrame(f.Length(protocol.Version1), protocol.Version1)).To(Equal(f))\n\t\t\tExpect(q.HasInitialData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"queues and retrieves a CRYPTO frame\", func() {\n\t\t\tf := &wire.CryptoFrame{Data: []byte(\"foobar\")}\n\t\t\tq.addInitial(f)\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tExpect(q.GetInitialFrame(f.Length(protocol.Version1), protocol.Version1)).To(Equal(f))\n\t\t\tExpect(q.HasInitialData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"returns split CRYPTO frames\", func() {\n\t\t\tf := &wire.CryptoFrame{\n\t\t\t\tOffset: 100,\n\t\t\t\tData:   []byte(\"foobar\"),\n\t\t\t}\n\t\t\tq.addInitial(f)\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tf1 := q.GetInitialFrame(f.Length(protocol.Version1)-3, protocol.Version1)\n\t\t\tExpect(f1).ToNot(BeNil())\n\t\t\tExpect(f1).To(BeAssignableToTypeOf(&wire.CryptoFrame{}))\n\t\t\tExpect(f1.(*wire.CryptoFrame).Data).To(Equal([]byte(\"foo\")))\n\t\t\tExpect(f1.(*wire.CryptoFrame).Offset).To(Equal(protocol.ByteCount(100)))\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tf2 := q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(f2).ToNot(BeNil())\n\t\t\tExpect(f2).To(BeAssignableToTypeOf(&wire.CryptoFrame{}))\n\t\t\tExpect(f2.(*wire.CryptoFrame).Data).To(Equal([]byte(\"bar\")))\n\t\t\tExpect(f2.(*wire.CryptoFrame).Offset).To(Equal(protocol.ByteCount(103)))\n\t\t\tExpect(q.HasInitialData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"returns other frames when a CRYPTO frame wouldn't fit\", func() {\n\t\t\tf := &wire.CryptoFrame{Data: []byte(\"foobar\")}\n\t\t\tq.addInitial(f)\n\t\t\tq.addInitial(&wire.PingFrame{})\n\t\t\tf1 := q.GetInitialFrame(2, protocol.Version1) // too small for a CRYPTO frame\n\t\t\tExpect(f1).ToNot(BeNil())\n\t\t\tExpect(f1).To(BeAssignableToTypeOf(&wire.PingFrame{}))\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tf2 := q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(f2).To(Equal(f))\n\t\t})\n\n\t\tIt(\"retrieves both a CRYPTO frame and a control frame\", func() {\n\t\t\tcf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tf := &wire.CryptoFrame{Data: []byte(\"foobar\")}\n\t\t\tq.addInitial(f)\n\t\t\tq.addInitial(cf)\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tExpect(q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(f))\n\t\t\tExpect(q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(cf))\n\t\t\tExpect(q.HasInitialData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops all Initial frames\", func() {\n\t\t\tq.addInitial(&wire.CryptoFrame{Data: []byte(\"foobar\")})\n\t\t\tq.addInitial(&wire.MaxDataFrame{MaximumData: 0x42})\n\t\t\tq.DropPackets(protocol.EncryptionInitial)\n\t\t\tExpect(q.HasInitialData()).To(BeFalse())\n\t\t\tExpect(q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)).To(BeNil())\n\t\t})\n\n\t\tIt(\"retransmits a frame\", func() {\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tq.InitialAckHandler().OnLost(f)\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tExpect(q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(f))\n\t\t})\n\n\t\tIt(\"adds a PING\", func() {\n\t\t\tq.AddPing(protocol.EncryptionInitial)\n\t\t\tExpect(q.HasInitialData()).To(BeTrue())\n\t\t\tExpect(q.GetInitialFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(&wire.PingFrame{}))\n\t\t})\n\t})\n\n\tContext(\"Handshake data\", func() {\n\t\tIt(\"doesn't dequeue anything when it's empty\", func() {\n\t\t\tExpect(q.HasHandshakeData()).To(BeFalse())\n\t\t\tExpect(q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)).To(BeNil())\n\t\t})\n\n\t\tIt(\"queues and retrieves a control frame\", func() {\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tq.addHandshake(f)\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tExpect(q.GetHandshakeFrame(f.Length(protocol.Version1)-1, protocol.Version1)).To(BeNil())\n\t\t\tExpect(q.GetHandshakeFrame(f.Length(protocol.Version1), protocol.Version1)).To(Equal(f))\n\t\t\tExpect(q.HasHandshakeData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"queues and retrieves a CRYPTO frame\", func() {\n\t\t\tf := &wire.CryptoFrame{Data: []byte(\"foobar\")}\n\t\t\tq.addHandshake(f)\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tExpect(q.GetHandshakeFrame(f.Length(protocol.Version1), protocol.Version1)).To(Equal(f))\n\t\t\tExpect(q.HasHandshakeData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"returns split CRYPTO frames\", func() {\n\t\t\tf := &wire.CryptoFrame{\n\t\t\t\tOffset: 100,\n\t\t\t\tData:   []byte(\"foobar\"),\n\t\t\t}\n\t\t\tq.addHandshake(f)\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tf1 := q.GetHandshakeFrame(f.Length(protocol.Version1)-3, protocol.Version1)\n\t\t\tExpect(f1).ToNot(BeNil())\n\t\t\tExpect(f1).To(BeAssignableToTypeOf(&wire.CryptoFrame{}))\n\t\t\tExpect(f1.(*wire.CryptoFrame).Data).To(Equal([]byte(\"foo\")))\n\t\t\tExpect(f1.(*wire.CryptoFrame).Offset).To(Equal(protocol.ByteCount(100)))\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tf2 := q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(f2).ToNot(BeNil())\n\t\t\tExpect(f2).To(BeAssignableToTypeOf(&wire.CryptoFrame{}))\n\t\t\tExpect(f2.(*wire.CryptoFrame).Data).To(Equal([]byte(\"bar\")))\n\t\t\tExpect(f2.(*wire.CryptoFrame).Offset).To(Equal(protocol.ByteCount(103)))\n\t\t\tExpect(q.HasHandshakeData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"returns other frames when a CRYPTO frame wouldn't fit\", func() {\n\t\t\tf := &wire.CryptoFrame{Data: []byte(\"foobar\")}\n\t\t\tq.addHandshake(f)\n\t\t\tq.addHandshake(&wire.PingFrame{})\n\t\t\tf1 := q.GetHandshakeFrame(2, protocol.Version1) // too small for a CRYPTO frame\n\t\t\tExpect(f1).ToNot(BeNil())\n\t\t\tExpect(f1).To(BeAssignableToTypeOf(&wire.PingFrame{}))\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tf2 := q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)\n\t\t\tExpect(f2).To(Equal(f))\n\t\t})\n\n\t\tIt(\"retrieves both a CRYPTO frame and a control frame\", func() {\n\t\t\tcf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tf := &wire.CryptoFrame{Data: []byte(\"foobar\")}\n\t\t\tq.addHandshake(f)\n\t\t\tq.addHandshake(cf)\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tExpect(q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(f))\n\t\t\tExpect(q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(cf))\n\t\t\tExpect(q.HasHandshakeData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"drops all Handshake frames\", func() {\n\t\t\tq.addHandshake(&wire.CryptoFrame{Data: []byte(\"foobar\")})\n\t\t\tq.addHandshake(&wire.MaxDataFrame{MaximumData: 0x42})\n\t\t\tq.DropPackets(protocol.EncryptionHandshake)\n\t\t\tExpect(q.HasHandshakeData()).To(BeFalse())\n\t\t\tExpect(q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)).To(BeNil())\n\t\t})\n\n\t\tIt(\"retransmits a frame\", func() {\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tq.HandshakeAckHandler().OnLost(f)\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tExpect(q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(f))\n\t\t})\n\n\t\tIt(\"adds a PING\", func() {\n\t\t\tq.AddPing(protocol.EncryptionHandshake)\n\t\t\tExpect(q.HasHandshakeData()).To(BeTrue())\n\t\t\tExpect(q.GetHandshakeFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(&wire.PingFrame{}))\n\t\t})\n\t})\n\n\tContext(\"Application data\", func() {\n\t\tIt(\"doesn't dequeue anything when it's empty\", func() {\n\t\t\tExpect(q.GetAppDataFrame(protocol.MaxByteCount, protocol.Version1)).To(BeNil())\n\t\t})\n\n\t\tIt(\"queues and retrieves a control frame\", func() {\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tExpect(q.HasAppData()).To(BeFalse())\n\t\t\tq.addAppData(f)\n\t\t\tExpect(q.HasAppData()).To(BeTrue())\n\t\t\tExpect(q.GetAppDataFrame(f.Length(protocol.Version1)-1, protocol.Version1)).To(BeNil())\n\t\t\tExpect(q.GetAppDataFrame(f.Length(protocol.Version1), protocol.Version1)).To(Equal(f))\n\t\t\tExpect(q.HasAppData()).To(BeFalse())\n\t\t})\n\n\t\tIt(\"retransmits a frame\", func() {\n\t\t\tf := &wire.MaxDataFrame{MaximumData: 0x42}\n\t\t\tq.AppDataAckHandler().OnLost(f)\n\t\t\tExpect(q.HasAppData()).To(BeTrue())\n\t\t\tExpect(q.GetAppDataFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(f))\n\t\t})\n\n\t\tIt(\"adds a PING\", func() {\n\t\t\tq.AddPing(protocol.Encryption1RTT)\n\t\t\tExpect(q.HasAppData()).To(BeTrue())\n\t\t\tExpect(q.GetAppDataFrame(protocol.MaxByteCount, protocol.Version1)).To(Equal(&wire.PingFrame{}))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "send_conn.go",
          "type": "blob",
          "size": 2.5908203125,
          "content": "package quic\n\nimport (\n\t\"net\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\n// A sendConn allows sending using a simple Write() on a non-connected packet conn.\ntype sendConn interface {\n\tWrite(b []byte, gsoSize uint16, ecn protocol.ECN) error\n\tClose() error\n\tLocalAddr() net.Addr\n\tRemoteAddr() net.Addr\n\n\tcapabilities() connCapabilities\n}\n\ntype sconn struct {\n\trawConn\n\n\tlocalAddr  net.Addr\n\tremoteAddr net.Addr\n\n\tlogger utils.Logger\n\n\tpacketInfoOOB []byte\n\t// If GSO enabled, and we receive a GSO error for this remote address, GSO is disabled.\n\tgotGSOError bool\n\t// Used to catch the error sometimes returned by the first sendmsg call on Linux,\n\t// see https://github.com/golang/go/issues/63322.\n\twroteFirstPacket bool\n}\n\nvar _ sendConn = &sconn{}\n\nfunc newSendConn(c rawConn, remote net.Addr, info packetInfo, logger utils.Logger) *sconn {\n\tlocalAddr := c.LocalAddr()\n\tif info.addr.IsValid() {\n\t\tif udpAddr, ok := localAddr.(*net.UDPAddr); ok {\n\t\t\taddrCopy := *udpAddr\n\t\t\taddrCopy.IP = info.addr.AsSlice()\n\t\t\tlocalAddr = &addrCopy\n\t\t}\n\t}\n\n\toob := info.OOB()\n\t// increase oob slice capacity, so we can add the UDP_SEGMENT and ECN control messages without allocating\n\tl := len(oob)\n\toob = append(oob, make([]byte, 64)...)[:l]\n\treturn &sconn{\n\t\trawConn:       c,\n\t\tlocalAddr:     localAddr,\n\t\tremoteAddr:    remote,\n\t\tpacketInfoOOB: oob,\n\t\tlogger:        logger,\n\t}\n}\n\nfunc (c *sconn) Write(p []byte, gsoSize uint16, ecn protocol.ECN) error {\n\terr := c.writePacket(p, c.remoteAddr, c.packetInfoOOB, gsoSize, ecn)\n\tif err != nil && isGSOError(err) {\n\t\t// disable GSO for future calls\n\t\tc.gotGSOError = true\n\t\tif c.logger.Debug() {\n\t\t\tc.logger.Debugf(\"GSO failed when sending to %s\", c.remoteAddr)\n\t\t}\n\t\t// send out the packets one by one\n\t\tfor len(p) > 0 {\n\t\t\tl := len(p)\n\t\t\tif l > int(gsoSize) {\n\t\t\t\tl = int(gsoSize)\n\t\t\t}\n\t\t\tif err := c.writePacket(p[:l], c.remoteAddr, c.packetInfoOOB, 0, ecn); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tp = p[l:]\n\t\t}\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc (c *sconn) writePacket(p []byte, addr net.Addr, oob []byte, gsoSize uint16, ecn protocol.ECN) error {\n\t_, err := c.WritePacket(p, addr, oob, gsoSize, ecn)\n\tif err != nil && !c.wroteFirstPacket && isPermissionError(err) {\n\t\t_, err = c.WritePacket(p, addr, oob, gsoSize, ecn)\n\t}\n\tc.wroteFirstPacket = true\n\treturn err\n}\n\nfunc (c *sconn) capabilities() connCapabilities {\n\tcapabilities := c.rawConn.capabilities()\n\tif capabilities.GSO {\n\t\tcapabilities.GSO = !c.gotGSOError\n\t}\n\treturn capabilities\n}\n\nfunc (c *sconn) RemoteAddr() net.Addr { return c.remoteAddr }\nfunc (c *sconn) LocalAddr() net.Addr  { return c.localAddr }\n"
        },
        {
          "name": "send_conn_test.go",
          "type": "blob",
          "size": 4.0224609375,
          "content": "package quic\n\nimport (\n\t\"net\"\n\t\"net/netip\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\n// Only if appendUDPSegmentSizeMsg actually appends a message (and isn't only a stub implementation),\n// GSO is actually supported on this platform.\nvar platformSupportsGSO = len(appendUDPSegmentSizeMsg([]byte{}, 1337)) > 0\n\nfunc TestSendConnLocalAndRemoteAddress(t *testing.T) {\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(192, 168, 100, 200), Port: 1337}\n\trawConn := NewMockRawConn(gomock.NewController(t))\n\trawConn.EXPECT().LocalAddr().Return(&net.UDPAddr{IP: net.IPv4(10, 11, 12, 13), Port: 14}).Times(2)\n\tc := newSendConn(\n\t\trawConn,\n\t\tremoteAddr,\n\t\tpacketInfo{addr: netip.AddrFrom4([4]byte{127, 0, 0, 42})},\n\t\tutils.DefaultLogger,\n\t)\n\trequire.Equal(t, \"127.0.0.42:14\", c.LocalAddr().String())\n\trequire.Equal(t, remoteAddr, c.RemoteAddr())\n\n\t// the local raw conn's local address is only used if we don't an address from the packet info\n\tc = newSendConn(rawConn, remoteAddr, packetInfo{}, utils.DefaultLogger)\n\trequire.Equal(t, \"10.11.12.13:14\", c.LocalAddr().String())\n}\n\nfunc TestSendConnOOB(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"we don't OOB conn on windows, and no packet info will be available\")\n\t}\n\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(192, 168, 100, 200), Port: 1337}\n\trawConn := NewMockRawConn(gomock.NewController(t))\n\trawConn.EXPECT().LocalAddr()\n\trawConn.EXPECT().capabilities().AnyTimes()\n\tpi := packetInfo{addr: netip.IPv6Loopback()}\n\trawConn.EXPECT().WritePacket([]byte(\"foobar\"), remoteAddr, pi.OOB(), uint16(0), protocol.ECT1)\n\trequire.NotEmpty(t, pi.OOB())\n\tc := newSendConn(rawConn, remoteAddr, pi, utils.DefaultLogger)\n\trequire.NoError(t, c.Write([]byte(\"foobar\"), 0, protocol.ECT1))\n}\n\nfunc TestSendConnDetectGSOFailure(t *testing.T) {\n\tif !platformSupportsGSO {\n\t\tt.Skip(\"GSO is not supported on this platform\")\n\t}\n\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(192, 168, 100, 200), Port: 1337}\n\trawConn := NewMockRawConn(gomock.NewController(t))\n\trawConn.EXPECT().LocalAddr()\n\trawConn.EXPECT().capabilities().Return(connCapabilities{GSO: true}).MinTimes(1)\n\tc := newSendConn(rawConn, remoteAddr, packetInfo{}, utils.DefaultLogger)\n\tgomock.InOrder(\n\t\trawConn.EXPECT().WritePacket([]byte(\"foobar\"), remoteAddr, gomock.Any(), uint16(4), protocol.ECNCE).Return(0, errGSO),\n\t\trawConn.EXPECT().WritePacket([]byte(\"foob\"), remoteAddr, gomock.Any(), uint16(0), protocol.ECNCE).Return(4, nil),\n\t\trawConn.EXPECT().WritePacket([]byte(\"ar\"), remoteAddr, gomock.Any(), uint16(0), protocol.ECNCE).Return(2, nil),\n\t)\n\trequire.NoError(t, c.Write([]byte(\"foobar\"), 4, protocol.ECNCE))\n\trequire.False(t, c.capabilities().GSO)\n}\n\nfunc TestSendConnSendmsgFailures(t *testing.T) {\n\tif runtime.GOOS != \"linux\" {\n\t\tt.Skip(\"only Linux exhibits this bug, we don't need to work around it on other platforms\")\n\t}\n\n\tremoteAddr := &net.UDPAddr{IP: net.IPv4(192, 168, 100, 200), Port: 1337}\n\n\tt.Run(\"first call to sendmsg fails\", func(t *testing.T) {\n\t\trawConn := NewMockRawConn(gomock.NewController(t))\n\t\trawConn.EXPECT().LocalAddr()\n\t\trawConn.EXPECT().capabilities().AnyTimes()\n\t\tc := newSendConn(rawConn, remoteAddr, packetInfo{}, utils.DefaultLogger)\n\t\tgomock.InOrder(\n\t\t\trawConn.EXPECT().WritePacket([]byte(\"foobar\"), remoteAddr, gomock.Any(), gomock.Any(), protocol.ECNCE).Return(0, errNotPermitted),\n\t\t\trawConn.EXPECT().WritePacket([]byte(\"foobar\"), remoteAddr, gomock.Any(), uint16(0), protocol.ECNCE).Return(6, nil),\n\t\t)\n\t\trequire.NoError(t, c.Write([]byte(\"foobar\"), 0, protocol.ECNCE))\n\t})\n\n\tt.Run(\"later call to sendmsg fails\", func(t *testing.T) {\n\t\trawConn := NewMockRawConn(gomock.NewController(t))\n\t\trawConn.EXPECT().LocalAddr()\n\t\trawConn.EXPECT().capabilities().AnyTimes()\n\t\tc := newSendConn(rawConn, remoteAddr, packetInfo{}, utils.DefaultLogger)\n\t\trawConn.EXPECT().WritePacket([]byte(\"foobar\"), remoteAddr, gomock.Any(), gomock.Any(), protocol.ECNCE).Return(0, errNotPermitted).Times(2)\n\t\trequire.Error(t, c.Write([]byte(\"foobar\"), 0, protocol.ECNCE))\n\t})\n}\n"
        },
        {
          "name": "send_queue.go",
          "type": "blob",
          "size": 2.4228515625,
          "content": "package quic\n\nimport \"github.com/quic-go/quic-go/internal/protocol\"\n\ntype sender interface {\n\tSend(p *packetBuffer, gsoSize uint16, ecn protocol.ECN)\n\tRun() error\n\tWouldBlock() bool\n\tAvailable() <-chan struct{}\n\tClose()\n}\n\ntype queueEntry struct {\n\tbuf     *packetBuffer\n\tgsoSize uint16\n\tecn     protocol.ECN\n}\n\ntype sendQueue struct {\n\tqueue       chan queueEntry\n\tcloseCalled chan struct{} // runStopped when Close() is called\n\trunStopped  chan struct{} // runStopped when the run loop returns\n\tavailable   chan struct{}\n\tconn        sendConn\n}\n\nvar _ sender = &sendQueue{}\n\nconst sendQueueCapacity = 8\n\nfunc newSendQueue(conn sendConn) sender {\n\treturn &sendQueue{\n\t\tconn:        conn,\n\t\trunStopped:  make(chan struct{}),\n\t\tcloseCalled: make(chan struct{}),\n\t\tavailable:   make(chan struct{}, 1),\n\t\tqueue:       make(chan queueEntry, sendQueueCapacity),\n\t}\n}\n\n// Send sends out a packet. It's guaranteed to not block.\n// Callers need to make sure that there's actually space in the send queue by calling WouldBlock.\n// Otherwise Send will panic.\nfunc (h *sendQueue) Send(p *packetBuffer, gsoSize uint16, ecn protocol.ECN) {\n\tselect {\n\tcase h.queue <- queueEntry{buf: p, gsoSize: gsoSize, ecn: ecn}:\n\t\t// clear available channel if we've reached capacity\n\t\tif len(h.queue) == sendQueueCapacity {\n\t\t\tselect {\n\t\t\tcase <-h.available:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\tcase <-h.runStopped:\n\tdefault:\n\t\tpanic(\"sendQueue.Send would have blocked\")\n\t}\n}\n\nfunc (h *sendQueue) WouldBlock() bool {\n\treturn len(h.queue) == sendQueueCapacity\n}\n\nfunc (h *sendQueue) Available() <-chan struct{} {\n\treturn h.available\n}\n\nfunc (h *sendQueue) Run() error {\n\tdefer close(h.runStopped)\n\tvar shouldClose bool\n\tfor {\n\t\tif shouldClose && len(h.queue) == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tselect {\n\t\tcase <-h.closeCalled:\n\t\t\th.closeCalled = nil // prevent this case from being selected again\n\t\t\t// make sure that all queued packets are actually sent out\n\t\t\tshouldClose = true\n\t\tcase e := <-h.queue:\n\t\t\tif err := h.conn.Write(e.buf.Data, e.gsoSize, e.ecn); err != nil {\n\t\t\t\t// This additional check enables:\n\t\t\t\t// 1. Checking for \"datagram too large\" message from the kernel, as such,\n\t\t\t\t// 2. Path MTU discovery,and\n\t\t\t\t// 3. Eventual detection of loss PingFrame.\n\t\t\t\tif !isSendMsgSizeErr(err) {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\te.buf.Release()\n\t\t\tselect {\n\t\t\tcase h.available <- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (h *sendQueue) Close() {\n\tclose(h.closeCalled)\n\t// wait until the run loop returned\n\t<-h.runStopped\n}\n"
        },
        {
          "name": "send_queue_test.go",
          "type": "blob",
          "size": 4.7509765625,
          "content": "package quic\n\nimport (\n\t\"errors\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nvar _ = Describe(\"Send Queue\", func() {\n\tvar q sender\n\tvar c *MockSendConn\n\n\tBeforeEach(func() {\n\t\tc = NewMockSendConn(mockCtrl)\n\t\tq = newSendQueue(c)\n\t})\n\n\tgetPacket := func(b []byte) *packetBuffer {\n\t\tbuf := getPacketBuffer()\n\t\tbuf.Data = buf.Data[:len(b)]\n\t\tcopy(buf.Data, b)\n\t\treturn buf\n\t}\n\n\tIt(\"sends a packet\", func() {\n\t\tp := getPacket([]byte(\"foobar\"))\n\t\tq.Send(p, 10, protocol.ECT1) // make sure the packet size is passed through to the conn\n\n\t\twritten := make(chan struct{})\n\t\tc.EXPECT().Write([]byte(\"foobar\"), uint16(10), protocol.ECT1).Do(func([]byte, uint16, protocol.ECN) error { close(written); return nil })\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tq.Run()\n\t\t\tclose(done)\n\t\t}()\n\n\t\tEventually(written).Should(BeClosed())\n\t\tq.Close()\n\t\tEventually(done).Should(BeClosed())\n\t})\n\n\tIt(\"panics when Send() is called although there's no space in the queue\", func() {\n\t\tfor i := 0; i < sendQueueCapacity; i++ {\n\t\t\tExpect(q.WouldBlock()).To(BeFalse())\n\t\t\tq.Send(getPacket([]byte(\"foobar\")), 6, protocol.ECNNon)\n\t\t}\n\t\tExpect(q.WouldBlock()).To(BeTrue())\n\t\tExpect(func() { q.Send(getPacket([]byte(\"raboof\")), 6, protocol.ECNNon) }).To(Panic())\n\t})\n\n\tIt(\"signals when sending is possible again\", func() {\n\t\tExpect(q.WouldBlock()).To(BeFalse())\n\t\tq.Send(getPacket([]byte(\"foobar1\")), 6, protocol.ECNNon)\n\t\tConsistently(q.Available()).ShouldNot(Receive())\n\n\t\t// now start sending out packets. This should free up queue space.\n\t\tc.EXPECT().Write(gomock.Any(), gomock.Any(), protocol.ECNNon).MinTimes(1).MaxTimes(2)\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tq.Run()\n\t\t\tclose(done)\n\t\t}()\n\n\t\tEventually(q.Available()).Should(Receive())\n\t\tExpect(q.WouldBlock()).To(BeFalse())\n\t\tExpect(func() { q.Send(getPacket([]byte(\"foobar2\")), 7, protocol.ECNNon) }).ToNot(Panic())\n\n\t\tq.Close()\n\t\tEventually(done).Should(BeClosed())\n\t})\n\n\tIt(\"signals when sending is possible again, when the first write succeeded\", func() {\n\t\twrite := make(chan struct{}, 1)\n\t\twritten := make(chan struct{}, 100)\n\t\t// now start sending out packets. This should free up queue space.\n\t\tc.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(func([]byte, uint16, protocol.ECN) error {\n\t\t\twritten <- struct{}{}\n\t\t\t<-write\n\t\t\treturn nil\n\t\t}).AnyTimes()\n\t\t// allow the first packet to be sent immediately\n\t\twrite <- struct{}{}\n\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tq.Run()\n\t\t\tclose(done)\n\t\t}()\n\n\t\tq.Send(getPacket([]byte(\"foobar\")), 6, protocol.ECNNon)\n\t\t<-written\n\n\t\t// now fill up the send queue\n\t\tfor i := 0; i < sendQueueCapacity; i++ {\n\t\t\tExpect(q.WouldBlock()).To(BeFalse())\n\t\t\tq.Send(getPacket([]byte(\"foobar\")), 6, protocol.ECNNon)\n\t\t}\n\t\t// One more packet is queued when it's picked up by Run and written to the connection.\n\t\t// In this test, it's blocked on write channel in the mocked Write call.\n\t\t<-written\n\t\tEventually(q.WouldBlock()).Should(BeFalse())\n\t\tq.Send(getPacket([]byte(\"foobar\")), 6, protocol.ECNNon)\n\n\t\tExpect(q.WouldBlock()).To(BeTrue())\n\t\tConsistently(q.Available()).ShouldNot(Receive())\n\t\twrite <- struct{}{}\n\t\tEventually(q.Available()).Should(Receive())\n\n\t\t// test shutdown\n\t\tfor i := 0; i < sendQueueCapacity; i++ {\n\t\t\twrite <- struct{}{}\n\t\t}\n\n\t\tq.Close()\n\t\tEventually(done).Should(BeClosed())\n\t})\n\n\tIt(\"does not block pending send after the queue has stopped running\", func() {\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tq.Run()\n\t\t\tclose(done)\n\t\t}()\n\n\t\t// the run loop exits if there is a write error\n\t\ttestErr := errors.New(\"test error\")\n\t\tc.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).Return(testErr)\n\t\tq.Send(getPacket([]byte(\"foobar\")), 6, protocol.ECNNon)\n\t\tEventually(done).Should(BeClosed())\n\n\t\tsent := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tq.Send(getPacket([]byte(\"raboof\")), 6, protocol.ECNNon)\n\t\t\tq.Send(getPacket([]byte(\"quux\")), 4, protocol.ECNNon)\n\t\t\tclose(sent)\n\t\t}()\n\n\t\tEventually(sent).Should(BeClosed())\n\t})\n\n\tIt(\"blocks Close() until the packet has been sent out\", func() {\n\t\twritten := make(chan []byte)\n\t\tc.EXPECT().Write(gomock.Any(), gomock.Any(), gomock.Any()).Do(func(p []byte, _ uint16, _ protocol.ECN) error { written <- p; return nil })\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tq.Run()\n\t\t\tclose(done)\n\t\t}()\n\n\t\tq.Send(getPacket([]byte(\"foobar\")), 6, protocol.ECNNon)\n\n\t\tclosed := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tq.Close()\n\t\t\tclose(closed)\n\t\t}()\n\n\t\tConsistently(closed).ShouldNot(BeClosed())\n\t\t// now write the packet\n\t\tExpect(written).To(Receive())\n\t\tEventually(done).Should(BeClosed())\n\t\tEventually(closed).Should(BeClosed())\n\t})\n})\n"
        },
        {
          "name": "send_stream.go",
          "type": "blob",
          "size": 16.39453125,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype sendStreamI interface {\n\tSendStream\n\thandleStopSendingFrame(*wire.StopSendingFrame)\n\thasData() bool\n\tpopStreamFrame(protocol.ByteCount, protocol.Version) (_ ackhandler.StreamFrame, _ *wire.StreamDataBlockedFrame, hasMore bool)\n\tcloseForShutdown(error)\n\tupdateSendWindow(protocol.ByteCount)\n}\n\ntype sendStream struct {\n\tmutex sync.Mutex\n\n\tnumOutstandingFrames int64 // outstanding STREAM and RESET_STREAM frames\n\tretransmissionQueue  []*wire.StreamFrame\n\n\tctx       context.Context\n\tctxCancel context.CancelCauseFunc\n\n\tstreamID protocol.StreamID\n\tsender   streamSender\n\n\twriteOffset protocol.ByteCount\n\n\tcancelWriteErr      *StreamError\n\tcloseForShutdownErr error\n\n\tqueuedResetStreamFrame bool\n\n\tfinishedWriting bool // set once Close() is called\n\tfinSent         bool // set when a STREAM_FRAME with FIN bit has been sent\n\t// Set when the application knows about the cancellation.\n\t// This can happen because the application called CancelWrite,\n\t// or because Write returned the error (for remote cancellations).\n\tcancellationFlagged bool\n\tcompleted           bool // set when this stream has been reported to the streamSender as completed\n\n\tdataForWriting []byte // during a Write() call, this slice is the part of p that still needs to be sent out\n\tnextFrame      *wire.StreamFrame\n\n\twriteChan chan struct{}\n\twriteOnce chan struct{}\n\tdeadline  time.Time\n\n\tflowController flowcontrol.StreamFlowController\n}\n\nvar (\n\t_ SendStream               = &sendStream{}\n\t_ sendStreamI              = &sendStream{}\n\t_ streamControlFrameGetter = &sendStream{}\n)\n\nfunc newSendStream(\n\tctx context.Context,\n\tstreamID protocol.StreamID,\n\tsender streamSender,\n\tflowController flowcontrol.StreamFlowController,\n) *sendStream {\n\ts := &sendStream{\n\t\tstreamID:       streamID,\n\t\tsender:         sender,\n\t\tflowController: flowController,\n\t\twriteChan:      make(chan struct{}, 1),\n\t\twriteOnce:      make(chan struct{}, 1), // cap: 1, to protect against concurrent use of Write\n\t}\n\ts.ctx, s.ctxCancel = context.WithCancelCause(ctx)\n\treturn s\n}\n\nfunc (s *sendStream) StreamID() protocol.StreamID {\n\treturn s.streamID // same for receiveStream and sendStream\n}\n\nfunc (s *sendStream) Write(p []byte) (int, error) {\n\t// Concurrent use of Write is not permitted (and doesn't make any sense),\n\t// but sometimes people do it anyway.\n\t// Make sure that we only execute one call at any given time to avoid hard to debug failures.\n\ts.writeOnce <- struct{}{}\n\tdefer func() { <-s.writeOnce }()\n\n\tisNewlyCompleted, n, err := s.write(p)\n\tif isNewlyCompleted {\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n\treturn n, err\n}\n\nfunc (s *sendStream) write(p []byte) (bool /* is newly completed */, int, error) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tif s.finishedWriting {\n\t\treturn false, 0, fmt.Errorf(\"write on closed stream %d\", s.streamID)\n\t}\n\tif s.cancelWriteErr != nil {\n\t\ts.cancellationFlagged = true\n\t\treturn s.isNewlyCompleted(), 0, s.cancelWriteErr\n\t}\n\tif s.closeForShutdownErr != nil {\n\t\treturn false, 0, s.closeForShutdownErr\n\t}\n\tif !s.deadline.IsZero() && !time.Now().Before(s.deadline) {\n\t\treturn false, 0, errDeadline\n\t}\n\tif len(p) == 0 {\n\t\treturn false, 0, nil\n\t}\n\n\ts.dataForWriting = p\n\n\tvar (\n\t\tdeadlineTimer  *utils.Timer\n\t\tbytesWritten   int\n\t\tnotifiedSender bool\n\t)\n\tfor {\n\t\tvar copied bool\n\t\tvar deadline time.Time\n\t\t// As soon as dataForWriting becomes smaller than a certain size x, we copy all the data to a STREAM frame (s.nextFrame),\n\t\t// which can then be popped the next time we assemble a packet.\n\t\t// This allows us to return Write() when all data but x bytes have been sent out.\n\t\t// When the user now calls Close(), this is much more likely to happen before we popped that last STREAM frame,\n\t\t// allowing us to set the FIN bit on that frame (instead of sending an empty STREAM frame with FIN).\n\t\tif s.canBufferStreamFrame() && len(s.dataForWriting) > 0 {\n\t\t\tif s.nextFrame == nil {\n\t\t\t\tf := wire.GetStreamFrame()\n\t\t\t\tf.Offset = s.writeOffset\n\t\t\t\tf.StreamID = s.streamID\n\t\t\t\tf.DataLenPresent = true\n\t\t\t\tf.Data = f.Data[:len(s.dataForWriting)]\n\t\t\t\tcopy(f.Data, s.dataForWriting)\n\t\t\t\ts.nextFrame = f\n\t\t\t} else {\n\t\t\t\tl := len(s.nextFrame.Data)\n\t\t\t\ts.nextFrame.Data = s.nextFrame.Data[:l+len(s.dataForWriting)]\n\t\t\t\tcopy(s.nextFrame.Data[l:], s.dataForWriting)\n\t\t\t}\n\t\t\ts.dataForWriting = nil\n\t\t\tbytesWritten = len(p)\n\t\t\tcopied = true\n\t\t} else {\n\t\t\tbytesWritten = len(p) - len(s.dataForWriting)\n\t\t\tdeadline = s.deadline\n\t\t\tif !deadline.IsZero() {\n\t\t\t\tif !time.Now().Before(deadline) {\n\t\t\t\t\ts.dataForWriting = nil\n\t\t\t\t\treturn false, bytesWritten, errDeadline\n\t\t\t\t}\n\t\t\t\tif deadlineTimer == nil {\n\t\t\t\t\tdeadlineTimer = utils.NewTimer()\n\t\t\t\t\tdefer deadlineTimer.Stop()\n\t\t\t\t}\n\t\t\t\tdeadlineTimer.Reset(deadline)\n\t\t\t}\n\t\t\tif s.dataForWriting == nil || s.cancelWriteErr != nil || s.closeForShutdownErr != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\ts.mutex.Unlock()\n\t\tif !notifiedSender {\n\t\t\ts.sender.onHasStreamData(s.streamID, s) // must be called without holding the mutex\n\t\t\tnotifiedSender = true\n\t\t}\n\t\tif copied {\n\t\t\ts.mutex.Lock()\n\t\t\tbreak\n\t\t}\n\t\tif deadline.IsZero() {\n\t\t\t<-s.writeChan\n\t\t} else {\n\t\t\tselect {\n\t\t\tcase <-s.writeChan:\n\t\t\tcase <-deadlineTimer.Chan():\n\t\t\t\tdeadlineTimer.SetRead()\n\t\t\t}\n\t\t}\n\t\ts.mutex.Lock()\n\t}\n\n\tif bytesWritten == len(p) {\n\t\treturn false, bytesWritten, nil\n\t}\n\tif s.closeForShutdownErr != nil {\n\t\treturn false, bytesWritten, s.closeForShutdownErr\n\t} else if s.cancelWriteErr != nil {\n\t\ts.cancellationFlagged = true\n\t\treturn s.isNewlyCompleted(), bytesWritten, s.cancelWriteErr\n\t}\n\treturn false, bytesWritten, nil\n}\n\nfunc (s *sendStream) canBufferStreamFrame() bool {\n\tvar l protocol.ByteCount\n\tif s.nextFrame != nil {\n\t\tl = s.nextFrame.DataLen()\n\t}\n\treturn l+protocol.ByteCount(len(s.dataForWriting)) <= protocol.MaxPacketBufferSize\n}\n\n// popStreamFrame returns the next STREAM frame that is supposed to be sent on this stream\n// maxBytes is the maximum length this frame (including frame header) will have.\nfunc (s *sendStream) popStreamFrame(maxBytes protocol.ByteCount, v protocol.Version) (_ ackhandler.StreamFrame, _ *wire.StreamDataBlockedFrame, hasMore bool) {\n\ts.mutex.Lock()\n\tf, blocked, hasMoreData := s.popNewOrRetransmittedStreamFrame(maxBytes, v)\n\tif f != nil {\n\t\ts.numOutstandingFrames++\n\t}\n\ts.mutex.Unlock()\n\n\tif f == nil {\n\t\treturn ackhandler.StreamFrame{}, blocked, hasMoreData\n\t}\n\treturn ackhandler.StreamFrame{\n\t\tFrame:   f,\n\t\tHandler: (*sendStreamAckHandler)(s),\n\t}, blocked, hasMoreData\n}\n\nfunc (s *sendStream) popNewOrRetransmittedStreamFrame(maxBytes protocol.ByteCount, v protocol.Version) (_ *wire.StreamFrame, _ *wire.StreamDataBlockedFrame, hasMoreData bool) {\n\tif s.cancelWriteErr != nil || s.closeForShutdownErr != nil {\n\t\treturn nil, nil, false\n\t}\n\n\tif len(s.retransmissionQueue) > 0 {\n\t\tf, hasMoreRetransmissions := s.maybeGetRetransmission(maxBytes, v)\n\t\tif f != nil || hasMoreRetransmissions {\n\t\t\tif f == nil {\n\t\t\t\treturn nil, nil, true\n\t\t\t}\n\t\t\t// We always claim that we have more data to send.\n\t\t\t// This might be incorrect, in which case there'll be a spurious call to popStreamFrame in the future.\n\t\t\treturn f, nil, true\n\t\t}\n\t}\n\n\tif len(s.dataForWriting) == 0 && s.nextFrame == nil {\n\t\tif s.finishedWriting && !s.finSent {\n\t\t\ts.finSent = true\n\t\t\treturn &wire.StreamFrame{\n\t\t\t\tStreamID:       s.streamID,\n\t\t\t\tOffset:         s.writeOffset,\n\t\t\t\tDataLenPresent: true,\n\t\t\t\tFin:            true,\n\t\t\t}, nil, false\n\t\t}\n\t\treturn nil, nil, false\n\t}\n\n\tsendWindow := s.flowController.SendWindowSize()\n\tif sendWindow == 0 {\n\t\treturn nil, nil, true\n\t}\n\n\tf, hasMoreData := s.popNewStreamFrame(maxBytes, sendWindow, v)\n\tif f == nil {\n\t\treturn nil, nil, hasMoreData\n\t}\n\tif f.DataLen() > 0 {\n\t\ts.writeOffset += f.DataLen()\n\t\ts.flowController.AddBytesSent(f.DataLen())\n\t}\n\tvar blocked *wire.StreamDataBlockedFrame\n\t// If the entire send window is used, the stream might have become blocked on stream-level flow control.\n\t// This is not guaranteed though, because the stream might also have been blocked on connection-level flow control.\n\tif f.DataLen() == sendWindow && s.flowController.IsNewlyBlocked() {\n\t\tblocked = &wire.StreamDataBlockedFrame{StreamID: s.streamID, MaximumStreamData: s.writeOffset}\n\t}\n\tf.Fin = s.finishedWriting && s.dataForWriting == nil && s.nextFrame == nil && !s.finSent\n\tif f.Fin {\n\t\ts.finSent = true\n\t}\n\treturn f, blocked, hasMoreData\n}\n\nfunc (s *sendStream) popNewStreamFrame(maxBytes, sendWindow protocol.ByteCount, v protocol.Version) (*wire.StreamFrame, bool) {\n\tif s.nextFrame != nil {\n\t\tmaxDataLen := min(sendWindow, s.nextFrame.MaxDataLen(maxBytes, v))\n\t\tif maxDataLen == 0 {\n\t\t\treturn nil, true\n\t\t}\n\t\tnextFrame := s.nextFrame\n\t\ts.nextFrame = nil\n\t\tif nextFrame.DataLen() > maxDataLen {\n\t\t\ts.nextFrame = wire.GetStreamFrame()\n\t\t\ts.nextFrame.StreamID = s.streamID\n\t\t\ts.nextFrame.Offset = s.writeOffset + maxDataLen\n\t\t\ts.nextFrame.Data = s.nextFrame.Data[:nextFrame.DataLen()-maxDataLen]\n\t\t\ts.nextFrame.DataLenPresent = true\n\t\t\tcopy(s.nextFrame.Data, nextFrame.Data[maxDataLen:])\n\t\t\tnextFrame.Data = nextFrame.Data[:maxDataLen]\n\t\t} else {\n\t\t\ts.signalWrite()\n\t\t}\n\t\treturn nextFrame, s.nextFrame != nil || s.dataForWriting != nil\n\t}\n\n\tf := wire.GetStreamFrame()\n\tf.Fin = false\n\tf.StreamID = s.streamID\n\tf.Offset = s.writeOffset\n\tf.DataLenPresent = true\n\tf.Data = f.Data[:0]\n\n\thasMoreData := s.popNewStreamFrameWithoutBuffer(f, maxBytes, sendWindow, v)\n\tif len(f.Data) == 0 && !f.Fin {\n\t\tf.PutBack()\n\t\treturn nil, hasMoreData\n\t}\n\treturn f, hasMoreData\n}\n\nfunc (s *sendStream) popNewStreamFrameWithoutBuffer(f *wire.StreamFrame, maxBytes, sendWindow protocol.ByteCount, v protocol.Version) bool {\n\tmaxDataLen := f.MaxDataLen(maxBytes, v)\n\tif maxDataLen == 0 { // a STREAM frame must have at least one byte of data\n\t\treturn s.dataForWriting != nil || s.nextFrame != nil || s.finishedWriting\n\t}\n\ts.getDataForWriting(f, min(maxDataLen, sendWindow))\n\n\treturn s.dataForWriting != nil || s.nextFrame != nil || s.finishedWriting\n}\n\nfunc (s *sendStream) maybeGetRetransmission(maxBytes protocol.ByteCount, v protocol.Version) (*wire.StreamFrame, bool /* has more retransmissions */) {\n\tf := s.retransmissionQueue[0]\n\tnewFrame, needsSplit := f.MaybeSplitOffFrame(maxBytes, v)\n\tif needsSplit {\n\t\treturn newFrame, true\n\t}\n\ts.retransmissionQueue = s.retransmissionQueue[1:]\n\treturn f, len(s.retransmissionQueue) > 0\n}\n\nfunc (s *sendStream) hasData() bool {\n\ts.mutex.Lock()\n\thasData := len(s.dataForWriting) > 0\n\ts.mutex.Unlock()\n\treturn hasData\n}\n\nfunc (s *sendStream) getDataForWriting(f *wire.StreamFrame, maxBytes protocol.ByteCount) {\n\tif protocol.ByteCount(len(s.dataForWriting)) <= maxBytes {\n\t\tf.Data = f.Data[:len(s.dataForWriting)]\n\t\tcopy(f.Data, s.dataForWriting)\n\t\ts.dataForWriting = nil\n\t\ts.signalWrite()\n\t\treturn\n\t}\n\tf.Data = f.Data[:maxBytes]\n\tcopy(f.Data, s.dataForWriting)\n\ts.dataForWriting = s.dataForWriting[maxBytes:]\n\tif s.canBufferStreamFrame() {\n\t\ts.signalWrite()\n\t}\n}\n\nfunc (s *sendStream) isNewlyCompleted() bool {\n\tif s.completed {\n\t\treturn false\n\t}\n\t// We need to keep the stream around until all frames have been sent and acknowledged.\n\tif s.numOutstandingFrames > 0 || len(s.retransmissionQueue) > 0 || s.queuedResetStreamFrame {\n\t\treturn false\n\t}\n\t// The stream is completed if we sent the FIN.\n\tif s.finSent {\n\t\ts.completed = true\n\t\treturn true\n\t}\n\t// The stream is also completed if:\n\t// 1. the application called CancelWrite, or\n\t// 2. we received a STOP_SENDING, and\n\t// \t\t* the application consumed the error via Write, or\n\t//\t\t* the application called Close\n\tif s.cancelWriteErr != nil && (s.cancellationFlagged || s.finishedWriting) {\n\t\ts.completed = true\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (s *sendStream) Close() error {\n\ts.mutex.Lock()\n\tif s.closeForShutdownErr != nil || s.finishedWriting {\n\t\ts.mutex.Unlock()\n\t\treturn nil\n\t}\n\ts.finishedWriting = true\n\tcancelWriteErr := s.cancelWriteErr\n\tif cancelWriteErr != nil {\n\t\ts.cancellationFlagged = true\n\t}\n\tcompleted := s.isNewlyCompleted()\n\ts.mutex.Unlock()\n\n\tif completed {\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n\tif cancelWriteErr != nil {\n\t\treturn fmt.Errorf(\"close called for canceled stream %d\", s.streamID)\n\t}\n\ts.sender.onHasStreamData(s.streamID, s) // need to send the FIN, must be called without holding the mutex\n\n\ts.ctxCancel(nil)\n\treturn nil\n}\n\nfunc (s *sendStream) CancelWrite(errorCode StreamErrorCode) {\n\ts.cancelWriteImpl(errorCode, false)\n}\n\nfunc (s *sendStream) cancelWriteImpl(errorCode qerr.StreamErrorCode, remote bool) {\n\ts.mutex.Lock()\n\tif s.closeForShutdownErr != nil {\n\t\ts.mutex.Unlock()\n\t\treturn\n\t}\n\tif !remote {\n\t\ts.cancellationFlagged = true\n\t\tif s.cancelWriteErr != nil {\n\t\t\tcompleted := s.isNewlyCompleted()\n\t\t\ts.mutex.Unlock()\n\t\t\t// The user has called CancelWrite. If the previous cancellation was\n\t\t\t// because of a STOP_SENDING, we don't need to flag the error to the\n\t\t\t// user anymore.\n\t\t\tif completed {\n\t\t\t\ts.sender.onStreamCompleted(s.streamID)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t}\n\tif s.cancelWriteErr != nil {\n\t\ts.mutex.Unlock()\n\t\treturn\n\t}\n\ts.cancelWriteErr = &StreamError{StreamID: s.streamID, ErrorCode: errorCode, Remote: remote}\n\ts.ctxCancel(s.cancelWriteErr)\n\ts.numOutstandingFrames = 0\n\ts.retransmissionQueue = nil\n\ts.queuedResetStreamFrame = true\n\ts.mutex.Unlock()\n\n\ts.signalWrite()\n\ts.sender.onHasStreamControlFrame(s.streamID, s)\n}\n\nfunc (s *sendStream) updateSendWindow(limit protocol.ByteCount) {\n\tupdated := s.flowController.UpdateSendWindow(limit)\n\tif !updated { // duplicate or reordered MAX_STREAM_DATA frame\n\t\treturn\n\t}\n\ts.mutex.Lock()\n\thasStreamData := s.dataForWriting != nil || s.nextFrame != nil\n\ts.mutex.Unlock()\n\tif hasStreamData {\n\t\ts.sender.onHasStreamData(s.streamID, s)\n\t}\n}\n\nfunc (s *sendStream) handleStopSendingFrame(frame *wire.StopSendingFrame) {\n\ts.cancelWriteImpl(frame.ErrorCode, true)\n}\n\nfunc (s *sendStream) getControlFrame(time.Time) (_ ackhandler.Frame, ok, hasMore bool) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tif !s.queuedResetStreamFrame {\n\t\treturn ackhandler.Frame{}, false, false\n\t}\n\ts.queuedResetStreamFrame = false\n\ts.numOutstandingFrames++\n\treturn ackhandler.Frame{\n\t\tFrame: &wire.ResetStreamFrame{\n\t\t\tStreamID:  s.streamID,\n\t\t\tFinalSize: s.writeOffset,\n\t\t\tErrorCode: s.cancelWriteErr.ErrorCode,\n\t\t},\n\t\tHandler: (*sendStreamResetStreamHandler)(s),\n\t}, true, false\n}\n\nfunc (s *sendStream) Context() context.Context {\n\treturn s.ctx\n}\n\nfunc (s *sendStream) SetWriteDeadline(t time.Time) error {\n\ts.mutex.Lock()\n\ts.deadline = t\n\ts.mutex.Unlock()\n\ts.signalWrite()\n\treturn nil\n}\n\n// CloseForShutdown closes a stream abruptly.\n// It makes Write unblock (and return the error) immediately.\n// The peer will NOT be informed about this: the stream is closed without sending a FIN or RST.\nfunc (s *sendStream) closeForShutdown(err error) {\n\ts.mutex.Lock()\n\ts.closeForShutdownErr = err\n\ts.mutex.Unlock()\n\ts.signalWrite()\n}\n\n// signalWrite performs a non-blocking send on the writeChan\nfunc (s *sendStream) signalWrite() {\n\tselect {\n\tcase s.writeChan <- struct{}{}:\n\tdefault:\n\t}\n}\n\ntype sendStreamAckHandler sendStream\n\nvar _ ackhandler.FrameHandler = &sendStreamAckHandler{}\n\nfunc (s *sendStreamAckHandler) OnAcked(f wire.Frame) {\n\tsf := f.(*wire.StreamFrame)\n\tsf.PutBack()\n\ts.mutex.Lock()\n\tif s.cancelWriteErr != nil {\n\t\ts.mutex.Unlock()\n\t\treturn\n\t}\n\ts.numOutstandingFrames--\n\tif s.numOutstandingFrames < 0 {\n\t\tpanic(\"numOutStandingFrames negative\")\n\t}\n\tcompleted := (*sendStream)(s).isNewlyCompleted()\n\ts.mutex.Unlock()\n\n\tif completed {\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n}\n\nfunc (s *sendStreamAckHandler) OnLost(f wire.Frame) {\n\tsf := f.(*wire.StreamFrame)\n\ts.mutex.Lock()\n\tif s.cancelWriteErr != nil {\n\t\ts.mutex.Unlock()\n\t\treturn\n\t}\n\tsf.DataLenPresent = true\n\ts.retransmissionQueue = append(s.retransmissionQueue, sf)\n\ts.numOutstandingFrames--\n\tif s.numOutstandingFrames < 0 {\n\t\tpanic(\"numOutStandingFrames negative\")\n\t}\n\ts.mutex.Unlock()\n\n\ts.sender.onHasStreamData(s.streamID, (*sendStream)(s))\n}\n\ntype sendStreamResetStreamHandler sendStream\n\nvar _ ackhandler.FrameHandler = &sendStreamResetStreamHandler{}\n\nfunc (s *sendStreamResetStreamHandler) OnAcked(wire.Frame) {\n\ts.mutex.Lock()\n\ts.numOutstandingFrames--\n\tif s.numOutstandingFrames < 0 {\n\t\tpanic(\"numOutStandingFrames negative\")\n\t}\n\tcompleted := (*sendStream)(s).isNewlyCompleted()\n\ts.mutex.Unlock()\n\n\tif completed {\n\t\ts.sender.onStreamCompleted(s.streamID)\n\t}\n}\n\nfunc (s *sendStreamResetStreamHandler) OnLost(wire.Frame) {\n\ts.mutex.Lock()\n\ts.queuedResetStreamFrame = true\n\ts.numOutstandingFrames--\n\ts.mutex.Unlock()\n\ts.sender.onHasStreamControlFrame(s.streamID, (*sendStream)(s))\n}\n"
        },
        {
          "name": "send_stream_test.go",
          "type": "blob",
          "size": 36.0302734375,
          "content": "package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\tmrand \"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\ntype writerWithTimeout struct {\n\tio.Writer\n\tTimeout time.Duration\n}\n\nfunc (w *writerWithTimeout) Write(p []byte) (n int, err error) {\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\tn, err = w.Writer.Write(p)\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn n, err\n\tcase <-time.After(w.Timeout):\n\t\treturn 0, fmt.Errorf(\"write timeout after %s\", w.Timeout)\n\t}\n}\n\nfunc expectedFrameHeaderLen(strID protocol.StreamID, offset protocol.ByteCount) protocol.ByteCount {\n\treturn (&wire.StreamFrame{StreamID: strID, Offset: offset, DataLenPresent: true}).Length(protocol.Version1)\n}\n\nfunc TestSendStreamSetup(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tctx := context.WithValue(context.Background(), \"foo\", \"bar\")\n\tstr := newSendStream(ctx, 1337, nil, mockFC)\n\trequire.NotNil(t, str.Context())\n\trequire.Equal(t, \"bar\", str.Context().Value(\"foo\"))\n\trequire.Equal(t, protocol.StreamID(1337), str.StreamID())\n}\n\nfunc TestSendStreamWriteData(t *testing.T) {\n\tconst streamID protocol.StreamID = 42\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\tstrWithTimeout := &writerWithTimeout{Writer: str, Timeout: time.Second}\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\tn, err := strWithTimeout.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 6, n)\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(6))\n\tframe, _, hasMore := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.False(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Data: []byte(\"foobar\"), DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// nothing more to send at this point\n\t_, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.False(t, hasMore)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// nil writes don't do anything\n\tn, err = strWithTimeout.Write(nil)\n\trequire.NoError(t, err)\n\trequire.Zero(t, n)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// empty slices writes don't do anything\n\tn, err = strWithTimeout.Write([]byte{})\n\trequire.NoError(t, err)\n\trequire.Zero(t, n)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// multiple writes are bundled into a single frame\n\tmockSender.EXPECT().onHasStreamData(streamID, str).Times(2)\n\tn, err = strWithTimeout.Write([]byte{0xde, 0xad})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, n)\n\tn, err = strWithTimeout.Write([]byte{0xbe, 0xef})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, n)\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(4))\n\tframe, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.False(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: 42, Offset: 6, Data: []byte{0xde, 0xad, 0xbe, 0xef}, DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n\n\t// a single write is split up into smaller frames\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\tn, err = strWithTimeout.Write([]byte(\"foobaz\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 6, n)\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount).Times(3)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3)).Times(2)\n\tframe, _, hasMore = str.popStreamFrame(expectedFrameHeaderLen(streamID, 10), protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.True(t, hasMore)\n\tframe, _, hasMore = str.popStreamFrame(expectedFrameHeaderLen(streamID, 10)+3, protocol.Version1)\n\trequire.True(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Offset: 10, Data: []byte(\"foo\"), DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n\tframe, _, hasMore = str.popStreamFrame(expectedFrameHeaderLen(streamID, 13)+3, protocol.Version1)\n\trequire.False(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Offset: 13, Data: []byte(\"baz\"), DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n}\n\nfunc TestSendStreamLargeWrites(t *testing.T) {\n\tconst streamID protocol.StreamID = 1337\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\tdata := make([]byte, 5000)\n\trand.Read(data)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write(data)\n\t\tstr.Close()\n\t\terrChan <- err\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)): // short wait to ensure write is blocked\n\t}\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxPacketBufferSize).AnyTimes()\n\tmockFC.EXPECT().AddBytesSent(gomock.Any()).AnyTimes()\n\tvar offset protocol.ByteCount\n\tconst size = 40\n\tfor offset+size < protocol.ByteCount(len(data))-protocol.MaxPacketBufferSize {\n\t\tframe, _, hasMore := str.popStreamFrame(size+expectedFrameHeaderLen(streamID, offset), protocol.Version1)\n\t\trequire.NotNil(t, frame.Frame)\n\t\trequire.True(t, hasMore)\n\t\trequire.Equal(t, offset, frame.Frame.Offset)\n\t\trequire.Equal(t, data[offset:offset+size], frame.Frame.Data)\n\t\toffset += size\n\t\trequire.True(t, mockCtrl.Satisfied())\n\t}\n\t// Write should still be blocked, since there's more than protocol.MaxPacketBufferSize left to send\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)): // short wait to ensure write is blocked\n\t}\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str) // from the Close call\n\tframe, _, hasMore := str.popStreamFrame(size+expectedFrameHeaderLen(streamID, offset), protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.True(t, hasMore)\n\trequire.Equal(t, data[offset:offset+size], frame.Frame.Data)\n\trequire.Equal(t, offset, frame.Frame.Offset)\n\toffset += size\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tframe, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\trequire.Equal(t, data[offset:], frame.Frame.Data)\n\trequire.True(t, frame.Frame.Fin)\n}\n\nfunc TestSendStreamLargeWriteBlocking(t *testing.T) {\n\tconst streamID protocol.StreamID = 1337\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str).Times(2)\n\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write(make([]byte, protocol.MaxPacketBufferSize))\n\t\terrChan <- err\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"write should not have returned yet: %v\", err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)):\n\t}\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount).Times(2)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3))\n\tframe, _, hasMoreData := str.popStreamFrame(expectedFrameHeaderLen(streamID, 0)+3, protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.True(t, hasMoreData)\n\trequire.Equal(t, []byte(\"foo\"), frame.Frame.Data)\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"write should not have returned yet: %v\", err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)):\n\t}\n\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3))\n\tframe, _, hasMoreData = str.popStreamFrame(expectedFrameHeaderLen(streamID, 3)+3, protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.True(t, hasMoreData)\n\trequire.Equal(t, []byte(\"bar\"), frame.Frame.Data)\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestSendStreamCopyData(t *testing.T) {\n\tconst streamID protocol.StreamID = 42\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\tstrWithTimeout := &writerWithTimeout{Writer: str, Timeout: time.Second}\n\n\t// for small writes\n\tdata := []byte(\"foobar\")\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\t_, err := strWithTimeout.Write(data)\n\trequire.NoError(t, err)\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(gomock.Any())\n\tframe, _, _ := str.popStreamFrame(protocol.MaxPacketBufferSize, protocol.Version1)\n\tdata[1] = 'e' // modify the data after it has been written\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Data: []byte(\"foobar\"), DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n}\n\nfunc TestSendStreamDeadlineInThePast(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), 42, mockSender, mockFC)\n\n\t// no data is written when the deadline is in the past\n\trequire.NoError(t, str.SetWriteDeadline(time.Now().Add(-time.Second)))\n\tn, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.ErrorIs(t, err, os.ErrDeadlineExceeded)\n\trequire.Zero(t, n)\n\tvar nerr net.Error\n\trequire.ErrorAs(t, err, &nerr)\n\trequire.True(t, nerr.Timeout())\n\n\t// data is written when the deadline is in the future\n\tmockSender.EXPECT().onHasStreamData(gomock.Any(), str)\n\trequire.NoError(t, str.SetWriteDeadline(time.Now().Add(time.Second)))\n\tn, err = (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\trequire.Equal(t, 6, n)\n}\n\nfunc TestSendStreamDeadlineRemoval(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), 42, mockSender, mockFC)\n\n\tdeadline := scaleDuration(20 * time.Millisecond)\n\trequire.NoError(t, str.SetWriteDeadline(time.Now().Add(deadline)))\n\tmockSender.EXPECT().onHasStreamData(gomock.Any(), str).Times(2)\n\n\t// small writes are written immediately\n\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\t// large writes might block, and therefore subject to the deadline\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := (&writerWithTimeout{Writer: str, Timeout: 5 * time.Second}).Write(make([]byte, 2000))\n\t\terrChan <- err\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"write should not have returned yet: %v\", err)\n\tcase <-time.After(deadline / 2):\n\t}\n\n\t// remove the deadline after a while (but before it expires)\n\trequire.NoError(t, str.SetWriteDeadline(time.Time{}))\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"write should not have returned yet: %v\", err)\n\tcase <-time.After(deadline):\n\t}\n\n\t// now set the deadline to the past to make Write return immediately\n\trequire.NoError(t, str.SetWriteDeadline(time.Now().Add(-time.Second)))\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, os.ErrDeadlineExceeded)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(gomock.Any())\n\tframe, _, hasMoreData := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.False(t, hasMoreData)\n\trequire.Equal(t, []byte(\"foobar\"), frame.Frame.Data)\n}\n\nfunc TestSendStreamDeadlineExtension(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), 42, mockSender, mockFC)\n\n\tdeadline := scaleDuration(20 * time.Millisecond)\n\trequire.NoError(t, str.SetWriteDeadline(time.Now().Add(deadline)))\n\n\tmockSender.EXPECT().onHasStreamData(gomock.Any(), str)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := (&writerWithTimeout{Writer: str, Timeout: 5 * time.Second}).Write(make([]byte, 2000))\n\t\terrChan <- err\n\t}()\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"write should not have returned yet: %v\", err)\n\tcase <-time.After(deadline / 2):\n\t}\n\n\t// extend the deadline\n\trequire.NoError(t, str.SetWriteDeadline(time.Now().Add(deadline)))\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, os.ErrDeadlineExceeded)\n\tcase <-time.After(deadline * 3 / 2):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tframe, _, hasMoreData := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMoreData)\n}\n\nfunc TestSendStreamClose(t *testing.T) {\n\tconst streamID protocol.StreamID = 1234\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\tstrWithTimeout := &writerWithTimeout{Writer: str, Timeout: time.Second}\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str).Times(2)\n\t_, err := strWithTimeout.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\trequire.NoError(t, str.Close())\n\n\tselect {\n\tcase <-str.Context().Done():\n\tdefault:\n\t\tt.Fatal(\"stream context should have been canceled\")\n\t}\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount).Times(2)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3)).Times(2)\n\tframe, _, hasMore := str.popStreamFrame(expectedFrameHeaderLen(streamID, 0)+3, protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.True(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Offset: 0, Data: []byte(\"foo\"), DataLenPresent: true}, // no FIN yet\n\t\tframe.Frame,\n\t)\n\tframe, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.False(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Offset: 3, Fin: true, Data: []byte(\"bar\"), DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// further calls to Write return an error\n\t_, err = strWithTimeout.Write([]byte(\"foobar\"))\n\trequire.ErrorContains(t, err, \"write on closed stream 1234\")\n\tframe, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\n\t// further calls to Close don't do anything\n\trequire.NoError(t, str.Close())\n\tframe, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\trequire.True(t, mockCtrl.Satisfied())\n}\n\nfunc TestSendStreamImmediateClose(t *testing.T) {\n\tconst streamID protocol.StreamID = 1337\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\trequire.NoError(t, str.Close())\n\tframe, _, hasMore := str.popStreamFrame(expectedFrameHeaderLen(streamID, 13)+3, protocol.Version1)\n\trequire.False(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Fin: true, DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n}\n\nfunc TestSendStreamFlowControlBlocked(t *testing.T) {\n\tconst streamID protocol.StreamID = 42\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\t_, err := str.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.ByteCount(3))\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3))\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.ByteCount(0))\n\tmockFC.EXPECT().IsNewlyBlocked().Return(true)\n\tframe, blocked, hasMore := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.True(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Data: []byte(\"foo\"), DataLenPresent: true},\n\t\tframe.Frame,\n\t)\n\trequire.Equal(t, &wire.StreamDataBlockedFrame{StreamID: streamID, MaximumStreamData: 3}, blocked)\n\n\tframe, blocked, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.Nil(t, blocked)\n\trequire.True(t, hasMore)\n\n\t_, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.False(t, ok)\n\trequire.False(t, hasMore)\n}\n\nfunc TestSendStreamCloseForShutdown(t *testing.T) {\n\tconst streamID protocol.StreamID = 1337\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\tstrWithTimeout := &writerWithTimeout{Writer: str, Timeout: time.Second}\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := strWithTimeout.Write(bytes.Repeat([]byte(\"foobar\"), 1000))\n\t\terrChan <- err\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\tt.Fatalf(\"write returned before closeForShutdown: %v\", err)\n\tcase <-time.After(scaleDuration(5 * time.Millisecond)): // short wait to ensure write is blocked\n\t}\n\n\ttestErr := errors.New(\"test error\")\n\tstr.closeForShutdown(testErr)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, testErr)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// future calls to Write should return the error\n\t_, err := strWithTimeout.Write([]byte(\"foobar\"))\n\trequire.ErrorIs(t, err, testErr)\n\n\t// closing the stream doesn't do anything\n\trequire.NoError(t, str.Close())\n\n\t// no STREAM frames popped\n\tframe, _, hasMore := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\n\t// canceling the stream doesn't do anything\n\tstr.CancelWrite(1234)\n\t_, err = strWithTimeout.Write([]byte(\"foobar\"))\n\trequire.ErrorIs(t, err, testErr) // error unchanged\n}\n\nfunc TestSendStreamUpdateSendWindow(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), 42, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(gomock.Any(), str)\n\t_, err := str.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// no calls to onHasStreamData if the window size wasn't increased\n\tmockFC.EXPECT().UpdateSendWindow(protocol.ByteCount(41)).Return(false)\n\tstr.updateSendWindow(41)\n}\n\nfunc TestSendStreamCancellation(t *testing.T) {\n\tconst streamID protocol.StreamID = 42\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\tstrWithTimeout := &writerWithTimeout{Writer: str, Timeout: time.Second}\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\t_, err := strWithTimeout.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3))\n\tframe, _, hasMore := str.popStreamFrame(3+expectedFrameHeaderLen(streamID, 0), protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.True(t, hasMore)\n\trequire.Equal(t, []byte(\"foo\"), frame.Frame.Data)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\twrote := make(chan struct{})\n\tmockSender.EXPECT().onHasStreamData(streamID, str).Do(func(protocol.StreamID, sendStreamI) { close(wrote) })\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := strWithTimeout.Write(make([]byte, 2000))\n\t\terrChan <- err\n\t}()\n\n\tselect {\n\tcase <-wrote:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// cancel the stream\n\tmockSender.EXPECT().onHasStreamControlFrame(streamID, str)\n\tstr.CancelWrite(1234)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\tcf, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\t// only the \"foo\" was sent out, so the final size is 3\n\trequire.Equal(t, &wire.ResetStreamFrame{StreamID: streamID, FinalSize: 3, ErrorCode: 1234}, cf.Frame)\n\trequire.False(t, hasMore)\n\n\t// the context was canceled\n\tselect {\n\tcase <-str.Context().Done():\n\tdefault:\n\t\tt.Fatal(\"stream context should have been canceled\")\n\t}\n\trequire.ErrorIs(t, context.Cause(str.Context()), &StreamError{StreamID: streamID, ErrorCode: 1234, Remote: false})\n\n\t// duplicate calls to CancelWrite don't do anything\n\tstr.CancelWrite(1234)\n\t_, ok, _ = str.getControlFrame(time.Now())\n\trequire.False(t, ok)\n\n\t// the Write call should return an error\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1234, Remote: false})\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// no data to send\n\tframe, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\n\t// future calls to Write should return an error\n\t_, err = strWithTimeout.Write([]byte(\"foo\"))\n\trequire.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1234, Remote: false})\n\tframe, _, hasMore = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\n\t// Close has no effect\n\trequire.ErrorContains(t, str.Close(), \"close called for canceled stream\")\n\tframe, _, _ = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\t_, err = (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.Error(t, err)\n\t// TODO(#4808):error code and remote flag are unchanged\n\t// require.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1234, Remote: false})\n}\n\nfunc TestSendStreamCancellationAfterClose(t *testing.T) {\n\tconst streamID protocol.StreamID = 1234\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str).Times(2)\n\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\trequire.NoError(t, str.Close())\n\n\tmockSender.EXPECT().onHasStreamControlFrame(streamID, str)\n\tstr.CancelWrite(1337)\n\n\tframe, _, hasMore := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\n\tcf, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\trequire.Equal(t, &wire.ResetStreamFrame{StreamID: streamID, FinalSize: 0, ErrorCode: 1337}, cf.Frame)\n\trequire.False(t, hasMore)\n}\n\nfunc TestSendStreamCancellationStreamRetransmission(t *testing.T) {\n\tt.Run(\"local\", func(t *testing.T) {\n\t\ttestSendStreamCancellationStreamRetransmission(t, false)\n\t})\n\tt.Run(\"remote\", func(t *testing.T) {\n\t\ttestSendStreamCancellationStreamRetransmission(t, true)\n\t})\n}\n\nfunc testSendStreamCancellationStreamRetransmission(t *testing.T, remote bool) {\n\tconst streamID protocol.StreamID = 1000\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount).Times(2)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3)).Times(2)\n\tf1, _, hasMore := str.popStreamFrame(3+expectedFrameHeaderLen(streamID, 0), protocol.Version1)\n\trequire.NotNil(t, f1.Frame)\n\trequire.True(t, hasMore)\n\tf2, _, hasMore := str.popStreamFrame(3+expectedFrameHeaderLen(streamID, 3), protocol.Version1)\n\trequire.NotNil(t, f2.Frame)\n\trequire.False(t, hasMore)\n\n\tmockSender.EXPECT().onHasStreamControlFrame(streamID, str)\n\tif remote {\n\t\tstr.handleStopSendingFrame(&wire.StopSendingFrame{StreamID: streamID, ErrorCode: 1337})\n\t} else {\n\t\tstr.CancelWrite(1337)\n\t}\n\tcf, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\trequire.IsType(t, &wire.ResetStreamFrame{}, cf.Frame)\n\trequire.False(t, hasMore)\n\n\t// it doesn't matter if the STREAM frames are acked or lost\n\tf1.Handler.OnAcked(f1.Frame)\n\tf2.Handler.OnLost(f2.Frame)\n\tframe, _, hasMore := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\trequire.False(t, hasMore)\n\t// if CancelWrite was called, the stream is completed as soon as the RESET_STREAM frame is acked\n\tif !remote {\n\t\tmockSender.EXPECT().onStreamCompleted(streamID)\n\t}\n\tcf.Handler.OnAcked(cf.Frame)\n\n\t// but if it's a remote cancellation, the application has to consume the error first\n\tif remote {\n\t\tmockSender.EXPECT().onStreamCompleted(streamID)\n\t\t_, err := str.Write([]byte(\"foobar\"))\n\t\trequire.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1337, Remote: true})\n\t}\n}\n\nfunc TestSendStreamCancellationResetStreamRetransmission(t *testing.T) {\n\tconst streamID protocol.StreamID = 1000\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamControlFrame(streamID, str)\n\tstr.CancelWrite(1337)\n\n\tf1, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\trequire.Equal(t, &wire.ResetStreamFrame{StreamID: streamID, FinalSize: 0, ErrorCode: 1337}, f1.Frame)\n\trequire.False(t, hasMore)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// lose the RESET_STREAM frame\n\tmockSender.EXPECT().onHasStreamControlFrame(streamID, str)\n\tf1.Handler.OnLost(f1.Frame)\n\t// get the retransmission\n\tf2, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\trequire.Equal(t, &wire.ResetStreamFrame{StreamID: streamID, FinalSize: 0, ErrorCode: 1337}, f2.Frame)\n\trequire.False(t, hasMore)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// acknowledging the RESET_STREAM frame completes the stream\n\tmockSender.EXPECT().onStreamCompleted(streamID)\n\tf2.Handler.OnAcked(f2.Frame)\n}\n\nfunc TestSendStreamStopSending(t *testing.T) {\n\tconst streamID protocol.StreamID = 1000\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str).MaxTimes(2)\n\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(gomock.Any())\n\tframe, _, _ := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.NotNil(t, frame.Frame)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write(make([]byte, 2000))\n\t\terrChan <- err\n\t}()\n\n\tmockSender.EXPECT().onHasStreamControlFrame(streamID, str)\n\tstr.handleStopSendingFrame(&wire.StopSendingFrame{StreamID: streamID, ErrorCode: 1337})\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1337, Remote: true})\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tcf, ok, hasMore := str.getControlFrame(time.Now())\n\trequire.True(t, ok)\n\trequire.Equal(t, &wire.ResetStreamFrame{StreamID: streamID, FinalSize: 6, ErrorCode: 1337}, cf.Frame)\n\trequire.False(t, hasMore)\n\n\t// calls to Write should return an error\n\t_, err = (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1337, Remote: true})\n\tframe, _, _ = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\n\t// calls to CancelWrite have no effect\n\tstr.CancelWrite(1234)\n\t_, err = (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\t// error code and remote flag are unchanged\n\trequire.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1337, Remote: true})\n\t_, ok, _ = str.getControlFrame(time.Now())\n\trequire.False(t, ok)\n\n\t// Close has no effect\n\trequire.ErrorContains(t, str.Close(), \"close called for canceled stream\")\n\tframe, _, _ = str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.Nil(t, frame.Frame)\n\t_, err = (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.Error(t, err)\n\t// TODO(#4808):error code and remote flag are unchanged\n\t// require.ErrorIs(t, err, &StreamError{StreamID: streamID, ErrorCode: 1337, Remote: true})\n}\n\n// This test is inherently racy, as it tests a concurrent call to Write() and CancelRead().\n// A single successful run of this test therefore doesn't mean a lot,\n// for reliable results it has to be run many times.\nfunc TestSendStreamConcurrentWriteAndCancel(t *testing.T) {\n\tconst streamID protocol.StreamID = 1000\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamControlFrame(gomock.Any(), gomock.Any()).MaxTimes(1)\n\tmockSender.EXPECT().onHasStreamData(streamID, str).MaxTimes(1)\n\tmockSender.EXPECT().onStreamCompleted(streamID).MaxTimes(1)\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount).MaxTimes(1)\n\tmockFC.EXPECT().AddBytesSent(gomock.Any()).MaxTimes(1)\n\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\tn, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write(make([]byte, 100))\n\t\tif n == 0 {\n\t\t\terrChan <- nil\n\t\t\treturn\n\t\t}\n\t\terrChan <- err\n\t}()\n\n\tdone := make(chan struct{}, 2)\n\tgo func() {\n\t\tstr.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\t\tdone <- struct{}{}\n\t}()\n\tgo func() {\n\t\tstr.CancelWrite(1234)\n\t\tdone <- struct{}{}\n\t}()\n\n\tselect {\n\tcase err := <-errChan:\n\t\trequire.NoError(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for write to complete\")\n\t}\n\n\tfor i := 0; i < 2; i++ {\n\t\tselect {\n\t\tcase <-done:\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatal(\"timeout waiting for cancel to complete\")\n\t\t}\n\t}\n}\n\nfunc TestSendStreamRetransmissions(t *testing.T) {\n\tconst streamID protocol.StreamID = 1000\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\t_, err := str.Write([]byte(\"foo\"))\n\trequire.NoError(t, err)\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3))\n\tf1, _, _ := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Data: []byte(\"foo\"), DataLenPresent: true},\n\t\tf1.Frame,\n\t)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// write some more data\n\tmockSender.EXPECT().onHasStreamData(streamID, str).Times(2)\n\t_, err = (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"bar\"))\n\trequire.NoError(t, err)\n\trequire.NoError(t, str.Close())\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// lose the frame\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\tf1.Handler.OnLost(f1.Frame)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// when popping a new frame, we first get the retransmission...\n\tf2, _, hasMoreData := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.EqualExportedValues(t, &wire.StreamFrame{StreamID: streamID, Data: []byte(\"foo\"), DataLenPresent: true}, f2.Frame)\n\trequire.True(t, hasMoreData)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// ... then we get the new data\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(3))\n\tf3, _, hasMoreData := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.EqualExportedValues(t, &wire.StreamFrame{StreamID: streamID, Offset: 3, Fin: true, Data: []byte(\"bar\"), DataLenPresent: true}, f3.Frame)\n\trequire.False(t, hasMoreData)\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// acknowledge the retransmission...\n\tf2.Handler.OnAcked(f2.Frame)\n\t// ... and the last frame, which concludes this stream\n\tmockSender.EXPECT().onStreamCompleted(streamID)\n\tf3.Handler.OnAcked(f3.Frame)\n}\n\nfunc TestSendStreamRetransmissionFraming(t *testing.T) {\n\tconst streamID protocol.StreamID = 1000\n\tmockCtrl := gomock.NewController(t)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(6))\n\tf, _, _ := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\trequire.NotNil(t, f.Frame)\n\n\t// lose the frame\n\tmockSender.EXPECT().onHasStreamData(streamID, str)\n\tf.Handler.OnLost(f.Frame)\n\n\t// retransmission doesn't fit\n\tf, _, hasMore := str.popStreamFrame(expectedFrameHeaderLen(streamID, 0), protocol.Version1)\n\trequire.Nil(t, f.Frame)\n\trequire.True(t, hasMore)\n\n\t// split the retransmission\n\tr1, _, hasMore := str.popStreamFrame(expectedFrameHeaderLen(streamID, 0)+3, protocol.Version1)\n\trequire.True(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Data: []byte(\"foo\"), DataLenPresent: true},\n\t\tr1.Frame,\n\t)\n\tr2, _, hasMore := str.popStreamFrame(expectedFrameHeaderLen(streamID, 3)+3, protocol.Version1)\n\trequire.True(t, hasMore)\n\t// When popping a retransmission, we always claim that there's more data to send.\n\t// We accept that this might be incorrect.\n\trequire.True(t, hasMore)\n\trequire.EqualExportedValues(t,\n\t\t&wire.StreamFrame{StreamID: streamID, Offset: 3, Data: []byte(\"bar\"), DataLenPresent: true},\n\t\tr2.Frame,\n\t)\n\t_, _, hasMore = str.popStreamFrame(expectedFrameHeaderLen(streamID, 3)+3, protocol.Version1)\n\trequire.False(t, hasMore)\n}\n\n// This test is kind of an integration test.\n// It writes 4 MB of data, and pops STREAM frames that sometimes are and sometimes aren't limited by flow control.\n// Half of these STREAM frames are then received and their content saved, while the other half is reported lost\n// and has to be retransmitted.\nfunc TestSendStreamRetransmitDataUntilAcknowledged(t *testing.T) {\n\tconst streamID protocol.StreamID = 123456\n\tconst dataLen = 1 << 22 // 4 MB\n\tmockCtrl := gomock.NewController(t)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tstr := newSendStream(context.Background(), streamID, mockSender, mockFC)\n\n\tmockSender.EXPECT().onHasStreamData(streamID, str).AnyTimes()\n\tmockFC.EXPECT().SendWindowSize().DoAndReturn(func() protocol.ByteCount {\n\t\treturn protocol.ByteCount(mrand.Intn(500)) + 50\n\t}).AnyTimes()\n\tmockFC.EXPECT().IsNewlyBlocked().Return(false).AnyTimes()\n\tmockFC.EXPECT().AddBytesSent(gomock.Any()).AnyTimes()\n\n\tdata := make([]byte, dataLen)\n\t_, err := rand.Read(data)\n\trequire.NoError(t, err)\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(done)\n\t\t_, err := str.Write(data)\n\t\trequire.NoError(t, err)\n\t\tstr.Close()\n\t}()\n\n\tvar completed bool\n\tmockSender.EXPECT().onStreamCompleted(streamID).Do(func(protocol.StreamID) { completed = true })\n\n\treceived := make([]byte, dataLen)\n\tfor {\n\t\tif completed {\n\t\t\tbreak\n\t\t}\n\t\tf, _, _ := str.popStreamFrame(protocol.ByteCount(mrand.Intn(300)+100), protocol.Version1)\n\t\tif f.Frame == nil {\n\t\t\tcontinue\n\t\t}\n\t\tsf := f.Frame\n\t\t// 50%: acknowledge the frame and save the data\n\t\t// 50%: lose the frame\n\t\tif mrand.Intn(100) < 50 {\n\t\t\tcopy(received[sf.Offset:sf.Offset+sf.DataLen()], sf.Data)\n\t\t\tf.Handler.OnAcked(f.Frame)\n\t\t} else {\n\t\t\tf.Handler.OnLost(f.Frame)\n\t\t}\n\t}\n\trequire.Equal(t, data, received)\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 30.34375,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\n// ErrServerClosed is returned by the Listener or EarlyListener's Accept method after a call to Close.\nvar ErrServerClosed = errServerClosed{}\n\ntype errServerClosed struct{}\n\nfunc (errServerClosed) Error() string { return \"quic: server closed\" }\nfunc (errServerClosed) Unwrap() error { return net.ErrClosed }\n\n// packetHandler handles packets\ntype packetHandler interface {\n\thandlePacket(receivedPacket)\n\tdestroy(error)\n\tcloseWithTransportError(qerr.TransportErrorCode)\n}\n\ntype packetHandlerManager interface {\n\tGet(protocol.ConnectionID) (packetHandler, bool)\n\tGetByResetToken(protocol.StatelessResetToken) (packetHandler, bool)\n\tAddWithConnID(destConnID, newConnID protocol.ConnectionID, h packetHandler) bool\n\tClose(error)\n\tconnRunner\n}\n\ntype quicConn interface {\n\tEarlyConnection\n\tearlyConnReady() <-chan struct{}\n\thandlePacket(receivedPacket)\n\trun() error\n\tdestroy(error)\n\tcloseWithTransportError(TransportErrorCode)\n}\n\ntype zeroRTTQueue struct {\n\tpackets    []receivedPacket\n\texpiration time.Time\n}\n\ntype rejectedPacket struct {\n\treceivedPacket\n\thdr *wire.Header\n}\n\n// A Listener of QUIC\ntype baseServer struct {\n\tdisableVersionNegotiation bool\n\tacceptEarlyConns          bool\n\n\ttlsConf *tls.Config\n\tconfig  *Config\n\n\tconn rawConn\n\n\ttokenGenerator *handshake.TokenGenerator\n\tmaxTokenAge    time.Duration\n\n\tconnIDGenerator ConnectionIDGenerator\n\tconnHandler     packetHandlerManager\n\tonClose         func()\n\n\treceivedPackets chan receivedPacket\n\n\tnextZeroRTTCleanup time.Time\n\tzeroRTTQueues      map[protocol.ConnectionID]*zeroRTTQueue // only initialized if acceptEarlyConns == true\n\n\tconnContext func(context.Context) context.Context\n\n\t// set as a member, so they can be set in the tests\n\tnewConn func(\n\t\tcontext.Context,\n\t\tcontext.CancelCauseFunc,\n\t\tsendConn,\n\t\tconnRunner,\n\t\tprotocol.ConnectionID, /* original dest connection ID */\n\t\t*protocol.ConnectionID, /* retry src connection ID */\n\t\tprotocol.ConnectionID, /* client dest connection ID */\n\t\tprotocol.ConnectionID, /* destination connection ID */\n\t\tprotocol.ConnectionID, /* source connection ID */\n\t\tConnectionIDGenerator,\n\t\tprotocol.StatelessResetToken,\n\t\t*Config,\n\t\t*tls.Config,\n\t\t*handshake.TokenGenerator,\n\t\tbool, /* client address validated by an address validation token */\n\t\t*logging.ConnectionTracer,\n\t\tutils.Logger,\n\t\tprotocol.Version,\n\t) quicConn\n\n\tcloseMx sync.Mutex\n\t// errorChan is closed when Close is called. This has two effects:\n\t// 1. it cancels handshakes that are still in flight (using CONNECTION_REFUSED) errors\n\t// 2. it stops handling of packets passed to this server\n\terrorChan chan struct{}\n\t// acceptChan is closed when Close returns.\n\t// This only happens once all handshake in flight have either completed and canceled.\n\t// Calls to Accept will first drain the queue of connections that have completed the handshake,\n\t// and then return ErrServerClosed.\n\tstopAccepting chan struct{}\n\tcloseErr      error\n\trunning       chan struct{} // closed as soon as run() returns\n\n\tversionNegotiationQueue chan receivedPacket\n\tinvalidTokenQueue       chan rejectedPacket\n\tconnectionRefusedQueue  chan rejectedPacket\n\tretryQueue              chan rejectedPacket\n\thandshakingCount        sync.WaitGroup\n\n\tverifySourceAddress func(net.Addr) bool\n\n\tconnQueue chan quicConn\n\n\ttracer *logging.Tracer\n\n\tlogger utils.Logger\n}\n\n// A Listener listens for incoming QUIC connections.\n// It returns connections once the handshake has completed.\ntype Listener struct {\n\tbaseServer *baseServer\n}\n\n// Accept returns new connections. It should be called in a loop.\nfunc (l *Listener) Accept(ctx context.Context) (Connection, error) {\n\treturn l.baseServer.Accept(ctx)\n}\n\n// Close closes the listener.\n// Accept will return ErrServerClosed as soon as all connections in the accept queue have been accepted.\n// QUIC handshakes that are still in flight will be rejected with a CONNECTION_REFUSED error.\n// The effect of closing the listener depends on how it was created:\n// * if it was created using Transport.Listen, already established connections will be unaffected\n// * if it was created using the Listen convenience method, all established connection will be closed immediately\nfunc (l *Listener) Close() error {\n\treturn l.baseServer.Close()\n}\n\n// Addr returns the local network address that the server is listening on.\nfunc (l *Listener) Addr() net.Addr {\n\treturn l.baseServer.Addr()\n}\n\n// An EarlyListener listens for incoming QUIC connections, and returns them before the handshake completes.\n// For connections that don't use 0-RTT, this allows the server to send 0.5-RTT data.\n// This data is encrypted with forward-secure keys, however, the client's identity has not yet been verified.\n// For connection using 0-RTT, this allows the server to accept and respond to streams that the client opened in the\n// 0-RTT data it sent. Note that at this point during the handshake, the live-ness of the\n// client has not yet been confirmed, and the 0-RTT data could have been replayed by an attacker.\ntype EarlyListener struct {\n\tbaseServer *baseServer\n}\n\n// Accept returns a new connections. It should be called in a loop.\nfunc (l *EarlyListener) Accept(ctx context.Context) (EarlyConnection, error) {\n\treturn l.baseServer.accept(ctx)\n}\n\n// Close the server. All active connections will be closed.\nfunc (l *EarlyListener) Close() error {\n\treturn l.baseServer.Close()\n}\n\n// Addr returns the local network addr that the server is listening on.\nfunc (l *EarlyListener) Addr() net.Addr {\n\treturn l.baseServer.Addr()\n}\n\n// ListenAddr creates a QUIC server listening on a given address.\n// See Listen for more details.\nfunc ListenAddr(addr string, tlsConf *tls.Config, config *Config) (*Listener, error) {\n\tconn, err := listenUDP(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn (&Transport{\n\t\tConn:        conn,\n\t\tcreatedConn: true,\n\t\tisSingleUse: true,\n\t}).Listen(tlsConf, config)\n}\n\n// ListenAddrEarly works like ListenAddr, but it returns connections before the handshake completes.\nfunc ListenAddrEarly(addr string, tlsConf *tls.Config, config *Config) (*EarlyListener, error) {\n\tconn, err := listenUDP(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn (&Transport{\n\t\tConn:        conn,\n\t\tcreatedConn: true,\n\t\tisSingleUse: true,\n\t}).ListenEarly(tlsConf, config)\n}\n\nfunc listenUDP(addr string) (*net.UDPConn, error) {\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn net.ListenUDP(\"udp\", udpAddr)\n}\n\n// Listen listens for QUIC connections on a given net.PacketConn.\n// If the PacketConn satisfies the OOBCapablePacketConn interface (as a net.UDPConn does),\n// ECN and packet info support will be enabled. In this case, ReadMsgUDP and WriteMsgUDP\n// will be used instead of ReadFrom and WriteTo to read/write packets.\n// A single net.PacketConn can only be used for a single call to Listen.\n//\n// The tls.Config must not be nil and must contain a certificate configuration.\n// Furthermore, it must define an application control (using NextProtos).\n// The quic.Config may be nil, in that case the default values will be used.\n//\n// This is a convenience function. More advanced use cases should instantiate a Transport,\n// which offers configuration options for a more fine-grained control of the connection establishment,\n// including reusing the underlying UDP socket for outgoing QUIC connections.\n// When closing a listener created with Listen, all established QUIC connections will be closed immediately.\nfunc Listen(conn net.PacketConn, tlsConf *tls.Config, config *Config) (*Listener, error) {\n\ttr := &Transport{Conn: conn, isSingleUse: true}\n\treturn tr.Listen(tlsConf, config)\n}\n\n// ListenEarly works like Listen, but it returns connections before the handshake completes.\nfunc ListenEarly(conn net.PacketConn, tlsConf *tls.Config, config *Config) (*EarlyListener, error) {\n\ttr := &Transport{Conn: conn, isSingleUse: true}\n\treturn tr.ListenEarly(tlsConf, config)\n}\n\nfunc newServer(\n\tconn rawConn,\n\tconnHandler packetHandlerManager,\n\tconnIDGenerator ConnectionIDGenerator,\n\tconnContext func(context.Context) context.Context,\n\ttlsConf *tls.Config,\n\tconfig *Config,\n\ttracer *logging.Tracer,\n\tonClose func(),\n\ttokenGeneratorKey TokenGeneratorKey,\n\tmaxTokenAge time.Duration,\n\tverifySourceAddress func(net.Addr) bool,\n\tdisableVersionNegotiation bool,\n\tacceptEarly bool,\n) *baseServer {\n\ts := &baseServer{\n\t\tconn:                      conn,\n\t\tconnContext:               connContext,\n\t\ttlsConf:                   tlsConf,\n\t\tconfig:                    config,\n\t\ttokenGenerator:            handshake.NewTokenGenerator(tokenGeneratorKey),\n\t\tmaxTokenAge:               maxTokenAge,\n\t\tverifySourceAddress:       verifySourceAddress,\n\t\tconnIDGenerator:           connIDGenerator,\n\t\tconnHandler:               connHandler,\n\t\tconnQueue:                 make(chan quicConn, protocol.MaxAcceptQueueSize),\n\t\terrorChan:                 make(chan struct{}),\n\t\tstopAccepting:             make(chan struct{}),\n\t\trunning:                   make(chan struct{}),\n\t\treceivedPackets:           make(chan receivedPacket, protocol.MaxServerUnprocessedPackets),\n\t\tversionNegotiationQueue:   make(chan receivedPacket, 4),\n\t\tinvalidTokenQueue:         make(chan rejectedPacket, 4),\n\t\tconnectionRefusedQueue:    make(chan rejectedPacket, 4),\n\t\tretryQueue:                make(chan rejectedPacket, 8),\n\t\tnewConn:                   newConnection,\n\t\ttracer:                    tracer,\n\t\tlogger:                    utils.DefaultLogger.WithPrefix(\"server\"),\n\t\tacceptEarlyConns:          acceptEarly,\n\t\tdisableVersionNegotiation: disableVersionNegotiation,\n\t\tonClose:                   onClose,\n\t}\n\tif acceptEarly {\n\t\ts.zeroRTTQueues = map[protocol.ConnectionID]*zeroRTTQueue{}\n\t}\n\tgo s.run()\n\tgo s.runSendQueue()\n\ts.logger.Debugf(\"Listening for %s connections on %s\", conn.LocalAddr().Network(), conn.LocalAddr().String())\n\treturn s\n}\n\nfunc (s *baseServer) run() {\n\tdefer close(s.running)\n\tfor {\n\t\tselect {\n\t\tcase <-s.errorChan:\n\t\t\treturn\n\t\tdefault:\n\t\t}\n\t\tselect {\n\t\tcase <-s.errorChan:\n\t\t\treturn\n\t\tcase p := <-s.receivedPackets:\n\t\t\tif bufferStillInUse := s.handlePacketImpl(p); !bufferStillInUse {\n\t\t\t\tp.buffer.Release()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (s *baseServer) runSendQueue() {\n\tfor {\n\t\tselect {\n\t\tcase <-s.running:\n\t\t\treturn\n\t\tcase p := <-s.versionNegotiationQueue:\n\t\t\ts.maybeSendVersionNegotiationPacket(p)\n\t\tcase p := <-s.invalidTokenQueue:\n\t\t\ts.maybeSendInvalidToken(p)\n\t\tcase p := <-s.connectionRefusedQueue:\n\t\t\ts.sendConnectionRefused(p)\n\t\tcase p := <-s.retryQueue:\n\t\t\ts.sendRetry(p)\n\t\t}\n\t}\n}\n\n// Accept returns connections that already completed the handshake.\n// It is only valid if acceptEarlyConns is false.\nfunc (s *baseServer) Accept(ctx context.Context) (Connection, error) {\n\treturn s.accept(ctx)\n}\n\nfunc (s *baseServer) accept(ctx context.Context) (quicConn, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tcase conn := <-s.connQueue:\n\t\treturn conn, nil\n\tcase <-s.stopAccepting:\n\t\t// first drain the queue\n\t\tselect {\n\t\tcase conn := <-s.connQueue:\n\t\t\treturn conn, nil\n\t\tdefault:\n\t\t}\n\t\treturn nil, s.closeErr\n\t}\n}\n\nfunc (s *baseServer) Close() error {\n\ts.close(ErrServerClosed, true)\n\treturn nil\n}\n\nfunc (s *baseServer) close(e error, notifyOnClose bool) {\n\ts.closeMx.Lock()\n\tif s.closeErr != nil {\n\t\ts.closeMx.Unlock()\n\t\treturn\n\t}\n\ts.closeErr = e\n\tclose(s.errorChan)\n\t<-s.running\n\ts.closeMx.Unlock()\n\n\tif notifyOnClose {\n\t\ts.onClose()\n\t}\n\t// wait until all handshakes in flight have terminated\n\ts.handshakingCount.Wait()\n\tclose(s.stopAccepting)\n}\n\n// Addr returns the server's network address\nfunc (s *baseServer) Addr() net.Addr {\n\treturn s.conn.LocalAddr()\n}\n\nfunc (s *baseServer) handlePacket(p receivedPacket) {\n\tselect {\n\tcase s.receivedPackets <- p:\n\tcase <-s.errorChan:\n\t\treturn\n\tdefault:\n\t\ts.logger.Debugf(\"Dropping packet from %s (%d bytes). Server receive queue full.\", p.remoteAddr, p.Size())\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t}\n}\n\nfunc (s *baseServer) handlePacketImpl(p receivedPacket) bool /* is the buffer still in use? */ {\n\tif !s.nextZeroRTTCleanup.IsZero() && p.rcvTime.After(s.nextZeroRTTCleanup) {\n\t\tdefer s.cleanupZeroRTTQueues(p.rcvTime)\n\t}\n\n\tif wire.IsVersionNegotiationPacket(p.data) {\n\t\ts.logger.Debugf(\"Dropping Version Negotiation packet.\")\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeVersionNegotiation, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn false\n\t}\n\t// Short header packets should never end up here in the first place\n\tif !wire.IsLongHeaderPacket(p.data[0]) {\n\t\tpanic(fmt.Sprintf(\"misrouted packet: %#v\", p.data))\n\t}\n\tv, err := wire.ParseVersion(p.data)\n\t// drop the packet if we failed to parse the protocol version\n\tif err != nil {\n\t\ts.logger.Debugf(\"Dropping a packet with an unknown version\")\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn false\n\t}\n\t// send a Version Negotiation Packet if the client is speaking a different protocol version\n\tif !protocol.IsSupportedVersion(s.config.Versions, v) {\n\t\tif s.disableVersionNegotiation {\n\t\t\treturn false\n\t\t}\n\n\t\tif p.Size() < protocol.MinUnknownVersionPacketSize {\n\t\t\ts.logger.Debugf(\"Dropping a packet with an unsupported version number %d that is too small (%d bytes)\", v, p.Size())\n\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\treturn s.enqueueVersionNegotiationPacket(p)\n\t}\n\n\tif wire.Is0RTTPacket(p.data) {\n\t\tif !s.acceptEarlyConns {\n\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\treturn s.handle0RTTPacket(p)\n\t}\n\n\t// If we're creating a new connection, the packet will be passed to the connection.\n\t// The header will then be parsed again.\n\thdr, _, _, err := wire.ParsePacket(p.data)\n\tif err != nil {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropHeaderParseError)\n\t\t}\n\t\ts.logger.Debugf(\"Error parsing packet: %s\", err)\n\t\treturn false\n\t}\n\tif hdr.Type == protocol.PacketTypeInitial && p.Size() < protocol.MinInitialPacketSize {\n\t\ts.logger.Debugf(\"Dropping a packet that is too small to be a valid Initial (%d bytes)\", p.Size())\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeInitial, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn false\n\t}\n\n\tif hdr.Type != protocol.PacketTypeInitial {\n\t\t// Drop long header packets.\n\t\t// There's little point in sending a Stateless Reset, since the client\n\t\t// might not have received the token yet.\n\t\ts.logger.Debugf(\"Dropping long header packet of type %s (%d bytes)\", hdr.Type, len(p.data))\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeFromHeader(hdr), p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn false\n\t}\n\n\ts.logger.Debugf(\"<- Received Initial packet.\")\n\n\tif err := s.handleInitialImpl(p, hdr); err != nil {\n\t\ts.logger.Errorf(\"Error occurred handling initial packet: %s\", err)\n\t}\n\t// Don't put the packet buffer back.\n\t// handleInitialImpl deals with the buffer.\n\treturn true\n}\n\nfunc (s *baseServer) handle0RTTPacket(p receivedPacket) bool {\n\tconnID, err := wire.ParseConnectionID(p.data, 0)\n\tif err != nil {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropHeaderParseError)\n\t\t}\n\t\treturn false\n\t}\n\n\t// check again if we might have a connection now\n\tif handler, ok := s.connHandler.Get(connID); ok {\n\t\thandler.handlePacket(p)\n\t\treturn true\n\t}\n\n\tif q, ok := s.zeroRTTQueues[connID]; ok {\n\t\tif len(q.packets) >= protocol.Max0RTTQueueLen {\n\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropDOSPrevention)\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\tq.packets = append(q.packets, p)\n\t\treturn true\n\t}\n\n\tif len(s.zeroRTTQueues) >= protocol.Max0RTTQueues {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t\treturn false\n\t}\n\tqueue := &zeroRTTQueue{packets: make([]receivedPacket, 1, 8)}\n\tqueue.packets[0] = p\n\texpiration := p.rcvTime.Add(protocol.Max0RTTQueueingDuration)\n\tqueue.expiration = expiration\n\tif s.nextZeroRTTCleanup.IsZero() || s.nextZeroRTTCleanup.After(expiration) {\n\t\ts.nextZeroRTTCleanup = expiration\n\t}\n\ts.zeroRTTQueues[connID] = queue\n\treturn true\n}\n\nfunc (s *baseServer) cleanupZeroRTTQueues(now time.Time) {\n\t// Iterate over all queues to find those that are expired.\n\t// This is ok since we're placing a pretty low limit on the number of queues.\n\tvar nextCleanup time.Time\n\tfor connID, q := range s.zeroRTTQueues {\n\t\tif q.expiration.After(now) {\n\t\t\tif nextCleanup.IsZero() || nextCleanup.After(q.expiration) {\n\t\t\t\tnextCleanup = q.expiration\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tfor _, p := range q.packets {\n\t\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropDOSPrevention)\n\t\t\t}\n\t\t\tp.buffer.Release()\n\t\t}\n\t\tdelete(s.zeroRTTQueues, connID)\n\t\tif s.logger.Debug() {\n\t\t\ts.logger.Debugf(\"Removing 0-RTT queue for %s.\", connID)\n\t\t}\n\t}\n\ts.nextZeroRTTCleanup = nextCleanup\n}\n\n// validateToken returns false if:\n//   - address is invalid\n//   - token is expired\n//   - token is null\nfunc (s *baseServer) validateToken(token *handshake.Token, addr net.Addr) bool {\n\tif token == nil {\n\t\treturn false\n\t}\n\tif !token.ValidateRemoteAddr(addr) {\n\t\treturn false\n\t}\n\tif !token.IsRetryToken && time.Since(token.SentTime) > s.maxTokenAge {\n\t\treturn false\n\t}\n\tif token.IsRetryToken && time.Since(token.SentTime) > s.config.maxRetryTokenAge() {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (s *baseServer) handleInitialImpl(p receivedPacket, hdr *wire.Header) error {\n\tif len(hdr.Token) == 0 && hdr.DestConnectionID.Len() < protocol.MinConnectionIDLenInitial {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeInitial, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\tp.buffer.Release()\n\t\treturn errors.New(\"too short connection ID\")\n\t}\n\n\t// The server queues packets for a while, and we might already have established a connection by now.\n\t// This results in a second check in the connection map.\n\t// That's ok since it's not the hot path (it's only taken by some Initial and 0-RTT packets).\n\tif handler, ok := s.connHandler.Get(hdr.DestConnectionID); ok {\n\t\thandler.handlePacket(p)\n\t\treturn nil\n\t}\n\n\tvar (\n\t\ttoken              *handshake.Token\n\t\tretrySrcConnID     *protocol.ConnectionID\n\t\tclientAddrVerified bool\n\t)\n\torigDestConnID := hdr.DestConnectionID\n\tif len(hdr.Token) > 0 {\n\t\ttok, err := s.tokenGenerator.DecodeToken(hdr.Token)\n\t\tif err == nil {\n\t\t\tif tok.IsRetryToken {\n\t\t\t\torigDestConnID = tok.OriginalDestConnectionID\n\t\t\t\tretrySrcConnID = &tok.RetrySrcConnectionID\n\t\t\t}\n\t\t\ttoken = tok\n\t\t}\n\t}\n\tif token != nil {\n\t\tclientAddrVerified = s.validateToken(token, p.remoteAddr)\n\t\tif !clientAddrVerified {\n\t\t\t// For invalid and expired non-retry tokens, we don't send an INVALID_TOKEN error.\n\t\t\t// We just ignore them, and act as if there was no token on this packet at all.\n\t\t\t// This also means we might send a Retry later.\n\t\t\tif !token.IsRetryToken {\n\t\t\t\ttoken = nil\n\t\t\t} else {\n\t\t\t\t// For Retry tokens, we send an INVALID_ERROR if\n\t\t\t\t// * the token is too old, or\n\t\t\t\t// * the token is invalid, in case of a retry token.\n\t\t\t\tselect {\n\t\t\t\tcase s.invalidTokenQueue <- rejectedPacket{receivedPacket: p, hdr: hdr}:\n\t\t\t\tdefault:\n\t\t\t\t\t// drop packet if we can't send out the  INVALID_TOKEN packets fast enough\n\t\t\t\t\tp.buffer.Release()\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif token == nil && s.verifySourceAddress != nil && s.verifySourceAddress(p.remoteAddr) {\n\t\t// Retry invalidates all 0-RTT packets sent.\n\t\tdelete(s.zeroRTTQueues, hdr.DestConnectionID)\n\t\tselect {\n\t\tcase s.retryQueue <- rejectedPacket{receivedPacket: p, hdr: hdr}:\n\t\tdefault:\n\t\t\t// drop packet if we can't send out Retry packets fast enough\n\t\t\tp.buffer.Release()\n\t\t}\n\t\treturn nil\n\t}\n\n\tconfig := s.config\n\tif s.config.GetConfigForClient != nil {\n\t\tconf, err := s.config.GetConfigForClient(&ClientHelloInfo{\n\t\t\tRemoteAddr:   p.remoteAddr,\n\t\t\tAddrVerified: clientAddrVerified,\n\t\t})\n\t\tif err != nil {\n\t\t\ts.logger.Debugf(\"Rejecting new connection due to GetConfigForClient callback\")\n\t\t\tdelete(s.zeroRTTQueues, hdr.DestConnectionID)\n\t\t\tselect {\n\t\t\tcase s.connectionRefusedQueue <- rejectedPacket{receivedPacket: p, hdr: hdr}:\n\t\t\tdefault:\n\t\t\t\t// drop packet if we can't send out the CONNECTION_REFUSED fast enough\n\t\t\t\tp.buffer.Release()\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tconfig = populateConfig(conf)\n\t}\n\n\tvar conn quicConn\n\tvar cancel context.CancelCauseFunc\n\tctx, cancel1 := context.WithCancelCause(context.Background())\n\tif s.connContext != nil {\n\t\tctx = s.connContext(ctx)\n\t\tif ctx == nil {\n\t\t\tpanic(\"quic: ConnContext returned nil\")\n\t\t}\n\t\t// There's no guarantee that the application returns a context\n\t\t// that's derived from the context we passed into ConnContext.\n\t\t// We need to make sure that both contexts are cancelled.\n\t\tvar cancel2 context.CancelCauseFunc\n\t\tctx, cancel2 = context.WithCancelCause(ctx)\n\t\tcancel = func(cause error) {\n\t\t\tcancel1(cause)\n\t\t\tcancel2(cause)\n\t\t}\n\t} else {\n\t\tcancel = cancel1\n\t}\n\tctx = context.WithValue(ctx, ConnectionTracingKey, nextConnTracingID())\n\tvar tracer *logging.ConnectionTracer\n\tif config.Tracer != nil {\n\t\t// Use the same connection ID that is passed to the client's GetLogWriter callback.\n\t\tconnID := hdr.DestConnectionID\n\t\tif origDestConnID.Len() > 0 {\n\t\t\tconnID = origDestConnID\n\t\t}\n\t\ttracer = config.Tracer(ctx, protocol.PerspectiveServer, connID)\n\t}\n\tconnID, err := s.connIDGenerator.GenerateConnectionID()\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.logger.Debugf(\"Changing connection ID to %s.\", connID)\n\tconn = s.newConn(\n\t\tctx,\n\t\tcancel,\n\t\tnewSendConn(s.conn, p.remoteAddr, p.info, s.logger),\n\t\ts.connHandler,\n\t\torigDestConnID,\n\t\tretrySrcConnID,\n\t\thdr.DestConnectionID,\n\t\thdr.SrcConnectionID,\n\t\tconnID,\n\t\ts.connIDGenerator,\n\t\ts.connHandler.GetStatelessResetToken(connID),\n\t\tconfig,\n\t\ts.tlsConf,\n\t\ts.tokenGenerator,\n\t\tclientAddrVerified,\n\t\ttracer,\n\t\ts.logger,\n\t\thdr.Version,\n\t)\n\tconn.handlePacket(p)\n\t// Adding the connection will fail if the client's chosen Destination Connection ID is already in use.\n\t// This is very unlikely: Even if an attacker chooses a connection ID that's already in use,\n\t// under normal circumstances the packet would just be routed to that connection.\n\t// The only time this collision will occur if we receive the two Initial packets at the same time.\n\tif added := s.connHandler.AddWithConnID(hdr.DestConnectionID, connID, conn); !added {\n\t\tdelete(s.zeroRTTQueues, hdr.DestConnectionID)\n\t\tconn.closeWithTransportError(qerr.ConnectionRefused)\n\t\treturn nil\n\t}\n\t// Pass queued 0-RTT to the newly established connection.\n\tif q, ok := s.zeroRTTQueues[hdr.DestConnectionID]; ok {\n\t\tfor _, p := range q.packets {\n\t\t\tconn.handlePacket(p)\n\t\t}\n\t\tdelete(s.zeroRTTQueues, hdr.DestConnectionID)\n\t}\n\n\ts.handshakingCount.Add(1)\n\tgo func() {\n\t\tdefer s.handshakingCount.Done()\n\t\ts.handleNewConn(conn)\n\t}()\n\tgo conn.run()\n\treturn nil\n}\n\nfunc (s *baseServer) handleNewConn(conn quicConn) {\n\tif s.acceptEarlyConns {\n\t\t// wait until the early connection is ready, the handshake fails, or the server is closed\n\t\tselect {\n\t\tcase <-s.errorChan:\n\t\t\tconn.closeWithTransportError(ConnectionRefused)\n\t\t\treturn\n\t\tcase <-conn.Context().Done():\n\t\t\treturn\n\t\tcase <-conn.earlyConnReady():\n\t\t}\n\t} else {\n\t\t// wait until the handshake completes, fails, or the server is closed\n\t\tselect {\n\t\tcase <-s.errorChan:\n\t\t\tconn.closeWithTransportError(ConnectionRefused)\n\t\t\treturn\n\t\tcase <-conn.Context().Done():\n\t\t\treturn\n\t\tcase <-conn.HandshakeComplete():\n\t\t}\n\t}\n\n\tselect {\n\tcase s.connQueue <- conn:\n\tdefault:\n\t\tconn.closeWithTransportError(ConnectionRefused)\n\t}\n}\n\nfunc (s *baseServer) sendRetry(p rejectedPacket) {\n\tif err := s.sendRetryPacket(p); err != nil {\n\t\ts.logger.Debugf(\"Error sending Retry packet: %s\", err)\n\t}\n}\n\nfunc (s *baseServer) sendRetryPacket(p rejectedPacket) error {\n\thdr := p.hdr\n\t// Log the Initial packet now.\n\t// If no Retry is sent, the packet will be logged by the connection.\n\t(&wire.ExtendedHeader{Header: *hdr}).Log(s.logger)\n\tsrcConnID, err := s.connIDGenerator.GenerateConnectionID()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoken, err := s.tokenGenerator.NewRetryToken(p.remoteAddr, hdr.DestConnectionID, srcConnID)\n\tif err != nil {\n\t\treturn err\n\t}\n\treplyHdr := &wire.ExtendedHeader{}\n\treplyHdr.Type = protocol.PacketTypeRetry\n\treplyHdr.Version = hdr.Version\n\treplyHdr.SrcConnectionID = srcConnID\n\treplyHdr.DestConnectionID = hdr.SrcConnectionID\n\treplyHdr.Token = token\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Changing connection ID to %s.\", srcConnID)\n\t\ts.logger.Debugf(\"-> Sending Retry\")\n\t\treplyHdr.Log(s.logger)\n\t}\n\n\tbuf := getPacketBuffer()\n\tdefer buf.Release()\n\tbuf.Data, err = replyHdr.Append(buf.Data, hdr.Version)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// append the Retry integrity tag\n\ttag := handshake.GetRetryIntegrityTag(buf.Data, hdr.DestConnectionID, hdr.Version)\n\tbuf.Data = append(buf.Data, tag[:]...)\n\tif s.tracer != nil && s.tracer.SentPacket != nil {\n\t\ts.tracer.SentPacket(p.remoteAddr, &replyHdr.Header, protocol.ByteCount(len(buf.Data)), nil)\n\t}\n\t_, err = s.conn.WritePacket(buf.Data, p.remoteAddr, p.info.OOB(), 0, protocol.ECNUnsupported)\n\treturn err\n}\n\nfunc (s *baseServer) maybeSendInvalidToken(p rejectedPacket) {\n\tdefer p.buffer.Release()\n\n\t// Only send INVALID_TOKEN if we can unprotect the packet.\n\t// This makes sure that we won't send it for packets that were corrupted.\n\thdr := p.hdr\n\tsealer, opener := handshake.NewInitialAEAD(hdr.DestConnectionID, protocol.PerspectiveServer, hdr.Version)\n\tdata := p.data[:hdr.ParsedLen()+hdr.Length]\n\textHdr, err := unpackLongHeader(opener, hdr, data)\n\t// Only send INVALID_TOKEN if we can unprotect the packet.\n\t// This makes sure that we won't send it for packets that were corrupted.\n\tif err != nil {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeInitial, p.Size(), logging.PacketDropHeaderParseError)\n\t\t}\n\t\treturn\n\t}\n\thdrLen := extHdr.ParsedLen()\n\tif _, err := opener.Open(data[hdrLen:hdrLen], data[hdrLen:], extHdr.PacketNumber, data[:hdrLen]); err != nil {\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeInitial, p.Size(), logging.PacketDropPayloadDecryptError)\n\t\t}\n\t\treturn\n\t}\n\tif s.logger.Debug() {\n\t\ts.logger.Debugf(\"Client sent an invalid retry token. Sending INVALID_TOKEN to %s.\", p.remoteAddr)\n\t}\n\tif err := s.sendError(p.remoteAddr, hdr, sealer, qerr.InvalidToken, p.info); err != nil {\n\t\ts.logger.Debugf(\"Error sending INVALID_TOKEN error: %s\", err)\n\t}\n}\n\nfunc (s *baseServer) sendConnectionRefused(p rejectedPacket) {\n\tdefer p.buffer.Release()\n\tsealer, _ := handshake.NewInitialAEAD(p.hdr.DestConnectionID, protocol.PerspectiveServer, p.hdr.Version)\n\tif err := s.sendError(p.remoteAddr, p.hdr, sealer, qerr.ConnectionRefused, p.info); err != nil {\n\t\ts.logger.Debugf(\"Error sending CONNECTION_REFUSED error: %s\", err)\n\t}\n}\n\n// sendError sends the error as a response to the packet received with header hdr\nfunc (s *baseServer) sendError(remoteAddr net.Addr, hdr *wire.Header, sealer handshake.LongHeaderSealer, errorCode qerr.TransportErrorCode, info packetInfo) error {\n\tb := getPacketBuffer()\n\tdefer b.Release()\n\n\tccf := &wire.ConnectionCloseFrame{ErrorCode: uint64(errorCode)}\n\n\treplyHdr := &wire.ExtendedHeader{}\n\treplyHdr.Type = protocol.PacketTypeInitial\n\treplyHdr.Version = hdr.Version\n\treplyHdr.SrcConnectionID = hdr.DestConnectionID\n\treplyHdr.DestConnectionID = hdr.SrcConnectionID\n\treplyHdr.PacketNumberLen = protocol.PacketNumberLen4\n\treplyHdr.Length = 4 /* packet number len */ + ccf.Length(hdr.Version) + protocol.ByteCount(sealer.Overhead())\n\tvar err error\n\tb.Data, err = replyHdr.Append(b.Data, hdr.Version)\n\tif err != nil {\n\t\treturn err\n\t}\n\tpayloadOffset := len(b.Data)\n\n\tb.Data, err = ccf.Append(b.Data, hdr.Version)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_ = sealer.Seal(b.Data[payloadOffset:payloadOffset], b.Data[payloadOffset:], replyHdr.PacketNumber, b.Data[:payloadOffset])\n\tb.Data = b.Data[0 : len(b.Data)+sealer.Overhead()]\n\n\tpnOffset := payloadOffset - int(replyHdr.PacketNumberLen)\n\tsealer.EncryptHeader(\n\t\tb.Data[pnOffset+4:pnOffset+4+16],\n\t\t&b.Data[0],\n\t\tb.Data[pnOffset:payloadOffset],\n\t)\n\n\treplyHdr.Log(s.logger)\n\twire.LogFrame(s.logger, ccf, true)\n\tif s.tracer != nil && s.tracer.SentPacket != nil {\n\t\ts.tracer.SentPacket(remoteAddr, &replyHdr.Header, protocol.ByteCount(len(b.Data)), []logging.Frame{ccf})\n\t}\n\t_, err = s.conn.WritePacket(b.Data, remoteAddr, info.OOB(), 0, protocol.ECNUnsupported)\n\treturn err\n}\n\nfunc (s *baseServer) enqueueVersionNegotiationPacket(p receivedPacket) (bufferInUse bool) {\n\tselect {\n\tcase s.versionNegotiationQueue <- p:\n\t\treturn true\n\tdefault:\n\t\t// it's fine to not send version negotiation packets when we are busy\n\t}\n\treturn false\n}\n\nfunc (s *baseServer) maybeSendVersionNegotiationPacket(p receivedPacket) {\n\tdefer p.buffer.Release()\n\n\tv, err := wire.ParseVersion(p.data)\n\tif err != nil {\n\t\ts.logger.Debugf(\"failed to parse version for sending version negotiation packet: %s\", err)\n\t\treturn\n\t}\n\n\t_, src, dest, err := wire.ParseArbitraryLenConnectionIDs(p.data)\n\tif err != nil { // should never happen\n\t\ts.logger.Debugf(\"Dropping a packet with an unknown version for which we failed to parse connection IDs\")\n\t\tif s.tracer != nil && s.tracer.DroppedPacket != nil {\n\t\t\ts.tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t}\n\t\treturn\n\t}\n\n\ts.logger.Debugf(\"Client offered version %s, sending Version Negotiation\", v)\n\n\tdata := wire.ComposeVersionNegotiation(dest, src, s.config.Versions)\n\tif s.tracer != nil && s.tracer.SentVersionNegotiationPacket != nil {\n\t\ts.tracer.SentVersionNegotiationPacket(p.remoteAddr, src, dest, s.config.Versions)\n\t}\n\tif _, err := s.conn.WritePacket(data, p.remoteAddr, p.info.OOB(), 0, protocol.ECNUnsupported); err != nil {\n\t\ts.logger.Debugf(\"Error sending Version Negotiation: %s\", err)\n\t}\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 55.98046875,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"golang.org/x/time/rate\"\n\n\t\"github.com/quic-go/quic-go/internal/handshake\"\n\tmocklogging \"github.com/quic-go/quic-go/internal/mocks/logging\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/testdata\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nvar _ = Describe(\"Server\", func() {\n\tvar (\n\t\tconn    *MockPacketConn\n\t\ttlsConf *tls.Config\n\t)\n\n\tgetPacket := func(hdr *wire.Header, p []byte) receivedPacket {\n\t\tbuf := getPacketBuffer()\n\t\thdr.Length = 4 + protocol.ByteCount(len(p)) + 16\n\t\tvar err error\n\t\tbuf.Data, err = (&wire.ExtendedHeader{\n\t\t\tHeader:          *hdr,\n\t\t\tPacketNumber:    0x42,\n\t\t\tPacketNumberLen: protocol.PacketNumberLen4,\n\t\t}).Append(buf.Data, protocol.Version1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tn := len(buf.Data)\n\t\tbuf.Data = append(buf.Data, p...)\n\t\tdata := buf.Data\n\t\tsealer, _ := handshake.NewInitialAEAD(hdr.DestConnectionID, protocol.PerspectiveClient, hdr.Version)\n\t\t_ = sealer.Seal(data[n:n], data[n:], 0x42, data[:n])\n\t\tdata = data[:len(data)+16]\n\t\tsealer.EncryptHeader(data[n:n+16], &data[0], data[n-4:n])\n\t\treturn receivedPacket{\n\t\t\trcvTime:    time.Now(),\n\t\t\tremoteAddr: &net.UDPAddr{IP: net.IPv4(4, 5, 6, 7), Port: 456},\n\t\t\tdata:       data,\n\t\t\tbuffer:     buf,\n\t\t}\n\t}\n\n\tgetInitial := func(destConnID protocol.ConnectionID) receivedPacket {\n\t\tsenderAddr := &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 42}\n\t\thdr := &wire.Header{\n\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\tDestConnectionID: destConnID,\n\t\t\tVersion:          protocol.Version1,\n\t\t}\n\t\tp := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\tp.buffer = getPacketBuffer()\n\t\tp.remoteAddr = senderAddr\n\t\treturn p\n\t}\n\n\tgetInitialWithRandomDestConnID := func() receivedPacket {\n\t\tb := make([]byte, 10)\n\t\t_, err := rand.Read(b)\n\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\treturn getInitial(protocol.ParseConnectionID(b))\n\t}\n\n\tparseHeader := func(data []byte) *wire.Header {\n\t\thdr, _, _, err := wire.ParsePacket(data)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\treturn hdr\n\t}\n\n\tcheckConnectionCloseError := func(b []byte, origHdr *wire.Header, errorCode qerr.TransportErrorCode) {\n\t\treplyHdr := parseHeader(b)\n\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeInitial))\n\t\tExpect(replyHdr.SrcConnectionID).To(Equal(origHdr.DestConnectionID))\n\t\tExpect(replyHdr.DestConnectionID).To(Equal(origHdr.SrcConnectionID))\n\t\t_, opener := handshake.NewInitialAEAD(origHdr.DestConnectionID, protocol.PerspectiveClient, replyHdr.Version)\n\t\textHdr, err := unpackLongHeader(opener, replyHdr, b)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tdata, err := opener.Open(nil, b[extHdr.ParsedLen():], extHdr.PacketNumber, b[:extHdr.ParsedLen()])\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\t_, f, err := wire.NewFrameParser(false).ParseNext(data, protocol.EncryptionInitial, origHdr.Version)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(f).To(BeAssignableToTypeOf(&wire.ConnectionCloseFrame{}))\n\t\tccf := f.(*wire.ConnectionCloseFrame)\n\t\tExpect(ccf.IsApplicationError).To(BeFalse())\n\t\tExpect(ccf.ErrorCode).To(BeEquivalentTo(errorCode))\n\t\tExpect(ccf.ReasonPhrase).To(BeEmpty())\n\t}\n\n\tBeforeEach(func() {\n\t\tconn = NewMockPacketConn(mockCtrl)\n\t\tconn.EXPECT().LocalAddr().Return(&net.UDPAddr{}).AnyTimes()\n\t\twait := make(chan struct{})\n\t\tconn.EXPECT().ReadFrom(gomock.Any()).DoAndReturn(func(_ []byte) (int, net.Addr, error) {\n\t\t\t<-wait\n\t\t\treturn 0, nil, errors.New(\"done\")\n\t\t}).MaxTimes(1)\n\t\tconn.EXPECT().SetReadDeadline(gomock.Any()).Do(func(time.Time) error {\n\t\t\tclose(wait)\n\t\t\tconn.EXPECT().SetReadDeadline(time.Time{})\n\t\t\treturn nil\n\t\t}).MaxTimes(1)\n\t\ttlsConf = testdata.GetTLSConfig()\n\t\ttlsConf.NextProtos = []string{\"proto1\"}\n\t})\n\n\tIt(\"errors when no tls.Config is given\", func() {\n\t\t_, err := ListenAddr(\"localhost:0\", nil, nil)\n\t\tExpect(err).To(HaveOccurred())\n\t\tExpect(err.Error()).To(ContainSubstring(\"quic: tls.Config not set\"))\n\t})\n\n\tIt(\"errors when the Config contains an invalid version\", func() {\n\t\tversion := protocol.Version(0x1234)\n\t\t_, err := Listen(nil, tlsConf, &Config{Versions: []protocol.Version{version}})\n\t\tExpect(err).To(MatchError(\"invalid QUIC version: 0x1234\"))\n\t})\n\n\tIt(\"fills in default values if options are not set in the Config\", func() {\n\t\tln, err := Listen(conn, tlsConf, &Config{})\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tserver := ln.baseServer\n\t\tExpect(server.config.Versions).To(Equal(protocol.SupportedVersions))\n\t\tExpect(server.config.HandshakeIdleTimeout).To(Equal(protocol.DefaultHandshakeIdleTimeout))\n\t\tExpect(server.config.MaxIdleTimeout).To(Equal(protocol.DefaultIdleTimeout))\n\t\tExpect(server.config.KeepAlivePeriod).To(BeZero())\n\t\t// stop the listener\n\t\tExpect(ln.Close()).To(Succeed())\n\t})\n\n\tIt(\"setups with the right values\", func() {\n\t\tsupportedVersions := []protocol.Version{protocol.Version1}\n\t\tconfig := Config{\n\t\t\tVersions:             supportedVersions,\n\t\t\tHandshakeIdleTimeout: 1337 * time.Hour,\n\t\t\tMaxIdleTimeout:       42 * time.Minute,\n\t\t\tKeepAlivePeriod:      5 * time.Second,\n\t\t}\n\t\tln, err := Listen(conn, tlsConf, &config)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tserver := ln.baseServer\n\t\tExpect(server.connHandler).ToNot(BeNil())\n\t\tExpect(server.config.Versions).To(Equal(supportedVersions))\n\t\tExpect(server.config.HandshakeIdleTimeout).To(Equal(1337 * time.Hour))\n\t\tExpect(server.config.MaxIdleTimeout).To(Equal(42 * time.Minute))\n\t\tExpect(server.config.KeepAlivePeriod).To(Equal(5 * time.Second))\n\t\t// stop the listener\n\t\tExpect(ln.Close()).To(Succeed())\n\t})\n\n\tIt(\"listens on a given address\", func() {\n\t\taddr := \"127.0.0.1:13579\"\n\t\tln, err := ListenAddr(addr, tlsConf, &Config{})\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(ln.Addr().String()).To(Equal(addr))\n\t\t// stop the listener\n\t\tExpect(ln.Close()).To(Succeed())\n\t})\n\n\tIt(\"errors if given an invalid address\", func() {\n\t\taddr := \"127.0.0.1\"\n\t\t_, err := ListenAddr(addr, tlsConf, &Config{})\n\t\tExpect(err).To(BeAssignableToTypeOf(&net.AddrError{}))\n\t})\n\n\tIt(\"errors if given an invalid address\", func() {\n\t\taddr := \"1.1.1.1:1111\"\n\t\t_, err := ListenAddr(addr, tlsConf, &Config{})\n\t\tExpect(err).To(BeAssignableToTypeOf(&net.OpError{}))\n\t})\n\n\tContext(\"server accepting connections that completed the handshake\", func() {\n\t\tvar (\n\t\t\ttr     *Transport\n\t\t\tserv   *baseServer\n\t\t\tphm    *MockPacketHandlerManager\n\t\t\ttracer *mocklogging.MockTracer\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\tvar t *logging.Tracer\n\t\t\tt, tracer = mocklogging.NewMockTracer(mockCtrl)\n\t\t\ttr = &Transport{Conn: conn, Tracer: t}\n\t\t\tln, err := tr.Listen(tlsConf, nil)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tserv = ln.baseServer\n\t\t\tphm = NewMockPacketHandlerManager(mockCtrl)\n\t\t\tserv.connHandler = phm\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\ttracer.EXPECT().Close()\n\t\t\ttr.Close()\n\t\t})\n\n\t\tContext(\"handling packets\", func() {\n\t\t\tIt(\"drops Initial packets with a too short connection ID\", func() {\n\t\t\t\tp := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4}),\n\t\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t\t}, nil)\n\t\t\t\ttracer.EXPECT().DroppedPacket(p.remoteAddr, logging.PacketTypeInitial, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\t// make sure there are no Write calls on the packet conn\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t})\n\n\t\t\tIt(\"drops too small Initial\", func() {\n\t\t\t\tp := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}),\n\t\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t\t}, make([]byte, protocol.MinInitialPacketSize-100))\n\t\t\t\ttracer.EXPECT().DroppedPacket(p.remoteAddr, logging.PacketTypeInitial, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\t// make sure there are no Write calls on the packet conn\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t})\n\n\t\t\tIt(\"drops non-Initial packets\", func() {\n\t\t\t\tp := getPacket(&wire.Header{\n\t\t\t\t\tType:    protocol.PacketTypeHandshake,\n\t\t\t\t\tVersion: serv.config.Versions[0],\n\t\t\t\t}, []byte(\"invalid\"))\n\t\t\t\ttracer.EXPECT().DroppedPacket(p.remoteAddr, logging.PacketTypeHandshake, p.Size(), logging.PacketDropUnexpectedPacket)\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\t// make sure there are no Write calls on the packet conn\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t})\n\n\t\t\tIt(\"passes packets to existing connections\", func() {\n\t\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\t\t\t\tp := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t\t}, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tconn := NewMockPacketHandler(mockCtrl)\n\t\t\t\tphm.EXPECT().Get(connID).Return(conn, true)\n\t\t\t\thandled := make(chan struct{})\n\t\t\t\tconn.EXPECT().handlePacket(p).Do(func(receivedPacket) { close(handled) })\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\tEventually(handled).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"creates a connection when the token is accepted\", func() {\n\t\t\t\tserv.verifySourceAddress = func(net.Addr) bool { return true }\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tretryToken, err := serv.tokenGenerator.NewRetryToken(\n\t\t\t\t\traddr,\n\t\t\t\t\tprotocol.ParseConnectionID([]byte{0xde, 0xad, 0xc0, 0xde}),\n\t\t\t\t\tprotocol.ParseConnectionID([]byte{0xde, 0xca, 0xfb, 0xad}),\n\t\t\t\t)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t\tToken:            retryToken,\n\t\t\t\t}\n\t\t\t\tp := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tp.remoteAddr = raddr\n\t\t\t\trun := make(chan struct{})\n\t\t\t\tvar token protocol.StatelessResetToken\n\t\t\t\trand.Read(token[:])\n\n\t\t\t\tvar newConnID protocol.ConnectionID\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\t_ connRunner,\n\t\t\t\t\torigDestConnID protocol.ConnectionID,\n\t\t\t\t\tretrySrcConnID *protocol.ConnectionID,\n\t\t\t\t\tclientDestConnID protocol.ConnectionID,\n\t\t\t\t\tdestConnID protocol.ConnectionID,\n\t\t\t\t\tsrcConnID protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\ttokenP protocol.StatelessResetToken,\n\t\t\t\t\t_ *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tExpect(origDestConnID).To(Equal(protocol.ParseConnectionID([]byte{0xde, 0xad, 0xc0, 0xde})))\n\t\t\t\t\tExpect(*retrySrcConnID).To(Equal(protocol.ParseConnectionID([]byte{0xde, 0xca, 0xfb, 0xad})))\n\t\t\t\t\tExpect(clientDestConnID).To(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(destConnID).To(Equal(hdr.SrcConnectionID))\n\t\t\t\t\t// make sure we're using a server-generated connection ID\n\t\t\t\t\tExpect(srcConnID).ToNot(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(srcConnID).ToNot(Equal(hdr.SrcConnectionID))\n\t\t\t\t\tnewConnID = srcConnID\n\t\t\t\t\tExpect(tokenP).To(Equal(token))\n\t\t\t\t\tconn.EXPECT().handlePacket(p)\n\t\t\t\t\tconn.EXPECT().run().Do(func() error { close(run); return nil })\n\t\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{}))\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\t\t\t\tphm.EXPECT().Get(connID)\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any()).Return(token)\n\t\t\t\tphm.EXPECT().AddWithConnID(connID, gomock.Any(), gomock.Any()).DoAndReturn(func(_, cid protocol.ConnectionID, h packetHandler) bool {\n\t\t\t\t\tExpect(cid).To(Equal(newConnID))\n\t\t\t\t\treturn true\n\t\t\t\t})\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tserv.handlePacket(p)\n\t\t\t\t\t// the Handshake packet is written by the connection.\n\t\t\t\t\t// Make sure there are no Write calls on the packet conn.\n\t\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\t\tclose(done)\n\t\t\t\t}()\n\t\t\t\t// make sure we're using a server-generated connection ID\n\t\t\t\tEventually(run).Should(BeClosed())\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t\t// shutdown\n\t\t\t\tconn.EXPECT().closeWithTransportError(gomock.Any())\n\t\t\t})\n\n\t\t\tIt(\"sends a Version Negotiation Packet for unsupported versions\", func() {\n\t\t\t\tsrcConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5})\n\t\t\t\tdestConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6})\n\t\t\t\tpacket := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tVersion:          0x42,\n\t\t\t\t}, make([]byte, protocol.MinUnknownVersionPacketSize))\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\ttracer.EXPECT().SentVersionNegotiationPacket(packet.remoteAddr, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ net.Addr, src, dest protocol.ArbitraryLenConnectionID, _ []protocol.Version) {\n\t\t\t\t\tExpect(src).To(Equal(protocol.ArbitraryLenConnectionID(destConnID.Bytes())))\n\t\t\t\t\tExpect(dest).To(Equal(protocol.ArbitraryLenConnectionID(srcConnID.Bytes())))\n\t\t\t\t})\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), raddr).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\tExpect(wire.IsVersionNegotiationPacket(b)).To(BeTrue())\n\t\t\t\t\tdest, src, versions, err := wire.ParseVersionNegotiationPacket(b)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(dest).To(Equal(protocol.ArbitraryLenConnectionID(srcConnID.Bytes())))\n\t\t\t\t\tExpect(src).To(Equal(protocol.ArbitraryLenConnectionID(destConnID.Bytes())))\n\t\t\t\t\tExpect(versions).ToNot(ContainElement(protocol.Version(0x42)))\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"doesn't send a Version Negotiation packets if sending them is disabled\", func() {\n\t\t\t\tserv.disableVersionNegotiation = true\n\t\t\t\tsrcConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5})\n\t\t\t\tdestConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6})\n\t\t\t\tpacket := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tVersion:          0x42,\n\t\t\t\t}, make([]byte, protocol.MinUnknownVersionPacketSize))\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\tConsistently(done, 50*time.Millisecond).ShouldNot(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"ignores Version Negotiation packets\", func() {\n\t\t\t\tdata := wire.ComposeVersionNegotiation(\n\t\t\t\t\tprotocol.ArbitraryLenConnectionID{1, 2, 3, 4},\n\t\t\t\t\tprotocol.ArbitraryLenConnectionID{4, 3, 2, 1},\n\t\t\t\t\t[]protocol.Version{1, 2, 3},\n\t\t\t\t)\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\ttracer.EXPECT().DroppedPacket(raddr, logging.PacketTypeVersionNegotiation, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket).Do(func(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\t\t\tclose(done)\n\t\t\t\t})\n\t\t\t\tserv.handlePacket(receivedPacket{\n\t\t\t\t\tremoteAddr: raddr,\n\t\t\t\t\tdata:       data,\n\t\t\t\t\tbuffer:     getPacketBuffer(),\n\t\t\t\t})\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t\t// make sure no other packet is sent\n\t\t\t\ttime.Sleep(scaleDuration(20 * time.Millisecond))\n\t\t\t})\n\n\t\t\tIt(\"doesn't send a Version Negotiation Packet for unsupported versions, if the packet is too small\", func() {\n\t\t\t\tsrcConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5})\n\t\t\t\tdestConnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6})\n\t\t\t\tp := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeHandshake,\n\t\t\t\t\tSrcConnectionID:  srcConnID,\n\t\t\t\t\tDestConnectionID: destConnID,\n\t\t\t\t\tVersion:          0x42,\n\t\t\t\t}, make([]byte, protocol.MinUnknownVersionPacketSize-50))\n\t\t\t\tExpect(p.Size()).To(BeNumerically(\"<\", protocol.MinUnknownVersionPacketSize))\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tp.remoteAddr = raddr\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\ttracer.EXPECT().DroppedPacket(raddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnexpectedPacket).Do(func(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\t\t\tclose(done)\n\t\t\t\t})\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t\t// make sure no other packet is sent\n\t\t\t\ttime.Sleep(scaleDuration(20 * time.Millisecond))\n\t\t\t})\n\n\t\t\tIt(\"replies with a Retry packet, if a token is required\", func() {\n\t\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tvar called bool\n\t\t\t\tserv.verifySourceAddress = func(addr net.Addr) bool {\n\t\t\t\t\tExpect(addr).To(Equal(raddr))\n\t\t\t\t\tcalled = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t}\n\t\t\t\tpacket := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\ttracer.EXPECT().SentPacket(packet.remoteAddr, gomock.Any(), gomock.Any(), nil).Do(func(_ net.Addr, replyHdr *logging.Header, _ logging.ByteCount, _ []logging.Frame) {\n\t\t\t\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeRetry))\n\t\t\t\t\tExpect(replyHdr.SrcConnectionID).ToNot(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(replyHdr.DestConnectionID).To(Equal(hdr.SrcConnectionID))\n\t\t\t\t\tExpect(replyHdr.Token).ToNot(BeEmpty())\n\t\t\t\t})\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), raddr).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\treplyHdr := parseHeader(b)\n\t\t\t\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeRetry))\n\t\t\t\t\tExpect(replyHdr.SrcConnectionID).ToNot(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(replyHdr.DestConnectionID).To(Equal(hdr.SrcConnectionID))\n\t\t\t\t\tExpect(replyHdr.Token).ToNot(BeEmpty())\n\t\t\t\t\tExpect(b[len(b)-16:]).To(Equal(handshake.GetRetryIntegrityTag(b[:len(b)-16], hdr.DestConnectionID, hdr.Version)[:]))\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tphm.EXPECT().Get(connID)\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t\tExpect(called).To(BeTrue())\n\t\t\t})\n\n\t\t\tIt(\"creates a connection, if no token is required\", func() {\n\t\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t}\n\t\t\t\tp := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\trun := make(chan struct{})\n\t\t\t\tvar token protocol.StatelessResetToken\n\t\t\t\trand.Read(token[:])\n\n\t\t\t\tvar newConnID protocol.ConnectionID\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\t_ connRunner,\n\t\t\t\t\torigDestConnID protocol.ConnectionID,\n\t\t\t\t\tretrySrcConnID *protocol.ConnectionID,\n\t\t\t\t\tclientDestConnID protocol.ConnectionID,\n\t\t\t\t\tdestConnID protocol.ConnectionID,\n\t\t\t\t\tsrcConnID protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\ttokenP protocol.StatelessResetToken,\n\t\t\t\t\t_ *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tExpect(origDestConnID).To(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(retrySrcConnID).To(BeNil())\n\t\t\t\t\tExpect(clientDestConnID).To(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(destConnID).To(Equal(hdr.SrcConnectionID))\n\t\t\t\t\t// make sure we're using a server-generated connection ID\n\t\t\t\t\tExpect(srcConnID).ToNot(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(srcConnID).ToNot(Equal(hdr.SrcConnectionID))\n\t\t\t\t\tnewConnID = srcConnID\n\t\t\t\t\tExpect(tokenP).To(Equal(token))\n\t\t\t\t\tconn.EXPECT().handlePacket(p)\n\t\t\t\t\tconn.EXPECT().run().Do(func() error { close(run); return nil })\n\t\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{}))\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\t\t\t\tgomock.InOrder(\n\t\t\t\t\tphm.EXPECT().Get(connID),\n\t\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any()).Return(token),\n\t\t\t\t\tphm.EXPECT().AddWithConnID(connID, gomock.Any(), gomock.Any()).DoAndReturn(func(_, c protocol.ConnectionID, h packetHandler) bool {\n\t\t\t\t\t\tExpect(c).To(Equal(newConnID))\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}),\n\t\t\t\t)\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tserv.handlePacket(p)\n\t\t\t\t\t// the Handshake packet is written by the connection\n\t\t\t\t\t// make sure there are no Write calls on the packet conn\n\t\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\t\tclose(done)\n\t\t\t\t}()\n\t\t\t\t// make sure we're using a server-generated connection ID\n\t\t\t\tEventually(run).Should(BeClosed())\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t\t// shutdown\n\t\t\t\tconn.EXPECT().closeWithTransportError(gomock.Any()).MaxTimes(1)\n\t\t\t})\n\n\t\t\tIt(\"drops packets if the receive queue is full\", func() {\n\t\t\t\tserv.verifySourceAddress = func(net.Addr) bool { return false }\n\n\t\t\t\tphm.EXPECT().Get(gomock.Any()).AnyTimes()\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any()).AnyTimes()\n\t\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true).AnyTimes()\n\n\t\t\t\tacceptConn := make(chan struct{})\n\t\t\t\tvar counter atomic.Uint32\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\trunner connRunner,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t\t_ *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\t<-acceptConn\n\t\t\t\t\tcounter.Add(1)\n\t\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\t\tconn.EXPECT().handlePacket(gomock.Any()).MaxTimes(1)\n\t\t\t\t\tconn.EXPECT().run().MaxTimes(1)\n\t\t\t\t\tconn.EXPECT().Context().Return(context.Background()).MaxTimes(1)\n\t\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{})).MaxTimes(1)\n\t\t\t\t\t// shutdown\n\t\t\t\t\tconn.EXPECT().closeWithTransportError(gomock.Any()).MaxTimes(1)\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\n\t\t\t\tp := getInitial(protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}))\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\ttracer.EXPECT().DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropDOSPrevention).MinTimes(1)\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\tfor i := 0; i < 3*protocol.MaxServerUnprocessedPackets; i++ {\n\t\t\t\t\twg.Add(1)\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\t\tserv.handlePacket(getInitial(protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})))\n\t\t\t\t\t}()\n\t\t\t\t}\n\t\t\t\twg.Wait()\n\n\t\t\t\tclose(acceptConn)\n\t\t\t\tEventually(\n\t\t\t\t\tfunc() uint32 { return counter.Load() },\n\t\t\t\t\tscaleDuration(100*time.Millisecond),\n\t\t\t\t).Should(BeEquivalentTo(protocol.MaxServerUnprocessedPackets + 1))\n\t\t\t\tConsistently(func() uint32 { return counter.Load() }).Should(BeEquivalentTo(protocol.MaxServerUnprocessedPackets + 1))\n\t\t\t})\n\n\t\t\tIt(\"only creates a single connection for a duplicate Initial\", func() {\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\trunner connRunner,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t\t_ *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\t\tconn.EXPECT().handlePacket(gomock.Any())\n\t\t\t\t\tconn.EXPECT().closeWithTransportError(qerr.ConnectionRefused).Do(func(qerr.TransportErrorCode) {\n\t\t\t\t\t\tclose(done)\n\t\t\t\t\t})\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\n\t\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9})\n\t\t\t\tp := getInitial(connID)\n\t\t\t\tphm.EXPECT().Get(connID)\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\t\tphm.EXPECT().AddWithConnID(connID, gomock.Any(), gomock.Any()).Return(false) // connection ID collision\n\t\t\t\tExpect(serv.handlePacketImpl(p)).To(BeTrue())\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"limits the number of unvalidated handshakes\", func() {\n\t\t\t\tconst limit = 3\n\t\t\t\tlimiter := rate.NewLimiter(0, limit)\n\t\t\t\tserv.verifySourceAddress = func(net.Addr) bool { return !limiter.Allow() }\n\n\t\t\t\tphm.EXPECT().Get(gomock.Any()).AnyTimes()\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any()).AnyTimes()\n\t\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true).AnyTimes()\n\n\t\t\t\tconnChan := make(chan *MockQUICConn, 1)\n\t\t\t\tvar wg sync.WaitGroup\n\t\t\t\twg.Add(limit)\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\trunner connRunner,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t\t_ *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tconn := <-connChan\n\t\t\t\t\tconn.EXPECT().handlePacket(gomock.Any())\n\t\t\t\t\tconn.EXPECT().run()\n\t\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\t\tconn.EXPECT().HandshakeComplete().DoAndReturn(func() <-chan struct{} { wg.Done(); return done })\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\n\t\t\t\t// Initiate the maximum number of allowed connection attempts.\n\t\t\t\tfor i := 0; i < limit; i++ {\n\t\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\t\tconnChan <- conn\n\t\t\t\t\tserv.handlePacket(getInitialWithRandomDestConnID())\n\t\t\t\t}\n\n\t\t\t\t// Now initiate another connection attempt.\n\t\t\t\tp := getInitialWithRandomDestConnID()\n\t\t\t\ttracer.EXPECT().SentPacket(p.remoteAddr, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ net.Addr, replyHdr *logging.Header, _ logging.ByteCount, frames []logging.Frame) {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeRetry))\n\t\t\t\t})\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), gomock.Any()).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\thdr, _, _, err := wire.ParsePacket(b)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(hdr.Type).To(Equal(protocol.PacketTypeRetry))\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\tEventually(done).Should(BeClosed())\n\n\t\t\t\tfor i := 0; i < limit; i++ {\n\t\t\t\t\t_, err := serv.Accept(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t}\n\t\t\t\twg.Wait()\n\t\t\t})\n\t\t})\n\n\t\tContext(\"token validation\", func() {\n\t\t\tIt(\"decodes the token from the token field\", func() {\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\t_ connRunner,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t\t_ *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tc := NewMockQUICConn(mockCtrl)\n\t\t\t\t\tc.EXPECT().handlePacket(gomock.Any())\n\t\t\t\t\tc.EXPECT().run()\n\t\t\t\t\tc.EXPECT().HandshakeComplete()\n\t\t\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\t\t\tcancel()\n\t\t\t\t\tc.EXPECT().Context().Return(ctx)\n\t\t\t\t\treturn c\n\t\t\t\t}\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(192, 168, 13, 37), Port: 1337}\n\t\t\t\ttoken, err := serv.tokenGenerator.NewRetryToken(raddr, protocol.ConnectionID{}, protocol.ConnectionID{})\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tpacket := getPacket(&wire.Header{\n\t\t\t\t\tType:    protocol.PacketTypeInitial,\n\t\t\t\t\tToken:   token,\n\t\t\t\t\tVersion: serv.config.Versions[0],\n\t\t\t\t}, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\t\t\ttracer.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).DoAndReturn(func(_, _ protocol.ConnectionID, _ packetHandler) bool {\n\t\t\t\t\tclose(done)\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t\t\tphm.EXPECT().Remove(gomock.Any()).AnyTimes()\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"sends an INVALID_TOKEN error, if an invalid retry token is received\", func() {\n\t\t\t\tserv.verifySourceAddress = func(net.Addr) bool { return true }\n\t\t\t\ttoken, err := serv.tokenGenerator.NewRetryToken(&net.UDPAddr{}, protocol.ConnectionID{}, protocol.ConnectionID{})\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}),\n\t\t\t\t\tToken:            token,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t}\n\t\t\t\tpacket := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tpacket.data = append(packet.data, []byte(\"coalesced packet\")...) // add some garbage to simulate a coalesced packet\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\ttracer.EXPECT().SentPacket(packet.remoteAddr, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ net.Addr, replyHdr *logging.Header, _ logging.ByteCount, frames []logging.Frame) {\n\t\t\t\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeInitial))\n\t\t\t\t\tExpect(replyHdr.SrcConnectionID).To(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(replyHdr.DestConnectionID).To(Equal(hdr.SrcConnectionID))\n\t\t\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\t\t\tExpect(frames[0]).To(BeAssignableToTypeOf(&wire.ConnectionCloseFrame{}))\n\t\t\t\t\tccf := frames[0].(*logging.ConnectionCloseFrame)\n\t\t\t\t\tExpect(ccf.IsApplicationError).To(BeFalse())\n\t\t\t\t\tExpect(ccf.ErrorCode).To(BeEquivalentTo(qerr.InvalidToken))\n\t\t\t\t})\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), raddr).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\tcheckConnectionCloseError(b, hdr, qerr.InvalidToken)\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"sends an INVALID_TOKEN error, if an expired retry token is received\", func() {\n\t\t\t\tserv.verifySourceAddress = func(net.Addr) bool { return true }\n\t\t\t\tserv.config.HandshakeIdleTimeout = time.Millisecond / 2 // the maximum retry token age is equivalent to the handshake timeout\n\t\t\t\tExpect(serv.config.maxRetryTokenAge()).To(Equal(time.Millisecond))\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\ttoken, err := serv.tokenGenerator.NewRetryToken(raddr, protocol.ConnectionID{}, protocol.ConnectionID{})\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\ttime.Sleep(2 * time.Millisecond) // make sure the token is expired\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}),\n\t\t\t\t\tToken:            token,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t}\n\t\t\t\tpacket := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\ttracer.EXPECT().SentPacket(packet.remoteAddr, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ net.Addr, replyHdr *logging.Header, _ logging.ByteCount, frames []logging.Frame) {\n\t\t\t\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeInitial))\n\t\t\t\t\tExpect(replyHdr.SrcConnectionID).To(Equal(hdr.DestConnectionID))\n\t\t\t\t\tExpect(replyHdr.DestConnectionID).To(Equal(hdr.SrcConnectionID))\n\t\t\t\t\tExpect(frames).To(HaveLen(1))\n\t\t\t\t\tExpect(frames[0]).To(BeAssignableToTypeOf(&wire.ConnectionCloseFrame{}))\n\t\t\t\t\tccf := frames[0].(*logging.ConnectionCloseFrame)\n\t\t\t\t\tExpect(ccf.IsApplicationError).To(BeFalse())\n\t\t\t\t\tExpect(ccf.ErrorCode).To(BeEquivalentTo(qerr.InvalidToken))\n\t\t\t\t})\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), raddr).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\tcheckConnectionCloseError(b, hdr, qerr.InvalidToken)\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"doesn't send an INVALID_TOKEN error, if an invalid non-retry token is received\", func() {\n\t\t\t\tserv.verifySourceAddress = func(net.Addr) bool { return true }\n\t\t\t\ttoken, err := serv.tokenGenerator.NewToken(&net.UDPAddr{IP: net.IPv4(192, 168, 0, 1), Port: 1337})\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}),\n\t\t\t\t\tToken:            token,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t}\n\t\t\t\tpacket := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tpacket.data[len(packet.data)-10] ^= 0xff // corrupt the packet\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\ttracer.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any()).MaxTimes(1)\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), raddr).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\treplyHdr := parseHeader(b)\n\t\t\t\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeRetry))\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\t// make sure there are no Write calls on the packet conn\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"sends an INVALID_TOKEN error, if an expired non-retry token is received\", func() {\n\t\t\t\tserv.verifySourceAddress = func(net.Addr) bool { return true }\n\t\t\t\tserv.maxTokenAge = time.Millisecond\n\t\t\t\traddr := &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\ttoken, err := serv.tokenGenerator.NewToken(raddr)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\ttime.Sleep(2 * time.Millisecond) // make sure the token is expired\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}),\n\t\t\t\t\tToken:            token,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t}\n\t\t\t\tpacket := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tpacket.remoteAddr = raddr\n\t\t\t\ttracer.EXPECT().SentPacket(packet.remoteAddr, gomock.Any(), gomock.Any(), gomock.Any()).Do(func(_ net.Addr, replyHdr *logging.Header, _ logging.ByteCount, frames []logging.Frame) {\n\t\t\t\t\tExpect(replyHdr.Type).To(Equal(protocol.PacketTypeRetry))\n\t\t\t\t})\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), raddr).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"doesn't send an INVALID_TOKEN error, if the packet is corrupted\", func() {\n\t\t\t\ttoken, err := serv.tokenGenerator.NewRetryToken(&net.UDPAddr{}, protocol.ConnectionID{}, protocol.ConnectionID{})\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\thdr := &wire.Header{\n\t\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\t\tSrcConnectionID:  protocol.ParseConnectionID([]byte{5, 4, 3, 2, 1}),\n\t\t\t\t\tDestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}),\n\t\t\t\t\tToken:            token,\n\t\t\t\t\tVersion:          protocol.Version1,\n\t\t\t\t}\n\t\t\t\tpacket := getPacket(hdr, make([]byte, protocol.MinInitialPacketSize))\n\t\t\t\tpacket.data[len(packet.data)-10] ^= 0xff // corrupt the packet\n\t\t\t\tpacket.remoteAddr = &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 1337}\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\ttracer.EXPECT().DroppedPacket(packet.remoteAddr, logging.PacketTypeInitial, packet.Size(), logging.PacketDropPayloadDecryptError).Do(func(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) { close(done) })\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tserv.handlePacket(packet)\n\t\t\t\t// make sure there are no Write calls on the packet conn\n\t\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\t\t})\n\n\t\tContext(\"accepting connections\", func() {\n\t\t\tIt(\"returns Accept when closed\", func() {\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\t_, err := serv.Accept(context.Background())\n\t\t\t\t\tExpect(err).To(MatchError(ErrServerClosed))\n\t\t\t\t\tExpect(err).To(MatchError(net.ErrClosed))\n\t\t\t\t\tclose(done)\n\t\t\t\t}()\n\n\t\t\t\tserv.Close()\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"returns immediately, if an error occurred before\", func() {\n\t\t\t\tserv.Close()\n\t\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t\t_, err := serv.Accept(context.Background())\n\t\t\t\t\tExpect(err).To(MatchError(ErrServerClosed))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tPIt(\"closes connection that are still handshaking after Close\", func() {\n\t\t\t\tserv.Close()\n\n\t\t\t\tdestroyed := make(chan struct{})\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\t_ connRunner,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t\tconf *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\t\tconn.EXPECT().handlePacket(gomock.Any())\n\t\t\t\t\tconn.EXPECT().closeWithTransportError(ConnectionRefused).Do(func(TransportErrorCode) { close(destroyed) })\n\t\t\t\t\tconn.EXPECT().HandshakeComplete().Return(make(chan struct{}))\n\t\t\t\t\tconn.EXPECT().run().MaxTimes(1)\n\t\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true)\n\t\t\t\tserv.handleInitialImpl(\n\t\t\t\t\treceivedPacket{buffer: getPacketBuffer()},\n\t\t\t\t\t&wire.Header{DestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})},\n\t\t\t\t)\n\t\t\t\tEventually(destroyed).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"returns when the context is canceled\", func() {\n\t\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\t_, err := serv.Accept(ctx)\n\t\t\t\t\tExpect(err).To(MatchError(\"context canceled\"))\n\t\t\t\t\tclose(done)\n\t\t\t\t}()\n\n\t\t\t\tConsistently(done).ShouldNot(BeClosed())\n\t\t\t\tcancel()\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"uses the config returned by GetConfigClient\", func() {\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\n\t\t\t\tconf := &Config{MaxIncomingStreams: 1234}\n\t\t\t\tserv.config = populateConfig(&Config{GetConfigForClient: func(*ClientHelloInfo) (*Config, error) { return conf, nil }})\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\ts, err := serv.Accept(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(s).To(Equal(conn))\n\t\t\t\t\tclose(done)\n\t\t\t\t}()\n\n\t\t\t\thandshakeChan := make(chan struct{})\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\t_ connRunner,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t\tconf *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tExpect(conf.MaxIncomingStreams).To(BeEquivalentTo(1234))\n\t\t\t\t\tconn.EXPECT().handlePacket(gomock.Any())\n\t\t\t\t\tconn.EXPECT().HandshakeComplete().Return(handshakeChan)\n\t\t\t\t\tconn.EXPECT().run()\n\t\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true)\n\t\t\t\tserv.handleInitialImpl(\n\t\t\t\t\treceivedPacket{buffer: getPacketBuffer()},\n\t\t\t\t\t&wire.Header{DestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})},\n\t\t\t\t)\n\t\t\t\tConsistently(done).ShouldNot(BeClosed())\n\t\t\t\tclose(handshakeChan) // complete the handshake\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"rejects a connection attempt when GetConfigClient returns an error\", func() {\n\t\t\t\tserv.config = populateConfig(&Config{GetConfigForClient: func(*ClientHelloInfo) (*Config, error) { return nil, errors.New(\"rejected\") }})\n\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\ttracer.EXPECT().SentPacket(gomock.Any(), gomock.Any(), gomock.Any(), gomock.Any())\n\t\t\t\tconn.EXPECT().WriteTo(gomock.Any(), gomock.Any()).DoAndReturn(func(b []byte, _ net.Addr) (int, error) {\n\t\t\t\t\tdefer close(done)\n\t\t\t\t\trejectHdr := parseHeader(b)\n\t\t\t\t\tExpect(rejectHdr.Type).To(Equal(protocol.PacketTypeInitial))\n\t\t\t\t\treturn len(b), nil\n\t\t\t\t})\n\t\t\t\tserv.handleInitialImpl(\n\t\t\t\t\treceivedPacket{buffer: getPacketBuffer()},\n\t\t\t\t\t&wire.Header{DestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8}), Version: protocol.Version1},\n\t\t\t\t)\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\n\t\t\tIt(\"accepts new connections when the handshake completes\", func() {\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\n\t\t\t\tdone := make(chan struct{})\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\ts, err := serv.Accept(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(s).To(Equal(conn))\n\t\t\t\t\tclose(done)\n\t\t\t\t}()\n\n\t\t\t\thandshakeChan := make(chan struct{})\n\t\t\t\tserv.newConn = func(\n\t\t\t\t\t_ context.Context,\n\t\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t\t_ sendConn,\n\t\t\t\t\trunner connRunner,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t\t_ *Config,\n\t\t\t\t\t_ *tls.Config,\n\t\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t\t_ bool,\n\t\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t\t_ utils.Logger,\n\t\t\t\t\t_ protocol.Version,\n\t\t\t\t) quicConn {\n\t\t\t\t\tconn.EXPECT().handlePacket(gomock.Any())\n\t\t\t\t\tconn.EXPECT().HandshakeComplete().Return(handshakeChan)\n\t\t\t\t\tconn.EXPECT().run()\n\t\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\t\treturn conn\n\t\t\t\t}\n\t\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true)\n\t\t\t\tserv.handleInitialImpl(\n\t\t\t\t\treceivedPacket{buffer: getPacketBuffer()},\n\t\t\t\t\t&wire.Header{DestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})},\n\t\t\t\t)\n\t\t\t\tConsistently(done).ShouldNot(BeClosed())\n\t\t\t\tclose(handshakeChan) // complete the handshake\n\t\t\t\tEventually(done).Should(BeClosed())\n\t\t\t})\n\t\t})\n\t})\n\n\tContext(\"server accepting connections that haven't completed the handshake\", func() {\n\t\tvar (\n\t\t\tserv *EarlyListener\n\t\t\tphm  *MockPacketHandlerManager\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\tvar err error\n\t\t\tserv, err = ListenEarly(conn, tlsConf, nil)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tphm = NewMockPacketHandlerManager(mockCtrl)\n\t\t\tserv.baseServer.connHandler = phm\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tserv.Close()\n\t\t})\n\n\t\tIt(\"accepts new connections when they become ready\", func() {\n\t\t\tconn := NewMockQUICConn(mockCtrl)\n\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\ts, err := serv.Accept(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(s).To(Equal(conn))\n\t\t\t\tclose(done)\n\t\t\t}()\n\n\t\t\tready := make(chan struct{})\n\t\t\tserv.baseServer.newConn = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t_ sendConn,\n\t\t\t\trunner connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t_ *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\t_ protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tconn.EXPECT().handlePacket(gomock.Any())\n\t\t\t\tconn.EXPECT().run()\n\t\t\t\tconn.EXPECT().earlyConnReady().Return(ready)\n\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\treturn conn\n\t\t\t}\n\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true)\n\t\t\tserv.baseServer.handleInitialImpl(\n\t\t\t\treceivedPacket{buffer: getPacketBuffer()},\n\t\t\t\t&wire.Header{DestConnectionID: protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})},\n\t\t\t)\n\t\t\tConsistently(done).ShouldNot(BeClosed())\n\t\t\tclose(ready)\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"rejects new connection attempts if the accept queue is full\", func() {\n\t\t\tconnChan := make(chan *MockQUICConn, 1)\n\t\t\tvar wg sync.WaitGroup // to make sure the test fully completes\n\t\t\twg.Add(protocol.MaxAcceptQueueSize)\n\t\t\tserv.baseServer.newConn = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t_ sendConn,\n\t\t\t\trunner connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t_ *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\t_ protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tready := make(chan struct{})\n\t\t\t\tclose(ready)\n\t\t\t\tconn := <-connChan\n\t\t\t\tconn.EXPECT().handlePacket(gomock.Any())\n\t\t\t\tconn.EXPECT().run().Do(func() error { wg.Done(); return nil })\n\t\t\t\tconn.EXPECT().earlyConnReady().Return(ready)\n\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\treturn conn\n\t\t\t}\n\n\t\t\tphm.EXPECT().Get(gomock.Any()).AnyTimes()\n\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any()).Times(protocol.MaxAcceptQueueSize)\n\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true).Times(protocol.MaxAcceptQueueSize)\n\t\t\tfor i := 0; i < protocol.MaxAcceptQueueSize; i++ {\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tconnChan <- conn\n\t\t\t\tserv.baseServer.handlePacket(getInitialWithRandomDestConnID())\n\t\t\t}\n\n\t\t\tEventually(serv.baseServer.connQueue).Should(HaveLen(protocol.MaxAcceptQueueSize))\n\t\t\twg.Wait()\n\t\t\twg.Add(1)\n\n\t\t\trejected := make(chan struct{})\n\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true)\n\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\tconn.EXPECT().closeWithTransportError(ConnectionRefused).Do(func(qerr.TransportErrorCode) {\n\t\t\t\tclose(rejected)\n\t\t\t})\n\t\t\tconnChan <- conn\n\t\t\tserv.baseServer.handlePacket(getInitialWithRandomDestConnID())\n\t\t\tEventually(rejected).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't accept new connections if they were closed in the mean time\", func() {\n\t\t\tp := getInitial(protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tconnCreated := make(chan struct{})\n\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\tserv.baseServer.newConn = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t_ sendConn,\n\t\t\t\trunner connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t_ *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\t_ protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tconn.EXPECT().handlePacket(p)\n\t\t\t\tconn.EXPECT().run()\n\t\t\t\tconn.EXPECT().earlyConnReady()\n\t\t\t\tconn.EXPECT().Context().Return(ctx)\n\t\t\t\tclose(connCreated)\n\t\t\t\treturn conn\n\t\t\t}\n\n\t\t\tphm.EXPECT().Get(gomock.Any())\n\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true)\n\t\t\tserv.baseServer.handlePacket(p)\n\t\t\t// make sure there are no Write calls on the packet conn\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t\tEventually(connCreated).Should(BeClosed())\n\t\t\tcancel()\n\t\t\ttime.Sleep(scaleDuration(200 * time.Millisecond))\n\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tserv.Accept(context.Background())\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\tConsistently(done).ShouldNot(BeClosed())\n\n\t\t\t// make the go routine return\n\t\t\tExpect(serv.Close()).To(Succeed())\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\t})\n\n\tContext(\"0-RTT\", func() {\n\t\tvar (\n\t\t\ttr     *Transport\n\t\t\tserv   *baseServer\n\t\t\tphm    *MockPacketHandlerManager\n\t\t\ttracer *mocklogging.MockTracer\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\tvar t *logging.Tracer\n\t\t\tt, tracer = mocklogging.NewMockTracer(mockCtrl)\n\t\t\ttr = &Transport{Conn: conn, Tracer: t}\n\t\t\tln, err := tr.ListenEarly(tlsConf, nil)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tphm = NewMockPacketHandlerManager(mockCtrl)\n\t\t\tserv = ln.baseServer\n\t\t\tserv.connHandler = phm\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\ttracer.EXPECT().Close()\n\t\t\tExpect(tr.Close()).To(Succeed())\n\t\t})\n\n\t\tIt(\"passes packets to existing connections\", func() {\n\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\t\t\tp := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, 100))\n\t\t\tconn := NewMockPacketHandler(mockCtrl)\n\t\t\tphm.EXPECT().Get(connID).Return(conn, true)\n\t\t\thandled := make(chan struct{})\n\t\t\tconn.EXPECT().handlePacket(p).Do(func(receivedPacket) { close(handled) })\n\t\t\tserv.handlePacket(p)\n\t\t\tEventually(handled).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"queues 0-RTT packets, up to Max0RTTQueueSize\", func() {\n\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\n\t\t\tvar zeroRTTPackets []receivedPacket\n\n\t\t\tfor i := 0; i < protocol.Max0RTTQueueLen; i++ {\n\t\t\t\tp := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t\t}, make([]byte, 100+i))\n\t\t\t\tphm.EXPECT().Get(connID)\n\t\t\t\tserv.handlePacket(p)\n\t\t\t\tzeroRTTPackets = append(zeroRTTPackets, p)\n\t\t\t}\n\n\t\t\t// send one more packet, this one should be dropped\n\t\t\tp := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, 200))\n\t\t\tphm.EXPECT().Get(connID)\n\t\t\ttracer.EXPECT().DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropDOSPrevention)\n\t\t\tserv.handlePacket(p)\n\n\t\t\tinitial := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketTypeInitial,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, protocol.MinInitialPacketSize))\n\t\t\tcalled := make(chan struct{})\n\t\t\tserv.newConn = func(\n\t\t\t\t_ context.Context,\n\t\t\t\t_ context.CancelCauseFunc,\n\t\t\t\t_ sendConn,\n\t\t\t\t_ connRunner,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ *protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ protocol.ConnectionID,\n\t\t\t\t_ ConnectionIDGenerator,\n\t\t\t\t_ protocol.StatelessResetToken,\n\t\t\t\t_ *Config,\n\t\t\t\t_ *tls.Config,\n\t\t\t\t_ *handshake.TokenGenerator,\n\t\t\t\t_ bool,\n\t\t\t\t_ *logging.ConnectionTracer,\n\t\t\t\t_ utils.Logger,\n\t\t\t\t_ protocol.Version,\n\t\t\t) quicConn {\n\t\t\t\tconn := NewMockQUICConn(mockCtrl)\n\t\t\t\tvar calls []any\n\t\t\t\tcalls = append(calls, conn.EXPECT().handlePacket(initial))\n\t\t\t\tfor _, p := range zeroRTTPackets {\n\t\t\t\t\tcalls = append(calls, conn.EXPECT().handlePacket(p))\n\t\t\t\t}\n\t\t\t\tgomock.InOrder(calls...)\n\t\t\t\tconn.EXPECT().run()\n\t\t\t\tconn.EXPECT().earlyConnReady()\n\t\t\t\tconn.EXPECT().Context().Return(context.Background())\n\t\t\t\tclose(called)\n\t\t\t\t// shutdown\n\t\t\t\tconn.EXPECT().closeWithTransportError(gomock.Any())\n\t\t\t\treturn conn\n\t\t\t}\n\n\t\t\tphm.EXPECT().Get(connID)\n\t\t\tphm.EXPECT().GetStatelessResetToken(gomock.Any())\n\t\t\tphm.EXPECT().AddWithConnID(gomock.Any(), gomock.Any(), gomock.Any()).Return(true)\n\t\t\tserv.handlePacket(initial)\n\t\t\tEventually(called).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"limits the number of queues\", func() {\n\t\t\tfor i := 0; i < protocol.Max0RTTQueues; i++ {\n\t\t\t\tb := make([]byte, 16)\n\t\t\t\trand.Read(b)\n\t\t\t\tconnID := protocol.ParseConnectionID(b)\n\t\t\t\tp := getPacket(&wire.Header{\n\t\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\t\tDestConnectionID: connID,\n\t\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t\t}, make([]byte, 100+i))\n\t\t\t\tphm.EXPECT().Get(connID)\n\t\t\t\tserv.handlePacket(p)\n\t\t\t}\n\n\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\t\t\tp := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, 200))\n\t\t\tphm.EXPECT().Get(connID)\n\t\t\tdropped := make(chan struct{})\n\t\t\ttracer.EXPECT().DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropDOSPrevention).Do(func(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\t\tclose(dropped)\n\t\t\t})\n\t\t\tserv.handlePacket(p)\n\t\t\tEventually(dropped).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"drops queues after a while\", func() {\n\t\t\tnow := time.Now()\n\n\t\t\tconnID := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\t\t\tp := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tDestConnectionID: connID,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, 200))\n\t\t\tp.rcvTime = now\n\n\t\t\tconnID2 := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 9})\n\t\t\tp2Time := now.Add(protocol.Max0RTTQueueingDuration / 2)\n\t\t\tp2 := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tDestConnectionID: connID2,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, 300))\n\t\t\tp2.rcvTime = p2Time // doesn't trigger the cleanup of the first packet\n\n\t\t\tdropped1 := make(chan struct{})\n\t\t\tdropped2 := make(chan struct{})\n\t\t\t// need to register the call before handling the packet to avoid race condition\n\t\t\tgomock.InOrder(\n\t\t\t\ttracer.EXPECT().DroppedPacket(p.remoteAddr, logging.PacketType0RTT, p.Size(), logging.PacketDropDOSPrevention).Do(func(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\t\t\tclose(dropped1)\n\t\t\t\t}),\n\t\t\t\ttracer.EXPECT().DroppedPacket(p2.remoteAddr, logging.PacketType0RTT, p2.Size(), logging.PacketDropDOSPrevention).Do(func(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\t\t\tclose(dropped2)\n\t\t\t\t}),\n\t\t\t)\n\n\t\t\tphm.EXPECT().Get(connID)\n\t\t\tserv.handlePacket(p)\n\n\t\t\t// There's no cleanup Go routine.\n\t\t\t// Cleanup is triggered when new packets are received.\n\n\t\t\tphm.EXPECT().Get(connID2)\n\t\t\tserv.handlePacket(p2)\n\t\t\t// make sure no cleanup is executed\n\t\t\tConsistently(dropped1, 50*time.Millisecond).ShouldNot(BeClosed())\n\n\t\t\t// There's no cleanup Go routine.\n\t\t\t// Cleanup is triggered when new packets are received.\n\t\t\tconnID3 := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 0})\n\t\t\tp3 := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tDestConnectionID: connID3,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, 200))\n\t\t\tp3.rcvTime = now.Add(protocol.Max0RTTQueueingDuration + time.Nanosecond) // now triggers the cleanup\n\t\t\tphm.EXPECT().Get(connID3)\n\t\t\tserv.handlePacket(p3)\n\t\t\tEventually(dropped1).Should(BeClosed())\n\t\t\tConsistently(dropped2, 50*time.Millisecond).ShouldNot(BeClosed())\n\n\t\t\t// make sure the second packet is also cleaned up\n\t\t\tconnID4 := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 1})\n\t\t\tp4 := getPacket(&wire.Header{\n\t\t\t\tType:             protocol.PacketType0RTT,\n\t\t\t\tDestConnectionID: connID4,\n\t\t\t\tVersion:          serv.config.Versions[0],\n\t\t\t}, make([]byte, 200))\n\t\t\tp4.rcvTime = p2Time.Add(protocol.Max0RTTQueueingDuration + time.Nanosecond) // now triggers the cleanup\n\t\t\tphm.EXPECT().Get(connID4)\n\t\t\tserv.handlePacket(p4)\n\t\t\tEventually(dropped2).Should(BeClosed())\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "stream.go",
          "type": "blob",
          "size": 5.0966796875,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/ackhandler\"\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype deadlineError struct{}\n\nfunc (deadlineError) Error() string   { return \"deadline exceeded\" }\nfunc (deadlineError) Temporary() bool { return true }\nfunc (deadlineError) Timeout() bool   { return true }\nfunc (deadlineError) Unwrap() error   { return os.ErrDeadlineExceeded }\n\nvar errDeadline net.Error = &deadlineError{}\n\n// The streamSender is notified by the stream about various events.\ntype streamSender interface {\n\tonHasConnectionData()\n\tonHasStreamData(protocol.StreamID, sendStreamI)\n\tonHasStreamControlFrame(protocol.StreamID, streamControlFrameGetter)\n\t// must be called without holding the mutex that is acquired by closeForShutdown\n\tonStreamCompleted(protocol.StreamID)\n}\n\n// Each of the both stream halves gets its own uniStreamSender.\n// This is necessary in order to keep track when both halves have been completed.\ntype uniStreamSender struct {\n\tstreamSender\n\tonStreamCompletedImpl       func()\n\tonHasStreamControlFrameImpl func(protocol.StreamID, streamControlFrameGetter)\n}\n\nfunc (s *uniStreamSender) onHasStreamData(id protocol.StreamID, str sendStreamI) {\n\ts.streamSender.onHasStreamData(id, str)\n}\nfunc (s *uniStreamSender) onStreamCompleted(protocol.StreamID) { s.onStreamCompletedImpl() }\nfunc (s *uniStreamSender) onHasStreamControlFrame(id protocol.StreamID, str streamControlFrameGetter) {\n\ts.onHasStreamControlFrameImpl(id, str)\n}\n\nvar _ streamSender = &uniStreamSender{}\n\ntype streamI interface {\n\tStream\n\tcloseForShutdown(error)\n\t// for receiving\n\thandleStreamFrame(*wire.StreamFrame, time.Time) error\n\thandleResetStreamFrame(*wire.ResetStreamFrame, time.Time) error\n\t// for sending\n\thasData() bool\n\thandleStopSendingFrame(*wire.StopSendingFrame)\n\tpopStreamFrame(protocol.ByteCount, protocol.Version) (_ ackhandler.StreamFrame, _ *wire.StreamDataBlockedFrame, hasMore bool)\n\tupdateSendWindow(protocol.ByteCount)\n}\n\nvar (\n\t_ receiveStreamI = (streamI)(nil)\n\t_ sendStreamI    = (streamI)(nil)\n)\n\n// A Stream assembles the data from StreamFrames and provides a super-convenient Read-Interface\n//\n// Read() and Write() may be called concurrently, but multiple calls to Read() or Write() individually must be synchronized manually.\ntype stream struct {\n\treceiveStream\n\tsendStream\n\n\tcompletedMutex         sync.Mutex\n\tsender                 streamSender\n\treceiveStreamCompleted bool\n\tsendStreamCompleted    bool\n}\n\nvar (\n\t_ Stream                   = &stream{}\n\t_ streamControlFrameGetter = &receiveStream{}\n)\n\n// newStream creates a new Stream\nfunc newStream(\n\tctx context.Context,\n\tstreamID protocol.StreamID,\n\tsender streamSender,\n\tflowController flowcontrol.StreamFlowController,\n) *stream {\n\ts := &stream{sender: sender}\n\tsenderForSendStream := &uniStreamSender{\n\t\tstreamSender: sender,\n\t\tonStreamCompletedImpl: func() {\n\t\t\ts.completedMutex.Lock()\n\t\t\ts.sendStreamCompleted = true\n\t\t\ts.checkIfCompleted()\n\t\t\ts.completedMutex.Unlock()\n\t\t},\n\t\tonHasStreamControlFrameImpl: func(id protocol.StreamID, str streamControlFrameGetter) {\n\t\t\tsender.onHasStreamControlFrame(streamID, s)\n\t\t},\n\t}\n\ts.sendStream = *newSendStream(ctx, streamID, senderForSendStream, flowController)\n\tsenderForReceiveStream := &uniStreamSender{\n\t\tstreamSender: sender,\n\t\tonStreamCompletedImpl: func() {\n\t\t\ts.completedMutex.Lock()\n\t\t\ts.receiveStreamCompleted = true\n\t\t\ts.checkIfCompleted()\n\t\t\ts.completedMutex.Unlock()\n\t\t},\n\t\tonHasStreamControlFrameImpl: func(id protocol.StreamID, str streamControlFrameGetter) {\n\t\t\tsender.onHasStreamControlFrame(streamID, s)\n\t\t},\n\t}\n\ts.receiveStream = *newReceiveStream(streamID, senderForReceiveStream, flowController)\n\treturn s\n}\n\n// need to define StreamID() here, since both receiveStream and readStream have a StreamID()\nfunc (s *stream) StreamID() protocol.StreamID {\n\t// the result is same for receiveStream and sendStream\n\treturn s.sendStream.StreamID()\n}\n\nfunc (s *stream) Close() error {\n\treturn s.sendStream.Close()\n}\n\nfunc (s *stream) getControlFrame(now time.Time) (_ ackhandler.Frame, ok, hasMore bool) {\n\tf, ok, _ := s.sendStream.getControlFrame(now)\n\tif ok {\n\t\treturn f, true, true\n\t}\n\treturn s.receiveStream.getControlFrame(now)\n}\n\nfunc (s *stream) SetDeadline(t time.Time) error {\n\t_ = s.SetReadDeadline(t)  // SetReadDeadline never errors\n\t_ = s.SetWriteDeadline(t) // SetWriteDeadline never errors\n\treturn nil\n}\n\n// CloseForShutdown closes a stream abruptly.\n// It makes Read and Write unblock (and return the error) immediately.\n// The peer will NOT be informed about this: the stream is closed without sending a FIN or RST.\nfunc (s *stream) closeForShutdown(err error) {\n\ts.sendStream.closeForShutdown(err)\n\ts.receiveStream.closeForShutdown(err)\n}\n\n// checkIfCompleted is called from the uniStreamSender, when one of the stream halves is completed.\n// It makes sure that the onStreamCompleted callback is only called if both receive and send side have completed.\nfunc (s *stream) checkIfCompleted() {\n\tif s.sendStreamCompleted && s.receiveStreamCompleted {\n\t\ts.sender.onStreamCompleted(s.StreamID())\n\t}\n}\n"
        },
        {
          "name": "stream_test.go",
          "type": "blob",
          "size": 3.3759765625,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nfunc TestStreamDeadlines(t *testing.T) {\n\tconst streamID protocol.StreamID = 1337\n\tmockCtrl := gomock.NewController(t)\n\tmockSender := NewMockStreamSender(mockCtrl)\n\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\tstr := newStream(context.Background(), streamID, mockSender, mockFC)\n\n\t// SetDeadline sets both read and write deadlines\n\tstr.SetDeadline(time.Now().Add(-time.Second))\n\tn, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\trequire.ErrorIs(t, err, os.ErrDeadlineExceeded)\n\trequire.Zero(t, n)\n\n\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), false, gomock.Any()).AnyTimes()\n\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{Data: []byte(\"foobar\")}, time.Now()))\n\tn, err = (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(make([]byte, 6))\n\trequire.ErrorIs(t, err, os.ErrDeadlineExceeded)\n\trequire.Zero(t, n)\n}\n\nfunc TestStreamCompletion(t *testing.T) {\n\tcompleteReadSide := func(\n\t\tt *testing.T,\n\t\tstr *stream,\n\t\tmockCtrl *gomock.Controller,\n\t\tmockFC *mocks.MockStreamFlowController,\n\t) {\n\t\tt.Helper()\n\t\tmockFC.EXPECT().UpdateHighestReceived(protocol.ByteCount(6), true, gomock.Any())\n\t\tmockFC.EXPECT().AddBytesRead(protocol.ByteCount(6))\n\t\trequire.NoError(t, str.handleStreamFrame(&wire.StreamFrame{\n\t\t\tStreamID: str.StreamID(),\n\t\t\tData:     []byte(\"foobar\"),\n\t\t\tFin:      true,\n\t\t}, time.Now()))\n\t\t_, err := (&readerWithTimeout{Reader: str, Timeout: time.Second}).Read(make([]byte, 6))\n\t\trequire.ErrorIs(t, err, io.EOF)\n\t\trequire.True(t, mockCtrl.Satisfied())\n\t}\n\n\tcompleteWriteSide := func(\n\t\tt *testing.T,\n\t\tstr *stream,\n\t\tmockCtrl *gomock.Controller,\n\t\tmockFC *mocks.MockStreamFlowController,\n\t\tmockSender *MockStreamSender,\n\t) {\n\t\tt.Helper()\n\t\tmockSender.EXPECT().onHasStreamData(str.StreamID(), gomock.Any()).Times(2)\n\t\t_, err := (&writerWithTimeout{Writer: str, Timeout: time.Second}).Write([]byte(\"foobar\"))\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, str.Close())\n\t\tmockFC.EXPECT().SendWindowSize().Return(protocol.MaxByteCount)\n\t\tmockFC.EXPECT().AddBytesSent(protocol.ByteCount(6))\n\t\tf, _, _ := str.popStreamFrame(protocol.MaxByteCount, protocol.Version1)\n\t\trequire.NotNil(t, f.Frame)\n\t\trequire.True(t, f.Frame.Fin)\n\t\tf.Handler.OnAcked(f.Frame)\n\t\trequire.True(t, mockCtrl.Satisfied())\n\t}\n\n\tconst streamID protocol.StreamID = 1337\n\n\tt.Run(\"first read, then write\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tmockSender := NewMockStreamSender(mockCtrl)\n\t\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\t\tstr := newStream(context.Background(), streamID, mockSender, mockFC)\n\n\t\tcompleteReadSide(t, str, mockCtrl, mockFC)\n\t\tmockSender.EXPECT().onStreamCompleted(streamID)\n\t\tcompleteWriteSide(t, str, mockCtrl, mockFC, mockSender)\n\t})\n\n\tt.Run(\"first write, then read\", func(t *testing.T) {\n\t\tmockCtrl := gomock.NewController(t)\n\t\tmockSender := NewMockStreamSender(mockCtrl)\n\t\tmockFC := mocks.NewMockStreamFlowController(mockCtrl)\n\t\tstr := newStream(context.Background(), streamID, mockSender, mockFC)\n\n\t\tcompleteWriteSide(t, str, mockCtrl, mockFC, mockSender)\n\t\tmockSender.EXPECT().onStreamCompleted(streamID)\n\t\tcompleteReadSide(t, str, mockCtrl, mockFC)\n\t})\n}\n"
        },
        {
          "name": "streams_map.go",
          "type": "blob",
          "size": 10.109375,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype streamError struct {\n\tmessage string\n\tnums    []protocol.StreamNum\n}\n\nfunc (e streamError) Error() string {\n\treturn e.message\n}\n\nfunc convertStreamError(err error, stype protocol.StreamType, pers protocol.Perspective) error {\n\tstrError, ok := err.(streamError)\n\tif !ok {\n\t\treturn err\n\t}\n\tids := make([]interface{}, len(strError.nums))\n\tfor i, num := range strError.nums {\n\t\tids[i] = num.StreamID(stype, pers)\n\t}\n\treturn fmt.Errorf(strError.Error(), ids...)\n}\n\ntype streamOpenErr struct{ error }\n\nvar _ net.Error = &streamOpenErr{}\n\nfunc (streamOpenErr) Timeout() bool   { return false }\nfunc (e streamOpenErr) Unwrap() error { return e.error }\n\nfunc (e streamOpenErr) Temporary() bool {\n\t// In older versions of quic-go, the stream limit error was documented to be a net.Error.Temporary.\n\t// This function was since deprecated, but we keep the existing behavior.\n\treturn errors.Is(e, &StreamLimitReachedError{})\n}\n\n// StreamLimitReachedError is returned from Connection.OpenStream and Connection.OpenUniStream\n// when it is not possible to open a new stream because the number of opens streams reached\n// the peer's stream limit.\ntype StreamLimitReachedError struct{}\n\nfunc (e StreamLimitReachedError) Error() string { return \"too many open streams\" }\n\ntype streamsMap struct {\n\tctx         context.Context // not used for cancellations, but carries the values associated with the connection\n\tperspective protocol.Perspective\n\n\tmaxIncomingBidiStreams uint64\n\tmaxIncomingUniStreams  uint64\n\n\tsender            streamSender\n\tqueueControlFrame func(wire.Frame)\n\tnewFlowController func(protocol.StreamID) flowcontrol.StreamFlowController\n\n\tmutex               sync.Mutex\n\toutgoingBidiStreams *outgoingStreamsMap[streamI]\n\toutgoingUniStreams  *outgoingStreamsMap[sendStreamI]\n\tincomingBidiStreams *incomingStreamsMap[streamI]\n\tincomingUniStreams  *incomingStreamsMap[receiveStreamI]\n\treset               bool\n}\n\nvar _ streamManager = &streamsMap{}\n\nfunc newStreamsMap(\n\tctx context.Context,\n\tsender streamSender,\n\tqueueControlFrame func(wire.Frame),\n\tnewFlowController func(protocol.StreamID) flowcontrol.StreamFlowController,\n\tmaxIncomingBidiStreams uint64,\n\tmaxIncomingUniStreams uint64,\n\tperspective protocol.Perspective,\n) *streamsMap {\n\tm := &streamsMap{\n\t\tctx:                    ctx,\n\t\tperspective:            perspective,\n\t\tqueueControlFrame:      queueControlFrame,\n\t\tnewFlowController:      newFlowController,\n\t\tmaxIncomingBidiStreams: maxIncomingBidiStreams,\n\t\tmaxIncomingUniStreams:  maxIncomingUniStreams,\n\t\tsender:                 sender,\n\t}\n\tm.initMaps()\n\treturn m\n}\n\nfunc (m *streamsMap) initMaps() {\n\tm.outgoingBidiStreams = newOutgoingStreamsMap(\n\t\tprotocol.StreamTypeBidi,\n\t\tfunc(num protocol.StreamNum) streamI {\n\t\t\tid := num.StreamID(protocol.StreamTypeBidi, m.perspective)\n\t\t\treturn newStream(m.ctx, id, m.sender, m.newFlowController(id))\n\t\t},\n\t\tm.queueControlFrame,\n\t)\n\tm.incomingBidiStreams = newIncomingStreamsMap(\n\t\tprotocol.StreamTypeBidi,\n\t\tfunc(num protocol.StreamNum) streamI {\n\t\t\tid := num.StreamID(protocol.StreamTypeBidi, m.perspective.Opposite())\n\t\t\treturn newStream(m.ctx, id, m.sender, m.newFlowController(id))\n\t\t},\n\t\tm.maxIncomingBidiStreams,\n\t\tm.queueControlFrame,\n\t)\n\tm.outgoingUniStreams = newOutgoingStreamsMap(\n\t\tprotocol.StreamTypeUni,\n\t\tfunc(num protocol.StreamNum) sendStreamI {\n\t\t\tid := num.StreamID(protocol.StreamTypeUni, m.perspective)\n\t\t\treturn newSendStream(m.ctx, id, m.sender, m.newFlowController(id))\n\t\t},\n\t\tm.queueControlFrame,\n\t)\n\tm.incomingUniStreams = newIncomingStreamsMap(\n\t\tprotocol.StreamTypeUni,\n\t\tfunc(num protocol.StreamNum) receiveStreamI {\n\t\t\tid := num.StreamID(protocol.StreamTypeUni, m.perspective.Opposite())\n\t\t\treturn newReceiveStream(id, m.sender, m.newFlowController(id))\n\t\t},\n\t\tm.maxIncomingUniStreams,\n\t\tm.queueControlFrame,\n\t)\n}\n\nfunc (m *streamsMap) OpenStream() (Stream, error) {\n\tm.mutex.Lock()\n\treset := m.reset\n\tmm := m.outgoingBidiStreams\n\tm.mutex.Unlock()\n\tif reset {\n\t\treturn nil, Err0RTTRejected\n\t}\n\tstr, err := mm.OpenStream()\n\treturn str, convertStreamError(err, protocol.StreamTypeBidi, m.perspective)\n}\n\nfunc (m *streamsMap) OpenStreamSync(ctx context.Context) (Stream, error) {\n\tm.mutex.Lock()\n\treset := m.reset\n\tmm := m.outgoingBidiStreams\n\tm.mutex.Unlock()\n\tif reset {\n\t\treturn nil, Err0RTTRejected\n\t}\n\tstr, err := mm.OpenStreamSync(ctx)\n\treturn str, convertStreamError(err, protocol.StreamTypeBidi, m.perspective)\n}\n\nfunc (m *streamsMap) OpenUniStream() (SendStream, error) {\n\tm.mutex.Lock()\n\treset := m.reset\n\tmm := m.outgoingUniStreams\n\tm.mutex.Unlock()\n\tif reset {\n\t\treturn nil, Err0RTTRejected\n\t}\n\tstr, err := mm.OpenStream()\n\treturn str, convertStreamError(err, protocol.StreamTypeBidi, m.perspective)\n}\n\nfunc (m *streamsMap) OpenUniStreamSync(ctx context.Context) (SendStream, error) {\n\tm.mutex.Lock()\n\treset := m.reset\n\tmm := m.outgoingUniStreams\n\tm.mutex.Unlock()\n\tif reset {\n\t\treturn nil, Err0RTTRejected\n\t}\n\tstr, err := mm.OpenStreamSync(ctx)\n\treturn str, convertStreamError(err, protocol.StreamTypeUni, m.perspective)\n}\n\nfunc (m *streamsMap) AcceptStream(ctx context.Context) (Stream, error) {\n\tm.mutex.Lock()\n\treset := m.reset\n\tmm := m.incomingBidiStreams\n\tm.mutex.Unlock()\n\tif reset {\n\t\treturn nil, Err0RTTRejected\n\t}\n\tstr, err := mm.AcceptStream(ctx)\n\treturn str, convertStreamError(err, protocol.StreamTypeBidi, m.perspective.Opposite())\n}\n\nfunc (m *streamsMap) AcceptUniStream(ctx context.Context) (ReceiveStream, error) {\n\tm.mutex.Lock()\n\treset := m.reset\n\tmm := m.incomingUniStreams\n\tm.mutex.Unlock()\n\tif reset {\n\t\treturn nil, Err0RTTRejected\n\t}\n\tstr, err := mm.AcceptStream(ctx)\n\treturn str, convertStreamError(err, protocol.StreamTypeUni, m.perspective.Opposite())\n}\n\nfunc (m *streamsMap) DeleteStream(id protocol.StreamID) error {\n\tnum := id.StreamNum()\n\tswitch id.Type() {\n\tcase protocol.StreamTypeUni:\n\t\tif id.InitiatedBy() == m.perspective {\n\t\t\treturn convertStreamError(m.outgoingUniStreams.DeleteStream(num), protocol.StreamTypeUni, m.perspective)\n\t\t}\n\t\treturn convertStreamError(m.incomingUniStreams.DeleteStream(num), protocol.StreamTypeUni, m.perspective.Opposite())\n\tcase protocol.StreamTypeBidi:\n\t\tif id.InitiatedBy() == m.perspective {\n\t\t\treturn convertStreamError(m.outgoingBidiStreams.DeleteStream(num), protocol.StreamTypeBidi, m.perspective)\n\t\t}\n\t\treturn convertStreamError(m.incomingBidiStreams.DeleteStream(num), protocol.StreamTypeBidi, m.perspective.Opposite())\n\t}\n\tpanic(\"\")\n}\n\nfunc (m *streamsMap) GetOrOpenReceiveStream(id protocol.StreamID) (receiveStreamI, error) {\n\tstr, err := m.getOrOpenReceiveStream(id)\n\tif err != nil {\n\t\treturn nil, &qerr.TransportError{\n\t\t\tErrorCode:    qerr.StreamStateError,\n\t\t\tErrorMessage: err.Error(),\n\t\t}\n\t}\n\treturn str, nil\n}\n\nfunc (m *streamsMap) getOrOpenReceiveStream(id protocol.StreamID) (receiveStreamI, error) {\n\tnum := id.StreamNum()\n\tswitch id.Type() {\n\tcase protocol.StreamTypeUni:\n\t\tif id.InitiatedBy() == m.perspective {\n\t\t\t// an outgoing unidirectional stream is a send stream, not a receive stream\n\t\t\treturn nil, fmt.Errorf(\"peer attempted to open receive stream %d\", id)\n\t\t}\n\t\tstr, err := m.incomingUniStreams.GetOrOpenStream(num)\n\t\treturn str, convertStreamError(err, protocol.StreamTypeUni, m.perspective)\n\tcase protocol.StreamTypeBidi:\n\t\tvar str receiveStreamI\n\t\tvar err error\n\t\tif id.InitiatedBy() == m.perspective {\n\t\t\tstr, err = m.outgoingBidiStreams.GetStream(num)\n\t\t} else {\n\t\t\tstr, err = m.incomingBidiStreams.GetOrOpenStream(num)\n\t\t}\n\t\treturn str, convertStreamError(err, protocol.StreamTypeBidi, id.InitiatedBy())\n\t}\n\tpanic(\"\")\n}\n\nfunc (m *streamsMap) GetOrOpenSendStream(id protocol.StreamID) (sendStreamI, error) {\n\tstr, err := m.getOrOpenSendStream(id)\n\tif err != nil {\n\t\treturn nil, &qerr.TransportError{\n\t\t\tErrorCode:    qerr.StreamStateError,\n\t\t\tErrorMessage: err.Error(),\n\t\t}\n\t}\n\treturn str, nil\n}\n\nfunc (m *streamsMap) getOrOpenSendStream(id protocol.StreamID) (sendStreamI, error) {\n\tnum := id.StreamNum()\n\tswitch id.Type() {\n\tcase protocol.StreamTypeUni:\n\t\tif id.InitiatedBy() == m.perspective {\n\t\t\tstr, err := m.outgoingUniStreams.GetStream(num)\n\t\t\treturn str, convertStreamError(err, protocol.StreamTypeUni, m.perspective)\n\t\t}\n\t\t// an incoming unidirectional stream is a receive stream, not a send stream\n\t\treturn nil, fmt.Errorf(\"peer attempted to open send stream %d\", id)\n\tcase protocol.StreamTypeBidi:\n\t\tvar str sendStreamI\n\t\tvar err error\n\t\tif id.InitiatedBy() == m.perspective {\n\t\t\tstr, err = m.outgoingBidiStreams.GetStream(num)\n\t\t} else {\n\t\t\tstr, err = m.incomingBidiStreams.GetOrOpenStream(num)\n\t\t}\n\t\treturn str, convertStreamError(err, protocol.StreamTypeBidi, id.InitiatedBy())\n\t}\n\tpanic(\"\")\n}\n\nfunc (m *streamsMap) HandleMaxStreamsFrame(f *wire.MaxStreamsFrame) {\n\tswitch f.Type {\n\tcase protocol.StreamTypeUni:\n\t\tm.outgoingUniStreams.SetMaxStream(f.MaxStreamNum)\n\tcase protocol.StreamTypeBidi:\n\t\tm.outgoingBidiStreams.SetMaxStream(f.MaxStreamNum)\n\t}\n}\n\nfunc (m *streamsMap) UpdateLimits(p *wire.TransportParameters) {\n\tm.outgoingBidiStreams.UpdateSendWindow(p.InitialMaxStreamDataBidiRemote)\n\tm.outgoingBidiStreams.SetMaxStream(p.MaxBidiStreamNum)\n\tm.outgoingUniStreams.UpdateSendWindow(p.InitialMaxStreamDataUni)\n\tm.outgoingUniStreams.SetMaxStream(p.MaxUniStreamNum)\n}\n\nfunc (m *streamsMap) CloseWithError(err error) {\n\tm.outgoingBidiStreams.CloseWithError(err)\n\tm.outgoingUniStreams.CloseWithError(err)\n\tm.incomingBidiStreams.CloseWithError(err)\n\tm.incomingUniStreams.CloseWithError(err)\n}\n\n// ResetFor0RTT resets is used when 0-RTT is rejected. In that case, the streams maps are\n// 1. closed with an Err0RTTRejected, making calls to Open{Uni}Stream{Sync} / Accept{Uni}Stream return that error.\n// 2. reset to their initial state, such that we can immediately process new incoming stream data.\n// Afterwards, calls to Open{Uni}Stream{Sync} / Accept{Uni}Stream will continue to return the error,\n// until UseResetMaps() has been called.\nfunc (m *streamsMap) ResetFor0RTT() {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\tm.reset = true\n\tm.CloseWithError(Err0RTTRejected)\n\tm.initMaps()\n}\n\nfunc (m *streamsMap) UseResetMaps() {\n\tm.mutex.Lock()\n\tm.reset = false\n\tm.mutex.Unlock()\n}\n"
        },
        {
          "name": "streams_map_incoming.go",
          "type": "blob",
          "size": 5.4453125,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype incomingStream interface {\n\tcloseForShutdown(error)\n}\n\n// When a stream is deleted before it was accepted, we can't delete it from the map immediately.\n// We need to wait until the application accepts it, and delete it then.\ntype incomingStreamEntry[T incomingStream] struct {\n\tstream       T\n\tshouldDelete bool\n}\n\ntype incomingStreamsMap[T incomingStream] struct {\n\tmutex         sync.RWMutex\n\tnewStreamChan chan struct{}\n\n\tstreamType protocol.StreamType\n\tstreams    map[protocol.StreamNum]incomingStreamEntry[T]\n\n\tnextStreamToAccept protocol.StreamNum // the next stream that will be returned by AcceptStream()\n\tnextStreamToOpen   protocol.StreamNum // the highest stream that the peer opened\n\tmaxStream          protocol.StreamNum // the highest stream that the peer is allowed to open\n\tmaxNumStreams      uint64             // maximum number of streams\n\n\tnewStream        func(protocol.StreamNum) T\n\tqueueMaxStreamID func(*wire.MaxStreamsFrame)\n\n\tcloseErr error\n}\n\nfunc newIncomingStreamsMap[T incomingStream](\n\tstreamType protocol.StreamType,\n\tnewStream func(protocol.StreamNum) T,\n\tmaxStreams uint64,\n\tqueueControlFrame func(wire.Frame),\n) *incomingStreamsMap[T] {\n\treturn &incomingStreamsMap[T]{\n\t\tnewStreamChan:      make(chan struct{}, 1),\n\t\tstreamType:         streamType,\n\t\tstreams:            make(map[protocol.StreamNum]incomingStreamEntry[T]),\n\t\tmaxStream:          protocol.StreamNum(maxStreams),\n\t\tmaxNumStreams:      maxStreams,\n\t\tnewStream:          newStream,\n\t\tnextStreamToOpen:   1,\n\t\tnextStreamToAccept: 1,\n\t\tqueueMaxStreamID:   func(f *wire.MaxStreamsFrame) { queueControlFrame(f) },\n\t}\n}\n\nfunc (m *incomingStreamsMap[T]) AcceptStream(ctx context.Context) (T, error) {\n\t// drain the newStreamChan, so we don't check the map twice if the stream doesn't exist\n\tselect {\n\tcase <-m.newStreamChan:\n\tdefault:\n\t}\n\n\tm.mutex.Lock()\n\n\tvar num protocol.StreamNum\n\tvar entry incomingStreamEntry[T]\n\tfor {\n\t\tnum = m.nextStreamToAccept\n\t\tif m.closeErr != nil {\n\t\t\tm.mutex.Unlock()\n\t\t\treturn *new(T), m.closeErr\n\t\t}\n\t\tvar ok bool\n\t\tentry, ok = m.streams[num]\n\t\tif ok {\n\t\t\tbreak\n\t\t}\n\t\tm.mutex.Unlock()\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn *new(T), ctx.Err()\n\t\tcase <-m.newStreamChan:\n\t\t}\n\t\tm.mutex.Lock()\n\t}\n\tm.nextStreamToAccept++\n\t// If this stream was completed before being accepted, we can delete it now.\n\tif entry.shouldDelete {\n\t\tif err := m.deleteStream(num); err != nil {\n\t\t\tm.mutex.Unlock()\n\t\t\treturn *new(T), err\n\t\t}\n\t}\n\tm.mutex.Unlock()\n\treturn entry.stream, nil\n}\n\nfunc (m *incomingStreamsMap[T]) GetOrOpenStream(num protocol.StreamNum) (T, error) {\n\tm.mutex.RLock()\n\tif num > m.maxStream {\n\t\tm.mutex.RUnlock()\n\t\treturn *new(T), streamError{\n\t\t\tmessage: \"peer tried to open stream %d (current limit: %d)\",\n\t\t\tnums:    []protocol.StreamNum{num, m.maxStream},\n\t\t}\n\t}\n\t// if the num is smaller than the highest we accepted\n\t// * this stream exists in the map, and we can return it, or\n\t// * this stream was already closed, then we can return the nil\n\tif num < m.nextStreamToOpen {\n\t\tvar s T\n\t\t// If the stream was already queued for deletion, and is just waiting to be accepted, don't return it.\n\t\tif entry, ok := m.streams[num]; ok && !entry.shouldDelete {\n\t\t\ts = entry.stream\n\t\t}\n\t\tm.mutex.RUnlock()\n\t\treturn s, nil\n\t}\n\tm.mutex.RUnlock()\n\n\tm.mutex.Lock()\n\t// no need to check the two error conditions from above again\n\t// * maxStream can only increase, so if the id was valid before, it definitely is valid now\n\t// * highestStream is only modified by this function\n\tfor newNum := m.nextStreamToOpen; newNum <= num; newNum++ {\n\t\tm.streams[newNum] = incomingStreamEntry[T]{stream: m.newStream(newNum)}\n\t\tselect {\n\t\tcase m.newStreamChan <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t}\n\tm.nextStreamToOpen = num + 1\n\tentry := m.streams[num]\n\tm.mutex.Unlock()\n\treturn entry.stream, nil\n}\n\nfunc (m *incomingStreamsMap[T]) DeleteStream(num protocol.StreamNum) error {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\treturn m.deleteStream(num)\n}\n\nfunc (m *incomingStreamsMap[T]) deleteStream(num protocol.StreamNum) error {\n\tif _, ok := m.streams[num]; !ok {\n\t\treturn streamError{\n\t\t\tmessage: \"tried to delete unknown incoming stream %d\",\n\t\t\tnums:    []protocol.StreamNum{num},\n\t\t}\n\t}\n\n\t// Don't delete this stream yet, if it was not yet accepted.\n\t// Just save it to streamsToDelete map, to make sure it is deleted as soon as it gets accepted.\n\tif num >= m.nextStreamToAccept {\n\t\tentry, ok := m.streams[num]\n\t\tif ok && entry.shouldDelete {\n\t\t\treturn streamError{\n\t\t\t\tmessage: \"tried to delete incoming stream %d multiple times\",\n\t\t\t\tnums:    []protocol.StreamNum{num},\n\t\t\t}\n\t\t}\n\t\tentry.shouldDelete = true\n\t\tm.streams[num] = entry // can't assign to struct in map, so we need to reassign\n\t\treturn nil\n\t}\n\n\tdelete(m.streams, num)\n\t// queue a MAX_STREAM_ID frame, giving the peer the option to open a new stream\n\tif m.maxNumStreams > uint64(len(m.streams)) {\n\t\tmaxStream := m.nextStreamToOpen + protocol.StreamNum(m.maxNumStreams-uint64(len(m.streams))) - 1\n\t\t// Never send a value larger than protocol.MaxStreamCount.\n\t\tif maxStream <= protocol.MaxStreamCount {\n\t\t\tm.maxStream = maxStream\n\t\t\tm.queueMaxStreamID(&wire.MaxStreamsFrame{\n\t\t\t\tType:         m.streamType,\n\t\t\t\tMaxStreamNum: m.maxStream,\n\t\t\t})\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (m *incomingStreamsMap[T]) CloseWithError(err error) {\n\tm.mutex.Lock()\n\tm.closeErr = err\n\tfor _, entry := range m.streams {\n\t\tentry.stream.closeForShutdown(err)\n\t}\n\tm.mutex.Unlock()\n\tclose(m.newStreamChan)\n}\n"
        },
        {
          "name": "streams_map_incoming_test.go",
          "type": "blob",
          "size": 9.7333984375,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\ntype mockGenericStream struct {\n\tnum protocol.StreamNum\n\n\tclosed     bool\n\tcloseErr   error\n\tsendWindow protocol.ByteCount\n}\n\nfunc (s *mockGenericStream) closeForShutdown(err error) {\n\ts.closed = true\n\ts.closeErr = err\n}\n\nfunc (s *mockGenericStream) updateSendWindow(limit protocol.ByteCount) {\n\ts.sendWindow = limit\n}\n\nvar _ = Describe(\"Streams Map (incoming)\", func() {\n\tvar (\n\t\tm                   *incomingStreamsMap[*mockGenericStream]\n\t\tnewItemCounter      int\n\t\tmaxNumStreams       uint64\n\t\tqueuedControlFrames []wire.Frame\n\t)\n\tstreamType := []protocol.StreamType{protocol.StreamTypeUni, protocol.StreamTypeUni}[rand.Intn(2)]\n\n\t// check that the frame can be serialized and deserialized\n\tcheckFrameSerialization := func(f wire.Frame) {\n\t\tb, err := f.Append(nil, protocol.Version1)\n\t\tExpectWithOffset(1, err).ToNot(HaveOccurred())\n\t\t_, frame, err := wire.NewFrameParser(false).ParseNext(b, protocol.Encryption1RTT, protocol.Version1)\n\t\tExpectWithOffset(1, err).ToNot(HaveOccurred())\n\t\tExpect(f).To(Equal(frame))\n\t}\n\n\tBeforeEach(func() { maxNumStreams = 5 })\n\n\tJustBeforeEach(func() {\n\t\tqueuedControlFrames = []wire.Frame{}\n\t\tnewItemCounter = 0\n\t\tm = newIncomingStreamsMap(\n\t\t\tstreamType,\n\t\t\tfunc(num protocol.StreamNum) *mockGenericStream {\n\t\t\t\tnewItemCounter++\n\t\t\t\treturn &mockGenericStream{num: num}\n\t\t\t},\n\t\t\tmaxNumStreams,\n\t\t\tfunc(f wire.Frame) { queuedControlFrames = append(queuedControlFrames, f) },\n\t\t)\n\t})\n\n\tIt(\"opens all streams up to the id on GetOrOpenStream\", func() {\n\t\t_, err := m.GetOrOpenStream(4)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(newItemCounter).To(Equal(4))\n\t})\n\n\tIt(\"starts opening streams at the right position\", func() {\n\t\t// like the test above, but with 2 calls to GetOrOpenStream\n\t\t_, err := m.GetOrOpenStream(2)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(newItemCounter).To(Equal(2))\n\t\t_, err = m.GetOrOpenStream(5)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(newItemCounter).To(Equal(5))\n\t})\n\n\tIt(\"accepts streams in the right order\", func() {\n\t\t_, err := m.GetOrOpenStream(2) // open streams 1 and 2\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tstr, err := m.AcceptStream(context.Background())\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\tstr, err = m.AcceptStream(context.Background())\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str.num).To(Equal(protocol.StreamNum(2)))\n\t})\n\n\tIt(\"allows opening the maximum stream ID\", func() {\n\t\tstr, err := m.GetOrOpenStream(1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t})\n\n\tIt(\"errors when trying to get a stream ID higher than the maximum\", func() {\n\t\t_, err := m.GetOrOpenStream(6)\n\t\tExpect(err).To(HaveOccurred())\n\t\tExpect(err.(streamError).TestError()).To(MatchError(\"peer tried to open stream 6 (current limit: 5)\"))\n\t})\n\n\tIt(\"blocks AcceptStream until a new stream is available\", func() {\n\t\tstrChan := make(chan *mockGenericStream)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tstr, err := m.AcceptStream(context.Background())\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tstrChan <- str\n\t\t}()\n\t\tConsistently(strChan).ShouldNot(Receive())\n\t\tstr, err := m.GetOrOpenStream(1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\tvar acceptedStr *mockGenericStream\n\t\tEventually(strChan).Should(Receive(&acceptedStr))\n\t\tExpect(acceptedStr.num).To(Equal(protocol.StreamNum(1)))\n\t})\n\n\tIt(\"unblocks AcceptStream when the context is canceled\", func() {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\t_, err := m.AcceptStream(ctx)\n\t\t\tExpect(err).To(MatchError(\"context canceled\"))\n\t\t\tclose(done)\n\t\t}()\n\t\tConsistently(done).ShouldNot(BeClosed())\n\t\tcancel()\n\t\tEventually(done).Should(BeClosed())\n\t})\n\n\tIt(\"unblocks AcceptStream when it is closed\", func() {\n\t\ttestErr := errors.New(\"test error\")\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\t_, err := m.AcceptStream(context.Background())\n\t\t\tExpect(err).To(MatchError(testErr))\n\t\t\tclose(done)\n\t\t}()\n\t\tConsistently(done).ShouldNot(BeClosed())\n\t\tm.CloseWithError(testErr)\n\t\tEventually(done).Should(BeClosed())\n\t})\n\n\tIt(\"errors AcceptStream immediately if it is closed\", func() {\n\t\ttestErr := errors.New(\"test error\")\n\t\tm.CloseWithError(testErr)\n\t\t_, err := m.AcceptStream(context.Background())\n\t\tExpect(err).To(MatchError(testErr))\n\t})\n\n\tIt(\"closes all streams when CloseWithError is called\", func() {\n\t\tstr1, err := m.GetOrOpenStream(1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tstr2, err := m.GetOrOpenStream(3)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\ttestErr := errors.New(\"test err\")\n\t\tm.CloseWithError(testErr)\n\t\tExpect(str1.closed).To(BeTrue())\n\t\tExpect(str1.closeErr).To(MatchError(testErr))\n\t\tExpect(str2.closed).To(BeTrue())\n\t\tExpect(str2.closeErr).To(MatchError(testErr))\n\t})\n\n\tIt(\"deletes streams\", func() {\n\t\t_, err := m.GetOrOpenStream(1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tstr, err := m.AcceptStream(context.Background())\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\tExpect(m.DeleteStream(1)).To(Succeed())\n\t\tstr, err = m.GetOrOpenStream(1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str).To(BeNil())\n\t})\n\n\tIt(\"waits until a stream is accepted before actually deleting it\", func() {\n\t\t_, err := m.GetOrOpenStream(2)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(m.DeleteStream(2)).To(Succeed())\n\t\tstr, err := m.AcceptStream(context.Background())\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t// when accepting this stream, it will get deleted, and a MAX_STREAMS frame is queued\n\t\tstr, err = m.AcceptStream(context.Background())\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str.num).To(Equal(protocol.StreamNum(2)))\n\t})\n\n\tIt(\"doesn't return a stream queued for deleting from GetOrOpenStream\", func() {\n\t\tstr, err := m.GetOrOpenStream(1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str).ToNot(BeNil())\n\t\tExpect(m.DeleteStream(1)).To(Succeed())\n\t\tstr, err = m.GetOrOpenStream(1)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str).To(BeNil())\n\t\t// when accepting this stream, it will get deleted, and a MAX_STREAMS frame is queued\n\t\tstr, err = m.AcceptStream(context.Background())\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\tExpect(str).ToNot(BeNil())\n\t})\n\n\tIt(\"errors when deleting a non-existing stream\", func() {\n\t\terr := m.DeleteStream(1337)\n\t\tExpect(err).To(HaveOccurred())\n\t\tExpect(err.(streamError).TestError()).To(MatchError(\"tried to delete unknown incoming stream 1337\"))\n\t})\n\n\tIt(\"sends MAX_STREAMS frames when streams are deleted\", func() {\n\t\t// open a bunch of streams\n\t\t_, err := m.GetOrOpenStream(5)\n\t\tExpect(err).ToNot(HaveOccurred())\n\t\t// accept all streams\n\t\tfor i := 0; i < 5; i++ {\n\t\t\t_, err := m.AcceptStream(context.Background())\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t}\n\t\tExpect(queuedControlFrames).To(BeEmpty())\n\t\tExpect(m.DeleteStream(3)).To(Succeed())\n\t\tExpect(queuedControlFrames).To(HaveLen(1))\n\t\tmsf := queuedControlFrames[0].(*wire.MaxStreamsFrame)\n\t\tExpect(msf.Type).To(BeEquivalentTo(streamType))\n\t\tExpect(msf.MaxStreamNum).To(Equal(protocol.StreamNum(maxNumStreams + 1)))\n\t\tcheckFrameSerialization(msf)\n\t\tExpect(m.DeleteStream(4)).To(Succeed())\n\t\tExpect(queuedControlFrames).To(HaveLen(2))\n\t\tExpect(queuedControlFrames[1].(*wire.MaxStreamsFrame).MaxStreamNum).To(Equal(protocol.StreamNum(maxNumStreams + 2)))\n\t\tcheckFrameSerialization(queuedControlFrames[1])\n\t})\n\n\tContext(\"using high stream limits\", func() {\n\t\tBeforeEach(func() { maxNumStreams = uint64(protocol.MaxStreamCount) - 2 })\n\n\t\tIt(\"doesn't send MAX_STREAMS frames if they would overflow 2^60 (the maximum stream count)\", func() {\n\t\t\t// open a bunch of streams\n\t\t\t_, err := m.GetOrOpenStream(5)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t// accept all streams\n\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\t_, err := m.AcceptStream(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t}\n\t\t\tExpect(queuedControlFrames).To(BeEmpty())\n\t\t\tExpect(m.DeleteStream(4)).To(Succeed())\n\t\t\tExpect(queuedControlFrames).To(HaveLen(1))\n\t\t\tExpect(queuedControlFrames[0].(*wire.MaxStreamsFrame).MaxStreamNum).To(Equal(protocol.MaxStreamCount - 1))\n\t\t\tcheckFrameSerialization(queuedControlFrames[0])\n\t\t\tExpect(m.DeleteStream(3)).To(Succeed())\n\t\t\tExpect(queuedControlFrames).To(HaveLen(2))\n\t\t\tExpect(queuedControlFrames[1].(*wire.MaxStreamsFrame).MaxStreamNum).To(Equal(protocol.MaxStreamCount))\n\t\t\tcheckFrameSerialization(queuedControlFrames[1])\n\t\t\t// at this point, we can't increase the stream limit any further, so no more MAX_STREAMS frames will be sent\n\t\t\tExpect(m.DeleteStream(2)).To(Succeed())\n\t\t\tExpect(m.DeleteStream(1)).To(Succeed())\n\t\t\tExpect(queuedControlFrames).To(HaveLen(2))\n\t\t})\n\t})\n\n\tContext(\"randomized tests\", func() {\n\t\tconst num = 1000\n\n\t\tBeforeEach(func() { maxNumStreams = num })\n\n\t\tIt(\"opens and accepts streams\", func() {\n\t\t\trand.Seed(uint64(GinkgoRandomSeed()))\n\t\t\tids := make([]protocol.StreamNum, num)\n\t\t\tfor i := 0; i < num; i++ {\n\t\t\t\tids[i] = protocol.StreamNum(i + 1)\n\t\t\t}\n\t\t\trand.Shuffle(len(ids), func(i, j int) { ids[i], ids[j] = ids[j], ids[i] })\n\n\t\t\tconst timeout = 5 * time.Second\n\t\t\tdone := make(chan struct{}, 2)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\t\t\tdefer cancel()\n\t\t\t\tfor i := 0; i < num; i++ {\n\t\t\t\t\t_, err := m.AcceptStream(ctx)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tfor i := 0; i < num; i++ {\n\t\t\t\t\t_, err := m.GetOrOpenStream(ids[i])\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\n\t\t\tEventually(done, timeout*3/2).Should(Receive())\n\t\t\tEventually(done, timeout*3/2).Should(Receive())\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "streams_map_outgoing.go",
          "type": "blob",
          "size": 5.46875,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n)\n\ntype outgoingStream interface {\n\tupdateSendWindow(protocol.ByteCount)\n\tcloseForShutdown(error)\n}\n\ntype outgoingStreamsMap[T outgoingStream] struct {\n\tmutex sync.RWMutex\n\n\tstreamType protocol.StreamType\n\tstreams    map[protocol.StreamNum]T\n\n\topenQueue      map[uint64]chan struct{}\n\tlowestInQueue  uint64\n\thighestInQueue uint64\n\n\tnextStream  protocol.StreamNum // stream ID of the stream returned by OpenStream(Sync)\n\tmaxStream   protocol.StreamNum // the maximum stream ID we're allowed to open\n\tblockedSent bool               // was a STREAMS_BLOCKED sent for the current maxStream\n\n\tnewStream            func(protocol.StreamNum) T\n\tqueueStreamIDBlocked func(*wire.StreamsBlockedFrame)\n\n\tcloseErr error\n}\n\nfunc newOutgoingStreamsMap[T outgoingStream](\n\tstreamType protocol.StreamType,\n\tnewStream func(protocol.StreamNum) T,\n\tqueueControlFrame func(wire.Frame),\n) *outgoingStreamsMap[T] {\n\treturn &outgoingStreamsMap[T]{\n\t\tstreamType:           streamType,\n\t\tstreams:              make(map[protocol.StreamNum]T),\n\t\topenQueue:            make(map[uint64]chan struct{}),\n\t\tmaxStream:            protocol.InvalidStreamNum,\n\t\tnextStream:           1,\n\t\tnewStream:            newStream,\n\t\tqueueStreamIDBlocked: func(f *wire.StreamsBlockedFrame) { queueControlFrame(f) },\n\t}\n}\n\nfunc (m *outgoingStreamsMap[T]) OpenStream() (T, error) {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tif m.closeErr != nil {\n\t\treturn *new(T), m.closeErr\n\t}\n\n\t// if there are OpenStreamSync calls waiting, return an error here\n\tif len(m.openQueue) > 0 || m.nextStream > m.maxStream {\n\t\tm.maybeSendBlockedFrame()\n\t\treturn *new(T), streamOpenErr{&StreamLimitReachedError{}}\n\t}\n\treturn m.openStream(), nil\n}\n\nfunc (m *outgoingStreamsMap[T]) OpenStreamSync(ctx context.Context) (T, error) {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tif m.closeErr != nil {\n\t\treturn *new(T), m.closeErr\n\t}\n\n\tif err := ctx.Err(); err != nil {\n\t\treturn *new(T), err\n\t}\n\n\tif len(m.openQueue) == 0 && m.nextStream <= m.maxStream {\n\t\treturn m.openStream(), nil\n\t}\n\n\twaitChan := make(chan struct{}, 1)\n\tqueuePos := m.highestInQueue\n\tm.highestInQueue++\n\tif len(m.openQueue) == 0 {\n\t\tm.lowestInQueue = queuePos\n\t}\n\tm.openQueue[queuePos] = waitChan\n\tm.maybeSendBlockedFrame()\n\n\tfor {\n\t\tm.mutex.Unlock()\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tm.mutex.Lock()\n\t\t\tdelete(m.openQueue, queuePos)\n\t\t\treturn *new(T), ctx.Err()\n\t\tcase <-waitChan:\n\t\t}\n\t\tm.mutex.Lock()\n\n\t\tif m.closeErr != nil {\n\t\t\treturn *new(T), m.closeErr\n\t\t}\n\t\tif m.nextStream > m.maxStream {\n\t\t\t// no stream available. Continue waiting\n\t\t\tcontinue\n\t\t}\n\t\tstr := m.openStream()\n\t\tdelete(m.openQueue, queuePos)\n\t\tm.lowestInQueue = queuePos + 1\n\t\tm.unblockOpenSync()\n\t\treturn str, nil\n\t}\n}\n\nfunc (m *outgoingStreamsMap[T]) openStream() T {\n\ts := m.newStream(m.nextStream)\n\tm.streams[m.nextStream] = s\n\tm.nextStream++\n\treturn s\n}\n\n// maybeSendBlockedFrame queues a STREAMS_BLOCKED frame for the current stream offset,\n// if we haven't sent one for this offset yet\nfunc (m *outgoingStreamsMap[T]) maybeSendBlockedFrame() {\n\tif m.blockedSent {\n\t\treturn\n\t}\n\n\tvar streamNum protocol.StreamNum\n\tif m.maxStream != protocol.InvalidStreamNum {\n\t\tstreamNum = m.maxStream\n\t}\n\tm.queueStreamIDBlocked(&wire.StreamsBlockedFrame{\n\t\tType:        m.streamType,\n\t\tStreamLimit: streamNum,\n\t})\n\tm.blockedSent = true\n}\n\nfunc (m *outgoingStreamsMap[T]) GetStream(num protocol.StreamNum) (T, error) {\n\tm.mutex.RLock()\n\tif num >= m.nextStream {\n\t\tm.mutex.RUnlock()\n\t\treturn *new(T), streamError{\n\t\t\tmessage: \"peer attempted to open stream %d\",\n\t\t\tnums:    []protocol.StreamNum{num},\n\t\t}\n\t}\n\ts := m.streams[num]\n\tm.mutex.RUnlock()\n\treturn s, nil\n}\n\nfunc (m *outgoingStreamsMap[T]) DeleteStream(num protocol.StreamNum) error {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tif _, ok := m.streams[num]; !ok {\n\t\treturn streamError{\n\t\t\tmessage: \"tried to delete unknown outgoing stream %d\",\n\t\t\tnums:    []protocol.StreamNum{num},\n\t\t}\n\t}\n\tdelete(m.streams, num)\n\treturn nil\n}\n\nfunc (m *outgoingStreamsMap[T]) SetMaxStream(num protocol.StreamNum) {\n\tm.mutex.Lock()\n\tdefer m.mutex.Unlock()\n\n\tif num <= m.maxStream {\n\t\treturn\n\t}\n\tm.maxStream = num\n\tm.blockedSent = false\n\tif m.maxStream < m.nextStream-1+protocol.StreamNum(len(m.openQueue)) {\n\t\tm.maybeSendBlockedFrame()\n\t}\n\tm.unblockOpenSync()\n}\n\n// UpdateSendWindow is called when the peer's transport parameters are received.\n// Only in the case of a 0-RTT handshake will we have open streams at this point.\n// We might need to update the send window, in case the server increased it.\nfunc (m *outgoingStreamsMap[T]) UpdateSendWindow(limit protocol.ByteCount) {\n\tm.mutex.Lock()\n\tfor _, str := range m.streams {\n\t\tstr.updateSendWindow(limit)\n\t}\n\tm.mutex.Unlock()\n}\n\n// unblockOpenSync unblocks the next OpenStreamSync go-routine to open a new stream\nfunc (m *outgoingStreamsMap[T]) unblockOpenSync() {\n\tif len(m.openQueue) == 0 {\n\t\treturn\n\t}\n\tfor qp := m.lowestInQueue; qp <= m.highestInQueue; qp++ {\n\t\tc, ok := m.openQueue[qp]\n\t\tif !ok { // entry was deleted because the context was canceled\n\t\t\tcontinue\n\t\t}\n\t\t// unblockOpenSync is called both from OpenStreamSync and from SetMaxStream.\n\t\t// It's sufficient to only unblock OpenStreamSync once.\n\t\tselect {\n\t\tcase c <- struct{}{}:\n\t\tdefault:\n\t\t}\n\t\treturn\n\t}\n}\n\nfunc (m *outgoingStreamsMap[T]) CloseWithError(err error) {\n\tm.mutex.Lock()\n\tm.closeErr = err\n\tfor _, str := range m.streams {\n\t\tstr.closeForShutdown(err)\n\t}\n\tfor _, c := range m.openQueue {\n\t\tif c != nil {\n\t\t\tclose(c)\n\t\t}\n\t}\n\tm.mutex.Unlock()\n}\n"
        },
        {
          "name": "streams_map_outgoing_test.go",
          "type": "blob",
          "size": 15.16015625,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/exp/rand\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Streams Map (outgoing)\", func() {\n\tvar (\n\t\tm                   *outgoingStreamsMap[*mockGenericStream]\n\t\tnewStr              func(num protocol.StreamNum) *mockGenericStream\n\t\tqueuedControlFrames []wire.Frame\n\t)\n\n\tconst streamType = 42\n\n\t// waitForEnqueued waits until there are n go routines waiting on OpenStreamSync()\n\twaitForEnqueued := func(n int) {\n\t\tEventually(func() int {\n\t\t\tm.mutex.Lock()\n\t\t\tdefer m.mutex.Unlock()\n\t\t\treturn len(m.openQueue)\n\t\t}, scaleDuration(100*time.Millisecond), scaleDuration(10*time.Microsecond)).Should(Equal(n))\n\t}\n\n\tBeforeEach(func() {\n\t\tqueuedControlFrames = []wire.Frame{}\n\t\tnewStr = func(num protocol.StreamNum) *mockGenericStream {\n\t\t\treturn &mockGenericStream{num: num}\n\t\t}\n\t\tm = newOutgoingStreamsMap[*mockGenericStream](\n\t\t\tstreamType,\n\t\t\tnewStr,\n\t\t\tfunc(f wire.Frame) { queuedControlFrames = append(queuedControlFrames, f) },\n\t\t)\n\t})\n\n\tContext(\"no stream ID limit\", func() {\n\t\tBeforeEach(func() {\n\t\t\tm.SetMaxStream(0xffffffff)\n\t\t})\n\n\t\tIt(\"opens streams\", func() {\n\t\t\tstr, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t\tstr, err = m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(2)))\n\t\t})\n\n\t\tIt(\"doesn't open streams after it has been closed\", func() {\n\t\t\ttestErr := errors.New(\"close\")\n\t\t\tm.CloseWithError(testErr)\n\t\t\t_, err := m.OpenStream()\n\t\t\tExpect(err).To(MatchError(testErr))\n\t\t})\n\n\t\tIt(\"gets streams\", func() {\n\t\t\t_, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tstr, err := m.GetStream(1)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t})\n\n\t\tIt(\"errors when trying to get a stream that has not yet been opened\", func() {\n\t\t\t_, err := m.GetStream(1)\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(streamError).TestError()).To(MatchError(\"peer attempted to open stream 1\"))\n\t\t})\n\n\t\tIt(\"deletes streams\", func() {\n\t\t\t_, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(m.DeleteStream(1)).To(Succeed())\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tstr, err := m.GetStream(1)\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str).To(BeNil())\n\t\t})\n\n\t\tIt(\"errors when deleting a non-existing stream\", func() {\n\t\t\terr := m.DeleteStream(1337)\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(streamError).TestError()).To(MatchError(\"tried to delete unknown outgoing stream 1337\"))\n\t\t})\n\n\t\tIt(\"errors when deleting a stream twice\", func() {\n\t\t\t_, err := m.OpenStream() // opens firstNewStream\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(m.DeleteStream(1)).To(Succeed())\n\t\t\terr = m.DeleteStream(1)\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(streamError).TestError()).To(MatchError(\"tried to delete unknown outgoing stream 1\"))\n\t\t})\n\n\t\tIt(\"closes all streams when CloseWithError is called\", func() {\n\t\t\tstr1, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tstr2, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\ttestErr := errors.New(\"test err\")\n\t\t\tm.CloseWithError(testErr)\n\t\t\tExpect(str1.closed).To(BeTrue())\n\t\t\tExpect(str1.closeErr).To(MatchError(testErr))\n\t\t\tExpect(str2.closed).To(BeTrue())\n\t\t\tExpect(str2.closeErr).To(MatchError(testErr))\n\t\t})\n\n\t\tIt(\"updates the send window\", func() {\n\t\t\tstr1, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tstr2, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tm.UpdateSendWindow(1337)\n\t\t\tExpect(str1.sendWindow).To(BeEquivalentTo(1337))\n\t\t\tExpect(str2.sendWindow).To(BeEquivalentTo(1337))\n\t\t})\n\t})\n\n\tContext(\"with stream ID limits\", func() {\n\t\tIt(\"errors when no stream can be opened immediately\", func() {\n\t\t\t_, err := m.OpenStream()\n\t\t\texpectTooManyStreamsError(err)\n\t\t})\n\n\t\tIt(\"returns immediately when called with a canceled context\", func() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tcancel()\n\t\t\t_, err := m.OpenStreamSync(ctx)\n\t\t\tExpect(err).To(MatchError(\"context canceled\"))\n\t\t})\n\n\t\tIt(\"blocks until a stream can be opened synchronously\", func() {\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tstr, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\twaitForEnqueued(1)\n\n\t\t\tm.SetMaxStream(1)\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"unblocks when the context is canceled\", func() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(ctx)\n\t\t\t\tExpect(err).To(MatchError(\"context canceled\"))\n\t\t\t\tclose(done)\n\t\t\t}()\n\t\t\twaitForEnqueued(1)\n\n\t\t\tcancel()\n\t\t\tEventually(done).Should(BeClosed())\n\n\t\t\t// make sure that the next stream opened is stream 1\n\t\t\tm.SetMaxStream(1000)\n\t\t\tstr, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t})\n\n\t\tIt(\"opens streams in the right order\", func() {\n\t\t\tdone1 := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tstr, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t\t\tclose(done1)\n\t\t\t}()\n\t\t\twaitForEnqueued(1)\n\n\t\t\tdone2 := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tstr, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(2)))\n\t\t\t\tclose(done2)\n\t\t\t}()\n\t\t\twaitForEnqueued(2)\n\n\t\t\tm.SetMaxStream(1)\n\t\t\tEventually(done1).Should(BeClosed())\n\t\t\tConsistently(done2).ShouldNot(BeClosed())\n\t\t\tm.SetMaxStream(2)\n\t\t\tEventually(done2).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"opens streams in the right order, when one of the contexts is canceled\", func() {\n\t\t\tdone1 := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tstr, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t\t\tclose(done1)\n\t\t\t}()\n\t\t\twaitForEnqueued(1)\n\n\t\t\tdone2 := make(chan struct{})\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(ctx)\n\t\t\t\tExpect(err).To(MatchError(context.Canceled))\n\t\t\t\tclose(done2)\n\t\t\t}()\n\t\t\twaitForEnqueued(2)\n\n\t\t\tdone3 := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tstr, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(2)))\n\t\t\t\tclose(done3)\n\t\t\t}()\n\t\t\twaitForEnqueued(3)\n\n\t\t\tcancel()\n\t\t\tEventually(done2).Should(BeClosed())\n\t\t\tm.SetMaxStream(1000)\n\t\t\tEventually(done1).Should(BeClosed())\n\t\t\tEventually(done3).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"unblocks multiple OpenStreamSync calls at the same time\", func() {\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\t\t\twaitForEnqueued(2)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).To(MatchError(\"test done\"))\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\t\t\twaitForEnqueued(3)\n\n\t\t\tm.SetMaxStream(2)\n\t\t\tEventually(done).Should(Receive())\n\t\t\tEventually(done).Should(Receive())\n\t\t\tConsistently(done).ShouldNot(Receive())\n\n\t\t\tm.CloseWithError(errors.New(\"test done\"))\n\t\t\tEventually(done).Should(Receive())\n\t\t})\n\n\t\tIt(\"returns an error for OpenStream while an OpenStreamSync call is blocking\", func() {\n\t\t\topenedSync := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tstr, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(1)))\n\t\t\t\tclose(openedSync)\n\t\t\t}()\n\t\t\twaitForEnqueued(1)\n\n\t\t\tstart := make(chan struct{})\n\t\t\topenend := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tvar hasStarted bool\n\t\t\t\tfor {\n\t\t\t\t\tstr, err := m.OpenStream()\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(2)))\n\t\t\t\t\t\tclose(openend)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\t\tif !hasStarted {\n\t\t\t\t\t\tclose(start)\n\t\t\t\t\t\thasStarted = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tEventually(start).Should(BeClosed())\n\t\t\tm.SetMaxStream(1)\n\t\t\tEventually(openedSync).Should(BeClosed())\n\t\t\tConsistently(openend).ShouldNot(BeClosed())\n\t\t\tm.SetMaxStream(2)\n\t\t\tEventually(openend).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"stops opening synchronously when it is closed\", func() {\n\t\t\ttestErr := errors.New(\"test error\")\n\t\t\tdone := make(chan struct{})\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).To(MatchError(testErr))\n\t\t\t\tclose(done)\n\t\t\t}()\n\n\t\t\tConsistently(done).ShouldNot(BeClosed())\n\t\t\tm.CloseWithError(testErr)\n\t\t\tEventually(done).Should(BeClosed())\n\t\t})\n\n\t\tIt(\"doesn't reduce the stream limit\", func() {\n\t\t\tm.SetMaxStream(2)\n\t\t\tm.SetMaxStream(1)\n\t\t\t_, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tstr, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(2)))\n\t\t})\n\n\t\tIt(\"queues a STREAMS_BLOCKED frame if no stream can be opened\", func() {\n\t\t\tm.SetMaxStream(6)\n\t\t\t// open the 6 allowed streams\n\t\t\tfor i := 0; i < 6; i++ {\n\t\t\t\t_, err := m.OpenStream()\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t}\n\n\t\t\tExpect(queuedControlFrames).To(BeEmpty())\n\t\t\t_, err := m.OpenStream()\n\t\t\tExpect(err).To(MatchError(&StreamLimitReachedError{}))\n\t\t\tExpect(queuedControlFrames).To(HaveLen(1))\n\t\t\tbf := queuedControlFrames[0].(*wire.StreamsBlockedFrame)\n\t\t\tExpect(bf.Type).To(BeEquivalentTo(streamType))\n\t\t\tExpect(bf.StreamLimit).To(BeEquivalentTo(6))\n\t\t})\n\n\t\tIt(\"only sends one STREAMS_BLOCKED frame for one stream ID\", func() {\n\t\t\tm.SetMaxStream(1)\n\t\t\t_, err := m.OpenStream()\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tExpect(queuedControlFrames).To(BeEmpty())\n\t\t\t// try to open a stream twice, but expect only one STREAMS_BLOCKED to be sent\n\t\t\t_, err = m.OpenStream()\n\t\t\texpectTooManyStreamsError(err)\n\t\t\tExpect(queuedControlFrames).To(HaveLen(1))\n\t\t\tExpect(queuedControlFrames[0].(*wire.StreamsBlockedFrame).StreamLimit).To(BeEquivalentTo(1))\n\t\t\t_, err = m.OpenStream()\n\t\t\texpectTooManyStreamsError(err)\n\t\t\tExpect(queuedControlFrames).To(HaveLen(1))\n\t\t})\n\n\t\tIt(\"queues a STREAMS_BLOCKED frame when there more streams waiting for OpenStreamSync than MAX_STREAMS allows\", func() {\n\t\t\tdone := make(chan struct{}, 2)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t_, err := m.OpenStreamSync(context.Background())\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\tdone <- struct{}{}\n\t\t\t}()\n\t\t\twaitForEnqueued(2)\n\t\t\tExpect(queuedControlFrames).To(HaveLen(1))\n\t\t\tExpect(queuedControlFrames[0].(*wire.StreamsBlockedFrame).StreamLimit).To(BeEquivalentTo(0))\n\n\t\t\tm.SetMaxStream(1)\n\t\t\tEventually(done).Should(Receive())\n\t\t\tConsistently(done).ShouldNot(Receive())\n\t\t\tExpect(queuedControlFrames).To(HaveLen(2))\n\t\t\tExpect(queuedControlFrames[1].(*wire.StreamsBlockedFrame).StreamLimit).To(BeEquivalentTo(1))\n\t\t\tm.SetMaxStream(2)\n\t\t\tEventually(done).Should(Receive())\n\t\t})\n\t})\n\n\tContext(\"randomized tests\", func() {\n\t\tIt(\"opens streams\", func() {\n\t\t\trand.Seed(uint64(GinkgoRandomSeed()))\n\t\t\tconst n = 100\n\t\t\tfmt.Fprintf(GinkgoWriter, \"Opening %d streams concurrently.\\n\", n)\n\n\t\t\tdone := make(map[int]chan struct{})\n\t\t\tfor i := 1; i <= n; i++ {\n\t\t\t\tc := make(chan struct{})\n\t\t\t\tdone[i] = c\n\n\t\t\t\tgo func(doneChan chan struct{}, id protocol.StreamNum) {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tdefer close(doneChan)\n\t\t\t\t\tstr, err := m.OpenStreamSync(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.num).To(Equal(id))\n\t\t\t\t}(c, protocol.StreamNum(i))\n\t\t\t\twaitForEnqueued(i)\n\t\t\t}\n\n\t\t\tvar limit int\n\t\t\tlimits := []protocol.StreamNum{0}\n\t\t\tfor limit < n {\n\t\t\t\tlimit += rand.Intn(n/5) + 1\n\t\t\t\tif limit <= n {\n\t\t\t\t\tlimits = append(limits, protocol.StreamNum(limit))\n\t\t\t\t}\n\t\t\t\tfmt.Fprintf(GinkgoWriter, \"Setting stream limit to %d.\\n\", limit)\n\t\t\t\tm.SetMaxStream(protocol.StreamNum(limit))\n\t\t\t\tfor i := 1; i <= n; i++ {\n\t\t\t\t\tif i <= limit {\n\t\t\t\t\t\tEventually(done[i]).Should(BeClosed())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tExpect(done[i]).ToNot(BeClosed())\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr, err := m.OpenStream()\n\t\t\t\tif limit <= n {\n\t\t\t\t\tExpect(err).To(MatchError(&StreamLimitReachedError{}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(str.num).To(Equal(protocol.StreamNum(n + 1)))\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar blockedAt []protocol.StreamNum\n\t\t\tfor _, f := range queuedControlFrames {\n\t\t\t\tblockedAt = append(blockedAt, f.(*wire.StreamsBlockedFrame).StreamLimit)\n\t\t\t}\n\t\t\tExpect(blockedAt).To(Equal(limits))\n\t\t})\n\n\t\tIt(\"opens streams, when some of them are getting canceled\", func() {\n\t\t\trand.Seed(uint64(GinkgoRandomSeed()))\n\t\t\tconst n = 100\n\t\t\tfmt.Fprintf(GinkgoWriter, \"Opening %d streams concurrently.\\n\", n)\n\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tstreamsToCancel := make(map[protocol.StreamNum]struct{}) // used as a set\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tid := protocol.StreamNum(rand.Intn(n) + 1)\n\t\t\t\tfmt.Fprintf(GinkgoWriter, \"Canceling stream %d.\\n\", id)\n\t\t\t\tstreamsToCancel[id] = struct{}{}\n\t\t\t}\n\n\t\t\tstreamWillBeCanceled := func(id protocol.StreamNum) bool {\n\t\t\t\t_, ok := streamsToCancel[id]\n\t\t\t\treturn ok\n\t\t\t}\n\n\t\t\tvar streamIDs []int\n\t\t\tvar mutex sync.Mutex\n\t\t\tdone := make(map[int]chan struct{})\n\t\t\tfor i := 1; i <= n; i++ {\n\t\t\t\tc := make(chan struct{})\n\t\t\t\tdone[i] = c\n\n\t\t\t\tgo func(doneChan chan struct{}, id protocol.StreamNum) {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tdefer close(doneChan)\n\t\t\t\t\tcont := context.Background()\n\t\t\t\t\tif streamWillBeCanceled(id) {\n\t\t\t\t\t\tcont = ctx\n\t\t\t\t\t}\n\t\t\t\t\tstr, err := m.OpenStreamSync(cont)\n\t\t\t\t\tif streamWillBeCanceled(id) {\n\t\t\t\t\t\tExpect(err).To(MatchError(context.Canceled))\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tstreamIDs = append(streamIDs, int(str.num))\n\t\t\t\t\tmutex.Unlock()\n\t\t\t\t}(c, protocol.StreamNum(i))\n\t\t\t\twaitForEnqueued(i)\n\t\t\t}\n\n\t\t\tcancel()\n\t\t\tfor id := range streamsToCancel {\n\t\t\t\tEventually(done[int(id)]).Should(BeClosed())\n\t\t\t}\n\t\t\tvar limit int\n\t\t\tnumStreams := n - len(streamsToCancel)\n\t\t\tvar limits []protocol.StreamNum\n\t\t\tfor limit < numStreams {\n\t\t\t\tlimits = append(limits, protocol.StreamNum(limit))\n\t\t\t\tlimit += rand.Intn(n/5) + 1\n\t\t\t\tfmt.Fprintf(GinkgoWriter, \"Setting stream limit to %d.\\n\", limit)\n\t\t\t\tm.SetMaxStream(protocol.StreamNum(limit))\n\t\t\t\tl := limit\n\t\t\t\tif l > numStreams {\n\t\t\t\t\tl = numStreams\n\t\t\t\t}\n\t\t\t\tEventually(func() int {\n\t\t\t\t\tmutex.Lock()\n\t\t\t\t\tdefer mutex.Unlock()\n\t\t\t\t\treturn len(streamIDs)\n\t\t\t\t}).Should(Equal(l))\n\t\t\t\t// check that all stream IDs were used\n\t\t\t\tExpect(streamIDs).To(HaveLen(l))\n\t\t\t\tsort.Ints(streamIDs)\n\t\t\t\tfor i := 0; i < l; i++ {\n\t\t\t\t\tExpect(streamIDs[i]).To(Equal(i + 1))\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar blockedAt []protocol.StreamNum\n\t\t\tfor _, f := range queuedControlFrames {\n\t\t\t\tblockedAt = append(blockedAt, f.(*wire.StreamsBlockedFrame).StreamLimit)\n\t\t\t}\n\t\t\tExpect(blockedAt).To(Equal(limits))\n\t\t})\n\t})\n})\n"
        },
        {
          "name": "streams_map_test.go",
          "type": "blob",
          "size": 17.337890625,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/quic-go/quic-go/internal/flowcontrol\"\n\t\"github.com/quic-go/quic-go/internal/mocks\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\n\t. \"github.com/onsi/ginkgo/v2\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc (e streamError) TestError() error {\n\tnums := make([]interface{}, len(e.nums))\n\tfor i, num := range e.nums {\n\t\tnums[i] = num\n\t}\n\treturn fmt.Errorf(e.message, nums...)\n}\n\ntype streamMapping struct {\n\tfirstIncomingBidiStream protocol.StreamID\n\tfirstIncomingUniStream  protocol.StreamID\n\tfirstOutgoingBidiStream protocol.StreamID\n\tfirstOutgoingUniStream  protocol.StreamID\n}\n\nfunc expectTooManyStreamsError(err error) {\n\tExpectWithOffset(1, err).To(MatchError(&StreamLimitReachedError{}))\n\tnerr, ok := err.(net.Error)\n\tExpectWithOffset(1, ok).To(BeTrue())\n\tExpectWithOffset(1, nerr.Timeout()).To(BeFalse())\n\t//nolint:staticcheck // SA1019\n\t// In older versions of quic-go, the stream limit error was documented to be a net.Error.Temporary.\n\t// This function was since deprecated, but we keep the existing behavior.\n\tExpectWithOffset(1, nerr.Temporary()).To(BeTrue())\n}\n\nvar _ = Describe(\"Streams Map\", func() {\n\tnewFlowController := func(protocol.StreamID) flowcontrol.StreamFlowController {\n\t\treturn mocks.NewMockStreamFlowController(mockCtrl)\n\t}\n\n\tserverStreamMapping := streamMapping{\n\t\tfirstIncomingBidiStream: 0,\n\t\tfirstOutgoingBidiStream: 1,\n\t\tfirstIncomingUniStream:  2,\n\t\tfirstOutgoingUniStream:  3,\n\t}\n\tclientStreamMapping := streamMapping{\n\t\tfirstIncomingBidiStream: 1,\n\t\tfirstOutgoingBidiStream: 0,\n\t\tfirstIncomingUniStream:  3,\n\t\tfirstOutgoingUniStream:  2,\n\t}\n\n\tfor _, p := range []protocol.Perspective{protocol.PerspectiveServer, protocol.PerspectiveClient} {\n\t\tperspective := p\n\t\tvar ids streamMapping\n\t\tif perspective == protocol.PerspectiveClient {\n\t\t\tids = clientStreamMapping\n\t\t} else {\n\t\t\tids = serverStreamMapping\n\t\t}\n\n\t\tContext(perspective.String(), func() {\n\t\t\tvar (\n\t\t\t\tm                   *streamsMap\n\t\t\t\tmockSender          *MockStreamSender\n\t\t\t\tqueuedControlFrames []wire.Frame\n\t\t\t)\n\n\t\t\tconst (\n\t\t\t\tMaxBidiStreamNum = 111\n\t\t\t\tMaxUniStreamNum  = 222\n\t\t\t)\n\n\t\t\tallowUnlimitedStreams := func() {\n\t\t\t\tm.UpdateLimits(&wire.TransportParameters{\n\t\t\t\t\tMaxBidiStreamNum: protocol.MaxStreamCount,\n\t\t\t\t\tMaxUniStreamNum:  protocol.MaxStreamCount,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tBeforeEach(func() {\n\t\t\t\tqueuedControlFrames = []wire.Frame{}\n\t\t\t\tmockSender = NewMockStreamSender(mockCtrl)\n\t\t\t\tm = newStreamsMap(\n\t\t\t\t\tcontext.Background(),\n\t\t\t\t\tmockSender,\n\t\t\t\t\tfunc(f wire.Frame) { queuedControlFrames = append(queuedControlFrames, f) },\n\t\t\t\t\tnewFlowController,\n\t\t\t\t\tMaxBidiStreamNum,\n\t\t\t\t\tMaxUniStreamNum,\n\t\t\t\t\tperspective,\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tContext(\"opening\", func() {\n\t\t\t\tIt(\"opens bidirectional streams\", func() {\n\t\t\t\t\tallowUnlimitedStreams()\n\t\t\t\t\tstr, err := m.OpenStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).To(BeAssignableToTypeOf(&stream{}))\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingBidiStream))\n\t\t\t\t\tstr, err = m.OpenStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).To(BeAssignableToTypeOf(&stream{}))\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingBidiStream + 4))\n\t\t\t\t})\n\n\t\t\t\tIt(\"opens unidirectional streams\", func() {\n\t\t\t\t\tallowUnlimitedStreams()\n\t\t\t\t\tstr, err := m.OpenUniStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).To(BeAssignableToTypeOf(&sendStream{}))\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingUniStream))\n\t\t\t\t\tstr, err = m.OpenUniStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).To(BeAssignableToTypeOf(&sendStream{}))\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingUniStream + 4))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tContext(\"accepting\", func() {\n\t\t\t\tIt(\"accepts bidirectional streams\", func() {\n\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(ids.firstIncomingBidiStream)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tstr, err := m.AcceptStream(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).To(BeAssignableToTypeOf(&stream{}))\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstIncomingBidiStream))\n\t\t\t\t})\n\n\t\t\t\tIt(\"accepts unidirectional streams\", func() {\n\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(ids.firstIncomingUniStream)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tstr, err := m.AcceptUniStream(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).To(BeAssignableToTypeOf(&receiveStream{}))\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstIncomingUniStream))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tContext(\"deleting\", func() {\n\t\t\t\tBeforeEach(func() { allowUnlimitedStreams() })\n\n\t\t\t\tIt(\"deletes outgoing bidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstOutgoingBidiStream\n\t\t\t\t\tstr, err := m.OpenStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(Succeed())\n\t\t\t\t\tdstr, err := m.GetOrOpenSendStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(dstr).To(BeNil())\n\t\t\t\t})\n\n\t\t\t\tIt(\"deletes incoming bidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstIncomingBidiStream\n\t\t\t\t\tstr, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(Succeed())\n\t\t\t\t\tdstr, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(dstr).To(BeNil())\n\t\t\t\t})\n\n\t\t\t\tIt(\"accepts bidirectional streams after they have been deleted\", func() {\n\t\t\t\t\tid := ids.firstIncomingBidiStream\n\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(Succeed())\n\t\t\t\t\tstr, err := m.AcceptStream(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).ToNot(BeNil())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t})\n\n\t\t\t\tIt(\"deletes outgoing unidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstOutgoingUniStream\n\t\t\t\t\tstr, err := m.OpenUniStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(Succeed())\n\t\t\t\t\tdstr, err := m.GetOrOpenSendStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(dstr).To(BeNil())\n\t\t\t\t})\n\n\t\t\t\tIt(\"deletes incoming unidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstIncomingUniStream\n\t\t\t\t\tstr, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(Succeed())\n\t\t\t\t\tdstr, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(dstr).To(BeNil())\n\t\t\t\t})\n\n\t\t\t\tIt(\"accepts unirectional streams after they have been deleted\", func() {\n\t\t\t\t\tid := ids.firstIncomingUniStream\n\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(Succeed())\n\t\t\t\t\tstr, err := m.AcceptUniStream(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).ToNot(BeNil())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t})\n\n\t\t\t\tIt(\"errors when deleting unknown incoming unidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstIncomingUniStream + 4\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(MatchError(fmt.Sprintf(\"tried to delete unknown incoming stream %d\", id)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"errors when deleting unknown outgoing unidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstOutgoingUniStream + 4\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(MatchError(fmt.Sprintf(\"tried to delete unknown outgoing stream %d\", id)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"errors when deleting unknown incoming bidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstIncomingBidiStream + 4\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(MatchError(fmt.Sprintf(\"tried to delete unknown incoming stream %d\", id)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"errors when deleting unknown outgoing bidirectional streams\", func() {\n\t\t\t\t\tid := ids.firstOutgoingBidiStream + 4\n\t\t\t\t\tExpect(m.DeleteStream(id)).To(MatchError(fmt.Sprintf(\"tried to delete unknown outgoing stream %d\", id)))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tContext(\"getting streams\", func() {\n\t\t\t\tBeforeEach(func() {\n\t\t\t\t\tallowUnlimitedStreams()\n\t\t\t\t})\n\n\t\t\t\tContext(\"send streams\", func() {\n\t\t\t\t\tIt(\"gets an outgoing bidirectional stream\", func() {\n\t\t\t\t\t\t// need to open the stream ourselves first\n\t\t\t\t\t\t// the peer is not allowed to create a stream initiated by us\n\t\t\t\t\t\t_, err := m.OpenStream()\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tstr, err := m.GetOrOpenSendStream(ids.firstOutgoingBidiStream)\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingBidiStream))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"errors when the peer tries to open a higher outgoing bidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstOutgoingBidiStream + 5*4\n\t\t\t\t\t\t_, err := m.GetOrOpenSendStream(id)\n\t\t\t\t\t\tExpect(err).To(MatchError(&qerr.TransportError{\n\t\t\t\t\t\t\tErrorCode:    qerr.StreamStateError,\n\t\t\t\t\t\t\tErrorMessage: fmt.Sprintf(\"peer attempted to open stream %d\", id),\n\t\t\t\t\t\t}))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"gets an outgoing unidirectional stream\", func() {\n\t\t\t\t\t\t// need to open the stream ourselves first\n\t\t\t\t\t\t// the peer is not allowed to create a stream initiated by us\n\t\t\t\t\t\t_, err := m.OpenUniStream()\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tstr, err := m.GetOrOpenSendStream(ids.firstOutgoingUniStream)\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingUniStream))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"errors when the peer tries to open a higher outgoing bidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstOutgoingUniStream + 5*4\n\t\t\t\t\t\t_, err := m.GetOrOpenSendStream(id)\n\t\t\t\t\t\tExpect(err).To(MatchError(&qerr.TransportError{\n\t\t\t\t\t\t\tErrorCode:    qerr.StreamStateError,\n\t\t\t\t\t\t\tErrorMessage: fmt.Sprintf(\"peer attempted to open stream %d\", id),\n\t\t\t\t\t\t}))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"gets an incoming bidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstIncomingBidiStream + 4*7\n\t\t\t\t\t\tstr, err := m.GetOrOpenSendStream(id)\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"errors when trying to get an incoming unidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstIncomingUniStream\n\t\t\t\t\t\t_, err := m.GetOrOpenSendStream(id)\n\t\t\t\t\t\tExpect(err).To(MatchError(&qerr.TransportError{\n\t\t\t\t\t\t\tErrorCode:    qerr.StreamStateError,\n\t\t\t\t\t\t\tErrorMessage: fmt.Sprintf(\"peer attempted to open send stream %d\", id),\n\t\t\t\t\t\t}))\n\t\t\t\t\t})\n\t\t\t\t})\n\n\t\t\t\tContext(\"receive streams\", func() {\n\t\t\t\t\tIt(\"gets an outgoing bidirectional stream\", func() {\n\t\t\t\t\t\t// need to open the stream ourselves first\n\t\t\t\t\t\t// the peer is not allowed to create a stream initiated by us\n\t\t\t\t\t\t_, err := m.OpenStream()\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tstr, err := m.GetOrOpenReceiveStream(ids.firstOutgoingBidiStream)\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingBidiStream))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"errors when the peer tries to open a higher outgoing bidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstOutgoingBidiStream + 5*4\n\t\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\t\tExpect(err).To(MatchError(&qerr.TransportError{\n\t\t\t\t\t\t\tErrorCode:    qerr.StreamStateError,\n\t\t\t\t\t\t\tErrorMessage: fmt.Sprintf(\"peer attempted to open stream %d\", id),\n\t\t\t\t\t\t}))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"gets an incoming bidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstIncomingBidiStream + 4*7\n\t\t\t\t\t\tstr, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"gets an incoming unidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstIncomingUniStream + 4*10\n\t\t\t\t\t\tstr, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t\tExpect(str.StreamID()).To(Equal(id))\n\t\t\t\t\t})\n\n\t\t\t\t\tIt(\"errors when trying to get an outgoing unidirectional stream\", func() {\n\t\t\t\t\t\tid := ids.firstOutgoingUniStream\n\t\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(id)\n\t\t\t\t\t\tExpect(err).To(MatchError(&qerr.TransportError{\n\t\t\t\t\t\t\tErrorCode:    qerr.StreamStateError,\n\t\t\t\t\t\t\tErrorMessage: fmt.Sprintf(\"peer attempted to open receive stream %d\", id),\n\t\t\t\t\t\t}))\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tIt(\"processes the parameter for outgoing streams\", func() {\n\t\t\t\t_, err := m.OpenStream()\n\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\tm.UpdateLimits(&wire.TransportParameters{\n\t\t\t\t\tMaxBidiStreamNum: 5,\n\t\t\t\t\tMaxUniStreamNum:  8,\n\t\t\t\t})\n\n\t\t\t\t// test we can only 5 bidirectional streams\n\t\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\t\tstr, err := m.OpenStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingBidiStream + protocol.StreamID(4*i)))\n\t\t\t\t}\n\t\t\t\t_, err = m.OpenStream()\n\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\t// test we can only 8 unidirectional streams\n\t\t\t\tfor i := 0; i < 8; i++ {\n\t\t\t\t\tstr, err := m.OpenUniStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingUniStream + protocol.StreamID(4*i)))\n\t\t\t\t}\n\t\t\t\t_, err = m.OpenUniStream()\n\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\tExpect(queuedControlFrames).To(HaveLen(3))\n\t\t\t})\n\n\t\t\tif perspective == protocol.PerspectiveClient {\n\t\t\t\tIt(\"applies parameters to existing streams (needed for 0-RTT)\", func() {\n\t\t\t\t\tm.UpdateLimits(&wire.TransportParameters{\n\t\t\t\t\t\tMaxBidiStreamNum: 1000,\n\t\t\t\t\t\tMaxUniStreamNum:  1000,\n\t\t\t\t\t})\n\t\t\t\t\tflowControllers := make(map[protocol.StreamID]*mocks.MockStreamFlowController)\n\t\t\t\t\tm.newFlowController = func(id protocol.StreamID) flowcontrol.StreamFlowController {\n\t\t\t\t\t\tfc := mocks.NewMockStreamFlowController(mockCtrl)\n\t\t\t\t\t\tflowControllers[id] = fc\n\t\t\t\t\t\treturn fc\n\t\t\t\t\t}\n\n\t\t\t\t\tstr, err := m.OpenStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tunistr, err := m.OpenUniStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\t\tExpect(flowControllers).To(HaveKey(str.StreamID()))\n\t\t\t\t\tflowControllers[str.StreamID()].EXPECT().UpdateSendWindow(protocol.ByteCount(4321))\n\t\t\t\t\tExpect(flowControllers).To(HaveKey(unistr.StreamID()))\n\t\t\t\t\tflowControllers[unistr.StreamID()].EXPECT().UpdateSendWindow(protocol.ByteCount(1234))\n\n\t\t\t\t\tm.UpdateLimits(&wire.TransportParameters{\n\t\t\t\t\t\tMaxBidiStreamNum:               1000,\n\t\t\t\t\t\tInitialMaxStreamDataUni:        1234,\n\t\t\t\t\t\tMaxUniStreamNum:                1000,\n\t\t\t\t\t\tInitialMaxStreamDataBidiRemote: 4321,\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tContext(\"handling MAX_STREAMS frames\", func() {\n\t\t\t\tIt(\"processes IDs for outgoing bidirectional streams\", func() {\n\t\t\t\t\t_, err := m.OpenStream()\n\t\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\t\tm.HandleMaxStreamsFrame(&wire.MaxStreamsFrame{\n\t\t\t\t\t\tType:         protocol.StreamTypeBidi,\n\t\t\t\t\t\tMaxStreamNum: 1,\n\t\t\t\t\t})\n\t\t\t\t\tstr, err := m.OpenStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingBidiStream))\n\t\t\t\t\t_, err = m.OpenStream()\n\t\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\t})\n\n\t\t\t\tIt(\"processes IDs for outgoing unidirectional streams\", func() {\n\t\t\t\t\t_, err := m.OpenUniStream()\n\t\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\t\tm.HandleMaxStreamsFrame(&wire.MaxStreamsFrame{\n\t\t\t\t\t\tType:         protocol.StreamTypeUni,\n\t\t\t\t\t\tMaxStreamNum: 1,\n\t\t\t\t\t})\n\t\t\t\t\tstr, err := m.OpenUniStream()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str.StreamID()).To(Equal(ids.firstOutgoingUniStream))\n\t\t\t\t\t_, err = m.OpenUniStream()\n\t\t\t\t\texpectTooManyStreamsError(err)\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tContext(\"sending MAX_STREAMS frames\", func() {\n\t\t\t\tIt(\"sends a MAX_STREAMS frame for bidirectional streams\", func() {\n\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(ids.firstIncomingBidiStream)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t_, err = m.AcceptStream(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(m.DeleteStream(ids.firstIncomingBidiStream)).To(Succeed())\n\t\t\t\t\tExpect(queuedControlFrames).To(Equal([]wire.Frame{\n\t\t\t\t\t\t&wire.MaxStreamsFrame{\n\t\t\t\t\t\t\tType:         protocol.StreamTypeBidi,\n\t\t\t\t\t\t\tMaxStreamNum: MaxBidiStreamNum + 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t}))\n\t\t\t\t})\n\n\t\t\t\tIt(\"sends a MAX_STREAMS frame for unidirectional streams\", func() {\n\t\t\t\t\t_, err := m.GetOrOpenReceiveStream(ids.firstIncomingUniStream)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\t_, err = m.AcceptUniStream(context.Background())\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(m.DeleteStream(ids.firstIncomingUniStream)).To(Succeed())\n\t\t\t\t\tExpect(queuedControlFrames).To(Equal([]wire.Frame{\n\t\t\t\t\t\t&wire.MaxStreamsFrame{\n\t\t\t\t\t\t\tType:         protocol.StreamTypeUni,\n\t\t\t\t\t\t\tMaxStreamNum: MaxUniStreamNum + 1,\n\t\t\t\t\t\t},\n\t\t\t\t\t}))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tIt(\"closes\", func() {\n\t\t\t\ttestErr := errors.New(\"test error\")\n\t\t\t\tm.CloseWithError(testErr)\n\t\t\t\t_, err := m.OpenStream()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err.Error()).To(Equal(testErr.Error()))\n\t\t\t\t_, err = m.OpenUniStream()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err.Error()).To(Equal(testErr.Error()))\n\t\t\t\t_, err = m.AcceptStream(context.Background())\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err.Error()).To(Equal(testErr.Error()))\n\t\t\t\t_, err = m.AcceptUniStream(context.Background())\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err.Error()).To(Equal(testErr.Error()))\n\t\t\t})\n\n\t\t\tif perspective == protocol.PerspectiveClient {\n\t\t\t\tIt(\"resets for 0-RTT\", func() {\n\t\t\t\t\tm.ResetFor0RTT()\n\t\t\t\t\t// make sure that calls to open / accept streams fail\n\t\t\t\t\t_, err := m.OpenStream()\n\t\t\t\t\tExpect(err).To(MatchError(Err0RTTRejected))\n\t\t\t\t\t_, err = m.AcceptStream(context.Background())\n\t\t\t\t\tExpect(err).To(MatchError(Err0RTTRejected))\n\t\t\t\t\t// make sure that we can still get new streams, as the server might be sending us data\n\t\t\t\t\tstr, err := m.GetOrOpenReceiveStream(3)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(str).ToNot(BeNil())\n\n\t\t\t\t\t// now switch to using the new streams map\n\t\t\t\t\tm.UseResetMaps()\n\t\t\t\t\t_, err = m.OpenStream()\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t\tExpect(err.Error()).To(ContainSubstring(\"too many open streams\"))\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n})\n"
        },
        {
          "name": "sys_conn.go",
          "type": "blob",
          "size": 3.4404296875,
          "content": "package quic\n\nimport (\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\n// OOBCapablePacketConn is a connection that allows the reading of ECN bits from the IP header.\n// If the PacketConn passed to Dial or Listen satisfies this interface, quic-go will use it.\n// In this case, ReadMsgUDP() will be used instead of ReadFrom() to read packets.\ntype OOBCapablePacketConn interface {\n\tnet.PacketConn\n\tSyscallConn() (syscall.RawConn, error)\n\tSetReadBuffer(int) error\n\tReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *net.UDPAddr, err error)\n\tWriteMsgUDP(b, oob []byte, addr *net.UDPAddr) (n, oobn int, err error)\n}\n\nvar _ OOBCapablePacketConn = &net.UDPConn{}\n\nfunc wrapConn(pc net.PacketConn) (rawConn, error) {\n\tif err := setReceiveBuffer(pc); err != nil {\n\t\tif !strings.Contains(err.Error(), \"use of closed network connection\") {\n\t\t\tsetBufferWarningOnce.Do(func() {\n\t\t\t\tif disable, _ := strconv.ParseBool(os.Getenv(\"QUIC_GO_DISABLE_RECEIVE_BUFFER_WARNING\")); disable {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Printf(\"%s. See https://github.com/quic-go/quic-go/wiki/UDP-Buffer-Sizes for details.\", err)\n\t\t\t})\n\t\t}\n\t}\n\tif err := setSendBuffer(pc); err != nil {\n\t\tif !strings.Contains(err.Error(), \"use of closed network connection\") {\n\t\t\tsetBufferWarningOnce.Do(func() {\n\t\t\t\tif disable, _ := strconv.ParseBool(os.Getenv(\"QUIC_GO_DISABLE_RECEIVE_BUFFER_WARNING\")); disable {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Printf(\"%s. See https://github.com/quic-go/quic-go/wiki/UDP-Buffer-Sizes for details.\", err)\n\t\t\t})\n\t\t}\n\t}\n\n\tconn, ok := pc.(interface {\n\t\tSyscallConn() (syscall.RawConn, error)\n\t})\n\tvar supportsDF bool\n\tif ok {\n\t\trawConn, err := conn.SyscallConn()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// only set DF on UDP sockets\n\t\tif _, ok := pc.LocalAddr().(*net.UDPAddr); ok {\n\t\t\tvar err error\n\t\t\tsupportsDF, err = setDF(rawConn)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\tc, ok := pc.(OOBCapablePacketConn)\n\tif !ok {\n\t\tutils.DefaultLogger.Infof(\"PacketConn is not a net.UDPConn. Disabling optimizations possible on UDP connections.\")\n\t\treturn &basicConn{PacketConn: pc, supportsDF: supportsDF}, nil\n\t}\n\treturn newConn(c, supportsDF)\n}\n\n// The basicConn is the most trivial implementation of a rawConn.\n// It reads a single packet from the underlying net.PacketConn.\n// It is used when\n// * the net.PacketConn is not a OOBCapablePacketConn, and\n// * when the OS doesn't support OOB.\ntype basicConn struct {\n\tnet.PacketConn\n\tsupportsDF bool\n}\n\nvar _ rawConn = &basicConn{}\n\nfunc (c *basicConn) ReadPacket() (receivedPacket, error) {\n\tbuffer := getPacketBuffer()\n\t// The packet size should not exceed protocol.MaxPacketBufferSize bytes\n\t// If it does, we only read a truncated packet, which will then end up undecryptable\n\tbuffer.Data = buffer.Data[:protocol.MaxPacketBufferSize]\n\tn, addr, err := c.PacketConn.ReadFrom(buffer.Data)\n\tif err != nil {\n\t\treturn receivedPacket{}, err\n\t}\n\treturn receivedPacket{\n\t\tremoteAddr: addr,\n\t\trcvTime:    time.Now(),\n\t\tdata:       buffer.Data[:n],\n\t\tbuffer:     buffer,\n\t}, nil\n}\n\nfunc (c *basicConn) WritePacket(b []byte, addr net.Addr, _ []byte, gsoSize uint16, ecn protocol.ECN) (n int, err error) {\n\tif gsoSize != 0 {\n\t\tpanic(\"cannot use GSO with a basicConn\")\n\t}\n\tif ecn != protocol.ECNUnsupported {\n\t\tpanic(\"cannot use ECN with a basicConn\")\n\t}\n\treturn c.PacketConn.WriteTo(b, addr)\n}\n\nfunc (c *basicConn) capabilities() connCapabilities { return connCapabilities{DF: c.supportsDF} }\n"
        },
        {
          "name": "sys_conn_buffers.go",
          "type": "blob",
          "size": 2.8916015625,
          "content": "package quic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\n//go:generate sh -c \"echo '// Code generated by go generate. DO NOT EDIT.\\n// Source: sys_conn_buffers.go\\n' > sys_conn_buffers_write.go && sed -e 's/SetReadBuffer/SetWriteBuffer/g' -e 's/setReceiveBuffer/setSendBuffer/g' -e 's/inspectReadBuffer/inspectWriteBuffer/g' -e 's/protocol\\\\.DesiredReceiveBufferSize/protocol\\\\.DesiredSendBufferSize/g' -e 's/forceSetReceiveBuffer/forceSetSendBuffer/g' -e 's/receive buffer/send buffer/g' sys_conn_buffers.go | sed '/^\\\\/\\\\/go:generate/d' >> sys_conn_buffers_write.go\"\nfunc setReceiveBuffer(c net.PacketConn) error {\n\tconn, ok := c.(interface{ SetReadBuffer(int) error })\n\tif !ok {\n\t\treturn errors.New(\"connection doesn't allow setting of receive buffer size. Not a *net.UDPConn?\")\n\t}\n\n\tvar syscallConn syscall.RawConn\n\tif sc, ok := c.(interface {\n\t\tSyscallConn() (syscall.RawConn, error)\n\t}); ok {\n\t\tvar err error\n\t\tsyscallConn, err = sc.SyscallConn()\n\t\tif err != nil {\n\t\t\tsyscallConn = nil\n\t\t}\n\t}\n\t// The connection has a SetReadBuffer method, but we couldn't obtain a syscall.RawConn.\n\t// This shouldn't happen for a net.UDPConn, but is possible if the connection just implements the\n\t// net.PacketConn interface and the SetReadBuffer method.\n\t// We have no way of checking if increasing the buffer size actually worked.\n\tif syscallConn == nil {\n\t\treturn conn.SetReadBuffer(protocol.DesiredReceiveBufferSize)\n\t}\n\n\tsize, err := inspectReadBuffer(syscallConn)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to determine receive buffer size: %w\", err)\n\t}\n\tif size >= protocol.DesiredReceiveBufferSize {\n\t\tutils.DefaultLogger.Debugf(\"Conn has receive buffer of %d kiB (wanted: at least %d kiB)\", size/1024, protocol.DesiredReceiveBufferSize/1024)\n\t\treturn nil\n\t}\n\t// Ignore the error. We check if we succeeded by querying the buffer size afterward.\n\t_ = conn.SetReadBuffer(protocol.DesiredReceiveBufferSize)\n\tnewSize, err := inspectReadBuffer(syscallConn)\n\tif newSize < protocol.DesiredReceiveBufferSize {\n\t\t// Try again with RCVBUFFORCE on Linux\n\t\t_ = forceSetReceiveBuffer(syscallConn, protocol.DesiredReceiveBufferSize)\n\t\tnewSize, err = inspectReadBuffer(syscallConn)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to determine receive buffer size: %w\", err)\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to determine receive buffer size: %w\", err)\n\t}\n\tif newSize == size {\n\t\treturn fmt.Errorf(\"failed to increase receive buffer size (wanted: %d kiB, got %d kiB)\", protocol.DesiredReceiveBufferSize/1024, newSize/1024)\n\t}\n\tif newSize < protocol.DesiredReceiveBufferSize {\n\t\treturn fmt.Errorf(\"failed to sufficiently increase receive buffer size (was: %d kiB, wanted: %d kiB, got: %d kiB)\", size/1024, protocol.DesiredReceiveBufferSize/1024, newSize/1024)\n\t}\n\tutils.DefaultLogger.Debugf(\"Increased receive buffer size to %d kiB\", newSize/1024)\n\treturn nil\n}\n"
        },
        {
          "name": "sys_conn_buffers_write.go",
          "type": "blob",
          "size": 2.4208984375,
          "content": "// Code generated by go generate. DO NOT EDIT.\n// Source: sys_conn_buffers.go\n\npackage quic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\nfunc setSendBuffer(c net.PacketConn) error {\n\tconn, ok := c.(interface{ SetWriteBuffer(int) error })\n\tif !ok {\n\t\treturn errors.New(\"connection doesn't allow setting of send buffer size. Not a *net.UDPConn?\")\n\t}\n\n\tvar syscallConn syscall.RawConn\n\tif sc, ok := c.(interface {\n\t\tSyscallConn() (syscall.RawConn, error)\n\t}); ok {\n\t\tvar err error\n\t\tsyscallConn, err = sc.SyscallConn()\n\t\tif err != nil {\n\t\t\tsyscallConn = nil\n\t\t}\n\t}\n\t// The connection has a SetWriteBuffer method, but we couldn't obtain a syscall.RawConn.\n\t// This shouldn't happen for a net.UDPConn, but is possible if the connection just implements the\n\t// net.PacketConn interface and the SetWriteBuffer method.\n\t// We have no way of checking if increasing the buffer size actually worked.\n\tif syscallConn == nil {\n\t\treturn conn.SetWriteBuffer(protocol.DesiredSendBufferSize)\n\t}\n\n\tsize, err := inspectWriteBuffer(syscallConn)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to determine send buffer size: %w\", err)\n\t}\n\tif size >= protocol.DesiredSendBufferSize {\n\t\tutils.DefaultLogger.Debugf(\"Conn has send buffer of %d kiB (wanted: at least %d kiB)\", size/1024, protocol.DesiredSendBufferSize/1024)\n\t\treturn nil\n\t}\n\t// Ignore the error. We check if we succeeded by querying the buffer size afterward.\n\t_ = conn.SetWriteBuffer(protocol.DesiredSendBufferSize)\n\tnewSize, err := inspectWriteBuffer(syscallConn)\n\tif newSize < protocol.DesiredSendBufferSize {\n\t\t// Try again with RCVBUFFORCE on Linux\n\t\t_ = forceSetSendBuffer(syscallConn, protocol.DesiredSendBufferSize)\n\t\tnewSize, err = inspectWriteBuffer(syscallConn)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to determine send buffer size: %w\", err)\n\t\t}\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to determine send buffer size: %w\", err)\n\t}\n\tif newSize == size {\n\t\treturn fmt.Errorf(\"failed to increase send buffer size (wanted: %d kiB, got %d kiB)\", protocol.DesiredSendBufferSize/1024, newSize/1024)\n\t}\n\tif newSize < protocol.DesiredSendBufferSize {\n\t\treturn fmt.Errorf(\"failed to sufficiently increase send buffer size (was: %d kiB, wanted: %d kiB, got: %d kiB)\", size/1024, protocol.DesiredSendBufferSize/1024, newSize/1024)\n\t}\n\tutils.DefaultLogger.Debugf(\"Increased send buffer size to %d kiB\", newSize/1024)\n\treturn nil\n}\n"
        },
        {
          "name": "sys_conn_df.go",
          "type": "blob",
          "size": 0.3837890625,
          "content": "//go:build !linux && !windows && !darwin\n\npackage quic\n\nimport (\n\t\"syscall\"\n)\n\nfunc setDF(syscall.RawConn) (bool, error) {\n\t// no-op on unsupported platforms\n\treturn false, nil\n}\n\nfunc isSendMsgSizeErr(err error) bool {\n\t// to be implemented for more specific platforms\n\treturn false\n}\n\nfunc isRecvMsgSizeErr(err error) bool {\n\t// to be implemented for more specific platforms\n\treturn false\n}\n"
        },
        {
          "name": "sys_conn_df_darwin.go",
          "type": "blob",
          "size": 2.37109375,
          "content": "//go:build darwin\n\npackage quic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// for macOS versions, see https://en.wikipedia.org/wiki/Darwin_(operating_system)#Darwin_20_onwards\nconst (\n\tmacOSVersion11 = 20\n\tmacOSVersion15 = 24\n)\n\nfunc setDF(rawConn syscall.RawConn) (bool, error) {\n\t// Setting DF bit is only supported from macOS 11.\n\t// https://github.com/chromium/chromium/blob/117.0.5881.2/net/socket/udp_socket_posix.cc#L555\n\tversion, err := getMacOSVersion()\n\tif err != nil || version < macOSVersion11 {\n\t\treturn false, err\n\t}\n\n\tvar controlErr error\n\tvar disableDF bool\n\tif err := rawConn.Control(func(fd uintptr) {\n\t\taddr, err := unix.Getsockname(int(fd))\n\t\tif err != nil {\n\t\t\tcontrolErr = fmt.Errorf(\"getsockname: %w\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Dual-stack sockets are effectively IPv6 sockets (with IPV6_ONLY set to 0).\n\t\t// On macOS, the DF bit on dual-stack sockets is controlled by the IPV6_DONTFRAG option.\n\t\t// See https://datatracker.ietf.org/doc/draft-seemann-tsvwg-udp-fragmentation/ for details.\n\t\tswitch addr.(type) {\n\t\tcase *unix.SockaddrInet4:\n\t\t\tcontrolErr = unix.SetsockoptInt(int(fd), unix.IPPROTO_IP, unix.IP_DONTFRAG, 1)\n\t\tcase *unix.SockaddrInet6:\n\t\t\tcontrolErr = unix.SetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_DONTFRAG, 1)\n\n\t\t\t// Setting the DF bit on dual-stack sockets works since macOS Sequoia.\n\t\t\t// Disable DF on dual-stack sockets before Sequoia.\n\t\t\tif version < macOSVersion15 {\n\t\t\t\t// check if this is a dual-stack socket by reading the IPV6_V6ONLY flag\n\t\t\t\tv6only, err := unix.GetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_V6ONLY)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontrolErr = fmt.Errorf(\"getting IPV6_V6ONLY: %w\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tdisableDF = v6only == 0\n\t\t\t}\n\t\tdefault:\n\t\t\tcontrolErr = fmt.Errorf(\"unknown address type: %T\", addr)\n\t\t}\n\t}); err != nil {\n\t\treturn false, err\n\t}\n\tif controlErr != nil {\n\t\treturn false, controlErr\n\t}\n\treturn !disableDF, nil\n}\n\nfunc isSendMsgSizeErr(err error) bool {\n\treturn errors.Is(err, unix.EMSGSIZE)\n}\n\nfunc isRecvMsgSizeErr(error) bool { return false }\n\nfunc getMacOSVersion() (int, error) {\n\tuname := &unix.Utsname{}\n\tif err := unix.Uname(uname); err != nil {\n\t\treturn 0, err\n\t}\n\n\trelease := string(uname.Release[:])\n\tidx := strings.Index(release, \".\")\n\tif idx == -1 {\n\t\treturn 0, nil\n\t}\n\tversion, err := strconv.Atoi(release[:idx])\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn version, nil\n}\n"
        },
        {
          "name": "sys_conn_df_darwin_test.go",
          "type": "blob",
          "size": 2.5185546875,
          "content": "package quic\n\nimport (\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIPFragmentation(t *testing.T) {\n\tsink, err := net.ListenUDP(\"udp\", &net.UDPAddr{Port: 0})\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { sink.Close() })\n\tsinkPort := sink.LocalAddr().(*net.UDPAddr).Port\n\n\tcanSendIPv4 := func(conn *net.UDPConn) bool {\n\t\t_, err := conn.WriteTo([]byte(\"hello\"), &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: sinkPort})\n\t\treturn err == nil\n\t}\n\n\tcanSendIPv6 := func(conn *net.UDPConn) bool {\n\t\t_, err := conn.WriteTo([]byte(\"hello\"), &net.UDPAddr{IP: net.IPv6loopback, Port: sinkPort})\n\t\treturn err == nil\n\t}\n\n\tt.Run(\"udp4\", func(t *testing.T) {\n\t\tconn, err := net.ListenUDP(\"udp4\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0})\n\t\trequire.NoError(t, err)\n\t\tdefer conn.Close()\n\n\t\trequire.True(t, canSendIPv4(conn))\n\t\trequire.False(t, canSendIPv6(conn))\n\n\t\traw, err := conn.SyscallConn()\n\t\trequire.NoError(t, err)\n\t\tcanDF, _ := setDF(raw)\n\t\trequire.True(t, canDF)\n\t})\n\n\tt.Run(\"udp6\", func(t *testing.T) {\n\t\tconn, err := net.ListenUDP(\"udp6\", &net.UDPAddr{IP: net.IPv6loopback, Port: 0})\n\t\trequire.NoError(t, err)\n\t\tdefer conn.Close()\n\n\t\trequire.False(t, canSendIPv4(conn))\n\t\trequire.True(t, canSendIPv6(conn))\n\n\t\traw, err := conn.SyscallConn()\n\t\trequire.NoError(t, err)\n\t\tcanDF, _ := setDF(raw)\n\t\trequire.True(t, canDF)\n\t})\n\n\tt.Run(\"udp, dual-stack\", func(t *testing.T) {\n\t\tif version, err := getMacOSVersion(); err != nil || version < macOSVersion15 {\n\t\t\tt.Skipf(\"skipping on darwin %d\", version-9)\n\t\t}\n\n\t\tconn, err := net.ListenUDP(\"udp\", &net.UDPAddr{Port: 0})\n\t\trequire.NoError(t, err)\n\t\tdefer conn.Close()\n\n\t\trequire.True(t, canSendIPv4(conn))\n\t\trequire.True(t, canSendIPv6(conn))\n\n\t\traw, err := conn.SyscallConn()\n\t\trequire.NoError(t, err)\n\t\tcanDF, _ := setDF(raw)\n\t\trequire.True(t, canDF)\n\t})\n\n\tt.Run(\"udp, listening on IPv4\", func(t *testing.T) {\n\t\tconn, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0})\n\t\trequire.NoError(t, err)\n\t\tdefer conn.Close()\n\n\t\trequire.True(t, canSendIPv4(conn))\n\t\trequire.False(t, canSendIPv6(conn))\n\n\t\traw, err := conn.SyscallConn()\n\t\trequire.NoError(t, err)\n\t\tcanDF, _ := setDF(raw)\n\t\trequire.True(t, canDF)\n\t})\n\n\tt.Run(\"udp, listening on IPv6\", func(t *testing.T) {\n\t\tconn, err := net.ListenUDP(\"udp6\", &net.UDPAddr{IP: net.IPv6loopback, Port: 0})\n\t\trequire.NoError(t, err)\n\t\tdefer conn.Close()\n\n\t\trequire.False(t, canSendIPv4(conn))\n\t\trequire.True(t, canSendIPv6(conn))\n\n\t\traw, err := conn.SyscallConn()\n\t\trequire.NoError(t, err)\n\t\tcanDF, _ := setDF(raw)\n\t\trequire.True(t, canDF)\n\t})\n}\n"
        },
        {
          "name": "sys_conn_df_linux.go",
          "type": "blob",
          "size": 1.259765625,
          "content": "//go:build linux\n\npackage quic\n\nimport (\n\t\"errors\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\nfunc setDF(rawConn syscall.RawConn) (bool, error) {\n\t// Enabling IP_MTU_DISCOVER will force the kernel to return \"sendto: message too long\"\n\t// and the datagram will not be fragmented\n\tvar errDFIPv4, errDFIPv6 error\n\tif err := rawConn.Control(func(fd uintptr) {\n\t\terrDFIPv4 = unix.SetsockoptInt(int(fd), unix.IPPROTO_IP, unix.IP_MTU_DISCOVER, unix.IP_PMTUDISC_PROBE)\n\t\terrDFIPv6 = unix.SetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_MTU_DISCOVER, unix.IPV6_PMTUDISC_PROBE)\n\t}); err != nil {\n\t\treturn false, err\n\t}\n\tswitch {\n\tcase errDFIPv4 == nil && errDFIPv6 == nil:\n\t\tutils.DefaultLogger.Debugf(\"Setting DF for IPv4 and IPv6.\")\n\tcase errDFIPv4 == nil && errDFIPv6 != nil:\n\t\tutils.DefaultLogger.Debugf(\"Setting DF for IPv4.\")\n\tcase errDFIPv4 != nil && errDFIPv6 == nil:\n\t\tutils.DefaultLogger.Debugf(\"Setting DF for IPv6.\")\n\tcase errDFIPv4 != nil && errDFIPv6 != nil:\n\t\treturn false, errors.New(\"setting DF failed for both IPv4 and IPv6\")\n\t}\n\treturn true, nil\n}\n\nfunc isSendMsgSizeErr(err error) bool {\n\t// https://man7.org/linux/man-pages/man7/udp.7.html\n\treturn errors.Is(err, unix.EMSGSIZE)\n}\n\nfunc isRecvMsgSizeErr(error) bool { return false }\n"
        },
        {
          "name": "sys_conn_df_windows.go",
          "type": "blob",
          "size": 1.58984375,
          "content": "//go:build windows\n\npackage quic\n\nimport (\n\t\"errors\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\nconst (\n\t// https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/Networking/WinSock/constant.IP_DONTFRAGMENT.html\n\t//nolint:stylecheck\n\tIP_DONTFRAGMENT = 14\n\t// https://microsoft.github.io/windows-docs-rs/doc/windows/Win32/Networking/WinSock/constant.IPV6_DONTFRAG.html\n\t//nolint:stylecheck\n\tIPV6_DONTFRAG = 14\n)\n\nfunc setDF(rawConn syscall.RawConn) (bool, error) {\n\tvar errDFIPv4, errDFIPv6 error\n\tif err := rawConn.Control(func(fd uintptr) {\n\t\terrDFIPv4 = windows.SetsockoptInt(windows.Handle(fd), windows.IPPROTO_IP, IP_DONTFRAGMENT, 1)\n\t\terrDFIPv6 = windows.SetsockoptInt(windows.Handle(fd), windows.IPPROTO_IPV6, IPV6_DONTFRAG, 1)\n\t}); err != nil {\n\t\treturn false, err\n\t}\n\tswitch {\n\tcase errDFIPv4 == nil && errDFIPv6 == nil:\n\t\tutils.DefaultLogger.Debugf(\"Setting DF for IPv4 and IPv6.\")\n\tcase errDFIPv4 == nil && errDFIPv6 != nil:\n\t\tutils.DefaultLogger.Debugf(\"Setting DF for IPv4.\")\n\tcase errDFIPv4 != nil && errDFIPv6 == nil:\n\t\tutils.DefaultLogger.Debugf(\"Setting DF for IPv6.\")\n\tcase errDFIPv4 != nil && errDFIPv6 != nil:\n\t\treturn false, errors.New(\"setting DF failed for both IPv4 and IPv6\")\n\t}\n\treturn true, nil\n}\n\nfunc isSendMsgSizeErr(err error) bool {\n\t// https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2\n\treturn errors.Is(err, windows.WSAEMSGSIZE)\n}\n\nfunc isRecvMsgSizeErr(err error) bool {\n\t// https://docs.microsoft.com/en-us/windows/win32/winsock/windows-sockets-error-codes-2\n\treturn errors.Is(err, windows.WSAEMSGSIZE)\n}\n"
        },
        {
          "name": "sys_conn_helper_darwin.go",
          "type": "blob",
          "size": 0.8916015625,
          "content": "//go:build darwin\n\npackage quic\n\nimport (\n\t\"encoding/binary\"\n\t\"net/netip\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tmsgTypeIPTOS = unix.IP_RECVTOS\n\tipv4PKTINFO  = unix.IP_RECVPKTINFO\n)\n\nconst ecnIPv4DataLen = 4\n\n// ReadBatch only returns a single packet on OSX,\n// see https://godoc.org/golang.org/x/net/ipv4#PacketConn.ReadBatch.\nconst batchSize = 1\n\nfunc parseIPv4PktInfo(body []byte) (ip netip.Addr, ifIndex uint32, ok bool) {\n\t// struct in_pktinfo {\n\t// \tunsigned int   ipi_ifindex;  /* Interface index */\n\t// \tstruct in_addr ipi_spec_dst; /* Local address */\n\t// \tstruct in_addr ipi_addr;     /* Header Destination address */\n\t// };\n\tif len(body) != 12 {\n\t\treturn netip.Addr{}, 0, false\n\t}\n\treturn netip.AddrFrom4(*(*[4]byte)(body[8:12])), binary.LittleEndian.Uint32(body), true\n}\n\nfunc isGSOEnabled(syscall.RawConn) bool { return false }\n\nfunc isECNEnabled() bool { return !isECNDisabledUsingEnv() }\n"
        },
        {
          "name": "sys_conn_helper_freebsd.go",
          "type": "blob",
          "size": 0.591796875,
          "content": "//go:build freebsd\n\npackage quic\n\nimport (\n\t\"net/netip\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tmsgTypeIPTOS = unix.IP_RECVTOS\n\tipv4PKTINFO  = 0x7\n)\n\nconst ecnIPv4DataLen = 1\n\nconst batchSize = 8\n\nfunc parseIPv4PktInfo(body []byte) (ip netip.Addr, _ uint32, ok bool) {\n\t// struct in_pktinfo {\n\t// \tstruct in_addr ipi_addr;     /* Header Destination address */\n\t// };\n\tif len(body) != 4 {\n\t\treturn netip.Addr{}, 0, false\n\t}\n\treturn netip.AddrFrom4(*(*[4]byte)(body)), 0, true\n}\n\nfunc isGSOEnabled(syscall.RawConn) bool { return false }\n\nfunc isECNEnabled() bool { return !isECNDisabledUsingEnv() }\n"
        },
        {
          "name": "sys_conn_helper_linux.go",
          "type": "blob",
          "size": 4.1181640625,
          "content": "//go:build linux\n\npackage quic\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"net/netip\"\n\t\"os\"\n\t\"strconv\"\n\t\"syscall\"\n\t\"unsafe\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nconst (\n\tmsgTypeIPTOS = unix.IP_TOS\n\tipv4PKTINFO  = unix.IP_PKTINFO\n)\n\nconst ecnIPv4DataLen = 1\n\nconst batchSize = 8 // needs to smaller than MaxUint8 (otherwise the type of oobConn.readPos has to be changed)\n\nvar kernelVersionMajor int\n\nfunc init() {\n\tkernelVersionMajor, _ = kernelVersion()\n}\n\nfunc forceSetReceiveBuffer(c syscall.RawConn, bytes int) error {\n\tvar serr error\n\tif err := c.Control(func(fd uintptr) {\n\t\tserr = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_RCVBUFFORCE, bytes)\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn serr\n}\n\nfunc forceSetSendBuffer(c syscall.RawConn, bytes int) error {\n\tvar serr error\n\tif err := c.Control(func(fd uintptr) {\n\t\tserr = unix.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_SNDBUFFORCE, bytes)\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn serr\n}\n\nfunc parseIPv4PktInfo(body []byte) (ip netip.Addr, ifIndex uint32, ok bool) {\n\t// struct in_pktinfo {\n\t// \tunsigned int   ipi_ifindex;  /* Interface index */\n\t// \tstruct in_addr ipi_spec_dst; /* Local address */\n\t// \tstruct in_addr ipi_addr;     /* Header Destination address */\n\t// };\n\tif len(body) != 12 {\n\t\treturn netip.Addr{}, 0, false\n\t}\n\treturn netip.AddrFrom4(*(*[4]byte)(body[8:12])), binary.LittleEndian.Uint32(body), true\n}\n\n// isGSOEnabled tests if the kernel supports GSO.\n// Sending with GSO might still fail later on, if the interface doesn't support it (see isGSOError).\nfunc isGSOEnabled(conn syscall.RawConn) bool {\n\tif kernelVersionMajor < 5 {\n\t\treturn false\n\t}\n\tdisabled, err := strconv.ParseBool(os.Getenv(\"QUIC_GO_DISABLE_GSO\"))\n\tif err == nil && disabled {\n\t\treturn false\n\t}\n\tvar serr error\n\tif err := conn.Control(func(fd uintptr) {\n\t\t_, serr = unix.GetsockoptInt(int(fd), unix.IPPROTO_UDP, unix.UDP_SEGMENT)\n\t}); err != nil {\n\t\treturn false\n\t}\n\treturn serr == nil\n}\n\nfunc appendUDPSegmentSizeMsg(b []byte, size uint16) []byte {\n\tstartLen := len(b)\n\tconst dataLen = 2 // payload is a uint16\n\tb = append(b, make([]byte, unix.CmsgSpace(dataLen))...)\n\th := (*unix.Cmsghdr)(unsafe.Pointer(&b[startLen]))\n\th.Level = syscall.IPPROTO_UDP\n\th.Type = unix.UDP_SEGMENT\n\th.SetLen(unix.CmsgLen(dataLen))\n\n\t// UnixRights uses the private `data` method, but I *think* this achieves the same goal.\n\toffset := startLen + unix.CmsgSpace(0)\n\t*(*uint16)(unsafe.Pointer(&b[offset])) = size\n\treturn b\n}\n\nfunc isGSOError(err error) bool {\n\tvar serr *os.SyscallError\n\tif errors.As(err, &serr) {\n\t\t// EIO is returned by udp_send_skb() if the device driver does not have tx checksums enabled,\n\t\t// which is a hard requirement of UDP_SEGMENT. See:\n\t\t// https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/man7/udp.7?id=806eabd74910447f21005160e90957bde4db0183#n228\n\t\t// https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/ipv4/udp.c?h=v6.2&id=c9c3395d5e3dcc6daee66c6908354d47bf98cb0c#n942\n\t\treturn serr.Err == unix.EIO\n\t}\n\treturn false\n}\n\n// The first sendmsg call on a new UDP socket sometimes errors on Linux.\n// It's not clear why this happens.\n// See https://github.com/golang/go/issues/63322.\nfunc isPermissionError(err error) bool {\n\tvar serr *os.SyscallError\n\tif errors.As(err, &serr) {\n\t\treturn serr.Syscall == \"sendmsg\" && serr.Err == unix.EPERM\n\t}\n\treturn false\n}\n\nfunc isECNEnabled() bool {\n\treturn kernelVersionMajor >= 5 && !isECNDisabledUsingEnv()\n}\n\n// kernelVersion returns major and minor kernel version numbers, parsed from\n// the syscall.Uname's Release field, or 0, 0 if the version can't be obtained\n// or parsed.\n//\n// copied from the standard library's internal/syscall/unix/kernel_version_linux.go\nfunc kernelVersion() (major, minor int) {\n\tvar uname syscall.Utsname\n\tif err := syscall.Uname(&uname); err != nil {\n\t\treturn\n\t}\n\n\tvar (\n\t\tvalues    [2]int\n\t\tvalue, vi int\n\t)\n\tfor _, c := range uname.Release {\n\t\tif '0' <= c && c <= '9' {\n\t\t\tvalue = (value * 10) + int(c-'0')\n\t\t} else {\n\t\t\t// Note that we're assuming N.N.N here.\n\t\t\t// If we see anything else, we are likely to mis-parse it.\n\t\t\tvalues[vi] = value\n\t\t\tvi++\n\t\t\tif vi >= len(values) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tvalue = 0\n\t\t}\n\t}\n\n\treturn values[0], values[1]\n}\n"
        },
        {
          "name": "sys_conn_helper_linux_test.go",
          "type": "blob",
          "size": 2.1103515625,
          "content": "//go:build linux\n\npackage quic\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"os\"\n\t\"testing\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\terrGSO          = &os.SyscallError{Err: unix.EIO}\n\terrNotPermitted = &os.SyscallError{Syscall: \"sendmsg\", Err: unix.EPERM}\n)\n\nfunc TestForcingReceiveBufferSize(t *testing.T) {\n\tif os.Getuid() != 0 {\n\t\tt.Skip(\"Must be root to force change the receive buffer size\")\n\t}\n\n\tc, err := net.ListenPacket(\"udp\", \"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\tsyscallConn, err := c.(*net.UDPConn).SyscallConn()\n\trequire.NoError(t, err)\n\n\tconst small = 256 << 10 // 256 KB\n\trequire.NoError(t, forceSetReceiveBuffer(syscallConn, small))\n\n\tsize, err := inspectReadBuffer(syscallConn)\n\trequire.NoError(t, err)\n\t// the kernel doubles this value (to allow space for bookkeeping overhead)\n\trequire.Equal(t, 2*small, size)\n\n\tconst large = 32 << 20 // 32 MB\n\trequire.NoError(t, forceSetReceiveBuffer(syscallConn, large))\n\tsize, err = inspectReadBuffer(syscallConn)\n\trequire.NoError(t, err)\n\t// the kernel doubles this value (to allow space for bookkeeping overhead)\n\trequire.Equal(t, 2*large, size)\n}\n\nfunc TestForcingSendBufferSize(t *testing.T) {\n\tif os.Getuid() != 0 {\n\t\tt.Skip(\"Must be root to force change the send buffer size\")\n\t}\n\n\tc, err := net.ListenPacket(\"udp\", \"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\tsyscallConn, err := c.(*net.UDPConn).SyscallConn()\n\trequire.NoError(t, err)\n\n\tconst small = 256 << 10 // 256 KB\n\trequire.NoError(t, forceSetSendBuffer(syscallConn, small))\n\n\tsize, err := inspectWriteBuffer(syscallConn)\n\trequire.NoError(t, err)\n\t// the kernel doubles this value (to allow space for bookkeeping overhead)\n\trequire.Equal(t, 2*small, size)\n\n\tconst large = 32 << 20 // 32 MB\n\trequire.NoError(t, forceSetSendBuffer(syscallConn, large))\n\tsize, err = inspectWriteBuffer(syscallConn)\n\trequire.NoError(t, err)\n\t// the kernel doubles this value (to allow space for bookkeeping overhead)\n\trequire.Equal(t, 2*large, size)\n}\n\nfunc TestGSOError(t *testing.T) {\n\trequire.True(t, isGSOError(errGSO))\n\trequire.False(t, isGSOError(nil))\n\trequire.False(t, isGSOError(errors.New(\"test\")))\n}\n"
        },
        {
          "name": "sys_conn_helper_nonlinux.go",
          "type": "blob",
          "size": 0.3623046875,
          "content": "//go:build !linux\n\npackage quic\n\nfunc forceSetReceiveBuffer(c any, bytes int) error { return nil }\nfunc forceSetSendBuffer(c any, bytes int) error    { return nil }\n\nfunc appendUDPSegmentSizeMsg([]byte, uint16) []byte { return nil }\nfunc isGSOError(error) bool                         { return false }\nfunc isPermissionError(err error) bool              { return false }\n"
        },
        {
          "name": "sys_conn_helper_nonlinux_test.go",
          "type": "blob",
          "size": 0.16015625,
          "content": "//go:build !linux\n\npackage quic\n\nimport \"errors\"\n\nvar (\n\terrGSO          = errors.New(\"fake GSO error\")\n\terrNotPermitted = errors.New(\"fake not permitted error\")\n)\n"
        },
        {
          "name": "sys_conn_no_oob.go",
          "type": "blob",
          "size": 0.4404296875,
          "content": "//go:build !darwin && !linux && !freebsd && !windows\n\npackage quic\n\nimport (\n\t\"net\"\n\t\"net/netip\"\n)\n\nfunc newConn(c net.PacketConn, supportsDF bool) (*basicConn, error) {\n\treturn &basicConn{PacketConn: c, supportsDF: supportsDF}, nil\n}\n\nfunc inspectReadBuffer(any) (int, error)  { return 0, nil }\nfunc inspectWriteBuffer(any) (int, error) { return 0, nil }\n\ntype packetInfo struct {\n\taddr netip.Addr\n}\n\nfunc (i *packetInfo) OOB() []byte { return nil }\n"
        },
        {
          "name": "sys_conn_oob.go",
          "type": "blob",
          "size": 9.4267578125,
          "content": "//go:build darwin || linux || freebsd\n\npackage quic\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"log\"\n\t\"net\"\n\t\"net/netip\"\n\t\"os\"\n\t\"strconv\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n\n\t\"golang.org/x/net/ipv4\"\n\t\"golang.org/x/net/ipv6\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n)\n\nconst (\n\tecnMask       = 0x3\n\toobBufferSize = 128\n)\n\n// Contrary to what the naming suggests, the ipv{4,6}.Message is not dependent on the IP version.\n// They're both just aliases for x/net/internal/socket.Message.\n// This means we can use this struct to read from a socket that receives both IPv4 and IPv6 messages.\nvar _ ipv4.Message = ipv6.Message{}\n\ntype batchConn interface {\n\tReadBatch(ms []ipv4.Message, flags int) (int, error)\n}\n\nfunc inspectReadBuffer(c syscall.RawConn) (int, error) {\n\tvar size int\n\tvar serr error\n\tif err := c.Control(func(fd uintptr) {\n\t\tsize, serr = unix.GetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_RCVBUF)\n\t}); err != nil {\n\t\treturn 0, err\n\t}\n\treturn size, serr\n}\n\nfunc inspectWriteBuffer(c syscall.RawConn) (int, error) {\n\tvar size int\n\tvar serr error\n\tif err := c.Control(func(fd uintptr) {\n\t\tsize, serr = unix.GetsockoptInt(int(fd), unix.SOL_SOCKET, unix.SO_SNDBUF)\n\t}); err != nil {\n\t\treturn 0, err\n\t}\n\treturn size, serr\n}\n\nfunc isECNDisabledUsingEnv() bool {\n\tdisabled, err := strconv.ParseBool(os.Getenv(\"QUIC_GO_DISABLE_ECN\"))\n\treturn err == nil && disabled\n}\n\ntype oobConn struct {\n\tOOBCapablePacketConn\n\tbatchConn batchConn\n\n\treadPos uint8\n\t// Packets received from the kernel, but not yet returned by ReadPacket().\n\tmessages []ipv4.Message\n\tbuffers  [batchSize]*packetBuffer\n\n\tcap connCapabilities\n}\n\nvar _ rawConn = &oobConn{}\n\nfunc newConn(c OOBCapablePacketConn, supportsDF bool) (*oobConn, error) {\n\trawConn, err := c.SyscallConn()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar needsPacketInfo bool\n\tif udpAddr, ok := c.LocalAddr().(*net.UDPAddr); ok && udpAddr.IP.IsUnspecified() {\n\t\tneedsPacketInfo = true\n\t}\n\t// We don't know if this a IPv4-only, IPv6-only or a IPv4-and-IPv6 connection.\n\t// Try enabling receiving of ECN and packet info for both IP versions.\n\t// We expect at least one of those syscalls to succeed.\n\tvar errECNIPv4, errECNIPv6, errPIIPv4, errPIIPv6 error\n\tif err := rawConn.Control(func(fd uintptr) {\n\t\terrECNIPv4 = unix.SetsockoptInt(int(fd), unix.IPPROTO_IP, unix.IP_RECVTOS, 1)\n\t\terrECNIPv6 = unix.SetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_RECVTCLASS, 1)\n\n\t\tif needsPacketInfo {\n\t\t\terrPIIPv4 = unix.SetsockoptInt(int(fd), unix.IPPROTO_IP, ipv4PKTINFO, 1)\n\t\t\terrPIIPv6 = unix.SetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_RECVPKTINFO, 1)\n\t\t}\n\t}); err != nil {\n\t\treturn nil, err\n\t}\n\tswitch {\n\tcase errECNIPv4 == nil && errECNIPv6 == nil:\n\t\tutils.DefaultLogger.Debugf(\"Activating reading of ECN bits for IPv4 and IPv6.\")\n\tcase errECNIPv4 == nil && errECNIPv6 != nil:\n\t\tutils.DefaultLogger.Debugf(\"Activating reading of ECN bits for IPv4.\")\n\tcase errECNIPv4 != nil && errECNIPv6 == nil:\n\t\tutils.DefaultLogger.Debugf(\"Activating reading of ECN bits for IPv6.\")\n\tcase errECNIPv4 != nil && errECNIPv6 != nil:\n\t\treturn nil, errors.New(\"activating ECN failed for both IPv4 and IPv6\")\n\t}\n\tif needsPacketInfo {\n\t\tswitch {\n\t\tcase errPIIPv4 == nil && errPIIPv6 == nil:\n\t\t\tutils.DefaultLogger.Debugf(\"Activating reading of packet info for IPv4 and IPv6.\")\n\t\tcase errPIIPv4 == nil && errPIIPv6 != nil:\n\t\t\tutils.DefaultLogger.Debugf(\"Activating reading of packet info bits for IPv4.\")\n\t\tcase errPIIPv4 != nil && errPIIPv6 == nil:\n\t\t\tutils.DefaultLogger.Debugf(\"Activating reading of packet info bits for IPv6.\")\n\t\tcase errPIIPv4 != nil && errPIIPv6 != nil:\n\t\t\treturn nil, errors.New(\"activating packet info failed for both IPv4 and IPv6\")\n\t\t}\n\t}\n\n\t// Allows callers to pass in a connection that already satisfies batchConn interface\n\t// to make use of the optimisation. Otherwise, ipv4.NewPacketConn would unwrap the file descriptor\n\t// via SyscallConn(), and read it that way, which might not be what the caller wants.\n\tvar bc batchConn\n\tif ibc, ok := c.(batchConn); ok {\n\t\tbc = ibc\n\t} else {\n\t\tbc = ipv4.NewPacketConn(c)\n\t}\n\n\tmsgs := make([]ipv4.Message, batchSize)\n\tfor i := range msgs {\n\t\t// preallocate the [][]byte\n\t\tmsgs[i].Buffers = make([][]byte, 1)\n\t}\n\toobConn := &oobConn{\n\t\tOOBCapablePacketConn: c,\n\t\tbatchConn:            bc,\n\t\tmessages:             msgs,\n\t\treadPos:              batchSize,\n\t\tcap: connCapabilities{\n\t\t\tDF:  supportsDF,\n\t\t\tGSO: isGSOEnabled(rawConn),\n\t\t\tECN: isECNEnabled(),\n\t\t},\n\t}\n\tfor i := 0; i < batchSize; i++ {\n\t\toobConn.messages[i].OOB = make([]byte, oobBufferSize)\n\t}\n\treturn oobConn, nil\n}\n\nvar invalidCmsgOnceV4, invalidCmsgOnceV6 sync.Once\n\nfunc (c *oobConn) ReadPacket() (receivedPacket, error) {\n\tif len(c.messages) == int(c.readPos) { // all messages read. Read the next batch of messages.\n\t\tc.messages = c.messages[:batchSize]\n\t\t// replace buffers data buffers up to the packet that has been consumed during the last ReadBatch call\n\t\tfor i := uint8(0); i < c.readPos; i++ {\n\t\t\tbuffer := getPacketBuffer()\n\t\t\tbuffer.Data = buffer.Data[:protocol.MaxPacketBufferSize]\n\t\t\tc.buffers[i] = buffer\n\t\t\tc.messages[i].Buffers[0] = c.buffers[i].Data\n\t\t}\n\t\tc.readPos = 0\n\n\t\tn, err := c.batchConn.ReadBatch(c.messages, 0)\n\t\tif n == 0 || err != nil {\n\t\t\treturn receivedPacket{}, err\n\t\t}\n\t\tc.messages = c.messages[:n]\n\t}\n\n\tmsg := c.messages[c.readPos]\n\tbuffer := c.buffers[c.readPos]\n\tc.readPos++\n\n\tdata := msg.OOB[:msg.NN]\n\tp := receivedPacket{\n\t\tremoteAddr: msg.Addr,\n\t\trcvTime:    time.Now(),\n\t\tdata:       msg.Buffers[0][:msg.N],\n\t\tbuffer:     buffer,\n\t}\n\tfor len(data) > 0 {\n\t\thdr, body, remainder, err := unix.ParseOneSocketControlMessage(data)\n\t\tif err != nil {\n\t\t\treturn receivedPacket{}, err\n\t\t}\n\t\tif hdr.Level == unix.IPPROTO_IP {\n\t\t\tswitch hdr.Type {\n\t\t\tcase msgTypeIPTOS:\n\t\t\t\tp.ecn = protocol.ParseECNHeaderBits(body[0] & ecnMask)\n\t\t\tcase ipv4PKTINFO:\n\t\t\t\tip, ifIndex, ok := parseIPv4PktInfo(body)\n\t\t\t\tif ok {\n\t\t\t\t\tp.info.addr = ip\n\t\t\t\t\tp.info.ifIndex = ifIndex\n\t\t\t\t} else {\n\t\t\t\t\tinvalidCmsgOnceV4.Do(func() {\n\t\t\t\t\t\tlog.Printf(\"Received invalid IPv4 packet info control message: %+x. \"+\n\t\t\t\t\t\t\t\"This should never occur, please open a new issue and include details about the architecture.\", body)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif hdr.Level == unix.IPPROTO_IPV6 {\n\t\t\tswitch hdr.Type {\n\t\t\tcase unix.IPV6_TCLASS:\n\t\t\t\tp.ecn = protocol.ParseECNHeaderBits(body[0] & ecnMask)\n\t\t\tcase unix.IPV6_PKTINFO:\n\t\t\t\t// struct in6_pktinfo {\n\t\t\t\t// \tstruct in6_addr ipi6_addr;    /* src/dst IPv6 address */\n\t\t\t\t// \tunsigned int    ipi6_ifindex; /* send/recv interface index */\n\t\t\t\t// };\n\t\t\t\tif len(body) == 20 {\n\t\t\t\t\tp.info.addr = netip.AddrFrom16(*(*[16]byte)(body[:16])).Unmap()\n\t\t\t\t\tp.info.ifIndex = binary.LittleEndian.Uint32(body[16:])\n\t\t\t\t} else {\n\t\t\t\t\tinvalidCmsgOnceV6.Do(func() {\n\t\t\t\t\t\tlog.Printf(\"Received invalid IPv6 packet info control message: %+x. \"+\n\t\t\t\t\t\t\t\"This should never occur, please open a new issue and include details about the architecture.\", body)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdata = remainder\n\t}\n\treturn p, nil\n}\n\n// WritePacket writes a new packet.\nfunc (c *oobConn) WritePacket(b []byte, addr net.Addr, packetInfoOOB []byte, gsoSize uint16, ecn protocol.ECN) (int, error) {\n\toob := packetInfoOOB\n\tif gsoSize > 0 {\n\t\tif !c.capabilities().GSO {\n\t\t\tpanic(\"GSO disabled\")\n\t\t}\n\t\toob = appendUDPSegmentSizeMsg(oob, gsoSize)\n\t}\n\tif ecn != protocol.ECNUnsupported {\n\t\tif !c.capabilities().ECN {\n\t\t\tpanic(\"tried to send an ECN-marked packet although ECN is disabled\")\n\t\t}\n\t\tif remoteUDPAddr, ok := addr.(*net.UDPAddr); ok {\n\t\t\tif remoteUDPAddr.IP.To4() != nil {\n\t\t\t\toob = appendIPv4ECNMsg(oob, ecn)\n\t\t\t} else {\n\t\t\t\toob = appendIPv6ECNMsg(oob, ecn)\n\t\t\t}\n\t\t}\n\t}\n\tn, _, err := c.OOBCapablePacketConn.WriteMsgUDP(b, oob, addr.(*net.UDPAddr))\n\treturn n, err\n}\n\nfunc (c *oobConn) capabilities() connCapabilities {\n\treturn c.cap\n}\n\ntype packetInfo struct {\n\taddr    netip.Addr\n\tifIndex uint32\n}\n\nfunc (info *packetInfo) OOB() []byte {\n\tif info == nil {\n\t\treturn nil\n\t}\n\tif info.addr.Is4() {\n\t\tip := info.addr.As4()\n\t\t// struct in_pktinfo {\n\t\t// \tunsigned int   ipi_ifindex;  /* Interface index */\n\t\t// \tstruct in_addr ipi_spec_dst; /* Local address */\n\t\t// \tstruct in_addr ipi_addr;     /* Header Destination address */\n\t\t// };\n\t\tcm := ipv4.ControlMessage{\n\t\t\tSrc:     ip[:],\n\t\t\tIfIndex: int(info.ifIndex),\n\t\t}\n\t\treturn cm.Marshal()\n\t} else if info.addr.Is6() {\n\t\tip := info.addr.As16()\n\t\t// struct in6_pktinfo {\n\t\t// \tstruct in6_addr ipi6_addr;    /* src/dst IPv6 address */\n\t\t// \tunsigned int    ipi6_ifindex; /* send/recv interface index */\n\t\t// };\n\t\tcm := ipv6.ControlMessage{\n\t\t\tSrc:     ip[:],\n\t\t\tIfIndex: int(info.ifIndex),\n\t\t}\n\t\treturn cm.Marshal()\n\t}\n\treturn nil\n}\n\nfunc appendIPv4ECNMsg(b []byte, val protocol.ECN) []byte {\n\tstartLen := len(b)\n\tb = append(b, make([]byte, unix.CmsgSpace(ecnIPv4DataLen))...)\n\th := (*unix.Cmsghdr)(unsafe.Pointer(&b[startLen]))\n\th.Level = syscall.IPPROTO_IP\n\th.Type = unix.IP_TOS\n\th.SetLen(unix.CmsgLen(ecnIPv4DataLen))\n\n\t// UnixRights uses the private `data` method, but I *think* this achieves the same goal.\n\toffset := startLen + unix.CmsgSpace(0)\n\tb[offset] = val.ToHeaderBits()\n\treturn b\n}\n\nfunc appendIPv6ECNMsg(b []byte, val protocol.ECN) []byte {\n\tstartLen := len(b)\n\tconst dataLen = 4\n\tb = append(b, make([]byte, unix.CmsgSpace(dataLen))...)\n\th := (*unix.Cmsghdr)(unsafe.Pointer(&b[startLen]))\n\th.Level = syscall.IPPROTO_IPV6\n\th.Type = unix.IPV6_TCLASS\n\th.SetLen(unix.CmsgLen(dataLen))\n\n\t// UnixRights uses the private `data` method, but I *think* this achieves the same goal.\n\toffset := startLen + unix.CmsgSpace(0)\n\tb[offset] = val.ToHeaderBits()\n\treturn b\n}\n"
        },
        {
          "name": "sys_conn_oob_test.go",
          "type": "blob",
          "size": 9.6142578125,
          "content": "//go:build darwin || linux || freebsd\n\npackage quic\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/net/ipv4\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc isIPv4(ip net.IP) bool { return ip.To4() != nil }\n\nfunc runSysConnServer(t *testing.T, network string, addr *net.UDPAddr) (*net.UDPAddr, <-chan receivedPacket) {\n\tt.Helper()\n\tudpConn, err := net.ListenUDP(network, addr)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { udpConn.Close() })\n\n\toobConn, err := newConn(udpConn, true)\n\trequire.NoError(t, err)\n\trequire.True(t, oobConn.capabilities().DF)\n\n\tpacketChan := make(chan receivedPacket, 1)\n\tgo func() {\n\t\tfor {\n\t\t\tp, err := oobConn.ReadPacket()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpacketChan <- p\n\t\t}\n\t}()\n\treturn udpConn.LocalAddr().(*net.UDPAddr), packetChan\n}\n\n// sendUDPPacketWithECN opens a new UDP socket and sends one packet with the ECN set.\n// It returns the local address of the socket.\nfunc sendUDPPacketWithECN(t *testing.T, network string, addr *net.UDPAddr, setECN func(uintptr)) net.Addr {\n\tconn, err := net.DialUDP(network, nil, addr)\n\trequire.NoError(t, err)\n\tt.Cleanup(func() { conn.Close() })\n\n\trawConn, err := conn.SyscallConn()\n\trequire.NoError(t, err)\n\trequire.NoError(t, rawConn.Control(func(fd uintptr) { setECN(fd) }))\n\t_, err = conn.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\treturn conn.LocalAddr()\n}\n\nfunc TestReadECNFlagsIPv4(t *testing.T) {\n\taddr, packetChan := runSysConnServer(t, \"udp4\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0})\n\n\tsentFrom := sendUDPPacketWithECN(t,\n\t\t\"udp4\",\n\t\taddr,\n\t\tfunc(fd uintptr) {\n\t\t\trequire.NoError(t, unix.SetsockoptInt(int(fd), unix.IPPROTO_IP, unix.IP_TOS, 2))\n\t\t},\n\t)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.WithinDuration(t, time.Now(), p.rcvTime, scaleDuration(20*time.Millisecond))\n\t\trequire.Equal(t, []byte(\"foobar\"), p.data)\n\t\trequire.Equal(t, sentFrom, p.remoteAddr)\n\t\trequire.Equal(t, protocol.ECT0, p.ecn)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet\")\n\t}\n}\n\nfunc TestReadECNFlagsIPv6(t *testing.T) {\n\taddr, packetChan := runSysConnServer(t, \"udp6\", &net.UDPAddr{IP: net.IPv6loopback, Port: 0})\n\n\tsentFrom := sendUDPPacketWithECN(t,\n\t\t\"udp6\",\n\t\taddr,\n\t\tfunc(fd uintptr) {\n\t\t\trequire.NoError(t, unix.SetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_TCLASS, 3))\n\t\t},\n\t)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.WithinDuration(t, time.Now(), p.rcvTime, scaleDuration(20*time.Millisecond))\n\t\trequire.Equal(t, []byte(\"foobar\"), p.data)\n\t\trequire.Equal(t, sentFrom, p.remoteAddr)\n\t\trequire.Equal(t, protocol.ECNCE, p.ecn)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet\")\n\t}\n}\n\nfunc TestReadECNFlagsDualStack(t *testing.T) {\n\taddr, packetChan := runSysConnServer(t, \"udp\", &net.UDPAddr{IP: net.IPv4(0, 0, 0, 0), Port: 0})\n\n\t// IPv4\n\tsentFrom := sendUDPPacketWithECN(t,\n\t\t\"udp4\",\n\t\t&net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: addr.Port},\n\t\tfunc(fd uintptr) {\n\t\t\trequire.NoError(t, unix.SetsockoptInt(int(fd), unix.IPPROTO_IP, unix.IP_TOS, 3))\n\t\t},\n\t)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.True(t, isIPv4(p.remoteAddr.(*net.UDPAddr).IP))\n\t\trequire.Equal(t, sentFrom.String(), p.remoteAddr.String())\n\t\trequire.Equal(t, protocol.ECNCE, p.ecn)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet\")\n\t}\n\n\t// IPv6\n\tsentFrom = sendUDPPacketWithECN(t,\n\t\t\"udp6\",\n\t\t&net.UDPAddr{IP: net.IPv6loopback, Port: addr.Port},\n\t\tfunc(fd uintptr) {\n\t\t\trequire.NoError(t, unix.SetsockoptInt(int(fd), unix.IPPROTO_IPV6, unix.IPV6_TCLASS, 1))\n\t\t},\n\t)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.Equal(t, sentFrom, p.remoteAddr)\n\t\trequire.False(t, isIPv4(p.remoteAddr.(*net.UDPAddr).IP))\n\t\trequire.Equal(t, protocol.ECT1, p.ecn)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet\")\n\t}\n}\n\nfunc TestSendPacketsWithECNOnIPv4(t *testing.T) {\n\taddr, packetChan := runSysConnServer(t, \"udp4\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0})\n\n\tc, err := net.ListenUDP(\"udp4\", nil)\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tfor _, val := range []protocol.ECN{protocol.ECNNon, protocol.ECT1, protocol.ECT0, protocol.ECNCE} {\n\t\t_, _, err = c.WriteMsgUDP([]byte(\"foobar\"), appendIPv4ECNMsg([]byte{}, val), addr)\n\t\trequire.NoError(t, err)\n\t\tselect {\n\t\tcase p := <-packetChan:\n\t\t\trequire.Equal(t, []byte(\"foobar\"), p.data)\n\t\t\trequire.Equal(t, val, p.ecn)\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatal(\"timeout waiting for packet\")\n\t\t}\n\t}\n}\n\nfunc TestSendPacketsWithECNOnIPv6(t *testing.T) {\n\taddr, packetChan := runSysConnServer(t, \"udp6\", &net.UDPAddr{IP: net.IPv6loopback, Port: 0})\n\n\tc, err := net.ListenUDP(\"udp6\", nil)\n\trequire.NoError(t, err)\n\tdefer c.Close()\n\n\tfor _, val := range []protocol.ECN{protocol.ECNNon, protocol.ECT1, protocol.ECT0, protocol.ECNCE} {\n\t\t_, _, err = c.WriteMsgUDP([]byte(\"foobar\"), appendIPv6ECNMsg([]byte{}, val), addr)\n\t\trequire.NoError(t, err)\n\t\tselect {\n\t\tcase p := <-packetChan:\n\t\t\trequire.Equal(t, []byte(\"foobar\"), p.data)\n\t\t\trequire.Equal(t, val, p.ecn)\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatal(\"timeout waiting for packet\")\n\t\t}\n\t}\n}\n\nfunc TestSysConnPacketInfoIPv4(t *testing.T) {\n\t// need to listen on 0.0.0.0, otherwise we won't get the packet info\n\taddr, packetChan := runSysConnServer(t, \"udp4\", &net.UDPAddr{IP: net.IPv4zero, Port: 0})\n\n\tconn, err := net.DialUDP(\"udp4\", nil, addr)\n\trequire.NoError(t, err)\n\tdefer conn.Close()\n\t_, err = conn.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.WithinDuration(t, time.Now(), p.rcvTime, scaleDuration(50*time.Millisecond))\n\t\trequire.Equal(t, []byte(\"foobar\"), p.data)\n\t\trequire.Equal(t, conn.LocalAddr(), p.remoteAddr)\n\t\trequire.True(t, p.info.addr.IsValid())\n\t\trequire.True(t, isIPv4(p.info.addr.AsSlice()))\n\t\trequire.Equal(t, net.IPv4(127, 0, 0, 1).String(), p.info.addr.String())\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet\")\n\t}\n}\n\nfunc TestSysConnPacketInfoIPv6(t *testing.T) {\n\t// need to listen on ::, otherwise we won't get the packet info\n\taddr, packetChan := runSysConnServer(t, \"udp6\", &net.UDPAddr{IP: net.IPv6zero, Port: 0})\n\n\tconn, err := net.DialUDP(\"udp6\", nil, addr)\n\trequire.NoError(t, err)\n\tdefer conn.Close()\n\t_, err = conn.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.WithinDuration(t, time.Now(), p.rcvTime, scaleDuration(20*time.Millisecond))\n\t\trequire.Equal(t, []byte(\"foobar\"), p.data)\n\t\trequire.Equal(t, conn.LocalAddr(), p.remoteAddr)\n\t\trequire.NotNil(t, p.info)\n\t\trequire.Equal(t, net.IPv6loopback, net.IP(p.info.addr.AsSlice()))\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet\")\n\t}\n}\n\nfunc TestSysConnPacketInfoDualStack(t *testing.T) {\n\taddr, packetChan := runSysConnServer(t, \"udp\", &net.UDPAddr{})\n\n\t// IPv4\n\tconn4, err := net.DialUDP(\"udp4\", nil, &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: addr.Port})\n\trequire.NoError(t, err)\n\tdefer conn4.Close()\n\t_, err = conn4.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.True(t, isIPv4(p.remoteAddr.(*net.UDPAddr).IP))\n\t\trequire.NotNil(t, p.info)\n\t\trequire.True(t, p.info.addr.Is4())\n\t\trequire.Equal(t, net.IPv4(127, 0, 0, 1).String(), p.info.addr.String())\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for IPv4 packet\")\n\t}\n\n\t// IPv6\n\tconn6, err := net.DialUDP(\"udp6\", nil, addr)\n\trequire.NoError(t, err)\n\tdefer conn6.Close()\n\t_, err = conn6.Write([]byte(\"foobar\"))\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase p := <-packetChan:\n\t\trequire.False(t, isIPv4(p.remoteAddr.(*net.UDPAddr).IP))\n\t\trequire.NotNil(t, p.info)\n\t\trequire.Equal(t, net.IPv6loopback.String(), p.info.addr.String())\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for IPv6 packet\")\n\t}\n}\n\ntype oobRecordingConn struct {\n\t*net.UDPConn\n\toobs [][]byte\n}\n\nfunc (c *oobRecordingConn) WriteMsgUDP(b, oob []byte, addr *net.UDPAddr) (n, oobn int, err error) {\n\tc.oobs = append(c.oobs, oob)\n\treturn c.UDPConn.WriteMsgUDP(b, oob, addr)\n}\n\ntype mockBatchConn struct {\n\tt          *testing.T\n\tnumMsgRead int\n\n\tcallCounter int\n}\n\nvar _ batchConn = &mockBatchConn{}\n\nfunc (c *mockBatchConn) ReadBatch(ms []ipv4.Message, _ int) (int, error) {\n\trequire.Len(c.t, ms, batchSize)\n\tfor i := 0; i < c.numMsgRead; i++ {\n\t\trequire.Len(c.t, ms[i].Buffers, 1)\n\t\trequire.Len(c.t, ms[i].Buffers[0], protocol.MaxPacketBufferSize)\n\t\tdata := []byte(fmt.Sprintf(\"message %d\", c.callCounter*c.numMsgRead+i))\n\t\tms[i].Buffers[0] = data\n\t\tms[i].N = len(data)\n\t}\n\tc.callCounter++\n\treturn c.numMsgRead, nil\n}\n\nfunc TestReadsMultipleMessagesInOneBatch(t *testing.T) {\n\tbc := &mockBatchConn{t: t, numMsgRead: batchSize/2 + 1}\n\n\tudpConn := newUPDConnLocalhost(t)\n\toobConn, err := newConn(udpConn, true)\n\trequire.NoError(t, err)\n\toobConn.batchConn = bc\n\n\tfor i := 0; i < batchSize+1; i++ {\n\t\tp, err := oobConn.ReadPacket()\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, fmt.Sprintf(\"message %d\", i), string(p.data))\n\t}\n\trequire.Equal(t, 2, bc.callCounter)\n}\n\nfunc TestSysConnSendGSO(t *testing.T) {\n\tif !platformSupportsGSO {\n\t\tt.Skip(\"GSO not supported on this platform\")\n\t}\n\n\tudpConn, err := net.ListenUDP(\"udp\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0})\n\trequire.NoError(t, err)\n\tc := &oobRecordingConn{UDPConn: udpConn}\n\toobConn, err := newConn(c, true)\n\trequire.NoError(t, err)\n\trequire.True(t, oobConn.capabilities().GSO)\n\n\toob := make([]byte, 0, 123)\n\toobConn.WritePacket([]byte(\"foobar\"), udpConn.LocalAddr(), oob, 3, protocol.ECNCE)\n\trequire.Len(t, c.oobs, 1)\n\toobMsg := c.oobs[0]\n\trequire.NotEmpty(t, oobMsg)\n\trequire.Equal(t, cap(oob), cap(oobMsg)) // check that it appended to oob\n\texpected := appendUDPSegmentSizeMsg([]byte{}, 3)\n\t// Check that the first control message is the OOB control message.\n\trequire.Equal(t, expected, oobMsg[:len(expected)])\n}\n"
        },
        {
          "name": "sys_conn_test.go",
          "type": "blob",
          "size": 0.8017578125,
          "content": "package quic\n\nimport (\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nfunc TestBasicConn(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\n\tc := NewMockPacketConn(mockCtrl)\n\taddr := &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 1234}\n\tc.EXPECT().ReadFrom(gomock.Any()).DoAndReturn(func(b []byte) (int, net.Addr, error) {\n\t\tdata := []byte(\"foobar\")\n\t\trequire.Equal(t, protocol.MaxPacketBufferSize, len(b))\n\t\treturn copy(b, data), addr, nil\n\t})\n\n\tconn, err := wrapConn(c)\n\trequire.NoError(t, err)\n\tp, err := conn.ReadPacket()\n\trequire.NoError(t, err)\n\trequire.Equal(t, []byte(\"foobar\"), p.data)\n\trequire.WithinDuration(t, time.Now(), p.rcvTime, scaleDuration(100*time.Millisecond))\n\trequire.Equal(t, addr, p.remoteAddr)\n}\n"
        },
        {
          "name": "sys_conn_windows.go",
          "type": "blob",
          "size": 0.87890625,
          "content": "//go:build windows\n\npackage quic\n\nimport (\n\t\"net/netip\"\n\t\"syscall\"\n\n\t\"golang.org/x/sys/windows\"\n)\n\nfunc newConn(c OOBCapablePacketConn, supportsDF bool) (*basicConn, error) {\n\treturn &basicConn{PacketConn: c, supportsDF: supportsDF}, nil\n}\n\nfunc inspectReadBuffer(c syscall.RawConn) (int, error) {\n\tvar size int\n\tvar serr error\n\tif err := c.Control(func(fd uintptr) {\n\t\tsize, serr = windows.GetsockoptInt(windows.Handle(fd), windows.SOL_SOCKET, windows.SO_RCVBUF)\n\t}); err != nil {\n\t\treturn 0, err\n\t}\n\treturn size, serr\n}\n\nfunc inspectWriteBuffer(c syscall.RawConn) (int, error) {\n\tvar size int\n\tvar serr error\n\tif err := c.Control(func(fd uintptr) {\n\t\tsize, serr = windows.GetsockoptInt(windows.Handle(fd), windows.SOL_SOCKET, windows.SO_SNDBUF)\n\t}); err != nil {\n\t\treturn 0, err\n\t}\n\treturn size, serr\n}\n\ntype packetInfo struct {\n\taddr netip.Addr\n}\n\nfunc (i *packetInfo) OOB() []byte { return nil }\n"
        },
        {
          "name": "sys_conn_windows_test.go",
          "type": "blob",
          "size": 0.71875,
          "content": "//go:build windows\n\npackage quic\n\nimport (\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestWindowsConn(t *testing.T) {\n\tt.Run(\"IPv4\", func(t *testing.T) {\n\t\tudpConn, err := net.ListenUDP(\"udp4\", &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 0})\n\t\trequire.NoError(t, err)\n\t\tconn, err := newConn(udpConn, true)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, conn.Close())\n\t\trequire.True(t, conn.capabilities().DF)\n\t})\n\n\tt.Run(\"IPv6\", func(t *testing.T) {\n\t\tudpConn, err := net.ListenUDP(\"udp6\", &net.UDPAddr{IP: net.IPv6loopback, Port: 0})\n\t\trequire.NoError(t, err)\n\t\tconn, err := newConn(udpConn, false)\n\t\trequire.NoError(t, err)\n\t\trequire.NoError(t, conn.Close())\n\t\trequire.False(t, conn.capabilities().DF)\n\t})\n}\n"
        },
        {
          "name": "testutils",
          "type": "tree",
          "content": null
        },
        {
          "name": "token_store.go",
          "type": "blob",
          "size": 2.51171875,
          "content": "package quic\n\nimport (\n\t\"sync\"\n\n\tlist \"github.com/quic-go/quic-go/internal/utils/linkedlist\"\n)\n\ntype singleOriginTokenStore struct {\n\ttokens []*ClientToken\n\tlen    int\n\tp      int\n}\n\nfunc newSingleOriginTokenStore(size int) *singleOriginTokenStore {\n\treturn &singleOriginTokenStore{tokens: make([]*ClientToken, size)}\n}\n\nfunc (s *singleOriginTokenStore) Add(token *ClientToken) {\n\ts.tokens[s.p] = token\n\ts.p = s.index(s.p + 1)\n\ts.len = min(s.len+1, len(s.tokens))\n}\n\nfunc (s *singleOriginTokenStore) Pop() *ClientToken {\n\ts.p = s.index(s.p - 1)\n\ttoken := s.tokens[s.p]\n\ts.tokens[s.p] = nil\n\ts.len = max(s.len-1, 0)\n\treturn token\n}\n\nfunc (s *singleOriginTokenStore) Len() int {\n\treturn s.len\n}\n\nfunc (s *singleOriginTokenStore) index(i int) int {\n\tmod := len(s.tokens)\n\treturn (i + mod) % mod\n}\n\ntype lruTokenStoreEntry struct {\n\tkey   string\n\tcache *singleOriginTokenStore\n}\n\ntype lruTokenStore struct {\n\tmutex sync.Mutex\n\n\tm                map[string]*list.Element[*lruTokenStoreEntry]\n\tq                *list.List[*lruTokenStoreEntry]\n\tcapacity         int\n\tsingleOriginSize int\n}\n\nvar _ TokenStore = &lruTokenStore{}\n\n// NewLRUTokenStore creates a new LRU cache for tokens received by the client.\n// maxOrigins specifies how many origins this cache is saving tokens for.\n// tokensPerOrigin specifies the maximum number of tokens per origin.\nfunc NewLRUTokenStore(maxOrigins, tokensPerOrigin int) TokenStore {\n\treturn &lruTokenStore{\n\t\tm:                make(map[string]*list.Element[*lruTokenStoreEntry]),\n\t\tq:                list.New[*lruTokenStoreEntry](),\n\t\tcapacity:         maxOrigins,\n\t\tsingleOriginSize: tokensPerOrigin,\n\t}\n}\n\nfunc (s *lruTokenStore) Put(key string, token *ClientToken) {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tif el, ok := s.m[key]; ok {\n\t\tentry := el.Value\n\t\tentry.cache.Add(token)\n\t\ts.q.MoveToFront(el)\n\t\treturn\n\t}\n\n\tif s.q.Len() < s.capacity {\n\t\tentry := &lruTokenStoreEntry{\n\t\t\tkey:   key,\n\t\t\tcache: newSingleOriginTokenStore(s.singleOriginSize),\n\t\t}\n\t\tentry.cache.Add(token)\n\t\ts.m[key] = s.q.PushFront(entry)\n\t\treturn\n\t}\n\n\telem := s.q.Back()\n\tentry := elem.Value\n\tdelete(s.m, entry.key)\n\tentry.key = key\n\tentry.cache = newSingleOriginTokenStore(s.singleOriginSize)\n\tentry.cache.Add(token)\n\ts.q.MoveToFront(elem)\n\ts.m[key] = elem\n}\n\nfunc (s *lruTokenStore) Pop(key string) *ClientToken {\n\ts.mutex.Lock()\n\tdefer s.mutex.Unlock()\n\n\tvar token *ClientToken\n\tif el, ok := s.m[key]; ok {\n\t\ts.q.MoveToFront(el)\n\t\tcache := el.Value.cache\n\t\ttoken = cache.Pop()\n\t\tif cache.Len() == 0 {\n\t\t\ts.q.Remove(el)\n\t\t\tdelete(s.m, key)\n\t\t}\n\t}\n\treturn token\n}\n"
        },
        {
          "name": "token_store_test.go",
          "type": "blob",
          "size": 2.1884765625,
          "content": "package quic\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc mockToken(num int) *ClientToken { return &ClientToken{data: []byte(fmt.Sprintf(\"%d\", num))} }\n\nfunc TestTokenStoreSingleOrigin(t *testing.T) {\n\tconst origin = \"localhost\"\n\n\ts := NewLRUTokenStore(1, 3)\n\ts.Put(origin, mockToken(1))\n\ts.Put(origin, mockToken(2))\n\trequire.Equal(t, mockToken(2), s.Pop(origin))\n\trequire.Equal(t, mockToken(1), s.Pop(origin))\n\trequire.Nil(t, s.Pop(origin))\n\n\t// now add more tokens than the cache size\n\ts.Put(origin, mockToken(1))\n\ts.Put(origin, mockToken(2))\n\ts.Put(origin, mockToken(3))\n\trequire.Equal(t, mockToken(3), s.Pop(origin))\n\ts.Put(origin, mockToken(4))\n\ts.Put(origin, mockToken(5))\n\trequire.Equal(t, mockToken(5), s.Pop(origin))\n\trequire.Equal(t, mockToken(4), s.Pop(origin))\n\trequire.Equal(t, mockToken(2), s.Pop(origin))\n\trequire.Nil(t, s.Pop(origin))\n}\n\nfunc TestTokenStoreMultipleOrigins(t *testing.T) {\n\ts := NewLRUTokenStore(3, 4)\n\n\ts.Put(\"host1\", mockToken(1))\n\ts.Put(\"host2\", mockToken(2))\n\ts.Put(\"host3\", mockToken(3))\n\ts.Put(\"host4\", mockToken(4))\n\trequire.Nil(t, s.Pop(\"host1\"))\n\trequire.Equal(t, mockToken(2), s.Pop(\"host2\"))\n\trequire.Equal(t, mockToken(3), s.Pop(\"host3\"))\n\trequire.Equal(t, mockToken(4), s.Pop(\"host4\"))\n}\n\nfunc TestTokenStoreUpdates(t *testing.T) {\n\ts := NewLRUTokenStore(3, 4)\n\ts.Put(\"host1\", mockToken(1))\n\ts.Put(\"host2\", mockToken(2))\n\ts.Put(\"host3\", mockToken(3))\n\ts.Put(\"host1\", mockToken(11))\n\t// make sure one is evicted\n\ts.Put(\"host4\", mockToken(4))\n\trequire.Nil(t, s.Pop(\"host2\"))\n\trequire.Equal(t, mockToken(11), s.Pop(\"host1\"))\n\trequire.Equal(t, mockToken(1), s.Pop(\"host1\"))\n\trequire.Equal(t, mockToken(3), s.Pop(\"host3\"))\n\trequire.Equal(t, mockToken(4), s.Pop(\"host4\"))\n}\n\nfunc TestTokenStoreEviction(t *testing.T) {\n\ts := NewLRUTokenStore(3, 4)\n\n\ts.Put(\"host1\", mockToken(1))\n\ts.Put(\"host2\", mockToken(2))\n\ts.Put(\"host3\", mockToken(3))\n\trequire.Equal(t, mockToken(2), s.Pop(\"host2\"))\n\trequire.Nil(t, s.Pop(\"host2\"))\n\t// host2 is now empty and should have been deleted, making space for host4\n\ts.Put(\"host4\", mockToken(4))\n\trequire.Equal(t, mockToken(1), s.Pop(\"host1\"))\n\trequire.Equal(t, mockToken(3), s.Pop(\"host3\"))\n\trequire.Equal(t, mockToken(4), s.Pop(\"host4\"))\n}\n"
        },
        {
          "name": "tools.go",
          "type": "blob",
          "size": 0.1083984375,
          "content": "//go:build tools\n\npackage quic\n\nimport (\n\t_ \"github.com/onsi/ginkgo/v2/ginkgo\"\n\t_ \"go.uber.org/mock/mockgen\"\n)\n"
        },
        {
          "name": "transport.go",
          "type": "blob",
          "size": 18.3115234375,
          "content": "package quic\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/utils\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n)\n\nvar errListenerAlreadySet = errors.New(\"listener already set\")\n\n// The Transport is the central point to manage incoming and outgoing QUIC connections.\n// QUIC demultiplexes connections based on their QUIC Connection IDs, not based on the 4-tuple.\n// This means that a single UDP socket can be used for listening for incoming connections, as well as\n// for dialing an arbitrary number of outgoing connections.\n// A Transport handles a single net.PacketConn, and offers a range of configuration options\n// compared to the simple helper functions like Listen and Dial that this package provides.\ntype Transport struct {\n\t// A single net.PacketConn can only be handled by one Transport.\n\t// Bad things will happen if passed to multiple Transports.\n\t//\n\t// A number of optimizations will be enabled if the connections implements the OOBCapablePacketConn interface,\n\t// as a *net.UDPConn does.\n\t// 1. It enables the Don't Fragment (DF) bit on the IP header.\n\t//    This is required to run DPLPMTUD (Path MTU Discovery, RFC 8899).\n\t// 2. It enables reading of the ECN bits from the IP header.\n\t//    This allows the remote node to speed up its loss detection and recovery.\n\t// 3. It uses batched syscalls (recvmmsg) to more efficiently receive packets from the socket.\n\t// 4. It uses Generic Segmentation Offload (GSO) to efficiently send batches of packets (on Linux).\n\t//\n\t// After passing the connection to the Transport, it's invalid to call ReadFrom or WriteTo on the connection.\n\tConn net.PacketConn\n\n\t// The length of the connection ID in bytes.\n\t// It can be any value between 1 and 20.\n\t// Due to the increased risk of collisions, it is not recommended to use connection IDs shorter than 4 bytes.\n\t// If unset, a 4 byte connection ID will be used.\n\tConnectionIDLength int\n\n\t// Use for generating new connection IDs.\n\t// This allows the application to control of the connection IDs used,\n\t// which allows routing / load balancing based on connection IDs.\n\t// All Connection IDs returned by the ConnectionIDGenerator MUST\n\t// have the same length.\n\tConnectionIDGenerator ConnectionIDGenerator\n\n\t// The StatelessResetKey is used to generate stateless reset tokens.\n\t// If no key is configured, sending of stateless resets is disabled.\n\t// It is highly recommended to configure a stateless reset key, as stateless resets\n\t// allow the peer to quickly recover from crashes and reboots of this node.\n\t// See section 10.3 of RFC 9000 for details.\n\tStatelessResetKey *StatelessResetKey\n\n\t// The TokenGeneratorKey is used to encrypt session resumption tokens.\n\t// If no key is configured, a random key will be generated.\n\t// If multiple servers are authoritative for the same domain, they should use the same key,\n\t// see section 8.1.3 of RFC 9000 for details.\n\tTokenGeneratorKey *TokenGeneratorKey\n\n\t// MaxTokenAge is the maximum age of the resumption token presented during the handshake.\n\t// These tokens allow skipping address resumption when resuming a QUIC connection,\n\t// and are especially useful when using 0-RTT.\n\t// If not set, it defaults to 24 hours.\n\t// See section 8.1.3 of RFC 9000 for details.\n\tMaxTokenAge time.Duration\n\n\t// DisableVersionNegotiationPackets disables the sending of Version Negotiation packets.\n\t// This can be useful if version information is exchanged out-of-band.\n\t// It has no effect for clients.\n\tDisableVersionNegotiationPackets bool\n\n\t// VerifySourceAddress decides if a connection attempt originating from unvalidated source\n\t// addresses first needs to go through source address validation using QUIC's Retry mechanism,\n\t// as described in RFC 9000 section 8.1.2.\n\t// Note that the address passed to this callback is unvalidated, and might be spoofed in case\n\t// of an attack.\n\t// Validating the source address adds one additional network roundtrip to the handshake,\n\t// and should therefore only be used if a suspiciously high number of incoming connection is recorded.\n\t// For most use cases, wrapping the Allow function of a rate.Limiter will be a reasonable\n\t// implementation of this callback (negating its return value).\n\tVerifySourceAddress func(net.Addr) bool\n\n\t// ConnContext is called when the server accepts a new connection.\n\t// The context is closed when the connection is closed, or when the handshake fails for any reason.\n\t// The context returned from the callback is used to derive every other context used during the\n\t// lifetime of the connection:\n\t// * the context passed to crypto/tls (and used on the tls.ClientHelloInfo)\n\t// * the context used in Config.Tracer\n\t// * the context returned from Connection.Context\n\t// * the context returned from SendStream.Context\n\t// It is not used for dialed connections.\n\tConnContext func(context.Context) context.Context\n\n\t// A Tracer traces events that don't belong to a single QUIC connection.\n\t// Tracer.Close is called when the transport is closed.\n\tTracer *logging.Tracer\n\n\thandlerMap packetHandlerManager\n\n\tmutex    sync.Mutex\n\tinitOnce sync.Once\n\tinitErr  error\n\n\t// Set in init.\n\t// If no ConnectionIDGenerator is set, this is the ConnectionIDLength.\n\tconnIDLen int\n\t// Set in init.\n\t// If no ConnectionIDGenerator is set, this is set to a default.\n\tconnIDGenerator ConnectionIDGenerator\n\n\tserver *baseServer\n\n\tconn rawConn\n\n\tcloseQueue          chan closePacket\n\tstatelessResetQueue chan receivedPacket\n\n\tlistening   chan struct{} // is closed when listen returns\n\tclosed      bool\n\tcreatedConn bool\n\tisSingleUse bool // was created for a single server or client, i.e. by calling quic.Listen or quic.Dial\n\n\treadingNonQUICPackets atomic.Bool\n\tnonQUICPackets        chan receivedPacket\n\n\tlogger utils.Logger\n}\n\n// Listen starts listening for incoming QUIC connections.\n// There can only be a single listener on any net.PacketConn.\n// Listen may only be called again after the current Listener was closed.\nfunc (t *Transport) Listen(tlsConf *tls.Config, conf *Config) (*Listener, error) {\n\ts, err := t.createServer(tlsConf, conf, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Listener{baseServer: s}, nil\n}\n\n// ListenEarly starts listening for incoming QUIC connections.\n// There can only be a single listener on any net.PacketConn.\n// Listen may only be called again after the current Listener was closed.\nfunc (t *Transport) ListenEarly(tlsConf *tls.Config, conf *Config) (*EarlyListener, error) {\n\ts, err := t.createServer(tlsConf, conf, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &EarlyListener{baseServer: s}, nil\n}\n\nfunc (t *Transport) createServer(tlsConf *tls.Config, conf *Config, allow0RTT bool) (*baseServer, error) {\n\tif tlsConf == nil {\n\t\treturn nil, errors.New(\"quic: tls.Config not set\")\n\t}\n\tif err := validateConfig(conf); err != nil {\n\t\treturn nil, err\n\t}\n\n\tt.mutex.Lock()\n\tdefer t.mutex.Unlock()\n\n\tif t.server != nil {\n\t\treturn nil, errListenerAlreadySet\n\t}\n\tconf = populateConfig(conf)\n\tif err := t.init(false); err != nil {\n\t\treturn nil, err\n\t}\n\tmaxTokenAge := t.MaxTokenAge\n\tif maxTokenAge == 0 {\n\t\tmaxTokenAge = 24 * time.Hour\n\t}\n\ts := newServer(\n\t\tt.conn,\n\t\tt.handlerMap,\n\t\tt.connIDGenerator,\n\t\tt.ConnContext,\n\t\ttlsConf,\n\t\tconf,\n\t\tt.Tracer,\n\t\tt.closeServer,\n\t\t*t.TokenGeneratorKey,\n\t\tmaxTokenAge,\n\t\tt.VerifySourceAddress,\n\t\tt.DisableVersionNegotiationPackets,\n\t\tallow0RTT,\n\t)\n\tt.server = s\n\treturn s, nil\n}\n\n// Dial dials a new connection to a remote host (not using 0-RTT).\nfunc (t *Transport) Dial(ctx context.Context, addr net.Addr, tlsConf *tls.Config, conf *Config) (Connection, error) {\n\treturn t.dial(ctx, addr, \"\", tlsConf, conf, false)\n}\n\n// DialEarly dials a new connection, attempting to use 0-RTT if possible.\nfunc (t *Transport) DialEarly(ctx context.Context, addr net.Addr, tlsConf *tls.Config, conf *Config) (EarlyConnection, error) {\n\treturn t.dial(ctx, addr, \"\", tlsConf, conf, true)\n}\n\nfunc (t *Transport) dial(ctx context.Context, addr net.Addr, host string, tlsConf *tls.Config, conf *Config, use0RTT bool) (EarlyConnection, error) {\n\tif err := validateConfig(conf); err != nil {\n\t\treturn nil, err\n\t}\n\tconf = populateConfig(conf)\n\tif err := t.init(t.isSingleUse); err != nil {\n\t\treturn nil, err\n\t}\n\tvar onClose func()\n\tif t.isSingleUse {\n\t\tonClose = func() { t.Close() }\n\t}\n\ttlsConf = tlsConf.Clone()\n\tsetTLSConfigServerName(tlsConf, addr, host)\n\treturn dial(ctx, newSendConn(t.conn, addr, packetInfo{}, utils.DefaultLogger), t.connIDGenerator, t.handlerMap, tlsConf, conf, onClose, use0RTT)\n}\n\nfunc (t *Transport) init(allowZeroLengthConnIDs bool) error {\n\tt.initOnce.Do(func() {\n\t\tvar conn rawConn\n\t\tif c, ok := t.Conn.(rawConn); ok {\n\t\t\tconn = c\n\t\t} else {\n\t\t\tvar err error\n\t\t\tconn, err = wrapConn(t.Conn)\n\t\t\tif err != nil {\n\t\t\t\tt.initErr = err\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tt.logger = utils.DefaultLogger // TODO: make this configurable\n\t\tt.conn = conn\n\t\tif t.handlerMap == nil { // allows mocking the handlerMap in tests\n\t\t\tt.handlerMap = newPacketHandlerMap(t.StatelessResetKey, t.enqueueClosePacket, t.logger)\n\t\t}\n\t\tt.listening = make(chan struct{})\n\n\t\tt.closeQueue = make(chan closePacket, 4)\n\t\tt.statelessResetQueue = make(chan receivedPacket, 4)\n\t\tif t.TokenGeneratorKey == nil {\n\t\t\tvar key TokenGeneratorKey\n\t\t\tif _, err := rand.Read(key[:]); err != nil {\n\t\t\t\tt.initErr = err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.TokenGeneratorKey = &key\n\t\t}\n\n\t\tif t.ConnectionIDGenerator != nil {\n\t\t\tt.connIDGenerator = t.ConnectionIDGenerator\n\t\t\tt.connIDLen = t.ConnectionIDGenerator.ConnectionIDLen()\n\t\t} else {\n\t\t\tconnIDLen := t.ConnectionIDLength\n\t\t\tif t.ConnectionIDLength == 0 && !allowZeroLengthConnIDs {\n\t\t\t\tconnIDLen = protocol.DefaultConnectionIDLength\n\t\t\t}\n\t\t\tt.connIDLen = connIDLen\n\t\t\tt.connIDGenerator = &protocol.DefaultConnectionIDGenerator{ConnLen: t.connIDLen}\n\t\t}\n\n\t\tgo t.listen(conn)\n\t\tgo t.runSendQueue()\n\t})\n\treturn t.initErr\n}\n\n// WriteTo sends a packet on the underlying connection.\nfunc (t *Transport) WriteTo(b []byte, addr net.Addr) (int, error) {\n\tif err := t.init(false); err != nil {\n\t\treturn 0, err\n\t}\n\treturn t.conn.WritePacket(b, addr, nil, 0, protocol.ECNUnsupported)\n}\n\nfunc (t *Transport) enqueueClosePacket(p closePacket) {\n\tselect {\n\tcase t.closeQueue <- p:\n\tdefault:\n\t\t// Oops, we're backlogged.\n\t\t// Just drop the packet, sending CONNECTION_CLOSE copies is best effort anyway.\n\t}\n}\n\nfunc (t *Transport) runSendQueue() {\n\tfor {\n\t\tselect {\n\t\tcase <-t.listening:\n\t\t\treturn\n\t\tcase p := <-t.closeQueue:\n\t\t\tt.conn.WritePacket(p.payload, p.addr, p.info.OOB(), 0, protocol.ECNUnsupported)\n\t\tcase p := <-t.statelessResetQueue:\n\t\t\tt.sendStatelessReset(p)\n\t\t}\n\t}\n}\n\n// Close closes the underlying connection.\n// If any listener was started, it will be closed as well.\n// It is invalid to start new listeners or connections after that.\nfunc (t *Transport) Close() error {\n\tt.close(errors.New(\"closing\"))\n\tif t.createdConn {\n\t\tif err := t.Conn.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if t.conn != nil {\n\t\tt.conn.SetReadDeadline(time.Now())\n\t\tdefer func() { t.conn.SetReadDeadline(time.Time{}) }()\n\t}\n\tif t.listening != nil {\n\t\t<-t.listening // wait until listening returns\n\t}\n\treturn nil\n}\n\nfunc (t *Transport) closeServer() {\n\tt.mutex.Lock()\n\tt.server = nil\n\tif t.isSingleUse {\n\t\tt.closed = true\n\t}\n\tt.mutex.Unlock()\n\tif t.createdConn {\n\t\tt.Conn.Close()\n\t}\n\tif t.isSingleUse {\n\t\tt.conn.SetReadDeadline(time.Now())\n\t\tdefer func() { t.conn.SetReadDeadline(time.Time{}) }()\n\t\t<-t.listening // wait until listening returns\n\t}\n}\n\nfunc (t *Transport) close(e error) {\n\tt.mutex.Lock()\n\tdefer t.mutex.Unlock()\n\tif t.closed {\n\t\treturn\n\t}\n\n\tif t.handlerMap != nil {\n\t\tt.handlerMap.Close(e)\n\t}\n\tif t.server != nil {\n\t\tt.server.close(e, false)\n\t}\n\tif t.Tracer != nil && t.Tracer.Close != nil {\n\t\tt.Tracer.Close()\n\t}\n\tt.closed = true\n}\n\n// only print warnings about the UDP receive buffer size once\nvar setBufferWarningOnce sync.Once\n\nfunc (t *Transport) listen(conn rawConn) {\n\tdefer close(t.listening)\n\n\tfor {\n\t\tp, err := conn.ReadPacket()\n\t\t//nolint:staticcheck // SA1019 ignore this!\n\t\t// TODO: This code is used to ignore wsa errors on Windows.\n\t\t// Since net.Error.Temporary is deprecated as of Go 1.18, we should find a better solution.\n\t\t// See https://github.com/quic-go/quic-go/issues/1737 for details.\n\t\tif nerr, ok := err.(net.Error); ok && nerr.Temporary() {\n\t\t\tt.mutex.Lock()\n\t\t\tclosed := t.closed\n\t\t\tt.mutex.Unlock()\n\t\t\tif closed {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tt.logger.Debugf(\"Temporary error reading from conn: %w\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\t// Windows returns an error when receiving a UDP datagram that doesn't fit into the provided buffer.\n\t\t\tif isRecvMsgSizeErr(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.close(err)\n\t\t\treturn\n\t\t}\n\t\tt.handlePacket(p)\n\t}\n}\n\nfunc (t *Transport) handlePacket(p receivedPacket) {\n\tif len(p.data) == 0 {\n\t\treturn\n\t}\n\tif !wire.IsPotentialQUICPacket(p.data[0]) && !wire.IsLongHeaderPacket(p.data[0]) {\n\t\tt.handleNonQUICPacket(p)\n\t\treturn\n\t}\n\tconnID, err := wire.ParseConnectionID(p.data, t.connIDLen)\n\tif err != nil {\n\t\tt.logger.Debugf(\"error parsing connection ID on packet from %s: %s\", p.remoteAddr, err)\n\t\tif t.Tracer != nil && t.Tracer.DroppedPacket != nil {\n\t\t\tt.Tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropHeaderParseError)\n\t\t}\n\t\tp.buffer.MaybeRelease()\n\t\treturn\n\t}\n\n\t// If there's a connection associated with the connection ID, pass the packet there.\n\tif handler, ok := t.handlerMap.Get(connID); ok {\n\t\thandler.handlePacket(p)\n\t\treturn\n\t}\n\t// RFC 9000 section 10.3.1 requires that the stateless reset detection logic is run for both\n\t// packets that cannot be associated with any connections, and for packets that can't be decrypted.\n\t// We deviate from the RFC and ignore the latter: If a packet's connection ID is associated with an\n\t// existing connection, it is dropped there if if it can't be decrypted.\n\t// Stateless resets use random connection IDs, and at reasonable connection ID lengths collisions are\n\t// exceedingly rare. In the unlikely event that a stateless reset is misrouted to an existing connection,\n\t// it is to be expected that the next stateless reset will be correctly detected.\n\tif isStatelessReset := t.maybeHandleStatelessReset(p.data); isStatelessReset {\n\t\treturn\n\t}\n\tif !wire.IsLongHeaderPacket(p.data[0]) {\n\t\tif statelessResetQueued := t.maybeSendStatelessReset(p); !statelessResetQueued {\n\t\t\tif t.Tracer != nil && t.Tracer.DroppedPacket != nil {\n\t\t\t\tt.Tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnknownConnectionID)\n\t\t\t}\n\t\t\tp.buffer.Release()\n\t\t}\n\t\treturn\n\t}\n\n\tt.mutex.Lock()\n\tdefer t.mutex.Unlock()\n\tif t.server == nil { // no server set\n\t\tt.logger.Debugf(\"received a packet with an unexpected connection ID %s\", connID)\n\t\tif t.Tracer != nil && t.Tracer.DroppedPacket != nil {\n\t\t\tt.Tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropUnknownConnectionID)\n\t\t}\n\t\tp.buffer.MaybeRelease()\n\t\treturn\n\t}\n\tt.server.handlePacket(p)\n}\n\nfunc (t *Transport) maybeSendStatelessReset(p receivedPacket) (statelessResetQueued bool) {\n\tif t.StatelessResetKey == nil {\n\t\treturn false\n\t}\n\n\t// Don't send a stateless reset in response to very small packets.\n\t// This includes packets that could be stateless resets.\n\tif len(p.data) <= protocol.MinStatelessResetSize {\n\t\treturn false\n\t}\n\n\tselect {\n\tcase t.statelessResetQueue <- p:\n\t\treturn true\n\tdefault:\n\t\t// it's fine to not send a stateless reset when we're busy\n\t\treturn false\n\t}\n}\n\nfunc (t *Transport) sendStatelessReset(p receivedPacket) {\n\tdefer p.buffer.Release()\n\n\tconnID, err := wire.ParseConnectionID(p.data, t.connIDLen)\n\tif err != nil {\n\t\tt.logger.Errorf(\"error parsing connection ID on packet from %s: %s\", p.remoteAddr, err)\n\t\treturn\n\t}\n\ttoken := t.handlerMap.GetStatelessResetToken(connID)\n\tt.logger.Debugf(\"Sending stateless reset to %s (connection ID: %s). Token: %#x\", p.remoteAddr, connID, token)\n\tdata := make([]byte, protocol.MinStatelessResetSize-16, protocol.MinStatelessResetSize)\n\trand.Read(data)\n\tdata[0] = (data[0] & 0x7f) | 0x40\n\tdata = append(data, token[:]...)\n\tif _, err := t.conn.WritePacket(data, p.remoteAddr, p.info.OOB(), 0, protocol.ECNUnsupported); err != nil {\n\t\tt.logger.Debugf(\"Error sending Stateless Reset to %s: %s\", p.remoteAddr, err)\n\t}\n}\n\nfunc (t *Transport) maybeHandleStatelessReset(data []byte) bool {\n\t// stateless resets are always short header packets\n\tif wire.IsLongHeaderPacket(data[0]) {\n\t\treturn false\n\t}\n\tif len(data) < 17 /* type byte + 16 bytes for the reset token */ {\n\t\treturn false\n\t}\n\n\ttoken := *(*protocol.StatelessResetToken)(data[len(data)-16:])\n\tif conn, ok := t.handlerMap.GetByResetToken(token); ok {\n\t\tt.logger.Debugf(\"Received a stateless reset with token %#x. Closing connection.\", token)\n\t\tgo conn.destroy(&StatelessResetError{})\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (t *Transport) handleNonQUICPacket(p receivedPacket) {\n\t// Strictly speaking, this is racy,\n\t// but we only care about receiving packets at some point after ReadNonQUICPacket has been called.\n\tif !t.readingNonQUICPackets.Load() {\n\t\treturn\n\t}\n\tselect {\n\tcase t.nonQUICPackets <- p:\n\tdefault:\n\t\tif t.Tracer != nil && t.Tracer.DroppedPacket != nil {\n\t\t\tt.Tracer.DroppedPacket(p.remoteAddr, logging.PacketTypeNotDetermined, p.Size(), logging.PacketDropDOSPrevention)\n\t\t}\n\t}\n}\n\nconst maxQueuedNonQUICPackets = 32\n\n// ReadNonQUICPacket reads non-QUIC packets received on the underlying connection.\n// The detection logic is very simple: Any packet that has the first and second bit of the packet set to 0.\n// Note that this is stricter than the detection logic defined in RFC 9443.\nfunc (t *Transport) ReadNonQUICPacket(ctx context.Context, b []byte) (int, net.Addr, error) {\n\tif err := t.init(false); err != nil {\n\t\treturn 0, nil, err\n\t}\n\tif !t.readingNonQUICPackets.Load() {\n\t\tt.nonQUICPackets = make(chan receivedPacket, maxQueuedNonQUICPackets)\n\t\tt.readingNonQUICPackets.Store(true)\n\t}\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn 0, nil, ctx.Err()\n\tcase p := <-t.nonQUICPackets:\n\t\tn := copy(b, p.data)\n\t\treturn n, p.remoteAddr, nil\n\tcase <-t.listening:\n\t\treturn 0, nil, errors.New(\"closed\")\n\t}\n}\n\nfunc setTLSConfigServerName(tlsConf *tls.Config, addr net.Addr, host string) {\n\t// If no ServerName is set, infer the ServerName from the host we're connecting to.\n\tif tlsConf.ServerName != \"\" {\n\t\treturn\n\t}\n\tif host == \"\" {\n\t\tif udpAddr, ok := addr.(*net.UDPAddr); ok {\n\t\t\ttlsConf.ServerName = udpAddr.IP.String()\n\t\t\treturn\n\t\t}\n\t}\n\th, _, err := net.SplitHostPort(host)\n\tif err != nil { // This happens if the host doesn't contain a port number.\n\t\ttlsConf.ServerName = host\n\t\treturn\n\t}\n\ttlsConf.ServerName = h\n}\n"
        },
        {
          "name": "transport_test.go",
          "type": "blob",
          "size": 14.1005859375,
          "content": "package quic\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\tmocklogging \"github.com/quic-go/quic-go/internal/mocks/logging\"\n\t\"github.com/quic-go/quic-go/internal/protocol\"\n\t\"github.com/quic-go/quic-go/internal/qerr\"\n\t\"github.com/quic-go/quic-go/internal/wire\"\n\t\"github.com/quic-go/quic-go/logging\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\ntype mockPacketConn struct {\n\tlocalAddr net.Addr\n\treadErrs  chan error\n}\n\nfunc (c *mockPacketConn) ReadFrom(p []byte) (n int, addr net.Addr, err error) {\n\terr, ok := <-c.readErrs\n\tif !ok {\n\t\treturn 0, nil, net.ErrClosed\n\t}\n\treturn 0, nil, err\n}\n\nfunc (c *mockPacketConn) WriteTo(p []byte, addr net.Addr) (n int, err error) { panic(\"implement me\") }\nfunc (c *mockPacketConn) LocalAddr() net.Addr                                { return c.localAddr }\nfunc (c *mockPacketConn) Close() error                                       { close(c.readErrs); return nil }\nfunc (c *mockPacketConn) SetDeadline(t time.Time) error                      { return nil }\nfunc (c *mockPacketConn) SetReadDeadline(t time.Time) error                  { return nil }\nfunc (c *mockPacketConn) SetWriteDeadline(t time.Time) error                 { return nil }\n\ntype mockPacketHandler struct {\n\tpackets     chan<- receivedPacket\n\tdestruction chan<- error\n}\n\nfunc (h *mockPacketHandler) handlePacket(p receivedPacket)                        { h.packets <- p }\nfunc (h *mockPacketHandler) destroy(err error)                                    { h.destruction <- err }\nfunc (h *mockPacketHandler) closeWithTransportError(code qerr.TransportErrorCode) {}\n\nfunc getPacket(t *testing.T, connID protocol.ConnectionID) []byte {\n\treturn getPacketWithPacketType(t, connID, protocol.PacketTypeHandshake, 2)\n}\n\nfunc getPacketWithPacketType(t *testing.T, connID protocol.ConnectionID, typ protocol.PacketType, length protocol.ByteCount) []byte {\n\tt.Helper()\n\tb, err := (&wire.ExtendedHeader{\n\t\tHeader: wire.Header{\n\t\t\tType:             typ,\n\t\t\tDestConnectionID: connID,\n\t\t\tLength:           length,\n\t\t\tVersion:          protocol.Version1,\n\t\t},\n\t\tPacketNumberLen: protocol.PacketNumberLen2,\n\t}).Append(nil, protocol.Version1)\n\trequire.NoError(t, err)\n\treturn append(b, bytes.Repeat([]byte{42}, int(length)-2)...)\n}\n\nfunc TestTransportPacketHandling(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tphm := NewMockPacketHandlerManager(mockCtrl)\n\n\ttr := &Transport{\n\t\tConn:       newUPDConnLocalhost(t),\n\t\thandlerMap: phm,\n\t}\n\ttr.init(true)\n\tdefer func() {\n\t\tphm.EXPECT().Close(gomock.Any())\n\t\ttr.Close()\n\t}()\n\n\tconnID1 := protocol.ParseConnectionID([]byte{1, 2, 3, 4, 5, 6, 7, 8})\n\tconnID2 := protocol.ParseConnectionID([]byte{8, 7, 6, 5, 4, 3, 2, 1})\n\n\tconnChan1 := make(chan receivedPacket, 1)\n\tconn1 := &mockPacketHandler{packets: connChan1}\n\tphm.EXPECT().Get(connID1).Return(conn1, true)\n\tconnChan2 := make(chan receivedPacket, 1)\n\tconn2 := &mockPacketHandler{packets: connChan2}\n\tphm.EXPECT().Get(connID2).Return(conn2, true)\n\n\tconn := newUPDConnLocalhost(t)\n\t_, err := conn.WriteTo(getPacket(t, connID1), tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\t_, err = conn.WriteTo(getPacket(t, connID2), tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase p := <-connChan1:\n\t\trequire.Equal(t, conn.LocalAddr(), p.remoteAddr)\n\t\tconnID, err := wire.ParseConnectionID(p.data, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, connID1, connID)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\tselect {\n\tcase p := <-connChan2:\n\t\trequire.Equal(t, conn.LocalAddr(), p.remoteAddr)\n\t\tconnID, err := wire.ParseConnectionID(p.data, 0)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, connID2, connID)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestTransportAndListenerConcurrentClose(t *testing.T) {\n\t// try 10 times to trigger race conditions\n\tfor i := 0; i < 10; i++ {\n\t\ttr := &Transport{Conn: newUPDConnLocalhost(t)}\n\t\tln, err := tr.Listen(&tls.Config{}, nil)\n\t\trequire.NoError(t, err)\n\t\t// close transport and listener concurrently\n\t\tlnErrChan := make(chan error, 1)\n\t\tgo func() { lnErrChan <- ln.Close() }()\n\t\trequire.NoError(t, tr.Close())\n\t\tselect {\n\t\tcase err := <-lnErrChan:\n\t\t\trequire.NoError(t, err)\n\t\tcase <-time.After(time.Second):\n\t\t\tt.Fatal(\"timeout\")\n\t\t}\n\t}\n}\n\nfunc TestTransportErrFromConn(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tphm := NewMockPacketHandlerManager(mockCtrl)\n\treadErrChan := make(chan error, 2)\n\tconn := &mockPacketConn{readErrs: readErrChan, localAddr: &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 1234}}\n\ttr := Transport{Conn: conn, handlerMap: phm}\n\tdefer tr.Close()\n\n\ttr.init(true)\n\ttr.handlerMap = phm\n\n\t// temporary errors don't lead to a shutdown...\n\tvar tempErr deadlineError\n\trequire.True(t, tempErr.Temporary())\n\treadErrChan <- tempErr\n\t// don't expect any calls to phm.Close\n\ttime.Sleep(scaleDuration(20 * time.Millisecond))\n\n\t// ...but non-temporary errors do\n\tdone := make(chan struct{})\n\tphm.EXPECT().Close(gomock.Any()).Do(func(error) { close(done) })\n\treadErrChan <- errors.New(\"read failed\")\n\tselect {\n\tcase <-done:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// TODO(#4778): test that it's not possible to listen after the transport is closed\n}\n\nfunc TestTransportStatelessResetReceiving(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tphm := NewMockPacketHandlerManager(mockCtrl)\n\ttr := &Transport{\n\t\tConn:               newUPDConnLocalhost(t),\n\t\tConnectionIDLength: 4,\n\t\thandlerMap:         phm,\n\t}\n\ttr.init(true)\n\tdefer func() {\n\t\tphm.EXPECT().Close(gomock.Any())\n\t\ttr.Close()\n\t}()\n\n\tconnID := protocol.ParseConnectionID([]byte{9, 10, 11, 12})\n\t// now send a packet with a connection ID that doesn't exist\n\ttoken := protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\tb, err := wire.AppendShortHeader(nil, connID, 1337, 2, protocol.KeyPhaseOne)\n\trequire.NoError(t, err)\n\tb = append(b, token[:]...)\n\n\tdestroyChan := make(chan error, 1)\n\tconn1 := &mockPacketHandler{destruction: destroyChan}\n\tgomock.InOrder(\n\t\tphm.EXPECT().Get(connID), // no handler for this connection ID\n\t\tphm.EXPECT().GetByResetToken(token).Return(conn1, true),\n\t)\n\n\tconn := newUPDConnLocalhost(t)\n\t_, err = conn.WriteTo(b, tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase err := <-destroyChan:\n\t\trequire.Error(t, err)\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n}\n\nfunc TestTransportStatelessResetSending(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\tphm := NewMockPacketHandlerManager(mockCtrl)\n\ttracer, mockTracer := mocklogging.NewMockTracer(mockCtrl)\n\ttr := &Transport{\n\t\tConn:               newUPDConnLocalhost(t),\n\t\tConnectionIDLength: 4,\n\t\tStatelessResetKey:  &StatelessResetKey{1, 2, 3, 4},\n\t\thandlerMap:         phm,\n\t\tTracer:             tracer,\n\t}\n\ttr.init(true)\n\tdefer func() {\n\t\tmockTracer.EXPECT().Close()\n\t\tphm.EXPECT().Close(gomock.Any())\n\t\ttr.Close()\n\t}()\n\n\tconnID := protocol.ParseConnectionID([]byte{9, 10, 11, 12})\n\tphm.EXPECT().Get(connID) // no handler for this connection ID\n\tphm.EXPECT().GetByResetToken(gomock.Any())\n\n\t// now send a packet with a connection ID that doesn't exist\n\tb, err := wire.AppendShortHeader(nil, connID, 1337, 2, protocol.KeyPhaseOne)\n\trequire.NoError(t, err)\n\n\tconn := newUPDConnLocalhost(t)\n\n\t// no stateless reset sent for packets smaller than MinStatelessResetSize\n\tdropped := make(chan struct{})\n\tsmallPacket := append(b, make([]byte, protocol.MinStatelessResetSize-len(b))...)\n\tmockTracer.EXPECT().DroppedPacket(conn.LocalAddr(), logging.PacketTypeNotDetermined, protocol.ByteCount(len(smallPacket)), logging.PacketDropUnknownConnectionID).Do(\n\t\tfunc(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) { close(dropped) },\n\t)\n\t_, err = conn.WriteTo(smallPacket, tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\tselect {\n\tcase <-dropped:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet to be dropped\")\n\t}\n\trequire.True(t, mockCtrl.Satisfied())\n\n\t// but a stateless reset is sent for packets larger than MinStatelessResetSize\n\tphm.EXPECT().Get(connID) // no handler for this connection ID\n\tphm.EXPECT().GetByResetToken(gomock.Any())\n\ttoken := protocol.StatelessResetToken{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}\n\tphm.EXPECT().GetStatelessResetToken(connID).Return(token)\n\t_, err = conn.WriteTo(append(b, make([]byte, protocol.MinStatelessResetSize-len(b)+1)...), tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\tconn.SetReadDeadline(time.Now().Add(time.Second))\n\tp := make([]byte, 1024)\n\tn, addr, err := conn.ReadFrom(p)\n\trequire.NoError(t, err)\n\trequire.Equal(t, addr, tr.Conn.LocalAddr())\n\trequire.Contains(t, string(p[:n]), string(token[:]))\n}\n\nfunc TestTransportDropsUnparseableQUICPackets(t *testing.T) {\n\tmockCtrl := gomock.NewController(t)\n\ttracer, mockTracer := mocklogging.NewMockTracer(mockCtrl)\n\ttr := &Transport{\n\t\tConn:               newUPDConnLocalhost(t),\n\t\tConnectionIDLength: 10,\n\t\tTracer:             tracer,\n\t}\n\trequire.NoError(t, tr.init(true))\n\tdefer func() {\n\t\tmockTracer.EXPECT().Close()\n\t\ttr.Close()\n\t}()\n\n\tconn := newUPDConnLocalhost(t)\n\n\tdropped := make(chan struct{})\n\tmockTracer.EXPECT().DroppedPacket(conn.LocalAddr(), logging.PacketTypeNotDetermined, protocol.ByteCount(4), logging.PacketDropHeaderParseError).Do(\n\t\tfunc(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) { close(dropped) },\n\t)\n\t_, err := conn.WriteTo([]byte{0x40 /* set the QUIC bit */, 1, 2, 3}, tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\tselect {\n\tcase <-dropped:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout waiting for packet to be dropped\")\n\t}\n}\n\nfunc TestTransportListening(t *testing.T) {\n\ttracer, mockTracer := mocklogging.NewMockTracer(gomock.NewController(t))\n\ttr := &Transport{\n\t\tConn:               newUPDConnLocalhost(t),\n\t\tConnectionIDLength: 5,\n\t\tTracer:             tracer,\n\t}\n\trequire.NoError(t, tr.init(true))\n\tdefer func() {\n\t\tmockTracer.EXPECT().Close()\n\t\ttr.Close()\n\t}()\n\n\tconn := newUPDConnLocalhost(t)\n\tdata := wire.ComposeVersionNegotiation([]byte{1, 2, 3, 4, 5}, []byte{6, 7, 8, 9, 10}, []protocol.Version{protocol.Version1})\n\tdropped := make(chan struct{}, 10)\n\tmockTracer.EXPECT().DroppedPacket(conn.LocalAddr(), logging.PacketTypeNotDetermined, protocol.ByteCount(len(data)), logging.PacketDropUnknownConnectionID).Do(\n\t\tfunc(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\tdropped <- struct{}{}\n\t\t},\n\t)\n\n\t_, err := conn.WriteTo(data, tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\tselect {\n\tcase <-dropped:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tln, err := tr.Listen(&tls.Config{}, nil)\n\trequire.NoError(t, err)\n\n\t// send the packet again\n\tlnDropped := make(chan struct{}, 10)\n\tmockTracer.EXPECT().DroppedPacket(conn.LocalAddr(), logging.PacketTypeVersionNegotiation, protocol.ByteCount(len(data)), logging.PacketDropUnexpectedPacket).Do(\n\t\tfunc(net.Addr, logging.PacketType, protocol.ByteCount, logging.PacketDropReason) {\n\t\t\tlnDropped <- struct{}{}\n\t\t},\n\t)\n\n\t_, err = conn.WriteTo(data, tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\tselect {\n\tcase <-lnDropped:\n\tcase <-dropped:\n\t\tt.Fatal(\"packet should have been handled by the listener\")\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\t// only a single listener can be set\n\t_, err = tr.Listen(&tls.Config{}, nil)\n\trequire.Error(t, err)\n\trequire.ErrorIs(t, err, errListenerAlreadySet)\n\n\trequire.NoError(t, ln.Close())\n\t// now it's possible to add a new listener\n\tln, err = tr.Listen(&tls.Config{}, nil)\n\trequire.NoError(t, err)\n\tdefer ln.Close()\n}\n\nfunc TestTransportNonQUICPackets(t *testing.T) {\n\ttr := &Transport{Conn: newUPDConnLocalhost(t)}\n\tdefer tr.Close()\n\n\tctx, cancel := context.WithTimeout(context.Background(), scaleDuration(5*time.Millisecond))\n\tdefer cancel()\n\t_, _, err := tr.ReadNonQUICPacket(ctx, make([]byte, 1024))\n\trequire.Error(t, err)\n\trequire.ErrorIs(t, err, context.DeadlineExceeded)\n\n\tconn := newUPDConnLocalhost(t)\n\tdata := []byte{0 /* don't set the QUIC bit */, 1, 2, 3}\n\t_, err = conn.WriteTo(data, tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\t_, err = conn.WriteTo(data, tr.Conn.LocalAddr())\n\trequire.NoError(t, err)\n\n\tctx, cancel = context.WithTimeout(context.Background(), scaleDuration(time.Second))\n\tdefer cancel()\n\tb := make([]byte, 1024)\n\tn, addr, err := tr.ReadNonQUICPacket(ctx, b)\n\trequire.NoError(t, err)\n\trequire.Equal(t, data, b[:n])\n\trequire.Equal(t, addr, conn.LocalAddr())\n\n\t// now send a lot of packets without reading them\n\tfor i := range 2 * maxQueuedNonQUICPackets {\n\t\tdata := append([]byte{0 /* don't set the QUIC bit */, uint8(i)}, bytes.Repeat([]byte{uint8(i)}, 1000)...)\n\t\t_, err = conn.WriteTo(data, tr.Conn.LocalAddr())\n\t\trequire.NoError(t, err)\n\t}\n\ttime.Sleep(scaleDuration(10 * time.Millisecond))\n\n\tvar received int\n\tfor {\n\t\tctx, cancel = context.WithTimeout(context.Background(), scaleDuration(20*time.Millisecond))\n\t\tdefer cancel()\n\t\t_, _, err := tr.ReadNonQUICPacket(ctx, b)\n\t\tif errors.Is(err, context.DeadlineExceeded) {\n\t\t\tbreak\n\t\t}\n\t\trequire.NoError(t, err)\n\t\treceived++\n\t}\n\trequire.Equal(t, received, maxQueuedNonQUICPackets)\n}\n\ntype faultySyscallConn struct{ net.PacketConn }\n\nfunc (c *faultySyscallConn) SyscallConn() (syscall.RawConn, error) { return nil, errors.New(\"mocked\") }\n\nfunc TestTransportFaultySyscallConn(t *testing.T) {\n\tsyscallconn := &faultySyscallConn{PacketConn: newUPDConnLocalhost(t)}\n\n\ttr := &Transport{Conn: syscallconn}\n\t_, err := tr.Listen(&tls.Config{}, nil)\n\trequire.Error(t, err)\n\trequire.ErrorContains(t, err, \"mocked\")\n}\n\nfunc TestTransportSetTLSConfigServerName(t *testing.T) {\n\tfor _, tt := range []struct {\n\t\tname     string\n\t\texpected string\n\t\tconf     *tls.Config\n\t\thost     string\n\t}{\n\t\t{\n\t\t\tname:     \"uses the value from the config\",\n\t\t\texpected: \"foo.bar\",\n\t\t\tconf:     &tls.Config{ServerName: \"foo.bar\"},\n\t\t\thost:     \"baz.foo\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uses the hostname\",\n\t\t\texpected: \"golang.org\",\n\t\t\tconf:     &tls.Config{},\n\t\t\thost:     \"golang.org\",\n\t\t},\n\t\t{\n\t\t\tname:     \"removes the port from the hostname\",\n\t\t\texpected: \"golang.org\",\n\t\t\tconf:     &tls.Config{},\n\t\t\thost:     \"golang.org:1234\",\n\t\t},\n\t\t{\n\t\t\tname:     \"uses the IP\",\n\t\t\texpected: \"1.3.5.7\",\n\t\t\tconf:     &tls.Config{},\n\t\t\thost:     \"\",\n\t\t},\n\t} {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tsetTLSConfigServerName(tt.conf, &net.UDPAddr{IP: net.IPv4(1, 3, 5, 7), Port: 1234}, tt.host)\n\t\t\trequire.Equal(t, tt.expected, tt.conf.ServerName)\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}