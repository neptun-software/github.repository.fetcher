{
  "metadata": {
    "timestamp": 1736568006858,
    "page": 142,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gizak/termui",
      "stars": 13257,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.037109375,
          "content": ".DS_Store\n.vscode/\n.mypy_cache/\n.idea\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 3.0087890625,
          "content": "# Changelog\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n## [3.1.0] - 2019-07-15\n\n### Added\n\n- Added Tree widget [#237]\n\n## [3.0.0] - 2019-03-07\n\n### Changed\n\n- Added sync.Locker interface to Drawable interface\n\n## 2019-03-01\n\n### Changed\n\n- Change scroll method names in List widget\n\n### Fixed\n\n- Fix List widget scrolling\n\n## 2019-02-28\n\n### Added\n\n- Add `ColumnResizer` to table which allows for custom column sizing\n- Add widget padding\n\n### Changed\n\n- Change various widget field names\n- s/`TextParse`/`ParseStyles`\n- Remove `AddColorMap` in place of modifying `StyleParserColorMap` directly\n\n## 2019-01-31\n\n### Added\n\n- Add more scrolling options to List\n\n### Changed\n\n- Make list scroll automatically\n\n### Added\n\n## 2019-01-26\n\n### Added\n\n- Add scrolling to List widget\n- Add WrapText option to Paragraph\n  - controls if text should wrap automatically\n\n## 2019-01-24\n\n### Added\n\n- Add image widget [#126]\n\n### Changed\n\n- Change LineChart to Plot\n  - Added ScatterPlot mode which plots points instead of lines between points\n\n## 2019-01-23\n\n### Added\n\n- Add `Canvas` which allows for drawing braille lines to a `Buffer`\n\n### Changed\n\n- Set `termbox-go` backend to 256 colors by default\n- Moved widgets to `github.com/gizak/termui/widgets`\n- Rewrote widgets (check examples and code)\n- Rewrote grid\n  - grids are instantiated locally instead of through `termui.Body`\n  - grids can be nested\n  - change grid layout mechanism\n    - columns and rows can be arbitrarily nested\n    - column and row size is now specified as a ratio of the available space\n- `Cell`s now contain a `Style` which holds a `Fg`, `Bg`, and `Modifier`\n- Change `Bufferer` interface to `Drawable`\n  - Add `GetRect` and `SetRect` methods to control widget sizing\n  - Change `Buffer` method to `Draw`\n    - `Draw` takes a `Buffer` and draws to it instead of returning a new `Buffer`\n- Refactor `Theme`\n  - `Theme` is now a large struct which holds the default `Styles` of everything\n- Combine `TermWidth` and `TermHeight` functions into `TerminalDimensions`\n- Rework `Block`\n- Rework `Buffer` methods\n- Decremente color numbers by 1 to match xterm colors\n- Change text parsing\n  - change style items from `fg-color` to `fg:color`\n  - adde mod item like `mod:reverse`\n\n## 2018-11-29\n\n### Changed\n\n- Move Tabpane from termui/extra to termui and rename it to TabPane\n- Rename PollEvent to PollEvents\n\n## 2018-11-28\n\n### Changed\n\n- Migrate from Dep to vgo\n- Overhaul the event system\n  - check the wiki/examples for details\n- Rename Par widget to Paragraph\n- Rename MBarChart widget to StackedBarChart\n\n[#237]: https://github.com/gizak/termui/pull/237\n[#126]: https://github.com/gizak/termui/pull/126\n\n[Unreleased]: https://github.com/gizak/termui/compare/v3.1.0...HEAD\n[3.1.0]: https://github.com/gizak/termui/compare/v3.0.0...v3.1.0\n[3.0.0]: https://github.com/gizak/termui/compare/v2.3.0...v3.0.0\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.05078125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Zack Guo\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.0966796875,
          "content": ".PHONY: run-examples\nrun-examples:\n\t@for file in _examples/*.go; do \\\n\t  go run $$file; \\\n\t  done;\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.478515625,
          "content": "# termui\n\n[<img src=\"./_assets/demo.gif\" alt=\"demo cast under osx 10.10; Terminal.app; Menlo Regular 12pt.)\" width=\"100%\">](./_examples/demo.go)\n\ntermui is a cross-platform and fully-customizable terminal dashboard and widget library built on top of [termbox-go](https://github.com/nsf/termbox-go). It is inspired by [blessed-contrib](https://github.com/yaronn/blessed-contrib) and [tui-rs](https://github.com/fdehau/tui-rs) and written purely in Go.\n\n## Note\n\nPlease be aware that due to my fluctuating availability, the frequency of updates to this project may not always follow a consistent schedule. I would like to invite potential maintainers to contribute to this project. If you are interested in becoming a maintainer, please do not hesitate to reach out to me.\n\n## Versions\n\ntermui is currently compatible with Go 1.15 (as in go.mod) and above (tracking the Debian's [oldstable](https://wiki.debian.org/DebianReleases)). Please use the version-numbered branch as stable release. The new changes will be pushed to master branch first and then merge to version branch.\n\n## Features\n\n- Several premade widgets for common use cases\n- Easily create custom widgets\n- Position widgets either in a relative grid or with absolute coordinates\n- Keyboard, mouse, and terminal resizing events\n- Colors and styling\n\n## Installation\n\n### Go modules\n\nIt is not necessary to `go get` termui, since Go will automatically manage any imported dependencies for you. Do note that you have to include `/v3` in the import statements as shown in the 'Hello World' example below.\n\n### Dep\n\nAdd with `dep ensure -add github.com/gizak/termui`. With Dep, `/v3` should *not* be included in the import statements.\n\n## Hello World\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\tui \"github.com/gizak/termui/v3\"\n\t\"github.com/gizak/termui/v3/widgets\"\n)\n\nfunc main() {\n\tif err := ui.Init(); err != nil {\n\t\tlog.Fatalf(\"failed to initialize termui: %v\", err)\n\t}\n\tdefer ui.Close()\n\n\tp := widgets.NewParagraph()\n\tp.Text = \"Hello World!\"\n\tp.SetRect(0, 0, 25, 5)\n\n\tui.Render(p)\n\n\tfor e := range ui.PollEvents() {\n\t\tif e.Type == ui.KeyboardEvent {\n\t\t\tbreak\n\t\t}\n\t}\n}\n```\n\n## Widgets\n\n- [BarChart](./_examples/barchart.go)\n- [Canvas](./_examples/canvas.go) (for drawing braille dots)\n- [Gauge](./_examples/gauge.go)\n- [Image](./_examples/image.go)\n- [List](./_examples/list.go)\n- [Tree](./_examples/tree.go)\n- [Paragraph](./_examples/paragraph.go)\n- [PieChart](./_examples/piechart.go)\n- [Plot](./_examples/plot.go) (for scatterplots and linecharts)\n- [Sparkline](./_examples/sparkline.go)\n- [StackedBarChart](./_examples/stacked_barchart.go)\n- [Table](./_examples/table.go)\n- [Tabs](./_examples/tabs.go)\n\nRun an example with `go run _examples/{example}.go` or run each example consecutively with `make run-examples`.\n\n## Documentation\n\n- [wiki](https://github.com/gizak/termui/wiki)\n\n## Uses\n\n- [dockdash](https://github.com/byrnedo/dockdash)\n- [expvarmon](https://github.com/divan/expvarmon)\n- [go-ethereum/monitorcmd](https://github.com/ethereum/go-ethereum/blob/master/cmd/geth/monitorcmd.go)\n- [go-jira-ui](https://github.com/mikepea/go-jira-ui)\n- [gotop](https://github.com/cjbassi/gotop)\n- [termeter](https://github.com/atsaki/termeter)\n- [updo](https://github.com/Owloops/updo)\n\n## Related Works\n\n- [blessed-contrib](https://github.com/yaronn/blessed-contrib)\n- [gocui](https://github.com/jroimartin/gocui)\n- [termdash](https://github.com/mum4k/termdash)\n- [tui-rs](https://github.com/fdehau/tui-rs)\n- [tview](https://github.com/rivo/tview)\n\n## License\n\n[MIT](http://opensource.org/licenses/MIT)\n"
        },
        {
          "name": "_assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "_scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "_test",
          "type": "tree",
          "content": null
        },
        {
          "name": "alignment.go",
          "type": "blob",
          "size": 0.09765625,
          "content": "package termui\n\ntype Alignment uint\n\nconst (\n\tAlignLeft Alignment = iota\n\tAlignCenter\n\tAlignRight\n)\n"
        },
        {
          "name": "backend.go",
          "type": "blob",
          "size": 0.751953125,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nimport (\n\ttb \"github.com/nsf/termbox-go\"\n)\n\n// Init initializes termbox-go and is required to render anything.\n// After initialization, the library must be finalized with `Close`.\nfunc Init() error {\n\tif err := tb.Init(); err != nil {\n\t\treturn err\n\t}\n\ttb.SetInputMode(tb.InputEsc | tb.InputMouse)\n\ttb.SetOutputMode(tb.Output256)\n\treturn nil\n}\n\n// Close closes termbox-go.\nfunc Close() {\n\ttb.Close()\n}\n\nfunc TerminalDimensions() (int, int) {\n\ttb.Sync()\n\twidth, height := tb.Size()\n\treturn width, height\n}\n\nfunc Clear() {\n\ttb.Clear(tb.ColorDefault, tb.Attribute(Theme.Default.Bg+1))\n}\n"
        },
        {
          "name": "block.go",
          "type": "blob",
          "size": 2.662109375,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nimport (\n\t\"image\"\n\t\"sync\"\n)\n\n// Block is the base struct inherited by most widgets.\n// Block manages size, position, border, and title.\n// It implements all 3 of the methods needed for the `Drawable` interface.\n// Custom widgets will override the Draw method.\ntype Block struct {\n\tBorder      bool\n\tBorderStyle Style\n\n\tBorderLeft, BorderRight, BorderTop, BorderBottom bool\n\n\tPaddingLeft, PaddingRight, PaddingTop, PaddingBottom int\n\n\timage.Rectangle\n\tInner image.Rectangle\n\n\tTitle      string\n\tTitleStyle Style\n\n\tsync.Mutex\n}\n\nfunc NewBlock() *Block {\n\treturn &Block{\n\t\tBorder:       true,\n\t\tBorderStyle:  Theme.Block.Border,\n\t\tBorderLeft:   true,\n\t\tBorderRight:  true,\n\t\tBorderTop:    true,\n\t\tBorderBottom: true,\n\n\t\tTitleStyle: Theme.Block.Title,\n\t}\n}\n\nfunc (self *Block) drawBorder(buf *Buffer) {\n\tverticalCell := Cell{VERTICAL_LINE, self.BorderStyle}\n\thorizontalCell := Cell{HORIZONTAL_LINE, self.BorderStyle}\n\n\t// draw lines\n\tif self.BorderTop {\n\t\tbuf.Fill(horizontalCell, image.Rect(self.Min.X, self.Min.Y, self.Max.X, self.Min.Y+1))\n\t}\n\tif self.BorderBottom {\n\t\tbuf.Fill(horizontalCell, image.Rect(self.Min.X, self.Max.Y-1, self.Max.X, self.Max.Y))\n\t}\n\tif self.BorderLeft {\n\t\tbuf.Fill(verticalCell, image.Rect(self.Min.X, self.Min.Y, self.Min.X+1, self.Max.Y))\n\t}\n\tif self.BorderRight {\n\t\tbuf.Fill(verticalCell, image.Rect(self.Max.X-1, self.Min.Y, self.Max.X, self.Max.Y))\n\t}\n\n\t// draw corners\n\tif self.BorderTop && self.BorderLeft {\n\t\tbuf.SetCell(Cell{TOP_LEFT, self.BorderStyle}, self.Min)\n\t}\n\tif self.BorderTop && self.BorderRight {\n\t\tbuf.SetCell(Cell{TOP_RIGHT, self.BorderStyle}, image.Pt(self.Max.X-1, self.Min.Y))\n\t}\n\tif self.BorderBottom && self.BorderLeft {\n\t\tbuf.SetCell(Cell{BOTTOM_LEFT, self.BorderStyle}, image.Pt(self.Min.X, self.Max.Y-1))\n\t}\n\tif self.BorderBottom && self.BorderRight {\n\t\tbuf.SetCell(Cell{BOTTOM_RIGHT, self.BorderStyle}, self.Max.Sub(image.Pt(1, 1)))\n\t}\n}\n\n// Draw implements the Drawable interface.\nfunc (self *Block) Draw(buf *Buffer) {\n\tif self.Border {\n\t\tself.drawBorder(buf)\n\t}\n\tbuf.SetString(\n\t\tself.Title,\n\t\tself.TitleStyle,\n\t\timage.Pt(self.Min.X+2, self.Min.Y),\n\t)\n}\n\n// SetRect implements the Drawable interface.\nfunc (self *Block) SetRect(x1, y1, x2, y2 int) {\n\tself.Rectangle = image.Rect(x1, y1, x2, y2)\n\tself.Inner = image.Rect(\n\t\tself.Min.X+1+self.PaddingLeft,\n\t\tself.Min.Y+1+self.PaddingTop,\n\t\tself.Max.X-1-self.PaddingRight,\n\t\tself.Max.Y-1-self.PaddingBottom,\n\t)\n}\n\n// GetRect implements the Drawable interface.\nfunc (self *Block) GetRect() image.Rectangle {\n\treturn self.Rectangle\n}\n"
        },
        {
          "name": "buffer.go",
          "type": "blob",
          "size": 1.5166015625,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nimport (\n\t\"image\"\n\n\trw \"github.com/mattn/go-runewidth\"\n)\n\n// Cell represents a viewable terminal cell\ntype Cell struct {\n\tRune  rune\n\tStyle Style\n}\n\nvar CellClear = Cell{\n\tRune:  ' ',\n\tStyle: StyleClear,\n}\n\n// NewCell takes 1 to 2 arguments\n// 1st argument = rune\n// 2nd argument = optional style\nfunc NewCell(rune rune, args ...interface{}) Cell {\n\tstyle := StyleClear\n\tif len(args) == 1 {\n\t\tstyle = args[0].(Style)\n\t}\n\treturn Cell{\n\t\tRune:  rune,\n\t\tStyle: style,\n\t}\n}\n\n// Buffer represents a section of a terminal and is a renderable rectangle of cells.\ntype Buffer struct {\n\timage.Rectangle\n\tCellMap map[image.Point]Cell\n}\n\nfunc NewBuffer(r image.Rectangle) *Buffer {\n\tbuf := &Buffer{\n\t\tRectangle: r,\n\t\tCellMap:   make(map[image.Point]Cell),\n\t}\n\tbuf.Fill(CellClear, r) // clears out area\n\treturn buf\n}\n\nfunc (self *Buffer) GetCell(p image.Point) Cell {\n\treturn self.CellMap[p]\n}\n\nfunc (self *Buffer) SetCell(c Cell, p image.Point) {\n\tself.CellMap[p] = c\n}\n\nfunc (self *Buffer) Fill(c Cell, rect image.Rectangle) {\n\tfor x := rect.Min.X; x < rect.Max.X; x++ {\n\t\tfor y := rect.Min.Y; y < rect.Max.Y; y++ {\n\t\t\tself.SetCell(c, image.Pt(x, y))\n\t\t}\n\t}\n}\n\nfunc (self *Buffer) SetString(s string, style Style, p image.Point) {\n\trunes := []rune(s)\n\tx := 0\n\tfor _, char := range runes {\n\t\tself.SetCell(Cell{char, style}, image.Pt(p.X+x, p.Y))\n\t\tx += rw.RuneWidth(char)\n\t}\n}\n"
        },
        {
          "name": "canvas.go",
          "type": "blob",
          "size": 0.7353515625,
          "content": "package termui\n\nimport (\n\t\"image\"\n\n\t\"github.com/gizak/termui/v3/drawille\"\n)\n\ntype Canvas struct {\n\tBlock\n\tdrawille.Canvas\n}\n\nfunc NewCanvas() *Canvas {\n\treturn &Canvas{\n\t\tBlock:  *NewBlock(),\n\t\tCanvas: *drawille.NewCanvas(),\n\t}\n}\n\nfunc (self *Canvas) SetPoint(p image.Point, color Color) {\n\tself.Canvas.SetPoint(p, drawille.Color(color))\n}\n\nfunc (self *Canvas) SetLine(p0, p1 image.Point, color Color) {\n\tself.Canvas.SetLine(p0, p1, drawille.Color(color))\n}\n\nfunc (self *Canvas) Draw(buf *Buffer) {\n\tfor point, cell := range self.Canvas.GetCells() {\n\t\tif point.In(self.Rectangle) {\n\t\t\tconvertedCell := Cell{\n\t\t\t\tcell.Rune,\n\t\t\t\tStyle{\n\t\t\t\t\tColor(cell.Color),\n\t\t\t\t\tColorClear,\n\t\t\t\t\tModifierClear,\n\t\t\t\t},\n\t\t\t}\n\t\t\tbuf.SetCell(convertedCell, point)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.2734375,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\n/*\nPackage termui is a library for creating terminal user interfaces (TUIs) using widgets.\n*/\npackage termui\n"
        },
        {
          "name": "drawille",
          "type": "tree",
          "content": null
        },
        {
          "name": "events.go",
          "type": "blob",
          "size": 4.7060546875,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nimport (\n\t\"fmt\"\n\n\ttb \"github.com/nsf/termbox-go\"\n)\n\n/*\nList of events:\n\tmouse events:\n\t\t<MouseLeft> <MouseRight> <MouseMiddle>\n\t\t<MouseWheelUp> <MouseWheelDown>\n\tkeyboard events:\n\t\tany uppercase or lowercase letter like j or J\n\t\t<C-d> etc\n\t\t<M-d> etc\n\t\t<Up> <Down> <Left> <Right>\n\t\t<Insert> <Delete> <Home> <End> <Previous> <Next>\n\t\t<Backspace> <Tab> <Enter> <Escape> <Space>\n\t\t<C-<Space>> etc\n\tterminal events:\n        <Resize>\n\n    keyboard events that do not work:\n        <C-->\n        <C-2> <C-~>\n        <C-h>\n        <C-i>\n        <C-m>\n        <C-[> <C-3>\n        <C-\\\\>\n        <C-]>\n        <C-/> <C-_>\n        <C-8>\n*/\n\ntype EventType uint\n\nconst (\n\tKeyboardEvent EventType = iota\n\tMouseEvent\n\tResizeEvent\n)\n\ntype Event struct {\n\tType    EventType\n\tID      string\n\tPayload interface{}\n}\n\n// Mouse payload.\ntype Mouse struct {\n\tDrag bool\n\tX    int\n\tY    int\n}\n\n// Resize payload.\ntype Resize struct {\n\tWidth  int\n\tHeight int\n}\n\n// PollEvents gets events from termbox, converts them, then sends them to each of its channels.\nfunc PollEvents() <-chan Event {\n\tch := make(chan Event)\n\tgo func() {\n\t\tfor {\n\t\t\tch <- convertTermboxEvent(tb.PollEvent())\n\t\t}\n\t}()\n\treturn ch\n}\n\nvar keyboardMap = map[tb.Key]string{\n\ttb.KeyF1:         \"<F1>\",\n\ttb.KeyF2:         \"<F2>\",\n\ttb.KeyF3:         \"<F3>\",\n\ttb.KeyF4:         \"<F4>\",\n\ttb.KeyF5:         \"<F5>\",\n\ttb.KeyF6:         \"<F6>\",\n\ttb.KeyF7:         \"<F7>\",\n\ttb.KeyF8:         \"<F8>\",\n\ttb.KeyF9:         \"<F9>\",\n\ttb.KeyF10:        \"<F10>\",\n\ttb.KeyF11:        \"<F11>\",\n\ttb.KeyF12:        \"<F12>\",\n\ttb.KeyInsert:     \"<Insert>\",\n\ttb.KeyDelete:     \"<Delete>\",\n\ttb.KeyHome:       \"<Home>\",\n\ttb.KeyEnd:        \"<End>\",\n\ttb.KeyPgup:       \"<PageUp>\",\n\ttb.KeyPgdn:       \"<PageDown>\",\n\ttb.KeyArrowUp:    \"<Up>\",\n\ttb.KeyArrowDown:  \"<Down>\",\n\ttb.KeyArrowLeft:  \"<Left>\",\n\ttb.KeyArrowRight: \"<Right>\",\n\n\ttb.KeyCtrlSpace:  \"<C-<Space>>\", // tb.KeyCtrl2 tb.KeyCtrlTilde\n\ttb.KeyCtrlA:      \"<C-a>\",\n\ttb.KeyCtrlB:      \"<C-b>\",\n\ttb.KeyCtrlC:      \"<C-c>\",\n\ttb.KeyCtrlD:      \"<C-d>\",\n\ttb.KeyCtrlE:      \"<C-e>\",\n\ttb.KeyCtrlF:      \"<C-f>\",\n\ttb.KeyCtrlG:      \"<C-g>\",\n\ttb.KeyBackspace:  \"<C-<Backspace>>\", // tb.KeyCtrlH\n\ttb.KeyTab:        \"<Tab>\",           // tb.KeyCtrlI\n\ttb.KeyCtrlJ:      \"<C-j>\",\n\ttb.KeyCtrlK:      \"<C-k>\",\n\ttb.KeyCtrlL:      \"<C-l>\",\n\ttb.KeyEnter:      \"<Enter>\", // tb.KeyCtrlM\n\ttb.KeyCtrlN:      \"<C-n>\",\n\ttb.KeyCtrlO:      \"<C-o>\",\n\ttb.KeyCtrlP:      \"<C-p>\",\n\ttb.KeyCtrlQ:      \"<C-q>\",\n\ttb.KeyCtrlR:      \"<C-r>\",\n\ttb.KeyCtrlS:      \"<C-s>\",\n\ttb.KeyCtrlT:      \"<C-t>\",\n\ttb.KeyCtrlU:      \"<C-u>\",\n\ttb.KeyCtrlV:      \"<C-v>\",\n\ttb.KeyCtrlW:      \"<C-w>\",\n\ttb.KeyCtrlX:      \"<C-x>\",\n\ttb.KeyCtrlY:      \"<C-y>\",\n\ttb.KeyCtrlZ:      \"<C-z>\",\n\ttb.KeyEsc:        \"<Escape>\", // tb.KeyCtrlLsqBracket tb.KeyCtrl3\n\ttb.KeyCtrl4:      \"<C-4>\",    // tb.KeyCtrlBackslash\n\ttb.KeyCtrl5:      \"<C-5>\",    // tb.KeyCtrlRsqBracket\n\ttb.KeyCtrl6:      \"<C-6>\",\n\ttb.KeyCtrl7:      \"<C-7>\", // tb.KeyCtrlSlash tb.KeyCtrlUnderscore\n\ttb.KeySpace:      \"<Space>\",\n\ttb.KeyBackspace2: \"<Backspace>\", // tb.KeyCtrl8:\n}\n\n// convertTermboxKeyboardEvent converts a termbox keyboard event to a more friendly string format.\n// Combines modifiers into the string instead of having them as additional fields in an event.\nfunc convertTermboxKeyboardEvent(e tb.Event) Event {\n\tID := \"%s\"\n\tif e.Mod == tb.ModAlt {\n\t\tID = \"<M-%s>\"\n\t}\n\n\tif e.Ch != 0 {\n\t\tID = fmt.Sprintf(ID, string(e.Ch))\n\t} else {\n\t\tconverted, ok := keyboardMap[e.Key]\n\t\tif !ok {\n\t\t\tconverted = \"\"\n\t\t}\n\t\tID = fmt.Sprintf(ID, converted)\n\t}\n\n\treturn Event{\n\t\tType: KeyboardEvent,\n\t\tID:   ID,\n\t}\n}\n\nvar mouseButtonMap = map[tb.Key]string{\n\ttb.MouseLeft:      \"<MouseLeft>\",\n\ttb.MouseMiddle:    \"<MouseMiddle>\",\n\ttb.MouseRight:     \"<MouseRight>\",\n\ttb.MouseRelease:   \"<MouseRelease>\",\n\ttb.MouseWheelUp:   \"<MouseWheelUp>\",\n\ttb.MouseWheelDown: \"<MouseWheelDown>\",\n}\n\nfunc convertTermboxMouseEvent(e tb.Event) Event {\n\tconverted, ok := mouseButtonMap[e.Key]\n\tif !ok {\n\t\tconverted = \"Unknown_Mouse_Button\"\n\t}\n\tDrag := e.Mod == tb.ModMotion\n\treturn Event{\n\t\tType: MouseEvent,\n\t\tID:   converted,\n\t\tPayload: Mouse{\n\t\t\tX:    e.MouseX,\n\t\t\tY:    e.MouseY,\n\t\t\tDrag: Drag,\n\t\t},\n\t}\n}\n\n// convertTermboxEvent turns a termbox event into a termui event.\nfunc convertTermboxEvent(e tb.Event) Event {\n\tif e.Type == tb.EventError {\n\t\tpanic(e.Err)\n\t}\n\tswitch e.Type {\n\tcase tb.EventKey:\n\t\treturn convertTermboxKeyboardEvent(e)\n\tcase tb.EventMouse:\n\t\treturn convertTermboxMouseEvent(e)\n\tcase tb.EventResize:\n\t\treturn Event{\n\t\t\tType: ResizeEvent,\n\t\t\tID:   \"<Resize>\",\n\t\t\tPayload: Resize{\n\t\t\t\tWidth:  e.Width,\n\t\t\t\tHeight: e.Height,\n\t\t\t},\n\t\t}\n\t}\n\treturn Event{}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2080078125,
          "content": "module github.com/gizak/termui/v3\n\ngo 1.15\n\nrequire (\n\tgithub.com/mattn/go-runewidth v0.0.15\n\tgithub.com/mitchellh/go-wordwrap v1.0.1\n\tgithub.com/nsf/termbox-go v1.1.1\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.4765625,
          "content": "github.com/mattn/go-runewidth v0.0.2 h1:UnlwIPBGaTZfPQ6T1IGzPI0EkYAQmT9fAEJ/poFC63o=\ngithub.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mitchellh/go-wordwrap v0.0.0-20150314170334-ad45545899c7 h1:DpOJ2HYzCv8LZP15IdmG+YdwD2luVPHITV96TkirNBM=\ngithub.com/mitchellh/go-wordwrap v0.0.0-20150314170334-ad45545899c7/go.mod h1:ZXFpozHsX6DPmq2I0TCekCxypsnAUbP2oI0UX1GXzOo=\ngithub.com/mitchellh/go-wordwrap v1.0.1 h1:TLuKupo69TCn6TQSyGxwI1EblZZEsQ0vMlAFQflz0v0=\ngithub.com/mitchellh/go-wordwrap v1.0.1/go.mod h1:R62XHJLzvMFRBbcrT7m7WgmE1eOyTSsCt+hzestvNj0=\ngithub.com/nsf/termbox-go v0.0.0-20190121233118-02980233997d h1:x3S6kxmy49zXVVyhcnrFqxvNVCBPb2KZ9hV2RBdS840=\ngithub.com/nsf/termbox-go v0.0.0-20190121233118-02980233997d/go.mod h1:IuKpRQcYE1Tfu+oAQqaLisqDeXgjyyltCfsaoYN18NQ=\ngithub.com/nsf/termbox-go v1.1.1 h1:nksUPLCb73Q++DwbYUBEglYBRPZyoXJdrj5L+TkjyZY=\ngithub.com/nsf/termbox-go v1.1.1/go.mod h1:T0cTdVuOwf7pHQNtfhnEbzHbcNyCEcVU4YPpouCbVxo=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.4 h1:8TfxU8dW6PdqD27gjM8MVNuicgxIjxpm4K7x4jp8sis=\ngithub.com/rivo/uniseg v0.4.4/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\n"
        },
        {
          "name": "grid.go",
          "type": "blob",
          "size": 3.2109375,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\ntype gridItemType uint\n\nconst (\n\tcol gridItemType = 0\n\trow gridItemType = 1\n)\n\ntype Grid struct {\n\tBlock\n\tItems []*GridItem\n}\n\n// GridItem represents either a Row or Column in a grid.\n// Holds sizing information and either an []GridItems or a widget.\ntype GridItem struct {\n\tType        gridItemType\n\tXRatio      float64\n\tYRatio      float64\n\tWidthRatio  float64\n\tHeightRatio float64\n\tEntry       interface{} // Entry.type == GridBufferer if IsLeaf else []GridItem\n\tIsLeaf      bool\n\tratio       float64\n}\n\nfunc NewGrid() *Grid {\n\tg := &Grid{\n\t\tBlock: *NewBlock(),\n\t}\n\tg.Border = false\n\treturn g\n}\n\n// NewCol takes a height percentage and either a widget or a Row or Column\nfunc NewCol(ratio float64, i ...interface{}) GridItem {\n\t_, ok := i[0].(Drawable)\n\tentry := i[0]\n\tif !ok {\n\t\tentry = i\n\t}\n\treturn GridItem{\n\t\tType:   col,\n\t\tEntry:  entry,\n\t\tIsLeaf: ok,\n\t\tratio:  ratio,\n\t}\n}\n\n// NewRow takes a width percentage and either a widget or a Row or Column\nfunc NewRow(ratio float64, i ...interface{}) GridItem {\n\t_, ok := i[0].(Drawable)\n\tentry := i[0]\n\tif !ok {\n\t\tentry = i\n\t}\n\treturn GridItem{\n\t\tType:   row,\n\t\tEntry:  entry,\n\t\tIsLeaf: ok,\n\t\tratio:  ratio,\n\t}\n}\n\n// Set is used to add Columns and Rows to the grid.\n// It recursively searches the GridItems, adding leaves to the grid and calculating the dimensions of the leaves.\nfunc (self *Grid) Set(entries ...interface{}) {\n\tentry := GridItem{\n\t\tType:   row,\n\t\tEntry:  entries,\n\t\tIsLeaf: false,\n\t\tratio:  1.0,\n\t}\n\tself.setHelper(entry, 1.0, 1.0)\n}\n\nfunc (self *Grid) setHelper(item GridItem, parentWidthRatio, parentHeightRatio float64) {\n\tvar HeightRatio float64\n\tvar WidthRatio float64\n\tswitch item.Type {\n\tcase col:\n\t\tHeightRatio = 1.0\n\t\tWidthRatio = item.ratio\n\tcase row:\n\t\tHeightRatio = item.ratio\n\t\tWidthRatio = 1.0\n\t}\n\titem.WidthRatio = parentWidthRatio * WidthRatio\n\titem.HeightRatio = parentHeightRatio * HeightRatio\n\n\tif item.IsLeaf {\n\t\tself.Items = append(self.Items, &item)\n\t} else {\n\t\tXRatio := 0.0\n\t\tYRatio := 0.0\n\t\tcols := false\n\t\trows := false\n\n\t\tchildren := InterfaceSlice(item.Entry)\n\n\t\tfor i := 0; i < len(children); i++ {\n\t\t\tif children[i] == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tchild, _ := children[i].(GridItem)\n\n\t\t\tchild.XRatio = item.XRatio + (item.WidthRatio * XRatio)\n\t\t\tchild.YRatio = item.YRatio + (item.HeightRatio * YRatio)\n\n\t\t\tswitch child.Type {\n\t\t\tcase col:\n\t\t\t\tcols = true\n\t\t\t\tXRatio += child.ratio\n\t\t\t\tif rows {\n\t\t\t\t\titem.HeightRatio /= 2\n\t\t\t\t}\n\t\t\tcase row:\n\t\t\t\trows = true\n\t\t\t\tYRatio += child.ratio\n\t\t\t\tif cols {\n\t\t\t\t\titem.WidthRatio /= 2\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tself.setHelper(child, item.WidthRatio, item.HeightRatio)\n\t\t}\n\t}\n}\n\nfunc (self *Grid) Draw(buf *Buffer) {\n\twidth := float64(self.Dx()) + 1\n\theight := float64(self.Dy()) + 1\n\n\tfor _, item := range self.Items {\n\t\tentry, _ := item.Entry.(Drawable)\n\n\t\tx := int(width*item.XRatio) + self.Min.X\n\t\ty := int(height*item.YRatio) + self.Min.Y\n\t\tw := int(width * item.WidthRatio)\n\t\th := int(height * item.HeightRatio)\n\n\t\tif x+w > self.Dx() {\n\t\t\tw--\n\t\t}\n\t\tif y+h > self.Dy() {\n\t\t\th--\n\t\t}\n\n\t\tentry.SetRect(x, y, x+w, y+h)\n\n\t\tentry.Lock()\n\t\tentry.Draw(buf)\n\t\tentry.Unlock()\n\t}\n}\n"
        },
        {
          "name": "render.go",
          "type": "blob",
          "size": 0.75,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nimport (\n\t\"image\"\n\t\"sync\"\n\n\ttb \"github.com/nsf/termbox-go\"\n)\n\ntype Drawable interface {\n\tGetRect() image.Rectangle\n\tSetRect(int, int, int, int)\n\tDraw(*Buffer)\n\tsync.Locker\n}\n\nfunc Render(items ...Drawable) {\n\tfor _, item := range items {\n\t\tbuf := NewBuffer(item.GetRect())\n\t\titem.Lock()\n\t\titem.Draw(buf)\n\t\titem.Unlock()\n\t\tfor point, cell := range buf.CellMap {\n\t\t\tif point.In(buf.Rectangle) {\n\t\t\t\ttb.SetCell(\n\t\t\t\t\tpoint.X, point.Y,\n\t\t\t\t\tcell.Rune,\n\t\t\t\t\ttb.Attribute(cell.Style.Fg+1)|tb.Attribute(cell.Style.Modifier), tb.Attribute(cell.Style.Bg+1),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\ttb.Flush()\n}\n"
        },
        {
          "name": "style.go",
          "type": "blob",
          "size": 1.2666015625,
          "content": "package termui\n\n// Color is an integer from -1 to 255\n// -1 = ColorClear\n// 0-255 = Xterm colors\ntype Color int\n\n// ColorClear clears the Fg or Bg color of a Style\nconst ColorClear Color = -1\n\n// Basic terminal colors\nconst (\n\tColorBlack   Color = 0\n\tColorRed     Color = 1\n\tColorGreen   Color = 2\n\tColorYellow  Color = 3\n\tColorBlue    Color = 4\n\tColorMagenta Color = 5\n\tColorCyan    Color = 6\n\tColorWhite   Color = 7\n)\n\ntype Modifier uint\n\nconst (\n\t// ModifierClear clears any modifiers\n\tModifierClear     Modifier = 0\n\tModifierBold      Modifier = 1 << 9\n\tModifierUnderline Modifier = 1 << 10\n\tModifierReverse   Modifier = 1 << 11\n)\n\n// Style represents the style of one terminal cell\ntype Style struct {\n\tFg       Color\n\tBg       Color\n\tModifier Modifier\n}\n\n// StyleClear represents a default Style, with no colors or modifiers\nvar StyleClear = Style{\n\tFg:       ColorClear,\n\tBg:       ColorClear,\n\tModifier: ModifierClear,\n}\n\n// NewStyle takes 1 to 3 arguments\n// 1st argument = Fg\n// 2nd argument = optional Bg\n// 3rd argument = optional Modifier\nfunc NewStyle(fg Color, args ...interface{}) Style {\n\tbg := ColorClear\n\tmodifier := ModifierClear\n\tif len(args) >= 1 {\n\t\tbg = args[0].(Color)\n\t}\n\tif len(args) == 2 {\n\t\tmodifier = args[1].(Modifier)\n\t}\n\treturn Style{\n\t\tfg,\n\t\tbg,\n\t\tmodifier,\n\t}\n}\n"
        },
        {
          "name": "style_parser.go",
          "type": "blob",
          "size": 3.76953125,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nimport (\n\t\"strings\"\n)\n\nconst (\n\ttokenFg       = \"fg\"\n\ttokenBg       = \"bg\"\n\ttokenModifier = \"mod\"\n\n\ttokenItemSeparator  = \",\"\n\ttokenValueSeparator = \":\"\n\n\ttokenBeginStyledText = '['\n\ttokenEndStyledText   = ']'\n\n\ttokenBeginStyle = '('\n\ttokenEndStyle   = ')'\n)\n\ntype parserState uint\n\nconst (\n\tparserStateDefault parserState = iota\n\tparserStateStyleItems\n\tparserStateStyledText\n)\n\n// StyleParserColorMap can be modified to add custom color parsing to text\nvar StyleParserColorMap = map[string]Color{\n\t\"red\":     ColorRed,\n\t\"blue\":    ColorBlue,\n\t\"black\":   ColorBlack,\n\t\"cyan\":    ColorCyan,\n\t\"yellow\":  ColorYellow,\n\t\"white\":   ColorWhite,\n\t\"clear\":   ColorClear,\n\t\"green\":   ColorGreen,\n\t\"magenta\": ColorMagenta,\n}\n\nvar modifierMap = map[string]Modifier{\n\t\"bold\":      ModifierBold,\n\t\"underline\": ModifierUnderline,\n\t\"reverse\":   ModifierReverse,\n}\n\n// readStyle translates an []rune like `fg:red,mod:bold,bg:white` to a style\nfunc readStyle(runes []rune, defaultStyle Style) Style {\n\tstyle := defaultStyle\n\tsplit := strings.Split(string(runes), tokenItemSeparator)\n\tfor _, item := range split {\n\t\tpair := strings.Split(item, tokenValueSeparator)\n\t\tif len(pair) == 2 {\n\t\t\tswitch pair[0] {\n\t\t\tcase tokenFg:\n\t\t\t\tstyle.Fg = StyleParserColorMap[pair[1]]\n\t\t\tcase tokenBg:\n\t\t\t\tstyle.Bg = StyleParserColorMap[pair[1]]\n\t\t\tcase tokenModifier:\n\t\t\t\tstyle.Modifier = modifierMap[pair[1]]\n\t\t\t}\n\t\t}\n\t}\n\treturn style\n}\n\n// ParseStyles parses a string for embedded Styles and returns []Cell with the correct styling.\n// Uses defaultStyle for any text without an embedded style.\n// Syntax is of the form [text](fg:<color>,mod:<attribute>,bg:<color>).\n// Ordering does not matter. All fields are optional.\nfunc ParseStyles(s string, defaultStyle Style) []Cell {\n\tcells := []Cell{}\n\trunes := []rune(s)\n\tstate := parserStateDefault\n\tstyledText := []rune{}\n\tstyleItems := []rune{}\n\tsquareCount := 0\n\n\treset := func() {\n\t\tstyledText = []rune{}\n\t\tstyleItems = []rune{}\n\t\tstate = parserStateDefault\n\t\tsquareCount = 0\n\t}\n\n\trollback := func() {\n\t\tcells = append(cells, RunesToStyledCells(styledText, defaultStyle)...)\n\t\tcells = append(cells, RunesToStyledCells(styleItems, defaultStyle)...)\n\t\treset()\n\t}\n\n\t// chop first and last runes\n\tchop := func(s []rune) []rune {\n\t\treturn s[1 : len(s)-1]\n\t}\n\n\tfor i, _rune := range runes {\n\t\tswitch state {\n\t\tcase parserStateDefault:\n\t\t\tif _rune == tokenBeginStyledText {\n\t\t\t\tstate = parserStateStyledText\n\t\t\t\tsquareCount = 1\n\t\t\t\tstyledText = append(styledText, _rune)\n\t\t\t} else {\n\t\t\t\tcells = append(cells, Cell{_rune, defaultStyle})\n\t\t\t}\n\t\tcase parserStateStyledText:\n\t\t\tswitch {\n\t\t\tcase squareCount == 0:\n\t\t\t\tswitch _rune {\n\t\t\t\tcase tokenBeginStyle:\n\t\t\t\t\tstate = parserStateStyleItems\n\t\t\t\t\tstyleItems = append(styleItems, _rune)\n\t\t\t\tdefault:\n\t\t\t\t\trollback()\n\t\t\t\t\tswitch _rune {\n\t\t\t\t\tcase tokenBeginStyledText:\n\t\t\t\t\t\tstate = parserStateStyledText\n\t\t\t\t\t\tsquareCount = 1\n\t\t\t\t\t\tstyleItems = append(styleItems, _rune)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcells = append(cells, Cell{_rune, defaultStyle})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcase len(runes) == i+1:\n\t\t\t\trollback()\n\t\t\t\tstyledText = append(styledText, _rune)\n\t\t\tcase _rune == tokenBeginStyledText:\n\t\t\t\tsquareCount++\n\t\t\t\tstyledText = append(styledText, _rune)\n\t\t\tcase _rune == tokenEndStyledText:\n\t\t\t\tsquareCount--\n\t\t\t\tstyledText = append(styledText, _rune)\n\t\t\tdefault:\n\t\t\t\tstyledText = append(styledText, _rune)\n\t\t\t}\n\t\tcase parserStateStyleItems:\n\t\t\tstyleItems = append(styleItems, _rune)\n\t\t\tif _rune == tokenEndStyle {\n\t\t\t\tstyle := readStyle(chop(styleItems), defaultStyle)\n\t\t\t\tcells = append(cells, RunesToStyledCells(chop(styledText), style)...)\n\t\t\t\treset()\n\t\t\t} else if len(runes) == i+1 {\n\t\t\t\trollback()\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cells\n}\n"
        },
        {
          "name": "symbols.go",
          "type": "blob",
          "size": 1.10546875,
          "content": "package termui\n\nconst (\n\tDOT      = '•'\n\tELLIPSES = '…'\n\n\tUP_ARROW   = '▲'\n\tDOWN_ARROW = '▼'\n\n\tCOLLAPSED = '+'\n\tEXPANDED  = '−'\n)\n\nvar (\n\tBARS = [...]rune{' ', '▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'}\n\n\tSHADED_BLOCKS = [...]rune{' ', '░', '▒', '▓', '█'}\n\n\tIRREGULAR_BLOCKS = [...]rune{\n\t\t' ', '▘', '▝', '▀', '▖', '▌', '▞', '▛',\n\t\t'▗', '▚', '▐', '▜', '▄', '▙', '▟', '█',\n\t}\n\n\tBRAILLE_OFFSET = '\\u2800'\n\tBRAILLE        = [4][2]rune{\n\t\t{'\\u0001', '\\u0008'},\n\t\t{'\\u0002', '\\u0010'},\n\t\t{'\\u0004', '\\u0020'},\n\t\t{'\\u0040', '\\u0080'},\n\t}\n\n\tDOUBLE_BRAILLE = map[[2]int]rune{\n\t\t[2]int{0, 0}: '⣀',\n\t\t[2]int{0, 1}: '⡠',\n\t\t[2]int{0, 2}: '⡐',\n\t\t[2]int{0, 3}: '⡈',\n\n\t\t[2]int{1, 0}: '⢄',\n\t\t[2]int{1, 1}: '⠤',\n\t\t[2]int{1, 2}: '⠔',\n\t\t[2]int{1, 3}: '⠌',\n\n\t\t[2]int{2, 0}: '⢂',\n\t\t[2]int{2, 1}: '⠢',\n\t\t[2]int{2, 2}: '⠒',\n\t\t[2]int{2, 3}: '⠊',\n\n\t\t[2]int{3, 0}: '⢁',\n\t\t[2]int{3, 1}: '⠡',\n\t\t[2]int{3, 2}: '⠑',\n\t\t[2]int{3, 3}: '⠉',\n\t}\n\n\tSINGLE_BRAILLE_LEFT  = [4]rune{'\\u2840', '⠄', '⠂', '⠁'}\n\tSINGLE_BRAILLE_RIGHT = [4]rune{'\\u2880', '⠠', '⠐', '⠈'}\n)\n"
        },
        {
          "name": "symbols_other.go",
          "type": "blob",
          "size": 0.5361328125,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\n// +build !windows\n\npackage termui\n\nconst (\n\tTOP_LEFT     = '┌'\n\tTOP_RIGHT    = '┐'\n\tBOTTOM_LEFT  = '└'\n\tBOTTOM_RIGHT = '┘'\n\n\tVERTICAL_LINE   = '│'\n\tHORIZONTAL_LINE = '─'\n\n\tVERTICAL_LEFT   = '┤'\n\tVERTICAL_RIGHT  = '├'\n\tHORIZONTAL_UP   = '┴'\n\tHORIZONTAL_DOWN = '┬'\n\n\tQUOTA_LEFT  = '«'\n\tQUOTA_RIGHT = '»'\n\n\tVERTICAL_DASH   = '┊'\n\tHORIZONTAL_DASH = '┈'\n)\n"
        },
        {
          "name": "symbols_windows.go",
          "type": "blob",
          "size": 0.509765625,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\n// +build windows\n\npackage termui\n\nconst (\n\tTOP_LEFT     = '+'\n\tTOP_RIGHT    = '+'\n\tBOTTOM_LEFT  = '+'\n\tBOTTOM_RIGHT = '+'\n\n\tVERTICAL_LINE   = '|'\n\tHORIZONTAL_LINE = '-'\n\n\tVERTICAL_LEFT   = '+'\n\tVERTICAL_RIGHT  = '+'\n\tHORIZONTAL_UP   = '+'\n\tHORIZONTAL_DOWN = '+'\n\n\tQUOTA_LEFT  = '<'\n\tQUOTA_RIGHT = '>'\n\n\tVERTICAL_DASH   = '|'\n\tHORIZONTAL_DASH = '-'\n)\n"
        },
        {
          "name": "theme.go",
          "type": "blob",
          "size": 2.69921875,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nvar StandardColors = []Color{\n\tColorRed,\n\tColorGreen,\n\tColorYellow,\n\tColorBlue,\n\tColorMagenta,\n\tColorCyan,\n\tColorWhite,\n}\n\nvar StandardStyles = []Style{\n\tNewStyle(ColorRed),\n\tNewStyle(ColorGreen),\n\tNewStyle(ColorYellow),\n\tNewStyle(ColorBlue),\n\tNewStyle(ColorMagenta),\n\tNewStyle(ColorCyan),\n\tNewStyle(ColorWhite),\n}\n\ntype RootTheme struct {\n\tDefault Style\n\n\tBlock BlockTheme\n\n\tBarChart        BarChartTheme\n\tGauge           GaugeTheme\n\tPlot            PlotTheme\n\tList            ListTheme\n\tTree            TreeTheme\n\tParagraph       ParagraphTheme\n\tPieChart        PieChartTheme\n\tSparkline       SparklineTheme\n\tStackedBarChart StackedBarChartTheme\n\tTab             TabTheme\n\tTable           TableTheme\n}\n\ntype BlockTheme struct {\n\tTitle  Style\n\tBorder Style\n}\n\ntype BarChartTheme struct {\n\tBars   []Color\n\tNums   []Style\n\tLabels []Style\n}\n\ntype GaugeTheme struct {\n\tBar   Color\n\tLabel Style\n}\n\ntype PlotTheme struct {\n\tLines []Color\n\tAxes  Color\n}\n\ntype ListTheme struct {\n\tText Style\n}\n\ntype TreeTheme struct {\n\tText      Style\n\tCollapsed rune\n\tExpanded  rune\n}\n\ntype ParagraphTheme struct {\n\tText Style\n}\n\ntype PieChartTheme struct {\n\tSlices []Color\n}\n\ntype SparklineTheme struct {\n\tTitle Style\n\tLine  Color\n}\n\ntype StackedBarChartTheme struct {\n\tBars   []Color\n\tNums   []Style\n\tLabels []Style\n}\n\ntype TabTheme struct {\n\tActive   Style\n\tInactive Style\n}\n\ntype TableTheme struct {\n\tText Style\n}\n\n// Theme holds the default Styles and Colors for all widgets.\n// You can set default widget Styles by modifying the Theme before creating the widgets.\nvar Theme = RootTheme{\n\tDefault: NewStyle(ColorWhite),\n\n\tBlock: BlockTheme{\n\t\tTitle:  NewStyle(ColorWhite),\n\t\tBorder: NewStyle(ColorWhite),\n\t},\n\n\tBarChart: BarChartTheme{\n\t\tBars:   StandardColors,\n\t\tNums:   StandardStyles,\n\t\tLabels: StandardStyles,\n\t},\n\n\tParagraph: ParagraphTheme{\n\t\tText: NewStyle(ColorWhite),\n\t},\n\n\tPieChart: PieChartTheme{\n\t\tSlices: StandardColors,\n\t},\n\n\tList: ListTheme{\n\t\tText: NewStyle(ColorWhite),\n\t},\n\n\tTree: TreeTheme{\n\t\tText:      NewStyle(ColorWhite),\n\t\tCollapsed: COLLAPSED,\n\t\tExpanded:  EXPANDED,\n\t},\n\n\tStackedBarChart: StackedBarChartTheme{\n\t\tBars:   StandardColors,\n\t\tNums:   StandardStyles,\n\t\tLabels: StandardStyles,\n\t},\n\n\tGauge: GaugeTheme{\n\t\tBar:   ColorWhite,\n\t\tLabel: NewStyle(ColorWhite),\n\t},\n\n\tSparkline: SparklineTheme{\n\t\tTitle: NewStyle(ColorWhite),\n\t\tLine:  ColorWhite,\n\t},\n\n\tPlot: PlotTheme{\n\t\tLines: StandardColors,\n\t\tAxes:  ColorWhite,\n\t},\n\n\tTable: TableTheme{\n\t\tText: NewStyle(ColorWhite),\n\t},\n\n\tTab: TabTheme{\n\t\tActive:   NewStyle(ColorRed),\n\t\tInactive: NewStyle(ColorWhite),\n\t},\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 4.474609375,
          "content": "// Copyright 2017 Zack Guo <zack.y.guo@gmail.com>. All rights reserved.\n// Use of this source code is governed by a MIT license that can\n// be found in the LICENSE file.\n\npackage termui\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\n\trw \"github.com/mattn/go-runewidth\"\n\twordwrap \"github.com/mitchellh/go-wordwrap\"\n)\n\n// InterfaceSlice takes an []interface{} represented as an interface{} and converts it\n// https://stackoverflow.com/questions/12753805/type-converting-slices-of-interfaces-in-go\nfunc InterfaceSlice(slice interface{}) []interface{} {\n\ts := reflect.ValueOf(slice)\n\tif s.Kind() != reflect.Slice {\n\t\tpanic(\"InterfaceSlice() given a non-slice type\")\n\t}\n\n\tret := make([]interface{}, s.Len())\n\n\tfor i := 0; i < s.Len(); i++ {\n\t\tret[i] = s.Index(i).Interface()\n\t}\n\n\treturn ret\n}\n\n// TrimString trims a string to a max length and adds '…' to the end if it was trimmed.\nfunc TrimString(s string, w int) string {\n\tif w <= 0 {\n\t\treturn \"\"\n\t}\n\tif rw.StringWidth(s) > w {\n\t\treturn rw.Truncate(s, w, string(ELLIPSES))\n\t}\n\treturn s\n}\n\nfunc SelectColor(colors []Color, index int) Color {\n\treturn colors[index%len(colors)]\n}\n\nfunc SelectStyle(styles []Style, index int) Style {\n\treturn styles[index%len(styles)]\n}\n\n// Math ------------------------------------------------------------------------\n\nfunc SumIntSlice(slice []int) int {\n\tsum := 0\n\tfor _, val := range slice {\n\t\tsum += val\n\t}\n\treturn sum\n}\n\nfunc SumFloat64Slice(data []float64) float64 {\n\tsum := 0.0\n\tfor _, v := range data {\n\t\tsum += v\n\t}\n\treturn sum\n}\n\nfunc GetMaxIntFromSlice(slice []int) (int, error) {\n\tif len(slice) == 0 {\n\t\treturn 0, fmt.Errorf(\"cannot get max value from empty slice\")\n\t}\n\tvar max int\n\tfor _, val := range slice {\n\t\tif val > max {\n\t\t\tmax = val\n\t\t}\n\t}\n\treturn max, nil\n}\n\nfunc GetMaxFloat64FromSlice(slice []float64) (float64, error) {\n\tif len(slice) == 0 {\n\t\treturn 0, fmt.Errorf(\"cannot get max value from empty slice\")\n\t}\n\tvar max float64\n\tfor _, val := range slice {\n\t\tif val > max {\n\t\t\tmax = val\n\t\t}\n\t}\n\treturn max, nil\n}\n\nfunc GetMaxFloat64From2dSlice(slices [][]float64) (float64, error) {\n\tif len(slices) == 0 {\n\t\treturn 0, fmt.Errorf(\"cannot get max value from empty slice\")\n\t}\n\tvar max float64\n\tfor _, slice := range slices {\n\t\tfor _, val := range slice {\n\t\t\tif val > max {\n\t\t\t\tmax = val\n\t\t\t}\n\t\t}\n\t}\n\treturn max, nil\n}\n\nfunc RoundFloat64(x float64) float64 {\n\treturn math.Floor(x + 0.5)\n}\n\nfunc FloorFloat64(x float64) float64 {\n\treturn math.Floor(x)\n}\n\nfunc AbsInt(x int) int {\n\tif x >= 0 {\n\t\treturn x\n\t}\n\treturn -x\n}\n\nfunc MinFloat64(x, y float64) float64 {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc MaxFloat64(x, y float64) float64 {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc MaxInt(x, y int) int {\n\tif x > y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nfunc MinInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n// []Cell ----------------------------------------------------------------------\n\n// WrapCells takes []Cell and inserts Cells containing '\\n' wherever a linebreak should go.\nfunc WrapCells(cells []Cell, width uint) []Cell {\n\tstr := CellsToString(cells)\n\twrapped := wordwrap.WrapString(str, width)\n\twrappedCells := []Cell{}\n\ti := 0\n\tfor _, _rune := range wrapped {\n\t\tif _rune == '\\n' {\n\t\t\twrappedCells = append(wrappedCells, Cell{_rune, StyleClear})\n\t\t} else {\n\t\t\twrappedCells = append(wrappedCells, Cell{_rune, cells[i].Style})\n\t\t}\n\t\ti++\n\t}\n\treturn wrappedCells\n}\n\nfunc RunesToStyledCells(runes []rune, style Style) []Cell {\n\tcells := []Cell{}\n\tfor _, _rune := range runes {\n\t\tcells = append(cells, Cell{_rune, style})\n\t}\n\treturn cells\n}\n\nfunc CellsToString(cells []Cell) string {\n\trunes := make([]rune, len(cells))\n\tfor i, cell := range cells {\n\t\trunes[i] = cell.Rune\n\t}\n\treturn string(runes)\n}\n\nfunc TrimCells(cells []Cell, w int) []Cell {\n\ts := CellsToString(cells)\n\ts = TrimString(s, w)\n\trunes := []rune(s)\n\tnewCells := []Cell{}\n\tfor i, r := range runes {\n\t\tnewCells = append(newCells, Cell{r, cells[i].Style})\n\t}\n\treturn newCells\n}\n\nfunc SplitCells(cells []Cell, r rune) [][]Cell {\n\tsplitCells := [][]Cell{}\n\ttemp := []Cell{}\n\tfor _, cell := range cells {\n\t\tif cell.Rune == r {\n\t\t\tsplitCells = append(splitCells, temp)\n\t\t\ttemp = []Cell{}\n\t\t} else {\n\t\t\ttemp = append(temp, cell)\n\t\t}\n\t}\n\tif len(temp) > 0 {\n\t\tsplitCells = append(splitCells, temp)\n\t}\n\treturn splitCells\n}\n\ntype CellWithX struct {\n\tX    int\n\tCell Cell\n}\n\nfunc BuildCellWithXArray(cells []Cell) []CellWithX {\n\tcellWithXArray := make([]CellWithX, len(cells))\n\tindex := 0\n\tfor i, cell := range cells {\n\t\tcellWithXArray[i] = CellWithX{X: index, Cell: cell}\n\t\tindex += rw.RuneWidth(cell.Rune)\n\t}\n\treturn cellWithXArray\n}\n"
        },
        {
          "name": "widgets",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}