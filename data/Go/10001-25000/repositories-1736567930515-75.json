{
  "metadata": {
    "timestamp": 1736567930515,
    "page": 75,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-playground/validator",
      "stars": 17267,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3251953125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\nbin\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n*.test\n*.out\n*.txt\n/**/*.DS_Store\ncover.html\nREADME.html\n.idea\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Dean Karn\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "MAINTAINERS.md",
          "type": "blob",
          "size": 0.439453125,
          "content": "## Maintainers Guide\n\n### Semantic Versioning\nSemantic versioning as defined [here](https://semver.org) must be strictly adhered to.\n\n### External Dependencies\nAny new external dependencies MUST:\n- Have a compatible LICENSE present.\n- Be actively maintained.\n- Be approved by @go-playground/admins\n\n### PR Merge Requirements\n- Up-to-date branch.\n- Passing tests and linting.\n- CODEOWNERS approval.\n- Tests that cover both the Happy and Unhappy paths."
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.390625,
          "content": "GOCMD=go\n\nlinters-install:\n\t@golangci-lint --version >/dev/null 2>&1 || { \\\n\t\techo \"installing linting tools...\"; \\\n\t\tcurl -sfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh| sh -s v1.41.1; \\\n\t}\n\nlint: linters-install\n\tgolangci-lint run\n\ntest:\n\t$(GOCMD) test -cover -race ./...\n\nbench:\n\t$(GOCMD) test -run=NONE -bench=. -benchmem ./...\n\n.PHONY: test lint linters-install\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.1181640625,
          "content": "Package validator\n=================\n<img align=\"right\" src=\"logo.png\">[![Join the chat at https://gitter.im/go-playground/validator](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/go-playground/validator?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n![Project status](https://img.shields.io/badge/version-10.23.0-green.svg)\n[![Build Status](https://travis-ci.org/go-playground/validator.svg?branch=master)](https://travis-ci.org/go-playground/validator)\n[![Coverage Status](https://coveralls.io/repos/go-playground/validator/badge.svg?branch=master&service=github)](https://coveralls.io/github/go-playground/validator?branch=master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/go-playground/validator)](https://goreportcard.com/report/github.com/go-playground/validator)\n[![GoDoc](https://godoc.org/github.com/go-playground/validator?status.svg)](https://pkg.go.dev/github.com/go-playground/validator/v10)\n![License](https://img.shields.io/dub/l/vibe-d.svg)\n\nPackage validator implements value validations for structs and individual fields based on tags.\n\nIt has the following **unique** features:\n\n-   Cross Field and Cross Struct validations by using validation tags or custom validators.\n-   Slice, Array and Map diving, which allows any or all levels of a multidimensional field to be validated.\n-   Ability to dive into both map keys and values for validation\n-   Handles type interface by determining it's underlying type prior to validation.\n-   Handles custom field types such as sql driver Valuer see [Valuer](https://golang.org/src/database/sql/driver/types.go?s=1210:1293#L29)\n-   Alias validation tags, which allows for mapping of several validations to a single tag for easier defining of validations on structs\n-   Extraction of custom defined Field Name e.g. can specify to extract the JSON name while validating and have it available in the resulting FieldError\n-   Customizable i18n aware error messages.\n-   Default validator for the [gin](https://github.com/gin-gonic/gin) web framework; upgrading from v8 to v9 in gin see [here](https://github.com/go-playground/validator/tree/master/_examples/gin-upgrading-overriding)\n\nA Call for Maintainers\n----------------------\n\nPlease read the discussiong started [here](https://github.com/go-playground/validator/discussions/1330) if you are interested in contributing/helping maintain this package.\n\nInstallation\n------------\n\nUse go get.\n\n\tgo get github.com/go-playground/validator/v10\n\nThen import the validator package into your own code.\n\n\timport \"github.com/go-playground/validator/v10\"\n\nError Return Value\n-------\n\nValidation functions return type error\n\nThey return type error to avoid the issue discussed in the following, where err is always != nil:\n\n* http://stackoverflow.com/a/29138676/3158232\n* https://github.com/go-playground/validator/issues/134\n\nValidator returns only InvalidValidationError for bad validation input, nil or ValidationErrors as type error; so, in your code all you need to do is check if the error returned is not nil, and if it's not check if error is InvalidValidationError ( if necessary, most of the time it isn't ) type cast it to type ValidationErrors like so:\n\n```go\nerr := validate.Struct(mystruct)\nvalidationErrors := err.(validator.ValidationErrors)\n ```\n\nUsage and documentation\n------\n\nPlease see https://pkg.go.dev/github.com/go-playground/validator/v10 for detailed usage docs.\n\n##### Examples:\n\n- [Simple](https://github.com/go-playground/validator/blob/master/_examples/simple/main.go)\n- [Custom Field Types](https://github.com/go-playground/validator/blob/master/_examples/custom/main.go)\n- [Struct Level](https://github.com/go-playground/validator/blob/master/_examples/struct-level/main.go)\n- [Translations & Custom Errors](https://github.com/go-playground/validator/blob/master/_examples/translations/main.go)\n- [Gin upgrade and/or override validator](https://github.com/go-playground/validator/tree/v9/_examples/gin-upgrading-overriding)\n- [wash - an example application putting it all together](https://github.com/bluesuncorp/wash)\n\nBaked-in Validations\n------\n\n### Special Notes:\n- If new to using validator it is highly recommended to initialize it using the `WithRequiredStructEnabled` option which is opt-in to new behaviour that will become the default behaviour in v11+. See documentation for more details.\n```go\nvalidate := validator.New(validator.WithRequiredStructEnabled())\n```\n\n### Fields:\n\n| Tag | Description |\n| - | - |\n| eqcsfield | Field Equals Another Field (relative)|\n| eqfield | Field Equals Another Field |\n| fieldcontains | Check the indicated characters are present in the Field |\n| fieldexcludes | Check the indicated characters are not present in the field |\n| gtcsfield | Field Greater Than Another Relative Field |\n| gtecsfield | Field Greater Than or Equal To Another Relative Field |\n| gtefield | Field Greater Than or Equal To Another Field |\n| gtfield | Field Greater Than Another Field |\n| ltcsfield | Less Than Another Relative Field |\n| ltecsfield | Less Than or Equal To Another Relative Field |\n| ltefield | Less Than or Equal To Another Field |\n| ltfield | Less Than Another Field |\n| necsfield | Field Does Not Equal Another Field (relative) |\n| nefield | Field Does Not Equal Another Field |\n\n### Network:\n\n| Tag | Description |\n| - | - |\n| cidr | Classless Inter-Domain Routing CIDR |\n| cidrv4 | Classless Inter-Domain Routing CIDRv4 |\n| cidrv6 | Classless Inter-Domain Routing CIDRv6 |\n| datauri | Data URL |\n| fqdn | Full Qualified Domain Name (FQDN) |\n| hostname | Hostname RFC 952 |\n| hostname_port | HostPort |\n| hostname_rfc1123 | Hostname RFC 1123 |\n| ip | Internet Protocol Address IP |\n| ip4_addr | Internet Protocol Address IPv4 |\n| ip6_addr | Internet Protocol Address IPv6 |\n| ip_addr | Internet Protocol Address IP |\n| ipv4 | Internet Protocol Address IPv4 |\n| ipv6 | Internet Protocol Address IPv6 |\n| mac | Media Access Control Address MAC |\n| tcp4_addr | Transmission Control Protocol Address TCPv4 |\n| tcp6_addr | Transmission Control Protocol Address TCPv6 |\n| tcp_addr | Transmission Control Protocol Address TCP |\n| udp4_addr | User Datagram Protocol Address UDPv4 |\n| udp6_addr | User Datagram Protocol Address UDPv6 |\n| udp_addr | User Datagram Protocol Address UDP |\n| unix_addr | Unix domain socket end point Address |\n| uri | URI String |\n| url | URL String |\n| http_url | HTTP URL String |\n| url_encoded | URL Encoded |\n| urn_rfc2141 | Urn RFC 2141 String |\n\n### Strings:\n\n| Tag | Description |\n| - | - |\n| alpha | Alpha Only |\n| alphanum | Alphanumeric |\n| alphanumunicode | Alphanumeric Unicode |\n| alphaunicode | Alpha Unicode |\n| ascii | ASCII |\n| boolean | Boolean |\n| contains | Contains |\n| containsany | Contains Any |\n| containsrune | Contains Rune |\n| endsnotwith | Ends Not With |\n| endswith | Ends With |\n| excludes | Excludes |\n| excludesall | Excludes All |\n| excludesrune | Excludes Rune |\n| lowercase | Lowercase |\n| multibyte | Multi-Byte Characters |\n| number | Number |\n| numeric | Numeric |\n| printascii | Printable ASCII |\n| startsnotwith | Starts Not With |\n| startswith | Starts With |\n| uppercase | Uppercase |\n\n### Format:\n| Tag | Description |\n| - | - |\n| base64 | Base64 String |\n| base64url | Base64URL String |\n| base64rawurl | Base64RawURL String |\n| bic | Business Identifier Code (ISO 9362) |\n| bcp47_language_tag | Language tag (BCP 47) |\n| btc_addr | Bitcoin Address |\n| btc_addr_bech32 | Bitcoin Bech32 Address (segwit) |\n| credit_card | Credit Card Number |\n| mongodb | MongoDB ObjectID |\n| mongodb_connection_string | MongoDB Connection String |\n| cron | Cron |\n| spicedb | SpiceDb ObjectID/Permission/Type |\n| datetime | Datetime |\n| e164 | e164 formatted phone number |\n| email | E-mail String\n| eth_addr | Ethereum Address |\n| hexadecimal | Hexadecimal String |\n| hexcolor | Hexcolor String |\n| hsl | HSL String |\n| hsla | HSLA String |\n| html | HTML Tags |\n| html_encoded | HTML Encoded |\n| isbn | International Standard Book Number |\n| isbn10 | International Standard Book Number 10 |\n| isbn13 | International Standard Book Number 13 |\n| issn | International Standard Serial Number |\n| iso3166_1_alpha2 | Two-letter country code (ISO 3166-1 alpha-2) |\n| iso3166_1_alpha3 | Three-letter country code (ISO 3166-1 alpha-3) |\n| iso3166_1_alpha_numeric | Numeric country code (ISO 3166-1 numeric) |\n| iso3166_2 | Country subdivision code (ISO 3166-2) |\n| iso4217 | Currency code (ISO 4217) |\n| json | JSON |\n| jwt | JSON Web Token (JWT) |\n| latitude | Latitude |\n| longitude | Longitude |\n| luhn_checksum | Luhn Algorithm Checksum (for strings and (u)int) |\n| postcode_iso3166_alpha2 | Postcode |\n| postcode_iso3166_alpha2_field | Postcode |\n| rgb | RGB String |\n| rgba | RGBA String |\n| ssn | Social Security Number SSN |\n| timezone | Timezone |\n| uuid | Universally Unique Identifier UUID |\n| uuid3 | Universally Unique Identifier UUID v3 |\n| uuid3_rfc4122 | Universally Unique Identifier UUID v3 RFC4122 |\n| uuid4 | Universally Unique Identifier UUID v4 |\n| uuid4_rfc4122 | Universally Unique Identifier UUID v4 RFC4122 |\n| uuid5 | Universally Unique Identifier UUID v5 |\n| uuid5_rfc4122 | Universally Unique Identifier UUID v5 RFC4122 |\n| uuid_rfc4122 | Universally Unique Identifier UUID RFC4122 |\n| md4 | MD4 hash |\n| md5 | MD5 hash |\n| sha256 | SHA256 hash |\n| sha384 | SHA384 hash |\n| sha512 | SHA512 hash |\n| ripemd128 | RIPEMD-128 hash |\n| ripemd128 | RIPEMD-160 hash |\n| tiger128 | TIGER128 hash |\n| tiger160 | TIGER160 hash |\n| tiger192 | TIGER192 hash |\n| semver | Semantic Versioning 2.0.0 |\n| ulid | Universally Unique Lexicographically Sortable Identifier ULID |\n| cve | Common Vulnerabilities and Exposures Identifier (CVE id) |\n\n### Comparisons:\n| Tag | Description |\n| - | - |\n| eq | Equals |\n| eq_ignore_case | Equals ignoring case |\n| gt | Greater than|\n| gte | Greater than or equal |\n| lt | Less Than |\n| lte | Less Than or Equal |\n| ne | Not Equal |\n| ne_ignore_case | Not Equal ignoring case |\n\n### Other:\n| Tag | Description |\n| - | - |\n| dir | Existing Directory |\n| dirpath | Directory Path |\n| file | Existing File |\n| filepath | File Path |\n| image | Image |\n| isdefault | Is Default |\n| len | Length |\n| max | Maximum |\n| min | Minimum |\n| oneof | One Of |\n| required | Required |\n| required_if | Required If |\n| required_unless | Required Unless |\n| required_with | Required With |\n| required_with_all | Required With All |\n| required_without | Required Without |\n| required_without_all | Required Without All |\n| excluded_if | Excluded If |\n| excluded_unless | Excluded Unless |\n| excluded_with | Excluded With |\n| excluded_with_all | Excluded With All |\n| excluded_without | Excluded Without |\n| excluded_without_all | Excluded Without All |\n| unique | Unique |\n\n#### Aliases:\n| Tag | Description |\n| - | - |\n| iscolor | hexcolor\\|rgb\\|rgba\\|hsl\\|hsla |\n| country_code | iso3166_1_alpha2\\|iso3166_1_alpha3\\|iso3166_1_alpha_numeric |\n\nBenchmarks\n------\n###### Run on MacBook Pro (15-inch, 2017) go version go1.10.2 darwin/amd64\n```go\ngo version go1.21.0 darwin/arm64\ngoos: darwin\ngoarch: arm64\npkg: github.com/go-playground/validator/v10\nBenchmarkFieldSuccess-8                                         33142266                35.94 ns/op            0 B/op          0 allocs/op\nBenchmarkFieldSuccessParallel-8                                 200816191                6.568 ns/op           0 B/op          0 allocs/op\nBenchmarkFieldFailure-8                                          6779707               175.1 ns/op           200 B/op          4 allocs/op\nBenchmarkFieldFailureParallel-8                                 11044147               108.4 ns/op           200 B/op          4 allocs/op\nBenchmarkFieldArrayDiveSuccess-8                                 6054232               194.4 ns/op            97 B/op          5 allocs/op\nBenchmarkFieldArrayDiveSuccessParallel-8                        12523388                94.07 ns/op           97 B/op          5 allocs/op\nBenchmarkFieldArrayDiveFailure-8                                 3587043               334.3 ns/op           300 B/op         10 allocs/op\nBenchmarkFieldArrayDiveFailureParallel-8                         5816665               200.8 ns/op           300 B/op         10 allocs/op\nBenchmarkFieldMapDiveSuccess-8                                   2217910               540.1 ns/op           288 B/op         14 allocs/op\nBenchmarkFieldMapDiveSuccessParallel-8                           4446698               258.7 ns/op           288 B/op         14 allocs/op\nBenchmarkFieldMapDiveFailure-8                                   2392759               504.6 ns/op           376 B/op         13 allocs/op\nBenchmarkFieldMapDiveFailureParallel-8                           4244199               286.9 ns/op           376 B/op         13 allocs/op\nBenchmarkFieldMapDiveWithKeysSuccess-8                           2005857               592.1 ns/op           288 B/op         14 allocs/op\nBenchmarkFieldMapDiveWithKeysSuccessParallel-8                   4400850               296.9 ns/op           288 B/op         14 allocs/op\nBenchmarkFieldMapDiveWithKeysFailure-8                           1850227               643.8 ns/op           553 B/op         16 allocs/op\nBenchmarkFieldMapDiveWithKeysFailureParallel-8                   3293233               375.1 ns/op           553 B/op         16 allocs/op\nBenchmarkFieldCustomTypeSuccess-8                               12174412                98.25 ns/op           32 B/op          2 allocs/op\nBenchmarkFieldCustomTypeSuccessParallel-8                       34389907                35.49 ns/op           32 B/op          2 allocs/op\nBenchmarkFieldCustomTypeFailure-8                                7582524               156.6 ns/op           184 B/op          3 allocs/op\nBenchmarkFieldCustomTypeFailureParallel-8                       13019902                92.79 ns/op          184 B/op          3 allocs/op\nBenchmarkFieldOrTagSuccess-8                                     3427260               349.4 ns/op            16 B/op          1 allocs/op\nBenchmarkFieldOrTagSuccessParallel-8                            15144128                81.25 ns/op           16 B/op          1 allocs/op\nBenchmarkFieldOrTagFailure-8                                     5913546               201.9 ns/op           216 B/op          5 allocs/op\nBenchmarkFieldOrTagFailureParallel-8                             9810212               113.7 ns/op           216 B/op          5 allocs/op\nBenchmarkStructLevelValidationSuccess-8                         13456327                87.66 ns/op           16 B/op          1 allocs/op\nBenchmarkStructLevelValidationSuccessParallel-8                 41818888                27.77 ns/op           16 B/op          1 allocs/op\nBenchmarkStructLevelValidationFailure-8                          4166284               272.6 ns/op           264 B/op          7 allocs/op\nBenchmarkStructLevelValidationFailureParallel-8                  7594581               152.1 ns/op           264 B/op          7 allocs/op\nBenchmarkStructSimpleCustomTypeSuccess-8                         6508082               182.6 ns/op            32 B/op          2 allocs/op\nBenchmarkStructSimpleCustomTypeSuccessParallel-8                23078605                54.78 ns/op           32 B/op          2 allocs/op\nBenchmarkStructSimpleCustomTypeFailure-8                         3118352               381.0 ns/op           416 B/op          9 allocs/op\nBenchmarkStructSimpleCustomTypeFailureParallel-8                 5300738               224.1 ns/op           432 B/op         10 allocs/op\nBenchmarkStructFilteredSuccess-8                                 4761807               251.1 ns/op           216 B/op          5 allocs/op\nBenchmarkStructFilteredSuccessParallel-8                         8792598               128.6 ns/op           216 B/op          5 allocs/op\nBenchmarkStructFilteredFailure-8                                 5202573               232.1 ns/op           216 B/op          5 allocs/op\nBenchmarkStructFilteredFailureParallel-8                         9591267               121.4 ns/op           216 B/op          5 allocs/op\nBenchmarkStructPartialSuccess-8                                  5188512               231.6 ns/op           224 B/op          4 allocs/op\nBenchmarkStructPartialSuccessParallel-8                          9179776               123.1 ns/op           224 B/op          4 allocs/op\nBenchmarkStructPartialFailure-8                                  3071212               392.5 ns/op           440 B/op          9 allocs/op\nBenchmarkStructPartialFailureParallel-8                          5344261               223.7 ns/op           440 B/op          9 allocs/op\nBenchmarkStructExceptSuccess-8                                   3184230               375.0 ns/op           424 B/op          8 allocs/op\nBenchmarkStructExceptSuccessParallel-8                          10090130               108.9 ns/op           208 B/op          3 allocs/op\nBenchmarkStructExceptFailure-8                                   3347226               357.7 ns/op           424 B/op          8 allocs/op\nBenchmarkStructExceptFailureParallel-8                           5654923               209.5 ns/op           424 B/op          8 allocs/op\nBenchmarkStructSimpleCrossFieldSuccess-8                         5232265               229.1 ns/op            56 B/op          3 allocs/op\nBenchmarkStructSimpleCrossFieldSuccessParallel-8                17436674                64.75 ns/op           56 B/op          3 allocs/op\nBenchmarkStructSimpleCrossFieldFailure-8                         3128613               383.6 ns/op           272 B/op          8 allocs/op\nBenchmarkStructSimpleCrossFieldFailureParallel-8                 6994113               168.8 ns/op           272 B/op          8 allocs/op\nBenchmarkStructSimpleCrossStructCrossFieldSuccess-8              3506487               340.9 ns/op            64 B/op          4 allocs/op\nBenchmarkStructSimpleCrossStructCrossFieldSuccessParallel-8     13431300                91.77 ns/op           64 B/op          4 allocs/op\nBenchmarkStructSimpleCrossStructCrossFieldFailure-8              2410566               500.9 ns/op           288 B/op          9 allocs/op\nBenchmarkStructSimpleCrossStructCrossFieldFailureParallel-8      6344510               188.2 ns/op           288 B/op          9 allocs/op\nBenchmarkStructSimpleSuccess-8                                   8922726               133.8 ns/op             0 B/op          0 allocs/op\nBenchmarkStructSimpleSuccessParallel-8                          55291153                23.63 ns/op            0 B/op          0 allocs/op\nBenchmarkStructSimpleFailure-8                                   3171553               378.4 ns/op           416 B/op          9 allocs/op\nBenchmarkStructSimpleFailureParallel-8                           5571692               212.0 ns/op           416 B/op          9 allocs/op\nBenchmarkStructComplexSuccess-8                                  1683750               714.5 ns/op           224 B/op          5 allocs/op\nBenchmarkStructComplexSuccessParallel-8                          4578046               257.0 ns/op           224 B/op          5 allocs/op\nBenchmarkStructComplexFailure-8                                   481585              2547 ns/op            3041 B/op         48 allocs/op\nBenchmarkStructComplexFailureParallel-8                           965764              1577 ns/op            3040 B/op         48 allocs/op\nBenchmarkOneof-8                                                17380881                68.50 ns/op            0 B/op          0 allocs/op\nBenchmarkOneofParallel-8                                         8084733               153.5 ns/op             0 B/op          0 allocs/op\n```\n\nComplementary Software\n----------------------\n\nHere is a list of software that complements using this library either pre or post validation.\n\n* [form](https://github.com/go-playground/form) - Decodes url.Values into Go value(s) and Encodes Go value(s) into url.Values. Dual Array and Full map support.\n* [mold](https://github.com/go-playground/mold) - A general library to help modify or set data within data structures and other objects\n\nHow to Contribute\n------\n\nMake a pull request...\n\nLicense\n-------\nDistributed under MIT License, please see license file within the code for more details.\n\nMaintainers\n-----------\nThis project has grown large enough that more than one person is required to properly support the community.\nIf you are interested in becoming a maintainer please reach out to me https://github.com/deankarn\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "baked_in.go",
          "type": "blob",
          "size": 87.751953125,
          "content": "package validator\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"net\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"golang.org/x/crypto/sha3\"\n\t\"golang.org/x/text/language\"\n\n\t\"github.com/gabriel-vasile/mimetype\"\n\turn \"github.com/leodido/go-urn\"\n)\n\n// Func accepts a FieldLevel interface for all validation needs. The return\n// value should be true when validation succeeds.\ntype Func func(fl FieldLevel) bool\n\n// FuncCtx accepts a context.Context and FieldLevel interface for all\n// validation needs. The return value should be true when validation succeeds.\ntype FuncCtx func(ctx context.Context, fl FieldLevel) bool\n\n// wrapFunc wraps normal Func makes it compatible with FuncCtx\nfunc wrapFunc(fn Func) FuncCtx {\n\tif fn == nil {\n\t\treturn nil // be sure not to wrap a bad function.\n\t}\n\treturn func(ctx context.Context, fl FieldLevel) bool {\n\t\treturn fn(fl)\n\t}\n}\n\nvar (\n\trestrictedTags = map[string]struct{}{\n\t\tdiveTag:           {},\n\t\tkeysTag:           {},\n\t\tendKeysTag:        {},\n\t\tstructOnlyTag:     {},\n\t\tomitempty:         {},\n\t\tomitnil:           {},\n\t\tskipValidationTag: {},\n\t\tutf8HexComma:      {},\n\t\tutf8Pipe:          {},\n\t\tnoStructLevelTag:  {},\n\t\trequiredTag:       {},\n\t\tisdefault:         {},\n\t}\n\n\t// bakedInAliases is a default mapping of a single validation tag that\n\t// defines a common or complex set of validation(s) to simplify\n\t// adding validation to structs.\n\tbakedInAliases = map[string]string{\n\t\t\"iscolor\":         \"hexcolor|rgb|rgba|hsl|hsla\",\n\t\t\"country_code\":    \"iso3166_1_alpha2|iso3166_1_alpha3|iso3166_1_alpha_numeric\",\n\t\t\"eu_country_code\": \"iso3166_1_alpha2_eu|iso3166_1_alpha3_eu|iso3166_1_alpha_numeric_eu\",\n\t}\n\n\t// bakedInValidators is the default map of ValidationFunc\n\t// you can add, remove or even replace items to suite your needs,\n\t// or even disregard and use your own map if so desired.\n\tbakedInValidators = map[string]Func{\n\t\t\"required\":                      hasValue,\n\t\t\"required_if\":                   requiredIf,\n\t\t\"required_unless\":               requiredUnless,\n\t\t\"skip_unless\":                   skipUnless,\n\t\t\"required_with\":                 requiredWith,\n\t\t\"required_with_all\":             requiredWithAll,\n\t\t\"required_without\":              requiredWithout,\n\t\t\"required_without_all\":          requiredWithoutAll,\n\t\t\"excluded_if\":                   excludedIf,\n\t\t\"excluded_unless\":               excludedUnless,\n\t\t\"excluded_with\":                 excludedWith,\n\t\t\"excluded_with_all\":             excludedWithAll,\n\t\t\"excluded_without\":              excludedWithout,\n\t\t\"excluded_without_all\":          excludedWithoutAll,\n\t\t\"isdefault\":                     isDefault,\n\t\t\"len\":                           hasLengthOf,\n\t\t\"min\":                           hasMinOf,\n\t\t\"max\":                           hasMaxOf,\n\t\t\"eq\":                            isEq,\n\t\t\"eq_ignore_case\":                isEqIgnoreCase,\n\t\t\"ne\":                            isNe,\n\t\t\"ne_ignore_case\":                isNeIgnoreCase,\n\t\t\"lt\":                            isLt,\n\t\t\"lte\":                           isLte,\n\t\t\"gt\":                            isGt,\n\t\t\"gte\":                           isGte,\n\t\t\"eqfield\":                       isEqField,\n\t\t\"eqcsfield\":                     isEqCrossStructField,\n\t\t\"necsfield\":                     isNeCrossStructField,\n\t\t\"gtcsfield\":                     isGtCrossStructField,\n\t\t\"gtecsfield\":                    isGteCrossStructField,\n\t\t\"ltcsfield\":                     isLtCrossStructField,\n\t\t\"ltecsfield\":                    isLteCrossStructField,\n\t\t\"nefield\":                       isNeField,\n\t\t\"gtefield\":                      isGteField,\n\t\t\"gtfield\":                       isGtField,\n\t\t\"ltefield\":                      isLteField,\n\t\t\"ltfield\":                       isLtField,\n\t\t\"fieldcontains\":                 fieldContains,\n\t\t\"fieldexcludes\":                 fieldExcludes,\n\t\t\"alpha\":                         isAlpha,\n\t\t\"alphanum\":                      isAlphanum,\n\t\t\"alphaunicode\":                  isAlphaUnicode,\n\t\t\"alphanumunicode\":               isAlphanumUnicode,\n\t\t\"boolean\":                       isBoolean,\n\t\t\"numeric\":                       isNumeric,\n\t\t\"number\":                        isNumber,\n\t\t\"hexadecimal\":                   isHexadecimal,\n\t\t\"hexcolor\":                      isHEXColor,\n\t\t\"rgb\":                           isRGB,\n\t\t\"rgba\":                          isRGBA,\n\t\t\"hsl\":                           isHSL,\n\t\t\"hsla\":                          isHSLA,\n\t\t\"e164\":                          isE164,\n\t\t\"email\":                         isEmail,\n\t\t\"url\":                           isURL,\n\t\t\"http_url\":                      isHttpURL,\n\t\t\"uri\":                           isURI,\n\t\t\"urn_rfc2141\":                   isUrnRFC2141, // RFC 2141\n\t\t\"file\":                          isFile,\n\t\t\"filepath\":                      isFilePath,\n\t\t\"base32\":                        isBase32,\n\t\t\"base64\":                        isBase64,\n\t\t\"base64url\":                     isBase64URL,\n\t\t\"base64rawurl\":                  isBase64RawURL,\n\t\t\"contains\":                      contains,\n\t\t\"containsany\":                   containsAny,\n\t\t\"containsrune\":                  containsRune,\n\t\t\"excludes\":                      excludes,\n\t\t\"excludesall\":                   excludesAll,\n\t\t\"excludesrune\":                  excludesRune,\n\t\t\"startswith\":                    startsWith,\n\t\t\"endswith\":                      endsWith,\n\t\t\"startsnotwith\":                 startsNotWith,\n\t\t\"endsnotwith\":                   endsNotWith,\n\t\t\"image\":                         isImage,\n\t\t\"isbn\":                          isISBN,\n\t\t\"isbn10\":                        isISBN10,\n\t\t\"isbn13\":                        isISBN13,\n\t\t\"issn\":                          isISSN,\n\t\t\"eth_addr\":                      isEthereumAddress,\n\t\t\"eth_addr_checksum\":             isEthereumAddressChecksum,\n\t\t\"btc_addr\":                      isBitcoinAddress,\n\t\t\"btc_addr_bech32\":               isBitcoinBech32Address,\n\t\t\"uuid\":                          isUUID,\n\t\t\"uuid3\":                         isUUID3,\n\t\t\"uuid4\":                         isUUID4,\n\t\t\"uuid5\":                         isUUID5,\n\t\t\"uuid_rfc4122\":                  isUUIDRFC4122,\n\t\t\"uuid3_rfc4122\":                 isUUID3RFC4122,\n\t\t\"uuid4_rfc4122\":                 isUUID4RFC4122,\n\t\t\"uuid5_rfc4122\":                 isUUID5RFC4122,\n\t\t\"ulid\":                          isULID,\n\t\t\"md4\":                           isMD4,\n\t\t\"md5\":                           isMD5,\n\t\t\"sha256\":                        isSHA256,\n\t\t\"sha384\":                        isSHA384,\n\t\t\"sha512\":                        isSHA512,\n\t\t\"ripemd128\":                     isRIPEMD128,\n\t\t\"ripemd160\":                     isRIPEMD160,\n\t\t\"tiger128\":                      isTIGER128,\n\t\t\"tiger160\":                      isTIGER160,\n\t\t\"tiger192\":                      isTIGER192,\n\t\t\"ascii\":                         isASCII,\n\t\t\"printascii\":                    isPrintableASCII,\n\t\t\"multibyte\":                     hasMultiByteCharacter,\n\t\t\"datauri\":                       isDataURI,\n\t\t\"latitude\":                      isLatitude,\n\t\t\"longitude\":                     isLongitude,\n\t\t\"ssn\":                           isSSN,\n\t\t\"ipv4\":                          isIPv4,\n\t\t\"ipv6\":                          isIPv6,\n\t\t\"ip\":                            isIP,\n\t\t\"cidrv4\":                        isCIDRv4,\n\t\t\"cidrv6\":                        isCIDRv6,\n\t\t\"cidr\":                          isCIDR,\n\t\t\"tcp4_addr\":                     isTCP4AddrResolvable,\n\t\t\"tcp6_addr\":                     isTCP6AddrResolvable,\n\t\t\"tcp_addr\":                      isTCPAddrResolvable,\n\t\t\"udp4_addr\":                     isUDP4AddrResolvable,\n\t\t\"udp6_addr\":                     isUDP6AddrResolvable,\n\t\t\"udp_addr\":                      isUDPAddrResolvable,\n\t\t\"ip4_addr\":                      isIP4AddrResolvable,\n\t\t\"ip6_addr\":                      isIP6AddrResolvable,\n\t\t\"ip_addr\":                       isIPAddrResolvable,\n\t\t\"unix_addr\":                     isUnixAddrResolvable,\n\t\t\"mac\":                           isMAC,\n\t\t\"hostname\":                      isHostnameRFC952,  // RFC 952\n\t\t\"hostname_rfc1123\":              isHostnameRFC1123, // RFC 1123\n\t\t\"fqdn\":                          isFQDN,\n\t\t\"unique\":                        isUnique,\n\t\t\"oneof\":                         isOneOf,\n\t\t\"oneofci\":                       isOneOfCI,\n\t\t\"html\":                          isHTML,\n\t\t\"html_encoded\":                  isHTMLEncoded,\n\t\t\"url_encoded\":                   isURLEncoded,\n\t\t\"dir\":                           isDir,\n\t\t\"dirpath\":                       isDirPath,\n\t\t\"json\":                          isJSON,\n\t\t\"jwt\":                           isJWT,\n\t\t\"hostname_port\":                 isHostnamePort,\n\t\t\"port\":                          isPort,\n\t\t\"lowercase\":                     isLowercase,\n\t\t\"uppercase\":                     isUppercase,\n\t\t\"datetime\":                      isDatetime,\n\t\t\"timezone\":                      isTimeZone,\n\t\t\"iso3166_1_alpha2\":              isIso3166Alpha2,\n\t\t\"iso3166_1_alpha2_eu\":           isIso3166Alpha2EU,\n\t\t\"iso3166_1_alpha3\":              isIso3166Alpha3,\n\t\t\"iso3166_1_alpha3_eu\":           isIso3166Alpha3EU,\n\t\t\"iso3166_1_alpha_numeric\":       isIso3166AlphaNumeric,\n\t\t\"iso3166_1_alpha_numeric_eu\":    isIso3166AlphaNumericEU,\n\t\t\"iso3166_2\":                     isIso31662,\n\t\t\"iso4217\":                       isIso4217,\n\t\t\"iso4217_numeric\":               isIso4217Numeric,\n\t\t\"bcp47_language_tag\":            isBCP47LanguageTag,\n\t\t\"postcode_iso3166_alpha2\":       isPostcodeByIso3166Alpha2,\n\t\t\"postcode_iso3166_alpha2_field\": isPostcodeByIso3166Alpha2Field,\n\t\t\"bic\":                           isIsoBicFormat,\n\t\t\"semver\":                        isSemverFormat,\n\t\t\"dns_rfc1035_label\":             isDnsRFC1035LabelFormat,\n\t\t\"credit_card\":                   isCreditCard,\n\t\t\"cve\":                           isCveFormat,\n\t\t\"luhn_checksum\":                 hasLuhnChecksum,\n\t\t\"mongodb\":                       isMongoDBObjectId,\n\t\t\"mongodb_connection_string\":     isMongoDBConnectionString,\n\t\t\"cron\":                          isCron,\n\t\t\"spicedb\":                       isSpiceDB,\n\t}\n)\n\nvar (\n\toneofValsCache       = map[string][]string{}\n\toneofValsCacheRWLock = sync.RWMutex{}\n)\n\nfunc parseOneOfParam2(s string) []string {\n\toneofValsCacheRWLock.RLock()\n\tvals, ok := oneofValsCache[s]\n\toneofValsCacheRWLock.RUnlock()\n\tif !ok {\n\t\toneofValsCacheRWLock.Lock()\n\t\tvals = splitParamsRegex().FindAllString(s, -1)\n\t\tfor i := 0; i < len(vals); i++ {\n\t\t\tvals[i] = strings.Replace(vals[i], \"'\", \"\", -1)\n\t\t}\n\t\toneofValsCache[s] = vals\n\t\toneofValsCacheRWLock.Unlock()\n\t}\n\treturn vals\n}\n\nfunc isURLEncoded(fl FieldLevel) bool {\n\treturn uRLEncodedRegex().MatchString(fl.Field().String())\n}\n\nfunc isHTMLEncoded(fl FieldLevel) bool {\n\treturn hTMLEncodedRegex().MatchString(fl.Field().String())\n}\n\nfunc isHTML(fl FieldLevel) bool {\n\treturn hTMLRegex().MatchString(fl.Field().String())\n}\n\nfunc isOneOf(fl FieldLevel) bool {\n\tvals := parseOneOfParam2(fl.Param())\n\n\tfield := fl.Field()\n\n\tvar v string\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tv = field.String()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tv = strconv.FormatInt(field.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tv = strconv.FormatUint(field.Uint(), 10)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\tfor i := 0; i < len(vals); i++ {\n\t\tif vals[i] == v {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isOneOfCI is the validation function for validating if the current field's value is one of the provided string values (case insensitive).\nfunc isOneOfCI(fl FieldLevel) bool {\n\tvals := parseOneOfParam2(fl.Param())\n\tfield := fl.Field()\n\n\tif field.Kind() != reflect.String {\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\tv := field.String()\n\tfor _, val := range vals {\n\t\tif strings.EqualFold(val, v) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isUnique is the validation function for validating if each array|slice|map value is unique\nfunc isUnique(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\tv := reflect.ValueOf(struct{}{})\n\n\tswitch field.Kind() {\n\tcase reflect.Slice, reflect.Array:\n\t\telem := field.Type().Elem()\n\t\tif elem.Kind() == reflect.Ptr {\n\t\t\telem = elem.Elem()\n\t\t}\n\n\t\tif param == \"\" {\n\t\t\tm := reflect.MakeMap(reflect.MapOf(elem, v.Type()))\n\n\t\t\tfor i := 0; i < field.Len(); i++ {\n\t\t\t\tm.SetMapIndex(reflect.Indirect(field.Index(i)), v)\n\t\t\t}\n\t\t\treturn field.Len() == m.Len()\n\t\t}\n\n\t\tsf, ok := elem.FieldByName(param)\n\t\tif !ok {\n\t\t\tpanic(fmt.Sprintf(\"Bad field name %s\", param))\n\t\t}\n\n\t\tsfTyp := sf.Type\n\t\tif sfTyp.Kind() == reflect.Ptr {\n\t\t\tsfTyp = sfTyp.Elem()\n\t\t}\n\n\t\tm := reflect.MakeMap(reflect.MapOf(sfTyp, v.Type()))\n\t\tvar fieldlen int\n\t\tfor i := 0; i < field.Len(); i++ {\n\t\t\tkey := reflect.Indirect(reflect.Indirect(field.Index(i)).FieldByName(param))\n\t\t\tif key.IsValid() {\n\t\t\t\tfieldlen++\n\t\t\t\tm.SetMapIndex(key, v)\n\t\t\t}\n\t\t}\n\t\treturn fieldlen == m.Len()\n\tcase reflect.Map:\n\t\tvar m reflect.Value\n\t\tif field.Type().Elem().Kind() == reflect.Ptr {\n\t\t\tm = reflect.MakeMap(reflect.MapOf(field.Type().Elem().Elem(), v.Type()))\n\t\t} else {\n\t\t\tm = reflect.MakeMap(reflect.MapOf(field.Type().Elem(), v.Type()))\n\t\t}\n\n\t\tfor _, k := range field.MapKeys() {\n\t\t\tm.SetMapIndex(reflect.Indirect(field.MapIndex(k)), v)\n\t\t}\n\n\t\treturn field.Len() == m.Len()\n\tdefault:\n\t\tif parent := fl.Parent(); parent.Kind() == reflect.Struct {\n\t\t\tuniqueField := parent.FieldByName(param)\n\t\t\tif uniqueField == reflect.ValueOf(nil) {\n\t\t\t\tpanic(fmt.Sprintf(\"Bad field name provided %s\", param))\n\t\t\t}\n\n\t\t\tif uniqueField.Kind() != field.Kind() {\n\t\t\t\tpanic(fmt.Sprintf(\"Bad field type %T:%T\", field.Interface(), uniqueField.Interface()))\n\t\t\t}\n\n\t\t\treturn field.Interface() != uniqueField.Interface()\n\t\t}\n\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n}\n\n// isMAC is the validation function for validating if the field's value is a valid MAC address.\nfunc isMAC(fl FieldLevel) bool {\n\t_, err := net.ParseMAC(fl.Field().String())\n\n\treturn err == nil\n}\n\n// isCIDRv4 is the validation function for validating if the field's value is a valid v4 CIDR address.\nfunc isCIDRv4(fl FieldLevel) bool {\n\tip, net, err := net.ParseCIDR(fl.Field().String())\n\n\treturn err == nil && ip.To4() != nil && net.IP.Equal(ip)\n}\n\n// isCIDRv6 is the validation function for validating if the field's value is a valid v6 CIDR address.\nfunc isCIDRv6(fl FieldLevel) bool {\n\tip, _, err := net.ParseCIDR(fl.Field().String())\n\n\treturn err == nil && ip.To4() == nil\n}\n\n// isCIDR is the validation function for validating if the field's value is a valid v4 or v6 CIDR address.\nfunc isCIDR(fl FieldLevel) bool {\n\t_, _, err := net.ParseCIDR(fl.Field().String())\n\n\treturn err == nil\n}\n\n// isIPv4 is the validation function for validating if a value is a valid v4 IP address.\nfunc isIPv4(fl FieldLevel) bool {\n\tip := net.ParseIP(fl.Field().String())\n\n\treturn ip != nil && ip.To4() != nil\n}\n\n// isIPv6 is the validation function for validating if the field's value is a valid v6 IP address.\nfunc isIPv6(fl FieldLevel) bool {\n\tip := net.ParseIP(fl.Field().String())\n\n\treturn ip != nil && ip.To4() == nil\n}\n\n// isIP is the validation function for validating if the field's value is a valid v4 or v6 IP address.\nfunc isIP(fl FieldLevel) bool {\n\tip := net.ParseIP(fl.Field().String())\n\n\treturn ip != nil\n}\n\n// isSSN is the validation function for validating if the field's value is a valid SSN.\nfunc isSSN(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tif field.Len() != 11 {\n\t\treturn false\n\t}\n\n\treturn sSNRegex().MatchString(field.String())\n}\n\n// isLongitude is the validation function for validating if the field's value is a valid longitude coordinate.\nfunc isLongitude(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tvar v string\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tv = field.String()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tv = strconv.FormatInt(field.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tv = strconv.FormatUint(field.Uint(), 10)\n\tcase reflect.Float32:\n\t\tv = strconv.FormatFloat(field.Float(), 'f', -1, 32)\n\tcase reflect.Float64:\n\t\tv = strconv.FormatFloat(field.Float(), 'f', -1, 64)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\n\treturn longitudeRegex().MatchString(v)\n}\n\n// isLatitude is the validation function for validating if the field's value is a valid latitude coordinate.\nfunc isLatitude(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tvar v string\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tv = field.String()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tv = strconv.FormatInt(field.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tv = strconv.FormatUint(field.Uint(), 10)\n\tcase reflect.Float32:\n\t\tv = strconv.FormatFloat(field.Float(), 'f', -1, 32)\n\tcase reflect.Float64:\n\t\tv = strconv.FormatFloat(field.Float(), 'f', -1, 64)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\n\treturn latitudeRegex().MatchString(v)\n}\n\n// isDataURI is the validation function for validating if the field's value is a valid data URI.\nfunc isDataURI(fl FieldLevel) bool {\n\turi := strings.SplitN(fl.Field().String(), \",\", 2)\n\n\tif len(uri) != 2 {\n\t\treturn false\n\t}\n\n\tif !dataURIRegex().MatchString(uri[0]) {\n\t\treturn false\n\t}\n\n\treturn base64Regex().MatchString(uri[1])\n}\n\n// hasMultiByteCharacter is the validation function for validating if the field's value has a multi byte character.\nfunc hasMultiByteCharacter(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tif field.Len() == 0 {\n\t\treturn true\n\t}\n\n\treturn multibyteRegex().MatchString(field.String())\n}\n\n// isPrintableASCII is the validation function for validating if the field's value is a valid printable ASCII character.\nfunc isPrintableASCII(fl FieldLevel) bool {\n\treturn printableASCIIRegex().MatchString(fl.Field().String())\n}\n\n// isASCII is the validation function for validating if the field's value is a valid ASCII character.\nfunc isASCII(fl FieldLevel) bool {\n\treturn aSCIIRegex().MatchString(fl.Field().String())\n}\n\n// isUUID5 is the validation function for validating if the field's value is a valid v5 UUID.\nfunc isUUID5(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUID5Regex, fl)\n}\n\n// isUUID4 is the validation function for validating if the field's value is a valid v4 UUID.\nfunc isUUID4(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUID4Regex, fl)\n}\n\n// isUUID3 is the validation function for validating if the field's value is a valid v3 UUID.\nfunc isUUID3(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUID3Regex, fl)\n}\n\n// isUUID is the validation function for validating if the field's value is a valid UUID of any version.\nfunc isUUID(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUIDRegex, fl)\n}\n\n// isUUID5RFC4122 is the validation function for validating if the field's value is a valid RFC4122 v5 UUID.\nfunc isUUID5RFC4122(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUID5RFC4122Regex, fl)\n}\n\n// isUUID4RFC4122 is the validation function for validating if the field's value is a valid RFC4122 v4 UUID.\nfunc isUUID4RFC4122(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUID4RFC4122Regex, fl)\n}\n\n// isUUID3RFC4122 is the validation function for validating if the field's value is a valid RFC4122 v3 UUID.\nfunc isUUID3RFC4122(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUID3RFC4122Regex, fl)\n}\n\n// isUUIDRFC4122 is the validation function for validating if the field's value is a valid RFC4122 UUID of any version.\nfunc isUUIDRFC4122(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uUIDRFC4122Regex, fl)\n}\n\n// isULID is the validation function for validating if the field's value is a valid ULID.\nfunc isULID(fl FieldLevel) bool {\n\treturn fieldMatchesRegexByStringerValOrString(uLIDRegex, fl)\n}\n\n// isMD4 is the validation function for validating if the field's value is a valid MD4.\nfunc isMD4(fl FieldLevel) bool {\n\treturn md4Regex().MatchString(fl.Field().String())\n}\n\n// isMD5 is the validation function for validating if the field's value is a valid MD5.\nfunc isMD5(fl FieldLevel) bool {\n\treturn md5Regex().MatchString(fl.Field().String())\n}\n\n// isSHA256 is the validation function for validating if the field's value is a valid SHA256.\nfunc isSHA256(fl FieldLevel) bool {\n\treturn sha256Regex().MatchString(fl.Field().String())\n}\n\n// isSHA384 is the validation function for validating if the field's value is a valid SHA384.\nfunc isSHA384(fl FieldLevel) bool {\n\treturn sha384Regex().MatchString(fl.Field().String())\n}\n\n// isSHA512 is the validation function for validating if the field's value is a valid SHA512.\nfunc isSHA512(fl FieldLevel) bool {\n\treturn sha512Regex().MatchString(fl.Field().String())\n}\n\n// isRIPEMD128 is the validation function for validating if the field's value is a valid PIPEMD128.\nfunc isRIPEMD128(fl FieldLevel) bool {\n\treturn ripemd128Regex().MatchString(fl.Field().String())\n}\n\n// isRIPEMD160 is the validation function for validating if the field's value is a valid PIPEMD160.\nfunc isRIPEMD160(fl FieldLevel) bool {\n\treturn ripemd160Regex().MatchString(fl.Field().String())\n}\n\n// isTIGER128 is the validation function for validating if the field's value is a valid TIGER128.\nfunc isTIGER128(fl FieldLevel) bool {\n\treturn tiger128Regex().MatchString(fl.Field().String())\n}\n\n// isTIGER160 is the validation function for validating if the field's value is a valid TIGER160.\nfunc isTIGER160(fl FieldLevel) bool {\n\treturn tiger160Regex().MatchString(fl.Field().String())\n}\n\n// isTIGER192 is the validation function for validating if the field's value is a valid isTIGER192.\nfunc isTIGER192(fl FieldLevel) bool {\n\treturn tiger192Regex().MatchString(fl.Field().String())\n}\n\n// isISBN is the validation function for validating if the field's value is a valid v10 or v13 ISBN.\nfunc isISBN(fl FieldLevel) bool {\n\treturn isISBN10(fl) || isISBN13(fl)\n}\n\n// isISBN13 is the validation function for validating if the field's value is a valid v13 ISBN.\nfunc isISBN13(fl FieldLevel) bool {\n\ts := strings.Replace(strings.Replace(fl.Field().String(), \"-\", \"\", 4), \" \", \"\", 4)\n\n\tif !iSBN13Regex().MatchString(s) {\n\t\treturn false\n\t}\n\n\tvar checksum int32\n\tvar i int32\n\n\tfactor := []int32{1, 3}\n\n\tfor i = 0; i < 12; i++ {\n\t\tchecksum += factor[i%2] * int32(s[i]-'0')\n\t}\n\n\treturn (int32(s[12]-'0'))-((10-(checksum%10))%10) == 0\n}\n\n// isISBN10 is the validation function for validating if the field's value is a valid v10 ISBN.\nfunc isISBN10(fl FieldLevel) bool {\n\ts := strings.Replace(strings.Replace(fl.Field().String(), \"-\", \"\", 3), \" \", \"\", 3)\n\n\tif !iSBN10Regex().MatchString(s) {\n\t\treturn false\n\t}\n\n\tvar checksum int32\n\tvar i int32\n\n\tfor i = 0; i < 9; i++ {\n\t\tchecksum += (i + 1) * int32(s[i]-'0')\n\t}\n\n\tif s[9] == 'X' {\n\t\tchecksum += 10 * 10\n\t} else {\n\t\tchecksum += 10 * int32(s[9]-'0')\n\t}\n\n\treturn checksum%11 == 0\n}\n\n// isISSN is the validation function for validating if the field's value is a valid ISSN.\nfunc isISSN(fl FieldLevel) bool {\n\ts := fl.Field().String()\n\n\tif !iSSNRegex().MatchString(s) {\n\t\treturn false\n\t}\n\ts = strings.ReplaceAll(s, \"-\", \"\")\n\n\tpos := 8\n\tchecksum := 0\n\n\tfor i := 0; i < 7; i++ {\n\t\tchecksum += pos * int(s[i]-'0')\n\t\tpos--\n\t}\n\n\tif s[7] == 'X' {\n\t\tchecksum += 10\n\t} else {\n\t\tchecksum += int(s[7] - '0')\n\t}\n\n\treturn checksum%11 == 0\n}\n\n// isEthereumAddress is the validation function for validating if the field's value is a valid Ethereum address.\nfunc isEthereumAddress(fl FieldLevel) bool {\n\taddress := fl.Field().String()\n\n\treturn ethAddressRegex().MatchString(address)\n}\n\n// isEthereumAddressChecksum is the validation function for validating if the field's value is a valid checksummed Ethereum address.\nfunc isEthereumAddressChecksum(fl FieldLevel) bool {\n\taddress := fl.Field().String()\n\n\tif !ethAddressRegex().MatchString(address) {\n\t\treturn false\n\t}\n\t// Checksum validation. Reference: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md\n\taddress = address[2:] // Skip \"0x\" prefix.\n\th := sha3.NewLegacyKeccak256()\n\t// hash.Hash's io.Writer implementation says it never returns an error. https://golang.org/pkg/hash/#Hash\n\t_, _ = h.Write([]byte(strings.ToLower(address)))\n\thash := hex.EncodeToString(h.Sum(nil))\n\n\tfor i := 0; i < len(address); i++ {\n\t\tif address[i] <= '9' { // Skip 0-9 digits: they don't have upper/lower-case.\n\t\t\tcontinue\n\t\t}\n\t\tif hash[i] > '7' && address[i] >= 'a' || hash[i] <= '7' && address[i] <= 'F' {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// isBitcoinAddress is the validation function for validating if the field's value is a valid btc address\nfunc isBitcoinAddress(fl FieldLevel) bool {\n\taddress := fl.Field().String()\n\n\tif !btcAddressRegex().MatchString(address) {\n\t\treturn false\n\t}\n\n\talphabet := []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")\n\n\tdecode := [25]byte{}\n\n\tfor _, n := range []byte(address) {\n\t\td := bytes.IndexByte(alphabet, n)\n\n\t\tfor i := 24; i >= 0; i-- {\n\t\t\td += 58 * int(decode[i])\n\t\t\tdecode[i] = byte(d % 256)\n\t\t\td /= 256\n\t\t}\n\t}\n\n\th := sha256.New()\n\t_, _ = h.Write(decode[:21])\n\td := h.Sum([]byte{})\n\th = sha256.New()\n\t_, _ = h.Write(d)\n\n\tvalidchecksum := [4]byte{}\n\tcomputedchecksum := [4]byte{}\n\n\tcopy(computedchecksum[:], h.Sum(d[:0]))\n\tcopy(validchecksum[:], decode[21:])\n\n\treturn validchecksum == computedchecksum\n}\n\n// isBitcoinBech32Address is the validation function for validating if the field's value is a valid bech32 btc address\nfunc isBitcoinBech32Address(fl FieldLevel) bool {\n\taddress := fl.Field().String()\n\n\tif !btcLowerAddressRegexBech32().MatchString(address) && !btcUpperAddressRegexBech32().MatchString(address) {\n\t\treturn false\n\t}\n\n\tam := len(address) % 8\n\n\tif am == 0 || am == 3 || am == 5 {\n\t\treturn false\n\t}\n\n\taddress = strings.ToLower(address)\n\n\talphabet := \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\n\n\thr := []int{3, 3, 0, 2, 3} // the human readable part will always be bc\n\taddr := address[3:]\n\tdp := make([]int, 0, len(addr))\n\n\tfor _, c := range addr {\n\t\tdp = append(dp, strings.IndexRune(alphabet, c))\n\t}\n\n\tver := dp[0]\n\n\tif ver < 0 || ver > 16 {\n\t\treturn false\n\t}\n\n\tif ver == 0 {\n\t\tif len(address) != 42 && len(address) != 62 {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tvalues := append(hr, dp...)\n\n\tGEN := []int{0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3}\n\n\tp := 1\n\n\tfor _, v := range values {\n\t\tb := p >> 25\n\t\tp = (p&0x1ffffff)<<5 ^ v\n\n\t\tfor i := 0; i < 5; i++ {\n\t\t\tif (b>>uint(i))&1 == 1 {\n\t\t\t\tp ^= GEN[i]\n\t\t\t}\n\t\t}\n\t}\n\n\tif p != 1 {\n\t\treturn false\n\t}\n\n\tb := uint(0)\n\tacc := 0\n\tmv := (1 << 5) - 1\n\tvar sw []int\n\n\tfor _, v := range dp[1 : len(dp)-6] {\n\t\tacc = (acc << 5) | v\n\t\tb += 5\n\t\tfor b >= 8 {\n\t\t\tb -= 8\n\t\t\tsw = append(sw, (acc>>b)&mv)\n\t\t}\n\t}\n\n\tif len(sw) < 2 || len(sw) > 40 {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// excludesRune is the validation function for validating that the field's value does not contain the rune specified within the param.\nfunc excludesRune(fl FieldLevel) bool {\n\treturn !containsRune(fl)\n}\n\n// excludesAll is the validation function for validating that the field's value does not contain any of the characters specified within the param.\nfunc excludesAll(fl FieldLevel) bool {\n\treturn !containsAny(fl)\n}\n\n// excludes is the validation function for validating that the field's value does not contain the text specified within the param.\nfunc excludes(fl FieldLevel) bool {\n\treturn !contains(fl)\n}\n\n// containsRune is the validation function for validating that the field's value contains the rune specified within the param.\nfunc containsRune(fl FieldLevel) bool {\n\tr, _ := utf8.DecodeRuneInString(fl.Param())\n\n\treturn strings.ContainsRune(fl.Field().String(), r)\n}\n\n// containsAny is the validation function for validating that the field's value contains any of the characters specified within the param.\nfunc containsAny(fl FieldLevel) bool {\n\treturn strings.ContainsAny(fl.Field().String(), fl.Param())\n}\n\n// contains is the validation function for validating that the field's value contains the text specified within the param.\nfunc contains(fl FieldLevel) bool {\n\treturn strings.Contains(fl.Field().String(), fl.Param())\n}\n\n// startsWith is the validation function for validating that the field's value starts with the text specified within the param.\nfunc startsWith(fl FieldLevel) bool {\n\treturn strings.HasPrefix(fl.Field().String(), fl.Param())\n}\n\n// endsWith is the validation function for validating that the field's value ends with the text specified within the param.\nfunc endsWith(fl FieldLevel) bool {\n\treturn strings.HasSuffix(fl.Field().String(), fl.Param())\n}\n\n// startsNotWith is the validation function for validating that the field's value does not start with the text specified within the param.\nfunc startsNotWith(fl FieldLevel) bool {\n\treturn !startsWith(fl)\n}\n\n// endsNotWith is the validation function for validating that the field's value does not end with the text specified within the param.\nfunc endsNotWith(fl FieldLevel) bool {\n\treturn !endsWith(fl)\n}\n\n// fieldContains is the validation function for validating if the current field's value contains the field specified by the param's value.\nfunc fieldContains(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tcurrentField, _, ok := fl.GetStructFieldOK()\n\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn strings.Contains(field.String(), currentField.String())\n}\n\n// fieldExcludes is the validation function for validating if the current field's value excludes the field specified by the param's value.\nfunc fieldExcludes(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tcurrentField, _, ok := fl.GetStructFieldOK()\n\tif !ok {\n\t\treturn true\n\t}\n\n\treturn !strings.Contains(field.String(), currentField.String())\n}\n\n// isNeField is the validation function for validating if the current field's value is not equal to the field specified by the param's value.\nfunc isNeField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\tcurrentField, currentKind, ok := fl.GetStructFieldOK()\n\n\tif !ok || currentKind != kind {\n\t\treturn true\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() != currentField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn field.Uint() != currentField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn field.Float() != currentField.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(field.Len()) != int64(currentField.Len())\n\n\tcase reflect.Bool:\n\t\treturn field.Bool() != currentField.Bool()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && currentField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := currentField.Interface().(time.Time)\n\t\t\tfieldTime := field.Interface().(time.Time)\n\n\t\t\treturn !fieldTime.Equal(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != currentField.Type() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn field.String() != currentField.String()\n}\n\n// isNe is the validation function for validating that the field's value does not equal the provided param value.\nfunc isNe(fl FieldLevel) bool {\n\treturn !isEq(fl)\n}\n\n// isNeIgnoreCase is the validation function for validating that the field's string value does not equal the\n// provided param value. The comparison is case-insensitive\nfunc isNeIgnoreCase(fl FieldLevel) bool {\n\treturn !isEqIgnoreCase(fl)\n}\n\n// isLteCrossStructField is the validation function for validating if the current field's value is less than or equal to the field, within a separate struct, specified by the param's value.\nfunc isLteCrossStructField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\ttopField, topKind, ok := fl.GetStructFieldOK()\n\tif !ok || topKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() <= topField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn field.Uint() <= topField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn field.Float() <= topField.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(field.Len()) <= int64(topField.Len())\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && topField.Type().ConvertibleTo(timeType) {\n\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\t\t\ttopTime := topField.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.Before(topTime) || fieldTime.Equal(topTime)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != topField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn field.String() <= topField.String()\n}\n\n// isLtCrossStructField is the validation function for validating if the current field's value is less than the field, within a separate struct, specified by the param's value.\n// NOTE: This is exposed for use within your own custom functions and not intended to be called directly.\nfunc isLtCrossStructField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\ttopField, topKind, ok := fl.GetStructFieldOK()\n\tif !ok || topKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() < topField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn field.Uint() < topField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn field.Float() < topField.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(field.Len()) < int64(topField.Len())\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && topField.Type().ConvertibleTo(timeType) {\n\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\t\t\ttopTime := topField.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.Before(topTime)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != topField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn field.String() < topField.String()\n}\n\n// isGteCrossStructField is the validation function for validating if the current field's value is greater than or equal to the field, within a separate struct, specified by the param's value.\nfunc isGteCrossStructField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\ttopField, topKind, ok := fl.GetStructFieldOK()\n\tif !ok || topKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() >= topField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn field.Uint() >= topField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn field.Float() >= topField.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(field.Len()) >= int64(topField.Len())\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && topField.Type().ConvertibleTo(timeType) {\n\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\t\t\ttopTime := topField.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.After(topTime) || fieldTime.Equal(topTime)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != topField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn field.String() >= topField.String()\n}\n\n// isGtCrossStructField is the validation function for validating if the current field's value is greater than the field, within a separate struct, specified by the param's value.\nfunc isGtCrossStructField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\ttopField, topKind, ok := fl.GetStructFieldOK()\n\tif !ok || topKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() > topField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn field.Uint() > topField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn field.Float() > topField.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(field.Len()) > int64(topField.Len())\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && topField.Type().ConvertibleTo(timeType) {\n\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\t\t\ttopTime := topField.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.After(topTime)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != topField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn field.String() > topField.String()\n}\n\n// isNeCrossStructField is the validation function for validating that the current field's value is not equal to the field, within a separate struct, specified by the param's value.\nfunc isNeCrossStructField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\ttopField, currentKind, ok := fl.GetStructFieldOK()\n\tif !ok || currentKind != kind {\n\t\treturn true\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn topField.Int() != field.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn topField.Uint() != field.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn topField.Float() != field.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(topField.Len()) != int64(field.Len())\n\n\tcase reflect.Bool:\n\t\treturn topField.Bool() != field.Bool()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && topField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := field.Convert(timeType).Interface().(time.Time)\n\t\t\tfieldTime := topField.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn !fieldTime.Equal(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != topField.Type() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn topField.String() != field.String()\n}\n\n// isEqCrossStructField is the validation function for validating that the current field's value is equal to the field, within a separate struct, specified by the param's value.\nfunc isEqCrossStructField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\ttopField, topKind, ok := fl.GetStructFieldOK()\n\tif !ok || topKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn topField.Int() == field.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn topField.Uint() == field.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn topField.Float() == field.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(topField.Len()) == int64(field.Len())\n\n\tcase reflect.Bool:\n\t\treturn topField.Bool() == field.Bool()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && topField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := field.Convert(timeType).Interface().(time.Time)\n\t\t\tfieldTime := topField.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.Equal(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != topField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn topField.String() == field.String()\n}\n\n// isEqField is the validation function for validating if the current field's value is equal to the field specified by the param's value.\nfunc isEqField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\tcurrentField, currentKind, ok := fl.GetStructFieldOK()\n\tif !ok || currentKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() == currentField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn field.Uint() == currentField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn field.Float() == currentField.Float()\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(field.Len()) == int64(currentField.Len())\n\n\tcase reflect.Bool:\n\t\treturn field.Bool() == currentField.Bool()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && currentField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := currentField.Convert(timeType).Interface().(time.Time)\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.Equal(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != currentField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String:\n\treturn field.String() == currentField.String()\n}\n\n// isEq is the validation function for validating if the current field's value is equal to the param's value.\nfunc isEq(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\treturn field.String() == param\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\tp := asInt(param)\n\n\t\treturn int64(field.Len()) == p\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp := asIntFromType(field.Type(), param)\n\n\t\treturn field.Int() == p\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp := asUint(param)\n\n\t\treturn field.Uint() == p\n\n\tcase reflect.Float32:\n\t\tp := asFloat32(param)\n\n\t\treturn field.Float() == p\n\n\tcase reflect.Float64:\n\t\tp := asFloat64(param)\n\n\t\treturn field.Float() == p\n\n\tcase reflect.Bool:\n\t\tp := asBool(param)\n\n\t\treturn field.Bool() == p\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isEqIgnoreCase is the validation function for validating if the current field's string value is\n// equal to the param's value.\n// The comparison is case-insensitive.\nfunc isEqIgnoreCase(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\treturn strings.EqualFold(field.String(), param)\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isPostcodeByIso3166Alpha2 validates by value which is country code in iso 3166 alpha 2\n// example: `postcode_iso3166_alpha2=US`\nfunc isPostcodeByIso3166Alpha2(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tpostcodeRegexInit.Do(initPostcodes)\n\treg, found := postCodeRegexDict[param]\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn reg.MatchString(field.String())\n}\n\n// isPostcodeByIso3166Alpha2Field validates by field which represents for a value of country code in iso 3166 alpha 2\n// example: `postcode_iso3166_alpha2_field=CountryCode`\nfunc isPostcodeByIso3166Alpha2Field(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparams := parseOneOfParam2(fl.Param())\n\n\tif len(params) != 1 {\n\t\treturn false\n\t}\n\n\tcurrentField, kind, _, found := fl.GetStructFieldOKAdvanced2(fl.Parent(), params[0])\n\tif !found {\n\t\treturn false\n\t}\n\n\tif kind != reflect.String {\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", currentField.Interface()))\n\t}\n\n\treg, found := postCodeRegexDict[currentField.String()]\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn reg.MatchString(field.String())\n}\n\n// isBase32 is the validation function for validating if the current field's value is a valid base 32.\nfunc isBase32(fl FieldLevel) bool {\n\treturn base32Regex().MatchString(fl.Field().String())\n}\n\n// isBase64 is the validation function for validating if the current field's value is a valid base 64.\nfunc isBase64(fl FieldLevel) bool {\n\treturn base64Regex().MatchString(fl.Field().String())\n}\n\n// isBase64URL is the validation function for validating if the current field's value is a valid base64 URL safe string.\nfunc isBase64URL(fl FieldLevel) bool {\n\treturn base64URLRegex().MatchString(fl.Field().String())\n}\n\n// isBase64RawURL is the validation function for validating if the current field's value is a valid base64 URL safe string without '=' padding.\nfunc isBase64RawURL(fl FieldLevel) bool {\n\treturn base64RawURLRegex().MatchString(fl.Field().String())\n}\n\n// isURI is the validation function for validating if the current field's value is a valid URI.\nfunc isURI(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\tcase reflect.String:\n\n\t\ts := field.String()\n\n\t\t// checks needed as of Go 1.6 because of change https://github.com/golang/go/commit/617c93ce740c3c3cc28cdd1a0d712be183d0b328#diff-6c2d018290e298803c0c9419d8739885L195\n\t\t// emulate browser and strip the '#' suffix prior to validation. see issue-#237\n\t\tif i := strings.Index(s, \"#\"); i > -1 {\n\t\t\ts = s[:i]\n\t\t}\n\n\t\tif len(s) == 0 {\n\t\t\treturn false\n\t\t}\n\n\t\t_, err := url.ParseRequestURI(s)\n\n\t\treturn err == nil\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isFileURL is the helper function for validating if the `path` valid file URL as per RFC8089\nfunc isFileURL(path string) bool {\n\tif !strings.HasPrefix(path, \"file:/\") {\n\t\treturn false\n\t}\n\t_, err := url.ParseRequestURI(path)\n\treturn err == nil\n}\n\n// isURL is the validation function for validating if the current field's value is a valid URL.\nfunc isURL(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\tcase reflect.String:\n\n\t\ts := strings.ToLower(field.String())\n\n\t\tif len(s) == 0 {\n\t\t\treturn false\n\t\t}\n\n\t\tif isFileURL(s) {\n\t\t\treturn true\n\t\t}\n\n\t\turl, err := url.Parse(s)\n\t\tif err != nil || url.Scheme == \"\" {\n\t\t\treturn false\n\t\t}\n\n\t\tif url.Host == \"\" && url.Fragment == \"\" && url.Opaque == \"\" {\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isHttpURL is the validation function for validating if the current field's value is a valid HTTP(s) URL.\nfunc isHttpURL(fl FieldLevel) bool {\n\tif !isURL(fl) {\n\t\treturn false\n\t}\n\n\tfield := fl.Field()\n\tswitch field.Kind() {\n\tcase reflect.String:\n\n\t\ts := strings.ToLower(field.String())\n\n\t\turl, err := url.Parse(s)\n\t\tif err != nil || url.Host == \"\" {\n\t\t\treturn false\n\t\t}\n\n\t\treturn url.Scheme == \"http\" || url.Scheme == \"https\"\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isUrnRFC2141 is the validation function for validating if the current field's value is a valid URN as per RFC 2141.\nfunc isUrnRFC2141(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\tcase reflect.String:\n\n\t\tstr := field.String()\n\n\t\t_, match := urn.Parse([]byte(str))\n\n\t\treturn match\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isFile is the validation function for validating if the current field's value is a valid existing file path.\nfunc isFile(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tfileInfo, err := os.Stat(field.String())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\treturn !fileInfo.IsDir()\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isImage is the validation function for validating if the current field's value contains the path to a valid image file\nfunc isImage(fl FieldLevel) bool {\n\tmimetypes := map[string]bool{\n\t\t\"image/bmp\":                true,\n\t\t\"image/cis-cod\":            true,\n\t\t\"image/gif\":                true,\n\t\t\"image/ief\":                true,\n\t\t\"image/jpeg\":               true,\n\t\t\"image/jp2\":                true,\n\t\t\"image/jpx\":                true,\n\t\t\"image/jpm\":                true,\n\t\t\"image/pipeg\":              true,\n\t\t\"image/png\":                true,\n\t\t\"image/svg+xml\":            true,\n\t\t\"image/tiff\":               true,\n\t\t\"image/webp\":               true,\n\t\t\"image/x-cmu-raster\":       true,\n\t\t\"image/x-cmx\":              true,\n\t\t\"image/x-icon\":             true,\n\t\t\"image/x-portable-anymap\":  true,\n\t\t\"image/x-portable-bitmap\":  true,\n\t\t\"image/x-portable-graymap\": true,\n\t\t\"image/x-portable-pixmap\":  true,\n\t\t\"image/x-rgb\":              true,\n\t\t\"image/x-xbitmap\":          true,\n\t\t\"image/x-xpixmap\":          true,\n\t\t\"image/x-xwindowdump\":      true,\n\t}\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tfilePath := field.String()\n\t\tfileInfo, err := os.Stat(filePath)\n\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif fileInfo.IsDir() {\n\t\t\treturn false\n\t\t}\n\n\t\tfile, err := os.Open(filePath)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tdefer file.Close()\n\n\t\tmime, err := mimetype.DetectReader(file)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif _, ok := mimetypes[mime.String()]; ok {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// isFilePath is the validation function for validating if the current field's value is a valid file path.\nfunc isFilePath(fl FieldLevel) bool {\n\n\tvar exists bool\n\tvar err error\n\n\tfield := fl.Field()\n\n\t// Not valid if it is a directory.\n\tif isDir(fl) {\n\t\treturn false\n\t}\n\t// If it exists, it obviously is valid.\n\t// This is done first to avoid code duplication and unnecessary additional logic.\n\tif exists = isFile(fl); exists {\n\t\treturn true\n\t}\n\n\t// It does not exist but may still be a valid filepath.\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\t// Every OS allows for whitespace, but none\n\t\t// let you use a file with no filename (to my knowledge).\n\t\t// Unless you're dealing with raw inodes, but I digress.\n\t\tif strings.TrimSpace(field.String()) == \"\" {\n\t\t\treturn false\n\t\t}\n\t\t// We make sure it isn't a directory.\n\t\tif strings.HasSuffix(field.String(), string(os.PathSeparator)) {\n\t\t\treturn false\n\t\t}\n\t\tif _, err = os.Stat(field.String()); err != nil {\n\t\t\tswitch t := err.(type) {\n\t\t\tcase *fs.PathError:\n\t\t\t\tif t.Err == syscall.EINVAL {\n\t\t\t\t\t// It's definitely an invalid character in the filepath.\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\t// It could be a permission error, a does-not-exist error, etc.\n\t\t\t\t// Out-of-scope for this validation, though.\n\t\t\t\treturn true\n\t\t\tdefault:\n\t\t\t\t// Something went *seriously* wrong.\n\t\t\t\t/*\n\t\t\t\t\tPer https://pkg.go.dev/os#Stat:\n\t\t\t\t\t\t\"If there is an error, it will be of type *PathError.\"\n\t\t\t\t*/\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isE164 is the validation function for validating if the current field's value is a valid e.164 formatted phone number.\nfunc isE164(fl FieldLevel) bool {\n\treturn e164Regex().MatchString(fl.Field().String())\n}\n\n// isEmail is the validation function for validating if the current field's value is a valid email address.\nfunc isEmail(fl FieldLevel) bool {\n\treturn emailRegex().MatchString(fl.Field().String())\n}\n\n// isHSLA is the validation function for validating if the current field's value is a valid HSLA color.\nfunc isHSLA(fl FieldLevel) bool {\n\treturn hslaRegex().MatchString(fl.Field().String())\n}\n\n// isHSL is the validation function for validating if the current field's value is a valid HSL color.\nfunc isHSL(fl FieldLevel) bool {\n\treturn hslRegex().MatchString(fl.Field().String())\n}\n\n// isRGBA is the validation function for validating if the current field's value is a valid RGBA color.\nfunc isRGBA(fl FieldLevel) bool {\n\treturn rgbaRegex().MatchString(fl.Field().String())\n}\n\n// isRGB is the validation function for validating if the current field's value is a valid RGB color.\nfunc isRGB(fl FieldLevel) bool {\n\treturn rgbRegex().MatchString(fl.Field().String())\n}\n\n// isHEXColor is the validation function for validating if the current field's value is a valid HEX color.\nfunc isHEXColor(fl FieldLevel) bool {\n\treturn hexColorRegex().MatchString(fl.Field().String())\n}\n\n// isHexadecimal is the validation function for validating if the current field's value is a valid hexadecimal.\nfunc isHexadecimal(fl FieldLevel) bool {\n\treturn hexadecimalRegex().MatchString(fl.Field().String())\n}\n\n// isNumber is the validation function for validating if the current field's value is a valid number.\nfunc isNumber(fl FieldLevel) bool {\n\tswitch fl.Field().Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr, reflect.Float32, reflect.Float64:\n\t\treturn true\n\tdefault:\n\t\treturn numberRegex().MatchString(fl.Field().String())\n\t}\n}\n\n// isNumeric is the validation function for validating if the current field's value is a valid numeric value.\nfunc isNumeric(fl FieldLevel) bool {\n\tswitch fl.Field().Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr, reflect.Float32, reflect.Float64:\n\t\treturn true\n\tdefault:\n\t\treturn numericRegex().MatchString(fl.Field().String())\n\t}\n}\n\n// isAlphanum is the validation function for validating if the current field's value is a valid alphanumeric value.\nfunc isAlphanum(fl FieldLevel) bool {\n\treturn alphaNumericRegex().MatchString(fl.Field().String())\n}\n\n// isAlpha is the validation function for validating if the current field's value is a valid alpha value.\nfunc isAlpha(fl FieldLevel) bool {\n\treturn alphaRegex().MatchString(fl.Field().String())\n}\n\n// isAlphanumUnicode is the validation function for validating if the current field's value is a valid alphanumeric unicode value.\nfunc isAlphanumUnicode(fl FieldLevel) bool {\n\treturn alphaUnicodeNumericRegex().MatchString(fl.Field().String())\n}\n\n// isAlphaUnicode is the validation function for validating if the current field's value is a valid alpha unicode value.\nfunc isAlphaUnicode(fl FieldLevel) bool {\n\treturn alphaUnicodeRegex().MatchString(fl.Field().String())\n}\n\n// isBoolean is the validation function for validating if the current field's value is a valid boolean value or can be safely converted to a boolean value.\nfunc isBoolean(fl FieldLevel) bool {\n\tswitch fl.Field().Kind() {\n\tcase reflect.Bool:\n\t\treturn true\n\tdefault:\n\t\t_, err := strconv.ParseBool(fl.Field().String())\n\t\treturn err == nil\n\t}\n}\n\n// isDefault is the opposite of required aka hasValue\nfunc isDefault(fl FieldLevel) bool {\n\treturn !hasValue(fl)\n}\n\n// hasValue is the validation function for validating if the current field's value is not the default static value.\nfunc hasValue(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tswitch field.Kind() {\n\tcase reflect.Slice, reflect.Map, reflect.Ptr, reflect.Interface, reflect.Chan, reflect.Func:\n\t\treturn !field.IsNil()\n\tdefault:\n\t\tif fl.(*validate).fldIsPointer && field.Interface() != nil {\n\t\t\treturn true\n\t\t}\n\t\treturn field.IsValid() && !field.IsZero()\n\t}\n}\n\n// requireCheckFieldKind is a func for check field kind\nfunc requireCheckFieldKind(fl FieldLevel, param string, defaultNotFoundValue bool) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\tvar nullable, found bool\n\tif len(param) > 0 {\n\t\tfield, kind, nullable, found = fl.GetStructFieldOKAdvanced2(fl.Parent(), param)\n\t\tif !found {\n\t\t\treturn defaultNotFoundValue\n\t\t}\n\t}\n\tswitch kind {\n\tcase reflect.Invalid:\n\t\treturn defaultNotFoundValue\n\tcase reflect.Slice, reflect.Map, reflect.Ptr, reflect.Interface, reflect.Chan, reflect.Func:\n\t\treturn field.IsNil()\n\tdefault:\n\t\tif nullable && field.Interface() != nil {\n\t\t\treturn false\n\t\t}\n\t\treturn field.IsValid() && field.IsZero()\n\t}\n}\n\n// requireCheckFieldValue is a func for check field value\nfunc requireCheckFieldValue(\n\tfl FieldLevel, param string, value string, defaultNotFoundValue bool,\n) bool {\n\tfield, kind, _, found := fl.GetStructFieldOKAdvanced2(fl.Parent(), param)\n\tif !found {\n\t\treturn defaultNotFoundValue\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn field.Int() == asInt(value)\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn field.Uint() == asUint(value)\n\n\tcase reflect.Float32:\n\t\treturn field.Float() == asFloat32(value)\n\n\tcase reflect.Float64:\n\t\treturn field.Float() == asFloat64(value)\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\treturn int64(field.Len()) == asInt(value)\n\n\tcase reflect.Bool:\n\t\treturn field.Bool() == (value == \"true\")\n\n\tcase reflect.Ptr:\n\t\tif field.IsNil() {\n\t\t\treturn value == \"nil\"\n\t\t}\n\t\t// Handle non-nil pointers\n\t\treturn requireCheckFieldValue(fl, param, value, defaultNotFoundValue)\n\t}\n\n\t// default reflect.String:\n\treturn field.String() == value\n}\n\n// requiredIf is the validation function\n// The field under validation must be present and not empty only if all the other specified fields are equal to the value following with the specified field.\nfunc requiredIf(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tif len(params)%2 != 0 {\n\t\tpanic(fmt.Sprintf(\"Bad param number for required_if %s\", fl.FieldName()))\n\t}\n\tfor i := 0; i < len(params); i += 2 {\n\t\tif !requireCheckFieldValue(fl, params[i], params[i+1], false) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn hasValue(fl)\n}\n\n// excludedIf is the validation function\n// The field under validation must not be present or is empty only if all the other specified fields are equal to the value following with the specified field.\nfunc excludedIf(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tif len(params)%2 != 0 {\n\t\tpanic(fmt.Sprintf(\"Bad param number for excluded_if %s\", fl.FieldName()))\n\t}\n\n\tfor i := 0; i < len(params); i += 2 {\n\t\tif !requireCheckFieldValue(fl, params[i], params[i+1], false) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn !hasValue(fl)\n}\n\n// requiredUnless is the validation function\n// The field under validation must be present and not empty only unless all the other specified fields are equal to the value following with the specified field.\nfunc requiredUnless(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tif len(params)%2 != 0 {\n\t\tpanic(fmt.Sprintf(\"Bad param number for required_unless %s\", fl.FieldName()))\n\t}\n\n\tfor i := 0; i < len(params); i += 2 {\n\t\tif requireCheckFieldValue(fl, params[i], params[i+1], false) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn hasValue(fl)\n}\n\n// skipUnless is the validation function\n// The field under validation must be present and not empty only unless all the other specified fields are equal to the value following with the specified field.\nfunc skipUnless(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tif len(params)%2 != 0 {\n\t\tpanic(fmt.Sprintf(\"Bad param number for skip_unless %s\", fl.FieldName()))\n\t}\n\tfor i := 0; i < len(params); i += 2 {\n\t\tif !requireCheckFieldValue(fl, params[i], params[i+1], false) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn hasValue(fl)\n}\n\n// excludedUnless is the validation function\n// The field under validation must not be present or is empty unless all the other specified fields are equal to the value following with the specified field.\nfunc excludedUnless(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tif len(params)%2 != 0 {\n\t\tpanic(fmt.Sprintf(\"Bad param number for excluded_unless %s\", fl.FieldName()))\n\t}\n\tfor i := 0; i < len(params); i += 2 {\n\t\tif !requireCheckFieldValue(fl, params[i], params[i+1], false) {\n\t\t\treturn !hasValue(fl)\n\t\t}\n\t}\n\treturn true\n}\n\n// excludedWith is the validation function\n// The field under validation must not be present or is empty if any of the other specified fields are present.\nfunc excludedWith(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tfor _, param := range params {\n\t\tif !requireCheckFieldKind(fl, param, true) {\n\t\t\treturn !hasValue(fl)\n\t\t}\n\t}\n\treturn true\n}\n\n// requiredWith is the validation function\n// The field under validation must be present and not empty only if any of the other specified fields are present.\nfunc requiredWith(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tfor _, param := range params {\n\t\tif !requireCheckFieldKind(fl, param, true) {\n\t\t\treturn hasValue(fl)\n\t\t}\n\t}\n\treturn true\n}\n\n// excludedWithAll is the validation function\n// The field under validation must not be present or is empty if all of the other specified fields are present.\nfunc excludedWithAll(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tfor _, param := range params {\n\t\tif requireCheckFieldKind(fl, param, true) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn !hasValue(fl)\n}\n\n// requiredWithAll is the validation function\n// The field under validation must be present and not empty only if all of the other specified fields are present.\nfunc requiredWithAll(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tfor _, param := range params {\n\t\tif requireCheckFieldKind(fl, param, true) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn hasValue(fl)\n}\n\n// excludedWithout is the validation function\n// The field under validation must not be present or is empty when any of the other specified fields are not present.\nfunc excludedWithout(fl FieldLevel) bool {\n\tif requireCheckFieldKind(fl, strings.TrimSpace(fl.Param()), true) {\n\t\treturn !hasValue(fl)\n\t}\n\treturn true\n}\n\n// requiredWithout is the validation function\n// The field under validation must be present and not empty only when any of the other specified fields are not present.\nfunc requiredWithout(fl FieldLevel) bool {\n\tif requireCheckFieldKind(fl, strings.TrimSpace(fl.Param()), true) {\n\t\treturn hasValue(fl)\n\t}\n\treturn true\n}\n\n// excludedWithoutAll is the validation function\n// The field under validation must not be present or is empty when all of the other specified fields are not present.\nfunc excludedWithoutAll(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tfor _, param := range params {\n\t\tif !requireCheckFieldKind(fl, param, true) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn !hasValue(fl)\n}\n\n// requiredWithoutAll is the validation function\n// The field under validation must be present and not empty only when all of the other specified fields are not present.\nfunc requiredWithoutAll(fl FieldLevel) bool {\n\tparams := parseOneOfParam2(fl.Param())\n\tfor _, param := range params {\n\t\tif !requireCheckFieldKind(fl, param, true) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn hasValue(fl)\n}\n\n// isGteField is the validation function for validating if the current field's value is greater than or equal to the field specified by the param's value.\nfunc isGteField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\tcurrentField, currentKind, ok := fl.GetStructFieldOK()\n\tif !ok || currentKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\n\t\treturn field.Int() >= currentField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\n\t\treturn field.Uint() >= currentField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\n\t\treturn field.Float() >= currentField.Float()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && currentField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := currentField.Convert(timeType).Interface().(time.Time)\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.After(t) || fieldTime.Equal(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != currentField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String\n\treturn len(field.String()) >= len(currentField.String())\n}\n\n// isGtField is the validation function for validating if the current field's value is greater than the field specified by the param's value.\nfunc isGtField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\tcurrentField, currentKind, ok := fl.GetStructFieldOK()\n\tif !ok || currentKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\n\t\treturn field.Int() > currentField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\n\t\treturn field.Uint() > currentField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\n\t\treturn field.Float() > currentField.Float()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && currentField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := currentField.Convert(timeType).Interface().(time.Time)\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.After(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != currentField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String\n\treturn len(field.String()) > len(currentField.String())\n}\n\n// isGte is the validation function for validating if the current field's value is greater than or equal to the param's value.\nfunc isGte(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\tp := asInt(param)\n\n\t\treturn int64(utf8.RuneCountInString(field.String())) >= p\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\tp := asInt(param)\n\n\t\treturn int64(field.Len()) >= p\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp := asIntFromType(field.Type(), param)\n\n\t\treturn field.Int() >= p\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp := asUint(param)\n\n\t\treturn field.Uint() >= p\n\n\tcase reflect.Float32:\n\t\tp := asFloat32(param)\n\n\t\treturn field.Float() >= p\n\n\tcase reflect.Float64:\n\t\tp := asFloat64(param)\n\n\t\treturn field.Float() >= p\n\n\tcase reflect.Struct:\n\n\t\tif field.Type().ConvertibleTo(timeType) {\n\n\t\t\tnow := time.Now().UTC()\n\t\t\tt := field.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn t.After(now) || t.Equal(now)\n\t\t}\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isGt is the validation function for validating if the current field's value is greater than the param's value.\nfunc isGt(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\tp := asInt(param)\n\n\t\treturn int64(utf8.RuneCountInString(field.String())) > p\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\tp := asInt(param)\n\n\t\treturn int64(field.Len()) > p\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp := asIntFromType(field.Type(), param)\n\n\t\treturn field.Int() > p\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp := asUint(param)\n\n\t\treturn field.Uint() > p\n\n\tcase reflect.Float32:\n\t\tp := asFloat32(param)\n\n\t\treturn field.Float() > p\n\n\tcase reflect.Float64:\n\t\tp := asFloat64(param)\n\n\t\treturn field.Float() > p\n\n\tcase reflect.Struct:\n\n\t\tif field.Type().ConvertibleTo(timeType) {\n\n\t\t\treturn field.Convert(timeType).Interface().(time.Time).After(time.Now().UTC())\n\t\t}\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// hasLengthOf is the validation function for validating if the current field's value is equal to the param's value.\nfunc hasLengthOf(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\tp := asInt(param)\n\n\t\treturn int64(utf8.RuneCountInString(field.String())) == p\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\tp := asInt(param)\n\n\t\treturn int64(field.Len()) == p\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp := asIntFromType(field.Type(), param)\n\n\t\treturn field.Int() == p\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp := asUint(param)\n\n\t\treturn field.Uint() == p\n\n\tcase reflect.Float32:\n\t\tp := asFloat32(param)\n\n\t\treturn field.Float() == p\n\n\tcase reflect.Float64:\n\t\tp := asFloat64(param)\n\n\t\treturn field.Float() == p\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// hasMinOf is the validation function for validating if the current field's value is greater than or equal to the param's value.\nfunc hasMinOf(fl FieldLevel) bool {\n\treturn isGte(fl)\n}\n\n// isLteField is the validation function for validating if the current field's value is less than or equal to the field specified by the param's value.\nfunc isLteField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\tcurrentField, currentKind, ok := fl.GetStructFieldOK()\n\tif !ok || currentKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\n\t\treturn field.Int() <= currentField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\n\t\treturn field.Uint() <= currentField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\n\t\treturn field.Float() <= currentField.Float()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && currentField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := currentField.Convert(timeType).Interface().(time.Time)\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.Before(t) || fieldTime.Equal(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != currentField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String\n\treturn len(field.String()) <= len(currentField.String())\n}\n\n// isLtField is the validation function for validating if the current field's value is less than the field specified by the param's value.\nfunc isLtField(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tkind := field.Kind()\n\n\tcurrentField, currentKind, ok := fl.GetStructFieldOK()\n\tif !ok || currentKind != kind {\n\t\treturn false\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\n\t\treturn field.Int() < currentField.Int()\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\n\t\treturn field.Uint() < currentField.Uint()\n\n\tcase reflect.Float32, reflect.Float64:\n\n\t\treturn field.Float() < currentField.Float()\n\n\tcase reflect.Struct:\n\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(timeType) && currentField.Type().ConvertibleTo(timeType) {\n\n\t\t\tt := currentField.Convert(timeType).Interface().(time.Time)\n\t\t\tfieldTime := field.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn fieldTime.Before(t)\n\t\t}\n\n\t\t// Not Same underlying type i.e. struct and time\n\t\tif fieldType != currentField.Type() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// default reflect.String\n\treturn len(field.String()) < len(currentField.String())\n}\n\n// isLte is the validation function for validating if the current field's value is less than or equal to the param's value.\nfunc isLte(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\tp := asInt(param)\n\n\t\treturn int64(utf8.RuneCountInString(field.String())) <= p\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\tp := asInt(param)\n\n\t\treturn int64(field.Len()) <= p\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp := asIntFromType(field.Type(), param)\n\n\t\treturn field.Int() <= p\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp := asUint(param)\n\n\t\treturn field.Uint() <= p\n\n\tcase reflect.Float32:\n\t\tp := asFloat32(param)\n\n\t\treturn field.Float() <= p\n\n\tcase reflect.Float64:\n\t\tp := asFloat64(param)\n\n\t\treturn field.Float() <= p\n\n\tcase reflect.Struct:\n\n\t\tif field.Type().ConvertibleTo(timeType) {\n\n\t\t\tnow := time.Now().UTC()\n\t\t\tt := field.Convert(timeType).Interface().(time.Time)\n\n\t\t\treturn t.Before(now) || t.Equal(now)\n\t\t}\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isLt is the validation function for validating if the current field's value is less than the param's value.\nfunc isLt(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tswitch field.Kind() {\n\n\tcase reflect.String:\n\t\tp := asInt(param)\n\n\t\treturn int64(utf8.RuneCountInString(field.String())) < p\n\n\tcase reflect.Slice, reflect.Map, reflect.Array:\n\t\tp := asInt(param)\n\n\t\treturn int64(field.Len()) < p\n\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tp := asIntFromType(field.Type(), param)\n\n\t\treturn field.Int() < p\n\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\tp := asUint(param)\n\n\t\treturn field.Uint() < p\n\n\tcase reflect.Float32:\n\t\tp := asFloat32(param)\n\n\t\treturn field.Float() < p\n\n\tcase reflect.Float64:\n\t\tp := asFloat64(param)\n\n\t\treturn field.Float() < p\n\n\tcase reflect.Struct:\n\n\t\tif field.Type().ConvertibleTo(timeType) {\n\n\t\t\treturn field.Convert(timeType).Interface().(time.Time).Before(time.Now().UTC())\n\t\t}\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// hasMaxOf is the validation function for validating if the current field's value is less than or equal to the param's value.\nfunc hasMaxOf(fl FieldLevel) bool {\n\treturn isLte(fl)\n}\n\n// isTCP4AddrResolvable is the validation function for validating if the field's value is a resolvable tcp4 address.\nfunc isTCP4AddrResolvable(fl FieldLevel) bool {\n\tif !isIP4Addr(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveTCPAddr(\"tcp4\", fl.Field().String())\n\treturn err == nil\n}\n\n// isTCP6AddrResolvable is the validation function for validating if the field's value is a resolvable tcp6 address.\nfunc isTCP6AddrResolvable(fl FieldLevel) bool {\n\tif !isIP6Addr(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveTCPAddr(\"tcp6\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isTCPAddrResolvable is the validation function for validating if the field's value is a resolvable tcp address.\nfunc isTCPAddrResolvable(fl FieldLevel) bool {\n\tif !isIP4Addr(fl) && !isIP6Addr(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveTCPAddr(\"tcp\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isUDP4AddrResolvable is the validation function for validating if the field's value is a resolvable udp4 address.\nfunc isUDP4AddrResolvable(fl FieldLevel) bool {\n\tif !isIP4Addr(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveUDPAddr(\"udp4\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isUDP6AddrResolvable is the validation function for validating if the field's value is a resolvable udp6 address.\nfunc isUDP6AddrResolvable(fl FieldLevel) bool {\n\tif !isIP6Addr(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveUDPAddr(\"udp6\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isUDPAddrResolvable is the validation function for validating if the field's value is a resolvable udp address.\nfunc isUDPAddrResolvable(fl FieldLevel) bool {\n\tif !isIP4Addr(fl) && !isIP6Addr(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveUDPAddr(\"udp\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isIP4AddrResolvable is the validation function for validating if the field's value is a resolvable ip4 address.\nfunc isIP4AddrResolvable(fl FieldLevel) bool {\n\tif !isIPv4(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveIPAddr(\"ip4\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isIP6AddrResolvable is the validation function for validating if the field's value is a resolvable ip6 address.\nfunc isIP6AddrResolvable(fl FieldLevel) bool {\n\tif !isIPv6(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveIPAddr(\"ip6\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isIPAddrResolvable is the validation function for validating if the field's value is a resolvable ip address.\nfunc isIPAddrResolvable(fl FieldLevel) bool {\n\tif !isIP(fl) {\n\t\treturn false\n\t}\n\n\t_, err := net.ResolveIPAddr(\"ip\", fl.Field().String())\n\n\treturn err == nil\n}\n\n// isUnixAddrResolvable is the validation function for validating if the field's value is a resolvable unix address.\nfunc isUnixAddrResolvable(fl FieldLevel) bool {\n\t_, err := net.ResolveUnixAddr(\"unix\", fl.Field().String())\n\n\treturn err == nil\n}\n\nfunc isIP4Addr(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\n\tif idx := strings.LastIndex(val, \":\"); idx != -1 {\n\t\tval = val[0:idx]\n\t}\n\n\tip := net.ParseIP(val)\n\n\treturn ip != nil && ip.To4() != nil\n}\n\nfunc isIP6Addr(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\n\tif idx := strings.LastIndex(val, \":\"); idx != -1 {\n\t\tif idx != 0 && val[idx-1:idx] == \"]\" {\n\t\t\tval = val[1 : idx-1]\n\t\t}\n\t}\n\n\tip := net.ParseIP(val)\n\n\treturn ip != nil && ip.To4() == nil\n}\n\nfunc isHostnameRFC952(fl FieldLevel) bool {\n\treturn hostnameRegexRFC952().MatchString(fl.Field().String())\n}\n\nfunc isHostnameRFC1123(fl FieldLevel) bool {\n\treturn hostnameRegexRFC1123().MatchString(fl.Field().String())\n}\n\nfunc isFQDN(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\n\tif val == \"\" {\n\t\treturn false\n\t}\n\n\treturn fqdnRegexRFC1123().MatchString(val)\n}\n\n// isDir is the validation function for validating if the current field's value is a valid existing directory.\nfunc isDir(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tif field.Kind() == reflect.String {\n\t\tfileInfo, err := os.Stat(field.String())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\treturn fileInfo.IsDir()\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isDirPath is the validation function for validating if the current field's value is a valid directory.\nfunc isDirPath(fl FieldLevel) bool {\n\n\tvar exists bool\n\tvar err error\n\n\tfield := fl.Field()\n\n\t// If it exists, it obviously is valid.\n\t// This is done first to avoid code duplication and unnecessary additional logic.\n\tif exists = isDir(fl); exists {\n\t\treturn true\n\t}\n\n\t// It does not exist but may still be a valid path.\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\t// Every OS allows for whitespace, but none\n\t\t// let you use a dir with no name (to my knowledge).\n\t\t// Unless you're dealing with raw inodes, but I digress.\n\t\tif strings.TrimSpace(field.String()) == \"\" {\n\t\t\treturn false\n\t\t}\n\t\tif _, err = os.Stat(field.String()); err != nil {\n\t\t\tswitch t := err.(type) {\n\t\t\tcase *fs.PathError:\n\t\t\t\tif t.Err == syscall.EINVAL {\n\t\t\t\t\t// It's definitely an invalid character in the path.\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\t// It could be a permission error, a does-not-exist error, etc.\n\t\t\t\t// Out-of-scope for this validation, though.\n\t\t\t\t// Lastly, we make sure it is a directory.\n\t\t\t\tif strings.HasSuffix(field.String(), string(os.PathSeparator)) {\n\t\t\t\t\treturn true\n\t\t\t\t} else {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// Something went *seriously* wrong.\n\t\t\t\t/*\n\t\t\t\t\tPer https://pkg.go.dev/os#Stat:\n\t\t\t\t\t\t\"If there is an error, it will be of type *PathError.\"\n\t\t\t\t*/\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\t// We repeat the check here to make sure it is an explicit directory in case the above os.Stat didn't trigger an error.\n\t\tif strings.HasSuffix(field.String(), string(os.PathSeparator)) {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isJSON is the validation function for validating if the current field's value is a valid json string.\nfunc isJSON(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tval := field.String()\n\t\treturn json.Valid([]byte(val))\n\tcase reflect.Slice:\n\t\tfieldType := field.Type()\n\n\t\tif fieldType.ConvertibleTo(byteSliceType) {\n\t\t\tb := field.Convert(byteSliceType).Interface().([]byte)\n\t\t\treturn json.Valid(b)\n\t\t}\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isJWT is the validation function for validating if the current field's value is a valid JWT string.\nfunc isJWT(fl FieldLevel) bool {\n\treturn jWTRegex().MatchString(fl.Field().String())\n}\n\n// isHostnamePort validates a <dns>:<port> combination for fields typically used for socket address.\nfunc isHostnamePort(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\thost, port, err := net.SplitHostPort(val)\n\tif err != nil {\n\t\treturn false\n\t}\n\t// Port must be a iny <= 65535.\n\tif portNum, err := strconv.ParseInt(\n\t\tport, 10, 32,\n\t); err != nil || portNum > 65535 || portNum < 1 {\n\t\treturn false\n\t}\n\n\t// If host is specified, it should match a DNS name\n\tif host != \"\" {\n\t\treturn hostnameRegexRFC1123().MatchString(host)\n\t}\n\treturn true\n}\n\n// IsPort validates if the current field's value represents a valid port\nfunc isPort(fl FieldLevel) bool {\n\tval := fl.Field().Uint()\n\n\treturn val >= 1 && val <= 65535\n}\n\n// isLowercase is the validation function for validating if the current field's value is a lowercase string.\nfunc isLowercase(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tif field.Kind() == reflect.String {\n\t\tif field.String() == \"\" {\n\t\t\treturn false\n\t\t}\n\t\treturn field.String() == strings.ToLower(field.String())\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isUppercase is the validation function for validating if the current field's value is an uppercase string.\nfunc isUppercase(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tif field.Kind() == reflect.String {\n\t\tif field.String() == \"\" {\n\t\t\treturn false\n\t\t}\n\t\treturn field.String() == strings.ToUpper(field.String())\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isDatetime is the validation function for validating if the current field's value is a valid datetime string.\nfunc isDatetime(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tparam := fl.Param()\n\n\tif field.Kind() == reflect.String {\n\t\t_, err := time.Parse(param, field.String())\n\n\t\treturn err == nil\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isTimeZone is the validation function for validating if the current field's value is a valid time zone string.\nfunc isTimeZone(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tif field.Kind() == reflect.String {\n\t\t// empty value is converted to UTC by time.LoadLocation but disallow it as it is not a valid time zone name\n\t\tif field.String() == \"\" {\n\t\t\treturn false\n\t\t}\n\n\t\t// Local value is converted to the current system time zone by time.LoadLocation but disallow it as it is not a valid time zone name\n\t\tif strings.ToLower(field.String()) == \"local\" {\n\t\t\treturn false\n\t\t}\n\n\t\t_, err := time.LoadLocation(field.String())\n\t\treturn err == nil\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isIso3166Alpha2 is the validation function for validating if the current field's value is a valid iso3166-1 alpha-2 country code.\nfunc isIso3166Alpha2(fl FieldLevel) bool {\n\t_, ok := iso3166_1_alpha2[fl.Field().String()]\n\treturn ok\n}\n\n// isIso3166Alpha2EU is the validation function for validating if the current field's value is a valid iso3166-1 alpha-2 European Union country code.\nfunc isIso3166Alpha2EU(fl FieldLevel) bool {\n\t_, ok := iso3166_1_alpha2_eu[fl.Field().String()]\n\treturn ok\n}\n\n// isIso3166Alpha3 is the validation function for validating if the current field's value is a valid iso3166-1 alpha-3 country code.\nfunc isIso3166Alpha3(fl FieldLevel) bool {\n\t_, ok := iso3166_1_alpha3[fl.Field().String()]\n\treturn ok\n}\n\n// isIso3166Alpha3EU is the validation function for validating if the current field's value is a valid iso3166-1 alpha-3 European Union country code.\nfunc isIso3166Alpha3EU(fl FieldLevel) bool {\n\t_, ok := iso3166_1_alpha3_eu[fl.Field().String()]\n\treturn ok\n}\n\n// isIso3166AlphaNumeric is the validation function for validating if the current field's value is a valid iso3166-1 alpha-numeric country code.\nfunc isIso3166AlphaNumeric(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tvar code int\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\ti, err := strconv.Atoi(field.String())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tcode = i % 1000\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tcode = int(field.Int() % 1000)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tcode = int(field.Uint() % 1000)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\n\t_, ok := iso3166_1_alpha_numeric[code]\n\treturn ok\n}\n\n// isIso3166AlphaNumericEU is the validation function for validating if the current field's value is a valid iso3166-1 alpha-numeric European Union country code.\nfunc isIso3166AlphaNumericEU(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tvar code int\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\ti, err := strconv.Atoi(field.String())\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tcode = i % 1000\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tcode = int(field.Int() % 1000)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tcode = int(field.Uint() % 1000)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\n\t_, ok := iso3166_1_alpha_numeric_eu[code]\n\treturn ok\n}\n\n// isIso31662 is the validation function for validating if the current field's value is a valid iso3166-2 code.\nfunc isIso31662(fl FieldLevel) bool {\n\t_, ok := iso3166_2[fl.Field().String()]\n\treturn ok\n}\n\n// isIso4217 is the validation function for validating if the current field's value is a valid iso4217 currency code.\nfunc isIso4217(fl FieldLevel) bool {\n\t_, ok := iso4217[fl.Field().String()]\n\treturn ok\n}\n\n// isIso4217Numeric is the validation function for validating if the current field's value is a valid iso4217 numeric currency code.\nfunc isIso4217Numeric(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tvar code int\n\tswitch field.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tcode = int(field.Int())\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tcode = int(field.Uint())\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\n\t_, ok := iso4217_numeric[code]\n\treturn ok\n}\n\n// isBCP47LanguageTag is the validation function for validating if the current field's value is a valid BCP 47 language tag, as parsed by language.Parse\nfunc isBCP47LanguageTag(fl FieldLevel) bool {\n\tfield := fl.Field()\n\n\tif field.Kind() == reflect.String {\n\t\t_, err := language.Parse(field.String())\n\t\treturn err == nil\n\t}\n\n\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n}\n\n// isIsoBicFormat is the validation function for validating if the current field's value is a valid Business Identifier Code (SWIFT code), defined in ISO 9362\nfunc isIsoBicFormat(fl FieldLevel) bool {\n\tbicString := fl.Field().String()\n\n\treturn bicRegex().MatchString(bicString)\n}\n\n// isSemverFormat is the validation function for validating if the current field's value is a valid semver version, defined in Semantic Versioning 2.0.0\nfunc isSemverFormat(fl FieldLevel) bool {\n\tsemverString := fl.Field().String()\n\n\treturn semverRegex().MatchString(semverString)\n}\n\n// isCveFormat is the validation function for validating if the current field's value is a valid cve id, defined in CVE mitre org\nfunc isCveFormat(fl FieldLevel) bool {\n\tcveString := fl.Field().String()\n\n\treturn cveRegex().MatchString(cveString)\n}\n\n// isDnsRFC1035LabelFormat is the validation function\n// for validating if the current field's value is\n// a valid dns RFC 1035 label, defined in RFC 1035.\nfunc isDnsRFC1035LabelFormat(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\treturn dnsRegexRFC1035Label().MatchString(val)\n}\n\n// digitsHaveLuhnChecksum returns true if and only if the last element of the given digits slice is the Luhn checksum of the previous elements\nfunc digitsHaveLuhnChecksum(digits []string) bool {\n\tsize := len(digits)\n\tsum := 0\n\tfor i, digit := range digits {\n\t\tvalue, err := strconv.Atoi(digit)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\t\tif size%2 == 0 && i%2 == 0 || size%2 == 1 && i%2 == 1 {\n\t\t\tv := value * 2\n\t\t\tif v >= 10 {\n\t\t\t\tsum += 1 + (v % 10)\n\t\t\t} else {\n\t\t\t\tsum += v\n\t\t\t}\n\t\t} else {\n\t\t\tsum += value\n\t\t}\n\t}\n\treturn (sum % 10) == 0\n}\n\n// isMongoDBObjectId is the validation function for validating if the current field's value is valid MongoDB ObjectID\nfunc isMongoDBObjectId(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\treturn mongodbIdRegex().MatchString(val)\n}\n\n// isMongoDBConnectionString is the validation function for validating if the current field's value is valid MongoDB Connection String\nfunc isMongoDBConnectionString(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\treturn mongodbConnectionRegex().MatchString(val)\n}\n\n// isSpiceDB is the validation function for validating if the current field's value is valid for use with Authzed SpiceDB in the indicated way\nfunc isSpiceDB(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\tparam := fl.Param()\n\n\tswitch param {\n\tcase \"permission\":\n\t\treturn spicedbPermissionRegex().MatchString(val)\n\tcase \"type\":\n\t\treturn spicedbTypeRegex().MatchString(val)\n\tcase \"id\", \"\":\n\t\treturn spicedbIDRegex().MatchString(val)\n\t}\n\n\tpanic(\"Unrecognized parameter: \" + param)\n}\n\n// isCreditCard is the validation function for validating if the current field's value is a valid credit card number\nfunc isCreditCard(fl FieldLevel) bool {\n\tval := fl.Field().String()\n\tvar creditCard bytes.Buffer\n\tsegments := strings.Split(val, \" \")\n\tfor _, segment := range segments {\n\t\tif len(segment) < 3 {\n\t\t\treturn false\n\t\t}\n\t\tcreditCard.WriteString(segment)\n\t}\n\n\tccDigits := strings.Split(creditCard.String(), \"\")\n\tsize := len(ccDigits)\n\tif size < 12 || size > 19 {\n\t\treturn false\n\t}\n\n\treturn digitsHaveLuhnChecksum(ccDigits)\n}\n\n// hasLuhnChecksum is the validation for validating if the current field's value has a valid Luhn checksum\nfunc hasLuhnChecksum(fl FieldLevel) bool {\n\tfield := fl.Field()\n\tvar str string // convert to a string which will then be split into single digits; easier and more readable than shifting/extracting single digits from a number\n\tswitch field.Kind() {\n\tcase reflect.String:\n\t\tstr = field.String()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\tstr = strconv.FormatInt(field.Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tstr = strconv.FormatUint(field.Uint(), 10)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Bad field type %T\", field.Interface()))\n\t}\n\tsize := len(str)\n\tif size < 2 { // there has to be at least one digit that carries a meaning + the checksum\n\t\treturn false\n\t}\n\tdigits := strings.Split(str, \"\")\n\treturn digitsHaveLuhnChecksum(digits)\n}\n\n// isCron is the validation function for validating if the current field's value is a valid cron expression\nfunc isCron(fl FieldLevel) bool {\n\tcronString := fl.Field().String()\n\treturn cronRegex().MatchString(cronString)\n}\n"
        },
        {
          "name": "benchmarks_test.go",
          "type": "blob",
          "size": 20.14453125,
          "content": "package validator\n\nimport (\n\t\"bytes\"\n\tsql \"database/sql/driver\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc BenchmarkFieldSuccess(b *testing.B) {\n\tvalidate := New()\n\ts := \"1\"\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(&s, \"len=1\")\n\t}\n}\n\nfunc BenchmarkFieldSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\ts := \"1\"\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(&s, \"len=1\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldFailure(b *testing.B) {\n\tvalidate := New()\n\ts := \"12\"\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(&s, \"len=1\")\n\t}\n}\n\nfunc BenchmarkFieldFailureParallel(b *testing.B) {\n\tvalidate := New()\n\ts := \"12\"\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(&s, \"len=1\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldArrayDiveSuccess(b *testing.B) {\n\tvalidate := New()\n\tm := []string{\"val1\", \"val2\", \"val3\"}\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(m, \"required,dive,required\")\n\t}\n}\n\nfunc BenchmarkFieldArrayDiveSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\tm := []string{\"val1\", \"val2\", \"val3\"}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(m, \"required,dive,required\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldArrayDiveFailure(b *testing.B) {\n\tvalidate := New()\n\tm := []string{\"val1\", \"\", \"val3\"}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(m, \"required,dive,required\")\n\t}\n}\n\nfunc BenchmarkFieldArrayDiveFailureParallel(b *testing.B) {\n\tvalidate := New()\n\tm := []string{\"val1\", \"\", \"val3\"}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(m, \"required,dive,required\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldMapDiveSuccess(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"val1\": \"val1\", \"val2\": \"val2\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(m, \"required,dive,required\")\n\t}\n}\n\nfunc BenchmarkFieldMapDiveSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"val1\": \"val1\", \"val2\": \"val2\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(m, \"required,dive,required\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldMapDiveFailure(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"\": \"\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(m, \"required,dive,required\")\n\t}\n}\n\nfunc BenchmarkFieldMapDiveFailureParallel(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"\": \"\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(m, \"required,dive,required\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldMapDiveWithKeysSuccess(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"val1\": \"val1\", \"val2\": \"val2\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(m, \"required,dive,keys,required,endkeys,required\")\n\t}\n}\n\nfunc BenchmarkFieldMapDiveWithKeysSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"val1\": \"val1\", \"val2\": \"val2\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(m, \"required,dive,keys,required,endkeys,required\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldMapDiveWithKeysFailure(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"\": \"\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(m, \"required,dive,keys,required,endkeys,required\")\n\t}\n}\n\nfunc BenchmarkFieldMapDiveWithKeysFailureParallel(b *testing.B) {\n\tvalidate := New()\n\tm := map[string]string{\"\": \"\", \"val3\": \"val3\"}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(m, \"required,dive,keys,required,endkeys,required\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldCustomTypeSuccess(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\tval := valuer{\n\t\tName: \"1\",\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(val, \"len=1\")\n\t}\n}\n\nfunc BenchmarkFieldCustomTypeSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\tval := valuer{\n\t\tName: \"1\",\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(val, \"len=1\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldCustomTypeFailure(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\tval := valuer{}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(val, \"len=1\")\n\t}\n}\n\nfunc BenchmarkFieldCustomTypeFailureParallel(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\tval := valuer{}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(val, \"len=1\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldOrTagSuccess(b *testing.B) {\n\tvalidate := New()\n\ts := \"rgba(0,0,0,1)\"\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(s, \"rgb|rgba\")\n\t}\n}\n\nfunc BenchmarkFieldOrTagSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\ts := \"rgba(0,0,0,1)\"\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(s, \"rgb|rgba\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkFieldOrTagFailure(b *testing.B) {\n\tvalidate := New()\n\ts := \"#000\"\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Var(s, \"rgb|rgba\")\n\t}\n}\n\nfunc BenchmarkFieldOrTagFailureParallel(b *testing.B) {\n\tvalidate := New()\n\ts := \"#000\"\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Var(s, \"rgb|rgba\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructLevelValidationSuccess(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterStructValidation(StructValidationTestStructSuccess, TestStruct{})\n\n\ttst := TestStruct{\n\t\tString: \"good value\",\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(tst)\n\t}\n}\n\nfunc BenchmarkStructLevelValidationSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterStructValidation(StructValidationTestStructSuccess, TestStruct{})\n\n\ttst := TestStruct{\n\t\tString: \"good value\",\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(tst)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructLevelValidationFailure(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterStructValidation(StructValidationTestStruct, TestStruct{})\n\n\ttst := TestStruct{\n\t\tString: \"good value\",\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(tst)\n\t}\n}\n\nfunc BenchmarkStructLevelValidationFailureParallel(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterStructValidation(StructValidationTestStruct, TestStruct{})\n\n\ttst := TestStruct{\n\t\tString: \"good value\",\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(tst)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleCustomTypeSuccess(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\n\tval := valuer{\n\t\tName: \"1\",\n\t}\n\n\ttype Foo struct {\n\t\tValuer   valuer `validate:\"len=1\"`\n\t\tIntValue int    `validate:\"min=5,max=10\"`\n\t}\n\n\tvalidFoo := &Foo{Valuer: val, IntValue: 7}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(validFoo)\n\t}\n}\n\nfunc BenchmarkStructSimpleCustomTypeSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\tval := valuer{\n\t\tName: \"1\",\n\t}\n\n\ttype Foo struct {\n\t\tValuer   valuer `validate:\"len=1\"`\n\t\tIntValue int    `validate:\"min=5,max=10\"`\n\t}\n\tvalidFoo := &Foo{Valuer: val, IntValue: 7}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(validFoo)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleCustomTypeFailure(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\n\tval := valuer{}\n\n\ttype Foo struct {\n\t\tValuer   valuer `validate:\"len=1\"`\n\t\tIntValue int    `validate:\"min=5,max=10\"`\n\t}\n\tvalidFoo := &Foo{Valuer: val, IntValue: 3}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(validFoo)\n\t}\n}\n\nfunc BenchmarkStructSimpleCustomTypeFailureParallel(b *testing.B) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*sql.Valuer)(nil), valuer{})\n\n\tval := valuer{}\n\n\ttype Foo struct {\n\t\tValuer   valuer `validate:\"len=1\"`\n\t\tIntValue int    `validate:\"min=5,max=10\"`\n\t}\n\tvalidFoo := &Foo{Valuer: val, IntValue: 3}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(validate.Struct(validFoo))\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructFilteredSuccess(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\tbyts := []byte(\"Name\")\n\tfn := func(ns []byte) bool {\n\t\treturn !bytes.HasSuffix(ns, byts)\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.StructFiltered(test, fn)\n\t}\n}\n\nfunc BenchmarkStructFilteredSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\tbyts := []byte(\"Name\")\n\tfn := func(ns []byte) bool {\n\t\treturn !bytes.HasSuffix(ns, byts)\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.StructFiltered(test, fn)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructFilteredFailure(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tbyts := []byte(\"NickName\")\n\n\tfn := func(ns []byte) bool {\n\t\treturn !bytes.HasSuffix(ns, byts)\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.StructFiltered(test, fn)\n\t}\n}\n\nfunc BenchmarkStructFilteredFailureParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\tbyts := []byte(\"NickName\")\n\tfn := func(ns []byte) bool {\n\t\treturn !bytes.HasSuffix(ns, byts)\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.StructFiltered(test, fn)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructPartialSuccess(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.StructPartial(test, \"Name\")\n\t}\n}\n\nfunc BenchmarkStructPartialSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.StructPartial(test, \"Name\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructPartialFailure(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.StructPartial(test, \"NickName\")\n\t}\n}\n\nfunc BenchmarkStructPartialFailureParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.StructPartial(test, \"NickName\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructExceptSuccess(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.StructExcept(test, \"Nickname\")\n\t}\n}\n\nfunc BenchmarkStructExceptSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.StructExcept(test, \"NickName\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructExceptFailure(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.StructExcept(test, \"Name\")\n\t}\n}\n\nfunc BenchmarkStructExceptFailureParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName     string `validate:\"required\"`\n\t\tNickName string `validate:\"required\"`\n\t}\n\n\ttest := &Test{\n\t\tName: \"Joey Bloggs\",\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.StructExcept(test, \"Name\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleCrossFieldSuccess(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tStart time.Time\n\t\tEnd   time.Time `validate:\"gtfield=Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * 5)\n\ttest := &Test{\n\t\tStart: now,\n\t\tEnd:   then,\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(test)\n\t}\n}\n\nfunc BenchmarkStructSimpleCrossFieldSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tStart time.Time\n\t\tEnd   time.Time `validate:\"gtfield=Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * 5)\n\ttest := &Test{\n\t\tStart: now,\n\t\tEnd:   then,\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(test)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleCrossFieldFailure(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tStart time.Time\n\t\tEnd   time.Time `validate:\"gtfield=Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * -5)\n\n\ttest := &Test{\n\t\tStart: now,\n\t\tEnd:   then,\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(test)\n\t}\n}\n\nfunc BenchmarkStructSimpleCrossFieldFailureParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tStart time.Time\n\t\tEnd   time.Time `validate:\"gtfield=Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * -5)\n\ttest := &Test{\n\t\tStart: now,\n\t\tEnd:   then,\n\t}\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(test)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleCrossStructCrossFieldSuccess(b *testing.B) {\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tStart time.Time\n\t}\n\n\ttype Outer struct {\n\t\tInner     *Inner\n\t\tCreatedAt time.Time `validate:\"eqcsfield=Inner.Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tinner := &Inner{\n\t\tStart: now,\n\t}\n\touter := &Outer{\n\t\tInner:     inner,\n\t\tCreatedAt: now,\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(outer)\n\t}\n}\n\nfunc BenchmarkStructSimpleCrossStructCrossFieldSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tStart time.Time\n\t}\n\n\ttype Outer struct {\n\t\tInner     *Inner\n\t\tCreatedAt time.Time `validate:\"eqcsfield=Inner.Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tinner := &Inner{\n\t\tStart: now,\n\t}\n\touter := &Outer{\n\t\tInner:     inner,\n\t\tCreatedAt: now,\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(outer)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleCrossStructCrossFieldFailure(b *testing.B) {\n\tvalidate := New()\n\ttype Inner struct {\n\t\tStart time.Time\n\t}\n\n\ttype Outer struct {\n\t\tInner     *Inner\n\t\tCreatedAt time.Time `validate:\"eqcsfield=Inner.Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * 5)\n\n\tinner := &Inner{\n\t\tStart: then,\n\t}\n\n\touter := &Outer{\n\t\tInner:     inner,\n\t\tCreatedAt: now,\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(outer)\n\t}\n}\n\nfunc BenchmarkStructSimpleCrossStructCrossFieldFailureParallel(b *testing.B) {\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tStart time.Time\n\t}\n\n\ttype Outer struct {\n\t\tInner     *Inner\n\t\tCreatedAt time.Time `validate:\"eqcsfield=Inner.Start\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * 5)\n\n\tinner := &Inner{\n\t\tStart: then,\n\t}\n\n\touter := &Outer{\n\t\tInner:     inner,\n\t\tCreatedAt: now,\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(outer)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleSuccess(b *testing.B) {\n\tvalidate := New()\n\ttype Foo struct {\n\t\tStringValue string `validate:\"min=5,max=10\"`\n\t\tIntValue    int    `validate:\"min=5,max=10\"`\n\t}\n\n\tvalidFoo := &Foo{StringValue: \"Foobar\", IntValue: 7}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(validFoo)\n\t}\n}\n\nfunc BenchmarkStructSimpleSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\ttype Foo struct {\n\t\tStringValue string `validate:\"min=5,max=10\"`\n\t\tIntValue    int    `validate:\"min=5,max=10\"`\n\t}\n\tvalidFoo := &Foo{StringValue: \"Foobar\", IntValue: 7}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(validFoo)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructSimpleFailure(b *testing.B) {\n\tvalidate := New()\n\ttype Foo struct {\n\t\tStringValue string `validate:\"min=5,max=10\"`\n\t\tIntValue    int    `validate:\"min=5,max=10\"`\n\t}\n\n\tinvalidFoo := &Foo{StringValue: \"Fo\", IntValue: 3}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(invalidFoo)\n\t}\n}\n\nfunc BenchmarkStructSimpleFailureParallel(b *testing.B) {\n\tvalidate := New()\n\ttype Foo struct {\n\t\tStringValue string `validate:\"min=5,max=10\"`\n\t\tIntValue    int    `validate:\"min=5,max=10\"`\n\t}\n\n\tinvalidFoo := &Foo{StringValue: \"Fo\", IntValue: 3}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(invalidFoo)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructComplexSuccess(b *testing.B) {\n\tvalidate := New()\n\ttSuccess := &TestString{\n\t\tRequired:  \"Required\",\n\t\tLen:       \"length==10\",\n\t\tMin:       \"min=1\",\n\t\tMax:       \"1234567890\",\n\t\tMinMax:    \"12345\",\n\t\tLt:        \"012345678\",\n\t\tLte:       \"0123456789\",\n\t\tGt:        \"01234567890\",\n\t\tGte:       \"0123456789\",\n\t\tOmitEmpty: \"\",\n\t\tSub: &SubTest{\n\t\t\tTest: \"1\",\n\t\t},\n\t\tSubIgnore: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}{\n\t\t\tA: \"1\",\n\t\t},\n\t\tIface: &Impl{\n\t\t\tF: \"123\",\n\t\t},\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(tSuccess)\n\t}\n}\n\nfunc BenchmarkStructComplexSuccessParallel(b *testing.B) {\n\tvalidate := New()\n\ttSuccess := &TestString{\n\t\tRequired:  \"Required\",\n\t\tLen:       \"length==10\",\n\t\tMin:       \"min=1\",\n\t\tMax:       \"1234567890\",\n\t\tMinMax:    \"12345\",\n\t\tLt:        \"012345678\",\n\t\tLte:       \"0123456789\",\n\t\tGt:        \"01234567890\",\n\t\tGte:       \"0123456789\",\n\t\tOmitEmpty: \"\",\n\t\tSub: &SubTest{\n\t\t\tTest: \"1\",\n\t\t},\n\t\tSubIgnore: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}{\n\t\t\tA: \"1\",\n\t\t},\n\t\tIface: &Impl{\n\t\t\tF: \"123\",\n\t\t},\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(tSuccess)\n\t\t}\n\t})\n}\n\nfunc BenchmarkStructComplexFailure(b *testing.B) {\n\tvalidate := New()\n\ttFail := &TestString{\n\t\tRequired:  \"\",\n\t\tLen:       \"\",\n\t\tMin:       \"\",\n\t\tMax:       \"12345678901\",\n\t\tMinMax:    \"\",\n\t\tLt:        \"0123456789\",\n\t\tLte:       \"01234567890\",\n\t\tGt:        \"1\",\n\t\tGte:       \"1\",\n\t\tOmitEmpty: \"12345678901\",\n\t\tSub: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}{\n\t\t\tA: \"\",\n\t\t},\n\t\tIface: &Impl{\n\t\t\tF: \"12\",\n\t\t},\n\t}\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = validate.Struct(tFail)\n\t}\n}\n\nfunc BenchmarkStructComplexFailureParallel(b *testing.B) {\n\tvalidate := New()\n\ttFail := &TestString{\n\t\tRequired:  \"\",\n\t\tLen:       \"\",\n\t\tMin:       \"\",\n\t\tMax:       \"12345678901\",\n\t\tMinMax:    \"\",\n\t\tLt:        \"0123456789\",\n\t\tLte:       \"01234567890\",\n\t\tGt:        \"1\",\n\t\tGte:       \"1\",\n\t\tOmitEmpty: \"12345678901\",\n\t\tSub: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}{\n\t\t\tA: \"\",\n\t\t},\n\t\tIface: &Impl{\n\t\t\tF: \"12\",\n\t\t},\n\t}\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = validate.Struct(tFail)\n\t\t}\n\t})\n}\n\ntype TestOneof struct {\n\tColor string `validate:\"oneof=red green\"`\n}\n\nfunc BenchmarkOneof(b *testing.B) {\n\tw := &TestOneof{Color: \"green\"}\n\tval := New()\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = val.Struct(w)\n\t}\n}\n\nfunc BenchmarkOneofParallel(b *testing.B) {\n\tw := &TestOneof{Color: \"green\"}\n\tval := New()\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = val.Struct(w)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "cache.go",
          "type": "blob",
          "size": 7.61328125,
          "content": "package validator\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\ntype tagType uint8\n\nconst (\n\ttypeDefault tagType = iota\n\ttypeOmitEmpty\n\ttypeIsDefault\n\ttypeNoStructLevel\n\ttypeStructOnly\n\ttypeDive\n\ttypeOr\n\ttypeKeys\n\ttypeEndKeys\n\ttypeOmitNil\n)\n\nconst (\n\tinvalidValidation   = \"Invalid validation tag on field '%s'\"\n\tundefinedValidation = \"Undefined validation function '%s' on field '%s'\"\n\tkeysTagNotDefined   = \"'\" + endKeysTag + \"' tag encountered without a corresponding '\" + keysTag + \"' tag\"\n)\n\ntype structCache struct {\n\tlock sync.Mutex\n\tm    atomic.Value // map[reflect.Type]*cStruct\n}\n\nfunc (sc *structCache) Get(key reflect.Type) (c *cStruct, found bool) {\n\tc, found = sc.m.Load().(map[reflect.Type]*cStruct)[key]\n\treturn\n}\n\nfunc (sc *structCache) Set(key reflect.Type, value *cStruct) {\n\tm := sc.m.Load().(map[reflect.Type]*cStruct)\n\tnm := make(map[reflect.Type]*cStruct, len(m)+1)\n\tfor k, v := range m {\n\t\tnm[k] = v\n\t}\n\tnm[key] = value\n\tsc.m.Store(nm)\n}\n\ntype tagCache struct {\n\tlock sync.Mutex\n\tm    atomic.Value // map[string]*cTag\n}\n\nfunc (tc *tagCache) Get(key string) (c *cTag, found bool) {\n\tc, found = tc.m.Load().(map[string]*cTag)[key]\n\treturn\n}\n\nfunc (tc *tagCache) Set(key string, value *cTag) {\n\tm := tc.m.Load().(map[string]*cTag)\n\tnm := make(map[string]*cTag, len(m)+1)\n\tfor k, v := range m {\n\t\tnm[k] = v\n\t}\n\tnm[key] = value\n\ttc.m.Store(nm)\n}\n\ntype cStruct struct {\n\tname   string\n\tfields []*cField\n\tfn     StructLevelFuncCtx\n}\n\ntype cField struct {\n\tidx        int\n\tname       string\n\taltName    string\n\tnamesEqual bool\n\tcTags      *cTag\n}\n\ntype cTag struct {\n\ttag                  string\n\taliasTag             string\n\tactualAliasTag       string\n\tparam                string\n\tkeys                 *cTag // only populated when using tag's 'keys' and 'endkeys' for map key validation\n\tnext                 *cTag\n\tfn                   FuncCtx\n\ttypeof               tagType\n\thasTag               bool\n\thasAlias             bool\n\thasParam             bool // true if parameter used eg. eq= where the equal sign has been set\n\tisBlockEnd           bool // indicates the current tag represents the last validation in the block\n\trunValidationWhenNil bool\n}\n\nfunc (v *Validate) extractStructCache(current reflect.Value, sName string) *cStruct {\n\tv.structCache.lock.Lock()\n\tdefer v.structCache.lock.Unlock() // leave as defer! because if inner panics, it will never get unlocked otherwise!\n\n\ttyp := current.Type()\n\n\t// could have been multiple trying to access, but once first is done this ensures struct\n\t// isn't parsed again.\n\tcs, ok := v.structCache.Get(typ)\n\tif ok {\n\t\treturn cs\n\t}\n\n\tcs = &cStruct{name: sName, fields: make([]*cField, 0), fn: v.structLevelFuncs[typ]}\n\n\tnumFields := current.NumField()\n\trules := v.rules[typ]\n\n\tvar ctag *cTag\n\tvar fld reflect.StructField\n\tvar tag string\n\tvar customName string\n\n\tfor i := 0; i < numFields; i++ {\n\n\t\tfld = typ.Field(i)\n\n\t\tif !v.privateFieldValidation && !fld.Anonymous && len(fld.PkgPath) > 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif rtag, ok := rules[fld.Name]; ok {\n\t\t\ttag = rtag\n\t\t} else {\n\t\t\ttag = fld.Tag.Get(v.tagName)\n\t\t}\n\n\t\tif tag == skipValidationTag {\n\t\t\tcontinue\n\t\t}\n\n\t\tcustomName = fld.Name\n\n\t\tif v.hasTagNameFunc {\n\t\t\tname := v.tagNameFunc(fld)\n\t\t\tif len(name) > 0 {\n\t\t\t\tcustomName = name\n\t\t\t}\n\t\t}\n\n\t\t// NOTE: cannot use shared tag cache, because tags may be equal, but things like alias may be different\n\t\t// and so only struct level caching can be used instead of combined with Field tag caching\n\n\t\tif len(tag) > 0 {\n\t\t\tctag, _ = v.parseFieldTagsRecursive(tag, fld.Name, \"\", false)\n\t\t} else {\n\t\t\t// even if field doesn't have validations need cTag for traversing to potential inner/nested\n\t\t\t// elements of the field.\n\t\t\tctag = new(cTag)\n\t\t}\n\n\t\tcs.fields = append(cs.fields, &cField{\n\t\t\tidx:        i,\n\t\t\tname:       fld.Name,\n\t\t\taltName:    customName,\n\t\t\tcTags:      ctag,\n\t\t\tnamesEqual: fld.Name == customName,\n\t\t})\n\t}\n\tv.structCache.Set(typ, cs)\n\treturn cs\n}\n\nfunc (v *Validate) parseFieldTagsRecursive(tag string, fieldName string, alias string, hasAlias bool) (firstCtag *cTag, current *cTag) {\n\tvar t string\n\tnoAlias := len(alias) == 0\n\ttags := strings.Split(tag, tagSeparator)\n\n\tfor i := 0; i < len(tags); i++ {\n\t\tt = tags[i]\n\t\tif noAlias {\n\t\t\talias = t\n\t\t}\n\n\t\t// check map for alias and process new tags, otherwise process as usual\n\t\tif tagsVal, found := v.aliases[t]; found {\n\t\t\tif i == 0 {\n\t\t\t\tfirstCtag, current = v.parseFieldTagsRecursive(tagsVal, fieldName, t, true)\n\t\t\t} else {\n\t\t\t\tnext, curr := v.parseFieldTagsRecursive(tagsVal, fieldName, t, true)\n\t\t\t\tcurrent.next, current = next, curr\n\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tvar prevTag tagType\n\n\t\tif i == 0 {\n\t\t\tcurrent = &cTag{aliasTag: alias, hasAlias: hasAlias, hasTag: true, typeof: typeDefault}\n\t\t\tfirstCtag = current\n\t\t} else {\n\t\t\tprevTag = current.typeof\n\t\t\tcurrent.next = &cTag{aliasTag: alias, hasAlias: hasAlias, hasTag: true}\n\t\t\tcurrent = current.next\n\t\t}\n\n\t\tswitch t {\n\t\tcase diveTag:\n\t\t\tcurrent.typeof = typeDive\n\t\t\tcontinue\n\n\t\tcase keysTag:\n\t\t\tcurrent.typeof = typeKeys\n\n\t\t\tif i == 0 || prevTag != typeDive {\n\t\t\t\tpanic(fmt.Sprintf(\"'%s' tag must be immediately preceded by the '%s' tag\", keysTag, diveTag))\n\t\t\t}\n\n\t\t\tcurrent.typeof = typeKeys\n\n\t\t\t// need to pass along only keys tag\n\t\t\t// need to increment i to skip over the keys tags\n\t\t\tb := make([]byte, 0, 64)\n\n\t\t\ti++\n\n\t\t\tfor ; i < len(tags); i++ {\n\n\t\t\t\tb = append(b, tags[i]...)\n\t\t\t\tb = append(b, ',')\n\n\t\t\t\tif tags[i] == endKeysTag {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrent.keys, _ = v.parseFieldTagsRecursive(string(b[:len(b)-1]), fieldName, \"\", false)\n\t\t\tcontinue\n\n\t\tcase endKeysTag:\n\t\t\tcurrent.typeof = typeEndKeys\n\n\t\t\t// if there are more in tags then there was no keysTag defined\n\t\t\t// and an error should be thrown\n\t\t\tif i != len(tags)-1 {\n\t\t\t\tpanic(keysTagNotDefined)\n\t\t\t}\n\t\t\treturn\n\n\t\tcase omitempty:\n\t\t\tcurrent.typeof = typeOmitEmpty\n\t\t\tcontinue\n\n\t\tcase omitnil:\n\t\t\tcurrent.typeof = typeOmitNil\n\t\t\tcontinue\n\n\t\tcase structOnlyTag:\n\t\t\tcurrent.typeof = typeStructOnly\n\t\t\tcontinue\n\n\t\tcase noStructLevelTag:\n\t\t\tcurrent.typeof = typeNoStructLevel\n\t\t\tcontinue\n\n\t\tdefault:\n\t\t\tif t == isdefault {\n\t\t\t\tcurrent.typeof = typeIsDefault\n\t\t\t}\n\t\t\t// if a pipe character is needed within the param you must use the utf8Pipe representation \"0x7C\"\n\t\t\torVals := strings.Split(t, orSeparator)\n\n\t\t\tfor j := 0; j < len(orVals); j++ {\n\t\t\t\tvals := strings.SplitN(orVals[j], tagKeySeparator, 2)\n\t\t\t\tif noAlias {\n\t\t\t\t\talias = vals[0]\n\t\t\t\t\tcurrent.aliasTag = alias\n\t\t\t\t} else {\n\t\t\t\t\tcurrent.actualAliasTag = t\n\t\t\t\t}\n\n\t\t\t\tif j > 0 {\n\t\t\t\t\tcurrent.next = &cTag{aliasTag: alias, actualAliasTag: current.actualAliasTag, hasAlias: hasAlias, hasTag: true}\n\t\t\t\t\tcurrent = current.next\n\t\t\t\t}\n\t\t\t\tcurrent.hasParam = len(vals) > 1\n\n\t\t\t\tcurrent.tag = vals[0]\n\t\t\t\tif len(current.tag) == 0 {\n\t\t\t\t\tpanic(strings.TrimSpace(fmt.Sprintf(invalidValidation, fieldName)))\n\t\t\t\t}\n\n\t\t\t\tif wrapper, ok := v.validations[current.tag]; ok {\n\t\t\t\t\tcurrent.fn = wrapper.fn\n\t\t\t\t\tcurrent.runValidationWhenNil = wrapper.runValidationOnNil\n\t\t\t\t} else {\n\t\t\t\t\tpanic(strings.TrimSpace(fmt.Sprintf(undefinedValidation, current.tag, fieldName)))\n\t\t\t\t}\n\n\t\t\t\tif len(orVals) > 1 {\n\t\t\t\t\tcurrent.typeof = typeOr\n\t\t\t\t}\n\n\t\t\t\tif len(vals) > 1 {\n\t\t\t\t\tcurrent.param = strings.Replace(strings.Replace(vals[1], utf8HexComma, \",\", -1), utf8Pipe, \"|\", -1)\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent.isBlockEnd = true\n\t\t}\n\t}\n\treturn\n}\n\nfunc (v *Validate) fetchCacheTag(tag string) *cTag {\n\t// find cached tag\n\tctag, found := v.tagCache.Get(tag)\n\tif !found {\n\t\tv.tagCache.lock.Lock()\n\t\tdefer v.tagCache.lock.Unlock()\n\n\t\t// could have been multiple trying to access, but once first is done this ensures tag\n\t\t// isn't parsed again.\n\t\tctag, found = v.tagCache.Get(tag)\n\t\tif !found {\n\t\t\tctag, _ = v.parseFieldTagsRecursive(tag, \"\", \"\", false)\n\t\t\tv.tagCache.Set(tag, ctag)\n\t\t}\n\t}\n\treturn ctag\n}\n"
        },
        {
          "name": "country_codes.go",
          "type": "blob",
          "size": 74.1982421875,
          "content": "package validator\n\nvar iso3166_1_alpha2 = map[string]struct{}{\n\t// see: https://www.iso.org/iso-3166-country-codes.html\n\t\"AF\": {}, \"AX\": {}, \"AL\": {}, \"DZ\": {}, \"AS\": {},\n\t\"AD\": {}, \"AO\": {}, \"AI\": {}, \"AQ\": {}, \"AG\": {},\n\t\"AR\": {}, \"AM\": {}, \"AW\": {}, \"AU\": {}, \"AT\": {},\n\t\"AZ\": {}, \"BS\": {}, \"BH\": {}, \"BD\": {}, \"BB\": {},\n\t\"BY\": {}, \"BE\": {}, \"BZ\": {}, \"BJ\": {}, \"BM\": {},\n\t\"BT\": {}, \"BO\": {}, \"BQ\": {}, \"BA\": {}, \"BW\": {},\n\t\"BV\": {}, \"BR\": {}, \"IO\": {}, \"BN\": {}, \"BG\": {},\n\t\"BF\": {}, \"BI\": {}, \"KH\": {}, \"CM\": {}, \"CA\": {},\n\t\"CV\": {}, \"KY\": {}, \"CF\": {}, \"TD\": {}, \"CL\": {},\n\t\"CN\": {}, \"CX\": {}, \"CC\": {}, \"CO\": {}, \"KM\": {},\n\t\"CG\": {}, \"CD\": {}, \"CK\": {}, \"CR\": {}, \"CI\": {},\n\t\"HR\": {}, \"CU\": {}, \"CW\": {}, \"CY\": {}, \"CZ\": {},\n\t\"DK\": {}, \"DJ\": {}, \"DM\": {}, \"DO\": {}, \"EC\": {},\n\t\"EG\": {}, \"SV\": {}, \"GQ\": {}, \"ER\": {}, \"EE\": {},\n\t\"ET\": {}, \"FK\": {}, \"FO\": {}, \"FJ\": {}, \"FI\": {},\n\t\"FR\": {}, \"GF\": {}, \"PF\": {}, \"TF\": {}, \"GA\": {},\n\t\"GM\": {}, \"GE\": {}, \"DE\": {}, \"GH\": {}, \"GI\": {},\n\t\"GR\": {}, \"GL\": {}, \"GD\": {}, \"GP\": {}, \"GU\": {},\n\t\"GT\": {}, \"GG\": {}, \"GN\": {}, \"GW\": {}, \"GY\": {},\n\t\"HT\": {}, \"HM\": {}, \"VA\": {}, \"HN\": {}, \"HK\": {},\n\t\"HU\": {}, \"IS\": {}, \"IN\": {}, \"ID\": {}, \"IR\": {},\n\t\"IQ\": {}, \"IE\": {}, \"IM\": {}, \"IL\": {}, \"IT\": {},\n\t\"JM\": {}, \"JP\": {}, \"JE\": {}, \"JO\": {}, \"KZ\": {},\n\t\"KE\": {}, \"KI\": {}, \"KP\": {}, \"KR\": {}, \"KW\": {},\n\t\"KG\": {}, \"LA\": {}, \"LV\": {}, \"LB\": {}, \"LS\": {},\n\t\"LR\": {}, \"LY\": {}, \"LI\": {}, \"LT\": {}, \"LU\": {},\n\t\"MO\": {}, \"MK\": {}, \"MG\": {}, \"MW\": {}, \"MY\": {},\n\t\"MV\": {}, \"ML\": {}, \"MT\": {}, \"MH\": {}, \"MQ\": {},\n\t\"MR\": {}, \"MU\": {}, \"YT\": {}, \"MX\": {}, \"FM\": {},\n\t\"MD\": {}, \"MC\": {}, \"MN\": {}, \"ME\": {}, \"MS\": {},\n\t\"MA\": {}, \"MZ\": {}, \"MM\": {}, \"NA\": {}, \"NR\": {},\n\t\"NP\": {}, \"NL\": {}, \"NC\": {}, \"NZ\": {}, \"NI\": {},\n\t\"NE\": {}, \"NG\": {}, \"NU\": {}, \"NF\": {}, \"MP\": {},\n\t\"NO\": {}, \"OM\": {}, \"PK\": {}, \"PW\": {}, \"PS\": {},\n\t\"PA\": {}, \"PG\": {}, \"PY\": {}, \"PE\": {}, \"PH\": {},\n\t\"PN\": {}, \"PL\": {}, \"PT\": {}, \"PR\": {}, \"QA\": {},\n\t\"RE\": {}, \"RO\": {}, \"RU\": {}, \"RW\": {}, \"BL\": {},\n\t\"SH\": {}, \"KN\": {}, \"LC\": {}, \"MF\": {}, \"PM\": {},\n\t\"VC\": {}, \"WS\": {}, \"SM\": {}, \"ST\": {}, \"SA\": {},\n\t\"SN\": {}, \"RS\": {}, \"SC\": {}, \"SL\": {}, \"SG\": {},\n\t\"SX\": {}, \"SK\": {}, \"SI\": {}, \"SB\": {}, \"SO\": {},\n\t\"ZA\": {}, \"GS\": {}, \"SS\": {}, \"ES\": {}, \"LK\": {},\n\t\"SD\": {}, \"SR\": {}, \"SJ\": {}, \"SZ\": {}, \"SE\": {},\n\t\"CH\": {}, \"SY\": {}, \"TW\": {}, \"TJ\": {}, \"TZ\": {},\n\t\"TH\": {}, \"TL\": {}, \"TG\": {}, \"TK\": {}, \"TO\": {},\n\t\"TT\": {}, \"TN\": {}, \"TR\": {}, \"TM\": {}, \"TC\": {},\n\t\"TV\": {}, \"UG\": {}, \"UA\": {}, \"AE\": {}, \"GB\": {},\n\t\"US\": {}, \"UM\": {}, \"UY\": {}, \"UZ\": {}, \"VU\": {},\n\t\"VE\": {}, \"VN\": {}, \"VG\": {}, \"VI\": {}, \"WF\": {},\n\t\"EH\": {}, \"YE\": {}, \"ZM\": {}, \"ZW\": {}, \"XK\": {},\n}\n\nvar iso3166_1_alpha2_eu = map[string]struct{}{\n\t\"AT\": {}, \"BE\": {}, \"BG\": {}, \"HR\": {}, \"CY\": {},\n\t\"CZ\": {}, \"DK\": {}, \"EE\": {}, \"FI\": {}, \"FR\": {},\n\t\"DE\": {}, \"GR\": {}, \"HU\": {}, \"IE\": {}, \"IT\": {},\n\t\"LV\": {}, \"LT\": {}, \"LU\": {}, \"MT\": {}, \"NL\": {},\n\t\"PL\": {}, \"PT\": {}, \"RO\": {}, \"SK\": {}, \"SI\": {},\n\t\"ES\": {}, \"SE\": {},\n}\n\nvar iso3166_1_alpha3 = map[string]struct{}{\n\t// see: https://www.iso.org/iso-3166-country-codes.html\n\t\"AFG\": {}, \"ALB\": {}, \"DZA\": {}, \"ASM\": {}, \"AND\": {},\n\t\"AGO\": {}, \"AIA\": {}, \"ATA\": {}, \"ATG\": {}, \"ARG\": {},\n\t\"ARM\": {}, \"ABW\": {}, \"AUS\": {}, \"AUT\": {}, \"AZE\": {},\n\t\"BHS\": {}, \"BHR\": {}, \"BGD\": {}, \"BRB\": {}, \"BLR\": {},\n\t\"BEL\": {}, \"BLZ\": {}, \"BEN\": {}, \"BMU\": {}, \"BTN\": {},\n\t\"BOL\": {}, \"BES\": {}, \"BIH\": {}, \"BWA\": {}, \"BVT\": {},\n\t\"BRA\": {}, \"IOT\": {}, \"BRN\": {}, \"BGR\": {}, \"BFA\": {},\n\t\"BDI\": {}, \"CPV\": {}, \"KHM\": {}, \"CMR\": {}, \"CAN\": {},\n\t\"CYM\": {}, \"CAF\": {}, \"TCD\": {}, \"CHL\": {}, \"CHN\": {},\n\t\"CXR\": {}, \"CCK\": {}, \"COL\": {}, \"COM\": {}, \"COD\": {},\n\t\"COG\": {}, \"COK\": {}, \"CRI\": {}, \"HRV\": {}, \"CUB\": {},\n\t\"CUW\": {}, \"CYP\": {}, \"CZE\": {}, \"CIV\": {}, \"DNK\": {},\n\t\"DJI\": {}, \"DMA\": {}, \"DOM\": {}, \"ECU\": {}, \"EGY\": {},\n\t\"SLV\": {}, \"GNQ\": {}, \"ERI\": {}, \"EST\": {}, \"SWZ\": {},\n\t\"ETH\": {}, \"FLK\": {}, \"FRO\": {}, \"FJI\": {}, \"FIN\": {},\n\t\"FRA\": {}, \"GUF\": {}, \"PYF\": {}, \"ATF\": {}, \"GAB\": {},\n\t\"GMB\": {}, \"GEO\": {}, \"DEU\": {}, \"GHA\": {}, \"GIB\": {},\n\t\"GRC\": {}, \"GRL\": {}, \"GRD\": {}, \"GLP\": {}, \"GUM\": {},\n\t\"GTM\": {}, \"GGY\": {}, \"GIN\": {}, \"GNB\": {}, \"GUY\": {},\n\t\"HTI\": {}, \"HMD\": {}, \"VAT\": {}, \"HND\": {}, \"HKG\": {},\n\t\"HUN\": {}, \"ISL\": {}, \"IND\": {}, \"IDN\": {}, \"IRN\": {},\n\t\"IRQ\": {}, \"IRL\": {}, \"IMN\": {}, \"ISR\": {}, \"ITA\": {},\n\t\"JAM\": {}, \"JPN\": {}, \"JEY\": {}, \"JOR\": {}, \"KAZ\": {},\n\t\"KEN\": {}, \"KIR\": {}, \"PRK\": {}, \"KOR\": {}, \"KWT\": {},\n\t\"KGZ\": {}, \"LAO\": {}, \"LVA\": {}, \"LBN\": {}, \"LSO\": {},\n\t\"LBR\": {}, \"LBY\": {}, \"LIE\": {}, \"LTU\": {}, \"LUX\": {},\n\t\"MAC\": {}, \"MDG\": {}, \"MWI\": {}, \"MYS\": {}, \"MDV\": {},\n\t\"MLI\": {}, \"MLT\": {}, \"MHL\": {}, \"MTQ\": {}, \"MRT\": {},\n\t\"MUS\": {}, \"MYT\": {}, \"MEX\": {}, \"FSM\": {}, \"MDA\": {},\n\t\"MCO\": {}, \"MNG\": {}, \"MNE\": {}, \"MSR\": {}, \"MAR\": {},\n\t\"MOZ\": {}, \"MMR\": {}, \"NAM\": {}, \"NRU\": {}, \"NPL\": {},\n\t\"NLD\": {}, \"NCL\": {}, \"NZL\": {}, \"NIC\": {}, \"NER\": {},\n\t\"NGA\": {}, \"NIU\": {}, \"NFK\": {}, \"MKD\": {}, \"MNP\": {},\n\t\"NOR\": {}, \"OMN\": {}, \"PAK\": {}, \"PLW\": {}, \"PSE\": {},\n\t\"PAN\": {}, \"PNG\": {}, \"PRY\": {}, \"PER\": {}, \"PHL\": {},\n\t\"PCN\": {}, \"POL\": {}, \"PRT\": {}, \"PRI\": {}, \"QAT\": {},\n\t\"ROU\": {}, \"RUS\": {}, \"RWA\": {}, \"REU\": {}, \"BLM\": {},\n\t\"SHN\": {}, \"KNA\": {}, \"LCA\": {}, \"MAF\": {}, \"SPM\": {},\n\t\"VCT\": {}, \"WSM\": {}, \"SMR\": {}, \"STP\": {}, \"SAU\": {},\n\t\"SEN\": {}, \"SRB\": {}, \"SYC\": {}, \"SLE\": {}, \"SGP\": {},\n\t\"SXM\": {}, \"SVK\": {}, \"SVN\": {}, \"SLB\": {}, \"SOM\": {},\n\t\"ZAF\": {}, \"SGS\": {}, \"SSD\": {}, \"ESP\": {}, \"LKA\": {},\n\t\"SDN\": {}, \"SUR\": {}, \"SJM\": {}, \"SWE\": {}, \"CHE\": {},\n\t\"SYR\": {}, \"TWN\": {}, \"TJK\": {}, \"TZA\": {}, \"THA\": {},\n\t\"TLS\": {}, \"TGO\": {}, \"TKL\": {}, \"TON\": {}, \"TTO\": {},\n\t\"TUN\": {}, \"TUR\": {}, \"TKM\": {}, \"TCA\": {}, \"TUV\": {},\n\t\"UGA\": {}, \"UKR\": {}, \"ARE\": {}, \"GBR\": {}, \"UMI\": {},\n\t\"USA\": {}, \"URY\": {}, \"UZB\": {}, \"VUT\": {}, \"VEN\": {},\n\t\"VNM\": {}, \"VGB\": {}, \"VIR\": {}, \"WLF\": {}, \"ESH\": {},\n\t\"YEM\": {}, \"ZMB\": {}, \"ZWE\": {}, \"ALA\": {}, \"UNK\": {},\n}\n\nvar iso3166_1_alpha3_eu = map[string]struct{}{\n\t\"AUT\": {}, \"BEL\": {}, \"BGR\": {}, \"HRV\": {}, \"CYP\": {},\n\t\"CZE\": {}, \"DNK\": {}, \"EST\": {}, \"FIN\": {}, \"FRA\": {},\n\t\"DEU\": {}, \"GRC\": {}, \"HUN\": {}, \"IRL\": {}, \"ITA\": {},\n\t\"LVA\": {}, \"LTU\": {}, \"LUX\": {}, \"MLT\": {}, \"NLD\": {},\n\t\"POL\": {}, \"PRT\": {}, \"ROU\": {}, \"SVK\": {}, \"SVN\": {},\n\t\"ESP\": {}, \"SWE\": {},\n}\nvar iso3166_1_alpha_numeric = map[int]struct{}{\n\t// see: https://www.iso.org/iso-3166-country-codes.html\n\t4: {}, 8: {}, 12: {}, 16: {}, 20: {},\n\t24: {}, 660: {}, 10: {}, 28: {}, 32: {},\n\t51: {}, 533: {}, 36: {}, 40: {}, 31: {},\n\t44: {}, 48: {}, 50: {}, 52: {}, 112: {},\n\t56: {}, 84: {}, 204: {}, 60: {}, 64: {},\n\t68: {}, 535: {}, 70: {}, 72: {}, 74: {},\n\t76: {}, 86: {}, 96: {}, 100: {}, 854: {},\n\t108: {}, 132: {}, 116: {}, 120: {}, 124: {},\n\t136: {}, 140: {}, 148: {}, 152: {}, 156: {},\n\t162: {}, 166: {}, 170: {}, 174: {}, 180: {},\n\t178: {}, 184: {}, 188: {}, 191: {}, 192: {},\n\t531: {}, 196: {}, 203: {}, 384: {}, 208: {},\n\t262: {}, 212: {}, 214: {}, 218: {}, 818: {},\n\t222: {}, 226: {}, 232: {}, 233: {}, 748: {},\n\t231: {}, 238: {}, 234: {}, 242: {}, 246: {},\n\t250: {}, 254: {}, 258: {}, 260: {}, 266: {},\n\t270: {}, 268: {}, 276: {}, 288: {}, 292: {},\n\t300: {}, 304: {}, 308: {}, 312: {}, 316: {},\n\t320: {}, 831: {}, 324: {}, 624: {}, 328: {},\n\t332: {}, 334: {}, 336: {}, 340: {}, 344: {},\n\t348: {}, 352: {}, 356: {}, 360: {}, 364: {},\n\t368: {}, 372: {}, 833: {}, 376: {}, 380: {},\n\t388: {}, 392: {}, 832: {}, 400: {}, 398: {},\n\t404: {}, 296: {}, 408: {}, 410: {}, 414: {},\n\t417: {}, 418: {}, 428: {}, 422: {}, 426: {},\n\t430: {}, 434: {}, 438: {}, 440: {}, 442: {},\n\t446: {}, 450: {}, 454: {}, 458: {}, 462: {},\n\t466: {}, 470: {}, 584: {}, 474: {}, 478: {},\n\t480: {}, 175: {}, 484: {}, 583: {}, 498: {},\n\t492: {}, 496: {}, 499: {}, 500: {}, 504: {},\n\t508: {}, 104: {}, 516: {}, 520: {}, 524: {},\n\t528: {}, 540: {}, 554: {}, 558: {}, 562: {},\n\t566: {}, 570: {}, 574: {}, 807: {}, 580: {},\n\t578: {}, 512: {}, 586: {}, 585: {}, 275: {},\n\t591: {}, 598: {}, 600: {}, 604: {}, 608: {},\n\t612: {}, 616: {}, 620: {}, 630: {}, 634: {},\n\t642: {}, 643: {}, 646: {}, 638: {}, 652: {},\n\t654: {}, 659: {}, 662: {}, 663: {}, 666: {},\n\t670: {}, 882: {}, 674: {}, 678: {}, 682: {},\n\t686: {}, 688: {}, 690: {}, 694: {}, 702: {},\n\t534: {}, 703: {}, 705: {}, 90: {}, 706: {},\n\t710: {}, 239: {}, 728: {}, 724: {}, 144: {},\n\t729: {}, 740: {}, 744: {}, 752: {}, 756: {},\n\t760: {}, 158: {}, 762: {}, 834: {}, 764: {},\n\t626: {}, 768: {}, 772: {}, 776: {}, 780: {},\n\t788: {}, 792: {}, 795: {}, 796: {}, 798: {},\n\t800: {}, 804: {}, 784: {}, 826: {}, 581: {},\n\t840: {}, 858: {}, 860: {}, 548: {}, 862: {},\n\t704: {}, 92: {}, 850: {}, 876: {}, 732: {},\n\t887: {}, 894: {}, 716: {}, 248: {}, 153: {},\n}\n\nvar iso3166_1_alpha_numeric_eu = map[int]struct{}{\n\t40: {}, 56: {}, 100: {}, 191: {}, 196: {},\n\t200: {}, 208: {}, 233: {}, 246: {}, 250: {},\n\t276: {}, 300: {}, 348: {}, 372: {}, 380: {},\n\t428: {}, 440: {}, 442: {}, 470: {}, 528: {},\n\t616: {}, 620: {}, 642: {}, 703: {}, 705: {},\n\t724: {}, 752: {},\n}\n\nvar iso3166_2 = map[string]struct{}{\n\t\"AD-02\": {}, \"AD-03\": {}, \"AD-04\": {}, \"AD-05\": {}, \"AD-06\": {},\n\t\"AD-07\": {}, \"AD-08\": {}, \"AE-AJ\": {}, \"AE-AZ\": {}, \"AE-DU\": {},\n\t\"AE-FU\": {}, \"AE-RK\": {}, \"AE-SH\": {}, \"AE-UQ\": {}, \"AF-BAL\": {},\n\t\"AF-BAM\": {}, \"AF-BDG\": {}, \"AF-BDS\": {}, \"AF-BGL\": {}, \"AF-DAY\": {},\n\t\"AF-FRA\": {}, \"AF-FYB\": {}, \"AF-GHA\": {}, \"AF-GHO\": {}, \"AF-HEL\": {},\n\t\"AF-HER\": {}, \"AF-JOW\": {}, \"AF-KAB\": {}, \"AF-KAN\": {}, \"AF-KAP\": {},\n\t\"AF-KDZ\": {}, \"AF-KHO\": {}, \"AF-KNR\": {}, \"AF-LAG\": {}, \"AF-LOG\": {},\n\t\"AF-NAN\": {}, \"AF-NIM\": {}, \"AF-NUR\": {}, \"AF-PAN\": {}, \"AF-PAR\": {},\n\t\"AF-PIA\": {}, \"AF-PKA\": {}, \"AF-SAM\": {}, \"AF-SAR\": {}, \"AF-TAK\": {},\n\t\"AF-URU\": {}, \"AF-WAR\": {}, \"AF-ZAB\": {}, \"AG-03\": {}, \"AG-04\": {},\n\t\"AG-05\": {}, \"AG-06\": {}, \"AG-07\": {}, \"AG-08\": {}, \"AG-10\": {},\n\t\"AG-11\": {}, \"AL-01\": {}, \"AL-02\": {}, \"AL-03\": {}, \"AL-04\": {},\n\t\"AL-05\": {}, \"AL-06\": {}, \"AL-07\": {}, \"AL-08\": {}, \"AL-09\": {},\n\t\"AL-10\": {}, \"AL-11\": {}, \"AL-12\": {}, \"AL-BR\": {}, \"AL-BU\": {},\n\t\"AL-DI\": {}, \"AL-DL\": {}, \"AL-DR\": {}, \"AL-DV\": {}, \"AL-EL\": {},\n\t\"AL-ER\": {}, \"AL-FR\": {}, \"AL-GJ\": {}, \"AL-GR\": {}, \"AL-HA\": {},\n\t\"AL-KA\": {}, \"AL-KB\": {}, \"AL-KC\": {}, \"AL-KO\": {}, \"AL-KR\": {},\n\t\"AL-KU\": {}, \"AL-LB\": {}, \"AL-LE\": {}, \"AL-LU\": {}, \"AL-MK\": {},\n\t\"AL-MM\": {}, \"AL-MR\": {}, \"AL-MT\": {}, \"AL-PG\": {}, \"AL-PQ\": {},\n\t\"AL-PR\": {}, \"AL-PU\": {}, \"AL-SH\": {}, \"AL-SK\": {}, \"AL-SR\": {},\n\t\"AL-TE\": {}, \"AL-TP\": {}, \"AL-TR\": {}, \"AL-VL\": {}, \"AM-AG\": {},\n\t\"AM-AR\": {}, \"AM-AV\": {}, \"AM-ER\": {}, \"AM-GR\": {}, \"AM-KT\": {},\n\t\"AM-LO\": {}, \"AM-SH\": {}, \"AM-SU\": {}, \"AM-TV\": {}, \"AM-VD\": {},\n\t\"AO-BGO\": {}, \"AO-BGU\": {}, \"AO-BIE\": {}, \"AO-CAB\": {}, \"AO-CCU\": {},\n\t\"AO-CNN\": {}, \"AO-CNO\": {}, \"AO-CUS\": {}, \"AO-HUA\": {}, \"AO-HUI\": {},\n\t\"AO-LNO\": {}, \"AO-LSU\": {}, \"AO-LUA\": {}, \"AO-MAL\": {}, \"AO-MOX\": {},\n\t\"AO-NAM\": {}, \"AO-UIG\": {}, \"AO-ZAI\": {}, \"AR-A\": {}, \"AR-B\": {},\n\t\"AR-C\": {}, \"AR-D\": {}, \"AR-E\": {}, \"AR-F\": {}, \"AR-G\": {}, \"AR-H\": {},\n\t\"AR-J\": {}, \"AR-K\": {}, \"AR-L\": {}, \"AR-M\": {}, \"AR-N\": {},\n\t\"AR-P\": {}, \"AR-Q\": {}, \"AR-R\": {}, \"AR-S\": {}, \"AR-T\": {},\n\t\"AR-U\": {}, \"AR-V\": {}, \"AR-W\": {}, \"AR-X\": {}, \"AR-Y\": {},\n\t\"AR-Z\": {}, \"AT-1\": {}, \"AT-2\": {}, \"AT-3\": {}, \"AT-4\": {},\n\t\"AT-5\": {}, \"AT-6\": {}, \"AT-7\": {}, \"AT-8\": {}, \"AT-9\": {},\n\t\"AU-ACT\": {}, \"AU-NSW\": {}, \"AU-NT\": {}, \"AU-QLD\": {}, \"AU-SA\": {},\n\t\"AU-TAS\": {}, \"AU-VIC\": {}, \"AU-WA\": {}, \"AZ-ABS\": {}, \"AZ-AGA\": {},\n\t\"AZ-AGC\": {}, \"AZ-AGM\": {}, \"AZ-AGS\": {}, \"AZ-AGU\": {}, \"AZ-AST\": {},\n\t\"AZ-BA\": {}, \"AZ-BAB\": {}, \"AZ-BAL\": {}, \"AZ-BAR\": {}, \"AZ-BEY\": {},\n\t\"AZ-BIL\": {}, \"AZ-CAB\": {}, \"AZ-CAL\": {}, \"AZ-CUL\": {}, \"AZ-DAS\": {},\n\t\"AZ-FUZ\": {}, \"AZ-GA\": {}, \"AZ-GAD\": {}, \"AZ-GOR\": {}, \"AZ-GOY\": {},\n\t\"AZ-GYG\": {}, \"AZ-HAC\": {}, \"AZ-IMI\": {}, \"AZ-ISM\": {}, \"AZ-KAL\": {},\n\t\"AZ-KAN\": {}, \"AZ-KUR\": {}, \"AZ-LA\": {}, \"AZ-LAC\": {}, \"AZ-LAN\": {},\n\t\"AZ-LER\": {}, \"AZ-MAS\": {}, \"AZ-MI\": {}, \"AZ-NA\": {}, \"AZ-NEF\": {},\n\t\"AZ-NV\": {}, \"AZ-NX\": {}, \"AZ-OGU\": {}, \"AZ-ORD\": {}, \"AZ-QAB\": {},\n\t\"AZ-QAX\": {}, \"AZ-QAZ\": {}, \"AZ-QBA\": {}, \"AZ-QBI\": {}, \"AZ-QOB\": {},\n\t\"AZ-QUS\": {}, \"AZ-SA\": {}, \"AZ-SAB\": {}, \"AZ-SAD\": {}, \"AZ-SAH\": {},\n\t\"AZ-SAK\": {}, \"AZ-SAL\": {}, \"AZ-SAR\": {}, \"AZ-SAT\": {}, \"AZ-SBN\": {},\n\t\"AZ-SIY\": {}, \"AZ-SKR\": {}, \"AZ-SM\": {}, \"AZ-SMI\": {}, \"AZ-SMX\": {},\n\t\"AZ-SR\": {}, \"AZ-SUS\": {}, \"AZ-TAR\": {}, \"AZ-TOV\": {}, \"AZ-UCA\": {},\n\t\"AZ-XA\": {}, \"AZ-XAC\": {}, \"AZ-XCI\": {}, \"AZ-XIZ\": {}, \"AZ-XVD\": {},\n\t\"AZ-YAR\": {}, \"AZ-YE\": {}, \"AZ-YEV\": {}, \"AZ-ZAN\": {}, \"AZ-ZAQ\": {},\n\t\"AZ-ZAR\": {}, \"BA-01\": {}, \"BA-02\": {}, \"BA-03\": {}, \"BA-04\": {},\n\t\"BA-05\": {}, \"BA-06\": {}, \"BA-07\": {}, \"BA-08\": {}, \"BA-09\": {},\n\t\"BA-10\": {}, \"BA-BIH\": {}, \"BA-BRC\": {}, \"BA-SRP\": {}, \"BB-01\": {},\n\t\"BB-02\": {}, \"BB-03\": {}, \"BB-04\": {}, \"BB-05\": {}, \"BB-06\": {},\n\t\"BB-07\": {}, \"BB-08\": {}, \"BB-09\": {}, \"BB-10\": {}, \"BB-11\": {},\n\t\"BD-01\": {}, \"BD-02\": {}, \"BD-03\": {}, \"BD-04\": {}, \"BD-05\": {},\n\t\"BD-06\": {}, \"BD-07\": {}, \"BD-08\": {}, \"BD-09\": {}, \"BD-10\": {},\n\t\"BD-11\": {}, \"BD-12\": {}, \"BD-13\": {}, \"BD-14\": {}, \"BD-15\": {},\n\t\"BD-16\": {}, \"BD-17\": {}, \"BD-18\": {}, \"BD-19\": {}, \"BD-20\": {},\n\t\"BD-21\": {}, \"BD-22\": {}, \"BD-23\": {}, \"BD-24\": {}, \"BD-25\": {},\n\t\"BD-26\": {}, \"BD-27\": {}, \"BD-28\": {}, \"BD-29\": {}, \"BD-30\": {},\n\t\"BD-31\": {}, \"BD-32\": {}, \"BD-33\": {}, \"BD-34\": {}, \"BD-35\": {},\n\t\"BD-36\": {}, \"BD-37\": {}, \"BD-38\": {}, \"BD-39\": {}, \"BD-40\": {},\n\t\"BD-41\": {}, \"BD-42\": {}, \"BD-43\": {}, \"BD-44\": {}, \"BD-45\": {},\n\t\"BD-46\": {}, \"BD-47\": {}, \"BD-48\": {}, \"BD-49\": {}, \"BD-50\": {},\n\t\"BD-51\": {}, \"BD-52\": {}, \"BD-53\": {}, \"BD-54\": {}, \"BD-55\": {},\n\t\"BD-56\": {}, \"BD-57\": {}, \"BD-58\": {}, \"BD-59\": {}, \"BD-60\": {},\n\t\"BD-61\": {}, \"BD-62\": {}, \"BD-63\": {}, \"BD-64\": {}, \"BD-A\": {},\n\t\"BD-B\": {}, \"BD-C\": {}, \"BD-D\": {}, \"BD-E\": {}, \"BD-F\": {},\n\t\"BD-G\": {}, \"BE-BRU\": {}, \"BE-VAN\": {}, \"BE-VBR\": {}, \"BE-VLG\": {},\n\t\"BE-VLI\": {}, \"BE-VOV\": {}, \"BE-VWV\": {}, \"BE-WAL\": {}, \"BE-WBR\": {},\n\t\"BE-WHT\": {}, \"BE-WLG\": {}, \"BE-WLX\": {}, \"BE-WNA\": {}, \"BF-01\": {},\n\t\"BF-02\": {}, \"BF-03\": {}, \"BF-04\": {}, \"BF-05\": {}, \"BF-06\": {},\n\t\"BF-07\": {}, \"BF-08\": {}, \"BF-09\": {}, \"BF-10\": {}, \"BF-11\": {},\n\t\"BF-12\": {}, \"BF-13\": {}, \"BF-BAL\": {}, \"BF-BAM\": {}, \"BF-BAN\": {},\n\t\"BF-BAZ\": {}, \"BF-BGR\": {}, \"BF-BLG\": {}, \"BF-BLK\": {}, \"BF-COM\": {},\n\t\"BF-GAN\": {}, \"BF-GNA\": {}, \"BF-GOU\": {}, \"BF-HOU\": {}, \"BF-IOB\": {},\n\t\"BF-KAD\": {}, \"BF-KEN\": {}, \"BF-KMD\": {}, \"BF-KMP\": {}, \"BF-KOP\": {},\n\t\"BF-KOS\": {}, \"BF-KOT\": {}, \"BF-KOW\": {}, \"BF-LER\": {}, \"BF-LOR\": {},\n\t\"BF-MOU\": {}, \"BF-NAM\": {}, \"BF-NAO\": {}, \"BF-NAY\": {}, \"BF-NOU\": {},\n\t\"BF-OUB\": {}, \"BF-OUD\": {}, \"BF-PAS\": {}, \"BF-PON\": {}, \"BF-SEN\": {},\n\t\"BF-SIS\": {}, \"BF-SMT\": {}, \"BF-SNG\": {}, \"BF-SOM\": {}, \"BF-SOR\": {},\n\t\"BF-TAP\": {}, \"BF-TUI\": {}, \"BF-YAG\": {}, \"BF-YAT\": {}, \"BF-ZIR\": {},\n\t\"BF-ZON\": {}, \"BF-ZOU\": {}, \"BG-01\": {}, \"BG-02\": {}, \"BG-03\": {},\n\t\"BG-04\": {}, \"BG-05\": {}, \"BG-06\": {}, \"BG-07\": {}, \"BG-08\": {},\n\t\"BG-09\": {}, \"BG-10\": {}, \"BG-11\": {}, \"BG-12\": {}, \"BG-13\": {},\n\t\"BG-14\": {}, \"BG-15\": {}, \"BG-16\": {}, \"BG-17\": {}, \"BG-18\": {},\n\t\"BG-19\": {}, \"BG-20\": {}, \"BG-21\": {}, \"BG-22\": {}, \"BG-23\": {},\n\t\"BG-24\": {}, \"BG-25\": {}, \"BG-26\": {}, \"BG-27\": {}, \"BG-28\": {},\n\t\"BH-13\": {}, \"BH-14\": {}, \"BH-15\": {}, \"BH-16\": {}, \"BH-17\": {},\n\t\"BI-BB\": {}, \"BI-BL\": {}, \"BI-BM\": {}, \"BI-BR\": {}, \"BI-CA\": {},\n\t\"BI-CI\": {}, \"BI-GI\": {}, \"BI-KI\": {}, \"BI-KR\": {}, \"BI-KY\": {},\n\t\"BI-MA\": {}, \"BI-MU\": {}, \"BI-MW\": {}, \"BI-NG\": {}, \"BI-RM\": {}, \"BI-RT\": {},\n\t\"BI-RY\": {}, \"BJ-AK\": {}, \"BJ-AL\": {}, \"BJ-AQ\": {}, \"BJ-BO\": {},\n\t\"BJ-CO\": {}, \"BJ-DO\": {}, \"BJ-KO\": {}, \"BJ-LI\": {}, \"BJ-MO\": {},\n\t\"BJ-OU\": {}, \"BJ-PL\": {}, \"BJ-ZO\": {}, \"BN-BE\": {}, \"BN-BM\": {},\n\t\"BN-TE\": {}, \"BN-TU\": {}, \"BO-B\": {}, \"BO-C\": {}, \"BO-H\": {},\n\t\"BO-L\": {}, \"BO-N\": {}, \"BO-O\": {}, \"BO-P\": {}, \"BO-S\": {},\n\t\"BO-T\": {}, \"BQ-BO\": {}, \"BQ-SA\": {}, \"BQ-SE\": {}, \"BR-AC\": {},\n\t\"BR-AL\": {}, \"BR-AM\": {}, \"BR-AP\": {}, \"BR-BA\": {}, \"BR-CE\": {},\n\t\"BR-DF\": {}, \"BR-ES\": {}, \"BR-FN\": {}, \"BR-GO\": {}, \"BR-MA\": {},\n\t\"BR-MG\": {}, \"BR-MS\": {}, \"BR-MT\": {}, \"BR-PA\": {}, \"BR-PB\": {},\n\t\"BR-PE\": {}, \"BR-PI\": {}, \"BR-PR\": {}, \"BR-RJ\": {}, \"BR-RN\": {},\n\t\"BR-RO\": {}, \"BR-RR\": {}, \"BR-RS\": {}, \"BR-SC\": {}, \"BR-SE\": {},\n\t\"BR-SP\": {}, \"BR-TO\": {}, \"BS-AK\": {}, \"BS-BI\": {}, \"BS-BP\": {},\n\t\"BS-BY\": {}, \"BS-CE\": {}, \"BS-CI\": {}, \"BS-CK\": {}, \"BS-CO\": {},\n\t\"BS-CS\": {}, \"BS-EG\": {}, \"BS-EX\": {}, \"BS-FP\": {}, \"BS-GC\": {},\n\t\"BS-HI\": {}, \"BS-HT\": {}, \"BS-IN\": {}, \"BS-LI\": {}, \"BS-MC\": {},\n\t\"BS-MG\": {}, \"BS-MI\": {}, \"BS-NE\": {}, \"BS-NO\": {}, \"BS-NP\": {}, \"BS-NS\": {},\n\t\"BS-RC\": {}, \"BS-RI\": {}, \"BS-SA\": {}, \"BS-SE\": {}, \"BS-SO\": {},\n\t\"BS-SS\": {}, \"BS-SW\": {}, \"BS-WG\": {}, \"BT-11\": {}, \"BT-12\": {},\n\t\"BT-13\": {}, \"BT-14\": {}, \"BT-15\": {}, \"BT-21\": {}, \"BT-22\": {},\n\t\"BT-23\": {}, \"BT-24\": {}, \"BT-31\": {}, \"BT-32\": {}, \"BT-33\": {},\n\t\"BT-34\": {}, \"BT-41\": {}, \"BT-42\": {}, \"BT-43\": {}, \"BT-44\": {},\n\t\"BT-45\": {}, \"BT-GA\": {}, \"BT-TY\": {}, \"BW-CE\": {}, \"BW-CH\": {}, \"BW-GH\": {},\n\t\"BW-KG\": {}, \"BW-KL\": {}, \"BW-KW\": {}, \"BW-NE\": {}, \"BW-NW\": {},\n\t\"BW-SE\": {}, \"BW-SO\": {}, \"BY-BR\": {}, \"BY-HM\": {}, \"BY-HO\": {},\n\t\"BY-HR\": {}, \"BY-MA\": {}, \"BY-MI\": {}, \"BY-VI\": {}, \"BZ-BZ\": {},\n\t\"BZ-CY\": {}, \"BZ-CZL\": {}, \"BZ-OW\": {}, \"BZ-SC\": {}, \"BZ-TOL\": {},\n\t\"CA-AB\": {}, \"CA-BC\": {}, \"CA-MB\": {}, \"CA-NB\": {}, \"CA-NL\": {},\n\t\"CA-NS\": {}, \"CA-NT\": {}, \"CA-NU\": {}, \"CA-ON\": {}, \"CA-PE\": {},\n\t\"CA-QC\": {}, \"CA-SK\": {}, \"CA-YT\": {}, \"CD-BC\": {}, \"CD-BN\": {},\n\t\"CD-EQ\": {}, \"CD-HK\": {}, \"CD-IT\": {}, \"CD-KA\": {}, \"CD-KC\": {}, \"CD-KE\": {}, \"CD-KG\": {}, \"CD-KN\": {},\n\t\"CD-KW\": {}, \"CD-KS\": {}, \"CD-LU\": {}, \"CD-MA\": {}, \"CD-NK\": {}, \"CD-OR\": {}, \"CD-SA\": {}, \"CD-SK\": {},\n\t\"CD-TA\": {}, \"CD-TO\": {}, \"CF-AC\": {}, \"CF-BB\": {}, \"CF-BGF\": {}, \"CF-BK\": {}, \"CF-HK\": {}, \"CF-HM\": {},\n\t\"CF-HS\": {}, \"CF-KB\": {}, \"CF-KG\": {}, \"CF-LB\": {}, \"CF-MB\": {},\n\t\"CF-MP\": {}, \"CF-NM\": {}, \"CF-OP\": {}, \"CF-SE\": {}, \"CF-UK\": {},\n\t\"CF-VK\": {}, \"CG-11\": {}, \"CG-12\": {}, \"CG-13\": {}, \"CG-14\": {},\n\t\"CG-15\": {}, \"CG-16\": {}, \"CG-2\": {}, \"CG-5\": {}, \"CG-7\": {}, \"CG-8\": {},\n\t\"CG-9\": {}, \"CG-BZV\": {}, \"CH-AG\": {}, \"CH-AI\": {}, \"CH-AR\": {},\n\t\"CH-BE\": {}, \"CH-BL\": {}, \"CH-BS\": {}, \"CH-FR\": {}, \"CH-GE\": {},\n\t\"CH-GL\": {}, \"CH-GR\": {}, \"CH-JU\": {}, \"CH-LU\": {}, \"CH-NE\": {},\n\t\"CH-NW\": {}, \"CH-OW\": {}, \"CH-SG\": {}, \"CH-SH\": {}, \"CH-SO\": {},\n\t\"CH-SZ\": {}, \"CH-TG\": {}, \"CH-TI\": {}, \"CH-UR\": {}, \"CH-VD\": {},\n\t\"CH-VS\": {}, \"CH-ZG\": {}, \"CH-ZH\": {}, \"CI-AB\": {}, \"CI-BS\": {},\n\t\"CI-CM\": {}, \"CI-DN\": {}, \"CI-GD\": {}, \"CI-LC\": {}, \"CI-LG\": {},\n\t\"CI-MG\": {}, \"CI-SM\": {}, \"CI-SV\": {}, \"CI-VB\": {}, \"CI-WR\": {},\n\t\"CI-YM\": {}, \"CI-ZZ\": {}, \"CL-AI\": {}, \"CL-AN\": {}, \"CL-AP\": {},\n\t\"CL-AR\": {}, \"CL-AT\": {}, \"CL-BI\": {}, \"CL-CO\": {}, \"CL-LI\": {},\n\t\"CL-LL\": {}, \"CL-LR\": {}, \"CL-MA\": {}, \"CL-ML\": {}, \"CL-NB\": {}, \"CL-RM\": {},\n\t\"CL-TA\": {}, \"CL-VS\": {}, \"CM-AD\": {}, \"CM-CE\": {}, \"CM-EN\": {},\n\t\"CM-ES\": {}, \"CM-LT\": {}, \"CM-NO\": {}, \"CM-NW\": {}, \"CM-OU\": {},\n\t\"CM-SU\": {}, \"CM-SW\": {}, \"CN-AH\": {}, \"CN-BJ\": {}, \"CN-CQ\": {},\n\t\"CN-FJ\": {}, \"CN-GS\": {}, \"CN-GD\": {}, \"CN-GX\": {}, \"CN-GZ\": {},\n\t\"CN-HI\": {}, \"CN-HE\": {}, \"CN-HL\": {}, \"CN-HA\": {}, \"CN-HB\": {},\n\t\"CN-HN\": {}, \"CN-JS\": {}, \"CN-JX\": {}, \"CN-JL\": {}, \"CN-LN\": {},\n\t\"CN-NM\": {}, \"CN-NX\": {}, \"CN-QH\": {}, \"CN-SN\": {}, \"CN-SD\": {}, \"CN-SH\": {},\n\t\"CN-SX\": {}, \"CN-SC\": {}, \"CN-TJ\": {}, \"CN-XJ\": {}, \"CN-XZ\": {}, \"CN-YN\": {},\n\t\"CN-ZJ\": {}, \"CO-AMA\": {}, \"CO-ANT\": {}, \"CO-ARA\": {}, \"CO-ATL\": {},\n\t\"CO-BOL\": {}, \"CO-BOY\": {}, \"CO-CAL\": {}, \"CO-CAQ\": {}, \"CO-CAS\": {},\n\t\"CO-CAU\": {}, \"CO-CES\": {}, \"CO-CHO\": {}, \"CO-COR\": {}, \"CO-CUN\": {},\n\t\"CO-DC\": {}, \"CO-GUA\": {}, \"CO-GUV\": {}, \"CO-HUI\": {}, \"CO-LAG\": {},\n\t\"CO-MAG\": {}, \"CO-MET\": {}, \"CO-NAR\": {}, \"CO-NSA\": {}, \"CO-PUT\": {},\n\t\"CO-QUI\": {}, \"CO-RIS\": {}, \"CO-SAN\": {}, \"CO-SAP\": {}, \"CO-SUC\": {},\n\t\"CO-TOL\": {}, \"CO-VAC\": {}, \"CO-VAU\": {}, \"CO-VID\": {}, \"CR-A\": {},\n\t\"CR-C\": {}, \"CR-G\": {}, \"CR-H\": {}, \"CR-L\": {}, \"CR-P\": {},\n\t\"CR-SJ\": {}, \"CU-01\": {}, \"CU-02\": {}, \"CU-03\": {}, \"CU-04\": {},\n\t\"CU-05\": {}, \"CU-06\": {}, \"CU-07\": {}, \"CU-08\": {}, \"CU-09\": {},\n\t\"CU-10\": {}, \"CU-11\": {}, \"CU-12\": {}, \"CU-13\": {}, \"CU-14\": {}, \"CU-15\": {},\n\t\"CU-16\": {}, \"CU-99\": {}, \"CV-B\": {}, \"CV-BR\": {}, \"CV-BV\": {}, \"CV-CA\": {},\n\t\"CV-CF\": {}, \"CV-CR\": {}, \"CV-MA\": {}, \"CV-MO\": {}, \"CV-PA\": {},\n\t\"CV-PN\": {}, \"CV-PR\": {}, \"CV-RB\": {}, \"CV-RG\": {}, \"CV-RS\": {},\n\t\"CV-S\": {}, \"CV-SD\": {}, \"CV-SF\": {}, \"CV-SL\": {}, \"CV-SM\": {},\n\t\"CV-SO\": {}, \"CV-SS\": {}, \"CV-SV\": {}, \"CV-TA\": {}, \"CV-TS\": {},\n\t\"CY-01\": {}, \"CY-02\": {}, \"CY-03\": {}, \"CY-04\": {}, \"CY-05\": {},\n\t\"CY-06\": {}, \"CZ-10\": {}, \"CZ-101\": {}, \"CZ-102\": {}, \"CZ-103\": {},\n\t\"CZ-104\": {}, \"CZ-105\": {}, \"CZ-106\": {}, \"CZ-107\": {}, \"CZ-108\": {},\n\t\"CZ-109\": {}, \"CZ-110\": {}, \"CZ-111\": {}, \"CZ-112\": {}, \"CZ-113\": {},\n\t\"CZ-114\": {}, \"CZ-115\": {}, \"CZ-116\": {}, \"CZ-117\": {}, \"CZ-118\": {},\n\t\"CZ-119\": {}, \"CZ-120\": {}, \"CZ-121\": {}, \"CZ-122\": {}, \"CZ-20\": {},\n\t\"CZ-201\": {}, \"CZ-202\": {}, \"CZ-203\": {}, \"CZ-204\": {}, \"CZ-205\": {},\n\t\"CZ-206\": {}, \"CZ-207\": {}, \"CZ-208\": {}, \"CZ-209\": {}, \"CZ-20A\": {},\n\t\"CZ-20B\": {}, \"CZ-20C\": {}, \"CZ-31\": {}, \"CZ-311\": {}, \"CZ-312\": {},\n\t\"CZ-313\": {}, \"CZ-314\": {}, \"CZ-315\": {}, \"CZ-316\": {}, \"CZ-317\": {},\n\t\"CZ-32\": {}, \"CZ-321\": {}, \"CZ-322\": {}, \"CZ-323\": {}, \"CZ-324\": {},\n\t\"CZ-325\": {}, \"CZ-326\": {}, \"CZ-327\": {}, \"CZ-41\": {}, \"CZ-411\": {},\n\t\"CZ-412\": {}, \"CZ-413\": {}, \"CZ-42\": {}, \"CZ-421\": {}, \"CZ-422\": {},\n\t\"CZ-423\": {}, \"CZ-424\": {}, \"CZ-425\": {}, \"CZ-426\": {}, \"CZ-427\": {},\n\t\"CZ-51\": {}, \"CZ-511\": {}, \"CZ-512\": {}, \"CZ-513\": {}, \"CZ-514\": {},\n\t\"CZ-52\": {}, \"CZ-521\": {}, \"CZ-522\": {}, \"CZ-523\": {}, \"CZ-524\": {},\n\t\"CZ-525\": {}, \"CZ-53\": {}, \"CZ-531\": {}, \"CZ-532\": {}, \"CZ-533\": {},\n\t\"CZ-534\": {}, \"CZ-63\": {}, \"CZ-631\": {}, \"CZ-632\": {}, \"CZ-633\": {},\n\t\"CZ-634\": {}, \"CZ-635\": {}, \"CZ-64\": {}, \"CZ-641\": {}, \"CZ-642\": {},\n\t\"CZ-643\": {}, \"CZ-644\": {}, \"CZ-645\": {}, \"CZ-646\": {}, \"CZ-647\": {},\n\t\"CZ-71\": {}, \"CZ-711\": {}, \"CZ-712\": {}, \"CZ-713\": {}, \"CZ-714\": {},\n\t\"CZ-715\": {}, \"CZ-72\": {}, \"CZ-721\": {}, \"CZ-722\": {}, \"CZ-723\": {},\n\t\"CZ-724\": {}, \"CZ-80\": {}, \"CZ-801\": {}, \"CZ-802\": {}, \"CZ-803\": {},\n\t\"CZ-804\": {}, \"CZ-805\": {}, \"CZ-806\": {}, \"DE-BB\": {}, \"DE-BE\": {},\n\t\"DE-BW\": {}, \"DE-BY\": {}, \"DE-HB\": {}, \"DE-HE\": {}, \"DE-HH\": {},\n\t\"DE-MV\": {}, \"DE-NI\": {}, \"DE-NW\": {}, \"DE-RP\": {}, \"DE-SH\": {},\n\t\"DE-SL\": {}, \"DE-SN\": {}, \"DE-ST\": {}, \"DE-TH\": {}, \"DJ-AR\": {},\n\t\"DJ-AS\": {}, \"DJ-DI\": {}, \"DJ-DJ\": {}, \"DJ-OB\": {}, \"DJ-TA\": {},\n\t\"DK-81\": {}, \"DK-82\": {}, \"DK-83\": {}, \"DK-84\": {}, \"DK-85\": {},\n\t\"DM-01\": {}, \"DM-02\": {}, \"DM-03\": {}, \"DM-04\": {}, \"DM-05\": {},\n\t\"DM-06\": {}, \"DM-07\": {}, \"DM-08\": {}, \"DM-09\": {}, \"DM-10\": {},\n\t\"DO-01\": {}, \"DO-02\": {}, \"DO-03\": {}, \"DO-04\": {}, \"DO-05\": {},\n\t\"DO-06\": {}, \"DO-07\": {}, \"DO-08\": {}, \"DO-09\": {}, \"DO-10\": {},\n\t\"DO-11\": {}, \"DO-12\": {}, \"DO-13\": {}, \"DO-14\": {}, \"DO-15\": {},\n\t\"DO-16\": {}, \"DO-17\": {}, \"DO-18\": {}, \"DO-19\": {}, \"DO-20\": {},\n\t\"DO-21\": {}, \"DO-22\": {}, \"DO-23\": {}, \"DO-24\": {}, \"DO-25\": {},\n\t\"DO-26\": {}, \"DO-27\": {}, \"DO-28\": {}, \"DO-29\": {}, \"DO-30\": {}, \"DO-31\": {},\n\t\"DZ-01\": {}, \"DZ-02\": {}, \"DZ-03\": {}, \"DZ-04\": {}, \"DZ-05\": {},\n\t\"DZ-06\": {}, \"DZ-07\": {}, \"DZ-08\": {}, \"DZ-09\": {}, \"DZ-10\": {},\n\t\"DZ-11\": {}, \"DZ-12\": {}, \"DZ-13\": {}, \"DZ-14\": {}, \"DZ-15\": {},\n\t\"DZ-16\": {}, \"DZ-17\": {}, \"DZ-18\": {}, \"DZ-19\": {}, \"DZ-20\": {},\n\t\"DZ-21\": {}, \"DZ-22\": {}, \"DZ-23\": {}, \"DZ-24\": {}, \"DZ-25\": {},\n\t\"DZ-26\": {}, \"DZ-27\": {}, \"DZ-28\": {}, \"DZ-29\": {}, \"DZ-30\": {},\n\t\"DZ-31\": {}, \"DZ-32\": {}, \"DZ-33\": {}, \"DZ-34\": {}, \"DZ-35\": {},\n\t\"DZ-36\": {}, \"DZ-37\": {}, \"DZ-38\": {}, \"DZ-39\": {}, \"DZ-40\": {},\n\t\"DZ-41\": {}, \"DZ-42\": {}, \"DZ-43\": {}, \"DZ-44\": {}, \"DZ-45\": {},\n\t\"DZ-46\": {}, \"DZ-47\": {}, \"DZ-48\": {}, \"DZ-49\": {}, \"DZ-51\": {},\n\t\"DZ-53\": {}, \"DZ-55\": {}, \"DZ-56\": {}, \"DZ-57\": {}, \"EC-A\": {}, \"EC-B\": {},\n\t\"EC-C\": {}, \"EC-D\": {}, \"EC-E\": {}, \"EC-F\": {}, \"EC-G\": {},\n\t\"EC-H\": {}, \"EC-I\": {}, \"EC-L\": {}, \"EC-M\": {}, \"EC-N\": {},\n\t\"EC-O\": {}, \"EC-P\": {}, \"EC-R\": {}, \"EC-S\": {}, \"EC-SD\": {},\n\t\"EC-SE\": {}, \"EC-T\": {}, \"EC-U\": {}, \"EC-W\": {}, \"EC-X\": {},\n\t\"EC-Y\": {}, \"EC-Z\": {}, \"EE-37\": {}, \"EE-39\": {}, \"EE-44\": {}, \"EE-45\": {},\n\t\"EE-49\": {}, \"EE-50\": {}, \"EE-51\": {}, \"EE-52\": {}, \"EE-56\": {}, \"EE-57\": {},\n\t\"EE-59\": {}, \"EE-60\": {}, \"EE-64\": {}, \"EE-65\": {}, \"EE-67\": {}, \"EE-68\": {},\n\t\"EE-70\": {}, \"EE-71\": {}, \"EE-74\": {}, \"EE-78\": {}, \"EE-79\": {}, \"EE-81\": {}, \"EE-82\": {},\n\t\"EE-84\": {}, \"EE-86\": {}, \"EE-87\": {}, \"EG-ALX\": {}, \"EG-ASN\": {}, \"EG-AST\": {},\n\t\"EG-BA\": {}, \"EG-BH\": {}, \"EG-BNS\": {}, \"EG-C\": {}, \"EG-DK\": {},\n\t\"EG-DT\": {}, \"EG-FYM\": {}, \"EG-GH\": {}, \"EG-GZ\": {}, \"EG-HU\": {},\n\t\"EG-IS\": {}, \"EG-JS\": {}, \"EG-KB\": {}, \"EG-KFS\": {}, \"EG-KN\": {},\n\t\"EG-LX\": {}, \"EG-MN\": {}, \"EG-MNF\": {}, \"EG-MT\": {}, \"EG-PTS\": {}, \"EG-SHG\": {},\n\t\"EG-SHR\": {}, \"EG-SIN\": {}, \"EG-SU\": {}, \"EG-SUZ\": {}, \"EG-WAD\": {},\n\t\"ER-AN\": {}, \"ER-DK\": {}, \"ER-DU\": {}, \"ER-GB\": {}, \"ER-MA\": {},\n\t\"ER-SK\": {}, \"ES-A\": {}, \"ES-AB\": {}, \"ES-AL\": {}, \"ES-AN\": {},\n\t\"ES-AR\": {}, \"ES-AS\": {}, \"ES-AV\": {}, \"ES-B\": {}, \"ES-BA\": {},\n\t\"ES-BI\": {}, \"ES-BU\": {}, \"ES-C\": {}, \"ES-CA\": {}, \"ES-CB\": {},\n\t\"ES-CC\": {}, \"ES-CE\": {}, \"ES-CL\": {}, \"ES-CM\": {}, \"ES-CN\": {},\n\t\"ES-CO\": {}, \"ES-CR\": {}, \"ES-CS\": {}, \"ES-CT\": {}, \"ES-CU\": {},\n\t\"ES-EX\": {}, \"ES-GA\": {}, \"ES-GC\": {}, \"ES-GI\": {}, \"ES-GR\": {},\n\t\"ES-GU\": {}, \"ES-H\": {}, \"ES-HU\": {}, \"ES-IB\": {}, \"ES-J\": {},\n\t\"ES-L\": {}, \"ES-LE\": {}, \"ES-LO\": {}, \"ES-LU\": {}, \"ES-M\": {},\n\t\"ES-MA\": {}, \"ES-MC\": {}, \"ES-MD\": {}, \"ES-ML\": {}, \"ES-MU\": {},\n\t\"ES-NA\": {}, \"ES-NC\": {}, \"ES-O\": {}, \"ES-OR\": {}, \"ES-P\": {},\n\t\"ES-PM\": {}, \"ES-PO\": {}, \"ES-PV\": {}, \"ES-RI\": {}, \"ES-S\": {},\n\t\"ES-SA\": {}, \"ES-SE\": {}, \"ES-SG\": {}, \"ES-SO\": {}, \"ES-SS\": {},\n\t\"ES-T\": {}, \"ES-TE\": {}, \"ES-TF\": {}, \"ES-TO\": {}, \"ES-V\": {},\n\t\"ES-VA\": {}, \"ES-VC\": {}, \"ES-VI\": {}, \"ES-Z\": {}, \"ES-ZA\": {},\n\t\"ET-AA\": {}, \"ET-AF\": {}, \"ET-AM\": {}, \"ET-BE\": {}, \"ET-DD\": {},\n\t\"ET-GA\": {}, \"ET-HA\": {}, \"ET-OR\": {}, \"ET-SN\": {}, \"ET-SO\": {},\n\t\"ET-TI\": {}, \"FI-01\": {}, \"FI-02\": {}, \"FI-03\": {}, \"FI-04\": {},\n\t\"FI-05\": {}, \"FI-06\": {}, \"FI-07\": {}, \"FI-08\": {}, \"FI-09\": {},\n\t\"FI-10\": {}, \"FI-11\": {}, \"FI-12\": {}, \"FI-13\": {}, \"FI-14\": {},\n\t\"FI-15\": {}, \"FI-16\": {}, \"FI-17\": {}, \"FI-18\": {}, \"FI-19\": {},\n\t\"FJ-C\": {}, \"FJ-E\": {}, \"FJ-N\": {}, \"FJ-R\": {}, \"FJ-W\": {},\n\t\"FM-KSA\": {}, \"FM-PNI\": {}, \"FM-TRK\": {}, \"FM-YAP\": {}, \"FR-01\": {},\n\t\"FR-02\": {}, \"FR-03\": {}, \"FR-04\": {}, \"FR-05\": {}, \"FR-06\": {},\n\t\"FR-07\": {}, \"FR-08\": {}, \"FR-09\": {}, \"FR-10\": {}, \"FR-11\": {},\n\t\"FR-12\": {}, \"FR-13\": {}, \"FR-14\": {}, \"FR-15\": {}, \"FR-16\": {},\n\t\"FR-17\": {}, \"FR-18\": {}, \"FR-19\": {}, \"FR-20R\": {}, \"FR-21\": {}, \"FR-22\": {},\n\t\"FR-23\": {}, \"FR-24\": {}, \"FR-25\": {}, \"FR-26\": {}, \"FR-27\": {},\n\t\"FR-28\": {}, \"FR-29\": {}, \"FR-2A\": {}, \"FR-2B\": {}, \"FR-30\": {},\n\t\"FR-31\": {}, \"FR-32\": {}, \"FR-33\": {}, \"FR-34\": {}, \"FR-35\": {},\n\t\"FR-36\": {}, \"FR-37\": {}, \"FR-38\": {}, \"FR-39\": {}, \"FR-40\": {},\n\t\"FR-41\": {}, \"FR-42\": {}, \"FR-43\": {}, \"FR-44\": {}, \"FR-45\": {},\n\t\"FR-46\": {}, \"FR-47\": {}, \"FR-48\": {}, \"FR-49\": {}, \"FR-50\": {},\n\t\"FR-51\": {}, \"FR-52\": {}, \"FR-53\": {}, \"FR-54\": {}, \"FR-55\": {},\n\t\"FR-56\": {}, \"FR-57\": {}, \"FR-58\": {}, \"FR-59\": {}, \"FR-60\": {},\n\t\"FR-61\": {}, \"FR-62\": {}, \"FR-63\": {}, \"FR-64\": {}, \"FR-65\": {},\n\t\"FR-66\": {}, \"FR-67\": {}, \"FR-68\": {}, \"FR-69\": {}, \"FR-70\": {},\n\t\"FR-71\": {}, \"FR-72\": {}, \"FR-73\": {}, \"FR-74\": {}, \"FR-75\": {},\n\t\"FR-76\": {}, \"FR-77\": {}, \"FR-78\": {}, \"FR-79\": {}, \"FR-80\": {},\n\t\"FR-81\": {}, \"FR-82\": {}, \"FR-83\": {}, \"FR-84\": {}, \"FR-85\": {},\n\t\"FR-86\": {}, \"FR-87\": {}, \"FR-88\": {}, \"FR-89\": {}, \"FR-90\": {},\n\t\"FR-91\": {}, \"FR-92\": {}, \"FR-93\": {}, \"FR-94\": {}, \"FR-95\": {},\n\t\"FR-ARA\": {}, \"FR-BFC\": {}, \"FR-BL\": {}, \"FR-BRE\": {}, \"FR-COR\": {},\n\t\"FR-CP\": {}, \"FR-CVL\": {}, \"FR-GES\": {}, \"FR-GF\": {}, \"FR-GP\": {},\n\t\"FR-GUA\": {}, \"FR-HDF\": {}, \"FR-IDF\": {}, \"FR-LRE\": {}, \"FR-MAY\": {},\n\t\"FR-MF\": {}, \"FR-MQ\": {}, \"FR-NAQ\": {}, \"FR-NC\": {}, \"FR-NOR\": {},\n\t\"FR-OCC\": {}, \"FR-PAC\": {}, \"FR-PDL\": {}, \"FR-PF\": {}, \"FR-PM\": {},\n\t\"FR-RE\": {}, \"FR-TF\": {}, \"FR-WF\": {}, \"FR-YT\": {}, \"GA-1\": {},\n\t\"GA-2\": {}, \"GA-3\": {}, \"GA-4\": {}, \"GA-5\": {}, \"GA-6\": {},\n\t\"GA-7\": {}, \"GA-8\": {}, \"GA-9\": {}, \"GB-ABC\": {}, \"GB-ABD\": {},\n\t\"GB-ABE\": {}, \"GB-AGB\": {}, \"GB-AGY\": {}, \"GB-AND\": {}, \"GB-ANN\": {},\n\t\"GB-ANS\": {}, \"GB-BAS\": {}, \"GB-BBD\": {}, \"GB-BDF\": {}, \"GB-BDG\": {},\n\t\"GB-BEN\": {}, \"GB-BEX\": {}, \"GB-BFS\": {}, \"GB-BGE\": {}, \"GB-BGW\": {},\n\t\"GB-BIR\": {}, \"GB-BKM\": {}, \"GB-BMH\": {}, \"GB-BNE\": {}, \"GB-BNH\": {},\n\t\"GB-BNS\": {}, \"GB-BOL\": {}, \"GB-BPL\": {}, \"GB-BRC\": {}, \"GB-BRD\": {},\n\t\"GB-BRY\": {}, \"GB-BST\": {}, \"GB-BUR\": {}, \"GB-CAM\": {}, \"GB-CAY\": {},\n\t\"GB-CBF\": {}, \"GB-CCG\": {}, \"GB-CGN\": {}, \"GB-CHE\": {}, \"GB-CHW\": {},\n\t\"GB-CLD\": {}, \"GB-CLK\": {}, \"GB-CMA\": {}, \"GB-CMD\": {}, \"GB-CMN\": {},\n\t\"GB-CON\": {}, \"GB-COV\": {}, \"GB-CRF\": {}, \"GB-CRY\": {}, \"GB-CWY\": {},\n\t\"GB-DAL\": {}, \"GB-DBY\": {}, \"GB-DEN\": {}, \"GB-DER\": {}, \"GB-DEV\": {},\n\t\"GB-DGY\": {}, \"GB-DNC\": {}, \"GB-DND\": {}, \"GB-DOR\": {}, \"GB-DRS\": {},\n\t\"GB-DUD\": {}, \"GB-DUR\": {}, \"GB-EAL\": {}, \"GB-EAW\": {}, \"GB-EAY\": {},\n\t\"GB-EDH\": {}, \"GB-EDU\": {}, \"GB-ELN\": {}, \"GB-ELS\": {}, \"GB-ENF\": {},\n\t\"GB-ENG\": {}, \"GB-ERW\": {}, \"GB-ERY\": {}, \"GB-ESS\": {}, \"GB-ESX\": {},\n\t\"GB-FAL\": {}, \"GB-FIF\": {}, \"GB-FLN\": {}, \"GB-FMO\": {}, \"GB-GAT\": {},\n\t\"GB-GBN\": {}, \"GB-GLG\": {}, \"GB-GLS\": {}, \"GB-GRE\": {}, \"GB-GWN\": {},\n\t\"GB-HAL\": {}, \"GB-HAM\": {}, \"GB-HAV\": {}, \"GB-HCK\": {}, \"GB-HEF\": {},\n\t\"GB-HIL\": {}, \"GB-HLD\": {}, \"GB-HMF\": {}, \"GB-HNS\": {}, \"GB-HPL\": {},\n\t\"GB-HRT\": {}, \"GB-HRW\": {}, \"GB-HRY\": {}, \"GB-IOS\": {}, \"GB-IOW\": {},\n\t\"GB-ISL\": {}, \"GB-IVC\": {}, \"GB-KEC\": {}, \"GB-KEN\": {}, \"GB-KHL\": {},\n\t\"GB-KIR\": {}, \"GB-KTT\": {}, \"GB-KWL\": {}, \"GB-LAN\": {}, \"GB-LBC\": {},\n\t\"GB-LBH\": {}, \"GB-LCE\": {}, \"GB-LDS\": {}, \"GB-LEC\": {}, \"GB-LEW\": {},\n\t\"GB-LIN\": {}, \"GB-LIV\": {}, \"GB-LND\": {}, \"GB-LUT\": {}, \"GB-MAN\": {},\n\t\"GB-MDB\": {}, \"GB-MDW\": {}, \"GB-MEA\": {}, \"GB-MIK\": {}, \"GD-01\": {},\n\t\"GB-MLN\": {}, \"GB-MON\": {}, \"GB-MRT\": {}, \"GB-MRY\": {}, \"GB-MTY\": {},\n\t\"GB-MUL\": {}, \"GB-NAY\": {}, \"GB-NBL\": {}, \"GB-NEL\": {}, \"GB-NET\": {},\n\t\"GB-NFK\": {}, \"GB-NGM\": {}, \"GB-NIR\": {}, \"GB-NLK\": {}, \"GB-NLN\": {},\n\t\"GB-NMD\": {}, \"GB-NSM\": {}, \"GB-NTH\": {}, \"GB-NTL\": {}, \"GB-NTT\": {},\n\t\"GB-NTY\": {}, \"GB-NWM\": {}, \"GB-NWP\": {}, \"GB-NYK\": {}, \"GB-OLD\": {},\n\t\"GB-ORK\": {}, \"GB-OXF\": {}, \"GB-PEM\": {}, \"GB-PKN\": {}, \"GB-PLY\": {},\n\t\"GB-POL\": {}, \"GB-POR\": {}, \"GB-POW\": {}, \"GB-PTE\": {}, \"GB-RCC\": {},\n\t\"GB-RCH\": {}, \"GB-RCT\": {}, \"GB-RDB\": {}, \"GB-RDG\": {}, \"GB-RFW\": {},\n\t\"GB-RIC\": {}, \"GB-ROT\": {}, \"GB-RUT\": {}, \"GB-SAW\": {}, \"GB-SAY\": {},\n\t\"GB-SCB\": {}, \"GB-SCT\": {}, \"GB-SFK\": {}, \"GB-SFT\": {}, \"GB-SGC\": {},\n\t\"GB-SHF\": {}, \"GB-SHN\": {}, \"GB-SHR\": {}, \"GB-SKP\": {}, \"GB-SLF\": {},\n\t\"GB-SLG\": {}, \"GB-SLK\": {}, \"GB-SND\": {}, \"GB-SOL\": {}, \"GB-SOM\": {},\n\t\"GB-SOS\": {}, \"GB-SRY\": {}, \"GB-STE\": {}, \"GB-STG\": {}, \"GB-STH\": {},\n\t\"GB-STN\": {}, \"GB-STS\": {}, \"GB-STT\": {}, \"GB-STY\": {}, \"GB-SWA\": {},\n\t\"GB-SWD\": {}, \"GB-SWK\": {}, \"GB-TAM\": {}, \"GB-TFW\": {}, \"GB-THR\": {},\n\t\"GB-TOB\": {}, \"GB-TOF\": {}, \"GB-TRF\": {}, \"GB-TWH\": {}, \"GB-UKM\": {},\n\t\"GB-VGL\": {}, \"GB-WAR\": {}, \"GB-WBK\": {}, \"GB-WDU\": {}, \"GB-WFT\": {},\n\t\"GB-WGN\": {}, \"GB-WIL\": {}, \"GB-WKF\": {}, \"GB-WLL\": {}, \"GB-WLN\": {},\n\t\"GB-WLS\": {}, \"GB-WLV\": {}, \"GB-WND\": {}, \"GB-WNM\": {}, \"GB-WOK\": {},\n\t\"GB-WOR\": {}, \"GB-WRL\": {}, \"GB-WRT\": {}, \"GB-WRX\": {}, \"GB-WSM\": {},\n\t\"GB-WSX\": {}, \"GB-YOR\": {}, \"GB-ZET\": {}, \"GD-02\": {}, \"GD-03\": {},\n\t\"GD-04\": {}, \"GD-05\": {}, \"GD-06\": {}, \"GD-10\": {}, \"GE-AB\": {},\n\t\"GE-AJ\": {}, \"GE-GU\": {}, \"GE-IM\": {}, \"GE-KA\": {}, \"GE-KK\": {},\n\t\"GE-MM\": {}, \"GE-RL\": {}, \"GE-SJ\": {}, \"GE-SK\": {}, \"GE-SZ\": {},\n\t\"GE-TB\": {}, \"GH-AA\": {}, \"GH-AH\": {}, \"GH-AF\": {}, \"GH-BA\": {}, \"GH-BO\": {}, \"GH-BE\": {}, \"GH-CP\": {},\n\t\"GH-EP\": {}, \"GH-NP\": {}, \"GH-TV\": {}, \"GH-UE\": {}, \"GH-UW\": {},\n\t\"GH-WP\": {}, \"GL-AV\": {}, \"GL-KU\": {}, \"GL-QA\": {}, \"GL-QT\": {}, \"GL-QE\": {}, \"GL-SM\": {},\n\t\"GM-B\": {}, \"GM-L\": {}, \"GM-M\": {}, \"GM-N\": {}, \"GM-U\": {},\n\t\"GM-W\": {}, \"GN-B\": {}, \"GN-BE\": {}, \"GN-BF\": {}, \"GN-BK\": {},\n\t\"GN-C\": {}, \"GN-CO\": {}, \"GN-D\": {}, \"GN-DB\": {}, \"GN-DI\": {},\n\t\"GN-DL\": {}, \"GN-DU\": {}, \"GN-F\": {}, \"GN-FA\": {}, \"GN-FO\": {},\n\t\"GN-FR\": {}, \"GN-GA\": {}, \"GN-GU\": {}, \"GN-K\": {}, \"GN-KA\": {},\n\t\"GN-KB\": {}, \"GN-KD\": {}, \"GN-KE\": {}, \"GN-KN\": {}, \"GN-KO\": {},\n\t\"GN-KS\": {}, \"GN-L\": {}, \"GN-LA\": {}, \"GN-LE\": {}, \"GN-LO\": {},\n\t\"GN-M\": {}, \"GN-MC\": {}, \"GN-MD\": {}, \"GN-ML\": {}, \"GN-MM\": {},\n\t\"GN-N\": {}, \"GN-NZ\": {}, \"GN-PI\": {}, \"GN-SI\": {}, \"GN-TE\": {},\n\t\"GN-TO\": {}, \"GN-YO\": {}, \"GQ-AN\": {}, \"GQ-BN\": {}, \"GQ-BS\": {},\n\t\"GQ-C\": {}, \"GQ-CS\": {}, \"GQ-I\": {}, \"GQ-KN\": {}, \"GQ-LI\": {},\n\t\"GQ-WN\": {}, \"GR-01\": {}, \"GR-03\": {}, \"GR-04\": {}, \"GR-05\": {},\n\t\"GR-06\": {}, \"GR-07\": {}, \"GR-11\": {}, \"GR-12\": {}, \"GR-13\": {},\n\t\"GR-14\": {}, \"GR-15\": {}, \"GR-16\": {}, \"GR-17\": {}, \"GR-21\": {},\n\t\"GR-22\": {}, \"GR-23\": {}, \"GR-24\": {}, \"GR-31\": {}, \"GR-32\": {},\n\t\"GR-33\": {}, \"GR-34\": {}, \"GR-41\": {}, \"GR-42\": {}, \"GR-43\": {},\n\t\"GR-44\": {}, \"GR-51\": {}, \"GR-52\": {}, \"GR-53\": {}, \"GR-54\": {},\n\t\"GR-55\": {}, \"GR-56\": {}, \"GR-57\": {}, \"GR-58\": {}, \"GR-59\": {},\n\t\"GR-61\": {}, \"GR-62\": {}, \"GR-63\": {}, \"GR-64\": {}, \"GR-69\": {},\n\t\"GR-71\": {}, \"GR-72\": {}, \"GR-73\": {}, \"GR-81\": {}, \"GR-82\": {},\n\t\"GR-83\": {}, \"GR-84\": {}, \"GR-85\": {}, \"GR-91\": {}, \"GR-92\": {},\n\t\"GR-93\": {}, \"GR-94\": {}, \"GR-A\": {}, \"GR-A1\": {}, \"GR-B\": {},\n\t\"GR-C\": {}, \"GR-D\": {}, \"GR-E\": {}, \"GR-F\": {}, \"GR-G\": {},\n\t\"GR-H\": {}, \"GR-I\": {}, \"GR-J\": {}, \"GR-K\": {}, \"GR-L\": {},\n\t\"GR-M\": {}, \"GT-01\": {}, \"GT-02\": {}, \"GT-03\": {}, \"GT-04\": {},\n\t\"GT-05\": {}, \"GT-06\": {}, \"GT-07\": {}, \"GT-08\": {}, \"GT-09\": {},\n\t\"GT-10\": {}, \"GT-11\": {}, \"GT-12\": {}, \"GT-13\": {}, \"GT-14\": {},\n\t\"GT-15\": {}, \"GT-16\": {}, \"GT-17\": {}, \"GT-18\": {}, \"GT-19\": {},\n\t\"GT-20\": {}, \"GT-21\": {}, \"GT-22\": {}, \"GW-BA\": {}, \"GW-BL\": {},\n\t\"GW-BM\": {}, \"GW-BS\": {}, \"GW-CA\": {}, \"GW-GA\": {}, \"GW-L\": {},\n\t\"GW-N\": {}, \"GW-OI\": {}, \"GW-QU\": {}, \"GW-S\": {}, \"GW-TO\": {},\n\t\"GY-BA\": {}, \"GY-CU\": {}, \"GY-DE\": {}, \"GY-EB\": {}, \"GY-ES\": {},\n\t\"GY-MA\": {}, \"GY-PM\": {}, \"GY-PT\": {}, \"GY-UD\": {}, \"GY-UT\": {},\n\t\"HN-AT\": {}, \"HN-CH\": {}, \"HN-CL\": {}, \"HN-CM\": {}, \"HN-CP\": {},\n\t\"HN-CR\": {}, \"HN-EP\": {}, \"HN-FM\": {}, \"HN-GD\": {}, \"HN-IB\": {},\n\t\"HN-IN\": {}, \"HN-LE\": {}, \"HN-LP\": {}, \"HN-OC\": {}, \"HN-OL\": {},\n\t\"HN-SB\": {}, \"HN-VA\": {}, \"HN-YO\": {}, \"HR-01\": {}, \"HR-02\": {},\n\t\"HR-03\": {}, \"HR-04\": {}, \"HR-05\": {}, \"HR-06\": {}, \"HR-07\": {},\n\t\"HR-08\": {}, \"HR-09\": {}, \"HR-10\": {}, \"HR-11\": {}, \"HR-12\": {},\n\t\"HR-13\": {}, \"HR-14\": {}, \"HR-15\": {}, \"HR-16\": {}, \"HR-17\": {},\n\t\"HR-18\": {}, \"HR-19\": {}, \"HR-20\": {}, \"HR-21\": {}, \"HT-AR\": {},\n\t\"HT-CE\": {}, \"HT-GA\": {}, \"HT-ND\": {}, \"HT-NE\": {}, \"HT-NO\": {}, \"HT-NI\": {},\n\t\"HT-OU\": {}, \"HT-SD\": {}, \"HT-SE\": {}, \"HU-BA\": {}, \"HU-BC\": {},\n\t\"HU-BE\": {}, \"HU-BK\": {}, \"HU-BU\": {}, \"HU-BZ\": {}, \"HU-CS\": {},\n\t\"HU-DE\": {}, \"HU-DU\": {}, \"HU-EG\": {}, \"HU-ER\": {}, \"HU-FE\": {},\n\t\"HU-GS\": {}, \"HU-GY\": {}, \"HU-HB\": {}, \"HU-HE\": {}, \"HU-HV\": {},\n\t\"HU-JN\": {}, \"HU-KE\": {}, \"HU-KM\": {}, \"HU-KV\": {}, \"HU-MI\": {},\n\t\"HU-NK\": {}, \"HU-NO\": {}, \"HU-NY\": {}, \"HU-PE\": {}, \"HU-PS\": {},\n\t\"HU-SD\": {}, \"HU-SF\": {}, \"HU-SH\": {}, \"HU-SK\": {}, \"HU-SN\": {},\n\t\"HU-SO\": {}, \"HU-SS\": {}, \"HU-ST\": {}, \"HU-SZ\": {}, \"HU-TB\": {},\n\t\"HU-TO\": {}, \"HU-VA\": {}, \"HU-VE\": {}, \"HU-VM\": {}, \"HU-ZA\": {},\n\t\"HU-ZE\": {}, \"ID-AC\": {}, \"ID-BA\": {}, \"ID-BB\": {}, \"ID-BE\": {},\n\t\"ID-BT\": {}, \"ID-GO\": {}, \"ID-IJ\": {}, \"ID-JA\": {}, \"ID-JB\": {},\n\t\"ID-JI\": {}, \"ID-JK\": {}, \"ID-JT\": {}, \"ID-JW\": {}, \"ID-KA\": {},\n\t\"ID-KB\": {}, \"ID-KI\": {}, \"ID-KU\": {}, \"ID-KR\": {}, \"ID-KS\": {},\n\t\"ID-KT\": {}, \"ID-LA\": {}, \"ID-MA\": {}, \"ID-ML\": {}, \"ID-MU\": {},\n\t\"ID-NB\": {}, \"ID-NT\": {}, \"ID-NU\": {}, \"ID-PA\": {}, \"ID-PB\": {},\n\t\"ID-PE\": {}, \"ID-PP\": {}, \"ID-PS\": {}, \"ID-PT\": {}, \"ID-RI\": {},\n\t\"ID-SA\": {}, \"ID-SB\": {}, \"ID-SG\": {}, \"ID-SL\": {}, \"ID-SM\": {},\n\t\"ID-SN\": {}, \"ID-SR\": {}, \"ID-SS\": {}, \"ID-ST\": {}, \"ID-SU\": {},\n\t\"ID-YO\": {}, \"IE-C\": {}, \"IE-CE\": {}, \"IE-CN\": {}, \"IE-CO\": {},\n\t\"IE-CW\": {}, \"IE-D\": {}, \"IE-DL\": {}, \"IE-G\": {}, \"IE-KE\": {},\n\t\"IE-KK\": {}, \"IE-KY\": {}, \"IE-L\": {}, \"IE-LD\": {}, \"IE-LH\": {},\n\t\"IE-LK\": {}, \"IE-LM\": {}, \"IE-LS\": {}, \"IE-M\": {}, \"IE-MH\": {},\n\t\"IE-MN\": {}, \"IE-MO\": {}, \"IE-OY\": {}, \"IE-RN\": {}, \"IE-SO\": {},\n\t\"IE-TA\": {}, \"IE-U\": {}, \"IE-WD\": {}, \"IE-WH\": {}, \"IE-WW\": {},\n\t\"IE-WX\": {}, \"IL-D\": {}, \"IL-HA\": {}, \"IL-JM\": {}, \"IL-M\": {},\n\t\"IL-TA\": {}, \"IL-Z\": {}, \"IN-AN\": {}, \"IN-AP\": {}, \"IN-AR\": {},\n\t\"IN-AS\": {}, \"IN-BR\": {}, \"IN-CH\": {}, \"IN-CT\": {}, \"IN-DH\": {},\n\t\"IN-DL\": {}, \"IN-DN\": {}, \"IN-GA\": {}, \"IN-GJ\": {}, \"IN-HP\": {},\n\t\"IN-HR\": {}, \"IN-JH\": {}, \"IN-JK\": {}, \"IN-KA\": {}, \"IN-KL\": {},\n\t\"IN-LD\": {}, \"IN-MH\": {}, \"IN-ML\": {}, \"IN-MN\": {}, \"IN-MP\": {},\n\t\"IN-MZ\": {}, \"IN-NL\": {}, \"IN-TG\": {}, \"IN-OR\": {}, \"IN-PB\": {}, \"IN-PY\": {},\n\t\"IN-RJ\": {}, \"IN-SK\": {}, \"IN-TN\": {}, \"IN-TR\": {}, \"IN-UP\": {},\n\t\"IN-UT\": {}, \"IN-WB\": {}, \"IQ-AN\": {}, \"IQ-AR\": {}, \"IQ-BA\": {},\n\t\"IQ-BB\": {}, \"IQ-BG\": {}, \"IQ-DA\": {}, \"IQ-DI\": {}, \"IQ-DQ\": {},\n\t\"IQ-KA\": {}, \"IQ-KI\": {}, \"IQ-MA\": {}, \"IQ-MU\": {}, \"IQ-NA\": {}, \"IQ-NI\": {},\n\t\"IQ-QA\": {}, \"IQ-SD\": {}, \"IQ-SW\": {}, \"IQ-SU\": {}, \"IQ-TS\": {}, \"IQ-WA\": {},\n\t\"IR-00\": {}, \"IR-01\": {}, \"IR-02\": {}, \"IR-03\": {}, \"IR-04\": {}, \"IR-05\": {},\n\t\"IR-06\": {}, \"IR-07\": {}, \"IR-08\": {}, \"IR-09\": {}, \"IR-10\": {}, \"IR-11\": {},\n\t\"IR-12\": {}, \"IR-13\": {}, \"IR-14\": {}, \"IR-15\": {}, \"IR-16\": {},\n\t\"IR-17\": {}, \"IR-18\": {}, \"IR-19\": {}, \"IR-20\": {}, \"IR-21\": {},\n\t\"IR-22\": {}, \"IR-23\": {}, \"IR-24\": {}, \"IR-25\": {}, \"IR-26\": {},\n\t\"IR-27\": {}, \"IR-28\": {}, \"IR-29\": {}, \"IR-30\": {}, \"IR-31\": {},\n\t\"IS-0\": {}, \"IS-1\": {}, \"IS-2\": {}, \"IS-3\": {}, \"IS-4\": {},\n\t\"IS-5\": {}, \"IS-6\": {}, \"IS-7\": {}, \"IS-8\": {}, \"IT-21\": {},\n\t\"IT-23\": {}, \"IT-25\": {}, \"IT-32\": {}, \"IT-34\": {}, \"IT-36\": {},\n\t\"IT-42\": {}, \"IT-45\": {}, \"IT-52\": {}, \"IT-55\": {}, \"IT-57\": {},\n\t\"IT-62\": {}, \"IT-65\": {}, \"IT-67\": {}, \"IT-72\": {}, \"IT-75\": {},\n\t\"IT-77\": {}, \"IT-78\": {}, \"IT-82\": {}, \"IT-88\": {}, \"IT-AG\": {},\n\t\"IT-AL\": {}, \"IT-AN\": {}, \"IT-AO\": {}, \"IT-AP\": {}, \"IT-AQ\": {},\n\t\"IT-AR\": {}, \"IT-AT\": {}, \"IT-AV\": {}, \"IT-BA\": {}, \"IT-BG\": {},\n\t\"IT-BI\": {}, \"IT-BL\": {}, \"IT-BN\": {}, \"IT-BO\": {}, \"IT-BR\": {},\n\t\"IT-BS\": {}, \"IT-BT\": {}, \"IT-BZ\": {}, \"IT-CA\": {}, \"IT-CB\": {},\n\t\"IT-CE\": {}, \"IT-CH\": {}, \"IT-CI\": {}, \"IT-CL\": {}, \"IT-CN\": {},\n\t\"IT-CO\": {}, \"IT-CR\": {}, \"IT-CS\": {}, \"IT-CT\": {}, \"IT-CZ\": {},\n\t\"IT-EN\": {}, \"IT-FC\": {}, \"IT-FE\": {}, \"IT-FG\": {}, \"IT-FI\": {},\n\t\"IT-FM\": {}, \"IT-FR\": {}, \"IT-GE\": {}, \"IT-GO\": {}, \"IT-GR\": {},\n\t\"IT-IM\": {}, \"IT-IS\": {}, \"IT-KR\": {}, \"IT-LC\": {}, \"IT-LE\": {},\n\t\"IT-LI\": {}, \"IT-LO\": {}, \"IT-LT\": {}, \"IT-LU\": {}, \"IT-MB\": {},\n\t\"IT-MC\": {}, \"IT-ME\": {}, \"IT-MI\": {}, \"IT-MN\": {}, \"IT-MO\": {},\n\t\"IT-MS\": {}, \"IT-MT\": {}, \"IT-NA\": {}, \"IT-NO\": {}, \"IT-NU\": {},\n\t\"IT-OG\": {}, \"IT-OR\": {}, \"IT-OT\": {}, \"IT-PA\": {}, \"IT-PC\": {},\n\t\"IT-PD\": {}, \"IT-PE\": {}, \"IT-PG\": {}, \"IT-PI\": {}, \"IT-PN\": {},\n\t\"IT-PO\": {}, \"IT-PR\": {}, \"IT-PT\": {}, \"IT-PU\": {}, \"IT-PV\": {},\n\t\"IT-PZ\": {}, \"IT-RA\": {}, \"IT-RC\": {}, \"IT-RE\": {}, \"IT-RG\": {},\n\t\"IT-RI\": {}, \"IT-RM\": {}, \"IT-RN\": {}, \"IT-RO\": {}, \"IT-SA\": {},\n\t\"IT-SI\": {}, \"IT-SO\": {}, \"IT-SP\": {}, \"IT-SR\": {}, \"IT-SS\": {},\n\t\"IT-SV\": {}, \"IT-TA\": {}, \"IT-TE\": {}, \"IT-TN\": {}, \"IT-TO\": {},\n\t\"IT-TP\": {}, \"IT-TR\": {}, \"IT-TS\": {}, \"IT-TV\": {}, \"IT-UD\": {},\n\t\"IT-VA\": {}, \"IT-VB\": {}, \"IT-VC\": {}, \"IT-VE\": {}, \"IT-VI\": {},\n\t\"IT-VR\": {}, \"IT-VS\": {}, \"IT-VT\": {}, \"IT-VV\": {}, \"JM-01\": {},\n\t\"JM-02\": {}, \"JM-03\": {}, \"JM-04\": {}, \"JM-05\": {}, \"JM-06\": {},\n\t\"JM-07\": {}, \"JM-08\": {}, \"JM-09\": {}, \"JM-10\": {}, \"JM-11\": {},\n\t\"JM-12\": {}, \"JM-13\": {}, \"JM-14\": {}, \"JO-AJ\": {}, \"JO-AM\": {},\n\t\"JO-AQ\": {}, \"JO-AT\": {}, \"JO-AZ\": {}, \"JO-BA\": {}, \"JO-IR\": {},\n\t\"JO-JA\": {}, \"JO-KA\": {}, \"JO-MA\": {}, \"JO-MD\": {}, \"JO-MN\": {},\n\t\"JP-01\": {}, \"JP-02\": {}, \"JP-03\": {}, \"JP-04\": {}, \"JP-05\": {},\n\t\"JP-06\": {}, \"JP-07\": {}, \"JP-08\": {}, \"JP-09\": {}, \"JP-10\": {},\n\t\"JP-11\": {}, \"JP-12\": {}, \"JP-13\": {}, \"JP-14\": {}, \"JP-15\": {},\n\t\"JP-16\": {}, \"JP-17\": {}, \"JP-18\": {}, \"JP-19\": {}, \"JP-20\": {},\n\t\"JP-21\": {}, \"JP-22\": {}, \"JP-23\": {}, \"JP-24\": {}, \"JP-25\": {},\n\t\"JP-26\": {}, \"JP-27\": {}, \"JP-28\": {}, \"JP-29\": {}, \"JP-30\": {},\n\t\"JP-31\": {}, \"JP-32\": {}, \"JP-33\": {}, \"JP-34\": {}, \"JP-35\": {},\n\t\"JP-36\": {}, \"JP-37\": {}, \"JP-38\": {}, \"JP-39\": {}, \"JP-40\": {},\n\t\"JP-41\": {}, \"JP-42\": {}, \"JP-43\": {}, \"JP-44\": {}, \"JP-45\": {},\n\t\"JP-46\": {}, \"JP-47\": {}, \"KE-01\": {}, \"KE-02\": {}, \"KE-03\": {},\n\t\"KE-04\": {}, \"KE-05\": {}, \"KE-06\": {}, \"KE-07\": {}, \"KE-08\": {},\n\t\"KE-09\": {}, \"KE-10\": {}, \"KE-11\": {}, \"KE-12\": {}, \"KE-13\": {},\n\t\"KE-14\": {}, \"KE-15\": {}, \"KE-16\": {}, \"KE-17\": {}, \"KE-18\": {},\n\t\"KE-19\": {}, \"KE-20\": {}, \"KE-21\": {}, \"KE-22\": {}, \"KE-23\": {},\n\t\"KE-24\": {}, \"KE-25\": {}, \"KE-26\": {}, \"KE-27\": {}, \"KE-28\": {},\n\t\"KE-29\": {}, \"KE-30\": {}, \"KE-31\": {}, \"KE-32\": {}, \"KE-33\": {},\n\t\"KE-34\": {}, \"KE-35\": {}, \"KE-36\": {}, \"KE-37\": {}, \"KE-38\": {},\n\t\"KE-39\": {}, \"KE-40\": {}, \"KE-41\": {}, \"KE-42\": {}, \"KE-43\": {},\n\t\"KE-44\": {}, \"KE-45\": {}, \"KE-46\": {}, \"KE-47\": {}, \"KG-B\": {},\n\t\"KG-C\": {}, \"KG-GB\": {}, \"KG-GO\": {}, \"KG-J\": {}, \"KG-N\": {}, \"KG-O\": {},\n\t\"KG-T\": {}, \"KG-Y\": {}, \"KH-1\": {}, \"KH-10\": {}, \"KH-11\": {},\n\t\"KH-12\": {}, \"KH-13\": {}, \"KH-14\": {}, \"KH-15\": {}, \"KH-16\": {},\n\t\"KH-17\": {}, \"KH-18\": {}, \"KH-19\": {}, \"KH-2\": {}, \"KH-20\": {},\n\t\"KH-21\": {}, \"KH-22\": {}, \"KH-23\": {}, \"KH-24\": {}, \"KH-3\": {},\n\t\"KH-4\": {}, \"KH-5\": {}, \"KH-6\": {}, \"KH-7\": {}, \"KH-8\": {},\n\t\"KH-9\": {}, \"KI-G\": {}, \"KI-L\": {}, \"KI-P\": {}, \"KM-A\": {},\n\t\"KM-G\": {}, \"KM-M\": {}, \"KN-01\": {}, \"KN-02\": {}, \"KN-03\": {},\n\t\"KN-04\": {}, \"KN-05\": {}, \"KN-06\": {}, \"KN-07\": {}, \"KN-08\": {},\n\t\"KN-09\": {}, \"KN-10\": {}, \"KN-11\": {}, \"KN-12\": {}, \"KN-13\": {},\n\t\"KN-15\": {}, \"KN-K\": {}, \"KN-N\": {}, \"KP-01\": {}, \"KP-02\": {},\n\t\"KP-03\": {}, \"KP-04\": {}, \"KP-05\": {}, \"KP-06\": {}, \"KP-07\": {},\n\t\"KP-08\": {}, \"KP-09\": {}, \"KP-10\": {}, \"KP-13\": {}, \"KR-11\": {},\n\t\"KR-26\": {}, \"KR-27\": {}, \"KR-28\": {}, \"KR-29\": {}, \"KR-30\": {},\n\t\"KR-31\": {}, \"KR-41\": {}, \"KR-42\": {}, \"KR-43\": {}, \"KR-44\": {},\n\t\"KR-45\": {}, \"KR-46\": {}, \"KR-47\": {}, \"KR-48\": {}, \"KR-49\": {},\n\t\"KW-AH\": {}, \"KW-FA\": {}, \"KW-HA\": {}, \"KW-JA\": {}, \"KW-KU\": {},\n\t\"KW-MU\": {}, \"KZ-10\": {}, \"KZ-75\": {}, \"KZ-19\": {}, \"KZ-11\": {},\n\t\"KZ-15\": {}, \"KZ-71\": {}, \"KZ-23\": {}, \"KZ-27\": {}, \"KZ-47\": {},\n\t\"KZ-55\": {}, \"KZ-35\": {}, \"KZ-39\": {}, \"KZ-43\": {}, \"KZ-63\": {},\n\t\"KZ-79\": {}, \"KZ-59\": {}, \"KZ-61\": {}, \"KZ-62\": {}, \"KZ-31\": {},\n\t\"KZ-33\": {}, \"LA-AT\": {}, \"LA-BK\": {}, \"LA-BL\": {},\n\t\"LA-CH\": {}, \"LA-HO\": {}, \"LA-KH\": {}, \"LA-LM\": {}, \"LA-LP\": {},\n\t\"LA-OU\": {}, \"LA-PH\": {}, \"LA-SL\": {}, \"LA-SV\": {}, \"LA-VI\": {},\n\t\"LA-VT\": {}, \"LA-XA\": {}, \"LA-XE\": {}, \"LA-XI\": {}, \"LA-XS\": {},\n\t\"LB-AK\": {}, \"LB-AS\": {}, \"LB-BA\": {}, \"LB-BH\": {}, \"LB-BI\": {},\n\t\"LB-JA\": {}, \"LB-JL\": {}, \"LB-NA\": {}, \"LC-01\": {}, \"LC-02\": {},\n\t\"LC-03\": {}, \"LC-05\": {}, \"LC-06\": {}, \"LC-07\": {}, \"LC-08\": {},\n\t\"LC-10\": {}, \"LC-11\": {}, \"LI-01\": {}, \"LI-02\": {},\n\t\"LI-03\": {}, \"LI-04\": {}, \"LI-05\": {}, \"LI-06\": {}, \"LI-07\": {},\n\t\"LI-08\": {}, \"LI-09\": {}, \"LI-10\": {}, \"LI-11\": {}, \"LK-1\": {},\n\t\"LK-11\": {}, \"LK-12\": {}, \"LK-13\": {}, \"LK-2\": {}, \"LK-21\": {},\n\t\"LK-22\": {}, \"LK-23\": {}, \"LK-3\": {}, \"LK-31\": {}, \"LK-32\": {},\n\t\"LK-33\": {}, \"LK-4\": {}, \"LK-41\": {}, \"LK-42\": {}, \"LK-43\": {},\n\t\"LK-44\": {}, \"LK-45\": {}, \"LK-5\": {}, \"LK-51\": {}, \"LK-52\": {},\n\t\"LK-53\": {}, \"LK-6\": {}, \"LK-61\": {}, \"LK-62\": {}, \"LK-7\": {},\n\t\"LK-71\": {}, \"LK-72\": {}, \"LK-8\": {}, \"LK-81\": {}, \"LK-82\": {},\n\t\"LK-9\": {}, \"LK-91\": {}, \"LK-92\": {}, \"LR-BG\": {}, \"LR-BM\": {},\n\t\"LR-CM\": {}, \"LR-GB\": {}, \"LR-GG\": {}, \"LR-GK\": {}, \"LR-LO\": {},\n\t\"LR-MG\": {}, \"LR-MO\": {}, \"LR-MY\": {}, \"LR-NI\": {}, \"LR-RI\": {},\n\t\"LR-SI\": {}, \"LS-A\": {}, \"LS-B\": {}, \"LS-C\": {}, \"LS-D\": {},\n\t\"LS-E\": {}, \"LS-F\": {}, \"LS-G\": {}, \"LS-H\": {}, \"LS-J\": {},\n\t\"LS-K\": {}, \"LT-AL\": {}, \"LT-KL\": {}, \"LT-KU\": {}, \"LT-MR\": {},\n\t\"LT-PN\": {}, \"LT-SA\": {}, \"LT-TA\": {}, \"LT-TE\": {}, \"LT-UT\": {},\n\t\"LT-VL\": {}, \"LU-CA\": {}, \"LU-CL\": {}, \"LU-DI\": {}, \"LU-EC\": {},\n\t\"LU-ES\": {}, \"LU-GR\": {}, \"LU-LU\": {}, \"LU-ME\": {}, \"LU-RD\": {},\n\t\"LU-RM\": {}, \"LU-VD\": {}, \"LU-WI\": {}, \"LU-D\": {}, \"LU-G\": {}, \"LU-L\": {},\n\t\"LV-001\": {}, \"LV-111\": {}, \"LV-112\": {}, \"LV-113\": {},\n\t\"LV-002\": {}, \"LV-003\": {}, \"LV-004\": {}, \"LV-005\": {}, \"LV-006\": {},\n\t\"LV-007\": {}, \"LV-008\": {}, \"LV-009\": {}, \"LV-010\": {}, \"LV-011\": {},\n\t\"LV-012\": {}, \"LV-013\": {}, \"LV-014\": {}, \"LV-015\": {}, \"LV-016\": {},\n\t\"LV-017\": {}, \"LV-018\": {}, \"LV-019\": {}, \"LV-020\": {}, \"LV-021\": {},\n\t\"LV-022\": {}, \"LV-023\": {}, \"LV-024\": {}, \"LV-025\": {}, \"LV-026\": {},\n\t\"LV-027\": {}, \"LV-028\": {}, \"LV-029\": {}, \"LV-030\": {}, \"LV-031\": {},\n\t\"LV-032\": {}, \"LV-033\": {}, \"LV-034\": {}, \"LV-035\": {}, \"LV-036\": {},\n\t\"LV-037\": {}, \"LV-038\": {}, \"LV-039\": {}, \"LV-040\": {}, \"LV-041\": {},\n\t\"LV-042\": {}, \"LV-043\": {}, \"LV-044\": {}, \"LV-045\": {}, \"LV-046\": {},\n\t\"LV-047\": {}, \"LV-048\": {}, \"LV-049\": {}, \"LV-050\": {}, \"LV-051\": {},\n\t\"LV-052\": {}, \"LV-053\": {}, \"LV-054\": {}, \"LV-055\": {}, \"LV-056\": {},\n\t\"LV-057\": {}, \"LV-058\": {}, \"LV-059\": {}, \"LV-060\": {}, \"LV-061\": {},\n\t\"LV-062\": {}, \"LV-063\": {}, \"LV-064\": {}, \"LV-065\": {}, \"LV-066\": {},\n\t\"LV-067\": {}, \"LV-068\": {}, \"LV-069\": {}, \"LV-070\": {}, \"LV-071\": {},\n\t\"LV-072\": {}, \"LV-073\": {}, \"LV-074\": {}, \"LV-075\": {}, \"LV-076\": {},\n\t\"LV-077\": {}, \"LV-078\": {}, \"LV-079\": {}, \"LV-080\": {}, \"LV-081\": {},\n\t\"LV-082\": {}, \"LV-083\": {}, \"LV-084\": {}, \"LV-085\": {}, \"LV-086\": {},\n\t\"LV-087\": {}, \"LV-088\": {}, \"LV-089\": {}, \"LV-090\": {}, \"LV-091\": {},\n\t\"LV-092\": {}, \"LV-093\": {}, \"LV-094\": {}, \"LV-095\": {}, \"LV-096\": {},\n\t\"LV-097\": {}, \"LV-098\": {}, \"LV-099\": {}, \"LV-100\": {}, \"LV-101\": {},\n\t\"LV-102\": {}, \"LV-103\": {}, \"LV-104\": {}, \"LV-105\": {}, \"LV-106\": {},\n\t\"LV-107\": {}, \"LV-108\": {}, \"LV-109\": {}, \"LV-110\": {}, \"LV-DGV\": {},\n\t\"LV-JEL\": {}, \"LV-JKB\": {}, \"LV-JUR\": {}, \"LV-LPX\": {}, \"LV-REZ\": {},\n\t\"LV-RIX\": {}, \"LV-VEN\": {}, \"LV-VMR\": {}, \"LY-BA\": {}, \"LY-BU\": {},\n\t\"LY-DR\": {}, \"LY-GT\": {}, \"LY-JA\": {}, \"LY-JB\": {}, \"LY-JG\": {},\n\t\"LY-JI\": {}, \"LY-JU\": {}, \"LY-KF\": {}, \"LY-MB\": {}, \"LY-MI\": {},\n\t\"LY-MJ\": {}, \"LY-MQ\": {}, \"LY-NL\": {}, \"LY-NQ\": {}, \"LY-SB\": {},\n\t\"LY-SR\": {}, \"LY-TB\": {}, \"LY-WA\": {}, \"LY-WD\": {}, \"LY-WS\": {},\n\t\"LY-ZA\": {}, \"MA-01\": {}, \"MA-02\": {}, \"MA-03\": {}, \"MA-04\": {},\n\t\"MA-05\": {}, \"MA-06\": {}, \"MA-07\": {}, \"MA-08\": {}, \"MA-09\": {},\n\t\"MA-10\": {}, \"MA-11\": {}, \"MA-12\": {}, \"MA-13\": {}, \"MA-14\": {},\n\t\"MA-15\": {}, \"MA-16\": {}, \"MA-AGD\": {}, \"MA-AOU\": {}, \"MA-ASZ\": {},\n\t\"MA-AZI\": {}, \"MA-BEM\": {}, \"MA-BER\": {}, \"MA-BES\": {}, \"MA-BOD\": {},\n\t\"MA-BOM\": {}, \"MA-CAS\": {}, \"MA-CHE\": {}, \"MA-CHI\": {}, \"MA-CHT\": {},\n\t\"MA-ERR\": {}, \"MA-ESI\": {}, \"MA-ESM\": {}, \"MA-FAH\": {}, \"MA-FES\": {},\n\t\"MA-FIG\": {}, \"MA-GUE\": {}, \"MA-HAJ\": {}, \"MA-HAO\": {}, \"MA-HOC\": {},\n\t\"MA-IFR\": {}, \"MA-INE\": {}, \"MA-JDI\": {}, \"MA-JRA\": {}, \"MA-KEN\": {},\n\t\"MA-KES\": {}, \"MA-KHE\": {}, \"MA-KHN\": {}, \"MA-KHO\": {}, \"MA-LAA\": {},\n\t\"MA-LAR\": {}, \"MA-MED\": {}, \"MA-MEK\": {}, \"MA-MMD\": {}, \"MA-MMN\": {},\n\t\"MA-MOH\": {}, \"MA-MOU\": {}, \"MA-NAD\": {}, \"MA-NOU\": {}, \"MA-OUA\": {},\n\t\"MA-OUD\": {}, \"MA-OUJ\": {}, \"MA-RAB\": {}, \"MA-SAF\": {}, \"MA-SAL\": {},\n\t\"MA-SEF\": {}, \"MA-SET\": {}, \"MA-SIK\": {}, \"MA-SKH\": {}, \"MA-SYB\": {},\n\t\"MA-TAI\": {}, \"MA-TAO\": {}, \"MA-TAR\": {}, \"MA-TAT\": {}, \"MA-TAZ\": {},\n\t\"MA-TET\": {}, \"MA-TIZ\": {}, \"MA-TNG\": {}, \"MA-TNT\": {}, \"MA-ZAG\": {},\n\t\"MC-CL\": {}, \"MC-CO\": {}, \"MC-FO\": {}, \"MC-GA\": {}, \"MC-JE\": {},\n\t\"MC-LA\": {}, \"MC-MA\": {}, \"MC-MC\": {}, \"MC-MG\": {}, \"MC-MO\": {},\n\t\"MC-MU\": {}, \"MC-PH\": {}, \"MC-SD\": {}, \"MC-SO\": {}, \"MC-SP\": {},\n\t\"MC-SR\": {}, \"MC-VR\": {}, \"MD-AN\": {}, \"MD-BA\": {}, \"MD-BD\": {},\n\t\"MD-BR\": {}, \"MD-BS\": {}, \"MD-CA\": {}, \"MD-CL\": {}, \"MD-CM\": {},\n\t\"MD-CR\": {}, \"MD-CS\": {}, \"MD-CT\": {}, \"MD-CU\": {}, \"MD-DO\": {},\n\t\"MD-DR\": {}, \"MD-DU\": {}, \"MD-ED\": {}, \"MD-FA\": {}, \"MD-FL\": {},\n\t\"MD-GA\": {}, \"MD-GL\": {}, \"MD-HI\": {}, \"MD-IA\": {}, \"MD-LE\": {},\n\t\"MD-NI\": {}, \"MD-OC\": {}, \"MD-OR\": {}, \"MD-RE\": {}, \"MD-RI\": {},\n\t\"MD-SD\": {}, \"MD-SI\": {}, \"MD-SN\": {}, \"MD-SO\": {}, \"MD-ST\": {},\n\t\"MD-SV\": {}, \"MD-TA\": {}, \"MD-TE\": {}, \"MD-UN\": {}, \"ME-01\": {},\n\t\"ME-02\": {}, \"ME-03\": {}, \"ME-04\": {}, \"ME-05\": {}, \"ME-06\": {},\n\t\"ME-07\": {}, \"ME-08\": {}, \"ME-09\": {}, \"ME-10\": {}, \"ME-11\": {},\n\t\"ME-12\": {}, \"ME-13\": {}, \"ME-14\": {}, \"ME-15\": {}, \"ME-16\": {},\n\t\"ME-17\": {}, \"ME-18\": {}, \"ME-19\": {}, \"ME-20\": {}, \"ME-21\": {}, \"ME-24\": {},\n\t\"MG-A\": {}, \"MG-D\": {}, \"MG-F\": {}, \"MG-M\": {}, \"MG-T\": {},\n\t\"MG-U\": {}, \"MH-ALK\": {}, \"MH-ALL\": {}, \"MH-ARN\": {}, \"MH-AUR\": {},\n\t\"MH-EBO\": {}, \"MH-ENI\": {}, \"MH-JAB\": {}, \"MH-JAL\": {}, \"MH-KIL\": {},\n\t\"MH-KWA\": {}, \"MH-L\": {}, \"MH-LAE\": {}, \"MH-LIB\": {}, \"MH-LIK\": {},\n\t\"MH-MAJ\": {}, \"MH-MAL\": {}, \"MH-MEJ\": {}, \"MH-MIL\": {}, \"MH-NMK\": {},\n\t\"MH-NMU\": {}, \"MH-RON\": {}, \"MH-T\": {}, \"MH-UJA\": {}, \"MH-UTI\": {},\n\t\"MH-WTJ\": {}, \"MH-WTN\": {}, \"MK-101\": {}, \"MK-102\": {}, \"MK-103\": {},\n\t\"MK-104\": {}, \"MK-105\": {},\n\t\"MK-106\": {}, \"MK-107\": {}, \"MK-108\": {}, \"MK-109\": {}, \"MK-201\": {},\n\t\"MK-202\": {}, \"MK-205\": {}, \"MK-206\": {}, \"MK-207\": {}, \"MK-208\": {},\n\t\"MK-209\": {}, \"MK-210\": {}, \"MK-211\": {}, \"MK-301\": {}, \"MK-303\": {},\n\t\"MK-307\": {}, \"MK-308\": {}, \"MK-310\": {}, \"MK-311\": {}, \"MK-312\": {},\n\t\"MK-401\": {}, \"MK-402\": {}, \"MK-403\": {}, \"MK-404\": {}, \"MK-405\": {},\n\t\"MK-406\": {}, \"MK-408\": {}, \"MK-409\": {}, \"MK-410\": {}, \"MK-501\": {},\n\t\"MK-502\": {}, \"MK-503\": {}, \"MK-505\": {}, \"MK-506\": {}, \"MK-507\": {},\n\t\"MK-508\": {}, \"MK-509\": {}, \"MK-601\": {}, \"MK-602\": {}, \"MK-604\": {},\n\t\"MK-605\": {}, \"MK-606\": {}, \"MK-607\": {}, \"MK-608\": {}, \"MK-609\": {},\n\t\"MK-701\": {}, \"MK-702\": {}, \"MK-703\": {}, \"MK-704\": {}, \"MK-705\": {},\n\t\"MK-803\": {}, \"MK-804\": {}, \"MK-806\": {}, \"MK-807\": {}, \"MK-809\": {},\n\t\"MK-810\": {}, \"MK-811\": {}, \"MK-812\": {}, \"MK-813\": {}, \"MK-814\": {},\n\t\"MK-816\": {}, \"ML-1\": {}, \"ML-2\": {}, \"ML-3\": {}, \"ML-4\": {},\n\t\"ML-5\": {}, \"ML-6\": {}, \"ML-7\": {}, \"ML-8\": {}, \"ML-BKO\": {},\n\t\"MM-01\": {}, \"MM-02\": {}, \"MM-03\": {}, \"MM-04\": {}, \"MM-05\": {},\n\t\"MM-06\": {}, \"MM-07\": {}, \"MM-11\": {}, \"MM-12\": {}, \"MM-13\": {},\n\t\"MM-14\": {}, \"MM-15\": {}, \"MM-16\": {}, \"MM-17\": {}, \"MM-18\": {}, \"MN-035\": {},\n\t\"MN-037\": {}, \"MN-039\": {}, \"MN-041\": {}, \"MN-043\": {}, \"MN-046\": {},\n\t\"MN-047\": {}, \"MN-049\": {}, \"MN-051\": {}, \"MN-053\": {}, \"MN-055\": {},\n\t\"MN-057\": {}, \"MN-059\": {}, \"MN-061\": {}, \"MN-063\": {}, \"MN-064\": {},\n\t\"MN-065\": {}, \"MN-067\": {}, \"MN-069\": {}, \"MN-071\": {}, \"MN-073\": {},\n\t\"MN-1\": {}, \"MR-01\": {}, \"MR-02\": {}, \"MR-03\": {}, \"MR-04\": {},\n\t\"MR-05\": {}, \"MR-06\": {}, \"MR-07\": {}, \"MR-08\": {}, \"MR-09\": {},\n\t\"MR-10\": {}, \"MR-11\": {}, \"MR-12\": {}, \"MR-13\": {}, \"MR-NKC\": {}, \"MT-01\": {},\n\t\"MT-02\": {}, \"MT-03\": {}, \"MT-04\": {}, \"MT-05\": {}, \"MT-06\": {},\n\t\"MT-07\": {}, \"MT-08\": {}, \"MT-09\": {}, \"MT-10\": {}, \"MT-11\": {},\n\t\"MT-12\": {}, \"MT-13\": {}, \"MT-14\": {}, \"MT-15\": {}, \"MT-16\": {},\n\t\"MT-17\": {}, \"MT-18\": {}, \"MT-19\": {}, \"MT-20\": {}, \"MT-21\": {},\n\t\"MT-22\": {}, \"MT-23\": {}, \"MT-24\": {}, \"MT-25\": {}, \"MT-26\": {},\n\t\"MT-27\": {}, \"MT-28\": {}, \"MT-29\": {}, \"MT-30\": {}, \"MT-31\": {},\n\t\"MT-32\": {}, \"MT-33\": {}, \"MT-34\": {}, \"MT-35\": {}, \"MT-36\": {},\n\t\"MT-37\": {}, \"MT-38\": {}, \"MT-39\": {}, \"MT-40\": {}, \"MT-41\": {},\n\t\"MT-42\": {}, \"MT-43\": {}, \"MT-44\": {}, \"MT-45\": {}, \"MT-46\": {},\n\t\"MT-47\": {}, \"MT-48\": {}, \"MT-49\": {}, \"MT-50\": {}, \"MT-51\": {},\n\t\"MT-52\": {}, \"MT-53\": {}, \"MT-54\": {}, \"MT-55\": {}, \"MT-56\": {},\n\t\"MT-57\": {}, \"MT-58\": {}, \"MT-59\": {}, \"MT-60\": {}, \"MT-61\": {},\n\t\"MT-62\": {}, \"MT-63\": {}, \"MT-64\": {}, \"MT-65\": {}, \"MT-66\": {},\n\t\"MT-67\": {}, \"MT-68\": {}, \"MU-AG\": {}, \"MU-BL\": {}, \"MU-BR\": {},\n\t\"MU-CC\": {}, \"MU-CU\": {}, \"MU-FL\": {}, \"MU-GP\": {}, \"MU-MO\": {},\n\t\"MU-PA\": {}, \"MU-PL\": {}, \"MU-PU\": {}, \"MU-PW\": {}, \"MU-QB\": {},\n\t\"MU-RO\": {}, \"MU-RP\": {}, \"MU-RR\": {}, \"MU-SA\": {}, \"MU-VP\": {}, \"MV-00\": {},\n\t\"MV-01\": {}, \"MV-02\": {}, \"MV-03\": {}, \"MV-04\": {}, \"MV-05\": {},\n\t\"MV-07\": {}, \"MV-08\": {}, \"MV-12\": {}, \"MV-13\": {}, \"MV-14\": {},\n\t\"MV-17\": {}, \"MV-20\": {}, \"MV-23\": {}, \"MV-24\": {}, \"MV-25\": {},\n\t\"MV-26\": {}, \"MV-27\": {}, \"MV-28\": {}, \"MV-29\": {}, \"MV-CE\": {},\n\t\"MV-MLE\": {}, \"MV-NC\": {}, \"MV-NO\": {}, \"MV-SC\": {}, \"MV-SU\": {},\n\t\"MV-UN\": {}, \"MV-US\": {}, \"MW-BA\": {}, \"MW-BL\": {}, \"MW-C\": {},\n\t\"MW-CK\": {}, \"MW-CR\": {}, \"MW-CT\": {}, \"MW-DE\": {}, \"MW-DO\": {},\n\t\"MW-KR\": {}, \"MW-KS\": {}, \"MW-LI\": {}, \"MW-LK\": {}, \"MW-MC\": {},\n\t\"MW-MG\": {}, \"MW-MH\": {}, \"MW-MU\": {}, \"MW-MW\": {}, \"MW-MZ\": {},\n\t\"MW-N\": {}, \"MW-NB\": {}, \"MW-NE\": {}, \"MW-NI\": {}, \"MW-NK\": {},\n\t\"MW-NS\": {}, \"MW-NU\": {}, \"MW-PH\": {}, \"MW-RU\": {}, \"MW-S\": {},\n\t\"MW-SA\": {}, \"MW-TH\": {}, \"MW-ZO\": {}, \"MX-AGU\": {}, \"MX-BCN\": {},\n\t\"MX-BCS\": {}, \"MX-CAM\": {}, \"MX-CHH\": {}, \"MX-CHP\": {}, \"MX-COA\": {},\n\t\"MX-COL\": {}, \"MX-CMX\": {}, \"MX-DIF\": {}, \"MX-DUR\": {}, \"MX-GRO\": {}, \"MX-GUA\": {},\n\t\"MX-HID\": {}, \"MX-JAL\": {}, \"MX-MEX\": {}, \"MX-MIC\": {}, \"MX-MOR\": {},\n\t\"MX-NAY\": {}, \"MX-NLE\": {}, \"MX-OAX\": {}, \"MX-PUE\": {}, \"MX-QUE\": {},\n\t\"MX-ROO\": {}, \"MX-SIN\": {}, \"MX-SLP\": {}, \"MX-SON\": {}, \"MX-TAB\": {},\n\t\"MX-TAM\": {}, \"MX-TLA\": {}, \"MX-VER\": {}, \"MX-YUC\": {}, \"MX-ZAC\": {},\n\t\"MY-01\": {}, \"MY-02\": {}, \"MY-03\": {}, \"MY-04\": {}, \"MY-05\": {},\n\t\"MY-06\": {}, \"MY-07\": {}, \"MY-08\": {}, \"MY-09\": {}, \"MY-10\": {},\n\t\"MY-11\": {}, \"MY-12\": {}, \"MY-13\": {}, \"MY-14\": {}, \"MY-15\": {},\n\t\"MY-16\": {}, \"MZ-A\": {}, \"MZ-B\": {}, \"MZ-G\": {}, \"MZ-I\": {},\n\t\"MZ-L\": {}, \"MZ-MPM\": {}, \"MZ-N\": {}, \"MZ-P\": {}, \"MZ-Q\": {},\n\t\"MZ-S\": {}, \"MZ-T\": {}, \"NA-CA\": {}, \"NA-ER\": {}, \"NA-HA\": {},\n\t\"NA-KA\": {}, \"NA-KE\": {}, \"NA-KH\": {}, \"NA-KU\": {}, \"NA-KW\": {}, \"NA-OD\": {}, \"NA-OH\": {},\n\t\"NA-OK\": {}, \"NA-ON\": {}, \"NA-OS\": {}, \"NA-OT\": {}, \"NA-OW\": {},\n\t\"NE-1\": {}, \"NE-2\": {}, \"NE-3\": {}, \"NE-4\": {}, \"NE-5\": {},\n\t\"NE-6\": {}, \"NE-7\": {}, \"NE-8\": {}, \"NG-AB\": {}, \"NG-AD\": {},\n\t\"NG-AK\": {}, \"NG-AN\": {}, \"NG-BA\": {}, \"NG-BE\": {}, \"NG-BO\": {},\n\t\"NG-BY\": {}, \"NG-CR\": {}, \"NG-DE\": {}, \"NG-EB\": {}, \"NG-ED\": {},\n\t\"NG-EK\": {}, \"NG-EN\": {}, \"NG-FC\": {}, \"NG-GO\": {}, \"NG-IM\": {},\n\t\"NG-JI\": {}, \"NG-KD\": {}, \"NG-KE\": {}, \"NG-KN\": {}, \"NG-KO\": {},\n\t\"NG-KT\": {}, \"NG-KW\": {}, \"NG-LA\": {}, \"NG-NA\": {}, \"NG-NI\": {},\n\t\"NG-OG\": {}, \"NG-ON\": {}, \"NG-OS\": {}, \"NG-OY\": {}, \"NG-PL\": {},\n\t\"NG-RI\": {}, \"NG-SO\": {}, \"NG-TA\": {}, \"NG-YO\": {}, \"NG-ZA\": {},\n\t\"NI-AN\": {}, \"NI-AS\": {}, \"NI-BO\": {}, \"NI-CA\": {}, \"NI-CI\": {},\n\t\"NI-CO\": {}, \"NI-ES\": {}, \"NI-GR\": {}, \"NI-JI\": {}, \"NI-LE\": {},\n\t\"NI-MD\": {}, \"NI-MN\": {}, \"NI-MS\": {}, \"NI-MT\": {}, \"NI-NS\": {},\n\t\"NI-RI\": {}, \"NI-SJ\": {}, \"NL-AW\": {}, \"NL-BQ1\": {}, \"NL-BQ2\": {},\n\t\"NL-BQ3\": {}, \"NL-CW\": {}, \"NL-DR\": {}, \"NL-FL\": {}, \"NL-FR\": {},\n\t\"NL-GE\": {}, \"NL-GR\": {}, \"NL-LI\": {}, \"NL-NB\": {}, \"NL-NH\": {},\n\t\"NL-OV\": {}, \"NL-SX\": {}, \"NL-UT\": {}, \"NL-ZE\": {}, \"NL-ZH\": {},\n\t\"NO-03\": {}, \"NO-11\": {}, \"NO-15\": {}, \"NO-16\": {}, \"NO-17\": {},\n\t\"NO-18\": {}, \"NO-21\": {}, \"NO-30\": {}, \"NO-34\": {}, \"NO-38\": {},\n\t\"NO-42\": {}, \"NO-46\": {}, \"NO-50\": {}, \"NO-54\": {},\n\t\"NO-22\": {}, \"NP-1\": {}, \"NP-2\": {}, \"NP-3\": {}, \"NP-4\": {},\n\t\"NP-5\": {}, \"NP-BA\": {}, \"NP-BH\": {}, \"NP-DH\": {}, \"NP-GA\": {},\n\t\"NP-JA\": {}, \"NP-KA\": {}, \"NP-KO\": {}, \"NP-LU\": {}, \"NP-MA\": {},\n\t\"NP-ME\": {}, \"NP-NA\": {}, \"NP-RA\": {}, \"NP-SA\": {}, \"NP-SE\": {},\n\t\"NR-01\": {}, \"NR-02\": {}, \"NR-03\": {}, \"NR-04\": {}, \"NR-05\": {},\n\t\"NR-06\": {}, \"NR-07\": {}, \"NR-08\": {}, \"NR-09\": {}, \"NR-10\": {},\n\t\"NR-11\": {}, \"NR-12\": {}, \"NR-13\": {}, \"NR-14\": {}, \"NZ-AUK\": {},\n\t\"NZ-BOP\": {}, \"NZ-CAN\": {}, \"NZ-CIT\": {}, \"NZ-GIS\": {}, \"NZ-HKB\": {},\n\t\"NZ-MBH\": {}, \"NZ-MWT\": {}, \"NZ-N\": {}, \"NZ-NSN\": {}, \"NZ-NTL\": {},\n\t\"NZ-OTA\": {}, \"NZ-S\": {}, \"NZ-STL\": {}, \"NZ-TAS\": {}, \"NZ-TKI\": {},\n\t\"NZ-WGN\": {}, \"NZ-WKO\": {}, \"NZ-WTC\": {}, \"OM-BA\": {}, \"OM-BS\": {}, \"OM-BU\": {}, \"OM-BJ\": {},\n\t\"OM-DA\": {}, \"OM-MA\": {}, \"OM-MU\": {}, \"OM-SH\": {}, \"OM-SJ\": {}, \"OM-SS\": {}, \"OM-WU\": {},\n\t\"OM-ZA\": {}, \"OM-ZU\": {}, \"PA-1\": {}, \"PA-2\": {}, \"PA-3\": {},\n\t\"PA-4\": {}, \"PA-5\": {}, \"PA-6\": {}, \"PA-7\": {}, \"PA-8\": {},\n\t\"PA-9\": {}, \"PA-EM\": {}, \"PA-KY\": {}, \"PA-NB\": {}, \"PE-AMA\": {},\n\t\"PE-ANC\": {}, \"PE-APU\": {}, \"PE-ARE\": {}, \"PE-AYA\": {}, \"PE-CAJ\": {},\n\t\"PE-CAL\": {}, \"PE-CUS\": {}, \"PE-HUC\": {}, \"PE-HUV\": {}, \"PE-ICA\": {},\n\t\"PE-JUN\": {}, \"PE-LAL\": {}, \"PE-LAM\": {}, \"PE-LIM\": {}, \"PE-LMA\": {},\n\t\"PE-LOR\": {}, \"PE-MDD\": {}, \"PE-MOQ\": {}, \"PE-PAS\": {}, \"PE-PIU\": {},\n\t\"PE-PUN\": {}, \"PE-SAM\": {}, \"PE-TAC\": {}, \"PE-TUM\": {}, \"PE-UCA\": {},\n\t\"PG-CPK\": {}, \"PG-CPM\": {}, \"PG-EBR\": {}, \"PG-EHG\": {}, \"PG-EPW\": {},\n\t\"PG-ESW\": {}, \"PG-GPK\": {}, \"PG-MBA\": {}, \"PG-MPL\": {}, \"PG-MPM\": {},\n\t\"PG-MRL\": {}, \"PG-NCD\": {}, \"PG-NIK\": {}, \"PG-NPP\": {}, \"PG-NSB\": {},\n\t\"PG-SAN\": {}, \"PG-SHM\": {}, \"PG-WBK\": {}, \"PG-WHM\": {}, \"PG-WPD\": {},\n\t\"PH-00\": {}, \"PH-01\": {}, \"PH-02\": {}, \"PH-03\": {}, \"PH-05\": {},\n\t\"PH-06\": {}, \"PH-07\": {}, \"PH-08\": {}, \"PH-09\": {}, \"PH-10\": {},\n\t\"PH-11\": {}, \"PH-12\": {}, \"PH-13\": {}, \"PH-14\": {}, \"PH-15\": {},\n\t\"PH-40\": {}, \"PH-41\": {}, \"PH-ABR\": {}, \"PH-AGN\": {}, \"PH-AGS\": {},\n\t\"PH-AKL\": {}, \"PH-ALB\": {}, \"PH-ANT\": {}, \"PH-APA\": {}, \"PH-AUR\": {},\n\t\"PH-BAN\": {}, \"PH-BAS\": {}, \"PH-BEN\": {}, \"PH-BIL\": {}, \"PH-BOH\": {},\n\t\"PH-BTG\": {}, \"PH-BTN\": {}, \"PH-BUK\": {}, \"PH-BUL\": {}, \"PH-CAG\": {},\n\t\"PH-CAM\": {}, \"PH-CAN\": {}, \"PH-CAP\": {}, \"PH-CAS\": {}, \"PH-CAT\": {},\n\t\"PH-CAV\": {}, \"PH-CEB\": {}, \"PH-COM\": {}, \"PH-DAO\": {}, \"PH-DAS\": {},\n\t\"PH-DAV\": {}, \"PH-DIN\": {}, \"PH-EAS\": {}, \"PH-GUI\": {}, \"PH-IFU\": {},\n\t\"PH-ILI\": {}, \"PH-ILN\": {}, \"PH-ILS\": {}, \"PH-ISA\": {}, \"PH-KAL\": {},\n\t\"PH-LAG\": {}, \"PH-LAN\": {}, \"PH-LAS\": {}, \"PH-LEY\": {}, \"PH-LUN\": {},\n\t\"PH-MAD\": {}, \"PH-MAG\": {}, \"PH-MAS\": {}, \"PH-MDC\": {}, \"PH-MDR\": {},\n\t\"PH-MOU\": {}, \"PH-MSC\": {}, \"PH-MSR\": {}, \"PH-NCO\": {}, \"PH-NEC\": {},\n\t\"PH-NER\": {}, \"PH-NSA\": {}, \"PH-NUE\": {}, \"PH-NUV\": {}, \"PH-PAM\": {},\n\t\"PH-PAN\": {}, \"PH-PLW\": {}, \"PH-QUE\": {}, \"PH-QUI\": {}, \"PH-RIZ\": {},\n\t\"PH-ROM\": {}, \"PH-SAR\": {}, \"PH-SCO\": {}, \"PH-SIG\": {}, \"PH-SLE\": {},\n\t\"PH-SLU\": {}, \"PH-SOR\": {}, \"PH-SUK\": {}, \"PH-SUN\": {}, \"PH-SUR\": {},\n\t\"PH-TAR\": {}, \"PH-TAW\": {}, \"PH-WSA\": {}, \"PH-ZAN\": {}, \"PH-ZAS\": {},\n\t\"PH-ZMB\": {}, \"PH-ZSI\": {}, \"PK-BA\": {}, \"PK-GB\": {}, \"PK-IS\": {},\n\t\"PK-JK\": {}, \"PK-KP\": {}, \"PK-PB\": {}, \"PK-SD\": {}, \"PK-TA\": {},\n\t\"PL-02\": {}, \"PL-04\": {}, \"PL-06\": {}, \"PL-08\": {}, \"PL-10\": {},\n\t\"PL-12\": {}, \"PL-14\": {}, \"PL-16\": {}, \"PL-18\": {}, \"PL-20\": {},\n\t\"PL-22\": {}, \"PL-24\": {}, \"PL-26\": {}, \"PL-28\": {}, \"PL-30\": {}, \"PL-32\": {},\n\t\"PS-BTH\": {}, \"PS-DEB\": {}, \"PS-GZA\": {}, \"PS-HBN\": {},\n\t\"PS-JEM\": {}, \"PS-JEN\": {}, \"PS-JRH\": {}, \"PS-KYS\": {}, \"PS-NBS\": {},\n\t\"PS-NGZ\": {}, \"PS-QQA\": {}, \"PS-RBH\": {}, \"PS-RFH\": {}, \"PS-SLT\": {},\n\t\"PS-TBS\": {}, \"PS-TKM\": {}, \"PT-01\": {}, \"PT-02\": {}, \"PT-03\": {},\n\t\"PT-04\": {}, \"PT-05\": {}, \"PT-06\": {}, \"PT-07\": {}, \"PT-08\": {},\n\t\"PT-09\": {}, \"PT-10\": {}, \"PT-11\": {}, \"PT-12\": {}, \"PT-13\": {},\n\t\"PT-14\": {}, \"PT-15\": {}, \"PT-16\": {}, \"PT-17\": {}, \"PT-18\": {},\n\t\"PT-20\": {}, \"PT-30\": {}, \"PW-002\": {}, \"PW-004\": {}, \"PW-010\": {},\n\t\"PW-050\": {}, \"PW-100\": {}, \"PW-150\": {}, \"PW-212\": {}, \"PW-214\": {},\n\t\"PW-218\": {}, \"PW-222\": {}, \"PW-224\": {}, \"PW-226\": {}, \"PW-227\": {},\n\t\"PW-228\": {}, \"PW-350\": {}, \"PW-370\": {}, \"PY-1\": {}, \"PY-10\": {},\n\t\"PY-11\": {}, \"PY-12\": {}, \"PY-13\": {}, \"PY-14\": {}, \"PY-15\": {},\n\t\"PY-16\": {}, \"PY-19\": {}, \"PY-2\": {}, \"PY-3\": {}, \"PY-4\": {},\n\t\"PY-5\": {}, \"PY-6\": {}, \"PY-7\": {}, \"PY-8\": {}, \"PY-9\": {},\n\t\"PY-ASU\": {}, \"QA-DA\": {}, \"QA-KH\": {}, \"QA-MS\": {}, \"QA-RA\": {},\n\t\"QA-US\": {}, \"QA-WA\": {}, \"QA-ZA\": {}, \"RO-AB\": {}, \"RO-AG\": {},\n\t\"RO-AR\": {}, \"RO-B\": {}, \"RO-BC\": {}, \"RO-BH\": {}, \"RO-BN\": {},\n\t\"RO-BR\": {}, \"RO-BT\": {}, \"RO-BV\": {}, \"RO-BZ\": {}, \"RO-CJ\": {},\n\t\"RO-CL\": {}, \"RO-CS\": {}, \"RO-CT\": {}, \"RO-CV\": {}, \"RO-DB\": {},\n\t\"RO-DJ\": {}, \"RO-GJ\": {}, \"RO-GL\": {}, \"RO-GR\": {}, \"RO-HD\": {},\n\t\"RO-HR\": {}, \"RO-IF\": {}, \"RO-IL\": {}, \"RO-IS\": {}, \"RO-MH\": {},\n\t\"RO-MM\": {}, \"RO-MS\": {}, \"RO-NT\": {}, \"RO-OT\": {}, \"RO-PH\": {},\n\t\"RO-SB\": {}, \"RO-SJ\": {}, \"RO-SM\": {}, \"RO-SV\": {}, \"RO-TL\": {},\n\t\"RO-TM\": {}, \"RO-TR\": {}, \"RO-VL\": {}, \"RO-VN\": {}, \"RO-VS\": {},\n\t\"RS-00\": {}, \"RS-01\": {}, \"RS-02\": {}, \"RS-03\": {}, \"RS-04\": {},\n\t\"RS-05\": {}, \"RS-06\": {}, \"RS-07\": {}, \"RS-08\": {}, \"RS-09\": {},\n\t\"RS-10\": {}, \"RS-11\": {}, \"RS-12\": {}, \"RS-13\": {}, \"RS-14\": {},\n\t\"RS-15\": {}, \"RS-16\": {}, \"RS-17\": {}, \"RS-18\": {}, \"RS-19\": {},\n\t\"RS-20\": {}, \"RS-21\": {}, \"RS-22\": {}, \"RS-23\": {}, \"RS-24\": {},\n\t\"RS-25\": {}, \"RS-26\": {}, \"RS-27\": {}, \"RS-28\": {}, \"RS-29\": {},\n\t\"RS-KM\": {}, \"RS-VO\": {}, \"RU-AD\": {}, \"RU-AL\": {}, \"RU-ALT\": {},\n\t\"RU-AMU\": {}, \"RU-ARK\": {}, \"RU-AST\": {}, \"RU-BA\": {}, \"RU-BEL\": {},\n\t\"RU-BRY\": {}, \"RU-BU\": {}, \"RU-CE\": {}, \"RU-CHE\": {}, \"RU-CHU\": {},\n\t\"RU-CU\": {}, \"RU-DA\": {}, \"RU-IN\": {}, \"RU-IRK\": {}, \"RU-IVA\": {},\n\t\"RU-KAM\": {}, \"RU-KB\": {}, \"RU-KC\": {}, \"RU-KDA\": {}, \"RU-KEM\": {},\n\t\"RU-KGD\": {}, \"RU-KGN\": {}, \"RU-KHA\": {}, \"RU-KHM\": {}, \"RU-KIR\": {},\n\t\"RU-KK\": {}, \"RU-KL\": {}, \"RU-KLU\": {}, \"RU-KO\": {}, \"RU-KOS\": {},\n\t\"RU-KR\": {}, \"RU-KRS\": {}, \"RU-KYA\": {}, \"RU-LEN\": {}, \"RU-LIP\": {},\n\t\"RU-MAG\": {}, \"RU-ME\": {}, \"RU-MO\": {}, \"RU-MOS\": {}, \"RU-MOW\": {},\n\t\"RU-MUR\": {}, \"RU-NEN\": {}, \"RU-NGR\": {}, \"RU-NIZ\": {}, \"RU-NVS\": {},\n\t\"RU-OMS\": {}, \"RU-ORE\": {}, \"RU-ORL\": {}, \"RU-PER\": {}, \"RU-PNZ\": {},\n\t\"RU-PRI\": {}, \"RU-PSK\": {}, \"RU-ROS\": {}, \"RU-RYA\": {}, \"RU-SA\": {},\n\t\"RU-SAK\": {}, \"RU-SAM\": {}, \"RU-SAR\": {}, \"RU-SE\": {}, \"RU-SMO\": {},\n\t\"RU-SPE\": {}, \"RU-STA\": {}, \"RU-SVE\": {}, \"RU-TA\": {}, \"RU-TAM\": {},\n\t\"RU-TOM\": {}, \"RU-TUL\": {}, \"RU-TVE\": {}, \"RU-TY\": {}, \"RU-TYU\": {},\n\t\"RU-UD\": {}, \"RU-ULY\": {}, \"RU-VGG\": {}, \"RU-VLA\": {}, \"RU-VLG\": {},\n\t\"RU-VOR\": {}, \"RU-YAN\": {}, \"RU-YAR\": {}, \"RU-YEV\": {}, \"RU-ZAB\": {},\n\t\"RW-01\": {}, \"RW-02\": {}, \"RW-03\": {}, \"RW-04\": {}, \"RW-05\": {},\n\t\"SA-01\": {}, \"SA-02\": {}, \"SA-03\": {}, \"SA-04\": {}, \"SA-05\": {},\n\t\"SA-06\": {}, \"SA-07\": {}, \"SA-08\": {}, \"SA-09\": {}, \"SA-10\": {},\n\t\"SA-11\": {}, \"SA-12\": {}, \"SA-14\": {}, \"SB-CE\": {}, \"SB-CH\": {},\n\t\"SB-CT\": {}, \"SB-GU\": {}, \"SB-IS\": {}, \"SB-MK\": {}, \"SB-ML\": {},\n\t\"SB-RB\": {}, \"SB-TE\": {}, \"SB-WE\": {}, \"SC-01\": {}, \"SC-02\": {},\n\t\"SC-03\": {}, \"SC-04\": {}, \"SC-05\": {}, \"SC-06\": {}, \"SC-07\": {},\n\t\"SC-08\": {}, \"SC-09\": {}, \"SC-10\": {}, \"SC-11\": {}, \"SC-12\": {},\n\t\"SC-13\": {}, \"SC-14\": {}, \"SC-15\": {}, \"SC-16\": {}, \"SC-17\": {},\n\t\"SC-18\": {}, \"SC-19\": {}, \"SC-20\": {}, \"SC-21\": {}, \"SC-22\": {},\n\t\"SC-23\": {}, \"SC-24\": {}, \"SC-25\": {}, \"SD-DC\": {}, \"SD-DE\": {},\n\t\"SD-DN\": {}, \"SD-DS\": {}, \"SD-DW\": {}, \"SD-GD\": {}, \"SD-GK\": {}, \"SD-GZ\": {},\n\t\"SD-KA\": {}, \"SD-KH\": {}, \"SD-KN\": {}, \"SD-KS\": {}, \"SD-NB\": {},\n\t\"SD-NO\": {}, \"SD-NR\": {}, \"SD-NW\": {}, \"SD-RS\": {}, \"SD-SI\": {},\n\t\"SE-AB\": {}, \"SE-AC\": {}, \"SE-BD\": {}, \"SE-C\": {}, \"SE-D\": {},\n\t\"SE-E\": {}, \"SE-F\": {}, \"SE-G\": {}, \"SE-H\": {}, \"SE-I\": {},\n\t\"SE-K\": {}, \"SE-M\": {}, \"SE-N\": {}, \"SE-O\": {}, \"SE-S\": {},\n\t\"SE-T\": {}, \"SE-U\": {}, \"SE-W\": {}, \"SE-X\": {}, \"SE-Y\": {},\n\t\"SE-Z\": {}, \"SG-01\": {}, \"SG-02\": {}, \"SG-03\": {}, \"SG-04\": {},\n\t\"SG-05\": {}, \"SH-AC\": {}, \"SH-HL\": {}, \"SH-TA\": {}, \"SI-001\": {},\n\t\"SI-002\": {}, \"SI-003\": {}, \"SI-004\": {}, \"SI-005\": {}, \"SI-006\": {},\n\t\"SI-007\": {}, \"SI-008\": {}, \"SI-009\": {}, \"SI-010\": {}, \"SI-011\": {},\n\t\"SI-012\": {}, \"SI-013\": {}, \"SI-014\": {}, \"SI-015\": {}, \"SI-016\": {},\n\t\"SI-017\": {}, \"SI-018\": {}, \"SI-019\": {}, \"SI-020\": {}, \"SI-021\": {},\n\t\"SI-022\": {}, \"SI-023\": {}, \"SI-024\": {}, \"SI-025\": {}, \"SI-026\": {},\n\t\"SI-027\": {}, \"SI-028\": {}, \"SI-029\": {}, \"SI-030\": {}, \"SI-031\": {},\n\t\"SI-032\": {}, \"SI-033\": {}, \"SI-034\": {}, \"SI-035\": {}, \"SI-036\": {},\n\t\"SI-037\": {}, \"SI-038\": {}, \"SI-039\": {}, \"SI-040\": {}, \"SI-041\": {},\n\t\"SI-042\": {}, \"SI-043\": {}, \"SI-044\": {}, \"SI-045\": {}, \"SI-046\": {},\n\t\"SI-047\": {}, \"SI-048\": {}, \"SI-049\": {}, \"SI-050\": {}, \"SI-051\": {},\n\t\"SI-052\": {}, \"SI-053\": {}, \"SI-054\": {}, \"SI-055\": {}, \"SI-056\": {},\n\t\"SI-057\": {}, \"SI-058\": {}, \"SI-059\": {}, \"SI-060\": {}, \"SI-061\": {},\n\t\"SI-062\": {}, \"SI-063\": {}, \"SI-064\": {}, \"SI-065\": {}, \"SI-066\": {},\n\t\"SI-067\": {}, \"SI-068\": {}, \"SI-069\": {}, \"SI-070\": {}, \"SI-071\": {},\n\t\"SI-072\": {}, \"SI-073\": {}, \"SI-074\": {}, \"SI-075\": {}, \"SI-076\": {},\n\t\"SI-077\": {}, \"SI-078\": {}, \"SI-079\": {}, \"SI-080\": {}, \"SI-081\": {},\n\t\"SI-082\": {}, \"SI-083\": {}, \"SI-084\": {}, \"SI-085\": {}, \"SI-086\": {},\n\t\"SI-087\": {}, \"SI-088\": {}, \"SI-089\": {}, \"SI-090\": {}, \"SI-091\": {},\n\t\"SI-092\": {}, \"SI-093\": {}, \"SI-094\": {}, \"SI-095\": {}, \"SI-096\": {},\n\t\"SI-097\": {}, \"SI-098\": {}, \"SI-099\": {}, \"SI-100\": {}, \"SI-101\": {},\n\t\"SI-102\": {}, \"SI-103\": {}, \"SI-104\": {}, \"SI-105\": {}, \"SI-106\": {},\n\t\"SI-107\": {}, \"SI-108\": {}, \"SI-109\": {}, \"SI-110\": {}, \"SI-111\": {},\n\t\"SI-112\": {}, \"SI-113\": {}, \"SI-114\": {}, \"SI-115\": {}, \"SI-116\": {},\n\t\"SI-117\": {}, \"SI-118\": {}, \"SI-119\": {}, \"SI-120\": {}, \"SI-121\": {},\n\t\"SI-122\": {}, \"SI-123\": {}, \"SI-124\": {}, \"SI-125\": {}, \"SI-126\": {},\n\t\"SI-127\": {}, \"SI-128\": {}, \"SI-129\": {}, \"SI-130\": {}, \"SI-131\": {},\n\t\"SI-132\": {}, \"SI-133\": {}, \"SI-134\": {}, \"SI-135\": {}, \"SI-136\": {},\n\t\"SI-137\": {}, \"SI-138\": {}, \"SI-139\": {}, \"SI-140\": {}, \"SI-141\": {},\n\t\"SI-142\": {}, \"SI-143\": {}, \"SI-144\": {}, \"SI-146\": {}, \"SI-147\": {},\n\t\"SI-148\": {}, \"SI-149\": {}, \"SI-150\": {}, \"SI-151\": {}, \"SI-152\": {},\n\t\"SI-153\": {}, \"SI-154\": {}, \"SI-155\": {}, \"SI-156\": {}, \"SI-157\": {},\n\t\"SI-158\": {}, \"SI-159\": {}, \"SI-160\": {}, \"SI-161\": {}, \"SI-162\": {},\n\t\"SI-163\": {}, \"SI-164\": {}, \"SI-165\": {}, \"SI-166\": {}, \"SI-167\": {},\n\t\"SI-168\": {}, \"SI-169\": {}, \"SI-170\": {}, \"SI-171\": {}, \"SI-172\": {},\n\t\"SI-173\": {}, \"SI-174\": {}, \"SI-175\": {}, \"SI-176\": {}, \"SI-177\": {},\n\t\"SI-178\": {}, \"SI-179\": {}, \"SI-180\": {}, \"SI-181\": {}, \"SI-182\": {},\n\t\"SI-183\": {}, \"SI-184\": {}, \"SI-185\": {}, \"SI-186\": {}, \"SI-187\": {},\n\t\"SI-188\": {}, \"SI-189\": {}, \"SI-190\": {}, \"SI-191\": {}, \"SI-192\": {},\n\t\"SI-193\": {}, \"SI-194\": {}, \"SI-195\": {}, \"SI-196\": {}, \"SI-197\": {},\n\t\"SI-198\": {}, \"SI-199\": {}, \"SI-200\": {}, \"SI-201\": {}, \"SI-202\": {},\n\t\"SI-203\": {}, \"SI-204\": {}, \"SI-205\": {}, \"SI-206\": {}, \"SI-207\": {},\n\t\"SI-208\": {}, \"SI-209\": {}, \"SI-210\": {}, \"SI-211\": {}, \"SI-212\": {}, \"SI-213\": {}, \"SK-BC\": {},\n\t\"SK-BL\": {}, \"SK-KI\": {}, \"SK-NI\": {}, \"SK-PV\": {}, \"SK-TA\": {},\n\t\"SK-TC\": {}, \"SK-ZI\": {}, \"SL-E\": {}, \"SL-N\": {}, \"SL-S\": {},\n\t\"SL-W\": {}, \"SM-01\": {}, \"SM-02\": {}, \"SM-03\": {}, \"SM-04\": {},\n\t\"SM-05\": {}, \"SM-06\": {}, \"SM-07\": {}, \"SM-08\": {}, \"SM-09\": {},\n\t\"SN-DB\": {}, \"SN-DK\": {}, \"SN-FK\": {}, \"SN-KA\": {}, \"SN-KD\": {},\n\t\"SN-KE\": {}, \"SN-KL\": {}, \"SN-LG\": {}, \"SN-MT\": {}, \"SN-SE\": {},\n\t\"SN-SL\": {}, \"SN-TC\": {}, \"SN-TH\": {}, \"SN-ZG\": {}, \"SO-AW\": {},\n\t\"SO-BK\": {}, \"SO-BN\": {}, \"SO-BR\": {}, \"SO-BY\": {}, \"SO-GA\": {},\n\t\"SO-GE\": {}, \"SO-HI\": {}, \"SO-JD\": {}, \"SO-JH\": {}, \"SO-MU\": {},\n\t\"SO-NU\": {}, \"SO-SA\": {}, \"SO-SD\": {}, \"SO-SH\": {}, \"SO-SO\": {},\n\t\"SO-TO\": {}, \"SO-WO\": {}, \"SR-BR\": {}, \"SR-CM\": {}, \"SR-CR\": {},\n\t\"SR-MA\": {}, \"SR-NI\": {}, \"SR-PM\": {}, \"SR-PR\": {}, \"SR-SA\": {},\n\t\"SR-SI\": {}, \"SR-WA\": {}, \"SS-BN\": {}, \"SS-BW\": {}, \"SS-EC\": {},\n\t\"SS-EE8\": {}, \"SS-EE\": {}, \"SS-EW\": {}, \"SS-JG\": {}, \"SS-LK\": {}, \"SS-NU\": {},\n\t\"SS-UY\": {}, \"SS-WR\": {}, \"ST-01\": {}, \"ST-P\": {}, \"ST-S\": {}, \"SV-AH\": {},\n\t\"SV-CA\": {}, \"SV-CH\": {}, \"SV-CU\": {}, \"SV-LI\": {}, \"SV-MO\": {},\n\t\"SV-PA\": {}, \"SV-SA\": {}, \"SV-SM\": {}, \"SV-SO\": {}, \"SV-SS\": {},\n\t\"SV-SV\": {}, \"SV-UN\": {}, \"SV-US\": {}, \"SY-DI\": {}, \"SY-DR\": {},\n\t\"SY-DY\": {}, \"SY-HA\": {}, \"SY-HI\": {}, \"SY-HL\": {}, \"SY-HM\": {},\n\t\"SY-ID\": {}, \"SY-LA\": {}, \"SY-QU\": {}, \"SY-RA\": {}, \"SY-RD\": {},\n\t\"SY-SU\": {}, \"SY-TA\": {}, \"SZ-HH\": {}, \"SZ-LU\": {}, \"SZ-MA\": {},\n\t\"SZ-SH\": {}, \"TD-BA\": {}, \"TD-BG\": {}, \"TD-BO\": {}, \"TD-CB\": {},\n\t\"TD-EN\": {}, \"TD-GR\": {}, \"TD-HL\": {}, \"TD-KA\": {}, \"TD-LC\": {},\n\t\"TD-LO\": {}, \"TD-LR\": {}, \"TD-MA\": {}, \"TD-MC\": {}, \"TD-ME\": {},\n\t\"TD-MO\": {}, \"TD-ND\": {}, \"TD-OD\": {}, \"TD-SA\": {}, \"TD-SI\": {},\n\t\"TD-TA\": {}, \"TD-TI\": {}, \"TD-WF\": {}, \"TG-C\": {}, \"TG-K\": {},\n\t\"TG-M\": {}, \"TG-P\": {}, \"TG-S\": {}, \"TH-10\": {}, \"TH-11\": {},\n\t\"TH-12\": {}, \"TH-13\": {}, \"TH-14\": {}, \"TH-15\": {}, \"TH-16\": {},\n\t\"TH-17\": {}, \"TH-18\": {}, \"TH-19\": {}, \"TH-20\": {}, \"TH-21\": {},\n\t\"TH-22\": {}, \"TH-23\": {}, \"TH-24\": {}, \"TH-25\": {}, \"TH-26\": {},\n\t\"TH-27\": {}, \"TH-30\": {}, \"TH-31\": {}, \"TH-32\": {}, \"TH-33\": {},\n\t\"TH-34\": {}, \"TH-35\": {}, \"TH-36\": {}, \"TH-37\": {}, \"TH-38\": {}, \"TH-39\": {},\n\t\"TH-40\": {}, \"TH-41\": {}, \"TH-42\": {}, \"TH-43\": {}, \"TH-44\": {},\n\t\"TH-45\": {}, \"TH-46\": {}, \"TH-47\": {}, \"TH-48\": {}, \"TH-49\": {},\n\t\"TH-50\": {}, \"TH-51\": {}, \"TH-52\": {}, \"TH-53\": {}, \"TH-54\": {},\n\t\"TH-55\": {}, \"TH-56\": {}, \"TH-57\": {}, \"TH-58\": {}, \"TH-60\": {},\n\t\"TH-61\": {}, \"TH-62\": {}, \"TH-63\": {}, \"TH-64\": {}, \"TH-65\": {},\n\t\"TH-66\": {}, \"TH-67\": {}, \"TH-70\": {}, \"TH-71\": {}, \"TH-72\": {},\n\t\"TH-73\": {}, \"TH-74\": {}, \"TH-75\": {}, \"TH-76\": {}, \"TH-77\": {},\n\t\"TH-80\": {}, \"TH-81\": {}, \"TH-82\": {}, \"TH-83\": {}, \"TH-84\": {},\n\t\"TH-85\": {}, \"TH-86\": {}, \"TH-90\": {}, \"TH-91\": {}, \"TH-92\": {},\n\t\"TH-93\": {}, \"TH-94\": {}, \"TH-95\": {}, \"TH-96\": {}, \"TH-S\": {},\n\t\"TJ-GB\": {}, \"TJ-KT\": {}, \"TJ-SU\": {}, \"TJ-DU\": {}, \"TJ-RA\": {}, \"TL-AL\": {}, \"TL-AN\": {},\n\t\"TL-BA\": {}, \"TL-BO\": {}, \"TL-CO\": {}, \"TL-DI\": {}, \"TL-ER\": {},\n\t\"TL-LA\": {}, \"TL-LI\": {}, \"TL-MF\": {}, \"TL-MT\": {}, \"TL-OE\": {},\n\t\"TL-VI\": {}, \"TM-A\": {}, \"TM-B\": {}, \"TM-D\": {}, \"TM-L\": {},\n\t\"TM-M\": {}, \"TM-S\": {}, \"TN-11\": {}, \"TN-12\": {}, \"TN-13\": {},\n\t\"TN-14\": {}, \"TN-21\": {}, \"TN-22\": {}, \"TN-23\": {}, \"TN-31\": {},\n\t\"TN-32\": {}, \"TN-33\": {}, \"TN-34\": {}, \"TN-41\": {}, \"TN-42\": {},\n\t\"TN-43\": {}, \"TN-51\": {}, \"TN-52\": {}, \"TN-53\": {}, \"TN-61\": {},\n\t\"TN-71\": {}, \"TN-72\": {}, \"TN-73\": {}, \"TN-81\": {}, \"TN-82\": {},\n\t\"TN-83\": {}, \"TO-01\": {}, \"TO-02\": {}, \"TO-03\": {}, \"TO-04\": {},\n\t\"TO-05\": {}, \"TR-01\": {}, \"TR-02\": {}, \"TR-03\": {}, \"TR-04\": {},\n\t\"TR-05\": {}, \"TR-06\": {}, \"TR-07\": {}, \"TR-08\": {}, \"TR-09\": {},\n\t\"TR-10\": {}, \"TR-11\": {}, \"TR-12\": {}, \"TR-13\": {}, \"TR-14\": {},\n\t\"TR-15\": {}, \"TR-16\": {}, \"TR-17\": {}, \"TR-18\": {}, \"TR-19\": {},\n\t\"TR-20\": {}, \"TR-21\": {}, \"TR-22\": {}, \"TR-23\": {}, \"TR-24\": {},\n\t\"TR-25\": {}, \"TR-26\": {}, \"TR-27\": {}, \"TR-28\": {}, \"TR-29\": {},\n\t\"TR-30\": {}, \"TR-31\": {}, \"TR-32\": {}, \"TR-33\": {}, \"TR-34\": {},\n\t\"TR-35\": {}, \"TR-36\": {}, \"TR-37\": {}, \"TR-38\": {}, \"TR-39\": {},\n\t\"TR-40\": {}, \"TR-41\": {}, \"TR-42\": {}, \"TR-43\": {}, \"TR-44\": {},\n\t\"TR-45\": {}, \"TR-46\": {}, \"TR-47\": {}, \"TR-48\": {}, \"TR-49\": {},\n\t\"TR-50\": {}, \"TR-51\": {}, \"TR-52\": {}, \"TR-53\": {}, \"TR-54\": {},\n\t\"TR-55\": {}, \"TR-56\": {}, \"TR-57\": {}, \"TR-58\": {}, \"TR-59\": {},\n\t\"TR-60\": {}, \"TR-61\": {}, \"TR-62\": {}, \"TR-63\": {}, \"TR-64\": {},\n\t\"TR-65\": {}, \"TR-66\": {}, \"TR-67\": {}, \"TR-68\": {}, \"TR-69\": {},\n\t\"TR-70\": {}, \"TR-71\": {}, \"TR-72\": {}, \"TR-73\": {}, \"TR-74\": {},\n\t\"TR-75\": {}, \"TR-76\": {}, \"TR-77\": {}, \"TR-78\": {}, \"TR-79\": {},\n\t\"TR-80\": {}, \"TR-81\": {}, \"TT-ARI\": {}, \"TT-CHA\": {}, \"TT-CTT\": {},\n\t\"TT-DMN\": {}, \"TT-ETO\": {}, \"TT-MRC\": {}, \"TT-TOB\": {}, \"TT-PED\": {}, \"TT-POS\": {}, \"TT-PRT\": {},\n\t\"TT-PTF\": {}, \"TT-RCM\": {}, \"TT-SFO\": {}, \"TT-SGE\": {}, \"TT-SIP\": {},\n\t\"TT-SJL\": {}, \"TT-TUP\": {}, \"TT-WTO\": {}, \"TV-FUN\": {}, \"TV-NIT\": {},\n\t\"TV-NKF\": {}, \"TV-NKL\": {}, \"TV-NMA\": {}, \"TV-NMG\": {}, \"TV-NUI\": {},\n\t\"TV-VAI\": {}, \"TW-CHA\": {}, \"TW-CYI\": {}, \"TW-CYQ\": {}, \"TW-KIN\": {}, \"TW-HSQ\": {},\n\t\"TW-HSZ\": {}, \"TW-HUA\": {}, \"TW-LIE\": {}, \"TW-ILA\": {}, \"TW-KEE\": {}, \"TW-KHH\": {},\n\t\"TW-KHQ\": {}, \"TW-MIA\": {}, \"TW-NAN\": {}, \"TW-NWT\": {}, \"TW-PEN\": {}, \"TW-PIF\": {},\n\t\"TW-TAO\": {}, \"TW-TNN\": {}, \"TW-TNQ\": {}, \"TW-TPE\": {}, \"TW-TPQ\": {},\n\t\"TW-TTT\": {}, \"TW-TXG\": {}, \"TW-TXQ\": {}, \"TW-YUN\": {}, \"TZ-01\": {},\n\t\"TZ-02\": {}, \"TZ-03\": {}, \"TZ-04\": {}, \"TZ-05\": {}, \"TZ-06\": {},\n\t\"TZ-07\": {}, \"TZ-08\": {}, \"TZ-09\": {}, \"TZ-10\": {}, \"TZ-11\": {},\n\t\"TZ-12\": {}, \"TZ-13\": {}, \"TZ-14\": {}, \"TZ-15\": {}, \"TZ-16\": {},\n\t\"TZ-17\": {}, \"TZ-18\": {}, \"TZ-19\": {}, \"TZ-20\": {}, \"TZ-21\": {},\n\t\"TZ-22\": {}, \"TZ-23\": {}, \"TZ-24\": {}, \"TZ-25\": {}, \"TZ-26\": {}, \"TZ-27\": {}, \"TZ-28\": {}, \"TZ-29\": {}, \"TZ-30\": {}, \"TZ-31\": {},\n\t\"UA-05\": {}, \"UA-07\": {}, \"UA-09\": {}, \"UA-12\": {}, \"UA-14\": {},\n\t\"UA-18\": {}, \"UA-21\": {}, \"UA-23\": {}, \"UA-26\": {}, \"UA-30\": {},\n\t\"UA-32\": {}, \"UA-35\": {}, \"UA-40\": {}, \"UA-43\": {}, \"UA-46\": {},\n\t\"UA-48\": {}, \"UA-51\": {}, \"UA-53\": {}, \"UA-56\": {}, \"UA-59\": {},\n\t\"UA-61\": {}, \"UA-63\": {}, \"UA-65\": {}, \"UA-68\": {}, \"UA-71\": {},\n\t\"UA-74\": {}, \"UA-77\": {}, \"UG-101\": {}, \"UG-102\": {}, \"UG-103\": {},\n\t\"UG-104\": {}, \"UG-105\": {}, \"UG-106\": {}, \"UG-107\": {}, \"UG-108\": {},\n\t\"UG-109\": {}, \"UG-110\": {}, \"UG-111\": {}, \"UG-112\": {}, \"UG-113\": {},\n\t\"UG-114\": {}, \"UG-115\": {}, \"UG-116\": {}, \"UG-201\": {}, \"UG-202\": {},\n\t\"UG-203\": {}, \"UG-204\": {}, \"UG-205\": {}, \"UG-206\": {}, \"UG-207\": {},\n\t\"UG-208\": {}, \"UG-209\": {}, \"UG-210\": {}, \"UG-211\": {}, \"UG-212\": {},\n\t\"UG-213\": {}, \"UG-214\": {}, \"UG-215\": {}, \"UG-216\": {}, \"UG-217\": {},\n\t\"UG-218\": {}, \"UG-219\": {}, \"UG-220\": {}, \"UG-221\": {}, \"UG-222\": {},\n\t\"UG-223\": {}, \"UG-224\": {}, \"UG-301\": {}, \"UG-302\": {}, \"UG-303\": {},\n\t\"UG-304\": {}, \"UG-305\": {}, \"UG-306\": {}, \"UG-307\": {}, \"UG-308\": {},\n\t\"UG-309\": {}, \"UG-310\": {}, \"UG-311\": {}, \"UG-312\": {}, \"UG-313\": {},\n\t\"UG-314\": {}, \"UG-315\": {}, \"UG-316\": {}, \"UG-317\": {}, \"UG-318\": {},\n\t\"UG-319\": {}, \"UG-320\": {}, \"UG-321\": {}, \"UG-401\": {}, \"UG-402\": {},\n\t\"UG-403\": {}, \"UG-404\": {}, \"UG-405\": {}, \"UG-406\": {}, \"UG-407\": {},\n\t\"UG-408\": {}, \"UG-409\": {}, \"UG-410\": {}, \"UG-411\": {}, \"UG-412\": {},\n\t\"UG-413\": {}, \"UG-414\": {}, \"UG-415\": {}, \"UG-416\": {}, \"UG-417\": {},\n\t\"UG-418\": {}, \"UG-419\": {}, \"UG-C\": {}, \"UG-E\": {}, \"UG-N\": {},\n\t\"UG-W\": {}, \"UG-322\": {}, \"UG-323\": {}, \"UG-420\": {}, \"UG-117\": {},\n\t\"UG-118\": {}, \"UG-225\": {}, \"UG-120\": {}, \"UG-226\": {},\n\t\"UG-121\": {}, \"UG-122\": {}, \"UG-227\": {}, \"UG-421\": {},\n\t\"UG-325\": {}, \"UG-228\": {}, \"UG-123\": {}, \"UG-422\": {},\n\t\"UG-326\": {}, \"UG-229\": {}, \"UG-124\": {}, \"UG-423\": {},\n\t\"UG-230\": {}, \"UG-327\": {}, \"UG-424\": {}, \"UG-328\": {},\n\t\"UG-425\": {}, \"UG-426\": {}, \"UG-330\": {},\n\t\"UM-67\": {}, \"UM-71\": {}, \"UM-76\": {}, \"UM-79\": {},\n\t\"UM-81\": {}, \"UM-84\": {}, \"UM-86\": {}, \"UM-89\": {}, \"UM-95\": {},\n\t\"US-AK\": {}, \"US-AL\": {}, \"US-AR\": {}, \"US-AS\": {}, \"US-AZ\": {},\n\t\"US-CA\": {}, \"US-CO\": {}, \"US-CT\": {}, \"US-DC\": {}, \"US-DE\": {},\n\t\"US-FL\": {}, \"US-GA\": {}, \"US-GU\": {}, \"US-HI\": {}, \"US-IA\": {},\n\t\"US-ID\": {}, \"US-IL\": {}, \"US-IN\": {}, \"US-KS\": {}, \"US-KY\": {},\n\t\"US-LA\": {}, \"US-MA\": {}, \"US-MD\": {}, \"US-ME\": {}, \"US-MI\": {},\n\t\"US-MN\": {}, \"US-MO\": {}, \"US-MP\": {}, \"US-MS\": {}, \"US-MT\": {},\n\t\"US-NC\": {}, \"US-ND\": {}, \"US-NE\": {}, \"US-NH\": {}, \"US-NJ\": {},\n\t\"US-NM\": {}, \"US-NV\": {}, \"US-NY\": {}, \"US-OH\": {}, \"US-OK\": {},\n\t\"US-OR\": {}, \"US-PA\": {}, \"US-PR\": {}, \"US-RI\": {}, \"US-SC\": {},\n\t\"US-SD\": {}, \"US-TN\": {}, \"US-TX\": {}, \"US-UM\": {}, \"US-UT\": {},\n\t\"US-VA\": {}, \"US-VI\": {}, \"US-VT\": {}, \"US-WA\": {}, \"US-WI\": {},\n\t\"US-WV\": {}, \"US-WY\": {}, \"UY-AR\": {}, \"UY-CA\": {}, \"UY-CL\": {},\n\t\"UY-CO\": {}, \"UY-DU\": {}, \"UY-FD\": {}, \"UY-FS\": {}, \"UY-LA\": {},\n\t\"UY-MA\": {}, \"UY-MO\": {}, \"UY-PA\": {}, \"UY-RN\": {}, \"UY-RO\": {},\n\t\"UY-RV\": {}, \"UY-SA\": {}, \"UY-SJ\": {}, \"UY-SO\": {}, \"UY-TA\": {},\n\t\"UY-TT\": {}, \"UZ-AN\": {}, \"UZ-BU\": {}, \"UZ-FA\": {}, \"UZ-JI\": {},\n\t\"UZ-NG\": {}, \"UZ-NW\": {}, \"UZ-QA\": {}, \"UZ-QR\": {}, \"UZ-SA\": {},\n\t\"UZ-SI\": {}, \"UZ-SU\": {}, \"UZ-TK\": {}, \"UZ-TO\": {}, \"UZ-XO\": {},\n\t\"VC-01\": {}, \"VC-02\": {}, \"VC-03\": {}, \"VC-04\": {}, \"VC-05\": {},\n\t\"VC-06\": {}, \"VE-A\": {}, \"VE-B\": {}, \"VE-C\": {}, \"VE-D\": {},\n\t\"VE-E\": {}, \"VE-F\": {}, \"VE-G\": {}, \"VE-H\": {}, \"VE-I\": {},\n\t\"VE-J\": {}, \"VE-K\": {}, \"VE-L\": {}, \"VE-M\": {}, \"VE-N\": {},\n\t\"VE-O\": {}, \"VE-P\": {}, \"VE-R\": {}, \"VE-S\": {}, \"VE-T\": {},\n\t\"VE-U\": {}, \"VE-V\": {}, \"VE-W\": {}, \"VE-X\": {}, \"VE-Y\": {},\n\t\"VE-Z\": {}, \"VN-01\": {}, \"VN-02\": {}, \"VN-03\": {}, \"VN-04\": {},\n\t\"VN-05\": {}, \"VN-06\": {}, \"VN-07\": {}, \"VN-09\": {}, \"VN-13\": {},\n\t\"VN-14\": {}, \"VN-15\": {}, \"VN-18\": {}, \"VN-20\": {}, \"VN-21\": {},\n\t\"VN-22\": {}, \"VN-23\": {}, \"VN-24\": {}, \"VN-25\": {}, \"VN-26\": {},\n\t\"VN-27\": {}, \"VN-28\": {}, \"VN-29\": {}, \"VN-30\": {}, \"VN-31\": {},\n\t\"VN-32\": {}, \"VN-33\": {}, \"VN-34\": {}, \"VN-35\": {}, \"VN-36\": {},\n\t\"VN-37\": {}, \"VN-39\": {}, \"VN-40\": {}, \"VN-41\": {}, \"VN-43\": {},\n\t\"VN-44\": {}, \"VN-45\": {}, \"VN-46\": {}, \"VN-47\": {}, \"VN-49\": {},\n\t\"VN-50\": {}, \"VN-51\": {}, \"VN-52\": {}, \"VN-53\": {}, \"VN-54\": {},\n\t\"VN-55\": {}, \"VN-56\": {}, \"VN-57\": {}, \"VN-58\": {}, \"VN-59\": {},\n\t\"VN-61\": {}, \"VN-63\": {}, \"VN-66\": {}, \"VN-67\": {}, \"VN-68\": {},\n\t\"VN-69\": {}, \"VN-70\": {}, \"VN-71\": {}, \"VN-72\": {}, \"VN-73\": {},\n\t\"VN-CT\": {}, \"VN-DN\": {}, \"VN-HN\": {}, \"VN-HP\": {}, \"VN-SG\": {},\n\t\"VU-MAP\": {}, \"VU-PAM\": {}, \"VU-SAM\": {}, \"VU-SEE\": {}, \"VU-TAE\": {},\n\t\"VU-TOB\": {}, \"WF-SG\": {}, \"WF-UV\": {}, \"WS-AA\": {}, \"WS-AL\": {}, \"WS-AT\": {}, \"WS-FA\": {},\n\t\"WS-GE\": {}, \"WS-GI\": {}, \"WS-PA\": {}, \"WS-SA\": {}, \"WS-TU\": {},\n\t\"WS-VF\": {}, \"WS-VS\": {}, \"YE-AB\": {}, \"YE-AD\": {}, \"YE-AM\": {},\n\t\"YE-BA\": {}, \"YE-DA\": {}, \"YE-DH\": {}, \"YE-HD\": {}, \"YE-HJ\": {}, \"YE-HU\": {},\n\t\"YE-IB\": {}, \"YE-JA\": {}, \"YE-LA\": {}, \"YE-MA\": {}, \"YE-MR\": {},\n\t\"YE-MU\": {}, \"YE-MW\": {}, \"YE-RA\": {}, \"YE-SA\": {}, \"YE-SD\": {}, \"YE-SH\": {},\n\t\"YE-SN\": {}, \"YE-TA\": {}, \"ZA-EC\": {}, \"ZA-FS\": {}, \"ZA-GP\": {},\n\t\"ZA-LP\": {}, \"ZA-MP\": {}, \"ZA-NC\": {}, \"ZA-NW\": {}, \"ZA-WC\": {},\n\t\"ZA-ZN\": {}, \"ZA-KZN\": {}, \"ZM-01\": {}, \"ZM-02\": {}, \"ZM-03\": {}, \"ZM-04\": {},\n\t\"ZM-05\": {}, \"ZM-06\": {}, \"ZM-07\": {}, \"ZM-08\": {}, \"ZM-09\": {}, \"ZM-10\": {},\n\t\"ZW-BU\": {}, \"ZW-HA\": {}, \"ZW-MA\": {}, \"ZW-MC\": {}, \"ZW-ME\": {},\n\t\"ZW-MI\": {}, \"ZW-MN\": {}, \"ZW-MS\": {}, \"ZW-MV\": {}, \"ZW-MW\": {},\n}\n"
        },
        {
          "name": "currency_codes.go",
          "type": "blob",
          "size": 3.646484375,
          "content": "package validator\n\nvar iso4217 = map[string]struct{}{\n\t\"AFN\": {}, \"EUR\": {}, \"ALL\": {}, \"DZD\": {}, \"USD\": {},\n\t\"AOA\": {}, \"XCD\": {}, \"ARS\": {}, \"AMD\": {}, \"AWG\": {},\n\t\"AUD\": {}, \"AZN\": {}, \"BSD\": {}, \"BHD\": {}, \"BDT\": {},\n\t\"BBD\": {}, \"BYN\": {}, \"BZD\": {}, \"XOF\": {}, \"BMD\": {},\n\t\"INR\": {}, \"BTN\": {}, \"BOB\": {}, \"BOV\": {}, \"BAM\": {},\n\t\"BWP\": {}, \"NOK\": {}, \"BRL\": {}, \"BND\": {}, \"BGN\": {},\n\t\"BIF\": {}, \"CVE\": {}, \"KHR\": {}, \"XAF\": {}, \"CAD\": {},\n\t\"KYD\": {}, \"CLP\": {}, \"CLF\": {}, \"CNY\": {}, \"COP\": {},\n\t\"COU\": {}, \"KMF\": {}, \"CDF\": {}, \"NZD\": {}, \"CRC\": {},\n\t\"HRK\": {}, \"CUP\": {}, \"CUC\": {}, \"ANG\": {}, \"CZK\": {},\n\t\"DKK\": {}, \"DJF\": {}, \"DOP\": {}, \"EGP\": {}, \"SVC\": {},\n\t\"ERN\": {}, \"SZL\": {}, \"ETB\": {}, \"FKP\": {}, \"FJD\": {},\n\t\"XPF\": {}, \"GMD\": {}, \"GEL\": {}, \"GHS\": {}, \"GIP\": {},\n\t\"GTQ\": {}, \"GBP\": {}, \"GNF\": {}, \"GYD\": {}, \"HTG\": {},\n\t\"HNL\": {}, \"HKD\": {}, \"HUF\": {}, \"ISK\": {}, \"IDR\": {},\n\t\"XDR\": {}, \"IRR\": {}, \"IQD\": {}, \"ILS\": {}, \"JMD\": {},\n\t\"JPY\": {}, \"JOD\": {}, \"KZT\": {}, \"KES\": {}, \"KPW\": {},\n\t\"KRW\": {}, \"KWD\": {}, \"KGS\": {}, \"LAK\": {}, \"LBP\": {},\n\t\"LSL\": {}, \"ZAR\": {}, \"LRD\": {}, \"LYD\": {}, \"CHF\": {},\n\t\"MOP\": {}, \"MKD\": {}, \"MGA\": {}, \"MWK\": {}, \"MYR\": {},\n\t\"MVR\": {}, \"MRU\": {}, \"MUR\": {}, \"XUA\": {}, \"MXN\": {},\n\t\"MXV\": {}, \"MDL\": {}, \"MNT\": {}, \"MAD\": {}, \"MZN\": {},\n\t\"MMK\": {}, \"NAD\": {}, \"NPR\": {}, \"NIO\": {}, \"NGN\": {},\n\t\"OMR\": {}, \"PKR\": {}, \"PAB\": {}, \"PGK\": {}, \"PYG\": {},\n\t\"PEN\": {}, \"PHP\": {}, \"PLN\": {}, \"QAR\": {}, \"RON\": {},\n\t\"RUB\": {}, \"RWF\": {}, \"SHP\": {}, \"WST\": {}, \"STN\": {},\n\t\"SAR\": {}, \"RSD\": {}, \"SCR\": {}, \"SLL\": {}, \"SGD\": {},\n\t\"XSU\": {}, \"SBD\": {}, \"SOS\": {}, \"SSP\": {}, \"LKR\": {},\n\t\"SDG\": {}, \"SRD\": {}, \"SEK\": {}, \"CHE\": {}, \"CHW\": {},\n\t\"SYP\": {}, \"TWD\": {}, \"TJS\": {}, \"TZS\": {}, \"THB\": {},\n\t\"TOP\": {}, \"TTD\": {}, \"TND\": {}, \"TRY\": {}, \"TMT\": {},\n\t\"UGX\": {}, \"UAH\": {}, \"AED\": {}, \"USN\": {}, \"UYU\": {},\n\t\"UYI\": {}, \"UYW\": {}, \"UZS\": {}, \"VUV\": {}, \"VES\": {},\n\t\"VND\": {}, \"YER\": {}, \"ZMW\": {}, \"ZWL\": {}, \"XBA\": {},\n\t\"XBB\": {}, \"XBC\": {}, \"XBD\": {}, \"XTS\": {}, \"XXX\": {},\n\t\"XAU\": {}, \"XPD\": {}, \"XPT\": {}, \"XAG\": {},\n}\n\nvar iso4217_numeric = map[int]struct{}{\n\t8: {}, 12: {}, 32: {}, 36: {}, 44: {},\n\t48: {}, 50: {}, 51: {}, 52: {}, 60: {},\n\t64: {}, 68: {}, 72: {}, 84: {}, 90: {},\n\t96: {}, 104: {}, 108: {}, 116: {}, 124: {},\n\t132: {}, 136: {}, 144: {}, 152: {}, 156: {},\n\t170: {}, 174: {}, 188: {}, 191: {}, 192: {},\n\t203: {}, 208: {}, 214: {}, 222: {}, 230: {},\n\t232: {}, 238: {}, 242: {}, 262: {}, 270: {},\n\t292: {}, 320: {}, 324: {}, 328: {}, 332: {},\n\t340: {}, 344: {}, 348: {}, 352: {}, 356: {},\n\t360: {}, 364: {}, 368: {}, 376: {}, 388: {},\n\t392: {}, 398: {}, 400: {}, 404: {}, 408: {},\n\t410: {}, 414: {}, 417: {}, 418: {}, 422: {},\n\t426: {}, 430: {}, 434: {}, 446: {}, 454: {},\n\t458: {}, 462: {}, 480: {}, 484: {}, 496: {},\n\t498: {}, 504: {}, 512: {}, 516: {}, 524: {},\n\t532: {}, 533: {}, 548: {}, 554: {}, 558: {},\n\t566: {}, 578: {}, 586: {}, 590: {}, 598: {},\n\t600: {}, 604: {}, 608: {}, 634: {}, 643: {},\n\t646: {}, 654: {}, 682: {}, 690: {}, 694: {},\n\t702: {}, 704: {}, 706: {}, 710: {}, 728: {},\n\t748: {}, 752: {}, 756: {}, 760: {}, 764: {},\n\t776: {}, 780: {}, 784: {}, 788: {}, 800: {},\n\t807: {}, 818: {}, 826: {}, 834: {}, 840: {},\n\t858: {}, 860: {}, 882: {}, 886: {}, 901: {},\n\t927: {}, 928: {}, 929: {}, 930: {}, 931: {},\n\t932: {}, 933: {}, 934: {}, 936: {}, 938: {},\n\t940: {}, 941: {}, 943: {}, 944: {}, 946: {},\n\t947: {}, 948: {}, 949: {}, 950: {}, 951: {},\n\t952: {}, 953: {}, 955: {}, 956: {}, 957: {},\n\t958: {}, 959: {}, 960: {}, 961: {}, 962: {},\n\t963: {}, 964: {}, 965: {}, 967: {}, 968: {},\n\t969: {}, 970: {}, 971: {}, 972: {}, 973: {},\n\t975: {}, 976: {}, 977: {}, 978: {}, 979: {},\n\t980: {}, 981: {}, 984: {}, 985: {}, 986: {},\n\t990: {}, 994: {}, 997: {}, 999: {},\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 38.8857421875,
          "content": "/*\nPackage validator implements value validations for structs and individual fields\nbased on tags.\n\nIt can also handle Cross-Field and Cross-Struct validation for nested structs\nand has the ability to dive into arrays and maps of any type.\n\nsee more examples https://github.com/go-playground/validator/tree/master/_examples\n\n# Singleton\n\nValidator is designed to be thread-safe and used as a singleton instance.\nIt caches information about your struct and validations,\nin essence only parsing your validation tags once per struct type.\nUsing multiple instances neglects the benefit of caching.\nThe not thread-safe functions are explicitly marked as such in the documentation.\n\n# Validation Functions Return Type error\n\nDoing things this way is actually the way the standard library does, see the\nfile.Open method here:\n\n\thttps://golang.org/pkg/os/#Open.\n\nThe authors return type \"error\" to avoid the issue discussed in the following,\nwhere err is always != nil:\n\n\thttp://stackoverflow.com/a/29138676/3158232\n\thttps://github.com/go-playground/validator/issues/134\n\nValidator only InvalidValidationError for bad validation input, nil or\nValidationErrors as type error; so, in your code all you need to do is check\nif the error returned is not nil, and if it's not check if error is\nInvalidValidationError ( if necessary, most of the time it isn't ) type cast\nit to type ValidationErrors like so err.(validator.ValidationErrors).\n\n# Custom Validation Functions\n\nCustom Validation functions can be added. Example:\n\n\t// Structure\n\tfunc customFunc(fl validator.FieldLevel) bool {\n\n\t\tif fl.Field().String() == \"invalid\" {\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tvalidate.RegisterValidation(\"custom tag name\", customFunc)\n\t// NOTES: using the same tag name as an existing function\n\t//        will overwrite the existing one\n\n# Cross-Field Validation\n\nCross-Field Validation can be done via the following tags:\n  - eqfield\n  - nefield\n  - gtfield\n  - gtefield\n  - ltfield\n  - ltefield\n  - eqcsfield\n  - necsfield\n  - gtcsfield\n  - gtecsfield\n  - ltcsfield\n  - ltecsfield\n\nIf, however, some custom cross-field validation is required, it can be done\nusing a custom validation.\n\nWhy not just have cross-fields validation tags (i.e. only eqcsfield and not\neqfield)?\n\nThe reason is efficiency. If you want to check a field within the same struct\n\"eqfield\" only has to find the field on the same struct (1 level). But, if we\nused \"eqcsfield\" it could be multiple levels down. Example:\n\n\ttype Inner struct {\n\t\tStartDate time.Time\n\t}\n\n\ttype Outer struct {\n\t\tInnerStructField *Inner\n\t\tCreatedAt time.Time      `validate:\"ltecsfield=InnerStructField.StartDate\"`\n\t}\n\n\tnow := time.Now()\n\n\tinner := &Inner{\n\t\tStartDate: now,\n\t}\n\n\touter := &Outer{\n\t\tInnerStructField: inner,\n\t\tCreatedAt: now,\n\t}\n\n\terrs := validate.Struct(outer)\n\n\t// NOTE: when calling validate.Struct(val) topStruct will be the top level struct passed\n\t//       into the function\n\t//       when calling validate.VarWithValue(val, field, tag) val will be\n\t//       whatever you pass, struct, field...\n\t//       when calling validate.Field(field, tag) val will be nil\n\n# Multiple Validators\n\nMultiple validators on a field will process in the order defined. Example:\n\n\ttype Test struct {\n\t\tField `validate:\"max=10,min=1\"`\n\t}\n\n\t// max will be checked then min\n\nBad Validator definitions are not handled by the library. Example:\n\n\ttype Test struct {\n\t\tField `validate:\"min=10,max=0\"`\n\t}\n\n\t// this definition of min max will never succeed\n\n# Using Validator Tags\n\nBaked In Cross-Field validation only compares fields on the same struct.\nIf Cross-Field + Cross-Struct validation is needed you should implement your\nown custom validator.\n\nComma (\",\") is the default separator of validation tags. If you wish to\nhave a comma included within the parameter (i.e. excludesall=,) you will need to\nuse the UTF-8 hex representation 0x2C, which is replaced in the code as a comma,\nso the above will become excludesall=0x2C.\n\n\ttype Test struct {\n\t\tField `validate:\"excludesall=,\"`    // BAD! Do not include a comma.\n\t\tField `validate:\"excludesall=0x2C\"` // GOOD! Use the UTF-8 hex representation.\n\t}\n\nPipe (\"|\") is the 'or' validation tags deparator. If you wish to\nhave a pipe included within the parameter i.e. excludesall=| you will need to\nuse the UTF-8 hex representation 0x7C, which is replaced in the code as a pipe,\nso the above will become excludesall=0x7C\n\n\ttype Test struct {\n\t\tField `validate:\"excludesall=|\"`    // BAD! Do not include a pipe!\n\t\tField `validate:\"excludesall=0x7C\"` // GOOD! Use the UTF-8 hex representation.\n\t}\n\n# Baked In Validators and Tags\n\nHere is a list of the current built in validators:\n\n# Skip Field\n\nTells the validation to skip this struct field; this is particularly\nhandy in ignoring embedded structs from being validated. (Usage: -)\n\n\tUsage: -\n\n# Or Operator\n\nThis is the 'or' operator allowing multiple validators to be used and\naccepted. (Usage: rgb|rgba) <-- this would allow either rgb or rgba\ncolors to be accepted. This can also be combined with 'and' for example\n( Usage: omitempty,rgb|rgba)\n\n\tUsage: |\n\n# StructOnly\n\nWhen a field that is a nested struct is encountered, and contains this flag\nany validation on the nested struct will be run, but none of the nested\nstruct fields will be validated. This is useful if inside of your program\nyou know the struct will be valid, but need to verify it has been assigned.\nNOTE: only \"required\" and \"omitempty\" can be used on a struct itself.\n\n\tUsage: structonly\n\n# NoStructLevel\n\nSame as structonly tag except that any struct level validations will not run.\n\n\tUsage: nostructlevel\n\n# Omit Empty\n\nAllows conditional validation, for example if a field is not set with\na value (Determined by the \"required\" validator) then other validation\nsuch as min or max won't run, but if a value is set validation will run.\n\n\tUsage: omitempty\n\n# Omit Nil\n\nAllows to skip the validation if the value is nil (same as omitempty, but\nonly for the nil-values).\n\n\tUsage: omitnil\n\n# Dive\n\nThis tells the validator to dive into a slice, array or map and validate that\nlevel of the slice, array or map with the validation tags that follow.\nMultidimensional nesting is also supported, each level you wish to dive will\nrequire another dive tag. dive has some sub-tags, 'keys' & 'endkeys', please see\nthe Keys & EndKeys section just below.\n\n\tUsage: dive\n\nExample #1\n\n\t[][]string with validation tag \"gt=0,dive,len=1,dive,required\"\n\t// gt=0 will be applied to []\n\t// len=1 will be applied to []string\n\t// required will be applied to string\n\nExample #2\n\n\t[][]string with validation tag \"gt=0,dive,dive,required\"\n\t// gt=0 will be applied to []\n\t// []string will be spared validation\n\t// required will be applied to string\n\nKeys & EndKeys\n\nThese are to be used together directly after the dive tag and tells the validator\nthat anything between 'keys' and 'endkeys' applies to the keys of a map and not the\nvalues; think of it like the 'dive' tag, but for map keys instead of values.\nMultidimensional nesting is also supported, each level you wish to validate will\nrequire another 'keys' and 'endkeys' tag. These tags are only valid for maps.\n\n\tUsage: dive,keys,othertagvalidation(s),endkeys,valuevalidationtags\n\nExample #1\n\n\tmap[string]string with validation tag \"gt=0,dive,keys,eq=1|eq=2,endkeys,required\"\n\t// gt=0 will be applied to the map itself\n\t// eq=1|eq=2 will be applied to the map keys\n\t// required will be applied to map values\n\nExample #2\n\n\tmap[[2]string]string with validation tag \"gt=0,dive,keys,dive,eq=1|eq=2,endkeys,required\"\n\t// gt=0 will be applied to the map itself\n\t// eq=1|eq=2 will be applied to each array element in the map keys\n\t// required will be applied to map values\n\n# Required\n\nThis validates that the value is not the data types default zero value.\nFor numbers ensures value is not zero. For strings ensures value is\nnot \"\". For booleans ensures value is not false. For slices, maps, pointers, interfaces, channels and functions\nensures the value is not nil. For structs ensures value is not the zero value when using WithRequiredStructEnabled.\n\n\tUsage: required\n\n# Required If\n\nThe field under validation must be present and not empty only if all\nthe other specified fields are equal to the value following the specified\nfield. For strings ensures value is not \"\". For slices, maps, pointers,\ninterfaces, channels and functions ensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: required_if\n\nExamples:\n\n\t// require the field if the Field1 is equal to the parameter given:\n\tUsage: required_if=Field1 foobar\n\n\t// require the field if the Field1 and Field2 is equal to the value respectively:\n\tUsage: required_if=Field1 foo Field2 bar\n\n# Required Unless\n\nThe field under validation must be present and not empty unless all\nthe other specified fields are equal to the value following the specified\nfield. For strings ensures value is not \"\". For slices, maps, pointers,\ninterfaces, channels and functions ensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: required_unless\n\nExamples:\n\n\t// require the field unless the Field1 is equal to the parameter given:\n\tUsage: required_unless=Field1 foobar\n\n\t// require the field unless the Field1 and Field2 is equal to the value respectively:\n\tUsage: required_unless=Field1 foo Field2 bar\n\n# Required With\n\nThe field under validation must be present and not empty only if any\nof the other specified fields are present. For strings ensures value is\nnot \"\". For slices, maps, pointers, interfaces, channels and functions\nensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: required_with\n\nExamples:\n\n\t// require the field if the Field1 is present:\n\tUsage: required_with=Field1\n\n\t// require the field if the Field1 or Field2 is present:\n\tUsage: required_with=Field1 Field2\n\n# Required With All\n\nThe field under validation must be present and not empty only if all\nof the other specified fields are present. For strings ensures value is\nnot \"\". For slices, maps, pointers, interfaces, channels and functions\nensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: required_with_all\n\nExample:\n\n\t// require the field if the Field1 and Field2 is present:\n\tUsage: required_with_all=Field1 Field2\n\n# Required Without\n\nThe field under validation must be present and not empty only when any\nof the other specified fields are not present. For strings ensures value is\nnot \"\". For slices, maps, pointers, interfaces, channels and functions\nensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: required_without\n\nExamples:\n\n\t// require the field if the Field1 is not present:\n\tUsage: required_without=Field1\n\n\t// require the field if the Field1 or Field2 is not present:\n\tUsage: required_without=Field1 Field2\n\n# Required Without All\n\nThe field under validation must be present and not empty only when all\nof the other specified fields are not present. For strings ensures value is\nnot \"\". For slices, maps, pointers, interfaces, channels and functions\nensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: required_without_all\n\nExample:\n\n\t// require the field if the Field1 and Field2 is not present:\n\tUsage: required_without_all=Field1 Field2\n\n# Excluded If\n\nThe field under validation must not be present or not empty only if all\nthe other specified fields are equal to the value following the specified\nfield. For strings ensures value is not \"\". For slices, maps, pointers,\ninterfaces, channels and functions ensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: excluded_if\n\nExamples:\n\n\t// exclude the field if the Field1 is equal to the parameter given:\n\tUsage: excluded_if=Field1 foobar\n\n\t// exclude the field if the Field1 and Field2 is equal to the value respectively:\n\tUsage: excluded_if=Field1 foo Field2 bar\n\n# Excluded Unless\n\nThe field under validation must not be present or empty unless all\nthe other specified fields are equal to the value following the specified\nfield. For strings ensures value is not \"\". For slices, maps, pointers,\ninterfaces, channels and functions ensures the value is not nil. For structs ensures value is not the zero value.\n\n\tUsage: excluded_unless\n\nExamples:\n\n\t// exclude the field unless the Field1 is equal to the parameter given:\n\tUsage: excluded_unless=Field1 foobar\n\n\t// exclude the field unless the Field1 and Field2 is equal to the value respectively:\n\tUsage: excluded_unless=Field1 foo Field2 bar\n\n# Is Default\n\nThis validates that the value is the default value and is almost the\nopposite of required.\n\n\tUsage: isdefault\n\n# Length\n\nFor numbers, length will ensure that the value is\nequal to the parameter given. For strings, it checks that\nthe string length is exactly that number of characters. For slices,\narrays, and maps, validates the number of items.\n\nExample #1\n\n\tUsage: len=10\n\nExample #2 (time.Duration)\n\nFor time.Duration, len will ensure that the value is equal to the duration given\nin the parameter.\n\n\tUsage: len=1h30m\n\n# Maximum\n\nFor numbers, max will ensure that the value is\nless than or equal to the parameter given. For strings, it checks\nthat the string length is at most that number of characters. For\nslices, arrays, and maps, validates the number of items.\n\nExample #1\n\n\tUsage: max=10\n\nExample #2 (time.Duration)\n\nFor time.Duration, max will ensure that the value is less than or equal to the\nduration given in the parameter.\n\n\tUsage: max=1h30m\n\n# Minimum\n\nFor numbers, min will ensure that the value is\ngreater or equal to the parameter given. For strings, it checks that\nthe string length is at least that number of characters. For slices,\narrays, and maps, validates the number of items.\n\nExample #1\n\n\tUsage: min=10\n\nExample #2 (time.Duration)\n\nFor time.Duration, min will ensure that the value is greater than or equal to\nthe duration given in the parameter.\n\n\tUsage: min=1h30m\n\n# Equals\n\nFor strings & numbers, eq will ensure that the value is\nequal to the parameter given. For slices, arrays, and maps,\nvalidates the number of items.\n\nExample #1\n\n\tUsage: eq=10\n\nExample #2 (time.Duration)\n\nFor time.Duration, eq will ensure that the value is equal to the duration given\nin the parameter.\n\n\tUsage: eq=1h30m\n\n# Not Equal\n\nFor strings & numbers, ne will ensure that the value is not\nequal to the parameter given. For slices, arrays, and maps,\nvalidates the number of items.\n\nExample #1\n\n\tUsage: ne=10\n\nExample #2 (time.Duration)\n\nFor time.Duration, ne will ensure that the value is not equal to the duration\ngiven in the parameter.\n\n\tUsage: ne=1h30m\n\n# One Of\n\nFor strings, ints, and uints, oneof will ensure that the value\nis one of the values in the parameter.  The parameter should be\na list of values separated by whitespace. Values may be\nstrings or numbers. To match strings with spaces in them, include\nthe target string between single quotes. Kind of like an 'enum'.\n\n\tUsage: oneof=red green\n\t       oneof='red green' 'blue yellow'\n\t       oneof=5 7 9\n\n# One Of Case Insensitive\n\nWorks the same as oneof but is case insensitive and therefore only accepts strings.\n\n\tUsage: oneofci=red green\n\t       oneofci='red green' 'blue yellow'\n\n# Greater Than\n\nFor numbers, this will ensure that the value is greater than the\nparameter given. For strings, it checks that the string length\nis greater than that number of characters. For slices, arrays\nand maps it validates the number of items.\n\nExample #1\n\n\tUsage: gt=10\n\nExample #2 (time.Time)\n\nFor time.Time ensures the time value is greater than time.Now.UTC().\n\n\tUsage: gt\n\nExample #3 (time.Duration)\n\nFor time.Duration, gt will ensure that the value is greater than the duration\ngiven in the parameter.\n\n\tUsage: gt=1h30m\n\n# Greater Than or Equal\n\nSame as 'min' above. Kept both to make terminology with 'len' easier.\n\nExample #1\n\n\tUsage: gte=10\n\nExample #2 (time.Time)\n\nFor time.Time ensures the time value is greater than or equal to time.Now.UTC().\n\n\tUsage: gte\n\nExample #3 (time.Duration)\n\nFor time.Duration, gte will ensure that the value is greater than or equal to\nthe duration given in the parameter.\n\n\tUsage: gte=1h30m\n\n# Less Than\n\nFor numbers, this will ensure that the value is less than the parameter given.\nFor strings, it checks that the string length is less than that number of\ncharacters. For slices, arrays, and maps it validates the number of items.\n\nExample #1\n\n\tUsage: lt=10\n\nExample #2 (time.Time)\n\nFor time.Time ensures the time value is less than time.Now.UTC().\n\n\tUsage: lt\n\nExample #3 (time.Duration)\n\nFor time.Duration, lt will ensure that the value is less than the duration given\nin the parameter.\n\n\tUsage: lt=1h30m\n\n# Less Than or Equal\n\nSame as 'max' above. Kept both to make terminology with 'len' easier.\n\nExample #1\n\n\tUsage: lte=10\n\nExample #2 (time.Time)\n\nFor time.Time ensures the time value is less than or equal to time.Now.UTC().\n\n\tUsage: lte\n\nExample #3 (time.Duration)\n\nFor time.Duration, lte will ensure that the value is less than or equal to the\nduration given in the parameter.\n\n\tUsage: lte=1h30m\n\n# Field Equals Another Field\n\nThis will validate the field value against another fields value either within\na struct or passed in field.\n\nExample #1:\n\n\t// Validation on Password field using:\n\tUsage: eqfield=ConfirmPassword\n\nExample #2:\n\n\t// Validating by field:\n\tvalidate.VarWithValue(password, confirmpassword, \"eqfield\")\n\nField Equals Another Field (relative)\n\nThis does the same as eqfield except that it validates the field provided relative\nto the top level struct.\n\n\tUsage: eqcsfield=InnerStructField.Field)\n\n# Field Does Not Equal Another Field\n\nThis will validate the field value against another fields value either within\na struct or passed in field.\n\nExamples:\n\n\t// Confirm two colors are not the same:\n\t//\n\t// Validation on Color field:\n\tUsage: nefield=Color2\n\n\t// Validating by field:\n\tvalidate.VarWithValue(color1, color2, \"nefield\")\n\nField Does Not Equal Another Field (relative)\n\nThis does the same as nefield except that it validates the field provided\nrelative to the top level struct.\n\n\tUsage: necsfield=InnerStructField.Field\n\n# Field Greater Than Another Field\n\nOnly valid for Numbers, time.Duration and time.Time types, this will validate\nthe field value against another fields value either within a struct or passed in\nfield. usage examples are for validation of a Start and End date:\n\nExample #1:\n\n\t// Validation on End field using:\n\tvalidate.Struct Usage(gtfield=Start)\n\nExample #2:\n\n\t// Validating by field:\n\tvalidate.VarWithValue(start, end, \"gtfield\")\n\n# Field Greater Than Another Relative Field\n\nThis does the same as gtfield except that it validates the field provided\nrelative to the top level struct.\n\n\tUsage: gtcsfield=InnerStructField.Field\n\n# Field Greater Than or Equal To Another Field\n\nOnly valid for Numbers, time.Duration and time.Time types, this will validate\nthe field value against another fields value either within a struct or passed in\nfield. usage examples are for validation of a Start and End date:\n\nExample #1:\n\n\t// Validation on End field using:\n\tvalidate.Struct Usage(gtefield=Start)\n\nExample #2:\n\n\t// Validating by field:\n\tvalidate.VarWithValue(start, end, \"gtefield\")\n\n# Field Greater Than or Equal To Another Relative Field\n\nThis does the same as gtefield except that it validates the field provided relative\nto the top level struct.\n\n\tUsage: gtecsfield=InnerStructField.Field\n\n# Less Than Another Field\n\nOnly valid for Numbers, time.Duration and time.Time types, this will validate\nthe field value against another fields value either within a struct or passed in\nfield. usage examples are for validation of a Start and End date:\n\nExample #1:\n\n\t// Validation on End field using:\n\tvalidate.Struct Usage(ltfield=Start)\n\nExample #2:\n\n\t// Validating by field:\n\tvalidate.VarWithValue(start, end, \"ltfield\")\n\n# Less Than Another Relative Field\n\nThis does the same as ltfield except that it validates the field provided relative\nto the top level struct.\n\n\tUsage: ltcsfield=InnerStructField.Field\n\n# Less Than or Equal To Another Field\n\nOnly valid for Numbers, time.Duration and time.Time types, this will validate\nthe field value against another fields value either within a struct or passed in\nfield. usage examples are for validation of a Start and End date:\n\nExample #1:\n\n\t// Validation on End field using:\n\tvalidate.Struct Usage(ltefield=Start)\n\nExample #2:\n\n\t// Validating by field:\n\tvalidate.VarWithValue(start, end, \"ltefield\")\n\n# Less Than or Equal To Another Relative Field\n\nThis does the same as ltefield except that it validates the field provided relative\nto the top level struct.\n\n\tUsage: ltecsfield=InnerStructField.Field\n\n# Field Contains Another Field\n\nThis does the same as contains except for struct fields. It should only be used\nwith string types. See the behavior of reflect.Value.String() for behavior on\nother types.\n\n\tUsage: containsfield=InnerStructField.Field\n\n# Field Excludes Another Field\n\nThis does the same as excludes except for struct fields. It should only be used\nwith string types. See the behavior of reflect.Value.String() for behavior on\nother types.\n\n\tUsage: excludesfield=InnerStructField.Field\n\n# Unique\n\nFor arrays & slices, unique will ensure that there are no duplicates.\nFor maps, unique will ensure that there are no duplicate values.\nFor slices of struct, unique will ensure that there are no duplicate values\nin a field of the struct specified via a parameter.\n\n\t// For arrays, slices, and maps:\n\tUsage: unique\n\n\t// For slices of struct:\n\tUsage: unique=field\n\n# Alpha Only\n\nThis validates that a string value contains ASCII alpha characters only\n\n\tUsage: alpha\n\n# Alphanumeric\n\nThis validates that a string value contains ASCII alphanumeric characters only\n\n\tUsage: alphanum\n\n# Alpha Unicode\n\nThis validates that a string value contains unicode alpha characters only\n\n\tUsage: alphaunicode\n\n# Alphanumeric Unicode\n\nThis validates that a string value contains unicode alphanumeric characters only\n\n\tUsage: alphanumunicode\n\n# Boolean\n\nThis validates that a string value can successfully be parsed into a boolean with strconv.ParseBool\n\n\tUsage: boolean\n\n# Number\n\nThis validates that a string value contains number values only.\nFor integers or float it returns true.\n\n\tUsage: number\n\n# Numeric\n\nThis validates that a string value contains a basic numeric value.\nbasic excludes exponents etc...\nfor integers or float it returns true.\n\n\tUsage: numeric\n\n# Hexadecimal String\n\nThis validates that a string value contains a valid hexadecimal.\n\n\tUsage: hexadecimal\n\n# Hexcolor String\n\nThis validates that a string value contains a valid hex color including\nhashtag (#)\n\n\tUsage: hexcolor\n\n# Lowercase String\n\nThis validates that a string value contains only lowercase characters. An empty string is not a valid lowercase string.\n\n\tUsage: lowercase\n\n# Uppercase String\n\nThis validates that a string value contains only uppercase characters. An empty string is not a valid uppercase string.\n\n\tUsage: uppercase\n\n# RGB String\n\nThis validates that a string value contains a valid rgb color\n\n\tUsage: rgb\n\n# RGBA String\n\nThis validates that a string value contains a valid rgba color\n\n\tUsage: rgba\n\n# HSL String\n\nThis validates that a string value contains a valid hsl color\n\n\tUsage: hsl\n\n# HSLA String\n\nThis validates that a string value contains a valid hsla color\n\n\tUsage: hsla\n\n# E.164 Phone Number String\n\nThis validates that a string value contains a valid E.164 Phone number\nhttps://en.wikipedia.org/wiki/E.164 (ex. +1123456789)\n\n\tUsage: e164\n\n# E-mail String\n\nThis validates that a string value contains a valid email\nThis may not conform to all possibilities of any rfc standard, but neither\ndoes any email provider accept all possibilities.\n\n\tUsage: email\n\n# JSON String\n\nThis validates that a string value is valid JSON\n\n\tUsage: json\n\n# JWT String\n\nThis validates that a string value is a valid JWT\n\n\tUsage: jwt\n\n# File\n\nThis validates that a string value contains a valid file path and that\nthe file exists on the machine.\nThis is done using os.Stat, which is a platform independent function.\n\n\tUsage: file\n\n# Image path\n\nThis validates that a string value contains a valid file path and that\nthe file exists on the machine and is an image.\nThis is done using os.Stat and github.com/gabriel-vasile/mimetype\n\n\tUsage: image\n\n# File Path\n\nThis validates that a string value contains a valid file path but does not\nvalidate the existence of that file.\nThis is done using os.Stat, which is a platform independent function.\n\n\tUsage: filepath\n\n# URL String\n\nThis validates that a string value contains a valid url\nThis will accept any url the golang request uri accepts but must contain\na schema for example http:// or rtmp://\n\n\tUsage: url\n\n# URI String\n\nThis validates that a string value contains a valid uri\nThis will accept any uri the golang request uri accepts\n\n\tUsage: uri\n\n# Urn RFC 2141 String\n\nThis validates that a string value contains a valid URN\naccording to the RFC 2141 spec.\n\n\tUsage: urn_rfc2141\n\n# Base32 String\n\nThis validates that a string value contains a valid bas324 value.\nAlthough an empty string is valid base32 this will report an empty string\nas an error, if you wish to accept an empty string as valid you can use\nthis with the omitempty tag.\n\n\tUsage: base32\n\n# Base64 String\n\nThis validates that a string value contains a valid base64 value.\nAlthough an empty string is valid base64 this will report an empty string\nas an error, if you wish to accept an empty string as valid you can use\nthis with the omitempty tag.\n\n\tUsage: base64\n\n# Base64URL String\n\nThis validates that a string value contains a valid base64 URL safe value\naccording the RFC4648 spec.\nAlthough an empty string is a valid base64 URL safe value, this will report\nan empty string as an error, if you wish to accept an empty string as valid\nyou can use this with the omitempty tag.\n\n\tUsage: base64url\n\n# Base64RawURL String\n\nThis validates that a string value contains a valid base64 URL safe value,\nbut without = padding, according the RFC4648 spec, section 3.2.\nAlthough an empty string is a valid base64 URL safe value, this will report\nan empty string as an error, if you wish to accept an empty string as valid\nyou can use this with the omitempty tag.\n\n\tUsage: base64url\n\n# Bitcoin Address\n\nThis validates that a string value contains a valid bitcoin address.\nThe format of the string is checked to ensure it matches one of the three formats\nP2PKH, P2SH and performs checksum validation.\n\n\tUsage: btc_addr\n\nBitcoin Bech32 Address (segwit)\n\nThis validates that a string value contains a valid bitcoin Bech32 address as defined\nby bip-0173 (https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)\nSpecial thanks to Pieter Wuille for providing reference implementations.\n\n\tUsage: btc_addr_bech32\n\n# Ethereum Address\n\nThis validates that a string value contains a valid ethereum address.\nThe format of the string is checked to ensure it matches the standard Ethereum address format.\n\n\tUsage: eth_addr\n\n# Contains\n\nThis validates that a string value contains the substring value.\n\n\tUsage: contains=@\n\n# Contains Any\n\nThis validates that a string value contains any Unicode code points\nin the substring value.\n\n\tUsage: containsany=!@#?\n\n# Contains Rune\n\nThis validates that a string value contains the supplied rune value.\n\n\tUsage: containsrune=@\n\n# Excludes\n\nThis validates that a string value does not contain the substring value.\n\n\tUsage: excludes=@\n\n# Excludes All\n\nThis validates that a string value does not contain any Unicode code\npoints in the substring value.\n\n\tUsage: excludesall=!@#?\n\n# Excludes Rune\n\nThis validates that a string value does not contain the supplied rune value.\n\n\tUsage: excludesrune=@\n\n# Starts With\n\nThis validates that a string value starts with the supplied string value\n\n\tUsage: startswith=hello\n\n# Ends With\n\nThis validates that a string value ends with the supplied string value\n\n\tUsage: endswith=goodbye\n\n# Does Not Start With\n\nThis validates that a string value does not start with the supplied string value\n\n\tUsage: startsnotwith=hello\n\n# Does Not End With\n\nThis validates that a string value does not end with the supplied string value\n\n\tUsage: endsnotwith=goodbye\n\n# International Standard Book Number\n\nThis validates that a string value contains a valid isbn10 or isbn13 value.\n\n\tUsage: isbn\n\n# International Standard Book Number 10\n\nThis validates that a string value contains a valid isbn10 value.\n\n\tUsage: isbn10\n\n# International Standard Book Number 13\n\nThis validates that a string value contains a valid isbn13 value.\n\n\tUsage: isbn13\n\n# Universally Unique Identifier UUID\n\nThis validates that a string value contains a valid UUID. Uppercase UUID values will not pass - use `uuid_rfc4122` instead.\n\n\tUsage: uuid\n\n# Universally Unique Identifier UUID v3\n\nThis validates that a string value contains a valid version 3 UUID.  Uppercase UUID values will not pass - use `uuid3_rfc4122` instead.\n\n\tUsage: uuid3\n\n# Universally Unique Identifier UUID v4\n\nThis validates that a string value contains a valid version 4 UUID.  Uppercase UUID values will not pass - use `uuid4_rfc4122` instead.\n\n\tUsage: uuid4\n\n# Universally Unique Identifier UUID v5\n\nThis validates that a string value contains a valid version 5 UUID.  Uppercase UUID values will not pass - use `uuid5_rfc4122` instead.\n\n\tUsage: uuid5\n\n# Universally Unique Lexicographically Sortable Identifier ULID\n\nThis validates that a string value contains a valid ULID value.\n\n\tUsage: ulid\n\n# ASCII\n\nThis validates that a string value contains only ASCII characters.\nNOTE: if the string is blank, this validates as true.\n\n\tUsage: ascii\n\n# Printable ASCII\n\nThis validates that a string value contains only printable ASCII characters.\nNOTE: if the string is blank, this validates as true.\n\n\tUsage: printascii\n\n# Multi-Byte Characters\n\nThis validates that a string value contains one or more multibyte characters.\nNOTE: if the string is blank, this validates as true.\n\n\tUsage: multibyte\n\n# Data URL\n\nThis validates that a string value contains a valid DataURI.\nNOTE: this will also validate that the data portion is valid base64\n\n\tUsage: datauri\n\n# Latitude\n\nThis validates that a string value contains a valid latitude.\n\n\tUsage: latitude\n\n# Longitude\n\nThis validates that a string value contains a valid longitude.\n\n\tUsage: longitude\n\n# Social Security Number SSN\n\nThis validates that a string value contains a valid U.S. Social Security Number.\n\n\tUsage: ssn\n\n# Internet Protocol Address IP\n\nThis validates that a string value contains a valid IP Address.\n\n\tUsage: ip\n\n# Internet Protocol Address IPv4\n\nThis validates that a string value contains a valid v4 IP Address.\n\n\tUsage: ipv4\n\n# Internet Protocol Address IPv6\n\nThis validates that a string value contains a valid v6 IP Address.\n\n\tUsage: ipv6\n\n# Classless Inter-Domain Routing CIDR\n\nThis validates that a string value contains a valid CIDR Address.\n\n\tUsage: cidr\n\n# Classless Inter-Domain Routing CIDRv4\n\nThis validates that a string value contains a valid v4 CIDR Address.\n\n\tUsage: cidrv4\n\n# Classless Inter-Domain Routing CIDRv6\n\nThis validates that a string value contains a valid v6 CIDR Address.\n\n\tUsage: cidrv6\n\n# Transmission Control Protocol Address TCP\n\nThis validates that a string value contains a valid resolvable TCP Address.\n\n\tUsage: tcp_addr\n\n# Transmission Control Protocol Address TCPv4\n\nThis validates that a string value contains a valid resolvable v4 TCP Address.\n\n\tUsage: tcp4_addr\n\n# Transmission Control Protocol Address TCPv6\n\nThis validates that a string value contains a valid resolvable v6 TCP Address.\n\n\tUsage: tcp6_addr\n\n# User Datagram Protocol Address UDP\n\nThis validates that a string value contains a valid resolvable UDP Address.\n\n\tUsage: udp_addr\n\n# User Datagram Protocol Address UDPv4\n\nThis validates that a string value contains a valid resolvable v4 UDP Address.\n\n\tUsage: udp4_addr\n\n# User Datagram Protocol Address UDPv6\n\nThis validates that a string value contains a valid resolvable v6 UDP Address.\n\n\tUsage: udp6_addr\n\n# Internet Protocol Address IP\n\nThis validates that a string value contains a valid resolvable IP Address.\n\n\tUsage: ip_addr\n\n# Internet Protocol Address IPv4\n\nThis validates that a string value contains a valid resolvable v4 IP Address.\n\n\tUsage: ip4_addr\n\n# Internet Protocol Address IPv6\n\nThis validates that a string value contains a valid resolvable v6 IP Address.\n\n\tUsage: ip6_addr\n\n# Unix domain socket end point Address\n\nThis validates that a string value contains a valid Unix Address.\n\n\tUsage: unix_addr\n\n# Media Access Control Address MAC\n\nThis validates that a string value contains a valid MAC Address.\n\n\tUsage: mac\n\nNote: See Go's ParseMAC for accepted formats and types:\n\n\thttp://golang.org/src/net/mac.go?s=866:918#L29\n\n# Hostname RFC 952\n\nThis validates that a string value is a valid Hostname according to RFC 952 https://tools.ietf.org/html/rfc952\n\n\tUsage: hostname\n\n# Hostname RFC 1123\n\nThis validates that a string value is a valid Hostname according to RFC 1123 https://tools.ietf.org/html/rfc1123\n\n\tUsage: hostname_rfc1123 or if you want to continue to use 'hostname' in your tags, create an alias.\n\nFull Qualified Domain Name (FQDN)\n\nThis validates that a string value contains a valid FQDN.\n\n\tUsage: fqdn\n\n# HTML Tags\n\nThis validates that a string value appears to be an HTML element tag\nincluding those described at https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\n\tUsage: html\n\n# HTML Encoded\n\nThis validates that a string value is a proper character reference in decimal\nor hexadecimal format\n\n\tUsage: html_encoded\n\n# URL Encoded\n\nThis validates that a string value is percent-encoded (URL encoded) according\nto https://tools.ietf.org/html/rfc3986#section-2.1\n\n\tUsage: url_encoded\n\n# Directory\n\nThis validates that a string value contains a valid directory and that\nit exists on the machine.\nThis is done using os.Stat, which is a platform independent function.\n\n\tUsage: dir\n\n# Directory Path\n\nThis validates that a string value contains a valid directory but does\nnot validate the existence of that directory.\nThis is done using os.Stat, which is a platform independent function.\nIt is safest to suffix the string with os.PathSeparator if the directory\nmay not exist at the time of validation.\n\n\tUsage: dirpath\n\n# HostPort\n\nThis validates that a string value contains a valid DNS hostname and port that\ncan be used to validate fields typically passed to sockets and connections.\n\n\tUsage: hostname_port\n\n# Datetime\n\nThis validates that a string value is a valid datetime based on the supplied datetime format.\nSupplied format must match the official Go time format layout as documented in https://golang.org/pkg/time/\n\n\tUsage: datetime=2006-01-02\n\n# Iso3166-1 alpha-2\n\nThis validates that a string value is a valid country code based on iso3166-1 alpha-2 standard.\nsee: https://www.iso.org/iso-3166-country-codes.html\n\n\tUsage: iso3166_1_alpha2\n\n# Iso3166-1 alpha-3\n\nThis validates that a string value is a valid country code based on iso3166-1 alpha-3 standard.\nsee: https://www.iso.org/iso-3166-country-codes.html\n\n\tUsage: iso3166_1_alpha3\n\n# Iso3166-1 alpha-numeric\n\nThis validates that a string value is a valid country code based on iso3166-1 alpha-numeric standard.\nsee: https://www.iso.org/iso-3166-country-codes.html\n\n\tUsage: iso3166_1_alpha3\n\n# BCP 47 Language Tag\n\nThis validates that a string value is a valid BCP 47 language tag, as parsed by language.Parse.\nMore information on https://pkg.go.dev/golang.org/x/text/language\n\n\tUsage: bcp47_language_tag\n\nBIC (SWIFT code)\n\nThis validates that a string value is a valid Business Identifier Code (SWIFT code), defined in ISO 9362.\nMore information on https://www.iso.org/standard/60390.html\n\n\tUsage: bic\n\n# RFC 1035 label\n\nThis validates that a string value is a valid dns RFC 1035 label, defined in RFC 1035.\nMore information on https://datatracker.ietf.org/doc/html/rfc1035\n\n\tUsage: dns_rfc1035_label\n\n# TimeZone\n\nThis validates that a string value is a valid time zone based on the time zone database present on the system.\nAlthough empty value and Local value are allowed by time.LoadLocation golang function, they are not allowed by this validator.\nMore information on https://golang.org/pkg/time/#LoadLocation\n\n\tUsage: timezone\n\n# Semantic Version\n\nThis validates that a string value is a valid semver version, defined in Semantic Versioning 2.0.0.\nMore information on https://semver.org/\n\n\tUsage: semver\n\n# CVE Identifier\n\nThis validates that a string value is a valid cve id, defined in cve mitre.\nMore information on https://cve.mitre.org/\n\n\tUsage: cve\n\n# Credit Card\n\nThis validates that a string value contains a valid credit card number using Luhn algorithm.\n\n\tUsage: credit_card\n\n# Luhn Checksum\n\n\tUsage: luhn_checksum\n\nThis validates that a string or (u)int value contains a valid checksum using the Luhn algorithm.\n\n# MongoDB\n\nThis validates that a string is a valid 24 character hexadecimal string or valid connection string.\n\n\tUsage: mongodb\n\t       mongodb_connection_string\n\nExample:\n\n\ttype Test struct {\n\t\tObjectIdField         string `validate:\"mongodb\"`\n\t\tConnectionStringField string `validate:\"mongodb_connection_string\"`\n\t}\n\n# Cron\n\nThis validates that a string value contains a valid cron expression.\n\n\tUsage: cron\n\n# SpiceDb ObjectID/Permission/Object Type\n\nThis validates that a string is valid for use with SpiceDb for the indicated purpose. If no purpose is given, a purpose of 'id' is assumed.\n\n\tUsage: spicedb=id|permission|type\n\n# Alias Validators and Tags\n\nAlias Validators and Tags\nNOTE: When returning an error, the tag returned in \"FieldError\" will be\nthe alias tag unless the dive tag is part of the alias. Everything after the\ndive tag is not reported as the alias tag. Also, the \"ActualTag\" in the before\ncase will be the actual tag within the alias that failed.\n\nHere is a list of the current built in alias tags:\n\n\t\"iscolor\"\n\t\talias is \"hexcolor|rgb|rgba|hsl|hsla\" (Usage: iscolor)\n\t\"country_code\"\n\t\talias is \"iso3166_1_alpha2|iso3166_1_alpha3|iso3166_1_alpha_numeric\" (Usage: country_code)\n\nValidator notes:\n\n\tregex\n\t\ta regex validator won't be added because commas and = signs can be part\n\t\tof a regex which conflict with the validation definitions. Although\n\t\tworkarounds can be made, they take away from using pure regex's.\n\t\tFurthermore it's quick and dirty but the regex's become harder to\n\t\tmaintain and are not reusable, so it's as much a programming philosophy\n\t\tas anything.\n\n\t\tIn place of this new validator functions should be created; a regex can\n\t\tbe used within the validator function and even be precompiled for better\n\t\tefficiency within regexes.go.\n\n\t\tAnd the best reason, you can submit a pull request and we can keep on\n\t\tadding to the validation library of this package!\n\n# Non standard validators\n\nA collection of validation rules that are frequently needed but are more\ncomplex than the ones found in the baked in validators.\nA non standard validator must be registered manually like you would\nwith your own custom validation functions.\n\nExample of registration and use:\n\n\ttype Test struct {\n\t\tTestField string `validate:\"yourtag\"`\n\t}\n\n\tt := &Test{\n\t\tTestField: \"Test\"\n\t}\n\n\tvalidate := validator.New()\n\tvalidate.RegisterValidation(\"yourtag\", validators.NotBlank)\n\nHere is a list of the current non standard validators:\n\n\tNotBlank\n\t\tThis validates that the value is not blank or with length zero.\n\t\tFor strings ensures they do not contain only spaces. For channels, maps, slices and arrays\n\t\tensures they don't have zero length. For others, a non empty value is required.\n\n\t\tUsage: notblank\n\n# Panics\n\nThis package panics when bad input is provided, this is by design, bad code like\nthat should not make it to production.\n\n\ttype Test struct {\n\t\tTestField string `validate:\"nonexistantfunction=1\"`\n\t}\n\n\tt := &Test{\n\t\tTestField: \"Test\"\n\t}\n\n\tvalidate.Struct(t) // this will panic\n*/\npackage validator\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 7.3232421875,
          "content": "package validator\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\tut \"github.com/go-playground/universal-translator\"\n)\n\nconst (\n\tfieldErrMsg = \"Key: '%s' Error:Field validation for '%s' failed on the '%s' tag\"\n)\n\n// ValidationErrorsTranslations is the translation return type\ntype ValidationErrorsTranslations map[string]string\n\n// InvalidValidationError describes an invalid argument passed to\n// `Struct`, `StructExcept`, StructPartial` or `Field`\ntype InvalidValidationError struct {\n\tType reflect.Type\n}\n\n// Error returns InvalidValidationError message\nfunc (e *InvalidValidationError) Error() string {\n\n\tif e.Type == nil {\n\t\treturn \"validator: (nil)\"\n\t}\n\n\treturn \"validator: (nil \" + e.Type.String() + \")\"\n}\n\n// ValidationErrors is an array of FieldError's\n// for use in custom error messages post validation.\ntype ValidationErrors []FieldError\n\n// Error is intended for use in development + debugging and not intended to be a production error message.\n// It allows ValidationErrors to subscribe to the Error interface.\n// All information to create an error message specific to your application is contained within\n// the FieldError found within the ValidationErrors array\nfunc (ve ValidationErrors) Error() string {\n\n\tbuff := bytes.NewBufferString(\"\")\n\n\tfor i := 0; i < len(ve); i++ {\n\n\t\tbuff.WriteString(ve[i].Error())\n\t\tbuff.WriteString(\"\\n\")\n\t}\n\n\treturn strings.TrimSpace(buff.String())\n}\n\n// Translate translates all of the ValidationErrors\nfunc (ve ValidationErrors) Translate(ut ut.Translator) ValidationErrorsTranslations {\n\n\ttrans := make(ValidationErrorsTranslations)\n\n\tvar fe *fieldError\n\n\tfor i := 0; i < len(ve); i++ {\n\t\tfe = ve[i].(*fieldError)\n\n\t\t// // in case an Anonymous struct was used, ensure that the key\n\t\t// // would be 'Username' instead of \".Username\"\n\t\t// if len(fe.ns) > 0 && fe.ns[:1] == \".\" {\n\t\t// \ttrans[fe.ns[1:]] = fe.Translate(ut)\n\t\t// \tcontinue\n\t\t// }\n\n\t\ttrans[fe.ns] = fe.Translate(ut)\n\t}\n\n\treturn trans\n}\n\n// FieldError contains all functions to get error details\ntype FieldError interface {\n\n\t// Tag returns the validation tag that failed. if the\n\t// validation was an alias, this will return the\n\t// alias name and not the underlying tag that failed.\n\t//\n\t// eg. alias \"iscolor\": \"hexcolor|rgb|rgba|hsl|hsla\"\n\t// will return \"iscolor\"\n\tTag() string\n\n\t// ActualTag returns the validation tag that failed, even if an\n\t// alias the actual tag within the alias will be returned.\n\t// If an 'or' validation fails the entire or will be returned.\n\t//\n\t// eg. alias \"iscolor\": \"hexcolor|rgb|rgba|hsl|hsla\"\n\t// will return \"hexcolor|rgb|rgba|hsl|hsla\"\n\tActualTag() string\n\n\t// Namespace returns the namespace for the field error, with the tag\n\t// name taking precedence over the field's actual name.\n\t//\n\t// eg. JSON name \"User.fname\"\n\t//\n\t// See StructNamespace() for a version that returns actual names.\n\t//\n\t// NOTE: this field can be blank when validating a single primitive field\n\t// using validate.Field(...) as there is no way to extract it's name\n\tNamespace() string\n\n\t// StructNamespace returns the namespace for the field error, with the field's\n\t// actual name.\n\t//\n\t// eq. \"User.FirstName\" see Namespace for comparison\n\t//\n\t// NOTE: this field can be blank when validating a single primitive field\n\t// using validate.Field(...) as there is no way to extract its name\n\tStructNamespace() string\n\n\t// Field returns the fields name with the tag name taking precedence over the\n\t// field's actual name.\n\t//\n\t// eq. JSON name \"fname\"\n\t// see StructField for comparison\n\tField() string\n\n\t// StructField returns the field's actual name from the struct, when able to determine.\n\t//\n\t// eq.  \"FirstName\"\n\t// see Field for comparison\n\tStructField() string\n\n\t// Value returns the actual field's value in case needed for creating the error\n\t// message\n\tValue() interface{}\n\n\t// Param returns the param value, in string form for comparison; this will also\n\t// help with generating an error message\n\tParam() string\n\n\t// Kind returns the Field's reflect Kind\n\t//\n\t// eg. time.Time's kind is a struct\n\tKind() reflect.Kind\n\n\t// Type returns the Field's reflect Type\n\t//\n\t// eg. time.Time's type is time.Time\n\tType() reflect.Type\n\n\t// Translate returns the FieldError's translated error\n\t// from the provided 'ut.Translator' and registered 'TranslationFunc'\n\t//\n\t// NOTE: if no registered translator can be found it returns the same as\n\t// calling fe.Error()\n\tTranslate(ut ut.Translator) string\n\n\t// Error returns the FieldError's message\n\tError() string\n}\n\n// compile time interface checks\nvar _ FieldError = new(fieldError)\nvar _ error = new(fieldError)\n\n// fieldError contains a single field's validation error along\n// with other properties that may be needed for error message creation\n// it complies with the FieldError interface\ntype fieldError struct {\n\tv              *Validate\n\ttag            string\n\tactualTag      string\n\tns             string\n\tstructNs       string\n\tfieldLen       uint8\n\tstructfieldLen uint8\n\tvalue          interface{}\n\tparam          string\n\tkind           reflect.Kind\n\ttyp            reflect.Type\n}\n\n// Tag returns the validation tag that failed.\nfunc (fe *fieldError) Tag() string {\n\treturn fe.tag\n}\n\n// ActualTag returns the validation tag that failed, even if an\n// alias the actual tag within the alias will be returned.\nfunc (fe *fieldError) ActualTag() string {\n\treturn fe.actualTag\n}\n\n// Namespace returns the namespace for the field error, with the tag\n// name taking precedence over the field's actual name.\nfunc (fe *fieldError) Namespace() string {\n\treturn fe.ns\n}\n\n// StructNamespace returns the namespace for the field error, with the field's\n// actual name.\nfunc (fe *fieldError) StructNamespace() string {\n\treturn fe.structNs\n}\n\n// Field returns the field's name with the tag name taking precedence over the\n// field's actual name.\nfunc (fe *fieldError) Field() string {\n\n\treturn fe.ns[len(fe.ns)-int(fe.fieldLen):]\n\t// // return fe.field\n\t// fld := fe.ns[len(fe.ns)-int(fe.fieldLen):]\n\n\t// log.Println(\"FLD:\", fld)\n\n\t// if len(fld) > 0 && fld[:1] == \".\" {\n\t// \treturn fld[1:]\n\t// }\n\n\t// return fld\n}\n\n// StructField returns the field's actual name from the struct, when able to determine.\nfunc (fe *fieldError) StructField() string {\n\t// return fe.structField\n\treturn fe.structNs[len(fe.structNs)-int(fe.structfieldLen):]\n}\n\n// Value returns the actual field's value in case needed for creating the error\n// message\nfunc (fe *fieldError) Value() interface{} {\n\treturn fe.value\n}\n\n// Param returns the param value, in string form for comparison; this will\n// also help with generating an error message\nfunc (fe *fieldError) Param() string {\n\treturn fe.param\n}\n\n// Kind returns the Field's reflect Kind\nfunc (fe *fieldError) Kind() reflect.Kind {\n\treturn fe.kind\n}\n\n// Type returns the Field's reflect Type\nfunc (fe *fieldError) Type() reflect.Type {\n\treturn fe.typ\n}\n\n// Error returns the fieldError's error message\nfunc (fe *fieldError) Error() string {\n\treturn fmt.Sprintf(fieldErrMsg, fe.ns, fe.Field(), fe.tag)\n}\n\n// Translate returns the FieldError's translated error\n// from the provided 'ut.Translator' and registered 'TranslationFunc'\n//\n// NOTE: if no registered translation can be found, it returns the original\n// untranslated error message.\nfunc (fe *fieldError) Translate(ut ut.Translator) string {\n\tvar fn TranslationFunc\n\n\tm, ok := fe.v.transTagFunc[ut]\n\tif !ok {\n\t\treturn fe.Error()\n\t}\n\n\tfn, ok = m[fe.tag]\n\tif !ok {\n\t\tfn, ok = m[fe.actualTag]\n\t\tif !ok {\n\t\t\treturn fe.Error()\n\t\t}\n\t}\n\n\treturn fn(ut, fe)\n}\n"
        },
        {
          "name": "field_level.go",
          "type": "blob",
          "size": 4.80859375,
          "content": "package validator\n\nimport \"reflect\"\n\n// FieldLevel contains all the information and helper functions\n// to validate a field\ntype FieldLevel interface {\n\n\t// Top returns the top level struct, if any\n\tTop() reflect.Value\n\n\t// Parent returns the current fields parent struct, if any or\n\t// the comparison value if called 'VarWithValue'\n\tParent() reflect.Value\n\n\t// Field returns current field for validation\n\tField() reflect.Value\n\n\t// FieldName returns the field's name with the tag\n\t// name taking precedence over the fields actual name.\n\tFieldName() string\n\n\t// StructFieldName returns the struct field's name\n\tStructFieldName() string\n\n\t// Param returns param for validation against current field\n\tParam() string\n\n\t// GetTag returns the current validations tag name\n\tGetTag() string\n\n\t// ExtractType gets the actual underlying type of field value.\n\t// It will dive into pointers, customTypes and return you the\n\t// underlying value and it's kind.\n\tExtractType(field reflect.Value) (value reflect.Value, kind reflect.Kind, nullable bool)\n\n\t// GetStructFieldOK traverses the parent struct to retrieve a specific field denoted by the provided namespace\n\t// in the param and returns the field, field kind and whether is was successful in retrieving\n\t// the field at all.\n\t//\n\t// NOTE: when not successful ok will be false, this can happen when a nested struct is nil and so the field\n\t// could not be retrieved because it didn't exist.\n\t//\n\t// Deprecated: Use GetStructFieldOK2() instead which also return if the value is nullable.\n\tGetStructFieldOK() (reflect.Value, reflect.Kind, bool)\n\n\t// GetStructFieldOKAdvanced is the same as GetStructFieldOK except that it accepts the parent struct to start looking for\n\t// the field and namespace allowing more extensibility for validators.\n\t//\n\t// Deprecated: Use GetStructFieldOKAdvanced2() instead which also return if the value is nullable.\n\tGetStructFieldOKAdvanced(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, bool)\n\n\t// GetStructFieldOK2 traverses the parent struct to retrieve a specific field denoted by the provided namespace\n\t// in the param and returns the field, field kind, if it's a nullable type and whether is was successful in retrieving\n\t// the field at all.\n\t//\n\t// NOTE: when not successful ok will be false, this can happen when a nested struct is nil and so the field\n\t// could not be retrieved because it didn't exist.\n\tGetStructFieldOK2() (reflect.Value, reflect.Kind, bool, bool)\n\n\t// GetStructFieldOKAdvanced2 is the same as GetStructFieldOK except that it accepts the parent struct to start looking for\n\t// the field and namespace allowing more extensibility for validators.\n\tGetStructFieldOKAdvanced2(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, bool, bool)\n}\n\nvar _ FieldLevel = new(validate)\n\n// Field returns current field for validation\nfunc (v *validate) Field() reflect.Value {\n\treturn v.flField\n}\n\n// FieldName returns the field's name with the tag\n// name taking precedence over the fields actual name.\nfunc (v *validate) FieldName() string {\n\treturn v.cf.altName\n}\n\n// GetTag returns the current validations tag name\nfunc (v *validate) GetTag() string {\n\treturn v.ct.tag\n}\n\n// StructFieldName returns the struct field's name\nfunc (v *validate) StructFieldName() string {\n\treturn v.cf.name\n}\n\n// Param returns param for validation against current field\nfunc (v *validate) Param() string {\n\treturn v.ct.param\n}\n\n// GetStructFieldOK returns Param returns param for validation against current field\n//\n// Deprecated: Use GetStructFieldOK2() instead which also return if the value is nullable.\nfunc (v *validate) GetStructFieldOK() (reflect.Value, reflect.Kind, bool) {\n\tcurrent, kind, _, found := v.getStructFieldOKInternal(v.slflParent, v.ct.param)\n\treturn current, kind, found\n}\n\n// GetStructFieldOKAdvanced is the same as GetStructFieldOK except that it accepts the parent struct to start looking for\n// the field and namespace allowing more extensibility for validators.\n//\n// Deprecated: Use GetStructFieldOKAdvanced2() instead which also return if the value is nullable.\nfunc (v *validate) GetStructFieldOKAdvanced(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, bool) {\n\tcurrent, kind, _, found := v.GetStructFieldOKAdvanced2(val, namespace)\n\treturn current, kind, found\n}\n\n// GetStructFieldOK2 returns Param returns param for validation against current field\nfunc (v *validate) GetStructFieldOK2() (reflect.Value, reflect.Kind, bool, bool) {\n\treturn v.getStructFieldOKInternal(v.slflParent, v.ct.param)\n}\n\n// GetStructFieldOKAdvanced2 is the same as GetStructFieldOK except that it accepts the parent struct to start looking for\n// the field and namespace allowing more extensibility for validators.\nfunc (v *validate) GetStructFieldOKAdvanced2(val reflect.Value, namespace string) (reflect.Value, reflect.Kind, bool, bool) {\n\treturn v.getStructFieldOKInternal(val, namespace)\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.419921875,
          "content": "module github.com/go-playground/validator/v10\n\ngo 1.18\n\nrequire (\n\tgithub.com/gabriel-vasile/mimetype v1.4.3\n\tgithub.com/go-playground/assert/v2 v2.2.0\n\tgithub.com/go-playground/locales v0.14.1\n\tgithub.com/go-playground/universal-translator v0.18.1\n\tgithub.com/leodido/go-urn v1.4.0\n\tgolang.org/x/crypto v0.19.0\n\tgolang.org/x/text v0.14.0\n)\n\nrequire (\n\tgolang.org/x/net v0.21.0 // indirect\n\tgolang.org/x/sys v0.17.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.8369140625,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/gabriel-vasile/mimetype v1.4.3 h1:in2uUcidCuFcDKtdcBxlR0rJ1+fsokWf+uqxgUFjbI0=\ngithub.com/gabriel-vasile/mimetype v1.4.3/go.mod h1:d8uq/6HKRL6CGdk+aubisF/M5GcPfT7nKyLpA0lbSSk=\ngithub.com/go-playground/assert/v2 v2.2.0 h1:JvknZsQTYeFEAhQwI4qEt9cyV5ONwRHC+lYKSsYSR8s=\ngithub.com/go-playground/assert/v2 v2.2.0/go.mod h1:VDjEfimB/XKnb+ZQfWdccd7VUvScMdVu0Titje2rxJ4=\ngithub.com/go-playground/locales v0.14.1 h1:EWaQ/wswjilfKLTECiXz7Rh+3BjFhfDFKv/oXslEjJA=\ngithub.com/go-playground/locales v0.14.1/go.mod h1:hxrqLVvrK65+Rwrd5Fc6F2O76J/NuW9t0sjnWqG1slY=\ngithub.com/go-playground/universal-translator v0.18.1 h1:Bcnm0ZwsGyWbCzImXv+pAJnYK9S473LQFuzCbDbfSFY=\ngithub.com/go-playground/universal-translator v0.18.1/go.mod h1:xekY+UJKNuX9WP91TpwSH2VMlDf28Uj24BCp08ZFTUY=\ngithub.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=\ngithub.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngolang.org/x/crypto v0.19.0 h1:ENy+Az/9Y1vSrlrvBSyna3PITt4tiZLf7sgCjZBX7Wo=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/net v0.21.0 h1:AQyQV4dYCvJ7vGmJyKki9+PBdyvhkSd8EIx/qb0AYv4=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/sys v0.17.0 h1:25cE3gD+tdBA7lp7QfhuV+rJiE9YXTcS3VG1SqssI/Y=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 13.1279296875,
          "content": null
        },
        {
          "name": "non-standard",
          "type": "tree",
          "content": null
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 0.9873046875,
          "content": "package validator\n\n// Option represents a configurations option to be applied to validator during initialization.\ntype Option func(*Validate)\n\n// WithRequiredStructEnabled enables required tag on non-pointer structs to be applied instead of ignored.\n//\n// This was made opt-in behaviour in order to maintain backward compatibility with the behaviour previous\n// to being able to apply struct level validations on struct fields directly.\n//\n// It is recommended you enabled this as it will be the default behaviour in v11+\nfunc WithRequiredStructEnabled() Option {\n\treturn func(v *Validate) {\n\t\tv.requiredStructEnabled = true\n\t}\n}\n\n// WithPrivateFieldValidation activates validation for unexported fields via the use of the `unsafe` package.\n//\n// By opting into this feature you are acknowledging that you are aware of the risks and accept any current or future\n// consequences of using this feature.\nfunc WithPrivateFieldValidation() Option {\n\treturn func(v *Validate) {\n\t\tv.privateFieldValidation = true\n\t}\n}\n"
        },
        {
          "name": "postcode_regexes.go",
          "type": "blob",
          "size": 4.232421875,
          "content": "package validator\n\nimport (\n\t\"regexp\"\n\t\"sync\"\n)\n\nvar postCodePatternDict = map[string]string{\n\t\"GB\": `^GIR[ ]?0AA|((AB|AL|B|BA|BB|BD|BH|BL|BN|BR|BS|BT|CA|CB|CF|CH|CM|CO|CR|CT|CV|CW|DA|DD|DE|DG|DH|DL|DN|DT|DY|E|EC|EH|EN|EX|FK|FY|G|GL|GY|GU|HA|HD|HG|HP|HR|HS|HU|HX|IG|IM|IP|IV|JE|KA|KT|KW|KY|L|LA|LD|LE|LL|LN|LS|LU|M|ME|MK|ML|N|NE|NG|NN|NP|NR|NW|OL|OX|PA|PE|PH|PL|PO|PR|RG|RH|RM|S|SA|SE|SG|SK|SL|SM|SN|SO|SP|SR|SS|ST|SW|SY|TA|TD|TF|TN|TQ|TR|TS|TW|UB|W|WA|WC|WD|WF|WN|WR|WS|WV|YO|ZE)(\\d[\\dA-Z]?[ ]?\\d[ABD-HJLN-UW-Z]{2}))|BFPO[ ]?\\d{1,4}$`,\n\t\"JE\": `^JE\\d[\\dA-Z]?[ ]?\\d[ABD-HJLN-UW-Z]{2}$`,\n\t\"GG\": `^GY\\d[\\dA-Z]?[ ]?\\d[ABD-HJLN-UW-Z]{2}$`,\n\t\"IM\": `^IM\\d[\\dA-Z]?[ ]?\\d[ABD-HJLN-UW-Z]{2}$`,\n\t\"US\": `^\\d{5}([ \\-]\\d{4})?$`,\n\t\"CA\": `^[ABCEGHJKLMNPRSTVXY]\\d[ABCEGHJ-NPRSTV-Z][ ]?\\d[ABCEGHJ-NPRSTV-Z]\\d$`,\n\t\"DE\": `^\\d{5}$`,\n\t\"JP\": `^\\d{3}-\\d{4}$`,\n\t\"FR\": `^\\d{2}[ ]?\\d{3}$`,\n\t\"AU\": `^\\d{4}$`,\n\t\"IT\": `^\\d{5}$`,\n\t\"CH\": `^\\d{4}$`,\n\t\"AT\": `^\\d{4}$`,\n\t\"ES\": `^\\d{5}$`,\n\t\"NL\": `^\\d{4}[ ]?[A-Z]{2}$`,\n\t\"BE\": `^\\d{4}$`,\n\t\"DK\": `^\\d{4}$`,\n\t\"SE\": `^\\d{3}[ ]?\\d{2}$`,\n\t\"NO\": `^\\d{4}$`,\n\t\"BR\": `^\\d{5}[\\-]?\\d{3}$`,\n\t\"PT\": `^\\d{4}([\\-]\\d{3})?$`,\n\t\"FI\": `^\\d{5}$`,\n\t\"AX\": `^22\\d{3}$`,\n\t\"KR\": `^\\d{3}[\\-]\\d{3}$`,\n\t\"CN\": `^\\d{6}$`,\n\t\"TW\": `^\\d{3}(\\d{2})?$`,\n\t\"SG\": `^\\d{6}$`,\n\t\"DZ\": `^\\d{5}$`,\n\t\"AD\": `^AD\\d{3}$`,\n\t\"AR\": `^([A-HJ-NP-Z])?\\d{4}([A-Z]{3})?$`,\n\t\"AM\": `^(37)?\\d{4}$`,\n\t\"AZ\": `^\\d{4}$`,\n\t\"BH\": `^((1[0-2]|[2-9])\\d{2})?$`,\n\t\"BD\": `^\\d{4}$`,\n\t\"BB\": `^(BB\\d{5})?$`,\n\t\"BY\": `^\\d{6}$`,\n\t\"BM\": `^[A-Z]{2}[ ]?[A-Z0-9]{2}$`,\n\t\"BA\": `^\\d{5}$`,\n\t\"IO\": `^BBND 1ZZ$`,\n\t\"BN\": `^[A-Z]{2}[ ]?\\d{4}$`,\n\t\"BG\": `^\\d{4}$`,\n\t\"KH\": `^\\d{5}$`,\n\t\"CV\": `^\\d{4}$`,\n\t\"CL\": `^\\d{7}$`,\n\t\"CR\": `^\\d{4,5}|\\d{3}-\\d{4}$`,\n\t\"HR\": `^\\d{5}$`,\n\t\"CY\": `^\\d{4}$`,\n\t\"CZ\": `^\\d{3}[ ]?\\d{2}$`,\n\t\"DO\": `^\\d{5}$`,\n\t\"EC\": `^([A-Z]\\d{4}[A-Z]|(?:[A-Z]{2})?\\d{6})?$`,\n\t\"EG\": `^\\d{5}$`,\n\t\"EE\": `^\\d{5}$`,\n\t\"FO\": `^\\d{3}$`,\n\t\"GE\": `^\\d{4}$`,\n\t\"GR\": `^\\d{3}[ ]?\\d{2}$`,\n\t\"GL\": `^39\\d{2}$`,\n\t\"GT\": `^\\d{5}$`,\n\t\"HT\": `^\\d{4}$`,\n\t\"HN\": `^(?:\\d{5})?$`,\n\t\"HU\": `^\\d{4}$`,\n\t\"IS\": `^\\d{3}$`,\n\t\"IN\": `^\\d{6}$`,\n\t\"ID\": `^\\d{5}$`,\n\t\"IL\": `^\\d{5}$`,\n\t\"JO\": `^\\d{5}$`,\n\t\"KZ\": `^\\d{6}$`,\n\t\"KE\": `^\\d{5}$`,\n\t\"KW\": `^\\d{5}$`,\n\t\"LA\": `^\\d{5}$`,\n\t\"LV\": `^\\d{4}$`,\n\t\"LB\": `^(\\d{4}([ ]?\\d{4})?)?$`,\n\t\"LI\": `^(948[5-9])|(949[0-7])$`,\n\t\"LT\": `^\\d{5}$`,\n\t\"LU\": `^\\d{4}$`,\n\t\"MK\": `^\\d{4}$`,\n\t\"MY\": `^\\d{5}$`,\n\t\"MV\": `^\\d{5}$`,\n\t\"MT\": `^[A-Z]{3}[ ]?\\d{2,4}$`,\n\t\"MU\": `^(\\d{3}[A-Z]{2}\\d{3})?$`,\n\t\"MX\": `^\\d{5}$`,\n\t\"MD\": `^\\d{4}$`,\n\t\"MC\": `^980\\d{2}$`,\n\t\"MA\": `^\\d{5}$`,\n\t\"NP\": `^\\d{5}$`,\n\t\"NZ\": `^\\d{4}$`,\n\t\"NI\": `^((\\d{4}-)?\\d{3}-\\d{3}(-\\d{1})?)?$`,\n\t\"NG\": `^(\\d{6})?$`,\n\t\"OM\": `^(PC )?\\d{3}$`,\n\t\"PK\": `^\\d{5}$`,\n\t\"PY\": `^\\d{4}$`,\n\t\"PH\": `^\\d{4}$`,\n\t\"PL\": `^\\d{2}-\\d{3}$`,\n\t\"PR\": `^00[679]\\d{2}([ \\-]\\d{4})?$`,\n\t\"RO\": `^\\d{6}$`,\n\t\"RU\": `^\\d{6}$`,\n\t\"SM\": `^4789\\d$`,\n\t\"SA\": `^\\d{5}$`,\n\t\"SN\": `^\\d{5}$`,\n\t\"SK\": `^\\d{3}[ ]?\\d{2}$`,\n\t\"SI\": `^\\d{4}$`,\n\t\"ZA\": `^\\d{4}$`,\n\t\"LK\": `^\\d{5}$`,\n\t\"TJ\": `^\\d{6}$`,\n\t\"TH\": `^\\d{5}$`,\n\t\"TN\": `^\\d{4}$`,\n\t\"TR\": `^\\d{5}$`,\n\t\"TM\": `^\\d{6}$`,\n\t\"UA\": `^\\d{5}$`,\n\t\"UY\": `^\\d{5}$`,\n\t\"UZ\": `^\\d{6}$`,\n\t\"VA\": `^00120$`,\n\t\"VE\": `^\\d{4}$`,\n\t\"ZM\": `^\\d{5}$`,\n\t\"AS\": `^96799$`,\n\t\"CC\": `^6799$`,\n\t\"CK\": `^\\d{4}$`,\n\t\"RS\": `^\\d{6}$`,\n\t\"ME\": `^8\\d{4}$`,\n\t\"CS\": `^\\d{5}$`,\n\t\"YU\": `^\\d{5}$`,\n\t\"CX\": `^6798$`,\n\t\"ET\": `^\\d{4}$`,\n\t\"FK\": `^FIQQ 1ZZ$`,\n\t\"NF\": `^2899$`,\n\t\"FM\": `^(9694[1-4])([ \\-]\\d{4})?$`,\n\t\"GF\": `^9[78]3\\d{2}$`,\n\t\"GN\": `^\\d{3}$`,\n\t\"GP\": `^9[78][01]\\d{2}$`,\n\t\"GS\": `^SIQQ 1ZZ$`,\n\t\"GU\": `^969[123]\\d([ \\-]\\d{4})?$`,\n\t\"GW\": `^\\d{4}$`,\n\t\"HM\": `^\\d{4}$`,\n\t\"IQ\": `^\\d{5}$`,\n\t\"KG\": `^\\d{6}$`,\n\t\"LR\": `^\\d{4}$`,\n\t\"LS\": `^\\d{3}$`,\n\t\"MG\": `^\\d{3}$`,\n\t\"MH\": `^969[67]\\d([ \\-]\\d{4})?$`,\n\t\"MN\": `^\\d{6}$`,\n\t\"MP\": `^9695[012]([ \\-]\\d{4})?$`,\n\t\"MQ\": `^9[78]2\\d{2}$`,\n\t\"NC\": `^988\\d{2}$`,\n\t\"NE\": `^\\d{4}$`,\n\t\"VI\": `^008(([0-4]\\d)|(5[01]))([ \\-]\\d{4})?$`,\n\t\"VN\": `^[0-9]{1,6}$`,\n\t\"PF\": `^987\\d{2}$`,\n\t\"PG\": `^\\d{3}$`,\n\t\"PM\": `^9[78]5\\d{2}$`,\n\t\"PN\": `^PCRN 1ZZ$`,\n\t\"PW\": `^96940$`,\n\t\"RE\": `^9[78]4\\d{2}$`,\n\t\"SH\": `^(ASCN|STHL) 1ZZ$`,\n\t\"SJ\": `^\\d{4}$`,\n\t\"SO\": `^\\d{5}$`,\n\t\"SZ\": `^[HLMS]\\d{3}$`,\n\t\"TC\": `^TKCA 1ZZ$`,\n\t\"WF\": `^986\\d{2}$`,\n\t\"XK\": `^\\d{5}$`,\n\t\"YT\": `^976\\d{2}$`,\n}\n\nvar (\n\tpostcodeRegexInit sync.Once\n\tpostCodeRegexDict = map[string]*regexp.Regexp{}\n)\n\nfunc initPostcodes() {\n\tfor countryCode, pattern := range postCodePatternDict {\n\t\tpostCodeRegexDict[countryCode] = regexp.MustCompile(pattern)\n\t}\n}\n"
        },
        {
          "name": "regexes.go",
          "type": "blob",
          "size": 13.4638671875,
          "content": "package validator\n\nimport (\n\t\"regexp\"\n\t\"sync\"\n)\n\nconst (\n\talphaRegexString                 = \"^[a-zA-Z]+$\"\n\talphaNumericRegexString          = \"^[a-zA-Z0-9]+$\"\n\talphaUnicodeRegexString          = \"^[\\\\p{L}]+$\"\n\talphaUnicodeNumericRegexString   = \"^[\\\\p{L}\\\\p{N}]+$\"\n\tnumericRegexString               = \"^[-+]?[0-9]+(?:\\\\.[0-9]+)?$\"\n\tnumberRegexString                = \"^[0-9]+$\"\n\thexadecimalRegexString           = \"^(0[xX])?[0-9a-fA-F]+$\"\n\thexColorRegexString              = \"^#(?:[0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$\"\n\trgbRegexString                   = \"^rgb\\\\(\\\\s*(?:(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])|(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])%\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])%\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])%)\\\\s*\\\\)$\"\n\trgbaRegexString                  = \"^rgba\\\\(\\\\s*(?:(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])|(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])%\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])%\\\\s*,\\\\s*(?:0|[1-9]\\\\d?|1\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])%)\\\\s*,\\\\s*(?:(?:0.[1-9]*)|[01])\\\\s*\\\\)$\"\n\thslRegexString                   = \"^hsl\\\\(\\\\s*(?:0|[1-9]\\\\d?|[12]\\\\d\\\\d|3[0-5]\\\\d|360)\\\\s*,\\\\s*(?:(?:0|[1-9]\\\\d?|100)%)\\\\s*,\\\\s*(?:(?:0|[1-9]\\\\d?|100)%)\\\\s*\\\\)$\"\n\thslaRegexString                  = \"^hsla\\\\(\\\\s*(?:0|[1-9]\\\\d?|[12]\\\\d\\\\d|3[0-5]\\\\d|360)\\\\s*,\\\\s*(?:(?:0|[1-9]\\\\d?|100)%)\\\\s*,\\\\s*(?:(?:0|[1-9]\\\\d?|100)%)\\\\s*,\\\\s*(?:(?:0.[1-9]*)|[01])\\\\s*\\\\)$\"\n\temailRegexString                 = \"^(?:(?:(?:(?:[a-zA-Z]|\\\\d|[!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])+(?:\\\\.([a-zA-Z]|\\\\d|[!#\\\\$%&'\\\\*\\\\+\\\\-\\\\/=\\\\?\\\\^_`{\\\\|}~]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])+)*)|(?:(?:\\\\x22)(?:(?:(?:(?:\\\\x20|\\\\x09)*(?:\\\\x0d\\\\x0a))?(?:\\\\x20|\\\\x09)+)?(?:(?:[\\\\x01-\\\\x08\\\\x0b\\\\x0c\\\\x0e-\\\\x1f\\\\x7f]|\\\\x21|[\\\\x23-\\\\x5b]|[\\\\x5d-\\\\x7e]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])|(?:(?:[\\\\x01-\\\\x09\\\\x0b\\\\x0c\\\\x0d-\\\\x7f]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}]))))*(?:(?:(?:\\\\x20|\\\\x09)*(?:\\\\x0d\\\\x0a))?(\\\\x20|\\\\x09)+)?(?:\\\\x22))))@(?:(?:(?:[a-zA-Z]|\\\\d|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])|(?:(?:[a-zA-Z]|\\\\d|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])(?:[a-zA-Z]|\\\\d|-|\\\\.|~|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])*(?:[a-zA-Z]|\\\\d|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])))\\\\.)+(?:(?:[a-zA-Z]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])|(?:(?:[a-zA-Z]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])(?:[a-zA-Z]|\\\\d|-|\\\\.|~|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])*(?:[a-zA-Z]|[\\\\x{00A0}-\\\\x{D7FF}\\\\x{F900}-\\\\x{FDCF}\\\\x{FDF0}-\\\\x{FFEF}])))\\\\.?$\"\n\te164RegexString                  = \"^\\\\+[1-9]?[0-9]{7,14}$\"\n\tbase32RegexString                = \"^(?:[A-Z2-7]{8})*(?:[A-Z2-7]{2}={6}|[A-Z2-7]{4}={4}|[A-Z2-7]{5}={3}|[A-Z2-7]{7}=|[A-Z2-7]{8})$\"\n\tbase64RegexString                = \"^(?:[A-Za-z0-9+\\\\/]{4})*(?:[A-Za-z0-9+\\\\/]{2}==|[A-Za-z0-9+\\\\/]{3}=|[A-Za-z0-9+\\\\/]{4})$\"\n\tbase64URLRegexString             = \"^(?:[A-Za-z0-9-_]{4})*(?:[A-Za-z0-9-_]{2}==|[A-Za-z0-9-_]{3}=|[A-Za-z0-9-_]{4})$\"\n\tbase64RawURLRegexString          = \"^(?:[A-Za-z0-9-_]{4})*(?:[A-Za-z0-9-_]{2,4})$\"\n\tiSBN10RegexString                = \"^(?:[0-9]{9}X|[0-9]{10})$\"\n\tiSBN13RegexString                = \"^(?:(?:97(?:8|9))[0-9]{10})$\"\n\tiSSNRegexString                  = \"^(?:[0-9]{4}-[0-9]{3}[0-9X])$\"\n\tuUID3RegexString                 = \"^[0-9a-f]{8}-[0-9a-f]{4}-3[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$\"\n\tuUID4RegexString                 = \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"\n\tuUID5RegexString                 = \"^[0-9a-f]{8}-[0-9a-f]{4}-5[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"\n\tuUIDRegexString                  = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\"\n\tuUID3RFC4122RegexString          = \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-3[0-9a-fA-F]{3}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\"\n\tuUID4RFC4122RegexString          = \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$\"\n\tuUID5RFC4122RegexString          = \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-5[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$\"\n\tuUIDRFC4122RegexString           = \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\"\n\tuLIDRegexString                  = \"^(?i)[A-HJKMNP-TV-Z0-9]{26}$\"\n\tmd4RegexString                   = \"^[0-9a-f]{32}$\"\n\tmd5RegexString                   = \"^[0-9a-f]{32}$\"\n\tsha256RegexString                = \"^[0-9a-f]{64}$\"\n\tsha384RegexString                = \"^[0-9a-f]{96}$\"\n\tsha512RegexString                = \"^[0-9a-f]{128}$\"\n\tripemd128RegexString             = \"^[0-9a-f]{32}$\"\n\tripemd160RegexString             = \"^[0-9a-f]{40}$\"\n\ttiger128RegexString              = \"^[0-9a-f]{32}$\"\n\ttiger160RegexString              = \"^[0-9a-f]{40}$\"\n\ttiger192RegexString              = \"^[0-9a-f]{48}$\"\n\taSCIIRegexString                 = \"^[\\x00-\\x7F]*$\"\n\tprintableASCIIRegexString        = \"^[\\x20-\\x7E]*$\"\n\tmultibyteRegexString             = \"[^\\x00-\\x7F]\"\n\tdataURIRegexString               = `^data:((?:\\w+\\/(?:([^;]|;[^;]).)+)?)`\n\tlatitudeRegexString              = \"^[-+]?([1-8]?\\\\d(\\\\.\\\\d+)?|90(\\\\.0+)?)$\"\n\tlongitudeRegexString             = \"^[-+]?(180(\\\\.0+)?|((1[0-7]\\\\d)|([1-9]?\\\\d))(\\\\.\\\\d+)?)$\"\n\tsSNRegexString                   = `^[0-9]{3}[ -]?(0[1-9]|[1-9][0-9])[ -]?([1-9][0-9]{3}|[0-9][1-9][0-9]{2}|[0-9]{2}[1-9][0-9]|[0-9]{3}[1-9])$`\n\thostnameRegexStringRFC952        = `^[a-zA-Z]([a-zA-Z0-9\\-]+[\\.]?)*[a-zA-Z0-9]$`                                                                   // https://tools.ietf.org/html/rfc952\n\thostnameRegexStringRFC1123       = `^([a-zA-Z0-9]{1}[a-zA-Z0-9-]{0,62}){1}(\\.[a-zA-Z0-9]{1}[a-zA-Z0-9-]{0,62})*?$`                                 // accepts hostname starting with a digit https://tools.ietf.org/html/rfc1123\n\tfqdnRegexStringRFC1123           = `^([a-zA-Z0-9]{1}[a-zA-Z0-9-]{0,62})(\\.[a-zA-Z0-9]{1}[a-zA-Z0-9-]{0,62})*?(\\.[a-zA-Z]{1}[a-zA-Z0-9]{0,62})\\.?$` // same as hostnameRegexStringRFC1123 but must contain a non numerical TLD (possibly ending with '.')\n\tbtcAddressRegexString            = `^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$`                                                                             // bitcoin address\n\tbtcAddressUpperRegexStringBech32 = `^BC1[02-9AC-HJ-NP-Z]{7,76}$`                                                                                   // bitcoin bech32 address https://en.bitcoin.it/wiki/Bech32\n\tbtcAddressLowerRegexStringBech32 = `^bc1[02-9ac-hj-np-z]{7,76}$`                                                                                   // bitcoin bech32 address https://en.bitcoin.it/wiki/Bech32\n\tethAddressRegexString            = `^0x[0-9a-fA-F]{40}$`\n\tethAddressUpperRegexString       = `^0x[0-9A-F]{40}$`\n\tethAddressLowerRegexString       = `^0x[0-9a-f]{40}$`\n\tuRLEncodedRegexString            = `^(?:[^%]|%[0-9A-Fa-f]{2})*$`\n\thTMLEncodedRegexString           = `&#[x]?([0-9a-fA-F]{2})|(&gt)|(&lt)|(&quot)|(&amp)+[;]?`\n\thTMLRegexString                  = `<[/]?([a-zA-Z]+).*?>`\n\tjWTRegexString                   = \"^[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]*$\"\n\tsplitParamsRegexString           = `'[^']*'|\\S+`\n\tbicRegexString                   = `^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$`\n\tsemverRegexString                = `^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$` // numbered capture groups https://semver.org/\n\tdnsRegexStringRFC1035Label       = \"^[a-z]([-a-z0-9]*[a-z0-9]){0,62}$\"\n\tcveRegexString                   = `^CVE-(1999|2\\d{3})-(0[^0]\\d{2}|0\\d[^0]\\d{1}|0\\d{2}[^0]|[1-9]{1}\\d{3,})$` // CVE Format Id https://cve.mitre.org/cve/identifiers/syntaxchange.html\n\tmongodbIdRegexString             = \"^[a-f\\\\d]{24}$\"\n\tmongodbConnStringRegexString     = \"^mongodb(\\\\+srv)?:\\\\/\\\\/(([a-zA-Z\\\\d]+):([a-zA-Z\\\\d$:\\\\/?#\\\\[\\\\]@]+)@)?(([a-z\\\\d.-]+)(:[\\\\d]+)?)((,(([a-z\\\\d.-]+)(:(\\\\d+))?))*)?(\\\\/[a-zA-Z-_]{1,64})?(\\\\?(([a-zA-Z]+)=([a-zA-Z\\\\d]+))(&(([a-zA-Z\\\\d]+)=([a-zA-Z\\\\d]+))?)*)?$\"\n\tcronRegexString                  = `(@(annually|yearly|monthly|weekly|daily|hourly|reboot))|(@every (\\d+(ns|us|µs|ms|s|m|h))+)|((((\\d+,)+\\d+|((\\*|\\d+)(\\/|-)\\d+)|\\d+|\\*) ?){5,7})`\n\tspicedbIDRegexString             = `^(([a-zA-Z0-9/_|\\-=+]{1,})|\\*)$`\n\tspicedbPermissionRegexString     = \"^([a-z][a-z0-9_]{1,62}[a-z0-9])?$\"\n\tspicedbTypeRegexString           = \"^([a-z][a-z0-9_]{1,61}[a-z0-9]/)?[a-z][a-z0-9_]{1,62}[a-z0-9]$\"\n)\n\nfunc lazyRegexCompile(str string) func() *regexp.Regexp {\n\tvar regex *regexp.Regexp\n\tvar once sync.Once\n\treturn func() *regexp.Regexp {\n\t\tonce.Do(func() {\n\t\t\tregex = regexp.MustCompile(str)\n\t\t})\n\t\treturn regex\n\t}\n}\n\nvar (\n\talphaRegex                 = lazyRegexCompile(alphaRegexString)\n\talphaNumericRegex          = lazyRegexCompile(alphaNumericRegexString)\n\talphaUnicodeRegex          = lazyRegexCompile(alphaUnicodeRegexString)\n\talphaUnicodeNumericRegex   = lazyRegexCompile(alphaUnicodeNumericRegexString)\n\tnumericRegex               = lazyRegexCompile(numericRegexString)\n\tnumberRegex                = lazyRegexCompile(numberRegexString)\n\thexadecimalRegex           = lazyRegexCompile(hexadecimalRegexString)\n\thexColorRegex              = lazyRegexCompile(hexColorRegexString)\n\trgbRegex                   = lazyRegexCompile(rgbRegexString)\n\trgbaRegex                  = lazyRegexCompile(rgbaRegexString)\n\thslRegex                   = lazyRegexCompile(hslRegexString)\n\thslaRegex                  = lazyRegexCompile(hslaRegexString)\n\te164Regex                  = lazyRegexCompile(e164RegexString)\n\temailRegex                 = lazyRegexCompile(emailRegexString)\n\tbase32Regex                = lazyRegexCompile(base32RegexString)\n\tbase64Regex                = lazyRegexCompile(base64RegexString)\n\tbase64URLRegex             = lazyRegexCompile(base64URLRegexString)\n\tbase64RawURLRegex          = lazyRegexCompile(base64RawURLRegexString)\n\tiSBN10Regex                = lazyRegexCompile(iSBN10RegexString)\n\tiSBN13Regex                = lazyRegexCompile(iSBN13RegexString)\n\tiSSNRegex                  = lazyRegexCompile(iSSNRegexString)\n\tuUID3Regex                 = lazyRegexCompile(uUID3RegexString)\n\tuUID4Regex                 = lazyRegexCompile(uUID4RegexString)\n\tuUID5Regex                 = lazyRegexCompile(uUID5RegexString)\n\tuUIDRegex                  = lazyRegexCompile(uUIDRegexString)\n\tuUID3RFC4122Regex          = lazyRegexCompile(uUID3RFC4122RegexString)\n\tuUID4RFC4122Regex          = lazyRegexCompile(uUID4RFC4122RegexString)\n\tuUID5RFC4122Regex          = lazyRegexCompile(uUID5RFC4122RegexString)\n\tuUIDRFC4122Regex           = lazyRegexCompile(uUIDRFC4122RegexString)\n\tuLIDRegex                  = lazyRegexCompile(uLIDRegexString)\n\tmd4Regex                   = lazyRegexCompile(md4RegexString)\n\tmd5Regex                   = lazyRegexCompile(md5RegexString)\n\tsha256Regex                = lazyRegexCompile(sha256RegexString)\n\tsha384Regex                = lazyRegexCompile(sha384RegexString)\n\tsha512Regex                = lazyRegexCompile(sha512RegexString)\n\tripemd128Regex             = lazyRegexCompile(ripemd128RegexString)\n\tripemd160Regex             = lazyRegexCompile(ripemd160RegexString)\n\ttiger128Regex              = lazyRegexCompile(tiger128RegexString)\n\ttiger160Regex              = lazyRegexCompile(tiger160RegexString)\n\ttiger192Regex              = lazyRegexCompile(tiger192RegexString)\n\taSCIIRegex                 = lazyRegexCompile(aSCIIRegexString)\n\tprintableASCIIRegex        = lazyRegexCompile(printableASCIIRegexString)\n\tmultibyteRegex             = lazyRegexCompile(multibyteRegexString)\n\tdataURIRegex               = lazyRegexCompile(dataURIRegexString)\n\tlatitudeRegex              = lazyRegexCompile(latitudeRegexString)\n\tlongitudeRegex             = lazyRegexCompile(longitudeRegexString)\n\tsSNRegex                   = lazyRegexCompile(sSNRegexString)\n\thostnameRegexRFC952        = lazyRegexCompile(hostnameRegexStringRFC952)\n\thostnameRegexRFC1123       = lazyRegexCompile(hostnameRegexStringRFC1123)\n\tfqdnRegexRFC1123           = lazyRegexCompile(fqdnRegexStringRFC1123)\n\tbtcAddressRegex            = lazyRegexCompile(btcAddressRegexString)\n\tbtcUpperAddressRegexBech32 = lazyRegexCompile(btcAddressUpperRegexStringBech32)\n\tbtcLowerAddressRegexBech32 = lazyRegexCompile(btcAddressLowerRegexStringBech32)\n\tethAddressRegex            = lazyRegexCompile(ethAddressRegexString)\n\tuRLEncodedRegex            = lazyRegexCompile(uRLEncodedRegexString)\n\thTMLEncodedRegex           = lazyRegexCompile(hTMLEncodedRegexString)\n\thTMLRegex                  = lazyRegexCompile(hTMLRegexString)\n\tjWTRegex                   = lazyRegexCompile(jWTRegexString)\n\tsplitParamsRegex           = lazyRegexCompile(splitParamsRegexString)\n\tbicRegex                   = lazyRegexCompile(bicRegexString)\n\tsemverRegex                = lazyRegexCompile(semverRegexString)\n\tdnsRegexRFC1035Label       = lazyRegexCompile(dnsRegexStringRFC1035Label)\n\tcveRegex                   = lazyRegexCompile(cveRegexString)\n\tmongodbIdRegex             = lazyRegexCompile(mongodbIdRegexString)\n\tmongodbConnectionRegex     = lazyRegexCompile(mongodbConnStringRegexString)\n\tcronRegex                  = lazyRegexCompile(cronRegexString)\n\tspicedbIDRegex             = lazyRegexCompile(spicedbIDRegexString)\n\tspicedbPermissionRegex     = lazyRegexCompile(spicedbPermissionRegexString)\n\tspicedbTypeRegex           = lazyRegexCompile(spicedbTypeRegexString)\n)\n"
        },
        {
          "name": "struct_level.go",
          "type": "blob",
          "size": 5.3359375,
          "content": "package validator\n\nimport (\n\t\"context\"\n\t\"reflect\"\n)\n\n// StructLevelFunc accepts all values needed for struct level validation\ntype StructLevelFunc func(sl StructLevel)\n\n// StructLevelFuncCtx accepts all values needed for struct level validation\n// but also allows passing of contextual validation information via context.Context.\ntype StructLevelFuncCtx func(ctx context.Context, sl StructLevel)\n\n// wrapStructLevelFunc wraps normal StructLevelFunc makes it compatible with StructLevelFuncCtx\nfunc wrapStructLevelFunc(fn StructLevelFunc) StructLevelFuncCtx {\n\treturn func(ctx context.Context, sl StructLevel) {\n\t\tfn(sl)\n\t}\n}\n\n// StructLevel contains all the information and helper functions\n// to validate a struct\ntype StructLevel interface {\n\n\t// Validator returns the main validation object, in case one wants to call validations internally.\n\t// this is so you don't have to use anonymous functions to get access to the validate\n\t// instance.\n\tValidator() *Validate\n\n\t// Top returns the top level struct, if any\n\tTop() reflect.Value\n\n\t// Parent returns the current fields parent struct, if any\n\tParent() reflect.Value\n\n\t// Current returns the current struct.\n\tCurrent() reflect.Value\n\n\t// ExtractType gets the actual underlying type of field value.\n\t// It will dive into pointers, customTypes and return you the\n\t// underlying value and its kind.\n\tExtractType(field reflect.Value) (value reflect.Value, kind reflect.Kind, nullable bool)\n\n\t// ReportError reports an error just by passing the field and tag information\n\t//\n\t// NOTES:\n\t//\n\t// fieldName and altName get appended to the existing namespace that\n\t// validator is on. e.g. pass 'FirstName' or 'Names[0]' depending\n\t// on the nesting\n\t//\n\t// tag can be an existing validation tag or just something you make up\n\t// and process on the flip side it's up to you.\n\tReportError(field interface{}, fieldName, structFieldName string, tag, param string)\n\n\t// ReportValidationErrors reports an error just by passing ValidationErrors\n\t//\n\t// NOTES:\n\t//\n\t// relativeNamespace and relativeActualNamespace get appended to the\n\t// existing namespace that validator is on.\n\t// e.g. pass 'User.FirstName' or 'Users[0].FirstName' depending\n\t// on the nesting. most of the time they will be blank, unless you validate\n\t// at a level lower the current field depth\n\tReportValidationErrors(relativeNamespace, relativeActualNamespace string, errs ValidationErrors)\n}\n\nvar _ StructLevel = new(validate)\n\n// Top returns the top level struct\n//\n// NOTE: this can be the same as the current struct being validated\n// if not is a nested struct.\n//\n// this is only called when within Struct and Field Level validation and\n// should not be relied upon for an accurate value otherwise.\nfunc (v *validate) Top() reflect.Value {\n\treturn v.top\n}\n\n// Parent returns the current structs parent\n//\n// NOTE: this can be the same as the current struct being validated\n// if not is a nested struct.\n//\n// this is only called when within Struct and Field Level validation and\n// should not be relied upon for an accurate value otherwise.\nfunc (v *validate) Parent() reflect.Value {\n\treturn v.slflParent\n}\n\n// Current returns the current struct.\nfunc (v *validate) Current() reflect.Value {\n\treturn v.slCurrent\n}\n\n// Validator returns the main validation object, in case one want to call validations internally.\nfunc (v *validate) Validator() *Validate {\n\treturn v.v\n}\n\n// ExtractType gets the actual underlying type of field value.\nfunc (v *validate) ExtractType(field reflect.Value) (reflect.Value, reflect.Kind, bool) {\n\treturn v.extractTypeInternal(field, false)\n}\n\n// ReportError reports an error just by passing the field and tag information\nfunc (v *validate) ReportError(field interface{}, fieldName, structFieldName, tag, param string) {\n\n\tfv, kind, _ := v.extractTypeInternal(reflect.ValueOf(field), false)\n\n\tif len(structFieldName) == 0 {\n\t\tstructFieldName = fieldName\n\t}\n\n\tv.str1 = string(append(v.ns, fieldName...))\n\n\tif v.v.hasTagNameFunc || fieldName != structFieldName {\n\t\tv.str2 = string(append(v.actualNs, structFieldName...))\n\t} else {\n\t\tv.str2 = v.str1\n\t}\n\n\tif kind == reflect.Invalid {\n\n\t\tv.errs = append(v.errs,\n\t\t\t&fieldError{\n\t\t\t\tv:              v.v,\n\t\t\t\ttag:            tag,\n\t\t\t\tactualTag:      tag,\n\t\t\t\tns:             v.str1,\n\t\t\t\tstructNs:       v.str2,\n\t\t\t\tfieldLen:       uint8(len(fieldName)),\n\t\t\t\tstructfieldLen: uint8(len(structFieldName)),\n\t\t\t\tparam:          param,\n\t\t\t\tkind:           kind,\n\t\t\t},\n\t\t)\n\t\treturn\n\t}\n\n\tv.errs = append(v.errs,\n\t\t&fieldError{\n\t\t\tv:              v.v,\n\t\t\ttag:            tag,\n\t\t\tactualTag:      tag,\n\t\t\tns:             v.str1,\n\t\t\tstructNs:       v.str2,\n\t\t\tfieldLen:       uint8(len(fieldName)),\n\t\t\tstructfieldLen: uint8(len(structFieldName)),\n\t\t\tvalue:          fv.Interface(),\n\t\t\tparam:          param,\n\t\t\tkind:           kind,\n\t\t\ttyp:            fv.Type(),\n\t\t},\n\t)\n}\n\n// ReportValidationErrors reports ValidationErrors obtained from running validations within the Struct Level validation.\n//\n// NOTE: this function prepends the current namespace to the relative ones.\nfunc (v *validate) ReportValidationErrors(relativeNamespace, relativeStructNamespace string, errs ValidationErrors) {\n\n\tvar err *fieldError\n\n\tfor i := 0; i < len(errs); i++ {\n\n\t\terr = errs[i].(*fieldError)\n\t\terr.ns = string(append(append(v.ns, relativeNamespace...), err.ns...))\n\t\terr.structNs = string(append(append(v.actualNs, relativeStructNamespace...), err.structNs...))\n\n\t\tv.errs = append(v.errs, err)\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "translations.go",
          "type": "blob",
          "size": 0.4150390625,
          "content": "package validator\n\nimport ut \"github.com/go-playground/universal-translator\"\n\n// TranslationFunc is the function type used to register or override\n// custom translations\ntype TranslationFunc func(ut ut.Translator, fe FieldError) string\n\n// RegisterTranslationsFunc allows for registering of translations\n// for a 'ut.Translator' for use within the 'TranslationFunc'\ntype RegisterTranslationsFunc func(ut ut.Translator) error\n"
        },
        {
          "name": "translations",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 7.1484375,
          "content": "package validator\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// extractTypeInternal gets the actual underlying type of field value.\n// It will dive into pointers, customTypes and return you the\n// underlying value and it's kind.\nfunc (v *validate) extractTypeInternal(current reflect.Value, nullable bool) (reflect.Value, reflect.Kind, bool) {\n\nBEGIN:\n\tswitch current.Kind() {\n\tcase reflect.Ptr:\n\n\t\tnullable = true\n\n\t\tif current.IsNil() {\n\t\t\treturn current, reflect.Ptr, nullable\n\t\t}\n\n\t\tcurrent = current.Elem()\n\t\tgoto BEGIN\n\n\tcase reflect.Interface:\n\n\t\tnullable = true\n\n\t\tif current.IsNil() {\n\t\t\treturn current, reflect.Interface, nullable\n\t\t}\n\n\t\tcurrent = current.Elem()\n\t\tgoto BEGIN\n\n\tcase reflect.Invalid:\n\t\treturn current, reflect.Invalid, nullable\n\n\tdefault:\n\n\t\tif v.v.hasCustomFuncs {\n\n\t\t\tif fn, ok := v.v.customFuncs[current.Type()]; ok {\n\t\t\t\tcurrent = reflect.ValueOf(fn(current))\n\t\t\t\tgoto BEGIN\n\t\t\t}\n\t\t}\n\n\t\treturn current, current.Kind(), nullable\n\t}\n}\n\n// getStructFieldOKInternal traverses a struct to retrieve a specific field denoted by the provided namespace and\n// returns the field, field kind and whether is was successful in retrieving the field at all.\n//\n// NOTE: when not successful ok will be false, this can happen when a nested struct is nil and so the field\n// could not be retrieved because it didn't exist.\nfunc (v *validate) getStructFieldOKInternal(val reflect.Value, namespace string) (current reflect.Value, kind reflect.Kind, nullable bool, found bool) {\n\nBEGIN:\n\tcurrent, kind, nullable = v.ExtractType(val)\n\tif kind == reflect.Invalid {\n\t\treturn\n\t}\n\n\tif namespace == \"\" {\n\t\tfound = true\n\t\treturn\n\t}\n\n\tswitch kind {\n\n\tcase reflect.Ptr, reflect.Interface:\n\t\treturn\n\n\tcase reflect.Struct:\n\n\t\ttyp := current.Type()\n\t\tfld := namespace\n\t\tvar ns string\n\n\t\tif !typ.ConvertibleTo(timeType) {\n\n\t\t\tidx := strings.Index(namespace, namespaceSeparator)\n\n\t\t\tif idx != -1 {\n\t\t\t\tfld = namespace[:idx]\n\t\t\t\tns = namespace[idx+1:]\n\t\t\t} else {\n\t\t\t\tns = \"\"\n\t\t\t}\n\n\t\t\tbracketIdx := strings.Index(fld, leftBracket)\n\t\t\tif bracketIdx != -1 {\n\t\t\t\tfld = fld[:bracketIdx]\n\n\t\t\t\tns = namespace[bracketIdx:]\n\t\t\t}\n\n\t\t\tval = current.FieldByName(fld)\n\t\t\tnamespace = ns\n\t\t\tgoto BEGIN\n\t\t}\n\n\tcase reflect.Array, reflect.Slice:\n\t\tidx := strings.Index(namespace, leftBracket)\n\t\tidx2 := strings.Index(namespace, rightBracket)\n\n\t\tarrIdx, _ := strconv.Atoi(namespace[idx+1 : idx2])\n\n\t\tif arrIdx >= current.Len() {\n\t\t\treturn\n\t\t}\n\n\t\tstartIdx := idx2 + 1\n\n\t\tif startIdx < len(namespace) {\n\t\t\tif namespace[startIdx:startIdx+1] == namespaceSeparator {\n\t\t\t\tstartIdx++\n\t\t\t}\n\t\t}\n\n\t\tval = current.Index(arrIdx)\n\t\tnamespace = namespace[startIdx:]\n\t\tgoto BEGIN\n\n\tcase reflect.Map:\n\t\tidx := strings.Index(namespace, leftBracket) + 1\n\t\tidx2 := strings.Index(namespace, rightBracket)\n\n\t\tendIdx := idx2\n\n\t\tif endIdx+1 < len(namespace) {\n\t\t\tif namespace[endIdx+1:endIdx+2] == namespaceSeparator {\n\t\t\t\tendIdx++\n\t\t\t}\n\t\t}\n\n\t\tkey := namespace[idx:idx2]\n\n\t\tswitch current.Type().Key().Kind() {\n\t\tcase reflect.Int:\n\t\t\ti, _ := strconv.Atoi(key)\n\t\t\tval = current.MapIndex(reflect.ValueOf(i))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Int8:\n\t\t\ti, _ := strconv.ParseInt(key, 10, 8)\n\t\t\tval = current.MapIndex(reflect.ValueOf(int8(i)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Int16:\n\t\t\ti, _ := strconv.ParseInt(key, 10, 16)\n\t\t\tval = current.MapIndex(reflect.ValueOf(int16(i)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Int32:\n\t\t\ti, _ := strconv.ParseInt(key, 10, 32)\n\t\t\tval = current.MapIndex(reflect.ValueOf(int32(i)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Int64:\n\t\t\ti, _ := strconv.ParseInt(key, 10, 64)\n\t\t\tval = current.MapIndex(reflect.ValueOf(i))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Uint:\n\t\t\ti, _ := strconv.ParseUint(key, 10, 0)\n\t\t\tval = current.MapIndex(reflect.ValueOf(uint(i)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Uint8:\n\t\t\ti, _ := strconv.ParseUint(key, 10, 8)\n\t\t\tval = current.MapIndex(reflect.ValueOf(uint8(i)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Uint16:\n\t\t\ti, _ := strconv.ParseUint(key, 10, 16)\n\t\t\tval = current.MapIndex(reflect.ValueOf(uint16(i)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Uint32:\n\t\t\ti, _ := strconv.ParseUint(key, 10, 32)\n\t\t\tval = current.MapIndex(reflect.ValueOf(uint32(i)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Uint64:\n\t\t\ti, _ := strconv.ParseUint(key, 10, 64)\n\t\t\tval = current.MapIndex(reflect.ValueOf(i))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Float32:\n\t\t\tf, _ := strconv.ParseFloat(key, 32)\n\t\t\tval = current.MapIndex(reflect.ValueOf(float32(f)))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Float64:\n\t\t\tf, _ := strconv.ParseFloat(key, 64)\n\t\t\tval = current.MapIndex(reflect.ValueOf(f))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\tcase reflect.Bool:\n\t\t\tb, _ := strconv.ParseBool(key)\n\t\t\tval = current.MapIndex(reflect.ValueOf(b))\n\t\t\tnamespace = namespace[endIdx+1:]\n\n\t\t// reflect.Type = string\n\t\tdefault:\n\t\t\tval = current.MapIndex(reflect.ValueOf(key))\n\t\t\tnamespace = namespace[endIdx+1:]\n\t\t}\n\n\t\tgoto BEGIN\n\t}\n\n\t// if got here there was more namespace, cannot go any deeper\n\tpanic(\"Invalid field namespace\")\n}\n\n// asInt returns the parameter as a int64\n// or panics if it can't convert\nfunc asInt(param string) int64 {\n\ti, err := strconv.ParseInt(param, 0, 64)\n\tpanicIf(err)\n\n\treturn i\n}\n\n// asIntFromTimeDuration parses param as time.Duration and returns it as int64\n// or panics on error.\nfunc asIntFromTimeDuration(param string) int64 {\n\td, err := time.ParseDuration(param)\n\tif err != nil {\n\t\t// attempt parsing as an integer assuming nanosecond precision\n\t\treturn asInt(param)\n\t}\n\treturn int64(d)\n}\n\n// asIntFromType calls the proper function to parse param as int64,\n// given a field's Type t.\nfunc asIntFromType(t reflect.Type, param string) int64 {\n\tswitch t {\n\tcase timeDurationType:\n\t\treturn asIntFromTimeDuration(param)\n\tdefault:\n\t\treturn asInt(param)\n\t}\n}\n\n// asUint returns the parameter as a uint64\n// or panics if it can't convert\nfunc asUint(param string) uint64 {\n\n\ti, err := strconv.ParseUint(param, 0, 64)\n\tpanicIf(err)\n\n\treturn i\n}\n\n// asFloat64 returns the parameter as a float64\n// or panics if it can't convert\nfunc asFloat64(param string) float64 {\n\ti, err := strconv.ParseFloat(param, 64)\n\tpanicIf(err)\n\treturn i\n}\n\n// asFloat32 returns the parameter as a float32\n// or panics if it can't convert\nfunc asFloat32(param string) float64 {\n\ti, err := strconv.ParseFloat(param, 32)\n\tpanicIf(err)\n\treturn i\n}\n\n// asBool returns the parameter as a bool\n// or panics if it can't convert\nfunc asBool(param string) bool {\n\n\ti, err := strconv.ParseBool(param)\n\tpanicIf(err)\n\n\treturn i\n}\n\nfunc panicIf(err error) {\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n}\n\n// Checks if field value matches regex. If fl.Field can be cast to Stringer, it uses the Stringer interfaces\n// String() return value. Otherwise, it uses fl.Field's String() value.\nfunc fieldMatchesRegexByStringerValOrString(regexFn func() *regexp.Regexp, fl FieldLevel) bool {\n\tregex := regexFn()\n\tswitch fl.Field().Kind() {\n\tcase reflect.String:\n\t\treturn regex.MatchString(fl.Field().String())\n\tdefault:\n\t\tif stringer, ok := fl.Field().Interface().(fmt.Stringer); ok {\n\t\t\treturn regex.MatchString(stringer.String())\n\t\t} else {\n\t\t\treturn regex.MatchString(fl.Field().String())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "validator.go",
          "type": "blob",
          "size": 12.3701171875,
          "content": "package validator\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"unsafe\"\n)\n\n// per validate construct\ntype validate struct {\n\tv              *Validate\n\ttop            reflect.Value\n\tns             []byte\n\tactualNs       []byte\n\terrs           ValidationErrors\n\tincludeExclude map[string]struct{} // reset only if StructPartial or StructExcept are called, no need otherwise\n\tffn            FilterFunc\n\tslflParent     reflect.Value // StructLevel & FieldLevel\n\tslCurrent      reflect.Value // StructLevel & FieldLevel\n\tflField        reflect.Value // StructLevel & FieldLevel\n\tcf             *cField       // StructLevel & FieldLevel\n\tct             *cTag         // StructLevel & FieldLevel\n\tmisc           []byte        // misc reusable\n\tstr1           string        // misc reusable\n\tstr2           string        // misc reusable\n\tfldIsPointer   bool          // StructLevel & FieldLevel\n\tisPartial      bool\n\thasExcludes    bool\n}\n\n// parent and current will be the same the first run of validateStruct\nfunc (v *validate) validateStruct(ctx context.Context, parent reflect.Value, current reflect.Value, typ reflect.Type, ns []byte, structNs []byte, ct *cTag) {\n\n\tcs, ok := v.v.structCache.Get(typ)\n\tif !ok {\n\t\tcs = v.v.extractStructCache(current, typ.Name())\n\t}\n\n\tif len(ns) == 0 && len(cs.name) != 0 {\n\n\t\tns = append(ns, cs.name...)\n\t\tns = append(ns, '.')\n\n\t\tstructNs = append(structNs, cs.name...)\n\t\tstructNs = append(structNs, '.')\n\t}\n\n\t// ct is nil on top level struct, and structs as fields that have no tag info\n\t// so if nil or if not nil and the structonly tag isn't present\n\tif ct == nil || ct.typeof != typeStructOnly {\n\n\t\tvar f *cField\n\n\t\tfor i := 0; i < len(cs.fields); i++ {\n\n\t\t\tf = cs.fields[i]\n\n\t\t\tif v.isPartial {\n\n\t\t\t\tif v.ffn != nil {\n\t\t\t\t\t// used with StructFiltered\n\t\t\t\t\tif v.ffn(append(structNs, f.name...)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\t// used with StructPartial & StructExcept\n\t\t\t\t\t_, ok = v.includeExclude[string(append(structNs, f.name...))]\n\n\t\t\t\t\tif (ok && v.hasExcludes) || (!ok && !v.hasExcludes) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tv.traverseField(ctx, current, current.Field(f.idx), ns, structNs, f, f.cTags)\n\t\t}\n\t}\n\n\t// check if any struct level validations, after all field validations already checked.\n\t// first iteration will have no info about nostructlevel tag, and is checked prior to\n\t// calling the next iteration of validateStruct called from traverseField.\n\tif cs.fn != nil {\n\n\t\tv.slflParent = parent\n\t\tv.slCurrent = current\n\t\tv.ns = ns\n\t\tv.actualNs = structNs\n\n\t\tcs.fn(ctx, v)\n\t}\n}\n\n// traverseField validates any field, be it a struct or single field, ensures it's validity and passes it along to be validated via it's tag options\nfunc (v *validate) traverseField(ctx context.Context, parent reflect.Value, current reflect.Value, ns []byte, structNs []byte, cf *cField, ct *cTag) {\n\tvar typ reflect.Type\n\tvar kind reflect.Kind\n\n\tcurrent, kind, v.fldIsPointer = v.extractTypeInternal(current, false)\n\n\tvar isNestedStruct bool\n\n\tswitch kind {\n\tcase reflect.Ptr, reflect.Interface, reflect.Invalid:\n\n\t\tif ct == nil {\n\t\t\treturn\n\t\t}\n\n\t\tif ct.typeof == typeOmitEmpty || ct.typeof == typeIsDefault {\n\t\t\treturn\n\t\t}\n\n\t\tif ct.typeof == typeOmitNil && (kind != reflect.Invalid && current.IsNil()) {\n\t\t\treturn\n\t\t}\n\n\t\tif ct.hasTag {\n\t\t\tif kind == reflect.Invalid {\n\t\t\t\tv.str1 = string(append(ns, cf.altName...))\n\t\t\t\tif v.v.hasTagNameFunc {\n\t\t\t\t\tv.str2 = string(append(structNs, cf.name...))\n\t\t\t\t} else {\n\t\t\t\t\tv.str2 = v.str1\n\t\t\t\t}\n\t\t\t\tv.errs = append(v.errs,\n\t\t\t\t\t&fieldError{\n\t\t\t\t\t\tv:              v.v,\n\t\t\t\t\t\ttag:            ct.aliasTag,\n\t\t\t\t\t\tactualTag:      ct.tag,\n\t\t\t\t\t\tns:             v.str1,\n\t\t\t\t\t\tstructNs:       v.str2,\n\t\t\t\t\t\tfieldLen:       uint8(len(cf.altName)),\n\t\t\t\t\t\tstructfieldLen: uint8(len(cf.name)),\n\t\t\t\t\t\tparam:          ct.param,\n\t\t\t\t\t\tkind:           kind,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv.str1 = string(append(ns, cf.altName...))\n\t\t\tif v.v.hasTagNameFunc {\n\t\t\t\tv.str2 = string(append(structNs, cf.name...))\n\t\t\t} else {\n\t\t\t\tv.str2 = v.str1\n\t\t\t}\n\t\t\tif !ct.runValidationWhenNil {\n\t\t\t\tv.errs = append(v.errs,\n\t\t\t\t\t&fieldError{\n\t\t\t\t\t\tv:              v.v,\n\t\t\t\t\t\ttag:            ct.aliasTag,\n\t\t\t\t\t\tactualTag:      ct.tag,\n\t\t\t\t\t\tns:             v.str1,\n\t\t\t\t\t\tstructNs:       v.str2,\n\t\t\t\t\t\tfieldLen:       uint8(len(cf.altName)),\n\t\t\t\t\t\tstructfieldLen: uint8(len(cf.name)),\n\t\t\t\t\t\tvalue:          getValue(current),\n\t\t\t\t\t\tparam:          ct.param,\n\t\t\t\t\t\tkind:           kind,\n\t\t\t\t\t\ttyp:            current.Type(),\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif kind == reflect.Invalid {\n\t\t\treturn\n\t\t}\n\n\tcase reflect.Struct:\n\t\tisNestedStruct = !current.Type().ConvertibleTo(timeType)\n\t\t// For backward compatibility before struct level validation tags were supported\n\t\t// as there were a number of projects relying on `required` not failing on non-pointer\n\t\t// structs. Since it's basically nonsensical to use `required` with a non-pointer struct\n\t\t// are explicitly skipping the required validation for it. This WILL be removed in the\n\t\t// next major version.\n\t\tif isNestedStruct && !v.v.requiredStructEnabled && ct != nil && ct.tag == requiredTag {\n\t\t\tct = ct.next\n\t\t}\n\t}\n\n\ttyp = current.Type()\n\nOUTER:\n\tfor {\n\t\tif ct == nil || !ct.hasTag || (isNestedStruct && len(cf.name) == 0) {\n\t\t\t// isNestedStruct check here\n\t\t\tif isNestedStruct {\n\t\t\t\t// if len == 0 then validating using 'Var' or 'VarWithValue'\n\t\t\t\t// Var - doesn't make much sense to do it that way, should call 'Struct', but no harm...\n\t\t\t\t// VarWithField - this allows for validating against each field within the struct against a specific value\n\t\t\t\t//                pretty handy in certain situations\n\t\t\t\tif len(cf.name) > 0 {\n\t\t\t\t\tns = append(append(ns, cf.altName...), '.')\n\t\t\t\t\tstructNs = append(append(structNs, cf.name...), '.')\n\t\t\t\t}\n\n\t\t\t\tv.validateStruct(ctx, parent, current, typ, ns, structNs, ct)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tswitch ct.typeof {\n\t\tcase typeNoStructLevel:\n\t\t\treturn\n\n\t\tcase typeStructOnly:\n\t\t\tif isNestedStruct {\n\t\t\t\t// if len == 0 then validating using 'Var' or 'VarWithValue'\n\t\t\t\t// Var - doesn't make much sense to do it that way, should call 'Struct', but no harm...\n\t\t\t\t// VarWithField - this allows for validating against each field within the struct against a specific value\n\t\t\t\t//                pretty handy in certain situations\n\t\t\t\tif len(cf.name) > 0 {\n\t\t\t\t\tns = append(append(ns, cf.altName...), '.')\n\t\t\t\t\tstructNs = append(append(structNs, cf.name...), '.')\n\t\t\t\t}\n\n\t\t\t\tv.validateStruct(ctx, parent, current, typ, ns, structNs, ct)\n\t\t\t}\n\t\t\treturn\n\n\t\tcase typeOmitEmpty:\n\n\t\t\t// set Field Level fields\n\t\t\tv.slflParent = parent\n\t\t\tv.flField = current\n\t\t\tv.cf = cf\n\t\t\tv.ct = ct\n\n\t\t\tif !hasValue(v) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tct = ct.next\n\t\t\tcontinue\n\n\t\tcase typeOmitNil:\n\t\t\tv.slflParent = parent\n\t\t\tv.flField = current\n\t\t\tv.cf = cf\n\t\t\tv.ct = ct\n\n\t\t\tswitch field := v.Field(); field.Kind() {\n\t\t\tcase reflect.Slice, reflect.Map, reflect.Ptr, reflect.Interface, reflect.Chan, reflect.Func:\n\t\t\t\tif field.IsNil() {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tif v.fldIsPointer && field.Interface() == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tct = ct.next\n\t\t\tcontinue\n\n\t\tcase typeEndKeys:\n\t\t\treturn\n\n\t\tcase typeDive:\n\n\t\t\tct = ct.next\n\n\t\t\t// traverse slice or map here\n\t\t\t// or panic ;)\n\t\t\tswitch kind {\n\t\t\tcase reflect.Slice, reflect.Array:\n\n\t\t\t\tvar i64 int64\n\t\t\t\treusableCF := &cField{}\n\n\t\t\t\tfor i := 0; i < current.Len(); i++ {\n\n\t\t\t\t\ti64 = int64(i)\n\n\t\t\t\t\tv.misc = append(v.misc[0:0], cf.name...)\n\t\t\t\t\tv.misc = append(v.misc, '[')\n\t\t\t\t\tv.misc = strconv.AppendInt(v.misc, i64, 10)\n\t\t\t\t\tv.misc = append(v.misc, ']')\n\n\t\t\t\t\treusableCF.name = string(v.misc)\n\n\t\t\t\t\tif cf.namesEqual {\n\t\t\t\t\t\treusableCF.altName = reusableCF.name\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv.misc = append(v.misc[0:0], cf.altName...)\n\t\t\t\t\t\tv.misc = append(v.misc, '[')\n\t\t\t\t\t\tv.misc = strconv.AppendInt(v.misc, i64, 10)\n\t\t\t\t\t\tv.misc = append(v.misc, ']')\n\n\t\t\t\t\t\treusableCF.altName = string(v.misc)\n\t\t\t\t\t}\n\t\t\t\t\tv.traverseField(ctx, parent, current.Index(i), ns, structNs, reusableCF, ct)\n\t\t\t\t}\n\n\t\t\tcase reflect.Map:\n\n\t\t\t\tvar pv string\n\t\t\t\treusableCF := &cField{}\n\n\t\t\t\tfor _, key := range current.MapKeys() {\n\n\t\t\t\t\tpv = fmt.Sprintf(\"%v\", key.Interface())\n\n\t\t\t\t\tv.misc = append(v.misc[0:0], cf.name...)\n\t\t\t\t\tv.misc = append(v.misc, '[')\n\t\t\t\t\tv.misc = append(v.misc, pv...)\n\t\t\t\t\tv.misc = append(v.misc, ']')\n\n\t\t\t\t\treusableCF.name = string(v.misc)\n\n\t\t\t\t\tif cf.namesEqual {\n\t\t\t\t\t\treusableCF.altName = reusableCF.name\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.misc = append(v.misc[0:0], cf.altName...)\n\t\t\t\t\t\tv.misc = append(v.misc, '[')\n\t\t\t\t\t\tv.misc = append(v.misc, pv...)\n\t\t\t\t\t\tv.misc = append(v.misc, ']')\n\n\t\t\t\t\t\treusableCF.altName = string(v.misc)\n\t\t\t\t\t}\n\n\t\t\t\t\tif ct != nil && ct.typeof == typeKeys && ct.keys != nil {\n\t\t\t\t\t\tv.traverseField(ctx, parent, key, ns, structNs, reusableCF, ct.keys)\n\t\t\t\t\t\t// can be nil when just keys being validated\n\t\t\t\t\t\tif ct.next != nil {\n\t\t\t\t\t\t\tv.traverseField(ctx, parent, current.MapIndex(key), ns, structNs, reusableCF, ct.next)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.traverseField(ctx, parent, current.MapIndex(key), ns, structNs, reusableCF, ct)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\t// throw error, if not a slice or map then should not have gotten here\n\t\t\t\t// bad dive tag\n\t\t\t\tpanic(\"dive error! can't dive on a non slice or map\")\n\t\t\t}\n\n\t\t\treturn\n\n\t\tcase typeOr:\n\n\t\t\tv.misc = v.misc[0:0]\n\n\t\t\tfor {\n\n\t\t\t\t// set Field Level fields\n\t\t\t\tv.slflParent = parent\n\t\t\t\tv.flField = current\n\t\t\t\tv.cf = cf\n\t\t\t\tv.ct = ct\n\n\t\t\t\tif ct.fn(ctx, v) {\n\t\t\t\t\tif ct.isBlockEnd {\n\t\t\t\t\t\tct = ct.next\n\t\t\t\t\t\tcontinue OUTER\n\t\t\t\t\t}\n\n\t\t\t\t\t// drain rest of the 'or' values, then continue or leave\n\t\t\t\t\tfor {\n\n\t\t\t\t\t\tct = ct.next\n\n\t\t\t\t\t\tif ct == nil {\n\t\t\t\t\t\t\tcontinue OUTER\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ct.typeof != typeOr {\n\t\t\t\t\t\t\tcontinue OUTER\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ct.isBlockEnd {\n\t\t\t\t\t\t\tct = ct.next\n\t\t\t\t\t\t\tcontinue OUTER\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tv.misc = append(v.misc, '|')\n\t\t\t\tv.misc = append(v.misc, ct.tag...)\n\n\t\t\t\tif ct.hasParam {\n\t\t\t\t\tv.misc = append(v.misc, '=')\n\t\t\t\t\tv.misc = append(v.misc, ct.param...)\n\t\t\t\t}\n\n\t\t\t\tif ct.isBlockEnd || ct.next == nil {\n\t\t\t\t\t// if we get here, no valid 'or' value and no more tags\n\t\t\t\t\tv.str1 = string(append(ns, cf.altName...))\n\n\t\t\t\t\tif v.v.hasTagNameFunc {\n\t\t\t\t\t\tv.str2 = string(append(structNs, cf.name...))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.str2 = v.str1\n\t\t\t\t\t}\n\n\t\t\t\t\tif ct.hasAlias {\n\n\t\t\t\t\t\tv.errs = append(v.errs,\n\t\t\t\t\t\t\t&fieldError{\n\t\t\t\t\t\t\t\tv:              v.v,\n\t\t\t\t\t\t\t\ttag:            ct.aliasTag,\n\t\t\t\t\t\t\t\tactualTag:      ct.actualAliasTag,\n\t\t\t\t\t\t\t\tns:             v.str1,\n\t\t\t\t\t\t\t\tstructNs:       v.str2,\n\t\t\t\t\t\t\t\tfieldLen:       uint8(len(cf.altName)),\n\t\t\t\t\t\t\t\tstructfieldLen: uint8(len(cf.name)),\n\t\t\t\t\t\t\t\tvalue:          getValue(current),\n\t\t\t\t\t\t\t\tparam:          ct.param,\n\t\t\t\t\t\t\t\tkind:           kind,\n\t\t\t\t\t\t\t\ttyp:            typ,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttVal := string(v.misc)[1:]\n\n\t\t\t\t\t\tv.errs = append(v.errs,\n\t\t\t\t\t\t\t&fieldError{\n\t\t\t\t\t\t\t\tv:              v.v,\n\t\t\t\t\t\t\t\ttag:            tVal,\n\t\t\t\t\t\t\t\tactualTag:      tVal,\n\t\t\t\t\t\t\t\tns:             v.str1,\n\t\t\t\t\t\t\t\tstructNs:       v.str2,\n\t\t\t\t\t\t\t\tfieldLen:       uint8(len(cf.altName)),\n\t\t\t\t\t\t\t\tstructfieldLen: uint8(len(cf.name)),\n\t\t\t\t\t\t\t\tvalue:          getValue(current),\n\t\t\t\t\t\t\t\tparam:          ct.param,\n\t\t\t\t\t\t\t\tkind:           kind,\n\t\t\t\t\t\t\t\ttyp:            typ,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tct = ct.next\n\t\t\t}\n\n\t\tdefault:\n\n\t\t\t// set Field Level fields\n\t\t\tv.slflParent = parent\n\t\t\tv.flField = current\n\t\t\tv.cf = cf\n\t\t\tv.ct = ct\n\n\t\t\tif !ct.fn(ctx, v) {\n\t\t\t\tv.str1 = string(append(ns, cf.altName...))\n\n\t\t\t\tif v.v.hasTagNameFunc {\n\t\t\t\t\tv.str2 = string(append(structNs, cf.name...))\n\t\t\t\t} else {\n\t\t\t\t\tv.str2 = v.str1\n\t\t\t\t}\n\n\t\t\t\tv.errs = append(v.errs,\n\t\t\t\t\t&fieldError{\n\t\t\t\t\t\tv:              v.v,\n\t\t\t\t\t\ttag:            ct.aliasTag,\n\t\t\t\t\t\tactualTag:      ct.tag,\n\t\t\t\t\t\tns:             v.str1,\n\t\t\t\t\t\tstructNs:       v.str2,\n\t\t\t\t\t\tfieldLen:       uint8(len(cf.altName)),\n\t\t\t\t\t\tstructfieldLen: uint8(len(cf.name)),\n\t\t\t\t\t\tvalue:          getValue(current),\n\t\t\t\t\t\tparam:          ct.param,\n\t\t\t\t\t\tkind:           kind,\n\t\t\t\t\t\ttyp:            typ,\n\t\t\t\t\t},\n\t\t\t\t)\n\n\t\t\t\treturn\n\t\t\t}\n\t\t\tct = ct.next\n\t\t}\n\t}\n\n}\n\nfunc getValue(val reflect.Value) interface{} {\n\tif val.CanInterface() {\n\t\treturn val.Interface()\n\t}\n\n\tif val.CanAddr() {\n\t\treturn reflect.NewAt(val.Type(), unsafe.Pointer(val.UnsafeAddr())).Elem().Interface()\n\t}\n\n\tswitch val.Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn val.Int()\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn val.Uint()\n\tcase reflect.Complex64, reflect.Complex128:\n\t\treturn val.Complex()\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn val.Float()\n\tdefault:\n\t\treturn val.String()\n\t}\n}\n"
        },
        {
          "name": "validator_instance.go",
          "type": "blob",
          "size": 23.8828125,
          "content": "package validator\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tut \"github.com/go-playground/universal-translator\"\n)\n\nconst (\n\tdefaultTagName        = \"validate\"\n\tutf8HexComma          = \"0x2C\"\n\tutf8Pipe              = \"0x7C\"\n\ttagSeparator          = \",\"\n\torSeparator           = \"|\"\n\ttagKeySeparator       = \"=\"\n\tstructOnlyTag         = \"structonly\"\n\tnoStructLevelTag      = \"nostructlevel\"\n\tomitempty             = \"omitempty\"\n\tomitnil               = \"omitnil\"\n\tisdefault             = \"isdefault\"\n\trequiredWithoutAllTag = \"required_without_all\"\n\trequiredWithoutTag    = \"required_without\"\n\trequiredWithTag       = \"required_with\"\n\trequiredWithAllTag    = \"required_with_all\"\n\trequiredIfTag         = \"required_if\"\n\trequiredUnlessTag     = \"required_unless\"\n\tskipUnlessTag         = \"skip_unless\"\n\texcludedWithoutAllTag = \"excluded_without_all\"\n\texcludedWithoutTag    = \"excluded_without\"\n\texcludedWithTag       = \"excluded_with\"\n\texcludedWithAllTag    = \"excluded_with_all\"\n\texcludedIfTag         = \"excluded_if\"\n\texcludedUnlessTag     = \"excluded_unless\"\n\tskipValidationTag     = \"-\"\n\tdiveTag               = \"dive\"\n\tkeysTag               = \"keys\"\n\tendKeysTag            = \"endkeys\"\n\trequiredTag           = \"required\"\n\tnamespaceSeparator    = \".\"\n\tleftBracket           = \"[\"\n\trightBracket          = \"]\"\n\trestrictedTagChars    = \".[],|=+()`~!@#$%^&*\\\\\\\"/?<>{}\"\n\trestrictedAliasErr    = \"Alias '%s' either contains restricted characters or is the same as a restricted tag needed for normal operation\"\n\trestrictedTagErr      = \"Tag '%s' either contains restricted characters or is the same as a restricted tag needed for normal operation\"\n)\n\nvar (\n\ttimeDurationType = reflect.TypeOf(time.Duration(0))\n\ttimeType         = reflect.TypeOf(time.Time{})\n\n\tbyteSliceType = reflect.TypeOf([]byte{})\n\n\tdefaultCField = &cField{namesEqual: true}\n)\n\n// FilterFunc is the type used to filter fields using\n// StructFiltered(...) function.\n// returning true results in the field being filtered/skipped from\n// validation\ntype FilterFunc func(ns []byte) bool\n\n// CustomTypeFunc allows for overriding or adding custom field type handler functions\n// field = field value of the type to return a value to be validated\n// example Valuer from sql drive see https://golang.org/src/database/sql/driver/types.go?s=1210:1293#L29\ntype CustomTypeFunc func(field reflect.Value) interface{}\n\n// TagNameFunc allows for adding of a custom tag name parser\ntype TagNameFunc func(field reflect.StructField) string\n\ntype internalValidationFuncWrapper struct {\n\tfn                 FuncCtx\n\trunValidationOnNil bool\n}\n\n// Validate contains the validator settings and cache\ntype Validate struct {\n\ttagName                string\n\tpool                   *sync.Pool\n\ttagNameFunc            TagNameFunc\n\tstructLevelFuncs       map[reflect.Type]StructLevelFuncCtx\n\tcustomFuncs            map[reflect.Type]CustomTypeFunc\n\taliases                map[string]string\n\tvalidations            map[string]internalValidationFuncWrapper\n\ttransTagFunc           map[ut.Translator]map[string]TranslationFunc // map[<locale>]map[<tag>]TranslationFunc\n\trules                  map[reflect.Type]map[string]string\n\ttagCache               *tagCache\n\tstructCache            *structCache\n\thasCustomFuncs         bool\n\thasTagNameFunc         bool\n\trequiredStructEnabled  bool\n\tprivateFieldValidation bool\n}\n\n// New returns a new instance of 'validate' with sane defaults.\n// Validate is designed to be thread-safe and used as a singleton instance.\n// It caches information about your struct and validations,\n// in essence only parsing your validation tags once per struct type.\n// Using multiple instances neglects the benefit of caching.\nfunc New(options ...Option) *Validate {\n\n\ttc := new(tagCache)\n\ttc.m.Store(make(map[string]*cTag))\n\n\tsc := new(structCache)\n\tsc.m.Store(make(map[reflect.Type]*cStruct))\n\n\tv := &Validate{\n\t\ttagName:     defaultTagName,\n\t\taliases:     make(map[string]string, len(bakedInAliases)),\n\t\tvalidations: make(map[string]internalValidationFuncWrapper, len(bakedInValidators)),\n\t\ttagCache:    tc,\n\t\tstructCache: sc,\n\t}\n\n\t// must copy alias validators for separate validations to be used in each validator instance\n\tfor k, val := range bakedInAliases {\n\t\tv.RegisterAlias(k, val)\n\t}\n\n\t// must copy validators for separate validations to be used in each instance\n\tfor k, val := range bakedInValidators {\n\n\t\tswitch k {\n\t\t// these require that even if the value is nil that the validation should run, omitempty still overrides this behaviour\n\t\tcase requiredIfTag, requiredUnlessTag, requiredWithTag, requiredWithAllTag, requiredWithoutTag, requiredWithoutAllTag,\n\t\t\texcludedIfTag, excludedUnlessTag, excludedWithTag, excludedWithAllTag, excludedWithoutTag, excludedWithoutAllTag,\n\t\t\tskipUnlessTag:\n\t\t\t_ = v.registerValidation(k, wrapFunc(val), true, true)\n\t\tdefault:\n\t\t\t// no need to error check here, baked in will always be valid\n\t\t\t_ = v.registerValidation(k, wrapFunc(val), true, false)\n\t\t}\n\t}\n\n\tv.pool = &sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn &validate{\n\t\t\t\tv:        v,\n\t\t\t\tns:       make([]byte, 0, 64),\n\t\t\t\tactualNs: make([]byte, 0, 64),\n\t\t\t\tmisc:     make([]byte, 32),\n\t\t\t}\n\t\t},\n\t}\n\n\tfor _, o := range options {\n\t\to(v)\n\t}\n\treturn v\n}\n\n// SetTagName allows for changing of the default tag name of 'validate'\nfunc (v *Validate) SetTagName(name string) {\n\tv.tagName = name\n}\n\n// ValidateMapCtx validates a map using a map of validation rules and allows passing of contextual\n// validation information via context.Context.\nfunc (v Validate) ValidateMapCtx(ctx context.Context, data map[string]interface{}, rules map[string]interface{}) map[string]interface{} {\n\terrs := make(map[string]interface{})\n\tfor field, rule := range rules {\n\t\tif ruleObj, ok := rule.(map[string]interface{}); ok {\n\t\t\tif dataObj, ok := data[field].(map[string]interface{}); ok {\n\t\t\t\terr := v.ValidateMapCtx(ctx, dataObj, ruleObj)\n\t\t\t\tif len(err) > 0 {\n\t\t\t\t\terrs[field] = err\n\t\t\t\t}\n\t\t\t} else if dataObjs, ok := data[field].([]map[string]interface{}); ok {\n\t\t\t\tfor _, obj := range dataObjs {\n\t\t\t\t\terr := v.ValidateMapCtx(ctx, obj, ruleObj)\n\t\t\t\t\tif len(err) > 0 {\n\t\t\t\t\t\terrs[field] = err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terrs[field] = errors.New(\"The field: '\" + field + \"' is not a map to dive\")\n\t\t\t}\n\t\t} else if ruleStr, ok := rule.(string); ok {\n\t\t\terr := v.VarCtx(ctx, data[field], ruleStr)\n\t\t\tif err != nil {\n\t\t\t\terrs[field] = err\n\t\t\t}\n\t\t}\n\t}\n\treturn errs\n}\n\n// ValidateMap validates map data from a map of tags\nfunc (v *Validate) ValidateMap(data map[string]interface{}, rules map[string]interface{}) map[string]interface{} {\n\treturn v.ValidateMapCtx(context.Background(), data, rules)\n}\n\n// RegisterTagNameFunc registers a function to get alternate names for StructFields.\n//\n// eg. to use the names which have been specified for JSON representations of structs, rather than normal Go field names:\n//\n//\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n//\t    name := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n//\t    // skip if tag key says it should be ignored\n//\t    if name == \"-\" {\n//\t        return \"\"\n//\t    }\n//\t    return name\n//\t})\nfunc (v *Validate) RegisterTagNameFunc(fn TagNameFunc) {\n\tv.tagNameFunc = fn\n\tv.hasTagNameFunc = true\n}\n\n// RegisterValidation adds a validation with the given tag\n//\n// NOTES:\n// - if the key already exists, the previous validation function will be replaced.\n// - this method is not thread-safe it is intended that these all be registered prior to any validation\nfunc (v *Validate) RegisterValidation(tag string, fn Func, callValidationEvenIfNull ...bool) error {\n\treturn v.RegisterValidationCtx(tag, wrapFunc(fn), callValidationEvenIfNull...)\n}\n\n// RegisterValidationCtx does the same as RegisterValidation on accepts a FuncCtx validation\n// allowing context.Context validation support.\nfunc (v *Validate) RegisterValidationCtx(tag string, fn FuncCtx, callValidationEvenIfNull ...bool) error {\n\tvar nilCheckable bool\n\tif len(callValidationEvenIfNull) > 0 {\n\t\tnilCheckable = callValidationEvenIfNull[0]\n\t}\n\treturn v.registerValidation(tag, fn, false, nilCheckable)\n}\n\nfunc (v *Validate) registerValidation(tag string, fn FuncCtx, bakedIn bool, nilCheckable bool) error {\n\tif len(tag) == 0 {\n\t\treturn errors.New(\"function Key cannot be empty\")\n\t}\n\n\tif fn == nil {\n\t\treturn errors.New(\"function cannot be empty\")\n\t}\n\n\t_, ok := restrictedTags[tag]\n\tif !bakedIn && (ok || strings.ContainsAny(tag, restrictedTagChars)) {\n\t\tpanic(fmt.Sprintf(restrictedTagErr, tag))\n\t}\n\tv.validations[tag] = internalValidationFuncWrapper{fn: fn, runValidationOnNil: nilCheckable}\n\treturn nil\n}\n\n// RegisterAlias registers a mapping of a single validation tag that\n// defines a common or complex set of validation(s) to simplify adding validation\n// to structs.\n//\n// NOTE: this function is not thread-safe it is intended that these all be registered prior to any validation\nfunc (v *Validate) RegisterAlias(alias, tags string) {\n\n\t_, ok := restrictedTags[alias]\n\n\tif ok || strings.ContainsAny(alias, restrictedTagChars) {\n\t\tpanic(fmt.Sprintf(restrictedAliasErr, alias))\n\t}\n\n\tv.aliases[alias] = tags\n}\n\n// RegisterStructValidation registers a StructLevelFunc against a number of types.\n//\n// NOTE:\n// - this method is not thread-safe it is intended that these all be registered prior to any validation\nfunc (v *Validate) RegisterStructValidation(fn StructLevelFunc, types ...interface{}) {\n\tv.RegisterStructValidationCtx(wrapStructLevelFunc(fn), types...)\n}\n\n// RegisterStructValidationCtx registers a StructLevelFuncCtx against a number of types and allows passing\n// of contextual validation information via context.Context.\n//\n// NOTE:\n// - this method is not thread-safe it is intended that these all be registered prior to any validation\nfunc (v *Validate) RegisterStructValidationCtx(fn StructLevelFuncCtx, types ...interface{}) {\n\n\tif v.structLevelFuncs == nil {\n\t\tv.structLevelFuncs = make(map[reflect.Type]StructLevelFuncCtx)\n\t}\n\n\tfor _, t := range types {\n\t\ttv := reflect.ValueOf(t)\n\t\tif tv.Kind() == reflect.Ptr {\n\t\t\tt = reflect.Indirect(tv).Interface()\n\t\t}\n\n\t\tv.structLevelFuncs[reflect.TypeOf(t)] = fn\n\t}\n}\n\n// RegisterStructValidationMapRules registers validate map rules.\n// Be aware that map validation rules supersede those defined on a/the struct if present.\n//\n// NOTE: this method is not thread-safe it is intended that these all be registered prior to any validation\nfunc (v *Validate) RegisterStructValidationMapRules(rules map[string]string, types ...interface{}) {\n\tif v.rules == nil {\n\t\tv.rules = make(map[reflect.Type]map[string]string)\n\t}\n\n\tdeepCopyRules := make(map[string]string)\n\tfor i, rule := range rules {\n\t\tdeepCopyRules[i] = rule\n\t}\n\n\tfor _, t := range types {\n\t\ttyp := reflect.TypeOf(t)\n\n\t\tif typ.Kind() == reflect.Ptr {\n\t\t\ttyp = typ.Elem()\n\t\t}\n\n\t\tif typ.Kind() != reflect.Struct {\n\t\t\tcontinue\n\t\t}\n\t\tv.rules[typ] = deepCopyRules\n\t}\n}\n\n// RegisterCustomTypeFunc registers a CustomTypeFunc against a number of types\n//\n// NOTE: this method is not thread-safe it is intended that these all be registered prior to any validation\nfunc (v *Validate) RegisterCustomTypeFunc(fn CustomTypeFunc, types ...interface{}) {\n\n\tif v.customFuncs == nil {\n\t\tv.customFuncs = make(map[reflect.Type]CustomTypeFunc)\n\t}\n\n\tfor _, t := range types {\n\t\tv.customFuncs[reflect.TypeOf(t)] = fn\n\t}\n\n\tv.hasCustomFuncs = true\n}\n\n// RegisterTranslation registers translations against the provided tag.\nfunc (v *Validate) RegisterTranslation(tag string, trans ut.Translator, registerFn RegisterTranslationsFunc, translationFn TranslationFunc) (err error) {\n\n\tif v.transTagFunc == nil {\n\t\tv.transTagFunc = make(map[ut.Translator]map[string]TranslationFunc)\n\t}\n\n\tif err = registerFn(trans); err != nil {\n\t\treturn\n\t}\n\n\tm, ok := v.transTagFunc[trans]\n\tif !ok {\n\t\tm = make(map[string]TranslationFunc)\n\t\tv.transTagFunc[trans] = m\n\t}\n\n\tm[tag] = translationFn\n\n\treturn\n}\n\n// Struct validates a structs exposed fields, and automatically validates nested structs, unless otherwise specified.\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) Struct(s interface{}) error {\n\treturn v.StructCtx(context.Background(), s)\n}\n\n// StructCtx validates a structs exposed fields, and automatically validates nested structs, unless otherwise specified\n// and also allows passing of context.Context for contextual validation information.\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) StructCtx(ctx context.Context, s interface{}) (err error) {\n\n\tval := reflect.ValueOf(s)\n\ttop := val\n\n\tif val.Kind() == reflect.Ptr && !val.IsNil() {\n\t\tval = val.Elem()\n\t}\n\n\tif val.Kind() != reflect.Struct || val.Type().ConvertibleTo(timeType) {\n\t\treturn &InvalidValidationError{Type: reflect.TypeOf(s)}\n\t}\n\n\t// good to validate\n\tvd := v.pool.Get().(*validate)\n\tvd.top = top\n\tvd.isPartial = false\n\t// vd.hasExcludes = false // only need to reset in StructPartial and StructExcept\n\n\tvd.validateStruct(ctx, top, val, val.Type(), vd.ns[0:0], vd.actualNs[0:0], nil)\n\n\tif len(vd.errs) > 0 {\n\t\terr = vd.errs\n\t\tvd.errs = nil\n\t}\n\n\tv.pool.Put(vd)\n\n\treturn\n}\n\n// StructFiltered validates a structs exposed fields, that pass the FilterFunc check and automatically validates\n// nested structs, unless otherwise specified.\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) StructFiltered(s interface{}, fn FilterFunc) error {\n\treturn v.StructFilteredCtx(context.Background(), s, fn)\n}\n\n// StructFilteredCtx validates a structs exposed fields, that pass the FilterFunc check and automatically validates\n// nested structs, unless otherwise specified and also allows passing of contextual validation information via\n// context.Context\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) StructFilteredCtx(ctx context.Context, s interface{}, fn FilterFunc) (err error) {\n\tval := reflect.ValueOf(s)\n\ttop := val\n\n\tif val.Kind() == reflect.Ptr && !val.IsNil() {\n\t\tval = val.Elem()\n\t}\n\n\tif val.Kind() != reflect.Struct || val.Type().ConvertibleTo(timeType) {\n\t\treturn &InvalidValidationError{Type: reflect.TypeOf(s)}\n\t}\n\n\t// good to validate\n\tvd := v.pool.Get().(*validate)\n\tvd.top = top\n\tvd.isPartial = true\n\tvd.ffn = fn\n\t// vd.hasExcludes = false // only need to reset in StructPartial and StructExcept\n\n\tvd.validateStruct(ctx, top, val, val.Type(), vd.ns[0:0], vd.actualNs[0:0], nil)\n\n\tif len(vd.errs) > 0 {\n\t\terr = vd.errs\n\t\tvd.errs = nil\n\t}\n\n\tv.pool.Put(vd)\n\n\treturn\n}\n\n// StructPartial validates the fields passed in only, ignoring all others.\n// Fields may be provided in a namespaced fashion relative to the  struct provided\n// eg. NestedStruct.Field or NestedArrayField[0].Struct.Name\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) StructPartial(s interface{}, fields ...string) error {\n\treturn v.StructPartialCtx(context.Background(), s, fields...)\n}\n\n// StructPartialCtx validates the fields passed in only, ignoring all others and allows passing of contextual\n// validation information via context.Context\n// Fields may be provided in a namespaced fashion relative to the  struct provided\n// eg. NestedStruct.Field or NestedArrayField[0].Struct.Name\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) StructPartialCtx(ctx context.Context, s interface{}, fields ...string) (err error) {\n\tval := reflect.ValueOf(s)\n\ttop := val\n\n\tif val.Kind() == reflect.Ptr && !val.IsNil() {\n\t\tval = val.Elem()\n\t}\n\n\tif val.Kind() != reflect.Struct || val.Type().ConvertibleTo(timeType) {\n\t\treturn &InvalidValidationError{Type: reflect.TypeOf(s)}\n\t}\n\n\t// good to validate\n\tvd := v.pool.Get().(*validate)\n\tvd.top = top\n\tvd.isPartial = true\n\tvd.ffn = nil\n\tvd.hasExcludes = false\n\tvd.includeExclude = make(map[string]struct{})\n\n\ttyp := val.Type()\n\tname := typ.Name()\n\n\tfor _, k := range fields {\n\n\t\tflds := strings.Split(k, namespaceSeparator)\n\t\tif len(flds) > 0 {\n\n\t\t\tvd.misc = append(vd.misc[0:0], name...)\n\t\t\t// Don't append empty name for unnamed structs\n\t\t\tif len(vd.misc) != 0 {\n\t\t\t\tvd.misc = append(vd.misc, '.')\n\t\t\t}\n\n\t\t\tfor _, s := range flds {\n\n\t\t\t\tidx := strings.Index(s, leftBracket)\n\n\t\t\t\tif idx != -1 {\n\t\t\t\t\tfor idx != -1 {\n\t\t\t\t\t\tvd.misc = append(vd.misc, s[:idx]...)\n\t\t\t\t\t\tvd.includeExclude[string(vd.misc)] = struct{}{}\n\n\t\t\t\t\t\tidx2 := strings.Index(s, rightBracket)\n\t\t\t\t\t\tidx2++\n\t\t\t\t\t\tvd.misc = append(vd.misc, s[idx:idx2]...)\n\t\t\t\t\t\tvd.includeExclude[string(vd.misc)] = struct{}{}\n\t\t\t\t\t\ts = s[idx2:]\n\t\t\t\t\t\tidx = strings.Index(s, leftBracket)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tvd.misc = append(vd.misc, s...)\n\t\t\t\t\tvd.includeExclude[string(vd.misc)] = struct{}{}\n\t\t\t\t}\n\n\t\t\t\tvd.misc = append(vd.misc, '.')\n\t\t\t}\n\t\t}\n\t}\n\n\tvd.validateStruct(ctx, top, val, typ, vd.ns[0:0], vd.actualNs[0:0], nil)\n\n\tif len(vd.errs) > 0 {\n\t\terr = vd.errs\n\t\tvd.errs = nil\n\t}\n\n\tv.pool.Put(vd)\n\n\treturn\n}\n\n// StructExcept validates all fields except the ones passed in.\n// Fields may be provided in a namespaced fashion relative to the  struct provided\n// i.e. NestedStruct.Field or NestedArrayField[0].Struct.Name\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) StructExcept(s interface{}, fields ...string) error {\n\treturn v.StructExceptCtx(context.Background(), s, fields...)\n}\n\n// StructExceptCtx validates all fields except the ones passed in and allows passing of contextual\n// validation information via context.Context\n// Fields may be provided in a namespaced fashion relative to the  struct provided\n// i.e. NestedStruct.Field or NestedArrayField[0].Struct.Name\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\nfunc (v *Validate) StructExceptCtx(ctx context.Context, s interface{}, fields ...string) (err error) {\n\tval := reflect.ValueOf(s)\n\ttop := val\n\n\tif val.Kind() == reflect.Ptr && !val.IsNil() {\n\t\tval = val.Elem()\n\t}\n\n\tif val.Kind() != reflect.Struct || val.Type().ConvertibleTo(timeType) {\n\t\treturn &InvalidValidationError{Type: reflect.TypeOf(s)}\n\t}\n\n\t// good to validate\n\tvd := v.pool.Get().(*validate)\n\tvd.top = top\n\tvd.isPartial = true\n\tvd.ffn = nil\n\tvd.hasExcludes = true\n\tvd.includeExclude = make(map[string]struct{})\n\n\ttyp := val.Type()\n\tname := typ.Name()\n\n\tfor _, key := range fields {\n\n\t\tvd.misc = vd.misc[0:0]\n\n\t\tif len(name) > 0 {\n\t\t\tvd.misc = append(vd.misc, name...)\n\t\t\tvd.misc = append(vd.misc, '.')\n\t\t}\n\n\t\tvd.misc = append(vd.misc, key...)\n\t\tvd.includeExclude[string(vd.misc)] = struct{}{}\n\t}\n\n\tvd.validateStruct(ctx, top, val, typ, vd.ns[0:0], vd.actualNs[0:0], nil)\n\n\tif len(vd.errs) > 0 {\n\t\terr = vd.errs\n\t\tvd.errs = nil\n\t}\n\n\tv.pool.Put(vd)\n\n\treturn\n}\n\n// Var validates a single variable using tag style validation.\n// eg.\n// var i int\n// validate.Var(i, \"gt=1,lt=10\")\n//\n// WARNING: a struct can be passed for validation eg. time.Time is a struct or\n// if you have a custom type and have registered a custom type handler, so must\n// allow it; however unforeseen validations will occur if trying to validate a\n// struct that is meant to be passed to 'validate.Struct'\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\n// validate Array, Slice and maps fields which may contain more than one error\nfunc (v *Validate) Var(field interface{}, tag string) error {\n\treturn v.VarCtx(context.Background(), field, tag)\n}\n\n// VarCtx validates a single variable using tag style validation and allows passing of contextual\n// validation information via context.Context.\n// eg.\n// var i int\n// validate.Var(i, \"gt=1,lt=10\")\n//\n// WARNING: a struct can be passed for validation eg. time.Time is a struct or\n// if you have a custom type and have registered a custom type handler, so must\n// allow it; however unforeseen validations will occur if trying to validate a\n// struct that is meant to be passed to 'validate.Struct'\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\n// validate Array, Slice and maps fields which may contain more than one error\nfunc (v *Validate) VarCtx(ctx context.Context, field interface{}, tag string) (err error) {\n\tif len(tag) == 0 || tag == skipValidationTag {\n\t\treturn nil\n\t}\n\n\tctag := v.fetchCacheTag(tag)\n\n\tval := reflect.ValueOf(field)\n\tvd := v.pool.Get().(*validate)\n\tvd.top = val\n\tvd.isPartial = false\n\tvd.traverseField(ctx, val, val, vd.ns[0:0], vd.actualNs[0:0], defaultCField, ctag)\n\n\tif len(vd.errs) > 0 {\n\t\terr = vd.errs\n\t\tvd.errs = nil\n\t}\n\tv.pool.Put(vd)\n\treturn\n}\n\n// VarWithValue validates a single variable, against another variable/field's value using tag style validation\n// eg.\n// s1 := \"abcd\"\n// s2 := \"abcd\"\n// validate.VarWithValue(s1, s2, \"eqcsfield\") // returns true\n//\n// WARNING: a struct can be passed for validation eg. time.Time is a struct or\n// if you have a custom type and have registered a custom type handler, so must\n// allow it; however unforeseen validations will occur if trying to validate a\n// struct that is meant to be passed to 'validate.Struct'\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\n// validate Array, Slice and maps fields which may contain more than one error\nfunc (v *Validate) VarWithValue(field interface{}, other interface{}, tag string) error {\n\treturn v.VarWithValueCtx(context.Background(), field, other, tag)\n}\n\n// VarWithValueCtx validates a single variable, against another variable/field's value using tag style validation and\n// allows passing of contextual validation information via context.Context.\n// eg.\n// s1 := \"abcd\"\n// s2 := \"abcd\"\n// validate.VarWithValue(s1, s2, \"eqcsfield\") // returns true\n//\n// WARNING: a struct can be passed for validation eg. time.Time is a struct or\n// if you have a custom type and have registered a custom type handler, so must\n// allow it; however unforeseen validations will occur if trying to validate a\n// struct that is meant to be passed to 'validate.Struct'\n//\n// It returns InvalidValidationError for bad values passed in and nil or ValidationErrors as error otherwise.\n// You will need to assert the error if it's not nil eg. err.(validator.ValidationErrors) to access the array of errors.\n// validate Array, Slice and maps fields which may contain more than one error\nfunc (v *Validate) VarWithValueCtx(ctx context.Context, field interface{}, other interface{}, tag string) (err error) {\n\tif len(tag) == 0 || tag == skipValidationTag {\n\t\treturn nil\n\t}\n\tctag := v.fetchCacheTag(tag)\n\totherVal := reflect.ValueOf(other)\n\tvd := v.pool.Get().(*validate)\n\tvd.top = otherVal\n\tvd.isPartial = false\n\tvd.traverseField(ctx, otherVal, reflect.ValueOf(field), vd.ns[0:0], vd.actualNs[0:0], defaultCField, ctag)\n\n\tif len(vd.errs) > 0 {\n\t\terr = vd.errs\n\t\tvd.errs = nil\n\t}\n\tv.pool.Put(vd)\n\treturn\n}\n"
        },
        {
          "name": "validator_test.go",
          "type": "blob",
          "size": 371.6767578125,
          "content": "package validator\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/go-playground/assert/v2\"\n\t\"github.com/go-playground/locales/en\"\n\t\"github.com/go-playground/locales/fr\"\n\t\"github.com/go-playground/locales/nl\"\n\tut \"github.com/go-playground/universal-translator\"\n)\n\n// NOTES:\n// - Run \"go test\" to run tests\n// - Run \"gocov test | gocov report\" to report on test coverage by file\n// - Run \"gocov test | gocov annotate -\" to report on all code and functions, those, marked with \"MISS\" were never called\n//\n// or\n//\n// -- may be a good idea to change to output path to somewherelike /tmp\n// go test -coverprofile cover.out && go tool cover -html=cover.out -o cover.html\n//\n//\n// go test -cpuprofile cpu.out\n// ./validator.test -test.bench=. -test.cpuprofile=cpu.prof\n// go tool pprof validator.test cpu.prof\n//\n//\n// go test -memprofile mem.out\n\ntype I interface {\n\tFoo() string\n}\n\ntype Impl struct {\n\tF string `validate:\"len=3\"`\n}\n\nfunc (i *Impl) Foo() string {\n\treturn i.F\n}\n\ntype SubTest struct {\n\tTest string `validate:\"required\"`\n}\n\ntype TestInterface struct {\n\tIface I\n}\n\ntype TestString struct {\n\tBlankTag  string `validate:\"\"`\n\tRequired  string `validate:\"required\"`\n\tLen       string `validate:\"len=10\"`\n\tMin       string `validate:\"min=1\"`\n\tMax       string `validate:\"max=10\"`\n\tMinMax    string `validate:\"min=1,max=10\"`\n\tLt        string `validate:\"lt=10\"`\n\tLte       string `validate:\"lte=10\"`\n\tGt        string `validate:\"gt=10\"`\n\tGte       string `validate:\"gte=10\"`\n\tOmitEmpty string `validate:\"omitempty,min=1,max=10\"`\n\tBoolean   string `validate:\"boolean\"`\n\tSub       *SubTest\n\tSubIgnore *SubTest `validate:\"-\"`\n\tAnonymous struct {\n\t\tA string `validate:\"required\"`\n\t}\n\tIface I\n}\n\ntype TestUint64 struct {\n\tRequired  uint64 `validate:\"required\"`\n\tLen       uint64 `validate:\"len=10\"`\n\tMin       uint64 `validate:\"min=1\"`\n\tMax       uint64 `validate:\"max=10\"`\n\tMinMax    uint64 `validate:\"min=1,max=10\"`\n\tOmitEmpty uint64 `validate:\"omitempty,min=1,max=10\"`\n}\n\ntype TestFloat64 struct {\n\tRequired  float64 `validate:\"required\"`\n\tLen       float64 `validate:\"len=10\"`\n\tMin       float64 `validate:\"min=1\"`\n\tMax       float64 `validate:\"max=10\"`\n\tMinMax    float64 `validate:\"min=1,max=10\"`\n\tLte       float64 `validate:\"lte=10\"`\n\tOmitEmpty float64 `validate:\"omitempty,min=1,max=10\"`\n}\n\ntype TestSlice struct {\n\tRequired  []int `validate:\"required\"`\n\tLen       []int `validate:\"len=10\"`\n\tMin       []int `validate:\"min=1\"`\n\tMax       []int `validate:\"max=10\"`\n\tMinMax    []int `validate:\"min=1,max=10\"`\n\tOmitEmpty []int `validate:\"omitempty,min=1,max=10\"`\n}\n\nfunc AssertError(t *testing.T, err error, nsKey, structNsKey, field, structField, expectedTag string) {\n\terrs := err.(ValidationErrors)\n\n\tfound := false\n\tvar fe FieldError\n\n\tfor i := 0; i < len(errs); i++ {\n\t\tif errs[i].Namespace() == nsKey && errs[i].StructNamespace() == structNsKey {\n\t\t\tfound = true\n\t\t\tfe = errs[i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tEqualSkip(t, 2, found, true)\n\tNotEqualSkip(t, 2, fe, nil)\n\tEqualSkip(t, 2, fe.Field(), field)\n\tEqualSkip(t, 2, fe.StructField(), structField)\n\tEqualSkip(t, 2, fe.Tag(), expectedTag)\n}\n\nfunc AssertDeepError(t *testing.T, err error, nsKey, structNsKey, field, structField, expectedTag, actualTag string) {\n\terrs := err.(ValidationErrors)\n\n\tfound := false\n\tvar fe FieldError\n\n\tfor i := 0; i < len(errs); i++ {\n\t\tif errs[i].Namespace() == nsKey && errs[i].StructNamespace() == structNsKey && errs[i].Tag() == expectedTag && errs[i].ActualTag() == actualTag {\n\t\t\tfound = true\n\t\t\tfe = errs[i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\tEqualSkip(t, 2, found, true)\n\tNotEqualSkip(t, 2, fe, nil)\n\tEqualSkip(t, 2, fe.Field(), field)\n\tEqualSkip(t, 2, fe.StructField(), structField)\n}\n\nfunc getError(err error, nsKey, structNsKey string) FieldError {\n\terrs := err.(ValidationErrors)\n\n\tvar fe FieldError\n\n\tfor i := 0; i < len(errs); i++ {\n\t\tif errs[i].Namespace() == nsKey && errs[i].StructNamespace() == structNsKey {\n\t\t\tfe = errs[i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn fe\n}\n\ntype valuer struct {\n\tName string\n}\n\nfunc (v valuer) Value() (driver.Value, error) {\n\tif v.Name == \"errorme\" {\n\t\tpanic(\"SQL Driver Valuer error: some kind of error\")\n\t\t// return nil, errors.New(\"some kind of error\")\n\t}\n\n\tif len(v.Name) == 0 {\n\t\treturn nil, nil\n\t}\n\n\treturn v.Name, nil\n}\n\ntype MadeUpCustomType struct {\n\tFirstName string\n\tLastName  string\n}\n\nfunc ValidateCustomType(field reflect.Value) interface{} {\n\tif cust, ok := field.Interface().(MadeUpCustomType); ok {\n\n\t\tif len(cust.FirstName) == 0 || len(cust.LastName) == 0 {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn cust.FirstName + \" \" + cust.LastName\n\t}\n\n\treturn \"\"\n}\n\nfunc OverrideIntTypeForSomeReason(field reflect.Value) interface{} {\n\tif i, ok := field.Interface().(int); ok {\n\t\tif i == 1 {\n\t\t\treturn \"1\"\n\t\t}\n\n\t\tif i == 2 {\n\t\t\treturn \"12\"\n\t\t}\n\t}\n\n\treturn \"\"\n}\n\ntype CustomMadeUpStruct struct {\n\tMadeUp        MadeUpCustomType `validate:\"required\"`\n\tOverriddenInt int              `validate:\"gt=1\"`\n}\n\nfunc ValidateValuerType(field reflect.Value) interface{} {\n\tif valuer, ok := field.Interface().(driver.Valuer); ok {\n\n\t\tval, err := valuer.Value()\n\t\tif err != nil {\n\t\t\t// handle the error how you want\n\t\t\treturn nil\n\t\t}\n\n\t\treturn val\n\t}\n\n\treturn nil\n}\n\ntype TestPartial struct {\n\tNoTag     string\n\tBlankTag  string     `validate:\"\"`\n\tRequired  string     `validate:\"required\"`\n\tSubSlice  []*SubTest `validate:\"required,dive\"`\n\tSub       *SubTest\n\tSubIgnore *SubTest `validate:\"-\"`\n\tAnonymous struct {\n\t\tA         string     `validate:\"required\"`\n\t\tASubSlice []*SubTest `validate:\"required,dive\"`\n\n\t\tSubAnonStruct []struct {\n\t\t\tTest      string `validate:\"required\"`\n\t\t\tOtherTest string `validate:\"required\"`\n\t\t} `validate:\"required,dive\"`\n\t}\n}\n\ntype TestStruct struct {\n\tString string `validate:\"required\" json:\"StringVal\"`\n}\n\nfunc StructValidationTestStructSuccess(sl StructLevel) {\n\tst := sl.Current().Interface().(TestStruct)\n\n\tif st.String != \"good value\" {\n\t\tsl.ReportError(st.String, \"StringVal\", \"String\", \"badvalueteststruct\", \"good value\")\n\t}\n}\n\nfunc StructValidationTestStruct(sl StructLevel) {\n\tst := sl.Current().Interface().(TestStruct)\n\n\tif st.String != \"bad value\" {\n\t\tsl.ReportError(st.String, \"StringVal\", \"String\", \"badvalueteststruct\", \"bad value\")\n\t}\n}\n\nfunc StructValidationNoTestStructCustomName(sl StructLevel) {\n\tst := sl.Current().Interface().(TestStruct)\n\n\tif st.String != \"bad value\" {\n\t\tsl.ReportError(st.String, \"String\", \"\", \"badvalueteststruct\", \"bad value\")\n\t}\n}\n\nfunc StructValidationTestStructInvalid(sl StructLevel) {\n\tst := sl.Current().Interface().(TestStruct)\n\n\tif st.String != \"bad value\" {\n\t\tsl.ReportError(nil, \"StringVal\", \"String\", \"badvalueteststruct\", \"bad value\")\n\t}\n}\n\nfunc StructValidationTestStructReturnValidationErrors(sl StructLevel) {\n\ts := sl.Current().Interface().(TestStructReturnValidationErrors)\n\n\terrs := sl.Validator().Struct(s.Inner1.Inner2)\n\tif errs == nil {\n\t\treturn\n\t}\n\n\tsl.ReportValidationErrors(\"Inner1.\", \"Inner1.\", errs.(ValidationErrors))\n}\n\nfunc StructValidationTestStructReturnValidationErrors2(sl StructLevel) {\n\ts := sl.Current().Interface().(TestStructReturnValidationErrors)\n\n\terrs := sl.Validator().Struct(s.Inner1.Inner2)\n\tif errs == nil {\n\t\treturn\n\t}\n\n\tsl.ReportValidationErrors(\"Inner1JSON.\", \"Inner1.\", errs.(ValidationErrors))\n}\n\ntype TestStructReturnValidationErrorsInner2 struct {\n\tString string `validate:\"required\" json:\"JSONString\"`\n}\n\ntype TestStructReturnValidationErrorsInner1 struct {\n\tInner2 *TestStructReturnValidationErrorsInner2\n}\n\ntype TestStructReturnValidationErrors struct {\n\tInner1 *TestStructReturnValidationErrorsInner1 `json:\"Inner1JSON\"`\n}\n\ntype StructLevelInvalidErr struct {\n\tValue string\n}\n\nfunc StructLevelInvalidError(sl StructLevel) {\n\ttop := sl.Top().Interface().(StructLevelInvalidErr)\n\ts := sl.Current().Interface().(StructLevelInvalidErr)\n\n\tif top.Value == s.Value {\n\t\tsl.ReportError(nil, \"Value\", \"Value\", \"required\", \"\")\n\t}\n}\n\nfunc stringPtr(v string) *string {\n\treturn &v\n}\n\nfunc intPtr(v int) *int {\n\treturn &v\n}\n\nfunc float64Ptr(v float64) *float64 {\n\treturn &v\n}\n\nfunc TestStructLevelInvalidError(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterStructValidation(StructLevelInvalidError, StructLevelInvalidErr{})\n\n\tvar test StructLevelInvalidErr\n\n\terr := validate.Struct(test)\n\tNotEqual(t, err, nil)\n\n\terrs, ok := err.(ValidationErrors)\n\tEqual(t, ok, true)\n\n\tfe := errs[0]\n\tEqual(t, fe.Field(), \"Value\")\n\tEqual(t, fe.StructField(), \"Value\")\n\tEqual(t, fe.Namespace(), \"StructLevelInvalidErr.Value\")\n\tEqual(t, fe.StructNamespace(), \"StructLevelInvalidErr.Value\")\n\tEqual(t, fe.Tag(), \"required\")\n\tEqual(t, fe.ActualTag(), \"required\")\n\tEqual(t, fe.Kind(), reflect.Invalid)\n\tEqual(t, fe.Type(), reflect.TypeOf(nil))\n}\n\nfunc TestNameNamespace(t *testing.T) {\n\ttype Inner2Namespace struct {\n\t\tString []string `validate:\"dive,required\" json:\"JSONString\"`\n\t}\n\n\ttype Inner1Namespace struct {\n\t\tInner2 *Inner2Namespace `json:\"Inner2JSON\"`\n\t}\n\n\ttype Namespace struct {\n\t\tInner1 *Inner1Namespace `json:\"Inner1JSON\"`\n\t}\n\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ti2 := &Inner2Namespace{String: []string{\"ok\", \"ok\", \"ok\"}}\n\ti1 := &Inner1Namespace{Inner2: i2}\n\tns := &Namespace{Inner1: i1}\n\n\terrs := validate.Struct(ns)\n\tEqual(t, errs, nil)\n\n\ti2.String[1] = \"\"\n\n\terrs = validate.Struct(ns)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"Namespace.Inner1JSON.Inner2JSON.JSONString[1]\", \"Namespace.Inner1.Inner2.String[1]\", \"JSONString[1]\", \"String[1]\", \"required\")\n\n\tfe := getError(ve, \"Namespace.Inner1JSON.Inner2JSON.JSONString[1]\", \"Namespace.Inner1.Inner2.String[1]\")\n\tNotEqual(t, fe, nil)\n\tEqual(t, fe.Field(), \"JSONString[1]\")\n\tEqual(t, fe.StructField(), \"String[1]\")\n\tEqual(t, fe.Namespace(), \"Namespace.Inner1JSON.Inner2JSON.JSONString[1]\")\n\tEqual(t, fe.StructNamespace(), \"Namespace.Inner1.Inner2.String[1]\")\n}\n\nfunc TestAnonymous(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype Test struct {\n\t\tAnonymous struct {\n\t\t\tA string `validate:\"required\" json:\"EH\"`\n\t\t}\n\t\tAnonymousB struct {\n\t\t\tB string `validate:\"required\" json:\"BEE\"`\n\t\t}\n\t\tanonymousC struct {\n\t\t\tc string `validate:\"required\"`\n\t\t}\n\t}\n\n\ttst := &Test{\n\t\tAnonymous: struct {\n\t\t\tA string `validate:\"required\" json:\"EH\"`\n\t\t}{\n\t\t\tA: \"1\",\n\t\t},\n\t\tAnonymousB: struct {\n\t\t\tB string `validate:\"required\" json:\"BEE\"`\n\t\t}{\n\t\t\tB: \"\",\n\t\t},\n\t\tanonymousC: struct {\n\t\t\tc string `validate:\"required\"`\n\t\t}{\n\t\t\tc: \"\",\n\t\t},\n\t}\n\n\tEqual(t, tst.anonymousC.c, \"\")\n\n\terr := validate.Struct(tst)\n\tNotEqual(t, err, nil)\n\n\terrs := err.(ValidationErrors)\n\n\tEqual(t, len(errs), 1)\n\tAssertError(t, errs, \"Test.AnonymousB.BEE\", \"Test.AnonymousB.B\", \"BEE\", \"B\", \"required\")\n\n\tfe := getError(errs, \"Test.AnonymousB.BEE\", \"Test.AnonymousB.B\")\n\tNotEqual(t, fe, nil)\n\tEqual(t, fe.Field(), \"BEE\")\n\tEqual(t, fe.StructField(), \"B\")\n\n\ts := struct {\n\t\tc string `validate:\"required\"`\n\t}{\n\t\tc: \"\",\n\t}\n\n\terr = validate.Struct(s)\n\tEqual(t, err, nil)\n}\n\nfunc TestAnonymousSameStructDifferentTags(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype Test struct {\n\t\tA interface{}\n\t}\n\n\ttst := &Test{\n\t\tA: struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}{\n\t\t\tA: \"\",\n\t\t},\n\t}\n\n\terr := validate.Struct(tst)\n\tNotEqual(t, err, nil)\n\n\terrs := err.(ValidationErrors)\n\n\tEqual(t, len(errs), 1)\n\tAssertError(t, errs, \"Test.A.A\", \"Test.A.A\", \"A\", \"A\", \"required\")\n\n\ttst = &Test{\n\t\tA: struct {\n\t\t\tA string `validate:\"omitempty,required\"`\n\t\t}{\n\t\t\tA: \"\",\n\t\t},\n\t}\n\n\terr = validate.Struct(tst)\n\tEqual(t, err, nil)\n}\n\nfunc TestStructLevelReturnValidationErrors(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterStructValidation(StructValidationTestStructReturnValidationErrors, TestStructReturnValidationErrors{})\n\n\tinner2 := &TestStructReturnValidationErrorsInner2{\n\t\tString: \"I'm HERE\",\n\t}\n\n\tinner1 := &TestStructReturnValidationErrorsInner1{\n\t\tInner2: inner2,\n\t}\n\n\tval := &TestStructReturnValidationErrors{\n\t\tInner1: inner1,\n\t}\n\n\terrs := validate.Struct(val)\n\tEqual(t, errs, nil)\n\n\tinner2.String = \"\"\n\n\terrs = validate.Struct(val)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 2)\n\tAssertError(t, errs, \"TestStructReturnValidationErrors.Inner1.Inner2.String\", \"TestStructReturnValidationErrors.Inner1.Inner2.String\", \"String\", \"String\", \"required\")\n\t// this is an extra error reported from struct validation\n\tAssertError(t, errs, \"TestStructReturnValidationErrors.Inner1.TestStructReturnValidationErrorsInner2.String\", \"TestStructReturnValidationErrors.Inner1.TestStructReturnValidationErrorsInner2.String\", \"String\", \"String\", \"required\")\n}\n\nfunc TestStructLevelReturnValidationErrorsWithJSON(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\tvalidate.RegisterStructValidation(StructValidationTestStructReturnValidationErrors2, TestStructReturnValidationErrors{})\n\n\tinner2 := &TestStructReturnValidationErrorsInner2{\n\t\tString: \"I'm HERE\",\n\t}\n\n\tinner1 := &TestStructReturnValidationErrorsInner1{\n\t\tInner2: inner2,\n\t}\n\n\tval := &TestStructReturnValidationErrors{\n\t\tInner1: inner1,\n\t}\n\n\terrs := validate.Struct(val)\n\tEqual(t, errs, nil)\n\n\tinner2.String = \"\"\n\n\terrs = validate.Struct(val)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 2)\n\tAssertError(t, errs, \"TestStructReturnValidationErrors.Inner1JSON.Inner2.JSONString\", \"TestStructReturnValidationErrors.Inner1.Inner2.String\", \"JSONString\", \"String\", \"required\")\n\t// this is an extra error reported from struct validation, it's a badly formatted one, but on purpose\n\tAssertError(t, errs, \"TestStructReturnValidationErrors.Inner1JSON.TestStructReturnValidationErrorsInner2.JSONString\", \"TestStructReturnValidationErrors.Inner1.TestStructReturnValidationErrorsInner2.String\", \"JSONString\", \"String\", \"required\")\n\n\tfe := getError(errs, \"TestStructReturnValidationErrors.Inner1JSON.Inner2.JSONString\", \"TestStructReturnValidationErrors.Inner1.Inner2.String\")\n\tNotEqual(t, fe, nil)\n\n\t// check for proper JSON namespace\n\tEqual(t, fe.Field(), \"JSONString\")\n\tEqual(t, fe.StructField(), \"String\")\n\tEqual(t, fe.Namespace(), \"TestStructReturnValidationErrors.Inner1JSON.Inner2.JSONString\")\n\tEqual(t, fe.StructNamespace(), \"TestStructReturnValidationErrors.Inner1.Inner2.String\")\n\n\tfe = getError(errs, \"TestStructReturnValidationErrors.Inner1JSON.TestStructReturnValidationErrorsInner2.JSONString\", \"TestStructReturnValidationErrors.Inner1.TestStructReturnValidationErrorsInner2.String\")\n\tNotEqual(t, fe, nil)\n\n\t// check for proper JSON namespace\n\tEqual(t, fe.Field(), \"JSONString\")\n\tEqual(t, fe.StructField(), \"String\")\n\tEqual(t, fe.Namespace(), \"TestStructReturnValidationErrors.Inner1JSON.TestStructReturnValidationErrorsInner2.JSONString\")\n\tEqual(t, fe.StructNamespace(), \"TestStructReturnValidationErrors.Inner1.TestStructReturnValidationErrorsInner2.String\")\n}\n\nfunc TestStructLevelValidations(t *testing.T) {\n\tv1 := New()\n\tv1.RegisterStructValidation(StructValidationTestStruct, TestStruct{})\n\n\ttst := &TestStruct{\n\t\tString: \"good value\",\n\t}\n\n\terrs := v1.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestStruct.StringVal\", \"TestStruct.String\", \"StringVal\", \"String\", \"badvalueteststruct\")\n\n\tv2 := New()\n\tv2.RegisterStructValidation(StructValidationNoTestStructCustomName, TestStruct{})\n\n\terrs = v2.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestStruct.String\", \"TestStruct.String\", \"String\", \"String\", \"badvalueteststruct\")\n\n\tv3 := New()\n\tv3.RegisterStructValidation(StructValidationTestStructInvalid, TestStruct{})\n\n\terrs = v3.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestStruct.StringVal\", \"TestStruct.String\", \"StringVal\", \"String\", \"badvalueteststruct\")\n\n\tv4 := New()\n\tv4.RegisterStructValidation(StructValidationTestStructSuccess, TestStruct{})\n\n\terrs = v4.Struct(tst)\n\tEqual(t, errs, nil)\n}\n\nfunc TestAliasTags(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterAlias(\"iscoloralias\", \"hexcolor|rgb|rgba|hsl|hsla\")\n\n\ts := \"rgb(255,255,255)\"\n\terrs := validate.Var(s, \"iscoloralias\")\n\tEqual(t, errs, nil)\n\n\ts = \"\"\n\terrs = validate.Var(s, \"omitempty,iscoloralias\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgb(255,255,0)\"\n\terrs = validate.Var(s, \"iscoloralias,len=5\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"len\")\n\n\ttype Test struct {\n\t\tColor string `validate:\"iscoloralias\"`\n\t}\n\n\ttst := &Test{\n\t\tColor: \"#000\",\n\t}\n\n\terrs = validate.Struct(tst)\n\tEqual(t, errs, nil)\n\n\ttst.Color = \"cfvre\"\n\terrs = validate.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Color\", \"Test.Color\", \"Color\", \"Color\", \"iscoloralias\")\n\n\tfe := getError(errs, \"Test.Color\", \"Test.Color\")\n\tNotEqual(t, fe, nil)\n\tEqual(t, fe.ActualTag(), \"hexcolor|rgb|rgba|hsl|hsla\")\n\n\tvalidate.RegisterAlias(\"req\", \"required,dive,iscoloralias\")\n\tarr := []string{\"val1\", \"#fff\", \"#000\"}\n\n\terrs = validate.Var(arr, \"req\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"[0]\", \"[0]\", \"[0]\", \"[0]\", \"iscoloralias\")\n\n\tPanicMatches(t, func() { validate.RegisterAlias(\"exists!\", \"gt=5,lt=10\") }, \"Alias 'exists!' either contains restricted characters or is the same as a restricted tag needed for normal operation\")\n}\n\nfunc TestNilValidator(t *testing.T) {\n\ttype TestStruct struct {\n\t\tTest string `validate:\"required\"`\n\t}\n\n\tts := TestStruct{}\n\n\tvar val *Validate\n\n\tfn := func(fl FieldLevel) bool {\n\t\treturn fl.Parent().String() == fl.Field().String()\n\t}\n\n\tPanicMatches(t, func() { val.RegisterCustomTypeFunc(ValidateCustomType, MadeUpCustomType{}) }, \"runtime error: invalid memory address or nil pointer dereference\")\n\tPanicMatches(t, func() { _ = val.RegisterValidation(\"something\", fn) }, \"runtime error: invalid memory address or nil pointer dereference\")\n\tPanicMatches(t, func() { _ = val.Var(ts.Test, \"required\") }, \"runtime error: invalid memory address or nil pointer dereference\")\n\tPanicMatches(t, func() { _ = val.VarWithValue(\"test\", ts.Test, \"required\") }, \"runtime error: invalid memory address or nil pointer dereference\")\n\tPanicMatches(t, func() { _ = val.Struct(ts) }, \"runtime error: invalid memory address or nil pointer dereference\")\n\tPanicMatches(t, func() { _ = val.StructExcept(ts, \"Test\") }, \"runtime error: invalid memory address or nil pointer dereference\")\n\tPanicMatches(t, func() { _ = val.StructPartial(ts, \"Test\") }, \"runtime error: invalid memory address or nil pointer dereference\")\n}\n\nfunc TestStructPartial(t *testing.T) {\n\tp1 := []string{\n\t\t\"NoTag\",\n\t\t\"Required\",\n\t}\n\n\tp2 := []string{\n\t\t\"SubSlice[0].Test\",\n\t\t\"Sub\",\n\t\t\"SubIgnore\",\n\t\t\"Anonymous.A\",\n\t}\n\n\tp3 := []string{\n\t\t\"SubTest.Test\",\n\t}\n\n\tp4 := []string{\n\t\t\"A\",\n\t}\n\n\ttPartial := &TestPartial{\n\t\tNoTag:    \"NoTag\",\n\t\tRequired: \"Required\",\n\n\t\tSubSlice: []*SubTest{\n\t\t\t{\n\n\t\t\t\tTest: \"Required\",\n\t\t\t},\n\t\t\t{\n\n\t\t\t\tTest: \"Required\",\n\t\t\t},\n\t\t},\n\n\t\tSub: &SubTest{\n\t\t\tTest: \"1\",\n\t\t},\n\t\tSubIgnore: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA             string     `validate:\"required\"`\n\t\t\tASubSlice     []*SubTest `validate:\"required,dive\"`\n\t\t\tSubAnonStruct []struct {\n\t\t\t\tTest      string `validate:\"required\"`\n\t\t\t\tOtherTest string `validate:\"required\"`\n\t\t\t} `validate:\"required,dive\"`\n\t\t}{\n\t\t\tA: \"1\",\n\t\t\tASubSlice: []*SubTest{\n\t\t\t\t{\n\t\t\t\t\tTest: \"Required\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tTest: \"Required\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tSubAnonStruct: []struct {\n\t\t\t\tTest      string `validate:\"required\"`\n\t\t\t\tOtherTest string `validate:\"required\"`\n\t\t\t}{\n\t\t\t\t{\"Required\", \"RequiredOther\"},\n\t\t\t\t{\"Required\", \"RequiredOther\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tvalidate := New()\n\n\t// the following should all return no errors as everything is valid in\n\t// the default state\n\terrs := validate.StructPartialCtx(context.Background(), tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructPartial(tPartial, p2...)\n\tEqual(t, errs, nil)\n\n\t// this isn't really a robust test, but is meant to illustrate the ANON CASE below\n\terrs = validate.StructPartial(tPartial.SubSlice[0], p3...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructExceptCtx(context.Background(), tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructExcept(tPartial, p2...)\n\tEqual(t, errs, nil)\n\n\t// mod tPartial for required field and re-test making sure invalid fields are NOT required:\n\ttPartial.Required = \"\"\n\n\terrs = validate.StructExcept(tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructPartial(tPartial, p2...)\n\tEqual(t, errs, nil)\n\n\t// inversion and retesting Partial to generate failures:\n\terrs = validate.StructPartial(tPartial, p1...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.Required\", \"TestPartial.Required\", \"Required\", \"Required\", \"required\")\n\n\terrs = validate.StructExcept(tPartial, p2...)\n\tAssertError(t, errs, \"TestPartial.Required\", \"TestPartial.Required\", \"Required\", \"Required\", \"required\")\n\n\t// reset Required field, and set nested struct\n\ttPartial.Required = \"Required\"\n\ttPartial.Anonymous.A = \"\"\n\n\t// will pass as unset fields is not going to be tested\n\terrs = validate.StructPartial(tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructExcept(tPartial, p2...)\n\tEqual(t, errs, nil)\n\n\t// ANON CASE the response here is strange, it clearly does what it is being told to\n\terrs = validate.StructExcept(tPartial.Anonymous, p4...)\n\tEqual(t, errs, nil)\n\n\t// will fail as unset field is tested\n\terrs = validate.StructPartial(tPartial, p2...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.Anonymous.A\", \"TestPartial.Anonymous.A\", \"A\", \"A\", \"required\")\n\n\terrs = validate.StructExcept(tPartial, p1...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.Anonymous.A\", \"TestPartial.Anonymous.A\", \"A\", \"A\", \"required\")\n\n\t// reset nested struct and unset struct in slice\n\ttPartial.Anonymous.A = \"Required\"\n\ttPartial.SubSlice[0].Test = \"\"\n\n\t// these will pass as unset item is NOT tested\n\terrs = validate.StructPartial(tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructExcept(tPartial, p2...)\n\tEqual(t, errs, nil)\n\n\t// these will fail as unset item IS tested\n\terrs = validate.StructExcept(tPartial, p1...)\n\tAssertError(t, errs, \"TestPartial.SubSlice[0].Test\", \"TestPartial.SubSlice[0].Test\", \"Test\", \"Test\", \"required\")\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\n\terrs = validate.StructPartial(tPartial, p2...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.SubSlice[0].Test\", \"TestPartial.SubSlice[0].Test\", \"Test\", \"Test\", \"required\")\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\n\t// Unset second slice member concurrently to test dive behavior:\n\ttPartial.SubSlice[1].Test = \"\"\n\n\terrs = validate.StructPartial(tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\t// NOTE: When specifying nested items, it is still the users responsibility\n\t// to specify the dive tag, the library does not override this.\n\terrs = validate.StructExcept(tPartial, p2...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.SubSlice[1].Test\", \"TestPartial.SubSlice[1].Test\", \"Test\", \"Test\", \"required\")\n\n\terrs = validate.StructExcept(tPartial, p1...)\n\tEqual(t, len(errs.(ValidationErrors)), 2)\n\tAssertError(t, errs, \"TestPartial.SubSlice[0].Test\", \"TestPartial.SubSlice[0].Test\", \"Test\", \"Test\", \"required\")\n\tAssertError(t, errs, \"TestPartial.SubSlice[1].Test\", \"TestPartial.SubSlice[1].Test\", \"Test\", \"Test\", \"required\")\n\n\terrs = validate.StructPartial(tPartial, p2...)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"TestPartial.SubSlice[0].Test\", \"TestPartial.SubSlice[0].Test\", \"Test\", \"Test\", \"required\")\n\n\t// reset struct in slice, and unset struct in slice in unset position\n\ttPartial.SubSlice[0].Test = \"Required\"\n\n\t// these will pass as the unset item is NOT tested\n\terrs = validate.StructPartial(tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructPartial(tPartial, p2...)\n\tEqual(t, errs, nil)\n\n\t// testing for missing item by exception, yes it dives and fails\n\terrs = validate.StructExcept(tPartial, p1...)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"TestPartial.SubSlice[1].Test\", \"TestPartial.SubSlice[1].Test\", \"Test\", \"Test\", \"required\")\n\n\terrs = validate.StructExcept(tPartial, p2...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.SubSlice[1].Test\", \"TestPartial.SubSlice[1].Test\", \"Test\", \"Test\", \"required\")\n\n\ttPartial.SubSlice[1].Test = \"Required\"\n\n\ttPartial.Anonymous.SubAnonStruct[0].Test = \"\"\n\t// these will pass as the unset item is NOT tested\n\terrs = validate.StructPartial(tPartial, p1...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructPartial(tPartial, p2...)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructExcept(tPartial, p1...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.Anonymous.SubAnonStruct[0].Test\", \"TestPartial.Anonymous.SubAnonStruct[0].Test\", \"Test\", \"Test\", \"required\")\n\n\terrs = validate.StructExcept(tPartial, p2...)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.Anonymous.SubAnonStruct[0].Test\", \"TestPartial.Anonymous.SubAnonStruct[0].Test\", \"Test\", \"Test\", \"required\")\n\n\t// Test for unnamed struct\n\ttestStruct := &TestStruct{\n\t\tString: \"test\",\n\t}\n\tunnamedStruct := struct {\n\t\tString string `validate:\"required\" json:\"StringVal\"`\n\t}{String: \"test\"}\n\tcomposedUnnamedStruct := struct{ *TestStruct }{&TestStruct{String: \"test\"}}\n\n\terrs = validate.StructPartial(testStruct, \"String\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructPartial(unnamedStruct, \"String\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructPartial(composedUnnamedStruct, \"TestStruct.String\")\n\tEqual(t, errs, nil)\n\n\ttestStruct.String = \"\"\n\terrs = validate.StructPartial(testStruct, \"String\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestStruct.String\", \"TestStruct.String\", \"String\", \"String\", \"required\")\n\n\tunnamedStruct.String = \"\"\n\terrs = validate.StructPartial(unnamedStruct, \"String\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"String\", \"String\", \"String\", \"String\", \"required\")\n\n\tcomposedUnnamedStruct.String = \"\"\n\terrs = validate.StructPartial(composedUnnamedStruct, \"TestStruct.String\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestStruct.String\", \"TestStruct.String\", \"String\", \"String\", \"required\")\n}\n\nfunc TestCrossStructLteFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tCreatedAt *time.Time\n\t\tString    string\n\t\tInt       int\n\t\tUint      uint\n\t\tFloat     float64\n\t\tArray     []string\n\t}\n\n\ttype Test struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time `validate:\"ltecsfield=Inner.CreatedAt\"`\n\t\tString    string     `validate:\"ltecsfield=Inner.String\"`\n\t\tInt       int        `validate:\"ltecsfield=Inner.Int\"`\n\t\tUint      uint       `validate:\"ltecsfield=Inner.Uint\"`\n\t\tFloat     float64    `validate:\"ltecsfield=Inner.Float\"`\n\t\tArray     []string   `validate:\"ltecsfield=Inner.Array\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * 5)\n\n\tinner := &Inner{\n\t\tCreatedAt: &then,\n\t\tString:    \"abcd\",\n\t\tInt:       13,\n\t\tUint:      13,\n\t\tFloat:     1.13,\n\t\tArray:     []string{\"val1\", \"val2\"},\n\t}\n\n\ttest := &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t\tString:    \"abc\",\n\t\tInt:       12,\n\t\tUint:      12,\n\t\tFloat:     1.12,\n\t\tArray:     []string{\"val1\"},\n\t}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest.CreatedAt = &then\n\ttest.String = \"abcd\"\n\ttest.Int = 13\n\ttest.Uint = 13\n\ttest.Float = 1.13\n\ttest.Array = []string{\"val1\", \"val2\"}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\tafter := now.Add(time.Hour * 10)\n\n\ttest.CreatedAt = &after\n\ttest.String = \"abce\"\n\ttest.Int = 14\n\ttest.Uint = 14\n\ttest.Float = 1.14\n\ttest.Array = []string{\"val1\", \"val2\", \"val3\"}\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"ltecsfield\")\n\n\terrs = validate.VarWithValueCtx(context.Background(), 1, \"\", \"ltecsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltecsfield\")\n\n\t// this test is for the WARNING about unforeseen validation issues.\n\terrs = validate.VarWithValue(test, now, \"ltecsfield\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 6)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"ltecsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"ltecsfield\")\n\n\ttype Other struct {\n\t\tValue string\n\t}\n\n\ttype Test2 struct {\n\t\tValue Other\n\t\tTime  time.Time `validate:\"ltecsfield=Value\"`\n\t}\n\n\ttst := Test2{\n\t\tValue: Other{Value: \"StringVal\"},\n\t\tTime:  then,\n\t}\n\n\terrs = validate.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test2.Time\", \"Test2.Time\", \"Time\", \"Time\", \"ltecsfield\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"ltecsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"ltecsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"ltecsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltecsfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), -time.Minute, \"omitempty,ltecsfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct and an inner struct with time.Duration type fields.\n\n\ttype TimeDurationInner struct {\n\t\tDuration time.Duration\n\t}\n\tvar timeDurationInner *TimeDurationInner\n\n\ttype TimeDurationTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"ltecsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour + time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour - time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"ltecsfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"omitempty,ltecsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationOmitemptyTest *TimeDurationOmitemptyTest\n\n\ttimeDurationInner = &TimeDurationInner{-time.Minute}\n\ttimeDurationOmitemptyTest = &TimeDurationOmitemptyTest{timeDurationInner, time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestCrossStructLtFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tCreatedAt *time.Time\n\t\tString    string\n\t\tInt       int\n\t\tUint      uint\n\t\tFloat     float64\n\t\tArray     []string\n\t}\n\n\ttype Test struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time `validate:\"ltcsfield=Inner.CreatedAt\"`\n\t\tString    string     `validate:\"ltcsfield=Inner.String\"`\n\t\tInt       int        `validate:\"ltcsfield=Inner.Int\"`\n\t\tUint      uint       `validate:\"ltcsfield=Inner.Uint\"`\n\t\tFloat     float64    `validate:\"ltcsfield=Inner.Float\"`\n\t\tArray     []string   `validate:\"ltcsfield=Inner.Array\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * 5)\n\n\tinner := &Inner{\n\t\tCreatedAt: &then,\n\t\tString:    \"abcd\",\n\t\tInt:       13,\n\t\tUint:      13,\n\t\tFloat:     1.13,\n\t\tArray:     []string{\"val1\", \"val2\"},\n\t}\n\n\ttest := &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t\tString:    \"abc\",\n\t\tInt:       12,\n\t\tUint:      12,\n\t\tFloat:     1.12,\n\t\tArray:     []string{\"val1\"},\n\t}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest.CreatedAt = &then\n\ttest.String = \"abcd\"\n\ttest.Int = 13\n\ttest.Uint = 13\n\ttest.Float = 1.13\n\ttest.Array = []string{\"val1\", \"val2\"}\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"ltcsfield\")\n\n\terrs = validate.VarWithValue(1, \"\", \"ltcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltcsfield\")\n\n\t// this test is for the WARNING about unforeseen validation issues.\n\terrs = validate.VarWithValue(test, now, \"ltcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"ltcsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"ltcsfield\")\n\n\ttype Other struct {\n\t\tValue string\n\t}\n\n\ttype Test2 struct {\n\t\tValue Other\n\t\tTime  time.Time `validate:\"ltcsfield=Value\"`\n\t}\n\n\ttst := Test2{\n\t\tValue: Other{Value: \"StringVal\"},\n\t\tTime:  then,\n\t}\n\n\terrs = validate.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test2.Time\", \"Test2.Time\", \"Time\", \"Time\", \"ltcsfield\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"ltcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"ltcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltcsfield\")\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"ltcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltcsfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), -time.Minute, \"omitempty,ltcsfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct and an inner struct with time.Duration type fields.\n\n\ttype TimeDurationInner struct {\n\t\tDuration time.Duration\n\t}\n\tvar timeDurationInner *TimeDurationInner\n\n\ttype TimeDurationTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"ltcsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour + time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"ltcsfield\")\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour - time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"ltcsfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"omitempty,ltcsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationOmitemptyTest *TimeDurationOmitemptyTest\n\n\ttimeDurationInner = &TimeDurationInner{-time.Minute}\n\ttimeDurationOmitemptyTest = &TimeDurationOmitemptyTest{timeDurationInner, time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestCrossStructGteFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tCreatedAt *time.Time\n\t\tString    string\n\t\tInt       int\n\t\tUint      uint\n\t\tFloat     float64\n\t\tArray     []string\n\t}\n\n\ttype Test struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time `validate:\"gtecsfield=Inner.CreatedAt\"`\n\t\tString    string     `validate:\"gtecsfield=Inner.String\"`\n\t\tInt       int        `validate:\"gtecsfield=Inner.Int\"`\n\t\tUint      uint       `validate:\"gtecsfield=Inner.Uint\"`\n\t\tFloat     float64    `validate:\"gtecsfield=Inner.Float\"`\n\t\tArray     []string   `validate:\"gtecsfield=Inner.Array\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * -5)\n\n\tinner := &Inner{\n\t\tCreatedAt: &then,\n\t\tString:    \"abcd\",\n\t\tInt:       13,\n\t\tUint:      13,\n\t\tFloat:     1.13,\n\t\tArray:     []string{\"val1\", \"val2\"},\n\t}\n\n\ttest := &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t\tString:    \"abcde\",\n\t\tInt:       14,\n\t\tUint:      14,\n\t\tFloat:     1.14,\n\t\tArray:     []string{\"val1\", \"val2\", \"val3\"},\n\t}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest.CreatedAt = &then\n\ttest.String = \"abcd\"\n\ttest.Int = 13\n\ttest.Uint = 13\n\ttest.Float = 1.13\n\ttest.Array = []string{\"val1\", \"val2\"}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\tbefore := now.Add(time.Hour * -10)\n\n\ttest.CreatedAt = &before\n\ttest.String = \"abc\"\n\ttest.Int = 12\n\ttest.Uint = 12\n\ttest.Float = 1.12\n\ttest.Array = []string{\"val1\"}\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"gtecsfield\")\n\n\terrs = validate.VarWithValue(1, \"\", \"gtecsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtecsfield\")\n\n\t// this test is for the WARNING about unforeseen validation issues.\n\terrs = validate.VarWithValue(test, now, \"gtecsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"gtecsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"gtecsfield\")\n\n\ttype Other struct {\n\t\tValue string\n\t}\n\n\ttype Test2 struct {\n\t\tValue Other\n\t\tTime  time.Time `validate:\"gtecsfield=Value\"`\n\t}\n\n\ttst := Test2{\n\t\tValue: Other{Value: \"StringVal\"},\n\t\tTime:  then,\n\t}\n\n\terrs = validate.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test2.Time\", \"Test2.Time\", \"Time\", \"Time\", \"gtecsfield\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"gtecsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"gtecsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"gtecsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtecsfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Hour, \"omitempty,gtecsfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct and an inner struct with time.Duration type fields.\n\n\ttype TimeDurationInner struct {\n\t\tDuration time.Duration\n\t}\n\tvar timeDurationInner *TimeDurationInner\n\n\ttype TimeDurationTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"gtecsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour - time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour + time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"gtecsfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"omitempty,gtecsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationOmitemptyTest *TimeDurationOmitemptyTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationOmitemptyTest = &TimeDurationOmitemptyTest{timeDurationInner, time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestCrossStructGtFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tCreatedAt *time.Time\n\t\tString    string\n\t\tInt       int\n\t\tUint      uint\n\t\tFloat     float64\n\t\tArray     []string\n\t}\n\n\ttype Test struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time `validate:\"gtcsfield=Inner.CreatedAt\"`\n\t\tString    string     `validate:\"gtcsfield=Inner.String\"`\n\t\tInt       int        `validate:\"gtcsfield=Inner.Int\"`\n\t\tUint      uint       `validate:\"gtcsfield=Inner.Uint\"`\n\t\tFloat     float64    `validate:\"gtcsfield=Inner.Float\"`\n\t\tArray     []string   `validate:\"gtcsfield=Inner.Array\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * -5)\n\n\tinner := &Inner{\n\t\tCreatedAt: &then,\n\t\tString:    \"abcd\",\n\t\tInt:       13,\n\t\tUint:      13,\n\t\tFloat:     1.13,\n\t\tArray:     []string{\"val1\", \"val2\"},\n\t}\n\n\ttest := &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t\tString:    \"abcde\",\n\t\tInt:       14,\n\t\tUint:      14,\n\t\tFloat:     1.14,\n\t\tArray:     []string{\"val1\", \"val2\", \"val3\"},\n\t}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest.CreatedAt = &then\n\ttest.String = \"abcd\"\n\ttest.Int = 13\n\ttest.Uint = 13\n\ttest.Float = 1.13\n\ttest.Array = []string{\"val1\", \"val2\"}\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"gtcsfield\")\n\n\terrs = validate.VarWithValue(1, \"\", \"gtcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtcsfield\")\n\n\t// this test is for the WARNING about unforeseen validation issues.\n\terrs = validate.VarWithValue(test, now, \"gtcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.String\", \"Test.String\", \"String\", \"String\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Int\", \"Test.Int\", \"Int\", \"Int\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Uint\", \"Test.Uint\", \"Uint\", \"Uint\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Float\", \"Test.Float\", \"Float\", \"Float\", \"gtcsfield\")\n\tAssertError(t, errs, \"Test.Array\", \"Test.Array\", \"Array\", \"Array\", \"gtcsfield\")\n\n\ttype Other struct {\n\t\tValue string\n\t}\n\n\ttype Test2 struct {\n\t\tValue Other\n\t\tTime  time.Time `validate:\"gtcsfield=Value\"`\n\t}\n\n\ttst := Test2{\n\t\tValue: Other{Value: \"StringVal\"},\n\t\tTime:  then,\n\t}\n\n\terrs = validate.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test2.Time\", \"Test2.Time\", \"Time\", \"Time\", \"gtcsfield\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"gtcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"gtcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtcsfield\")\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"gtcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtcsfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Hour, \"omitempty,gtcsfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct and an inner struct with time.Duration type fields.\n\n\ttype TimeDurationInner struct {\n\t\tDuration time.Duration\n\t}\n\tvar timeDurationInner *TimeDurationInner\n\n\ttype TimeDurationTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"gtcsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour - time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"gtcsfield\")\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour + time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"gtcsfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"omitempty,gtcsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationOmitemptyTest *TimeDurationOmitemptyTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationOmitemptyTest = &TimeDurationOmitemptyTest{timeDurationInner, time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestCrossStructNeFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tCreatedAt *time.Time\n\t}\n\n\ttype Test struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time `validate:\"necsfield=Inner.CreatedAt\"`\n\t}\n\n\tnow := time.Now().UTC()\n\tthen := now.Add(time.Hour * 5)\n\n\tinner := &Inner{\n\t\tCreatedAt: &then,\n\t}\n\n\ttest := &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest.CreatedAt = &then\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"necsfield\")\n\n\tvar j uint64\n\tvar k float64\n\tvar j2 uint64\n\tvar k2 float64\n\ts := \"abcd\"\n\ti := 1\n\tj = 1\n\tk = 1.543\n\tb := true\n\tarr := []string{\"test\"}\n\n\ts2 := \"abcd\"\n\ti2 := 1\n\tj2 = 1\n\tk2 = 1.543\n\tb2 := true\n\tarr2 := []string{\"test\"}\n\tarr3 := []string{\"test\", \"test2\"}\n\tnow2 := now\n\n\terrs = validate.VarWithValue(s, s2, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(i2, i, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(j2, j, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(k2, k, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(b2, b, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(arr2, arr, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(now2, now, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(arr3, arr, \"necsfield\")\n\tEqual(t, errs, nil)\n\n\ttype SInner struct {\n\t\tName string\n\t}\n\n\ttype TStruct struct {\n\t\tInner     *SInner\n\t\tCreatedAt *time.Time `validate:\"necsfield=Inner\"`\n\t}\n\n\tsinner := &SInner{\n\t\tName: \"NAME\",\n\t}\n\n\ttest2 := &TStruct{\n\t\tInner:     sinner,\n\t\tCreatedAt: &now,\n\t}\n\n\terrs = validate.Struct(test2)\n\tEqual(t, errs, nil)\n\n\ttest2.Inner = nil\n\terrs = validate.Struct(test2)\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(nil, 1, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"necsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"necsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"necsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"necsfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Duration(0), \"omitempty,necsfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct and an inner struct with time.Duration type fields.\n\n\ttype TimeDurationInner struct {\n\t\tDuration time.Duration\n\t}\n\tvar timeDurationInner *TimeDurationInner\n\n\ttype TimeDurationTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"necsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour - time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour + time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"necsfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"omitempty,necsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationOmitemptyTest *TimeDurationOmitemptyTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Duration(0)}\n\ttimeDurationOmitemptyTest = &TimeDurationOmitemptyTest{timeDurationInner, time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestCrossStructEqFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tCreatedAt *time.Time\n\t}\n\n\ttype Test struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time `validate:\"eqcsfield=Inner.CreatedAt\"`\n\t}\n\n\tnow := time.Now().UTC()\n\n\tinner := &Inner{\n\t\tCreatedAt: &now,\n\t}\n\n\ttest := &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t}\n\n\terrs = validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\tnewTime := time.Now().Add(time.Hour).UTC()\n\ttest.CreatedAt = &newTime\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.CreatedAt\", \"Test.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"eqcsfield\")\n\n\tvar j uint64\n\tvar k float64\n\ts := \"abcd\"\n\ti := 1\n\tj = 1\n\tk = 1.543\n\tb := true\n\tarr := []string{\"test\"}\n\n\tvar j2 uint64\n\tvar k2 float64\n\ts2 := \"abcd\"\n\ti2 := 1\n\tj2 = 1\n\tk2 = 1.543\n\tb2 := true\n\tarr2 := []string{\"test\"}\n\tarr3 := []string{\"test\", \"test2\"}\n\tnow2 := now\n\n\terrs = validate.VarWithValue(s, s2, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(i2, i, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(j2, j, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(k2, k, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(b2, b, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(arr2, arr, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(now2, now, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(arr3, arr, \"eqcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqcsfield\")\n\n\ttype SInner struct {\n\t\tName string\n\t}\n\n\ttype TStruct struct {\n\t\tInner     *SInner\n\t\tCreatedAt *time.Time `validate:\"eqcsfield=Inner\"`\n\t}\n\n\tsinner := &SInner{\n\t\tName: \"NAME\",\n\t}\n\n\ttest2 := &TStruct{\n\t\tInner:     sinner,\n\t\tCreatedAt: &now,\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TStruct.CreatedAt\", \"TStruct.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"eqcsfield\")\n\n\ttest2.Inner = nil\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TStruct.CreatedAt\", \"TStruct.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"eqcsfield\")\n\n\terrs = validate.VarWithValue(nil, 1, \"eqcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqcsfield\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"eqcsfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"eqcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqcsfield\")\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"eqcsfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqcsfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Hour, \"omitempty,eqcsfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct and an inner struct with time.Duration type fields.\n\n\ttype TimeDurationInner struct {\n\t\tDuration time.Duration\n\t}\n\tvar timeDurationInner *TimeDurationInner\n\n\ttype TimeDurationTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"eqcsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour - time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"eqcsfield\")\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour + time.Minute}\n\ttimeDurationTest = &TimeDurationTest{timeDurationInner, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"eqcsfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tInner    *TimeDurationInner\n\t\tDuration time.Duration `validate:\"omitempty,eqcsfield=Inner.Duration\"`\n\t}\n\tvar timeDurationOmitemptyTest *TimeDurationOmitemptyTest\n\n\ttimeDurationInner = &TimeDurationInner{time.Hour}\n\ttimeDurationOmitemptyTest = &TimeDurationOmitemptyTest{timeDurationInner, time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestCrossNamespaceFieldValidation(t *testing.T) {\n\ttype SliceStruct struct {\n\t\tName string\n\t}\n\n\ttype Inner struct {\n\t\tCreatedAt        *time.Time\n\t\tSlice            []string\n\t\tSliceStructs     []*SliceStruct\n\t\tSliceSlice       [][]string\n\t\tSliceSliceStruct [][]*SliceStruct\n\t\tSliceMap         []map[string]string\n\t\tMap              map[string]string\n\t\tMapMap           map[string]map[string]string\n\t\tMapStructs       map[string]*SliceStruct\n\t\tMapMapStruct     map[string]map[string]*SliceStruct\n\t\tMapSlice         map[string][]string\n\t\tMapInt           map[int]string\n\t\tMapInt8          map[int8]string\n\t\tMapInt16         map[int16]string\n\t\tMapInt32         map[int32]string\n\t\tMapInt64         map[int64]string\n\t\tMapUint          map[uint]string\n\t\tMapUint8         map[uint8]string\n\t\tMapUint16        map[uint16]string\n\t\tMapUint32        map[uint32]string\n\t\tMapUint64        map[uint64]string\n\t\tMapFloat32       map[float32]string\n\t\tMapFloat64       map[float64]string\n\t\tMapBool          map[bool]string\n\t}\n\n\ttype Test struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time\n\t}\n\n\tnow := time.Now()\n\n\tinner := &Inner{\n\t\tCreatedAt:        &now,\n\t\tSlice:            []string{\"val1\", \"val2\", \"val3\"},\n\t\tSliceStructs:     []*SliceStruct{{Name: \"name1\"}, {Name: \"name2\"}, {Name: \"name3\"}},\n\t\tSliceSlice:       [][]string{{\"1\", \"2\", \"3\"}, {\"4\", \"5\", \"6\"}, {\"7\", \"8\", \"9\"}},\n\t\tSliceSliceStruct: [][]*SliceStruct{{{Name: \"name1\"}, {Name: \"name2\"}, {Name: \"name3\"}}, {{Name: \"name4\"}, {Name: \"name5\"}, {Name: \"name6\"}}, {{Name: \"name7\"}, {Name: \"name8\"}, {Name: \"name9\"}}},\n\t\tSliceMap:         []map[string]string{{\"key1\": \"val1\", \"key2\": \"val2\", \"key3\": \"val3\"}, {\"key4\": \"val4\", \"key5\": \"val5\", \"key6\": \"val6\"}},\n\t\tMap:              map[string]string{\"key1\": \"val1\", \"key2\": \"val2\", \"key3\": \"val3\"},\n\t\tMapStructs:       map[string]*SliceStruct{\"key1\": {Name: \"name1\"}, \"key2\": {Name: \"name2\"}, \"key3\": {Name: \"name3\"}},\n\t\tMapMap:           map[string]map[string]string{\"key1\": {\"key1-1\": \"val1\"}, \"key2\": {\"key2-1\": \"val2\"}, \"key3\": {\"key3-1\": \"val3\"}},\n\t\tMapMapStruct:     map[string]map[string]*SliceStruct{\"key1\": {\"key1-1\": {Name: \"name1\"}}, \"key2\": {\"key2-1\": {Name: \"name2\"}}, \"key3\": {\"key3-1\": {Name: \"name3\"}}},\n\t\tMapSlice:         map[string][]string{\"key1\": {\"1\", \"2\", \"3\"}, \"key2\": {\"4\", \"5\", \"6\"}, \"key3\": {\"7\", \"8\", \"9\"}},\n\t\tMapInt:           map[int]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapInt8:          map[int8]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapInt16:         map[int16]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapInt32:         map[int32]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapInt64:         map[int64]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapUint:          map[uint]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapUint8:         map[uint8]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapUint16:        map[uint16]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapUint32:        map[uint32]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapUint64:        map[uint64]string{1: \"val1\", 2: \"val2\", 3: \"val3\"},\n\t\tMapFloat32:       map[float32]string{1.01: \"val1\", 2.02: \"val2\", 3.03: \"val3\"},\n\t\tMapFloat64:       map[float64]string{1.01: \"val1\", 2.02: \"val2\", 3.03: \"val3\"},\n\t\tMapBool:          map[bool]string{true: \"val1\", false: \"val2\"},\n\t}\n\n\ttest := &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t}\n\n\tval := reflect.ValueOf(test)\n\n\tvd := New()\n\tv := &validate{\n\t\tv: vd,\n\t}\n\n\tcurrent, kind, _, ok := v.getStructFieldOKInternal(val, \"Inner.CreatedAt\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.Struct)\n\ttm, ok := current.Interface().(time.Time)\n\tEqual(t, ok, true)\n\tEqual(t, tm, now)\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.Slice[1]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\t_, _, _, ok = v.getStructFieldOKInternal(val, \"Inner.CrazyNonExistantField\")\n\tEqual(t, ok, false)\n\n\t_, _, _, ok = v.getStructFieldOKInternal(val, \"Inner.Slice[101]\")\n\tEqual(t, ok, false)\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.Map[key3]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val3\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapMap[key2][key2-1]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapStructs[key2].Name\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"name2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapMapStruct[key3][key3-1].Name\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"name3\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.SliceSlice[2][0]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"7\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.SliceSliceStruct[2][1].Name\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"name8\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.SliceMap[1][key5]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val5\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapSlice[key3][2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"9\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapInt[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapInt8[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapInt16[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapInt32[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapInt64[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapUint[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapUint8[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapUint16[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapUint32[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapUint64[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapFloat32[3.03]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val3\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapFloat64[2.02]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val2\")\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.MapBool[true]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.String)\n\tEqual(t, current.String(), \"val1\")\n\n\tinner = &Inner{\n\t\tCreatedAt:        &now,\n\t\tSlice:            []string{\"val1\", \"val2\", \"val3\"},\n\t\tSliceStructs:     []*SliceStruct{{Name: \"name1\"}, {Name: \"name2\"}, nil},\n\t\tSliceSlice:       [][]string{{\"1\", \"2\", \"3\"}, {\"4\", \"5\", \"6\"}, {\"7\", \"8\", \"9\"}},\n\t\tSliceSliceStruct: [][]*SliceStruct{{{Name: \"name1\"}, {Name: \"name2\"}, {Name: \"name3\"}}, {{Name: \"name4\"}, {Name: \"name5\"}, {Name: \"name6\"}}, {{Name: \"name7\"}, {Name: \"name8\"}, {Name: \"name9\"}}},\n\t\tSliceMap:         []map[string]string{{\"key1\": \"val1\", \"key2\": \"val2\", \"key3\": \"val3\"}, {\"key4\": \"val4\", \"key5\": \"val5\", \"key6\": \"val6\"}},\n\t\tMap:              map[string]string{\"key1\": \"val1\", \"key2\": \"val2\", \"key3\": \"val3\"},\n\t\tMapStructs:       map[string]*SliceStruct{\"key1\": {Name: \"name1\"}, \"key2\": {Name: \"name2\"}, \"key3\": {Name: \"name3\"}},\n\t\tMapMap:           map[string]map[string]string{\"key1\": {\"key1-1\": \"val1\"}, \"key2\": {\"key2-1\": \"val2\"}, \"key3\": {\"key3-1\": \"val3\"}},\n\t\tMapMapStruct:     map[string]map[string]*SliceStruct{\"key1\": {\"key1-1\": {Name: \"name1\"}}, \"key2\": {\"key2-1\": {Name: \"name2\"}}, \"key3\": {\"key3-1\": {Name: \"name3\"}}},\n\t\tMapSlice:         map[string][]string{\"key1\": {\"1\", \"2\", \"3\"}, \"key2\": {\"4\", \"5\", \"6\"}, \"key3\": {\"7\", \"8\", \"9\"}},\n\t}\n\n\ttest = &Test{\n\t\tInner:     inner,\n\t\tCreatedAt: nil,\n\t}\n\n\tval = reflect.ValueOf(test)\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.SliceStructs[2]\")\n\tEqual(t, ok, true)\n\tEqual(t, kind, reflect.Ptr)\n\tEqual(t, current.String(), \"<*validator.SliceStruct Value>\")\n\tEqual(t, current.IsNil(), true)\n\n\tcurrent, kind, _, ok = v.getStructFieldOKInternal(val, \"Inner.SliceStructs[2].Name\")\n\tEqual(t, ok, false)\n\tEqual(t, kind, reflect.Ptr)\n\tEqual(t, current.String(), \"<*validator.SliceStruct Value>\")\n\tEqual(t, current.IsNil(), true)\n\n\tPanicMatches(t, func() { v.getStructFieldOKInternal(reflect.ValueOf(1), \"crazyinput\") }, \"Invalid field namespace\")\n}\n\nfunc TestExistsValidation(t *testing.T) {\n\tjsonText := \"{ \\\"truthiness2\\\": true }\"\n\n\ttype Thing struct {\n\t\tTruthiness *bool `json:\"truthiness\" validate:\"required\"`\n\t}\n\n\tvar ting Thing\n\n\terr := json.Unmarshal([]byte(jsonText), &ting)\n\tEqual(t, err, nil)\n\tNotEqual(t, ting, nil)\n\tEqual(t, ting.Truthiness, nil)\n\n\tvalidate := New()\n\terrs := validate.Struct(ting)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Thing.Truthiness\", \"Thing.Truthiness\", \"Truthiness\", \"Truthiness\", \"required\")\n\n\tjsonText = \"{ \\\"truthiness\\\": true }\"\n\n\terr = json.Unmarshal([]byte(jsonText), &ting)\n\tEqual(t, err, nil)\n\tNotEqual(t, ting, nil)\n\tEqual(t, ting.Truthiness, true)\n\n\terrs = validate.Struct(ting)\n\tEqual(t, errs, nil)\n}\n\nfunc TestSQLValue2Validation(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, valuer{}, (*driver.Valuer)(nil), sql.NullString{}, sql.NullInt64{}, sql.NullBool{}, sql.NullFloat64{})\n\tvalidate.RegisterCustomTypeFunc(ValidateCustomType, MadeUpCustomType{})\n\tvalidate.RegisterCustomTypeFunc(OverrideIntTypeForSomeReason, 1)\n\n\tval := valuer{\n\t\tName: \"\",\n\t}\n\n\terrs := validate.Var(val, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tval.Name = \"Valid Name\"\n\terrs = validate.VarCtx(context.Background(), val, \"required\")\n\tEqual(t, errs, nil)\n\n\tval.Name = \"errorme\"\n\n\tPanicMatches(t, func() { _ = validate.Var(val, \"required\") }, \"SQL Driver Valuer error: some kind of error\")\n\n\tmyVal := valuer{\n\t\tName: \"\",\n\t}\n\n\terrs = validate.Var(myVal, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tcust := MadeUpCustomType{\n\t\tFirstName: \"Joey\",\n\t\tLastName:  \"Bloggs\",\n\t}\n\n\tc := CustomMadeUpStruct{MadeUp: cust, OverriddenInt: 2}\n\n\terrs = validate.Struct(c)\n\tEqual(t, errs, nil)\n\n\tc.MadeUp.FirstName = \"\"\n\tc.OverriddenInt = 1\n\n\terrs = validate.Struct(c)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 2)\n\tAssertError(t, errs, \"CustomMadeUpStruct.MadeUp\", \"CustomMadeUpStruct.MadeUp\", \"MadeUp\", \"MadeUp\", \"required\")\n\tAssertError(t, errs, \"CustomMadeUpStruct.OverriddenInt\", \"CustomMadeUpStruct.OverriddenInt\", \"OverriddenInt\", \"OverriddenInt\", \"gt\")\n}\n\nfunc TestSQLValueValidation(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterCustomTypeFunc(ValidateValuerType, (*driver.Valuer)(nil), valuer{})\n\tvalidate.RegisterCustomTypeFunc(ValidateCustomType, MadeUpCustomType{})\n\tvalidate.RegisterCustomTypeFunc(OverrideIntTypeForSomeReason, 1)\n\n\tval := valuer{\n\t\tName: \"\",\n\t}\n\n\terrs := validate.Var(val, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tval.Name = \"Valid Name\"\n\terrs = validate.Var(val, \"required\")\n\tEqual(t, errs, nil)\n\n\tval.Name = \"errorme\"\n\n\tPanicMatches(t, func() { errs = validate.Var(val, \"required\") }, \"SQL Driver Valuer error: some kind of error\")\n\n\tmyVal := valuer{\n\t\tName: \"\",\n\t}\n\n\terrs = validate.Var(myVal, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tcust := MadeUpCustomType{\n\t\tFirstName: \"Joey\",\n\t\tLastName:  \"Bloggs\",\n\t}\n\n\tc := CustomMadeUpStruct{MadeUp: cust, OverriddenInt: 2}\n\n\terrs = validate.Struct(c)\n\tEqual(t, errs, nil)\n\n\tc.MadeUp.FirstName = \"\"\n\tc.OverriddenInt = 1\n\n\terrs = validate.Struct(c)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 2)\n\tAssertError(t, errs, \"CustomMadeUpStruct.MadeUp\", \"CustomMadeUpStruct.MadeUp\", \"MadeUp\", \"MadeUp\", \"required\")\n\tAssertError(t, errs, \"CustomMadeUpStruct.OverriddenInt\", \"CustomMadeUpStruct.OverriddenInt\", \"OverriddenInt\", \"OverriddenInt\", \"gt\")\n\n\t// Test for empty field on structs without tags\n\ttype InvalidValuePanicSafetyTest struct {\n\t\tV valuer\n\t}\n\terrs = validate.Struct(InvalidValuePanicSafetyTest{})\n\tEqual(t, errs, nil)\n}\n\nfunc TestMACValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"3D:F2:C9:A6:B3:4F\", true},\n\t\t{\"3D-F2-C9-A6-B3:4F\", false},\n\t\t{\"123\", false},\n\t\t{\"\", false},\n\t\t{\"abacaba\", false},\n\t\t{\"00:25:96:FF:FE:12:34:56\", true},\n\t\t{\"0025:96FF:FE12:3456\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"mac\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d mac failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d mac failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"mac\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d mac failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIPValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"10.0.0.1\", true},\n\t\t{\"172.16.0.1\", true},\n\t\t{\"192.168.0.1\", true},\n\t\t{\"192.168.255.254\", true},\n\t\t{\"192.168.255.256\", false},\n\t\t{\"172.16.255.254\", true},\n\t\t{\"172.16.256.255\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652\", true},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652\", true},\n\t\t{\"2001:cdba::3257:9652\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ip\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ip failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ip failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ip\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ip failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIPv6Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"10.0.0.1\", false},\n\t\t{\"172.16.0.1\", false},\n\t\t{\"192.168.0.1\", false},\n\t\t{\"192.168.255.254\", false},\n\t\t{\"192.168.255.256\", false},\n\t\t{\"172.16.255.254\", false},\n\t\t{\"172.16.256.255\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652\", true},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652\", true},\n\t\t{\"2001:cdba::3257:9652\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ipv6\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ipv6 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ipv6 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ipv6\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ipv6 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIPv4Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"10.0.0.1\", true},\n\t\t{\"172.16.0.1\", true},\n\t\t{\"192.168.0.1\", true},\n\t\t{\"192.168.255.254\", true},\n\t\t{\"192.168.255.256\", false},\n\t\t{\"172.16.255.254\", true},\n\t\t{\"172.16.256.255\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652\", false},\n\t\t{\"2001:cdba::3257:9652\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ipv4\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ipv4 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ipv4 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ipv4\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ipv4 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCIDRValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"10.0.0.0/0\", true},\n\t\t{\"10.0.0.1/8\", true},\n\t\t{\"172.16.0.1/16\", true},\n\t\t{\"192.168.0.1/24\", true},\n\t\t{\"192.168.255.254/24\", true},\n\t\t{\"192.168.255.254/48\", false},\n\t\t{\"192.168.255.256/24\", false},\n\t\t{\"172.16.255.254/16\", true},\n\t\t{\"172.16.256.255/16\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652/64\", true},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652/256\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652/32\", true},\n\t\t{\"2001:cdba::3257:9652/16\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"cidr\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cidr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cidr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"cidr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d cidr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCIDRv6Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"10.0.0.0/0\", false},\n\t\t{\"10.0.0.1/8\", false},\n\t\t{\"172.16.0.1/16\", false},\n\t\t{\"192.168.0.1/24\", false},\n\t\t{\"192.168.255.254/24\", false},\n\t\t{\"192.168.255.254/48\", false},\n\t\t{\"192.168.255.256/24\", false},\n\t\t{\"172.16.255.254/16\", false},\n\t\t{\"172.16.256.255/16\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652/64\", true},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652/256\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652/32\", true},\n\t\t{\"2001:cdba::3257:9652/16\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"cidrv6\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cidrv6 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cidrv6 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"cidrv6\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d cidrv6 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCIDRv4Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"0.0.0.0/0\", true},\n\t\t{\"10.0.0.0/0\", false},\n\t\t{\"10.0.0.0/8\", true},\n\t\t{\"10.0.0.1/8\", false},\n\t\t{\"172.16.0.0/16\", true},\n\t\t{\"172.16.0.1/16\", false},\n\t\t{\"192.168.0.0/24\", true},\n\t\t{\"192.168.0.1/24\", false},\n\t\t{\"192.168.255.0/24\", true},\n\t\t{\"192.168.255.254/24\", false},\n\t\t{\"192.168.255.254/48\", false},\n\t\t{\"192.168.255.256/24\", false},\n\t\t{\"172.16.0.0/16\", true},\n\t\t{\"172.16.255.254/16\", false},\n\t\t{\"172.16.256.255/16\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652/64\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652/256\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652/32\", false},\n\t\t{\"2001:cdba::3257:9652/16\", false},\n\t\t{\"172.56.1.0/16\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"cidrv4\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cidrv4 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cidrv4 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"cidrv4\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d cidrv4 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTCPAddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\":80\", false},\n\t\t{\"127.0.0.1:80\", true},\n\t\t{\"[::1]:80\", true},\n\t\t{\"256.0.0.0:1\", false},\n\t\t{\"[::1]\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"tcp_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d tcp_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d tcp_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"tcp_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d tcp_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTCP6AddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\":80\", false},\n\t\t{\"127.0.0.1:80\", false},\n\t\t{\"[::1]:80\", true},\n\t\t{\"256.0.0.0:1\", false},\n\t\t{\"[::1]\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"tcp6_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d tcp6_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d tcp6_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"tcp6_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d tcp6_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTCP4AddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\":80\", false},\n\t\t{\"127.0.0.1:80\", true},\n\t\t{\"[::1]:80\", false}, // https://github.com/golang/go/issues/14037\n\t\t{\"256.0.0.0:1\", false},\n\t\t{\"[::1]\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"tcp4_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d tcp4_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Log(test.param, IsEqual(errs, nil))\n\t\t\t\tt.Fatalf(\"Index: %d tcp4_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"tcp4_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d tcp4_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUDPAddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\":80\", false},\n\t\t{\"127.0.0.1:80\", true},\n\t\t{\"[::1]:80\", true},\n\t\t{\"256.0.0.0:1\", false},\n\t\t{\"[::1]\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"udp_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d udp_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d udp_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"udp_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d udp_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUDP6AddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\":80\", false},\n\t\t{\"127.0.0.1:80\", false},\n\t\t{\"[::1]:80\", true},\n\t\t{\"256.0.0.0:1\", false},\n\t\t{\"[::1]\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"udp6_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d udp6_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d udp6_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"udp6_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d udp6_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUDP4AddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\":80\", false},\n\t\t{\"127.0.0.1:80\", true},\n\t\t{\"[::1]:80\", false}, // https://github.com/golang/go/issues/14037\n\t\t{\"256.0.0.0:1\", false},\n\t\t{\"[::1]\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"udp4_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d udp4_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Log(test.param, IsEqual(errs, nil))\n\t\t\t\tt.Fatalf(\"Index: %d udp4_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"udp4_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d udp4_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIPAddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"127.0.0.1\", true},\n\t\t{\"127.0.0.1:80\", false},\n\t\t{\"::1\", true},\n\t\t{\"256.0.0.0\", false},\n\t\t{\"localhost\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"ip_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ip_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ip_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ip_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ip_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIP6AddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"127.0.0.1\", false}, // https://github.com/golang/go/issues/14037\n\t\t{\"127.0.0.1:80\", false},\n\t\t{\"::1\", true},\n\t\t{\"0:0:0:0:0:0:0:1\", true},\n\t\t{\"256.0.0.0\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"ip6_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ip6_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ip6_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ip6_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ip6_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIP4AddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"127.0.0.1\", true},\n\t\t{\"127.0.0.1:80\", false},\n\t\t{\"::1\", false}, // https://github.com/golang/go/issues/14037\n\t\t{\"256.0.0.0\", false},\n\t\t{\"localhost\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"ip4_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ip4_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Log(test.param, IsEqual(errs, nil))\n\t\t\t\tt.Fatalf(\"Index: %d ip4_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ip4_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ip4_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUnixAddrValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"v.sock\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"unix_addr\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d unix_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Log(test.param, IsEqual(errs, nil))\n\t\t\t\tt.Fatalf(\"Index: %d unix_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"unix_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d unix_addr failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSliceMapArrayChanFuncPtrInterfaceRequiredValidation(t *testing.T) {\n\tvalidate := New()\n\n\tvar m map[string]string\n\n\terrs := validate.Var(m, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tm = map[string]string{}\n\terrs = validate.Var(m, \"required\")\n\tEqual(t, errs, nil)\n\n\tvar arr [5]string\n\terrs = validate.Var(arr, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tarr[0] = \"ok\"\n\terrs = validate.Var(arr, \"required\")\n\tEqual(t, errs, nil)\n\n\tvar s []string\n\terrs = validate.Var(s, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\ts = []string{}\n\terrs = validate.Var(s, \"required\")\n\tEqual(t, errs, nil)\n\n\tvar c chan string\n\terrs = validate.Var(c, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tc = make(chan string)\n\terrs = validate.Var(c, \"required\")\n\tEqual(t, errs, nil)\n\n\tvar tst *int\n\terrs = validate.Var(tst, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tone := 1\n\ttst = &one\n\terrs = validate.Var(tst, \"required\")\n\tEqual(t, errs, nil)\n\n\tvar iface interface{}\n\n\terrs = validate.Var(iface, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\terrs = validate.Var(iface, \"omitempty,required\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(iface, \"\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(nil, iface, \"\")\n\tEqual(t, errs, nil)\n\n\tvar f func(string)\n\n\terrs = validate.Var(f, \"required\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"required\")\n\n\tf = func(name string) {}\n\n\terrs = validate.Var(f, \"required\")\n\tEqual(t, errs, nil)\n}\n\nfunc TestDatePtrValidationIssueValidation(t *testing.T) {\n\ttype Test struct {\n\t\tLastViewed *time.Time\n\t\tReminder   *time.Time\n\t}\n\n\ttest := &Test{}\n\n\tvalidate := New()\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n}\n\nfunc TestCommaAndPipeObfuscationValidation(t *testing.T) {\n\ts := \"My Name Is, |joeybloggs|\"\n\n\tvalidate := New()\n\n\terrs := validate.Var(s, \"excludesall=0x2C\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"excludesall\")\n\n\terrs = validate.Var(s, \"excludesall=0x7C\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"excludesall\")\n}\n\nfunc TestBadKeyValidation(t *testing.T) {\n\ttype Test struct {\n\t\tName string `validate:\"required, \"`\n\t}\n\n\ttst := &Test{\n\t\tName: \"test\",\n\t}\n\n\tvalidate := New()\n\n\tPanicMatches(t, func() { _ = validate.Struct(tst) }, \"Undefined validation function ' ' on field 'Name'\")\n\n\ttype Test2 struct {\n\t\tName string `validate:\"required,,len=2\"`\n\t}\n\n\ttst2 := &Test2{\n\t\tName: \"test\",\n\t}\n\n\tPanicMatches(t, func() { _ = validate.Struct(tst2) }, \"Invalid validation tag on field 'Name'\")\n}\n\nfunc TestInterfaceErrValidation(t *testing.T) {\n\tvar v2 interface{} = 1\n\tvar v1 interface{} = v2\n\n\tvalidate := New()\n\terrs := validate.Var(v1, \"len=1\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(v2, \"len=1\")\n\tEqual(t, errs, nil)\n\n\ttype ExternalCMD struct {\n\t\tUserid string      `json:\"userid\"`\n\t\tAction uint32      `json:\"action\"`\n\t\tData   interface{} `json:\"data,omitempty\" validate:\"required\"`\n\t}\n\n\ts := &ExternalCMD{\n\t\tUserid: \"123456\",\n\t\tAction: 10000,\n\t\t// Data:   1,\n\t}\n\n\terrs = validate.Struct(s)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"ExternalCMD.Data\", \"ExternalCMD.Data\", \"Data\", \"Data\", \"required\")\n\n\ttype ExternalCMD2 struct {\n\t\tUserid string      `json:\"userid\"`\n\t\tAction uint32      `json:\"action\"`\n\t\tData   interface{} `json:\"data,omitempty\" validate:\"len=1\"`\n\t}\n\n\ts2 := &ExternalCMD2{\n\t\tUserid: \"123456\",\n\t\tAction: 10000,\n\t\t// Data:   1,\n\t}\n\n\terrs = validate.Struct(s2)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"ExternalCMD2.Data\", \"ExternalCMD2.Data\", \"Data\", \"Data\", \"len\")\n\n\ts3 := &ExternalCMD2{\n\t\tUserid: \"123456\",\n\t\tAction: 10000,\n\t\tData:   2,\n\t}\n\n\terrs = validate.Struct(s3)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"ExternalCMD2.Data\", \"ExternalCMD2.Data\", \"Data\", \"Data\", \"len\")\n\n\ttype Inner struct {\n\t\tName string `validate:\"required\"`\n\t}\n\n\tinner := &Inner{\n\t\tName: \"\",\n\t}\n\n\ts4 := &ExternalCMD{\n\t\tUserid: \"123456\",\n\t\tAction: 10000,\n\t\tData:   inner,\n\t}\n\n\terrs = validate.Struct(s4)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"ExternalCMD.Data.Name\", \"ExternalCMD.Data.Name\", \"Name\", \"Name\", \"required\")\n\n\ttype TestMapStructPtr struct {\n\t\tErrs map[int]interface{} `validate:\"gt=0,dive,required\"`\n\t}\n\n\tmip := map[int]interface{}{0: &Inner{\"ok\"}, 3: nil, 4: &Inner{\"ok\"}}\n\n\tmsp := &TestMapStructPtr{\n\t\tErrs: mip,\n\t}\n\n\terrs = validate.Struct(msp)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"TestMapStructPtr.Errs[3]\", \"TestMapStructPtr.Errs[3]\", \"Errs[3]\", \"Errs[3]\", \"required\")\n\n\ttype TestMultiDimensionalStructs struct {\n\t\tErrs [][]interface{} `validate:\"gt=0,dive,dive\"`\n\t}\n\n\tvar errStructArray [][]interface{}\n\n\terrStructArray = append(errStructArray, []interface{}{&Inner{\"ok\"}, &Inner{\"\"}, &Inner{\"\"}})\n\terrStructArray = append(errStructArray, []interface{}{&Inner{\"ok\"}, &Inner{\"\"}, &Inner{\"\"}})\n\n\ttms := &TestMultiDimensionalStructs{\n\t\tErrs: errStructArray,\n\t}\n\n\terrs = validate.Struct(tms)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 4)\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[0][1].Name\", \"TestMultiDimensionalStructs.Errs[0][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[0][2].Name\", \"TestMultiDimensionalStructs.Errs[0][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[1][1].Name\", \"TestMultiDimensionalStructs.Errs[1][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[1][2].Name\", \"TestMultiDimensionalStructs.Errs[1][2].Name\", \"Name\", \"Name\", \"required\")\n\n\ttype TestMultiDimensionalStructsPtr2 struct {\n\t\tErrs [][]*Inner `validate:\"gt=0,dive,dive,required\"`\n\t}\n\n\tvar errStructPtr2Array [][]*Inner\n\n\terrStructPtr2Array = append(errStructPtr2Array, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtr2Array = append(errStructPtr2Array, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtr2Array = append(errStructPtr2Array, []*Inner{{\"ok\"}, {\"\"}, nil})\n\n\ttmsp2 := &TestMultiDimensionalStructsPtr2{\n\t\tErrs: errStructPtr2Array,\n\t}\n\n\terrs = validate.Struct(tmsp2)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 6)\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[0][1].Name\", \"TestMultiDimensionalStructsPtr2.Errs[0][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[0][2].Name\", \"TestMultiDimensionalStructsPtr2.Errs[0][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[1][1].Name\", \"TestMultiDimensionalStructsPtr2.Errs[1][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[1][2].Name\", \"TestMultiDimensionalStructsPtr2.Errs[1][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[2][1].Name\", \"TestMultiDimensionalStructsPtr2.Errs[2][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[2][2]\", \"TestMultiDimensionalStructsPtr2.Errs[2][2]\", \"Errs[2][2]\", \"Errs[2][2]\", \"required\")\n\n\tm := map[int]interface{}{0: \"ok\", 3: \"\", 4: \"ok\"}\n\n\terrs = validate.Var(m, \"len=3,dive,len=2\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"[3]\", \"[3]\", \"[3]\", \"[3]\", \"len\")\n\n\terrs = validate.Var(m, \"len=2,dive,required\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"len\")\n\n\tarr := []interface{}{\"ok\", \"\", \"ok\"}\n\n\terrs = validate.Var(arr, \"len=3,dive,len=2\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"[1]\", \"[1]\", \"[1]\", \"[1]\", \"len\")\n\n\terrs = validate.Var(arr, \"len=2,dive,required\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"len\")\n\n\ttype MyStruct struct {\n\t\tA, B string\n\t\tC    interface{}\n\t}\n\n\tvar a MyStruct\n\n\ta.A = \"value\"\n\ta.C = \"nu\"\n\n\terrs = validate.Struct(a)\n\tEqual(t, errs, nil)\n}\n\nfunc TestMapDiveValidation(t *testing.T) {\n\tvalidate := New()\n\n\tn := map[int]interface{}{0: nil}\n\terrs := validate.Var(n, \"omitempty,required\")\n\tEqual(t, errs, nil)\n\n\tm := map[int]string{0: \"ok\", 3: \"\", 4: \"ok\"}\n\n\terrs = validate.Var(m, \"len=3,dive,required\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"[3]\", \"[3]\", \"[3]\", \"[3]\", \"required\")\n\n\terrs = validate.Var(m, \"len=2,dive,required\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"len\")\n\n\ttype Inner struct {\n\t\tName string `validate:\"required\"`\n\t}\n\n\ttype TestMapStruct struct {\n\t\tErrs map[int]Inner `validate:\"gt=0,dive\"`\n\t}\n\n\tmi := map[int]Inner{0: {\"ok\"}, 3: {\"\"}, 4: {\"ok\"}}\n\n\tms := &TestMapStruct{\n\t\tErrs: mi,\n\t}\n\n\terrs = validate.Struct(ms)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"TestMapStruct.Errs[3].Name\", \"TestMapStruct.Errs[3].Name\", \"Name\", \"Name\", \"required\")\n\n\t// for full test coverage\n\ts := fmt.Sprint(errs.Error())\n\tNotEqual(t, s, \"\")\n\n\ttype TestMapInterface struct {\n\t\tErrs map[int]interface{} `validate:\"dive\"`\n\t}\n\n\tmit := map[int]interface{}{0: Inner{\"ok\"}, 1: Inner{\"\"}, 3: nil, 5: \"string\", 6: 33}\n\n\tmsi := &TestMapInterface{\n\t\tErrs: mit,\n\t}\n\n\terrs = validate.Struct(msi)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"TestMapInterface.Errs[1].Name\", \"TestMapInterface.Errs[1].Name\", \"Name\", \"Name\", \"required\")\n\n\ttype TestMapTimeStruct struct {\n\t\tErrs map[int]*time.Time `validate:\"gt=0,dive,required\"`\n\t}\n\n\tt1 := time.Now().UTC()\n\n\tmta := map[int]*time.Time{0: &t1, 3: nil, 4: nil}\n\n\tmt := &TestMapTimeStruct{\n\t\tErrs: mta,\n\t}\n\n\terrs = validate.Struct(mt)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 2)\n\tAssertError(t, errs, \"TestMapTimeStruct.Errs[3]\", \"TestMapTimeStruct.Errs[3]\", \"Errs[3]\", \"Errs[3]\", \"required\")\n\tAssertError(t, errs, \"TestMapTimeStruct.Errs[4]\", \"TestMapTimeStruct.Errs[4]\", \"Errs[4]\", \"Errs[4]\", \"required\")\n\n\ttype TestMapStructPtr struct {\n\t\tErrs map[int]*Inner `validate:\"gt=0,dive,required\"`\n\t}\n\n\tmip := map[int]*Inner{0: {\"ok\"}, 3: nil, 4: {\"ok\"}}\n\n\tmsp := &TestMapStructPtr{\n\t\tErrs: mip,\n\t}\n\n\terrs = validate.Struct(msp)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"TestMapStructPtr.Errs[3]\", \"TestMapStructPtr.Errs[3]\", \"Errs[3]\", \"Errs[3]\", \"required\")\n\n\ttype TestMapStructPtr2 struct {\n\t\tErrs map[int]*Inner `validate:\"gt=0,dive,omitempty,required\"`\n\t}\n\n\tmip2 := map[int]*Inner{0: {\"ok\"}, 3: nil, 4: {\"ok\"}}\n\n\tmsp2 := &TestMapStructPtr2{\n\t\tErrs: mip2,\n\t}\n\n\terrs = validate.Struct(msp2)\n\tEqual(t, errs, nil)\n\n\tv2 := New()\n\tv2.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype MapDiveJSONTest struct {\n\t\tMap map[string]string `validate:\"required,gte=1,dive,gte=1\" json:\"MyName\"`\n\t}\n\n\tmdjt := &MapDiveJSONTest{\n\t\tMap: map[string]string{\n\t\t\t\"Key1\": \"Value1\",\n\t\t\t\"Key2\": \"\",\n\t\t},\n\t}\n\n\terr := v2.Struct(mdjt)\n\tNotEqual(t, err, nil)\n\n\terrs = err.(ValidationErrors)\n\tfe := getError(errs, \"MapDiveJSONTest.MyName[Key2]\", \"MapDiveJSONTest.Map[Key2]\")\n\tNotEqual(t, fe, nil)\n\tEqual(t, fe.Tag(), \"gte\")\n\tEqual(t, fe.ActualTag(), \"gte\")\n\tEqual(t, fe.Field(), \"MyName[Key2]\")\n\tEqual(t, fe.StructField(), \"Map[Key2]\")\n}\n\nfunc TestArrayDiveValidation(t *testing.T) {\n\tvalidate := New()\n\n\tarr := []string{\"ok\", \"\", \"ok\"}\n\n\terrs := validate.Var(arr, \"len=3,dive,required\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"[1]\", \"[1]\", \"[1]\", \"[1]\", \"required\")\n\n\terrs = validate.Var(arr, \"len=2,dive,required\")\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"len\")\n\n\ttype BadDive struct {\n\t\tName string `validate:\"dive\"`\n\t}\n\n\tbd := &BadDive{\n\t\tName: \"TEST\",\n\t}\n\n\tPanicMatches(t, func() { _ = validate.Struct(bd) }, \"dive error! can't dive on a non slice or map\")\n\n\ttype Test struct {\n\t\tErrs []string `validate:\"gt=0,dive,required\"`\n\t}\n\n\ttest := &Test{\n\t\tErrs: []string{\"ok\", \"\", \"ok\"},\n\t}\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"Test.Errs[1]\", \"Test.Errs[1]\", \"Errs[1]\", \"Errs[1]\", \"required\")\n\n\ttest = &Test{\n\t\tErrs: []string{\"ok\", \"ok\", \"\"},\n\t}\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"Test.Errs[2]\", \"Test.Errs[2]\", \"Errs[2]\", \"Errs[2]\", \"required\")\n\n\ttype TestMultiDimensional struct {\n\t\tErrs [][]string `validate:\"gt=0,dive,dive,required\"`\n\t}\n\n\tvar errArray [][]string\n\n\terrArray = append(errArray, []string{\"ok\", \"\", \"\"})\n\terrArray = append(errArray, []string{\"ok\", \"\", \"\"})\n\n\ttm := &TestMultiDimensional{\n\t\tErrs: errArray,\n\t}\n\n\terrs = validate.Struct(tm)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 4)\n\tAssertError(t, errs, \"TestMultiDimensional.Errs[0][1]\", \"TestMultiDimensional.Errs[0][1]\", \"Errs[0][1]\", \"Errs[0][1]\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensional.Errs[0][2]\", \"TestMultiDimensional.Errs[0][2]\", \"Errs[0][2]\", \"Errs[0][2]\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensional.Errs[1][1]\", \"TestMultiDimensional.Errs[1][1]\", \"Errs[1][1]\", \"Errs[1][1]\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensional.Errs[1][2]\", \"TestMultiDimensional.Errs[1][2]\", \"Errs[1][2]\", \"Errs[1][2]\", \"required\")\n\n\ttype Inner struct {\n\t\tName string `validate:\"required\"`\n\t}\n\n\ttype TestMultiDimensionalStructs struct {\n\t\tErrs [][]Inner `validate:\"gt=0,dive,dive\"`\n\t}\n\n\tvar errStructArray [][]Inner\n\n\terrStructArray = append(errStructArray, []Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructArray = append(errStructArray, []Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\n\ttms := &TestMultiDimensionalStructs{\n\t\tErrs: errStructArray,\n\t}\n\n\terrs = validate.Struct(tms)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 4)\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[0][1].Name\", \"TestMultiDimensionalStructs.Errs[0][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[0][2].Name\", \"TestMultiDimensionalStructs.Errs[0][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[1][1].Name\", \"TestMultiDimensionalStructs.Errs[1][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructs.Errs[1][2].Name\", \"TestMultiDimensionalStructs.Errs[1][2].Name\", \"Name\", \"Name\", \"required\")\n\n\ttype TestMultiDimensionalStructsPtr struct {\n\t\tErrs [][]*Inner `validate:\"gt=0,dive,dive\"`\n\t}\n\n\tvar errStructPtrArray [][]*Inner\n\n\terrStructPtrArray = append(errStructPtrArray, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtrArray = append(errStructPtrArray, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtrArray = append(errStructPtrArray, []*Inner{{\"ok\"}, {\"\"}, nil})\n\n\ttmsp := &TestMultiDimensionalStructsPtr{\n\t\tErrs: errStructPtrArray,\n\t}\n\n\terrs = validate.Struct(tmsp)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 5)\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr.Errs[0][1].Name\", \"TestMultiDimensionalStructsPtr.Errs[0][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr.Errs[0][2].Name\", \"TestMultiDimensionalStructsPtr.Errs[0][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr.Errs[1][1].Name\", \"TestMultiDimensionalStructsPtr.Errs[1][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr.Errs[1][2].Name\", \"TestMultiDimensionalStructsPtr.Errs[1][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr.Errs[2][1].Name\", \"TestMultiDimensionalStructsPtr.Errs[2][1].Name\", \"Name\", \"Name\", \"required\")\n\n\t// for full test coverage\n\ts := fmt.Sprint(errs.Error())\n\tNotEqual(t, s, \"\")\n\n\ttype TestMultiDimensionalStructsPtr2 struct {\n\t\tErrs [][]*Inner `validate:\"gt=0,dive,dive,required\"`\n\t}\n\n\tvar errStructPtr2Array [][]*Inner\n\n\terrStructPtr2Array = append(errStructPtr2Array, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtr2Array = append(errStructPtr2Array, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtr2Array = append(errStructPtr2Array, []*Inner{{\"ok\"}, {\"\"}, nil})\n\n\ttmsp2 := &TestMultiDimensionalStructsPtr2{\n\t\tErrs: errStructPtr2Array,\n\t}\n\n\terrs = validate.Struct(tmsp2)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 6)\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[0][1].Name\", \"TestMultiDimensionalStructsPtr2.Errs[0][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[0][2].Name\", \"TestMultiDimensionalStructsPtr2.Errs[0][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[1][1].Name\", \"TestMultiDimensionalStructsPtr2.Errs[1][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[1][2].Name\", \"TestMultiDimensionalStructsPtr2.Errs[1][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[2][1].Name\", \"TestMultiDimensionalStructsPtr2.Errs[2][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr2.Errs[2][2]\", \"TestMultiDimensionalStructsPtr2.Errs[2][2]\", \"Errs[2][2]\", \"Errs[2][2]\", \"required\")\n\n\ttype TestMultiDimensionalStructsPtr3 struct {\n\t\tErrs [][]*Inner `validate:\"gt=0,dive,dive,omitempty\"`\n\t}\n\n\tvar errStructPtr3Array [][]*Inner\n\n\terrStructPtr3Array = append(errStructPtr3Array, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtr3Array = append(errStructPtr3Array, []*Inner{{\"ok\"}, {\"\"}, {\"\"}})\n\terrStructPtr3Array = append(errStructPtr3Array, []*Inner{{\"ok\"}, {\"\"}, nil})\n\n\ttmsp3 := &TestMultiDimensionalStructsPtr3{\n\t\tErrs: errStructPtr3Array,\n\t}\n\n\terrs = validate.Struct(tmsp3)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 5)\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr3.Errs[0][1].Name\", \"TestMultiDimensionalStructsPtr3.Errs[0][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr3.Errs[0][2].Name\", \"TestMultiDimensionalStructsPtr3.Errs[0][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr3.Errs[1][1].Name\", \"TestMultiDimensionalStructsPtr3.Errs[1][1].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr3.Errs[1][2].Name\", \"TestMultiDimensionalStructsPtr3.Errs[1][2].Name\", \"Name\", \"Name\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalStructsPtr3.Errs[2][1].Name\", \"TestMultiDimensionalStructsPtr3.Errs[2][1].Name\", \"Name\", \"Name\", \"required\")\n\n\ttype TestMultiDimensionalTimeTime struct {\n\t\tErrs [][]*time.Time `validate:\"gt=0,dive,dive,required\"`\n\t}\n\n\tvar errTimePtr3Array [][]*time.Time\n\n\tt1 := time.Now().UTC()\n\tt2 := time.Now().UTC()\n\tt3 := time.Now().UTC().Add(time.Hour * 24)\n\n\terrTimePtr3Array = append(errTimePtr3Array, []*time.Time{&t1, &t2, &t3})\n\terrTimePtr3Array = append(errTimePtr3Array, []*time.Time{&t1, &t2, nil})\n\terrTimePtr3Array = append(errTimePtr3Array, []*time.Time{&t1, nil, nil})\n\n\ttmtp3 := &TestMultiDimensionalTimeTime{\n\t\tErrs: errTimePtr3Array,\n\t}\n\n\terrs = validate.Struct(tmtp3)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 3)\n\tAssertError(t, errs, \"TestMultiDimensionalTimeTime.Errs[1][2]\", \"TestMultiDimensionalTimeTime.Errs[1][2]\", \"Errs[1][2]\", \"Errs[1][2]\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalTimeTime.Errs[2][1]\", \"TestMultiDimensionalTimeTime.Errs[2][1]\", \"Errs[2][1]\", \"Errs[2][1]\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalTimeTime.Errs[2][2]\", \"TestMultiDimensionalTimeTime.Errs[2][2]\", \"Errs[2][2]\", \"Errs[2][2]\", \"required\")\n\n\ttype TestMultiDimensionalTimeTime2 struct {\n\t\tErrs [][]*time.Time `validate:\"gt=0,dive,dive,required\"`\n\t}\n\n\tvar errTimeArray [][]*time.Time\n\n\tt1 = time.Now().UTC()\n\tt2 = time.Now().UTC()\n\tt3 = time.Now().UTC().Add(time.Hour * 24)\n\n\terrTimeArray = append(errTimeArray, []*time.Time{&t1, &t2, &t3})\n\terrTimeArray = append(errTimeArray, []*time.Time{&t1, &t2, nil})\n\terrTimeArray = append(errTimeArray, []*time.Time{&t1, nil, nil})\n\n\ttmtp := &TestMultiDimensionalTimeTime2{\n\t\tErrs: errTimeArray,\n\t}\n\n\terrs = validate.Struct(tmtp)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 3)\n\tAssertError(t, errs, \"TestMultiDimensionalTimeTime2.Errs[1][2]\", \"TestMultiDimensionalTimeTime2.Errs[1][2]\", \"Errs[1][2]\", \"Errs[1][2]\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalTimeTime2.Errs[2][1]\", \"TestMultiDimensionalTimeTime2.Errs[2][1]\", \"Errs[2][1]\", \"Errs[2][1]\", \"required\")\n\tAssertError(t, errs, \"TestMultiDimensionalTimeTime2.Errs[2][2]\", \"TestMultiDimensionalTimeTime2.Errs[2][2]\", \"Errs[2][2]\", \"Errs[2][2]\", \"required\")\n}\n\nfunc TestNilStructPointerValidation(t *testing.T) {\n\ttype Inner struct {\n\t\tData string\n\t}\n\n\ttype Outer struct {\n\t\tInner *Inner `validate:\"omitempty\"`\n\t}\n\n\tinner := &Inner{\n\t\tData: \"test\",\n\t}\n\n\touter := &Outer{\n\t\tInner: inner,\n\t}\n\n\tvalidate := New()\n\terrs := validate.Struct(outer)\n\tEqual(t, errs, nil)\n\n\touter = &Outer{\n\t\tInner: nil,\n\t}\n\n\terrs = validate.Struct(outer)\n\tEqual(t, errs, nil)\n\n\ttype Inner2 struct {\n\t\tData string\n\t}\n\n\ttype Outer2 struct {\n\t\tInner2 *Inner2 `validate:\"required\"`\n\t}\n\n\tinner2 := &Inner2{\n\t\tData: \"test\",\n\t}\n\n\touter2 := &Outer2{\n\t\tInner2: inner2,\n\t}\n\n\terrs = validate.Struct(outer2)\n\tEqual(t, errs, nil)\n\n\touter2 = &Outer2{\n\t\tInner2: nil,\n\t}\n\n\terrs = validate.Struct(outer2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Outer2.Inner2\", \"Outer2.Inner2\", \"Inner2\", \"Inner2\", \"required\")\n\n\ttype Inner3 struct {\n\t\tData string\n\t}\n\n\ttype Outer3 struct {\n\t\tInner3 *Inner3\n\t}\n\n\tinner3 := &Inner3{\n\t\tData: \"test\",\n\t}\n\n\touter3 := &Outer3{\n\t\tInner3: inner3,\n\t}\n\n\terrs = validate.Struct(outer3)\n\tEqual(t, errs, nil)\n\n\ttype Inner4 struct {\n\t\tData string\n\t}\n\n\ttype Outer4 struct {\n\t\tInner4 *Inner4 `validate:\"-\"`\n\t}\n\n\tinner4 := &Inner4{\n\t\tData: \"test\",\n\t}\n\n\touter4 := &Outer4{\n\t\tInner4: inner4,\n\t}\n\n\terrs = validate.Struct(outer4)\n\tEqual(t, errs, nil)\n}\n\nfunc TestSSNValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"00-90-8787\", false},\n\t\t{\"66690-76\", false},\n\t\t{\"191 60 2869\", true},\n\t\t{\"191-60-2869\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ssn\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SSN failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SSN failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ssn\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Latitude failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestLongitudeValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"-180.000\", true},\n\t\t{\"180.1\", false},\n\t\t{\"+73.234\", true},\n\t\t{\"+382.3811\", false},\n\t\t{\"23.11111111\", true},\n\t\t{uint(180), true},\n\t\t{float32(-180.0), true},\n\t\t{-180, true},\n\t\t{180.1, false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"longitude\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Longitude failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Longitude failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"longitude\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Longitude failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() { _ = validate.Var(true, \"longitude\") }, \"Bad field type bool\")\n}\n\nfunc TestLatitudeValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"-90.000\", true},\n\t\t{\"+90\", true},\n\t\t{\"47.1231231\", true},\n\t\t{\"+99.9\", false},\n\t\t{\"108\", false},\n\t\t{uint(90), true},\n\t\t{float32(-90.0), true},\n\t\t{-90, true},\n\t\t{90.1, false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"latitude\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Latitude failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Latitude failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"latitude\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Latitude failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() { _ = validate.Var(true, \"latitude\") }, \"Bad field type bool\")\n}\n\nfunc TestDataURIValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"data:image/png;base64,TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdC4=\", true},\n\t\t{\"data:text/plain;base64,Vml2YW11cyBmZXJtZW50dW0gc2VtcGVyIHBvcnRhLg==\", true},\n\t\t{\"image/gif;base64,U3VzcGVuZGlzc2UgbGVjdHVzIGxlbw==\", false},\n\t\t{\n\t\t\t\"data:image/gif;base64,MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuMPNS1Ufof9EW/M98FNw\" +\n\t\t\t\t\"UAKrwflsqVxaxQjBQnHQmiI7Vac40t8x7pIb8gLGV6wL7sBTJiPovJ0V7y7oc0Ye\" +\n\t\t\t\t\"rhKh0Rm4skP2z/jHwwZICgGzBvA0rH8xlhUiTvcwDCJ0kc+fh35hNt8srZQM4619\" +\n\t\t\t\t\"FTgB66Xmp4EtVyhpQV+t02g6NzK72oZI0vnAvqhpkxLeLiMCyrI416wHm5Tkukhx\" +\n\t\t\t\t\"QmcL2a6hNOyu0ixX/x2kSFXApEnVrJ+/IxGyfyw8kf4N2IZpW5nEP847lpfj0SZZ\" +\n\t\t\t\t\"Fwrd1mnfnDbYohX2zRptLy2ZUn06Qo9pkG5ntvFEPo9bfZeULtjYzIl6K8gJ2uGZ\" + \"HQIDAQAB\", true,\n\t\t},\n\t\t{\"data:image/png;base64,12345\", false},\n\t\t{\"\", false},\n\t\t{\"data:text,:;base85,U3VzcGVuZGlzc2UgbGVjdHVzIGxlbw==\", false},\n\t\t{\"data:image/jpeg;key=value;base64,UEsDBBQAAAAI\", true},\n\t\t{\"data:image/jpeg;key=value,UEsDBBQAAAAI\", true},\n\t\t{\"data:;base64;sdfgsdfgsdfasdfa=s,UEsDBBQAAAAI\", true},\n\t\t{\"data:,UEsDBBQAAAAI\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"datauri\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d DataURI failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d DataURI failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"datauri\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d DataURI failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestMultibyteValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"abc\", false},\n\t\t{\"123\", false},\n\t\t{\"<>@;.-=\", false},\n\t\t{\"ひらがな・カタカナ、．漢字\", true},\n\t\t{\"あいうえお foobar\", true},\n\t\t{\"test＠example.com\", true},\n\t\t{\"test＠example.com\", true},\n\t\t{\"1234abcDEｘｙｚ\", true},\n\t\t{\"ｶﾀｶﾅ\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"multibyte\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Multibyte failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Multibyte failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"multibyte\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Multibyte failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPrintableASCIIValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"ｆｏｏbar\", false},\n\t\t{\"ｘｙｚ０９８\", false},\n\t\t{\"１２３456\", false},\n\t\t{\"ｶﾀｶﾅ\", false},\n\t\t{\"foobar\", true},\n\t\t{\"0987654321\", true},\n\t\t{\"test@example.com\", true},\n\t\t{\"1234abcDEF\", true},\n\t\t{\"newline\\n\", false},\n\t\t{\"\\x19test\\x7F\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"printascii\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Printable ASCII failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Printable ASCII failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"printascii\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Printable ASCII failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestASCIIValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"ｆｏｏbar\", false},\n\t\t{\"ｘｙｚ０９８\", false},\n\t\t{\"１２３456\", false},\n\t\t{\"ｶﾀｶﾅ\", false},\n\t\t{\"foobar\", true},\n\t\t{\"0987654321\", true},\n\t\t{\"test@example.com\", true},\n\t\t{\"1234abcDEF\", true},\n\t\t{\"\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ascii\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ASCII failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ASCII failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ascii\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ASCII failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUUID5Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"9c858901-8a57-4791-81fe-4c455b099bc9\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"987fbc97-4bed-5078-af07-9141ba07c9f3\", true},\n\t\t{\"987fbc97-4bed-5078-9f07-9141ba07c9f3\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid5\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID5 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID5 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid5\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUID5 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUUID4Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-5078-af07-9141ba07c9f3\", false},\n\t\t{\"934859\", false},\n\t\t{\"57b73598-8764-4ad0-a76a-679bb6640eb1\", true},\n\t\t{\"625e63f3-58f5-40b7-83a1-a72ad31acffb\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid4\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID4 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID4 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid4\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUID4 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUUID3Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"412452646\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-4078-8f07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid3\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID3 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID3 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid3\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUID3 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ntype uuidTestType struct {\n\tval string\n}\n\nfunc (u uuidTestType) String() string {\n\treturn u.val\n}\n\ntype uuidAlias string\n\nfunc (u uuidAlias) String() string {\n\treturn \"This is a UUID \" + string(u)\n}\n\nvar _ fmt.Stringer = uuidTestType{}\nvar _ fmt.Stringer = uuidAlias(\"\")\n\nfunc TestUUIDValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3xxx\", false},\n\t\t{\"a987fbc94bed3078cf079141ba07c9f3\", false},\n\t\t{\"934859\", false},\n\t\t{\"987fbc9-4bed-3078-cf07a-9141ba07c9f3\", false},\n\t\t{\"aaaaaaaa-1111-1111-aaag-111111111111\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9f3\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUID failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test UUID validation on uuid structs type that implements Stringer interface.\n\tstructWithValidUUID := struct {\n\t\tUUID uuidTestType `validate:\"uuid\"`\n\t}{\n\t\tUUID: uuidTestType{val: \"a987fbc9-4bed-3078-cf07-9141ba07c9f3\"},\n\t}\n\tstructWithInvalidUUID := struct {\n\t\tUUID uuidTestType `validate:\"uuid\"`\n\t}{\n\t\tUUID: uuidTestType{val: \"934859\"},\n\t}\n\n\tif err := validate.Struct(structWithValidUUID); err != nil {\n\t\tt.Fatalf(\"UUID failed Error: %s\", err)\n\t}\n\tif err := validate.Struct(structWithInvalidUUID); err == nil {\n\t\tt.Fatal(\"UUID failed Error expected but received nil\")\n\t}\n\n\t// Test on Alias type with Stringer interface.\n\talias := uuidAlias(\"a987fbc9-4bed-3078-cf07-9141ba07c9f3\")\n\tif err := validate.Var(alias, \"uuid\"); err != nil {\n\t\tt.Fatalf(\"UUID failed Error: %s\", err)\n\t}\n}\n\nfunc TestUUID5RFC4122Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\n\t\t{\"\", false},\n\t\t{\"xxxa987Fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"9c858901-8a57-4791-81Fe-4c455b099bc9\", false},\n\t\t{\"a987Fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"987Fbc97-4bed-5078-af07-9141ba07c9f3\", true},\n\t\t{\"987Fbc97-4bed-5078-9f07-9141ba07c9f3\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid5_rfc4122\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID5RFC4122 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID5RFC4122 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid5_rfc4122\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUID5RFC4122 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUUID4RFC4122Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9F3\", false},\n\t\t{\"a987fbc9-4bed-5078-af07-9141ba07c9F3\", false},\n\t\t{\"934859\", false},\n\t\t{\"57b73598-8764-4ad0-a76A-679bb6640eb1\", true},\n\t\t{\"625e63f3-58f5-40b7-83a1-a72ad31acFfb\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid4_rfc4122\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID4RFC4122 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID4RFC4122 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid4_rfc4122\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUID4RFC4122 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUUID3RFC4122Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"412452646\", false},\n\t\t{\"xxxa987fbc9-4bed-3078-cf07-9141ba07c9F3\", false},\n\t\t{\"a987fbc9-4bed-4078-8f07-9141ba07c9F3\", false},\n\t\t{\"a987fbc9-4bed-3078-cf07-9141ba07c9F3\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid3_rfc4122\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID3RFC4122 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUID3RFC4122 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid3_rfc4122\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUID3RFC4122 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUUIDRFC4122Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"xxxa987Fbc9-4bed-3078-cf07-9141ba07c9f3\", false},\n\t\t{\"a987Fbc9-4bed-3078-cf07-9141ba07c9f3xxx\", false},\n\t\t{\"a987Fbc94bed3078cf079141ba07c9f3\", false},\n\t\t{\"934859\", false},\n\t\t{\"987fbc9-4bed-3078-cf07a-9141ba07c9F3\", false},\n\t\t{\"aaaaaaaa-1111-1111-aaaG-111111111111\", false},\n\t\t{\"a987Fbc9-4bed-3078-cf07-9141ba07c9f3\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uuid_rfc4122\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUIDRFC4122 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d UUIDRFC4122 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uuid_rfc4122\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d UUIDRFC4122 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestULIDValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"01BX5ZZKBKACT-V9WEVGEMMVRZ\", false},\n\t\t{\"01bx5zzkbkactav9wevgemmvrz\", true},\n\t\t{\"a987Fbc9-4bed-3078-cf07-9141ba07c9f3xxx\", false},\n\t\t{\"01BX5ZZKBKACTAV9WEVGEMMVRZABC\", false},\n\t\t{\"01BX5ZZKBKACTAV9WEVGEMMVRZABC\", false},\n\t\t{\"0IBX5ZZKBKACTAV9WEVGEMMVRZ\", false},\n\t\t{\"O1BX5ZZKBKACTAV9WEVGEMMVRZ\", false},\n\t\t{\"01BX5ZZKBKACTAVLWEVGEMMVRZ\", false},\n\t\t{\"01BX5ZZKBKACTAV9WEVGEMMVRZ\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ulid\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ULID failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ULID failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ulid\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ULID failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestMD4Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"md4\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d MD4 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d MD4 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"md4\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d MD4 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestMD5Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"md5\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d MD5 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d MD5 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"md5\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d MD5 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSHA256Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"sha256\")\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SHA256 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SHA256 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"sha256\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d SHA256 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSHA384Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"sha384\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SHA384 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SHA384 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"sha384\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d SHA384 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSHA512Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc46f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"sha512\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SHA512 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d SHA512 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"sha512\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d SHA512 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRIPEMD128Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ripemd128\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d RIPEMD128 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d RIPEMD128 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ripemd128\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d RIPEMD128 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRIPEMD160Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"ripemd160\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d RIPEMD160 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d RIPEMD160 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"ripemd160\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d RIPEMD160 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTIGER128Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"tiger128\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d TIGER128 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d TIGER128 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"tiger128\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d TIGER128 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTIGER160Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac6f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"tiger160\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d TIGER160 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d TIGER160 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"tiger160\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d TIGER160 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTIGER192Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"6f5902ac237024bd6f5902ac237024bdd0c176cb93063dc4\", true},\n\t\t{\"6f5902ac237024bd6f5902ac237024bdd0c176cb93063dc-\", false},\n\t\t{\"6f5902ac237024bd6f5902ac237024bdd0c176cb93063dc41\", false},\n\t\t{\"6f5902ac237024bd6f5902ac237024bdd0c176cb93063dcC\", false},\n\t\t{\"6f5902ac237024bd6f5902ac237024bdd0c176cb93063dc\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"tiger192\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d TIGER192 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d TIGER192 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"tiger192\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d TIGER192 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestISBNValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo\", false},\n\t\t{\"3836221195\", true},\n\t\t{\"1-61729-085-8\", true},\n\t\t{\"3 423 21412 0\", true},\n\t\t{\"3 401 01319 X\", true},\n\t\t{\"9784873113685\", true},\n\t\t{\"978-4-87311-368-5\", true},\n\t\t{\"978 3401013190\", true},\n\t\t{\"978-3-8362-2119-1\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"isbn\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISBN failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISBN failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"isbn\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ISBN failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestISBN13Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo\", false},\n\t\t{\"3-8362-2119-5\", false},\n\t\t{\"01234567890ab\", false},\n\t\t{\"978 3 8362 2119 0\", false},\n\t\t{\"9784873113685\", true},\n\t\t{\"978-4-87311-368-5\", true},\n\t\t{\"978 3401013190\", true},\n\t\t{\"978-3-8362-2119-1\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"isbn13\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISBN13 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISBN13 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"isbn13\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ISBN13 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestISBN10Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo\", false},\n\t\t{\"3423214121\", false},\n\t\t{\"978-3836221191\", false},\n\t\t{\"3-423-21412-1\", false},\n\t\t{\"3 423 21412 1\", false},\n\t\t{\"3836221195\", true},\n\t\t{\"1-61729-085-8\", true},\n\t\t{\"3 423 21412 0\", true},\n\t\t{\"3 401 01319 X\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"isbn10\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISBN10 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISBN10 failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"isbn10\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ISBN10 failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestISSNValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"foo\", false},\n\t\t{\"20519990\", false},\n\t\t{\"2051-9991\", false},\n\t\t{\"2051-999X\", false},\n\t\t{\"1050-124X\", true},\n\t\t{\"0317-8471\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.param, \"issn\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISSN failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d ISSN failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"issn\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d ISSN failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestExcludesRuneValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"excludesrune=☻\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"a☺b☻c☹d\", Tag: \"excludesrune=☻\", ExpectedNil: false},\n\t\t{Value: \"abcd\", Tag: \"excludesrune=☻\", ExpectedNil: true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n}\n\nfunc TestExcludesAllValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"excludesall=@!{}[]\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"abcd@!jfk\", Tag: \"excludesall=@!{}[]\", ExpectedNil: false},\n\t\t{Value: \"abcdefg\", Tag: \"excludesall=@!{}[]\", ExpectedNil: true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n\n\tusername := \"joeybloggs \"\n\n\terrs := validate.Var(username, \"excludesall=@ \")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"excludesall\")\n\n\texcluded := \",\"\n\n\terrs = validate.Var(excluded, \"excludesall=!@#$%^&*()_+.0x2C?\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"excludesall\")\n\n\texcluded = \"=\"\n\n\terrs = validate.Var(excluded, \"excludesall=!@#$%^&*()_+.0x2C=?\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"excludesall\")\n}\n\nfunc TestExcludesValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"excludes=@\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"abcd@!jfk\", Tag: \"excludes=@\", ExpectedNil: false},\n\t\t{Value: \"abcdq!jfk\", Tag: \"excludes=@\", ExpectedNil: true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n}\n\nfunc TestContainsRuneValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"containsrune=☻\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"a☺b☻c☹d\", Tag: \"containsrune=☻\", ExpectedNil: true},\n\t\t{Value: \"abcd\", Tag: \"containsrune=☻\", ExpectedNil: false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n}\n\nfunc TestContainsAnyValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"containsany=@!{}[]\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"abcd@!jfk\", Tag: \"containsany=@!{}[]\", ExpectedNil: true},\n\t\t{Value: \"abcdefg\", Tag: \"containsany=@!{}[]\", ExpectedNil: false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n}\n\nfunc TestContainsValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"contains=@\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"abcd@!jfk\", Tag: \"contains=@\", ExpectedNil: true},\n\t\t{Value: \"abcdq!jfk\", Tag: \"contains=@\", ExpectedNil: false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n}\n\nfunc TestIsNeFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\tvar j uint64\n\tvar k float64\n\ts := \"abcd\"\n\ti := 1\n\tj = 1\n\tk = 1.543\n\tb := true\n\tarr := []string{\"test\"}\n\tnow := time.Now().UTC()\n\n\tvar j2 uint64\n\tvar k2 float64\n\ts2 := \"abcdef\"\n\ti2 := 3\n\tj2 = 2\n\tk2 = 1.5434456\n\tb2 := false\n\tarr2 := []string{\"test\", \"test2\"}\n\tarr3 := []string{\"test\"}\n\tnow2 := now\n\n\terrs = validate.VarWithValue(s, s2, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(i2, i, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(j2, j, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(k2, k, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(b2, b, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(arr2, arr, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(now2, now, \"nefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"nefield\")\n\n\terrs = validate.VarWithValue(arr3, arr, \"nefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"nefield\")\n\n\ttype Test struct {\n\t\tStart *time.Time `validate:\"nefield=End\"`\n\t\tEnd   *time.Time\n\t}\n\n\tsv := &Test{\n\t\tStart: &now,\n\t\tEnd:   &now,\n\t}\n\n\terrs = validate.Struct(sv)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Start\", \"Test.Start\", \"Start\", \"Start\", \"nefield\")\n\n\tnow3 := time.Now().Add(time.Hour).UTC()\n\n\tsv = &Test{\n\t\tStart: &now,\n\t\tEnd:   &now3,\n\t}\n\n\terrs = validate.Struct(sv)\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(nil, 1, \"nefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"nefield\")\n\n\terrs = validate.VarWithValue(sv, now, \"nefield\")\n\tEqual(t, errs, nil)\n\n\ttype Test2 struct {\n\t\tStart *time.Time `validate:\"nefield=NonExistantField\"`\n\t\tEnd   *time.Time\n\t}\n\n\tsv2 := &Test2{\n\t\tStart: &now,\n\t\tEnd:   &now,\n\t}\n\n\terrs = validate.Struct(sv2)\n\tEqual(t, errs, nil)\n\n\ttype Other struct {\n\t\tValue string\n\t}\n\n\ttype Test3 struct {\n\t\tValue Other\n\t\tTime  time.Time `validate:\"nefield=Value\"`\n\t}\n\n\ttst := Test3{\n\t\tValue: Other{Value: \"StringVal\"},\n\t\tTime:  now,\n\t}\n\n\terrs = validate.Struct(tst)\n\tEqual(t, errs, nil)\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"nefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"nefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"nefield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Duration(0), \"omitempty,nefield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with time.Duration type fields.\n\n\ttype TimeDurationTest struct {\n\t\tFirst  time.Duration `validate:\"nefield=Second\"`\n\t\tSecond time.Duration\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"nefield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tFirst  time.Duration `validate:\"omitempty,nefield=Second\"`\n\t\tSecond time.Duration\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0), time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsNeValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\tvar j uint64\n\tvar k float64\n\ts := \"abcdef\"\n\ti := 3\n\tj = 2\n\tk = 1.5434\n\tarr := []string{\"test\"}\n\tnow := time.Now().UTC()\n\n\terrs = validate.Var(s, \"ne=abcd\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(i, \"ne=1\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(j, \"ne=1\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(k, \"ne=1.543\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(arr, \"ne=2\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(arr, \"ne=1\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ne\")\n\n\tPanicMatches(t, func() { _ = validate.Var(now, \"ne=now\") }, \"Bad field type time.Time\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour-time.Minute, \"ne=1h\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour+time.Minute, \"ne=1h\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour, \"ne=1h\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ne\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,ne=0\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"ne=1h\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"ne\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,ne=0\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsNeIgnoreCaseValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\ts := \"abcd\"\n\tnow := time.Now()\n\n\terrs = validate.Var(s, \"ne_ignore_case=efgh\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(s, \"ne_ignore_case=AbCd\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ne_ignore_case\")\n\n\tPanicMatches(\n\t\tt, func() { _ = validate.Var(now, \"ne_ignore_case=abcd\") }, \"Bad field type time.Time\",\n\t)\n}\n\nfunc TestIsEqFieldValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\tvar j uint64\n\tvar k float64\n\ts := \"abcd\"\n\ti := 1\n\tj = 1\n\tk = 1.543\n\tb := true\n\tarr := []string{\"test\"}\n\tnow := time.Now().UTC()\n\n\tvar j2 uint64\n\tvar k2 float64\n\ts2 := \"abcd\"\n\ti2 := 1\n\tj2 = 1\n\tk2 = 1.543\n\tb2 := true\n\tarr2 := []string{\"test\"}\n\tarr3 := []string{\"test\", \"test2\"}\n\tnow2 := now\n\n\terrs = validate.VarWithValue(s, s2, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(i2, i, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(j2, j, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(k2, k, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(b2, b, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(arr2, arr, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(now2, now, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(arr3, arr, \"eqfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqfield\")\n\n\ttype Test struct {\n\t\tStart *time.Time `validate:\"eqfield=End\"`\n\t\tEnd   *time.Time\n\t}\n\n\tsv := &Test{\n\t\tStart: &now,\n\t\tEnd:   &now,\n\t}\n\n\terrs = validate.Struct(sv)\n\tEqual(t, errs, nil)\n\n\tnow3 := time.Now().Add(time.Hour).UTC()\n\n\tsv = &Test{\n\t\tStart: &now,\n\t\tEnd:   &now3,\n\t}\n\n\terrs = validate.Struct(sv)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Start\", \"Test.Start\", \"Start\", \"Start\", \"eqfield\")\n\n\terrs = validate.VarWithValue(nil, 1, \"eqfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqfield\")\n\n\tchannel := make(chan string)\n\terrs = validate.VarWithValue(5, channel, \"eqfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqfield\")\n\n\terrs = validate.VarWithValue(5, now, \"eqfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqfield\")\n\n\ttype Test2 struct {\n\t\tStart *time.Time `validate:\"eqfield=NonExistantField\"`\n\t\tEnd   *time.Time\n\t}\n\n\tsv2 := &Test2{\n\t\tStart: &now,\n\t\tEnd:   &now,\n\t}\n\n\terrs = validate.Struct(sv2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test2.Start\", \"Test2.Start\", \"Start\", \"Start\", \"eqfield\")\n\n\ttype Inner struct {\n\t\tName string\n\t}\n\n\ttype TStruct struct {\n\t\tInner     *Inner\n\t\tCreatedAt *time.Time `validate:\"eqfield=Inner\"`\n\t}\n\n\tinner := &Inner{\n\t\tName: \"NAME\",\n\t}\n\n\ttest := &TStruct{\n\t\tInner:     inner,\n\t\tCreatedAt: &now,\n\t}\n\n\terrs = validate.Struct(test)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TStruct.CreatedAt\", \"TStruct.CreatedAt\", \"CreatedAt\", \"CreatedAt\", \"eqfield\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"eqfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"eqfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqfield\")\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"eqfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eqfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Hour, \"omitempty,eqfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with time.Duration type fields.\n\n\ttype TimeDurationTest struct {\n\t\tFirst  time.Duration `validate:\"eqfield=Second\"`\n\t\tSecond time.Duration\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"eqfield\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"eqfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tFirst  time.Duration `validate:\"omitempty,eqfield=Second\"`\n\t\tSecond time.Duration\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0), time.Hour}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsEqFieldValidationWithAliasTime(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype CustomTime time.Time\n\n\ttype Test struct {\n\t\tStart CustomTime `validate:\"eqfield=End\"`\n\t\tEnd   *time.Time\n\t}\n\n\tnow := time.Now().UTC()\n\n\tsv := &Test{\n\t\tStart: CustomTime(now),\n\t\tEnd:   &now,\n\t}\n\n\terrs = validate.Struct(sv)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsEqValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\tvar j uint64\n\tvar k float64\n\ts := \"abcd\"\n\ti := 1\n\tj = 1\n\tk = 1.543\n\tarr := []string{\"test\"}\n\tnow := time.Now().UTC()\n\n\terrs = validate.Var(s, \"eq=abcd\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(i, \"eq=1\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(j, \"eq=1\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(k, \"eq=1.543\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(arr, \"eq=1\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(arr, \"eq=2\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eq\")\n\n\tPanicMatches(t, func() { _ = validate.Var(now, \"eq=now\") }, \"Bad field type time.Time\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"eq=1h\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-time.Minute, \"eq=1h\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eq\")\n\n\terrs = validate.Var(time.Hour+time.Minute, \"eq=1h\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"eq\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,eq=1h\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"eq=1h\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"eq\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"eq\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,eq=1h\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsEqIgnoreCaseValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\ts := \"abcd\"\n\tnow := time.Now()\n\n\terrs = validate.Var(s, \"eq_ignore_case=abcd\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(s, \"eq_ignore_case=AbCd\")\n\tEqual(t, errs, nil)\n\n\tPanicMatches(\n\t\tt, func() { _ = validate.Var(now, \"eq_ignore_case=abcd\") }, \"Bad field type time.Time\",\n\t)\n}\n\nfunc TestOneOfValidation(t *testing.T) {\n\tvalidate := New()\n\n\tpassSpecs := []struct {\n\t\tf interface{}\n\t\tt string\n\t}{\n\t\t{f: \"red\", t: \"oneof=red green\"},\n\t\t{f: \"green\", t: \"oneof=red green\"},\n\t\t{f: \"red green\", t: \"oneof='red green' blue\"},\n\t\t{f: \"blue\", t: \"oneof='red green' blue\"},\n\t\t{f: 5, t: \"oneof=5 6\"},\n\t\t{f: 6, t: \"oneof=5 6\"},\n\t\t{f: int8(6), t: \"oneof=5 6\"},\n\t\t{f: int16(6), t: \"oneof=5 6\"},\n\t\t{f: int32(6), t: \"oneof=5 6\"},\n\t\t{f: int64(6), t: \"oneof=5 6\"},\n\t\t{f: uint(6), t: \"oneof=5 6\"},\n\t\t{f: uint8(6), t: \"oneof=5 6\"},\n\t\t{f: uint16(6), t: \"oneof=5 6\"},\n\t\t{f: uint32(6), t: \"oneof=5 6\"},\n\t\t{f: uint64(6), t: \"oneof=5 6\"},\n\t}\n\n\tfor _, spec := range passSpecs {\n\t\tt.Logf(\"%#v\", spec)\n\t\terrs := validate.Var(spec.f, spec.t)\n\t\tEqual(t, errs, nil)\n\t}\n\n\tfailSpecs := []struct {\n\t\tf interface{}\n\t\tt string\n\t}{\n\t\t{f: \"\", t: \"oneof=red green\"},\n\t\t{f: \"yellow\", t: \"oneof=red green\"},\n\t\t{f: \"green\", t: \"oneof='red green' blue\"},\n\t\t{f: 5, t: \"oneof=red green\"},\n\t\t{f: 6, t: \"oneof=red green\"},\n\t\t{f: 6, t: \"oneof=7\"},\n\t\t{f: uint(6), t: \"oneof=7\"},\n\t\t{f: int8(5), t: \"oneof=red green\"},\n\t\t{f: int16(5), t: \"oneof=red green\"},\n\t\t{f: int32(5), t: \"oneof=red green\"},\n\t\t{f: int64(5), t: \"oneof=red green\"},\n\t\t{f: uint(5), t: \"oneof=red green\"},\n\t\t{f: uint8(5), t: \"oneof=red green\"},\n\t\t{f: uint16(5), t: \"oneof=red green\"},\n\t\t{f: uint32(5), t: \"oneof=red green\"},\n\t\t{f: uint64(5), t: \"oneof=red green\"},\n\t}\n\n\tfor _, spec := range failSpecs {\n\t\tt.Logf(\"%#v\", spec)\n\t\terrs := validate.Var(spec.f, spec.t)\n\t\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"oneof\")\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(3.14, \"oneof=red green\")\n\t}, \"Bad field type float64\")\n}\n\nfunc TestOneOfCIValidation(t *testing.T) {\n\tvalidate := New()\n\n\tpassSpecs := []struct {\n\t\tf interface{}\n\t\tt string\n\t}{\n\t\t{f: \"red\", t: \"oneofci=RED GREEN\"},\n\t\t{f: \"RED\", t: \"oneofci=red green\"},\n\t\t{f: \"red\", t: \"oneofci=red green\"},\n\t\t{f: \"RED\", t: \"oneofci=RED GREEN\"},\n\t\t{f: \"green\", t: \"oneofci=red green\"},\n\t\t{f: \"red green\", t: \"oneofci='red green' blue\"},\n\t\t{f: \"blue\", t: \"oneofci='red green' blue\"},\n\t\t{f: \"GREEN\", t: \"oneofci=Red Green\"},\n\t\t{f: \"ReD\", t: \"oneofci=RED GREEN\"},\n\t\t{f: \"gReEn\", t: \"oneofci=rEd GrEeN\"},\n\t\t{f: \"RED GREEN\", t: \"oneofci='red green' blue\"},\n\t\t{f: \"red Green\", t: \"oneofci='RED GREEN' Blue\"},\n\t\t{f: \"Red green\", t: \"oneofci='Red Green' BLUE\"},\n\t\t{f: \"rEd GrEeN\", t: \"oneofci='ReD gReEn' BlUe\"},\n\t\t{f: \"BLUE\", t: \"oneofci='Red Green' BLUE\"},\n\t\t{f: \"BlUe\", t: \"oneofci='RED GREEN' Blue\"},\n\t\t{f: \"bLuE\", t: \"oneofci='red green' BLUE\"},\n\t}\n\n\tfor _, spec := range passSpecs {\n\t\tt.Logf(\"%#v\", spec)\n\t\terrs := validate.Var(spec.f, spec.t)\n\t\tEqual(t, errs, nil)\n\t}\n\n\tfailSpecs := []struct {\n\t\tf interface{}\n\t\tt string\n\t}{\n\t\t{f: \"\", t: \"oneofci=red green\"},\n\t\t{f: \"yellow\", t: \"oneofci=red green\"},\n\t\t{f: \"green\", t: \"oneofci='red green' blue\"},\n\t}\n\n\tfor _, spec := range failSpecs {\n\t\tt.Logf(\"%#v\", spec)\n\t\terrs := validate.Var(spec.f, spec.t)\n\t\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"oneofci\")\n\t}\n\n\tpanicSpecs := []struct {\n\t\tf interface{}\n\t\tt string\n\t}{\n\t\t{f: 3.14, t: \"oneofci=red green\"},\n\t\t{f: 5, t: \"oneofci=red green\"},\n\t\t{f: uint(6), t: \"oneofci=7\"},\n\t\t{f: int8(5), t: \"oneofci=red green\"},\n\t\t{f: int16(5), t: \"oneofci=red green\"},\n\t\t{f: int32(5), t: \"oneofci=red green\"},\n\t\t{f: int64(5), t: \"oneofci=red green\"},\n\t\t{f: uint(5), t: \"oneofci=red green\"},\n\t\t{f: uint8(5), t: \"oneofci=red green\"},\n\t\t{f: uint16(5), t: \"oneofci=red green\"},\n\t\t{f: uint32(5), t: \"oneofci=red green\"},\n\t\t{f: uint64(5), t: \"oneofci=red green\"},\n\t}\n\n\tpanicCount := 0\n\tfor _, spec := range panicSpecs {\n\t\tt.Logf(\"%#v\", spec)\n\t\tPanicMatches(t, func() {\n\t\t\t_ = validate.Var(spec.f, spec.t)\n\t\t}, fmt.Sprintf(\"Bad field type %T\", spec.f))\n\t\tpanicCount++\n\t}\n\tEqual(t, panicCount, len(panicSpecs))\n}\n\nfunc TestBase32Validation(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"ABCD2345\"\n\terrs := validate.Var(s, \"base32\")\n\tEqual(t, errs, nil)\n\n\ts = \"AB======\"\n\terrs = validate.Var(s, \"base32\")\n\tEqual(t, errs, nil)\n\n\ts = \"ABCD2===\"\n\terrs = validate.Var(s, \"base32\")\n\tEqual(t, errs, nil)\n\n\ts = \"ABCD====\"\n\terrs = validate.Var(s, \"base32\")\n\tEqual(t, errs, nil)\n\n\ts = \"ABCD234=\"\n\terrs = validate.Var(s, \"base32\")\n\tEqual(t, errs, nil)\n\n\ts = \"\"\n\terrs = validate.Var(s, \"base32\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"base32\")\n\n\ts = \"ABCabc1890== foo bar\"\n\terrs = validate.Var(s, \"base32\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"base32\")\n}\n\nfunc TestBase64Validation(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"dW5pY29ybg==\"\n\n\terrs := validate.Var(s, \"base64\")\n\tEqual(t, errs, nil)\n\n\ts = \"dGhpIGlzIGEgdGVzdCBiYXNlNjQ=\"\n\terrs = validate.Var(s, \"base64\")\n\tEqual(t, errs, nil)\n\n\ts = \"\"\n\terrs = validate.Var(s, \"base64\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"base64\")\n\n\ts = \"dW5pY29ybg== foo bar\"\n\terrs = validate.Var(s, \"base64\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"base64\")\n}\n\nfunc TestBase64URLValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttestCases := []struct {\n\t\tdecoded, encoded string\n\t\tsuccess          bool\n\t}{\n\t\t// empty string, although a valid base64 string, should fail\n\t\t{\"\", \"\", false},\n\t\t// invalid length\n\t\t{\"\", \"a\", false},\n\t\t// base64 with padding\n\t\t{\"f\", \"Zg==\", true},\n\t\t{\"fo\", \"Zm8=\", true},\n\t\t// base64 without padding\n\t\t{\"foo\", \"Zm9v\", true},\n\t\t{\"\", \"Zg\", false},\n\t\t{\"\", \"Zm8\", false},\n\t\t// base64 URL safe encoding with invalid, special characters '+' and '/'\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xd9\\x7e\", \"FPucA9l+\", false},\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xf9\\x73\", \"FPucA/lz\", false},\n\t\t// base64 URL safe encoding with valid, special characters '-' and '_'\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xd9\\x7e\", \"FPucA9l-\", true},\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xf9\\x73\", \"FPucA_lz\", true},\n\t\t// non base64 characters\n\t\t{\"\", \"@mc=\", false},\n\t\t{\"\", \"Zm 9\", false},\n\t}\n\tfor _, tc := range testCases {\n\t\terr := validate.Var(tc.encoded, \"base64url\")\n\t\tif tc.success {\n\t\t\tEqual(t, err, nil)\n\t\t\t// make sure encoded value is decoded back to the expected value\n\t\t\td, innerErr := base64.URLEncoding.DecodeString(tc.encoded)\n\t\t\tEqual(t, innerErr, nil)\n\t\t\tEqual(t, tc.decoded, string(d))\n\t\t} else {\n\t\t\tNotEqual(t, err, nil)\n\t\t\tif len(tc.encoded) > 0 {\n\t\t\t\t// make sure that indeed the encoded value was faulty\n\t\t\t\t_, err := base64.URLEncoding.DecodeString(tc.encoded)\n\t\t\t\tNotEqual(t, err, nil)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBase64RawURLValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttestCases := []struct {\n\t\tdecoded, encoded string\n\t\tsuccess          bool\n\t}{\n\t\t// empty string, although a valid base64 string, should fail\n\t\t{\"\", \"\", false},\n\t\t// invalid length\n\t\t{\"\", \"a\", false},\n\t\t// base64 with padding should fail\n\t\t{\"f\", \"Zg==\", false},\n\t\t{\"fo\", \"Zm8=\", false},\n\t\t// base64 without padding\n\t\t{\"foo\", \"Zm9v\", true},\n\t\t{\"hello\", \"aGVsbG8\", true},\n\t\t{\"\", \"aGVsb\", false},\n\t\t// // base64 URL safe encoding with invalid, special characters '+' and '/'\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xd9\\x7e\", \"FPucA9l+\", false},\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xf9\\x73\", \"FPucA/lz\", false},\n\t\t// // base64 URL safe encoding with valid, special characters '-' and '_'\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xd9\\x7e\", \"FPucA9l-\", true},\n\t\t{\"\\x14\\xfb\\x9c\\x03\\xf9\\x73\", \"FPucA_lz\", true},\n\t\t// non base64 characters\n\t\t{\"\", \"@mc=\", false},\n\t\t{\"\", \"Zm 9\", false},\n\t}\n\tfor _, tc := range testCases {\n\t\terr := validate.Var(tc.encoded, \"base64rawurl\")\n\t\tif tc.success {\n\t\t\tEqual(t, err, nil)\n\t\t\t// make sure encoded value is decoded back to the expected value\n\t\t\td, innerErr := base64.RawURLEncoding.DecodeString(tc.encoded)\n\t\t\tEqual(t, innerErr, nil)\n\t\t\tEqual(t, tc.decoded, string(d))\n\t\t} else {\n\t\t\tNotEqual(t, err, nil)\n\t\t\tif len(tc.encoded) > 0 {\n\t\t\t\t// make sure that indeed the encoded value was faulty\n\t\t\t\t_, err := base64.RawURLEncoding.DecodeString(tc.encoded)\n\t\t\t\tNotEqual(t, err, nil)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestFileValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"empty path\", \"\", false},\n\t\t{\"regular file\", filepath.Join(\"testdata\", \"a.go\"), true},\n\t\t{\"missing file\", filepath.Join(\"testdata\", \"no.go\"), false},\n\t\t{\"directory, not a file\", \"testdata\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\terrs := validate.Var(test.param, \"file\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(6, \"file\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestImageValidation(t *testing.T) {\n\tvalidate := New()\n\n\tpaths := map[string]string{\n\t\t\"empty\":     \"\",\n\t\t\"directory\": \"testdata\",\n\t\t\"missing\":   filepath.Join(\"testdata\", \"none.png\"),\n\t\t\"png\":       filepath.Join(\"testdata\", \"image.png\"),\n\t\t\"jpeg\":      filepath.Join(\"testdata\", \"image.jpg\"),\n\t\t\"mp3\":       filepath.Join(\"testdata\", \"music.mp3\"),\n\t}\n\n\ttests := []struct {\n\t\ttitle        string\n\t\tparam        string\n\t\texpected     bool\n\t\tcreateImage  func()\n\t\tdestroyImage func()\n\t}{\n\t\t{\n\t\t\t\"empty path\",\n\t\t\tpaths[\"empty\"], false,\n\t\t\tfunc() {},\n\t\t\tfunc() {},\n\t\t},\n\t\t{\n\t\t\t\"directory, not a file\",\n\t\t\tpaths[\"directory\"],\n\t\t\tfalse,\n\t\t\tfunc() {},\n\t\t\tfunc() {},\n\t\t},\n\t\t{\n\t\t\t\"missing file\",\n\t\t\tpaths[\"missing\"],\n\t\t\tfalse,\n\t\t\tfunc() {},\n\t\t\tfunc() {},\n\t\t},\n\t\t{\n\t\t\t\"valid png\",\n\t\t\tpaths[\"png\"],\n\t\t\ttrue,\n\t\t\tfunc() {\n\t\t\t\timg := image.NewRGBA(image.Rectangle{image.Point{0, 0}, image.Point{10, 10}})\n\t\t\t\tf, _ := os.Create(paths[\"png\"])\n\t\t\t\terr := png.Encode(f, img)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(fmt.Sprintf(\"Could not encode file in PNG. Error: %s\", err))\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunc() {\n\t\t\t\tos.Remove(paths[\"png\"])\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"valid jpeg\",\n\t\t\tpaths[\"jpeg\"],\n\t\t\ttrue,\n\t\t\tfunc() {\n\t\t\t\tvar opt jpeg.Options\n\t\t\t\timg := image.NewGray(image.Rect(0, 0, 10, 10))\n\t\t\t\tf, _ := os.Create(paths[\"jpeg\"])\n\t\t\t\terr := jpeg.Encode(f, img, &opt)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(fmt.Sprintf(\"Could not encode file in JPEG. Error: %s\", err))\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunc() {\n\t\t\t\tos.Remove(paths[\"jpeg\"])\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"valid mp3\",\n\t\t\tpaths[\"mp3\"],\n\t\t\tfalse,\n\t\t\tfunc() {},\n\t\t\tfunc() {},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest.createImage()\n\t\terrs := validate.Var(test.param, \"image\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t}\n\t\ttest.destroyImage()\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(6, \"file\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestFilePathValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"empty filepath\", \"\", false},\n\t\t{\"valid filepath\", filepath.Join(\"testdata\", \"a.go\"), true},\n\t\t{\"invalid filepath\", filepath.Join(\"testdata\", \"no\\000.go\"), false},\n\t\t{\"directory, not a filepath\", \"testdata\" + string(os.PathSeparator), false},\n\t\t{\"directory\", \"testdata\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\terrs := validate.Var(test.param, \"filepath\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t}\n\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(6, \"filepath\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestEthereumAddressValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t// All caps.\n\t\t{\"0x52908400098527886E0F7030069857D2E4169EE7\", true},\n\t\t{\"0x8617E340B3D01FA5F11F306F4090FD50E238070D\", true},\n\n\t\t// All lower.\n\t\t{\"0xde709f2102306220921060314715629080e2fb77\", true},\n\t\t{\"0x27b1fdb04752bbc536007a920d24acb045561c26\", true},\n\t\t{\"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", true},\n\n\t\t// Mixed case: runs checksum validation.\n\t\t{\"0x02F9AE5f22EA3fA88F05780B30385bECFacbf130\", true},\n\t\t{\"0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed\", true},\n\t\t{\"0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359\", true},\n\t\t{\"0xdbF03B407c01E7cD3CBea99509d93f8DDDC8C6FB\", true},\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb\", true},\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDB\", true}, // Invalid checksum, but valid address.\n\n\t\t// Other.\n\t\t{\"\", false},\n\t\t{\"D1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb\", false},    // Missing \"0x\" prefix.\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDbc\", false}, // More than 40 hex digits.\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aD\", false},   // Less than 40 hex digits.\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDw\", false},  // Invalid hex digit \"w\".\n\t}\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"eth_addr\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d eth_addr failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d eth_addr failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"eth_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Latitude failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEthereumAddressChecksumValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t// All caps.\n\t\t{\"0x52908400098527886E0F7030069857D2E4169EE7\", true},\n\t\t{\"0x8617E340B3D01FA5F11F306F4090FD50E238070D\", true},\n\n\t\t// All lower.\n\t\t{\"0x27b1fdb04752bbc536007a920d24acb045561c26\", true},\n\t\t{\"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", false},\n\n\t\t// Mixed case: runs checksum validation.\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb\", true},\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDB\", false}, // Invalid checksum.\n\t\t{\"0x000000000000000000000000000000000000dead\", false}, // Invalid checksum.\n\t\t{\"0x000000000000000000000000000000000000dEaD\", true},  // Valid checksum.\n\n\t\t// Other.\n\t\t{\"\", false},\n\t\t{\"D1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDb\", false},    // Missing \"0x\" prefix.\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDbc\", false}, // More than 40 hex digits.\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aD\", false},   // Less than 40 hex digits.\n\t\t{\"0xD1220A0cf47c7B9Be7A2E6BA89F429762e7b9aDw\", false},  // Invalid hex digit \"w\".\n\t}\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"eth_addr_checksum\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d eth_addr_checksum failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d eth_addr_checksum failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"eth_addr_checksum\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Latitude failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBitcoinAddressValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"x\", false},\n\t\t{\"0x02F9AE5f22EA3fA88F05780B30385bEC\", false},\n\t\t{\"1A1zP1ePQGefi2DMPTifTL5SLmv7DivfNa\", false},\n\t\t{\"1P9RQEr2XeE3PEb44ZE35sfZRRW1JH8Uqx\", false},\n\t\t{\"3P14159I73E4gFr7JterCCQh9QjiTjiZrG\", false},\n\t\t{\"3P141597f3E4gFr7JterCCQh9QjiTjiZrG\", false},\n\t\t{\"37qgekLpCCHrQuSjvX3fs496FWTGsHFHizjJAs6NPcR47aefnnCWECAhHV6E3g4YN7u7Yuwod5Y\", false},\n\t\t{\"dzb7VV1Ui55BARxv7ATxAtCUeJsANKovDGWFVgpTbhq9gvPqP3yv\", false},\n\t\t{\"MuNu7ZAEDFiHthiunm7dPjwKqrVNCM3mAz6rP9zFveQu14YA8CxExSJTHcVP9DErn6u84E6Ej7S\", false},\n\t\t{\"rPpQpYknyNQ5AEHuY6H8ijJJrYc2nDKKk9jjmKEXsWzyAQcFGpDLU2Zvsmoi8JLR7hAwoy3RQWf\", false},\n\t\t{\"4Uc3FmN6NQ6zLBK5QQBXRBUREaaHwCZYsGCueHauuDmJpZKn6jkEskMB2Zi2CNgtb5r6epWEFfUJq\", false},\n\t\t{\"7aQgR5DFQ25vyXmqZAWmnVCjL3PkBcdVkBUpjrjMTcghHx3E8wb\", false},\n\t\t{\"17QpPprjeg69fW1DV8DcYYCKvWjYhXvWkov6MJ1iTTvMFj6weAqW7wybZeH57WTNxXVCRH4veVs\", false},\n\t\t{\"KxuACDviz8Xvpn1xAh9MfopySZNuyajYMZWz16Dv2mHHryznWUp3\", false},\n\t\t{\"7nK3GSmqdXJQtdohvGfJ7KsSmn3TmGqExug49583bDAL91pVSGq5xS9SHoAYL3Wv3ijKTit65th\", false},\n\t\t{\"cTivdBmq7bay3RFGEBBuNfMh2P1pDCgRYN2Wbxmgwr4ki3jNUL2va\", false},\n\t\t{\"gjMV4vjNjyMrna4fsAr8bWxAbwtmMUBXJS3zL4NJt5qjozpbQLmAfK1uA3CquSqsZQMpoD1g2nk\", false},\n\t\t{\"emXm1naBMoVzPjbk7xpeTVMFy4oDEe25UmoyGgKEB1gGWsK8kRGs\", false},\n\t\t{\"7VThQnNRj1o3Zyvc7XHPRrjDf8j2oivPTeDXnRPYWeYGE4pXeRJDZgf28ppti5hsHWXS2GSobdqyo\", false},\n\t\t{\"1G9u6oCVCPh2o8m3t55ACiYvG1y5BHewUkDSdiQarDcYXXhFHYdzMdYfUAhfxn5vNZBwpgUNpso\", false},\n\t\t{\"31QQ7ZMLkScDiB4VyZjuptr7AEc9j1SjstF7pRoLhHTGkW4Q2y9XELobQmhhWxeRvqcukGd1XCq\", false},\n\t\t{\"DHqKSnpxa8ZdQyH8keAhvLTrfkyBMQxqngcQA5N8LQ9KVt25kmGN\", false},\n\t\t{\"2LUHcJPbwLCy9GLH1qXmfmAwvadWw4bp4PCpDfduLqV17s6iDcy1imUwhQJhAoNoN1XNmweiJP4i\", false},\n\t\t{\"7USRzBXAnmck8fX9HmW7RAb4qt92VFX6soCnts9s74wxm4gguVhtG5of8fZGbNPJA83irHVY6bCos\", false},\n\t\t{\"1DGezo7BfVebZxAbNT3XGujdeHyNNBF3vnficYoTSp4PfK2QaML9bHzAMxke3wdKdHYWmsMTJVu\", false},\n\t\t{\"2D12DqDZKwCxxkzs1ZATJWvgJGhQ4cFi3WrizQ5zLAyhN5HxuAJ1yMYaJp8GuYsTLLxTAz6otCfb\", false},\n\t\t{\"8AFJzuTujXjw1Z6M3fWhQ1ujDW7zsV4ePeVjVo7D1egERqSW9nZ\", false},\n\t\t{\"163Q17qLbTCue8YY3AvjpUhotuaodLm2uqMhpYirsKjVqnxJRWTEoywMVY3NbBAHuhAJ2cF9GAZ\", false},\n\t\t{\"2MnmgiRH4eGLyLc9eAqStzk7dFgBjFtUCtu\", false},\n\t\t{\"461QQ2sYWxU7H2PV4oBwJGNch8XVTYYbZxU\", false},\n\t\t{\"2UCtv53VttmQYkVU4VMtXB31REvQg4ABzs41AEKZ8UcB7DAfVzdkV9JDErwGwyj5AUHLkmgZeobs\", false},\n\t\t{\"cSNjAsnhgtiFMi6MtfvgscMB2Cbhn2v1FUYfviJ1CdjfidvmeW6mn\", false},\n\t\t{\"gmsow2Y6EWAFDFE1CE4Hd3Tpu2BvfmBfG1SXsuRARbnt1WjkZnFh1qGTiptWWbjsq2Q6qvpgJVj\", false},\n\t\t{\"nksUKSkzS76v8EsSgozXGMoQFiCoCHzCVajFKAXqzK5on9ZJYVHMD5CKwgmX3S3c7M1U3xabUny\", false},\n\t\t{\"L3favK1UzFGgdzYBF2oBT5tbayCo4vtVBLJhg2iYuMeePxWG8SQc\", false},\n\t\t{\"7VxLxGGtYT6N99GdEfi6xz56xdQ8nP2dG1CavuXx7Rf2PrvNMTBNevjkfgs9JmkcGm6EXpj8ipyPZ \", false},\n\t\t{\"2mbZwFXF6cxShaCo2czTRB62WTx9LxhTtpP\", false},\n\t\t{\"dB7cwYdcPSgiyAwKWL3JwCVwSk6epU2txw\", false},\n\t\t{\"HPhFUhUAh8ZQQisH8QQWafAxtQYju3SFTX\", false},\n\t\t{\"4ctAH6AkHzq5ioiM1m9T3E2hiYEev5mTsB\", false},\n\t\t{\"31uEbMgunupShBVTewXjtqbBv5MndwfXhb\", false},\n\t\t{\"175tWpb8K1S7NmH4Zx6rewF9WQrcZv245W\", false},\n\t\t{\"Hn1uFi4dNexWrqARpjMqgT6cX1UsNPuV3cHdGg9ExyXw8HTKadbktRDtdeVmY3M1BxJStiL4vjJ\", false},\n\t\t{\"Sq3fDbvutABmnAHHExJDgPLQn44KnNC7UsXuT7KZecpaYDMU9Txs\", false},\n\t\t{\"6TqWyrqdgUEYDQU1aChMuFMMEimHX44qHFzCUgGfqxGgZNMUVWJ\", false},\n\t\t{\"giqJo7oWqFxNKWyrgcBxAVHXnjJ1t6cGoEffce5Y1y7u649Noj5wJ4mmiUAKEVVrYAGg2KPB3Y4\", false},\n\t\t{\"cNzHY5e8vcmM3QVJUcjCyiKMYfeYvyueq5qCMV3kqcySoLyGLYUK\", false},\n\t\t{\"37uTe568EYc9WLoHEd9jXEvUiWbq5LFLscNyqvAzLU5vBArUJA6eydkLmnMwJDjkL5kXc2VK7ig\", false},\n\t\t{\"EsYbG4tWWWY45G31nox838qNdzksbPySWc\", false},\n\t\t{\"nbuzhfwMoNzA3PaFnyLcRxE9bTJPDkjZ6Rf6Y6o2ckXZfzZzXBT\", false},\n\t\t{\"cQN9PoxZeCWK1x56xnz6QYAsvR11XAce3Ehp3gMUdfSQ53Y2mPzx\", false},\n\t\t{\"1Gm3N3rkef6iMbx4voBzaxtXcmmiMTqZPhcuAepRzYUJQW4qRpEnHvMojzof42hjFRf8PE2jPde\", false},\n\t\t{\"2TAq2tuN6x6m233bpT7yqdYQPELdTDJn1eU\", false},\n\t\t{\"ntEtnnGhqPii4joABvBtSEJG6BxjT2tUZqE8PcVYgk3RHpgxgHDCQxNbLJf7ardf1dDk2oCQ7Cf\", false},\n\t\t{\"Ky1YjoZNgQ196HJV3HpdkecfhRBmRZdMJk89Hi5KGfpfPwS2bUbfd\", false},\n\t\t{\"2A1q1YsMZowabbvta7kTy2Fd6qN4r5ZCeG3qLpvZBMzCixMUdkN2Y4dHB1wPsZAeVXUGD83MfRED\", false},\n\t\t{\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\", true},\n\t\t{\"1Ax4gZtb7gAit2TivwejZHYtNNLT18PUXJ\", true},\n\t\t{\"1C5bSj1iEGUgSTbziymG7Cn18ENQuT36vv\", true},\n\t\t{\"1Gqk4Tv79P91Cc1STQtU3s1W6277M2CVWu\", true},\n\t\t{\"1JwMWBVLtiqtscbaRHai4pqHokhFCbtoB4\", true},\n\t\t{\"19dcawoKcZdQz365WpXWMhX6QCUpR9SY4r\", true},\n\t\t{\"13p1ijLwsnrcuyqcTvJXkq2ASdXqcnEBLE\", true},\n\t\t{\"1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2\", true},\n\t\t{\"3P14159f73E4gFr7JterCCQh9QjiTjiZrG\", true},\n\t\t{\"3CMNFxN1oHBc4R1EpboAL5yzHGgE611Xou\", true},\n\t\t{\"3QjYXhTkvuj8qPaXHTTWb5wjXhdsLAAWVy\", true},\n\t\t{\"3AnNxabYGoTxYiTEZwFEnerUoeFXK2Zoks\", true},\n\t\t{\"33vt8ViH5jsr115AGkW6cEmEz9MpvJSwDk\", true},\n\t\t{\"3QCzvfL4ZRvmJFiWWBVwxfdaNBT8EtxB5y\", true},\n\t\t{\"37Sp6Rv3y4kVd1nQ1JV5pfqXccHNyZm1x3\", true},\n\t\t{\"3ALJH9Y951VCGcVZYAdpA3KchoP9McEj1G\", true},\n\t\t{\"12KYrjTdVGjFMtaxERSk3gphreJ5US8aUP\", true},\n\t\t{\"12QeMLzSrB8XH8FvEzPMVoRxVAzTr5XM2y\", true},\n\t\t{\"1oNLrsHnBcR6dpaBpwz3LSwutbUNkNSjs\", true},\n\t\t{\"1SQHtwR5oJRKLfiWQ2APsAd9miUc4k2ez\", true},\n\t\t{\"116CGDLddrZhMrTwhCVJXtXQpxygTT1kHd\", true},\n\t\t{\"3NJZLcZEEYBpxYEUGewU4knsQRn1WM5Fkt\", true},\n\t}\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"btc_addr\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d btc_addr failed with Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d btc_addr failed with Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"btc_addr\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Latitude failed with Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBitcoinBech32AddressValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"bc1rw5uspcuh\", false},\n\t\t{\"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5\", false},\n\t\t{\"BC13W508D6QEJXTDG4Y5R3ZARVARY0C5XW7KN40WF2\", false},\n\t\t{\"qw508d6qejxtdg4y5r3zarvary0c5xw7kg3g4ty\", false},\n\t\t{\"bc1rw5uspcuh\", false},\n\t\t{\"bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90\", false},\n\t\t{\"BC1QW508d6QEJxTDG4y5R3ZArVARY0C5XW7KV8F3T4\", false},\n\t\t{\"BC1QR508D6QEJXTDG4Y5R3ZARVARYV98GJ9P\", false},\n\t\t{\"bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t5\", false},\n\t\t{\"bc10w508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7kw5rljs90\", false},\n\t\t{\"bc1pw508d6qejxtdg4y5r3zarqfsj6c3\", false},\n\t\t{\"bc1zw508d6qejxtdg4y5r3zarvaryvqyzf3du\", false},\n\t\t{\"bc1gmk9yu\", false},\n\t\t{\"bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3pjxtptv\", false},\n\t\t{\"BC1QW508D6QEJXTDG4Y5R3ZARVARY0C5XW7KV8F3T4\", true},\n\t\t{\"bc1pw508d6qejxtdg4y5r3zarvary0c5xw7kw508d6qejxtdg4y5r3zarvary0c5xw7k7grplx\", true},\n\t\t{\"bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3\", true},\n\t\t{\"BC1SW50QA3JX3S\", true},\n\t\t{\"bc1zw508d6qejxtdg4y5r3zarvaryvg6kdaj\", true},\n\t}\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"btc_addr_bech32\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d btc_addr_bech32 failed with Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d btc_addr_bech32 failed with Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"btc_addr_bech32\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Latitude failed with Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNoStructLevelValidation(t *testing.T) {\n\ttype Inner struct {\n\t\tTest string `validate:\"len=5\"`\n\t}\n\n\ttype Outer struct {\n\t\tInnerStruct    Inner  `validate:\"required,nostructlevel\"`\n\t\tInnerStructPtr *Inner `validate:\"required,nostructlevel\"`\n\t}\n\n\touter := &Outer{\n\t\tInnerStructPtr: nil,\n\t\tInnerStruct:    Inner{},\n\t}\n\n\t// test with struct required failing on\n\tvalidate := New(WithRequiredStructEnabled())\n\n\terrs := validate.Struct(outer)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Outer.InnerStruct\", \"Outer.InnerStruct\", \"InnerStruct\", \"InnerStruct\", \"required\")\n\tAssertError(t, errs, \"Outer.InnerStructPtr\", \"Outer.InnerStructPtr\", \"InnerStructPtr\", \"InnerStructPtr\", \"required\")\n\n\tinner := Inner{\n\t\tTest: \"1234\",\n\t}\n\n\touter = &Outer{\n\t\tInnerStruct:    inner,\n\t\tInnerStructPtr: &inner,\n\t}\n\n\terrs = validate.Struct(outer)\n\tEqual(t, errs, nil)\n\n\t// test with struct required failing off\n\n\touter = &Outer{\n\t\tInnerStructPtr: nil,\n\t\tInnerStruct:    Inner{},\n\t}\n\tvalidate = New()\n\n\terrs = validate.Struct(outer)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Outer.InnerStructPtr\", \"Outer.InnerStructPtr\", \"InnerStructPtr\", \"InnerStructPtr\", \"required\")\n\n\tinner = Inner{\n\t\tTest: \"1234\",\n\t}\n\n\touter = &Outer{\n\t\tInnerStruct:    inner,\n\t\tInnerStructPtr: &inner,\n\t}\n\n\terrs = validate.Struct(outer)\n\tEqual(t, errs, nil)\n}\n\nfunc TestStructOnlyValidation(t *testing.T) {\n\ttype Inner struct {\n\t\tTest string `validate:\"len=5\"`\n\t}\n\n\ttype Outer struct {\n\t\tInnerStruct    Inner  `validate:\"required,structonly\"`\n\t\tInnerStructPtr *Inner `validate:\"required,structonly\"`\n\t}\n\n\touter := &Outer{\n\t\tInnerStruct:    Inner{},\n\t\tInnerStructPtr: nil,\n\t}\n\n\t// without required struct on\n\tvalidate := New()\n\n\terrs := validate.Struct(outer)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Outer.InnerStructPtr\", \"Outer.InnerStructPtr\", \"InnerStructPtr\", \"InnerStructPtr\", \"required\")\n\n\t// with required struct on\n\tvalidate.requiredStructEnabled = true\n\n\terrs = validate.Struct(outer)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Outer.InnerStruct\", \"Outer.InnerStruct\", \"InnerStruct\", \"InnerStruct\", \"required\")\n\tAssertError(t, errs, \"Outer.InnerStructPtr\", \"Outer.InnerStructPtr\", \"InnerStructPtr\", \"InnerStructPtr\", \"required\")\n\n\tinner := Inner{\n\t\tTest: \"1234\",\n\t}\n\n\touter = &Outer{\n\t\tInnerStruct:    inner,\n\t\tInnerStructPtr: &inner,\n\t}\n\n\terrs = validate.Struct(outer)\n\tEqual(t, errs, nil)\n\n\t// Address houses a users address information\n\ttype Address struct {\n\t\tStreet string `validate:\"required\"`\n\t\tCity   string `validate:\"required\"`\n\t\tPlanet string `validate:\"required\"`\n\t\tPhone  string `validate:\"required\"`\n\t}\n\n\ttype User struct {\n\t\tFirstName      string     `json:\"fname\"`\n\t\tLastName       string     `json:\"lname\"`\n\t\tAge            uint8      `validate:\"gte=0,lte=130\"`\n\t\tNumber         string     `validate:\"required,e164\"`\n\t\tEmail          string     `validate:\"required,email\"`\n\t\tFavouriteColor string     `validate:\"hexcolor|rgb|rgba\"`\n\t\tAddresses      []*Address `validate:\"required\"`   // a person can have a home and cottage...\n\t\tAddress        Address    `validate:\"structonly\"` // a person can have a home and cottage...\n\t}\n\n\taddress := &Address{\n\t\tStreet: \"Eavesdown Docks\",\n\t\tPlanet: \"Persphone\",\n\t\tPhone:  \"none\",\n\t\tCity:   \"Unknown\",\n\t}\n\n\tuser := &User{\n\t\tFirstName:      \"\",\n\t\tLastName:       \"\",\n\t\tAge:            45,\n\t\tNumber:         \"+1123456789\",\n\t\tEmail:          \"Badger.Smith@gmail.com\",\n\t\tFavouriteColor: \"#000\",\n\t\tAddresses:      []*Address{address},\n\t\tAddress: Address{\n\t\t\t// Street: \"Eavesdown Docks\",\n\t\t\tPlanet: \"Persphone\",\n\t\t\tPhone:  \"none\",\n\t\t\tCity:   \"Unknown\",\n\t\t},\n\t}\n\n\terrs = validate.Struct(user)\n\tEqual(t, errs, nil)\n}\n\nfunc TestGtField(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype TimeTest struct {\n\t\tStart *time.Time `validate:\"required,gt\"`\n\t\tEnd   *time.Time `validate:\"required,gt,gtfield=Start\"`\n\t}\n\n\tnow := time.Now()\n\tstart := now.Add(time.Hour * 24)\n\tend := start.Add(time.Hour * 24)\n\n\ttimeTest := &TimeTest{\n\t\tStart: &start,\n\t\tEnd:   &end,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tEqual(t, errs, nil)\n\n\ttimeTest = &TimeTest{\n\t\tStart: &end,\n\t\tEnd:   &start,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest.End\", \"TimeTest.End\", \"End\", \"End\", \"gtfield\")\n\n\terrs = validate.VarWithValue(&end, &start, \"gtfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(&start, &end, \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\terrs = validate.VarWithValue(&end, &start, \"gtfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(&timeTest, &end, \"gtfield\")\n\tNotEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(\"test bigger\", \"test\", \"gtfield\")\n\tEqual(t, errs, nil)\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"gtfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Hour, \"omitempty,gtfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with time.Duration type fields.\n\n\ttype TimeDurationTest struct {\n\t\tFirst  time.Duration `validate:\"gtfield=Second\"`\n\t\tSecond time.Duration\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"gtfield\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"gtfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tFirst  time.Duration `validate:\"omitempty,gtfield=Second\"`\n\t\tSecond time.Duration\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0), time.Hour}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n\n\t// Tests for Ints types.\n\n\ttype IntTest struct {\n\t\tVal1 int `validate:\"required\"`\n\t\tVal2 int `validate:\"required,gtfield=Val1\"`\n\t}\n\n\tintTest := &IntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tEqual(t, errs, nil)\n\n\tintTest = &IntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"IntTest.Val2\", \"IntTest.Val2\", \"Val2\", \"Val2\", \"gtfield\")\n\n\terrs = validate.VarWithValue(int(5), int(1), \"gtfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(int(1), int(5), \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\ttype UIntTest struct {\n\t\tVal1 uint `validate:\"required\"`\n\t\tVal2 uint `validate:\"required,gtfield=Val1\"`\n\t}\n\n\tuIntTest := &UIntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tEqual(t, errs, nil)\n\n\tuIntTest = &UIntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"UIntTest.Val2\", \"UIntTest.Val2\", \"Val2\", \"Val2\", \"gtfield\")\n\n\terrs = validate.VarWithValue(uint(5), uint(1), \"gtfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(uint(1), uint(5), \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\ttype FloatTest struct {\n\t\tVal1 float64 `validate:\"required\"`\n\t\tVal2 float64 `validate:\"required,gtfield=Val1\"`\n\t}\n\n\tfloatTest := &FloatTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tEqual(t, errs, nil)\n\n\tfloatTest = &FloatTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"FloatTest.Val2\", \"FloatTest.Val2\", \"Val2\", \"Val2\", \"gtfield\")\n\n\terrs = validate.VarWithValue(float32(5), float32(1), \"gtfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(float32(1), float32(5), \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\terrs = validate.VarWithValue(nil, 1, \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\terrs = validate.VarWithValue(5, \"T\", \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\terrs = validate.VarWithValue(5, start, \"gtfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtfield\")\n\n\ttype TimeTest2 struct {\n\t\tStart *time.Time `validate:\"required\"`\n\t\tEnd   *time.Time `validate:\"required,gtfield=NonExistantField\"`\n\t}\n\n\ttimeTest2 := &TimeTest2{\n\t\tStart: &start,\n\t\tEnd:   &end,\n\t}\n\n\terrs = validate.Struct(timeTest2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest2.End\", \"TimeTest2.End\", \"End\", \"End\", \"gtfield\")\n\n\ttype Other struct {\n\t\tValue string\n\t}\n\n\ttype Test struct {\n\t\tValue Other\n\t\tTime  time.Time `validate:\"gtfield=Value\"`\n\t}\n\n\ttst := Test{\n\t\tValue: Other{Value: \"StringVal\"},\n\t\tTime:  end,\n\t}\n\n\terrs = validate.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Time\", \"Test.Time\", \"Time\", \"Time\", \"gtfield\")\n}\n\nfunc TestLtField(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype TimeTest struct {\n\t\tStart *time.Time `validate:\"required,lt,ltfield=End\"`\n\t\tEnd   *time.Time `validate:\"required,lt\"`\n\t}\n\n\tnow := time.Now()\n\tstart := now.Add(time.Hour * 24 * -1 * 2)\n\tend := start.Add(time.Hour * 24)\n\n\ttimeTest := &TimeTest{\n\t\tStart: &start,\n\t\tEnd:   &end,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tEqual(t, errs, nil)\n\n\ttimeTest = &TimeTest{\n\t\tStart: &end,\n\t\tEnd:   &start,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest.Start\", \"TimeTest.Start\", \"Start\", \"Start\", \"ltfield\")\n\n\terrs = validate.VarWithValue(&start, &end, \"ltfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(&end, &start, \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\terrs = validate.VarWithValue(&end, timeTest, \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\terrs = validate.VarWithValue(\"tes\", \"test\", \"ltfield\")\n\tEqual(t, errs, nil)\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"ltfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), -time.Minute, \"omitempty,ltfield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with time.Duration type fields.\n\n\ttype TimeDurationTest struct {\n\t\tFirst  time.Duration `validate:\"ltfield=Second\"`\n\t\tSecond time.Duration\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"ltfield\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"ltfield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tFirst  time.Duration `validate:\"omitempty,ltfield=Second\"`\n\t\tSecond time.Duration\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0), -time.Minute}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n\n\t// Tests for Ints types.\n\n\ttype IntTest struct {\n\t\tVal1 int `validate:\"required\"`\n\t\tVal2 int `validate:\"required,ltfield=Val1\"`\n\t}\n\n\tintTest := &IntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tEqual(t, errs, nil)\n\n\tintTest = &IntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"IntTest.Val2\", \"IntTest.Val2\", \"Val2\", \"Val2\", \"ltfield\")\n\n\terrs = validate.VarWithValue(int(1), int(5), \"ltfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(int(5), int(1), \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\ttype UIntTest struct {\n\t\tVal1 uint `validate:\"required\"`\n\t\tVal2 uint `validate:\"required,ltfield=Val1\"`\n\t}\n\n\tuIntTest := &UIntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tEqual(t, errs, nil)\n\n\tuIntTest = &UIntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"UIntTest.Val2\", \"UIntTest.Val2\", \"Val2\", \"Val2\", \"ltfield\")\n\n\terrs = validate.VarWithValue(uint(1), uint(5), \"ltfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(uint(5), uint(1), \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\ttype FloatTest struct {\n\t\tVal1 float64 `validate:\"required\"`\n\t\tVal2 float64 `validate:\"required,ltfield=Val1\"`\n\t}\n\n\tfloatTest := &FloatTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tEqual(t, errs, nil)\n\n\tfloatTest = &FloatTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"FloatTest.Val2\", \"FloatTest.Val2\", \"Val2\", \"Val2\", \"ltfield\")\n\n\terrs = validate.VarWithValue(float32(1), float32(5), \"ltfield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(float32(5), float32(1), \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\terrs = validate.VarWithValue(nil, 5, \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\terrs = validate.VarWithValue(1, \"T\", \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\terrs = validate.VarWithValue(1, end, \"ltfield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltfield\")\n\n\ttype TimeTest2 struct {\n\t\tStart *time.Time `validate:\"required\"`\n\t\tEnd   *time.Time `validate:\"required,ltfield=NonExistantField\"`\n\t}\n\n\ttimeTest2 := &TimeTest2{\n\t\tStart: &end,\n\t\tEnd:   &start,\n\t}\n\n\terrs = validate.Struct(timeTest2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest2.End\", \"TimeTest2.End\", \"End\", \"End\", \"ltfield\")\n}\n\nfunc TestFieldContains(t *testing.T) {\n\tvalidate := New()\n\n\ttype StringTest struct {\n\t\tFoo string `validate:\"fieldcontains=Bar\"`\n\t\tBar string\n\t}\n\n\tstringTest := &StringTest{\n\t\tFoo: \"foobar\",\n\t\tBar: \"bar\",\n\t}\n\n\terrs := validate.Struct(stringTest)\n\tEqual(t, errs, nil)\n\n\tstringTest = &StringTest{\n\t\tFoo: \"foo\",\n\t\tBar: \"bar\",\n\t}\n\n\terrs = validate.Struct(stringTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"StringTest.Foo\", \"StringTest.Foo\", \"Foo\", \"Foo\", \"fieldcontains\")\n\n\terrs = validate.VarWithValue(\"foo\", \"bar\", \"fieldcontains\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"fieldcontains\")\n\n\terrs = validate.VarWithValue(\"bar\", \"foobarfoo\", \"fieldcontains\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"fieldcontains\")\n\n\terrs = validate.VarWithValue(\"foobarfoo\", \"bar\", \"fieldcontains\")\n\tEqual(t, errs, nil)\n\n\ttype StringTestMissingField struct {\n\t\tFoo string `validate:\"fieldcontains=Bar\"`\n\t}\n\n\tstringTestMissingField := &StringTestMissingField{\n\t\tFoo: \"foo\",\n\t}\n\n\terrs = validate.Struct(stringTestMissingField)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"StringTestMissingField.Foo\", \"StringTestMissingField.Foo\", \"Foo\", \"Foo\", \"fieldcontains\")\n}\n\nfunc TestFieldExcludes(t *testing.T) {\n\tvalidate := New()\n\n\ttype StringTest struct {\n\t\tFoo string `validate:\"fieldexcludes=Bar\"`\n\t\tBar string\n\t}\n\n\tstringTest := &StringTest{\n\t\tFoo: \"foobar\",\n\t\tBar: \"bar\",\n\t}\n\n\terrs := validate.Struct(stringTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"StringTest.Foo\", \"StringTest.Foo\", \"Foo\", \"Foo\", \"fieldexcludes\")\n\n\tstringTest = &StringTest{\n\t\tFoo: \"foo\",\n\t\tBar: \"bar\",\n\t}\n\n\terrs = validate.Struct(stringTest)\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(\"foo\", \"bar\", \"fieldexcludes\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(\"bar\", \"foobarfoo\", \"fieldexcludes\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(\"foobarfoo\", \"bar\", \"fieldexcludes\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"fieldexcludes\")\n\n\ttype StringTestMissingField struct {\n\t\tFoo string `validate:\"fieldexcludes=Bar\"`\n\t}\n\n\tstringTestMissingField := &StringTestMissingField{\n\t\tFoo: \"foo\",\n\t}\n\n\terrs = validate.Struct(stringTestMissingField)\n\tEqual(t, errs, nil)\n}\n\nfunc TestContainsAndExcludes(t *testing.T) {\n\tvalidate := New()\n\n\ttype ImpossibleStringTest struct {\n\t\tFoo string `validate:\"fieldcontains=Bar\"`\n\t\tBar string `validate:\"fieldexcludes=Foo\"`\n\t}\n\n\timpossibleStringTest := &ImpossibleStringTest{\n\t\tFoo: \"foo\",\n\t\tBar: \"bar\",\n\t}\n\n\terrs := validate.Struct(impossibleStringTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"ImpossibleStringTest.Foo\", \"ImpossibleStringTest.Foo\", \"Foo\", \"Foo\", \"fieldcontains\")\n\n\timpossibleStringTest = &ImpossibleStringTest{\n\t\tFoo: \"bar\",\n\t\tBar: \"foo\",\n\t}\n\n\terrs = validate.Struct(impossibleStringTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"ImpossibleStringTest.Foo\", \"ImpossibleStringTest.Foo\", \"Foo\", \"Foo\", \"fieldcontains\")\n}\n\nfunc TestLteField(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype TimeTest struct {\n\t\tStart *time.Time `validate:\"required,lte,ltefield=End\"`\n\t\tEnd   *time.Time `validate:\"required,lte\"`\n\t}\n\n\tnow := time.Now()\n\tstart := now.Add(time.Hour * 24 * -1 * 2)\n\tend := start.Add(time.Hour * 24)\n\n\ttimeTest := &TimeTest{\n\t\tStart: &start,\n\t\tEnd:   &end,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tEqual(t, errs, nil)\n\n\ttimeTest = &TimeTest{\n\t\tStart: &end,\n\t\tEnd:   &start,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest.Start\", \"TimeTest.Start\", \"Start\", \"Start\", \"ltefield\")\n\n\terrs = validate.VarWithValue(&start, &end, \"ltefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(&end, &start, \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\terrs = validate.VarWithValue(&end, timeTest, \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\terrs = validate.VarWithValue(\"tes\", \"test\", \"ltefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(\"test\", \"test\", \"ltefield\")\n\tEqual(t, errs, nil)\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"ltefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"ltefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), -time.Minute, \"omitempty,ltefield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with time.Duration type fields.\n\n\ttype TimeDurationTest struct {\n\t\tFirst  time.Duration `validate:\"ltefield=Second\"`\n\t\tSecond time.Duration\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"ltefield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tFirst  time.Duration `validate:\"omitempty,ltefield=Second\"`\n\t\tSecond time.Duration\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0), -time.Minute}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n\n\t// Tests for Ints types.\n\n\ttype IntTest struct {\n\t\tVal1 int `validate:\"required\"`\n\t\tVal2 int `validate:\"required,ltefield=Val1\"`\n\t}\n\n\tintTest := &IntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tEqual(t, errs, nil)\n\n\tintTest = &IntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"IntTest.Val2\", \"IntTest.Val2\", \"Val2\", \"Val2\", \"ltefield\")\n\n\terrs = validate.VarWithValue(int(1), int(5), \"ltefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(int(5), int(1), \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\ttype UIntTest struct {\n\t\tVal1 uint `validate:\"required\"`\n\t\tVal2 uint `validate:\"required,ltefield=Val1\"`\n\t}\n\n\tuIntTest := &UIntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tEqual(t, errs, nil)\n\n\tuIntTest = &UIntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"UIntTest.Val2\", \"UIntTest.Val2\", \"Val2\", \"Val2\", \"ltefield\")\n\n\terrs = validate.VarWithValue(uint(1), uint(5), \"ltefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(uint(5), uint(1), \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\ttype FloatTest struct {\n\t\tVal1 float64 `validate:\"required\"`\n\t\tVal2 float64 `validate:\"required,ltefield=Val1\"`\n\t}\n\n\tfloatTest := &FloatTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tEqual(t, errs, nil)\n\n\tfloatTest = &FloatTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"FloatTest.Val2\", \"FloatTest.Val2\", \"Val2\", \"Val2\", \"ltefield\")\n\n\terrs = validate.VarWithValue(float32(1), float32(5), \"ltefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(float32(5), float32(1), \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\terrs = validate.VarWithValue(nil, 5, \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\terrs = validate.VarWithValue(1, \"T\", \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\terrs = validate.VarWithValue(1, end, \"ltefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"ltefield\")\n\n\ttype TimeTest2 struct {\n\t\tStart *time.Time `validate:\"required\"`\n\t\tEnd   *time.Time `validate:\"required,ltefield=NonExistantField\"`\n\t}\n\n\ttimeTest2 := &TimeTest2{\n\t\tStart: &end,\n\t\tEnd:   &start,\n\t}\n\n\terrs = validate.Struct(timeTest2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest2.End\", \"TimeTest2.End\", \"End\", \"End\", \"ltefield\")\n}\n\nfunc TestGteField(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ttype TimeTest struct {\n\t\tStart *time.Time `validate:\"required,gte\"`\n\t\tEnd   *time.Time `validate:\"required,gte,gtefield=Start\"`\n\t}\n\n\tnow := time.Now()\n\tstart := now.Add(time.Hour * 24)\n\tend := start.Add(time.Hour * 24)\n\n\ttimeTest := &TimeTest{\n\t\tStart: &start,\n\t\tEnd:   &end,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tEqual(t, errs, nil)\n\n\ttimeTest = &TimeTest{\n\t\tStart: &end,\n\t\tEnd:   &start,\n\t}\n\n\terrs = validate.Struct(timeTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest.End\", \"TimeTest.End\", \"End\", \"End\", \"gtefield\")\n\n\terrs = validate.VarWithValue(&end, &start, \"gtefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(&start, &end, \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\terrs = validate.VarWithValue(&start, timeTest, \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\terrs = validate.VarWithValue(\"test\", \"test\", \"gtefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(\"test bigger\", \"test\", \"gtefield\")\n\tEqual(t, errs, nil)\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for variables of time.Duration type.\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour-time.Minute, \"gtefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour, \"gtefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(time.Hour, time.Hour+time.Minute, \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\terrs = validate.VarWithValue(time.Duration(0), time.Hour, \"omitempty,gtefield\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with time.Duration type fields.\n\n\ttype TimeDurationTest struct {\n\t\tFirst  time.Duration `validate:\"gtefield=Second\"`\n\t\tSecond time.Duration\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour, time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.First\", \"TimeDurationTest.First\", \"First\", \"First\", \"gtefield\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tFirst  time.Duration `validate:\"omitempty,gtefield=Second\"`\n\t\tSecond time.Duration\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0), time.Hour}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n\n\t// Tests for Ints types.\n\n\ttype IntTest struct {\n\t\tVal1 int `validate:\"required\"`\n\t\tVal2 int `validate:\"required,gtefield=Val1\"`\n\t}\n\n\tintTest := &IntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tEqual(t, errs, nil)\n\n\tintTest = &IntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(intTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"IntTest.Val2\", \"IntTest.Val2\", \"Val2\", \"Val2\", \"gtefield\")\n\n\terrs = validate.VarWithValue(int(5), int(1), \"gtefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(int(1), int(5), \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\ttype UIntTest struct {\n\t\tVal1 uint `validate:\"required\"`\n\t\tVal2 uint `validate:\"required,gtefield=Val1\"`\n\t}\n\n\tuIntTest := &UIntTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tEqual(t, errs, nil)\n\n\tuIntTest = &UIntTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(uIntTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"UIntTest.Val2\", \"UIntTest.Val2\", \"Val2\", \"Val2\", \"gtefield\")\n\n\terrs = validate.VarWithValue(uint(5), uint(1), \"gtefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(uint(1), uint(5), \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\ttype FloatTest struct {\n\t\tVal1 float64 `validate:\"required\"`\n\t\tVal2 float64 `validate:\"required,gtefield=Val1\"`\n\t}\n\n\tfloatTest := &FloatTest{\n\t\tVal1: 1,\n\t\tVal2: 5,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tEqual(t, errs, nil)\n\n\tfloatTest = &FloatTest{\n\t\tVal1: 5,\n\t\tVal2: 1,\n\t}\n\n\terrs = validate.Struct(floatTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"FloatTest.Val2\", \"FloatTest.Val2\", \"Val2\", \"Val2\", \"gtefield\")\n\n\terrs = validate.VarWithValue(float32(5), float32(1), \"gtefield\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(float32(1), float32(5), \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\terrs = validate.VarWithValue(nil, 1, \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\terrs = validate.VarWithValue(5, \"T\", \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\terrs = validate.VarWithValue(5, start, \"gtefield\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gtefield\")\n\n\ttype TimeTest2 struct {\n\t\tStart *time.Time `validate:\"required\"`\n\t\tEnd   *time.Time `validate:\"required,gtefield=NonExistantField\"`\n\t}\n\n\ttimeTest2 := &TimeTest2{\n\t\tStart: &start,\n\t\tEnd:   &end,\n\t}\n\n\terrs = validate.Struct(timeTest2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeTest2.End\", \"TimeTest2.End\", \"End\", \"End\", \"gtefield\")\n}\n\nfunc TestValidateByTagAndValue(t *testing.T) {\n\tvalidate := New()\n\n\tval := \"test\"\n\tfield := \"test\"\n\terrs := validate.VarWithValue(val, field, \"required\")\n\tEqual(t, errs, nil)\n\n\tfn := func(fl FieldLevel) bool {\n\t\treturn fl.Parent().String() == fl.Field().String()\n\t}\n\n\terrs = validate.RegisterValidation(\"isequaltestfunc\", fn)\n\tEqual(t, errs, nil)\n\n\terrs = validate.VarWithValue(val, field, \"isequaltestfunc\")\n\tEqual(t, errs, nil)\n\n\tval = \"unequal\"\n\n\terrs = validate.VarWithValue(val, field, \"isequaltestfunc\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"isequaltestfunc\")\n}\n\nfunc TestAddFunctions(t *testing.T) {\n\tfn := func(fl FieldLevel) bool {\n\t\treturn true\n\t}\n\n\tfnCtx := func(ctx context.Context, fl FieldLevel) bool {\n\t\treturn true\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.RegisterValidation(\"new\", fn)\n\tEqual(t, errs, nil)\n\n\terrs = validate.RegisterValidation(\"\", fn)\n\tNotEqual(t, errs, nil)\n\n\terrs = validate.RegisterValidation(\"new\", nil)\n\tNotEqual(t, errs, nil)\n\n\terrs = validate.RegisterValidation(\"new\", fn)\n\tEqual(t, errs, nil)\n\n\terrs = validate.RegisterValidationCtx(\"new\", fnCtx)\n\tEqual(t, errs, nil)\n\n\tPanicMatches(t, func() { _ = validate.RegisterValidation(\"dive\", fn) }, \"Tag 'dive' either contains restricted characters or is the same as a restricted tag needed for normal operation\")\n}\n\nfunc TestChangeTag(t *testing.T) {\n\tvalidate := New()\n\tvalidate.SetTagName(\"val\")\n\n\ttype Test struct {\n\t\tName string `val:\"len=4\"`\n\t}\n\ts := &Test{\n\t\tName: \"TEST\",\n\t}\n\n\terrs := validate.Struct(s)\n\tEqual(t, errs, nil)\n\n\ts.Name = \"\"\n\n\terrs = validate.Struct(s)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Name\", \"Test.Name\", \"Name\", \"Name\", \"len\")\n}\n\nfunc TestUnexposedStruct(t *testing.T) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tName      string\n\t\tunexposed struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}\n\t}\n\n\ts := &Test{\n\t\tName: \"TEST\",\n\t}\n\tEqual(t, s.unexposed.A, \"\")\n\n\terrs := validate.Struct(s)\n\tEqual(t, errs, nil)\n}\n\nfunc TestBadParams(t *testing.T) {\n\tvalidate := New()\n\ti := 1\n\terrs := validate.Var(i, \"-\")\n\tEqual(t, errs, nil)\n\n\tPanicMatches(t, func() { _ = validate.Var(i, \"len=a\") }, \"strconv.ParseInt: parsing \\\"a\\\": invalid syntax\")\n\tPanicMatches(t, func() { _ = validate.Var(i, \"len=a\") }, \"strconv.ParseInt: parsing \\\"a\\\": invalid syntax\")\n\n\tvar ui uint = 1\n\tPanicMatches(t, func() { _ = validate.Var(ui, \"len=a\") }, \"strconv.ParseUint: parsing \\\"a\\\": invalid syntax\")\n\n\tf := 1.23\n\tPanicMatches(t, func() { _ = validate.Var(f, \"len=a\") }, \"strconv.ParseFloat: parsing \\\"a\\\": invalid syntax\")\n}\n\nfunc TestLength(t *testing.T) {\n\tvalidate := New()\n\ti := true\n\tPanicMatches(t, func() { _ = validate.Var(i, \"len\") }, \"Bad field type bool\")\n}\n\nfunc TestIsGt(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\tmyMap := map[string]string{}\n\terrs = validate.Var(myMap, \"gt=0\")\n\tNotEqual(t, errs, nil)\n\n\tf := 1.23\n\terrs = validate.Var(f, \"gt=5\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gt\")\n\n\tvar ui uint = 5\n\terrs = validate.Var(ui, \"gt=10\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gt\")\n\n\ti := true\n\tPanicMatches(t, func() { _ = validate.Var(i, \"gt\") }, \"Bad field type bool\")\n\n\ttm := time.Now().UTC()\n\ttm = tm.Add(time.Hour * 24)\n\n\terrs = validate.Var(tm, \"gt\")\n\tEqual(t, errs, nil)\n\n\tt2 := time.Now().UTC().Add(-time.Hour)\n\n\terrs = validate.Var(t2, \"gt\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gt\")\n\n\ttype Test struct {\n\t\tNow *time.Time `validate:\"gt\"`\n\t}\n\ts := &Test{\n\t\tNow: &tm,\n\t}\n\n\terrs = validate.Struct(s)\n\tEqual(t, errs, nil)\n\n\ts = &Test{\n\t\tNow: &t2,\n\t}\n\n\terrs = validate.Struct(s)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Now\", \"Test.Now\", \"Now\", \"Now\", \"gt\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"gt=59m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-time.Minute, \"gt=59m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gt\")\n\n\terrs = validate.Var(time.Hour-2*time.Minute, \"gt=59m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gt\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,gt=59m\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"gt=59m\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"gt\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"gt\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,gt=59m\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsGte(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ti := true\n\tPanicMatches(t, func() { _ = validate.Var(i, \"gte\") }, \"Bad field type bool\")\n\n\tt1 := time.Now().UTC()\n\tt1 = t1.Add(time.Hour * 24)\n\n\terrs = validate.Var(t1, \"gte\")\n\tEqual(t, errs, nil)\n\n\tt2 := time.Now().UTC().Add(-time.Hour)\n\n\terrs = validate.Var(t2, \"gte\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gte\")\n\n\ttype Test struct {\n\t\tNow *time.Time `validate:\"gte\"`\n\t}\n\ts := &Test{\n\t\tNow: &t1,\n\t}\n\n\terrs = validate.Struct(s)\n\tEqual(t, errs, nil)\n\n\ts = &Test{\n\t\tNow: &t2,\n\t}\n\n\terrs = validate.Struct(s)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Now\", \"Test.Now\", \"Now\", \"Now\", \"gte\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"gte=59m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-time.Minute, \"gte=59m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-2*time.Minute, \"gte=59m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"gte\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,gte=59m\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"gte=59m\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"gte\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,gte=59m\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestMinValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"min=59m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-time.Minute, \"min=59m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-2*time.Minute, \"min=59m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"min\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,min=59m\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"min=59m\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"min\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,min=59m\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestMaxValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"max=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour+time.Minute, \"max=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour+2*time.Minute, \"max=1h1m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"max\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,max=-1s\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"max=1h1m\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"max\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,max=-1s\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestMinMaxValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"min=59m,max=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-time.Minute, \"min=59m,max=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour+time.Minute, \"min=59m,max=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-2*time.Minute, \"min=59m,max=1h1m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"min\")\n\n\terrs = validate.Var(time.Hour+2*time.Minute, \"min=59m,max=1h1m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"max\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,min=59m,max=1h1m\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"min=59m,max=1h1m\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"min\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"max\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,min=59m,max=1h1m\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestLenValidation(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"len=1h\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour-time.Minute, \"len=1h\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"len\")\n\n\terrs = validate.Var(time.Hour+time.Minute, \"len=1h\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"len\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,len=1h\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"len=1h\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour - time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"len\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"len\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,len=1h\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsLt(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\tmyMap := map[string]string{}\n\terrs = validate.Var(myMap, \"lt=0\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lt\")\n\n\tf := 1.23\n\terrs = validate.Var(f, \"lt=0\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lt\")\n\n\tvar ui uint = 5\n\terrs = validate.Var(ui, \"lt=0\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lt\")\n\n\ti := true\n\tPanicMatches(t, func() { _ = validate.Var(i, \"lt\") }, \"Bad field type bool\")\n\n\tt1 := time.Now().UTC().Add(-time.Hour)\n\n\terrs = validate.Var(t1, \"lt\")\n\tEqual(t, errs, nil)\n\n\tt2 := time.Now().UTC()\n\tt2 = t2.Add(time.Hour * 24)\n\n\terrs = validate.Var(t2, \"lt\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lt\")\n\n\ttype Test struct {\n\t\tNow *time.Time `validate:\"lt\"`\n\t}\n\n\ts := &Test{\n\t\tNow: &t1,\n\t}\n\n\terrs = validate.Struct(s)\n\tEqual(t, errs, nil)\n\n\ts = &Test{\n\t\tNow: &t2,\n\t}\n\n\terrs = validate.Struct(s)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.Now\", \"Test.Now\", \"Now\", \"Now\", \"lt\")\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"lt=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour+time.Minute, \"lt=1h1m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lt\")\n\n\terrs = validate.Var(time.Hour+2*time.Minute, \"lt=1h1m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lt\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,lt=0\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"lt=1h1m\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"lt\")\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"lt\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,lt=0\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestIsLte(t *testing.T) {\n\tvar errs error\n\tvalidate := New()\n\n\ti := true\n\tPanicMatches(t, func() { _ = validate.Var(i, \"lte\") }, \"Bad field type bool\")\n\n\tt1 := time.Now().UTC().Add(-time.Hour)\n\n\terrs = validate.Var(t1, \"lte\")\n\tEqual(t, errs, nil)\n\n\tt2 := time.Now().UTC()\n\tt2 = t2.Add(time.Hour * 24)\n\n\terrs = validate.Var(t2, \"lte\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lte\")\n\n\ttype Test struct {\n\t\tNow *time.Time `validate:\"lte\"`\n\t}\n\n\ts := &Test{\n\t\tNow: &t1,\n\t}\n\n\terrs = validate.Struct(s)\n\tEqual(t, errs, nil)\n\n\ts = &Test{\n\t\tNow: &t2,\n\t}\n\n\terrs = validate.Struct(s)\n\tNotEqual(t, errs, nil)\n\n\t// Tests for time.Duration type.\n\n\t// -- Validations for a variable of time.Duration type.\n\n\terrs = validate.Var(time.Hour, \"lte=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour+time.Minute, \"lte=1h1m\")\n\tEqual(t, errs, nil)\n\n\terrs = validate.Var(time.Hour+2*time.Minute, \"lte=1h1m\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"lte\")\n\n\terrs = validate.Var(time.Duration(0), \"omitempty,lte=-1s\")\n\tEqual(t, errs, nil)\n\n\t// -- Validations for a struct with a time.Duration type field.\n\n\ttype TimeDurationTest struct {\n\t\tDuration time.Duration `validate:\"lte=1h1m\"`\n\t}\n\tvar timeDurationTest *TimeDurationTest\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tEqual(t, errs, nil)\n\n\ttimeDurationTest = &TimeDurationTest{time.Hour + 2*time.Minute}\n\terrs = validate.Struct(timeDurationTest)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TimeDurationTest.Duration\", \"TimeDurationTest.Duration\", \"Duration\", \"Duration\", \"lte\")\n\n\ttype TimeDurationOmitemptyTest struct {\n\t\tDuration time.Duration `validate:\"omitempty,lte=-1s\"`\n\t}\n\n\ttimeDurationOmitemptyTest := &TimeDurationOmitemptyTest{time.Duration(0)}\n\terrs = validate.Struct(timeDurationOmitemptyTest)\n\tEqual(t, errs, nil)\n}\n\nfunc TestUrnRFC2141(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"urn:a:b\", true},\n\t\t{\"urn:a::\", true},\n\t\t{\"urn:a:-\", true},\n\t\t{\"URN:simple:simple\", true},\n\t\t{\"urn:urna:simple\", true},\n\t\t{\"urn:burnout:nss\", true},\n\t\t{\"urn:burn:nss\", true},\n\t\t{\"urn:urnurnurn:x\", true},\n\t\t{\"urn:abcdefghilmnopqrstuvzabcdefghilm:x\", true},\n\t\t{\"URN:123:x\", true},\n\t\t{\"URN:abcd-:x\", true},\n\t\t{\"URN:abcd-abcd:x\", true},\n\t\t{\"urn:urnx:urn\", true},\n\t\t{\"urn:ciao:a:b:c\", true},\n\t\t{\"urn:aaa:x:y:\", true},\n\t\t{\"urn:ciao:-\", true},\n\t\t{\"urn:colon:::::nss\", true},\n\t\t{\"urn:ciao:@!=%2C(xyz)+a,b.*@g=$_'\", true},\n\t\t{\"URN:hexes:%25\", true},\n\t\t{\"URN:x:abc%1Dz%2F%3az\", true},\n\t\t{\"URN:foo:a123,456\", true},\n\t\t{\"urn:foo:a123,456\", true},\n\t\t{\"urn:FOO:a123,456\", true},\n\t\t{\"urn:foo:A123,456\", true},\n\t\t{\"urn:foo:a123%2C456\", true},\n\t\t{\"URN:FOO:a123%2c456\", true},\n\t\t{\"URN:FOO:ABC%FFabc123%2c456\", true},\n\t\t{\"URN:FOO:ABC%FFabc123%2C456%9A\", true},\n\t\t{\"urn:ietf:params:scim:schemas:core:2.0:User\", true},\n\t\t{\"urn:ietf:params:scim:schemas:extension:enterprise:2.0:User:meta.lastModified\", true},\n\t\t{\"URN:-xxx:x\", false},\n\t\t{\"urn::colon:nss\", false},\n\t\t{\"urn:abcdefghilmnopqrstuvzabcdefghilmn:specificstring\", false},\n\t\t{\"URN:a!?:x\", false},\n\t\t{\"URN:#,:x\", false},\n\t\t{\"urn:urn:NSS\", false},\n\t\t{\"urn:URN:NSS\", false},\n\t\t{\"urn:white space:NSS\", false},\n\t\t{\"urn:concat:no spaces\", false},\n\t\t{\"urn:a:%\", false},\n\t\t{\"urn:\", false},\n\t}\n\n\ttag := \"urn_rfc2141\"\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d URN failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d URN failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != tag {\n\t\t\t\t\tt.Fatalf(\"Index: %d URN failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ti := 1\n\tPanicMatches(t, func() { _ = validate.Var(i, tag) }, \"Bad field type int\")\n}\n\nfunc TestUrl(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"http://foo.bar#com\", true},\n\t\t{\"http://foobar.com\", true},\n\t\t{\"https://foobar.com\", true},\n\t\t{\"foobar.com\", false},\n\t\t{\"http://foobar.coffee/\", true},\n\t\t{\"http://foobar.中文网/\", true},\n\t\t{\"http://foobar.org/\", true},\n\t\t{\"http://foobar.org:8080/\", true},\n\t\t{\"ftp://foobar.ru/\", true},\n\t\t{\"http://user:pass@www.foobar.com/\", true},\n\t\t{\"http://127.0.0.1/\", true},\n\t\t{\"http://duckduckgo.com/?q=%2F\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/?foo=bar#baz=qux\", true},\n\t\t{\"http://foobar.com?foo=bar\", true},\n\t\t{\"http://www.xn--froschgrn-x9a.net/\", true},\n\t\t{\"\", false},\n\t\t{\"xyz://foobar.com\", true},\n\t\t{\"invalid.\", false},\n\t\t{\".com\", false},\n\t\t{\"rtmp://foobar.com\", true},\n\t\t{\"http://www.foo_bar.com/\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/#baz\", true},\n\t\t{\"http://foobar.com#baz=qux\", true},\n\t\t{\"http://foobar.com/t$-_.+!*\\\\'(),\", true},\n\t\t{\"http://www.foobar.com/~foobar\", true},\n\t\t{\"http://www.-foobar.com/\", true},\n\t\t{\"http://www.foo---bar.com/\", true},\n\t\t{\"mailto:someone@example.com\", true},\n\t\t{\"irc://irc.server.org/channel\", true},\n\t\t{\"irc://#channel@network\", true},\n\t\t{\"/abs/test/dir\", false},\n\t\t{\"./rel/test/dir\", false},\n\t\t{\"irc:\", false},\n\t\t{\"http://\", false},\n\t\t{\"file://path/to/file.txt\", true},\n\t\t{\"file:///c:/Windows/file.txt\", true},\n\t\t{\"file://localhost/path/to/file.txt\", true},\n\t\t{\"file://localhost/c:/WINDOWS/file.txt\", true},\n\t\t{\"file://\", true},\n\t\t{\"file:////remotehost/path/file.txt\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"url\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d URL failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d URL failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"url\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d URL failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ti := 1\n\tPanicMatches(t, func() { _ = validate.Var(i, \"url\") }, \"Bad field type int\")\n}\n\nfunc TestHttpUrl(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"http://foo.bar#com\", true},\n\t\t{\"http://foobar.com\", true},\n\t\t{\"HTTP://foobar.com\", true},\n\t\t{\"https://foobar.com\", true},\n\t\t{\"foobar.com\", false},\n\t\t{\"http://foobar.coffee/\", true},\n\t\t{\"http://foobar.中文网/\", true},\n\t\t{\"http://foobar.org/\", true},\n\t\t{\"http://foobar.org:8080/\", true},\n\t\t{\"ftp://foobar.ru/\", false},\n\t\t{\"file:///etc/passwd\", false},\n\t\t{\"file://C:/windows/win.ini\", false},\n\t\t{\"http://user:pass@www.foobar.com/\", true},\n\t\t{\"http://127.0.0.1/\", true},\n\t\t{\"http://duckduckgo.com/?q=%2F\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/?foo=bar#baz=qux\", true},\n\t\t{\"http://foobar.com?foo=bar\", true},\n\t\t{\"http://www.xn--froschgrn-x9a.net/\", true},\n\t\t{\"\", false},\n\t\t{\"a://b\", false},\n\t\t{\"xyz://foobar.com\", false},\n\t\t{\"invalid.\", false},\n\t\t{\".com\", false},\n\t\t{\"rtmp://foobar.com\", false},\n\t\t{\"http://www.foo_bar.com/\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/#baz\", true},\n\t\t{\"http://foobar.com#baz=qux\", true},\n\t\t{\"http://foobar.com/t$-_.+!*\\\\'(),\", true},\n\t\t{\"http://www.foobar.com/~foobar\", true},\n\t\t{\"http://www.-foobar.com/\", true},\n\t\t{\"http://www.foo---bar.com/\", true},\n\t\t{\"mailto:someone@example.com\", false},\n\t\t{\"irc://irc.server.org/channel\", false},\n\t\t{\"irc://#channel@network\", false},\n\t\t{\"/abs/test/dir\", false},\n\t\t{\"./rel/test/dir\", false},\n\t\t{\"http:\", false},\n\t\t{\"http://\", false},\n\t\t{\"http://#invalid\", false},\n\t\t{\"https://1.1.1.1\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"http_url\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d HTTP URL failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d HTTP URL failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"http_url\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d HTTP URL failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ti := 1\n\tPanicMatches(t, func() { _ = validate.Var(i, \"http_url\") }, \"Bad field type int\")\n}\n\nfunc TestUri(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"http://foo.bar#com\", true},\n\t\t{\"http://foobar.com\", true},\n\t\t{\"https://foobar.com\", true},\n\t\t{\"foobar.com\", false},\n\t\t{\"http://foobar.coffee/\", true},\n\t\t{\"http://foobar.中文网/\", true},\n\t\t{\"http://foobar.org/\", true},\n\t\t{\"http://foobar.org:8080/\", true},\n\t\t{\"ftp://foobar.ru/\", true},\n\t\t{\"http://user:pass@www.foobar.com/\", true},\n\t\t{\"http://127.0.0.1/\", true},\n\t\t{\"http://duckduckgo.com/?q=%2F\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com/?foo=bar#baz=qux\", true},\n\t\t{\"http://foobar.com?foo=bar\", true},\n\t\t{\"http://www.xn--froschgrn-x9a.net/\", true},\n\t\t{\"\", false},\n\t\t{\"xyz://foobar.com\", true},\n\t\t{\"invalid.\", false},\n\t\t{\".com\", false},\n\t\t{\"rtmp://foobar.com\", true},\n\t\t{\"http://www.foo_bar.com/\", true},\n\t\t{\"http://localhost:3000/\", true},\n\t\t{\"http://foobar.com#baz=qux\", true},\n\t\t{\"http://foobar.com/t$-_.+!*\\\\'(),\", true},\n\t\t{\"http://www.foobar.com/~foobar\", true},\n\t\t{\"http://www.-foobar.com/\", true},\n\t\t{\"http://www.foo---bar.com/\", true},\n\t\t{\"mailto:someone@example.com\", true},\n\t\t{\"irc://irc.server.org/channel\", true},\n\t\t{\"irc://#channel@network\", true},\n\t\t{\"/abs/test/dir\", true},\n\t\t{\"./rel/test/dir\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uri\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d URI failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d URI failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uri\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d URI failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ti := 1\n\tPanicMatches(t, func() { _ = validate.Var(i, \"uri\") }, \"Bad field type int\")\n}\n\nfunc TestOrTag(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"rgba(0,31,255,0.5)\"\n\terrs := validate.Var(s, \"rgb|rgba\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgba(0,31,255,0.5)\"\n\terrs = validate.Var(s, \"rgb|rgba|len=18\")\n\tEqual(t, errs, nil)\n\n\ts = \"this ain't right\"\n\terrs = validate.Var(s, \"rgb|rgba\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgb|rgba\")\n\n\ts = \"this ain't right\"\n\terrs = validate.Var(s, \"rgb|rgba|len=10\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgb|rgba|len=10\")\n\n\ts = \"this is right\"\n\terrs = validate.Var(s, \"rgb|rgba|len=13\")\n\tEqual(t, errs, nil)\n\n\ts = \"\"\n\terrs = validate.Var(s, \"omitempty,rgb|rgba\")\n\tEqual(t, errs, nil)\n\n\ts = \"green\"\n\terrs = validate.Var(s, \"eq=|eq=blue,rgb|rgba\") // should fail on first validation block\n\tNotEqual(t, errs, nil)\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tEqual(t, ve[0].Tag(), \"eq=|eq=blue\")\n\n\ts = \"this is right, but a blank or isn't\"\n\n\tPanicMatches(t, func() { _ = validate.Var(s, \"rgb||len=13\") }, \"Invalid validation tag on field ''\")\n\tPanicMatches(t, func() { _ = validate.Var(s, \"rgb|rgbaa|len=13\") }, \"Undefined validation function 'rgbaa' on field ''\")\n\n\tv2 := New()\n\tv2.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype Colors struct {\n\t\tFav string `validate:\"rgb|rgba\" json:\"fc\"`\n\t}\n\n\tc := Colors{Fav: \"this ain't right\"}\n\n\terr := v2.Struct(c)\n\tNotEqual(t, err, nil)\n\n\terrs = err.(ValidationErrors)\n\tfe := getError(errs, \"Colors.fc\", \"Colors.Fav\")\n\tNotEqual(t, fe, nil)\n}\n\nfunc TestHsla(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"hsla(360,100%,100%,1)\"\n\terrs := validate.Var(s, \"hsla\")\n\tEqual(t, errs, nil)\n\n\ts = \"hsla(360,100%,100%,0.5)\"\n\terrs = validate.Var(s, \"hsla\")\n\tEqual(t, errs, nil)\n\n\ts = \"hsla(0,0%,0%, 0)\"\n\terrs = validate.Var(s, \"hsla\")\n\tEqual(t, errs, nil)\n\n\ts = \"hsl(361,100%,50%,1)\"\n\terrs = validate.Var(s, \"hsla\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsla\")\n\n\ts = \"hsl(361,100%,50%)\"\n\terrs = validate.Var(s, \"hsla\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsla\")\n\n\ts = \"hsla(361,100%,50%)\"\n\terrs = validate.Var(s, \"hsla\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsla\")\n\n\ts = \"hsla(360,101%,50%)\"\n\terrs = validate.Var(s, \"hsla\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsla\")\n\n\ts = \"hsla(360,100%,101%)\"\n\terrs = validate.Var(s, \"hsla\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsla\")\n\n\ti := 1\n\terrs = validate.Var(i, \"hsla\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsla\")\n}\n\nfunc TestHsl(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"hsl(360,100%,50%)\"\n\terrs := validate.Var(s, \"hsl\")\n\tEqual(t, errs, nil)\n\n\ts = \"hsl(0,0%,0%)\"\n\terrs = validate.Var(s, \"hsl\")\n\tEqual(t, errs, nil)\n\n\ts = \"hsl(361,100%,50%)\"\n\terrs = validate.Var(s, \"hsl\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsl\")\n\n\ts = \"hsl(361,101%,50%)\"\n\terrs = validate.Var(s, \"hsl\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsl\")\n\n\ts = \"hsl(361,100%,101%)\"\n\terrs = validate.Var(s, \"hsl\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsl\")\n\n\ts = \"hsl(-10,100%,100%)\"\n\terrs = validate.Var(s, \"hsl\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsl\")\n\n\ti := 1\n\terrs = validate.Var(i, \"hsl\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hsl\")\n}\n\nfunc TestRgba(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"rgba(0,31,255,0.5)\"\n\terrs := validate.Var(s, \"rgba\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgba(0,31,255,0.12)\"\n\terrs = validate.Var(s, \"rgba\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgba(12%,55%,100%,0.12)\"\n\terrs = validate.Var(s, \"rgba\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgba( 0,  31, 255, 0.5)\"\n\terrs = validate.Var(s, \"rgba\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgba(12%,55,100%,0.12)\"\n\terrs = validate.Var(s, \"rgba\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgba\")\n\n\ts = \"rgb(0,  31, 255)\"\n\terrs = validate.Var(s, \"rgba\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgba\")\n\n\ts = \"rgb(1,349,275,0.5)\"\n\terrs = validate.Var(s, \"rgba\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgba\")\n\n\ts = \"rgb(01,31,255,0.5)\"\n\terrs = validate.Var(s, \"rgba\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgba\")\n\n\ti := 1\n\terrs = validate.Var(i, \"rgba\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgba\")\n}\n\nfunc TestRgb(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"rgb(0,31,255)\"\n\terrs := validate.Var(s, \"rgb\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgb(0,  31, 255)\"\n\terrs = validate.Var(s, \"rgb\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgb(10%,  50%, 100%)\"\n\terrs = validate.Var(s, \"rgb\")\n\tEqual(t, errs, nil)\n\n\ts = \"rgb(10%,  50%, 55)\"\n\terrs = validate.Var(s, \"rgb\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgb\")\n\n\ts = \"rgb(1,349,275)\"\n\terrs = validate.Var(s, \"rgb\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgb\")\n\n\ts = \"rgb(01,31,255)\"\n\terrs = validate.Var(s, \"rgb\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgb\")\n\n\ts = \"rgba(0,31,255)\"\n\terrs = validate.Var(s, \"rgb\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgb\")\n\n\ti := 1\n\terrs = validate.Var(i, \"rgb\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"rgb\")\n}\n\nfunc TestEmail(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"test@mail.com\"\n\terrs := validate.Var(s, \"email\")\n\tEqual(t, errs, nil)\n\n\ts = \"Dörte@Sörensen.example.com\"\n\terrs = validate.Var(s, \"email\")\n\tEqual(t, errs, nil)\n\n\ts = \"θσερ@εχαμπλε.ψομ\"\n\terrs = validate.Var(s, \"email\")\n\tEqual(t, errs, nil)\n\n\ts = \"юзер@екзампл.ком\"\n\terrs = validate.Var(s, \"email\")\n\tEqual(t, errs, nil)\n\n\ts = \"उपयोगकर्ता@उदाहरण.कॉम\"\n\terrs = validate.Var(s, \"email\")\n\tEqual(t, errs, nil)\n\n\ts = \"用户@例子.广告\"\n\terrs = validate.Var(s, \"email\")\n\tEqual(t, errs, nil)\n\n\ts = \"mail@domain_with_underscores.org\"\n\terrs = validate.Var(s, \"email\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"email\")\n\n\ts = \"\"\n\terrs = validate.Var(s, \"email\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"email\")\n\n\ts = \"test@email\"\n\terrs = validate.Var(s, \"email\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"email\")\n\n\ts = \"test@email.\"\n\terrs = validate.Var(s, \"email\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"email\")\n\n\ts = \"@email.com\"\n\terrs = validate.Var(s, \"email\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"email\")\n\n\ts = `\"test test\"@email.com`\n\terrs = validate.Var(s, \"email\")\n\tEqual(t, errs, nil)\n\n\ts = `\"@email.com`\n\terrs = validate.Var(s, \"email\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"email\")\n\n\ti := true\n\terrs = validate.Var(i, \"email\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"email\")\n}\n\nfunc TestHexColor(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"#fff\"\n\terrs := validate.Var(s, \"hexcolor\")\n\tEqual(t, errs, nil)\n\n\ts = \"#c2c2c2\"\n\terrs = validate.Var(s, \"hexcolor\")\n\tEqual(t, errs, nil)\n\n\ts = \"fff\"\n\terrs = validate.Var(s, \"hexcolor\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hexcolor\")\n\n\ts = \"fffFF\"\n\terrs = validate.Var(s, \"hexcolor\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hexcolor\")\n\n\ti := true\n\terrs = validate.Var(i, \"hexcolor\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hexcolor\")\n}\n\nfunc TestHexadecimal(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"ff0044\"\n\terrs := validate.Var(s, \"hexadecimal\")\n\tEqual(t, errs, nil)\n\n\ts = \"0xff0044\"\n\terrs = validate.Var(s, \"hexadecimal\")\n\tEqual(t, errs, nil)\n\n\ts = \"0Xff0044\"\n\terrs = validate.Var(s, \"hexadecimal\")\n\tEqual(t, errs, nil)\n\n\ts = \"abcdefg\"\n\terrs = validate.Var(s, \"hexadecimal\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hexadecimal\")\n\n\ti := true\n\terrs = validate.Var(i, \"hexadecimal\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"hexadecimal\")\n}\n\nfunc TestNumber(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"1\"\n\terrs := validate.Var(s, \"number\")\n\tEqual(t, errs, nil)\n\n\ts = \"+1\"\n\terrs = validate.Var(s, \"number\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"number\")\n\n\ts = \"-1\"\n\terrs = validate.Var(s, \"number\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"number\")\n\n\ts = \"1.12\"\n\terrs = validate.Var(s, \"number\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"number\")\n\n\ts = \"+1.12\"\n\terrs = validate.Var(s, \"number\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"number\")\n\n\ts = \"-1.12\"\n\terrs = validate.Var(s, \"number\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"number\")\n\n\ts = \"1.\"\n\terrs = validate.Var(s, \"number\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"number\")\n\n\ts = \"1.o\"\n\terrs = validate.Var(s, \"number\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"number\")\n\n\ti := 1\n\terrs = validate.Var(i, \"number\")\n\tEqual(t, errs, nil)\n}\n\nfunc TestNumeric(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"1\"\n\terrs := validate.Var(s, \"numeric\")\n\tEqual(t, errs, nil)\n\n\ts = \"+1\"\n\terrs = validate.Var(s, \"numeric\")\n\tEqual(t, errs, nil)\n\n\ts = \"-1\"\n\terrs = validate.Var(s, \"numeric\")\n\tEqual(t, errs, nil)\n\n\ts = \"1.12\"\n\terrs = validate.Var(s, \"numeric\")\n\tEqual(t, errs, nil)\n\n\ts = \"+1.12\"\n\terrs = validate.Var(s, \"numeric\")\n\tEqual(t, errs, nil)\n\n\ts = \"-1.12\"\n\terrs = validate.Var(s, \"numeric\")\n\tEqual(t, errs, nil)\n\n\ts = \"1.\"\n\terrs = validate.Var(s, \"numeric\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"numeric\")\n\n\ts = \"1.o\"\n\terrs = validate.Var(s, \"numeric\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"numeric\")\n\n\ti := 1\n\terrs = validate.Var(i, \"numeric\")\n\tEqual(t, errs, nil)\n}\nfunc TestBoolean(t *testing.T) {\n\tvalidate := New()\n\n\tb := true\n\terrs := validate.Var(b, \"boolean\")\n\tEqual(t, errs, nil)\n\n\tb = false\n\terrs = validate.Var(b, \"boolean\")\n\tEqual(t, errs, nil)\n\n\ts := \"true\"\n\terrs = validate.Var(s, \"boolean\")\n\tEqual(t, errs, nil)\n\n\ts = \"false\"\n\terrs = validate.Var(s, \"boolean\")\n\tEqual(t, errs, nil)\n\n\ts = \"0\"\n\terrs = validate.Var(s, \"boolean\")\n\tEqual(t, errs, nil)\n\n\ts = \"1\"\n\terrs = validate.Var(s, \"boolean\")\n\tEqual(t, errs, nil)\n\n\ts = \"xyz\"\n\terrs = validate.Var(s, \"boolean\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"boolean\")\n\n\ts = \"1.\"\n\terrs = validate.Var(s, \"boolean\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"boolean\")\n}\n\nfunc TestAlphaNumeric(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"abcd123\"\n\terrs := validate.Var(s, \"alphanum\")\n\tEqual(t, errs, nil)\n\n\ts = \"abc!23\"\n\terrs = validate.Var(s, \"alphanum\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"alphanum\")\n\n\terrs = validate.Var(1, \"alphanum\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"alphanum\")\n}\n\nfunc TestAlpha(t *testing.T) {\n\tvalidate := New()\n\n\ts := \"abcd\"\n\terrs := validate.Var(s, \"alpha\")\n\tEqual(t, errs, nil)\n\n\ts = \"abc®\"\n\terrs = validate.Var(s, \"alpha\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"alpha\")\n\n\ts = \"abc÷\"\n\terrs = validate.Var(s, \"alpha\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"alpha\")\n\n\ts = \"abc1\"\n\terrs = validate.Var(s, \"alpha\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"alpha\")\n\n\ts = \"this is a test string\"\n\terrs = validate.Var(s, \"alpha\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"alpha\")\n\n\terrs = validate.Var(1, \"alpha\")\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"\", \"\", \"\", \"\", \"alpha\")\n}\n\nfunc TestStructStringValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttSuccess := &TestString{\n\t\tRequired:  \"Required\",\n\t\tLen:       \"length==10\",\n\t\tMin:       \"min=1\",\n\t\tMax:       \"1234567890\",\n\t\tMinMax:    \"12345\",\n\t\tLt:        \"012345678\",\n\t\tLte:       \"0123456789\",\n\t\tGt:        \"01234567890\",\n\t\tGte:       \"0123456789\",\n\t\tBoolean:   \"true\",\n\t\tOmitEmpty: \"\",\n\t\tSub: &SubTest{\n\t\t\tTest: \"1\",\n\t\t},\n\t\tSubIgnore: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}{\n\t\t\tA: \"1\",\n\t\t},\n\t\tIface: &Impl{\n\t\t\tF: \"123\",\n\t\t},\n\t}\n\n\terrs := validate.Struct(tSuccess)\n\tEqual(t, errs, nil)\n\n\ttFail := &TestString{\n\t\tRequired:  \"\",\n\t\tLen:       \"\",\n\t\tMin:       \"\",\n\t\tMax:       \"12345678901\",\n\t\tMinMax:    \"\",\n\t\tLt:        \"0123456789\",\n\t\tLte:       \"01234567890\",\n\t\tGt:        \"1\",\n\t\tGte:       \"1\",\n\t\tOmitEmpty: \"12345678901\",\n\t\tBoolean:   \"nope\",\n\t\tSub: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA string `validate:\"required\"`\n\t\t}{\n\t\t\tA: \"\",\n\t\t},\n\t\tIface: &Impl{\n\t\t\tF: \"12\",\n\t\t},\n\t}\n\n\terrs = validate.Struct(tFail)\n\n\t// Assert Top Level\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 14)\n\n\t// Assert Fields\n\tAssertError(t, errs, \"TestString.Required\", \"TestString.Required\", \"Required\", \"Required\", \"required\")\n\tAssertError(t, errs, \"TestString.Len\", \"TestString.Len\", \"Len\", \"Len\", \"len\")\n\tAssertError(t, errs, \"TestString.Min\", \"TestString.Min\", \"Min\", \"Min\", \"min\")\n\tAssertError(t, errs, \"TestString.Max\", \"TestString.Max\", \"Max\", \"Max\", \"max\")\n\tAssertError(t, errs, \"TestString.MinMax\", \"TestString.MinMax\", \"MinMax\", \"MinMax\", \"min\")\n\tAssertError(t, errs, \"TestString.Lt\", \"TestString.Lt\", \"Lt\", \"Lt\", \"lt\")\n\tAssertError(t, errs, \"TestString.Lte\", \"TestString.Lte\", \"Lte\", \"Lte\", \"lte\")\n\tAssertError(t, errs, \"TestString.Gt\", \"TestString.Gt\", \"Gt\", \"Gt\", \"gt\")\n\tAssertError(t, errs, \"TestString.Gte\", \"TestString.Gte\", \"Gte\", \"Gte\", \"gte\")\n\tAssertError(t, errs, \"TestString.OmitEmpty\", \"TestString.OmitEmpty\", \"OmitEmpty\", \"OmitEmpty\", \"max\")\n\tAssertError(t, errs, \"TestString.Boolean\", \"TestString.Boolean\", \"Boolean\", \"Boolean\", \"boolean\")\n\n\t// Nested Struct Field Errs\n\tAssertError(t, errs, \"TestString.Anonymous.A\", \"TestString.Anonymous.A\", \"A\", \"A\", \"required\")\n\tAssertError(t, errs, \"TestString.Sub.Test\", \"TestString.Sub.Test\", \"Test\", \"Test\", \"required\")\n\tAssertError(t, errs, \"TestString.Iface.F\", \"TestString.Iface.F\", \"F\", \"F\", \"len\")\n}\n\nfunc TestStructInt32Validation(t *testing.T) {\n\ttype TestInt32 struct {\n\t\tRequired  int `validate:\"required\"`\n\t\tLen       int `validate:\"len=10\"`\n\t\tMin       int `validate:\"min=1\"`\n\t\tMax       int `validate:\"max=10\"`\n\t\tMinMax    int `validate:\"min=1,max=10\"`\n\t\tLt        int `validate:\"lt=10\"`\n\t\tLte       int `validate:\"lte=10\"`\n\t\tGt        int `validate:\"gt=10\"`\n\t\tGte       int `validate:\"gte=10\"`\n\t\tOmitEmpty int `validate:\"omitempty,min=1,max=10\"`\n\t}\n\n\ttSuccess := &TestInt32{\n\t\tRequired:  1,\n\t\tLen:       10,\n\t\tMin:       1,\n\t\tMax:       10,\n\t\tMinMax:    5,\n\t\tLt:        9,\n\t\tLte:       10,\n\t\tGt:        11,\n\t\tGte:       10,\n\t\tOmitEmpty: 0,\n\t}\n\n\tvalidate := New()\n\terrs := validate.Struct(tSuccess)\n\tEqual(t, errs, nil)\n\n\ttFail := &TestInt32{\n\t\tRequired:  0,\n\t\tLen:       11,\n\t\tMin:       -1,\n\t\tMax:       11,\n\t\tMinMax:    -1,\n\t\tLt:        10,\n\t\tLte:       11,\n\t\tGt:        10,\n\t\tGte:       9,\n\t\tOmitEmpty: 11,\n\t}\n\n\terrs = validate.Struct(tFail)\n\n\t// Assert Top Level\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 10)\n\n\t// Assert Fields\n\tAssertError(t, errs, \"TestInt32.Required\", \"TestInt32.Required\", \"Required\", \"Required\", \"required\")\n\tAssertError(t, errs, \"TestInt32.Len\", \"TestInt32.Len\", \"Len\", \"Len\", \"len\")\n\tAssertError(t, errs, \"TestInt32.Min\", \"TestInt32.Min\", \"Min\", \"Min\", \"min\")\n\tAssertError(t, errs, \"TestInt32.Max\", \"TestInt32.Max\", \"Max\", \"Max\", \"max\")\n\tAssertError(t, errs, \"TestInt32.MinMax\", \"TestInt32.MinMax\", \"MinMax\", \"MinMax\", \"min\")\n\tAssertError(t, errs, \"TestInt32.Lt\", \"TestInt32.Lt\", \"Lt\", \"Lt\", \"lt\")\n\tAssertError(t, errs, \"TestInt32.Lte\", \"TestInt32.Lte\", \"Lte\", \"Lte\", \"lte\")\n\tAssertError(t, errs, \"TestInt32.Gt\", \"TestInt32.Gt\", \"Gt\", \"Gt\", \"gt\")\n\tAssertError(t, errs, \"TestInt32.Gte\", \"TestInt32.Gte\", \"Gte\", \"Gte\", \"gte\")\n\tAssertError(t, errs, \"TestInt32.OmitEmpty\", \"TestInt32.OmitEmpty\", \"OmitEmpty\", \"OmitEmpty\", \"max\")\n}\n\nfunc TestStructUint64Validation(t *testing.T) {\n\tvalidate := New()\n\n\ttSuccess := &TestUint64{\n\t\tRequired:  1,\n\t\tLen:       10,\n\t\tMin:       1,\n\t\tMax:       10,\n\t\tMinMax:    5,\n\t\tOmitEmpty: 0,\n\t}\n\n\terrs := validate.Struct(tSuccess)\n\tEqual(t, errs, nil)\n\n\ttFail := &TestUint64{\n\t\tRequired:  0,\n\t\tLen:       11,\n\t\tMin:       0,\n\t\tMax:       11,\n\t\tMinMax:    0,\n\t\tOmitEmpty: 11,\n\t}\n\n\terrs = validate.Struct(tFail)\n\n\t// Assert Top Level\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 6)\n\n\t// Assert Fields\n\tAssertError(t, errs, \"TestUint64.Required\", \"TestUint64.Required\", \"Required\", \"Required\", \"required\")\n\tAssertError(t, errs, \"TestUint64.Len\", \"TestUint64.Len\", \"Len\", \"Len\", \"len\")\n\tAssertError(t, errs, \"TestUint64.Min\", \"TestUint64.Min\", \"Min\", \"Min\", \"min\")\n\tAssertError(t, errs, \"TestUint64.Max\", \"TestUint64.Max\", \"Max\", \"Max\", \"max\")\n\tAssertError(t, errs, \"TestUint64.MinMax\", \"TestUint64.MinMax\", \"MinMax\", \"MinMax\", \"min\")\n\tAssertError(t, errs, \"TestUint64.OmitEmpty\", \"TestUint64.OmitEmpty\", \"OmitEmpty\", \"OmitEmpty\", \"max\")\n}\n\nfunc TestStructFloat64Validation(t *testing.T) {\n\tvalidate := New()\n\n\ttSuccess := &TestFloat64{\n\t\tRequired:  1,\n\t\tLen:       10,\n\t\tMin:       1,\n\t\tMax:       10,\n\t\tMinMax:    5,\n\t\tOmitEmpty: 0,\n\t}\n\n\terrs := validate.Struct(tSuccess)\n\tEqual(t, errs, nil)\n\n\ttFail := &TestFloat64{\n\t\tRequired:  0,\n\t\tLen:       11,\n\t\tMin:       0,\n\t\tMax:       11,\n\t\tMinMax:    0,\n\t\tOmitEmpty: 11,\n\t}\n\n\terrs = validate.Struct(tFail)\n\n\t// Assert Top Level\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 6)\n\n\t// Assert Fields\n\tAssertError(t, errs, \"TestFloat64.Required\", \"TestFloat64.Required\", \"Required\", \"Required\", \"required\")\n\tAssertError(t, errs, \"TestFloat64.Len\", \"TestFloat64.Len\", \"Len\", \"Len\", \"len\")\n\tAssertError(t, errs, \"TestFloat64.Min\", \"TestFloat64.Min\", \"Min\", \"Min\", \"min\")\n\tAssertError(t, errs, \"TestFloat64.Max\", \"TestFloat64.Max\", \"Max\", \"Max\", \"max\")\n\tAssertError(t, errs, \"TestFloat64.MinMax\", \"TestFloat64.MinMax\", \"MinMax\", \"MinMax\", \"min\")\n\tAssertError(t, errs, \"TestFloat64.OmitEmpty\", \"TestFloat64.OmitEmpty\", \"OmitEmpty\", \"OmitEmpty\", \"max\")\n}\n\nfunc TestStructSliceValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttSuccess := &TestSlice{\n\t\tRequired:  []int{1},\n\t\tLen:       []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0},\n\t\tMin:       []int{1, 2},\n\t\tMax:       []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0},\n\t\tMinMax:    []int{1, 2, 3, 4, 5},\n\t\tOmitEmpty: nil,\n\t}\n\n\terrs := validate.Struct(tSuccess)\n\tEqual(t, errs, nil)\n\n\ttFail := &TestSlice{\n\t\tRequired:  nil,\n\t\tLen:       []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1},\n\t\tMin:       []int{},\n\t\tMax:       []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1},\n\t\tMinMax:    []int{},\n\t\tOmitEmpty: []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1},\n\t}\n\n\terrs = validate.Struct(tFail)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 6)\n\n\t// Assert Field Errors\n\tAssertError(t, errs, \"TestSlice.Required\", \"TestSlice.Required\", \"Required\", \"Required\", \"required\")\n\tAssertError(t, errs, \"TestSlice.Len\", \"TestSlice.Len\", \"Len\", \"Len\", \"len\")\n\tAssertError(t, errs, \"TestSlice.Min\", \"TestSlice.Min\", \"Min\", \"Min\", \"min\")\n\tAssertError(t, errs, \"TestSlice.Max\", \"TestSlice.Max\", \"Max\", \"Max\", \"max\")\n\tAssertError(t, errs, \"TestSlice.MinMax\", \"TestSlice.MinMax\", \"MinMax\", \"MinMax\", \"min\")\n\tAssertError(t, errs, \"TestSlice.OmitEmpty\", \"TestSlice.OmitEmpty\", \"OmitEmpty\", \"OmitEmpty\", \"max\")\n\n\tfe := getError(errs, \"TestSlice.Len\", \"TestSlice.Len\")\n\tNotEqual(t, fe, nil)\n\tEqual(t, fe.Field(), \"Len\")\n\tEqual(t, fe.StructField(), \"Len\")\n\tEqual(t, fe.Namespace(), \"TestSlice.Len\")\n\tEqual(t, fe.StructNamespace(), \"TestSlice.Len\")\n\tEqual(t, fe.Tag(), \"len\")\n\tEqual(t, fe.ActualTag(), \"len\")\n\tEqual(t, fe.Param(), \"10\")\n\tEqual(t, fe.Kind(), reflect.Slice)\n\tEqual(t, fe.Type(), reflect.TypeOf([]int{}))\n\n\t_, ok := fe.Value().([]int)\n\tEqual(t, ok, true)\n}\n\nfunc TestInvalidStruct(t *testing.T) {\n\tvalidate := New()\n\n\ts := &SubTest{\n\t\tTest: \"1\",\n\t}\n\n\terr := validate.Struct(s.Test)\n\tNotEqual(t, err, nil)\n\tEqual(t, err.Error(), \"validator: (nil string)\")\n\n\terr = validate.Struct(nil)\n\tNotEqual(t, err, nil)\n\tEqual(t, err.Error(), \"validator: (nil)\")\n\n\terr = validate.StructPartial(nil, \"SubTest.Test\")\n\tNotEqual(t, err, nil)\n\tEqual(t, err.Error(), \"validator: (nil)\")\n\n\terr = validate.StructExcept(nil, \"SubTest.Test\")\n\tNotEqual(t, err, nil)\n\tEqual(t, err.Error(), \"validator: (nil)\")\n}\n\nfunc TestInvalidValidatorFunction(t *testing.T) {\n\tvalidate := New()\n\n\ts := &SubTest{\n\t\tTest: \"1\",\n\t}\n\n\tPanicMatches(t, func() { _ = validate.Var(s.Test, \"zzxxBadFunction\") }, \"Undefined validation function 'zzxxBadFunction' on field ''\")\n}\n\nfunc TestCustomFieldName(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"schema\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype A struct {\n\t\tB string `schema:\"b\" validate:\"required\"`\n\t\tC string `schema:\"c\" validate:\"required\"`\n\t\tD []bool `schema:\"d\" validate:\"required\"`\n\t\tE string `schema:\"-\" validate:\"required\"`\n\t}\n\n\ta := &A{}\n\n\terr := validate.Struct(a)\n\tNotEqual(t, err, nil)\n\n\terrs := err.(ValidationErrors)\n\tEqual(t, len(errs), 4)\n\tEqual(t, getError(errs, \"A.b\", \"A.B\").Field(), \"b\")\n\tEqual(t, getError(errs, \"A.c\", \"A.C\").Field(), \"c\")\n\tEqual(t, getError(errs, \"A.d\", \"A.D\").Field(), \"d\")\n\tEqual(t, getError(errs, \"A.E\", \"A.E\").Field(), \"E\")\n\n\tv2 := New()\n\terr = v2.Struct(a)\n\tNotEqual(t, err, nil)\n\n\terrs = err.(ValidationErrors)\n\tEqual(t, len(errs), 4)\n\tEqual(t, getError(errs, \"A.B\", \"A.B\").Field(), \"B\")\n\tEqual(t, getError(errs, \"A.C\", \"A.C\").Field(), \"C\")\n\tEqual(t, getError(errs, \"A.D\", \"A.D\").Field(), \"D\")\n\tEqual(t, getError(errs, \"A.E\", \"A.E\").Field(), \"E\")\n}\n\nfunc TestMultipleRecursiveExtractStructCache(t *testing.T) {\n\tvalidate := New()\n\n\ttype Recursive struct {\n\t\tField *string `validate:\"required,len=5,ne=string\"`\n\t}\n\n\tvar test Recursive\n\n\tcurrent := reflect.ValueOf(test)\n\tname := \"Recursive\"\n\tproceed := make(chan struct{})\n\n\tsc := validate.extractStructCache(current, name)\n\tptr := fmt.Sprintf(\"%p\", sc)\n\n\tfor i := 0; i < 100; i++ {\n\t\tgo func() {\n\t\t\t<-proceed\n\t\t\tsc := validate.extractStructCache(current, name)\n\t\t\tEqual(t, ptr, fmt.Sprintf(\"%p\", sc))\n\t\t}()\n\t}\n\n\tclose(proceed)\n}\n\n// Thanks @robbrockbank, see https://github.com/go-playground/validator/issues/249\nfunc TestPointerAndOmitEmpty(t *testing.T) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tMyInt *int `validate:\"omitempty,gte=2,lte=255\"`\n\t}\n\n\tval1 := 0\n\tval2 := 256\n\n\tt1 := Test{MyInt: &val1} // This should fail validation on gte because value is 0\n\tt2 := Test{MyInt: &val2} // This should fail validate on lte because value is 256\n\tt3 := Test{MyInt: nil}   // This should succeed validation because pointer is nil\n\n\terrs := validate.Struct(t1)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.MyInt\", \"Test.MyInt\", \"MyInt\", \"MyInt\", \"gte\")\n\n\terrs = validate.Struct(t2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"Test.MyInt\", \"Test.MyInt\", \"MyInt\", \"MyInt\", \"lte\")\n\n\terrs = validate.Struct(t3)\n\tEqual(t, errs, nil)\n\n\ttype TestIface struct {\n\t\tMyInt interface{} `validate:\"omitempty,gte=2,lte=255\"`\n\t}\n\n\tti1 := TestIface{MyInt: &val1} // This should fail validation on gte because value is 0\n\tti2 := TestIface{MyInt: &val2} // This should fail validate on lte because value is 256\n\tti3 := TestIface{MyInt: nil}   // This should succeed validation because pointer is nil\n\n\terrs = validate.Struct(ti1)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestIface.MyInt\", \"TestIface.MyInt\", \"MyInt\", \"MyInt\", \"gte\")\n\n\terrs = validate.Struct(ti2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestIface.MyInt\", \"TestIface.MyInt\", \"MyInt\", \"MyInt\", \"lte\")\n\n\terrs = validate.Struct(ti3)\n\tEqual(t, errs, nil)\n}\n\nfunc TestRequired(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype Test struct {\n\t\tValue interface{} `validate:\"required\"`\n\t}\n\n\tvar test Test\n\n\terr := validate.Struct(test)\n\tNotEqual(t, err, nil)\n\tAssertError(t, err.(ValidationErrors), \"Test.Value\", \"Test.Value\", \"Value\", \"Value\", \"required\")\n}\n\nfunc TestBoolEqual(t *testing.T) {\n\tvalidate := New()\n\n\ttype Test struct {\n\t\tValue bool `validate:\"eq=true\"`\n\t}\n\n\tvar test Test\n\n\terr := validate.Struct(test)\n\tNotEqual(t, err, nil)\n\tAssertError(t, err.(ValidationErrors), \"Test.Value\", \"Test.Value\", \"Value\", \"Value\", \"eq\")\n\n\ttest.Value = true\n\terr = validate.Struct(test)\n\tEqual(t, err, nil)\n}\n\nfunc TestTranslations(t *testing.T) {\n\ten := en.New()\n\tuni := ut.New(en, en, fr.New())\n\n\ttrans, _ := uni.GetTranslator(\"en\")\n\tfr, _ := uni.GetTranslator(\"fr\")\n\n\tvalidate := New()\n\terr := validate.RegisterTranslation(\"required\", trans,\n\t\tfunc(ut ut.Translator) (err error) {\n\t\t\t// using this stype because multiple translation may have to be added for the full translation\n\t\t\tif err = ut.Add(\"required\", \"{0} is a required field\", false); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treturn\n\t\t}, func(ut ut.Translator, fe FieldError) string {\n\t\t\tt, err := ut.T(fe.Tag(), fe.Field())\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"warning: error translating FieldError: %#v\", fe.(*fieldError))\n\t\t\t\treturn fe.(*fieldError).Error()\n\t\t\t}\n\n\t\t\treturn t\n\t\t})\n\tEqual(t, err, nil)\n\n\terr = validate.RegisterTranslation(\"required\", fr,\n\t\tfunc(ut ut.Translator) (err error) {\n\t\t\t// using this stype because multiple translation may have to be added for the full translation\n\t\t\tif err = ut.Add(\"required\", \"{0} est un champ obligatoire\", false); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treturn\n\t\t}, func(ut ut.Translator, fe FieldError) string {\n\t\t\tt, transErr := ut.T(fe.Tag(), fe.Field())\n\t\t\tif transErr != nil {\n\t\t\t\tfmt.Printf(\"warning: error translating FieldError: %#v\", fe.(*fieldError))\n\t\t\t\treturn fe.(*fieldError).Error()\n\t\t\t}\n\n\t\t\treturn t\n\t\t})\n\n\tEqual(t, err, nil)\n\n\ttype Test struct {\n\t\tValue interface{} `validate:\"required\"`\n\t}\n\n\tvar test Test\n\n\terr = validate.Struct(test)\n\tNotEqual(t, err, nil)\n\n\terrs := err.(ValidationErrors)\n\tEqual(t, len(errs), 1)\n\n\tfe := errs[0]\n\tEqual(t, fe.Tag(), \"required\")\n\tEqual(t, fe.Namespace(), \"Test.Value\")\n\tEqual(t, fe.Translate(trans), fmt.Sprintf(\"%s is a required field\", fe.Field()))\n\tEqual(t, fe.Translate(fr), fmt.Sprintf(\"%s est un champ obligatoire\", fe.Field()))\n\n\tnl := nl.New()\n\tuni2 := ut.New(nl, nl)\n\ttrans2, _ := uni2.GetTranslator(\"nl\")\n\tEqual(t, fe.Translate(trans2), \"Key: 'Test.Value' Error:Field validation for 'Value' failed on the 'required' tag\")\n\n\tterrs := errs.Translate(trans)\n\tEqual(t, len(terrs), 1)\n\n\tv, ok := terrs[\"Test.Value\"]\n\tEqual(t, ok, true)\n\tEqual(t, v, fmt.Sprintf(\"%s is a required field\", fe.Field()))\n\n\tterrs = errs.Translate(fr)\n\tEqual(t, len(terrs), 1)\n\n\tv, ok = terrs[\"Test.Value\"]\n\tEqual(t, ok, true)\n\tEqual(t, v, fmt.Sprintf(\"%s est un champ obligatoire\", fe.Field()))\n\n\ttype Test2 struct {\n\t\tValue string `validate:\"gt=1\"`\n\t}\n\n\tvar t2 Test2\n\n\terr = validate.Struct(t2)\n\tNotEqual(t, err, nil)\n\n\terrs = err.(ValidationErrors)\n\tEqual(t, len(errs), 1)\n\n\tfe = errs[0]\n\tEqual(t, fe.Tag(), \"gt\")\n\tEqual(t, fe.Namespace(), \"Test2.Value\")\n\tEqual(t, fe.Translate(trans), \"Key: 'Test2.Value' Error:Field validation for 'Value' failed on the 'gt' tag\")\n}\n\nfunc TestTranslationErrors(t *testing.T) {\n\ten := en.New()\n\tuni := ut.New(en, en, fr.New())\n\n\ttrans, _ := uni.GetTranslator(\"en\")\n\terr := trans.Add(\"required\", \"{0} is a required field\", false) // using translator outside of validator also\n\tEqual(t, err, nil)\n\n\tvalidate := New()\n\terr = validate.RegisterTranslation(\"required\", trans,\n\t\tfunc(ut ut.Translator) (err error) {\n\t\t\t// using this stype because multiple translation may have to be added for the full translation\n\t\t\tif err = ut.Add(\"required\", \"{0} is a required field\", false); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\treturn\n\t\t}, func(ut ut.Translator, fe FieldError) string {\n\t\t\tt, err := ut.T(fe.Tag(), fe.Field())\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"warning: error translating FieldError: %#v\", fe.(*fieldError))\n\t\t\t\treturn fe.(*fieldError).Error()\n\t\t\t}\n\n\t\t\treturn t\n\t\t})\n\n\tNotEqual(t, err, nil)\n\tEqual(t, err.Error(), \"error: conflicting key 'required' rule 'Unknown' with text '{0} is a required field' for locale 'en', value being ignored\")\n}\n\nfunc TestStructFiltered(t *testing.T) {\n\tp1 := func(ns []byte) bool {\n\t\tif bytes.HasSuffix(ns, []byte(\"NoTag\")) || bytes.HasSuffix(ns, []byte(\"Required\")) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tp2 := func(ns []byte) bool {\n\t\tif bytes.HasSuffix(ns, []byte(\"SubSlice[0].Test\")) ||\n\t\t\tbytes.HasSuffix(ns, []byte(\"SubSlice[0]\")) ||\n\t\t\tbytes.HasSuffix(ns, []byte(\"SubSlice\")) ||\n\t\t\tbytes.HasSuffix(ns, []byte(\"Sub\")) ||\n\t\t\tbytes.HasSuffix(ns, []byte(\"SubIgnore\")) ||\n\t\t\tbytes.HasSuffix(ns, []byte(\"Anonymous\")) ||\n\t\t\tbytes.HasSuffix(ns, []byte(\"Anonymous.A\")) {\n\t\t\treturn false\n\t\t}\n\n\t\treturn true\n\t}\n\n\tp3 := func(ns []byte) bool {\n\t\treturn !bytes.HasSuffix(ns, []byte(\"SubTest.Test\"))\n\t}\n\n\t// p4 := []string{\n\t// \t\"A\",\n\t// }\n\n\ttPartial := &TestPartial{\n\t\tNoTag:    \"NoTag\",\n\t\tRequired: \"Required\",\n\n\t\tSubSlice: []*SubTest{\n\t\t\t{\n\n\t\t\t\tTest: \"Required\",\n\t\t\t},\n\t\t\t{\n\n\t\t\t\tTest: \"Required\",\n\t\t\t},\n\t\t},\n\n\t\tSub: &SubTest{\n\t\t\tTest: \"1\",\n\t\t},\n\t\tSubIgnore: &SubTest{\n\t\t\tTest: \"\",\n\t\t},\n\t\tAnonymous: struct {\n\t\t\tA             string     `validate:\"required\"`\n\t\t\tASubSlice     []*SubTest `validate:\"required,dive\"`\n\t\t\tSubAnonStruct []struct {\n\t\t\t\tTest      string `validate:\"required\"`\n\t\t\t\tOtherTest string `validate:\"required\"`\n\t\t\t} `validate:\"required,dive\"`\n\t\t}{\n\t\t\tA: \"1\",\n\t\t\tASubSlice: []*SubTest{\n\t\t\t\t{\n\t\t\t\t\tTest: \"Required\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tTest: \"Required\",\n\t\t\t\t},\n\t\t\t},\n\n\t\t\tSubAnonStruct: []struct {\n\t\t\t\tTest      string `validate:\"required\"`\n\t\t\t\tOtherTest string `validate:\"required\"`\n\t\t\t}{\n\t\t\t\t{\"Required\", \"RequiredOther\"},\n\t\t\t\t{\"Required\", \"RequiredOther\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tvalidate := New()\n\n\t// the following should all return no errors as everything is valid in\n\t// the default state\n\terrs := validate.StructFilteredCtx(context.Background(), tPartial, p1)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructFiltered(tPartial, p2)\n\tEqual(t, errs, nil)\n\n\t// this isn't really a robust test, but is meant to illustrate the ANON CASE below\n\terrs = validate.StructFiltered(tPartial.SubSlice[0], p3)\n\tEqual(t, errs, nil)\n\n\t// mod tPartial for required field and re-test making sure invalid fields are NOT required:\n\ttPartial.Required = \"\"\n\n\t// inversion and retesting Partial to generate failures:\n\terrs = validate.StructFiltered(tPartial, p1)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.Required\", \"TestPartial.Required\", \"Required\", \"Required\", \"required\")\n\n\t// reset Required field, and set nested struct\n\ttPartial.Required = \"Required\"\n\ttPartial.Anonymous.A = \"\"\n\n\t// will pass as unset fields is not going to be tested\n\terrs = validate.StructFiltered(tPartial, p1)\n\tEqual(t, errs, nil)\n\n\t// will fail as unset field is tested\n\terrs = validate.StructFiltered(tPartial, p2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.Anonymous.A\", \"TestPartial.Anonymous.A\", \"A\", \"A\", \"required\")\n\n\t// reset nested struct and unset struct in slice\n\ttPartial.Anonymous.A = \"Required\"\n\ttPartial.SubSlice[0].Test = \"\"\n\n\t// these will pass as unset item is NOT tested\n\terrs = validate.StructFiltered(tPartial, p1)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructFiltered(tPartial, p2)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestPartial.SubSlice[0].Test\", \"TestPartial.SubSlice[0].Test\", \"Test\", \"Test\", \"required\")\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\n\t// Unset second slice member concurrently to test dive behavior:\n\ttPartial.SubSlice[1].Test = \"\"\n\n\terrs = validate.StructFiltered(tPartial, p1)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructFiltered(tPartial, p2)\n\tNotEqual(t, errs, nil)\n\tEqual(t, len(errs.(ValidationErrors)), 1)\n\tAssertError(t, errs, \"TestPartial.SubSlice[0].Test\", \"TestPartial.SubSlice[0].Test\", \"Test\", \"Test\", \"required\")\n\n\t// reset struct in slice, and unset struct in slice in unset position\n\ttPartial.SubSlice[0].Test = \"Required\"\n\n\t// these will pass as the unset item is NOT tested\n\terrs = validate.StructFiltered(tPartial, p1)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructFiltered(tPartial, p2)\n\tEqual(t, errs, nil)\n\n\ttPartial.SubSlice[1].Test = \"Required\"\n\ttPartial.Anonymous.SubAnonStruct[0].Test = \"\"\n\n\t// these will pass as the unset item is NOT tested\n\terrs = validate.StructFiltered(tPartial, p1)\n\tEqual(t, errs, nil)\n\n\terrs = validate.StructFiltered(tPartial, p2)\n\tEqual(t, errs, nil)\n\n\tdt := time.Now()\n\terr := validate.StructFiltered(&dt, func(ns []byte) bool { return true })\n\tNotEqual(t, err, nil)\n\tEqual(t, err.Error(), \"validator: (nil *time.Time)\")\n}\n\nfunc TestRequiredPtr(t *testing.T) {\n\ttype Test struct {\n\t\tBool *bool `validate:\"required\"`\n\t}\n\n\tvalidate := New()\n\n\tf := false\n\n\ttest := Test{\n\t\tBool: &f,\n\t}\n\n\terr := validate.Struct(test)\n\tEqual(t, err, nil)\n\n\ttr := true\n\n\ttest.Bool = &tr\n\n\terr = validate.Struct(test)\n\tEqual(t, err, nil)\n\n\ttest.Bool = nil\n\n\terr = validate.Struct(test)\n\tNotEqual(t, err, nil)\n\n\terrs, ok := err.(ValidationErrors)\n\tEqual(t, ok, true)\n\tEqual(t, len(errs), 1)\n\tAssertError(t, errs, \"Test.Bool\", \"Test.Bool\", \"Bool\", \"Bool\", \"required\")\n\n\ttype Test2 struct {\n\t\tBool bool `validate:\"required\"`\n\t}\n\n\tvar test2 Test2\n\n\terr = validate.Struct(test2)\n\tNotEqual(t, err, nil)\n\n\terrs, ok = err.(ValidationErrors)\n\tEqual(t, ok, true)\n\tEqual(t, len(errs), 1)\n\tAssertError(t, errs, \"Test2.Bool\", \"Test2.Bool\", \"Bool\", \"Bool\", \"required\")\n\n\ttest2.Bool = true\n\n\terr = validate.Struct(test2)\n\tEqual(t, err, nil)\n\n\ttype Test3 struct {\n\t\tArr []string `validate:\"required\"`\n\t}\n\n\tvar test3 Test3\n\n\terr = validate.Struct(test3)\n\tNotEqual(t, err, nil)\n\n\terrs, ok = err.(ValidationErrors)\n\tEqual(t, ok, true)\n\tEqual(t, len(errs), 1)\n\tAssertError(t, errs, \"Test3.Arr\", \"Test3.Arr\", \"Arr\", \"Arr\", \"required\")\n\n\ttest3.Arr = make([]string, 0)\n\n\terr = validate.Struct(test3)\n\tEqual(t, err, nil)\n\n\ttype Test4 struct {\n\t\tArr *[]string `validate:\"required\"` // I know I know pointer to array, just making sure validation works as expected...\n\t}\n\n\tvar test4 Test4\n\n\terr = validate.Struct(test4)\n\tNotEqual(t, err, nil)\n\n\terrs, ok = err.(ValidationErrors)\n\tEqual(t, ok, true)\n\tEqual(t, len(errs), 1)\n\tAssertError(t, errs, \"Test4.Arr\", \"Test4.Arr\", \"Arr\", \"Arr\", \"required\")\n\n\tarr := make([]string, 0)\n\ttest4.Arr = &arr\n\n\terr = validate.Struct(test4)\n\tEqual(t, err, nil)\n}\n\nfunc TestAlphaUnicodeValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"abc\", true},\n\t\t{\"this is a test string\", false},\n\t\t{\"这是一个测试字符串\", true},\n\t\t{\"123\", false},\n\t\t{\"<>@;.-=\", false},\n\t\t{\"ひらがな・カタカナ、．漢字\", false},\n\t\t{\"あいうえおfoobar\", true},\n\t\t{\"test＠example.com\", false},\n\t\t{\"1234abcDE\", false},\n\t\t{\"ｶﾀｶﾅ\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"alphaunicode\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Alpha Unicode failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Alpha Unicode failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"alphaunicode\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Alpha Unicode failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestAlphanumericUnicodeValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"\", false},\n\t\t{\"abc\", true},\n\t\t{\"this is a test string\", false},\n\t\t{\"这是一个测试字符串\", true},\n\t\t{\"\\u0031\\u0032\\u0033\", true}, // unicode 5\n\t\t{\"123\", true},\n\t\t{\"<>@;.-=\", false},\n\t\t{\"ひらがな・カタカナ、．漢字\", false},\n\t\t{\"あいうえおfoobar\", true},\n\t\t{\"test＠example.com\", false},\n\t\t{\"1234abcDE\", true},\n\t\t{\"ｶﾀｶﾅ\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"alphanumunicode\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Alphanum Unicode failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d Alphanum Unicode failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"alphanumunicode\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d Alphanum Unicode failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestArrayStructNamespace(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype child struct {\n\t\tName string `json:\"name\" validate:\"required\"`\n\t}\n\tvar input struct {\n\t\tChildren []child `json:\"children\" validate:\"required,gt=0,dive\"`\n\t}\n\tinput.Children = []child{{\"ok\"}, {\"\"}}\n\n\terrs := validate.Struct(input)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"children[1].name\", \"Children[1].Name\", \"name\", \"Name\", \"required\")\n}\n\nfunc TestMapStructNamespace(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype child struct {\n\t\tName string `json:\"name\" validate:\"required\"`\n\t}\n\tvar input struct {\n\t\tChildren map[int]child `json:\"children\" validate:\"required,gt=0,dive\"`\n\t}\n\tinput.Children = map[int]child{\n\t\t0: {Name: \"ok\"},\n\t\t1: {Name: \"\"},\n\t}\n\n\terrs := validate.Struct(input)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"children[1].name\", \"Children[1].Name\", \"name\", \"Name\", \"required\")\n}\n\nfunc TestFieldLevelName(t *testing.T) {\n\ttype Test struct {\n\t\tString string            `validate:\"custom1\"      json:\"json1\"`\n\t\tArray  []string          `validate:\"dive,custom2\" json:\"json2\"`\n\t\tMap    map[string]string `validate:\"dive,custom3\" json:\"json3\"`\n\t\tArray2 []string          `validate:\"custom4\"      json:\"json4\"`\n\t\tMap2   map[string]string `validate:\"custom5\"      json:\"json5\"`\n\t}\n\n\tvar res1, res2, res3, res4, res5, alt1, alt2, alt3, alt4, alt5 string\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\terr := validate.RegisterValidation(\"custom1\", func(fl FieldLevel) bool {\n\t\tres1 = fl.FieldName()\n\t\talt1 = fl.StructFieldName()\n\t\treturn true\n\t})\n\tEqual(t, err, nil)\n\n\terr = validate.RegisterValidation(\"custom2\", func(fl FieldLevel) bool {\n\t\tres2 = fl.FieldName()\n\t\talt2 = fl.StructFieldName()\n\t\treturn true\n\t})\n\tEqual(t, err, nil)\n\n\terr = validate.RegisterValidation(\"custom3\", func(fl FieldLevel) bool {\n\t\tres3 = fl.FieldName()\n\t\talt3 = fl.StructFieldName()\n\t\treturn true\n\t})\n\tEqual(t, err, nil)\n\n\terr = validate.RegisterValidation(\"custom4\", func(fl FieldLevel) bool {\n\t\tres4 = fl.FieldName()\n\t\talt4 = fl.StructFieldName()\n\t\treturn true\n\t})\n\tEqual(t, err, nil)\n\n\terr = validate.RegisterValidation(\"custom5\", func(fl FieldLevel) bool {\n\t\tres5 = fl.FieldName()\n\t\talt5 = fl.StructFieldName()\n\t\treturn true\n\t})\n\tEqual(t, err, nil)\n\n\ttest := Test{\n\t\tString: \"test\",\n\t\tArray:  []string{\"1\"},\n\t\tMap:    map[string]string{\"test\": \"test\"},\n\t}\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\tEqual(t, res1, \"json1\")\n\tEqual(t, alt1, \"String\")\n\tEqual(t, res2, \"json2[0]\")\n\tEqual(t, alt2, \"Array[0]\")\n\tEqual(t, res3, \"json3[test]\")\n\tEqual(t, alt3, \"Map[test]\")\n\tEqual(t, res4, \"json4\")\n\tEqual(t, alt4, \"Array2\")\n\tEqual(t, res5, \"json5\")\n\tEqual(t, alt5, \"Map2\")\n}\n\nfunc TestValidateStructRegisterCtx(t *testing.T) {\n\tvar ctxVal string\n\n\tfnCtx := func(ctx context.Context, fl FieldLevel) bool {\n\t\tctxVal = ctx.Value(&ctxVal).(string)\n\t\treturn true\n\t}\n\n\tvar ctxSlVal string\n\tslFn := func(ctx context.Context, sl StructLevel) {\n\t\tctxSlVal = ctx.Value(&ctxSlVal).(string)\n\t}\n\n\ttype Test struct {\n\t\tField string `validate:\"val\"`\n\t}\n\n\tvar tst Test\n\n\tvalidate := New()\n\terr := validate.RegisterValidationCtx(\"val\", fnCtx)\n\tEqual(t, err, nil)\n\n\tvalidate.RegisterStructValidationCtx(slFn, Test{})\n\n\tctx := context.WithValue(context.Background(), &ctxVal, \"testval\")\n\tctx = context.WithValue(ctx, &ctxSlVal, \"slVal\")\n\terrs := validate.StructCtx(ctx, tst)\n\tEqual(t, errs, nil)\n\tEqual(t, ctxVal, \"testval\")\n\tEqual(t, ctxSlVal, \"slVal\")\n}\n\nfunc TestHostnameRFC952Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"test.example.com\", true},\n\t\t{\"example.com\", true},\n\t\t{\"example24.com\", true},\n\t\t{\"test.example24.com\", true},\n\t\t{\"test24.example24.com\", true},\n\t\t{\"example\", true},\n\t\t{\"EXAMPLE\", true},\n\t\t{\"1.foo.com\", false},\n\t\t{\"test.example.com.\", false},\n\t\t{\"example.com.\", false},\n\t\t{\"example24.com.\", false},\n\t\t{\"test.example24.com.\", false},\n\t\t{\"test24.example24.com.\", false},\n\t\t{\"example.\", false},\n\t\t{\"192.168.0.1\", false},\n\t\t{\"email@example.com\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652\", false},\n\t\t{\"2001:cdba::3257:9652\", false},\n\t\t{\"example..........com\", false},\n\t\t{\"1234\", false},\n\t\t{\"abc1234\", true},\n\t\t{\"example. com\", false},\n\t\t{\"ex ample.com\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"hostname\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d hostname failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d hostname failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"hostname\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d hostname failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestHostnameRFC1123Validation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"test.example.com\", true},\n\t\t{\"example.com\", true},\n\t\t{\"example24.com\", true},\n\t\t{\"test.example24.com\", true},\n\t\t{\"test24.example24.com\", true},\n\t\t{\"example\", true},\n\t\t{\"1.foo.com\", true},\n\t\t{\"test.example.com.\", false},\n\t\t{\"example.com.\", false},\n\t\t{\"example24.com.\", false},\n\t\t{\"test.example24.com.\", false},\n\t\t{\"test24.example24.com.\", false},\n\t\t{\"example.\", false},\n\t\t{\"test_example\", false},\n\t\t{\"192.168.0.1\", true},\n\t\t{\"email@example.com\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652\", false},\n\t\t{\"2001:cdba::3257:9652\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"hostname_rfc1123\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Hostname: %v failed Error: %v\", test, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Hostname: %v failed Error: %v\", test, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"hostname_rfc1123\" {\n\t\t\t\t\tt.Fatalf(\"Hostname: %v failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestHostnameRFC1123AliasValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"test.example.com\", true},\n\t\t{\"example.com\", true},\n\t\t{\"example24.com\", true},\n\t\t{\"test.example24.com\", true},\n\t\t{\"test24.example24.com\", true},\n\t\t{\"example\", true},\n\t\t{\"1.foo.com\", true},\n\t\t{\"test.example.com.\", false},\n\t\t{\"example.com.\", false},\n\t\t{\"example24.com.\", false},\n\t\t{\"test.example24.com.\", false},\n\t\t{\"test24.example24.com.\", false},\n\t\t{\"example.\", false},\n\t\t{\"test_example\", false},\n\t\t{\"192.168.0.1\", true},\n\t\t{\"email@example.com\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652\", false},\n\t\t{\"2001:cdba::3257:9652\", false},\n\t}\n\n\tvalidate := New()\n\tvalidate.RegisterAlias(\"hostname\", \"hostname_rfc1123\")\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"hostname\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d hostname failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d hostname failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"hostname\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d hostname failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestFQDNValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"test.example.com\", true},\n\t\t{\"example.com\", true},\n\t\t{\"example24.com\", true},\n\t\t{\"test.example24.com\", true},\n\t\t{\"test24.example24.com\", true},\n\t\t{\"test.example.com.\", true},\n\t\t{\"example.com.\", true},\n\t\t{\"example24.com.\", true},\n\t\t{\"test.example24.com.\", true},\n\t\t{\"test24.example24.com.\", true},\n\t\t{\"24.example24.com\", true},\n\t\t{\"test.24.example.com\", true},\n\t\t{\"test24.example24.com..\", false},\n\t\t{\"example\", false},\n\t\t{\"192.168.0.1\", false},\n\t\t{\"email@example.com\", false},\n\t\t{\"2001:cdba:0000:0000:0000:0000:3257:9652\", false},\n\t\t{\"2001:cdba:0:0:0:0:3257:9652\", false},\n\t\t{\"2001:cdba::3257:9652\", false},\n\t\t{\"\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"fqdn\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d fqdn failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d fqdn failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"fqdn\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d fqdn failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsDefault(t *testing.T) {\n\tvalidate := New()\n\n\ttype Inner struct {\n\t\tString string `validate:\"isdefault\"`\n\t}\n\ttype Test struct {\n\t\tString string `validate:\"isdefault\"`\n\t\tInner  *Inner `validate:\"isdefault\"`\n\t}\n\n\tvar tt Test\n\n\terrs := validate.Struct(tt)\n\tEqual(t, errs, nil)\n\n\ttt.Inner = &Inner{String: \"\"}\n\terrs = validate.Struct(tt)\n\tNotEqual(t, errs, nil)\n\n\tfe := errs.(ValidationErrors)[0]\n\tEqual(t, fe.Field(), \"Inner\")\n\tEqual(t, fe.Namespace(), \"Test.Inner\")\n\tEqual(t, fe.Tag(), \"isdefault\")\n\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn name\n\t})\n\n\ttype Inner2 struct {\n\t\tString string `validate:\"isdefault\"`\n\t}\n\n\ttype Test2 struct {\n\t\tInner Inner2 `validate:\"isdefault\" json:\"inner\"`\n\t}\n\n\tvar t2 Test2\n\terrs = validate.Struct(t2)\n\tEqual(t, errs, nil)\n\n\tt2.Inner.String = \"Changed\"\n\terrs = validate.Struct(t2)\n\tNotEqual(t, errs, nil)\n\n\tfe = errs.(ValidationErrors)[0]\n\tEqual(t, fe.Field(), \"inner\")\n\tEqual(t, fe.Namespace(), \"Test2.inner\")\n\tEqual(t, fe.Tag(), \"isdefault\")\n}\n\nfunc TestUniqueValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t// Arrays\n\t\t{[2]string{\"a\", \"b\"}, true},\n\t\t{[2]int{1, 2}, true},\n\t\t{[2]float64{1, 2}, true},\n\t\t{[2]interface{}{\"a\", \"b\"}, true},\n\t\t{[2]interface{}{\"a\", 1}, true},\n\t\t{[2]float64{1, 1}, false},\n\t\t{[2]int{1, 1}, false},\n\t\t{[2]string{\"a\", \"a\"}, false},\n\t\t{[2]interface{}{\"a\", \"a\"}, false},\n\t\t{[4]interface{}{\"a\", 1, \"b\", 1}, false},\n\t\t{[2]*string{stringPtr(\"a\"), stringPtr(\"b\")}, true},\n\t\t{[2]*int{intPtr(1), intPtr(2)}, true},\n\t\t{[2]*float64{float64Ptr(1), float64Ptr(2)}, true},\n\t\t{[2]*string{stringPtr(\"a\"), stringPtr(\"a\")}, false},\n\t\t{[2]*float64{float64Ptr(1), float64Ptr(1)}, false},\n\t\t{[2]*int{intPtr(1), intPtr(1)}, false},\n\t\t// Slices\n\t\t{[]string{\"a\", \"b\"}, true},\n\t\t{[]int{1, 2}, true},\n\t\t{[]float64{1, 2}, true},\n\t\t{[]interface{}{\"a\", \"b\"}, true},\n\t\t{[]interface{}{\"a\", 1}, true},\n\t\t{[]float64{1, 1}, false},\n\t\t{[]int{1, 1}, false},\n\t\t{[]string{\"a\", \"a\"}, false},\n\t\t{[]interface{}{\"a\", \"a\"}, false},\n\t\t{[]interface{}{\"a\", 1, \"b\", 1}, false},\n\t\t{[]*string{stringPtr(\"a\"), stringPtr(\"b\")}, true},\n\t\t{[]*int{intPtr(1), intPtr(2)}, true},\n\t\t{[]*float64{float64Ptr(1), float64Ptr(2)}, true},\n\t\t{[]*string{stringPtr(\"a\"), stringPtr(\"a\")}, false},\n\t\t{[]*float64{float64Ptr(1), float64Ptr(1)}, false},\n\t\t{[]*int{intPtr(1), intPtr(1)}, false},\n\t\t// Maps\n\t\t{map[string]string{\"one\": \"a\", \"two\": \"b\"}, true},\n\t\t{map[string]int{\"one\": 1, \"two\": 2}, true},\n\t\t{map[string]float64{\"one\": 1, \"two\": 2}, true},\n\t\t{map[string]interface{}{\"one\": \"a\", \"two\": \"b\"}, true},\n\t\t{map[string]interface{}{\"one\": \"a\", \"two\": 1}, true},\n\t\t{map[string]float64{\"one\": 1, \"two\": 1}, false},\n\t\t{map[string]int{\"one\": 1, \"two\": 1}, false},\n\t\t{map[string]string{\"one\": \"a\", \"two\": \"a\"}, false},\n\t\t{map[string]interface{}{\"one\": \"a\", \"two\": \"a\"}, false},\n\t\t{map[string]interface{}{\"one\": \"a\", \"two\": 1, \"three\": \"b\", \"four\": 1}, false},\n\t\t{map[string]*string{\"one\": stringPtr(\"a\"), \"two\": stringPtr(\"a\")}, false},\n\t\t{map[string]*string{\"one\": stringPtr(\"a\"), \"two\": stringPtr(\"b\")}, true},\n\t\t{map[string]*int{\"one\": intPtr(1), \"two\": intPtr(1)}, false},\n\t\t{map[string]*int{\"one\": intPtr(1), \"two\": intPtr(2)}, true},\n\t\t{map[string]*float64{\"one\": float64Ptr(1.1), \"two\": float64Ptr(1.1)}, false},\n\t\t{map[string]*float64{\"one\": float64Ptr(1.1), \"two\": float64Ptr(1.2)}, true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"unique\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"unique\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPanicMatches(t, func() { _ = validate.Var(1.0, \"unique\") }, \"Bad field type float64\")\n\n\tt.Run(\"struct\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tparam    interface{}\n\t\t\texpected bool\n\t\t}{\n\t\t\t{struct {\n\t\t\t\tA string `validate:\"unique=B\"`\n\t\t\t\tB string\n\t\t\t}{A: \"abc\", B: \"bcd\"}, true},\n\t\t\t{struct {\n\t\t\t\tA string `validate:\"unique=B\"`\n\t\t\t\tB string\n\t\t\t}{A: \"abc\", B: \"abc\"}, false},\n\t\t}\n\t\tvalidate := New()\n\n\t\tfor i, test := range tests {\n\t\t\terrs := validate.Struct(test.param)\n\t\t\tif test.expected {\n\t\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif IsEqual(errs, nil) {\n\t\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t\t} else {\n\t\t\t\t\tval := getError(errs, \"A\", \"A\")\n\t\t\t\t\tif val.Tag() != \"unique\" {\n\t\t\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestUniqueValidationStructSlice(t *testing.T) {\n\ttestStructs := []struct {\n\t\tA string\n\t\tB string\n\t}{\n\t\t{A: \"one\", B: \"two\"},\n\t\t{A: \"one\", B: \"three\"},\n\t}\n\n\ttests := []struct {\n\t\ttarget   interface{}\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{testStructs, \"unique\", true},\n\t\t{testStructs, \"unique=A\", false},\n\t\t{testStructs, \"unique=B\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.target, test.param)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"unique\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPanicMatches(t, func() { _ = validate.Var(testStructs, \"unique=C\") }, \"Bad field name C\")\n}\n\nfunc TestUniqueValidationStructPtrSlice(t *testing.T) {\n\ttestStructs := []*struct {\n\t\tA *string\n\t\tB *string\n\t}{\n\t\t{A: stringPtr(\"one\"), B: stringPtr(\"two\")},\n\t\t{A: stringPtr(\"one\"), B: stringPtr(\"three\")},\n\t\t{},\n\t}\n\n\ttests := []struct {\n\t\ttarget   interface{}\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{testStructs, \"unique\", true},\n\t\t{testStructs, \"unique=A\", false},\n\t\t{testStructs, \"unique=B\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.target, test.param)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"unique\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d unique failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tPanicMatches(t, func() { _ = validate.Var(testStructs, \"unique=C\") }, \"Bad field name C\")\n}\n\nfunc TestHTMLValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"<html>\", true},\n\t\t{\"<script>\", true},\n\t\t{\"<stillworks>\", true},\n\t\t{\"</html\", false},\n\t\t{\"</script>\", true},\n\t\t{\"<//script>\", false},\n\t\t{\"<123nonsense>\", false},\n\t\t{\"test\", false},\n\t\t{\"&example\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"html\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d html failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d html failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"html\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d html failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestHTMLEncodedValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"&#x3c;\", true},\n\t\t{\"&#xaf;\", true},\n\t\t{\"&#x00;\", true},\n\t\t{\"&#xf0;\", true},\n\t\t{\"&#x3c\", true},\n\t\t{\"&#xaf\", true},\n\t\t{\"&#x00\", true},\n\t\t{\"&#xf0\", true},\n\t\t{\"&#ab\", true},\n\t\t{\"&lt;\", true},\n\t\t{\"&gt;\", true},\n\t\t{\"&quot;\", true},\n\t\t{\"&amp;\", true},\n\t\t{\"#x0a\", false},\n\t\t{\"&x00\", false},\n\t\t{\"&#x1z\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"html_encoded\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d html_encoded failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d html_encoded failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"html_encoded\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d html_encoded failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestURLEncodedValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"%20\", true},\n\t\t{\"%af\", true},\n\t\t{\"%ff\", true},\n\t\t{\"<%az\", false},\n\t\t{\"%test%\", false},\n\t\t{\"a%b\", false},\n\t\t{\"1%2\", false},\n\t\t{\"%%a%%\", false},\n\t\t{\"hello\", true},\n\t\t{\"\", true},\n\t\t{\"+\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"url_encoded\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d url_encoded failed Error: %v\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d url_encoded failed Error: %v\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"url_encoded\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d url_encoded failed Error: %v\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestKeys(t *testing.T) {\n\ttype Test struct {\n\t\tTest1 map[string]string `validate:\"gt=0,dive,keys,eq=testkey,endkeys,eq=testval\" json:\"test1\"`\n\t\tTest2 map[int]int       `validate:\"gt=0,dive,keys,eq=3,endkeys,eq=4\"             json:\"test2\"`\n\t\tTest3 map[int]int       `validate:\"gt=0,dive,keys,eq=3,endkeys\"                  json:\"test3\"`\n\t}\n\n\tvar tst Test\n\n\tvalidate := New()\n\terr := validate.Struct(tst)\n\tNotEqual(t, err, nil)\n\tEqual(t, len(err.(ValidationErrors)), 3)\n\tAssertError(t, err.(ValidationErrors), \"Test.Test1\", \"Test.Test1\", \"Test1\", \"Test1\", \"gt\")\n\tAssertError(t, err.(ValidationErrors), \"Test.Test2\", \"Test.Test2\", \"Test2\", \"Test2\", \"gt\")\n\tAssertError(t, err.(ValidationErrors), \"Test.Test3\", \"Test.Test3\", \"Test3\", \"Test3\", \"gt\")\n\n\ttst.Test1 = map[string]string{\n\t\t\"testkey\": \"testval\",\n\t}\n\n\ttst.Test2 = map[int]int{\n\t\t3: 4,\n\t}\n\n\ttst.Test3 = map[int]int{\n\t\t3: 4,\n\t}\n\n\terr = validate.Struct(tst)\n\tEqual(t, err, nil)\n\n\ttst.Test1[\"badtestkey\"] = \"badtestvalue\"\n\ttst.Test2[10] = 11\n\n\terr = validate.Struct(tst)\n\tNotEqual(t, err, nil)\n\n\terrs := err.(ValidationErrors)\n\n\tEqual(t, len(errs), 4)\n\n\tAssertDeepError(t, errs, \"Test.Test1[badtestkey]\", \"Test.Test1[badtestkey]\", \"Test1[badtestkey]\", \"Test1[badtestkey]\", \"eq\", \"eq\")\n\tAssertDeepError(t, errs, \"Test.Test1[badtestkey]\", \"Test.Test1[badtestkey]\", \"Test1[badtestkey]\", \"Test1[badtestkey]\", \"eq\", \"eq\")\n\tAssertDeepError(t, errs, \"Test.Test2[10]\", \"Test.Test2[10]\", \"Test2[10]\", \"Test2[10]\", \"eq\", \"eq\")\n\tAssertDeepError(t, errs, \"Test.Test2[10]\", \"Test.Test2[10]\", \"Test2[10]\", \"Test2[10]\", \"eq\", \"eq\")\n\n\ttype Test2 struct {\n\t\tNestedKeys map[[1]string]string `validate:\"gt=0,dive,keys,dive,eq=innertestkey,endkeys,eq=outertestval\"`\n\t}\n\n\tvar tst2 Test2\n\n\terr = validate.Struct(tst2)\n\tNotEqual(t, err, nil)\n\tEqual(t, len(err.(ValidationErrors)), 1)\n\tAssertError(t, err.(ValidationErrors), \"Test2.NestedKeys\", \"Test2.NestedKeys\", \"NestedKeys\", \"NestedKeys\", \"gt\")\n\n\ttst2.NestedKeys = map[[1]string]string{\n\t\t{\"innertestkey\"}: \"outertestval\",\n\t}\n\n\terr = validate.Struct(tst2)\n\tEqual(t, err, nil)\n\n\ttst2.NestedKeys[[1]string{\"badtestkey\"}] = \"badtestvalue\"\n\n\terr = validate.Struct(tst2)\n\tNotEqual(t, err, nil)\n\n\terrs = err.(ValidationErrors)\n\n\tEqual(t, len(errs), 2)\n\tAssertDeepError(t, errs, \"Test2.NestedKeys[[badtestkey]][0]\", \"Test2.NestedKeys[[badtestkey]][0]\", \"NestedKeys[[badtestkey]][0]\", \"NestedKeys[[badtestkey]][0]\", \"eq\", \"eq\")\n\tAssertDeepError(t, errs, \"Test2.NestedKeys[[badtestkey]]\", \"Test2.NestedKeys[[badtestkey]]\", \"NestedKeys[[badtestkey]]\", \"NestedKeys[[badtestkey]]\", \"eq\", \"eq\")\n\n\t// test bad tag definitions\n\n\tPanicMatches(t, func() { _ = validate.Var(map[string]string{\"key\": \"val\"}, \"endkeys,dive,eq=val\") }, \"'endkeys' tag encountered without a corresponding 'keys' tag\")\n\tPanicMatches(t, func() { _ = validate.Var(1, \"keys,eq=1,endkeys\") }, \"'keys' tag must be immediately preceded by the 'dive' tag\")\n\n\t// test custom tag name\n\tvalidate = New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn name\n\t})\n\n\terr = validate.Struct(tst)\n\tNotEqual(t, err, nil)\n\n\terrs = err.(ValidationErrors)\n\n\tEqual(t, len(errs), 4)\n\n\tAssertDeepError(t, errs, \"Test.test1[badtestkey]\", \"Test.Test1[badtestkey]\", \"test1[badtestkey]\", \"Test1[badtestkey]\", \"eq\", \"eq\")\n\tAssertDeepError(t, errs, \"Test.test1[badtestkey]\", \"Test.Test1[badtestkey]\", \"test1[badtestkey]\", \"Test1[badtestkey]\", \"eq\", \"eq\")\n\tAssertDeepError(t, errs, \"Test.test2[10]\", \"Test.Test2[10]\", \"test2[10]\", \"Test2[10]\", \"eq\", \"eq\")\n\tAssertDeepError(t, errs, \"Test.test2[10]\", \"Test.Test2[10]\", \"test2[10]\", \"Test2[10]\", \"eq\", \"eq\")\n}\n\n// Thanks @adrian-sgn specific test for your specific scenario\nfunc TestKeysCustomValidation(t *testing.T) {\n\ttype LangCode string\n\ttype Label map[LangCode]string\n\n\ttype TestMapStructPtr struct {\n\t\tLabel Label `validate:\"dive,keys,lang_code,endkeys,required\"`\n\t}\n\n\tvalidate := New()\n\terr := validate.RegisterValidation(\"lang_code\", func(fl FieldLevel) bool {\n\t\tvalidLangCodes := map[LangCode]struct{}{\n\t\t\t\"en\": {},\n\t\t\t\"es\": {},\n\t\t\t\"pt\": {},\n\t\t}\n\n\t\t_, ok := validLangCodes[fl.Field().Interface().(LangCode)]\n\t\treturn ok\n\t})\n\tEqual(t, err, nil)\n\n\tlabel := Label{\n\t\t\"en\":  \"Good morning!\",\n\t\t\"pt\":  \"\",\n\t\t\"es\":  \"¡Buenos días!\",\n\t\t\"xx\":  \"Bad key\",\n\t\t\"xxx\": \"\",\n\t}\n\n\terr = validate.Struct(TestMapStructPtr{label})\n\tNotEqual(t, err, nil)\n\n\terrs := err.(ValidationErrors)\n\tEqual(t, len(errs), 4)\n\n\tAssertDeepError(t, errs, \"TestMapStructPtr.Label[xx]\", \"TestMapStructPtr.Label[xx]\", \"Label[xx]\", \"Label[xx]\", \"lang_code\", \"lang_code\")\n\tAssertDeepError(t, errs, \"TestMapStructPtr.Label[pt]\", \"TestMapStructPtr.Label[pt]\", \"Label[pt]\", \"Label[pt]\", \"required\", \"required\")\n\tAssertDeepError(t, errs, \"TestMapStructPtr.Label[xxx]\", \"TestMapStructPtr.Label[xxx]\", \"Label[xxx]\", \"Label[xxx]\", \"lang_code\", \"lang_code\")\n\tAssertDeepError(t, errs, \"TestMapStructPtr.Label[xxx]\", \"TestMapStructPtr.Label[xxx]\", \"Label[xxx]\", \"Label[xxx]\", \"required\", \"required\")\n\n\t// find specific error\n\n\tvar e FieldError\n\tfor _, e = range errs {\n\t\tif e.Namespace() == \"TestMapStructPtr.Label[xxx]\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tEqual(t, e.Param(), \"\")\n\tEqual(t, e.Value().(LangCode), LangCode(\"xxx\"))\n\n\tfor _, e = range errs {\n\t\tif e.Namespace() == \"TestMapStructPtr.Label[xxx]\" && e.Tag() == \"required\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tEqual(t, e.Param(), \"\")\n\tEqual(t, e.Value().(string), \"\")\n}\n\nfunc TestKeyOrs(t *testing.T) {\n\ttype Test struct {\n\t\tTest1 map[string]string `validate:\"gt=0,dive,keys,eq=testkey|eq=testkeyok,endkeys,eq=testval\" json:\"test1\"`\n\t}\n\n\tvar tst Test\n\n\tvalidate := New()\n\terr := validate.Struct(tst)\n\tNotEqual(t, err, nil)\n\tEqual(t, len(err.(ValidationErrors)), 1)\n\tAssertError(t, err.(ValidationErrors), \"Test.Test1\", \"Test.Test1\", \"Test1\", \"Test1\", \"gt\")\n\n\ttst.Test1 = map[string]string{\n\t\t\"testkey\": \"testval\",\n\t}\n\n\terr = validate.Struct(tst)\n\tEqual(t, err, nil)\n\n\ttst.Test1[\"badtestkey\"] = \"badtestval\"\n\n\terr = validate.Struct(tst)\n\tNotEqual(t, err, nil)\n\n\terrs := err.(ValidationErrors)\n\n\tEqual(t, len(errs), 2)\n\n\tAssertDeepError(t, errs, \"Test.Test1[badtestkey]\", \"Test.Test1[badtestkey]\", \"Test1[badtestkey]\", \"Test1[badtestkey]\", \"eq=testkey|eq=testkeyok\", \"eq=testkey|eq=testkeyok\")\n\tAssertDeepError(t, errs, \"Test.Test1[badtestkey]\", \"Test.Test1[badtestkey]\", \"Test1[badtestkey]\", \"Test1[badtestkey]\", \"eq\", \"eq\")\n\n\tvalidate.RegisterAlias(\"okkey\", \"eq=testkey|eq=testkeyok\")\n\n\ttype Test2 struct {\n\t\tTest1 map[string]string `validate:\"gt=0,dive,keys,okkey,endkeys,eq=testval\" json:\"test1\"`\n\t}\n\n\tvar tst2 Test2\n\n\terr = validate.Struct(tst2)\n\tNotEqual(t, err, nil)\n\tEqual(t, len(err.(ValidationErrors)), 1)\n\tAssertError(t, err.(ValidationErrors), \"Test2.Test1\", \"Test2.Test1\", \"Test1\", \"Test1\", \"gt\")\n\n\ttst2.Test1 = map[string]string{\n\t\t\"testkey\": \"testval\",\n\t}\n\n\terr = validate.Struct(tst2)\n\tEqual(t, err, nil)\n\n\ttst2.Test1[\"badtestkey\"] = \"badtestval\"\n\n\terr = validate.Struct(tst2)\n\tNotEqual(t, err, nil)\n\n\terrs = err.(ValidationErrors)\n\n\tEqual(t, len(errs), 2)\n\n\tAssertDeepError(t, errs, \"Test2.Test1[badtestkey]\", \"Test2.Test1[badtestkey]\", \"Test1[badtestkey]\", \"Test1[badtestkey]\", \"okkey\", \"eq=testkey|eq=testkeyok\")\n\tAssertDeepError(t, errs, \"Test2.Test1[badtestkey]\", \"Test2.Test1[badtestkey]\", \"Test1[badtestkey]\", \"Test1[badtestkey]\", \"eq\", \"eq\")\n}\n\nfunc TestStructLevelValidationsPointerPassing(t *testing.T) {\n\tv1 := New()\n\tv1.RegisterStructValidation(StructValidationTestStruct, &TestStruct{})\n\n\ttst := &TestStruct{\n\t\tString: \"good value\",\n\t}\n\n\terrs := v1.Struct(tst)\n\tNotEqual(t, errs, nil)\n\tAssertError(t, errs, \"TestStruct.StringVal\", \"TestStruct.String\", \"StringVal\", \"String\", \"badvalueteststruct\")\n}\n\nfunc TestDirValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"existing dir\", \"testdata\", true},\n\t\t{\"existing self dir\", \".\", true},\n\t\t{\"existing parent dir\", \"..\", true},\n\t\t{\"empty dir\", \"\", false},\n\t\t{\"missing dir\", \"non_existing_testdata\", false},\n\t\t{\"a file not a directory\", filepath.Join(\"testdata\", \"a.go\"), false},\n\t}\n\n\tfor _, test := range tests {\n\t\terrs := validate.Var(test.param, \"dir\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(2, \"dir\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestDirPathValidation(t *testing.T) {\n\tvalidate := New()\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"empty dirpath\", \"\", false},\n\t\t{\"valid dirpath - exists\", \"testdata\", true},\n\t\t{\"valid dirpath - explicit\", \"testdatanoexist\" + string(os.PathSeparator), true},\n\t\t{\"invalid dirpath\", \"testdata\\000\" + string(os.PathSeparator), false},\n\t\t{\"file, not a dirpath\", filepath.Join(\"testdata\", \"a.go\"), false},\n\t}\n\n\tfor _, test := range tests {\n\t\terrs := validate.Var(test.param, \"dirpath\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Test: '%s' failed Error: %s\", test.title, errs)\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(6, \"filepath\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestStartsWithValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"startswith=(/^ヮ^)/*:・ﾟ✧\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"(/^ヮ^)/*:・ﾟ✧ glitter\", Tag: \"startswith=(/^ヮ^)/*:・ﾟ✧\", ExpectedNil: true},\n\t\t{Value: \"abcd\", Tag: \"startswith=(/^ヮ^)/*:・ﾟ✧\", ExpectedNil: false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n}\n\nfunc TestEndsWithValidation(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"endswith=(/^ヮ^)/*:・ﾟ✧\"`\n\t\tTag         string\n\t\tExpectedNil bool\n\t}{\n\t\t{Value: \"glitter (/^ヮ^)/*:・ﾟ✧\", Tag: \"endswith=(/^ヮ^)/*:・ﾟ✧\", ExpectedNil: true},\n\t\t{Value: \"(/^ヮ^)/*:・ﾟ✧ glitter\", Tag: \"endswith=(/^ヮ^)/*:・ﾟ✧\", ExpectedNil: false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, s := range tests {\n\t\terrs := validate.Var(s.Value, s.Tag)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\n\t\terrs = validate.Struct(s)\n\n\t\tif (s.ExpectedNil && errs != nil) || (!s.ExpectedNil && errs == nil) {\n\t\t\tt.Fatalf(\"Index: %d failed Error: %s\", i, errs)\n\t\t}\n\t}\n}\n\nfunc TestRequiredIf(t *testing.T) {\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner   *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_if=FieldE test\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_if=Field1 test\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_if=Field2 test\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_if=Field3 1\" json:\"field_4\"`\n\t\tField5  int               `validate:\"required_if=Inner.Field test\" json:\"field_5\"`\n\t\tField6  uint              `validate:\"required_if=Field5 1\" json:\"field_6\"`\n\t\tField7  float32           `validate:\"required_if=Field6 1\" json:\"field_7\"`\n\t\tField8  float64           `validate:\"required_if=Field7 1.0\" json:\"field_8\"`\n\t\tField9  Inner             `validate:\"required_if=Field1 test\" json:\"field_9\"`\n\t\tField10 *Inner            `validate:\"required_if=Field1 test\" json:\"field_10\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: 2,\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner   *Inner\n\t\tInner2  *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_if=FieldE test\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_if=Field1 test\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_if=Field2 test\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_if=Field2 test\" json:\"field_4\"`\n\t\tField5  string            `validate:\"required_if=Field3 1\" json:\"field_5\"`\n\t\tField6  string            `validate:\"required_if=Inner.Field test\" json:\"field_6\"`\n\t\tField7  string            `validate:\"required_if=Inner2.Field test\" json:\"field_7\"`\n\t\tField8  Inner             `validate:\"required_if=Field2 test\" json:\"field_8\"`\n\t\tField9  *Inner            `validate:\"required_if=Field2 test\" json:\"field_9\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField2: &fieldVal,\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 5)\n\tAssertError(t, errs, \"Field3\", \"Field3\", \"Field3\", \"Field3\", \"required_if\")\n\tAssertError(t, errs, \"Field4\", \"Field4\", \"Field4\", \"Field4\", \"required_if\")\n\tAssertError(t, errs, \"Field6\", \"Field6\", \"Field6\", \"Field6\", \"required_if\")\n\tAssertError(t, errs, \"Field8\", \"Field8\", \"Field8\", \"Field8\", \"required_if\")\n\tAssertError(t, errs, \"Field9\", \"Field9\", \"Field9\", \"Field9\", \"required_if\")\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"test3 should have panicked!\")\n\t\t}\n\t}()\n\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tField1 string `validate:\"required_if=Inner.Field\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &fieldVal},\n\t}\n\t_ = validate.Struct(test3)\n}\n\nfunc TestRequiredUnless(t *testing.T) {\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner   *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_unless=FieldE test\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_unless=Field1 test\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_unless=Field2 test\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_unless=Field3 1\" json:\"field_4\"`\n\t\tField5  int               `validate:\"required_unless=Inner.Field test\" json:\"field_5\"`\n\t\tField6  uint              `validate:\"required_unless=Field5 2\" json:\"field_6\"`\n\t\tField7  float32           `validate:\"required_unless=Field6 0\" json:\"field_7\"`\n\t\tField8  float64           `validate:\"required_unless=Field7 0.0\" json:\"field_8\"`\n\t\tField9  bool              `validate:\"omitempty\" json:\"field_9\"`\n\t\tField10 string            `validate:\"required_unless=Field9 true\" json:\"field_10\"`\n\t\tField11 Inner             `validate:\"required_unless=Field9 true\" json:\"field_11\"`\n\t\tField12 *Inner            `validate:\"required_unless=Field9 true\" json:\"field_12\"`\n\t}{\n\t\tFieldE: \"test\",\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: 2,\n\t\tField9: true,\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner   *Inner\n\t\tInner2  *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_unless=FieldE test\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_unless=Field1 test\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_unless=Field2 test\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_unless=Field2 test\" json:\"field_4\"`\n\t\tField5  string            `validate:\"required_unless=Field3 0\" json:\"field_5\"`\n\t\tField6  string            `validate:\"required_unless=Inner.Field test\" json:\"field_6\"`\n\t\tField7  string            `validate:\"required_unless=Inner2.Field test\" json:\"field_7\"`\n\t\tField8  bool              `validate:\"omitempty\" json:\"field_8\"`\n\t\tField9  string            `validate:\"required_unless=Field8 true\" json:\"field_9\"`\n\t\tField10 Inner             `validate:\"required_unless=Field9 true\" json:\"field_10\"`\n\t\tField11 *Inner            `validate:\"required_unless=Field9 true\" json:\"field_11\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tFieldE: \"test\",\n\t\tField1: \"test\",\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 6)\n\tAssertError(t, errs, \"Field3\", \"Field3\", \"Field3\", \"Field3\", \"required_unless\")\n\tAssertError(t, errs, \"Field4\", \"Field4\", \"Field4\", \"Field4\", \"required_unless\")\n\tAssertError(t, errs, \"Field7\", \"Field7\", \"Field7\", \"Field7\", \"required_unless\")\n\tAssertError(t, errs, \"Field9\", \"Field9\", \"Field9\", \"Field9\", \"required_unless\")\n\tAssertError(t, errs, \"Field10\", \"Field10\", \"Field10\", \"Field10\", \"required_unless\")\n\tAssertError(t, errs, \"Field11\", \"Field11\", \"Field11\", \"Field11\", \"required_unless\")\n\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"test3 should have panicked!\")\n\t\t}\n\t}()\n\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tField1 string `validate:\"required_unless=Inner.Field\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &fieldVal},\n\t}\n\t_ = validate.Struct(test3)\n}\n\nfunc TestSkipUnless(t *testing.T) {\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tfieldVal := \"test1\"\n\ttest := struct {\n\t\tInner   *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"skip_unless=FieldE test\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"skip_unless=Field1 test\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"skip_unless=Field2 test\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"skip_unless=Field3 1\" json:\"field_4\"`\n\t\tField5  int               `validate:\"skip_unless=Inner.Field test\" json:\"field_5\"`\n\t\tField6  uint              `validate:\"skip_unless=Field5 2\" json:\"field_6\"`\n\t\tField7  float32           `validate:\"skip_unless=Field6 1\" json:\"field_7\"`\n\t\tField8  float64           `validate:\"skip_unless=Field7 1.0\" json:\"field_8\"`\n\t\tField9  bool              `validate:\"omitempty\" json:\"field_9\"`\n\t\tField10 string            `validate:\"skip_unless=Field9 false\" json:\"field_10\"`\n\t\tField11 Inner             `validate:\"skip_unless=Field9 false\" json:\"field_11\"`\n\t\tField12 *Inner            `validate:\"skip_unless=Field9 false\" json:\"field_12\"`\n\t}{\n\t\tFieldE: \"test1\",\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: 3,\n\t\tField9: true,\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner   *Inner\n\t\tInner2  *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"skip_unless=FieldE test\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"skip_unless=Field1 test\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"skip_unless=Field2 test\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"skip_unless=Field2 test\" json:\"field_4\"`\n\t\tField5  string            `validate:\"skip_unless=Field3 0\" json:\"field_5\"`\n\t\tField6  string            `validate:\"skip_unless=Inner.Field test\" json:\"field_6\"`\n\t\tField7  string            `validate:\"skip_unless=Inner2.Field test\" json:\"field_7\"`\n\t\tField8  bool              `validate:\"omitempty\" json:\"field_8\"`\n\t\tField9  string            `validate:\"skip_unless=Field8 true\" json:\"field_9\"`\n\t\tField10 Inner             `validate:\"skip_unless=Field8 false\" json:\"field_10\"`\n\t\tField11 *Inner            `validate:\"skip_unless=Field8 false\" json:\"field_11\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tFieldE: \"test1\",\n\t\tField1: \"test1\",\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 3)\n\tAssertError(t, errs, \"Field5\", \"Field5\", \"Field5\", \"Field5\", \"skip_unless\")\n\tAssertError(t, errs, \"Field10\", \"Field10\", \"Field10\", \"Field10\", \"skip_unless\")\n\tAssertError(t, errs, \"Field11\", \"Field11\", \"Field11\", \"Field11\", \"skip_unless\")\n\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tField1 string `validate:\"skip_unless=Inner.Field\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &fieldVal},\n\t}\n\tPanicMatches(t, func() {\n\t\t_ = validate.Struct(test3)\n\t}, \"Bad param number for skip_unless Field1\")\n\n\ttest4 := struct {\n\t\tInner  *Inner\n\t\tField1 string `validate:\"skip_unless=Inner.Field test1\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &fieldVal},\n\t}\n\terrs = validate.Struct(test4)\n\tNotEqual(t, errs, nil)\n\n\tve = errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"Field1\", \"Field1\", \"Field1\", \"Field1\", \"skip_unless\")\n}\n\nfunc TestRequiredWith(t *testing.T) {\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner   *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_with=FieldE\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_with=Field1\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_with=Field2\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_with=Field3\" json:\"field_4\"`\n\t\tField5  string            `validate:\"required_with=Field\" json:\"field_5\"`\n\t\tField6  Inner             `validate:\"required_with=Field2\" json:\"field_6\"`\n\t\tField7  *Inner            `validate:\"required_with=Field2\" json:\"field_7\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: Inner{Field: &fieldVal},\n\t\tField7: &Inner{Field: &fieldVal},\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner   *Inner\n\t\tInner2  *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_with=FieldE\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_with=Field1\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_with=Field2\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_with=Field2\" json:\"field_4\"`\n\t\tField5  string            `validate:\"required_with=Field3\" json:\"field_5\"`\n\t\tField6  string            `validate:\"required_with=Inner.Field\" json:\"field_6\"`\n\t\tField7  string            `validate:\"required_with=Inner2.Field\" json:\"field_7\"`\n\t\tField8  Inner             `validate:\"required_with=Field2\" json:\"field_8\"`\n\t\tField9  *Inner            `validate:\"required_with=Field2\" json:\"field_9\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField2: &fieldVal,\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 5)\n\tAssertError(t, errs, \"Field3\", \"Field3\", \"Field3\", \"Field3\", \"required_with\")\n\tAssertError(t, errs, \"Field4\", \"Field4\", \"Field4\", \"Field4\", \"required_with\")\n\tAssertError(t, errs, \"Field6\", \"Field6\", \"Field6\", \"Field6\", \"required_with\")\n\tAssertError(t, errs, \"Field8\", \"Field8\", \"Field8\", \"Field8\", \"required_with\")\n\tAssertError(t, errs, \"Field9\", \"Field9\", \"Field9\", \"Field9\", \"required_with\")\n}\n\nfunc TestExcludedWith(t *testing.T) {\n\ttype Inner struct {\n\t\tFieldE string\n\t\tField  *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_with=FieldE\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_with=FieldE\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_with=FieldE\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_with=FieldE\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_with=Inner.FieldE\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_with=Inner2.FieldE\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_with=FieldE\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_with=FieldE\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: \"test\",\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_with=Field\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_with=Field\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_with=Field\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_with=Field\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_with=Inner.Field\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_with=Inner2.Field\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_with=Field\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_with=Field\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField:  \"populated\",\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: \"test\",\n\t\tField7: Inner{FieldE: \"potato\"},\n\t\tField8: &Inner{FieldE: \"potato\"},\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 7)\n\tfor i := 1; i <= 7; i++ {\n\t\t// accounting for field 7 & 8 failures, 6 skipped because no failure\n\t\tif i > 5 {\n\t\t\ti++\n\t\t}\n\t\tname := fmt.Sprintf(\"Field%d\", i)\n\t\tAssertError(t, errs, name, name, name, name, \"excluded_with\")\n\t}\n\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_with=FieldE\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_with=FieldE\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_with=FieldE\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_with=FieldE\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_with=Inner.FieldE\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_with=Inner2.FieldE\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_with=FieldE\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_with=FieldE\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{FieldE: \"populated\"},\n\t\tInner2: &Inner{FieldE: \"populated\"},\n\t\tFieldE: \"populated\",\n\t}\n\n\tvalidate = New()\n\n\terrs = validate.Struct(test3)\n\tEqual(t, errs, nil)\n}\n\nfunc TestExcludedWithout(t *testing.T) {\n\ttype Inner struct {\n\t\tFieldE string\n\t\tField  *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_without=Field\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_without=Field\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_without=Field\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_without=Field\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_without=Inner.Field\" json:\"field_5\"`\n\t\tField6 Inner             `validate:\"excluded_without=Field\" json:\"field_6\"`\n\t\tField7 *Inner            `validate:\"excluded_without=Field\" json:\"field_7\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField:  \"populated\",\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: Inner{FieldE: \"potato\"},\n\t\tField7: &Inner{FieldE: \"potato\"},\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_without=FieldE\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_without=FieldE\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_without=FieldE\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_without=FieldE\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_without=Inner.FieldE\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_without=Inner2.FieldE\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_without=FieldE\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_without=FieldE\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: \"test\",\n\t\tField7: Inner{FieldE: \"potato\"},\n\t\tField8: &Inner{FieldE: \"potato\"},\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 8)\n\tfor i := 1; i <= 8; i++ {\n\t\tname := fmt.Sprintf(\"Field%d\", i)\n\t\tAssertError(t, errs, name, name, name, name, \"excluded_without\")\n\t}\n\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_without=Field\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_without=Field\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_without=Field\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_without=Field\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_without=Inner.Field\" json:\"field_5\"`\n\t\tField6 Inner             `validate:\"excluded_without=Field\" json:\"field_6\"`\n\t\tField7 *Inner            `validate:\"excluded_without=Field\" json:\"field_7\"`\n\t}{\n\t\tInner: &Inner{Field: &fieldVal},\n\t\tField: \"populated\",\n\t}\n\n\tvalidate = New()\n\n\terrs = validate.Struct(test3)\n\tEqual(t, errs, nil)\n}\n\nfunc TestExcludedWithAll(t *testing.T) {\n\ttype Inner struct {\n\t\tFieldE string\n\t\tField  *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_with_all=FieldE Field\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_with_all=FieldE Field\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_with_all=FieldE Field\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_with_all=FieldE Field\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_with_all=Inner.FieldE\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_with_all=Inner2.FieldE\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_with_all=FieldE Field\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_with_all=FieldE Field\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField:  fieldVal,\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: \"test\",\n\t\tField7: Inner{FieldE: \"potato\"},\n\t\tField8: &Inner{FieldE: \"potato\"},\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_with_all=Field FieldE\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_with_all=Field FieldE\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_with_all=Field FieldE\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_with_all=Field FieldE\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_with_all=Inner.Field\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_with_all=Inner2.Field\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_with_all=Field FieldE\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_with_all=Field FieldE\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField:  \"populated\",\n\t\tFieldE: \"populated\",\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: \"test\",\n\t\tField7: Inner{FieldE: \"potato\"},\n\t\tField8: &Inner{FieldE: \"potato\"},\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 7)\n\tfor i := 1; i <= 7; i++ {\n\t\t// accounting for no err for field 6\n\t\tif i > 5 {\n\t\t\ti++\n\t\t}\n\t\tname := fmt.Sprintf(\"Field%d\", i)\n\t\tAssertError(t, errs, name, name, name, name, \"excluded_with_all\")\n\t}\n\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_with_all=FieldE Field\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_with_all=FieldE Field\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_with_all=FieldE Field\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_with_all=FieldE Field\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_with_all=Inner.FieldE\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_with_all=Inner2.FieldE\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_with_all=Field FieldE\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_with_all=Field FieldE\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{FieldE: \"populated\"},\n\t\tInner2: &Inner{FieldE: \"populated\"},\n\t\tField:  \"populated\",\n\t\tFieldE: \"populated\",\n\t}\n\n\tvalidate = New()\n\n\terrs = validate.Struct(test3)\n\tEqual(t, errs, nil)\n}\n\nfunc TestExcludedWithoutAll(t *testing.T) {\n\ttype Inner struct {\n\t\tFieldE string\n\t\tField  *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_without_all=Field FieldE\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_without_all=Field FieldE\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_without_all=Field FieldE\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_without_all=Field FieldE\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_without_all=Inner.Field Inner2.Field\" json:\"field_5\"`\n\t\tField6 Inner             `validate:\"excluded_without_all=Field FieldE\" json:\"field_6\"`\n\t\tField7 *Inner            `validate:\"excluded_without_all=Field FieldE\" json:\"field_7\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tInner2: &Inner{Field: &fieldVal},\n\t\tField:  \"populated\",\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: Inner{FieldE: \"potato\"},\n\t\tField7: &Inner{FieldE: \"potato\"},\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_without_all=FieldE Field\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_without_all=FieldE Field\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_without_all=FieldE Field\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_without_all=FieldE Field\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_without_all=Inner.FieldE\" json:\"field_5\"`\n\t\tField6 string            `validate:\"excluded_without_all=Inner2.FieldE\" json:\"field_6\"`\n\t\tField7 Inner             `validate:\"excluded_without_all=Field FieldE\" json:\"field_7\"`\n\t\tField8 *Inner            `validate:\"excluded_without_all=Field FieldE\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField1: fieldVal,\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: \"test\",\n\t\tField7: Inner{FieldE: \"potato\"},\n\t\tField8: &Inner{FieldE: \"potato\"},\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 8)\n\tfor i := 1; i <= 8; i++ {\n\t\tname := fmt.Sprintf(\"Field%d\", i)\n\t\tAssertError(t, errs, name, name, name, name, \"excluded_without_all\")\n\t}\n\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tInner2 *Inner\n\t\tField  string            `validate:\"omitempty\" json:\"field\"`\n\t\tFieldE string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string            `validate:\"excluded_without_all=Field FieldE\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"excluded_without_all=Field FieldE\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"excluded_without_all=Field FieldE\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"excluded_without_all=Field FieldE\" json:\"field_4\"`\n\t\tField5 string            `validate:\"excluded_without_all=Inner.Field Inner2.Field\" json:\"field_5\"`\n\t\tField6 Inner             `validate:\"excluded_without_all=Field FieldE\" json:\"field_6\"`\n\t\tField7 *Inner            `validate:\"excluded_without_all=Field FieldE\" json:\"field_7\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tInner2: &Inner{Field: &fieldVal},\n\t\tField:  \"populated\",\n\t\tFieldE: \"populated\",\n\t}\n\n\tvalidate = New()\n\n\terrs = validate.Struct(test3)\n\tEqual(t, errs, nil)\n}\n\nfunc TestRequiredWithAll(t *testing.T) {\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner   *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_with_all=FieldE\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_with_all=Field1\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_with_all=Field2\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_with_all=Field3\" json:\"field_4\"`\n\t\tField5  string            `validate:\"required_with_all=Inner.Field\" json:\"field_5\"`\n\t\tField6  Inner             `validate:\"required_with_all=Field1 Field2\" json:\"field_6\"`\n\t\tField7  *Inner            `validate:\"required_with_all=Field1 Field2\" json:\"field_7\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField1: \"test_field1\",\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: Inner{Field: &fieldVal},\n\t\tField7: &Inner{Field: &fieldVal},\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner   *Inner\n\t\tInner2  *Inner\n\t\tFieldE  string            `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string            `validate:\"required_with_all=FieldE\" json:\"field_er\"`\n\t\tField1  string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_with_all=Field1\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_with_all=Field2\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_with_all=Field1 FieldE\" json:\"field_4\"`\n\t\tField5  string            `validate:\"required_with_all=Inner.Field Field2\" json:\"field_5\"`\n\t\tField6  string            `validate:\"required_with_all=Inner2.Field Field2\" json:\"field_6\"`\n\t\tField7  Inner             `validate:\"required_with_all=Inner.Field Field2\" json:\"field_7\"`\n\t\tField8  *Inner            `validate:\"required_with_all=Inner.Field Field2\" json:\"field_8\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField2: &fieldVal,\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 4)\n\tAssertError(t, errs, \"Field3\", \"Field3\", \"Field3\", \"Field3\", \"required_with_all\")\n\tAssertError(t, errs, \"Field5\", \"Field5\", \"Field5\", \"Field5\", \"required_with_all\")\n\tAssertError(t, errs, \"Field7\", \"Field7\", \"Field7\", \"Field7\", \"required_with_all\")\n\tAssertError(t, errs, \"Field8\", \"Field8\", \"Field8\", \"Field8\", \"required_with_all\")\n}\n\nfunc TestRequiredWithout(t *testing.T) {\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tInner  *Inner\n\t\tField1 string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"required_without=Field1\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"required_without=Field2\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"required_without=Field3\" json:\"field_4\"`\n\t\tField5 string            `validate:\"required_without=Field3\" json:\"field_5\"`\n\t\tField6 Inner             `validate:\"required_without=Field1\" json:\"field_6\"`\n\t\tField7 *Inner            `validate:\"required_without=Field1\" json:\"field_7\"`\n\t}{\n\t\tInner:  &Inner{Field: &fieldVal},\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: Inner{Field: &fieldVal},\n\t\tField7: &Inner{Field: &fieldVal},\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tInner   *Inner\n\t\tInner2  *Inner\n\t\tField1  string            `json:\"field_1\"`\n\t\tField2  *string           `validate:\"required_without=Field1\" json:\"field_2\"`\n\t\tField3  map[string]string `validate:\"required_without=Field2\" json:\"field_3\"`\n\t\tField4  interface{}       `validate:\"required_without=Field3\" json:\"field_4\"`\n\t\tField5  string            `validate:\"required_without=Field3\" json:\"field_5\"`\n\t\tField6  string            `validate:\"required_without=Field1\" json:\"field_6\"`\n\t\tField7  string            `validate:\"required_without=Inner.Field\" json:\"field_7\"`\n\t\tField8  string            `validate:\"required_without=Inner.Field\" json:\"field_8\"`\n\t\tField9  Inner             `validate:\"required_without=Field1\" json:\"field_9\"`\n\t\tField10 *Inner            `validate:\"required_without=Field1\" json:\"field_10\"`\n\t}{\n\t\tInner:  &Inner{},\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t}\n\n\terrs = validate.Struct(&test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 6)\n\tAssertError(t, errs, \"Field2\", \"Field2\", \"Field2\", \"Field2\", \"required_without\")\n\tAssertError(t, errs, \"Field6\", \"Field6\", \"Field6\", \"Field6\", \"required_without\")\n\tAssertError(t, errs, \"Field7\", \"Field7\", \"Field7\", \"Field7\", \"required_without\")\n\tAssertError(t, errs, \"Field8\", \"Field8\", \"Field8\", \"Field8\", \"required_without\")\n\tAssertError(t, errs, \"Field9\", \"Field9\", \"Field9\", \"Field9\", \"required_without\")\n\tAssertError(t, errs, \"Field10\", \"Field10\", \"Field10\", \"Field10\", \"required_without\")\n\n\ttest3 := struct {\n\t\tField1 *string `validate:\"required_without=Field2,omitempty,min=1\" json:\"field_1\"`\n\t\tField2 *string `validate:\"required_without=Field1,omitempty,min=1\" json:\"field_2\"`\n\t}{\n\t\tField1: &fieldVal,\n\t}\n\n\terrs = validate.Struct(&test3)\n\tEqual(t, errs, nil)\n}\n\nfunc TestRequiredWithoutAll(t *testing.T) {\n\ttype nested struct {\n\t\tvalue string\n\t}\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tField1 string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"required_without_all=Field1\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"required_without_all=Field2\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"required_without_all=Field3\" json:\"field_4\"`\n\t\tField5 string            `validate:\"required_without_all=Field3\" json:\"field_5\"`\n\t\tField6 nested            `validate:\"required_without_all=Field1\" json:\"field_6\"`\n\t\tField7 *nested           `validate:\"required_without_all=Field1\" json:\"field_7\"`\n\t}{\n\t\tField1: \"\",\n\t\tField2: &fieldVal,\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t\tField6: nested{\"potato\"},\n\t\tField7: &nested{\"potato\"},\n\t}\n\n\tvalidate := New()\n\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tField1 string            `validate:\"omitempty\" json:\"field_1\"`\n\t\tField2 *string           `validate:\"required_without_all=Field1\" json:\"field_2\"`\n\t\tField3 map[string]string `validate:\"required_without_all=Field2\" json:\"field_3\"`\n\t\tField4 interface{}       `validate:\"required_without_all=Field3\" json:\"field_4\"`\n\t\tField5 string            `validate:\"required_without_all=Field3\" json:\"field_5\"`\n\t\tField6 string            `validate:\"required_without_all=Field1 Field3\" json:\"field_6\"`\n\t\tField7 nested            `validate:\"required_without_all=Field1\" json:\"field_7\"`\n\t\tField8 *nested           `validate:\"required_without_all=Field1\" json:\"field_8\"`\n\t}{\n\t\tField3: map[string]string{\"key\": \"val\"},\n\t\tField4: \"test\",\n\t\tField5: \"test\",\n\t}\n\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 3)\n\tAssertError(t, errs, \"Field2\", \"Field2\", \"Field2\", \"Field2\", \"required_without_all\")\n\tAssertError(t, errs, \"Field7\", \"Field7\", \"Field7\", \"Field7\", \"required_without_all\")\n\tAssertError(t, errs, \"Field8\", \"Field8\", \"Field8\", \"Field8\", \"required_without_all\")\n}\n\nfunc TestExcludedIf(t *testing.T) {\n\tvalidate := New()\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tshouldExclude := \"exclude\"\n\tshouldNotExclude := \"dontExclude\"\n\n\ttest1 := struct {\n\t\tFieldE  string  `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER *string `validate:\"excluded_if=FieldE exclude\" json:\"field_er\"`\n\t}{\n\t\tFieldE: shouldExclude,\n\t}\n\terrs := validate.Struct(test1)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_if=FieldE exclude\" json:\"field_er\"`\n\t}{\n\t\tFieldE:  shouldExclude,\n\t\tFieldER: \"set\",\n\t}\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"FieldER\", \"FieldER\", \"FieldER\", \"FieldER\", \"excluded_if\")\n\n\ttest3 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldF  string `validate:\"omitempty\" json:\"field_f\"`\n\t\tFieldER string `validate:\"excluded_if=FieldE exclude FieldF exclude\" json:\"field_er\"`\n\t}{\n\t\tFieldE:  shouldExclude,\n\t\tFieldF:  shouldExclude,\n\t\tFieldER: \"set\",\n\t}\n\terrs = validate.Struct(test3)\n\tNotEqual(t, errs, nil)\n\tve = errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"FieldER\", \"FieldER\", \"FieldER\", \"FieldER\", \"excluded_if\")\n\n\ttest4 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldF  string `validate:\"omitempty\" json:\"field_f\"`\n\t\tFieldER string `validate:\"excluded_if=FieldE exclude FieldF exclude\" json:\"field_er\"`\n\t}{\n\t\tFieldE:  shouldExclude,\n\t\tFieldF:  shouldNotExclude,\n\t\tFieldER: \"set\",\n\t}\n\terrs = validate.Struct(test4)\n\tEqual(t, errs, nil)\n\n\ttest5 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_if=FieldE exclude\" json:\"field_er\"`\n\t}{\n\t\tFieldE: shouldNotExclude,\n\t}\n\terrs = validate.Struct(test5)\n\tEqual(t, errs, nil)\n\n\ttest6 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_if=FieldE exclude\" json:\"field_er\"`\n\t}{\n\t\tFieldE:  shouldNotExclude,\n\t\tFieldER: \"set\",\n\t}\n\terrs = validate.Struct(test6)\n\tEqual(t, errs, nil)\n\n\ttest7 := struct {\n\t\tInner  *Inner\n\t\tFieldE string `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 int    `validate:\"excluded_if=Inner.Field exclude\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &shouldExclude},\n\t}\n\terrs = validate.Struct(test7)\n\tEqual(t, errs, nil)\n\n\ttest8 := struct {\n\t\tInner  *Inner\n\t\tFieldE string `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 int    `validate:\"excluded_if=Inner.Field exclude\" json:\"field_1\"`\n\t}{\n\t\tInner:  &Inner{Field: &shouldExclude},\n\t\tField1: 1,\n\t}\n\terrs = validate.Struct(test8)\n\tNotEqual(t, errs, nil)\n\tve = errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"Field1\", \"Field1\", \"Field1\", \"Field1\", \"excluded_if\")\n\n\ttest9 := struct {\n\t\tInner  *Inner\n\t\tFieldE string `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 int    `validate:\"excluded_if=Inner.Field exclude\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &shouldNotExclude},\n\t}\n\terrs = validate.Struct(test9)\n\tEqual(t, errs, nil)\n\n\ttest10 := struct {\n\t\tInner  *Inner\n\t\tFieldE string `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 int    `validate:\"excluded_if=Inner.Field exclude\" json:\"field_1\"`\n\t}{\n\t\tInner:  &Inner{Field: &shouldNotExclude},\n\t\tField1: 1,\n\t}\n\terrs = validate.Struct(test10)\n\tEqual(t, errs, nil)\n\n\ttest11 := struct {\n\t\tField1 bool\n  \t\tField2 *string `validate:\"excluded_if=Field1 false\"`\n\t}{\n\t\tField1: false,\n\t\tField2: nil,\n\t}\n\terrs = validate.Struct(test11)\n\tEqual(t, errs, nil)\n\n\ttest12 := struct {\n\t\tField1 bool\n\t\tField2 *string `validate:\"excluded_if=Field1 !Field1\"`\n\t}{\n\t\tField1: true,\n\t\tField2: nil,\n\t}\n\terrs = validate.Struct(test12)\n\tEqual(t, errs, nil)\n\t// Checks number of params in struct tag is correct\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"panicTest should have panicked!\")\n\t\t}\n\t}()\n\tfieldVal := \"panicTest\"\n\tpanicTest := struct {\n\t\tInner  *Inner\n\t\tField1 string `validate:\"excluded_if=Inner.Field\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &fieldVal},\n\t}\n\t_ = validate.Struct(panicTest)\n}\n\nfunc TestExcludedUnless(t *testing.T) {\n\tvalidate := New()\n\ttype Inner struct {\n\t\tField *string\n\t}\n\n\tfieldVal := \"test\"\n\ttest := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_unless=FieldE test\" json:\"field_er\"`\n\t}{\n\t\tFieldE:  \"test\",\n\t\tFieldER: \"filled\",\n\t}\n\terrs := validate.Struct(test)\n\tEqual(t, errs, nil)\n\n\ttest2 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_unless=FieldE test\" json:\"field_er\"`\n\t}{\n\t\tFieldE:  \"notest\",\n\t\tFieldER: \"filled\",\n\t}\n\terrs = validate.Struct(test2)\n\tNotEqual(t, errs, nil)\n\tve := errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"FieldER\", \"FieldER\", \"FieldER\", \"FieldER\", \"excluded_unless\")\n\n\t// test5 and test6: excluded_unless has no effect if FieldER is left blank\n\ttest5 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_unless=FieldE test\" json:\"field_er\"`\n\t}{\n\t\tFieldE: \"test\",\n\t}\n\terrs = validate.Struct(test5)\n\tEqual(t, errs, nil)\n\n\ttest6 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_unless=FieldE test\" json:\"field_er\"`\n\t}{\n\t\tFieldE: \"notest\",\n\t}\n\terrs = validate.Struct(test6)\n\tEqual(t, errs, nil)\n\n\tshouldError := \"notest\"\n\ttest3 := struct {\n\t\tInner  *Inner\n\t\tField1 string `validate:\"excluded_unless=Inner.Field test\" json:\"field_1\"`\n\t}{\n\t\tInner:  &Inner{Field: &shouldError},\n\t\tField1: \"filled\",\n\t}\n\terrs = validate.Struct(test3)\n\tNotEqual(t, errs, nil)\n\tve = errs.(ValidationErrors)\n\tEqual(t, len(ve), 1)\n\tAssertError(t, errs, \"Field1\", \"Field1\", \"Field1\", \"Field1\", \"excluded_unless\")\n\n\tshouldPass := \"test\"\n\ttest4 := struct {\n\t\tInner  *Inner\n\t\tFieldE string `validate:\"omitempty\" json:\"field_e\"`\n\t\tField1 string `validate:\"excluded_unless=Inner.Field test\" json:\"field_1\"`\n\t}{\n\t\tInner:  &Inner{Field: &shouldPass},\n\t\tField1: \"filled\",\n\t}\n\terrs = validate.Struct(test4)\n\tEqual(t, errs, nil)\n\n\t// test7 and test8: excluded_unless has no effect if FieldER is left blank\n\ttest7 := struct {\n\t\tInner   *Inner\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_unless=Inner.Field test\" json:\"field_er\"`\n\t}{\n\t\tFieldE: \"test\",\n\t}\n\terrs = validate.Struct(test7)\n\tEqual(t, errs, nil)\n\n\ttest8 := struct {\n\t\tFieldE  string `validate:\"omitempty\" json:\"field_e\"`\n\t\tFieldER string `validate:\"excluded_unless=Inner.Field test\" json:\"field_er\"`\n\t}{\n\t\tFieldE: \"test\",\n\t}\n\terrs = validate.Struct(test8)\n\tEqual(t, errs, nil)\n\n\t// Checks number of params in struct tag is correct\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"panicTest should have panicked!\")\n\t\t}\n\t}()\n\tpanicTest := struct {\n\t\tInner  *Inner\n\t\tField1 string `validate:\"excluded_unless=Inner.Field\" json:\"field_1\"`\n\t}{\n\t\tInner: &Inner{Field: &fieldVal},\n\t}\n\t_ = validate.Struct(panicTest)\n}\n\nfunc TestLookup(t *testing.T) {\n\ttype Lookup struct {\n\t\tFieldA *string `json:\"fieldA,omitempty\" validate:\"required_without=FieldB\"`\n\t\tFieldB *string `json:\"fieldB,omitempty\" validate:\"required_without=FieldA\"`\n\t}\n\n\tfieldAValue := \"1232\"\n\tlookup := Lookup{\n\t\tFieldA: &fieldAValue,\n\t\tFieldB: nil,\n\t}\n\tEqual(t, New().Struct(lookup), nil)\n}\n\nfunc TestAbilityToValidateNils(t *testing.T) {\n\ttype TestStruct struct {\n\t\tTest *string `validate:\"nil\"`\n\t}\n\n\tts := TestStruct{}\n\tval := New()\n\tfn := func(fl FieldLevel) bool {\n\t\treturn fl.Field().Kind() == reflect.Ptr && fl.Field().IsNil()\n\t}\n\n\terr := val.RegisterValidation(\"nil\", fn, true)\n\tEqual(t, err, nil)\n\n\terrs := val.Struct(ts)\n\tEqual(t, errs, nil)\n\n\tstr := \"string\"\n\tts.Test = &str\n\n\terrs = val.Struct(ts)\n\tNotEqual(t, errs, nil)\n}\n\nfunc TestRequiredWithoutPointers(t *testing.T) {\n\ttype Lookup struct {\n\t\tFieldA *bool `json:\"fieldA,omitempty\" validate:\"required_without=FieldB\"`\n\t\tFieldB *bool `json:\"fieldB,omitempty\" validate:\"required_without=FieldA\"`\n\t}\n\n\tb := true\n\tlookup := Lookup{\n\t\tFieldA: &b,\n\t\tFieldB: nil,\n\t}\n\n\tval := New()\n\terrs := val.Struct(lookup)\n\tEqual(t, errs, nil)\n\n\tb = false\n\tlookup = Lookup{\n\t\tFieldA: &b,\n\t\tFieldB: nil,\n\t}\n\terrs = val.Struct(lookup)\n\tEqual(t, errs, nil)\n}\n\nfunc TestRequiredWithoutAllPointers(t *testing.T) {\n\ttype Lookup struct {\n\t\tFieldA *bool `json:\"fieldA,omitempty\" validate:\"required_without_all=FieldB\"`\n\t\tFieldB *bool `json:\"fieldB,omitempty\" validate:\"required_without_all=FieldA\"`\n\t}\n\n\tb := true\n\tlookup := Lookup{\n\t\tFieldA: &b,\n\t\tFieldB: nil,\n\t}\n\n\tval := New()\n\terrs := val.Struct(lookup)\n\tEqual(t, errs, nil)\n\n\tb = false\n\tlookup = Lookup{\n\t\tFieldA: &b,\n\t\tFieldB: nil,\n\t}\n\terrs = val.Struct(lookup)\n\tEqual(t, errs, nil)\n}\n\nfunc TestGetTag(t *testing.T) {\n\tvar tag string\n\n\ttype Test struct {\n\t\tString string `validate:\"mytag\"`\n\t}\n\n\tval := New()\n\t_ = val.RegisterValidation(\"mytag\", func(fl FieldLevel) bool {\n\t\ttag = fl.GetTag()\n\t\treturn true\n\t})\n\n\tvar test Test\n\terrs := val.Struct(test)\n\tEqual(t, errs, nil)\n\tEqual(t, tag, \"mytag\")\n}\n\nfunc TestJSONValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    interface{}\n\t\texpected bool\n\t}{\n\t\t{`foo`, false},\n\t\t{`}{`, false},\n\t\t{`{]`, false},\n\t\t{`{}`, true},\n\t\t{`{\"foo\":\"bar\"}`, true},\n\t\t{`{\"foo\":\"bar\",\"bar\":{\"baz\":[\"qux\"]}}`, true},\n\t\t{`{\"foo\": 3 \"bar\": 4}`, false},\n\t\t{`{\"foo\": 3 ,\"bar\": 4`, false},\n\t\t{`{foo\": 3, \"bar\": 4}`, false},\n\t\t{`foo`, false},\n\t\t{`1`, true},\n\t\t{`true`, true},\n\t\t{`null`, true},\n\t\t{`\"null\"`, true},\n\t\t{json.RawMessage(`foo`), false},\n\t\t{json.RawMessage(`}{`), false},\n\t\t{json.RawMessage(`{]`), false},\n\t\t{json.RawMessage(`{}`), true},\n\t\t{json.RawMessage(`{\"foo\":\"bar\"}`), true},\n\t\t{json.RawMessage(`{\"foo\":\"bar\",\"bar\":{\"baz\":[\"qux\"]}}`), true},\n\t\t{json.RawMessage(`{\"foo\": 3 \"bar\": 4}`), false},\n\t\t{json.RawMessage(`{\"foo\": 3 ,\"bar\": 4`), false},\n\t\t{json.RawMessage(`{foo\": 3, \"bar\": 4}`), false},\n\t\t{json.RawMessage(`foo`), false},\n\t\t{json.RawMessage(`1`), true},\n\t\t{json.RawMessage(`true`), true},\n\t\t{json.RawMessage(`null`), true},\n\t\t{json.RawMessage(`\"null\"`), true},\n\t\t{[]byte(`foo`), false},\n\t\t{[]byte(`}{`), false},\n\t\t{[]byte(`{]`), false},\n\t\t{[]byte(`{}`), true},\n\t\t{[]byte(`{\"foo\":\"bar\"}`), true},\n\t\t{[]byte(`{\"foo\":\"bar\",\"bar\":{\"baz\":[\"qux\"]}}`), true},\n\t\t{[]byte(`{\"foo\": 3 \"bar\": 4}`), false},\n\t\t{[]byte(`{\"foo\": 3 ,\"bar\": 4`), false},\n\t\t{[]byte(`{foo\": 3, \"bar\": 4}`), false},\n\t\t{[]byte(`foo`), false},\n\t\t{[]byte(`1`), true},\n\t\t{[]byte(`true`), true},\n\t\t{[]byte(`null`), true},\n\t\t{[]byte(`\"null\"`), true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"json\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d json failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d json failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"json\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d json failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(2, \"json\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestJWTValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{\"eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiZ29waGVyIn0.O_bROM_szPq9qBql-XDHMranHwP48ODdoLICWzqBr_U\", true},\n\t\t{\"acb123-_.def456-_.ghi789-_\", true},\n\t\t{\"eyJhbGciOiJOT05FIn0.e30.\", true},\n\t\t{\"eyJhbGciOiJOT05FIn0.e30.\\n\", false},\n\t\t{\"\\x00.\\x00.\\x00\", false},\n\t\t{\"\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"jwt\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d jwt failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d jwt failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"jwt\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d jwt failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_hostnameport_validator(t *testing.T) {\n\ttype Host struct {\n\t\tAddr string `validate:\"hostname_port\"`\n\t}\n\n\ttype testInput struct {\n\t\tdata     string\n\t\texpected bool\n\t}\n\ttestData := []testInput{\n\t\t{\"bad..domain.name:234\", false},\n\t\t{\"extra.dot.com.\", false},\n\t\t{\"localhost:1234\", true},\n\t\t{\"192.168.1.1:1234\", true},\n\t\t{\":1234\", true},\n\t\t{\"domain.com:1334\", true},\n\t\t{\"this.domain.com:234\", true},\n\t\t{\"domain:75000\", false},\n\t\t{\"missing.port\", false},\n\t}\n\tfor _, td := range testData {\n\t\th := Host{Addr: td.data}\n\t\tv := New()\n\t\terr := v.Struct(h)\n\t\tif td.expected != (err == nil) {\n\t\t\tt.Fatalf(\"Test failed for data: %v Error: %v\", td.data, err)\n\t\t}\n\t}\n}\n\nfunc Test_port_validator(t *testing.T) {\n\ttype Host struct {\n\t\tPort uint32 `validate:\"port\"`\n\t}\n\n\ttype testInput struct {\n\t\tdata     uint32\n\t\texpected bool\n\t}\n\ttestData := []testInput{\n\t\t{0, false},\n\t\t{1, true},\n\t\t{65535, true},\n\t\t{65536, false},\n\t\t{65538, false},\n\t}\n\tfor _, td := range testData {\n\t\th := Host{Port: td.data}\n\t\tv := New()\n\t\terr := v.Struct(h)\n\t\tif td.expected != (err == nil) {\n\t\t\tt.Fatalf(\"Test failed for data: %v Error: %v\", td.data, err)\n\t\t}\n\t}\n}\n\nfunc TestLowercaseValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{`abcdefg`, true},\n\t\t{`Abcdefg`, false},\n\t\t{\"\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"lowercase\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d lowercase failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d lowercase failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"lowercase\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d lowercase failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(2, \"lowercase\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestUppercaseValidation(t *testing.T) {\n\ttests := []struct {\n\t\tparam    string\n\t\texpected bool\n\t}{\n\t\t{`ABCDEFG`, true},\n\t\t{`aBCDEFG`, false},\n\t\t{\"\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.param, \"uppercase\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d uppercase failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d uppercase failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"uppercase\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d uppercase failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(2, \"uppercase\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestDatetimeValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"datetime=2006-01-02\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"2008-02-01\", `datetime=2006-01-02`, true},\n\t\t{\"2008-Feb-01\", `datetime=2006-01-02`, false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d datetime failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d datetime failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"datetime\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d datetime failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(2, \"datetime\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestIsIso3166Alpha2Validation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"iso3166_1_alpha2\"`\n\t\texpected bool\n\t}{\n\t\t{\"PL\", true},\n\t\t{\"POL\", false},\n\t\t{\"AA\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso3166_1_alpha2\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha2 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha2 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsIso3166Alpha2EUValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"iso3166_1_alpha2_eu\"`\n\t\texpected bool\n\t}{\n\t\t{\"SE\", true},\n\t\t{\"UK\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso3166_1_alpha2_eu\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha2_eu failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha2_eu failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsIso31662Validation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"iso3166_2\"`\n\t\texpected bool\n\t}{\n\t\t{\"US-FL\", true},\n\t\t{\"US-F\", false},\n\t\t{\"US\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso3166_2\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_2 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_2 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsIso3166Alpha3Validation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"iso3166_1_alpha3\"`\n\t\texpected bool\n\t}{\n\t\t{\"POL\", true},\n\t\t{\"PL\", false},\n\t\t{\"AAA\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso3166_1_alpha3\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha3 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha3 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsIso3166Alpha3EUValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"iso3166_1_alpha3_eu\"`\n\t\texpected bool\n\t}{\n\t\t{\"POL\", true},\n\t\t{\"SWE\", true},\n\t\t{\"UNK\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso3166_1_alpha3_eu\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha3_eu failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha3_eu failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsIso3166AlphaNumericValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    interface{}\n\t\texpected bool\n\t}{\n\t\t{248, true},\n\t\t{\"248\", true},\n\t\t{0, false},\n\t\t{1, false},\n\t\t{\"1\", false},\n\t\t{\"invalid_int\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso3166_1_alpha_numeric\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha_numeric failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha_numeric failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var([]string{\"1\"}, \"iso3166_1_alpha_numeric\")\n\t}, \"Bad field type []string\")\n}\n\nfunc TestIsIso3166AlphaNumericEUValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    interface{}\n\t\texpected bool\n\t}{\n\t\t{752, true}, //Sweden\n\t\t{\"752\", true},\n\t\t{826, false}, // UK\n\t\t{\"826\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso3166_1_alpha_numeric_eu\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha_numeric_eu failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso3166_1_alpha_numeric_eu failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var([]string{\"1\"}, \"iso3166_1_alpha_numeric_eu\")\n\t}, \"Bad field type []string\")\n}\n\nfunc TestCountryCodeValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    interface{}\n\t\texpected bool\n\t}{\n\t\t{248, true},\n\t\t{0, false},\n\t\t{1, false},\n\t\t{\"POL\", true},\n\t\t{\"NO\", true},\n\t\t{\"248\", true},\n\t\t{\"1\", false},\n\t\t{\"0\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"country_code\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d country_code failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d country_code failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestEUCountryCodeValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    interface{}\n\t\texpected bool\n\t}{\n\t\t{724, true},\n\t\t{0, false},\n\t\t{1, false},\n\t\t{\"POL\", true},\n\t\t{\"NO\", false},\n\t\t{\"724\", true},\n\t\t{\"1\", false},\n\t\t{\"0\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"eu_country_code\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d eu_country_code failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d eu_country_code failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsIso4217Validation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"iso4217\"`\n\t\texpected bool\n\t}{\n\t\t{\"TRY\", true},\n\t\t{\"EUR\", true},\n\t\t{\"USA\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso4217\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso4217 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso4217 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestIsIso4217NumericValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    int `validate:\"iso4217_numeric\"`\n\t\texpected bool\n\t}{\n\t\t{8, true},\n\t\t{12, true},\n\t\t{13, false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, \"iso4217_numeric\")\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso4217 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d iso4217 failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestTimeZoneValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"timezone\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t// systems may have different time zone database, some systems time zone are case insensitive\n\t\t{\"America/New_York\", `timezone`, true},\n\t\t{\"UTC\", `timezone`, true},\n\t\t{\"\", `timezone`, false},\n\t\t{\"Local\", `timezone`, false},\n\t\t{\"Unknown\", `timezone`, false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d time zone failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d time zone failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"timezone\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d time zone failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(2, \"timezone\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestDurationType(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\ts       interface{} // struct\n\t\tsuccess bool\n\t}{\n\t\t{\n\t\t\tname: \"valid duration string pass\",\n\t\t\ts: struct {\n\t\t\t\tValue time.Duration `validate:\"gte=500ns\"`\n\t\t\t}{\n\t\t\t\tValue: time.Second,\n\t\t\t},\n\t\t\tsuccess: true,\n\t\t},\n\t\t{\n\t\t\tname: \"valid duration int pass\",\n\t\t\ts: struct {\n\t\t\t\tValue time.Duration `validate:\"gte=500\"`\n\t\t\t}{\n\t\t\t\tValue: time.Second,\n\t\t\t},\n\t\t\tsuccess: true,\n\t\t},\n\t}\n\n\tvalidate := New()\n\n\tfor _, tc := range tests {\n\t\ttc := tc\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\terrs := validate.Struct(tc.s)\n\t\t\tif tc.success {\n\t\t\t\tEqual(t, errs, nil)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tNotEqual(t, errs, nil)\n\t\t})\n\t}\n}\n\nfunc TestBCP47LanguageTagValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"bcp47_language_tag\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"en-US\", \"bcp47_language_tag\", true},\n\t\t{\"en_GB\", \"bcp47_language_tag\", true},\n\t\t{\"es\", \"bcp47_language_tag\", true},\n\t\t{\"English\", \"bcp47_language_tag\", false},\n\t\t{\"ESES\", \"bcp47_language_tag\", false},\n\t\t{\"az-Cyrl-AZ\", \"bcp47_language_tag\", true},\n\t\t{\"en-029\", \"bcp47_language_tag\", true},\n\t\t{\"xog\", \"bcp47_language_tag\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d locale failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d locale failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"bcp47_language_tag\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d locale failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tPanicMatches(t, func() {\n\t\t_ = validate.Var(2, \"bcp47_language_tag\")\n\t}, \"Bad field type int\")\n}\n\nfunc TestBicIsoFormatValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"bic\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"SBICKEN1345\", \"bic\", true},\n\t\t{\"SBICKEN1\", \"bic\", true},\n\t\t{\"SBICKENY\", \"bic\", true},\n\t\t{\"SBICKEN1YYP\", \"bic\", true},\n\t\t{\"SBIC23NXXX\", \"bic\", false},\n\t\t{\"S23CKENXXXX\", \"bic\", false},\n\t\t{\"SBICKENXX\", \"bic\", false},\n\t\t{\"SBICKENXX9\", \"bic\", false},\n\t\t{\"SBICKEN13458\", \"bic\", false},\n\t\t{\"SBICKEN\", \"bic\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d bic failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d bic failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"bic\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d bic failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSemverFormatValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"semver\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"1.2.3\", \"semver\", true},\n\t\t{\"10.20.30\", \"semver\", true},\n\t\t{\"1.1.2-prerelease+meta\", \"semver\", true},\n\t\t{\"1.1.2+meta\", \"semver\", true},\n\t\t{\"1.1.2+meta-valid\", \"semver\", true},\n\t\t{\"1.0.0-alpha\", \"semver\", true},\n\t\t{\"1.0.0-alpha.1\", \"semver\", true},\n\t\t{\"1.0.0-alpha.beta\", \"semver\", true},\n\t\t{\"1.0.0-alpha.beta.1\", \"semver\", true},\n\t\t{\"1.0.0-alpha0.valid\", \"semver\", true},\n\t\t{\"1.0.0-alpha.0valid\", \"semver\", true},\n\t\t{\"1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay\", \"semver\", true},\n\t\t{\"1.0.0-rc.1+build.1\", \"semver\", true},\n\t\t{\"1.0.0-rc.1+build.123\", \"semver\", true},\n\t\t{\"1.2.3-beta\", \"semver\", true},\n\t\t{\"1.2.3-DEV-SNAPSHOT\", \"semver\", true},\n\t\t{\"1.2.3-SNAPSHOT-123\", \"semver\", true},\n\t\t{\"2.0.0+build.1848\", \"semver\", true},\n\t\t{\"2.0.1-alpha.1227\", \"semver\", true},\n\t\t{\"1.0.0-alpha+beta\", \"semver\", true},\n\t\t{\"1.2.3----RC-SNAPSHOT.12.9.1--.12+788\", \"semver\", true},\n\t\t{\"1.2.3----R-S.12.9.1--.12+meta\", \"semver\", true},\n\t\t{\"1.2.3----RC-SNAPSHOT.12.9.1--.12\", \"semver\", true},\n\t\t{\"1.0.0+0.build.1-rc.10000aaa-kk-0.1\", \"semver\", true},\n\t\t{\"99999999999999999999999.999999999999999999.99999999999999999\", \"semver\", true},\n\t\t{\"1.0.0-0A.is.legal\", \"semver\", true},\n\t\t{\"1\", \"semver\", false},\n\t\t{\"1.2\", \"semver\", false},\n\t\t{\"1.2.3-0123\", \"semver\", false},\n\t\t{\"1.2.3-0123.0123\", \"semver\", false},\n\t\t{\"1.1.2+.123\", \"semver\", false},\n\t\t{\"+invalid\", \"semver\", false},\n\t\t{\"-invalid\", \"semver\", false},\n\t\t{\"-invalid+invalid\", \"semver\", false},\n\t\t{\"alpha\", \"semver\", false},\n\t\t{\"alpha.beta.1\", \"semver\", false},\n\t\t{\"alpha.1\", \"semver\", false},\n\t\t{\"1.0.0-alpha_beta\", \"semver\", false},\n\t\t{\"1.0.0-alpha_beta\", \"semver\", false},\n\t\t{\"1.0.0-alpha...1\", \"semver\", false},\n\t\t{\"01.1.1\", \"semver\", false},\n\t\t{\"1.01.1\", \"semver\", false},\n\t\t{\"1.1.01\", \"semver\", false},\n\t\t{\"1.2\", \"semver\", false},\n\t\t{\"1.2.Dev\", \"semver\", false},\n\t\t{\"1.2.3.Dev\", \"semver\", false},\n\t\t{\"1.2-SNAPSHOT\", \"semver\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d semver failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d semver failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"semver\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d semver failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCveFormatValidation(t *testing.T) {\n\n\ttests := []struct {\n\t\tvalue    string `validate:\"cve\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"CVE-1999-0001\", \"cve\", true},\n\t\t{\"CVE-1998-0001\", \"cve\", false},\n\t\t{\"CVE-2000-0001\", \"cve\", true},\n\t\t{\"CVE-2222-0001\", \"cve\", true},\n\t\t{\"2222-0001\", \"cve\", false},\n\t\t{\"-2222-0001\", \"cve\", false},\n\t\t{\"CVE22220001\", \"cve\", false},\n\t\t{\"CVE-2222-000001\", \"cve\", false},\n\t\t{\"CVE-2222-100001\", \"cve\", true},\n\t\t{\"CVE-2222-99999999999\", \"cve\", true},\n\t\t{\"CVE-3000-0001\", \"cve\", false},\n\t\t{\"CVE-1999-0000\", \"cve\", false},\n\t\t{\"CVE-2099-0000\", \"cve\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cve failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d cve failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"cve\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d cve failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRFC1035LabelFormatValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"dns_rfc1035_label\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"abc\", \"dns_rfc1035_label\", true},\n\t\t{\"abc-\", \"dns_rfc1035_label\", false},\n\t\t{\"abc-123\", \"dns_rfc1035_label\", true},\n\t\t{\"ABC\", \"dns_rfc1035_label\", false},\n\t\t{\"ABC-123\", \"dns_rfc1035_label\", false},\n\t\t{\"abc-abc\", \"dns_rfc1035_label\", true},\n\t\t{\"ABC-ABC\", \"dns_rfc1035_label\", false},\n\t\t{\"123-abc\", \"dns_rfc1035_label\", false},\n\t\t{\"\", \"dns_rfc1035_label\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d dns_rfc1035_label failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d dns_rfc1035_label failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"dns_rfc1035_label\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d dns_rfc1035_label failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPostCodeByIso3166Alpha2(t *testing.T) {\n\ttests := map[string][]struct {\n\t\tvalue    string\n\t\texpected bool\n\t}{\n\t\t\"VN\": {\n\t\t\t{\"ABC\", false},\n\t\t\t{\"700000\", true},\n\t\t\t{\"A1\", false},\n\t\t},\n\t\t\"GB\": {\n\t\t\t{\"EC1A 1BB\", true},\n\t\t\t{\"CF10 1B1H\", false},\n\t\t},\n\t\t\"VI\": {\n\t\t\t{\"00803\", true},\n\t\t\t{\"1234567\", false},\n\t\t},\n\t\t\"LC\": {\n\t\t\t// not support regexp for post code\n\t\t\t{\"123456\", false},\n\t\t},\n\t\t\"XX\": {\n\t\t\t// not support country\n\t\t\t{\"123456\", false},\n\t\t},\n\t}\n\n\tvalidate := New()\n\n\tfor cc, ccTests := range tests {\n\t\tfor i, test := range ccTests {\n\t\t\terrs := validate.Var(test.value, fmt.Sprintf(\"postcode_iso3166_alpha2=%s\", cc))\n\n\t\t\tif test.expected {\n\t\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\t\tt.Fatalf(\"Index: %d postcode_iso3166_alpha2=%s failed Error: %s\", i, cc, errs)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif IsEqual(errs, nil) {\n\t\t\t\t\tt.Fatalf(\"Index: %d postcode_iso3166_alpha2=%s failed Error: %s\", i, cc, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPostCodeByIso3166Alpha2Field(t *testing.T) {\n\ttests := []struct {\n\t\tValue       string `validate:\"postcode_iso3166_alpha2_field=CountryCode\"`\n\t\tCountryCode interface{}\n\t\texpected    bool\n\t}{\n\t\t{\"ABC\", \"VN\", false},\n\t\t{\"700000\", \"VN\", true},\n\t\t{\"A1\", \"VN\", false},\n\t\t{\"EC1A 1BB\", \"GB\", true},\n\t\t{\"CF10 1B1H\", \"GB\", false},\n\t\t{\"00803\", \"VI\", true},\n\t\t{\"1234567\", \"VI\", false},\n\t\t{\"123456\", \"LC\", false}, // not support regexp for post code\n\t\t{\"123456\", \"XX\", false}, // not support country\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Struct(test)\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d postcode_iso3166_alpha2_field=CountryCode failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d postcode_iso3166_alpha2_field=CountryCode failed Error: %s\", i, errs)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestPostCodeByIso3166Alpha2Field_WrongField(t *testing.T) {\n\ttype test struct {\n\t\tValue        string `validate:\"postcode_iso3166_alpha2_field=CountryCode\"`\n\t\tCountryCode1 interface{}\n\t\texpected     bool\n\t}\n\n\terrs := New().Struct(test{\"ABC\", \"VN\", false})\n\tNotEqual(t, nil, errs)\n}\n\nfunc TestPostCodeByIso3166Alpha2Field_MissingParam(t *testing.T) {\n\ttype test struct {\n\t\tValue        string `validate:\"postcode_iso3166_alpha2_field=\"`\n\t\tCountryCode1 interface{}\n\t\texpected     bool\n\t}\n\n\terrs := New().Struct(test{\"ABC\", \"VN\", false})\n\tNotEqual(t, nil, errs)\n}\n\nfunc TestPostCodeByIso3166Alpha2Field_InvalidKind(t *testing.T) {\n\ttype test struct {\n\t\tValue       string `validate:\"postcode_iso3166_alpha2_field=CountryCode\"`\n\t\tCountryCode interface{}\n\t\texpected    bool\n\t}\n\tdefer func() { _ = recover() }()\n\n\t_ = New().Struct(test{\"ABC\", 123, false})\n\tt.Errorf(\"Didn't panic as expected\")\n}\n\nfunc TestValidate_ValidateMapCtx(t *testing.T) {\n\n\ttype args struct {\n\t\tdata  map[string]interface{}\n\t\trules map[string]interface{}\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant int\n\t}{\n\t\t{\n\t\t\tname: \"test nested map in slice\",\n\t\t\targs: args{\n\t\t\t\tdata: map[string]interface{}{\n\t\t\t\t\t\"Test_A\": map[string]interface{}{\n\t\t\t\t\t\t\"Test_B\": \"Test_B\",\n\t\t\t\t\t\t\"Test_C\": []map[string]interface{}{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"Test_D\": \"Test_D\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Test_E\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_F\": \"Test_F\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\trules: map[string]interface{}{\n\t\t\t\t\t\"Test_A\": map[string]interface{}{\n\t\t\t\t\t\t\"Test_B\": \"min=2\",\n\t\t\t\t\t\t\"Test_C\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_D\": \"min=2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Test_E\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_F\": \"min=2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: 0,\n\t\t},\n\n\t\t{\n\t\t\tname: \"test nested map error\",\n\t\t\targs: args{\n\t\t\t\tdata: map[string]interface{}{\n\t\t\t\t\t\"Test_A\": map[string]interface{}{\n\t\t\t\t\t\t\"Test_B\": \"Test_B\",\n\t\t\t\t\t\t\"Test_C\": []interface{}{\"Test_D\"},\n\t\t\t\t\t\t\"Test_E\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_F\": \"Test_F\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Test_G\": \"Test_G\",\n\t\t\t\t\t\t\"Test_I\": []map[string]interface{}{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"Test_J\": \"Test_J\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\trules: map[string]interface{}{\n\t\t\t\t\t\"Test_A\": map[string]interface{}{\n\t\t\t\t\t\t\"Test_B\": \"min=2\",\n\t\t\t\t\t\t\"Test_C\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_D\": \"min=2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Test_E\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_F\": \"min=100\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Test_G\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_H\": \"min=2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"Test_I\": map[string]interface{}{\n\t\t\t\t\t\t\t\"Test_J\": \"min=100\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: 1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvalidate := New()\n\t\t\tif got := validate.ValidateMapCtx(context.Background(), tt.args.data, tt.args.rules); len(got) != tt.want {\n\t\t\t\tt.Errorf(\"ValidateMapCtx() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMongoDBObjectIDFormatValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"mongodb\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"507f191e810c19729de860ea\", \"mongodb\", true},\n\t\t{\"507f191e810c19729de860eG\", \"mongodb\", false},\n\t\t{\"M07f191e810c19729de860eG\", \"mongodb\", false},\n\t\t{\"07f191e810c19729de860ea\", \"mongodb\", false},\n\t\t{\"507f191e810c19729de860e\", \"mongodb\", false},\n\t\t{\"507f191e810c19729de860ea4\", \"mongodb\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d mongodb failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d mongodb failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"mongodb\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d mongodb failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nfunc TestMongoDBConnectionStringFormatValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"mongodb_connection_string\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"mongodb://username:password@server.example.com:20017/database?replicaSet=test&connectTimeoutMS=300000&ssl=true\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://username:password@server.example.com:20017/database?replicaSet=test&connectTimeoutMS=300000&ssl=true\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://username:password@server.example.com:20017,server.example.com,server.example.com:20017/database?replicaSet=test&connectTimeoutMS=300000&ssl=true\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://username:password@server.example.com:20017,server.example.com,server.example.com:20017?replicaSet=test&connectTimeoutMS=300000&ssl=true\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb://username:password@server.example.com:20017,server.example.com,server.example.com:20017/database?replicaSet=test&connectTimeoutMS=300000&ssl=true\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb://localhost\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb://localhost:27017\", \"mongodb_connection_string\", true},\n\t\t{\"localhost\", \"mongodb_connection_string\", false},\n\t\t{\"mongodb://\", \"mongodb_connection_string\", false},\n\t\t{\"mongodb+srv://\", \"mongodb_connection_string\", false},\n\t\t{\"mongodbsrv://localhost\", \"mongodb_connection_string\", false},\n\t\t{\"mongodb+srv://localhost\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://localhost:27017\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://localhost?replicaSet=test\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://localhost:27017?replicaSet=test\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://localhost:27017?\", \"mongodb_connection_string\", false},\n\t\t{\"mongodb+srv://localhost:27017?replicaSet\", \"mongodb_connection_string\", false},\n\t\t{\"mongodb+srv://localhost/database\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://localhost:27017/database\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://username@localhost\", \"mongodb_connection_string\", false},\n\t\t{\"mongodb+srv://username:password@localhost\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://username:password@localhost:27017\", \"mongodb_connection_string\", true},\n\t\t{\"mongodb+srv://username:password@localhost:27017,192.0.0.7,192.0.0.9:27018,server.example.com\", \"mongodb_connection_string\", true},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d mongodb_connection_string failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d mongodb_connection_string failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"mongodb_connection_string\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d mongodb_connection_string failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestSpiceDBValueFormatValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t// Must be an asterisk OR a string containing alphanumeric characters and a restricted set a special symbols: _ | / - = +\n\t\t{\"*\", \"spicedb=id\", true},\n\t\t{`azAZ09_|/-=+`, \"spicedb=id\", true},\n\t\t{`a*`, \"spicedb=id\", false},\n\t\t{`/`, \"spicedb=id\", true},\n\t\t{\"*\", \"spicedb\", true},\n\n\t\t// Must begin and end with a lowercase letter, may also contain numbers and underscores between, min length 3, max length 64\n\t\t{\"a\", \"spicedb=permission\", false},\n\t\t{\"1\", \"spicedb=permission\", false},\n\t\t{\"a1\", \"spicedb=permission\", false},\n\t\t{\"a_b\", \"spicedb=permission\", true},\n\t\t{\"A_b\", \"spicedb=permission\", false},\n\t\t{\"a_B\", \"spicedb=permission\", false},\n\t\t{\"abcdefghijklmnopqrstuvwxyz_0123456789_abcdefghijklmnopqrstuvwxyz\", \"spicedb=permission\", true},\n\t\t{\"abcdefghijklmnopqrstuvwxyz_01234_56789_abcdefghijklmnopqrstuvwxyz\", \"spicedb=permission\", false},\n\n\t\t// Object types follow the same rules as permissions for the type name plus an optional prefix up to 63 characters with a /\n\t\t{\"a\", \"spicedb=type\", false},\n\t\t{\"1\", \"spicedb=type\", false},\n\t\t{\"a1\", \"spicedb=type\", false},\n\t\t{\"a_b\", \"spicedb=type\", true},\n\t\t{\"A_b\", \"spicedb=type\", false},\n\t\t{\"a_B\", \"spicedb=type\", false},\n\t\t{\"abcdefghijklmnopqrstuvwxyz_0123456789_abcdefghijklmnopqrstuvwxyz\", \"spicedb=type\", true},\n\t\t{\"abcdefghijklmnopqrstuvwxyz_01234_56789_abcdefghijklmnopqrstuvwxyz\", \"spicedb=type\", false},\n\n\t\t{`a_b/a`, \"spicedb=type\", false},\n\t\t{`a_b/1`, \"spicedb=type\", false},\n\t\t{`a_b/a1`, \"spicedb=type\", false},\n\t\t{`a_b/a_b`, \"spicedb=type\", true},\n\t\t{`a_b/A_b`, \"spicedb=type\", false},\n\t\t{`a_b/a_B`, \"spicedb=type\", false},\n\t\t{`a_b/abcdefghijklmnopqrstuvwxyz_0123456789_abcdefghijklmnopqrstuvwxyz`, \"spicedb=type\", true},\n\t\t{`a_b/abcdefghijklmnopqrstuvwxyz_01234_56789_abcdefghijklmnopqrstuvwxyz`, \"spicedb=type\", false},\n\n\t\t{`a/a_b`, \"spicedb=type\", false},\n\t\t{`1/a_b`, \"spicedb=type\", false},\n\t\t{`a1/a_b`, \"spicedb=type\", false},\n\t\t{`a_b/a_b`, \"spicedb=type\", true},\n\t\t{`A_b/a_b`, \"spicedb=type\", false},\n\t\t{`a_B/a_b`, \"spicedb=type\", false},\n\t\t{`abcdefghijklmnopqrstuvwxyz_0123456789_abcdefghijklmnopqrstuvwxy/a_b`, \"spicedb=type\", true},\n\t\t{`abcdefghijklmnopqrstuvwxyz_0123456789_abcdefghijklmnopqrstuvwxyz/a_b`, \"spicedb=type\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d spicedb failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d spicedb - expected error but there was none.\", i)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"spicedb\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d spicedb failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCreditCardFormatValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"credit_card\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"586824160825533338\", \"credit_card\", true},\n\t\t{\"586824160825533328\", \"credit_card\", false},\n\t\t{\"4624748233249780\", \"credit_card\", true},\n\t\t{\"4624748233349780\", \"credit_card\", false},\n\t\t{\"378282246310005\", \"credit_card\", true},\n\t\t{\"378282146310005\", \"credit_card\", false},\n\t\t{\"4624 7482 3324 9780\", \"credit_card\", true},\n\t\t{\"4624 7482 3324  9780\", \"credit_card\", false},\n\t\t{\"4624 7482 3324 978A\", \"credit_card\", false},\n\t\t{\"4624 7482 332\", \"credit_card\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.value, test.tag)\n\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d credit_card failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d credit_card failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"credit_card\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d credit_card failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestLuhnChecksumValidation(t *testing.T) {\n\ttestsUint := []struct {\n\t\tvalue    interface{} `validate:\"luhn_checksum\"` // the type is interface{} because the luhn_checksum works on both strings and numbers\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{uint64(586824160825533338), \"luhn_checksum\", true}, // credit card numbers are just special cases of numbers with luhn checksum\n\t\t{586824160825533338, \"luhn_checksum\", true},\n\t\t{\"586824160825533338\", \"luhn_checksum\", true},\n\t\t{uint64(586824160825533328), \"luhn_checksum\", false},\n\t\t{586824160825533328, \"luhn_checksum\", false},\n\t\t{\"586824160825533328\", \"luhn_checksum\", false},\n\t\t{10000000116, \"luhn_checksum\", true}, // but there may be shorter numbers (11 digits)\n\t\t{\"10000000116\", \"luhn_checksum\", true},\n\t\t{10000000117, \"luhn_checksum\", false},\n\t\t{\"10000000117\", \"luhn_checksum\", false},\n\t\t{uint64(12345678123456789011), \"luhn_checksum\", true}, // or longer numbers (19 digits)\n\t\t{\"12345678123456789011\", \"luhn_checksum\", true},\n\t\t{1, \"luhn_checksum\", false}, // single digits (checksum only) are not allowed\n\t\t{\"1\", \"luhn_checksum\", false},\n\t\t{-10, \"luhn_checksum\", false}, // negative ints are not allowed\n\t\t{\"abcdefghijklmnop\", \"luhn_checksum\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range testsUint {\n\t\terrs := validate.Var(test.value, test.tag)\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d luhn_checksum failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d luhn_checksum failed Error: %s\", i, errs)\n\t\t\t} else {\n\t\t\t\tval := getError(errs, \"\", \"\")\n\t\t\t\tif val.Tag() != \"luhn_checksum\" {\n\t\t\t\t\tt.Fatalf(\"Index: %d luhn_checksum failed Error: %s\", i, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestMultiOrOperatorGroup(t *testing.T) {\n\ttests := []struct {\n\t\tValue    int `validate:\"eq=1|gte=5,eq=1|lt=7\"`\n\t\texpected bool\n\t}{\n\t\t{1, true}, {2, false}, {5, true}, {6, true}, {8, false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Struct(test)\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d multi_group_of_OR_operators failed Error: %s\", i, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(\"Index: %d multi_group_of_OR_operators should have errs\", i)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestCronExpressionValidation(t *testing.T) {\n\ttests := []struct {\n\t\tvalue    string `validate:\"cron\"`\n\t\ttag      string\n\t\texpected bool\n\t}{\n\t\t{\"0 0 12 * * ?\", \"cron\", true},\n\t\t{\"0 15 10 ? * *\", \"cron\", true},\n\t\t{\"0 15 10 * * ?\", \"cron\", true},\n\t\t{\"0 15 10 * * ? 2005\", \"cron\", true},\n\t\t{\"0 15 10 ? * 6L\", \"cron\", true},\n\t\t{\"0 15 10 ? * 6L 2002-2005\", \"cron\", true},\n\t\t{\"*/20 * * * *\", \"cron\", true},\n\t\t{\"0 15 10 ? * MON-FRI\", \"cron\", true},\n\t\t{\"0 15 10 ? * 6#3\", \"cron\", true},\n\t\t{\"0 */15 * * *\", \"cron\", true},\n\t\t{\"wrong\", \"cron\", false},\n\t}\n\n\tvalidate := New()\n\n\tfor i, test := range tests {\n\t\terrs := validate.Var(test.value, test.tag)\n\t\tif test.expected {\n\t\t\tif !IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(`Index: %d cron \"%s\" failed Error: %s`, i, test.value, errs)\n\t\t\t}\n\t\t} else {\n\t\t\tif IsEqual(errs, nil) {\n\t\t\t\tt.Fatalf(`Index: %d cron \"%s\" should have errs`, i, test.value)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestNestedStructValidation(t *testing.T) {\n\tvalidator := New(WithRequiredStructEnabled())\n\n\tt.Run(\"required\", func(t *testing.T) {\n\t\ttype (\n\t\t\tvalue struct {\n\t\t\t\tField string\n\t\t\t}\n\t\t\ttopLevel struct {\n\t\t\t\tNested value `validate:\"required\"`\n\t\t\t}\n\t\t)\n\n\t\tvar validationErrs ValidationErrors\n\t\tif errs := validator.Struct(topLevel{}); errs != nil {\n\t\t\tvalidationErrs = errs.(ValidationErrors)\n\t\t}\n\n\t\tEqual(t, 1, len(validationErrs))\n\t\tAssertError(t, validationErrs, \"topLevel.Nested\", \"topLevel.Nested\", \"Nested\", \"Nested\", \"required\")\n\n\t\tEqual(t, validator.Struct(topLevel{value{\"potato\"}}), nil)\n\t})\n\n\tt.Run(\"omitempty\", func(t *testing.T) {\n\t\ttype (\n\t\t\tvalue struct {\n\t\t\t\tField string\n\t\t\t}\n\t\t\ttopLevel struct {\n\t\t\t\tNested value `validate:\"omitempty,required\"`\n\t\t\t}\n\t\t)\n\n\t\terrs := validator.Struct(topLevel{})\n\t\tEqual(t, errs, nil)\n\t})\n\n\tt.Run(\"excluded_if\", func(t *testing.T) {\n\t\ttype (\n\t\t\tvalue struct {\n\t\t\t\tField string\n\t\t\t}\n\t\t\ttopLevel struct {\n\t\t\t\tField  string\n\t\t\t\tNested value `validate:\"excluded_if=Field potato\"`\n\t\t\t}\n\t\t)\n\n\t\terrs := validator.Struct(topLevel{Field: \"test\", Nested: value{\"potato\"}})\n\t\tEqual(t, errs, nil)\n\n\t\terrs = validator.Struct(topLevel{Field: \"potato\"})\n\t\tEqual(t, errs, nil)\n\n\t\terrs = validator.Struct(topLevel{Field: \"potato\", Nested: value{\"potato\"}})\n\t\tAssertError(t, errs, \"topLevel.Nested\", \"topLevel.Nested\", \"Nested\", \"Nested\", \"excluded_if\")\n\t})\n\n\tt.Run(\"excluded_unless\", func(t *testing.T) {\n\t\ttype (\n\t\t\tvalue struct {\n\t\t\t\tField string\n\t\t\t}\n\t\t\ttopLevel struct {\n\t\t\t\tField  string\n\t\t\t\tNested value `validate:\"excluded_unless=Field potato\"`\n\t\t\t}\n\t\t)\n\n\t\terrs := validator.Struct(topLevel{Field: \"test\"})\n\t\tEqual(t, errs, nil)\n\n\t\terrs = validator.Struct(topLevel{Field: \"potato\", Nested: value{\"potato\"}})\n\t\tEqual(t, errs, nil)\n\n\t\terrs = validator.Struct(topLevel{Field: \"test\", Nested: value{\"potato\"}})\n\t\tAssertError(t, errs, \"topLevel.Nested\", \"topLevel.Nested\", \"Nested\", \"Nested\", \"excluded_unless\")\n\t})\n\n\tt.Run(\"nonComparableField\", func(t *testing.T) {\n\t\ttype (\n\t\t\tvalue struct {\n\t\t\t\tField []string\n\t\t\t}\n\t\t\ttopLevel struct {\n\t\t\t\tNested value `validate:\"required\"`\n\t\t\t}\n\t\t)\n\n\t\terrs := validator.Struct(topLevel{value{[]string{}}})\n\t\tEqual(t, errs, nil)\n\t})\n\n\ttype (\n\t\tveggyBasket struct {\n\t\t\tRoot   string\n\t\t\tSquash string `validate:\"required\"`\n\t\t}\n\t\ttestErr struct {\n\t\t\tpath string\n\t\t\ttag  string\n\t\t}\n\t\ttest struct {\n\t\t\tname  string\n\t\t\terr   testErr\n\t\t\tvalue veggyBasket\n\t\t}\n\t)\n\n\tif err := validator.RegisterValidation(\"veggy\", func(f FieldLevel) bool {\n\t\tv, ok := f.Field().Interface().(veggyBasket)\n\t\tif !ok || v.Root != \"potato\" {\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}); err != nil {\n\t\tt.Fatal(fmt.Errorf(\"failed to register potato tag: %w\", err))\n\t}\n\n\ttests := []test{\n\t\t{\n\t\t\tname:  \"valid\",\n\t\t\tvalue: veggyBasket{\"potato\", \"zucchini\"},\n\t\t}, {\n\t\t\tname:  \"failedCustomTag\",\n\t\t\tvalue: veggyBasket{\"zucchini\", \"potato\"},\n\t\t\terr:   testErr{\"topLevel.VeggyBasket\", \"veggy\"},\n\t\t}, {\n\t\t\tname:  \"failedInnerField\",\n\t\t\tvalue: veggyBasket{\"potato\", \"\"},\n\t\t\terr:   testErr{\"topLevel.VeggyBasket.Squash\", \"required\"},\n\t\t}, {\n\t\t\tname:  \"customTagFailurePriorityCheck\",\n\t\t\tvalue: veggyBasket{\"zucchini\", \"\"},\n\t\t\terr:   testErr{\"topLevel.VeggyBasket\", \"veggy\"},\n\t\t},\n\t}\n\n\tvar evaluateTest = func(tt test, errs error) {\n\t\tif tt.err != (testErr{}) && errs != nil {\n\t\t\tEqual(t, len(errs.(ValidationErrors)), 1)\n\n\t\t\tsegments := strings.Split(tt.err.path, \".\")\n\t\t\tfieldName := segments[len(segments)-1]\n\t\t\tAssertError(t, errs, tt.err.path, tt.err.path, fieldName, fieldName, tt.err.tag)\n\t\t}\n\n\t\tshouldFail := tt.err != (testErr{})\n\t\thasFailed := errs != nil\n\t\tif shouldFail != hasFailed {\n\t\t\tt.Fatalf(\"expected failure %v, got: %v with errs: %v\", shouldFail, hasFailed, errs)\n\t\t}\n\t}\n\n\tfor _, tt := range tests {\n\t\ttype topLevel struct {\n\t\t\tVeggyBasket veggyBasket `validate:\"veggy\"`\n\t\t}\n\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tevaluateTest(tt, validator.Struct(topLevel{tt.value}))\n\t\t})\n\t}\n\n\t// Also test on struct pointers\n\tfor _, tt := range tests {\n\t\ttype topLevel struct {\n\t\t\tVeggyBasket *veggyBasket `validate:\"veggy\"`\n\t\t}\n\n\t\tt.Run(tt.name+\"Ptr\", func(t *testing.T) {\n\t\t\tevaluateTest(tt, validator.Struct(topLevel{&tt.value}))\n\t\t})\n\t}\n}\n\nfunc TestTimeRequired(t *testing.T) {\n\tvalidate := New()\n\tvalidate.RegisterTagNameFunc(func(fld reflect.StructField) string {\n\t\tname := strings.SplitN(fld.Tag.Get(\"json\"), \",\", 2)[0]\n\n\t\tif name == \"-\" {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn name\n\t})\n\n\ttype TestTime struct {\n\t\tTime time.Time `validate:\"required\"`\n\t}\n\n\tvar testTime TestTime\n\n\terr := validate.Struct(&testTime)\n\tNotEqual(t, err, nil)\n\tAssertError(t, err.(ValidationErrors), \"TestTime.Time\", \"TestTime.Time\", \"Time\", \"Time\", \"required\")\n}\n\nfunc TestOmitNilAndRequired(t *testing.T) {\n\ttype (\n\t\tOmitEmpty struct {\n\t\t\tStr    string  `validate:\"omitempty,required,min=10\"`\n\t\t\tStrPtr *string `validate:\"omitempty,required,min=10\"`\n\t\t\tInner  *OmitEmpty\n\t\t}\n\t\tOmitNil struct {\n\t\t\tStr    string  `validate:\"omitnil,required,min=10\"`\n\t\t\tStrPtr *string `validate:\"omitnil,required,min=10\"`\n\t\t\tInner  *OmitNil\n\t\t}\n\t)\n\n\tvar (\n\t\tvalidate = New(WithRequiredStructEnabled())\n\t\tvalid    = \"this is the long string to pass the validation rule\"\n\t)\n\n\tt.Run(\"compare using valid data\", func(t *testing.T) {\n\t\terr1 := validate.Struct(OmitEmpty{Str: valid, StrPtr: &valid, Inner: &OmitEmpty{Str: valid, StrPtr: &valid}})\n\t\terr2 := validate.Struct(OmitNil{Str: valid, StrPtr: &valid, Inner: &OmitNil{Str: valid, StrPtr: &valid}})\n\n\t\tEqual(t, err1, nil)\n\t\tEqual(t, err2, nil)\n\t})\n\n\tt.Run(\"compare fully empty omitempty and omitnil\", func(t *testing.T) {\n\t\terr1 := validate.Struct(OmitEmpty{})\n\t\terr2 := validate.Struct(OmitNil{})\n\n\t\tEqual(t, err1, nil)\n\t\tAssertError(t, err2, \"OmitNil.Str\", \"OmitNil.Str\", \"Str\", \"Str\", \"required\")\n\t})\n\n\tt.Run(\"validate in deep\", func(t *testing.T) {\n\t\terr1 := validate.Struct(OmitEmpty{Str: valid, Inner: &OmitEmpty{}})\n\t\terr2 := validate.Struct(OmitNil{Str: valid, Inner: &OmitNil{}})\n\n\t\tEqual(t, err1, nil)\n\t\tAssertError(t, err2, \"OmitNil.Inner.Str\", \"OmitNil.Inner.Str\", \"Str\", \"Str\", \"required\")\n\t})\n}\n\nfunc TestPrivateFieldsStruct(t *testing.T) {\n\ttype tc struct {\n\t\tstct     interface{}\n\t\terrorNum int\n\t}\n\n\ttcs := []tc{\n\t\t{\n\t\t\tstct: &struct {\n\t\t\t\tf1 int8  `validate:\"required\"`\n\t\t\t\tf2 int16 `validate:\"required\"`\n\t\t\t\tf3 int32 `validate:\"required\"`\n\t\t\t\tf4 int64 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 4,\n\t\t},\n\t\t{\n\t\t\tstct: &struct {\n\t\t\t\tf1 uint8  `validate:\"required\"`\n\t\t\t\tf2 uint16 `validate:\"required\"`\n\t\t\t\tf3 uint32 `validate:\"required\"`\n\t\t\t\tf4 uint64 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 4,\n\t\t},\n\t\t{\n\t\t\tstct: &struct {\n\t\t\t\tf1 complex64  `validate:\"required\"`\n\t\t\t\tf2 complex128 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 2,\n\t\t},\n\t\t{\n\t\t\tstct: &struct {\n\t\t\t\tf1 float32 `validate:\"required\"`\n\t\t\t\tf2 float64 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 2,\n\t\t},\n\t\t{\n\t\t\tstct: struct {\n\t\t\t\tf1 int8  `validate:\"required\"`\n\t\t\t\tf2 int16 `validate:\"required\"`\n\t\t\t\tf3 int32 `validate:\"required\"`\n\t\t\t\tf4 int64 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 4,\n\t\t},\n\t\t{\n\t\t\tstct: struct {\n\t\t\t\tf1 uint8  `validate:\"required\"`\n\t\t\t\tf2 uint16 `validate:\"required\"`\n\t\t\t\tf3 uint32 `validate:\"required\"`\n\t\t\t\tf4 uint64 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 4,\n\t\t},\n\t\t{\n\t\t\tstct: struct {\n\t\t\t\tf1 complex64  `validate:\"required\"`\n\t\t\t\tf2 complex128 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 2,\n\t\t},\n\t\t{\n\t\t\tstct: struct {\n\t\t\t\tf1 float32 `validate:\"required\"`\n\t\t\t\tf2 float64 `validate:\"required\"`\n\t\t\t}{},\n\t\t\terrorNum: 2,\n\t\t},\n\t\t{\n\t\t\tstct: struct {\n\t\t\t\tf1 *int `validate:\"required\"`\n\t\t\t\tf2 struct {\n\t\t\t\t\tf3 int `validate:\"required\"`\n\t\t\t\t}\n\t\t\t}{},\n\t\t\terrorNum: 2,\n\t\t},\n\t\t{\n\t\t\tstct: &struct {\n\t\t\t\tf1 *int `validate:\"required\"`\n\t\t\t\tf2 struct {\n\t\t\t\t\tf3 int `validate:\"required\"`\n\t\t\t\t}\n\t\t\t}{},\n\t\t\terrorNum: 2,\n\t\t},\n\t}\n\n\tvalidate := New(WithPrivateFieldValidation())\n\n\tfor _, tc := range tcs {\n\t\terr := validate.Struct(tc.stct)\n\t\tNotEqual(t, err, nil)\n\n\t\terrs := err.(ValidationErrors)\n\t\tEqual(t, len(errs), tc.errorNum)\n\t}\n}\n"
        }
      ]
    }
  ]
}