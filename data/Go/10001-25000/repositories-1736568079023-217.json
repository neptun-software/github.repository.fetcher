{
  "metadata": {
    "timestamp": 1736568079023,
    "page": 217,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rs/zerolog",
      "stars": 10836,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.263671875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\ntmp\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n"
        },
        {
          "name": "CNAME",
          "type": "blob",
          "size": 0.009765625,
          "content": "zerolog.io"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.046875,
          "content": "MIT License\n\nCopyright (c) 2017 Olivier Poitrey\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 25.4853515625,
          "content": "# Zero Allocation JSON Logger\n\n[![godoc](http://img.shields.io/badge/godoc-reference-blue.svg?style=flat)](https://godoc.org/github.com/rs/zerolog) [![license](http://img.shields.io/badge/license-MIT-red.svg?style=flat)](https://raw.githubusercontent.com/rs/zerolog/master/LICENSE) [![Build Status](https://github.com/rs/zerolog/actions/workflows/test.yml/badge.svg)](https://github.com/rs/zerolog/actions/workflows/test.yml) [![Go Coverage](https://github.com/rs/zerolog/wiki/coverage.svg)](https://raw.githack.com/wiki/rs/zerolog/coverage.html)\n\nThe zerolog package provides a fast and simple logger dedicated to JSON output.\n\nZerolog's API is designed to provide both a great developer experience and stunning [performance](#benchmarks). Its unique chaining API allows zerolog to write JSON (or CBOR) log events by avoiding allocations and reflection.\n\nUber's [zap](https://godoc.org/go.uber.org/zap) library pioneered this approach. Zerolog is taking this concept to the next level with a simpler to use API and even better performance.\n\nTo keep the code base and the API simple, zerolog focuses on efficient structured logging only. Pretty logging on the console is made possible using the provided (but inefficient) [`zerolog.ConsoleWriter`](#pretty-logging).\n\n![Pretty Logging Image](pretty.png)\n\n## Who uses zerolog\n\nFind out [who uses zerolog](https://github.com/rs/zerolog/wiki/Who-uses-zerolog) and add your company / project to the list.\n\n## Features\n\n* [Blazing fast](#benchmarks)\n* [Low to zero allocation](#benchmarks)\n* [Leveled logging](#leveled-logging)\n* [Sampling](#log-sampling)\n* [Hooks](#hooks)\n* [Contextual fields](#contextual-logging)\n* [`context.Context` integration](#contextcontext-integration)\n* [Integration with `net/http`](#integration-with-nethttp)\n* [JSON and CBOR encoding formats](#binary-encoding)\n* [Pretty logging for development](#pretty-logging)\n* [Error Logging (with optional Stacktrace)](#error-logging)\n\n## Installation\n\n```bash\ngo get -u github.com/rs/zerolog/log\n```\n\n## Getting Started\n\n### Simple Logging Example\n\nFor simple logging, import the global logger package **github.com/rs/zerolog/log**\n\n```go\npackage main\n\nimport (\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    // UNIX Time is faster and smaller than most timestamps\n    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n    log.Print(\"hello world\")\n}\n\n// Output: {\"time\":1516134303,\"level\":\"debug\",\"message\":\"hello world\"}\n```\n> Note: By default log writes to `os.Stderr`\n> Note: The default log level for `log.Print` is *trace*\n\n### Contextual Logging\n\n**zerolog** allows data to be added to log messages in the form of key:value pairs. The data added to the message adds \"context\" about the log event that can be critical for debugging as well as myriad other purposes. An example of this is below:\n\n```go\npackage main\n\nimport (\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n    log.Debug().\n        Str(\"Scale\", \"833 cents\").\n        Float64(\"Interval\", 833.09).\n        Msg(\"Fibonacci is everywhere\")\n    \n    log.Debug().\n        Str(\"Name\", \"Tom\").\n        Send()\n}\n\n// Output: {\"level\":\"debug\",\"Scale\":\"833 cents\",\"Interval\":833.09,\"time\":1562212768,\"message\":\"Fibonacci is everywhere\"}\n// Output: {\"level\":\"debug\",\"Name\":\"Tom\",\"time\":1562212768}\n```\n\n> You'll note in the above example that when adding contextual fields, the fields are strongly typed. You can find the full list of supported fields [here](#standard-types)\n\n### Leveled Logging\n\n#### Simple Leveled Logging Example\n\n```go\npackage main\n\nimport (\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n    log.Info().Msg(\"hello world\")\n}\n\n// Output: {\"time\":1516134303,\"level\":\"info\",\"message\":\"hello world\"}\n```\n\n> It is very important to note that when using the **zerolog** chaining API, as shown above (`log.Info().Msg(\"hello world\"`), the chain must have either the `Msg` or `Msgf` method call. If you forget to add either of these, the log will not occur and there is no compile time error to alert you of this.\n\n**zerolog** allows for logging at the following levels (from highest to lowest):\n\n* panic (`zerolog.PanicLevel`, 5)\n* fatal (`zerolog.FatalLevel`, 4)\n* error (`zerolog.ErrorLevel`, 3)\n* warn (`zerolog.WarnLevel`, 2)\n* info (`zerolog.InfoLevel`, 1)\n* debug (`zerolog.DebugLevel`, 0)\n* trace (`zerolog.TraceLevel`, -1)\n\nYou can set the Global logging level to any of these options using the `SetGlobalLevel` function in the zerolog package, passing in one of the given constants above, e.g. `zerolog.InfoLevel` would be the \"info\" level.  Whichever level is chosen, all logs with a level greater than or equal to that level will be written. To turn off logging entirely, pass the `zerolog.Disabled` constant.\n\n#### Setting Global Log Level\n\nThis example uses command-line flags to demonstrate various outputs depending on the chosen log level.\n\n```go\npackage main\n\nimport (\n    \"flag\"\n\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n    debug := flag.Bool(\"debug\", false, \"sets log level to debug\")\n\n    flag.Parse()\n\n    // Default level for this example is info, unless debug flag is present\n    zerolog.SetGlobalLevel(zerolog.InfoLevel)\n    if *debug {\n        zerolog.SetGlobalLevel(zerolog.DebugLevel)\n    }\n\n    log.Debug().Msg(\"This message appears only when log level set to Debug\")\n    log.Info().Msg(\"This message appears when log level set to Debug or Info\")\n\n    if e := log.Debug(); e.Enabled() {\n        // Compute log output only if enabled.\n        value := \"bar\"\n        e.Str(\"foo\", value).Msg(\"some debug message\")\n    }\n}\n```\n\nInfo Output (no flag)\n\n```bash\n$ ./logLevelExample\n{\"time\":1516387492,\"level\":\"info\",\"message\":\"This message appears when log level set to Debug or Info\"}\n```\n\nDebug Output (debug flag set)\n\n```bash\n$ ./logLevelExample -debug\n{\"time\":1516387573,\"level\":\"debug\",\"message\":\"This message appears only when log level set to Debug\"}\n{\"time\":1516387573,\"level\":\"info\",\"message\":\"This message appears when log level set to Debug or Info\"}\n{\"time\":1516387573,\"level\":\"debug\",\"foo\":\"bar\",\"message\":\"some debug message\"}\n```\n\n#### Logging without Level or Message\n\nYou may choose to log without a specific level by using the `Log` method. You may also write without a message by setting an empty string in the `msg string` parameter of the `Msg` method. Both are demonstrated in the example below.\n\n```go\npackage main\n\nimport (\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n    log.Log().\n        Str(\"foo\", \"bar\").\n        Msg(\"\")\n}\n\n// Output: {\"time\":1494567715,\"foo\":\"bar\"}\n```\n\n### Error Logging\n\nYou can log errors using the `Err` method\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\n\t\"github.com/rs/zerolog\"\n\t\"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n\tzerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n\terr := errors.New(\"seems we have an error here\")\n\tlog.Error().Err(err).Msg(\"\")\n}\n\n// Output: {\"level\":\"error\",\"error\":\"seems we have an error here\",\"time\":1609085256}\n```\n\n> The default field name for errors is `error`, you can change this by setting `zerolog.ErrorFieldName` to meet your needs.\n\n#### Error Logging with Stacktrace\n\nUsing `github.com/pkg/errors`, you can add a formatted stacktrace to your errors. \n\n```go\npackage main\n\nimport (\n\t\"github.com/pkg/errors\"\n\t\"github.com/rs/zerolog/pkgerrors\"\n\n\t\"github.com/rs/zerolog\"\n\t\"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n\tzerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\tzerolog.ErrorStackMarshaler = pkgerrors.MarshalStack\n\n\terr := outer()\n\tlog.Error().Stack().Err(err).Msg(\"\")\n}\n\nfunc inner() error {\n\treturn errors.New(\"seems we have an error here\")\n}\n\nfunc middle() error {\n\terr := inner()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc outer() error {\n\terr := middle()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Output: {\"level\":\"error\",\"stack\":[{\"func\":\"inner\",\"line\":\"20\",\"source\":\"errors.go\"},{\"func\":\"middle\",\"line\":\"24\",\"source\":\"errors.go\"},{\"func\":\"outer\",\"line\":\"32\",\"source\":\"errors.go\"},{\"func\":\"main\",\"line\":\"15\",\"source\":\"errors.go\"},{\"func\":\"main\",\"line\":\"204\",\"source\":\"proc.go\"},{\"func\":\"goexit\",\"line\":\"1374\",\"source\":\"asm_amd64.s\"}],\"error\":\"seems we have an error here\",\"time\":1609086683}\n```\n\n> zerolog.ErrorStackMarshaler must be set in order for the stack to output anything.\n\n#### Logging Fatal Messages\n\n```go\npackage main\n\nimport (\n    \"errors\"\n\n    \"github.com/rs/zerolog\"\n    \"github.com/rs/zerolog/log\"\n)\n\nfunc main() {\n    err := errors.New(\"A repo man spends his life getting into tense situations\")\n    service := \"myservice\"\n\n    zerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n    log.Fatal().\n        Err(err).\n        Str(\"service\", service).\n        Msgf(\"Cannot start %s\", service)\n}\n\n// Output: {\"time\":1516133263,\"level\":\"fatal\",\"error\":\"A repo man spends his life getting into tense situations\",\"service\":\"myservice\",\"message\":\"Cannot start myservice\"}\n//         exit status 1\n```\n\n> NOTE: Using `Msgf` generates one allocation even when the logger is disabled.\n\n\n### Create logger instance to manage different outputs\n\n```go\nlogger := zerolog.New(os.Stderr).With().Timestamp().Logger()\n\nlogger.Info().Str(\"foo\", \"bar\").Msg(\"hello world\")\n\n// Output: {\"level\":\"info\",\"time\":1494567715,\"message\":\"hello world\",\"foo\":\"bar\"}\n```\n\n### Sub-loggers let you chain loggers with additional context\n\n```go\nsublogger := log.With().\n                 Str(\"component\", \"foo\").\n                 Logger()\nsublogger.Info().Msg(\"hello world\")\n\n// Output: {\"level\":\"info\",\"time\":1494567715,\"message\":\"hello world\",\"component\":\"foo\"}\n```\n\n### Pretty logging\n\nTo log a human-friendly, colorized output, use `zerolog.ConsoleWriter`:\n\n```go\nlog.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})\n\nlog.Info().Str(\"foo\", \"bar\").Msg(\"Hello world\")\n\n// Output: 3:04PM INF Hello World foo=bar\n```\n\nTo customize the configuration and formatting:\n\n```go\noutput := zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339}\noutput.FormatLevel = func(i interface{}) string {\n    return strings.ToUpper(fmt.Sprintf(\"| %-6s|\", i))\n}\noutput.FormatMessage = func(i interface{}) string {\n    return fmt.Sprintf(\"***%s****\", i)\n}\noutput.FormatFieldName = func(i interface{}) string {\n    return fmt.Sprintf(\"%s:\", i)\n}\noutput.FormatFieldValue = func(i interface{}) string {\n    return strings.ToUpper(fmt.Sprintf(\"%s\", i))\n}\n\nlog := zerolog.New(output).With().Timestamp().Logger()\n\nlog.Info().Str(\"foo\", \"bar\").Msg(\"Hello World\")\n\n// Output: 2006-01-02T15:04:05Z07:00 | INFO  | ***Hello World**** foo:BAR\n```\n\nTo use custom advanced formatting:\n\n```go\noutput := zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true,\n    PartsOrder:    []string{\"level\", \"one\", \"two\", \"three\", \"message\"},\n    FieldsExclude: []string{\"one\", \"two\", \"three\"}}\noutput.FormatLevel = func(i interface{}) string { return strings.ToUpper(fmt.Sprintf(\"%-6s\", i)) }\noutput.FormatFieldName = func(i interface{}) string { return fmt.Sprintf(\"%s:\", i) }\noutput.FormatPartValueByName = func(i interface{}, s string) string {\n    var ret string\n    switch s {\n    case \"one\":\n        ret = strings.ToUpper(fmt.Sprintf(\"%s\", i))\n    case \"two\":\n        ret = strings.ToLower(fmt.Sprintf(\"%s\", i))\n    case \"three\":\n        ret = strings.ToLower(fmt.Sprintf(\"(%s)\", i))\n    }\n    return ret\n}\nlog := zerolog.New(output)\n\nlog.Info().Str(\"foo\", \"bar\").\n    Str(\"two\", \"TEST_TWO\").\n    Str(\"one\", \"test_one\").\n    Str(\"three\", \"test_three\").\n    Msg(\"Hello World\")\n    \n// Output: INFO   TEST_ONE test_two (test_three) Hello World foo:bar\n```\n\n### Sub dictionary\n\n```go\nlog.Info().\n    Str(\"foo\", \"bar\").\n    Dict(\"dict\", zerolog.Dict().\n        Str(\"bar\", \"baz\").\n        Int(\"n\", 1),\n    ).Msg(\"hello world\")\n\n// Output: {\"level\":\"info\",\"time\":1494567715,\"foo\":\"bar\",\"dict\":{\"bar\":\"baz\",\"n\":1},\"message\":\"hello world\"}\n```\n\n### Customize automatic field names\n\n```go\nzerolog.TimestampFieldName = \"t\"\nzerolog.LevelFieldName = \"l\"\nzerolog.MessageFieldName = \"m\"\n\nlog.Info().Msg(\"hello world\")\n\n// Output: {\"l\":\"info\",\"t\":1494567715,\"m\":\"hello world\"}\n```\n\n### Add contextual fields to the global logger\n\n```go\nlog.Logger = log.With().Str(\"foo\", \"bar\").Logger()\n```\n\n### Add file and line number to log\n\nEquivalent of `Llongfile`:\n\n```go\nlog.Logger = log.With().Caller().Logger()\nlog.Info().Msg(\"hello world\")\n\n// Output: {\"level\": \"info\", \"message\": \"hello world\", \"caller\": \"/go/src/your_project/some_file:21\"}\n```\n\nEquivalent of `Lshortfile`:\n\n```go\nzerolog.CallerMarshalFunc = func(pc uintptr, file string, line int) string {\n    return filepath.Base(file) + \":\" + strconv.Itoa(line)\n}\nlog.Logger = log.With().Caller().Logger()\nlog.Info().Msg(\"hello world\")\n\n// Output: {\"level\": \"info\", \"message\": \"hello world\", \"caller\": \"some_file:21\"}\n```\n\n### Thread-safe, lock-free, non-blocking writer\n\nIf your writer might be slow or not thread-safe and you need your log producers to never get slowed down by a slow writer, you can use a `diode.Writer` as follows:\n\n```go\nwr := diode.NewWriter(os.Stdout, 1000, 10*time.Millisecond, func(missed int) {\n\t\tfmt.Printf(\"Logger Dropped %d messages\", missed)\n\t})\nlog := zerolog.New(wr)\nlog.Print(\"test\")\n```\n\nYou will need to install `code.cloudfoundry.org/go-diodes` to use this feature.\n\n### Log Sampling\n\n```go\nsampled := log.Sample(&zerolog.BasicSampler{N: 10})\nsampled.Info().Msg(\"will be logged every 10 messages\")\n\n// Output: {\"time\":1494567715,\"level\":\"info\",\"message\":\"will be logged every 10 messages\"}\n```\n\nMore advanced sampling:\n\n```go\n// Will let 5 debug messages per period of 1 second.\n// Over 5 debug message, 1 every 100 debug messages are logged.\n// Other levels are not sampled.\nsampled := log.Sample(zerolog.LevelSampler{\n    DebugSampler: &zerolog.BurstSampler{\n        Burst: 5,\n        Period: 1*time.Second,\n        NextSampler: &zerolog.BasicSampler{N: 100},\n    },\n})\nsampled.Debug().Msg(\"hello world\")\n\n// Output: {\"time\":1494567715,\"level\":\"debug\",\"message\":\"hello world\"}\n```\n\n### Hooks\n\n```go\ntype SeverityHook struct{}\n\nfunc (h SeverityHook) Run(e *zerolog.Event, level zerolog.Level, msg string) {\n    if level != zerolog.NoLevel {\n        e.Str(\"severity\", level.String())\n    }\n}\n\nhooked := log.Hook(SeverityHook{})\nhooked.Warn().Msg(\"\")\n\n// Output: {\"level\":\"warn\",\"severity\":\"warn\"}\n```\n\n### Pass a sub-logger by context\n\n```go\nctx := log.With().Str(\"component\", \"module\").Logger().WithContext(ctx)\n\nlog.Ctx(ctx).Info().Msg(\"hello world\")\n\n// Output: {\"component\":\"module\",\"level\":\"info\",\"message\":\"hello world\"}\n```\n\n### Set as standard logger output\n\n```go\nlog := zerolog.New(os.Stdout).With().\n    Str(\"foo\", \"bar\").\n    Logger()\n\nstdlog.SetFlags(0)\nstdlog.SetOutput(log)\n\nstdlog.Print(\"hello world\")\n\n// Output: {\"foo\":\"bar\",\"message\":\"hello world\"}\n```\n\n### context.Context integration\n\nGo contexts are commonly passed throughout Go code, and this can help you pass\nyour Logger into places it might otherwise be hard to inject.  The `Logger`\ninstance may be attached to Go context (`context.Context`) using\n`Logger.WithContext(ctx)` and extracted from it using `zerolog.Ctx(ctx)`.\nFor example:\n\n```go\nfunc f() {\n    logger := zerolog.New(os.Stdout)\n    ctx := context.Background()\n\n    // Attach the Logger to the context.Context\n    ctx = logger.WithContext(ctx)\n    someFunc(ctx)\n}\n\nfunc someFunc(ctx context.Context) {\n    // Get Logger from the go Context. if it's nil, then\n    // `zerolog.DefaultContextLogger` is returned, if\n    // `DefaultContextLogger` is nil, then a disabled logger is returned.\n    logger := zerolog.Ctx(ctx)\n    logger.Info().Msg(\"Hello\")\n}\n```\n\nA second form of `context.Context` integration allows you to pass the current\ncontext.Context into the logged event, and retrieve it from hooks.  This can be\nuseful to log trace and span IDs or other information stored in the go context,\nand facilitates the unification of logging and tracing in some systems:\n\n```go\ntype TracingHook struct{}\n\nfunc (h TracingHook) Run(e *zerolog.Event, level zerolog.Level, msg string) {\n    ctx := e.GetCtx()\n    spanId := getSpanIdFromContext(ctx) // as per your tracing framework\n    e.Str(\"span-id\", spanId)\n}\n\nfunc f() {\n    // Setup the logger\n    logger := zerolog.New(os.Stdout)\n    logger = logger.Hook(TracingHook{})\n\n    ctx := context.Background()\n    // Use the Ctx function to make the context available to the hook\n    logger.Info().Ctx(ctx).Msg(\"Hello\")\n}\n```\n\n### Integration with `net/http`\n\nThe `github.com/rs/zerolog/hlog` package provides some helpers to integrate zerolog with `http.Handler`.\n\nIn this example we use [alice](https://github.com/justinas/alice) to install logger for better readability.\n\n```go\nlog := zerolog.New(os.Stdout).With().\n    Timestamp().\n    Str(\"role\", \"my-service\").\n    Str(\"host\", host).\n    Logger()\n\nc := alice.New()\n\n// Install the logger handler with default output on the console\nc = c.Append(hlog.NewHandler(log))\n\n// Install some provided extra handler to set some request's context fields.\n// Thanks to that handler, all our logs will come with some prepopulated fields.\nc = c.Append(hlog.AccessHandler(func(r *http.Request, status, size int, duration time.Duration) {\n    hlog.FromRequest(r).Info().\n        Str(\"method\", r.Method).\n        Stringer(\"url\", r.URL).\n        Int(\"status\", status).\n        Int(\"size\", size).\n        Dur(\"duration\", duration).\n        Msg(\"\")\n}))\nc = c.Append(hlog.RemoteAddrHandler(\"ip\"))\nc = c.Append(hlog.UserAgentHandler(\"user_agent\"))\nc = c.Append(hlog.RefererHandler(\"referer\"))\nc = c.Append(hlog.RequestIDHandler(\"req_id\", \"Request-Id\"))\n\n// Here is your final handler\nh := c.Then(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    // Get the logger from the request's context. You can safely assume it\n    // will be always there: if the handler is removed, hlog.FromRequest\n    // will return a no-op logger.\n    hlog.FromRequest(r).Info().\n        Str(\"user\", \"current user\").\n        Str(\"status\", \"ok\").\n        Msg(\"Something happened\")\n\n    // Output: {\"level\":\"info\",\"time\":\"2001-02-03T04:05:06Z\",\"role\":\"my-service\",\"host\":\"local-hostname\",\"req_id\":\"b4g0l5t6tfid6dtrapu0\",\"user\":\"current user\",\"status\":\"ok\",\"message\":\"Something happened\"}\n}))\nhttp.Handle(\"/\", h)\n\nif err := http.ListenAndServe(\":8080\", nil); err != nil {\n    log.Fatal().Err(err).Msg(\"Startup failed\")\n}\n```\n\n## Multiple Log Output\n`zerolog.MultiLevelWriter` may be used to send the log message to multiple outputs. \nIn this example, we send the log message to both `os.Stdout` and the in-built ConsoleWriter.\n```go\nfunc main() {\n\tconsoleWriter := zerolog.ConsoleWriter{Out: os.Stdout}\n\n\tmulti := zerolog.MultiLevelWriter(consoleWriter, os.Stdout)\n\n\tlogger := zerolog.New(multi).With().Timestamp().Logger()\n\n\tlogger.Info().Msg(\"Hello World!\")\n}\n\n// Output (Line 1: Console; Line 2: Stdout)\n// 12:36PM INF Hello World!\n// {\"level\":\"info\",\"time\":\"2019-11-07T12:36:38+03:00\",\"message\":\"Hello World!\"}\n```\n\n## Global Settings\n\nSome settings can be changed and will be applied to all loggers:\n\n* `log.Logger`: You can set this value to customize the global logger (the one used by package level methods).\n* `zerolog.SetGlobalLevel`: Can raise the minimum level of all loggers. Call this with `zerolog.Disabled` to disable logging altogether (quiet mode).\n* `zerolog.DisableSampling`: If argument is `true`, all sampled loggers will stop sampling and issue 100% of their log events.\n* `zerolog.TimestampFieldName`: Can be set to customize `Timestamp` field name.\n* `zerolog.LevelFieldName`: Can be set to customize level field name.\n* `zerolog.MessageFieldName`: Can be set to customize message field name.\n* `zerolog.ErrorFieldName`: Can be set to customize `Err` field name.\n* `zerolog.TimeFieldFormat`: Can be set to customize `Time` field value formatting. If set with `zerolog.TimeFormatUnix`, `zerolog.TimeFormatUnixMs` or `zerolog.TimeFormatUnixMicro`, times are formatted as UNIX timestamp.\n* `zerolog.DurationFieldUnit`: Can be set to customize the unit for time.Duration type fields added by `Dur` (default: `time.Millisecond`).\n* `zerolog.DurationFieldInteger`: If set to `true`, `Dur` fields are formatted as integers instead of floats (default: `false`). \n* `zerolog.ErrorHandler`: Called whenever zerolog fails to write an event on its output. If not set, an error is printed on the stderr. This handler must be thread safe and non-blocking.\n* `zerolog.FloatingPointPrecision`: If set to a value other than -1, controls the number\nof digits when formatting float numbers in JSON. See\n[strconv.FormatFloat](https://pkg.go.dev/strconv#FormatFloat)\nfor more details.\n\n## Field Types\n\n### Standard Types\n\n* `Str`\n* `Bool`\n* `Int`, `Int8`, `Int16`, `Int32`, `Int64`\n* `Uint`, `Uint8`, `Uint16`, `Uint32`, `Uint64`\n* `Float32`, `Float64`\n\n### Advanced Fields\n\n* `Err`: Takes an `error` and renders it as a string using the `zerolog.ErrorFieldName` field name.\n* `Func`: Run a `func` only if the level is enabled.\n* `Timestamp`: Inserts a timestamp field with `zerolog.TimestampFieldName` field name, formatted using `zerolog.TimeFieldFormat`.\n* `Time`: Adds a field with time formatted with `zerolog.TimeFieldFormat`.\n* `Dur`: Adds a field with `time.Duration`.\n* `Dict`: Adds a sub-key/value as a field of the event.\n* `RawJSON`: Adds a field with an already encoded JSON (`[]byte`)\n* `Hex`: Adds a field with value formatted as a hexadecimal string (`[]byte`)\n* `Interface`: Uses reflection to marshal the type.\n\nMost fields are also available in the slice format (`Strs` for `[]string`, `Errs` for `[]error` etc.)\n\n## Binary Encoding\n\nIn addition to the default JSON encoding, `zerolog` can produce binary logs using [CBOR](https://cbor.io) encoding. The choice of encoding can be decided at compile time using the build tag `binary_log` as follows:\n\n```bash\ngo build -tags binary_log .\n```\n\nTo Decode binary encoded log files you can use any CBOR decoder. One has been tested to work\nwith zerolog library is [CSD](https://github.com/toravir/csd/).\n\n## Related Projects\n\n* [grpc-zerolog](https://github.com/cheapRoc/grpc-zerolog): Implementation of `grpclog.LoggerV2` interface using `zerolog`\n* [overlog](https://github.com/Trendyol/overlog): Implementation of `Mapped Diagnostic Context` interface using `zerolog`\n* [zerologr](https://github.com/go-logr/zerologr): Implementation of `logr.LogSink` interface using `zerolog`\n\n## Benchmarks\n\nSee [logbench](http://bench.zerolog.io/) for more comprehensive and up-to-date benchmarks.\n\nAll operations are allocation free (those numbers *include* JSON encoding):\n\n```text\nBenchmarkLogEmpty-8        100000000    19.1 ns/op     0 B/op       0 allocs/op\nBenchmarkDisabled-8        500000000    4.07 ns/op     0 B/op       0 allocs/op\nBenchmarkInfo-8            30000000     42.5 ns/op     0 B/op       0 allocs/op\nBenchmarkContextFields-8   30000000     44.9 ns/op     0 B/op       0 allocs/op\nBenchmarkLogFields-8       10000000     184 ns/op      0 B/op       0 allocs/op\n```\n\nThere are a few Go logging benchmarks and comparisons that include zerolog.\n\n* [imkira/go-loggers-bench](https://github.com/imkira/go-loggers-bench)\n* [uber-common/zap](https://github.com/uber-go/zap#performance)\n\nUsing Uber's zap comparison benchmark:\n\nLog a message and 10 fields:\n\n| Library | Time | Bytes Allocated | Objects Allocated |\n| :--- | :---: | :---: | :---: |\n| zerolog | 767 ns/op | 552 B/op | 6 allocs/op |\n| :zap: zap | 848 ns/op | 704 B/op | 2 allocs/op |\n| :zap: zap (sugared) | 1363 ns/op | 1610 B/op | 20 allocs/op |\n| go-kit | 3614 ns/op | 2895 B/op | 66 allocs/op |\n| lion | 5392 ns/op | 5807 B/op | 63 allocs/op |\n| logrus | 5661 ns/op | 6092 B/op | 78 allocs/op |\n| apex/log | 15332 ns/op | 3832 B/op | 65 allocs/op |\n| log15 | 20657 ns/op | 5632 B/op | 93 allocs/op |\n\nLog a message with a logger that already has 10 fields of context:\n\n| Library | Time | Bytes Allocated | Objects Allocated |\n| :--- | :---: | :---: | :---: |\n| zerolog | 52 ns/op | 0 B/op | 0 allocs/op |\n| :zap: zap | 283 ns/op | 0 B/op | 0 allocs/op |\n| :zap: zap (sugared) | 337 ns/op | 80 B/op | 2 allocs/op |\n| lion | 2702 ns/op | 4074 B/op | 38 allocs/op |\n| go-kit | 3378 ns/op | 3046 B/op | 52 allocs/op |\n| logrus | 4309 ns/op | 4564 B/op | 63 allocs/op |\n| apex/log | 13456 ns/op | 2898 B/op | 51 allocs/op |\n| log15 | 14179 ns/op | 2642 B/op | 44 allocs/op |\n\nLog a static string, without any context or `printf`-style templating:\n\n| Library | Time | Bytes Allocated | Objects Allocated |\n| :--- | :---: | :---: | :---: |\n| zerolog | 50 ns/op | 0 B/op | 0 allocs/op |\n| :zap: zap | 236 ns/op | 0 B/op | 0 allocs/op |\n| standard library | 453 ns/op | 80 B/op | 2 allocs/op |\n| :zap: zap (sugared) | 337 ns/op | 80 B/op | 2 allocs/op |\n| go-kit | 508 ns/op | 656 B/op | 13 allocs/op |\n| lion | 771 ns/op | 1224 B/op | 10 allocs/op |\n| logrus | 1244 ns/op | 1505 B/op | 27 allocs/op |\n| apex/log | 2751 ns/op | 584 B/op | 11 allocs/op |\n| log15 | 5181 ns/op | 1592 B/op | 26 allocs/op |\n\n## Caveats\n\n### Field duplication\n\nNote that zerolog does no de-duplication of fields. Using the same key multiple times creates multiple keys in final JSON:\n\n```go\nlogger := zerolog.New(os.Stderr).With().Timestamp().Logger()\nlogger.Info().\n       Timestamp().\n       Msg(\"dup\")\n// Output: {\"level\":\"info\",\"time\":1494567715,\"time\":1494567715,\"message\":\"dup\"}\n```\n\nIn this case, many consumers will take the last value, but this is not guaranteed; check yours if in doubt.\n\n### Concurrency safety\n\nBe careful when calling UpdateContext. It is not concurrency safe. Use the With method to create a child logger:\n\n```go\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    // Create a child logger for concurrency safety\n    logger := log.Logger.With().Logger()\n\n    // Add context fields, for example User-Agent from HTTP headers\n    logger.UpdateContext(func(c zerolog.Context) zerolog.Context {\n        ...\n    })\n}\n```\n"
        },
        {
          "name": "_config.yml",
          "type": "blob",
          "size": 0.0263671875,
          "content": "remote_theme: rs/gh-readme\n"
        },
        {
          "name": "array.go",
          "type": "blob",
          "size": 6.1142578125,
          "content": "package zerolog\n\nimport (\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar arrayPool = &sync.Pool{\n\tNew: func() interface{} {\n\t\treturn &Array{\n\t\t\tbuf: make([]byte, 0, 500),\n\t\t}\n\t},\n}\n\n// Array is used to prepopulate an array of items\n// which can be re-used to add to log messages.\ntype Array struct {\n\tbuf []byte\n}\n\nfunc putArray(a *Array) {\n\t// Proper usage of a sync.Pool requires each entry to have approximately\n\t// the same memory cost. To obtain this property when the stored type\n\t// contains a variably-sized buffer, we add a hard limit on the maximum buffer\n\t// to place back in the pool.\n\t//\n\t// See https://golang.org/issue/23199\n\tconst maxSize = 1 << 16 // 64KiB\n\tif cap(a.buf) > maxSize {\n\t\treturn\n\t}\n\tarrayPool.Put(a)\n}\n\n// Arr creates an array to be added to an Event or Context.\nfunc Arr() *Array {\n\ta := arrayPool.Get().(*Array)\n\ta.buf = a.buf[:0]\n\treturn a\n}\n\n// MarshalZerologArray method here is no-op - since data is\n// already in the needed format.\nfunc (*Array) MarshalZerologArray(*Array) {\n}\n\nfunc (a *Array) write(dst []byte) []byte {\n\tdst = enc.AppendArrayStart(dst)\n\tif len(a.buf) > 0 {\n\t\tdst = append(dst, a.buf...)\n\t}\n\tdst = enc.AppendArrayEnd(dst)\n\tputArray(a)\n\treturn dst\n}\n\n// Object marshals an object that implement the LogObjectMarshaler\n// interface and appends it to the array.\nfunc (a *Array) Object(obj LogObjectMarshaler) *Array {\n\te := Dict()\n\tobj.MarshalZerologObject(e)\n\te.buf = enc.AppendEndMarker(e.buf)\n\ta.buf = append(enc.AppendArrayDelim(a.buf), e.buf...)\n\tputEvent(e)\n\treturn a\n}\n\n// Str appends the val as a string to the array.\nfunc (a *Array) Str(val string) *Array {\n\ta.buf = enc.AppendString(enc.AppendArrayDelim(a.buf), val)\n\treturn a\n}\n\n// Bytes appends the val as a string to the array.\nfunc (a *Array) Bytes(val []byte) *Array {\n\ta.buf = enc.AppendBytes(enc.AppendArrayDelim(a.buf), val)\n\treturn a\n}\n\n// Hex appends the val as a hex string to the array.\nfunc (a *Array) Hex(val []byte) *Array {\n\ta.buf = enc.AppendHex(enc.AppendArrayDelim(a.buf), val)\n\treturn a\n}\n\n// RawJSON adds already encoded JSON to the array.\nfunc (a *Array) RawJSON(val []byte) *Array {\n\ta.buf = appendJSON(enc.AppendArrayDelim(a.buf), val)\n\treturn a\n}\n\n// Err serializes and appends the err to the array.\nfunc (a *Array) Err(err error) *Array {\n\tswitch m := ErrorMarshalFunc(err).(type) {\n\tcase LogObjectMarshaler:\n\t\te := newEvent(nil, 0)\n\t\te.buf = e.buf[:0]\n\t\te.appendObject(m)\n\t\ta.buf = append(enc.AppendArrayDelim(a.buf), e.buf...)\n\t\tputEvent(e)\n\tcase error:\n\t\tif m == nil || isNilValue(m) {\n\t\t\ta.buf = enc.AppendNil(enc.AppendArrayDelim(a.buf))\n\t\t} else {\n\t\t\ta.buf = enc.AppendString(enc.AppendArrayDelim(a.buf), m.Error())\n\t\t}\n\tcase string:\n\t\ta.buf = enc.AppendString(enc.AppendArrayDelim(a.buf), m)\n\tdefault:\n\t\ta.buf = enc.AppendInterface(enc.AppendArrayDelim(a.buf), m)\n\t}\n\n\treturn a\n}\n\n// Bool appends the val as a bool to the array.\nfunc (a *Array) Bool(b bool) *Array {\n\ta.buf = enc.AppendBool(enc.AppendArrayDelim(a.buf), b)\n\treturn a\n}\n\n// Int appends i as a int to the array.\nfunc (a *Array) Int(i int) *Array {\n\ta.buf = enc.AppendInt(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Int8 appends i as a int8 to the array.\nfunc (a *Array) Int8(i int8) *Array {\n\ta.buf = enc.AppendInt8(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Int16 appends i as a int16 to the array.\nfunc (a *Array) Int16(i int16) *Array {\n\ta.buf = enc.AppendInt16(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Int32 appends i as a int32 to the array.\nfunc (a *Array) Int32(i int32) *Array {\n\ta.buf = enc.AppendInt32(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Int64 appends i as a int64 to the array.\nfunc (a *Array) Int64(i int64) *Array {\n\ta.buf = enc.AppendInt64(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Uint appends i as a uint to the array.\nfunc (a *Array) Uint(i uint) *Array {\n\ta.buf = enc.AppendUint(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Uint8 appends i as a uint8 to the array.\nfunc (a *Array) Uint8(i uint8) *Array {\n\ta.buf = enc.AppendUint8(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Uint16 appends i as a uint16 to the array.\nfunc (a *Array) Uint16(i uint16) *Array {\n\ta.buf = enc.AppendUint16(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Uint32 appends i as a uint32 to the array.\nfunc (a *Array) Uint32(i uint32) *Array {\n\ta.buf = enc.AppendUint32(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Uint64 appends i as a uint64 to the array.\nfunc (a *Array) Uint64(i uint64) *Array {\n\ta.buf = enc.AppendUint64(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// Float32 appends f as a float32 to the array.\nfunc (a *Array) Float32(f float32) *Array {\n\ta.buf = enc.AppendFloat32(enc.AppendArrayDelim(a.buf), f, FloatingPointPrecision)\n\treturn a\n}\n\n// Float64 appends f as a float64 to the array.\nfunc (a *Array) Float64(f float64) *Array {\n\ta.buf = enc.AppendFloat64(enc.AppendArrayDelim(a.buf), f, FloatingPointPrecision)\n\treturn a\n}\n\n// Time appends t formatted as string using zerolog.TimeFieldFormat.\nfunc (a *Array) Time(t time.Time) *Array {\n\ta.buf = enc.AppendTime(enc.AppendArrayDelim(a.buf), t, TimeFieldFormat)\n\treturn a\n}\n\n// Dur appends d to the array.\nfunc (a *Array) Dur(d time.Duration) *Array {\n\ta.buf = enc.AppendDuration(enc.AppendArrayDelim(a.buf), d, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\treturn a\n}\n\n// Interface appends i marshaled using reflection.\nfunc (a *Array) Interface(i interface{}) *Array {\n\tif obj, ok := i.(LogObjectMarshaler); ok {\n\t\treturn a.Object(obj)\n\t}\n\ta.buf = enc.AppendInterface(enc.AppendArrayDelim(a.buf), i)\n\treturn a\n}\n\n// IPAddr adds IPv4 or IPv6 address to the array\nfunc (a *Array) IPAddr(ip net.IP) *Array {\n\ta.buf = enc.AppendIPAddr(enc.AppendArrayDelim(a.buf), ip)\n\treturn a\n}\n\n// IPPrefix adds IPv4 or IPv6 Prefix (IP + mask) to the array\nfunc (a *Array) IPPrefix(pfx net.IPNet) *Array {\n\ta.buf = enc.AppendIPPrefix(enc.AppendArrayDelim(a.buf), pfx)\n\treturn a\n}\n\n// MACAddr adds a MAC (Ethernet) address to the array\nfunc (a *Array) MACAddr(ha net.HardwareAddr) *Array {\n\ta.buf = enc.AppendMACAddr(enc.AppendArrayDelim(a.buf), ha)\n\treturn a\n}\n\n// Dict adds the dict Event to the array\nfunc (a *Array) Dict(dict *Event) *Array {\n\tdict.buf = enc.AppendEndMarker(dict.buf)\n\ta.buf = append(enc.AppendArrayDelim(a.buf), dict.buf...)\n\treturn a\n}\n"
        },
        {
          "name": "array_test.go",
          "type": "blob",
          "size": 0.75390625,
          "content": "package zerolog\n\nimport (\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestArray(t *testing.T) {\n\ta := Arr().\n\t\tBool(true).\n\t\tInt(1).\n\t\tInt8(2).\n\t\tInt16(3).\n\t\tInt32(4).\n\t\tInt64(5).\n\t\tUint(6).\n\t\tUint8(7).\n\t\tUint16(8).\n\t\tUint32(9).\n\t\tUint64(10).\n\t\tFloat32(11.98122).\n\t\tFloat64(12.987654321).\n\t\tStr(\"a\").\n\t\tBytes([]byte(\"b\")).\n\t\tHex([]byte{0x1f}).\n\t\tRawJSON([]byte(`{\"some\":\"json\"}`)).\n\t\tTime(time.Time{}).\n\t\tIPAddr(net.IP{192, 168, 0, 10}).\n\t\tDur(0).\n\t\tDict(Dict().\n\t\t\tStr(\"bar\", \"baz\").\n\t\t\tInt(\"n\", 1),\n\t\t)\n\twant := `[true,1,2,3,4,5,6,7,8,9,10,11.98122,12.987654321,\"a\",\"b\",\"1f\",{\"some\":\"json\"},\"0001-01-01T00:00:00Z\",\"192.168.0.10\",0,{\"bar\":\"baz\",\"n\":1}]`\n\tif got := decodeObjectToStr(a.write([]byte{})); got != want {\n\t\tt.Errorf(\"Array.write()\\ngot:  %s\\nwant: %s\", got, want)\n\t}\n}\n"
        },
        {
          "name": "benchmark_test.go",
          "type": "blob",
          "size": 8.115234375,
          "content": "package zerolog\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar (\n\terrExample  = errors.New(\"fail\")\n\tfakeMessage = \"Test logging, but use a somewhat realistic message length.\"\n)\n\nfunc BenchmarkLogEmpty(b *testing.B) {\n\tlogger := New(io.Discard)\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.Log().Msg(\"\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkDisabled(b *testing.B) {\n\tlogger := New(io.Discard).Level(Disabled)\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.Info().Msg(fakeMessage)\n\t\t}\n\t})\n}\n\nfunc BenchmarkInfo(b *testing.B) {\n\tlogger := New(io.Discard)\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.Info().Msg(fakeMessage)\n\t\t}\n\t})\n}\n\nfunc BenchmarkContextFields(b *testing.B) {\n\tlogger := New(io.Discard).With().\n\t\tStr(\"string\", \"four!\").\n\t\tTime(\"time\", time.Time{}).\n\t\tInt(\"int\", 123).\n\t\tFloat32(\"float\", -2.203230293249593).\n\t\tLogger()\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.Info().Msg(fakeMessage)\n\t\t}\n\t})\n}\n\nfunc BenchmarkContextAppend(b *testing.B) {\n\tlogger := New(io.Discard).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tLogger()\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.With().Str(\"bar\", \"baz\")\n\t\t}\n\t})\n}\n\nfunc BenchmarkLogFields(b *testing.B) {\n\tlogger := New(io.Discard)\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tlogger.Info().\n\t\t\t\tStr(\"string\", \"four!\").\n\t\t\t\tTime(\"time\", time.Time{}).\n\t\t\t\tInt(\"int\", 123).\n\t\t\t\tFloat32(\"float\", -2.203230293249593).\n\t\t\t\tMsg(fakeMessage)\n\t\t}\n\t})\n}\n\ntype obj struct {\n\tPub  string\n\tTag  string `json:\"tag\"`\n\tpriv int\n}\n\nfunc (o obj) MarshalZerologObject(e *Event) {\n\te.Str(\"Pub\", o.Pub).\n\t\tStr(\"Tag\", o.Tag).\n\t\tInt(\"priv\", o.priv)\n}\n\nfunc BenchmarkLogArrayObject(b *testing.B) {\n\tobj1 := obj{\"a\", \"b\", 2}\n\tobj2 := obj{\"c\", \"d\", 3}\n\tobj3 := obj{\"e\", \"f\", 4}\n\tlogger := New(io.Discard)\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\tfor i := 0; i < b.N; i++ {\n\t\tarr := Arr()\n\t\tarr.Object(&obj1)\n\t\tarr.Object(&obj2)\n\t\tarr.Object(&obj3)\n\t\tlogger.Info().Array(\"objects\", arr).Msg(\"test\")\n\t}\n}\n\nfunc BenchmarkLogFieldType(b *testing.B) {\n\tbools := []bool{true, false, true, false, true, false, true, false, true, false}\n\tints := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tfloats := []float64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tstrings := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"}\n\tdurations := []time.Duration{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\ttimes := []time.Time{\n\t\ttime.Unix(0, 0),\n\t\ttime.Unix(1, 0),\n\t\ttime.Unix(2, 0),\n\t\ttime.Unix(3, 0),\n\t\ttime.Unix(4, 0),\n\t\ttime.Unix(5, 0),\n\t\ttime.Unix(6, 0),\n\t\ttime.Unix(7, 0),\n\t\ttime.Unix(8, 0),\n\t\ttime.Unix(9, 0),\n\t}\n\tinterfaces := []struct {\n\t\tPub  string\n\t\tTag  string `json:\"tag\"`\n\t\tpriv int\n\t}{\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t}\n\tobjects := []obj{\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t}\n\terrs := []error{errors.New(\"a\"), errors.New(\"b\"), errors.New(\"c\"), errors.New(\"d\"), errors.New(\"e\")}\n\tctx := context.Background()\n\ttypes := map[string]func(e *Event) *Event{\n\t\t\"Bool\": func(e *Event) *Event {\n\t\t\treturn e.Bool(\"k\", bools[0])\n\t\t},\n\t\t\"Bools\": func(e *Event) *Event {\n\t\t\treturn e.Bools(\"k\", bools)\n\t\t},\n\t\t\"Int\": func(e *Event) *Event {\n\t\t\treturn e.Int(\"k\", ints[0])\n\t\t},\n\t\t\"Ints\": func(e *Event) *Event {\n\t\t\treturn e.Ints(\"k\", ints)\n\t\t},\n\t\t\"Float\": func(e *Event) *Event {\n\t\t\treturn e.Float64(\"k\", floats[0])\n\t\t},\n\t\t\"Floats\": func(e *Event) *Event {\n\t\t\treturn e.Floats64(\"k\", floats)\n\t\t},\n\t\t\"Str\": func(e *Event) *Event {\n\t\t\treturn e.Str(\"k\", strings[0])\n\t\t},\n\t\t\"Strs\": func(e *Event) *Event {\n\t\t\treturn e.Strs(\"k\", strings)\n\t\t},\n\t\t\"Err\": func(e *Event) *Event {\n\t\t\treturn e.Err(errs[0])\n\t\t},\n\t\t\"Errs\": func(e *Event) *Event {\n\t\t\treturn e.Errs(\"k\", errs)\n\t\t},\n\t\t\"Ctx\": func(e *Event) *Event {\n\t\t\treturn e.Ctx(ctx)\n\t\t},\n\t\t\"Time\": func(e *Event) *Event {\n\t\t\treturn e.Time(\"k\", times[0])\n\t\t},\n\t\t\"Times\": func(e *Event) *Event {\n\t\t\treturn e.Times(\"k\", times)\n\t\t},\n\t\t\"Dur\": func(e *Event) *Event {\n\t\t\treturn e.Dur(\"k\", durations[0])\n\t\t},\n\t\t\"Durs\": func(e *Event) *Event {\n\t\t\treturn e.Durs(\"k\", durations)\n\t\t},\n\t\t\"Interface\": func(e *Event) *Event {\n\t\t\treturn e.Interface(\"k\", interfaces[0])\n\t\t},\n\t\t\"Interfaces\": func(e *Event) *Event {\n\t\t\treturn e.Interface(\"k\", interfaces)\n\t\t},\n\t\t\"Interface(Object)\": func(e *Event) *Event {\n\t\t\treturn e.Interface(\"k\", objects[0])\n\t\t},\n\t\t\"Interface(Objects)\": func(e *Event) *Event {\n\t\t\treturn e.Interface(\"k\", objects)\n\t\t},\n\t\t\"Object\": func(e *Event) *Event {\n\t\t\treturn e.Object(\"k\", objects[0])\n\t\t},\n\t}\n\tlogger := New(io.Discard)\n\tb.ResetTimer()\n\tfor name := range types {\n\t\tf := types[name]\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\tfor pb.Next() {\n\t\t\t\t\tf(logger.Info()).Msg(\"\")\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc BenchmarkContextFieldType(b *testing.B) {\n\toldFormat := TimeFieldFormat\n\tTimeFieldFormat = TimeFormatUnix\n\tdefer func() { TimeFieldFormat = oldFormat }()\n\tbools := []bool{true, false, true, false, true, false, true, false, true, false}\n\tints := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tfloats := []float64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tstrings := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"}\n\tstringer := net.IP{127, 0, 0, 1}\n\tdurations := []time.Duration{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\ttimes := []time.Time{\n\t\ttime.Unix(0, 0),\n\t\ttime.Unix(1, 0),\n\t\ttime.Unix(2, 0),\n\t\ttime.Unix(3, 0),\n\t\ttime.Unix(4, 0),\n\t\ttime.Unix(5, 0),\n\t\ttime.Unix(6, 0),\n\t\ttime.Unix(7, 0),\n\t\ttime.Unix(8, 0),\n\t\ttime.Unix(9, 0),\n\t}\n\tinterfaces := []struct {\n\t\tPub  string\n\t\tTag  string `json:\"tag\"`\n\t\tpriv int\n\t}{\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t}\n\tobjects := []obj{\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t\t{\"a\", \"a\", 0},\n\t}\n\terrs := []error{errors.New(\"a\"), errors.New(\"b\"), errors.New(\"c\"), errors.New(\"d\"), errors.New(\"e\")}\n\tctx := context.Background()\n\ttypes := map[string]func(c Context) Context{\n\t\t\"Bool\": func(c Context) Context {\n\t\t\treturn c.Bool(\"k\", bools[0])\n\t\t},\n\t\t\"Bools\": func(c Context) Context {\n\t\t\treturn c.Bools(\"k\", bools)\n\t\t},\n\t\t\"Int\": func(c Context) Context {\n\t\t\treturn c.Int(\"k\", ints[0])\n\t\t},\n\t\t\"Ints\": func(c Context) Context {\n\t\t\treturn c.Ints(\"k\", ints)\n\t\t},\n\t\t\"Float\": func(c Context) Context {\n\t\t\treturn c.Float64(\"k\", floats[0])\n\t\t},\n\t\t\"Floats\": func(c Context) Context {\n\t\t\treturn c.Floats64(\"k\", floats)\n\t\t},\n\t\t\"Str\": func(c Context) Context {\n\t\t\treturn c.Str(\"k\", strings[0])\n\t\t},\n\t\t\"Strs\": func(c Context) Context {\n\t\t\treturn c.Strs(\"k\", strings)\n\t\t},\n\t\t\"Stringer\": func(c Context) Context {\n\t\t\treturn c.Stringer(\"k\", stringer)\n\t\t},\n\t\t\"Err\": func(c Context) Context {\n\t\t\treturn c.Err(errs[0])\n\t\t},\n\t\t\"Errs\": func(c Context) Context {\n\t\t\treturn c.Errs(\"k\", errs)\n\t\t},\n\t\t\"Ctx\": func(c Context) Context {\n\t\t\treturn c.Ctx(ctx)\n\t\t},\n\t\t\"Time\": func(c Context) Context {\n\t\t\treturn c.Time(\"k\", times[0])\n\t\t},\n\t\t\"Times\": func(c Context) Context {\n\t\t\treturn c.Times(\"k\", times)\n\t\t},\n\t\t\"Dur\": func(c Context) Context {\n\t\t\treturn c.Dur(\"k\", durations[0])\n\t\t},\n\t\t\"Durs\": func(c Context) Context {\n\t\t\treturn c.Durs(\"k\", durations)\n\t\t},\n\t\t\"Interface\": func(c Context) Context {\n\t\t\treturn c.Interface(\"k\", interfaces[0])\n\t\t},\n\t\t\"Interfaces\": func(c Context) Context {\n\t\t\treturn c.Interface(\"k\", interfaces)\n\t\t},\n\t\t\"Interface(Object)\": func(c Context) Context {\n\t\t\treturn c.Interface(\"k\", objects[0])\n\t\t},\n\t\t\"Interface(Objects)\": func(c Context) Context {\n\t\t\treturn c.Interface(\"k\", objects)\n\t\t},\n\t\t\"Object\": func(c Context) Context {\n\t\t\treturn c.Object(\"k\", objects[0])\n\t\t},\n\t\t\"Timestamp\": func(c Context) Context {\n\t\t\treturn c.Timestamp()\n\t\t},\n\t}\n\tlogger := New(io.Discard)\n\tb.ResetTimer()\n\tfor name := range types {\n\t\tf := types[name]\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\tfor pb.Next() {\n\t\t\t\t\tl := f(logger.With()).Logger()\n\t\t\t\t\tl.Info().Msg(\"\")\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "binary_test.go",
          "type": "blob",
          "size": 11.9111328125,
          "content": "// +build binary_log\n\npackage zerolog\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\n\tstdlog \"log\"\n\t\"time\"\n)\n\nfunc ExampleBinaryNew() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Info().Msg(\"hello world\")\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"info\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_With() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).\n\t\tWith().\n\t\tStr(\"foo\", \"bar\").\n\t\tLogger()\n\n\tlog.Info().Msg(\"hello world\")\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\n\t// Output: {\"level\":\"info\",\"foo\":\"bar\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Level() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).Level(WarnLevel)\n\n\tlog.Info().Msg(\"filtered out message\")\n\tlog.Error().Msg(\"kept message\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"error\",\"message\":\"kept message\"}\n}\n\nfunc ExampleLogger_Sample() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).Sample(&BasicSampler{N: 2})\n\n\tlog.Info().Msg(\"message 1\")\n\tlog.Info().Msg(\"message 2\")\n\tlog.Info().Msg(\"message 3\")\n\tlog.Info().Msg(\"message 4\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"info\",\"message\":\"message 1\"}\n\t// {\"level\":\"info\",\"message\":\"message 3\"}\n}\n\ntype LevelNameHook1 struct{}\n\nfunc (h LevelNameHook1) Run(e *Event, l Level, msg string) {\n\tif l != NoLevel {\n\t\te.Str(\"level_name\", l.String())\n\t} else {\n\t\te.Str(\"level_name\", \"NoLevel\")\n\t}\n}\n\ntype MessageHook string\n\nfunc (h MessageHook) Run(e *Event, l Level, msg string) {\n\te.Str(\"the_message\", msg)\n}\n\nfunc ExampleLogger_Hook() {\n\tvar levelNameHook LevelNameHook1\n\tvar messageHook MessageHook = \"The message\"\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).Hook(levelNameHook).Hook(messageHook)\n\n\tlog.Info().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"info\",\"level_name\":\"info\",\"the_message\":\"hello world\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Print() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Print(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"debug\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Printf() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Printf(\"hello %s\", \"world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"debug\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Trace() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Trace().\n\t\tStr(\"foo\", \"bar\").\n\t\tInt(\"n\", 123).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"trace\",\"foo\":\"bar\",\"n\":123,\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Debug() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Debug().\n\t\tStr(\"foo\", \"bar\").\n\t\tInt(\"n\", 123).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"debug\",\"foo\":\"bar\",\"n\":123,\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Info() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Info().\n\t\tStr(\"foo\", \"bar\").\n\t\tInt(\"n\", 123).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"info\",\"foo\":\"bar\",\"n\":123,\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Warn() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Warn().\n\t\tStr(\"foo\", \"bar\").\n\t\tMsg(\"a warning message\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"warn\",\"foo\":\"bar\",\"message\":\"a warning message\"}\n}\n\nfunc ExampleLogger_Error() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Error().\n\t\tErr(errors.New(\"some error\")).\n\t\tMsg(\"error doing something\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"error\",\"error\":\"some error\",\"message\":\"error doing something\"}\n}\n\nfunc ExampleLogger_WithLevel() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.WithLevel(InfoLevel).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"level\":\"info\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Write() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tLogger()\n\n\tstdlog.SetFlags(0)\n\tstdlog.SetOutput(log)\n\n\tstdlog.Print(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Log() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tStr(\"bar\", \"baz\").\n\t\tMsg(\"\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\"}\n}\n\nfunc ExampleEvent_Dict() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tDict(\"dict\", Dict().\n\t\t\tStr(\"bar\", \"baz\").\n\t\t\tInt(\"n\", 1),\n\t\t).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"dict\":{\"bar\":\"baz\",\"n\":1},\"message\":\"hello world\"}\n}\n\ntype User struct {\n\tName    string\n\tAge     int\n\tCreated time.Time\n}\n\nfunc (u User) MarshalZerologObject(e *Event) {\n\te.Str(\"name\", u.Name).\n\t\tInt(\"age\", u.Age).\n\t\tTime(\"created\", u.Created)\n}\n\ntype Users []User\n\nfunc (uu Users) MarshalZerologArray(a *Array) {\n\tfor _, u := range uu {\n\t\ta.Object(u)\n\t}\n}\n\nfunc ExampleEvent_Array() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"array\", Arr().\n\t\t\tStr(\"baz\").\n\t\t\tInt(1),\n\t\t).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"array\":[\"baz\",1],\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Array_object() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\t// Users implements LogArrayMarshaler\n\tu := Users{\n\t\tUser{\"John\", 35, time.Time{}},\n\t\tUser{\"Bob\", 55, time.Time{}},\n\t}\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"users\", u).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"users\":[{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},{\"name\":\"Bob\",\"age\":55,\"created\":\"0001-01-01T00:00:00Z\"}],\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Object() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\t// User implements LogObjectMarshaler\n\tu := User{\"John\", 35, time.Time{}}\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tObject(\"user\", u).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"user\":{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_EmbedObject() {\n\tprice := Price{val: 6449, prec: 2, unit: \"$\"}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tEmbedObject(price).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"price\":\"$64.49\",\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Interface() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tobj := struct {\n\t\tName string `json:\"name\"`\n\t}{\n\t\tName: \"john\",\n\t}\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tInterface(\"obj\", obj).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"obj\":{\"name\":\"john\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Dur() {\n\td := time.Duration(10 * time.Second)\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tDur(\"dur\", d).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"dur\":10000,\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Durs() {\n\td := []time.Duration{\n\t\ttime.Duration(10 * time.Second),\n\t\ttime.Duration(20 * time.Second),\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tDurs(\"durs\", d).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"durs\":[10000,20000],\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Fields_map() {\n\tfields := map[string]interface{}{\n\t\t\"bar\": \"baz\",\n\t\t\"n\":   1,\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Fields_slice() {\n\tfields := []interface{}{\n\t\t\"bar\", \"baz\",\n\t\t\"n\", 1,\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tMsg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Dict() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tDict(\"dict\", Dict().\n\t\t\tStr(\"bar\", \"baz\").\n\t\t\tInt(\"n\", 1),\n\t\t).Logger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"dict\":{\"bar\":\"baz\",\"n\":1},\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Array() {\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"array\", Arr().\n\t\t\tStr(\"baz\").\n\t\t\tInt(1),\n\t\t).Logger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"array\":[\"baz\",1],\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Array_object() {\n\t// Users implements LogArrayMarshaler\n\tu := Users{\n\t\tUser{\"John\", 35, time.Time{}},\n\t\tUser{\"Bob\", 55, time.Time{}},\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"users\", u).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"users\":[{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},{\"name\":\"Bob\",\"age\":55,\"created\":\"0001-01-01T00:00:00Z\"}],\"message\":\"hello world\"}\n}\n\ntype Price struct {\n\tval  uint64\n\tprec int\n\tunit string\n}\n\nfunc (p Price) MarshalZerologObject(e *Event) {\n\tdenom := uint64(1)\n\tfor i := 0; i < p.prec; i++ {\n\t\tdenom *= 10\n\t}\n\tresult := []byte(p.unit)\n\tresult = append(result, fmt.Sprintf(\"%d.%d\", p.val/denom, p.val%denom)...)\n\te.Str(\"price\", string(result))\n}\n\nfunc ExampleContext_EmbedObject() {\n\tprice := Price{val: 6449, prec: 2, unit: \"$\"}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tEmbedObject(price).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"price\":\"$64.49\",\"message\":\"hello world\"}\n}\nfunc ExampleContext_Object() {\n\t// User implements LogObjectMarshaler\n\tu := User{\"John\", 35, time.Time{}}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tObject(\"user\", u).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"user\":{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Interface() {\n\tobj := struct {\n\t\tName string `json:\"name\"`\n\t}{\n\t\tName: \"john\",\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tInterface(\"obj\", obj).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"obj\":{\"name\":\"john\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Dur() {\n\td := time.Duration(10 * time.Second)\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tDur(\"dur\", d).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"dur\":10000,\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Durs() {\n\td := []time.Duration{\n\t\ttime.Duration(10 * time.Second),\n\t\ttime.Duration(20 * time.Second),\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tDurs(\"durs\", d).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"durs\":[10000,20000],\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Fields_map() {\n\tfields := map[string]interface{}{\n\t\t\"bar\": \"baz\",\n\t\t\"n\":   1,\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Fields_slice() {\n\tfields := []interface{}{\n\t\t\"bar\", \"baz\",\n\t\t\"n\", 1,\n\t}\n\n\tdst := bytes.Buffer{}\n\tlog := New(&dst).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\tfmt.Println(decodeIfBinaryToString(dst.Bytes()))\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "console.go",
          "type": "blob",
          "size": 11.8349609375,
          "content": "package zerolog\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/mattn/go-colorable\"\n)\n\nconst (\n\tcolorBlack = iota + 30\n\tcolorRed\n\tcolorGreen\n\tcolorYellow\n\tcolorBlue\n\tcolorMagenta\n\tcolorCyan\n\tcolorWhite\n\n\tcolorBold     = 1\n\tcolorDarkGray = 90\n\n\tunknownLevel = \"???\"\n)\n\nvar (\n\tconsoleBufPool = sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\treturn bytes.NewBuffer(make([]byte, 0, 100))\n\t\t},\n\t}\n)\n\nconst (\n\tconsoleDefaultTimeFormat = time.Kitchen\n)\n\n// Formatter transforms the input into a formatted string.\ntype Formatter func(interface{}) string\n\n// FormatterByFieldName transforms the input into a formatted string,\n// being able to differentiate formatting based on field name.\ntype FormatterByFieldName func(interface{}, string) string\n\n// ConsoleWriter parses the JSON input and writes it in an\n// (optionally) colorized, human-friendly format to Out.\ntype ConsoleWriter struct {\n\t// Out is the output destination.\n\tOut io.Writer\n\n\t// NoColor disables the colorized output.\n\tNoColor bool\n\n\t// TimeFormat specifies the format for timestamp in output.\n\tTimeFormat string\n\n\t// TimeLocation tells ConsoleWriters default FormatTimestamp\n\t// how to localize the time.\n\tTimeLocation *time.Location\n\n\t// PartsOrder defines the order of parts in output.\n\tPartsOrder []string\n\n\t// PartsExclude defines parts to not display in output.\n\tPartsExclude []string\n\n\t// FieldsOrder defines the order of contextual fields in output.\n\tFieldsOrder []string\n\n\tfieldIsOrdered map[string]int\n\n\t// FieldsExclude defines contextual fields to not display in output.\n\tFieldsExclude []string\n\n\tFormatTimestamp     Formatter\n\tFormatLevel         Formatter\n\tFormatCaller        Formatter\n\tFormatMessage       Formatter\n\tFormatFieldName     Formatter\n\tFormatFieldValue    Formatter\n\tFormatErrFieldName  Formatter\n\tFormatErrFieldValue Formatter\n\t// If this is configured it is used for \"part\" values and\n\t// has precedence on FormatFieldValue\n\tFormatPartValueByName FormatterByFieldName\n\n\tFormatExtra func(map[string]interface{}, *bytes.Buffer) error\n\n\tFormatPrepare func(map[string]interface{}) error\n}\n\n// NewConsoleWriter creates and initializes a new ConsoleWriter.\nfunc NewConsoleWriter(options ...func(w *ConsoleWriter)) ConsoleWriter {\n\tw := ConsoleWriter{\n\t\tOut:          os.Stdout,\n\t\tTimeFormat:   consoleDefaultTimeFormat,\n\t\tPartsOrder:   consoleDefaultPartsOrder(),\n\t}\n\n\tfor _, opt := range options {\n\t\topt(&w)\n\t}\n\n\t// Fix color on Windows\n\tif w.Out == os.Stdout || w.Out == os.Stderr {\n\t\tw.Out = colorable.NewColorable(w.Out.(*os.File))\n\t}\n\n\treturn w\n}\n\n// Write transforms the JSON input with formatters and appends to w.Out.\nfunc (w ConsoleWriter) Write(p []byte) (n int, err error) {\n\t// Fix color on Windows\n\tif w.Out == os.Stdout || w.Out == os.Stderr {\n\t\tw.Out = colorable.NewColorable(w.Out.(*os.File))\n\t}\n\n\tif w.PartsOrder == nil {\n\t\tw.PartsOrder = consoleDefaultPartsOrder()\n\t}\n\n\tvar buf = consoleBufPool.Get().(*bytes.Buffer)\n\tdefer func() {\n\t\tbuf.Reset()\n\t\tconsoleBufPool.Put(buf)\n\t}()\n\n\tvar evt map[string]interface{}\n\tp = decodeIfBinaryToBytes(p)\n\td := json.NewDecoder(bytes.NewReader(p))\n\td.UseNumber()\n\terr = d.Decode(&evt)\n\tif err != nil {\n\t\treturn n, fmt.Errorf(\"cannot decode event: %s\", err)\n\t}\n\n\tif w.FormatPrepare != nil {\n\t\terr = w.FormatPrepare(evt)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\n\tfor _, p := range w.PartsOrder {\n\t\tw.writePart(buf, evt, p)\n\t}\n\n\tw.writeFields(evt, buf)\n\n\tif w.FormatExtra != nil {\n\t\terr = w.FormatExtra(evt, buf)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t}\n\n\terr = buf.WriteByte('\\n')\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\t_, err = buf.WriteTo(w.Out)\n\treturn len(p), err\n}\n\n// Call the underlying writer's Close method if it is an io.Closer. Otherwise\n// does nothing.\nfunc (w ConsoleWriter) Close() error {\n\tif closer, ok := w.Out.(io.Closer); ok {\n\t\treturn closer.Close()\n\t}\n\treturn nil\n}\n\n// writeFields appends formatted key-value pairs to buf.\nfunc (w ConsoleWriter) writeFields(evt map[string]interface{}, buf *bytes.Buffer) {\n\tvar fields = make([]string, 0, len(evt))\n\tfor field := range evt {\n\t\tvar isExcluded bool\n\t\tfor _, excluded := range w.FieldsExclude {\n\t\t\tif field == excluded {\n\t\t\t\tisExcluded = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isExcluded {\n\t\t\tcontinue\n\t\t}\n\n\t\tswitch field {\n\t\tcase LevelFieldName, TimestampFieldName, MessageFieldName, CallerFieldName:\n\t\t\tcontinue\n\t\t}\n\t\tfields = append(fields, field)\n\t}\n\n\tif len(w.FieldsOrder) > 0 {\n\t\tw.orderFields(fields)\n\t} else {\n\t\tsort.Strings(fields)\n\t}\n\n\t// Write space only if something has already been written to the buffer, and if there are fields.\n\tif buf.Len() > 0 && len(fields) > 0 {\n\t\tbuf.WriteByte(' ')\n\t}\n\n\t// Move the \"error\" field to the front\n\tei := sort.Search(len(fields), func(i int) bool { return fields[i] >= ErrorFieldName })\n\tif ei < len(fields) && fields[ei] == ErrorFieldName {\n\t\tfields[ei] = \"\"\n\t\tfields = append([]string{ErrorFieldName}, fields...)\n\t\tvar xfields = make([]string, 0, len(fields))\n\t\tfor _, field := range fields {\n\t\t\tif field == \"\" { // Skip empty fields\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\txfields = append(xfields, field)\n\t\t}\n\t\tfields = xfields\n\t}\n\n\tfor i, field := range fields {\n\t\tvar fn Formatter\n\t\tvar fv Formatter\n\n\t\tif field == ErrorFieldName {\n\t\t\tif w.FormatErrFieldName == nil {\n\t\t\t\tfn = consoleDefaultFormatErrFieldName(w.NoColor)\n\t\t\t} else {\n\t\t\t\tfn = w.FormatErrFieldName\n\t\t\t}\n\n\t\t\tif w.FormatErrFieldValue == nil {\n\t\t\t\tfv = consoleDefaultFormatErrFieldValue(w.NoColor)\n\t\t\t} else {\n\t\t\t\tfv = w.FormatErrFieldValue\n\t\t\t}\n\t\t} else {\n\t\t\tif w.FormatFieldName == nil {\n\t\t\t\tfn = consoleDefaultFormatFieldName(w.NoColor)\n\t\t\t} else {\n\t\t\t\tfn = w.FormatFieldName\n\t\t\t}\n\n\t\t\tif w.FormatFieldValue == nil {\n\t\t\t\tfv = consoleDefaultFormatFieldValue\n\t\t\t} else {\n\t\t\t\tfv = w.FormatFieldValue\n\t\t\t}\n\t\t}\n\n\t\tbuf.WriteString(fn(field))\n\n\t\tswitch fValue := evt[field].(type) {\n\t\tcase string:\n\t\t\tif needsQuote(fValue) {\n\t\t\t\tbuf.WriteString(fv(strconv.Quote(fValue)))\n\t\t\t} else {\n\t\t\t\tbuf.WriteString(fv(fValue))\n\t\t\t}\n\t\tcase json.Number:\n\t\t\tbuf.WriteString(fv(fValue))\n\t\tdefault:\n\t\t\tb, err := InterfaceMarshalFunc(fValue)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(buf, colorize(\"[error: %v]\", colorRed, w.NoColor), err)\n\t\t\t} else {\n\t\t\t\tfmt.Fprint(buf, fv(b))\n\t\t\t}\n\t\t}\n\n\t\tif i < len(fields)-1 { // Skip space for last field\n\t\t\tbuf.WriteByte(' ')\n\t\t}\n\t}\n}\n\n// writePart appends a formatted part to buf.\nfunc (w ConsoleWriter) writePart(buf *bytes.Buffer, evt map[string]interface{}, p string) {\n\tvar f Formatter\n\tvar fvn FormatterByFieldName\n\n\tif len(w.PartsExclude) > 0 {\n\t\tfor _, exclude := range w.PartsExclude {\n\t\t\tif exclude == p {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch p {\n\tcase LevelFieldName:\n\t\tif w.FormatLevel == nil {\n\t\t\tf = consoleDefaultFormatLevel(w.NoColor)\n\t\t} else {\n\t\t\tf = w.FormatLevel\n\t\t}\n\tcase TimestampFieldName:\n\t\tif w.FormatTimestamp == nil {\n\t\t\tf = consoleDefaultFormatTimestamp(w.TimeFormat, w.TimeLocation, w.NoColor)\n\t\t} else {\n\t\t\tf = w.FormatTimestamp\n\t\t}\n\tcase MessageFieldName:\n\t\tif w.FormatMessage == nil {\n\t\t\tf = consoleDefaultFormatMessage(w.NoColor, evt[LevelFieldName])\n\t\t} else {\n\t\t\tf = w.FormatMessage\n\t\t}\n\tcase CallerFieldName:\n\t\tif w.FormatCaller == nil {\n\t\t\tf = consoleDefaultFormatCaller(w.NoColor)\n\t\t} else {\n\t\t\tf = w.FormatCaller\n\t\t}\n\tdefault:\n\t\tif w.FormatPartValueByName != nil {\n\t\t\tfvn = w.FormatPartValueByName\n\t\t} else if w.FormatFieldValue != nil {\n\t\t\tf = w.FormatFieldValue\n\t\t} else {\n\t\t\tf = consoleDefaultFormatFieldValue\n\t\t}\n\t}\n\n\tvar s string\n\tif f == nil {\n\t\ts = fvn(evt[p], p)\n\t} else {\n\t\ts = f(evt[p])\n\t}\n\n\tif len(s) > 0 {\n\t\tif buf.Len() > 0 {\n\t\t\tbuf.WriteByte(' ') // Write space only if not the first part\n\t\t}\n\t\tbuf.WriteString(s)\n\t}\n}\n\n// orderFields takes an array of field names and an array representing field order\n// and returns an array with any ordered fields at the beginning, in order,\n// and the remaining fields after in their original order.\nfunc (w ConsoleWriter) orderFields(fields []string) {\n\tif w.fieldIsOrdered == nil {\n\t\tw.fieldIsOrdered = make(map[string]int)\n\t\tfor i, fieldName := range w.FieldsOrder {\n\t\t\tw.fieldIsOrdered[fieldName] = i\n\t\t}\n\t}\n\tsort.Slice(fields, func(i, j int) bool {\n\t\tii, iOrdered := w.fieldIsOrdered[fields[i]]\n\t\tjj, jOrdered := w.fieldIsOrdered[fields[j]]\n\t\tif iOrdered && jOrdered {\n\t\t\treturn ii < jj\n\t\t}\n\t\tif iOrdered {\n\t\t\treturn true\n\t\t}\n\t\tif jOrdered {\n\t\t\treturn false\n\t\t}\n\t\treturn fields[i] < fields[j]\n\t})\n}\n\n// needsQuote returns true when the string s should be quoted in output.\nfunc needsQuote(s string) bool {\n\tfor i := range s {\n\t\tif s[i] < 0x20 || s[i] > 0x7e || s[i] == ' ' || s[i] == '\\\\' || s[i] == '\"' {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// colorize returns the string s wrapped in ANSI code c, unless disabled is true or c is 0.\nfunc colorize(s interface{}, c int, disabled bool) string {\n\te := os.Getenv(\"NO_COLOR\")\n\tif e != \"\" || c == 0 {\n\t\tdisabled = true\n\t}\n\n\tif disabled {\n\t\treturn fmt.Sprintf(\"%s\", s)\n\t}\n\treturn fmt.Sprintf(\"\\x1b[%dm%v\\x1b[0m\", c, s)\n}\n\n// ----- DEFAULT FORMATTERS ---------------------------------------------------\n\nfunc consoleDefaultPartsOrder() []string {\n\treturn []string{\n\t\tTimestampFieldName,\n\t\tLevelFieldName,\n\t\tCallerFieldName,\n\t\tMessageFieldName,\n\t}\n}\n\nfunc consoleDefaultFormatTimestamp(timeFormat string, location *time.Location, noColor bool) Formatter {\n\tif timeFormat == \"\" {\n\t\ttimeFormat = consoleDefaultTimeFormat\n\t}\n\tif location == nil {\n\t\tlocation = time.Local\n\t}\n\n\treturn func(i interface{}) string {\n\t\tt := \"<nil>\"\n\t\tswitch tt := i.(type) {\n\t\tcase string:\n\t\t\tts, err := time.ParseInLocation(TimeFieldFormat, tt, location)\n\t\t\tif err != nil {\n\t\t\t\tt = tt\n\t\t\t} else {\n\t\t\t\tt = ts.In(location).Format(timeFormat)\n\t\t\t}\n\t\tcase json.Number:\n\t\t\ti, err := tt.Int64()\n\t\t\tif err != nil {\n\t\t\t\tt = tt.String()\n\t\t\t} else {\n\t\t\t\tvar sec, nsec int64\n\n\t\t\t\tswitch TimeFieldFormat {\n\t\t\t\tcase TimeFormatUnixNano:\n\t\t\t\t\tsec, nsec = 0, i\n\t\t\t\tcase TimeFormatUnixMicro:\n\t\t\t\t\tsec, nsec = 0, int64(time.Duration(i)*time.Microsecond)\n\t\t\t\tcase TimeFormatUnixMs:\n\t\t\t\t\tsec, nsec = 0, int64(time.Duration(i)*time.Millisecond)\n\t\t\t\tdefault:\n\t\t\t\t\tsec, nsec = i, 0\n\t\t\t\t}\n\n\t\t\t\tts := time.Unix(sec, nsec)\n\t\t\t\tt = ts.In(location).Format(timeFormat)\n\t\t\t}\n\t\t}\n\t\treturn colorize(t, colorDarkGray, noColor)\n\t}\n}\n\nfunc stripLevel(ll string) string {\n\tif len(ll) == 0 {\n\t\treturn unknownLevel\n\t}\n\tif len(ll) > 3 {\n\t\tll = ll[:3]\n\t}\n\treturn strings.ToUpper(ll)\n}\n\nfunc consoleDefaultFormatLevel(noColor bool) Formatter {\n\treturn func(i interface{}) string {\n\t\tif ll, ok := i.(string); ok {\n\t\t\tlevel, _ := ParseLevel(ll)\n\t\t\tfl, ok := FormattedLevels[level]\n\t\t\tif ok {\n\t\t\t\treturn colorize(fl, LevelColors[level], noColor)\n\t\t\t}\n\t\t\treturn stripLevel(ll)\n\t\t}\n\t\tif i == nil {\n\t\t\treturn unknownLevel\n\t\t}\n\t\treturn stripLevel(fmt.Sprintf(\"%s\", i))\n\t}\n}\n\nfunc consoleDefaultFormatCaller(noColor bool) Formatter {\n\treturn func(i interface{}) string {\n\t\tvar c string\n\t\tif cc, ok := i.(string); ok {\n\t\t\tc = cc\n\t\t}\n\t\tif len(c) > 0 {\n\t\t\tif cwd, err := os.Getwd(); err == nil {\n\t\t\t\tif rel, err := filepath.Rel(cwd, c); err == nil {\n\t\t\t\t\tc = rel\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = colorize(c, colorBold, noColor) + colorize(\" >\", colorCyan, noColor)\n\t\t}\n\t\treturn c\n\t}\n}\n\nfunc consoleDefaultFormatMessage(noColor bool, level interface{}) Formatter {\n\treturn func(i interface{}) string {\n\t\tif i == nil || i == \"\" {\n\t\t\treturn \"\"\n\t\t}\n\t\tswitch level {\n\t\tcase LevelInfoValue, LevelWarnValue, LevelErrorValue, LevelFatalValue, LevelPanicValue:\n\t\t\treturn colorize(fmt.Sprintf(\"%s\", i), colorBold, noColor)\n\t\tdefault:\n\t\t\treturn fmt.Sprintf(\"%s\", i)\n\t\t}\n\t}\n}\n\nfunc consoleDefaultFormatFieldName(noColor bool) Formatter {\n\treturn func(i interface{}) string {\n\t\treturn colorize(fmt.Sprintf(\"%s=\", i), colorCyan, noColor)\n\t}\n}\n\nfunc consoleDefaultFormatFieldValue(i interface{}) string {\n\treturn fmt.Sprintf(\"%s\", i)\n}\n\nfunc consoleDefaultFormatErrFieldName(noColor bool) Formatter {\n\treturn func(i interface{}) string {\n\t\treturn colorize(fmt.Sprintf(\"%s=\", i), colorCyan, noColor)\n\t}\n}\n\nfunc consoleDefaultFormatErrFieldValue(noColor bool) Formatter {\n\treturn func(i interface{}) string {\n\t\treturn colorize(colorize(fmt.Sprintf(\"%s\", i), colorBold, noColor), colorRed, noColor)\n\t}\n}\n"
        },
        {
          "name": "console_test.go",
          "type": "blob",
          "size": 19.39453125,
          "content": "package zerolog_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n)\n\nfunc ExampleConsoleWriter() {\n\tlog := zerolog.New(zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true})\n\n\tlog.Info().Str(\"foo\", \"bar\").Msg(\"Hello World\")\n\t// Output: <nil> INF Hello World foo=bar\n}\n\nfunc ExampleConsoleWriter_customFormatters() {\n\tout := zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true}\n\tout.FormatLevel = func(i interface{}) string { return strings.ToUpper(fmt.Sprintf(\"%-6s|\", i)) }\n\tout.FormatFieldName = func(i interface{}) string { return fmt.Sprintf(\"%s:\", i) }\n\tout.FormatFieldValue = func(i interface{}) string { return strings.ToUpper(fmt.Sprintf(\"%s\", i)) }\n\tlog := zerolog.New(out)\n\n\tlog.Info().Str(\"foo\", \"bar\").Msg(\"Hello World\")\n\t// Output: <nil> INFO  | Hello World foo:BAR\n}\n\nfunc ExampleConsoleWriter_partValueFormatter() {\n\tout := zerolog.ConsoleWriter{Out: os.Stdout, NoColor: true,\n\t\tPartsOrder:    []string{\"level\", \"one\", \"two\", \"three\", \"message\"},\n\t\tFieldsExclude: []string{\"one\", \"two\", \"three\"}}\n\tout.FormatLevel = func(i interface{}) string { return strings.ToUpper(fmt.Sprintf(\"%-6s\", i)) }\n\tout.FormatFieldName = func(i interface{}) string { return fmt.Sprintf(\"%s:\", i) }\n\tout.FormatPartValueByName = func(i interface{}, s string) string {\n\t\tvar ret string\n\t\tswitch s {\n\t\tcase \"one\":\n\t\t\tret = strings.ToUpper(fmt.Sprintf(\"%s\", i))\n\t\tcase \"two\":\n\t\t\tret = strings.ToLower(fmt.Sprintf(\"%s\", i))\n\t\tcase \"three\":\n\t\t\tret = strings.ToLower(fmt.Sprintf(\"(%s)\", i))\n\t\t}\n\t\treturn ret\n\t}\n\tlog := zerolog.New(out)\n\n\tlog.Info().Str(\"foo\", \"bar\").\n\t\tStr(\"two\", \"TEST_TWO\").\n\t\tStr(\"one\", \"test_one\").\n\t\tStr(\"three\", \"test_three\").\n\t\tMsg(\"Hello World\")\n\t// Output: INFO   TEST_ONE test_two (test_three) Hello World foo:bar\n}\n\nfunc ExampleNewConsoleWriter() {\n\tout := zerolog.NewConsoleWriter()\n\tout.NoColor = true // For testing purposes only\n\tlog := zerolog.New(out)\n\n\tlog.Debug().Str(\"foo\", \"bar\").Msg(\"Hello World\")\n\t// Output: <nil> DBG Hello World foo=bar\n}\n\nfunc ExampleNewConsoleWriter_customFormatters() {\n\tout := zerolog.NewConsoleWriter(\n\t\tfunc(w *zerolog.ConsoleWriter) {\n\t\t\t// Customize time format\n\t\t\tw.TimeFormat = time.RFC822\n\t\t\t// Customize level formatting\n\t\t\tw.FormatLevel = func(i interface{}) string { return strings.ToUpper(fmt.Sprintf(\"[%-5s]\", i)) }\n\t\t},\n\t)\n\tout.NoColor = true // For testing purposes only\n\n\tlog := zerolog.New(out)\n\n\tlog.Info().Str(\"foo\", \"bar\").Msg(\"Hello World\")\n\t// Output: <nil> [INFO ] Hello World foo=bar\n}\n\nfunc TestConsoleLogger(t *testing.T) {\n\tt.Run(\"Numbers\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tlog := zerolog.New(zerolog.ConsoleWriter{Out: buf, NoColor: true})\n\t\tlog.Info().\n\t\t\tFloat64(\"float\", 1.23).\n\t\t\tUint64(\"small\", 123).\n\t\t\tUint64(\"big\", 1152921504606846976).\n\t\t\tMsg(\"msg\")\n\t\tif got, want := strings.TrimSpace(buf.String()), \"<nil> INF msg big=1152921504606846976 float=1.23 small=123\"; got != want {\n\t\t\tt.Errorf(\"\\ngot:\\n%s\\nwant:\\n%s\", got, want)\n\t\t}\n\t})\n}\n\nfunc TestConsoleWriter(t *testing.T) {\n\tt.Run(\"Default field formatter\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true, PartsOrder: []string{\"foo\"}}\n\n\t\t_, err := w.Write([]byte(`{\"foo\": \"DEFAULT\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"DEFAULT foo=DEFAULT\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Write colorized\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: false}\n\n\t\t_, err := w.Write([]byte(`{\"level\": \"warn\", \"message\": \"Foobar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"\\x1b[90m<nil>\\x1b[0m \\x1b[33mWRN\\x1b[0m \\x1b[1mFoobar\\x1b[0m\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"NO_COLOR = true\", func(t *testing.T) {\n\t\tos.Setenv(\"NO_COLOR\", \"anything\")\n\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf}\n\n\t\t_, err := w.Write([]byte(`{\"level\": \"warn\", \"message\": \"Foobar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"<nil> WRN Foobar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t\tos.Unsetenv(\"NO_COLOR\")\n\t})\n\n\tt.Run(\"Write fields\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true}\n\n\t\tts := time.Unix(0, 0)\n\t\td := ts.UTC().Format(time.RFC3339)\n\t\t_, err := w.Write([]byte(`{\"time\": \"` + d + `\", \"level\": \"debug\", \"message\": \"Foobar\", \"foo\": \"bar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := ts.Format(time.Kitchen) + \" DBG Foobar foo=bar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Unix timestamp input format\", func(t *testing.T) {\n\t\tof := zerolog.TimeFieldFormat\n\t\tdefer func() {\n\t\t\tzerolog.TimeFieldFormat = of\n\t\t}()\n\t\tzerolog.TimeFieldFormat = zerolog.TimeFormatUnix\n\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, TimeFormat: time.StampMilli, NoColor: true}\n\n\t\t_, err := w.Write([]byte(`{\"time\": 1234, \"level\": \"debug\", \"message\": \"Foobar\", \"foo\": \"bar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := time.Unix(1234, 0).Format(time.StampMilli) + \" DBG Foobar foo=bar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Unix timestamp ms input format\", func(t *testing.T) {\n\t\tof := zerolog.TimeFieldFormat\n\t\tdefer func() {\n\t\t\tzerolog.TimeFieldFormat = of\n\t\t}()\n\t\tzerolog.TimeFieldFormat = zerolog.TimeFormatUnixMs\n\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, TimeFormat: time.StampMilli, NoColor: true}\n\n\t\t_, err := w.Write([]byte(`{\"time\": 1234567, \"level\": \"debug\", \"message\": \"Foobar\", \"foo\": \"bar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := time.Unix(1234, 567000000).Format(time.StampMilli) + \" DBG Foobar foo=bar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Unix timestamp us input format\", func(t *testing.T) {\n\t\tof := zerolog.TimeFieldFormat\n\t\tdefer func() {\n\t\t\tzerolog.TimeFieldFormat = of\n\t\t}()\n\t\tzerolog.TimeFieldFormat = zerolog.TimeFormatUnixMicro\n\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, TimeFormat: time.StampMicro, NoColor: true}\n\n\t\t_, err := w.Write([]byte(`{\"time\": 1234567891, \"level\": \"debug\", \"message\": \"Foobar\", \"foo\": \"bar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := time.Unix(1234, 567891000).Format(time.StampMicro) + \" DBG Foobar foo=bar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"No message field\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true}\n\n\t\t_, err := w.Write([]byte(`{\"level\": \"debug\", \"foo\": \"bar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"<nil> DBG foo=bar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"No level field\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true}\n\n\t\t_, err := w.Write([]byte(`{\"message\": \"Foobar\", \"foo\": \"bar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"<nil> ??? Foobar foo=bar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Write colorized fields\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: false}\n\n\t\t_, err := w.Write([]byte(`{\"level\": \"warn\", \"message\": \"Foobar\", \"foo\": \"bar\"}`))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"\\x1b[90m<nil>\\x1b[0m \\x1b[33mWRN\\x1b[0m \\x1b[1mFoobar\\x1b[0m \\x1b[36mfoo=\\x1b[0mbar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Write error field\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true}\n\n\t\tts := time.Unix(0, 0)\n\t\td := ts.UTC().Format(time.RFC3339)\n\t\tevt := `{\"time\": \"` + d + `\", \"level\": \"error\", \"message\": \"Foobar\", \"aaa\": \"bbb\", \"error\": \"Error\"}`\n\t\t// t.Log(evt)\n\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := ts.Format(time.Kitchen) + \" ERR Foobar error=Error aaa=bbb\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Write caller field\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true}\n\n\t\tcwd, err := os.Getwd()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Cannot get working directory: %s\", err)\n\t\t}\n\n\t\tts := time.Unix(0, 0)\n\t\td := ts.UTC().Format(time.RFC3339)\n\t\tevt := `{\"time\": \"` + d + `\", \"level\": \"debug\", \"message\": \"Foobar\", \"foo\": \"bar\", \"caller\": \"` + cwd + `/foo/bar.go\"}`\n\t\t// t.Log(evt)\n\n\t\t_, err = w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := ts.Format(time.Kitchen) + \" DBG foo/bar.go > Foobar foo=bar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Write JSON field\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true}\n\n\t\tevt := `{\"level\": \"debug\", \"message\": \"Foobar\", \"foo\": [1, 2, 3], \"bar\": true}`\n\t\t// t.Log(evt)\n\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"<nil> DBG Foobar bar=true foo=[1,2,3]\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"With an extra 'level' field\", func(t *testing.T) {\n\t\tt.Run(\"malformed string\", func(t *testing.T) {\n\t\t\tcases := []struct {\n\t\t\t\tfield  string\n\t\t\t\toutput string\n\t\t\t}{\n\t\t\t\t{\"\", \"<nil> ??? Hello World foo=bar\\n\"},\n\t\t\t\t{\"-\", \"<nil> - Hello World foo=bar\\n\"},\n\t\t\t\t{\"1\", \"<nil> \" + zerolog.FormattedLevels[1] + \" Hello World foo=bar\\n\"},\n\t\t\t\t{\"a\", \"<nil> A Hello World foo=bar\\n\"},\n\t\t\t\t{\"12\", \"<nil> 12 Hello World foo=bar\\n\"},\n\t\t\t\t{\"a2\", \"<nil> A2 Hello World foo=bar\\n\"},\n\t\t\t\t{\"2a\", \"<nil> 2A Hello World foo=bar\\n\"},\n\t\t\t\t{\"ab\", \"<nil> AB Hello World foo=bar\\n\"},\n\t\t\t\t{\"12a\", \"<nil> 12A Hello World foo=bar\\n\"},\n\t\t\t\t{\"a12\", \"<nil> A12 Hello World foo=bar\\n\"},\n\t\t\t\t{\"abc\", \"<nil> ABC Hello World foo=bar\\n\"},\n\t\t\t\t{\"123\", \"<nil> 123 Hello World foo=bar\\n\"},\n\t\t\t\t{\"abcd\", \"<nil> ABC Hello World foo=bar\\n\"},\n\t\t\t\t{\"1234\", \"<nil> 123 Hello World foo=bar\\n\"},\n\t\t\t\t{\"123d\", \"<nil> 123 Hello World foo=bar\\n\"},\n\t\t\t\t{\"01\", \"<nil> \" + zerolog.FormattedLevels[1] + \" Hello World foo=bar\\n\"},\n\t\t\t\t{\"001\", \"<nil> \" + zerolog.FormattedLevels[1] + \" Hello World foo=bar\\n\"},\n\t\t\t\t{\"0001\", \"<nil> \" + zerolog.FormattedLevels[1] + \" Hello World foo=bar\\n\"},\n\t\t\t}\n\t\t\tfor i, c := range cases {\n\t\t\t\tc := c\n\t\t\t\tt.Run(fmt.Sprintf(\"case %d\", i), func(t *testing.T) {\n\t\t\t\t\tbuf := &bytes.Buffer{}\n\t\t\t\t\tout := zerolog.NewConsoleWriter()\n\t\t\t\t\tout.NoColor = true\n\t\t\t\t\tout.Out = buf\n\t\t\t\t\tlog := zerolog.New(out)\n\n\t\t\t\t\tlog.Debug().Str(\"level\", c.field).Str(\"foo\", \"bar\").Msg(\"Hello World\")\n\n\t\t\t\t\tactualOutput := buf.String()\n\t\t\t\t\tif actualOutput != c.output {\n\t\t\t\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, c.output)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\n\t\tt.Run(\"weird value\", func(t *testing.T) {\n\t\t\tcases := []struct {\n\t\t\t\tfield  interface{}\n\t\t\t\toutput string\n\t\t\t}{\n\t\t\t\t{0, \"<nil> 0 Hello World foo=bar\\n\"},\n\t\t\t\t{1, \"<nil> 1 Hello World foo=bar\\n\"},\n\t\t\t\t{-1, \"<nil> -1 Hello World foo=bar\\n\"},\n\t\t\t\t{-3, \"<nil> -3 Hello World foo=bar\\n\"},\n\t\t\t\t{-32, \"<nil> -32 Hello World foo=bar\\n\"},\n\t\t\t\t{-321, \"<nil> -32 Hello World foo=bar\\n\"},\n\t\t\t\t{12, \"<nil> 12 Hello World foo=bar\\n\"},\n\t\t\t\t{123, \"<nil> 123 Hello World foo=bar\\n\"},\n\t\t\t\t{1234, \"<nil> 123 Hello World foo=bar\\n\"},\n\t\t\t}\n\t\t\tfor i, c := range cases {\n\t\t\t\tc := c\n\t\t\t\tt.Run(fmt.Sprintf(\"case %d\", i), func(t *testing.T) {\n\t\t\t\t\tbuf := &bytes.Buffer{}\n\t\t\t\t\tout := zerolog.NewConsoleWriter()\n\t\t\t\t\tout.NoColor = true\n\t\t\t\t\tout.Out = buf\n\t\t\t\t\tlog := zerolog.New(out)\n\n\t\t\t\t\tlog.Debug().Interface(\"level\", c.field).Str(\"foo\", \"bar\").Msg(\"Hello World\")\n\n\t\t\t\t\tactualOutput := buf.String()\n\t\t\t\t\tif actualOutput != c.output {\n\t\t\t\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, c.output)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunc TestConsoleWriterConfiguration(t *testing.T) {\n\tt.Run(\"Sets TimeFormat\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true, TimeFormat: time.RFC3339}\n\n\t\tts := time.Unix(0, 0)\n\t\td := ts.UTC().Format(time.RFC3339)\n\t\tevt := `{\"time\": \"` + d + `\", \"level\": \"info\", \"message\": \"Foobar\"}`\n\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := ts.Format(time.RFC3339) + \" INF Foobar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Sets TimeFormat and TimeLocation\", func(t *testing.T) {\n\t\tlocs := []*time.Location{ time.Local, time.UTC }\n\n\t\tfor _, location := range locs {\n\t\t\tbuf := &bytes.Buffer{}\n\t\t\tw := zerolog.ConsoleWriter{\n\t\t\t\tOut: buf,\n\t\t\t\tNoColor: true,\n\t\t\t\tTimeFormat: time.RFC3339,\n\t\t\t\tTimeLocation: location,\n\t\t\t}\n\n\t\t\tts := time.Unix(0, 0)\n\t\t\td := ts.UTC().Format(time.RFC3339)\n\t\t\tevt := `{\"time\": \"` + d + `\", \"level\": \"info\", \"message\": \"Foobar\"}`\n\n\t\t\t_, err := w.Write([]byte(evt))\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t\t}\n\n\t\t\texpectedOutput := ts.In(location).Format(time.RFC3339) + \" INF Foobar\\n\"\n\t\t\tactualOutput := buf.String()\n\t\t\tif actualOutput != expectedOutput {\n\t\t\t\tt.Errorf(\"Unexpected output %q, want: %q (location=%s)\", actualOutput, expectedOutput, location)\n\t\t\t}\n\t\t}\n\t})\n\n\tt.Run(\"Sets PartsOrder\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true, PartsOrder: []string{\"message\", \"level\"}}\n\n\t\tevt := `{\"level\": \"info\", \"message\": \"Foobar\"}`\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"Foobar INF\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Sets PartsExclude\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true, PartsExclude: []string{\"time\"}}\n\n\t\td := time.Unix(0, 0).UTC().Format(time.RFC3339)\n\t\tevt := `{\"time\": \"` + d + `\", \"level\": \"info\", \"message\": \"Foobar\"}`\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"INF Foobar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Sets FieldsOrder\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true, FieldsOrder: []string{\"zebra\", \"aardvark\"}}\n\n\t\tevt := `{\"level\": \"info\", \"message\": \"Zoo\", \"aardvark\": \"Able\", \"mussel\": \"Mountain\", \"zebra\": \"Zulu\"}`\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"<nil> INF Zoo zebra=Zulu aardvark=Able mussel=Mountain\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Sets FieldsExclude\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true, FieldsExclude: []string{\"foo\"}}\n\n\t\tevt := `{\"level\": \"info\", \"message\": \"Foobar\", \"foo\":\"bar\", \"baz\":\"quux\"}`\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"<nil> INF Foobar baz=quux\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Sets FormatExtra\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{\n\t\t\tOut: buf, NoColor: true, PartsOrder: []string{\"level\", \"message\"},\n\t\t\tFormatExtra: func(evt map[string]interface{}, buf *bytes.Buffer) error {\n\t\t\t\tbuf.WriteString(\"\\nAdditional stacktrace\")\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\n\t\tevt := `{\"level\": \"info\", \"message\": \"Foobar\"}`\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"INF Foobar\\nAdditional stacktrace\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Sets FormatPrepare\", func(t *testing.T) {\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{\n\t\t\tOut: buf, NoColor: true, PartsOrder: []string{\"level\", \"message\"},\n\t\t\tFormatPrepare: func(evt map[string]interface{}) error {\n\t\t\t\tevt[\"message\"] = fmt.Sprintf(\"msg=%s\", evt[\"message\"])\n\t\t\t\treturn nil\n\t\t\t},\n\t\t}\n\n\t\tevt := `{\"level\": \"info\", \"message\": \"Foobar\"}`\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\texpectedOutput := \"INF msg=Foobar\\n\"\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n\n\tt.Run(\"Uses local time for console writer without time zone\", func(t *testing.T) {\n\t\t// Regression test for issue #483 (check there for more details)\n\n\t\ttimeFormat := \"2006-01-02 15:04:05\"\n\t\texpectedOutput := \"2022-10-20 20:24:50 INF Foobar\\n\"\n\t\tevt := `{\"time\": \"2022-10-20 20:24:50\", \"level\": \"info\", \"message\": \"Foobar\"}`\n\n\t\tof := zerolog.TimeFieldFormat\n\t\tdefer func() {\n\t\t\tzerolog.TimeFieldFormat = of\n\t\t}()\n\t\tzerolog.TimeFieldFormat = timeFormat\n\n\t\tbuf := &bytes.Buffer{}\n\t\tw := zerolog.ConsoleWriter{Out: buf, NoColor: true, TimeFormat: timeFormat}\n\t\t_, err := w.Write([]byte(evt))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Unexpected error when writing output: %s\", err)\n\t\t}\n\n\t\tactualOutput := buf.String()\n\t\tif actualOutput != expectedOutput {\n\t\t\tt.Errorf(\"Unexpected output %q, want: %q\", actualOutput, expectedOutput)\n\t\t}\n\t})\n}\n\nfunc BenchmarkConsoleWriter(b *testing.B) {\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\n\tvar msg = []byte(`{\"level\": \"info\", \"foo\": \"bar\", \"message\": \"HELLO\", \"time\": \"1990-01-01\"}`)\n\n\tw := zerolog.ConsoleWriter{Out: io.Discard, NoColor: false}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tw.Write(msg)\n\t}\n}\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 14.97265625,
          "content": "package zerolog\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net\"\n\t\"time\"\n)\n\n// Context configures a new sub-logger with contextual fields.\ntype Context struct {\n\tl Logger\n}\n\n// Logger returns the logger with the context previously set.\nfunc (c Context) Logger() Logger {\n\treturn c.l\n}\n\n// Fields is a helper function to use a map or slice to set fields using type assertion.\n// Only map[string]interface{} and []interface{} are accepted. []interface{} must\n// alternate string keys and arbitrary values, and extraneous ones are ignored.\nfunc (c Context) Fields(fields interface{}) Context {\n\tc.l.context = appendFields(c.l.context, fields, c.l.stack)\n\treturn c\n}\n\n// Dict adds the field key with the dict to the logger context.\nfunc (c Context) Dict(key string, dict *Event) Context {\n\tdict.buf = enc.AppendEndMarker(dict.buf)\n\tc.l.context = append(enc.AppendKey(c.l.context, key), dict.buf...)\n\tputEvent(dict)\n\treturn c\n}\n\n// Array adds the field key with an array to the event context.\n// Use zerolog.Arr() to create the array or pass a type that\n// implement the LogArrayMarshaler interface.\nfunc (c Context) Array(key string, arr LogArrayMarshaler) Context {\n\tc.l.context = enc.AppendKey(c.l.context, key)\n\tif arr, ok := arr.(*Array); ok {\n\t\tc.l.context = arr.write(c.l.context)\n\t\treturn c\n\t}\n\tvar a *Array\n\tif aa, ok := arr.(*Array); ok {\n\t\ta = aa\n\t} else {\n\t\ta = Arr()\n\t\tarr.MarshalZerologArray(a)\n\t}\n\tc.l.context = a.write(c.l.context)\n\treturn c\n}\n\n// Object marshals an object that implement the LogObjectMarshaler interface.\nfunc (c Context) Object(key string, obj LogObjectMarshaler) Context {\n\te := newEvent(LevelWriterAdapter{io.Discard}, 0)\n\te.Object(key, obj)\n\tc.l.context = enc.AppendObjectData(c.l.context, e.buf)\n\tputEvent(e)\n\treturn c\n}\n\n// EmbedObject marshals and Embeds an object that implement the LogObjectMarshaler interface.\nfunc (c Context) EmbedObject(obj LogObjectMarshaler) Context {\n\te := newEvent(LevelWriterAdapter{io.Discard}, 0)\n\te.EmbedObject(obj)\n\tc.l.context = enc.AppendObjectData(c.l.context, e.buf)\n\tputEvent(e)\n\treturn c\n}\n\n// Str adds the field key with val as a string to the logger context.\nfunc (c Context) Str(key, val string) Context {\n\tc.l.context = enc.AppendString(enc.AppendKey(c.l.context, key), val)\n\treturn c\n}\n\n// Strs adds the field key with val as a string to the logger context.\nfunc (c Context) Strs(key string, vals []string) Context {\n\tc.l.context = enc.AppendStrings(enc.AppendKey(c.l.context, key), vals)\n\treturn c\n}\n\n// Stringer adds the field key with val.String() (or null if val is nil) to the logger context.\nfunc (c Context) Stringer(key string, val fmt.Stringer) Context {\n\tif val != nil {\n\t\tc.l.context = enc.AppendString(enc.AppendKey(c.l.context, key), val.String())\n\t\treturn c\n\t}\n\n\tc.l.context = enc.AppendInterface(enc.AppendKey(c.l.context, key), nil)\n\treturn c\n}\n\n// Bytes adds the field key with val as a []byte to the logger context.\nfunc (c Context) Bytes(key string, val []byte) Context {\n\tc.l.context = enc.AppendBytes(enc.AppendKey(c.l.context, key), val)\n\treturn c\n}\n\n// Hex adds the field key with val as a hex string to the logger context.\nfunc (c Context) Hex(key string, val []byte) Context {\n\tc.l.context = enc.AppendHex(enc.AppendKey(c.l.context, key), val)\n\treturn c\n}\n\n// RawJSON adds already encoded JSON to context.\n//\n// No sanity check is performed on b; it must not contain carriage returns and\n// be valid JSON.\nfunc (c Context) RawJSON(key string, b []byte) Context {\n\tc.l.context = appendJSON(enc.AppendKey(c.l.context, key), b)\n\treturn c\n}\n\n// AnErr adds the field key with serialized err to the logger context.\nfunc (c Context) AnErr(key string, err error) Context {\n\tswitch m := ErrorMarshalFunc(err).(type) {\n\tcase nil:\n\t\treturn c\n\tcase LogObjectMarshaler:\n\t\treturn c.Object(key, m)\n\tcase error:\n\t\tif m == nil || isNilValue(m) {\n\t\t\treturn c\n\t\t} else {\n\t\t\treturn c.Str(key, m.Error())\n\t\t}\n\tcase string:\n\t\treturn c.Str(key, m)\n\tdefault:\n\t\treturn c.Interface(key, m)\n\t}\n}\n\n// Errs adds the field key with errs as an array of serialized errors to the\n// logger context.\nfunc (c Context) Errs(key string, errs []error) Context {\n\tarr := Arr()\n\tfor _, err := range errs {\n\t\tswitch m := ErrorMarshalFunc(err).(type) {\n\t\tcase LogObjectMarshaler:\n\t\t\tarr = arr.Object(m)\n\t\tcase error:\n\t\t\tif m == nil || isNilValue(m) {\n\t\t\t\tarr = arr.Interface(nil)\n\t\t\t} else {\n\t\t\t\tarr = arr.Str(m.Error())\n\t\t\t}\n\t\tcase string:\n\t\t\tarr = arr.Str(m)\n\t\tdefault:\n\t\t\tarr = arr.Interface(m)\n\t\t}\n\t}\n\n\treturn c.Array(key, arr)\n}\n\n// Err adds the field \"error\" with serialized err to the logger context.\nfunc (c Context) Err(err error) Context {\n\tif c.l.stack && ErrorStackMarshaler != nil {\n\t\tswitch m := ErrorStackMarshaler(err).(type) {\n\t\tcase nil:\n\t\tcase LogObjectMarshaler:\n\t\t\tc = c.Object(ErrorStackFieldName, m)\n\t\tcase error:\n\t\t\tif m != nil && !isNilValue(m) {\n\t\t\t\tc = c.Str(ErrorStackFieldName, m.Error())\n\t\t\t}\n\t\tcase string:\n\t\t\tc = c.Str(ErrorStackFieldName, m)\n\t\tdefault:\n\t\t\tc = c.Interface(ErrorStackFieldName, m)\n\t\t}\n\t}\n\n\treturn c.AnErr(ErrorFieldName, err)\n}\n\n// Ctx adds the context.Context to the logger context. The context.Context is\n// not rendered in the error message, but is made available for hooks to use.\n// A typical use case is to extract tracing information from the\n// context.Context.\nfunc (c Context) Ctx(ctx context.Context) Context {\n\tc.l.ctx = ctx\n\treturn c\n}\n\n// Bool adds the field key with val as a bool to the logger context.\nfunc (c Context) Bool(key string, b bool) Context {\n\tc.l.context = enc.AppendBool(enc.AppendKey(c.l.context, key), b)\n\treturn c\n}\n\n// Bools adds the field key with val as a []bool to the logger context.\nfunc (c Context) Bools(key string, b []bool) Context {\n\tc.l.context = enc.AppendBools(enc.AppendKey(c.l.context, key), b)\n\treturn c\n}\n\n// Int adds the field key with i as a int to the logger context.\nfunc (c Context) Int(key string, i int) Context {\n\tc.l.context = enc.AppendInt(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Ints adds the field key with i as a []int to the logger context.\nfunc (c Context) Ints(key string, i []int) Context {\n\tc.l.context = enc.AppendInts(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Int8 adds the field key with i as a int8 to the logger context.\nfunc (c Context) Int8(key string, i int8) Context {\n\tc.l.context = enc.AppendInt8(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Ints8 adds the field key with i as a []int8 to the logger context.\nfunc (c Context) Ints8(key string, i []int8) Context {\n\tc.l.context = enc.AppendInts8(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Int16 adds the field key with i as a int16 to the logger context.\nfunc (c Context) Int16(key string, i int16) Context {\n\tc.l.context = enc.AppendInt16(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Ints16 adds the field key with i as a []int16 to the logger context.\nfunc (c Context) Ints16(key string, i []int16) Context {\n\tc.l.context = enc.AppendInts16(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Int32 adds the field key with i as a int32 to the logger context.\nfunc (c Context) Int32(key string, i int32) Context {\n\tc.l.context = enc.AppendInt32(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Ints32 adds the field key with i as a []int32 to the logger context.\nfunc (c Context) Ints32(key string, i []int32) Context {\n\tc.l.context = enc.AppendInts32(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Int64 adds the field key with i as a int64 to the logger context.\nfunc (c Context) Int64(key string, i int64) Context {\n\tc.l.context = enc.AppendInt64(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Ints64 adds the field key with i as a []int64 to the logger context.\nfunc (c Context) Ints64(key string, i []int64) Context {\n\tc.l.context = enc.AppendInts64(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uint adds the field key with i as a uint to the logger context.\nfunc (c Context) Uint(key string, i uint) Context {\n\tc.l.context = enc.AppendUint(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uints adds the field key with i as a []uint to the logger context.\nfunc (c Context) Uints(key string, i []uint) Context {\n\tc.l.context = enc.AppendUints(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uint8 adds the field key with i as a uint8 to the logger context.\nfunc (c Context) Uint8(key string, i uint8) Context {\n\tc.l.context = enc.AppendUint8(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uints8 adds the field key with i as a []uint8 to the logger context.\nfunc (c Context) Uints8(key string, i []uint8) Context {\n\tc.l.context = enc.AppendUints8(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uint16 adds the field key with i as a uint16 to the logger context.\nfunc (c Context) Uint16(key string, i uint16) Context {\n\tc.l.context = enc.AppendUint16(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uints16 adds the field key with i as a []uint16 to the logger context.\nfunc (c Context) Uints16(key string, i []uint16) Context {\n\tc.l.context = enc.AppendUints16(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uint32 adds the field key with i as a uint32 to the logger context.\nfunc (c Context) Uint32(key string, i uint32) Context {\n\tc.l.context = enc.AppendUint32(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uints32 adds the field key with i as a []uint32 to the logger context.\nfunc (c Context) Uints32(key string, i []uint32) Context {\n\tc.l.context = enc.AppendUints32(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uint64 adds the field key with i as a uint64 to the logger context.\nfunc (c Context) Uint64(key string, i uint64) Context {\n\tc.l.context = enc.AppendUint64(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Uints64 adds the field key with i as a []uint64 to the logger context.\nfunc (c Context) Uints64(key string, i []uint64) Context {\n\tc.l.context = enc.AppendUints64(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Float32 adds the field key with f as a float32 to the logger context.\nfunc (c Context) Float32(key string, f float32) Context {\n\tc.l.context = enc.AppendFloat32(enc.AppendKey(c.l.context, key), f, FloatingPointPrecision)\n\treturn c\n}\n\n// Floats32 adds the field key with f as a []float32 to the logger context.\nfunc (c Context) Floats32(key string, f []float32) Context {\n\tc.l.context = enc.AppendFloats32(enc.AppendKey(c.l.context, key), f, FloatingPointPrecision)\n\treturn c\n}\n\n// Float64 adds the field key with f as a float64 to the logger context.\nfunc (c Context) Float64(key string, f float64) Context {\n\tc.l.context = enc.AppendFloat64(enc.AppendKey(c.l.context, key), f, FloatingPointPrecision)\n\treturn c\n}\n\n// Floats64 adds the field key with f as a []float64 to the logger context.\nfunc (c Context) Floats64(key string, f []float64) Context {\n\tc.l.context = enc.AppendFloats64(enc.AppendKey(c.l.context, key), f, FloatingPointPrecision)\n\treturn c\n}\n\ntype timestampHook struct{}\n\nfunc (ts timestampHook) Run(e *Event, level Level, msg string) {\n\te.Timestamp()\n}\n\nvar th = timestampHook{}\n\n// Timestamp adds the current local time to the logger context with the \"time\" key, formatted using zerolog.TimeFieldFormat.\n// To customize the key name, change zerolog.TimestampFieldName.\n// To customize the time format, change zerolog.TimeFieldFormat.\n//\n// NOTE: It won't dedupe the \"time\" key if the *Context has one already.\nfunc (c Context) Timestamp() Context {\n\tc.l = c.l.Hook(th)\n\treturn c\n}\n\n// Time adds the field key with t formatted as string using zerolog.TimeFieldFormat.\nfunc (c Context) Time(key string, t time.Time) Context {\n\tc.l.context = enc.AppendTime(enc.AppendKey(c.l.context, key), t, TimeFieldFormat)\n\treturn c\n}\n\n// Times adds the field key with t formatted as string using zerolog.TimeFieldFormat.\nfunc (c Context) Times(key string, t []time.Time) Context {\n\tc.l.context = enc.AppendTimes(enc.AppendKey(c.l.context, key), t, TimeFieldFormat)\n\treturn c\n}\n\n// Dur adds the fields key with d divided by unit and stored as a float.\nfunc (c Context) Dur(key string, d time.Duration) Context {\n\tc.l.context = enc.AppendDuration(enc.AppendKey(c.l.context, key), d, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\treturn c\n}\n\n// Durs adds the fields key with d divided by unit and stored as a float.\nfunc (c Context) Durs(key string, d []time.Duration) Context {\n\tc.l.context = enc.AppendDurations(enc.AppendKey(c.l.context, key), d, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\treturn c\n}\n\n// Interface adds the field key with obj marshaled using reflection.\nfunc (c Context) Interface(key string, i interface{}) Context {\n\tif obj, ok := i.(LogObjectMarshaler); ok {\n\t\treturn c.Object(key, obj)\n\t}\n\tc.l.context = enc.AppendInterface(enc.AppendKey(c.l.context, key), i)\n\treturn c\n}\n\n// Type adds the field key with val's type using reflection.\nfunc (c Context) Type(key string, val interface{}) Context {\n\tc.l.context = enc.AppendType(enc.AppendKey(c.l.context, key), val)\n\treturn c\n}\n\n// Any is a wrapper around Context.Interface.\nfunc (c Context) Any(key string, i interface{}) Context {\n\treturn c.Interface(key, i)\n}\n\n// Reset removes all the context fields.\nfunc (c Context) Reset() Context {\n\tc.l.context = enc.AppendBeginMarker(make([]byte, 0, 500))\n\treturn c\n}\n\ntype callerHook struct {\n\tcallerSkipFrameCount int\n}\n\nfunc newCallerHook(skipFrameCount int) callerHook {\n\treturn callerHook{callerSkipFrameCount: skipFrameCount}\n}\n\nfunc (ch callerHook) Run(e *Event, level Level, msg string) {\n\tswitch ch.callerSkipFrameCount {\n\tcase useGlobalSkipFrameCount:\n\t\t// Extra frames to skip (added by hook infra).\n\t\te.caller(CallerSkipFrameCount + contextCallerSkipFrameCount)\n\tdefault:\n\t\t// Extra frames to skip (added by hook infra).\n\t\te.caller(ch.callerSkipFrameCount + contextCallerSkipFrameCount)\n\t}\n}\n\n// useGlobalSkipFrameCount acts as a flag to informat callerHook.Run\n// to use the global CallerSkipFrameCount.\nconst useGlobalSkipFrameCount = math.MinInt32\n\n// ch is the default caller hook using the global CallerSkipFrameCount.\nvar ch = newCallerHook(useGlobalSkipFrameCount)\n\n// Caller adds the file:line of the caller with the zerolog.CallerFieldName key.\nfunc (c Context) Caller() Context {\n\tc.l = c.l.Hook(ch)\n\treturn c\n}\n\n// CallerWithSkipFrameCount adds the file:line of the caller with the zerolog.CallerFieldName key.\n// The specified skipFrameCount int will override the global CallerSkipFrameCount for this context's respective logger.\n// If set to -1 the global CallerSkipFrameCount will be used.\nfunc (c Context) CallerWithSkipFrameCount(skipFrameCount int) Context {\n\tc.l = c.l.Hook(newCallerHook(skipFrameCount))\n\treturn c\n}\n\n// Stack enables stack trace printing for the error passed to Err().\nfunc (c Context) Stack() Context {\n\tc.l.stack = true\n\treturn c\n}\n\n// IPAddr adds IPv4 or IPv6 Address to the context\nfunc (c Context) IPAddr(key string, ip net.IP) Context {\n\tc.l.context = enc.AppendIPAddr(enc.AppendKey(c.l.context, key), ip)\n\treturn c\n}\n\n// IPPrefix adds IPv4 or IPv6 Prefix (address and mask) to the context\nfunc (c Context) IPPrefix(key string, pfx net.IPNet) Context {\n\tc.l.context = enc.AppendIPPrefix(enc.AppendKey(c.l.context, key), pfx)\n\treturn c\n}\n\n// MACAddr adds MAC address to the context\nfunc (c Context) MACAddr(key string, ha net.HardwareAddr) Context {\n\tc.l.context = enc.AppendMACAddr(enc.AppendKey(c.l.context, key), ha)\n\treturn c\n}\n"
        },
        {
          "name": "ctx.go",
          "type": "blob",
          "size": 1.46875,
          "content": "package zerolog\n\nimport (\n\t\"context\"\n)\n\nvar disabledLogger *Logger\n\nfunc init() {\n\tSetGlobalLevel(TraceLevel)\n\tl := Nop()\n\tdisabledLogger = &l\n}\n\ntype ctxKey struct{}\n\n// WithContext returns a copy of ctx with the receiver attached. The Logger\n// attached to the provided Context (if any) will not be effected.  If the\n// receiver's log level is Disabled it will only be attached to the returned\n// Context if the provided Context has a previously attached Logger. If the\n// provided Context has no attached Logger, a Disabled Logger will not be\n// attached.\n//\n// Note: to modify the existing Logger attached to a Context (instead of\n// replacing it in a new Context), use UpdateContext with the following\n// notation:\n//\n//     ctx := r.Context()\n//     l := zerolog.Ctx(ctx)\n//     l.UpdateContext(func(c Context) Context {\n//         return c.Str(\"bar\", \"baz\")\n//     })\n//\nfunc (l Logger) WithContext(ctx context.Context) context.Context {\n\tif _, ok := ctx.Value(ctxKey{}).(*Logger); !ok && l.level == Disabled {\n\t\t// Do not store disabled logger.\n\t\treturn ctx\n\t}\n\treturn context.WithValue(ctx, ctxKey{}, &l)\n}\n\n// Ctx returns the Logger associated with the ctx. If no logger\n// is associated, DefaultContextLogger is returned, unless DefaultContextLogger\n// is nil, in which case a disabled logger is returned.\nfunc Ctx(ctx context.Context) *Logger {\n\tif l, ok := ctx.Value(ctxKey{}).(*Logger); ok {\n\t\treturn l\n\t} else if l = DefaultContextLogger; l != nil {\n\t\treturn l\n\t}\n\treturn disabledLogger\n}\n"
        },
        {
          "name": "ctx_test.go",
          "type": "blob",
          "size": 2.3046875,
          "content": "package zerolog\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/rs/zerolog/internal/cbor\"\n)\n\nfunc TestCtx(t *testing.T) {\n\tlog := New(io.Discard)\n\tctx := log.WithContext(context.Background())\n\tlog2 := Ctx(ctx)\n\tif !reflect.DeepEqual(log, *log2) {\n\t\tt.Error(\"Ctx did not return the expected logger\")\n\t}\n\n\t// update\n\tlog = log.Level(InfoLevel)\n\tctx = log.WithContext(ctx)\n\tlog2 = Ctx(ctx)\n\tif !reflect.DeepEqual(log, *log2) {\n\t\tt.Error(\"Ctx did not return the expected logger\")\n\t}\n\n\tlog2 = Ctx(context.Background())\n\tif log2 != disabledLogger {\n\t\tt.Error(\"Ctx did not return the expected logger\")\n\t}\n\n\tDefaultContextLogger = &log\n\tt.Cleanup(func() { DefaultContextLogger = nil })\n\tlog2 = Ctx(context.Background())\n\tif log2 != &log {\n\t\tt.Error(\"Ctx did not return the expected logger\")\n\t}\n}\n\nfunc TestCtxDisabled(t *testing.T) {\n\tdl := New(io.Discard).Level(Disabled)\n\tctx := dl.WithContext(context.Background())\n\tif ctx != context.Background() {\n\t\tt.Error(\"WithContext stored a disabled logger\")\n\t}\n\n\tl := New(io.Discard).With().Str(\"foo\", \"bar\").Logger()\n\tctx = l.WithContext(ctx)\n\tif !reflect.DeepEqual(Ctx(ctx), &l) {\n\t\tt.Error(\"WithContext did not store logger\")\n\t}\n\n\tl.UpdateContext(func(c Context) Context {\n\t\treturn c.Str(\"bar\", \"baz\")\n\t})\n\tctx = l.WithContext(ctx)\n\tif !reflect.DeepEqual(Ctx(ctx), &l) {\n\t\tt.Error(\"WithContext did not store updated logger\")\n\t}\n\n\tl = l.Level(DebugLevel)\n\tctx = l.WithContext(ctx)\n\tif !reflect.DeepEqual(Ctx(ctx), &l) {\n\t\tt.Error(\"WithContext did not store copied logger\")\n\t}\n\n\tctx = dl.WithContext(ctx)\n\tif !reflect.DeepEqual(Ctx(ctx), &dl) {\n\t\tt.Error(\"WithContext did not override logger with a disabled logger\")\n\t}\n}\n\ntype logObjectMarshalerImpl struct {\n\tname string\n\tage  int\n}\n\nfunc (t logObjectMarshalerImpl) MarshalZerologObject(e *Event) {\n\te.Str(\"name\", \"custom_value\").Int(\"age\", t.age)\n}\n\nfunc Test_InterfaceLogObjectMarshaler(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlog := New(&buf)\n\tctx := log.WithContext(context.Background())\n\n\tlog2 := Ctx(ctx)\n\n\twithLog := log2.With().Interface(\"obj\", &logObjectMarshalerImpl{\n\t\tname: \"foo\",\n\t\tage:  29,\n\t}).Logger()\n\n\twithLog.Info().Msg(\"test\")\n\n\tif got, want := cbor.DecodeIfBinaryToString(buf.Bytes()), `{\"level\":\"info\",\"obj\":{\"name\":\"custom_value\",\"age\":29},\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"got %q, want %q\", got, want)\n\t}\n}\n"
        },
        {
          "name": "diode",
          "type": "tree",
          "content": null
        },
        {
          "name": "encoder.go",
          "type": "blob",
          "size": 2.2822265625,
          "content": "package zerolog\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype encoder interface {\n\tAppendArrayDelim(dst []byte) []byte\n\tAppendArrayEnd(dst []byte) []byte\n\tAppendArrayStart(dst []byte) []byte\n\tAppendBeginMarker(dst []byte) []byte\n\tAppendBool(dst []byte, val bool) []byte\n\tAppendBools(dst []byte, vals []bool) []byte\n\tAppendBytes(dst, s []byte) []byte\n\tAppendDuration(dst []byte, d time.Duration, unit time.Duration, useInt bool, precision int) []byte\n\tAppendDurations(dst []byte, vals []time.Duration, unit time.Duration, useInt bool, precision int) []byte\n\tAppendEndMarker(dst []byte) []byte\n\tAppendFloat32(dst []byte, val float32, precision int) []byte\n\tAppendFloat64(dst []byte, val float64, precision int) []byte\n\tAppendFloats32(dst []byte, vals []float32, precision int) []byte\n\tAppendFloats64(dst []byte, vals []float64, precision int) []byte\n\tAppendHex(dst, s []byte) []byte\n\tAppendIPAddr(dst []byte, ip net.IP) []byte\n\tAppendIPPrefix(dst []byte, pfx net.IPNet) []byte\n\tAppendInt(dst []byte, val int) []byte\n\tAppendInt16(dst []byte, val int16) []byte\n\tAppendInt32(dst []byte, val int32) []byte\n\tAppendInt64(dst []byte, val int64) []byte\n\tAppendInt8(dst []byte, val int8) []byte\n\tAppendInterface(dst []byte, i interface{}) []byte\n\tAppendInts(dst []byte, vals []int) []byte\n\tAppendInts16(dst []byte, vals []int16) []byte\n\tAppendInts32(dst []byte, vals []int32) []byte\n\tAppendInts64(dst []byte, vals []int64) []byte\n\tAppendInts8(dst []byte, vals []int8) []byte\n\tAppendKey(dst []byte, key string) []byte\n\tAppendLineBreak(dst []byte) []byte\n\tAppendMACAddr(dst []byte, ha net.HardwareAddr) []byte\n\tAppendNil(dst []byte) []byte\n\tAppendObjectData(dst []byte, o []byte) []byte\n\tAppendString(dst []byte, s string) []byte\n\tAppendStrings(dst []byte, vals []string) []byte\n\tAppendTime(dst []byte, t time.Time, format string) []byte\n\tAppendTimes(dst []byte, vals []time.Time, format string) []byte\n\tAppendUint(dst []byte, val uint) []byte\n\tAppendUint16(dst []byte, val uint16) []byte\n\tAppendUint32(dst []byte, val uint32) []byte\n\tAppendUint64(dst []byte, val uint64) []byte\n\tAppendUint8(dst []byte, val uint8) []byte\n\tAppendUints(dst []byte, vals []uint) []byte\n\tAppendUints16(dst []byte, vals []uint16) []byte\n\tAppendUints32(dst []byte, vals []uint32) []byte\n\tAppendUints64(dst []byte, vals []uint64) []byte\n\tAppendUints8(dst []byte, vals []uint8) []byte\n}\n"
        },
        {
          "name": "encoder_cbor.go",
          "type": "blob",
          "size": 1.005859375,
          "content": "// +build binary_log\n\npackage zerolog\n\n// This file contains bindings to do binary encoding.\n\nimport (\n\t\"github.com/rs/zerolog/internal/cbor\"\n)\n\nvar (\n\t_ encoder = (*cbor.Encoder)(nil)\n\n\tenc = cbor.Encoder{}\n)\n\nfunc init() {\n\t// using closure to reflect the changes at runtime.\n\tcbor.JSONMarshalFunc = func(v interface{}) ([]byte, error) {\n\t\treturn InterfaceMarshalFunc(v)\n\t}\n}\n\nfunc appendJSON(dst []byte, j []byte) []byte {\n\treturn cbor.AppendEmbeddedJSON(dst, j)\n}\nfunc appendCBOR(dst []byte, c []byte) []byte {\n\treturn cbor.AppendEmbeddedCBOR(dst, c)\n}\n\n// decodeIfBinaryToString - converts a binary formatted log msg to a\n// JSON formatted String Log message.\nfunc decodeIfBinaryToString(in []byte) string {\n\treturn cbor.DecodeIfBinaryToString(in)\n}\n\nfunc decodeObjectToStr(in []byte) string {\n\treturn cbor.DecodeObjectToStr(in)\n}\n\n// decodeIfBinaryToBytes - converts a binary formatted log msg to a\n// JSON formatted Bytes Log message.\nfunc decodeIfBinaryToBytes(in []byte) []byte {\n\treturn cbor.DecodeIfBinaryToBytes(in)\n}\n"
        },
        {
          "name": "encoder_json.go",
          "type": "blob",
          "size": 0.97265625,
          "content": "// +build !binary_log\n\npackage zerolog\n\n// encoder_json.go file contains bindings to generate\n// JSON encoded byte stream.\n\nimport (\n\t\"encoding/base64\"\n\t\"github.com/rs/zerolog/internal/json\"\n)\n\nvar (\n\t_ encoder = (*json.Encoder)(nil)\n\n\tenc = json.Encoder{}\n)\n\nfunc init() {\n\t// using closure to reflect the changes at runtime.\n\tjson.JSONMarshalFunc = func(v interface{}) ([]byte, error) {\n\t\treturn InterfaceMarshalFunc(v)\n\t}\n}\n\nfunc appendJSON(dst []byte, j []byte) []byte {\n\treturn append(dst, j...)\n}\nfunc appendCBOR(dst []byte, cbor []byte) []byte {\n\tdst = append(dst, []byte(\"\\\"data:application/cbor;base64,\")...)\n\tl := len(dst)\n\tenc := base64.StdEncoding\n\tn := enc.EncodedLen(len(cbor))\n\tfor i := 0; i < n; i++ {\n\t\tdst = append(dst, '.')\n\t}\n\tenc.Encode(dst[l:], cbor)\n\treturn append(dst, '\"')\n}\n\nfunc decodeIfBinaryToString(in []byte) string {\n\treturn string(in)\n}\n\nfunc decodeObjectToStr(in []byte) string {\n\treturn string(in)\n}\n\nfunc decodeIfBinaryToBytes(in []byte) []byte {\n\treturn in\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 20.8056640625,
          "content": "package zerolog\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar eventPool = &sync.Pool{\n\tNew: func() interface{} {\n\t\treturn &Event{\n\t\t\tbuf: make([]byte, 0, 500),\n\t\t}\n\t},\n}\n\n// Event represents a log event. It is instanced by one of the level method of\n// Logger and finalized by the Msg or Msgf method.\ntype Event struct {\n\tbuf       []byte\n\tw         LevelWriter\n\tlevel     Level\n\tdone      func(msg string)\n\tstack     bool            // enable error stack trace\n\tch        []Hook          // hooks from context\n\tskipFrame int             // The number of additional frames to skip when printing the caller.\n\tctx       context.Context // Optional Go context for event\n}\n\nfunc putEvent(e *Event) {\n\t// Proper usage of a sync.Pool requires each entry to have approximately\n\t// the same memory cost. To obtain this property when the stored type\n\t// contains a variably-sized buffer, we add a hard limit on the maximum buffer\n\t// to place back in the pool.\n\t//\n\t// See https://golang.org/issue/23199\n\tconst maxSize = 1 << 16 // 64KiB\n\tif cap(e.buf) > maxSize {\n\t\treturn\n\t}\n\teventPool.Put(e)\n}\n\n// LogObjectMarshaler provides a strongly-typed and encoding-agnostic interface\n// to be implemented by types used with Event/Context's Object methods.\ntype LogObjectMarshaler interface {\n\tMarshalZerologObject(e *Event)\n}\n\n// LogArrayMarshaler provides a strongly-typed and encoding-agnostic interface\n// to be implemented by types used with Event/Context's Array methods.\ntype LogArrayMarshaler interface {\n\tMarshalZerologArray(a *Array)\n}\n\nfunc newEvent(w LevelWriter, level Level) *Event {\n\te := eventPool.Get().(*Event)\n\te.buf = e.buf[:0]\n\te.ch = nil\n\te.buf = enc.AppendBeginMarker(e.buf)\n\te.w = w\n\te.level = level\n\te.stack = false\n\te.skipFrame = 0\n\treturn e\n}\n\nfunc (e *Event) write() (err error) {\n\tif e == nil {\n\t\treturn nil\n\t}\n\tif e.level != Disabled {\n\t\te.buf = enc.AppendEndMarker(e.buf)\n\t\te.buf = enc.AppendLineBreak(e.buf)\n\t\tif e.w != nil {\n\t\t\t_, err = e.w.WriteLevel(e.level, e.buf)\n\t\t}\n\t}\n\tputEvent(e)\n\treturn\n}\n\n// Enabled return false if the *Event is going to be filtered out by\n// log level or sampling.\nfunc (e *Event) Enabled() bool {\n\treturn e != nil && e.level != Disabled\n}\n\n// Discard disables the event so Msg(f) won't print it.\nfunc (e *Event) Discard() *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.level = Disabled\n\treturn nil\n}\n\n// Msg sends the *Event with msg added as the message field if not empty.\n//\n// NOTICE: once this method is called, the *Event should be disposed.\n// Calling Msg twice can have unexpected result.\nfunc (e *Event) Msg(msg string) {\n\tif e == nil {\n\t\treturn\n\t}\n\te.msg(msg)\n}\n\n// Send is equivalent to calling Msg(\"\").\n//\n// NOTICE: once this method is called, the *Event should be disposed.\nfunc (e *Event) Send() {\n\tif e == nil {\n\t\treturn\n\t}\n\te.msg(\"\")\n}\n\n// Msgf sends the event with formatted msg added as the message field if not empty.\n//\n// NOTICE: once this method is called, the *Event should be disposed.\n// Calling Msgf twice can have unexpected result.\nfunc (e *Event) Msgf(format string, v ...interface{}) {\n\tif e == nil {\n\t\treturn\n\t}\n\te.msg(fmt.Sprintf(format, v...))\n}\n\nfunc (e *Event) MsgFunc(createMsg func() string) {\n\tif e == nil {\n\t\treturn\n\t}\n\te.msg(createMsg())\n}\n\nfunc (e *Event) msg(msg string) {\n\tfor _, hook := range e.ch {\n\t\thook.Run(e, e.level, msg)\n\t}\n\tif msg != \"\" {\n\t\te.buf = enc.AppendString(enc.AppendKey(e.buf, MessageFieldName), msg)\n\t}\n\tif e.done != nil {\n\t\tdefer e.done(msg)\n\t}\n\tif err := e.write(); err != nil {\n\t\tif ErrorHandler != nil {\n\t\t\tErrorHandler(err)\n\t\t} else {\n\t\t\tfmt.Fprintf(os.Stderr, \"zerolog: could not write event: %v\\n\", err)\n\t\t}\n\t}\n}\n\n// Fields is a helper function to use a map or slice to set fields using type assertion.\n// Only map[string]interface{} and []interface{} are accepted. []interface{} must\n// alternate string keys and arbitrary values, and extraneous ones are ignored.\nfunc (e *Event) Fields(fields interface{}) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = appendFields(e.buf, fields, e.stack)\n\treturn e\n}\n\n// Dict adds the field key with a dict to the event context.\n// Use zerolog.Dict() to create the dictionary.\nfunc (e *Event) Dict(key string, dict *Event) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tdict.buf = enc.AppendEndMarker(dict.buf)\n\te.buf = append(enc.AppendKey(e.buf, key), dict.buf...)\n\tputEvent(dict)\n\treturn e\n}\n\n// Dict creates an Event to be used with the *Event.Dict method.\n// Call usual field methods like Str, Int etc to add fields to this\n// event and give it as argument the *Event.Dict method.\nfunc Dict() *Event {\n\treturn newEvent(nil, 0)\n}\n\n// Array adds the field key with an array to the event context.\n// Use zerolog.Arr() to create the array or pass a type that\n// implement the LogArrayMarshaler interface.\nfunc (e *Event) Array(key string, arr LogArrayMarshaler) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendKey(e.buf, key)\n\tvar a *Array\n\tif aa, ok := arr.(*Array); ok {\n\t\ta = aa\n\t} else {\n\t\ta = Arr()\n\t\tarr.MarshalZerologArray(a)\n\t}\n\te.buf = a.write(e.buf)\n\treturn e\n}\n\nfunc (e *Event) appendObject(obj LogObjectMarshaler) {\n\te.buf = enc.AppendBeginMarker(e.buf)\n\tobj.MarshalZerologObject(e)\n\te.buf = enc.AppendEndMarker(e.buf)\n}\n\n// Object marshals an object that implement the LogObjectMarshaler interface.\nfunc (e *Event) Object(key string, obj LogObjectMarshaler) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendKey(e.buf, key)\n\tif obj == nil {\n\t\te.buf = enc.AppendNil(e.buf)\n\n\t\treturn e\n\t}\n\n\te.appendObject(obj)\n\treturn e\n}\n\n// Func allows an anonymous func to run only if the event is enabled.\nfunc (e *Event) Func(f func(e *Event)) *Event {\n\tif e != nil && e.Enabled() {\n\t\tf(e)\n\t}\n\treturn e\n}\n\n// EmbedObject marshals an object that implement the LogObjectMarshaler interface.\nfunc (e *Event) EmbedObject(obj LogObjectMarshaler) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tif obj == nil {\n\t\treturn e\n\t}\n\tobj.MarshalZerologObject(e)\n\treturn e\n}\n\n// Str adds the field key with val as a string to the *Event context.\nfunc (e *Event) Str(key, val string) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendString(enc.AppendKey(e.buf, key), val)\n\treturn e\n}\n\n// Strs adds the field key with vals as a []string to the *Event context.\nfunc (e *Event) Strs(key string, vals []string) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendStrings(enc.AppendKey(e.buf, key), vals)\n\treturn e\n}\n\n// Stringer adds the field key with val.String() (or null if val is nil)\n// to the *Event context.\nfunc (e *Event) Stringer(key string, val fmt.Stringer) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendStringer(enc.AppendKey(e.buf, key), val)\n\treturn e\n}\n\n// Stringers adds the field key with vals where each individual val\n// is used as val.String() (or null if val is empty) to the *Event\n// context.\nfunc (e *Event) Stringers(key string, vals []fmt.Stringer) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendStringers(enc.AppendKey(e.buf, key), vals)\n\treturn e\n}\n\n// Bytes adds the field key with val as a string to the *Event context.\n//\n// Runes outside of normal ASCII ranges will be hex-encoded in the resulting\n// JSON.\nfunc (e *Event) Bytes(key string, val []byte) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendBytes(enc.AppendKey(e.buf, key), val)\n\treturn e\n}\n\n// Hex adds the field key with val as a hex string to the *Event context.\nfunc (e *Event) Hex(key string, val []byte) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendHex(enc.AppendKey(e.buf, key), val)\n\treturn e\n}\n\n// RawJSON adds already encoded JSON to the log line under key.\n//\n// No sanity check is performed on b; it must not contain carriage returns and\n// be valid JSON.\nfunc (e *Event) RawJSON(key string, b []byte) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = appendJSON(enc.AppendKey(e.buf, key), b)\n\treturn e\n}\n\n// RawCBOR adds already encoded CBOR to the log line under key.\n//\n// No sanity check is performed on b\n// Note: The full featureset of CBOR is supported as data will not be mapped to json but stored as data-url\nfunc (e *Event) RawCBOR(key string, b []byte) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = appendCBOR(enc.AppendKey(e.buf, key), b)\n\treturn e\n}\n\n// AnErr adds the field key with serialized err to the *Event context.\n// If err is nil, no field is added.\nfunc (e *Event) AnErr(key string, err error) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tswitch m := ErrorMarshalFunc(err).(type) {\n\tcase nil:\n\t\treturn e\n\tcase LogObjectMarshaler:\n\t\treturn e.Object(key, m)\n\tcase error:\n\t\tif m == nil || isNilValue(m) {\n\t\t\treturn e\n\t\t} else {\n\t\t\treturn e.Str(key, m.Error())\n\t\t}\n\tcase string:\n\t\treturn e.Str(key, m)\n\tdefault:\n\t\treturn e.Interface(key, m)\n\t}\n}\n\n// Errs adds the field key with errs as an array of serialized errors to the\n// *Event context.\nfunc (e *Event) Errs(key string, errs []error) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tarr := Arr()\n\tfor _, err := range errs {\n\t\tswitch m := ErrorMarshalFunc(err).(type) {\n\t\tcase LogObjectMarshaler:\n\t\t\tarr = arr.Object(m)\n\t\tcase error:\n\t\t\tarr = arr.Err(m)\n\t\tcase string:\n\t\t\tarr = arr.Str(m)\n\t\tdefault:\n\t\t\tarr = arr.Interface(m)\n\t\t}\n\t}\n\n\treturn e.Array(key, arr)\n}\n\n// Err adds the field \"error\" with serialized err to the *Event context.\n// If err is nil, no field is added.\n//\n// To customize the key name, change zerolog.ErrorFieldName.\n//\n// If Stack() has been called before and zerolog.ErrorStackMarshaler is defined,\n// the err is passed to ErrorStackMarshaler and the result is appended to the\n// zerolog.ErrorStackFieldName.\nfunc (e *Event) Err(err error) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tif e.stack && ErrorStackMarshaler != nil {\n\t\tswitch m := ErrorStackMarshaler(err).(type) {\n\t\tcase nil:\n\t\tcase LogObjectMarshaler:\n\t\t\te.Object(ErrorStackFieldName, m)\n\t\tcase error:\n\t\t\tif m != nil && !isNilValue(m) {\n\t\t\t\te.Str(ErrorStackFieldName, m.Error())\n\t\t\t}\n\t\tcase string:\n\t\t\te.Str(ErrorStackFieldName, m)\n\t\tdefault:\n\t\t\te.Interface(ErrorStackFieldName, m)\n\t\t}\n\t}\n\treturn e.AnErr(ErrorFieldName, err)\n}\n\n// Stack enables stack trace printing for the error passed to Err().\n//\n// ErrorStackMarshaler must be set for this method to do something.\nfunc (e *Event) Stack() *Event {\n\tif e != nil {\n\t\te.stack = true\n\t}\n\treturn e\n}\n\n// Ctx adds the Go Context to the *Event context.  The context is not rendered\n// in the output message, but is available to hooks and to Func() calls via the\n// GetCtx() accessor. A typical use case is to extract tracing information from\n// the Go Ctx.\nfunc (e *Event) Ctx(ctx context.Context) *Event {\n\tif e != nil {\n\t\te.ctx = ctx\n\t}\n\treturn e\n}\n\n// GetCtx retrieves the Go context.Context which is optionally stored in the\n// Event.  This allows Hooks and functions passed to Func() to retrieve values\n// which are stored in the context.Context.  This can be useful in tracing,\n// where span information is commonly propagated in the context.Context.\nfunc (e *Event) GetCtx() context.Context {\n\tif e == nil || e.ctx == nil {\n\t\treturn context.Background()\n\t}\n\treturn e.ctx\n}\n\n// Bool adds the field key with val as a bool to the *Event context.\nfunc (e *Event) Bool(key string, b bool) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendBool(enc.AppendKey(e.buf, key), b)\n\treturn e\n}\n\n// Bools adds the field key with val as a []bool to the *Event context.\nfunc (e *Event) Bools(key string, b []bool) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendBools(enc.AppendKey(e.buf, key), b)\n\treturn e\n}\n\n// Int adds the field key with i as a int to the *Event context.\nfunc (e *Event) Int(key string, i int) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInt(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Ints adds the field key with i as a []int to the *Event context.\nfunc (e *Event) Ints(key string, i []int) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInts(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Int8 adds the field key with i as a int8 to the *Event context.\nfunc (e *Event) Int8(key string, i int8) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInt8(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Ints8 adds the field key with i as a []int8 to the *Event context.\nfunc (e *Event) Ints8(key string, i []int8) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInts8(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Int16 adds the field key with i as a int16 to the *Event context.\nfunc (e *Event) Int16(key string, i int16) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInt16(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Ints16 adds the field key with i as a []int16 to the *Event context.\nfunc (e *Event) Ints16(key string, i []int16) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInts16(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Int32 adds the field key with i as a int32 to the *Event context.\nfunc (e *Event) Int32(key string, i int32) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInt32(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Ints32 adds the field key with i as a []int32 to the *Event context.\nfunc (e *Event) Ints32(key string, i []int32) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInts32(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Int64 adds the field key with i as a int64 to the *Event context.\nfunc (e *Event) Int64(key string, i int64) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInt64(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Ints64 adds the field key with i as a []int64 to the *Event context.\nfunc (e *Event) Ints64(key string, i []int64) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendInts64(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uint adds the field key with i as a uint to the *Event context.\nfunc (e *Event) Uint(key string, i uint) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUint(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uints adds the field key with i as a []int to the *Event context.\nfunc (e *Event) Uints(key string, i []uint) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUints(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uint8 adds the field key with i as a uint8 to the *Event context.\nfunc (e *Event) Uint8(key string, i uint8) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUint8(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uints8 adds the field key with i as a []int8 to the *Event context.\nfunc (e *Event) Uints8(key string, i []uint8) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUints8(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uint16 adds the field key with i as a uint16 to the *Event context.\nfunc (e *Event) Uint16(key string, i uint16) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUint16(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uints16 adds the field key with i as a []int16 to the *Event context.\nfunc (e *Event) Uints16(key string, i []uint16) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUints16(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uint32 adds the field key with i as a uint32 to the *Event context.\nfunc (e *Event) Uint32(key string, i uint32) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUint32(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uints32 adds the field key with i as a []int32 to the *Event context.\nfunc (e *Event) Uints32(key string, i []uint32) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUints32(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uint64 adds the field key with i as a uint64 to the *Event context.\nfunc (e *Event) Uint64(key string, i uint64) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUint64(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Uints64 adds the field key with i as a []int64 to the *Event context.\nfunc (e *Event) Uints64(key string, i []uint64) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendUints64(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Float32 adds the field key with f as a float32 to the *Event context.\nfunc (e *Event) Float32(key string, f float32) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendFloat32(enc.AppendKey(e.buf, key), f, FloatingPointPrecision)\n\treturn e\n}\n\n// Floats32 adds the field key with f as a []float32 to the *Event context.\nfunc (e *Event) Floats32(key string, f []float32) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendFloats32(enc.AppendKey(e.buf, key), f, FloatingPointPrecision)\n\treturn e\n}\n\n// Float64 adds the field key with f as a float64 to the *Event context.\nfunc (e *Event) Float64(key string, f float64) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendFloat64(enc.AppendKey(e.buf, key), f, FloatingPointPrecision)\n\treturn e\n}\n\n// Floats64 adds the field key with f as a []float64 to the *Event context.\nfunc (e *Event) Floats64(key string, f []float64) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendFloats64(enc.AppendKey(e.buf, key), f, FloatingPointPrecision)\n\treturn e\n}\n\n// Timestamp adds the current local time as UNIX timestamp to the *Event context with the \"time\" key.\n// To customize the key name, change zerolog.TimestampFieldName.\n//\n// NOTE: It won't dedupe the \"time\" key if the *Event (or *Context) has one\n// already.\nfunc (e *Event) Timestamp() *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendTime(enc.AppendKey(e.buf, TimestampFieldName), TimestampFunc(), TimeFieldFormat)\n\treturn e\n}\n\n// Time adds the field key with t formatted as string using zerolog.TimeFieldFormat.\nfunc (e *Event) Time(key string, t time.Time) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendTime(enc.AppendKey(e.buf, key), t, TimeFieldFormat)\n\treturn e\n}\n\n// Times adds the field key with t formatted as string using zerolog.TimeFieldFormat.\nfunc (e *Event) Times(key string, t []time.Time) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendTimes(enc.AppendKey(e.buf, key), t, TimeFieldFormat)\n\treturn e\n}\n\n// Dur adds the field key with duration d stored as zerolog.DurationFieldUnit.\n// If zerolog.DurationFieldInteger is true, durations are rendered as integer\n// instead of float.\nfunc (e *Event) Dur(key string, d time.Duration) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendDuration(enc.AppendKey(e.buf, key), d, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\treturn e\n}\n\n// Durs adds the field key with duration d stored as zerolog.DurationFieldUnit.\n// If zerolog.DurationFieldInteger is true, durations are rendered as integer\n// instead of float.\nfunc (e *Event) Durs(key string, d []time.Duration) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendDurations(enc.AppendKey(e.buf, key), d, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\treturn e\n}\n\n// TimeDiff adds the field key with positive duration between time t and start.\n// If time t is not greater than start, duration will be 0.\n// Duration format follows the same principle as Dur().\nfunc (e *Event) TimeDiff(key string, t time.Time, start time.Time) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tvar d time.Duration\n\tif t.After(start) {\n\t\td = t.Sub(start)\n\t}\n\te.buf = enc.AppendDuration(enc.AppendKey(e.buf, key), d, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\treturn e\n}\n\n// Any is a wrapper around Event.Interface.\nfunc (e *Event) Any(key string, i interface{}) *Event {\n\treturn e.Interface(key, i)\n}\n\n// Interface adds the field key with i marshaled using reflection.\nfunc (e *Event) Interface(key string, i interface{}) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tif obj, ok := i.(LogObjectMarshaler); ok {\n\t\treturn e.Object(key, obj)\n\t}\n\te.buf = enc.AppendInterface(enc.AppendKey(e.buf, key), i)\n\treturn e\n}\n\n// Type adds the field key with val's type using reflection.\nfunc (e *Event) Type(key string, val interface{}) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendType(enc.AppendKey(e.buf, key), val)\n\treturn e\n}\n\n// CallerSkipFrame instructs any future Caller calls to skip the specified number of frames.\n// This includes those added via hooks from the context.\nfunc (e *Event) CallerSkipFrame(skip int) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.skipFrame += skip\n\treturn e\n}\n\n// Caller adds the file:line of the caller with the zerolog.CallerFieldName key.\n// The argument skip is the number of stack frames to ascend\n// Skip If not passed, use the global variable CallerSkipFrameCount\nfunc (e *Event) Caller(skip ...int) *Event {\n\tsk := CallerSkipFrameCount\n\tif len(skip) > 0 {\n\t\tsk = skip[0] + CallerSkipFrameCount\n\t}\n\treturn e.caller(sk)\n}\n\nfunc (e *Event) caller(skip int) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\tpc, file, line, ok := runtime.Caller(skip + e.skipFrame)\n\tif !ok {\n\t\treturn e\n\t}\n\te.buf = enc.AppendString(enc.AppendKey(e.buf, CallerFieldName), CallerMarshalFunc(pc, file, line))\n\treturn e\n}\n\n// IPAddr adds IPv4 or IPv6 Address to the event\nfunc (e *Event) IPAddr(key string, ip net.IP) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendIPAddr(enc.AppendKey(e.buf, key), ip)\n\treturn e\n}\n\n// IPPrefix adds IPv4 or IPv6 Prefix (address and mask) to the event\nfunc (e *Event) IPPrefix(key string, pfx net.IPNet) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendIPPrefix(enc.AppendKey(e.buf, key), pfx)\n\treturn e\n}\n\n// MACAddr adds MAC address to the event\nfunc (e *Event) MACAddr(key string, ha net.HardwareAddr) *Event {\n\tif e == nil {\n\t\treturn e\n\t}\n\te.buf = enc.AppendMACAddr(enc.AppendKey(e.buf, key), ha)\n\treturn e\n}\n"
        },
        {
          "name": "event_test.go",
          "type": "blob",
          "size": 1.3125,
          "content": "// +build !binary_log\n\npackage zerolog\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype nilError struct{}\n\nfunc (nilError) Error() string {\n\treturn \"\"\n}\n\nfunc TestEvent_AnErr(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\terr  error\n\t\twant string\n\t}{\n\t\t{\"nil\", nil, `{}`},\n\t\t{\"error\", errors.New(\"test\"), `{\"err\":\"test\"}`},\n\t\t{\"nil interface\", func() *nilError { return nil }(), `{}`},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar buf bytes.Buffer\n\t\t\te := newEvent(LevelWriterAdapter{&buf}, DebugLevel)\n\t\t\te.AnErr(\"err\", tt.err)\n\t\t\t_ = e.write()\n\t\t\tif got, want := strings.TrimSpace(buf.String()), tt.want; got != want {\n\t\t\t\tt.Errorf(\"Event.AnErr() = %v, want %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEvent_ObjectWithNil(t *testing.T) {\n\tvar buf bytes.Buffer\n\te := newEvent(LevelWriterAdapter{&buf}, DebugLevel)\n\t_ = e.Object(\"obj\", nil)\n\t_ = e.write()\n\n\twant := `{\"obj\":null}`\n\tgot := strings.TrimSpace(buf.String())\n\tif got != want {\n\t\tt.Errorf(\"Event.Object() = %q, want %q\", got, want)\n\t}\n}\n\nfunc TestEvent_EmbedObjectWithNil(t *testing.T) {\n\tvar buf bytes.Buffer\n\te := newEvent(LevelWriterAdapter{&buf}, DebugLevel)\n\t_ = e.EmbedObject(nil)\n\t_ = e.write()\n\n\twant := \"{}\"\n\tgot := strings.TrimSpace(buf.String())\n\tif got != want {\n\t\tt.Errorf(\"Event.EmbedObject() = %q, want %q\", got, want)\n\t}\n}\n"
        },
        {
          "name": "example.jsonl",
          "type": "blob",
          "size": 0.7685546875,
          "content": "{\"time\":\"5:41PM\",\"level\":\"info\",\"message\":\"Starting listener\",\"listen\":\":8080\",\"pid\":37556}\n{\"time\":\"5:41PM\",\"level\":\"debug\",\"message\":\"Access\",\"database\":\"myapp\",\"host\":\"localhost:4962\",\"pid\":37556}\n{\"time\":\"5:41PM\",\"level\":\"info\",\"message\":\"Access\",\"method\":\"GET\",\"path\":\"/users\",\"pid\":37556,\"resp_time\":23}\n{\"time\":\"5:41PM\",\"level\":\"info\",\"message\":\"Access\",\"method\":\"POST\",\"path\":\"/posts\",\"pid\":37556,\"resp_time\":532}\n{\"time\":\"5:41PM\",\"level\":\"warn\",\"message\":\"Slow request\",\"method\":\"POST\",\"path\":\"/posts\",\"pid\":37556,\"resp_time\":532}\n{\"time\":\"5:41PM\",\"level\":\"info\",\"message\":\"Access\",\"method\":\"GET\",\"path\":\"/users\",\"pid\":37556,\"resp_time\":10}\n{\"time\":\"5:41PM\",\"level\":\"error\",\"message\":\"Database connection lost\",\"database\":\"myapp\",\"pid\":37556,\"error\":\"connection reset by peer\"}\n"
        },
        {
          "name": "fields.go",
          "type": "blob",
          "size": 6.8310546875,
          "content": "package zerolog\n\nimport (\n\t\"encoding/json\"\n\t\"net\"\n\t\"sort\"\n\t\"time\"\n\t\"unsafe\"\n)\n\nfunc isNilValue(i interface{}) bool {\n\treturn (*[2]uintptr)(unsafe.Pointer(&i))[1] == 0\n}\n\nfunc appendFields(dst []byte, fields interface{}, stack bool) []byte {\n\tswitch fields := fields.(type) {\n\tcase []interface{}:\n\t\tif n := len(fields); n&0x1 == 1 { // odd number\n\t\t\tfields = fields[:n-1]\n\t\t}\n\t\tdst = appendFieldList(dst, fields, stack)\n\tcase map[string]interface{}:\n\t\tkeys := make([]string, 0, len(fields))\n\t\tfor key := range fields {\n\t\t\tkeys = append(keys, key)\n\t\t}\n\t\tsort.Strings(keys)\n\t\tkv := make([]interface{}, 2)\n\t\tfor _, key := range keys {\n\t\t\tkv[0], kv[1] = key, fields[key]\n\t\t\tdst = appendFieldList(dst, kv, stack)\n\t\t}\n\t}\n\treturn dst\n}\n\nfunc appendFieldList(dst []byte, kvList []interface{}, stack bool) []byte {\n\tfor i, n := 0, len(kvList); i < n; i += 2 {\n\t\tkey, val := kvList[i], kvList[i+1]\n\t\tif key, ok := key.(string); ok {\n\t\t\tdst = enc.AppendKey(dst, key)\n\t\t} else {\n\t\t\tcontinue\n\t\t}\n\t\tif val, ok := val.(LogObjectMarshaler); ok {\n\t\t\te := newEvent(nil, 0)\n\t\t\te.buf = e.buf[:0]\n\t\t\te.appendObject(val)\n\t\t\tdst = append(dst, e.buf...)\n\t\t\tputEvent(e)\n\t\t\tcontinue\n\t\t}\n\t\tswitch val := val.(type) {\n\t\tcase string:\n\t\t\tdst = enc.AppendString(dst, val)\n\t\tcase []byte:\n\t\t\tdst = enc.AppendBytes(dst, val)\n\t\tcase error:\n\t\t\tswitch m := ErrorMarshalFunc(val).(type) {\n\t\t\tcase LogObjectMarshaler:\n\t\t\t\te := newEvent(nil, 0)\n\t\t\t\te.buf = e.buf[:0]\n\t\t\t\te.appendObject(m)\n\t\t\t\tdst = append(dst, e.buf...)\n\t\t\t\tputEvent(e)\n\t\t\tcase error:\n\t\t\t\tif m == nil || isNilValue(m) {\n\t\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t\t} else {\n\t\t\t\t\tdst = enc.AppendString(dst, m.Error())\n\t\t\t\t}\n\t\t\tcase string:\n\t\t\t\tdst = enc.AppendString(dst, m)\n\t\t\tdefault:\n\t\t\t\tdst = enc.AppendInterface(dst, m)\n\t\t\t}\n\n\t\t\tif stack && ErrorStackMarshaler != nil {\n\t\t\t\tdst = enc.AppendKey(dst, ErrorStackFieldName)\n\t\t\t\tswitch m := ErrorStackMarshaler(val).(type) {\n\t\t\t\tcase nil:\n\t\t\t\tcase error:\n\t\t\t\t\tif m != nil && !isNilValue(m) {\n\t\t\t\t\t\tdst = enc.AppendString(dst, m.Error())\n\t\t\t\t\t}\n\t\t\t\tcase string:\n\t\t\t\t\tdst = enc.AppendString(dst, m)\n\t\t\t\tdefault:\n\t\t\t\t\tdst = enc.AppendInterface(dst, m)\n\t\t\t\t}\n\t\t\t}\n\t\tcase []error:\n\t\t\tdst = enc.AppendArrayStart(dst)\n\t\t\tfor i, err := range val {\n\t\t\t\tswitch m := ErrorMarshalFunc(err).(type) {\n\t\t\t\tcase LogObjectMarshaler:\n\t\t\t\t\te := newEvent(nil, 0)\n\t\t\t\t\te.buf = e.buf[:0]\n\t\t\t\t\te.appendObject(m)\n\t\t\t\t\tdst = append(dst, e.buf...)\n\t\t\t\t\tputEvent(e)\n\t\t\t\tcase error:\n\t\t\t\t\tif m == nil || isNilValue(m) {\n\t\t\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdst = enc.AppendString(dst, m.Error())\n\t\t\t\t\t}\n\t\t\t\tcase string:\n\t\t\t\t\tdst = enc.AppendString(dst, m)\n\t\t\t\tdefault:\n\t\t\t\t\tdst = enc.AppendInterface(dst, m)\n\t\t\t\t}\n\n\t\t\t\tif i < (len(val) - 1) {\n\t\t\t\t\tenc.AppendArrayDelim(dst)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdst = enc.AppendArrayEnd(dst)\n\t\tcase bool:\n\t\t\tdst = enc.AppendBool(dst, val)\n\t\tcase int:\n\t\t\tdst = enc.AppendInt(dst, val)\n\t\tcase int8:\n\t\t\tdst = enc.AppendInt8(dst, val)\n\t\tcase int16:\n\t\t\tdst = enc.AppendInt16(dst, val)\n\t\tcase int32:\n\t\t\tdst = enc.AppendInt32(dst, val)\n\t\tcase int64:\n\t\t\tdst = enc.AppendInt64(dst, val)\n\t\tcase uint:\n\t\t\tdst = enc.AppendUint(dst, val)\n\t\tcase uint8:\n\t\t\tdst = enc.AppendUint8(dst, val)\n\t\tcase uint16:\n\t\t\tdst = enc.AppendUint16(dst, val)\n\t\tcase uint32:\n\t\t\tdst = enc.AppendUint32(dst, val)\n\t\tcase uint64:\n\t\t\tdst = enc.AppendUint64(dst, val)\n\t\tcase float32:\n\t\t\tdst = enc.AppendFloat32(dst, val, FloatingPointPrecision)\n\t\tcase float64:\n\t\t\tdst = enc.AppendFloat64(dst, val, FloatingPointPrecision)\n\t\tcase time.Time:\n\t\t\tdst = enc.AppendTime(dst, val, TimeFieldFormat)\n\t\tcase time.Duration:\n\t\t\tdst = enc.AppendDuration(dst, val, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\t\tcase *string:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendString(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *bool:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendBool(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *int:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendInt(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *int8:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendInt8(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *int16:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendInt16(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *int32:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendInt32(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *int64:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendInt64(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *uint:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendUint(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *uint8:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendUint8(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *uint16:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendUint16(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *uint32:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendUint32(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *uint64:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendUint64(dst, *val)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *float32:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendFloat32(dst, *val, FloatingPointPrecision)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *float64:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendFloat64(dst, *val, FloatingPointPrecision)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *time.Time:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendTime(dst, *val, TimeFieldFormat)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase *time.Duration:\n\t\t\tif val != nil {\n\t\t\t\tdst = enc.AppendDuration(dst, *val, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\t\t\t} else {\n\t\t\t\tdst = enc.AppendNil(dst)\n\t\t\t}\n\t\tcase []string:\n\t\t\tdst = enc.AppendStrings(dst, val)\n\t\tcase []bool:\n\t\t\tdst = enc.AppendBools(dst, val)\n\t\tcase []int:\n\t\t\tdst = enc.AppendInts(dst, val)\n\t\tcase []int8:\n\t\t\tdst = enc.AppendInts8(dst, val)\n\t\tcase []int16:\n\t\t\tdst = enc.AppendInts16(dst, val)\n\t\tcase []int32:\n\t\t\tdst = enc.AppendInts32(dst, val)\n\t\tcase []int64:\n\t\t\tdst = enc.AppendInts64(dst, val)\n\t\tcase []uint:\n\t\t\tdst = enc.AppendUints(dst, val)\n\t\t// case []uint8:\n\t\t// \tdst = enc.AppendUints8(dst, val)\n\t\tcase []uint16:\n\t\t\tdst = enc.AppendUints16(dst, val)\n\t\tcase []uint32:\n\t\t\tdst = enc.AppendUints32(dst, val)\n\t\tcase []uint64:\n\t\t\tdst = enc.AppendUints64(dst, val)\n\t\tcase []float32:\n\t\t\tdst = enc.AppendFloats32(dst, val, FloatingPointPrecision)\n\t\tcase []float64:\n\t\t\tdst = enc.AppendFloats64(dst, val, FloatingPointPrecision)\n\t\tcase []time.Time:\n\t\t\tdst = enc.AppendTimes(dst, val, TimeFieldFormat)\n\t\tcase []time.Duration:\n\t\t\tdst = enc.AppendDurations(dst, val, DurationFieldUnit, DurationFieldInteger, FloatingPointPrecision)\n\t\tcase nil:\n\t\t\tdst = enc.AppendNil(dst)\n\t\tcase net.IP:\n\t\t\tdst = enc.AppendIPAddr(dst, val)\n\t\tcase net.IPNet:\n\t\t\tdst = enc.AppendIPPrefix(dst, val)\n\t\tcase net.HardwareAddr:\n\t\t\tdst = enc.AppendMACAddr(dst, val)\n\t\tcase json.RawMessage:\n\t\t\tdst = appendJSON(dst, val)\n\t\tdefault:\n\t\t\tdst = enc.AppendInterface(dst, val)\n\t\t}\n\t}\n\treturn dst\n}\n"
        },
        {
          "name": "globals.go",
          "type": "blob",
          "size": 5.6689453125,
          "content": "package zerolog\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"strconv\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nconst (\n\t// TimeFormatUnix defines a time format that makes time fields to be\n\t// serialized as Unix timestamp integers.\n\tTimeFormatUnix = \"\"\n\n\t// TimeFormatUnixMs defines a time format that makes time fields to be\n\t// serialized as Unix timestamp integers in milliseconds.\n\tTimeFormatUnixMs = \"UNIXMS\"\n\n\t// TimeFormatUnixMicro defines a time format that makes time fields to be\n\t// serialized as Unix timestamp integers in microseconds.\n\tTimeFormatUnixMicro = \"UNIXMICRO\"\n\n\t// TimeFormatUnixNano defines a time format that makes time fields to be\n\t// serialized as Unix timestamp integers in nanoseconds.\n\tTimeFormatUnixNano = \"UNIXNANO\"\n)\n\nvar (\n\t// TimestampFieldName is the field name used for the timestamp field.\n\tTimestampFieldName = \"time\"\n\n\t// LevelFieldName is the field name used for the level field.\n\tLevelFieldName = \"level\"\n\n\t// LevelTraceValue is the value used for the trace level field.\n\tLevelTraceValue = \"trace\"\n\t// LevelDebugValue is the value used for the debug level field.\n\tLevelDebugValue = \"debug\"\n\t// LevelInfoValue is the value used for the info level field.\n\tLevelInfoValue = \"info\"\n\t// LevelWarnValue is the value used for the warn level field.\n\tLevelWarnValue = \"warn\"\n\t// LevelErrorValue is the value used for the error level field.\n\tLevelErrorValue = \"error\"\n\t// LevelFatalValue is the value used for the fatal level field.\n\tLevelFatalValue = \"fatal\"\n\t// LevelPanicValue is the value used for the panic level field.\n\tLevelPanicValue = \"panic\"\n\n\t// LevelFieldMarshalFunc allows customization of global level field marshaling.\n\tLevelFieldMarshalFunc = func(l Level) string {\n\t\treturn l.String()\n\t}\n\n\t// MessageFieldName is the field name used for the message field.\n\tMessageFieldName = \"message\"\n\n\t// ErrorFieldName is the field name used for error fields.\n\tErrorFieldName = \"error\"\n\n\t// CallerFieldName is the field name used for caller field.\n\tCallerFieldName = \"caller\"\n\n\t// CallerSkipFrameCount is the number of stack frames to skip to find the caller.\n\tCallerSkipFrameCount = 2\n\n\t// CallerMarshalFunc allows customization of global caller marshaling\n\tCallerMarshalFunc = func(pc uintptr, file string, line int) string {\n\t\treturn file + \":\" + strconv.Itoa(line)\n\t}\n\n\t// ErrorStackFieldName is the field name used for error stacks.\n\tErrorStackFieldName = \"stack\"\n\n\t// ErrorStackMarshaler extract the stack from err if any.\n\tErrorStackMarshaler func(err error) interface{}\n\n\t// ErrorMarshalFunc allows customization of global error marshaling\n\tErrorMarshalFunc = func(err error) interface{} {\n\t\treturn err\n\t}\n\n\t// InterfaceMarshalFunc allows customization of interface marshaling.\n\t// Default: \"encoding/json.Marshal\" with disabled HTML escaping\n\tInterfaceMarshalFunc = func(v interface{}) ([]byte, error) {\n\t\tvar buf bytes.Buffer\n\t\tencoder := json.NewEncoder(&buf)\n\t\tencoder.SetEscapeHTML(false)\n\t\terr := encoder.Encode(v)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb := buf.Bytes()\n\t\tif len(b) > 0 {\n\t\t\t// Remove trailing \\n which is added by Encode.\n\t\t\treturn b[:len(b)-1], nil\n\t\t}\n\t\treturn b, nil\n\t}\n\n\t// TimeFieldFormat defines the time format of the Time field type. If set to\n\t// TimeFormatUnix, TimeFormatUnixMs, TimeFormatUnixMicro or TimeFormatUnixNano, the time is formatted as a UNIX\n\t// timestamp as integer.\n\tTimeFieldFormat = time.RFC3339\n\n\t// TimestampFunc defines the function called to generate a timestamp.\n\tTimestampFunc = time.Now\n\n\t// DurationFieldUnit defines the unit for time.Duration type fields added\n\t// using the Dur method.\n\tDurationFieldUnit = time.Millisecond\n\n\t// DurationFieldInteger renders Dur fields as integer instead of float if\n\t// set to true.\n\tDurationFieldInteger = false\n\n\t// ErrorHandler is called whenever zerolog fails to write an event on its\n\t// output. If not set, an error is printed on the stderr. This handler must\n\t// be thread safe and non-blocking.\n\tErrorHandler func(err error)\n\n\t// DefaultContextLogger is returned from Ctx() if there is no logger associated\n\t// with the context.\n\tDefaultContextLogger *Logger\n\n\t// LevelColors are used by ConsoleWriter's consoleDefaultFormatLevel to color\n\t// log levels.\n\tLevelColors = map[Level]int{\n\t\tTraceLevel: colorBlue,\n\t\tDebugLevel: 0,\n\t\tInfoLevel:  colorGreen,\n\t\tWarnLevel:  colorYellow,\n\t\tErrorLevel: colorRed,\n\t\tFatalLevel: colorRed,\n\t\tPanicLevel: colorRed,\n\t}\n\n\t// FormattedLevels are used by ConsoleWriter's consoleDefaultFormatLevel\n\t// for a short level name.\n\tFormattedLevels = map[Level]string{\n\t\tTraceLevel: \"TRC\",\n\t\tDebugLevel: \"DBG\",\n\t\tInfoLevel:  \"INF\",\n\t\tWarnLevel:  \"WRN\",\n\t\tErrorLevel: \"ERR\",\n\t\tFatalLevel: \"FTL\",\n\t\tPanicLevel: \"PNC\",\n\t}\n\n\t// TriggerLevelWriterBufferReuseLimit is a limit in bytes that a buffer is dropped\n\t// from the TriggerLevelWriter buffer pool if the buffer grows above the limit.\n\tTriggerLevelWriterBufferReuseLimit = 64 * 1024\n\n\t// FloatingPointPrecision, if set to a value other than -1, controls the number\n\t// of digits when formatting float numbers in JSON. See strconv.FormatFloat for\n\t// more details.\n\tFloatingPointPrecision = -1\n)\n\nvar (\n\tgLevel          = new(int32)\n\tdisableSampling = new(int32)\n)\n\n// SetGlobalLevel sets the global override for log level. If this\n// values is raised, all Loggers will use at least this value.\n//\n// To globally disable logs, set GlobalLevel to Disabled.\nfunc SetGlobalLevel(l Level) {\n\tatomic.StoreInt32(gLevel, int32(l))\n}\n\n// GlobalLevel returns the current global log level\nfunc GlobalLevel() Level {\n\treturn Level(atomic.LoadInt32(gLevel))\n}\n\n// DisableSampling will disable sampling in all Loggers if true.\nfunc DisableSampling(v bool) {\n\tvar i int32\n\tif v {\n\t\ti = 1\n\t}\n\tatomic.StoreInt32(disableSampling, i)\n}\n\nfunc samplingDisabled() bool {\n\treturn atomic.LoadInt32(disableSampling) == 1\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.267578125,
          "content": "module github.com/rs/zerolog\n\ngo 1.15\n\nrequire (\n\tgithub.com/coreos/go-systemd/v22 v22.5.0\n\tgithub.com/mattn/go-colorable v0.1.13\n\tgithub.com/mattn/go-isatty v0.0.19 // indirect\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/rs/xid v1.6.0\n\tgolang.org/x/sys v0.12.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.3359375,
          "content": "github.com/coreos/go-systemd/v22 v22.5.0 h1:RrqgGjYQKalulkV8NGVIfkXQf6YYmOyiJKk8iXXhfZs=\ngithub.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.19 h1:JITubQf0MOLdlGRuRq+jtsDlekdYPia9ZFsB8h/APPA=\ngithub.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/rs/xid v1.6.0 h1:fV591PaemRlL6JfRxGDEPl69wICngIQ3shQtzfy2gxU=\ngithub.com/rs/xid v1.6.0/go.mod h1:7XoLgs4eV+QndskICGsho+ADou8ySMSjJKDIan90Nz0=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0 h1:CM0HF96J0hcLAwsHPJZjfdNzs0gftsLfgKt57wWHJ0o=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\n"
        },
        {
          "name": "go112.go",
          "type": "blob",
          "size": 0.1572265625,
          "content": "// +build go1.12\n\npackage zerolog\n\n// Since go 1.12, some auto generated init functions are hidden from\n// runtime.Caller.\nconst contextCallerSkipFrameCount = 2\n"
        },
        {
          "name": "hlog",
          "type": "tree",
          "content": null
        },
        {
          "name": "hook.go",
          "type": "blob",
          "size": 1.474609375,
          "content": "package zerolog\n\n// Hook defines an interface to a log hook.\ntype Hook interface {\n\t// Run runs the hook with the event.\n\tRun(e *Event, level Level, message string)\n}\n\n// HookFunc is an adaptor to allow the use of an ordinary function\n// as a Hook.\ntype HookFunc func(e *Event, level Level, message string)\n\n// Run implements the Hook interface.\nfunc (h HookFunc) Run(e *Event, level Level, message string) {\n\th(e, level, message)\n}\n\n// LevelHook applies a different hook for each level.\ntype LevelHook struct {\n\tNoLevelHook, TraceHook, DebugHook, InfoHook, WarnHook, ErrorHook, FatalHook, PanicHook Hook\n}\n\n// Run implements the Hook interface.\nfunc (h LevelHook) Run(e *Event, level Level, message string) {\n\tswitch level {\n\tcase TraceLevel:\n\t\tif h.TraceHook != nil {\n\t\t\th.TraceHook.Run(e, level, message)\n\t\t}\n\tcase DebugLevel:\n\t\tif h.DebugHook != nil {\n\t\t\th.DebugHook.Run(e, level, message)\n\t\t}\n\tcase InfoLevel:\n\t\tif h.InfoHook != nil {\n\t\t\th.InfoHook.Run(e, level, message)\n\t\t}\n\tcase WarnLevel:\n\t\tif h.WarnHook != nil {\n\t\t\th.WarnHook.Run(e, level, message)\n\t\t}\n\tcase ErrorLevel:\n\t\tif h.ErrorHook != nil {\n\t\t\th.ErrorHook.Run(e, level, message)\n\t\t}\n\tcase FatalLevel:\n\t\tif h.FatalHook != nil {\n\t\t\th.FatalHook.Run(e, level, message)\n\t\t}\n\tcase PanicLevel:\n\t\tif h.PanicHook != nil {\n\t\t\th.PanicHook.Run(e, level, message)\n\t\t}\n\tcase NoLevel:\n\t\tif h.NoLevelHook != nil {\n\t\t\th.NoLevelHook.Run(e, level, message)\n\t\t}\n\t}\n}\n\n// NewLevelHook returns a new LevelHook.\nfunc NewLevelHook() LevelHook {\n\treturn LevelHook{}\n}\n"
        },
        {
          "name": "hook_test.go",
          "type": "blob",
          "size": 6.8056640625,
          "content": "package zerolog\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"testing\"\n)\n\ntype contextKeyType int\n\nvar contextKey contextKeyType\n\nvar (\n\tlevelNameHook = HookFunc(func(e *Event, level Level, msg string) {\n\t\tlevelName := level.String()\n\t\tif level == NoLevel {\n\t\t\tlevelName = \"nolevel\"\n\t\t}\n\t\te.Str(\"level_name\", levelName)\n\t})\n\tsimpleHook = HookFunc(func(e *Event, level Level, msg string) {\n\t\te.Bool(\"has_level\", level != NoLevel)\n\t\te.Str(\"test\", \"logged\")\n\t})\n\tcopyHook = HookFunc(func(e *Event, level Level, msg string) {\n\t\thasLevel := level != NoLevel\n\t\te.Bool(\"copy_has_level\", hasLevel)\n\t\tif hasLevel {\n\t\t\te.Str(\"copy_level\", level.String())\n\t\t}\n\t\te.Str(\"copy_msg\", msg)\n\t})\n\tnopHook = HookFunc(func(e *Event, level Level, message string) {\n\t})\n\tdiscardHook = HookFunc(func(e *Event, level Level, message string) {\n\t\te.Discard()\n\t})\n\tcontextHook = HookFunc(func(e *Event, level Level, message string) {\n\t\tcontextData, ok := e.GetCtx().Value(contextKey).(string)\n\t\tif ok {\n\t\t\te.Str(\"context-data\", contextData)\n\t\t}\n\t})\n)\n\nfunc TestHook(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\twant string\n\t\ttest func(log Logger)\n\t}{\n\t\t{\"Message\", `{\"level_name\":\"nolevel\",\"message\":\"test message\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook)\n\t\t\tlog.Log().Msg(\"test message\")\n\t\t}},\n\t\t{\"NoLevel\", `{\"level_name\":\"nolevel\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook)\n\t\t\tlog.Log().Msg(\"\")\n\t\t}},\n\t\t{\"Print\", `{\"level\":\"debug\",\"level_name\":\"debug\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook)\n\t\t\tlog.Print(\"\")\n\t\t}},\n\t\t{\"Error\", `{\"level\":\"error\",\"level_name\":\"error\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"Copy/1\", `{\"copy_has_level\":false,\"copy_msg\":\"\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(copyHook)\n\t\t\tlog.Log().Msg(\"\")\n\t\t}},\n\t\t{\"Copy/2\", `{\"level\":\"info\",\"copy_has_level\":true,\"copy_level\":\"info\",\"copy_msg\":\"a message\",\"message\":\"a message\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(copyHook)\n\t\t\tlog.Info().Msg(\"a message\")\n\t\t}},\n\t\t{\"Multi\", `{\"level\":\"error\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook).Hook(simpleHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"Multi/Message\", `{\"level\":\"error\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\",\"message\":\"a message\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook).Hook(simpleHook)\n\t\t\tlog.Error().Msg(\"a message\")\n\t\t}},\n\t\t{\"Output/single/pre\", `{\"level\":\"error\",\"level_name\":\"error\"}` + \"\\n\", func(log Logger) {\n\t\t\tignored := &bytes.Buffer{}\n\t\t\tlog = New(ignored).Hook(levelNameHook).Output(log.w)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"Output/single/post\", `{\"level\":\"error\",\"level_name\":\"error\"}` + \"\\n\", func(log Logger) {\n\t\t\tignored := &bytes.Buffer{}\n\t\t\tlog = New(ignored).Output(log.w).Hook(levelNameHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"Output/multi/pre\", `{\"level\":\"error\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\"}` + \"\\n\", func(log Logger) {\n\t\t\tignored := &bytes.Buffer{}\n\t\t\tlog = New(ignored).Hook(levelNameHook).Hook(simpleHook).Output(log.w)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"Output/multi/post\", `{\"level\":\"error\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\"}` + \"\\n\", func(log Logger) {\n\t\t\tignored := &bytes.Buffer{}\n\t\t\tlog = New(ignored).Output(log.w).Hook(levelNameHook).Hook(simpleHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"Output/mixed\", `{\"level\":\"error\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\"}` + \"\\n\", func(log Logger) {\n\t\t\tignored := &bytes.Buffer{}\n\t\t\tlog = New(ignored).Hook(levelNameHook).Output(log.w).Hook(simpleHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"With/single/pre\", `{\"level\":\"error\",\"with\":\"pre\",\"level_name\":\"error\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook).With().Str(\"with\", \"pre\").Logger()\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"With/single/post\", `{\"level\":\"error\",\"with\":\"post\",\"level_name\":\"error\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.With().Str(\"with\", \"post\").Logger().Hook(levelNameHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"With/multi/pre\", `{\"level\":\"error\",\"with\":\"pre\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook).Hook(simpleHook).With().Str(\"with\", \"pre\").Logger()\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"With/multi/post\", `{\"level\":\"error\",\"with\":\"post\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.With().Str(\"with\", \"post\").Logger().Hook(levelNameHook).Hook(simpleHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"With/mixed\", `{\"level\":\"error\",\"with\":\"mixed\",\"level_name\":\"error\",\"has_level\":true,\"test\":\"logged\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(levelNameHook).With().Str(\"with\", \"mixed\").Logger().Hook(simpleHook)\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t\t{\"Discard\", \"\", func(log Logger) {\n\t\t\tlog = log.Hook(discardHook)\n\t\t\tlog.Log().Msg(\"test message\")\n\t\t}},\n\t\t{\"Context/Background\", `{\"level\":\"info\",\"message\":\"test message\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog = log.Hook(contextHook)\n\t\t\tlog.Info().Ctx(context.Background()).Msg(\"test message\")\n\t\t}},\n\t\t{\"Context/nil\", `{\"level\":\"info\",\"message\":\"test message\"}` + \"\\n\", func(log Logger) {\n\t\t\t// passing `nil` where a context is wanted is against\n\t\t\t// the rules, but people still do it.\n\t\t\tlog = log.Hook(contextHook)\n\t\t\tlog.Info().Ctx(nil).Msg(\"test message\") // nolint\n\t\t}},\n\t\t{\"Context/valid\", `{\"level\":\"info\",\"context-data\":\"12345abcdef\",\"message\":\"test message\"}` + \"\\n\", func(log Logger) {\n\t\t\tctx := context.Background()\n\t\t\tctx = context.WithValue(ctx, contextKey, \"12345abcdef\")\n\t\t\tlog = log.Hook(contextHook)\n\t\t\tlog.Info().Ctx(ctx).Msg(\"test message\")\n\t\t}},\n\t\t{\"Context/With/valid\", `{\"level\":\"info\",\"context-data\":\"12345abcdef\",\"message\":\"test message\"}` + \"\\n\", func(log Logger) {\n\t\t\tctx := context.Background()\n\t\t\tctx = context.WithValue(ctx, contextKey, \"12345abcdef\")\n\t\t\tlog = log.Hook(contextHook)\n\t\t\tlog = log.With().Ctx(ctx).Logger()\n\t\t\tlog.Info().Msg(\"test message\")\n\t\t}},\n\t\t{\"None\", `{\"level\":\"error\"}` + \"\\n\", func(log Logger) {\n\t\t\tlog.Error().Msg(\"\")\n\t\t}},\n\t}\n\tfor _, tt := range tests {\n\t\ttt := tt\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tout := &bytes.Buffer{}\n\t\t\tlog := New(out)\n\t\t\ttt.test(log)\n\t\t\tif got, want := decodeIfBinaryToString(out.Bytes()), tt.want; got != want {\n\t\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkHooks(b *testing.B) {\n\tlogger := New(io.Discard)\n\tb.ResetTimer()\n\tb.Run(\"Nop/Single\", func(b *testing.B) {\n\t\tlog := logger.Hook(nopHook)\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tlog.Log().Msg(\"\")\n\t\t\t}\n\t\t})\n\t})\n\tb.Run(\"Nop/Multi\", func(b *testing.B) {\n\t\tlog := logger.Hook(nopHook).Hook(nopHook)\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tlog.Log().Msg(\"\")\n\t\t\t}\n\t\t})\n\t})\n\tb.Run(\"Simple\", func(b *testing.B) {\n\t\tlog := logger.Hook(simpleHook)\n\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\tfor pb.Next() {\n\t\t\t\tlog.Log().Msg(\"\")\n\t\t\t}\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "journald",
          "type": "tree",
          "content": null
        },
        {
          "name": "log.go",
          "type": "blob",
          "size": 14.3701171875,
          "content": "// Package zerolog provides a lightweight logging library dedicated to JSON logging.\n//\n// A global Logger can be use for simple logging:\n//\n//     import \"github.com/rs/zerolog/log\"\n//\n//     log.Info().Msg(\"hello world\")\n//     // Output: {\"time\":1494567715,\"level\":\"info\",\"message\":\"hello world\"}\n//\n// NOTE: To import the global logger, import the \"log\" subpackage \"github.com/rs/zerolog/log\".\n//\n// Fields can be added to log messages:\n//\n//     log.Info().Str(\"foo\", \"bar\").Msg(\"hello world\")\n//     // Output: {\"time\":1494567715,\"level\":\"info\",\"message\":\"hello world\",\"foo\":\"bar\"}\n//\n// Create logger instance to manage different outputs:\n//\n//     logger := zerolog.New(os.Stderr).With().Timestamp().Logger()\n//     logger.Info().\n//            Str(\"foo\", \"bar\").\n//            Msg(\"hello world\")\n//     // Output: {\"time\":1494567715,\"level\":\"info\",\"message\":\"hello world\",\"foo\":\"bar\"}\n//\n// Sub-loggers let you chain loggers with additional context:\n//\n//     sublogger := log.With().Str(\"component\", \"foo\").Logger()\n//     sublogger.Info().Msg(\"hello world\")\n//     // Output: {\"time\":1494567715,\"level\":\"info\",\"message\":\"hello world\",\"component\":\"foo\"}\n//\n// Level logging\n//\n//     zerolog.SetGlobalLevel(zerolog.InfoLevel)\n//\n//     log.Debug().Msg(\"filtered out message\")\n//     log.Info().Msg(\"routed message\")\n//\n//     if e := log.Debug(); e.Enabled() {\n//         // Compute log output only if enabled.\n//         value := compute()\n//         e.Str(\"foo\": value).Msg(\"some debug message\")\n//     }\n//     // Output: {\"level\":\"info\",\"time\":1494567715,\"routed message\"}\n//\n// Customize automatic field names:\n//\n//     log.TimestampFieldName = \"t\"\n//     log.LevelFieldName = \"p\"\n//     log.MessageFieldName = \"m\"\n//\n//     log.Info().Msg(\"hello world\")\n//     // Output: {\"t\":1494567715,\"p\":\"info\",\"m\":\"hello world\"}\n//\n// Log with no level and message:\n//\n//     log.Log().Str(\"foo\",\"bar\").Msg(\"\")\n//     // Output: {\"time\":1494567715,\"foo\":\"bar\"}\n//\n// Add contextual fields to global Logger:\n//\n//     log.Logger = log.With().Str(\"foo\", \"bar\").Logger()\n//\n// Sample logs:\n//\n//     sampled := log.Sample(&zerolog.BasicSampler{N: 10})\n//     sampled.Info().Msg(\"will be logged every 10 messages\")\n//\n// Log with contextual hooks:\n//\n//     // Create the hook:\n//     type SeverityHook struct{}\n//\n//     func (h SeverityHook) Run(e *zerolog.Event, level zerolog.Level, msg string) {\n//          if level != zerolog.NoLevel {\n//              e.Str(\"severity\", level.String())\n//          }\n//     }\n//\n//     // And use it:\n//     var h SeverityHook\n//     log := zerolog.New(os.Stdout).Hook(h)\n//     log.Warn().Msg(\"\")\n//     // Output: {\"level\":\"warn\",\"severity\":\"warn\"}\n//\n// # Caveats\n//\n// Field duplication:\n//\n// There is no fields deduplication out-of-the-box.\n// Using the same key multiple times creates new key in final JSON each time.\n//\n//     logger := zerolog.New(os.Stderr).With().Timestamp().Logger()\n//     logger.Info().\n//            Timestamp().\n//            Msg(\"dup\")\n//     // Output: {\"level\":\"info\",\"time\":1494567715,\"time\":1494567715,\"message\":\"dup\"}\n//\n// In this case, many consumers will take the last value,\n// but this is not guaranteed; check yours if in doubt.\n//\n// Concurrency safety:\n//\n// Be careful when calling UpdateContext. It is not concurrency safe. Use the With method to create a child logger:\n//\n//     func handler(w http.ResponseWriter, r *http.Request) {\n//         // Create a child logger for concurrency safety\n//         logger := log.Logger.With().Logger()\n//\n//         // Add context fields, for example User-Agent from HTTP headers\n//         logger.UpdateContext(func(c zerolog.Context) zerolog.Context {\n//             ...\n//         })\n//     }\npackage zerolog\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Level defines log levels.\ntype Level int8\n\nconst (\n\t// DebugLevel defines debug log level.\n\tDebugLevel Level = iota\n\t// InfoLevel defines info log level.\n\tInfoLevel\n\t// WarnLevel defines warn log level.\n\tWarnLevel\n\t// ErrorLevel defines error log level.\n\tErrorLevel\n\t// FatalLevel defines fatal log level.\n\tFatalLevel\n\t// PanicLevel defines panic log level.\n\tPanicLevel\n\t// NoLevel defines an absent log level.\n\tNoLevel\n\t// Disabled disables the logger.\n\tDisabled\n\n\t// TraceLevel defines trace log level.\n\tTraceLevel Level = -1\n\t// Values less than TraceLevel are handled as numbers.\n)\n\nfunc (l Level) String() string {\n\tswitch l {\n\tcase TraceLevel:\n\t\treturn LevelTraceValue\n\tcase DebugLevel:\n\t\treturn LevelDebugValue\n\tcase InfoLevel:\n\t\treturn LevelInfoValue\n\tcase WarnLevel:\n\t\treturn LevelWarnValue\n\tcase ErrorLevel:\n\t\treturn LevelErrorValue\n\tcase FatalLevel:\n\t\treturn LevelFatalValue\n\tcase PanicLevel:\n\t\treturn LevelPanicValue\n\tcase Disabled:\n\t\treturn \"disabled\"\n\tcase NoLevel:\n\t\treturn \"\"\n\t}\n\treturn strconv.Itoa(int(l))\n}\n\n// ParseLevel converts a level string into a zerolog Level value.\n// returns an error if the input string does not match known values.\nfunc ParseLevel(levelStr string) (Level, error) {\n\tswitch {\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(TraceLevel)):\n\t\treturn TraceLevel, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(DebugLevel)):\n\t\treturn DebugLevel, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(InfoLevel)):\n\t\treturn InfoLevel, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(WarnLevel)):\n\t\treturn WarnLevel, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(ErrorLevel)):\n\t\treturn ErrorLevel, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(FatalLevel)):\n\t\treturn FatalLevel, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(PanicLevel)):\n\t\treturn PanicLevel, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(Disabled)):\n\t\treturn Disabled, nil\n\tcase strings.EqualFold(levelStr, LevelFieldMarshalFunc(NoLevel)):\n\t\treturn NoLevel, nil\n\t}\n\ti, err := strconv.Atoi(levelStr)\n\tif err != nil {\n\t\treturn NoLevel, fmt.Errorf(\"Unknown Level String: '%s', defaulting to NoLevel\", levelStr)\n\t}\n\tif i > 127 || i < -128 {\n\t\treturn NoLevel, fmt.Errorf(\"Out-Of-Bounds Level: '%d', defaulting to NoLevel\", i)\n\t}\n\treturn Level(i), nil\n}\n\n// UnmarshalText implements encoding.TextUnmarshaler to allow for easy reading from toml/yaml/json formats\nfunc (l *Level) UnmarshalText(text []byte) error {\n\tif l == nil {\n\t\treturn errors.New(\"can't unmarshal a nil *Level\")\n\t}\n\tvar err error\n\t*l, err = ParseLevel(string(text))\n\treturn err\n}\n\n// MarshalText implements encoding.TextMarshaler to allow for easy writing into toml/yaml/json formats\nfunc (l Level) MarshalText() ([]byte, error) {\n\treturn []byte(LevelFieldMarshalFunc(l)), nil\n}\n\n// A Logger represents an active logging object that generates lines\n// of JSON output to an io.Writer. Each logging operation makes a single\n// call to the Writer's Write method. There is no guarantee on access\n// serialization to the Writer. If your Writer is not thread safe,\n// you may consider a sync wrapper.\ntype Logger struct {\n\tw       LevelWriter\n\tlevel   Level\n\tsampler Sampler\n\tcontext []byte\n\thooks   []Hook\n\tstack   bool\n\tctx     context.Context\n}\n\n// New creates a root logger with given output writer. If the output writer implements\n// the LevelWriter interface, the WriteLevel method will be called instead of the Write\n// one.\n//\n// Each logging operation makes a single call to the Writer's Write method. There is no\n// guarantee on access serialization to the Writer. If your Writer is not thread safe,\n// you may consider using sync wrapper.\nfunc New(w io.Writer) Logger {\n\tif w == nil {\n\t\tw = io.Discard\n\t}\n\tlw, ok := w.(LevelWriter)\n\tif !ok {\n\t\tlw = LevelWriterAdapter{w}\n\t}\n\treturn Logger{w: lw, level: TraceLevel}\n}\n\n// Nop returns a disabled logger for which all operation are no-op.\nfunc Nop() Logger {\n\treturn New(nil).Level(Disabled)\n}\n\n// Output duplicates the current logger and sets w as its output.\nfunc (l Logger) Output(w io.Writer) Logger {\n\tl2 := New(w)\n\tl2.level = l.level\n\tl2.sampler = l.sampler\n\tl2.stack = l.stack\n\tif len(l.hooks) > 0 {\n\t\tl2.hooks = append(l2.hooks, l.hooks...)\n\t}\n\tif l.context != nil {\n\t\tl2.context = make([]byte, len(l.context), cap(l.context))\n\t\tcopy(l2.context, l.context)\n\t}\n\treturn l2\n}\n\n// With creates a child logger with the field added to its context.\nfunc (l Logger) With() Context {\n\tcontext := l.context\n\tl.context = make([]byte, 0, 500)\n\tif context != nil {\n\t\tl.context = append(l.context, context...)\n\t} else {\n\t\t// This is needed for AppendKey to not check len of input\n\t\t// thus making it inlinable\n\t\tl.context = enc.AppendBeginMarker(l.context)\n\t}\n\treturn Context{l}\n}\n\n// UpdateContext updates the internal logger's context.\n//\n// Caution: This method is not concurrency safe.\n// Use the With method to create a child logger before modifying the context from concurrent goroutines.\nfunc (l *Logger) UpdateContext(update func(c Context) Context) {\n\tif l == disabledLogger {\n\t\treturn\n\t}\n\tif cap(l.context) == 0 {\n\t\tl.context = make([]byte, 0, 500)\n\t}\n\tif len(l.context) == 0 {\n\t\tl.context = enc.AppendBeginMarker(l.context)\n\t}\n\tc := update(Context{*l})\n\tl.context = c.l.context\n}\n\n// Level creates a child logger with the minimum accepted level set to level.\nfunc (l Logger) Level(lvl Level) Logger {\n\tl.level = lvl\n\treturn l\n}\n\n// GetLevel returns the current Level of l.\nfunc (l Logger) GetLevel() Level {\n\treturn l.level\n}\n\n// Sample returns a logger with the s sampler.\nfunc (l Logger) Sample(s Sampler) Logger {\n\tl.sampler = s\n\treturn l\n}\n\n// Hook returns a logger with the h Hook.\nfunc (l Logger) Hook(hooks ...Hook) Logger {\n\tif len(hooks) == 0 {\n\t\treturn l\n\t}\n\tnewHooks := make([]Hook, len(l.hooks), len(l.hooks)+len(hooks))\n\tcopy(newHooks, l.hooks)\n\tl.hooks = append(newHooks, hooks...)\n\treturn l\n}\n\n// Trace starts a new message with trace level.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Trace() *Event {\n\treturn l.newEvent(TraceLevel, nil)\n}\n\n// Debug starts a new message with debug level.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Debug() *Event {\n\treturn l.newEvent(DebugLevel, nil)\n}\n\n// Info starts a new message with info level.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Info() *Event {\n\treturn l.newEvent(InfoLevel, nil)\n}\n\n// Warn starts a new message with warn level.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Warn() *Event {\n\treturn l.newEvent(WarnLevel, nil)\n}\n\n// Error starts a new message with error level.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Error() *Event {\n\treturn l.newEvent(ErrorLevel, nil)\n}\n\n// Err starts a new message with error level with err as a field if not nil or\n// with info level if err is nil.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Err(err error) *Event {\n\tif err != nil {\n\t\treturn l.Error().Err(err)\n\t}\n\n\treturn l.Info()\n}\n\n// Fatal starts a new message with fatal level. The os.Exit(1) function\n// is called by the Msg method, which terminates the program immediately.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Fatal() *Event {\n\treturn l.newEvent(FatalLevel, func(msg string) {\n\t\tif closer, ok := l.w.(io.Closer); ok {\n\t\t\t// Close the writer to flush any buffered message. Otherwise the message\n\t\t\t// will be lost as os.Exit() terminates the program immediately.\n\t\t\tcloser.Close()\n\t\t}\n\t\tos.Exit(1)\n\t})\n}\n\n// Panic starts a new message with panic level. The panic() function\n// is called by the Msg method, which stops the ordinary flow of a goroutine.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Panic() *Event {\n\treturn l.newEvent(PanicLevel, func(msg string) { panic(msg) })\n}\n\n// WithLevel starts a new message with level. Unlike Fatal and Panic\n// methods, WithLevel does not terminate the program or stop the ordinary\n// flow of a goroutine when used with their respective levels.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) WithLevel(level Level) *Event {\n\tswitch level {\n\tcase TraceLevel:\n\t\treturn l.Trace()\n\tcase DebugLevel:\n\t\treturn l.Debug()\n\tcase InfoLevel:\n\t\treturn l.Info()\n\tcase WarnLevel:\n\t\treturn l.Warn()\n\tcase ErrorLevel:\n\t\treturn l.Error()\n\tcase FatalLevel:\n\t\treturn l.newEvent(FatalLevel, nil)\n\tcase PanicLevel:\n\t\treturn l.newEvent(PanicLevel, nil)\n\tcase NoLevel:\n\t\treturn l.Log()\n\tcase Disabled:\n\t\treturn nil\n\tdefault:\n\t\treturn l.newEvent(level, nil)\n\t}\n}\n\n// Log starts a new message with no level. Setting GlobalLevel to Disabled\n// will still disable events produced by this method.\n//\n// You must call Msg on the returned event in order to send the event.\nfunc (l *Logger) Log() *Event {\n\treturn l.newEvent(NoLevel, nil)\n}\n\n// Print sends a log event using debug level and no extra field.\n// Arguments are handled in the manner of fmt.Print.\nfunc (l *Logger) Print(v ...interface{}) {\n\tif e := l.Debug(); e.Enabled() {\n\t\te.CallerSkipFrame(1).Msg(fmt.Sprint(v...))\n\t}\n}\n\n// Printf sends a log event using debug level and no extra field.\n// Arguments are handled in the manner of fmt.Printf.\nfunc (l *Logger) Printf(format string, v ...interface{}) {\n\tif e := l.Debug(); e.Enabled() {\n\t\te.CallerSkipFrame(1).Msg(fmt.Sprintf(format, v...))\n\t}\n}\n\n// Println sends a log event using debug level and no extra field.\n// Arguments are handled in the manner of fmt.Println.\nfunc (l *Logger) Println(v ...interface{}) {\n\tif e := l.Debug(); e.Enabled() {\n\t\te.CallerSkipFrame(1).Msg(fmt.Sprintln(v...))\n\t}\n}\n\n// Write implements the io.Writer interface. This is useful to set as a writer\n// for the standard library log.\nfunc (l Logger) Write(p []byte) (n int, err error) {\n\tn = len(p)\n\tif n > 0 && p[n-1] == '\\n' {\n\t\t// Trim CR added by stdlog.\n\t\tp = p[0 : n-1]\n\t}\n\tl.Log().CallerSkipFrame(1).Msg(string(p))\n\treturn\n}\n\nfunc (l *Logger) newEvent(level Level, done func(string)) *Event {\n\tenabled := l.should(level)\n\tif !enabled {\n\t\tif done != nil {\n\t\t\tdone(\"\")\n\t\t}\n\t\treturn nil\n\t}\n\te := newEvent(l.w, level)\n\te.done = done\n\te.ch = l.hooks\n\te.ctx = l.ctx\n\tif level != NoLevel && LevelFieldName != \"\" {\n\t\te.Str(LevelFieldName, LevelFieldMarshalFunc(level))\n\t}\n\tif len(l.context) > 1 {\n\t\te.buf = enc.AppendObjectData(e.buf, l.context)\n\t}\n\tif l.stack {\n\t\te.Stack()\n\t}\n\treturn e\n}\n\n// should returns true if the log event should be logged.\nfunc (l *Logger) should(lvl Level) bool {\n\tif l.w == nil {\n\t\treturn false\n\t}\n\tif lvl < l.level || lvl < GlobalLevel() {\n\t\treturn false\n\t}\n\tif l.sampler != nil && !samplingDisabled() {\n\t\treturn l.sampler.Sample(lvl)\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "log",
          "type": "tree",
          "content": null
        },
        {
          "name": "log_example_test.go",
          "type": "blob",
          "size": 10.9609375,
          "content": "// +build !binary_log\n\npackage zerolog_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\tstdlog \"log\"\n\t\"net\"\n\t\"os\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n)\n\nfunc ExampleNew() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Info().Msg(\"hello world\")\n\t// Output: {\"level\":\"info\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_With() {\n\tlog := zerolog.New(os.Stdout).\n\t\tWith().\n\t\tStr(\"foo\", \"bar\").\n\t\tLogger()\n\n\tlog.Info().Msg(\"hello world\")\n\n\t// Output: {\"level\":\"info\",\"foo\":\"bar\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Level() {\n\tlog := zerolog.New(os.Stdout).Level(zerolog.WarnLevel)\n\n\tlog.Info().Msg(\"filtered out message\")\n\tlog.Error().Msg(\"kept message\")\n\n\t// Output: {\"level\":\"error\",\"message\":\"kept message\"}\n}\n\nfunc ExampleLogger_Sample() {\n\tlog := zerolog.New(os.Stdout).Sample(&zerolog.BasicSampler{N: 2})\n\n\tlog.Info().Msg(\"message 1\")\n\tlog.Info().Msg(\"message 2\")\n\tlog.Info().Msg(\"message 3\")\n\tlog.Info().Msg(\"message 4\")\n\n\t// Output: {\"level\":\"info\",\"message\":\"message 1\"}\n\t// {\"level\":\"info\",\"message\":\"message 3\"}\n}\n\ntype LevelNameHook struct{}\n\nfunc (h LevelNameHook) Run(e *zerolog.Event, l zerolog.Level, msg string) {\n\tif l != zerolog.NoLevel {\n\t\te.Str(\"level_name\", l.String())\n\t} else {\n\t\te.Str(\"level_name\", \"NoLevel\")\n\t}\n}\n\ntype MessageHook string\n\nfunc (h MessageHook) Run(e *zerolog.Event, l zerolog.Level, msg string) {\n\te.Str(\"the_message\", msg)\n}\n\nfunc ExampleLogger_Hook() {\n\tvar levelNameHook LevelNameHook\n\tvar messageHook MessageHook = \"The message\"\n\n\tlog := zerolog.New(os.Stdout).Hook(levelNameHook, messageHook)\n\n\tlog.Info().Msg(\"hello world\")\n\n\t// Output: {\"level\":\"info\",\"level_name\":\"info\",\"the_message\":\"hello world\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Print() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Print(\"hello world\")\n\n\t// Output: {\"level\":\"debug\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Printf() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Printf(\"hello %s\", \"world\")\n\n\t// Output: {\"level\":\"debug\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Println() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Println(\"hello world\")\n\n\t// Output: {\"level\":\"debug\",\"message\":\"hello world\\n\"}\n}\n\nfunc ExampleLogger_Trace() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Trace().\n\t\tStr(\"foo\", \"bar\").\n\t\tInt(\"n\", 123).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"level\":\"trace\",\"foo\":\"bar\",\"n\":123,\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Debug() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Debug().\n\t\tStr(\"foo\", \"bar\").\n\t\tInt(\"n\", 123).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"level\":\"debug\",\"foo\":\"bar\",\"n\":123,\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Info() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Info().\n\t\tStr(\"foo\", \"bar\").\n\t\tInt(\"n\", 123).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"level\":\"info\",\"foo\":\"bar\",\"n\":123,\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Warn() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Warn().\n\t\tStr(\"foo\", \"bar\").\n\t\tMsg(\"a warning message\")\n\n\t// Output: {\"level\":\"warn\",\"foo\":\"bar\",\"message\":\"a warning message\"}\n}\n\nfunc ExampleLogger_Error() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Error().\n\t\tErr(errors.New(\"some error\")).\n\t\tMsg(\"error doing something\")\n\n\t// Output: {\"level\":\"error\",\"error\":\"some error\",\"message\":\"error doing something\"}\n}\n\nfunc ExampleLogger_WithLevel() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.WithLevel(zerolog.InfoLevel).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"level\":\"info\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Write() {\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tLogger()\n\n\tstdlog.SetFlags(0)\n\tstdlog.SetOutput(log)\n\n\tstdlog.Print(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"message\":\"hello world\"}\n}\n\nfunc ExampleLogger_Log() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tStr(\"bar\", \"baz\").\n\t\tMsg(\"\")\n\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\"}\n}\n\nfunc ExampleEvent_Dict() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tDict(\"dict\", zerolog.Dict().\n\t\t\tStr(\"bar\", \"baz\").\n\t\t\tInt(\"n\", 1),\n\t\t).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"dict\":{\"bar\":\"baz\",\"n\":1},\"message\":\"hello world\"}\n}\n\ntype User struct {\n\tName    string\n\tAge     int\n\tCreated time.Time\n}\n\nfunc (u User) MarshalZerologObject(e *zerolog.Event) {\n\te.Str(\"name\", u.Name).\n\t\tInt(\"age\", u.Age).\n\t\tTime(\"created\", u.Created)\n}\n\ntype Price struct {\n\tval  uint64\n\tprec int\n\tunit string\n}\n\nfunc (p Price) MarshalZerologObject(e *zerolog.Event) {\n\tdenom := uint64(1)\n\tfor i := 0; i < p.prec; i++ {\n\t\tdenom *= 10\n\t}\n\tresult := []byte(p.unit)\n\tresult = append(result, fmt.Sprintf(\"%d.%d\", p.val/denom, p.val%denom)...)\n\te.Str(\"price\", string(result))\n}\n\ntype Users []User\n\nfunc (uu Users) MarshalZerologArray(a *zerolog.Array) {\n\tfor _, u := range uu {\n\t\ta.Object(u)\n\t}\n}\n\nfunc ExampleEvent_Array() {\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"array\", zerolog.Arr().\n\t\t\tStr(\"baz\").\n\t\t\tInt(1).\n\t\t\tDict(zerolog.Dict().\n\t\t\t\tStr(\"bar\", \"baz\").\n\t\t\t\tInt(\"n\", 1),\n\t\t\t),\n\t\t).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"array\":[\"baz\",1,{\"bar\":\"baz\",\"n\":1}],\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Array_object() {\n\tlog := zerolog.New(os.Stdout)\n\n\t// Users implements zerolog.LogArrayMarshaler\n\tu := Users{\n\t\tUser{\"John\", 35, time.Time{}},\n\t\tUser{\"Bob\", 55, time.Time{}},\n\t}\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"users\", u).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"users\":[{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},{\"name\":\"Bob\",\"age\":55,\"created\":\"0001-01-01T00:00:00Z\"}],\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Object() {\n\tlog := zerolog.New(os.Stdout)\n\n\t// User implements zerolog.LogObjectMarshaler\n\tu := User{\"John\", 35, time.Time{}}\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tObject(\"user\", u).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"user\":{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_EmbedObject() {\n\tlog := zerolog.New(os.Stdout)\n\n\tprice := Price{val: 6449, prec: 2, unit: \"$\"}\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tEmbedObject(price).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"price\":\"$64.49\",\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Interface() {\n\tlog := zerolog.New(os.Stdout)\n\n\tobj := struct {\n\t\tName string `json:\"name\"`\n\t}{\n\t\tName: \"john\",\n\t}\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tInterface(\"obj\", obj).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"obj\":{\"name\":\"john\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Dur() {\n\td := 10 * time.Second\n\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tDur(\"dur\", d).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"dur\":10000,\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Durs() {\n\td := []time.Duration{\n\t\t10 * time.Second,\n\t\t20 * time.Second,\n\t}\n\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tDurs(\"durs\", d).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"durs\":[10000,20000],\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Fields_map() {\n\tfields := map[string]interface{}{\n\t\t\"bar\": \"baz\",\n\t\t\"n\":   1,\n\t}\n\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n\nfunc ExampleEvent_Fields_slice() {\n\tfields := []interface{}{\n\t\t\"bar\", \"baz\",\n\t\t\"n\", 1,\n\t}\n\n\tlog := zerolog.New(os.Stdout)\n\n\tlog.Log().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tMsg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Dict() {\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tDict(\"dict\", zerolog.Dict().\n\t\t\tStr(\"bar\", \"baz\").\n\t\t\tInt(\"n\", 1),\n\t\t).Logger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"dict\":{\"bar\":\"baz\",\"n\":1},\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Array() {\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"array\", zerolog.Arr().\n\t\t\tStr(\"baz\").\n\t\t\tInt(1),\n\t\t).Logger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"array\":[\"baz\",1],\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Array_object() {\n\t// Users implements zerolog.LogArrayMarshaler\n\tu := Users{\n\t\tUser{\"John\", 35, time.Time{}},\n\t\tUser{\"Bob\", 55, time.Time{}},\n\t}\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tArray(\"users\", u).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"users\":[{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},{\"name\":\"Bob\",\"age\":55,\"created\":\"0001-01-01T00:00:00Z\"}],\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Object() {\n\t// User implements zerolog.LogObjectMarshaler\n\tu := User{\"John\", 35, time.Time{}}\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tObject(\"user\", u).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"user\":{\"name\":\"John\",\"age\":35,\"created\":\"0001-01-01T00:00:00Z\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_EmbedObject() {\n\n\tprice := Price{val: 6449, prec: 2, unit: \"$\"}\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tEmbedObject(price).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"price\":\"$64.49\",\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Interface() {\n\tobj := struct {\n\t\tName string `json:\"name\"`\n\t}{\n\t\tName: \"john\",\n\t}\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tInterface(\"obj\", obj).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"obj\":{\"name\":\"john\"},\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Dur() {\n\td := 10 * time.Second\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tDur(\"dur\", d).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"dur\":10000,\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Durs() {\n\td := []time.Duration{\n\t\t10 * time.Second,\n\t\t20 * time.Second,\n\t}\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tDurs(\"durs\", d).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"durs\":[10000,20000],\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_IPAddr() {\n\thostIP := net.IP{192, 168, 0, 100}\n\tlog := zerolog.New(os.Stdout).With().\n\t\tIPAddr(\"HostIP\", hostIP).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"HostIP\":\"192.168.0.100\",\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_IPPrefix() {\n\troute := net.IPNet{IP: net.IP{192, 168, 0, 0}, Mask: net.CIDRMask(24, 32)}\n\tlog := zerolog.New(os.Stdout).With().\n\t\tIPPrefix(\"Route\", route).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"Route\":\"192.168.0.0/24\",\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_MACAddr() {\n\tmac := net.HardwareAddr{0x00, 0x14, 0x22, 0x01, 0x23, 0x45}\n\tlog := zerolog.New(os.Stdout).With().\n\t\tMACAddr(\"hostMAC\", mac).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"hostMAC\":\"00:14:22:01:23:45\",\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Fields_map() {\n\tfields := map[string]interface{}{\n\t\t\"bar\": \"baz\",\n\t\t\"n\":   1,\n\t}\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n\nfunc ExampleContext_Fields_slice() {\n\tfields := []interface{}{\n\t\t\"bar\", \"baz\",\n\t\t\"n\", 1,\n\t}\n\n\tlog := zerolog.New(os.Stdout).With().\n\t\tStr(\"foo\", \"bar\").\n\t\tFields(fields).\n\t\tLogger()\n\n\tlog.Log().Msg(\"hello world\")\n\n\t// Output: {\"foo\":\"bar\",\"bar\":\"baz\",\"n\":1,\"message\":\"hello world\"}\n}\n"
        },
        {
          "name": "log_test.go",
          "type": "blob",
          "size": 32.822265625,
          "content": "package zerolog\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestLog(t *testing.T) {\n\tt.Run(\"empty\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out)\n\t\tlog.Log().Msg(\"\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), \"{}\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"one-field\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out)\n\t\tlog.Log().Str(\"foo\", \"bar\").Msg(\"\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"foo\":\"bar\"}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"two-field\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out)\n\t\tlog.Log().\n\t\t\tStr(\"foo\", \"bar\").\n\t\t\tInt(\"n\", 123).\n\t\t\tMsg(\"\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"foo\":\"bar\",\"n\":123}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n}\n\nfunc TestInfo(t *testing.T) {\n\tt.Run(\"empty\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out)\n\t\tlog.Info().Msg(\"\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"info\"}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"one-field\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out)\n\t\tlog.Info().Str(\"foo\", \"bar\").Msg(\"\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"info\",\"foo\":\"bar\"}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"two-field\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out)\n\t\tlog.Info().\n\t\t\tStr(\"foo\", \"bar\").\n\t\t\tInt(\"n\", 123).\n\t\t\tMsg(\"\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"info\",\"foo\":\"bar\",\"n\":123}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n}\n\nfunc TestEmptyLevelFieldName(t *testing.T) {\n\tfieldName := LevelFieldName\n\tLevelFieldName = \"\"\n\n\tt.Run(\"empty setting\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out)\n\t\tlog.Info().\n\t\t\tStr(\"foo\", \"bar\").\n\t\t\tInt(\"n\", 123).\n\t\t\tMsg(\"\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"foo\":\"bar\",\"n\":123}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\tLevelFieldName = fieldName\n}\n\nfunc TestWith(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tctx := New(out).With().\n\t\tStr(\"string\", \"foo\").\n\t\tStringer(\"stringer\", net.IP{127, 0, 0, 1}).\n\t\tStringer(\"stringer_nil\", nil).\n\t\tBytes(\"bytes\", []byte(\"bar\")).\n\t\tHex(\"hex\", []byte{0x12, 0xef}).\n\t\tRawJSON(\"json\", []byte(`{\"some\":\"json\"}`)).\n\t\tAnErr(\"some_err\", nil).\n\t\tErr(errors.New(\"some error\")).\n\t\tBool(\"bool\", true).\n\t\tInt(\"int\", 1).\n\t\tInt8(\"int8\", 2).\n\t\tInt16(\"int16\", 3).\n\t\tInt32(\"int32\", 4).\n\t\tInt64(\"int64\", 5).\n\t\tUint(\"uint\", 6).\n\t\tUint8(\"uint8\", 7).\n\t\tUint16(\"uint16\", 8).\n\t\tUint32(\"uint32\", 9).\n\t\tUint64(\"uint64\", 10).\n\t\tFloat32(\"float32\", 11.101).\n\t\tFloat64(\"float64\", 12.30303).\n\t\tTime(\"time\", time.Time{}).\n\t\tCtx(context.Background())\n\t_, file, line, _ := runtime.Caller(0)\n\tcaller := fmt.Sprintf(\"%s:%d\", file, line+3)\n\tlog := ctx.Caller().Logger()\n\tlog.Log().Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"string\":\"foo\",\"stringer\":\"127.0.0.1\",\"stringer_nil\":null,\"bytes\":\"bar\",\"hex\":\"12ef\",\"json\":{\"some\":\"json\"},\"error\":\"some error\",\"bool\":true,\"int\":1,\"int8\":2,\"int16\":3,\"int32\":4,\"int64\":5,\"uint\":6,\"uint8\":7,\"uint16\":8,\"uint32\":9,\"uint64\":10,\"float32\":11.101,\"float64\":12.30303,\"time\":\"0001-01-01T00:00:00Z\",\"caller\":\"`+caller+`\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\n\t// Validate CallerWithSkipFrameCount.\n\tout.Reset()\n\t_, file, line, _ = runtime.Caller(0)\n\tcaller = fmt.Sprintf(\"%s:%d\", file, line+5)\n\tlog = ctx.CallerWithSkipFrameCount(3).Logger()\n\tfunc() {\n\t\tlog.Log().Msg(\"\")\n\t}()\n\t// The above line is a little contrived, but the line above should be the line due\n\t// to the extra frame skip.\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"string\":\"foo\",\"stringer\":\"127.0.0.1\",\"stringer_nil\":null,\"bytes\":\"bar\",\"hex\":\"12ef\",\"json\":{\"some\":\"json\"},\"error\":\"some error\",\"bool\":true,\"int\":1,\"int8\":2,\"int16\":3,\"int32\":4,\"int64\":5,\"uint\":6,\"uint8\":7,\"uint16\":8,\"uint32\":9,\"uint64\":10,\"float32\":11.101,\"float64\":12.30303,\"time\":\"0001-01-01T00:00:00Z\",\"caller\":\"`+caller+`\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestWithReset(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tctx := New(out).With().\n\t\tStr(\"string\", \"foo\").\n\t\tStringer(\"stringer\", net.IP{127, 0, 0, 1}).\n\t\tStringer(\"stringer_nil\", nil).\n\t\tReset().\n\t\tBytes(\"bytes\", []byte(\"bar\")).\n\t\tHex(\"hex\", []byte{0x12, 0xef}).\n\t\tUint64(\"uint64\", 10).\n\t\tFloat64(\"float64\", 12.30303).\n\t\tCtx(context.Background())\n\tlog := ctx.Logger()\n\tlog.Log().Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"bytes\":\"bar\",\"hex\":\"12ef\",\"uint64\":10,\"float64\":12.30303}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsMap(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().Fields(map[string]interface{}{\n\t\t\"nil\":     nil,\n\t\t\"string\":  \"foo\",\n\t\t\"bytes\":   []byte(\"bar\"),\n\t\t\"error\":   errors.New(\"some error\"),\n\t\t\"bool\":    true,\n\t\t\"int\":     int(1),\n\t\t\"int8\":    int8(2),\n\t\t\"int16\":   int16(3),\n\t\t\"int32\":   int32(4),\n\t\t\"int64\":   int64(5),\n\t\t\"uint\":    uint(6),\n\t\t\"uint8\":   uint8(7),\n\t\t\"uint16\":  uint16(8),\n\t\t\"uint32\":  uint32(9),\n\t\t\"uint64\":  uint64(10),\n\t\t\"float32\": float32(11),\n\t\t\"float64\": float64(12),\n\t\t\"ipv6\":    net.IP{0x20, 0x01, 0x0d, 0xb8, 0x85, 0xa3, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x2e, 0x03, 0x70, 0x73, 0x34},\n\t\t\"dur\":     1 * time.Second,\n\t\t\"time\":    time.Time{},\n\t\t\"obj\":     obj{\"a\", \"b\", 1},\n\t}).Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"bool\":true,\"bytes\":\"bar\",\"dur\":1000,\"error\":\"some error\",\"float32\":11,\"float64\":12,\"int\":1,\"int16\":3,\"int32\":4,\"int64\":5,\"int8\":2,\"ipv6\":\"2001:db8:85a3::8a2e:370:7334\",\"nil\":null,\"obj\":{\"Pub\":\"a\",\"Tag\":\"b\",\"priv\":1},\"string\":\"foo\",\"time\":\"0001-01-01T00:00:00Z\",\"uint\":6,\"uint16\":8,\"uint32\":9,\"uint64\":10,\"uint8\":7}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsMapPnt(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().Fields(map[string]interface{}{\n\t\t\"string\":  new(string),\n\t\t\"bool\":    new(bool),\n\t\t\"int\":     new(int),\n\t\t\"int8\":    new(int8),\n\t\t\"int16\":   new(int16),\n\t\t\"int32\":   new(int32),\n\t\t\"int64\":   new(int64),\n\t\t\"uint\":    new(uint),\n\t\t\"uint8\":   new(uint8),\n\t\t\"uint16\":  new(uint16),\n\t\t\"uint32\":  new(uint32),\n\t\t\"uint64\":  new(uint64),\n\t\t\"float32\": new(float32),\n\t\t\"float64\": new(float64),\n\t\t\"dur\":     new(time.Duration),\n\t\t\"time\":    new(time.Time),\n\t}).Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"bool\":false,\"dur\":0,\"float32\":0,\"float64\":0,\"int\":0,\"int16\":0,\"int32\":0,\"int64\":0,\"int8\":0,\"string\":\"\",\"time\":\"0001-01-01T00:00:00Z\",\"uint\":0,\"uint16\":0,\"uint32\":0,\"uint64\":0,\"uint8\":0}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsMapNilPnt(t *testing.T) {\n\tvar (\n\t\tstringPnt  *string\n\t\tboolPnt    *bool\n\t\tintPnt     *int\n\t\tint8Pnt    *int8\n\t\tint16Pnt   *int16\n\t\tint32Pnt   *int32\n\t\tint64Pnt   *int64\n\t\tuintPnt    *uint\n\t\tuint8Pnt   *uint8\n\t\tuint16Pnt  *uint16\n\t\tuint32Pnt  *uint32\n\t\tuint64Pnt  *uint64\n\t\tfloat32Pnt *float32\n\t\tfloat64Pnt *float64\n\t\tdurPnt     *time.Duration\n\t\ttimePnt    *time.Time\n\t)\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tfields := map[string]interface{}{\n\t\t\"string\":  stringPnt,\n\t\t\"bool\":    boolPnt,\n\t\t\"int\":     intPnt,\n\t\t\"int8\":    int8Pnt,\n\t\t\"int16\":   int16Pnt,\n\t\t\"int32\":   int32Pnt,\n\t\t\"int64\":   int64Pnt,\n\t\t\"uint\":    uintPnt,\n\t\t\"uint8\":   uint8Pnt,\n\t\t\"uint16\":  uint16Pnt,\n\t\t\"uint32\":  uint32Pnt,\n\t\t\"uint64\":  uint64Pnt,\n\t\t\"float32\": float32Pnt,\n\t\t\"float64\": float64Pnt,\n\t\t\"dur\":     durPnt,\n\t\t\"time\":    timePnt,\n\t}\n\n\tlog.Log().Fields(fields).Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"bool\":null,\"dur\":null,\"float32\":null,\"float64\":null,\"int\":null,\"int16\":null,\"int32\":null,\"int64\":null,\"int8\":null,\"string\":null,\"time\":null,\"uint\":null,\"uint16\":null,\"uint32\":null,\"uint64\":null,\"uint8\":null}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsSlice(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().Fields([]interface{}{\n\t\t\"nil\", nil,\n\t\t\"string\", \"foo\",\n\t\t\"bytes\", []byte(\"bar\"),\n\t\t\"error\", errors.New(\"some error\"),\n\t\t\"bool\", true,\n\t\t\"int\", int(1),\n\t\t\"int8\", int8(2),\n\t\t\"int16\", int16(3),\n\t\t\"int32\", int32(4),\n\t\t\"int64\", int64(5),\n\t\t\"uint\", uint(6),\n\t\t\"uint8\", uint8(7),\n\t\t\"uint16\", uint16(8),\n\t\t\"uint32\", uint32(9),\n\t\t\"uint64\", uint64(10),\n\t\t\"float32\", float32(11),\n\t\t\"float64\", float64(12),\n\t\t\"ipv6\", net.IP{0x20, 0x01, 0x0d, 0xb8, 0x85, 0xa3, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x2e, 0x03, 0x70, 0x73, 0x34},\n\t\t\"dur\", 1 * time.Second,\n\t\t\"time\", time.Time{},\n\t\t\"obj\", obj{\"a\", \"b\", 1},\n\t}).Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"nil\":null,\"string\":\"foo\",\"bytes\":\"bar\",\"error\":\"some error\",\"bool\":true,\"int\":1,\"int8\":2,\"int16\":3,\"int32\":4,\"int64\":5,\"uint\":6,\"uint8\":7,\"uint16\":8,\"uint32\":9,\"uint64\":10,\"float32\":11,\"float64\":12,\"ipv6\":\"2001:db8:85a3::8a2e:370:7334\",\"dur\":1000,\"time\":\"0001-01-01T00:00:00Z\",\"obj\":{\"Pub\":\"a\",\"Tag\":\"b\",\"priv\":1}}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsSliceExtraneous(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().Fields([]interface{}{\n\t\t\"string\", \"foo\",\n\t\t\"error\", errors.New(\"some error\"),\n\t\t32, \"valueForNonStringKey\",\n\t\t\"bool\", true,\n\t\t\"int\", int(1),\n\t\t\"keyWithoutValue\",\n\t}).Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"string\":\"foo\",\"error\":\"some error\",\"bool\":true,\"int\":1}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsNotMapSlice(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().\n\t\tFields(obj{\"a\", \"b\", 1}).\n\t\tFields(\"string\").\n\t\tFields(1).\n\t\tMsg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFields(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tnow := time.Now()\n\t_, file, line, _ := runtime.Caller(0)\n\tcaller := fmt.Sprintf(\"%s:%d\", file, line+3)\n\tlog.Log().\n\t\tCaller().\n\t\tStr(\"string\", \"foo\").\n\t\tStringer(\"stringer\", net.IP{127, 0, 0, 1}).\n\t\tStringer(\"stringer_nil\", nil).\n\t\tBytes(\"bytes\", []byte(\"bar\")).\n\t\tHex(\"hex\", []byte{0x12, 0xef}).\n\t\tRawJSON(\"json\", []byte(`{\"some\":\"json\"}`)).\n\t\tRawCBOR(\"cbor\", []byte{0x83, 0x01, 0x82, 0x02, 0x03, 0x82, 0x04, 0x05}).\n\t\tFunc(func(e *Event) { e.Str(\"func\", \"func_output\") }).\n\t\tAnErr(\"some_err\", nil).\n\t\tErr(errors.New(\"some error\")).\n\t\tBool(\"bool\", true).\n\t\tInt(\"int\", 1).\n\t\tInt8(\"int8\", 2).\n\t\tInt16(\"int16\", 3).\n\t\tInt32(\"int32\", 4).\n\t\tInt64(\"int64\", 5).\n\t\tUint(\"uint\", 6).\n\t\tUint8(\"uint8\", 7).\n\t\tUint16(\"uint16\", 8).\n\t\tUint32(\"uint32\", 9).\n\t\tUint64(\"uint64\", 10).\n\t\tIPAddr(\"IPv4\", net.IP{192, 168, 0, 100}).\n\t\tIPAddr(\"IPv6\", net.IP{0x20, 0x01, 0x0d, 0xb8, 0x85, 0xa3, 0x00, 0x00, 0x00, 0x00, 0x8a, 0x2e, 0x03, 0x70, 0x73, 0x34}).\n\t\tMACAddr(\"Mac\", net.HardwareAddr{0x00, 0x14, 0x22, 0x01, 0x23, 0x45}).\n\t\tIPPrefix(\"Prefix\", net.IPNet{IP: net.IP{192, 168, 0, 100}, Mask: net.CIDRMask(24, 32)}).\n\t\tFloat32(\"float32\", 11.1234).\n\t\tFloat64(\"float64\", 12.321321321).\n\t\tDur(\"dur\", 1*time.Second).\n\t\tTime(\"time\", time.Time{}).\n\t\tTimeDiff(\"diff\", now, now.Add(-10*time.Second)).\n\t\tCtx(context.Background()).\n\t\tMsg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"caller\":\"`+caller+`\",\"string\":\"foo\",\"stringer\":\"127.0.0.1\",\"stringer_nil\":null,\"bytes\":\"bar\",\"hex\":\"12ef\",\"json\":{\"some\":\"json\"},\"cbor\":\"data:application/cbor;base64,gwGCAgOCBAU=\",\"func\":\"func_output\",\"error\":\"some error\",\"bool\":true,\"int\":1,\"int8\":2,\"int16\":3,\"int32\":4,\"int64\":5,\"uint\":6,\"uint8\":7,\"uint16\":8,\"uint32\":9,\"uint64\":10,\"IPv4\":\"192.168.0.100\",\"IPv6\":\"2001:db8:85a3::8a2e:370:7334\",\"Mac\":\"00:14:22:01:23:45\",\"Prefix\":\"192.168.0.100/24\",\"float32\":11.1234,\"float64\":12.321321321,\"dur\":1000,\"time\":\"0001-01-01T00:00:00Z\",\"diff\":10000}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsArrayEmpty(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().\n\t\tStrs(\"string\", []string{}).\n\t\tStringers(\"stringer\", []fmt.Stringer{}).\n\t\tErrs(\"err\", []error{}).\n\t\tBools(\"bool\", []bool{}).\n\t\tInts(\"int\", []int{}).\n\t\tInts8(\"int8\", []int8{}).\n\t\tInts16(\"int16\", []int16{}).\n\t\tInts32(\"int32\", []int32{}).\n\t\tInts64(\"int64\", []int64{}).\n\t\tUints(\"uint\", []uint{}).\n\t\tUints8(\"uint8\", []uint8{}).\n\t\tUints16(\"uint16\", []uint16{}).\n\t\tUints32(\"uint32\", []uint32{}).\n\t\tUints64(\"uint64\", []uint64{}).\n\t\tFloats32(\"float32\", []float32{}).\n\t\tFloats64(\"float64\", []float64{}).\n\t\tDurs(\"dur\", []time.Duration{}).\n\t\tTimes(\"time\", []time.Time{}).\n\t\tMsg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"string\":[],\"stringer\":[],\"err\":[],\"bool\":[],\"int\":[],\"int8\":[],\"int16\":[],\"int32\":[],\"int64\":[],\"uint\":[],\"uint8\":[],\"uint16\":[],\"uint32\":[],\"uint64\":[],\"float32\":[],\"float64\":[],\"dur\":[],\"time\":[]}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsArraySingleElement(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().\n\t\tStrs(\"string\", []string{\"foo\"}).\n\t\tStringers(\"stringer\", []fmt.Stringer{net.IP{127, 0, 0, 1}}).\n\t\tErrs(\"err\", []error{errors.New(\"some error\")}).\n\t\tBools(\"bool\", []bool{true}).\n\t\tInts(\"int\", []int{1}).\n\t\tInts8(\"int8\", []int8{2}).\n\t\tInts16(\"int16\", []int16{3}).\n\t\tInts32(\"int32\", []int32{4}).\n\t\tInts64(\"int64\", []int64{5}).\n\t\tUints(\"uint\", []uint{6}).\n\t\tUints8(\"uint8\", []uint8{7}).\n\t\tUints16(\"uint16\", []uint16{8}).\n\t\tUints32(\"uint32\", []uint32{9}).\n\t\tUints64(\"uint64\", []uint64{10}).\n\t\tFloats32(\"float32\", []float32{11}).\n\t\tFloats64(\"float64\", []float64{12}).\n\t\tDurs(\"dur\", []time.Duration{1 * time.Second}).\n\t\tTimes(\"time\", []time.Time{{}}).\n\t\tMsg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"string\":[\"foo\"],\"stringer\":[\"127.0.0.1\"],\"err\":[\"some error\"],\"bool\":[true],\"int\":[1],\"int8\":[2],\"int16\":[3],\"int32\":[4],\"int64\":[5],\"uint\":[6],\"uint8\":[7],\"uint16\":[8],\"uint32\":[9],\"uint64\":[10],\"float32\":[11],\"float64\":[12],\"dur\":[1000],\"time\":[\"0001-01-01T00:00:00Z\"]}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsArrayMultipleElement(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().\n\t\tStrs(\"string\", []string{\"foo\", \"bar\"}).\n\t\tStringers(\"stringer\", []fmt.Stringer{nil, net.IP{127, 0, 0, 1}}).\n\t\tErrs(\"err\", []error{errors.New(\"some error\"), nil}).\n\t\tBools(\"bool\", []bool{true, false}).\n\t\tInts(\"int\", []int{1, 0}).\n\t\tInts8(\"int8\", []int8{2, 0}).\n\t\tInts16(\"int16\", []int16{3, 0}).\n\t\tInts32(\"int32\", []int32{4, 0}).\n\t\tInts64(\"int64\", []int64{5, 0}).\n\t\tUints(\"uint\", []uint{6, 0}).\n\t\tUints8(\"uint8\", []uint8{7, 0}).\n\t\tUints16(\"uint16\", []uint16{8, 0}).\n\t\tUints32(\"uint32\", []uint32{9, 0}).\n\t\tUints64(\"uint64\", []uint64{10, 0}).\n\t\tFloats32(\"float32\", []float32{11, 0}).\n\t\tFloats64(\"float64\", []float64{12, 0}).\n\t\tDurs(\"dur\", []time.Duration{1 * time.Second, 0}).\n\t\tTimes(\"time\", []time.Time{{}, {}}).\n\t\tMsg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"string\":[\"foo\",\"bar\"],\"stringer\":[null,\"127.0.0.1\"],\"err\":[\"some error\",null],\"bool\":[true,false],\"int\":[1,0],\"int8\":[2,0],\"int16\":[3,0],\"int32\":[4,0],\"int64\":[5,0],\"uint\":[6,0],\"uint8\":[7,0],\"uint16\":[8,0],\"uint32\":[9,0],\"uint64\":[10,0],\"float32\":[11,0],\"float64\":[12,0],\"dur\":[1000,0],\"time\":[\"0001-01-01T00:00:00Z\",\"0001-01-01T00:00:00Z\"]}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestFieldsDisabled(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out).Level(InfoLevel)\n\tnow := time.Now()\n\tlog.Debug().\n\t\tStr(\"string\", \"foo\").\n\t\tStringer(\"stringer\", net.IP{127, 0, 0, 1}).\n\t\tBytes(\"bytes\", []byte(\"bar\")).\n\t\tHex(\"hex\", []byte{0x12, 0xef}).\n\t\tAnErr(\"some_err\", nil).\n\t\tErr(errors.New(\"some error\")).\n\t\tFunc(func(e *Event) { e.Str(\"func\", \"func_output\") }).\n\t\tBool(\"bool\", true).\n\t\tInt(\"int\", 1).\n\t\tInt8(\"int8\", 2).\n\t\tInt16(\"int16\", 3).\n\t\tInt32(\"int32\", 4).\n\t\tInt64(\"int64\", 5).\n\t\tUint(\"uint\", 6).\n\t\tUint8(\"uint8\", 7).\n\t\tUint16(\"uint16\", 8).\n\t\tUint32(\"uint32\", 9).\n\t\tUint64(\"uint64\", 10).\n\t\tFloat32(\"float32\", 11).\n\t\tFloat64(\"float64\", 12).\n\t\tDur(\"dur\", 1*time.Second).\n\t\tTime(\"time\", time.Time{}).\n\t\tTimeDiff(\"diff\", now, now.Add(-10*time.Second)).\n\t\tCtx(context.Background()).\n\t\tMsg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), \"\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestMsgf(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().Msgf(\"one %s %.1f %d %v\", \"two\", 3.4, 5, errors.New(\"six\"))\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"message\":\"one two 3.4 5 six\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestWithAndFieldsCombined(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out).With().Str(\"f1\", \"val\").Str(\"f2\", \"val\").Logger()\n\tlog.Log().Str(\"f3\", \"val\").Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"f1\":\"val\",\"f2\":\"val\",\"f3\":\"val\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestLevel(t *testing.T) {\n\tt.Run(\"Disabled\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out).Level(Disabled)\n\t\tlog.Info().Msg(\"test\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), \"\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NoLevel/Disabled\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out).Level(Disabled)\n\t\tlog.Log().Msg(\"test\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), \"\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NoLevel/Info\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out).Level(InfoLevel)\n\t\tlog.Log().Msg(\"test\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NoLevel/Panic\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out).Level(PanicLevel)\n\t\tlog.Log().Msg(\"test\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"NoLevel/WithLevel\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out).Level(InfoLevel)\n\t\tlog.WithLevel(NoLevel).Msg(\"test\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Info\", func(t *testing.T) {\n\t\tout := &bytes.Buffer{}\n\t\tlog := New(out).Level(InfoLevel)\n\t\tlog.Info().Msg(\"test\")\n\t\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"info\",\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t\t}\n\t})\n}\n\nfunc TestGetLevel(t *testing.T) {\n\tlevels := []Level{\n\t\tDebugLevel,\n\t\tInfoLevel,\n\t\tWarnLevel,\n\t\tErrorLevel,\n\t\tFatalLevel,\n\t\tPanicLevel,\n\t\tNoLevel,\n\t\tDisabled,\n\t}\n\tfor _, level := range levels {\n\t\tif got, want := New(nil).Level(level).GetLevel(), level; got != want {\n\t\t\tt.Errorf(\"GetLevel() = %v, want: %v\", got, want)\n\t\t}\n\t}\n}\n\nfunc TestSampling(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out).Sample(&BasicSampler{N: 2})\n\tlog.Log().Int(\"i\", 1).Msg(\"\")\n\tlog.Log().Int(\"i\", 2).Msg(\"\")\n\tlog.Log().Int(\"i\", 3).Msg(\"\")\n\tlog.Log().Int(\"i\", 4).Msg(\"\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), \"{\\\"i\\\":1}\\n{\\\"i\\\":3}\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestDiscard(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().Discard().Str(\"a\", \"b\").Msgf(\"one %s %.1f %d %v\", \"two\", 3.4, 5, errors.New(\"six\"))\n\tif got, want := decodeIfBinaryToString(out.Bytes()), \"\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\n\t// Double call\n\tlog.Log().Discard().Discard().Str(\"a\", \"b\").Msgf(\"one %s %.1f %d %v\", \"two\", 3.4, 5, errors.New(\"six\"))\n\tif got, want := decodeIfBinaryToString(out.Bytes()), \"\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\ntype levelWriter struct {\n\tops []struct {\n\t\tl Level\n\t\tp string\n\t}\n}\n\nfunc (lw *levelWriter) Write(p []byte) (int, error) {\n\treturn len(p), nil\n}\n\nfunc (lw *levelWriter) WriteLevel(lvl Level, p []byte) (int, error) {\n\tp = decodeIfBinaryToBytes(p)\n\tlw.ops = append(lw.ops, struct {\n\t\tl Level\n\t\tp string\n\t}{lvl, string(p)})\n\treturn len(p), nil\n}\n\nfunc TestLevelWriter(t *testing.T) {\n\tlw := &levelWriter{\n\t\tops: []struct {\n\t\t\tl Level\n\t\t\tp string\n\t\t}{},\n\t}\n\n\t// Allow extra-verbose logs.\n\tSetGlobalLevel(TraceLevel - 1)\n\tlog := New(lw).Level(TraceLevel - 1)\n\n\tlog.Trace().Msg(\"0\")\n\tlog.Debug().Msg(\"1\")\n\tlog.Info().Msg(\"2\")\n\tlog.Warn().Msg(\"3\")\n\tlog.Error().Msg(\"4\")\n\tlog.Log().Msg(\"nolevel-1\")\n\tlog.WithLevel(TraceLevel).Msg(\"5\")\n\tlog.WithLevel(DebugLevel).Msg(\"6\")\n\tlog.WithLevel(InfoLevel).Msg(\"7\")\n\tlog.WithLevel(WarnLevel).Msg(\"8\")\n\tlog.WithLevel(ErrorLevel).Msg(\"9\")\n\tlog.WithLevel(NoLevel).Msg(\"nolevel-2\")\n\tlog.WithLevel(-1).Msg(\"-1\") // Same as TraceLevel\n\tlog.WithLevel(-2).Msg(\"-2\") // Will log\n\tlog.WithLevel(-3).Msg(\"-3\") // Will not log\n\n\twant := []struct {\n\t\tl Level\n\t\tp string\n\t}{\n\t\t{TraceLevel, `{\"level\":\"trace\",\"message\":\"0\"}` + \"\\n\"},\n\t\t{DebugLevel, `{\"level\":\"debug\",\"message\":\"1\"}` + \"\\n\"},\n\t\t{InfoLevel, `{\"level\":\"info\",\"message\":\"2\"}` + \"\\n\"},\n\t\t{WarnLevel, `{\"level\":\"warn\",\"message\":\"3\"}` + \"\\n\"},\n\t\t{ErrorLevel, `{\"level\":\"error\",\"message\":\"4\"}` + \"\\n\"},\n\t\t{NoLevel, `{\"message\":\"nolevel-1\"}` + \"\\n\"},\n\t\t{TraceLevel, `{\"level\":\"trace\",\"message\":\"5\"}` + \"\\n\"},\n\t\t{DebugLevel, `{\"level\":\"debug\",\"message\":\"6\"}` + \"\\n\"},\n\t\t{InfoLevel, `{\"level\":\"info\",\"message\":\"7\"}` + \"\\n\"},\n\t\t{WarnLevel, `{\"level\":\"warn\",\"message\":\"8\"}` + \"\\n\"},\n\t\t{ErrorLevel, `{\"level\":\"error\",\"message\":\"9\"}` + \"\\n\"},\n\t\t{NoLevel, `{\"message\":\"nolevel-2\"}` + \"\\n\"},\n\t\t{Level(-1), `{\"level\":\"trace\",\"message\":\"-1\"}` + \"\\n\"},\n\t\t{Level(-2), `{\"level\":\"-2\",\"message\":\"-2\"}` + \"\\n\"},\n\t}\n\tif got := lw.ops; !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"invalid ops:\\ngot:\\n%v\\nwant:\\n%v\", got, want)\n\t}\n}\n\nfunc TestContextTimestamp(t *testing.T) {\n\tTimestampFunc = func() time.Time {\n\t\treturn time.Date(2001, time.February, 3, 4, 5, 6, 7, time.UTC)\n\t}\n\tdefer func() {\n\t\tTimestampFunc = time.Now\n\t}()\n\tout := &bytes.Buffer{}\n\tlog := New(out).With().Timestamp().Str(\"foo\", \"bar\").Logger()\n\tlog.Log().Msg(\"hello world\")\n\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"foo\":\"bar\",\"time\":\"2001-02-03T04:05:06Z\",\"message\":\"hello world\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestEventTimestamp(t *testing.T) {\n\tTimestampFunc = func() time.Time {\n\t\treturn time.Date(2001, time.February, 3, 4, 5, 6, 7, time.UTC)\n\t}\n\tdefer func() {\n\t\tTimestampFunc = time.Now\n\t}()\n\tout := &bytes.Buffer{}\n\tlog := New(out).With().Str(\"foo\", \"bar\").Logger()\n\tlog.Log().Timestamp().Msg(\"hello world\")\n\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"foo\":\"bar\",\"time\":\"2001-02-03T04:05:06Z\",\"message\":\"hello world\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestOutputWithoutTimestamp(t *testing.T) {\n\tignoredOut := &bytes.Buffer{}\n\tout := &bytes.Buffer{}\n\tlog := New(ignoredOut).Output(out).With().Str(\"foo\", \"bar\").Logger()\n\tlog.Log().Msg(\"hello world\")\n\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"foo\":\"bar\",\"message\":\"hello world\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestOutputWithTimestamp(t *testing.T) {\n\tTimestampFunc = func() time.Time {\n\t\treturn time.Date(2001, time.February, 3, 4, 5, 6, 7, time.UTC)\n\t}\n\tdefer func() {\n\t\tTimestampFunc = time.Now\n\t}()\n\tignoredOut := &bytes.Buffer{}\n\tout := &bytes.Buffer{}\n\tlog := New(ignoredOut).Output(out).With().Timestamp().Str(\"foo\", \"bar\").Logger()\n\tlog.Log().Msg(\"hello world\")\n\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"foo\":\"bar\",\"time\":\"2001-02-03T04:05:06Z\",\"message\":\"hello world\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\ntype loggableError struct {\n\terror\n}\n\nfunc (l loggableError) MarshalZerologObject(e *Event) {\n\te.Str(\"message\", l.error.Error()+\": loggableError\")\n}\n\nfunc TestErrorMarshalFunc(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\n\t// test default behaviour\n\tlog.Log().Err(errors.New(\"err\")).Msg(\"msg\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"error\":\"err\",\"message\":\"msg\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\tout.Reset()\n\n\tlog.Log().Err(loggableError{errors.New(\"err\")}).Msg(\"msg\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"error\":{\"message\":\"err: loggableError\"},\"message\":\"msg\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\tout.Reset()\n\n\t// test overriding the ErrorMarshalFunc\n\toriginalErrorMarshalFunc := ErrorMarshalFunc\n\tdefer func() {\n\t\tErrorMarshalFunc = originalErrorMarshalFunc\n\t}()\n\n\tErrorMarshalFunc = func(err error) interface{} {\n\t\treturn err.Error() + \": marshaled string\"\n\t}\n\tlog.Log().Err(errors.New(\"err\")).Msg(\"msg\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"error\":\"err: marshaled string\",\"message\":\"msg\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\n\tout.Reset()\n\tErrorMarshalFunc = func(err error) interface{} {\n\t\treturn errors.New(err.Error() + \": new error\")\n\t}\n\tlog.Log().Err(errors.New(\"err\")).Msg(\"msg\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"error\":\"err: new error\",\"message\":\"msg\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\n\tout.Reset()\n\tErrorMarshalFunc = func(err error) interface{} {\n\t\treturn loggableError{err}\n\t}\n\tlog.Log().Err(errors.New(\"err\")).Msg(\"msg\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"error\":{\"message\":\"err: loggableError\"},\"message\":\"msg\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestCallerMarshalFunc(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\n\t// test default behaviour this is really brittle due to the line numbers\n\t// actually mattering for validation\n\tpc, file, line, _ := runtime.Caller(0)\n\tcaller := fmt.Sprintf(\"%s:%d\", file, line+2)\n\tlog.Log().Caller().Msg(\"msg\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"caller\":\"`+caller+`\",\"message\":\"msg\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\tout.Reset()\n\n\t// test custom behavior. In this case we'll take just the last directory\n\torigCallerMarshalFunc := CallerMarshalFunc\n\tdefer func() { CallerMarshalFunc = origCallerMarshalFunc }()\n\tCallerMarshalFunc = func(pc uintptr, file string, line int) string {\n\t\tparts := strings.Split(file, \"/\")\n\t\tif len(parts) > 1 {\n\t\t\treturn strings.Join(parts[len(parts)-2:], \"/\") + \":\" + strconv.Itoa(line)\n\t\t}\n\n\t\treturn runtime.FuncForPC(pc).Name() + \":\" + file + \":\" + strconv.Itoa(line)\n\t}\n\tpc, file, line, _ = runtime.Caller(0)\n\tcaller = CallerMarshalFunc(pc, file, line+2)\n\tlog.Log().Caller().Msg(\"msg\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"caller\":\"`+caller+`\",\"message\":\"msg\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n\nfunc TestLevelFieldMarshalFunc(t *testing.T) {\n\torigLevelFieldMarshalFunc := LevelFieldMarshalFunc\n\tLevelFieldMarshalFunc = func(l Level) string {\n\t\treturn strings.ToUpper(l.String())\n\t}\n\tdefer func() {\n\t\tLevelFieldMarshalFunc = origLevelFieldMarshalFunc\n\t}()\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\n\tlog.Debug().Msg(\"test\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"DEBUG\",\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\tout.Reset()\n\n\tlog.Info().Msg(\"test\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"INFO\",\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\tout.Reset()\n\n\tlog.Warn().Msg(\"test\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"WARN\",\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\tout.Reset()\n\n\tlog.Error().Msg(\"test\")\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"level\":\"ERROR\",\"message\":\"test\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n\tout.Reset()\n}\n\ntype errWriter struct {\n\terror\n}\n\nfunc (w errWriter) Write(p []byte) (n int, err error) {\n\treturn 0, w.error\n}\n\nfunc TestErrorHandler(t *testing.T) {\n\tvar got error\n\twant := errors.New(\"write error\")\n\tErrorHandler = func(err error) {\n\t\tgot = err\n\t}\n\tlog := New(errWriter{want})\n\tlog.Log().Msg(\"test\")\n\tif got != want {\n\t\tt.Errorf(\"ErrorHandler err = %#v, want %#v\", got, want)\n\t}\n}\n\nfunc TestUpdateEmptyContext(t *testing.T) {\n\tvar buf bytes.Buffer\n\tlog := New(&buf)\n\n\tlog.UpdateContext(func(c Context) Context {\n\t\treturn c.Str(\"foo\", \"bar\")\n\t})\n\tlog.Info().Msg(\"no panic\")\n\n\twant := `{\"level\":\"info\",\"foo\":\"bar\",\"message\":\"no panic\"}` + \"\\n\"\n\n\tif got := decodeIfBinaryToString(buf.Bytes()); got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %q\\nwant: %q\", got, want)\n\t}\n}\n\nfunc TestLevel_String(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tl    Level\n\t\twant string\n\t}{\n\t\t{\"trace\", TraceLevel, \"trace\"},\n\t\t{\"debug\", DebugLevel, \"debug\"},\n\t\t{\"info\", InfoLevel, \"info\"},\n\t\t{\"warn\", WarnLevel, \"warn\"},\n\t\t{\"error\", ErrorLevel, \"error\"},\n\t\t{\"fatal\", FatalLevel, \"fatal\"},\n\t\t{\"panic\", PanicLevel, \"panic\"},\n\t\t{\"disabled\", Disabled, \"disabled\"},\n\t\t{\"nolevel\", NoLevel, \"\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.l.String(); got != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLevel_MarshalText(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tl    Level\n\t\twant string\n\t}{\n\t\t{\"trace\", TraceLevel, \"trace\"},\n\t\t{\"debug\", DebugLevel, \"debug\"},\n\t\t{\"info\", InfoLevel, \"info\"},\n\t\t{\"warn\", WarnLevel, \"warn\"},\n\t\t{\"error\", ErrorLevel, \"error\"},\n\t\t{\"fatal\", FatalLevel, \"fatal\"},\n\t\t{\"panic\", PanicLevel, \"panic\"},\n\t\t{\"disabled\", Disabled, \"disabled\"},\n\t\t{\"nolevel\", NoLevel, \"\"},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got, err := tt.l.MarshalText(); err != nil {\n\t\t\t\tt.Errorf(\"MarshalText couldn't marshal: %v\", tt.l)\n\t\t\t} else if string(got) != tt.want {\n\t\t\t\tt.Errorf(\"String() = %v, want %v\", string(got), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseLevel(t *testing.T) {\n\ttype args struct {\n\t\tlevelStr string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    Level\n\t\twantErr bool\n\t}{\n\t\t{\"trace\", args{\"trace\"}, TraceLevel, false},\n\t\t{\"debug\", args{\"debug\"}, DebugLevel, false},\n\t\t{\"info\", args{\"info\"}, InfoLevel, false},\n\t\t{\"warn\", args{\"warn\"}, WarnLevel, false},\n\t\t{\"error\", args{\"error\"}, ErrorLevel, false},\n\t\t{\"fatal\", args{\"fatal\"}, FatalLevel, false},\n\t\t{\"panic\", args{\"panic\"}, PanicLevel, false},\n\t\t{\"disabled\", args{\"disabled\"}, Disabled, false},\n\t\t{\"nolevel\", args{\"\"}, NoLevel, false},\n\t\t{\"-1\", args{\"-1\"}, TraceLevel, false},\n\t\t{\"-2\", args{\"-2\"}, Level(-2), false},\n\t\t{\"-3\", args{\"-3\"}, Level(-3), false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := ParseLevel(tt.args.levelStr)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"ParseLevel() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"ParseLevel() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUnmarshalTextLevel(t *testing.T) {\n\ttype args struct {\n\t\tlevelStr string\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\targs    args\n\t\twant    Level\n\t\twantErr bool\n\t}{\n\t\t{\"trace\", args{\"trace\"}, TraceLevel, false},\n\t\t{\"debug\", args{\"debug\"}, DebugLevel, false},\n\t\t{\"info\", args{\"info\"}, InfoLevel, false},\n\t\t{\"warn\", args{\"warn\"}, WarnLevel, false},\n\t\t{\"error\", args{\"error\"}, ErrorLevel, false},\n\t\t{\"fatal\", args{\"fatal\"}, FatalLevel, false},\n\t\t{\"panic\", args{\"panic\"}, PanicLevel, false},\n\t\t{\"disabled\", args{\"disabled\"}, Disabled, false},\n\t\t{\"nolevel\", args{\"\"}, NoLevel, false},\n\t\t{\"-1\", args{\"-1\"}, TraceLevel, false},\n\t\t{\"-2\", args{\"-2\"}, Level(-2), false},\n\t\t{\"-3\", args{\"-3\"}, Level(-3), false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar l Level\n\t\t\terr := l.UnmarshalText([]byte(tt.args.levelStr))\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"UnmarshalText() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif l != tt.want {\n\t\t\t\tt.Errorf(\"UnmarshalText() got = %v, want %v\", l, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHTMLNoEscaping(t *testing.T) {\n\tout := &bytes.Buffer{}\n\tlog := New(out)\n\tlog.Log().Interface(\"head\", \"<test>\").Send()\n\tif got, want := decodeIfBinaryToString(out.Bytes()), `{\"head\":\"<test>\"}`+\"\\n\"; got != want {\n\t\tt.Errorf(\"invalid log output:\\ngot:  %v\\nwant: %v\", got, want)\n\t}\n}\n"
        },
        {
          "name": "not_go112.go",
          "type": "blob",
          "size": 0.072265625,
          "content": "// +build !go1.12\n\npackage zerolog\n\nconst contextCallerSkipFrameCount = 3\n"
        },
        {
          "name": "pkgerrors",
          "type": "tree",
          "content": null
        },
        {
          "name": "pretty.png",
          "type": "blob",
          "size": 116.0537109375,
          "content": null
        },
        {
          "name": "sampler.go",
          "type": "blob",
          "size": 3.1005859375,
          "content": "package zerolog\n\nimport (\n\t\"math/rand\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nvar (\n\t// Often samples log every ~ 10 events.\n\tOften = RandomSampler(10)\n\t// Sometimes samples log every ~ 100 events.\n\tSometimes = RandomSampler(100)\n\t// Rarely samples log every ~ 1000 events.\n\tRarely = RandomSampler(1000)\n)\n\n// Sampler defines an interface to a log sampler.\ntype Sampler interface {\n\t// Sample returns true if the event should be part of the sample, false if\n\t// the event should be dropped.\n\tSample(lvl Level) bool\n}\n\n// RandomSampler use a PRNG to randomly sample an event out of N events,\n// regardless of their level.\ntype RandomSampler uint32\n\n// Sample implements the Sampler interface.\nfunc (s RandomSampler) Sample(lvl Level) bool {\n\tif s <= 0 {\n\t\treturn false\n\t}\n\tif rand.Intn(int(s)) != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// BasicSampler is a sampler that will send every Nth events, regardless of\n// their level.\ntype BasicSampler struct {\n\tN       uint32\n\tcounter uint32\n}\n\n// Sample implements the Sampler interface.\nfunc (s *BasicSampler) Sample(lvl Level) bool {\n\tn := s.N\n\tif n == 0 {\n\t\treturn false\n\t}\n\tif n == 1 {\n\t\treturn true\n\t}\n\tc := atomic.AddUint32(&s.counter, 1)\n\treturn c%n == 1\n}\n\n// BurstSampler lets Burst events pass per Period then pass the decision to\n// NextSampler. If Sampler is not set, all subsequent events are rejected.\ntype BurstSampler struct {\n\t// Burst is the maximum number of event per period allowed before calling\n\t// NextSampler.\n\tBurst uint32\n\t// Period defines the burst period. If 0, NextSampler is always called.\n\tPeriod time.Duration\n\t// NextSampler is the sampler used after the burst is reached. If nil,\n\t// events are always rejected after the burst.\n\tNextSampler Sampler\n\n\tcounter uint32\n\tresetAt int64\n}\n\n// Sample implements the Sampler interface.\nfunc (s *BurstSampler) Sample(lvl Level) bool {\n\tif s.Burst > 0 && s.Period > 0 {\n\t\tif s.inc() <= s.Burst {\n\t\t\treturn true\n\t\t}\n\t}\n\tif s.NextSampler == nil {\n\t\treturn false\n\t}\n\treturn s.NextSampler.Sample(lvl)\n}\n\nfunc (s *BurstSampler) inc() uint32 {\n\tnow := TimestampFunc().UnixNano()\n\tresetAt := atomic.LoadInt64(&s.resetAt)\n\tvar c uint32\n\tif now > resetAt {\n\t\tc = 1\n\t\tatomic.StoreUint32(&s.counter, c)\n\t\tnewResetAt := now + s.Period.Nanoseconds()\n\t\treset := atomic.CompareAndSwapInt64(&s.resetAt, resetAt, newResetAt)\n\t\tif !reset {\n\t\t\t// Lost the race with another goroutine trying to reset.\n\t\t\tc = atomic.AddUint32(&s.counter, 1)\n\t\t}\n\t} else {\n\t\tc = atomic.AddUint32(&s.counter, 1)\n\t}\n\treturn c\n}\n\n// LevelSampler applies a different sampler for each level.\ntype LevelSampler struct {\n\tTraceSampler, DebugSampler, InfoSampler, WarnSampler, ErrorSampler Sampler\n}\n\nfunc (s LevelSampler) Sample(lvl Level) bool {\n\tswitch lvl {\n\tcase TraceLevel:\n\t\tif s.TraceSampler != nil {\n\t\t\treturn s.TraceSampler.Sample(lvl)\n\t\t}\n\tcase DebugLevel:\n\t\tif s.DebugSampler != nil {\n\t\t\treturn s.DebugSampler.Sample(lvl)\n\t\t}\n\tcase InfoLevel:\n\t\tif s.InfoSampler != nil {\n\t\t\treturn s.InfoSampler.Sample(lvl)\n\t\t}\n\tcase WarnLevel:\n\t\tif s.WarnSampler != nil {\n\t\t\treturn s.WarnSampler.Sample(lvl)\n\t\t}\n\tcase ErrorLevel:\n\t\tif s.ErrorSampler != nil {\n\t\t\treturn s.ErrorSampler.Sample(lvl)\n\t\t}\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "sampler_test.go",
          "type": "blob",
          "size": 1.666015625,
          "content": "// +build !binary_log\n\npackage zerolog\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nvar samplers = []struct {\n\tname    string\n\tsampler func() Sampler\n\ttotal   int\n\twantMin int\n\twantMax int\n}{\n\t{\n\t\t\"BasicSampler_1\",\n\t\tfunc() Sampler {\n\t\t\treturn &BasicSampler{N: 1}\n\t\t},\n\t\t100, 100, 100,\n\t},\n\t{\n\t\t\"BasicSampler_5\",\n\t\tfunc() Sampler {\n\t\t\treturn &BasicSampler{N: 5}\n\t\t},\n\t\t100, 20, 20,\n\t},\n\t{\n\t\t\"BasicSampler_0\",\n\t\tfunc() Sampler {\n\t\t\treturn &BasicSampler{N: 0}\n\t\t},\n\t\t100, 0, 0,\n\t},\n\t{\n\t\t\"RandomSampler\",\n\t\tfunc() Sampler {\n\t\t\treturn RandomSampler(5)\n\t\t},\n\t\t100, 10, 30,\n\t},\n\t{\n\t\t\"RandomSampler_0\",\n\t\tfunc() Sampler {\n\t\t\treturn RandomSampler(0)\n\t\t},\n\t\t100, 0, 0,\n\t},\n\t{\n\t\t\"BurstSampler\",\n\t\tfunc() Sampler {\n\t\t\treturn &BurstSampler{Burst: 20, Period: time.Second}\n\t\t},\n\t\t100, 20, 20,\n\t},\n\t{\n\t\t\"BurstSampler_0\",\n\t\tfunc() Sampler {\n\t\t\treturn &BurstSampler{Burst: 0, Period: time.Second}\n\t\t},\n\t\t100, 0, 0,\n\t},\n\t{\n\t\t\"BurstSamplerNext\",\n\t\tfunc() Sampler {\n\t\t\treturn &BurstSampler{Burst: 20, Period: time.Second, NextSampler: &BasicSampler{N: 5}}\n\t\t},\n\t\t120, 40, 40,\n\t},\n}\n\nfunc TestSamplers(t *testing.T) {\n\tfor i := range samplers {\n\t\ts := samplers[i]\n\t\tt.Run(s.name, func(t *testing.T) {\n\t\t\tsampler := s.sampler()\n\t\t\tgot := 0\n\t\t\tfor t := s.total; t > 0; t-- {\n\t\t\t\tif sampler.Sample(0) {\n\t\t\t\t\tgot++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif got < s.wantMin || got > s.wantMax {\n\t\t\t\tt.Errorf(\"%s.Sample(0) == true %d on %d, want [%d, %d]\", s.name, got, s.total, s.wantMin, s.wantMax)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkSamplers(b *testing.B) {\n\tfor i := range samplers {\n\t\ts := samplers[i]\n\t\tb.Run(s.name, func(b *testing.B) {\n\t\t\tsampler := s.sampler()\n\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\tfor pb.Next() {\n\t\t\t\t\tsampler.Sample(0)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "syslog.go",
          "type": "blob",
          "size": 2.142578125,
          "content": "// +build !windows\n// +build !binary_log\n\npackage zerolog\n\nimport (\n\t\"io\"\n)\n\n// See http://cee.mitre.org/language/1.0-beta1/clt.html#syslog\n// or https://www.rsyslog.com/json-elasticsearch/\nconst ceePrefix = \"@cee:\"\n\n// SyslogWriter is an interface matching a syslog.Writer struct.\ntype SyslogWriter interface {\n\tio.Writer\n\tDebug(m string) error\n\tInfo(m string) error\n\tWarning(m string) error\n\tErr(m string) error\n\tEmerg(m string) error\n\tCrit(m string) error\n}\n\ntype syslogWriter struct {\n\tw      SyslogWriter\n\tprefix string\n}\n\n// SyslogLevelWriter wraps a SyslogWriter and call the right syslog level\n// method matching the zerolog level.\nfunc SyslogLevelWriter(w SyslogWriter) LevelWriter {\n\treturn syslogWriter{w, \"\"}\n}\n\n// SyslogCEEWriter wraps a SyslogWriter with a SyslogLevelWriter that adds a\n// MITRE CEE prefix for JSON syslog entries, compatible with rsyslog \n// and syslog-ng JSON logging support. \n// See https://www.rsyslog.com/json-elasticsearch/\nfunc SyslogCEEWriter(w SyslogWriter) LevelWriter {\n\treturn syslogWriter{w, ceePrefix}\n}\n\nfunc (sw syslogWriter) Write(p []byte) (n int, err error) {\n\tvar pn int\n\tif sw.prefix != \"\" {\n\t\tpn, err = sw.w.Write([]byte(sw.prefix))\n\t\tif err != nil {\n\t\t\treturn pn, err\n\t\t}\n\t}\n\tn, err = sw.w.Write(p)\n\treturn pn + n, err\n}\n\n// WriteLevel implements LevelWriter interface.\nfunc (sw syslogWriter) WriteLevel(level Level, p []byte) (n int, err error) {\n\tswitch level {\n\tcase TraceLevel:\n\tcase DebugLevel:\n\t\terr = sw.w.Debug(sw.prefix + string(p))\n\tcase InfoLevel:\n\t\terr = sw.w.Info(sw.prefix + string(p))\n\tcase WarnLevel:\n\t\terr = sw.w.Warning(sw.prefix + string(p))\n\tcase ErrorLevel:\n\t\terr = sw.w.Err(sw.prefix + string(p))\n\tcase FatalLevel:\n\t\terr = sw.w.Emerg(sw.prefix + string(p))\n\tcase PanicLevel:\n\t\terr = sw.w.Crit(sw.prefix + string(p))\n\tcase NoLevel:\n\t\terr = sw.w.Info(sw.prefix + string(p))\n\tdefault:\n\t\tpanic(\"invalid level\")\n\t}\n\t// Any CEE prefix is not part of the message, so we don't include its length\n\tn = len(p)\n\treturn\n}\n\n// Call the underlying writer's Close method if it is an io.Closer. Otherwise\n// does nothing.\nfunc (sw syslogWriter) Close() error {\n\tif c, ok := sw.w.(io.Closer); ok {\n\t\treturn c.Close()\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "syslog_test.go",
          "type": "blob",
          "size": 2.6728515625,
          "content": "// +build !binary_log\n// +build !windows\n\npackage zerolog\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype syslogEvent struct {\n\tlevel string\n\tmsg   string\n}\ntype syslogTestWriter struct {\n\tevents []syslogEvent\n}\n\nfunc (w *syslogTestWriter) Write(p []byte) (int, error) {\n\treturn 0, nil\n}\nfunc (w *syslogTestWriter) Trace(m string) error {\n\tw.events = append(w.events, syslogEvent{\"Trace\", m})\n\treturn nil\n}\nfunc (w *syslogTestWriter) Debug(m string) error {\n\tw.events = append(w.events, syslogEvent{\"Debug\", m})\n\treturn nil\n}\nfunc (w *syslogTestWriter) Info(m string) error {\n\tw.events = append(w.events, syslogEvent{\"Info\", m})\n\treturn nil\n}\nfunc (w *syslogTestWriter) Warning(m string) error {\n\tw.events = append(w.events, syslogEvent{\"Warning\", m})\n\treturn nil\n}\nfunc (w *syslogTestWriter) Err(m string) error {\n\tw.events = append(w.events, syslogEvent{\"Err\", m})\n\treturn nil\n}\nfunc (w *syslogTestWriter) Emerg(m string) error {\n\tw.events = append(w.events, syslogEvent{\"Emerg\", m})\n\treturn nil\n}\nfunc (w *syslogTestWriter) Crit(m string) error {\n\tw.events = append(w.events, syslogEvent{\"Crit\", m})\n\treturn nil\n}\n\nfunc TestSyslogWriter(t *testing.T) {\n\tsw := &syslogTestWriter{}\n\tlog := New(SyslogLevelWriter(sw))\n\tlog.Trace().Msg(\"trace\")\n\tlog.Debug().Msg(\"debug\")\n\tlog.Info().Msg(\"info\")\n\tlog.Warn().Msg(\"warn\")\n\tlog.Error().Msg(\"error\")\n\tlog.Log().Msg(\"nolevel\")\n\twant := []syslogEvent{\n\t\t{\"Debug\", `{\"level\":\"debug\",\"message\":\"debug\"}` + \"\\n\"},\n\t\t{\"Info\", `{\"level\":\"info\",\"message\":\"info\"}` + \"\\n\"},\n\t\t{\"Warning\", `{\"level\":\"warn\",\"message\":\"warn\"}` + \"\\n\"},\n\t\t{\"Err\", `{\"level\":\"error\",\"message\":\"error\"}` + \"\\n\"},\n\t\t{\"Info\", `{\"message\":\"nolevel\"}` + \"\\n\"},\n\t}\n\tif got := sw.events; !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Invalid syslog message routing: want %v, got %v\", want, got)\n\t}\n}\n\ntype testCEEwriter struct {\n\tbuf *bytes.Buffer\n}\n\n// Only implement one method as we're just testing the prefixing\nfunc (c testCEEwriter) Debug(m string) error { return nil }\n\nfunc (c testCEEwriter) Info(m string) error {\n\t_, err := c.buf.Write([]byte(m))\n\treturn err\n}\n\nfunc (c testCEEwriter) Warning(m string) error { return nil }\n\nfunc (c testCEEwriter) Err(m string) error { return nil }\n\nfunc (c testCEEwriter) Emerg(m string) error { return nil }\n\nfunc (c testCEEwriter) Crit(m string) error { return nil }\n\nfunc (c testCEEwriter) Write(b []byte) (int, error) {\n\treturn c.buf.Write(b)\n}\n\nfunc TestSyslogWriter_WithCEE(t *testing.T) {\n\tvar buf bytes.Buffer\n\tsw := testCEEwriter{&buf}\n\tlog := New(SyslogCEEWriter(sw))\n\tlog.Info().Str(\"key\", \"value\").Msg(\"message string\")\n\tgot := buf.String()\n\twant := \"@cee:{\"\n\tif !strings.HasPrefix(got, want) {\n\t\tt.Errorf(\"Bad CEE message start: want %v, got %v\", want, got)\n\t}\n}\n"
        },
        {
          "name": "writer.go",
          "type": "blob",
          "size": 9.0771484375,
          "content": "package zerolog\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"path\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// LevelWriter defines as interface a writer may implement in order\n// to receive level information with payload.\ntype LevelWriter interface {\n\tio.Writer\n\tWriteLevel(level Level, p []byte) (n int, err error)\n}\n\n// LevelWriterAdapter adapts an io.Writer to support the LevelWriter interface.\ntype LevelWriterAdapter struct {\n\tio.Writer\n}\n\n// WriteLevel simply writes everything to the adapted writer, ignoring the level.\nfunc (lw LevelWriterAdapter) WriteLevel(l Level, p []byte) (n int, err error) {\n\treturn lw.Write(p)\n}\n\n// Call the underlying writer's Close method if it is an io.Closer. Otherwise\n// does nothing.\nfunc (lw LevelWriterAdapter) Close() error {\n\tif closer, ok := lw.Writer.(io.Closer); ok {\n\t\treturn closer.Close()\n\t}\n\treturn nil\n}\n\ntype syncWriter struct {\n\tmu sync.Mutex\n\tlw LevelWriter\n}\n\n// SyncWriter wraps w so that each call to Write is synchronized with a mutex.\n// This syncer can be used to wrap the call to writer's Write method if it is\n// not thread safe. Note that you do not need this wrapper for os.File Write\n// operations on POSIX and Windows systems as they are already thread-safe.\nfunc SyncWriter(w io.Writer) io.Writer {\n\tif lw, ok := w.(LevelWriter); ok {\n\t\treturn &syncWriter{lw: lw}\n\t}\n\treturn &syncWriter{lw: LevelWriterAdapter{w}}\n}\n\n// Write implements the io.Writer interface.\nfunc (s *syncWriter) Write(p []byte) (n int, err error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.lw.Write(p)\n}\n\n// WriteLevel implements the LevelWriter interface.\nfunc (s *syncWriter) WriteLevel(l Level, p []byte) (n int, err error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.lw.WriteLevel(l, p)\n}\n\nfunc (s *syncWriter) Close() error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tif closer, ok := s.lw.(io.Closer); ok {\n\t\treturn closer.Close()\n\t}\n\treturn nil\n}\n\ntype multiLevelWriter struct {\n\twriters []LevelWriter\n}\n\nfunc (t multiLevelWriter) Write(p []byte) (n int, err error) {\n\tfor _, w := range t.writers {\n\t\tif _n, _err := w.Write(p); err == nil {\n\t\t\tn = _n\n\t\t\tif _err != nil {\n\t\t\t\terr = _err\n\t\t\t} else if _n != len(p) {\n\t\t\t\terr = io.ErrShortWrite\n\t\t\t}\n\t\t}\n\t}\n\treturn n, err\n}\n\nfunc (t multiLevelWriter) WriteLevel(l Level, p []byte) (n int, err error) {\n\tfor _, w := range t.writers {\n\t\tif _n, _err := w.WriteLevel(l, p); err == nil {\n\t\t\tn = _n\n\t\t\tif _err != nil {\n\t\t\t\terr = _err\n\t\t\t} else if _n != len(p) {\n\t\t\t\terr = io.ErrShortWrite\n\t\t\t}\n\t\t}\n\t}\n\treturn n, err\n}\n\n// Calls close on all the underlying writers that are io.Closers. If any of the\n// Close methods return an error, the remainder of the closers are not closed\n// and the error is returned.\nfunc (t multiLevelWriter) Close() error {\n\tfor _, w := range t.writers {\n\t\tif closer, ok := w.(io.Closer); ok {\n\t\t\tif err := closer.Close(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// MultiLevelWriter creates a writer that duplicates its writes to all the\n// provided writers, similar to the Unix tee(1) command. If some writers\n// implement LevelWriter, their WriteLevel method will be used instead of Write.\nfunc MultiLevelWriter(writers ...io.Writer) LevelWriter {\n\tlwriters := make([]LevelWriter, 0, len(writers))\n\tfor _, w := range writers {\n\t\tif lw, ok := w.(LevelWriter); ok {\n\t\t\tlwriters = append(lwriters, lw)\n\t\t} else {\n\t\t\tlwriters = append(lwriters, LevelWriterAdapter{w})\n\t\t}\n\t}\n\treturn multiLevelWriter{lwriters}\n}\n\n// TestingLog is the logging interface of testing.TB.\ntype TestingLog interface {\n\tLog(args ...interface{})\n\tLogf(format string, args ...interface{})\n\tHelper()\n}\n\n// TestWriter is a writer that writes to testing.TB.\ntype TestWriter struct {\n\tT TestingLog\n\n\t// Frame skips caller frames to capture the original file and line numbers.\n\tFrame int\n}\n\n// NewTestWriter creates a writer that logs to the testing.TB.\nfunc NewTestWriter(t TestingLog) TestWriter {\n\treturn TestWriter{T: t}\n}\n\n// Write to testing.TB.\nfunc (t TestWriter) Write(p []byte) (n int, err error) {\n\tt.T.Helper()\n\n\tn = len(p)\n\n\t// Strip trailing newline because t.Log always adds one.\n\tp = bytes.TrimRight(p, \"\\n\")\n\n\t// Try to correct the log file and line number to the caller.\n\tif t.Frame > 0 {\n\t\t_, origFile, origLine, _ := runtime.Caller(1)\n\t\t_, frameFile, frameLine, ok := runtime.Caller(1 + t.Frame)\n\t\tif ok {\n\t\t\terase := strings.Repeat(\"\\b\", len(path.Base(origFile))+len(strconv.Itoa(origLine))+3)\n\t\t\tt.T.Logf(\"%s%s:%d: %s\", erase, path.Base(frameFile), frameLine, p)\n\t\t\treturn n, err\n\t\t}\n\t}\n\tt.T.Log(string(p))\n\n\treturn n, err\n}\n\n// ConsoleTestWriter creates an option that correctly sets the file frame depth for testing.TB log.\nfunc ConsoleTestWriter(t TestingLog) func(w *ConsoleWriter) {\n\treturn func(w *ConsoleWriter) {\n\t\tw.Out = TestWriter{T: t, Frame: 6}\n\t}\n}\n\n// FilteredLevelWriter writes only logs at Level or above to Writer.\n//\n// It should be used only in combination with MultiLevelWriter when you\n// want to write to multiple destinations at different levels. Otherwise\n// you should just set the level on the logger and filter events early.\n// When using MultiLevelWriter then you set the level on the logger to\n// the lowest of the levels you use for writers.\ntype FilteredLevelWriter struct {\n\tWriter LevelWriter\n\tLevel  Level\n}\n\n// Write writes to the underlying Writer.\nfunc (w *FilteredLevelWriter) Write(p []byte) (int, error) {\n\treturn w.Writer.Write(p)\n}\n\n// WriteLevel calls WriteLevel of the underlying Writer only if the level is equal\n// or above the Level.\nfunc (w *FilteredLevelWriter) WriteLevel(level Level, p []byte) (int, error) {\n\tif level >= w.Level {\n\t\treturn w.Writer.WriteLevel(level, p)\n\t}\n\treturn len(p), nil\n}\n\nvar triggerWriterPool = &sync.Pool{\n\tNew: func() interface{} {\n\t\treturn bytes.NewBuffer(make([]byte, 0, 1024))\n\t},\n}\n\n// TriggerLevelWriter buffers log lines at the ConditionalLevel or below\n// until a trigger level (or higher) line is emitted. Log lines with level\n// higher than ConditionalLevel are always written out to the destination\n// writer. If trigger never happens, buffered log lines are never written out.\n//\n// It can be used to configure \"log level per request\".\ntype TriggerLevelWriter struct {\n\t// Destination writer. If LevelWriter is provided (usually), its WriteLevel is used\n\t// instead of Write.\n\tio.Writer\n\n\t// ConditionalLevel is the level (and below) at which lines are buffered until\n\t// a trigger level (or higher) line is emitted. Usually this is set to DebugLevel.\n\tConditionalLevel Level\n\n\t// TriggerLevel is the lowest level that triggers the sending of the conditional\n\t// level lines. Usually this is set to ErrorLevel.\n\tTriggerLevel Level\n\n\tbuf       *bytes.Buffer\n\ttriggered bool\n\tmu        sync.Mutex\n}\n\nfunc (w *TriggerLevelWriter) WriteLevel(l Level, p []byte) (n int, err error) {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\t// At first trigger level or above log line, we flush the buffer and change the\n\t// trigger state to triggered.\n\tif !w.triggered && l >= w.TriggerLevel {\n\t\terr := w.trigger()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Unless triggered, we buffer everything at and below ConditionalLevel.\n\tif !w.triggered && l <= w.ConditionalLevel {\n\t\tif w.buf == nil {\n\t\t\tw.buf = triggerWriterPool.Get().(*bytes.Buffer)\n\t\t}\n\n\t\t// We prefix each log line with a byte with the level.\n\t\t// Hopefully we will never have a level value which equals a newline\n\t\t// (which could interfere with reconstruction of log lines in the trigger method).\n\t\tw.buf.WriteByte(byte(l))\n\t\tw.buf.Write(p)\n\t\treturn len(p), nil\n\t}\n\n\t// Anything above ConditionalLevel is always passed through.\n\t// Once triggered, everything is passed through.\n\tif lw, ok := w.Writer.(LevelWriter); ok {\n\t\treturn lw.WriteLevel(l, p)\n\t}\n\treturn w.Write(p)\n}\n\n// trigger expects lock to be held.\nfunc (w *TriggerLevelWriter) trigger() error {\n\tif w.triggered {\n\t\treturn nil\n\t}\n\tw.triggered = true\n\n\tif w.buf == nil {\n\t\treturn nil\n\t}\n\n\tp := w.buf.Bytes()\n\tfor len(p) > 0 {\n\t\t// We do not use bufio.Scanner here because we already have full buffer\n\t\t// in the memory and we do not want extra copying from the buffer to\n\t\t// scanner's token slice, nor we want to hit scanner's token size limit,\n\t\t// and we also want to preserve newlines.\n\t\ti := bytes.IndexByte(p, '\\n')\n\t\tline := p[0 : i+1]\n\t\tp = p[i+1:]\n\t\t// We prefixed each log line with a byte with the level.\n\t\tlevel := Level(line[0])\n\t\tline = line[1:]\n\t\tvar err error\n\t\tif lw, ok := w.Writer.(LevelWriter); ok {\n\t\t\t_, err = lw.WriteLevel(level, line)\n\t\t} else {\n\t\t\t_, err = w.Write(line)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Trigger forces flushing the buffer and change the trigger state to\n// triggered, if the writer has not already been triggered before.\nfunc (w *TriggerLevelWriter) Trigger() error {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\treturn w.trigger()\n}\n\n// Close closes the writer and returns the buffer to the pool.\nfunc (w *TriggerLevelWriter) Close() error {\n\tw.mu.Lock()\n\tdefer w.mu.Unlock()\n\n\tif w.buf == nil {\n\t\treturn nil\n\t}\n\n\t// We return the buffer only if it has not grown above the limit.\n\t// This prevents accumulation of large buffers in the pool just\n\t// because occasionally a large buffer might be needed.\n\tif w.buf.Cap() <= TriggerLevelWriterBufferReuseLimit {\n\t\tw.buf.Reset()\n\t\ttriggerWriterPool.Put(w.buf)\n\t}\n\tw.buf = nil\n\n\treturn nil\n}\n"
        },
        {
          "name": "writer_test.go",
          "type": "blob",
          "size": 5.12890625,
          "content": "//go:build !binary_log && !windows\n// +build !binary_log,!windows\n\npackage zerolog\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestMultiSyslogWriter(t *testing.T) {\n\tsw := &syslogTestWriter{}\n\tlog := New(MultiLevelWriter(SyslogLevelWriter(sw)))\n\tlog.Debug().Msg(\"debug\")\n\tlog.Info().Msg(\"info\")\n\tlog.Warn().Msg(\"warn\")\n\tlog.Error().Msg(\"error\")\n\tlog.Log().Msg(\"nolevel\")\n\twant := []syslogEvent{\n\t\t{\"Debug\", `{\"level\":\"debug\",\"message\":\"debug\"}` + \"\\n\"},\n\t\t{\"Info\", `{\"level\":\"info\",\"message\":\"info\"}` + \"\\n\"},\n\t\t{\"Warning\", `{\"level\":\"warn\",\"message\":\"warn\"}` + \"\\n\"},\n\t\t{\"Err\", `{\"level\":\"error\",\"message\":\"error\"}` + \"\\n\"},\n\t\t{\"Info\", `{\"message\":\"nolevel\"}` + \"\\n\"},\n\t}\n\tif got := sw.events; !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"Invalid syslog message routing: want %v, got %v\", want, got)\n\t}\n}\n\nvar writeCalls int\n\ntype mockedWriter struct {\n\twantErr bool\n}\n\nfunc (c mockedWriter) Write(p []byte) (int, error) {\n\twriteCalls++\n\n\tif c.wantErr {\n\t\treturn -1, errors.New(\"Expected error\")\n\t}\n\n\treturn len(p), nil\n}\n\n// Tests that a new writer is only used if it actually works.\nfunc TestResilientMultiWriter(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\twriters []io.Writer\n\t}{\n\t\t{\n\t\t\tname: \"All valid writers\",\n\t\t\twriters: []io.Writer{\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: false,\n\t\t\t\t},\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"All invalid writers\",\n\t\t\twriters: []io.Writer{\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: true,\n\t\t\t\t},\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"First invalid writer\",\n\t\t\twriters: []io.Writer{\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: true,\n\t\t\t\t},\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"First valid writer\",\n\t\t\twriters: []io.Writer{\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: false,\n\t\t\t\t},\n\t\t\t\tmockedWriter{\n\t\t\t\t\twantErr: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\twriters := tt.writers\n\t\tmultiWriter := MultiLevelWriter(writers...)\n\n\t\tlogger := New(multiWriter).With().Timestamp().Logger().Level(InfoLevel)\n\t\tlogger.Info().Msg(\"Test msg\")\n\n\t\tif len(writers) != writeCalls {\n\t\t\tt.Errorf(\"Expected %d writers to have been called but only %d were.\", len(writers), writeCalls)\n\t\t}\n\t\twriteCalls = 0\n\t}\n}\n\ntype testingLog struct {\n\ttesting.TB\n\tbuf bytes.Buffer\n}\n\nfunc (t *testingLog) Log(args ...interface{}) {\n\tif _, err := t.buf.WriteString(fmt.Sprint(args...)); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc (t *testingLog) Logf(format string, args ...interface{}) {\n\tif _, err := t.buf.WriteString(fmt.Sprintf(format, args...)); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestTestWriter(t *testing.T) {\n\ttests := []struct {\n\t\tname  string\n\t\twrite []byte\n\t\twant  []byte\n\t}{{\n\t\tname:  \"newline\",\n\t\twrite: []byte(\"newline\\n\"),\n\t\twant:  []byte(\"newline\"),\n\t}, {\n\t\tname:  \"oneline\",\n\t\twrite: []byte(\"oneline\"),\n\t\twant:  []byte(\"oneline\"),\n\t}, {\n\t\tname:  \"twoline\",\n\t\twrite: []byte(\"twoline\\n\\n\"),\n\t\twant:  []byte(\"twoline\"),\n\t}}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttb := &testingLog{TB: t} // Capture TB log buffer.\n\t\t\tw := TestWriter{T: tb}\n\n\t\t\tn, err := w.Write(tt.write)\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tif n != len(tt.write) {\n\t\t\t\tt.Errorf(\"Expected %d write length but got %d\", len(tt.write), n)\n\t\t\t}\n\t\t\tp := tb.buf.Bytes()\n\t\t\tif !bytes.Equal(tt.want, p) {\n\t\t\t\tt.Errorf(\"Expected %q, got %q.\", tt.want, p)\n\t\t\t}\n\n\t\t\tlog := New(NewConsoleWriter(ConsoleTestWriter(t)))\n\t\t\tlog.Info().Str(\"name\", tt.name).Msg(\"Success!\")\n\n\t\t\ttb.buf.Reset()\n\t\t})\n\t}\n\n}\n\nfunc TestFilteredLevelWriter(t *testing.T) {\n\tbuf := bytes.Buffer{}\n\twriter := FilteredLevelWriter{\n\t\tWriter: LevelWriterAdapter{&buf},\n\t\tLevel:  InfoLevel,\n\t}\n\t_, err := writer.WriteLevel(DebugLevel, []byte(\"no\"))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\t_, err = writer.WriteLevel(InfoLevel, []byte(\"yes\"))\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tp := buf.Bytes()\n\tif want := \"yes\"; !bytes.Equal([]byte(want), p) {\n\t\tt.Errorf(\"Expected %q, got %q.\", want, p)\n\t}\n}\n\ntype testWrite struct {\n\tLevel\n\tLine []byte\n}\n\nfunc TestTriggerLevelWriter(t *testing.T) {\n\ttests := []struct {\n\t\twrite []testWrite\n\t\twant  []byte\n\t\tall   []byte\n\t}{{\n\t\t[]testWrite{\n\t\t\t{DebugLevel, []byte(\"no\\n\")},\n\t\t\t{InfoLevel, []byte(\"yes\\n\")},\n\t\t},\n\t\t[]byte(\"yes\\n\"),\n\t\t[]byte(\"yes\\nno\\n\"),\n\t}, {\n\t\t[]testWrite{\n\t\t\t{DebugLevel, []byte(\"yes1\\n\")},\n\t\t\t{InfoLevel, []byte(\"yes2\\n\")},\n\t\t\t{ErrorLevel, []byte(\"yes3\\n\")},\n\t\t\t{DebugLevel, []byte(\"yes4\\n\")},\n\t\t},\n\t\t[]byte(\"yes2\\nyes1\\nyes3\\nyes4\\n\"),\n\t\t[]byte(\"yes2\\nyes1\\nyes3\\nyes4\\n\"),\n\t}}\n\n\tfor k, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"case=%d\", k), func(t *testing.T) {\n\t\t\tbuf := bytes.Buffer{}\n\t\t\twriter := TriggerLevelWriter{Writer: LevelWriterAdapter{&buf}, ConditionalLevel: DebugLevel, TriggerLevel: ErrorLevel}\n\t\t\tt.Cleanup(func() { writer.Close() })\n\t\t\tfor _, w := range tt.write {\n\t\t\t\t_, err := writer.WriteLevel(w.Level, w.Line)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tp := buf.Bytes()\n\t\t\tif want := tt.want; !bytes.Equal([]byte(want), p) {\n\t\t\t\tt.Errorf(\"Expected %q, got %q.\", want, p)\n\t\t\t}\n\t\t\terr := writer.Trigger()\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t}\n\t\t\tp = buf.Bytes()\n\t\t\tif want := tt.all; !bytes.Equal([]byte(want), p) {\n\t\t\t\tt.Errorf(\"Expected %q, got %q.\", want, p)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}