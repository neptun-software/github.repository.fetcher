{
  "metadata": {
    "timestamp": 1736568012331,
    "page": 147,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "revel/revel",
      "stars": 13153,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codebeatsettings",
          "type": "blob",
          "size": 0.259765625,
          "content": "{\n  \"GOLANG\": {\n  \"ABC\":[15, 25, 50, 70],\n  \"BLOCK_NESTING\":[5, 6, 7, 8],\n  \"CYCLO\":[20, 30, 45, 60],\n    \"TOO_MANY_IVARS\": [15, 18, 20, 25],\n    \"TOO_MANY_FUNCTIONS\": [20, 30, 40, 50],\n    \"TOTAL_COMPLEXITY\": [150, 250, 400, 500],\n    \"LOC\": [50, 75, 90, 120]\n  }\n}"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.068359375,
          "content": "tmp/\nroutes/\ntest-results/\nrevel/revel\n\n# editor\n*.swp\n\n.idea/\n*.iml\n\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.5673828125,
          "content": "language: go\n\ngo:\n  - \"1.13.x\"\n  - \"1.14.x\"\n  - \"1.15.x\"\n  - \"tip\"\n\nos:\n  - linux\n  - osx\n  - windows\n\nsudo: false\n\nbranches:\n  only:\n    - master\n    - develop\n\nservices:\n  # github.com/revel/revel/cache\n  - memcache\n  - redis-server\n\nbefore_install:\n  # TRAVIS_OS_NAME - linux and osx\n  - echo $TRAVIS_OS_NAME\n  - echo $PATH\n  - |\n    if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then\n      brew update && brew install memcached redis && brew services start redis && brew services start memcached\n    fi\n  - |\n    if [[ \"$TRAVIS_OS_NAME\" != \"windows\" ]]; then\n      redis-server --daemonize yes\n      redis-cli info\n    else\n      # redis-server.exe\n      # redis-cli.exe info\n      echo $PATH\n    fi\n\ninstall:\n  # Setting environments variables\n  - export PATH=$PATH:$HOME/gopath/bin\n  - export REVEL_BRANCH=\"develop\"\n  - 'if [[ \"$TRAVIS_BRANCH\" == \"master\" ]]; then export REVEL_BRANCH=\"master\"; fi'\n  - 'echo \"Travis branch: $TRAVIS_BRANCH, Revel dependency branch: $REVEL_BRANCH\"'\n  - git clone -b $REVEL_BRANCH git://github.com/revel/modules ../modules/\n  - git clone -b $REVEL_BRANCH git://github.com/revel/cmd ../cmd/\n  - git clone -b $REVEL_BRANCH git://github.com/revel/config ../config/\n  - git clone -b $REVEL_BRANCH git://github.com/revel/cron ../cron/\n  - git clone -b $REVEL_BRANCH git://github.com/revel/examples ../examples/\n  - go get -t -v github.com/revel/revel/...\n\nscript:\n  - |\n    if [[ \"$TRAVIS_OS_NAME\" != \"windows\" ]]; then\n      go test -v github.com/revel/revel/...\n    else\n      go test -v github.com/revel/revel/.\n    fi\n\nmatrix:\n  allow_failures:\n    - go: tip\n    - os: windows\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.0419921875,
          "content": "# TODO Revel Framework Authors Information\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 43.30078125,
          "content": "# CHANGELOG\n\n\n## v1.1.0\n\n[[revel/revel](https://github.com/revel/revel)]\n\n* bc0e27f Merge pull request #1552 from revel/1542_recursive_call\n* d202b93 Merge pull request #1448 from golddranks/master\n* 859e5b4 Merge pull request #1511 from jiro4989/patch-1\n* 90489b1 Merge pull request #1523 from KoichiWada/handle-sigterm\n* 347610c Merge branch 'develop' into handle-sigterm\n* 942bd2e Merge pull request #1525 from mikyk10/feature/adding-mime-compress\n* 2cb950f Merge pull request #1543 from dhiemaz/fixing-typos\n* aed0d1e Merge pull request #1550 from revel/bugfix/readme-install\n* bc89379 Fixed log recursive call There was a recusive loop in the logger, this fixes it closes #1542\n* aa8a94d Merge pull request #1546 from braineet/master\n* 741d2c8 Corrects install command for new version of go\n* 65db3c0 Merge pull request #1549 from revel/bugfix/session-uuid\n* 624f341 Merge branch 'develop' into bugfix/session-uuid\n* 5e99db8 Refactors session uuid to use google's package\n* 30f3424 Correction redis import\n* f934412 fixing typos\n* f261091 Added a MIME type for compressableMimes\n* 9907376 Handle SIGTERM for graceful shutdown.\n* 413dda3 Merge pull request #1518 from ptman/lint\n* 45a4413 More lint fixes and dead code removal\n* 3799c55 Merge pull request #1514 from ptman/lint\n* 655927a Removed go 1.12 added go 1.15\n* 060e640 Fix misspellings and some lint errors\n* 921e1b4 Fix URL (http -> https)\n* e12cd0e develop v1.1.0-dev\n* a29f37c Fix a bug when binding to pointer\n\n[[revel/cmd](https://github.com/revel/cmd)]\n\n* 86b4670 Update README.md\n* bc376fb Merge pull request #211 from lujiacn/develop\n* 5c8ac53 Merge branch 'develop' into develop\n* c674084 Merge pull request #201 from ptman/lint\n* cfe1d97 Merge branch 'develop' into lint\n* 7f9f658 Merge pull request #209 from glaslos/patch-1\n* 126d20c Merge pull request #210 from revel/build_process_update\n* 111264c updated go.mod\n* 4087c49 updated golang.org/x/tools, to avoid internal error: package xxx without types was imported from ...\n* 3602eb4 Merge branch 'develop' into patch-1\n* 192fc66 Merge pull request #200 from julidau/develop\n* 5689f86 Merge pull request #204 from shinypb/master\n* 6dba0c3 Fix bad error syntax An wrapped error message in the cmd module was referencing the wrong parameter value to be built closes revel/revel#1532\n* bb926f3 Added additional pattern to test against Another different missing pacakge error thrown that can be detected and added This error occurs because a package may have been stripped down when originally loaded\n* 3cd5ebb Updated launch scripts\n* 25dc05b Updated Launch code Added output to error stack, so terminal errors are displayed Ficed c.Verbose, it was changed to an array which causes issues launching Removed . notation from doing anything special. This was already replaced with the -p CLI option Added documentaiton on adding the package name Started watcher with force refresh.\n* 0a40a20 Merge pull request #208 from notzippy/build_process_update\n* fcc1319 Fixing type\n* ea5acb7 Updated shared build environments Updated check for errors. Updated go.mod Added .vscode launch\n* 25d6352 Get rid of redundant space in the output of `revel new -a`\n* ddec572 More linting\n* 7a91d0c interrupt process on windows as well\n* b562bd2 Merge pull request #199 from ptman/lint\n* bf17a71 Merge branch 'develop' into lint\n* 3d924a0 Lint fixes\n* d64c7f1 develop v1.1.0-dev\n\n[[revel/config](https://github.com/revel/config)]\n\n* no changes\n\n[[revel/modules](https://github.com/revel/modules)]\n\n* 852ea71 Merge branch 'master' into develop\n* 789324e Merge pull request #105 from ptman/lint\n* 0a9a7f4 Update .travis.yml\n* 8dbd171 Lint fixes\n* 464e072 develop v1.1.0-dev\n\n[[revel/cron](https://github.com/revel/cron)]\n\n* 031e64e Merge pull request #5 from ptman/lint\n* 7cfc261 Lint fixes\n\n[[revel/examples](https://github.com/revel/examples)]\n\n* e51ed5a Merge pull request #54 from realbucksavage/master\n* c555714 Merge pull request #58 from teitei-tk/update_gorp_link\n* 24ed869 Merge pull request #62 from ptman/lint\n* 5ec13f7 More lint fixes\n* b14432a Merge branch 'develop' into lint\n* a33af07 Merge pull request #59 from obsti8383/master\n* 46ae3a6 Removed go 1.12, added 1.15\n* ced52ae Lint and revel 1.0.0 fixes\n* b245628 revert to old go.sum\n* b6ea1ec upgrade references to revel framework to 1.0.0 in go.mod; fixes compile errors\n* 8353712 update gorp link\n* be755f5 Indented the code.\n\n[[revel/revel.github.io](https://github.com/revel/revel.github.io)]\n\n* 32d1cd9 Merge branch 'master' into develop\n* e72f206 Merge pull request #197 from revel/update_go_version\n* 1ae75e8 Merge branch 'develop' into update_go_version\n* 75172ea develop v1.1.0-dev\n\n[[revel/heroku-buildpack-go-revel](https://github.com/revel/heroku-buildpack-go-revel)]\n\n* no changes\n\n\n## v1.0.0\n\n[[revel/revel](https://github.com/revel/revel)]\n\n* 3d1b0c3 Merge pull request #1497 from lujiacn/master\n* ff2da7e Merge pull request #1498 from aacapella/feature/same-site-cookies\n* c6c4c35 SameSite cookie support\n* bfad570 Update server_adapter_go.go\n* ff43c73 Merge pull request #1491 from notzippy/go-mod\n* dbe9fee Update .travis.yml\n* 38b0687 Fixed paths for test cases\n* 39523bf Enhanced logging\n* 59b8375 Changes to Revel for go.mod support Modified module lookup to handle lookups using the app.conf (before relied on source file) Added extra logging for routes error handling\n* 1053f49 Merge pull request #1443 from lujiacn/develop\n* dcafb9e Merge pull request #1488 from notzippy/go-mod\n* e30c8da Merge pull request #1483 from goevexx/feature/fix-issue-1482\n* 50e70f9 Updated revel to receive paths passed in Updated watcher to use master branch\n* d581f71 change import to fix issue 1482\n* fdc724a Merge pull request #1462 from torden/feature/fix_puretextstrict\n* fe4861c Fix (#1458) the undetected self-closing tags in isPureTextStrict Fix (#1458) the always uses STRICT mode in PureText.IsSatisFied\n* ae3895a added wasm mime-type\n* 45ec814 Merge pull request #1439 from mukeshjeengar/hotfix/log-rotation-fixed\n* d3a76ed log rotation fixed\n* 2eb9067 Merge pull request #1413 from nevkontakte/patch-1\n* ccf085e Merge pull request #1434 from dmjones/fix-1433\n* 34e886a Don't invoke action when Before returns value\n* 5b70626 Merge pull request #1427 from SYM01/hotfix/avoid-dos\n* d160ecb fix issue #1424\n* db7db5b remove unneccsary code assignment to nil\n* 8bff5bb Update controller.go\n* 16f5fef Remove a stray println call.\n* 60c3d7a develop v1.0.0-dev\n\n[[revel/cmd](https://github.com/revel/cmd)]\n\n* d8117a3 Merge pull request #186 from notzippy/go-mod\n* 6371373 Removed version update Version control is maintained through go.mod file Modified harness to only kill the application if not responded after 60 seconds in windows\n* 28ac65f Merge pull request #185 from notzippy/go-mod\n* 5070fb8 Fixed issue with new and run flag Updated tests to run final test in non gopath, with new name\n* 904cfa2 Added some informational messages while download\n* 223bd3b Added manual scan on packages in app folder This allows for source code generation. Packages in <application>/app folder are scanned manually as opposed to the `packages.Load` scan which will fast fail on compile error, and leave you with go files with no syntax.\n* 4987ee8 Added verbose logging to building / testing a no-vendor app Removed section which raises an error when examining packages, we dont need to check for errors on foreign packages since we are importing only a slice of the data\n* 4bab440 Updated Revel command Added a check to see if harness had already started, saves a recompile on load Added check to source info for local import renames Removed the go/build check for path and just check existence of the path Formatting updates\n* 741f492 Updated scanner Removed scanning all the import statements, this is not needed Added recursive scan for revel import path to pick up testunits\n* 60b88a4 Merge pull request #180 from notzippy/go-mod\n* 49eef29 Build and Historic build updates Modified GOPATH to not modify build with go.mod Updated go.mod to version 1.12 Updated harness to setup listener before killing process Updated notvendored flag to --no-vendor Updated command_config to ensure no-vendor can be build Added additional checks in source path lookup\n* 9d3a554 Updates Updated NotVendored flag Updated travis matrix Updated build log\n* 36bd6b9 Corrected flags\n* 1d9df25 Moved test cases to run last\n* ad694c0 Debug travis\n* fb4b565 Debug travis Added verbose flag so we can see what is occurring, Removed checkout for revel, not needed anymore\n* 20d5766 Added gomod-flags Added a gomod-flags parameter which allows you to run go mod commands on the go.mod file before the build is performed. This allows for development environments.\n* 0920905 Updated to build go 1.12 and up Modified to use fsnotify directlyUpdated travis to not use go deps\n* 31cb64e Check-in of command_test, remaps the go mod command to use the develop branch.\n* 33abc47 Fixed remaining test\n* 86736d6 Updated formating Ran through testing individually for vendored Revel applications\n* 07d6784 Restructured command config Removed go/build reference in clean\n* c1aee24 Corrected version detection, so that equal versions match\n* f2b54f5 Updated sourceinfo Added packagepathmap to the SourceInfo, this in turn allows the RevelCLI app command to pass the source paths directly to Revel directly Added default to build to be \"target\" of the current folder Renamed source processor\n* 3f54665 Added processor to read the functions in the imported files, and populate the SourceInfo object the same as before\n* 548cbc1 Upatede Error type to SourceError Added processor object to code Verified compile errors appearing Signed-off-by: notzippy@gmail.com\n* 9a9511d Updated so revel new works and revel run starts parsing the source.\n* acb8fb6 Initial commit to go mod\n* d201463 Merge pull request #176 from xXLokerXx/fix_windows_path\n* 773f688 Merge branch 'develop' into fix_windows_path\n* ca4cfa5 Merge pull request #165 from kumakichi/fixed_import_C\n* 4368690 Merge pull request #179 from Laur1nMartins/Laur1nMartins/fix-linkerFlags\n* cf2e617 Merge branch 'develop' into Laur1nMartins/fix-linkerFlags\n* 424474a Fix linker flags inclusion in build comamnd\n* 6d8fcd9 Fix sintax error\n* aa459c1 Fix sintaxis error\n* 0b23b3e Fix complexity\n* 3f65e1e acept slash and inverted slash in src path validation\n* 7dce3d8 fixed import \"C\"\n* 5c8d5bc develop v1.0.0-dev\n\n[[revel/config](https://github.com/revel/config)]\n\n* no changes\n\n[[revel/modules](https://github.com/revel/modules)]\n\n* e1fdc01 Merge pull request #103 from revel/master\n* 80d53e2 Merge pull request #102 from notzippy/go-mod\n* 2048fce Updated build processor\n* 19728d3 Added gomod removed vendor specific imports\n* 515369e develop v1.0.0-dev\n\n[[revel/cron](https://github.com/revel/cron)]\n\n* no changes\n\n[[revel/examples](https://github.com/revel/examples)]\n\n* 2d2968c Merge pull request #57 from notzippy/go-mod\n* dc75997 Updated examples Updated booking app to go.mod Updated chat, facebook, others app to add in go file in the root Updated travis to run tests in windows Updated travis to exclude testing fasthttp on windows\n* 5b25a51 Removed persona from project, this function no longer exists in browsers\n\n[[revel/revel.github.io](https://github.com/revel/revel.github.io)]\n\n* 6cd3647 Merge pull request #196 from aacapella/feature/same-site-cookies\n* 9f8f537 Merge pull request #191 from dmjones/session-value-not-found-returns-error\n* d79c912 Merge pull request #194 from DGKSK8LIFE/patch-1\n* 3911471 Merge pull request #195 from notzippy/develop\n* 67b088f Same site cookie setting\n* f5c5cb0 Corrected issues\n* bba502d Update for gomod docs\n* 9765ef0 Merge remote-tracking branch 'revel/master' into develop\n* eedc235 fixed spelling error\n* 9b9270a Explain return value when session value not found\n* 24abe9a Merge pull request #184 from manfordbenjamin/master\n* 4969200 Change logo and apply blue theme style to all pages\n* 844fe5d Revamp homepage\n* ef54af7 develop v1.0.0-dev\n\n[[revel/heroku-buildpack-go-revel](https://github.com/revel/heroku-buildpack-go-revel)]\n\n* no changes\n\n\n## v0.21.0\n\n### New items\n* **Session Engine support** You can now define your own session engine. By default the cookie engine is the one used for the session, but with this change you can implement your own. Also controller.Session is now a `map[string]interface{}` which means you can place any object that can be serialized to a string. \n* **Added http mux support** you can now integrate Revel with packages that have their own HTTP muxers. This allows you to integrate with Hugo, Swagger or any suite of software that is out there.\n* `revel.controller.reuse` app.conf option to turn on / off reuse of the controllers. Defaults to true\n\n### Breaking changes\ncontroller.Session is now a map[string]interface{} (previously was map[string]string) this means existing code needs to cast any values they pull from the session \n```\n\tif username, ok := c.Session[\"user\"]; ok { // username is a string type\n\t\treturn c.getUser(username)\n\t}\n```\nchanges to\n```\n\tif username, ok := c.Session[\"user\"]; ok { // username is an interface{} type\n\t\treturn c.getUser(username.(string))\n\t}\n```\n\nDeprecated log points removed\nrevel.ERROR, revel.TRACE, revel.DEBUG, revel.WARN have been removed\n\nFunction name change `revel.OnAppStop` Replaced revel.OnAppShutdown \n\nrevel.SimpleStack was moved to github.com/revel/revel/utils.SimpleStack\n\n### New packages required\n#### Revel Framework\n* github.com/twinj/uuid (revel/revel session ID generation)\n\n#### Revel Cmd\n* github.com/kr/pty (revel/cmd capture output of dep tool)\n\n### Package changes\n#### Revel Framework \n* Added stack to errors Added stack information to router when forumlating error\n* Fix spelling errors from go report\n* Removed deprecated loggers\n* Updated travis , made windows success optional\n* Exposed StopServer function to public Changed session filter to use empty call\n* 577ae8b Enhancement pack for next release Added session engine support, and the session cookie engine breaking change revel.Session was map[string]string now is map[string]interface{}\n* Updated shutdown to support windows environment \n* Patched shutdown support to make it work through the event engine \n* Added ENGINE_SHUTDOWN_REQUEST to events, raising this event will cause the server to shutdown \n* Assigned Server engines to receive revel.Events Added revel.OnAppStop hooks - \n* Normalized startup / shutdown hooks into their own package\n\n#### Revel Cmd\n* Modified run command to translate symlinks to absolute paths\n* Tool updates Updated tool to give more meaningful errors \n* Added file system as an option to fetch the skeleton from\n* Allow windows to fail on travis \n* run Command will choose CWD if no additional arguments are supplied \n* Added Revel version check, compatible lists are in model/version\n\n#### Revel Modules\n* Updated CSRF test cases \n* Added travis test for modified test engine\n* Updated server-engine modules to support OnAppStop functionality.\n* Reorganization, readme updates Moved auth example into its own folder \n* Updated root readme \n* Updated CSRF\n\n#### Revel Examples\n* Fixed issue with error checking closes websocket in chat\n* Updated booking module to work with changed session \n* Updated to remove any references to old revel.log variables\n\n\n## v0.20.0\n\n### New items\n* **Updated minimum Go requirements to Go 1.8**\n\n#### Revel Cmd changes\nSee [manual](http://revel.github.io/manual/tool.html) for more information on the flags and new features\n* Rewrote revel/cmd package so it has no dependencies on revel/revel - future releases for revel/cmd will not be on the same schedule as revel/revel\n* Added flag support to revel/cmd ,\n* Added automatic vendor creation flag, when enabled a vendor folder will be added and used to the project\n* Added [DEFAULT] section to message skeleton so multiple lines work\n* If port specified is 0 then proxy can will run on a random free port\n* Split main file into two files so it may be invoked using other methods\n* Added ability to only monitor and update build files (without running a proxy)\n* Auto download revel/revel, revel/cmd - if you point your GOPATH to an empty directory the `revel` tool will still be able to create a new project\n* Made application path smarter. Now supports absolute paths and relatives paths.\n* modified `revel run` to pass in json code to the `revel.Init` function in place of the `mode` field. This allows for dynamic information to be passed to the Revel Server. This can be disabled by using  this flag ` --historic-run-mode`\n* modified `revel new` added `-V` to auto create the vendor folder inside the application along with the Gopkg.toml file.\n* modified `revel new` added `-r` to run the application after creating it.\n\n### revel/module\n* Enhanced gorp module to make database schema available\n* Added server-engine  server-engine/gohttptest and a testsuite file that implements all the methods from revel/testsuite. This test engine as an alpha implementation to be able to run `go test` from the command line. Meaning your tests can now live beside the controller. An example testsuite is [here](https://github.com/revel/examples/blob/develop/booking/app/controllers/app_test.go)\n* Updated static module, moved a structure into a model package\n\n### revel/revel\n* Added startup fail REVEL_FAILURE event\n* Added HTTP_REQUEST_CONTEXT fetch\n* Added websockets Message.Send / Message.Receive functions.\n* Enhanced required validator\n* Graceful shutdown added. By doing a `revel.RaiseEvent()`\n\n#### Breaking Changes\n* `Request.Context() map[string]interface()` renamed to\n`Request.Args() map[string]interface()`\nnew function added which returns the request.Context for the server-engine that supports it\n`Request.Context() context.Context`\n`revel.EventHandler` signature was `func(typeOf int, value interface{}) (responseOf int)`\nnow it is func(typeOf Event, value interface{}) (responseOf EventResponse)\n\n\n## v0.19.1\nFix import to point to the fsnotify/fsnotify.v1\n\n\n## v0.19.0\n\n# Maintenance Release\n\nThis release is focused on improving the security and resolving some issues. \n\n**There are no breaking changes from version 0.18**\n\n[[revel/cmd](https://github.com/revel/cmd)]\n* Improved vendor folder detection revel/cmd#117\n* Added ordering of controllers so order remains consistent in main.go revel/cmd#112\n* Generate same value of `AppVersion` regardless of where Revel is run revel/cmd#108\n* Added referrer policy security header revel/cmd#114\n\n[[revel/modules](https://github.com/revel/modules)]\n* Added directory representation to static module revel/modules#46\n* Gorp enhancements (added abstraction layer for transactions and database connection so both can be used), Added security fix for CSRF module revel/modules#68\n* Added authorization configuration options to job page revel/modules#44\n\n[[revel/examples](https://github.com/revel/examples)]\n* General improvements and examples added revel/examples#39  revel/examples#40\n\n## v0.18\n\n## Upgrade path\nThe main breaking change is the removal of `http.Request` from the `revel.Request` object.\nEverything else should just work....\n\n## New items\n* Server Engine revel/revel#998\nThe server engine implementation is described in the [docs](http://revel.github.io/manual/server-engine.html)\n* Allow binding to a structured map. revel/revel#998 \nHave a structure inside a map object which will be realized properly from params\n* Gorm module revel/modules/#51\nAdded transaction controller\n* Gorp module revel/modules/#52\n* Autorun on startup in develop mode revel/cmd#95\nStart the application without doing a request first using revel run ....\n* Logger update revel/revel#1213\nConfigurable logger and added context logging on controller via controller.Log\n* Before after finally panic controller method detection revel/revel#1211 \nController methods will be automatically detected and called - similar to interceptors but without the extra code\n* Float validation revel/revel#1209\nAdded validation for floats\n* Timeago template function revel/revel#1207\nAdded timeago function to Revel template functions\n* Authorization to jobs module revel/module#44\nAdded ability to specify authorization to access the jobs module routes\n* Add MessageKey, ErrorKey methods to ValidationResult object revel/revel#1215\nThis allows the message translator to translate the keys added. So model objects can send out validation codes\n* Vendor friendlier - Revel recognizes and uses `deps` (to checkout go libraries) if a vendor folder exists in the project root. \n* Updated examples to use Gorp modules and new loggers\n\n\n### Breaking Changes\n\n* `http.Request` is no longer contained in `revel.Request` revel.Request remains functionally the same but \nyou cannot extract the `http.Request` from it. You can get the `http.Request` from `revel.Controller.Request.In.GetRaw().(*http.Request)`\n* `http.Response.Out` Is not the http.Response and is deprecated, you can get the output writer by doing `http.Response.GetWriter()`. You can get the `http.Response` from revel.Controller.Response.Out.Server.GetRaw().(*http.Response)`\n\n* `Websocket` changes. `revel.ServerWebsocket` is the new type of object you need to declare for controllers \nwhich should need to attach to websockets. Implementation of these objects have been simplified\n\nOld\n```\n\nfunc (c WebSocket) RoomSocket(user string, ws *websocket.Conn) revel.Result {\n\t// Join the room.\n\tsubscription := chatroom.Subscribe()\n\tdefer subscription.Cancel()\n\n\tchatroom.Join(user)\n\tdefer chatroom.Leave(user)\n\n\t// Send down the archive.\n\tfor _, event := range subscription.Archive {\n\t\tif websocket.JSON.Send(ws, &event) != nil {\n\t\t\t// They disconnected\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// In order to select between websocket messages and subscription events, we\n\t// need to stuff websocket events into a channel.\n\tnewMessages := make(chan string)\n\tgo func() {\n\t\tvar msg string\n\t\tfor {\n\t\t\terr := websocket.Message.Receive(ws, &msg)\n\t\t\tif err != nil {\n\t\t\t\tclose(newMessages)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnewMessages <- msg\n\t\t}\n\t}()\n```\nNew\n```\nfunc (c WebSocket) RoomSocket(user string, ws revel.ServerWebSocket) revel.Result {\n\t// Join the room.\n\tsubscription := chatroom.Subscribe()\n\tdefer subscription.Cancel()\n\n\tchatroom.Join(user)\n\tdefer chatroom.Leave(user)\n\n\t// Send down the archive.\n\tfor _, event := range subscription.Archive {\n\t\tif ws.MessageSendJSON(&event) != nil {\n\t\t\t// They disconnected\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// In order to select between websocket messages and subscription events, we\n\t// need to stuff websocket events into a channel.\n\tnewMessages := make(chan string)\n\tgo func() {\n\t\tvar msg string\n\t\tfor {\n\t\t\terr := ws.MessageReceiveJSON(&msg)\n\t\t\tif err != nil {\n\t\t\t\tclose(newMessages)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnewMessages <- msg\n\t\t}\n\t}()\n```\n* GORM module has been refactored into modules/orm/gorm \n\n\n### Deprecated methods\n* `revel.Request.FormValue()` Is deprecated, you should use methods in the controller.Params to access this data\n* `revel.Request.PostFormValue()` Is deprecated, you should use methods in the controller.Params.Form to access this data\n* `revel.Request.ParseForm()` Is deprecated - not needed\n* `revel.Request.ParseMultipartForm()` Is deprecated - not needed\n* `revel.Request.Form` Is deprecated, you should use the controller.Params.Form to access this data\n* `revel.Request.MultipartForm` Is deprecated, you should use the controller.Params.Form to access this data\n* `revel.TRACE`, `revel.INFO` `revel.WARN` `revel.ERROR` are deprecated. Use new application logger `revel.AppLog` and the controller logger `controller.Log`. See [logging](http://revel.github.io/manual/logging.html) for more details.\n\n### Features\n\n* Pluggable server engine support. You can now implement **your own server engine**. This means if you need to listen to more then 1 IP address or port you can implement a custom server engine to do this. By default Revel uses GO http server, but also available is fasthttp server in the revel/modules repository. See the docs for more information on how to implement your own engine.\n\n### Enhancements\n* Controller instances are cached for reuse. This speeds up the request response time and prevents unnecessary garbage collection cycles.  \n\n### Bug fixes\n\n\n\n\n## v0.17\n\n[[revel/revel](https://github.com/revel/revel)]\n\n* add-validation\n* i18-lang-by-param\n* Added namespace to routes, controllers\n* Added go 1.6 to testing\n* Adds the ability to set the language by a url parameter. The route file will need to specify the parameter so that it will be picked up\n* Changed url validation logic to regex\n* Added new validation mehtods (IPAddr,MacAddr,Domain,URL,PureText)\n\n[[revel/cmd](https://github.com/revel/cmd)]\n\n* no changes\n\n[[revel/config](https://github.com/revel/config)]\n\n* no changes\n\n[[revel/modules](https://github.com/revel/modules)]\n\n* Added Gorm module\n\n[[revel/cron](https://github.com/revel/cron)]\n\n* Updated cron task manager\n* Added ability to run a specific job, reschedules job if cron is running.\n\n[[revel/examples](https://github.com/revel/examples)]\n\n* Gorm module (Example)\n\n# v0.16.0\n\nDeprecating support for golang versions prior to 1.6\n### Breaking Changes\n\n* `CurrentLocaleRenderArg` to `CurrentLocaleViewArg` for consistency\n* JSON requests are now parsed by Revel, if the content type is `text/json` or `application/json`. The raw data is available in `Revel.Controller.Params.JSON`. But you can also use the automatic controller operation to load the data like you would any structure or map. See [here](http://revel.github.io/manual/parameters.html) for more details\n\n### Features\n\n* Modular Template Engine #1170 \n* Pongo2 engine driver added revel/modules#39\n* Ace engine driver added revel/modules#40\n* Added i18n template support #746 \n\n### Enhancements\n\n* JSON request binding #1161 \n* revel.SetSecretKey function added #1127 \n* ResolveFormat now looks at the extension as well (this sets the content type) #936 \n* Updated command to run tests using the configuration revel/cmd#61\n\n### Bug fixes\n\n* Updated documentation typos revel/modules#37\n* Updated order of parameter map assignment #1155 \n* Updated cookie lifetime for firefox #1174 \n* Added test path for modules, so modules will run tests as well #1162 \n* Fixed go profiler module revel/modules#20\n\n\n# v0.15.0\n@shawncatz released this on 2017-05-11\n\nDeprecating support for golang versions prior to 1.7\n\n### Breaking Changes\n\n* None\n\n### Features\n\n* None\n\n### Enhancements\n\n* Update and improve docs revel/examples#17 revel/cmd#85\n\n### Bug fixes\n\n* Prevent XSS revel/revel#1153\n* Improve error checking for go version detection revel/cmd#86\n\n# v0.14.0\n@notzippy released this on 2017-03-24\n\n## Changes since v0.13.0\n\n#### Breaking Changes\n- `revel/revel`:\n  - change RenderArgs to ViewArgs PR #1135\n  - change RenderJson to RenderJSON PR #1057\n  - change RenderHtml to RenderHTML PR #1057\n  - change RenderXml to RenderXML PR #1057\n\n#### Features\n- `revel/revel`:\n\n#### Enhancements\n- `revel/revel`:\n\n\n#### Bug Fixes\n- `revel/revel`:\n\n\n# v0.13.1\n@jeevatkm released this on 2016-06-07\n\n**Bug fix:**\n- Windows path fix #1064\n\n\n# v0.13.0\n@jeevatkm released this on 2016-06-06\n\n## Changes since v0.12.0\n\n#### Breaking Changes\n- `revel/revel`:\n  - Application Config name changed from `watcher.*` to `watch.*`  PR #992, PR #991\n\n#### Features\n- `revel/revel`:\n  - Request access log PR #1059, PR #913, #1055\n  - Messages loaded from modules too PR #828\n- `revel/cmd`:\n  - Added `revel version` command emits the revel version and go version revel/cmd#19\n\n#### Enhancements\n- `revel/revel`:\n  - Creates log directory if missing PR #1039\n  - Added `application/javascript` to accepted headers PR #1022\n  - You can change `Server.Addr` value via hook function PR #999\n  - Improved deflate/gzip compressor PR #995\n  - Consistent config name `watch.*` PR #992, PR #991\n  - Defaults to HttpOnly and always secure cookies for non-dev mode #942, PR #943\n  - Configurable server Read and Write Timeout via app config #936, PR #940\n  - `OnAppStart` hook now supports order param too PR #935\n  - Added `PutForm` and `PutFormCustom` helper method in `testing.TestSuite` #898\n  - Validator supports UTF-8 string too PR #891, #841\n  - Added `InitServer` method that returns `http.HandlerFunc` PR #879\n  - Symlink aware processing Views, Messages and Watch mode PR #867, #673\n  - Added i18n settings support unknown format PR #852\n  - i18n: Make Message Translation pluggable PR #768\n  - jQuery `min-2.2.4` & Bootstrap `min-3.3.6` version updated in `skeleton/public` #1063\n- `revel/cmd`:\n  - Revel identifies current `GOPATH` and performs `new` command; relative to directory revel/revel#1004\n  - Installs package dependencies during a build PR revel/cmd#43\n  - Non-200 response of test case request will correctly result into error PR revel/cmd#38\n  - Websockets SSL support in `dev` mode PR revel/cmd#32\n  - Won't yell about non-existent directory while cleaning PR revel/cmd#31, #908\n    - [x] non-fatal errors when building #908\n  - Improved warnings about route generation PR revel/cmd#25\n  - Command is Symlink aware PR revel/cmd#20\n  - `revel package` & `revel build` now supports environment mode PR revel/cmd#14\n  - `revel clean` now cleans generated routes too PR revel/cmd#6\n- `revel/config`:\n  - Upstream `robfig/config` refresh and import path updated from `github.com/revel/revel/config` to `github.com/revel/config`, PR #868\n  - Config loading order and external configuration to override application configuration revel/config#4 [commit](https://github.com/revel/revel/commit/f3a422c228994978ae0a5dd837afa97248b26b41)\n  - Application config error will produce insight on error PR revel/config#3 [commit](https://github.com/revel/config/commit/85a123061070899a82f59c5ef6187e8fb4457f64)\n- `revel/modules`:\n  - Testrunner enhancements\n    - Minor improvement on testrunner module PR #820, #895\n    - Add Test Runner panels per test group PR revel/modules#12\n- `revel/revel.github.io`:\n  - Update `index.md` and homepage (change how samples repo is installed) PR [#85](https://github.com/revel/revel.github.io/pull/85)\n  - Couple of UI improvements PR [#93](https://github.com/revel/revel.github.io/pull/93)\n  - Updated techempower benchmarks Round 11 [URL](http://www.techempower.com/benchmarks/#section=data-r11)\n  - Docs updated for v0.13 release\n- Cross-Platform Support\n  - Slashes should be normalized in paths #260, PR #1028, PR #928\n\n#### Bug Fixes\n- `revel/revel`:\n  - Binder: Multipart `io.Reader` parameters needs to be closed #756\n  - Default Date & Time Format correct in skeleton PR #1062, #878\n  - Addressed with alternative for `json: unsupported type: <-chan struct {}` on Go 1.6 revel/revel#1037\n  - Addressed one edge case, invalid Accept-Encoding header causes panic revel/revel#914\n\n\n# v0.11.3\n@brendensoares released this on 2015-01-04\n\nThis is a minor release to address a critical bug (#824) in v0.11.2.\n\nEverybody is strongly encouraged to rebuild their projects with the latest version of Revel. To do it, execute the commands:\n\n``` sh\n$ go get -u github.com/revel/cmd/revel\n\n$ revel build github.com/myusername/myproject /path/to/destination/folder\n```\n\n\n# v0.11.2\non 2014-11-23\n\nThis is a minor release to address a critical bug in v0.11.0.\n\nEverybody is strongly encouraged to rebuild their projects with the latest version of Revel. To do it, execute the commands:\n\n``` sh\n$ go get -u github.com/revel/cmd/revel\n\n$ revel build github.com/myusername/myproject /path/to/destination/folder\n```\n\n\n# v0.11.1\n@pushrax released this on 2014-10-27\n\nThis is a minor release to address a compilation error in v0.11.0.\n\n\n# v0.12.0\n@brendensoares released this on 2015-03-25\n\nChanges since v0.11.3:\n\n## Breaking Changes\n1. Add import path to new `testing` sub-package for all Revel tests. For example:\n\n``` go\npackage tests\n\nimport \"github.com/revel/revel/testing\"\n\ntype AppTest struct {\n    testing.TestSuite\n}\n```\n1. We've relocated modules to a dedicated repo. Make sure you update your `conf/app.conf`. For example, change:\n\n``` ini\nmodule.static=github.com/revel/revel/modules/static\nmodule.testrunner = github.com/revel/revel/modules/testrunner\n```\n\nto the new paths:\n\n``` ini\nmodule.static=github.com/revel/modules/static\nmodule.testrunner = github.com/revel/modules/testrunner\n```\n\n## [ROADMAP] Focus: Improve Internal Organization\n\nThe majority of our effort here is increasing the modularity of the code within Revel so that further development can be done more productively while keeping documentation up to date.\n- `revel/revel.github.io`\n  - [x] Improve docs #[43](https://github.com/revel/revel.github.io/pull/43)\n- `revel/revel`:\n  - [x] Move the `revel/revel/harness` to the `revel/cmd` repo since it's only used during build time. #[714](https://github.com/revel/revel/issues/714)\n  - [x] Move `revel/revel/modules` to the `revel/modules` repo #[785](https://github.com/revel/revel/issues/785)\n  - [x] Move `revel/revel/samples` to the `revel/samples` repo #[784](https://github.com/revel/revel/issues/784)\n  - [x] `testing` TestSuite #[737](https://github.com/revel/revel/issues/737) #[810](https://github.com/revel/revel/issues/810)\n  - [x] Feature/sane http timeout defaults #[837](https://github.com/revel/revel/issues/837) PR#[843](https://github.com/revel/revel/issues/843) Bug Fix PR#[860](https://github.com/revel/revel/issues/860)\n  - [x] Eagerly load templates in dev mode #[353](https://github.com/revel/revel/issues/353) PR#[844](https://github.com/revel/revel/pull/844)\n  - [x] Add an option to trim whitespace from rendered HTML #[800](https://github.com/revel/revel/issues/800)\n  - [x] Remove built-in mailer in favor of 3rd party package #[783](https://github.com/revel/revel/issues/783)\n  - [x] Allow local reverse proxy access to jobs module status page for IPv4/6 #[481](https://github.com/revel/revel/issues/481) PR#[6](https://github.com/revel/modules/pull/6) PR#[7](https://github.com/revel/modules/pull/7)\n  - [x] Add default http.Status code for render methods. #[728](https://github.com/revel/revel/issues/728)\n  - [x] add domain for cookie #[770](https://github.com/revel/revel/issues/770) PR#[882](https://github.com/revel/revel/pull/882)\n  - [x] production mode panic bug #[831](https://github.com/revel/revel/issues/831) PR#[881](https://github.com/revel/revel/pull/881)\n  - [x] Fixes template loading order whether watcher is enabled or not #[844](https://github.com/revel/revel/issues/844)\n  - [x] Fixes reverse routing wildcard bug PR#[886](https://github.com/revel/revel/pull/886) #[869](https://github.com/revel/revel/issues/869)\n  - [x] Fixes router app start bug without routes. PR #[855](https://github.com/revel/revel/pull/855)\n  - [x] Friendly URL template errors; Fixes template `url` func \"index out of range\" when param is `undefined` #[811](https://github.com/revel/revel/issues/811) PR#[880](https://github.com/revel/revel/pull/880)\n  - [x] Make result compression conditional PR#[888](https://github.com/revel/revel/pull/888)\n  - [x] ensure routes are loaded before returning from OnAppStart callback PR#[884](https://github.com/revel/revel/pull/884)\n  - [x] Use \"302 Found\" HTTP code for redirect PR#[900](https://github.com/revel/revel/pull/900)\n  - [x] Fix broken fake app tests PR#[899](https://github.com/revel/revel/pull/899)\n  - [x] Optimize search of template names PR#[885](https://github.com/revel/revel/pull/885)\n- `revel/cmd`:\n  - [x] track current Revel version #[418](https://github.com/revel/revel/issues/418) PR#[858](https://github.com/revel/revel/pull/858)\n  - [x] log path error After revel build? #[763](https://github.com/revel/revel/issues/763)\n  - [x] Use a separate directory for revel project binaries #[17](https://github.com/revel/cmd/pull/17) #[819](https://github.com/revel/revel/issues/819)\n  - [x] Overwrite generated app files instead of deleting directory #[551](https://github.com/revel/revel/issues/551) PR#[23](https://github.com/revel/cmd/pull/23)\n- `revel/modules`:\n  - [x] Adds runtime pprof/trace support #[9](https://github.com/revel/modules/pull/9)\n- Community Goals:\n  - [x] Issue labels #[545](https://github.com/revel/revel/issues/545)\n    - [x] Sync up labels/milestones in other repos #[721](https://github.com/revel/revel/issues/721)\n  - [x] Update the Revel Manual to reflect current features\n    - [x] [revel/revel.github.io/32](https://github.com/revel/revel.github.io/issues/32)\n    - [x] [revel/revel.github.io/39](https://github.com/revel/revel.github.io/issues/39)\n    - [x] Docs are obsolete, inaccessible TestRequest.testSuite #[791](https://github.com/revel/revel/issues/791)\n    - [x] Some questions about revel & go docs #[793](https://github.com/revel/revel/issues/793)\n  - [x] RFCs to organize features #[827](https://github.com/revel/revel/issues/827)\n\n[Full list of commits](https://github.com/revel/revel/compare/v0.11.3...v0.12.0)\n\n\n# v0.11.0\n@brendensoares released this on 2014-10-26\n\nNote, Revel 0.11 requires Go 1.3 or higher.\n\nChanges since v0.10:\n\n[BUG]   #729    Adding define inside the template results in an error (Changes how template file name case insensitivity is handled)\n\n[ENH]   #769    Add swap files to gitignore\n[ENH]   #766    Added passing in build flags to the go build command\n[ENH]   #761    Fixing cross-compiling issue #456 setting windows path from linux\n[ENH]   #759    Include upload sample's tests in travis\n[ENH]   #755    Changes c.Action to be the action method name's letter casing per #635\n[ENH]   #754    Adds call stack display to runtime panic in browser to match console\n[ENH]   #740    Redis Cache: Add timeouts.\n[ENH]   #734    watcher: treat fsnotify Op as a bitmask\n[ENH]   #731    Second struct in type revel fails to find the controller\n[ENH]   #725    Testrunner: show response info\n[ENH]   #723    Improved compilation errors and open file from error page\n[ENH]   #720    Get testrunner path from config file\n[ENH]   #707    Add log.colorize option to enable/disable colorize\n[ENH]   #696    Revel file upload testing\n[ENH]   #694    Install dependencies at build time\n[ENH]   #693    Prefer extension over Accept header\n[ENH]   #692    Update fsnotify to v1 API\n[ENH]   #690    Support zero downtime restarts\n[ENH]   #687    Tests: request override\n[ENH]   #685    Persona sample tests and bugfix\n[ENH]   #598    Added README file to Revel skeleton\n[ENH]   #591    Realtime rebuild\n[ENH]   #573    Add AppRoot to allow changing the root path of an application\n\n[FTR]   #606    CSRF Support\n\n[Full list of commits](https://github.com/revel/revel/compare/v0.10.0...v0.11.0)\n\n\n# v0.10.0\n@brendensoares released this on 2014-08-10\n\nChanges since v0.9.1:\n- [FTR] #641 - Add \"X-HTTP-Method-Override\" to router\n- [FTR] #583 - Added HttpMethodOverride filter to routes\n- [FTR] #540 - watcher flag for refresh on app start\n- [BUG] #681 - Case insensitive comparison for websocket upgrades (Fixes IE Websockets ...\n- [BUG] #668 - Compression: Properly close gzip/deflate\n- [BUG] #667 - Fix redis GetMulti and improve test coverage\n- [BUG] #664 - Is compression working correct?\n- [BUG] #657 - Redis Cache: panic when testing Ge\n- [BUG] #637 - RedisCache: fix Get/GetMulti error return\n- [BUG] #621 - Bugfix/router csv error\n- [BUG] #618 - Router throws exception when parsing line with multiple default string arguments\n- [BUG] #604 - Compression: Properly close gzip/deflate.\n- [BUG] #567 - Fixed regex pattern to properly require message files to have a dot in filename\n- [BUG] #566 - Compression fails (\"unexpected EOF\" in tests)\n- [BUG] #287 - Don't remove the parent folders containing generated code.\n- [BUG] #556 - fix for #534, also added url path to not found message\n- [BUG] #534 - Websocket route not found\n- [BUG] #343 - validation.Required(funtionCall).Key(...) - reflect.go:715: Failed to generate name for field.\n- [ENH] #643 - Documentation Fix in Skeleton for OnAppStart\n- [ENH] #674 - Removes custom `eq` template function\n- [ENH] #669 - Develop compress closenotifier\n- [ENH] #663 - fix for static content type not being set and defaulting to OS\n- [ENH] #658 - Minor: fix niggle with import statement\n- [ENH] #652 - Update the contributing guidelines\n- [ENH] #651 - Use upstream gomemcache again\n- [ENH] #650 - Go back to upstream memcached library\n- [ENH] #612 - Fix CI package error\n- [ENH] #611 - Fix \"go vet\" problems\n- [ENH] #610 - Added MakeMultipartRequest() to the TestSuite\n- [ENH] #608 - Develop compress closenotifier\n- [ENH] #596 - Expose redis cache options to config\n- [ENH] #581 - Make the option template tag type agnostic.\n- [ENH] #576 - Defer session instantiation to first set\n- [ENH] #565 - Fix #563 -- Some custom template funcs cannot be used in JavaScript cont...\n- [ENH] #563 - TemplateFuncs cannot be used in JavaScript context\n- [ENH] #561 - Fix missing extension from message file causing panic\n- [ENH] #560 - enhancement / templateFunc `firstof`\n- [ENH] #555 - adding symlink handling to the template loader and watcher processes\n- [ENH] #531 - Update app.conf.template\n- [ENH] #520 - Respect controller's Response.Status when action returns nil\n- [ENH] #519 - Link to issues\n- [ENH] #486 - Support for json compress\n- [ENH] #480 - Eq implementation in template.go still necessary ?\n- [ENH] #461 - Cron jobs not started until I pull a page\n- [ENH] #323 - disable session/set-cookie for `Static.Serve()`\n\n[Full list of commits](https://github.com/revel/revel/compare/v0.9.1...v0.10.0)\n\n\n# v0.9.1\n@pushrax released this on 2014-03-02\n\nMinor patch release to address a couple bugs.\n\nChanges since v0.9.0:\n- [BUG] #529 - Wrong path was used to determine existence of `.git`\n- [BUG] #532 - Fix typo for new type `ValidEmail`\n\nThe full list of commits can be found [here](https://github.com/revel/revel/compare/v0.9.0...v0.9.1).\n\n\n# v0.9.0\n@pushrax released this on 2014-02-26\n\n## Revel GitHub Organization\n\nWe've moved development of the framework to the @revel GitHub organization, to help manage the project as Revel grows. The old import path is still valid, but will not be updated in the future.\n\nYou'll need to manually update your apps to work with the new import path. This can be done by replacing all instances of `github.com/robfig/revel` with `github.com/revel/revel` in your app, and running:\n\n```\n$ cd your_app_folder\n$ go get -u github.com/howeyc/fsnotify  # needs updating\n$ go get github.com/revel/revel\n$ go get github.com/revel/cmd/revel     # command line tools have moved\n```\n\n**Note:** if you have references to `github.com/robfig/revel/revel` in any files, you need to replace them with `github.com/revel/cmd/revel` _before_ replacing `github.com/robfig/revel`! (note the prefix collision)\n\nIf you have any trouble upgrading or notice something we missed, feel free to hop in the IRC channel (#revel on Freenode) or send the mailing list a message.\n\nAlso note, the documentation is now at [revel.github.io](http://revel.github.io)!\n\nChanges since v0.8:\n- [BUG] #522 - `revel new` bug\n- [BUG] - Booking sample error\n- [BUG] #504 - File access via URL security issue\n- [BUG] #489 - Email validator bug\n- [BUG] #475 - File watcher infinite loop\n- [BUG] #333 - Extensions in routes break parameters\n- [FTR] #472 - Support for 3rd part app skeletons\n- [ENH] #512 - Per session expiration methods\n- [ENH] #496 - Type check renderArgs[CurrentLocalRenderArg]\n- [ENH] #490 - App.conf manual typo\n- [ENH] #487 - Make files executable on `revel build`\n- [ENH] #482 - Retain input values after form valdiation\n- [ENH] #473 - OnAppStart documentation\n- [ENH] #466 - JSON error template quoting fix\n- [ENH] #464 - Remove unneeded trace statement\n- [ENH] #457 - Remove unneeded trace\n- [ENH] #508 - Support arbitrary network types\n- [ENH] #516 - Add Date and Message-Id mail headers\n\nThe full list of commits can be found [here](https://github.com/revel/revel/compare/v0.8...v0.9.0).\n\n\n# v0.8\n@pushrax released this on 2014-01-06\n\nChanges since v0.7:\n- [BUG] #379 - HTTP 500 error for not found public path files\n- [FTR] #424 - HTTP pprof support\n- [FTR] #346 - Redis Cache support\n- [FTR] #292 - SMTP Mailer\n- [ENH] #443 - Validator constructors to improve `v.Check()` usage\n- [ENH] #439 - Basic terminal output coloring\n- [ENH] #428 - Improve error message for missing `RenderArg`\n- [ENH] #422 - Route embedding for modules\n- [ENH] #413 - App version variable\n- [ENH] #153 - $GOPATH-wide file watching aka hot loading\n\n\n# v0.6\n@robfig released this on 2013-09-16\n\n\n\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 6.7998046875,
          "content": "## Contributing to Revel\n\nThis describes how developers may contribute to Revel.\n\n## Mission\n\nRevel's mission is to provide a batteries-included framework for making large\nscale web application development as efficient and maintainable as possible.\n\nThe design should be configurable and modular so that it can grow with the\ndeveloper. However, it should provide a wonderful un-boxing experience and\ndefault configuration that can woo new developers and make simple web apps\nstraight forward. The framework should have an opinion about how to do all of the\ncommon tasks in web development to reduce unnecessary cognitive load.\n\nPerhaps most important of all, Revel should be a joy to use. We want to reduce\nthe time spent on tedious boilerplate functionality and increase the time\navailable for creating polished solutions for your application's target users.\n\n## How to Contribute\n\n### Join the Community\n\nThe first step to making Revel better is joining the community! You can find the\ncommunity on:\n\n* [Google Groups](https://groups.google.com/forum/#!forum/revel-framework) via [revel-framework@googlegroups.com](mailto:revel-framework@googlegroups.com)\n* [GitHub Issues](https://github.com/revel/revel/issues)\n* [StackOverflow Questions](http://stackoverflow.com/questions/tagged/revel)\n* [IRC](http://webchat.freenode.net/?channels=%23revel&uio=d4) via #revel on Freenode\n\nOnce you've joined, there are many ways to contribute to Revel:\n\n* Report bugs (via GitHub)\n* Answer questions of other community members (via Google Groups or IRC)\n* Give feedback on new feature discussions (via GitHub and Google Groups)\n* Propose your own ideas (via Google Groups or GitHub)\n\n### How Revel is Developed\n\nWe have begun to formalize the development process by adopting pragmatic\npractices such as:\n\n* Developing on the `develop` branch\n* Merging `develop` branch to `master` branch in 6 week iterations\n* Tagging releases with MAJOR.MINOR syntax (e.g. v0.8)\n** We may also tag MAJOR.MINOR.HOTFIX releases as needed (e.g. v0.8.1) to\naddress urgent bugs. Such releases will not introduce or change functionality\n* Managing bugs, enhancements, features and release milestones via GitHub's Issue Tracker\n* Using feature branches to create pull requests\n* Discussing new features **before** hacking away at it\n\n\n### How to Correctly Fork\n\nGo uses the repository URL to import packages, so forking and `go get`ing the\nforked project **will not work**.\n\nInstead, follow these steps:\n\n1. Install Revel normally\n2. Fork Revel on GitHub\n3. Add your fork as a git remote\n\nHere's the commands to do so:\n```\n$ go get github.com/revel/revel                        # Install Revel\n$ cd $GOPATH/src/github.com/revel/revel                # Change directory to revel repo\n$ git remote add fork git@github.com:$USER/revel.git  # Add your fork as a remote, where $USER is your GitHub username\n```\n\n### Create a Feature Branch & Code Away!\n\nNow that you've properly installed and forked Revel, you are ready to start coding (assuming\nyou have a validated your ideas with other community members)!\n\nIn order to have your pull requests accepted, we recommend you make your changes to Revel on a\nnew git branch. For example,\n```\n$ git checkout -b feature/useful-new-thing origin/develop    # Create a new branch based on develop and switch to it\n$ ...                                                        # Make your changes and commit them\n$ git push fork feature/useful-new-thing                     # After new commits, push to your fork\n```\n\n### Format Your Code\n\nRemember to run `go fmt` before committing your changes.\nMany Go developers opt to have their editor run `go fmt` automatically when\nsaving Go files.\n\nAdditionally, follow the [core Go style conventions](https://code.google.com/p/go-wiki/wiki/CodeReviewComments)\nto have your pull requests accepted.\n\n### Write Tests (and Benchmarks for Bonus Points)\n\nSignificant new features require tests. Besides unit tests, it is also possible\nto test a feature by exercising it in one of the sample apps and verifying its\noperation using that app's test suite. This has the added benefit of providing\nexample code for developers to refer to.\n\nBenchmarks are helpful but not required.\n\n### Run the Tests\n\nTypically running the main set of unit tests will be sufficient:\n\n```\n$ go test github.com/revel/revel\n```\n\nRefer to the\n[Travis configuration](https://github.com/revel/revel/blob/master/.travis.yml)\nfor the full set of tests.  They take less than a minute to run.\n\n### Document Your Feature\n\nDue to the wide audience and shared nature of Revel, documentation is an essential\naddition to your new code. **Pull requests risk not being accepted** until proper\ndocumentation is created to detail how to make use of new functionality.\n\nThe [Revel web site](http://revel.github.io/) is hosted on GitHub Pages and\n[built with Jekyll](https://help.github.com/articles/using-jekyll-with-pages).\n\nTo develop the Jekyll site locally:\n\n    # Clone the documentation repository\n    $ git clone git@github.com:revel/revel.github.io\n    $ cd revel.github.io\n\n    # Install and run Jekyll to generate and serve the site\n    $ gem install jekyll kramdown\n    $ jekyll serve --watch\n\n    # Now load in your browser\n    $ open http://localhost:4000/\n\nAny changes you make to the site should be reflected within a few seconds.\n\n### Submit Pull Request\n\nOnce you've done all of the above & pushed your changes to your fork, you can create a pull request for review and acceptance.\n\n## Potential Projects\n\nThese are outstanding feature requests, roughly ordered by priority.\nAdditionally, there are frequently smaller feature requests or items in the\n[issues](https://github.com/revel/revel/issues?labels=contributor+ready&page=1&state=open).\n\n1.\tBetter ORM support.  Provide more samples (or modules) and better documentation for setting up common situations like SQL database, Mongo, LevelDB, etc.\n1.\tSupport for other templating languages (e.g. mustache, HAML).  Make TemplateLoader pluggable.  Use Pongo instead of vanilla Go templates (and update the samples)\n1.\tTest Fixtures\n1.\tAuthenticity tokens for CSRF protection\n1.\tCoffeescript pre-processor.  Could potentially use [otto](https://github.com/robertkrimen/otto) as a native Go method to compiling.\n1.\tSCSS/LESS pre-processor.\n1.\tGAE support.  Some progress made in the 'appengine' branch -- the remaining piece is running the appengine services in development.\n1.\tMore Form helpers (template funcs).\n1.\tA Mongo module (perhaps with a sample app)\n1.\tDeployment to OpenShift (support, documentation, etc)\n1.\tImprove the logging situation.  The configuration is a little awkward and not very powerful.  Integrating something more powerful would be good. (like [seelog](https://github.com/cihub/seelog) or [log4go](https://code.google.com/p/log4go/))\n1.\tETags, cache controls\n1.\tA module or plugins for adding HTTP Basic Auth\n1.\tAllowing the app to hook into the source code processing step\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.07421875,
          "content": "The MIT License (MIT)\n\nCopyright (C) 2012-2018 The Revel Framework Authors.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.1708984375,
          "content": "# Revel Framework\n\n[![Build Status](https://secure.travis-ci.org/revel/revel.svg?branch=master)](https://travis-ci.org/revel/revel) \n[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Go Report Card](https://goreportcard.com/badge/github.com/revel/revel)](https://goreportcard.com/report/github.com/revel/revel)\n\nA high productivity, full-stack web framework for the [Go language](https://www.golang.org).\n\nCurrent Version: 1.1.0 (2022-04-11)\n\n**Supports go.mod package management**\n\n## Quick Start\n\nInstall Revel:\n\n\tgo install github.com/revel/cmd/revel@latest\n\n\nCreate & Run your app:\n\n\trevel new -a my-app -r\n\nOpen http://localhost:9000 in your browser and you should see \"It works!\"\n\n\n## Community\n\n* [Gitter](https://gitter.im/revel/community)\n* [StackOverflow](https://stackoverflow.com/questions/tagged/revel)\n\n\n## Learn More\n\n* [Manual, Samples, Godocs, etc](https://revel.github.io)\n* [Apps using Revel](https://github.com/revel/revel/wiki/Apps-in-the-Wild)\n* [Articles Featuring Revel](https://github.com/revel/revel/wiki/Articles)\n\n## Contributing\n\n* [Contributing Code Guidelines](https://github.com/revel/revel/blob/master/CONTRIBUTING.md)\n* [Revel Contributors](https://github.com/revel/revel/graphs/contributors)\n\n## Contributors\n\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/0)](https://sourcerer.io/fame/notzippy/revel/revel/links/0)\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/1)](https://sourcerer.io/fame/notzippy/revel/revel/links/1)\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/2)](https://sourcerer.io/fame/notzippy/revel/revel/links/2)\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/3)](https://sourcerer.io/fame/notzippy/revel/revel/links/3)\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/4)](https://sourcerer.io/fame/notzippy/revel/revel/links/4)\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/5)](https://sourcerer.io/fame/notzippy/revel/revel/links/5)\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/6)](https://sourcerer.io/fame/notzippy/revel/revel/links/6)\n[![](https://sourcerer.io/fame/notzippy/revel/revel/images/7)](https://sourcerer.io/fame/notzippy/revel/revel/links/7)\n"
        },
        {
          "name": "before_after_filter.go",
          "type": "blob",
          "size": 1.50390625,
          "content": "package revel\n\nimport (\n\t\"reflect\"\n)\n\n// Autocalls any defined before and after methods on the target controller\n// If either calls returns a value then the result is returned.\nfunc BeforeAfterFilter(c *Controller, fc []Filter) {\n\tdefer func() {\n\t\tif resultValue := beforeAfterFilterInvoke(FINALLY, c); resultValue != nil && !resultValue.IsNil() {\n\t\t\tc.Result = resultValue.Interface().(Result)\n\t\t}\n\t}()\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tif resultValue := beforeAfterFilterInvoke(PANIC, c); resultValue != nil && !resultValue.IsNil() {\n\t\t\t\tc.Result = resultValue.Interface().(Result)\n\t\t\t}\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\tif resultValue := beforeAfterFilterInvoke(BEFORE, c); resultValue != nil && !resultValue.IsNil() {\n\t\tc.Result = resultValue.Interface().(Result)\n\t\treturn\n\t}\n\tfc[0](c, fc[1:])\n\tif resultValue := beforeAfterFilterInvoke(AFTER, c); resultValue != nil && !resultValue.IsNil() {\n\t\tc.Result = resultValue.Interface().(Result)\n\t}\n}\n\nfunc beforeAfterFilterInvoke(method When, c *Controller) (r *reflect.Value) {\n\tif c.Type == nil {\n\t\treturn\n\t}\n\tvar index []*ControllerFieldPath\n\tswitch method {\n\tcase BEFORE:\n\t\tindex = c.Type.ControllerEvents.Before\n\tcase AFTER:\n\t\tindex = c.Type.ControllerEvents.After\n\tcase FINALLY:\n\t\tindex = c.Type.ControllerEvents.Finally\n\tcase PANIC:\n\t\tindex = c.Type.ControllerEvents.Panic\n\t}\n\n\tif len(index) == 0 {\n\t\treturn\n\t}\n\tfor _, function := range index {\n\t\tresult := function.Invoke(reflect.ValueOf(c.AppController), nil)[0]\n\t\tif !result.IsNil() {\n\t\t\treturn &result\n\t\t}\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "before_after_filter_test.go",
          "type": "blob",
          "size": 1.1142578125,
          "content": "// Copyright (c) 2019 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"testing\"\n)\n\ntype bafTestController struct {\n\t*Controller\n}\n\nfunc (c bafTestController) Before() (Result, bafTestController) {\n\treturn c.Redirect(\"http://www.example.com\"), c\n}\n\nfunc (c bafTestController) Index() Result {\n\t// We shouldn't get here\n\tpanic(\"Should not be called\")\n}\n\ntype failingFilter struct {\n\tt *testing.T\n}\n\nfunc (f failingFilter) FailIfCalled(c *Controller, filterChain []Filter) {\n\tf.t.Error(\"Filter should not have been called\")\n}\n\nfunc TestInterceptorsNotCalledIfBeforeReturns(t *testing.T) {\n\tInit(\"prod\", \"github.com/revel/revel/testdata\", \"\")\n\tcontrollers = make(map[string]*ControllerType)\n\tRegisterController((*bafTestController)(nil), []*MethodType{\n\t\t{\n\t\t\tName: \"Before\",\n\t\t},\n\t\t{\n\t\t\tName: \"Index\",\n\t\t},\n\t})\n\n\tc := NewControllerEmpty()\n\terr := c.SetAction(\"bafTestController\", \"Index\")\n\tif err != nil {\n\t\tt.Error(err.Error())\n\t}\n\n\tBeforeAfterFilter(c, []Filter{failingFilter{t}.FailIfCalled})\n}\n"
        },
        {
          "name": "binder.go",
          "type": "blob",
          "size": 16.26171875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// A Binder translates between string parameters and Go data structures.\ntype Binder struct {\n\t// Bind takes the name and type of the desired parameter and constructs it\n\t// from one or more values from Params.\n\t//\n\t// Example\n\t//\n\t// Request:\n\t//   url?id=123&ol[0]=1&ol[1]=2&ul[]=str&ul[]=array&user.Name=rob\n\t//\n\t// Action:\n\t//   Example.Action(id int, ol []int, ul []string, user User)\n\t//\n\t// Calls:\n\t//   Bind(params, \"id\", int): 123\n\t//   Bind(params, \"ol\", []int): {1, 2}\n\t//   Bind(params, \"ul\", []string): {\"str\", \"array\"}\n\t//   Bind(params, \"user\", User): User{Name:\"rob\"}\n\t//\n\t// Note that only exported struct fields may be bound.\n\tBind func(params *Params, name string, typ reflect.Type) reflect.Value\n\n\t// Unbind serializes a given value to one or more URL parameters of the given\n\t// name.\n\tUnbind func(output map[string]string, name string, val interface{})\n}\n\nvar binderLog = RevelLog.New(\"section\", \"binder\")\n\n// ValueBinder is adapter for easily making one-key-value binders.\nfunc ValueBinder(f func(value string, typ reflect.Type) reflect.Value) func(*Params, string, reflect.Type) reflect.Value {\n\treturn func(params *Params, name string, typ reflect.Type) reflect.Value {\n\t\tvals, ok := params.Values[name]\n\t\tif !ok || len(vals) == 0 {\n\t\t\treturn reflect.Zero(typ)\n\t\t}\n\t\treturn f(vals[0], typ)\n\t}\n}\n\n// Revel's default date and time constants.\nconst (\n\tDefaultDateFormat     = \"2006-01-02\"\n\tDefaultDateTimeFormat = \"2006-01-02 15:04\"\n)\n\n// Binders type and kind definition.\nvar (\n\t// These are the lookups to find a Binder for any type of data.\n\t// The most specific binder found will be used (Type before Kind).\n\tTypeBinders = make(map[reflect.Type]Binder)\n\tKindBinders = make(map[reflect.Kind]Binder)\n\n\t// Applications can add custom time formats to this array, and they will be\n\t// automatically attempted when binding a time.Time.\n\tTimeFormats = []string{}\n\n\tDateFormat     string\n\tDateTimeFormat string\n\tTimeZone       = time.UTC\n\n\tIntBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tintValue, err := strconv.ParseInt(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"IntBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetInt(intValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%d\", val)\n\t\t},\n\t}\n\n\tUintBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tuintValue, err := strconv.ParseUint(val, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"UintBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetUint(uintValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%d\", val)\n\t\t},\n\t}\n\n\tFloatBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tif len(val) == 0 {\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tfloatValue, err := strconv.ParseFloat(val, 64)\n\t\t\tif err != nil {\n\t\t\t\tbinderLog.Warn(\"FloatBinder Conversion Error\", \"error\", err)\n\t\t\t\treturn reflect.Zero(typ)\n\t\t\t}\n\t\t\tpValue := reflect.New(typ)\n\t\t\tpValue.Elem().SetFloat(floatValue)\n\t\t\treturn pValue.Elem()\n\t\t}),\n\t\tUnbind: func(output map[string]string, key string, val interface{}) {\n\t\t\toutput[key] = fmt.Sprintf(\"%f\", val)\n\t\t},\n\t}\n\n\tStringBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\treturn reflect.ValueOf(val)\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\toutput[name] = val.(string)\n\t\t},\n\t}\n\n\t// Booleans support a various value formats,\n\t// refer `revel.Atob` method.\n\tBoolBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\treturn reflect.ValueOf(Atob(val))\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\toutput[name] = fmt.Sprintf(\"%t\", val)\n\t\t},\n\t}\n\n\tPointerBinder = Binder{\n\t\tBind: func(params *Params, name string, typ reflect.Type) reflect.Value {\n\t\t\tv := Bind(params, name, typ.Elem())\n\t\t\tif v.CanAddr() {\n\t\t\t\treturn v.Addr()\n\t\t\t}\n\n\t\t\treturn reflect.Zero(typ)\n\t\t},\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\tUnbind(output, name, reflect.ValueOf(val).Elem().Interface())\n\t\t},\n\t}\n\n\tTimeBinder = Binder{\n\t\tBind: ValueBinder(func(val string, typ reflect.Type) reflect.Value {\n\t\t\tfor _, f := range TimeFormats {\n\t\t\t\tif r, err := time.ParseInLocation(f, val, TimeZone); err == nil {\n\t\t\t\t\treturn reflect.ValueOf(r)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn reflect.Zero(typ)\n\t\t}),\n\t\tUnbind: func(output map[string]string, name string, val interface{}) {\n\t\t\tvar (\n\t\t\t\tt       = val.(time.Time)\n\t\t\t\tformat  = DateTimeFormat\n\t\t\t\th, m, s = t.Clock()\n\t\t\t)\n\t\t\tif h == 0 && m == 0 && s == 0 {\n\t\t\t\tformat = DateFormat\n\t\t\t}\n\t\t\toutput[name] = t.Format(format)\n\t\t},\n\t}\n\n\tMapBinder = Binder{\n\t\tBind:   bindMap,\n\t\tUnbind: unbindMap,\n\t}\n)\n\n// Used to keep track of the index for individual keyvalues.\ntype sliceValue struct {\n\tindex int           // Index extracted from brackets.  If -1, no index was provided.\n\tvalue reflect.Value // the bound value for this slice element.\n}\n\n// This function creates a slice of the given type, Binds each of the individual\n// elements, and then sets them to their appropriate location in the slice.\n// If elements are provided without an explicit index, they are added (in\n// unspecified order) to the end of the slice.\nfunc bindSlice(params *Params, name string, typ reflect.Type) reflect.Value {\n\t// Collect an array of slice elements with their indexes (and the max index).\n\tmaxIndex := -1\n\tnumNoIndex := 0\n\tsliceValues := []sliceValue{}\n\n\tmaxIndexBound := Config.IntDefault(\"params.max_index\", 4096)\n\n\t// Factor out the common slice logic (between form values and files).\n\tprocessElement := func(key string, vals []string, files []*multipart.FileHeader) {\n\t\tif !strings.HasPrefix(key, name+\"[\") {\n\t\t\treturn\n\t\t}\n\n\t\t// Extract the index, and the index where a sub-key starts. (e.g. field[0].subkey)\n\t\tindex := -1\n\t\tleftBracket, rightBracket := len(name), strings.Index(key[len(name):], \"]\")+len(name)\n\t\tif rightBracket > leftBracket+1 {\n\t\t\tindex, _ = strconv.Atoi(key[leftBracket+1 : rightBracket])\n\t\t}\n\t\tsubKeyIndex := rightBracket + 1\n\n\t\t// Handle the indexed case.\n\t\tif index > -1 {\n\t\t\t// Just ignore illegal index, fix issue #1424\n\t\t\tif index > maxIndexBound {\n\t\t\t\tbinderLog.Error(\"Ignoring parameter for security reason\", \"index\", index, \"key\", key)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif index > maxIndex {\n\t\t\t\tmaxIndex = index\n\t\t\t}\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: index,\n\t\t\t\tvalue: Bind(params, key[:subKeyIndex], typ.Elem()),\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// It's an un-indexed element.  (e.g. element[])\n\t\tnumNoIndex += len(vals) + len(files)\n\t\tfor _, val := range vals {\n\t\t\t// Unindexed values can only be direct-bound.\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: -1,\n\t\t\t\tvalue: BindValue(val, typ.Elem()),\n\t\t\t})\n\t\t}\n\n\t\tfor _, fileHeader := range files {\n\t\t\tsliceValues = append(sliceValues, sliceValue{\n\t\t\t\tindex: -1,\n\t\t\t\tvalue: BindFile(fileHeader, typ.Elem()),\n\t\t\t})\n\t\t}\n\t}\n\n\tfor key, vals := range params.Values {\n\t\tprocessElement(key, vals, nil)\n\t}\n\tfor key, fileHeaders := range params.Files {\n\t\tprocessElement(key, nil, fileHeaders)\n\t}\n\n\tresultArray := reflect.MakeSlice(typ, maxIndex+1, maxIndex+1+numNoIndex)\n\tfor _, sv := range sliceValues {\n\t\tif sv.index != -1 {\n\t\t\tresultArray.Index(sv.index).Set(sv.value)\n\t\t} else {\n\t\t\tresultArray = reflect.Append(resultArray, sv.value)\n\t\t}\n\t}\n\n\treturn resultArray\n}\n\n// Break on dots and brackets.\n// e.g. bar => \"bar\", bar.baz => \"bar\", bar[0] => \"bar\".\nfunc nextKey(key string) string {\n\tfieldLen := strings.IndexAny(key, \".[\")\n\tif fieldLen == -1 {\n\t\treturn key\n\t}\n\treturn key[:fieldLen]\n}\n\nfunc unbindSlice(output map[string]string, name string, val interface{}) {\n\tv := reflect.ValueOf(val)\n\tfor i := 0; i < v.Len(); i++ {\n\t\tUnbind(output, fmt.Sprintf(\"%s[%d]\", name, i), v.Index(i).Interface())\n\t}\n}\n\nfunc bindStruct(params *Params, name string, typ reflect.Type) reflect.Value {\n\tresultPointer := reflect.New(typ)\n\tresult := resultPointer.Elem()\n\tif params.JSON != nil {\n\t\t// Try to inject the response as a json into the created result\n\t\tif err := json.Unmarshal(params.JSON, resultPointer.Interface()); err != nil {\n\t\t\tbinderLog.Error(\"bindStruct Unable to unmarshal request\", \"name\", name, \"error\", err, \"data\", string(params.JSON))\n\t\t}\n\t\treturn result\n\t}\n\tfieldValues := make(map[string]reflect.Value)\n\tfor key := range params.Values {\n\t\tif !strings.HasPrefix(key, name+\".\") {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the name of the struct property.\n\t\t// Strip off the prefix. e.g. foo.bar.baz => bar.baz\n\t\tsuffix := key[len(name)+1:]\n\t\tfieldName := nextKey(suffix)\n\t\tfieldLen := len(fieldName)\n\n\t\tif _, ok := fieldValues[fieldName]; !ok {\n\t\t\t// Time to bind this field.  Get it and make sure we can set it.\n\t\t\tfieldValue := result.FieldByName(fieldName)\n\t\t\tif !fieldValue.IsValid() {\n\t\t\t\tbinderLog.Warn(\"bindStruct Field not found\", \"name\", fieldName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !fieldValue.CanSet() {\n\t\t\t\tbinderLog.Warn(\"bindStruct Field not settable\", \"name\", fieldName)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tboundVal := Bind(params, key[:len(name)+1+fieldLen], fieldValue.Type())\n\t\t\tfieldValue.Set(boundVal)\n\t\t\tfieldValues[fieldName] = boundVal\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc unbindStruct(output map[string]string, name string, iface interface{}) {\n\tval := reflect.ValueOf(iface)\n\ttyp := val.Type()\n\tfor i := 0; i < val.NumField(); i++ {\n\t\tstructField := typ.Field(i)\n\t\tfieldValue := val.Field(i)\n\n\t\t// PkgPath is specified to be empty exactly for exported fields.\n\t\tif structField.PkgPath == \"\" {\n\t\t\tUnbind(output, fmt.Sprintf(\"%s.%s\", name, structField.Name), fieldValue.Interface())\n\t\t}\n\t}\n}\n\n// Helper that returns an upload of the given name, or nil.\nfunc getMultipartFile(params *Params, name string) multipart.File {\n\tfor _, fileHeader := range params.Files[name] {\n\t\tfile, err := fileHeader.Open()\n\t\tif err == nil {\n\t\t\treturn file\n\t\t}\n\t\tbinderLog.Warn(\"getMultipartFile: Failed to open uploaded file\", \"name\", name, \"error\", err)\n\t}\n\treturn nil\n}\n\nfunc bindFile(params *Params, name string, typ reflect.Type) reflect.Value {\n\treader := getMultipartFile(params, name)\n\tif reader == nil {\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t// If it's already stored in a temp file, just return that.\n\tif osFile, ok := reader.(*os.File); ok {\n\t\treturn reflect.ValueOf(osFile)\n\t}\n\n\t// Otherwise, have to store it.\n\ttmpFile, err := ioutil.TempFile(\"\", \"revel-upload\")\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to create a temp file to store upload\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t// Register it to be deleted after the request is done.\n\tparams.tmpFiles = append(params.tmpFiles, tmpFile)\n\n\t_, err = io.Copy(tmpFile, reader)\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to copy upload to temp file\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\t_, err = tmpFile.Seek(0, 0)\n\tif err != nil {\n\t\tbinderLog.Warn(\"bindFile: Failed to seek to beginning of temp file\", \"name\", name, \"error\", err)\n\t\treturn reflect.Zero(typ)\n\t}\n\n\treturn reflect.ValueOf(tmpFile)\n}\n\nfunc bindByteArray(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif reader := getMultipartFile(params, name); reader != nil {\n\t\tb, err := ioutil.ReadAll(reader)\n\t\tif err == nil {\n\t\t\treturn reflect.ValueOf(b)\n\t\t}\n\t\tbinderLog.Warn(\"bindByteArray: Error reading uploaded file contents\", \"name\", name, \"error\", err)\n\t}\n\treturn reflect.Zero(typ)\n}\n\nfunc bindReadSeeker(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif reader := getMultipartFile(params, name); reader != nil {\n\t\treturn reflect.ValueOf(reader.(io.ReadSeeker))\n\t}\n\treturn reflect.Zero(typ)\n}\n\n// bindMap converts parameters using map syntax into the corresponding map. e.g.:\n//   params[\"a[5]\"]=foo, name=\"a\", typ=map[int]string => map[int]string{5: \"foo\"}\nfunc bindMap(params *Params, name string, typ reflect.Type) reflect.Value {\n\tvar (\n\t\tkeyType   = typ.Key()\n\t\tvalueType = typ.Elem()\n\t\tresultPtr = reflect.New(reflect.MapOf(keyType, valueType))\n\t\tresult    = resultPtr.Elem()\n\t)\n\tresult.Set(reflect.MakeMap(typ))\n\tif params.JSON != nil {\n\t\t// Try to inject the response as a json into the created result\n\t\tif err := json.Unmarshal(params.JSON, resultPtr.Interface()); err != nil {\n\t\t\tbinderLog.Warn(\"bindMap: Unable to unmarshal request\", \"name\", name, \"error\", err)\n\t\t}\n\t\treturn result\n\t}\n\n\tfor paramName := range params.Values {\n\t\t// The paramName string must start with the value in the \"name\" parameter,\n\t\t// otherwise there is no way the parameter is part of the map\n\t\tif !strings.HasPrefix(paramName, name) {\n\t\t\tcontinue\n\t\t}\n\n\t\tsuffix := paramName[len(name)+1:]\n\t\tfieldName := nextKey(suffix)\n\t\tif fieldName != \"\" {\n\t\t\tfieldName = fieldName[:len(fieldName)-1]\n\t\t}\n\t\tif !strings.HasPrefix(paramName, name+\"[\"+fieldName+\"]\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult.SetMapIndex(BindValue(fieldName, keyType), Bind(params, name+\"[\"+fieldName+\"]\", valueType))\n\t}\n\treturn result\n}\n\nfunc unbindMap(output map[string]string, name string, iface interface{}) {\n\tmapValue := reflect.ValueOf(iface)\n\tfor _, key := range mapValue.MapKeys() {\n\t\tUnbind(output, name+\"[\"+fmt.Sprintf(\"%v\", key.Interface())+\"]\",\n\t\t\tmapValue.MapIndex(key).Interface())\n\t}\n}\n\n// Bind takes the name and type of the desired parameter and constructs it\n// from one or more values from Params.\n// Returns the zero value of the type upon any sort of failure.\nfunc Bind(params *Params, name string, typ reflect.Type) reflect.Value {\n\tif binder, found := binderForType(typ); found {\n\t\treturn binder.Bind(params, name, typ)\n\t}\n\treturn reflect.Zero(typ)\n}\n\nfunc BindValue(val string, typ reflect.Type) reflect.Value {\n\treturn Bind(&Params{Values: map[string][]string{\"\": {val}}}, \"\", typ)\n}\n\nfunc BindFile(fileHeader *multipart.FileHeader, typ reflect.Type) reflect.Value {\n\treturn Bind(&Params{Files: map[string][]*multipart.FileHeader{\"\": {fileHeader}}}, \"\", typ)\n}\n\nfunc Unbind(output map[string]string, name string, val interface{}) {\n\tif binder, found := binderForType(reflect.TypeOf(val)); found {\n\t\tif binder.Unbind != nil {\n\t\t\tbinder.Unbind(output, name, val)\n\t\t} else {\n\t\t\tbinderLog.Error(\"Unbind: Unable to unmarshal request\", \"name\", name, \"value\", val)\n\t\t}\n\t}\n}\n\nfunc binderForType(typ reflect.Type) (Binder, bool) {\n\tbinder, ok := TypeBinders[typ]\n\tif !ok {\n\t\tbinder, ok = KindBinders[typ.Kind()]\n\t\tif !ok {\n\t\t\tbinderLog.Error(\"binderForType: no binder for type\", \"type\", typ)\n\t\t\treturn Binder{}, false\n\t\t}\n\t}\n\treturn binder, true\n}\n\n// Sadly, the binder lookups can not be declared initialized -- that results in\n// an \"initialization loop\" compile error.\nfunc init() {\n\tKindBinders[reflect.Int] = IntBinder\n\tKindBinders[reflect.Int8] = IntBinder\n\tKindBinders[reflect.Int16] = IntBinder\n\tKindBinders[reflect.Int32] = IntBinder\n\tKindBinders[reflect.Int64] = IntBinder\n\n\tKindBinders[reflect.Uint] = UintBinder\n\tKindBinders[reflect.Uint8] = UintBinder\n\tKindBinders[reflect.Uint16] = UintBinder\n\tKindBinders[reflect.Uint32] = UintBinder\n\tKindBinders[reflect.Uint64] = UintBinder\n\n\tKindBinders[reflect.Float32] = FloatBinder\n\tKindBinders[reflect.Float64] = FloatBinder\n\n\tKindBinders[reflect.String] = StringBinder\n\tKindBinders[reflect.Bool] = BoolBinder\n\tKindBinders[reflect.Slice] = Binder{bindSlice, unbindSlice}\n\tKindBinders[reflect.Struct] = Binder{bindStruct, unbindStruct}\n\tKindBinders[reflect.Ptr] = PointerBinder\n\tKindBinders[reflect.Map] = MapBinder\n\n\tTypeBinders[reflect.TypeOf(time.Time{})] = TimeBinder\n\n\t// Uploads\n\tTypeBinders[reflect.TypeOf(&os.File{})] = Binder{bindFile, nil}\n\tTypeBinders[reflect.TypeOf([]byte{})] = Binder{bindByteArray, nil}\n\tTypeBinders[reflect.TypeOf((*io.Reader)(nil)).Elem()] = Binder{bindReadSeeker, nil}\n\tTypeBinders[reflect.TypeOf((*io.ReadSeeker)(nil)).Elem()] = Binder{bindReadSeeker, nil}\n\n\tOnAppStart(func() {\n\t\tDateTimeFormat = Config.StringDefault(\"format.datetime\", DefaultDateTimeFormat)\n\t\tDateFormat = Config.StringDefault(\"format.date\", DefaultDateFormat)\n\t\tTimeFormats = append(TimeFormats, DateTimeFormat, DateFormat)\n\t})\n}\n"
        },
        {
          "name": "binder_test.go",
          "type": "blob",
          "size": 12.794921875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/revel/config\"\n)\n\ntype A struct {\n\tID   int\n\tName string\n\tB    B\n\t//nolint:unused\n\tprivate int\n}\n\ntype B struct {\n\tExtra string\n}\n\nvar (\n\tParamTestValues = map[string][]string{\n\t\t\"int\":                            {\"1\"},\n\t\t\"int8\":                           {\"1\"},\n\t\t\"int16\":                          {\"1\"},\n\t\t\"int32\":                          {\"1\"},\n\t\t\"int64\":                          {\"1\"},\n\t\t\"uint\":                           {\"1\"},\n\t\t\"uint8\":                          {\"1\"},\n\t\t\"uint16\":                         {\"1\"},\n\t\t\"uint32\":                         {\"1\"},\n\t\t\"uint64\":                         {\"1\"},\n\t\t\"float32\":                        {\"1.000000\"},\n\t\t\"float64\":                        {\"1.000000\"},\n\t\t\"str\":                            {\"hello\"},\n\t\t\"bool-true\":                      {\"true\"},\n\t\t\"bool-1\":                         {\"1\"},\n\t\t\"bool-on\":                        {\"on\"},\n\t\t\"bool-false\":                     {\"false\"},\n\t\t\"bool-0\":                         {\"0\"},\n\t\t\"bool-0.0\":                       {\"0.0\"},\n\t\t\"bool-off\":                       {\"off\"},\n\t\t\"bool-f\":                         {\"f\"},\n\t\t\"date\":                           {\"1982-07-09\"},\n\t\t\"datetime\":                       {\"1982-07-09 21:30\"},\n\t\t\"customDate\":                     {\"07/09/1982\"},\n\t\t\"arr[0]\":                         {\"1\"},\n\t\t\"arr[1]\":                         {\"2\"},\n\t\t\"arr[3]\":                         {\"3\"},\n\t\t\"uarr[]\":                         {\"1\", \"2\"},\n\t\t\"arruarr[0][]\":                   {\"1\", \"2\"},\n\t\t\"arruarr[1][]\":                   {\"3\", \"4\"},\n\t\t\"2darr[0][0]\":                    {\"0\"},\n\t\t\"2darr[0][1]\":                    {\"1\"},\n\t\t\"2darr[1][0]\":                    {\"10\"},\n\t\t\"2darr[1][1]\":                    {\"11\"},\n\t\t\"A.ID\":                           {\"123\"},\n\t\t\"A.Name\":                         {\"rob\"},\n\t\t\"B.ID\":                           {\"123\"},\n\t\t\"B.Name\":                         {\"rob\"},\n\t\t\"B.B.Extra\":                      {\"hello\"},\n\t\t\"pB.ID\":                          {\"123\"},\n\t\t\"pB.Name\":                        {\"rob\"},\n\t\t\"pB.B.Extra\":                     {\"hello\"},\n\t\t\"priv.private\":                   {\"123\"},\n\t\t\"arrC[0].ID\":                     {\"5\"},\n\t\t\"arrC[0].Name\":                   {\"rob\"},\n\t\t\"arrC[0].B.Extra\":                {\"foo\"},\n\t\t\"arrC[1].ID\":                     {\"8\"},\n\t\t\"arrC[1].Name\":                   {\"bill\"},\n\t\t\"m[a]\":                           {\"foo\"},\n\t\t\"m[b]\":                           {\"bar\"},\n\t\t\"m2[1]\":                          {\"foo\"},\n\t\t\"m2[2]\":                          {\"bar\"},\n\t\t\"m3[a]\":                          {\"1\"},\n\t\t\"m3[b]\":                          {\"2\"},\n\t\t\"m4[a].ID\":                       {\"1\"},\n\t\t\"m4[a].Name\":                     {\"foo\"},\n\t\t\"m4[b].ID\":                       {\"2\"},\n\t\t\"m4[b].Name\":                     {\"bar\"},\n\t\t\"mapWithAMuchLongerName[a].ID\":   {\"1\"},\n\t\t\"mapWithAMuchLongerName[a].Name\": {\"foo\"},\n\t\t\"mapWithAMuchLongerName[b].ID\":   {\"2\"},\n\t\t\"mapWithAMuchLongerName[b].Name\": {\"bar\"},\n\t\t\"invalidInt\":                     {\"xyz\"},\n\t\t\"invalidInt2\":                    {\"\"},\n\t\t\"invalidBool\":                    {\"xyz\"},\n\t\t\"invalidArr\":                     {\"xyz\"},\n\t\t\"int8-overflow\":                  {\"1024\"},\n\t\t\"uint8-overflow\":                 {\"1024\"},\n\t\t\"arrDoS[2]\":                      {\"2\"},\n\t\t\"arrDoS[65535]\":                  {\"65535\"},\n\t}\n\n\ttestDate     = time.Date(1982, time.July, 9, 0, 0, 0, 0, time.UTC)\n\ttestDatetime = time.Date(1982, time.July, 9, 21, 30, 0, 0, time.UTC)\n)\n\nvar binderTestCases = map[string]interface{}{\n\t\"int\":        1,\n\t\"int8\":       int8(1),\n\t\"int16\":      int16(1),\n\t\"int32\":      int32(1),\n\t\"int64\":      int64(1),\n\t\"uint\":       1,\n\t\"uint8\":      uint8(1),\n\t\"uint16\":     uint16(1),\n\t\"uint32\":     uint32(1),\n\t\"uint64\":     uint64(1),\n\t\"float32\":    float32(1.0),\n\t\"float64\":    float64(1.0),\n\t\"str\":        \"hello\",\n\t\"bool-true\":  true,\n\t\"bool-1\":     true,\n\t\"bool-on\":    true,\n\t\"bool-false\": false,\n\t\"bool-0\":     false,\n\t\"bool-0.0\":   false,\n\t\"bool-off\":   false,\n\t\"bool-f\":     false,\n\t\"date\":       testDate,\n\t\"datetime\":   testDatetime,\n\t\"customDate\": testDate,\n\t\"arr\":        []int{1, 2, 0, 3},\n\t\"uarr\":       []int{1, 2},\n\t\"arruarr\":    [][]int{{1, 2}, {3, 4}},\n\t\"2darr\":      [][]int{{0, 1}, {10, 11}},\n\t\"A\":          A{ID: 123, Name: \"rob\"},\n\t\"B\":          A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"pB\":         &A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"arrC\": []A{\n\t\t{\n\t\t\tID:   5,\n\t\t\tName: \"rob\",\n\t\t\tB:    B{\"foo\"},\n\t\t},\n\t\t{\n\t\t\tID:   8,\n\t\t\tName: \"bill\",\n\t\t},\n\t},\n\t\"m\":  map[string]string{\"a\": \"foo\", \"b\": \"bar\"},\n\t\"m2\": map[int]string{1: \"foo\", 2: \"bar\"},\n\t\"m3\": map[string]int{\"a\": 1, \"b\": 2},\n\t\"m4\": map[string]A{\"a\": {ID: 1, Name: \"foo\"}, \"b\": {ID: 2, Name: \"bar\"}},\n\n\t// NOTE: We also include a map with a longer name than the others since this has caused problems\n\t// described in github issue #1285, resolved in pull request #1344. This test case should\n\t// prevent regression.\n\t\"mapWithAMuchLongerName\": map[string]A{\"a\": {ID: 1, Name: \"foo\"}, \"b\": {ID: 2, Name: \"bar\"}},\n\n\t// TODO: Tests that use TypeBinders\n\n\t// Invalid value tests (the result should always be the zero value for that type)\n\t// The point of these is to ensure that invalid user input does not cause panics.\n\t\"invalidInt\":     0,\n\t\"invalidInt2\":    0,\n\t\"invalidBool\":    true,\n\t\"invalidArr\":     []int{},\n\t\"priv\":           A{},\n\t\"int8-overflow\":  int8(0),\n\t\"uint8-overflow\": uint8(0),\n\t\"arrDoS\":         []int{0, 0, 2},\n}\n\n// Types that files may be bound to, and a func that can read the content from\n// that type.\n// TODO: Is there any way to create a slice, given only the element Type?\nvar fileBindings = []struct{ val, arrval, f interface{} }{\n\t{(**os.File)(nil), []*os.File{}, ioutil.ReadAll},\n\t{(*[]byte)(nil), [][]byte{}, func(b []byte) []byte { return b }},\n\t{(*io.Reader)(nil), []io.Reader{}, ioutil.ReadAll},\n\t{(*io.ReadSeeker)(nil), []io.ReadSeeker{}, ioutil.ReadAll},\n}\n\nfunc TestJsonBinder(t *testing.T) {\n\t// create a structure to be populated\n\t{\n\t\td, _ := json.Marshal(map[string]int{\"a\": 1})\n\t\tparams := &Params{JSON: d}\n\t\tfoo := struct{ A int }{}\n\t\tc := NewTestController(nil, getMultipartRequest())\n\n\t\tParseParams(params, NewRequest(c.Request.In))\n\t\tactual := Bind(params, \"test\", reflect.TypeOf(foo))\n\t\tvalEq(t, \"TestJsonBinder\", reflect.ValueOf(actual.Interface().(struct{ A int }).A), reflect.ValueOf(1))\n\t}\n\t{\n\t\td, _ := json.Marshal(map[string]interface{}{\"a\": map[string]int{\"b\": 45}})\n\t\tparams := &Params{JSON: d}\n\t\ttestMap := map[string]interface{}{}\n\t\tactual := Bind(params, \"test\", reflect.TypeOf(testMap)).Interface().(map[string]interface{})\n\t\tif actual[\"a\"].(map[string]interface{})[\"b\"].(float64) != 45 {\n\t\t\tt.Errorf(\"Failed to fetch map value %#v\", actual[\"a\"])\n\t\t}\n\t\t// Check to see if a named map works\n\t\tactualb := Bind(params, \"test\", reflect.TypeOf(map[string]map[string]float64{})).Interface().(map[string]map[string]float64)\n\t\tif actualb[\"a\"][\"b\"] != 45 {\n\t\t\tt.Errorf(\"Failed to fetch map value %#v\", actual[\"a\"])\n\t\t}\n\t}\n}\n\nfunc TestBinder(t *testing.T) {\n\t// Reuse the mvc_test.go multipart request to test the binder.\n\tparams := &Params{}\n\tc := NewTestController(nil, getMultipartRequest())\n\tif Config == nil {\n\t\tConfig = config.NewContext()\n\t\tdefer func() {\n\t\t\tConfig = nil\n\t\t}()\n\t}\n\tParseParams(params, NewRequest(c.Request.In))\n\tparams.Values = ParamTestValues\n\n\t// Values\n\tfor k, v := range binderTestCases {\n\t\tactual := Bind(params, k, reflect.TypeOf(v))\n\t\texpected := reflect.ValueOf(v)\n\t\tvalEq(t, k, actual, expected)\n\t}\n\n\t// Files\n\n\t// Get the keys in sorted order to make the expectation right.\n\tkeys := []string{}\n\tfor k := range expectedFiles {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\texpectedBoundFiles := make(map[string][]fh)\n\tfor _, k := range keys {\n\t\tfhs := expectedFiles[k]\n\t\tk := nextKey(k)\n\t\texpectedBoundFiles[k] = append(expectedBoundFiles[k], fhs...)\n\t}\n\n\tfor k, fhs := range expectedBoundFiles {\n\t\tif len(fhs) == 1 {\n\t\t\t// Test binding single files to: *os.File, []byte, io.Reader, io.ReadSeeker\n\t\t\tfor _, binding := range fileBindings {\n\t\t\t\ttyp := reflect.TypeOf(binding.val).Elem()\n\t\t\t\tactual := Bind(params, k, typ)\n\t\t\t\tif !actual.IsValid() || (actual.Kind() == reflect.Interface && actual.IsNil()) {\n\t\t\t\t\tt.Errorf(\"%s (%s) - Returned nil.\", k, typ)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturns := reflect.ValueOf(binding.f).Call([]reflect.Value{actual})\n\t\t\t\tvalEq(t, k, returns[0], reflect.ValueOf(fhs[0].content))\n\t\t\t}\n\t\t} else {\n\t\t\t// Test binding multi to:\n\t\t\t// []*os.File, [][]byte, []io.Reader, []io.ReadSeeker\n\t\t\tfor _, binding := range fileBindings {\n\t\t\t\ttyp := reflect.TypeOf(binding.arrval)\n\t\t\t\tactual := Bind(params, k, typ)\n\t\t\t\tif actual.Len() != len(fhs) {\n\t\t\t\t\tt.Fatalf(\"%s (%s) - Number of files: (expected) %d != %d (actual)\",\n\t\t\t\t\t\tk, typ, len(fhs), actual.Len())\n\t\t\t\t}\n\t\t\t\tfor i := range fhs {\n\t\t\t\t\treturns := reflect.ValueOf(binding.f).Call([]reflect.Value{actual.Index(i)})\n\t\t\t\t\tif !returns[0].IsValid() {\n\t\t\t\t\t\tt.Errorf(\"%s (%s) - Returned nil.\", k, typ)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tvalEq(t, k, returns[0], reflect.ValueOf(fhs[i].content))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Unbinding tests\n\nvar unbinderTestCases = map[string]interface{}{\n\t\"int\":        1,\n\t\"int8\":       int8(1),\n\t\"int16\":      int16(1),\n\t\"int32\":      int32(1),\n\t\"int64\":      int64(1),\n\t\"uint\":       1,\n\t\"uint8\":      uint8(1),\n\t\"uint16\":     uint16(1),\n\t\"uint32\":     uint32(1),\n\t\"uint64\":     uint64(1),\n\t\"float32\":    float32(1.0),\n\t\"float64\":    float64(1.0),\n\t\"str\":        \"hello\",\n\t\"bool-true\":  true,\n\t\"bool-false\": false,\n\t\"date\":       testDate,\n\t\"datetime\":   testDatetime,\n\t\"arr\":        []int{1, 2, 0, 3},\n\t\"2darr\":      [][]int{{0, 1}, {10, 11}},\n\t\"A\":          A{ID: 123, Name: \"rob\"},\n\t\"B\":          A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"pB\":         &A{ID: 123, Name: \"rob\", B: B{Extra: \"hello\"}},\n\t\"arrC\": []A{\n\t\t{\n\t\t\tID:   5,\n\t\t\tName: \"rob\",\n\t\t\tB:    B{\"foo\"},\n\t\t},\n\t\t{\n\t\t\tID:   8,\n\t\t\tName: \"bill\",\n\t\t},\n\t},\n\t\"m\":  map[string]string{\"a\": \"foo\", \"b\": \"bar\"},\n\t\"m2\": map[int]string{1: \"foo\", 2: \"bar\"},\n\t\"m3\": map[string]int{\"a\": 1, \"b\": 2},\n}\n\n// Some of the unbinding results are not exactly what is in ParamTestValues, since it\n// serializes implicit zero values explicitly.\nvar unbinderOverrideAnswers = map[string]map[string]string{\n\t\"arr\": {\n\t\t\"arr[0]\": \"1\",\n\t\t\"arr[1]\": \"2\",\n\t\t\"arr[2]\": \"0\",\n\t\t\"arr[3]\": \"3\",\n\t},\n\t\"A\": {\n\t\t\"A.ID\":      \"123\",\n\t\t\"A.Name\":    \"rob\",\n\t\t\"A.B.Extra\": \"\",\n\t},\n\t\"arrC\": {\n\t\t\"arrC[0].ID\":      \"5\",\n\t\t\"arrC[0].Name\":    \"rob\",\n\t\t\"arrC[0].B.Extra\": \"foo\",\n\t\t\"arrC[1].ID\":      \"8\",\n\t\t\"arrC[1].Name\":    \"bill\",\n\t\t\"arrC[1].B.Extra\": \"\",\n\t},\n\t\"m\":  {\"m[a]\": \"foo\", \"m[b]\": \"bar\"},\n\t\"m2\": {\"m2[1]\": \"foo\", \"m2[2]\": \"bar\"},\n\t\"m3\": {\"m3[a]\": \"1\", \"m3[b]\": \"2\"},\n}\n\nfunc TestUnbinder(t *testing.T) {\n\tfor k, v := range unbinderTestCases {\n\t\tactual := make(map[string]string)\n\t\tUnbind(actual, k, v)\n\n\t\t// Get the expected key/values.\n\t\texpected, ok := unbinderOverrideAnswers[k]\n\t\tif !ok {\n\t\t\texpected = make(map[string]string)\n\t\t\tfor k2, v2 := range ParamTestValues {\n\t\t\t\tif k == k2 || strings.HasPrefix(k2, k+\".\") || strings.HasPrefix(k2, k+\"[\") {\n\t\t\t\t\texpected[k2] = v2[0]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Compare length and values.\n\t\tif len(actual) != len(expected) {\n\t\t\tt.Errorf(\"Length mismatch\\nExpected length %d, actual %d\\nExpected: %s\\nActual: %s\",\n\t\t\t\tlen(expected), len(actual), expected, actual)\n\t\t}\n\t\tfor k, v := range actual {\n\t\t\tif expected[k] != v {\n\t\t\t\tt.Errorf(\"Value mismatch.\\nExpected: %s\\nActual: %s\", expected, actual)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helpers\n\nfunc valEq(t *testing.T, name string, actual, expected reflect.Value) {\n\tswitch expected.Kind() {\n\tcase reflect.Slice:\n\t\t// Check the type/length/element type\n\t\tif !eq(t, name+\" (type)\", actual.Kind(), expected.Kind()) ||\n\t\t\t!eq(t, name+\" (len)\", actual.Len(), expected.Len()) ||\n\t\t\t!eq(t, name+\" (elem)\", actual.Type().Elem(), expected.Type().Elem()) {\n\t\t\treturn\n\t\t}\n\n\t\t// Check value equality for each element.\n\t\tfor i := 0; i < actual.Len(); i++ {\n\t\t\tvalEq(t, fmt.Sprintf(\"%s[%d]\", name, i), actual.Index(i), expected.Index(i))\n\t\t}\n\n\tcase reflect.Ptr:\n\t\t// Check equality on the element type.\n\t\tvalEq(t, name, actual.Elem(), expected.Elem())\n\tcase reflect.Map:\n\t\tif !eq(t, name+\" (len)\", actual.Len(), expected.Len()) {\n\t\t\treturn\n\t\t}\n\t\tfor _, key := range expected.MapKeys() {\n\t\t\texpectedValue := expected.MapIndex(key)\n\t\t\tactualValue := actual.MapIndex(key)\n\t\t\tif actualValue.IsValid() {\n\t\t\t\tvalEq(t, fmt.Sprintf(\"%s[%s]\", name, key), actualValue, expectedValue)\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"Expected key %s not found\", key)\n\t\t\t}\n\t\t}\n\tdefault:\n\t\teq(t, name, actual.Interface(), expected.Interface())\n\t}\n}\n\nfunc init() {\n\tDateFormat = DefaultDateFormat\n\tDateTimeFormat = DefaultDateTimeFormat\n\tTimeFormats = append(TimeFormats, DefaultDateFormat, DefaultDateTimeFormat, \"01/02/2006\")\n}\n"
        },
        {
          "name": "cache",
          "type": "tree",
          "content": null
        },
        {
          "name": "compress.go",
          "type": "blob",
          "size": 9.7802734375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"compress/gzip\"\n\t\"compress/zlib\"\n\t\"io\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar compressionTypes = [...]string{\n\t\"gzip\",\n\t\"deflate\",\n}\n\nvar compressableMimes = [...]string{\n\t\"text/plain\",\n\t\"text/csv\",\n\t\"text/html\",\n\t\"text/xml\",\n\t\"text/css\",\n\t\"application/json\",\n\t\"application/xml\",\n\t\"application/xhtml+xml\",\n\t\"application/rss+xml\",\n\t\"application/javascript\",\n\t\"application/x-javascript\",\n}\n\n// Local log instance for this class.\nvar compressLog = RevelLog.New(\"section\", \"compress\")\n\n// WriteFlusher interface for compress writer.\ntype WriteFlusher interface {\n\tio.Writer     // An IO Writer\n\tio.Closer     // A closure\n\tFlush() error /// A flush function\n}\n\n// The compressed writer.\ntype CompressResponseWriter struct {\n\tHeader             *BufferedServerHeader // The header\n\tControllerResponse *Response             // The response\n\tOriginalWriter     io.Writer             // The writer\n\tcompressWriter     WriteFlusher          // The flushed writer\n\tcompressionType    string                // The compression type\n\theadersWritten     bool                  // True if written\n\tcloseNotify        chan bool             // The notify channel to close\n\tparentNotify       <-chan bool           // The parent chanel to receive the closed event\n\tclosed             bool                  // True if closed\n}\n\n// CompressFilter does compression of response body in gzip/deflate if\n// `results.compressed=true` in the app.conf.\nfunc CompressFilter(c *Controller, fc []Filter) {\n\tif c.Response.Out.internalHeader.Server != nil && Config.BoolDefault(\"results.compressed\", false) {\n\t\tif c.Response.Status != http.StatusNoContent && c.Response.Status != http.StatusNotModified {\n\t\t\tif found, compressType, compressWriter := detectCompressionType(c.Request, c.Response); found {\n\t\t\t\twriter := CompressResponseWriter{\n\t\t\t\t\tControllerResponse: c.Response,\n\t\t\t\t\tOriginalWriter:     c.Response.GetWriter(),\n\t\t\t\t\tcompressWriter:     compressWriter,\n\t\t\t\t\tcompressionType:    compressType,\n\t\t\t\t\theadersWritten:     false,\n\t\t\t\t\tcloseNotify:        make(chan bool, 1),\n\t\t\t\t\tclosed:             false,\n\t\t\t\t}\n\t\t\t\t// Swap out the header with our own\n\t\t\t\twriter.Header = NewBufferedServerHeader(c.Response.Out.internalHeader.Server)\n\t\t\t\tc.Response.Out.internalHeader.Server = writer.Header\n\t\t\t\tif w, ok := c.Response.GetWriter().(http.CloseNotifier); ok {\n\t\t\t\t\twriter.parentNotify = w.CloseNotify()\n\t\t\t\t}\n\t\t\t\tc.Response.SetWriter(&writer)\n\t\t\t}\n\t\t} else {\n\t\t\tcompressLog.Debug(\"CompressFilter: Compression disabled for response \", \"status\", c.Response.Status)\n\t\t}\n\t}\n\tfc[0](c, fc[1:])\n}\n\n// Called to notify the writer is closing.\nfunc (c CompressResponseWriter) CloseNotify() <-chan bool {\n\tif c.parentNotify != nil {\n\t\treturn c.parentNotify\n\t}\n\treturn c.closeNotify\n}\n\n// Prepare the headers.\nfunc (c *CompressResponseWriter) prepareHeaders() {\n\tif c.compressionType != \"\" {\n\t\tresponseMime := \"\"\n\t\tif t := c.Header.Get(\"Content-Type\"); len(t) > 0 {\n\t\t\tresponseMime = t[0]\n\t\t}\n\t\tresponseMime = strings.TrimSpace(strings.SplitN(responseMime, \";\", 2)[0])\n\t\tshouldEncode := false\n\n\t\tif len(c.Header.Get(\"Content-Encoding\")) == 0 {\n\t\t\tfor _, compressableMime := range compressableMimes {\n\t\t\t\tif responseMime == compressableMime {\n\t\t\t\t\tshouldEncode = true\n\t\t\t\t\tc.Header.Set(\"Content-Encoding\", c.compressionType)\n\t\t\t\t\tc.Header.Del(\"Content-Length\")\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !shouldEncode {\n\t\t\tc.compressWriter = nil\n\t\t\tc.compressionType = \"\"\n\t\t}\n\t}\n\tc.Header.Release()\n}\n\n// Write the headers.\nfunc (c *CompressResponseWriter) WriteHeader(status int) {\n\tif c.closed {\n\t\treturn\n\t}\n\tc.headersWritten = true\n\tc.prepareHeaders()\n\tc.Header.SetStatus(status)\n}\n\n// Close the writer.\nfunc (c *CompressResponseWriter) Close() error {\n\tif c.closed {\n\t\treturn nil\n\t}\n\tif !c.headersWritten {\n\t\tc.prepareHeaders()\n\t}\n\tif c.compressionType != \"\" {\n\t\tc.Header.Del(\"Content-Length\")\n\t\tif err := c.compressWriter.Close(); err != nil {\n\t\t\t// TODO When writing directly to stream, an error will be generated\n\t\t\tcompressLog.Error(\"Close: Error closing compress writer\", \"type\", c.compressionType, \"error\", err)\n\t\t}\n\t}\n\t// Non-blocking write to the closenotifier, if we for some reason should\n\t// get called multiple times\n\tselect {\n\tcase c.closeNotify <- true:\n\tdefault:\n\t}\n\tc.closed = true\n\treturn nil\n}\n\n// Write to the underling buffer.\nfunc (c *CompressResponseWriter) Write(b []byte) (int, error) {\n\tif c.closed {\n\t\treturn 0, io.ErrClosedPipe\n\t}\n\t// Abort if parent has been closed\n\tif c.parentNotify != nil {\n\t\tselect {\n\t\tcase <-c.parentNotify:\n\t\t\treturn 0, io.ErrClosedPipe\n\t\tdefault:\n\t\t}\n\t}\n\t// Abort if we ourselves have been closed\n\tif c.closed {\n\t\treturn 0, io.ErrClosedPipe\n\t}\n\n\tif !c.headersWritten {\n\t\tc.prepareHeaders()\n\t\tc.headersWritten = true\n\t}\n\tif c.compressionType != \"\" {\n\t\treturn c.compressWriter.Write(b)\n\t}\n\treturn c.OriginalWriter.Write(b)\n}\n\n// DetectCompressionType method detects the compression type\n// from header \"Accept-Encoding\".\nfunc detectCompressionType(req *Request, resp *Response) (found bool, compressionType string, compressionKind WriteFlusher) {\n\tif Config.BoolDefault(\"results.compressed\", false) {\n\t\tacceptedEncodings := strings.Split(req.GetHttpHeader(\"Accept-Encoding\"), \",\")\n\n\t\tlargestQ := 0.0\n\t\tchosenEncoding := len(compressionTypes)\n\n\t\t// I have fixed one edge case for issue #914\n\t\t// But it's better to cover all possible edge cases or\n\t\t// Adapt to https://github.com/golang/gddo/blob/master/httputil/header/header.go#L172\n\t\tfor _, encoding := range acceptedEncodings {\n\t\t\tencoding = strings.TrimSpace(encoding)\n\t\t\tencodingParts := strings.SplitN(encoding, \";\", 2)\n\n\t\t\t// If we are the format \"gzip;q=0.8\"\n\t\t\tif len(encodingParts) > 1 {\n\t\t\t\tq := strings.TrimSpace(encodingParts[1])\n\t\t\t\tif len(q) == 0 || !strings.HasPrefix(q, \"q=\") {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Strip off the q=\n\t\t\t\tnum, err := strconv.ParseFloat(q[2:], 32)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif num >= largestQ && num > 0 {\n\t\t\t\t\tif encodingParts[0] == \"*\" {\n\t\t\t\t\t\tchosenEncoding = 0\n\t\t\t\t\t\tlargestQ = num\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tfor i, encoding := range compressionTypes {\n\t\t\t\t\t\tif encoding == encodingParts[0] {\n\t\t\t\t\t\t\tif i < chosenEncoding {\n\t\t\t\t\t\t\t\tlargestQ = num\n\t\t\t\t\t\t\t\tchosenEncoding = i\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we can accept anything, chose our preferred method.\n\t\t\t\tif encodingParts[0] == \"*\" {\n\t\t\t\t\tchosenEncoding = 0\n\t\t\t\t\tlargestQ = 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\t// This is for just plain \"gzip\"\n\t\t\t\tfor i, encoding := range compressionTypes {\n\t\t\t\t\tif encoding == encodingParts[0] {\n\t\t\t\t\t\tif i < chosenEncoding {\n\t\t\t\t\t\t\tlargestQ = 1.0\n\t\t\t\t\t\t\tchosenEncoding = i\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif largestQ == 0 {\n\t\t\treturn\n\t\t}\n\n\t\tcompressionType = compressionTypes[chosenEncoding]\n\n\t\tswitch compressionType {\n\t\tcase \"gzip\":\n\t\t\tcompressionKind = gzip.NewWriter(resp.GetWriter())\n\t\t\tfound = true\n\t\tcase \"deflate\":\n\t\t\tcompressionKind = zlib.NewWriter(resp.GetWriter())\n\t\t\tfound = true\n\t\t}\n\t}\n\treturn\n}\n\n// BufferedServerHeader will not send content out until the Released is called, from that point on it will act normally\n// It implements all the ServerHeader.\ntype BufferedServerHeader struct {\n\tcookieList []string            // The cookie list\n\theaderMap  map[string][]string // The header map\n\tstatus     int                 // The status\n\treleased   bool                // True if released\n\toriginal   ServerHeader        // The original header\n}\n\n// Creates a new instance based on the ServerHeader.\nfunc NewBufferedServerHeader(o ServerHeader) *BufferedServerHeader {\n\treturn &BufferedServerHeader{original: o, headerMap: map[string][]string{}}\n}\n\n// Sets the cookie.\nfunc (bsh *BufferedServerHeader) SetCookie(cookie string) {\n\tif bsh.released {\n\t\tbsh.original.SetCookie(cookie)\n\t} else {\n\t\tbsh.cookieList = append(bsh.cookieList, cookie)\n\t}\n}\n\n// Returns a cookie.\nfunc (bsh *BufferedServerHeader) GetCookie(key string) (ServerCookie, error) {\n\treturn bsh.original.GetCookie(key)\n}\n\n// Sets (replace) the header key.\nfunc (bsh *BufferedServerHeader) Set(key string, value string) {\n\tif bsh.released {\n\t\tbsh.original.Set(key, value)\n\t} else {\n\t\tbsh.headerMap[key] = []string{value}\n\t}\n}\n\n// Add (append) to a key this value.\nfunc (bsh *BufferedServerHeader) Add(key string, value string) {\n\tif bsh.released {\n\t\tbsh.original.Set(key, value)\n\t} else {\n\t\told := []string{}\n\t\tif v, found := bsh.headerMap[key]; found {\n\t\t\told = v\n\t\t}\n\t\tbsh.headerMap[key] = append(old, value)\n\t}\n}\n\n// Delete this key.\nfunc (bsh *BufferedServerHeader) Del(key string) {\n\tif bsh.released {\n\t\tbsh.original.Del(key)\n\t} else {\n\t\tdelete(bsh.headerMap, key)\n\t}\n}\n\n// Get this key.\nfunc (bsh *BufferedServerHeader) Get(key string) (value []string) {\n\tif bsh.released {\n\t\tvalue = bsh.original.Get(key)\n\t} else {\n\t\tif v, found := bsh.headerMap[key]; found && len(v) > 0 {\n\t\t\tvalue = v\n\t\t} else {\n\t\t\tvalue = bsh.original.Get(key)\n\t\t}\n\t}\n\treturn\n}\n\n// Get all header keys.\nfunc (bsh *BufferedServerHeader) GetKeys() (value []string) {\n\tif bsh.released {\n\t\tvalue = bsh.original.GetKeys()\n\t} else {\n\t\tvalue = bsh.original.GetKeys()\n\t\tfor key := range bsh.headerMap {\n\t\t\tfound := false\n\t\t\tfor _, v := range value {\n\t\t\t\tif v == key {\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\tvalue = append(value, key)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\n// Set the status.\nfunc (bsh *BufferedServerHeader) SetStatus(statusCode int) {\n\tif bsh.released {\n\t\tbsh.original.SetStatus(statusCode)\n\t} else {\n\t\tbsh.status = statusCode\n\t}\n}\n\n// Release the header and push the results to the original.\nfunc (bsh *BufferedServerHeader) Release() {\n\tbsh.released = true\n\tfor k, v := range bsh.headerMap {\n\t\tfor _, r := range v {\n\t\t\tbsh.original.Set(k, r)\n\t\t}\n\t}\n\tfor _, c := range bsh.cookieList {\n\t\tbsh.original.SetCookie(c)\n\t}\n\tif bsh.status > 0 {\n\t\tbsh.original.SetStatus(bsh.status)\n\t}\n}\n"
        },
        {
          "name": "compress_test.go",
          "type": "blob",
          "size": 1.62890625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// Test that the render response is as expected.\nfunc TestBenchmarkCompressed(t *testing.T) {\n\tstartFakeBookingApp()\n\tresp := httptest.NewRecorder()\n\tc := NewTestController(resp, showRequest)\n\tif err := c.SetAction(\"Hotels\", \"Show\"); err != nil {\n\t\tt.Errorf(\"SetAction failed: %s\", err)\n\t}\n\tConfig.SetOption(\"results.compressed\", \"true\")\n\tresult := Hotels{c}.Show(3)\n\tresult.Apply(c.Request, c.Response)\n\tif !strings.Contains(resp.Body.String(), \"300 Main St.\") {\n\t\tt.Errorf(\"Failed to find hotel address in action response:\\n%s\", resp.Body)\n\t}\n}\n\nfunc BenchmarkRenderCompressed(b *testing.B) {\n\tstartFakeBookingApp()\n\tresp := httptest.NewRecorder()\n\tresp.Body = nil\n\tc := NewTestController(resp, showRequest)\n\tif err := c.SetAction(\"Hotels\", \"Show\"); err != nil {\n\t\tb.Errorf(\"SetAction failed: %s\", err)\n\t}\n\tConfig.SetOption(\"results.compressed\", \"true\")\n\tb.ResetTimer()\n\n\thotels := Hotels{c}\n\tfor i := 0; i < b.N; i++ {\n\t\thotels.Show(3).Apply(c.Request, c.Response)\n\t}\n}\n\nfunc BenchmarkRenderUnCompressed(b *testing.B) {\n\tstartFakeBookingApp()\n\tresp := httptest.NewRecorder()\n\tresp.Body = nil\n\tc := NewTestController(resp, showRequest)\n\tif err := c.SetAction(\"Hotels\", \"Show\"); err != nil {\n\t\tb.Errorf(\"SetAction failed: %s\", err)\n\t}\n\tConfig.SetOption(\"results.compressed\", \"false\")\n\tb.ResetTimer()\n\n\thotels := Hotels{c}\n\tfor i := 0; i < b.N; i++ {\n\t\thotels.Show(3).Apply(c.Request, c.Response)\n\t}\n}\n"
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "controller.go",
          "type": "blob",
          "size": 17.0927734375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/revel/revel/logger\"\n\t\"github.com/revel/revel/session\"\n\t\"github.com/revel/revel/utils\"\n)\n\n// Controller Revel's controller structure that gets embedded in user defined\n// controllers.\ntype Controller struct {\n\tName          string          // The controller name, e.g. \"Application\"\n\tType          *ControllerType // A description of the controller type.\n\tMethodName    string          // The method name, e.g. \"Index\"\n\tMethodType    *MethodType     // A description of the invoked action type.\n\tAppController interface{}     // The controller that was instantiated. embeds revel.Controller\n\tAction        string          // The fully qualified action name, e.g. \"App.Index\"\n\tClientIP      string          // holds IP address of request came from\n\n\tRequest  *Request\n\tResponse *Response\n\tResult   Result\n\n\tFlash      Flash                  // User cookie, cleared after 1 request.\n\tSession    session.Session        // Session, stored using the session engine specified\n\tParams     *Params                // Parameters from URL and form (including multipart).\n\tArgs       map[string]interface{} // Per-request scratch space.\n\tViewArgs   map[string]interface{} // Variables passed to the template.\n\tValidation *Validation            // Data validation helpers\n\tLog        logger.MultiLogger     // Context Logger\n}\n\n// The map of controllers, controllers are mapped by using the namespace|controller_name as the key.\nvar (\n\tcontrollers   = make(map[string]*ControllerType)\n\tcontrollerLog = RevelLog.New(\"section\", \"controller\")\n)\n\n// NewController returns new controller instance for Request and Response.\nfunc NewControllerEmpty() *Controller {\n\treturn &Controller{Request: NewRequest(nil), Response: NewResponse(nil)}\n}\n\n// New controller, creates a new instance wrapping the request and response in it.\nfunc NewController(context ServerContext) *Controller {\n\tc := NewControllerEmpty()\n\tc.SetController(context)\n\treturn c\n}\n\n// Sets the request and the response for the controller.\nfunc (c *Controller) SetController(context ServerContext) {\n\tc.Request.SetRequest(context.GetRequest())\n\tc.Response.SetResponse(context.GetResponse())\n\tc.Request.controller = c\n\tc.Params = new(Params)\n\tc.Args = map[string]interface{}{}\n\tc.ViewArgs = map[string]interface{}{\n\t\t\"RunMode\": RunMode,\n\t\t\"DevMode\": DevMode,\n\t}\n}\n\nfunc (c *Controller) Destroy() {\n\t// When the instantiated controller gets injected\n\t// It inherits this method, so we need to\n\t// check to see if the controller is nil before performing\n\t// any actions\n\tif c == nil {\n\t\treturn\n\t}\n\tif c.AppController != nil {\n\t\tc.resetAppControllerFields()\n\t\t// Return this instance to the pool\n\t\tappController := c.AppController\n\t\tc.AppController = nil\n\t\tif RevelConfig.Controller.Reuse {\n\t\t\tRevelConfig.Controller.CachedMap[c.Name].Push(appController)\n\t\t}\n\t}\n\n\tc.Request.Destroy()\n\tc.Response.Destroy()\n\tc.Params = nil\n\tc.Args = nil\n\tc.ViewArgs = nil\n\tc.Name = \"\"\n\tc.Type = nil\n\tc.MethodName = \"\"\n\tc.MethodType = nil\n\tc.Action = \"\"\n\tc.ClientIP = \"\"\n\tc.Result = nil\n\tc.Flash = Flash{}\n\tc.Session = session.NewSession()\n\tc.Params = nil\n\tc.Validation = nil\n\tc.Log = nil\n}\n\n// FlashParams serializes the contents of Controller.Params to the Flash\n// cookie.\nfunc (c *Controller) FlashParams() {\n\tfor key, vals := range c.Params.Values {\n\t\tc.Flash.Out[key] = strings.Join(vals, \",\")\n\t}\n}\n\nfunc (c *Controller) SetCookie(cookie *http.Cookie) {\n\tc.Response.Out.internalHeader.SetCookie(cookie.String())\n}\n\ntype ErrorCoder interface {\n\tHTTPCode() int\n}\n\nfunc (c *Controller) RenderError(err error) Result {\n\tif coder, ok := err.(ErrorCoder); ok {\n\t\tc.setStatusIfNil(coder.HTTPCode())\n\t} else {\n\t\tc.setStatusIfNil(http.StatusInternalServerError)\n\t}\n\n\treturn ErrorResult{c.ViewArgs, err}\n}\n\nfunc (c *Controller) setStatusIfNil(status int) {\n\tif c.Response.Status == 0 {\n\t\tc.Response.Status = status\n\t}\n}\n\n// Render a template corresponding to the calling Controller method.\n// Arguments will be added to c.ViewArgs prior to rendering the template.\n// They are keyed on their local identifier.\n//\n// For example:\n//\n//     func (c Users) ShowUser(id int) revel.Result {\n//     \t user := loadUser(id)\n//     \t return c.Render(user)\n//     }\n//\n// This action will render views/Users/ShowUser.html, passing in an extra\n// key-value \"user\": (User).\n//\n// This is the slower magical version which uses the runtime\n// to determine\n// 1) Set c.ViewArgs to the arguments passed into this function\n// 2) How to call the RenderTemplate by building the following line\n// c.RenderTemplate(c.Name + \"/\" + c.MethodType.Name + \".\" + c.Request.Format)\n//\n// If you want your code to run faster it is recommended you add the template values directly\n// to the c.ViewArgs and call c.RenderTemplate directly.\nfunc (c *Controller) Render(extraViewArgs ...interface{}) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\t// Get the calling function line number.\n\t_, _, line, ok := runtime.Caller(1)\n\tif !ok {\n\t\tcontrollerLog.Error(\"Render: Failed to get Caller information\")\n\t}\n\n\t// Get the extra ViewArgs passed in.\n\tif renderArgNames, ok := c.MethodType.RenderArgNames[line]; ok {\n\t\tif len(renderArgNames) == len(extraViewArgs) {\n\t\t\tfor i, extraRenderArg := range extraViewArgs {\n\t\t\t\tc.ViewArgs[renderArgNames[i]] = extraRenderArg\n\t\t\t}\n\t\t} else {\n\t\t\tcontrollerLog.Error(fmt.Sprint(len(renderArgNames), \"RenderArg names found for\",\n\t\t\t\tlen(extraViewArgs), \"extra ViewArgs\"))\n\t\t}\n\t} else {\n\t\tcontrollerLog.Error(fmt.Sprint(\"No RenderArg names found for Render call on line\", line,\n\t\t\t\"(Action\", c.Action, \")\"), \"stack\", logger.NewCallStack())\n\t}\n\n\treturn c.RenderTemplate(c.Name + \"/\" + c.MethodType.Name + \".\" + c.Request.Format)\n}\n\n// RenderTemplate method does less magical way to render a template.\n// Renders the given template, using the current ViewArgs.\nfunc (c *Controller) RenderTemplate(templatePath string) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\t// Get the Template.\n\tlang, _ := c.ViewArgs[CurrentLocaleViewArg].(string)\n\ttemplate, err := MainTemplateLoader.TemplateLang(templatePath, lang)\n\tif err != nil {\n\t\treturn c.RenderError(err)\n\t}\n\n\treturn &RenderTemplateResult{\n\t\tTemplate: template,\n\t\tViewArgs: c.ViewArgs,\n\t}\n}\n\n// TemplateOutput returns the result of the template rendered using the controllers ViewArgs.\nfunc (c *Controller) TemplateOutput(templatePath string) (data []byte, err error) {\n\treturn TemplateOutputArgs(templatePath, c.ViewArgs)\n}\n\n// RenderJSON uses encoding/json.Marshal to return JSON to the client.\nfunc (c *Controller) RenderJSON(o interface{}) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\treturn RenderJSONResult{o, \"\"}\n}\n\n// RenderJSONP renders JSONP result using encoding/json.Marshal.\nfunc (c *Controller) RenderJSONP(callback string, o interface{}) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\treturn RenderJSONResult{o, callback}\n}\n\n// RenderXML uses encoding/xml.Marshal to return XML to the client.\nfunc (c *Controller) RenderXML(o interface{}) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\treturn RenderXMLResult{o}\n}\n\n// RenderText renders plaintext in response, printf style.\nfunc (c *Controller) RenderText(text string, objs ...interface{}) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\tfinalText := text\n\tif len(objs) > 0 {\n\t\tfinalText = fmt.Sprintf(text, objs...)\n\t}\n\treturn &RenderTextResult{finalText}\n}\n\n// RenderHTML renders html in response.\nfunc (c *Controller) RenderHTML(html string) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\treturn &RenderHTMLResult{html}\n}\n\n// Todo returns an HTTP 501 Not Implemented \"todo\" indicating that the\n// action isn't done yet.\nfunc (c *Controller) Todo() Result {\n\tc.Response.Status = http.StatusNotImplemented\n\tcontrollerLog.Debug(\"Todo: Not implemented function\", \"action\", c.Action)\n\treturn c.RenderError(&Error{\n\t\tTitle:       \"TODO\",\n\t\tDescription: \"This action is not implemented\",\n\t})\n}\n\n// NotFound returns an HTTP 404 Not Found response whose body is the\n// formatted string of msg and objs.\nfunc (c *Controller) NotFound(msg string, objs ...interface{}) Result {\n\tfinalText := msg\n\tif len(objs) > 0 {\n\t\tfinalText = fmt.Sprintf(msg, objs...)\n\t}\n\tc.Response.Status = http.StatusNotFound\n\treturn c.RenderError(&Error{\n\t\tTitle:       \"Not Found\",\n\t\tDescription: finalText,\n\t})\n}\n\n// Forbidden returns an HTTP 403 Forbidden response whose body is the\n// formatted string of msg and objs.\nfunc (c *Controller) Forbidden(msg string, objs ...interface{}) Result {\n\tfinalText := msg\n\tif len(objs) > 0 {\n\t\tfinalText = fmt.Sprintf(msg, objs...)\n\t}\n\tc.Response.Status = http.StatusForbidden\n\treturn c.RenderError(&Error{\n\t\tTitle:       \"Forbidden\",\n\t\tDescription: finalText,\n\t})\n}\n\n// RenderFileName returns a file indicated by the path as provided via the filename.\n// It can be either displayed inline or downloaded as an attachment.\n// The name and size are taken from the file info.\nfunc (c *Controller) RenderFileName(filename string, delivery ContentDisposition) Result {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\tc.Log.Errorf(\"Cant open file: %v\", err)\n\t\treturn c.RenderError(err)\n\t}\n\treturn c.RenderFile(f, delivery)\n}\n\n// RenderFile returns a file, either displayed inline or downloaded\n// as an attachment. The name and size are taken from the file info.\nfunc (c *Controller) RenderFile(file *os.File, delivery ContentDisposition) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\tvar (\n\t\tmodtime       = time.Now()\n\t\tfileInfo, err = file.Stat()\n\t)\n\tif err != nil {\n\t\tcontrollerLog.Error(\"RenderFile: error\", \"error\", err)\n\t}\n\tif fileInfo != nil {\n\t\tmodtime = fileInfo.ModTime()\n\t}\n\treturn c.RenderBinary(file, filepath.Base(file.Name()), delivery, modtime)\n}\n\n// RenderBinary is like RenderFile() except that it instead of a file on disk,\n// it renders data from memory (which could be a file that has not been written,\n// the output from some function, or bytes streamed from somewhere else, as long\n// it implements io.Reader).  When called directly on something generated or\n// streamed, modtime should mostly likely be time.Now().\nfunc (c *Controller) RenderBinary(memfile io.Reader, filename string, delivery ContentDisposition, modtime time.Time) Result {\n\tc.setStatusIfNil(http.StatusOK)\n\n\treturn &BinaryResult{\n\t\tReader:   memfile,\n\t\tName:     filename,\n\t\tDelivery: delivery,\n\t\tLength:   -1, // http.ServeContent gets the length itself unless memfile is a stream.\n\t\tModTime:  modtime,\n\t}\n}\n\n// Redirect to an action or to a URL.\n//   c.Redirect(Controller.Action)\n//   c.Redirect(\"/controller/action\")\n//   c.Redirect(\"/controller/%d/action\", id)\nfunc (c *Controller) Redirect(val interface{}, args ...interface{}) Result {\n\tc.setStatusIfNil(http.StatusFound)\n\n\tif url, ok := val.(string); ok {\n\t\tif len(args) == 0 {\n\t\t\treturn &RedirectToURLResult{url}\n\t\t}\n\t\treturn &RedirectToURLResult{fmt.Sprintf(url, args...)}\n\t}\n\treturn &RedirectToActionResult{val, args}\n}\n\n// This stats returns some interesting stats based on what is cached in memory\n// and what is available directly.\nfunc (c *Controller) Stats() map[string]interface{} {\n\tresult := CurrentEngine.Stats()\n\tif RevelConfig.Controller.Reuse {\n\t\tresult[\"revel-controllers\"] = RevelConfig.Controller.Stack.String()\n\t\tfor key, appStack := range RevelConfig.Controller.CachedMap {\n\t\t\tresult[\"app-\"+key] = appStack.String()\n\t\t}\n\t}\n\treturn result\n}\n\n// Message performs a lookup for the given message name using the given\n// arguments using the current language defined for this controller.\n//\n// The current language is set by the i18n plugin.\nfunc (c *Controller) Message(message string, args ...interface{}) string {\n\treturn MessageFunc(c.Request.Locale, message, args...)\n}\n\n// SetAction sets the action that is being invoked in the current request.\n// It sets the following properties: Name, Action, Type, MethodType.\nfunc (c *Controller) SetAction(controllerName, methodName string) error {\n\treturn c.SetTypeAction(controllerName, methodName, nil)\n}\n\n// SetAction sets the assigns the Controller type, sets the action and initializes the controller.\nfunc (c *Controller) SetTypeAction(controllerName, methodName string, typeOfController *ControllerType) error {\n\t// Look up the controller and method types.\n\tif typeOfController == nil {\n\t\tif c.Type = ControllerTypeByName(controllerName, anyModule); c.Type == nil {\n\t\t\treturn errors.New(\"revel/controller: failed to find controller \" + controllerName)\n\t\t}\n\t} else {\n\t\tc.Type = typeOfController\n\t}\n\n\t// Note method name is case insensitive search\n\tif c.MethodType = c.Type.Method(methodName); c.MethodType == nil {\n\t\treturn errors.New(\"revel/controller: failed to find action \" + controllerName + \".\" + methodName)\n\t}\n\n\tc.Name, c.MethodName = c.Type.Type.Name(), c.MethodType.Name\n\tc.Action = c.Name + \".\" + c.MethodName\n\n\t// Update Logger with controller and namespace\n\tif c.Log != nil {\n\t\tc.Log = c.Log.New(\"action\", c.Action, \"namespace\", c.Type.Namespace)\n\t}\n\n\tif RevelConfig.Controller.Reuse {\n\t\tif _, ok := RevelConfig.Controller.CachedMap[c.Name]; !ok {\n\t\t\t// Create a new stack for this controller\n\t\t\tlocalType := c.Type.Type\n\t\t\tRevelConfig.Controller.CachedMap[c.Name] = utils.NewStackLock(\n\t\t\t\tRevelConfig.Controller.CachedStackSize,\n\t\t\t\tRevelConfig.Controller.CachedStackMaxSize,\n\t\t\t\tfunc() interface{} {\n\t\t\t\t\treturn reflect.New(localType).Interface()\n\t\t\t\t})\n\t\t}\n\t\t// Instantiate the controller.\n\t\tc.AppController = RevelConfig.Controller.CachedMap[c.Name].Pop()\n\t} else {\n\t\tc.AppController = reflect.New(c.Type.Type).Interface()\n\t}\n\tc.setAppControllerFields()\n\n\treturn nil\n}\n\nfunc ControllerTypeByName(controllerName string, moduleSource *Module) (c *ControllerType) {\n\tvar found bool\n\tif c, found = controllers[controllerName]; !found {\n\t\t// Backup, passed in controllerName should be in lower case, but may not be\n\t\tif c, found = controllers[strings.ToLower(controllerName)]; !found {\n\t\t\tcontrollerLog.Debug(\"ControllerTypeByName: Cannot find controller in controllers map \", \"controller\", controllerName)\n\t\t\t// Search for the controller by name\n\t\t\tfor _, cType := range controllers {\n\t\t\t\ttestControllerName := strings.ToLower(cType.Type.Name())\n\t\t\t\tif testControllerName == strings.ToLower(controllerName) && (cType.ModuleSource == moduleSource || moduleSource == anyModule) {\n\t\t\t\t\tcontrollerLog.Warn(\"ControllerTypeByName: Matched empty namespace controller \", \"controller\", controllerName, \"namespace\", cType.ModuleSource.Name)\n\t\t\t\t\tc = cType\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\n// Injects this instance (c) into the AppController instance.\nfunc (c *Controller) setAppControllerFields() {\n\tappController := reflect.ValueOf(c.AppController).Elem()\n\tcValue := reflect.ValueOf(c)\n\tfor _, index := range c.Type.ControllerIndexes {\n\t\tappController.FieldByIndex(index).Set(cValue)\n\t}\n}\n\n// Removes this instance (c) from the AppController instance.\nfunc (c *Controller) resetAppControllerFields() {\n\tappController := reflect.ValueOf(c.AppController).Elem()\n\t// Zero out controller\n\tfor _, index := range c.Type.ControllerIndexes {\n\t\tappController.FieldByIndex(index).Set(reflect.Zero(reflect.TypeOf(c.AppController).Elem().FieldByIndex(index).Type))\n\t}\n}\n\nfunc findControllers(appControllerType reflect.Type) (indexes [][]int) {\n\t// It might be a multi-level embedding. To find the controllers, we follow\n\t// every anonymous field, using breadth-first search.\n\ttype nodeType struct {\n\t\tval   reflect.Value\n\t\tindex []int\n\t}\n\tappControllerPtr := reflect.New(appControllerType)\n\tqueue := []nodeType{{appControllerPtr, []int{}}}\n\tfor len(queue) > 0 {\n\t\t// Get the next value and de-reference it if necessary.\n\t\tvar (\n\t\t\tnode     = queue[0]\n\t\t\telem     = node.val\n\t\t\telemType = elem.Type()\n\t\t)\n\t\tif elemType.Kind() == reflect.Ptr {\n\t\t\telem = elem.Elem()\n\t\t\telemType = elem.Type()\n\t\t}\n\t\tqueue = queue[1:]\n\n\t\t// #944 if the type's Kind is not `Struct` move on,\n\t\t// otherwise `elem.NumField()` will panic\n\t\tif elemType.Kind() != reflect.Struct {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Look at all the struct fields.\n\t\tfor i := 0; i < elem.NumField(); i++ {\n\t\t\t// If this is not an anonymous field, skip it.\n\t\t\tstructField := elemType.Field(i)\n\t\t\tif !structField.Anonymous {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfieldValue := elem.Field(i)\n\t\t\tfieldType := structField.Type\n\n\t\t\t// If it's a Controller, record the field indexes to get here.\n\t\t\tif fieldType == controllerPtrType {\n\t\t\t\tindexes = append(indexes, append(node.index, i))\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tqueue = append(queue,\n\t\t\t\tnodeType{fieldValue, append(append([]int{}, node.index...), i)})\n\t\t}\n\t}\n\treturn\n}\n\n// RegisterController registers a Controller and its Methods with Revel.\nfunc RegisterController(c interface{}, methods []*MethodType) {\n\t// De-star the controller type\n\t// (e.g. given TypeOf((*Application)(nil)), want TypeOf(Application))\n\telem := reflect.TypeOf(c).Elem()\n\n\t// De-star all of the method arg types too.\n\tfor _, m := range methods {\n\t\tm.lowerName = strings.ToLower(m.Name)\n\t\tfor _, arg := range m.Args {\n\t\t\targ.Type = arg.Type.Elem()\n\t\t}\n\t}\n\n\t// Fetch module for controller, if none found controller must be part of the app\n\tcontrollerModule := ModuleFromPath(elem.PkgPath(), true)\n\n\tcontrollerType := AddControllerType(controllerModule, elem, methods)\n\n\tcontrollerLog.Debug(\"RegisterController:Registered controller\", \"controller\", controllerType.Name(), \"module-name\", controllerModule.Name)\n}\n"
        },
        {
          "name": "controller_type.go",
          "type": "blob",
          "size": 5.525390625,
          "content": "package revel\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Controller registry and types.\ntype ControllerType struct {\n\tNamespace         string  // The namespace of the controller\n\tModuleSource      *Module // The module for the controller\n\tType              reflect.Type\n\tMethods           []*MethodType\n\tControllerIndexes [][]int // FieldByIndex to all embedded *Controllers\n\tControllerEvents  *ControllerTypeEvents\n}\n\ntype ControllerTypeEvents struct {\n\tBefore, After, Finally, Panic []*ControllerFieldPath\n}\n\n// The controller field path provides the caller the ability to invoke the call\n// directly.\ntype ControllerFieldPath struct {\n\tIsPointer      bool\n\tFieldIndexPath []int\n\tFunctionCall   reflect.Value\n}\n\ntype MethodType struct {\n\tName           string\n\tArgs           []*MethodArg\n\tRenderArgNames map[int][]string\n\tlowerName      string\n\tIndex          int\n}\n\ntype MethodArg struct {\n\tName string\n\tType reflect.Type\n}\n\n// Adds the controller to the controllers map using its namespace, also adds it to the module list of controllers.\n// If the controller is in the main application it is added without its namespace as well.\nfunc AddControllerType(moduleSource *Module, controllerType reflect.Type, methods []*MethodType) (newControllerType *ControllerType) {\n\tif moduleSource == nil {\n\t\tmoduleSource = appModule\n\t}\n\n\tnewControllerType = &ControllerType{ModuleSource: moduleSource, Type: controllerType, Methods: methods, ControllerIndexes: findControllers(controllerType)}\n\tnewControllerType.ControllerEvents = NewControllerTypeEvents(newControllerType)\n\tnewControllerType.Namespace = moduleSource.Namespace()\n\tcontrollerName := newControllerType.Name()\n\n\t// Store the first controller only in the controllers map with the unmapped namespace.\n\tif _, found := controllers[controllerName]; !found {\n\t\tcontrollers[controllerName] = newControllerType\n\t\tnewControllerType.ModuleSource.AddController(newControllerType)\n\t\tif newControllerType.ModuleSource == appModule {\n\t\t\t// Add the controller mapping into the global namespace\n\t\t\tcontrollers[newControllerType.ShortName()] = newControllerType\n\t\t}\n\t} else {\n\t\tcontrollerLog.Errorf(\"Error, attempt to register duplicate controller as %s\", controllerName)\n\t}\n\tcontrollerLog.Debugf(\"Registered controller: %s\", controllerName)\n\n\treturn\n}\n\n// Method searches for a given exported method (case insensitive).\nfunc (ct *ControllerType) Method(name string) *MethodType {\n\tlowerName := strings.ToLower(name)\n\tfor _, method := range ct.Methods {\n\t\tif method.lowerName == lowerName {\n\t\t\treturn method\n\t\t}\n\t}\n\treturn nil\n}\n\n// The controller name with the namespace.\nfunc (ct *ControllerType) Name() string {\n\treturn ct.Namespace + ct.ShortName()\n}\n\n// The controller name without the namespace.\nfunc (ct *ControllerType) ShortName() string {\n\treturn strings.ToLower(ct.Type.Name())\n}\n\nfunc NewControllerTypeEvents(c *ControllerType) (ce *ControllerTypeEvents) {\n\tce = &ControllerTypeEvents{}\n\t// Parse the methods for the controller type, assign any control methods\n\tcheckType := c.Type\n\tce.check(checkType, []int{})\n\treturn\n}\n\n// Add in before after panic and finally, recursive call\n// Befores are ordered in revers, everything else is in order of first encountered.\nfunc (cte *ControllerTypeEvents) check(theType reflect.Type, fieldPath []int) {\n\ttypeChecker := func(checkType reflect.Type) {\n\t\tfor index := 0; index < checkType.NumMethod(); index++ {\n\t\t\tm := checkType.Method(index)\n\t\t\t// Must be two arguments, the second returns the controller type\n\t\t\t// Go cannot differentiate between promoted methods and\n\t\t\t// embedded methods, this allows the embedded method to be run\n\t\t\t// https://github.com/golang/go/issues/21162\n\t\t\tif m.Type.NumOut() == 2 && m.Type.Out(1) == checkType {\n\t\t\t\tif checkType.Kind() == reflect.Ptr {\n\t\t\t\t\tcontrollerLog.Debug(\"Found controller type event method pointer\", \"name\", checkType.Elem().Name(), \"methodname\", m.Name)\n\t\t\t\t} else {\n\t\t\t\t\tcontrollerLog.Debug(\"Found controller type event method\", \"name\", checkType.Name(), \"methodname\", m.Name)\n\t\t\t\t}\n\t\t\t\tcontrollerFieldPath := newFieldPath(checkType.Kind() == reflect.Ptr, m.Func, fieldPath)\n\t\t\t\tswitch strings.ToLower(m.Name) {\n\t\t\t\tcase \"before\":\n\t\t\t\t\tcte.Before = append([]*ControllerFieldPath{controllerFieldPath}, cte.Before...)\n\t\t\t\tcase \"after\":\n\t\t\t\t\tcte.After = append(cte.After, controllerFieldPath)\n\t\t\t\tcase \"panic\":\n\t\t\t\t\tcte.Panic = append(cte.Panic, controllerFieldPath)\n\t\t\t\tcase \"finally\":\n\t\t\t\t\tcte.Finally = append(cte.Finally, controllerFieldPath)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check methods of both types\n\ttypeChecker(theType)\n\ttypeChecker(reflect.PtrTo(theType))\n\n\t// Check for any sub controllers, ignore any pointers to controllers revel.Controller\n\tfor i := 0; i < theType.NumField(); i++ {\n\t\tv := theType.Field(i)\n\n\t\tswitch v.Type.Kind() {\n\t\tcase reflect.Struct:\n\t\t\tcte.check(v.Type, append(fieldPath, i))\n\t\t}\n\t}\n}\n\nfunc newFieldPath(isPointer bool, value reflect.Value, fieldPath []int) *ControllerFieldPath {\n\treturn &ControllerFieldPath{IsPointer: isPointer, FunctionCall: value, FieldIndexPath: fieldPath}\n}\n\nfunc (fieldPath *ControllerFieldPath) Invoke(value reflect.Value, input []reflect.Value) (result []reflect.Value) {\n\tfor _, index := range fieldPath.FieldIndexPath {\n\t\t// You can only fetch fields from non pointers\n\t\tif value.Type().Kind() == reflect.Ptr {\n\t\t\tvalue = value.Elem().Field(index)\n\t\t} else {\n\t\t\tvalue = value.Field(index)\n\t\t}\n\t}\n\tif fieldPath.IsPointer && value.Type().Kind() != reflect.Ptr {\n\t\tvalue = value.Addr()\n\t} else if !fieldPath.IsPointer && value.Type().Kind() == reflect.Ptr {\n\t\tvalue = value.Elem()\n\t}\n\n\treturn fieldPath.FunctionCall.Call(append([]reflect.Value{value}, input...))\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 4.736328125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Error description, used as an argument to the error template.\ntype Error struct {\n\tSourceType               string   // The type of source that failed to build.\n\tTitle, Path, Description string   // Description of the error, as presented to the user.\n\tLine, Column             int      // Where the error was encountered.\n\tSourceLines              []string // The entire source file, split into lines.\n\tStack                    string   // The raw stack trace string from debug.Stack().\n\tMetaError                string   // Error that occurred producing the error page.\n\tLink                     string   // A configurable link to wrap the error source in\n}\n\n// SourceLine structure to hold the per-source-line details.\ntype SourceLine struct {\n\tSource  string\n\tLine    int\n\tIsError bool\n}\n\n// NewErrorFromPanic method finds the deepest stack from in user code and\n// provide a code listing of that, on the line that eventually triggered\n// the panic.  Returns nil if no relevant stack frame can be found.\nfunc NewErrorFromPanic(err interface{}) *Error {\n\t// Parse the filename and line from the originating line of app code.\n\t// /Users/robfig/code/gocode/src/revel/examples/booking/app/controllers/hotels.go:191 (0x44735)\n\tstack := string(debug.Stack())\n\tframe, basePath := findRelevantStackFrame(stack)\n\tif frame == -1 {\n\t\treturn nil\n\t}\n\n\tstack = stack[frame:]\n\tstackElement := stack[:strings.Index(stack, \"\\n\")]\n\tcolonIndex := strings.LastIndex(stackElement, \":\")\n\tfilename := stackElement[:colonIndex]\n\tvar line int\n\tfmt.Sscan(stackElement[colonIndex+1:], &line)\n\n\t// Show an error page.\n\tdescription := \"Unspecified error\"\n\tif err != nil {\n\t\tdescription = fmt.Sprint(err)\n\t}\n\tlines, readErr := ReadLines(filename)\n\tif readErr != nil {\n\t\tutilLog.Error(\"Unable to read file\", \"file\", filename, \"error\", readErr)\n\t}\n\treturn &Error{\n\t\tTitle:       \"Runtime Panic\",\n\t\tPath:        filename[len(basePath):],\n\t\tLine:        line,\n\t\tDescription: description,\n\t\tSourceLines: lines,\n\t\tStack:       stack,\n\t}\n}\n\n// Error method constructs a plaintext version of the error, taking\n// account that fields are optionally set. Returns e.g. Compilation Error\n// (in views/header.html:51): expected right delim in end; got \"}\".\nfunc (e *Error) Error() string {\n\tloc := \"\"\n\tif e.Path != \"\" {\n\t\tline := \"\"\n\t\tif e.Line != 0 {\n\t\t\tline = fmt.Sprintf(\":%d\", e.Line)\n\t\t}\n\t\tloc = fmt.Sprintf(\"(in %s%s)\", e.Path, line)\n\t}\n\theader := loc\n\tif e.Title != \"\" {\n\t\tif loc != \"\" {\n\t\t\theader = fmt.Sprintf(\"%s %s: \", e.Title, loc)\n\t\t} else {\n\t\t\theader = fmt.Sprintf(\"%s: \", e.Title)\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"%s%s Stack: %s\", header, e.Description, e.Stack)\n}\n\n// ContextSource method returns a snippet of the source around\n// where the error occurred.\nfunc (e *Error) ContextSource() []SourceLine {\n\tif e.SourceLines == nil {\n\t\treturn nil\n\t}\n\tstart := (e.Line - 1) - 5\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tend := (e.Line - 1) + 5\n\tif end > len(e.SourceLines) {\n\t\tend = len(e.SourceLines)\n\t}\n\n\tlines := make([]SourceLine, end-start)\n\tfor i, src := range e.SourceLines[start:end] {\n\t\tfileLine := start + i + 1\n\t\tlines[i] = SourceLine{src, fileLine, fileLine == e.Line}\n\t}\n\treturn lines\n}\n\n// SetLink method prepares a link and assign to Error.Link attribute.\nfunc (e *Error) SetLink(errorLink string) {\n\terrorLink = strings.Replace(errorLink, \"{{Path}}\", e.Path, -1)\n\terrorLink = strings.Replace(errorLink, \"{{Line}}\", strconv.Itoa(e.Line), -1)\n\n\te.Link = \"<a href=\" + errorLink + \">\" + e.Path + \":\" + strconv.Itoa(e.Line) + \"</a>\"\n}\n\n// Return the character index of the first relevant stack frame, or -1 if none were found.\n// Additionally it returns the base path of the tree in which the identified code resides.\nfunc findRelevantStackFrame(stack string) (int, string) {\n\t// Find first item in SourcePath that isn't in RevelPath.\n\t// If first item is in RevelPath, keep track of position, trim and check again.\n\tpartialStack := stack\n\tsourcePath := filepath.ToSlash(SourcePath)\n\trevelPath := filepath.ToSlash(RevelPath)\n\tsumFrame := 0\n\tfor {\n\t\tframe := strings.Index(partialStack, sourcePath)\n\t\trevelFrame := strings.Index(partialStack, revelPath)\n\n\t\tif frame == -1 {\n\t\t\tbreak\n\t\t} else if frame != revelFrame {\n\t\t\treturn sumFrame + frame, SourcePath\n\t\t} else {\n\t\t\t// Need to at least trim off the first character so this frame isn't caught again.\n\t\t\tpartialStack = partialStack[frame+1:]\n\t\t\tsumFrame += frame + 1\n\t\t}\n\t}\n\tfor _, module := range Modules {\n\t\tif frame := strings.Index(stack, filepath.ToSlash(module.Path)); frame != -1 {\n\t\t\treturn frame, module.Path\n\t\t}\n\t}\n\treturn -1, \"\"\n}\n"
        },
        {
          "name": "event.go",
          "type": "blob",
          "size": 2.005859375,
          "content": "package revel\n\ntype (\n\t// The event type.\n\tEvent int\n\t// The event response.\n\tEventResponse int\n\t// The handler signature.\n\tEventHandler func(typeOf Event, value interface{}) (responseOf EventResponse)\n)\n\nconst (\n\t// Event type when templates are going to be refreshed (receivers are registered template engines added to the template.engine conf option).\n\tTEMPLATE_REFRESH_REQUESTED Event = iota\n\t// Event type when templates are refreshed (receivers are registered template engines added to the template.engine conf option).\n\tTEMPLATE_REFRESH_COMPLETED\n\t// Event type before all module loads, events thrown to handlers added to AddInitEventHandler.\n\n\t// Event type before all module loads, events thrown to handlers added to AddInitEventHandler.\n\tREVEL_BEFORE_MODULES_LOADED\n\t// Event type after all module loads, events thrown to handlers added to AddInitEventHandler.\n\tREVEL_AFTER_MODULES_LOADED\n\n\t// Event type before server engine is initialized, receivers are active server engine and handlers added to AddInitEventHandler.\n\tENGINE_BEFORE_INITIALIZED\n\t// Event type before server engine is started, receivers are active server engine and handlers added to AddInitEventHandler.\n\tENGINE_STARTED\n\n\t// Event raised when the engine is told to shutdown.\n\tENGINE_SHUTDOWN_REQUEST\n\n\t// Event type after server engine is stopped, receivers are active server engine and handlers added to AddInitEventHandler.\n\tENGINE_SHUTDOWN\n\n\t// Called before routes are refreshed.\n\tROUTE_REFRESH_REQUESTED\n\t// Called after routes have been refreshed.\n\tROUTE_REFRESH_COMPLETED\n\n\t// Fired when a panic is caught during the startup process.\n\tREVEL_FAILURE\n)\n\n// Fires system events from revel.\nfunc RaiseEvent(key Event, value interface{}) (response EventResponse) {\n\tutilLog.Info(\"Raising event\", \"len\", len(initEventList))\n\tfor _, handler := range initEventList {\n\t\tresponse |= handler(key, value)\n\t}\n\treturn\n}\n\n// Add event handler to listen for all system events.\nfunc AddInitEventHandler(handler EventHandler) {\n\tinitEventList = append(initEventList, handler)\n\treturn\n}\n"
        },
        {
          "name": "event_test.go",
          "type": "blob",
          "size": 0.728515625,
          "content": "package revel_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/revel/revel\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Test that the event handler can be attached and it dispatches the event received.\nfunc TestEventHandler(t *testing.T) {\n\tcounter := 0\n\tnewListener := func(typeOf revel.Event, value interface{}) (responseOf revel.EventResponse) {\n\t\tif typeOf == revel.REVEL_FAILURE {\n\t\t\tcounter++\n\t\t}\n\t\treturn\n\t}\n\t// Attach the same handlder twice so we expect to see the response twice as well\n\trevel.AddInitEventHandler(newListener)\n\trevel.AddInitEventHandler(newListener)\n\trevel.RaiseEvent(revel.REVEL_AFTER_MODULES_LOADED, nil)\n\trevel.RaiseEvent(revel.REVEL_FAILURE, nil)\n\tassert.Equal(t, counter, 2, \"Expected event handler to have been called\")\n}\n"
        },
        {
          "name": "fakeapp_test.go",
          "type": "blob",
          "size": 3.5673828125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n)\n\ntype Hotel struct {\n\tHotelID          int\n\tName, Address    string\n\tCity, State, Zip string\n\tCountry          string\n\tPrice            int\n}\n\ntype Hotels struct {\n\t*Controller\n}\n\ntype Static struct {\n\t*Controller\n}\n\ntype Implicit struct {\n\t*Controller\n}\n\ntype Application struct {\n\t*Controller\n}\n\nfunc (c Hotels) Show(id int) Result {\n\ttitle := \"View Hotel\"\n\thotel := &Hotel{id, \"A Hotel\", \"300 Main St.\", \"New York\", \"NY\", \"10010\", \"USA\", 300}\n\t// The line number below must match the one with the code : RenderArgNames: map[int][]string{43: {\"title\", \"hotel\"}},\n\treturn c.Render(title, hotel)\n}\n\nfunc (c Hotels) Book(id int) Result {\n\thotel := &Hotel{id, \"A Hotel\", \"300 Main St.\", \"New York\", \"NY\", \"10010\", \"USA\", 300}\n\treturn c.RenderJSON(hotel)\n}\n\nfunc (c Hotels) Index() Result {\n\treturn c.RenderText(\"Hello, World!\")\n}\n\nfunc (c Static) Serve(prefix, path string) Result {\n\tvar basePath, dirName string\n\n\tif !filepath.IsAbs(dirName) {\n\t\tbasePath = BasePath\n\t}\n\n\tfname := filepath.Join(basePath, prefix, path)\n\tfile, err := os.Open(fname)\n\tif os.IsNotExist(err) {\n\t\treturn c.NotFound(\"\")\n\t} else if err != nil {\n\t\tRevelLog.Errorf(\"Problem opening file (%s): %s \", fname, err)\n\t\treturn c.NotFound(\"This was found but not sure why we couldn't open it.\")\n\t}\n\treturn c.RenderFile(file, \"\")\n}\n\n// Register controllers is in its own function so the route test can use it as well.\nfunc registerControllers() {\n\tcontrollers = make(map[string]*ControllerType)\n\tRaiseEvent(ROUTE_REFRESH_REQUESTED, nil)\n\tRegisterController((*Hotels)(nil),\n\t\t[]*MethodType{\n\t\t\t{\n\t\t\t\tName: \"Index\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Show\",\n\t\t\t\tArgs: []*MethodArg{\n\t\t\t\t\t{\"id\", reflect.TypeOf((*int)(nil))},\n\t\t\t\t},\n\t\t\t\tRenderArgNames: map[int][]string{41: {\"title\", \"hotel\"}},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Book\",\n\t\t\t\tArgs: []*MethodArg{\n\t\t\t\t\t{\"id\", reflect.TypeOf((*int)(nil))},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tRegisterController((*Static)(nil),\n\t\t[]*MethodType{\n\t\t\t{\n\t\t\t\tName: \"Serve\",\n\t\t\t\tArgs: []*MethodArg{\n\t\t\t\t\t{Name: \"prefix\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t\t{Name: \"filepath\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t},\n\t\t\t\tRenderArgNames: map[int][]string{},\n\t\t\t},\n\t\t})\n\tRegisterController((*Implicit)(nil),\n\t\t[]*MethodType{\n\t\t\t{\n\t\t\t\tName: \"Implicit\",\n\t\t\t\tArgs: []*MethodArg{\n\t\t\t\t\t{Name: \"prefix\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t\t{Name: \"filepath\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t},\n\t\t\t\tRenderArgNames: map[int][]string{},\n\t\t\t},\n\t\t})\n\tRegisterController((*Application)(nil),\n\t\t[]*MethodType{\n\t\t\t{\n\t\t\t\tName: \"Application\",\n\t\t\t\tArgs: []*MethodArg{\n\t\t\t\t\t{Name: \"prefix\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t\t{Name: \"filepath\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t},\n\t\t\t\tRenderArgNames: map[int][]string{},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName: \"Index\",\n\t\t\t\tArgs: []*MethodArg{\n\t\t\t\t\t{Name: \"foo\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t\t{Name: \"bar\", Type: reflect.TypeOf((*string)(nil))},\n\t\t\t\t},\n\t\t\t\tRenderArgNames: map[int][]string{},\n\t\t\t},\n\t\t})\n}\n\nfunc startFakeBookingApp() {\n\tInit(\"prod\", \"github.com/revel/revel/testdata\", \"\")\n\n\tMainTemplateLoader = NewTemplateLoader([]string{ViewsPath, filepath.Join(RevelPath, \"templates\")})\n\tif err := MainTemplateLoader.Refresh(); err != nil {\n\t\tRevelLog.Fatal(\"Template error\", \"error\", err)\n\t}\n\n\tregisterControllers()\n\n\tInitServerEngine(9000, GO_NATIVE_SERVER_ENGINE)\n\tRaiseEvent(ENGINE_BEFORE_INITIALIZED, nil)\n\tInitServer()\n\n\tRaiseEvent(ENGINE_STARTED, nil)\n}\n"
        },
        {
          "name": "field.go",
          "type": "blob",
          "size": 2.470703125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Field represents a data field that may be collected in a web form.\ntype Field struct {\n\tName       string\n\tError      *ValidationError\n\tviewArgs   map[string]interface{}\n\tcontroller *Controller\n}\n\nfunc NewField(name string, viewArgs map[string]interface{}) *Field {\n\terr, _ := viewArgs[\"errors\"].(map[string]*ValidationError)[name]\n\tcontroller, _ := viewArgs[\"_controller\"].(*Controller)\n\treturn &Field{\n\t\tName:       name,\n\t\tError:      err,\n\t\tviewArgs:   viewArgs,\n\t\tcontroller: controller,\n\t}\n}\n\n// ID returns an identifier suitable for use as an HTML id.\nfunc (f *Field) ID() string {\n\treturn strings.Replace(f.Name, \".\", \"_\", -1)\n}\n\n// Flash returns the flashed value of this Field.\nfunc (f *Field) Flash() string {\n\tv, _ := f.viewArgs[\"flash\"].(map[string]string)[f.Name]\n\treturn v\n}\n\n// Options returns the option list of this Field.\nfunc (f *Field) Options() []string {\n\tif f.viewArgs[\"options\"] == nil {\n\t\treturn nil\n\t}\n\tv, _ := f.viewArgs[\"options\"].(map[string][]string)[f.Name]\n\treturn v\n}\n\n// FlashArray returns the flashed value of this Field as a list split on comma.\nfunc (f *Field) FlashArray() []string {\n\tv := f.Flash()\n\tif v == \"\" {\n\t\treturn []string{}\n\t}\n\treturn strings.Split(v, \",\")\n}\n\n// Value returns the current value of this Field.\nfunc (f *Field) Value() interface{} {\n\tpieces := strings.Split(f.Name, \".\")\n\tanswer, ok := f.viewArgs[pieces[0]]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\n\tval := reflect.ValueOf(answer)\n\tfor i := 1; i < len(pieces); i++ {\n\t\tif val.Kind() == reflect.Ptr {\n\t\t\tval = val.Elem()\n\t\t}\n\t\tval = val.FieldByName(pieces[i])\n\t\tif !val.IsValid() {\n\t\t\treturn \"\"\n\t\t}\n\t}\n\n\treturn val.Interface()\n}\n\n// ErrorClass returns ErrorCSSClass if this field has a validation error, else empty string.\nfunc (f *Field) ErrorClass() string {\n\tif f.Error != nil {\n\t\tif errorClass, ok := f.viewArgs[\"ERROR_CLASS\"]; ok {\n\t\t\treturn errorClass.(string)\n\t\t}\n\t\treturn ErrorCSSClass\n\t}\n\treturn \"\"\n}\n\n// Get the short name and translate it.\nfunc (f *Field) ShortName() string {\n\tname := f.Name\n\tif i := strings.LastIndex(name, \".\"); i > 0 {\n\t\tname = name[i+1:]\n\t}\n\treturn f.Translate(name)\n}\n\n// Translate the text.\nfunc (f *Field) Translate(text string, args ...interface{}) string {\n\tif f.controller != nil {\n\t\ttext = f.controller.Message(text, args...)\n\t}\n\treturn text\n}\n"
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 1.33203125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\n// Filter type definition for Revel's filter.\ntype Filter func(c *Controller, filterChain []Filter)\n\n// Filters is the default set of global filters.\n// It may be set by the application on initialization.\nvar Filters = []Filter{\n\tPanicFilter,             // Recover from panics and display an error page instead.\n\tRouterFilter,            // Use the routing table to select the right Action.\n\tFilterConfiguringFilter, // A hook for adding or removing per-Action filters.\n\tParamsFilter,            // Parse parameters into Controller.Params.\n\tSessionFilter,           // Restore and write the session cookie.\n\tFlashFilter,             // Restore and write the flash cookie.\n\tValidationFilter,        // Restore kept validation errors and save new ones from cookie.\n\tI18nFilter,              // Resolve the requested language.\n\tInterceptorFilter,       // Run interceptors around the action.\n\tCompressFilter,          // Compress the result.\n\tBeforeAfterFilter,\n\tActionInvoker, // Invoke the action.\n}\n\n// NilFilter and NilChain are helpful in writing filter tests.\nvar (\n\tNilFilter = func(_ *Controller, _ []Filter) {}\n\tNilChain  = []Filter{NilFilter}\n)\n"
        },
        {
          "name": "filterconfig.go",
          "type": "blob",
          "size": 6.86328125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Map from \"Controller\" or \"Controller.Method\" to the Filter chain.\nvar filterOverrides = make(map[string][]Filter)\n\n// FilterConfigurator allows the developer configure the filter chain on a\n// per-controller or per-action basis.  The filter configuration is applied by\n// the FilterConfiguringFilter, which is itself a filter stage.  For example,\n//\n// Assuming:\n//   Filters = []Filter{\n//     RouterFilter,\n//     FilterConfiguringFilter,\n//     SessionFilter,\n//     ActionInvoker,\n//   }\n//\n// Add:\n//   FilterAction(App.Action).\n//     Add(OtherFilter)\n//\n//   => RouterFilter, FilterConfiguringFilter, SessionFilter, OtherFilter, ActionInvoker\n//\n// Remove:\n//   FilterAction(App.Action).\n//     Remove(SessionFilter)\n//\n//   => RouterFilter, FilterConfiguringFilter, OtherFilter, ActionInvoker\n//\n// Insert:\n//   FilterAction(App.Action).\n//     Insert(OtherFilter, revel.BEFORE, SessionFilter)\n//\n//   => RouterFilter, FilterConfiguringFilter, OtherFilter, SessionFilter, ActionInvoker\n//\n// Filter modifications may be combined between Controller and Action.  For example:\n//   FilterController(App{}).\n//     Add(Filter1)\n//   FilterAction(App.Action).\n//     Add(Filter2)\n//\n//  .. would result in App.Action being filtered by both Filter1 and Filter2.\n//\n// Note: the last filter stage is not subject to the configurator.  In\n// particular, Add() adds a filter to the second-to-last place.\ntype FilterConfigurator struct {\n\tkey            string // e.g. \"App\", \"App.Action\"\n\tcontrollerName string // e.g. \"App\"\n}\n\nfunc newFilterConfigurator(controllerName, methodName string) FilterConfigurator {\n\tif methodName == \"\" {\n\t\treturn FilterConfigurator{controllerName, controllerName}\n\t}\n\treturn FilterConfigurator{controllerName + \".\" + methodName, controllerName}\n}\n\n// FilterController returns a configurator for the filters applied to all\n// actions on the given controller instance.  For example:\n//   FilterController(MyController{})\nfunc FilterController(controllerInstance interface{}) FilterConfigurator {\n\tt := reflect.TypeOf(controllerInstance)\n\tfor t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\treturn newFilterConfigurator(t.Name(), \"\")\n}\n\n// FilterAction returns a configurator for the filters applied to the given\n// controller method. For example:\n//   FilterAction(MyController.MyAction)\nfunc FilterAction(methodRef interface{}) FilterConfigurator {\n\tvar (\n\t\tmethodValue = reflect.ValueOf(methodRef)\n\t\tmethodType  = methodValue.Type()\n\t)\n\tif methodType.Kind() != reflect.Func || methodType.NumIn() == 0 {\n\t\tpanic(\"Expecting a controller method reference (e.g. Controller.Action), got a \" +\n\t\t\tmethodType.String())\n\t}\n\n\tcontrollerType := methodType.In(0)\n\tmethod := FindMethod(controllerType, methodValue)\n\tif method == nil {\n\t\tpanic(\"Action not found on controller \" + controllerType.Name())\n\t}\n\n\tfor controllerType.Kind() == reflect.Ptr {\n\t\tcontrollerType = controllerType.Elem()\n\t}\n\n\treturn newFilterConfigurator(controllerType.Name(), method.Name)\n}\n\n// Add the given filter in the second-to-last position in the filter chain.\n// (Second-to-last so that it is before ActionInvoker).\nfunc (conf FilterConfigurator) Add(f Filter) FilterConfigurator {\n\tconf.apply(func(fc []Filter) []Filter {\n\t\treturn conf.addFilter(f, fc)\n\t})\n\treturn conf\n}\n\nfunc (conf FilterConfigurator) addFilter(f Filter, fc []Filter) []Filter {\n\treturn append(fc[:len(fc)-1], f, fc[len(fc)-1])\n}\n\n// Remove a filter from the filter chain.\nfunc (conf FilterConfigurator) Remove(target Filter) FilterConfigurator {\n\tconf.apply(func(fc []Filter) []Filter {\n\t\treturn conf.rmFilter(target, fc)\n\t})\n\treturn conf\n}\n\nfunc (conf FilterConfigurator) rmFilter(target Filter, fc []Filter) []Filter {\n\tfor i, f := range fc {\n\t\tif FilterEq(f, target) {\n\t\t\treturn append(fc[:i], fc[i+1:]...)\n\t\t}\n\t}\n\treturn fc\n}\n\n// Insert a filter into the filter chain before or after another.\n// This may be called with the BEFORE or AFTER constants, for example:\n//   revel.FilterAction(App.Index).\n//     Insert(MyFilter, revel.BEFORE, revel.ActionInvoker).\n//     Insert(MyFilter2, revel.AFTER, revel.PanicFilter)\nfunc (conf FilterConfigurator) Insert(insert Filter, where When, target Filter) FilterConfigurator {\n\tif where != BEFORE && where != AFTER {\n\t\tpanic(\"where must be BEFORE or AFTER\")\n\t}\n\tconf.apply(func(fc []Filter) []Filter {\n\t\treturn conf.insertFilter(insert, where, target, fc)\n\t})\n\treturn conf\n}\n\nfunc (conf FilterConfigurator) insertFilter(insert Filter, where When, target Filter, fc []Filter) []Filter {\n\tfor i, f := range fc {\n\t\tif FilterEq(f, target) {\n\t\t\tif where == BEFORE {\n\t\t\t\treturn append(fc[:i], append([]Filter{insert}, fc[i:]...)...)\n\t\t\t}\n\t\t\treturn append(fc[:i+1], append([]Filter{insert}, fc[i+1:]...)...)\n\t\t}\n\t}\n\treturn fc\n}\n\n// getChain returns the filter chain that applies to the given controller or\n// action.  If no overrides are configured, then a copy of the default filter\n// chain is returned.\nfunc (conf FilterConfigurator) getChain() []Filter {\n\tvar filters []Filter\n\tif filters = getOverrideChain(conf.controllerName, conf.key); filters == nil {\n\t\t// The override starts with all filters after FilterConfiguringFilter\n\t\tfor i, f := range Filters {\n\t\t\tif FilterEq(f, FilterConfiguringFilter) {\n\t\t\t\tfilters = make([]Filter, len(Filters)-i-1)\n\t\t\t\tcopy(filters, Filters[i+1:])\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif filters == nil {\n\t\t\tpanic(\"FilterConfiguringFilter not found in revel.Filters.\")\n\t\t}\n\t}\n\treturn filters\n}\n\n// apply applies the given functional change to the filter overrides.\n// No other function modifies the filterOverrides map.\nfunc (conf FilterConfigurator) apply(f func([]Filter) []Filter) {\n\t// Updates any actions that have had their filters overridden, if this is a\n\t// Controller configurator.\n\tif conf.controllerName == conf.key {\n\t\tfor k, v := range filterOverrides {\n\t\t\tif strings.HasPrefix(k, conf.controllerName+\".\") {\n\t\t\t\tfilterOverrides[k] = f(v)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update the Controller or Action overrides.\n\tfilterOverrides[conf.key] = f(conf.getChain())\n}\n\n// FilterEq returns true if the two filters reference the same filter.\nfunc FilterEq(a, b Filter) bool {\n\treturn reflect.ValueOf(a).Pointer() == reflect.ValueOf(b).Pointer()\n}\n\n// FilterConfiguringFilter is a filter stage that customizes the remaining\n// filter chain for the action being invoked.\nfunc FilterConfiguringFilter(c *Controller, fc []Filter) {\n\tif newChain := getOverrideChain(c.Name, c.Action); newChain != nil {\n\t\tnewChain[0](c, newChain[1:])\n\t\treturn\n\t}\n\tfc[0](c, fc[1:])\n}\n\n// getOverrideChain retrieves the overrides for the action that is set.\nfunc getOverrideChain(controllerName, action string) []Filter {\n\tif newChain, ok := filterOverrides[action]; ok {\n\t\treturn newChain\n\t}\n\tif newChain, ok := filterOverrides[controllerName]; ok {\n\t\treturn newChain\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "filterconfig_test.go",
          "type": "blob",
          "size": 3.51171875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport \"testing\"\n\ntype FakeController struct{}\n\nfunc (c FakeController) Foo()  {}\nfunc (c *FakeController) Bar() {}\n\nfunc TestFilterConfiguratorKey(t *testing.T) {\n\tconf := FilterController(FakeController{})\n\tif conf.key != \"FakeController\" {\n\t\tt.Errorf(\"Expected key 'FakeController', was %s\", conf.key)\n\t}\n\n\tconf = FilterController(&FakeController{})\n\tif conf.key != \"FakeController\" {\n\t\tt.Errorf(\"Expected key 'FakeController', was %s\", conf.key)\n\t}\n\n\tconf = FilterAction(FakeController.Foo)\n\tif conf.key != \"FakeController.Foo\" {\n\t\tt.Errorf(\"Expected key 'FakeController.Foo', was %s\", conf.key)\n\t}\n\n\tconf = FilterAction((*FakeController).Bar)\n\tif conf.key != \"FakeController.Bar\" {\n\t\tt.Errorf(\"Expected key 'FakeController.Bar', was %s\", conf.key)\n\t}\n}\n\nfunc TestFilterConfigurator(t *testing.T) {\n\t// Filters is global state.  Restore it after this test.\n\toldFilters := make([]Filter, len(Filters))\n\tcopy(oldFilters, Filters)\n\tdefer func() {\n\t\tFilters = oldFilters\n\t}()\n\n\tFilters = []Filter{\n\t\tRouterFilter,\n\t\tFilterConfiguringFilter,\n\t\tSessionFilter,\n\t\tFlashFilter,\n\t\tActionInvoker,\n\t}\n\n\t// Do one of each operation.\n\tconf := FilterAction(FakeController.Foo).\n\t\tAdd(NilFilter).\n\t\tRemove(FlashFilter).\n\t\tInsert(ValidationFilter, BEFORE, NilFilter).\n\t\tInsert(I18nFilter, AFTER, NilFilter)\n\texpected := []Filter{\n\t\tSessionFilter,\n\t\tValidationFilter,\n\t\tNilFilter,\n\t\tI18nFilter,\n\t\tActionInvoker,\n\t}\n\tactual := getOverride(\"Foo\")\n\tif len(actual) != len(expected) || !filterSliceEqual(actual, expected) {\n\t\tt.Errorf(\"Ops failed.\\nActual: %#v\\nExpect: %#v\\nConf:%v\", actual, expected, conf)\n\t}\n\n\t// Action2 should be unchanged\n\tif getOverride(\"Bar\") != nil {\n\t\tt.Errorf(\"Filtering Action should not affect Action2.\")\n\t}\n\n\t// Test that combining overrides on both the Controller and Action works.\n\tFilterController(FakeController{}).\n\t\tAdd(PanicFilter)\n\texpected = []Filter{\n\t\tSessionFilter,\n\t\tValidationFilter,\n\t\tNilFilter,\n\t\tI18nFilter,\n\t\tPanicFilter,\n\t\tActionInvoker,\n\t}\n\tactual = getOverride(\"Foo\")\n\tif len(actual) != len(expected) || !filterSliceEqual(actual, expected) {\n\t\tt.Errorf(\"Expected PanicFilter added to Foo.\\nActual: %#v\\nExpect: %#v\", actual, expected)\n\t}\n\n\texpected = []Filter{\n\t\tSessionFilter,\n\t\tFlashFilter,\n\t\tPanicFilter,\n\t\tActionInvoker,\n\t}\n\tactual = getOverride(\"Bar\")\n\tif len(actual) != len(expected) || !filterSliceEqual(actual, expected) {\n\t\tt.Errorf(\"Expected PanicFilter added to Bar.\\nActual: %#v\\nExpect: %#v\", actual, expected)\n\t}\n\n\tFilterAction((*FakeController).Bar).\n\t\tAdd(NilFilter)\n\texpected = []Filter{\n\t\tSessionFilter,\n\t\tValidationFilter,\n\t\tNilFilter,\n\t\tI18nFilter,\n\t\tPanicFilter,\n\t\tActionInvoker,\n\t}\n\tactual = getOverride(\"Foo\")\n\tif len(actual) != len(expected) || !filterSliceEqual(actual, expected) {\n\t\tt.Errorf(\"Expected no change to Foo.\\nActual: %#v\\nExpect: %#v\", actual, expected)\n\t}\n\n\texpected = []Filter{\n\t\tSessionFilter,\n\t\tFlashFilter,\n\t\tPanicFilter,\n\t\tNilFilter,\n\t\tActionInvoker,\n\t}\n\tactual = getOverride(\"Bar\")\n\tif len(actual) != len(expected) || !filterSliceEqual(actual, expected) {\n\t\tt.Errorf(\"Expected NilFilter added to Bar.\\nActual: %#v\\nExpect: %#v\", actual, expected)\n\t}\n}\n\nfunc filterSliceEqual(a, e []Filter) bool {\n\tfor i, f := range a {\n\t\tif !FilterEq(f, e[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc getOverride(methodName string) []Filter {\n\treturn getOverrideChain(\"FakeController\", \"FakeController.\"+methodName)\n}\n"
        },
        {
          "name": "flash.go",
          "type": "blob",
          "size": 2.25390625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// Flash represents a cookie that is overwritten on each request.\n// It allows data to be stored across one page at a time.\n// This is commonly used to implement success or error messages.\n// E.g. the Post/Redirect/Get pattern:\n// http://en.wikipedia.org/wiki/Post/Redirect/Get\ntype Flash struct {\n\t// `Data` is the input which is read in `restoreFlash`, `Out` is the output which is set in a FLASH cookie at the end of the `FlashFilter()`\n\tData, Out map[string]string\n}\n\n// Error serializes the given msg and args to an \"error\" key within\n// the Flash cookie.\nfunc (f Flash) Error(msg string, args ...interface{}) {\n\tif len(args) == 0 {\n\t\tf.Out[\"error\"] = msg\n\t} else {\n\t\tf.Out[\"error\"] = fmt.Sprintf(msg, args...)\n\t}\n}\n\n// Success serializes the given msg and args to a \"success\" key within\n// the Flash cookie.\nfunc (f Flash) Success(msg string, args ...interface{}) {\n\tif len(args) == 0 {\n\t\tf.Out[\"success\"] = msg\n\t} else {\n\t\tf.Out[\"success\"] = fmt.Sprintf(msg, args...)\n\t}\n}\n\n// FlashFilter is a Revel Filter that retrieves and sets the flash cookie.\n// Within Revel, it is available as a Flash attribute on Controller instances.\n// The name of the Flash cookie is set as CookiePrefix + \"_FLASH\".\nfunc FlashFilter(c *Controller, fc []Filter) {\n\tc.Flash = restoreFlash(c.Request)\n\tc.ViewArgs[\"flash\"] = c.Flash.Data\n\n\tfc[0](c, fc[1:])\n\n\t// Store the flash.\n\tvar flashValue string\n\tfor key, value := range c.Flash.Out {\n\t\tflashValue += \"\\x00\" + key + \":\" + value + \"\\x00\"\n\t}\n\tc.SetCookie(&http.Cookie{\n\t\tName:     CookiePrefix + \"_FLASH\",\n\t\tValue:    url.QueryEscape(flashValue),\n\t\tHttpOnly: true,\n\t\tSecure:   CookieSecure,\n\t\tSameSite: CookieSameSite,\n\t\tPath:     \"/\",\n\t})\n}\n\n// restoreFlash deserializes a Flash cookie struct from a request.\nfunc restoreFlash(req *Request) Flash {\n\tflash := Flash{\n\t\tData: make(map[string]string),\n\t\tOut:  make(map[string]string),\n\t}\n\tif cookie, err := req.Cookie(CookiePrefix + \"_FLASH\"); err == nil {\n\t\tParseKeyValueCookie(cookie.GetValue(), func(key, val string) {\n\t\t\tflash.Data[key] = val\n\t\t})\n\t}\n\treturn flash\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.1328125,
          "content": "module github.com/revel/revel\n\ngo 1.17\n\nrequire (\n\tgithub.com/bradfitz/gomemcache v0.0.0-20220106215444-fb4bf637b56d\n\tgithub.com/fsnotify/fsnotify v1.5.1\n\tgithub.com/go-stack/stack v1.8.1\n\tgithub.com/gomodule/redigo v1.8.8\n\tgithub.com/google/uuid v1.3.0\n\tgithub.com/mattn/go-colorable v0.1.12\n\tgithub.com/patrickmn/go-cache v2.1.0+incompatible\n\tgithub.com/revel/config v1.0.0\n\tgithub.com/revel/log15 v2.11.20+incompatible\n\tgithub.com/revel/pathtree v0.0.0-20140121041023-41257a1839e9\n\tgithub.com/stretchr/testify v1.7.1\n\tgithub.com/xeonx/timeago v1.0.0-rc4\n\tgolang.org/x/net v0.0.0-20220412020605-290c469a71a5\n\tgopkg.in/natefinch/lumberjack.v2 v2.0.0\n\tgopkg.in/stack.v0 v0.0.0-20141108040640-9b43fcefddd0\n)\n\nrequire (\n\tgithub.com/BurntSushi/toml v1.1.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.0 // indirect\n\tgithub.com/inconshreveable/log15 v0.0.0-20201112154412-8562bdadbbac // indirect\n\tgithub.com/mattn/go-isatty v0.0.14 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgolang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.2001953125,
          "content": "github.com/BurntSushi/toml v1.1.0 h1:ksErzDEI1khOiGPgpwuI7x2ebx/uXQNw7xJpn9Eq1+I=\ngithub.com/BurntSushi/toml v1.1.0/go.mod h1:CxXYINrC8qIiEnFrOxCa7Jy5BFHlXnUU2pbicEuybxQ=\ngithub.com/bradfitz/gomemcache v0.0.0-20220106215444-fb4bf637b56d h1:pVrfxiGfwelyab6n21ZBkbkmbevaf+WvMIiR7sr97hw=\ngithub.com/bradfitz/gomemcache v0.0.0-20220106215444-fb4bf637b56d/go.mod h1:H0wQNHz2YrLsuXOZozoeDmnHXkNCRmMW0gwFWDfEZDA=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fsnotify/fsnotify v1.5.1 h1:mZcQUHVQUQWoPXXtuf9yuEXKudkV2sx1E06UadKWpgI=\ngithub.com/fsnotify/fsnotify v1.5.1/go.mod h1:T3375wBYaZdLLcVNkcVbzGHY7f1l/uK5T5Ai1i3InKU=\ngithub.com/go-stack/stack v1.8.1 h1:ntEHSVwIt7PNXNpgPmVfMrNhLtgjlmnZha2kOpuRiDw=\ngithub.com/go-stack/stack v1.8.1/go.mod h1:dcoOX6HbPZSZptuspn9bctJ+N/CnF5gGygcUP3XYfe4=\ngithub.com/gomodule/redigo v1.8.8 h1:f6cXq6RRfiyrOJEV7p3JhLDlmawGBVBBP1MggY8Mo4E=\ngithub.com/gomodule/redigo v1.8.8/go.mod h1:7ArFNvsTjH8GMMzB4uy1snslv2BwmginuMs06a1uzZE=\ngithub.com/google/uuid v1.3.0 h1:t6JiXgmwXMjEs8VusXIJk2BXHsn+wx8BZdTaoZ5fu7I=\ngithub.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/inconshreveable/log15 v0.0.0-20201112154412-8562bdadbbac h1:n1DqxAo4oWPMvH1+v+DLYlMCecgumhhgnxAPdqDIFHI=\ngithub.com/inconshreveable/log15 v0.0.0-20201112154412-8562bdadbbac/go.mod h1:cOaXtrgN4ScfRrD9Bre7U1thNq5RtJ8ZoP4iXVGRj6o=\ngithub.com/mattn/go-colorable v0.1.12 h1:jF+Du6AlPIjs2BiUiQlKOX0rt3SujHxPnksPKZbaA40=\ngithub.com/mattn/go-colorable v0.1.12/go.mod h1:u5H1YNBxpqRaxsYJYSkiCWKzEfiAb1Gb520KVy5xxl4=\ngithub.com/mattn/go-isatty v0.0.14 h1:yVuAays6BHfxijgZPzw+3Zlu5yQgKGP2/hcQbHb7S9Y=\ngithub.com/mattn/go-isatty v0.0.14/go.mod h1:7GGIvUiUoEMVVmxf/4nioHXj79iQHKdU27kJ6hsGG94=\ngithub.com/patrickmn/go-cache v2.1.0+incompatible h1:HRMgzkcYKYpi3C8ajMPV8OFXaaRUnok+kx1WdO15EQc=\ngithub.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/revel/config v1.0.0 h1:UAzLPQ+x9nJeP6a+H93G+AKEosg3OO2oVLBXK9oSN2U=\ngithub.com/revel/config v1.0.0/go.mod h1:GT4a9px5kDGRqLizcw/md0QFErrhen76toz4qS3oIoI=\ngithub.com/revel/log15 v2.11.20+incompatible h1:JkA4tbwIo/UGEMumY50zndKq816RQW3LQ0wIpRc+32U=\ngithub.com/revel/log15 v2.11.20+incompatible/go.mod h1:l0WmLRs+IM1hBl4noJiBc2tZQiOgZyXzS1mdmFt+5Gc=\ngithub.com/revel/pathtree v0.0.0-20140121041023-41257a1839e9 h1:/d6kfjzjyx19ieWqMOXHSTLFuRxLOH15ZubtcAXExKw=\ngithub.com/revel/pathtree v0.0.0-20140121041023-41257a1839e9/go.mod h1:TmlwoRLDvgRjoTe6rbsxIaka/CulzYrgfef7iNJcEWY=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1 h1:5TQK59W5E3v0r2duFAb7P95B6hEeOyEnHRa8MjYSMTY=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/xeonx/timeago v1.0.0-rc4 h1:9rRzv48GlJC0vm+iBpLcWAr8YbETyN9Vij+7h2ammz4=\ngithub.com/xeonx/timeago v1.0.0-rc4/go.mod h1:qDLrYEFynLO7y5Ho7w3GwgtYgpy5UfhcXIIQvMKVDkA=\ngolang.org/x/net v0.0.0-20220412020605-290c469a71a5 h1:bRb386wvrE+oBNdF1d/Xh9mQrfQ4ecYhW5qJ5GvTGT4=\ngolang.org/x/net v0.0.0-20220412020605-290c469a71a5/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210927094055-39ccf1dd6fa6/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e h1:fLOSk5Q00efkSvAm+4xcoXD+RRmLmmulPn5I3Y9F2EM=\ngolang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/natefinch/lumberjack.v2 v2.0.0 h1:1Lc07Kr7qY4U2YPouBjpCLxpiyxIVoxqXgkXLknAOE8=\ngopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=\ngopkg.in/stack.v0 v0.0.0-20141108040640-9b43fcefddd0 h1:lMH45EKqD8Nf6LwoF+43YOKjOAEEHQRVgDyG8RCV4MU=\ngopkg.in/stack.v0 v0.0.0-20141108040640-9b43fcefddd0/go.mod h1:kl/bNzW/jgTgUOCGDj3XPn9/Hbfhw6pjfBRUnaTioFQ=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "http.go",
          "type": "blob",
          "size": 13.07421875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Request is Revel's HTTP request object structure.\ntype Request struct {\n\tIn              ServerRequest   // The server request\n\tHeader          *RevelHeader    // The revel header\n\tContentType     string          // The content type\n\tFormat          string          // The output format \"html\", \"xml\", \"json\", or \"txt\"\n\tAcceptLanguages AcceptLanguages // The languages to accept\n\tLocale          string          // THe locale\n\tWebSocket       ServerWebSocket // The websocket\n\tMethod          string          // The method\n\tRemoteAddr      string          // The remote address\n\tHost            string          // The host\n\t// URL request path from the server (built)\n\tURL *url.URL // The url\n\t// DEPRECATED use GetForm()\n\tForm url.Values // The Form\n\t// DEPRECATED use GetMultipartForm()\n\tMultipartForm *MultipartForm // The multipart form\n\tcontroller    *Controller    // The controller, so some of this data can be fetched\n}\n\nvar (\n\tFORM_NOT_FOUND = errors.New(\"Form Not Found\")\n\thttpLog        = RevelLog.New(\"section\", \"http\")\n)\n\n// Response is Revel's HTTP response object structure.\ntype Response struct {\n\tStatus      int\n\tContentType string\n\tOut         OutResponse\n\twriter      io.Writer\n}\n\n// The output response.\ntype OutResponse struct {\n\t// internalHeader.Server Set by ServerResponse.Get(HTTP_SERVER_HEADER), saves calling the get every time the header needs to be written to\n\tinternalHeader *RevelHeader   // The internal header\n\tServer         ServerResponse // The server response\n\tresponse       *Response      // The response\n}\n\n// The header defined in Revel.\ntype RevelHeader struct {\n\tServer ServerHeader // The server\n}\n\n// NewResponse wraps ServerResponse inside a Revel's Response and returns it.\nfunc NewResponse(w ServerResponse) (r *Response) {\n\tr = &Response{Out: OutResponse{Server: w, internalHeader: &RevelHeader{}}}\n\tr.Out.response = r\n\treturn r\n}\n\n// NewRequest returns a Revel's HTTP request instance with given HTTP instance.\nfunc NewRequest(r ServerRequest) *Request {\n\treq := &Request{Header: &RevelHeader{}}\n\tif r != nil {\n\t\treq.SetRequest(r)\n\t}\n\treturn req\n}\n\nfunc (req *Request) SetRequest(r ServerRequest) {\n\treq.In = r\n\tif h, e := req.In.Get(HTTP_SERVER_HEADER); e == nil {\n\t\treq.Header.Server = h.(ServerHeader)\n\t}\n\n\treq.URL, _ = req.GetValue(HTTP_URL).(*url.URL)\n\treq.ContentType = ResolveContentType(req)\n\treq.Format = ResolveFormat(req)\n\treq.AcceptLanguages = ResolveAcceptLanguage(req)\n\treq.Method, _ = req.GetValue(HTTP_METHOD).(string)\n\treq.RemoteAddr, _ = req.GetValue(HTTP_REMOTE_ADDR).(string)\n\treq.Host, _ = req.GetValue(HTTP_HOST).(string)\n}\n\n// Returns a cookie.\nfunc (req *Request) Cookie(key string) (ServerCookie, error) {\n\tif req.Header.Server != nil {\n\t\treturn req.Header.Server.GetCookie(key)\n\t}\n\treturn nil, http.ErrNoCookie\n}\n\n// Fetch the requested URI.\nfunc (req *Request) GetRequestURI() string {\n\turi, _ := req.GetValue(HTTP_REQUEST_URI).(string)\n\treturn uri\n}\n\n// Fetch the query.\nfunc (req *Request) GetQuery() (v url.Values) {\n\tv, _ = req.GetValue(ENGINE_PARAMETERS).(url.Values)\n\treturn\n}\n\n// Fetch the path.\nfunc (req *Request) GetPath() (path string) {\n\tpath, _ = req.GetValue(ENGINE_PATH).(string)\n\treturn\n}\n\n// Fetch the body.\nfunc (req *Request) GetBody() (body io.Reader) {\n\tbody, _ = req.GetValue(HTTP_BODY).(io.Reader)\n\treturn\n}\n\n// Fetch the context.\nfunc (req *Request) Context() (c context.Context) {\n\tc, _ = req.GetValue(HTTP_REQUEST_CONTEXT).(context.Context)\n\treturn\n}\n\n// Deprecated use controller.Params.Get().\nfunc (req *Request) FormValue(key string) (value string) {\n\treturn req.controller.Params.Get(key)\n}\n\n// Deprecated use controller.Params.Form[Key].\nfunc (req *Request) PostFormValue(key string) (value string) {\n\tvalueList := req.controller.Params.Form[key]\n\tif len(valueList) > 0 {\n\t\tvalue = valueList[0]\n\t}\n\treturn\n}\n\n// Deprecated use GetForm() instead.\nfunc (req *Request) ParseForm() (e error) {\n\tif req.Form == nil {\n\t\treq.Form, e = req.GetForm()\n\t}\n\treturn\n}\n\nfunc (req *Request) GetForm() (url.Values, error) {\n\tif form, err := req.In.Get(HTTP_FORM); err != nil {\n\t\treturn nil, err\n\t} else if values, found := form.(url.Values); found {\n\t\treq.Form = values\n\t\treturn values, nil\n\t}\n\treturn nil, FORM_NOT_FOUND\n}\n\n// Deprecated for backwards compatibility only.\ntype MultipartForm struct {\n\tFile   map[string][]*multipart.FileHeader\n\tValue  url.Values\n\torigin ServerMultipartForm\n}\n\nfunc (req *Request) MultipartReader() (*multipart.Reader, error) {\n\treturn nil, errors.New(\"MultipartReader not supported, use controller.Param\")\n}\n\n// Deprecated for backwards compatibility only.\nfunc newMultipareForm(s ServerMultipartForm) (f *MultipartForm) {\n\treturn &MultipartForm{File: s.GetFiles(), Value: s.GetValues(), origin: s}\n}\n\n// Deprecated use GetMultipartForm() instead.\nfunc (req *Request) ParseMultipartForm(_ int64) (e error) {\n\tvar s ServerMultipartForm\n\tif s, e = req.GetMultipartForm(); e == nil {\n\t\treq.MultipartForm = newMultipareForm(s)\n\t}\n\treturn\n}\n\n// Return the args for the controller.\nfunc (req *Request) Args() map[string]interface{} {\n\treturn req.controller.Args\n}\n\n// Return a multipart form.\nfunc (req *Request) GetMultipartForm() (ServerMultipartForm, error) {\n\tif form, err := req.In.Get(HTTP_MULTIPART_FORM); err != nil {\n\t\treturn nil, err\n\t} else if values, found := form.(ServerMultipartForm); found {\n\t\treturn values, nil\n\t}\n\treturn nil, FORM_NOT_FOUND\n}\n\n// Destroy the request.\nfunc (req *Request) Destroy() {\n\treq.In = nil\n\treq.ContentType = \"\"\n\treq.Format = \"\"\n\treq.AcceptLanguages = nil\n\treq.Method = \"\"\n\treq.RemoteAddr = \"\"\n\treq.Host = \"\"\n\treq.Header.Destroy()\n\treq.URL = nil\n\treq.Form = nil\n\treq.MultipartForm = nil\n}\n\n// Set the server response.\nfunc (resp *Response) SetResponse(r ServerResponse) {\n\tresp.Out.Server = r\n\tif h, e := r.Get(HTTP_SERVER_HEADER); e == nil {\n\t\tresp.Out.internalHeader.Server, _ = h.(ServerHeader)\n\t}\n}\n\n// Destroy the output response.\nfunc (o *OutResponse) Destroy() {\n\to.response = nil\n\to.internalHeader.Destroy()\n}\n\n// Destroy the RevelHeader.\nfunc (h *RevelHeader) Destroy() {\n\th.Server = nil\n}\n\n// Destroy the Response.\nfunc (resp *Response) Destroy() {\n\tresp.Out.Destroy()\n\tresp.Status = 0\n\tresp.ContentType = \"\"\n\tresp.writer = nil\n}\n\n// UserAgent returns the client's User-Agent header string.\nfunc (r *Request) UserAgent() string {\n\treturn r.Header.Get(\"User-Agent\")\n}\n\n// Referer returns the client's Referer header string.\nfunc (req *Request) Referer() string {\n\treturn req.Header.Get(\"Referer\")\n}\n\n// Return the httpheader for the key.\nfunc (req *Request) GetHttpHeader(key string) string {\n\treturn req.Header.Get(key)\n}\n\n// Return the value from the server.\nfunc (r *Request) GetValue(key int) (value interface{}) {\n\tvalue, _ = r.In.Get(key)\n\treturn\n}\n\n// WriteHeader writes the header (for now, just the status code).\n// The status may be set directly by the application (c.Response.Status = 501).\n// If it isn't, then fall back to the provided status code.\nfunc (resp *Response) WriteHeader(defaultStatusCode int, defaultContentType string) {\n\tif resp.ContentType == \"\" {\n\t\tresp.ContentType = defaultContentType\n\t}\n\tresp.Out.internalHeader.Set(\"Content-Type\", resp.ContentType)\n\tif resp.Status == 0 {\n\t\tresp.Status = defaultStatusCode\n\t}\n\tresp.SetStatus(resp.Status)\n}\n\nfunc (resp *Response) SetStatus(statusCode int) {\n\tif resp.Out.internalHeader.Server != nil {\n\t\tresp.Out.internalHeader.Server.SetStatus(statusCode)\n\t} else {\n\t\tresp.Out.Server.Set(ENGINE_RESPONSE_STATUS, statusCode)\n\t}\n}\n\n// Return the writer.\nfunc (resp *Response) GetWriter() (writer io.Writer) {\n\twriter = resp.writer\n\tif writer == nil {\n\t\tif w, e := resp.Out.Server.Get(ENGINE_WRITER); e == nil {\n\t\t\twriter, resp.writer = w.(io.Writer), w.(io.Writer)\n\t\t}\n\t}\n\n\treturn\n}\n\n// Replace the writer.\nfunc (resp *Response) SetWriter(writer io.Writer) bool {\n\tresp.writer = writer\n\t// Leave it up to the engine to flush and close the writer\n\treturn resp.Out.Server.Set(ENGINE_WRITER, writer)\n}\n\n// Passes full control to the response to the caller - terminates any initial writes.\nfunc (resp *Response) GetStreamWriter() (writer StreamWriter) {\n\tif w, e := resp.Out.Server.Get(HTTP_STREAM_WRITER); e == nil {\n\t\twriter = w.(StreamWriter)\n\t}\n\treturn\n}\n\n// Return the header.\nfunc (o *OutResponse) Header() *RevelHeader {\n\treturn o.internalHeader\n}\n\n// Write the header out.\nfunc (o *OutResponse) Write(data []byte) (int, error) {\n\treturn o.response.GetWriter().Write(data)\n}\n\n// Set a value in the header.\nfunc (h *RevelHeader) Set(key, value string) {\n\tif h.Server != nil {\n\t\th.Server.Set(key, value)\n\t}\n}\n\n// Add a key to the header.\nfunc (h *RevelHeader) Add(key, value string) {\n\tif h.Server != nil {\n\t\th.Server.Add(key, value)\n\t}\n}\n\n// Set a cookie in the header.\nfunc (h *RevelHeader) SetCookie(cookie string) {\n\tif h.Server != nil {\n\t\th.Server.SetCookie(cookie)\n\t}\n}\n\n// Set the status for the header.\nfunc (h *RevelHeader) SetStatus(status int) {\n\tif h.Server != nil {\n\t\th.Server.SetStatus(status)\n\t}\n}\n\n// Get a key from the header.\nfunc (h *RevelHeader) Get(key string) (value string) {\n\tvalues := h.GetAll(key)\n\tif len(values) > 0 {\n\t\tvalue = values[0]\n\t}\n\treturn\n}\n\n// GetAll returns []string of items (the header split by a comma).\nfunc (h *RevelHeader) GetAll(key string) (values []string) {\n\tif h.Server != nil {\n\t\tvalues = h.Server.Get(key)\n\t}\n\treturn\n}\n\n// ResolveContentType gets the content type.\n// e.g. From \"multipart/form-data; boundary=--\" to \"multipart/form-data\"\n// If none is specified, returns \"text/html\" by default.\nfunc ResolveContentType(req *Request) string {\n\tcontentType := req.Header.Get(\"Content-Type\")\n\tif contentType == \"\" {\n\t\treturn \"text/html\"\n\t}\n\treturn strings.ToLower(strings.TrimSpace(strings.Split(contentType, \";\")[0]))\n}\n\n// ResolveFormat maps the request's Accept MIME type declaration to\n// a Request.Format attribute, specifically \"html\", \"xml\", \"json\", or \"txt\",\n// returning a default of \"html\" when Accept header cannot be mapped to a\n// value above.\nfunc ResolveFormat(req *Request) string {\n\text := strings.ToLower(filepath.Ext(req.GetPath()))\n\tswitch ext {\n\tcase \".html\":\n\t\treturn \"html\"\n\tcase \".json\":\n\t\treturn \"json\"\n\tcase \".xml\":\n\t\treturn \"xml\"\n\tcase \".txt\":\n\t\treturn \"txt\"\n\t}\n\n\taccept := req.GetHttpHeader(\"accept\")\n\n\tswitch {\n\tcase accept == \"\",\n\t\tstrings.HasPrefix(accept, \"*/*\"), // */\n\t\tstrings.Contains(accept, \"application/xhtml\"),\n\t\tstrings.Contains(accept, \"text/html\"):\n\t\treturn \"html\"\n\tcase strings.Contains(accept, \"application/json\"),\n\t\tstrings.Contains(accept, \"text/javascript\"),\n\t\tstrings.Contains(accept, \"application/javascript\"):\n\t\treturn \"json\"\n\tcase strings.Contains(accept, \"application/xml\"),\n\t\tstrings.Contains(accept, \"text/xml\"):\n\t\treturn \"xml\"\n\tcase strings.Contains(accept, \"text/plain\"):\n\t\treturn \"txt\"\n\t}\n\n\treturn \"html\"\n}\n\n// AcceptLanguage is a single language from the Accept-Language HTTP header.\ntype AcceptLanguage struct {\n\tLanguage string\n\tQuality  float32\n}\n\n// AcceptLanguages is collection of sortable AcceptLanguage instances.\ntype AcceptLanguages []AcceptLanguage\n\nfunc (al AcceptLanguages) Len() int           { return len(al) }\nfunc (al AcceptLanguages) Swap(i, j int)      { al[i], al[j] = al[j], al[i] }\nfunc (al AcceptLanguages) Less(i, j int) bool { return al[i].Quality > al[j].Quality }\nfunc (al AcceptLanguages) String() string {\n\toutput := bytes.NewBufferString(\"\")\n\tfor i, language := range al {\n\t\tif _, err := output.WriteString(fmt.Sprintf(\"%s (%1.1f)\", language.Language, language.Quality)); err != nil {\n\t\t\thttpLog.Error(\"String: WriteString failed:\", \"error\", err)\n\t\t}\n\t\tif i != len(al)-1 {\n\t\t\tif _, err := output.WriteString(\", \"); err != nil {\n\t\t\t\thttpLog.Error(\"String: WriteString failed:\", \"error\", err)\n\t\t\t}\n\t\t}\n\t}\n\treturn output.String()\n}\n\n// ResolveAcceptLanguage returns a sorted list of Accept-Language\n// header values.\n//\n// The results are sorted using the quality defined in the header for each\n// language range with the most qualified language range as the first\n// element in the slice.\n//\n// See the HTTP header fields specification\n// (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4) for more details.\nfunc ResolveAcceptLanguage(req *Request) AcceptLanguages {\n\theader := req.Header.Get(\"Accept-Language\")\n\tif header == \"\" {\n\t\treturn req.AcceptLanguages\n\t}\n\n\tacceptLanguageHeaderValues := strings.Split(header, \",\")\n\tacceptLanguages := make(AcceptLanguages, len(acceptLanguageHeaderValues))\n\n\tfor i, languageRange := range acceptLanguageHeaderValues {\n\t\tif qualifiedRange := strings.Split(languageRange, \";q=\"); len(qualifiedRange) == 2 {\n\t\t\tquality, err := strconv.ParseFloat(qualifiedRange[1], 32)\n\t\t\tif err != nil {\n\t\t\t\thttpLog.Warn(\"Detected malformed Accept-Language header quality in  assuming quality is 1\", \"languageRange\", languageRange)\n\t\t\t\tacceptLanguages[i] = AcceptLanguage{qualifiedRange[0], 1}\n\t\t\t} else {\n\t\t\t\tacceptLanguages[i] = AcceptLanguage{qualifiedRange[0], float32(quality)}\n\t\t\t}\n\t\t} else {\n\t\t\tacceptLanguages[i] = AcceptLanguage{languageRange, 1}\n\t\t}\n\t}\n\n\tsort.Sort(acceptLanguages)\n\treturn acceptLanguages\n}\n"
        },
        {
          "name": "i18n.go",
          "type": "blob",
          "size": 7.828125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/revel/config\"\n)\n\nconst (\n\t// CurrentLocaleViewArg the key for the current locale view arg value.\n\tCurrentLocaleViewArg = \"currentLocale\"\n\n\tmessageFilesDirectory  = \"messages\"\n\tmessageFilePattern     = `^\\w+\\.[a-zA-Z]{2}$`\n\tdefaultUnknownFormat   = \"??? %s ???\"\n\tunknownFormatConfigKey = \"i18n.unknown_format\"\n\tdefaultLanguageOption  = \"i18n.default_language\"\n\tlocaleCookieConfigKey  = \"i18n.cookie\"\n)\n\nvar (\n\t// All currently loaded message configs.\n\tmessages            map[string]*config.Config\n\tlocaleParameterName string\n\ti18nLog             = RevelLog.New(\"section\", \"i18n\")\n)\n\n// MessageFunc allows you to override the translation interface.\n//\n// Set this to your own function that translates to the current locale.\n// This allows you to set up your own loading and logging of translated texts.\n//\n// See Message(...) in i18n.go for example of function.\nvar MessageFunc = Message\n\n// MessageLanguages returns all currently loaded message languages.\nfunc MessageLanguages() []string {\n\tlanguages := make([]string, len(messages))\n\ti := 0\n\tfor language := range messages {\n\t\tlanguages[i] = language\n\t\ti++\n\t}\n\treturn languages\n}\n\n// Message performs a message look-up for the given locale and message using the given arguments.\n//\n// When either an unknown locale or message is detected, a specially formatted string is returned.\nfunc Message(locale, message string, args ...interface{}) string {\n\tlanguage, region := parseLocale(locale)\n\tunknownValueFormat := getUnknownValueFormat()\n\n\tmessageConfig, knownLanguage := messages[language]\n\tif !knownLanguage {\n\t\ti18nLog.Debugf(\"Unsupported language for locale '%s' and message '%s', trying default language\", locale, message)\n\n\t\tif defaultLanguage, found := Config.String(defaultLanguageOption); found {\n\t\t\ti18nLog.Debugf(\"Using default language '%s'\", defaultLanguage)\n\n\t\t\tmessageConfig, knownLanguage = messages[defaultLanguage]\n\t\t\tif !knownLanguage {\n\t\t\t\ti18nLog.Debugf(\"Unsupported default language for locale '%s' and message '%s'\", defaultLanguage, message)\n\t\t\t\treturn fmt.Sprintf(unknownValueFormat, message)\n\t\t\t}\n\t\t} else {\n\t\t\ti18nLog.Warnf(\"Unable to find default language option (%s); messages for unsupported locales will never be translated\", defaultLanguageOption)\n\t\t\treturn fmt.Sprintf(unknownValueFormat, message)\n\t\t}\n\t}\n\n\t// This works because unlike the goconfig documentation suggests it will actually\n\t// try to resolve message in DEFAULT if it did not find it in the given section.\n\tvalue, err := messageConfig.String(region, message)\n\tif err != nil {\n\t\ti18nLog.Warnf(\"Unknown message '%s' for locale '%s'\", message, locale)\n\t\treturn fmt.Sprintf(unknownValueFormat, message)\n\t}\n\n\tif len(args) > 0 {\n\t\ti18nLog.Debugf(\"Arguments detected, formatting '%s' with %v\", value, args)\n\t\tsafeArgs := make([]interface{}, 0, len(args))\n\t\tfor _, arg := range args {\n\t\t\tswitch a := arg.(type) {\n\t\t\tcase template.HTML:\n\t\t\t\tsafeArgs = append(safeArgs, a)\n\t\t\tcase string:\n\t\t\t\tsafeArgs = append(safeArgs, template.HTML(template.HTMLEscapeString(a)))\n\t\t\tdefault:\n\t\t\t\tsafeArgs = append(safeArgs, a)\n\t\t\t}\n\t\t}\n\t\tvalue = fmt.Sprintf(value, safeArgs...)\n\t}\n\n\treturn value\n}\n\nfunc parseLocale(locale string) (language, region string) {\n\tif strings.Contains(locale, \"-\") {\n\t\tlanguageAndRegion := strings.Split(locale, \"-\")\n\t\treturn languageAndRegion[0], languageAndRegion[1]\n\t}\n\n\treturn locale, \"\"\n}\n\n// Retrieve message format or default format when i18n message is missing.\nfunc getUnknownValueFormat() string {\n\treturn Config.StringDefault(unknownFormatConfigKey, defaultUnknownFormat)\n}\n\n// Recursively read and cache all available messages from all message files on the given path.\nfunc loadMessages(path string) {\n\tmessages = make(map[string]*config.Config)\n\n\t// Read in messages from the modules. Load the module messges first,\n\t// so that it can be override in parent application\n\tfor _, module := range Modules {\n\t\ti18nLog.Debug(\"Importing messages from module:\", \"importpath\", module.ImportPath)\n\t\tif err := Walk(filepath.Join(module.Path, messageFilesDirectory), loadMessageFile); err != nil &&\n\t\t\t!os.IsNotExist(err) {\n\t\t\ti18nLog.Error(\"Error reading messages files from module:\", \"error\", err)\n\t\t}\n\t}\n\n\tif err := Walk(path, loadMessageFile); err != nil && !os.IsNotExist(err) {\n\t\ti18nLog.Error(\"Error reading messages files:\", \"error\", err)\n\t}\n}\n\n// Load a single message file.\nfunc loadMessageFile(path string, info os.FileInfo, osError error) error {\n\tif osError != nil {\n\t\treturn osError\n\t}\n\tif info.IsDir() {\n\t\treturn nil\n\t}\n\n\tif matched, _ := regexp.MatchString(messageFilePattern, info.Name()); matched {\n\t\tmessageConfig, err := parseMessagesFile(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlocale := parseLocaleFromFileName(info.Name())\n\n\t\t// If we have already parsed a message file for this locale, merge both\n\t\tif _, exists := messages[locale]; exists {\n\t\t\tmessages[locale].Merge(messageConfig)\n\t\t\ti18nLog.Debugf(\"Successfully merged messages for locale '%s'\", locale)\n\t\t} else {\n\t\t\tmessages[locale] = messageConfig\n\t\t}\n\n\t\ti18nLog.Debug(\"Successfully loaded messages from file\", \"file\", info.Name())\n\t} else {\n\t\ti18nLog.Warn(\"Ignoring file because it did not have a valid extension\", \"file\", info.Name())\n\t}\n\n\treturn nil\n}\n\nfunc parseMessagesFile(path string) (messageConfig *config.Config, err error) {\n\tmessageConfig, err = config.ReadDefault(path)\n\treturn\n}\n\nfunc parseLocaleFromFileName(file string) string {\n\textension := filepath.Ext(file)[1:]\n\treturn strings.ToLower(extension)\n}\n\nfunc init() {\n\tOnAppStart(func() {\n\t\tloadMessages(filepath.Join(BasePath, messageFilesDirectory))\n\t\tlocaleParameterName = Config.StringDefault(\"i18n.locale.parameter\", \"\")\n\t}, 0)\n}\n\nfunc I18nFilter(c *Controller, fc []Filter) {\n\tfoundLocale := false\n\t// Search for a parameter first\n\tif localeParameterName != \"\" {\n\t\tif locale, found := c.Params.Values[localeParameterName]; found && len(locale[0]) > 0 {\n\t\t\tsetCurrentLocaleControllerArguments(c, locale[0])\n\t\t\tfoundLocale = true\n\t\t\ti18nLog.Debug(\"Found locale parameter value: \", \"locale\", locale[0])\n\t\t}\n\t}\n\tif !foundLocale {\n\t\tif foundCookie, cookieValue := hasLocaleCookie(c.Request); foundCookie {\n\t\t\ti18nLog.Debug(\"Found locale cookie value: \", \"cookie\", cookieValue)\n\t\t\tsetCurrentLocaleControllerArguments(c, cookieValue)\n\t\t} else if foundHeader, headerValue := hasAcceptLanguageHeader(c.Request); foundHeader {\n\t\t\ti18nLog.Debug(\"Found Accept-Language header value: \", \"header\", headerValue)\n\t\t\tsetCurrentLocaleControllerArguments(c, headerValue)\n\t\t} else {\n\t\t\ti18nLog.Debug(\"Unable to find locale in cookie or header, using empty string\")\n\t\t\tsetCurrentLocaleControllerArguments(c, \"\")\n\t\t}\n\t}\n\tfc[0](c, fc[1:])\n}\n\n// Set the current locale controller argument (CurrentLocaleControllerArg) with the given locale.\nfunc setCurrentLocaleControllerArguments(c *Controller, locale string) {\n\tc.Request.Locale = locale\n\tc.ViewArgs[CurrentLocaleViewArg] = locale\n}\n\n// Determine whether the given request has valid Accept-Language value.\n//\n// Assumes that the accept languages stored in the request are sorted according to quality, with top\n// quality first in the slice.\nfunc hasAcceptLanguageHeader(request *Request) (bool, string) {\n\tif request.AcceptLanguages != nil && len(request.AcceptLanguages) > 0 {\n\t\treturn true, request.AcceptLanguages[0].Language\n\t}\n\n\treturn false, \"\"\n}\n\n// Determine whether the given request has a valid language cookie value.\nfunc hasLocaleCookie(request *Request) (bool, string) {\n\tif request != nil {\n\t\tname := Config.StringDefault(localeCookieConfigKey, CookiePrefix+\"_LANG\")\n\t\tcookie, err := request.Cookie(name)\n\t\tif err == nil {\n\t\t\treturn true, cookie.GetValue()\n\t\t}\n\t\ti18nLog.Debug(\"Unable to read locale cookie \", \"name\", name, \"error\", err)\n\t}\n\n\treturn false, \"\"\n}\n"
        },
        {
          "name": "i18n_test.go",
          "type": "blob",
          "size": 9.6484375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/revel/config\"\n\t\"github.com/revel/revel/logger\"\n)\n\nconst (\n\ttestDataPath   string = \"testdata/i18n\"\n\ttestConfigPath string = \"testdata/i18n/config\"\n\ttestConfigName string = \"test_app.conf\"\n)\n\nfunc TestI18nLoadMessages(t *testing.T) {\n\tloadMessages(testDataPath)\n\n\t// Assert that we have the expected number of languages\n\tif len(MessageLanguages()) != 2 {\n\t\tt.Fatalf(\"Expected messages to contain no more or less than 2 languages, instead there are %d languages\", len(MessageLanguages()))\n\t}\n}\n\nfunc TestI18nMessage(t *testing.T) {\n\tloadMessages(testDataPath)\n\tloadTestI18nConfig(t)\n\n\t// Assert that we can get a message and we get the expected return value\n\tif message := Message(\"nl\", \"greeting\"); message != \"Hallo\" {\n\t\tt.Errorf(\"Message 'greeting' for locale 'nl' (%s) does not have the expected value\", message)\n\t}\n\tif message := Message(\"en\", \"greeting\"); message != \"Hello\" {\n\t\tt.Errorf(\"Message 'greeting' for locale 'en' (%s) does not have the expected value\", message)\n\t}\n\tif message := Message(\"en\", \"folded\"); message != \"Greeting is 'Hello'\" {\n\t\tt.Error(\"Unexpected unfolded message: \", message)\n\t}\n\tif message := Message(\"en\", \"arguments.string\", \"Vincent Hanna\"); message != \"My name is Vincent Hanna\" {\n\t\tt.Errorf(\"Message 'arguments.string' for locale 'en' (%s) does not have the expected value\", message)\n\t}\n\tif message := Message(\"en\", \"arguments.hex\", 1234567, 1234567); message != \"The number 1234567 in hexadecimal notation would be 12d687\" {\n\t\tt.Errorf(\"Message 'arguments.hex' for locale 'en' (%s) does not have the expected value\", message)\n\t}\n\tif message := Message(\"en\", \"folded.arguments\", 12345); message != \"Rob is 12345 years old\" {\n\t\tt.Errorf(\"Message 'folded.arguments' for locale 'en' (%s) does not have the expected value\", message)\n\t}\n\tif message := Message(\"en-AU\", \"greeting\"); message != \"G'day\" {\n\t\tt.Errorf(\"Message 'greeting' for locale 'en-AU' (%s) does not have the expected value\", message)\n\t}\n\tif message := Message(\"en-AU\", \"only_exists_in_default\"); message != \"Default\" {\n\t\tt.Errorf(\"Message 'only_exists_in_default' for locale 'en-AU' (%s) does not have the expected value\", message)\n\t}\n\n\t// Assert that message merging works\n\tif message := Message(\"en\", \"greeting2\"); message != \"Yo!\" {\n\t\tt.Errorf(\"Message 'greeting2' for locale 'en' (%s) does not have the expected value\", message)\n\t}\n\n\t// Assert that we get the expected return value for a locale that doesn't exist\n\tif message := Message(\"unknown locale\", \"message\"); message != \"??? message ???\" {\n\t\tt.Error(\"Locale 'unknown locale' is not supposed to exist\")\n\t}\n\t// Assert that we get the expected return value for a message that doesn't exist\n\tif message := Message(\"nl\", \"unknown message\"); message != \"??? unknown message ???\" {\n\t\tt.Error(\"Message 'unknown message' is not supposed to exist\")\n\t}\n\t// XSS\n\tif message := Message(\"en\", \"arguments.string\", \"<img src=a onerror=alert(1) />\"); message != \"My name is &lt;img src=a onerror=alert(1) /&gt;\" {\n\t\tt.Error(\"XSS protection for messages is broken:\", message)\n\t}\n\t// Avoid escaping HTML\n\tif message := Message(\"en\", \"arguments.string\", template.HTML(\"<img src=a onerror=alert(1) />\")); message != \"My name is <img src=a onerror=alert(1) />\" {\n\t\tt.Error(\"Passing safe HTML to message is broken:\", message)\n\t}\n}\n\nfunc TestI18nMessageWithDefaultLocale(t *testing.T) {\n\tloadMessages(testDataPath)\n\tloadTestI18nConfig(t)\n\n\tif message := Message(\"doesn't exist\", \"greeting\"); message != \"Hello\" {\n\t\tt.Errorf(\"Expected message '%s' for unknown locale to be default '%s' but was '%s'\", \"greeting\", \"Hello\", message)\n\t}\n\tif message := Message(\"doesn't exist\", \"unknown message\"); message != \"??? unknown message ???\" {\n\t\tt.Error(\"Message 'unknown message' is not supposed to exist in the default language\")\n\t}\n}\n\nfunc TestHasLocaleCookie(t *testing.T) {\n\tloadTestI18nConfig(t)\n\n\tif found, value := hasLocaleCookie(buildRequestWithCookie(\"APP_LANG\", \"en\").Request); !found {\n\t\tt.Errorf(\"Expected %s cookie with value '%s' but found nothing or unexpected value '%s'\", \"APP_LANG\", \"en\", value)\n\t}\n\tif found, value := hasLocaleCookie(buildRequestWithCookie(\"APP_LANG\", \"en-US\").Request); !found {\n\t\tt.Errorf(\"Expected %s cookie with value '%s' but found nothing or unexpected value '%s'\", \"APP_LANG\", \"en-US\", value)\n\t}\n\tif found, _ := hasLocaleCookie(buildRequestWithCookie(\"DOESNT_EXIST\", \"en-US\").Request); found {\n\t\tt.Errorf(\"Expected %s cookie to not exist, but apparently it does\", \"DOESNT_EXIST\")\n\t}\n}\n\nfunc TestHasLocaleCookieWithInvalidConfig(t *testing.T) {\n\tloadTestI18nConfigWithoutLanguageCookieOption(t)\n\tif found, _ := hasLocaleCookie(buildRequestWithCookie(\"APP_LANG\", \"en-US\").Request); found {\n\t\tt.Errorf(\"Expected %s cookie to not exist because the configured name is missing\", \"APP_LANG\")\n\t}\n\tif found, _ := hasLocaleCookie(buildRequestWithCookie(\"REVEL_LANG\", \"en-US\").Request); !found {\n\t\tt.Errorf(\"Expected %s cookie to exist\", \"REVEL_LANG\")\n\t}\n}\n\nfunc TestHasAcceptLanguageHeader(t *testing.T) {\n\tif found, value := hasAcceptLanguageHeader(buildRequestWithAcceptLanguages(\"en-US\").Request); !found && value != \"en-US\" {\n\t\tt.Errorf(\"Expected to find Accept-Language header with value '%s', found '%s' instead\", \"en-US\", value)\n\t}\n\tif found, value := hasAcceptLanguageHeader(buildRequestWithAcceptLanguages(\"en-GB\", \"en-US\", \"nl\").Request); !found && value != \"en-GB\" {\n\t\tt.Errorf(\"Expected to find Accept-Language header with value '%s', found '%s' instead\", \"en-GB\", value)\n\t}\n}\n\nfunc TestBeforeRequest(t *testing.T) {\n\tloadTestI18nConfig(t)\n\n\tc := buildEmptyRequest()\n\tif I18nFilter(c, NilChain); c.Request.Locale != \"\" {\n\t\tt.Errorf(\"Expected to find current language '%s' in controller, found '%s' instead\", \"\", c.Request.Locale)\n\t}\n\n\tc = buildRequestWithCookie(\"APP_LANG\", \"en-US\")\n\tif I18nFilter(c, NilChain); c.Request.Locale != \"en-US\" {\n\t\tt.Errorf(\"Expected to find current language '%s' in controller, found '%s' instead\", \"en-US\", c.Request.Locale)\n\t}\n\n\tc = buildRequestWithAcceptLanguages(\"en-GB\", \"en-US\")\n\tif I18nFilter(c, NilChain); c.Request.Locale != \"en-GB\" {\n\t\tt.Errorf(\"Expected to find current language '%s' in controller, found '%s' instead\", \"en-GB\", c.Request.Locale)\n\t}\n}\n\nfunc TestI18nMessageUnknownValueFormat(t *testing.T) {\n\tloadMessages(testDataPath)\n\tloadTestI18nConfigWithUnknowFormatOption(t)\n\n\t// Assert that we can get a message and we get the expected return value\n\tif message := Message(\"en\", \"greeting\"); message != \"Hello\" {\n\t\tt.Errorf(\"Message 'greeting' for locale 'en' (%s) does not have the expected value\", message)\n\t}\n\n\t// Assert that we get the expected return value with original format\n\tif message := Message(\"unknown locale\", \"message\"); message != \"*** message ***\" {\n\t\tt.Error(\"Locale 'unknown locale' is not supposed to exist\")\n\t}\n\tif message := Message(\"nl\", \"unknown message\"); message != \"*** unknown message ***\" {\n\t\tt.Error(\"Message 'unknown message' is not supposed to exist\")\n\t}\n}\n\nfunc BenchmarkI18nLoadMessages(b *testing.B) {\n\texcludeFromTimer(b, func() {\n\t\tRevelLog.SetHandler(logger.FuncHandler(func(r *logger.Record) error {\n\t\t\treturn nil\n\t\t}))\n\t})\n\n\tfor i := 0; i < b.N; i++ {\n\t\tloadMessages(testDataPath)\n\t}\n}\n\nfunc BenchmarkI18nMessage(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tMessage(\"nl\", \"greeting\")\n\t}\n}\n\nfunc BenchmarkI18nMessageWithArguments(b *testing.B) {\n\texcludeFromTimer(b, func() {\n\t\tRevelLog.SetHandler(logger.FuncHandler(func(r *logger.Record) error {\n\t\t\treturn nil\n\t\t}))\n\t})\n\n\tfor i := 0; i < b.N; i++ {\n\t\tMessage(\"en\", \"arguments.string\", \"Vincent Hanna\")\n\t}\n}\n\nfunc BenchmarkI18nMessageWithFoldingAndArguments(b *testing.B) {\n\texcludeFromTimer(b, func() {\n\t\tRevelLog.SetHandler(logger.FuncHandler(func(r *logger.Record) error {\n\t\t\treturn nil\n\t\t}))\n\t})\n\n\tfor i := 0; i < b.N; i++ {\n\t\tMessage(\"en\", \"folded.arguments\", 12345)\n\t}\n}\n\n// Exclude whatever operations the given function performs from the benchmark timer.\nfunc excludeFromTimer(b *testing.B, f func()) {\n\tb.StopTimer()\n\tf()\n\tb.StartTimer()\n}\n\nfunc loadTestI18nConfig(t *testing.T) {\n\tConfPaths = append(ConfPaths, testConfigPath)\n\ttestConfig, err := config.LoadContext(testConfigName, ConfPaths)\n\tif err != nil {\n\t\tt.Fatalf(\"Unable to load test config '%s': %s\", testConfigName, err.Error())\n\t}\n\tConfig = testConfig\n\tCookiePrefix = Config.StringDefault(\"cookie.prefix\", \"REVEL\")\n}\n\nfunc loadTestI18nConfigWithoutLanguageCookieOption(t *testing.T) {\n\tloadTestI18nConfig(t)\n\tConfig.Raw().RemoveOption(\"DEFAULT\", \"i18n.cookie\")\n}\n\nfunc loadTestI18nConfigWithUnknowFormatOption(t *testing.T) {\n\tloadTestI18nConfig(t)\n\tConfig.Raw().AddOption(\"DEFAULT\", \"i18n.unknown_format\", \"*** %s ***\")\n}\n\nfunc buildRequestWithCookie(name, value string) *Controller {\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\tcontroller := NewTestController(nil, httpRequest)\n\n\thttpRequest.AddCookie(&http.Cookie{\n\t\tName:       name,\n\t\tValue:      value,\n\t\tPath:       \"\",\n\t\tDomain:     \"\",\n\t\tExpires:    time.Now(),\n\t\tRawExpires: \"\",\n\t\tMaxAge:     0,\n\t\tSecure:     false,\n\t\tHttpOnly:   false,\n\t\tRaw:        \"\",\n\t\tUnparsed:   nil,\n\t})\n\treturn controller\n}\n\nfunc buildRequestWithAcceptLanguages(acceptLanguages ...string) *Controller {\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\tcontroller := NewTestController(nil, httpRequest)\n\n\trequest := controller.Request\n\tfor _, acceptLanguage := range acceptLanguages {\n\t\trequest.AcceptLanguages = append(request.AcceptLanguages, AcceptLanguage{acceptLanguage, 1})\n\t}\n\treturn controller\n}\n\nfunc buildEmptyRequest() *Controller {\n\thttpRequest, _ := http.NewRequest(\"GET\", \"/\", nil)\n\tcontroller := NewTestController(nil, httpRequest)\n\treturn controller\n}\n"
        },
        {
          "name": "intercept.go",
          "type": "blob",
          "size": 6.86328125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"log\"\n\t\"reflect\"\n\t\"sort\"\n)\n\n// An InterceptorFunc is functionality invoked by the framework BEFORE or AFTER\n// an action.\n//\n// An interceptor may optionally return a Result (instead of nil).  Depending on\n// when the interceptor was invoked, the response is different:\n// 1. BEFORE:  No further interceptors are invoked, and neither is the action.\n// 2. AFTER: Further interceptors are still run.\n// In all cases, any returned Result will take the place of any existing Result.\n//\n// In the BEFORE case, that returned Result is guaranteed to be final, while\n// in the AFTER case it is possible that a further interceptor could emit its\n// own Result.\n//\n// Interceptors are called in the order that they are added.\n//\n// ***\n//\n// Two types of interceptors are provided: Funcs and Methods\n//\n// Func Interceptors may apply to any / all Controllers.\n//\n//   func example(*revel.Controller) revel.Result\n//\n// Method Interceptors are provided so that properties can be set on application\n// controllers.\n//\n//   func (c AppController) example() revel.Result\n//   func (c *AppController) example() revel.Result\n//\ntype InterceptorFunc func(*Controller) Result\n\ntype InterceptorMethod interface{}\n\ntype When int\n\nconst (\n\tBEFORE When = iota\n\tAFTER\n\tPANIC\n\tFINALLY\n)\n\ntype InterceptTarget int\n\nconst (\n\tAllControllers InterceptTarget = iota\n)\n\ntype Interception struct {\n\tWhen When\n\n\tfunction InterceptorFunc\n\tmethod   InterceptorMethod\n\n\tcallable     reflect.Value\n\ttarget       reflect.Type\n\tinterceptAll bool\n}\n\n// Invoke performs the given interception.\n// val is a pointer to the App Controller.\nfunc (i Interception) Invoke(val reflect.Value, target *reflect.Value) reflect.Value {\n\tvar arg reflect.Value\n\tif i.function == nil {\n\t\t// If it's an InterceptorMethod, then we have to pass in the target type.\n\t\targ = *target\n\t} else {\n\t\t// If it's an InterceptorFunc, then the type must be *Controller.\n\t\t// We can find that by following the embedded types up the chain.\n\t\tfor val.Type() != controllerPtrType {\n\t\t\tif val.Kind() == reflect.Ptr {\n\t\t\t\tval = val.Elem()\n\t\t\t}\n\t\t\tval = val.Field(0)\n\t\t}\n\t\targ = val\n\t}\n\n\tvals := i.callable.Call([]reflect.Value{arg})\n\treturn vals[0]\n}\n\nfunc InterceptorFilter(c *Controller, fc []Filter) {\n\tdefer invokeInterceptors(FINALLY, c)\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tinvokeInterceptors(PANIC, c)\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n\t// Invoke the BEFORE interceptors and return early, if we get a result.\n\tinvokeInterceptors(BEFORE, c)\n\tif c.Result != nil {\n\t\treturn\n\t}\n\n\tfc[0](c, fc[1:])\n\tinvokeInterceptors(AFTER, c)\n}\n\nfunc invokeInterceptors(when When, c *Controller) {\n\tvar (\n\t\tapp    = reflect.ValueOf(c.AppController)\n\t\tresult Result\n\t)\n\n\tfor _, intc := range getInterceptors(when, app) {\n\t\tresultValue := intc.Interceptor.Invoke(app, &intc.Target)\n\t\tif !resultValue.IsNil() {\n\t\t\tresult = resultValue.Interface().(Result)\n\t\t}\n\t\tif when == BEFORE && result != nil {\n\t\t\tc.Result = result\n\t\t\treturn\n\t\t}\n\t}\n\tif result != nil {\n\t\tc.Result = result\n\t}\n}\n\nvar interceptors []*Interception\n\n// InterceptFunc installs a general interceptor.\n// This can be applied to any Controller.\n// It must have the signature of:\n//   func example(c *revel.Controller) revel.Result\nfunc InterceptFunc(intc InterceptorFunc, when When, target interface{}) {\n\tinterceptors = append(interceptors, &Interception{\n\t\tWhen:         when,\n\t\tfunction:     intc,\n\t\tcallable:     reflect.ValueOf(intc),\n\t\ttarget:       reflect.TypeOf(target),\n\t\tinterceptAll: target == AllControllers,\n\t})\n}\n\n// InterceptMethod installs an interceptor method that applies to its own Controller.\n//   func (c AppController) example() revel.Result\n//   func (c *AppController) example() revel.Result\nfunc InterceptMethod(intc InterceptorMethod, when When) {\n\tmethodType := reflect.TypeOf(intc)\n\tif methodType.Kind() != reflect.Func || methodType.NumOut() != 1 || methodType.NumIn() != 1 {\n\t\tlog.Fatalln(\"Interceptor method should have signature like\",\n\t\t\t\"'func (c *AppController) example() revel.Result' but was\", methodType)\n\t}\n\n\tinterceptors = append(interceptors, &Interception{\n\t\tWhen:     when,\n\t\tmethod:   intc,\n\t\tcallable: reflect.ValueOf(intc),\n\t\ttarget:   methodType.In(0),\n\t})\n}\n\n// This item is used to provide a sortable set to be returned to the caller. This ensures calls order is maintained\n//\ntype interceptorItem struct {\n\tInterceptor *Interception\n\tTarget      reflect.Value\n\tLevel       int\n}\ntype interceptorItemList []*interceptorItem\n\nfunc (a interceptorItemList) Len() int           { return len(a) }\nfunc (a interceptorItemList) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a interceptorItemList) Less(i, j int) bool { return a[i].Level < a[j].Level }\n\ntype reverseInterceptorItemList []*interceptorItem\n\nfunc (a reverseInterceptorItemList) Len() int           { return len(a) }\nfunc (a reverseInterceptorItemList) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a reverseInterceptorItemList) Less(i, j int) bool { return a[i].Level > a[j].Level }\nfunc getInterceptors(when When, val reflect.Value) interceptorItemList {\n\tresult := interceptorItemList{}\n\tfor _, intc := range interceptors {\n\t\tif intc.When != when {\n\t\t\tcontinue\n\t\t}\n\n\t\tlevel, target := findTarget(val, intc.target)\n\t\tif intc.interceptAll || target.IsValid() {\n\t\t\tresult = append(result, &interceptorItem{intc, target, level})\n\t\t}\n\t}\n\n\t// Before is deepest to highest\n\tif when == BEFORE {\n\t\tsort.Sort(result)\n\t} else {\n\t\t// Everything else is highest to deepest\n\t\tsort.Sort(reverseInterceptorItemList(result))\n\t}\n\treturn result\n}\n\n// Find the value of the target, starting from val and including embedded types.\n// Also, convert between any difference in indirection.\n// If the target couldn't be found, the returned Value will have IsValid() == false.\nfunc findTarget(val reflect.Value, target reflect.Type) (int, reflect.Value) {\n\t// Look through the embedded types (until we reach the *revel.Controller at the top).\n\tvalueQueue := []reflect.Value{val}\n\tlevel := 0\n\tfor len(valueQueue) > 0 {\n\t\tval, valueQueue = valueQueue[0], valueQueue[1:]\n\n\t\t// Check if val is of a similar type to the target type.\n\t\tif val.Type() == target {\n\t\t\treturn level, val\n\t\t}\n\t\tif val.Kind() == reflect.Ptr && val.Elem().Type() == target {\n\t\t\treturn level, val.Elem()\n\t\t}\n\t\tif target.Kind() == reflect.Ptr && target.Elem() == val.Type() {\n\t\t\treturn level, val.Addr()\n\t\t}\n\n\t\t// If we reached the *revel.Controller and still didn't find what we were\n\t\t// looking for, give up.\n\t\tif val.Type() == controllerPtrType {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Else, add each anonymous field to the queue.\n\t\tif val.Kind() == reflect.Ptr {\n\t\t\tval = val.Elem()\n\t\t}\n\n\t\tfor i := 0; i < val.NumField(); i++ {\n\t\t\tif val.Type().Field(i).Anonymous {\n\t\t\t\tvalueQueue = append(valueQueue, val.Field(i))\n\t\t\t}\n\t\t}\n\t\tlevel--\n\t}\n\n\treturn level, reflect.Value{}\n}\n"
        },
        {
          "name": "intercept_test.go",
          "type": "blob",
          "size": 2.7548828125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar (\n\tfuncP  = func(c *Controller) Result { return nil }\n\tfuncP2 = func(c *Controller) Result { return nil }\n)\n\ntype (\n\tInterceptController   struct{ *Controller }\n\tInterceptControllerN  struct{ InterceptController }\n\tInterceptControllerP  struct{ *InterceptController }\n\tInterceptControllerNP struct {\n\t\t*Controller\n\t\tInterceptControllerN\n\t\tInterceptControllerP\n\t}\n)\n\nfunc (c InterceptController) methN() Result  { return nil }\nfunc (c *InterceptController) methP() Result { return nil }\n\nfunc (c InterceptControllerN) methNN() Result  { return nil }\nfunc (c *InterceptControllerN) methNP() Result { return nil }\nfunc (c InterceptControllerP) methPN() Result  { return nil }\nfunc (c *InterceptControllerP) methPP() Result { return nil }\n\n// Methods accessible from InterceptControllerN.\nvar MethodN = []interface{}{\n\tInterceptController.methN,\n\t(*InterceptController).methP,\n\tInterceptControllerN.methNN,\n\t(*InterceptControllerN).methNP,\n}\n\n// Methods accessible from InterceptControllerP.\nvar MethodP = []interface{}{\n\tInterceptController.methN,\n\t(*InterceptController).methP,\n\tInterceptControllerP.methPN,\n\t(*InterceptControllerP).methPP,\n}\n\n// This checks that all the various kinds of interceptor functions/methods are\n// properly invoked.\nfunc TestInvokeArgType(t *testing.T) {\n\tn := InterceptControllerN{InterceptController{&Controller{}}}\n\tp := InterceptControllerP{&InterceptController{&Controller{}}}\n\tnp := InterceptControllerNP{&Controller{}, n, p}\n\ttestInterceptorController(t, reflect.ValueOf(&n), MethodN)\n\ttestInterceptorController(t, reflect.ValueOf(&p), MethodP)\n\ttestInterceptorController(t, reflect.ValueOf(&np), MethodN)\n\ttestInterceptorController(t, reflect.ValueOf(&np), MethodP)\n}\n\nfunc testInterceptorController(t *testing.T, appControllerPtr reflect.Value, methods []interface{}) {\n\tinterceptors = []*Interception{}\n\tInterceptFunc(funcP, BEFORE, appControllerPtr.Elem().Interface())\n\tInterceptFunc(funcP2, BEFORE, AllControllers)\n\tfor _, m := range methods {\n\t\tInterceptMethod(m, BEFORE)\n\t}\n\tints := getInterceptors(BEFORE, appControllerPtr)\n\n\tif len(ints) != 6 {\n\t\tt.Fatalf(\"N: Expected 6 interceptors, got %d.\", len(ints))\n\t}\n\n\ttestInterception(t, ints[0], reflect.ValueOf(&Controller{}))\n\ttestInterception(t, ints[1], reflect.ValueOf(&Controller{}))\n\tfor i := range methods {\n\t\ttestInterception(t, ints[i+2], appControllerPtr)\n\t}\n}\n\nfunc testInterception(t *testing.T, intc *interceptorItem, arg reflect.Value) {\n\tval := intc.Interceptor.Invoke(arg, &intc.Target)\n\tif !val.IsNil() {\n\t\tt.Errorf(\"Failed (%v): Expected nil got %v\", intc, val)\n\t}\n}\n"
        },
        {
          "name": "invoker.go",
          "type": "blob",
          "size": 1.43359375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"io\"\n\t\"reflect\"\n)\n\nvar (\n\tcontrollerPtrType = reflect.TypeOf(&Controller{})\n\twebsocketType     = reflect.TypeOf((*ServerWebSocket)(nil)).Elem()\n)\n\nfunc ActionInvoker(c *Controller, _ []Filter) {\n\t// Instantiate the method.\n\tmethodValue := reflect.ValueOf(c.AppController).MethodByName(c.MethodType.Name)\n\n\t// Collect the values for the method's arguments.\n\tvar methodArgs []reflect.Value\n\tfor _, arg := range c.MethodType.Args {\n\t\t// If they accept a websocket connection, treat that arg specially.\n\t\tvar boundArg reflect.Value\n\t\tif arg.Type.Implements(websocketType) {\n\t\t\tboundArg = reflect.ValueOf(c.Request.WebSocket)\n\t\t} else {\n\t\t\tboundArg = Bind(c.Params, arg.Name, arg.Type)\n\t\t\t// #756 - If the argument is a closer, defer a Close call,\n\t\t\t// so we don't risk on leaks.\n\t\t\tif closer, ok := boundArg.Interface().(io.Closer); ok {\n\t\t\t\tdefer func() {\n\t\t\t\t\t_ = closer.Close()\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t\tmethodArgs = append(methodArgs, boundArg)\n\t}\n\n\tvar resultValue reflect.Value\n\tif methodValue.Type().IsVariadic() {\n\t\tresultValue = methodValue.CallSlice(methodArgs)[0]\n\t} else {\n\t\tresultValue = methodValue.Call(methodArgs)[0]\n\t}\n\tif resultValue.Kind() == reflect.Interface && !resultValue.IsNil() {\n\t\tc.Result = resultValue.Interface().(Result)\n\t}\n}\n"
        },
        {
          "name": "invoker_test.go",
          "type": "blob",
          "size": 3.416015625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n// These tests verify that Controllers are initialized properly, given the range\n// of embedding possibilities..\n\ntype P struct{ *Controller }\n\ntype PN struct{ P }\n\ntype PNN struct{ PN }\n\n// Embedded via two paths.\ntype P2 struct{ *Controller }\n\ntype PP2 struct {\n\t*Controller // Need to embed this explicitly to avoid duplicate selector.\n\tP\n\tP2\n\tPNN\n}\n\nfunc TestFindControllers(t *testing.T) {\n\tcontrollers = make(map[string]*ControllerType)\n\tRegisterController((*P)(nil), nil)\n\tRegisterController((*PN)(nil), nil)\n\tRegisterController((*PNN)(nil), nil)\n\tRegisterController((*PP2)(nil), nil)\n\n\t// Test construction of indexes to each *Controller\n\tcheckSearchResults(t, P{}, [][]int{{0}})\n\tcheckSearchResults(t, PN{}, [][]int{{0, 0}})\n\tcheckSearchResults(t, PNN{}, [][]int{{0, 0, 0}})\n\tcheckSearchResults(t, PP2{}, [][]int{{0}, {1, 0}, {2, 0}, {3, 0, 0, 0}})\n}\n\nfunc checkSearchResults(t *testing.T, obj interface{}, expected [][]int) {\n\tactual := findControllers(reflect.TypeOf(obj))\n\tif !reflect.DeepEqual(expected, actual) {\n\t\tt.Errorf(\"Indexes do not match.  expected %v actual %v\", expected, actual)\n\t}\n}\n\nfunc TestSetAction(t *testing.T) {\n\tcontrollers = make(map[string]*ControllerType)\n\tRegisterController((*P)(nil), []*MethodType{{Name: \"Method\"}})\n\tRegisterController((*PNN)(nil), []*MethodType{{Name: \"Method\"}})\n\tRegisterController((*PP2)(nil), []*MethodType{{Name: \"Method\"}})\n\n\t// Test that all *revel.Controllers are initialized.\n\tc := &Controller{Name: \"Test\"}\n\tif err := c.SetAction(\"P\", \"Method\"); err != nil {\n\t\tt.Error(err)\n\t} else if c.AppController.(*P).Controller != c {\n\t\tt.Errorf(\"P not initialized\")\n\t}\n\n\tif err := c.SetAction(\"PNN\", \"Method\"); err != nil {\n\t\tt.Error(err)\n\t} else if c.AppController.(*PNN).Controller != c {\n\t\tt.Errorf(\"PNN not initialized\")\n\t}\n\n\t// PP2 has 4 different slots for *Controller.\n\tif err := c.SetAction(\"PP2\", \"Method\"); err != nil {\n\t\tt.Error(err)\n\t} else if pp2 := c.AppController.(*PP2); pp2.Controller != c ||\n\t\tpp2.P.Controller != c ||\n\t\tpp2.P2.Controller != c ||\n\t\tpp2.PNN.Controller != c {\n\t\tt.Errorf(\"PP2 not initialized\")\n\t}\n}\n\nfunc BenchmarkSetAction(b *testing.B) {\n\t//nolint:unused\n\ttype Mixin1 struct {\n\t\t*Controller\n\t\tx, y int\n\t\tfoo  string\n\t}\n\n\t//nolint:unused\n\ttype Mixin2 struct {\n\t\t*Controller\n\t\ta, b float64\n\t\tbar  string\n\t}\n\n\t//nolint:unused\n\ttype Benchmark struct {\n\t\t*Controller\n\t\tMixin1\n\t\tMixin2\n\t\tuser interface{}\n\t\tguy  string\n\t}\n\n\tRegisterController((*Mixin1)(nil), []*MethodType{{Name: \"Method\"}})\n\tRegisterController((*Mixin2)(nil), []*MethodType{{Name: \"Method\"}})\n\tRegisterController((*Benchmark)(nil), []*MethodType{{Name: \"Method\"}})\n\tc := Controller{\n\t\tViewArgs: make(map[string]interface{}),\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := c.SetAction(\"Benchmark\", \"Method\"); err != nil {\n\t\t\tb.Errorf(\"Failed to set action: %s\", err)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc BenchmarkInvoker(b *testing.B) {\n\tstartFakeBookingApp()\n\tc := NewTestController(nil, showRequest)\n\tc.ViewArgs = make(map[string]interface{})\n\tif err := c.SetAction(\"Hotels\", \"Show\"); err != nil {\n\t\tb.Errorf(\"Failed to set action: %s\", err)\n\t\treturn\n\t}\n\n\tc.Params = &Params{Values: make(url.Values)}\n\tc.Params.Set(\"id\", \"3\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tActionInvoker(c, nil)\n\t}\n}\n"
        },
        {
          "name": "libs.go",
          "type": "blob",
          "size": 2.3154296875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// Sign a given string with the app-configured secret key.\n// If no secret key is set, returns the empty string.\n// Return the signature in base64 (URLEncoding).\nfunc Sign(message string) string {\n\tif len(secretKey) == 0 {\n\t\treturn \"\"\n\t}\n\tmac := hmac.New(sha1.New, secretKey)\n\tif _, err := io.WriteString(mac, message); err != nil {\n\t\tutilLog.Error(\"WriteString failed\", \"error\", err)\n\t\treturn \"\"\n\t}\n\treturn hex.EncodeToString(mac.Sum(nil))\n}\n\n// Verify returns true if the given signature is correct for the given message.\n// e.g. it matches what we generate with Sign().\nfunc Verify(message, sig string) bool {\n\treturn hmac.Equal([]byte(sig), []byte(Sign(message)))\n}\n\n// ToBool method converts/assert value into true or false. Default is true.\n// When converting to boolean, the following values are considered FALSE:\n// - The integer value is 0 (zero)\n// - The float value 0.0 (zero)\n// - The complex value 0.0 (zero)\n// - For string value, please refer `revel.Atob` method\n// - An array, map, slice with zero elements\n// - Boolean value returned as-is\n// - \"nil\" value.\nfunc ToBool(val interface{}) bool {\n\tif val == nil {\n\t\treturn false\n\t}\n\n\tv := reflect.ValueOf(val)\n\tswitch v.Kind() {\n\tcase reflect.Bool:\n\t\treturn v.Bool()\n\tcase reflect.String:\n\t\treturn Atob(v.String())\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() != 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() != 0.0\n\tcase reflect.Complex64, reflect.Complex128:\n\t\treturn v.Complex() != 0.0\n\tcase reflect.Array, reflect.Map, reflect.Slice:\n\t\treturn v.Len() != 0\n\t}\n\n\t// Return true by default\n\treturn true\n}\n\n// Atob converts string into boolean. It is in-case sensitive\n// When converting to boolean, the following values are considered FALSE:\n// - The \"\" (empty) string\n// - The \"false\" string\n// - The \"f\" string\n// - The \"off\" string,\n// - The string \"0\" & \"0.0\".\nfunc Atob(v string) bool {\n\tswitch strings.TrimSpace(strings.ToLower(v)) {\n\tcase \"\", \"false\", \"off\", \"f\", \"0\", \"0.0\":\n\t\treturn false\n\t}\n\n\t// Return true by default\n\treturn true\n}\n"
        },
        {
          "name": "libs_test.go",
          "type": "blob",
          "size": 0.83984375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport \"testing\"\n\nfunc TestToBooleanForFalse(t *testing.T) {\n\tif ToBool(nil) ||\n\t\tToBool([]string{}) ||\n\t\tToBool(map[string]string{}) ||\n\t\tToBool(0) ||\n\t\tToBool(0.0) ||\n\t\tToBool(\"\") ||\n\t\tToBool(\"false\") ||\n\t\tToBool(\"0\") ||\n\t\tToBool(\"0.0\") ||\n\t\tToBool(\"off\") ||\n\t\tToBool(\"f\") {\n\t\tt.Error(\"Expected 'false' got 'true'\")\n\t}\n}\n\nfunc TestToBooleanForTrue(t *testing.T) {\n\tif !ToBool([]string{\"true\"}) ||\n\t\t!ToBool(map[string]string{\"true\": \"value\"}) ||\n\t\t!ToBool(1) ||\n\t\t!ToBool(0.1) ||\n\t\t!ToBool(\"not empty\") ||\n\t\t!ToBool(\"true\") ||\n\t\t!ToBool(\"1\") ||\n\t\t!ToBool(\"1.0\") ||\n\t\t!ToBool(\"on\") ||\n\t\t!ToBool(\"t\") {\n\t\tt.Error(\"Expected 'true' got 'false'\")\n\t}\n}\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 1.892578125,
          "content": "package revel\n\nimport (\n\t\"github.com/revel/revel/logger\"\n)\n\n// Logger.\nvar (\n\t// The root log is what all other logs are branched from, meaning if you set the handler for the root\n\t// it will adjust all children.\n\tRootLog = logger.New()\n\t// This logger is the application logger, use this for your application log messages - ie jobs and startup,\n\t// Use Controller.Log for Controller logging\n\t// The requests are logged to this logger with the context of `section:requestlog`.\n\tAppLog = RootLog.New(\"module\", \"app\")\n\t// This is the logger revel writes to, added log messages will have a context of module:revel in them\n\t// It is based off of `RootLog`.\n\tRevelLog = RootLog.New(\"module\", \"revel\")\n\n\t// This is the handler for the AppLog, it is stored so that if the AppLog is changed it can be assigned to the\n\t// new AppLog.\n\tappLogHandler *logger.CompositeMultiHandler\n\n\t// System logger.\n\tSysLog = AppLog.New(\"section\", \"system\")\n)\n\n// Initialize the loggers first.\nfunc init() {\n\t// RootLog.SetHandler(\n\t//\tlogger.LevelHandler(logger.LogLevel(log15.LvlDebug),\n\t//\t\tlogger.StreamHandler(os.Stdout, logger.TerminalFormatHandler(false, true))))\n\tinitLoggers()\n\tOnAppStart(initLoggers, -5)\n}\n\nfunc initLoggers() {\n\tappHandle := logger.InitializeFromConfig(BasePath, Config)\n\n\t// Set all the log handlers\n\tsetAppLog(AppLog, appHandle)\n}\n\n// Set the application log and handler, if handler is nil it will\n// use the same handler used to configure the application log before.\nfunc setAppLog(appLog logger.MultiLogger, appHandler *logger.CompositeMultiHandler) {\n\tif appLog != nil {\n\t\tAppLog = appLog\n\t}\n\n\tif appHandler != nil {\n\t\tappLogHandler = appHandler\n\t\t// Set the app log and the handler for all forked loggers\n\t\tRootLog.SetHandler(appLogHandler)\n\n\t\t// Set the system log handler - this sets golang writer stream to the\n\t\t// sysLog router\n\t\tlogger.SetDefaultLog(SysLog)\n\t\tSysLog.SetStackDepth(5)\n\t\tSysLog.SetHandler(appLogHandler)\n\t}\n}\n"
        },
        {
          "name": "logger",
          "type": "tree",
          "content": null
        },
        {
          "name": "model",
          "type": "tree",
          "content": null
        },
        {
          "name": "module.go",
          "type": "blob",
          "size": 6.748046875,
          "content": "package revel\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/go-stack/stack\"\n\t\"github.com/revel/revel/logger\"\n)\n\n// Module specific functions.\ntype Module struct {\n\tName, ImportPath, Path string\n\tControllerTypeList     []*ControllerType\n\tLog                    logger.MultiLogger\n\tinitializedModules     map[string]ModuleCallbackInterface\n}\n\n// Modules can be called back after they are loaded in revel by using this interface.\ntype ModuleCallbackInterface func(*Module)\n\n// The namespace separator constant.\nconst namespaceSeperator = `\\` // (note cannot be . or : as this is already used for routes)\n\nvar (\n\tModules   []*Module                                                                                     // The list of modules in use\n\tanyModule = &Module{}                                                                                   // Wildcard search for controllers for a module (for backward compatible lookups)\n\tappModule = &Module{Name: \"App\", initializedModules: map[string]ModuleCallbackInterface{}, Log: AppLog} // The app module\n\tmoduleLog = RevelLog.New(\"section\", \"module\")\n)\n\n// Called by a module init() function, caller will receive the *Module object created for that module\n// This would be useful for assigning a logger for logging information in the module (since the module context would be correct).\nfunc RegisterModuleInit(callback ModuleCallbackInterface) {\n\t// Store the module that called this so we can do a callback when the app is initialized\n\t// The format %+k is from go-stack/Call.Format and returns the package path\n\tkey := fmt.Sprintf(\"%+k\", stack.Caller(1))\n\tappModule.initializedModules[key] = callback\n\tif Initialized {\n\t\tRevelLog.Error(\"Application already initialized, initializing using app module\", \"key\", key)\n\t\tcallback(appModule)\n\t}\n}\n\n// Called on startup to make a callback so that modules can be initialized through the `RegisterModuleInit` function.\nfunc init() {\n\tAddInitEventHandler(func(typeOf Event, value interface{}) (responseOf EventResponse) {\n\t\tif typeOf == REVEL_BEFORE_MODULES_LOADED {\n\t\t\tModules = []*Module{appModule}\n\t\t\tappModule.Path = filepath.ToSlash(AppPath)\n\t\t\tappModule.ImportPath = filepath.ToSlash(ImportPath)\n\t\t}\n\n\t\treturn\n\t})\n}\n\n// Returns the namespace for the module in the format `module_name|`.\nfunc (m *Module) Namespace() (namespace string) {\n\tnamespace = m.Name + namespaceSeperator\n\treturn\n}\n\n// Returns the named controller and action that is in this module.\nfunc (m *Module) ControllerByName(name, action string) (ctype *ControllerType) {\n\tcomparison := name\n\tif strings.Index(name, namespaceSeperator) < 0 {\n\t\tcomparison = m.Namespace() + name\n\t}\n\tfor _, c := range m.ControllerTypeList {\n\t\tif c.Name() == comparison {\n\t\t\tctype = c\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}\n\n// Adds the controller type to this module.\nfunc (m *Module) AddController(ct *ControllerType) {\n\tm.ControllerTypeList = append(m.ControllerTypeList, ct)\n}\n\n// Based on the full path given return the relevant module\n// Only to be used on initialization.\nfunc ModuleFromPath(packagePath string, addGopathToPath bool) (module *Module) {\n\tpackagePath = filepath.ToSlash(packagePath)\n\t// The module paths will match the configuration module paths, so we will use those to determine them\n\t// Since the revel.Init is called first, then revel.Config exists and can be used to determine the module path\n\n\t// See if the path exists in the module based\n\tfor i := range Modules {\n\t\tif strings.Index(packagePath, Modules[i].ImportPath) == 0 {\n\t\t\t// This is a prefix, so the module is this module\n\t\t\tmodule = Modules[i]\n\t\t\tbreak\n\t\t}\n\t\tif module != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\t// Default to the app module if not found\n\tif module == nil {\n\t\tmodule = appModule\n\t}\n\treturn\n}\n\n// ModuleByName returns the module of the given name, if loaded, case insensitive.\nfunc ModuleByName(name string) (*Module, bool) {\n\t// If the name ends with the namespace separator remove it\n\tif name[len(name)-1] == []byte(namespaceSeperator)[0] {\n\t\tname = name[:len(name)-1]\n\t}\n\tname = strings.ToLower(name)\n\tif name == strings.ToLower(appModule.Name) {\n\t\treturn appModule, true\n\t}\n\tfor _, module := range Modules {\n\t\tif strings.ToLower(module.Name) == name {\n\t\t\treturn module, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// Loads the modules specified in the config.\nfunc loadModules() {\n\tkeys := []string{}\n\tfor _, key := range Config.Options(\"module.\") {\n\t\tkeys = append(keys, key)\n\t}\n\n\t// Reorder module order by key name, a poor mans sort but at least it is consistent\n\tsort.Strings(keys)\n\tfor _, key := range keys {\n\t\tmoduleLog.Debug(\"Sorted keys\", \"keys\", key)\n\t}\n\tfor _, key := range keys {\n\t\tmoduleImportPath := Config.StringDefault(key, \"\")\n\t\tif moduleImportPath == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tmodulePath, err := ResolveImportPath(moduleImportPath)\n\t\tif err != nil {\n\t\t\tmoduleLog.Error(\"Failed to load module.  Import of path failed\", \"modulePath\", moduleImportPath, \"error\", err)\n\t\t}\n\t\t// Drop anything between module.???.<name of module>\n\t\tsubKey := key[len(\"module.\"):]\n\t\tif index := strings.Index(subKey, \".\"); index > -1 {\n\t\t\tsubKey = subKey[index+1:]\n\t\t}\n\t\taddModule(subKey, moduleImportPath, modulePath)\n\t}\n\n\t// Modules loaded, now show module path\n\tfor key, callback := range appModule.initializedModules {\n\t\tif m := ModuleFromPath(key, false); m != nil {\n\t\t\tcallback(m)\n\t\t} else {\n\t\t\tRevelLog.Error(\"Callback for non registered module initializing with application module\", \"modulePath\", key)\n\t\t\tcallback(appModule)\n\t\t}\n\t}\n}\n\n// called by `loadModules`, creates a new `Module` instance and appends it to the `Modules` list.\nfunc addModule(name, importPath, modulePath string) {\n\tif _, found := ModuleByName(name); found {\n\t\tmoduleLog.Panic(\"Attempt to import duplicate module %s path %s aborting startup\", \"name\", name, \"path\", modulePath)\n\t}\n\tModules = append(Modules, &Module{\n\t\tName:       name,\n\t\tImportPath: filepath.ToSlash(importPath),\n\t\tPath:       filepath.ToSlash(modulePath),\n\t\tLog:        RootLog.New(\"module\", name),\n\t})\n\tif codePath := filepath.Join(modulePath, \"app\"); DirExists(codePath) {\n\t\tCodePaths = append(CodePaths, codePath)\n\t\tif viewsPath := filepath.Join(modulePath, \"app\", \"views\"); DirExists(viewsPath) {\n\t\t\tTemplatePaths = append(TemplatePaths, viewsPath)\n\t\t}\n\t}\n\n\tmoduleLog.Debug(\"Loaded module \", \"module\", filepath.Base(modulePath))\n\n\t// Hack: There is presently no way for the testrunner module to add the\n\t// \"test\" subdirectory to the CodePaths.  So this does it instead.\n\tif importPath == Config.StringDefault(\"module.testrunner\", \"github.com/revel/modules/testrunner\") {\n\t\tjoinedPath := filepath.Join(BasePath, \"tests\")\n\t\tmoduleLog.Debug(\"Found testrunner module, adding `tests` path \", \"path\", joinedPath)\n\t\tCodePaths = append(CodePaths, joinedPath)\n\t}\n\tif testsPath := filepath.Join(modulePath, \"tests\"); DirExists(testsPath) {\n\t\tmoduleLog.Debug(\"Found tests path \", \"path\", testsPath)\n\t\tCodePaths = append(CodePaths, testsPath)\n\t}\n}\n"
        },
        {
          "name": "namespace.go",
          "type": "blob",
          "size": 1.208984375,
          "content": "package revel\n\nimport (\n\t\"bytes\"\n\t\"regexp\"\n)\n\n// Module matching template syntax allows for modules to replace this text with the name of the module declared on import\n// this allows the reverse router to use correct syntax\n// Match _LOCAL_.static or  _LOCAL_|.\nvar namespaceReplacement = regexp.MustCompile(`(_LOCAL_)(\\.(.*?))?\\\\`)\n\n// Function to replace the bytes data that may match the _LOCAL_ namespace specifier,\n// the replacement will be the current module.Name.\nfunc namespaceReplace(fileBytes []byte, module *Module) []byte {\n\tnewBytes, lastIndex := &bytes.Buffer{}, 0\n\tmatches := namespaceReplacement.FindAllSubmatchIndex(fileBytes, -1)\n\tfor _, match := range matches {\n\t\t// Write up to first bytes\n\t\tnewBytes.Write(fileBytes[lastIndex:match[0]])\n\t\t// skip ahead index to match[1]\n\t\tlastIndex = match[3]\n\t\tif match[4] > 0 {\n\t\t\t// This match includes the module name as imported by the module\n\t\t\t// We could transform the module name if it is different..\n\t\t\t// For now leave it the same\n\t\t\t// so _LOCAL_.static| becomes static|\n\t\t\tlastIndex++\n\t\t} else {\n\t\t\t// Inject the module name\n\t\t\tnewBytes.Write([]byte(module.Name))\n\t\t}\n\t}\n\t// Write remainder of document\n\tnewBytes.Write(fileBytes[lastIndex:])\n\treturn newBytes.Bytes()\n}\n"
        },
        {
          "name": "panic.go",
          "type": "blob",
          "size": 1.41015625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"runtime/debug\"\n)\n\n// PanicFilter wraps the action invocation in a protective defer blanket that\n// converts panics into 500 error pages.\nfunc PanicFilter(c *Controller, fc []Filter) {\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\thandleInvocationPanic(c, err)\n\t\t}\n\t}()\n\tfc[0](c, fc[1:])\n}\n\n// This function handles a panic in an action invocation.\n// It cleans up the stack trace, logs it, and displays an error page.\nfunc handleInvocationPanic(c *Controller, err interface{}) {\n\terror := NewErrorFromPanic(err)\n\tif error != nil {\n\t\tutilLog.Error(\"PanicFilter: Caught panic\", \"error\", err, \"stack\", error.Stack)\n\t\tif DevMode {\n\t\t\tfmt.Println(err)\n\t\t\tfmt.Println(error.Stack)\n\t\t}\n\t} else {\n\t\tutilLog.Error(\"PanicFilter: Caught panic, unable to determine stack location\", \"error\", err, \"stack\", string(debug.Stack()))\n\t\tif DevMode {\n\t\t\tfmt.Println(err)\n\t\t\tfmt.Println(\"stack\", string(debug.Stack()))\n\t\t}\n\t}\n\n\tif error == nil && DevMode {\n\t\t// Only show the sensitive information in the debug stack trace in development mode, not production\n\t\tc.Response.SetStatus(http.StatusInternalServerError)\n\t\t_, _ = c.Response.GetWriter().Write(debug.Stack())\n\t\treturn\n\t}\n\n\tc.Result = c.RenderError(error)\n}\n"
        },
        {
          "name": "params.go",
          "type": "blob",
          "size": 5.0302734375,
          "content": "// Copyright (c) 2012-2017 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"mime/multipart\"\n\t\"net/url\"\n\t\"os\"\n\t\"reflect\"\n)\n\n// Params provides a unified view of the request params.\n// Includes:\n// - URL query string\n// - Form values\n// - File uploads\n//\n// Warning: param maps other than Values may be nil if there were none.\ntype Params struct {\n\turl.Values // A unified view of all the individual param maps below.\n\n\t// Set by the router\n\tFixed url.Values // Fixed parameters from the route, e.g. App.Action(\"fixed param\")\n\tRoute url.Values // Parameters extracted from the route,  e.g. /customers/{id}\n\n\t// Set by the ParamsFilter\n\tQuery url.Values // Parameters from the query string, e.g. /index?limit=10\n\tForm  url.Values // Parameters from the request body.\n\n\tFiles    map[string][]*multipart.FileHeader // Files uploaded in a multipart form\n\ttmpFiles []*os.File                         // Temp files used during the request.\n\tJSON     []byte                             // JSON data from request body\n}\n\nvar paramsLogger = RevelLog.New(\"section\", \"params\")\n\n// ParseParams parses the `http.Request` params into `revel.Controller.Params`.\nfunc ParseParams(params *Params, req *Request) {\n\tparams.Query = req.GetQuery()\n\n\t// Parse the body depending on the content type.\n\tswitch req.ContentType {\n\tcase \"application/x-www-form-urlencoded\":\n\t\t// Typical form.\n\t\tvar err error\n\t\tif params.Form, err = req.GetForm(); err != nil {\n\t\t\tparamsLogger.Warn(\"ParseParams: Error parsing request body\", \"error\", err)\n\t\t}\n\n\tcase \"multipart/form-data\":\n\t\t// Multipart form.\n\t\tif mp, err := req.GetMultipartForm(); err != nil {\n\t\t\tparamsLogger.Warn(\"ParseParams: parsing request body:\", \"error\", err)\n\t\t} else {\n\t\t\tparams.Form = mp.GetValues()\n\t\t\tparams.Files = mp.GetFiles()\n\t\t}\n\tcase \"application/json\":\n\t\tfallthrough\n\tcase \"text/json\":\n\t\tif body := req.GetBody(); body != nil {\n\t\t\tif content, err := ioutil.ReadAll(body); err == nil {\n\t\t\t\t// We wont bind it until we determine what we are binding too\n\t\t\t\tparams.JSON = content\n\t\t\t} else {\n\t\t\t\tparamsLogger.Error(\"ParseParams: Failed to ready request body bytes\", \"error\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tparamsLogger.Info(\"ParseParams: Json post received with empty body\")\n\t\t}\n\t}\n\n\tparams.Values = params.calcValues()\n}\n\n// Bind looks for the named parameter, converts it to the requested type, and\n// writes it into \"dest\", which must be settable.  If the value can not be\n// parsed, \"dest\" is set to the zero value.\nfunc (p *Params) Bind(dest interface{}, name string) {\n\tvalue := reflect.ValueOf(dest)\n\tif value.Kind() != reflect.Ptr {\n\t\tparamsLogger.Panic(\"Bind: revel/params: non-pointer passed to Bind: \" + name)\n\t}\n\tvalue = value.Elem()\n\tif !value.CanSet() {\n\t\tparamsLogger.Panic(\"Bind: revel/params: non-settable variable passed to Bind: \" + name)\n\t}\n\n\t// Remove the json from the Params, this will stop the binder from attempting\n\t// to use the json data to populate the destination interface. We do not want\n\t// to do this on a named bind directly against the param, it is ok to happen when\n\t// the action is invoked.\n\tjsonData := p.JSON\n\tp.JSON = nil\n\tvalue.Set(Bind(p, name, value.Type()))\n\tp.JSON = jsonData\n}\n\n// Bind binds the JSON data to the dest.\nfunc (p *Params) BindJSON(dest interface{}) error {\n\tvalue := reflect.ValueOf(dest)\n\tif value.Kind() != reflect.Ptr {\n\t\tparamsLogger.Warn(\"BindJSON: Not a pointer\")\n\t\treturn errors.New(\"BindJSON not a pointer\")\n\t}\n\tif err := json.Unmarshal(p.JSON, dest); err != nil {\n\t\tparamsLogger.Warn(\"BindJSON: Unable to unmarshal request:\", \"error\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// calcValues returns a unified view of the component param maps.\nfunc (p *Params) calcValues() url.Values {\n\tnumParams := len(p.Query) + len(p.Fixed) + len(p.Route) + len(p.Form)\n\n\t// If there were no params, return an empty map.\n\tif numParams == 0 {\n\t\treturn make(url.Values, 0)\n\t}\n\n\t// If only one of the param sources has anything, return that directly.\n\tswitch numParams {\n\tcase len(p.Query):\n\t\treturn p.Query\n\tcase len(p.Route):\n\t\treturn p.Route\n\tcase len(p.Fixed):\n\t\treturn p.Fixed\n\tcase len(p.Form):\n\t\treturn p.Form\n\t}\n\n\t// Copy everything into a param map,\n\t// order of priority is least to most trusted\n\tvalues := make(url.Values, numParams)\n\n\t// ?query string parameters are first\n\tfor k, v := range p.Query {\n\t\tvalues[k] = append(values[k], v...)\n\t}\n\n\t// form parameters append\n\tfor k, v := range p.Form {\n\t\tvalues[k] = append(values[k], v...)\n\t}\n\n\t// :/path parameters overwrite\n\tfor k, v := range p.Route {\n\t\tvalues[k] = v\n\t}\n\n\t// fixed route parameters overwrite\n\tfor k, v := range p.Fixed {\n\t\tvalues[k] = v\n\t}\n\n\treturn values\n}\n\nfunc ParamsFilter(c *Controller, fc []Filter) {\n\tParseParams(c.Params, c.Request)\n\n\t// Clean up from the request.\n\tdefer func() {\n\t\tfor _, tmpFile := range c.Params.tmpFiles {\n\t\t\terr := os.Remove(tmpFile.Name())\n\t\t\tif err != nil {\n\t\t\t\tparamsLogger.Warn(\"ParamsFilter: Could not remove upload temp file:\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tfc[0](c, fc[1:])\n}\n"
        },
        {
          "name": "params_test.go",
          "type": "blob",
          "size": 4.744140625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n// Params: Testing Multipart forms\n\nconst (\n\tMultipartBoundary = \"A\"\n\tMultipartFormData = `--A\nContent-Disposition: form-data; name=\"text1\"\n\ndata1\n--A\nContent-Disposition: form-data; name=\"text2\"\n\ndata2\n--A\nContent-Disposition: form-data; name=\"text2\"\n\ndata3\n--A\nContent-Disposition: form-data; name=\"file1\"; filename=\"test.txt\"\nContent-Type: text/plain\n\ncontent1\n--A\nContent-Disposition: form-data; name=\"file2[]\"; filename=\"test.txt\"\nContent-Type: text/plain\n\ncontent2\n--A\nContent-Disposition: form-data; name=\"file2[]\"; filename=\"favicon.ico\"\nContent-Type: image/x-icon\n\nxyz\n--A\nContent-Disposition: form-data; name=\"file3[0]\"; filename=\"test.txt\"\nContent-Type: text/plain\n\ncontent3\n--A\nContent-Disposition: form-data; name=\"file3[1]\"; filename=\"favicon.ico\"\nContent-Type: image/x-icon\n\nzzz\n--A--\n`\n)\n\n// The values represented by the form data.\ntype fh struct {\n\tfilename string\n\tcontent  []byte\n}\n\nvar (\n\texpectedValues = map[string][]string{\n\t\t\"text1\": {\"data1\"},\n\t\t\"text2\": {\"data2\", \"data3\"},\n\t}\n\texpectedFiles = map[string][]fh{\n\t\t\"file1\":    {fh{\"test.txt\", []byte(\"content1\")}},\n\t\t\"file2[]\":  {fh{\"test.txt\", []byte(\"content2\")}, fh{\"favicon.ico\", []byte(\"xyz\")}},\n\t\t\"file3[0]\": {fh{\"test.txt\", []byte(\"content3\")}},\n\t\t\"file3[1]\": {fh{\"favicon.ico\", []byte(\"zzz\")}},\n\t}\n)\n\nfunc getMultipartRequest() *http.Request {\n\treq, _ := http.NewRequest(\"POST\", \"http://localhost/path\",\n\t\tbytes.NewBufferString(MultipartFormData))\n\treq.Header.Set(\n\t\t\"Content-Type\", fmt.Sprintf(\"multipart/form-data; boundary=%s\", MultipartBoundary))\n\treq.Header.Set(\n\t\t\"Content-Length\", fmt.Sprintf(\"%d\", len(MultipartFormData)))\n\treturn req\n}\n\nfunc BenchmarkParams(b *testing.B) {\n\tc := NewTestController(nil, showRequest)\n\tc.Params = &Params{}\n\n\tfor i := 0; i < b.N; i++ {\n\t\tParamsFilter(c, NilChain)\n\t}\n}\n\nfunc TestMultipartForm(t *testing.T) {\n\tc := NewTestController(nil, getMultipartRequest())\n\tc.Params = &Params{}\n\n\tParamsFilter(c, NilChain)\n\n\tif !reflect.DeepEqual(expectedValues, map[string][]string(c.Params.Values)) {\n\t\tt.Errorf(\"Param values: (expected) %v != %v (actual)\",\n\t\t\texpectedValues, map[string][]string(c.Params.Values))\n\t}\n\n\tactualFiles := make(map[string][]fh)\n\tfor key, fileHeaders := range c.Params.Files {\n\t\tfor _, fileHeader := range fileHeaders {\n\t\t\tfile, _ := fileHeader.Open()\n\t\t\tcontent, _ := ioutil.ReadAll(file)\n\t\t\tactualFiles[key] = append(actualFiles[key], fh{fileHeader.Filename, content})\n\t\t}\n\t}\n\n\tif !reflect.DeepEqual(expectedFiles, actualFiles) {\n\t\tt.Errorf(\"Param files: (expected) %v != %v (actual)\", expectedFiles, actualFiles)\n\t}\n}\n\nfunc TestBind(t *testing.T) {\n\tparams := Params{\n\t\tValues: url.Values{\n\t\t\t\"x\": {\"5\"},\n\t\t},\n\t}\n\tvar x int\n\tparams.Bind(&x, \"x\")\n\tif x != 5 {\n\t\tt.Errorf(\"Failed to bind x.  Value: %d\", x)\n\t}\n}\n\nfunc TestResolveAcceptLanguage(t *testing.T) {\n\trequest := buildHTTPRequestWithAcceptLanguage(\"\")\n\tif result := ResolveAcceptLanguage(request); result != nil {\n\t\tt.Errorf(\"Expected Accept-Language to resolve to an empty string but it was '%s'\", result)\n\t}\n\n\trequest = buildHTTPRequestWithAcceptLanguage(\"en-GB,en;q=0.8,nl;q=0.6\")\n\tif result := ResolveAcceptLanguage(request); len(result) != 3 {\n\t\tt.Errorf(\"Unexpected Accept-Language values length of %d (expected %d)\", len(result), 3)\n\t} else {\n\t\tif result[0].Language != \"en-GB\" {\n\t\t\tt.Errorf(\"Expected '%s' to be most qualified but instead it's '%s'\", \"en-GB\", result[0].Language)\n\t\t}\n\t\tif result[1].Language != \"en\" {\n\t\t\tt.Errorf(\"Expected '%s' to be most qualified but instead it's '%s'\", \"en\", result[1].Language)\n\t\t}\n\t\tif result[2].Language != \"nl\" {\n\t\t\tt.Errorf(\"Expected '%s' to be most qualified but instead it's '%s'\", \"nl\", result[2].Language)\n\t\t}\n\t}\n\n\trequest = buildHTTPRequestWithAcceptLanguage(\"en;q=0.8,nl;q=0.6,en-AU;q=malformed\")\n\tif result := ResolveAcceptLanguage(request); len(result) != 3 {\n\t\tt.Errorf(\"Unexpected Accept-Language values length of %d (expected %d)\", len(result), 3)\n\t} else {\n\t\tif result[0].Language != \"en-AU\" {\n\t\t\tt.Errorf(\"Expected '%s' to be most qualified but instead it's '%s'\", \"en-AU\", result[0].Language)\n\t\t}\n\t}\n}\n\nfunc BenchmarkResolveAcceptLanguage(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\trequest := buildHTTPRequestWithAcceptLanguage(\"en-GB,en;q=0.8,nl;q=0.6,fr;q=0.5,de-DE;q=0.4,no-NO;q=0.4,ru;q=0.2\")\n\t\tResolveAcceptLanguage(request)\n\t}\n}\n\nfunc buildHTTPRequestWithAcceptLanguage(acceptLanguage string) *Request {\n\trequest, _ := http.NewRequest(\"POST\", \"http://localhost/path\", nil)\n\trequest.Header.Set(\"Accept-Language\", acceptLanguage)\n\tc := NewTestController(nil, request)\n\n\treturn c.Request\n}\n"
        },
        {
          "name": "results.go",
          "type": "blob",
          "size": 14.4306640625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Result interface {\n\tApply(req *Request, resp *Response)\n}\n\n// ErrorResult structure used to handles all kinds of error codes (500, 404, ..).\n// It renders the relevant error page (errors/CODE.format, e.g. errors/500.json).\n// If RunMode is \"dev\", this results in a friendly error page.\ntype ErrorResult struct {\n\tViewArgs map[string]interface{}\n\tError    error\n}\n\nvar resultsLog = RevelLog.New(\"section\", \"results\")\n\nfunc (r ErrorResult) Apply(req *Request, resp *Response) {\n\tformat := req.Format\n\tstatus := resp.Status\n\tif status == 0 {\n\t\tstatus = http.StatusInternalServerError\n\t}\n\n\tcontentType := ContentTypeByFilename(\"xxx.\" + format)\n\tif contentType == DefaultFileContentType {\n\t\tcontentType = \"text/plain\"\n\t}\n\tlang, _ := r.ViewArgs[CurrentLocaleViewArg].(string)\n\t// Get the error template.\n\tvar err error\n\ttemplatePath := fmt.Sprintf(\"errors/%d.%s\", status, format)\n\ttmpl, err := MainTemplateLoader.TemplateLang(templatePath, lang)\n\n\t// This func shows a plaintext error message, in case the template rendering\n\t// doesn't work.\n\tshowPlaintext := func(err error) {\n\t\tPlaintextErrorResult{fmt.Errorf(\"Server Error:\\n%s\\n\\n\"+\n\t\t\t\"Additionally, an error occurred when rendering the error page:\\n%s\",\n\t\t\tr.Error, err)}.Apply(req, resp)\n\t}\n\n\tif tmpl == nil {\n\t\tif err == nil {\n\t\t\terr = fmt.Errorf(\"Couldn't find template %s\", templatePath)\n\t\t}\n\t\ttemplateLog.Warn(\"Got an error rendering template\", \"error\", err, \"template\", templatePath, \"lang\", lang)\n\t\tshowPlaintext(err)\n\t\treturn\n\t}\n\n\t// If it's not a revel error, wrap it in one.\n\tvar revelError *Error\n\tswitch e := r.Error.(type) {\n\tcase *Error:\n\t\trevelError = e\n\tcase error:\n\t\trevelError = &Error{\n\t\t\tTitle:       \"Server Error\",\n\t\t\tDescription: e.Error(),\n\t\t}\n\t}\n\n\tif revelError == nil {\n\t\tpanic(\"no error provided\")\n\t}\n\n\tif r.ViewArgs == nil {\n\t\tr.ViewArgs = make(map[string]interface{})\n\t}\n\tr.ViewArgs[\"RunMode\"] = RunMode\n\tr.ViewArgs[\"DevMode\"] = DevMode\n\tr.ViewArgs[\"Error\"] = revelError\n\tr.ViewArgs[\"Router\"] = MainRouter\n\n\tresultsLog.Info(\"Rendering error template\", \"template\", templatePath, \"error\", revelError)\n\n\t// Render it.\n\tvar b bytes.Buffer\n\terr = tmpl.Render(&b, r.ViewArgs)\n\n\t// If there was an error, print it in plain text.\n\tif err != nil {\n\t\ttemplateLog.Warn(\"Got an error rendering template\", \"error\", err, \"template\", templatePath, \"lang\", lang)\n\t\tshowPlaintext(err)\n\t\treturn\n\t}\n\n\t// need to check if we are on a websocket here\n\t// net/http panics if we write to a hijacked connection\n\tif req.Method == \"WS\" {\n\t\tif err := req.WebSocket.MessageSendJSON(fmt.Sprint(revelError)); err != nil {\n\t\t\tresultsLog.Error(\"Apply: Send failed\", \"error\", err)\n\t\t}\n\t} else {\n\t\tresp.WriteHeader(status, contentType)\n\t\tif _, err := b.WriteTo(resp.GetWriter()); err != nil {\n\t\t\tresultsLog.Error(\"Apply: Response WriteTo failed:\", \"error\", err)\n\t\t}\n\t}\n}\n\ntype PlaintextErrorResult struct {\n\tError error\n}\n\n// Apply method is used when the template loader or error template is not available.\nfunc (r PlaintextErrorResult) Apply(req *Request, resp *Response) {\n\tresp.WriteHeader(http.StatusInternalServerError, \"text/plain; charset=utf-8\")\n\tif _, err := resp.GetWriter().Write([]byte(r.Error.Error())); err != nil {\n\t\tresultsLog.Error(\"Apply: Write error:\", \"error\", err)\n\t}\n}\n\n// RenderTemplateResult action methods returns this result to request\n// a template be rendered.\ntype RenderTemplateResult struct {\n\tTemplate Template\n\tViewArgs map[string]interface{}\n}\n\nfunc (r *RenderTemplateResult) Apply(req *Request, resp *Response) {\n\t// Handle panics when rendering templates.\n\tdefer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tresultsLog.Error(\"Apply: panic recovery\", \"error\", err)\n\t\t\tPlaintextErrorResult{fmt.Errorf(\"Template Execution Panic in %s:\\n%s\",\n\t\t\t\tr.Template.Name(), err)}.Apply(req, resp)\n\t\t}\n\t}()\n\n\tchunked := Config.BoolDefault(\"results.chunked\", false)\n\n\t// If it's a HEAD request, throw away the bytes.\n\tout := resp.GetWriter()\n\tif req.Method == \"HEAD\" {\n\t\tout = ioutil.Discard\n\t}\n\n\t// In a prod mode, write the status, render, and hope for the best.\n\t// (In a dev mode, always render to a temporary buffer first to avoid having\n\t// error pages distorted by HTML already written)\n\tif chunked && !DevMode {\n\t\tresp.WriteHeader(http.StatusOK, \"text/html; charset=utf-8\")\n\t\tif err := r.renderOutput(out); err != nil {\n\t\t\tr.renderError(err, req, resp)\n\t\t}\n\t\treturn\n\t}\n\n\t// Render the template into a temporary buffer, to see if there was an error\n\t// rendering the template.  If not, then copy it into the response buffer.\n\t// Otherwise, template render errors may result in unpredictable HTML (and\n\t// would carry a 200 status code)\n\tb, err := r.ToBytes()\n\tif err != nil {\n\t\tr.renderError(err, req, resp)\n\t\treturn\n\t}\n\n\tif !chunked {\n\t\tresp.Out.Header().Set(\"Content-Length\", strconv.Itoa(b.Len()))\n\t}\n\tresp.WriteHeader(http.StatusOK, \"text/html; charset=utf-8\")\n\tif _, err := b.WriteTo(out); err != nil {\n\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t}\n}\n\n// Return a byte array and or an error object if the template failed to render.\nfunc (r *RenderTemplateResult) ToBytes() (b *bytes.Buffer, err error) {\n\tdefer func() {\n\t\tif rerr := recover(); rerr != nil {\n\t\t\tresultsLog.Error(\"ApplyBytes: panic recovery\", \"recover-error\", rerr)\n\t\t\terr = fmt.Errorf(\"Template Execution Panic in %s:\\n%s\", r.Template.Name(), rerr)\n\t\t}\n\t}()\n\tb = &bytes.Buffer{}\n\tif err = r.renderOutput(b); err == nil {\n\t\tif Config.BoolDefault(\"results.trim.html\", false) {\n\t\t\tb = r.compressHtml(b)\n\t\t}\n\t}\n\treturn\n}\n\n// Output the template to the writer, catch any panics and return as an error.\nfunc (r *RenderTemplateResult) renderOutput(wr io.Writer) (err error) {\n\tdefer func() {\n\t\tif rerr := recover(); rerr != nil {\n\t\t\tresultsLog.Error(\"ApplyBytes: panic recovery\", \"recover-error\", rerr)\n\t\t\terr = fmt.Errorf(\"Template Execution Panic in %s:\\n%s\", r.Template.Name(), rerr)\n\t\t}\n\t}()\n\terr = r.Template.Render(wr, r.ViewArgs)\n\treturn\n}\n\n// Trimming the HTML will do the following:\n// * Remove all leading & trailing whitespace on every line\n// * Remove all empty lines\n// * Attempt to keep formatting inside <pre></pre> tags\n//\n// This is safe unless white-space: pre; is used in css for formatting.\n// Since there is no way to detect that, you will have to keep trimming off in these cases.\nfunc (r *RenderTemplateResult) compressHtml(b *bytes.Buffer) (b2 *bytes.Buffer) {\n\t// Allocate length of original buffer, so we can write everything without allocating again\n\tb2.Grow(b.Len())\n\tinsidePre := false\n\tfor {\n\t\ttext, err := b.ReadString('\\n')\n\t\t// Convert to lower case for finding <pre> tags.\n\t\ttl := strings.ToLower(text)\n\t\tif strings.Contains(tl, \"<pre>\") {\n\t\t\tinsidePre = true\n\t\t}\n\t\t// Trim if not inside a <pre> statement\n\t\tif !insidePre {\n\t\t\t// Cut trailing/leading whitespace\n\t\t\ttext = strings.Trim(text, \" \\t\\r\\n\")\n\t\t\tif len(text) > 0 {\n\t\t\t\tif _, err = b2.WriteString(text); err != nil {\n\t\t\t\t\tresultsLog.Error(\"Apply: \", \"error\", err)\n\t\t\t\t}\n\t\t\t\tif _, err = b2.WriteString(\"\\n\"); err != nil {\n\t\t\t\t\tresultsLog.Error(\"Apply: \", \"error\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif _, err = b2.WriteString(text); err != nil {\n\t\t\t\tresultsLog.Error(\"Apply: \", \"error\", err)\n\t\t\t}\n\t\t}\n\t\tif strings.Contains(tl, \"</pre>\") {\n\t\t\tinsidePre = false\n\t\t}\n\t\t// We are finished\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn\n}\n\n// Render the error in the response.\nfunc (r *RenderTemplateResult) renderError(err error, req *Request, resp *Response) {\n\tcompileError, found := err.(*Error)\n\tif !found {\n\t\tvar templateContent []string\n\t\ttemplateName, line, description := ParseTemplateError(err)\n\t\tif templateName == \"\" {\n\t\t\ttemplateLog.Info(\"Cannot determine template name to render error\", \"error\", err)\n\t\t\ttemplateName = r.Template.Name()\n\t\t\ttemplateContent = r.Template.Content()\n\t\t} else {\n\t\t\tlang, _ := r.ViewArgs[CurrentLocaleViewArg].(string)\n\t\t\tif tmpl, err := MainTemplateLoader.TemplateLang(templateName, lang); err == nil {\n\t\t\t\ttemplateContent = tmpl.Content()\n\t\t\t} else {\n\t\t\t\ttemplateLog.Info(\"Unable to retrieve template \", \"error\", err)\n\t\t\t}\n\t\t}\n\t\tcompileError = &Error{\n\t\t\tTitle:       \"Template Execution Error\",\n\t\t\tPath:        templateName,\n\t\t\tDescription: description,\n\t\t\tLine:        line,\n\t\t\tSourceLines: templateContent,\n\t\t}\n\t}\n\tresp.Status = 500\n\tresultsLog.Errorf(\"render: Template Execution Error (in %s): %s\", compileError.Path, compileError.Description)\n\tErrorResult{r.ViewArgs, compileError}.Apply(req, resp)\n}\n\ntype RenderHTMLResult struct {\n\thtml string\n}\n\nfunc (r RenderHTMLResult) Apply(req *Request, resp *Response) {\n\tresp.WriteHeader(http.StatusOK, \"text/html; charset=utf-8\")\n\tif _, err := resp.GetWriter().Write([]byte(r.html)); err != nil {\n\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t}\n}\n\ntype RenderJSONResult struct {\n\tobj      interface{}\n\tcallback string\n}\n\nfunc (r RenderJSONResult) Apply(req *Request, resp *Response) {\n\tvar b []byte\n\tvar err error\n\tif Config.BoolDefault(\"results.pretty\", false) {\n\t\tb, err = json.MarshalIndent(r.obj, \"\", \"  \")\n\t} else {\n\t\tb, err = json.Marshal(r.obj)\n\t}\n\n\tif err != nil {\n\t\tErrorResult{Error: err}.Apply(req, resp)\n\t\treturn\n\t}\n\n\tif r.callback == \"\" {\n\t\tresp.WriteHeader(http.StatusOK, \"application/json; charset=utf-8\")\n\t\tif _, err = resp.GetWriter().Write(b); err != nil {\n\t\t\tresultsLog.Error(\"Apply: Response write failed:\", \"error\", err)\n\t\t}\n\t\treturn\n\t}\n\n\tresp.WriteHeader(http.StatusOK, \"application/javascript; charset=utf-8\")\n\tif _, err = resp.GetWriter().Write([]byte(r.callback + \"(\")); err != nil {\n\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t}\n\tif _, err = resp.GetWriter().Write(b); err != nil {\n\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t}\n\tif _, err = resp.GetWriter().Write([]byte(\");\")); err != nil {\n\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t}\n}\n\ntype RenderXMLResult struct {\n\tobj interface{}\n}\n\nfunc (r RenderXMLResult) Apply(req *Request, resp *Response) {\n\tvar b []byte\n\tvar err error\n\tif Config.BoolDefault(\"results.pretty\", false) {\n\t\tb, err = xml.MarshalIndent(r.obj, \"\", \"  \")\n\t} else {\n\t\tb, err = xml.Marshal(r.obj)\n\t}\n\n\tif err != nil {\n\t\tErrorResult{Error: err}.Apply(req, resp)\n\t\treturn\n\t}\n\n\tresp.WriteHeader(http.StatusOK, \"application/xml; charset=utf-8\")\n\tif _, err = resp.GetWriter().Write(b); err != nil {\n\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t}\n}\n\ntype RenderTextResult struct {\n\ttext string\n}\n\nfunc (r RenderTextResult) Apply(req *Request, resp *Response) {\n\tresp.WriteHeader(http.StatusOK, \"text/plain; charset=utf-8\")\n\tif _, err := resp.GetWriter().Write([]byte(r.text)); err != nil {\n\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t}\n}\n\ntype ContentDisposition string\n\nvar (\n\tNoDisposition ContentDisposition = \"\"\n\tAttachment    ContentDisposition = \"attachment\"\n\tInline        ContentDisposition = \"inline\"\n)\n\ntype BinaryResult struct {\n\tReader   io.Reader\n\tName     string\n\tLength   int64\n\tDelivery ContentDisposition\n\tModTime  time.Time\n}\n\nfunc (r *BinaryResult) Apply(req *Request, resp *Response) {\n\tif r.Delivery != NoDisposition {\n\t\tdisposition := string(r.Delivery)\n\t\tif r.Name != \"\" {\n\t\t\tdisposition += fmt.Sprintf(`; filename=\"%s\"`, r.Name)\n\t\t}\n\t\tresp.Out.internalHeader.Set(\"Content-Disposition\", disposition)\n\t}\n\tif resp.ContentType != \"\" {\n\t\tresp.Out.internalHeader.Set(\"Content-Type\", resp.ContentType)\n\t} else {\n\t\tcontentType := ContentTypeByFilename(r.Name)\n\t\tresp.Out.internalHeader.Set(\"Content-Type\", contentType)\n\t}\n\tif content, ok := r.Reader.(io.ReadSeeker); ok && r.Length < 0 {\n\t\t// get the size from the stream\n\t\t// go1.6 compatibility change, go1.6 does not define constants io.SeekStart\n\t\t// if size, err := content.Seek(0, io.SeekEnd); err == nil {\n\t\t//\tif _, err = content.Seek(0, io.SeekStart); err == nil {\n\t\tif size, err := content.Seek(0, 2); err == nil {\n\t\t\tif _, err = content.Seek(0, 0); err == nil {\n\t\t\t\tr.Length = size\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write stream writes the status code to the header as well\n\tif ws := resp.GetStreamWriter(); ws != nil {\n\t\tif err := ws.WriteStream(r.Name, r.Length, r.ModTime, r.Reader); err != nil {\n\t\t\tresultsLog.Error(\"Apply: Response write failed\", \"error\", err)\n\t\t}\n\t}\n\n\t// Close the Reader if we can\n\tif v, ok := r.Reader.(io.Closer); ok {\n\t\t_ = v.Close()\n\t}\n}\n\ntype RedirectToURLResult struct {\n\turl string\n}\n\nfunc (r *RedirectToURLResult) Apply(req *Request, resp *Response) {\n\tresp.Out.internalHeader.Set(\"Location\", r.url)\n\tresp.WriteHeader(http.StatusFound, \"\")\n}\n\ntype RedirectToActionResult struct {\n\tval  interface{}\n\targs []interface{}\n}\n\nfunc (r *RedirectToActionResult) Apply(req *Request, resp *Response) {\n\turl, err := getRedirectURL(r.val, r.args)\n\tif err != nil {\n\t\treq.controller.Log.Error(\"Apply: Couldn't resolve redirect\", \"error\", err)\n\t\tErrorResult{Error: err}.Apply(req, resp)\n\t\treturn\n\t}\n\tresp.Out.internalHeader.Set(\"Location\", url)\n\tresp.WriteHeader(http.StatusFound, \"\")\n}\n\nfunc getRedirectURL(item interface{}, args []interface{}) (string, error) {\n\t// Handle strings\n\tif url, ok := item.(string); ok {\n\t\treturn url, nil\n\t}\n\n\t// Handle funcs\n\tval := reflect.ValueOf(item)\n\ttyp := reflect.TypeOf(item)\n\tif typ.Kind() == reflect.Func && typ.NumIn() > 0 {\n\t\t// Get the Controller Method\n\t\trecvType := typ.In(0)\n\t\tmethod := FindMethod(recvType, val)\n\t\tif method == nil {\n\t\t\treturn \"\", errors.New(\"couldn't find method\")\n\t\t}\n\n\t\t// Construct the action string (e.g. \"Controller.Method\")\n\t\tif recvType.Kind() == reflect.Ptr {\n\t\t\trecvType = recvType.Elem()\n\t\t}\n\t\tmodule := ModuleFromPath(recvType.PkgPath(), true)\n\t\taction := module.Namespace() + recvType.Name() + \".\" + method.Name\n\t\t// Fetch the action path to get the defaults\n\t\tpathData, found := splitActionPath(nil, action, true)\n\t\tif !found {\n\t\t\treturn \"\", fmt.Errorf(\"Unable to redirect '%s', expected 'Controller.Action'\", action)\n\t\t}\n\n\t\t// Build the map for the router to reverse\n\t\t// Unbind the arguments.\n\t\targsByName := make(map[string]string)\n\t\t// Bind any static args first\n\t\tfixedParams := len(pathData.FixedParamsByName)\n\t\tmethodType := pathData.TypeOfController.Method(pathData.MethodName)\n\n\t\tfor i, argValue := range args {\n\t\t\tUnbind(argsByName, methodType.Args[i+fixedParams].Name, argValue)\n\t\t}\n\n\t\tactionDef := MainRouter.Reverse(action, argsByName)\n\t\tif actionDef == nil {\n\t\t\treturn \"\", errors.New(\"no route for action \" + action)\n\t\t}\n\n\t\treturn actionDef.String(), nil\n\t}\n\n\t// Out of guesses\n\treturn \"\", errors.New(\"didn't recognize type: \" + typ.String())\n}\n"
        },
        {
          "name": "results_test.go",
          "type": "blob",
          "size": 2.013671875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// Added test case for redirection testing for strings.\nfunc TestRedirect(t *testing.T) {\n\tstartFakeBookingApp()\n\tredirect := RedirectToURLResult{fmt.Sprintf(\"/hotels/index/foo\")}\n\tresp := httptest.NewRecorder()\n\tc := NewTestController(resp, showRequest)\n\tredirect.Apply(c.Request, c.Response)\n\tif resp.Header().Get(\"Location\") != \"/hotels/index/foo\" {\n\t\tt.Errorf(\"Failed to set redirect header correctly. : %s\", resp.Header().Get(\"Location\"))\n\t}\n}\n\n// Test that the render response is as expected.\nfunc TestBenchmarkRender(t *testing.T) {\n\tstartFakeBookingApp()\n\tresp := httptest.NewRecorder()\n\tc := NewTestController(resp, showRequest)\n\tif err := c.SetAction(\"Hotels\", \"Show\"); err != nil {\n\t\tt.Errorf(\"SetAction failed: %s\", err)\n\t}\n\tresult := Hotels{c}.Show(3)\n\tresult.Apply(c.Request, c.Response)\n\tif !strings.Contains(resp.Body.String(), \"300 Main St.\") {\n\t\tt.Errorf(\"Failed to find hotel address in action response:\\n%s\", resp.Body)\n\t}\n}\n\nfunc BenchmarkRenderChunked(b *testing.B) {\n\tstartFakeBookingApp()\n\tresp := httptest.NewRecorder()\n\tresp.Body = nil\n\tc := NewTestController(resp, showRequest)\n\tif err := c.SetAction(\"Hotels\", \"Show\"); err != nil {\n\t\tb.Errorf(\"SetAction failed: %s\", err)\n\t}\n\tConfig.SetOption(\"results.chunked\", \"true\")\n\tb.ResetTimer()\n\n\thotels := Hotels{c}\n\tfor i := 0; i < b.N; i++ {\n\t\thotels.Show(3).Apply(c.Request, c.Response)\n\t}\n}\n\nfunc BenchmarkRenderNotChunked(b *testing.B) {\n\tstartFakeBookingApp()\n\tresp := httptest.NewRecorder()\n\tresp.Body = nil\n\tc := NewTestController(resp, showRequest)\n\tif err := c.SetAction(\"Hotels\", \"Show\"); err != nil {\n\t\tb.Errorf(\"SetAction failed: %s\", err)\n\t}\n\tConfig.SetOption(\"results.chunked\", \"false\")\n\tb.ResetTimer()\n\n\thotels := Hotels{c}\n\tfor i := 0; i < b.N; i++ {\n\t\thotels.Show(3).Apply(c.Request, c.Response)\n\t}\n}\n"
        },
        {
          "name": "revel.go",
          "type": "blob",
          "size": 10.2568359375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"go/build\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/revel/config\"\n\t\"github.com/revel/revel/logger\"\n\t\"github.com/revel/revel/model\"\n)\n\nconst (\n\t// RevelImportPath Revel framework import path.\n\tRevelImportPath = \"github.com/revel/revel\"\n)\n\nconst (\n\tTEST_MODE_FLAG   = \"testModeFlag\"\n\tSPECIAL_USE_FLAG = \"specialUseFlag\"\n)\n\n// App details.\nvar (\n\tRevelConfig *model.RevelContainer\n\tAppName     string // e.g. \"sample\"\n\tAppRoot     string // e.g. \"/app1\"\n\tBasePath    string // e.g. \"$GOPATH/src/corp/sample\"\n\tAppPath     string // e.g. \"$GOPATH/src/corp/sample/app\"\n\tViewsPath   string // e.g. \"$GOPATH/src/corp/sample/app/views\"\n\tImportPath  string // e.g. \"corp/sample\"\n\tSourcePath  string // e.g. \"$GOPATH/src\"\n\n\tConfig  *config.Context\n\tRunMode string // Application-defined (by default, \"dev\" or \"prod\")\n\tDevMode bool   // if true, RunMode is a development mode.\n\n\t// Revel installation details.\n\tRevelPath string // e.g. \"$GOPATH/src/github.com/revel/revel\"\n\n\t// Where to look for templates\n\t// Ordered by priority. (Earlier paths take precedence over later paths.)\n\tCodePaths     []string // Code base directories, for modules and app\n\tTemplatePaths []string // Template path directories manually added\n\n\t// ConfPaths where to look for configurations\n\t// Config load order\n\t// 1. framework (revel/conf/*)\n\t// 2. application (conf/*)\n\t// 3. user supplied configs (...) - User configs can override/add any from above.\n\tConfPaths []string\n\n\t// Server config.\n\t//\n\t// Alert: This is how the app is configured, which may be different from\n\t// the current process reality.  For example, if the app is configured for\n\t// port 9000, HTTPPort will always be 9000, even though in dev mode it is\n\t// run on a random port and proxied.\n\tHTTPPort    int    // e.g. 9000\n\tHTTPAddr    string // e.g. \"\", \"127.0.0.1\"\n\tHTTPSsl     bool   // e.g. true if using ssl\n\tHTTPSslCert string // e.g. \"/path/to/cert.pem\"\n\tHTTPSslKey  string // e.g. \"/path/to/key.pem\"\n\n\t// All cookies dropped by the framework begin with this prefix.\n\tCookiePrefix string\n\t// Cookie domain.\n\tCookieDomain string\n\t// Cookie flags.\n\tCookieSecure   bool\n\tCookieSameSite http.SameSite\n\n\t// Revel request access log, not exposed from package.\n\t// However output settings can be controlled from app.conf.\n\n\t// True when revel engine has been initialized (Init has returned).\n\tInitialized bool\n\n\t// Private.\n\tsecretKey      []byte                // Key used to sign cookies. An empty key disables signing.\n\tpackaged       bool                  // If true, this is running from a pre-built package.\n\tinitEventList  = []EventHandler{}    // Event handler list for receiving events\n\tpackagePathMap = map[string]string{} // The map of the directories needed\n)\n\n// Init initializes Revel -- it provides paths for getting around the app.\n//\n// Params:\n//   mode - the run mode, which determines which app.conf settings are used.\n//   importPath - the Go import path of the application.\n//   srcPath - the path to the source directory, containing Revel and the app.\n//     If not specified (\"\"), then a functioning Go installation is required.\nfunc Init(inputmode, importPath, srcPath string) {\n\tRevelConfig = &model.RevelContainer{}\n\t// Ignore trailing slashes.\n\tImportPath = strings.TrimRight(importPath, \"/\")\n\tSourcePath = srcPath\n\n\tRunMode = updateLog(inputmode)\n\n\t// If the SourcePath is not specified, find it using build.Import.\n\tvar revelSourcePath string // may be different from the app source path\n\tif SourcePath == \"\" {\n\t\trevelSourcePath, SourcePath = findSrcPaths(importPath)\n\t\tBasePath = SourcePath\n\t} else {\n\t\t// If the SourcePath was specified, assume both Revel and the app are within it.\n\t\tSourcePath = filepath.Clean(SourcePath)\n\t\trevelSourcePath = filepath.Join(SourcePath, filepath.FromSlash(RevelImportPath))\n\t\tBasePath = filepath.Join(SourcePath, filepath.FromSlash(importPath))\n\t\tpackaged = true\n\t}\n\n\tRevelPath = revelSourcePath // filepath.Join(revelSourcePath, filepath.FromSlash(RevelImportPath))\n\tAppPath = filepath.Join(BasePath, \"app\")\n\tViewsPath = filepath.Join(AppPath, \"views\")\n\tRevelLog.Debug(\"Paths\", \"revel\", RevelPath, \"base\", BasePath, \"app\", AppPath, \"views\", ViewsPath)\n\n\tCodePaths = []string{AppPath}\n\n\tif ConfPaths == nil {\n\t\tConfPaths = []string{}\n\t}\n\n\t// Config load order\n\t// 1. framework (revel/conf/*)\n\t// 2. application (conf/*)\n\t// 3. user supplied configs (...) - User configs can override/add any from above\n\tConfPaths = append(\n\t\t[]string{\n\t\t\tfilepath.Join(RevelPath, \"conf\"),\n\t\t\tfilepath.Join(BasePath, \"conf\"),\n\t\t},\n\t\tConfPaths...)\n\n\tTemplatePaths = []string{\n\t\tViewsPath,\n\t\tfilepath.Join(RevelPath, \"templates\"),\n\t}\n\n\t// Load app.conf\n\tvar err error\n\tConfig, err = config.LoadContext(\"app.conf\", ConfPaths)\n\tif err != nil || Config == nil {\n\t\tRevelLog.Fatal(\"Failed to load app.conf:\", \"error\", err)\n\t}\n\n\t// After application config is loaded update the logger\n\tupdateLog(inputmode)\n\n\t// Configure properties from app.conf\n\tDevMode = Config.BoolDefault(\"mode.dev\", false)\n\tHTTPPort = Config.IntDefault(\"http.port\", 9000)\n\tHTTPAddr = Config.StringDefault(\"http.addr\", \"\")\n\tHTTPSsl = Config.BoolDefault(\"http.ssl\", false)\n\tHTTPSslCert = Config.StringDefault(\"http.sslcert\", \"\")\n\tHTTPSslKey = Config.StringDefault(\"http.sslkey\", \"\")\n\tif HTTPSsl {\n\t\tif HTTPSslCert == \"\" {\n\t\t\tRevelLog.Fatal(\"No http.sslcert provided.\")\n\t\t}\n\t\tif HTTPSslKey == \"\" {\n\t\t\tRevelLog.Fatal(\"No http.sslkey provided.\")\n\t\t}\n\t}\n\n\tAppName = Config.StringDefault(\"app.name\", \"(not set)\")\n\tAppRoot = Config.StringDefault(\"app.root\", \"\")\n\tCookiePrefix = Config.StringDefault(\"cookie.prefix\", \"REVEL\")\n\tCookieDomain = Config.StringDefault(\"cookie.domain\", \"\")\n\tCookieSecure = Config.BoolDefault(\"cookie.secure\", HTTPSsl)\n\n\tswitch Config.StringDefault(\"cookie.samesite\", \"\") {\n\tcase \"lax\":\n\t\tCookieSameSite = http.SameSiteLaxMode\n\tcase \"strict\":\n\t\tCookieSameSite = http.SameSiteStrictMode\n\tcase \"none\":\n\t\tCookieSameSite = http.SameSiteNoneMode\n\tdefault:\n\t\tCookieSameSite = http.SameSiteDefaultMode\n\t}\n\n\tif secretStr := Config.StringDefault(\"app.secret\", \"\"); secretStr != \"\" {\n\t\tSetSecretKey([]byte(secretStr))\n\t}\n\n\tRaiseEvent(REVEL_BEFORE_MODULES_LOADED, nil)\n\tloadModules()\n\tRaiseEvent(REVEL_AFTER_MODULES_LOADED, nil)\n\n\tInitialized = true\n\tRevelLog.Info(\"Initialized Revel\", \"Version\", Version, \"BuildDate\", BuildDate, \"MinimumGoVersion\", MinimumGoVersion)\n}\n\n// The input mode can be as simple as \"prod\" or it can be a JSON string like\n// {\"mode\":\"%s\",\"testModeFlag\":true}\n// When this function is called it returns the true \"inputmode\" extracted from the parameter\n// and it sets the log context appropriately.\nfunc updateLog(inputmode string) (returnMode string) {\n\tif inputmode == \"\" {\n\t\treturnMode = config.DefaultSection\n\t\treturn\n\t} else {\n\t\treturnMode = inputmode\n\t}\n\n\t// Check to see if the mode is a json object\n\tmodemap := map[string]interface{}{}\n\n\tvar testModeFlag, specialUseFlag bool\n\tif err := json.Unmarshal([]byte(inputmode), &modemap); err == nil {\n\t\treturnMode = modemap[\"mode\"].(string)\n\t\tif testmode, found := modemap[TEST_MODE_FLAG]; found {\n\t\t\ttestModeFlag, _ = testmode.(bool)\n\t\t}\n\t\tif specialUse, found := modemap[SPECIAL_USE_FLAG]; found {\n\t\t\tspecialUseFlag, _ = specialUse.(bool)\n\t\t}\n\t\tif packagePathMapI, found := modemap[\"packagePathMap\"]; found {\n\t\t\tfor k, v := range packagePathMapI.(map[string]interface{}) {\n\t\t\t\tpackagePathMap[k] = v.(string)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar newContext *config.Context\n\t// If the Config is nil, set the logger to minimal log messages by adding the option\n\tif Config == nil {\n\t\tnewContext = config.NewContext()\n\t\tnewContext.SetOption(TEST_MODE_FLAG, fmt.Sprint(true))\n\t} else {\n\t\t// Ensure that the selected runmode appears in app.conf.\n\t\t// If empty string is passed as the mode, treat it as \"DEFAULT\"\n\t\tif !Config.HasSection(returnMode) {\n\t\t\tRevelLog.Fatal(\"app.conf: Run mode not found:\", \"runmode\", returnMode)\n\t\t}\n\t\tConfig.SetSection(returnMode)\n\t\tnewContext = Config\n\t}\n\n\t// Only set the testmode flag if it doesnt exist\n\tif _, found := newContext.Bool(TEST_MODE_FLAG); !found {\n\t\tnewContext.SetOption(TEST_MODE_FLAG, fmt.Sprint(testModeFlag))\n\t}\n\tif _, found := newContext.Bool(SPECIAL_USE_FLAG); !found {\n\t\tnewContext.SetOption(SPECIAL_USE_FLAG, fmt.Sprint(specialUseFlag))\n\t}\n\n\tappHandle := logger.InitializeFromConfig(BasePath, newContext)\n\n\t// Set all the log handlers\n\tsetAppLog(AppLog, appHandle)\n\n\treturn\n}\n\n// Set the secret key.\nfunc SetSecretKey(newKey []byte) error {\n\tsecretKey = newKey\n\treturn nil\n}\n\n// ResolveImportPath returns the filesystem path for the given import path.\n// Returns an error if the import path could not be found.\nfunc ResolveImportPath(importPath string) (string, error) {\n\tif packaged {\n\t\treturn filepath.Join(SourcePath, importPath), nil\n\t}\n\tif path, found := packagePathMap[importPath]; found {\n\t\treturn path, nil\n\t}\n\n\tmodPkg, err := build.Import(importPath, RevelPath, build.FindOnly)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn modPkg.Dir, nil\n}\n\n// CheckInit method checks `revel.Initialized` if not initialized it panics.\nfunc CheckInit() {\n\tif !Initialized {\n\t\tRevelLog.Panic(\"CheckInit: Revel has not been initialized!\")\n\t}\n}\n\n// findSrcPaths uses the \"go/build\" package to find the source root for Revel\n// and the app.\nfunc findSrcPaths(importPath string) (revelSourcePath, appSourcePath string) {\n\tif importFsPath, found := packagePathMap[importPath]; found {\n\t\treturn packagePathMap[RevelImportPath], importFsPath\n\t}\n\tvar (\n\t\tgopaths = filepath.SplitList(build.Default.GOPATH)\n\t\tgoroot  = build.Default.GOROOT\n\t)\n\n\tif len(gopaths) == 0 {\n\t\tRevelLog.Fatal(\"GOPATH environment variable is not set. \" +\n\t\t\t\"Please refer to http://golang.org/doc/code.html to configure your Go environment.\")\n\t}\n\n\tif ContainsString(gopaths, goroot) {\n\t\tRevelLog.Fatalf(\"GOPATH (%s) must not include your GOROOT (%s). \"+\n\t\t\t\"Please refer to http://golang.org/doc/code.html to configure your Go environment.\",\n\t\t\tgopaths, goroot)\n\t}\n\n\tappPkg, err := build.Import(importPath, \"\", build.FindOnly)\n\tif err != nil {\n\t\tRevelLog.Panic(\"Failed to import \"+importPath+\" with error:\", \"error\", err)\n\t}\n\n\trevelPkg, err := build.Import(RevelImportPath, appPkg.Dir, build.FindOnly)\n\tif err != nil {\n\t\tRevelLog.Fatal(\"Failed to find Revel with error:\", \"error\", err)\n\t}\n\n\treturn revelPkg.Dir, appPkg.Dir\n}\n"
        },
        {
          "name": "revel_hooks.go",
          "type": "blob",
          "size": 2.5234375,
          "content": "package revel\n\nimport (\n\t\"sort\"\n)\n\n// The list of startup hooks.\ntype (\n\t// The startup hooks structure.\n\tRevelHook struct {\n\t\torder int    // The order\n\t\tf     func() // The function to call\n\t}\n\n\tRevelHooks []RevelHook\n)\n\nvar (\n\t// The local instance of the list.\n\tstartupHooks RevelHooks\n\n\t// The instance of the list.\n\tshutdownHooks RevelHooks\n)\n\n// Called to run the hooks.\nfunc (r RevelHooks) Run() {\n\tserverLogger.Infof(\"There is %d hooks need to run ...\", len(r))\n\tsort.Sort(r)\n\tfor i, hook := range r {\n\t\tutilLog.Infof(\"Run the %d hook ...\", i+1)\n\t\thook.f()\n\t}\n}\n\n// Adds a new function hook, using the order.\nfunc (r RevelHooks) Add(fn func(), order ...int) RevelHooks {\n\to := 1\n\tif len(order) > 0 {\n\t\to = order[0]\n\t}\n\treturn append(r, RevelHook{order: o, f: fn})\n}\n\n// Sorting function.\nfunc (slice RevelHooks) Len() int {\n\treturn len(slice)\n}\n\n// Sorting function.\nfunc (slice RevelHooks) Less(i, j int) bool {\n\treturn slice[i].order < slice[j].order\n}\n\n// Sorting function.\nfunc (slice RevelHooks) Swap(i, j int) {\n\tslice[i], slice[j] = slice[j], slice[i]\n}\n\n// OnAppStart registers a function to be run at app startup.\n//\n// The order you register the functions will be the order they are run.\n// You can think of it as a FIFO queue.\n// This process will happen after the config file is read\n// and before the server is listening for connections.\n//\n// Ideally, your application should have only one call to init() in the file init.go.\n// The reason being that the call order of multiple init() functions in\n// the same package is undefined.\n// Inside of init() call revel.OnAppStart() for each function you wish to register.\n//\n// Example:\n//\n//      // from: yourapp/app/controllers/somefile.go\n//      func InitDB() {\n//          // do DB connection stuff here\n//      }\n//\n//      func FillCache() {\n//          // fill a cache from DB\n//          // this depends on InitDB having been run\n//      }\n//\n//      // from: yourapp/app/init.go\n//      func init() {\n//          // set up filters...\n//\n//          // register startup functions\n//          revel.OnAppStart(InitDB)\n//          revel.OnAppStart(FillCache)\n//      }\n//\n// This can be useful when you need to establish connections to databases or third-party services,\n// setup app components, compile assets, or any thing you need to do between starting Revel and accepting connections.\n//\nfunc OnAppStart(f func(), order ...int) {\n\tstartupHooks = startupHooks.Add(f, order...)\n}\n\n// Called to add a new stop hook.\nfunc OnAppStop(f func(), order ...int) {\n\tshutdownHooks = shutdownHooks.Add(f, order...)\n}\n"
        },
        {
          "name": "revel_test.go",
          "type": "blob",
          "size": 0.2451171875,
          "content": "package revel\n\nimport (\n\t\"net/http\"\n)\n\nfunc NewTestController(w http.ResponseWriter, r *http.Request) *Controller {\n\tcontext := NewGoContext(nil)\n\tcontext.Request.SetRequest(r)\n\tcontext.Response.SetResponse(w)\n\tc := NewController(context)\n\treturn c\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 28.3173828125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"encoding/csv\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/revel/pathtree\"\n\t\"github.com/revel/revel/logger\"\n)\n\nconst (\n\thttpStatusCode = \"404\"\n)\n\ntype Route struct {\n\tModuleSource        *Module         // Module name of route\n\tMethod              string          // e.g. GET\n\tPath                string          // e.g. /app/:id\n\tAction              string          // e.g. \"Application.ShowApp\", \"404\"\n\tControllerNamespace string          // e.g. \"testmodule.\",\n\tControllerName      string          // e.g. \"Application\", \"\"\n\tMethodName          string          // e.g. \"ShowApp\", \"\"\n\tFixedParams         []string        // e.g. \"arg1\",\"arg2\",\"arg3\" (CSV formatting)\n\tTreePath            string          // e.g. \"/GET/app/:id\"\n\tTypeOfController    *ControllerType // The controller type (if route is not wild carded)\n\n\troutesPath string // e.g. /Users/robfig/gocode/src/myapp/conf/routes\n\tline       int    // e.g. 3\n}\n\ntype RouteMatch struct {\n\tAction           string // e.g. 404\n\tControllerName   string // e.g. Application\n\tMethodName       string // e.g. ShowApp\n\tFixedParams      []string\n\tParams           map[string][]string // e.g. {id: 123}\n\tTypeOfController *ControllerType     // The controller type\n\tModuleSource     *Module             // The module\n}\n\ntype ActionPathData struct {\n\tKey                 string            // The unique key\n\tControllerNamespace string            // The controller namespace\n\tControllerName      string            // The controller name\n\tMethodName          string            // The method name\n\tAction              string            // The action\n\tModuleSource        *Module           // The module\n\tRoute               *Route            // The route\n\tFixedParamsByName   map[string]string // The fixed parameters\n\tTypeOfController    *ControllerType   // The controller type\n}\n\nvar (\n\t// Used to store decoded action path mappings.\n\tactionPathCacheMap = map[string]*ActionPathData{}\n\t// Used to prevent concurrent writes to map.\n\tactionPathCacheLock = sync.Mutex{}\n\t// The path returned if not found.\n\tnotFound = &RouteMatch{Action: \"404\"}\n)\n\nvar routerLog = RevelLog.New(\"section\", \"router\")\n\nfunc init() {\n\tAddInitEventHandler(func(typeOf Event, value interface{}) (responseOf EventResponse) {\n\t\t// Add in an\n\t\tif typeOf == ROUTE_REFRESH_REQUESTED {\n\t\t\t// Clear the actionPathCacheMap cache\n\t\t\tactionPathCacheLock.Lock()\n\t\t\tdefer actionPathCacheLock.Unlock()\n\t\t\tactionPathCacheMap = map[string]*ActionPathData{}\n\t\t}\n\t\treturn\n\t})\n}\n\n// NewRoute prepares the route to be used in matching.\nfunc NewRoute(moduleSource *Module, method, path, action, fixedArgs, routesPath string, line int) (r *Route) {\n\t// Handle fixed arguments\n\targsReader := strings.NewReader(string(namespaceReplace([]byte(fixedArgs), moduleSource)))\n\tcsvReader := csv.NewReader(argsReader)\n\tcsvReader.TrimLeadingSpace = true\n\tfargs, err := csvReader.Read()\n\tif err != nil && err != io.EOF {\n\t\trouterLog.Error(\"NewRoute: Invalid fixed parameters for string \", \"error\", err, \"fixedargs\", fixedArgs)\n\t}\n\n\tr = &Route{\n\t\tModuleSource: moduleSource,\n\t\tMethod:       strings.ToUpper(method),\n\t\tPath:         path,\n\t\tAction:       string(namespaceReplace([]byte(action), moduleSource)),\n\t\tFixedParams:  fargs,\n\t\tTreePath:     treePath(strings.ToUpper(method), path),\n\t\troutesPath:   routesPath,\n\t\tline:         line,\n\t}\n\n\t// URL pattern\n\tif !strings.HasPrefix(r.Path, \"/\") {\n\t\trouterLog.Error(\"NewRoute: Absolute URL required.\")\n\t\treturn\n\t}\n\n\t// Ignore the not found status code\n\tif action != httpStatusCode {\n\t\trouterLog.Debugf(\"NewRoute: New splitActionPath path:%s action:%s\", path, action)\n\t\tpathData, found := splitActionPath(&ActionPathData{ModuleSource: moduleSource, Route: r}, r.Action, false)\n\t\tif found {\n\t\t\tif pathData.TypeOfController != nil {\n\t\t\t\t// Assign controller type to avoid looking it up based on name\n\t\t\t\tr.TypeOfController = pathData.TypeOfController\n\t\t\t\t// Create the fixed parameters\n\t\t\t\tif l := len(pathData.Route.FixedParams); l > 0 && len(pathData.FixedParamsByName) == 0 {\n\t\t\t\t\tmethodType := pathData.TypeOfController.Method(pathData.MethodName)\n\t\t\t\t\tif methodType != nil {\n\t\t\t\t\t\tpathData.FixedParamsByName = make(map[string]string, l)\n\t\t\t\t\t\tfor i, argValue := range pathData.Route.FixedParams {\n\t\t\t\t\t\t\tUnbind(pathData.FixedParamsByName, methodType.Args[i].Name, argValue)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trouterLog.Panicf(\"NewRoute: Method %s not found for controller %s\", pathData.MethodName, pathData.ControllerName)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.ControllerNamespace = pathData.ControllerNamespace\n\t\t\tr.ControllerName = pathData.ControllerName\n\t\t\tr.ModuleSource = pathData.ModuleSource\n\t\t\tr.MethodName = pathData.MethodName\n\n\t\t\t// The same action path could be used for multiple routes (like the Static.Serve)\n\t\t} else {\n\t\t\trouterLog.Panicf(\"NewRoute: Failed to find controller for route path action %s \\n%#v\\n\", path+\"?\"+r.Action, actionPathCacheMap)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (route *Route) ActionPath() string {\n\treturn route.ModuleSource.Namespace() + route.ControllerName\n}\n\nfunc treePath(method, path string) string {\n\tif method == \"*\" {\n\t\tmethod = \":METHOD\"\n\t}\n\treturn \"/\" + method + path\n}\n\ntype Router struct {\n\tRoutes []*Route\n\tTree   *pathtree.Node\n\tModule string // The module the route is associated with\n\tpath   string // path to the routes file\n}\n\nfunc (router *Router) Route(req *Request) (routeMatch *RouteMatch) {\n\t// Override method if set in header\n\tif method := req.GetHttpHeader(\"X-HTTP-Method-Override\"); method != \"\" && req.Method == \"POST\" {\n\t\treq.Method = method\n\t}\n\n\tleaf, expansions := router.Tree.Find(treePath(req.Method, req.GetPath()))\n\tif leaf == nil {\n\t\treturn nil\n\t}\n\n\t// Create a map of the route parameters.\n\tvar params url.Values\n\tif len(expansions) > 0 {\n\t\tparams = make(url.Values)\n\t\tfor i, v := range expansions {\n\t\t\tparams[leaf.Wildcards[i]] = []string{v}\n\t\t}\n\t}\n\tvar route *Route\n\tvar controllerName, methodName string\n\n\t// The leaf value is now a list of possible routes to match, only a controller\n\trouteList := leaf.Value.([]*Route)\n\tvar typeOfController *ControllerType\n\n\t// INFO.Printf(\"Found route for path %s %#v\", req.URL.Path, len(routeList))\n\tfor index := range routeList {\n\t\troute = routeList[index]\n\t\tmethodName = route.MethodName\n\n\t\t// Special handling for explicit 404's.\n\t\tif route.Action == httpStatusCode {\n\t\t\troute = nil\n\t\t\tbreak\n\t\t}\n\n\t\t// If wildcard match on method name use the method name from the params\n\t\tif methodName[0] == ':' {\n\t\t\tif methodKey, found := params[methodName[1:]]; found && len(methodKey) > 0 {\n\t\t\t\tmethodName = strings.ToLower(methodKey[0])\n\t\t\t} else {\n\t\t\t\trouterLog.Fatal(\"Route: Failure to find method name in parameters\", \"params\", params, \"methodName\", methodName)\n\t\t\t}\n\t\t}\n\n\t\t// If the action is variablized, replace into it with the captured args.\n\t\tcontrollerName = route.ControllerName\n\t\tif controllerName[0] == ':' {\n\t\t\tcontrollerName = strings.ToLower(params[controllerName[1:]][0])\n\t\t\tif typeOfController = route.ModuleSource.ControllerByName(controllerName, methodName); typeOfController != nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t} else {\n\t\t\ttypeOfController = route.TypeOfController\n\t\t\tbreak\n\t\t}\n\t\troute = nil\n\t}\n\n\tif route == nil {\n\t\trouteMatch = notFound\n\t} else {\n\t\trouteMatch = &RouteMatch{\n\t\t\tControllerName:   route.ControllerNamespace + controllerName,\n\t\t\tMethodName:       methodName,\n\t\t\tParams:           params,\n\t\t\tFixedParams:      route.FixedParams,\n\t\t\tTypeOfController: typeOfController,\n\t\t\tModuleSource:     route.ModuleSource,\n\t\t}\n\t}\n\n\treturn\n}\n\n// Refresh re-reads the routes file and re-calculates the routing table.\n// Returns an error if a specified action could not be found.\nfunc (router *Router) Refresh() (err *Error) {\n\tRaiseEvent(ROUTE_REFRESH_REQUESTED, nil)\n\trouter.Routes, err = parseRoutesFile(appModule, router.path, \"\", true)\n\tRaiseEvent(ROUTE_REFRESH_COMPLETED, nil)\n\tif err != nil {\n\t\treturn\n\t}\n\terr = router.updateTree()\n\treturn\n}\n\nfunc (router *Router) updateTree() *Error {\n\trouter.Tree = pathtree.New()\n\tpathMap := map[string][]*Route{}\n\n\tallPathsOrdered := []string{}\n\t// It is possible for some route paths to overlap\n\t// based on wildcard matches,\n\t// TODO when pathtree is fixed (made to be smart enough to not require a predefined intake order) keeping the routes in order is not necessary\n\tfor _, route := range router.Routes {\n\t\tif _, found := pathMap[route.TreePath]; !found {\n\t\t\tpathMap[route.TreePath] = append(pathMap[route.TreePath], route)\n\t\t\tallPathsOrdered = append(allPathsOrdered, route.TreePath)\n\t\t} else {\n\t\t\tpathMap[route.TreePath] = append(pathMap[route.TreePath], route)\n\t\t}\n\t}\n\tfor _, path := range allPathsOrdered {\n\t\trouteList := pathMap[path]\n\t\terr := router.Tree.Add(path, routeList)\n\n\t\t// Allow GETs to respond to HEAD requests.\n\t\tif err == nil && routeList[0].Method == \"GET\" {\n\t\t\terr = router.Tree.Add(treePath(\"HEAD\", routeList[0].Path), routeList)\n\t\t}\n\n\t\t// Error adding a route to the pathtree.\n\t\tif err != nil {\n\t\t\treturn routeError(err, path, fmt.Sprintf(\"%#v\", routeList), routeList[0].line)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Returns the controller namespace and name, action and module if found from the actionPath specified.\nfunc splitActionPath(actionPathData *ActionPathData, actionPath string, useCache bool) (pathData *ActionPathData, found bool) {\n\tactionPath = strings.ToLower(actionPath)\n\tif pathData, found = actionPathCacheMap[actionPath]; found && useCache {\n\t\treturn\n\t}\n\tvar (\n\t\tcontrollerNamespace, controllerName, methodName, action string\n\t\tfoundModuleSource                                       *Module\n\t\ttypeOfController                                        *ControllerType\n\t\tlog                                                     = routerLog.New(\"actionPath\", actionPath)\n\t)\n\tactionSplit := strings.Split(actionPath, \".\")\n\tif actionPathData != nil {\n\t\tfoundModuleSource = actionPathData.ModuleSource\n\t}\n\tif len(actionSplit) == 2 {\n\t\tcontrollerName, methodName = strings.ToLower(actionSplit[0]), strings.ToLower(actionSplit[1])\n\t\tif i := strings.Index(methodName, \"(\"); i > 0 {\n\t\t\tmethodName = methodName[:i]\n\t\t}\n\t\tlog = log.New(\"controller\", controllerName, \"method\", methodName)\n\t\tlog.Debug(\"splitActionPath: Check for namespace\")\n\t\tif i := strings.Index(controllerName, namespaceSeperator); i > -1 {\n\t\t\tcontrollerNamespace = controllerName[:i+1]\n\t\t\tif moduleSource, found := ModuleByName(controllerNamespace[:len(controllerNamespace)-1]); found {\n\t\t\t\tfoundModuleSource = moduleSource\n\t\t\t\tcontrollerNamespace = moduleSource.Namespace()\n\t\t\t\tlog = log.New(\"namespace\", controllerNamespace)\n\t\t\t\tlog.Debug(\"Found module namespace\")\n\t\t\t} else {\n\t\t\t\tlog.Warnf(\"splitActionPath: Unable to find module %s for action: %s\", controllerNamespace[:len(controllerNamespace)-1], actionPath)\n\t\t\t}\n\t\t\tcontrollerName = controllerName[i+1:]\n\t\t\tlog = log.New(\"controllerShortName\", controllerName)\n\t\t\t// Check for the type of controller\n\t\t\ttypeOfController = foundModuleSource.ControllerByName(controllerName, methodName)\n\t\t\tfound = typeOfController != nil\n\t\t\tlog.Debug(\"Found controller\", \"found\", found, \"type\", typeOfController)\n\t\t} else if controllerName[0] != ':' {\n\t\t\t// First attempt to find the controller in the module source\n\t\t\tif foundModuleSource != nil {\n\t\t\t\ttypeOfController = foundModuleSource.ControllerByName(controllerName, methodName)\n\t\t\t\tif typeOfController != nil {\n\t\t\t\t\tcontrollerNamespace = typeOfController.Namespace\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.Info(\"Found controller for path\", \"controllerType\", typeOfController)\n\n\t\t\tif typeOfController == nil {\n\t\t\t\t// Check to see if we can determine the controller from only the controller name\n\t\t\t\t// an actionPath without a moduleSource will only come from\n\t\t\t\t// Scan through the controllers\n\t\t\t\tmatchName := controllerName\n\t\t\t\tfor key, controller := range controllers {\n\t\t\t\t\t// Strip away the namespace from the controller. to be match\n\t\t\t\t\tregularName := key\n\t\t\t\t\tif i := strings.Index(key, namespaceSeperator); i > -1 {\n\t\t\t\t\t\tregularName = regularName[i+1:]\n\t\t\t\t\t}\n\t\t\t\t\tif regularName == matchName {\n\t\t\t\t\t\t// Found controller match\n\t\t\t\t\t\ttypeOfController = controller\n\t\t\t\t\t\tcontrollerNamespace = typeOfController.Namespace\n\t\t\t\t\t\tcontrollerName = typeOfController.ShortName()\n\t\t\t\t\t\tfoundModuleSource = typeOfController.ModuleSource\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t} else {\n\t\t\t// If wildcard assign the route the controller namespace found\n\t\t\tcontrollerNamespace = actionPathData.ModuleSource.Name + namespaceSeperator\n\t\t\tfoundModuleSource = actionPathData.ModuleSource\n\t\t\tfound = true\n\t\t}\n\t\taction = actionSplit[1]\n\t} else {\n\t\tfoundPaths := \"\"\n\t\tfor path := range actionPathCacheMap {\n\t\t\tfoundPaths += path + \",\"\n\t\t}\n\t\tlog.Warnf(\"splitActionPath: Invalid action path %s found paths %s\", actionPath, foundPaths)\n\t\tfound = false\n\t}\n\n\t// Make sure no concurrent map writes occur\n\tif found {\n\t\tactionPathCacheLock.Lock()\n\t\tdefer actionPathCacheLock.Unlock()\n\t\tif actionPathData != nil {\n\t\t\tactionPathData.ControllerNamespace = controllerNamespace\n\t\t\tactionPathData.ControllerName = controllerName\n\t\t\tactionPathData.MethodName = methodName\n\t\t\tactionPathData.Action = action\n\t\t\tactionPathData.ModuleSource = foundModuleSource\n\t\t\tactionPathData.TypeOfController = typeOfController\n\t\t} else {\n\t\t\tactionPathData = &ActionPathData{\n\t\t\t\tControllerNamespace: controllerNamespace,\n\t\t\t\tControllerName:      controllerName,\n\t\t\t\tMethodName:          methodName,\n\t\t\t\tAction:              action,\n\t\t\t\tModuleSource:        foundModuleSource,\n\t\t\t\tTypeOfController:    typeOfController,\n\t\t\t}\n\t\t}\n\t\tactionPathData.TypeOfController = foundModuleSource.ControllerByName(controllerName, \"\")\n\t\tif actionPathData.TypeOfController == nil && actionPathData.ControllerName[0] != ':' {\n\t\t\tlog.Warnf(\"splitActionPath: No controller found for %s %#v\", foundModuleSource.Namespace()+controllerName, controllers)\n\t\t}\n\n\t\tpathData = actionPathData\n\t\tif pathData.Route != nil && len(pathData.Route.FixedParams) > 0 {\n\t\t\t// If there are fixed params on the route then add them to the path\n\t\t\t// This will give it a unique path and it should still be usable for a reverse lookup provided the name is matchable\n\t\t\t// for example\n\t\t\t// GET   /test/                     Application.Index(\"Test\", \"Test2\")\n\t\t\t// {{url \"Application.Index(test,test)\" }}\n\t\t\t// should be parseable\n\t\t\tactionPath = actionPath + \"(\" + strings.ToLower(strings.Join(pathData.Route.FixedParams, \",\")) + \")\"\n\t\t}\n\t\tif actionPathData.Route != nil {\n\t\t\tlog.Debugf(\"splitActionPath: Split Storing recognized action path %s for route  %#v \", actionPath, actionPathData.Route)\n\t\t}\n\t\tpathData.Key = actionPath\n\t\tactionPathCacheMap[actionPath] = pathData\n\t\tif !strings.Contains(actionPath, namespaceSeperator) && pathData.TypeOfController != nil {\n\t\t\tactionPathCacheMap[strings.ToLower(pathData.TypeOfController.Namespace)+actionPath] = pathData\n\t\t\tlog.Debugf(\"splitActionPath: Split Storing recognized action path %s for route  %#v \", strings.ToLower(pathData.TypeOfController.Namespace)+actionPath, actionPathData.Route)\n\t\t}\n\t}\n\treturn\n}\n\n// parseRoutesFile reads the given routes file and returns the contained routes.\nfunc parseRoutesFile(moduleSource *Module, routesPath, joinedPath string, validate bool) ([]*Route, *Error) {\n\tcontentBytes, err := ioutil.ReadFile(routesPath)\n\tif err != nil {\n\t\treturn nil, &Error{\n\t\t\tTitle:       \"Failed to load routes file\",\n\t\t\tDescription: err.Error(),\n\t\t}\n\t}\n\treturn parseRoutes(moduleSource, routesPath, joinedPath, string(contentBytes), validate)\n}\n\n// parseRoutes reads the content of a routes file into the routing table.\nfunc parseRoutes(moduleSource *Module, routesPath, joinedPath, content string, validate bool) ([]*Route, *Error) {\n\tvar routes []*Route\n\n\t// For each line..\n\tfor n, line := range strings.Split(content, \"\\n\") {\n\t\tline = strings.TrimSpace(line)\n\t\tif len(line) == 0 || line[0] == '#' {\n\t\t\tcontinue\n\t\t}\n\n\t\tconst modulePrefix = \"module:\"\n\n\t\t// Handle included routes from modules.\n\t\t// e.g. \"module:testrunner\" imports all routes from that module.\n\t\tif strings.HasPrefix(line, modulePrefix) {\n\t\t\tmoduleRoutes, err := getModuleRoutes(line[len(modulePrefix):], joinedPath, validate)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, routeError(err, routesPath, content, n)\n\t\t\t}\n\t\t\troutes = append(routes, moduleRoutes...)\n\t\t\tcontinue\n\t\t}\n\n\t\t// A single route\n\t\tmethod, path, action, fixedArgs, found := parseRouteLine(line)\n\t\tif !found {\n\t\t\tcontinue\n\t\t}\n\n\t\t// this will avoid accidental double forward slashes in a route.\n\t\t// this also avoids pathtree freaking out and causing a runtime panic\n\t\t// because of the double slashes\n\t\tif strings.HasSuffix(joinedPath, \"/\") && strings.HasPrefix(path, \"/\") {\n\t\t\tjoinedPath = joinedPath[0 : len(joinedPath)-1]\n\t\t}\n\t\tpath = strings.Join([]string{AppRoot, joinedPath, path}, \"\")\n\n\t\t// This will import the module routes under the path described in the\n\t\t// routes file (joinedPath param). e.g. \"* /jobs module:jobs\" -> all\n\t\t// routes' paths will have the path /jobs prepended to them.\n\t\t// See #282 for more info\n\t\tif method == \"*\" && strings.HasPrefix(action, modulePrefix) {\n\t\t\tmoduleRoutes, err := getModuleRoutes(action[len(modulePrefix):], path, validate)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, routeError(err, routesPath, content, n)\n\t\t\t}\n\t\t\troutes = append(routes, moduleRoutes...)\n\t\t\tcontinue\n\t\t}\n\n\t\troute := NewRoute(moduleSource, method, path, action, fixedArgs, routesPath, n)\n\t\troutes = append(routes, route)\n\n\t\tif validate {\n\t\t\tif err := validateRoute(route); err != nil {\n\t\t\t\treturn nil, routeError(err, routesPath, content, n)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn routes, nil\n}\n\n// validateRoute checks that every specified action exists.\nfunc validateRoute(route *Route) error {\n\t// Skip 404s\n\tif route.Action == httpStatusCode {\n\t\treturn nil\n\t}\n\n\t// Skip variable routes.\n\tif route.ControllerName[0] == ':' || route.MethodName[0] == ':' {\n\t\treturn nil\n\t}\n\n\t// Precheck to see if controller exists\n\tif _, found := controllers[route.ControllerNamespace+route.ControllerName]; !found {\n\t\t// Scan through controllers to find module\n\t\tfor _, c := range controllers {\n\t\t\tcontrollerName := strings.ToLower(c.Type.Name())\n\t\t\tif controllerName == route.ControllerName {\n\t\t\t\troute.ControllerNamespace = c.ModuleSource.Name + namespaceSeperator\n\t\t\t\trouterLog.Warn(\"validateRoute: Matched empty namespace route for %s to this namespace %s for the route %s\", controllerName, c.ModuleSource.Name, route.Path)\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO need to check later\n\t// does it do only validation or validation and instantiate the controller.\n\tvar c Controller\n\treturn c.SetTypeAction(route.ControllerNamespace+route.ControllerName, route.MethodName, route.TypeOfController)\n}\n\n// routeError adds context to a simple error message.\nfunc routeError(err error, routesPath, content string, n int) *Error {\n\tif revelError, ok := err.(*Error); ok {\n\t\treturn revelError\n\t}\n\t// Load the route file content if necessary\n\tif content == \"\" {\n\t\tif contentBytes, er := ioutil.ReadFile(routesPath); er != nil {\n\t\t\trouterLog.Error(\"routeError: Failed to read route file \", \"file\", routesPath, \"error\", er)\n\t\t} else {\n\t\t\tcontent = string(contentBytes)\n\t\t}\n\t}\n\treturn &Error{\n\t\tTitle:       \"Route validation error\",\n\t\tDescription: err.Error(),\n\t\tPath:        routesPath,\n\t\tLine:        n + 1,\n\t\tSourceLines: strings.Split(content, \"\\n\"),\n\t\tStack:       fmt.Sprintf(\"%s\", logger.NewCallStack()),\n\t}\n}\n\n// getModuleRoutes loads the routes file for the given module and returns the\n// list of routes.\nfunc getModuleRoutes(moduleName, joinedPath string, validate bool) (routes []*Route, err *Error) {\n\t// Look up the module.  It may be not found due to the common case of e.g. the\n\t// testrunner module being active only in dev mode.\n\tmodule, found := ModuleByName(moduleName)\n\tif !found {\n\t\trouterLog.Debug(\"getModuleRoutes: Skipping routes for inactive module\", \"module\", moduleName)\n\t\treturn nil, nil\n\t}\n\troutePath := filepath.Join(module.Path, \"conf\", \"routes\")\n\tif _, e := os.Stat(routePath); e == nil {\n\t\troutes, err = parseRoutesFile(module, routePath, joinedPath, validate)\n\t}\n\tif err == nil {\n\t\tfor _, route := range routes {\n\t\t\troute.ModuleSource = module\n\t\t}\n\t}\n\n\treturn routes, err\n}\n\n// Groups:\n// 1: method\n// 4: path\n// 5: action\n// 6: fixedargs\nvar routePattern = regexp.MustCompile(\n\t\"(?i)^(GET|POST|PUT|DELETE|PATCH|OPTIONS|HEAD|WS|PROPFIND|MKCOL|COPY|MOVE|PROPPATCH|LOCK|UNLOCK|TRACE|PURGE|\\\\*)\" +\n\t\t\"[(]?([^)]*)(\\\\))?[ \\t]+\" +\n\t\t\"(.*/[^ \\t]*)[ \\t]+([^ \\t(]+)\" +\n\t\t`\\(?([^)]*)\\)?[ \\t]*$`)\n\nfunc parseRouteLine(line string) (method, path, action, fixedArgs string, found bool) {\n\tmatches := routePattern.FindStringSubmatch(line)\n\tif matches == nil {\n\t\treturn\n\t}\n\tmethod, path, action, fixedArgs = matches[1], matches[4], matches[5], matches[6]\n\tfound = true\n\treturn\n}\n\nfunc NewRouter(routesPath string) *Router {\n\treturn &Router{\n\t\tTree: pathtree.New(),\n\t\tpath: routesPath,\n\t}\n}\n\ntype ActionDefinition struct {\n\tHost, Method, URL, Action string\n\tStar                      bool\n\tArgs                      map[string]string\n}\n\nfunc (a *ActionDefinition) String() string {\n\treturn a.URL\n}\n\nfunc (router *Router) Reverse(action string, argValues map[string]string) (ad *ActionDefinition) {\n\tad, err := router.ReverseError(action, argValues, nil)\n\tif err != nil {\n\t\trouterLog.Error(\"splitActionPath: Failed to find reverse route\", \"action\", action, \"arguments\", argValues)\n\t}\n\treturn ad\n}\n\nfunc (router *Router) ReverseError(action string, argValues map[string]string, req *Request) (ad *ActionDefinition, err error) {\n\tvar log logger.MultiLogger\n\tif req != nil {\n\t\tlog = req.controller.Log.New(\"action\", action)\n\t} else {\n\t\tlog = routerLog.New(\"action\", action)\n\t}\n\tpathData, found := splitActionPath(nil, action, true)\n\tif !found {\n\t\tlog.Error(\"splitActionPath: Failed to find reverse route\", \"action\", action, \"arguments\", argValues)\n\t\treturn\n\t}\n\n\tlog.Debug(\"Checking for route\", \"pathdataRoute\", pathData.Route)\n\tif pathData.Route == nil {\n\t\tvar possibleRoute *Route\n\t\t// If the route is nil then we need to go through the routes to find the first matching route\n\t\t// from this controllers namespace, this is likely a wildcard route match\n\t\tfor _, route := range router.Routes {\n\t\t\t// Skip routes that are not wild card or empty\n\t\t\tif route.ControllerName == \"\" || route.MethodName == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif route.ModuleSource == pathData.ModuleSource && route.ControllerName[0] == ':' {\n\t\t\t\t// Wildcard match in same module space\n\t\t\t\tpathData.Route = route\n\t\t\t\tbreak\n\t\t\t} else if route.ActionPath() == pathData.ModuleSource.Namespace()+pathData.ControllerName &&\n\t\t\t\t(route.Method[0] == ':' || route.Method == pathData.MethodName) {\n\t\t\t\t// Action path match\n\t\t\t\tpathData.Route = route\n\t\t\t\tbreak\n\t\t\t} else if route.ControllerName == pathData.ControllerName &&\n\t\t\t\t(route.Method[0] == ':' || route.Method == pathData.MethodName) {\n\t\t\t\t// Controller name match\n\t\t\t\tpossibleRoute = route\n\t\t\t}\n\t\t}\n\t\tif pathData.Route == nil && possibleRoute != nil {\n\t\t\tpathData.Route = possibleRoute\n\t\t\trouterLog.Warnf(\"Reverse: For a url reverse a match was based on  %s matched path to route %#v \", action, possibleRoute)\n\t\t}\n\t\tif pathData.Route != nil {\n\t\t\trouterLog.Debugf(\"Reverse: Reverse Storing recognized action path %s for route %#v\\n\", action, pathData.Route)\n\t\t}\n\t}\n\n\t// Likely unknown route because of a wildcard, perform manual lookup\n\tif pathData.Route != nil {\n\t\troute := pathData.Route\n\n\t\t// If the controller or method are wildcards we need to populate the argValues\n\t\tcontrollerWildcard := route.ControllerName[0] == ':'\n\t\tmethodWildcard := route.MethodName[0] == ':'\n\n\t\t// populate route arguments with the names\n\t\tif controllerWildcard {\n\t\t\targValues[route.ControllerName[1:]] = pathData.ControllerName\n\t\t}\n\t\tif methodWildcard {\n\t\t\targValues[route.MethodName[1:]] = pathData.MethodName\n\t\t}\n\t\t// In theory all routes should be defined and pre-populated, the route controllers may not be though\n\t\t// with wildcard routes\n\t\tif pathData.TypeOfController == nil {\n\t\t\tif controllerWildcard || methodWildcard {\n\t\t\t\tif controller := ControllerTypeByName(pathData.ControllerNamespace+pathData.ControllerName, route.ModuleSource); controller != nil {\n\t\t\t\t\t// Wildcard match boundary\n\t\t\t\t\tpathData.TypeOfController = controller\n\t\t\t\t\t// See if the path exists in the module based\n\t\t\t\t} else {\n\t\t\t\t\tlog.Errorf(\"Reverse: Controller %s not found in reverse lookup\", pathData.ControllerNamespace+pathData.ControllerName)\n\t\t\t\t\terr = errors.New(\"Reverse: Controller not found in reverse lookup\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif pathData.TypeOfController == nil {\n\t\t\tlog.Errorf(\"Reverse: Controller %s not found in reverse lookup\", pathData.ControllerNamespace+pathData.ControllerName)\n\t\t\terr = errors.New(\"Reverse: Controller not found in reverse lookup\")\n\t\t\treturn\n\t\t}\n\t\tvar (\n\t\t\tqueryValues  = make(url.Values)\n\t\t\tpathElements = strings.Split(route.Path, \"/\")\n\t\t)\n\t\tfor i, el := range pathElements {\n\t\t\tif el == \"\" || (el[0] != ':' && el[0] != '*') {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tval, ok := pathData.FixedParamsByName[el[1:]]\n\t\t\tif !ok {\n\t\t\t\tval, ok = argValues[el[1:]]\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tval = \"<nil>\"\n\t\t\t\tlog.Error(\"Reverse: reverse route missing route argument \", \"argument\", el[1:])\n\t\t\t\terr = errors.New(\"Missing route argument\")\n\t\t\t\tpanic(\"Check stack\")\n\t\t\t}\n\t\t\tpathElements[i] = val\n\t\t\tdelete(argValues, el[1:])\n\t\t\tcontinue\n\t\t}\n\n\t\t// Add any args that were not inserted into the path into the query string.\n\t\tfor k, v := range argValues {\n\t\t\tqueryValues.Set(k, v)\n\t\t}\n\n\t\t// Calculate the final URL and Method\n\t\turlPath := strings.Join(pathElements, \"/\")\n\t\tif len(queryValues) > 0 {\n\t\t\turlPath += \"?\" + queryValues.Encode()\n\t\t}\n\n\t\tmethod := route.Method\n\t\tstar := false\n\t\tif route.Method == \"*\" {\n\t\t\tmethod = \"GET\"\n\t\t\tstar = true\n\t\t}\n\n\t\tlog.Debugf(\"Reversing action %s to %s Using Route %#v\", action, urlPath, pathData.Route)\n\n\t\tad = &ActionDefinition{\n\t\t\tURL:    urlPath,\n\t\t\tMethod: method,\n\t\t\tStar:   star,\n\t\t\tAction: action,\n\t\t\tArgs:   argValues,\n\t\t\tHost:   \"TODO\",\n\t\t}\n\t\treturn\n\t}\n\n\trouterLog.Error(\"Reverse: Failed to find controller for reverse route\", \"action\", action, \"arguments\", argValues)\n\terr = errors.New(\"Reverse: Failed to find controller for reverse route\")\n\treturn\n}\n\nfunc RouterFilter(c *Controller, fc []Filter) {\n\t// Figure out the Controller/Action\n\troute := MainRouter.Route(c.Request)\n\tif route == nil {\n\t\tc.Result = c.NotFound(\"No matching route found: \" + c.Request.GetRequestURI())\n\t\treturn\n\t}\n\n\t// The route may want to explicitly return a 404.\n\tif route.Action == httpStatusCode {\n\t\tc.Result = c.NotFound(\"(intentionally)\")\n\t\treturn\n\t}\n\n\t// Set the action.\n\tif err := c.SetTypeAction(route.ControllerName, route.MethodName, route.TypeOfController); err != nil {\n\t\tc.Result = c.NotFound(err.Error())\n\t\treturn\n\t}\n\n\t// Add the route and fixed params to the Request Params.\n\tc.Params.Route = route.Params\n\t// Assign logger if from module\n\tif c.Type.ModuleSource != nil && c.Type.ModuleSource != appModule {\n\t\tc.Log = c.Type.ModuleSource.Log.New(\"ip\", c.ClientIP,\n\t\t\t\"path\", c.Request.URL.Path, \"method\", c.Request.Method)\n\t}\n\n\t// Add the fixed parameters mapped by name.\n\t// TODO: Pre-calculate this mapping.\n\tfor i, value := range route.FixedParams {\n\t\tif c.Params.Fixed == nil {\n\t\t\tc.Params.Fixed = make(url.Values)\n\t\t}\n\t\tif i < len(c.MethodType.Args) {\n\t\t\targ := c.MethodType.Args[i]\n\t\t\tc.Params.Fixed.Set(arg.Name, value)\n\t\t} else {\n\t\t\trouterLog.Warn(\"RouterFilter: Too many parameters to action\", \"action\", route.Action, \"value\", value)\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfc[0](c, fc[1:])\n}\n\n// HTTPMethodOverride overrides allowed http methods via form or browser param.\nfunc HTTPMethodOverride(c *Controller, fc []Filter) {\n\t// An array of HTTP verbs allowed.\n\tverbs := []string{\"POST\", \"PUT\", \"PATCH\", \"DELETE\"}\n\n\tmethod := strings.ToUpper(c.Request.Method)\n\n\tif method == \"POST\" {\n\t\tparam := \"\"\n\t\tif f, err := c.Request.GetForm(); err == nil {\n\t\t\tparam = strings.ToUpper(f.Get(\"_method\"))\n\t\t}\n\n\t\tif len(param) > 0 {\n\t\t\toverride := false\n\t\t\t// Check if param is allowed\n\t\t\tfor _, verb := range verbs {\n\t\t\t\tif verb == param {\n\t\t\t\t\toverride = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif override {\n\t\t\t\tc.Request.Method = param\n\t\t\t} else {\n\t\t\t\tc.Response.Status = 405\n\t\t\t\tc.Result = c.RenderError(&Error{\n\t\t\t\t\tTitle:       \"Method not allowed\",\n\t\t\t\t\tDescription: \"Method \" + param + \" is not allowed (valid: \" + strings.Join(verbs, \", \") + \")\",\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\n\tfc[0](c, fc[1:]) // Execute the next filter stage.\n}\n\nfunc init() {\n\tOnAppStart(func() {\n\t\tMainRouter = NewRouter(filepath.Join(BasePath, \"conf\", \"routes\"))\n\t\terr := MainRouter.Refresh()\n\t\tif MainWatcher != nil && Config.BoolDefault(\"watch.routes\", true) {\n\t\t\tMainWatcher.Listen(MainRouter, MainRouter.path)\n\t\t} else if err != nil {\n\t\t\t// Not in dev mode and Route loading failed, we should crash.\n\t\t\trouterLog.Panic(\"init: router initialize error\", \"error\", err)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "router_test.go",
          "type": "blob",
          "size": 15.99609375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// Data-driven tests that check that a given routes-file line translates into\n// the expected Route object.\nvar routeTestCases = map[string]*Route{\n\t\"get / Application.Index\": {\n\t\tMethod:      \"GET\",\n\t\tPath:        \"/\",\n\t\tAction:      \"Application.Index\",\n\t\tFixedParams: []string{},\n\t},\n\n\t\"post /app/:id Application.SaveApp\": {\n\t\tMethod:      \"POST\",\n\t\tPath:        \"/app/:id\",\n\t\tAction:      \"Application.SaveApp\",\n\t\tFixedParams: []string{},\n\t},\n\n\t\"get /app/ Application.List\": {\n\t\tMethod:      \"GET\",\n\t\tPath:        \"/app/\",\n\t\tAction:      \"Application.List\",\n\t\tFixedParams: []string{},\n\t},\n\n\t`get /app/:appId/ Application.Show`: {\n\t\tMethod:      \"GET\",\n\t\tPath:        `/app/:appId/`,\n\t\tAction:      \"Application.Show\",\n\t\tFixedParams: []string{},\n\t},\n\n\t`get /app-wild/*appId/ Application.WildShow`: {\n\t\tMethod:      \"GET\",\n\t\tPath:        `/app-wild/*appId/`,\n\t\tAction:      \"Application.WildShow\",\n\t\tFixedParams: []string{},\n\t},\n\n\t`GET /public/:filepath   Static.Serve(\"public\")`: {\n\t\tMethod: \"GET\",\n\t\tPath:   \"/public/:filepath\",\n\t\tAction: \"Static.Serve\",\n\t\tFixedParams: []string{\n\t\t\t\"public\",\n\t\t},\n\t},\n\n\t`GET /javascript/:filepath Static.Serve(\"public/js\")`: {\n\t\tMethod: \"GET\",\n\t\tPath:   \"/javascript/:filepath\",\n\t\tAction: \"Static.Serve\",\n\t\tFixedParams: []string{\n\t\t\t\"public\",\n\t\t},\n\t},\n\n\t\"* /apps/:id/:action Application.:action\": {\n\t\tMethod:      \"*\",\n\t\tPath:        \"/apps/:id/:action\",\n\t\tAction:      \"Application.:action\",\n\t\tFixedParams: []string{},\n\t},\n\n\t\"* /:controller/:action :controller.:action\": {\n\t\tMethod:      \"*\",\n\t\tPath:        \"/:controller/:action\",\n\t\tAction:      \":controller.:action\",\n\t\tFixedParams: []string{},\n\t},\n\n\t`GET / Application.Index(\"Test\", \"Test2\")`: {\n\t\tMethod: \"GET\",\n\t\tPath:   \"/\",\n\t\tAction: \"Application.Index\",\n\t\tFixedParams: []string{\n\t\t\t\"Test\",\n\t\t\t\"Test2\",\n\t\t},\n\t},\n}\n\n// Run the test cases above.\nfunc TestComputeRoute(t *testing.T) {\n\tfor routeLine, expected := range routeTestCases {\n\t\tmethod, path, action, fixedArgs, found := parseRouteLine(routeLine)\n\t\tif !found {\n\t\t\tt.Error(\"Failed to parse route line:\", routeLine)\n\t\t\tcontinue\n\t\t}\n\t\tactual := NewRoute(appModule, method, path, action, fixedArgs, \"\", 0)\n\t\teq(t, \"Method\", actual.Method, expected.Method)\n\t\teq(t, \"Path\", actual.Path, expected.Path)\n\t\teq(t, \"Action\", actual.Action, expected.Action)\n\t\tif t.Failed() {\n\t\t\tt.Fatal(\"Failed on route:\", routeLine)\n\t\t}\n\t}\n}\n\n// Router Tests\n\nconst TestRoutes = `\n# This is a comment\nGET   \t\t/                   Application.Index\nGET   \t\t/test/              Application.Index(\"Test\", \"Test2\")\nGET   \t\t/app/:id/           Application.Show\nGET   \t\t/app-wild/*id/\t\tApplication.WildShow\nPOST  \t\t/app/:id            Application.Save\nPATCH \t\t/app/:id/           Application.Update\nPROPFIND\t/app/:id\t\t\tApplication.WebDevMethodPropFind\nMKCOL\t\t/app/:id\t\t\tApplication.WebDevMethodMkCol\nCOPY\t\t/app/:id\t\t\tApplication.WebDevMethodCopy\nMOVE\t\t/app/:id\t\t\tApplication.WebDevMethodMove\nPROPPATCH\t/app/:id\t\t\tApplication.WebDevMethodPropPatch\nLOCK\t\t/app/:id\t\t\tApplication.WebDevMethodLock\nUNLOCK\t\t/app/:id\t\t\tApplication.WebDevMethodUnLock\nTRACE\t\t/app/:id\t\t\tApplication.WebDevMethodTrace\nPURGE\t\t/app/:id\t\t\tApplication.CacheMethodPurge\nGET   /javascript/:filepath      App\\Static.Serve(\"public/js\")\nGET   /public/*filepath          Static.Serve(\"public\")\n*     /:controller/:action       :controller.:action\n\nGET   /favicon.ico               404\n`\n\nvar routeMatchTestCases = map[*http.Request]*RouteMatch{\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Index\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/test/\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Index\",\n\t\tFixedParams:    []string{\"Test\", \"Test2\"},\n\t\tParams:         map[string][]string{},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Show\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"PATCH\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Update\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"POST\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Save\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/app/123/\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Show\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/public/css/style.css\"},\n\t}: {\n\t\tControllerName: \"static\",\n\t\tMethodName:     \"Serve\",\n\t\tFixedParams:    []string{\"public\"},\n\t\tParams:         map[string][]string{\"filepath\": {\"css/style.css\"}},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/javascript/sessvars.js\"},\n\t}: {\n\t\tControllerName: \"static\",\n\t\tMethodName:     \"Serve\",\n\t\tFixedParams:    []string{\"public/js\"},\n\t\tParams:         map[string][]string{\"filepath\": {\"sessvars.js\"}},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/Implicit/Route\"},\n\t}: {\n\t\tControllerName: \"implicit\",\n\t\tMethodName:     \"Route\",\n\t\tFixedParams:    []string{},\n\t\tParams: map[string][]string{\n\t\t\t\"METHOD\":     {\"GET\"},\n\t\t\t\"controller\": {\"Implicit\"},\n\t\t\t\"action\":     {\"Route\"},\n\t\t},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/favicon.ico\"},\n\t}: {\n\t\tControllerName: \"\",\n\t\tMethodName:     \"\",\n\t\tAction:         \"404\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{},\n\t},\n\n\t{\n\t\tMethod: \"POST\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t\tHeader: http.Header{\"X-Http-Method-Override\": []string{\"PATCH\"}},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Update\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"GET\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t\tHeader: http.Header{\"X-Http-Method-Override\": []string{\"PATCH\"}},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Show\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"PATCH\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"Update\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"PROPFIND\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodPropFind\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"MKCOL\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodMkCol\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"COPY\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodCopy\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"MOVE\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodMove\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"PROPPATCH\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodPropPatch\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\t{\n\t\tMethod: \"LOCK\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodLock\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"UNLOCK\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodUnLock\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"TRACE\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"WebDevMethodTrace\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n\n\t{\n\t\tMethod: \"PURGE\",\n\t\tURL:    &url.URL{Path: \"/app/123\"},\n\t}: {\n\t\tControllerName: \"application\",\n\t\tMethodName:     \"CacheMethodPurge\",\n\t\tFixedParams:    []string{},\n\t\tParams:         map[string][]string{\"id\": {\"123\"}},\n\t},\n}\n\nfunc TestRouteMatches(t *testing.T) {\n\tinitControllers()\n\tBasePath = \"/BasePath\"\n\trouter := NewRouter(\"\")\n\trouter.Routes, _ = parseRoutes(appModule, \"\", \"\", TestRoutes, false)\n\tif err := router.updateTree(); err != nil {\n\t\tt.Errorf(\"updateTree failed: %s\", err)\n\t}\n\tfor req, expected := range routeMatchTestCases {\n\t\tt.Log(\"Routing:\", req.Method, req.URL)\n\n\t\tcontext := NewGoContext(nil)\n\t\tcontext.Request.SetRequest(req)\n\t\tc := NewTestController(nil, req)\n\n\t\tactual := router.Route(c.Request)\n\t\tif !eq(t, \"Found route\", actual != nil, expected != nil) {\n\t\t\tcontinue\n\t\t}\n\t\tif expected.ControllerName != \"\" {\n\t\t\teq(t, \"ControllerName\", actual.ControllerName, appModule.Namespace()+expected.ControllerName)\n\t\t} else {\n\t\t\teq(t, \"ControllerName\", actual.ControllerName, expected.ControllerName)\n\t\t}\n\n\t\teq(t, \"MethodName\", actual.MethodName, strings.ToLower(expected.MethodName))\n\t\teq(t, \"len(Params)\", len(actual.Params), len(expected.Params))\n\t\tfor key, actualValue := range actual.Params {\n\t\t\teq(t, \"Params \"+key, actualValue[0], expected.Params[key][0])\n\t\t}\n\t\teq(t, \"len(FixedParams)\", len(actual.FixedParams), len(expected.FixedParams))\n\t\tfor i, actualValue := range actual.FixedParams {\n\t\t\teq(t, \"FixedParams\", actualValue, expected.FixedParams[i])\n\t\t}\n\t}\n}\n\n// Reverse Routing\n\ntype ReverseRouteArgs struct {\n\taction string\n\targs   map[string]string\n}\n\nvar reverseRoutingTestCases = map[*ReverseRouteArgs]*ActionDefinition{\n\t{\n\t\taction: \"Application.Index\",\n\t\targs:   map[string]string{},\n\t}: {\n\t\tURL:    \"/\",\n\t\tMethod: \"GET\",\n\t\tStar:   false,\n\t\tAction: \"Application.Index\",\n\t},\n\n\t{\n\t\taction: \"Application.Show\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123/\",\n\t\tMethod: \"GET\",\n\t\tStar:   false,\n\t\tAction: \"Application.Show\",\n\t},\n\n\t{\n\t\taction: \"Implicit.Route\",\n\t\targs:   map[string]string{},\n\t}: {\n\t\tURL:    \"/implicit/route\",\n\t\tMethod: \"GET\",\n\t\tStar:   true,\n\t\tAction: \"Implicit.Route\",\n\t},\n\n\t{\n\t\taction: \"Application.Save\",\n\t\targs:   map[string]string{\"id\": \"123\", \"c\": \"http://continue\"},\n\t}: {\n\t\tURL:    \"/app/123?c=http%3A%2F%2Fcontinue\",\n\t\tMethod: \"POST\",\n\t\tStar:   false,\n\t\tAction: \"Application.Save\",\n\t},\n\n\t{\n\t\taction: \"Application.WildShow\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app-wild/123/\",\n\t\tMethod: \"GET\",\n\t\tStar:   false,\n\t\tAction: \"Application.WildShow\",\n\t},\n\n\t{\n\t\taction: \"Application.WebDevMethodPropFind\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"PROPFIND\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodPropFind\",\n\t},\n\t{\n\t\taction: \"Application.WebDevMethodMkCol\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"MKCOL\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodMkCol\",\n\t},\n\t{\n\t\taction: \"Application.WebDevMethodCopy\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"COPY\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodCopy\",\n\t},\n\t{\n\t\taction: \"Application.WebDevMethodMove\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"MOVE\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodMove\",\n\t},\n\t{\n\t\taction: \"Application.WebDevMethodPropPatch\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"PROPPATCH\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodPropPatch\",\n\t},\n\t{\n\t\taction: \"Application.WebDevMethodLock\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"LOCK\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodLock\",\n\t},\n\t{\n\t\taction: \"Application.WebDevMethodUnLock\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"UNLOCK\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodUnLock\",\n\t},\n\t{\n\t\taction: \"Application.WebDevMethodTrace\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"TRACE\",\n\t\tStar:   false,\n\t\tAction: \"Application.WebDevMethodTrace\",\n\t},\n\t{\n\t\taction: \"Application.CacheMethodPurge\",\n\t\targs:   map[string]string{\"id\": \"123\"},\n\t}: {\n\t\tURL:    \"/app/123\",\n\t\tMethod: \"PURGE\",\n\t\tStar:   false,\n\t\tAction: \"Application.CacheMethodPurge\",\n\t},\n}\n\nfunc initControllers() {\n\tregisterControllers()\n}\n\nfunc TestReverseRouting(t *testing.T) {\n\tinitControllers()\n\trouter := NewRouter(\"\")\n\trouter.Routes, _ = parseRoutes(appModule, \"\", \"\", TestRoutes, false)\n\tfor routeArgs, expected := range reverseRoutingTestCases {\n\t\tactual := router.Reverse(routeArgs.action, routeArgs.args)\n\t\tif !eq(t, fmt.Sprintf(\"Found route %s %s\", routeArgs.action, actual), actual != nil, expected != nil) {\n\t\t\tcontinue\n\t\t}\n\t\teq(t, \"Url\", actual.URL, expected.URL)\n\t\teq(t, \"Method\", actual.Method, expected.Method)\n\t\teq(t, \"Star\", actual.Star, expected.Star)\n\t\teq(t, \"Action\", actual.Action, expected.Action)\n\t}\n}\n\nfunc BenchmarkRouter(b *testing.B) {\n\trouter := NewRouter(\"\")\n\trouter.Routes, _ = parseRoutes(nil, \"\", \"\", TestRoutes, false)\n\tif err := router.updateTree(); err != nil {\n\t\tb.Errorf(\"updateTree failed: %s\", err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N/len(routeMatchTestCases); i++ {\n\t\tfor req := range routeMatchTestCases {\n\t\t\tc := NewTestController(nil, req)\n\t\t\tr := router.Route(c.Request)\n\t\t\tif r == nil {\n\t\t\t\tb.Errorf(\"Request not found: %s\", req.URL.Path)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// The benchmark from github.com/ant0ine/go-urlrouter.\nfunc BenchmarkLargeRouter(b *testing.B) {\n\trouter := NewRouter(\"\")\n\n\troutePaths := []string{\n\t\t\"/\",\n\t\t\"/signin\",\n\t\t\"/signout\",\n\t\t\"/profile\",\n\t\t\"/settings\",\n\t\t\"/upload/*file\",\n\t}\n\tfor i := 0; i < 10; i++ {\n\t\tfor j := 0; j < 5; j++ {\n\t\t\troutePaths = append(routePaths, fmt.Sprintf(\"/resource%d/:id/property%d\", i, j))\n\t\t}\n\t\troutePaths = append(routePaths, fmt.Sprintf(\"/resource%d/:id\", i))\n\t\troutePaths = append(routePaths, fmt.Sprintf(\"/resource%d\", i))\n\t}\n\troutePaths = append(routePaths, \"/:any\")\n\n\tfor _, p := range routePaths {\n\t\trouter.Routes = append(router.Routes,\n\t\t\tNewRoute(appModule, \"GET\", p, \"Controller.Action\", \"\", \"\", 0))\n\t}\n\tif err := router.updateTree(); err != nil {\n\t\tb.Errorf(\"updateTree failed: %s\", err)\n\t}\n\n\trequestUrls := []string{\n\t\t\"http://example.org/\",\n\t\t\"http://example.org/resource9/123\",\n\t\t\"http://example.org/resource9/123/property1\",\n\t\t\"http://example.org/doesnotexist\",\n\t}\n\tvar reqs []*http.Request\n\tfor _, url := range requestUrls {\n\t\treq, _ := http.NewRequest(\"GET\", url, nil)\n\t\treqs = append(reqs, req)\n\t}\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N/len(reqs); i++ {\n\t\tfor _, req := range reqs {\n\t\t\tc := NewTestController(nil, req)\n\t\t\troute := router.Route(c.Request)\n\t\t\tif route == nil {\n\t\t\t\tb.Errorf(\"Failed to route: %s\", req.URL.Path)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkRouterFilter(b *testing.B) {\n\tstartFakeBookingApp()\n\tcontrollers := []*Controller{\n\t\tNewTestController(nil, showRequest),\n\t\tNewTestController(nil, staticRequest),\n\t}\n\tfor _, c := range controllers {\n\t\tc.Params = &Params{}\n\t\tParseParams(c.Params, c.Request)\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N/len(controllers); i++ {\n\t\tfor _, c := range controllers {\n\t\t\tRouterFilter(c, NilChain)\n\t\t}\n\t}\n}\n\nfunc TestOverrideMethodFilter(t *testing.T) {\n\treq, _ := http.NewRequest(\"POST\", \"/hotels/3\", strings.NewReader(\"_method=put\"))\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded; param=value\")\n\tc := NewTestController(nil, req)\n\n\tif HTTPMethodOverride(c, NilChain); c.Request.Method != \"PUT\" {\n\t\tt.Errorf(\"Expected to override current method '%s' in route, found '%s' instead\", \"\", c.Request.Method)\n\t}\n}\n\n// Helpers\n\nfunc eq(t *testing.T, name string, a, b interface{}) bool {\n\tif a != b {\n\t\tt.Error(name, \": (actual)\", a, \" != \", b, \"(expected)\")\n\t\treturn false\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "server-engine.go",
          "type": "blob",
          "size": 6.3828125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\t/* Minimum Engine Type Values. */\n\t_ = iota\n\tENGINE_RESPONSE_STATUS\n\tENGINE_WRITER\n\tENGINE_PARAMETERS\n\tENGINE_PATH\n\tENGINE_REQUEST\n\tENGINE_RESPONSE\n)\n\nconst (\n\t/* HTTP Engine Type Values Starts at 1000. */\n\tHTTP_QUERY           = ENGINE_PARAMETERS\n\tHTTP_PATH            = ENGINE_PATH\n\tHTTP_BODY            = iota + 1000\n\tHTTP_FORM            = iota + 1000\n\tHTTP_MULTIPART_FORM  = iota + 1000\n\tHTTP_METHOD          = iota + 1000\n\tHTTP_REQUEST_URI     = iota + 1000\n\tHTTP_REQUEST_CONTEXT = iota + 1000\n\tHTTP_REMOTE_ADDR     = iota + 1000\n\tHTTP_HOST            = iota + 1000\n\tHTTP_URL             = iota + 1000\n\tHTTP_SERVER_HEADER   = iota + 1000\n\tHTTP_STREAM_WRITER   = iota + 1000\n\tHTTP_WRITER          = ENGINE_WRITER\n)\n\ntype (\n\tServerContext interface {\n\t\tGetRequest() ServerRequest\n\t\tGetResponse() ServerResponse\n\t}\n\n\t// Callback ServerRequest type.\n\tServerRequest interface {\n\t\tGetRaw() interface{}\n\t\tGet(theType int) (interface{}, error)\n\t\tSet(theType int, theValue interface{}) bool\n\t}\n\t// Callback ServerResponse type.\n\tServerResponse interface {\n\t\tServerRequest\n\t}\n\t// Callback WebSocket type.\n\tServerWebSocket interface {\n\t\tServerResponse\n\t\tMessageSendJSON(v interface{}) error\n\t\tMessageReceiveJSON(v interface{}) error\n\t\tMessageSend(v interface{}) error\n\t\tMessageReceive(v interface{}) error\n\t}\n\n\t// Expected response for HTTP_SERVER_HEADER type (if implemented).\n\tServerHeader interface {\n\t\tSetCookie(cookie string)                              // Sets the cookie\n\t\tGetCookie(key string) (value ServerCookie, err error) // Gets the cookie\n\t\tSet(key string, value string)\n\t\tAdd(key string, value string)\n\t\tDel(key string)\n\t\tGet(key string) (value []string)\n\t\tGetKeys() (headerKeys []string)\n\t\tSetStatus(statusCode int)\n\t}\n\n\t// Expected response for FROM_HTTP_COOKIE type (if implemented).\n\tServerCookie interface {\n\t\tGetValue() string\n\t}\n\n\t// Expected response for HTTP_MULTIPART_FORM.\n\tServerMultipartForm interface {\n\t\tGetFiles() map[string][]*multipart.FileHeader\n\t\tGetValues() url.Values\n\t\tRemoveAll() error\n\t}\n\tStreamWriter interface {\n\t\tWriteStream(name string, contentlen int64, modtime time.Time, reader io.Reader) error\n\t}\n\n\tServerEngine interface {\n\t\t// Initialize the server (non blocking)\n\t\tInit(init *EngineInit)\n\t\t// Starts the server. This will block until server is stopped\n\t\tStart()\n\t\t// Fires a new event to the server\n\t\tEvent(event Event, args interface{}) EventResponse\n\t\t// Returns the engine instance for specific calls\n\t\tEngine() interface{}\n\t\t// Returns the engine Name\n\t\tName() string\n\t\t// Returns any stats\n\t\tStats() map[string]interface{}\n\t}\n\n\t// The initialization structure passed into the engine.\n\tEngineInit struct {\n\t\tAddress, // The address\n\t\tNetwork string // The network\n\t\tPort        int                 // The port\n\t\tHTTPMuxList ServerMuxList       // The HTTPMux\n\t\tCallback    func(ServerContext) // The ServerContext callback endpoint\n\t}\n\n\t// An empty server engine.\n\tServerEngineEmpty struct {\n\t}\n\n\t// The route handler structure.\n\tServerMux struct {\n\t\tPathPrefix string      // The path prefix\n\t\tCallback   interface{} // The callback interface as appropriate to the server\n\t}\n\n\t// A list of handlers used for adding special route functions.\n\tServerMuxList []ServerMux\n)\n\n// Sorting function.\nfunc (r ServerMuxList) Len() int {\n\treturn len(r)\n}\n\n// Sorting function.\nfunc (r ServerMuxList) Less(i, j int) bool {\n\treturn len(r[i].PathPrefix) > len(r[j].PathPrefix)\n}\n\n// Sorting function.\nfunc (r ServerMuxList) Swap(i, j int) {\n\tr[i], r[j] = r[j], r[i]\n}\n\n// Search function, returns the largest path matching this.\nfunc (r ServerMuxList) Find(path string) (interface{}, bool) {\n\tfor _, p := range r {\n\t\tif p.PathPrefix == path || strings.HasPrefix(path, p.PathPrefix) {\n\t\t\treturn p.Callback, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// Adds this routehandler to the route table. It will be called (if the path prefix matches)\n// before the Revel mux, this can only be called after the ENGINE_BEFORE_INITIALIZED event.\nfunc AddHTTPMux(path string, callback interface{}) {\n\tServerEngineInit.HTTPMuxList = append(ServerEngineInit.HTTPMuxList, ServerMux{PathPrefix: path, Callback: callback})\n}\n\n// Callback point for the server to handle the.\nfunc handleInternal(ctx ServerContext) {\n\tstart := time.Now()\n\tvar c *Controller\n\tif RevelConfig.Controller.Reuse {\n\t\tc = RevelConfig.Controller.Stack.Pop().(*Controller)\n\t\tdefer func() {\n\t\t\tRevelConfig.Controller.Stack.Push(c)\n\t\t}()\n\t} else {\n\t\tc = NewControllerEmpty()\n\t}\n\n\tvar (\n\t\treq  = c.Request\n\t\tresp = c.Response\n\t)\n\tc.SetController(ctx)\n\treq.WebSocket, _ = ctx.GetResponse().(ServerWebSocket)\n\n\tclientIP := ClientIP(req)\n\n\t// Once finished in the internal, we can return these to the stack\n\n\tc.ClientIP = clientIP\n\tc.Log = AppLog.New(\"ip\", clientIP,\n\t\t\"path\", req.GetPath(), \"method\", req.Method)\n\t// Call the first filter, this will process the request\n\tFilters[0](c, Filters[1:])\n\tif c.Result != nil {\n\t\tc.Result.Apply(req, resp)\n\t} else if c.Response.Status != 0 {\n\t\tc.Response.SetStatus(c.Response.Status)\n\t}\n\t// Close the Writer if we can\n\tif w, ok := resp.GetWriter().(io.Closer); ok {\n\t\t_ = w.Close()\n\t}\n\n\t// Revel request access log format\n\t// RequestStartTime ClientIP ResponseStatus RequestLatency HTTPMethod URLPath\n\t// Sample format: terminal format\n\t// INFO 2017/08/02 22:31:41 server-engine.go:168: Request Stats                            ip=::1 path=/public/img/favicon.png method=GET action=Static.Serve namespace=static\\\\ start=2017/08/02 22:31:41 status=200 duration_seconds=0.0007656\n\t// Recommended storing format to json code which looks like\n\t// {\"action\":\"Static.Serve\",\"caller\":\"server-engine.go:168\",\"duration_seconds\":0.00058336,\"ip\":\"::1\",\"lvl\":3,\n\t// \"method\":\"GET\",\"msg\":\"Request Stats\",\"namespace\":\"static\\\\\",\"path\":\"/public/img/favicon.png\",\n\t// \"start\":\"2017-08-02T22:34:08-0700\",\"status\":200,\"t\":\"2017-08-02T22:34:08.303112145-07:00\"}\n\n\tc.Log.Info(\"Request Stats\",\n\t\t\"start\", start,\n\t\t\"status\", c.Response.Status,\n\t\t\"duration_seconds\", time.Since(start).Seconds(), \"section\", \"requestlog\",\n\t)\n}\n\nvar ENGINE_UNKNOWN_GET = errors.New(\"Server Engine Invalid Get\")\n\nfunc (e *ServerEngineEmpty) Get(_ string) interface{} {\n\treturn nil\n}\n\nfunc (e *ServerEngineEmpty) Set(_ string, _ interface{}) bool {\n\treturn false\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 4.953125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/revel/revel/session\"\n\t\"github.com/revel/revel/utils\"\n)\n\n// Revel's variables server, router, etc.\nvar (\n\tMainRouter         *Router\n\tMainTemplateLoader *TemplateLoader\n\tMainWatcher        *Watcher\n\tserverEngineMap    = map[string]func() ServerEngine{}\n\tCurrentEngine      ServerEngine\n\tServerEngineInit   *EngineInit\n\tserverLogger       = RevelLog.New(\"section\", \"server\")\n)\n\nfunc RegisterServerEngine(name string, loader func() ServerEngine) {\n\tserverLogger.Debug(\"RegisterServerEngine: Registered engine \", \"name\", name)\n\tserverEngineMap[name] = loader\n}\n\n// InitServer initializes the server and returns the handler\n// It can be used as an alternative entry-point if one needs the http handler\n// to be exposed. E.g. to run on multiple addresses and ports or to set custom\n// TLS options.\nfunc InitServer() {\n\tCurrentEngine.Init(ServerEngineInit)\n\tinitControllerStack()\n\tstartupHooks.Run()\n\n\t// Load templates\n\tMainTemplateLoader = NewTemplateLoader(TemplatePaths)\n\tif err := MainTemplateLoader.Refresh(); err != nil {\n\t\tserverLogger.Debug(\"InitServer: Main template loader failed to refresh\", \"error\", err)\n\t}\n\n\t// The \"watch\" config variable can turn on and off all watching.\n\t// (As a convenient way to control it all together.)\n\tif Config.BoolDefault(\"watch\", true) {\n\t\tMainWatcher = NewWatcher()\n\t\tFilters = append([]Filter{WatchFilter}, Filters...)\n\t}\n\n\t// If desired (or by default), create a watcher for templates and routes.\n\t// The watcher calls Refresh() on things on the first request.\n\tif MainWatcher != nil && Config.BoolDefault(\"watch.templates\", true) {\n\t\tMainWatcher.Listen(MainTemplateLoader, MainTemplateLoader.paths...)\n\t}\n}\n\n// Run the server.\n// This is called from the generated main file.\n// If port is non-zero, use that.  Else, read the port from app.conf.\nfunc Run(port int) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tRevelLog.Crit(\"Recovered error in startup\", \"error\", r)\n\t\t\tRaiseEvent(REVEL_FAILURE, r)\n\t\t\tpanic(\"Fatal error in startup\")\n\t\t}\n\t}()\n\n\t// Initialize the session logger, must be initiated from this app to avoid\n\t// circular references\n\tsession.InitSession(RevelLog)\n\n\t// Create the CurrentEngine instance from the application config\n\tInitServerEngine(port, Config.StringDefault(\"server.engine\", GO_NATIVE_SERVER_ENGINE))\n\tRaiseEvent(ENGINE_BEFORE_INITIALIZED, nil)\n\tInitServer()\n\tRaiseEvent(ENGINE_STARTED, nil)\n\t// This is needed for the harness to recognize that the server is started, it looks for the word\n\t// \"Listening\" in the stdout stream\n\n\tfmt.Fprintf(os.Stdout, \"Revel engine is listening on.. %s\\n\", ServerEngineInit.Address)\n\t// Start never returns,\n\tCurrentEngine.Start()\n\tfmt.Fprintf(os.Stdout, \"Revel engine is NOT listening on.. %s\\n\", ServerEngineInit.Address)\n\tRaiseEvent(ENGINE_SHUTDOWN, nil)\n\tshutdownHooks.Run()\n\tprintln(\"\\nRevel exited normally\\n\")\n}\n\n// Build an engine initialization object and start the engine.\nfunc InitServerEngine(port int, serverEngine string) {\n\taddress := HTTPAddr\n\tif address == \"\" {\n\t\taddress = \"localhost\"\n\t}\n\tif port == 0 {\n\t\tport = HTTPPort\n\t}\n\n\tvar (\n\t\tnetwork      = \"tcp\"\n\t\tlocalAddress string\n\t)\n\n\t// If the port is zero, treat the address as a fully qualified local address.\n\t// This address must be prefixed with the network type followed by a colon,\n\t// e.g. unix:/tmp/app.socket or tcp6:::1 (equivalent to tcp6:0:0:0:0:0:0:0:1)\n\tif port == 0 {\n\t\tparts := strings.SplitN(address, \":\", 2)\n\t\tnetwork = parts[0]\n\t\tlocalAddress = parts[1]\n\t} else {\n\t\tlocalAddress = address + \":\" + strconv.Itoa(port)\n\t}\n\n\tif engineLoader, ok := serverEngineMap[serverEngine]; !ok {\n\t\tpanic(\"Server Engine \" + serverEngine + \" Not found\")\n\t} else {\n\t\tCurrentEngine = engineLoader()\n\t\tserverLogger.Debug(\"InitServerEngine: Found server engine and invoking\", \"name\", CurrentEngine.Name())\n\t\tServerEngineInit = &EngineInit{\n\t\t\tAddress:  localAddress,\n\t\t\tNetwork:  network,\n\t\t\tPort:     port,\n\t\t\tCallback: handleInternal,\n\t\t}\n\t}\n\tAddInitEventHandler(CurrentEngine.Event)\n}\n\n// Initialize the controller stack for the application.\nfunc initControllerStack() {\n\tRevelConfig.Controller.Reuse = Config.BoolDefault(\"revel.controller.reuse\", true)\n\n\tif RevelConfig.Controller.Reuse {\n\t\tRevelConfig.Controller.Stack = utils.NewStackLock(\n\t\t\tConfig.IntDefault(\"revel.controller.stack\", 10),\n\t\t\tConfig.IntDefault(\"revel.controller.maxstack\", 200), func() interface{} {\n\t\t\t\treturn NewControllerEmpty()\n\t\t\t})\n\t\tRevelConfig.Controller.CachedStackSize = Config.IntDefault(\"revel.cache.controller.stack\", 10)\n\t\tRevelConfig.Controller.CachedStackMaxSize = Config.IntDefault(\"revel.cache.controller.maxstack\", 100)\n\t\tRevelConfig.Controller.CachedMap = map[string]*utils.SimpleLockStack{}\n\t}\n}\n\n// Called to stop the server.\nfunc StopServer(value interface{}) EventResponse {\n\treturn RaiseEvent(ENGINE_SHUTDOWN_REQUEST, value)\n}\n"
        },
        {
          "name": "server_adapter_go.go",
          "type": "blob",
          "size": 16.5751953125,
          "content": "package revel\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/revel/revel/utils\"\n\t\"golang.org/x/net/websocket\"\n)\n\n// Register the GoHttpServer engine.\nfunc init() {\n\tAddInitEventHandler(func(typeOf Event, value interface{}) (responseOf EventResponse) {\n\t\tif typeOf == REVEL_BEFORE_MODULES_LOADED {\n\t\t\tRegisterServerEngine(GO_NATIVE_SERVER_ENGINE, func() ServerEngine { return &GoHttpServer{} })\n\t\t}\n\t\treturn\n\t})\n}\n\n// The Go HTTP server.\ntype GoHttpServer struct {\n\tServer               *http.Server           // The server instance\n\tServerInit           *EngineInit            // The server engine initialization\n\tMaxMultipartSize     int64                  // The largest size of file to accept\n\tgoContextStack       *utils.SimpleLockStack // The context stack Set via server.context.stack, server.context.maxstack\n\tgoMultipartFormStack *utils.SimpleLockStack // The multipart form stack set via server.form.stack, server.form.maxstack\n\tHttpMuxList          ServerMuxList\n\tHasAppMux            bool\n\tsignalChan           chan os.Signal\n}\n\n// Called to initialize the server with this EngineInit.\nfunc (g *GoHttpServer) Init(init *EngineInit) {\n\tg.MaxMultipartSize = int64(Config.IntDefault(\"server.request.max.multipart.filesize\", 32)) << 20 /* 32 MB */\n\tg.goContextStack = utils.NewStackLock(Config.IntDefault(\"server.context.stack\", 100),\n\t\tConfig.IntDefault(\"server.context.maxstack\", 200),\n\t\tfunc() interface{} {\n\t\t\treturn NewGoContext(g)\n\t\t})\n\tg.goMultipartFormStack = utils.NewStackLock(Config.IntDefault(\"server.form.stack\", 100),\n\t\tConfig.IntDefault(\"server.form.maxstack\", 200),\n\t\tfunc() interface{} { return &GoMultipartForm{} })\n\tg.ServerInit = init\n\n\trevelHandler := http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {\n\t\tg.Handle(writer, request)\n\t})\n\n\t// Adds the mux list\n\tg.HttpMuxList = init.HTTPMuxList\n\tsort.Sort(g.HttpMuxList)\n\tg.HasAppMux = len(g.HttpMuxList) > 0\n\tg.signalChan = make(chan os.Signal)\n\n\tg.Server = &http.Server{\n\t\tAddr:         init.Address,\n\t\tHandler:      revelHandler,\n\t\tReadTimeout:  time.Duration(Config.IntDefault(\"http.timeout.read\", 0)) * time.Second,\n\t\tWriteTimeout: time.Duration(Config.IntDefault(\"http.timeout.write\", 0)) * time.Second,\n\t}\n}\n\n// Handler is assigned in the Init.\nfunc (g *GoHttpServer) Start() {\n\tgo func() {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tserverLogger.Debugf(\"Start: Listening on %s...\", g.Server.Addr)\n\t}()\n\tif HTTPSsl {\n\t\tif g.ServerInit.Network != \"tcp\" {\n\t\t\t// This limitation is just to reduce complexity, since it is standard\n\t\t\t// to terminate SSL upstream when using unix domain sockets.\n\t\t\tserverLogger.Fatal(\"SSL is only supported for TCP sockets. Specify a port to listen on.\")\n\t\t}\n\t\tserverLogger.Fatal(\"Failed to listen:\", \"error\",\n\t\t\tg.Server.ListenAndServeTLS(HTTPSslCert, HTTPSslKey))\n\t} else {\n\t\tlistener, err := net.Listen(g.ServerInit.Network, g.Server.Addr)\n\t\tif err != nil {\n\t\t\tserverLogger.Fatal(\"Failed to listen:\", \"error\", err)\n\t\t}\n\t\tserverLogger.Warn(\"Server exiting:\", \"error\", g.Server.Serve(listener))\n\t}\n}\n\n// Handle the request and response for the server.\nfunc (g *GoHttpServer) Handle(w http.ResponseWriter, r *http.Request) {\n\t// This section is called if the developer has added custom mux to the app\n\tif g.HasAppMux && g.handleAppMux(w, r) {\n\t\treturn\n\t}\n\tg.handleMux(w, r)\n}\n\n// Handle the request and response for the servers mux.\nfunc (g *GoHttpServer) handleAppMux(w http.ResponseWriter, r *http.Request) bool {\n\t// Check the prefix and split them\n\trequestPath := path.Clean(r.URL.Path)\n\tif handler, hasHandler := g.HttpMuxList.Find(requestPath); hasHandler {\n\t\tclientIP := HttpClientIP(r)\n\t\tlocalLog := AppLog.New(\"ip\", clientIP,\n\t\t\t\"path\", r.URL.Path, \"method\", r.Method)\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tlocalLog.Error(\"An error was caught using the handler\", \"path\", requestPath, \"error\", err)\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t}\n\t\t}()\n\t\tstart := time.Now()\n\t\thandler.(http.HandlerFunc)(w, r)\n\t\tlocalLog.Info(\"Request Stats\",\n\t\t\t\"start\", start,\n\t\t\t\"duration_seconds\", time.Since(start).Seconds(), \"section\", \"requestlog\",\n\t\t)\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Passes the server request to Revel.\nfunc (g *GoHttpServer) handleMux(w http.ResponseWriter, r *http.Request) {\n\tif maxRequestSize := int64(Config.IntDefault(\"http.maxrequestsize\", 0)); maxRequestSize > 0 {\n\t\tr.Body = http.MaxBytesReader(w, r.Body, maxRequestSize)\n\t}\n\n\tupgrade := r.Header.Get(\"Upgrade\")\n\tcontext := g.goContextStack.Pop().(*GoContext)\n\tdefer func() {\n\t\tg.goContextStack.Push(context)\n\t}()\n\tcontext.Request.SetRequest(r)\n\tcontext.Response.SetResponse(w)\n\n\tif upgrade == \"websocket\" || upgrade == \"Websocket\" {\n\t\twebsocket.Handler(func(ws *websocket.Conn) {\n\t\t\t// Override default Read/Write timeout with sane value for a web socket request\n\t\t\tif err := ws.SetDeadline(time.Now().Add(time.Hour * 24)); err != nil {\n\t\t\t\tserverLogger.Error(\"SetDeadLine failed:\", err)\n\t\t\t}\n\t\t\tr.Method = \"WS\"\n\t\t\tcontext.Request.WebSocket = ws\n\t\t\tcontext.WebSocket = &GoWebSocket{Conn: ws, GoResponse: *context.Response}\n\t\t\tg.ServerInit.Callback(context)\n\t\t}).ServeHTTP(w, r)\n\t} else {\n\t\tg.ServerInit.Callback(context)\n\t}\n}\n\n// ClientIP method returns client IP address from HTTP request.\n//\n// Note: Set property \"app.behind.proxy\" to true only if Revel is running\n// behind proxy like nginx, haproxy, apache, etc. Otherwise\n// you may get inaccurate Client IP address. Revel parses the\n// IP address in the order of X-Forwarded-For, X-Real-IP.\n//\n// By default revel will get http.Request's RemoteAddr.\nfunc HttpClientIP(r *http.Request) string {\n\tif Config.BoolDefault(\"app.behind.proxy\", false) {\n\t\t// Header X-Forwarded-For\n\t\tif fwdFor := strings.TrimSpace(r.Header.Get(HdrForwardedFor)); fwdFor != \"\" {\n\t\t\tindex := strings.Index(fwdFor, \",\")\n\t\t\tif index == -1 {\n\t\t\t\treturn fwdFor\n\t\t\t}\n\t\t\treturn fwdFor[:index]\n\t\t}\n\n\t\t// Header X-Real-Ip\n\t\tif realIP := strings.TrimSpace(r.Header.Get(HdrRealIP)); realIP != \"\" {\n\t\t\treturn realIP\n\t\t}\n\t}\n\n\tif remoteAddr, _, err := net.SplitHostPort(r.RemoteAddr); err == nil {\n\t\treturn remoteAddr\n\t}\n\n\treturn \"\"\n}\n\n// The server key name.\nconst GO_NATIVE_SERVER_ENGINE = \"go\"\n\n// Returns the name of this engine.\nfunc (g *GoHttpServer) Name() string {\n\treturn GO_NATIVE_SERVER_ENGINE\n}\n\n// Returns stats for this engine.\nfunc (g *GoHttpServer) Stats() map[string]interface{} {\n\treturn map[string]interface{}{\n\t\t\"Go Engine Context\": g.goContextStack.String(),\n\t\t\"Go Engine Forms\":   g.goMultipartFormStack.String(),\n\t}\n}\n\n// Return the engine instance.\nfunc (g *GoHttpServer) Engine() interface{} {\n\treturn g.Server\n}\n\n// Handles an event from Revel.\nfunc (g *GoHttpServer) Event(event Event, args interface{}) (r EventResponse) {\n\tswitch event {\n\tcase ENGINE_STARTED:\n\t\tsignal.Notify(g.signalChan, os.Interrupt, syscall.SIGTERM, os.Kill)\n\t\tgo func() {\n\t\t\t_ = <-g.signalChan\n\t\t\tserverLogger.Info(\"Received quit singal Please wait ... \")\n\t\t\tRaiseEvent(ENGINE_SHUTDOWN_REQUEST, nil)\n\t\t}()\n\tcase ENGINE_SHUTDOWN_REQUEST:\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*time.Duration(Config.IntDefault(\"app.cancel.timeout\", 60)))\n\t\tdefer cancel()\n\t\tg.Server.Shutdown(ctx)\n\tdefault:\n\t}\n\n\treturn\n}\n\ntype (\n\t// The go context.\n\tGoContext struct {\n\t\tRequest   *GoRequest   // The request\n\t\tResponse  *GoResponse  // The response\n\t\tWebSocket *GoWebSocket // The websocket\n\t}\n\n\t// The go request.\n\tGoRequest struct {\n\t\tOriginal        *http.Request    // The original\n\t\tFormParsed      bool             // True if form parsed\n\t\tMultiFormParsed bool             // True if multipart form parsed\n\t\tWebSocket       *websocket.Conn  // The websocket\n\t\tParsedForm      *GoMultipartForm // The parsed form data\n\t\tGoheader        *GoHeader        // The header\n\t\tEngine          *GoHttpServer    // THe server\n\t}\n\n\t// The response.\n\tGoResponse struct {\n\t\tOriginal http.ResponseWriter // The original writer\n\t\tGoheader *GoHeader           // The header\n\t\tWriter   io.Writer           // The writer\n\t\tRequest  *GoRequest          // The request\n\t\tEngine   *GoHttpServer       // The engine\n\t}\n\n\t// The multipart form.\n\tGoMultipartForm struct {\n\t\tForm *multipart.Form // The form\n\t}\n\n\t// The go header.\n\tGoHeader struct {\n\t\tSource     interface{} // The source\n\t\tisResponse bool        // True if response header\n\t}\n\n\t// The websocket.\n\tGoWebSocket struct {\n\t\tConn       *websocket.Conn // The connection\n\t\tGoResponse                 // The response\n\t}\n\n\t// The cookie.\n\tGoCookie http.Cookie\n)\n\n// Create a new go context.\nfunc NewGoContext(instance *GoHttpServer) *GoContext {\n\t// This bit in here is for the test cases, which pass in a nil value\n\tif instance == nil {\n\t\tinstance = &GoHttpServer{MaxMultipartSize: 32 << 20}\n\t\tinstance.goContextStack = utils.NewStackLock(100, 200,\n\t\t\tfunc() interface{} {\n\t\t\t\treturn NewGoContext(instance)\n\t\t\t})\n\t\tinstance.goMultipartFormStack = utils.NewStackLock(100, 200,\n\t\t\tfunc() interface{} { return &GoMultipartForm{} })\n\t}\n\tc := &GoContext{Request: &GoRequest{Goheader: &GoHeader{}, Engine: instance}}\n\tc.Response = &GoResponse{Goheader: &GoHeader{}, Request: c.Request, Engine: instance}\n\treturn c\n}\n\n// get the request.\nfunc (c *GoContext) GetRequest() ServerRequest {\n\treturn c.Request\n}\n\n// Get the response.\nfunc (c *GoContext) GetResponse() ServerResponse {\n\tif c.WebSocket != nil {\n\t\treturn c.WebSocket\n\t}\n\treturn c.Response\n}\n\n// Destroy the context.\nfunc (c *GoContext) Destroy() {\n\tc.Response.Destroy()\n\tc.Request.Destroy()\n\tif c.WebSocket != nil {\n\t\tc.WebSocket.Destroy()\n\t\tc.WebSocket = nil\n\t}\n}\n\n// Communicate with the server engine to exchange data.\nfunc (r *GoRequest) Get(key int) (value interface{}, err error) {\n\tswitch key {\n\tcase HTTP_SERVER_HEADER:\n\t\tvalue = r.GetHeader()\n\tcase HTTP_MULTIPART_FORM:\n\t\tvalue, err = r.GetMultipartForm()\n\tcase HTTP_QUERY:\n\t\tvalue = r.Original.URL.Query()\n\tcase HTTP_FORM:\n\t\tvalue, err = r.GetForm()\n\tcase HTTP_REQUEST_URI:\n\t\tvalue = r.Original.URL.String()\n\tcase HTTP_REQUEST_CONTEXT:\n\t\tvalue = r.Original.Context()\n\tcase HTTP_REMOTE_ADDR:\n\t\tvalue = r.Original.RemoteAddr\n\tcase HTTP_METHOD:\n\t\tvalue = r.Original.Method\n\tcase HTTP_PATH:\n\t\tvalue = r.Original.URL.Path\n\tcase HTTP_HOST:\n\t\tvalue = r.Original.Host\n\tcase HTTP_URL:\n\t\tvalue = r.Original.URL\n\tcase HTTP_BODY:\n\t\tvalue = r.Original.Body\n\tdefault:\n\t\terr = ENGINE_UNKNOWN_GET\n\t}\n\n\treturn\n}\n\n// Sets the request key with value.\nfunc (r *GoRequest) Set(key int, value interface{}) bool {\n\treturn false\n}\n\n// Returns the form.\nfunc (r *GoRequest) GetForm() (url.Values, error) {\n\tif !r.FormParsed {\n\t\tif e := r.Original.ParseForm(); e != nil {\n\t\t\treturn nil, e\n\t\t}\n\t\tr.FormParsed = true\n\t}\n\n\treturn r.Original.Form, nil\n}\n\n// Returns the form.\nfunc (r *GoRequest) GetMultipartForm() (ServerMultipartForm, error) {\n\tif !r.MultiFormParsed {\n\t\tif e := r.Original.ParseMultipartForm(r.Engine.MaxMultipartSize); e != nil {\n\t\t\treturn nil, e\n\t\t}\n\t\tr.ParsedForm = r.Engine.goMultipartFormStack.Pop().(*GoMultipartForm)\n\t\tr.ParsedForm.Form = r.Original.MultipartForm\n\t}\n\n\treturn r.ParsedForm, nil\n}\n\n// Returns the header.\nfunc (r *GoRequest) GetHeader() ServerHeader {\n\treturn r.Goheader\n}\n\n// Returns the raw value.\nfunc (r *GoRequest) GetRaw() interface{} {\n\treturn r.Original\n}\n\n// Sets the request.\nfunc (r *GoRequest) SetRequest(req *http.Request) {\n\tr.Original = req\n\tr.Goheader.Source = r\n\tr.Goheader.isResponse = false\n}\n\n// Destroy the request.\nfunc (r *GoRequest) Destroy() {\n\tr.Goheader.Source = nil\n\tr.Original = nil\n\tr.FormParsed = false\n\tr.MultiFormParsed = false\n\tr.ParsedForm = nil\n}\n\n// Gets the key from the response.\nfunc (r *GoResponse) Get(key int) (value interface{}, err error) {\n\tswitch key {\n\tcase HTTP_SERVER_HEADER:\n\t\tvalue = r.Header()\n\tcase HTTP_STREAM_WRITER:\n\t\tvalue = r\n\tcase HTTP_WRITER:\n\t\tvalue = r.Writer\n\tdefault:\n\t\terr = ENGINE_UNKNOWN_GET\n\t}\n\treturn\n}\n\n// Sets the key with the value.\nfunc (r *GoResponse) Set(key int, value interface{}) (set bool) {\n\tswitch key {\n\tcase ENGINE_RESPONSE_STATUS:\n\t\tr.Header().SetStatus(value.(int))\n\t\tset = true\n\tcase HTTP_WRITER:\n\t\tr.SetWriter(value.(io.Writer))\n\t\tset = true\n\t}\n\treturn\n}\n\n// Sets the header.\nfunc (r *GoResponse) Header() ServerHeader {\n\treturn r.Goheader\n}\n\n// Gets the original response.\nfunc (r *GoResponse) GetRaw() interface{} {\n\treturn r.Original\n}\n\n// Sets the writer.\nfunc (r *GoResponse) SetWriter(writer io.Writer) {\n\tr.Writer = writer\n}\n\n// Write output to stream.\nfunc (r *GoResponse) WriteStream(name string, contentlen int64, modtime time.Time, reader io.Reader) error {\n\t// Check to see if the output stream is modified, if not send it using the\n\t// Native writer\n\twritten := false\n\tif _, ok := r.Writer.(http.ResponseWriter); ok {\n\t\tif rs, ok := reader.(io.ReadSeeker); ok {\n\t\t\thttp.ServeContent(r.Original, r.Request.Original, name, modtime, rs)\n\t\t\twritten = true\n\t\t}\n\t}\n\tif !written {\n\t\t// Else, do a simple io.Copy.\n\t\tius := r.Request.Original.Header.Get(\"If-Unmodified-Since\")\n\t\tif t, err := http.ParseTime(ius); err == nil && !modtime.IsZero() {\n\t\t\t// The Date-Modified header truncates sub-second precision, so\n\t\t\t// use mtime < t+1s instead of mtime <= t to check for unmodified.\n\t\t\tif modtime.Before(t.Add(1 * time.Second)) {\n\t\t\t\th := r.Original.Header()\n\t\t\t\tdelete(h, \"Content-Type\")\n\t\t\t\tdelete(h, \"Content-Length\")\n\t\t\t\tif h.Get(\"Etag\") != \"\" {\n\t\t\t\t\tdelete(h, \"Last-Modified\")\n\t\t\t\t}\n\t\t\t\tr.Original.WriteHeader(http.StatusNotModified)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tif contentlen != -1 {\n\t\t\theader := ServerHeader(r.Goheader)\n\t\t\tif writer, found := r.Writer.(*CompressResponseWriter); found {\n\t\t\t\theader = ServerHeader(writer.Header)\n\t\t\t}\n\t\t\theader.Set(\"Content-Length\", strconv.FormatInt(contentlen, 10))\n\t\t}\n\t\tif _, err := io.Copy(r.Writer, reader); err != nil {\n\t\t\tr.Original.WriteHeader(http.StatusInternalServerError)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Frees response.\nfunc (r *GoResponse) Destroy() {\n\tif c, ok := r.Writer.(io.Closer); ok {\n\t\tc.Close()\n\t}\n\tr.Goheader.Source = nil\n\tr.Original = nil\n\tr.Writer = nil\n}\n\n// Sets the response.\nfunc (r *GoResponse) SetResponse(w http.ResponseWriter) {\n\tr.Original = w\n\tr.Writer = w\n\tr.Goheader.Source = r\n\tr.Goheader.isResponse = true\n}\n\n// Sets the cookie.\nfunc (r *GoHeader) SetCookie(cookie string) {\n\tif r.isResponse {\n\t\tr.Source.(*GoResponse).Original.Header().Add(\"Set-Cookie\", cookie)\n\t}\n}\n\n// Gets the cookie.\nfunc (r *GoHeader) GetCookie(key string) (value ServerCookie, err error) {\n\tif !r.isResponse {\n\t\tvar cookie *http.Cookie\n\t\tif cookie, err = r.Source.(*GoRequest).Original.Cookie(key); err == nil {\n\t\t\tvalue = GoCookie(*cookie)\n\t\t}\n\t}\n\treturn\n}\n\n// Sets (replaces) header key.\nfunc (r *GoHeader) Set(key string, value string) {\n\tif r.isResponse {\n\t\tr.Source.(*GoResponse).Original.Header().Set(key, value)\n\t}\n}\n\n// Adds the header key.\nfunc (r *GoHeader) Add(key string, value string) {\n\tif r.isResponse {\n\t\tr.Source.(*GoResponse).Original.Header().Add(key, value)\n\t}\n}\n\n// Deletes the header key.\nfunc (r *GoHeader) Del(key string) {\n\tif r.isResponse {\n\t\tr.Source.(*GoResponse).Original.Header().Del(key)\n\t}\n}\n\n// Gets the header key.\nfunc (r *GoHeader) Get(key string) (value []string) {\n\tif !r.isResponse {\n\t\tvalue = r.Source.(*GoRequest).Original.Header[key]\n\t\tif len(value) == 0 {\n\t\t\tif ihead := r.Source.(*GoRequest).Original.Header.Get(key); ihead != \"\" {\n\t\t\t\tvalue = append(value, ihead)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvalue = r.Source.(*GoResponse).Original.Header()[key]\n\t}\n\treturn\n}\n\n// Returns list of header keys.\nfunc (r *GoHeader) GetKeys() (value []string) {\n\tif !r.isResponse {\n\t\tfor key := range r.Source.(*GoRequest).Original.Header {\n\t\t\tvalue = append(value, key)\n\t\t}\n\t} else {\n\t\tfor key := range r.Source.(*GoResponse).Original.Header() {\n\t\t\tvalue = append(value, key)\n\t\t}\n\t}\n\treturn\n}\n\n// Sets the status of the header.\nfunc (r *GoHeader) SetStatus(statusCode int) {\n\tif r.isResponse {\n\t\tr.Source.(*GoResponse).Original.WriteHeader(statusCode)\n\t}\n}\n\n// Return cookies value.\nfunc (r GoCookie) GetValue() string {\n\treturn r.Value\n}\n\n// Return files from the form.\nfunc (f *GoMultipartForm) GetFiles() map[string][]*multipart.FileHeader {\n\treturn f.Form.File\n}\n\n// Return values from the form.\nfunc (f *GoMultipartForm) GetValues() url.Values {\n\treturn url.Values(f.Form.Value)\n}\n\n// Remove all values from the form freeing memory.\nfunc (f *GoMultipartForm) RemoveAll() error {\n\treturn f.Form.RemoveAll()\n}\n\n/**\n * Message send JSON.\n */\nfunc (g *GoWebSocket) MessageSendJSON(v interface{}) error {\n\treturn websocket.JSON.Send(g.Conn, v)\n}\n\n/**\n * Message receive JSON.\n */\nfunc (g *GoWebSocket) MessageReceiveJSON(v interface{}) error {\n\treturn websocket.JSON.Receive(g.Conn, v)\n}\n\n/**\n * Message Send.\n */\nfunc (g *GoWebSocket) MessageSend(v interface{}) error {\n\treturn websocket.Message.Send(g.Conn, v)\n}\n\n/**\n * Message receive.\n */\nfunc (g *GoWebSocket) MessageReceive(v interface{}) error {\n\treturn websocket.Message.Receive(g.Conn, v)\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 3.6943359375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// This tries to benchmark the usual request-serving pipeline to get an overall\n// performance metric.\n//\n// Each iteration runs one mock request to display a hotel's detail page by id.\n//\n// Contributing parts:\n// - Routing\n// - Controller lookup / invocation\n// - Parameter binding\n// - Session, flash, i18n cookies\n// - Render() call magic\n// - Template rendering.\nfunc BenchmarkServeAction(b *testing.B) {\n\tbenchmarkRequest(b, showRequest)\n}\n\nfunc BenchmarkServeJson(b *testing.B) {\n\tbenchmarkRequest(b, jsonRequest)\n}\n\nfunc BenchmarkServePlaintext(b *testing.B) {\n\tbenchmarkRequest(b, plaintextRequest)\n}\n\n// This tries to benchmark the static serving overhead when serving an \"average\n// size\" 7k file.\nfunc BenchmarkServeStatic(b *testing.B) {\n\tbenchmarkRequest(b, staticRequest)\n}\n\nfunc benchmarkRequest(b *testing.B, req *http.Request) {\n\tstartFakeBookingApp()\n\tb.ResetTimer()\n\tresp := httptest.NewRecorder()\n\tfor i := 0; i < b.N; i++ {\n\t\tCurrentEngine.(*GoHttpServer).Handle(resp, req)\n\t}\n}\n\n// Test that the booking app can be successfully run for a test.\nfunc TestFakeServer(t *testing.T) {\n\tstartFakeBookingApp()\n\n\tresp := httptest.NewRecorder()\n\n\t// First, test that the expected responses are actually generated\n\tCurrentEngine.(*GoHttpServer).Handle(resp, showRequest)\n\tif !strings.Contains(resp.Body.String(), \"300 Main St.\") {\n\t\tt.Errorf(\"Failed to find hotel address in action response:\\n%s\", resp.Body)\n\t\tt.FailNow()\n\t}\n\tresp.Body.Reset()\n\n\tCurrentEngine.(*GoHttpServer).Handle(resp, staticRequest)\n\tsessvarsSize := getFileSize(t, filepath.Join(BasePath, \"public\", \"js\", \"sessvars.js\"))\n\tif int64(resp.Body.Len()) != sessvarsSize {\n\t\tt.Errorf(\"Expected sessvars.js to have %d bytes, got %d:\\n%s\", sessvarsSize, resp.Body.Len(), resp.Body)\n\t\tt.FailNow()\n\t}\n\tresp.Body.Reset()\n\n\tCurrentEngine.(*GoHttpServer).Handle(resp, jsonRequest)\n\tif !strings.Contains(resp.Body.String(), `\"Address\":\"300 Main St.\"`) {\n\t\tt.Errorf(\"Failed to find hotel address in JSON response:\\n%s\", resp.Body)\n\t\tt.FailNow()\n\t}\n\tresp.Body.Reset()\n\n\tCurrentEngine.(*GoHttpServer).Handle(resp, plaintextRequest)\n\tif resp.Body.String() != \"Hello, World!\" {\n\t\tt.Errorf(\"Failed to find greeting in plaintext response:\\n%s\", resp.Body)\n\t\tt.FailNow()\n\t}\n\n\tresp.Body = nil\n}\n\nfunc getFileSize(t *testing.T, name string) int64 {\n\tfi, err := os.Stat(name)\n\tif err != nil {\n\t\tt.Errorf(\"Unable to stat file:\\n%s\", name)\n\t\tt.FailNow()\n\t}\n\treturn fi.Size()\n}\n\n// Ensure on app start runs in order.\nfunc TestOnAppStart(t *testing.T) {\n\tstr := \"\"\n\ta := assert.New(t)\n\tOnAppStart(func() {\n\t\tstr += \" World\"\n\t}, 2)\n\n\tOnAppStart(func() {\n\t\tstr += \"Hello\"\n\t}, 1)\n\n\tstartFakeBookingApp()\n\n\ta.Equal(\"Hello World\", str, \"Failed to order OnAppStart\")\n}\n\n// Ensure on app stop runs in order.\nfunc TestOnAppStop(t *testing.T) {\n\ta := assert.New(t)\n\tstartFakeBookingApp()\n\ti := \"\"\n\tOnAppStop(func() {\n\t\ti += \"cruel world\"\n\t\tt.Logf(\"i: %v \\n\", i)\n\t}, 2)\n\tOnAppStop(func() {\n\t\ti += \"goodbye \"\n\t\tt.Logf(\"i: %v \\n\", i)\n\t}, 1)\n\tgo func() {\n\t\ttime.Sleep(2 * time.Second)\n\t\tRaiseEvent(ENGINE_SHUTDOWN_REQUEST, nil)\n\t}()\n\tRun(0)\n\ta.Equal(\"goodbye cruel world\", i, \"Did not get shutdown events\")\n}\n\nvar (\n\tshowRequest, _      = http.NewRequest(\"GET\", \"/hotels/3\", nil)\n\tstaticRequest, _    = http.NewRequest(\"GET\", \"/public/js/sessvars.js\", nil)\n\tjsonRequest, _      = http.NewRequest(\"GET\", \"/hotels/3/booking\", nil)\n\tplaintextRequest, _ = http.NewRequest(\"GET\", \"/hotels\", nil)\n)\n"
        },
        {
          "name": "session",
          "type": "tree",
          "content": null
        },
        {
          "name": "session_adapter_cookie.go",
          "type": "blob",
          "size": 3.9296875,
          "content": "package revel\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/revel/revel/session\"\n)\n\ntype (\n\t// The session cookie engine.\n\tSessionCookieEngine struct {\n\t\tExpireAfterDuration time.Duration\n\t}\n)\n\n// A logger for the session engine.\nvar sessionEngineLog = RevelLog.New(\"section\", \"session-engine\")\n\n// Create a new instance to test.\nfunc init() {\n\tRegisterSessionEngine(initCookieEngine, \"revel-cookie\")\n}\n\n// For testing purposes this engine is used.\nfunc NewSessionCookieEngine() *SessionCookieEngine {\n\tce := &SessionCookieEngine{}\n\treturn ce\n}\n\n// Called when the the application starts, retrieves data from the app config so cannot be run until then.\nfunc initCookieEngine() SessionEngine {\n\tce := &SessionCookieEngine{}\n\n\tvar err error\n\tif expiresString, ok := Config.String(\"session.expires\"); !ok {\n\t\tce.ExpireAfterDuration = 30 * 24 * time.Hour\n\t} else if expiresString == session.SessionValueName {\n\t\tce.ExpireAfterDuration = 0\n\t} else if ce.ExpireAfterDuration, err = time.ParseDuration(expiresString); err != nil {\n\t\tpanic(fmt.Errorf(\"session.expires invalid: %s\", err))\n\t}\n\n\treturn ce\n}\n\n// Decode the session information from the cookie retrieved from the controller request.\nfunc (cse *SessionCookieEngine) Decode(c *Controller) {\n\t// Decode the session from a cookie.\n\tc.Session = map[string]interface{}{}\n\tsessionMap := c.Session\n\tif cookie, err := c.Request.Cookie(CookiePrefix + session.SessionCookieSuffix); err != nil {\n\t\treturn\n\t} else {\n\t\tcse.DecodeCookie(cookie, sessionMap)\n\t\tc.Session = sessionMap\n\t}\n}\n\n// Encode the session information to the cookie, set the cookie on the controller.\nfunc (cse *SessionCookieEngine) Encode(c *Controller) {\n\tc.SetCookie(cse.GetCookie(c.Session))\n}\n\n// Exposed only for testing purposes.\nfunc (cse *SessionCookieEngine) DecodeCookie(cookie ServerCookie, s session.Session) {\n\t// Decode the session from a cookie.\n\t// Separate the data from the signature.\n\tcookieValue := cookie.GetValue()\n\thyphen := strings.Index(cookieValue, \"-\")\n\tif hyphen == -1 || hyphen >= len(cookieValue)-1 {\n\t\treturn\n\t}\n\tsig, data := cookieValue[:hyphen], cookieValue[hyphen+1:]\n\n\t// Verify the signature.\n\tif !Verify(data, sig) {\n\t\tsessionEngineLog.Warn(\"Session cookie signature failed\")\n\t\treturn\n\t}\n\n\t// Parse the cookie into a temp map, and then load it into the session object\n\ttempMap := map[string]string{}\n\tParseKeyValueCookie(data, func(key, val string) {\n\t\ttempMap[key] = val\n\t})\n\ts.Load(tempMap)\n\n\t// Check timeout after unpacking values - if timeout missing (or removed) destroy all session\n\t// objects\n\tif s.SessionTimeoutExpiredOrMissing() {\n\t\t// If this fails we need to delete all the keys from the session\n\t\tfor key := range s {\n\t\t\tdelete(s, key)\n\t\t}\n\t}\n}\n\n// Convert session to cookie.\nfunc (cse *SessionCookieEngine) GetCookie(s session.Session) *http.Cookie {\n\tvar sessionValue string\n\tts := s.GetExpiration(cse.ExpireAfterDuration)\n\tif ts.IsZero() {\n\t\ts[session.TimestampKey] = session.SessionValueName\n\t} else {\n\t\ts[session.TimestampKey] = strconv.FormatInt(ts.Unix(), 10)\n\t}\n\n\t// Convert the key to a string map\n\tstringMap := s.Serialize()\n\n\tfor key, value := range stringMap {\n\t\tif strings.ContainsAny(key, \":\\x00\") {\n\t\t\tpanic(\"Session keys may not have colons or null bytes\")\n\t\t}\n\t\tif strings.Contains(value, \"\\x00\") {\n\t\t\tpanic(\"Session values may not have null bytes\")\n\t\t}\n\t\tsessionValue += \"\\x00\" + key + \":\" + value + \"\\x00\"\n\t}\n\n\tif len(sessionValue) > 1024*4 {\n\t\tsessionEngineLog.Error(\"SessionCookieEngine.Cookie, session data has exceeded 4k limit (%d) cookie data will not be reliable\", \"length\", len(sessionValue))\n\t}\n\n\tsessionData := url.QueryEscape(sessionValue)\n\tsessionCookie := &http.Cookie{\n\t\tName:     CookiePrefix + session.SessionCookieSuffix,\n\t\tValue:    Sign(sessionData) + \"-\" + sessionData,\n\t\tDomain:   CookieDomain,\n\t\tPath:     \"/\",\n\t\tHttpOnly: true,\n\t\tSecure:   CookieSecure,\n\t\tSameSite: CookieSameSite,\n\t\tExpires:  ts.UTC(),\n\t\tMaxAge:   int(cse.ExpireAfterDuration.Seconds()),\n\t}\n\treturn sessionCookie\n}\n"
        },
        {
          "name": "session_engine.go",
          "type": "blob",
          "size": 1.0205078125,
          "content": "package revel\n\n// The session engine provides an interface to allow for storage of session data.\ntype (\n\tSessionEngine interface {\n\t\tDecode(c *Controller) // Called to decode the session information on the controller\n\t\tEncode(c *Controller) // Called to encode the session information on the controller\n\t}\n)\n\nvar (\n\tsessionEngineMap     = map[string]func() SessionEngine{}\n\tCurrentSessionEngine SessionEngine\n)\n\n// Initialize session engine on startup.\nfunc init() {\n\tOnAppStart(initSessionEngine, 5)\n}\n\nfunc RegisterSessionEngine(f func() SessionEngine, name string) {\n\tsessionEngineMap[name] = f\n}\n\n// Called when application is starting up.\nfunc initSessionEngine() {\n\t// Check for session engine to use and assign it\n\tsename := Config.StringDefault(\"session.engine\", \"revel-cookie\")\n\tif se, found := sessionEngineMap[sename]; found {\n\t\tCurrentSessionEngine = se()\n\t} else {\n\t\tsessionLog.Warn(\"Session engine '%s' not found, using default session engine revel-cookie\", sename)\n\t\tCurrentSessionEngine = sessionEngineMap[\"revel-cookie\"]()\n\t}\n}\n"
        },
        {
          "name": "session_filter.go",
          "type": "blob",
          "size": 0.75,
          "content": "package revel\n\n// SessionFilter is a Revel Filter that retrieves and sets the session cookie.\n// Within Revel, it is available as a Session attribute on Controller instances.\n// The name of the Session cookie is set as CookiePrefix + \"_SESSION\".\n\nvar sessionLog = RevelLog.New(\"section\", \"session\")\n\nfunc SessionFilter(c *Controller, fc []Filter) {\n\tCurrentSessionEngine.Decode(c)\n\tsessionWasEmpty := c.Session.Empty()\n\n\t// Make session vars available in templates as {{.session.xyz}}\n\tc.ViewArgs[\"session\"] = c.Session\n\tc.ViewArgs[\"_controller\"] = c\n\n\tfc[0](c, fc[1:])\n\n\t// If session is not empty or if session was not empty then\n\t// pass it back to the session engine to be encoded\n\tif !c.Session.Empty() || !sessionWasEmpty {\n\t\tCurrentSessionEngine.Encode(c)\n\t}\n}\n"
        },
        {
          "name": "template.go",
          "type": "blob",
          "size": 15.306640625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\n// ErrorCSSClass httml CSS error class name.\nvar ErrorCSSClass = \"hasError\"\n\n// TemplateLoader object handles loading and parsing of templates.\n// Everything below the application's views directory is treated as a template.\ntype TemplateLoader struct {\n\t// Paths to search for templates, in priority order.\n\tpaths []string\n\t// load version seed for templates\n\tloadVersionSeed int\n\t// A templateRuntime of looked up template results\n\truntimeLoader atomic.Value\n\t// Lock to prevent concurrent map writes\n\ttemplateMutex sync.Mutex\n}\n\ntype Template interface {\n\t// The name of the template.\n\tName() string // Name of template\n\t// The content of the template as a string (Used in error handling).\n\tContent() []string // Content\n\t// Called by the server to render the template out the io.Writer, context contains the view args to be passed to the template.\n\tRender(wr io.Writer, context interface{}) error\n\t// The full path to the file on the disk.\n\tLocation() string // Disk location\n}\n\nvar (\n\tinvalidSlugPattern = regexp.MustCompile(`[^a-z0-9 _-]`)\n\twhiteSpacePattern  = regexp.MustCompile(`\\s+`)\n\ttemplateLog        = RevelLog.New(\"section\", \"template\")\n)\n\n// TemplateOutputArgs returns the result of the template rendered using the passed in arguments.\nfunc TemplateOutputArgs(templatePath string, args map[string]interface{}) (data []byte, err error) {\n\t// Get the Template.\n\tlang, _ := args[CurrentLocaleViewArg].(string)\n\ttemplate, err := MainTemplateLoader.TemplateLang(templatePath, lang)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttr := &RenderTemplateResult{\n\t\tTemplate: template,\n\t\tViewArgs: args,\n\t}\n\tb, err := tr.ToBytes()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn b.Bytes(), nil\n}\n\nfunc NewTemplateLoader(paths []string) *TemplateLoader {\n\tloader := &TemplateLoader{\n\t\tpaths: paths,\n\t}\n\treturn loader\n}\n\n// WatchDir returns true of directory doesn't start with . (dot)\n// otherwise false.\nfunc (loader *TemplateLoader) WatchDir(info os.FileInfo) bool {\n\t// Watch all directories, except the ones starting with a dot.\n\treturn !strings.HasPrefix(info.Name(), \".\")\n}\n\n// WatchFile returns true of file doesn't start with . (dot)\n// otherwise false.\nfunc (loader *TemplateLoader) WatchFile(basename string) bool {\n\t// Watch all files, except the ones starting with a dot.\n\treturn !strings.HasPrefix(basename, \".\")\n}\n\n// DEPRECATED Use TemplateLang, will be removed in future release.\nfunc (loader *TemplateLoader) Template(name string) (tmpl Template, err error) {\n\truntimeLoader := loader.runtimeLoader.Load().(*templateRuntime)\n\treturn runtimeLoader.TemplateLang(name, \"\")\n}\n\nfunc (loader *TemplateLoader) TemplateLang(name, lang string) (tmpl Template, err error) {\n\truntimeLoader := loader.runtimeLoader.Load().(*templateRuntime)\n\treturn runtimeLoader.TemplateLang(name, lang)\n}\n\n// Refresh method scans the views directory and parses all templates as Go Templates.\n// If a template fails to parse, the error is set on the loader.\n// (It's awkward to refresh a single Go Template).\nfunc (loader *TemplateLoader) Refresh() (err *Error) {\n\tloader.templateMutex.Lock()\n\tdefer loader.templateMutex.Unlock()\n\n\tloader.loadVersionSeed++\n\truntimeLoader := &templateRuntime{\n\t\tloader:      loader,\n\t\tversion:     loader.loadVersionSeed,\n\t\ttemplateMap: map[string]Template{},\n\t}\n\n\ttemplateLog.Debug(\"Refresh: Refreshing templates from \", \"path\", loader.paths)\n\tif err = loader.initializeEngines(runtimeLoader, Config.StringDefault(\"template.engines\", GO_TEMPLATE)); err != nil {\n\t\treturn\n\t}\n\tfor _, engine := range runtimeLoader.templatesAndEngineList {\n\t\tengine.Event(TEMPLATE_REFRESH_REQUESTED, nil)\n\t}\n\tRaiseEvent(TEMPLATE_REFRESH_REQUESTED, nil)\n\tdefer func() {\n\t\tfor _, engine := range runtimeLoader.templatesAndEngineList {\n\t\t\tengine.Event(TEMPLATE_REFRESH_COMPLETED, nil)\n\t\t}\n\t\tRaiseEvent(TEMPLATE_REFRESH_COMPLETED, nil)\n\n\t\t// Reset the runtimeLoader\n\t\tloader.runtimeLoader.Store(runtimeLoader)\n\t}()\n\n\t// Resort the paths, make sure the revel path is the last path,\n\t// so anything can override it\n\trevelTemplatePath := filepath.Join(RevelPath, \"templates\")\n\t// Go through the paths\n\tfor i, o := range loader.paths {\n\t\tif o == revelTemplatePath && i != len(loader.paths)-1 {\n\t\t\tloader.paths[i] = loader.paths[len(loader.paths)-1]\n\t\t\tloader.paths[len(loader.paths)-1] = revelTemplatePath\n\t\t}\n\t}\n\ttemplateLog.Debug(\"Refresh: Refreshing templates from\", \"path\", loader.paths)\n\n\truntimeLoader.compileError = nil\n\truntimeLoader.TemplatePaths = map[string]string{}\n\n\tfor _, basePath := range loader.paths {\n\t\t// Walk only returns an error if the template loader is completely unusable\n\t\t// (namely, if one of the TemplateFuncs does not have an acceptable signature).\n\n\t\t// Handling symlinked directories\n\t\tvar fullSrcDir string\n\t\tf, err := os.Lstat(basePath)\n\t\tif err == nil && f.Mode()&os.ModeSymlink == os.ModeSymlink {\n\t\t\tfullSrcDir, err = filepath.EvalSymlinks(basePath)\n\t\t\tif err != nil {\n\t\t\t\ttemplateLog.Panic(\"Refresh: Eval symlinks error \", \"error\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tfullSrcDir = basePath\n\t\t}\n\n\t\tvar templateWalker filepath.WalkFunc\n\n\t\ttemplateWalker = func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\ttemplateLog.Error(\"Refresh: error walking templates:\", \"error\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Walk into watchable directories\n\t\t\tif info.IsDir() {\n\t\t\t\tif !loader.WatchDir(info) {\n\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Only add watchable\n\t\t\tif !loader.WatchFile(info.Name()) {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t//nolint:scopelint\n\t\t\tfileBytes, err := runtimeLoader.findAndAddTemplate(path, fullSrcDir, basePath)\n\t\t\tif err != nil {\n\t\t\t\t// Add in this template name to the list of templates unable to be compiled\n\t\t\t\truntimeLoader.compileErrorNameList = append(runtimeLoader.compileErrorNameList, filepath.ToSlash(path[len(fullSrcDir)+1:]))\n\t\t\t}\n\t\t\t// Store / report the first error encountered.\n\t\t\tif err != nil && runtimeLoader.compileError == nil {\n\t\t\t\truntimeLoader.compileError, _ = err.(*Error)\n\n\t\t\t\tif nil == runtimeLoader.compileError {\n\t\t\t\t\t_, line, description := ParseTemplateError(err)\n\n\t\t\t\t\truntimeLoader.compileError = &Error{\n\t\t\t\t\t\tTitle:       \"Template Compilation Error\",\n\t\t\t\t\t\tPath:        path,\n\t\t\t\t\t\tDescription: description,\n\t\t\t\t\t\tLine:        line,\n\t\t\t\t\t\tSourceLines: strings.Split(string(fileBytes), \"\\n\"),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttemplateLog.Errorf(\"Refresh: Template compilation error (In %s around line %d):\\n\\t%s\",\n\t\t\t\t\tpath, runtimeLoader.compileError.Line, err.Error())\n\t\t\t} else if nil != err { //&& strings.HasPrefix(templateName, \"errors/\") {\n\t\t\t\tif compileError, ok := err.(*Error); ok {\n\t\t\t\t\ttemplateLog.Errorf(\"Template compilation error (In %s around line %d):\\n\\t%s\",\n\t\t\t\t\t\tpath, compileError.Line, err.Error())\n\t\t\t\t} else {\n\t\t\t\t\ttemplateLog.Errorf(\"Template compilation error (In %s ):\\n\\t%s\",\n\t\t\t\t\t\tpath, err.Error())\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif _, err = os.Lstat(fullSrcDir); os.IsNotExist(err) {\n\t\t\t// #1058 Given views/template path is not exists\n\t\t\t// so no need to walk, move on to next path\n\t\t\tcontinue\n\t\t}\n\n\t\tfuncErr := Walk(fullSrcDir, templateWalker)\n\n\t\t// If there was an error with the Funcs, set it and return immediately.\n\t\tif funcErr != nil {\n\t\t\truntimeLoader.compileError = NewErrorFromPanic(funcErr)\n\t\t\treturn runtimeLoader.compileError\n\t\t}\n\t}\n\n\t// Note: compileError may or may not be set.\n\treturn runtimeLoader.compileError\n}\n\ntype templateRuntime struct {\n\tloader *TemplateLoader\n\t// load version for templates\n\tversion int\n\t// Template data and implementation\n\ttemplatesAndEngineList []TemplateEngine\n\t// If an error was encountered parsing the templates, it is stored here.\n\tcompileError *Error\n\t// A list of the names of the templates with errors\n\tcompileErrorNameList []string\n\t// Map from template name to the path from whence it was loaded.\n\tTemplatePaths map[string]string\n\t// A map of looked up template results\n\ttemplateMap map[string]Template\n}\n\n// Checks to see if template exists in templatePaths, if so it is skipped (templates are imported in order\n// reads the template file into memory, replaces namespace keys with module (if found.\nfunc (runtimeLoader *templateRuntime) findAndAddTemplate(path, fullSrcDir, basePath string) (fileBytes []byte, err error) {\n\ttemplateName := filepath.ToSlash(path[len(fullSrcDir)+1:])\n\t// Convert template names to use forward slashes, even on Windows.\n\tif os.PathSeparator == '\\\\' {\n\t\ttemplateName = strings.Replace(templateName, `\\`, `/`, -1) // `\n\t}\n\n\t// Check to see if template was found\n\tif place, found := runtimeLoader.TemplatePaths[templateName]; found {\n\t\ttemplateLog.Debug(\"findAndAddTemplate: Not Loading, template is already exists: \", \"name\", templateName, \"old\",\n\t\t\tplace, \"new\", path)\n\t\treturn\n\t}\n\n\tfileBytes, err = ioutil.ReadFile(path)\n\tif err != nil {\n\t\ttemplateLog.Error(\"findAndAddTemplate: Failed reading file:\", \"path\", path, \"error\", err)\n\t\treturn\n\t}\n\t// Parse template file and replace the \"_LOCAL_|\" in the template with the module name\n\t// allow for namespaces to be renamed \"_LOCAL_(.*?)|\"\n\tif module := ModuleFromPath(path, false); module != nil {\n\t\tfileBytes = namespaceReplace(fileBytes, module)\n\t}\n\n\t// if we have an engine picked for this template process it now\n\tbaseTemplate := NewBaseTemplate(templateName, path, basePath, fileBytes)\n\n\t// Try to find a default engine for the file\n\tfor _, engine := range runtimeLoader.templatesAndEngineList {\n\t\tif engine.Handles(baseTemplate) {\n\t\t\t_, err = runtimeLoader.loadIntoEngine(engine, baseTemplate)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Try all engines available\n\tvar defaultError error\n\tfor _, engine := range runtimeLoader.templatesAndEngineList {\n\t\tif loaded, loaderr := runtimeLoader.loadIntoEngine(engine, baseTemplate); loaded {\n\t\t\treturn\n\t\t} else {\n\t\t\ttemplateLog.Debugf(\"findAndAddTemplate: Engine '%s' unable to compile %s %s\", engine.Name(), path, loaderr.Error())\n\t\t\tif defaultError == nil {\n\t\t\t\tdefaultError = loaderr\n\t\t\t}\n\t\t}\n\t}\n\n\t// Assign the error from the first parser\n\terr = defaultError\n\n\t// No engines could be found return the err\n\tif err == nil {\n\t\terr = fmt.Errorf(\"Failed to parse template file using engines %s\", path)\n\t}\n\n\treturn\n}\n\nfunc (runtimeLoader *templateRuntime) loadIntoEngine(engine TemplateEngine, baseTemplate *TemplateView) (loaded bool, err error) {\n\tif loadedTemplate, found := runtimeLoader.templateMap[baseTemplate.TemplateName]; found {\n\t\t// Duplicate template found in map\n\t\ttemplateLog.Debug(\"template already exists in map: \", baseTemplate.TemplateName, \" in engine \", engine.Name(), \"\\r\\n\\told file:\",\n\t\t\tloadedTemplate.Location(), \"\\r\\n\\tnew file:\", baseTemplate.FilePath)\n\t\treturn\n\t}\n\n\tif loadedTemplate := engine.Lookup(baseTemplate.TemplateName); loadedTemplate != nil {\n\t\t// Duplicate template found for engine\n\t\ttemplateLog.Debug(\"loadIntoEngine: template already exists: \", \"template\", baseTemplate.TemplateName, \"inengine \", engine.Name(), \"old\",\n\t\t\tloadedTemplate.Location(), \"new\", baseTemplate.FilePath)\n\t\tloaded = true\n\t\treturn\n\t}\n\tif err = engine.ParseAndAdd(baseTemplate); err == nil {\n\t\tif tmpl := engine.Lookup(baseTemplate.TemplateName); tmpl != nil {\n\t\t\truntimeLoader.templateMap[baseTemplate.TemplateName] = tmpl\n\t\t}\n\t\truntimeLoader.TemplatePaths[baseTemplate.TemplateName] = baseTemplate.FilePath\n\t\ttemplateLog.Debugf(\"loadIntoEngine:Engine '%s' compiled %s\", engine.Name(), baseTemplate.FilePath)\n\t\tloaded = true\n\t} else {\n\t\ttemplateLog.Debug(\"loadIntoEngine: Engine failed to compile\", \"engine\", engine.Name(), \"file\", baseTemplate.FilePath, \"error\", err)\n\t}\n\treturn\n}\n\n// Parse the line, and description from an error message like:\n// html/template:Application/Register.html:36: no such template \"footer.html\".\nfunc ParseTemplateError(err error) (templateName string, line int, description string) {\n\tif e, ok := err.(*Error); ok {\n\t\treturn \"\", e.Line, e.Description\n\t}\n\n\tdescription = err.Error()\n\ti := regexp.MustCompile(`:\\d+:`).FindStringIndex(description)\n\tif i != nil {\n\t\tline, err = strconv.Atoi(description[i[0]+1 : i[1]-1])\n\t\tif err != nil {\n\t\t\ttemplateLog.Error(\"ParseTemplateError: Failed to parse line number from error message:\", \"error\", err)\n\t\t}\n\t\ttemplateName = description[:i[0]]\n\t\tif colon := strings.Index(templateName, \":\"); colon != -1 {\n\t\t\ttemplateName = templateName[colon+1:]\n\t\t}\n\t\ttemplateName = strings.TrimSpace(templateName)\n\t\tdescription = description[i[1]+1:]\n\t}\n\treturn templateName, line, description\n}\n\n// Template returns the Template with the given name.  The name is the template's path\n// relative to a template loader root.\n//\n// An Error is returned if there was any problem with any of the templates.  (In\n// this case, if a template is returned, it may still be usable.)\nfunc (runtimeLoader *templateRuntime) TemplateLang(name, lang string) (tmpl Template, err error) {\n\tif runtimeLoader.compileError != nil {\n\t\tfor _, errName := range runtimeLoader.compileErrorNameList {\n\t\t\tif name == errName {\n\t\t\t\treturn nil, runtimeLoader.compileError\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fetch the template from the map\n\ttmpl = runtimeLoader.templateLoad(name, lang)\n\tif tmpl == nil {\n\t\terr = fmt.Errorf(\"Template %s not found.\", name)\n\t}\n\n\treturn\n}\n\n// Load and also updates map if name is not found (to speed up next lookup).\nfunc (runtimeLoader *templateRuntime) templateLoad(name, lang string) (tmpl Template) {\n\tlangName := name\n\tfound := false\n\tif lang != \"\" {\n\t\t// Look up and return the template.\n\t\tlangName = name + \".\" + lang\n\t\ttmpl, found = runtimeLoader.templateMap[langName]\n\t\tif found {\n\t\t\treturn\n\t\t}\n\t\ttmpl, found = runtimeLoader.templateMap[name]\n\t} else {\n\t\ttmpl, found = runtimeLoader.templateMap[name]\n\t\tif found {\n\t\t\treturn\n\t\t}\n\t}\n\n\tif !found {\n\t\t// Neither name is found\n\t\t// Look up and return the template.\n\t\tfor _, engine := range runtimeLoader.templatesAndEngineList {\n\t\t\tif tmpl = engine.Lookup(langName); tmpl != nil {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif tmpl = engine.Lookup(name); tmpl != nil {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// If we found anything store it in the map, we need to copy so we do not\n\t// run into concurrency issues\n\truntimeLoader.loader.templateMutex.Lock()\n\tdefer runtimeLoader.loader.templateMutex.Unlock()\n\n\t// In case another thread has loaded the map, reload the atomic value and check\n\tnewRuntimeLoader := runtimeLoader.loader.runtimeLoader.Load().(*templateRuntime)\n\tif newRuntimeLoader.version != runtimeLoader.version {\n\t\treturn\n\t}\n\n\tnewTemplateMap := map[string]Template{}\n\tfor k, v := range newRuntimeLoader.templateMap {\n\t\tnewTemplateMap[k] = v\n\t}\n\tnewTemplateMap[langName] = tmpl\n\tif _, found := newTemplateMap[name]; !found {\n\t\tnewTemplateMap[name] = tmpl\n\t}\n\truntimeCopy := &templateRuntime{}\n\t*runtimeCopy = *newRuntimeLoader\n\truntimeCopy.templateMap = newTemplateMap\n\n\t// Set the atomic value\n\truntimeLoader.loader.runtimeLoader.Store(runtimeCopy)\n\treturn\n}\n\nfunc (i *TemplateView) Location() string {\n\treturn i.FilePath\n}\n\nfunc (i *TemplateView) Content() (content []string) {\n\tif i.FileBytes != nil {\n\t\t// Parse the bytes\n\t\tbuffer := bytes.NewBuffer(i.FileBytes)\n\t\treader := bufio.NewScanner(buffer)\n\t\tfor reader.Scan() {\n\t\t\tcontent = append(content, string(reader.Bytes()))\n\t\t}\n\t}\n\n\treturn content\n}\n\nfunc NewBaseTemplate(templateName, filePath, basePath string, fileBytes []byte) *TemplateView {\n\treturn &TemplateView{TemplateName: templateName, FilePath: filePath, FileBytes: fileBytes, BasePath: basePath}\n}\n"
        },
        {
          "name": "template_adapter_go.go",
          "type": "blob",
          "size": 3.9384765625,
          "content": "package revel\n\nimport (\n\t\"html/template\"\n\t\"io\"\n\t\"log\"\n\t\"strings\"\n)\n\nconst GO_TEMPLATE = \"go\"\n\n// Called on startup, initialized when the REVEL_BEFORE_MODULES_LOADED is called.\nfunc init() {\n\tAddInitEventHandler(func(typeOf Event, value interface{}) (responseOf EventResponse) {\n\t\tif typeOf == REVEL_BEFORE_MODULES_LOADED {\n\t\t\tRegisterTemplateLoader(GO_TEMPLATE, func(loader *TemplateLoader) (TemplateEngine, error) {\n\t\t\t\t// Set the template delimiters for the project if present, then split into left\n\t\t\t\t// and right delimiters around a space character\n\n\t\t\t\tTemplateDelims := Config.StringDefault(\"template.go.delimiters\", \"\")\n\t\t\t\tvar splitDelims []string\n\t\t\t\tif TemplateDelims != \"\" {\n\t\t\t\t\tsplitDelims = strings.Split(TemplateDelims, \" \")\n\t\t\t\t\tif len(splitDelims) != 2 {\n\t\t\t\t\t\tlog.Fatalln(\"app.conf: Incorrect format for template.delimiters\")\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn &GoEngine{\n\t\t\t\t\tloader:          loader,\n\t\t\t\t\ttemplateSet:     template.New(\"__root__\").Funcs(TemplateFuncs),\n\t\t\t\t\ttemplatesByName: map[string]*GoTemplate{},\n\t\t\t\t\tsplitDelims:     splitDelims,\n\t\t\t\t}, nil\n\t\t\t})\n\t\t}\n\t\treturn\n\t})\n}\n\n// Adapter for Go Templates.\ntype GoTemplate struct {\n\t*template.Template\n\tengine *GoEngine\n\t*TemplateView\n}\n\n// return a 'revel.Template' from Go's template.\nfunc (gotmpl GoTemplate) Render(wr io.Writer, arg interface{}) error {\n\treturn gotmpl.Execute(wr, arg)\n}\n\n// The main template engine for Go.\ntype GoEngine struct {\n\t// The template loader\n\tloader *TemplateLoader\n\t// THe current template set\n\ttemplateSet *template.Template\n\t// A map of templates by name\n\ttemplatesByName map[string]*GoTemplate\n\t// The delimiter that is used to indicate template code, defaults to {{\n\tsplitDelims []string\n\t// True if map is case insensitive\n\tCaseInsensitive bool\n}\n\n// Convert the path to lower case if needed.\nfunc (i *GoEngine) ConvertPath(path string) string {\n\tif i.CaseInsensitive {\n\t\treturn strings.ToLower(path)\n\t}\n\treturn path\n}\n\n// Returns true if this engine can handle the response.\nfunc (i *GoEngine) Handles(templateView *TemplateView) bool {\n\treturn EngineHandles(i, templateView)\n}\n\n// Parses the template vide and adds it to the template set.\nfunc (engine *GoEngine) ParseAndAdd(baseTemplate *TemplateView) error {\n\t// If alternate delimiters set for the project, change them for this set\n\tif engine.splitDelims != nil && strings.Index(baseTemplate.Location(), ViewsPath) > -1 {\n\t\tengine.templateSet.Delims(engine.splitDelims[0], engine.splitDelims[1])\n\t} else {\n\t\t// Reset to default otherwise\n\t\tengine.templateSet.Delims(\"\", \"\")\n\t}\n\ttemplateSource := string(baseTemplate.FileBytes)\n\ttemplateName := engine.ConvertPath(baseTemplate.TemplateName)\n\ttpl, err := engine.templateSet.New(baseTemplate.TemplateName).Parse(templateSource)\n\tif nil != err {\n\t\t_, line, description := ParseTemplateError(err)\n\t\treturn &Error{\n\t\t\tTitle:       \"Template Compilation Error\",\n\t\t\tPath:        baseTemplate.TemplateName,\n\t\t\tDescription: description,\n\t\t\tLine:        line,\n\t\t\tSourceLines: strings.Split(templateSource, \"\\n\"),\n\t\t}\n\t}\n\tengine.templatesByName[templateName] = &GoTemplate{Template: tpl, engine: engine, TemplateView: baseTemplate}\n\treturn nil\n}\n\n// Lookups the template name, to see if it is contained in this engine.\nfunc (engine *GoEngine) Lookup(templateName string) Template {\n\t// Case-insensitive matching of template file name\n\tif tpl, found := engine.templatesByName[engine.ConvertPath(templateName)]; found {\n\t\treturn tpl\n\t}\n\treturn nil\n}\n\n// Return the engine name.\nfunc (engine *GoEngine) Name() string {\n\treturn GO_TEMPLATE\n}\n\n// An event listener to listen for Revel INIT events.\nfunc (engine *GoEngine) Event(action Event, i interface{}) {\n\tif action == TEMPLATE_REFRESH_REQUESTED {\n\t\t// At this point all the templates have been passed into the\n\t\tengine.templatesByName = map[string]*GoTemplate{}\n\t\tengine.templateSet = template.New(\"__root__\").Funcs(TemplateFuncs)\n\t\t// Check to see what should be used for case sensitivity\n\t\tengine.CaseInsensitive = Config.BoolDefault(\"go.template.caseinsensitive\", true)\n\t}\n}\n"
        },
        {
          "name": "template_engine.go",
          "type": "blob",
          "size": 4.072265625,
          "content": "package revel\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype TemplateEngine interface {\n\t// prase template string and add template to the set.\n\tParseAndAdd(basePath *TemplateView) error\n\n\t// returns Template corresponding to the given templateName, or nil\n\tLookup(templateName string) Template\n\n\t// Fired by the template loader when events occur\n\tEvent(event Event, arg interface{})\n\n\t// returns true if this engine should be used to parse the file specified in baseTemplate\n\tHandles(templateView *TemplateView) bool\n\n\t// returns the name of the engine\n\tName() string\n}\n\n// The template view information.\ntype TemplateView struct {\n\tTemplateName string // The name of the view\n\tFilePath     string // The file path (view relative)\n\tBasePath     string // The file system base path\n\tFileBytes    []byte // The file loaded\n\tEngineType   string // The name of the engine used to render the view\n}\n\nvar templateLoaderMap = map[string]func(loader *TemplateLoader) (TemplateEngine, error){}\n\n// Allow for templates to be registered during init but not initialized until application has been started.\nfunc RegisterTemplateLoader(key string, loader func(loader *TemplateLoader) (TemplateEngine, error)) (err error) {\n\tif _, found := templateLoaderMap[key]; found {\n\t\terr = fmt.Errorf(\"Template loader %s already exists\", key)\n\t}\n\ttemplateLog.Debug(\"Registered template engine loaded\", \"name\", key)\n\ttemplateLoaderMap[key] = loader\n\treturn\n}\n\n// Sets the template name from Config\n// Sets the template API methods for parsing and storing templates before rendering.\nfunc (loader *TemplateLoader) CreateTemplateEngine(templateEngineName string) (TemplateEngine, error) {\n\tif templateEngineName == \"\" {\n\t\ttemplateEngineName = GO_TEMPLATE\n\t}\n\tfactory := templateLoaderMap[templateEngineName]\n\tif factory == nil {\n\t\tfmt.Printf(\"registered factories %#v\\n %s \\n\", templateLoaderMap, templateEngineName)\n\t\treturn nil, errors.New(\"Unknown template engine name - \" + templateEngineName + \".\")\n\t}\n\ttemplateEngine, err := factory(loader)\n\tif err != nil {\n\t\treturn nil, errors.New(\"Failed to init template engine (\" + templateEngineName + \"), \" + err.Error())\n\t}\n\n\ttemplateLog.Debug(\"CreateTemplateEngine: init templates\", \"name\", templateEngineName)\n\treturn templateEngine, nil\n}\n\n// Passing in a comma delimited list of engine names to be used with this loader to parse the template files.\nfunc (loader *TemplateLoader) initializeEngines(runtimeLoader *templateRuntime, templateEngineNameList string) (err *Error) {\n\t// Walk through the template loader's paths and build up a template set.\n\tif templateEngineNameList == \"\" {\n\t\ttemplateEngineNameList = GO_TEMPLATE\n\t}\n\truntimeLoader.templatesAndEngineList = []TemplateEngine{}\n\tfor _, engine := range strings.Split(templateEngineNameList, \",\") {\n\t\tengine := strings.TrimSpace(strings.ToLower(engine))\n\n\t\tif templateLoader, err := loader.CreateTemplateEngine(engine); err != nil {\n\t\t\truntimeLoader.compileError = &Error{\n\t\t\t\tTitle:       \"Panic (Template Loader)\",\n\t\t\t\tDescription: err.Error(),\n\t\t\t}\n\t\t\treturn runtimeLoader.compileError\n\t\t} else {\n\t\t\t// Always assign a default engine, switch it if it is specified in the config\n\t\t\truntimeLoader.templatesAndEngineList = append(runtimeLoader.templatesAndEngineList, templateLoader)\n\t\t}\n\t}\n\treturn\n}\n\nfunc EngineHandles(engine TemplateEngine, templateView *TemplateView) bool {\n\tif line, _, e := bufio.NewReader(bytes.NewBuffer(templateView.FileBytes)).ReadLine(); e == nil && string(line[:3]) == \"#! \" {\n\t\t// Extract the shebang and look at the rest of the line\n\t\t// #! pong2\n\t\t// #! go\n\t\ttemplateType := strings.TrimSpace(string(line[2:]))\n\t\tif engine.Name() == templateType {\n\t\t\t// Advance the read file bytes so it does not include the shebang\n\t\t\ttemplateView.FileBytes = templateView.FileBytes[len(line)+1:]\n\t\t\ttemplateView.EngineType = templateType\n\t\t\treturn true\n\t\t}\n\t}\n\tfilename := filepath.Base(templateView.FilePath)\n\tbits := strings.Split(filename, \".\")\n\tif len(bits) > 2 {\n\t\ttemplateType := strings.TrimSpace(bits[len(bits)-2])\n\t\tif engine.Name() == templateType {\n\t\t\ttemplateView.EngineType = templateType\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "template_functions.go",
          "type": "blob",
          "size": 10.025390625,
          "content": "package revel\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"html\"\n\t\"html/template\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/xeonx/timeago\"\n)\n\n// The functions available for use in the templates.\nvar TemplateFuncs = map[string]interface{}{\n\t\"url\": ReverseURL,\n\t\"set\": func(viewArgs map[string]interface{}, key string, value interface{}) template.JS {\n\t\tviewArgs[key] = value\n\t\treturn template.JS(\"\")\n\t},\n\t\"append\": func(viewArgs map[string]interface{}, key string, value interface{}) template.JS {\n\t\tif viewArgs[key] == nil {\n\t\t\tviewArgs[key] = []interface{}{value}\n\t\t} else {\n\t\t\tviewArgs[key] = append(viewArgs[key].([]interface{}), value)\n\t\t}\n\t\treturn template.JS(\"\")\n\t},\n\t\"field\": NewField,\n\t\"firstof\": func(args ...interface{}) interface{} {\n\t\tfor _, val := range args {\n\t\t\tswitch val.(type) {\n\t\t\tcase nil:\n\t\t\t\tcontinue\n\t\t\tcase string:\n\t\t\t\tif val == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\treturn val\n\t\t\tdefault:\n\t\t\t\treturn val\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t},\n\t\"option\": func(f *Field, val interface{}, label string) template.HTML {\n\t\tselected := \"\"\n\t\tif f.Flash() == val || (f.Flash() == \"\" && f.Value() == val) {\n\t\t\tselected = \" selected\"\n\t\t}\n\n\t\treturn template.HTML(fmt.Sprintf(`<option value=\"%s\"%s>%s</option>`,\n\t\t\thtml.EscapeString(fmt.Sprintf(\"%v\", val)), selected, html.EscapeString(label)))\n\t},\n\t\"radio\": func(f *Field, val string) template.HTML {\n\t\tchecked := \"\"\n\t\tif f.Flash() == val {\n\t\t\tchecked = \" checked\"\n\t\t}\n\t\treturn template.HTML(fmt.Sprintf(`<input type=\"radio\" name=\"%s\" value=\"%s\"%s>`,\n\t\t\thtml.EscapeString(f.Name), html.EscapeString(val), checked))\n\t},\n\t\"checkbox\": func(f *Field, val string) template.HTML {\n\t\tchecked := \"\"\n\t\tif f.Flash() == val {\n\t\t\tchecked = \" checked\"\n\t\t}\n\t\treturn template.HTML(fmt.Sprintf(`<input type=\"checkbox\" name=\"%s\" value=\"%s\"%s>`,\n\t\t\thtml.EscapeString(f.Name), html.EscapeString(val), checked))\n\t},\n\t// Pads the given string with &nbsp;'s up to the given width.\n\t\"pad\": func(str string, width int) template.HTML {\n\t\tif len(str) >= width {\n\t\t\treturn template.HTML(html.EscapeString(str))\n\t\t}\n\t\treturn template.HTML(html.EscapeString(str) + strings.Repeat(\"&nbsp;\", width-len(str)))\n\t},\n\n\t\"errorClass\": func(name string, viewArgs map[string]interface{}) template.HTML {\n\t\terrorMap, ok := viewArgs[\"errors\"].(map[string]*ValidationError)\n\t\tif !ok || errorMap == nil {\n\t\t\ttemplateLog.Warn(\"errorClass: Called 'errorClass' without 'errors' in the view args.\")\n\t\t\treturn template.HTML(\"\")\n\t\t}\n\t\tvalError, ok := errorMap[name]\n\t\tif !ok || valError == nil {\n\t\t\treturn template.HTML(\"\")\n\t\t}\n\t\treturn template.HTML(ErrorCSSClass)\n\t},\n\n\t\"msg\": func(viewArgs map[string]interface{}, message string, args ...interface{}) template.HTML {\n\t\tstr, ok := viewArgs[CurrentLocaleViewArg].(string)\n\t\tif !ok {\n\t\t\treturn \"\"\n\t\t}\n\t\treturn template.HTML(MessageFunc(str, message, args...))\n\t},\n\n\t// Replaces newlines with <br>\n\t\"nl2br\": func(text string) template.HTML {\n\t\treturn template.HTML(strings.Replace(template.HTMLEscapeString(text), \"\\n\", \"<br>\", -1))\n\t},\n\n\t// Skips sanitation on the parameter.  Do not use with dynamic data.\n\t\"raw\": func(text string) template.HTML {\n\t\treturn template.HTML(text)\n\t},\n\n\t// Pluralize, a helper for pluralizing words to correspond to data of dynamic length.\n\t// items - a slice of items, or an integer indicating how many items there are.\n\t// pluralOverrides - optional arguments specifying the output in the\n\t//     singular and plural cases.  by default \"\" and \"s\"\n\t\"pluralize\": func(items interface{}, pluralOverrides ...string) string {\n\t\tsingular, plural := \"\", \"s\"\n\t\tif len(pluralOverrides) >= 1 {\n\t\t\tsingular = pluralOverrides[0]\n\t\t\tif len(pluralOverrides) == 2 {\n\t\t\t\tplural = pluralOverrides[1]\n\t\t\t}\n\t\t}\n\n\t\tswitch v := reflect.ValueOf(items); v.Kind() {\n\t\tcase reflect.Int:\n\t\t\tif items.(int) != 1 {\n\t\t\t\treturn plural\n\t\t\t}\n\t\tcase reflect.Slice:\n\t\t\tif v.Len() != 1 {\n\t\t\t\treturn plural\n\t\t\t}\n\t\tdefault:\n\t\t\ttemplateLog.Error(\"pluralize: unexpected type: \", \"value\", v)\n\t\t}\n\t\treturn singular\n\t},\n\n\t// Format a date according to the application's default date(time) format.\n\t\"date\": func(date time.Time) string {\n\t\treturn date.Format(DateFormat)\n\t},\n\t\"datetime\": func(date time.Time) string {\n\t\treturn date.Format(DateTimeFormat)\n\t},\n\t// Fetch an object from the session.\n\t\"session\": func(key string, viewArgs map[string]interface{}) interface{} {\n\t\tif viewArgs != nil {\n\t\t\tif c, found := viewArgs[\"_controller\"]; found {\n\t\t\t\tif v, err := c.(*Controller).Session.Get(key); err == nil {\n\t\t\t\t\treturn v\n\t\t\t\t} else {\n\t\t\t\t\ttemplateLog.Errorf(\"template.session, key %s error %v\", key, err)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttemplateLog.Warnf(\"template.session, key %s requested without controller\", key)\n\t\t\t}\n\t\t} else {\n\t\t\ttemplateLog.Warnf(\"template.session, key %s requested passing in view args\", key)\n\t\t}\n\t\treturn \"\"\n\t},\n\n\t\"slug\": Slug,\n\t\"even\": func(a int) bool { return (a % 2) == 0 },\n\n\t// Using https://github.com/xeonx/timeago\n\t\"timeago\": TimeAgo,\n\t\"i18ntemplate\": func(args ...interface{}) (template.HTML, error) {\n\t\ttemplateName, lang := \"\", \"\"\n\t\tvar viewArgs interface{}\n\t\tswitch len(args) {\n\t\tcase 0:\n\t\t\ttemplateLog.Error(\"i18ntemplate: No arguments passed to template call\")\n\t\tcase 1:\n\t\t\t// Assume only the template name is passed in\n\t\t\ttemplateName = args[0].(string)\n\t\tcase 2:\n\t\t\t// Assume template name and viewArgs is passed in\n\t\t\ttemplateName = args[0].(string)\n\t\t\tviewArgs = args[1]\n\t\t\t// Try to extract language from the view args\n\t\t\tif viewargsmap, ok := viewArgs.(map[string]interface{}); ok {\n\t\t\t\tlang, _ = viewargsmap[CurrentLocaleViewArg].(string)\n\t\t\t}\n\t\tdefault:\n\t\t\t// Assume third argument is the region\n\t\t\ttemplateName = args[0].(string)\n\t\t\tviewArgs = args[1]\n\t\t\tlang, _ = args[2].(string)\n\t\t\tif len(args) > 3 {\n\t\t\t\ttemplateLog.Error(\"i18ntemplate: Received more parameters then needed for\", \"template\", templateName)\n\t\t\t}\n\t\t}\n\n\t\tvar buf bytes.Buffer\n\t\t// Get template\n\t\ttmpl, err := MainTemplateLoader.TemplateLang(templateName, lang)\n\t\tif err == nil {\n\t\t\terr = tmpl.Render(&buf, viewArgs)\n\t\t} else {\n\t\t\ttemplateLog.Error(\"i18ntemplate: Failed to render i18ntemplate \", \"name\", templateName, \"error\", err)\n\t\t}\n\t\treturn template.HTML(buf.String()), err\n\t},\n}\n\n/////////////////////\n// Template functions\n/////////////////////\n\n// ReverseURL returns a url capable of invoking a given controller method:\n// \"Application.ShowApp 123\" => \"/app/123\".\nfunc ReverseURL(args ...interface{}) (template.URL, error) {\n\tif len(args) == 0 {\n\t\treturn \"\", errors.New(\"no arguments provided to reverse route\")\n\t}\n\n\taction := args[0].(string)\n\tif action == \"Root\" {\n\t\treturn template.URL(AppRoot), nil\n\t}\n\n\tpathData, found := splitActionPath(nil, action, true)\n\n\tif !found {\n\t\treturn \"\", fmt.Errorf(\"reversing '%s', expected 'Controller.Action'\", action)\n\t}\n\n\t// Look up the types.\n\n\tif pathData.TypeOfController == nil {\n\t\treturn \"\", fmt.Errorf(\"Failed reversing %s: controller not found %#v\", action, pathData)\n\t}\n\n\t// Note method name is case insensitive search\n\tmethodType := pathData.TypeOfController.Method(pathData.MethodName)\n\tif methodType == nil {\n\t\treturn \"\", errors.New(\"revel/controller: In \" + action + \" failed to find function \" + pathData.MethodName)\n\t}\n\n\tif len(methodType.Args) < len(args)-1 {\n\t\treturn \"\", fmt.Errorf(\"reversing %s: route defines %d args, but received %d\",\n\t\t\taction, len(methodType.Args), len(args)-1)\n\t}\n\t// Unbind the arguments.\n\targsByName := make(map[string]string)\n\t// Bind any static args first\n\tfixedParams := len(pathData.FixedParamsByName)\n\n\tfor i, argValue := range args[1:] {\n\t\tUnbind(argsByName, methodType.Args[i+fixedParams].Name, argValue)\n\t}\n\n\treturn template.URL(MainRouter.Reverse(args[0].(string), argsByName).URL), nil\n}\n\nfunc Slug(text string) string {\n\tseparator := \"-\"\n\ttext = strings.ToLower(text)\n\ttext = invalidSlugPattern.ReplaceAllString(text, \"\")\n\ttext = whiteSpacePattern.ReplaceAllString(text, separator)\n\ttext = strings.Trim(text, separator)\n\treturn text\n}\n\nvar timeAgoLangs = map[string]timeago.Config{}\n\nfunc TimeAgo(args ...interface{}) string {\n\tdatetime := time.Now()\n\tlang := \"\"\n\tvar viewArgs interface{}\n\tswitch len(args) {\n\tcase 0:\n\t\ttemplateLog.Error(\"TimeAgo: No arguments passed to timeago\")\n\tcase 1:\n\t\t// only the time is passed in\n\t\tdatetime = args[0].(time.Time)\n\tcase 2:\n\t\t// time and region is passed in\n\t\tdatetime = args[0].(time.Time)\n\t\tswitch v := reflect.ValueOf(args[1]); v.Kind() {\n\t\tcase reflect.String:\n\t\t\t// second params type string equals region\n\t\t\tlang, _ = args[1].(string)\n\t\tcase reflect.Map:\n\t\t\t// second params type map equals viewArgs\n\t\t\tviewArgs = args[1]\n\t\t\tif viewargsmap, ok := viewArgs.(map[string]interface{}); ok {\n\t\t\t\tlang, _ = viewargsmap[CurrentLocaleViewArg].(string)\n\t\t\t}\n\t\tdefault:\n\t\t\ttemplateLog.Error(\"TimeAgo: unexpected type: \", \"value\", v)\n\t\t}\n\tdefault:\n\t\t// Assume third argument is the region\n\t\tdatetime = args[0].(time.Time)\n\n\t\tif reflect.ValueOf(args[1]).Kind() != reflect.Map {\n\t\t\ttemplateLog.Error(\"TimeAgo: unexpected type\", \"value\", args[1])\n\t\t}\n\n\t\tif reflect.ValueOf(args[2]).Kind() != reflect.String {\n\t\t\ttemplateLog.Error(\"TimeAgo: unexpected type: \", \"value\", args[2])\n\t\t}\n\n\t\tlang, _ = args[2].(string)\n\t\tif len(args) > 3 {\n\t\t\ttemplateLog.Error(\"TimeAgo: Received more parameters then needed for timeago\")\n\t\t}\n\t}\n\n\tif lang == \"\" {\n\t\tlang, _ = Config.String(defaultLanguageOption)\n\t\tif lang == \"en\" {\n\t\t\ttimeAgoLangs[lang] = timeago.English\n\t\t}\n\t}\n\n\t_, ok := timeAgoLangs[lang]\n\tif !ok {\n\t\ttimeAgoLangs[lang] = timeago.Config{\n\t\t\tPastPrefix:   \"\",\n\t\t\tPastSuffix:   \" \" + MessageFunc(lang, \"ago\"),\n\t\t\tFuturePrefix: MessageFunc(lang, \"in\") + \" \",\n\t\t\tFutureSuffix: \"\",\n\t\t\tPeriods: []timeago.FormatPeriod{\n\t\t\t\t{time.Second, MessageFunc(lang, \"about a second\"), MessageFunc(lang, \"%d seconds\")},\n\t\t\t\t{time.Minute, MessageFunc(lang, \"about a minute\"), MessageFunc(lang, \"%d minutes\")},\n\t\t\t\t{time.Hour, MessageFunc(lang, \"about an hour\"), MessageFunc(lang, \"%d hours\")},\n\t\t\t\t{timeago.Day, MessageFunc(lang, \"one day\"), MessageFunc(lang, \"%d days\")},\n\t\t\t\t{timeago.Month, MessageFunc(lang, \"one month\"), MessageFunc(lang, \"%d months\")},\n\t\t\t\t{timeago.Year, MessageFunc(lang, \"one year\"), MessageFunc(lang, \"%d years\")},\n\t\t\t},\n\t\t\tZero:          MessageFunc(lang, \"about a second\"),\n\t\t\tMax:           73 * time.Hour,\n\t\t\tDefaultLayout: \"2006-01-02\",\n\t\t}\n\t}\n\treturn timeAgoLangs[lang].Format(datetime)\n}\n"
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "testing",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 6.951171875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/revel/config\"\n)\n\nconst (\n\t// DefaultFileContentType Revel's default response content type.\n\tDefaultFileContentType = \"application/octet-stream\"\n)\n\nvar (\n\tcookieKeyValueParser = regexp.MustCompile(\"\\x00([^:]*):([^\\x00]*)\\x00\")\n\tHdrForwardedFor      = http.CanonicalHeaderKey(\"X-Forwarded-For\")\n\tHdrRealIP            = http.CanonicalHeaderKey(\"X-Real-Ip\")\n\tutilLog              = RevelLog.New(\"section\", \"util\")\n\tmimeConfig           *config.Context\n)\n\n// ExecutableTemplate adds some more methods to the default Template.\ntype ExecutableTemplate interface {\n\tExecute(io.Writer, interface{}) error\n}\n\n// ExecuteTemplate execute a template and returns the result as a string.\nfunc ExecuteTemplate(tmpl ExecutableTemplate, data interface{}) string {\n\tvar b bytes.Buffer\n\tif err := tmpl.Execute(&b, data); err != nil {\n\t\tutilLog.Error(\"ExecuteTemplate: Execute failed\", \"error\", err)\n\t}\n\treturn b.String()\n}\n\n// MustReadLines reads the lines of the given file.  Panics in the case of error.\nfunc MustReadLines(filename string) []string {\n\tr, err := ReadLines(filename)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn r\n}\n\n// ReadLines reads the lines of the given file.  Panics in the case of error.\nfunc ReadLines(filename string) ([]string, error) {\n\tdataBytes, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn strings.Split(string(dataBytes), \"\\n\"), nil\n}\n\nfunc ContainsString(list []string, target string) bool {\n\tfor _, el := range list {\n\t\tif el == target {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// FindMethod returns the reflect.Method, given a Receiver type and Func value.\nfunc FindMethod(recvType reflect.Type, funcVal reflect.Value) *reflect.Method {\n\t// It is not possible to get the name of the method from the Func.\n\t// Instead, compare it to each method of the Controller.\n\tfor i := 0; i < recvType.NumMethod(); i++ {\n\t\tmethod := recvType.Method(i)\n\t\tif method.Func.Pointer() == funcVal.Pointer() {\n\t\t\treturn &method\n\t\t}\n\t}\n\treturn nil\n}\n\n// ParseKeyValueCookie takes the raw (escaped) cookie value and parses out key values.\nfunc ParseKeyValueCookie(val string, cb func(key, val string)) {\n\tval, _ = url.QueryUnescape(val)\n\tif matches := cookieKeyValueParser.FindAllStringSubmatch(val, -1); matches != nil {\n\t\tfor _, match := range matches {\n\t\t\tcb(match[1], match[2])\n\t\t}\n\t}\n}\n\n// LoadMimeConfig load mime-types.conf on init.\nfunc LoadMimeConfig() {\n\tvar err error\n\tmimeConfig, err = config.LoadContext(\"mime-types.conf\", ConfPaths)\n\tif err != nil {\n\t\tutilLog.Fatal(\"Failed to load mime type config:\", \"error\", err)\n\t}\n}\n\n// ContentTypeByFilename returns a MIME content type based on the filename's extension.\n// If no appropriate one is found, returns \"application/octet-stream\" by default.\n// Additionally, specifies the charset as UTF-8 for text/* types.\nfunc ContentTypeByFilename(filename string) string {\n\tdot := strings.LastIndex(filename, \".\")\n\tif dot == -1 || dot+1 >= len(filename) {\n\t\treturn DefaultFileContentType\n\t}\n\n\textension := filename[dot+1:]\n\tcontentType := mimeConfig.StringDefault(extension, \"\")\n\tif contentType == \"\" {\n\t\treturn DefaultFileContentType\n\t}\n\n\tif strings.HasPrefix(contentType, \"text/\") {\n\t\treturn contentType + \"; charset=utf-8\"\n\t}\n\n\treturn contentType\n}\n\n// DirExists returns true if the given path exists and is a directory.\nfunc DirExists(filename string) bool {\n\tfileInfo, err := os.Stat(filename)\n\treturn err == nil && fileInfo.IsDir()\n}\n\nfunc FirstNonEmpty(strs ...string) string {\n\tfor _, str := range strs {\n\t\tif len(str) > 0 {\n\t\t\treturn str\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// Equal is a helper for comparing value equality, following these rules:\n//  - Values with equivalent types are compared with reflect.DeepEqual\n//  - int, uint, and float values are compared without regard to the type width.\n//    for example, Equal(int32(5), int64(5)) == true\n//  - strings and byte slices are converted to strings before comparison.\n//  - else, return false.\nfunc Equal(a, b interface{}) bool {\n\tif reflect.TypeOf(a) == reflect.TypeOf(b) {\n\t\treturn reflect.DeepEqual(a, b)\n\t}\n\tswitch a.(type) {\n\tcase int, int8, int16, int32, int64:\n\t\tswitch b.(type) {\n\t\tcase int, int8, int16, int32, int64:\n\t\t\treturn reflect.ValueOf(a).Int() == reflect.ValueOf(b).Int()\n\t\t}\n\tcase uint, uint8, uint16, uint32, uint64:\n\t\tswitch b.(type) {\n\t\tcase uint, uint8, uint16, uint32, uint64:\n\t\t\treturn reflect.ValueOf(a).Uint() == reflect.ValueOf(b).Uint()\n\t\t}\n\tcase float32, float64:\n\t\tswitch b.(type) {\n\t\tcase float32, float64:\n\t\t\treturn reflect.ValueOf(a).Float() == reflect.ValueOf(b).Float()\n\t\t}\n\tcase string:\n\t\tswitch b.(type) {\n\t\tcase []byte:\n\t\t\treturn a.(string) == string(b.([]byte))\n\t\t}\n\tcase []byte:\n\t\tswitch b.(type) {\n\t\tcase string:\n\t\t\treturn b.(string) == string(a.([]byte))\n\t\t}\n\t}\n\treturn false\n}\n\n// ClientIP method returns client IP address from HTTP request.\n//\n// Note: Set property \"app.behind.proxy\" to true only if Revel is running\n// behind proxy like nginx, haproxy, apache, etc. Otherwise\n// you may get inaccurate Client IP address. Revel parses the\n// IP address in the order of X-Forwarded-For, X-Real-IP.\n//\n// By default revel will get http.Request's RemoteAddr.\nfunc ClientIP(r *Request) string {\n\tif Config.BoolDefault(\"app.behind.proxy\", false) {\n\t\t// Header X-Forwarded-For\n\t\tif fwdFor := strings.TrimSpace(r.GetHttpHeader(HdrForwardedFor)); fwdFor != \"\" {\n\t\t\tindex := strings.Index(fwdFor, \",\")\n\t\t\tif index == -1 {\n\t\t\t\treturn fwdFor\n\t\t\t}\n\t\t\treturn fwdFor[:index]\n\t\t}\n\n\t\t// Header X-Real-Ip\n\t\tif realIP := strings.TrimSpace(r.GetHttpHeader(HdrRealIP)); realIP != \"\" {\n\t\t\treturn realIP\n\t\t}\n\t}\n\n\tif remoteAddr, _, err := net.SplitHostPort(r.RemoteAddr); err == nil {\n\t\treturn remoteAddr\n\t}\n\n\treturn \"\"\n}\n\n// Walk method extends filepath.Walk to also follow symlinks.\n// Always returns the path of the file or directory.\nfunc Walk(root string, walkFn filepath.WalkFunc) error {\n\treturn fsWalk(root, root, walkFn)\n}\n\nfunc fsWalk(fname string, linkName string, walkFn filepath.WalkFunc) error {\n\tfsWalkFunc := func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar name string\n\t\tname, err = filepath.Rel(fname, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpath = filepath.Join(linkName, name)\n\n\t\tif err == nil && info.Mode()&os.ModeSymlink == os.ModeSymlink {\n\t\t\tvar symlinkPath string\n\t\t\tsymlinkPath, err = filepath.EvalSymlinks(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// https://github.com/golang/go/blob/master/src/path/filepath/path.go#L392\n\t\t\tinfo, err = os.Lstat(symlinkPath)\n\n\t\t\tif err != nil {\n\t\t\t\treturn walkFn(path, info, err)\n\t\t\t}\n\n\t\t\tif info.IsDir() {\n\t\t\t\treturn fsWalk(symlinkPath, path, walkFn)\n\t\t\t}\n\t\t}\n\n\t\treturn walkFn(path, info, err)\n\t}\n\terr := filepath.Walk(fname, fsWalkFunc)\n\treturn err\n}\n\nfunc init() {\n\tOnAppStart(LoadMimeConfig)\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 2.7041015625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestContentTypeByFilename(t *testing.T) {\n\ttestCases := map[string]string{\n\t\t\"xyz.jpg\":       \"image/jpeg\",\n\t\t\"helloworld.c\":  \"text/x-c; charset=utf-8\",\n\t\t\"helloworld.\":   \"application/octet-stream\",\n\t\t\"helloworld\":    \"application/octet-stream\",\n\t\t\"hello.world.c\": \"text/x-c; charset=utf-8\",\n\t}\n\tsrcPath, _ := findSrcPaths(RevelImportPath)\n\tConfPaths = []string{\n\t\tfilepath.Join(\n\t\t\tsrcPath,\n\t\t\t\"conf\"),\n\t}\n\tLoadMimeConfig()\n\tfor filename, expected := range testCases {\n\t\tactual := ContentTypeByFilename(filename)\n\t\tif actual != expected {\n\t\t\tt.Errorf(\"%s: %s, Expected %s\", filename, actual, expected)\n\t\t}\n\t}\n}\n\nfunc TestEqual(t *testing.T) {\n\ttype testStruct struct{}\n\ttype testStruct2 struct{}\n\tconst (\n\t\ti  = 8\n\t\ti2 = 9\n\t)\n\ts, s2 := \"@æœ•µ\\n\\tüöäß\", \"@æœ•µ\\n\\tüöäss\"\n\tslice, slice2 := []int{1, 2, 3, 4, 5}, []int{1, 2, 3, 4, 5}\n\tslice3, slice4 := []int{5, 4, 3, 2, 1}, []int{5, 4, 3, 2, 1}\n\n\ttm := map[string][]interface{}{\n\t\t\"slices\":   {slice, slice2},\n\t\t\"slices2\":  {slice3, slice4},\n\t\t\"types\":    {new(testStruct), new(testStruct)},\n\t\t\"types2\":   {new(testStruct2), new(testStruct2)},\n\t\t\"ints\":     {int(i), int8(i), int16(i), int32(i), int64(i)},\n\t\t\"ints2\":    {int(i2), int8(i2), int16(i2), int32(i2), int64(i2)},\n\t\t\"uints\":    {uint(i), uint8(i), uint16(i), uint32(i), uint64(i)},\n\t\t\"uints2\":   {uint(i2), uint8(i2), uint16(i2), uint32(i2), uint64(i2)},\n\t\t\"floats\":   {float32(i), float64(i)},\n\t\t\"floats2\":  {float32(i2), float64(i2)},\n\t\t\"strings\":  {[]byte(s), s},\n\t\t\"strings2\": {[]byte(s2), s2},\n\t}\n\n\ttestRow := func(row, row2 string, expected bool) {\n\t\tfor _, a := range tm[row] {\n\t\t\tfor _, b := range tm[row2] {\n\t\t\t\tok := Equal(a, b)\n\t\t\t\tif ok != expected {\n\t\t\t\t\tak := reflect.TypeOf(a).Kind()\n\t\t\t\t\tbk := reflect.TypeOf(b).Kind()\n\t\t\t\t\tt.Errorf(\"eq(%s=%v,%s=%v) want %t got %t\", ak, a, bk, b, expected, ok)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttestRow(\"slices\", \"slices\", true)\n\ttestRow(\"slices\", \"slices2\", false)\n\ttestRow(\"slices2\", \"slices\", false)\n\n\ttestRow(\"types\", \"types\", true)\n\ttestRow(\"types2\", \"types\", false)\n\ttestRow(\"types\", \"types2\", false)\n\n\ttestRow(\"ints\", \"ints\", true)\n\ttestRow(\"ints\", \"ints2\", false)\n\ttestRow(\"ints2\", \"ints\", false)\n\n\ttestRow(\"uints\", \"uints\", true)\n\ttestRow(\"uints2\", \"uints\", false)\n\ttestRow(\"uints\", \"uints2\", false)\n\n\ttestRow(\"floats\", \"floats\", true)\n\ttestRow(\"floats2\", \"floats\", false)\n\ttestRow(\"floats\", \"floats2\", false)\n\n\ttestRow(\"strings\", \"strings\", true)\n\ttestRow(\"strings2\", \"strings\", false)\n\ttestRow(\"strings\", \"strings2\", false)\n}\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        },
        {
          "name": "validation.go",
          "type": "blob",
          "size": 9.5244140625,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"regexp\"\n\t\"runtime\"\n)\n\n// ValidationError simple struct to store the Message & Key of a validation error.\ntype ValidationError struct {\n\tMessage, Key string\n}\n\n// String returns the Message field of the ValidationError struct.\nfunc (e *ValidationError) String() string {\n\tif e == nil {\n\t\treturn \"\"\n\t}\n\treturn e.Message\n}\n\n// Validation context manages data validation and error messages.\ntype Validation struct {\n\tErrors     []*ValidationError\n\tRequest    *Request\n\tTranslator func(locale, message string, args ...interface{}) string\n\tkeep       bool\n}\n\n// Keep tells revel to set a flash cookie on the client to make the validation\n// errors available for the next request.\n// This is helpful  when redirecting the client after the validation failed.\n// It is good practice to always redirect upon a HTTP POST request. Thus\n// one should use this method when HTTP POST validation failed and redirect\n// the user back to the form.\nfunc (v *Validation) Keep() {\n\tv.keep = true\n}\n\n// Clear *all* ValidationErrors.\nfunc (v *Validation) Clear() {\n\tv.Errors = []*ValidationError{}\n}\n\n// HasErrors returns true if there are any (ie > 0) errors. False otherwise.\nfunc (v *Validation) HasErrors() bool {\n\treturn len(v.Errors) > 0\n}\n\n// ErrorMap returns the errors mapped by key.\n// If there are multiple validation errors associated with a single key, the\n// first one \"wins\".  (Typically the first validation will be the more basic).\nfunc (v *Validation) ErrorMap() map[string]*ValidationError {\n\tm := map[string]*ValidationError{}\n\tfor _, e := range v.Errors {\n\t\tif _, ok := m[e.Key]; !ok {\n\t\t\tm[e.Key] = e\n\t\t}\n\t}\n\treturn m\n}\n\n// Error adds an error to the validation context.\nfunc (v *Validation) Error(message string, args ...interface{}) *ValidationResult {\n\tresult := v.ValidationResult(false).Message(message, args...)\n\tv.Errors = append(v.Errors, result.Error)\n\treturn result\n}\n\n// Error adds an error to the validation context.\nfunc (v *Validation) ErrorKey(message string, args ...interface{}) *ValidationResult {\n\tresult := v.ValidationResult(false).MessageKey(message, args...)\n\tv.Errors = append(v.Errors, result.Error)\n\treturn result\n}\n\n// Error adds an error to the validation context.\nfunc (v *Validation) ValidationResult(ok bool) *ValidationResult {\n\tif ok {\n\t\treturn &ValidationResult{Ok: ok}\n\t} else {\n\t\treturn &ValidationResult{Ok: ok, Error: &ValidationError{}, Locale: v.Request.Locale, Translator: v.Translator}\n\t}\n}\n\n// ValidationResult is returned from every validation method.\n// It provides an indication of success, and a pointer to the Error (if any).\ntype ValidationResult struct {\n\tError      *ValidationError\n\tOk         bool\n\tLocale     string\n\tTranslator func(locale, message string, args ...interface{}) string\n}\n\n// Key sets the ValidationResult's Error \"key\" and returns itself for chaining.\nfunc (r *ValidationResult) Key(key string) *ValidationResult {\n\tif r.Error != nil {\n\t\tr.Error.Key = key\n\t}\n\treturn r\n}\n\n// Message sets the error message for a ValidationResult. Returns itself to\n// allow chaining.  Allows Sprintf() type calling with multiple parameters.\nfunc (r *ValidationResult) Message(message string, args ...interface{}) *ValidationResult {\n\tif r.Error != nil {\n\t\tif len(args) == 0 {\n\t\t\tr.Error.Message = message\n\t\t} else {\n\t\t\tr.Error.Message = fmt.Sprintf(message, args...)\n\t\t}\n\t}\n\treturn r\n}\n\n// Allow a message key to be passed into the validation result. The Validation has already\n// setup the translator to translate the message key.\nfunc (r *ValidationResult) MessageKey(message string, args ...interface{}) *ValidationResult {\n\tif r.Error == nil {\n\t\treturn r\n\t}\n\n\t// If translator found, use that to create the message, otherwise call Message method\n\tif r.Translator != nil {\n\t\tr.Error.Message = r.Translator(r.Locale, message, args...)\n\t} else {\n\t\tr.Message(message, args...)\n\t}\n\n\treturn r\n}\n\n// Required tests that the argument is non-nil and non-empty (if string or list).\nfunc (v *Validation) Required(obj interface{}) *ValidationResult {\n\treturn v.apply(Required{}, obj)\n}\n\nfunc (v *Validation) Min(n int, min int) *ValidationResult {\n\treturn v.MinFloat(float64(n), float64(min))\n}\n\nfunc (v *Validation) MinFloat(n float64, min float64) *ValidationResult {\n\treturn v.apply(Min{min}, n)\n}\n\nfunc (v *Validation) Max(n int, max int) *ValidationResult {\n\treturn v.MaxFloat(float64(n), float64(max))\n}\n\nfunc (v *Validation) MaxFloat(n float64, max float64) *ValidationResult {\n\treturn v.apply(Max{max}, n)\n}\n\nfunc (v *Validation) Range(n, min, max int) *ValidationResult {\n\treturn v.RangeFloat(float64(n), float64(min), float64(max))\n}\n\nfunc (v *Validation) RangeFloat(n, min, max float64) *ValidationResult {\n\treturn v.apply(Range{Min{min}, Max{max}}, n)\n}\n\nfunc (v *Validation) MinSize(obj interface{}, min int) *ValidationResult {\n\treturn v.apply(MinSize{min}, obj)\n}\n\nfunc (v *Validation) MaxSize(obj interface{}, max int) *ValidationResult {\n\treturn v.apply(MaxSize{max}, obj)\n}\n\nfunc (v *Validation) Length(obj interface{}, n int) *ValidationResult {\n\treturn v.apply(Length{n}, obj)\n}\n\nfunc (v *Validation) Match(str string, regex *regexp.Regexp) *ValidationResult {\n\treturn v.apply(Match{regex}, str)\n}\n\nfunc (v *Validation) Email(str string) *ValidationResult {\n\treturn v.apply(Email{Match{emailPattern}}, str)\n}\n\nfunc (v *Validation) IPAddr(str string, cktype ...int) *ValidationResult {\n\treturn v.apply(IPAddr{cktype}, str)\n}\n\nfunc (v *Validation) MacAddr(str string) *ValidationResult {\n\treturn v.apply(IPAddr{}, str)\n}\n\nfunc (v *Validation) Domain(str string) *ValidationResult {\n\treturn v.apply(Domain{}, str)\n}\n\nfunc (v *Validation) URL(str string) *ValidationResult {\n\treturn v.apply(URL{}, str)\n}\n\nfunc (v *Validation) PureText(str string, m int) *ValidationResult {\n\treturn v.apply(PureText{m}, str)\n}\n\nfunc (v *Validation) FilePath(str string, m int) *ValidationResult {\n\treturn v.apply(FilePath{m}, str)\n}\n\nfunc (v *Validation) apply(chk Validator, obj interface{}) *ValidationResult {\n\tif chk.IsSatisfied(obj) {\n\t\treturn v.ValidationResult(true)\n\t}\n\n\t// Get the default key.\n\tvar key string\n\tif pc, _, line, ok := runtime.Caller(2); ok {\n\t\tf := runtime.FuncForPC(pc)\n\t\tif defaultKeys, ok := DefaultValidationKeys[f.Name()]; ok {\n\t\t\tkey = defaultKeys[line]\n\t\t}\n\t} else {\n\t\tutilLog.Error(\"Validation: Failed to get Caller information to look up Validation key\")\n\t}\n\n\t// Add the error to the validation context.\n\terr := &ValidationError{\n\t\tMessage: chk.DefaultMessage(),\n\t\tKey:     key,\n\t}\n\tv.Errors = append(v.Errors, err)\n\n\t// Also return it in the result.\n\tvr := v.ValidationResult(false)\n\tvr.Error = err\n\treturn vr\n}\n\n// Check applies a group of validators to a field, in order, and return the\n// ValidationResult from the first one that fails, or the last one that\n// succeeds.\nfunc (v *Validation) Check(obj interface{}, checks ...Validator) *ValidationResult {\n\tvar result *ValidationResult\n\tfor _, check := range checks {\n\t\tresult = v.apply(check, obj)\n\t\tif !result.Ok {\n\t\t\treturn result\n\t\t}\n\t}\n\treturn result\n}\n\n// ValidationFilter revel Filter function to be hooked into the filter chain.\nfunc ValidationFilter(c *Controller, fc []Filter) {\n\t// If json request, we shall assume json response is intended,\n\t// as such no validation cookies should be tied response\n\tif c.Params != nil && c.Params.JSON != nil {\n\t\tc.Validation = &Validation{Request: c.Request, Translator: MessageFunc}\n\t\tfc[0](c, fc[1:])\n\t} else {\n\t\terrors, err := restoreValidationErrors(c.Request)\n\t\tc.Validation = &Validation{\n\t\t\tErrors:     errors,\n\t\t\tkeep:       false,\n\t\t\tRequest:    c.Request,\n\t\t\tTranslator: MessageFunc,\n\t\t}\n\t\thasCookie := (err != http.ErrNoCookie)\n\n\t\tfc[0](c, fc[1:])\n\n\t\t// Add Validation errors to ViewArgs.\n\t\tc.ViewArgs[\"errors\"] = c.Validation.ErrorMap()\n\n\t\t// Store the Validation errors\n\t\tvar errorsValue string\n\t\tif c.Validation.keep {\n\t\t\tfor _, err := range c.Validation.Errors {\n\t\t\t\tif err.Message != \"\" {\n\t\t\t\t\terrorsValue += \"\\x00\" + err.Key + \":\" + err.Message + \"\\x00\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// When there are errors from Validation and Keep() has been called, store the\n\t\t// values in a cookie. If there previously was a cookie but no errors, remove\n\t\t// the cookie.\n\t\tif errorsValue != \"\" {\n\t\t\tc.SetCookie(&http.Cookie{\n\t\t\t\tName:     CookiePrefix + \"_ERRORS\",\n\t\t\t\tValue:    url.QueryEscape(errorsValue),\n\t\t\t\tDomain:   CookieDomain,\n\t\t\t\tPath:     \"/\",\n\t\t\t\tHttpOnly: true,\n\t\t\t\tSecure:   CookieSecure,\n\t\t\t\tSameSite: CookieSameSite,\n\t\t\t})\n\t\t} else if hasCookie {\n\t\t\tc.SetCookie(&http.Cookie{\n\t\t\t\tName:     CookiePrefix + \"_ERRORS\",\n\t\t\t\tMaxAge:   -1,\n\t\t\t\tDomain:   CookieDomain,\n\t\t\t\tPath:     \"/\",\n\t\t\t\tHttpOnly: true,\n\t\t\t\tSecure:   CookieSecure,\n\t\t\t\tSameSite: CookieSameSite,\n\t\t\t})\n\t\t}\n\t}\n}\n\n// Restore Validation.Errors from a request.\nfunc restoreValidationErrors(req *Request) ([]*ValidationError, error) {\n\tvar (\n\t\terr    error\n\t\tcookie ServerCookie\n\t\terrors = make([]*ValidationError, 0, 5)\n\t)\n\tif cookie, err = req.Cookie(CookiePrefix + \"_ERRORS\"); err == nil {\n\t\tParseKeyValueCookie(cookie.GetValue(), func(key, val string) {\n\t\t\terrors = append(errors, &ValidationError{\n\t\t\t\tKey:     key,\n\t\t\t\tMessage: val,\n\t\t\t})\n\t\t})\n\t}\n\treturn errors, err\n}\n\n// DefaultValidationKeys register default validation keys for all calls to Controller.Validation.Func().\n// Map from (package).func => (line => name of first arg to Validation func)\n// E.g. \"myapp/controllers.helper\" or \"myapp/controllers.(*Application).Action\"\n// This is set on initialization in the generated main.go file.\nvar DefaultValidationKeys map[string]map[int]string\n"
        },
        {
          "name": "validation_test.go",
          "type": "blob",
          "size": 3.1376953125,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// getRecordedCookie returns the recorded cookie from a ResponseRecorder with\n// the given name. It utilizes the cookie reader found in the standard library.\nfunc getRecordedCookie(recorder *httptest.ResponseRecorder, name string) (*http.Cookie, error) {\n\tr := &http.Response{Header: recorder.HeaderMap}\n\tfor _, cookie := range r.Cookies() {\n\t\tif cookie.Name == name {\n\t\t\treturn cookie, nil\n\t\t}\n\t}\n\treturn nil, http.ErrNoCookie\n}\n\n// r.Original.URL.String().\nfunc validationTester(req *Request, fn func(c *Controller)) *httptest.ResponseRecorder {\n\trecorder := httptest.NewRecorder()\n\tc := NewTestController(recorder, req.In.GetRaw().(*http.Request))\n\tc.Request = req\n\n\tValidationFilter(c, []Filter{I18nFilter, func(c *Controller, _ []Filter) {\n\t\tfn(c)\n\t}})\n\treturn recorder\n}\n\n// Test that errors are encoded into the _ERRORS cookie.\nfunc TestValidationWithError(t *testing.T) {\n\trecorder := validationTester(buildEmptyRequest().Request, func(c *Controller) {\n\t\tc.Validation.Required(\"\")\n\t\tif !c.Validation.HasErrors() {\n\t\t\tt.Fatal(\"errors should be present\")\n\t\t}\n\t\tc.Validation.Keep()\n\t})\n\n\tif cookie, err := getRecordedCookie(recorder, \"REVEL_ERRORS\"); err != nil {\n\t\tt.Fatal(err)\n\t} else if cookie.MaxAge < 0 {\n\t\tt.Fatalf(\"cookie should not expire\")\n\t}\n}\n\n// Test that no cookie is sent if errors are found, but Keep() is not called.\nfunc TestValidationNoKeep(t *testing.T) {\n\trecorder := validationTester(buildEmptyRequest().Request, func(c *Controller) {\n\t\tc.Validation.Required(\"\")\n\t\tif !c.Validation.HasErrors() {\n\t\t\tt.Fatal(\"errors should not be present\")\n\t\t}\n\t})\n\n\tif _, err := getRecordedCookie(recorder, \"REVEL_ERRORS\"); err != http.ErrNoCookie {\n\t\tt.Fatal(err)\n\t}\n}\n\n// Test that a previously set _ERRORS cookie is deleted if no errors are found.\nfunc TestValidationNoKeepCookiePreviouslySet(t *testing.T) {\n\treq := buildRequestWithCookie(\"REVEL_ERRORS\", \"invalid\").Request\n\trecorder := validationTester(req, func(c *Controller) {\n\t\tc.Validation.Required(\"success\")\n\t\tif c.Validation.HasErrors() {\n\t\t\tt.Fatal(\"errors should not be present\")\n\t\t}\n\t})\n\n\tif cookie, err := getRecordedCookie(recorder, \"REVEL_ERRORS\"); err != nil {\n\t\tt.Fatal(err)\n\t} else if cookie.MaxAge >= 0 {\n\t\tt.Fatalf(\"cookie should be deleted\")\n\t}\n}\n\nfunc TestValidateMessageKey(t *testing.T) {\n\tInit(\"prod\", \"github.com/revel/revel/testdata\", \"\")\n\tloadMessages(testDataPath)\n\n\t// Assert that we have the expected number of languages\n\tif len(MessageLanguages()) != 2 {\n\t\tt.Fatalf(\"Expected messages to contain no more or less than 2 languages, instead there are %d languages\", len(MessageLanguages()))\n\t}\n\treq := buildRequestWithAcceptLanguages(\"nl\").Request\n\n\tvalidationTester(req, func(c *Controller) {\n\t\tc.Validation.Required(\"\").MessageKey(\"greeting\")\n\t\tif msg := c.Validation.Errors[0].Message; msg != \"Hallo\" {\n\t\t\tt.Errorf(\"Failed expected message Hallo got %s\", msg)\n\t\t}\n\n\t\tif !c.Validation.HasErrors() {\n\t\t\tt.Fatal(\"errors should not be present\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "validators.go",
          "type": "blob",
          "size": 13.7255859375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"html\"\n\t\"net\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\ntype Validator interface {\n\tIsSatisfied(interface{}) bool\n\tDefaultMessage() string\n}\n\ntype Required struct{}\n\nfunc ValidRequired() Required {\n\treturn Required{}\n}\n\nfunc (r Required) IsSatisfied(obj interface{}) bool {\n\tif obj == nil {\n\t\treturn false\n\t}\n\tswitch v := reflect.ValueOf(obj); v.Kind() {\n\tcase reflect.Array, reflect.Slice, reflect.Map, reflect.String, reflect.Chan:\n\t\tif v.Len() == 0 {\n\t\t\treturn false\n\t\t}\n\tcase reflect.Ptr:\n\t\treturn r.IsSatisfied(reflect.Indirect(v).Interface())\n\t}\n\treturn !reflect.DeepEqual(obj, reflect.Zero(reflect.TypeOf(obj)).Interface())\n}\n\nfunc (r Required) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Required\")\n}\n\ntype Min struct {\n\tMin float64\n}\n\nfunc ValidMin(min int) Min {\n\treturn ValidMinFloat(float64(min))\n}\n\nfunc ValidMinFloat(min float64) Min {\n\treturn Min{min}\n}\n\nfunc (m Min) IsSatisfied(obj interface{}) bool {\n\tvar (\n\t\tnum float64\n\t\tok  bool\n\t)\n\tswitch reflect.TypeOf(obj).Kind() {\n\tcase reflect.Float64:\n\t\tnum, ok = obj.(float64)\n\tcase reflect.Float32:\n\t\tok = true\n\t\tnum = float64(obj.(float32))\n\tcase reflect.Int:\n\t\tok = true\n\t\tnum = float64(obj.(int))\n\t}\n\n\tif ok {\n\t\treturn num >= m.Min\n\t}\n\treturn false\n}\n\nfunc (m Min) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Minimum is\", m.Min)\n}\n\ntype Max struct {\n\tMax float64\n}\n\nfunc ValidMax(max int) Max {\n\treturn ValidMaxFloat(float64(max))\n}\n\nfunc ValidMaxFloat(max float64) Max {\n\treturn Max{max}\n}\n\nfunc (m Max) IsSatisfied(obj interface{}) bool {\n\tvar (\n\t\tnum float64\n\t\tok  bool\n\t)\n\tswitch reflect.TypeOf(obj).Kind() {\n\tcase reflect.Float64:\n\t\tnum, ok = obj.(float64)\n\tcase reflect.Float32:\n\t\tok = true\n\t\tnum = float64(obj.(float32))\n\tcase reflect.Int:\n\t\tok = true\n\t\tnum = float64(obj.(int))\n\t}\n\n\tif ok {\n\t\treturn num <= m.Max\n\t}\n\treturn false\n}\n\nfunc (m Max) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Maximum is\", m.Max)\n}\n\n// Range requires an integer to be within Min, Max inclusive.\ntype Range struct {\n\tMin\n\tMax\n}\n\nfunc ValidRange(min, max int) Range {\n\treturn ValidRangeFloat(float64(min), float64(max))\n}\n\nfunc ValidRangeFloat(min, max float64) Range {\n\treturn Range{Min{min}, Max{max}}\n}\n\nfunc (r Range) IsSatisfied(obj interface{}) bool {\n\treturn r.Min.IsSatisfied(obj) && r.Max.IsSatisfied(obj)\n}\n\nfunc (r Range) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Range is\", r.Min.Min, \"to\", r.Max.Max)\n}\n\n// MinSize requires an array or string to be at least a given length.\ntype MinSize struct {\n\tMin int\n}\n\nfunc ValidMinSize(min int) MinSize {\n\treturn MinSize{min}\n}\n\nfunc (m MinSize) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\treturn utf8.RuneCountInString(str) >= m.Min\n\t}\n\tv := reflect.ValueOf(obj)\n\tif v.Kind() == reflect.Slice {\n\t\treturn v.Len() >= m.Min\n\t}\n\treturn false\n}\n\nfunc (m MinSize) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Minimum size is\", m.Min)\n}\n\n// MaxSize requires an array or string to be at most a given length.\ntype MaxSize struct {\n\tMax int\n}\n\nfunc ValidMaxSize(max int) MaxSize {\n\treturn MaxSize{max}\n}\n\nfunc (m MaxSize) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\treturn utf8.RuneCountInString(str) <= m.Max\n\t}\n\tv := reflect.ValueOf(obj)\n\tif v.Kind() == reflect.Slice {\n\t\treturn v.Len() <= m.Max\n\t}\n\treturn false\n}\n\nfunc (m MaxSize) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Maximum size is\", m.Max)\n}\n\n// Length requires an array or string to be exactly a given length.\ntype Length struct {\n\tN int\n}\n\nfunc ValidLength(n int) Length {\n\treturn Length{n}\n}\n\nfunc (s Length) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\treturn utf8.RuneCountInString(str) == s.N\n\t}\n\tv := reflect.ValueOf(obj)\n\tif v.Kind() == reflect.Slice {\n\t\treturn v.Len() == s.N\n\t}\n\treturn false\n}\n\nfunc (s Length) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Required length is\", s.N)\n}\n\n// Match requires a string to match a given regex.\ntype Match struct {\n\tRegexp *regexp.Regexp\n}\n\nfunc ValidMatch(regex *regexp.Regexp) Match {\n\treturn Match{regex}\n}\n\nfunc (m Match) IsSatisfied(obj interface{}) bool {\n\tstr := obj.(string)\n\treturn m.Regexp.MatchString(str)\n}\n\nfunc (m Match) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must match\", m.Regexp)\n}\n\nvar emailPattern = regexp.MustCompile(\"^[\\\\w!#$%&'*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[a-zA-Z0-9](?:[\\\\w-]*[\\\\w])?$\")\n\ntype Email struct {\n\tMatch\n}\n\nfunc ValidEmail() Email {\n\treturn Email{Match{emailPattern}}\n}\n\nfunc (e Email) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must be a valid email address\")\n}\n\nconst (\n\tNone               = 0\n\tIPAny              = 1\n\tIPv4               = 32 // IPv4 (32 chars)\n\tIPv6               = 39 // IPv6(39 chars)\n\tIPv4MappedIPv6     = 45 // IP4-mapped IPv6 (45 chars) , Ex) ::FFFF:129.144.52.38\n\tIPv4CIDR           = IPv4 + 3\n\tIPv6CIDR           = IPv6 + 3\n\tIPv4MappedIPv6CIDR = IPv4MappedIPv6 + 3\n)\n\n// Requires a string(IP Address) to be within IP Pattern type inclusive.\ntype IPAddr struct {\n\tVaildtypes []int\n}\n\n// Requires an IP Address string to be exactly a given  validation type (IPv4, IPv6, IPv4MappedIPv6, IPv4CIDR, IPv6CIDR, IPv4MappedIPv6CIDR OR IPAny).\nfunc ValidIPAddr(cktypes ...int) IPAddr {\n\tfor _, cktype := range cktypes {\n\t\tif cktype != IPAny && cktype != IPv4 && cktype != IPv6 && cktype != IPv4MappedIPv6 && cktype != IPv4CIDR && cktype != IPv6CIDR && cktype != IPv4MappedIPv6CIDR {\n\t\t\treturn IPAddr{Vaildtypes: []int{None}}\n\t\t}\n\t}\n\n\treturn IPAddr{Vaildtypes: cktypes}\n}\n\nfunc isWithCIDR(str string, l int) bool {\n\tif str[l-3] == '/' || str[l-2] == '/' {\n\t\tcidr_bit := strings.Split(str, \"/\")\n\t\tif 2 == len(cidr_bit) {\n\t\t\tbit, err := strconv.Atoi(cidr_bit[1])\n\t\t\t// IPv4 : 0~32, IPv6 : 0 ~ 128\n\t\t\tif err == nil && bit >= 0 && bit <= 128 {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc getIPType(str string, l int) int {\n\tif l < 3 { // least 3 chars (::F)\n\t\treturn None\n\t}\n\n\thas_dot := strings.Index(str[2:], \".\")\n\thas_colon := strings.Index(str[2:], \":\")\n\n\tswitch {\n\tcase has_dot > -1 && has_colon == -1 && l >= 7 && l <= IPv4CIDR:\n\t\tif isWithCIDR(str, l) == true {\n\t\t\treturn IPv4CIDR\n\t\t} else {\n\t\t\treturn IPv4\n\t\t}\n\tcase has_dot == -1 && has_colon > -1 && l >= 6 && l <= IPv6CIDR:\n\t\tif isWithCIDR(str, l) == true {\n\t\t\treturn IPv6CIDR\n\t\t} else {\n\t\t\treturn IPv6\n\t\t}\n\n\tcase has_dot > -1 && has_colon > -1 && l >= 14 && l <= IPv4MappedIPv6:\n\t\tif isWithCIDR(str, l) == true {\n\t\t\treturn IPv4MappedIPv6CIDR\n\t\t} else {\n\t\t\treturn IPv4MappedIPv6\n\t\t}\n\t}\n\n\treturn None\n}\n\nfunc (i IPAddr) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\tl := len(str)\n\t\tret := getIPType(str, l)\n\n\t\tfor _, ck := range i.Vaildtypes {\n\t\t\tif ret != None && (ck == ret || ck == IPAny) {\n\t\t\t\tswitch ret {\n\t\t\t\tcase IPv4, IPv6, IPv4MappedIPv6:\n\t\t\t\t\tip := net.ParseIP(str)\n\n\t\t\t\t\tif ip != nil {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\n\t\t\t\tcase IPv4CIDR, IPv6CIDR, IPv4MappedIPv6CIDR:\n\t\t\t\t\t_, _, err := net.ParseCIDR(str)\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\treturn true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (i IPAddr) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must be a valid IP address\")\n}\n\n// Requires a MAC Address string to be exactly.\ntype MacAddr struct{}\n\nfunc ValidMacAddr() MacAddr {\n\treturn MacAddr{}\n}\n\nfunc (m MacAddr) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\tif _, err := net.ParseMAC(str); err == nil {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (m MacAddr) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must be a valid MAC address\")\n}\n\nvar domainPattern = regexp.MustCompile(`^(([a-zA-Z0-9-\\p{L}]{1,63}\\.)?(xn--)?[a-zA-Z0-9\\p{L}]+(-[a-zA-Z0-9\\p{L}]+)*\\.)+[a-zA-Z\\p{L}]{2,63}$`)\n\n// Requires a Domain string to be exactly.\ntype Domain struct {\n\tRegexp *regexp.Regexp\n}\n\nfunc ValidDomain() Domain {\n\treturn Domain{domainPattern}\n}\n\nfunc (d Domain) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\tl := len(str)\n\t\t// can't exceed 253 chars.\n\t\tif l > 253 {\n\t\t\treturn false\n\t\t}\n\n\t\t// first and last char must be alphanumeric\n\t\tif str[l-1] == 46 || str[0] == 46 {\n\t\t\treturn false\n\t\t}\n\n\t\treturn domainPattern.MatchString(str)\n\t}\n\n\treturn false\n}\n\nfunc (d Domain) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must be a valid domain address\")\n}\n\nvar urlPattern = regexp.MustCompile(`^((((https?|ftps?|gopher|telnet|nntp)://)|(mailto:|news:))(%[0-9A-Fa-f]{2}|[-()_.!~*';/?:@#&=+$,A-Za-z0-9\\p{L}])+)([).!';/?:,][[:blank:]])?$`)\n\ntype URL struct {\n\tDomain\n}\n\nfunc ValidURL() URL {\n\treturn URL{Domain: ValidDomain()}\n}\n\nfunc (u URL) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\t// TODO : Required lot of testing\n\t\treturn urlPattern.MatchString(str)\n\t}\n\n\treturn false\n}\n\nfunc (u URL) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must be a valid URL address\")\n}\n\n/*\nNORMAL BenchmarkRegex-8   \t2000000000\t         0.24 ns/op\nSTRICT BenchmarkLoop-8    \t2000000000\t         0.01 ns/op.\n*/\nconst (\n\tNORMAL = 0\n\tSTRICT = 4\n)\n\n// Requires a string to be without invisible characters.\ntype PureText struct {\n\tMode int\n}\n\nfunc ValidPureText(m int) PureText {\n\tif m != NORMAL && m != STRICT { // Q:required fatal error\n\t\tm = STRICT\n\t}\n\treturn PureText{m}\n}\n\nfunc isPureTextStrict(str string) (bool, error) {\n\tl := len(str)\n\n\tfor i := 0; i < l; i++ {\n\t\tc := str[i]\n\n\t\t// deny : control char (00-31 without 9(TAB) and Single 10(LF),13(CR)\n\t\tif c >= 0 && c <= 31 && c != 9 && c != 10 && c != 13 {\n\t\t\treturn false, errors.New(\"detect control character\")\n\t\t}\n\n\t\t// deny : control char (DEL)\n\t\tif c == 127 {\n\t\t\treturn false, errors.New(\"detect control character (DEL)\")\n\t\t}\n\n\t\t// deny : short tag (<~> <~ />)\n\t\tif c == 60 {\n\t\t\tfor n := i + 2; n < l; n++ {\n\t\t\t\t// 62 (>)\n\t\t\t\tif str[n] == 62 {\n\t\t\t\t\treturn false, errors.New(\"detect tag (<(.*)+>)\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// deny : html tag (< ~ >)\n\t\tif c == 60 {\n\t\t\tds := 0\n\t\t\tfor n := i; n < l; n++ {\n\t\t\t\t// 60 (<) , 47(/) | 33(!) | 63(?)\n\t\t\t\tif str[n] == 60 && n+1 <= l && (str[n+1] == 47 || str[n+1] == 33 || str[n+1] == 63) {\n\t\t\t\t\tds = 1\n\t\t\t\t\tn += 3 // jump to next char\n\t\t\t\t}\n\n\t\t\t\t// 62 (>)\n\t\t\t\tif ds == 1 && str[n] == 62 {\n\t\t\t\t\treturn false, errors.New(\"detect tag (<[!|?]~>)\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// deny : html encoded(hex) tag (&xxx;)\n\t\t// 38(&) , 35(#), 59(;)\n\t\tif c == 38 && i+1 <= l {\n\t\t\tmax := i + 64\n\t\t\tif max > l {\n\t\t\t\tmax = l\n\t\t\t}\n\t\t\tfor n := i; n < max; n++ {\n\t\t\t\tif str[n] == 59 {\n\t\t\t\t\treturn false, errors.New(\"detect html encoded ta (&XXX;)\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true, nil\n}\n\n// Requires a string to match a given html tag elements regex pattern\n// referrer : http://www.w3schools.com/Tags/\nvar elementPattern = regexp.MustCompile(`(?im)<(?P<tag>(/*\\s*|\\?*|\\!*)(figcaption|expression|blockquote|plaintext|textarea|progress|optgroup|noscript|noframes|menuitem|frameset|fieldset|!DOCTYPE|datalist|colgroup|behavior|basefont|summary|section|isindex|details|caption|bgsound|article|address|acronym|strong|strike|source|select|script|output|option|object|legend|keygen|ilayer|iframe|header|footer|figure|dialog|center|canvas|button|applet|video|track|title|thead|tfoot|tbody|table|style|small|param|meter|layer|label|input|frame|embed|blink|audio|aside|alert|time|span|samp|ruby|meta|menu|mark|main|link|html|head|form|font|code|cite|body|base|area|abbr|xss|xml|wbr|var|svg|sup|sub|pre|nav|map|kbd|ins|img|div|dir|dfn|del|col|big|bdo|bdi|!--|ul|tt|tr|th|td|rt|rp|ol|li|hr|em|dt|dl|dd|br|u|s|q|p|i|b|a|(h[0-9]+)))([^><]*)([><]*)`)\n\n// Requires a string to match a given urlencoded regex pattern.\nvar urlencodedPattern = regexp.MustCompile(`(?im)(\\%[0-9a-fA-F]{1,})`)\n\n// Requires a string to match a given control characters regex pattern (ASCII : 00-08, 11, 12, 14, 15-31).\nvar controlcharPattern = regexp.MustCompile(`(?im)([\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]+)`)\n\nfunc isPureTextNormal(str string) (bool, error) {\n\tdecoded_str := html.UnescapeString(str)\n\n\tmatched_urlencoded := urlencodedPattern.MatchString(decoded_str)\n\tif matched_urlencoded == true {\n\t\ttemp_buf, err := url.QueryUnescape(decoded_str)\n\t\tif err == nil {\n\t\t\tdecoded_str = temp_buf\n\t\t}\n\t}\n\n\tmatched_element := elementPattern.MatchString(decoded_str)\n\tif matched_element == true {\n\t\treturn false, errors.New(\"detect html element\")\n\t}\n\n\tmatched_cc := controlcharPattern.MatchString(decoded_str)\n\tif matched_cc == true {\n\t\treturn false, errors.New(\"detect control character\")\n\t}\n\n\treturn true, nil\n}\n\nfunc (p PureText) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\tvar ret bool\n\t\tswitch p.Mode {\n\t\tcase STRICT:\n\t\t\tret, _ = isPureTextStrict(str)\n\t\tcase NORMAL:\n\t\t\tret, _ = isPureTextNormal(str)\n\t\t}\n\t\treturn ret\n\t}\n\n\treturn false\n}\n\nfunc (p PureText) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must be a valid Text\")\n}\n\nconst (\n\tONLY_FILENAME       = 0\n\tALLOW_RELATIVE_PATH = 1\n)\n\nconst (\n\tregexDenyFileNameCharList = `[\\x00-\\x1f|\\x21-\\x2c|\\x3b-\\x40|\\x5b-\\x5e|\\x60|\\x7b-\\x7f]+`\n\tregexDenyFileName         = `|\\x2e\\x2e\\x2f+`\n)\n\nvar (\n\tcheckAllowRelativePath = regexp.MustCompile(`(?m)(` + regexDenyFileNameCharList + `)`)\n\tcheckDenyRelativePath  = regexp.MustCompile(`(?m)(` + regexDenyFileNameCharList + regexDenyFileName + `)`)\n)\n\n// Requires an string to be sanitary file path.\ntype FilePath struct {\n\tMode int\n}\n\nfunc ValidFilePath(m int) FilePath {\n\tif m != ONLY_FILENAME && m != ALLOW_RELATIVE_PATH {\n\t\tm = ONLY_FILENAME\n\t}\n\treturn FilePath{m}\n}\n\nfunc (f FilePath) IsSatisfied(obj interface{}) bool {\n\tif str, ok := obj.(string); ok {\n\t\tvar ret bool\n\t\tswitch f.Mode {\n\t\tcase ALLOW_RELATIVE_PATH:\n\t\t\tret = checkAllowRelativePath.MatchString(str)\n\t\t\tif ret == false {\n\t\t\t\treturn true\n\t\t\t}\n\t\tdefault: // ONLY_FILENAME\n\t\t\tret = checkDenyRelativePath.MatchString(str)\n\t\t\tif ret == false {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (f FilePath) DefaultMessage() string {\n\treturn fmt.Sprintln(\"Must be a unsanitary string\")\n}\n"
        },
        {
          "name": "validators_test.go",
          "type": "blob",
          "size": 24.4296875,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel_test\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/revel/revel\"\n)\n\nconst (\n\terrorsMessage   = \"validation for %s should not be satisfied with %s\\n\"\n\tnoErrorsMessage = \"validation for %s should be satisfied with %s\\n\"\n)\n\ntype Expect struct {\n\tinput          interface{}\n\texpectedResult bool\n\terrorMessage   string\n}\n\nfunc performTests(validator revel.Validator, tests []Expect, t *testing.T) {\n\tfor _, test := range tests {\n\t\tif validator.IsSatisfied(test.input) != test.expectedResult {\n\t\t\tif test.expectedResult {\n\t\t\t\tt.Errorf(noErrorsMessage, reflect.TypeOf(validator), test.errorMessage)\n\t\t\t} else {\n\t\t\t\tt.Errorf(errorsMessage, reflect.TypeOf(validator), test.errorMessage)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRequired(t *testing.T) {\n\ttests := []Expect{\n\t\t{nil, false, \"nil data\"},\n\t\t{\"Testing\", true, \"non-empty string\"},\n\t\t{\"\", false, \"empty string\"},\n\t\t{true, true, \"true boolean\"},\n\t\t{false, false, \"false boolean\"},\n\t\t{1, true, \"positive integer\"},\n\t\t{-1, true, \"negative integer\"},\n\t\t{0, false, \"0 integer\"},\n\t\t{time.Now(), true, \"current time\"},\n\t\t{time.Time{}, false, \"a zero time\"},\n\t\t{func() {}, true, \"other non-nil data types\"},\n\t\t{net.IP(\"\"), false, \"empty IP address\"},\n\t}\n\n\t// testing both the struct and the helper method\n\tfor _, required := range []revel.Required{{}, revel.ValidRequired()} {\n\t\tperformTests(required, tests, t)\n\t}\n}\n\nfunc TestMin(t *testing.T) {\n\ttests := []Expect{\n\t\t{11, true, \"val > min\"},\n\t\t{10, true, \"val == min\"},\n\t\t{9, false, \"val < min\"},\n\t\t{true, false, \"TypeOf(val) != int\"},\n\t}\n\tfor _, min := range []revel.Min{{10}, revel.ValidMin(10)} {\n\t\tperformTests(min, tests, t)\n\t}\n}\n\nfunc TestMax(t *testing.T) {\n\ttests := []Expect{\n\t\t{9, true, \"val < max\"},\n\t\t{10, true, \"val == max\"},\n\t\t{11, false, \"val > max\"},\n\t\t{true, false, \"TypeOf(val) != int\"},\n\t}\n\tfor _, max := range []revel.Max{{10}, revel.ValidMax(10)} {\n\t\tperformTests(max, tests, t)\n\t}\n}\n\nfunc TestRange(t *testing.T) {\n\ttests := []Expect{\n\t\t{50, true, \"min <= val <= max\"},\n\t\t{10, true, \"val == min\"},\n\t\t{100, true, \"val == max\"},\n\t\t{9, false, \"val < min\"},\n\t\t{101, false, \"val > max\"},\n\t}\n\n\tgoodValidators := []revel.Range{\n\t\t{revel.Min{10}, revel.Max{100}},\n\t\trevel.ValidRange(10, 100),\n\t}\n\tfor _, rangeValidator := range goodValidators {\n\t\tperformTests(rangeValidator, tests, t)\n\t}\n\n\ttestsFloat := []Expect{\n\t\t{50, true, \"min <= val <= max\"},\n\t\t{10.25, true, \"val == min\"},\n\t\t{100, true, \"val == max\"},\n\t\t{9, false, \"val < min\"},\n\t\t{101, false, \"val > max\"},\n\t}\n\tgoodValidatorsFloat := []revel.Range{\n\t\t{revel.Min{10.25}, revel.Max{100.5}},\n\t\trevel.ValidRangeFloat(10.25, 100.5),\n\t}\n\tfor _, rangeValidator := range goodValidatorsFloat {\n\t\tperformTests(rangeValidator, testsFloat, t)\n\t}\n\n\ttests = []Expect{\n\t\t{10, true, \"min == val == max\"},\n\t\t{9, false, \"val < min && val < max && min == max\"},\n\t\t{11, false, \"val > min && val > max && min == max\"},\n\t}\n\n\tgoodValidators = []revel.Range{\n\t\t{revel.Min{10}, revel.Max{10}},\n\t\trevel.ValidRange(10, 10),\n\t}\n\tfor _, rangeValidator := range goodValidators {\n\t\tperformTests(rangeValidator, tests, t)\n\t}\n\n\ttests = make([]Expect, 7)\n\tfor i, num := range []int{50, 100, 10, 9, 101, 0, -1} {\n\t\ttests[i] = Expect{\n\t\t\tnum,\n\t\t\tfalse,\n\t\t\t\"min > val < max\",\n\t\t}\n\t}\n\t// these are min/max with values swapped, so the min is the high\n\t// and max is the low. rangeValidator.IsSatisfied() should ALWAYS\n\t// result in false since val can never be greater than min and less\n\t// than max when min > max\n\tbadValidators := []revel.Range{\n\t\t{revel.Min{100}, revel.Max{10}},\n\t\trevel.ValidRange(100, 10),\n\t}\n\tfor _, rangeValidator := range badValidators {\n\t\tperformTests(rangeValidator, tests, t)\n\t}\n\n\tbadValidatorsFloat := []revel.Range{\n\t\t{revel.Min{100}, revel.Max{10}},\n\t\trevel.ValidRangeFloat(100, 10),\n\t}\n\tfor _, rangeValidator := range badValidatorsFloat {\n\t\tperformTests(rangeValidator, tests, t)\n\t}\n}\n\nfunc TestMinSize(t *testing.T) {\n\tgreaterThanMessage := \"len(val) >= min\"\n\ttests := []Expect{\n\t\t{\"12\", true, greaterThanMessage},\n\t\t{\"123\", true, greaterThanMessage},\n\t\t{[]int{1, 2}, true, greaterThanMessage},\n\t\t{[]int{1, 2, 3}, true, greaterThanMessage},\n\t\t{\"\", false, \"len(val) <= min\"},\n\t\t{\"手\", false, \"len(val) <= min\"},\n\t\t{[]int{}, false, \"len(val) <= min\"},\n\t\t{nil, false, \"TypeOf(val) != string && TypeOf(val) != slice\"},\n\t}\n\n\tfor _, minSize := range []revel.MinSize{{2}, revel.ValidMinSize(2)} {\n\t\tperformTests(minSize, tests, t)\n\t}\n}\n\nfunc TestMaxSize(t *testing.T) {\n\tlessThanMessage := \"len(val) <= max\"\n\ttests := []Expect{\n\t\t{\"\", true, lessThanMessage},\n\t\t{\"12\", true, lessThanMessage},\n\t\t{\"ルビー\", true, lessThanMessage},\n\t\t{[]int{}, true, lessThanMessage},\n\t\t{[]int{1, 2}, true, lessThanMessage},\n\t\t{[]int{1, 2, 3}, true, lessThanMessage},\n\t\t{\"1234\", false, \"len(val) >= max\"},\n\t\t{[]int{1, 2, 3, 4}, false, \"len(val) >= max\"},\n\t}\n\tfor _, maxSize := range []revel.MaxSize{{3}, revel.ValidMaxSize(3)} {\n\t\tperformTests(maxSize, tests, t)\n\t}\n}\n\nfunc TestLength(t *testing.T) {\n\ttests := []Expect{\n\t\t{\"12\", true, \"len(val) == length\"},\n\t\t{\"火箭\", true, \"len(val) == length\"},\n\t\t{[]int{1, 2}, true, \"len(val) == length\"},\n\t\t{\"123\", false, \"len(val) > length\"},\n\t\t{[]int{1, 2, 3}, false, \"len(val) > length\"},\n\t\t{\"1\", false, \"len(val) < length\"},\n\t\t{[]int{1}, false, \"len(val) < length\"},\n\t\t{nil, false, \"TypeOf(val) != string && TypeOf(val) != slice\"},\n\t}\n\tfor _, length := range []revel.Length{{2}, revel.ValidLength(2)} {\n\t\tperformTests(length, tests, t)\n\t}\n}\n\nfunc TestMatch(t *testing.T) {\n\ttests := []Expect{\n\t\t{\"bca123\", true, `\"[abc]{3}\\d*\" matches \"bca123\"`},\n\t\t{\"bc123\", false, `\"[abc]{3}\\d*\" does not match \"bc123\"`},\n\t\t{\"\", false, `\"[abc]{3}\\d*\" does not match \"\"`},\n\t}\n\tregex := regexp.MustCompile(`[abc]{3}\\d*`)\n\tfor _, match := range []revel.Match{{regex}, revel.ValidMatch(regex)} {\n\t\tperformTests(match, tests, t)\n\t}\n}\n\nfunc TestEmail(t *testing.T) {\n\t// unicode char included\n\tvalidStartingCharacters := strings.Split(\"!#$%^&*_+1234567890abcdefghijklmnopqrstuvwxyzñ\", \"\")\n\tinvalidCharacters := strings.Split(\" ()\", \"\")\n\n\tdefiniteInvalidDomains := []string{\n\t\t\"\",                  // any empty string (x@)\n\t\t\".com\",              // only the TLD (x@.com)\n\t\t\".\",                 // only the . (x@.)\n\t\t\".*\",                // TLD containing symbol (x@.*)\n\t\t\"asdf\",              // no TLD\n\t\t\"a!@#$%^&*()+_.com\", // characters which are not ASCII/0-9/dash(-) in a domain\n\t\t\"-a.com\",            // host starting with any symbol\n\t\t\"a-.com\",            // host ending with any symbol\n\t\t\"aå.com\",            // domain containing unicode (however, unicode domains do exist in the state of xn--<POINT>.com e.g. å.com = xn--5ca.com)\n\t}\n\n\t// Email pattern is not exposed\n\temailPattern := regexp.MustCompile(\"^[\\\\w!#$%&'*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[a-zA-Z0-9](?:[\\\\w-]*[\\\\w])?$\")\n\tfor _, email := range []revel.Email{{revel.Match{emailPattern}}, revel.ValidEmail()} {\n\t\tvar currentEmail string\n\n\t\t// test invalid starting chars\n\t\tfor _, startingChar := range validStartingCharacters {\n\t\t\tcurrentEmail = fmt.Sprintf(\"%sñbc+123@do-main.com\", startingChar)\n\t\t\tif email.IsSatisfied(currentEmail) {\n\t\t\t\tt.Errorf(noErrorsMessage, \"starting characters\", fmt.Sprintf(\"email = %s\", currentEmail))\n\t\t\t}\n\n\t\t\t// validation should fail because of multiple @ symbols\n\t\t\tcurrentEmail = fmt.Sprintf(\"%s@ñbc+123@do-main.com\", startingChar)\n\t\t\tif email.IsSatisfied(currentEmail) {\n\t\t\t\tt.Errorf(errorsMessage, \"starting characters with multiple @ symbols\", fmt.Sprintf(\"email = %s\", currentEmail))\n\t\t\t}\n\n\t\t\t// should fail simply because of the invalid char\n\t\t\tfor _, invalidChar := range invalidCharacters {\n\t\t\t\tcurrentEmail = fmt.Sprintf(\"%sñbc%s+123@do-main.com\", startingChar, invalidChar)\n\t\t\t\tif email.IsSatisfied(currentEmail) {\n\t\t\t\t\tt.Errorf(errorsMessage, \"invalid starting characters\", fmt.Sprintf(\"email = %s\", currentEmail))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// test invalid domains\n\t\tfor _, invalidDomain := range definiteInvalidDomains {\n\t\t\tcurrentEmail = fmt.Sprintf(\"a@%s\", invalidDomain)\n\t\t\tif email.IsSatisfied(currentEmail) {\n\t\t\t\tt.Errorf(errorsMessage, \"invalid domain\", fmt.Sprintf(\"email = %s\", currentEmail))\n\t\t\t}\n\t\t}\n\n\t\t// should always be satisfied\n\t\tif !email.IsSatisfied(\"t0.est+email123@1abc0-def.com\") {\n\t\t\tt.Errorf(noErrorsMessage, \"guaranteed valid email\", fmt.Sprintf(\"email = %s\", \"t0.est+email123@1abc0-def.com\"))\n\t\t}\n\n\t\t// should never be satisfied (this is redundant given the loops above)\n\t\tif email.IsSatisfied(\"a@xcom\") {\n\t\t\tt.Errorf(noErrorsMessage, \"guaranteed invalid email\", fmt.Sprintf(\"email = %s\", \"a@xcom\"))\n\t\t}\n\t\tif email.IsSatisfied(\"a@@x.com\") {\n\t\t\tt.Errorf(noErrorsMessage, \"guaranteed invalid email\", fmt.Sprintf(\"email = %s\", \"a@@x.com\"))\n\t\t}\n\t}\n}\n\nfunc runIPAddrTestfunc(t *testing.T, test_type int, ipaddr_list map[string]bool, msg_fmt string) {\n\t// generate dataset for test\n\ttest_ipaddr_list := []Expect{}\n\tfor ipaddr, expected := range ipaddr_list {\n\t\ttest_ipaddr_list = append(test_ipaddr_list, Expect{input: ipaddr, expectedResult: expected, errorMessage: fmt.Sprintf(msg_fmt, ipaddr)})\n\t}\n\n\tfor _, ip_test_list := range []revel.IPAddr{{[]int{test_type}}, revel.ValidIPAddr(test_type)} {\n\t\tperformTests(ip_test_list, test_ipaddr_list, t)\n\t}\n}\n\nfunc TestIPAddr(t *testing.T) {\n\t// IPv4\n\ttest_ipv4_ipaddrs := map[string]bool{\n\t\t\"192.168.1.1\":     true,\n\t\t\"127.0.0.1\":       true,\n\t\t\"10.10.90.12\":     true,\n\t\t\"8.8.8.8\":         true,\n\t\t\"4.4.4.4\":         true,\n\t\t\"912.456.123.123\": false,\n\t\t\"999.999.999.999\": false,\n\t\t\"192.192.19.999\":  false,\n\t}\n\n\t// IPv4 with CIDR\n\ttest_ipv4_with_cidr_ipaddrs := map[string]bool{\n\t\t\"192.168.1.1/24\": true,\n\t\t\"127.0.0.1/32\":   true,\n\t\t\"10.10.90.12/8\":  true,\n\t\t\"8.8.8.8/1\":      true,\n\t\t\"4.4.4.4/7\":      true,\n\t\t\"192.168.1.1/99\": false,\n\t\t\"127.0.0.1/9999\": false,\n\t\t\"10.10.90.12/33\": false,\n\t\t\"8.8.8.8/128\":    false,\n\t\t\"4.4.4.4/256\":    false,\n\t}\n\n\t// IPv6\n\ttest_ipv6_ipaddrs := map[string]bool{\n\t\t\"2607:f0d0:1002:51::4\":                    true,\n\t\t\"2607:f0d0:1002:0051:0000:0000:0000:0004\": true,\n\t\t\"ff05::1:3\": true,\n\t\t\"FE80:0000:0000:0000:0202:B3FF:FE1E:8329\": true,\n\t\t\"FE80::0202:B3FF:FE1E:8329\":               true,\n\t\t\"fe80::202:b3ff:fe1e:8329\":                true,\n\t\t\"fe80:0000:0000:0000:0202:b3ff:fe1e:8329\": true,\n\t\t\"2001:470:1f09:495::3\":                    true,\n\t\t\"2001:470:1f1d:275::1\":                    true,\n\t\t\"2600:9000:5304:200::1\":                   true,\n\t\t\"2600:9000:5306:d500::1\":                  true,\n\t\t\"2600:9000:5301:b600::1\":                  true,\n\t\t\"2600:9000:5303:900::1\":                   true,\n\t\t\"127:12:12:12:12:12:!2:!2\":                false,\n\t\t\"127.0.0.1\":                               false,\n\t\t\"234:23:23:23:23:23:23\":                   false,\n\t}\n\n\t// IPv6 with CIDR\n\ttest_ipv6_with_cidr_ipaddrs := map[string]bool{\n\t\t\"2000::/5\":      true,\n\t\t\"2000::/15\":     true,\n\t\t\"2001:db8::/33\": true,\n\t\t\"2001:db8::/48\": true,\n\t\t\"fc00::/7\":      true,\n\t}\n\n\t// IPv4-Mapped Embedded IPv6 Address\n\ttest_ipv4_mapped_ipv6_ipaddrs := map[string]bool{\n\t\t\"2001:470:1f09:495::3:217.126.185.215\":         true,\n\t\t\"2001:470:1f1d:275::1:213.0.69.132\":            true,\n\t\t\"2600:9000:5304:200::1:205.251.196.2\":          true,\n\t\t\"2600:9000:5306:d500::1:205.251.198.213\":       true,\n\t\t\"2600:9000:5301:b600::1:205.251.193.182\":       true,\n\t\t\"2600:9000:5303:900::1:205.251.195.9\":          true,\n\t\t\"0:0:0:0:0:FFFF:222.1.41.90\":                   true,\n\t\t\"::FFFF:222.1.41.90\":                           true,\n\t\t\"0000:0000:0000:0000:0000:FFFF:12.155.166.101\": true,\n\t\t\"12.155.166.101\":                               false,\n\t\t\"12.12/12\":                                     false,\n\t}\n\n\trunIPAddrTestfunc(t, revel.IPv4, test_ipv4_ipaddrs, \"invalid (%s) IPv4 address\")\n\trunIPAddrTestfunc(t, revel.IPv4CIDR, test_ipv4_with_cidr_ipaddrs, \"invalid (%s) IPv4 with CIDR address\")\n\n\trunIPAddrTestfunc(t, revel.IPv6, test_ipv6_ipaddrs, \"invalid (%s) IPv6 address\")\n\trunIPAddrTestfunc(t, revel.IPv6CIDR, test_ipv6_with_cidr_ipaddrs, \"invalid (%s) IPv6 with CIDR address\")\n\trunIPAddrTestfunc(t, revel.IPv4MappedIPv6, test_ipv4_mapped_ipv6_ipaddrs, \"invalid (%s) IPv4-Mapped Embedded IPv6 address\")\n}\n\nfunc TestMacAddr(t *testing.T) {\n\tmacaddr_list := map[string]bool{\n\t\t\"02:f3:71:eb:9e:4b\": true,\n\t\t\"02-f3-71-eb-9e-4b\": true,\n\t\t\"02f3.71eb.9e4b\":    true,\n\t\t\"87:78:6e:3e:90:40\": true,\n\t\t\"87-78-6e-3e-90-40\": true,\n\t\t\"8778.6e3e.9040\":    true,\n\t\t\"e7:28:b9:57:ab:36\": true,\n\t\t\"e7-28-b9-57-ab-36\": true,\n\t\t\"e728.b957.ab36\":    true,\n\t\t\"eb:f8:2b:d7:e9:62\": true,\n\t\t\"eb-f8-2b-d7-e9-62\": true,\n\t\t\"ebf8.2bd7.e962\":    true,\n\t}\n\n\ttest_macaddr_list := []Expect{}\n\tfor macaddr, expected := range macaddr_list {\n\t\ttest_macaddr_list = append(test_macaddr_list, Expect{input: macaddr, expectedResult: expected, errorMessage: fmt.Sprintf(\"invalid (%s) MAC address\", macaddr)})\n\t}\n\n\tfor _, mac_test_list := range []revel.MacAddr{{}, revel.ValidMacAddr()} {\n\t\tperformTests(mac_test_list, test_macaddr_list, t)\n\t}\n}\n\nfunc TestDomain(t *testing.T) {\n\ttest_domains := map[string]bool{\n\t\t\"대한민국.xn-korea.co.kr\":           true,\n\t\t\"google.com\":                    true,\n\t\t\"masełkowski.pl\":                true,\n\t\t\"maselkowski.pl\":                true,\n\t\t\"m.maselkowski.pl\":              true,\n\t\t\"www.masełkowski.pl.com\":        true,\n\t\t\"xn--masekowski-d0b.pl\":         true,\n\t\t\"中国互联网络信息中心.中国\":                 true,\n\t\t\"masełkowski.pl.\":               false,\n\t\t\"中国互联网络信息中心.xn--masekowski-d0b\": false,\n\t\t\"a.jp\":                     true,\n\t\t\"a.co\":                     true,\n\t\t\"a.co.jp\":                  true,\n\t\t\"a.co.or\":                  true,\n\t\t\"a.or.kr\":                  true,\n\t\t\"qwd-qwdqwd.com\":           true,\n\t\t\"qwd-qwdqwd.co_m\":          false,\n\t\t\"qwd-qwdqwd.c\":             false,\n\t\t\"qwd-qwdqwd.-12\":           false,\n\t\t\"qwd-qwdqwd.1212\":          false,\n\t\t\"qwd-qwdqwd.org\":           true,\n\t\t\"qwd-qwdqwd.ac.kr\":         true,\n\t\t\"qwd-qwdqwd.gov\":           true,\n\t\t\"chicken.beer\":             true,\n\t\t\"aa.xyz\":                   true,\n\t\t\"google.asn.au\":            true,\n\t\t\"google.com.au\":            true,\n\t\t\"google.net.au\":            true,\n\t\t\"google.priv.at\":           true,\n\t\t\"google.ac.at\":             true,\n\t\t\"google.gv.at\":             true,\n\t\t\"google.avocat.fr\":         true,\n\t\t\"google.geek.nz\":           true,\n\t\t\"google.gen.nz\":            true,\n\t\t\"google.kiwi.nz\":           true,\n\t\t\"google.org.il\":            true,\n\t\t\"google.net.il\":            true,\n\t\t\"www.google.edu.au\":        true,\n\t\t\"www.google.gov.au\":        true,\n\t\t\"www.google.csiro.au\":      true,\n\t\t\"www.google.act.au\":        true,\n\t\t\"www.google.avocat.fr\":     true,\n\t\t\"www.google.aeroport.fr\":   true,\n\t\t\"www.google.co.nz\":         true,\n\t\t\"www.google.geek.nz\":       true,\n\t\t\"www.google.gen.nz\":        true,\n\t\t\"www.google.kiwi.nz\":       true,\n\t\t\"www.google.parliament.nz\": true,\n\t\t\"www.google.muni.il\":       true,\n\t\t\"www.google.idf.il\":        true,\n\t}\n\n\ttests := []Expect{}\n\n\tfor domain, expected := range test_domains {\n\t\ttests = append(tests, Expect{input: domain, expectedResult: expected, errorMessage: fmt.Sprintf(\"invalid (%s) domain\", domain)})\n\t}\n\n\tfor _, domain := range []revel.Domain{{}, revel.ValidDomain()} {\n\t\tperformTests(domain, tests, t)\n\t}\n}\n\nfunc TestURL(t *testing.T) {\n\ttest_urls := map[string]bool{\n\t\t\"https://www.google.co.kr/url?sa=t&rct=j&q=&esrc=s&source=web\":                                                         true,\n\t\t\"http://stackoverflow.com/questions/27812164/can-i-import-3rd-party-package-into-golang-playground\":                    true,\n\t\t\"https://tour.golang.org/welcome/4\":                                                                                    true,\n\t\t\"https://revel.github.io/\":                                                                                             true,\n\t\t\"https://github.com/revel/revel/commit/bd1d083ee4345e919b3bca1e4c42ca682525e395#diff-972a2b2141d27e9d7a8a4149a7e28eef\": true,\n\t\t\"https://github.com/ndevilla/iniparser/pull/82#issuecomment-261817064\":                                                 true,\n\t\t\"http://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=0&rsv_idx=1&tn=baidu&wd=golang\":                                            true,\n\t\t\"http://www.baidu.com/link?url=DrWkM_beo2M5kB5sLYnItKSQ0Ib3oDhKcPprdtLzAWNfFt_VN5oyD3KwnAKT6Xsk\":                       true,\n\t}\n\n\ttests := []Expect{}\n\n\tfor url, expected := range test_urls {\n\t\ttests = append(tests, Expect{input: url, expectedResult: expected, errorMessage: fmt.Sprintf(\"invalid (%s) url\", url)})\n\t}\n\n\tfor _, url := range []revel.URL{{}, revel.ValidURL()} {\n\t\tperformTests(url, tests, t)\n\t}\n}\n\nfunc TestPureTextNormal(t *testing.T) {\n\ttest_txts := map[string]bool{\n\t\t`<script ?>qwdpijqwd</script>qd08j123lneqw\\t\\nqwedojiqwd\\rqwdoihjqwd1d[08jaedl;jkqwd\\r\\nqdolijqdwqwd`:       false,\n\t\t`a\\r\\nb<script ?>qwdpijqwd</script>qd08j123lneqw\\t\\nqwedojiqwd\\rqwdoihjqwd1d[08jaedl;jkqwd\\r\\nqdolijqdwqwd`: false,\n\t\t`Foo<script type=\"text/javascript\">alert(1337)</script>Bar`:                                                 false,\n\t\t`Foo<12>Bar`:              true,\n\t\t`Foo<>Bar`:                true,\n\t\t`Foo</br>Bar`:             false,\n\t\t`Foo <!-- Bar --> Baz`:    false,\n\t\t`I <3 Ponies!`:            true,\n\t\t`I &#32; like Golang\\t\\n`: true,\n\t\t`I &amp; like Golang\\t\\n`: true,\n\t\t`<?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"> <log4j:configuration debug=\"true\" xmlns:log4j='http://jakarta.apache.org/log4j/'> <appender name=\"console\" class=\"org.apache.log4j.ConsoleAppender\"> <layout class=\"org.apache.log4j.PatternLayout\"> <param name=\"ConversionPattern\" value=\"%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\" /> </layout> </appender> <root> <level value=\"DEBUG\" /> <appender-ref ref=\"console\" /> </root> </log4j:configuration>`: false,\n\t\t`I like Golang\\r\\n`:       true,\n\t\t`I like Golang\\r\\na`:      true,\n\t\t\"I &#32; like Golang\\t\\n\": true,\n\t\t\"I &amp; like Golang\\t\\n\": true,\n\t\t`ハイレゾ対応ウォークマン®、ヘッドホン、スピーカー「Winter Gift Collection ～Presented by JUJU～」をソニーストアにて販売開始`: true,\n\t\t`VAIOパーソナルコンピューター type T TZシリーズ 無償点検・修理のお知らせとお詫び（2009年10月15日更新）`:                     true,\n\t\t`把百度设为主页关于百度About  Baidu百度推广`: true,\n\t\t`%E6%8A%8A%E7%99%BE%E5%BA%A6%E8%AE%BE%E4%B8%BA%E4%B8%BB%E9%A1%B5%E5%85%B3%E4%BA%8E%E7%99%BE%E5%BA%A6About++Baidu%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF`:     true,\n\t\t`%E6%8A%8A%E7%99%BE%E5%BA%A6%E8%AE%BE%E4%B8%BA%E4%B8%BB%E9%A1%B5%E5%85%B3%E4%BA%8E%E7%99%BE%E5%BA%A6About%20%20Baidu%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF`: true,\n\t\t`abcd/>qwdqwdoijhwer/>qwdojiqwdqwd</>qwdoijqwdoiqjd`:                                   true,\n\t\t`abcd/>qwdqwdoijhwer/>qwdojiqwdqwd</a>qwdoijqwdoiqjd`:                                  false,\n\t\t`<img src=\"Bar\" onerror=\"alert(123)\" />`:                                               false,\n\t\t`<img src=\"javascript:alert('abc')\">`:                                                  false,\n\t\t`&#x3C;img src=&#x22;javascript:alert(&#x27;abc&#x27;)&#x22;&#x3E;`:                    false,\n\t\t`&#x3C;a href=&#x22;javascript:alert(&#x27;hello&#x27;);&#x22;&#x3E;AAA&#x3C;/a&#x3E;`: false,\n\t}\n\n\ttests := []Expect{}\n\n\tfor txt, expected := range test_txts {\n\t\ttests = append(tests, Expect{input: txt, expectedResult: expected, errorMessage: fmt.Sprintf(\"invalid (%#v) text\", txt)})\n\t}\n\n\t// normal\n\tfor _, txt := range []revel.PureText{{revel.NORMAL}, revel.ValidPureText(revel.NORMAL)} {\n\t\tperformTests(txt, tests, t)\n\t}\n}\n\nfunc TestPureTextStrict(t *testing.T) {\n\ttest_txts := map[string]bool{\n\t\t`<script ?>qwdpijqwd</script>qd08j123lneqw\\t\\nqwedojiqwd\\rqwdoihjqwd1d[08jaedl;jkqwd\\r\\nqdolijqdwqwd`:       false,\n\t\t`a\\r\\nb<script ?>qwdpijqwd</script>qd08j123lneqw\\t\\nqwedojiqwd\\rqwdoihjqwd1d[08jaedl;jkqwd\\r\\nqdolijqdwqwd`: false,\n\t\t`Foo<script type=\"text/javascript\">alert(1337)</script>Bar`:                                                 false,\n\t\t`Foo<12>Bar`:              false,\n\t\t`Foo<>Bar`:                true,\n\t\t`Foo</br>Bar`:             false,\n\t\t`Foo <!-- Bar --> Baz`:    false,\n\t\t`I <3 Ponies!`:            true,\n\t\t`I &#32; like Golang\\t\\n`: false,\n\t\t`I &amp; like Golang\\t\\n`: false,\n\t\t`<?xml version=\"1.0\" encoding=\"UTF-8\" ?> <!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"> <log4j:configuration debug=\"true\" xmlns:log4j='http://jakarta.apache.org/log4j/'> <appender name=\"console\" class=\"org.apache.log4j.ConsoleAppender\"> <layout class=\"org.apache.log4j.PatternLayout\"> <param name=\"ConversionPattern\" value=\"%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\" /> </layout> </appender> <root> <level value=\"DEBUG\" /> <appender-ref ref=\"console\" /> </root> </log4j:configuration>`: false,\n\t\t`I like Golang\\r\\n`:       true,\n\t\t`I like Golang\\r\\na`:      true,\n\t\t\"I &#32; like Golang\\t\\n\": false,\n\t\t\"I &amp; like Golang\\t\\n\": false,\n\t\t`ハイレゾ対応ウォークマン®、ヘッドホン、スピーカー「Winter Gift Collection ～Presented by JUJU～」をソニーストアにて販売開始`: true,\n\t\t`VAIOパーソナルコンピューター type T TZシリーズ 無償点検・修理のお知らせとお詫び（2009年10月15日更新）`:                     true,\n\t\t`把百度设为主页关于百度About  Baidu百度推广`: true,\n\t\t`%E6%8A%8A%E7%99%BE%E5%BA%A6%E8%AE%BE%E4%B8%BA%E4%B8%BB%E9%A1%B5%E5%85%B3%E4%BA%8E%E7%99%BE%E5%BA%A6About++Baidu%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF`:     true,\n\t\t`%E6%8A%8A%E7%99%BE%E5%BA%A6%E8%AE%BE%E4%B8%BA%E4%B8%BB%E9%A1%B5%E5%85%B3%E4%BA%8E%E7%99%BE%E5%BA%A6About%20%20Baidu%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF`: true,\n\t\t`abcd/>qwdqwdoijhwer/>qwdojiqwdqwd</>qwdoijqwdoiqjd`:                                   false,\n\t\t`abcd/>qwdqwdoijhwer/>qwdojiqwdqwd</a>qwdoijqwdoiqjd`:                                  false,\n\t\t`<img src=\"Bar\" onerror=\"alert(123)\" />`:                                               false,\n\t\t`<img src=\"javascript:alert('abc')\">`:                                                  false,\n\t\t`&#x3C;img src=&#x22;javascript:alert(&#x27;abc&#x27;)&#x22;&#x3E;`:                    false,\n\t\t`&#x3C;a href=&#x22;javascript:alert(&#x27;hello&#x27;);&#x22;&#x3E;AAA&#x3C;/a&#x3E;`: false,\n\t}\n\n\ttests := []Expect{}\n\n\tfor txt, expected := range test_txts {\n\t\ttests = append(tests, Expect{input: txt, expectedResult: expected, errorMessage: fmt.Sprintf(\"invalid (%#v) text\", txt)})\n\t}\n\n\t// strict\n\tfor _, txt := range []revel.PureText{{revel.STRICT}, revel.ValidPureText(revel.STRICT)} {\n\t\tperformTests(txt, tests, t)\n\t}\n}\n\nfunc TestFilePathOnlyFilePath(t *testing.T) {\n\ttest_filepaths := map[string]bool{\n\t\t\"../../qwdqwdqwd/../qwdqwdqwd.txt\": false,\n\t\t`../../qwdqwdqwd/..\n\t\t\t\t        /qwdqwdqwd.txt`: false,\n\t\t\"\\t../../qwdqwdqwd/../qwdqwdqwd.txt\": false,\n\t\t`\u0016../../qwdqwdqwd/../qwdqwdqwd.txt`: false,\n\t\t`../../qwdqwdqwd/..\u0002/qwdqwdqwd.txt`: false,\n\t\t\"../../etc/passwd\":                         false,\n\t\t\"a.txt;rm -rf /\":                           false,\n\t\t\"sudo rm -rf ../\":                          false,\n\t\t\"a-1-s-d-v-we-wd_+qwd-qwd-qwd.txt\":         false,\n\t\t\"a-qwdqwd_qwdqwdqwd-123.txt\":               true,\n\t\t\"a.txt\":                                    true,\n\t\t\"a-1-e-r-t-_1_21234_d_1234_qwed_1423_.txt\": true,\n\t}\n\n\ttests := []Expect{}\n\n\tfor filepath, expected := range test_filepaths {\n\t\ttests = append(tests, Expect{input: filepath, expectedResult: expected, errorMessage: fmt.Sprintf(\"unsanitary (%#v) string\", filepath)})\n\t}\n\n\t// filename without relative path\n\tfor _, filepath := range []revel.FilePath{{revel.ONLY_FILENAME}, revel.ValidFilePath(revel.ONLY_FILENAME)} {\n\t\tperformTests(filepath, tests, t)\n\t}\n}\n\nfunc TestFilePathAllowRelativePath(t *testing.T) {\n\ttest_filepaths := map[string]bool{\n\t\t\"../../qwdqwdqwd/../qwdqwdqwd.txt\": true,\n\t\t`../../qwdqwdqwd/..\n\t\t\t\t        /qwdqwdqwd.txt`: false,\n\t\t\"\\t../../qwdqwdqwd/../qwdqwdqwd.txt\": false,\n\t\t`\u0016../../qwdqwdqwd/../qwdqwdqwd.txt`: false,\n\t\t`../../qwdqwdqwd/..\u0002/qwdqwdqwd.txt`: false,\n\t\t\"../../etc/passwd\":                         true,\n\t\t\"a.txt;rm -rf /\":                           false,\n\t\t\"sudo rm -rf ../\":                          true,\n\t\t\"a-1-s-d-v-we-wd_+qwd-qwd-qwd.txt\":         false,\n\t\t\"a-qwdqwd_qwdqwdqwd-123.txt\":               true,\n\t\t\"a.txt\":                                    true,\n\t\t\"a-1-e-r-t-_1_21234_d_1234_qwed_1423_.txt\": true,\n\t\t\"/asdasd/asdasdasd/qwdqwd_qwdqwd/12-12/a-1-e-r-t-_1_21234_d_1234_qwed_1423_.txt\": true,\n\t}\n\n\ttests := []Expect{}\n\n\tfor filepath, expected := range test_filepaths {\n\t\ttests = append(tests, Expect{input: filepath, expectedResult: expected, errorMessage: fmt.Sprintf(\"unsanitary (%#v) string\", filepath)})\n\t}\n\n\t// filename with relative path\n\tfor _, filepath := range []revel.FilePath{{revel.ALLOW_RELATIVE_PATH}, revel.ValidFilePath(revel.ALLOW_RELATIVE_PATH)} {\n\t\tperformTests(filepath, tests, t)\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.4267578125,
          "content": "// Copyright (c) 2012-2018 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nconst (\n\t// Version current Revel version.\n\tVersion = \"1.1.0\"\n\n\t// BuildDate latest commit/release date.\n\tBuildDate = \"2022-04-11\"\n\n\t// MinimumGoVersion minimum required Go version for Revel.\n\tMinimumGoVersion = \">= go1.17\"\n)\n"
        },
        {
          "name": "watcher.go",
          "type": "blob",
          "size": 8.458984375,
          "content": "// Copyright (c) 2012-2016 The Revel Framework Authors, All rights reserved.\n// Revel Framework source code and usage is governed by a MIT style\n// license that can be found in the LICENSE file.\n\npackage revel\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\n// Listener is an interface for receivers of filesystem events.\ntype Listener interface {\n\t// Refresh is invoked by the watcher on relevant filesystem events.\n\t// If the listener returns an error, it is served to the user on the current request.\n\tRefresh() *Error\n}\n\n// DiscerningListener allows the receiver to selectively watch files.\ntype DiscerningListener interface {\n\tListener\n\tWatchDir(info os.FileInfo) bool\n\tWatchFile(basename string) bool\n}\n\n// Watcher allows listeners to register to be notified of changes under a given\n// directory.\ntype Watcher struct {\n\tserial              bool                // true to process events in serial\n\twatchers            []*fsnotify.Watcher // Parallel arrays of watcher/listener pairs.\n\tlisteners           []Listener          // List of listeners for watcher\n\tforceRefresh        bool                // True to force the refresh\n\tlastError           int                 // The last error found\n\tnotifyMutex         sync.Mutex          // The mutext to serialize watches\n\trefreshTimer        *time.Timer         // The timer to countdown the next refresh\n\ttimerMutex          *sync.Mutex         // A mutex to prevent concurrent updates\n\trefreshChannel      chan *Error         // The error channel to listen to when waiting for a refresh\n\trefreshChannelCount int                 // The number of clients listening on the channel\n\trefreshTimerMS      time.Duration       // The number of milliseconds between refreshing builds\n}\n\nfunc NewWatcher() *Watcher {\n\treturn &Watcher{\n\t\tforceRefresh:        true,\n\t\tlastError:           -1,\n\t\trefreshTimerMS:      time.Duration(Config.IntDefault(\"watch.rebuild.delay\", 10)),\n\t\ttimerMutex:          &sync.Mutex{},\n\t\trefreshChannel:      make(chan *Error, 10),\n\t\trefreshChannelCount: 0,\n\t}\n}\n\n// Listen registers for events within the given root directories (recursively).\nfunc (w *Watcher) Listen(listener Listener, roots ...string) {\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tutilLog.Fatal(\"Watcher: Failed to create watcher\", \"error\", err)\n\t}\n\n\t// Replace the unbuffered Event channel with a buffered one.\n\t// Otherwise multiple change events only come out one at a time, across\n\t// multiple page views.  (There appears no way to \"pump\" the events out of\n\t// the watcher)\n\t// This causes a notification when you do a check in go, since you are modifying a buffer in use\n\twatcher.Events = make(chan fsnotify.Event, 100)\n\twatcher.Errors = make(chan error, 10)\n\n\t// Walk through all files / directories under the root, adding each to watcher.\n\tfor _, p := range roots {\n\t\t// is the directory / file a symlink?\n\t\tf, err := os.Lstat(p)\n\t\tif err == nil && f.Mode()&os.ModeSymlink == os.ModeSymlink {\n\t\t\tvar realPath string\n\t\t\trealPath, err = filepath.EvalSymlinks(p)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tp = realPath\n\t\t}\n\n\t\tfi, err := os.Stat(p)\n\t\tif err != nil {\n\t\t\tutilLog.Error(\"Watcher: Failed to stat watched path, code will continue but auto updates will not work\", \"path\", p, \"error\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// If it is a file, watch that specific file.\n\t\tif !fi.IsDir() {\n\t\t\terr = watcher.Add(p)\n\t\t\tif err != nil {\n\t\t\t\tutilLog.Error(\"Watcher: Failed to watch, code will continue but auto updates will not work\", \"path\", p, \"error\", err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tvar watcherWalker func(path string, info os.FileInfo, err error) error\n\n\t\twatcherWalker = func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\tutilLog.Error(\"Watcher: Error walking path:\", \"error\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif info.IsDir() {\n\t\t\t\tif dl, ok := listener.(DiscerningListener); ok {\n\t\t\t\t\tif !dl.WatchDir(info) {\n\t\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\terr := watcher.Add(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\tutilLog.Error(\"Watcher: Failed to watch this path, code will continue but auto updates will not work\", \"path\", path, \"error\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\t// Else, walk the directory tree.\n\t\terr = Walk(p, watcherWalker)\n\t\tif err != nil {\n\t\t\tutilLog.Error(\"Watcher: Failed to walk directory, code will continue but auto updates will not work\", \"path\", p, \"error\", err)\n\t\t}\n\t}\n\n\tif w.eagerRebuildEnabled() {\n\t\t// Create goroutine to notify file changes in real time\n\t\tgo w.NotifyWhenUpdated(listener, watcher)\n\t}\n\n\tw.watchers = append(w.watchers, watcher)\n\tw.listeners = append(w.listeners, listener)\n}\n\n// NotifyWhenUpdated notifies the watcher when a file event is received.\nfunc (w *Watcher) NotifyWhenUpdated(listener Listener, watcher *fsnotify.Watcher) {\n\tfor {\n\t\tselect {\n\t\tcase ev := <-watcher.Events:\n\t\t\tif w.rebuildRequired(ev, listener) {\n\t\t\t\t// Serialize listener.Refresh() calls.\n\t\t\t\tif w.serial {\n\t\t\t\t\t// Serialize listener.Refresh() calls.\n\t\t\t\t\tw.notifyMutex.Lock()\n\n\t\t\t\t\tif err := listener.Refresh(); err != nil {\n\t\t\t\t\t\tutilLog.Error(\"Watcher: Listener refresh reported error:\", \"error\", err)\n\t\t\t\t\t}\n\t\t\t\t\tw.notifyMutex.Unlock()\n\t\t\t\t} else {\n\t\t\t\t\t// Run refresh in parallel\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tw.notifyInProcess(listener)\n\t\t\t\t\t}()\n\t\t\t\t}\n\t\t\t}\n\t\tcase <-watcher.Errors:\n\t\t\tcontinue\n\t\t}\n\t}\n}\n\n// Notify causes the watcher to forward any change events to listeners.\n// It returns the first (if any) error returned.\nfunc (w *Watcher) Notify() *Error {\n\t// Serialize Notify() calls.\n\tw.notifyMutex.Lock()\n\tdefer w.notifyMutex.Unlock()\n\n\tfor i, watcher := range w.watchers {\n\t\tlistener := w.listeners[i]\n\n\t\t// Pull all pending events / errors from the watcher.\n\t\trefresh := false\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase ev := <-watcher.Events:\n\t\t\t\tif w.rebuildRequired(ev, listener) {\n\t\t\t\t\trefresh = true\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\tcase <-watcher.Errors:\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\t// No events left to pull\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif w.forceRefresh || refresh || w.lastError == i {\n\t\t\tvar err *Error\n\t\t\tif w.serial {\n\t\t\t\terr = listener.Refresh()\n\t\t\t} else {\n\t\t\t\terr = w.notifyInProcess(listener)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\tw.lastError = i\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tw.forceRefresh = false\n\tw.lastError = -1\n\treturn nil\n}\n\n// Build a queue for refresh notifications\n// this will not return until one of the queue completes.\nfunc (w *Watcher) notifyInProcess(listener Listener) (err *Error) {\n\tshouldReturn := false\n\t// This code block ensures that either a timer is created\n\t// or that a process would be added the the h.refreshChannel\n\tfunc() {\n\t\tw.timerMutex.Lock()\n\t\tdefer w.timerMutex.Unlock()\n\t\t// If we are in the process of a rebuild, forceRefresh will always be true\n\t\tw.forceRefresh = true\n\t\tif w.refreshTimer != nil {\n\t\t\tutilLog.Info(\"Found existing timer running, resetting\")\n\t\t\tw.refreshTimer.Reset(time.Millisecond * w.refreshTimerMS)\n\t\t\tshouldReturn = true\n\t\t\tw.refreshChannelCount++\n\t\t} else {\n\t\t\tw.refreshTimer = time.NewTimer(time.Millisecond * w.refreshTimerMS)\n\t\t}\n\t}()\n\n\t// If another process is already waiting for the timer this one\n\t// only needs to return the output from the channel\n\tif shouldReturn {\n\t\treturn <-w.refreshChannel\n\t}\n\tutilLog.Info(\"Waiting for refresh timer to expire\")\n\t<-w.refreshTimer.C\n\tw.timerMutex.Lock()\n\n\t// Ensure the queue is properly dispatched even if a panic occurs\n\tdefer func() {\n\t\tfor x := 0; x < w.refreshChannelCount; x++ {\n\t\t\tw.refreshChannel <- err\n\t\t}\n\t\tw.refreshChannelCount = 0\n\t\tw.refreshTimer = nil\n\t\tw.timerMutex.Unlock()\n\t}()\n\n\terr = listener.Refresh()\n\tif err != nil {\n\t\tutilLog.Info(\"Watcher: Recording error last build, setting rebuild on\", \"error\", err)\n\t} else {\n\t\tw.lastError = -1\n\t\tw.forceRefresh = false\n\t}\n\tutilLog.Info(\"Rebuilt, result\", \"error\", err)\n\treturn\n}\n\n// If watch.mode is set to eager, the application is rebuilt immediately\n// when a source file is changed.\n// This feature is available only in dev mode.\nfunc (w *Watcher) eagerRebuildEnabled() bool {\n\treturn Config.BoolDefault(\"mode.dev\", true) &&\n\t\tConfig.BoolDefault(\"watch\", true) &&\n\t\tConfig.StringDefault(\"watch.mode\", \"normal\") == \"eager\"\n}\n\nfunc (w *Watcher) rebuildRequired(ev fsnotify.Event, listener Listener) bool {\n\t// Ignore changes to dotfiles.\n\tif strings.HasPrefix(filepath.Base(ev.Name), \".\") {\n\t\treturn false\n\t}\n\n\tif dl, ok := listener.(DiscerningListener); ok {\n\t\tif !dl.WatchFile(ev.Name) || ev.Op&fsnotify.Chmod == fsnotify.Chmod {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nvar WatchFilter = func(c *Controller, fc []Filter) {\n\tif MainWatcher != nil {\n\t\terr := MainWatcher.Notify()\n\t\tif err != nil {\n\t\t\tc.Result = c.RenderError(err)\n\t\t\treturn\n\t\t}\n\t}\n\tfc[0](c, fc[1:])\n}\n"
        }
      ]
    }
  ]
}