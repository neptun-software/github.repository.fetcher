{
  "metadata": {
    "timestamp": 1736568042181,
    "page": 181,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-task/task",
      "stars": 11916,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.232421875,
          "content": "# editorconfig.org\n\nroot = true\n\n[*]\ninsert_final_newline = true\ncharset = utf-8\ntrim_trailing_whitespace = true\nindent_style = tab\n\n[*.{md,mdx,yml,yaml,json,toml,htm,html,js,ts,css,svg,sh,bash,fish}]\nindent_style = space\nindent_size = 2\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0380859375,
          "content": "* text=auto\n*.mdx -linguist-detectable\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4462890625,
          "content": "# Binaries for programs and plugins\n*.exe\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Graphvis files\n*.gv\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n./task\n.task\ndist/\n\n.DS_Store\n\n# editors\n.idea/\n.vscode/settings.json\n.fleet/\n\n# exuberant ctags\ntags\n\n/bin/*\n!/bin/.keep\n/testdata/vars/v1\n/tmp\nnode_modules\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.693359375,
          "content": "# NOTE(@andreynering): The linters listed here are additions on top of\n# those enabled by default:\n#\n# https://golangci-lint.run/usage/linters/#enabled-by-default\n\nlinters:\n  enable:\n    - depguard\n    - goimports\n    - gofmt\n    - gofumpt\n    - misspell\n    - noctx\n    - paralleltest\n    - tenv\n    - thelper\n    - tparallel\n\nlinters-settings:\n  depguard:\n    rules:\n      main:\n        files:\n          - \"$all\"\n          - \"!$test\"\n          - \"!**/errors/*.go\"\n        deny:\n          - pkg: \"errors\"\n            desc: \"Use github.com/go-task/task/v3/errors instead\"\n  goimports:\n    local-prefixes: github.com/go-task\n  gofmt:\n    rewrite-rules:\n      - pattern: 'interface{}'\n        replacement: 'any'\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 3.1640625,
          "content": "# yaml-language-server: $schema=https://goreleaser.com/static/schema.json\nversion: 2\n\nbuilds:\n  - binary: task\n    main: ./cmd/task\n    goos:\n      - windows\n      - darwin\n      - linux\n      - freebsd\n    goarch:\n      - '386'\n      - amd64\n      - arm\n      - arm64\n      - riscv64\n    goarm:\n      - '6'\n    ignore:\n      - goos: darwin\n        goarch: '386'\n      - goos: darwin\n        goarch: riscv64\n      - goos: windows\n        goarch: riscv64\n    env:\n      - CGO_ENABLED=0\n    mod_timestamp: '{{ .CommitTimestamp }}'\n    flags:\n      - -trimpath\n    ldflags:\n      - -s -w # Don't set main.version.\n\ngomod:\n  proxy: true\n\narchives:\n  - name_template: \"{{.Binary}}_{{.Os}}_{{.Arch}}\"\n    files:\n      - README.md\n      - LICENSE\n      - completion/**/*\n    format_overrides:\n      - goos: windows\n        format: zip\n\nrelease:\n  draft: true\n\nsnapshot:\n  version_template: \"{{.Version}}\"\n\nchecksum:\n  name_template: \"task_checksums.txt\"\n\nnfpms:\n  - vendor: Task\n    homepage: https://taskfile.dev\n    maintainer: The Task authors <task@taskfile.dev>\n    description: Simple task runner written in Go\n    license: MIT\n    conflicts:\n      - taskwarrior\n    formats:\n      - deb\n      - rpm\n    file_name_template: \"{{.ProjectName}}_{{.Os}}_{{.Arch}}\"\n    contents:\n      - src: completion/bash/task.bash\n        dst: /etc/bash_completion.d/task\n      - src: completion/fish/task.fish\n        dst: /usr/share/fish/completions/task.fish\n      - src: completion/zsh/_task\n        dst: /usr/local/share/zsh/site-functions/_task\n\nbrews:\n  - name: go-task\n    description: Task runner / simpler Make alternative written in Go\n    license: MIT\n    homepage: https://taskfile.dev\n    directory: Formula\n    repository:\n      owner: go-task\n      name: homebrew-tap\n    test:\n      system \"#{bin}/task\", \"--help\"\n    install: |-\n      bin.install \"task\"\n      bash_completion.install \"completion/bash/task.bash\" => \"task\"\n      zsh_completion.install \"completion/zsh/_task\" => \"_task\"\n      fish_completion.install \"completion/fish/task.fish\"\n    commit_author:\n      name: task-bot\n      email: 106601941+task-bot@users.noreply.github.com\n\nwinget:\n  - name: Task\n    publisher: Task\n    short_description: A task runner / simpler Make alternative written in Go\n    description: Task is a task runner / build tool that aims to be simpler and easier to use than, for example, GNU Make.\n    license: MIT\n    homepage: https://taskfile.dev/\n    publisher_url: https://taskfile.dev/\n    publisher_support_url: https://github.com/go-task/task/issues\n    package_identifier: Task.Task\n    commit_author:\n      name: task-bot\n      email: 106601941+task-bot@users.noreply.github.com\n    commit_msg_template: \"chore: bump {{.PackageIdentifier}} to {{.Tag}}\"\n    release_notes_url: https://github.com/go-task/task/releases/tag/{{.Tag}}\n    tags:\n      - build\n      - build-tool\n      - devops\n      - go\n      - make\n      - makefile\n      - runner\n      - task\n      - task-runner\n      - taskfile\n      - tool\n    skip_upload: true\n    repository:\n      owner: microsoft\n      name: winget-pkgs\n      pull_request:\n        enabled: true\n        base:\n          owner: go-task\n          name: winget-pkgs\n          branch: \"bump-task-to-{{.Tag}}\"\n"
        },
        {
          "name": ".mockery.yaml",
          "type": "blob",
          "size": 0.0751953125,
          "content": "with-expecter: true\nkeeptree: true\ncase: underscore\noutput: ./internal/mocks\n"
        },
        {
          "name": ".nvmrc",
          "type": "blob",
          "size": 0.0078125,
          "content": "22.12.0\n"
        },
        {
          "name": ".prettierrc.yml",
          "type": "blob",
          "size": 0.1220703125,
          "content": "trailingComma: none\nsingleQuote: true\noverrides:\n  - files: \"*.md\"\n    options:\n      printWidth: 80\n      proseWrap: always\n"
        },
        {
          "name": ".vscode",
          "type": "tree",
          "content": null
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 45.330078125,
          "content": "# Changelog\n\n## Unreleased\n\n- Fixed an issue where dynamic variables were not properly logged in verbose\n  mode (#1920, #1921 by @mgbowman).\n- Support `silent` for defer statements (#1877, #1879 by @danilobuerger).\n- Added an option to exclude some tasks from being included (#1859 by\n  @vmaerten).\n- Fixed an issue where a required variable was incorrectly handled in a template\n  function (#1950, #1962 by @vmaerten).\n- Expose a new `TASK_DIR` special variable, which will contain the absolute path\n  of task directory. (#1959, #1961 by @vmaerten).\n- Fixed fatal bugs that caused concurrent map writes (#1605, #1972, #1974 by\n  @pd93, @GrahamDennis and @trim21.\n- Refactored internal ordered map implementation to use\n  [github.com/elliotchance/orderedmap](https://github.com/elliotchance/orderedmap)\n  (#1797 by @pd93).\n- Fixed a bug where variables defined at the task level were being ignored in\n  the `requires` section. (#1960, #1955, #1768 by @vmaerten and @mokeko)\n- The `CHECKSUM` and `TIMESTAMP` variables are now accessible within `cmds`\n  (#1872 by @niklasr22).\n- Updated [installation docs](https://taskfile.dev/installation) and added pip\n  installation method (#935, #1989 by @pd93).\n- Fixed a bug where dynamic variables could not access environment variables\n  (#630, #1869 by @rohm1 and @pd93).\n\n## v3.40.1 - 2024-12-06\n\n- Fixed a security issue in `git-urls` by switching to the maintained fork\n  `chainguard-dev/git-urls` (#1917 by @AlekSi).\n- Added missing `platforms` property to `cmds` that use `for` (#1915 by\n  @dkarter).\n- Added misspell linter to check for misspelled English words (#1883 by\n  @christiandins).\n\n## v3.40.0 - 2024-11-05\n\n- Fixed output of some functions (e.g. `splitArgs`/`splitLines`) not working in\n  for loops (#1822, #1823 by @stawii).\n- Added a new `TASK_OFFLINE` environment variable to configure the `--offline`\n  flag and expose it as a special variable in the templating system (#1470,\n  #1716 by @vmaerten and @pd93).\n- Fixed a bug where multiple remote includes caused all prompts to display\n  without waiting for user input (#1832, #1833 by @vmaerten and @pd93).\n- When using the\n  \"[Remote Taskfiles](https://taskfile.dev/experiments/remote-taskfiles/)\".\n  experiment, you can now include Taskfiles from Git repositories (#1652 by\n  @vmaerten).\n- Improved the error message when a dotenv file cannot be parsed (#1842 by\n  @pbitty).\n- Fix issue with directory when using the remote experiment (#1757 by @pbitty).\n- Fixed an issue where a special variable was used in combination with a dotenv\n  file (#1232, #1810 by @vmaerten).\n- Refactor the way Task reads Taskfiles to improve readability (#1771 by\n  @pbitty).\n- Added a new option to ensure variable is within the list of values (#1827 by\n  @vmaerten).\n- Allow multiple prompts to be specified for a task (#1861, #1866 by @mfbmina).\n- Added new template function: `numCPU`, which returns the number of logical\n  CPUs usable (#1890, #1887 by @Amoghrd).\n- Fixed a bug where non-nil, empty dynamic variables are returned as an empty\n  interface (#1903, #1904 by @pd93).\n\n## v3.39.2 - 2024-09-19\n\n- Fix dynamic variables not working properly for a defer: statement (#1803,\n  #1818 by @vmaerten).\n\n## v3.39.1 - 2024-09-18\n\n- Added Renovate configuration to automatically create PRs to keep dependencies\n  up to date (#1783 by @vmaerten).\n- Fixed a bug where the help was displayed twice (#1805, #1806 by @vmaerten).\n- Fixed a bug where ZSH and PowerShell completions did not work when using the\n  recommended method. (#1813, #1809 by @vmaerten and @shirayu)\n- Fix variables not working properly for a `defer:` statement (#1803, #1814 by\n  @vmaerten and @andreynering).\n\n## v3.39.0 - 2024-09-07\n\n- Added\n  [Env Precedence Experiment](https://taskfile.dev/experiments/env-precedence)\n  (#1038, #1633 by @vmaerten).\n- Added a CI lint job to ensure that the docs are updated correctly (#1719 by\n  @vmaerten).\n- Updated minimum required Go version to 1.22 (#1758 by @pd93).\n- Expose a new `EXIT_CODE` special variable on `defer:` when a command finishes\n  with a non-zero exit code (#1484, #1762 by @dorimon-1 and @andreynering).\n- Expose a new `ALIAS` special variable, which will contain the alias used to\n  call the current task. Falls back to the task name. (#1764 by @DanStory).\n- Fixed `TASK_REMOTE_DIR` environment variable not working when the path was\n  absolute. (#1715 by @vmaerten).\n- Added an option to declare an included Taskfile as flattened (#1704 by\n  @vmaerten).\n- Added a new\n  [`--completion` flag](https://taskfile.dev/installation/#setup-completions) to\n  output completion scripts for various shells (#293, #1157 by @pd93).\n  - This is now the preferred way to install completions.\n  - The completion scripts in the `completion` directory\n    [are now deprecated](https://taskfile.dev/deprecations/completion-scripts/).\n- Added the ability to\n  [loop over a matrix of values](https://taskfile.dev/usage/#looping-over-a-matrix)\n  (#1766, #1767, #1784 by @pd93).\n- Fixed a bug in fish completion where aliases were not displayed (#1781, #1782\n  by @vmaerten).\n- Fixed panic when having a flattened included Taskfile that contains a\n  `default` task (#1777, #1778 by @vmaerten).\n- Optimized file existence checks for remote Taskfiles (#1713 by @vmaerten).\n\n## v3.38.0 - 2024-06-30\n\n- Added `TASK_EXE` special variable (#1616, #1624 by @pd93 and @andreynering).\n- Some YAML parsing errors will now show in a more user friendly way (#1619 by\n  @pd93).\n- Prefixed outputs will now be colorized by default (#1572 by\n  @AlexanderArvidsson)\n- [References](https://taskfile.dev/usage/#referencing-other-variables) are now\n  generally available (no experiments required) (#1654 by @pd93).\n- Templating functions can now be used in references (#1645, #1654 by @pd93).\n- Added a new\n  [templating reference page](https://taskfile.dev/reference/templating/) to the\n  documentation (#1614, #1653 by @pd93).\n- If using the\n  [Map Variables experiment (1)](https://taskfile.dev/experiments/map-variables/?proposal=1),\n  references are available by\n  [prefixing a string with a `#`](https://taskfile.dev/experiments/map-variables/?proposal=1#references)\n  (#1654 by @pd93).\n- If using the\n  [Map Variables experiment (2)](https://taskfile.dev/experiments/map-variables/?proposal=2),\n  the `yaml` and `json` keys are no longer available (#1654 by @pd93).\n- Added a new `TASK_REMOTE_DIR` environment variable to configure where cached\n  remote Taskfiles are stored (#1661 by @vmaerten).\n- Added a new `--clear-cache` flag to clear the cache of remote Taskfiles (#1639\n  by @vmaerten).\n- Improved the readability of cached remote Taskfile filenames (#1636 by\n  @vmaerten).\n- Starting releasing a binary for the `riscv64` architecture on Linux (#1699 by\n  @mengzhuo).\n- Added `CLI_SILENT` and `CLI_VERBOSE` variables (#1480, #1669 by @Vince-Smith).\n- Fixed a couple of bugs with the `prompt:` feature (#1657 by @pd93).\n- Fixed JSON Schema to disallow invalid properties (#1657 by @pd93).\n- Fixed version checks not working as intended (#872, #1663 by @vmaerten).\n- Fixed a bug where included tasks were run multiple times even if `run: once`\n  was set (#852, #1655 by @pd93).\n- Fixed some bugs related to column formatting in the terminal (#1350, #1637,\n  #1656 by @vmaerten).\n\n## v3.37.2 - 2024-05-12\n\n- Fixed a bug where an empty Taskfile would cause a panic (#1648 by @pd93).\n- Fixed a bug where includes Taskfile variable were not being merged correctly\n  (#1643, #1649 by @pd93).\n\n## v3.37.1 - 2024-05-09\n\n- Fix bug where non-string values (numbers, bools) added to `env:` weren't been\n  correctly exported (#1640, #1641 by @vmaerten and @andreynering).\n\n## v3.37.0 - 2024-05-08\n\n- Released the\n  [Any Variables experiment](https://taskfile.dev/blog/any-variables), but\n  [_without support for maps_](https://github.com/go-task/task/issues/1415#issuecomment-2044756925)\n  (#1415, #1547 by @pd93).\n- Refactored how Task reads, parses and merges Taskfiles using a DAG (#1563,\n  #1607 by @pd93).\n- Fix a bug which stopped tasks from using `stdin` as input (#1593, #1623 by\n  @pd93).\n- Fix error when a file or directory in the project contained a special char\n  like `&`, `(` or `)` (#1551, #1584 by @andreynering).\n- Added alias `q` for template function `shellQuote` (#1601, #1603 by @vergenzt)\n- Added support for `~` on ZSH completions (#1613 by @jwater7).\n- Added the ability to pass variables by reference using Go template syntax when\n  the\n  [Map Variables experiment](https://taskfile.dev/experiments/map-variables/) is\n  enabled (#1612 by @pd93).\n- Added support for environment variables in the templating engine in `includes`\n  (#1610 by @vmaerten).\n\n## v3.36.0 - 2024-04-08\n\n- Added support for\n  [looping over dependencies](https://taskfile.dev/usage/#looping-over-dependencies)\n  (#1299, #1541 by @pd93).\n- When using the\n  \"[Remote Taskfiles](https://taskfile.dev/experiments/remote-taskfiles/)\"\n  experiment, you are now able to use\n  [remote Taskfiles as your entrypoint](https://taskfile.dev/experiments/remote-taskfiles/#root-remote-taskfiles).\n  - `includes` in remote Taskfiles will now also resolve correctly (#1347 by\n    @pd93).\n- When using the\n  \"[Any Variables](https://taskfile.dev/experiments/any-variables/)\"\n  experiments, templating is now supported in collection-type variables (#1477,\n  #1511, #1526 by @pd93).\n- Fixed a bug where variables being passed to an included Taskfile were not\n  available when defining global variables (#1503, #1533 by @pd93).\n- Improved support to customized colors by allowing 8-bit colors and multiple\n  ANSI attributes (#1576 by @pd93).\n\n## v3.35.1 - 2024-03-04\n\n- Fixed a bug where the `TASKFILE_DIR` variable was sometimes incorrect (#1522,\n  #1523 by @pd93).\n- Added a new `TASKFILE` special variable that holds the root Taskfile path\n  (#1523 by @pd93).\n- Fixed various issues related to running a Taskfile from a subdirectory (#1529,\n  #1530 by @pd93).\n\n## v3.35.0 - 2024-02-28\n\n- Added support for\n  [wildcards in task names](https://taskfile.dev/usage/#wildcard-arguments)\n  (#836, #1489 by @pd93).\n- Added the ability to\n  [run Taskfiles via stdin](https://taskfile.dev/usage/#reading-a-taskfile-from-stdin)\n  (#655, #1483 by @pd93).\n- Bumped minimum Go version to 1.21 (#1500 by @pd93).\n- Fixed bug related to the `--list` flag (#1509, #1512 by @pd93, #1514, #1520 by\n  @pd93).\n- Add mention on the documentation to the fact that the variable declaration\n  order is respected (#1510 by @kirkrodrigues).\n- Improved style guide docs (#1495 by @iwittkau).\n- Removed duplicated entry for `requires` on the API docs (#1491 by\n  @teatimeguest).\n\n## v3.34.1 - 2024-01-27\n\n- Fixed prompt regression on\n  [Remote Taskfiles experiment](https://taskfile.dev/experiments/remote-taskfiles/)\n  (#1486, #1487 by @pd93).\n\n## v3.34.0 - 2024-01-25\n\n- Removed support for `version: 2` schemas. See the\n  [deprecation notice on our website](https://taskfile.dev/deprecations/version-2-schema)\n  (#1197, #1447 by @pd93).\n- Fixed a couple of issues in the JSON Schema + added a CI step to ensure it's\n  correct (#1471, #1474, #1476 by @sirosen).\n- Added\n  [Any Variables experiment proposal 2](https://taskfile.dev/experiments/any-variables/?proposal=2)\n  (#1415, #1444 by @pd93).\n- Updated the experiments and deprecations documentation format (#1445 by\n  @pd93).\n- Added new template function: `spew`, which can be used to print variables for\n  debugging purposes (#1452 by @pd93).\n- Added new template function: `merge`, which can be used to merge any number of\n  map variables (#1438, #1464 by @pd93).\n- Small change on the API when using as a library: `call.Direct` became\n  `call.Indirect` (#1459 by @pd93).\n- Refactored the public `read` and `taskfile` packages and introduced\n  `taskfile/ast` (#1450 by @pd93).\n- `ast.IncludedTaskfiles` renamed to `ast.Includes` and `orderedmap` package\n  renamed to `omap` plus some internal refactor work (#1456 by @pd93).\n- Fix zsh completion script to allow lowercase `taskfile` file names (#1482 by\n  @xontab).\n- Improvements on how we check the Taskfile version (#1465 by @pd93).\n- Added a new `ROOT_TASKFILE` special variable (#1468, #1469 by @pd93).\n- Fix experiment flags in `.env` when the `--dir` or `--taskfile` flags were\n  used (#1478 by @pd93).\n\n## v3.33.1 - 2023-12-21\n\n- Added support for looping over map variables with the\n  [Any Variables experiment](https://taskfile.dev/experiments/any-variables)\n  enabled (#1435, #1437 by @pd93).\n- Fixed a bug where dynamic variables were causing errors during fast\n  compilation (#1435, #1437 by @pd93)\n\n## v3.33.0 - 2023-12-20\n\n- Added\n  [Any Variables experiment](https://taskfile.dev/experiments/any-variables)\n  (#1415, #1421 by @pd93).\n- Updated Docusaurus to v3 (#1432 by @pd93).\n- Added `aliases` to `--json` flag output (#1430, #1431 by @pd93).\n- Added new `CLI_FORCE` special variable containing whether the `--force` or\n  `--force-all` flags were set (#1412, #1434 by @pd93).\n\n## v3.32.0 - 2023-11-29\n\n- Added ability to exclude some files from `sources:` by using `exclude:` (#225,\n  #1324 by @pd93 and @andreynering).\n- The\n  [Remote Taskfiles experiment](https://taskfile.dev/experiments/remote-taskfiles)\n  now prefers remote files over cached ones by default (#1317, #1345 by @pd93).\n- Added `--timeout` flag to the\n  [Remote Taskfiles experiment](https://taskfile.dev/experiments/remote-taskfiles)\n  (#1317, #1345 by @pd93).\n- Fix bug where dynamic `vars:` and `env:` were being executed when they should\n  actually be skipped by `platforms:` (#1273, #1377 by @andreynering).\n- Fix `schema.json` to make `silent` valid in `cmds` that use `for` (#1385,\n  #1386 by @iainvm).\n- Add new `--no-status` flag to skip expensive status checks when running\n  `task --list --json` (#1348, #1368 by @amancevice).\n\n## v3.31.0 - 2023-10-07\n\n- Enabled the `--yes` flag for the\n  [Remote Taskfiles experiment](https://taskfile.dev/experiments/remote-taskfiles)\n  (#1317, #1344 by @pd93).\n- Add ability to set `watch: true` in a task to automatically run it in watch\n  mode (#231, #1361 by @andreynering).\n- Fixed a bug on the watch mode where paths that contained `.git` (like\n  `.github`), for example, were also being ignored (#1356 by @butuzov).\n- Fixed a nil pointer error when running a Taskfile with no contents (#1341,\n  #1342 by @pd93).\n- Added a new [exit code](https://taskfile.dev/api/#exit-codes) (107) for when a\n  Taskfile does not contain a schema version (#1342 by @pd93).\n- Increased limit of maximum task calls from 100 to 1000 for now, as some people\n  have been reaching this limit organically now that we have loops. This check\n  exists to detect recursive calls, but will be removed in favor of a better\n  algorithm soon (#1321, #1332).\n- Fixed templating on descriptions on `task --list` (#1343 by @blackjid).\n- Fixed a bug where precondition errors were incorrectly being printed when task\n  execution was aborted (#1337, #1338 by @sylv-io).\n\n## v3.30.1 - 2023-09-14\n\n- Fixed a regression where some special variables weren't being set correctly\n  (#1331, #1334 by @pd93).\n\n## v3.30.0 - 2023-09-13\n\n- Prep work for Remote Taskfiles (#1316 by @pd93).\n- Added the\n  [Remote Taskfiles experiment](https://taskfile.dev/experiments/remote-taskfiles)\n  as a draft (#1152, #1317 by @pd93).\n- Improve performance of content checksumming on `sources:` by replacing md5\n  with [XXH3](https://xxhash.com/) which is much faster. This is a soft breaking\n  change because checksums will be invalidated when upgrading to this release\n  (#1325 by @ReillyBrogan).\n\n## v3.29.1 - 2023-08-26\n\n- Update to Go 1.21 (bump minimum version to 1.20) (#1302 by @pd93)\n- Fix a missing a line break on log when using `--watch` mode (#1285, #1297 by\n  @FilipSolich).\n- Fix `defer` on JSON Schema (#1288 by @calvinmclean and @andreynering).\n- Fix bug in usage of special variables like `{{.USER_WORKING_DIR}}` in\n  combination with `includes` (#1046, #1205, #1250, #1293, #1312, #1274 by\n  @andarto, #1309 by @andreynering).\n- Fix bug on `--status` flag. Running this flag should not have side-effects: it\n  should not update the checksum on `.task`, only report its status (#1305,\n  #1307 by @visciang, #1313 by @andreynering).\n\n## v3.28.0 - 2023-07-24\n\n- Added the ability to\n  [loop over commands and tasks](https://taskfile.dev/usage/#looping-over-values)\n  using `for` (#82, #1220 by @pd93).\n- Fixed variable propagation in multi-level includes (#778, #996, #1256 by\n  @hudclark).\n- Fixed a bug where the `--exit-code` code flag was not returning the correct\n  exit code when calling commands indirectly (#1266, #1270 by @pd93).\n- Fixed a `nil` panic when a dependency was commented out or left empty (#1263\n  by @neomantra).\n\n## v3.27.1 - 2023-06-30\n\n- Fix panic when a `.env` directory (not file) is present on current directory\n  (#1244, #1245 by @pd93).\n\n## v3.27.0 - 2023-06-29\n\n- Allow Taskfiles starting with lowercase characters (#947, #1221 by @pd93).\n  - e.g. `taskfile.yml`, `taskfile.yaml`, `taskfile.dist.yml` &\n    `taskfile.dist.yaml`\n- Bug fixes were made to the\n  [npm installation method](https://taskfile.dev/installation/#npm). (#1190, by\n  @sounisi5011).\n- Added the\n  [gentle force experiment](https://taskfile.dev/experiments/gentle-force) as a\n  draft (#1200, #1216 by @pd93).\n- Added an `--experiments` flag to allow you to see which experiments are\n  enabled (#1242 by @pd93).\n- Added ability to specify which variables are required in a task (#1203, #1204\n  by @benc-uk).\n\n## v3.26.0 - 2023-06-10\n\n- Only rewrite checksum files in `.task` if the checksum has changed (#1185,\n  #1194 by @deviantintegral).\n- Added [experiments documentation](https://taskfile.dev/experiments) to the\n  website (#1198 by @pd93).\n- Deprecated `version: 2` schema. This will be removed in the next major release\n  (#1197, #1198, #1199 by @pd93).\n- Added a new `prompt:` prop to set a warning prompt to be shown before running\n  a potential dangerous task (#100, #1163 by @MaxCheetham,\n  [Documentation](https://taskfile.dev/usage/#warning-prompts)).\n- Added support for single command task syntax. With this change, it's now\n  possible to declare just `cmd:` in a task, avoiding the more complex\n  `cmds: []` when you have only a single command for that task (#1130, #1131 by\n  @timdp).\n\n## v3.25.0 - 2023-05-22\n\n- Support `silent:` when calling another tasks (#680, #1142 by @danquah).\n- Improve PowerShell completion script (#1168 by @trim21).\n- Add more languages to the website menu and show translation progress\n  percentage (#1173 by @misitebao).\n- Starting on this release, official binaries for FreeBSD will be available to\n  download (#1068 by @andreynering).\n- Fix some errors being unintendedly suppressed (#1134 by @clintmod).\n- Fix a nil pointer error when `version` is omitted from a Taskfile (#1148,\n  #1149 by @pd93).\n- Fix duplicate error message when a task does not exists (#1141, #1144 by\n  @pd93).\n\n## v3.24.0 - 2023-04-15\n\n- Fix Fish shell completion for tasks with aliases (#1113 by @patricksjackson).\n- The default branch was renamed from `master` to `main` (#1049, #1048 by\n  @pd93).\n- Fix bug where \"up-to-date\" logs were not being omitted for silent tasks (#546,\n  #1107 by @danquah).\n- Add `.hg` (Mercurial) to the list of ignored directories when using `--watch`\n  (#1098 by @misery).\n- More improvements to the release tool (#1096 by @pd93).\n- Enforce [gofumpt](https://github.com/mvdan/gofumpt) linter (#1099 by @pd93)\n- Add `--sort` flag for use with `--list` and `--list-all` (#946, #1105 by\n  @pd93).\n- Task now has [custom exit codes](https://taskfile.dev/api/#exit-codes)\n  depending on the error (#1114 by @pd93).\n\n## v3.23.0 - 2023-03-26\n\nTask now has an\n[official extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=task.vscode-task)\ncontributed by @pd93! :tada: The extension is maintained in a\n[new repository](https://github.com/go-task/vscode-task) under the `go-task`\norganization. We're looking to gather feedback from the community so please give\nit a go and let us know what you think via a\n[discussion](https://github.com/go-task/vscode-task/discussions),\n[issue](https://github.com/go-task/vscode-task/issues) or on our\n[Discord](https://discord.gg/6TY36E39UK)!\n\n> **NOTE:** The extension _requires_ v3.23.0 to be installed in order to work.\n\n- The website was integrated with\n  [Crowdin](https://crowdin.com/project/taskfile) to allow the community to\n  contribute with translations! [Chinese](https://taskfile.dev/zh-Hans/) is the\n  first language available (#1057, #1058 by @misitebao).\n- Added task location data to the `--json` flag output (#1056 by @pd93)\n- Change the name of the file generated by `task --init` from `Taskfile.yaml` to\n  `Taskfile.yml` (#1062 by @misitebao).\n- Added new `splitArgs` template function\n  (`{{splitArgs \"foo bar 'foo bar baz'\"}}`) to ensure string is split as\n  arguments (#1040, #1059 by @dhanusaputra).\n- Fix the value of `{{.CHECKSUM}}` variable in status (#1076, #1080 by @pd93).\n- Fixed deep copy implementation (#1072 by @pd93)\n- Created a tool to assist with releases (#1086 by @pd93).\n\n## v3.22.0 - 2023-03-10\n\n- Add a brand new `--global` (`-g`) flag that will run a Taskfile from your\n  `$HOME` directory. This is useful to have automation that you can run from\n  anywhere in your system!\n  ([Documentation](https://taskfile.dev/usage/#running-a-global-taskfile), #1029\n  by @andreynering).\n- Add ability to set `error_only: true` on the `group` output mode. This will\n  instruct Task to only print a command output if it returned with a non-zero\n  exit code (#664, #1022 by @jaedle).\n- Fixed bug where `.task/checksum` file was sometimes not being created when\n  task also declares a `status:` (#840, #1035 by @harelwa, #1037 by @pd93).\n- Refactored and decoupled fingerprinting from the main Task executor (#1039 by\n  @pd93).\n- Fixed deadlock issue when using `run: once` (#715, #1025 by\n  @theunrepentantgeek).\n\n## v3.21.0 - 2023-02-22\n\n- Added new `TASK_VERSION` special variable (#990, #1014 by @ja1code).\n- Fixed a bug where tasks were sometimes incorrectly marked as internal (#1007\n  by @pd93).\n- Update to Go 1.20 (bump minimum version to 1.19) (#1010 by @pd93)\n- Added environment variable `FORCE_COLOR` support to force color output. Useful\n  for environments without TTY (#1003 by @automation-stack)\n\n## v3.20.0 - 2023-01-14\n\n- Improve behavior and performance of status checking when using the `timestamp`\n  mode (#976, #977 by @aminya).\n- Performance optimizations were made for large Taskfiles (#982 by @pd93).\n- Add ability to configure options for the\n  [`set`](https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html)\n  and\n  [`shopt`](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html)\n  builtins (#908, #929 by @pd93,\n  [Documentation](http://taskfile.dev/usage/#set-and-shopt)).\n- Add new `platforms:` attribute to `task` and `cmd`, so it's now possible to\n  choose in which platforms that given task or command will be run on. Possible\n  values are operating system (GOOS), architecture (GOARCH) or a combination of\n  the two. Example: `platforms: [linux]`, `platforms: [amd64]` or\n  `platforms: [linux/amd64]`. Other platforms will be skipped (#978, #980 by\n  @leaanthony).\n\n## v3.19.1 - 2022-12-31\n\n- Small bug fix: closing `Taskfile.yml` once we're done reading it (#963, #964\n  by @HeCorr).\n- Fixes a bug in v2 that caused a panic when using a `Taskfile_{{OS}}.yml` file\n  (#961, #971 by @pd93).\n- Fixed a bug where watch intervals set in the Taskfile were not being respected\n  (#969, #970 by @pd93)\n- Add `--json` flag (alias `-j`) with the intent to improve support for code\n  editors and add room to other possible integrations. This is basic for now,\n  but we plan to add more info in the near future (#936 by @davidalpert, #764).\n\n## v3.19.0 - 2022-12-05\n\n- Installation via npm now supports [pnpm](https://pnpm.io/) as well\n  ([go-task/go-npm#2](https://github.com/go-task/go-npm/issues/2),\n  [go-task/go-npm#3](https://github.com/go-task/go-npm/pull/3)).\n- It's now possible to run Taskfiles from subdirectories! A new\n  `USER_WORKING_DIR` special variable was added to add even more flexibility for\n  monorepos (#289, #920).\n- Add task-level `dotenv` support (#389, #904).\n- It's now possible to use global level variables on `includes` (#942, #943).\n- The website got a brand new\n  [translation to Chinese](https://task-zh.readthedocs.io/zh_CN/latest/) by\n  [@DeronW](https://github.com/DeronW). Thanks!\n\n## v3.18.0 - 2022-11-12\n\n- Show aliases on `task --list --silent` (`task --ls`). This means that aliases\n  will be completed by the completion scripts (#919).\n- Tasks in the root Taskfile will now be displayed first in\n  `--list`/`--list-all` output (#806, #890).\n- It's now possible to call a `default` task in an included Taskfile by using\n  just the namespace. For example: `docs:default` is now automatically aliased\n  to `docs` (#661, #815).\n\n## v3.17.0 - 2022-10-14\n\n- Add a \"Did you mean ...?\" suggestion when a task does not exits another one\n  with a similar name is found (#867, #880).\n- Now YAML parse errors will print which Taskfile failed to parse (#885, #887).\n- Add ability to set `aliases` for tasks and namespaces (#268, #340, #879).\n- Improvements to Fish shell completion (#897).\n- Added ability to set a different watch interval by setting `interval: '500ms'`\n  or using the `--interval=500ms` flag (#813, #865).\n- Add colored output to `--list`, `--list-all` and `--summary` flags (#845,\n  #874).\n- Fix unexpected behavior where `label:` was being shown instead of the task\n  name on `--list` (#603, #877).\n\n## v3.16.0 - 2022-09-29\n\n- Add `npm` as new installation method: `npm i -g @go-task/cli` (#870, #871,\n  [npm package](https://www.npmjs.com/package/@go-task/cli)).\n- Add support to marking tasks and includes as internal, which will hide them\n  from `--list` and `--list-all` (#818).\n\n## v3.15.2 - 2022-09-08\n\n- Fix error when using variable in `env:` introduced in the previous release\n  (#858, #866).\n- Fix handling of `CLI_ARGS` (`--`) in Bash completion (#863).\n- On zsh completion, add ability to replace `--list-all` with `--list` as\n  already possible on the Bash completion (#861).\n\n## v3.15.0 - 2022-09-03\n\n- Add new special variables `ROOT_DIR` and `TASKFILE_DIR`. This was a highly\n  requested feature (#215, #857,\n  [Documentation](https://taskfile.dev/api/#special-variables)).\n- Follow symlinks on `sources` (#826, #831).\n- Improvements and fixes to Bash completion (#835, #844).\n\n## v3.14.1 - 2022-08-03\n\n- Always resolve relative include paths relative to the including Taskfile\n  (#822, #823).\n- Fix ZSH and PowerShell completions to consider all tasks instead of just the\n  public ones (those with descriptions) (#803).\n\n## v3.14.0 - 2022-07-08\n\n- Add ability to override the `.task` directory location with the\n  `TASK_TEMP_DIR` environment variable.\n- Allow to override Task colors using environment variables: `TASK_COLOR_RESET`,\n  `TASK_COLOR_BLUE`, `TASK_COLOR_GREEN`, `TASK_COLOR_CYAN`, `TASK_COLOR_YELLOW`,\n  `TASK_COLOR_MAGENTA` and `TASK_COLOR_RED` (#568, #792).\n- Fixed bug when using the `output: group` mode where STDOUT and STDERR were\n  being print in separated blocks instead of in the right order (#779).\n- Starting on this release, ARM architecture binaries are been released to Snap\n  as well (#795).\n- i386 binaries won't be available anymore on Snap because Ubuntu removed the\n  support for this architecture.\n- Upgrade mvdan.cc/sh, which fixes a bug with associative arrays (#785,\n  [mvdan/sh#884](https://github.com/mvdan/sh/issues/884),\n  [mvdan/sh#893](https://github.com/mvdan/sh/pull/893)).\n\n## v3.13.0 - 2022-06-13\n\n- Added `-n` as an alias to `--dry` (#776, #777).\n- Fix behavior of interrupt (SIGINT, SIGTERM) signals. Task will now give time\n  for the processes running to do cleanup work (#458, #479, #728, #769).\n- Add new `--exit-code` (`-x`) flag that will pass-through the exit form the\n  command being ran (#755).\n\n## v3.12.1 - 2022-05-10\n\n- Fixed bug where, on Windows, variables were ending with `\\r` because we were\n  only removing the final `\\n` but not `\\r\\n` (#717).\n\n## v3.12.0 - 2022-03-31\n\n- The `--list` and `--list-all` flags can now be combined with the `--silent`\n  flag to print the task names only, without their description (#691).\n- Added support for multi-level inclusion of Taskfiles. This means that included\n  Taskfiles can also include other Taskfiles. Before this was limited to one\n  level (#390, #623, #656).\n- Add ability to specify vars when including a Taskfile.\n  [Check out the documentation](https://taskfile.dev/#/usage?id=vars-of-included-taskfiles)\n  for more information (#677).\n\n## v3.11.0 - 2022-02-19\n\n- Task now supports printing begin and end messages when using the `group`\n  output mode, useful for grouping tasks in CI systems.\n  [Check out the documentation](http://taskfile.dev/#/usage?id=output-syntax)\n  for more information (#647, #651).\n- Add `Taskfile.dist.yml` and `Taskfile.dist.yaml` to the supported file name\n  list.\n  [Check out the documentation](https://taskfile.dev/#/usage?id=supported-file-names)\n  for more information (#498, #666).\n\n## v3.10.0 - 2022-01-04\n\n- A new `--list-all` (alias `-a`) flag is now available. It's similar to the\n  exiting `--list` (`-l`) but prints all tasks, even those without a description\n  (#383, #401).\n- It's now possible to schedule cleanup commands to run once a task finishes\n  with the `defer:` keyword\n  ([Documentation](https://taskfile.dev/#/usage?id=doing-task-cleanup-with-defer),\n  #475, #626).\n- Remove long deprecated and undocumented `$` variable prefix and `^` command\n  prefix (#642, #644, #645).\n- Add support for `.yaml` extension (as an alternative to `.yml`). This was\n  requested multiple times throughout the years. Enjoy! (#183, #184, #369, #584,\n  #621).\n- Fixed error when computing a variable when the task directory do not exist yet\n  (#481, #579).\n\n## v3.9.2 - 2021-12-02\n\n- Upgrade [mvdan/sh](https://github.com/mvdan/sh) which contains a fix a for a\n  important regression on Windows (#619,\n  [mvdan/sh#768](https://github.com/mvdan/sh/issues/768),\n  [mvdan/sh#769](https://github.com/mvdan/sh/pull/769)).\n\n## v3.9.1 - 2021-11-28\n\n- Add logging in verbose mode for when a task starts and finishes (#533, #588).\n- Fix an issue with preconditions and context errors (#597, #598).\n- Quote each `{{.CLI_ARGS}}` argument to prevent one with spaces to become many\n  (#613).\n- Fix nil pointer when `cmd:` was left empty (#612, #614).\n- Upgrade [mvdan/sh](https://github.com/mvdan/sh) which contains two relevant\n  fixes:\n  - Fix quote of empty strings in `shellQuote` (#609,\n    [mvdan/sh#763](https://github.com/mvdan/sh/issues/763)).\n  - Fix issue of wrong environment variable being picked when there's another\n    very similar one (#586,\n    [mvdan/sh#745](https://github.com/mvdan/sh/pull/745)).\n- Install shell completions automatically when installing via Homebrew (#264,\n  #592,\n  [go-task/homebrew-tap#2](https://github.com/go-task/homebrew-tap/pull/2)).\n\n## v3.9.0 - 2021-10-02\n\n- A new `shellQuote` function was added to the template system\n  (`{{shellQuote \"a string\"}}`) to ensure a string is safe for use in shell\n  ([mvdan/sh#727](https://github.com/mvdan/sh/pull/727),\n  [mvdan/sh#737](https://github.com/mvdan/sh/pull/737),\n  [Documentation](https://pkg.go.dev/mvdan.cc/sh/v3@v3.4.0/syntax#Quote))\n- In this version [mvdan.cc/sh](https://github.com/mvdan/sh) was upgraded with\n  some small fixes and features\n  - The `read -p` flag is now supported (#314,\n    [mvdan/sh#551](https://github.com/mvdan/sh/issues/551),\n    [mvdan/sh#772](https://github.com/mvdan/sh/pull/722))\n  - The `pwd -P` and `pwd -L` flags are now supported (#553,\n    [mvdan/sh#724](https://github.com/mvdan/sh/issues/724),\n    [mvdan/sh#728](https://github.com/mvdan/sh/pull/728))\n  - The `$GID` environment variable is now correctly being set (#561,\n    [mvdan/sh#723](https://github.com/mvdan/sh/pull/723))\n\n## v3.8.0 - 2021-09-26\n\n- Add `interactive: true` setting to improve support for interactive CLI apps\n  (#217, #563).\n- Fix some `nil` errors (#534, #573).\n- Add ability to declare an included Taskfile as optional (#519, #552).\n- Add support for including Taskfiles in the home directory by using `~` (#539,\n  #557).\n\n## v3.7.3 - 2021-09-04\n\n- Add official support to Apple M1 (#564, #567).\n- Our [official Homebrew tap](https://github.com/go-task/homebrew-tap) will\n  support more platforms, including Apple M1\n\n## v3.7.0 - 2021-07-31\n\n- Add `run:` setting to control if tasks should run multiple times or not.\n  Available options are `always` (the default), `when_changed` (if a variable\n  modified the task) and `once` (run only once no matter what). This is a long\n  time requested feature. Enjoy! (#53, #359).\n\n## v3.6.0 - 2021-07-10\n\n- Allow using both `sources:` and `status:` in the same task (#411, #427, #477).\n- Small optimization and bug fix: don't compute variables if not needed for\n  `dotenv:` (#517).\n\n## v3.5.0 - 2021-07-04\n\n- Add support for interpolation in `dotenv:` (#433, #434, #453).\n\n## v3.4.3 - 2021-05-30\n\n- Add support for the `NO_COLOR` environment variable. (#459,\n  [fatih/color#137](https://github.com/fatih/color/pull/137)).\n- Fix bug where sources were not considering the right directory in `--watch`\n  mode (#484, #485).\n\n## v3.4.2 - 2021-04-23\n\n- On watch, report which file failed to read (#472).\n- Do not try to catch SIGKILL signal, which are not actually possible (#476).\n- Improve version reporting when building Task from source using Go Modules\n  (#462, #473).\n\n## v3.4.1 - 2021-04-17\n\n- Improve error reporting when parsing YAML: in some situations where you would\n  just see an generic error, you'll now see the actual error with more detail:\n  the YAML line the failed to parse, for example (#467).\n- A JSON Schema was published [here](https://json.schemastore.org/taskfile.json)\n  and is automatically being used by some editors like Visual Studio Code\n  (#135).\n- Print task name before the command in the log output (#398).\n\n## v3.3.0 - 2021-03-20\n\n- Add support for delegating CLI arguments to commands with `--` and a special\n  `CLI_ARGS` variable (#327).\n- Add a `--concurrency` (alias `-C`) flag, to limit the number of tasks that run\n  concurrently. This is useful for heavy workloads. (#345).\n\n## v3.2.2 - 2021-01-12\n\n- Improve performance of `--list` and `--summary` by skipping running shell\n  variables for these flags (#332).\n- Fixed a bug where an environment in a Taskfile was not always overridable by\n  the system environment (#425).\n- Fixed environment from .env files not being available as variables (#379).\n- The install script is now working for ARM platforms (#428).\n\n## v3.2.1 - 2021-01-09\n\n- Fixed some bugs and regressions regarding dynamic variables and directories\n  (#426).\n- The [slim-sprig](https://github.com/go-task/slim-sprig) package was updated\n  with the upstream [sprig](https://github.com/Masterminds/sprig).\n\n## v3.2.0 - 2021-01-07\n\n- Fix the `.task` directory being created in the task directory instead of the\n  Taskfile directory (#247).\n- Fix a bug where dynamic variables (those declared with `sh:`) were not running\n  in the task directory when the task has a custom dir or it was in an included\n  Taskfile (#384).\n- The watch feature (via the `--watch` flag) got a few different bug fixes and\n  should be more stable now (#423, #365).\n\n## v3.1.0 - 2021-01-03\n\n- Fix a bug when the checksum up-to-date resolution is used by a task with a\n  custom `label:` attribute (#412).\n- Starting from this release, we're releasing official ARMv6 and ARM64 binaries\n  for Linux (#375, #418).\n- Task now respects the order of declaration of included Taskfiles when\n  evaluating variables declaring by them (#393).\n- `set -e` is now automatically set on every command. This was done to fix an\n  issue where multiline string commands wouldn't really fail unless the sentence\n  was in the last line (#403).\n\n## v3.0.1 - 2020-12-26\n\n- Allow use as a library by moving the required packages out of the `internal`\n  directory (#358).\n- Do not error if a specified dotenv file does not exist (#378, #385).\n- Fix panic when you have empty tasks in your Taskfile (#338, #362).\n\n## v3.0.0 - 2020-08-16\n\n- On `v3`, all CLI variables will be considered global variables (#336, #341)\n- Add support to `.env` like files (#324, #356).\n- Add `label:` to task so you can override the task name in the logs (#321,\n  #337).\n- Refactor how variables work on version 3 (#311).\n- Disallow `expansions` on v3 since it has no effect.\n- `Taskvars.yml` is not automatically included anymore.\n- `Taskfile_{{OS}}.yml` is not automatically included anymore.\n- Allow interpolation on `includes`, so you can manually include a Taskfile\n  based on operation system, for example.\n- Expose `.TASK` variable in templates with the task name (#252).\n- Implement short task syntax (#194, #240).\n- Added option to make included Taskfile run commands on its own directory\n  (#260, #144)\n- Taskfiles in version 1 are not supported anymore (#237).\n- Added global `method:` option. With this option, you can set a default method\n  to all tasks in a Taskfile (#246).\n- Changed default method from `timestamp` to `checksum` (#246).\n- New magic variables are now available when using `status:`: `.TIMESTAMP` which\n  contains the greatest modification date from the files listed in `sources:`,\n  and `.CHECKSUM`, which contains a checksum of all files listed in `status:`.\n  This is useful for manual checking when using external, or even remote,\n  artifacts when using `status:` (#216).\n- We're now using [slim-sprig](https://github.com/go-task/slim-sprig) instead of\n  [sprig](https://github.com/Masterminds/sprig), which allowed a file size\n  reduction of about 22% (#219).\n- We now use some colors on Task output to better distinguish message types -\n  commands are green, errors are red, etc (#207).\n\n## v2.8.1 - 2020-05-20\n\n- Fix error code for the `--help` flag (#300, #330).\n- Print version to stdout instead of stderr (#299, #329).\n- Suppress `context` errors when using the `--watch` flag (#313, #317).\n- Support templating on description (#276, #283).\n\n## v2.8.0 - 2019-12-07\n\n- Add `--parallel` flag (alias `-p`) to run tasks given by the command line in\n  parallel (#266).\n- Fixed bug where calling the `task` CLI only informing global vars would not\n  execute the `default` task.\n- Add ability to silent all tasks by adding `silent: true` a the root of the\n  Taskfile.\n\n## v2.7.1 - 2019-11-10\n\n- Fix error being raised when `exit 0` was called (#251).\n\n## v2.7.0 - 2019-09-22\n\n- Fixed panic bug when assigning a global variable (#229, #243).\n- A task with `method: checksum` will now re-run if generated files are deleted\n  (#228, #238).\n\n## v2.6.0 - 2019-07-21\n\n- Fixed some bugs regarding minor version checks on `version:`.\n- Add `preconditions:` to task (#205).\n- Create directory informed on `dir:` if it doesn't exist (#209, #211).\n- We now have a `--taskfile` flag (alias `-t`), which can be used to run another\n  Taskfile (other than the default `Taskfile.yml`) (#221).\n- It's now possible to install Task using Homebrew on Linux\n  ([go-task/homebrew-tap#1](https://github.com/go-task/homebrew-tap/pull/1)).\n\n## v2.5.2 - 2019-05-11\n\n- Reverted YAML upgrade due issues with CRLF on Windows (#201,\n  [go-yaml/yaml#450](https://github.com/go-yaml/yaml/issues/450)).\n- Allow setting global variables through the CLI (#192).\n\n## 2.5.1 - 2019-04-27\n\n- Fixed some issues with interactive command line tools, where sometimes the\n  output were not being shown, and similar issues (#114, #190, #200).\n- Upgraded [go-yaml/yaml](https://github.com/go-yaml/yaml) from v2 to v3.\n\n## v2.5.0 - 2019-03-16\n\n- We moved from the taskfile.org domain to the new fancy taskfile.dev domain.\n  While stuff is being redirected, we strongly recommend to everyone that use\n  [this install script](https://taskfile.dev/#/installation?id=install-script)\n  to use the new taskfile.dev domain on scripts from now on.\n- Fixed to the ZSH completion (#182).\n- Add\n  [`--summary` flag along with `summary:` task attribute](https://taskfile.org/#/usage?id=display-summary-of-task)\n  (#180).\n\n## v2.4.0 - 2019-02-21\n\n- Allow calling a task of the root Taskfile from an included Taskfile by\n  prefixing it with `:` (#161, #172).\n- Add flag to override the `output` option (#173).\n- Fix bug where Task was persisting the new checksum on the disk when the Dry\n  Mode is enabled (#166).\n- Fix file timestamp issue when the file name has spaces (#176).\n- Mitigating path expanding issues on Windows (#170).\n\n## v2.3.0 - 2019-01-02\n\n- On Windows, Task can now be installed using [Scoop](https://scoop.sh/) (#152).\n- Fixed issue with file/directory globing (#153).\n- Added ability to globally set environment variables (#138, #159).\n\n## v2.2.1 - 2018-12-09\n\n- This repository now uses Go Modules (#143). We'll still keep the `vendor`\n  directory in sync for some time, though;\n- Fixing a bug when the Taskfile has no tasks but includes another Taskfile\n  (#150);\n- Fix a bug when calling another task or a dependency in an included Taskfile\n  (#151).\n\n## v2.2.0 - 2018-10-25\n\n- Added support for\n  [including other Taskfiles](https://taskfile.org/#/usage?id=including-other-taskfiles)\n  (#98)\n  - This should be considered experimental. For now, only including local files\n    is supported, but support for including remote Taskfiles is being discussed.\n    If you have any feedback, please comment on #98.\n- Task now have a dedicated documentation site: https://taskfile.org\n  - Thanks to [Docsify](https://docsify.js.org/) for making this pretty easy. To\n    check the source code, just take a look at the\n    [docs](https://github.com/go-task/task/tree/main/docs) directory of this\n    repository. Contributions to the documentation is really appreciated.\n\n## v2.1.1 - 2018-09-17\n\n- Fix suggestion to use `task --init` not being shown anymore (when a\n  `Taskfile.yml` is not found)\n- Fix error when using checksum method and no file exists for a source glob\n  (#131)\n- Fix signal handling when the `--watch` flag is given (#132)\n\n## v2.1.0 - 2018-08-19\n\n- Add a `ignore_error` option to task and command (#123)\n- Add a dry run mode (`--dry` flag) (#126)\n\n## v2.0.3 - 2018-06-24\n\n- Expand environment variables on \"dir\", \"sources\" and \"generates\" (#116)\n- Fix YAML merging syntax (#112)\n- Add ZSH completion (#111)\n- Implement new `output` option. Please check out the\n  [documentation](https://github.com/go-task/task#output-syntax)\n\n## v2.0.2 - 2018-05-01\n\n- Fix merging of YAML anchors (#112)\n\n## v2.0.1 - 2018-03-11\n\n- Fixes panic on `task --list`\n\n## v2.0.0 - 2018-03-08\n\nVersion 2.0.0 is here, with a new Taskfile format.\n\nPlease, make sure to read the\n[Taskfile versions](https://github.com/go-task/task/blob/main/TASKFILE_VERSIONS.md)\ndocument, since it describes in depth what changed for this version.\n\n- New Taskfile version 2 (#77)\n- Possibility to have global variables in the `Taskfile.yml` instead of\n  `Taskvars.yml` (#66)\n- Small improvements and fixes\n\n## v1.4.4 - 2017-11-19\n\n- Handle SIGINT and SIGTERM (#75);\n- List: print message with there's no task with description;\n- Expand home dir (\"~\" symbol) on paths (#74);\n- Add Snap as an installation method;\n- Move examples to its own repo;\n- Watch: also walk on tasks called on on \"cmds\", and not only on \"deps\";\n- Print logs to stderr instead of stdout (#68);\n- Remove deprecated `set` keyword;\n- Add checksum based status check, alternative to timestamp based.\n\n## v1.4.3 - 2017-09-07\n\n- Allow assigning variables to tasks at run time via CLI (#33)\n- Added support for multiline variables from sh (#64)\n- Fixes env: remove square braces and evaluate shell (#62)\n- Watch: change watch library and few fixes and improvements\n- When use watching, cancel and restart long running process on file change (#59\n  and #60)\n\n## v1.4.2 - 2017-07-30\n\n- Flag to set directory of execution\n- Always echo command if is verbose mode\n- Add silent mode to disable echoing of commands\n- Fixes and improvements of variables (#56)\n\n## v1.4.1 - 2017-07-15\n\n- Allow use of YAML for dynamic variables instead of $ prefix\n  - `VAR: {sh: echo Hello}` instead of `VAR: $echo Hello`\n- Add `--list` (or `-l`) flag to print existing tasks\n- OS specific Taskvars file (e.g. `Taskvars_windows.yml`, `Taskvars_linux.yml`,\n  etc)\n- Consider task up-to-date on equal timestamps (#49)\n- Allow absolute path in generates section (#48)\n- Bugfix: allow templating when calling deps (#42)\n- Fix panic for invalid task in cyclic dep detection\n- Better error output for dynamic variables in Taskvars.yml (#41)\n- Allow template evaluation in parameters\n\n## v1.4.0 - 2017-07-06\n\n- Cache dynamic variables\n- Add verbose mode (`-v` flag)\n- Support to task parameters (overriding vars) (#31) (#32)\n- Print command, also when \"set:\" is specified (#35)\n- Improve task command help text (#35)\n\n## v1.3.1 - 2017-06-14\n\n- Fix glob not working on commands (#28)\n- Add ExeExt template function\n- Add `--init` flag to create a new Taskfile\n- Add status option to prevent task from running (#27)\n- Allow interpolation on `generates` and `sources` attributes (#26)\n\n## v1.3.0 - 2017-04-24\n\n- Migrate from os/exec.Cmd to a native Go sh/bash interpreter\n  - This is a potentially breaking change if you use Windows.\n  - Now, `cmd` is not used anymore on Windows. Always use Bash-like syntax for\n    your commands, even on Windows.\n- Add \"ToSlash\" and \"FromSlash\" to template functions\n- Use functions defined on github.com/Masterminds/sprig\n- Do not redirect stdin while running variables commands\n- Using `context` and `errgroup` packages (this will make other tasks to be\n  cancelled, if one returned an error)\n\n## v1.2.0 - 2017-04-02\n\n- More tests and Travis integration\n- Watch a task (experimental)\n- Possibility to call another task\n- Fix \"=\" not being recognized in variables/environment variables\n- Tasks can now have a description, and help will print them (#10)\n- Task dependencies now run concurrently\n- Support for a default task (#16)\n\n## v1.1.0 - 2017-03-08\n\n- Support for YAML, TOML and JSON (#1)\n- Support running command in another directory (#4)\n- `--force` or `-f` flag to force execution of task even when it's up-to-date\n- Detection of cyclic dependencies (#5)\n- Support for variables (#6, #9, #14)\n- Operation System specific commands and variables (#13)\n\n## v1.0.0 - 2017-02-28\n\n- Add LICENSE file\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Andrey Nering\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.951171875,
          "content": "<div align=\"center\">\n  <a href=\"https://taskfile.dev\">\n    <img src=\"website/static/img/logo.svg\" width=\"200px\" height=\"200px\" />\n  </a>\n\n  <h1>Task</h1>\n\n  <p>\n    Task is a task runner / build tool that aims to be simpler and easier to use than, for example, <a href=\"https://www.gnu.org/software/make/\">GNU Make<a>.\n  </p>\n\n  <p>\n    <a href=\"https://taskfile.dev/installation/\">Installation</a> | <a href=\"https://taskfile.dev/usage/\">Documentation</a> | <a href=\"https://twitter.com/taskfiledev\">Twitter</a> | <a href=\"https://bsky.app/profile/taskfile.dev\">Bluesky</a> | <a href=\"https://fosstodon.org/@task\">Mastodon</a> | <a href=\"https://discord.gg/6TY36E39UK\">Discord</a>\n  </p>\n\n  <h1>Gold Sponsors</h1>\n\n  <table>\n    <tr>\n      <td align=\"center\" valign=\"middle\">\n        <a target=\"_blank\" href=\"https://devowl.io\">\n          <img src=\"/website/static/img/devowl.io.svg\" height=\"100px\" title=\"devowl.io\" />\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n"
        },
        {
          "name": "Taskfile.yml",
          "type": "blob",
          "size": 4.6669921875,
          "content": "version: '3'\n\nincludes:\n  website:\n    aliases: [w, docs, d]\n    taskfile: ./website\n    dir: ./website\n\nvars:\n  BIN: \"{{.ROOT_DIR}}/bin\"\n\nenv:\n  CGO_ENABLED: '0'\n\ntasks:\n  default:\n    cmds:\n      - task: lint\n      - task: test\n\n  install:\n    desc: Installs Task\n    aliases: [i]\n    sources:\n      - './**/*.go'\n    cmds:\n      - go install -v ./cmd/task\n\n  generate:\n    desc: Runs Mockery to create mocks\n    aliases: [gen, g]\n    deps: [install:mockery]\n    sources:\n      - \"internal/fingerprint/checker.go\"\n    generates:\n      - \"internal/mocks/*.go\"\n    cmds:\n      - \"{{.BIN}}/mockery --dir ./internal/fingerprint --name SourcesCheckable\"\n      - \"{{.BIN}}/mockery --dir ./internal/fingerprint --name StatusCheckable\"\n\n  install:mockery:\n    desc: Installs mockgen; a tool to generate mock files\n    vars:\n      MOCKERY_VERSION: v2.24.0\n    env:\n      GOBIN: \"{{.BIN}}\"\n    status:\n      - go version -m {{.BIN}}/mockery | grep github.com/vektra/mockery | grep {{.MOCKERY_VERSION}}\n    cmds:\n      - go install github.com/vektra/mockery/v2@{{.MOCKERY_VERSION}}\n\n  mod:\n    desc: Downloads and tidy Go modules\n    cmds:\n      - go mod download\n      - go mod tidy\n\n  clean:\n    desc: Cleans temp files and folders\n    aliases: [clear]\n    cmds:\n      - rm -rf dist/\n      - rm -rf tmp/\n\n  lint:\n    desc: Runs golangci-lint\n    aliases: [l]\n    sources:\n      - './**/*.go'\n      - .golangci.yml\n    cmds:\n      - golangci-lint run\n\n  lint:fix:\n    desc: Runs golangci-lint and fixes any issues\n    sources:\n      - './**/*.go'\n      - .golangci.yml\n    cmds:\n      - golangci-lint run --fix\n\n  sleepit:build:\n    desc: Builds the sleepit test helper\n    sources:\n      - ./cmd/sleepit/**/*.go\n    generates:\n      - \"{{.BIN}}/sleepit\"\n    cmds:\n      - go build -o {{.BIN}}/sleepit{{exeExt}} ./cmd/sleepit\n\n  sleepit:run:\n    desc: Builds the sleepit test helper\n    deps: [sleepit:build]\n    cmds:\n      - \"{{.BIN}}/sleepit {{.CLI_ARGS}}\"\n    silent: true\n\n  test:\n    desc: Runs test suite\n    aliases: [t]\n    deps: [install]\n    cmds:\n      - go test {{catLines .GO_PACKAGES}}\n    vars:\n      GO_PACKAGES:\n        sh: go list ./...\n\n  test:all:\n    desc: Runs test suite with signals and watch tests included\n    deps: [install, sleepit:build]\n    cmds:\n      - go test {{catLines .GO_PACKAGES}} -tags 'signals watch'\n    vars:\n      GO_PACKAGES:\n        sh: go list ./...\n\n  goreleaser:test:\n    desc: Tests release process without publishing\n    cmds:\n      - goreleaser --snapshot --clean\n\n  goreleaser:install:\n    desc: Installs goreleaser\n    cmds:\n      - go install github.com/goreleaser/goreleaser/v2@latest\n\n  release:*:\n    desc: Prepare the project for a new release\n    summary: |\n      This task will do the following:\n\n      - Update the version and date in the CHANGELOG.md file\n      - Update the version in the package.json and package-lock.json files\n      - Copy the latest docs to the \"current\" version on the website\n      - Commit the changes\n      - Create a new tag\n      - Push the commit/tag to the repository\n      - Create a GitHub release\n\n      To use the task, simply run \"task release:<version>\" where \"<version>\" is is one of:\n\n      - \"major\" - Bumps the major number\n      - \"minor\" - Bumps the minor number\n      - \"patch\" - Bumps the patch number\n      - A semver compatible version number (e.g. \"1.2.3\")\n    vars:\n      VERSION:\n        sh: \"go run ./cmd/release --version {{index .MATCH 0}}\"\n      COMPLETE_MESSAGE: |\n        Creating release with GoReleaser: https://github.com/go-task/task/actions/workflows/release.yml\n\n        Please wait for the CI to finish and then do the following:\n\n        - Copy the changelog for v{{.VERSION}} to the GitHub release\n        - Publish the package to NPM with `task npm:publish`\n        - Update and push the snapcraft manifest in https://github.com/go-task/snap/blob/main/snap/snapcraft.yaml\n    preconditions:\n      - sh: test $(git rev-parse --abbrev-ref HEAD) = \"main\"\n        msg: \"You must be on the main branch to release\"\n      - sh: \"[[ -z $(git diff --shortstat main) ]]\"\n        msg: \"You must have a clean working tree to release\"\n    prompt: \"Are you sure you want to release version {{.VERSION}}?\"\n    cmds:\n      - cmd: echo \"Releasing v{{.VERSION}}\"\n        silent: true\n      - \"go run ./cmd/release {{.VERSION}}\"\n      - \"git add --all\"\n      - \"git commit -m v{{.VERSION}}\"\n      - \"git push\"\n      - \"git tag v{{.VERSION}}\"\n      - \"git push origin tag v{{.VERSION}}\"\n      - cmd: printf \"%s\" '{{.COMPLETE_MESSAGE}}'\n        silent: true\n\n  npm:publish:\n    desc: Publish release to npm\n    cmds:\n      - npm publish --access=public\n\n  packages:\n    cmds:\n      - echo '{{.GO_PACKAGES}}'\n    vars:\n      GO_PACKAGES:\n        sh: go list ./...\n    silent: true\n"
        },
        {
          "name": "args",
          "type": "tree",
          "content": null
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "completion.go",
          "type": "blob",
          "size": 0.6591796875,
          "content": "package task\n\nimport (\n\t_ \"embed\"\n\t\"fmt\"\n)\n\n//go:embed completion/bash/task.bash\nvar completionBash string\n\n//go:embed completion/fish/task.fish\nvar completionFish string\n\n//go:embed completion/ps/task.ps1\nvar completionPowershell string\n\n//go:embed completion/zsh/_task\nvar completionZsh string\n\nfunc Completion(completion string) (string, error) {\n\t// Get the file extension for the selected shell\n\tswitch completion {\n\tcase \"bash\":\n\t\treturn completionBash, nil\n\tcase \"fish\":\n\t\treturn completionFish, nil\n\tcase \"powershell\":\n\t\treturn completionPowershell, nil\n\tcase \"zsh\":\n\t\treturn completionZsh, nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"unknown shell: %s\", completion)\n\t}\n}\n"
        },
        {
          "name": "completion",
          "type": "tree",
          "content": null
        },
        {
          "name": "concurrency.go",
          "type": "blob",
          "size": 0.42578125,
          "content": "package task\n\nfunc (e *Executor) acquireConcurrencyLimit() func() {\n\tif e.concurrencySemaphore == nil {\n\t\treturn emptyFunc\n\t}\n\n\te.concurrencySemaphore <- struct{}{}\n\treturn func() {\n\t\t<-e.concurrencySemaphore\n\t}\n}\n\nfunc (e *Executor) releaseConcurrencyLimit() func() {\n\tif e.concurrencySemaphore == nil {\n\t\treturn emptyFunc\n\t}\n\n\t<-e.concurrencySemaphore\n\treturn func() {\n\t\te.concurrencySemaphore <- struct{}{}\n\t}\n}\n\nfunc emptyFunc() {}\n"
        },
        {
          "name": "errors",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.263671875,
          "content": "module github.com/go-task/task/v3\n\ngo 1.22.0\n\nrequire (\n\tgithub.com/Ladicle/tabwriter v1.0.0\n\tgithub.com/Masterminds/semver/v3 v3.3.1\n\tgithub.com/alecthomas/chroma/v2 v2.14.0\n\tgithub.com/chainguard-dev/git-urls v1.0.2\n\tgithub.com/davecgh/go-spew v1.1.1\n\tgithub.com/dominikbraun/graph v0.23.0\n\tgithub.com/elliotchance/orderedmap/v2 v2.7.0\n\tgithub.com/fatih/color v1.18.0\n\tgithub.com/go-git/go-billy/v5 v5.6.1\n\tgithub.com/go-git/go-git/v5 v5.13.1\n\tgithub.com/go-task/slim-sprig/v3 v3.0.0\n\tgithub.com/go-task/template v0.1.0\n\tgithub.com/joho/godotenv v1.5.1\n\tgithub.com/mattn/go-zglob v0.0.6\n\tgithub.com/mitchellh/hashstructure/v2 v2.0.2\n\tgithub.com/otiai10/copy v1.14.0\n\tgithub.com/radovskyb/watcher v1.0.7\n\tgithub.com/sajari/fuzzy v1.0.0\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.10.0\n\tgithub.com/zeebo/xxh3 v1.0.2\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/term v0.27.0\n\tgopkg.in/yaml.v3 v3.0.1\n\tmvdan.cc/sh/v3 v3.10.0\n)\n\nrequire (\n\tdario.cat/mergo v1.0.0 // indirect\n\tgithub.com/Microsoft/go-winio v0.6.1 // indirect\n\tgithub.com/ProtonMail/go-crypto v1.1.3 // indirect\n\tgithub.com/cloudflare/circl v1.3.7 // indirect\n\tgithub.com/cyphar/filepath-securejoin v0.3.6 // indirect\n\tgithub.com/dlclark/regexp2 v1.11.0 // indirect\n\tgithub.com/emirpasic/gods v1.18.1 // indirect\n\tgithub.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect\n\tgithub.com/kevinburke/ssh_config v1.2.0 // indirect\n\tgithub.com/klauspost/cpuid/v2 v2.2.7 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/muesli/cancelreader v0.2.2 // indirect\n\tgithub.com/pjbgf/sha1cd v0.3.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 // indirect\n\tgithub.com/skeema/knownhosts v1.3.0 // indirect\n\tgithub.com/stretchr/objx v0.5.2 // indirect\n\tgithub.com/xanzy/ssh-agent v0.3.3 // indirect\n\tgolang.org/x/crypto v0.31.0 // indirect\n\tgolang.org/x/mod v0.18.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/tools v0.22.0 // indirect\n\tgopkg.in/warnings.v0 v0.1.2 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 15.2021484375,
          "content": "dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=\ndario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=\ngithub.com/Ladicle/tabwriter v1.0.0 h1:DZQqPvMumBDwVNElso13afjYLNp0Z7pHqHnu0r4t9Dg=\ngithub.com/Ladicle/tabwriter v1.0.0/go.mod h1:c4MdCjxQyTbGuQO/gvqJ+IA/89UEwrsD6hUCW98dyp4=\ngithub.com/Masterminds/semver/v3 v3.3.1 h1:QtNSWtVZ3nBfk8mAOu/B6v7FMJ+NHTIgUPi7rj+4nv4=\ngithub.com/Masterminds/semver/v3 v3.3.1/go.mod h1:4V+yj/TJE1HU9XfppCwVMZq3I84lprf4nC11bSS5beM=\ngithub.com/Microsoft/go-winio v0.5.2/go.mod h1:WpS1mjBmmwHBEWmogvA2mj8546UReBk4v8QkMxJ6pZY=\ngithub.com/Microsoft/go-winio v0.6.1 h1:9/kr64B9VUZrLm5YYwbGtUJnMgqWVOdUAXu6Migciow=\ngithub.com/Microsoft/go-winio v0.6.1/go.mod h1:LRdKpFKfdobln8UmuiYcKPot9D2v6svN5+sAH+4kjUM=\ngithub.com/ProtonMail/go-crypto v1.1.3 h1:nRBOetoydLeUb4nHajyO2bKqMLfWQ/ZPwkXqXxPxCFk=\ngithub.com/ProtonMail/go-crypto v1.1.3/go.mod h1:rA3QumHc/FZ8pAHreoekgiAbzpNsfQAosU5td4SnOrE=\ngithub.com/alecthomas/assert/v2 v2.7.0 h1:QtqSACNS3tF7oasA8CU6A6sXZSBDqnm7RfpLl9bZqbE=\ngithub.com/alecthomas/assert/v2 v2.7.0/go.mod h1:Bze95FyfUr7x34QZrjL+XP+0qgp/zg8yS+TtBj1WA3k=\ngithub.com/alecthomas/chroma/v2 v2.14.0 h1:R3+wzpnUArGcQz7fCETQBzO5n9IMNi13iIs46aU4V9E=\ngithub.com/alecthomas/chroma/v2 v2.14.0/go.mod h1:QolEbTfmUHIMVpBqxeDnNBj2uoeI4EbYP4i6n68SG4I=\ngithub.com/alecthomas/repr v0.4.0 h1:GhI2A8MACjfegCPVq9f1FLvIBS+DrQ2KQBFZP1iFzXc=\ngithub.com/alecthomas/repr v0.4.0/go.mod h1:Fr0507jx4eOXV7AlPV6AVZLYrLIuIeSOWtW57eE/O/4=\ngithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=\ngithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=\ngithub.com/chainguard-dev/git-urls v1.0.2 h1:pSpT7ifrpc5X55n4aTTm7FFUE+ZQHKiqpiwNkJrVcKQ=\ngithub.com/chainguard-dev/git-urls v1.0.2/go.mod h1:rbGgj10OS7UgZlbzdUQIQpT0k/D4+An04HJY7Ol+Y/o=\ngithub.com/cloudflare/circl v1.3.7 h1:qlCDlTPz2n9fu58M0Nh1J/JzcFpfgkFHHX3O35r5vcU=\ngithub.com/cloudflare/circl v1.3.7/go.mod h1:sRTcRWXGLrKw6yIGJ+l7amYJFfAXbZG0kBSc8r4zxgA=\ngithub.com/creack/pty v1.1.23 h1:4M6+isWdcStXEf15G/RbrMPOQj1dZ7HPZCGwE4kOeP0=\ngithub.com/creack/pty v1.1.23/go.mod h1:08sCNb52WyoAwi2QDyzUCTgcvVFhUzewun7wtTfvcwE=\ngithub.com/cyphar/filepath-securejoin v0.3.6 h1:4d9N5ykBnSp5Xn2JkhocYDkOpURL/18CYMpo6xB9uWM=\ngithub.com/cyphar/filepath-securejoin v0.3.6/go.mod h1:Sdj7gXlvMcPZsbhwhQ33GguGLDGQL7h7bg04C/+u9jI=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dlclark/regexp2 v1.11.0 h1:G/nrcoOa7ZXlpoa/91N3X7mM3r8eIlMBBJZvsz/mxKI=\ngithub.com/dlclark/regexp2 v1.11.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/dominikbraun/graph v0.23.0 h1:TdZB4pPqCLFxYhdyMFb1TBdFxp8XLcJfTTBQucVPgCo=\ngithub.com/dominikbraun/graph v0.23.0/go.mod h1:yOjYyogZLY1LSG9E33JWZJiq5k83Qy2C6POAuiViluc=\ngithub.com/elazarl/goproxy v1.2.3 h1:xwIyKHbaP5yfT6O9KIeYJR5549MXRQkoQMRXGztz8YQ=\ngithub.com/elazarl/goproxy v1.2.3/go.mod h1:YfEbZtqP4AetfO6d40vWchF3znWX7C7Vd6ZMfdL8z64=\ngithub.com/elliotchance/orderedmap/v2 v2.7.0 h1:WHuf0DRo63uLnldCPp9ojm3gskYwEdIIfAUVG5KhoOc=\ngithub.com/elliotchance/orderedmap/v2 v2.7.0/go.mod h1:85lZyVbpGaGvHvnKa7Qhx7zncAdBIBq6u56Hb1PRU5Q=\ngithub.com/emirpasic/gods v1.18.1 h1:FXtiHYKDGKCW2KzwZKx0iC0PQmdlorYgdFG9jPXJ1Bc=\ngithub.com/emirpasic/gods v1.18.1/go.mod h1:8tpGGwCnJ5H4r6BWwaV6OrWmMoPhUl5jm/FMNAnJvWQ=\ngithub.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=\ngithub.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=\ngithub.com/gliderlabs/ssh v0.3.8 h1:a4YXD1V7xMF9g5nTkdfnja3Sxy1PVDCj1Zg4Wb8vY6c=\ngithub.com/gliderlabs/ssh v0.3.8/go.mod h1:xYoytBv1sV0aL3CavoDuJIQNURXkkfPA/wxQ1pL1fAU=\ngithub.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 h1:+zs/tPmkDkHx3U66DAb0lQFJrpS6731Oaa12ikc+DiI=\ngithub.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376/go.mod h1:an3vInlBmSxCcxctByoQdvwPiA7DTK7jaaFDBTtu0ic=\ngithub.com/go-git/go-billy/v5 v5.6.1 h1:u+dcrgaguSSkbjzHwelEjc0Yj300NUevrrPphk/SoRA=\ngithub.com/go-git/go-billy/v5 v5.6.1/go.mod h1:0AsLr1z2+Uksi4NlElmMblP5rPcDZNRCD8ujZCRR2BE=\ngithub.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399 h1:eMje31YglSBqCdIqdhKBW8lokaMrL3uTkpGYlE2OOT4=\ngithub.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399/go.mod h1:1OCfN199q1Jm3HZlxleg+Dw/mwps2Wbk9frAWm+4FII=\ngithub.com/go-git/go-git/v5 v5.13.1 h1:DAQ9APonnlvSWpvolXWIuV6Q6zXy2wHbN4cVlNR5Q+M=\ngithub.com/go-git/go-git/v5 v5.13.1/go.mod h1:qryJB4cSBoq3FRoBRf5A77joojuBcmPJ0qu3XXXVixc=\ngithub.com/go-quicktest/qt v1.101.0 h1:O1K29Txy5P2OK0dGo59b7b0LR6wKfIhttaAhHUyn7eI=\ngithub.com/go-quicktest/qt v1.101.0/go.mod h1:14Bz/f7NwaXPtdYEgzsx46kqSxVwTbzVZsDC26tQJow=\ngithub.com/go-task/slim-sprig/v3 v3.0.0 h1:sUs3vkvUymDpBKi3qH1YSqBQk9+9D/8M2mN1vB6EwHI=\ngithub.com/go-task/slim-sprig/v3 v3.0.0/go.mod h1:W848ghGpv3Qj3dhTPRyJypKRiqCdHZiAzKg9hl15HA8=\ngithub.com/go-task/template v0.1.0 h1:ym/r2G937RZA1bsgiWedNnY9e5kxDT+3YcoAnuIetTE=\ngithub.com/go-task/template v0.1.0/go.mod h1:RgwRaZK+kni/hJJ7/AaOE2lPQFPbAdji/DyhC6pxo4k=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/hexops/gotextdiff v1.0.3 h1:gitA9+qJrrTCsiCl7+kh75nPqQt1cx4ZkudSTLoUqJM=\ngithub.com/hexops/gotextdiff v1.0.3/go.mod h1:pSWU5MAI3yDq+fZBTazCSJysOMbxWL1BSow5/V2vxeg=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 h1:BQSFePA1RWJOlocH6Fxy8MmwDt+yVQYULKfN0RoTN8A=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99/go.mod h1:1lJo3i6rXxKeerYnT8Nvf0QmHCRC1n8sfWVwXF2Frvo=\ngithub.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=\ngithub.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=\ngithub.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=\ngithub.com/kevinburke/ssh_config v1.2.0/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=\ngithub.com/klauspost/cpuid/v2 v2.2.7 h1:ZWSB3igEs+d0qvnxR/ZBzXVmxkgt8DdzP6m9pfuVLDM=\ngithub.com/klauspost/cpuid/v2 v2.2.7/go.mod h1:Lcz8mBdAVJIBVzewtcLocK12l3Y+JytZYpaMropDUws=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-zglob v0.0.6 h1:mP8RnmCgho4oaUYDIDn6GNxYk+qJGUs8fJLn+twYj2A=\ngithub.com/mattn/go-zglob v0.0.6/go.mod h1:MxxjyoXXnMxfIpxTK2GAkw1w8glPsQILx3N5wrKakiY=\ngithub.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=\ngithub.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=\ngithub.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=\ngithub.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=\ngithub.com/onsi/gomega v1.34.1 h1:EUMJIKUjM8sKjYbtxQI9A4z2o+rruxnzNvpknOXie6k=\ngithub.com/onsi/gomega v1.34.1/go.mod h1:kU1QgUvBDLXBJq618Xvm2LUX6rSAfRaFRTcdOeDLwwY=\ngithub.com/otiai10/copy v1.14.0 h1:dCI/t1iTdYGtkvCuBG2BgR6KZa83PTclw4U5n2wAllU=\ngithub.com/otiai10/copy v1.14.0/go.mod h1:ECfuL02W+/FkTWZWgQqXPWZgW9oeKCSQ5qVfSc4qc4w=\ngithub.com/otiai10/mint v1.5.1 h1:XaPLeE+9vGbuyEHem1JNk3bYc7KKqyI/na0/mLd/Kks=\ngithub.com/otiai10/mint v1.5.1/go.mod h1:MJm72SBthJjz8qhefc4z1PYEieWmy8Bku7CjcAqyUSM=\ngithub.com/pjbgf/sha1cd v0.3.0 h1:4D5XXmUUBUl/xQ6IjCkEAbqXskkq/4O7LmGn0AqMDs4=\ngithub.com/pjbgf/sha1cd v0.3.0/go.mod h1:nZ1rrWOcGJ5uZgEEVL1VUM9iRQiZvWdbZjkKyFzPPsI=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/radovskyb/watcher v1.0.7 h1:AYePLih6dpmS32vlHfhCeli8127LzkIgwJGcwwe8tUE=\ngithub.com/radovskyb/watcher v1.0.7/go.mod h1:78okwvY5wPdzcb1UYnip1pvrZNIVEIh/Cm+ZuvsUYIg=\ngithub.com/rogpeppe/go-internal v1.13.1 h1:KvO1DLK/DRN07sQ1LQKScxyZJuNnedQ5/wKSR38lUII=\ngithub.com/rogpeppe/go-internal v1.13.1/go.mod h1:uMEvuHeurkdAXX61udpOXGD/AzZDWNMNyH2VO9fmH0o=\ngithub.com/sajari/fuzzy v1.0.0 h1:+FmwVvJErsd0d0hAPlj4CxqxUtQY/fOoY0DwX4ykpRY=\ngithub.com/sajari/fuzzy v1.0.0/go.mod h1:OjYR6KxoWOe9+dOlXeiCJd4dIbED4Oo8wpS89o0pwOo=\ngithub.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 h1:n661drycOFuPLCN3Uc8sB6B/s6Z4t2xvBgU1htSHuq8=\ngithub.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=\ngithub.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/skeema/knownhosts v1.3.0 h1:AM+y0rI04VksttfwjkSTNQorvGqmwATnvnAHpSgc0LY=\ngithub.com/skeema/knownhosts v1.3.0/go.mod h1:sPINvnADmT/qYH1kfv+ePMmOBTH6Tbl7b5LvTDjFK7M=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/xanzy/ssh-agent v0.3.3 h1:+/15pJfg/RsTxqYcX6fHqOXZwwMP+2VyYWJeWM2qQFM=\ngithub.com/xanzy/ssh-agent v0.3.3/go.mod h1:6dzNDKs0J9rVPHPhaGCukekBHKqfl+L3KghI1Bc68Uw=\ngithub.com/zeebo/assert v1.3.0 h1:g7C04CbJuIDKNPFHmsk4hwZDO5O+kntRxzaUoNXj+IQ=\ngithub.com/zeebo/assert v1.3.0/go.mod h1:Pq9JiuJQpG8JLJdtkwrJESF0Foym2/D9XMU5ciN/wJ0=\ngithub.com/zeebo/xxh3 v1.0.2 h1:xZmwmqxHZA8AI603jOQ0tMqmBr9lPeFwGg6d+xy9DC0=\ngithub.com/zeebo/xxh3 v1.0.2/go.mod h1:5NWz9Sef7zIDm2JHfFlcQvNekmcEl9ekUZQQKCYaDcA=\ngolang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 h1:2dVuKD2vS7b0QIHQbpyTISPd0LeHDbnYEryqj5Q1ug8=\ngolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56/go.mod h1:M4RDyNAINzryxdtnbRXRL/OHtkFuWGRjvuhBJpk2IlY=\ngolang.org/x/mod v0.18.0 h1:5+9lSbEzPSdWkH32vYPBwEpX8KwDbM52Ud9xBUvNlb0=\ngolang.org/x/mod v0.18.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=\ngolang.org/x/term v0.27.0/go.mod h1:iMsnZpn0cago0GOrHO2+Y7u7JPn5AylBrcoWkElMTSM=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.22.0 h1:gqSGLZqv+AI9lIQzniJ0nZDRG5GBPsSi+DRNHWNz6yA=\ngolang.org/x/tools v0.22.0/go.mod h1:aCwcsjqvq7Yqt6TNyX7QMU2enbQ/Gt0bo6krSeEri+c=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/warnings.v0 v0.1.2 h1:wFXVbFY8DY5/xOe1ECiWdKCzZlxgshcYVNkBHstARME=\ngopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nmvdan.cc/sh/v3 v3.10.0 h1:v9z7N1DLZ7owyLM/SXZQkBSXcwr2IGMm2LY2pmhVXj4=\nmvdan.cc/sh/v3 v3.10.0/go.mod h1:z/mSSVyLFGZzqb3ZIKojjyqIx/xbmz/UHdCSv9HmqXY=\n"
        },
        {
          "name": "hash.go",
          "type": "blob",
          "size": 0.4267578125,
          "content": "package task\n\nimport (\n\t\"cmp\"\n\t\"fmt\"\n\n\t\"github.com/go-task/task/v3/internal/hash\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\nfunc (e *Executor) GetHash(t *ast.Task) (string, error) {\n\tr := cmp.Or(t.Run, e.Taskfile.Run)\n\tvar h hash.HashFunc\n\tswitch r {\n\tcase \"always\":\n\t\th = hash.Empty\n\tcase \"once\":\n\t\th = hash.Name\n\tcase \"when_changed\":\n\t\th = hash.Hash\n\tdefault:\n\t\treturn \"\", fmt.Errorf(`task: invalid run \"%s\"`, r)\n\t}\n\treturn h(t)\n}\n"
        },
        {
          "name": "help.go",
          "type": "blob",
          "size": 5.6787109375,
          "content": "package task\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/Ladicle/tabwriter\"\n\t\"golang.org/x/sync/errgroup\"\n\n\t\"github.com/go-task/task/v3/internal/editors\"\n\t\"github.com/go-task/task/v3/internal/fingerprint\"\n\t\"github.com/go-task/task/v3/internal/logger\"\n\t\"github.com/go-task/task/v3/internal/sort\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\n// ListOptions collects list-related options\ntype ListOptions struct {\n\tListOnlyTasksWithDescriptions bool\n\tListAllTasks                  bool\n\tFormatTaskListAsJSON          bool\n\tNoStatus                      bool\n}\n\n// NewListOptions creates a new ListOptions instance\nfunc NewListOptions(list, listAll, listAsJson, noStatus bool) ListOptions {\n\treturn ListOptions{\n\t\tListOnlyTasksWithDescriptions: list,\n\t\tListAllTasks:                  listAll,\n\t\tFormatTaskListAsJSON:          listAsJson,\n\t\tNoStatus:                      noStatus,\n\t}\n}\n\n// ShouldListTasks returns true if one of the options to list tasks has been set to true\nfunc (o ListOptions) ShouldListTasks() bool {\n\treturn o.ListOnlyTasksWithDescriptions || o.ListAllTasks\n}\n\n// Validate validates that the collection of list-related options are in a valid configuration\nfunc (o ListOptions) Validate() error {\n\tif o.ListOnlyTasksWithDescriptions && o.ListAllTasks {\n\t\treturn fmt.Errorf(\"task: cannot use --list and --list-all at the same time\")\n\t}\n\tif o.FormatTaskListAsJSON && !o.ShouldListTasks() {\n\t\treturn fmt.Errorf(\"task: --json only applies to --list or --list-all\")\n\t}\n\tif o.NoStatus && !o.FormatTaskListAsJSON {\n\t\treturn fmt.Errorf(\"task: --no-status only applies to --json with --list or --list-all\")\n\t}\n\treturn nil\n}\n\n// Filters returns the slice of FilterFunc which filters a list\n// of ast.Task according to the given ListOptions\nfunc (o ListOptions) Filters() []FilterFunc {\n\tfilters := []FilterFunc{FilterOutInternal}\n\n\tif o.ListOnlyTasksWithDescriptions {\n\t\tfilters = append(filters, FilterOutNoDesc)\n\t}\n\n\treturn filters\n}\n\n// ListTasks prints a list of tasks.\n// Tasks that match the given filters will be excluded from the list.\n// The function returns a boolean indicating whether tasks were found\n// and an error if one was encountered while preparing the output.\nfunc (e *Executor) ListTasks(o ListOptions) (bool, error) {\n\ttasks, err := e.GetTaskList(o.Filters()...)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif o.FormatTaskListAsJSON {\n\t\toutput, err := e.ToEditorOutput(tasks, o.NoStatus)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\tencoder := json.NewEncoder(e.Stdout)\n\t\tencoder.SetIndent(\"\", \"  \")\n\t\tif err := encoder.Encode(output); err != nil {\n\t\t\treturn false, err\n\t\t}\n\n\t\treturn len(tasks) > 0, nil\n\t}\n\tif len(tasks) == 0 {\n\t\tif o.ListOnlyTasksWithDescriptions {\n\t\t\te.Logger.Outf(logger.Yellow, \"task: No tasks with description available. Try --list-all to list all tasks\\n\")\n\t\t} else if o.ListAllTasks {\n\t\t\te.Logger.Outf(logger.Yellow, \"task: No tasks available\\n\")\n\t\t}\n\t\treturn false, nil\n\t}\n\te.Logger.Outf(logger.Default, \"task: Available tasks for this project:\\n\")\n\n\t// Format in tab-separated columns with a tab stop of 8.\n\tw := tabwriter.NewWriter(e.Stdout, 0, 8, 6, ' ', 0)\n\tfor _, task := range tasks {\n\t\te.Logger.FOutf(w, logger.Yellow, \"* \")\n\t\te.Logger.FOutf(w, logger.Green, task.Task)\n\t\tdesc := strings.ReplaceAll(task.Desc, \"\\n\", \" \")\n\t\te.Logger.FOutf(w, logger.Default, \": \\t%s\", desc)\n\t\tif len(task.Aliases) > 0 {\n\t\t\te.Logger.FOutf(w, logger.Cyan, \"\\t(aliases: %s)\", strings.Join(task.Aliases, \", \"))\n\t\t}\n\t\t_, _ = fmt.Fprint(w, \"\\n\")\n\t}\n\tif err := w.Flush(); err != nil {\n\t\treturn false, err\n\t}\n\treturn true, nil\n}\n\n// ListTaskNames prints only the task names in a Taskfile.\n// Only tasks with a non-empty description are printed if allTasks is false.\n// Otherwise, all task names are printed.\nfunc (e *Executor) ListTaskNames(allTasks bool) error {\n\t// use stdout if no output defined\n\tvar w io.Writer = os.Stdout\n\tif e.Stdout != nil {\n\t\tw = e.Stdout\n\t}\n\n\t// Get the list of tasks and sort them\n\ttasks := e.Taskfile.Tasks.Values()\n\n\t// Sort the tasks\n\tif e.TaskSorter == nil {\n\t\te.TaskSorter = &sort.AlphaNumericWithRootTasksFirst{}\n\t}\n\te.TaskSorter.Sort(tasks)\n\n\t// Create a list of task names\n\ttaskNames := make([]string, 0, e.Taskfile.Tasks.Len())\n\tfor _, task := range tasks {\n\t\tif (allTasks || task.Desc != \"\") && !task.Internal {\n\t\t\ttaskNames = append(taskNames, strings.TrimRight(task.Task, \":\"))\n\t\t\tfor _, alias := range task.Aliases {\n\t\t\t\ttaskNames = append(taskNames, strings.TrimRight(alias, \":\"))\n\t\t\t}\n\t\t}\n\t}\n\tfor _, t := range taskNames {\n\t\tfmt.Fprintln(w, t)\n\t}\n\treturn nil\n}\n\nfunc (e *Executor) ToEditorOutput(tasks []*ast.Task, noStatus bool) (*editors.Taskfile, error) {\n\to := &editors.Taskfile{\n\t\tTasks:    make([]editors.Task, len(tasks)),\n\t\tLocation: e.Taskfile.Location,\n\t}\n\tvar g errgroup.Group\n\tfor i := range tasks {\n\t\taliases := []string{}\n\t\tif len(tasks[i].Aliases) > 0 {\n\t\t\taliases = tasks[i].Aliases\n\t\t}\n\t\tg.Go(func() error {\n\t\t\to.Tasks[i] = editors.Task{\n\t\t\t\tName:     tasks[i].Name(),\n\t\t\t\tDesc:     tasks[i].Desc,\n\t\t\t\tSummary:  tasks[i].Summary,\n\t\t\t\tAliases:  aliases,\n\t\t\t\tUpToDate: false,\n\t\t\t\tLocation: &editors.Location{\n\t\t\t\t\tLine:     tasks[i].Location.Line,\n\t\t\t\t\tColumn:   tasks[i].Location.Column,\n\t\t\t\t\tTaskfile: tasks[i].Location.Taskfile,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tif noStatus {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Get the fingerprinting method to use\n\t\t\tmethod := e.Taskfile.Method\n\t\t\tif tasks[i].Method != \"\" {\n\t\t\t\tmethod = tasks[i].Method\n\t\t\t}\n\t\t\tupToDate, err := fingerprint.IsTaskUpToDate(context.Background(), tasks[i],\n\t\t\t\tfingerprint.WithMethod(method),\n\t\t\t\tfingerprint.WithTempDir(e.TempDir.Fingerprint),\n\t\t\t\tfingerprint.WithDry(e.Dry),\n\t\t\t\tfingerprint.WithLogger(e.Logger),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\to.Tasks[i].UpToDate = upToDate\n\n\t\t\treturn nil\n\t\t})\n\t}\n\treturn o, g.Wait()\n}\n"
        },
        {
          "name": "init.go",
          "type": "blob",
          "size": 0.751953125,
          "content": "package task\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/internal/filepathext\"\n)\n\nconst defaultTaskfile = `# https://taskfile.dev\n\nversion: '3'\n\nvars:\n  GREETING: Hello, World!\n\ntasks:\n  default:\n    cmds:\n      - echo \"{{.GREETING}}\"\n    silent: true\n`\n\nconst defaultTaskfileName = \"Taskfile.yml\"\n\n// InitTaskfile Taskfile creates a new Taskfile\nfunc InitTaskfile(w io.Writer, dir string) error {\n\tf := filepathext.SmartJoin(dir, defaultTaskfileName)\n\n\tif _, err := os.Stat(f); err == nil {\n\t\treturn errors.TaskfileAlreadyExistsError{}\n\t}\n\n\tif err := os.WriteFile(f, []byte(defaultTaskfile), 0o644); err != nil {\n\t\treturn err\n\t}\n\tfmt.Fprintf(w, \"%s created in the current directory\\n\", defaultTaskfile)\n\treturn nil\n}\n"
        },
        {
          "name": "install-task.sh",
          "type": "blob",
          "size": 9.408203125,
          "content": "#!/bin/sh\nset -e\n# Code generated by godownloader on 2021-01-12T13:40:40Z. DO NOT EDIT.\n#\n\nusage() {\n  this=$1\n  cat <<EOF\n$this: download go binaries for go-task/task\n\nUsage: $this [-b] bindir [-d] [tag]\n  -b sets bindir or installation directory, Defaults to ./bin\n  -d turns on debug logging\n   [tag] is a tag from\n   https://github.com/go-task/task/releases\n   If tag is missing, then the latest will be used.\n\n Generated by godownloader\n  https://github.com/goreleaser/godownloader\n\nEOF\n  exit 2\n}\n\nparse_args() {\n  #BINDIR is ./bin unless set be ENV\n  # over-ridden by flag below\n\n  BINDIR=${BINDIR:-./bin}\n  while getopts \"b:dh?x\" arg; do\n    case \"$arg\" in\n      b) BINDIR=\"$OPTARG\" ;;\n      d) log_set_priority 10 ;;\n      h | \\?) usage \"$0\" ;;\n      x) set -x ;;\n    esac\n  done\n  shift $((OPTIND - 1))\n  TAG=$1\n}\n# this function wraps all the destructive operations\n# if a curl|bash cuts off the end of the script due to\n# network, either nothing will happen or will syntax error\n# out preventing half-done work\nexecute() {\n  tmpdir=$(mktemp -d)\n  log_debug \"downloading files into ${tmpdir}\"\n  http_download \"${tmpdir}/${TARBALL}\" \"${TARBALL_URL}\"\n  http_download \"${tmpdir}/${CHECKSUM}\" \"${CHECKSUM_URL}\"\n  hash_sha256_verify \"${tmpdir}/${TARBALL}\" \"${tmpdir}/${CHECKSUM}\"\n  srcdir=\"${tmpdir}\"\n  (cd \"${tmpdir}\" && untar \"${TARBALL}\")\n  test ! -d \"${BINDIR}\" && install -d \"${BINDIR}\"\n  for binexe in $BINARIES; do\n    if [ \"$OS\" = \"windows\" ]; then\n      binexe=\"${binexe}.exe\"\n    fi\n    install \"${srcdir}/${binexe}\" \"${BINDIR}/\"\n    log_info \"installed ${BINDIR}/${binexe}\"\n  done\n  rm -rf \"${tmpdir}\"\n}\nget_binaries() {\n  case \"$PLATFORM\" in\n    darwin/amd64) BINARIES=\"task\" ;;\n    darwin/arm64) BINARIES=\"task\" ;;\n    darwin/armv5) BINARIES=\"task\" ;;\n    darwin/armv6) BINARIES=\"task\" ;;\n    darwin/armv7) BINARIES=\"task\" ;;\n    linux/386) BINARIES=\"task\" ;;\n    linux/amd64) BINARIES=\"task\" ;;\n    linux/arm64) BINARIES=\"task\" ;;\n    linux/armv5) BINARIES=\"task\" ;;\n    linux/armv6) BINARIES=\"task\" ;;\n    linux/armv7) BINARIES=\"task\" ;;\n    windows/386) BINARIES=\"task\" ;;\n    windows/amd64) BINARIES=\"task\" ;;\n    windows/arm64) BINARIES=\"task\" ;;\n    windows/armv5) BINARIES=\"task\" ;;\n    windows/armv6) BINARIES=\"task\" ;;\n    windows/armv7) BINARIES=\"task\" ;;\n    *)\n      log_crit \"platform $PLATFORM is not supported.  Make sure this script is up-to-date and file request at https://github.com/${PREFIX}/issues/new\"\n      exit 1\n      ;;\n  esac\n}\ntag_to_version() {\n  if [ -z \"${TAG}\" ]; then\n    log_info \"checking GitHub for latest tag\"\n  else\n    log_info \"checking GitHub for tag '${TAG}'\"\n  fi\n  REALTAG=$(github_release \"$OWNER/$REPO\" \"${TAG}\") && true\n  if test -z \"$REALTAG\"; then\n    log_crit \"unable to find '${TAG}' - use 'latest' or see https://github.com/${PREFIX}/releases for details\"\n    exit 1\n  fi\n  # if version starts with 'v', remove it\n  TAG=\"$REALTAG\"\n  VERSION=${TAG#v}\n}\nadjust_format() {\n  # change format (tar.gz or zip) based on OS\n  case ${OS} in\n    windows) FORMAT=zip ;;\n  esac\n  true\n}\nadjust_os() {\n  # adjust archive name based on OS\n  true\n}\nadjust_arch() {\n  # adjust archive name based on ARCH\n  true\n}\n\ncat /dev/null <<EOF\n------------------------------------------------------------------------\nhttps://github.com/client9/shlib - portable posix shell functions\nPublic domain - http://unlicense.org\nhttps://github.com/client9/shlib/blob/master/LICENSE.md\nbut credit (and pull requests) appreciated.\n------------------------------------------------------------------------\nEOF\nis_command() {\n  command -v \"$1\" >/dev/null\n}\nechoerr() {\n  echo \"$@\" 1>&2\n}\nlog_prefix() {\n  echo \"$0\"\n}\n_logp=6\nlog_set_priority() {\n  _logp=\"$1\"\n}\nlog_priority() {\n  if test -z \"$1\"; then\n    echo \"$_logp\"\n    return\n  fi\n  [ \"$1\" -le \"$_logp\" ]\n}\nlog_tag() {\n  case $1 in\n    0) echo \"emerg\" ;;\n    1) echo \"alert\" ;;\n    2) echo \"crit\" ;;\n    3) echo \"err\" ;;\n    4) echo \"warning\" ;;\n    5) echo \"notice\" ;;\n    6) echo \"info\" ;;\n    7) echo \"debug\" ;;\n    *) echo \"$1\" ;;\n  esac\n}\nlog_debug() {\n  log_priority 7 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 7)\" \"$@\"\n}\nlog_info() {\n  log_priority 6 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 6)\" \"$@\"\n}\nlog_err() {\n  log_priority 3 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 3)\" \"$@\"\n}\nlog_crit() {\n  log_priority 2 || return 0\n  echoerr \"$(log_prefix)\" \"$(log_tag 2)\" \"$@\"\n}\nuname_os() {\n  os=$(uname -s | tr '[:upper:]' '[:lower:]')\n  case \"$os\" in\n    cygwin_nt*) os=\"windows\" ;;\n    mingw*) os=\"windows\" ;;\n    msys_nt*) os=\"windows\" ;;\n  esac\n  echo \"$os\"\n}\nuname_arch() {\n  arch=$(uname -m)\n  case $arch in\n    x86_64) arch=\"amd64\" ;;\n    x86) arch=\"386\" ;;\n    i686) arch=\"386\" ;;\n    i386) arch=\"386\" ;;\n    aarch64) arch=\"arm64\" ;;\n    armv5*) arch=\"arm\" ;;\n    armv6*) arch=\"arm\" ;;\n    armv7*) arch=\"arm\" ;;\n  esac\n  echo ${arch}\n}\nuname_os_check() {\n  os=$(uname_os)\n  case \"$os\" in\n    darwin) return 0 ;;\n    dragonfly) return 0 ;;\n    freebsd) return 0 ;;\n    linux) return 0 ;;\n    android) return 0 ;;\n    nacl) return 0 ;;\n    netbsd) return 0 ;;\n    openbsd) return 0 ;;\n    plan9) return 0 ;;\n    solaris) return 0 ;;\n    windows) return 0 ;;\n  esac\n  log_crit \"uname_os_check '$(uname -s)' got converted to '$os' which is not a GOOS value. Please file bug at https://github.com/client9/shlib\"\n  return 1\n}\nuname_arch_check() {\n  arch=$(uname_arch)\n  case \"$arch\" in\n    386) return 0 ;;\n    amd64) return 0 ;;\n    arm64) return 0 ;;\n    arm) return 0 ;;\n    ppc64) return 0 ;;\n    ppc64le) return 0 ;;\n    mips) return 0 ;;\n    mipsle) return 0 ;;\n    mips64) return 0 ;;\n    mips64le) return 0 ;;\n    s390x) return 0 ;;\n    amd64p32) return 0 ;;\n  esac\n  log_crit \"uname_arch_check '$(uname -m)' got converted to '$arch' which is not a GOARCH value.  Please file bug report at https://github.com/client9/shlib\"\n  return 1\n}\nuntar() {\n  tarball=$1\n  case \"${tarball}\" in\n    *.tar.gz | *.tgz) tar --no-same-owner -xzf \"${tarball}\" ;;\n    *.tar) tar --no-same-owner -xf \"${tarball}\" ;;\n    *.zip) unzip \"${tarball}\" ;;\n    *)\n      log_err \"untar unknown archive format for ${tarball}\"\n      return 1\n      ;;\n  esac\n}\nhttp_download_curl() {\n  local_file=$1\n  source_url=$2\n  header=$3\n  if [ -z \"$header\" ]; then\n    code=$(curl -w '%{http_code}' -sL -o \"$local_file\" \"$source_url\")\n  else\n    code=$(curl -w '%{http_code}' -sL -H \"$header\" -o \"$local_file\" \"$source_url\")\n  fi\n  if [ \"$code\" != \"200\" ]; then\n    log_debug \"http_download_curl received HTTP status $code\"\n    return 1\n  fi\n  return 0\n}\nhttp_download_wget() {\n  local_file=$1\n  source_url=$2\n  header=$3\n  if [ -z \"$header\" ]; then\n    wget -q -O \"$local_file\" \"$source_url\"\n  else\n    wget -q --header \"$header\" -O \"$local_file\" \"$source_url\"\n  fi\n}\nhttp_download() {\n  log_debug \"http_download $2\"\n  if is_command curl; then\n    http_download_curl \"$@\"\n    return\n  elif is_command wget; then\n    http_download_wget \"$@\"\n    return\n  fi\n  log_crit \"http_download unable to find wget or curl\"\n  return 1\n}\nhttp_copy() {\n  tmp=$(mktemp)\n  http_download \"${tmp}\" \"$1\" \"$2\" || return 1\n  body=$(cat \"$tmp\")\n  rm -f \"${tmp}\"\n  echo \"$body\"\n}\ngithub_release() {\n  owner_repo=$1\n  version=$2\n  test -z \"$version\" && version=\"latest\"\n  giturl=\"https://github.com/${owner_repo}/releases/${version}\"\n  json=$(http_copy \"$giturl\" \"Accept:application/json\")\n  test -z \"$json\" && return 1\n  version=$(echo \"$json\" | tr -s '\\n' ' ' | sed 's/.*\"tag_name\":\"//' | sed 's/\".*//')\n  test -z \"$version\" && return 1\n  echo \"$version\"\n}\nhash_sha256() {\n  TARGET=${1:-/dev/stdin}\n  if is_command gsha256sum; then\n    hash=$(gsha256sum \"$TARGET\") || return 1\n    echo \"$hash\" | cut -d ' ' -f 1\n  elif is_command sha256sum; then\n    hash=$(sha256sum \"$TARGET\") || return 1\n    echo \"$hash\" | cut -d ' ' -f 1\n  elif is_command shasum; then\n    hash=$(shasum -a 256 \"$TARGET\" 2>/dev/null) || return 1\n    echo \"$hash\" | cut -d ' ' -f 1\n  elif is_command openssl; then\n    hash=$(openssl -dst openssl dgst -sha256 \"$TARGET\") || return 1\n    echo \"$hash\" | cut -d ' ' -f a\n  else\n    log_crit \"hash_sha256 unable to find command to compute sha-256 hash\"\n    return 1\n  fi\n}\nhash_sha256_verify() {\n  TARGET=$1\n  checksums=$2\n  if [ -z \"$checksums\" ]; then\n    log_err \"hash_sha256_verify checksum file not specified in arg2\"\n    return 1\n  fi\n  BASENAME=${TARGET##*/}\n  want=$(grep \"${BASENAME}\" \"${checksums}\" 2>/dev/null | tr '\\t' ' ' | cut -d ' ' -f 1)\n  if [ -z \"$want\" ]; then\n    log_err \"hash_sha256_verify unable to find checksum for '${TARGET}' in '${checksums}'\"\n    return 1\n  fi\n  got=$(hash_sha256 \"$TARGET\")\n  if [ \"$want\" != \"$got\" ]; then\n    log_err \"hash_sha256_verify checksum for '$TARGET' did not verify ${want} vs $got\"\n    return 1\n  fi\n}\ncat /dev/null <<EOF\n------------------------------------------------------------------------\nEnd of functions from https://github.com/client9/shlib\n------------------------------------------------------------------------\nEOF\n\nPROJECT_NAME=\"task\"\nOWNER=go-task\nREPO=\"task\"\nBINARY=task\nFORMAT=tar.gz\nOS=$(uname_os)\nARCH=$(uname_arch)\nPREFIX=\"$OWNER/$REPO\"\n\n# use in logging routines\nlog_prefix() {\n\techo \"$PREFIX\"\n}\nPLATFORM=\"${OS}/${ARCH}\"\nGITHUB_DOWNLOAD=https://github.com/${OWNER}/${REPO}/releases/download\n\nuname_os_check \"$OS\"\nuname_arch_check \"$ARCH\"\n\nparse_args \"$@\"\n\nget_binaries\n\ntag_to_version\n\nadjust_format\n\nadjust_os\n\nadjust_arch\n\nlog_info \"found version: ${VERSION} for ${TAG}/${OS}/${ARCH}\"\n\nNAME=${BINARY}_${OS}_${ARCH}\nTARBALL=${NAME}.${FORMAT}\nTARBALL_URL=${GITHUB_DOWNLOAD}/${TAG}/${TARBALL}\nCHECKSUM=task_checksums.txt\nCHECKSUM_URL=${GITHUB_DOWNLOAD}/${TAG}/${CHECKSUM}\n\n\nexecute\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "package-lock.json",
          "type": "blob",
          "size": 0.90234375,
          "content": "{\n  \"name\": \"@go-task/cli\",\n  \"version\": \"3.40.1\",\n  \"lockfileVersion\": 2,\n  \"requires\": true,\n  \"packages\": {\n    \"\": {\n      \"name\": \"@go-task/cli\",\n      \"version\": \"3.26.0\",\n      \"hasInstallScript\": true,\n      \"license\": \"MIT\",\n      \"dependencies\": {\n        \"@go-task/go-npm\": \"^0.2.0\"\n      }\n    },\n    \"node_modules/@go-task/go-npm\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/@go-task/go-npm/-/go-npm-0.2.0.tgz\",\n      \"integrity\": \"sha512-vQbdtBvesHm8EUFHX8QKg4rbBodmu9VsAXH1ozpbiN5jdTMOYHTCMM31EurAYmY+rNNtxJQ4JGy6t383RPlqbw==\",\n      \"bin\": {\n        \"go-npm\": \"bin/index.js\"\n      }\n    }\n  },\n  \"dependencies\": {\n    \"@go-task/go-npm\": {\n      \"version\": \"0.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/@go-task/go-npm/-/go-npm-0.2.0.tgz\",\n      \"integrity\": \"sha512-vQbdtBvesHm8EUFHX8QKg4rbBodmu9VsAXH1ozpbiN5jdTMOYHTCMM31EurAYmY+rNNtxJQ4JGy6t383RPlqbw==\"\n    }\n  }\n}\n"
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.791015625,
          "content": "{\n  \"name\": \"@go-task/cli\",\n  \"version\": \"3.40.1\",\n  \"description\": \"A task runner / simpler Make alternative written in Go\",\n  \"scripts\": {\n    \"postinstall\": \"go-npm install\",\n    \"preuninstall\": \"go-npm uninstall\"\n  },\n  \"goBinary\": {\n    \"name\": \"task\",\n    \"path\": \"./bin\",\n    \"url\": \"https://github.com/go-task/task/releases/download/v{{version}}/task_{{platform}}_{{arch}}{{archive_ext}}\"\n  },\n  \"files\": [],\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/go-task/task.git\"\n  },\n  \"keywords\": [\n    \"task\",\n    \"taskfile\",\n    \"build-tool\",\n    \"task-runner\"\n  ],\n  \"author\": \"The Task authors\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/go-task/task/issues\"\n  },\n  \"homepage\": \"https://taskfile.dev\",\n  \"dependencies\": {\n    \"@go-task/go-npm\": \"^0.2.0\"\n  }\n}\n"
        },
        {
          "name": "precondition.go",
          "type": "blob",
          "size": 0.8115234375,
          "content": "package task\n\nimport (\n\t\"context\"\n\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/internal/env\"\n\t\"github.com/go-task/task/v3/internal/execext\"\n\t\"github.com/go-task/task/v3/internal/logger\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\n// ErrPreconditionFailed is returned when a precondition fails\nvar ErrPreconditionFailed = errors.New(\"task: precondition not met\")\n\nfunc (e *Executor) areTaskPreconditionsMet(ctx context.Context, t *ast.Task) (bool, error) {\n\tfor _, p := range t.Preconditions {\n\t\terr := execext.RunCommand(ctx, &execext.RunCommandOptions{\n\t\t\tCommand: p.Sh,\n\t\t\tDir:     t.Dir,\n\t\t\tEnv:     env.Get(t),\n\t\t})\n\t\tif err != nil {\n\t\t\tif !errors.Is(err, context.Canceled) {\n\t\t\t\te.Logger.Errf(logger.Magenta, \"task: %s\\n\", p.Msg)\n\t\t\t}\n\t\t\treturn false, ErrPreconditionFailed\n\t\t}\n\t}\n\n\treturn true, nil\n}\n"
        },
        {
          "name": "requires.go",
          "type": "blob",
          "size": 1.0732421875,
          "content": "package task\n\nimport (\n\t\"slices\"\n\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\nfunc (e *Executor) areTaskRequiredVarsSet(t *ast.Task) error {\n\tif t.Requires == nil || len(t.Requires.Vars) == 0 {\n\t\treturn nil\n\t}\n\n\tvar missingVars []string\n\tvar notAllowedValuesVars []errors.NotAllowedVar\n\tfor _, requiredVar := range t.Requires.Vars {\n\t\tvalue, ok := t.Vars.Get(requiredVar.Name)\n\t\tif !ok {\n\t\t\tmissingVars = append(missingVars, requiredVar.Name)\n\t\t} else {\n\t\t\tvalue, isString := value.Value.(string)\n\t\t\tif isString && requiredVar.Enum != nil && !slices.Contains(requiredVar.Enum, value) {\n\t\t\t\tnotAllowedValuesVars = append(notAllowedValuesVars, errors.NotAllowedVar{\n\t\t\t\t\tValue: value,\n\t\t\t\t\tEnum:  requiredVar.Enum,\n\t\t\t\t\tName:  requiredVar.Name,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(missingVars) > 0 {\n\t\treturn &errors.TaskMissingRequiredVars{\n\t\t\tTaskName:    t.Name(),\n\t\t\tMissingVars: missingVars,\n\t\t}\n\t}\n\n\tif len(notAllowedValuesVars) > 0 {\n\t\treturn &errors.TaskNotAllowedVars{\n\t\t\tTaskName:       t.Name(),\n\t\t\tNotAllowedVars: notAllowedValuesVars,\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "setup.go",
          "type": "blob",
          "size": 6.314453125,
          "content": "package task\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"slices\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/Masterminds/semver/v3\"\n\t\"github.com/sajari/fuzzy\"\n\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/internal/compiler\"\n\t\"github.com/go-task/task/v3/internal/execext\"\n\t\"github.com/go-task/task/v3/internal/filepathext\"\n\t\"github.com/go-task/task/v3/internal/logger\"\n\t\"github.com/go-task/task/v3/internal/output\"\n\t\"github.com/go-task/task/v3/internal/version\"\n\t\"github.com/go-task/task/v3/taskfile\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\nfunc (e *Executor) Setup() error {\n\te.setupLogger()\n\tnode, err := e.getRootNode()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := e.setupTempDir(); err != nil {\n\t\treturn err\n\t}\n\tif err := e.readTaskfile(node); err != nil {\n\t\treturn err\n\t}\n\te.setupFuzzyModel()\n\te.setupStdFiles()\n\tif err := e.setupOutput(); err != nil {\n\t\treturn err\n\t}\n\tif err := e.setupCompiler(); err != nil {\n\t\treturn err\n\t}\n\tif err := e.readDotEnvFiles(); err != nil {\n\t\treturn err\n\t}\n\tif err := e.doVersionChecks(); err != nil {\n\t\treturn err\n\t}\n\te.setupDefaults()\n\te.setupConcurrencyState()\n\treturn nil\n}\n\nfunc (e *Executor) getRootNode() (taskfile.Node, error) {\n\tnode, err := taskfile.NewRootNode(e.Logger, e.Entrypoint, e.Dir, e.Insecure, e.Timeout)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\te.Dir = node.Dir()\n\treturn node, err\n}\n\nfunc (e *Executor) readTaskfile(node taskfile.Node) error {\n\treader := taskfile.NewReader(\n\t\tnode,\n\t\te.Insecure,\n\t\te.Download,\n\t\te.Offline,\n\t\te.Timeout,\n\t\te.TempDir.Remote,\n\t\te.Logger,\n\t)\n\tgraph, err := reader.Read()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif e.Taskfile, err = graph.Merge(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (e *Executor) setupFuzzyModel() {\n\tif e.Taskfile != nil {\n\t\treturn\n\t}\n\n\tmodel := fuzzy.NewModel()\n\tmodel.SetThreshold(1) // because we want to build grammar based on every task name\n\n\tvar words []string\n\tfor _, taskName := range e.Taskfile.Tasks.Keys() {\n\t\twords = append(words, taskName)\n\n\t\tfor _, task := range e.Taskfile.Tasks.Values() {\n\t\t\twords = slices.Concat(words, task.Aliases)\n\t\t}\n\t}\n\n\tmodel.Train(words)\n\te.fuzzyModel = model\n}\n\nfunc (e *Executor) setupTempDir() error {\n\tif e.TempDir != (TempDir{}) {\n\t\treturn nil\n\t}\n\n\tif os.Getenv(\"TASK_TEMP_DIR\") == \"\" {\n\t\te.TempDir = TempDir{\n\t\t\tRemote:      filepathext.SmartJoin(e.Dir, \".task\"),\n\t\t\tFingerprint: filepathext.SmartJoin(e.Dir, \".task\"),\n\t\t}\n\t} else if filepath.IsAbs(os.Getenv(\"TASK_TEMP_DIR\")) || strings.HasPrefix(os.Getenv(\"TASK_TEMP_DIR\"), \"~\") {\n\t\ttempDir, err := execext.Expand(os.Getenv(\"TASK_TEMP_DIR\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprojectDir, _ := filepath.Abs(e.Dir)\n\t\tprojectName := filepath.Base(projectDir)\n\t\te.TempDir = TempDir{\n\t\t\tRemote:      tempDir,\n\t\t\tFingerprint: filepathext.SmartJoin(tempDir, projectName),\n\t\t}\n\n\t} else {\n\t\te.TempDir = TempDir{\n\t\t\tRemote:      filepathext.SmartJoin(e.Dir, os.Getenv(\"TASK_TEMP_DIR\")),\n\t\t\tFingerprint: filepathext.SmartJoin(e.Dir, os.Getenv(\"TASK_TEMP_DIR\")),\n\t\t}\n\t}\n\n\tif os.Getenv(\"TASK_REMOTE_DIR\") != \"\" {\n\t\tif filepath.IsAbs(os.Getenv(\"TASK_REMOTE_DIR\")) || strings.HasPrefix(os.Getenv(\"TASK_REMOTE_DIR\"), \"~\") {\n\t\t\tremoteTempDir, err := execext.Expand(os.Getenv(\"TASK_REMOTE_DIR\"))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\te.TempDir.Remote = remoteTempDir\n\t\t} else {\n\t\t\te.TempDir.Remote = filepathext.SmartJoin(e.Dir, \".task\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (e *Executor) setupStdFiles() {\n\tif e.Stdin == nil {\n\t\te.Stdin = os.Stdin\n\t}\n\tif e.Stdout == nil {\n\t\te.Stdout = os.Stdout\n\t}\n\tif e.Stderr == nil {\n\t\te.Stderr = os.Stderr\n\t}\n}\n\nfunc (e *Executor) setupLogger() {\n\te.Logger = &logger.Logger{\n\t\tStdin:      e.Stdin,\n\t\tStdout:     e.Stdout,\n\t\tStderr:     e.Stderr,\n\t\tVerbose:    e.Verbose,\n\t\tColor:      e.Color,\n\t\tAssumeYes:  e.AssumeYes,\n\t\tAssumeTerm: e.AssumeTerm,\n\t}\n}\n\nfunc (e *Executor) setupOutput() error {\n\tif !e.OutputStyle.IsSet() {\n\t\te.OutputStyle = e.Taskfile.Output\n\t}\n\n\tvar err error\n\te.Output, err = output.BuildFor(&e.OutputStyle, e.Logger)\n\treturn err\n}\n\nfunc (e *Executor) setupCompiler() error {\n\tif e.UserWorkingDir == \"\" {\n\t\tvar err error\n\t\te.UserWorkingDir, err = os.Getwd()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\te.Compiler = &compiler.Compiler{\n\t\tDir:            e.Dir,\n\t\tEntrypoint:     e.Entrypoint,\n\t\tUserWorkingDir: e.UserWorkingDir,\n\t\tTaskfileEnv:    e.Taskfile.Env,\n\t\tTaskfileVars:   e.Taskfile.Vars,\n\t\tLogger:         e.Logger,\n\t}\n\treturn nil\n}\n\nfunc (e *Executor) readDotEnvFiles() error {\n\tif e.Taskfile.Version.LessThan(ast.V3) {\n\t\treturn nil\n\t}\n\n\tenv, err := taskfile.Dotenv(e.Compiler, e.Taskfile, e.Dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = env.Range(func(key string, value ast.Var) error {\n\t\tif _, ok := e.Taskfile.Env.Get(key); !ok {\n\t\t\te.Taskfile.Env.Set(key, value)\n\t\t}\n\t\treturn nil\n\t})\n\treturn err\n}\n\nfunc (e *Executor) setupDefaults() {\n\tif e.Taskfile.Method == \"\" {\n\t\te.Taskfile.Method = \"checksum\"\n\t}\n\tif e.Taskfile.Run == \"\" {\n\t\te.Taskfile.Run = \"always\"\n\t}\n}\n\nfunc (e *Executor) setupConcurrencyState() {\n\te.executionHashes = make(map[string]context.Context)\n\n\te.taskCallCount = make(map[string]*int32, e.Taskfile.Tasks.Len())\n\te.mkdirMutexMap = make(map[string]*sync.Mutex, e.Taskfile.Tasks.Len())\n\tfor _, k := range e.Taskfile.Tasks.Keys() {\n\t\te.taskCallCount[k] = new(int32)\n\t\te.mkdirMutexMap[k] = &sync.Mutex{}\n\t}\n\n\tif e.Concurrency > 0 {\n\t\te.concurrencySemaphore = make(chan struct{}, e.Concurrency)\n\t}\n}\n\nfunc (e *Executor) doVersionChecks() error {\n\t// Copy the version to avoid modifying the original\n\tschemaVersion := &semver.Version{}\n\t*schemaVersion = *e.Taskfile.Version\n\n\t// Error if the Taskfile uses a schema version below v3\n\tif schemaVersion.LessThan(ast.V3) {\n\t\treturn &errors.TaskfileVersionCheckError{\n\t\t\tURI:           e.Taskfile.Location,\n\t\t\tSchemaVersion: schemaVersion,\n\t\t\tMessage:       `no longer supported. Please use v3 or above`,\n\t\t}\n\t}\n\n\t// Get the current version of Task\n\t// If we can't parse the version (e.g. when its \"devel\"), then ignore the current version checks\n\tcurrentVersion, err := semver.NewVersion(version.GetVersion())\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\t// Error if the Taskfile uses a schema version above the current version of Task\n\tif schemaVersion.GreaterThan(currentVersion) {\n\t\treturn &errors.TaskfileVersionCheckError{\n\t\t\tURI:           e.Taskfile.Location,\n\t\t\tSchemaVersion: schemaVersion,\n\t\t\tMessage:       fmt.Sprintf(`is greater than the current version of Task (%s)`, currentVersion.String()),\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "signals.go",
          "type": "blob",
          "size": 0.7587890625,
          "content": "package task\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/go-task/task/v3/internal/logger\"\n)\n\nconst interruptSignalsCount = 3\n\n// NOTE(@andreynering): This function intercepts SIGINT and SIGTERM signals\n// so the Task process is not killed immediately and processes running have\n// time to do cleanup work.\nfunc (e *Executor) InterceptInterruptSignals() {\n\tch := make(chan os.Signal, interruptSignalsCount)\n\tsignal.Notify(ch, os.Interrupt, syscall.SIGTERM)\n\n\tgo func() {\n\t\tfor i := range interruptSignalsCount {\n\t\t\tsig := <-ch\n\n\t\t\tif i+1 >= interruptSignalsCount {\n\t\t\t\te.Logger.Errf(logger.Red, \"task: Signal received for the third time: %q. Forcing shutdown\\n\", sig)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\n\t\t\te.Logger.Outf(logger.Yellow, \"task: Signal received: %q\\n\", sig)\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "signals_test.go",
          "type": "blob",
          "size": 7.4140625,
          "content": "//go:build signals\n// +build signals\n\n// This file contains tests for signal handling on Unix.\n// Based on code from https://github.com/marco-m/timeit\n// Due to how signals work, for robustness we always spawn a separate process;\n// we never send signals to the test process.\n\npackage task_test\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar SLEEPIT, _ = filepath.Abs(\"./bin/sleepit\")\n\nfunc TestSignalSentToProcessGroup(t *testing.T) {\n\ttask, err := getTaskPath()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttestCases := map[string]struct {\n\t\targs     []string\n\t\tsendSigs int\n\t\twant     []string\n\t\tnotWant  []string\n\t}{\n\t\t// regression:\n\t\t// - child is terminated, immediately, by \"context canceled\" (another bug???)\n\t\t\"child does not handle sigint: receives sigint and terminates immediately\": {\n\t\t\targs:     []string{task, \"--\", SLEEPIT, \"default\", \"-sleep=10s\"},\n\t\t\tsendSigs: 1,\n\t\t\twant: []string{\n\t\t\t\t\"sleepit: ready\\n\",\n\t\t\t\t\"sleepit: work started\\n\",\n\t\t\t\t\"task: Signal received: \\\"interrupt\\\"\\n\",\n\t\t\t\t// 130 = 128 + SIGINT\n\t\t\t\t\"task: Failed to run task \\\"default\\\": exit status 130\\n\",\n\t\t\t},\n\t\t\tnotWant: []string{\n\t\t\t\t\"task: Failed to run task \\\"default\\\": context canceled\\n\",\n\t\t\t},\n\t\t},\n\t\t// 2 regressions:\n\t\t// - child receives 2 signals instead of 1\n\t\t// - child is terminated, immediately, by \"context canceled\" (another bug???)\n\t\t// TODO we need -cleanup=2s only to show reliably the bug; once the fix is committed,\n\t\t// we can use -cleanup=50ms to speed the test up\n\t\t\"child intercepts sigint: receives sigint and does cleanup\": {\n\t\t\targs:     []string{task, \"--\", SLEEPIT, \"handle\", \"-sleep=10s\", \"-cleanup=2s\"},\n\t\t\tsendSigs: 1,\n\t\t\twant: []string{\n\t\t\t\t\"sleepit: ready\\n\",\n\t\t\t\t\"sleepit: work started\\n\",\n\t\t\t\t\"task: Signal received: \\\"interrupt\\\"\\n\",\n\t\t\t\t\"sleepit: got signal=interrupt count=1\\n\",\n\t\t\t\t\"sleepit: work canceled\\n\",\n\t\t\t\t\"sleepit: cleanup started\\n\",\n\t\t\t\t\"sleepit: cleanup done\\n\",\n\t\t\t\t\"task: Failed to run task \\\"default\\\": exit status 3\\n\",\n\t\t\t},\n\t\t\tnotWant: []string{\n\t\t\t\t\"sleepit: got signal=interrupt count=2\\n\",\n\t\t\t\t\"task: Failed to run task \\\"default\\\": context canceled\\n\",\n\t\t\t},\n\t\t},\n\t\t// regression: child receives 2 signal instead of 1 and thus terminates abruptly\n\t\t\"child simulates terraform: receives 1 sigint and does cleanup\": {\n\t\t\targs:     []string{task, \"--\", SLEEPIT, \"handle\", \"-term-after=2\", \"-sleep=10s\", \"-cleanup=50ms\"},\n\t\t\tsendSigs: 1,\n\t\t\twant: []string{\n\t\t\t\t\"sleepit: ready\\n\",\n\t\t\t\t\"sleepit: work started\\n\",\n\t\t\t\t\"task: Signal received: \\\"interrupt\\\"\\n\",\n\t\t\t\t\"sleepit: got signal=interrupt count=1\\n\",\n\t\t\t\t\"sleepit: work canceled\\n\",\n\t\t\t\t\"sleepit: cleanup started\\n\",\n\t\t\t\t\"sleepit: cleanup done\\n\",\n\t\t\t\t\"task: Failed to run task \\\"default\\\": exit status 3\\n\",\n\t\t\t},\n\t\t\tnotWant: []string{\n\t\t\t\t\"sleepit: got signal=interrupt count=2\\n\",\n\t\t\t\t\"sleepit: cleanup canceled\\n\",\n\t\t\t\t\"task: Failed to run task \\\"default\\\": exit status 4\\n\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor name, tc := range testCases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tvar out bytes.Buffer\n\t\t\tsut := exec.Command(tc.args[0], tc.args[1:]...)\n\t\t\tsut.Stdout = &out\n\t\t\tsut.Stderr = &out\n\t\t\tsut.Dir = \"testdata/ignore_signals\"\n\t\t\t// Create a new process group by setting the process group ID of the child\n\t\t\t// to the child PID.\n\t\t\t// By default, the child would inherit the process group of the parent, but\n\t\t\t// we want to avoid this, to protect the parent (the test process) from the\n\t\t\t// signal that this test will send. More info in the comments below for\n\t\t\t// syscall.Kill().\n\t\t\tsut.SysProcAttr = &syscall.SysProcAttr{Setpgid: true, Pgid: 0}\n\n\t\t\tif err := sut.Start(); err != nil {\n\t\t\t\tt.Fatalf(\"starting the SUT process: %v\", err)\n\t\t\t}\n\n\t\t\t// After the child is started, we want to avoid a race condition where we send\n\t\t\t// it a signal before it had time to setup its own signal handlers. Sleeping\n\t\t\t// is way too flaky, instead we parse the child output until we get a line\n\t\t\t// that we know is printed after the signal handlers are installed...\n\t\t\tready := false\n\t\t\ttimeout := time.Duration(time.Second)\n\t\t\tstart := time.Now()\n\t\t\tfor time.Since(start) < timeout {\n\t\t\t\tif strings.Contains(out.String(), \"sleepit: ready\\n\") {\n\t\t\t\t\tready = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t}\n\t\t\tif !ready {\n\t\t\t\tt.Fatalf(\"sleepit not ready after %v\\n\"+\n\t\t\t\t\t\"additional information:\\n\"+\n\t\t\t\t\t\"  output:\\n%s\",\n\t\t\t\t\ttimeout, out.String())\n\t\t\t}\n\n\t\t\t// When we have a running program in a shell and type CTRL-C, the tty driver\n\t\t\t// will send a SIGINT signal to all the processes in the foreground process\n\t\t\t// group (see https://en.wikipedia.org/wiki/Process_group).\n\t\t\t//\n\t\t\t// Here we want to emulate this behavior: send SIGINT to the process group of\n\t\t\t// the test executable. Although Go for some reasons doesn't wrap the\n\t\t\t// killpg(2) system call, what works is using syscall.Kill(-PID, SIGINT),\n\t\t\t// where the negative PID means the corresponding process group. Note that\n\t\t\t// this negative PID works only as long as the caller of the kill(2) system\n\t\t\t// call has a different PID, which is the case for this test.\n\t\t\tfor range tc.sendSigs - 1 {\n\t\t\t\tif err := syscall.Kill(-sut.Process.Pid, syscall.SIGINT); err != nil {\n\t\t\t\t\tt.Fatalf(\"sending INT signal to the process group: %v\", err)\n\t\t\t\t}\n\t\t\t\ttime.Sleep(1 * time.Millisecond)\n\t\t\t}\n\n\t\t\terr := sut.Wait()\n\n\t\t\tvar wantErr *exec.ExitError\n\t\t\tconst wantExitStatus = 201\n\t\t\tif errors.As(err, &wantErr) {\n\t\t\t\tif wantErr.ExitCode() != wantExitStatus {\n\t\t\t\t\tt.Errorf(\n\t\t\t\t\t\t\"waiting for child process: got exit status %v; want %d\\n\"+\n\t\t\t\t\t\t\t\"additional information:\\n\"+\n\t\t\t\t\t\t\t\"  process state: %q\",\n\t\t\t\t\t\twantErr.ExitCode(), wantExitStatus, wantErr.String())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt.Errorf(\"waiting for child process: got unexpected error type %v (%T); want (%T)\",\n\t\t\t\t\terr, err, wantErr)\n\t\t\t}\n\n\t\t\tgotLines := strings.SplitAfter(out.String(), \"\\n\")\n\t\t\tnotFound := listDifference(tc.want, gotLines)\n\t\t\tif len(notFound) > 0 {\n\t\t\t\tt.Errorf(\"\\nwanted but not found:\\n%v\", notFound)\n\t\t\t}\n\n\t\t\tfound := listIntersection(tc.notWant, gotLines)\n\t\t\tif len(found) > 0 {\n\t\t\t\tt.Errorf(\"\\nunwanted but found:\\n%v\", found)\n\t\t\t}\n\n\t\t\tif len(notFound) > 0 || len(found) > 0 {\n\t\t\t\tt.Errorf(\"\\noutput:\\n%v\", gotLines)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc getTaskPath() (string, error) {\n\tif info, err := os.Stat(\"./bin/task\"); err == nil {\n\t\treturn info.Name(), nil\n\t}\n\n\tif path, err := exec.LookPath(\"task\"); err == nil {\n\t\treturn path, nil\n\t}\n\n\treturn \"\", errors.New(\"task: \\\"task\\\" binary was not found!\")\n}\n\n// Return the difference of the two lists: the elements that are present in the first\n// list, but not in the second one. The notion of presence is not with `=` but with\n// string.Contains(l2, l1).\n// FIXME this does not enforce ordering. We might want to support both.\nfunc listDifference(lines1, lines2 []string) []string {\n\tdifference := []string{}\n\tfor _, l1 := range lines1 {\n\t\tfound := false\n\t\tfor _, l2 := range lines2 {\n\t\t\tif strings.Contains(l2, l1) {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tdifference = append(difference, l1)\n\t\t}\n\t}\n\n\treturn difference\n}\n\n// Return the intersection of the two lists: the elements that are present in both lists.\n// The notion of presence is not with '=' but with string.Contains(l2, l1)\n// FIXME this does not enforce ordering. We might want to support both.\nfunc listIntersection(lines1, lines2 []string) []string {\n\tintersection := []string{}\n\tfor _, l1 := range lines1 {\n\t\tfor _, l2 := range lines2 {\n\t\t\tif strings.Contains(l2, l1) {\n\t\t\t\tintersection = append(intersection, l1)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn intersection\n}\n"
        },
        {
          "name": "status.go",
          "type": "blob",
          "size": 1.16796875,
          "content": "package task\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/go-task/task/v3/internal/fingerprint\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\n// Status returns an error if any the of given tasks is not up-to-date\nfunc (e *Executor) Status(ctx context.Context, calls ...*ast.Call) error {\n\tfor _, call := range calls {\n\n\t\t// Compile the task\n\t\tt, err := e.CompiledTask(call)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Get the fingerprinting method to use\n\t\tmethod := e.Taskfile.Method\n\t\tif t.Method != \"\" {\n\t\t\tmethod = t.Method\n\t\t}\n\n\t\t// Check if the task is up-to-date\n\t\tisUpToDate, err := fingerprint.IsTaskUpToDate(ctx, t,\n\t\t\tfingerprint.WithMethod(method),\n\t\t\tfingerprint.WithTempDir(e.TempDir.Fingerprint),\n\t\t\tfingerprint.WithDry(e.Dry),\n\t\t\tfingerprint.WithLogger(e.Logger),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !isUpToDate {\n\t\t\treturn fmt.Errorf(`task: Task \"%s\" is not up-to-date`, t.Name())\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *Executor) statusOnError(t *ast.Task) error {\n\tmethod := t.Method\n\tif method == \"\" {\n\t\tmethod = e.Taskfile.Method\n\t}\n\tchecker, err := fingerprint.NewSourcesChecker(method, e.TempDir.Fingerprint, e.Dry)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn checker.OnError(t)\n}\n"
        },
        {
          "name": "task.go",
          "type": "blob",
          "size": 13.6875,
          "content": "package task\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"slices\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"mvdan.cc/sh/v3/interp\"\n\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/internal/compiler\"\n\t\"github.com/go-task/task/v3/internal/env\"\n\t\"github.com/go-task/task/v3/internal/execext\"\n\t\"github.com/go-task/task/v3/internal/fingerprint\"\n\t\"github.com/go-task/task/v3/internal/logger\"\n\t\"github.com/go-task/task/v3/internal/output\"\n\t\"github.com/go-task/task/v3/internal/slicesext\"\n\t\"github.com/go-task/task/v3/internal/sort\"\n\t\"github.com/go-task/task/v3/internal/summary\"\n\t\"github.com/go-task/task/v3/internal/templater\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n\n\t\"github.com/sajari/fuzzy\"\n\t\"golang.org/x/sync/errgroup\"\n)\n\nconst (\n\t// MaximumTaskCall is the max number of times a task can be called.\n\t// This exists to prevent infinite loops on cyclic dependencies\n\tMaximumTaskCall = 1000\n)\n\ntype TempDir struct {\n\tRemote      string\n\tFingerprint string\n}\n\n// Executor executes a Taskfile\ntype Executor struct {\n\tTaskfile *ast.Taskfile\n\n\tDir         string\n\tEntrypoint  string\n\tTempDir     TempDir\n\tForce       bool\n\tForceAll    bool\n\tInsecure    bool\n\tDownload    bool\n\tOffline     bool\n\tTimeout     time.Duration\n\tWatch       bool\n\tVerbose     bool\n\tSilent      bool\n\tAssumeYes   bool\n\tAssumeTerm  bool // Used for testing\n\tDry         bool\n\tSummary     bool\n\tParallel    bool\n\tColor       bool\n\tConcurrency int\n\tInterval    time.Duration\n\n\tStdin  io.Reader\n\tStdout io.Writer\n\tStderr io.Writer\n\n\tLogger         *logger.Logger\n\tCompiler       *compiler.Compiler\n\tOutput         output.Output\n\tOutputStyle    ast.Output\n\tTaskSorter     sort.TaskSorter\n\tUserWorkingDir string\n\n\tfuzzyModel *fuzzy.Model\n\n\tconcurrencySemaphore chan struct{}\n\ttaskCallCount        map[string]*int32\n\tmkdirMutexMap        map[string]*sync.Mutex\n\texecutionHashes      map[string]context.Context\n\texecutionHashesMutex sync.Mutex\n}\n\n// Run runs Task\nfunc (e *Executor) Run(ctx context.Context, calls ...*ast.Call) error {\n\t// check if given tasks exist\n\tfor _, call := range calls {\n\t\ttask, err := e.GetTask(call)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(*errors.TaskNotFoundError); ok {\n\t\t\t\tif _, err := e.ListTasks(ListOptions{ListOnlyTasksWithDescriptions: true}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif task.Internal {\n\t\t\tif _, ok := err.(*errors.TaskNotFoundError); ok {\n\t\t\t\tif _, err := e.ListTasks(ListOptions{ListOnlyTasksWithDescriptions: true}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn &errors.TaskInternalError{TaskName: call.Task}\n\t\t}\n\t}\n\n\tif e.Summary {\n\t\tfor i, c := range calls {\n\t\t\tcompiledTask, err := e.FastCompiledTask(c)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tsummary.PrintSpaceBetweenSummaries(e.Logger, i)\n\t\t\tsummary.PrintTask(e.Logger, compiledTask)\n\t\t}\n\t\treturn nil\n\t}\n\n\tregularCalls, watchCalls, err := e.splitRegularAndWatchCalls(calls...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tg, ctx := errgroup.WithContext(ctx)\n\tfor _, c := range regularCalls {\n\t\tc := c\n\t\tif e.Parallel {\n\t\t\tg.Go(func() error { return e.RunTask(ctx, c) })\n\t\t} else {\n\t\t\tif err := e.RunTask(ctx, c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif err := g.Wait(); err != nil {\n\t\treturn err\n\t}\n\n\tif len(watchCalls) > 0 {\n\t\treturn e.watchTasks(watchCalls...)\n\t}\n\n\treturn nil\n}\n\nfunc (e *Executor) splitRegularAndWatchCalls(calls ...*ast.Call) (regularCalls []*ast.Call, watchCalls []*ast.Call, err error) {\n\tfor _, c := range calls {\n\t\tt, err := e.GetTask(c)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tif e.Watch || t.Watch {\n\t\t\twatchCalls = append(watchCalls, c)\n\t\t} else {\n\t\t\tregularCalls = append(regularCalls, c)\n\t\t}\n\t}\n\treturn\n}\n\n// RunTask runs a task by its name\nfunc (e *Executor) RunTask(ctx context.Context, call *ast.Call) error {\n\tt, err := e.FastCompiledTask(call)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !shouldRunOnCurrentPlatform(t.Platforms) {\n\t\te.Logger.VerboseOutf(logger.Yellow, `task: %q not for current platform - ignored\\n`, call.Task)\n\t\treturn nil\n\t}\n\n\tif err := e.areTaskRequiredVarsSet(t); err != nil {\n\t\treturn err\n\t}\n\n\tt, err = e.CompiledTask(call)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !e.Watch && atomic.AddInt32(e.taskCallCount[t.Task], 1) >= MaximumTaskCall {\n\t\treturn &errors.TaskCalledTooManyTimesError{\n\t\t\tTaskName:        t.Task,\n\t\t\tMaximumTaskCall: MaximumTaskCall,\n\t\t}\n\t}\n\n\trelease := e.acquireConcurrencyLimit()\n\tdefer release()\n\n\treturn e.startExecution(ctx, t, func(ctx context.Context) error {\n\t\te.Logger.VerboseErrf(logger.Magenta, \"task: %q started\\n\", call.Task)\n\t\tif err := e.runDeps(ctx, t); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tskipFingerprinting := e.ForceAll || (!call.Indirect && e.Force)\n\t\tif !skipFingerprinting {\n\t\t\tif err := ctx.Err(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tpreCondMet, err := e.areTaskPreconditionsMet(ctx, t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Get the fingerprinting method to use\n\t\t\tmethod := e.Taskfile.Method\n\t\t\tif t.Method != \"\" {\n\t\t\t\tmethod = t.Method\n\t\t\t}\n\n\t\t\tupToDate, err := fingerprint.IsTaskUpToDate(ctx, t,\n\t\t\t\tfingerprint.WithMethod(method),\n\t\t\t\tfingerprint.WithTempDir(e.TempDir.Fingerprint),\n\t\t\t\tfingerprint.WithDry(e.Dry),\n\t\t\t\tfingerprint.WithLogger(e.Logger),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif upToDate && preCondMet {\n\t\t\t\tif e.Verbose || (!call.Silent && !t.Silent && !e.Taskfile.Silent && !e.Silent) {\n\t\t\t\t\te.Logger.Errf(logger.Magenta, \"task: Task %q is up to date\\n\", t.Name())\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tfor _, p := range t.Prompt {\n\t\t\tif p != \"\" && !e.Dry {\n\t\t\t\tif err := e.Logger.Prompt(logger.Yellow, p, \"n\", \"y\", \"yes\"); errors.Is(err, logger.ErrNoTerminal) {\n\t\t\t\t\treturn &errors.TaskCancelledNoTerminalError{TaskName: call.Task}\n\t\t\t\t} else if errors.Is(err, logger.ErrPromptCancelled) {\n\t\t\t\t\treturn &errors.TaskCancelledByUserError{TaskName: call.Task}\n\t\t\t\t} else if err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err := e.mkdir(t); err != nil {\n\t\t\te.Logger.Errf(logger.Red, \"task: cannot make directory %q: %v\\n\", t.Dir, err)\n\t\t}\n\n\t\tvar deferredExitCode uint8\n\n\t\tfor i := range t.Cmds {\n\t\t\tif t.Cmds[i].Defer {\n\t\t\t\tdefer e.runDeferred(t, call, i, &deferredExitCode)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif err := e.runCommand(ctx, t, call, i); err != nil {\n\t\t\t\tif err2 := e.statusOnError(t); err2 != nil {\n\t\t\t\t\te.Logger.VerboseErrf(logger.Yellow, \"task: error cleaning status on error: %v\\n\", err2)\n\t\t\t\t}\n\n\t\t\t\texitCode, isExitError := interp.IsExitStatus(err)\n\t\t\t\tif isExitError {\n\t\t\t\t\tif t.IgnoreError {\n\t\t\t\t\t\te.Logger.VerboseErrf(logger.Yellow, \"task: task error ignored: %v\\n\", err)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tdeferredExitCode = exitCode\n\t\t\t\t}\n\n\t\t\t\tif call.Indirect {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\treturn &errors.TaskRunError{TaskName: t.Task, Err: err}\n\t\t\t}\n\t\t}\n\t\te.Logger.VerboseErrf(logger.Magenta, \"task: %q finished\\n\", call.Task)\n\t\treturn nil\n\t})\n}\n\nfunc (e *Executor) mkdir(t *ast.Task) error {\n\tif t.Dir == \"\" {\n\t\treturn nil\n\t}\n\n\tmutex := e.mkdirMutexMap[t.Task]\n\tmutex.Lock()\n\tdefer mutex.Unlock()\n\n\tif _, err := os.Stat(t.Dir); os.IsNotExist(err) {\n\t\tif err := os.MkdirAll(t.Dir, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *Executor) runDeps(ctx context.Context, t *ast.Task) error {\n\tg, ctx := errgroup.WithContext(ctx)\n\n\treacquire := e.releaseConcurrencyLimit()\n\tdefer reacquire()\n\n\tfor _, d := range t.Deps {\n\t\td := d\n\t\tg.Go(func() error {\n\t\t\terr := e.RunTask(ctx, &ast.Call{Task: d.Task, Vars: d.Vars, Silent: d.Silent, Indirect: true})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\n\treturn g.Wait()\n}\n\nfunc (e *Executor) runDeferred(t *ast.Task, call *ast.Call, i int, deferredExitCode *uint8) {\n\tctx, cancel := context.WithCancel(context.Background())\n\tdefer cancel()\n\n\torigTask, err := e.GetTask(call)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tcmd := t.Cmds[i]\n\tvars, _ := e.Compiler.GetVariables(origTask, call)\n\tcache := &templater.Cache{Vars: vars}\n\textra := map[string]any{}\n\n\tif deferredExitCode != nil && *deferredExitCode > 0 {\n\t\textra[\"EXIT_CODE\"] = fmt.Sprintf(\"%d\", *deferredExitCode)\n\t}\n\n\tcmd.Cmd = templater.ReplaceWithExtra(cmd.Cmd, cache, extra)\n\n\tif err := e.runCommand(ctx, t, call, i); err != nil {\n\t\te.Logger.VerboseErrf(logger.Yellow, \"task: ignored error in deferred cmd: %s\\n\", err.Error())\n\t}\n}\n\nfunc (e *Executor) runCommand(ctx context.Context, t *ast.Task, call *ast.Call, i int) error {\n\tcmd := t.Cmds[i]\n\n\tswitch {\n\tcase cmd.Task != \"\":\n\t\treacquire := e.releaseConcurrencyLimit()\n\t\tdefer reacquire()\n\n\t\terr := e.RunTask(ctx, &ast.Call{Task: cmd.Task, Vars: cmd.Vars, Silent: cmd.Silent, Indirect: true})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\tcase cmd.Cmd != \"\":\n\t\tif !shouldRunOnCurrentPlatform(cmd.Platforms) {\n\t\t\te.Logger.VerboseOutf(logger.Yellow, \"task: [%s] %s not for current platform - ignored\\n\", t.Name(), cmd.Cmd)\n\t\t\treturn nil\n\t\t}\n\n\t\tif e.Verbose || (!call.Silent && !cmd.Silent && !t.Silent && !e.Taskfile.Silent && !e.Silent) {\n\t\t\te.Logger.Errf(logger.Green, \"task: [%s] %s\\n\", t.Name(), cmd.Cmd)\n\t\t}\n\n\t\tif e.Dry {\n\t\t\treturn nil\n\t\t}\n\n\t\toutputWrapper := e.Output\n\t\tif t.Interactive {\n\t\t\toutputWrapper = output.Interleaved{}\n\t\t}\n\t\tvars, err := e.Compiler.FastGetVariables(t, call)\n\t\toutputTemplater := &templater.Cache{Vars: vars}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"task: failed to get variables: %w\", err)\n\t\t}\n\t\tstdOut, stdErr, close := outputWrapper.WrapWriter(e.Stdout, e.Stderr, t.Prefix, outputTemplater)\n\n\t\terr = execext.RunCommand(ctx, &execext.RunCommandOptions{\n\t\t\tCommand:   cmd.Cmd,\n\t\t\tDir:       t.Dir,\n\t\t\tEnv:       env.Get(t),\n\t\t\tPosixOpts: slicesext.UniqueJoin(e.Taskfile.Set, t.Set, cmd.Set),\n\t\t\tBashOpts:  slicesext.UniqueJoin(e.Taskfile.Shopt, t.Shopt, cmd.Shopt),\n\t\t\tStdin:     e.Stdin,\n\t\t\tStdout:    stdOut,\n\t\t\tStderr:    stdErr,\n\t\t})\n\t\tif closeErr := close(err); closeErr != nil {\n\t\t\te.Logger.Errf(logger.Red, \"task: unable to close writer: %v\\n\", closeErr)\n\t\t}\n\t\tif _, isExitError := interp.IsExitStatus(err); isExitError && cmd.IgnoreError {\n\t\t\te.Logger.VerboseErrf(logger.Yellow, \"task: [%s] command error ignored: %v\\n\", t.Name(), err)\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (e *Executor) startExecution(ctx context.Context, t *ast.Task, execute func(ctx context.Context) error) error {\n\th, err := e.GetHash(t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif h == \"\" {\n\t\treturn execute(ctx)\n\t}\n\n\te.executionHashesMutex.Lock()\n\n\tif otherExecutionCtx, ok := e.executionHashes[h]; ok {\n\t\te.executionHashesMutex.Unlock()\n\t\te.Logger.VerboseErrf(logger.Magenta, \"task: skipping execution of task: %s\\n\", h)\n\n\t\t// Release our execution slot to avoid blocking other tasks while we wait\n\t\treacquire := e.releaseConcurrencyLimit()\n\t\tdefer reacquire()\n\n\t\t<-otherExecutionCtx.Done()\n\t\treturn nil\n\t}\n\n\tctx, cancel := context.WithCancel(ctx)\n\tdefer cancel()\n\n\te.executionHashes[h] = ctx\n\te.executionHashesMutex.Unlock()\n\n\treturn execute(ctx)\n}\n\n// GetTask will return the task with the name matching the given call from the taskfile.\n// If no task is found, it will search for tasks with a matching alias.\n// If multiple tasks contain the same alias or no matches are found an error is returned.\nfunc (e *Executor) GetTask(call *ast.Call) (*ast.Task, error) {\n\t// Search for a matching task\n\tmatchingTasks := e.Taskfile.Tasks.FindMatchingTasks(call)\n\tswitch len(matchingTasks) {\n\tcase 0: // Carry on\n\tcase 1:\n\t\tif call.Vars == nil {\n\t\t\tcall.Vars = ast.NewVars()\n\t\t}\n\t\tcall.Vars.Set(\"MATCH\", ast.Var{Value: matchingTasks[0].Wildcards})\n\t\treturn matchingTasks[0].Task, nil\n\tdefault:\n\t\ttaskNames := make([]string, len(matchingTasks))\n\t\tfor i, matchingTask := range matchingTasks {\n\t\t\ttaskNames[i] = matchingTask.Task.Task\n\t\t}\n\t\treturn nil, &errors.TaskNameConflictError{\n\t\t\tCall:      call.Task,\n\t\t\tTaskNames: taskNames,\n\t\t}\n\t}\n\n\t// If didn't find one, search for a task with a matching alias\n\tvar matchingTask *ast.Task\n\tvar aliasedTasks []string\n\tfor _, task := range e.Taskfile.Tasks.Values() {\n\t\tif slices.Contains(task.Aliases, call.Task) {\n\t\t\taliasedTasks = append(aliasedTasks, task.Task)\n\t\t\tmatchingTask = task\n\t\t}\n\t}\n\t// If we found multiple tasks\n\tif len(aliasedTasks) > 1 {\n\t\treturn nil, &errors.TaskNameConflictError{\n\t\t\tCall:      call.Task,\n\t\t\tTaskNames: aliasedTasks,\n\t\t}\n\t}\n\t// If we found no tasks\n\tif len(aliasedTasks) == 0 {\n\t\tdidYouMean := \"\"\n\t\tif e.fuzzyModel != nil {\n\t\t\tdidYouMean = e.fuzzyModel.SpellCheck(call.Task)\n\t\t}\n\t\treturn nil, &errors.TaskNotFoundError{\n\t\t\tTaskName:   call.Task,\n\t\t\tDidYouMean: didYouMean,\n\t\t}\n\t}\n\n\treturn matchingTask, nil\n}\n\ntype FilterFunc func(task *ast.Task) bool\n\nfunc (e *Executor) GetTaskList(filters ...FilterFunc) ([]*ast.Task, error) {\n\ttasks := make([]*ast.Task, 0, e.Taskfile.Tasks.Len())\n\n\t// Create an error group to wait for each task to be compiled\n\tvar g errgroup.Group\n\n\t// Filter tasks based on the given filter functions\n\tfor _, task := range e.Taskfile.Tasks.Values() {\n\t\tvar shouldFilter bool\n\t\tfor _, filter := range filters {\n\t\t\tif filter(task) {\n\t\t\t\tshouldFilter = true\n\t\t\t}\n\t\t}\n\t\tif !shouldFilter {\n\t\t\ttasks = append(tasks, task)\n\t\t}\n\t}\n\n\t// Compile the list of tasks\n\tfor i := range tasks {\n\t\tg.Go(func() error {\n\t\t\tcompiledTask, err := e.FastCompiledTask(&ast.Call{Task: tasks[i].Task})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttasks[i] = compiledTask\n\t\t\treturn nil\n\t\t})\n\t}\n\n\t// Wait for all the go routines to finish\n\tif err := g.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Sort the tasks\n\tif e.TaskSorter == nil {\n\t\te.TaskSorter = &sort.AlphaNumericWithRootTasksFirst{}\n\t}\n\te.TaskSorter.Sort(tasks)\n\n\treturn tasks, nil\n}\n\n// FilterOutNoDesc removes all tasks that do not contain a description.\nfunc FilterOutNoDesc(task *ast.Task) bool {\n\treturn task.Desc == \"\"\n}\n\n// FilterOutInternal removes all tasks that are marked as internal.\nfunc FilterOutInternal(task *ast.Task) bool {\n\treturn task.Internal\n}\n\nfunc shouldRunOnCurrentPlatform(platforms []*ast.Platform) bool {\n\tif len(platforms) == 0 {\n\t\treturn true\n\t}\n\tfor _, p := range platforms {\n\t\tif (p.OS == \"\" || p.OS == runtime.GOOS) && (p.Arch == \"\" || p.Arch == runtime.GOARCH) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "task_test.go",
          "type": "blob",
          "size": 79.1767578125,
          "content": "package task_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\trand \"math/rand/v2\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/Masterminds/semver/v3\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/go-task/task/v3\"\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/internal/experiments\"\n\t\"github.com/go-task/task/v3/internal/filepathext\"\n\t\"github.com/go-task/task/v3/internal/logger\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\nfunc init() {\n\t_ = os.Setenv(\"NO_COLOR\", \"1\")\n}\n\n// SyncBuffer is a threadsafe buffer for testing.\n// Some times replace stdout/stderr with a buffer to capture output.\n// stdout and stderr are threadsafe, but a regular bytes.Buffer is not.\n// Using this instead helps prevents race conditions with output.\ntype SyncBuffer struct {\n\tbuf bytes.Buffer\n\tmu  sync.Mutex\n}\n\nfunc (sb *SyncBuffer) Write(p []byte) (n int, err error) {\n\tsb.mu.Lock()\n\tdefer sb.mu.Unlock()\n\treturn sb.buf.Write(p)\n}\n\n// fileContentTest provides a basic reusable test-case for running a Taskfile\n// and inspect generated files.\ntype fileContentTest struct {\n\tDir        string\n\tEntrypoint string\n\tTarget     string\n\tTrimSpace  bool\n\tFiles      map[string]string\n}\n\nfunc (fct fileContentTest) name(file string) string {\n\treturn fmt.Sprintf(\"target=%q,file=%q\", fct.Target, file)\n}\n\nfunc (fct fileContentTest) Run(t *testing.T) {\n\tt.Helper()\n\n\tfor f := range fct.Files {\n\t\t_ = os.Remove(filepathext.SmartJoin(fct.Dir, f))\n\t}\n\te := &task.Executor{\n\t\tDir: fct.Dir,\n\t\tTempDir: task.TempDir{\n\t\t\tRemote:      filepathext.SmartJoin(fct.Dir, \".task\"),\n\t\t\tFingerprint: filepathext.SmartJoin(fct.Dir, \".task\"),\n\t\t},\n\t\tEntrypoint: fct.Entrypoint,\n\t\tStdout:     io.Discard,\n\t\tStderr:     io.Discard,\n\t}\n\n\trequire.NoError(t, e.Setup(), \"e.Setup()\")\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: fct.Target}), \"e.Run(target)\")\n\tfor name, expectContent := range fct.Files {\n\t\tt.Run(fct.name(name), func(t *testing.T) {\n\t\t\tpath := filepathext.SmartJoin(e.Dir, name)\n\t\t\tb, err := os.ReadFile(path)\n\t\t\trequire.NoError(t, err, \"Error reading file\")\n\t\t\ts := string(b)\n\t\t\tif fct.TrimSpace {\n\t\t\t\ts = strings.TrimSpace(s)\n\t\t\t}\n\t\t\tassert.Equal(t, expectContent, s, \"unexpected file content in %s\", path)\n\t\t})\n\t}\n}\n\nfunc TestEmptyTask(t *testing.T) {\n\tt.Parallel()\n\n\te := &task.Executor{\n\t\tDir:    \"testdata/empty_task\",\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\trequire.NoError(t, e.Setup(), \"e.Setup()\")\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n}\n\nfunc TestEmptyTaskfile(t *testing.T) {\n\tt.Parallel()\n\n\te := &task.Executor{\n\t\tDir:    \"testdata/empty_taskfile\",\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\trequire.Error(t, e.Setup(), \"e.Setup()\")\n}\n\nfunc TestEnv(t *testing.T) {\n\tt.Setenv(\"QUX\", \"from_os\")\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/env\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"local.txt\":          \"GOOS='linux' GOARCH='amd64' CGO_ENABLED='0'\\n\",\n\t\t\t\"global.txt\":         \"FOO='foo' BAR='overridden' BAZ='baz'\\n\",\n\t\t\t\"multiple_type.txt\":  \"FOO='1' BAR='true' BAZ='1.1'\\n\",\n\t\t\t\"not-overridden.txt\": \"QUX='from_os'\\n\",\n\t\t\t\"dynamic.txt\":        \"foo\\n\",\n\t\t},\n\t}\n\ttt.Run(t)\n\tt.Setenv(\"TASK_X_ENV_PRECEDENCE\", \"1\")\n\texperiments.EnvPrecedence = experiments.New(\"ENV_PRECEDENCE\")\n\tttt := fileContentTest{\n\t\tDir:       \"testdata/env\",\n\t\tTarget:    \"overridden\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"overridden.txt\": \"QUX='from_taskfile'\\n\",\n\t\t},\n\t}\n\tttt.Run(t)\n}\n\nfunc TestVars(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:    \"testdata/vars\",\n\t\tTarget: \"default\",\n\t\tFiles: map[string]string{\n\t\t\t\"missing-var.txt\":  \"\\n\",\n\t\t\t\"var-order.txt\":    \"ABCDEF\\n\",\n\t\t\t\"dependent-sh.txt\": \"123456\\n\",\n\t\t\t\"with-call.txt\":    \"Hi, ABC123!\\n\",\n\t\t\t\"from-dot-env.txt\": \"From .env file\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestRequires(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/requires\"\n\n\tvar buff bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\trequire.ErrorContains(t, e.Run(context.Background(), &ast.Call{Task: \"missing-var\"}), \"task: Task \\\"missing-var\\\" cancelled because it is missing required variables: foo\")\n\tbuff.Reset()\n\trequire.NoError(t, e.Setup())\n\n\tvars := ast.NewVars()\n\tvars.Set(\"foo\", ast.Var{Value: \"bar\"})\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{\n\t\tTask: \"missing-var\",\n\t\tVars: vars,\n\t}))\n\tbuff.Reset()\n\n\trequire.NoError(t, e.Setup())\n\trequire.ErrorContains(t, e.Run(context.Background(), &ast.Call{Task: \"validation-var\", Vars: vars}), \"task: Task \\\"validation-var\\\" cancelled because it is missing required variables:\\n  - foo has an invalid value : 'bar' (allowed values : [one two])\")\n\tbuff.Reset()\n\n\trequire.NoError(t, e.Setup())\n\tvars.Set(\"foo\", ast.Var{Value: \"one\"})\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"validation-var\", Vars: vars}))\n\tbuff.Reset()\n\n\trequire.NoError(t, e.Setup())\n\trequire.ErrorContains(t, e.Run(context.Background(), &ast.Call{Task: \"require-before-compile\"}), \"task: Task \\\"require-before-compile\\\" cancelled because it is missing required variables: MY_VAR\")\n\tbuff.Reset()\n\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"var-defined-in-task\"}))\n\tbuff.Reset()\n}\n\nfunc TestSpecialVars(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/special_vars\"\n\tconst subdir = \"testdata/special_vars/subdir\"\n\ttoAbs := func(rel string) string {\n\t\tabs, err := filepath.Abs(rel)\n\t\tassert.NoError(t, err)\n\t\treturn abs\n\t}\n\n\ttests := []struct {\n\t\ttarget   string\n\t\texpected string\n\t}{\n\t\t// Root\n\t\t{target: \"print-task\", expected: \"print-task\"},\n\t\t{target: \"print-root-dir\", expected: toAbs(dir)},\n\t\t{target: \"print-taskfile\", expected: toAbs(dir) + \"/Taskfile.yml\"},\n\t\t{target: \"print-taskfile-dir\", expected: toAbs(dir)},\n\t\t{target: \"print-task-version\", expected: \"unknown\"},\n\t\t{target: \"print-task-dir\", expected: toAbs(dir) + \"/foo\"},\n\t\t// Included\n\t\t{target: \"included:print-task\", expected: \"included:print-task\"},\n\t\t{target: \"included:print-root-dir\", expected: toAbs(dir)},\n\t\t{target: \"included:print-taskfile\", expected: toAbs(dir) + \"/included/Taskfile.yml\"},\n\t\t{target: \"included:print-taskfile-dir\", expected: toAbs(dir) + \"/included\"},\n\t\t{target: \"included:print-task-version\", expected: \"unknown\"},\n\t}\n\n\tfor _, dir := range []string{dir, subdir} {\n\t\tfor _, test := range tests {\n\t\t\tt.Run(test.target, func(t *testing.T) {\n\t\t\t\tt.Parallel()\n\n\t\t\t\tvar buff bytes.Buffer\n\t\t\t\te := &task.Executor{\n\t\t\t\t\tDir:    dir,\n\t\t\t\t\tStdout: &buff,\n\t\t\t\t\tStderr: &buff,\n\t\t\t\t\tSilent: true,\n\t\t\t\t}\n\t\t\t\trequire.NoError(t, e.Setup())\n\t\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: test.target}))\n\t\t\t\tassert.Equal(t, test.expected+\"\\n\", buff.String())\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestConcurrency(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tdir    = \"testdata/concurrency\"\n\t\ttarget = \"default\"\n\t)\n\n\te := &task.Executor{\n\t\tDir:         dir,\n\t\tStdout:      io.Discard,\n\t\tStderr:      io.Discard,\n\t\tConcurrency: 1,\n\t}\n\trequire.NoError(t, e.Setup(), \"e.Setup()\")\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: target}), \"e.Run(target)\")\n}\n\nfunc TestParams(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/params\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"hello.txt\":       \"Hello\\n\",\n\t\t\t\"world.txt\":       \"World\\n\",\n\t\t\t\"exclamation.txt\": \"!\\n\",\n\t\t\t\"dep1.txt\":        \"Dependence1\\n\",\n\t\t\t\"dep2.txt\":        \"Dependence2\\n\",\n\t\t\t\"spanish.txt\":     \"¡Holla mundo!\\n\",\n\t\t\t\"spanish-dep.txt\": \"¡Holla dependencia!\\n\",\n\t\t\t\"portuguese.txt\":  \"Olá, mundo!\\n\",\n\t\t\t\"portuguese2.txt\": \"Olá, mundo!\\n\",\n\t\t\t\"german.txt\":      \"Welt!\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestDeps(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/deps\"\n\n\tfiles := []string{\n\t\t\"d1.txt\",\n\t\t\"d2.txt\",\n\t\t\"d3.txt\",\n\t\t\"d11.txt\",\n\t\t\"d12.txt\",\n\t\t\"d13.txt\",\n\t\t\"d21.txt\",\n\t\t\"d22.txt\",\n\t\t\"d23.txt\",\n\t\t\"d31.txt\",\n\t\t\"d32.txt\",\n\t\t\"d33.txt\",\n\t}\n\n\tfor _, f := range files {\n\t\t_ = os.Remove(filepathext.SmartJoin(dir, f))\n\t}\n\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\n\tfor _, f := range files {\n\t\tf = filepathext.SmartJoin(dir, f)\n\t\tif _, err := os.Stat(f); err != nil {\n\t\t\tt.Errorf(\"File %s should exist\", f)\n\t\t}\n\t}\n}\n\nfunc TestStatus(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/status\"\n\n\tfiles := []string{\n\t\t\"foo.txt\",\n\t\t\"bar.txt\",\n\t\t\"baz.txt\",\n\t}\n\n\tfor _, f := range files {\n\t\tpath := filepathext.SmartJoin(dir, f)\n\t\t_ = os.Remove(path)\n\t\tif _, err := os.Stat(path); err == nil {\n\t\t\tt.Errorf(\"File should not exist: %v\", err)\n\t\t}\n\t}\n\n\tvar buff bytes.Buffer\n\te := &task.Executor{\n\t\tDir: dir,\n\t\tTempDir: task.TempDir{\n\t\t\tRemote:      filepathext.SmartJoin(dir, \".task\"),\n\t\t\tFingerprint: filepathext.SmartJoin(dir, \".task\"),\n\t\t},\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\t// gen-foo creates foo.txt, and will always fail it's status check.\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-foo\"}))\n\t// gen-foo creates bar.txt, and will pass its status-check the 3. time it\n\t// is run. It creates bar.txt, but also lists it as its source. So, the checksum\n\t// for the file won't match before after the second run as we the file\n\t// only exists after the first run.\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-bar\"}))\n\t// gen-silent-baz is marked as being silent, and should only produce output\n\t// if e.Verbose is set to true.\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-silent-baz\"}))\n\n\tfor _, f := range files {\n\t\tif _, err := os.Stat(filepathext.SmartJoin(dir, f)); err != nil {\n\t\t\tt.Errorf(\"File should exist: %v\", err)\n\t\t}\n\t}\n\n\t// Run gen-bar a second time to produce a checksum file that matches bar.txt\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-bar\"}))\n\n\t// Run gen-bar a third time, to make sure we've triggered the status check.\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-bar\"}))\n\n\t// We're silent, so no output should have been produced.\n\tassert.Empty(t, buff.String())\n\n\t// Now, let's remove source file, and run the task again to to prepare\n\t// for the next test.\n\terr := os.Remove(filepathext.SmartJoin(dir, \"bar.txt\"))\n\trequire.NoError(t, err)\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-bar\"}))\n\tbuff.Reset()\n\n\t// Global silence switched of, so we should see output unless the task itself\n\t// is silent.\n\te.Silent = false\n\n\t// all: not up-to-date\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-foo\"}))\n\tassert.Equal(t, \"task: [gen-foo] touch foo.txt\", strings.TrimSpace(buff.String()))\n\tbuff.Reset()\n\t// status: not up-to-date\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-foo\"}))\n\tassert.Equal(t, \"task: [gen-foo] touch foo.txt\", strings.TrimSpace(buff.String()))\n\tbuff.Reset()\n\n\t// sources: not up-to-date\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-bar\"}))\n\tassert.Equal(t, \"task: [gen-bar] touch bar.txt\", strings.TrimSpace(buff.String()))\n\tbuff.Reset()\n\t// all: up-to-date\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-bar\"}))\n\tassert.Equal(t, `task: Task \"gen-bar\" is up to date`, strings.TrimSpace(buff.String()))\n\tbuff.Reset()\n\n\t// sources: not up-to-date, no output produced.\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-silent-baz\"}))\n\tassert.Empty(t, buff.String())\n\n\t// up-to-date, no output produced\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-silent-baz\"}))\n\tassert.Empty(t, buff.String())\n\n\te.Verbose = true\n\t// up-to-date, output produced due to Verbose mode.\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"gen-silent-baz\"}))\n\tassert.Equal(t, `task: Task \"gen-silent-baz\" is up to date`, strings.TrimSpace(buff.String()))\n\tbuff.Reset()\n}\n\nfunc TestPrecondition(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/precondition\"\n\n\tvar buff bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\n\t// A precondition that has been met\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"foo\"}))\n\tif buff.String() != \"\" {\n\t\tt.Errorf(\"Got Output when none was expected: %s\", buff.String())\n\t}\n\n\t// A precondition that was not met\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"impossible\"}))\n\n\tif buff.String() != \"task: 1 != 0 obviously!\\n\" {\n\t\tt.Errorf(\"Wrong output message: %s\", buff.String())\n\t}\n\tbuff.Reset()\n\n\t// Calling a task with a precondition in a dependency fails the task\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"depends_on_impossible\"}))\n\n\tif buff.String() != \"task: 1 != 0 obviously!\\n\" {\n\t\tt.Errorf(\"Wrong output message: %s\", buff.String())\n\t}\n\tbuff.Reset()\n\n\t// Calling a task with a precondition in a cmd fails the task\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"executes_failing_task_as_cmd\"}))\n\tif buff.String() != \"task: 1 != 0 obviously!\\n\" {\n\t\tt.Errorf(\"Wrong output message: %s\", buff.String())\n\t}\n\tbuff.Reset()\n}\n\nfunc TestGenerates(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/generates\"\n\n\tconst (\n\t\tsrcTask        = \"sub/src.txt\"\n\t\trelTask        = \"rel.txt\"\n\t\tabsTask        = \"abs.txt\"\n\t\tfileWithSpaces = \"my text file.txt\"\n\t)\n\n\tsrcFile := filepathext.SmartJoin(dir, srcTask)\n\n\tfor _, task := range []string{srcTask, relTask, absTask, fileWithSpaces} {\n\t\tpath := filepathext.SmartJoin(dir, task)\n\t\t_ = os.Remove(path)\n\t\tif _, err := os.Stat(path); err == nil {\n\t\t\tt.Errorf(\"File should not exist: %v\", err)\n\t\t}\n\t}\n\n\tbuff := bytes.NewBuffer(nil)\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: buff,\n\t\tStderr: buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\tfor _, theTask := range []string{relTask, absTask, fileWithSpaces} {\n\t\tdestFile := filepathext.SmartJoin(dir, theTask)\n\t\tupToDate := fmt.Sprintf(\"task: Task \\\"%s\\\" is up to date\\n\", srcTask) +\n\t\t\tfmt.Sprintf(\"task: Task \\\"%s\\\" is up to date\\n\", theTask)\n\n\t\t// Run task for the first time.\n\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: theTask}))\n\n\t\tif _, err := os.Stat(srcFile); err != nil {\n\t\t\tt.Errorf(\"File should exist: %v\", err)\n\t\t}\n\t\tif _, err := os.Stat(destFile); err != nil {\n\t\t\tt.Errorf(\"File should exist: %v\", err)\n\t\t}\n\t\t// Ensure task was not incorrectly found to be up-to-date on first run.\n\t\tif buff.String() == upToDate {\n\t\t\tt.Errorf(\"Wrong output message: %s\", buff.String())\n\t\t}\n\t\tbuff.Reset()\n\n\t\t// Re-run task to ensure it's now found to be up-to-date.\n\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: theTask}))\n\t\tif buff.String() != upToDate {\n\t\t\tt.Errorf(\"Wrong output message: %s\", buff.String())\n\t\t}\n\t\tbuff.Reset()\n\t}\n}\n\nfunc TestStatusChecksum(t *testing.T) { // nolint:paralleltest // cannot run in parallel\n\tconst dir = \"testdata/checksum\"\n\n\ttests := []struct {\n\t\tfiles []string\n\t\ttask  string\n\t}{\n\t\t{[]string{\"generated.txt\", \".task/checksum/build\"}, \"build\"},\n\t\t{[]string{\"generated.txt\", \".task/checksum/build-with-status\"}, \"build-with-status\"},\n\t}\n\n\tfor _, test := range tests { // nolint:paralleltest // cannot run in parallel\n\t\tt.Run(test.task, func(t *testing.T) {\n\t\t\tfor _, f := range test.files {\n\t\t\t\t_ = os.Remove(filepathext.SmartJoin(dir, f))\n\n\t\t\t\t_, err := os.Stat(filepathext.SmartJoin(dir, f))\n\t\t\t\trequire.Error(t, err)\n\t\t\t}\n\n\t\t\tvar buff bytes.Buffer\n\t\t\ttempdir := task.TempDir{\n\t\t\t\tRemote:      filepathext.SmartJoin(dir, \".task\"),\n\t\t\t\tFingerprint: filepathext.SmartJoin(dir, \".task\"),\n\t\t\t}\n\t\t\te := task.Executor{\n\t\t\t\tDir:     dir,\n\t\t\t\tTempDir: tempdir,\n\t\t\t\tStdout:  &buff,\n\t\t\t\tStderr:  &buff,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: test.task}))\n\t\t\tfor _, f := range test.files {\n\t\t\t\t_, err := os.Stat(filepathext.SmartJoin(dir, f))\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\n\t\t\t// Capture the modification time, so we can ensure the checksum file\n\t\t\t// is not regenerated when the hash hasn't changed.\n\t\t\ts, err := os.Stat(filepathext.SmartJoin(tempdir.Fingerprint, \"checksum/\"+test.task))\n\t\t\trequire.NoError(t, err)\n\t\t\ttime := s.ModTime()\n\n\t\t\tbuff.Reset()\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: test.task}))\n\t\t\tassert.Equal(t, `task: Task \"`+test.task+`\" is up to date`+\"\\n\", buff.String())\n\n\t\t\ts, err = os.Stat(filepathext.SmartJoin(tempdir.Fingerprint, \"checksum/\"+test.task))\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, time, s.ModTime())\n\t\t})\n\t}\n}\n\nfunc TestAlias(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/alias\"\n\n\tdata, err := os.ReadFile(filepathext.SmartJoin(dir, \"alias.txt\"))\n\trequire.NoError(t, err)\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"f\"}))\n\tassert.Equal(t, string(data), buff.String())\n}\n\nfunc TestDuplicateAlias(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/alias\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"x\"}))\n\tassert.Equal(t, \"\", buff.String())\n}\n\nfunc TestAliasSummary(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/alias\"\n\n\tdata, err := os.ReadFile(filepathext.SmartJoin(dir, \"alias-summary.txt\"))\n\trequire.NoError(t, err)\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:     dir,\n\t\tSummary: true,\n\t\tStdout:  &buff,\n\t\tStderr:  &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"f\"}))\n\tassert.Equal(t, string(data), buff.String())\n}\n\nfunc TestLabelUpToDate(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/label_uptodate\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"foo\"}))\n\tassert.Contains(t, buff.String(), \"foobar\")\n}\n\nfunc TestLabelSummary(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/label_summary\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:     dir,\n\t\tSummary: true,\n\t\tStdout:  &buff,\n\t\tStderr:  &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"foo\"}))\n\tassert.Contains(t, buff.String(), \"foobar\")\n}\n\nfunc TestLabelInStatus(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/label_status\"\n\n\te := task.Executor{\n\t\tDir: dir,\n\t}\n\trequire.NoError(t, e.Setup())\n\terr := e.Status(context.Background(), &ast.Call{Task: \"foo\"})\n\tassert.ErrorContains(t, err, \"foobar\")\n}\n\nfunc TestLabelWithVariableExpansion(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/label_var\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"foo\"}))\n\tassert.Contains(t, buff.String(), \"foobaz\")\n}\n\nfunc TestLabelInSummary(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/label_summary\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"foo\"}))\n\tassert.Contains(t, buff.String(), \"foobar\")\n}\n\nfunc TestPromptInSummary(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/prompt\"\n\ttests := []struct {\n\t\tname      string\n\t\tinput     string\n\t\twantError bool\n\t}{\n\t\t{\"test short approval\", \"y\\n\", false},\n\t\t{\"test long approval\", \"yes\\n\", false},\n\t\t{\"test uppercase approval\", \"Y\\n\", false},\n\t\t{\"test stops task\", \"n\\n\", true},\n\t\t{\"test junk value stops task\", \"foobar\\n\", true},\n\t\t{\"test Enter stops task\", \"\\n\", true},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar inBuff bytes.Buffer\n\t\t\tvar outBuff bytes.Buffer\n\t\t\tvar errBuff bytes.Buffer\n\n\t\t\tinBuff.Write([]byte(test.input))\n\n\t\t\te := task.Executor{\n\t\t\t\tDir:        dir,\n\t\t\t\tStdin:      &inBuff,\n\t\t\t\tStdout:     &outBuff,\n\t\t\t\tStderr:     &errBuff,\n\t\t\t\tAssumeTerm: true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: \"foo\"})\n\n\t\t\tif test.wantError {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPromptWithIndirectTask(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/prompt\"\n\tvar inBuff bytes.Buffer\n\tvar outBuff bytes.Buffer\n\tvar errBuff bytes.Buffer\n\n\tinBuff.Write([]byte(\"y\\n\"))\n\n\te := task.Executor{\n\t\tDir:        dir,\n\t\tStdin:      &inBuff,\n\t\tStdout:     &outBuff,\n\t\tStderr:     &errBuff,\n\t\tAssumeTerm: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"bar\"})\n\tassert.Contains(t, outBuff.String(), \"show-prompt\")\n\trequire.NoError(t, err)\n}\n\nfunc TestPromptAssumeYes(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/prompt\"\n\ttests := []struct {\n\t\tname      string\n\t\tassumeYes bool\n\t}{\n\t\t{\"--yes flag should skip prompt\", true},\n\t\t{\"task should raise errors.TaskCancelledError\", false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar inBuff bytes.Buffer\n\t\t\tvar outBuff bytes.Buffer\n\t\t\tvar errBuff bytes.Buffer\n\n\t\t\t// always cancel the prompt so we can require.Error\n\t\t\tinBuff.Write([]byte(\"\\n\"))\n\n\t\t\te := task.Executor{\n\t\t\t\tDir:       dir,\n\t\t\t\tStdin:     &inBuff,\n\t\t\t\tStdout:    &outBuff,\n\t\t\t\tStderr:    &errBuff,\n\t\t\t\tAssumeYes: test.assumeYes,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: \"foo\"})\n\n\t\t\tif !test.assumeYes {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNoLabelInList(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/label_list\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\tif _, err := e.ListTasks(task.ListOptions{ListOnlyTasksWithDescriptions: true}); err != nil {\n\t\tt.Error(err)\n\t}\n\tassert.Contains(t, buff.String(), \"foo\")\n}\n\n// task -al case 1: listAll list all tasks\nfunc TestListAllShowsNoDesc(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/list_mixed_desc\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\n\tvar title string\n\tif _, err := e.ListTasks(task.ListOptions{ListAllTasks: true}); err != nil {\n\t\tt.Error(err)\n\t}\n\tfor _, title = range []string{\n\t\t\"foo\",\n\t\t\"voo\",\n\t\t\"doo\",\n\t} {\n\t\tassert.Contains(t, buff.String(), title)\n\t}\n}\n\n// task -al case 2: !listAll list some tasks (only those with desc)\nfunc TestListCanListDescOnly(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/list_mixed_desc\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\tif _, err := e.ListTasks(task.ListOptions{ListOnlyTasksWithDescriptions: true}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tvar title string\n\tassert.Contains(t, buff.String(), \"foo\")\n\tfor _, title = range []string{\n\t\t\"voo\",\n\t\t\"doo\",\n\t} {\n\t\tassert.NotContains(t, buff.String(), title)\n\t}\n}\n\nfunc TestListDescInterpolation(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/list_desc_interpolation\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\tif _, err := e.ListTasks(task.ListOptions{ListOnlyTasksWithDescriptions: true}); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tassert.Contains(t, buff.String(), \"foo-var\")\n\tassert.Contains(t, buff.String(), \"bar-var\")\n}\n\nfunc TestStatusVariables(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/status_vars\"\n\n\t_ = os.RemoveAll(filepathext.SmartJoin(dir, \".task\"))\n\t_ = os.Remove(filepathext.SmartJoin(dir, \"generated.txt\"))\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir: dir,\n\t\tTempDir: task.TempDir{\n\t\t\tRemote:      filepathext.SmartJoin(dir, \".task\"),\n\t\t\tFingerprint: filepathext.SmartJoin(dir, \".task\"),\n\t\t},\n\t\tStdout:  &buff,\n\t\tStderr:  &buff,\n\t\tSilent:  false,\n\t\tVerbose: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"build\"}))\n\n\tassert.Contains(t, buff.String(), \"3e464c4b03f4b65d740e1e130d4d108a\")\n\n\tinf, err := os.Stat(filepathext.SmartJoin(dir, \"source.txt\"))\n\trequire.NoError(t, err)\n\tts := fmt.Sprintf(\"%d\", inf.ModTime().Unix())\n\ttf := inf.ModTime().String()\n\n\tassert.Contains(t, buff.String(), ts)\n\tassert.Contains(t, buff.String(), tf)\n}\n\nfunc TestCmdsVariables(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/cmds_vars\"\n\n\t_ = os.RemoveAll(filepathext.SmartJoin(dir, \".task\"))\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir: dir,\n\t\tTempDir: task.TempDir{\n\t\t\tRemote:      filepathext.SmartJoin(dir, \".task\"),\n\t\t\tFingerprint: filepathext.SmartJoin(dir, \".task\"),\n\t\t},\n\t\tStdout:  &buff,\n\t\tStderr:  &buff,\n\t\tSilent:  false,\n\t\tVerbose: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"build\"}))\n\n\tassert.Contains(t, buff.String(), \"3e464c4b03f4b65d740e1e130d4d108a\")\n\n\tinf, err := os.Stat(filepathext.SmartJoin(dir, \"source.txt\"))\n\trequire.NoError(t, err)\n\tts := fmt.Sprintf(\"%d\", inf.ModTime().Unix())\n\ttf := inf.ModTime().String()\n\n\tassert.Contains(t, buff.String(), ts)\n\tassert.Contains(t, buff.String(), tf)\n}\n\nfunc TestInit(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/init\"\n\tfile := filepathext.SmartJoin(dir, \"Taskfile.yml\")\n\n\t_ = os.Remove(file)\n\tif _, err := os.Stat(file); err == nil {\n\t\tt.Errorf(\"Taskfile.yml should not exist\")\n\t}\n\n\tif err := task.InitTaskfile(io.Discard, dir); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif _, err := os.Stat(file); err != nil {\n\t\tt.Errorf(\"Taskfile.yml should exist\")\n\t}\n\t_ = os.Remove(file)\n}\n\nfunc TestCyclicDep(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/cyclic\"\n\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\trequire.NoError(t, e.Setup())\n\tassert.IsType(t, &errors.TaskCalledTooManyTimesError{}, e.Run(context.Background(), &ast.Call{Task: \"task-1\"}))\n}\n\nfunc TestTaskVersion(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tDir     string\n\t\tVersion *semver.Version\n\t\twantErr bool\n\t}{\n\t\t{\"testdata/version/v1\", semver.MustParse(\"1\"), true},\n\t\t{\"testdata/version/v2\", semver.MustParse(\"2\"), true},\n\t\t{\"testdata/version/v3\", semver.MustParse(\"3\"), false},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.Dir, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\te := task.Executor{\n\t\t\t\tDir:    test.Dir,\n\t\t\t\tStdout: io.Discard,\n\t\t\t\tStderr: io.Discard,\n\t\t\t}\n\t\t\terr := e.Setup()\n\t\t\tif test.wantErr {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, test.Version, e.Taskfile.Version)\n\t\t\tassert.Equal(t, 2, e.Taskfile.Tasks.Len())\n\t\t})\n\t}\n}\n\nfunc TestTaskIgnoreErrors(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/ignore_errors\"\n\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"task-should-pass\"}))\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"task-should-fail\"}))\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"cmd-should-pass\"}))\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"cmd-should-fail\"}))\n}\n\nfunc TestExpand(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/expand\"\n\n\thome, err := os.UserHomeDir()\n\tif err != nil {\n\t\tt.Errorf(\"Couldn't get $HOME: %v\", err)\n\t}\n\tvar buff bytes.Buffer\n\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"pwd\"}))\n\tassert.Equal(t, home, strings.TrimSpace(buff.String()))\n}\n\nfunc TestDry(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/dry\"\n\n\tfile := filepathext.SmartJoin(dir, \"file.txt\")\n\t_ = os.Remove(file)\n\n\tvar buff bytes.Buffer\n\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tDry:    true,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"build\"}))\n\n\tassert.Equal(t, \"task: [build] touch file.txt\", strings.TrimSpace(buff.String()))\n\tif _, err := os.Stat(file); err == nil {\n\t\tt.Errorf(\"File should not exist %s\", file)\n\t}\n}\n\n// TestDryChecksum tests if the checksum file is not being written to disk\n// if the dry mode is enabled.\nfunc TestDryChecksum(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/dry_checksum\"\n\n\tchecksumFile := filepathext.SmartJoin(dir, \".task/checksum/default\")\n\t_ = os.Remove(checksumFile)\n\n\te := task.Executor{\n\t\tDir: dir,\n\t\tTempDir: task.TempDir{\n\t\t\tRemote:      filepathext.SmartJoin(dir, \".task\"),\n\t\t\tFingerprint: filepathext.SmartJoin(dir, \".task\"),\n\t\t},\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t\tDry:    true,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\n\t_, err := os.Stat(checksumFile)\n\trequire.Error(t, err, \"checksum file should not exist\")\n\n\te.Dry = false\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\t_, err = os.Stat(checksumFile)\n\trequire.NoError(t, err, \"checksum file should exist\")\n}\n\nfunc TestIncludes(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"main.txt\":                                  \"main\",\n\t\t\t\"included_directory.txt\":                    \"included_directory\",\n\t\t\t\"included_directory_without_dir.txt\":        \"included_directory_without_dir\",\n\t\t\t\"included_taskfile_without_dir.txt\":         \"included_taskfile_without_dir\",\n\t\t\t\"./module2/included_directory_with_dir.txt\": \"included_directory_with_dir\",\n\t\t\t\"./module2/included_taskfile_with_dir.txt\":  \"included_taskfile_with_dir\",\n\t\t\t\"os_include.txt\":                            \"os\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesMultiLevel(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes_multi_level\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"called_one.txt\":   \"one\",\n\t\t\t\"called_two.txt\":   \"two\",\n\t\t\t\"called_three.txt\": \"three\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesRemote(t *testing.T) {\n\tenableExperimentForTest(t, &experiments.RemoteTaskfiles, \"1\")\n\n\tdir := \"testdata/includes_remote\"\n\n\tsrv := httptest.NewServer(http.FileServer(http.Dir(dir)))\n\tdefer srv.Close()\n\n\ttcs := []struct {\n\t\tfirstRemote  string\n\t\tsecondRemote string\n\t}{\n\t\t{\n\t\t\tfirstRemote:  srv.URL + \"/first/Taskfile.yml\",\n\t\t\tsecondRemote: srv.URL + \"/first/second/Taskfile.yml\",\n\t\t},\n\t\t{\n\t\t\tfirstRemote:  srv.URL + \"/first/Taskfile.yml\",\n\t\t\tsecondRemote: \"./second/Taskfile.yml\",\n\t\t},\n\t}\n\n\ttasks := []string{\n\t\t\"first:write-file\",\n\t\t\"first:second:write-file\",\n\t}\n\n\tfor i, tc := range tcs {\n\t\tt.Run(fmt.Sprint(i), func(t *testing.T) {\n\t\t\tt.Setenv(\"FIRST_REMOTE_URL\", tc.firstRemote)\n\t\t\tt.Setenv(\"SECOND_REMOTE_URL\", tc.secondRemote)\n\n\t\t\tvar buff SyncBuffer\n\n\t\t\texecutors := []struct {\n\t\t\t\tname     string\n\t\t\t\texecutor *task.Executor\n\t\t\t}{\n\t\t\t\t{\n\t\t\t\t\tname: \"online, always download\",\n\t\t\t\t\texecutor: &task.Executor{\n\t\t\t\t\t\tDir:      dir,\n\t\t\t\t\t\tStdout:   &buff,\n\t\t\t\t\t\tStderr:   &buff,\n\t\t\t\t\t\tTimeout:  time.Minute,\n\t\t\t\t\t\tInsecure: true,\n\t\t\t\t\t\tLogger:   &logger.Logger{Stdout: &buff, Stderr: &buff, Verbose: true},\n\n\t\t\t\t\t\t// Without caching\n\t\t\t\t\t\tAssumeYes: true,\n\t\t\t\t\t\tDownload:  true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: \"offline, use cache\",\n\t\t\t\t\texecutor: &task.Executor{\n\t\t\t\t\t\tDir:      dir,\n\t\t\t\t\t\tStdout:   &buff,\n\t\t\t\t\t\tStderr:   &buff,\n\t\t\t\t\t\tTimeout:  time.Minute,\n\t\t\t\t\t\tInsecure: true,\n\t\t\t\t\t\tLogger:   &logger.Logger{Stdout: &buff, Stderr: &buff, Verbose: true},\n\n\t\t\t\t\t\t// With caching\n\t\t\t\t\t\tAssumeYes: false,\n\t\t\t\t\t\tDownload:  false,\n\t\t\t\t\t\tOffline:   true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tfor j, e := range executors {\n\t\t\t\tt.Run(fmt.Sprint(j), func(t *testing.T) {\n\t\t\t\t\trequire.NoError(t, e.executor.Setup())\n\n\t\t\t\t\tfor k, task := range tasks {\n\t\t\t\t\t\tt.Run(task, func(t *testing.T) {\n\t\t\t\t\t\t\texpectedContent := fmt.Sprint(rand.Int64())\n\t\t\t\t\t\t\tt.Setenv(\"CONTENT\", expectedContent)\n\n\t\t\t\t\t\t\toutputFile := fmt.Sprintf(\"%d.%d.txt\", i, k)\n\t\t\t\t\t\t\tt.Setenv(\"OUTPUT_FILE\", outputFile)\n\n\t\t\t\t\t\t\tpath := filepath.Join(dir, outputFile)\n\t\t\t\t\t\t\trequire.NoError(t, os.RemoveAll(path))\n\n\t\t\t\t\t\t\trequire.NoError(t, e.executor.Run(context.Background(), &ast.Call{Task: task}))\n\n\t\t\t\t\t\t\tactualContent, err := os.ReadFile(path)\n\t\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\t\tassert.Equal(t, expectedContent, strings.TrimSpace(string(actualContent)))\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tt.Log(\"\\noutput:\\n\", buff.buf.String())\n\t\t})\n\t}\n}\n\nfunc TestIncludeCycle(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/includes_cycle\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: true,\n\t}\n\n\terr := e.Setup()\n\trequire.Error(t, err)\n\tassert.Contains(t, err.Error(), \"task: include cycle detected between\")\n}\n\nfunc TestIncludesIncorrect(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/includes_incorrect\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: true,\n\t}\n\n\terr := e.Setup()\n\trequire.Error(t, err)\n\tassert.Contains(t, err.Error(), \"Failed to parse testdata/includes_incorrect/incomplete.yml:\", err.Error())\n}\n\nfunc TestIncludesEmptyMain(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes_empty\",\n\t\tTarget:    \"included:default\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"file.txt\": \"default\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesHttp(t *testing.T) {\n\tenableExperimentForTest(t, &experiments.RemoteTaskfiles, \"1\")\n\n\tdir, err := filepath.Abs(\"testdata/includes_http\")\n\trequire.NoError(t, err)\n\n\tsrv := httptest.NewServer(http.FileServer(http.Dir(dir)))\n\tdefer srv.Close()\n\n\tt.Cleanup(func() {\n\t\t// This test fills the .task/remote directory with cache entries because the include URL\n\t\t// is different on every test due to the dynamic nature of the TCP port in srv.URL\n\t\tif err := os.RemoveAll(filepath.Join(dir, \".task\")); err != nil {\n\t\t\tt.Logf(\"error cleaning up: %s\", err)\n\t\t}\n\t})\n\n\ttaskfiles, err := fs.Glob(os.DirFS(dir), \"root-taskfile-*.yml\")\n\trequire.NoError(t, err)\n\n\tremotes := []struct {\n\t\tname string\n\t\troot string\n\t}{\n\t\t{\n\t\t\tname: \"local\",\n\t\t\troot: \".\",\n\t\t},\n\t\t{\n\t\t\tname: \"http-remote\",\n\t\t\troot: srv.URL,\n\t\t},\n\t}\n\n\tfor _, taskfile := range taskfiles {\n\t\tt.Run(taskfile, func(t *testing.T) {\n\t\t\tfor _, remote := range remotes {\n\t\t\t\tt.Run(remote.name, func(t *testing.T) {\n\t\t\t\t\tt.Setenv(\"INCLUDE_ROOT\", remote.root)\n\t\t\t\t\tentrypoint := filepath.Join(dir, taskfile)\n\n\t\t\t\t\tvar buff SyncBuffer\n\t\t\t\t\te := task.Executor{\n\t\t\t\t\t\tEntrypoint: entrypoint,\n\t\t\t\t\t\tDir:        dir,\n\t\t\t\t\t\tStdout:     &buff,\n\t\t\t\t\t\tStderr:     &buff,\n\t\t\t\t\t\tInsecure:   true,\n\t\t\t\t\t\tDownload:   true,\n\t\t\t\t\t\tAssumeYes:  true,\n\t\t\t\t\t\tLogger:     &logger.Logger{Stdout: &buff, Stderr: &buff, Verbose: true},\n\t\t\t\t\t\tTimeout:    time.Minute,\n\t\t\t\t\t}\n\t\t\t\t\trequire.NoError(t, e.Setup())\n\t\t\t\t\tdefer func() { t.Log(\"output:\", buff.buf.String()) }()\n\n\t\t\t\t\ttcs := []struct {\n\t\t\t\t\t\tname, dir string\n\t\t\t\t\t}{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: \"second-with-dir-1:third-with-dir-1:default\",\n\t\t\t\t\t\t\tdir:  filepath.Join(dir, \"dir-1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: \"second-with-dir-1:third-with-dir-2:default\",\n\t\t\t\t\t\t\tdir:  filepath.Join(dir, \"dir-2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tfor _, tc := range tcs {\n\t\t\t\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\t\t\t\ttask, err := e.CompiledTask(&ast.Call{Task: tc.name})\n\t\t\t\t\t\t\trequire.NoError(t, err)\n\t\t\t\t\t\t\tassert.Equal(t, tc.dir, task.Dir)\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIncludesDependencies(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes_deps\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"default.txt\":     \"default\",\n\t\t\t\"called_dep.txt\":  \"called_dep\",\n\t\t\t\"called_task.txt\": \"called_task\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesCallingRoot(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes_call_root_task\",\n\t\tTarget:    \"included:call-root\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"root_task.txt\": \"root task\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesOptional(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes_optional\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"called_dep.txt\": \"called_dep\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesOptionalImplicitFalse(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/includes_optional_implicit_false\"\n\twd, _ := os.Getwd()\n\n\tmessage := \"stat %s/%s/TaskfileOptional.yml: no such file or directory\"\n\texpected := fmt.Sprintf(message, wd, dir)\n\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\n\terr := e.Setup()\n\trequire.Error(t, err)\n\tassert.Equal(t, expected, err.Error())\n}\n\nfunc TestIncludesOptionalExplicitFalse(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/includes_optional_explicit_false\"\n\twd, _ := os.Getwd()\n\n\tmessage := \"stat %s/%s/TaskfileOptional.yml: no such file or directory\"\n\texpected := fmt.Sprintf(message, wd, dir)\n\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\n\terr := e.Setup()\n\trequire.Error(t, err)\n\tassert.Equal(t, expected, err.Error())\n}\n\nfunc TestIncludesFromCustomTaskfile(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tEntrypoint: \"testdata/includes_yaml/Custom.ext\",\n\t\tDir:        \"testdata/includes_yaml\",\n\t\tTarget:     \"default\",\n\t\tTrimSpace:  true,\n\t\tFiles: map[string]string{\n\t\t\t\"main.txt\":                         \"main\",\n\t\t\t\"included_with_yaml_extension.txt\": \"included_with_yaml_extension\",\n\t\t\t\"included_with_custom_file.txt\":    \"included_with_custom_file\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesRelativePath(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/includes_rel_path\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"common:pwd\"}))\n\tassert.Contains(t, buff.String(), \"testdata/includes_rel_path/common\")\n\n\tbuff.Reset()\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"included:common:pwd\"}))\n\tassert.Contains(t, buff.String(), \"testdata/includes_rel_path/common\")\n}\n\nfunc TestIncludesInternal(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/internal_task\"\n\ttests := []struct {\n\t\tname           string\n\t\ttask           string\n\t\texpectedErr    bool\n\t\texpectedOutput string\n\t}{\n\t\t{\"included internal task via task\", \"task-1\", false, \"Hello, World!\\n\"},\n\t\t{\"included internal task via dep\", \"task-2\", false, \"Hello, World!\\n\"},\n\t\t{\"included internal direct\", \"included:task-3\", true, \"task: No tasks with description available. Try --list-all to list all tasks\\n\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    dir,\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: test.task})\n\t\t\tif test.expectedErr {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, test.expectedOutput, buff.String())\n\t\t})\n\t}\n}\n\nfunc TestIncludesFlatten(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/includes_flatten\"\n\ttests := []struct {\n\t\tname           string\n\t\ttaskfile       string\n\t\ttask           string\n\t\texpectedErr    bool\n\t\texpectedOutput string\n\t}{\n\t\t{name: \"included flatten\", taskfile: \"Taskfile.yml\", task: \"gen\", expectedOutput: \"gen from included\\n\"},\n\t\t{name: \"included flatten with default\", taskfile: \"Taskfile.yml\", task: \"default\", expectedOutput: \"default from included flatten\\n\"},\n\t\t{name: \"included flatten can call entrypoint tasks\", taskfile: \"Taskfile.yml\", task: \"from_entrypoint\", expectedOutput: \"from entrypoint\\n\"},\n\t\t{name: \"included flatten with deps\", taskfile: \"Taskfile.yml\", task: \"with_deps\", expectedOutput: \"gen from included\\nwith_deps from included\\n\"},\n\t\t{name: \"included flatten nested\", taskfile: \"Taskfile.yml\", task: \"from_nested\", expectedOutput: \"from nested\\n\"},\n\t\t{name: \"included flatten multiple same task\", taskfile: \"Taskfile.multiple.yml\", task: \"gen\", expectedErr: true, expectedOutput: \"task: Found multiple tasks (gen) included by \\\"included\\\"\\\"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:        dir,\n\t\t\t\tEntrypoint: dir + \"/\" + test.taskfile,\n\t\t\t\tStdout:     &buff,\n\t\t\t\tStderr:     &buff,\n\t\t\t\tSilent:     true,\n\t\t\t}\n\t\t\terr := e.Setup()\n\t\t\tif test.expectedErr {\n\t\t\t\tassert.EqualError(t, err, test.expectedOutput)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\t_ = e.Run(context.Background(), &ast.Call{Task: test.task})\n\t\t\t\tassert.Equal(t, test.expectedOutput, buff.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestIncludesInterpolation(t *testing.T) { // nolint:paralleltest // cannot run in parallel\n\tconst dir = \"testdata/includes_interpolation\"\n\ttests := []struct {\n\t\tname           string\n\t\ttask           string\n\t\texpectedErr    bool\n\t\texpectedOutput string\n\t}{\n\t\t{\"include\", \"include\", false, \"include\\n\"},\n\t\t{\"include_with_env_variable\", \"include-with-env-variable\", false, \"include_with_env_variable\\n\"},\n\t\t{\"include_with_dir\", \"include-with-dir\", false, \"included\\n\"},\n\t}\n\tt.Setenv(\"MODULE\", \"included\")\n\n\tfor _, test := range tests { // nolint:paralleltest // cannot run in parallel\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    filepath.Join(dir, test.name),\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: test.task})\n\t\t\tif test.expectedErr {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, test.expectedOutput, buff.String())\n\t\t})\n\t}\n}\n\nfunc TestIncludesWithExclude(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/includes_with_excludes\",\n\t\tSilent: true,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"included:bar\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"bar\\n\", buff.String())\n\tbuff.Reset()\n\n\terr = e.Run(context.Background(), &ast.Call{Task: \"included:foo\"})\n\trequire.Error(t, err)\n\tbuff.Reset()\n\n\terr = e.Run(context.Background(), &ast.Call{Task: \"bar\"})\n\trequire.Error(t, err)\n\tbuff.Reset()\n\n\terr = e.Run(context.Background(), &ast.Call{Task: \"foo\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"foo\\n\", buff.String())\n}\n\nfunc TestIncludedTaskfileVarMerging(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/included_taskfile_var_merging\"\n\ttests := []struct {\n\t\tname           string\n\t\ttask           string\n\t\texpectedOutput string\n\t}{\n\t\t{\"foo\", \"foo:pwd\", \"included_taskfile_var_merging/foo\\n\"},\n\t\t{\"bar\", \"bar:pwd\", \"included_taskfile_var_merging/bar\\n\"},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    dir,\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: test.task})\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Contains(t, buff.String(), test.expectedOutput)\n\t\t})\n\t}\n}\n\nfunc TestInternalTask(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/internal_task\"\n\ttests := []struct {\n\t\tname           string\n\t\ttask           string\n\t\texpectedErr    bool\n\t\texpectedOutput string\n\t}{\n\t\t{\"internal task via task\", \"task-1\", false, \"Hello, World!\\n\"},\n\t\t{\"internal task via dep\", \"task-2\", false, \"Hello, World!\\n\"},\n\t\t{\"internal direct\", \"task-3\", true, \"\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    dir,\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: test.task})\n\t\t\tif test.expectedErr {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t\tassert.Equal(t, test.expectedOutput, buff.String())\n\t\t})\n\t}\n}\n\nfunc TestIncludesShadowedDefault(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes_shadowed_default\",\n\t\tTarget:    \"included\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"file.txt\": \"shadowed\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestIncludesUnshadowedDefault(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/includes_unshadowed_default\",\n\t\tTarget:    \"included\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"file.txt\": \"included\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestSupportedFileNames(t *testing.T) {\n\tt.Parallel()\n\n\tfileNames := []string{\n\t\t\"Taskfile.yml\",\n\t\t\"Taskfile.yaml\",\n\t\t\"Taskfile.dist.yml\",\n\t\t\"Taskfile.dist.yaml\",\n\t}\n\tfor _, fileName := range fileNames {\n\t\tt.Run(fileName, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\ttt := fileContentTest{\n\t\t\t\tDir:       fmt.Sprintf(\"testdata/file_names/%s\", fileName),\n\t\t\t\tTarget:    \"default\",\n\t\t\t\tTrimSpace: true,\n\t\t\t\tFiles: map[string]string{\n\t\t\t\t\t\"output.txt\": \"hello\",\n\t\t\t\t},\n\t\t\t}\n\t\t\ttt.Run(t)\n\t\t})\n\t}\n}\n\nfunc TestSummary(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/summary\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:     dir,\n\t\tStdout:  &buff,\n\t\tStderr:  &buff,\n\t\tSummary: true,\n\t\tSilent:  true,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"task-with-summary\"}, &ast.Call{Task: \"other-task-with-summary\"}))\n\n\tdata, err := os.ReadFile(filepathext.SmartJoin(dir, \"task-with-summary.txt\"))\n\trequire.NoError(t, err)\n\n\texpectedOutput := string(data)\n\tif runtime.GOOS == \"windows\" {\n\t\texpectedOutput = strings.ReplaceAll(expectedOutput, \"\\r\\n\", \"\\n\")\n\t}\n\n\tassert.Equal(t, expectedOutput, buff.String())\n}\n\nfunc TestWhenNoDirAttributeItRunsInSameDirAsTaskfile(t *testing.T) {\n\tt.Parallel()\n\n\tconst expected = \"dir\"\n\tconst dir = \"testdata/\" + expected\n\tvar out bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &out,\n\t\tStderr: &out,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"whereami\"}))\n\n\t// got should be the \"dir\" part of \"testdata/dir\"\n\tgot := strings.TrimSuffix(filepath.Base(out.String()), \"\\n\")\n\tassert.Equal(t, expected, got, \"Mismatch in the working directory\")\n}\n\nfunc TestWhenDirAttributeAndDirExistsItRunsInThatDir(t *testing.T) {\n\tt.Parallel()\n\n\tconst expected = \"exists\"\n\tconst dir = \"testdata/dir/explicit_exists\"\n\tvar out bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &out,\n\t\tStderr: &out,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"whereami\"}))\n\n\tgot := strings.TrimSuffix(filepath.Base(out.String()), \"\\n\")\n\tassert.Equal(t, expected, got, \"Mismatch in the working directory\")\n}\n\nfunc TestWhenDirAttributeItCreatesMissingAndRunsInThatDir(t *testing.T) {\n\tt.Parallel()\n\n\tconst expected = \"createme\"\n\tconst dir = \"testdata/dir/explicit_doesnt_exist/\"\n\tconst toBeCreated = dir + expected\n\tconst target = \"whereami\"\n\tvar out bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &out,\n\t\tStderr: &out,\n\t}\n\n\t// Ensure that the directory to be created doesn't actually exist.\n\t_ = os.RemoveAll(toBeCreated)\n\tif _, err := os.Stat(toBeCreated); err == nil {\n\t\tt.Errorf(\"Directory should not exist: %v\", err)\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: target}))\n\n\tgot := strings.TrimSuffix(filepath.Base(out.String()), \"\\n\")\n\tassert.Equal(t, expected, got, \"Mismatch in the working directory\")\n\n\t// Clean-up after ourselves only if no error.\n\t_ = os.RemoveAll(toBeCreated)\n}\n\nfunc TestDynamicVariablesRunOnTheNewCreatedDir(t *testing.T) {\n\tt.Parallel()\n\n\tconst expected = \"created\"\n\tconst dir = \"testdata/dir/dynamic_var_on_created_dir/\"\n\tconst toBeCreated = dir + expected\n\tconst target = \"default\"\n\tvar out bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &out,\n\t\tStderr: &out,\n\t}\n\n\t// Ensure that the directory to be created doesn't actually exist.\n\t_ = os.RemoveAll(toBeCreated)\n\tif _, err := os.Stat(toBeCreated); err == nil {\n\t\tt.Errorf(\"Directory should not exist: %v\", err)\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: target}))\n\n\tgot := strings.TrimSuffix(filepath.Base(out.String()), \"\\n\")\n\tassert.Equal(t, expected, got, \"Mismatch in the working directory\")\n\n\t// Clean-up after ourselves only if no error.\n\t_ = os.RemoveAll(toBeCreated)\n}\n\nfunc TestDynamicVariablesShouldRunOnTheTaskDir(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dir/dynamic_var\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"subdirectory/from_root_taskfile.txt\":          \"subdirectory\\n\",\n\t\t\t\"subdirectory/from_included_taskfile.txt\":      \"subdirectory\\n\",\n\t\t\t\"subdirectory/from_included_taskfile_task.txt\": \"subdirectory\\n\",\n\t\t\t\"subdirectory/from_interpolated_dir.txt\":       \"subdirectory\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestDisplaysErrorOnVersion1Schema(t *testing.T) {\n\tt.Parallel()\n\n\te := task.Executor{\n\t\tDir:    \"testdata/version/v1\",\n\t\tStdout: io.Discard,\n\t\tStderr: io.Discard,\n\t}\n\terr := e.Setup()\n\trequire.Error(t, err)\n\tassert.Regexp(t, regexp.MustCompile(`task: Invalid schema version in Taskfile \\\".*testdata\\/version\\/v1\\/Taskfile\\.yml\\\":\\nSchema version \\(1\\.0\\.0\\) no longer supported\\. Please use v3 or above`), err.Error())\n}\n\nfunc TestDisplaysErrorOnVersion2Schema(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/version/v2\",\n\t\tStdout: io.Discard,\n\t\tStderr: &buff,\n\t}\n\terr := e.Setup()\n\trequire.Error(t, err)\n\tassert.Regexp(t, regexp.MustCompile(`task: Invalid schema version in Taskfile \\\".*testdata\\/version\\/v2\\/Taskfile\\.yml\\\":\\nSchema version \\(2\\.0\\.0\\) no longer supported\\. Please use v3 or above`), err.Error())\n}\n\nfunc TestShortTaskNotation(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/short_task_notation\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\tassert.Equal(t, \"string-slice-1\\nstring-slice-2\\nstring\\n\", buff.String())\n}\n\nfunc TestDotenvShouldIncludeAllEnvFiles(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv/default\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"include.txt\": \"INCLUDE1='from_include1' INCLUDE2='from_include2'\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestDotenvShouldErrorWhenIncludingDependantDotenvs(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:     \"testdata/dotenv/error_included_envs\",\n\t\tSummary: true,\n\t\tStdout:  &buff,\n\t\tStderr:  &buff,\n\t}\n\n\terr := e.Setup()\n\trequire.Error(t, err)\n\tassert.Contains(t, err.Error(), \"move the dotenv\")\n}\n\nfunc TestDotenvShouldAllowMissingEnv(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv/missing_env\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"include.txt\": \"INCLUDE1='' INCLUDE2=''\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestDotenvHasLocalEnvInPath(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv/local_env_in_path\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"var.txt\": \"VAR='var_in_dot_env_1'\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestDotenvHasLocalVarInPath(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv/local_var_in_path\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"var.txt\": \"VAR='var_in_dot_env_3'\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestDotenvHasEnvVarInPath(t *testing.T) { // nolint:paralleltest // cannot run in parallel\n\tt.Setenv(\"ENV_VAR\", \"testing\")\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv/env_var_in_path\",\n\t\tTarget:    \"default\",\n\t\tTrimSpace: false,\n\t\tFiles: map[string]string{\n\t\t\t\"var.txt\": \"VAR='var_in_dot_env_2'\\n\",\n\t\t},\n\t}\n\ttt.Run(t)\n}\n\nfunc TestTaskDotenvParseErrorMessage(t *testing.T) {\n\tt.Parallel()\n\n\te := task.Executor{\n\t\tDir: \"testdata/dotenv/parse_error\",\n\t}\n\n\tpath, _ := filepath.Abs(filepath.Join(e.Dir, \".env-with-error\"))\n\texpected := fmt.Sprintf(\"error reading env file %s:\", path)\n\n\terr := e.Setup()\n\trequire.ErrorContains(t, err, expected)\n}\n\nfunc TestTaskDotenv(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv_task/default\",\n\t\tTarget:    \"dotenv\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"dotenv.txt\": \"foo\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestTaskDotenvFail(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv_task/default\",\n\t\tTarget:    \"no-dotenv\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"no-dotenv.txt\": \"global\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestTaskDotenvOverriddenByEnv(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv_task/default\",\n\t\tTarget:    \"dotenv-overridden-by-env\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"dotenv-overridden-by-env.txt\": \"overridden\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestTaskDotenvWithVarName(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:       \"testdata/dotenv_task/default\",\n\t\tTarget:    \"dotenv-with-var-name\",\n\t\tTrimSpace: true,\n\t\tFiles: map[string]string{\n\t\t\t\"dotenv-with-var-name.txt\": \"foo\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestExitImmediately(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/exit_immediately\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\tassert.Contains(t, buff.String(), `\"this_should_fail\": executable file not found in $PATH`)\n}\n\nfunc TestRunOnlyRunsJobsHashOnce(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:    \"testdata/run\",\n\t\tTarget: \"generate-hash\",\n\t\tFiles: map[string]string{\n\t\t\t\"hash.txt\": \"starting 1\\n1\\n2\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestRunOnceSharedDeps(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/run_once_shared_deps\"\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:      dir,\n\t\tStdout:   &buff,\n\t\tStderr:   &buff,\n\t\tForceAll: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"build\"}))\n\n\trx := regexp.MustCompile(`task: \\[service-[a,b]:library:build\\] echo \"build library\"`)\n\tmatches := rx.FindAllStringSubmatch(buff.String(), -1)\n\tassert.Len(t, matches, 1)\n\tassert.Contains(t, buff.String(), `task: [service-a:build] echo \"build a\"`)\n\tassert.Contains(t, buff.String(), `task: [service-b:build] echo \"build b\"`)\n}\n\nfunc TestDeferredCmds(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/deferred\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\texpectedOutputOrder := strings.TrimSpace(`\ntask: [task-2] echo 'cmd ran'\ncmd ran\ntask: [task-2] exit 1\ntask: [task-2] echo 'failing' && exit 2\nfailing\necho ran\ntask-1 ran successfully\ntask: [task-1] echo 'task-1 ran successfully'\ntask-1 ran successfully\n`)\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"task-2\"}))\n\tassert.Contains(t, buff.String(), expectedOutputOrder)\n}\n\nfunc TestExitCodeZero(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/exit_code\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"exit-zero\"}))\n\tassert.Equal(t, \"FOO=bar - DYNAMIC_FOO=bar - EXIT_CODE=\", strings.TrimSpace(buff.String()))\n}\n\nfunc TestExitCodeOne(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/exit_code\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"exit-one\"}))\n\tassert.Equal(t, \"FOO=bar - DYNAMIC_FOO=bar - EXIT_CODE=1\", strings.TrimSpace(buff.String()))\n}\n\nfunc TestIgnoreNilElements(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname string\n\t\tdir  string\n\t}{\n\t\t{\"nil cmd\", \"testdata/ignore_nil_elements/cmds\"},\n\t\t{\"nil dep\", \"testdata/ignore_nil_elements/deps\"},\n\t\t{\"nil include\", \"testdata/ignore_nil_elements/includes\"},\n\t\t{\"nil precondition\", \"testdata/ignore_nil_elements/preconditions\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    test.dir,\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\t\t\tassert.Equal(t, \"string-slice-1\\n\", buff.String())\n\t\t})\n\t}\n}\n\nfunc TestOutputGroup(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/output_group\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\texpectedOutputOrder := strings.TrimSpace(`\ntask: [hello] echo 'Hello!'\n::group::hello\nHello!\n::endgroup::\ntask: [bye] echo 'Bye!'\n::group::bye\nBye!\n::endgroup::\n`)\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"bye\"}))\n\tt.Log(buff.String())\n\tassert.Equal(t, strings.TrimSpace(buff.String()), expectedOutputOrder)\n}\n\nfunc TestOutputGroupErrorOnlySwallowsOutputOnSuccess(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/output_group_error_only\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"passing\"}))\n\tt.Log(buff.String())\n\tassert.Empty(t, buff.String())\n}\n\nfunc TestOutputGroupErrorOnlyShowsOutputOnFailure(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/output_group_error_only\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: \"failing\"}))\n\tt.Log(buff.String())\n\tassert.Contains(t, \"failing-output\", strings.TrimSpace(buff.String()))\n\tassert.NotContains(t, \"passing\", strings.TrimSpace(buff.String()))\n}\n\nfunc TestIncludedVars(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/include_with_vars\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\texpectedOutputOrder := strings.TrimSpace(`\ntask: [included1:task1] echo \"VAR_1 is included1-var1\"\nVAR_1 is included1-var1\ntask: [included1:task1] echo \"VAR_2 is included-default-var2\"\nVAR_2 is included-default-var2\ntask: [included2:task1] echo \"VAR_1 is included2-var1\"\nVAR_1 is included2-var1\ntask: [included2:task1] echo \"VAR_2 is included-default-var2\"\nVAR_2 is included-default-var2\ntask: [included3:task1] echo \"VAR_1 is included-default-var1\"\nVAR_1 is included-default-var1\ntask: [included3:task1] echo \"VAR_2 is included-default-var2\"\nVAR_2 is included-default-var2\n`)\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"task1\"}))\n\tt.Log(buff.String())\n\tassert.Equal(t, strings.TrimSpace(buff.String()), expectedOutputOrder)\n}\n\nfunc TestIncludedVarsMultiLevel(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/include_with_vars_multi_level\"\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\texpectedOutputOrder := strings.TrimSpace(`\ntask: [lib:greet] echo 'Hello world'\nHello world\ntask: [foo:lib:greet] echo 'Hello foo'\nHello foo\ntask: [bar:lib:greet] echo 'Hello bar'\nHello bar\n`)\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\tt.Log(buff.String())\n\tassert.Equal(t, expectedOutputOrder, strings.TrimSpace(buff.String()))\n}\n\nfunc TestErrorCode(t *testing.T) {\n\tt.Parallel()\n\n\tconst dir = \"testdata/error_code\"\n\ttests := []struct {\n\t\tname     string\n\t\ttask     string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tname:     \"direct task\",\n\t\t\ttask:     \"direct\",\n\t\t\texpected: 42,\n\t\t}, {\n\t\t\tname:     \"indirect task\",\n\t\t\ttask:     \"indirect\",\n\t\t\texpected: 42,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := &task.Executor{\n\t\t\t\tDir:    dir,\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: test.task})\n\t\t\trequire.Error(t, err)\n\t\t\ttaskRunErr, ok := err.(*errors.TaskRunError)\n\t\t\tassert.True(t, ok, \"cannot cast returned error to *task.TaskRunError\")\n\t\t\tassert.Equal(t, test.expected, taskRunErr.TaskExitCode(), \"unexpected exit code from task\")\n\t\t})\n\t}\n}\n\nfunc TestEvaluateSymlinksInPaths(t *testing.T) { // nolint:paralleltest // cannot run in parallel\n\tconst dir = \"testdata/evaluate_symlinks_in_paths\"\n\tvar buff bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: false,\n\t}\n\ttests := []struct {\n\t\tname     string\n\t\ttask     string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"default (1)\",\n\t\t\ttask:     \"default\",\n\t\t\texpected: \"task: [default] echo \\\"some job\\\"\\nsome job\",\n\t\t},\n\t\t{\n\t\t\tname:     \"test-sym (1)\",\n\t\t\ttask:     \"test-sym\",\n\t\t\texpected: \"task: [test-sym] echo \\\"shared file source changed\\\" > src/shared/b\",\n\t\t},\n\t\t{\n\t\t\tname:     \"default (2)\",\n\t\t\ttask:     \"default\",\n\t\t\texpected: \"task: [default] echo \\\"some job\\\"\\nsome job\",\n\t\t},\n\t\t{\n\t\t\tname:     \"default (3)\",\n\t\t\ttask:     \"default\",\n\t\t\texpected: `task: Task \"default\" is up to date`,\n\t\t},\n\t\t{\n\t\t\tname:     \"reset\",\n\t\t\ttask:     \"reset\",\n\t\t\texpected: \"task: [reset] echo \\\"shared file source\\\" > src/shared/b\\ntask: [reset] echo \\\"file source\\\" > src/a\",\n\t\t},\n\t}\n\tfor _, test := range tests { // nolint:paralleltest // cannot run in parallel\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\terr := e.Run(context.Background(), &ast.Call{Task: test.task})\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, test.expected, strings.TrimSpace(buff.String()))\n\t\t\tbuff.Reset()\n\t\t})\n\t}\n\terr := os.RemoveAll(dir + \"/.task\")\n\trequire.NoError(t, err)\n}\n\nfunc TestTaskfileWalk(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname     string\n\t\tdir      string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"walk from root directory\",\n\t\t\tdir:      \"testdata/taskfile_walk\",\n\t\t\texpected: \"foo\\n\",\n\t\t}, {\n\t\t\tname:     \"walk from sub directory\",\n\t\t\tdir:      \"testdata/taskfile_walk/foo\",\n\t\t\texpected: \"foo\\n\",\n\t\t}, {\n\t\t\tname:     \"walk from sub sub directory\",\n\t\t\tdir:      \"testdata/taskfile_walk/foo/bar\",\n\t\t\texpected: \"foo\\n\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    test.dir,\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\t\t\tassert.Equal(t, test.expected, buff.String())\n\t\t})\n\t}\n}\n\nfunc TestUserWorkingDirectory(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/user_working_dir\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\twd, err := os.Getwd()\n\trequire.NoError(t, err)\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"default\"}))\n\tassert.Equal(t, fmt.Sprintf(\"%s\\n\", wd), buff.String())\n}\n\nfunc TestUserWorkingDirectoryWithIncluded(t *testing.T) {\n\tt.Parallel()\n\n\twd, err := os.Getwd()\n\trequire.NoError(t, err)\n\n\twd = filepathext.SmartJoin(wd, \"testdata/user_working_dir_with_includes/somedir\")\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tUserWorkingDir: wd,\n\t\tDir:            \"testdata/user_working_dir_with_includes\",\n\t\tStdout:         &buff,\n\t\tStderr:         &buff,\n\t}\n\n\trequire.NoError(t, err)\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"included:echo\"}))\n\tassert.Equal(t, fmt.Sprintf(\"%s\\n\", wd), buff.String())\n}\n\nfunc TestPlatforms(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/platforms\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"build-\" + runtime.GOOS}))\n\tassert.Equal(t, fmt.Sprintf(\"task: [build-%s] echo 'Running task on %s'\\nRunning task on %s\\n\", runtime.GOOS, runtime.GOOS, runtime.GOOS), buff.String())\n}\n\nfunc TestPOSIXShellOptsGlobalLevel(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/shopts/global_level\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"pipefail\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"pipefail\\ton\\n\", buff.String())\n}\n\nfunc TestPOSIXShellOptsTaskLevel(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/shopts/task_level\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"pipefail\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"pipefail\\ton\\n\", buff.String())\n}\n\nfunc TestPOSIXShellOptsCommandLevel(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/shopts/command_level\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"pipefail\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"pipefail\\ton\\n\", buff.String())\n}\n\nfunc TestBashShellOptsGlobalLevel(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/shopts/global_level\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"globstar\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"globstar\\ton\\n\", buff.String())\n}\n\nfunc TestBashShellOptsTaskLevel(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/shopts/task_level\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"globstar\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"globstar\\ton\\n\", buff.String())\n}\n\nfunc TestBashShellOptsCommandLevel(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/shopts/command_level\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"globstar\"})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"globstar\\ton\\n\", buff.String())\n}\n\nfunc TestSplitArgs(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/split_args\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: true,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\tvars := ast.NewVars()\n\tvars.Set(\"CLI_ARGS\", ast.Var{Value: \"foo bar 'foo bar baz'\"})\n\n\terr := e.Run(context.Background(), &ast.Call{Task: \"default\", Vars: vars})\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"3\\n\", buff.String())\n}\n\nfunc TestSingleCmdDep(t *testing.T) {\n\tt.Parallel()\n\n\ttt := fileContentTest{\n\t\tDir:    \"testdata/single_cmd_dep\",\n\t\tTarget: \"foo\",\n\t\tFiles: map[string]string{\n\t\t\t\"foo.txt\": \"foo\\n\",\n\t\t\t\"bar.txt\": \"bar\\n\",\n\t\t},\n\t}\n\tt.Run(\"\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\ttt.Run(t)\n\t})\n}\n\nfunc TestSilence(t *testing.T) {\n\tt.Parallel()\n\n\tvar buff bytes.Buffer\n\te := task.Executor{\n\t\tDir:    \"testdata/silent\",\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tSilent: false,\n\t}\n\trequire.NoError(t, e.Setup())\n\n\t// First verify that the silent flag is in place.\n\ttask, err := e.GetTask(&ast.Call{Task: \"task-test-silent-calls-chatty-silenced\"})\n\trequire.NoError(t, err, \"Unable to look up task task-test-silent-calls-chatty-silenced\")\n\trequire.True(t, task.Cmds[0].Silent, \"The task task-test-silent-calls-chatty-silenced should have a silent call to chatty\")\n\n\t// Then test the two basic cases where the task is silent or not.\n\t// A silenced task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"silent\"})\n\trequire.NoError(t, err)\n\trequire.Empty(t, buff.String(), \"siWhile running lent: Expected not see output, because the task is silent\")\n\n\tbuff.Reset()\n\n\t// A chatty (not silent) task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"chatty\"})\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, buff.String(), \"chWhile running atty: Expected to see output, because the task is not silent\")\n\n\tbuff.Reset()\n\n\t// Then test invoking the two task from other tasks.\n\t// A silenced task that calls a chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-silent-calls-chatty-non-silenced\"})\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, buff.String(), \"While running task-test-silent-calls-chatty-non-silenced: Expected to see output. The task is silenced, but the called task is not. Silence does not propagate to called tasks.\")\n\n\tbuff.Reset()\n\n\t// A silent task that does a silent call to a chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-silent-calls-chatty-silenced\"})\n\trequire.NoError(t, err)\n\trequire.Empty(t, buff.String(), \"While running task-test-silent-calls-chatty-silenced: Expected not to see output. The task calls chatty task, but the call is silenced.\")\n\n\tbuff.Reset()\n\n\t// A chatty task that does a call to a chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-chatty-calls-chatty-non-silenced\"})\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, buff.String(), \"While running task-test-chatty-calls-chatty-non-silenced: Expected to see output. Both caller and callee are chatty and not silenced.\")\n\n\tbuff.Reset()\n\n\t// A chatty task that does a silenced call to a chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-chatty-calls-chatty-silenced\"})\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, buff.String(), \"While running task-test-chatty-calls-chatty-silenced: Expected to see output. Call to a chatty task is silenced, but the parent task is not.\")\n\n\tbuff.Reset()\n\n\t// A chatty task with no cmd's of its own that does a silenced call to a chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-no-cmds-calls-chatty-silenced\"})\n\trequire.NoError(t, err)\n\trequire.Empty(t, buff.String(), \"While running task-test-no-cmds-calls-chatty-silenced: Expected not to see output. While the task itself is not silenced, it does not have any cmds and only does an invocation of a silenced task.\")\n\n\tbuff.Reset()\n\n\t// A chatty task that does a silenced invocation of a task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-chatty-calls-silenced-cmd\"})\n\trequire.NoError(t, err)\n\trequire.Empty(t, buff.String(), \"While running task-test-chatty-calls-silenced-cmd: Expected not to see output. While the task itself is not silenced, its call to the chatty task is silent.\")\n\n\tbuff.Reset()\n\n\t// Then test calls via dependencies.\n\t// A silent task that depends on a chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-is-silent-depends-on-chatty-non-silenced\"})\n\trequire.NoError(t, err)\n\trequire.NotEmpty(t, buff.String(), \"While running task-test-is-silent-depends-on-chatty-non-silenced: Expected to see output. The task is silent and depends on a chatty task. Dependencies does not inherit silence.\")\n\n\tbuff.Reset()\n\n\t// A silent task that depends on a silenced chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-is-silent-depends-on-chatty-silenced\"})\n\trequire.NoError(t, err)\n\trequire.Empty(t, buff.String(), \"While running task-test-is-silent-depends-on-chatty-silenced: Expected not to see output. The task is silent and has a silenced dependency on a chatty task.\")\n\n\tbuff.Reset()\n\n\t// A chatty task that, depends on a silenced chatty task.\n\terr = e.Run(context.Background(), &ast.Call{Task: \"task-test-is-chatty-depends-on-chatty-silenced\"})\n\trequire.NoError(t, err)\n\trequire.Empty(t, buff.String(), \"While running task-test-is-chatty-depends-on-chatty-silenced: Expected not to see output. The task is chatty but does not have commands and has a silenced dependency on a chatty task.\")\n\n\tbuff.Reset()\n}\n\nfunc TestForce(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname     string\n\t\tenv      map[string]string\n\t\tforce    bool\n\t\tforceAll bool\n\t}{\n\t\t{\n\t\t\tname:  \"force\",\n\t\t\tforce: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"force-all\",\n\t\t\tforceAll: true,\n\t\t},\n\t\t{\n\t\t\tname:  \"force with gentle force experiment\",\n\t\t\tforce: true,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"TASK_X_GENTLE_FORCE\": \"1\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"force-all with gentle force experiment\",\n\t\t\tforceAll: true,\n\t\t\tenv: map[string]string{\n\t\t\t\t\"TASK_X_GENTLE_FORCE\": \"1\",\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:      \"testdata/force\",\n\t\t\t\tStdout:   &buff,\n\t\t\t\tStderr:   &buff,\n\t\t\t\tForce:    tt.force,\n\t\t\t\tForceAll: tt.forceAll,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: \"task-with-dep\"}))\n\t\t})\n\t}\n}\n\nfunc TestForCmds(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname           string\n\t\texpectedOutput string\n\t}{\n\t\t{\n\t\t\tname:           \"loop-explicit\",\n\t\t\texpectedOutput: \"a\\nb\\nc\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-matrix\",\n\t\t\texpectedOutput: \"windows/amd64\\nwindows/arm64\\nlinux/amd64\\nlinux/arm64\\ndarwin/amd64\\ndarwin/arm64\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-sources\",\n\t\t\texpectedOutput: \"bar\\nfoo\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-sources-glob\",\n\t\t\texpectedOutput: \"bar\\nfoo\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-vars\",\n\t\t\texpectedOutput: \"foo\\nbar\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-vars-sh\",\n\t\t\texpectedOutput: \"bar\\nfoo\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-task\",\n\t\t\texpectedOutput: \"foo\\nbar\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-task-as\",\n\t\t\texpectedOutput: \"foo\\nbar\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"loop-different-tasks\",\n\t\t\texpectedOutput: \"1\\n2\\n3\\n\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar stdOut bytes.Buffer\n\t\t\tvar stdErr bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    \"testdata/for/cmds\",\n\t\t\t\tStdout: &stdOut,\n\t\t\t\tStderr: &stdErr,\n\t\t\t\tSilent: true,\n\t\t\t\tForce:  true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: test.name}))\n\t\t\tassert.Equal(t, test.expectedOutput, stdOut.String())\n\t\t})\n\t}\n}\n\nfunc TestForDeps(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname                   string\n\t\texpectedOutputContains []string\n\t}{\n\t\t{\n\t\t\tname:                   \"loop-explicit\",\n\t\t\texpectedOutputContains: []string{\"a\\n\", \"b\\n\", \"c\\n\"},\n\t\t},\n\t\t{\n\t\t\tname: \"loop-matrix\",\n\t\t\texpectedOutputContains: []string{\n\t\t\t\t\"windows/amd64\\n\",\n\t\t\t\t\"windows/arm64\\n\",\n\t\t\t\t\"linux/amd64\\n\",\n\t\t\t\t\"linux/arm64\\n\",\n\t\t\t\t\"darwin/amd64\\n\",\n\t\t\t\t\"darwin/arm64\\n\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:                   \"loop-sources\",\n\t\t\texpectedOutputContains: []string{\"bar\\n\", \"foo\\n\"},\n\t\t},\n\t\t{\n\t\t\tname:                   \"loop-sources-glob\",\n\t\t\texpectedOutputContains: []string{\"bar\\n\", \"foo\\n\"},\n\t\t},\n\t\t{\n\t\t\tname:                   \"loop-vars\",\n\t\t\texpectedOutputContains: []string{\"foo\\n\", \"bar\\n\"},\n\t\t},\n\t\t{\n\t\t\tname:                   \"loop-vars-sh\",\n\t\t\texpectedOutputContains: []string{\"bar\\n\", \"foo\\n\"},\n\t\t},\n\t\t{\n\t\t\tname:                   \"loop-task\",\n\t\t\texpectedOutputContains: []string{\"foo\\n\", \"bar\\n\"},\n\t\t},\n\t\t{\n\t\t\tname:                   \"loop-task-as\",\n\t\t\texpectedOutputContains: []string{\"foo\\n\", \"bar\\n\"},\n\t\t},\n\t\t{\n\t\t\tname:                   \"loop-different-tasks\",\n\t\t\texpectedOutputContains: []string{\"1\\n\", \"2\\n\", \"3\\n\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\t// We need to use a sync buffer here as deps are run concurrently\n\t\t\tvar buff SyncBuffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    \"testdata/for/deps\",\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t\tForce:  true,\n\t\t\t\t// Force output of each dep to be grouped together to prevent interleaving\n\t\t\t\tOutputStyle: ast.Output{Name: \"group\"},\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: test.name}))\n\t\t\tfor _, expectedOutputContains := range test.expectedOutputContains {\n\t\t\t\tassert.Contains(t, buff.buf.String(), expectedOutputContains)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWildcard(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname           string\n\t\tcall           string\n\t\texpectedOutput string\n\t\twantErr        bool\n\t}{\n\t\t{\n\t\t\tname:           \"basic wildcard\",\n\t\t\tcall:           \"wildcard-foo\",\n\t\t\texpectedOutput: \"Hello foo\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"double wildcard\",\n\t\t\tcall:           \"foo-wildcard-bar\",\n\t\t\texpectedOutput: \"Hello foo bar\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"store wildcard\",\n\t\t\tcall:           \"start-foo\",\n\t\t\texpectedOutput: \"Starting foo\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"matches exactly\",\n\t\t\tcall:           \"matches-exactly-*\",\n\t\t\texpectedOutput: \"I don't consume matches: []\\n\",\n\t\t},\n\t\t{\n\t\t\tname:    \"no matches\",\n\t\t\tcall:    \"no-match\",\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple matches\",\n\t\t\tcall:    \"wildcard-foo-bar\",\n\t\t\twantErr: true,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.call, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    \"testdata/wildcards\",\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t\tForce:  true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\tif test.wantErr {\n\t\t\t\trequire.Error(t, e.Run(context.Background(), &ast.Call{Task: test.call}))\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: test.call}))\n\t\t\tassert.Equal(t, test.expectedOutput, buff.String())\n\t\t})\n\t}\n}\n\nfunc TestReference(t *testing.T) {\n\tt.Parallel()\n\n\ttests := []struct {\n\t\tname           string\n\t\tcall           string\n\t\texpectedOutput string\n\t}{\n\t\t{\n\t\t\tname:           \"reference in command\",\n\t\t\tcall:           \"ref-cmd\",\n\t\t\texpectedOutput: \"1\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"reference in dependency\",\n\t\t\tcall:           \"ref-dep\",\n\t\t\texpectedOutput: \"1\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"reference using templating resolver\",\n\t\t\tcall:           \"ref-resolver\",\n\t\t\texpectedOutput: \"1\\n\",\n\t\t},\n\t\t{\n\t\t\tname:           \"reference using templating resolver and dynamic var\",\n\t\t\tcall:           \"ref-resolver-sh\",\n\t\t\texpectedOutput: \"Alice has 3 children called Bob, Charlie, and Diane\\n\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.call, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tvar buff bytes.Buffer\n\t\t\te := task.Executor{\n\t\t\t\tDir:    \"testdata/var_references\",\n\t\t\t\tStdout: &buff,\n\t\t\t\tStderr: &buff,\n\t\t\t\tSilent: true,\n\t\t\t\tForce:  true,\n\t\t\t}\n\t\t\trequire.NoError(t, e.Setup())\n\t\t\trequire.NoError(t, e.Run(context.Background(), &ast.Call{Task: test.call}))\n\t\t\tassert.Equal(t, test.expectedOutput, buff.String())\n\t\t})\n\t}\n}\n\n// enableExperimentForTest enables the experiment behind pointer e for the duration of test t and sub-tests,\n// with the experiment being restored to its previous state when tests complete.\n//\n// Typically experiments are controlled via TASK_X_ env vars, but we cannot use those in tests\n// because the experiment settings are parsed during experiments.init(), before any tests run.\nfunc enableExperimentForTest(t *testing.T, e *experiments.Experiment, val string) {\n\tt.Helper()\n\n\tprev := *e\n\t*e = experiments.Experiment{\n\t\tName:    prev.Name,\n\t\tEnabled: true,\n\t\tValue:   val,\n\t}\n\tt.Cleanup(func() { *e = prev })\n}\n"
        },
        {
          "name": "taskfile",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "variables.go",
          "type": "blob",
          "size": 10.5263671875,
          "content": "package task\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/joho/godotenv\"\n\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/internal/env\"\n\t\"github.com/go-task/task/v3/internal/execext\"\n\t\"github.com/go-task/task/v3/internal/filepathext\"\n\t\"github.com/go-task/task/v3/internal/fingerprint\"\n\t\"github.com/go-task/task/v3/internal/templater\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\n// CompiledTask returns a copy of a task, but replacing variables in almost all\n// properties using the Go template package.\nfunc (e *Executor) CompiledTask(call *ast.Call) (*ast.Task, error) {\n\treturn e.compiledTask(call, true)\n}\n\n// FastCompiledTask is like CompiledTask, but it skippes dynamic variables.\nfunc (e *Executor) FastCompiledTask(call *ast.Call) (*ast.Task, error) {\n\treturn e.compiledTask(call, false)\n}\n\nfunc (e *Executor) compiledTask(call *ast.Call, evaluateShVars bool) (*ast.Task, error) {\n\torigTask, err := e.GetTask(call)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar vars *ast.Vars\n\tif evaluateShVars {\n\t\tvars, err = e.Compiler.GetVariables(origTask, call)\n\t} else {\n\t\tvars, err = e.Compiler.FastGetVariables(origTask, call)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcache := &templater.Cache{Vars: vars}\n\n\tnew := ast.Task{\n\t\tTask:                 origTask.Task,\n\t\tLabel:                templater.Replace(origTask.Label, cache),\n\t\tDesc:                 templater.Replace(origTask.Desc, cache),\n\t\tPrompt:               templater.Replace(origTask.Prompt, cache),\n\t\tSummary:              templater.Replace(origTask.Summary, cache),\n\t\tAliases:              origTask.Aliases,\n\t\tSources:              templater.ReplaceGlobs(origTask.Sources, cache),\n\t\tGenerates:            templater.ReplaceGlobs(origTask.Generates, cache),\n\t\tDir:                  templater.Replace(origTask.Dir, cache),\n\t\tSet:                  origTask.Set,\n\t\tShopt:                origTask.Shopt,\n\t\tVars:                 vars,\n\t\tEnv:                  nil,\n\t\tDotenv:               templater.Replace(origTask.Dotenv, cache),\n\t\tSilent:               origTask.Silent,\n\t\tInteractive:          origTask.Interactive,\n\t\tInternal:             origTask.Internal,\n\t\tMethod:               templater.Replace(origTask.Method, cache),\n\t\tPrefix:               templater.Replace(origTask.Prefix, cache),\n\t\tIgnoreError:          origTask.IgnoreError,\n\t\tRun:                  templater.Replace(origTask.Run, cache),\n\t\tIncludeVars:          origTask.IncludeVars,\n\t\tIncludedTaskfileVars: origTask.IncludedTaskfileVars,\n\t\tPlatforms:            origTask.Platforms,\n\t\tLocation:             origTask.Location,\n\t\tRequires:             origTask.Requires,\n\t\tWatch:                origTask.Watch,\n\t\tNamespace:            origTask.Namespace,\n\t}\n\tnew.Dir, err = execext.Expand(new.Dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif e.Dir != \"\" {\n\t\tnew.Dir = filepathext.SmartJoin(e.Dir, new.Dir)\n\t}\n\tif new.Prefix == \"\" {\n\t\tnew.Prefix = new.Task\n\t}\n\n\tdotenvEnvs := ast.NewVars()\n\tif len(new.Dotenv) > 0 {\n\t\tfor _, dotEnvPath := range new.Dotenv {\n\t\t\tdotEnvPath = filepathext.SmartJoin(new.Dir, dotEnvPath)\n\t\t\tif _, err := os.Stat(dotEnvPath); os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tenvs, err := godotenv.Read(dotEnvPath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfor key, value := range envs {\n\t\t\t\tif _, ok := dotenvEnvs.Get(key); !ok {\n\t\t\t\t\tdotenvEnvs.Set(key, ast.Var{Value: value})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tnew.Env = ast.NewVars()\n\tnew.Env.Merge(templater.ReplaceVars(e.Taskfile.Env, cache), nil)\n\tnew.Env.Merge(templater.ReplaceVars(dotenvEnvs, cache), nil)\n\tnew.Env.Merge(templater.ReplaceVars(origTask.Env, cache), nil)\n\tif evaluateShVars {\n\t\terr = new.Env.Range(func(k string, v ast.Var) error {\n\t\t\t// If the variable is not dynamic, we can set it and return\n\t\t\tif v.Value != nil || v.Sh == nil {\n\t\t\t\tnew.Env.Set(k, ast.Var{Value: v.Value})\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tstatic, err := e.Compiler.HandleDynamicVar(v, new.Dir, env.GetFromVars(new.Env))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnew.Env.Set(k, ast.Var{Value: static})\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif len(origTask.Sources) > 0 {\n\t\ttimestampChecker := fingerprint.NewTimestampChecker(e.TempDir.Fingerprint, e.Dry)\n\t\tchecksumChecker := fingerprint.NewChecksumChecker(e.TempDir.Fingerprint, e.Dry)\n\n\t\tfor _, checker := range []fingerprint.SourcesCheckable{timestampChecker, checksumChecker} {\n\t\t\tvalue, err := checker.Value(&new)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvars.Set(strings.ToUpper(checker.Kind()), ast.Var{Live: value})\n\t\t}\n\n\t\t// Adding new variables, requires us to refresh the templaters\n\t\t// cache of the the values manually\n\t\tcache.ResetCache()\n\t}\n\n\tif len(origTask.Cmds) > 0 {\n\t\tnew.Cmds = make([]*ast.Cmd, 0, len(origTask.Cmds))\n\t\tfor _, cmd := range origTask.Cmds {\n\t\t\tif cmd == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif cmd.For != nil {\n\t\t\t\tlist, keys, err := itemsFromFor(cmd.For, new.Dir, new.Sources, vars, origTask.Location)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t// Name the iterator variable\n\t\t\t\tvar as string\n\t\t\t\tif cmd.For.As != \"\" {\n\t\t\t\t\tas = cmd.For.As\n\t\t\t\t} else {\n\t\t\t\t\tas = \"ITEM\"\n\t\t\t\t}\n\t\t\t\t// Create a new command for each item in the list\n\t\t\t\tfor i, loopValue := range list {\n\t\t\t\t\textra := map[string]any{\n\t\t\t\t\t\tas: loopValue,\n\t\t\t\t\t}\n\t\t\t\t\tif len(keys) > 0 {\n\t\t\t\t\t\textra[\"KEY\"] = keys[i]\n\t\t\t\t\t}\n\t\t\t\t\tnewCmd := cmd.DeepCopy()\n\t\t\t\t\tnewCmd.Cmd = templater.ReplaceWithExtra(cmd.Cmd, cache, extra)\n\t\t\t\t\tnewCmd.Task = templater.ReplaceWithExtra(cmd.Task, cache, extra)\n\t\t\t\t\tnewCmd.Vars = templater.ReplaceVarsWithExtra(cmd.Vars, cache, extra)\n\t\t\t\t\tnew.Cmds = append(new.Cmds, newCmd)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Defer commands are replaced in a lazy manner because\n\t\t\t// we need to include EXIT_CODE.\n\t\t\tif cmd.Defer {\n\t\t\t\tnew.Cmds = append(new.Cmds, cmd.DeepCopy())\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewCmd := cmd.DeepCopy()\n\t\t\tnewCmd.Cmd = templater.Replace(cmd.Cmd, cache)\n\t\t\tnewCmd.Task = templater.Replace(cmd.Task, cache)\n\t\t\tnewCmd.Vars = templater.ReplaceVars(cmd.Vars, cache)\n\t\t\tnew.Cmds = append(new.Cmds, newCmd)\n\t\t}\n\t}\n\tif len(origTask.Deps) > 0 {\n\t\tnew.Deps = make([]*ast.Dep, 0, len(origTask.Deps))\n\t\tfor _, dep := range origTask.Deps {\n\t\t\tif dep == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif dep.For != nil {\n\t\t\t\tlist, keys, err := itemsFromFor(dep.For, new.Dir, new.Sources, vars, origTask.Location)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\t// Name the iterator variable\n\t\t\t\tvar as string\n\t\t\t\tif dep.For.As != \"\" {\n\t\t\t\t\tas = dep.For.As\n\t\t\t\t} else {\n\t\t\t\t\tas = \"ITEM\"\n\t\t\t\t}\n\t\t\t\t// Create a new command for each item in the list\n\t\t\t\tfor i, loopValue := range list {\n\t\t\t\t\textra := map[string]any{\n\t\t\t\t\t\tas: loopValue,\n\t\t\t\t\t}\n\t\t\t\t\tif len(keys) > 0 {\n\t\t\t\t\t\textra[\"KEY\"] = keys[i]\n\t\t\t\t\t}\n\t\t\t\t\tnewDep := dep.DeepCopy()\n\t\t\t\t\tnewDep.Task = templater.ReplaceWithExtra(dep.Task, cache, extra)\n\t\t\t\t\tnewDep.Vars = templater.ReplaceVarsWithExtra(dep.Vars, cache, extra)\n\t\t\t\t\tnew.Deps = append(new.Deps, newDep)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewDep := dep.DeepCopy()\n\t\t\tnewDep.Task = templater.Replace(dep.Task, cache)\n\t\t\tnewDep.Vars = templater.ReplaceVars(dep.Vars, cache)\n\t\t\tnew.Deps = append(new.Deps, newDep)\n\t\t}\n\t}\n\n\tif len(origTask.Preconditions) > 0 {\n\t\tnew.Preconditions = make([]*ast.Precondition, 0, len(origTask.Preconditions))\n\t\tfor _, precondition := range origTask.Preconditions {\n\t\t\tif precondition == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewPrecondition := precondition.DeepCopy()\n\t\t\tnewPrecondition.Sh = templater.Replace(precondition.Sh, cache)\n\t\t\tnewPrecondition.Msg = templater.Replace(precondition.Msg, cache)\n\t\t\tnew.Preconditions = append(new.Preconditions, newPrecondition)\n\t\t}\n\t}\n\n\tif len(origTask.Status) > 0 {\n\t\tnew.Status = templater.Replace(origTask.Status, cache)\n\t}\n\n\t// We only care about templater errors if we are evaluating shell variables\n\tif evaluateShVars && cache.Err() != nil {\n\t\treturn &new, cache.Err()\n\t}\n\n\treturn &new, nil\n}\n\nfunc asAnySlice[T any](slice []T) []any {\n\tret := make([]any, len(slice))\n\tfor i, v := range slice {\n\t\tret[i] = v\n\t}\n\treturn ret\n}\n\nfunc itemsFromFor(\n\tf *ast.For,\n\tdir string,\n\tsources []*ast.Glob,\n\tvars *ast.Vars,\n\tlocation *ast.Location,\n) ([]any, []string, error) {\n\tvar keys []string // The list of keys to loop over (only if looping over a map)\n\tvar values []any  // The list of values to loop over\n\t// Get the list from a matrix\n\tif f.Matrix.Len() != 0 {\n\t\treturn asAnySlice(product(f.Matrix)), nil, nil\n\t}\n\t// Get the list from the explicit for list\n\tif len(f.List) > 0 {\n\t\treturn f.List, nil, nil\n\t}\n\t// Get the list from the task sources\n\tif f.From == \"sources\" {\n\t\tglist, err := fingerprint.Globs(dir, sources)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\t// Make the paths relative to the task dir\n\t\tfor i, v := range glist {\n\t\t\tif glist[i], err = filepath.Rel(dir, v); err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\t\tvalues = asAnySlice(glist)\n\t}\n\t// Get the list from a variable and split it up\n\tif f.Var != \"\" {\n\t\tif vars != nil {\n\t\t\tv, ok := vars.Get(f.Var)\n\t\t\t// If the variable is dynamic, then it hasn't been resolved yet\n\t\t\t// and we can't use it as a list. This happens when fast compiling a task\n\t\t\t// for use in --list or --list-all etc.\n\t\t\tif ok && v.Sh == nil {\n\t\t\t\tswitch value := v.Value.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\tif f.Split != \"\" {\n\t\t\t\t\t\tvalues = asAnySlice(strings.Split(value, f.Split))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalues = asAnySlice(strings.Fields(value))\n\t\t\t\t\t}\n\t\t\t\tcase []string:\n\t\t\t\t\tvalues = asAnySlice(value)\n\t\t\t\tcase []int:\n\t\t\t\t\tvalues = asAnySlice(value)\n\t\t\t\tcase []any:\n\t\t\t\t\tvalues = value\n\t\t\t\tcase map[string]any:\n\t\t\t\t\tfor k, v := range value {\n\t\t\t\t\t\tkeys = append(keys, k)\n\t\t\t\t\t\tvalues = append(values, v)\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\treturn nil, nil, errors.TaskfileInvalidError{\n\t\t\t\t\t\tURI: location.Taskfile,\n\t\t\t\t\t\tErr: errors.New(\"loop var must be a delimiter-separated string, list or a map\"),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn values, keys, nil\n}\n\n// product generates the cartesian product of the input map of slices.\nfunc product(inputMap *ast.Matrix) []map[string]any {\n\tif inputMap.Len() == 0 {\n\t\treturn nil\n\t}\n\n\t// Start with an empty product result\n\tresult := []map[string]any{{}}\n\n\t// Iterate over each slice in the slices\n\t_ = inputMap.Range(func(key string, slice []any) error {\n\t\tvar newResult []map[string]any\n\n\t\t// For each combination in the current result\n\t\tfor _, combination := range result {\n\t\t\t// Append each element from the current slice to the combinations\n\t\t\tfor _, item := range slice {\n\t\t\t\tnewComb := make(map[string]any, len(combination))\n\t\t\t\t// Copy the existing combination\n\t\t\t\tfor k, v := range combination {\n\t\t\t\t\tnewComb[k] = v\n\t\t\t\t}\n\t\t\t\t// Add the current item with the corresponding key\n\t\t\t\tnewComb[key] = item\n\t\t\t\tnewResult = append(newResult, newComb)\n\t\t\t}\n\t\t}\n\n\t\t// Update result with the new combinations\n\t\tresult = newResult\n\t\treturn nil\n\t})\n\n\treturn result\n}\n"
        },
        {
          "name": "watch.go",
          "type": "blob",
          "size": 4.1162109375,
          "content": "package task\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/radovskyb/watcher\"\n\n\t\"github.com/go-task/task/v3/errors\"\n\t\"github.com/go-task/task/v3/internal/fingerprint\"\n\t\"github.com/go-task/task/v3/internal/logger\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\nconst defaultWatchInterval = 5 * time.Second\n\n// watchTasks start watching the given tasks\nfunc (e *Executor) watchTasks(calls ...*ast.Call) error {\n\ttasks := make([]string, len(calls))\n\tfor i, c := range calls {\n\t\ttasks[i] = c.Task\n\t}\n\n\te.Logger.Errf(logger.Green, \"task: Started watching for tasks: %s\\n\", strings.Join(tasks, \", \"))\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tfor _, c := range calls {\n\t\tc := c\n\t\tgo func() {\n\t\t\tif err := e.RunTask(ctx, c); err != nil && !isContextError(err) {\n\t\t\t\te.Logger.Errf(logger.Red, \"%v\\n\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tvar watchInterval time.Duration\n\tswitch {\n\tcase e.Interval != 0:\n\t\twatchInterval = e.Interval\n\tcase e.Taskfile.Interval != 0:\n\t\twatchInterval = e.Taskfile.Interval\n\tdefault:\n\t\twatchInterval = defaultWatchInterval\n\t}\n\n\te.Logger.VerboseOutf(logger.Green, \"task: Watching for changes every %v\\n\", watchInterval)\n\n\tw := watcher.New()\n\tdefer w.Close()\n\tw.SetMaxEvents(1)\n\n\tcloseOnInterrupt(w)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event := <-w.Event:\n\t\t\t\te.Logger.VerboseErrf(logger.Magenta, \"task: received watch event: %v\\n\", event)\n\n\t\t\t\tcancel()\n\t\t\t\tctx, cancel = context.WithCancel(context.Background())\n\n\t\t\t\te.Compiler.ResetCache()\n\n\t\t\t\tfor _, c := range calls {\n\t\t\t\t\tc := c\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tif err := e.RunTask(ctx, c); err != nil && !isContextError(err) {\n\t\t\t\t\t\t\te.Logger.Errf(logger.Red, \"%v\\n\", err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n\t\t\t\t}\n\t\t\tcase err := <-w.Error:\n\t\t\t\tswitch err {\n\t\t\t\tcase watcher.ErrWatchedFileDeleted:\n\t\t\t\tdefault:\n\t\t\t\t\te.Logger.Errf(logger.Red, \"%v\\n\", err)\n\t\t\t\t}\n\t\t\tcase <-w.Closed:\n\t\t\t\tcancel()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\t// re-register every 5 seconds because we can have new files, but this process is expensive to run\n\t\tfor {\n\t\t\tif err := e.registerWatchedFiles(w, calls...); err != nil {\n\t\t\t\te.Logger.Errf(logger.Red, \"%v\\n\", err)\n\t\t\t}\n\t\t\ttime.Sleep(watchInterval)\n\t\t}\n\t}()\n\n\treturn w.Start(watchInterval)\n}\n\nfunc isContextError(err error) bool {\n\tif taskRunErr, ok := err.(*errors.TaskRunError); ok {\n\t\terr = taskRunErr.Err\n\t}\n\n\treturn err == context.Canceled || err == context.DeadlineExceeded\n}\n\nfunc closeOnInterrupt(w *watcher.Watcher) {\n\tch := make(chan os.Signal, 1)\n\tsignal.Notify(ch, os.Interrupt, syscall.SIGTERM)\n\tgo func() {\n\t\t<-ch\n\t\tw.Close()\n\t}()\n}\n\nfunc (e *Executor) registerWatchedFiles(w *watcher.Watcher, calls ...*ast.Call) error {\n\twatchedFiles := w.WatchedFiles()\n\n\tvar registerTaskFiles func(*ast.Call) error\n\tregisterTaskFiles = func(c *ast.Call) error {\n\t\ttask, err := e.CompiledTask(c)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, d := range task.Deps {\n\t\t\tif err := registerTaskFiles(&ast.Call{Task: d.Task, Vars: d.Vars}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, c := range task.Cmds {\n\t\t\tif c.Task != \"\" {\n\t\t\t\tif err := registerTaskFiles(&ast.Call{Task: c.Task, Vars: c.Vars}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tglobs, err := fingerprint.Globs(task.Dir, task.Sources)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, s := range globs {\n\t\t\tfiles, err := fingerprint.Glob(task.Dir, s)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"task: %s: %w\", s, err)\n\t\t\t}\n\t\t\tfor _, f := range files {\n\t\t\t\tabsFile, err := filepath.Abs(f)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif ShouldIgnoreFile(absFile) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif _, ok := watchedFiles[absFile]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif err := w.Add(absFile); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\te.Logger.VerboseOutf(logger.Green, \"task: watching new file: %v\\n\", absFile)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\tfor _, c := range calls {\n\t\tif err := registerTaskFiles(c); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc ShouldIgnoreFile(path string) bool {\n\tignorePaths := []string{\n\t\t\"/.task\",\n\t\t\"/.git\",\n\t\t\"/.hg\",\n\t\t\"/node_modules\",\n\t}\n\tfor _, p := range ignorePaths {\n\t\tif strings.Contains(path, fmt.Sprintf(\"%s/\", p)) || strings.HasSuffix(path, p) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "watch_test.go",
          "type": "blob",
          "size": 1.9931640625,
          "content": "//go:build watch\n// +build watch\n\npackage task_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/go-task/task/v3\"\n\t\"github.com/go-task/task/v3/internal/filepathext\"\n\t\"github.com/go-task/task/v3/taskfile/ast\"\n)\n\nfunc TestFileWatcherInterval(t *testing.T) {\n\tconst dir = \"testdata/watcher_interval\"\n\texpectedOutput := strings.TrimSpace(`\ntask: Started watching for tasks: default\ntask: [default] echo \"Hello, World!\"\nHello, World!\ntask: [default] echo \"Hello, World!\"\nHello, World!\n\t`)\n\n\tvar buff bytes.Buffer\n\te := &task.Executor{\n\t\tDir:    dir,\n\t\tStdout: &buff,\n\t\tStderr: &buff,\n\t\tWatch:  true,\n\t}\n\n\trequire.NoError(t, e.Setup())\n\tbuff.Reset()\n\n\terr := os.MkdirAll(filepathext.SmartJoin(dir, \"src\"), 0755)\n\trequire.NoError(t, err)\n\n\terr = os.WriteFile(filepathext.SmartJoin(dir, \"src/a\"), []byte(\"test\"), 0644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tctx := context.Background()\n\tctx, cancel := context.WithCancel(ctx)\n\n\tgo func(ctx context.Context) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\terr := e.Run(ctx, &ast.Call{Task: \"default\"})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}(ctx)\n\n\ttime.Sleep(10 * time.Millisecond)\n\terr = os.WriteFile(filepathext.SmartJoin(dir, \"src/a\"), []byte(\"test updated\"), 0644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttime.Sleep(700 * time.Millisecond)\n\tcancel()\n\tassert.Equal(t, expectedOutput, strings.TrimSpace(buff.String()))\n\tbuff.Reset()\n\terr = os.RemoveAll(filepathext.SmartJoin(dir, \".task\"))\n\trequire.NoError(t, err)\n\terr = os.RemoveAll(filepathext.SmartJoin(dir, \"src\"))\n\trequire.NoError(t, err)\n}\n\nfunc TestShouldIgnoreFile(t *testing.T) {\n\ttt := []struct {\n\t\tpath   string\n\t\texpect bool\n\t}{\n\t\t{\"/.git/hooks\", true},\n\t\t{\"/.github/workflows/build.yaml\", false},\n\t}\n\n\tfor k, ct := range tt {\n\t\tct := ct\n\t\tt.Run(fmt.Sprintf(\"ignore - %d\", k), func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\trequire.Equal(t, task.ShouldIgnoreFile(ct.path), ct.expect)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}