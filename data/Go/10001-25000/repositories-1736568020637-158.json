{
  "metadata": {
    "timestamp": 1736568020637,
    "page": 158,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fogleman/primitive",
      "stars": 12863,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "/*.png\n/*.svg\n/*.gif\n\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.03515625,
          "content": "Copyright (C) 2016 Michael Fogleman\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.8994140625,
          "content": "# Primitive Pictures\n\nReproducing images with geometric primitives.\n\n![Example](https://www.michaelfogleman.com/static/primitive/examples/16550611738.200.128.4.5.png)\n\n### How it Works\n\nA target image is provided as input. The algorithm tries to find the single most optimal shape that can be drawn to minimize the error between the target image and the drawn image. It repeats this process, adding *one shape at a time*. Around 50 to 200 shapes are needed to reach a result that is recognizable yet artistic and abstract.\n\n### Primitive for macOS\n\nNow available as a native Mac application!\n\nhttps://primitive.lol/\n\n### Twitter\n\nFollow [@PrimitivePic](https://twitter.com/PrimitivePic) on Twitter to see a new primitive picture every 30 minutes!\n\nThe Twitter bot looks for interesting photos using the Flickr API, runs the algorithm using randomized parameters, and\nposts the picture using the Twitter API.\n\nYou can tweet a picture to the bot and it will process it for you.\n\n### Command-line Usage\n\nRun it on your own images! First, [install Go](https://golang.org/doc/install).\n\n    go get -u github.com/fogleman/primitive\n    primitive -i input.png -o output.png -n 100\n\nSmall input images should be used (like 256x256px). You don't need the detail anyway and the code will run faster.\n\n| Flag | Default | Description |\n| --- | --- | --- |\n| `i` | n/a | input file |\n| `o` | n/a | output file |\n| `n` | n/a | number of shapes |\n| `m` | 1 | mode: 0=combo, 1=triangle, 2=rect, 3=ellipse, 4=circle, 5=rotatedrect, 6=beziers, 7=rotatedellipse, 8=polygon |\n| `rep` | 0 | add N extra shapes each iteration with reduced search (mostly good for beziers) |\n| `nth` | 1 | save every Nth frame (only when `%d` is in output path) |\n| `r` | 256 | resize large input images to this size before processing |\n| `s` | 1024 | output image size |\n| `a` | 128 | color alpha (use `0` to let the algorithm choose alpha for each shape) |\n| `bg` | avg | starting background color (hex) |\n| `j` | 0 | number of parallel workers (default uses all cores) |\n| `v` | off | verbose output |\n| `vv` | off | very verbose output |\n\n### Output Formats\n\nDepending on the output filename extension provided, you can produce different types of output.\n\n- `PNG`: raster output\n- `JPG`: raster output\n- `SVG`: vector output\n- `GIF`: animated output showing shapes being added - requires ImageMagick (specifically the `convert` command)\n\nFor PNG and SVG outputs, you can also include `%d`, `%03d`, etc. in the filename. In this case, each frame will be saved separately.\n\nYou can use the `-o` flag multiple times. This way you can save both a PNG and an SVG, for example.\n\n### Progression\n\nThis GIF demonstrates the iterative nature of the algorithm, attempting to minimize the mean squared error by adding one shape at a time. (Use a \".gif\" output file to generate one yourself!)\n\n<img src=\"https://www.michaelfogleman.com/static/primitive/examples/monalisa.3.2000.gif\" width=\"440\"/> <img src=\"https://www.michaelfogleman.com/static/primitive/examples/monalisa-original.png\" width=\"440\"/>\n\n### Static Animation\n\nSince the algorithm has a random component to it, you can run it against the same input image multiple times to bring life to a static image.\n\n![Pencils](https://www.michaelfogleman.com/static/primitive/examples/pencils.gif)\n\n### Creative Constraints\n\nIf you're willing to dabble in the code, you can enforce constraints on the shapes to produce even more interesting results. Here, the rectangles are constrained to point toward the sun in this picture of a pyramid sunset.\n\n![Pyramids](https://www.michaelfogleman.com/static/primitive/examples/pyramids.png)\n\n### Shape and Iteration Comparison Matrix\n\nThe matrix below shows triangles, ellipses and rectangles at 50, 100 and 200 iterations each.\n\n![Matrix](http://i.imgur.com/H5NYpL4.png)\n\n### How it Works, Part II\n\nSay we have a `Target Image`. This is what we're working towards recreating. We start with a blank canvas, but we fill it with a single solid color. Currently, this is the average color of the `Target Image`. We call this new blank canvas the `Current Image`. Now, we start evaluating shapes. To evaluate a shape, we draw it on top of the `Current Image`, producing a `New Image`. This `New Image` is compared to the `Target Image` to compute a score. We use the [root-mean-square error](https://en.wikipedia.org/wiki/Root-mean-square_deviation) for the score.\n\n    Current Image + Shape => New Image\n    RMSE(New Image, Target Image) => Score\n\nThe shapes are generated randomly. We can generate a random shape and score it. Then we can mutate the shape (by tweaking a triangle vertex, tweaking an ellipse radius or center, etc.) and score it again. If the mutation improved the score, we keep it. Otherwise we rollback to the previous state. Repeating this process is known as [hill climbing](https://en.wikipedia.org/wiki/Hill_climbing). Hill climbing is prone to getting stuck in local minima, so we actually do this many different times with several different starting shapes. We can also generate N random shapes and pick the best one before we start hill climbing. [Simulated annealing](https://en.wikipedia.org/wiki/Simulated_annealing) is another good option, but in my tests I found the hill climbing technique just as good and faster, at least for this particular problem.\n\nOnce we have found a good-scoring shape, we add it to the `Current Image`, where it will remain unchanged. Then we start the process again to find the next shape to draw. This process is repeated as many times as desired.\n\n### Primitives\n\nThe following primitives are supported:\n\n- Triangle\n- Rectangle (axis-aligned)\n- Ellipse (axis-aligned)\n- Circle\n- Rotated Rectangle\n- Combo (a mix of the above in a single image)\n\nMore shapes can be added by implementing the following interface:\n\n```go\ntype Shape interface {\n\tRasterize() []Scanline\n\tCopy() Shape\n\tMutate()\n\tDraw(dc *gg.Context)\n\tSVG(attrs string) string\n}\n```\n\n### Features\n\n- [Hill Climbing](https://en.wikipedia.org/wiki/Hill_climbing) or [Simulated Annealing](https://en.wikipedia.org/wiki/Simulated_annealing) for optimization (hill climbing multiple random shapes is nearly as good as annealing and faster)\n- Scanline rasterization of shapes in pure Go (preferable for implementing the features below)\n- Optimal color computation based on affected pixels for each shape (color is directly computed, not optimized for)\n- Partial image difference for faster scoring (only pixels that change need be considered)\n- Anti-aliased output rendering\n\n### Inspiration\n\nThis project was originally inspired by the popular and excellent work of Roger Johansson - [Genetic Programming: Evolution of Mona Lisa](https://rogeralsing.com/2008/12/07/genetic-programming-evolution-of-mona-lisa/). Since seeing that article when it was quite new, I've tinkered with this problem here and there over the years. But only now am I satisfied with my results.\n\nIt should be noted that there are significant differences in my implementation compared to Roger's original work. Mine is not a genetic algorithm. Mine only operates on one shape at a time. Mine is much faster (AFAIK) and supports many types of shapes.\n\n### Examples\n\nHere are more examples from interesting photos found on Flickr.\n\n![Example](https://www.michaelfogleman.com/static/primitive/examples/29167683201.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/26574286221.200.128.4.1.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/15011768709.200.128.4.1.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/27540729075.200.128.4.1.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/28896874003.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/20414282102.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/15199237095.200.128.4.1.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/11707819764.200.128.4.1.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/18270231645.200.128.4.3.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/15705764893.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/25213252889.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/15015411870.200.128.4.3.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/25766500104.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/27471731151.50.128.4.1.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/11720700033.200.128.4.3.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/18782606664.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/21374478713.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/15196426112.200.128.4.5.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/24696847962.png)\n![Example](https://www.michaelfogleman.com/static/primitive/examples/18276676312.100.128.4.1.png)\n"
        },
        {
          "name": "bot",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 4.9580078125,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/fogleman/primitive/primitive\"\n\t\"github.com/nfnt/resize\"\n)\n\nvar (\n\tInput      string\n\tOutputs    flagArray\n\tBackground string\n\tConfigs    shapeConfigArray\n\tAlpha      int\n\tInputSize  int\n\tOutputSize int\n\tMode       int\n\tWorkers    int\n\tNth        int\n\tRepeat     int\n\tV, VV      bool\n)\n\ntype flagArray []string\n\nfunc (i *flagArray) String() string {\n\treturn strings.Join(*i, \", \")\n}\n\nfunc (i *flagArray) Set(value string) error {\n\t*i = append(*i, value)\n\treturn nil\n}\n\ntype shapeConfig struct {\n\tCount  int\n\tMode   int\n\tAlpha  int\n\tRepeat int\n}\n\ntype shapeConfigArray []shapeConfig\n\nfunc (i *shapeConfigArray) String() string {\n\treturn \"\"\n}\n\nfunc (i *shapeConfigArray) Set(value string) error {\n\tn, _ := strconv.ParseInt(value, 0, 0)\n\t*i = append(*i, shapeConfig{int(n), Mode, Alpha, Repeat})\n\treturn nil\n}\n\nfunc init() {\n\tflag.StringVar(&Input, \"i\", \"\", \"input image path\")\n\tflag.Var(&Outputs, \"o\", \"output image path\")\n\tflag.Var(&Configs, \"n\", \"number of primitives\")\n\tflag.StringVar(&Background, \"bg\", \"\", \"background color (hex)\")\n\tflag.IntVar(&Alpha, \"a\", 128, \"alpha value\")\n\tflag.IntVar(&InputSize, \"r\", 256, \"resize large input images to this size\")\n\tflag.IntVar(&OutputSize, \"s\", 1024, \"output image size\")\n\tflag.IntVar(&Mode, \"m\", 1, \"0=combo 1=triangle 2=rect 3=ellipse 4=circle 5=rotatedrect 6=beziers 7=rotatedellipse 8=polygon\")\n\tflag.IntVar(&Workers, \"j\", 0, \"number of parallel workers (default uses all cores)\")\n\tflag.IntVar(&Nth, \"nth\", 1, \"save every Nth frame (put \\\"%d\\\" in path)\")\n\tflag.IntVar(&Repeat, \"rep\", 0, \"add N extra shapes per iteration with reduced search\")\n\tflag.BoolVar(&V, \"v\", false, \"verbose\")\n\tflag.BoolVar(&VV, \"vv\", false, \"very verbose\")\n}\n\nfunc errorMessage(message string) bool {\n\tfmt.Fprintln(os.Stderr, message)\n\treturn false\n}\n\nfunc check(err error) {\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nfunc main() {\n\t// parse and validate arguments\n\tflag.Parse()\n\tok := true\n\tif Input == \"\" {\n\t\tok = errorMessage(\"ERROR: input argument required\")\n\t}\n\tif len(Outputs) == 0 {\n\t\tok = errorMessage(\"ERROR: output argument required\")\n\t}\n\tif len(Configs) == 0 {\n\t\tok = errorMessage(\"ERROR: number argument required\")\n\t}\n\tif len(Configs) == 1 {\n\t\tConfigs[0].Mode = Mode\n\t\tConfigs[0].Alpha = Alpha\n\t\tConfigs[0].Repeat = Repeat\n\t}\n\tfor _, config := range Configs {\n\t\tif config.Count < 1 {\n\t\t\tok = errorMessage(\"ERROR: number argument must be > 0\")\n\t\t}\n\t}\n\tif !ok {\n\t\tfmt.Println(\"Usage: primitive [OPTIONS] -i input -o output -n count\")\n\t\tflag.PrintDefaults()\n\t\tos.Exit(1)\n\t}\n\n\t// set log level\n\tif V {\n\t\tprimitive.LogLevel = 1\n\t}\n\tif VV {\n\t\tprimitive.LogLevel = 2\n\t}\n\n\t// seed random number generator\n\trand.Seed(time.Now().UTC().UnixNano())\n\n\t// determine worker count\n\tif Workers < 1 {\n\t\tWorkers = runtime.NumCPU()\n\t}\n\n\t// read input image\n\tprimitive.Log(1, \"reading %s\\n\", Input)\n\tinput, err := primitive.LoadImage(Input)\n\tcheck(err)\n\n\t// scale down input image if needed\n\tsize := uint(InputSize)\n\tif size > 0 {\n\t\tinput = resize.Thumbnail(size, size, input, resize.Bilinear)\n\t}\n\n\t// determine background color\n\tvar bg primitive.Color\n\tif Background == \"\" {\n\t\tbg = primitive.MakeColor(primitive.AverageImageColor(input))\n\t} else {\n\t\tbg = primitive.MakeHexColor(Background)\n\t}\n\n\t// run algorithm\n\tmodel := primitive.NewModel(input, bg, OutputSize, Workers)\n\tprimitive.Log(1, \"%d: t=%.3f, score=%.6f\\n\", 0, 0.0, model.Score)\n\tstart := time.Now()\n\tframe := 0\n\tfor j, config := range Configs {\n\t\tprimitive.Log(1, \"count=%d, mode=%d, alpha=%d, repeat=%d\\n\",\n\t\t\tconfig.Count, config.Mode, config.Alpha, config.Repeat)\n\n\t\tfor i := 0; i < config.Count; i++ {\n\t\t\tframe++\n\n\t\t\t// find optimal shape and add it to the model\n\t\t\tt := time.Now()\n\t\t\tn := model.Step(primitive.ShapeType(config.Mode), config.Alpha, config.Repeat)\n\t\t\tnps := primitive.NumberString(float64(n) / time.Since(t).Seconds())\n\t\t\telapsed := time.Since(start).Seconds()\n\t\t\tprimitive.Log(1, \"%d: t=%.3f, score=%.6f, n=%d, n/s=%s\\n\", frame, elapsed, model.Score, n, nps)\n\n\t\t\t// write output image(s)\n\t\t\tfor _, output := range Outputs {\n\t\t\t\text := strings.ToLower(filepath.Ext(output))\n\t\t\t\tif output == \"-\" {\n\t\t\t\t\text = \".svg\"\n\t\t\t\t}\n\t\t\t\tpercent := strings.Contains(output, \"%\")\n\t\t\t\tsaveFrames := percent && ext != \".gif\"\n\t\t\t\tsaveFrames = saveFrames && frame%Nth == 0\n\t\t\t\tlast := j == len(Configs)-1 && i == config.Count-1\n\t\t\t\tif saveFrames || last {\n\t\t\t\t\tpath := output\n\t\t\t\t\tif percent {\n\t\t\t\t\t\tpath = fmt.Sprintf(output, frame)\n\t\t\t\t\t}\n\t\t\t\t\tprimitive.Log(1, \"writing %s\\n\", path)\n\t\t\t\t\tswitch ext {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcheck(fmt.Errorf(\"unrecognized file extension: %s\", ext))\n\t\t\t\t\tcase \".png\":\n\t\t\t\t\t\tcheck(primitive.SavePNG(path, model.Context.Image()))\n\t\t\t\t\tcase \".jpg\", \".jpeg\":\n\t\t\t\t\t\tcheck(primitive.SaveJPG(path, model.Context.Image(), 95))\n\t\t\t\t\tcase \".svg\":\n\t\t\t\t\t\tcheck(primitive.SaveFile(path, model.SVG()))\n\t\t\t\t\tcase \".gif\":\n\t\t\t\t\t\tframes := model.Frames(0.001)\n\t\t\t\t\t\tcheck(primitive.SaveGIFImageMagick(path, frames, 50, 250))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "primitive",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}