{
  "metadata": {
    "timestamp": 1736568022170,
    "page": 160,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "golang/dep",
      "stars": 12834,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".codeclimate.yml",
          "type": "blob",
          "size": 0.6953125,
          "content": "version: \"2\"\nchecks:\n  argument-count:\n    enabled: false\n  complex-logic:\n    enabled: false\n  file-lines:\n    enabled: false\n  method-complexity:\n    enabled: false\n  method-count:\n    enabled: false\n  method-lines:\n    enabled: false\n  nested-control-flow:\n    enabled: false\n  return-statements:\n    enabled: false\n  similar-code:\n    enabled: false\n  identical-code:\n    enabled: false\nplugins:\n  gofmt:\n    # Codeclimate go fmt does not agree with tip go fmt; consider re-enabling\n    # CC when the advice matches up with tip again.\n    enabled: false\n  govet:\n    enabled: true\n  golint:\n    enabled: true\nexclude_paths:\n  - vendor/\n  - gps/_testdata\n  - cmd/dep/testdata\n  - testdata\n  - gps/internal/pb\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.078125,
          "content": "# Prevent problems comparing golden files on Windows\n**/testdata/** text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3359375,
          "content": "# dep project generated files to ignore\n#  if you want to ignore files created by your editor/tools,\n#  please consider a global .gitignore https://help.github.com/articles/ignoring-files\n#  please do not open a pull request to add something created by your editor or tools\n/dep\n/testdep\n/dep.exe\n/licenseok\n/profile.out\n/coverage.txt\nrelease/\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 4.5634765625,
          "content": "language: go\nsudo: false\ndist: xenial\nnotifications:\n  email: false\njobs:\n  include:\n    - stage: test\n      go_import_path: github.com/golang/dep\n      install:\n        - ssh-keyscan -t $TRAVIS_SSH_KEY_TYPES -H bitbucket.org >> ~/.ssh/known_hosts\n        - make get-deps\n        - npm install -g codeclimate-test-reporter\n      env:\n        - DEPTESTBYPASS501=1\n        - TZ=UTC\n        - GOCACHE=/home/travis/var/cache\n      os: linux\n      go: 1.12.x\n      script:\n        - make validate test\n        - ./hack/coverage.bash\n      after_success:\n        - codeclimate-test-reporter < coverage.txt\n    # YAML alias, for settings shared across the simpler builds\n    - &simple-test\n      go: 1.11.x\n      stage: test\n      go_import_path: github.com/golang/dep\n      install:\n        - ssh-keyscan -t $TRAVIS_SSH_KEY_TYPES -H bitbucket.org >> ~/.ssh/known_hosts\n      env:\n        - DEPTESTBYPASS501=1\n        - TZ=UTC\n      script:\n        - make test\n    - <<: *simple-test\n      go: 1.9.x\n    - <<: *simple-test\n      go: tip\n      install:\n        - ssh-keyscan -t $TRAVIS_SSH_KEY_TYPES -H bitbucket.org >> ~/.ssh/known_hosts\n        - mkdir -p /home/travis/var/cache\n      env:\n        - GOCACHE=/home/travis/var/cache\n        - DEPTESTBYPASS501=1\n        - TZ=UTC\n\n    - <<: *simple-test\n      os: osx\n      go: 1.12.x\n      install:\n        # brew takes horribly long to update itself despite the above caching\n        # attempt; only bzr install if it's not on the $PATH\n        - ssh-keyscan -t $TRAVIS_SSH_KEY_TYPES -H bitbucket.org >> ~/.ssh/known_hosts\n        - test $(which bzr) || brew install bzr\n      env:\n        - HOMEBREW_NO_AUTO_UPDATE=1\n        - DEPTESTBYPASS501=1\n        - TZ=UTC\n        - GOCACHE=/Users/travis/var/cache\n      script:\n        # OSX as of El Capitan sets an exit trap that interacts poorly with how\n        # travis seems to spawn these shells; if set -e is set, then it can cause\n        # build failures. We're not doing that here, but retain the trap statement\n        # for future safety.\n        # Related: https://superuser.com/questions/1044130/why-am-i-having-how-can-i-fix-this-error-shell-session-update-command-not-f\n        - trap EXIT\n        - make test\n    - go: 1.12.x\n      # Run on OS X so that we get a CGO-enabled binary for this OS; see\n      # https://github.com/golang/dep/issues/1838 for more details.\n      os: osx\n      stage: deploy\n      go_import_path: github.com/golang/dep\n      install:\n        - ssh-keyscan -t $TRAVIS_SSH_KEY_TYPES -H bitbucket.org >> ~/.ssh/known_hosts\n      script:\n        - skip\n      before_deploy:\n        - ./hack/build-all.bash\n      deploy:\n        - provider: releases\n          api_key:\n            secure: fL9GX11J3JLizEBTPZHN32wuAT91eAJsGl0kjlAdIc6Lb/9UCe1XZGgFnpQFN4qo/S+omhHBDbM6Ty1xhNy7xmjDecpQGDU8Rmap9Oll0TuxqMigG+njOuPp5VUYPofPP0PGKdxAcYg+KaFM7x0o2rK+qA046NHwo2gH1BbE+bn55TZglEajEfc8j9iX4jt96KC7zlu+WiKArLmfUtlrI8m8ZYgbYcvFmlYjeCiEqlNhvNL59ejug9Rl0PLtPbamqVXkGLafYtekgPCb4WSxBiCt8pq5Rb5svk9YcdXpiaWQhZjMPAuKN6BrmN2lw1PiXzADUG5fjvNc8eo2HY70GD2utU9cAsY8VIafhoH5n6uM1WI8MHwDfd7P1PiQA3ZGQ8CPwk4q/8HSfQU9ap7vZgSF63pTIbtlviyIG67orOJE9PWWncl9olYM946UylZu6m3hWI/rmJxOeJ1UJjym/3GNPMRfKubaGhV/TyRdM0bKX4M0cXHU6k/ESVFupGXdKRt4RpvkD4/1Km6b2OShW6PNI+ifFspnJr7obkI7dm7ubySdnNz4lMv9WWymxRpMVc8hUAhuoDvXeZJq7pSnkjBEWDxIRoTkA93CU3/Rf7MFYCJMnGSqjcxWUpIfCAk2/r4BqL9NQnqBvvVt+MYi64QaD5n7ZF3dVbr6HZ2zjSU=\n          file:\n            - release/dep-linux-amd64\n            - release/dep-linux-amd64.sha256\n            - release/dep-darwin-amd64\n            - release/dep-darwin-amd64.sha256\n            - release/dep-freebsd-amd64\n            - release/dep-freebsd-amd64.sha256\n            - release/dep-windows-amd64.exe\n            - release/dep-windows-amd64.exe.sha256\n            - release/dep-linux-386\n            - release/dep-linux-386.sha256\n            - release/dep-darwin-386\n            - release/dep-darwin-386.sha256\n            - release/dep-freebsd-386\n            - release/dep-freebsd-386.sha256\n            - release/dep-windows-386.exe\n            - release/dep-windows-386.exe.sha256\n            - release/dep-linux-ppc64\n            - release/dep-linux-ppc64.sha256\n            - release/dep-linux-ppc64le\n            - release/dep-linux-ppc64le.sha256\n            - release/dep-linux-s390x\n            - release/dep-linux-s390x.sha256\n            - release/dep-linux-arm\n            - release/dep-linux-arm.sha256\n            - release/dep-linux-arm64\n            - release/dep-linux-arm64.sha256\n          skip_cleanup: true\n          on:\n            repo: golang/dep\n            branch: master\n            tags: true\naddons:\n  ssh_known_hosts: github.com\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.1689453125,
          "content": "# This source code refers to The Go Authors for copyright purposes.\n# The master list of authors is in the main Go distribution,\n# visible at http://tip.golang.org/AUTHORS.\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 12.3486328125,
          "content": "# v0.5.4\n\nReleased on June 13, 2019. We are [looking for\nsponsors!](https://github.com/golang/dep/issues/2165)\n\n- Fix an error in the TOML example for the Gopkg.toml documentation.\n  ([#2174][2174])\n\n- Fix error when cleaning up git submodules with newer versions of git. Thanks\n  @geearu for the fix. ([#2168][2168], [#2176][2176])\n\n[2168]: https://github.com/golang/dep/pull/2168\n[2174]: https://github.com/golang/dep/pull/2174\n[2176]: https://github.com/golang/dep/pull/2176\n\n# v0.5.3\n\nReleased on May 13, 2019\n\n0.5.2 was released without a \"v\" prefix on the tag. The contents of this release\nare identical to 0.5.2.\n\n# 0.5.2\n\nReleased on May 8, 2019\n\nIMPROVEMENTS:\n\n* Dep will read a netrc file now, which should allow you to authenticate against\n  Gitlab and other private repositories that require basic auth. ([#2155][2155])\n\n* Ignore \"mod\" VCS type in parseMetaGoImports ([#2152][2152])\n\n* Use correct filename for ARM releases.\n\n# v0.5.1\n\nReleased on February 16, 2019\n\nIMPROVEMENTS:\n\n* Add CI tests against go1.11.\n* Fix indefinite hang cloning Git repositories that failed fsck checks. ([#2070][2070])\n* The `noverify` field in `Gopkg.toml` allows for the preservation of excess files under `vendor`. ([#2002](https://github.com/golang/dep/issue/2002))\n* Add releases for `arm`, `armv6` ([#2102][2102]), `s390x` ([#2070][2070]), and `ppc` architectures.\n* Fix handling of cyclic import graphs ([#2003][2003]).\n* Fix error in preservation of vendor/.git ([#2000][2000]).\n* Fix an edge case in lockdiff where all the projects may be removed from the lock file ([#1972][1972]).\n* Fix panic related to projects. ([#1945][1945])\n\n[2102]: https://github.com/golang/dep/pull/2102\n[2070]: https://github.com/golang/dep/pull/2070\n[2000]: https://github.com/golang/dep/pull/2000\n[1981]: https://github.com/golang/dep/pull/1981\n[2003]: https://github.com/golang/dep/pull/2003\n[1972]: https://github.com/golang/dep/pull/1972\n[1945]: https://github.com/golang/dep/pull/1945\n\nBUG FIXES:\n\n* Correctly handle certain cases where `dep ensure` removed projects from Gopkg.lock. ([#1945](https://github.com/golang/dep/issue/1945)).\n\n# v0.5.0\n\nNEW FEATURES:\n\n* Add CI tests against go1.10. Drop support for go1.8. ([#1620](https://github.com/golang/dep/pull/1620)).\n* Added `install.sh` script. ([#1533](https://github.com/golang/dep/pull/1533)).\n* List out of date projects in dep status ([#1553](https://github.com/golang/dep/pull/1553)).\n* Enabled opt-in persistent caching via `DEPCACHEAGE` env var. ([#1711](https://github.com/golang/dep/pull/1711)).\n* Allow `DEPPROJECTROOT` [environment variable](https://golang.github.io/dep/docs/env-vars.html#depprojectroot) to supersede GOPATH deduction and explicitly set the current project's [root](https://golang.github.io/dep/docs/glossary.html#project-root) ([#1883](https://github.com/golang/dep/pull/1883)).\n* `dep ensure` now explains what changes to the code or Gopkg.toml have induced solving ([#1912](https://github.com/golang/dep/pull/1912)).\n* Hash digests of vendor contents are now stored in `Gopkg.lock`, and the contents of vendor are only rewritten on change or hash mismatch ([#1912](https://github.com/golang/dep/pull/1912)).\n* Added support for ppc64/ppc64le.\n* New subcommand `dep check` quickly reports if imports, Gopkg.toml, Gopkg.lock, and vendor are out of sync ([#1932](https://github.com/golang/dep/pull/1932)).\n\nBUG FIXES:\n\n* Excise certain git-related environment variables. ([#1872](https://github.com/golang/dep/pull/1872))\n\nIMPROVEMENTS:\n\n* Add template operations support in dep status template output ([#1549](https://github.com/golang/dep/pull/1549)).\n* Reduce network access by trusting local source information and only pulling from upstream when necessary ([#1250](https://github.com/golang/dep/pull/1250)).\n* Update our dependency on Masterminds/semver to follow upstream again now that [Masterminds/semver#67](https://github.com/Masterminds/semver/pull/67) is merged([#1792](https://github.com/golang/dep/pull/1792)).\n* `inputs-digest` was removed from `Gopkg.lock` ([#1912](https://github.com/golang/dep/pull/1912)).\n* Hash digests of vendor contents are now stored in `Gopkg.lock`, and the contents of vendor are only rewritten on change or hash mismatch ([#1912](https://github.com/golang/dep/pull/1912)).\n* Don't exclude `Godeps` folder ([#1822](https://github.com/golang/dep/issues/1822)).\n* Add project-package relationship graph support in graphviz ([#1588](https://github.com/golang/dep/pull/1588)).\n* Limit concurrency of `dep status` to avoid hitting open file limits ([#1923](https://github.com/golang/dep/issue/1923)).\n\nWIP:\n* Enable importing external configuration from dependencies during init (#1277). This is feature flagged and disabled by default.\n\n# v0.4.1\n\nNEW FEATURES:\n\nBUG FIXES:\n\n* Fix per-project prune option handling ([#1570](https://github.com/golang/dep/pull/1570))\n\n# v0.4.0\n\nNEW FEATURES:\n\n* Absorb `dep prune` into `dep ensure`. ([#944](https://github.com/golang/dep/issues/944))\n* Add support for importing from [glock](https://github.com/robfig/glock) based projects. ([#1422](https://github.com/golang/dep/pull/1422))\n* Add support for importing from [govendor](https://github.com/kardianos/govendor) based projects. ([#815](https://github.com/golang/dep/pull/815))\n* Allow override of cache directory location using environment variable `DEPCACHEDIR`. ([#1234](https://github.com/golang/dep/pull/1234))\n* Add support for template output in `dep status`. ([#1389](https://github.com/golang/dep/pull/1389))\n* Each element in a multi-item TOML array is output on its own line. ([#1461](https://github.com/golang/dep/pull/1461))\n\nBUG FIXES:\n\n* Releases targeting Windows now have a `.exe` suffix. ([#1291](https://github.com/golang/dep/pull/1291))\n* Adaptively recover from dirty and corrupted git repositories in cache. ([#1279](https://github.com/golang/dep/pull/1279))\n* Suppress git password prompts in more places. ([#1357](https://github.com/golang/dep/pull/1357))\n* Fix `-no-vendor` flag for `ensure -update`. ([#1361](https://github.com/golang/dep/pull/1361))\n* Validate `git ls-remote` output and ignore all malformed lines. ([#1379](https://github.com/golang/dep/pull/1379))\n* Support [gopkg.in version zero](http://labix.org/gopkg.in#VersionZero). ([#1243](https://github.com/golang/dep/pull/1243))\n* Fix how dep status print revision constraints. ([#1421](https://github.com/golang/dep/pull/1421))\n* Add optional `-v` flag to ensure sub command's syntax. ([#1458](https://github.com/golang/dep/pull/1458))\n* Allow URLs containing ports in `Gopkg.toml` `source` fields. ([#1509](https://github.com/golang/dep/pull/1509))\n\nIMPROVEMENTS:\n\n* Log as dependencies are pre-fetched during dep init. ([#1176](https://github.com/golang/dep/pull/1176))\n* Make the gps package importable. ([#1349](https://github.com/golang/dep/pull/1349))\n* Improve file copy performance by not forcing a file sync. ([#1408](https://github.com/golang/dep/pull/1408))\n* Skip empty constraints during import. ([#1414](https://github.com/golang/dep/pull/1349))\n* Handle errors when writing status output. ([#1420](https://github.com/golang/dep/pull/1420))\n* Add constraint for locked projects in `dep status`. ([#962](https://github.com/golang/dep/pull/962))\n* Make external config importers error tolerant. ([#1315](https://github.com/golang/dep/pull/1315))\n* Show LATEST and VERSION as the same type in status. ([#1515](https://github.com/golang/dep/pull/1515))\n* Warn when [[constraint]] rules that will have no effect. ([#1534](https://github.com/golang/dep/pull/1534))\n\n# v0.3.2\n\nNEW FEATURES:\n\n* Add support for importing from [gvt](https://github.com/FiloSottile/gvt)\nand [gb](https://godoc.org/github.com/constabulary/gb/cmd/gb-vendor).\n([#1149](https://github.com/golang/dep/pull/1149))\n* Wildcard ignore support. ([#1156](https://github.com/golang/dep/pull/1156))\n* Disable SourceManager lock by setting `DEPNOLOCK` environment variable.\n([#1206](https://github.com/golang/dep/pull/1206))\n* `dep ensure -no-vendor -dry-run` now exits with an error when changes would\nhave to be made to `Gopkg.lock`. This is useful for CI. ([#1256](https://github.com/golang/dep/pull/1256))\n\nBUG FIXES:\n\n* gps: Fix case mismatch error with multiple dependers. ([#1233](https://github.com/golang/dep/pull/1233))\n* Skip broken `vendor` symlink rather than returning an error. ([#1191](https://github.com/golang/dep/pull/1191))\n* Fix `status` shows incorrect reason for lock mismatch when ignoring packages.\n([#1216](https://github.com/golang/dep/pull/1216))\n\nIMPROVEMENTS:\n\n* Allow `dep ensure -add` and `-update` when lock is out-of-sync. ([#1225](https://github.com/golang/dep/pull/1225))\n* gps: vcs: Dedupe git version list ([#1212](https://github.com/golang/dep/pull/1212))\n* gps: Add prune functions to gps. ([#1020](https://github.com/golang/dep/pull/1020))\n* gps: Skip broken vendor symlinks. ([#1191](https://github.com/golang/dep/pull/1191))\n* `dep ensure -add` now concurrently fetches the source and adds the projects.\n([#1218](https://github.com/golang/dep/pull/1218))\n* File name case check is now performed on `Gopkg.toml` and `Gopkg.lock`.\n([#1114](https://github.com/golang/dep/pull/1114))\n* gps: gps now supports pruning. ([#1020](https://github.com/golang/dep/pull/1020))\n* `dep ensure -update` now concurrently validates the passed project arguments.\nImproving performance when updating dependencies with `-update`. ([#1175](https://github.com/golang/dep/pull/1175))\n* `dep status` now concurrently fetches repo info. Improving status performance.\n([#1135](https://github.com/golang/dep/pull/1135))\n* gps: Add SourceURLsForPath() to SourceManager. ([#1166](https://github.com/golang/dep/pull/1166))\n* gps: Include output in error. ([#1180](https://github.com/golang/dep/pull/1180))\n\nWIP:\n\n* gps: Process canonical import paths. ([#1017](https://github.com/golang/dep/pull/1017))\n* gps: Persistent cache. ([#1127](https://github.com/golang/dep/pull/1127), [#1215](https://github.com/golang/dep/pull/1215))\n\n\n# v0.3.1\n\n* gps: Add satisfiability check for case variants ([#1079](https://github.com/golang/dep/pull/1079))\n* Validate Project Roots in manifest ([#1116](https://github.com/golang/dep/pull/1116))\n* gps: Properly separate sources for different gopkg.in versions & github\n([#1132](https://github.com/golang/dep/pull/1132))\n* gps: Add persistent BoltDB cache ([#1098](https://github.com/golang/dep/pull/1098))\n* gps: Increase default subcommand timeout to 30s ([#1087](https://github.com/golang/dep/pull/1087))\n* Fix importer [issue](https://github.com/golang/dep/issues/939) where the\nimporter would drop the imported version of a project ([#1100](https://github.com/golang/dep/pull/1100))\n* Import analyzer now always uses the same name, fixing the lock mismatch\nimmediately after dep init issue ([#1099](https://github.com/golang/dep/pull/1099))\n* Add support for importing from [govend](https://github.com/govend/govend)\n(#1040) and [LK4D4/vndr](https://github.com/LK4D4/vndr) ([#978](https://github.com/golang/dep/pull/978)) based projects\n* gps: gps no longer assumes that every git repo has a HEAD ([#1053](https://github.com/golang/dep/pull/1053))\n* `os.Chmod` failures on Windows due to long path length has been fixed ([#925](https://github.com/golang/dep/pull/925))\n* Add `version` command ([#996](https://github.com/golang/dep/pull/996))\n* Drop support for building with go1.7 ([#714](https://github.com/golang/dep/pull/714))\n* gps: Parse abbreviated git revisions ([#1027](https://github.com/golang/dep/pull/1027))\n* gps: Parallelize writing dep tree ([#1021](https://github.com/golang/dep/pull/1021))\n* `status` now shows the progress in verbose mode ([#1009](https://github.com/golang/dep/pull/1009), [#1037](https://github.com/golang/dep/pull/1037))\n* Fix empty `Constraint` and `Version` in `status` json output ([#976](https://github.com/golang/dep/pull/976))\n* `status` table output now shows override constraints ([#918](https://github.com/golang/dep/pull/918))\n* gps: Display warning message every 15 seconds when lockfile is busy ([#958](https://github.com/golang/dep/pull/958))\n* gps: Hashing directory tree and tree verification ([#959](https://github.com/golang/dep/pull/959))\n* `ensure` now has `-vendor-only` mode to populate vendor/ without updating\nGopkg.lock ([#954](https://github.com/golang/dep/pull/954))\n* Use fork of Masterminds/semver until\nMasterminds/semver [issue#59](https://github.com/Masterminds/semver/issues/59)\nis fixed upstream ([#938](https://github.com/golang/dep/pull/938))\n* gps: Ensure packages are deducible before attempting to solve ([#697](https://github.com/golang/dep/pull/697))\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.1552734375,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as\ncontributors and maintainers pledge to making participation in our project and\nour community a harassment-free experience for everyone, regardless of age, body\nsize, disability, ethnicity, gender identity and expression, level of\nexperience, nationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment\ninclude:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or\n  advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic\n  address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable\nbehavior and are expected to take appropriate and fair corrective action in\nresponse to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, or to ban temporarily or permanently any\ncontributor for other behaviors that they deem inappropriate, threatening,\noffensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community. Examples of\nrepresenting a project or community include using an official project e-mail\naddress, posting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event. Representation of a project may be\nfurther defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported by contacting the project team at sam (at) samboyer.org. All complaints\nwill be reviewed and investigated and will result in a response that is deemed\nnecessary and appropriate to the circumstances. The project team is obligated to\nmaintain confidentiality with regard to the reporter of an incident. Further\ndetails of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good\nfaith may face temporary or permanent repercussions as determined by other\nmembers of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 8.7021484375,
          "content": "# Contributing to `dep`\n\n`dep` is an open source project.\n\nIt is the work of hundreds of contributors. We appreciate your help!\n\nKeep an eye on the [Roadmap](https://github.com/golang/dep/wiki/Roadmap) for a summary of where the project is, and where we're headed.\n\n## Filing issues\n\nPlease check the existing issues and [FAQ](docs/FAQ.md) to see if your feedback has already been reported.\n\nGeneral questions should go to the [golang-nuts mailing list](https://groups.google.com/group/golang-nuts) or the [Gophers Slack #vendor channel](https://gophers.slack.com/messages/C0M5YP9LN/) instead of the issue tracker.\nThe gophers there will answer or ask you to file an issue if you've tripped over a bug.\nFor an invite to the Slack channel, [fill out this form](https://invite.slack.golangbridge.org/).\n\nWhen [filing an issue](https://github.com/golang/dep/issues/new), make sure to answer these five questions:\n\n1. What version of Go (`go version`) and `dep` (`git describe --tags`) are you using??\n3. What `dep` command did you run?\n4. What did you expect to see?\n5. What did you see instead?\n\n## Contributing code\n\nLet us know if you are interested in working on an issue by leaving a comment\non the issue in GitHub. This helps avoid multiple people unknowingly\nworking on the same issue.\n\nPlease read the [Contribution Guidelines](https://golang.org/doc/contribute.html)\nbefore sending patches.\n\nThe\n[help wanted](https://github.com/golang/dep/issues?q=is%3Aissue+is%3Aopen+label%3A%22help%20wanted%22)\nlabel highlights issues that are well-suited for folks to jump in on. The\n[good first issue](https://github.com/golang/dep/issues?q=is%3Aissue+is%3Aopen+label%3A%22good%20first%20issue%22)\nlabel further identifies issues that are particularly well-sized for newcomers.\n\nUnless otherwise noted, the `dep` source files are distributed under\nthe BSD-style license found in the LICENSE file.\n\nAll submissions, including submissions by project members, require review. We\nuse GitHub pull requests for this purpose. Consult [GitHub Help] for more\ninformation on using pull requests.\n\nWe check `dep`'s own `vendor` directory into git. For any PR to `dep` where you're\nupdating `Gopkg.toml`, make sure to run `dep ensure` and commit all changes to `vendor`.\n\n[GitHub Help]: https://help.github.com/articles/about-pull-requests/\n\n## Contributing to the Documentation\n\nAll the docs reside in the [`docs/`](docs/) directory. For any relatively small\nchange - like fixing a typo or rewording something - the easiest way to\ncontribute is directly on Github, using their web code editor.\n\nFor relatively big change - changes in the design, links or adding a new page -\nthe docs site can be run locally. We use [docusaurus](http://docusaurus.io/) to\ngenerate the docs site. [`website/`](website/) directory contains all the\ndocusaurus configurations. To run the site locally, `cd` into `website/`\ndirectory and run `npm i --only=dev` to install all the dev dependencies. Then\nrun `npm start` to start serving the site. By default, the site would be served\nat http://localhost:3000.\n\n## Contributor License Agreement\n\nContributions to this project must be accompanied by a Contributor License\nAgreement. You (or your employer) retain the copyright to your contribution,\nthis simply gives us permission to use and redistribute your contributions as\npart of the project. Head over to <https://cla.developers.google.com/> to see\nyour current agreements on file or to sign a new one.\n\nYou generally only need to submit a CLA once, so if you've already submitted one\n(even if it was for a different project), you probably don't need to do it\nagain.\n\n## Maintainer's Guide\n\n`dep` has subsystem maintainers; this guide is intended for them in performing their work as a maintainer.\n\n### General guidelines\n\n* _Be kind, respectful, and inclusive_. Really live that [CoC](https://github.com/golang/dep/blob/master/CODE_OF_CONDUCT.md). We've developed a reputation as one of the most welcoming and supportive project environments in the Go community, and we want to keep that up!\n* The lines of responsibility between maintainership areas can be fuzzy. Get to know your fellow maintainers - it's important to work _with_ them when an issue falls in this grey area.\n* Remember, the long-term goal of `dep` is to disappear into the `go` toolchain. That's going to be a challenging process, no matter what. Minimizing that eventual difficulty should be a guiding light for all your decisions today.\n  * Try to match the toolchain's assumptions as closely as possible ([example](https://github.com/golang/dep/issues/564#issuecomment-300994599)), and avoid introducing new rules the toolchain would later have to incorporate.\n  * Every new flag or option in the metadata files is more exposed surface area that demands conversion later. Only add these with a clear design plan.\n  * `dep` is experimental, but increasingly only on a larger scale. Experiments need clear hypotheses and parameters for testing - nothing off-the-cuff.\n* Being a maintainer doesn't mean you're always right. Admitting when you've made a mistake keeps the code flowing, the environment health, and the respect level up.\n* It's fine if you need to step back from maintainership responsibilities - just, please, don't fade away! Let other maintainers know what's going on.\n\n### Issue management\n\n* We use [Zenhub](https://www.zenhub.com) to manage the queue, in addition to what we do with labels.\n  * You will need to install [ZenHub extension](https://www.zenhub.com/extension) to your browser to show the board.\n  * Pipelines, and [the board](https://github.com/golang/dep#boards) are one thing we try to utilize:\n    * **New Issues Pipeline**: When someone creates a new issue, it goes here first. Keep an eye out for issues that fall into your area. Add labels to them, and if it's something we should do, put it in the `Backlog` pipeline. If you aren't sure, throw it in the `Icebox`. It helps to sort this pipeline by date.\n    * **Icebox Pipeline**: Issues that we aren't immediately closing but aren't really ready to be prioritized and started on. It's not a wontfix bucket, but a \"not sure if we should/can fix right now\" bucket.\n    * **Backlog Pipeline**: Issues that we know we want to tackle. You can drag/drop up and down to prioritize issues.\n  * Marking dependencies/blockers is also quite useful where appropriate; please do that.\n  * We use epics and milestones in roughly the same way (because OSS projects don't have real sprints). Epics should be duplicated as milestones; if there's a main epic issue, it should contain a checklist of the relevant issues to complete it.\n* The `area:` labels correspond to maintainership areas. Apply yours to any issues or PRs that fall under your purview. It's to be expected that multiple `area:` labels may be applied to a single issue.\n* The [`help wanted`](https://github.com/golang/dep/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22) and [`good first issue`](https://github.com/golang/dep/labels/good%20first%20issue) labels are two of our most important tools for making the project accessible to newcomers - a key goal for our community. Here's how to use them well.\n  * `good-first-pr` should be applied when there's a very straightforward, self-contained task that is very unlikely to have any hidden complexity. The real purpose of these is to provide a \"chink in the armor\", providing newcomers a lens through which to start understanding the project.\n  * `help-wanted` should be applied to issues where there's a clear, stated goal, there is at most one significant question that needs answering, and it looks like the implementation won't be inordinately difficult, or disruptive to other parts of the system.\n    * `help-wanted` should also be applied to all `good-first-pr` issues - it's duplicative, but not doing so seems unfriendly.\n\n\n### Pull Requests\n\n* Try to make, and encourage, smaller pull requests.\n* [No is temporary. Yes is forever.](https://blog.jessfraz.com/post/the-art-of-closing/)\n* Long-running feature branches should generally be avoided. Discuss it with other maintainers first.\n* Unless it's trivial, don't merge your own PRs - ask another maintainer.\n* Commit messages should follow [Tim Pope's rules](http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html).\n* Checklist for merging PRs:\n  * Does the PR pass [the code review comments](https://github.com/golang/go/wiki/CodeReviewComments)? (internalize these rules!)\n  * Are there tests to cover new or changed behavior? Prefer reliable tests > no tests > flaky tests.\n  * Does the first post in the PR contain \"Fixes #...\" text for any issues it resolves?\n  * Are any necessary follow-up issues _already_ posted, prior to merging?\n  * Does this change entail the updating of any docs?\n     * For docs kept in the repo, e.g. FAQ.md, docs changes _must_ be submitted as part of the same PR.\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.166015625,
          "content": "# This source code was written by the Go contributors.\n# The master list of contributors is in the main Go distribution,\n# visible at http://tip.golang.org/CONTRIBUTORS.\n"
        },
        {
          "name": "Gopkg.lock",
          "type": "blob",
          "size": 4.359375,
          "content": "# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n\n[[projects]]\n  branch = \"2.x\"\n  digest = \"1:ee2887fecb4d923fa90f8dd9cf33e876bf9260fed62f2ca5a5c3f41b4eb07683\"\n  name = \"github.com/Masterminds/semver\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"24642bd0573145a5ee04f9be773641695289be46\"\n\n[[projects]]\n  digest = \"1:442020d26d1f891d5014cae4353b6ff589562c2b303504627de3660adf3fb217\"\n  name = \"github.com/Masterminds/vcs\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"3084677c2c188840777bff30054f2b553729d329\"\n  version = \"v1.11.1\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:60861e762bdbe39c4c7bf292c291329b731c9925388fd41125888f5c1c595feb\"\n  name = \"github.com/armon/go-radix\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"4239b77079c7b5d1243b7b4736304ce8ddb6f0f2\"\n\n[[projects]]\n  digest = \"1:a12d94258c5298ead75e142e8001224bf029f302fed9e96cd39c0eaf90f3954d\"\n  name = \"github.com/boltdb/bolt\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"2f1ce7a837dcb8da3ec595b1dac9d0632f0f99e8\"\n  version = \"v1.3.1\"\n\n[[projects]]\n  digest = \"1:9f35c1344b56e5868d511d231f215edd0650aa572664f856444affdd256e43e4\"\n  name = \"github.com/golang/protobuf\"\n  packages = [\"proto\"]\n  pruneopts = \"NUT\"\n  revision = \"925541529c1fa6821df4e44ce2723319eb2be768\"\n  version = \"v1.0.0\"\n\n[[projects]]\n  digest = \"1:2e3c336fc7fde5c984d2841455a658a6d626450b1754a854b3b32e7a8f49a07a\"\n  name = \"github.com/google/go-cmp\"\n  packages = [\n    \"cmp\",\n    \"cmp/internal/diff\",\n    \"cmp/internal/function\",\n    \"cmp/internal/value\",\n  ]\n  pruneopts = \"NUT\"\n  revision = \"3af367b6b30c263d47e8895973edcca9a49cf029\"\n  version = \"v0.2.0\"\n\n[[projects]]\n  digest = \"1:f5169729244becc423886eae4d72547e28ac3f13f861bed8a9d749bc7238a1c3\"\n  name = \"github.com/jmank88/nuts\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"8b28145dffc87104e66d074f62ea8080edfad7c8\"\n  version = \"v0.3.0\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:01af3a6abe28784782680e1f75ef8767cfc5d4b230dc156ff7eb8db395cbbfd2\"\n  name = \"github.com/nightlyone/lockfile\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"e83dc5e7bba095e8d32fb2124714bf41f2a30cb5\"\n\n[[projects]]\n  digest = \"1:51ea800cff51752ff68e12e04106f5887b4daec6f9356721238c28019f0b42db\"\n  name = \"github.com/pelletier/go-toml\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"c01d1270ff3e442a8a57cddc1c92dc1138598194\"\n  version = \"v1.2.0\"\n\n[[projects]]\n  digest = \"1:5cf3f025cbee5951a4ee961de067c8a89fc95a5adabead774f82822efabab121\"\n  name = \"github.com/pkg/errors\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"645ef00459ed84a119197bfb8d8205042c6df63d\"\n  version = \"v0.8.0\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:abb4b60c28323cde32c193ce6083bb600fac462d1780cf83461b4c23ed5ce904\"\n  name = \"github.com/sdboyer/constext\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"836a144573533ea4da4e6929c235fd348aed1c80\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:6ad2104db8f34b8656382ef0a7297b9a5cc42e7bdce95d968e02b92fc97470d1\"\n  name = \"golang.org/x/net\"\n  packages = [\"context\"]\n  pruneopts = \"NUT\"\n  revision = \"66aacef3dd8a676686c7ae3716979581e8b03c47\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:39ebcc2b11457b703ae9ee2e8cca0f68df21969c6102cb3b705f76cca0ea0239\"\n  name = \"golang.org/x/sync\"\n  packages = [\"errgroup\"]\n  pruneopts = \"NUT\"\n  revision = \"f52d1811a62927559de87708c8913c1650ce4f26\"\n\n[[projects]]\n  branch = \"master\"\n  digest = \"1:51912e607c5e28a89fdc7e41d3377b92086ab7f76ded236765dbf98d0a704c5d\"\n  name = \"golang.org/x/sys\"\n  packages = [\"unix\"]\n  pruneopts = \"NUT\"\n  revision = \"bb24a47a89eac6c1227fbcb2ae37a8b9ed323366\"\n\n[[projects]]\n  branch = \"v2\"\n  digest = \"1:13e704c08924325be00f96e47e7efe0bfddf0913cdfc237423c83f9b183ff590\"\n  name = \"gopkg.in/yaml.v2\"\n  packages = [\".\"]\n  pruneopts = \"NUT\"\n  revision = \"d670f9405373e636a5a2765eea47fac0c9bc91a4\"\n\n[solve-meta]\n  analyzer-name = \"dep\"\n  analyzer-version = 1\n  input-imports = [\n    \"github.com/Masterminds/semver\",\n    \"github.com/Masterminds/vcs\",\n    \"github.com/armon/go-radix\",\n    \"github.com/boltdb/bolt\",\n    \"github.com/golang/protobuf/proto\",\n    \"github.com/google/go-cmp/cmp\",\n    \"github.com/jmank88/nuts\",\n    \"github.com/nightlyone/lockfile\",\n    \"github.com/pelletier/go-toml\",\n    \"github.com/pkg/errors\",\n    \"github.com/sdboyer/constext\",\n    \"golang.org/x/sync/errgroup\",\n    \"golang.org/x/sys/unix\",\n    \"gopkg.in/yaml.v2\",\n  ]\n  solver-name = \"gps-cdcl\"\n  solver-version = 1\n"
        },
        {
          "name": "Gopkg.toml",
          "type": "blob",
          "size": 0.490234375,
          "content": "[[constraint]]\n  name = \"github.com/Masterminds/semver\"\n  branch = \"2.x\"\n\n[[constraint]]\n  name = \"github.com/Masterminds/vcs\"\n  version = \"1.11.0\"\n\n[[constraint]]\n  name = \"github.com/pelletier/go-toml\"\n  version = \"1.2.0\"\n\n[[constraint]]\n  name = \"github.com/pkg/errors\"\n  version = \"0.8.0\"\n\n[[constraint]]\n  name = \"github.com/boltdb/bolt\"\n  version = \"1.0.0\"\n\n[[constraint]]\n  name = \"github.com/jmank88/nuts\"\n  version = \"0.3.0\"\n\n[prune]\n  non-go = true\n  go-tests = true\n  unused-packages = true\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4443359375,
          "content": "Copyright (c) 2014 The Go Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "MAINTAINERS.md",
          "type": "blob",
          "size": 0.443359375,
          "content": "\nGeneral maintainers:\n    sam boyer (@sdboyer)\n\n* dep\n  * `init` command: Carolyn Van Slyck (@carolynvs)\n  * `ensure` command: Ibrahim AshShohail (@ibrasho)\n  * `status` command: Sunny (@darkowlzz)\n  * testing harness: (vacant)\n* gps\n  * solver: (vacant)\n  * source manager: (@jmank88)\n  * root deduction: (vacant)\n  * source/vcs interaction: (@jmank88)\n  * caching: Jordan Krage (@jmank88)\n  * pkgtree: (vacant)\n  * versions and constraints: (@jmank88)\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.767578125,
          "content": "SHELL := /bin/bash\nPLATFORM := $(shell go env GOOS)\nARCH := $(shell go env GOARCH)\nGOPATH := $(shell go env GOPATH)\nGOBIN := $(GOPATH)/bin\n\ndefault: build validate test\n\nget-deps:\n\tgo get -u golang.org/x/lint/golint honnef.co/go/tools/cmd/staticcheck\n\nbuild:\n\tgo fmt ./...\n\tDEP_BUILD_PLATFORMS=$(PLATFORM) DEP_BUILD_ARCHS=$(ARCH) ./hack/build-all.bash\n\tcp ./release/dep-$(PLATFORM)-$(ARCH) dep\n\nlicenseok:\n\tgo build -o licenseok ./hack/licenseok/main.go\n\nvalidate: build licenseok\n\t./dep check\n\t./hack/lint.bash\n\t./hack/validate-licence.bash\n\ntest: build\n\t./hack/test.bash\n\ninstall: build\n\tcp ./dep $(GOBIN)\n\ndocusaurus:\n\tdocker run --rm -it -v `pwd`:/dep -p 3000:3000 \\\n\t\t-w /dep/website node \\\n\t\tbash -c \"npm i --only=dev && npm start\"\n\n.PHONY: build validate test install docusaurus\n"
        },
        {
          "name": "PATENTS",
          "type": "blob",
          "size": 1.2724609375,
          "content": "Additional IP Rights Grant (Patents)\n\n\"This implementation\" means the copyrightable works distributed by\nGoogle as part of the Go project.\n\nGoogle hereby grants to You a perpetual, worldwide, non-exclusive,\nno-charge, royalty-free, irrevocable (except as stated in this section)\npatent license to make, have made, use, offer to sell, sell, import,\ntransfer and otherwise run, modify and propagate the contents of this\nimplementation of Go, where such license applies only to those patent\nclaims, both currently owned or controlled by Google and acquired in\nthe future, licensable by Google that are necessarily infringed by this\nimplementation of Go.  This grant does not include claims that would be\ninfringed only as a consequence of further modification of this\nimplementation.  If you or your agent or exclusive licensee institute or\norder or agree to the institution of patent litigation against any\nentity (including a cross-claim or counterclaim in a lawsuit) alleging\nthat this implementation of Go or any code incorporated within this\nimplementation of Go constitutes direct or contributory patent\ninfringement, or inducement of patent infringement, then any patent\nrights granted to you under this License for this implementation of Go\nshall terminate as of the date such litigation is filed.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.1728515625,
          "content": "<p align=\"center\"><img src=\"docs/assets/DigbyShadows.png\" width=\"360\"></p>\n<p align=\"center\">\n  <a href=\"https://travis-ci.org/golang/dep\"><img src=\"https://travis-ci.org/golang/dep.svg?branch=master\" alt=\"Build Status\"></img></a>\n  <a href=\"https://ci.appveyor.com/project/golang/dep\"><img src=\"https://ci.appveyor.com/api/projects/status/github/golang/dep?svg=true&branch=master&passingText=Windows%20-%20OK&failingText=Windows%20-%20failed&pendingText=Windows%20-%20pending\" alt=\"Windows Build Status\"></a>\n  <a href=\"https://goreportcard.com/report/github.com/golang/dep\"><img src=\"https://goreportcard.com/badge/github.com/golang/dep\" /></a>\n</p>\n\n## Dep\n\n`dep` is a dependency management tool for Go. It requires Go 1.9 or newer to compile.\n\n**NOTE:** Dep was an official experiment to implement a package manager for Go.\nAs of 2020, Dep is deprecated and archived in favor of Go modules, which have\nhad official support since Go 1.11. For more details, see https://golang.org/ref/mod.\n\nFor guides and reference materials about `dep`, see [the documentation](https://golang.github.io/dep).\n\n## Installation\n\nYou should use an officially released version. Release binaries are available on\nthe [releases](https://github.com/golang/dep/releases) page.\n\nOn MacOS you can install or upgrade to the latest released version with Homebrew:\n\n```sh\n$ brew install dep\n$ brew upgrade dep\n```\n\nOn Debian platforms you can install or upgrade to the latest version with apt-get:\n\n```sh\n$ sudo apt-get install go-dep\n```\n\nOn Windows, you can download a tarball from\n[go.equinox.io](https://go.equinox.io/github.com/golang/dep/cmd/dep).\n\nOn other platforms you can use the `install.sh` script:\n\n```sh\n$ curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh\n```\n\nIt will install into your `$GOPATH/bin` directory by default or any other directory you specify using the `INSTALL_DIRECTORY` environment variable.\n\nIf your platform is not supported, you'll need to build it manually or let the team know and we'll consider adding your platform\nto the release builds.\n\nIf you're interested in getting the source code, or hacking on `dep`, you can\ninstall via `go get`:\n\n```sh\ngo get -u github.com/golang/dep/cmd/dep\n```\n"
        },
        {
          "name": "analyzer.go",
          "type": "blob",
          "size": 1.2744140625,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/internal/fs\"\n)\n\n// Analyzer implements gps.ProjectAnalyzer.\ntype Analyzer struct{}\n\n// HasDepMetadata determines if a dep manifest exists at the specified path.\nfunc (a Analyzer) HasDepMetadata(path string) bool {\n\tmf := filepath.Join(path, ManifestName)\n\tfileOK, err := fs.IsRegular(mf)\n\treturn err == nil && fileOK\n}\n\n// DeriveManifestAndLock reads and returns the manifest at path/ManifestName or nil if one is not found.\n// The Lock is always nil for now.\nfunc (a Analyzer) DeriveManifestAndLock(path string, n gps.ProjectRoot) (gps.Manifest, gps.Lock, error) {\n\tif !a.HasDepMetadata(path) {\n\t\treturn nil, nil, nil\n\t}\n\n\tf, err := os.Open(filepath.Join(path, ManifestName))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer f.Close()\n\n\t// Ignore warnings irrelevant to user.\n\tm, _, err := readManifest(f)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn m, nil, nil\n}\n\n// Info returns Analyzer's name and version info.\nfunc (a Analyzer) Info() gps.ProjectAnalyzerInfo {\n\treturn gps.ProjectAnalyzerInfo{\n\t\tName:    \"dep\",\n\t\tVersion: 1,\n\t}\n}\n"
        },
        {
          "name": "analyzer_notwindows_test.go",
          "type": "blob",
          "size": 0.41796875,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !windows\n\npackage dep\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\nfunc makeUnreadable(path string) (io.Closer, error) {\n\terr := os.Chmod(path, 0222)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn closer{}, nil\n}\n\ntype closer struct{}\n\nfunc (closer) Close() error { return nil }\n"
        },
        {
          "name": "analyzer_test.go",
          "type": "blob",
          "size": 2.720703125,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/golang/dep/internal/test\"\n)\n\nfunc TestAnalyzerDeriveManifestAndLock(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"dep\")\n\tgolden := filepath.Join(\"analyzer\", ManifestName)\n\twant := h.GetTestFileString(golden)\n\th.TempCopy(filepath.Join(\"dep\", ManifestName), golden)\n\n\ta := Analyzer{}\n\n\tm, l, err := a.DeriveManifestAndLock(h.Path(\"dep\"), \"my/fake/project\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tgot, err := m.(*Manifest).MarshalTOML()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif want != string(got) {\n\t\tif *test.UpdateGolden {\n\t\t\tif err := h.WriteTestFile(golden, string(got)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Fatalf(\"(WNT):\\n%s\\n(GOT):\\n%s\", want, string(got))\n\t\t}\n\t}\n\n\tif l != nil {\n\t\tt.Fatalf(\"expected lock to be nil, got: %#v\", l)\n\t}\n}\n\nfunc TestAnalyzerDeriveManifestAndLockDoesNotExist(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"dep\")\n\n\ta := Analyzer{}\n\n\tm, l, err := a.DeriveManifestAndLock(h.Path(\"dep\"), \"my/fake/project\")\n\tif m != nil || l != nil || err != nil {\n\t\tt.Fatalf(\"expected manifest & lock & err to be nil: m -> %#v l -> %#v err-> %#v\", m, l, err)\n\t}\n}\n\nfunc TestAnalyzerDeriveManifestAndLockCannotOpen(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"dep\")\n\n\t// Simulate an inaccessible manifest file.\n\th.TempFile(filepath.Join(\"dep\", ManifestName), \"\")\n\tcloser, err := makeUnreadable(filepath.Join(h.Path(\"dep\"), ManifestName))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer closer.Close()\n\n\ta := Analyzer{}\n\n\t// Verify that the solver rejects the manifest, rather than treating it as\n\t// offering no constraints.\n\tm, l, err := a.DeriveManifestAndLock(h.Path(\"dep\"), \"my/fake/project\")\n\tif m != nil || l != nil || err == nil {\n\t\tt.Fatalf(\"expected manifest & lock to be nil, err to be not nil: m -> %#v l -> %#v err -> %#v\", m, l, err)\n\t}\n}\n\nfunc TestAnalyzerDeriveManifestAndLockInvalidManifest(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"dep\")\n\n\t// Create a manifest with invalid contents\n\th.TempFile(filepath.Join(\"dep\", ManifestName), \"invalid manifest\")\n\n\ta := Analyzer{}\n\n\tm, l, err := a.DeriveManifestAndLock(h.Path(\"dep\"), \"my/fake/project\")\n\tif m != nil || l != nil || err == nil {\n\t\tt.Fatalf(\"expected manifest & lock & err to be nil: m -> %#v l -> %#v err-> %#v\", m, l, err)\n\t}\n}\n\nfunc TestAnalyzerInfo(t *testing.T) {\n\ta := Analyzer{}\n\n\tinfo := a.Info()\n\n\tif info.Name != \"dep\" || info.Version != 1 {\n\t\tt.Fatalf(\"expected name to be 'dep' and version to be 1: name -> %q vers -> %d\", info.Name, info.Version)\n\t}\n}\n"
        },
        {
          "name": "analyzer_windows_test.go",
          "type": "blob",
          "size": 0.9560546875,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"syscall\"\n)\n\n// makeUnreadable opens the file at path in exclusive mode. A file opened in\n// exclusive mode cannot be opened again until the exclusive mode file handle\n// is closed.\nfunc makeUnreadable(path string) (io.Closer, error) {\n\tif len(path) == 0 {\n\t\treturn nil, syscall.ERROR_FILE_NOT_FOUND\n\t}\n\tpathp, err := syscall.UTF16PtrFromString(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\taccess := uint32(syscall.GENERIC_READ | syscall.GENERIC_WRITE)\n\tsharemode := uint32(0) // no sharing == exclusive mode\n\tsa := (*syscall.SecurityAttributes)(nil)\n\tcreatemode := uint32(syscall.OPEN_EXISTING)\n\th, err := syscall.CreateFile(pathp, access, sharemode, sa, createmode, syscall.FILE_ATTRIBUTE_NORMAL, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn os.NewFile(uintptr(h), path), nil\n}\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.7705078125,
          "content": "version: \"{build}\"\n\n# Source Config\n\nclone_folder: c:\\gopath\\src\\github.com\\golang\\dep\n\n# Build host\n\nenvironment:\n  GOPATH: c:\\gopath\n  DEPTESTBYPASS501: 1\n  GOVERSION: 1.9\n\ninit:\n  - git config --global core.autocrlf input\n\n# Build\n\ninstall:\n  # Install the specific Go version.\n  - rmdir c:\\go /s /q\n  - appveyor DownloadFile https://storage.googleapis.com/golang/go%GOVERSION%.windows-amd64.msi\n  - msiexec /i go%GOVERSION%.windows-amd64.msi /q\n  - choco install bzr\n  - set Path=c:\\go\\bin;c:\\gopath\\bin;C:\\Program Files (x86)\\Bazaar\\;C:\\Program Files\\Mercurial\\%Path%\n  - go version\n  - go env\n\nbuild: false\ndeploy: false\n\ntest_script:\n  - go build github.com/golang/dep/cmd/dep\n  - for /f \"\" %%G in ('go list github.com/golang/dep/...') do ( go test %%G & IF ERRORLEVEL == 1 EXIT 1)\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 10.849609375,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"sort\"\n\t\"time\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/gps/paths\"\n\t\"github.com/golang/dep/gps/pkgtree\"\n\t\"github.com/golang/dep/gps/verify\"\n\t\"github.com/golang/dep/internal/fs\"\n\t\"github.com/pkg/errors\"\n)\n\n// Ctx defines the supporting context of dep.\n//\n// A properly initialized Ctx has a GOPATH containing the project root and non-nil Loggers.\n//\n//\tctx := &dep.Ctx{\n//\t\tWorkingDir: GOPATH + \"/src/project/root\",\n//\t\tGOPATH: GOPATH,\n//\t\tOut: log.New(os.Stdout, \"\", 0),\n//\t\tErr: log.New(os.Stderr, \"\", 0),\n//\t}\n//\n// Ctx.DetectProjectGOPATH() helps with setting the containing GOPATH.\n//\n//\tctx.GOPATH, err := Ctx.DetectProjectGOPATH(project)\n//\tif err != nil {\n//\t\t// Could not determine which GOPATH to use for the project.\n//\t}\n//\ntype Ctx struct {\n\tWorkingDir     string        // Where to execute.\n\tGOPATH         string        // Selected Go path, containing WorkingDir.\n\tGOPATHs        []string      // Other Go paths.\n\tExplicitRoot   string        // An explicitly-set path to use as the project root.\n\tOut, Err       *log.Logger   // Required loggers.\n\tVerbose        bool          // Enables more verbose logging.\n\tDisableLocking bool          // When set, no lock file will be created to protect against simultaneous dep processes.\n\tCachedir       string        // Cache directory loaded from environment.\n\tCacheAge       time.Duration // Maximum valid age of cached source data. <=0: Don't cache.\n}\n\n// SetPaths sets the WorkingDir and GOPATHs fields. If GOPATHs is empty, then\n// the GOPATH environment variable (or the default GOPATH) is used instead.\nfunc (c *Ctx) SetPaths(wd string, GOPATHs ...string) error {\n\tif wd == \"\" {\n\t\treturn errors.New(\"cannot set Ctx.WorkingDir to an empty path\")\n\t}\n\tc.WorkingDir = wd\n\n\tif len(GOPATHs) == 0 {\n\t\tGOPATH := os.Getenv(\"GOPATH\")\n\t\tif GOPATH == \"\" {\n\t\t\tGOPATH = defaultGOPATH()\n\t\t}\n\t\tGOPATHs = filepath.SplitList(GOPATH)\n\t}\n\n\tc.GOPATHs = append(c.GOPATHs, GOPATHs...)\n\n\tc.ExplicitRoot = os.Getenv(\"DEPPROJECTROOT\")\n\n\treturn nil\n}\n\n// defaultGOPATH gets the default GOPATH that was added in 1.8\n// copied from go/build/build.go\nfunc defaultGOPATH() string {\n\tenv := \"HOME\"\n\tif runtime.GOOS == \"windows\" {\n\t\tenv = \"USERPROFILE\"\n\t} else if runtime.GOOS == \"plan9\" {\n\t\tenv = \"home\"\n\t}\n\tif home := os.Getenv(env); home != \"\" {\n\t\tdef := filepath.Join(home, \"go\")\n\t\tif def == runtime.GOROOT() {\n\t\t\t// Don't set the default GOPATH to GOROOT,\n\t\t\t// as that will trigger warnings from the go tool.\n\t\t\treturn \"\"\n\t\t}\n\t\treturn def\n\t}\n\treturn \"\"\n}\n\n// SourceManager produces an instance of gps's built-in SourceManager\n// initialized to log to the receiver's logger.\nfunc (c *Ctx) SourceManager() (*gps.SourceMgr, error) {\n\tcachedir := c.Cachedir\n\tif cachedir == \"\" {\n\t\t// When `DEPCACHEDIR` isn't set in the env, use the default - `$GOPATH/pkg/dep`.\n\t\tcachedir = filepath.Join(c.GOPATH, \"pkg\", \"dep\")\n\t\t// Create the default cachedir if it does not exist.\n\t\tif err := os.MkdirAll(cachedir, 0777); err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"failed to create default cache directory\")\n\t\t}\n\t}\n\n\treturn gps.NewSourceManager(gps.SourceManagerConfig{\n\t\tCacheAge:       c.CacheAge,\n\t\tCachedir:       cachedir,\n\t\tLogger:         c.Out,\n\t\tDisableLocking: c.DisableLocking,\n\t})\n}\n\n// LoadProject starts from the current working directory and searches up the\n// directory tree for a project root.  The search stops when a file with the name\n// ManifestName (Gopkg.toml, by default) is located.\n//\n// The Project contains the parsed manifest as well as a parsed lock file, if\n// present.  The import path is calculated as the remaining path segment\n// below Ctx.GOPATH/src.\nfunc (c *Ctx) LoadProject() (*Project, error) {\n\troot, err := findProjectRoot(c.WorkingDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = checkGopkgFilenames(root)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tp := new(Project)\n\n\tif err = p.SetRoot(root); err != nil {\n\t\treturn nil, err\n\t}\n\n\tc.GOPATH, err = c.DetectProjectGOPATH(p)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.ExplicitRoot != \"\" {\n\t\tp.ImportRoot = gps.ProjectRoot(c.ExplicitRoot)\n\t} else {\n\t\tip, err := c.ImportForAbs(p.AbsRoot)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrap(err, \"root project import\")\n\t\t}\n\t\tp.ImportRoot = gps.ProjectRoot(ip)\n\t}\n\n\tmp := filepath.Join(p.AbsRoot, ManifestName)\n\tmf, err := os.Open(mp)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\t// TODO: list possible solutions? (dep init, cd $project)\n\t\t\treturn nil, errors.Errorf(\"no %v found in project root %v\", ManifestName, p.AbsRoot)\n\t\t}\n\t\t// Unable to read the manifest file\n\t\treturn nil, err\n\t}\n\tdefer mf.Close()\n\n\tvar warns []error\n\tp.Manifest, warns, err = readManifest(mf)\n\tfor _, warn := range warns {\n\t\tc.Err.Printf(\"dep: WARNING: %v\\n\", warn)\n\t}\n\tif err != nil {\n\t\treturn nil, errors.Wrapf(err, \"error while parsing %s\", mp)\n\t}\n\n\t// Parse in the root package tree.\n\tptree, err := p.parseRootPackageTree()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlp := filepath.Join(p.AbsRoot, LockName)\n\tlf, err := os.Open(lp)\n\tif err == nil {\n\t\tdefer lf.Close()\n\n\t\tp.Lock, err = readLock(lf)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Wrapf(err, \"error while parsing %s\", lp)\n\t\t}\n\n\t\t// If there's a current Lock, apply the input and pruneopt changes that we\n\t\t// can know without solving.\n\t\tif p.Lock != nil {\n\t\t\tp.ChangedLock = p.Lock.dup()\n\t\t\tp.ChangedLock.SolveMeta.InputImports = externalImportList(ptree, p.Manifest)\n\n\t\t\tfor k, lp := range p.ChangedLock.Projects() {\n\t\t\t\tvp := lp.(verify.VerifiableProject)\n\t\t\t\tvp.PruneOpts = p.Manifest.PruneOptions.PruneOptionsFor(lp.Ident().ProjectRoot)\n\t\t\t\tp.ChangedLock.P[k] = vp\n\t\t\t}\n\t\t}\n\n\t} else if !os.IsNotExist(err) {\n\t\t// It's fine for the lock not to exist, but if a file does exist and we\n\t\t// can't open it, that's a problem.\n\t\treturn nil, errors.Wrapf(err, \"could not open %s\", lp)\n\t}\n\n\treturn p, nil\n}\n\nfunc externalImportList(rpt pkgtree.PackageTree, m gps.RootManifest) []string {\n\trm, _ := rpt.ToReachMap(true, true, false, m.IgnoredPackages())\n\treach := rm.FlattenFn(paths.IsStandardImportPath)\n\treq := m.RequiredPackages()\n\n\t// If there are any requires, slide them into the reach list, as well.\n\tif len(req) > 0 {\n\t\t// Make a map of imports that are both in the import path list and the\n\t\t// required list to avoid duplication.\n\t\tskip := make(map[string]bool, len(req))\n\t\tfor _, r := range reach {\n\t\t\tif req[r] {\n\t\t\t\tskip[r] = true\n\t\t\t}\n\t\t}\n\n\t\tfor r := range req {\n\t\t\tif !skip[r] {\n\t\t\t\treach = append(reach, r)\n\t\t\t}\n\t\t}\n\t}\n\n\tsort.Strings(reach)\n\treturn reach\n}\n\n// DetectProjectGOPATH attempt to find the GOPATH containing the project.\n//\n//  If p.AbsRoot is not a symlink and is within a GOPATH, the GOPATH containing p.AbsRoot is returned.\n//  If p.AbsRoot is a symlink and is not within any known GOPATH, the GOPATH containing p.ResolvedAbsRoot is returned.\n//\n// p.AbsRoot is assumed to be a symlink if it is not the same as p.ResolvedAbsRoot.\n//\n// DetectProjectGOPATH will return an error in the following cases:\n//\n//  If p.AbsRoot is not a symlink and is not within any known GOPATH.\n//  If neither p.AbsRoot nor p.ResolvedAbsRoot are within a known GOPATH.\n//  If both p.AbsRoot and p.ResolvedAbsRoot are within the same GOPATH.\n//  If p.AbsRoot and p.ResolvedAbsRoot are each within a different GOPATH.\nfunc (c *Ctx) DetectProjectGOPATH(p *Project) (string, error) {\n\tif p.AbsRoot == \"\" || p.ResolvedAbsRoot == \"\" {\n\t\treturn \"\", errors.New(\"project AbsRoot and ResolvedAbsRoot must be set to detect GOPATH\")\n\t}\n\n\tif c.ExplicitRoot != \"\" {\n\t\t// If an explicit root is set, just use the first GOPATH in the list.\n\t\treturn c.GOPATHs[0], nil\n\t}\n\n\tpGOPATH, perr := c.detectGOPATH(p.AbsRoot)\n\n\t// If p.AbsRoot is a not a symlink, attempt to detect GOPATH for p.AbsRoot only.\n\tif equal, _ := fs.EquivalentPaths(p.AbsRoot, p.ResolvedAbsRoot); equal {\n\t\treturn pGOPATH, perr\n\t}\n\n\trGOPATH, rerr := c.detectGOPATH(p.ResolvedAbsRoot)\n\n\t// If detectGOPATH() failed for both p.AbsRoot and p.ResolvedAbsRoot, then both are not within any known GOPATHs.\n\tif perr != nil && rerr != nil {\n\t\treturn \"\", errors.Errorf(\"both %s and %s are not within any known GOPATH\", p.AbsRoot, p.ResolvedAbsRoot)\n\t}\n\n\t// If pGOPATH equals rGOPATH, then both are within the same GOPATH.\n\tif equal, _ := fs.EquivalentPaths(pGOPATH, rGOPATH); equal {\n\t\treturn \"\", errors.Errorf(\"both %s and %s are in the same GOPATH %s\", p.AbsRoot, p.ResolvedAbsRoot, pGOPATH)\n\t}\n\n\tif pGOPATH != \"\" && rGOPATH != \"\" {\n\t\treturn \"\", errors.Errorf(\"%s and %s are both in different GOPATHs\", p.AbsRoot, p.ResolvedAbsRoot)\n\t}\n\n\t// Otherwise, either the p.AbsRoot or p.ResolvedAbsRoot is within a GOPATH.\n\tif pGOPATH == \"\" {\n\t\treturn rGOPATH, nil\n\t}\n\n\treturn pGOPATH, nil\n}\n\n// detectGOPATH detects the GOPATH for a given path from ctx.GOPATHs.\nfunc (c *Ctx) detectGOPATH(path string) (string, error) {\n\tfor _, gp := range c.GOPATHs {\n\t\tisPrefix, err := fs.HasFilepathPrefix(path, gp)\n\t\tif err != nil {\n\t\t\treturn \"\", errors.Wrap(err, \"failed to detect GOPATH\")\n\t\t}\n\t\tif isPrefix {\n\t\t\treturn filepath.Clean(gp), nil\n\t\t}\n\t}\n\treturn \"\", errors.Errorf(\"%s is not within a known GOPATH/src\", path)\n}\n\n// ImportForAbs returns the import path for an absolute project path by trimming the\n// `$GOPATH/src/` prefix.  Returns an error for paths equal to, or without this prefix.\nfunc (c *Ctx) ImportForAbs(path string) (string, error) {\n\tsrcprefix := filepath.Join(c.GOPATH, \"src\") + string(filepath.Separator)\n\tisPrefix, err := fs.HasFilepathPrefix(path, srcprefix)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"failed to find import path\")\n\t}\n\tif isPrefix {\n\t\tif len(path) <= len(srcprefix) {\n\t\t\treturn \"\", errors.New(\"dep does not currently support using GOPATH/src as the project root\")\n\t\t}\n\n\t\t// filepath.ToSlash because we're dealing with an import path now,\n\t\t// not an fs path\n\t\treturn filepath.ToSlash(path[len(srcprefix):]), nil\n\t}\n\n\treturn \"\", errors.Errorf(\"%s is not within any GOPATH/src\", path)\n}\n\n// AbsForImport returns the absolute path for the project root\n// including the $GOPATH. This will not work with stdlib packages and the\n// package directory needs to exist.\nfunc (c *Ctx) AbsForImport(path string) (string, error) {\n\tposspath := filepath.Join(c.GOPATH, \"src\", path)\n\tdirOK, err := fs.IsDir(posspath)\n\tif err != nil {\n\t\treturn \"\", errors.Wrapf(err, \"checking if %s is a directory\", posspath)\n\t}\n\tif !dirOK {\n\t\treturn \"\", errors.Errorf(\"%s does not exist\", posspath)\n\t}\n\treturn posspath, nil\n}\n\n// ValidateParams ensure that solving can be completed with the specified params.\nfunc (c *Ctx) ValidateParams(sm gps.SourceManager, params gps.SolveParameters) error {\n\terr := gps.ValidateParams(params, sm)\n\tif err != nil {\n\t\tif deduceErrs, ok := err.(gps.DeductionErrs); ok {\n\t\t\tc.Err.Println(\"The following errors occurred while deducing packages:\")\n\t\t\tfor ip, dErr := range deduceErrs {\n\t\t\t\tc.Err.Printf(\"  * \\\"%s\\\": %s\", ip, dErr)\n\t\t\t}\n\t\t\tc.Err.Println()\n\t\t}\n\t}\n\n\treturn errors.Wrap(err, \"validateParams\")\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 15.9892578125,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/golang/dep/internal/test\"\n)\n\nfunc discardLogger() *log.Logger {\n\treturn log.New(ioutil.Discard, \"\", 0)\n}\n\nfunc TestCtx_ProjectImport(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"src\")\n\n\th.Setenv(\"GOPATH\", h.Path(\".\"))\n\tdepCtx := &Ctx{GOPATH: h.Path(\".\")}\n\n\timportPaths := []string{\n\t\t\"github.com/pkg/errors\",\n\t\t\"my/silly/thing\",\n\t}\n\n\tfor _, want := range importPaths {\n\t\tfullpath := filepath.Join(depCtx.GOPATH, \"src\", want)\n\t\th.TempDir(filepath.Join(\"src\", want))\n\t\tgot, err := depCtx.ImportForAbs(fullpath)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif got != want {\n\t\t\tt.Fatalf(\"expected %s, got %s\", want, got)\n\t\t}\n\t}\n\n\t// test where it should return an error when directly within $GOPATH/src\n\tgot, err := depCtx.ImportForAbs(filepath.Join(depCtx.GOPATH, \"src\"))\n\tif err == nil || !strings.Contains(err.Error(), \"GOPATH/src\") {\n\t\tt.Fatalf(\"should have gotten an error for use directly in GOPATH/src, but got %s\", got)\n\t}\n\n\t// test where it should return an error\n\tgot, err = depCtx.ImportForAbs(\"tra/la/la/la\")\n\tif err == nil {\n\t\tt.Fatalf(\"should have gotten an error but did not for tra/la/la/la: %s\", got)\n\t}\n}\n\nfunc TestAbsoluteProjectRoot(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"src\")\n\th.Setenv(\"GOPATH\", h.Path(\".\"))\n\tdepCtx := &Ctx{GOPATH: h.Path(\".\")}\n\n\timportPaths := map[string]bool{\n\t\t\"github.com/pkg/errors\": true,\n\t\t\"my/silly/thing\":        false,\n\t}\n\n\tfor i, create := range importPaths {\n\t\tif create {\n\t\t\th.TempDir(filepath.Join(\"src\", i))\n\t\t}\n\t}\n\n\tfor i, ok := range importPaths {\n\t\tgot, err := depCtx.AbsForImport(i)\n\t\tif ok {\n\t\t\th.Must(err)\n\t\t\twant := h.Path(filepath.Join(\"src\", i))\n\t\t\tif got != want {\n\t\t\t\tt.Fatalf(\"expected %s, got %q\", want, got)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expected %s to fail\", i)\n\t\t}\n\t}\n\n\t// test that a file fails\n\th.TempFile(\"src/thing/thing.go\", \"hello world\")\n\t_, err := depCtx.AbsForImport(\"thing/thing.go\")\n\tif err == nil {\n\t\tt.Fatal(\"error should not be nil for a file found\")\n\t}\n}\n\nfunc TestLoadProject(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(filepath.Join(\"src\", \"test1\", \"sub\"))\n\th.TempFile(filepath.Join(\"src\", \"test1\", ManifestName), \"\")\n\th.TempFile(filepath.Join(\"src\", \"test1\", LockName), `memo = \"cdafe8641b28cd16fe025df278b0a49b9416859345d8b6ba0ace0272b74925ee\"`)\n\th.TempDir(filepath.Join(\"src\", \"test2\", \"sub\"))\n\th.TempFile(filepath.Join(\"src\", \"test2\", ManifestName), \"\")\n\n\tvar testcases = []struct {\n\t\tname string\n\t\tlock bool\n\t\twd   string\n\t}{\n\t\t{\"direct\", true, filepath.Join(\"src\", \"test1\")},\n\t\t{\"ascending\", true, filepath.Join(\"src\", \"test1\", \"sub\")},\n\t\t{\"without lock\", false, filepath.Join(\"src\", \"test2\")},\n\t\t{\"ascending without lock\", false, filepath.Join(\"src\", \"test2\", \"sub\")},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tctx := &Ctx{\n\t\t\t\tOut: discardLogger(),\n\t\t\t\tErr: discardLogger(),\n\t\t\t}\n\n\t\t\terr := ctx.SetPaths(h.Path(tc.wd), h.Path(\".\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%+v\", err)\n\t\t\t}\n\n\t\t\tp, err := ctx.LoadProject()\n\t\t\tswitch {\n\t\t\tcase err != nil:\n\t\t\t\tt.Fatalf(\"%s: LoadProject failed: %+v\", tc.wd, err)\n\t\t\tcase p.Manifest == nil:\n\t\t\t\tt.Fatalf(\"%s: Manifest file didn't load\", tc.wd)\n\t\t\tcase tc.lock && p.Lock == nil:\n\t\t\t\tt.Fatalf(\"%s: Lock file didn't load\", tc.wd)\n\t\t\tcase !tc.lock && p.Lock != nil:\n\t\t\t\tt.Fatalf(\"%s: Non-existent Lock file loaded\", tc.wd)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExplicitRootProject(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(filepath.Join(\"src\", \"test1\", \"sub\"))\n\th.TempFile(filepath.Join(\"src\", \"test1\", ManifestName), \"\")\n\th.TempFile(filepath.Join(\"src\", \"test1\", LockName), `memo = \"cdafe8641b28cd16fe025df278b0a49b9416859345d8b6ba0ace0272b74925ee\"`)\n\th.TempDir(filepath.Join(\"src\", \"test2\", \"sub\"))\n\th.TempFile(filepath.Join(\"src\", \"test2\", ManifestName), \"\")\n\th.Setenv(\"DEP_PROJECT_ROOT\", \"github.com/user/module\")\n\n\ttype tcase struct {\n\t\tname string\n\t\tlock bool\n\t\twd   string\n\t}\n\tvar testcases = []tcase{\n\t\t{\"direct\", true, filepath.Join(\"src\", \"test1\")},\n\t\t{\"ascending\", true, filepath.Join(\"src\", \"test1\", \"sub\")},\n\t\t{\"without lock\", false, filepath.Join(\"src\", \"test2\")},\n\t\t{\"ascending without lock\", false, filepath.Join(\"src\", \"test2\", \"sub\")},\n\t}\n\n\ttf := func(withGOPATH bool, tc tcase, t *testing.T) func(t *testing.T) {\n\t\treturn func(t *testing.T) {\n\t\t\tctx := &Ctx{\n\t\t\t\tOut: discardLogger(),\n\t\t\t\tErr: discardLogger(),\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tif withGOPATH {\n\t\t\t\terr = ctx.SetPaths(h.Path(tc.wd), h.Path(\".\"))\n\t\t\t} else {\n\t\t\t\terr = ctx.SetPaths(h.Path(tc.wd))\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"%+v\", err)\n\t\t\t}\n\t\t\tctx.ExplicitRoot = \"github.com/user/module\"\n\n\t\t\tp, err := ctx.LoadProject()\n\t\t\tswitch {\n\t\t\tcase err != nil:\n\t\t\t\tt.Fatalf(\"%s: LoadProject failed: %+v\", tc.wd, err)\n\t\t\tcase p.Manifest == nil:\n\t\t\t\tt.Fatalf(\"%s: Manifest file didn't load\", tc.wd)\n\t\t\tcase tc.lock && p.Lock == nil:\n\t\t\t\tt.Fatalf(\"%s: Lock file didn't load\", tc.wd)\n\t\t\tcase !tc.lock && p.Lock != nil:\n\t\t\t\tt.Fatalf(\"%s: Non-existent Lock file loaded\", tc.wd)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, tc := range testcases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tt.Run(\"within-GOPATH\", tf(true, tc, t))\n\t\t\tt.Run(\"outside-GOPATH\", tf(false, tc, t))\n\t\t})\n\t}\n}\n\nfunc TestLoadProjectNotFoundErrors(t *testing.T) {\n\ttg := test.NewHelper(t)\n\tdefer tg.Cleanup()\n\n\ttg.TempDir(\"src\")\n\ttg.TempDir(\"src/test1\")\n\ttg.TempDir(\"src/test1/sub\")\n\ttg.Setenv(\"GOPATH\", tg.Path(\".\"))\n\n\tvar testcases = []struct {\n\t\tlock  bool\n\t\tstart string\n\t\tpath  string\n\t}{\n\t\t{true, filepath.Join(\"src\", \"test1\"), \"\"},        //direct\n\t\t{true, filepath.Join(\"src\", \"test1\", \"sub\"), \"\"}, //ascending\n\t}\n\n\tfor _, testcase := range testcases {\n\t\tctx := &Ctx{GOPATHs: []string{tg.Path(\".\")}, WorkingDir: tg.Path(testcase.start)}\n\n\t\t_, err := ctx.LoadProject()\n\t\tif err == nil {\n\t\t\tt.Errorf(\"%s: should have returned 'No Manifest Found' error\", testcase.start)\n\t\t}\n\t}\n}\n\nfunc TestLoadProjectManifestParseError(t *testing.T) {\n\ttg := test.NewHelper(t)\n\tdefer tg.Cleanup()\n\n\ttg.TempDir(\"src\")\n\ttg.TempDir(\"src/test1\")\n\ttg.TempFile(filepath.Join(\"src/test1\", ManifestName), `[[constraint]]`)\n\ttg.TempFile(filepath.Join(\"src/test1\", LockName), `memo = \"cdafe8641b28cd16fe025df278b0a49b9416859345d8b6ba0ace0272b74925ee\"\\n\\n[[projects]]`)\n\ttg.Setenv(\"GOPATH\", tg.Path(\".\"))\n\n\tpath := filepath.Join(\"src\", \"test1\")\n\ttg.Cd(tg.Path(path))\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(\"failed to get working directory\", err)\n\t}\n\n\tctx := &Ctx{\n\t\tGOPATH:     tg.Path(\".\"),\n\t\tWorkingDir: wd,\n\t\tOut:        discardLogger(),\n\t\tErr:        discardLogger(),\n\t}\n\n\t_, err = ctx.LoadProject()\n\tif err == nil {\n\t\tt.Fatal(\"should have returned 'Manifest Syntax' error\")\n\t}\n}\n\nfunc TestLoadProjectLockParseError(t *testing.T) {\n\ttg := test.NewHelper(t)\n\tdefer tg.Cleanup()\n\n\ttg.TempDir(\"src\")\n\ttg.TempDir(\"src/test1\")\n\ttg.TempFile(filepath.Join(\"src/test1\", ManifestName), `[[constraint]]`)\n\ttg.TempFile(filepath.Join(\"src/test1\", LockName), `memo = \"cdafe8641b28cd16fe025df278b0a49b9416859345d8b6ba0ace0272b74925ee\"\\n\\n[[projects]]`)\n\ttg.Setenv(\"GOPATH\", tg.Path(\".\"))\n\n\tpath := filepath.Join(\"src\", \"test1\")\n\ttg.Cd(tg.Path(path))\n\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(\"failed to get working directory\", err)\n\t}\n\n\tctx := &Ctx{\n\t\tGOPATH:     tg.Path(\".\"),\n\t\tWorkingDir: wd,\n\t\tOut:        discardLogger(),\n\t\tErr:        discardLogger(),\n\t}\n\n\t_, err = ctx.LoadProject()\n\tif err == nil {\n\t\tt.Fatal(\"should have returned 'Lock Syntax' error\")\n\t}\n}\n\nfunc TestLoadProjectNoSrcDir(t *testing.T) {\n\ttg := test.NewHelper(t)\n\tdefer tg.Cleanup()\n\n\ttg.TempDir(\"test1\")\n\ttg.TempFile(filepath.Join(\"test1\", ManifestName), `[[constraint]]`)\n\ttg.TempFile(filepath.Join(\"test1\", LockName), `memo = \"cdafe8641b28cd16fe025df278b0a49b9416859345d8b6ba0ace0272b74925ee\"\\n\\n[[projects]]`)\n\ttg.Setenv(\"GOPATH\", tg.Path(\".\"))\n\n\tctx := &Ctx{GOPATH: tg.Path(\".\")}\n\tpath := filepath.Join(\"test1\")\n\ttg.Cd(tg.Path(path))\n\n\tf, _ := os.OpenFile(filepath.Join(ctx.GOPATH, \"src\", \"test1\", LockName), os.O_WRONLY, os.ModePerm)\n\tdefer f.Close()\n\n\t_, err := ctx.LoadProject()\n\tif err == nil {\n\t\tt.Fatal(\"should have returned 'Split Absolute Root' error (no 'src' dir present)\")\n\t}\n}\n\nfunc TestLoadProjectGopkgFilenames(t *testing.T) {\n\t// We are trying to skip this test on file systems which are case-sensiive. We could\n\t// have used `fs.IsCaseSensitiveFilesystem` for this check. However, the code we are\n\t// testing also relies on `fs.IsCaseSensitiveFilesystem`. So a bug in\n\t// `fs.IsCaseSensitiveFilesystem` could prevent this test from being run. This is the\n\t// only scenario where we prefer the OS heuristic over doing the actual work of\n\t// validating filesystem case sensitivity via `fs.IsCaseSensitiveFilesystem`.\n\tif runtime.GOOS != \"windows\" && runtime.GOOS != \"darwin\" {\n\t\tt.Skip(\"skip this test on non-Windows, non-macOS\")\n\t}\n\n\t// Here we test that a manifest filename with incorrect case throws an error. Similar\n\t// error will also be thrown for the lock file as well which has been tested in\n\t// `project_test.go#TestCheckGopkgFilenames`. So not repeating here.\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tinvalidMfName := strings.ToLower(ManifestName)\n\n\twd := filepath.Join(\"src\", \"test\")\n\th.TempFile(filepath.Join(wd, invalidMfName), \"\")\n\n\tctx := &Ctx{\n\t\tOut: discardLogger(),\n\t\tErr: discardLogger(),\n\t}\n\n\terr := ctx.SetPaths(h.Path(wd), h.Path(\".\"))\n\tif err != nil {\n\t\tt.Fatalf(\"%+v\", err)\n\t}\n\n\t_, err = ctx.LoadProject()\n\n\tif err == nil {\n\t\tt.Fatal(\"should have returned 'Manifest Filename' error\")\n\t}\n\n\texpectedErrMsg := fmt.Sprintf(\n\t\t\"manifest filename %q does not match %q\",\n\t\tinvalidMfName, ManifestName,\n\t)\n\n\tif err.Error() != expectedErrMsg {\n\t\tt.Fatalf(\"unexpected error: %+v\", err)\n\t}\n}\n\n// TestCaseInsensitive is test for Windows. This should work even though set\n// difference letter cases in GOPATH.\nfunc TestCaseInsensitiveGOPATH(t *testing.T) {\n\tif runtime.GOOS != \"windows\" {\n\t\tt.Skip(\"skip this test on non-Windows\")\n\t}\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"src\")\n\th.TempDir(\"src/test1\")\n\th.TempFile(filepath.Join(\"src/test1\", ManifestName), `\n\t[[constraint]]\n\t\tname = \"github.com/foo/bar\"\n\t\tbranch = \"master\"`)\n\n\t// Shuffle letter case\n\trs := []rune(strings.ToLower(h.Path(\".\")))\n\tfor i, r := range rs {\n\t\tif unicode.IsLower(r) {\n\t\t\trs[i] = unicode.ToUpper(r)\n\t\t} else {\n\t\t\trs[i] = unicode.ToLower(r)\n\t\t}\n\t}\n\tgopath := string(rs)\n\th.Setenv(\"GOPATH\", gopath)\n\twd := h.Path(\"src/test1\")\n\n\tdepCtx := &Ctx{}\n\tif err := depCtx.SetPaths(wd, gopath); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := depCtx.LoadProject(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tip := \"github.com/pkg/errors\"\n\tfullpath := filepath.Join(depCtx.GOPATH, \"src\", ip)\n\th.TempDir(filepath.Join(\"src\", ip))\n\tpr, err := depCtx.ImportForAbs(fullpath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif pr != ip {\n\t\tt.Fatalf(\"expected %s, got %s\", ip, pr)\n\t}\n}\n\nfunc TestDetectProjectGOPATH(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(filepath.Join(\"sym\", \"symlink\"))\n\th.TempDir(filepath.Join(\"go\", \"src\", \"sym\", \"path\"))\n\th.TempDir(filepath.Join(\"go\", \"src\", \"real\", \"path\"))\n\th.TempDir(filepath.Join(\"go-two\", \"src\", \"real\", \"path\"))\n\th.TempDir(filepath.Join(\"go-two\", \"src\", \"sym\"))\n\n\tctx := &Ctx{\n\t\tGOPATHs: []string{h.Path(\"go\"), h.Path(\"go-two\")},\n\t}\n\n\ttestcases := []struct {\n\t\tname         string\n\t\troot         string\n\t\tresolvedRoot string\n\t\tGOPATH       string\n\t\texpectErr    bool\n\t}{\n\t\t{\n\t\t\tname:         \"project-with-no-AbsRoot\",\n\t\t\troot:         \"\",\n\t\t\tresolvedRoot: filepath.Join(ctx.GOPATHs[0], \"src\", \"real\", \"path\"),\n\t\t\texpectErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"project-with-no-ResolvedAbsRoot\",\n\t\t\troot:         filepath.Join(ctx.GOPATHs[0], \"src\", \"real\", \"path\"),\n\t\t\tresolvedRoot: \"\",\n\t\t\texpectErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"AbsRoot-is-not-within-any-GOPATH\",\n\t\t\troot:         filepath.Join(h.Path(\".\"), \"src\", \"real\", \"path\"),\n\t\t\tresolvedRoot: filepath.Join(h.Path(\".\"), \"src\", \"real\", \"path\"),\n\t\t\texpectErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"neither-AbsRoot-nor-ResolvedAbsRoot-are-in-any-GOPATH\",\n\t\t\troot:         filepath.Join(h.Path(\".\"), \"src\", \"sym\", \"path\"),\n\t\t\tresolvedRoot: filepath.Join(h.Path(\".\"), \"src\", \"real\", \"path\"),\n\t\t\texpectErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"both-AbsRoot-and-ResolvedAbsRoot-are-in-the-same-GOPATH\",\n\t\t\troot:         filepath.Join(ctx.GOPATHs[0], \"src\", \"sym\", \"path\"),\n\t\t\tresolvedRoot: filepath.Join(ctx.GOPATHs[0], \"src\", \"real\", \"path\"),\n\t\t\texpectErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"AbsRoot-and-ResolvedAbsRoot-are-each-within-a-different-GOPATH\",\n\t\t\troot:         filepath.Join(ctx.GOPATHs[0], \"src\", \"sym\", \"path\"),\n\t\t\tresolvedRoot: filepath.Join(ctx.GOPATHs[1], \"src\", \"real\", \"path\"),\n\t\t\texpectErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:         \"AbsRoot-is-not-a-symlink\",\n\t\t\troot:         filepath.Join(ctx.GOPATHs[0], \"src\", \"real\", \"path\"),\n\t\t\tresolvedRoot: filepath.Join(ctx.GOPATHs[0], \"src\", \"real\", \"path\"),\n\t\t\tGOPATH:       ctx.GOPATHs[0],\n\t\t},\n\t\t{\n\t\t\tname:         \"AbsRoot-is-a-symlink-to-ResolvedAbsRoot\",\n\t\t\troot:         filepath.Join(h.Path(\".\"), \"sym\", \"symlink\"),\n\t\t\tresolvedRoot: filepath.Join(ctx.GOPATHs[0], \"src\", \"real\", \"path\"),\n\t\t\tGOPATH:       ctx.GOPATHs[0],\n\t\t},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tproject := &Project{\n\t\t\t\tAbsRoot:         tc.root,\n\t\t\t\tResolvedAbsRoot: tc.resolvedRoot,\n\t\t\t}\n\n\t\t\tGOPATH, err := ctx.DetectProjectGOPATH(project)\n\t\t\tif !tc.expectErr && err != nil {\n\t\t\t\tt.Fatalf(\"%+v\", err)\n\t\t\t} else if tc.expectErr && err == nil {\n\t\t\t\tt.Fatalf(\"expected an error, got nil and gopath %s\", GOPATH)\n\t\t\t}\n\t\t\tif GOPATH != tc.GOPATH {\n\t\t\t\tt.Errorf(\"expected GOPATH %s, got %s\", tc.GOPATH, GOPATH)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDetectGOPATH(t *testing.T) {\n\tth := test.NewHelper(t)\n\tdefer th.Cleanup()\n\n\tth.TempDir(filepath.Join(\"code\", \"src\", \"github.com\", \"username\", \"package\"))\n\tth.TempDir(filepath.Join(\"go\", \"src\", \"github.com\", \"username\", \"package\"))\n\tth.TempDir(filepath.Join(\"gotwo\", \"src\", \"github.com\", \"username\", \"package\"))\n\tth.TempDir(filepath.Join(\"gothree\", \"sep\", \"src\", \"github.com\", \"username\", \"package\"))\n\n\tsep := string(os.PathSeparator)\n\n\tctx := &Ctx{GOPATHs: []string{\n\t\tth.Path(\"go\"),\n\t\tth.Path(\"gotwo\"),\n\t\tth.Path(\"gothree\") + sep + sep + \"sep\",\n\t}}\n\n\ttestcases := []struct {\n\t\tGOPATH string\n\t\tpath   string\n\t\terr    bool\n\t}{\n\t\t{th.Path(\"go\"), th.Path(filepath.Join(\"go\", \"src\", \"github.com\", \"username\", \"package\")), false},\n\t\t{th.Path(\"go\"), th.Path(filepath.Join(\"go\", \"src\", \"github.com\", \"username\", \"package\")), false},\n\t\t{th.Path(\"gotwo\"), th.Path(filepath.Join(\"gotwo\", \"src\", \"github.com\", \"username\", \"package\")), false},\n\t\t{th.Path(filepath.Join(\"gothree\", \"sep\")),\n\t\t\tth.Path(filepath.Join(\"gothree\", \"sep\", \"src\", \"github.com\", \"username\", \"package\")), false},\n\t\t{\"\", th.Path(filepath.Join(\"code\", \"src\", \"github.com\", \"username\", \"package\")), true},\n\t}\n\n\tfor _, tc := range testcases {\n\t\tGOPATH, err := ctx.detectGOPATH(tc.path)\n\t\tif tc.err && err == nil {\n\t\t\tt.Error(\"expected error but got none\")\n\t\t}\n\t\tif GOPATH != tc.GOPATH {\n\t\t\tt.Errorf(\"expected GOPATH to be %s, got %s\", tc.GOPATH, GOPATH)\n\t\t}\n\t}\n}\n\nfunc TestDepCachedir(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"cache\")\n\t// Create the directory for default cachedir location.\n\th.TempDir(filepath.Join(\"go\", \"pkg\", \"dep\"))\n\n\ttestCachedir := h.Path(\"cache\")\n\tgopath := h.Path(\"go\")\n\tdiscardLgr := discardLogger()\n\n\tcases := []struct {\n\t\tcachedir     string\n\t\twantCachedir string\n\t}{\n\t\t// If `Cachedir` is not set in the context, it should use `$GOPATH/pkg/dep`.\n\t\t{cachedir: \"\", wantCachedir: h.Path(filepath.Join(\"go\", \"pkg\", \"dep\"))},\n\t\t// If `Cachedir` is set in the context, it should use that.\n\t\t{cachedir: testCachedir, wantCachedir: testCachedir},\n\t}\n\n\tfor _, c := range cases {\n\t\tctx := &Ctx{\n\t\t\tGOPATH:   gopath,\n\t\t\tCachedir: c.cachedir,\n\t\t\tOut:      discardLgr,\n\t\t\tErr:      discardLgr,\n\t\t}\n\t\tsm, err := ctx.SourceManager()\n\t\th.Must(err)\n\t\tdefer sm.Release()\n\n\t\tif sm.Cachedir() != c.wantCachedir {\n\t\t\tt.Errorf(\"expected cachedir to be %s, got %s\", c.wantCachedir, sm.Cachedir())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.2275390625,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package dep is a prototype dependency management library.\npackage dep\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "gps",
          "type": "tree",
          "content": null
        },
        {
          "name": "hack",
          "type": "tree",
          "content": null
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 5.107421875,
          "content": "#!/bin/sh\n\n# This install script is intended to download and install the latest available\n# release of the dep dependency manager for Golang.\n#\n# It attempts to identify the current platform and an error will be thrown if\n# the platform is not supported.\n#\n# Environment variables:\n# - INSTALL_DIRECTORY (optional): defaults to $GOPATH/bin\n# - DEP_RELEASE_TAG (optional): defaults to fetching the latest release\n# - DEP_OS (optional): use a specific value for OS (mostly for testing)\n# - DEP_ARCH (optional): use a specific value for ARCH (mostly for testing)\n#\n# You can install using this script:\n# $ curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh\n\nset -e\n\nRELEASES_URL=\"https://github.com/golang/dep/releases\"\n\ndownloadJSON() {\n    url=\"$2\"\n\n    echo \"Fetching $url..\"\n    if test -x \"$(command -v curl)\"; then\n        response=$(curl -s -L -w 'HTTPSTATUS:%{http_code}' -H 'Accept: application/json' \"$url\")\n        body=$(echo \"$response\" | sed -e 's/HTTPSTATUS\\:.*//g')\n        code=$(echo \"$response\" | tr -d '\\n' | sed -e 's/.*HTTPSTATUS://')\n    elif test -x \"$(command -v wget)\"; then\n        temp=$(mktemp)\n        body=$(wget -q --header='Accept: application/json' -O - --server-response \"$url\" 2> \"$temp\")\n        code=$(awk '/^  HTTP/{print $2}' < \"$temp\" | tail -1)\n        rm \"$temp\"\n    else\n        echo \"Neither curl nor wget was available to perform http requests.\"\n        exit 1\n    fi\n    if [ \"$code\" != 200 ]; then\n        echo \"Request failed with code $code\"\n        exit 1\n    fi\n\n    eval \"$1='$body'\"\n}\n\ndownloadFile() {\n    url=\"$1\"\n    destination=\"$2\"\n\n    echo \"Fetching $url..\"\n    if test -x \"$(command -v curl)\"; then\n        code=$(curl -s -w '%{http_code}' -L \"$url\" -o \"$destination\")\n    elif test -x \"$(command -v wget)\"; then\n        code=$(wget -q -O \"$destination\" --server-response \"$url\" 2>&1 | awk '/^  HTTP/{print $2}' | tail -1)\n    else\n        echo \"Neither curl nor wget was available to perform http requests.\"\n        exit 1\n    fi\n\n    if [ \"$code\" != 200 ]; then\n        echo \"Request failed with code $code\"\n        exit 1\n    fi\n}\n\nfindGoBinDirectory() {\n    EFFECTIVE_GOPATH=$(go env GOPATH)\n    # CYGWIN: Convert Windows-style path into sh-compatible path\n    if [ \"$OS_CYGWIN\" = \"1\" ]; then\n\tEFFECTIVE_GOPATH=$(cygpath \"$EFFECTIVE_GOPATH\")\n    fi\n    if [ -z \"$EFFECTIVE_GOPATH\" ]; then\n        echo \"Installation could not determine your \\$GOPATH.\"\n        exit 1\n    fi\n    if [ -z \"$GOBIN\" ]; then\n        GOBIN=$(echo \"${EFFECTIVE_GOPATH%%:*}/bin\" | sed s#//*#/#g)\n    fi\n    if [ ! -d \"$GOBIN\" ]; then\n        echo \"Installation requires your GOBIN directory $GOBIN to exist. Please create it.\"\n        exit 1\n    fi\n    eval \"$1='$GOBIN'\"\n}\n\ninitArch() {\n    ARCH=$(uname -m)\n    if [ -n \"$DEP_ARCH\" ]; then\n        echo \"Using DEP_ARCH\"\n        ARCH=\"$DEP_ARCH\"\n    fi\n    case $ARCH in\n        amd64) ARCH=\"amd64\";;\n        x86_64) ARCH=\"amd64\";;\n        i386) ARCH=\"386\";;\n        ppc64) ARCH=\"ppc64\";;\n        ppc64le) ARCH=\"ppc64le\";;\n        s390x) ARCH=\"s390x\";;\n        armv6*) ARCH=\"arm\";;\n        armv7*) ARCH=\"arm\";;\n        aarch64) ARCH=\"arm64\";;\n        *) echo \"Architecture ${ARCH} is not supported by this installation script\"; exit 1;;\n    esac\n    echo \"ARCH = $ARCH\"\n}\n\ninitOS() {\n    OS=$(uname | tr '[:upper:]' '[:lower:]')\n    OS_CYGWIN=0\n    if [ -n \"$DEP_OS\" ]; then\n        echo \"Using DEP_OS\"\n        OS=\"$DEP_OS\"\n    fi\n    case \"$OS\" in\n        darwin) OS='darwin';;\n        linux) OS='linux';;\n        freebsd) OS='freebsd';;\n        mingw*) OS='windows';;\n        msys*) OS='windows';;\n\tcygwin*)\n\t    OS='windows'\n\t    OS_CYGWIN=1\n\t    ;;\n        *) echo \"OS ${OS} is not supported by this installation script\"; exit 1;;\n    esac\n    echo \"OS = $OS\"\n}\n\n# identify platform based on uname output\ninitArch\ninitOS\n\n# determine install directory if required\nif [ -z \"$INSTALL_DIRECTORY\" ]; then\n    findGoBinDirectory INSTALL_DIRECTORY\nfi\necho \"Will install into $INSTALL_DIRECTORY\"\n\n# assemble expected release artifact name\nif [ \"${OS}\" != \"linux\" ] && { [ \"${ARCH}\" = \"ppc64\" ] || [ \"${ARCH}\" = \"ppc64le\" ];}; then\n    # ppc64 and ppc64le are only supported on Linux.\n    echo \"${OS}-${ARCH} is not supported by this instalation script\"\nelse\n    BINARY=\"dep-${OS}-${ARCH}\"\nfi\n\n# add .exe if on windows\nif [ \"$OS\" = \"windows\" ]; then\n    BINARY=\"$BINARY.exe\"\nfi\n\n# if DEP_RELEASE_TAG was not provided, assume latest\nif [ -z \"$DEP_RELEASE_TAG\" ]; then\n    downloadJSON LATEST_RELEASE \"$RELEASES_URL/latest\"\n    DEP_RELEASE_TAG=$(echo \"${LATEST_RELEASE}\" | tr -s '\\n' ' ' | sed 's/.*\"tag_name\":\"//' | sed 's/\".*//' )\nfi\necho \"Release Tag = $DEP_RELEASE_TAG\"\n\n# fetch the real release data to make sure it exists before we attempt a download\ndownloadJSON RELEASE_DATA \"$RELEASES_URL/tag/$DEP_RELEASE_TAG\"\n\nBINARY_URL=\"$RELEASES_URL/download/$DEP_RELEASE_TAG/$BINARY\"\nDOWNLOAD_FILE=$(mktemp)\n\ndownloadFile \"$BINARY_URL\" \"$DOWNLOAD_FILE\"\n\necho \"Setting executable permissions.\"\nchmod +x \"$DOWNLOAD_FILE\"\n\nINSTALL_NAME=\"dep\"\n\nif [ \"$OS\" = \"windows\" ]; then\n    INSTALL_NAME=\"$INSTALL_NAME.exe\"\nfi\n\necho \"Moving executable to $INSTALL_DIRECTORY/$INSTALL_NAME\"\nmv \"$DOWNLOAD_FILE\" \"$INSTALL_DIRECTORY/$INSTALL_NAME\"\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "lock.go",
          "type": "blob",
          "size": 6.9658203125,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"sort\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/gps/verify\"\n\t\"github.com/pelletier/go-toml\"\n\t\"github.com/pkg/errors\"\n)\n\n// LockName is the lock file name used by dep.\nconst LockName = \"Gopkg.lock\"\n\n// Lock holds lock file data and implements gps.Lock.\ntype Lock struct {\n\tSolveMeta SolveMeta\n\tP         []gps.LockedProject\n}\n\n// SolveMeta holds metadata about the solving process that created the lock that\n// is not specific to any individual project.\ntype SolveMeta struct {\n\tAnalyzerName    string\n\tAnalyzerVersion int\n\tSolverName      string\n\tSolverVersion   int\n\tInputImports    []string\n}\n\ntype rawLock struct {\n\tSolveMeta solveMeta          `toml:\"solve-meta\"`\n\tProjects  []rawLockedProject `toml:\"projects\"`\n}\n\ntype solveMeta struct {\n\tAnalyzerName    string   `toml:\"analyzer-name\"`\n\tAnalyzerVersion int      `toml:\"analyzer-version\"`\n\tSolverName      string   `toml:\"solver-name\"`\n\tSolverVersion   int      `toml:\"solver-version\"`\n\tInputImports    []string `toml:\"input-imports\"`\n}\n\ntype rawLockedProject struct {\n\tName      string   `toml:\"name\"`\n\tBranch    string   `toml:\"branch,omitempty\"`\n\tRevision  string   `toml:\"revision\"`\n\tVersion   string   `toml:\"version,omitempty\"`\n\tSource    string   `toml:\"source,omitempty\"`\n\tPackages  []string `toml:\"packages\"`\n\tPruneOpts string   `toml:\"pruneopts\"`\n\tDigest    string   `toml:\"digest\"`\n}\n\nfunc readLock(r io.Reader) (*Lock, error) {\n\tbuf := &bytes.Buffer{}\n\t_, err := buf.ReadFrom(r)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Unable to read byte stream\")\n\t}\n\n\traw := rawLock{}\n\terr = toml.Unmarshal(buf.Bytes(), &raw)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"Unable to parse the lock as TOML\")\n\t}\n\n\treturn fromRawLock(raw)\n}\n\nfunc fromRawLock(raw rawLock) (*Lock, error) {\n\tl := &Lock{\n\t\tP: make([]gps.LockedProject, 0, len(raw.Projects)),\n\t}\n\n\tl.SolveMeta.AnalyzerName = raw.SolveMeta.AnalyzerName\n\tl.SolveMeta.AnalyzerVersion = raw.SolveMeta.AnalyzerVersion\n\tl.SolveMeta.SolverName = raw.SolveMeta.SolverName\n\tl.SolveMeta.SolverVersion = raw.SolveMeta.SolverVersion\n\tl.SolveMeta.InputImports = raw.SolveMeta.InputImports\n\n\tfor _, ld := range raw.Projects {\n\t\tr := gps.Revision(ld.Revision)\n\n\t\tvar v gps.Version = r\n\t\tif ld.Version != \"\" {\n\t\t\tif ld.Branch != \"\" {\n\t\t\t\treturn nil, errors.Errorf(\"lock file specified both a branch (%s) and version (%s) for %s\", ld.Branch, ld.Version, ld.Name)\n\t\t\t}\n\t\t\tv = gps.NewVersion(ld.Version).Pair(r)\n\t\t} else if ld.Branch != \"\" {\n\t\t\tv = gps.NewBranch(ld.Branch).Pair(r)\n\t\t} else if r == \"\" {\n\t\t\treturn nil, errors.Errorf(\"lock file has entry for %s, but specifies no branch or version\", ld.Name)\n\t\t}\n\n\t\tid := gps.ProjectIdentifier{\n\t\t\tProjectRoot: gps.ProjectRoot(ld.Name),\n\t\t\tSource:      ld.Source,\n\t\t}\n\n\t\tvar err error\n\t\tvp := verify.VerifiableProject{\n\t\t\tLockedProject: gps.NewLockedProject(id, v, ld.Packages),\n\t\t}\n\t\tif ld.Digest != \"\" {\n\t\t\tvp.Digest, err = verify.ParseVersionedDigest(ld.Digest)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tpo, err := gps.ParsePruneOptions(ld.PruneOpts)\n\t\tif err != nil {\n\t\t\treturn nil, errors.Errorf(\"%s in prune options for %s\", err.Error(), ld.Name)\n\t\t}\n\t\t// Add the vendor pruning bit so that gps doesn't get confused\n\t\tvp.PruneOpts = po | gps.PruneNestedVendorDirs\n\n\t\tl.P = append(l.P, vp)\n\t}\n\n\treturn l, nil\n}\n\n// Projects returns the list of LockedProjects contained in the lock data.\nfunc (l *Lock) Projects() []gps.LockedProject {\n\tif l == nil || l == (*Lock)(nil) {\n\t\treturn nil\n\t}\n\treturn l.P\n}\n\n// InputImports reports the list of input imports that were used in generating\n// this Lock.\nfunc (l *Lock) InputImports() []string {\n\tif l == nil || l == (*Lock)(nil) {\n\t\treturn nil\n\t}\n\treturn l.SolveMeta.InputImports\n}\n\n// HasProjectWithRoot checks if the lock contains a project with the provided\n// ProjectRoot.\n//\n// This check is O(n) in the number of projects.\nfunc (l *Lock) HasProjectWithRoot(root gps.ProjectRoot) bool {\n\tfor _, p := range l.P {\n\t\tif p.Ident().ProjectRoot == root {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (l *Lock) dup() *Lock {\n\tl2 := &Lock{\n\t\tSolveMeta: l.SolveMeta,\n\t\tP:         make([]gps.LockedProject, len(l.P)),\n\t}\n\n\tl2.SolveMeta.InputImports = make([]string, len(l.SolveMeta.InputImports))\n\tcopy(l2.SolveMeta.InputImports, l.SolveMeta.InputImports)\n\tcopy(l2.P, l.P)\n\n\treturn l2\n}\n\n// toRaw converts the manifest into a representation suitable to write to the lock file\nfunc (l *Lock) toRaw() rawLock {\n\traw := rawLock{\n\t\tSolveMeta: solveMeta{\n\t\t\tAnalyzerName:    l.SolveMeta.AnalyzerName,\n\t\t\tAnalyzerVersion: l.SolveMeta.AnalyzerVersion,\n\t\t\tInputImports:    l.SolveMeta.InputImports,\n\t\t\tSolverName:      l.SolveMeta.SolverName,\n\t\t\tSolverVersion:   l.SolveMeta.SolverVersion,\n\t\t},\n\t\tProjects: make([]rawLockedProject, 0, len(l.P)),\n\t}\n\n\tsort.Slice(l.P, func(i, j int) bool {\n\t\treturn l.P[i].Ident().Less(l.P[j].Ident())\n\t})\n\n\tfor _, lp := range l.P {\n\t\tid := lp.Ident()\n\t\tld := rawLockedProject{\n\t\t\tName:     string(id.ProjectRoot),\n\t\t\tSource:   id.Source,\n\t\t\tPackages: lp.Packages(),\n\t\t}\n\n\t\tv := lp.Version()\n\t\tld.Revision, ld.Branch, ld.Version = gps.VersionComponentStrings(v)\n\n\t\t// This will panic if the lock isn't the expected dynamic type. We can\n\t\t// relax this later if it turns out to create real problems, but there's\n\t\t// no intended case in which this is untrue, so it's preferable to start\n\t\t// by failing hard if those expectations aren't met.\n\t\tvp := lp.(verify.VerifiableProject)\n\t\tld.Digest = vp.Digest.String()\n\t\tld.PruneOpts = (vp.PruneOpts & ^gps.PruneNestedVendorDirs).String()\n\n\t\traw.Projects = append(raw.Projects, ld)\n\t}\n\n\treturn raw\n}\n\n// MarshalTOML serializes this lock into TOML via an intermediate raw form.\nfunc (l *Lock) MarshalTOML() ([]byte, error) {\n\traw := l.toRaw()\n\tvar buf bytes.Buffer\n\tenc := toml.NewEncoder(&buf).ArraysWithOneElementPerLine(true)\n\terr := enc.Encode(raw)\n\treturn buf.Bytes(), errors.Wrap(err, \"Unable to marshal lock to TOML string\")\n}\n\n// LockFromSolution converts a gps.Solution to dep's representation of a lock.\n// It makes sure that that the provided prune options are set correctly, as the\n// solver does not use VerifiableProjects for new selections it makes.\n//\n// Data is defensively copied wherever necessary to ensure the resulting *Lock\n// shares no memory with the input solution.\nfunc LockFromSolution(in gps.Solution, prune gps.CascadingPruneOptions) *Lock {\n\tp := in.Projects()\n\n\tl := &Lock{\n\t\tSolveMeta: SolveMeta{\n\t\t\tAnalyzerName:    in.AnalyzerName(),\n\t\t\tAnalyzerVersion: in.AnalyzerVersion(),\n\t\t\tInputImports:    in.InputImports(),\n\t\t\tSolverName:      in.SolverName(),\n\t\t\tSolverVersion:   in.SolverVersion(),\n\t\t},\n\t\tP: make([]gps.LockedProject, 0, len(p)),\n\t}\n\n\tfor _, lp := range p {\n\t\tif vp, ok := lp.(verify.VerifiableProject); ok {\n\t\t\tl.P = append(l.P, vp)\n\t\t} else {\n\t\t\tl.P = append(l.P, verify.VerifiableProject{\n\t\t\t\tLockedProject: lp,\n\t\t\t\tPruneOpts:     prune.PruneOptionsFor(lp.Ident().ProjectRoot),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn l\n}\n"
        },
        {
          "name": "lock_test.go",
          "type": "blob",
          "size": 4.474609375,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/gps/verify\"\n\t\"github.com/golang/dep/internal/test\"\n)\n\nfunc TestReadLock(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tgolden := \"lock/golden0.toml\"\n\tg0f := h.GetTestFile(golden)\n\tdefer g0f.Close()\n\tgot, err := readLock(g0f)\n\tif err != nil {\n\t\tt.Fatalf(\"Should have read Lock correctly, but got err %q\", err)\n\t}\n\n\twant := &Lock{\n\t\tSolveMeta: SolveMeta{InputImports: []string{}},\n\t\tP: []gps.LockedProject{\n\t\t\tverify.VerifiableProject{\n\t\t\t\tLockedProject: gps.NewLockedProject(\n\t\t\t\t\tgps.ProjectIdentifier{ProjectRoot: gps.ProjectRoot(\"github.com/golang/dep\")},\n\t\t\t\t\tgps.NewBranch(\"master\").Pair(gps.Revision(\"d05d5aca9f895d19e9265839bffeadd74a2d2ecb\")),\n\t\t\t\t\t[]string{\".\"},\n\t\t\t\t),\n\t\t\t\tPruneOpts: gps.PruneOptions(1),\n\t\t\t\tDigest: verify.VersionedDigest{\n\t\t\t\t\tHashVersion: verify.HashVersion,\n\t\t\t\t\tDigest:      []byte(\"foo\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Error(\"Valid lock did not parse as expected\")\n\t}\n\n\tgolden = \"lock/golden1.toml\"\n\tg1f := h.GetTestFile(golden)\n\tdefer g1f.Close()\n\tgot, err = readLock(g1f)\n\tif err != nil {\n\t\tt.Fatalf(\"Should have read Lock correctly, but got err %q\", err)\n\t}\n\n\twant = &Lock{\n\t\tSolveMeta: SolveMeta{InputImports: []string{}},\n\t\tP: []gps.LockedProject{\n\t\t\tverify.VerifiableProject{\n\t\t\t\tLockedProject: gps.NewLockedProject(\n\t\t\t\t\tgps.ProjectIdentifier{ProjectRoot: gps.ProjectRoot(\"github.com/golang/dep\")},\n\t\t\t\t\tgps.NewVersion(\"0.12.2\").Pair(gps.Revision(\"d05d5aca9f895d19e9265839bffeadd74a2d2ecb\")),\n\t\t\t\t\t[]string{\".\"},\n\t\t\t\t),\n\t\t\t\tPruneOpts: gps.PruneOptions(15),\n\t\t\t\tDigest: verify.VersionedDigest{\n\t\t\t\t\tHashVersion: verify.HashVersion,\n\t\t\t\t\tDigest:      []byte(\"foo\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Error(\"Valid lock did not parse as expected\")\n\t}\n}\n\nfunc TestWriteLock(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tgolden := \"lock/golden0.toml\"\n\twant := h.GetTestFileString(golden)\n\tl := &Lock{\n\t\tP: []gps.LockedProject{\n\t\t\tverify.VerifiableProject{\n\t\t\t\tLockedProject: gps.NewLockedProject(\n\t\t\t\t\tgps.ProjectIdentifier{ProjectRoot: gps.ProjectRoot(\"github.com/golang/dep\")},\n\t\t\t\t\tgps.NewBranch(\"master\").Pair(gps.Revision(\"d05d5aca9f895d19e9265839bffeadd74a2d2ecb\")),\n\t\t\t\t\t[]string{\".\"},\n\t\t\t\t),\n\t\t\t\tPruneOpts: gps.PruneOptions(1),\n\t\t\t\tDigest: verify.VersionedDigest{\n\t\t\t\t\tHashVersion: verify.HashVersion,\n\t\t\t\t\tDigest:      []byte(\"foo\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tgot, err := l.MarshalTOML()\n\tif err != nil {\n\t\tt.Fatalf(\"Error while marshaling valid lock to TOML: %q\", err)\n\t}\n\n\tif string(got) != want {\n\t\tif *test.UpdateGolden {\n\t\t\tif err = h.WriteTestFile(golden, string(got)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Valid lock did not marshal to TOML as expected:\\n\\t(GOT): %s\\n\\t(WNT): %s\", string(got), want)\n\t\t}\n\t}\n\n\tgolden = \"lock/golden1.toml\"\n\twant = h.GetTestFileString(golden)\n\tl = &Lock{\n\t\tP: []gps.LockedProject{\n\t\t\tverify.VerifiableProject{\n\t\t\t\tLockedProject: gps.NewLockedProject(\n\t\t\t\t\tgps.ProjectIdentifier{ProjectRoot: gps.ProjectRoot(\"github.com/golang/dep\")},\n\t\t\t\t\tgps.NewVersion(\"0.12.2\").Pair(gps.Revision(\"d05d5aca9f895d19e9265839bffeadd74a2d2ecb\")),\n\t\t\t\t\t[]string{\".\"},\n\t\t\t\t),\n\t\t\t\tPruneOpts: gps.PruneOptions(15),\n\t\t\t\tDigest: verify.VersionedDigest{\n\t\t\t\t\tHashVersion: verify.HashVersion,\n\t\t\t\t\tDigest:      []byte(\"foo\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tgot, err = l.MarshalTOML()\n\tif err != nil {\n\t\tt.Fatalf(\"Error while marshaling valid lock to TOML: %q\", err)\n\t}\n\n\tif string(got) != want {\n\t\tif *test.UpdateGolden {\n\t\t\tif err = h.WriteTestFile(golden, string(got)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"Valid lock did not marshal to TOML as expected:\\n\\t(GOT): %s\\n\\t(WNT): %s\", string(got), want)\n\t\t}\n\t}\n}\n\nfunc TestReadLockErrors(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tvar err error\n\n\ttests := []struct {\n\t\tname string\n\t\tfile string\n\t}{\n\t\t{\"specified both\", \"lock/error0.toml\"},\n\t\t{\"odd length\", \"lock/error1.toml\"},\n\t\t{\"no branch or version\", \"lock/error2.toml\"},\n\t}\n\n\tfor _, tst := range tests {\n\t\tlf := h.GetTestFile(tst.file)\n\t\tdefer lf.Close()\n\t\t_, err = readLock(lf)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Reading lock with %s should have caused error, but did not\", tst.name)\n\t\t} else if !strings.Contains(err.Error(), tst.name) {\n\t\t\tt.Errorf(\"Unexpected error %q; expected %s error\", err, tst.name)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "manifest.go",
          "type": "blob",
          "size": 18.8857421875,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"sort\"\n\t\"sync\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/gps/pkgtree\"\n\t\"github.com/pelletier/go-toml\"\n\t\"github.com/pkg/errors\"\n)\n\n// ManifestName is the manifest file name used by dep.\nconst ManifestName = \"Gopkg.toml\"\n\n// Errors\nvar (\n\terrInvalidConstraint   = errors.Errorf(\"%q must be a TOML array of tables\", \"constraint\")\n\terrInvalidOverride     = errors.Errorf(\"%q must be a TOML array of tables\", \"override\")\n\terrInvalidRequired     = errors.Errorf(\"%q must be a TOML list of strings\", \"required\")\n\terrInvalidIgnored      = errors.Errorf(\"%q must be a TOML list of strings\", \"ignored\")\n\terrInvalidNoVerify     = errors.Errorf(\"%q must be a TOML list of strings\", \"noverify\")\n\terrInvalidPrune        = errors.Errorf(\"%q must be a TOML table of booleans\", \"prune\")\n\terrInvalidPruneProject = errors.Errorf(\"%q must be a TOML array of tables\", \"prune.project\")\n\terrInvalidMetadata     = errors.New(\"metadata should be a TOML table\")\n\n\terrInvalidProjectRoot = errors.New(\"ProjectRoot name validation failed\")\n\n\terrInvalidPruneValue = errors.New(\"prune options values must be booleans\")\n\terrPruneSubProject   = errors.New(\"prune projects should not contain sub projects\")\n\n\terrRootPruneContainsName   = errors.Errorf(\"%q should not include a name\", \"prune\")\n\terrInvalidRootPruneValue   = errors.New(\"root prune options must be omitted instead of being set to false\")\n\terrInvalidPruneProjectName = errors.Errorf(\"%q in %q must be a string\", \"name\", \"prune.project\")\n\terrNoName                  = errors.New(\"no name provided\")\n)\n\n// Manifest holds manifest file data and implements gps.RootManifest.\ntype Manifest struct {\n\tConstraints gps.ProjectConstraints\n\tOvr         gps.ProjectConstraints\n\n\tIgnored  []string\n\tRequired []string\n\n\tNoVerify []string\n\n\tPruneOptions gps.CascadingPruneOptions\n}\n\ntype rawManifest struct {\n\tConstraints  []rawProject    `toml:\"constraint,omitempty\"`\n\tOverrides    []rawProject    `toml:\"override,omitempty\"`\n\tIgnored      []string        `toml:\"ignored,omitempty\"`\n\tRequired     []string        `toml:\"required,omitempty\"`\n\tNoVerify     []string        `toml:\"noverify,omitempty\"`\n\tPruneOptions rawPruneOptions `toml:\"prune,omitempty\"`\n}\n\ntype rawProject struct {\n\tName     string `toml:\"name\"`\n\tBranch   string `toml:\"branch,omitempty\"`\n\tRevision string `toml:\"revision,omitempty\"`\n\tVersion  string `toml:\"version,omitempty\"`\n\tSource   string `toml:\"source,omitempty\"`\n}\n\ntype rawPruneOptions struct {\n\tUnusedPackages bool `toml:\"unused-packages,omitempty\"`\n\tNonGoFiles     bool `toml:\"non-go,omitempty\"`\n\tGoTests        bool `toml:\"go-tests,omitempty\"`\n\n\t//Projects []map[string]interface{} `toml:\"project,omitempty\"`\n\tProjects []map[string]interface{}\n}\n\nconst (\n\tpruneOptionUnusedPackages = \"unused-packages\"\n\tpruneOptionGoTests        = \"go-tests\"\n\tpruneOptionNonGo          = \"non-go\"\n)\n\n// Constants representing per-project prune uint8 values.\nconst (\n\tpvnone  uint8 = 0 // No per-project prune value was set in Gopkg.toml.\n\tpvtrue  uint8 = 1 // Per-project prune value was explicitly set to true.\n\tpvfalse uint8 = 2 // Per-project prune value was explicitly set to false.\n)\n\n// NewManifest instantites a new manifest.\nfunc NewManifest() *Manifest {\n\treturn &Manifest{\n\t\tConstraints: make(gps.ProjectConstraints),\n\t\tOvr:         make(gps.ProjectConstraints),\n\t\tPruneOptions: gps.CascadingPruneOptions{\n\t\t\tDefaultOptions:    gps.PruneNestedVendorDirs,\n\t\t\tPerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{},\n\t\t},\n\t}\n}\n\nfunc validateManifest(s string) ([]error, error) {\n\tvar warns []error\n\t// Load the TomlTree from string\n\ttree, err := toml.Load(s)\n\tif err != nil {\n\t\treturn warns, errors.Wrap(err, \"unable to load TomlTree from string\")\n\t}\n\t// Convert tree to a map\n\tmanifest := tree.ToMap()\n\n\t// match abbreviated git hash (7chars) or hg hash (12chars)\n\tabbrevRevHash := regexp.MustCompile(\"^[a-f0-9]{7}([a-f0-9]{5})?$\")\n\t// Look for unknown fields and collect errors\n\tfor prop, val := range manifest {\n\t\tswitch prop {\n\t\tcase \"metadata\":\n\t\t\t// Check if metadata is of Map type\n\t\t\tif reflect.TypeOf(val).Kind() != reflect.Map {\n\t\t\t\twarns = append(warns, errInvalidMetadata)\n\t\t\t}\n\t\tcase \"constraint\", \"override\":\n\t\t\tvalid := true\n\t\t\t// Invalid if type assertion fails. Not a TOML array of tables.\n\t\t\tif rawProj, ok := val.([]interface{}); ok {\n\t\t\t\t// Check element type. Must be a map. Checking one element would be\n\t\t\t\t// enough because TOML doesn't allow mixing of types.\n\t\t\t\tif reflect.TypeOf(rawProj[0]).Kind() != reflect.Map {\n\t\t\t\t\tvalid = false\n\t\t\t\t}\n\n\t\t\t\tif valid {\n\t\t\t\t\t// Iterate through each array of tables\n\t\t\t\t\tfor _, v := range rawProj {\n\t\t\t\t\t\truleProvided := false\n\t\t\t\t\t\tprops := v.(map[string]interface{})\n\t\t\t\t\t\t// Check the individual field's key to be valid\n\t\t\t\t\t\tfor key, value := range props {\n\t\t\t\t\t\t\t// Check if the key is valid\n\t\t\t\t\t\t\tswitch key {\n\t\t\t\t\t\t\tcase \"name\":\n\t\t\t\t\t\t\tcase \"branch\", \"version\", \"source\":\n\t\t\t\t\t\t\t\truleProvided = true\n\t\t\t\t\t\t\tcase \"revision\":\n\t\t\t\t\t\t\t\truleProvided = true\n\t\t\t\t\t\t\t\tif valueStr, ok := value.(string); ok {\n\t\t\t\t\t\t\t\t\tif abbrevRevHash.MatchString(valueStr) {\n\t\t\t\t\t\t\t\t\t\twarns = append(warns, fmt.Errorf(\"revision %q should not be in abbreviated form\", valueStr))\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"metadata\":\n\t\t\t\t\t\t\t\t// Check if metadata is of Map type\n\t\t\t\t\t\t\t\tif reflect.TypeOf(value).Kind() != reflect.Map {\n\t\t\t\t\t\t\t\t\twarns = append(warns, fmt.Errorf(\"metadata in %q should be a TOML table\", prop))\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// unknown/invalid key\n\t\t\t\t\t\t\t\twarns = append(warns, fmt.Errorf(\"invalid key %q in %q\", key, prop))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif _, ok := props[\"name\"]; !ok {\n\t\t\t\t\t\t\twarns = append(warns, errNoName)\n\t\t\t\t\t\t} else if !ruleProvided && prop == \"constraint\" {\n\t\t\t\t\t\t\twarns = append(warns, fmt.Errorf(\"branch, version, revision, or source should be provided for %q\", props[\"name\"]))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalid = false\n\t\t\t}\n\n\t\t\tif !valid {\n\t\t\t\tif prop == \"constraint\" {\n\t\t\t\t\treturn warns, errInvalidConstraint\n\t\t\t\t}\n\t\t\t\tif prop == \"override\" {\n\t\t\t\t\treturn warns, errInvalidOverride\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"ignored\", \"required\", \"noverify\":\n\t\t\tvalid := true\n\t\t\tif rawList, ok := val.([]interface{}); ok {\n\t\t\t\t// Check element type of the array. TOML doesn't let mixing of types in\n\t\t\t\t// array. Checking one element would be enough. Empty array is valid.\n\t\t\t\tif len(rawList) > 0 && reflect.TypeOf(rawList[0]).Kind() != reflect.String {\n\t\t\t\t\tvalid = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalid = false\n\t\t\t}\n\n\t\t\tif !valid {\n\t\t\t\tif prop == \"ignored\" {\n\t\t\t\t\treturn warns, errInvalidIgnored\n\t\t\t\t}\n\t\t\t\tif prop == \"required\" {\n\t\t\t\t\treturn warns, errInvalidRequired\n\t\t\t\t}\n\t\t\t\tif prop == \"noverify\" {\n\t\t\t\t\treturn warns, errInvalidNoVerify\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"prune\":\n\t\t\tpruneWarns, err := validatePruneOptions(val, true)\n\t\t\twarns = append(warns, pruneWarns...)\n\t\t\tif err != nil {\n\t\t\t\treturn warns, err\n\t\t\t}\n\t\tdefault:\n\t\t\twarns = append(warns, fmt.Errorf(\"unknown field in manifest: %v\", prop))\n\t\t}\n\t}\n\n\treturn warns, nil\n}\n\nfunc validatePruneOptions(val interface{}, root bool) (warns []error, err error) {\n\tif reflect.TypeOf(val).Kind() != reflect.Map {\n\t\treturn warns, errInvalidPrune\n\t}\n\n\tfor key, value := range val.(map[string]interface{}) {\n\t\tswitch key {\n\t\tcase pruneOptionNonGo, pruneOptionGoTests, pruneOptionUnusedPackages:\n\t\t\tif option, ok := value.(bool); !ok {\n\t\t\t\treturn warns, errInvalidPruneValue\n\t\t\t} else if root && !option {\n\t\t\t\treturn warns, errInvalidRootPruneValue\n\t\t\t}\n\t\tcase \"name\":\n\t\t\tif root {\n\t\t\t\twarns = append(warns, errRootPruneContainsName)\n\t\t\t} else if _, ok := value.(string); !ok {\n\t\t\t\treturn warns, errInvalidPruneProjectName\n\t\t\t}\n\t\tcase \"project\":\n\t\t\tif !root {\n\t\t\t\treturn warns, errPruneSubProject\n\t\t\t}\n\t\t\tif reflect.TypeOf(value).Kind() != reflect.Slice {\n\t\t\t\treturn warns, errInvalidPruneProject\n\t\t\t}\n\n\t\t\tfor _, project := range value.([]interface{}) {\n\t\t\t\tprojectWarns, err := validatePruneOptions(project, false)\n\t\t\t\twarns = append(warns, projectWarns...)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\n\t\tdefault:\n\t\t\tif root {\n\t\t\t\twarns = append(warns, errors.Errorf(\"unknown field %q in %q\", key, \"prune\"))\n\t\t\t} else {\n\t\t\t\twarns = append(warns, errors.Errorf(\"unknown field %q in %q\", key, \"prune.project\"))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warns, err\n}\n\nfunc checkRedundantPruneOptions(co gps.CascadingPruneOptions) (warns []error) {\n\tfor name, project := range co.PerProjectOptions {\n\t\tif project.UnusedPackages != pvnone {\n\t\t\tif (co.DefaultOptions&gps.PruneUnusedPackages != 0) == (project.UnusedPackages == pvtrue) {\n\t\t\t\twarns = append(warns, errors.Errorf(\"redundant prune option %q set for %q\", pruneOptionUnusedPackages, name))\n\t\t\t}\n\t\t}\n\n\t\tif project.NonGoFiles != pvnone {\n\t\t\tif (co.DefaultOptions&gps.PruneNonGoFiles != 0) == (project.NonGoFiles == pvtrue) {\n\t\t\t\twarns = append(warns, errors.Errorf(\"redundant prune option %q set for %q\", pruneOptionNonGo, name))\n\t\t\t}\n\t\t}\n\n\t\tif project.GoTests != pvnone {\n\t\t\tif (co.DefaultOptions&gps.PruneGoTestFiles != 0) == (project.GoTests == pvtrue) {\n\t\t\t\twarns = append(warns, errors.Errorf(\"redundant prune option %q set for %q\", pruneOptionGoTests, name))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn warns\n}\n\n// ValidateProjectRoots validates the project roots present in manifest.\nfunc ValidateProjectRoots(c *Ctx, m *Manifest, sm gps.SourceManager) error {\n\t// Channel to receive all the errors\n\terrorCh := make(chan error, len(m.Constraints)+len(m.Ovr))\n\n\tvar wg sync.WaitGroup\n\n\tvalidate := func(pr gps.ProjectRoot) {\n\t\tdefer wg.Done()\n\t\torigPR, err := sm.DeduceProjectRoot(string(pr))\n\t\tif err != nil {\n\t\t\terrorCh <- err\n\t\t} else if origPR != pr {\n\t\t\terrorCh <- fmt.Errorf(\"the name for %q should be changed to %q\", pr, origPR)\n\t\t}\n\t}\n\n\tfor pr := range m.Constraints {\n\t\twg.Add(1)\n\t\tgo validate(pr)\n\t}\n\tfor pr := range m.Ovr {\n\t\twg.Add(1)\n\t\tgo validate(pr)\n\t}\n\tfor pr := range m.PruneOptions.PerProjectOptions {\n\t\twg.Add(1)\n\t\tgo validate(pr)\n\t}\n\n\twg.Wait()\n\tclose(errorCh)\n\n\tvar valErr error\n\tif len(errorCh) > 0 {\n\t\tvalErr = errInvalidProjectRoot\n\t\tc.Err.Printf(\"The following issues were found in Gopkg.toml:\\n\\n\")\n\t\tfor err := range errorCh {\n\t\t\tc.Err.Println(\"  ✗\", err.Error())\n\t\t}\n\t\tc.Err.Println()\n\t}\n\n\treturn valErr\n}\n\n// readManifest returns a Manifest read from r and a slice of validation warnings.\nfunc readManifest(r io.Reader) (*Manifest, []error, error) {\n\tbuf := &bytes.Buffer{}\n\t_, err := buf.ReadFrom(r)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"unable to read byte stream\")\n\t}\n\n\twarns, err := validateManifest(buf.String())\n\tif err != nil {\n\t\treturn nil, warns, errors.Wrap(err, \"manifest validation failed\")\n\t}\n\n\traw := rawManifest{}\n\terr = toml.Unmarshal(buf.Bytes(), &raw)\n\tif err != nil {\n\t\treturn nil, warns, errors.Wrap(err, \"unable to parse the manifest as TOML\")\n\t}\n\n\tm, err := fromRawManifest(raw, buf)\n\tif err != nil {\n\t\treturn nil, warns, err\n\t}\n\n\twarns = append(warns, checkRedundantPruneOptions(m.PruneOptions)...)\n\treturn m, warns, nil\n}\n\nfunc fromRawManifest(raw rawManifest, buf *bytes.Buffer) (*Manifest, error) {\n\tm := NewManifest()\n\n\tm.Constraints = make(gps.ProjectConstraints, len(raw.Constraints))\n\tm.Ovr = make(gps.ProjectConstraints, len(raw.Overrides))\n\tm.Ignored = raw.Ignored\n\tm.Required = raw.Required\n\tm.NoVerify = raw.NoVerify\n\n\tfor i := 0; i < len(raw.Constraints); i++ {\n\t\tname, prj, err := toProject(raw.Constraints[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif _, exists := m.Constraints[name]; exists {\n\t\t\treturn nil, errors.Errorf(\"multiple dependencies specified for %s, can only specify one\", name)\n\t\t}\n\t\tm.Constraints[name] = prj\n\t}\n\n\tfor i := 0; i < len(raw.Overrides); i++ {\n\t\tname, prj, err := toProject(raw.Overrides[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif _, exists := m.Ovr[name]; exists {\n\t\t\treturn nil, errors.Errorf(\"multiple overrides specified for %s, can only specify one\", name)\n\t\t}\n\t\tm.Ovr[name] = prj\n\t}\n\n\t// TODO(sdboyer) it is awful that we have to do this manual extraction\n\ttree, err := toml.Load(buf.String())\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to load TomlTree from string\")\n\t}\n\n\tiprunemap := tree.Get(\"prune\")\n\tif iprunemap == nil {\n\t\treturn m, nil\n\t}\n\t// Previous validation already guaranteed that, if it exists, it's this map\n\t// type.\n\tm.PruneOptions = fromRawPruneOptions(iprunemap.(*toml.Tree).ToMap())\n\n\treturn m, nil\n}\n\nfunc fromRawPruneOptions(prunemap map[string]interface{}) gps.CascadingPruneOptions {\n\topts := gps.CascadingPruneOptions{\n\t\tDefaultOptions:    gps.PruneNestedVendorDirs,\n\t\tPerProjectOptions: make(map[gps.ProjectRoot]gps.PruneOptionSet),\n\t}\n\n\tif val, has := prunemap[pruneOptionUnusedPackages]; has && val.(bool) {\n\t\topts.DefaultOptions |= gps.PruneUnusedPackages\n\t}\n\tif val, has := prunemap[pruneOptionNonGo]; has && val.(bool) {\n\t\topts.DefaultOptions |= gps.PruneNonGoFiles\n\t}\n\tif val, has := prunemap[pruneOptionGoTests]; has && val.(bool) {\n\t\topts.DefaultOptions |= gps.PruneGoTestFiles\n\t}\n\n\ttrinary := func(v interface{}) uint8 {\n\t\tb := v.(bool)\n\t\tif b {\n\t\t\treturn pvtrue\n\t\t}\n\t\treturn pvfalse\n\t}\n\n\tif projprunes, has := prunemap[\"project\"]; has {\n\t\tfor _, proj := range projprunes.([]interface{}) {\n\t\t\tvar pr gps.ProjectRoot\n\t\t\t// This should be redundant, but being explicit doesn't hurt.\n\t\t\tpos := gps.PruneOptionSet{NestedVendor: pvtrue}\n\n\t\t\tfor key, val := range proj.(map[string]interface{}) {\n\t\t\t\tswitch key {\n\t\t\t\tcase \"name\":\n\t\t\t\t\tpr = gps.ProjectRoot(val.(string))\n\t\t\t\tcase pruneOptionNonGo:\n\t\t\t\t\tpos.NonGoFiles = trinary(val)\n\t\t\t\tcase pruneOptionGoTests:\n\t\t\t\t\tpos.GoTests = trinary(val)\n\t\t\t\tcase pruneOptionUnusedPackages:\n\t\t\t\t\tpos.UnusedPackages = trinary(val)\n\t\t\t\t}\n\t\t\t}\n\t\t\topts.PerProjectOptions[pr] = pos\n\t\t}\n\t}\n\n\treturn opts\n}\n\n// toRawPruneOptions converts a gps.RootPruneOption's PruneOptions to rawPruneOptions\n//\n// Will panic if gps.RootPruneOption includes ProjectPruneOptions\n// See https://github.com/golang/dep/pull/1460#discussion_r158128740 for more information\nfunc toRawPruneOptions(co gps.CascadingPruneOptions) rawPruneOptions {\n\tif len(co.PerProjectOptions) != 0 {\n\t\tpanic(\"toRawPruneOptions cannot convert ProjectOptions to rawPruneOptions\")\n\t}\n\traw := rawPruneOptions{}\n\n\tif (co.DefaultOptions & gps.PruneUnusedPackages) != 0 {\n\t\traw.UnusedPackages = true\n\t}\n\n\tif (co.DefaultOptions & gps.PruneNonGoFiles) != 0 {\n\t\traw.NonGoFiles = true\n\t}\n\n\tif (co.DefaultOptions & gps.PruneGoTestFiles) != 0 {\n\t\traw.GoTests = true\n\t}\n\treturn raw\n}\n\n// toProject interprets the string representations of project information held in\n// a rawProject, converting them into a proper gps.ProjectProperties. An\n// error is returned if the rawProject contains some invalid combination -\n// for example, if both a branch and version constraint are specified.\nfunc toProject(raw rawProject) (n gps.ProjectRoot, pp gps.ProjectProperties, err error) {\n\tn = gps.ProjectRoot(raw.Name)\n\tif raw.Branch != \"\" {\n\t\tif raw.Version != \"\" || raw.Revision != \"\" {\n\t\t\treturn n, pp, errors.Errorf(\"multiple constraints specified for %s, can only specify one\", n)\n\t\t}\n\t\tpp.Constraint = gps.NewBranch(raw.Branch)\n\t} else if raw.Version != \"\" {\n\t\tif raw.Revision != \"\" {\n\t\t\treturn n, pp, errors.Errorf(\"multiple constraints specified for %s, can only specify one\", n)\n\t\t}\n\n\t\t// always semver if we can\n\t\tpp.Constraint, err = gps.NewSemverConstraintIC(raw.Version)\n\t\tif err != nil {\n\t\t\t// but if not, fall back on plain versions\n\t\t\tpp.Constraint = gps.NewVersion(raw.Version)\n\t\t}\n\t} else if raw.Revision != \"\" {\n\t\tpp.Constraint = gps.Revision(raw.Revision)\n\t} else {\n\t\t// If the user specifies nothing, it means an open constraint (accept\n\t\t// anything).\n\t\tpp.Constraint = gps.Any()\n\t}\n\n\tpp.Source = raw.Source\n\n\treturn n, pp, nil\n}\n\n// MarshalTOML serializes this manifest into TOML via an intermediate raw form.\nfunc (m *Manifest) MarshalTOML() ([]byte, error) {\n\traw := m.toRaw()\n\tvar buf bytes.Buffer\n\tenc := toml.NewEncoder(&buf).ArraysWithOneElementPerLine(true)\n\terr := enc.Encode(raw)\n\treturn buf.Bytes(), errors.Wrap(err, \"unable to marshal the lock to a TOML string\")\n}\n\n// toRaw converts the manifest into a representation suitable to write to the manifest file\nfunc (m *Manifest) toRaw() rawManifest {\n\traw := rawManifest{\n\t\tConstraints: make([]rawProject, 0, len(m.Constraints)),\n\t\tOverrides:   make([]rawProject, 0, len(m.Ovr)),\n\t\tIgnored:     m.Ignored,\n\t\tRequired:    m.Required,\n\t\tNoVerify:    m.NoVerify,\n\t}\n\n\tfor n, prj := range m.Constraints {\n\t\traw.Constraints = append(raw.Constraints, toRawProject(n, prj))\n\t}\n\tsort.Sort(sortedRawProjects(raw.Constraints))\n\n\tfor n, prj := range m.Ovr {\n\t\traw.Overrides = append(raw.Overrides, toRawProject(n, prj))\n\t}\n\tsort.Sort(sortedRawProjects(raw.Overrides))\n\n\traw.PruneOptions = toRawPruneOptions(m.PruneOptions)\n\n\treturn raw\n}\n\ntype sortedRawProjects []rawProject\n\nfunc (s sortedRawProjects) Len() int      { return len(s) }\nfunc (s sortedRawProjects) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\nfunc (s sortedRawProjects) Less(i, j int) bool {\n\tl, r := s[i], s[j]\n\n\tif l.Name < r.Name {\n\t\treturn true\n\t}\n\tif r.Name < l.Name {\n\t\treturn false\n\t}\n\n\treturn l.Source < r.Source\n}\n\nfunc toRawProject(name gps.ProjectRoot, project gps.ProjectProperties) rawProject {\n\traw := rawProject{\n\t\tName:   string(name),\n\t\tSource: project.Source,\n\t}\n\n\tif v, ok := project.Constraint.(gps.Version); ok {\n\t\tswitch v.Type() {\n\t\tcase gps.IsRevision:\n\t\t\traw.Revision = v.String()\n\t\tcase gps.IsBranch:\n\t\t\traw.Branch = v.String()\n\t\tcase gps.IsSemver, gps.IsVersion:\n\t\t\traw.Version = v.ImpliedCaretString()\n\t\t}\n\t\treturn raw\n\t}\n\n\t// We simply don't allow for a case where the user could directly\n\t// express a 'none' constraint, so we can ignore it here. We also ignore\n\t// the 'any' case, because that's the other possibility, and it's what\n\t// we interpret not having any constraint expressions at all to mean.\n\t// if !gps.IsAny(pp.Constraint) && !gps.IsNone(pp.Constraint) {\n\tif !gps.IsAny(project.Constraint) && project.Constraint != nil {\n\t\t// Has to be a semver range.\n\t\traw.Version = project.Constraint.ImpliedCaretString()\n\t}\n\n\treturn raw\n}\n\n// DependencyConstraints returns a list of project-level constraints.\nfunc (m *Manifest) DependencyConstraints() gps.ProjectConstraints {\n\treturn m.Constraints\n}\n\n// Overrides returns a list of project-level override constraints.\nfunc (m *Manifest) Overrides() gps.ProjectConstraints {\n\treturn m.Ovr\n}\n\n// IgnoredPackages returns a set of import paths to ignore.\nfunc (m *Manifest) IgnoredPackages() *pkgtree.IgnoredRuleset {\n\tif m == nil {\n\t\treturn pkgtree.NewIgnoredRuleset(nil)\n\t}\n\treturn pkgtree.NewIgnoredRuleset(m.Ignored)\n}\n\n// HasConstraintsOn checks if the manifest contains either constraints or\n// overrides on the provided ProjectRoot.\nfunc (m *Manifest) HasConstraintsOn(root gps.ProjectRoot) bool {\n\tif _, has := m.Constraints[root]; has {\n\t\treturn true\n\t}\n\tif _, has := m.Ovr[root]; has {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// RequiredPackages returns a set of import paths to require.\nfunc (m *Manifest) RequiredPackages() map[string]bool {\n\tif m == nil || m == (*Manifest)(nil) {\n\t\treturn map[string]bool{}\n\t}\n\n\tif len(m.Required) == 0 {\n\t\treturn nil\n\t}\n\n\tmp := make(map[string]bool, len(m.Required))\n\tfor _, i := range m.Required {\n\t\tmp[i] = true\n\t}\n\n\treturn mp\n}\n"
        },
        {
          "name": "manifest_test.go",
          "type": "blob",
          "size": 19.359375,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/internal/test\"\n)\n\nfunc TestReadManifest(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tmf := h.GetTestFile(\"manifest/golden.toml\")\n\tdefer mf.Close()\n\tgot, _, err := readManifest(mf)\n\tif err != nil {\n\t\tt.Fatalf(\"should have read manifest correctly, but got err %q\", err)\n\t}\n\n\tc, _ := gps.NewSemverConstraint(\"^0.12.0\")\n\twant := Manifest{\n\t\tConstraints: map[gps.ProjectRoot]gps.ProjectProperties{\n\t\t\tgps.ProjectRoot(\"github.com/golang/dep\"): {\n\t\t\t\tConstraint: c,\n\t\t\t},\n\t\t\tgps.ProjectRoot(\"github.com/babble/brook\"): {\n\t\t\t\tConstraint: gps.Revision(\"d05d5aca9f895d19e9265839bffeadd74a2d2ecb\"),\n\t\t\t},\n\t\t},\n\t\tOvr: map[gps.ProjectRoot]gps.ProjectProperties{\n\t\t\tgps.ProjectRoot(\"github.com/golang/dep\"): {\n\t\t\t\tSource:     \"https://github.com/golang/dep\",\n\t\t\t\tConstraint: gps.NewBranch(\"master\"),\n\t\t\t},\n\t\t},\n\t\tIgnored: []string{\"github.com/foo/bar\"},\n\t\tPruneOptions: gps.CascadingPruneOptions{\n\t\t\tDefaultOptions:    gps.PruneNestedVendorDirs | gps.PruneNonGoFiles,\n\t\t\tPerProjectOptions: make(map[gps.ProjectRoot]gps.PruneOptionSet),\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(got.Constraints, want.Constraints) {\n\t\tt.Error(\"Valid manifest's dependencies did not parse as expected\")\n\t}\n\tif !reflect.DeepEqual(got.Ovr, want.Ovr) {\n\t\tt.Error(\"Valid manifest's overrides did not parse as expected\")\n\t}\n\tif !reflect.DeepEqual(got.Ignored, want.Ignored) {\n\t\tt.Error(\"Valid manifest's ignored did not parse as expected\")\n\t}\n\tif !reflect.DeepEqual(got.PruneOptions, want.PruneOptions) {\n\t\tt.Error(\"Valid manifest's prune options did not parse as expected\")\n\t\tt.Error(got.PruneOptions, want.PruneOptions)\n\t}\n}\n\nfunc TestWriteManifest(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tgolden := \"manifest/golden.toml\"\n\twant := h.GetTestFileString(golden)\n\tc, _ := gps.NewSemverConstraint(\"^0.12.0\")\n\tm := NewManifest()\n\tm.Constraints[gps.ProjectRoot(\"github.com/golang/dep\")] = gps.ProjectProperties{\n\t\tConstraint: c,\n\t}\n\tm.Constraints[gps.ProjectRoot(\"github.com/babble/brook\")] = gps.ProjectProperties{\n\t\tConstraint: gps.Revision(\"d05d5aca9f895d19e9265839bffeadd74a2d2ecb\"),\n\t}\n\tm.Ovr[gps.ProjectRoot(\"github.com/golang/dep\")] = gps.ProjectProperties{\n\t\tSource:     \"https://github.com/golang/dep\",\n\t\tConstraint: gps.NewBranch(\"master\"),\n\t}\n\tm.Ignored = []string{\"github.com/foo/bar\"}\n\tm.PruneOptions = gps.CascadingPruneOptions{\n\t\tDefaultOptions:    gps.PruneNestedVendorDirs | gps.PruneNonGoFiles,\n\t\tPerProjectOptions: make(map[gps.ProjectRoot]gps.PruneOptionSet),\n\t}\n\n\tgot, err := m.MarshalTOML()\n\tif err != nil {\n\t\tt.Fatalf(\"error while marshaling valid manifest to TOML: %q\", err)\n\t}\n\n\tif string(got) != want {\n\t\tif *test.UpdateGolden {\n\t\t\tif err = h.WriteTestFile(golden, string(got)); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t} else {\n\t\t\tt.Errorf(\"valid manifest did not marshal to TOML as expected:\\n(GOT):\\n%s\\n(WNT):\\n%s\", string(got), want)\n\t\t}\n\t}\n}\n\nfunc TestReadManifestErrors(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tvar err error\n\n\ttests := []struct {\n\t\tname string\n\t\tfile string\n\t}{\n\t\t{\"multiple constraints\", \"manifest/error1.toml\"},\n\t\t{\"multiple dependencies\", \"manifest/error2.toml\"},\n\t\t{\"multiple overrides\", \"manifest/error3.toml\"},\n\t}\n\n\tfor _, tst := range tests {\n\t\tmf := h.GetTestFile(tst.file)\n\t\tdefer mf.Close()\n\t\t_, _, err = readManifest(mf)\n\t\tif err == nil {\n\t\t\tt.Errorf(\"reading manifest with %s should have caused error, but did not\", tst.name)\n\t\t} else if !strings.Contains(err.Error(), tst.name) {\n\t\t\tt.Errorf(\"unexpected error %q; expected %s error\", err, tst.name)\n\t\t}\n\t}\n}\n\nfunc TestValidateManifest(t *testing.T) {\n\tcases := []struct {\n\t\tname       string\n\t\ttomlString string\n\t\twantWarn   []error\n\t\twantError  error\n\t}{\n\t\t{\n\t\t\tname: \"valid required\",\n\t\t\ttomlString: `\n\t\t\trequired = [\"github.com/foo/bar\"]\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid required\",\n\t\t\ttomlString: `\n\t\t\trequired = \"github.com/foo/bar\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidRequired,\n\t\t},\n\t\t{\n\t\t\tname: \"empty required\",\n\t\t\ttomlString: `\n\t\t\trequired = []\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid required list\",\n\t\t\ttomlString: `\n\t\t\trequired = [1, 2, 3]\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidRequired,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid required format\",\n\t\t\ttomlString: `\n\t\t\t[[required]]\n\t\t\t  name = \"foo\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidRequired,\n\t\t},\n\t\t{\n\t\t\tname: \"valid ignored\",\n\t\t\ttomlString: `\n\t\t\tignored = [\"foo\"]\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid ignored\",\n\t\t\ttomlString: `\n\t\t\tignored = \"foo\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidIgnored,\n\t\t},\n\t\t{\n\t\t\tname: \"empty ignored\",\n\t\t\ttomlString: `\n\t\t\tignored = []\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid ignored list\",\n\t\t\ttomlString: `\n\t\t\tignored = [1, 2, 3]\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidIgnored,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid ignored format\",\n\t\t\ttomlString: `\n\t\t\t[[ignored]]\n\t\t\t  name = \"foo\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidIgnored,\n\t\t},\n\t\t{\n\t\t\tname: \"valid metadata\",\n\t\t\ttomlString: `\n\t\t\t[metadata]\n\t\t\t  authors = \"foo\"\n\t\t\t  version = \"1.0.0\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid metadata\",\n\t\t\ttomlString: `\n\t\t\tfoo = \"some-value\"\n\t\t\tversion = 14\n\n\t\t\t[[bar]]\n\t\t\t  author = \"xyz\"\n\n\t\t\t[[constraint]]\n\t\t\t  name = \"github.com/foo/bar\"\n\t\t\t  version = \"\"\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrors.New(\"unknown field in manifest: foo\"),\n\t\t\t\terrors.New(\"unknown field in manifest: bar\"),\n\t\t\t\terrors.New(\"unknown field in manifest: version\"),\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid metadata format\",\n\t\t\ttomlString: `\n\t\t\tmetadata = \"project-name\"\n\n\t\t\t[[constraint]]\n\t\t\t  name = \"github.com/foo/bar\"\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrInvalidMetadata,\n\t\t\t\terrors.New(\"branch, version, revision, or source should be provided for \\\"github.com/foo/bar\\\"\"),\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"plain constraint\",\n\t\t\ttomlString: `\n\t\t\t[[constraint]]\n\t\t\t  name = \"github.com/foo/bar\"\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrors.New(\"branch, version, revision, or source should be provided for \\\"github.com/foo/bar\\\"\"),\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"empty constraint\",\n\t\t\ttomlString: `\n\t\t\t[[constraint]]\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrNoName,\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid constraint\",\n\t\t\ttomlString: `\n\t\t\tconstraint = \"foo\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidConstraint,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid constraint list\",\n\t\t\ttomlString: `\n\t\t\tconstraint = [\"foo\", \"bar\"]\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidConstraint,\n\t\t},\n\t\t{\n\t\t\tname: \"valid override\",\n\t\t\ttomlString: `\n\t\t\t[[override]]\n\t\t\t  name = \"github.com/foo/bar\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"empty override\",\n\t\t\ttomlString: `\n\t\t\t[[override]]\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrNoName,\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid override\",\n\t\t\ttomlString: `\n\t\t\toverride = \"bar\"\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidOverride,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid override list\",\n\t\t\ttomlString: `\n\t\t\toverride = [\"foo\", \"bar\"]\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidOverride,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid fields\",\n\t\t\ttomlString: `\n\t\t\t[[constraint]]\n\t\t\t  name = \"github.com/foo/bar\"\n\t\t\t  location = \"some-value\"\n\t\t\t  link = \"some-other-value\"\n\t\t\t  metadata = \"foo\"\n\n\t\t\t[[override]]\n\t\t\t  nick = \"foo\"\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrors.New(\"invalid key \\\"location\\\" in \\\"constraint\\\"\"),\n\t\t\t\terrors.New(\"invalid key \\\"link\\\" in \\\"constraint\\\"\"),\n\t\t\t\terrors.New(\"metadata in \\\"constraint\\\" should be a TOML table\"),\n\t\t\t\terrors.New(\"branch, version, revision, or source should be provided for \\\"github.com/foo/bar\\\"\"),\n\t\t\t\terrors.New(\"invalid key \\\"nick\\\" in \\\"override\\\"\"),\n\t\t\t\terrNoName,\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"constraint metadata\",\n\t\t\ttomlString: `\n\t\t\t[[constraint]]\n\t\t\t  name = \"github.com/foo/bar\"\n\n\t\t\t  [constraint.metadata]\n\t\t\t    color = \"blue\"\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrors.New(\"branch, version, revision, or source should be provided for \\\"github.com/foo/bar\\\"\"),\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid revision\",\n\t\t\ttomlString: `\n\t\t\t[[constraint]]\n\t\t\t  name = \"github.com/foo/bar\"\n\t\t\t  revision = \"b86ad16\"\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrors.New(\"revision \\\"b86ad16\\\" should not be in abbreviated form\"),\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid hg revision\",\n\t\t\ttomlString: `\n\t\t\t[[constraint]]\n\t\t\t  name = \"foobar.com/hg\"\n\t\t\t  revision = \"8d43f8c0b836\"\n\t\t\t`,\n\t\t\twantWarn:  []error{errors.New(\"revision \\\"8d43f8c0b836\\\" should not be in abbreviated form\")},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"valid prune options\",\n\t\t\ttomlString: `\n\t\t\t[prune]\n\t\t\t  non-go = true\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid root prune options\",\n\t\t\ttomlString: `\n\t\t\t[prune]\n\t\t\t  non-go = false\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidRootPruneValue,\n\t\t},\n\t\t{\n\t\t\tname: \"root options should not contain a name\",\n\t\t\ttomlString: `\n\t\t\t[prune]\n\t\t\t  go-tests = true\n\t\t\t  name = \"github.com/golang/dep\"\n\t\t\t`,\n\t\t\twantWarn: []error{\n\t\t\t\terrRootPruneContainsName,\n\t\t\t},\n\t\t\twantError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"invalid prune project\",\n\t\t\ttomlString: `\n\t\t\t[prune]\n\t\t\t  non-go = true\n\n\t\t\t  [prune.project]\n\t\t\t    name = \"github.com/org/project\"\n\t\t\t    non-go = true\n\t\t\t`,\n\t\t\twantWarn:  []error{},\n\t\t\twantError: errInvalidPruneProject,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\terrs, err := validateManifest(c.tomlString)\n\n\t\t\t// compare validation errors\n\t\t\tif err != c.wantError {\n\t\t\t\tt.Fatalf(\"manifest errors are not as expected: \\n\\t(GOT) %v \\n\\t(WNT) %v\", err, c.wantError)\n\t\t\t}\n\n\t\t\t// compare length of error slice\n\t\t\tif len(errs) != len(c.wantWarn) {\n\t\t\t\tt.Fatalf(\"number of manifest errors are not as expected: \\n\\t(GOT) %v errors(%v)\\n\\t(WNT) %v errors(%v).\", len(errs), errs, len(c.wantWarn), c.wantWarn)\n\t\t\t}\n\n\t\t\t// check if the expected errors exist in actual errors slice\n\t\t\tfor _, er := range errs {\n\t\t\t\tif !containsErr(c.wantWarn, er) {\n\t\t\t\t\tt.Fatalf(\"manifest errors are not as expected: \\n\\t(MISSING) %v\\n\\t(FROM) %v\", er, c.wantWarn)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCheckRedundantPruneOptions(t *testing.T) {\n\tcases := []struct {\n\t\tname         string\n\t\tpruneOptions gps.CascadingPruneOptions\n\t\twantWarn     []error\n\t}{\n\t\t{\n\t\t\tname: \"all redundant on true\",\n\t\t\tpruneOptions: gps.CascadingPruneOptions{\n\t\t\t\tDefaultOptions: 15,\n\t\t\t\tPerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{\n\t\t\t\t\t\"github.com/golang/dep\": {\n\t\t\t\t\t\tNestedVendor:   pvtrue,\n\t\t\t\t\t\tUnusedPackages: pvtrue,\n\t\t\t\t\t\tNonGoFiles:     pvtrue,\n\t\t\t\t\t\tGoTests:        pvtrue,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantWarn: []error{\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"unused-packages\", \"github.com/golang/dep\"),\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"non-go\", \"github.com/golang/dep\"),\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"go-tests\", \"github.com/golang/dep\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"all redundant on false\",\n\t\t\tpruneOptions: gps.CascadingPruneOptions{\n\t\t\t\tDefaultOptions: 1,\n\t\t\t\tPerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{\n\t\t\t\t\t\"github.com/golang/dep\": {\n\t\t\t\t\t\tNestedVendor:   pvtrue,\n\t\t\t\t\t\tUnusedPackages: pvfalse,\n\t\t\t\t\t\tNonGoFiles:     pvfalse,\n\t\t\t\t\t\tGoTests:        pvfalse,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantWarn: []error{\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"unused-packages\", \"github.com/golang/dep\"),\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"non-go\", \"github.com/golang/dep\"),\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"go-tests\", \"github.com/golang/dep\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"redundancy mix across multiple projects\",\n\t\t\tpruneOptions: gps.CascadingPruneOptions{\n\t\t\t\tDefaultOptions: 7,\n\t\t\t\tPerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{\n\t\t\t\t\t\"github.com/golang/dep\": {\n\t\t\t\t\t\tNestedVendor: pvtrue,\n\t\t\t\t\t\tNonGoFiles:   pvtrue,\n\t\t\t\t\t\tGoTests:      pvtrue,\n\t\t\t\t\t},\n\t\t\t\t\t\"github.com/other/project\": {\n\t\t\t\t\t\tNestedVendor:   pvtrue,\n\t\t\t\t\t\tUnusedPackages: pvfalse,\n\t\t\t\t\t\tGoTests:        pvfalse,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantWarn: []error{\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"non-go\", \"github.com/golang/dep\"),\n\t\t\t\tfmt.Errorf(\"redundant prune option %q set for %q\", \"go-tests\", \"github.com/other/project\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\terrs := checkRedundantPruneOptions(c.pruneOptions)\n\n\t\t\t// compare length of error slice\n\t\t\tif len(errs) != len(c.wantWarn) {\n\t\t\t\tt.Fatalf(\"number of manifest errors are not as expected:\\n\\t(GOT) %v errors(%v)\\n\\t(WNT) %v errors(%v).\", len(errs), errs, len(c.wantWarn), c.wantWarn)\n\t\t\t}\n\n\t\t\tfor _, er := range errs {\n\t\t\t\tif !containsErr(c.wantWarn, er) {\n\t\t\t\t\tt.Fatalf(\"manifest errors are not as expected:\\n\\t(MISSING)\\n%v\\n\\t(FROM)\\n%v\", er, c.wantWarn)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateProjectRoots(t *testing.T) {\n\tcases := []struct {\n\t\tname      string\n\t\tmanifest  Manifest\n\t\twantError error\n\t\twantWarn  []string\n\t}{\n\t\t{\n\t\t\tname:      \"empty Manifest\",\n\t\t\tmanifest:  Manifest{},\n\t\t\twantError: nil,\n\t\t\twantWarn:  []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"valid project root\",\n\t\t\tmanifest: Manifest{\n\t\t\t\tConstraints: map[gps.ProjectRoot]gps.ProjectProperties{\n\t\t\t\t\tgps.ProjectRoot(\"github.com/golang/dep\"): {\n\t\t\t\t\t\tConstraint: gps.Any(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantError: nil,\n\t\t\twantWarn:  []string{},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid project roots in Constraints and Overrides\",\n\t\t\tmanifest: Manifest{\n\t\t\t\tConstraints: map[gps.ProjectRoot]gps.ProjectProperties{\n\t\t\t\t\tgps.ProjectRoot(\"github.com/golang/dep/foo\"): {\n\t\t\t\t\t\tConstraint: gps.Any(),\n\t\t\t\t\t},\n\t\t\t\t\tgps.ProjectRoot(\"github.com/golang/go/xyz\"): {\n\t\t\t\t\t\tConstraint: gps.Any(),\n\t\t\t\t\t},\n\t\t\t\t\tgps.ProjectRoot(\"github.com/golang/fmt\"): {\n\t\t\t\t\t\tConstraint: gps.Any(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tOvr: map[gps.ProjectRoot]gps.ProjectProperties{\n\t\t\t\t\tgps.ProjectRoot(\"github.com/golang/mock/bar\"): {\n\t\t\t\t\t\tConstraint: gps.Any(),\n\t\t\t\t\t},\n\t\t\t\t\tgps.ProjectRoot(\"github.com/golang/mock\"): {\n\t\t\t\t\t\tConstraint: gps.Any(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantError: errInvalidProjectRoot,\n\t\t\twantWarn: []string{\n\t\t\t\t\"the name for \\\"github.com/golang/dep/foo\\\" should be changed to \\\"github.com/golang/dep\\\"\",\n\t\t\t\t\"the name for \\\"github.com/golang/mock/bar\\\" should be changed to \\\"github.com/golang/mock\\\"\",\n\t\t\t\t\"the name for \\\"github.com/golang/go/xyz\\\" should be changed to \\\"github.com/golang/go\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"invalid source path\",\n\t\t\tmanifest: Manifest{\n\t\t\t\tConstraints: map[gps.ProjectRoot]gps.ProjectProperties{\n\t\t\t\t\tgps.ProjectRoot(\"github.com/golang\"): {\n\t\t\t\t\t\tConstraint: gps.Any(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantError: errInvalidProjectRoot,\n\t\t\twantWarn:  []string{},\n\t\t},\n\t}\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\th.TempDir(\"src\")\n\tpwd := h.Path(\".\")\n\n\t// Capture the stderr to verify the warnings\n\tstderrOutput := &bytes.Buffer{}\n\terrLogger := log.New(stderrOutput, \"\", 0)\n\tctx := &Ctx{\n\t\tGOPATH: pwd,\n\t\tOut:    log.New(ioutil.Discard, \"\", 0),\n\t\tErr:    errLogger,\n\t}\n\n\tsm, err := ctx.SourceManager()\n\th.Must(err)\n\tdefer sm.Release()\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\t// Empty the buffer for every case\n\t\t\tstderrOutput.Reset()\n\t\t\terr := ValidateProjectRoots(ctx, &c.manifest, sm)\n\t\t\tif err != c.wantError {\n\t\t\t\tt.Fatalf(\"unexpected error while validating project roots:\\n\\t(GOT): %v\\n\\t(WNT): %v\", err, c.wantError)\n\t\t\t}\n\n\t\t\twarnings := stderrOutput.String()\n\t\t\tfor _, warn := range c.wantWarn {\n\t\t\t\tif !strings.Contains(warnings, warn) {\n\t\t\t\t\tt.Fatalf(\"expected ValidateProjectRoot errors to contain: %q\", warn)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n//func TestFromRawPruneOptions(t *testing.T) {\n//cases := []struct {\n//name            string\n//rawPruneOptions rawPruneOptions\n//wantOptions     gps.CascadingPruneOptions\n//}{\n//{\n//name: \"global all options project no options\",\n//rawPruneOptions: rawPruneOptions{\n//UnusedPackages: true,\n//NonGoFiles:     true,\n//GoTests:        true,\n//Projects: []map[string]interface{}{\n//{\n//\"name\": \"github.com/golang/dep\",\n//pruneOptionUnusedPackages: false,\n//pruneOptionNonGo:          false,\n//pruneOptionGoTests:        false,\n//},\n//},\n//},\n//wantOptions: gps.CascadingPruneOptions{\n//DefaultOptions: 15,\n//PerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{\n//\"github.com/golang/dep\": gps.PruneOptionSet{\n//NestedVendor:   pvtrue,\n//UnusedPackages: pvfalse,\n//NonGoFiles:     pvfalse,\n//GoTests:        pvfalse,\n//},\n//},\n//},\n//},\n//{\n//name: \"global all options project mixed options\",\n//rawPruneOptions: rawPruneOptions{\n//UnusedPackages: true,\n//NonGoFiles:     true,\n//GoTests:        true,\n//Projects: []map[string]interface{}{\n//{\n//\"name\": \"github.com/golang/dep\",\n//pruneOptionUnusedPackages: false,\n//},\n//},\n//},\n//wantOptions: gps.CascadingPruneOptions{\n//DefaultOptions: 15,\n//PerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{\n//\"github.com/golang/dep\": gps.PruneOptionSet{\n//NestedVendor:   pvtrue,\n//UnusedPackages: pvfalse,\n//},\n//},\n//},\n//},\n//{\n//name: \"global no options project all options\",\n//rawPruneOptions: rawPruneOptions{\n//UnusedPackages: false,\n//NonGoFiles:     false,\n//GoTests:        false,\n//Projects: []map[string]interface{}{\n//{\n//\"name\": \"github.com/golang/dep\",\n//pruneOptionUnusedPackages: true,\n//pruneOptionNonGo:          true,\n//pruneOptionGoTests:        true,\n//},\n//},\n//},\n//wantOptions: gps.CascadingPruneOptions{\n//DefaultOptions: 1,\n//PerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{\n//\"github.com/golang/dep\": gps.PruneOptionSet{\n//NestedVendor:   pvtrue,\n//UnusedPackages: pvtrue,\n//NonGoFiles:     pvtrue,\n//GoTests:        pvtrue,\n//},\n//},\n//},\n//},\n//}\n\n//for _, c := range cases {\n//t.Run(c.name, func(t *testing.T) {\n//opts, err := fromRawPruneOptions(c.rawPruneOptions)\n//if err != nil {\n//t.Fatal(err)\n//}\n\n//if !reflect.DeepEqual(opts, c.wantOptions) {\n//t.Fatalf(\"rawPruneOptions are not as expected:\\n\\t(GOT) %v\\n\\t(WNT) %v\", opts, c.wantOptions)\n//}\n//})\n//}\n//}\n\nfunc TestToRawPruneOptions(t *testing.T) {\n\tcases := []struct {\n\t\tname         string\n\t\tpruneOptions gps.CascadingPruneOptions\n\t\twantOptions  rawPruneOptions\n\t}{\n\t\t{\n\t\t\tname:         \"all options\",\n\t\t\tpruneOptions: gps.CascadingPruneOptions{DefaultOptions: 15},\n\t\t\twantOptions: rawPruneOptions{\n\t\t\t\tUnusedPackages: true,\n\t\t\t\tNonGoFiles:     true,\n\t\t\t\tGoTests:        true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:         \"no options\",\n\t\t\tpruneOptions: gps.CascadingPruneOptions{DefaultOptions: 1},\n\t\t\twantOptions: rawPruneOptions{\n\t\t\t\tUnusedPackages: false,\n\t\t\t\tNonGoFiles:     false,\n\t\t\t\tGoTests:        false,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.name, func(t *testing.T) {\n\t\t\traw := toRawPruneOptions(c.pruneOptions)\n\n\t\t\tif !reflect.DeepEqual(raw, c.wantOptions) {\n\t\t\t\tt.Fatalf(\"rawPruneOptions are not as expected:\\n\\t(GOT) %v\\n\\t(WNT) %v\", raw, c.wantOptions)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestToRawPruneOptions_Panic(t *testing.T) {\n\tpruneOptions := gps.CascadingPruneOptions{\n\t\tDefaultOptions: 1,\n\t\tPerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{\n\t\t\t\"github.com/carolynvs/deptest\": {\n\t\t\t\tNestedVendor: pvtrue,\n\t\t\t},\n\t\t},\n\t}\n\tdefer func() {\n\t\tif err := recover(); err == nil {\n\t\t\tt.Error(\"toRawPruneOptions did not panic with non-empty ProjectOptions\")\n\t\t}\n\t}()\n\t_ = toRawPruneOptions(pruneOptions)\n}\n\nfunc containsErr(s []error, e error) bool {\n\tfor _, a := range s {\n\t\tif a.Error() == e.Error() {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
        },
        {
          "name": "project.go",
          "type": "blob",
          "size": 9.6025390625,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"sync\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/gps/pkgtree\"\n\t\"github.com/golang/dep/gps/verify\"\n\t\"github.com/golang/dep/internal/fs\"\n\t\"github.com/pkg/errors\"\n)\n\nvar (\n\terrProjectNotFound    = fmt.Errorf(\"could not find project %s, use dep init to initiate a manifest\", ManifestName)\n\terrVendorBackupFailed = fmt.Errorf(\"failed to create vendor backup. File with same name exists\")\n)\n\n// findProjectRoot searches from the starting directory upwards looking for a\n// manifest file until we get to the root of the filesystem.\nfunc findProjectRoot(from string) (string, error) {\n\tfor {\n\t\tmp := filepath.Join(from, ManifestName)\n\n\t\t_, err := os.Stat(mp)\n\t\tif err == nil {\n\t\t\treturn from, nil\n\t\t}\n\t\tif !os.IsNotExist(err) {\n\t\t\t// Some err other than non-existence - return that out\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tparent := filepath.Dir(from)\n\t\tif parent == from {\n\t\t\treturn \"\", errProjectNotFound\n\t\t}\n\t\tfrom = parent\n\t}\n}\n\n// checkGopkgFilenames validates filename case for the manifest and lock files.\n//\n// This is relevant on case-insensitive file systems like the defaults in Windows and\n// macOS.\n//\n// If manifest file is not found, it returns an error indicating the project could not be\n// found. If it is found but the case does not match, an error is returned. If a lock\n// file is not found, no error is returned as lock file is optional. If it is found but\n// the case does not match, an error is returned.\nfunc checkGopkgFilenames(projectRoot string) error {\n\t// ReadActualFilenames is actually costly. Since the check to validate filename case\n\t// for Gopkg filenames is not relevant to case-sensitive filesystems like\n\t// ext4(linux), try for an early return.\n\tcaseSensitive, err := fs.IsCaseSensitiveFilesystem(projectRoot)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"could not check validity of configuration filenames\")\n\t}\n\tif caseSensitive {\n\t\treturn nil\n\t}\n\n\tactualFilenames, err := fs.ReadActualFilenames(projectRoot, []string{ManifestName, LockName})\n\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"could not check validity of configuration filenames\")\n\t}\n\n\tactualMfName, found := actualFilenames[ManifestName]\n\tif !found {\n\t\t// Ideally this part of the code won't ever be executed if it is called after\n\t\t// `findProjectRoot`. But be thorough and handle it anyway.\n\t\treturn errProjectNotFound\n\t}\n\tif actualMfName != ManifestName {\n\t\treturn fmt.Errorf(\"manifest filename %q does not match %q\", actualMfName, ManifestName)\n\t}\n\n\t// If a file is not found, the string map returned by `fs.ReadActualFilenames` will\n\t// not have an entry for the given filename. Since the lock file is optional, we\n\t// should check for equality only if it was found.\n\tactualLfName, found := actualFilenames[LockName]\n\tif found && actualLfName != LockName {\n\t\treturn fmt.Errorf(\"lock filename %q does not match %q\", actualLfName, LockName)\n\t}\n\n\treturn nil\n}\n\n// A Project holds a Manifest and optional Lock for a project.\ntype Project struct {\n\t// AbsRoot is the absolute path to the root directory of the project.\n\tAbsRoot string\n\t// ResolvedAbsRoot is the resolved absolute path to the root directory of the project.\n\t// If AbsRoot is not a symlink, then ResolvedAbsRoot should equal AbsRoot.\n\tResolvedAbsRoot string\n\t// ImportRoot is the import path of the project's root directory.\n\tImportRoot gps.ProjectRoot\n\t// The Manifest, as read from Gopkg.toml on disk.\n\tManifest *Manifest\n\t// The Lock, as read from Gopkg.lock on disk.\n\tLock *Lock // Optional\n\t// The above Lock, with changes applied to it. There are two possible classes of\n\t// changes:\n\t//  1. Changes to InputImports\n\t//  2. Changes to per-project prune options\n\tChangedLock *Lock\n\t// The PackageTree representing the project, with hidden and ignored\n\t// packages already trimmed.\n\tRootPackageTree pkgtree.PackageTree\n\t// Oncer to manage access to initial check of vendor.\n\tCheckVendor sync.Once\n\t// The result of calling verify.CheckDepTree against the current lock and\n\t// vendor dir.\n\tVendorStatus map[string]verify.VendorStatus\n\t// The error, if any, from checking vendor.\n\tCheckVendorErr error\n}\n\n// VerifyVendor checks the vendor directory against the hash digests in\n// Gopkg.lock.\n//\n// This operation is overseen by the sync.Once in CheckVendor. This is intended\n// to facilitate running verification in the background while solving, then\n// having the results ready later.\nfunc (p *Project) VerifyVendor() (map[string]verify.VendorStatus, error) {\n\tp.CheckVendor.Do(func() {\n\t\tp.VendorStatus = make(map[string]verify.VendorStatus)\n\t\tvendorDir := filepath.Join(p.AbsRoot, \"vendor\")\n\n\t\tvar lps []gps.LockedProject\n\t\tif p.Lock != nil {\n\t\t\tlps = p.Lock.Projects()\n\t\t}\n\n\t\tsums := make(map[string]verify.VersionedDigest)\n\t\tfor _, lp := range lps {\n\t\t\tsums[string(lp.Ident().ProjectRoot)] = lp.(verify.VerifiableProject).Digest\n\t\t}\n\n\t\tp.VendorStatus, p.CheckVendorErr = verify.CheckDepTree(vendorDir, sums)\n\t})\n\n\treturn p.VendorStatus, p.CheckVendorErr\n}\n\n// SetRoot sets the project AbsRoot and ResolvedAbsRoot. If root is not a symlink, ResolvedAbsRoot will be set to root.\nfunc (p *Project) SetRoot(root string) error {\n\trroot, err := filepath.EvalSymlinks(root)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.ResolvedAbsRoot, p.AbsRoot = rroot, root\n\treturn nil\n}\n\n// MakeParams is a simple helper to create a gps.SolveParameters without setting\n// any nils incorrectly.\nfunc (p *Project) MakeParams() gps.SolveParameters {\n\tparams := gps.SolveParameters{\n\t\tRootDir:         p.AbsRoot,\n\t\tProjectAnalyzer: Analyzer{},\n\t\tRootPackageTree: p.RootPackageTree,\n\t}\n\n\tif p.Manifest != nil {\n\t\tparams.Manifest = p.Manifest\n\t}\n\n\t// It should be impossible for p.ChangedLock to be nil if p.Lock is non-nil;\n\t// we always want to use the former for solving.\n\tif p.ChangedLock != nil {\n\t\tparams.Lock = p.ChangedLock\n\t}\n\n\treturn params\n}\n\n// parseRootPackageTree analyzes the root project's disk contents to create a\n// PackageTree, trimming out packages that are not relevant for root projects\n// along the way.\n//\n// The resulting tree is cached internally at p.RootPackageTree.\nfunc (p *Project) parseRootPackageTree() (pkgtree.PackageTree, error) {\n\tif p.RootPackageTree.Packages == nil {\n\t\tptree, err := pkgtree.ListPackages(p.ResolvedAbsRoot, string(p.ImportRoot))\n\t\tif err != nil {\n\t\t\treturn pkgtree.PackageTree{}, errors.Wrap(err, \"analysis of current project's packages failed\")\n\t\t}\n\t\t// We don't care about (unreachable) hidden packages for the root project,\n\t\t// so drop all of those.\n\t\tvar ig *pkgtree.IgnoredRuleset\n\t\tif p.Manifest != nil {\n\t\t\tig = p.Manifest.IgnoredPackages()\n\t\t}\n\t\tp.RootPackageTree = ptree.TrimHiddenPackages(true, true, ig)\n\t}\n\treturn p.RootPackageTree, nil\n}\n\n// GetDirectDependencyNames returns the set of unique Project Roots that are the\n// direct dependencies of this Project.\n//\n// A project is considered a direct dependency if at least one of its packages\n// is named in either this Project's required list, or if there is at least one\n// non-ignored import statement from a non-ignored package in the current\n// project's package tree.\n//\n// The returned map of Project Roots contains only boolean true values; this\n// makes a \"false\" value always indicate an absent key, which makes conditional\n// checks against the map more ergonomic.\n//\n// This function will correctly utilize ignores and requireds from an existing\n// manifest, if one is present, but will also do the right thing without a\n// manifest.\nfunc (p *Project) GetDirectDependencyNames(sm gps.SourceManager) (map[gps.ProjectRoot]bool, error) {\n\tvar reach []string\n\tif p.ChangedLock != nil {\n\t\treach = p.ChangedLock.InputImports()\n\t} else {\n\t\tptree, err := p.parseRootPackageTree()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treach = externalImportList(ptree, p.Manifest)\n\t}\n\n\tdirectDeps := map[gps.ProjectRoot]bool{}\n\tfor _, ip := range reach {\n\t\tpr, err := sm.DeduceProjectRoot(ip)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdirectDeps[pr] = true\n\t}\n\n\treturn directDeps, nil\n}\n\n// FindIneffectualConstraints looks for constraint rules expressed in the\n// manifest that will have no effect during solving, as they are specified for\n// projects that are not direct dependencies of the Project.\n//\n// \"Direct dependency\" here is as implemented by GetDirectDependencyNames();\n// it correctly incorporates all \"ignored\" and \"required\" rules.\nfunc (p *Project) FindIneffectualConstraints(sm gps.SourceManager) []gps.ProjectRoot {\n\tif p.Manifest == nil {\n\t\treturn nil\n\t}\n\n\tdd, err := p.GetDirectDependencyNames(sm)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tvar ineff []gps.ProjectRoot\n\tfor pr := range p.Manifest.DependencyConstraints() {\n\t\tif !dd[pr] {\n\t\t\tineff = append(ineff, pr)\n\t\t}\n\t}\n\n\tsort.Slice(ineff, func(i, j int) bool {\n\t\treturn ineff[i] < ineff[j]\n\t})\n\treturn ineff\n}\n\n// BackupVendor looks for existing vendor directory and if it's not empty,\n// creates a backup of it to a new directory with the provided suffix.\nfunc BackupVendor(vpath, suffix string) (string, error) {\n\t// Check if there's a non-empty vendor directory\n\tvendorExists, err := fs.IsNonEmptyDir(vpath)\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn \"\", err\n\t}\n\tif vendorExists {\n\t\t// vpath is a full filepath. We need to split it to prefix the backup dir\n\t\t// with an \"_\"\n\t\tvpathDir, name := filepath.Split(vpath)\n\t\tvendorbak := filepath.Join(vpathDir, \"_\"+name+\"-\"+suffix)\n\t\t// Check if a directory with same name exists\n\t\tif _, err = os.Stat(vendorbak); os.IsNotExist(err) {\n\t\t\t// Copy existing vendor to vendor-{suffix}\n\t\t\tif err := fs.CopyDir(vpath, vendorbak); err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\treturn vendorbak, nil\n\t\t}\n\t\treturn \"\", errVendorBackupFailed\n\t}\n\n\treturn \"\", nil\n}\n"
        },
        {
          "name": "project_test.go",
          "type": "blob",
          "size": 6.5625,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/internal/test\"\n)\n\nfunc TestFindRoot(t *testing.T) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := filepath.Join(wd, \"testdata\", \"rootfind\")\n\tgot1, err := findProjectRoot(want)\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error while finding root: %s\", err)\n\t} else if want != got1 {\n\t\tt.Errorf(\"findProjectRoot directly on root dir should have found %s, got %s\", want, got1)\n\t}\n\n\tgot2, err := findProjectRoot(filepath.Join(want, \"subdir\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error while finding root: %s\", err)\n\t} else if want != got2 {\n\t\tt.Errorf(\"findProjectRoot on subdir should have found %s, got %s\", want, got2)\n\t}\n\n\tgot3, err := findProjectRoot(filepath.Join(want, \"nonexistent\"))\n\tif err != nil {\n\t\tt.Errorf(\"Unexpected error while finding root: %s\", err)\n\t} else if want != got3 {\n\t\tt.Errorf(\"findProjectRoot on nonexistent subdir should still work and give %s, got %s\", want, got3)\n\t}\n\n\troot := \"/\"\n\tp, err := findProjectRoot(root)\n\tif p != \"\" {\n\t\tt.Errorf(\"findProjectRoot with path %s returned non empty string: %s\", root, p)\n\t}\n\tif err != errProjectNotFound {\n\t\tt.Errorf(\"findProjectRoot want: %#v got: %#v\", errProjectNotFound, err)\n\t}\n\n\t// The following test does not work on windows because syscall.Stat does not\n\t// return a \"not a directory\" error.\n\tif runtime.GOOS != \"windows\" {\n\t\tgot4, err := findProjectRoot(filepath.Join(want, ManifestName))\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Should have err'd when trying subdir of file, but returned %s\", got4)\n\t\t}\n\t}\n}\n\nfunc TestCheckGopkgFilenames(t *testing.T) {\n\t// We are trying to skip this test on file systems which are case-sensiive. We could\n\t// have used `fs.IsCaseSensitiveFilesystem` for this check. However, the code we are\n\t// testing also relies on `fs.IsCaseSensitiveFilesystem`. So a bug in\n\t// `fs.IsCaseSensitiveFilesystem` could prevent this test from being run. This is the\n\t// only scenario where we prefer the OS heuristic over doing the actual work of\n\t// validating filesystem case sensitivity via `fs.IsCaseSensitiveFilesystem`.\n\tif runtime.GOOS != \"windows\" && runtime.GOOS != \"darwin\" {\n\t\tt.Skip(\"skip this test on non-Windows, non-macOS\")\n\t}\n\n\terrMsgFor := func(filetype, filename string) func(string) string {\n\t\treturn func(name string) string {\n\t\t\treturn fmt.Sprintf(\"%s filename %q does not match %q\", filetype, name, filename)\n\t\t}\n\t}\n\n\tmanifestErrMsg := errMsgFor(\"manifest\", ManifestName)\n\tlockErrMsg := errMsgFor(\"lock\", LockName)\n\n\tinvalidMfName := strings.ToLower(ManifestName)\n\tinvalidLfName := strings.ToLower(LockName)\n\n\tcases := []struct {\n\t\twantErr     bool\n\t\tcreateFiles []string\n\t\twantErrMsg  string\n\t}{\n\t\t// No error should be returned when the project contains a valid manifest file\n\t\t// but no lock file.\n\t\t{false, []string{ManifestName}, \"\"},\n\t\t// No error should be returned when the project contains a valid manifest file as\n\t\t// well as a valid lock file.\n\t\t{false, []string{ManifestName, LockName}, \"\"},\n\t\t// Error indicating the project was not found should be returned if a manifest\n\t\t// file is not found.\n\t\t{true, nil, errProjectNotFound.Error()},\n\t\t// Error should be returned if the project has a manifest file with invalid name\n\t\t// but no lock file.\n\t\t{true, []string{invalidMfName}, manifestErrMsg(invalidMfName)},\n\t\t// Error should be returned if the project has a valid manifest file and an\n\t\t// invalid lock file.\n\t\t{true, []string{ManifestName, invalidLfName}, lockErrMsg(invalidLfName)},\n\t}\n\n\tfor _, c := range cases {\n\t\th := test.NewHelper(t)\n\t\tdefer h.Cleanup()\n\n\t\t// Create a temporary directory which we will use as the project folder.\n\t\th.TempDir(\"\")\n\t\ttmpPath := h.Path(\".\")\n\n\t\t// Create any files that are needed for the test before invoking\n\t\t// `checkGopkgFilenames`.\n\t\tfor _, file := range c.createFiles {\n\t\t\th.TempFile(file, \"\")\n\t\t}\n\t\terr := checkGopkgFilenames(tmpPath)\n\n\t\tif c.wantErr {\n\t\t\tif err == nil {\n\t\t\t\t// We were expecting an error but did not get one.\n\t\t\t\tt.Fatalf(\"unexpected error message: \\n\\t(GOT) nil\\n\\t(WNT) %s\", c.wantErrMsg)\n\t\t\t} else if err.Error() != c.wantErrMsg {\n\t\t\t\t// We got an error but it is not the one we were expecting.\n\t\t\t\tt.Fatalf(\"unexpected error message: \\n\\t(GOT) %s\\n\\t(WNT) %s\", err.Error(), c.wantErrMsg)\n\t\t\t}\n\t\t} else if err != nil {\n\t\t\t// Error was not expected but still we got one\n\t\t\tt.Fatalf(\"unexpected error message: \\n\\t(GOT) %+v\", err)\n\t\t}\n\t}\n}\n\nfunc TestProjectMakeParams(t *testing.T) {\n\tm := NewManifest()\n\tm.Ignored = []string{\"ignoring this\"}\n\n\tp := Project{\n\t\tAbsRoot:    \"someroot\",\n\t\tImportRoot: gps.ProjectRoot(\"Some project root\"),\n\t\tManifest:   m,\n\t\tLock:       &Lock{},\n\t}\n\tp.ChangedLock = p.Lock\n\n\tsolveParam := p.MakeParams()\n\n\tif solveParam.Manifest != p.Manifest {\n\t\tt.Error(\"makeParams() returned gps.SolveParameters with incorrect Manifest\")\n\t}\n\n\tif solveParam.Lock != p.Lock {\n\t\tt.Error(\"makeParams() returned gps.SolveParameters with incorrect Lock\")\n\t}\n}\n\nfunc TestBackupVendor(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, \"vendorbackupproject\")\n\tdefer pc.Release()\n\n\tdummyFile := filepath.Join(\"vendor\", \"badinput_fileroot\")\n\tpc.CopyFile(dummyFile, \"txn_writer/badinput_fileroot\")\n\tpc.Load()\n\n\tif err := pc.VendorShouldExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Create a backup\n\twantName := \"_vendor-sfx\"\n\tvendorbak, err := BackupVendor(\"vendor\", \"sfx\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif vendorbak != wantName {\n\t\tt.Fatalf(\"Vendor backup name is not as expected: \\n\\t(GOT) %v\\n\\t(WNT) %v\", vendorbak, wantName)\n\t}\n\n\tif err = pc.h.ShouldExist(vendorbak); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err = pc.h.ShouldExist(vendorbak + string(filepath.Separator) + \"badinput_fileroot\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Should return error on creating backup with existing filename\n\tvendorbak, err = BackupVendor(\"vendor\", \"sfx\")\n\n\tif err != errVendorBackupFailed {\n\t\tt.Fatalf(\"Vendor backup error is not as expected: \\n\\t(GOT) %v\\n\\t(WNT) %v\", err, errVendorBackupFailed)\n\t}\n\n\tif vendorbak != \"\" {\n\t\tt.Fatalf(\"Vendor backup name is not as expected: \\n\\t(GOT) %v\\n\\t(WNT) %v\", vendorbak, \"\")\n\t}\n\n\t// Delete vendor\n\tif err = os.RemoveAll(\"vendor\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Should return empty backup file name when no vendor exists\n\tvendorbak, err = BackupVendor(\"vendor\", \"sfx\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif vendorbak != \"\" {\n\t\tt.Fatalf(\"Vendor backup name is not as expected: \\n\\t(GOT) %v\\n\\t(WNT) %v\", vendorbak, \"\")\n\t}\n}\n"
        },
        {
          "name": "test_project_context_test.go",
          "type": "blob",
          "size": 5.6201171875,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"path/filepath\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/internal/test\"\n\t\"github.com/pkg/errors\"\n)\n\n// TestProjectContext groups together test project files and helps test them\ntype TestProjectContext struct {\n\th              *test.Helper\n\ttempDir        string // Full path to the temp directory\n\ttempProjectDir string // Relative path of the project under the temp directory\n\n\tContext       *Ctx\n\tProject       *Project\n\tSourceManager gps.SourceManager\n}\n\n// NewTestProjectContext creates a new on-disk test project\nfunc NewTestProjectContext(h *test.Helper, projectName string) *TestProjectContext {\n\tpc := &TestProjectContext{h: h}\n\n\t// Create the test project directory\n\tpc.tempProjectDir = filepath.Join(\"src\", projectName)\n\th.TempDir(pc.tempProjectDir)\n\tpc.tempDir = h.Path(\".\")\n\tpc.Project = &Project{AbsRoot: filepath.Join(pc.tempDir, pc.tempProjectDir)}\n\th.Cd(pc.Project.AbsRoot)\n\th.Setenv(\"GOPATH\", pc.tempDir)\n\n\t// Set up a Source Manager\n\tvar err error\n\tpc.Context = &Ctx{\n\t\tGOPATH: pc.tempDir,\n\t\tOut:    discardLogger(),\n\t\tErr:    discardLogger(),\n\t}\n\tpc.SourceManager, err = pc.Context.SourceManager()\n\th.Must(errors.Wrap(err, \"Unable to create a SourceManager\"))\n\n\treturn pc\n}\n\n// CopyFile copies a file from the testdata directory into the project\n// projectPath is the destination file path, relative to the project directory\n// testdataPath is the source path, relative to the testdata directory\nfunc (pc *TestProjectContext) CopyFile(projectPath string, testdataPath string) string {\n\tpath := filepath.Join(pc.tempProjectDir, projectPath)\n\tpc.h.TempCopy(path, testdataPath)\n\treturn path\n}\n\nfunc (pc *TestProjectContext) Load() {\n\t// TODO(carolynvs): Can't use Ctx.LoadProject until dep doesn't require a manifest at the project root or it also looks for lock\n\tvar err error\n\tvar m *Manifest\n\tmp := pc.getManifestPath()\n\tif pc.h.Exist(mp) {\n\t\tmf := pc.h.GetFile(mp)\n\t\tdefer mf.Close()\n\t\tvar warns []error\n\t\tm, warns, err = readManifest(mf)\n\t\tfor _, warn := range warns {\n\t\t\tpc.Context.Err.Printf(\"dep: WARNING: %v\\n\", warn)\n\t\t}\n\t\tpc.h.Must(errors.Wrapf(err, \"Unable to read manifest at %s\", mp))\n\t}\n\tvar l *Lock\n\tlp := pc.getLockPath()\n\tif pc.h.Exist(lp) {\n\t\tlf := pc.h.GetFile(lp)\n\t\tdefer lf.Close()\n\t\tl, err = readLock(lf)\n\t\tpc.h.Must(errors.Wrapf(err, \"Unable to read lock at %s\", lp))\n\t}\n\tpc.Project.Manifest = m\n\tpc.Project.Lock = l\n}\n\n// GetLockPath returns the full path to the lock\nfunc (pc *TestProjectContext) getLockPath() string {\n\treturn filepath.Join(pc.Project.AbsRoot, LockName)\n}\n\n// GetManifestPath returns the full path to the manifest\nfunc (pc *TestProjectContext) getManifestPath() string {\n\treturn filepath.Join(pc.Project.AbsRoot, ManifestName)\n}\n\n// GetVendorPath returns the full path to the vendor directory\nfunc (pc *TestProjectContext) getVendorPath() string {\n\treturn filepath.Join(pc.Project.AbsRoot, \"vendor\")\n}\n\n// LockShouldMatchGolden returns an error when the lock does not match the golden lock.\n// goldenLockPath is the path to the golden lock file relative to the testdata directory\n// Updates the golden file when -UpdateGolden flag is present.\nfunc (pc *TestProjectContext) LockShouldMatchGolden(goldenLockPath string) error {\n\tgot := pc.h.ReadLock()\n\treturn pc.ShouldMatchGolden(goldenLockPath, got)\n}\n\n// LockShouldNotExist returns an error when the lock exists.\nfunc (pc *TestProjectContext) LockShouldNotExist() error {\n\treturn pc.h.ShouldNotExist(pc.getLockPath())\n}\n\n// ManifestShouldMatchGolden returns an error when the manifest does not match the golden manifest.\n// goldenManifestPath is the path to the golden manifest file, relative to the testdata directory\n// Updates the golden file when -UpdateGolden flag is present\nfunc (pc *TestProjectContext) ManifestShouldMatchGolden(goldenManifestPath string) error {\n\tgot := pc.h.ReadManifest()\n\treturn pc.ShouldMatchGolden(goldenManifestPath, got)\n}\n\n// ManifestShouldNotExist returns an error when the lock exists.\nfunc (pc *TestProjectContext) ManifestShouldNotExist() error {\n\treturn pc.h.ShouldNotExist(pc.getManifestPath())\n}\n\n// ShouldMatchGolden returns an error when a file does not match the golden file.\n// goldenFile is the path to the golden file, relative to the testdata directory\n// Updates the golden file when -UpdateGolden flag is present\nfunc (pc *TestProjectContext) ShouldMatchGolden(goldenFile string, got string) error {\n\twant := pc.h.GetTestFileString(goldenFile)\n\tif want != got {\n\t\tif *test.UpdateGolden {\n\t\t\tif err := pc.h.WriteTestFile(goldenFile, got); err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"Unable to write updated golden file %s\", goldenFile)\n\t\t\t}\n\t\t} else {\n\t\t\treturn errors.Errorf(\"expected %s, got %s\", want, got)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// VendorShouldExist returns an error when the vendor directory does not exist.\nfunc (pc *TestProjectContext) VendorShouldExist() error {\n\treturn pc.h.ShouldExist(pc.getVendorPath())\n}\n\n// VendorFileShouldExist returns an error when the specified file does not exist in vendor.\n// filePath is the relative path to the file within vendor\nfunc (pc *TestProjectContext) VendorFileShouldExist(filePath string) error {\n\tfullPath := filepath.Join(pc.getVendorPath(), filePath)\n\treturn pc.h.ShouldExist(fullPath)\n}\n\n// VendorShouldNotExist returns an error when the vendor directory exists.\nfunc (pc *TestProjectContext) VendorShouldNotExist() error {\n\treturn pc.h.ShouldNotExist(pc.getVendorPath())\n}\n\n// Release cleans up after test objects created by this instance\nfunc (pc *TestProjectContext) Release() {\n\tif pc.SourceManager != nil {\n\t\tpc.SourceManager.Release()\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "txn_writer.go",
          "type": "blob",
          "size": 23.64453125,
          "content": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/gps/verify\"\n\t\"github.com/golang/dep/internal/fs\"\n\t\"github.com/pkg/errors\"\n)\n\nconst (\n\t// Helper consts for common diff-checking patterns.\n\tanyExceptHash verify.DeltaDimension = verify.AnyChanged & ^verify.HashVersionChanged & ^verify.HashChanged\n)\n\n// Example string to be written to the manifest file\n// if no dependencies are found in the project\n// during `dep init`\nvar exampleTOML = []byte(`# Gopkg.toml example\n#\n# Refer to https://golang.github.io/dep/docs/Gopkg.toml.html\n# for detailed Gopkg.toml documentation.\n#\n# required = [\"github.com/user/thing/cmd/thing\"]\n# ignored = [\"github.com/user/project/pkgX\", \"bitbucket.org/user/project/pkgA/pkgY\"]\n#\n# [[constraint]]\n#   name = \"github.com/user/project\"\n#   version = \"1.0.0\"\n#\n# [[constraint]]\n#   name = \"github.com/user/project2\"\n#   branch = \"dev\"\n#   source = \"github.com/myfork/project2\"\n#\n# [[override]]\n#   name = \"github.com/x/y\"\n#   version = \"2.4.0\"\n#\n# [prune]\n#   non-go = false\n#   go-tests = true\n#   unused-packages = true\n\n`)\n\n// String added on top of lock file\nvar lockFileComment = []byte(`# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n\n`)\n\n// SafeWriter transactionalizes writes of manifest, lock, and vendor dir, both\n// individually and in any combination, into a pseudo-atomic action with\n// transactional rollback.\n//\n// It is not impervious to errors (writing to disk is hard), but it should\n// guard against non-arcane failure conditions.\ntype SafeWriter struct {\n\tManifest     *Manifest\n\tlock         *Lock\n\tlockDiff     verify.LockDelta\n\twriteVendor  bool\n\twriteLock    bool\n\tpruneOptions gps.CascadingPruneOptions\n}\n\n// NewSafeWriter sets up a SafeWriter to write a set of manifest, lock, and\n// vendor tree.\n//\n// - If manifest is provided, it will be written to the standard manifest file\n// name beneath root.\n//\n// - If newLock is provided, it will be written to the standard lock file\n// name beneath root.\n//\n// - If vendor is VendorAlways, or is VendorOnChanged and the locks are different,\n// the vendor directory will be written beneath root based on newLock.\n//\n// - If oldLock is provided without newLock, error.\n//\n// - If vendor is VendorAlways without a newLock, error.\nfunc NewSafeWriter(manifest *Manifest, oldLock, newLock *Lock, vendor VendorBehavior, prune gps.CascadingPruneOptions, status map[string]verify.VendorStatus) (*SafeWriter, error) {\n\tsw := &SafeWriter{\n\t\tManifest:     manifest,\n\t\tlock:         newLock,\n\t\tpruneOptions: prune,\n\t}\n\n\tif oldLock != nil {\n\t\tif newLock == nil {\n\t\t\treturn nil, errors.New(\"must provide newLock when oldLock is specified\")\n\t\t}\n\n\t\tsw.lockDiff = verify.DiffLocks(oldLock, newLock)\n\t\tif sw.lockDiff.Changed(anyExceptHash) {\n\t\t\tsw.writeLock = true\n\t\t}\n\t} else if newLock != nil {\n\t\tsw.writeLock = true\n\t}\n\n\tswitch vendor {\n\tcase VendorAlways:\n\t\tsw.writeVendor = true\n\tcase VendorOnChanged:\n\t\tif newLock != nil && oldLock == nil {\n\t\t\tsw.writeVendor = true\n\t\t} else if sw.lockDiff.Changed(anyExceptHash & ^verify.InputImportsChanged) {\n\t\t\tsw.writeVendor = true\n\t\t} else {\n\t\t\tfor _, stat := range status {\n\t\t\t\tif stat != verify.NoMismatch {\n\t\t\t\t\tsw.writeVendor = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif sw.writeVendor && newLock == nil {\n\t\treturn nil, errors.New(\"must provide newLock in order to write out vendor\")\n\t}\n\n\treturn sw, nil\n}\n\n// HasLock checks if a Lock is present in the SafeWriter\nfunc (sw *SafeWriter) HasLock() bool {\n\treturn sw.lock != nil\n}\n\n// HasManifest checks if a Manifest is present in the SafeWriter\nfunc (sw *SafeWriter) HasManifest() bool {\n\treturn sw.Manifest != nil\n}\n\n// VendorBehavior defines when the vendor directory should be written.\ntype VendorBehavior int\n\nconst (\n\t// VendorOnChanged indicates that the vendor directory should be written\n\t// when the lock is new or changed, or a project in vendor differs from its\n\t// intended state.\n\tVendorOnChanged VendorBehavior = iota\n\t// VendorAlways forces the vendor directory to always be written.\n\tVendorAlways\n\t// VendorNever indicates the vendor directory should never be written.\n\tVendorNever\n)\n\nfunc (sw SafeWriter) validate(root string, sm gps.SourceManager) error {\n\tif root == \"\" {\n\t\treturn errors.New(\"root path must be non-empty\")\n\t}\n\tif is, err := fs.IsDir(root); !is {\n\t\tif err != nil && !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t\treturn errors.Errorf(\"root path %q does not exist\", root)\n\t}\n\n\tif sw.writeVendor && sm == nil {\n\t\treturn errors.New(\"must provide a SourceManager if writing out a vendor dir\")\n\t}\n\n\treturn nil\n}\n\n// Write saves some combination of manifest, lock, and a vendor tree. root is\n// the absolute path of root dir in which to write. sm is only required if\n// vendor is being written.\n//\n// It first writes to a temp dir, then moves them in place if and only if all\n// the write operations succeeded. It also does its best to roll back if any\n// moves fail. This mostly guarantees that dep cannot exit with a partial write\n// that would leave an undefined state on disk.\n//\n// If logger is not nil, progress will be logged after each project write.\nfunc (sw *SafeWriter) Write(root string, sm gps.SourceManager, examples bool, logger *log.Logger) error {\n\terr := sw.validate(root, sm)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !sw.HasManifest() && !sw.writeLock && !sw.writeVendor {\n\t\t// nothing to do\n\t\treturn nil\n\t}\n\n\tmpath := filepath.Join(root, ManifestName)\n\tlpath := filepath.Join(root, LockName)\n\tvpath := filepath.Join(root, \"vendor\")\n\n\ttd, err := ioutil.TempDir(os.TempDir(), \"dep\")\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"error while creating temp dir for writing manifest/lock/vendor\")\n\t}\n\tdefer os.RemoveAll(td)\n\n\tif sw.HasManifest() {\n\t\t// Always write the example text to the bottom of the TOML file.\n\t\ttb, err := sw.Manifest.MarshalTOML()\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to marshal manifest to TOML\")\n\t\t}\n\n\t\tvar initOutput []byte\n\n\t\t// If examples are enabled, use the example text\n\t\tif examples {\n\t\t\tinitOutput = exampleTOML\n\t\t}\n\n\t\tif err = ioutil.WriteFile(filepath.Join(td, ManifestName), append(initOutput, tb...), 0666); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to write manifest file to temp dir\")\n\t\t}\n\t}\n\n\tif sw.writeVendor {\n\t\tvar onWrite func(gps.WriteProgress)\n\t\tif logger != nil {\n\t\t\tonWrite = func(progress gps.WriteProgress) {\n\t\t\t\tlogger.Println(progress)\n\t\t\t}\n\t\t}\n\t\terr = gps.WriteDepTree(filepath.Join(td, \"vendor\"), sw.lock, sm, sw.pruneOptions, onWrite)\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"error while writing out vendor tree\")\n\t\t}\n\n\t\tfor k, lp := range sw.lock.Projects() {\n\t\t\tvp := lp.(verify.VerifiableProject)\n\t\t\tvp.Digest, err = verify.DigestFromDirectory(filepath.Join(td, \"vendor\", string(lp.Ident().ProjectRoot)))\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error while hashing tree of %s in vendor\", lp.Ident().ProjectRoot)\n\t\t\t}\n\t\t\tsw.lock.P[k] = vp\n\t\t}\n\t}\n\n\tif sw.writeLock {\n\t\tl, err := sw.lock.MarshalTOML()\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to marshal lock to TOML\")\n\t\t}\n\n\t\tif err = ioutil.WriteFile(filepath.Join(td, LockName), append(lockFileComment, l...), 0666); err != nil {\n\t\t\treturn errors.Wrap(err, \"failed to write lock file to temp dir\")\n\t\t}\n\t}\n\n\t// Ensure vendor/.git is preserved if present\n\tif hasDotGit(vpath) {\n\t\terr = fs.RenameWithFallback(filepath.Join(vpath, \".git\"), filepath.Join(td, \"vendor/.git\"))\n\t\tif _, ok := err.(*os.LinkError); ok {\n\t\t\treturn errors.Wrap(err, \"failed to preserve vendor/.git\")\n\t\t}\n\t}\n\n\t// Move the existing files and dirs to the temp dir while we put the new\n\t// ones in, to provide insurance against errors for as long as possible.\n\ttype pathpair struct {\n\t\tfrom, to string\n\t}\n\tvar restore []pathpair\n\tvar failerr error\n\tvar vendorbak string\n\n\tif sw.HasManifest() {\n\t\tif _, err := os.Stat(mpath); err == nil {\n\t\t\t// Move out the old one.\n\t\t\ttmploc := filepath.Join(td, ManifestName+\".orig\")\n\t\t\tfailerr = fs.RenameWithFallback(mpath, tmploc)\n\t\t\tif failerr != nil {\n\t\t\t\tgoto fail\n\t\t\t}\n\t\t\trestore = append(restore, pathpair{from: tmploc, to: mpath})\n\t\t}\n\n\t\t// Move in the new one.\n\t\tfailerr = fs.RenameWithFallback(filepath.Join(td, ManifestName), mpath)\n\t\tif failerr != nil {\n\t\t\tgoto fail\n\t\t}\n\t}\n\n\tif sw.writeLock {\n\t\tif _, err := os.Stat(lpath); err == nil {\n\t\t\t// Move out the old one.\n\t\t\ttmploc := filepath.Join(td, LockName+\".orig\")\n\n\t\t\tfailerr = fs.RenameWithFallback(lpath, tmploc)\n\t\t\tif failerr != nil {\n\t\t\t\tgoto fail\n\t\t\t}\n\t\t\trestore = append(restore, pathpair{from: tmploc, to: lpath})\n\t\t}\n\n\t\t// Move in the new one.\n\t\tfailerr = fs.RenameWithFallback(filepath.Join(td, LockName), lpath)\n\t\tif failerr != nil {\n\t\t\tgoto fail\n\t\t}\n\t}\n\n\tif sw.writeVendor {\n\t\tif _, err := os.Stat(vpath); err == nil {\n\t\t\t// Move out the old vendor dir. just do it into an adjacent dir, to\n\t\t\t// try to mitigate the possibility of a pointless cross-filesystem\n\t\t\t// move with a temp directory.\n\t\t\tvendorbak = vpath + \".orig\"\n\t\t\tif _, err := os.Stat(vendorbak); err == nil {\n\t\t\t\t// If the adjacent dir already exists, bite the bullet and move\n\t\t\t\t// to a proper tempdir.\n\t\t\t\tvendorbak = filepath.Join(td, \".vendor.orig\")\n\t\t\t}\n\n\t\t\tfailerr = fs.RenameWithFallback(vpath, vendorbak)\n\t\t\tif failerr != nil {\n\t\t\t\tgoto fail\n\t\t\t}\n\t\t\trestore = append(restore, pathpair{from: vendorbak, to: vpath})\n\t\t}\n\n\t\t// Move in the new one.\n\t\tfailerr = fs.RenameWithFallback(filepath.Join(td, \"vendor\"), vpath)\n\t\tif failerr != nil {\n\t\t\tgoto fail\n\t\t}\n\t}\n\n\t// Renames all went smoothly. The deferred os.RemoveAll will get the temp\n\t// dir, but if we wrote vendor, we have to clean that up directly\n\tif sw.writeVendor {\n\t\t// Nothing we can really do about an error at this point, so ignore it\n\t\tos.RemoveAll(vendorbak)\n\t}\n\n\treturn nil\n\nfail:\n\t// If we failed at any point, move all the things back into place, then bail.\n\tfor _, pair := range restore {\n\t\t// Nothing we can do on err here, as we're already in recovery mode.\n\t\tfs.RenameWithFallback(pair.from, pair.to)\n\t}\n\treturn failerr\n}\n\n// PrintPreparedActions logs the actions a call to Write would perform.\nfunc (sw *SafeWriter) PrintPreparedActions(output *log.Logger, verbose bool) error {\n\tif output == nil {\n\t\toutput = log.New(ioutil.Discard, \"\", 0)\n\t}\n\tif sw.HasManifest() {\n\t\tif verbose {\n\t\t\tm, err := sw.Manifest.MarshalTOML()\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"ensure DryRun cannot serialize manifest\")\n\t\t\t}\n\t\t\toutput.Printf(\"Would have written the following %s:\\n%s\\n\", ManifestName, string(m))\n\t\t} else {\n\t\t\toutput.Printf(\"Would have written %s.\\n\", ManifestName)\n\t\t}\n\t}\n\n\tif sw.writeLock {\n\t\tif verbose {\n\t\t\tl, err := sw.lock.MarshalTOML()\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"ensure DryRun cannot serialize lock\")\n\t\t\t}\n\t\t\toutput.Printf(\"Would have written the following %s:\\n%s\\n\", LockName, string(l))\n\t\t} else {\n\t\t\toutput.Printf(\"Would have written %s.\\n\", LockName)\n\t\t}\n\t}\n\n\tif sw.writeVendor {\n\t\tif verbose {\n\t\t\toutput.Printf(\"Would have written the following %d projects to the vendor directory:\\n\", len(sw.lock.Projects()))\n\t\t\tlps := sw.lock.Projects()\n\t\t\tfor i, p := range lps {\n\t\t\t\toutput.Printf(\"(%d/%d) %s@%s\\n\", i+1, len(lps), p.Ident(), p.Version())\n\t\t\t}\n\t\t} else {\n\t\t\toutput.Printf(\"Would have written %d projects to the vendor directory.\\n\", len(sw.lock.Projects()))\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// hasDotGit checks if a given path has .git file or directory in it.\nfunc hasDotGit(path string) bool {\n\tgitfilepath := filepath.Join(path, \".git\")\n\t_, err := os.Stat(gitfilepath)\n\treturn err == nil\n}\n\n// DeltaWriter manages batched writes to populate vendor/ and update Gopkg.lock.\n// Its primary design goal is to minimize writes by only writing things that\n// have changed.\ntype DeltaWriter struct {\n\tlock      *Lock\n\tlockDiff  verify.LockDelta\n\tvendorDir string\n\tchanged   map[gps.ProjectRoot]changeType\n\tbehavior  VendorBehavior\n}\n\ntype changeType uint8\n\nconst (\n\thashMismatch changeType = iota + 1\n\thashVersionMismatch\n\thashAbsent\n\tnoVerify\n\tsolveChanged\n\tpruneOptsChanged\n\tmissingFromTree\n\tprojectAdded\n\tprojectRemoved\n\tpathPreserved\n)\n\n// NewDeltaWriter prepares a vendor writer that will construct a vendor\n// directory by writing out only those projects that actually need to be written\n// out - they have changed in some way, or they lack the necessary hash\n// information to be verified.\nfunc NewDeltaWriter(p *Project, newLock *Lock, behavior VendorBehavior) (TreeWriter, error) {\n\tdw := &DeltaWriter{\n\t\tlock:      newLock,\n\t\tvendorDir: filepath.Join(p.AbsRoot, \"vendor\"),\n\t\tchanged:   make(map[gps.ProjectRoot]changeType),\n\t\tbehavior:  behavior,\n\t}\n\n\tif newLock == nil {\n\t\treturn nil, errors.New(\"must provide a non-nil newlock\")\n\t}\n\n\tstatus, err := p.VerifyVendor()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = os.Stat(dw.vendorDir)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\t// Provided dir does not exist, so there's no disk contents to compare\n\t\t\t// against. Fall back to the old SafeWriter.\n\t\t\treturn NewSafeWriter(nil, p.Lock, newLock, behavior, p.Manifest.PruneOptions, status)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\tdw.lockDiff = verify.DiffLocks(p.Lock, newLock)\n\n\tfor pr, lpd := range dw.lockDiff.ProjectDeltas {\n\t\t// Hash changes aren't relevant at this point, as they could be empty\n\t\t// in the new lock, and therefore a symptom of a solver change.\n\t\tif lpd.Changed(anyExceptHash) {\n\t\t\tif lpd.WasAdded() {\n\t\t\t\tdw.changed[pr] = projectAdded\n\t\t\t} else if lpd.WasRemoved() {\n\t\t\t\tdw.changed[pr] = projectRemoved\n\t\t\t} else if lpd.PruneOptsChanged() {\n\t\t\t\tdw.changed[pr] = pruneOptsChanged\n\t\t\t} else {\n\t\t\t\tdw.changed[pr] = solveChanged\n\t\t\t}\n\t\t}\n\t}\n\n\tfor spr, stat := range status {\n\t\tpr := gps.ProjectRoot(spr)\n\t\t// These cases only matter if there was no change already recorded via\n\t\t// the differ.\n\t\tif _, has := dw.changed[pr]; !has {\n\t\t\tswitch stat {\n\t\t\tcase verify.NotInTree:\n\t\t\t\tdw.changed[pr] = missingFromTree\n\t\t\tcase verify.NotInLock:\n\t\t\t\tdw.changed[pr] = projectRemoved\n\t\t\tcase verify.DigestMismatchInLock:\n\t\t\t\tdw.changed[pr] = hashMismatch\n\t\t\tcase verify.HashVersionMismatch:\n\t\t\t\tdw.changed[pr] = hashVersionMismatch\n\t\t\tcase verify.EmptyDigestInLock:\n\t\t\t\tdw.changed[pr] = hashAbsent\n\t\t\t}\n\t\t}\n\t}\n\n\t// Apply noverify last, as it should only supersede changeTypes with lower\n\t// values. It is NOT applied if no existing change is registered.\n\tfor _, spr := range p.Manifest.NoVerify {\n\t\tpr := gps.ProjectRoot(spr)\n\t\t// We don't validate this field elsewhere as it can be difficult to know\n\t\t// at the beginning of a dep ensure command whether or not the noverify\n\t\t// project actually will exist as part of the Lock by the end of the\n\t\t// run. So, only apply if it's in the lockdiff.\n\t\tif _, has := dw.lockDiff.ProjectDeltas[pr]; has {\n\t\t\tif typ, has := dw.changed[pr]; has {\n\t\t\t\tif typ < noVerify {\n\t\t\t\t\t// Avoid writing noverify projects at all for the lower change\n\t\t\t\t\t// types.\n\t\t\t\t\tdelete(dw.changed, pr)\n\n\t\t\t\t\t// Uncomment this if we want to switch to the safer behavior,\n\t\t\t\t\t// where we ALWAYS write noverify projects.\n\t\t\t\t\t//dw.changed[pr] = noVerify\n\t\t\t\t} else if typ == projectRemoved {\n\t\t\t\t\t// noverify can also be used to preserve files that would\n\t\t\t\t\t// otherwise be removed.\n\t\t\t\t\tdw.changed[pr] = pathPreserved\n\t\t\t\t}\n\t\t\t}\n\t\t\t// It's also allowed to preserve entirely unknown paths using noverify.\n\t\t} else if _, has := status[spr]; has {\n\t\t\tdw.changed[pr] = pathPreserved\n\t\t}\n\t}\n\n\treturn dw, nil\n}\n\n// Write executes the planned changes.\n//\n// This writes recreated projects to a new directory, then moves in existing,\n// unchanged projects from the original vendor directory. If any failures occur,\n// reasonable attempts are made to roll back the changes.\nfunc (dw *DeltaWriter) Write(path string, sm gps.SourceManager, examples bool, logger *log.Logger) error {\n\t// TODO(sdboyer) remove path from the signature for this\n\tif path != filepath.Dir(dw.vendorDir) {\n\t\treturn errors.Errorf(\"target path (%q) must be the parent of the original vendor path (%q)\", path, dw.vendorDir)\n\t}\n\n\tif logger == nil {\n\t\tlogger = log.New(ioutil.Discard, \"\", 0)\n\t}\n\n\tlpath := filepath.Join(path, LockName)\n\tvpath := dw.vendorDir\n\n\t// Write the modified projects to a new adjacent directory. We use an\n\t// adjacent directory to minimize the possibility of cross-filesystem renames\n\t// becoming expensive copies, and to make removal of unneeded projects implicit\n\t// and automatic.\n\tvnewpath := filepath.Join(filepath.Dir(vpath), \".vendor-new\")\n\tif _, err := os.Stat(vnewpath); err == nil {\n\t\treturn errors.Errorf(\"scratch directory %s already exists, please remove it\", vnewpath)\n\t}\n\terr := os.MkdirAll(vnewpath, os.FileMode(0777))\n\tif err != nil {\n\t\treturn errors.Wrapf(err, \"error while creating scratch directory at %s\", vnewpath)\n\t}\n\n\t// Write out all the deltas to the newpath\n\tprojs := make(map[gps.ProjectRoot]gps.LockedProject)\n\tfor _, lp := range dw.lock.Projects() {\n\t\tprojs[lp.Ident().ProjectRoot] = lp\n\t}\n\n\tvar dropped, preserved []gps.ProjectRoot\n\ti := 0\n\ttot := len(dw.changed)\n\tfor _, reason := range dw.changed {\n\t\tif reason != pathPreserved {\n\t\t\tlogger.Println(\"# Bringing vendor into sync\")\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfor pr, reason := range dw.changed {\n\t\tswitch reason {\n\t\tcase projectRemoved:\n\t\t\tdropped = append(dropped, pr)\n\t\t\tcontinue\n\t\tcase pathPreserved:\n\t\t\tpreserved = append(preserved, pr)\n\t\t\tcontinue\n\t\t}\n\n\t\tto := filepath.FromSlash(filepath.Join(vnewpath, string(pr)))\n\t\tpo := projs[pr].(verify.VerifiableProject).PruneOpts\n\t\tif err := sm.ExportPrunedProject(context.TODO(), projs[pr], po, to); err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to export %s\", pr)\n\t\t}\n\n\t\ti++\n\t\tlpd := dw.lockDiff.ProjectDeltas[pr]\n\t\tv, id := projs[pr].Version(), projs[pr].Ident()\n\n\t\t// Only print things if we're actually going to leave behind a new\n\t\t// vendor dir.\n\t\tif dw.behavior != VendorNever {\n\t\t\tlogger.Printf(\"(%d/%d) Wrote %s@%s: %s\", i, tot, id, v, changeExplanation(reason, lpd))\n\t\t}\n\n\t\tdigest, err := verify.DigestFromDirectory(to)\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to hash %s\", pr)\n\t\t}\n\n\t\t// Update the new Lock with verification information.\n\t\tfor k, lp := range dw.lock.P {\n\t\t\tif lp.Ident().ProjectRoot == pr {\n\t\t\t\tvp := lp.(verify.VerifiableProject)\n\t\t\t\tvp.Digest = digest\n\t\t\t\tdw.lock.P[k] = verify.VerifiableProject{\n\t\t\t\t\tLockedProject: lp,\n\t\t\t\t\tPruneOpts:     po,\n\t\t\t\t\tDigest:        digest,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Write out the lock, now that it's fully updated with digests.\n\tl, err := dw.lock.MarshalTOML()\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to marshal lock to TOML\")\n\t}\n\n\tif err = ioutil.WriteFile(lpath, append(lockFileComment, l...), 0666); err != nil {\n\t\treturn errors.Wrap(err, \"failed to write new lock file\")\n\t}\n\n\tif dw.behavior == VendorNever {\n\t\treturn os.RemoveAll(vnewpath)\n\t}\n\n\t// Changed projects are fully populated. Now, iterate over the lock's\n\t// projects and move any remaining ones not in the changed list to vnewpath.\n\tfor _, lp := range dw.lock.Projects() {\n\t\tpr := lp.Ident().ProjectRoot\n\t\ttgt := filepath.Join(vnewpath, string(pr))\n\t\terr := os.MkdirAll(filepath.Dir(tgt), os.FileMode(0777))\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"error creating parent directory in vendor for %s\", tgt)\n\t\t}\n\n\t\tif _, has := dw.changed[pr]; !has {\n\t\t\terr = fs.RenameWithFallback(filepath.Join(vpath, string(pr)), tgt)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrapf(err, \"error moving unchanged project %s into scratch vendor dir\", pr)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor i, pr := range dropped {\n\t\t// Kind of a lie to print this. ¯\\_(ツ)_/¯\n\t\tfi, err := os.Stat(filepath.Join(vpath, string(pr)))\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"could not stat file that VerifyVendor claimed existed\")\n\t\t}\n\n\t\tif fi.IsDir() {\n\t\t\tlogger.Printf(\"(%d/%d) Removed unused project %s\", tot-(len(dropped)-i-1), tot, pr)\n\t\t} else {\n\t\t\tlogger.Printf(\"(%d/%d) Removed orphaned file %s\", tot-(len(dropped)-i-1), tot, pr)\n\t\t}\n\t}\n\n\t// Special case: ensure vendor/.git is preserved if present\n\tif hasDotGit(vpath) {\n\t\tpreserved = append(preserved, \".git\")\n\t}\n\n\tfor _, path := range preserved {\n\t\terr = fs.RenameWithFallback(filepath.Join(vpath, string(path)), filepath.Join(vnewpath, string(path)))\n\t\tif err != nil {\n\t\t\treturn errors.Wrapf(err, \"failed to preserve vendor/%s\", path)\n\t\t}\n\t}\n\n\terr = os.RemoveAll(vpath)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to remove original vendor directory\")\n\t}\n\terr = fs.RenameWithFallback(vnewpath, vpath)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"failed to put new vendor directory into place\")\n\t}\n\n\treturn nil\n}\n\n// changeExplanation outputs a string explaining what changed for each different\n// possible changeType.\nfunc changeExplanation(c changeType, lpd verify.LockedProjectDelta) string {\n\tswitch c {\n\tcase noVerify:\n\t\treturn \"verification is disabled\"\n\tcase solveChanged:\n\t\tif lpd.SourceChanged() {\n\t\t\treturn fmt.Sprintf(\"source changed (%s -> %s)\", lpd.SourceBefore, lpd.SourceAfter)\n\t\t} else if lpd.VersionChanged() {\n\t\t\tif lpd.VersionBefore == nil {\n\t\t\t\treturn fmt.Sprintf(\"version changed (was a bare revision)\")\n\t\t\t}\n\t\t\treturn fmt.Sprintf(\"version changed (was %s)\", lpd.VersionBefore.String())\n\t\t} else if lpd.RevisionChanged() {\n\t\t\treturn fmt.Sprintf(\"revision changed (%s -> %s)\", trimSHA(lpd.RevisionBefore), trimSHA(lpd.RevisionAfter))\n\t\t} else if lpd.PackagesChanged() {\n\t\t\tla, lr := len(lpd.PackagesAdded), len(lpd.PackagesRemoved)\n\t\t\tif la > 0 && lr > 0 {\n\t\t\t\treturn fmt.Sprintf(\"packages changed (%v added, %v removed)\", la, lr)\n\t\t\t} else if la > 0 {\n\t\t\t\treturn fmt.Sprintf(\"packages changed (%v added)\", la)\n\t\t\t}\n\t\t\treturn fmt.Sprintf(\"packages changed (%v removed)\", lr)\n\t\t}\n\tcase pruneOptsChanged:\n\t\t// Override what's on the lockdiff with the extra info we have;\n\t\t// this lets us excise PruneNestedVendorDirs and get the real\n\t\t// value from the input param in place.\n\t\told := lpd.PruneOptsBefore & ^gps.PruneNestedVendorDirs\n\t\tnew := lpd.PruneOptsAfter & ^gps.PruneNestedVendorDirs\n\t\treturn fmt.Sprintf(\"prune options changed (%s -> %s)\", old, new)\n\tcase hashMismatch:\n\t\treturn \"hash of vendored tree didn't match digest in Gopkg.lock\"\n\tcase hashVersionMismatch:\n\t\treturn \"hashing algorithm mismatch\"\n\tcase hashAbsent:\n\t\treturn \"hash digest absent from lock\"\n\tcase projectAdded:\n\t\treturn \"new project\"\n\tcase missingFromTree:\n\t\treturn \"missing from vendor\"\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unrecognized changeType value %v\", c))\n\t}\n\n\treturn \"\"\n}\n\n// PrintPreparedActions indicates what changes the DeltaWriter plans to make.\nfunc (dw *DeltaWriter) PrintPreparedActions(output *log.Logger, verbose bool) error {\n\tif verbose {\n\t\tl, err := dw.lock.MarshalTOML()\n\t\tif err != nil {\n\t\t\treturn errors.Wrap(err, \"ensure DryRun cannot serialize lock\")\n\t\t}\n\t\toutput.Printf(\"Would have written the following %s (hash digests may be incorrect):\\n%s\\n\", LockName, string(l))\n\t} else {\n\t\toutput.Printf(\"Would have written %s.\\n\", LockName)\n\t}\n\n\tprojs := make(map[gps.ProjectRoot]gps.LockedProject)\n\tfor _, lp := range dw.lock.Projects() {\n\t\tprojs[lp.Ident().ProjectRoot] = lp\n\t}\n\n\ttot := len(dw.changed)\n\tif tot > 0 {\n\t\toutput.Print(\"Would have updated the following projects in the vendor directory:\\n\\n\")\n\t\ti := 0\n\t\tfor pr, reason := range dw.changed {\n\t\t\tlpd := dw.lockDiff.ProjectDeltas[pr]\n\t\t\tif reason == projectRemoved {\n\t\t\t\toutput.Printf(\"(%d/%d) Would have removed %s\", i, tot, pr)\n\t\t\t} else {\n\t\t\t\toutput.Printf(\"(%d/%d) Would have written %s@%s: %s\", i, tot, projs[pr].Ident(), projs[pr].Version(), changeExplanation(reason, lpd))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// A TreeWriter is responsible for writing important dep states to disk -\n// Gopkg.lock, vendor, and possibly Gopkg.toml.\ntype TreeWriter interface {\n\tPrintPreparedActions(output *log.Logger, verbose bool) error\n\tWrite(path string, sm gps.SourceManager, examples bool, logger *log.Logger) error\n}\n\n// trimSHA checks if revision is a valid SHA1 digest and trims to 10 characters.\nfunc trimSHA(revision gps.Revision) string {\n\tif len(revision) == 40 {\n\t\tif _, err := hex.DecodeString(string(revision)); err == nil {\n\t\t\t// Valid SHA1 digest\n\t\t\trevision = revision[0:10]\n\t\t}\n\t}\n\n\treturn string(revision)\n}\n"
        },
        {
          "name": "txn_writer_test.go",
          "type": "blob",
          "size": 13.4345703125,
          "content": "// Copyright 2017 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage dep\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/golang/dep/gps\"\n\t\"github.com/golang/dep/internal/test\"\n\t\"github.com/pkg/errors\"\n)\n\nconst safeWriterProject = \"safewritertest\"\nconst safeWriterGoldenManifest = \"txn_writer/expected_manifest.toml\"\nconst safeWriterGoldenLock = \"txn_writer/expected_lock.toml\"\n\nfunc defaultCascadingPruneOptions() gps.CascadingPruneOptions {\n\treturn gps.CascadingPruneOptions{\n\t\tDefaultOptions:    gps.PruneNestedVendorDirs,\n\t\tPerProjectOptions: map[gps.ProjectRoot]gps.PruneOptionSet{},\n\t}\n}\n\nfunc TestSafeWriter_BadInput_MissingRoot(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\n\tsw, _ := NewSafeWriter(nil, nil, nil, VendorOnChanged, defaultCascadingPruneOptions(), nil)\n\terr := sw.Write(\"\", pc.SourceManager, true, nil)\n\n\tif err == nil {\n\t\tt.Fatal(\"should have errored without a root path, but did not\")\n\t} else if !strings.Contains(err.Error(), \"root path\") {\n\t\tt.Fatalf(\"expected root path error, got %s\", err.Error())\n\t}\n}\n\nfunc TestSafeWriter_BadInput_MissingSourceManager(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.CopyFile(LockName, safeWriterGoldenLock)\n\tpc.Load()\n\n\tsw, _ := NewSafeWriter(nil, nil, pc.Project.Lock, VendorAlways, defaultCascadingPruneOptions(), nil)\n\terr := sw.Write(pc.Project.AbsRoot, nil, true, nil)\n\n\tif err == nil {\n\t\tt.Fatal(\"should have errored without a source manager when forceVendor is true, but did not\")\n\t} else if !strings.Contains(err.Error(), \"SourceManager\") {\n\t\tt.Fatalf(\"expected SourceManager error, got %s\", err.Error())\n\t}\n}\n\nfunc TestSafeWriter_BadInput_ForceVendorMissingLock(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\n\t_, err := NewSafeWriter(nil, nil, nil, VendorAlways, defaultCascadingPruneOptions(), nil)\n\tif err == nil {\n\t\tt.Fatal(\"should have errored without a lock when forceVendor is true, but did not\")\n\t} else if !strings.Contains(err.Error(), \"newLock\") {\n\t\tt.Fatalf(\"expected newLock error, got %s\", err.Error())\n\t}\n}\n\nfunc TestSafeWriter_BadInput_OldLockOnly(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.CopyFile(LockName, safeWriterGoldenLock)\n\tpc.Load()\n\n\t_, err := NewSafeWriter(nil, pc.Project.Lock, nil, VendorAlways, defaultCascadingPruneOptions(), nil)\n\tif err == nil {\n\t\tt.Fatal(\"should have errored with only an old lock, but did not\")\n\t} else if !strings.Contains(err.Error(), \"oldLock\") {\n\t\tt.Fatalf(\"expected oldLock error, got %s\", err.Error())\n\t}\n}\n\nfunc TestSafeWriter_BadInput_NonexistentRoot(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\n\tsw, _ := NewSafeWriter(nil, nil, nil, VendorOnChanged, defaultCascadingPruneOptions(), nil)\n\n\tmissingroot := filepath.Join(pc.Project.AbsRoot, \"nonexistent\")\n\terr := sw.Write(missingroot, pc.SourceManager, true, nil)\n\n\tif err == nil {\n\t\tt.Fatal(\"should have errored with nonexistent dir for root path, but did not\")\n\t} else if !strings.Contains(err.Error(), \"does not exist\") {\n\t\tt.Fatalf(\"expected does not exist error, got %s\", err.Error())\n\t}\n}\n\nfunc TestSafeWriter_BadInput_RootIsFile(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\n\tsw, _ := NewSafeWriter(nil, nil, nil, VendorOnChanged, defaultCascadingPruneOptions(), nil)\n\n\tfileroot := pc.CopyFile(\"fileroot\", \"txn_writer/badinput_fileroot\")\n\terr := sw.Write(fileroot, pc.SourceManager, true, nil)\n\n\tif err == nil {\n\t\tt.Fatal(\"should have errored when root path is a file, but did not\")\n\t} else if !strings.Contains(err.Error(), \"does not exist\") {\n\t\tt.Fatalf(\"expected does not exist error, got %s\", err.Error())\n\t}\n}\n\nfunc TestSafeWriter_Manifest(t *testing.T) {\n\ttest.NeedsExternalNetwork(t)\n\ttest.NeedsGit(t)\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.CopyFile(ManifestName, safeWriterGoldenManifest)\n\tpc.Load()\n\n\tsw, _ := NewSafeWriter(pc.Project.Manifest, nil, nil, VendorOnChanged, defaultCascadingPruneOptions(), nil)\n\n\t// Verify prepared actions\n\tif !sw.HasManifest() {\n\t\tt.Fatal(\"Expected the payload to contain the manifest\")\n\t}\n\tif sw.HasLock() {\n\t\tt.Fatal(\"Did not expect the payload to contain the lock\")\n\t}\n\tif sw.writeVendor {\n\t\tt.Fatal(\"Did not expect the payload to contain the vendor directory\")\n\t}\n\n\t// Write changes\n\terr := sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify file system changes\n\tif err := pc.ManifestShouldMatchGolden(safeWriterGoldenManifest); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.LockShouldNotExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorShouldNotExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSafeWriter_ManifestAndUnmodifiedLock(t *testing.T) {\n\ttest.NeedsExternalNetwork(t)\n\ttest.NeedsGit(t)\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.CopyFile(ManifestName, safeWriterGoldenManifest)\n\tpc.CopyFile(LockName, safeWriterGoldenLock)\n\tpc.Load()\n\n\tsw, _ := NewSafeWriter(pc.Project.Manifest, pc.Project.Lock, pc.Project.Lock, VendorOnChanged, defaultCascadingPruneOptions(), nil)\n\n\t// Verify prepared actions\n\tif !sw.HasManifest() {\n\t\tt.Fatal(\"Expected the payload to contain the manifest\")\n\t}\n\tif !sw.HasLock() {\n\t\tt.Fatal(\"Expected the payload to contain the lock.\")\n\t}\n\tif sw.writeLock {\n\t\tt.Fatal(\"Did not expect that the writer should plan to write the lock\")\n\t}\n\tif sw.writeVendor {\n\t\tt.Fatal(\"Did not expect the payload to contain the vendor directory\")\n\t}\n\n\t// Write changes\n\terr := sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify file system changes\n\tif err := pc.ManifestShouldMatchGolden(safeWriterGoldenManifest); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.LockShouldMatchGolden(safeWriterGoldenLock); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorShouldNotExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSafeWriter_ManifestAndUnmodifiedLockWithForceVendor(t *testing.T) {\n\ttest.NeedsExternalNetwork(t)\n\ttest.NeedsGit(t)\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.CopyFile(ManifestName, safeWriterGoldenManifest)\n\tpc.CopyFile(LockName, safeWriterGoldenLock)\n\tpc.Load()\n\n\tsw, _ := NewSafeWriter(pc.Project.Manifest, pc.Project.Lock, pc.Project.Lock, VendorAlways, defaultCascadingPruneOptions(), nil)\n\n\t// Verify prepared actions\n\tif !sw.HasManifest() {\n\t\tt.Fatal(\"Expected the payload to contain the manifest\")\n\t}\n\tif !sw.HasLock() {\n\t\tt.Fatal(\"Expected the payload to contain the lock\")\n\t}\n\tif sw.writeLock {\n\t\tt.Fatal(\"Did not expect that the writer should plan to write the lock\")\n\t}\n\tif !sw.writeVendor {\n\t\tt.Fatal(\"Expected the payload to contain the vendor directory\")\n\t}\n\n\t// Write changes\n\terr := sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify file system changes\n\tif err := pc.ManifestShouldMatchGolden(safeWriterGoldenManifest); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.LockShouldMatchGolden(safeWriterGoldenLock); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorShouldExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorFileShouldExist(\"github.com/sdboyer/dep-test\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSafeWriter_ForceVendorWhenVendorAlreadyExists(t *testing.T) {\n\ttest.NeedsExternalNetwork(t)\n\ttest.NeedsGit(t)\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.CopyFile(LockName, safeWriterGoldenLock)\n\tpc.Load()\n\n\tsw, _ := NewSafeWriter(nil, pc.Project.Lock, pc.Project.Lock, VendorAlways, defaultCascadingPruneOptions(), nil)\n\terr := sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify prepared actions\n\tsw, _ = NewSafeWriter(nil, nil, pc.Project.Lock, VendorAlways, defaultCascadingPruneOptions(), nil)\n\tif sw.HasManifest() {\n\t\tt.Fatal(\"Did not expect the payload to contain the manifest\")\n\t}\n\tif !sw.HasLock() {\n\t\tt.Fatal(\"Expected the payload to contain the lock\")\n\t}\n\tif !sw.writeLock {\n\t\tt.Fatal(\"Expected that the writer should plan to write the lock\")\n\t}\n\tif !sw.writeVendor {\n\t\tt.Fatal(\"Expected the payload to contain the vendor directory \")\n\t}\n\n\terr = sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify file system changes\n\tif err := pc.ManifestShouldNotExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.LockShouldMatchGolden(safeWriterGoldenLock); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorShouldExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorFileShouldExist(\"github.com/sdboyer/dep-test\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSafeWriter_NewLock(t *testing.T) {\n\ttest.NeedsExternalNetwork(t)\n\ttest.NeedsGit(t)\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.Load()\n\n\tlf := h.GetTestFile(safeWriterGoldenLock)\n\tdefer lf.Close()\n\tnewLock, err := readLock(lf)\n\th.Must(err)\n\tsw, _ := NewSafeWriter(nil, nil, newLock, VendorOnChanged, defaultCascadingPruneOptions(), nil)\n\n\t// Verify prepared actions\n\tif sw.HasManifest() {\n\t\tt.Fatal(\"Did not expect the payload to contain the manifest\")\n\t}\n\tif !sw.HasLock() {\n\t\tt.Fatal(\"Expected the payload to contain the lock\")\n\t}\n\tif !sw.writeLock {\n\t\tt.Fatal(\"Expected that the writer should plan to write the lock\")\n\t}\n\tif !sw.writeVendor {\n\t\tt.Fatal(\"Expected the payload to contain the vendor directory\")\n\t}\n\n\t// Write changes\n\terr = sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify file system changes\n\tif err := pc.ManifestShouldNotExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.LockShouldMatchGolden(safeWriterGoldenLock); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorShouldExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSafeWriter_NewLockSkipVendor(t *testing.T) {\n\ttest.NeedsExternalNetwork(t)\n\ttest.NeedsGit(t)\n\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\tpc.Load()\n\n\tlf := h.GetTestFile(safeWriterGoldenLock)\n\tdefer lf.Close()\n\tnewLock, err := readLock(lf)\n\th.Must(err)\n\tsw, _ := NewSafeWriter(nil, nil, newLock, VendorNever, defaultCascadingPruneOptions(), nil)\n\n\t// Verify prepared actions\n\tif sw.HasManifest() {\n\t\tt.Fatal(\"Did not expect the payload to contain the manifest\")\n\t}\n\tif !sw.HasLock() {\n\t\tt.Fatal(\"Expected the payload to contain the lock\")\n\t}\n\tif !sw.writeLock {\n\t\tt.Fatal(\"Expected that the writer should plan to write the lock\")\n\t}\n\tif sw.writeVendor {\n\t\tt.Fatal(\"Did not expect the payload to contain the vendor directory\")\n\t}\n\n\t// Write changes\n\terr = sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify file system changes\n\tif err := pc.ManifestShouldNotExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.LockShouldMatchGolden(safeWriterGoldenLock); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorShouldNotExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestHasDotGit(t *testing.T) {\n\t// Create a tempdir with .git file\n\ttd, err := ioutil.TempDir(os.TempDir(), \"dotGitFile\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(td)\n\n\tos.OpenFile(td+string(filepath.Separator)+\".git\", os.O_CREATE, 0777)\n\tif !hasDotGit(td) {\n\t\tt.Fatal(\"Expected hasDotGit to find .git\")\n\t}\n}\n\nfunc TestSafeWriter_VendorDotGitPreservedWithForceVendor(t *testing.T) {\n\th := test.NewHelper(t)\n\tdefer h.Cleanup()\n\n\tpc := NewTestProjectContext(h, safeWriterProject)\n\tdefer pc.Release()\n\n\tgitDirPath := filepath.Join(pc.Project.AbsRoot, \"vendor\", \".git\")\n\tos.MkdirAll(gitDirPath, 0777)\n\tdummyFile := filepath.Join(\"vendor\", \".git\", \"badinput_fileroot\")\n\tpc.CopyFile(dummyFile, \"txn_writer/badinput_fileroot\")\n\tpc.CopyFile(ManifestName, safeWriterGoldenManifest)\n\tpc.CopyFile(LockName, safeWriterGoldenLock)\n\tpc.Load()\n\n\tsw, _ := NewSafeWriter(pc.Project.Manifest, pc.Project.Lock, pc.Project.Lock, VendorAlways, defaultCascadingPruneOptions(), nil)\n\n\t// Verify prepared actions\n\tif !sw.HasManifest() {\n\t\tt.Fatal(\"Expected the payload to contain the manifest\")\n\t}\n\tif !sw.HasLock() {\n\t\tt.Fatal(\"Expected the payload to contain the lock\")\n\t}\n\tif sw.writeLock {\n\t\tt.Fatal(\"Did not expect that the writer should plan to write the lock\")\n\t}\n\tif !sw.writeVendor {\n\t\tt.Fatal(\"Expected the payload to contain the vendor directory\")\n\t}\n\n\terr := sw.Write(pc.Project.AbsRoot, pc.SourceManager, true, nil)\n\th.Must(errors.Wrap(err, \"SafeWriter.Write failed\"))\n\n\t// Verify file system changes\n\tif err := pc.ManifestShouldMatchGolden(safeWriterGoldenManifest); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.LockShouldMatchGolden(safeWriterGoldenLock); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorShouldExist(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorFileShouldExist(\"github.com/sdboyer/dep-test\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := pc.VendorFileShouldExist(\".git/badinput_fileroot\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}