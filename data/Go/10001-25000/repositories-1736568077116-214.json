{
  "metadata": {
    "timestamp": 1736568077116,
    "page": 214,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Shopify/toxiproxy",
      "stars": 10959,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.6044921875,
          "content": "# EditorConfig is awesome: https://EditorConfig.org\n\n# Unix-style newlines with a newline ending every file\n[*]\ncharset                  = utf-8\nend_of_line              = lf\ninsert_final_newline     = true\ntrim_trailing_whitespace = true\nmax_line_length          = 100\n\n[Makefile]\nindent_style = tab\n\n[{scripts/*, *.sh}]\nmax_line_length    = 80\nindent_style       = space\nindent_size        = 2\nshell_variant      = bash\nbinary_next_line   = true\nswitch_case_indent = true\nspace_redirects    = true\nkeep_padding       = true\n\n[*.{yaml,yml}]\nindent_style       = space\nindent_size        = 2\n\n[*.go]\nindent_style = tab\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0712890625,
          "content": "# goreleaser output directory\ndist/\n\n# go mod dependencies\nvendor/\n\ntmp/\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.576171875,
          "content": "---\nrun:\n  go: \"1.22\"\nlinters:\n  disable-all: true\n  enable:\n    - bodyclose\n    # https://github.com/atc0005/go-ci/issues/1024\n    # - depguard\n    - dogsled\n    - exhaustive\n    - funlen\n    - gocritic\n    - gocyclo\n    - godot\n    - gofmt\n    - goimports\n    - gosec\n    - gosimple\n    - govet\n    - ineffassign\n    - lll\n    - misspell\n    - staticcheck\n    - typecheck\n    - unused\n    - whitespace\n  fast: false\nlinters-settings:\n  gosec:\n    excludes:\n      - G107\n\n  funlen:\n    lines: 80\n    statements: 30\n\n  lll:\n    line-length: 100\n    tab-width: 2\n\n  misspell:\n    locale: US\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 6.646484375,
          "content": "---\n\nproject_name: toxiproxy\n\nenv:\n  - GO111MODULE=on\n\nbefore:\n  hooks:\n    - go mod download\n    - go mod tidy\n\nbuilds:\n  - &build_default\n    id: server\n    main: ./cmd/server\n    binary: toxiproxy-server-{{.Os}}-{{.Arch}}\n    no_unique_dist_dir: true\n    env:\n      - CGO_ENABLED=0\n\n    goos:\n      - darwin\n      - freebsd\n      - linux\n      - netbsd\n      - openbsd\n      - solaris\n      - windows\n\n    goarch:\n      - amd64\n      - arm64\n\n    ignore:\n      - goos: windows\n        goarch: arm64\n\n      - goarch: arm\n\n    ldflags:\n      - -s -w -X github.com/Shopify/toxiproxy/v2.Version={{.Version}}\n\n  - <<: *build_default\n    id: server-arm\n    goarch:\n      - arm\n    goarm:\n      - \"6\"\n      - \"7\"\n    ignore:\n      - goos: windows\n        goarch: arm\n    binary: toxiproxy-server-{{.Os}}-{{.Arch}}v{{.Arm}}\n\n  - &build_client\n    <<: *build_default\n    id: client\n    main: ./cmd/cli\n    binary: toxiproxy-cli-{{.Os}}-{{.Arch}}\n\n  - <<: *build_client\n    id: client-arm\n    goarch:\n      - arm\n    goarm:\n      - \"6\"\n      - \"7\"\n    ignore:\n      - goos: windows\n        goarch: arm\n    binary: toxiproxy-cli-{{.Os}}-{{.Arch}}v{{.Arm}}\n\n  - <<: *build_default\n    id: pkg-server\n    no_unique_dist_dir: false\n    binary: toxiproxy-server\n\n  - <<: *build_default\n    id: pkg-client\n    no_unique_dist_dir: false\n    main: ./cmd/cli\n    binary: toxiproxy-cli\n\nchecksum:\n  name_template: checksums.txt\n\nsnapshot:\n  name_template: \"{{ incpatch .Version }}-next\"\n\nnfpms:\n  - id: packages\n    package_name: toxiproxy\n    homepage: https://github.com/Shopify/toxiproxy\n    maintainer: Shopify Opensource <opensource@shopify.com>\n    description: TCP proxy to simulate network and system conditions.\n    license: MIT\n    bindir: /usr/bin\n    builds:\n      - pkg-server\n      - pkg-client\n    formats:\n      - apk\n      - deb\n      - rpm\n      # NOTE: Starting with Ubuntu 15.04, Upstart will be deprecated in favor of Systemd.\n      # contents:\n      #   - src: share/toxiproxy.conf\n      #     dst: /etc/init/toxiproxy.conf\n\ndockers:\n  - &docker\n    use: buildx\n    dockerfile: Dockerfile\n    ids:\n      - server\n      - client\n    goos: linux\n    goarch: amd64\n    image_templates:\n      - ghcr.io/shopify/toxiproxy:{{ .Version }}-amd64\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}-amd64\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}.{{ .Minor }}-amd64\n    build_flag_templates:\n      - --platform=linux/amd64\n      - --no-cache\n      - --label=org.opencontainers.image.title={{ .ProjectName }}\n      - --label=org.opencontainers.image.description={{ .ProjectName }}\n      - --label=org.opencontainers.image.url=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.source=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.version={{ .Version }}\n      - --label=org.opencontainers.image.created={{ time \"2006-01-02T15:04:05Z07:00\" }}\n      - --label=org.opencontainers.image.revision={{ .FullCommit }}\n      - --label=org.opencontainers.image.licenses=MIT\n  - <<: *docker\n    goarch: arm64\n    image_templates:\n      - ghcr.io/shopify/toxiproxy:{{ .Version }}-arm64\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}-arm64\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}.{{ .Minor }}-arm64\n    build_flag_templates:\n      - --platform=linux/arm64/v8\n      - --no-cache\n      - --label=org.opencontainers.image.title={{ .ProjectName }}\n      - --label=org.opencontainers.image.description={{ .ProjectName }}\n      - --label=org.opencontainers.image.url=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.source=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.version={{ .Version }}\n      - --label=org.opencontainers.image.created={{ time \"2006-01-02T15:04:05Z07:00\" }}\n      - --label=org.opencontainers.image.revision={{ .FullCommit }}\n      - --label=org.opencontainers.image.licenses=MIT\n  - <<: *docker\n    goarch: arm\n    goarm: \"7\"\n    image_templates:\n      - ghcr.io/shopify/toxiproxy:{{ .Version }}-armv7\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}-armv7\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}.{{ .Minor }}-armv7\n    build_flag_templates:\n      - --platform=linux/arm/v6\n      - --no-cache\n      - --label=org.opencontainers.image.title={{ .ProjectName }}\n      - --label=org.opencontainers.image.description={{ .ProjectName }}\n      - --label=org.opencontainers.image.url=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.source=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.version={{ .Version }}\n      - --label=org.opencontainers.image.created={{ time \"2006-01-02T15:04:05Z07:00\" }}\n      - --label=org.opencontainers.image.revision={{ .FullCommit }}\n      - --label=org.opencontainers.image.licenses=MIT\n  - <<: *docker\n    goarch: arm\n    goarm: \"6\"\n    image_templates:\n      - ghcr.io/shopify/toxiproxy:{{ .Version }}-armv6\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}-armv6\n      - ghcr.io/shopify/toxiproxy:v{{ .Major }}.{{ .Minor }}-armv6\n    build_flag_templates:\n      - --platform=linux/arm/v6\n      - --no-cache\n      - --label=org.opencontainers.image.title={{ .ProjectName }}\n      - --label=org.opencontainers.image.description={{ .ProjectName }}\n      - --label=org.opencontainers.image.url=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.source=https://github.com/Shopify/{{ .ProjectName }}\n      - --label=org.opencontainers.image.version={{ .Version }}\n      - --label=org.opencontainers.image.created={{ time \"2006-01-02T15:04:05Z07:00\" }}\n      - --label=org.opencontainers.image.revision={{ .FullCommit }}\n      - --label=org.opencontainers.image.licenses=MIT\n\ndocker_manifests:\n  - name_template: ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}\n    image_templates:\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-amd64\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-arm64\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-armv6\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-armv7\n  - name_template: ghcr.io/shopify/{{ .ProjectName }}:latest\n    image_templates:\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-amd64\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-arm64\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-armv6\n      - ghcr.io/shopify/{{ .ProjectName }}:{{ .Version }}-armv7\n\nchangelog:\n  sort: asc\n  filters:\n    exclude:\n      - \"^docs:\"\n      - \"^test:\"\n      - ^Merge\n\narchives:\n  - id: archive_binaries\n    format: binary\n    name_template: \"{{ .Binary }}\"\n    builds:\n      - server\n      - client\n\n  - id: archive_default\n    format: tar.gz\n    builds:\n      - pkg-server\n      - pkg-client\n"
        },
        {
          "name": ".yamllint.yml",
          "type": "blob",
          "size": 0.57421875,
          "content": "---\n\nyaml-files:\n  - \"*.yaml\"\n  - \"*.yml\"\n\nignore: |\n  vendor/**/*\n  dist/*.yaml\n  .github/**/*\n\nrules:\n  comments:\n    require-starting-space: true\n  comments-indentation: enable\n  document-start:\n    present: true\n  indentation:\n    spaces: 2\n    indent-sequences: true\n    check-multi-line-strings: true\n  line-length:\n    max: 100\n    level: warning\n    allow-non-breakable-words: true\n    allow-non-breakable-inline-mappings: false\n  key-duplicates: enable\n  new-lines:\n    type: unix\n  trailing-spaces: enable\n  quoted-strings:\n    quote-type: double\n    required: only-when-needed\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 10.6357421875,
          "content": "# [Unreleased]\n\n# [2.11.0] - 2024-10-16\n\n- Do not pin minimum patch version in module (#595, @jaimem88)\n\n# [2.10.0] - 2024-10-08\n\n- Update various go packages\n- Update go version to 1.22.8 (#594, @abecevello)\n\n# [2.9.0] - 2024-03-12\n\n- Updated go version to 1.22.1 to fix 3 CVEs (#559, @dianadevasia)\n- Updated the version of golangci to 1.56.2 and disabled depguard rule in golangci (#559, @dianadevasia)\n\n# [2.8.0] - 2024-02-27\n\n- toxiproxy-cli - sortedAttributes sort by attribute.key instead attribute.value (#543, @jesseward)\n\n# [2.7.0] - 2023-10-25\n\n- Fix invalid JSON in /version endpoint response (#538, @whatyouhide)\n- Update minimum supported Go version 1.19. (@abecevello)\n\n# [2.6.0] - 2023-08-22\n\n- Gracefull shutdown of HTTP server. (#439, @miry)\n- Support PATCH HTTP method for Proxy update(`PATCH /proxies/{proxy}`) and\n  Toxic update(`PATCH /proxies/{proxy}/toxics/{toxic}`) endpoints.\n  Deprecat POST HTTP method for those endpoints. (@miry)\n- Client does not parse response body in case of errors for Populate.\n  Requires to get current proxies with new command. (#441, @miry)\n- Client specifies `User-Agent` HTTP header for all requests as\n  \"toxiproxy-cli/<version> <os>/<runtime>\".\n  Specifies client request content type as `application/json`. (#441, @miry)\n- Replace Api.Listen parameters `host` and `port` with single `addr`. (#445, @miry)\n\n# [2.5.0] - 2022-09-10\n\n- Update Release steps. (#369, @neufeldtech)\n- Migrate off probot-CLA to new GitHub Action. (#405, @cursedcoder)\n- Support go 1.18, 1.19. (#415, @miry)\n- `toxiproxy.NewProxy` now accepts `name`, `listen addr` and `upstream addr`. (#418, @miry)\n- Replace logrus with zerolog. (#413, @miry)\n- Log HTTP requests to API server. (#413, #421, @miry)\n- Add TimeoutHandler for the HTTP API server. (#420, @miry)\n- Set Write and Read timeouts for HTTP API server connections. (#423, @miry)\n- Show unique request id in API HTTP response. (#425, @miry)\n- Add method to parse `stream.Direction` from a string.\n  Allow converting `stream.Direction` to string. (#430, @miry)\n- Add the possibility to write to Output with a deadline.\n  On interrupting Bandwidth toxic, use non-blocking writes. (#436, @miry)\n- Update minimum supported Go version 1.17. (#438, @miry)\n\n# [2.4.0] - 2022-03-07\n\n- Verify git tag on release (#347, @miry)\n- Fix MacOS 12 tests for go17 with -race flag (#351, @strech)\n- Rename `testing/` and `bin/` folders (#354, @strech)\n- Added verbose error on proxy upstream dialing (#355, @f-dg)\n- Improve server startup message (#358, @areveny)\n- Introduce yaml linter. (#362, @miry)\n- Handle slicer toxic with zero `SizeVariation` and fix slicing randomization (#359, @areveny)\n- Added /metrics endpoint for exposing Prometheus-compatible internal metrics (#366, @neufeldtech)\n\n# [2.3.0] - 2021-12-23\n\n- Store all the executable `main` packages in `cmd` folder. (#335, @miry)\n- Extract common test helpers to own files. (#336, @miry)\n- Client: Allow HTTPS endpoints. (#338, @chen-anders)\n- client.Populate assign client to proxy. (#291, @hellodudu)\n- fix: The release-test task is always success.\n  add: Allow to run release-test on arm machines. (#340, @miry)\n- Upgrade `goreleaser`. Support `armv7` and `armv6` oses. (#339, @mitchellrj)\n- Allow to change log level for server. (#346, @miry)\n\n# [2.2.0] - 2021-10-17\n\n- Update linux packages to use `/usr/bin` folder as binary destination and change the executable names to\n  exclude ARCH and OS names. New pathes:\n  ```\n  /usr/bin/toxiproxy-cli\n  /usr/bin/toxiproxy-server\n  ```\n  (#331, @miry)\n- A new toxic to simulate TCP RESET (Connection reset by peer) on the connections by closing\n  the stub Input immediately or after a timeout. (#247 and #333, @chaosbox)\n\n# [2.1.7] - 2021-09-23\n\n- Set the valid version during the build process.\n  Verify the correct verion of the built binaries with `make release-dry` (#328, @miry)\n\n# [2.1.6] - 2021-09-23\n\n- Use CHANGELOG.md for release description (#306, @miry)\n- Dependency updates in #294 introduced a breaking change in CLI argument parsing.\n  Now [flags must be specified before arguments](https://github.com/urfave/cli/blob/master/docs/migrate-v1-to-v2.md#flags-before-args).\n  Previously, arguments could be specified prior to flags.\n  Update usage help text and documentation. (#308, @miry)\n- Run e2e tests to validate the command line and basic features of server,\n  client and application (#309, @miry)\n- Add /v2 suffix to module import path (#311, @dnwe)\n- Setup automated checking source code for security vulnerabilities (#312, @miry)\n- Setup code linter (#314, @miry)\n  - Max line length is 100 characters (#316, @miry)\n  - Linter to check whether HTTP response body is closed successfully (#317, @miry)\n  - Make sure the function are not big (#318, @miry)\n    - Extract client flags specs to seprate methods.\n      Introduce a new way to manage toxics with `ToxicOptions` structure (#321, @miry)\n    - Split `Proxy.server` to multiple small (#322, @miry)\n    - Extract initializetion of fake upstream server to test helper (#323, @miry)\n    - Support a list of well knonwn linters (#326, @miry)\n- `--host` flag uses `TOXIPROXY_URL` if it is set (#319, @maaslalani)\n- Run benchmarks in CI/CD (#320, @miry)\n- Use scratch docker base image instead of alpine (#325, @miry)\n\n# [2.1.5] - 2021-09-01\n\n- Move to Go Modules from godeps (#253, @epk)\n- Update the example in `client/README.md` (#251, @nothinux)\n- Update TOC in `README.md` (4ca1eddddfcd0c50c8f6dfb97089bb68e6310fd9, @dwradcliffe)\n- Add an example of `config.json` file to `README.md` (#260, @JesseEstum)\n- Add Link to Elixir Client (#287, @Jcambass)\n- Add Rust client link (#293, @itarato)\n- Renovations: formatting code, update dependicies, make govet/staticcheck pass (#294, @dnwe)\n- Remove `openssl` from `dev.yml` to use `dev` tool (#298, @pedro-stanaka)\n- Update `go` versions in development (#299, @miry)\n- Mention `MacPorts` in `README.md` (#290, @amake)\n- Fix some typos in `README.md` and `CHANGELOG.md` (#222, @jwilk)\n- Replace TravisCI with Github Actions to run tests (#303, @miry)\n- Build and release binaries with `goreleaser`. Support `arm64` and BSD oses. (#301, @miry)\n- Automate release with Github actions (#304, @miry)\n\n# [2.1.4] - 2019-01-11\n\n- Bug fix: Fix OOM in toxic. #232\n- Documentation updates.\n- CI and test updates.\n\n# [2.1.3] - 2018-03-05\n\n- Update `/version` endpoint to also return a charset of utf-8. #204\n- Bug fix: Double http concatenation. #191\n- Update cli examples to be more accurate. #187\n\n# [2.1.2] - 2017-07-10\n\n- go 1.8, make Sirupsen lower case, update godeps (issue #179)\n- Handle SIGTERM to exit cleanly (issue #180)\n- Address security issue by disallowing browsers from accessing API\n\n# [2.1.1] - 2017-05-16\n\n- Fix timeout toxic causing hang (issue #159)\n\n# [2.1.0] - 2016-12-07\n\n- Add -config server option to populate on startup #154\n- Updated CLI for scriptability #133\n- Add `/populate` endpoint to server #111\n- Change error responses from `title` to `error`\n- Allow hostname to be specified in CLI #129\n- Add support for stateful toxics #127\n- Add limit_data toxic\n\n# [2.0.0] - 2016-04-25\n\n- Add CLI (`toxiproxy-cli`) and rename server binary to `toxiproxy-server` #93\n- Fix removing a timeout toxic causing API to hang #89\n- API and client return toxics as array rather than a map of name to toxic #92\n- Fix multiple latency toxics not accumulating #94\n- Change default toxic name to `<type>_<stream>` #96\n- Nest toxic attributes rather than having a flat structure #98\n- 2.0 RFC: #54 and PR #62\n  - Change toxic API endpoints to an Add/Update/Remove structure\n  - Remove `enabled` field, and add `name` and `type` fields to toxics\n  - Add global toxic fields to a wrapper struct\n  - Chain toxics together dynamically instead of in a fixed length chain\n  - Register toxics in `init()` functions instead of a hard-coded list\n  - Clean up API error codes to make them more consistent\n  - Move toxics to their own package to allow 3rd party toxics\n- Remove stream direction from API urls #73\n- Add `toxicity` field for toxics #75\n- Refactor Go client to make usage easier with 2.0 #76\n- Make `ChanReader` in the `stream` package interruptible #77\n- Define proxy buffer sizes per-toxic (Fixes #72)\n- Fix slicer toxic testing race condition #71\n\n# [1.2.1] - 2015-07-24\n\n- Fix proxy name conflicts leaking an open port #69\n\n# [1.2.0] - 2015-07-23\n\n- Add a Toxic and Toxics type for the Go client\n- Add `Dockerfile`\n- Fix latency toxic limiting bandwidth #67\n- Add Slicer toxic\n\n# [1.1.0] - 2015-05-05\n\n- Remove /toxics endpoint in favour of /proxies\n- Add bandwidth toxic\n\n# [1.0.3] - 2015-04-29\n\n- Rename Go library package to Toxiproxy from Client\n- Fix latency toxic send to closed channel panic #46\n- Fix latency toxic accumulating delay #47\n\n# [1.0.2] - 2015-04-12\n\n- Added Toxic support to Go client\n\n# [1.0.1] - 2015-03-31\n\n- Various improvements to the documentation\n- Initial version of Go client\n- Fix toxic disabling bug #42\n\n# [1.0.0] - 2015-01-07\n\nInitial public release.\n\n[Unreleased]: https://github.com/Shopify/toxiproxy/compare/v2.11.0...HEAD\n[2.11.0]: https://github.com/Shopify/toxiproxy/compare/v2.10.0...v2.11.0\n[2.10.0]: https://github.com/Shopify/toxiproxy/compare/v2.9.0...v2.10.0\n[2.9.0]: https://github.com/Shopify/toxiproxy/compare/v2.8.0...v2.9.0\n[2.8.0]: https://github.com/Shopify/toxiproxy/compare/v2.7.0...v2.8.0\n[2.7.0]: https://github.com/Shopify/toxiproxy/compare/v2.6.0...v2.7.0\n[2.6.0]: https://github.com/Shopify/toxiproxy/compare/v2.5.0...v2.6.0\n[2.5.0]: https://github.com/Shopify/toxiproxy/compare/v2.4.0...v2.5.0\n[2.4.0]: https://github.com/Shopify/toxiproxy/compare/v2.3.0...v2.4.0\n[2.3.0]: https://github.com/Shopify/toxiproxy/compare/v2.2.0...v2.3.0\n[2.2.0]: https://github.com/Shopify/toxiproxy/compare/v2.1.7...v2.2.0\n[2.1.7]: https://github.com/Shopify/toxiproxy/compare/v2.1.6...v2.1.7\n[2.1.6]: https://github.com/Shopify/toxiproxy/compare/v2.1.5...v2.1.6\n[2.1.5]: https://github.com/Shopify/toxiproxy/compare/v2.1.4...v2.1.5\n[2.1.4]: https://github.com/Shopify/toxiproxy/compare/v2.1.3...v2.1.4\n[2.1.3]: https://github.com/Shopify/toxiproxy/compare/v2.1.2...v2.1.3\n[2.1.2]: https://github.com/Shopify/toxiproxy/compare/v2.1.1...v2.1.2\n[2.1.1]: https://github.com/Shopify/toxiproxy/compare/v2.1.0...v2.1.1\n[2.1.0]: https://github.com/Shopify/toxiproxy/compare/v2.0.0...v2.1.0\n[2.0.0]: https://github.com/Shopify/toxiproxy/compare/v1.2.1...v2.0.0\n[1.2.1]: https://github.com/Shopify/toxiproxy/compare/v1.2.0...v1.2.1\n[1.2.0]: https://github.com/Shopify/toxiproxy/compare/v1.1.0...v1.2.0\n[1.1.0]: https://github.com/Shopify/toxiproxy/compare/v1.0.3...v1.1.0\n[1.0.3]: https://github.com/Shopify/toxiproxy/compare/v1.0.2...v1.0.3\n[1.0.2]: https://github.com/Shopify/toxiproxy/compare/v1.0.1...v1.0.2\n[1.0.1]: https://github.com/Shopify/toxiproxy/compare/v1.0.0...v1.0.1\n[1.0.0]: https://github.com/Shopify/toxiproxy/releases/tag/v1.0.0\n"
        },
        {
          "name": "CREATING_TOXICS.md",
          "type": "blob",
          "size": 6.2646484375,
          "content": "# Creating custom toxics\n\nCreating a toxic is done by implementing the `Toxic` interface:\n\n```go\ntype Toxic interface {\n    Pipe(*toxics.ToxicStub)\n}\n```\n\nThe `Pipe()` function defines how data flows through the toxic, and is passed a\n`ToxicStub` to operate on. A `ToxicStub` stores the input and output channels for\nthe toxic, as well as an interrupt channel that is used to pause operation of the\ntoxic.\n\nThe input and output channels in a `ToxicStub` send and receive `StreamChunk` structs,\nwhich are similar to network packets. A `StreamChunk` contains a `byte[]` of stream\ndata, and a timestamp of when Toxiproxy received the data from the client or server.\nThis is used instead of just a plain `byte[]` so that toxics like latency can find out\nhow long a chunk of data has been waiting in the proxy.\n\nToxics are registered in an `init()` function so that they can be used by the server:\n\n```go\nfunc init() {\n    toxics.Register(\"toxic_name\", new(ExampleToxic))\n}\n```\n\nIn order to use your own toxics, you will need to compile your own binary.\nThis can be done by copying [server](./cmd/server/server.go)\ninto a new project and registering your toxic with the server.\nThis will allow you to add toxics without having to make a full fork of the project.\nIf you think your toxics will be useful to others,\ncontribute them back with a Pull Request.\n\nAn example project for building a separate binary can be found here:\n[examples](./_examples/toxics/)\n\n## A basic toxic\n\nThe most basic implementation of a toxic is the [noop toxic](./toxics/noop.go),\nwhich just passes data through without any modifications.\n\n```go\ntype NoopToxic struct{}\n\nfunc (t *NoopToxic) Pipe(stub *toxics.ToxicStub) {\n    for {\n        select {\n        case <-stub.Interrupt:\n            return\n        case c := <-stub.Input:\n            if c == nil {\n                stub.Close()\n                return\n            }\n            stub.Output <- c\n        }\n    }\n}\n```\n\nThe above code reads from `stub.Input` in a loop, and passes the `StreamChunk` along to\n`stub.Output`. Since reading from `stub.Input` will block until a chunk is available,\nwe need to check for interrupts as the same time.\n\nToxics will be interrupted whenever they are being updated, or possibly removed. This can\nhappen at any point within the `Pipe()` function, so all blocking operations (including sleep),\nshould be interruptible. When an interrupt is received, the toxic should return from the `Pipe()`\nfunction after it has written any \"in-flight\" data back to `stub.Output`. It is important that\nall data read from `stub.Input` is passed along to `stub.Output`, otherwise the stream will be\nmissing bytes and become corrupted.\n\nWhen an `end of stream` is reached, `stub.Input` will return a `nil` chunk. Whenever a\nnil chunk is returned, the toxic should call `Close()` on the stub, and return from `Pipe()`.\n\n## Toxic configuration\n\nToxic configuration information can be stored in the toxic struct. The toxic will be json\nencoded and decoded by the api, so all public fields will be api accessible.\n\nAn example of a toxic that uses configuration values is the [latency toxic](./toxics/latency.go)\n\n```go\ntype LatencyToxic struct {\n    Latency int64 `json:\"latency\"`\n    Jitter  int64 `json:\"jitter\"`\n}\n```\n\nThese fields can be used inside the `Pipe()` function, but generally should not be written\nto from the toxic. A separate instance of the toxic exists for each connection through the\nproxy, and may be replaced when updated by the api. If state is required in your toxic, it\nis better to use a local variable at the top of `Pipe()`, since struct fields are not\nguaranteed to be persisted across interrupts.\n\n## Toxic buffering\n\nBy default, toxics are not buffered. This means that writes to `stub.Output` will block until\neither the endpoint or another toxic reads it. Since toxics are chained together, this means\nnot reading from `stub.Input` will block other toxics (and endpoint writes) from operating.\nIf this is not behavior you want your toxic to have, you can specify a buffer size for your\ntoxic's input. The [latency toxic](./toxics/latency.go)\nuses this in order to prevent added latency from limiting the proxy bandwidth.\n\nSpecifying a buffer size is done by implementing the `BufferedToxic` interface, which adds the\n`GetBufferSize()` function:\n\n```go\nfunc (t *LatencyToxic) GetBufferSize() int {\n    return 1024\n}\n```\n\nThe unit used by `GetBufferSize()` is `StreamChunk`s. Chunks are generally anywhere from\n1 byte, up to 32KB, so keep this in mind when thinking about how much buffering you need,\nand how much memory you are comfortable with using.\n\n## Stateful toxics\n\nIf a toxic needs to store extra information for a connection such as the number of bytes\ntransferred (See `limit_data` toxic), a state object can be created by implementing the\n`StatefulToxic` interface. This interface defines the `NewState()` function that can create\na new state object with default values set.\n\nWhen a stateful toxic is created, the state object will be stored on the `ToxicStub` and\ncan be accessed from `toxic.Pipe()`:\n\n```go\nstate := stub.State.(*ExampleToxicState)\n```\n\nIf necessary, some global state can be stored in the toxic struct, which will not be\ninstanced per-connection. These fields cannot have a custom default value set and will\nnot be thread-safe, so proper locking or atomic operations will need to be used.\n\n## Using `io.Reader` and `io.Writer`\n\nIf your toxic involves modifying the data going through a proxy, you can use the `ChanReader`\nand `ChanWriter` interfaces in the [stream package](./stream).\nThese allow reading and writing from the input and output channels as you would a normal data\nstream such as a TCP socket.\n\nAn implementation of the noop toxic above using the stream package would look something like this:\n\n```go\nfunc (t *NoopToxic) Pipe(stub *toxics.ToxicStub) {\n    buf := make([]byte, 32*1024)\n    writer := stream.NewChanWriter(stub.Output)\n    reader := stream.NewChanReader(stub.Input)\n    reader.SetInterrupt(stub.Interrupt)\n    for {\n        n, err := reader.Read(buf)\n        if err == stream.ErrInterrupted {\n            writer.Write(buf[:n])\n            return\n        } else if err == io.EOF {\n            stub.Close()\n            return\n        }\n        writer.Write(buf[:n])\n    }\n}\n```\n\nSee [examples](./_examples/toxics/) for a full example of using\nthe stream package with Go's http package.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.173828125,
          "content": "FROM scratch\n\nEXPOSE 8474\nENTRYPOINT [\"/toxiproxy\"]\nCMD [\"-host=0.0.0.0\"]\n\nENV LOG_LEVEL=info\n\nCOPY toxiproxy-server-linux-* /toxiproxy\nCOPY toxiproxy-cli-linux-* /toxiproxy-cli\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0498046875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Shopify\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "METRICS.md",
          "type": "blob",
          "size": 1.8486328125,
          "content": "# Metrics\n\n- [Metrics](#metrics)\n    - [Runtime Metrics](#runtime-metrics)\n    - [Proxy Metrics](#proxy-metrics)\n      - [toxiproxy_proxy_received_bytes_total / toxiproxy_proxy_sent_bytes_total](#toxiproxy_proxy_received_bytes_total--toxiproxy_proxy_sent_bytes_total)\n\n### Runtime Metrics\n\nTo enable runtime metrics related to the state of the go runtime, build version, process info, use the `-runtime-metrics` flag.\n\nFor more details, see below:\n- [NewGoCollector](https://pkg.go.dev/github.com/prometheus/client_golang/prometheus/collectors#NewGoCollector)\n- [NewBuildInfoCollector](https://pkg.go.dev/github.com/prometheus/client_golang/prometheus/collectors#NewBuildInfoCollector)\n- [NewProcessCollector](https://pkg.go.dev/github.com/prometheus/client_golang/prometheus/collectors#NewProcessCollector)\n\n### Proxy Metrics\n\nTo enable metrics related to toxiproxy internals, use the `-proxy-metrics` flag.\n#### toxiproxy_proxy_received_bytes_total / toxiproxy_proxy_sent_bytes_total\n\nThe total number of bytes received/sent on a given proxy link in a given direction\n\n```mermaid\nsequenceDiagram\n    Client->>+Toxiproxy: toxiproxy_proxy_received_bytes_total{direction=\"upstream\"}\n    Toxiproxy->>+Server: toxiproxy_proxy_sent_bytes_total{direction=\"upstream\"}\n    Server->>+Toxiproxy: toxiproxy_proxy_received_bytes_total{direction=\"downstream\"}\n    Toxiproxy->>+Client: toxiproxy_proxy_sent_bytes_total{direction=\"downstream\"}\n```\n\n**Type**\n\nCounter\n\n**Labels**\n\n| Label     | Description                    | Example               |\n|-----------|--------------------------------|-----------------------|\n| direction | Direction of the link          | upstream / downstream |\n| listener  | Listener address of this proxy | 0.0.0.0:8080          |\n| proxy     | Proxy name                     | my-proxy              |\n| upstream  | Upstream address of this proxy | httpbin.org:80        |\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.884765625,
          "content": "OS := $(shell uname -s)\nARCH := $(shell uname -m)\nGO_VERSION := $(shell go version | cut -f3 -d\" \")\nGO_MINOR_VERSION := $(shell echo $(GO_VERSION) | cut -f2 -d.)\nGO_PATCH_VERSION := $(shell echo $(GO_VERSION) | cut -f3 -d. | sed \"s/^\\s*$$/0/\")\nMALLOC_ENV := $(shell [ $(OS) = Darwin -a $(GO_MINOR_VERSION) -eq 17 -a $(GO_PATCH_VERSION) -lt 6 ] && echo \"MallocNanoZone=0\")\n\n.PHONY: all\nall: setup build test bench fmt lint\n\n.PHONY: test\ntest:\n\t# NOTE: https://github.com/golang/go/issues/49138\n\t$(MALLOC_ENV) go test -v -race -timeout 1m ./...\n\n.PHONY: test-e2e\ntest-e2e: build container.build\n\tscripts/test-e2e\n\ttimeout -v --foreground 20m scripts/test-e2e-hazelcast toxiproxy\n\n.PHONY: test-release\ntest-release: lint fmt test bench test-e2e release-dry\n\tscripts/test-release\n\n.PHONY: bench\nbench:\n\t# TODO: Investigate why benchmarks require more sockets: ulimit -n 10240\n\tgo test -bench=. -v *.go\n\tgo test -bench=. -v toxics/*.go\n\n.PHONY: fmt\nfmt:\n\tgo fmt ./...\n\tgoimports -w **/*.go\n\tgolangci-lint run --fix\n\tshfmt -l -s -w -kp -i 2 scripts/test-*\n\n.PHONY: lint\nlint:\n\tgolangci-lint run\n\tshellcheck scripts/test-*\n\tshfmt -l -s -d -kp -i 2 scripts/test-*\n\tyamllint .\n\n.PHONY: build\nbuild: dist clean\n\tgo build -ldflags=\"-s -w\" -o ./dist/toxiproxy-server ./cmd/server\n\tgo build -ldflags=\"-s -w\" -o ./dist/toxiproxy-cli ./cmd/cli\n\n.PHONY: container.build\ncontainer.build:\n\tenv GOOS=linux CGO_ENABLED=0 go build -ldflags=\"-s -w\" -o ./dist/toxiproxy-server-linux-$(ARCH) ./cmd/server\n\tenv GOOS=linux CGO_ENABLED=0 go build -ldflags=\"-s -w\" -o ./dist/toxiproxy-cli-linux-$(ARCH) ./cmd/cli\n\tdocker build -f Dockerfile -t toxiproxy dist\n\tdocker run --rm toxiproxy --version\n\n.PHONY: release\nrelease:\n\tgoreleaser release --rm-dist\n\n.PHONY: release-dry\nrelease-dry:\n\tgoreleaser release --rm-dist --skip-publish --skip-validate\n\n.PHONY: setup\nsetup:\n\tgo mod download\n\tgo mod tidy\n\ndist:\n\tmkdir -p dist\n\n.PHONY: clean\nclean:\n\trm -fr dist/*\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 19.4658203125,
          "content": "# Toxiproxy\n[![GitHub release](https://img.shields.io/github/release/Shopify/toxiproxy.svg)](https://github.com/Shopify/toxiproxy/releases/latest)\n![Build Status](https://github.com/Shopify/toxiproxy/actions/workflows/test.yml/badge.svg)\n\n![](http://i.imgur.com/sOaNw0o.png)\n\nToxiproxy is a framework for simulating network conditions. It's made\nspecifically to work in testing, CI and development environments, supporting\ndeterministic tampering with connections, but with support for randomized chaos\nand customization. **Toxiproxy is the tool you need to prove with tests that\nyour application doesn't have single points of failure.** We've been\nsuccessfully using it in all development and test environments at Shopify since\nOctober, 2014. See our [blog post][blog] on resiliency for more information.\n\nToxiproxy usage consists of two parts. A TCP proxy written in Go (what this\nrepository contains) and a client communicating with the proxy over HTTP. You\nconfigure your application to make all test connections go through Toxiproxy\nand can then manipulate their health via HTTP. See [Usage](#usage)\nbelow on how to set up your project.\n\nFor example, to add 1000ms of latency to the response of MySQL from the [Ruby\nclient](https://github.com/Shopify/toxiproxy-ruby):\n\n```ruby\nToxiproxy[:mysql_master].downstream(:latency, latency: 1000).apply do\n  Shop.first # this takes at least 1s\nend\n```\n\nTo take down all Redis instances:\n\n```ruby\nToxiproxy[/redis/].down do\n  Shop.first # this will throw an exception\nend\n```\n\nWhile the examples in this README are currently in Ruby, there's nothing\nstopping you from creating a client in any other language (see\n[Clients](#clients)).\n\n## Table of Contents\n\n- [Toxiproxy](#toxiproxy)\n  - [Table of Contents](#table-of-contents)\n  - [Why yet another chaotic TCP proxy?](#why-yet-another-chaotic-tcp-proxy)\n  - [Clients](#clients)\n  - [Example](#example)\n  - [Usage](#usage)\n    - [1. Installing Toxiproxy](#1-installing-toxiproxy)\n      - [Upgrading from Toxiproxy 1.x](#upgrading-from-toxiproxy-1x)\n    - [2. Populating Toxiproxy](#2-populating-toxiproxy)\n    - [3. Using Toxiproxy](#3-using-toxiproxy)\n    - [4. Logging](#4-logging)\n    - [Toxics](#toxics)\n      - [latency](#latency)\n      - [down](#down)\n      - [bandwidth](#bandwidth)\n      - [slow_close](#slow_close)\n      - [timeout](#timeout)\n      - [reset_peer](#reset_peer)\n      - [slicer](#slicer)\n      - [limit_data](#limit_data)\n    - [HTTP API](#http-api)\n      - [Proxy fields:](#proxy-fields)\n      - [Toxic fields:](#toxic-fields)\n      - [Endpoints](#endpoints)\n      - [Populating Proxies](#populating-proxies)\n    - [CLI Example](#cli-example)\n    - [Metrics](#metrics)\n    - [Frequently Asked Questions](#frequently-asked-questions)\n    - [Development](#development)\n    - [Release](#release)\n\n## Why yet another chaotic TCP proxy?\n\nThe existing ones we found didn't provide the kind of dynamic API we needed for\nintegration and unit testing. Linux tools like `nc` and so on are not\ncross-platform and require root, which makes them problematic in test,\ndevelopment and CI environments.\n\n## Clients\n\n* [toxiproxy-ruby](https://github.com/Shopify/toxiproxy-ruby)\n* [toxiproxy-go](https://github.com/Shopify/toxiproxy/tree/main/client)\n* [toxiproxy-python](https://github.com/douglas/toxiproxy-python)\n* [toxiproxy.net](https://github.com/mdevilliers/Toxiproxy.Net)\n* [toxiproxy-php-client](https://github.com/ihsw/toxiproxy-php-client)\n* [toxiproxy-node-client](https://github.com/ihsw/toxiproxy-node-client)\n* [toxiproxy-java](https://github.com/trekawek/toxiproxy-java)\n* [toxiproxy-haskell](https://github.com/jpittis/toxiproxy-haskell)\n* [toxiproxy-rust](https://github.com/itarato/toxiproxy_rust)\n* [toxiproxy-elixir](https://github.com/Jcambass/toxiproxy_ex)\n\n## Example\n\nLet's walk through an example with a Rails application. Note that Toxiproxy is\nin no way tied to Ruby, it's just been our first use case. You can see the full example at\n[sirupsen/toxiproxy-rails-example](https://github.com/sirupsen/toxiproxy-rails-example).\nTo get started right away, jump down to [Usage](#usage).\n\nFor our popular blog, for some reason we're storing the tags for our posts in\nRedis and the posts themselves in MySQL. We might have a `Post` class that\nincludes some methods to manipulate tags in a [Redis set](http://redis.io/commands#set):\n\n```ruby\nclass Post < ActiveRecord::Base\n  # Return an Array of all the tags.\n  def tags\n    TagRedis.smembers(tag_key)\n  end\n\n  # Add a tag to the post.\n  def add_tag(tag)\n    TagRedis.sadd(tag_key, tag)\n  end\n\n  # Remove a tag from the post.\n  def remove_tag(tag)\n    TagRedis.srem(tag_key, tag)\n  end\n\n  # Return the key in Redis for the set of tags for the post.\n  def tag_key\n    \"post:tags:#{self.id}\"\n  end\nend\n```\n\nWe've decided that erroring while writing to the tag data store\n(adding/removing) is OK. However, if the tag data store is down, we should be\nable to see the post with no tags. We could simply rescue the\n`Redis::CannotConnectError` around the `SMEMBERS` Redis call in the `tags`\nmethod. Let's use Toxiproxy to test that.\n\nSince we've already installed Toxiproxy and it's running on our machine, we can\nskip to step 2. This is where we need to make sure Toxiproxy has a mapping for\nRedis tags. To `config/boot.rb` (before any connection is made) we add:\n\n```ruby\nrequire 'toxiproxy'\n\nToxiproxy.populate([\n  {\n    name: \"toxiproxy_test_redis_tags\",\n    listen: \"127.0.0.1:22222\",\n    upstream: \"127.0.0.1:6379\"\n  }\n])\n```\n\nThen in `config/environments/test.rb` we set the `TagRedis` to be a Redis client\nthat connects to Redis through Toxiproxy by adding this line:\n\n```ruby\nTagRedis = Redis.new(port: 22222)\n```\n\nAll calls in the test environment now go through Toxiproxy. That means we can\nadd a unit test where we simulate a failure:\n\n```ruby\ntest \"should return empty array when tag redis is down when listing tags\" do\n  @post.add_tag \"mammals\"\n\n  # Take down all Redises in Toxiproxy\n  Toxiproxy[/redis/].down do\n    assert_equal [], @post.tags\n  end\nend\n```\n\nThe test fails with `Redis::CannotConnectError`. Perfect! Toxiproxy took down\nthe Redis successfully for the duration of the closure. Let's fix the `tags`\nmethod to be resilient:\n\n```ruby\ndef tags\n  TagRedis.smembers(tag_key)\nrescue Redis::CannotConnectError\n  []\nend\n```\n\nThe tests pass! We now have a unit test that proves fetching the tags when Redis\nis down returns an empty array, instead of throwing an exception. For full\ncoverage you should also write an integration test that wraps fetching the\nentire blog post page when Redis is down.\n\nFull example application is at\n[sirupsen/toxiproxy-rails-example](https://github.com/sirupsen/toxiproxy-rails-example).\n\n## Usage\n\nConfiguring a project to use Toxiproxy consists of three steps:\n\n1. Installing Toxiproxy\n2. Populating Toxiproxy\n3. Using Toxiproxy\n\n### 1. Installing Toxiproxy\n\n**Linux**\n\nSee [`Releases`](https://github.com/Shopify/toxiproxy/releases) for the latest\nbinaries and system packages for your architecture.\n\n**Ubuntu**\n\n```bash\n$ wget -O toxiproxy-2.1.4.deb https://github.com/Shopify/toxiproxy/releases/download/v2.1.4/toxiproxy_2.1.4_amd64.deb\n$ sudo dpkg -i toxiproxy-2.1.4.deb\n$ sudo service toxiproxy start\n```\n\n**OS X**\n\nWith [Homebrew](https://brew.sh/):\n\n```bash\n$ brew tap shopify/shopify\n$ brew install toxiproxy\n```\n\nOr with [MacPorts](https://www.macports.org/):\n\n```bash\n$ port install toxiproxy\n```\n\n**Windows**\n\nToxiproxy for Windows is available for download at https://github.com/Shopify/toxiproxy/releases/download/v2.1.4/toxiproxy-server-windows-amd64.exe\n\n**Docker**\n\nToxiproxy is available on [Github container registry](https://github.com/Shopify/toxiproxy/pkgs/container/toxiproxy).\nOld versions `<= 2.1.4` are available on on [Docker Hub](https://hub.docker.com/r/shopify/toxiproxy/).\n\n```bash\n$ docker pull ghcr.io/shopify/toxiproxy\n$ docker run --rm -it ghcr.io/shopify/toxiproxy\n```\n\nIf using Toxiproxy from the host rather than other containers, enable host networking with `--net=host`.\n\n```shell\n$ docker run --rm --entrypoint=\"/toxiproxy-cli\" -it ghcr.io/shopify/toxiproxy list\n```\n\n**Source**\n\nIf you have Go installed, you can build Toxiproxy from source using the make file:\n```bash\n$ make build\n$ ./toxiproxy-server\n```\n\n#### Upgrading from Toxiproxy 1.x\n\nIn Toxiproxy 2.0 several changes were made to the API that make it incompatible with version 1.x.\nIn order to use version 2.x of the Toxiproxy server, you will need to make sure your client\nlibrary supports the same version. You can check which version of Toxiproxy you are running by\nlooking at the `/version` endpoint.\n\nSee the documentation for your client library for specific library changes. Detailed changes\nfor the Toxiproxy server can been found in [CHANGELOG.md](./CHANGELOG.md).\n\n### 2. Populating Toxiproxy\n\nWhen your application boots, it needs to make sure that Toxiproxy knows which\nendpoints to proxy where. The main parameters are: name, address for Toxiproxy\nto **listen** on and the address of the upstream.\n\nSome client libraries have helpers for this task, which is essentially just\nmaking sure each proxy in a list is created. Example from the Ruby client:\n\n```ruby\n# Make sure `shopify_test_redis_master` and `shopify_test_mysql_master` are\n# present in Toxiproxy\nToxiproxy.populate([\n  {\n    name: \"shopify_test_redis_master\",\n    listen: \"127.0.0.1:22220\",\n    upstream: \"127.0.0.1:6379\"\n  },\n  {\n    name: \"shopify_test_mysql_master\",\n    listen: \"127.0.0.1:24220\",\n    upstream: \"127.0.0.1:3306\"\n  }\n])\n```\n\nThis code needs to run as early in boot as possible, before any code establishes\na connection through Toxiproxy. Please check your client library for\ndocumentation on the population helpers.\n\nAlternatively use the CLI to create proxies, e.g.:\n\n```bash\ntoxiproxy-cli create -l localhost:26379 -u localhost:6379 shopify_test_redis_master\n```\n\nWe recommend a naming such as the above: `<app>_<env>_<data store>_<shard>`.\nThis makes sure there are no clashes between applications using the same\nToxiproxy.\n\nFor large application we recommend storing the Toxiproxy configurations in a\nseparate configuration file. We use `config/toxiproxy.json`. This file can be\npassed to the server using the `-config` option, or loaded by the application\nto use with the `populate` function.\n\nAn example `config/toxiproxy.json`:\n\n```json\n[\n  {\n    \"name\": \"web_dev_frontend_1\",\n    \"listen\": \"[::]:18080\",\n    \"upstream\": \"webapp.domain:8080\",\n    \"enabled\": true\n  },\n  {\n    \"name\": \"web_dev_mysql_1\",\n    \"listen\": \"[::]:13306\",\n    \"upstream\": \"database.domain:3306\",\n    \"enabled\": true\n  }\n]\n```\n\nUse ports outside the ephemeral port range to avoid random port conflicts.\nIt's `32,768` to `61,000` on Linux by default, see\n`/proc/sys/net/ipv4/ip_local_port_range`.\n\n### 3. Using Toxiproxy\n\nTo use Toxiproxy, you now need to configure your application to connect through\nToxiproxy. Continuing with our example from step two, we can configure our Redis\nclient to connect through Toxiproxy:\n\n```ruby\n# old straight to redis\nredis = Redis.new(port: 6380)\n\n# new through toxiproxy\nredis = Redis.new(port: 22220)\n```\n\nNow you can tamper with it through the Toxiproxy API. In Ruby:\n\n```ruby\nredis = Redis.new(port: 22220)\n\nToxiproxy[:shopify_test_redis_master].downstream(:latency, latency: 1000).apply do\n  redis.get(\"test\") # will take 1s\nend\n```\n\nOr via the CLI:\n\n```bash\ntoxiproxy-cli toxic add -t latency -a latency=1000 shopify_test_redis_master\n```\n\nPlease consult your respective client library on usage.\n\n### 4. Logging\n\nThere are the following log levels: panic, fatal, error, warn or warning, info, debug and trace.\nThe level could be updated via environment variable `LOG_LEVEL`.\n\n### Toxics\n\nToxics manipulate the pipe between the client and upstream. They can be added\nand removed from proxies using the [HTTP api](#http-api). Each toxic has its own parameters\nto change how it affects the proxy links.\n\nFor documentation on implementing custom toxics, see [CREATING_TOXICS.md](./CREATING_TOXICS.md)\n\n#### latency\n\nAdd a delay to all data going through the proxy. The delay is equal to `latency` +/- `jitter`.\n\nAttributes:\n\n - `latency`: time in milliseconds\n - `jitter`: time in milliseconds\n\n#### down\n\nBringing a service down is not technically a toxic in the implementation of\nToxiproxy. This is done by `POST`ing to `/proxies/{proxy}` and setting the\n`enabled` field to `false`.\n\n#### bandwidth\n\nLimit a connection to a maximum number of kilobytes per second.\n\nAttributes:\n\n - `rate`: rate in KB/s\n\n#### slow_close\n\nDelay the TCP socket from closing until `delay` has elapsed.\n\nAttributes:\n\n - `delay`: time in milliseconds\n\n#### timeout\n\nStops all data from getting through, and closes the connection after `timeout`. If\n`timeout` is 0, the connection won't close, and data will be dropped until the\ntoxic is removed.\n\nAttributes:\n\n - `timeout`: time in milliseconds\n\n#### reset_peer\n\nSimulate TCP RESET (Connection reset by peer) on the connections by closing the stub Input\nimmediately or after a `timeout`.\n\nAttributes:\n\n - `timeout`: time in milliseconds\n\n#### slicer\n\nSlices TCP data up into small bits, optionally adding a delay between each\nsliced \"packet\".\n\nAttributes:\n\n - `average_size`: size in bytes of an average packet\n - `size_variation`: variation in bytes of an average packet (should be smaller than average_size)\n - `delay`: time in microseconds to delay each packet by\n\n#### limit_data\n\nCloses connection when transmitted data exceeded limit.\n\n - `bytes`: number of bytes it should transmit before connection is closed\n\n### HTTP API\n\nAll communication with the Toxiproxy daemon from the client happens through the\nHTTP interface, which is described here.\n\nToxiproxy listens for HTTP on port **8474**.\n\n#### Proxy fields:\n\n - `name`: proxy name (string)\n - `listen`: listen address (string)\n - `upstream`: proxy upstream address (string)\n - `enabled`: true/false (defaults to true on creation)\n\nTo change a proxy's name, it must be deleted and recreated.\n\nChanging the `listen` or `upstream` fields will restart the proxy and drop any active connections.\n\nIf `listen` is specified with a port of 0, toxiproxy will pick an ephemeral port. The `listen` field\nin the response will be updated with the actual port.\n\nIf you change `enabled` to `false`, it will take down the proxy. You can switch it\nback to `true` to reenable it.\n\n#### Toxic fields:\n\n - `name`: toxic name (string, defaults to `<type>_<stream>`)\n - `type`: toxic type (string)\n - `stream`: link direction to affect (defaults to `downstream`)\n - `toxicity`: probability of the toxic being applied to a link (defaults to 1.0, 100%)\n - `attributes`: a map of toxic-specific attributes\n\nSee [Toxics](#toxics) for toxic-specific attributes.\n\nThe `stream` direction must be either `upstream` or `downstream`. `upstream` applies\nthe toxic on the `client -> server` connection, while `downstream` applies the toxic\non the `server -> client` connection. This can be used to modify requests and responses\nseparately.\n\n#### Endpoints\n\nAll endpoints are JSON.\n\n - **GET /proxies** - List existing proxies and their toxics\n - **POST /proxies** - Create a new proxy\n - **POST /populate** - Create or replace a list of proxies\n - **GET /proxies/{proxy}** - Show the proxy with all its active toxics\n - **POST /proxies/{proxy}** - Update a proxy's fields\n - **DELETE /proxies/{proxy}** - Delete an existing proxy\n - **GET /proxies/{proxy}/toxics** - List active toxics\n - **POST /proxies/{proxy}/toxics** - Create a new toxic\n - **GET /proxies/{proxy}/toxics/{toxic}** - Get an active toxic's fields\n - **POST /proxies/{proxy}/toxics/{toxic}** - Update an active toxic\n - **DELETE /proxies/{proxy}/toxics/{toxic}** - Remove an active toxic\n - **POST /reset** - Enable all proxies and remove all active toxics\n - **GET /version** - Returns the server version number\n - **GET /metrics** - Returns Prometheus-compatible metrics\n\n#### Populating Proxies\n\nProxies can be added and configured in bulk using the `/populate` endpoint. This is done by\npassing a json array of proxies to toxiproxy. If a proxy with the same name already exists,\nit will be compared to the new proxy and replaced if the `upstream` and `listen` address don't match.\n\nA `/populate` call can be included for example at application start to ensure all required proxies\nexist. It is safe to make this call several times, since proxies will be untouched as long as their\nfields are consistent with the new data.\n\n### CLI Example\n\n```bash\n$ toxiproxy-cli create -l localhost:26379 -u localhost:6379 redis\nCreated new proxy redis\n$ toxiproxy-cli list\nListen          Upstream        Name  Enabled Toxics\n======================================================================\n127.0.0.1:26379 localhost:6379  redis true    None\n\nHint: inspect toxics with `toxiproxy-client inspect <proxyName>`\n```\n\n```bash\n$ redis-cli -p 26379\n127.0.0.1:26379> SET omg pandas\nOK\n127.0.0.1:26379> GET omg\n\"pandas\"\n```\n\n```bash\n$ toxiproxy-cli toxic add -t latency -a latency=1000 redis\nAdded downstream latency toxic 'latency_downstream' on proxy 'redis'\n```\n\n```bash\n$ redis-cli -p 26379\n127.0.0.1:26379> GET omg\n\"pandas\"\n(1.00s)\n127.0.0.1:26379> DEL omg\n(integer) 1\n(1.00s)\n```\n\n```bash\n$ toxiproxy-cli toxic remove -n latency_downstream redis\nRemoved toxic 'latency_downstream' on proxy 'redis'\n```\n\n```bash\n$ redis-cli -p 26379\n127.0.0.1:26379> GET omg\n(nil)\n```\n\n```bash\n$ toxiproxy-cli delete redis\nDeleted proxy redis\n```\n\n```bash\n$ redis-cli -p 26379\nCould not connect to Redis at 127.0.0.1:26379: Connection refused\n```\n\n### Metrics\n\nToxiproxy exposes Prometheus-compatible metrics via its HTTP API at /metrics.\nSee [METRICS.md](./METRICS.md) for full descriptions\n\n### Frequently Asked Questions\n\n**How fast is Toxiproxy?** The speed of Toxiproxy depends largely on your hardware,\nbut you can expect a latency of *< 100s* when no toxics are enabled. When running\nwith `GOMAXPROCS=4` on a Macbook Pro we achieved *~1000MB/s* throughput, and as high\nas *2400MB/s* on a higher end desktop. Basically, you can expect Toxiproxy to move\ndata around at least as fast the app you're testing.\n\n**Can Toxiproxy do randomized testing?** Many of the available toxics can be configured\nto have randomness, such as `jitter` in the `latency` toxic. There is also a\nglobal `toxicity` parameter that specifies the percentage of connections a toxic\nwill affect. This is most useful for things like the `timeout` toxic, which would\nallow X% of connections to timeout.\n\n**I am not seeing my Toxiproxy actions reflected for MySQL**. MySQL will prefer\nthe local Unix domain socket for some clients, no matter which port you pass it\nif the host is set to `localhost`. Configure your MySQL server to not create a\nsocket, and use `127.0.0.1` as the host. Remember to remove the old socket\nafter you restart the server.\n\n**Toxiproxy causes intermittent connection failures**. Use ports outside the\nephemeral port range to avoid random port conflicts. It's `32,768` to `61,000` on\nLinux by default, see `/proc/sys/net/ipv4/ip_local_port_range`.\n\n**Should I run a Toxiproxy for each application?** No, we recommend using the\nsame Toxiproxy for all applications. To distinguish between services we\nrecommend naming your proxies with the scheme: `<app>_<env>_<data store>_<shard>`.\nFor example, `shopify_test_redis_master` or `shopify_development_mysql_1`.\n\n### Development\n\n* `make`. Build a toxiproxy development binary for the current platform.\n* `make all`. Build Toxiproxy binaries and packages for all platforms. Requires\n  to have Go compiled with cross compilation enabled on Linux and Darwin (amd64)\n  as well as [`goreleaser`](https://goreleaser.com/) in your `$PATH` to\n  build binaries the Linux package.\n* `make test`. Run the Toxiproxy tests.\n\n### Release\n\nSee [RELEASE.md](./RELEASE.md)\n\n[blog]: https://shopify.engineering/building-and-testing-resilient-ruby-on-rails-applications\n"
        },
        {
          "name": "RELEASE.md",
          "type": "blob",
          "size": 2.4697265625,
          "content": "# Releasing\n\n- [Releasing](#releasing)\n  - [Before You Begin](#before-you-begin)\n  - [Local Release Preparation](#local-release-preparation)\n    - [Checkout latest code](#checkout-latest-code)\n    - [Update the CHANGELOG.md](#update-the-changelogmd)\n    - [Create Release Commit and Tag](#create-release-commit-and-tag)\n    - [Run Pre-Release Tests](#run-pre-release-tests)\n  - [Push Release Tag](#push-release-tag)\n  - [Verify Github Release](#verify-github-release)\n  - [Update Homebrew versions](#update-homebrew-versions)\n\n## Before You Begin\n\nEnsure your local workstation is configured to be able to [Sign commits](https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits)\n\n## Local Release Preparation\n\n### Checkout latest code\n\n```shell\ngit checkout main\ngit pull origin main\n```\n\n### Update the [CHANGELOG.md](CHANGELOG.md)\n\n- Add a new version header at the top of the document, just after `# [Unreleased]`\n- Update links at bottom of changelog\n\n### Create Release Commit and Tag\n\n```shell\nexport RELEASE_VERSION=2.x.y\ngit commit -a -S -m \"Release $RELEASE_VERSION\"\ngit tag -s \"v$RELEASE_VERSION\" # When prompted for a commit message, enter the 'release notes' style message, just like on the releases page\n```\n\n### Run Pre-Release Tests\n\n```shell\nmake test-release\n```\n\n- Push to Main Branch\n```shell\ngit push origin main --follow-tags\n```\n\n## Push Release Tag\n\n- On your local machine again, push your tag to github\n\n```shell\ngit push origin \"v$RELEASE_VERSION\"\n```\n\n## Verify Github Release\n\n- Github Actions should kick off a build and release after the tag is pushed.\n- Verify that a [Release gets created in Github](https://github.com/Shopify/toxiproxy/releases) and verify that the release notes look correct\n- Github Actions should also attatch the built binaries to the release (it might take a few mins)\n\n## Update Homebrew versions\n\n- Update [homebrew-shopify toxiproxy.rb](https://github.com/Shopify/homebrew-shopify/blob/master/toxiproxy.rb#L9) manifest\n  1. Update `app_version` string to your released version\n  2. Update hashes for all platforms (find the hashes in the checksums.txt from your release notes)\n\n- Do a manual check of installing toxiproxy via brew\n  1. While in the homebrew-shopify directory...\n  ```shell\n  brew install ./toxiproxy.rb --debug\n  ```\n  Note: it's normal to get some errors when homebrew attempts to load the file as a Cask instead of a formula, just make sure that it still gets installed.\n- PR the version update change and merge\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 14.6171875,
          "content": "package toxiproxy\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/rs/zerolog\"\n\t\"github.com/rs/zerolog/hlog\"\n\n\t\"github.com/Shopify/toxiproxy/v2/toxics\"\n)\n\nfunc stopBrowsersMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif strings.HasPrefix(r.UserAgent(), \"Mozilla/\") {\n\t\t\thttp.Error(w, \"User agent not allowed\", 403)\n\t\t} else {\n\t\t\tnext.ServeHTTP(w, r)\n\t\t}\n\t})\n}\n\nfunc timeoutMiddleware(next http.Handler) http.Handler {\n\treturn http.TimeoutHandler(next, 25*time.Second, \"\")\n}\n\ntype ApiServer struct {\n\tCollection *ProxyCollection\n\tMetrics    *metricsContainer\n\tLogger     *zerolog.Logger\n\thttp       *http.Server\n}\n\nconst (\n\twait_timeout = 30 * time.Second\n\tread_timeout = 15 * time.Second\n)\n\nfunc NewServer(m *metricsContainer, logger zerolog.Logger) *ApiServer {\n\treturn &ApiServer{\n\t\tCollection: NewProxyCollection(),\n\t\tMetrics:    m,\n\t\tLogger:     &logger,\n\t}\n}\n\nfunc (server *ApiServer) Listen(addr string) error {\n\tserver.Logger.\n\t\tInfo().\n\t\tStr(\"address\", addr).\n\t\tMsg(\"Starting Toxiproxy HTTP server\")\n\n\tserver.http = &http.Server{\n\t\tAddr:         addr,\n\t\tHandler:      server.Routes(),\n\t\tWriteTimeout: wait_timeout,\n\t\tReadTimeout:  read_timeout,\n\t\tIdleTimeout:  60 * time.Second,\n\t}\n\n\terr := server.http.ListenAndServe()\n\tif err == http.ErrServerClosed {\n\t\terr = nil\n\t}\n\n\treturn err\n}\n\nfunc (server *ApiServer) Shutdown() error {\n\tif server.http == nil {\n\t\treturn nil\n\t}\n\n\tctx, cancel := context.WithTimeout(context.Background(), wait_timeout)\n\tdefer cancel()\n\n\terr := server.http.Shutdown(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (server *ApiServer) Routes() *mux.Router {\n\tr := mux.NewRouter()\n\tr.Use(hlog.NewHandler(*server.Logger))\n\tr.Use(hlog.RequestIDHandler(\"request_id\", \"X-Toxiproxy-Request-Id\"))\n\tr.Use(hlog.AccessHandler(func(r *http.Request, status, size int, duration time.Duration) {\n\t\thandler := mux.CurrentRoute(r).GetName()\n\t\tzerolog.Ctx(r.Context()).\n\t\t\tDebug().\n\t\t\tStr(\"client\", r.RemoteAddr).\n\t\t\tStr(\"method\", r.Method).\n\t\t\tStringer(\"url\", r.URL).\n\t\t\tStr(\"user_agent\", r.Header.Get(\"User-Agent\")).\n\t\t\tInt(\"status\", status).\n\t\t\tInt(\"size\", size).\n\t\t\tDur(\"duration\", duration).\n\t\t\tStr(\"handler\", handler).\n\t\t\tMsg(\"\")\n\t}))\n\tr.Use(stopBrowsersMiddleware)\n\tr.Use(timeoutMiddleware)\n\n\tr.HandleFunc(\"/reset\", server.ResetState).Methods(\"POST\").\n\t\tName(\"ResetState\")\n\tr.HandleFunc(\"/proxies\", server.ProxyIndex).Methods(\"GET\").\n\t\tName(\"ProxyIndex\")\n\tr.HandleFunc(\"/proxies\", server.ProxyCreate).Methods(\"POST\").\n\t\tName(\"ProxyCreate\")\n\tr.HandleFunc(\"/populate\", server.Populate).Methods(\"POST\").\n\t\tName(\"Populate\")\n\tr.HandleFunc(\"/proxies/{proxy}\", server.ProxyShow).Methods(\"GET\").\n\t\tName(\"ProxyShow\")\n\tr.HandleFunc(\"/proxies/{proxy}\", server.ProxyUpdate).Methods(\"POST\", \"PATCH\").\n\t\tName(\"ProxyUpdate\")\n\tr.HandleFunc(\"/proxies/{proxy}\", server.ProxyDelete).Methods(\"DELETE\").\n\t\tName(\"ProxyDelete\")\n\tr.HandleFunc(\"/proxies/{proxy}/toxics\", server.ToxicIndex).Methods(\"GET\").\n\t\tName(\"ToxicIndex\")\n\tr.HandleFunc(\"/proxies/{proxy}/toxics\", server.ToxicCreate).Methods(\"POST\").\n\t\tName(\"ToxicCreate\")\n\tr.HandleFunc(\"/proxies/{proxy}/toxics/{toxic}\", server.ToxicShow).Methods(\"GET\").\n\t\tName(\"ToxicShow\")\n\tr.HandleFunc(\"/proxies/{proxy}/toxics/{toxic}\", server.ToxicUpdate).Methods(\"POST\", \"PATCH\").\n\t\tName(\"ToxicUpdate\")\n\tr.HandleFunc(\"/proxies/{proxy}/toxics/{toxic}\", server.ToxicDelete).Methods(\"DELETE\").\n\t\tName(\"ToxicDelete\")\n\n\tr.HandleFunc(\"/version\", server.Version).Methods(\"GET\").Name(\"Version\")\n\n\tif server.Metrics.anyMetricsEnabled() {\n\t\tr.Handle(\"/metrics\", server.Metrics.handler()).Name(\"Metrics\")\n\t}\n\n\treturn r\n}\n\nfunc (server *ApiServer) PopulateConfig(filename string) {\n\tfile, err := os.Open(filename)\n\tlogger := server.Logger\n\tif err != nil {\n\t\tlogger.Err(err).Str(\"config\", filename).Msg(\"Error reading config file\")\n\t\treturn\n\t}\n\n\tproxies, err := server.Collection.PopulateJson(server, file)\n\tif err != nil {\n\t\tlogger.Err(err).Msg(\"Failed to populate proxies from file\")\n\t} else {\n\t\tlogger.Info().Int(\"proxies\", len(proxies)).Msg(\"Populated proxies from file\")\n\t}\n}\n\nfunc (server *ApiServer) ProxyIndex(response http.ResponseWriter, request *http.Request) {\n\tproxies := server.Collection.Proxies()\n\tmarshalData := make(map[string]interface{}, len(proxies))\n\n\tfor name, proxy := range proxies {\n\t\tmarshalData[name] = proxyWithToxics(proxy)\n\t}\n\n\tdata, err := json.Marshal(marshalData)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog := zerolog.Ctx(request.Context())\n\t\tlog.Warn().Err(err).Msg(\"ProxyIndex: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ResetState(response http.ResponseWriter, request *http.Request) {\n\tctx := request.Context()\n\tproxies := server.Collection.Proxies()\n\n\tfor _, proxy := range proxies {\n\t\terr := proxy.Start()\n\t\tif err != ErrProxyAlreadyStarted && server.apiError(response, err) {\n\t\t\treturn\n\t\t}\n\n\t\tproxy.Toxics.ResetToxics(ctx)\n\t}\n\n\tresponse.WriteHeader(http.StatusNoContent)\n\t_, err := response.Write(nil)\n\tif err != nil {\n\t\tlog := zerolog.Ctx(ctx)\n\t\tlog.Warn().Err(err).Msg(\"ResetState: Failed to write headers to client\")\n\t}\n}\n\nfunc (server *ApiServer) ProxyCreate(response http.ResponseWriter, request *http.Request) {\n\t// Default fields to enable the proxy right away\n\tinput := Proxy{Enabled: true}\n\terr := json.NewDecoder(request.Body).Decode(&input)\n\tif server.apiError(response, joinError(err, ErrBadRequestBody)) {\n\t\treturn\n\t}\n\n\tif len(input.Name) < 1 {\n\t\tserver.apiError(response, joinError(fmt.Errorf(\"name\"), ErrMissingField))\n\t\treturn\n\t}\n\tif len(input.Upstream) < 1 {\n\t\tserver.apiError(response, joinError(fmt.Errorf(\"upstream\"), ErrMissingField))\n\t\treturn\n\t}\n\n\tproxy := NewProxy(server, input.Name, input.Listen, input.Upstream)\n\n\terr = server.Collection.Add(proxy, input.Enabled)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(proxyWithToxics(proxy))\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse.WriteHeader(http.StatusCreated)\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog := zerolog.Ctx(request.Context())\n\t\tlog.Warn().Err(err).Msg(\"ProxyCreate: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) Populate(response http.ResponseWriter, request *http.Request) {\n\tproxies, err := server.Collection.PopulateJson(server, request.Body)\n\tlog := zerolog.Ctx(request.Context())\n\tif err != nil {\n\t\tlog.Warn().Err(err).Msg(\"Populate errors\")\n\t}\n\n\tapiErr, ok := err.(*ApiError)\n\tif !ok && err != nil {\n\t\tlog.Warn().Err(err).Msg(\"Error did not include status code\")\n\t\tapiErr = &ApiError{err.Error(), http.StatusInternalServerError}\n\t}\n\n\tdata, err := json.Marshal(struct {\n\t\t*ApiError `json:\",omitempty\"`\n\t\tProxies   []proxyToxics `json:\"proxies\"`\n\t}{apiErr, proxiesWithToxics(proxies)})\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponseCode := http.StatusCreated\n\tif apiErr != nil {\n\t\tresponseCode = apiErr.StatusCode\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\tresponse.WriteHeader(responseCode)\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog.Warn().Err(err).Msg(\"Populate: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ProxyShow(response http.ResponseWriter, request *http.Request) {\n\tvars := mux.Vars(request)\n\n\tproxy, err := server.Collection.Get(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(proxyWithToxics(proxy))\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tserver.Logger.Warn().Err(err).Msg(\"ProxyShow: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ProxyUpdate(response http.ResponseWriter, request *http.Request) {\n\tlog := zerolog.Ctx(request.Context())\n\tif request.Method == \"POST\" {\n\t\tlog.Warn().Msg(\"ProxyUpdate: HTTP method POST is depercated. Use HTTP PATCH instead.\")\n\t}\n\n\tvars := mux.Vars(request)\n\n\tproxy, err := server.Collection.Get(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\t// Default fields are the same as existing proxy\n\tinput := Proxy{Listen: proxy.Listen, Upstream: proxy.Upstream, Enabled: proxy.Enabled}\n\terr = json.NewDecoder(request.Body).Decode(&input)\n\tif server.apiError(response, joinError(err, ErrBadRequestBody)) {\n\t\treturn\n\t}\n\n\terr = proxy.Update(&input)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(proxyWithToxics(proxy))\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog.Warn().Err(err).Msg(\"ProxyUpdate: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ProxyDelete(response http.ResponseWriter, request *http.Request) {\n\tvars := mux.Vars(request)\n\n\terr := server.Collection.Remove(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.WriteHeader(http.StatusNoContent)\n\t_, err = response.Write(nil)\n\tif err != nil {\n\t\tlog := zerolog.Ctx(request.Context())\n\t\tlog.Warn().Err(err).Msg(\"ProxyDelete: Failed to write headers to client\")\n\t}\n}\n\nfunc (server *ApiServer) ToxicIndex(response http.ResponseWriter, request *http.Request) {\n\tvars := mux.Vars(request)\n\n\tproxy, err := server.Collection.Get(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\ttoxics := proxy.Toxics.GetToxicArray()\n\tdata, err := json.Marshal(toxics)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog := zerolog.Ctx(request.Context())\n\t\tlog.Warn().Err(err).Msg(\"ToxicIndex: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ToxicCreate(response http.ResponseWriter, request *http.Request) {\n\tvars := mux.Vars(request)\n\n\tproxy, err := server.Collection.Get(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\ttoxic, err := proxy.Toxics.AddToxicJson(request.Body)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(toxic)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog := zerolog.Ctx(request.Context())\n\t\tlog.Warn().Err(err).Msg(\"ToxicCreate: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ToxicShow(response http.ResponseWriter, request *http.Request) {\n\tvars := mux.Vars(request)\n\n\tproxy, err := server.Collection.Get(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\ttoxic := proxy.Toxics.GetToxic(vars[\"toxic\"])\n\tif toxic == nil {\n\t\tserver.apiError(response, ErrToxicNotFound)\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(toxic)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog := zerolog.Ctx(request.Context())\n\t\tlog.Warn().Err(err).Msg(\"ToxicShow: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ToxicUpdate(response http.ResponseWriter, request *http.Request) {\n\tlog := zerolog.Ctx(request.Context())\n\tif request.Method == \"POST\" {\n\t\tlog.Warn().Msg(\"ToxicUpdate: HTTP method POST is depercated. Use HTTP PATCH instead.\")\n\t}\n\n\tvars := mux.Vars(request)\n\n\tproxy, err := server.Collection.Get(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\ttoxic, err := proxy.Toxics.UpdateToxicJson(vars[\"toxic\"], request.Body)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(toxic)\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json\")\n\t_, err = response.Write(data)\n\tif err != nil {\n\t\tlog.Warn().Err(err).Msg(\"ToxicUpdate: Failed to write response to client\")\n\t}\n}\n\nfunc (server *ApiServer) ToxicDelete(response http.ResponseWriter, request *http.Request) {\n\tvars := mux.Vars(request)\n\tctx := request.Context()\n\tlog := zerolog.Ctx(ctx)\n\n\tproxy, err := server.Collection.Get(vars[\"proxy\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\terr = proxy.Toxics.RemoveToxic(ctx, vars[\"toxic\"])\n\tif server.apiError(response, err) {\n\t\treturn\n\t}\n\n\tresponse.WriteHeader(http.StatusNoContent)\n\t_, err = response.Write(nil)\n\tif err != nil {\n\t\tlog.Warn().Err(err).Msg(\"ToxicDelete: Failed to write headers to client\")\n\t}\n}\n\nfunc (server *ApiServer) Version(response http.ResponseWriter, request *http.Request) {\n\tlog := zerolog.Ctx(request.Context())\n\n\tresponse.Header().Set(\"Content-Type\", \"application/json;charset=utf-8\")\n\tversion := fmt.Sprintf(\"{\\\"version\\\": \\\"%s\\\"}\\n\", Version)\n\t_, err := response.Write([]byte(version))\n\tif err != nil {\n\t\tlog.Warn().Err(err).Msg(\"Version: Failed to write response to client\")\n\t}\n}\n\ntype ApiError struct {\n\tMessage    string `json:\"error\"`\n\tStatusCode int    `json:\"status\"`\n}\n\nfunc (e *ApiError) Error() string {\n\treturn e.Message\n}\n\nfunc newError(msg string, status int) *ApiError {\n\treturn &ApiError{msg, status}\n}\n\nfunc joinError(err error, wrapper *ApiError) *ApiError {\n\tif err != nil {\n\t\treturn &ApiError{wrapper.Message + \": \" + err.Error(), wrapper.StatusCode}\n\t}\n\treturn nil\n}\n\nvar (\n\tErrBadRequestBody     = newError(\"bad request body\", http.StatusBadRequest)\n\tErrMissingField       = newError(\"missing required field\", http.StatusBadRequest)\n\tErrProxyNotFound      = newError(\"proxy not found\", http.StatusNotFound)\n\tErrProxyAlreadyExists = newError(\"proxy already exists\", http.StatusConflict)\n\tErrInvalidStream      = newError(\n\t\t\"stream was invalid, can be either upstream or downstream\",\n\t\thttp.StatusBadRequest,\n\t)\n\tErrInvalidToxicType   = newError(\"invalid toxic type\", http.StatusBadRequest)\n\tErrToxicAlreadyExists = newError(\"toxic already exists\", http.StatusConflict)\n\tErrToxicNotFound      = newError(\"toxic not found\", http.StatusNotFound)\n)\n\nfunc (server *ApiServer) apiError(resp http.ResponseWriter, err error) bool {\n\tobj, ok := err.(*ApiError)\n\tif !ok && err != nil {\n\t\tserver.Logger.Warn().Err(err).Msg(\"Error did not include status code\")\n\t\tobj = &ApiError{err.Error(), http.StatusInternalServerError}\n\t}\n\n\tif obj == nil {\n\t\treturn false\n\t}\n\n\tdata, err2 := json.Marshal(obj)\n\tif err2 != nil {\n\t\tserver.Logger.Warn().Err(err2).Msg(\"Error json encoding error (  \")\n\t}\n\tresp.Header().Set(\"Content-Type\", \"application/json\")\n\thttp.Error(resp, string(data), obj.StatusCode)\n\n\treturn true\n}\n\ntype proxyToxics struct {\n\t*Proxy\n\tToxics []toxics.Toxic `json:\"toxics\"`\n}\n\nfunc proxyWithToxics(proxy *Proxy) (result proxyToxics) {\n\tresult.Proxy = proxy\n\tresult.Toxics = proxy.Toxics.GetToxicArray()\n\treturn\n}\n\nfunc proxiesWithToxics(proxies []*Proxy) (result []proxyToxics) {\n\tfor _, proxy := range proxies {\n\t\tresult = append(result, proxyWithToxics(proxy))\n\t}\n\treturn\n}\n"
        },
        {
          "name": "api_test.go",
          "type": "blob",
          "size": 29.8515625,
          "content": "package toxiproxy_test\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/Shopify/toxiproxy/v2\"\n\ttclient \"github.com/Shopify/toxiproxy/v2/client\"\n)\n\nvar testServer *toxiproxy.ApiServer\n\nvar client = tclient.NewClient(\"http://127.0.0.1:8475\")\n\nfunc WithServer(t *testing.T, f func(string)) {\n\tlog := zerolog.Nop()\n\tif flag.Lookup(\"test.v\").DefValue == \"true\" {\n\t\tlog = zerolog.New(os.Stdout).With().Caller().Timestamp().Logger()\n\t}\n\n\t// Make sure only one server is running at a time. Apparently there's no clean\n\t// way to shut it down between each test run.\n\tif testServer == nil {\n\t\ttestServer = toxiproxy.NewServer(\n\t\t\ttoxiproxy.NewMetricsContainer(prometheus.NewRegistry()),\n\t\t\tlog,\n\t\t)\n\n\t\tgo testServer.Listen(\"localhost:8475\")\n\n\t\t// Allow server to start. There's no clean way to know when it listens.\n\t\ttime.Sleep(50 * time.Millisecond)\n\t}\n\n\tdefer func() {\n\t\terr := testServer.Collection.Clear()\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to clear collection\", err)\n\t\t}\n\t}()\n\n\tf(\"http://localhost:8475\")\n}\n\nfunc TestRequestId(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\tclient := http.Client{}\n\n\t\treq, _ := http.NewRequest(\"GET\", \"http://localhost:8475/version\", nil)\n\t\treq.Header.Add(\"User-Agent\", \"curl\")\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Does not expect errors from client: %+v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif _, ok := resp.Header[\"X-Toxiproxy-Request-Id\"]; !ok {\n\t\t\tt.Fatalf(\"Expect http response with header X-Toxiproxy-Request-Id, got %+v\", resp.Header)\n\t\t}\n\t})\n}\n\nfunc TestBrowserGets403(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\tclient := http.Client{}\n\n\t\treq, _ := http.NewRequest(\"GET\", \"http://localhost:8475/proxies\", nil)\n\t\treq.Header.Add(\n\t\t\t\"User-Agent\",\n\t\t\t\"Mozilla/5.0 (Linux; Android 4.4.2); Nexus 5 Build/KOT49H) AppleWebKit/537.36\"+\n\t\t\t\t\"(KHTML, like Gecko) Chrome/33.0.1750.117 Mobile Safari/537.36 OPR/20.0.1396.72047\",\n\t\t)\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Does not expect errors from client: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != 403 {\n\t\t\tt.Fatal(\"Browser-like UserAgent was not denied access to Toxiproxy\")\n\t\t}\n\t})\n}\n\nfunc TestNonBrowserGets200(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\tclient := http.Client{}\n\n\t\treq, _ := http.NewRequest(\"GET\", \"http://localhost:8475/proxies\", nil)\n\t\treq.Header.Add(\"User-Agent\", \"Wget/2.1\")\n\n\t\tresp, err := client.Do(req)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Does not expect errors from client: %v\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode == 403 {\n\t\t\tt.Fatal(\"Non-Browser-like UserAgent was denied access to Toxiproxy\")\n\t\t}\n\t})\n}\n\nfunc TestIndexWithNoProxies(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\tclient := tclient.NewClient(addr)\n\t\tproxies, err := client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed getting proxies:\", err)\n\t\t}\n\n\t\tif len(proxies) > 0 {\n\t\t\tt.Fatal(\"Expected no proxies, got:\", proxies)\n\t\t}\n\t})\n}\n\nfunc TestCreateProxyBlankName(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\t_, err := client.CreateProxy(\"\", \"\", \"\")\n\n\t\texpected := \"Create: HTTP 400: missing required field: name\"\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected error creating proxy, got nil\")\n\t\t} else if err.Error() != expected {\n\t\t\tt.Errorf(\"Expected error `%s',\\n\\tgot: `%s'\", expected, err)\n\t\t}\n\t})\n}\n\nfunc TestCreateProxyBlankUpstream(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\t_, err := client.CreateProxy(\"test\", \"\", \"\")\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected error creating proxy, got nil\")\n\t\t} else if err.Error() != \"Create: HTTP 400: missing required field: upstream\" {\n\t\t\tt.Error(\"Expected different error creating proxy:\", err)\n\t\t}\n\t})\n}\n\nfunc TestPopulateProxy(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxies, err := client.Populate([]tclient.Proxy{\n\t\t\t{\n\t\t\t\tName:     \"one\",\n\t\t\t\tListen:   \"localhost:7070\",\n\t\t\t\tUpstream: \"localhost:7171\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"two\",\n\t\t\t\tListen:   \"localhost:7373\",\n\t\t\t\tUpstream: \"localhost:7474\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to populate:\", err)\n\t\t}\n\n\t\tif len(testProxies) != 2 {\n\t\t\tt.Fatalf(\"Wrong number of proxies returned: %d != 2\", len(testProxies))\n\t\t}\n\n\t\tif testProxies[0].Name != \"one\" || testProxies[1].Name != \"two\" {\n\t\t\tt.Fatalf(\"Wrong proxy names returned: %s, %s\", testProxies[0].Name, testProxies[1].Name)\n\t\t}\n\n\t\tfor _, p := range testProxies {\n\t\t\tAssertProxyUp(t, p.Listen, true)\n\t\t}\n\t})\n}\n\nfunc TestPopulateDefaultEnabled(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\trequest := []byte(\n\t\t\t`[{\"name\": \"test\", \"listen\": \"localhost:7070\", \"upstream\": \"localhost:7171\"}]`,\n\t\t)\n\n\t\tresp, err := http.Post(addr+\"/populate\", \"application/json\", bytes.NewReader(request))\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to send POST to /populate:\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tif resp.StatusCode != http.StatusCreated {\n\t\t\tmessage, _ := io.ReadAll(resp.Body)\n\t\t\tt.Fatalf(\"Failed to populate proxy list: HTTP %s\\n%s\", resp.Status, string(message))\n\t\t}\n\n\t\tproxies, err := client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if len(proxies) != 1 {\n\t\t\tt.Fatalf(\"Wrong number of proxies created: %d != 1\", len(proxies))\n\t\t} else if _, ok := proxies[\"test\"]; !ok {\n\t\t\tt.Fatalf(\"Wrong proxy name returned\")\n\t\t}\n\n\t\tfor _, p := range proxies {\n\t\t\tAssertProxyUp(t, p.Listen, true)\n\t\t}\n\t})\n}\n\nfunc TestPopulateDisabledProxy(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxies, err := client.Populate([]tclient.Proxy{\n\t\t\t{\n\t\t\t\tName:     \"one\",\n\t\t\t\tListen:   \"localhost:7070\",\n\t\t\t\tUpstream: \"localhost:7171\",\n\t\t\t\tEnabled:  false,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"two\",\n\t\t\t\tListen:   \"localhost:7373\",\n\t\t\t\tUpstream: \"localhost:7474\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to populate:\", err)\n\t\t}\n\n\t\tif len(testProxies) != 2 {\n\t\t\tt.Fatalf(\"Wrong number of proxies returned: %d != 2\", len(testProxies))\n\t\t}\n\n\t\tif testProxies[0].Name != \"one\" || testProxies[1].Name != \"two\" {\n\t\t\tt.Fatalf(\"Wrong proxy names returned: %s, %s\", testProxies[0].Name, testProxies[1].Name)\n\t\t}\n\n\t\tAssertProxyUp(t, \"localhost:7070\", false)\n\t\tAssertProxyUp(t, \"localhost:7373\", true)\n\t})\n}\n\nfunc TestPopulateExistingProxy(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"one\", \"localhost:7070\", \"localhost:7171\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\t\t_, err = client.CreateProxy(\"two\", \"localhost:7373\", \"localhost:7474\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\t// Create a toxic so we can make sure the proxy wasn't replaced\n\t\t_, err = testProxy.AddToxic(\"\", \"latency\", \"downstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create toxic:\", err)\n\t\t}\n\n\t\ttestProxies, err := client.Populate([]tclient.Proxy{\n\t\t\t{\n\t\t\t\tName:     \"one\",\n\t\t\t\tListen:   \"127.0.0.1:7070\",\n\t\t\t\tUpstream: \"localhost:7171\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"two\",\n\t\t\t\tListen:   \"127.0.0.1:7575\",\n\t\t\t\tUpstream: \"localhost:7676\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to populate:\", err)\n\t\t}\n\n\t\tif len(testProxies) != 2 {\n\t\t\tt.Fatalf(\"Wrong number of proxies returned: %d != 2\", len(testProxies))\n\t\t}\n\n\t\tif testProxies[0].Name != \"one\" || testProxies[1].Name != \"two\" {\n\t\t\tt.Fatalf(\"Wrong proxy names returned: %s, %s\", testProxies[0].Name, testProxies[1].Name)\n\t\t}\n\n\t\tif testProxies[0].Listen != \"127.0.0.1:7070\" ||\n\t\t\ttestProxies[1].Listen != \"127.0.0.1:7575\" {\n\t\t\tt.Fatalf(\"Wrong proxy listen addresses returned: %s, %s\",\n\t\t\t\ttestProxies[0].Listen, testProxies[1].Listen,\n\t\t\t)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to get toxics:\", err)\n\t\t}\n\t\tif len(toxics) != 1 || toxics[0].Type != \"latency\" {\n\t\t\tt.Fatalf(\"Populate did not preseve existing proxy. (%d toxics)\", len(toxics))\n\t\t}\n\n\t\tfor _, p := range testProxies {\n\t\t\tAssertProxyUp(t, p.Listen, true)\n\t\t}\n\t})\n}\n\nfunc TestPopulateWithBadName(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxies, err := client.Populate([]tclient.Proxy{\n\t\t\t{\n\t\t\t\tName:     \"one\",\n\t\t\t\tListen:   \"localhost:7070\",\n\t\t\t\tUpstream: \"localhost:7171\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:    \"\",\n\t\t\t\tListen:  \"\",\n\t\t\t\tEnabled: true,\n\t\t\t},\n\t\t})\n\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected Populate to fail.\")\n\t\t}\n\n\t\texpected := \"Populate: HTTP 400: missing required field: name at proxy 2\"\n\t\tif err.Error() != expected {\n\t\t\tt.Fatalf(\"Expected error `%s',\\n\\tgot: `%s'\", expected, err)\n\t\t}\n\n\t\tif len(testProxies) != 0 {\n\t\t\tt.Fatalf(\"Wrong number of proxies returned: %d != 0\", len(testProxies))\n\t\t}\n\n\t\tproxies, err := client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t} else if len(proxies) != 0 {\n\t\t\tt.Fatalf(\"Expected no proxies to be created: %d != 0\", len(proxies))\n\t\t}\n\t})\n}\n\nfunc TestPopulateProxyWithBadDataShouldReturnError(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxies, err := client.Populate([]tclient.Proxy{\n\t\t\t{\n\t\t\t\tName:     \"one\",\n\t\t\t\tListen:   \"localhost:7070\",\n\t\t\t\tUpstream: \"localhost:7171\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"two\",\n\t\t\t\tListen:   \"local373\",\n\t\t\t\tUpstream: \"localhost:7474\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:     \"three\",\n\t\t\t\tListen:   \"localhost:7575\",\n\t\t\t\tUpstream: \"localhost:7676\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t})\n\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Expected Populate to fail.\")\n\t\t}\n\n\t\tif len(testProxies) != 0 {\n\t\t\tt.Fatalf(\"Expected Proxies to be empty, got %v\", testProxies)\n\t\t}\n\n\t\tproxies, err := client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\tif len(proxies) != 1 {\n\t\t\tt.Fatalf(\"Wrong number of proxies returned: %d != %d\", len(proxies), 1)\n\t\t}\n\n\t\tif _, ok := proxies[\"one\"]; !ok {\n\t\t\tt.Fatal(\"Proxy `one' was not created!\")\n\t\t}\n\n\t\tfor _, p := range testProxies {\n\t\t\tAssertProxyUp(t, p.Listen, true)\n\t\t}\n\n\t\tfor _, p := range proxies {\n\t\t\tif p.Name == \"two\" || p.Name == \"three\" {\n\t\t\t\tt.Fatalf(\"Proxy %s exists, populate did not fail correctly.\", p.Name)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestPopulateAddToxic(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxies, err := client.Populate([]tclient.Proxy{\n\t\t\t{\n\t\t\t\tName:     \"one\",\n\t\t\t\tListen:   \"localhost:7070\",\n\t\t\t\tUpstream: \"localhost:7171\",\n\t\t\t\tEnabled:  true,\n\t\t\t},\n\t\t})\n\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to populate:\", err)\n\t\t}\n\n\t\tif len(testProxies) != 1 {\n\t\t\tt.Fatalf(\"Wrong number of proxies returned: %d != %d\", len(testProxies), 1)\n\t\t}\n\n\t\tif testProxies[0].Name != \"one\" {\n\t\t\tt.Fatalf(\"Wrong proxy name returned: %s != one\", testProxies[0].Name)\n\t\t}\n\n\t\t_, err = testProxies[0].AddToxic(\"\", \"latency\", \"downstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to AddToxic.\")\n\t\t}\n\t})\n}\n\nfunc TestListingProxies(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\t_, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tproxies, err := client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error listing proxies:\", err)\n\t\t}\n\n\t\tif len(proxies) == 0 {\n\t\t\tt.Fatal(\"Expected new proxy in list\")\n\t\t}\n\t\tproxy, ok := proxies[\"mysql_master\"]\n\t\tif !ok {\n\t\t\tt.Fatal(\"Expected to see mysql_master proxy in list\")\n\t\t}\n\t\tif proxy.Name != \"mysql_master\" || proxy.Listen != \"127.0.0.1:3310\" ||\n\t\t\tproxy.Upstream != \"localhost:20001\" {\n\t\t\tt.Fatalf(\n\t\t\t\t\"Unexpected proxy metadata: %s, %s, %s\",\n\t\t\t\tproxy.Name,\n\t\t\t\tproxy.Listen,\n\t\t\t\tproxy.Upstream,\n\t\t\t)\n\t\t}\n\t\tAssertToxicExists(t, proxy.ActiveToxics, \"latency\", \"\", \"\", false)\n\t})\n}\n\nfunc TestCreateAndGetProxy(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\t_, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tproxy, err := client.Proxy(\"mysql_master\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to retriecve proxy:\", err)\n\t\t}\n\n\t\tif proxy.Name != \"mysql_master\" || proxy.Listen != \"127.0.0.1:3310\" ||\n\t\t\tproxy.Upstream != \"localhost:20001\" ||\n\t\t\t!proxy.Enabled {\n\t\t\tt.Fatalf(\n\t\t\t\t\"Unexpected proxy metadata: %s, %s, %s, %v\",\n\t\t\t\tproxy.Name,\n\t\t\t\tproxy.Listen,\n\t\t\t\tproxy.Upstream,\n\t\t\t\tproxy.Enabled,\n\t\t\t)\n\t\t}\n\n\t\tAssertToxicExists(t, proxy.ActiveToxics, \"latency\", \"\", \"\", false)\n\t})\n}\n\nfunc TestCreateProxyWithSave(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy := client.NewProxy()\n\t\ttestProxy.Name = \"mysql_master\"\n\t\ttestProxy.Listen = \"localhost:3310\"\n\t\ttestProxy.Upstream = \"localhost:20001\"\n\t\ttestProxy.Enabled = true\n\n\t\terr := testProxy.Save()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tproxy, err := client.Proxy(\"mysql_master\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to retriecve proxy:\", err)\n\t\t}\n\n\t\tif proxy.Name != \"mysql_master\" || proxy.Listen != \"127.0.0.1:3310\" ||\n\t\t\tproxy.Upstream != \"localhost:20001\" ||\n\t\t\t!proxy.Enabled {\n\t\t\tt.Fatalf(\n\t\t\t\t\"Unexpected proxy metadata: %s, %s, %s, %v\",\n\t\t\t\tproxy.Name,\n\t\t\t\tproxy.Listen,\n\t\t\t\tproxy.Upstream,\n\t\t\t\tproxy.Enabled,\n\t\t\t)\n\t\t}\n\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\t})\n}\n\nfunc TestCreateDisabledProxy(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\tdisabledProxy := client.NewProxy()\n\t\tdisabledProxy.Name = \"mysql_master\"\n\t\tdisabledProxy.Listen = \"localhost:3310\"\n\t\tdisabledProxy.Upstream = \"localhost:20001\"\n\n\t\terr := disabledProxy.Save()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tproxy, err := client.Proxy(\"mysql_master\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to retriecve proxy:\", err)\n\t\t}\n\n\t\tif proxy.Name != \"mysql_master\" || proxy.Listen != \"localhost:3310\" ||\n\t\t\tproxy.Upstream != \"localhost:20001\" ||\n\t\t\tproxy.Enabled {\n\t\t\tt.Fatalf(\n\t\t\t\t\"Unexpected proxy metadata: %s, %s, %s, %v\",\n\t\t\t\tproxy.Name,\n\t\t\t\tproxy.Listen,\n\t\t\t\tproxy.Upstream,\n\t\t\t\tproxy.Enabled,\n\t\t\t)\n\t\t}\n\n\t\tAssertProxyUp(t, proxy.Listen, false)\n\t})\n}\n\nfunc TestCreateDisabledProxyAndEnable(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\tdisabledProxy := client.NewProxy()\n\t\tdisabledProxy.Name = \"mysql_master\"\n\t\tdisabledProxy.Listen = \"localhost:3310\"\n\t\tdisabledProxy.Upstream = \"localhost:20001\"\n\n\t\terr := disabledProxy.Save()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tproxy, err := client.Proxy(\"mysql_master\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to retriecve proxy:\", err)\n\t\t}\n\n\t\tif proxy.Name != \"mysql_master\" || proxy.Listen != \"localhost:3310\" ||\n\t\t\tproxy.Upstream != \"localhost:20001\" ||\n\t\t\tproxy.Enabled {\n\t\t\tt.Fatalf(\n\t\t\t\t\"Unexpected proxy metadata: %s, %s, %s, %v\",\n\t\t\t\tproxy.Name,\n\t\t\t\tproxy.Listen,\n\t\t\t\tproxy.Upstream,\n\t\t\t\tproxy.Enabled,\n\t\t\t)\n\t\t}\n\n\t\tproxy.Enabled = true\n\n\t\terr = proxy.Save()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to update proxy:\", err)\n\t\t}\n\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\n\t\tproxy.Enabled = false\n\n\t\terr = proxy.Save()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to update proxy:\", err)\n\t\t}\n\n\t\tAssertProxyUp(t, proxy.Listen, false)\n\t})\n}\n\nfunc TestDeleteProxy(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tproxies, err := client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error listing proxies:\", err)\n\t\t}\n\n\t\tif len(proxies) == 0 {\n\t\t\tt.Fatal(\"Expected new proxy in list\")\n\t\t}\n\n\t\tAssertProxyUp(t, testProxy.Listen, true)\n\n\t\terr = testProxy.Delete()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed deleting proxy:\", err)\n\t\t}\n\n\t\tAssertProxyUp(t, testProxy.Listen, false)\n\n\t\tproxies, err = client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error listing proxies:\", err)\n\t\t}\n\n\t\tif len(proxies) > 0 {\n\t\t\tt.Fatal(\"Expected proxy to be deleted from list\")\n\t\t}\n\n\t\texpected := \"Delete: HTTP 404: proxy not found\"\n\t\terr = testProxy.Delete()\n\t\tif err == nil {\n\t\t\tt.Error(\"Proxy did not result in not found.\")\n\t\t} else if err.Error() != expected {\n\t\t\tt.Errorf(\"Expected error `%s',\\n\\tgot: `%s'\", expected, err)\n\t\t}\n\t})\n}\n\nfunc TestCreateProxyPortConflict(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\texpected := \"Create: HTTP 500: listen tcp 127.0.0.1:3310: bind: address already in use\"\n\t\t_, err = client.CreateProxy(\"test\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err == nil {\n\t\t\tt.Error(\"Proxy did not result in conflict.\")\n\t\t} else if err.Error() != expected {\n\t\t\tt.Errorf(\"Expected error `%s',\\n\\tgot: `%s'\", expected, err)\n\t\t}\n\n\t\terr = testProxy.Delete()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to delete proxy:\", err)\n\t\t}\n\t\t_, err = client.CreateProxy(\"test\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\t})\n}\n\nfunc TestCreateProxyNameConflict(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\texpected := \"Create: HTTP 409: proxy already exists\"\n\t\t_, err = client.CreateProxy(\"mysql_master\", \"localhost:3311\", \"localhost:20001\")\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Proxy did not result in conflict.\")\n\t\t} else if err.Error() != expected {\n\t\t\tt.Fatalf(\"Expected error `%s',\\n\\tgot: `%s'\", expected, err)\n\t\t}\n\n\t\terr = testProxy.Delete()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to delete proxy:\", err)\n\t\t}\n\t\t_, err = client.CreateProxy(\"mysql_master\", \"localhost:3311\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\t})\n}\n\nfunc TestResetState(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tlatency, err := testProxy.AddToxic(\"\", \"latency\", \"downstream\", 1, tclient.Attributes{\n\t\t\t\"latency\": 100,\n\t\t\t\"jitter\":  10,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\tif latency.Attributes[\"latency\"] != 100.0 || latency.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Latency toxic did not start up with correct settings\")\n\t\t}\n\n\t\terr = client.ResetState()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"unable to reset state:\", err)\n\t\t}\n\n\t\tproxies, err := client.Proxies()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error listing proxies:\", err)\n\t\t}\n\n\t\tproxy, ok := proxies[\"mysql_master\"]\n\t\tif !ok {\n\t\t\tt.Fatal(\"Expected proxy to still exist\")\n\t\t}\n\t\tif !proxy.Enabled {\n\t\t\tt.Fatal(\"Expected proxy to be enabled\")\n\t\t}\n\n\t\ttoxics, err := proxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error requesting toxics:\", err)\n\t\t}\n\n\t\tAssertToxicExists(t, toxics, \"latency\", \"\", \"\", false)\n\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\t})\n}\n\nfunc TestListingToxics(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\n\t\tAssertToxicExists(t, toxics, \"latency\", \"\", \"\", false)\n\t})\n}\n\nfunc TestAddToxic(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tlatency, err := testProxy.AddToxic(\"foobar\", \"latency\", \"downstream\", 1, tclient.Attributes{\n\t\t\t\"latency\": 100,\n\t\t\t\"jitter\":  10,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\tif latency.Attributes[\"latency\"] != 100.0 || latency.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Latency toxic did not start up with correct settings\")\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\t\ttoxic := AssertToxicExists(t, toxics, \"foobar\", \"latency\", \"downstream\", true)\n\t\tif toxic.Toxicity != 1.0 || toxic.Attributes[\"latency\"] != 100.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t})\n}\n\nfunc TestAddMultipleToxics(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"latency1\", \"latency\", \"downstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"latency2\", \"latency\", \"downstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\t\tAssertToxicExists(t, toxics, \"latency1\", \"latency\", \"downstream\", true)\n\t\ttoxic := AssertToxicExists(t, toxics, \"latency2\", \"latency\", \"downstream\", true)\n\t\tif toxic.Toxicity != 1.0 || toxic.Attributes[\"latency\"] != 0.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 0.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t\tAssertToxicExists(t, toxics, \"latency1\", \"\", \"upstream\", false)\n\t\tAssertToxicExists(t, toxics, \"latency2\", \"\", \"upstream\", false)\n\t})\n}\n\nfunc TestAddConflictingToxic(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"foobar\", \"latency\", \"downstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"foobar\", \"slow_close\", \"downstream\", 1, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Toxic did not result in conflict.\")\n\t\t} else if err.Error() != \"AddToxic: HTTP 409: toxic already exists\" {\n\t\t\tt.Fatal(\"Incorrect error setting toxic:\", err)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\t\ttoxic := AssertToxicExists(t, toxics, \"foobar\", \"latency\", \"downstream\", true)\n\t\tif toxic.Toxicity != 1.0 || toxic.Attributes[\"latency\"] != 0.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 0.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t\tAssertToxicExists(t, toxics, \"foobar\", \"\", \"upstream\", false)\n\t})\n}\n\nfunc TestAddConflictingToxicsMultistream(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"foobar\", \"latency\", \"upstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"foobar\", \"latency\", \"downstream\", 1, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Toxic did not result in conflict.\")\n\t\t} else if err.Error() != \"AddToxic: HTTP 409: toxic already exists\" {\n\t\t\tt.Fatal(\"Incorrect error setting toxic:\", err)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\n\t\ttoxic := AssertToxicExists(t, toxics, \"foobar\", \"latency\", \"upstream\", true)\n\t\tif toxic.Toxicity != 1.0 || toxic.Attributes[\"latency\"] != 0.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 0.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t\tAssertToxicExists(t, toxics, \"foobar\", \"\", \"downstream\", false)\n\t})\n}\n\nfunc TestAddConflictingToxicsMultistreamDefaults(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"\", \"latency\", \"upstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"\", \"latency\", \"downstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\t\ttoxic := AssertToxicExists(t, toxics, \"latency_upstream\", \"latency\", \"upstream\", true)\n\t\tif toxic.Toxicity != 1.0 || toxic.Attributes[\"latency\"] != 0.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 0.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t\ttoxic = AssertToxicExists(t, toxics, \"latency_downstream\", \"latency\", \"downstream\", true)\n\t\tif toxic.Toxicity != 1.0 || toxic.Attributes[\"latency\"] != 0.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 0.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t})\n}\n\nfunc TestAddToxicWithToxicity(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tlatency, err := testProxy.AddToxic(\"\", \"latency\", \"downstream\", 0.2, tclient.Attributes{\n\t\t\t\"latency\": 100,\n\t\t\t\"jitter\":  10,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\tif latency.Toxicity != 0.2 || latency.Attributes[\"latency\"] != 100.0 ||\n\t\t\tlatency.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Latency toxic did not start up with correct settings:\", latency)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\t\ttoxic := AssertToxicExists(t, toxics, \"latency_downstream\", \"latency\", \"downstream\", true)\n\t\tif toxic.Toxicity != 0.2 || toxic.Attributes[\"latency\"] != 100.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t})\n}\n\nfunc TestAddNoop(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tnoop, err := testProxy.AddToxic(\"foobar\", \"noop\", \"\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\tif noop.Toxicity != 1.0 || noop.Name != \"foobar\" || noop.Type != \"noop\" ||\n\t\t\tnoop.Stream != \"downstream\" {\n\t\t\tt.Fatal(\"Noop toxic did not start up with correct settings:\", noop)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\t\ttoxic := AssertToxicExists(t, toxics, \"foobar\", \"noop\", \"downstream\", true)\n\t\tif toxic.Toxicity != 1.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t})\n}\n\nfunc TestUpdateToxics(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\tlatency, err := testProxy.AddToxic(\"\", \"latency\", \"downstream\", -1, tclient.Attributes{\n\t\t\t\"latency\": 100,\n\t\t\t\"jitter\":  10,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\tif latency.Toxicity != 1.0 || latency.Attributes[\"latency\"] != 100.0 ||\n\t\t\tlatency.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Latency toxic did not start up with correct settings:\", latency)\n\t\t}\n\n\t\tlatency, err = testProxy.UpdateToxic(\"latency_downstream\", 0.5, tclient.Attributes{\n\t\t\t\"latency\": 1000,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\tif latency.Toxicity != 0.5 || latency.Attributes[\"latency\"] != 1000.0 ||\n\t\t\tlatency.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Latency toxic did not get updated with the correct settings:\", latency)\n\t\t}\n\n\t\tlatency, err = testProxy.UpdateToxic(\"latency_downstream\", -1, tclient.Attributes{\n\t\t\t\"latency\": 500,\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\tif latency.Toxicity != 0.5 || latency.Attributes[\"latency\"] != 500.0 ||\n\t\t\tlatency.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Latency toxic did not get updated with the correct settings:\", latency)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\n\t\ttoxic := AssertToxicExists(t, toxics, \"latency_downstream\", \"latency\", \"downstream\", true)\n\t\tif toxic.Toxicity != 0.5 || toxic.Attributes[\"latency\"] != 500.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 10.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\t})\n}\n\nfunc TestRemoveToxic(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"\", \"latency\", \"downstream\", 1, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\n\t\ttoxics, err := testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\n\t\ttoxic := AssertToxicExists(t, toxics, \"latency_downstream\", \"latency\", \"downstream\", true)\n\t\tif toxic.Toxicity != 1.0 || toxic.Attributes[\"latency\"] != 0.0 ||\n\t\t\ttoxic.Attributes[\"jitter\"] != 0.0 {\n\t\t\tt.Fatal(\"Toxic was not read back correctly:\", toxic)\n\t\t}\n\n\t\terr = testProxy.RemoveToxic(\"latency_downstream\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error removing toxic:\", err)\n\t\t}\n\n\t\ttoxics, err = testProxy.Toxics()\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Error returning toxics:\", err)\n\t\t}\n\t\tAssertToxicExists(t, toxics, \"latency_downstream\", \"\", \"\", false)\n\t})\n}\n\nfunc TestVersionEndpointReturnsVersion(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\tresp, err := http.Get(addr + \"/version\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to get index\", err)\n\t\t}\n\t\tdefer resp.Body.Close()\n\n\t\tbody, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to read body from response\")\n\t\t}\n\n\t\tif string(body) != \"{\\\"version\\\": \\\"git\\\"}\\n\" {\n\t\t\tt.Fatal(\"Expected to return Version from /version, got:\", string(body))\n\t\t}\n\t})\n}\n\nfunc TestInvalidStream(t *testing.T) {\n\tWithServer(t, func(addr string) {\n\t\ttestProxy, err := client.CreateProxy(\"mysql_master\", \"localhost:3310\", \"localhost:20001\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Unable to create proxy:\", err)\n\t\t}\n\n\t\t_, err = testProxy.AddToxic(\"\", \"latency\", \"walrustream\", 1, nil)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"Error setting toxic:\", err)\n\t\t}\n\t})\n}\n\nfunc AssertToxicExists(\n\tt *testing.T,\n\ttoxics tclient.Toxics,\n\tname, typeName, stream string,\n\texists bool,\n) *tclient.Toxic {\n\tvar toxic *tclient.Toxic\n\tvar actualType, actualStream string\n\n\tfor i, tox := range toxics {\n\t\tif name == tox.Name {\n\t\t\ttoxic = &toxics[i]\n\t\t\tactualType = tox.Type\n\t\t\tactualStream = tox.Stream\n\t\t}\n\t}\n\tif exists {\n\t\tif toxic == nil {\n\t\t\tt.Fatalf(\"Expected to see %s toxic in list\", name)\n\t\t}\n\n\t\tif actualType != typeName {\n\t\t\tt.Fatalf(\"Expected %s to be of type %s, found %s\", name, typeName, actualType)\n\t\t}\n\n\t\tif actualStream != stream {\n\t\t\tt.Fatalf(\"Expected %s to be in stream %s, found %s\", name, stream, actualStream)\n\t\t}\n\t} else if toxic != nil && actualStream == stream {\n\t\tt.Fatalf(\"Expected %s toxic to be missing from list, found type %s\", name, actualType)\n\t}\n\treturn toxic\n}\n"
        },
        {
          "name": "client",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "collectors",
          "type": "tree",
          "content": null
        },
        {
          "name": "dev.yml",
          "type": "blob",
          "size": 0.2021484375,
          "content": "---\n\nname: toxiproxy\n\ntype: go\n\nup:\n  - packages:\n      - gnu-tar\n      - golangci-lint\n      - goreleaser\n      - shellcheck\n      - shfmt\n      - yamllint\n  - go:\n      version: 1.22.8\n      modules: true\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.05078125,
          "content": "module github.com/Shopify/toxiproxy/v2\n\ngo 1.22\n\nrequire (\n\tgithub.com/gorilla/mux v1.8.1\n\tgithub.com/prometheus/client_golang v1.20.5\n\tgithub.com/rs/zerolog v1.33.0\n\tgithub.com/urfave/cli/v2 v2.27.5\n\tgolang.org/x/term v0.28.0\n\tgopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7\n)\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.5 // indirect\n\tgithub.com/klauspost/compress v1.17.9 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.55.0 // indirect\n\tgithub.com/prometheus/procfs v0.15.1 // indirect\n\tgithub.com/rs/xid v1.5.0 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgoogle.golang.org/protobuf v1.34.2 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.7099609375,
          "content": "github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.5 h1:ZtcqGrnekaHpVLArFSe4HK5DoKx1T0rq2DwVB0alcyc=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.5/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/gorilla/mux v1.8.1 h1:TuBL49tXwgrFYWhqrNgrUNEY92u81SPhu7sTdzQEiWY=\ngithub.com/gorilla/mux v1.8.1/go.mod h1:AKf9I4AEqPTmMytcMc0KkNouC66V3BtZ4qD5fmWSiMQ=\ngithub.com/klauspost/compress v1.17.9 h1:6KIumPrER1LHsvBVuDa0r5xaG0Es51mhhB9BQB2qeMA=\ngithub.com/klauspost/compress v1.17.9/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/prometheus/client_golang v1.20.5 h1:cxppBPuYhUnsO6yo/aoRol4L7q7UFfdm+bR9r+8l63Y=\ngithub.com/prometheus/client_golang v1.20.5/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.55.0 h1:KEi6DK7lXW/m7Ig5i47x0vRzuBsHuvJdi5ee6Y3G1dc=\ngithub.com/prometheus/common v0.55.0/go.mod h1:2SECS4xJG1kd8XF9IcM1gMX6510RAEL65zxzNImwdc8=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/rs/xid v1.5.0 h1:mKX4bl4iPYJtEIxp6CYiUuLQ/8DYMoz0PUdtGgMFRVc=\ngithub.com/rs/xid v1.5.0/go.mod h1:trrq9SKmegXys3aeAKXMUTdJsYXVwGY3RLcfgqegfbg=\ngithub.com/rs/zerolog v1.33.0 h1:1cU2KZkvPxNyfgEmhHAz/1A9Bz+llsdYzklWFzgp0r8=\ngithub.com/rs/zerolog v1.33.0/go.mod h1:/7mN4D5sKwJLZQ2b/znpjC3/GQWY/xaDXUM0kKWRHss=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/urfave/cli/v2 v2.27.5 h1:WoHEJLdsXr6dDWoJgMq/CboDmyY/8HMMH1fTECbih+w=\ngithub.com/urfave/cli/v2 v2.27.5/go.mod h1:3Sevf16NykTbInEnD0yKkjDAeZDS0A6bzhBH5hrMvTQ=\ngithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1 h1:gEOO8jv9F4OT7lGCjxCBTO/36wtF6j2nSip77qHd4x4=\ngithub.com/xrash/smetrics v0.0.0-20240521201337-686a1a2994c1/go.mod h1:Ohn+xnUBiLI6FVj/9LpzZWtj1/D6lUovWYBkxHVV3aM=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=\ngolang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=\ngoogle.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=\ngoogle.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\n"
        },
        {
          "name": "link.go",
          "type": "blob",
          "size": 7.6591796875,
          "content": "package toxiproxy\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/Shopify/toxiproxy/v2/stream\"\n\t\"github.com/Shopify/toxiproxy/v2/toxics\"\n)\n\n// ToxicLinks are single direction pipelines that connects an input and output via\n// a chain of toxics. The chain always starts with a NoopToxic, and toxics are added\n// and removed as they are enabled/disabled. New toxics are always added to the end\n// of the chain.\n//\n// |         NoopToxic  LatencyToxic\n// |             v           v\n// | Input > ToxicStub > ToxicStub > Output.\ntype ToxicLink struct {\n\tstubs     []*toxics.ToxicStub\n\tproxy     *Proxy\n\ttoxics    *ToxicCollection\n\tinput     *stream.ChanWriter\n\toutput    *stream.ChanReader\n\tdirection stream.Direction\n\tLogger    *zerolog.Logger\n}\n\nfunc NewToxicLink(\n\tproxy *Proxy,\n\tcollection *ToxicCollection,\n\tdirection stream.Direction,\n\tlogger zerolog.Logger,\n) *ToxicLink {\n\tlink := &ToxicLink{\n\t\tstubs: make(\n\t\t\t[]*toxics.ToxicStub,\n\t\t\tlen(collection.chain[direction]),\n\t\t\tcap(collection.chain[direction]),\n\t\t),\n\t\tproxy:     proxy,\n\t\ttoxics:    collection,\n\t\tdirection: direction,\n\t\tLogger:    &logger,\n\t}\n\t// Initialize the link with ToxicStubs\n\tlast := make(chan *stream.StreamChunk) // The first toxic is always a noop\n\tlink.input = stream.NewChanWriter(last)\n\tfor i := 0; i < len(link.stubs); i++ {\n\t\tvar next chan *stream.StreamChunk\n\t\tif i+1 < len(link.stubs) {\n\t\t\tnext = make(chan *stream.StreamChunk, link.toxics.chain[direction][i+1].BufferSize)\n\t\t} else {\n\t\t\tnext = make(chan *stream.StreamChunk)\n\t\t}\n\n\t\tlink.stubs[i] = toxics.NewToxicStub(last, next)\n\t\tlast = next\n\t}\n\tlink.output = stream.NewChanReader(last)\n\treturn link\n}\n\n// Start the link with the specified toxics.\nfunc (link *ToxicLink) Start(\n\tserver *ApiServer,\n\tname string,\n\tsource io.Reader,\n\tdest io.WriteCloser,\n) {\n\tlogger := link.Logger\n\tlogger.\n\t\tDebug().\n\t\tStr(\"direction\", link.Direction()).\n\t\tMsg(\"Setup connection\")\n\n\tlabels := []string{\n\t\tlink.Direction(),\n\t\tlink.proxy.Name,\n\t\tlink.proxy.Listen,\n\t\tlink.proxy.Upstream}\n\n\tgo link.read(labels, server, source)\n\n\tfor i, toxic := range link.toxics.chain[link.direction] {\n\t\tif stateful, ok := toxic.Toxic.(toxics.StatefulToxic); ok {\n\t\t\tlink.stubs[i].State = stateful.NewState()\n\t\t}\n\n\t\tif _, ok := toxic.Toxic.(*toxics.ResetToxic); ok {\n\t\t\tif err := source.(*net.TCPConn).SetLinger(0); err != nil {\n\t\t\t\tlogger.Err(err).\n\t\t\t\t\tStr(\"toxic\", toxic.Type).\n\t\t\t\t\tMsg(\"source: Unable to setLinger(ms)\")\n\t\t\t}\n\n\t\t\tif err := dest.(*net.TCPConn).SetLinger(0); err != nil {\n\t\t\t\tlogger.Err(err).\n\t\t\t\t\tStr(\"toxic\", toxic.Type).\n\t\t\t\t\tMsg(\"dest: Unable to setLinger(ms)\")\n\t\t\t}\n\t\t}\n\n\t\tgo link.stubs[i].Run(toxic)\n\t}\n\n\tgo link.write(labels, name, server, dest)\n}\n\n// read copies bytes from a source to the link's input channel.\nfunc (link *ToxicLink) read(\n\tmetricLabels []string,\n\tserver *ApiServer,\n\tsource io.Reader,\n) {\n\tlogger := link.Logger\n\tbytes, err := io.Copy(link.input, source)\n\tif err != nil {\n\t\tlogger.Warn().\n\t\t\tInt64(\"bytes\", bytes).\n\t\t\tErr(err).\n\t\t\tMsg(\"Source terminated\")\n\t}\n\tif server.Metrics.proxyMetricsEnabled() {\n\t\tserver.Metrics.ProxyMetrics.ReceivedBytesTotal.\n\t\t\tWithLabelValues(metricLabels...).Add(float64(bytes))\n\t}\n\tlink.input.Close()\n}\n\n// write copies bytes from the link's output channel to a destination.\nfunc (link *ToxicLink) write(\n\tmetricLabels []string,\n\tname string,\n\tserver *ApiServer, // TODO: Replace with AppConfig for Metrics and Logger\n\tdest io.WriteCloser,\n) {\n\tlogger := link.Logger.\n\t\tWith().\n\t\tStr(\"component\", \"ToxicLink\").\n\t\tStr(\"method\", \"write\").\n\t\tStr(\"link\", name).\n\t\tStr(\"proxy\", link.proxy.Name).\n\t\tStr(\"link_addr\", fmt.Sprintf(\"%p\", link)).\n\t\tLogger()\n\n\tbytes, err := io.Copy(dest, link.output)\n\tif err != nil {\n\t\tlogger.Warn().\n\t\t\tInt64(\"bytes\", bytes).\n\t\t\tErr(err).\n\t\t\tMsg(\"Could not write to destination\")\n\t} else if server.Metrics.proxyMetricsEnabled() {\n\t\tserver.Metrics.ProxyMetrics.SentBytesTotal.\n\t\t\tWithLabelValues(metricLabels...).Add(float64(bytes))\n\t}\n\n\tdest.Close()\n\tlogger.Trace().Msgf(\"Remove link %s from ToxicCollection\", name)\n\tlink.toxics.RemoveLink(name)\n\tlogger.Trace().Msgf(\"RemoveConnection %s from Proxy %s\", name, link.proxy.Name)\n\tlink.proxy.RemoveConnection(name)\n}\n\n// Add a toxic to the end of the chain.\nfunc (link *ToxicLink) AddToxic(toxic *toxics.ToxicWrapper) {\n\ti := len(link.stubs)\n\n\tnewin := make(chan *stream.StreamChunk, toxic.BufferSize)\n\tlink.stubs = append(link.stubs, toxics.NewToxicStub(newin, link.stubs[i-1].Output))\n\n\t// Interrupt the last toxic so that we don't have a race when moving channels\n\tif link.stubs[i-1].InterruptToxic() {\n\t\tlink.stubs[i-1].Output = newin\n\n\t\tif stateful, ok := toxic.Toxic.(toxics.StatefulToxic); ok {\n\t\t\tlink.stubs[i].State = stateful.NewState()\n\t\t}\n\n\t\tgo link.stubs[i].Run(toxic)\n\t\tgo link.stubs[i-1].Run(link.toxics.chain[link.direction][i-1])\n\t} else {\n\t\t// This link is already closed, make sure the new toxic matches\n\t\tlink.stubs[i].Output = newin // The real output is already closed, close this instead\n\t\tlink.stubs[i].Close()\n\t}\n}\n\n// Update an existing toxic in the chain.\nfunc (link *ToxicLink) UpdateToxic(toxic *toxics.ToxicWrapper) {\n\tif link.stubs[toxic.Index].InterruptToxic() {\n\t\tgo link.stubs[toxic.Index].Run(toxic)\n\t}\n}\n\n// Remove an existing toxic from the chain.\nfunc (link *ToxicLink) RemoveToxic(ctx context.Context, toxic *toxics.ToxicWrapper) {\n\ttoxic_index := toxic.Index\n\tlog := zerolog.Ctx(ctx).\n\t\tWith().\n\t\tStr(\"component\", \"ToxicLink\").\n\t\tStr(\"method\", \"RemoveToxic\").\n\t\tStr(\"toxic\", toxic.Name).\n\t\tStr(\"toxic_type\", toxic.Type).\n\t\tInt(\"toxic_index\", toxic.Index).\n\t\tStr(\"link_addr\", fmt.Sprintf(\"%p\", link)).\n\t\tStr(\"toxic_stub_addr\", fmt.Sprintf(\"%p\", link.stubs[toxic_index])).\n\t\tStr(\"prev_toxic_stub_addr\", fmt.Sprintf(\"%p\", link.stubs[toxic_index-1])).\n\t\tLogger()\n\n\tif link.stubs[toxic_index].InterruptToxic() {\n\t\tcleanup, ok := toxic.Toxic.(toxics.CleanupToxic)\n\t\tif ok {\n\t\t\tcleanup.Cleanup(link.stubs[toxic_index])\n\t\t\t// Cleanup could have closed the stub.\n\t\t\tif link.stubs[toxic_index].Closed() {\n\t\t\t\tlog.Trace().Msg(\"Cleanup closed toxic and removed toxic\")\n\t\t\t\t// TODO: Check if cleanup happen would link.stubs recalculated?\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tlog.Trace().Msg(\"Interrupting the previous toxic to update its output\")\n\t\tstop := make(chan bool)\n\t\tgo func(stub *toxics.ToxicStub, stop chan bool) {\n\t\t\tstop <- stub.InterruptToxic()\n\t\t}(link.stubs[toxic_index-1], stop)\n\n\t\t// Unblock the previous toxic if it is trying to flush\n\t\t// If the previous toxic is closed, continue flusing until we reach the end.\n\t\tinterrupted := false\n\t\tstopped := false\n\t\tfor !interrupted {\n\t\t\tselect {\n\t\t\tcase interrupted = <-stop:\n\t\t\t\tstopped = true\n\t\t\tcase tmp := <-link.stubs[toxic_index].Input:\n\t\t\t\tif tmp == nil {\n\t\t\t\t\tlink.stubs[toxic_index].Close()\n\t\t\t\t\tif !stopped {\n\t\t\t\t\t\t<-stop\n\t\t\t\t\t}\n\t\t\t\t\treturn // TODO: There are some steps after this to clean buffer\n\t\t\t\t}\n\n\t\t\t\terr := link.stubs[toxic_index].WriteOutput(tmp, 5*time.Second)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Err(err).\n\t\t\t\t\t\tMsg(\"Could not write last packets after interrupt to Output\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Empty the toxic's buffer if necessary\n\t\tfor len(link.stubs[toxic_index].Input) > 0 {\n\t\t\ttmp := <-link.stubs[toxic_index].Input\n\t\t\tif tmp == nil {\n\t\t\t\tlink.stubs[toxic_index].Close()\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr := link.stubs[toxic_index].WriteOutput(tmp, 5*time.Second)\n\t\t\tif err != nil {\n\t\t\t\tlog.Err(err).\n\t\t\t\t\tMsg(\"Could not write last packets after interrupt to Output\")\n\t\t\t}\n\t\t}\n\n\t\tlink.stubs[toxic_index-1].Output = link.stubs[toxic_index].Output\n\t\tlink.stubs = append(link.stubs[:toxic_index], link.stubs[toxic_index+1:]...)\n\n\t\tgo link.stubs[toxic_index-1].Run(link.toxics.chain[link.direction][toxic_index-1])\n\t}\n}\n\n// Direction returns the direction of the link (upstream or downstream).\nfunc (link *ToxicLink) Direction() string {\n\treturn link.direction.String()\n}\n"
        },
        {
          "name": "link_test.go",
          "type": "blob",
          "size": 8.0419921875,
          "content": "package toxiproxy\n\nimport (\n\t\"context\"\n\t\"encoding/binary\"\n\t\"flag\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/Shopify/toxiproxy/v2/stream\"\n\t\"github.com/Shopify/toxiproxy/v2/testhelper\"\n\t\"github.com/Shopify/toxiproxy/v2/toxics\"\n)\n\nfunc TestToxicsAreLoaded(t *testing.T) {\n\tif toxics.Count() < 1 {\n\t\tt.Fatal(\"No toxics loaded!\")\n\t}\n}\n\nfunc TestStubInitializaation(t *testing.T) {\n\tcollection := NewToxicCollection(nil)\n\tlink := NewToxicLink(nil, collection, stream.Downstream, zerolog.Nop())\n\tif len(link.stubs) != 1 {\n\t\tt.Fatalf(\"Link created with wrong number of stubs: %d != 1\", len(link.stubs))\n\t}\n\n\tif cap(link.stubs) != toxics.Count()+1 {\n\t\tt.Fatalf(\"Link created with wrong capacity: %d != %d\", cap(link.stubs), toxics.Count()+1)\n\t}\n\n\tif cap(link.stubs[0].Input) != 0 {\n\t\tt.Fatalf(\"Noop buffer was not initialized as 0: %d\", cap(link.stubs[0].Input))\n\t}\n\n\tif cap(link.stubs[0].Output) != 0 {\n\t\tt.Fatalf(\"Link output buffer was not initialized as 0: %d\", cap(link.stubs[0].Output))\n\t}\n}\n\nfunc TestStubInitializaationWithToxics(t *testing.T) {\n\tcollection := NewToxicCollection(nil)\n\tcollection.chainAddToxic(&toxics.ToxicWrapper{\n\t\tToxic:      new(toxics.LatencyToxic),\n\t\tType:       \"latency\",\n\t\tDirection:  stream.Downstream,\n\t\tBufferSize: 1024,\n\t\tToxicity:   1,\n\t})\n\tcollection.chainAddToxic(&toxics.ToxicWrapper{\n\t\tToxic:     new(toxics.BandwidthToxic),\n\t\tType:      \"bandwidth\",\n\t\tDirection: stream.Downstream,\n\t\tToxicity:  1,\n\t})\n\tlink := NewToxicLink(nil, collection, stream.Downstream, zerolog.Nop())\n\n\tif len(link.stubs) != 3 {\n\t\tt.Fatalf(\"Link created with wrong number of stubs: %d != 3\", len(link.stubs))\n\t}\n\n\tif cap(link.stubs) != toxics.Count()+1 {\n\t\tt.Fatalf(\"Link created with wrong capacity: %d != %d\", cap(link.stubs), toxics.Count()+1)\n\t}\n\n\tif cap(link.stubs[len(link.stubs)-1].Output) != 0 {\n\t\tt.Fatalf(\"Link output buffer was not initialized as 0: %d\", cap(link.stubs[0].Output))\n\t}\n\n\tfor i, toxic := range collection.chain[stream.Downstream] {\n\t\tif cap(link.stubs[i].Input) != toxic.BufferSize {\n\t\t\tt.Fatalf(\n\t\t\t\t\"%s buffer was not initialized as %d: %d\",\n\t\t\t\ttoxic.Type,\n\t\t\t\ttoxic.BufferSize,\n\t\t\t\tcap(link.stubs[i].Input),\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunc TestAddRemoveStubs(t *testing.T) {\n\tctx := context.Background()\n\tcollection := NewToxicCollection(nil)\n\tlink := NewToxicLink(nil, collection, stream.Downstream, zerolog.Nop())\n\tgo link.stubs[0].Run(collection.chain[stream.Downstream][0])\n\tcollection.links[\"test\"] = link\n\n\t// Add stubs\n\tcollection.chainAddToxic(&toxics.ToxicWrapper{\n\t\tToxic:      new(toxics.LatencyToxic),\n\t\tType:       \"latency\",\n\t\tDirection:  stream.Downstream,\n\t\tBufferSize: 1024,\n\t\tToxicity:   1,\n\t})\n\ttoxic := &toxics.ToxicWrapper{\n\t\tToxic:      new(toxics.BandwidthToxic),\n\t\tType:       \"bandwidth\",\n\t\tDirection:  stream.Downstream,\n\t\tBufferSize: 2048,\n\t\tToxicity:   1,\n\t}\n\tcollection.chainAddToxic(toxic)\n\tif cap(link.stubs[len(link.stubs)-1].Output) != 0 {\n\t\tt.Fatalf(\"Link output buffer was not initialized as 0: %d\", cap(link.stubs[0].Output))\n\t}\n\tfor i, toxic := range collection.chain[stream.Downstream] {\n\t\tif cap(link.stubs[i].Input) != toxic.BufferSize {\n\t\t\tt.Fatalf(\n\t\t\t\t\"%s buffer was not initialized as %d: %d\",\n\t\t\t\ttoxic.Type,\n\t\t\t\ttoxic.BufferSize,\n\t\t\t\tcap(link.stubs[i].Input),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Remove stubs\n\tcollection.chainRemoveToxic(ctx, toxic)\n\tif cap(link.stubs[len(link.stubs)-1].Output) != 0 {\n\t\tt.Fatalf(\"Link output buffer was not initialized as 0: %d\", cap(link.stubs[0].Output))\n\t}\n\tfor i, toxic := range collection.chain[stream.Downstream] {\n\t\tif cap(link.stubs[i].Input) != toxic.BufferSize {\n\t\t\tt.Fatalf(\n\t\t\t\t\"%s buffer was not initialized as %d: %d\",\n\t\t\t\ttoxic.Type,\n\t\t\t\ttoxic.BufferSize,\n\t\t\t\tcap(link.stubs[i].Input),\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunc TestNoDataDropped(t *testing.T) {\n\tctx := context.Background()\n\tcollection := NewToxicCollection(nil)\n\tlink := NewToxicLink(nil, collection, stream.Downstream, zerolog.Nop())\n\tgo link.stubs[0].Run(collection.chain[stream.Downstream][0])\n\tcollection.links[\"test\"] = link\n\n\ttoxic := &toxics.ToxicWrapper{\n\t\tToxic: &toxics.LatencyToxic{\n\t\t\tLatency: 1000,\n\t\t},\n\t\tType:       \"latency\",\n\t\tDirection:  stream.Downstream,\n\t\tBufferSize: 1024,\n\t\tToxicity:   1,\n\t}\n\n\tdone := make(chan struct{})\n\tdefer close(done)\n\tgo func() {\n\t\tfor i := uint16(0); i < 65535; i++ {\n\t\t\tbuf := make([]byte, 2)\n\t\t\tbinary.BigEndian.PutUint16(buf, i)\n\t\t\tlink.input.Write(buf)\n\t\t}\n\t\tlink.input.Close()\n\t}()\n\tgo func(ctx context.Context) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tcollection.chainAddToxic(toxic)\n\t\t\t\tcollection.chainRemoveToxic(ctx, toxic)\n\t\t\t}\n\t\t}\n\t}(ctx)\n\n\tbuf := make([]byte, 2)\n\tfor i := uint16(0); i < 65535; i++ {\n\t\tn, err := link.output.Read(buf)\n\t\tif n != 2 || err != nil {\n\t\t\tt.Fatalf(\"Read failed: %d %v\", n, err)\n\t\t} else {\n\t\t\tval := binary.BigEndian.Uint16(buf)\n\t\t\tif val != i {\n\t\t\t\tt.Fatalf(\"Read incorrect bytes: %v != %d\", val, i)\n\t\t\t}\n\t\t}\n\t}\n\tn, err := link.output.Read(buf)\n\tif n != 0 || err != io.EOF {\n\t\tt.Fatalf(\"Expected EOF: %d %v\", n, err)\n\t}\n}\n\nfunc TestToxicity(t *testing.T) {\n\tcollection := NewToxicCollection(nil)\n\tlink := NewToxicLink(nil, collection, stream.Downstream, zerolog.Nop())\n\tgo link.stubs[0].Run(collection.chain[stream.Downstream][0])\n\tcollection.links[\"test\"] = link\n\n\ttoxic := &toxics.ToxicWrapper{\n\t\tToxic:     new(toxics.TimeoutToxic),\n\t\tName:      \"timeout1\",\n\t\tType:      \"timeout\",\n\t\tDirection: stream.Downstream,\n\t\tToxicity:  0,\n\t}\n\tcollection.chainAddToxic(toxic)\n\n\t// Toxic should be a Noop because of toxicity\n\tn, err := link.input.Write([]byte{42})\n\tif n != 1 || err != nil {\n\t\tt.Fatalf(\"Write failed: %d %v\", n, err)\n\t}\n\tbuf := make([]byte, 2)\n\tn, err = link.output.Read(buf)\n\tif n != 1 || err != nil {\n\t\tt.Fatalf(\"Read failed: %d %v\", n, err)\n\t} else if buf[0] != 42 {\n\t\tt.Fatalf(\"Read wrong byte: %x\", buf[0])\n\t}\n\n\ttoxic.Toxicity = 1\n\ttoxic.Toxic.(*toxics.TimeoutToxic).Timeout = 100\n\tcollection.chainUpdateToxic(toxic)\n\n\terr = testhelper.TimeoutAfter(150*time.Millisecond, func() {\n\t\tn, err = link.input.Write([]byte{42})\n\t\tif n != 1 || err != nil {\n\t\t\tt.Fatalf(\"Write failed: %d %v\", n, err)\n\t\t}\n\t\tn, err = link.output.Read(buf)\n\t\tif n != 0 || err != io.EOF {\n\t\t\tt.Fatalf(\"Read did not get EOF: %d %v\", n, err)\n\t\t}\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestStateCreated(t *testing.T) {\n\tcollection := NewToxicCollection(nil)\n\tlog := zerolog.Nop()\n\tif flag.Lookup(\"test.v\").DefValue == \"true\" {\n\t\tlog = zerolog.New(os.Stdout).With().Caller().Timestamp().Logger()\n\t}\n\n\tlink := NewToxicLink(nil, collection, stream.Downstream, log)\n\tgo link.stubs[0].Run(collection.chain[stream.Downstream][0])\n\tcollection.links[\"test\"] = link\n\n\tcollection.chainAddToxic(&toxics.ToxicWrapper{\n\t\tToxic:     new(toxics.LimitDataToxic),\n\t\tType:      \"limit_data\",\n\t\tDirection: stream.Downstream,\n\t\tToxicity:  1,\n\t})\n\tif link.stubs[len(link.stubs)-1].State == nil {\n\t\tt.Fatalf(\"New toxic did not have state object created.\")\n\t}\n}\n\nfunc TestRemoveToxicWithBrokenConnection(t *testing.T) {\n\tctx := context.Background()\n\n\tlog := zerolog.Nop()\n\tif flag.Lookup(\"test.v\").DefValue == \"true\" {\n\t\tlog = zerolog.New(os.Stdout).With().Caller().Timestamp().Logger()\n\t}\n\tctx = log.WithContext(ctx)\n\n\tcollection := NewToxicCollection(nil)\n\tlink := NewToxicLink(nil, collection, stream.Downstream, log)\n\tgo link.stubs[0].Run(collection.chain[stream.Downstream][0])\n\tcollection.links[\"test\"] = link\n\n\ttoxics := [2]*toxics.ToxicWrapper{\n\t\t{\n\t\t\tToxic: &toxics.BandwidthToxic{\n\t\t\t\tRate: 0,\n\t\t\t},\n\t\t\tType:      \"bandwidth\",\n\t\t\tDirection: stream.Downstream,\n\t\t\tToxicity:  1,\n\t\t},\n\t\t{\n\t\t\tToxic: &toxics.BandwidthToxic{\n\t\t\t\tRate: 0,\n\t\t\t},\n\t\t\tType:      \"bandwidth\",\n\t\t\tDirection: stream.Upstream,\n\t\t\tToxicity:  1,\n\t\t},\n\t}\n\n\tcollection.chainAddToxic(toxics[0])\n\tcollection.chainAddToxic(toxics[1])\n\n\tdone := make(chan struct{})\n\tdefer close(done)\n\n\tvar data uint16 = 42\n\tgo func(log zerolog.Logger) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tlink.input.Close()\n\t\t\t\treturn\n\t\t\tcase <-time.After(10 * time.Second):\n\t\t\t\tlog.Print(\"Finish load\")\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tbuf := make([]byte, 2)\n\t\t\t\tbinary.BigEndian.PutUint16(buf, data)\n\t\t\t\tlink.input.Write(buf)\n\t\t\t}\n\t\t}\n\t}(log)\n\n\tcollection.chainRemoveToxic(ctx, toxics[0])\n\tcollection.chainRemoveToxic(ctx, toxics[1])\n}\n"
        },
        {
          "name": "metrics.go",
          "type": "blob",
          "size": 1.4462890625,
          "content": "package toxiproxy\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/Shopify/toxiproxy/v2/collectors\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\n// NewMetricsContainer initializes a container for storing all prometheus metrics.\nfunc NewMetricsContainer(registry *prometheus.Registry) *metricsContainer {\n\tif registry == nil {\n\t\tregistry = prometheus.NewRegistry()\n\t}\n\treturn &metricsContainer{\n\t\tregistry: registry,\n\t}\n}\n\ntype metricsContainer struct {\n\tRuntimeMetrics *collectors.RuntimeMetricCollectors\n\tProxyMetrics   *collectors.ProxyMetricCollectors\n\n\tregistry *prometheus.Registry\n}\n\nfunc (m *metricsContainer) runtimeMetricsEnabled() bool {\n\treturn m.RuntimeMetrics != nil\n}\n\nfunc (m *metricsContainer) proxyMetricsEnabled() bool {\n\treturn m.ProxyMetrics != nil\n}\n\n// anyMetricsEnabled determines whether we have any prometheus metrics registered for exporting.\nfunc (m *metricsContainer) anyMetricsEnabled() bool {\n\treturn m.runtimeMetricsEnabled() || m.proxyMetricsEnabled()\n}\n\n// handler returns an HTTP handler with the necessary collectors registered\n// via a global prometheus registry.\nfunc (m *metricsContainer) handler() http.Handler {\n\tif m.runtimeMetricsEnabled() {\n\t\tm.registry.MustRegister(m.RuntimeMetrics.Collectors()...)\n\t}\n\tif m.proxyMetricsEnabled() {\n\t\tm.registry.MustRegister(m.ProxyMetrics.Collectors()...)\n\t}\n\treturn promhttp.HandlerFor(\n\t\tm.registry, promhttp.HandlerOpts{Registry: m.registry})\n}\n"
        },
        {
          "name": "metrics_test.go",
          "type": "blob",
          "size": 2.6611328125,
          "content": "package toxiproxy\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/Shopify/toxiproxy/v2/collectors\"\n\t\"github.com/Shopify/toxiproxy/v2/stream\"\n)\n\nfunc TestProxyMetricsReceivedSentBytes(t *testing.T) {\n\tsrv := NewServer(NewMetricsContainer(prometheus.NewRegistry()), zerolog.Nop())\n\tsrv.Metrics.ProxyMetrics = collectors.NewProxyMetricCollectors()\n\n\tproxy := NewProxy(srv, \"test_proxy_metrics_received_sent_bytes\", \"localhost:0\", \"upstream\")\n\n\tr := bufio.NewReader(bytes.NewBufferString(\"hello\"))\n\tw := &testWriteCloser{\n\t\tbufio.NewWriter(bytes.NewBuffer([]byte{})),\n\t}\n\tlinkName := \"testupstream\"\n\tproxy.Toxics.StartLink(srv, linkName, r, w, stream.Upstream)\n\tproxy.Toxics.RemoveLink(linkName)\n\n\tactual := prometheusOutput(t, srv, \"toxiproxy_proxy\")\n\n\texpected := []string{\n\t\t`toxiproxy_proxy_received_bytes_total{` +\n\t\t\t`direction=\"upstream\",listener=\"localhost:0\",` +\n\t\t\t`proxy=\"test_proxy_metrics_received_sent_bytes\",upstream=\"upstream\"` +\n\t\t\t`} 5`,\n\n\t\t`toxiproxy_proxy_sent_bytes_total{` +\n\t\t\t`direction=\"upstream\",listener=\"localhost:0\",` +\n\t\t\t`proxy=\"test_proxy_metrics_received_sent_bytes\",upstream=\"upstream\"` +\n\t\t\t`} 5`,\n\t}\n\n\tif !reflect.DeepEqual(actual, expected) {\n\t\tt.Fatalf(\n\t\t\t\"\\nexpected:\\n  [%v]\\ngot:\\n  [%v]\",\n\t\t\tstrings.Join(expected, \"\\n  \"),\n\t\t\tstrings.Join(actual, \"\\n  \"),\n\t\t)\n\t}\n}\n\nfunc TestRuntimeMetricsBuildInfo(t *testing.T) {\n\tsrv := NewServer(NewMetricsContainer(prometheus.NewRegistry()), zerolog.Nop())\n\tsrv.Metrics.RuntimeMetrics = collectors.NewRuntimeMetricCollectors()\n\n\texpected := `go_build_info{checksum=\"[^\"]*\",path=\"[^\"]*\",version=\"[^\"]*\"} 1`\n\n\tactual := prometheusOutput(t, srv, \"go_build_info\")\n\n\tif len(actual) != 1 {\n\t\tt.Fatalf(\n\t\t\t\"\\nexpected: 1 item\\ngot: %d item(s)\\nmetrics:\\n  %+v\",\n\t\t\tlen(actual),\n\t\t\tstrings.Join(actual, \"\\n  \"),\n\t\t)\n\t}\n\n\tmatched, err := regexp.MatchString(expected, actual[0])\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error: %s\", err)\n\t}\n\tif !matched {\n\t\tt.Fatalf(\"\\nexpected:\\n  %v\\nto match:\\n  %v\", actual[0], expected)\n\t}\n}\n\ntype testWriteCloser struct {\n\t*bufio.Writer\n}\n\nfunc (t *testWriteCloser) Close() error {\n\treturn t.Flush()\n}\n\nfunc prometheusOutput(t *testing.T, apiServer *ApiServer, prefix string) []string {\n\tt.Helper()\n\n\ttestServer := httptest.NewServer(apiServer.Metrics.handler())\n\tdefer testServer.Close()\n\n\tresp, err := http.Get(testServer.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer resp.Body.Close()\n\n\tvar selected []string\n\ts := bufio.NewScanner(resp.Body)\n\tfor s.Scan() {\n\t\tif strings.HasPrefix(s.Text(), prefix) {\n\t\t\tselected = append(selected, s.Text())\n\t\t}\n\t}\n\treturn selected\n}\n"
        },
        {
          "name": "proxy.go",
          "type": "blob",
          "size": 5.310546875,
          "content": "package toxiproxy\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"sync\"\n\n\t\"github.com/rs/zerolog\"\n\ttomb \"gopkg.in/tomb.v1\"\n\n\t\"github.com/Shopify/toxiproxy/v2/stream\"\n)\n\n// Proxy represents the proxy in its entirety with all its links. The main\n// responsibility of Proxy is to accept new client and create Links between the\n// client and upstream.\n//\n// Client <-> toxiproxy <-> Upstream.\ntype Proxy struct {\n\tsync.Mutex\n\n\tName     string `json:\"name\"`\n\tListen   string `json:\"listen\"`\n\tUpstream string `json:\"upstream\"`\n\tEnabled  bool   `json:\"enabled\"`\n\n\tlistener net.Listener\n\tstarted  chan error\n\n\ttomb        tomb.Tomb\n\tconnections ConnectionList\n\tToxics      *ToxicCollection `json:\"-\"`\n\tapiServer   *ApiServer\n\tLogger      *zerolog.Logger\n}\n\ntype ConnectionList struct {\n\tlist map[string]net.Conn\n\tlock sync.Mutex\n}\n\nfunc (c *ConnectionList) Lock() {\n\tc.lock.Lock()\n}\n\nfunc (c *ConnectionList) Unlock() {\n\tc.lock.Unlock()\n}\n\nvar ErrProxyAlreadyStarted = errors.New(\"Proxy already started\")\n\nfunc NewProxy(server *ApiServer, name, listen, upstream string) *Proxy {\n\tl := server.Logger.\n\t\tWith().\n\t\tStr(\"name\", name).\n\t\tStr(\"listen\", listen).\n\t\tStr(\"upstream\", upstream).\n\t\tLogger()\n\n\tproxy := &Proxy{\n\t\tName:        name,\n\t\tListen:      listen,\n\t\tUpstream:    upstream,\n\t\tstarted:     make(chan error),\n\t\tconnections: ConnectionList{list: make(map[string]net.Conn)},\n\t\tapiServer:   server,\n\t\tLogger:      &l,\n\t}\n\tproxy.Toxics = NewToxicCollection(proxy)\n\treturn proxy\n}\n\nfunc (proxy *Proxy) Start() error {\n\tproxy.Lock()\n\tdefer proxy.Unlock()\n\n\treturn start(proxy)\n}\n\nfunc (proxy *Proxy) Update(input *Proxy) error {\n\tproxy.Lock()\n\tdefer proxy.Unlock()\n\n\tif input.Listen != proxy.Listen || input.Upstream != proxy.Upstream {\n\t\tstop(proxy)\n\t\tproxy.Listen = input.Listen\n\t\tproxy.Upstream = input.Upstream\n\t}\n\n\tif input.Enabled != proxy.Enabled {\n\t\tif input.Enabled {\n\t\t\treturn start(proxy)\n\t\t}\n\t\tstop(proxy)\n\t}\n\treturn nil\n}\n\nfunc (proxy *Proxy) Stop() {\n\tproxy.Lock()\n\tdefer proxy.Unlock()\n\n\tstop(proxy)\n}\n\nfunc (proxy *Proxy) listen() error {\n\tvar err error\n\tproxy.listener, err = net.Listen(\"tcp\", proxy.Listen)\n\tif err != nil {\n\t\tproxy.started <- err\n\t\treturn err\n\t}\n\tproxy.Listen = proxy.listener.Addr().String()\n\tproxy.started <- nil\n\n\tproxy.Logger.\n\t\tInfo().\n\t\tMsg(\"Started proxy\")\n\n\treturn nil\n}\n\nfunc (proxy *Proxy) close() {\n\t// Unblock proxy.listener.Accept()\n\terr := proxy.listener.Close()\n\tif err != nil {\n\t\tproxy.Logger.\n\t\t\tWarn().\n\t\t\tErr(err).\n\t\t\tMsg(\"Attempted to close an already closed proxy server\")\n\t}\n}\n\n// This channel is to kill the blocking Accept() call below by closing the\n// net.Listener.\nfunc (proxy *Proxy) freeBlocker(acceptTomb *tomb.Tomb) {\n\t<-proxy.tomb.Dying()\n\n\t// Notify ln.Accept() that the shutdown was safe\n\tacceptTomb.Killf(\"Shutting down from stop()\")\n\n\tproxy.close()\n\n\t// Wait for the accept loop to finish processing\n\tacceptTomb.Wait()\n\tproxy.tomb.Done()\n}\n\n// server runs the Proxy server, accepting new clients and creating Links to\n// connect them to upstreams.\nfunc (proxy *Proxy) server() {\n\terr := proxy.listen()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tacceptTomb := &tomb.Tomb{}\n\tdefer acceptTomb.Done()\n\n\t// This channel is to kill the blocking Accept() call below by closing the\n\t// net.Listener.\n\tgo proxy.freeBlocker(acceptTomb)\n\n\tfor {\n\t\tclient, err := proxy.listener.Accept()\n\t\tif err != nil {\n\t\t\t// This is to confirm we're being shut down in a legit way. Unfortunately,\n\t\t\t// Go doesn't export the error when it's closed from Close() so we have to\n\t\t\t// sync up with a channel here.\n\t\t\t//\n\t\t\t// See http://zhen.org/blog/graceful-shutdown-of-go-net-dot-listeners/\n\t\t\tselect {\n\t\t\tcase <-acceptTomb.Dying():\n\t\t\tdefault:\n\t\t\t\tproxy.Logger.\n\t\t\t\t\tWarn().\n\t\t\t\t\tErr(err).\n\t\t\t\t\tMsg(\"Error while accepting client\")\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tproxy.Logger.\n\t\t\tInfo().\n\t\t\tStr(\"client\", client.RemoteAddr().String()).\n\t\t\tMsg(\"Accepted client\")\n\n\t\tupstream, err := net.Dial(\"tcp\", proxy.Upstream)\n\t\tif err != nil {\n\t\t\tproxy.Logger.\n\t\t\t\tErr(err).\n\t\t\t\tStr(\"client\", client.RemoteAddr().String()).\n\t\t\t\tMsg(\"Unable to open connection to upstream\")\n\t\t\tclient.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tname := client.RemoteAddr().String()\n\t\tproxy.connections.Lock()\n\t\tproxy.connections.list[name+\"upstream\"] = upstream\n\t\tproxy.connections.list[name+\"downstream\"] = client\n\t\tproxy.connections.Unlock()\n\t\tproxy.Toxics.StartLink(proxy.apiServer, name+\"upstream\", client, upstream, stream.Upstream)\n\t\tproxy.Toxics.StartLink(proxy.apiServer, name+\"downstream\", upstream, client, stream.Downstream)\n\t}\n}\n\nfunc (proxy *Proxy) RemoveConnection(name string) {\n\tproxy.connections.Lock()\n\tdefer proxy.connections.Unlock()\n\tdelete(proxy.connections.list, name)\n}\n\n// Starts a proxy, assumes the lock has already been taken.\nfunc start(proxy *Proxy) error {\n\tif proxy.Enabled {\n\t\treturn ErrProxyAlreadyStarted\n\t}\n\n\tproxy.tomb = tomb.Tomb{} // Reset tomb, from previous starts/stops\n\tgo proxy.server()\n\terr := <-proxy.started\n\t// Only enable the proxy if it successfully started\n\tproxy.Enabled = err == nil\n\treturn err\n}\n\n// Stops a proxy, assumes the lock has already been taken.\nfunc stop(proxy *Proxy) {\n\tif !proxy.Enabled {\n\t\treturn\n\t}\n\tproxy.Enabled = false\n\n\tproxy.tomb.Killf(\"Shutting down from stop()\")\n\tproxy.tomb.Wait() // Wait until we stop accepting new connections\n\n\tproxy.connections.Lock()\n\tdefer proxy.connections.Unlock()\n\tfor _, conn := range proxy.connections.list {\n\t\tconn.Close()\n\t}\n\n\tproxy.Logger.\n\t\tInfo().\n\t\tMsg(\"Terminated proxy\")\n}\n"
        },
        {
          "name": "proxy_collection.go",
          "type": "blob",
          "size": 3.5146484375,
          "content": "package toxiproxy\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n)\n\n// ProxyCollection is a collection of proxies. It's the interface for anything\n// to add and remove proxies from the toxiproxy instance. It's responsibility is\n// to maintain the integrity of the proxy set, by guarding for things such as\n// duplicate names.\ntype ProxyCollection struct {\n\tsync.RWMutex\n\n\tproxies map[string]*Proxy\n}\n\nfunc NewProxyCollection() *ProxyCollection {\n\treturn &ProxyCollection{\n\t\tproxies: make(map[string]*Proxy),\n\t}\n}\n\nfunc (collection *ProxyCollection) Add(proxy *Proxy, start bool) error {\n\tcollection.Lock()\n\tdefer collection.Unlock()\n\n\tif _, exists := collection.proxies[proxy.Name]; exists {\n\t\treturn ErrProxyAlreadyExists\n\t}\n\n\tif start {\n\t\terr := proxy.Start()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcollection.proxies[proxy.Name] = proxy\n\n\treturn nil\n}\n\nfunc (collection *ProxyCollection) AddOrReplace(proxy *Proxy, start bool) error {\n\tcollection.Lock()\n\tdefer collection.Unlock()\n\n\tif existing, exists := collection.proxies[proxy.Name]; exists {\n\t\tif existing.Listen == proxy.Listen && existing.Upstream == proxy.Upstream {\n\t\t\treturn nil\n\t\t}\n\t\texisting.Stop()\n\t}\n\n\tif start {\n\t\terr := proxy.Start()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcollection.proxies[proxy.Name] = proxy\n\n\treturn nil\n}\n\nfunc (collection *ProxyCollection) PopulateJson(\n\tserver *ApiServer,\n\tdata io.Reader,\n) ([]*Proxy, error) {\n\tinput := []struct {\n\t\tProxy\n\t\tEnabled *bool `json:\"enabled\"` // Overrides Proxy field to make field nullable\n\t}{}\n\n\terr := json.NewDecoder(data).Decode(&input)\n\tif err != nil {\n\t\treturn nil, joinError(err, ErrBadRequestBody)\n\t}\n\n\t// Check for valid input before creating any proxies\n\tt := true\n\tfor i := range input {\n\t\tif len(input[i].Name) < 1 {\n\t\t\treturn nil, joinError(fmt.Errorf(\"name at proxy %d\", i+1), ErrMissingField)\n\t\t}\n\t\tif len(input[i].Upstream) < 1 {\n\t\t\treturn nil, joinError(fmt.Errorf(\"upstream at proxy %d\", i+1), ErrMissingField)\n\t\t}\n\t\tif input[i].Enabled == nil {\n\t\t\tinput[i].Enabled = &t\n\t\t}\n\t}\n\n\tproxies := make([]*Proxy, 0, len(input))\n\n\tfor i := range input {\n\t\tproxy := NewProxy(server, input[i].Name, input[i].Listen, input[i].Upstream)\n\t\terr = collection.AddOrReplace(proxy, *input[i].Enabled)\n\t\tif err != nil {\n\t\t\treturn proxies, err\n\t\t}\n\n\t\tproxies = append(proxies, proxy)\n\t}\n\treturn proxies, err\n}\n\nfunc (collection *ProxyCollection) Proxies() map[string]*Proxy {\n\tcollection.RLock()\n\tdefer collection.RUnlock()\n\n\t// Copy the map since using the existing one isn't thread-safe\n\tproxies := make(map[string]*Proxy, len(collection.proxies))\n\tfor k, v := range collection.proxies {\n\t\tproxies[k] = v\n\t}\n\treturn proxies\n}\n\nfunc (collection *ProxyCollection) Get(name string) (*Proxy, error) {\n\tcollection.RLock()\n\tdefer collection.RUnlock()\n\n\treturn collection.getByName(name)\n}\n\nfunc (collection *ProxyCollection) Remove(name string) error {\n\tcollection.Lock()\n\tdefer collection.Unlock()\n\n\tproxy, err := collection.getByName(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproxy.Stop()\n\n\tdelete(collection.proxies, proxy.Name)\n\treturn nil\n}\n\nfunc (collection *ProxyCollection) Clear() error {\n\tcollection.Lock()\n\tdefer collection.Unlock()\n\n\tfor _, proxy := range collection.proxies {\n\t\tproxy.Stop()\n\n\t\tdelete(collection.proxies, proxy.Name)\n\t}\n\n\treturn nil\n}\n\n// getByName returns a proxy by its name. Its used from #remove and #get.\n// It assumes the lock has already been acquired.\nfunc (collection *ProxyCollection) getByName(name string) (*Proxy, error) {\n\tproxy, exists := collection.proxies[name]\n\tif !exists {\n\t\treturn nil, ErrProxyNotFound\n\t}\n\treturn proxy, nil\n}\n"
        },
        {
          "name": "proxy_collection_test.go",
          "type": "blob",
          "size": 2.8583984375,
          "content": "package toxiproxy_test\n\nimport (\n\t\"bytes\"\n\t\"net\"\n\t\"testing\"\n\n\t\"github.com/Shopify/toxiproxy/v2\"\n)\n\nfunc TestAddProxyToCollection(t *testing.T) {\n\tcollection := toxiproxy.NewProxyCollection()\n\tproxy := NewTestProxy(\"test\", \"localhost:20000\")\n\n\tif _, err := collection.Get(proxy.Name); err == nil {\n\t\tt.Error(\"Expected proxies to be empty\")\n\t}\n\n\terr := collection.Add(proxy, false)\n\tif err != nil {\n\t\tt.Error(\"Expected to be able to add first proxy to collection\")\n\t}\n\n\tif _, err := collection.Get(proxy.Name); err != nil {\n\t\tt.Error(\"Expected proxy to be added to map\")\n\t}\n}\n\nfunc TestAddTwoProxiesToCollection(t *testing.T) {\n\tcollection := toxiproxy.NewProxyCollection()\n\tproxy := NewTestProxy(\"test\", \"localhost:20000\")\n\n\terr := collection.Add(proxy, false)\n\tif err != nil {\n\t\tt.Error(\"Expected to be able to add first proxy to collection\")\n\t}\n\n\terr = collection.Add(proxy, false)\n\tif err == nil {\n\t\tt.Error(\"Expected to not be able to add proxy with same name\")\n\t}\n}\n\nfunc TestListProxies(t *testing.T) {\n\tcollection := toxiproxy.NewProxyCollection()\n\tproxy := NewTestProxy(\"test\", \"localhost:20000\")\n\n\terr := collection.Add(proxy, false)\n\tif err != nil {\n\t\tt.Error(\"Expected to be able to add first proxy to collection\")\n\t}\n\n\tproxies := collection.Proxies()\n\tproxy, ok := proxies[proxy.Name]\n\tif !ok {\n\t\tt.Error(\"Expected to be able to see existing proxy\")\n\t} else if proxy.Enabled {\n\t\tt.Error(\"Expected proxy not to be running\")\n\t}\n}\n\nfunc TestAddProxyAndStart(t *testing.T) {\n\tcollection := toxiproxy.NewProxyCollection()\n\tproxy := NewTestProxy(\"test\", \"localhost:20000\")\n\n\terr := collection.Add(proxy, true)\n\tif err != nil {\n\t\tt.Error(\"Expected to be able to add proxy to collection:\", err)\n\t}\n\n\tproxies := collection.Proxies()\n\tproxy, ok := proxies[proxy.Name]\n\tif !ok {\n\t\tt.Error(\"Expected to be able to see existing proxy\")\n\t} else if !proxy.Enabled {\n\t\tt.Error(\"Expected proxy to be running\")\n\t}\n}\n\nfunc TestAddAndRemoveProxyFromCollection(t *testing.T) {\n\tWithTCPProxy(t, func(conn net.Conn, response chan []byte, proxy *toxiproxy.Proxy) {\n\t\tcollection := toxiproxy.NewProxyCollection()\n\n\t\tif _, err := collection.Get(proxy.Name); err == nil {\n\t\t\tt.Error(\"Expected proxies to be empty\")\n\t\t}\n\n\t\terr := collection.Add(proxy, false)\n\t\tif err != nil {\n\t\t\tt.Error(\"Expected to be able to add first proxy to collection\")\n\t\t}\n\n\t\tif _, err := collection.Get(proxy.Name); err != nil {\n\t\t\tt.Error(\"Expected proxy to be added to map\")\n\t\t}\n\n\t\tmsg := []byte(\"go away\")\n\n\t\t_, err = conn.Write(msg)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed writing to socket to shut down server\")\n\t\t}\n\n\t\tconn.Close()\n\n\t\tresp := <-response\n\t\tif !bytes.Equal(resp, msg) {\n\t\t\tt.Error(\"Server didn't read bytes from client\")\n\t\t}\n\n\t\terr = collection.Remove(proxy.Name)\n\t\tif err != nil {\n\t\t\tt.Error(\"Expected to remove proxy from collection\")\n\t\t}\n\n\t\tif _, err := collection.Get(proxy.Name); err == nil {\n\t\t\tt.Error(\"Expected proxies to be empty\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "proxy_test.go",
          "type": "blob",
          "size": 5.0078125,
          "content": "package toxiproxy_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"io\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/Shopify/toxiproxy/v2\"\n\t\"github.com/Shopify/toxiproxy/v2/testhelper\"\n)\n\nfunc TestProxySimpleMessage(t *testing.T) {\n\tWithTCPProxy(t, func(conn net.Conn, response chan []byte, proxy *toxiproxy.Proxy) {\n\t\tmsg := []byte(\"hello world\")\n\n\t\t_, err := conn.Write(msg)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed writing to TCP server\", err)\n\t\t}\n\n\t\terr = conn.Close()\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to close TCP connection\", err)\n\t\t}\n\n\t\tresp := <-response\n\t\tif !bytes.Equal(resp, msg) {\n\t\t\tt.Error(\"Server didn't read correct bytes from client\", resp)\n\t\t}\n\t})\n}\n\nfunc TestProxyToDownUpstream(t *testing.T) {\n\tproxy := NewTestProxy(\"test\", \"localhost:20009\")\n\tproxy.Start()\n\n\tconn := AssertProxyUp(t, proxy.Listen, true)\n\t// Check to make sure the connection is closed\n\tconn.SetReadDeadline(time.Now().Add(500 * time.Millisecond))\n\t_, err := conn.Read(make([]byte, 1))\n\tif err != io.EOF {\n\t\tt.Error(\"Proxy did not close connection when upstream down\", err)\n\t}\n\n\tproxy.Stop()\n}\n\nfunc TestProxyBigMessage(t *testing.T) {\n\tWithTCPProxy(t, func(conn net.Conn, response chan []byte, proxy *toxiproxy.Proxy) {\n\t\tbuf := make([]byte, 32*1024)\n\t\tmsg := make([]byte, len(buf)*2)\n\t\thex.Encode(msg, buf)\n\n\t\t_, err := conn.Write(msg)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed writing to TCP server\", err)\n\t\t}\n\n\t\terr = conn.Close()\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to close TCP connection\", err)\n\t\t}\n\n\t\tresp := <-response\n\t\tif !bytes.Equal(resp, msg) {\n\t\t\tt.Error(\"Server didn't read correct bytes from client\", resp)\n\t\t}\n\t})\n}\n\nfunc TestProxyTwoPartMessage(t *testing.T) {\n\tWithTCPProxy(t, func(conn net.Conn, response chan []byte, proxy *toxiproxy.Proxy) {\n\t\tmsg1 := []byte(\"hello world\")\n\t\tmsg2 := []byte(\"hello world\")\n\n\t\t_, err := conn.Write(msg1)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed writing to TCP server\", err)\n\t\t}\n\n\t\t_, err = conn.Write(msg2)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed writing to TCP server\", err)\n\t\t}\n\n\t\terr = conn.Close()\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to close TCP connection\", err)\n\t\t}\n\n\t\tmsg1 = append(msg1, msg2...)\n\n\t\tresp := <-response\n\t\tif !bytes.Equal(resp, msg1) {\n\t\t\tt.Error(\"Server didn't read correct bytes from client\", resp)\n\t\t}\n\t})\n}\n\nfunc TestClosingProxyMultipleTimes(t *testing.T) {\n\tWithTCPProxy(t, func(conn net.Conn, response chan []byte, proxy *toxiproxy.Proxy) {\n\t\tproxy.Stop()\n\t\tproxy.Stop()\n\t\tproxy.Stop()\n\t})\n}\n\nfunc TestStartTwoProxiesOnSameAddress(t *testing.T) {\n\tWithTCPProxy(t, func(conn net.Conn, response chan []byte, proxy *toxiproxy.Proxy) {\n\t\tproxy2 := NewTestProxy(\"proxy_2\", \"localhost:3306\")\n\t\tproxy2.Listen = proxy.Listen\n\t\tif err := proxy2.Start(); err == nil {\n\t\t\tt.Fatal(\"Expected an err back from start\")\n\t\t}\n\t})\n}\n\nfunc TestStopProxyBeforeStarting(t *testing.T) {\n\ttesthelper.WithTCPServer(t, func(upstream string, response chan []byte) {\n\t\tproxy := NewTestProxy(\"test\", upstream)\n\t\tAssertProxyUp(t, proxy.Listen, false)\n\n\t\tproxy.Stop()\n\t\terr := proxy.Start()\n\t\tif err != nil {\n\t\t\tt.Error(\"Proxy failed to start\", err)\n\t\t}\n\n\t\terr = proxy.Start()\n\t\tif err != toxiproxy.ErrProxyAlreadyStarted {\n\t\t\tt.Error(\"Proxy did not fail to start when already started\", err)\n\t\t}\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\n\t\tproxy.Stop()\n\t\tAssertProxyUp(t, proxy.Listen, false)\n\t})\n}\n\nfunc TestProxyUpdate(t *testing.T) {\n\ttesthelper.WithTCPServer(t, func(upstream string, response chan []byte) {\n\t\tproxy := NewTestProxy(\"test\", upstream)\n\t\terr := proxy.Start()\n\t\tif err != nil {\n\t\t\tt.Error(\"Proxy failed to start\", err)\n\t\t}\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\n\t\tbefore := proxy.Listen\n\n\t\tinput := &toxiproxy.Proxy{Listen: \"localhost:0\", Upstream: proxy.Upstream, Enabled: true}\n\t\terr = proxy.Update(input)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to update proxy\", err)\n\t\t}\n\t\tif proxy.Listen == before || proxy.Listen == input.Listen {\n\t\t\tt.Errorf(\"Proxy update didn't change listen address: %s to %s\", before, proxy.Listen)\n\t\t}\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\n\t\tinput.Listen = proxy.Listen\n\t\terr = proxy.Update(input)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to update proxy\", err)\n\t\t}\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\n\t\tinput.Enabled = false\n\t\terr = proxy.Update(input)\n\t\tif err != nil {\n\t\t\tt.Error(\"Failed to update proxy\", err)\n\t\t}\n\t\tAssertProxyUp(t, proxy.Listen, false)\n\t})\n}\n\nfunc TestRestartFailedToStartProxy(t *testing.T) {\n\ttesthelper.WithTCPServer(t, func(upstream string, response chan []byte) {\n\t\tproxy := NewTestProxy(\"test\", upstream)\n\t\tconflict := NewTestProxy(\"test2\", upstream)\n\n\t\terr := conflict.Start()\n\t\tif err != nil {\n\t\t\tt.Error(\"Proxy failed to start\", err)\n\t\t}\n\t\tAssertProxyUp(t, conflict.Listen, true)\n\n\t\tproxy.Listen = conflict.Listen\n\t\terr = proxy.Start()\n\t\tif err == nil || err == toxiproxy.ErrProxyAlreadyStarted {\n\t\t\tt.Error(\"Proxy started when it should have conflicted\")\n\t\t}\n\n\t\tconflict.Stop()\n\t\tAssertProxyUp(t, conflict.Listen, false)\n\n\t\terr = proxy.Start()\n\t\tif err != nil {\n\t\t\tt.Error(\"Proxy failed to start after conflict went away\", err)\n\t\t}\n\t\tAssertProxyUp(t, proxy.Listen, true)\n\n\t\tproxy.Stop()\n\t\tAssertProxyUp(t, proxy.Listen, false)\n\t})\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "share",
          "type": "tree",
          "content": null
        },
        {
          "name": "stream",
          "type": "tree",
          "content": null
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "testhelper",
          "type": "tree",
          "content": null
        },
        {
          "name": "toxic_collection.go",
          "type": "blob",
          "size": 6.67578125,
          "content": "package toxiproxy\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/Shopify/toxiproxy/v2/stream\"\n\t\"github.com/Shopify/toxiproxy/v2/toxics\"\n)\n\n// ToxicCollection contains a list of toxics that are chained together. Each proxy\n// has its own collection. A hidden noop toxic is always maintained at the beginning\n// of each chain so toxics have a method of pausing incoming data (by interrupting\n// the preceding toxic).\ntype ToxicCollection struct {\n\tsync.Mutex\n\n\tnoop  *toxics.ToxicWrapper\n\tproxy *Proxy\n\tchain [][]*toxics.ToxicWrapper\n\tlinks map[string]*ToxicLink\n}\n\nfunc NewToxicCollection(proxy *Proxy) *ToxicCollection {\n\tcollection := &ToxicCollection{\n\t\tnoop: &toxics.ToxicWrapper{\n\t\t\tToxic: new(toxics.NoopToxic),\n\t\t\tType:  \"noop\",\n\t\t},\n\t\tproxy: proxy,\n\t\tchain: make([][]*toxics.ToxicWrapper, stream.NumDirections),\n\t\tlinks: make(map[string]*ToxicLink),\n\t}\n\tfor dir := range collection.chain {\n\t\tcollection.chain[dir] = make([]*toxics.ToxicWrapper, 1, toxics.Count()+1)\n\t\tcollection.chain[dir][0] = collection.noop\n\t}\n\treturn collection\n}\n\nfunc (c *ToxicCollection) ResetToxics(ctx context.Context) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\t// Remove all but the first noop toxic\n\tfor dir := range c.chain {\n\t\tfor len(c.chain[dir]) > 1 {\n\t\t\tc.chainRemoveToxic(ctx, c.chain[dir][1])\n\t\t}\n\t}\n}\n\nfunc (c *ToxicCollection) GetToxic(name string) *toxics.ToxicWrapper {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\treturn c.findToxicByName(name)\n}\n\nfunc (c *ToxicCollection) GetToxicArray() []toxics.Toxic {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tresult := make([]toxics.Toxic, 0)\n\tfor dir := range c.chain {\n\t\tfor i, toxic := range c.chain[dir] {\n\t\t\tif i == 0 {\n\t\t\t\t// Skip the first noop toxic, it should not be visible\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tresult = append(result, toxic)\n\t\t}\n\t}\n\treturn result\n}\n\nfunc (c *ToxicCollection) AddToxicJson(data io.Reader) (*toxics.ToxicWrapper, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tvar buffer bytes.Buffer\n\n\t// Default to a downstream toxic with a toxicity of 1.\n\twrapper := &toxics.ToxicWrapper{\n\t\tStream:   \"downstream\",\n\t\tToxicity: 1.0,\n\t\tToxic:    new(toxics.NoopToxic),\n\t}\n\n\terr := json.NewDecoder(io.TeeReader(data, &buffer)).Decode(wrapper)\n\tif err != nil {\n\t\treturn nil, joinError(err, ErrBadRequestBody)\n\t}\n\n\twrapper.Direction, err = stream.ParseDirection(wrapper.Stream)\n\tif err != nil {\n\t\treturn nil, ErrInvalidStream\n\t}\n\n\tif wrapper.Name == \"\" {\n\t\twrapper.Name = fmt.Sprintf(\"%s_%s\", wrapper.Type, wrapper.Stream)\n\t}\n\n\tif toxics.New(wrapper) == nil {\n\t\treturn nil, ErrInvalidToxicType\n\t}\n\n\tfound := c.findToxicByName(wrapper.Name)\n\tif found != nil {\n\t\treturn nil, ErrToxicAlreadyExists\n\t}\n\n\t// Parse attributes because we now know the toxics type.\n\tattrs := &struct {\n\t\tAttributes interface{} `json:\"attributes\"`\n\t}{\n\t\twrapper.Toxic,\n\t}\n\terr = json.NewDecoder(&buffer).Decode(attrs)\n\tif err != nil {\n\t\treturn nil, joinError(err, ErrBadRequestBody)\n\t}\n\n\tc.chainAddToxic(wrapper)\n\treturn wrapper, nil\n}\n\nfunc (c *ToxicCollection) UpdateToxicJson(\n\tname string,\n\tdata io.Reader,\n) (*toxics.ToxicWrapper, error) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\ttoxic := c.findToxicByName(name)\n\tif toxic != nil {\n\t\tattrs := &struct {\n\t\t\tAttributes interface{} `json:\"attributes\"`\n\t\t\tToxicity   float32     `json:\"toxicity\"`\n\t\t}{\n\t\t\ttoxic.Toxic,\n\t\t\ttoxic.Toxicity,\n\t\t}\n\t\terr := json.NewDecoder(data).Decode(attrs)\n\t\tif err != nil {\n\t\t\treturn nil, joinError(err, ErrBadRequestBody)\n\t\t}\n\t\ttoxic.Toxicity = attrs.Toxicity\n\n\t\tc.chainUpdateToxic(toxic)\n\t\treturn toxic, nil\n\t}\n\treturn nil, ErrToxicNotFound\n}\n\nfunc (c *ToxicCollection) RemoveToxic(ctx context.Context, name string) error {\n\tlog := zerolog.Ctx(ctx).\n\t\tWith().\n\t\tStr(\"component\", \"ToxicCollection\").\n\t\tStr(\"method\", \"RemoveToxic\").\n\t\tStr(\"toxic\", name).\n\t\tStr(\"proxy\", c.proxy.Name).\n\t\tLogger()\n\tlog.Trace().Msg(\"Acquire locking...\")\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tlog.Trace().Msg(\"Getting toxic by name...\")\n\ttoxic := c.findToxicByName(name)\n\tif toxic == nil {\n\t\tlog.Trace().Msg(\"Could not find toxic by name\")\n\t\treturn ErrToxicNotFound\n\t}\n\n\tc.chainRemoveToxic(ctx, toxic)\n\tlog.Trace().Msg(\"Finished\")\n\treturn nil\n}\n\nfunc (c *ToxicCollection) StartLink(\n\tserver *ApiServer,\n\tname string,\n\tinput io.Reader,\n\toutput io.WriteCloser,\n\tdirection stream.Direction,\n) {\n\tc.Lock()\n\tdefer c.Unlock()\n\n\tvar logger zerolog.Logger\n\tif c.proxy.Logger != nil {\n\t\tlogger = *c.proxy.Logger\n\t} else {\n\t\tlogger = zerolog.Nop()\n\t}\n\n\tlink := NewToxicLink(c.proxy, c, direction, logger)\n\tlink.Start(server, name, input, output)\n\tc.links[name] = link\n}\n\nfunc (c *ToxicCollection) RemoveLink(name string) {\n\tc.Lock()\n\tdefer c.Unlock()\n\tdelete(c.links, name)\n}\n\n// All following functions assume the lock is already grabbed.\nfunc (c *ToxicCollection) findToxicByName(name string) *toxics.ToxicWrapper {\n\tfor dir := range c.chain {\n\t\t// Skip the first noop toxic, it has no name\n\t\tfor _, toxic := range c.chain[dir][1:] {\n\t\t\tif toxic.Name == name {\n\t\t\t\treturn toxic\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *ToxicCollection) chainAddToxic(toxic *toxics.ToxicWrapper) {\n\tdir := toxic.Direction\n\ttoxic.Index = len(c.chain[dir])\n\tc.chain[dir] = append(c.chain[dir], toxic)\n\n\t// Asynchronously add the toxic to each link\n\twg := sync.WaitGroup{}\n\tfor _, link := range c.links {\n\t\tif link.direction == dir {\n\t\t\twg.Add(1)\n\t\t\tgo func(link *ToxicLink, wg *sync.WaitGroup) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tlink.AddToxic(toxic)\n\t\t\t}(link, &wg)\n\t\t}\n\t}\n\twg.Wait()\n}\n\nfunc (c *ToxicCollection) chainUpdateToxic(toxic *toxics.ToxicWrapper) {\n\tc.chain[toxic.Direction][toxic.Index] = toxic\n\n\t// Asynchronously update the toxic in each link\n\tgroup := sync.WaitGroup{}\n\tfor _, link := range c.links {\n\t\tif link.direction == toxic.Direction {\n\t\t\tgroup.Add(1)\n\t\t\tgo func(link *ToxicLink) {\n\t\t\t\tdefer group.Done()\n\t\t\t\tlink.UpdateToxic(toxic)\n\t\t\t}(link)\n\t\t}\n\t}\n\tgroup.Wait()\n}\n\nfunc (c *ToxicCollection) chainRemoveToxic(ctx context.Context, toxic *toxics.ToxicWrapper) {\n\tlog := zerolog.Ctx(ctx).\n\t\tWith().\n\t\tStr(\"component\", \"ToxicCollection\").\n\t\tStr(\"method\", \"chainRemoveToxic\").\n\t\tStr(\"toxic\", toxic.Name).\n\t\tStr(\"direction\", toxic.Direction.String()).\n\t\tLogger()\n\n\tdir := toxic.Direction\n\tc.chain[dir] = append(c.chain[dir][:toxic.Index], c.chain[dir][toxic.Index+1:]...)\n\tfor i := toxic.Index; i < len(c.chain[dir]); i++ {\n\t\tc.chain[dir][i].Index = i\n\t}\n\n\t// Asynchronously remove the toxic from each link\n\twg := sync.WaitGroup{}\n\n\tevent_array := zerolog.Arr()\n\tfor _, link := range c.links {\n\t\tif link.direction == dir {\n\t\t\tevent_array = event_array.Str(fmt.Sprintf(\"Link[%p] %s\", link, link.Direction()))\n\t\t\twg.Add(1)\n\t\t\tgo func(ctx context.Context, link *ToxicLink, log zerolog.Logger) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tlink.RemoveToxic(ctx, toxic)\n\t\t\t}(ctx, link, log)\n\t\t}\n\t}\n\n\tlog.Trace().\n\t\tArray(\"links\", event_array).\n\t\tMsg(\"Waiting to update links\")\n\twg.Wait()\n\n\ttoxic.Index = -1\n}\n"
        },
        {
          "name": "toxics",
          "type": "tree",
          "content": null
        },
        {
          "name": "toxiproxy_test.go",
          "type": "blob",
          "size": 1.291015625,
          "content": "package toxiproxy_test\n\nimport (\n\t\"flag\"\n\t\"net\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/rs/zerolog\"\n\n\t\"github.com/Shopify/toxiproxy/v2\"\n\t\"github.com/Shopify/toxiproxy/v2/collectors\"\n\t\"github.com/Shopify/toxiproxy/v2/testhelper\"\n)\n\nfunc NewTestProxy(name, upstream string) *toxiproxy.Proxy {\n\tlog := zerolog.Nop()\n\tif flag.Lookup(\"test.v\").DefValue == \"true\" {\n\t\tlog = zerolog.New(os.Stdout).With().Caller().Timestamp().Logger()\n\t}\n\tsrv := toxiproxy.NewServer(\n\t\ttoxiproxy.NewMetricsContainer(prometheus.NewRegistry()),\n\t\tlog,\n\t)\n\tsrv.Metrics.ProxyMetrics = collectors.NewProxyMetricCollectors()\n\tproxy := toxiproxy.NewProxy(srv, name, \"localhost:0\", upstream)\n\n\treturn proxy\n}\n\nfunc WithTCPProxy(\n\tt *testing.T,\n\tf func(proxy net.Conn, response chan []byte, proxyServer *toxiproxy.Proxy),\n) {\n\ttesthelper.WithTCPServer(t, func(upstream string, response chan []byte) {\n\t\tproxy := NewTestProxy(\"test\", upstream)\n\t\tproxy.Start()\n\n\t\tconn := AssertProxyUp(t, proxy.Listen, true)\n\n\t\tf(conn, response, proxy)\n\n\t\tproxy.Stop()\n\t})\n}\n\nfunc AssertProxyUp(t *testing.T, addr string, up bool) net.Conn {\n\tconn, err := net.Dial(\"tcp\", addr)\n\tif err != nil && up {\n\t\tt.Error(\"Expected proxy to be up:\", err)\n\t} else if err == nil && !up {\n\t\tt.Error(\"Expected proxy to be down\")\n\t}\n\treturn conn\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.0380859375,
          "content": "package toxiproxy\n\nvar Version = \"git\"\n"
        }
      ]
    }
  ]
}