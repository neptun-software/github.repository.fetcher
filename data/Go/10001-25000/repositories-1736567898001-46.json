{
  "metadata": {
    "timestamp": 1736567898001,
    "page": 46,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "antonmedv/fx",
      "stars": 19185,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.0146484375,
          "content": "*.golden -text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.2548828125,
          "content": "FROM golang:latest as builder\n\nWORKDIR /go\n\nCOPY go.mod go.sum ./\n\nRUN go mod download\n\nCOPY . .\n\nRUN go build -o fx .\n\nFROM alpine\n\nRUN apk add --update nodejs\n\nCOPY --from=builder /go/fx /bin/fx\n\nWORKDIR /data\n\nENV COLORTERM=truecolor\n\nENTRYPOINT [\"/bin/fx\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0458984375,
          "content": "MIT License\n\nCopyright (c) 2019 Anton Medvedev\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.67578125,
          "content": "# f(x)\n\n<p align=\"center\"><a href=\"https://fx.wtf\"><img src=\".github/images/preview.gif\" width=\"500\" alt=\"fx preview\"></a></p>\n\n<p align=\"center\"><sup>Special thanks to:</sup></p>\n<a href=\"https://www.warp.dev/?utm_source=github&utm_medium=referral&utm_campaign=fx_20231001\">\n    <p align=\"center\"><img src=\".github/warp-logo@2x.png\" alt=\"Warp\"></p>\n    <p align=\"center\">Warp is a modern, Rust-based terminal with AI built in so you and your team can build great software, faster.</p>\n    <p align=\"center\"><b>Visit warp.dev to learn more.</b></p>\n</a>\n\n## Install\n\n```sh\nbrew install fx\n```\n\n## Documentation\n\nSee full documentation at [fx.wtf](https://fx.wtf).\n\n## License\n\n[MIT](LICENSE)\n"
        },
        {
          "name": "RELEASE.md",
          "type": "blob",
          "size": 0.630859375,
          "content": "# Release\n\n1. Bump version in [version.go](version.go).\n2. Bump version in [snapcraft.yaml](snap/snapcraft.yaml).\n3. Bump version in [package.json](npm/package.json).\n4. Commit changes.\n5. Publish npm package.\n6. Trigger [GitHub Actions](https://github.com/antonmedv/fx/actions) (brew, snap, docker).\n7. Create a new release on [GitHub](https://github.com/antonmedv/fx/releases/new).\n8. Run [build.mjs](scripts/build.mjs) to upload binaries to the release.\n   ```sh\n   npx zx scripts/build.mjs\n   ```\n9. Bump version in [install.sh](https://github.com/antonmedv/fx.wtf/blob/master/public/install.sh) and upload it\n   to [fx.wtf](https://fx.wtf).\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.703125,
          "content": "module github.com/antonmedv/fx\n\ngo 1.21\n\nrequire (\n\tgithub.com/antonmedv/clipboard v1.0.1\n\tgithub.com/charmbracelet/bubbles v0.18.0\n\tgithub.com/charmbracelet/bubbletea v0.25.0\n\tgithub.com/charmbracelet/lipgloss v0.10.0\n\tgithub.com/charmbracelet/x/exp/teatest v0.0.0-20231025135604-4a717d4fb812\n\tgithub.com/dop251/goja v0.0.0-20240220182346-e401ed450204\n\tgithub.com/goccy/go-yaml v1.11.3\n\tgithub.com/mattn/go-isatty v0.0.20\n\tgithub.com/mattn/go-runewidth v0.0.15\n\tgithub.com/muesli/termenv v0.15.2\n\tgithub.com/sahilm/fuzzy v0.1.1\n\tgithub.com/stretchr/testify v1.8.4\n)\n\nrequire (\n\tgithub.com/atotto/clipboard v0.1.4 // indirect\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/aymanbagabas/go-udiff v0.1.3 // indirect\n\tgithub.com/containerd/console v1.0.4 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dlclark/regexp2 v1.11.0 // indirect\n\tgithub.com/fatih/color v1.16.0 // indirect\n\tgithub.com/go-sourcemap/sourcemap v2.1.4+incompatible // indirect\n\tgithub.com/google/pprof v0.0.0-20240409012703-83162a5b38cd // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-localereader v0.0.1 // indirect\n\tgithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect\n\tgithub.com/muesli/cancelreader v0.2.2 // indirect\n\tgithub.com/muesli/reflow v0.3.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgolang.org/x/sync v0.7.0 // indirect\n\tgolang.org/x/sys v0.19.0 // indirect\n\tgolang.org/x/term v0.19.0 // indirect\n\tgolang.org/x/text v0.14.0 // indirect\n\tgolang.org/x/xerrors v0.0.0-20231012003039-104605ab7028 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 13.287109375,
          "content": "github.com/antonmedv/clipboard v1.0.1 h1:z9rRBhSKt4lDb6uNcMykUmNbspk/6v07JeiTaOfYYOY=\ngithub.com/antonmedv/clipboard v1.0.1/go.mod h1:3jcOUCdraVHehZaOsMaJZoE92MxURt5fovC1gDAiZ2s=\ngithub.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=\ngithub.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/aymanbagabas/go-udiff v0.1.3 h1:RhVuqTFzgmpfIkaxzHupCiY3szWWYQym60+D32PeGD8=\ngithub.com/aymanbagabas/go-udiff v0.1.3/go.mod h1:RE4Ex0qsGkTAJoQdQQCA0uG+nAzJO/pI/QwceO5fgrA=\ngithub.com/charmbracelet/bubbles v0.18.0 h1:PYv1A036luoBGroX6VWjQIE9Syf2Wby2oOl/39KLfy0=\ngithub.com/charmbracelet/bubbles v0.18.0/go.mod h1:08qhZhtIwzgrtBjAcJnij1t1H0ZRjwHyGsy6AL11PSw=\ngithub.com/charmbracelet/bubbletea v0.25.0 h1:bAfwk7jRz7FKFl9RzlIULPkStffg5k6pNt5dywy4TcM=\ngithub.com/charmbracelet/bubbletea v0.25.0/go.mod h1:EN3QDR1T5ZdWmdfDzYcqOCAps45+QIJbLOBxmVNWNNg=\ngithub.com/charmbracelet/lipgloss v0.10.0 h1:KWeXFSexGcfahHX+54URiZGkBFazf70JNMtwg/AFW3s=\ngithub.com/charmbracelet/lipgloss v0.10.0/go.mod h1:Wig9DSfvANsxqkRsqj6x87irdy123SR4dOXlKa91ciE=\ngithub.com/charmbracelet/x/exp/teatest v0.0.0-20231025135604-4a717d4fb812 h1:W/hU7Z+y+QsZo2qg0hwjv56qSMP12Z72DJR8k+ULbA4=\ngithub.com/charmbracelet/x/exp/teatest v0.0.0-20231025135604-4a717d4fb812/go.mod h1:TckAxPtan3aJ5wbTgBkySpc50SZhXJRZ8PtYICnZJEw=\ngithub.com/chzyer/logex v1.2.0/go.mod h1:9+9sk7u7pGNWYMkh0hdiL++6OeibzJccyQU4p4MedaY=\ngithub.com/chzyer/readline v1.5.0/go.mod h1:x22KAscuvRqlLoK9CsoYsmxoXZMMFVyOl86cAH8qUic=\ngithub.com/chzyer/test v0.0.0-20210722231415-061457976a23/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/containerd/console v1.0.4 h1:F2g4+oChYvBTsASRTz8NP6iIAi97J3TtSAsLbIFn4ro=\ngithub.com/containerd/console v1.0.4/go.mod h1:YynlIjWYF8myEu6sdkwKIvGQq+cOckRm6So2avqoYAk=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dlclark/regexp2 v1.4.1-0.20201116162257-a2a8dda75c91/go.mod h1:2pZnwuY/m+8K6iRw6wQdMtk+rH5tNGR1i55kozfMjCc=\ngithub.com/dlclark/regexp2 v1.7.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/dlclark/regexp2 v1.11.0 h1:G/nrcoOa7ZXlpoa/91N3X7mM3r8eIlMBBJZvsz/mxKI=\ngithub.com/dlclark/regexp2 v1.11.0/go.mod h1:DHkYz0B9wPfa6wondMfaivmHpzrQ3v9q8cnmRbL6yW8=\ngithub.com/dop251/goja v0.0.0-20211022113120-dc8c55024d06/go.mod h1:R9ET47fwRVRPZnOGvHxxhuZcbrMCuiqOz3Rlrh4KSnk=\ngithub.com/dop251/goja v0.0.0-20240220182346-e401ed450204 h1:O7I1iuzEA7SG+dK8ocOBSlYAA9jBUmCYl/Qa7ey7JAM=\ngithub.com/dop251/goja v0.0.0-20240220182346-e401ed450204/go.mod h1:QMWlm50DNe14hD7t24KEqZuUdC9sOTy8W6XbCU1mlw4=\ngithub.com/dop251/goja_nodejs v0.0.0-20210225215109-d91c329300e7/go.mod h1:hn7BA7c8pLvoGndExHudxTDKZ84Pyvv+90pbBjbTz0Y=\ngithub.com/dop251/goja_nodejs v0.0.0-20211022123610-8dd9abb0616d/go.mod h1:DngW8aVqWbuLRMHItjPUyqdj+HWPvnQe8V8y1nDpIbM=\ngithub.com/fatih/color v1.16.0 h1:zmkK9Ngbjj+K0yRhTVONQh1p/HknKYSlNT+vZCzyokM=\ngithub.com/fatih/color v1.16.0/go.mod h1:fL2Sau1YI5c0pdGEVCbKQbLXB6edEj1ZgiY4NijnWvE=\ngithub.com/go-playground/locales v0.13.0 h1:HyWk6mgj5qFqCT5fjGBuRArbVDfE4hi8+e8ceBS/t7Q=\ngithub.com/go-playground/locales v0.13.0/go.mod h1:taPMhCMXrRLJO55olJkUXHZBHCxTMfnGwq/HNwmWNS8=\ngithub.com/go-playground/universal-translator v0.17.0 h1:icxd5fm+REJzpZx7ZfpaD876Lmtgy7VtROAbHHXk8no=\ngithub.com/go-playground/universal-translator v0.17.0/go.mod h1:UkSxE5sNxxRwHyU+Scu5vgOQjsIJAF8j9muTVoKLVtA=\ngithub.com/go-playground/validator/v10 v10.4.1 h1:pH2c5ADXtd66mxoE0Zm9SUhxE20r7aM3F26W0hOn+GE=\ngithub.com/go-playground/validator/v10 v10.4.1/go.mod h1:nlOn6nFhuKACm19sB/8EGNn9GlaMV7XkbRSipzJ0Ii4=\ngithub.com/go-sourcemap/sourcemap v2.1.3+incompatible/go.mod h1:F8jJfvm2KbVjc5NqelyYJmf/v5J0dwNLS2mL4sNA1Jg=\ngithub.com/go-sourcemap/sourcemap v2.1.4+incompatible h1:a+iTbH5auLKxaNwQFg0B+TCYl6lbukKPc7b5x0n1s6Q=\ngithub.com/go-sourcemap/sourcemap v2.1.4+incompatible/go.mod h1:F8jJfvm2KbVjc5NqelyYJmf/v5J0dwNLS2mL4sNA1Jg=\ngithub.com/goccy/go-yaml v1.11.3 h1:B3W9IdWbvrUu2OYQGwvU1nZtvMQJPBKgBUuweJjLj6I=\ngithub.com/goccy/go-yaml v1.11.3/go.mod h1:wKnAMd44+9JAAnGQpWVEgBzGt3YuTaQ4uXoHvE4m7WU=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/pprof v0.0.0-20230207041349-798e818bf904/go.mod h1:uglQLonpP8qtYCYyzA+8c/9qtqgA3qsXGYqCPKARAFg=\ngithub.com/google/pprof v0.0.0-20240409012703-83162a5b38cd h1:gbpYu9NMq8jhDVbvlGkMFWCjLFlqqEZjEmObmhUy6Vo=\ngithub.com/google/pprof v0.0.0-20240409012703-83162a5b38cd/go.mod h1:kf6iHlnVGwgKolg33glAes7Yg/8iWP8ukqeldJSO7jw=\ngithub.com/ianlancetaylor/demangle v0.0.0-20220319035150-800ac71e25c2/go.mod h1:aYm2/VgdVmcIU8iMfdMvDMsRAQjcfZSKFby6HOFvi/w=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.3.0 h1:WgNl7dwNpEZ6jJ9k1snq4pZsg7DOEN8hP9Xw0Tsjwk0=\ngithub.com/kr/pretty v0.3.0/go.mod h1:640gp4NfQd8pI5XOwp5fnNeVWj67G7CFk/SaSQn7NBk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/kylelemons/godebug v1.1.0 h1:RPNrshWIDI6G2gRW9EHilWtl7Z6Sb1BR0xunSBf0SNc=\ngithub.com/kylelemons/godebug v1.1.0/go.mod h1:9/0rRGxNHcop5bhtWyNeEfOS8JIWk580+fNqagV/RAw=\ngithub.com/leodido/go-urn v1.2.0 h1:hpXL4XnriNwQ/ABnpepYM/1vCLWNDfUNts8dX3xTG6Y=\ngithub.com/leodido/go-urn v1.2.0/go.mod h1:+8+nEpDfqqsY+g338gtMEUOtuK+4dEMhiQEgxpxOKII=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=\ngithub.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=\ngithub.com/mattn/go-runewidth v0.0.12/go.mod h1:RAqKPSqVFrSLVXbA8x7dzmKdmGzieGRCM46jaSJTDAk=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=\ngithub.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=\ngithub.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=\ngithub.com/muesli/reflow v0.3.0 h1:IFsN6K9NfGtjeggFP+68I4chLZV2yIKsXJFNZ+eWh6s=\ngithub.com/muesli/reflow v0.3.0/go.mod h1:pbwTDkVPibjO2kyvBQRBxTWEEGDGq0FlB1BIKtnHY/8=\ngithub.com/muesli/termenv v0.15.2 h1:GohcuySI0QmI3wN8Ok9PtKGkgkFIk7y6Vpb5PvrY+Wo=\ngithub.com/muesli/termenv v0.15.2/go.mod h1:Epx+iuz8sNs7mNKhxzH4fWXGNpZwUaJKRS1noLXviQ8=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.1.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/rogpeppe/go-internal v1.6.1 h1:/FiVV8dS/e+YqF2JvO3yXRFbBLTIuSDkuC7aBOAvL+k=\ngithub.com/rogpeppe/go-internal v1.6.1/go.mod h1:xXDCJY+GAPziupqXw64V24skbSoqbTEfhy4qGm1nDQc=\ngithub.com/sahilm/fuzzy v0.1.1 h1:ceu5RHF8DGgoi+/dR5PsECjCDH1BE3Fnmpo7aVXOdRA=\ngithub.com/sahilm/fuzzy v0.1.1/go.mod h1:VFvziUEIMCrT6A6tw2RFIXPXXmzXbOsSHF0DOI8ZK9Y=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.7.0 h1:AvwMYaRytfdeVt3u6mLaxYtErKYjxA2OXjJ1HHq6t3A=\ngolang.org/x/crypto v0.7.0/go.mod h1:pYwdfH91IfpZVANVyUOhSIPZaFoJGxTFbZhFTx+dXZU=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220310020820-b874c991c1a5/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.19.0 h1:q5f1RH2jigJ1MoAWp2KTp3gm5zAGFUTarQZ5U386+4o=\ngolang.org/x/sys v0.19.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.19.0 h1:+ThwsDv+tYfnJFhF4L8jITxu1tdTWRTZpdsWgEgjL6Q=\ngolang.org/x/term v0.19.0/go.mod h1:2CuTdWZ7KHSQwUzKva0cbMg6q2DMI3Mmxp+gKJbskEk=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=\ngolang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20231012003039-104605ab7028 h1:+cNy6SZtPcJQH3LJVLOSmiC7MMxXNOb3PU/VUEz+EhU=\ngolang.org/x/xerrors v0.0.0-20231012003039-104605ab7028/go.mod h1:NDW/Ps6MPRej6fsCIbMTohpP40sJ/P/vI1MoTEGwX90=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "help.go",
          "type": "blob",
          "size": 1.9306640625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\nfunc usage(keyMap KeyMap) string {\n\ttitle := lipgloss.NewStyle().Bold(true)\n\tpad := lipgloss.NewStyle().PaddingLeft(4)\n\treturn fmt.Sprintf(`\n  %v\n    Terminal JSON viewer\n\n  %v\n    fx data.json\n    fx data.json .field\n    curl ... | fx\n\n  %v\n    -h, --help            print help\n    -v, --version         print version\n    --themes              print themes\n    --comp <shell>        print completion script\n    -r, --raw             treat input as a raw string\n    -s, --slurp           read all inputs into an array\n    --yaml                parse input as YAML\n\n  %v\n%v\n\n  %v\n    [https://fx.wtf]\n`,\n\t\ttitle.Render(\"fx \"+version),\n\t\ttitle.Render(\"Usage\"),\n\t\ttitle.Render(\"Flags\"),\n\t\ttitle.Render(\"Key Bindings\"),\n\t\tstrings.Join(keyMapInfo(keyMap, pad), \"\\n\"),\n\t\ttitle.Render(\"More info\"),\n\t)\n}\n\nfunc help(keyMap KeyMap) string {\n\ttitle := lipgloss.NewStyle().Bold(true)\n\tpad := lipgloss.NewStyle().PaddingLeft(4)\n\treturn fmt.Sprintf(`\n  %v\n%v\n`,\n\t\ttitle.Render(\"Key Bindings\"),\n\t\tstrings.Join(keyMapInfo(keyMap, pad), \"\\n\"),\n\t)\n}\n\nfunc keyMapInfo(keyMap KeyMap, style lipgloss.Style) []string {\n\tv := reflect.ValueOf(keyMap)\n\tfields := reflect.VisibleFields(v.Type())\n\n\tkeys := make([]string, 0)\n\tfor i := range fields {\n\t\tk := v.Field(i).Interface().(key.Binding)\n\t\tstr := k.Help().Key\n\t\tif len(str) == 0 {\n\t\t\tif len(k.Keys()) > 5 {\n\t\t\t\tstr = fmt.Sprintf(\"%v-%v\", k.Keys()[0], k.Keys()[len(k.Keys())-1])\n\t\t\t} else {\n\t\t\t\tstr = strings.Join(k.Keys(), \", \")\n\t\t\t}\n\t\t}\n\t\tkeys = append(keys, fmt.Sprintf(\"%v    \", str))\n\t}\n\n\tdesc := make([]string, 0)\n\tfor i := range fields {\n\t\tk := v.Field(i).Interface().(key.Binding)\n\t\tdesc = append(desc, fmt.Sprintf(\"%v\", k.Help().Desc))\n\t}\n\n\tcontent := lipgloss.JoinHorizontal(\n\t\tlipgloss.Top,\n\t\tstrings.Join(keys, \"\\n\"),\n\t\tstrings.Join(desc, \"\\n\"),\n\t)\n\n\treturn strings.Split(style.Render(content), \"\\n\")\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "keymap.go",
          "type": "blob",
          "size": 3.9580078125,
          "content": "package main\n\nimport \"github.com/charmbracelet/bubbles/key\"\n\ntype KeyMap struct {\n\tQuit                key.Binding\n\tPageDown            key.Binding\n\tPageUp              key.Binding\n\tHalfPageUp          key.Binding\n\tHalfPageDown        key.Binding\n\tGotoTop             key.Binding\n\tGotoBottom          key.Binding\n\tDown                key.Binding\n\tUp                  key.Binding\n\tHelp                key.Binding\n\tExpand              key.Binding\n\tCollapse            key.Binding\n\tExpandRecursively   key.Binding\n\tCollapseRecursively key.Binding\n\tExpandAll           key.Binding\n\tCollapseAll         key.Binding\n\tCollapseLevel       key.Binding\n\tNextSibling         key.Binding\n\tPrevSibling         key.Binding\n\tToggleWrap          key.Binding\n\tYank                key.Binding\n\tSearch              key.Binding\n\tSearchNext          key.Binding\n\tSearchPrev          key.Binding\n\tPreview             key.Binding\n\tPrint               key.Binding\n\tDig                 key.Binding\n}\n\nvar keyMap KeyMap\n\nfunc init() {\n\tkeyMap = KeyMap{\n\t\tQuit: key.NewBinding(\n\t\t\tkey.WithKeys(\"q\", \"ctrl+c\", \"esc\"),\n\t\t\tkey.WithHelp(\"\", \"exit program\"),\n\t\t),\n\t\tPageDown: key.NewBinding(\n\t\t\tkey.WithKeys(\"pgdown\", \" \", \"f\"),\n\t\t\tkey.WithHelp(\"pgdown, space, f\", \"page down\"),\n\t\t),\n\t\tPageUp: key.NewBinding(\n\t\t\tkey.WithKeys(\"pgup\", \"b\"),\n\t\t\tkey.WithHelp(\"pgup, b\", \"page up\"),\n\t\t),\n\t\tHalfPageUp: key.NewBinding(\n\t\t\tkey.WithKeys(\"u\", \"ctrl+u\"),\n\t\t\tkey.WithHelp(\"\", \"half page up\"),\n\t\t),\n\t\tHalfPageDown: key.NewBinding(\n\t\t\tkey.WithKeys(\"d\", \"ctrl+d\"),\n\t\t\tkey.WithHelp(\"\", \"half page down\"),\n\t\t),\n\t\tGotoTop: key.NewBinding(\n\t\t\tkey.WithKeys(\"g\", \"home\"),\n\t\t\tkey.WithHelp(\"\", \"goto top\"),\n\t\t),\n\t\tGotoBottom: key.NewBinding(\n\t\t\tkey.WithKeys(\"G\", \"end\"),\n\t\t\tkey.WithHelp(\"\", \"goto bottom\"),\n\t\t),\n\t\tDown: key.NewBinding(\n\t\t\tkey.WithKeys(\"down\", \"j\"),\n\t\t\tkey.WithHelp(\"\", \"down\"),\n\t\t),\n\t\tUp: key.NewBinding(\n\t\t\tkey.WithKeys(\"up\", \"k\"),\n\t\t\tkey.WithHelp(\"\", \"up\"),\n\t\t),\n\t\tHelp: key.NewBinding(\n\t\t\tkey.WithKeys(\"?\"),\n\t\t\tkey.WithHelp(\"\", \"show help\"),\n\t\t),\n\t\tExpand: key.NewBinding(\n\t\t\tkey.WithKeys(\"right\", \"l\", \"enter\"),\n\t\t\tkey.WithHelp(\"\", \"expand\"),\n\t\t),\n\t\tCollapse: key.NewBinding(\n\t\t\tkey.WithKeys(\"left\", \"h\", \"backspace\"),\n\t\t\tkey.WithHelp(\"\", \"collapse\"),\n\t\t),\n\t\tExpandRecursively: key.NewBinding(\n\t\t\tkey.WithKeys(\"L\", \"shift+right\"),\n\t\t\tkey.WithHelp(\"\", \"expand recursively\"),\n\t\t),\n\t\tCollapseRecursively: key.NewBinding(\n\t\t\tkey.WithKeys(\"H\", \"shift+left\"),\n\t\t\tkey.WithHelp(\"\", \"collapse recursively\"),\n\t\t),\n\t\tExpandAll: key.NewBinding(\n\t\t\tkey.WithKeys(\"e\"),\n\t\t\tkey.WithHelp(\"\", \"expand all\"),\n\t\t),\n\t\tCollapseAll: key.NewBinding(\n\t\t\tkey.WithKeys(\"E\"),\n\t\t\tkey.WithHelp(\"\", \"collapse all\"),\n\t\t),\n\t\tCollapseLevel: key.NewBinding(\n\t\t\tkey.WithKeys(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"),\n\t\t\tkey.WithHelp(\"\", \"collapse to nth level\"),\n\t\t),\n\t\tNextSibling: key.NewBinding(\n\t\t\tkey.WithKeys(\"J\", \"shift+down\"),\n\t\t\tkey.WithHelp(\"\", \"next sibling\"),\n\t\t),\n\t\tPrevSibling: key.NewBinding(\n\t\t\tkey.WithKeys(\"K\", \"shift+up\"),\n\t\t\tkey.WithHelp(\"\", \"previous sibling\"),\n\t\t),\n\t\tToggleWrap: key.NewBinding(\n\t\t\tkey.WithKeys(\"z\"),\n\t\t\tkey.WithHelp(\"\", \"toggle strings wrap\"),\n\t\t),\n\t\tYank: key.NewBinding(\n\t\t\tkey.WithKeys(\"y\"),\n\t\t\tkey.WithHelp(\"\", \"yank/copy\"),\n\t\t),\n\t\tSearch: key.NewBinding(\n\t\t\tkey.WithKeys(\"/\"),\n\t\t\tkey.WithHelp(\"\", \"search regexp\"),\n\t\t),\n\t\tSearchNext: key.NewBinding(\n\t\t\tkey.WithKeys(\"n\"),\n\t\t\tkey.WithHelp(\"\", \"next search result\"),\n\t\t),\n\t\tSearchPrev: key.NewBinding(\n\t\t\tkey.WithKeys(\"N\"),\n\t\t\tkey.WithHelp(\"\", \"prev search result\"),\n\t\t),\n\t\tPreview: key.NewBinding(\n\t\t\tkey.WithKeys(\"p\"),\n\t\t\tkey.WithHelp(\"\", \"preview\"),\n\t\t),\n\t\tPrint: key.NewBinding(\n\t\t\tkey.WithKeys(\"P\"),\n\t\t\tkey.WithHelp(\"\", \"print\"),\n\t\t),\n\t\tDig: key.NewBinding(\n\t\t\tkey.WithKeys(\".\"),\n\t\t\tkey.WithHelp(\"\", \"dig\"),\n\t\t),\n\t}\n}\n\nvar (\n\tyankValueY = key.NewBinding(key.WithKeys(\"y\"))\n\tyankValueV = key.NewBinding(key.WithKeys(\"v\"))\n\tyankKey    = key.NewBinding(key.WithKeys(\"k\"))\n\tyankPath   = key.NewBinding(key.WithKeys(\"p\"))\n\tarrowUp    = key.NewBinding(key.WithKeys(\"up\"))\n\tarrowDown  = key.NewBinding(key.WithKeys(\"down\"))\n)\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 24.1298828125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"math\"\n\t\"os\"\n\t\"path\"\n\t\"regexp\"\n\t\"runtime/pprof\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/antonmedv/clipboard\"\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/textinput\"\n\t\"github.com/charmbracelet/bubbles/viewport\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/goccy/go-yaml\"\n\t\"github.com/mattn/go-isatty\"\n\t\"github.com/sahilm/fuzzy\"\n\n\t\"github.com/antonmedv/fx/internal/complete\"\n\t. \"github.com/antonmedv/fx/internal/jsonx\"\n\t\"github.com/antonmedv/fx/internal/theme\"\n\tjsonpath \"github.com/antonmedv/fx/path\"\n)\n\nvar (\n\tflagYaml bool\n\tflagComp bool\n)\n\nfunc main() {\n\tif _, ok := os.LookupEnv(\"FX_PPROF\"); ok {\n\t\tf, err := os.Create(\"cpu.prof\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\terr = pprof.StartCPUProfile(f)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer f.Close()\n\t\tdefer pprof.StopCPUProfile()\n\t\tmemProf, err := os.Create(\"mem.prof\")\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tdefer memProf.Close()\n\t\tdefer pprof.WriteHeapProfile(memProf)\n\t}\n\n\tif complete.Complete() {\n\t\tos.Exit(0)\n\t\treturn\n\t}\n\n\tvar args []string\n\tfor _, arg := range os.Args[1:] {\n\t\tif strings.HasPrefix(arg, \"--comp\") {\n\t\t\tflagComp = true\n\t\t\tcontinue\n\t\t}\n\t\tswitch arg {\n\t\tcase \"-h\", \"--help\":\n\t\t\tfmt.Println(usage(keyMap))\n\t\t\treturn\n\t\tcase \"-v\", \"-V\", \"--version\":\n\t\t\tfmt.Println(version)\n\t\t\treturn\n\t\tcase \"--themes\":\n\t\t\ttheme.ThemeTester()\n\t\t\treturn\n\t\tcase \"--export-themes\":\n\t\t\ttheme.ExportThemes()\n\t\t\treturn\n\t\tdefault:\n\t\t\targs = append(args, arg)\n\t\t}\n\t}\n\n\tif flagComp {\n\t\tshell := flag.String(\"comp\", \"\", \"\")\n\t\tflag.Parse()\n\t\tswitch *shell {\n\t\tcase \"bash\":\n\t\t\tfmt.Print(complete.Bash())\n\t\tcase \"zsh\":\n\t\t\tfmt.Print(complete.Zsh())\n\t\tcase \"fish\":\n\t\t\tfmt.Print(complete.Fish())\n\t\tdefault:\n\t\t\tfmt.Println(\"unknown shell type\")\n\t\t}\n\t\treturn\n\t}\n\n\tfd := os.Stdin.Fd()\n\tstdinIsTty := isatty.IsTerminal(fd) || isatty.IsCygwinTerminal(fd)\n\tvar fileName string\n\tvar src io.Reader\n\n\tif stdinIsTty && len(args) == 0 {\n\t\tfmt.Println(usage(keyMap))\n\t\treturn\n\t} else if stdinIsTty && len(args) == 1 {\n\t\tfilePath := args[0]\n\t\tf, err := os.Open(filePath)\n\t\tif err != nil {\n\t\t\tvar pathError *fs.PathError\n\t\t\tif errors.As(err, &pathError) {\n\t\t\t\tfmt.Println(err)\n\t\t\t\tos.Exit(1)\n\t\t\t} else {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t}\n\t\tfileName = path.Base(filePath)\n\t\tsrc = f\n\t\thasYamlExt, _ := regexp.MatchString(`(?i)\\.ya?ml$`, fileName)\n\t\tif !flagYaml && hasYamlExt {\n\t\t\tflagYaml = true\n\t\t}\n\t} else if !stdinIsTty && len(args) == 0 {\n\t\tsrc = os.Stdin\n\t} else {\n\t\treduce(os.Args[1:])\n\t\treturn\n\t}\n\n\tdata, err := io.ReadAll(src)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif flagYaml {\n\t\tdata, err = yaml.YAMLToJSON(data)\n\t\tif err != nil {\n\t\t\tfmt.Print(err.Error())\n\t\t\tos.Exit(1)\n\t\t\treturn\n\t\t}\n\t}\n\n\thead, err := Parse(data)\n\tif err != nil {\n\t\tfmt.Print(err.Error())\n\t\tos.Exit(1)\n\t\treturn\n\t}\n\n\tdigInput := textinput.New()\n\tdigInput.Prompt = \"\"\n\tdigInput.TextStyle = lipgloss.NewStyle().\n\t\tBackground(lipgloss.Color(\"7\")).\n\t\tForeground(lipgloss.Color(\"0\"))\n\tdigInput.Cursor.Style = lipgloss.NewStyle().\n\t\tBackground(lipgloss.Color(\"15\")).\n\t\tForeground(lipgloss.Color(\"0\"))\n\n\tsearchInput := textinput.New()\n\tsearchInput.Prompt = \"/\"\n\n\tm := &model{\n\t\thead:        head,\n\t\ttop:         head,\n\t\tshowCursor:  true,\n\t\twrap:        true,\n\t\tfileName:    fileName,\n\t\tdigInput:    digInput,\n\t\tsearchInput: searchInput,\n\t\tsearch:      newSearch(),\n\t}\n\n\tlipgloss.SetColorProfile(theme.TermOutput.ColorProfile())\n\n\twithMouse := tea.WithMouseCellMotion()\n\tif _, ok := os.LookupEnv(\"FX_NO_MOUSE\"); ok {\n\t\twithMouse = tea.WithAltScreen()\n\t}\n\n\tp := tea.NewProgram(m,\n\t\ttea.WithAltScreen(),\n\t\twithMouse,\n\t\ttea.WithOutput(os.Stderr),\n\t)\n\t_, err = p.Run()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif m.printOnExit {\n\t\tfmt.Println(m.cursorValue())\n\t}\n}\n\ntype model struct {\n\ttermWidth, termHeight int\n\thead, top             *Node\n\tcursor                int // cursor position [0, termHeight)\n\tshowCursor            bool\n\twrap                  bool\n\tmargin                int\n\tfileName              string\n\tdigInput              textinput.Model\n\tsearchInput           textinput.Model\n\tsearch                *search\n\tyank                  bool\n\tshowHelp              bool\n\thelp                  viewport.Model\n\tshowPreview           bool\n\tpreview               viewport.Model\n\tprintOnExit           bool\n}\n\nfunc (m *model) Init() tea.Cmd {\n\treturn nil\n}\n\nfunc (m *model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tif msg, ok := msg.(tea.WindowSizeMsg); ok {\n\t\tm.termWidth = msg.Width\n\t\tm.termHeight = msg.Height\n\t\tm.help.Width = m.termWidth\n\t\tm.help.Height = m.termHeight - 1\n\t\tm.preview.Width = m.termWidth\n\t\tm.preview.Height = m.termHeight - 1\n\t\tWrapAll(m.top, m.termWidth)\n\t\tm.redoSearch()\n\t}\n\n\tif m.showHelp {\n\t\treturn m.handleHelpKey(msg)\n\t}\n\n\tif m.showPreview {\n\t\treturn m.handlePreviewKey(msg)\n\t}\n\n\tswitch msg := msg.(type) {\n\tcase tea.MouseMsg:\n\t\tswitch msg.Type {\n\t\tcase tea.MouseWheelUp:\n\t\t\tm.up()\n\n\t\tcase tea.MouseWheelDown:\n\t\t\tm.down()\n\n\t\tcase tea.MouseLeft:\n\t\t\tm.digInput.Blur()\n\t\t\tm.showCursor = true\n\t\t\tif msg.Y < m.viewHeight() {\n\t\t\t\tif m.cursor == msg.Y {\n\t\t\t\t\tto := m.cursorPointsTo()\n\t\t\t\t\tif to != nil {\n\t\t\t\t\t\tif to.IsCollapsed() {\n\t\t\t\t\t\t\tto.Expand()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tto.Collapse()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tto := m.at(msg.Y)\n\t\t\t\t\tif to != nil {\n\t\t\t\t\t\tm.cursor = msg.Y\n\t\t\t\t\t\tif to.IsCollapsed() {\n\t\t\t\t\t\t\tto.Expand()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tcase tea.KeyMsg:\n\t\tif m.digInput.Focused() {\n\t\t\treturn m.handleDigKey(msg)\n\t\t}\n\t\tif m.searchInput.Focused() {\n\t\t\treturn m.handleSearchKey(msg)\n\t\t}\n\t\tif m.yank {\n\t\t\treturn m.handleYankKey(msg)\n\t\t}\n\t\treturn m.handleKey(msg)\n\t}\n\treturn m, nil\n}\n\nfunc (m *model) handleDigKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {\n\tvar cmd tea.Cmd\n\tswitch {\n\tcase key.Matches(msg, arrowUp):\n\t\tm.up()\n\t\tm.digInput.SetValue(m.cursorPath())\n\t\tm.digInput.CursorEnd()\n\n\tcase key.Matches(msg, arrowDown):\n\t\tm.down()\n\t\tm.digInput.SetValue(m.cursorPath())\n\t\tm.digInput.CursorEnd()\n\n\tcase msg.Type == tea.KeyEscape:\n\t\tm.digInput.Blur()\n\n\tcase msg.Type == tea.KeyTab:\n\t\tm.digInput.SetValue(m.cursorPath())\n\t\tm.digInput.CursorEnd()\n\n\tcase msg.Type == tea.KeyEnter:\n\t\tm.digInput.Blur()\n\t\tdigPath, ok := jsonpath.Split(m.digInput.Value())\n\t\tif ok {\n\t\t\tn := m.selectByPath(digPath)\n\t\t\tif n != nil {\n\t\t\t\tm.selectNode(n)\n\t\t\t}\n\t\t}\n\n\tcase key.Matches(msg, key.NewBinding(key.WithKeys(\"ctrl+w\"))):\n\t\tdigPath, ok := jsonpath.Split(m.digInput.Value())\n\t\tif ok {\n\t\t\tif len(digPath) > 0 {\n\t\t\t\tdigPath = digPath[:len(digPath)-1]\n\t\t\t}\n\t\t\tn := m.selectByPath(digPath)\n\t\t\tif n != nil {\n\t\t\t\tm.selectNode(n)\n\t\t\t\tm.digInput.SetValue(m.cursorPath())\n\t\t\t\tm.digInput.CursorEnd()\n\t\t\t}\n\t\t}\n\n\tcase key.Matches(msg, textinput.DefaultKeyMap.WordBackward):\n\t\tvalue := m.digInput.Value()\n\t\tpth, ok := jsonpath.Split(value[0:m.digInput.Position()])\n\t\tif ok {\n\t\t\tif len(pth) > 0 {\n\t\t\t\tpth = pth[:len(pth)-1]\n\t\t\t\tm.digInput.SetCursor(len(jsonpath.Join(pth)))\n\t\t\t} else {\n\t\t\t\tm.digInput.CursorStart()\n\t\t\t}\n\t\t}\n\n\tcase key.Matches(msg, textinput.DefaultKeyMap.WordForward):\n\t\tvalue := m.digInput.Value()\n\t\tfullPath, ok1 := jsonpath.Split(value)\n\t\tpth, ok2 := jsonpath.Split(value[0:m.digInput.Position()])\n\t\tif ok1 && ok2 {\n\t\t\tif len(pth) < len(fullPath) {\n\t\t\t\tpth = append(pth, fullPath[len(pth)])\n\t\t\t\tm.digInput.SetCursor(len(jsonpath.Join(pth)))\n\t\t\t} else {\n\t\t\t\tm.digInput.CursorEnd()\n\t\t\t}\n\t\t}\n\n\tdefault:\n\t\tif key.Matches(msg, key.NewBinding(key.WithKeys(\".\"))) {\n\t\t\tif m.digInput.Position() == len(m.digInput.Value()) {\n\t\t\t\tm.digInput.SetValue(m.cursorPath())\n\t\t\t\tm.digInput.CursorEnd()\n\t\t\t}\n\t\t}\n\n\t\tm.digInput, cmd = m.digInput.Update(msg)\n\t\tn := m.dig(m.digInput.Value())\n\t\tif n != nil {\n\t\t\tm.selectNode(n)\n\t\t}\n\t}\n\treturn m, cmd\n}\n\nfunc (m *model) handleHelpKey(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmd tea.Cmd\n\tif msg, ok := msg.(tea.KeyMsg); ok {\n\t\tswitch {\n\t\tcase key.Matches(msg, keyMap.Quit), key.Matches(msg, keyMap.Help):\n\t\t\tm.showHelp = false\n\t\t}\n\t}\n\tm.help, cmd = m.help.Update(msg)\n\treturn m, cmd\n}\n\nfunc (m *model) handlePreviewKey(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmd tea.Cmd\n\tif msg, ok := msg.(tea.KeyMsg); ok {\n\t\tswitch {\n\t\tcase key.Matches(msg, keyMap.Quit),\n\t\t\tkey.Matches(msg, keyMap.Preview):\n\t\t\tm.showPreview = false\n\n\t\tcase key.Matches(msg, keyMap.Print):\n\t\t\treturn m, m.print()\n\t\t}\n\t}\n\tm.preview, cmd = m.preview.Update(msg)\n\treturn m, cmd\n}\n\nfunc (m *model) handleSearchKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {\n\tvar cmd tea.Cmd\n\tswitch {\n\tcase msg.Type == tea.KeyEscape:\n\t\tm.searchInput.Blur()\n\t\tm.searchInput.SetValue(\"\")\n\t\tm.doSearch(\"\")\n\t\tm.showCursor = true\n\n\tcase msg.Type == tea.KeyEnter:\n\t\tm.searchInput.Blur()\n\t\tm.doSearch(m.searchInput.Value())\n\n\tdefault:\n\t\tm.searchInput, cmd = m.searchInput.Update(msg)\n\t}\n\treturn m, cmd\n}\n\nfunc (m *model) handleYankKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {\n\tswitch {\n\tcase key.Matches(msg, yankPath):\n\t\t_ = clipboard.WriteAll(m.cursorPath())\n\tcase key.Matches(msg, yankKey):\n\t\t_ = clipboard.WriteAll(m.cursorKey())\n\tcase key.Matches(msg, yankValueY, yankValueV):\n\t\t_ = clipboard.WriteAll(m.cursorValue())\n\t}\n\tm.yank = false\n\treturn m, nil\n}\n\nfunc (m *model) handleKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) {\n\tswitch {\n\tcase key.Matches(msg, keyMap.Quit):\n\t\treturn m, tea.Quit\n\n\tcase key.Matches(msg, keyMap.Help):\n\t\tm.help.SetContent(help(keyMap))\n\t\tm.showHelp = true\n\n\tcase key.Matches(msg, keyMap.Up):\n\t\tm.up()\n\n\tcase key.Matches(msg, keyMap.Down):\n\t\tm.down()\n\n\tcase key.Matches(msg, keyMap.PageUp):\n\t\tm.cursor = 0\n\t\tfor i := 0; i < m.viewHeight(); i++ {\n\t\t\tm.up()\n\t\t}\n\n\tcase key.Matches(msg, keyMap.PageDown):\n\t\tm.cursor = m.viewHeight() - 1\n\t\tfor i := 0; i < m.viewHeight(); i++ {\n\t\t\tm.down()\n\t\t}\n\t\tm.scrollIntoView()\n\n\tcase key.Matches(msg, keyMap.HalfPageUp):\n\t\tm.cursor = 0\n\t\tfor i := 0; i < m.viewHeight()/2; i++ {\n\t\t\tm.up()\n\t\t}\n\n\tcase key.Matches(msg, keyMap.HalfPageDown):\n\t\tm.cursor = m.viewHeight() - 1\n\t\tfor i := 0; i < m.viewHeight()/2; i++ {\n\t\t\tm.down()\n\t\t}\n\t\tm.scrollIntoView()\n\n\tcase key.Matches(msg, keyMap.GotoTop):\n\t\tm.head = m.top\n\t\tm.cursor = 0\n\t\tm.showCursor = true\n\n\tcase key.Matches(msg, keyMap.GotoBottom):\n\t\tm.head = m.findBottom()\n\t\tm.cursor = 0\n\t\tm.showCursor = true\n\t\tm.scrollIntoView()\n\n\tcase key.Matches(msg, keyMap.NextSibling):\n\t\tpointsTo := m.cursorPointsTo()\n\t\tvar nextSibling *Node\n\t\tif pointsTo.End != nil && pointsTo.End.Next != nil {\n\t\t\tnextSibling = pointsTo.End.Next\n\t\t} else {\n\t\t\tnextSibling = pointsTo.Next\n\t\t}\n\t\tif nextSibling != nil {\n\t\t\tm.selectNode(nextSibling)\n\t\t}\n\n\tcase key.Matches(msg, keyMap.PrevSibling):\n\t\tpointsTo := m.cursorPointsTo()\n\t\tvar prevSibling *Node\n\t\tif pointsTo.Parent() != nil && pointsTo.Parent().End == pointsTo {\n\t\t\tprevSibling = pointsTo.Parent()\n\t\t} else if pointsTo.Prev != nil {\n\t\t\tprevSibling = pointsTo.Prev\n\t\t\tparent := prevSibling.Parent()\n\t\t\tif parent != nil && parent.End == prevSibling {\n\t\t\t\tprevSibling = parent\n\t\t\t}\n\t\t}\n\t\tif prevSibling != nil {\n\t\t\tm.selectNode(prevSibling)\n\t\t}\n\n\tcase key.Matches(msg, keyMap.Collapse):\n\t\tn := m.cursorPointsTo()\n\t\tif n.HasChildren() && !n.IsCollapsed() {\n\t\t\tn.Collapse()\n\t\t} else {\n\t\t\tif n.Parent() != nil {\n\t\t\t\tn = n.Parent()\n\t\t\t}\n\t\t}\n\t\tm.selectNode(n)\n\n\tcase key.Matches(msg, keyMap.Expand):\n\t\tm.cursorPointsTo().Expand()\n\t\tm.showCursor = true\n\n\tcase key.Matches(msg, keyMap.CollapseRecursively):\n\t\tn := m.cursorPointsTo()\n\t\tif n.HasChildren() {\n\t\t\tn.CollapseRecursively()\n\t\t}\n\t\tm.showCursor = true\n\n\tcase key.Matches(msg, keyMap.ExpandRecursively):\n\t\tn := m.cursorPointsTo()\n\t\tif n.HasChildren() {\n\t\t\tn.ExpandRecursively(0, math.MaxInt)\n\t\t}\n\t\tm.showCursor = true\n\n\tcase key.Matches(msg, keyMap.CollapseAll):\n\t\tn := m.top\n\t\tfor n != nil {\n\t\t\tn.CollapseRecursively()\n\t\t\tif n.End == nil {\n\t\t\t\tn = nil\n\t\t\t} else {\n\t\t\t\tn = n.End.Next\n\t\t\t}\n\t\t}\n\t\tm.cursor = 0\n\t\tm.head = m.top\n\t\tm.showCursor = true\n\n\tcase key.Matches(msg, keyMap.ExpandAll):\n\t\tat := m.cursorPointsTo()\n\t\tn := m.top\n\t\tfor n != nil {\n\t\t\tn.ExpandRecursively(0, math.MaxInt)\n\t\t\tif n.End == nil {\n\t\t\t\tn = nil\n\t\t\t} else {\n\t\t\t\tn = n.End.Next\n\t\t\t}\n\t\t}\n\t\tm.selectNode(at)\n\n\tcase key.Matches(msg, keyMap.CollapseLevel):\n\t\tat := m.cursorPointsTo()\n\t\tif at != nil && at.HasChildren() {\n\t\t\ttoLevel, _ := strconv.Atoi(msg.String())\n\t\t\tat.CollapseRecursively()\n\t\t\tat.ExpandRecursively(0, toLevel)\n\t\t\tm.showCursor = true\n\t\t}\n\n\tcase key.Matches(msg, keyMap.ToggleWrap):\n\t\tat := m.cursorPointsTo()\n\t\tm.wrap = !m.wrap\n\t\tif m.wrap {\n\t\t\tWrapAll(m.top, m.termWidth)\n\t\t} else {\n\t\t\tDropWrapAll(m.top)\n\t\t}\n\t\tif at.Chunk != nil && at.Value == nil {\n\t\t\tat = at.Parent()\n\t\t}\n\t\tm.redoSearch()\n\t\tm.selectNode(at)\n\n\tcase key.Matches(msg, keyMap.Yank):\n\t\tm.yank = true\n\n\tcase key.Matches(msg, keyMap.Preview):\n\t\tm.showPreview = true\n\t\tcontent := lipgloss.NewStyle().Width(m.termWidth).Render(m.cursorValue())\n\t\tm.preview.SetContent(content)\n\t\tm.preview.GotoTop()\n\n\tcase key.Matches(msg, keyMap.Print):\n\t\treturn m, m.print()\n\n\tcase key.Matches(msg, keyMap.Dig):\n\t\tm.digInput.SetValue(m.cursorPath() + \".\")\n\t\tm.digInput.CursorEnd()\n\t\tm.digInput.Width = m.termWidth - 1\n\t\tm.digInput.Focus()\n\n\tcase key.Matches(msg, keyMap.Search):\n\t\tm.searchInput.CursorEnd()\n\t\tm.searchInput.Width = m.termWidth - 2 // -1 for the prompt, -1 for the cursor\n\t\tm.searchInput.Focus()\n\n\tcase key.Matches(msg, keyMap.SearchNext):\n\t\tm.selectSearchResult(m.search.cursor + 1)\n\n\tcase key.Matches(msg, keyMap.SearchPrev):\n\t\tm.selectSearchResult(m.search.cursor - 1)\n\t}\n\treturn m, nil\n}\n\nfunc (m *model) up() {\n\tm.showCursor = true\n\tm.cursor--\n\tif m.cursor < 0 {\n\t\tm.cursor = 0\n\t\tif m.head.Prev != nil {\n\t\t\tm.head = m.head.Prev\n\t\t}\n\t}\n}\n\nfunc (m *model) down() {\n\tm.showCursor = true\n\tm.cursor++\n\tn := m.cursorPointsTo()\n\tif n == nil {\n\t\tm.cursor--\n\t\treturn\n\t}\n\tif m.cursor >= m.viewHeight() {\n\t\tm.cursor = m.viewHeight() - 1\n\t\tif m.head.Next != nil {\n\t\t\tm.head = m.head.Next\n\t\t}\n\t}\n}\n\nfunc (m *model) visibleLines() int {\n\tvisibleLines := 0\n\tn := m.head\n\tfor n != nil && visibleLines < m.viewHeight() {\n\t\tvisibleLines++\n\t\tn = n.Next\n\t}\n\treturn visibleLines\n}\n\nfunc (m *model) scrollIntoView() {\n\tvisibleLines := m.visibleLines()\n\tif m.cursor >= visibleLines {\n\t\tm.cursor = visibleLines - 1\n\t}\n\tfor visibleLines < m.viewHeight() && m.head.Prev != nil {\n\t\tvisibleLines++\n\t\tm.cursor++\n\t\tm.head = m.head.Prev\n\t}\n}\n\nfunc (m *model) View() string {\n\tif m.showHelp {\n\t\tstatusBar := flex(m.termWidth, \": press q or ? to close help\", \"\")\n\t\treturn m.help.View() + \"\\n\" + string(theme.CurrentTheme.StatusBar([]byte(statusBar)))\n\t}\n\n\tif m.showPreview {\n\t\tstatusBar := flex(m.termWidth, m.cursorPath(), m.fileName)\n\t\treturn m.preview.View() + \"\\n\" + string(theme.CurrentTheme.StatusBar([]byte(statusBar)))\n\t}\n\n\tvar screen []byte\n\tn := m.head\n\n\tprintedLines := 0\n\tfor lineNumber := 0; lineNumber < m.viewHeight(); lineNumber++ {\n\t\tif n == nil {\n\t\t\tbreak\n\t\t}\n\t\tfor ident := 0; ident < int(n.Depth); ident++ {\n\t\t\tscreen = append(screen, ' ', ' ')\n\t\t}\n\n\t\tisSelected := m.cursor == lineNumber\n\t\tif !m.showCursor {\n\t\t\tisSelected = false // don't highlight the cursor while iterating search results\n\t\t}\n\n\t\tif n.Key != nil {\n\t\t\tscreen = append(screen, m.prettyKey(n, isSelected)...)\n\t\t\tscreen = append(screen, theme.Colon...)\n\t\t\tisSelected = false // don't highlight the key's value\n\t\t}\n\n\t\tscreen = append(screen, m.prettyPrint(n, isSelected)...)\n\n\t\tif n.IsCollapsed() {\n\t\t\tif n.Value[0] == '{' {\n\t\t\t\tif n.Collapsed.Key != nil {\n\t\t\t\t\tscreen = append(screen, theme.CurrentTheme.Preview(n.Collapsed.Key)...)\n\t\t\t\t\tscreen = append(screen, theme.ColonPreview...)\n\t\t\t\t}\n\t\t\t\tscreen = append(screen, theme.Dot3...)\n\t\t\t\tscreen = append(screen, theme.CloseCurlyBracket...)\n\t\t\t} else if n.Value[0] == '[' {\n\t\t\t\tscreen = append(screen, theme.Dot3...)\n\t\t\t\tscreen = append(screen, theme.CloseSquareBracket...)\n\t\t\t}\n\t\t\tif n.End != nil && n.End.Comma {\n\t\t\t\tscreen = append(screen, theme.Comma...)\n\t\t\t}\n\t\t}\n\t\tif n.Comma {\n\t\t\tscreen = append(screen, theme.Comma...)\n\t\t}\n\n\t\tif theme.ShowSizes && len(n.Value) > 0 && (n.Value[0] == '{' || n.Value[0] == '[') {\n\t\t\tif n.IsCollapsed() || n.Size > 1 {\n\t\t\t\tscreen = append(screen, theme.CurrentTheme.Size([]byte(fmt.Sprintf(\" // %d\", n.Size)))...)\n\t\t\t}\n\t\t}\n\n\t\tscreen = append(screen, '\\n')\n\t\tprintedLines++\n\t\tn = n.Next\n\t}\n\n\tfor i := printedLines; i < m.viewHeight(); i++ {\n\t\tscreen = append(screen, theme.Empty...)\n\t\tscreen = append(screen, '\\n')\n\t}\n\n\tif m.digInput.Focused() {\n\t\tscreen = append(screen, m.digInput.View()...)\n\t} else {\n\t\tstatusBar := flex(m.termWidth, m.cursorPath(), m.fileName)\n\t\tscreen = append(screen, theme.CurrentTheme.StatusBar([]byte(statusBar))...)\n\t}\n\n\tif m.yank {\n\t\tscreen = append(screen, '\\n')\n\t\tscreen = append(screen, []byte(\"(y)value  (p)path  (k)key\")...)\n\t} else if m.searchInput.Focused() {\n\t\tscreen = append(screen, '\\n')\n\t\tscreen = append(screen, m.searchInput.View()...)\n\t} else if m.searchInput.Value() != \"\" {\n\t\tscreen = append(screen, '\\n')\n\t\tre, ci := regexCase(m.searchInput.Value())\n\t\tre = \"/\" + re + \"/\"\n\t\tif ci {\n\t\t\tre += \"i\"\n\t\t}\n\t\tif m.search.err != nil {\n\t\t\tscreen = append(screen, flex(m.termWidth, re, m.search.err.Error())...)\n\t\t} else if len(m.search.results) == 0 {\n\t\t\tscreen = append(screen, flex(m.termWidth, re, \"not found\")...)\n\t\t} else {\n\t\t\tcursor := fmt.Sprintf(\"found: [%v/%v]\", m.search.cursor+1, len(m.search.results))\n\t\t\tscreen = append(screen, flex(m.termWidth, re, cursor)...)\n\t\t}\n\t}\n\n\treturn string(screen)\n}\n\nfunc (m *model) prettyKey(node *Node, selected bool) []byte {\n\tb := node.Key\n\n\tstyle := theme.CurrentTheme.Key\n\tif selected {\n\t\tstyle = theme.CurrentTheme.Cursor\n\t}\n\n\tif indexes, ok := m.search.keys[node]; ok {\n\t\tvar out []byte\n\t\tfor i, p := range splitBytesByIndexes(b, indexes) {\n\t\t\tif i%2 == 0 {\n\t\t\t\tout = append(out, style(p.b)...)\n\t\t\t} else if p.index == m.search.cursor {\n\t\t\t\tout = append(out, theme.CurrentTheme.Cursor(p.b)...)\n\t\t\t} else {\n\t\t\t\tout = append(out, theme.CurrentTheme.Search(p.b)...)\n\t\t\t}\n\t\t}\n\t\treturn out\n\t} else {\n\t\treturn style(b)\n\t}\n}\n\nfunc (m *model) prettyPrint(node *Node, selected bool) []byte {\n\tvar b []byte\n\tif node.Chunk != nil {\n\t\tb = node.Chunk\n\t} else {\n\t\tb = node.Value\n\t}\n\n\tif len(b) == 0 {\n\t\treturn b\n\t}\n\n\tstyle := theme.Value(b, selected, node.Chunk != nil)\n\n\tif indexes, ok := m.search.values[node]; ok {\n\t\tvar out []byte\n\t\tfor i, p := range splitBytesByIndexes(b, indexes) {\n\t\t\tif i%2 == 0 {\n\t\t\t\tout = append(out, style(p.b)...)\n\t\t\t} else if p.index == m.search.cursor {\n\t\t\t\tout = append(out, theme.CurrentTheme.Cursor(p.b)...)\n\t\t\t} else {\n\t\t\t\tout = append(out, theme.CurrentTheme.Search(p.b)...)\n\t\t\t}\n\t\t}\n\t\treturn out\n\t} else {\n\t\treturn style(b)\n\t}\n}\n\nfunc (m *model) viewHeight() int {\n\tif m.searchInput.Focused() || m.searchInput.Value() != \"\" {\n\t\treturn m.termHeight - 2\n\t}\n\tif m.yank {\n\t\treturn m.termHeight - 2\n\t}\n\treturn m.termHeight - 1\n}\n\nfunc (m *model) cursorPointsTo() *Node {\n\treturn m.at(m.cursor)\n}\n\nfunc (m *model) at(pos int) *Node {\n\thead := m.head\n\tfor i := 0; i < pos; i++ {\n\t\tif head == nil {\n\t\t\tbreak\n\t\t}\n\t\thead = head.Next\n\t}\n\treturn head\n}\n\nfunc (m *model) findBottom() *Node {\n\tn := m.head\n\tfor n.Next != nil {\n\t\tif n.End != nil {\n\t\t\tn = n.End\n\t\t} else {\n\t\t\tn = n.Next\n\t\t}\n\t}\n\treturn n\n}\n\nfunc (m *model) nodeInsideView(n *Node) bool {\n\tif n == nil {\n\t\treturn false\n\t}\n\thead := m.head\n\tfor i := 0; i < m.viewHeight(); i++ {\n\t\tif head == nil {\n\t\t\tbreak\n\t\t}\n\t\tif head == n {\n\t\t\treturn true\n\t\t}\n\t\thead = head.Next\n\t}\n\treturn false\n}\n\nfunc (m *model) selectNodeInView(n *Node) {\n\thead := m.head\n\tfor i := 0; i < m.viewHeight(); i++ {\n\t\tif head == nil {\n\t\t\tbreak\n\t\t}\n\t\tif head == n {\n\t\t\tm.cursor = i\n\t\t\treturn\n\t\t}\n\t\thead = head.Next\n\t}\n}\n\nfunc (m *model) selectNode(n *Node) {\n\tm.showCursor = true\n\tif m.nodeInsideView(n) {\n\t\tm.selectNodeInView(n)\n\t\tm.scrollIntoView()\n\t} else {\n\t\tm.cursor = 0\n\t\tm.head = n\n\t\tm.scrollIntoView()\n\t}\n\tparent := n.Parent()\n\tfor parent != nil {\n\t\tparent.Expand()\n\t\tparent = parent.Parent()\n\t}\n}\n\nfunc (m *model) cursorPath() string {\n\tpath := \"\"\n\tat := m.cursorPointsTo()\n\tfor at != nil {\n\t\tif at.Prev != nil {\n\t\t\tif at.Chunk != nil && at.Value == nil {\n\t\t\t\tat = at.Parent()\n\t\t\t}\n\t\t\tif at.Key != nil {\n\t\t\t\tquoted := string(at.Key)\n\t\t\t\tunquoted, err := strconv.Unquote(quoted)\n\t\t\t\tif err == nil && jsonpath.Identifier.MatchString(unquoted) {\n\t\t\t\t\tpath = \".\" + unquoted + path\n\t\t\t\t} else {\n\t\t\t\t\tpath = \"[\" + quoted + \"]\" + path\n\t\t\t\t}\n\t\t\t} else if at.Index >= 0 {\n\t\t\t\tpath = \"[\" + strconv.Itoa(at.Index) + \"]\" + path\n\t\t\t}\n\t\t}\n\t\tat = at.Parent()\n\t}\n\treturn path\n}\n\nfunc (m *model) cursorValue() string {\n\tat := m.cursorPointsTo()\n\tif at == nil {\n\t\treturn \"\"\n\t}\n\tparent := at.Parent()\n\tif parent != nil {\n\t\t// wrapped string part\n\t\tif at.Chunk != nil && at.Value == nil {\n\t\t\tat = parent\n\t\t}\n\t\tif len(at.Value) == 1 && at.Value[0] == '}' || at.Value[0] == ']' {\n\t\t\tat = parent\n\t\t}\n\t}\n\n\tif len(at.Value) > 0 && at.Value[0] == '\"' {\n\t\tstr, err := strconv.Unquote(string(at.Value))\n\t\tif err == nil {\n\t\t\treturn str\n\t\t}\n\t\treturn string(at.Value)\n\t}\n\n\tvar out strings.Builder\n\tout.Write(at.Value)\n\tout.WriteString(\"\\n\")\n\tif at.HasChildren() {\n\t\tit := at.Next\n\t\tif at.IsCollapsed() {\n\t\t\tit = at.Collapsed\n\t\t}\n\t\tfor it != nil {\n\t\t\tout.WriteString(strings.Repeat(\"  \", int(it.Depth-at.Depth)))\n\t\t\tif it.Key != nil {\n\t\t\t\tout.Write(it.Key)\n\t\t\t\tout.WriteString(\": \")\n\t\t\t}\n\t\t\tif it.Value != nil {\n\t\t\t\tout.Write(it.Value)\n\t\t\t}\n\t\t\tif it == at.End {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif it.Comma {\n\t\t\t\tout.WriteString(\",\")\n\t\t\t}\n\t\t\tout.WriteString(\"\\n\")\n\t\t\tif it.ChunkEnd != nil {\n\t\t\t\tit = it.ChunkEnd.Next\n\t\t\t} else if it.IsCollapsed() {\n\t\t\t\tit = it.Collapsed\n\t\t\t} else {\n\t\t\t\tit = it.Next\n\t\t\t}\n\t\t}\n\t}\n\treturn out.String()\n}\n\nfunc (m *model) cursorKey() string {\n\tat := m.cursorPointsTo()\n\tif at == nil {\n\t\treturn \"\"\n\t}\n\tif at.IsWrap() {\n\t\tat = at.Parent()\n\t}\n\tif at.Key != nil {\n\t\tvar v string\n\t\t_ = json.Unmarshal(at.Key, &v)\n\t\treturn v\n\t}\n\treturn strconv.Itoa(at.Index)\n\n}\n\nfunc (m *model) selectByPath(path []any) *Node {\n\tn := m.currentTopNode()\n\tfor _, part := range path {\n\t\tif n == nil {\n\t\t\treturn nil\n\t\t}\n\t\tswitch part := part.(type) {\n\t\tcase string:\n\t\t\tn = n.FindChildByKey(part)\n\t\tcase int:\n\t\t\tn = n.FindChildByIndex(part)\n\t\t}\n\t}\n\treturn n\n}\n\nfunc (m *model) currentTopNode() *Node {\n\tat := m.cursorPointsTo()\n\tif at == nil {\n\t\treturn nil\n\t}\n\tfor at.Parent() != nil {\n\t\tat = at.Parent()\n\t}\n\treturn at\n}\n\nfunc (m *model) doSearch(s string) {\n\tm.search = newSearch()\n\n\tif s == \"\" {\n\t\treturn\n\t}\n\n\tcode, ci := regexCase(s)\n\tif ci {\n\t\tcode = \"(?i)\" + code\n\t}\n\n\tre, err := regexp.Compile(code)\n\tif err != nil {\n\t\tm.search.err = err\n\t\treturn\n\t}\n\n\tn := m.top\n\tsearchIndex := 0\n\tfor n != nil {\n\t\tif n.Key != nil {\n\t\t\tindexes := re.FindAllIndex(n.Key, -1)\n\t\t\tif len(indexes) > 0 {\n\t\t\t\tfor i, pair := range indexes {\n\t\t\t\t\tm.search.results = append(m.search.results, n)\n\t\t\t\t\tm.search.keys[n] = append(m.search.keys[n], match{start: pair[0], end: pair[1], index: searchIndex + i})\n\t\t\t\t}\n\t\t\t\tsearchIndex += len(indexes)\n\t\t\t}\n\t\t}\n\t\tindexes := re.FindAllIndex(n.Value, -1)\n\t\tif len(indexes) > 0 {\n\t\t\tfor range indexes {\n\t\t\t\tm.search.results = append(m.search.results, n)\n\t\t\t}\n\t\t\tif n.Chunk != nil {\n\t\t\t\t// String can be split into chunks, so we need to map the indexes to the chunks.\n\t\t\t\tchunks := [][]byte{n.Chunk}\n\t\t\t\tchunkNodes := []*Node{n}\n\n\t\t\t\tit := n.Next\n\t\t\t\tfor it != nil {\n\t\t\t\t\tchunkNodes = append(chunkNodes, it)\n\t\t\t\t\tchunks = append(chunks, it.Chunk)\n\t\t\t\t\tif it == n.ChunkEnd {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tit = it.Next\n\t\t\t\t}\n\n\t\t\t\tchunkMatches := splitIndexesToChunks(chunks, indexes, searchIndex)\n\t\t\t\tfor i, matches := range chunkMatches {\n\t\t\t\t\tm.search.values[chunkNodes[i]] = matches\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor i, pair := range indexes {\n\t\t\t\t\tm.search.values[n] = append(m.search.values[n], match{start: pair[0], end: pair[1], index: searchIndex + i})\n\t\t\t\t}\n\t\t\t}\n\t\t\tsearchIndex += len(indexes)\n\t\t}\n\n\t\tif n.IsCollapsed() {\n\t\t\tn = n.Collapsed\n\t\t} else {\n\t\t\tn = n.Next\n\t\t}\n\t}\n\n\tm.selectSearchResult(0)\n}\n\nfunc (m *model) selectSearchResult(i int) {\n\tif len(m.search.results) == 0 {\n\t\treturn\n\t}\n\tif i < 0 {\n\t\ti = len(m.search.results) - 1\n\t}\n\tif i >= len(m.search.results) {\n\t\ti = 0\n\t}\n\tm.search.cursor = i\n\tresult := m.search.results[i]\n\tm.selectNode(result)\n\tm.showCursor = false\n}\n\nfunc (m *model) redoSearch() {\n\tif m.searchInput.Value() != \"\" && len(m.search.results) > 0 {\n\t\tcursor := m.search.cursor\n\t\tm.doSearch(m.searchInput.Value())\n\t\tm.selectSearchResult(cursor)\n\t}\n}\n\nfunc (m *model) dig(v string) *Node {\n\tp, ok := jsonpath.Split(v)\n\tif !ok {\n\t\treturn nil\n\t}\n\tat := m.selectByPath(p)\n\tif at != nil {\n\t\treturn at\n\t}\n\n\tlastPart := p[len(p)-1]\n\tsearchTerm, ok := lastPart.(string)\n\tif !ok {\n\t\treturn nil\n\t}\n\tp = p[:len(p)-1]\n\n\tat = m.selectByPath(p)\n\tif at == nil {\n\t\treturn nil\n\t}\n\n\tkeys, nodes := at.Children()\n\n\tmatches := fuzzy.Find(searchTerm, keys)\n\tif len(matches) == 0 {\n\t\treturn nil\n\t}\n\n\treturn nodes[matches[0].Index]\n}\n\nfunc (m *model) print() tea.Cmd {\n\tm.printOnExit = true\n\treturn tea.Quit\n\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 2.763671875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/textinput\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/charmbracelet/x/exp/teatest\"\n\t\"github.com/muesli/termenv\"\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/antonmedv/fx/internal/jsonx\"\n\t\"github.com/antonmedv/fx/internal/theme\"\n)\n\nfunc init() {\n\tlipgloss.SetColorProfile(termenv.ANSI)\n}\n\nfunc prepare(t *testing.T) *teatest.TestModel {\n\tfile, err := os.Open(\"testdata/example.json\")\n\trequire.NoError(t, err)\n\n\tjson, err := io.ReadAll(file)\n\trequire.NoError(t, err)\n\n\thead, err := jsonx.Parse(json)\n\trequire.NoError(t, err)\n\n\tm := &model{\n\t\ttop:         head,\n\t\thead:        head,\n\t\twrap:        true,\n\t\tshowCursor:  true,\n\t\tdigInput:    textinput.New(),\n\t\tsearchInput: textinput.New(),\n\t\tsearch:      newSearch(),\n\t}\n\ttm := teatest.NewTestModel(\n\t\tt, m,\n\t\tteatest.WithInitialTermSize(80, 40),\n\t)\n\treturn tm\n}\n\nfunc read(t *testing.T, tm *teatest.TestModel) []byte {\n\tvar out []byte\n\tteatest.WaitFor(t,\n\t\ttm.Output(),\n\t\tfunc(b []byte) bool {\n\t\t\tout = b\n\t\t\treturn bytes.Contains(b, []byte(\"{\"))\n\t\t},\n\t\tteatest.WithCheckInterval(time.Millisecond*100),\n\t\tteatest.WithDuration(time.Second),\n\t)\n\treturn out\n}\n\nfunc TestOutput(t *testing.T) {\n\ttm := prepare(t)\n\n\tteatest.RequireEqualOutput(t, read(t, tm))\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(\"q\")})\n\ttm.WaitFinished(t, teatest.WithFinalTimeout(time.Second))\n}\n\nfunc TestNavigation(t *testing.T) {\n\ttm := prepare(t)\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyDown})\n\ttm.Send(tea.KeyMsg{Type: tea.KeyDown})\n\ttm.Send(tea.KeyMsg{Type: tea.KeyDown})\n\tteatest.RequireEqualOutput(t, read(t, tm))\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(\"q\")})\n\ttm.WaitFinished(t, teatest.WithFinalTimeout(time.Second))\n}\n\nfunc TestDig(t *testing.T) {\n\ttm := prepare(t)\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(\".\")})\n\ttm.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(\"year\")})\n\ttm.Send(tea.KeyMsg{Type: tea.KeyEnter})\n\tteatest.RequireEqualOutput(t, read(t, tm))\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(\"q\")})\n\ttm.WaitFinished(t, teatest.WithFinalTimeout(time.Second))\n}\n\nfunc TestCollapseRecursive(t *testing.T) {\n\ttm := prepare(t)\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyShiftLeft})\n\tteatest.RequireEqualOutput(t, read(t, tm))\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(\"q\")})\n\ttm.WaitFinished(t, teatest.WithFinalTimeout(time.Second))\n}\n\nfunc TestCollapseRecursiveWithSizes(t *testing.T) {\n\ttheme.ShowSizes = true\n\tdefer func() { theme.ShowSizes = true }()\n\n\ttm := prepare(t)\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyShiftLeft})\n\tteatest.RequireEqualOutput(t, read(t, tm))\n\n\ttm.Send(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune(\"q\")})\n\ttm.WaitFinished(t, teatest.WithFinalTimeout(time.Second))\n}\n"
        },
        {
          "name": "npm",
          "type": "tree",
          "content": null
        },
        {
          "name": "path",
          "type": "tree",
          "content": null
        },
        {
          "name": "reduce.go",
          "type": "blob",
          "size": 1.1533203125,
          "content": "package main\n\nimport (\n\t_ \"embed\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\n\t\"github.com/antonmedv/fx/internal/engine\"\n)\n\n//go:embed npm/index.js\nvar src []byte\n\nfunc reduce(fns []string) {\n\tif _, ok := os.LookupEnv(\"FX_JS\"); ok {\n\t\tengine.Reduce(fns)\n\t\treturn\n\t}\n\n\tvar deno bool\n\tbin, err := exec.LookPath(\"node\")\n\tif err != nil {\n\t\tbin, err = exec.LookPath(\"deno\")\n\t\tif err != nil {\n\t\t\tengine.Reduce(fns)\n\t\t\treturn\n\t\t}\n\t\tdeno = true\n\t}\n\n\tscript := path.Join(os.TempDir(), fmt.Sprintf(\"fx-%v.js\", version))\n\t_, err = os.Stat(script)\n\tif os.IsNotExist(err) {\n\t\terr := os.WriteFile(script, src, 0644)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tenv := os.Environ()\n\tvar args []string\n\n\tif deno {\n\t\targs = []string{\"run\", \"-A\", script}\n\t\tenv = append(env, \"V8_FLAGS=--max-old-space-size=16384\")\n\t} else {\n\t\targs = []string{script}\n\t\tenv = append(env, \"NODE_OPTIONS=--max-old-space-size=16384\")\n\t}\n\n\targs = append(args, fns...)\n\n\tcmd := exec.Command(bin, args...)\n\tcmd.Env = env\n\tcmd.Stdin = os.Stdin\n\tcmd.Stdout = os.Stdout\n\tcmd.Stderr = os.Stderr\n\terr = cmd.Run()\n\n\tswitch err := err.(type) {\n\tcase nil:\n\t\tos.Exit(0)\n\tcase *exec.ExitError:\n\t\tos.Exit(err.ExitCode())\n\tdefault:\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "search.go",
          "type": "blob",
          "size": 1.75390625,
          "content": "package main\n\nimport (\n\t. \"github.com/antonmedv/fx/internal/jsonx\"\n)\n\ntype search struct {\n\terr     error\n\tresults []*Node\n\tcursor  int\n\tvalues  map[*Node][]match\n\tkeys    map[*Node][]match\n}\n\nfunc newSearch() *search {\n\treturn &search{\n\t\tresults: make([]*Node, 0),\n\t\tvalues:  make(map[*Node][]match),\n\t\tkeys:    make(map[*Node][]match),\n\t}\n}\n\ntype match struct {\n\tstart, end int\n\tindex      int\n}\n\ntype piece struct {\n\tb     []byte\n\tindex int\n}\n\nfunc splitBytesByIndexes(b []byte, indexes []match) []piece {\n\tout := make([]piece, 0, 1)\n\tpos := 0\n\tfor _, pair := range indexes {\n\t\tout = append(out, piece{safeSlice(b, pos, pair.start), -1})\n\t\tout = append(out, piece{safeSlice(b, pair.start, pair.end), pair.index})\n\t\tpos = pair.end\n\t}\n\tout = append(out, piece{safeSlice(b, pos, len(b)), -1})\n\treturn out\n}\n\nfunc splitIndexesToChunks(chunks [][]byte, indexes [][]int, searchIndex int) (chunkIndexes [][]match) {\n\tchunkIndexes = make([][]match, len(chunks))\n\n\tfor index, idx := range indexes {\n\t\tposition := 0\n\t\tfor i, chunk := range chunks {\n\t\t\t// If start index lies in this chunk\n\t\t\tif idx[0] < position+len(chunk) {\n\t\t\t\t// Calculate local start and end for this chunk\n\t\t\t\tlocalStart := idx[0] - position\n\t\t\t\tlocalEnd := idx[1] - position\n\n\t\t\t\t// If the end index also lies in this chunk\n\t\t\t\tif idx[1] <= position+len(chunk) {\n\t\t\t\t\tchunkIndexes[i] = append(chunkIndexes[i], match{start: localStart, end: localEnd, index: searchIndex + index})\n\t\t\t\t\tbreak\n\t\t\t\t} else {\n\t\t\t\t\t// If the end index is outside this chunk, split the index\n\t\t\t\t\tchunkIndexes[i] = append(chunkIndexes[i], match{start: localStart, end: len(chunk), index: searchIndex + index})\n\n\t\t\t\t\t// Adjust the starting index for the next chunk\n\t\t\t\t\tidx[0] = position + len(chunk)\n\t\t\t\t}\n\t\t\t}\n\t\t\tposition += len(chunk)\n\t\t}\n\t}\n\n\treturn\n}\n"
        },
        {
          "name": "snap",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 0.623046875,
          "content": "package main\n\nimport (\n\t\"strings\"\n)\n\nfunc regexCase(code string) (string, bool) {\n\tif strings.HasSuffix(code, \"/i\") {\n\t\treturn code[:len(code)-2], true\n\t} else if strings.HasSuffix(code, \"/\") {\n\t\treturn code[:len(code)-1], false\n\t} else {\n\t\treturn code, true\n\t}\n}\n\nfunc flex(width int, a, b string) string {\n\treturn a + strings.Repeat(\" \", max(1, width-len(a)-len(b))) + b\n}\n\nfunc safeSlice(b []byte, start, end int) []byte {\n\tlength := len(b)\n\tif start > length {\n\t\tstart = length\n\t}\n\tif end > length {\n\t\tend = length\n\t}\n\tif start < 0 {\n\t\tstart = 0\n\t}\n\tif end < 0 {\n\t\tend = 0\n\t}\n\tif start > end {\n\t\tstart = end\n\t}\n\treturn b[start:end]\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.0380859375,
          "content": "package main\n\nconst version = \"35.0.0\"\n"
        }
      ]
    }
  ]
}