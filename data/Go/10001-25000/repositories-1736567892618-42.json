{
  "metadata": {
    "timestamp": 1736567892618,
    "page": 42,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "redis/go-redis",
      "stars": 20346,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.046875,
          "content": "*.rdb\ntestdata/*\n.idea/\n.DS_Store\n*.tar.gz\n*.dic"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.05078125,
          "content": "run:\n  concurrency: 8\n  deadline: 5m\n  tests: false\n"
        },
        {
          "name": ".prettierrc.yml",
          "type": "blob",
          "size": 0.0625,
          "content": "semi: false\nsingleQuote: true\nproseWrap: always\nprintWidth: 100\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.271484375,
          "content": "## Unreleased\n\n### Changed\n\n* `go-redis` won't skip span creation if the parent spans is not recording. ([#2980](https://github.com/redis/go-redis/issues/2980))\n  Users can use the OpenTelemetry sampler to control the sampling behavior.\n  For instance, you can use the `ParentBased(NeverSample())` sampler from `go.opentelemetry.io/otel/sdk/trace` to keep\n  a similar behavior (drop orphan spans) of `go-redis` as before.\n\n## [9.0.5](https://github.com/redis/go-redis/compare/v9.0.4...v9.0.5) (2023-05-29)\n\n\n### Features\n\n* Add ACL LOG ([#2536](https://github.com/redis/go-redis/issues/2536)) ([31ba855](https://github.com/redis/go-redis/commit/31ba855ddebc38fbcc69a75d9d4fb769417cf602))\n* add field protocol to setupClusterQueryParams ([#2600](https://github.com/redis/go-redis/issues/2600)) ([840c25c](https://github.com/redis/go-redis/commit/840c25cb6f320501886a82a5e75f47b491e46fbe))\n* add protocol option ([#2598](https://github.com/redis/go-redis/issues/2598)) ([3917988](https://github.com/redis/go-redis/commit/391798880cfb915c4660f6c3ba63e0c1a459e2af))\n\n\n\n## [9.0.4](https://github.com/redis/go-redis/compare/v9.0.3...v9.0.4) (2023-05-01)\n\n\n### Bug Fixes\n\n* reader float parser ([#2513](https://github.com/redis/go-redis/issues/2513)) ([46f2450](https://github.com/redis/go-redis/commit/46f245075e6e3a8bd8471f9ca67ea95fd675e241))\n\n\n### Features\n\n* add client info command ([#2483](https://github.com/redis/go-redis/issues/2483)) ([b8c7317](https://github.com/redis/go-redis/commit/b8c7317cc6af444603731f7017c602347c0ba61e))\n* no longer verify HELLO error messages ([#2515](https://github.com/redis/go-redis/issues/2515)) ([7b4f217](https://github.com/redis/go-redis/commit/7b4f2179cb5dba3d3c6b0c6f10db52b837c912c8))\n* read the structure to increase the judgment of the omitempty op… ([#2529](https://github.com/redis/go-redis/issues/2529)) ([37c057b](https://github.com/redis/go-redis/commit/37c057b8e597c5e8a0e372337f6a8ad27f6030af))\n\n\n\n## [9.0.3](https://github.com/redis/go-redis/compare/v9.0.2...v9.0.3) (2023-04-02)\n\n### New Features\n\n- feat(scan): scan time.Time sets the default decoding (#2413)\n- Add support for CLUSTER LINKS command (#2504)\n- Add support for acl dryrun command (#2502)\n- Add support for COMMAND GETKEYS & COMMAND GETKEYSANDFLAGS (#2500)\n- Add support for LCS Command (#2480)\n- Add support for BZMPOP (#2456)\n- Adding support for ZMPOP command (#2408)\n- Add support for LMPOP (#2440)\n- feat: remove pool unused fields (#2438)\n- Expiretime and PExpireTime (#2426)\n- Implement `FUNCTION` group of commands (#2475)\n- feat(zadd): add ZAddLT and ZAddGT (#2429)\n- Add: Support for COMMAND LIST command (#2491)\n- Add support for BLMPOP (#2442)\n- feat: check pipeline.Do to prevent confusion with Exec (#2517)\n- Function stats, function kill, fcall and fcall_ro (#2486)\n- feat: Add support for CLUSTER SHARDS command (#2507)\n- feat(cmd): support for adding byte,bit parameters to the bitpos command (#2498)\n\n### Fixed\n\n- fix: eval api cmd.SetFirstKeyPos (#2501)\n- fix: limit the number of connections created (#2441)\n- fixed #2462  v9 continue support dragonfly,  it's Hello command return \"NOAUTH Authentication required\" error (#2479)\n- Fix for internal/hscan/structmap.go:89:23: undefined: reflect.Pointer (#2458)\n- fix: group lag can be null (#2448)\n\n### Maintenance\n\n- Updating to the latest version of redis (#2508)\n- Allowing for running tests on a port other than the fixed 6380 (#2466)\n- redis 7.0.8 in tests (#2450)\n- docs: Update redisotel example for v9 (#2425)\n- chore: update go mod, Upgrade golang.org/x/net version to 0.7.0 (#2476)\n- chore: add Chinese translation (#2436)\n- chore(deps): bump github.com/bsm/gomega from 1.20.0 to 1.26.0 (#2421)\n- chore(deps): bump github.com/bsm/ginkgo/v2 from 2.5.0 to 2.7.0 (#2420)\n- chore(deps): bump actions/setup-go from 3 to 4 (#2495)\n- docs: add instructions for the HSet api (#2503)\n- docs: add reading lag field comment (#2451)\n- test: update go mod before testing(go mod tidy) (#2423)\n- docs: fix comment typo (#2505)\n- test: remove testify (#2463)\n- refactor: change ListElementCmd to KeyValuesCmd. (#2443)\n- fix(appendArg): appendArg case special type (#2489)\n\n## [9.0.2](https://github.com/redis/go-redis/compare/v9.0.1...v9.0.2) (2023-02-01)\n\n### Features\n\n* upgrade OpenTelemetry, use the new metrics API. ([#2410](https://github.com/redis/go-redis/issues/2410)) ([e29e42c](https://github.com/redis/go-redis/commit/e29e42cde2755ab910d04185025dc43ce6f59c65))\n\n## v9 2023-01-30\n\n### Breaking\n\n- Changed Pipelines to not be thread-safe any more.\n\n### Added\n\n- Added support for [RESP3](https://github.com/antirez/RESP3/blob/master/spec.md) protocol. It was\n  contributed by @monkey92t who has done the majority of work in this release.\n- Added `ContextTimeoutEnabled` option that controls whether the client respects context timeouts\n  and deadlines. See\n  [Redis Timeouts](https://redis.uptrace.dev/guide/go-redis-debugging.html#timeouts) for details.\n- Added `ParseClusterURL` to parse URLs into `ClusterOptions`, for example,\n  `redis://user:password@localhost:6789?dial_timeout=3&read_timeout=6s&addr=localhost:6790&addr=localhost:6791`.\n- Added metrics instrumentation using `redisotel.IstrumentMetrics`. See\n  [documentation](https://redis.uptrace.dev/guide/go-redis-monitoring.html)\n- Added `redis.HasErrorPrefix` to help working with errors.\n\n### Changed\n\n- Removed asynchronous cancellation based on the context timeout. It was racy in v8 and is\n  completely gone in v9.\n- Reworked hook interface and added `DialHook`.\n- Replaced `redisotel.NewTracingHook` with `redisotel.InstrumentTracing`. See\n  [example](example/otel) and\n  [documentation](https://redis.uptrace.dev/guide/go-redis-monitoring.html).\n- Replaced `*redis.Z` with `redis.Z` since it is small enough to be passed as value without making\n  an allocation.\n- Renamed the option `MaxConnAge` to `ConnMaxLifetime`.\n- Renamed the option `IdleTimeout` to `ConnMaxIdleTime`.\n- Removed connection reaper in favor of `MaxIdleConns`.\n- Removed `WithContext` since `context.Context` can be passed directly as an arg.\n- Removed `Pipeline.Close` since there is no real need to explicitly manage pipeline resources and\n  it can be safely reused via `sync.Pool` etc. `Pipeline.Discard` is still available if you want to\n  reset commands for some reason.\n\n### Fixed\n\n- Improved and fixed pipeline retries.\n- As usually, added support for more commands and fixed some bugs.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 3.498046875,
          "content": "# Contributing\n\n## Introduction\n\nWe appreciate your interest in considering contributing to go-redis.\nCommunity contributions mean a lot to us.\n\n## Contributions we need\n\nYou may already know how you'd like to contribute, whether it's a fix for a bug you\nencountered, or a new feature your team wants to use.\n\nIf you don't know where to start, consider improving\ndocumentation, bug triaging, and writing tutorials are all examples of\nhelpful contributions that mean less work for you.\n\n## Your First Contribution\n\nUnsure where to begin contributing? You can start by looking through\n[help-wanted\nissues](https://github.com/redis/go-redis/issues?q=is%3Aopen+is%3Aissue+label%3ahelp-wanted).\n\nNever contributed to open source before? Here are a couple of friendly\ntutorials:\n\n-   <http://makeapullrequest.com/>\n-   <http://www.firsttimersonly.com/>\n\n## Getting Started\n\nHere's how to get started with your code contribution:\n\n1.  Create your own fork of go-redis\n2.  Do the changes in your fork\n3.  If you need a development environment, run `make test`. Note: this clones and builds the latest release of [redis](https://redis.io). You also need a redis-stack-server docker, in order to run the capabilities tests. This can be started by running:\n    ```docker run -p 6379:6379 -it redis/redis-stack-server:edge```\n4.  While developing, make sure the tests pass by running `make tests`\n5.  If you like the change and think the project could use it, send a\n    pull request\n\nTo see what else is part of the automation, run `invoke -l`\n\n## Testing\n\nCall `make test` to run all tests, including linters.\n\nContinuous Integration uses these same wrappers to run all of these\ntests against multiple versions of python. Feel free to test your\nchanges against all the go versions supported, as declared by the\n[build.yml](./.github/workflows/build.yml) file.\n\n### Troubleshooting\n\nIf you get any errors when running `make test`, make sure\nthat you are using supported versions of Docker and go.\n\n## How to Report a Bug\n\n### Security Vulnerabilities\n\n**NOTE**: If you find a security vulnerability, do NOT open an issue.\nEmail [Redis Open Source (<oss@redis.com>)](mailto:oss@redis.com) instead.\n\nIn order to determine whether you are dealing with a security issue, ask\nyourself these two questions:\n\n-   Can I access something that's not mine, or something I shouldn't\n    have access to?\n-   Can I disable something for other people?\n\nIf the answer to either of those two questions are *yes*, then you're\nprobably dealing with a security issue. Note that even if you answer\n*no*  to both questions, you may still be dealing with a security\nissue, so if you're unsure, just email [us](mailto:oss@redis.com).\n\n### Everything Else\n\nWhen filing an issue, make sure to answer these five questions:\n\n1.  What version of go-redis are you using?\n2.  What version of redis are you using?\n3.  What did you do?\n4.  What did you expect to see?\n5.  What did you see instead?\n\n## Suggest a feature or enhancement\n\nIf you'd like to contribute a new feature, make sure you check our\nissue list to see if someone has already proposed it. Work may already\nbe underway on the feature you want or we may have rejected a\nfeature like it already.\n\nIf you don't see anything, open a new issue that describes the feature\nyou would like and how it should work.\n\n## Code review process\n\nThe core team regularly looks at pull requests. We will provide\nfeedback as soon as possible. After receiving our feedback, please respond\nwithin two weeks. After that time, we may close your PR if it isn't\nshowing any activity.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.287109375,
          "content": "Copyright (c) 2013 The github.com/redis/go-redis Authors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.42578125,
          "content": "GO_MOD_DIRS := $(shell find . -type f -name 'go.mod' -exec dirname {} \\; | sort)\n\ntest: testdeps\n\t$(eval GO_VERSION := $(shell go version | cut -d \" \" -f 3 | cut -d. -f2))\n\tset -e; for dir in $(GO_MOD_DIRS); do \\\n\t  if echo \"$${dir}\" | grep -q \"./example\" && [ \"$(GO_VERSION)\" = \"19\" ]; then \\\n\t    echo \"Skipping go test in $${dir} due to Go version 1.19 and dir contains ./example\"; \\\n\t    continue; \\\n\t  fi; \\\n\t  echo \"go test in $${dir}\"; \\\n\t  (cd \"$${dir}\" && \\\n\t    go mod tidy -compat=1.18 && \\\n\t    go test && \\\n\t    go test ./... -short -race && \\\n\t    go test ./... -run=NONE -bench=. -benchmem && \\\n\t    env GOOS=linux GOARCH=386 go test && \\\n\t    go test -coverprofile=coverage.txt -covermode=atomic ./... && \\\n\t    go vet); \\\n\tdone\n\tcd internal/customvet && go build .\n\tgo vet -vettool ./internal/customvet/customvet\n\ntestdeps: testdata/redis/src/redis-server\n\nbench: testdeps\n\tgo test ./... -test.run=NONE -test.bench=. -test.benchmem\n\n.PHONY: all test testdeps bench fmt\n\nbuild:\n\tgo build .\n\ntestdata/redis:\n\tmkdir -p $@\n\twget -qO- https://download.redis.io/releases/redis-7.4-rc2.tar.gz  | tar xvz --strip-components=1 -C $@\n\ntestdata/redis/src/redis-server: testdata/redis\n\tcd $< && make all\n\nfmt:\n\tgofumpt -w ./\n\tgoimports -w  -local github.com/redis/go-redis ./\n\ngo_mod_tidy:\n\tset -e; for dir in $(GO_MOD_DIRS); do \\\n\t  echo \"go mod tidy in $${dir}\"; \\\n\t  (cd \"$${dir}\" && \\\n\t    go get -u ./... && \\\n\t    go mod tidy -compat=1.18); \\\n\tdone\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.4892578125,
          "content": "# Redis client for Go\n\n[![build workflow](https://github.com/redis/go-redis/actions/workflows/build.yml/badge.svg)](https://github.com/redis/go-redis/actions)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/redis/go-redis/v9)](https://pkg.go.dev/github.com/redis/go-redis/v9?tab=doc)\n[![Documentation](https://img.shields.io/badge/redis-documentation-informational)](https://redis.uptrace.dev/)\n[![codecov](https://codecov.io/github/redis/go-redis/graph/badge.svg?token=tsrCZKuSSw)](https://codecov.io/github/redis/go-redis)\n[![Chat](https://discordapp.com/api/guilds/752070105847955518/widget.png)](https://discord.gg/rWtp5Aj)\n\n> go-redis is brought to you by :star: [**uptrace/uptrace**](https://github.com/uptrace/uptrace).\n> Uptrace is an open-source APM tool that supports distributed tracing, metrics, and logs. You can\n> use it to monitor applications and set up automatic alerts to receive notifications via email,\n> Slack, Telegram, and others.\n>\n> See [OpenTelemetry](https://github.com/redis/go-redis/tree/master/example/otel) example which\n> demonstrates how you can use Uptrace to monitor go-redis.\n\n## How do I Redis?\n\n[Learn for free at Redis University](https://university.redis.com/)\n\n[Build faster with the Redis Launchpad](https://launchpad.redis.com/)\n\n[Try the Redis Cloud](https://redis.com/try-free/)\n\n[Dive in developer tutorials](https://developer.redis.com/)\n\n[Join the Redis community](https://redis.com/community/)\n\n[Work at Redis](https://redis.com/company/careers/jobs/)\n\n## Documentation\n\n- [English](https://redis.uptrace.dev)\n- [简体中文](https://redis.uptrace.dev/zh/)\n\n## Resources\n\n- [Discussions](https://github.com/redis/go-redis/discussions)\n- [Chat](https://discord.gg/rWtp5Aj)\n- [Reference](https://pkg.go.dev/github.com/redis/go-redis/v9)\n- [Examples](https://pkg.go.dev/github.com/redis/go-redis/v9#pkg-examples)\n\n## Ecosystem\n\n- [Redis Mock](https://github.com/go-redis/redismock)\n- [Distributed Locks](https://github.com/bsm/redislock)\n- [Redis Cache](https://github.com/go-redis/cache)\n- [Rate limiting](https://github.com/go-redis/redis_rate)\n\nThis client also works with [Kvrocks](https://github.com/apache/incubator-kvrocks), a distributed\nkey value NoSQL database that uses RocksDB as storage engine and is compatible with Redis protocol.\n\n## Features\n\n- Redis commands except QUIT and SYNC.\n- Automatic connection pooling.\n- [Pub/Sub](https://redis.uptrace.dev/guide/go-redis-pubsub.html).\n- [Pipelines and transactions](https://redis.uptrace.dev/guide/go-redis-pipelines.html).\n- [Scripting](https://redis.uptrace.dev/guide/lua-scripting.html).\n- [Redis Sentinel](https://redis.uptrace.dev/guide/go-redis-sentinel.html).\n- [Redis Cluster](https://redis.uptrace.dev/guide/go-redis-cluster.html).\n- [Redis Ring](https://redis.uptrace.dev/guide/ring.html).\n- [Redis Performance Monitoring](https://redis.uptrace.dev/guide/redis-performance-monitoring.html).\n- [Redis Probabilistic [RedisStack]](https://redis.io/docs/data-types/probabilistic/)\n\n## Installation\n\ngo-redis supports 2 last Go versions and requires a Go version with\n[modules](https://github.com/golang/go/wiki/Modules) support. So make sure to initialize a Go\nmodule:\n\n```shell\ngo mod init github.com/my/repo\n```\n\nThen install go-redis/**v9**:\n\n```shell\ngo get github.com/redis/go-redis/v9\n```\n\n## Quickstart\n\n```go\nimport (\n    \"context\"\n    \"fmt\"\n\n    \"github.com/redis/go-redis/v9\"\n)\n\nvar ctx = context.Background()\n\nfunc ExampleClient() {\n    rdb := redis.NewClient(&redis.Options{\n        Addr:     \"localhost:6379\",\n        Password: \"\", // no password set\n        DB:       0,  // use default DB\n    })\n\n    err := rdb.Set(ctx, \"key\", \"value\", 0).Err()\n    if err != nil {\n        panic(err)\n    }\n\n    val, err := rdb.Get(ctx, \"key\").Result()\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(\"key\", val)\n\n    val2, err := rdb.Get(ctx, \"key2\").Result()\n    if err == redis.Nil {\n        fmt.Println(\"key2 does not exist\")\n    } else if err != nil {\n        panic(err)\n    } else {\n        fmt.Println(\"key2\", val2)\n    }\n    // Output: key value\n    // key2 does not exist\n}\n```\n\nThe above can be modified to specify the version of the RESP protocol by adding the `protocol`\noption to the `Options` struct:\n\n```go\n    rdb := redis.NewClient(&redis.Options{\n        Addr:     \"localhost:6379\",\n        Password: \"\", // no password set\n        DB:       0,  // use default DB\n        Protocol: 3, // specify 2 for RESP 2 or 3 for RESP 3\n    })\n\n```\n\n### Connecting via a redis url\n\ngo-redis also supports connecting via the\n[redis uri specification](https://github.com/redis/redis-specifications/tree/master/uri/redis.txt).\nThe example below demonstrates how the connection can easily be configured using a string, adhering\nto this specification.\n\n```go\nimport (\n    \"github.com/redis/go-redis/v9\"\n)\n\nfunc ExampleClient() *redis.Client {\n    url := \"redis://user:password@localhost:6379/0?protocol=3\"\n    opts, err := redis.ParseURL(url)\n    if err != nil {\n        panic(err)\n    }\n\n    return redis.NewClient(opts)\n}\n\n```\n\n\n### Advanced Configuration\n\ngo-redis supports extending the client identification phase to allow projects to send their own custom client identification.\n\n#### Default Client Identification\n\nBy default, go-redis automatically sends the client library name and version during the connection process. This feature is available in redis-server as of version 7.2. As a result, the command is \"fire and forget\", meaning it should fail silently, in the case that the redis server does not support this feature.\n\n#### Disabling Identity Verification\n\nWhen connection identity verification is not required or needs to be explicitly disabled, a `DisableIndentity` configuration option exists. In V10 of this library, `DisableIndentity` will become `DisableIdentity` in order to fix the associated typo.\n\nTo disable verification, set the `DisableIndentity` option to `true` in the Redis client options:\n\n```go\nrdb := redis.NewClient(&redis.Options{\n    Addr:            \"localhost:6379\",\n    Password:        \"\",\n    DB:              0,\n    DisableIndentity: true, // Disable set-info on connect\n})\n```\n\n#### Unstable RESP3 Structures for RediSearch Commands\nWhen integrating Redis with application functionalities using RESP3, it's important to note that some response structures aren't final yet. This is especially true for more complex structures like search and query results. We recommend using RESP2 when using the search and query capabilities, but we plan to stabilize the RESP3-based API-s in the coming versions. You can find more guidance in the upcoming release notes.\n\nTo enable unstable RESP3, set the option in your client configuration:\n\n```go\nredis.NewClient(&redis.Options{\n\t\t\tUnstableResp3: true,\n\t\t})\n```\n**Note:** When UnstableResp3 mode is enabled, it's necessary to use RawResult() and RawVal() to retrieve a raw data.\n          Since, raw response is the only option for unstable search commands Val() and Result() calls wouldn't have any affect on them:\n\n```go\nres1, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo bar\", &redis.FTSearchOptions{}).RawResult()\nval1 := client.FTSearchWithArgs(ctx, \"txt\", \"foo bar\", &redis.FTSearchOptions{}).RawVal()\n```\n\n## Contributing\n\nPlease see [out contributing guidelines](CONTRIBUTING.md) to help us improve this library!\n\n## Look and feel\n\nSome corner cases:\n\n```go\n// SET key value EX 10 NX\nset, err := rdb.SetNX(ctx, \"key\", \"value\", 10*time.Second).Result()\n\n// SET key value keepttl NX\nset, err := rdb.SetNX(ctx, \"key\", \"value\", redis.KeepTTL).Result()\n\n// SORT list LIMIT 0 2 ASC\nvals, err := rdb.Sort(ctx, \"list\", &redis.Sort{Offset: 0, Count: 2, Order: \"ASC\"}).Result()\n\n// ZRANGEBYSCORE zset -inf +inf WITHSCORES LIMIT 0 2\nvals, err := rdb.ZRangeByScoreWithScores(ctx, \"zset\", &redis.ZRangeBy{\n    Min: \"-inf\",\n    Max: \"+inf\",\n    Offset: 0,\n    Count: 2,\n}).Result()\n\n// ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3 AGGREGATE SUM\nvals, err := rdb.ZInterStore(ctx, \"out\", &redis.ZStore{\n    Keys: []string{\"zset1\", \"zset2\"},\n    Weights: []int64{2, 3}\n}).Result()\n\n// EVAL \"return {KEYS[1],ARGV[1]}\" 1 \"key\" \"hello\"\nvals, err := rdb.Eval(ctx, \"return {KEYS[1],ARGV[1]}\", []string{\"key\"}, \"hello\").Result()\n\n// custom command\nres, err := rdb.Do(ctx, \"set\", \"key\", \"value\").Result()\n```\n\n## Run the test\n\ngo-redis will start a redis-server and run the test cases.\n\nThe paths of redis-server bin file and redis config file are defined in `main_test.go`:\n\n```go\nvar (\n\tredisServerBin, _  = filepath.Abs(filepath.Join(\"testdata\", \"redis\", \"src\", \"redis-server\"))\n\tredisServerConf, _ = filepath.Abs(filepath.Join(\"testdata\", \"redis\", \"redis.conf\"))\n)\n```\n\nFor local testing, you can change the variables to refer to your local files, or create a soft link\nto the corresponding folder for redis-server and copy the config file to `testdata/redis/`:\n\n```shell\nln -s /usr/bin/redis-server ./go-redis/testdata/redis/src\ncp ./go-redis/testdata/redis.conf ./go-redis/testdata/redis/\n```\n\nLastly, run:\n\n```shell\ngo test\n```\n\nAnother option is to run your specific tests with an already running redis. The example below, tests\nagainst a redis running on port 9999.:\n\n```shell\nREDIS_PORT=9999 go test <your options>\n```\n\n## See also\n\n- [Golang ORM](https://bun.uptrace.dev) for PostgreSQL, MySQL, MSSQL, and SQLite\n- [Golang PostgreSQL](https://bun.uptrace.dev/postgres/)\n- [Golang HTTP router](https://bunrouter.uptrace.dev/)\n- [Golang ClickHouse ORM](https://github.com/uptrace/go-clickhouse)\n\n## Contributors\n\nThanks to all the people who already contributed!\n\n<a href=\"https://github.com/redis/go-redis/graphs/contributors\">\n  <img src=\"https://contributors-img.web.app/image?repo=redis/go-redis\" />\n</a>\n"
        },
        {
          "name": "RELEASING.md",
          "type": "blob",
          "size": 0.3251953125,
          "content": "# Releasing\n\n1. Run `release.sh` script which updates versions in go.mod files and pushes a new branch to GitHub:\n\n```shell\nTAG=v1.0.0 ./scripts/release.sh\n```\n\n2. Open a pull request and wait for the build to finish.\n\n3. Merge the pull request and run `tag.sh` to create tags for packages:\n\n```shell\nTAG=v1.0.0 ./scripts/tag.sh\n```\n"
        },
        {
          "name": "acl_commands.go",
          "type": "blob",
          "size": 0.9208984375,
          "content": "package redis\n\nimport \"context\"\n\ntype ACLCmdable interface {\n\tACLDryRun(ctx context.Context, username string, command ...interface{}) *StringCmd\n\tACLLog(ctx context.Context, count int64) *ACLLogCmd\n\tACLLogReset(ctx context.Context) *StatusCmd\n}\n\nfunc (c cmdable) ACLDryRun(ctx context.Context, username string, command ...interface{}) *StringCmd {\n\targs := make([]interface{}, 0, 3+len(command))\n\targs = append(args, \"acl\", \"dryrun\", username)\n\targs = append(args, command...)\n\tcmd := NewStringCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ACLLog(ctx context.Context, count int64) *ACLLogCmd {\n\targs := make([]interface{}, 0, 3)\n\targs = append(args, \"acl\", \"log\")\n\tif count > 0 {\n\t\targs = append(args, count)\n\t}\n\tcmd := NewACLLogCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ACLLogReset(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"acl\", \"log\", \"reset\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "bench_decode_test.go",
          "type": "blob",
          "size": 7.537109375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\nvar ctx = context.TODO()\n\ntype ClientStub struct {\n\tCmdable\n\tresp []byte\n}\n\nvar initHello = []byte(\"%1\\r\\n+proto\\r\\n:3\\r\\n\")\n\nfunc NewClientStub(resp []byte) *ClientStub {\n\tstub := &ClientStub{\n\t\tresp: resp,\n\t}\n\n\tstub.Cmdable = NewClient(&Options{\n\t\tPoolSize: 128,\n\t\tDialer: func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\treturn stub.stubConn(initHello), nil\n\t\t},\n\t\tDisableIndentity: true,\n\t})\n\treturn stub\n}\n\nfunc NewClusterClientStub(resp []byte) *ClientStub {\n\tstub := &ClientStub{\n\t\tresp: resp,\n\t}\n\n\tclient := NewClusterClient(&ClusterOptions{\n\t\tPoolSize: 128,\n\t\tAddrs:    []string{\":6379\"},\n\t\tDialer: func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\treturn stub.stubConn(initHello), nil\n\t\t},\n\t\tDisableIndentity: true,\n\n\t\tClusterSlots: func(_ context.Context) ([]ClusterSlot, error) {\n\t\t\treturn []ClusterSlot{\n\t\t\t\t{\n\t\t\t\t\tStart: 0,\n\t\t\t\t\tEnd:   16383,\n\t\t\t\t\tNodes: []ClusterNode{{Addr: \"127.0.0.1:6379\"}},\n\t\t\t\t},\n\t\t\t}, nil\n\t\t},\n\t})\n\n\tstub.Cmdable = client\n\treturn stub\n}\n\nfunc (c *ClientStub) stubConn(init []byte) *ConnStub {\n\treturn &ConnStub{\n\t\tinit: init,\n\t\tresp: c.resp,\n\t}\n}\n\ntype ConnStub struct {\n\tinit []byte\n\tresp []byte\n\tpos  int\n}\n\nfunc (c *ConnStub) Read(b []byte) (n int, err error) {\n\t// Return conn.init()\n\tif len(c.init) > 0 {\n\t\tn = copy(b, c.init)\n\t\tc.init = c.init[n:]\n\t\treturn n, nil\n\t}\n\n\tif len(c.resp) == 0 {\n\t\treturn 0, io.EOF\n\t}\n\n\tif c.pos >= len(c.resp) {\n\t\tc.pos = 0\n\t}\n\tn = copy(b, c.resp[c.pos:])\n\tc.pos += n\n\treturn n, nil\n}\n\nfunc (c *ConnStub) Write(b []byte) (n int, err error)  { return len(b), nil }\nfunc (c *ConnStub) Close() error                       { return nil }\nfunc (c *ConnStub) LocalAddr() net.Addr                { return nil }\nfunc (c *ConnStub) RemoteAddr() net.Addr               { return nil }\nfunc (c *ConnStub) SetDeadline(_ time.Time) error      { return nil }\nfunc (c *ConnStub) SetReadDeadline(_ time.Time) error  { return nil }\nfunc (c *ConnStub) SetWriteDeadline(_ time.Time) error { return nil }\n\ntype ClientStubFunc func([]byte) *ClientStub\n\nfunc BenchmarkDecode(b *testing.B) {\n\ttype Benchmark struct {\n\t\tname string\n\t\tstub ClientStubFunc\n\t}\n\n\tbenchmarks := []Benchmark{\n\t\t{\"server\", NewClientStub},\n\t\t{\"cluster\", NewClusterClientStub},\n\t}\n\n\tfor _, bench := range benchmarks {\n\t\tb.Run(fmt.Sprintf(\"RespError-%s\", bench.name), func(b *testing.B) {\n\t\t\trespError(b, bench.stub)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"RespStatus-%s\", bench.name), func(b *testing.B) {\n\t\t\trespStatus(b, bench.stub)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"RespInt-%s\", bench.name), func(b *testing.B) {\n\t\t\trespInt(b, bench.stub)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"RespString-%s\", bench.name), func(b *testing.B) {\n\t\t\trespString(b, bench.stub)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"RespArray-%s\", bench.name), func(b *testing.B) {\n\t\t\trespArray(b, bench.stub)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"RespPipeline-%s\", bench.name), func(b *testing.B) {\n\t\t\trespPipeline(b, bench.stub)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"RespTxPipeline-%s\", bench.name), func(b *testing.B) {\n\t\t\trespTxPipeline(b, bench.stub)\n\t\t})\n\n\t\t// goroutine\n\t\tb.Run(fmt.Sprintf(\"DynamicGoroutine-%s-pool=5\", bench.name), func(b *testing.B) {\n\t\t\tdynamicGoroutine(b, bench.stub, 5)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"DynamicGoroutine-%s-pool=20\", bench.name), func(b *testing.B) {\n\t\t\tdynamicGoroutine(b, bench.stub, 20)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"DynamicGoroutine-%s-pool=50\", bench.name), func(b *testing.B) {\n\t\t\tdynamicGoroutine(b, bench.stub, 50)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"DynamicGoroutine-%s-pool=100\", bench.name), func(b *testing.B) {\n\t\t\tdynamicGoroutine(b, bench.stub, 100)\n\t\t})\n\n\t\tb.Run(fmt.Sprintf(\"StaticGoroutine-%s-pool=5\", bench.name), func(b *testing.B) {\n\t\t\tstaticGoroutine(b, bench.stub, 5)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"StaticGoroutine-%s-pool=20\", bench.name), func(b *testing.B) {\n\t\t\tstaticGoroutine(b, bench.stub, 20)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"StaticGoroutine-%s-pool=50\", bench.name), func(b *testing.B) {\n\t\t\tstaticGoroutine(b, bench.stub, 50)\n\t\t})\n\t\tb.Run(fmt.Sprintf(\"StaticGoroutine-%s-pool=100\", bench.name), func(b *testing.B) {\n\t\t\tstaticGoroutine(b, bench.stub, 100)\n\t\t})\n\t}\n}\n\nfunc respError(b *testing.B, stub ClientStubFunc) {\n\trdb := stub([]byte(\"-ERR test error\\r\\n\"))\n\trespErr := proto.RedisError(\"ERR test error\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := rdb.Get(ctx, \"key\").Err(); err != respErr {\n\t\t\tb.Fatalf(\"response error, got %q, want %q\", err, respErr)\n\t\t}\n\t}\n}\n\nfunc respStatus(b *testing.B, stub ClientStubFunc) {\n\trdb := stub([]byte(\"+OK\\r\\n\"))\n\tvar val string\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif val = rdb.Set(ctx, \"key\", \"value\", 0).Val(); val != \"OK\" {\n\t\t\tb.Fatalf(\"response error, got %q, want OK\", val)\n\t\t}\n\t}\n}\n\nfunc respInt(b *testing.B, stub ClientStubFunc) {\n\trdb := stub([]byte(\":10\\r\\n\"))\n\tvar val int64\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif val = rdb.Incr(ctx, \"key\").Val(); val != 10 {\n\t\t\tb.Fatalf(\"response error, got %q, want 10\", val)\n\t\t}\n\t}\n}\n\nfunc respString(b *testing.B, stub ClientStubFunc) {\n\trdb := stub([]byte(\"$5\\r\\nhello\\r\\n\"))\n\tvar val string\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif val = rdb.Get(ctx, \"key\").Val(); val != \"hello\" {\n\t\t\tb.Fatalf(\"response error, got %q, want hello\", val)\n\t\t}\n\t}\n}\n\nfunc respArray(b *testing.B, stub ClientStubFunc) {\n\trdb := stub([]byte(\"*3\\r\\n$5\\r\\nhello\\r\\n:10\\r\\n+OK\\r\\n\"))\n\tvar val []interface{}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif val = rdb.MGet(ctx, \"key\").Val(); len(val) != 3 {\n\t\t\tb.Fatalf(\"response error, got len(%d), want len(3)\", len(val))\n\t\t}\n\t}\n}\n\nfunc respPipeline(b *testing.B, stub ClientStubFunc) {\n\trdb := stub([]byte(\"+OK\\r\\n$5\\r\\nhello\\r\\n:1\\r\\n\"))\n\tvar pipe Pipeliner\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tpipe = rdb.Pipeline()\n\t\tset := pipe.Set(ctx, \"key\", \"value\", 0)\n\t\tget := pipe.Get(ctx, \"key\")\n\t\tdel := pipe.Del(ctx, \"key\")\n\t\t_, err := pipe.Exec(ctx)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"response error, got %q, want nil\", err)\n\t\t}\n\t\tif set.Val() != \"OK\" || get.Val() != \"hello\" || del.Val() != 1 {\n\t\t\tb.Fatal(\"response error\")\n\t\t}\n\t}\n}\n\nfunc respTxPipeline(b *testing.B, stub ClientStubFunc) {\n\trdb := stub([]byte(\"+OK\\r\\n+QUEUED\\r\\n+QUEUED\\r\\n+QUEUED\\r\\n*3\\r\\n+OK\\r\\n$5\\r\\nhello\\r\\n:1\\r\\n\"))\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvar set *StatusCmd\n\t\tvar get *StringCmd\n\t\tvar del *IntCmd\n\t\t_, err := rdb.TxPipelined(ctx, func(pipe Pipeliner) error {\n\t\t\tset = pipe.Set(ctx, \"key\", \"value\", 0)\n\t\t\tget = pipe.Get(ctx, \"key\")\n\t\t\tdel = pipe.Del(ctx, \"key\")\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"response error, got %q, want nil\", err)\n\t\t}\n\t\tif set.Val() != \"OK\" || get.Val() != \"hello\" || del.Val() != 1 {\n\t\t\tb.Fatal(\"response error\")\n\t\t}\n\t}\n}\n\nfunc dynamicGoroutine(b *testing.B, stub ClientStubFunc, concurrency int) {\n\trdb := stub([]byte(\"$5\\r\\nhello\\r\\n\"))\n\tc := make(chan struct{}, concurrency)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tc <- struct{}{}\n\t\tgo func() {\n\t\t\tif val := rdb.Get(ctx, \"key\").Val(); val != \"hello\" {\n\t\t\t\tpanic(fmt.Sprintf(\"response error, got %q, want hello\", val))\n\t\t\t}\n\t\t\t<-c\n\t\t}()\n\t}\n\t// Here no longer wait for all goroutines to complete, it will not affect the test results.\n\tclose(c)\n}\n\nfunc staticGoroutine(b *testing.B, stub ClientStubFunc, concurrency int) {\n\trdb := stub([]byte(\"$5\\r\\nhello\\r\\n\"))\n\tc := make(chan struct{}, concurrency)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t_, ok := <-c\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif val := rdb.Get(ctx, \"key\").Val(); val != \"hello\" {\n\t\t\t\t\tpanic(fmt.Sprintf(\"response error, got %q, want hello\", val))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\tfor i := 0; i < b.N; i++ {\n\t\tc <- struct{}{}\n\t}\n\tclose(c)\n}\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 8.6337890625,
          "content": "package redis_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nfunc benchmarkRedisClient(ctx context.Context, poolSize int) *redis.Client {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:         \":6379\",\n\t\tDialTimeout:  time.Second,\n\t\tReadTimeout:  time.Second,\n\t\tWriteTimeout: time.Second,\n\t\tPoolSize:     poolSize,\n\t})\n\tif err := client.FlushDB(ctx).Err(); err != nil {\n\t\tpanic(err)\n\t}\n\treturn client\n}\n\nfunc BenchmarkRedisPing(b *testing.B) {\n\tctx := context.Background()\n\trdb := benchmarkRedisClient(ctx, 10)\n\tdefer rdb.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tif err := rdb.Ping(ctx).Err(); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkSetGoroutines(b *testing.B) {\n\tctx := context.Background()\n\trdb := benchmarkRedisClient(ctx, 10)\n\tdefer rdb.Close()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tvar wg sync.WaitGroup\n\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\terr := rdb.Set(ctx, \"hello\", \"world\", 0).Err()\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t}\n\n\t\twg.Wait()\n\t}\n}\n\nfunc BenchmarkRedisGetNil(b *testing.B) {\n\tctx := context.Background()\n\tclient := benchmarkRedisClient(ctx, 10)\n\tdefer client.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tif err := client.Get(ctx, \"key\").Err(); err != redis.Nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\ntype setStringBenchmark struct {\n\tpoolSize  int\n\tvalueSize int\n}\n\nfunc (bm setStringBenchmark) String() string {\n\treturn fmt.Sprintf(\"pool=%d value=%d\", bm.poolSize, bm.valueSize)\n}\n\nfunc BenchmarkRedisSetString(b *testing.B) {\n\tbenchmarks := []setStringBenchmark{\n\t\t{10, 64},\n\t\t{10, 1024},\n\t\t{10, 64 * 1024},\n\t\t{10, 1024 * 1024},\n\t\t{10, 10 * 1024 * 1024},\n\n\t\t{100, 64},\n\t\t{100, 1024},\n\t\t{100, 64 * 1024},\n\t\t{100, 1024 * 1024},\n\t\t{100, 10 * 1024 * 1024},\n\t}\n\tfor _, bm := range benchmarks {\n\t\tb.Run(bm.String(), func(b *testing.B) {\n\t\t\tctx := context.Background()\n\t\t\tclient := benchmarkRedisClient(ctx, bm.poolSize)\n\t\t\tdefer client.Close()\n\n\t\t\tvalue := strings.Repeat(\"1\", bm.valueSize)\n\n\t\t\tb.ResetTimer()\n\n\t\t\tb.RunParallel(func(pb *testing.PB) {\n\t\t\t\tfor pb.Next() {\n\t\t\t\t\terr := client.Set(ctx, \"key\", value, 0).Err()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tb.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc BenchmarkRedisSetGetBytes(b *testing.B) {\n\tctx := context.Background()\n\tclient := benchmarkRedisClient(ctx, 10)\n\tdefer client.Close()\n\n\tvalue := bytes.Repeat([]byte{'1'}, 10000)\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tif err := client.Set(ctx, \"key\", value, 0).Err(); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\n\t\t\tgot, err := client.Get(ctx, \"key\").Bytes()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif !bytes.Equal(got, value) {\n\t\t\t\tb.Fatalf(\"got != value\")\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkRedisMGet(b *testing.B) {\n\tctx := context.Background()\n\tclient := benchmarkRedisClient(ctx, 10)\n\tdefer client.Close()\n\n\tif err := client.MSet(ctx, \"key1\", \"hello1\", \"key2\", \"hello2\").Err(); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tif err := client.MGet(ctx, \"key1\", \"key2\").Err(); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkSetExpire(b *testing.B) {\n\tctx := context.Background()\n\tclient := benchmarkRedisClient(ctx, 10)\n\tdefer client.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tif err := client.Set(ctx, \"key\", \"hello\", 0).Err(); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tif err := client.Expire(ctx, \"key\", time.Second).Err(); err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkPipeline(b *testing.B) {\n\tctx := context.Background()\n\tclient := benchmarkRedisClient(ctx, 10)\n\tdefer client.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Set(ctx, \"key\", \"hello\", 0)\n\t\t\t\tpipe.Expire(ctx, \"key\", time.Second)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkZAdd(b *testing.B) {\n\tctx := context.Background()\n\tclient := benchmarkRedisClient(ctx, 10)\n\tdefer client.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\terr := client.ZAdd(ctx, \"key\", redis.Z{\n\t\t\t\tScore:  float64(1),\n\t\t\t\tMember: \"hello\",\n\t\t\t}).Err()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkXRead(b *testing.B) {\n\tctx := context.Background()\n\tclient := benchmarkRedisClient(ctx, 10)\n\tdefer client.Close()\n\n\targs := redis.XAddArgs{\n\t\tStream: \"1\",\n\t\tID:     \"*\",\n\t\tValues: map[string]string{\"uno\": \"dos\"},\n\t}\n\n\tlenStreams := 16\n\tstreams := make([]string, 0, lenStreams)\n\tfor i := 0; i < lenStreams; i++ {\n\t\tstreams = append(streams, strconv.Itoa(i))\n\t}\n\tfor i := 0; i < lenStreams; i++ {\n\t\tstreams = append(streams, \"0\")\n\t}\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\tclient.XAdd(ctx, &args)\n\n\t\t\terr := client.XRead(ctx, &redis.XReadArgs{\n\t\t\t\tStreams: streams,\n\t\t\t\tCount:   1,\n\t\t\t\tBlock:   time.Second,\n\t\t\t}).Err()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\n//------------------------------------------------------------------------------\n\nfunc newClusterScenario() *clusterScenario {\n\treturn &clusterScenario{\n\t\tports:     []string{\"8220\", \"8221\", \"8222\", \"8223\", \"8224\", \"8225\"},\n\t\tnodeIDs:   make([]string, 6),\n\t\tprocesses: make(map[string]*redisProcess, 6),\n\t\tclients:   make(map[string]*redis.Client, 6),\n\t}\n}\n\nfunc BenchmarkClusterPing(b *testing.B) {\n\tif testing.Short() {\n\t\tb.Skip(\"skipping in short mode\")\n\t}\n\n\tctx := context.Background()\n\tcluster := newClusterScenario()\n\tif err := startCluster(ctx, cluster); err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer cluster.Close()\n\n\tclient := cluster.newClusterClient(ctx, redisClusterOptions())\n\tdefer client.Close()\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\terr := client.Ping(ctx).Err()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkClusterDoInt(b *testing.B) {\n\tif testing.Short() {\n\t\tb.Skip(\"skipping in short mode\")\n\t}\n\n\tctx := context.Background()\n\tcluster := newClusterScenario()\n\tif err := startCluster(ctx, cluster); err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer cluster.Close()\n\n\tclient := cluster.newClusterClient(ctx, redisClusterOptions())\n\tdefer client.Close()\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\terr := client.Do(ctx, \"SET\", 10, 10).Err()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkClusterSetString(b *testing.B) {\n\tif testing.Short() {\n\t\tb.Skip(\"skipping in short mode\")\n\t}\n\n\tctx := context.Background()\n\tcluster := newClusterScenario()\n\tif err := startCluster(ctx, cluster); err != nil {\n\t\tb.Fatal(err)\n\t}\n\tdefer cluster.Close()\n\n\tclient := cluster.newClusterClient(ctx, redisClusterOptions())\n\tdefer client.Close()\n\n\tvalue := string(bytes.Repeat([]byte{'1'}, 10000))\n\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\terr := client.Set(ctx, \"key\", value, 0).Err()\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkExecRingSetAddrsCmd(b *testing.B) {\n\tconst (\n\t\tringShard1Name = \"ringShardOne\"\n\t\tringShard2Name = \"ringShardTwo\"\n\t)\n\n\tfor _, port := range []string{ringShard1Port, ringShard2Port} {\n\t\tif _, err := startRedis(port); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n\n\tb.Cleanup(func() {\n\t\tfor _, p := range processes {\n\t\t\tif err := p.Close(); err != nil {\n\t\t\t\tb.Errorf(\"Failed to stop redis process: %v\", err)\n\t\t\t}\n\t\t}\n\t\tprocesses = nil\n\t})\n\n\tring := redis.NewRing(&redis.RingOptions{\n\t\tAddrs: map[string]string{\n\t\t\t\"ringShardOne\": \":\" + ringShard1Port,\n\t\t},\n\t\tNewClient: func(opt *redis.Options) *redis.Client {\n\t\t\t// Simulate slow shard creation\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\treturn redis.NewClient(opt)\n\t\t},\n\t})\n\tdefer ring.Close()\n\n\tif _, err := ring.Ping(context.Background()).Result(); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\t// Continuously update addresses by adding and removing one address\n\tupdatesDone := make(chan struct{})\n\tdefer func() { close(updatesDone) }()\n\tgo func() {\n\t\tticker := time.NewTicker(10 * time.Millisecond)\n\t\tdefer ticker.Stop()\n\t\tfor i := 0; ; i++ {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\tif i%2 == 0 {\n\t\t\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\t\t\tringShard1Name: \":\" + ringShard1Port,\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\t\t\tringShard1Name: \":\" + ringShard1Port,\n\t\t\t\t\t\tringShard2Name: \":\" + ringShard2Port,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\tcase <-updatesDone:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tif _, err := ring.Ping(context.Background()).Result(); err != nil {\n\t\t\tif err == redis.ErrClosed {\n\t\t\t\t// The shard client could be closed while ping command is in progress\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "bitmap_commands.go",
          "type": "blob",
          "size": 5.109375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"errors\"\n)\n\ntype BitMapCmdable interface {\n\tGetBit(ctx context.Context, key string, offset int64) *IntCmd\n\tSetBit(ctx context.Context, key string, offset int64, value int) *IntCmd\n\tBitCount(ctx context.Context, key string, bitCount *BitCount) *IntCmd\n\tBitOpAnd(ctx context.Context, destKey string, keys ...string) *IntCmd\n\tBitOpOr(ctx context.Context, destKey string, keys ...string) *IntCmd\n\tBitOpXor(ctx context.Context, destKey string, keys ...string) *IntCmd\n\tBitOpNot(ctx context.Context, destKey string, key string) *IntCmd\n\tBitPos(ctx context.Context, key string, bit int64, pos ...int64) *IntCmd\n\tBitPosSpan(ctx context.Context, key string, bit int8, start, end int64, span string) *IntCmd\n\tBitField(ctx context.Context, key string, values ...interface{}) *IntSliceCmd\n\tBitFieldRO(ctx context.Context, key string, values ...interface{}) *IntSliceCmd\n}\n\nfunc (c cmdable) GetBit(ctx context.Context, key string, offset int64) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"getbit\", key, offset)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SetBit(ctx context.Context, key string, offset int64, value int) *IntCmd {\n\tcmd := NewIntCmd(\n\t\tctx,\n\t\t\"setbit\",\n\t\tkey,\n\t\toffset,\n\t\tvalue,\n\t)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype BitCount struct {\n\tStart, End int64\n\tUnit       string // BYTE(default) | BIT\n}\n\nconst BitCountIndexByte string = \"BYTE\"\nconst BitCountIndexBit string = \"BIT\"\n\nfunc (c cmdable) BitCount(ctx context.Context, key string, bitCount *BitCount) *IntCmd {\n\targs := make([]any, 2, 5)\n\targs[0] = \"bitcount\"\n\targs[1] = key\n\tif bitCount != nil {\n\t\targs = append(args, bitCount.Start, bitCount.End)\n\t\tif bitCount.Unit != \"\" {\n\t\t\tif bitCount.Unit != BitCountIndexByte && bitCount.Unit != BitCountIndexBit {\n\t\t\t\tcmd := NewIntCmd(ctx)\n\t\t\t\tcmd.SetErr(errors.New(\"redis: invalid bitcount index\"))\n\t\t\t\treturn cmd\n\t\t\t}\n\t\t\targs = append(args, bitCount.Unit)\n\t\t}\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) bitOp(ctx context.Context, op, destKey string, keys ...string) *IntCmd {\n\targs := make([]interface{}, 3+len(keys))\n\targs[0] = \"bitop\"\n\targs[1] = op\n\targs[2] = destKey\n\tfor i, key := range keys {\n\t\targs[3+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) BitOpAnd(ctx context.Context, destKey string, keys ...string) *IntCmd {\n\treturn c.bitOp(ctx, \"and\", destKey, keys...)\n}\n\nfunc (c cmdable) BitOpOr(ctx context.Context, destKey string, keys ...string) *IntCmd {\n\treturn c.bitOp(ctx, \"or\", destKey, keys...)\n}\n\nfunc (c cmdable) BitOpXor(ctx context.Context, destKey string, keys ...string) *IntCmd {\n\treturn c.bitOp(ctx, \"xor\", destKey, keys...)\n}\n\nfunc (c cmdable) BitOpNot(ctx context.Context, destKey string, key string) *IntCmd {\n\treturn c.bitOp(ctx, \"not\", destKey, key)\n}\n\n// BitPos is an API before Redis version 7.0, cmd: bitpos key bit start end\n// if you need the `byte | bit` parameter, please use `BitPosSpan`.\nfunc (c cmdable) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *IntCmd {\n\targs := make([]interface{}, 3+len(pos))\n\targs[0] = \"bitpos\"\n\targs[1] = key\n\targs[2] = bit\n\tswitch len(pos) {\n\tcase 0:\n\tcase 1:\n\t\targs[3] = pos[0]\n\tcase 2:\n\t\targs[3] = pos[0]\n\t\targs[4] = pos[1]\n\tdefault:\n\t\tpanic(\"too many arguments\")\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BitPosSpan supports the `byte | bit` parameters in redis version 7.0,\n// the bitpos command defaults to using byte type for the `start-end` range,\n// which means it counts in bytes from start to end. you can set the value\n// of \"span\" to determine the type of `start-end`.\n// span = \"bit\", cmd: bitpos key bit start end bit\n// span = \"byte\", cmd: bitpos key bit start end byte\nfunc (c cmdable) BitPosSpan(ctx context.Context, key string, bit int8, start, end int64, span string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"bitpos\", key, bit, start, end, span)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BitField accepts multiple values:\n//   - BitField(\"set\", \"i1\", \"offset1\", \"value1\",\"cmd2\", \"type2\", \"offset2\", \"value2\")\n//   - BitField([]string{\"cmd1\", \"type1\", \"offset1\", \"value1\",\"cmd2\", \"type2\", \"offset2\", \"value2\"})\n//   - BitField([]interface{}{\"cmd1\", \"type1\", \"offset1\", \"value1\",\"cmd2\", \"type2\", \"offset2\", \"value2\"})\nfunc (c cmdable) BitField(ctx context.Context, key string, values ...interface{}) *IntSliceCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"bitfield\"\n\targs[1] = key\n\targs = appendArgs(args, values)\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BitFieldRO - Read-only variant of the BITFIELD command.\n// It is like the original BITFIELD but only accepts GET subcommand and can safely be used in read-only replicas.\n// - BitFieldRO(ctx, key, \"<Encoding0>\", \"<Offset0>\", \"<Encoding1>\",\"<Offset1>\")\nfunc (c cmdable) BitFieldRO(ctx context.Context, key string, values ...interface{}) *IntSliceCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"BITFIELD_RO\"\n\targs[1] = key\n\tif len(values)%2 != 0 {\n\t\tpanic(\"BitFieldRO: invalid number of arguments, must be even\")\n\t}\n\tfor i := 0; i < len(values); i += 2 {\n\t\targs = append(args, \"GET\", values[i], values[i+1])\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "bitmap_commands_test.go",
          "type": "blob",
          "size": 2.203125,
          "content": "package redis_test\n\nimport (\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\t\"github.com/redis/go-redis/v9\"\n)\n\ntype bitCountExpected struct {\n\tStart    int64\n\tEnd      int64\n\tExpected int64\n}\n\nvar _ = Describe(\"BitCountBite\", func() {\n\tvar client *redis.Client\n\tkey := \"bit_count_test\"\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t\tvalues := []int{0, 1, 0, 0, 1, 0, 1, 0, 1, 1}\n\t\tfor i, v := range values {\n\t\t\tcmd := client.SetBit(ctx, key, int64(i), v)\n\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"bit count bite\", func() {\n\t\tvar expected = []bitCountExpected{\n\t\t\t{0, 0, 0},\n\t\t\t{0, 1, 1},\n\t\t\t{0, 2, 1},\n\t\t\t{0, 3, 1},\n\t\t\t{0, 4, 2},\n\t\t\t{0, 5, 2},\n\t\t\t{0, 6, 3},\n\t\t\t{0, 7, 3},\n\t\t\t{0, 8, 4},\n\t\t\t{0, 9, 5},\n\t\t}\n\n\t\tfor _, e := range expected {\n\t\t\tcmd := client.BitCount(ctx, key, &redis.BitCount{Start: e.Start, End: e.End, Unit: redis.BitCountIndexBit})\n\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(cmd.Val()).To(Equal(e.Expected))\n\t\t}\n\t})\n})\n\nvar _ = Describe(\"BitCountByte\", func() {\n\tvar client *redis.Client\n\tkey := \"bit_count_test\"\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t\tvalues := []int{0, 0, 0, 0, 0, 0, 0, 1, 1, 1}\n\t\tfor i, v := range values {\n\t\t\tcmd := client.SetBit(ctx, key, int64(i), v)\n\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"bit count byte\", func() {\n\t\tvar expected = []bitCountExpected{\n\t\t\t{0, 0, 1},\n\t\t\t{0, 1, 3},\n\t\t}\n\n\t\tfor _, e := range expected {\n\t\t\tcmd := client.BitCount(ctx, key, &redis.BitCount{Start: e.Start, End: e.End, Unit: redis.BitCountIndexByte})\n\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(cmd.Val()).To(Equal(e.Expected))\n\t\t}\n\t})\n\n\tIt(\"bit count byte with no unit specified\", func() {\n\t\tvar expected = []bitCountExpected{\n\t\t\t{0, 0, 1},\n\t\t\t{0, 1, 3},\n\t\t}\n\n\t\tfor _, e := range expected {\n\t\t\tcmd := client.BitCount(ctx, key, &redis.BitCount{Start: e.Start, End: e.End})\n\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(cmd.Val()).To(Equal(e.Expected))\n\t\t}\n\t})\n})\n"
        },
        {
          "name": "cluster_commands.go",
          "type": "blob",
          "size": 5.5244140625,
          "content": "package redis\n\nimport \"context\"\n\ntype ClusterCmdable interface {\n\tClusterMyShardID(ctx context.Context) *StringCmd\n\tClusterSlots(ctx context.Context) *ClusterSlotsCmd\n\tClusterShards(ctx context.Context) *ClusterShardsCmd\n\tClusterLinks(ctx context.Context) *ClusterLinksCmd\n\tClusterNodes(ctx context.Context) *StringCmd\n\tClusterMeet(ctx context.Context, host, port string) *StatusCmd\n\tClusterForget(ctx context.Context, nodeID string) *StatusCmd\n\tClusterReplicate(ctx context.Context, nodeID string) *StatusCmd\n\tClusterResetSoft(ctx context.Context) *StatusCmd\n\tClusterResetHard(ctx context.Context) *StatusCmd\n\tClusterInfo(ctx context.Context) *StringCmd\n\tClusterKeySlot(ctx context.Context, key string) *IntCmd\n\tClusterGetKeysInSlot(ctx context.Context, slot int, count int) *StringSliceCmd\n\tClusterCountFailureReports(ctx context.Context, nodeID string) *IntCmd\n\tClusterCountKeysInSlot(ctx context.Context, slot int) *IntCmd\n\tClusterDelSlots(ctx context.Context, slots ...int) *StatusCmd\n\tClusterDelSlotsRange(ctx context.Context, min, max int) *StatusCmd\n\tClusterSaveConfig(ctx context.Context) *StatusCmd\n\tClusterSlaves(ctx context.Context, nodeID string) *StringSliceCmd\n\tClusterFailover(ctx context.Context) *StatusCmd\n\tClusterAddSlots(ctx context.Context, slots ...int) *StatusCmd\n\tClusterAddSlotsRange(ctx context.Context, min, max int) *StatusCmd\n\tReadOnly(ctx context.Context) *StatusCmd\n\tReadWrite(ctx context.Context) *StatusCmd\n}\n\nfunc (c cmdable) ClusterMyShardID(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"cluster\", \"myshardid\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterSlots(ctx context.Context) *ClusterSlotsCmd {\n\tcmd := NewClusterSlotsCmd(ctx, \"cluster\", \"slots\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterShards(ctx context.Context) *ClusterShardsCmd {\n\tcmd := NewClusterShardsCmd(ctx, \"cluster\", \"shards\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterLinks(ctx context.Context) *ClusterLinksCmd {\n\tcmd := NewClusterLinksCmd(ctx, \"cluster\", \"links\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterNodes(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"cluster\", \"nodes\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterMeet(ctx context.Context, host, port string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"cluster\", \"meet\", host, port)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterForget(ctx context.Context, nodeID string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"cluster\", \"forget\", nodeID)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterReplicate(ctx context.Context, nodeID string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"cluster\", \"replicate\", nodeID)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterResetSoft(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"cluster\", \"reset\", \"soft\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterResetHard(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"cluster\", \"reset\", \"hard\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterInfo(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"cluster\", \"info\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterKeySlot(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"cluster\", \"keyslot\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"cluster\", \"getkeysinslot\", slot, count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterCountFailureReports(ctx context.Context, nodeID string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"cluster\", \"count-failure-reports\", nodeID)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterCountKeysInSlot(ctx context.Context, slot int) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"cluster\", \"countkeysinslot\", slot)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterDelSlots(ctx context.Context, slots ...int) *StatusCmd {\n\targs := make([]interface{}, 2+len(slots))\n\targs[0] = \"cluster\"\n\targs[1] = \"delslots\"\n\tfor i, slot := range slots {\n\t\targs[2+i] = slot\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterDelSlotsRange(ctx context.Context, min, max int) *StatusCmd {\n\tsize := max - min + 1\n\tslots := make([]int, size)\n\tfor i := 0; i < size; i++ {\n\t\tslots[i] = min + i\n\t}\n\treturn c.ClusterDelSlots(ctx, slots...)\n}\n\nfunc (c cmdable) ClusterSaveConfig(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"cluster\", \"saveconfig\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterSlaves(ctx context.Context, nodeID string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"cluster\", \"slaves\", nodeID)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterFailover(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"cluster\", \"failover\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterAddSlots(ctx context.Context, slots ...int) *StatusCmd {\n\targs := make([]interface{}, 2+len(slots))\n\targs[0] = \"cluster\"\n\targs[1] = \"addslots\"\n\tfor i, num := range slots {\n\t\targs[2+i] = num\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClusterAddSlotsRange(ctx context.Context, min, max int) *StatusCmd {\n\tsize := max - min + 1\n\tslots := make([]int, size)\n\tfor i := 0; i < size; i++ {\n\t\tslots[i] = min + i\n\t}\n\treturn c.ClusterAddSlots(ctx, slots...)\n}\n\nfunc (c cmdable) ReadOnly(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"readonly\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ReadWrite(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"readwrite\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "command.go",
          "type": "blob",
          "size": 112.6591796875,
          "content": "package redis\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/hscan\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n\t\"github.com/redis/go-redis/v9/internal/util\"\n)\n\ntype Cmder interface {\n\t// command name.\n\t// e.g. \"set k v ex 10\" -> \"set\", \"cluster info\" -> \"cluster\".\n\tName() string\n\n\t// full command name.\n\t// e.g. \"set k v ex 10\" -> \"set\", \"cluster info\" -> \"cluster info\".\n\tFullName() string\n\n\t// all args of the command.\n\t// e.g. \"set k v ex 10\" -> \"[set k v ex 10]\".\n\tArgs() []interface{}\n\n\t// format request and response string.\n\t// e.g. \"set k v ex 10\" -> \"set k v ex 10: OK\", \"get k\" -> \"get k: v\".\n\tString() string\n\n\tstringArg(int) string\n\tfirstKeyPos() int8\n\tSetFirstKeyPos(int8)\n\n\treadTimeout() *time.Duration\n\treadReply(rd *proto.Reader) error\n\treadRawReply(rd *proto.Reader) error\n\tSetErr(error)\n\tErr() error\n}\n\nfunc setCmdsErr(cmds []Cmder, e error) {\n\tfor _, cmd := range cmds {\n\t\tif cmd.Err() == nil {\n\t\t\tcmd.SetErr(e)\n\t\t}\n\t}\n}\n\nfunc cmdsFirstErr(cmds []Cmder) error {\n\tfor _, cmd := range cmds {\n\t\tif err := cmd.Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc writeCmds(wr *proto.Writer, cmds []Cmder) error {\n\tfor _, cmd := range cmds {\n\t\tif err := writeCmd(wr, cmd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc writeCmd(wr *proto.Writer, cmd Cmder) error {\n\treturn wr.WriteArgs(cmd.Args())\n}\n\nfunc cmdFirstKeyPos(cmd Cmder) int {\n\tif pos := cmd.firstKeyPos(); pos != 0 {\n\t\treturn int(pos)\n\t}\n\n\tswitch cmd.Name() {\n\tcase \"eval\", \"evalsha\", \"eval_ro\", \"evalsha_ro\":\n\t\tif cmd.stringArg(2) != \"0\" {\n\t\t\treturn 3\n\t\t}\n\n\t\treturn 0\n\tcase \"publish\":\n\t\treturn 1\n\tcase \"memory\":\n\t\t// https://github.com/redis/redis/issues/7493\n\t\tif cmd.stringArg(1) == \"usage\" {\n\t\t\treturn 2\n\t\t}\n\t}\n\treturn 1\n}\n\nfunc cmdString(cmd Cmder, val interface{}) string {\n\tb := make([]byte, 0, 64)\n\n\tfor i, arg := range cmd.Args() {\n\t\tif i > 0 {\n\t\t\tb = append(b, ' ')\n\t\t}\n\t\tb = internal.AppendArg(b, arg)\n\t}\n\n\tif err := cmd.Err(); err != nil {\n\t\tb = append(b, \": \"...)\n\t\tb = append(b, err.Error()...)\n\t} else if val != nil {\n\t\tb = append(b, \": \"...)\n\t\tb = internal.AppendArg(b, val)\n\t}\n\n\treturn util.BytesToString(b)\n}\n\n//------------------------------------------------------------------------------\n\ntype baseCmd struct {\n\tctx          context.Context\n\targs         []interface{}\n\terr          error\n\tkeyPos       int8\n\trawVal       interface{}\n\t_readTimeout *time.Duration\n}\n\nvar _ Cmder = (*Cmd)(nil)\n\nfunc (cmd *baseCmd) Name() string {\n\tif len(cmd.args) == 0 {\n\t\treturn \"\"\n\t}\n\t// Cmd name must be lower cased.\n\treturn internal.ToLower(cmd.stringArg(0))\n}\n\nfunc (cmd *baseCmd) FullName() string {\n\tswitch name := cmd.Name(); name {\n\tcase \"cluster\", \"command\":\n\t\tif len(cmd.args) == 1 {\n\t\t\treturn name\n\t\t}\n\t\tif s2, ok := cmd.args[1].(string); ok {\n\t\t\treturn name + \" \" + s2\n\t\t}\n\t\treturn name\n\tdefault:\n\t\treturn name\n\t}\n}\n\nfunc (cmd *baseCmd) Args() []interface{} {\n\treturn cmd.args\n}\n\nfunc (cmd *baseCmd) stringArg(pos int) string {\n\tif pos < 0 || pos >= len(cmd.args) {\n\t\treturn \"\"\n\t}\n\targ := cmd.args[pos]\n\tswitch v := arg.(type) {\n\tcase string:\n\t\treturn v\n\tcase []byte:\n\t\treturn string(v)\n\tdefault:\n\t\t// TODO: consider using appendArg\n\t\treturn fmt.Sprint(v)\n\t}\n}\n\nfunc (cmd *baseCmd) firstKeyPos() int8 {\n\treturn cmd.keyPos\n}\n\nfunc (cmd *baseCmd) SetFirstKeyPos(keyPos int8) {\n\tcmd.keyPos = keyPos\n}\n\nfunc (cmd *baseCmd) SetErr(e error) {\n\tcmd.err = e\n}\n\nfunc (cmd *baseCmd) Err() error {\n\treturn cmd.err\n}\n\nfunc (cmd *baseCmd) readTimeout() *time.Duration {\n\treturn cmd._readTimeout\n}\n\nfunc (cmd *baseCmd) setReadTimeout(d time.Duration) {\n\tcmd._readTimeout = &d\n}\n\nfunc (cmd *baseCmd) readRawReply(rd *proto.Reader) (err error) {\n\tcmd.rawVal, err = rd.ReadReply()\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype Cmd struct {\n\tbaseCmd\n\n\tval interface{}\n}\n\nfunc NewCmd(ctx context.Context, args ...interface{}) *Cmd {\n\treturn &Cmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *Cmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *Cmd) SetVal(val interface{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *Cmd) Val() interface{} {\n\treturn cmd.val\n}\n\nfunc (cmd *Cmd) Result() (interface{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *Cmd) Text() (string, error) {\n\tif cmd.err != nil {\n\t\treturn \"\", cmd.err\n\t}\n\treturn toString(cmd.val)\n}\n\nfunc toString(val interface{}) (string, error) {\n\tswitch val := val.(type) {\n\tcase string:\n\t\treturn val, nil\n\tdefault:\n\t\terr := fmt.Errorf(\"redis: unexpected type=%T for String\", val)\n\t\treturn \"\", err\n\t}\n}\n\nfunc (cmd *Cmd) Int() (int, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\tswitch val := cmd.val.(type) {\n\tcase int64:\n\t\treturn int(val), nil\n\tcase string:\n\t\treturn strconv.Atoi(val)\n\tdefault:\n\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Int\", val)\n\t\treturn 0, err\n\t}\n}\n\nfunc (cmd *Cmd) Int64() (int64, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn toInt64(cmd.val)\n}\n\nfunc toInt64(val interface{}) (int64, error) {\n\tswitch val := val.(type) {\n\tcase int64:\n\t\treturn val, nil\n\tcase string:\n\t\treturn strconv.ParseInt(val, 10, 64)\n\tdefault:\n\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Int64\", val)\n\t\treturn 0, err\n\t}\n}\n\nfunc (cmd *Cmd) Uint64() (uint64, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn toUint64(cmd.val)\n}\n\nfunc toUint64(val interface{}) (uint64, error) {\n\tswitch val := val.(type) {\n\tcase int64:\n\t\treturn uint64(val), nil\n\tcase string:\n\t\treturn strconv.ParseUint(val, 10, 64)\n\tdefault:\n\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Uint64\", val)\n\t\treturn 0, err\n\t}\n}\n\nfunc (cmd *Cmd) Float32() (float32, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn toFloat32(cmd.val)\n}\n\nfunc toFloat32(val interface{}) (float32, error) {\n\tswitch val := val.(type) {\n\tcase int64:\n\t\treturn float32(val), nil\n\tcase string:\n\t\tf, err := strconv.ParseFloat(val, 32)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn float32(f), nil\n\tdefault:\n\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Float32\", val)\n\t\treturn 0, err\n\t}\n}\n\nfunc (cmd *Cmd) Float64() (float64, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn toFloat64(cmd.val)\n}\n\nfunc toFloat64(val interface{}) (float64, error) {\n\tswitch val := val.(type) {\n\tcase int64:\n\t\treturn float64(val), nil\n\tcase string:\n\t\treturn strconv.ParseFloat(val, 64)\n\tdefault:\n\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Float64\", val)\n\t\treturn 0, err\n\t}\n}\n\nfunc (cmd *Cmd) Bool() (bool, error) {\n\tif cmd.err != nil {\n\t\treturn false, cmd.err\n\t}\n\treturn toBool(cmd.val)\n}\n\nfunc toBool(val interface{}) (bool, error) {\n\tswitch val := val.(type) {\n\tcase bool:\n\t\treturn val, nil\n\tcase int64:\n\t\treturn val != 0, nil\n\tcase string:\n\t\treturn strconv.ParseBool(val)\n\tdefault:\n\t\terr := fmt.Errorf(\"redis: unexpected type=%T for Bool\", val)\n\t\treturn false, err\n\t}\n}\n\nfunc (cmd *Cmd) Slice() ([]interface{}, error) {\n\tif cmd.err != nil {\n\t\treturn nil, cmd.err\n\t}\n\tswitch val := cmd.val.(type) {\n\tcase []interface{}:\n\t\treturn val, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"redis: unexpected type=%T for Slice\", val)\n\t}\n}\n\nfunc (cmd *Cmd) StringSlice() ([]string, error) {\n\tslice, err := cmd.Slice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tss := make([]string, len(slice))\n\tfor i, iface := range slice {\n\t\tval, err := toString(iface)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tss[i] = val\n\t}\n\treturn ss, nil\n}\n\nfunc (cmd *Cmd) Int64Slice() ([]int64, error) {\n\tslice, err := cmd.Slice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnums := make([]int64, len(slice))\n\tfor i, iface := range slice {\n\t\tval, err := toInt64(iface)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnums[i] = val\n\t}\n\treturn nums, nil\n}\n\nfunc (cmd *Cmd) Uint64Slice() ([]uint64, error) {\n\tslice, err := cmd.Slice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnums := make([]uint64, len(slice))\n\tfor i, iface := range slice {\n\t\tval, err := toUint64(iface)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnums[i] = val\n\t}\n\treturn nums, nil\n}\n\nfunc (cmd *Cmd) Float32Slice() ([]float32, error) {\n\tslice, err := cmd.Slice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfloats := make([]float32, len(slice))\n\tfor i, iface := range slice {\n\t\tval, err := toFloat32(iface)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfloats[i] = val\n\t}\n\treturn floats, nil\n}\n\nfunc (cmd *Cmd) Float64Slice() ([]float64, error) {\n\tslice, err := cmd.Slice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfloats := make([]float64, len(slice))\n\tfor i, iface := range slice {\n\t\tval, err := toFloat64(iface)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfloats[i] = val\n\t}\n\treturn floats, nil\n}\n\nfunc (cmd *Cmd) BoolSlice() ([]bool, error) {\n\tslice, err := cmd.Slice()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbools := make([]bool, len(slice))\n\tfor i, iface := range slice {\n\t\tval, err := toBool(iface)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbools[i] = val\n\t}\n\treturn bools, nil\n}\n\nfunc (cmd *Cmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = rd.ReadReply()\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype SliceCmd struct {\n\tbaseCmd\n\n\tval []interface{}\n}\n\nvar _ Cmder = (*SliceCmd)(nil)\n\nfunc NewSliceCmd(ctx context.Context, args ...interface{}) *SliceCmd {\n\treturn &SliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *SliceCmd) SetVal(val []interface{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *SliceCmd) Val() []interface{} {\n\treturn cmd.val\n}\n\nfunc (cmd *SliceCmd) Result() ([]interface{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *SliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\n// Scan scans the results from the map into a destination struct. The map keys\n// are matched in the Redis struct fields by the `redis:\"field\"` tag.\nfunc (cmd *SliceCmd) Scan(dst interface{}) error {\n\tif cmd.err != nil {\n\t\treturn cmd.err\n\t}\n\n\t// Pass the list of keys and values.\n\t// Skip the first two args for: HMGET key\n\tvar args []interface{}\n\tif cmd.args[0] == \"hmget\" {\n\t\targs = cmd.args[2:]\n\t} else {\n\t\t// Otherwise, it's: MGET field field ...\n\t\targs = cmd.args[1:]\n\t}\n\n\treturn hscan.Scan(dst, args, cmd.val)\n}\n\nfunc (cmd *SliceCmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = rd.ReadSlice()\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype StatusCmd struct {\n\tbaseCmd\n\n\tval string\n}\n\nvar _ Cmder = (*StatusCmd)(nil)\n\nfunc NewStatusCmd(ctx context.Context, args ...interface{}) *StatusCmd {\n\treturn &StatusCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *StatusCmd) SetVal(val string) {\n\tcmd.val = val\n}\n\nfunc (cmd *StatusCmd) Val() string {\n\treturn cmd.val\n}\n\nfunc (cmd *StatusCmd) Result() (string, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *StatusCmd) Bytes() ([]byte, error) {\n\treturn util.StringToBytes(cmd.val), cmd.err\n}\n\nfunc (cmd *StatusCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *StatusCmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = rd.ReadString()\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype IntCmd struct {\n\tbaseCmd\n\n\tval int64\n}\n\nvar _ Cmder = (*IntCmd)(nil)\n\nfunc NewIntCmd(ctx context.Context, args ...interface{}) *IntCmd {\n\treturn &IntCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *IntCmd) SetVal(val int64) {\n\tcmd.val = val\n}\n\nfunc (cmd *IntCmd) Val() int64 {\n\treturn cmd.val\n}\n\nfunc (cmd *IntCmd) Result() (int64, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *IntCmd) Uint64() (uint64, error) {\n\treturn uint64(cmd.val), cmd.err\n}\n\nfunc (cmd *IntCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *IntCmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = rd.ReadInt()\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype IntSliceCmd struct {\n\tbaseCmd\n\n\tval []int64\n}\n\nvar _ Cmder = (*IntSliceCmd)(nil)\n\nfunc NewIntSliceCmd(ctx context.Context, args ...interface{}) *IntSliceCmd {\n\treturn &IntSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *IntSliceCmd) SetVal(val []int64) {\n\tcmd.val = val\n}\n\nfunc (cmd *IntSliceCmd) Val() []int64 {\n\treturn cmd.val\n}\n\nfunc (cmd *IntSliceCmd) Result() ([]int64, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *IntSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *IntSliceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]int64, n)\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tif cmd.val[i], err = rd.ReadInt(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype DurationCmd struct {\n\tbaseCmd\n\n\tval       time.Duration\n\tprecision time.Duration\n}\n\nvar _ Cmder = (*DurationCmd)(nil)\n\nfunc NewDurationCmd(ctx context.Context, precision time.Duration, args ...interface{}) *DurationCmd {\n\treturn &DurationCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t\tprecision: precision,\n\t}\n}\n\nfunc (cmd *DurationCmd) SetVal(val time.Duration) {\n\tcmd.val = val\n}\n\nfunc (cmd *DurationCmd) Val() time.Duration {\n\treturn cmd.val\n}\n\nfunc (cmd *DurationCmd) Result() (time.Duration, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *DurationCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *DurationCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadInt()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch n {\n\t// -2 if the key does not exist\n\t// -1 if the key exists but has no associated expire\n\tcase -2, -1:\n\t\tcmd.val = time.Duration(n)\n\tdefault:\n\t\tcmd.val = time.Duration(n) * cmd.precision\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype TimeCmd struct {\n\tbaseCmd\n\n\tval time.Time\n}\n\nvar _ Cmder = (*TimeCmd)(nil)\n\nfunc NewTimeCmd(ctx context.Context, args ...interface{}) *TimeCmd {\n\treturn &TimeCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *TimeCmd) SetVal(val time.Time) {\n\tcmd.val = val\n}\n\nfunc (cmd *TimeCmd) Val() time.Time {\n\treturn cmd.val\n}\n\nfunc (cmd *TimeCmd) Result() (time.Time, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *TimeCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *TimeCmd) readReply(rd *proto.Reader) error {\n\tif err := rd.ReadFixedArrayLen(2); err != nil {\n\t\treturn err\n\t}\n\tsecond, err := rd.ReadInt()\n\tif err != nil {\n\t\treturn err\n\t}\n\tmicrosecond, err := rd.ReadInt()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = time.Unix(second, microsecond*1000)\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype BoolCmd struct {\n\tbaseCmd\n\n\tval bool\n}\n\nvar _ Cmder = (*BoolCmd)(nil)\n\nfunc NewBoolCmd(ctx context.Context, args ...interface{}) *BoolCmd {\n\treturn &BoolCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *BoolCmd) SetVal(val bool) {\n\tcmd.val = val\n}\n\nfunc (cmd *BoolCmd) Val() bool {\n\treturn cmd.val\n}\n\nfunc (cmd *BoolCmd) Result() (bool, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *BoolCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *BoolCmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = rd.ReadBool()\n\n\t// `SET key value NX` returns nil when key already exists. But\n\t// `SETNX key value` returns bool (0/1). So convert nil to bool.\n\tif err == Nil {\n\t\tcmd.val = false\n\t\terr = nil\n\t}\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype StringCmd struct {\n\tbaseCmd\n\n\tval string\n}\n\nvar _ Cmder = (*StringCmd)(nil)\n\nfunc NewStringCmd(ctx context.Context, args ...interface{}) *StringCmd {\n\treturn &StringCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *StringCmd) SetVal(val string) {\n\tcmd.val = val\n}\n\nfunc (cmd *StringCmd) Val() string {\n\treturn cmd.val\n}\n\nfunc (cmd *StringCmd) Result() (string, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *StringCmd) Bytes() ([]byte, error) {\n\treturn util.StringToBytes(cmd.val), cmd.err\n}\n\nfunc (cmd *StringCmd) Bool() (bool, error) {\n\tif cmd.err != nil {\n\t\treturn false, cmd.err\n\t}\n\treturn strconv.ParseBool(cmd.val)\n}\n\nfunc (cmd *StringCmd) Int() (int, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn strconv.Atoi(cmd.Val())\n}\n\nfunc (cmd *StringCmd) Int64() (int64, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn strconv.ParseInt(cmd.Val(), 10, 64)\n}\n\nfunc (cmd *StringCmd) Uint64() (uint64, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn strconv.ParseUint(cmd.Val(), 10, 64)\n}\n\nfunc (cmd *StringCmd) Float32() (float32, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\tf, err := strconv.ParseFloat(cmd.Val(), 32)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn float32(f), nil\n}\n\nfunc (cmd *StringCmd) Float64() (float64, error) {\n\tif cmd.err != nil {\n\t\treturn 0, cmd.err\n\t}\n\treturn strconv.ParseFloat(cmd.Val(), 64)\n}\n\nfunc (cmd *StringCmd) Time() (time.Time, error) {\n\tif cmd.err != nil {\n\t\treturn time.Time{}, cmd.err\n\t}\n\treturn time.Parse(time.RFC3339Nano, cmd.Val())\n}\n\nfunc (cmd *StringCmd) Scan(val interface{}) error {\n\tif cmd.err != nil {\n\t\treturn cmd.err\n\t}\n\treturn proto.Scan([]byte(cmd.val), val)\n}\n\nfunc (cmd *StringCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *StringCmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = rd.ReadString()\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype FloatCmd struct {\n\tbaseCmd\n\n\tval float64\n}\n\nvar _ Cmder = (*FloatCmd)(nil)\n\nfunc NewFloatCmd(ctx context.Context, args ...interface{}) *FloatCmd {\n\treturn &FloatCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *FloatCmd) SetVal(val float64) {\n\tcmd.val = val\n}\n\nfunc (cmd *FloatCmd) Val() float64 {\n\treturn cmd.val\n}\n\nfunc (cmd *FloatCmd) Result() (float64, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FloatCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FloatCmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = rd.ReadFloat()\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\ntype FloatSliceCmd struct {\n\tbaseCmd\n\n\tval []float64\n}\n\nvar _ Cmder = (*FloatSliceCmd)(nil)\n\nfunc NewFloatSliceCmd(ctx context.Context, args ...interface{}) *FloatSliceCmd {\n\treturn &FloatSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *FloatSliceCmd) SetVal(val []float64) {\n\tcmd.val = val\n}\n\nfunc (cmd *FloatSliceCmd) Val() []float64 {\n\treturn cmd.val\n}\n\nfunc (cmd *FloatSliceCmd) Result() ([]float64, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FloatSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FloatSliceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make([]float64, n)\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tswitch num, err := rd.ReadFloat(); {\n\t\tcase err == Nil:\n\t\t\tcmd.val[i] = 0\n\t\tcase err != nil:\n\t\t\treturn err\n\t\tdefault:\n\t\t\tcmd.val[i] = num\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype StringSliceCmd struct {\n\tbaseCmd\n\n\tval []string\n}\n\nvar _ Cmder = (*StringSliceCmd)(nil)\n\nfunc NewStringSliceCmd(ctx context.Context, args ...interface{}) *StringSliceCmd {\n\treturn &StringSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *StringSliceCmd) SetVal(val []string) {\n\tcmd.val = val\n}\n\nfunc (cmd *StringSliceCmd) Val() []string {\n\treturn cmd.val\n}\n\nfunc (cmd *StringSliceCmd) Result() ([]string, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *StringSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *StringSliceCmd) ScanSlice(container interface{}) error {\n\treturn proto.ScanSlice(cmd.Val(), container)\n}\n\nfunc (cmd *StringSliceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]string, n)\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tswitch s, err := rd.ReadString(); {\n\t\tcase err == Nil:\n\t\t\tcmd.val[i] = \"\"\n\t\tcase err != nil:\n\t\t\treturn err\n\t\tdefault:\n\t\t\tcmd.val[i] = s\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype KeyValue struct {\n\tKey   string\n\tValue string\n}\n\ntype KeyValueSliceCmd struct {\n\tbaseCmd\n\n\tval []KeyValue\n}\n\nvar _ Cmder = (*KeyValueSliceCmd)(nil)\n\nfunc NewKeyValueSliceCmd(ctx context.Context, args ...interface{}) *KeyValueSliceCmd {\n\treturn &KeyValueSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *KeyValueSliceCmd) SetVal(val []KeyValue) {\n\tcmd.val = val\n}\n\nfunc (cmd *KeyValueSliceCmd) Val() []KeyValue {\n\treturn cmd.val\n}\n\nfunc (cmd *KeyValueSliceCmd) Result() ([]KeyValue, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *KeyValueSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\n// Many commands will respond to two formats:\n//  1. 1) \"one\"\n//  2. (double) 1\n//  2. 1) \"two\"\n//  2. (double) 2\n//\n// OR:\n//  1. \"two\"\n//  2. (double) 2\n//  3. \"one\"\n//  4. (double) 1\nfunc (cmd *KeyValueSliceCmd) readReply(rd *proto.Reader) error { // nolint:dupl\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the n is 0, can't continue reading.\n\tif n == 0 {\n\t\tcmd.val = make([]KeyValue, 0)\n\t\treturn nil\n\t}\n\n\ttyp, err := rd.PeekReplyType()\n\tif err != nil {\n\t\treturn err\n\t}\n\tarray := typ == proto.RespArray\n\n\tif array {\n\t\tcmd.val = make([]KeyValue, n)\n\t} else {\n\t\tcmd.val = make([]KeyValue, n/2)\n\t}\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tif array {\n\t\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif cmd.val[i].Key, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cmd.val[i].Value, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype BoolSliceCmd struct {\n\tbaseCmd\n\n\tval []bool\n}\n\nvar _ Cmder = (*BoolSliceCmd)(nil)\n\nfunc NewBoolSliceCmd(ctx context.Context, args ...interface{}) *BoolSliceCmd {\n\treturn &BoolSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *BoolSliceCmd) SetVal(val []bool) {\n\tcmd.val = val\n}\n\nfunc (cmd *BoolSliceCmd) Val() []bool {\n\treturn cmd.val\n}\n\nfunc (cmd *BoolSliceCmd) Result() ([]bool, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *BoolSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *BoolSliceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]bool, n)\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tif cmd.val[i], err = rd.ReadBool(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype MapStringStringCmd struct {\n\tbaseCmd\n\n\tval map[string]string\n}\n\nvar _ Cmder = (*MapStringStringCmd)(nil)\n\nfunc NewMapStringStringCmd(ctx context.Context, args ...interface{}) *MapStringStringCmd {\n\treturn &MapStringStringCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *MapStringStringCmd) Val() map[string]string {\n\treturn cmd.val\n}\n\nfunc (cmd *MapStringStringCmd) SetVal(val map[string]string) {\n\tcmd.val = val\n}\n\nfunc (cmd *MapStringStringCmd) Result() (map[string]string, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *MapStringStringCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\n// Scan scans the results from the map into a destination struct. The map keys\n// are matched in the Redis struct fields by the `redis:\"field\"` tag.\nfunc (cmd *MapStringStringCmd) Scan(dest interface{}) error {\n\tif cmd.err != nil {\n\t\treturn cmd.err\n\t}\n\n\tstrct, err := hscan.Struct(dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor k, v := range cmd.val {\n\t\tif err := strct.Scan(k, v); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (cmd *MapStringStringCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make(map[string]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvalue, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcmd.val[key] = value\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype MapStringIntCmd struct {\n\tbaseCmd\n\n\tval map[string]int64\n}\n\nvar _ Cmder = (*MapStringIntCmd)(nil)\n\nfunc NewMapStringIntCmd(ctx context.Context, args ...interface{}) *MapStringIntCmd {\n\treturn &MapStringIntCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *MapStringIntCmd) SetVal(val map[string]int64) {\n\tcmd.val = val\n}\n\nfunc (cmd *MapStringIntCmd) Val() map[string]int64 {\n\treturn cmd.val\n}\n\nfunc (cmd *MapStringIntCmd) Result() (map[string]int64, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *MapStringIntCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *MapStringIntCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make(map[string]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tnn, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[key] = nn\n\t}\n\treturn nil\n}\n\n// ------------------------------------------------------------------------------\ntype MapStringSliceInterfaceCmd struct {\n\tbaseCmd\n\tval map[string][]interface{}\n}\n\nfunc NewMapStringSliceInterfaceCmd(ctx context.Context, args ...interface{}) *MapStringSliceInterfaceCmd {\n\treturn &MapStringSliceInterfaceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *MapStringSliceInterfaceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *MapStringSliceInterfaceCmd) SetVal(val map[string][]interface{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *MapStringSliceInterfaceCmd) Result() (map[string][]interface{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *MapStringSliceInterfaceCmd) Val() map[string][]interface{} {\n\treturn cmd.val\n}\n\nfunc (cmd *MapStringSliceInterfaceCmd) readReply(rd *proto.Reader) (err error) {\n\treadType, err := rd.PeekReplyType()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make(map[string][]interface{})\n\n\tif readType == proto.RespMap {\n\t\tn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tk, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnn, err := rd.ReadArrayLen()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcmd.val[k] = make([]interface{}, nn)\n\t\t\tfor j := 0; j < nn; j++ {\n\t\t\t\tvalue, err := rd.ReadReply()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcmd.val[k][j] = value\n\t\t\t}\n\t\t}\n\t} else if readType == proto.RespArray {\n\t\t// RESP2 response\n\t\tn, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\t// Each entry in this array is itself an array with key details\n\t\t\titemLen, err := rd.ReadArrayLen()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcmd.val[key] = make([]interface{}, 0, itemLen-1)\n\t\t\tfor j := 1; j < itemLen; j++ {\n\t\t\t\t// Read the inner array for timestamp-value pairs\n\t\t\t\tdata, err := rd.ReadReply()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcmd.val[key] = append(cmd.val[key], data)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype StringStructMapCmd struct {\n\tbaseCmd\n\n\tval map[string]struct{}\n}\n\nvar _ Cmder = (*StringStructMapCmd)(nil)\n\nfunc NewStringStructMapCmd(ctx context.Context, args ...interface{}) *StringStructMapCmd {\n\treturn &StringStructMapCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *StringStructMapCmd) SetVal(val map[string]struct{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *StringStructMapCmd) Val() map[string]struct{} {\n\treturn cmd.val\n}\n\nfunc (cmd *StringStructMapCmd) Result() (map[string]struct{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *StringStructMapCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *StringStructMapCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make(map[string]struct{}, n)\n\tfor i := 0; i < n; i++ {\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[key] = struct{}{}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XMessage struct {\n\tID     string\n\tValues map[string]interface{}\n}\n\ntype XMessageSliceCmd struct {\n\tbaseCmd\n\n\tval []XMessage\n}\n\nvar _ Cmder = (*XMessageSliceCmd)(nil)\n\nfunc NewXMessageSliceCmd(ctx context.Context, args ...interface{}) *XMessageSliceCmd {\n\treturn &XMessageSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *XMessageSliceCmd) SetVal(val []XMessage) {\n\tcmd.val = val\n}\n\nfunc (cmd *XMessageSliceCmd) Val() []XMessage {\n\treturn cmd.val\n}\n\nfunc (cmd *XMessageSliceCmd) Result() ([]XMessage, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XMessageSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XMessageSliceCmd) readReply(rd *proto.Reader) (err error) {\n\tcmd.val, err = readXMessageSlice(rd)\n\treturn err\n}\n\nfunc readXMessageSlice(rd *proto.Reader) ([]XMessage, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tmsgs := make([]XMessage, n)\n\tfor i := 0; i < len(msgs); i++ {\n\t\tif msgs[i], err = readXMessage(rd); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn msgs, nil\n}\n\nfunc readXMessage(rd *proto.Reader) (XMessage, error) {\n\tif err := rd.ReadFixedArrayLen(2); err != nil {\n\t\treturn XMessage{}, err\n\t}\n\n\tid, err := rd.ReadString()\n\tif err != nil {\n\t\treturn XMessage{}, err\n\t}\n\n\tv, err := stringInterfaceMapParser(rd)\n\tif err != nil {\n\t\tif err != proto.Nil {\n\t\t\treturn XMessage{}, err\n\t\t}\n\t}\n\n\treturn XMessage{\n\t\tID:     id,\n\t\tValues: v,\n\t}, nil\n}\n\nfunc stringInterfaceMapParser(rd *proto.Reader) (map[string]interface{}, error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tm := make(map[string]interface{}, n)\n\tfor i := 0; i < n; i++ {\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvalue, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tm[key] = value\n\t}\n\treturn m, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XStream struct {\n\tStream   string\n\tMessages []XMessage\n}\n\ntype XStreamSliceCmd struct {\n\tbaseCmd\n\n\tval []XStream\n}\n\nvar _ Cmder = (*XStreamSliceCmd)(nil)\n\nfunc NewXStreamSliceCmd(ctx context.Context, args ...interface{}) *XStreamSliceCmd {\n\treturn &XStreamSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *XStreamSliceCmd) SetVal(val []XStream) {\n\tcmd.val = val\n}\n\nfunc (cmd *XStreamSliceCmd) Val() []XStream {\n\treturn cmd.val\n}\n\nfunc (cmd *XStreamSliceCmd) Result() ([]XStream, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XStreamSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XStreamSliceCmd) readReply(rd *proto.Reader) error {\n\ttyp, err := rd.PeekReplyType()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar n int\n\tif typ == proto.RespMap {\n\t\tn, err = rd.ReadMapLen()\n\t} else {\n\t\tn, err = rd.ReadArrayLen()\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]XStream, n)\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tif typ != proto.RespMap {\n\t\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif cmd.val[i].Stream, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif cmd.val[i].Messages, err = readXMessageSlice(rd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XPending struct {\n\tCount     int64\n\tLower     string\n\tHigher    string\n\tConsumers map[string]int64\n}\n\ntype XPendingCmd struct {\n\tbaseCmd\n\tval *XPending\n}\n\nvar _ Cmder = (*XPendingCmd)(nil)\n\nfunc NewXPendingCmd(ctx context.Context, args ...interface{}) *XPendingCmd {\n\treturn &XPendingCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *XPendingCmd) SetVal(val *XPending) {\n\tcmd.val = val\n}\n\nfunc (cmd *XPendingCmd) Val() *XPending {\n\treturn cmd.val\n}\n\nfunc (cmd *XPendingCmd) Result() (*XPending, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XPendingCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XPendingCmd) readReply(rd *proto.Reader) error {\n\tvar err error\n\tif err = rd.ReadFixedArrayLen(4); err != nil {\n\t\treturn err\n\t}\n\tcmd.val = &XPending{}\n\n\tif cmd.val.Count, err = rd.ReadInt(); err != nil {\n\t\treturn err\n\t}\n\n\tif cmd.val.Lower, err = rd.ReadString(); err != nil && err != Nil {\n\t\treturn err\n\t}\n\n\tif cmd.val.Higher, err = rd.ReadString(); err != nil && err != Nil {\n\t\treturn err\n\t}\n\n\tn, err := rd.ReadArrayLen()\n\tif err != nil && err != Nil {\n\t\treturn err\n\t}\n\tcmd.val.Consumers = make(map[string]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tconsumerName, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconsumerPending, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val.Consumers[consumerName] = consumerPending\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XPendingExt struct {\n\tID         string\n\tConsumer   string\n\tIdle       time.Duration\n\tRetryCount int64\n}\n\ntype XPendingExtCmd struct {\n\tbaseCmd\n\tval []XPendingExt\n}\n\nvar _ Cmder = (*XPendingExtCmd)(nil)\n\nfunc NewXPendingExtCmd(ctx context.Context, args ...interface{}) *XPendingExtCmd {\n\treturn &XPendingExtCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *XPendingExtCmd) SetVal(val []XPendingExt) {\n\tcmd.val = val\n}\n\nfunc (cmd *XPendingExtCmd) Val() []XPendingExt {\n\treturn cmd.val\n}\n\nfunc (cmd *XPendingExtCmd) Result() ([]XPendingExt, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XPendingExtCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XPendingExtCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]XPendingExt, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tif err = rd.ReadFixedArrayLen(4); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cmd.val[i].ID, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cmd.val[i].Consumer, err = rd.ReadString(); err != nil && err != Nil {\n\t\t\treturn err\n\t\t}\n\n\t\tidle, err := rd.ReadInt()\n\t\tif err != nil && err != Nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[i].Idle = time.Duration(idle) * time.Millisecond\n\n\t\tif cmd.val[i].RetryCount, err = rd.ReadInt(); err != nil && err != Nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XAutoClaimCmd struct {\n\tbaseCmd\n\n\tstart string\n\tval   []XMessage\n}\n\nvar _ Cmder = (*XAutoClaimCmd)(nil)\n\nfunc NewXAutoClaimCmd(ctx context.Context, args ...interface{}) *XAutoClaimCmd {\n\treturn &XAutoClaimCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *XAutoClaimCmd) SetVal(val []XMessage, start string) {\n\tcmd.val = val\n\tcmd.start = start\n}\n\nfunc (cmd *XAutoClaimCmd) Val() (messages []XMessage, start string) {\n\treturn cmd.val, cmd.start\n}\n\nfunc (cmd *XAutoClaimCmd) Result() (messages []XMessage, start string, err error) {\n\treturn cmd.val, cmd.start, cmd.err\n}\n\nfunc (cmd *XAutoClaimCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XAutoClaimCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch n {\n\tcase 2, // Redis 6\n\t\t3: // Redis 7:\n\t\t// ok\n\tdefault:\n\t\treturn fmt.Errorf(\"redis: got %d elements in XAutoClaim reply, wanted 2/3\", n)\n\t}\n\n\tcmd.start, err = rd.ReadString()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val, err = readXMessageSlice(rd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif n >= 3 {\n\t\tif err := rd.DiscardNext(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XAutoClaimJustIDCmd struct {\n\tbaseCmd\n\n\tstart string\n\tval   []string\n}\n\nvar _ Cmder = (*XAutoClaimJustIDCmd)(nil)\n\nfunc NewXAutoClaimJustIDCmd(ctx context.Context, args ...interface{}) *XAutoClaimJustIDCmd {\n\treturn &XAutoClaimJustIDCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *XAutoClaimJustIDCmd) SetVal(val []string, start string) {\n\tcmd.val = val\n\tcmd.start = start\n}\n\nfunc (cmd *XAutoClaimJustIDCmd) Val() (ids []string, start string) {\n\treturn cmd.val, cmd.start\n}\n\nfunc (cmd *XAutoClaimJustIDCmd) Result() (ids []string, start string, err error) {\n\treturn cmd.val, cmd.start, cmd.err\n}\n\nfunc (cmd *XAutoClaimJustIDCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XAutoClaimJustIDCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch n {\n\tcase 2, // Redis 6\n\t\t3: // Redis 7:\n\t\t// ok\n\tdefault:\n\t\treturn fmt.Errorf(\"redis: got %d elements in XAutoClaimJustID reply, wanted 2/3\", n)\n\t}\n\n\tcmd.start, err = rd.ReadString()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tnn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make([]string, nn)\n\tfor i := 0; i < nn; i++ {\n\t\tcmd.val[i], err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif n >= 3 {\n\t\tif err := rd.DiscardNext(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XInfoConsumersCmd struct {\n\tbaseCmd\n\tval []XInfoConsumer\n}\n\ntype XInfoConsumer struct {\n\tName     string\n\tPending  int64\n\tIdle     time.Duration\n\tInactive time.Duration\n}\n\nvar _ Cmder = (*XInfoConsumersCmd)(nil)\n\nfunc NewXInfoConsumersCmd(ctx context.Context, stream string, group string) *XInfoConsumersCmd {\n\treturn &XInfoConsumersCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: []interface{}{\"xinfo\", \"consumers\", stream, group},\n\t\t},\n\t}\n}\n\nfunc (cmd *XInfoConsumersCmd) SetVal(val []XInfoConsumer) {\n\tcmd.val = val\n}\n\nfunc (cmd *XInfoConsumersCmd) Val() []XInfoConsumer {\n\treturn cmd.val\n}\n\nfunc (cmd *XInfoConsumersCmd) Result() ([]XInfoConsumer, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XInfoConsumersCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XInfoConsumersCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]XInfoConsumer, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar key string\n\t\tfor f := 0; f < nn; f++ {\n\t\t\tkey, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"name\":\n\t\t\t\tcmd.val[i].Name, err = rd.ReadString()\n\t\t\tcase \"pending\":\n\t\t\t\tcmd.val[i].Pending, err = rd.ReadInt()\n\t\t\tcase \"idle\":\n\t\t\t\tvar idle int64\n\t\t\t\tidle, err = rd.ReadInt()\n\t\t\t\tcmd.val[i].Idle = time.Duration(idle) * time.Millisecond\n\t\t\tcase \"inactive\":\n\t\t\t\tvar inactive int64\n\t\t\t\tinactive, err = rd.ReadInt()\n\t\t\t\tcmd.val[i].Inactive = time.Duration(inactive) * time.Millisecond\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"redis: unexpected content %s in XINFO CONSUMERS reply\", key)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XInfoGroupsCmd struct {\n\tbaseCmd\n\tval []XInfoGroup\n}\n\ntype XInfoGroup struct {\n\tName            string\n\tConsumers       int64\n\tPending         int64\n\tLastDeliveredID string\n\tEntriesRead     int64\n\tLag             int64\n}\n\nvar _ Cmder = (*XInfoGroupsCmd)(nil)\n\nfunc NewXInfoGroupsCmd(ctx context.Context, stream string) *XInfoGroupsCmd {\n\treturn &XInfoGroupsCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: []interface{}{\"xinfo\", \"groups\", stream},\n\t\t},\n\t}\n}\n\nfunc (cmd *XInfoGroupsCmd) SetVal(val []XInfoGroup) {\n\tcmd.val = val\n}\n\nfunc (cmd *XInfoGroupsCmd) Val() []XInfoGroup {\n\treturn cmd.val\n}\n\nfunc (cmd *XInfoGroupsCmd) Result() ([]XInfoGroup, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XInfoGroupsCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XInfoGroupsCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]XInfoGroup, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tgroup := &cmd.val[i]\n\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar key string\n\t\tfor j := 0; j < nn; j++ {\n\t\t\tkey, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"name\":\n\t\t\t\tgroup.Name, err = rd.ReadString()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase \"consumers\":\n\t\t\t\tgroup.Consumers, err = rd.ReadInt()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase \"pending\":\n\t\t\t\tgroup.Pending, err = rd.ReadInt()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase \"last-delivered-id\":\n\t\t\t\tgroup.LastDeliveredID, err = rd.ReadString()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase \"entries-read\":\n\t\t\t\tgroup.EntriesRead, err = rd.ReadInt()\n\t\t\t\tif err != nil && err != Nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase \"lag\":\n\t\t\t\tgroup.Lag, err = rd.ReadInt()\n\n\t\t\t\t// lag: the number of entries in the stream that are still waiting to be delivered\n\t\t\t\t// to the group's consumers, or a NULL(Nil) when that number can't be determined.\n\t\t\t\tif err != nil && err != Nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"redis: unexpected key %q in XINFO GROUPS reply\", key)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XInfoStreamCmd struct {\n\tbaseCmd\n\tval *XInfoStream\n}\n\ntype XInfoStream struct {\n\tLength               int64\n\tRadixTreeKeys        int64\n\tRadixTreeNodes       int64\n\tGroups               int64\n\tLastGeneratedID      string\n\tMaxDeletedEntryID    string\n\tEntriesAdded         int64\n\tFirstEntry           XMessage\n\tLastEntry            XMessage\n\tRecordedFirstEntryID string\n}\n\nvar _ Cmder = (*XInfoStreamCmd)(nil)\n\nfunc NewXInfoStreamCmd(ctx context.Context, stream string) *XInfoStreamCmd {\n\treturn &XInfoStreamCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: []interface{}{\"xinfo\", \"stream\", stream},\n\t\t},\n\t}\n}\n\nfunc (cmd *XInfoStreamCmd) SetVal(val *XInfoStream) {\n\tcmd.val = val\n}\n\nfunc (cmd *XInfoStreamCmd) Val() *XInfoStream {\n\treturn cmd.val\n}\n\nfunc (cmd *XInfoStreamCmd) Result() (*XInfoStream, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XInfoStreamCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XInfoStreamCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = &XInfoStream{}\n\n\tfor i := 0; i < n; i++ {\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch key {\n\t\tcase \"length\":\n\t\t\tcmd.val.Length, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"radix-tree-keys\":\n\t\t\tcmd.val.RadixTreeKeys, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"radix-tree-nodes\":\n\t\t\tcmd.val.RadixTreeNodes, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"groups\":\n\t\t\tcmd.val.Groups, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"last-generated-id\":\n\t\t\tcmd.val.LastGeneratedID, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"max-deleted-entry-id\":\n\t\t\tcmd.val.MaxDeletedEntryID, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"entries-added\":\n\t\t\tcmd.val.EntriesAdded, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"first-entry\":\n\t\t\tcmd.val.FirstEntry, err = readXMessage(rd)\n\t\t\tif err != nil && err != Nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"last-entry\":\n\t\t\tcmd.val.LastEntry, err = readXMessage(rd)\n\t\t\tif err != nil && err != Nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"recorded-first-entry-id\":\n\t\t\tcmd.val.RecordedFirstEntryID, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: unexpected key %q in XINFO STREAM reply\", key)\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype XInfoStreamFullCmd struct {\n\tbaseCmd\n\tval *XInfoStreamFull\n}\n\ntype XInfoStreamFull struct {\n\tLength               int64\n\tRadixTreeKeys        int64\n\tRadixTreeNodes       int64\n\tLastGeneratedID      string\n\tMaxDeletedEntryID    string\n\tEntriesAdded         int64\n\tEntries              []XMessage\n\tGroups               []XInfoStreamGroup\n\tRecordedFirstEntryID string\n}\n\ntype XInfoStreamGroup struct {\n\tName            string\n\tLastDeliveredID string\n\tEntriesRead     int64\n\tLag             int64\n\tPelCount        int64\n\tPending         []XInfoStreamGroupPending\n\tConsumers       []XInfoStreamConsumer\n}\n\ntype XInfoStreamGroupPending struct {\n\tID            string\n\tConsumer      string\n\tDeliveryTime  time.Time\n\tDeliveryCount int64\n}\n\ntype XInfoStreamConsumer struct {\n\tName       string\n\tSeenTime   time.Time\n\tActiveTime time.Time\n\tPelCount   int64\n\tPending    []XInfoStreamConsumerPending\n}\n\ntype XInfoStreamConsumerPending struct {\n\tID            string\n\tDeliveryTime  time.Time\n\tDeliveryCount int64\n}\n\nvar _ Cmder = (*XInfoStreamFullCmd)(nil)\n\nfunc NewXInfoStreamFullCmd(ctx context.Context, args ...interface{}) *XInfoStreamFullCmd {\n\treturn &XInfoStreamFullCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *XInfoStreamFullCmd) SetVal(val *XInfoStreamFull) {\n\tcmd.val = val\n}\n\nfunc (cmd *XInfoStreamFullCmd) Val() *XInfoStreamFull {\n\treturn cmd.val\n}\n\nfunc (cmd *XInfoStreamFullCmd) Result() (*XInfoStreamFull, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *XInfoStreamFullCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *XInfoStreamFullCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = &XInfoStreamFull{}\n\n\tfor i := 0; i < n; i++ {\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"length\":\n\t\t\tcmd.val.Length, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"radix-tree-keys\":\n\t\t\tcmd.val.RadixTreeKeys, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"radix-tree-nodes\":\n\t\t\tcmd.val.RadixTreeNodes, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"last-generated-id\":\n\t\t\tcmd.val.LastGeneratedID, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"entries-added\":\n\t\t\tcmd.val.EntriesAdded, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"entries\":\n\t\t\tcmd.val.Entries, err = readXMessageSlice(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"groups\":\n\t\t\tcmd.val.Groups, err = readStreamGroups(rd)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"max-deleted-entry-id\":\n\t\t\tcmd.val.MaxDeletedEntryID, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"recorded-first-entry-id\":\n\t\t\tcmd.val.RecordedFirstEntryID, err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: unexpected key %q in XINFO STREAM FULL reply\", key)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc readStreamGroups(rd *proto.Reader) ([]XInfoStreamGroup, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tgroups := make([]XInfoStreamGroup, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tgroup := XInfoStreamGroup{}\n\n\t\tfor j := 0; j < nn; j++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"name\":\n\t\t\t\tgroup.Name, err = rd.ReadString()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"last-delivered-id\":\n\t\t\t\tgroup.LastDeliveredID, err = rd.ReadString()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"entries-read\":\n\t\t\t\tgroup.EntriesRead, err = rd.ReadInt()\n\t\t\t\tif err != nil && err != Nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"lag\":\n\t\t\t\t// lag: the number of entries in the stream that are still waiting to be delivered\n\t\t\t\t// to the group's consumers, or a NULL(Nil) when that number can't be determined.\n\t\t\t\tgroup.Lag, err = rd.ReadInt()\n\t\t\t\tif err != nil && err != Nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"pel-count\":\n\t\t\t\tgroup.PelCount, err = rd.ReadInt()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"pending\":\n\t\t\t\tgroup.Pending, err = readXInfoStreamGroupPending(rd)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"consumers\":\n\t\t\t\tgroup.Consumers, err = readXInfoStreamConsumers(rd)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"redis: unexpected key %q in XINFO STREAM FULL reply\", key)\n\t\t\t}\n\t\t}\n\n\t\tgroups = append(groups, group)\n\t}\n\n\treturn groups, nil\n}\n\nfunc readXInfoStreamGroupPending(rd *proto.Reader) ([]XInfoStreamGroupPending, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpending := make([]XInfoStreamGroupPending, 0, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tif err = rd.ReadFixedArrayLen(4); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp := XInfoStreamGroupPending{}\n\n\t\tp.ID, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tp.Consumer, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tdelivery, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tp.DeliveryTime = time.Unix(delivery/1000, delivery%1000*int64(time.Millisecond))\n\n\t\tp.DeliveryCount, err = rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tpending = append(pending, p)\n\t}\n\n\treturn pending, nil\n}\n\nfunc readXInfoStreamConsumers(rd *proto.Reader) ([]XInfoStreamConsumer, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconsumers := make([]XInfoStreamConsumer, 0, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tc := XInfoStreamConsumer{}\n\n\t\tfor f := 0; f < nn; f++ {\n\t\t\tcKey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tswitch cKey {\n\t\t\tcase \"name\":\n\t\t\t\tc.Name, err = rd.ReadString()\n\t\t\tcase \"seen-time\":\n\t\t\t\tseen, err := rd.ReadInt()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tc.SeenTime = time.UnixMilli(seen)\n\t\t\tcase \"active-time\":\n\t\t\t\tactive, err := rd.ReadInt()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tc.ActiveTime = time.UnixMilli(active)\n\t\t\tcase \"pel-count\":\n\t\t\t\tc.PelCount, err = rd.ReadInt()\n\t\t\tcase \"pending\":\n\t\t\t\tpendingNumber, err := rd.ReadArrayLen()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tc.Pending = make([]XInfoStreamConsumerPending, 0, pendingNumber)\n\n\t\t\t\tfor pn := 0; pn < pendingNumber; pn++ {\n\t\t\t\t\tif err = rd.ReadFixedArrayLen(3); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\tp := XInfoStreamConsumerPending{}\n\n\t\t\t\t\tp.ID, err = rd.ReadString()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\tdelivery, err := rd.ReadInt()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tp.DeliveryTime = time.Unix(delivery/1000, delivery%1000*int64(time.Millisecond))\n\n\t\t\t\t\tp.DeliveryCount, err = rd.ReadInt()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\n\t\t\t\t\tc.Pending = append(c.Pending, p)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"redis: unexpected content %s \"+\n\t\t\t\t\t\"in XINFO STREAM FULL reply\", cKey)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tconsumers = append(consumers, c)\n\t}\n\n\treturn consumers, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype ZSliceCmd struct {\n\tbaseCmd\n\n\tval []Z\n}\n\nvar _ Cmder = (*ZSliceCmd)(nil)\n\nfunc NewZSliceCmd(ctx context.Context, args ...interface{}) *ZSliceCmd {\n\treturn &ZSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ZSliceCmd) SetVal(val []Z) {\n\tcmd.val = val\n}\n\nfunc (cmd *ZSliceCmd) Val() []Z {\n\treturn cmd.val\n}\n\nfunc (cmd *ZSliceCmd) Result() ([]Z, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ZSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ZSliceCmd) readReply(rd *proto.Reader) error { // nolint:dupl\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If the n is 0, can't continue reading.\n\tif n == 0 {\n\t\tcmd.val = make([]Z, 0)\n\t\treturn nil\n\t}\n\n\ttyp, err := rd.PeekReplyType()\n\tif err != nil {\n\t\treturn err\n\t}\n\tarray := typ == proto.RespArray\n\n\tif array {\n\t\tcmd.val = make([]Z, n)\n\t} else {\n\t\tcmd.val = make([]Z, n/2)\n\t}\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tif array {\n\t\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif cmd.val[i].Member, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cmd.val[i].Score, err = rd.ReadFloat(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype ZWithKeyCmd struct {\n\tbaseCmd\n\n\tval *ZWithKey\n}\n\nvar _ Cmder = (*ZWithKeyCmd)(nil)\n\nfunc NewZWithKeyCmd(ctx context.Context, args ...interface{}) *ZWithKeyCmd {\n\treturn &ZWithKeyCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ZWithKeyCmd) SetVal(val *ZWithKey) {\n\tcmd.val = val\n}\n\nfunc (cmd *ZWithKeyCmd) Val() *ZWithKey {\n\treturn cmd.val\n}\n\nfunc (cmd *ZWithKeyCmd) Result() (*ZWithKey, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ZWithKeyCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ZWithKeyCmd) readReply(rd *proto.Reader) (err error) {\n\tif err = rd.ReadFixedArrayLen(3); err != nil {\n\t\treturn err\n\t}\n\tcmd.val = &ZWithKey{}\n\n\tif cmd.val.Key, err = rd.ReadString(); err != nil {\n\t\treturn err\n\t}\n\tif cmd.val.Member, err = rd.ReadString(); err != nil {\n\t\treturn err\n\t}\n\tif cmd.val.Score, err = rd.ReadFloat(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype ScanCmd struct {\n\tbaseCmd\n\n\tpage   []string\n\tcursor uint64\n\n\tprocess cmdable\n}\n\nvar _ Cmder = (*ScanCmd)(nil)\n\nfunc NewScanCmd(ctx context.Context, process cmdable, args ...interface{}) *ScanCmd {\n\treturn &ScanCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t\tprocess: process,\n\t}\n}\n\nfunc (cmd *ScanCmd) SetVal(page []string, cursor uint64) {\n\tcmd.page = page\n\tcmd.cursor = cursor\n}\n\nfunc (cmd *ScanCmd) Val() (keys []string, cursor uint64) {\n\treturn cmd.page, cmd.cursor\n}\n\nfunc (cmd *ScanCmd) Result() (keys []string, cursor uint64, err error) {\n\treturn cmd.page, cmd.cursor, cmd.err\n}\n\nfunc (cmd *ScanCmd) String() string {\n\treturn cmdString(cmd, cmd.page)\n}\n\nfunc (cmd *ScanCmd) readReply(rd *proto.Reader) error {\n\tif err := rd.ReadFixedArrayLen(2); err != nil {\n\t\treturn err\n\t}\n\n\tcursor, err := rd.ReadUint()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.cursor = cursor\n\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.page = make([]string, n)\n\n\tfor i := 0; i < len(cmd.page); i++ {\n\t\tif cmd.page[i], err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Iterator creates a new ScanIterator.\nfunc (cmd *ScanCmd) Iterator() *ScanIterator {\n\treturn &ScanIterator{\n\t\tcmd: cmd,\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype ClusterNode struct {\n\tID                 string\n\tAddr               string\n\tNetworkingMetadata map[string]string\n}\n\ntype ClusterSlot struct {\n\tStart int\n\tEnd   int\n\tNodes []ClusterNode\n}\n\ntype ClusterSlotsCmd struct {\n\tbaseCmd\n\n\tval []ClusterSlot\n}\n\nvar _ Cmder = (*ClusterSlotsCmd)(nil)\n\nfunc NewClusterSlotsCmd(ctx context.Context, args ...interface{}) *ClusterSlotsCmd {\n\treturn &ClusterSlotsCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ClusterSlotsCmd) SetVal(val []ClusterSlot) {\n\tcmd.val = val\n}\n\nfunc (cmd *ClusterSlotsCmd) Val() []ClusterSlot {\n\treturn cmd.val\n}\n\nfunc (cmd *ClusterSlotsCmd) Result() ([]ClusterSlot, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ClusterSlotsCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ClusterSlotsCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]ClusterSlot, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tn, err = rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n < 2 {\n\t\t\treturn fmt.Errorf(\"redis: got %d elements in cluster info, expected at least 2\", n)\n\t\t}\n\n\t\tstart, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tend, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// subtract start and end.\n\t\tnodes := make([]ClusterNode, n-2)\n\n\t\tfor j := 0; j < len(nodes); j++ {\n\t\t\tnn, err := rd.ReadArrayLen()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif nn < 2 || nn > 4 {\n\t\t\t\treturn fmt.Errorf(\"got %d elements in cluster info address, expected 2, 3, or 4\", n)\n\t\t\t}\n\n\t\t\tip, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tport, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tnodes[j].Addr = net.JoinHostPort(ip, port)\n\n\t\t\tif nn >= 3 {\n\t\t\t\tid, err := rd.ReadString()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tnodes[j].ID = id\n\t\t\t}\n\n\t\t\tif nn >= 4 {\n\t\t\t\tmetadataLength, err := rd.ReadMapLen()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tnetworkingMetadata := make(map[string]string, metadataLength)\n\n\t\t\t\tfor i := 0; i < metadataLength; i++ {\n\t\t\t\t\tkey, err := rd.ReadString()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tvalue, err := rd.ReadString()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tnetworkingMetadata[key] = value\n\t\t\t\t}\n\n\t\t\t\tnodes[j].NetworkingMetadata = networkingMetadata\n\t\t\t}\n\t\t}\n\n\t\tcmd.val[i] = ClusterSlot{\n\t\t\tStart: int(start),\n\t\t\tEnd:   int(end),\n\t\t\tNodes: nodes,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\n// GeoLocation is used with GeoAdd to add geospatial location.\ntype GeoLocation struct {\n\tName                      string\n\tLongitude, Latitude, Dist float64\n\tGeoHash                   int64\n}\n\n// GeoRadiusQuery is used with GeoRadius to query geospatial index.\ntype GeoRadiusQuery struct {\n\tRadius float64\n\t// Can be m, km, ft, or mi. Default is km.\n\tUnit        string\n\tWithCoord   bool\n\tWithDist    bool\n\tWithGeoHash bool\n\tCount       int\n\t// Can be ASC or DESC. Default is no sort order.\n\tSort      string\n\tStore     string\n\tStoreDist string\n\n\t// WithCoord+WithDist+WithGeoHash\n\twithLen int\n}\n\ntype GeoLocationCmd struct {\n\tbaseCmd\n\n\tq         *GeoRadiusQuery\n\tlocations []GeoLocation\n}\n\nvar _ Cmder = (*GeoLocationCmd)(nil)\n\nfunc NewGeoLocationCmd(ctx context.Context, q *GeoRadiusQuery, args ...interface{}) *GeoLocationCmd {\n\treturn &GeoLocationCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: geoLocationArgs(q, args...),\n\t\t},\n\t\tq: q,\n\t}\n}\n\nfunc geoLocationArgs(q *GeoRadiusQuery, args ...interface{}) []interface{} {\n\targs = append(args, q.Radius)\n\tif q.Unit != \"\" {\n\t\targs = append(args, q.Unit)\n\t} else {\n\t\targs = append(args, \"km\")\n\t}\n\tif q.WithCoord {\n\t\targs = append(args, \"withcoord\")\n\t\tq.withLen++\n\t}\n\tif q.WithDist {\n\t\targs = append(args, \"withdist\")\n\t\tq.withLen++\n\t}\n\tif q.WithGeoHash {\n\t\targs = append(args, \"withhash\")\n\t\tq.withLen++\n\t}\n\tif q.Count > 0 {\n\t\targs = append(args, \"count\", q.Count)\n\t}\n\tif q.Sort != \"\" {\n\t\targs = append(args, q.Sort)\n\t}\n\tif q.Store != \"\" {\n\t\targs = append(args, \"store\")\n\t\targs = append(args, q.Store)\n\t}\n\tif q.StoreDist != \"\" {\n\t\targs = append(args, \"storedist\")\n\t\targs = append(args, q.StoreDist)\n\t}\n\treturn args\n}\n\nfunc (cmd *GeoLocationCmd) SetVal(locations []GeoLocation) {\n\tcmd.locations = locations\n}\n\nfunc (cmd *GeoLocationCmd) Val() []GeoLocation {\n\treturn cmd.locations\n}\n\nfunc (cmd *GeoLocationCmd) Result() ([]GeoLocation, error) {\n\treturn cmd.locations, cmd.err\n}\n\nfunc (cmd *GeoLocationCmd) String() string {\n\treturn cmdString(cmd, cmd.locations)\n}\n\nfunc (cmd *GeoLocationCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.locations = make([]GeoLocation, n)\n\n\tfor i := 0; i < len(cmd.locations); i++ {\n\t\t// only name\n\t\tif cmd.q.withLen == 0 {\n\t\t\tif cmd.locations[i].Name, err = rd.ReadString(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// +name\n\t\tif err = rd.ReadFixedArrayLen(cmd.q.withLen + 1); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cmd.locations[i].Name, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif cmd.q.WithDist {\n\t\t\tif cmd.locations[i].Dist, err = rd.ReadFloat(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif cmd.q.WithGeoHash {\n\t\t\tif cmd.locations[i].GeoHash, err = rd.ReadInt(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif cmd.q.WithCoord {\n\t\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif cmd.locations[i].Longitude, err = rd.ReadFloat(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif cmd.locations[i].Latitude, err = rd.ReadFloat(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\n// GeoSearchQuery is used for GEOSearch/GEOSearchStore command query.\ntype GeoSearchQuery struct {\n\tMember string\n\n\t// Latitude and Longitude when using FromLonLat option.\n\tLongitude float64\n\tLatitude  float64\n\n\t// Distance and unit when using ByRadius option.\n\t// Can use m, km, ft, or mi. Default is km.\n\tRadius     float64\n\tRadiusUnit string\n\n\t// Height, width and unit when using ByBox option.\n\t// Can be m, km, ft, or mi. Default is km.\n\tBoxWidth  float64\n\tBoxHeight float64\n\tBoxUnit   string\n\n\t// Can be ASC or DESC. Default is no sort order.\n\tSort     string\n\tCount    int\n\tCountAny bool\n}\n\ntype GeoSearchLocationQuery struct {\n\tGeoSearchQuery\n\n\tWithCoord bool\n\tWithDist  bool\n\tWithHash  bool\n}\n\ntype GeoSearchStoreQuery struct {\n\tGeoSearchQuery\n\n\t// When using the StoreDist option, the command stores the items in a\n\t// sorted set populated with their distance from the center of the circle or box,\n\t// as a floating-point number, in the same unit specified for that shape.\n\tStoreDist bool\n}\n\nfunc geoSearchLocationArgs(q *GeoSearchLocationQuery, args []interface{}) []interface{} {\n\targs = geoSearchArgs(&q.GeoSearchQuery, args)\n\n\tif q.WithCoord {\n\t\targs = append(args, \"withcoord\")\n\t}\n\tif q.WithDist {\n\t\targs = append(args, \"withdist\")\n\t}\n\tif q.WithHash {\n\t\targs = append(args, \"withhash\")\n\t}\n\n\treturn args\n}\n\nfunc geoSearchArgs(q *GeoSearchQuery, args []interface{}) []interface{} {\n\tif q.Member != \"\" {\n\t\targs = append(args, \"frommember\", q.Member)\n\t} else {\n\t\targs = append(args, \"fromlonlat\", q.Longitude, q.Latitude)\n\t}\n\n\tif q.Radius > 0 {\n\t\tif q.RadiusUnit == \"\" {\n\t\t\tq.RadiusUnit = \"km\"\n\t\t}\n\t\targs = append(args, \"byradius\", q.Radius, q.RadiusUnit)\n\t} else {\n\t\tif q.BoxUnit == \"\" {\n\t\t\tq.BoxUnit = \"km\"\n\t\t}\n\t\targs = append(args, \"bybox\", q.BoxWidth, q.BoxHeight, q.BoxUnit)\n\t}\n\n\tif q.Sort != \"\" {\n\t\targs = append(args, q.Sort)\n\t}\n\n\tif q.Count > 0 {\n\t\targs = append(args, \"count\", q.Count)\n\t\tif q.CountAny {\n\t\t\targs = append(args, \"any\")\n\t\t}\n\t}\n\n\treturn args\n}\n\ntype GeoSearchLocationCmd struct {\n\tbaseCmd\n\n\topt *GeoSearchLocationQuery\n\tval []GeoLocation\n}\n\nvar _ Cmder = (*GeoSearchLocationCmd)(nil)\n\nfunc NewGeoSearchLocationCmd(\n\tctx context.Context, opt *GeoSearchLocationQuery, args ...interface{},\n) *GeoSearchLocationCmd {\n\treturn &GeoSearchLocationCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t\topt: opt,\n\t}\n}\n\nfunc (cmd *GeoSearchLocationCmd) SetVal(val []GeoLocation) {\n\tcmd.val = val\n}\n\nfunc (cmd *GeoSearchLocationCmd) Val() []GeoLocation {\n\treturn cmd.val\n}\n\nfunc (cmd *GeoSearchLocationCmd) Result() ([]GeoLocation, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *GeoSearchLocationCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *GeoSearchLocationCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make([]GeoLocation, n)\n\tfor i := 0; i < n; i++ {\n\t\t_, err = rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tvar loc GeoLocation\n\n\t\tloc.Name, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif cmd.opt.WithDist {\n\t\t\tloc.Dist, err = rd.ReadFloat()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif cmd.opt.WithHash {\n\t\t\tloc.GeoHash, err = rd.ReadInt()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif cmd.opt.WithCoord {\n\t\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tloc.Longitude, err = rd.ReadFloat()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tloc.Latitude, err = rd.ReadFloat()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tcmd.val[i] = loc\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype GeoPos struct {\n\tLongitude, Latitude float64\n}\n\ntype GeoPosCmd struct {\n\tbaseCmd\n\n\tval []*GeoPos\n}\n\nvar _ Cmder = (*GeoPosCmd)(nil)\n\nfunc NewGeoPosCmd(ctx context.Context, args ...interface{}) *GeoPosCmd {\n\treturn &GeoPosCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *GeoPosCmd) SetVal(val []*GeoPos) {\n\tcmd.val = val\n}\n\nfunc (cmd *GeoPosCmd) Val() []*GeoPos {\n\treturn cmd.val\n}\n\nfunc (cmd *GeoPosCmd) Result() ([]*GeoPos, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *GeoPosCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *GeoPosCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]*GeoPos, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\terr = rd.ReadFixedArrayLen(2)\n\t\tif err != nil {\n\t\t\tif err == Nil {\n\t\t\t\tcmd.val[i] = nil\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tlongitude, err := rd.ReadFloat()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlatitude, err := rd.ReadFloat()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcmd.val[i] = &GeoPos{\n\t\t\tLongitude: longitude,\n\t\t\tLatitude:  latitude,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype CommandInfo struct {\n\tName        string\n\tArity       int8\n\tFlags       []string\n\tACLFlags    []string\n\tFirstKeyPos int8\n\tLastKeyPos  int8\n\tStepCount   int8\n\tReadOnly    bool\n}\n\ntype CommandsInfoCmd struct {\n\tbaseCmd\n\n\tval map[string]*CommandInfo\n}\n\nvar _ Cmder = (*CommandsInfoCmd)(nil)\n\nfunc NewCommandsInfoCmd(ctx context.Context, args ...interface{}) *CommandsInfoCmd {\n\treturn &CommandsInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *CommandsInfoCmd) SetVal(val map[string]*CommandInfo) {\n\tcmd.val = val\n}\n\nfunc (cmd *CommandsInfoCmd) Val() map[string]*CommandInfo {\n\treturn cmd.val\n}\n\nfunc (cmd *CommandsInfoCmd) Result() (map[string]*CommandInfo, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *CommandsInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *CommandsInfoCmd) readReply(rd *proto.Reader) error {\n\tconst numArgRedis5 = 6\n\tconst numArgRedis6 = 7\n\tconst numArgRedis7 = 10\n\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make(map[string]*CommandInfo, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tnn, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch nn {\n\t\tcase numArgRedis5, numArgRedis6, numArgRedis7:\n\t\t\t// ok\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: got %d elements in COMMAND reply, wanted 6/7/10\", nn)\n\t\t}\n\n\t\tcmdInfo := &CommandInfo{}\n\t\tif cmdInfo.Name, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tarity, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmdInfo.Arity = int8(arity)\n\n\t\tflagLen, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmdInfo.Flags = make([]string, flagLen)\n\t\tfor f := 0; f < len(cmdInfo.Flags); f++ {\n\t\t\tswitch s, err := rd.ReadString(); {\n\t\t\tcase err == Nil:\n\t\t\t\tcmdInfo.Flags[f] = \"\"\n\t\t\tcase err != nil:\n\t\t\t\treturn err\n\t\t\tdefault:\n\t\t\t\tif !cmdInfo.ReadOnly && s == \"readonly\" {\n\t\t\t\t\tcmdInfo.ReadOnly = true\n\t\t\t\t}\n\t\t\t\tcmdInfo.Flags[f] = s\n\t\t\t}\n\t\t}\n\n\t\tfirstKeyPos, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmdInfo.FirstKeyPos = int8(firstKeyPos)\n\n\t\tlastKeyPos, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmdInfo.LastKeyPos = int8(lastKeyPos)\n\n\t\tstepCount, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmdInfo.StepCount = int8(stepCount)\n\n\t\tif nn >= numArgRedis6 {\n\t\t\taclFlagLen, err := rd.ReadArrayLen()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcmdInfo.ACLFlags = make([]string, aclFlagLen)\n\t\t\tfor f := 0; f < len(cmdInfo.ACLFlags); f++ {\n\t\t\t\tswitch s, err := rd.ReadString(); {\n\t\t\t\tcase err == Nil:\n\t\t\t\t\tcmdInfo.ACLFlags[f] = \"\"\n\t\t\t\tcase err != nil:\n\t\t\t\t\treturn err\n\t\t\t\tdefault:\n\t\t\t\t\tcmdInfo.ACLFlags[f] = s\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif nn >= numArgRedis7 {\n\t\t\tif err := rd.DiscardNext(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := rd.DiscardNext(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := rd.DiscardNext(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tcmd.val[cmdInfo.Name] = cmdInfo\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype cmdsInfoCache struct {\n\tfn func(ctx context.Context) (map[string]*CommandInfo, error)\n\n\tonce internal.Once\n\tcmds map[string]*CommandInfo\n}\n\nfunc newCmdsInfoCache(fn func(ctx context.Context) (map[string]*CommandInfo, error)) *cmdsInfoCache {\n\treturn &cmdsInfoCache{\n\t\tfn: fn,\n\t}\n}\n\nfunc (c *cmdsInfoCache) Get(ctx context.Context) (map[string]*CommandInfo, error) {\n\terr := c.once.Do(func() error {\n\t\tcmds, err := c.fn(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Extensions have cmd names in upper case. Convert them to lower case.\n\t\tfor k, v := range cmds {\n\t\t\tlower := internal.ToLower(k)\n\t\t\tif lower != k {\n\t\t\t\tcmds[lower] = v\n\t\t\t}\n\t\t}\n\n\t\tc.cmds = cmds\n\t\treturn nil\n\t})\n\treturn c.cmds, err\n}\n\n//------------------------------------------------------------------------------\n\ntype SlowLog struct {\n\tID       int64\n\tTime     time.Time\n\tDuration time.Duration\n\tArgs     []string\n\t// These are also optional fields emitted only by Redis 4.0 or greater:\n\t// https://redis.io/commands/slowlog#output-format\n\tClientAddr string\n\tClientName string\n}\n\ntype SlowLogCmd struct {\n\tbaseCmd\n\n\tval []SlowLog\n}\n\nvar _ Cmder = (*SlowLogCmd)(nil)\n\nfunc NewSlowLogCmd(ctx context.Context, args ...interface{}) *SlowLogCmd {\n\treturn &SlowLogCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *SlowLogCmd) SetVal(val []SlowLog) {\n\tcmd.val = val\n}\n\nfunc (cmd *SlowLogCmd) Val() []SlowLog {\n\treturn cmd.val\n}\n\nfunc (cmd *SlowLogCmd) Result() ([]SlowLog, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *SlowLogCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *SlowLogCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]SlowLog, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tnn, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif nn < 4 {\n\t\t\treturn fmt.Errorf(\"redis: got %d elements in slowlog get, expected at least 4\", nn)\n\t\t}\n\n\t\tif cmd.val[i].ID, err = rd.ReadInt(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tcreatedAt, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[i].Time = time.Unix(createdAt, 0)\n\n\t\tcosts, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[i].Duration = time.Duration(costs) * time.Microsecond\n\n\t\tcmdLen, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif cmdLen < 1 {\n\t\t\treturn fmt.Errorf(\"redis: got %d elements commands reply in slowlog get, expected at least 1\", cmdLen)\n\t\t}\n\n\t\tcmd.val[i].Args = make([]string, cmdLen)\n\t\tfor f := 0; f < len(cmd.val[i].Args); f++ {\n\t\t\tcmd.val[i].Args[f], err = rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif nn >= 5 {\n\t\t\tif cmd.val[i].ClientAddr, err = rd.ReadString(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif nn >= 6 {\n\t\t\tif cmd.val[i].ClientName, err = rd.ReadString(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//-----------------------------------------------------------------------\n\ntype MapStringInterfaceCmd struct {\n\tbaseCmd\n\n\tval map[string]interface{}\n}\n\nvar _ Cmder = (*MapStringInterfaceCmd)(nil)\n\nfunc NewMapStringInterfaceCmd(ctx context.Context, args ...interface{}) *MapStringInterfaceCmd {\n\treturn &MapStringInterfaceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *MapStringInterfaceCmd) SetVal(val map[string]interface{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *MapStringInterfaceCmd) Val() map[string]interface{} {\n\treturn cmd.val\n}\n\nfunc (cmd *MapStringInterfaceCmd) Result() (map[string]interface{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *MapStringInterfaceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *MapStringInterfaceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make(map[string]interface{}, n)\n\tfor i := 0; i < n; i++ {\n\t\tk, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv, err := rd.ReadReply()\n\t\tif err != nil {\n\t\t\tif err == Nil {\n\t\t\t\tcmd.val[k] = Nil\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err, ok := err.(proto.RedisError); ok {\n\t\t\t\tcmd.val[k] = err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[k] = v\n\t}\n\treturn nil\n}\n\n//-----------------------------------------------------------------------\n\ntype MapStringStringSliceCmd struct {\n\tbaseCmd\n\n\tval []map[string]string\n}\n\nvar _ Cmder = (*MapStringStringSliceCmd)(nil)\n\nfunc NewMapStringStringSliceCmd(ctx context.Context, args ...interface{}) *MapStringStringSliceCmd {\n\treturn &MapStringStringSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *MapStringStringSliceCmd) SetVal(val []map[string]string) {\n\tcmd.val = val\n}\n\nfunc (cmd *MapStringStringSliceCmd) Val() []map[string]string {\n\treturn cmd.val\n}\n\nfunc (cmd *MapStringStringSliceCmd) Result() ([]map[string]string, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *MapStringStringSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *MapStringStringSliceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make([]map[string]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[i] = make(map[string]string, nn)\n\t\tfor f := 0; f < nn; f++ {\n\t\t\tk, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tv, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcmd.val[i][k] = v\n\t\t}\n\t}\n\treturn nil\n}\n\n// -----------------------------------------------------------------------\n// MapStringInterfaceCmd represents a command that returns a map of strings to interface{}.\ntype MapMapStringInterfaceCmd struct {\n\tbaseCmd\n\tval map[string]interface{}\n}\n\nfunc NewMapMapStringInterfaceCmd(ctx context.Context, args ...interface{}) *MapMapStringInterfaceCmd {\n\treturn &MapMapStringInterfaceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *MapMapStringInterfaceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *MapMapStringInterfaceCmd) SetVal(val map[string]interface{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *MapMapStringInterfaceCmd) Result() (map[string]interface{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *MapMapStringInterfaceCmd) Val() map[string]interface{} {\n\treturn cmd.val\n}\n\nfunc (cmd *MapMapStringInterfaceCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdata := make(map[string]interface{}, n/2)\n\tfor i := 0; i < n; i += 2 {\n\t\t_, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\tcmd.err = err\n\t\t}\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\tcmd.err = err\n\t\t}\n\t\tvalue, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\tcmd.err = err\n\t\t}\n\t\tdata[key] = value\n\t}\n\n\tcmd.val = data\n\treturn nil\n}\n\n//-----------------------------------------------------------------------\n\ntype MapStringInterfaceSliceCmd struct {\n\tbaseCmd\n\n\tval []map[string]interface{}\n}\n\nvar _ Cmder = (*MapStringInterfaceSliceCmd)(nil)\n\nfunc NewMapStringInterfaceSliceCmd(ctx context.Context, args ...interface{}) *MapStringInterfaceSliceCmd {\n\treturn &MapStringInterfaceSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *MapStringInterfaceSliceCmd) SetVal(val []map[string]interface{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *MapStringInterfaceSliceCmd) Val() []map[string]interface{} {\n\treturn cmd.val\n}\n\nfunc (cmd *MapStringInterfaceSliceCmd) Result() ([]map[string]interface{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *MapStringInterfaceSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *MapStringInterfaceSliceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make([]map[string]interface{}, n)\n\tfor i := 0; i < n; i++ {\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[i] = make(map[string]interface{}, nn)\n\t\tfor f := 0; f < nn; f++ {\n\t\t\tk, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tv, err := rd.ReadReply()\n\t\t\tif err != nil {\n\t\t\t\tif err != Nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tcmd.val[i][k] = v\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype KeyValuesCmd struct {\n\tbaseCmd\n\n\tkey string\n\tval []string\n}\n\nvar _ Cmder = (*KeyValuesCmd)(nil)\n\nfunc NewKeyValuesCmd(ctx context.Context, args ...interface{}) *KeyValuesCmd {\n\treturn &KeyValuesCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *KeyValuesCmd) SetVal(key string, val []string) {\n\tcmd.key = key\n\tcmd.val = val\n}\n\nfunc (cmd *KeyValuesCmd) Val() (string, []string) {\n\treturn cmd.key, cmd.val\n}\n\nfunc (cmd *KeyValuesCmd) Result() (string, []string, error) {\n\treturn cmd.key, cmd.val, cmd.err\n}\n\nfunc (cmd *KeyValuesCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *KeyValuesCmd) readReply(rd *proto.Reader) (err error) {\n\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\treturn err\n\t}\n\n\tcmd.key, err = rd.ReadString()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tcmd.val[i], err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype ZSliceWithKeyCmd struct {\n\tbaseCmd\n\n\tkey string\n\tval []Z\n}\n\nvar _ Cmder = (*ZSliceWithKeyCmd)(nil)\n\nfunc NewZSliceWithKeyCmd(ctx context.Context, args ...interface{}) *ZSliceWithKeyCmd {\n\treturn &ZSliceWithKeyCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ZSliceWithKeyCmd) SetVal(key string, val []Z) {\n\tcmd.key = key\n\tcmd.val = val\n}\n\nfunc (cmd *ZSliceWithKeyCmd) Val() (string, []Z) {\n\treturn cmd.key, cmd.val\n}\n\nfunc (cmd *ZSliceWithKeyCmd) Result() (string, []Z, error) {\n\treturn cmd.key, cmd.val, cmd.err\n}\n\nfunc (cmd *ZSliceWithKeyCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ZSliceWithKeyCmd) readReply(rd *proto.Reader) (err error) {\n\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\treturn err\n\t}\n\n\tcmd.key, err = rd.ReadString()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttyp, err := rd.PeekReplyType()\n\tif err != nil {\n\t\treturn err\n\t}\n\tarray := typ == proto.RespArray\n\n\tif array {\n\t\tcmd.val = make([]Z, n)\n\t} else {\n\t\tcmd.val = make([]Z, n/2)\n\t}\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tif array {\n\t\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif cmd.val[i].Member, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cmd.val[i].Score, err = rd.ReadFloat(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype Function struct {\n\tName        string\n\tDescription string\n\tFlags       []string\n}\n\ntype Library struct {\n\tName      string\n\tEngine    string\n\tFunctions []Function\n\tCode      string\n}\n\ntype FunctionListCmd struct {\n\tbaseCmd\n\n\tval []Library\n}\n\nvar _ Cmder = (*FunctionListCmd)(nil)\n\nfunc NewFunctionListCmd(ctx context.Context, args ...interface{}) *FunctionListCmd {\n\treturn &FunctionListCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *FunctionListCmd) SetVal(val []Library) {\n\tcmd.val = val\n}\n\nfunc (cmd *FunctionListCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FunctionListCmd) Val() []Library {\n\treturn cmd.val\n}\n\nfunc (cmd *FunctionListCmd) Result() ([]Library, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FunctionListCmd) First() (*Library, error) {\n\tif cmd.err != nil {\n\t\treturn nil, cmd.err\n\t}\n\tif len(cmd.val) > 0 {\n\t\treturn &cmd.val[0], nil\n\t}\n\treturn nil, Nil\n}\n\nfunc (cmd *FunctionListCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlibraries := make([]Library, n)\n\tfor i := 0; i < n; i++ {\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlibrary := Library{}\n\t\tfor f := 0; f < nn; f++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"library_name\":\n\t\t\t\tlibrary.Name, err = rd.ReadString()\n\t\t\tcase \"engine\":\n\t\t\t\tlibrary.Engine, err = rd.ReadString()\n\t\t\tcase \"functions\":\n\t\t\t\tlibrary.Functions, err = cmd.readFunctions(rd)\n\t\t\tcase \"library_code\":\n\t\t\t\tlibrary.Code, err = rd.ReadString()\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"redis: function list unexpected key %s\", key)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tlibraries[i] = library\n\t}\n\tcmd.val = libraries\n\treturn nil\n}\n\nfunc (cmd *FunctionListCmd) readFunctions(rd *proto.Reader) ([]Function, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfunctions := make([]Function, n)\n\tfor i := 0; i < n; i++ {\n\t\tnn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfunction := Function{}\n\t\tfor f := 0; f < nn; f++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"name\":\n\t\t\t\tif function.Name, err = rd.ReadString(); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"description\":\n\t\t\t\tif function.Description, err = rd.ReadString(); err != nil && err != Nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\tcase \"flags\":\n\t\t\t\t// resp set\n\t\t\t\tnx, err := rd.ReadArrayLen()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tfunction.Flags = make([]string, nx)\n\t\t\t\tfor j := 0; j < nx; j++ {\n\t\t\t\t\tif function.Flags[j], err = rd.ReadString(); err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"redis: function list unexpected key %s\", key)\n\t\t\t}\n\t\t}\n\n\t\tfunctions[i] = function\n\t}\n\treturn functions, nil\n}\n\n// FunctionStats contains information about the scripts currently executing on the server, and the available engines\n//   - Engines:\n//     Statistics about the engine like number of functions and number of libraries\n//   - RunningScript:\n//     The script currently running on the shard we're connecting to.\n//     For Redis Enterprise and Redis Cloud, this represents the\n//     function with the longest running time, across all the running functions, on all shards\n//   - RunningScripts\n//     All scripts currently running in a Redis Enterprise clustered database.\n//     Only available on Redis Enterprise\ntype FunctionStats struct {\n\tEngines   []Engine\n\tisRunning bool\n\trs        RunningScript\n\tallrs     []RunningScript\n}\n\nfunc (fs *FunctionStats) Running() bool {\n\treturn fs.isRunning\n}\n\nfunc (fs *FunctionStats) RunningScript() (RunningScript, bool) {\n\treturn fs.rs, fs.isRunning\n}\n\n// AllRunningScripts returns all scripts currently running in a Redis Enterprise clustered database.\n// Only available on Redis Enterprise\nfunc (fs *FunctionStats) AllRunningScripts() []RunningScript {\n\treturn fs.allrs\n}\n\ntype RunningScript struct {\n\tName     string\n\tCommand  []string\n\tDuration time.Duration\n}\n\ntype Engine struct {\n\tLanguage       string\n\tLibrariesCount int64\n\tFunctionsCount int64\n}\n\ntype FunctionStatsCmd struct {\n\tbaseCmd\n\tval FunctionStats\n}\n\nvar _ Cmder = (*FunctionStatsCmd)(nil)\n\nfunc NewFunctionStatsCmd(ctx context.Context, args ...interface{}) *FunctionStatsCmd {\n\treturn &FunctionStatsCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *FunctionStatsCmd) SetVal(val FunctionStats) {\n\tcmd.val = val\n}\n\nfunc (cmd *FunctionStatsCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FunctionStatsCmd) Val() FunctionStats {\n\treturn cmd.val\n}\n\nfunc (cmd *FunctionStatsCmd) Result() (FunctionStats, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FunctionStatsCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar key string\n\tvar result FunctionStats\n\tfor f := 0; f < n; f++ {\n\t\tkey, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"running_script\":\n\t\t\tresult.rs, result.isRunning, err = cmd.readRunningScript(rd)\n\t\tcase \"engines\":\n\t\t\tresult.Engines, err = cmd.readEngines(rd)\n\t\tcase \"all_running_scripts\": // Redis Enterprise only\n\t\t\tresult.allrs, result.isRunning, err = cmd.readRunningScripts(rd)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: function stats unexpected key %s\", key)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcmd.val = result\n\treturn nil\n}\n\nfunc (cmd *FunctionStatsCmd) readRunningScript(rd *proto.Reader) (RunningScript, bool, error) {\n\terr := rd.ReadFixedMapLen(3)\n\tif err != nil {\n\t\tif err == Nil {\n\t\t\treturn RunningScript{}, false, nil\n\t\t}\n\t\treturn RunningScript{}, false, err\n\t}\n\n\tvar runningScript RunningScript\n\tfor i := 0; i < 3; i++ {\n\t\tkey, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn RunningScript{}, false, err\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"name\":\n\t\t\trunningScript.Name, err = rd.ReadString()\n\t\tcase \"duration_ms\":\n\t\t\trunningScript.Duration, err = cmd.readDuration(rd)\n\t\tcase \"command\":\n\t\t\trunningScript.Command, err = cmd.readCommand(rd)\n\t\tdefault:\n\t\t\treturn RunningScript{}, false, fmt.Errorf(\"redis: function stats unexpected running_script key %s\", key)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn RunningScript{}, false, err\n\t\t}\n\t}\n\n\treturn runningScript, true, nil\n}\n\nfunc (cmd *FunctionStatsCmd) readEngines(rd *proto.Reader) ([]Engine, error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tengines := make([]Engine, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tengine := Engine{}\n\t\tengine.Language, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = rd.ReadFixedMapLen(2)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"redis: function stats unexpected %s engine map length\", engine.Language)\n\t\t}\n\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tswitch key {\n\t\t\tcase \"libraries_count\":\n\t\t\t\tengine.LibrariesCount, err = rd.ReadInt()\n\t\t\tcase \"functions_count\":\n\t\t\t\tengine.FunctionsCount, err = rd.ReadInt()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\tengines = append(engines, engine)\n\t}\n\treturn engines, nil\n}\n\nfunc (cmd *FunctionStatsCmd) readDuration(rd *proto.Reader) (time.Duration, error) {\n\tt, err := rd.ReadInt()\n\tif err != nil {\n\t\treturn time.Duration(0), err\n\t}\n\treturn time.Duration(t) * time.Millisecond, nil\n}\n\nfunc (cmd *FunctionStatsCmd) readCommand(rd *proto.Reader) ([]string, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcommand := make([]string, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tx, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcommand = append(command, x)\n\t}\n\n\treturn command, nil\n}\n\nfunc (cmd *FunctionStatsCmd) readRunningScripts(rd *proto.Reader) ([]RunningScript, bool, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\n\trunningScripts := make([]RunningScript, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\trs, _, err := cmd.readRunningScript(rd)\n\t\tif err != nil {\n\t\t\treturn nil, false, err\n\t\t}\n\t\trunningScripts = append(runningScripts, rs)\n\t}\n\n\treturn runningScripts, len(runningScripts) > 0, nil\n}\n\n//------------------------------------------------------------------------------\n\n// LCSQuery is a parameter used for the LCS command\ntype LCSQuery struct {\n\tKey1         string\n\tKey2         string\n\tLen          bool\n\tIdx          bool\n\tMinMatchLen  int\n\tWithMatchLen bool\n}\n\n// LCSMatch is the result set of the LCS command.\ntype LCSMatch struct {\n\tMatchString string\n\tMatches     []LCSMatchedPosition\n\tLen         int64\n}\n\ntype LCSMatchedPosition struct {\n\tKey1 LCSPosition\n\tKey2 LCSPosition\n\n\t// only for withMatchLen is true\n\tMatchLen int64\n}\n\ntype LCSPosition struct {\n\tStart int64\n\tEnd   int64\n}\n\ntype LCSCmd struct {\n\tbaseCmd\n\n\t// 1: match string\n\t// 2: match len\n\t// 3: match idx LCSMatch\n\treadType uint8\n\tval      *LCSMatch\n}\n\nfunc NewLCSCmd(ctx context.Context, q *LCSQuery) *LCSCmd {\n\targs := make([]interface{}, 3, 7)\n\targs[0] = \"lcs\"\n\targs[1] = q.Key1\n\targs[2] = q.Key2\n\n\tcmd := &LCSCmd{readType: 1}\n\tif q.Len {\n\t\tcmd.readType = 2\n\t\targs = append(args, \"len\")\n\t} else if q.Idx {\n\t\tcmd.readType = 3\n\t\targs = append(args, \"idx\")\n\t\tif q.MinMatchLen != 0 {\n\t\t\targs = append(args, \"minmatchlen\", q.MinMatchLen)\n\t\t}\n\t\tif q.WithMatchLen {\n\t\t\targs = append(args, \"withmatchlen\")\n\t\t}\n\t}\n\tcmd.baseCmd = baseCmd{\n\t\tctx:  ctx,\n\t\targs: args,\n\t}\n\n\treturn cmd\n}\n\nfunc (cmd *LCSCmd) SetVal(val *LCSMatch) {\n\tcmd.val = val\n}\n\nfunc (cmd *LCSCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *LCSCmd) Val() *LCSMatch {\n\treturn cmd.val\n}\n\nfunc (cmd *LCSCmd) Result() (*LCSMatch, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *LCSCmd) readReply(rd *proto.Reader) (err error) {\n\tlcs := &LCSMatch{}\n\tswitch cmd.readType {\n\tcase 1:\n\t\t// match string\n\t\tif lcs.MatchString, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase 2:\n\t\t// match len\n\t\tif lcs.Len, err = rd.ReadInt(); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase 3:\n\t\t// read LCSMatch\n\t\tif err = rd.ReadFixedMapLen(2); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// read matches or len field\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"matches\":\n\t\t\t\t// read array of matched positions\n\t\t\t\tif lcs.Matches, err = cmd.readMatchedPositions(rd); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase \"len\":\n\t\t\t\t// read match length\n\t\t\t\tif lcs.Len, err = rd.ReadInt(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd.val = lcs\n\treturn nil\n}\n\nfunc (cmd *LCSCmd) readMatchedPositions(rd *proto.Reader) ([]LCSMatchedPosition, error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tpositions := make([]LCSMatchedPosition, n)\n\tfor i := 0; i < n; i++ {\n\t\tpn, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif positions[i].Key1, err = cmd.readPosition(rd); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif positions[i].Key2, err = cmd.readPosition(rd); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// read match length if WithMatchLen is true\n\t\tif pn > 2 {\n\t\t\tif positions[i].MatchLen, err = rd.ReadInt(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn positions, nil\n}\n\nfunc (cmd *LCSCmd) readPosition(rd *proto.Reader) (pos LCSPosition, err error) {\n\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\treturn pos, err\n\t}\n\tif pos.Start, err = rd.ReadInt(); err != nil {\n\t\treturn pos, err\n\t}\n\tif pos.End, err = rd.ReadInt(); err != nil {\n\t\treturn pos, err\n\t}\n\n\treturn pos, nil\n}\n\n// ------------------------------------------------------------------------\n\ntype KeyFlags struct {\n\tKey   string\n\tFlags []string\n}\n\ntype KeyFlagsCmd struct {\n\tbaseCmd\n\n\tval []KeyFlags\n}\n\nvar _ Cmder = (*KeyFlagsCmd)(nil)\n\nfunc NewKeyFlagsCmd(ctx context.Context, args ...interface{}) *KeyFlagsCmd {\n\treturn &KeyFlagsCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *KeyFlagsCmd) SetVal(val []KeyFlags) {\n\tcmd.val = val\n}\n\nfunc (cmd *KeyFlagsCmd) Val() []KeyFlags {\n\treturn cmd.val\n}\n\nfunc (cmd *KeyFlagsCmd) Result() ([]KeyFlags, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *KeyFlagsCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *KeyFlagsCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif n == 0 {\n\t\tcmd.val = make([]KeyFlags, 0)\n\t\treturn nil\n\t}\n\n\tcmd.val = make([]KeyFlags, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\n\t\tif err = rd.ReadFixedArrayLen(2); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif cmd.val[i].Key, err = rd.ReadString(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tflagsLen, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[i].Flags = make([]string, flagsLen)\n\n\t\tfor j := 0; j < flagsLen; j++ {\n\t\t\tif cmd.val[i].Flags[j], err = rd.ReadString(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ---------------------------------------------------------------------------------------------------\n\ntype ClusterLink struct {\n\tDirection           string\n\tNode                string\n\tCreateTime          int64\n\tEvents              string\n\tSendBufferAllocated int64\n\tSendBufferUsed      int64\n}\n\ntype ClusterLinksCmd struct {\n\tbaseCmd\n\n\tval []ClusterLink\n}\n\nvar _ Cmder = (*ClusterLinksCmd)(nil)\n\nfunc NewClusterLinksCmd(ctx context.Context, args ...interface{}) *ClusterLinksCmd {\n\treturn &ClusterLinksCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ClusterLinksCmd) SetVal(val []ClusterLink) {\n\tcmd.val = val\n}\n\nfunc (cmd *ClusterLinksCmd) Val() []ClusterLink {\n\treturn cmd.val\n}\n\nfunc (cmd *ClusterLinksCmd) Result() ([]ClusterLink, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ClusterLinksCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ClusterLinksCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]ClusterLink, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tm, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor j := 0; j < m; j++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"direction\":\n\t\t\t\tcmd.val[i].Direction, err = rd.ReadString()\n\t\t\tcase \"node\":\n\t\t\t\tcmd.val[i].Node, err = rd.ReadString()\n\t\t\tcase \"create-time\":\n\t\t\t\tcmd.val[i].CreateTime, err = rd.ReadInt()\n\t\t\tcase \"events\":\n\t\t\t\tcmd.val[i].Events, err = rd.ReadString()\n\t\t\tcase \"send-buffer-allocated\":\n\t\t\t\tcmd.val[i].SendBufferAllocated, err = rd.ReadInt()\n\t\t\tcase \"send-buffer-used\":\n\t\t\t\tcmd.val[i].SendBufferUsed, err = rd.ReadInt()\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"redis: unexpected key %q in CLUSTER LINKS reply\", key)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// ------------------------------------------------------------------------------------------------------------------\n\ntype SlotRange struct {\n\tStart int64\n\tEnd   int64\n}\n\ntype Node struct {\n\tID                string\n\tEndpoint          string\n\tIP                string\n\tHostname          string\n\tPort              int64\n\tTLSPort           int64\n\tRole              string\n\tReplicationOffset int64\n\tHealth            string\n}\n\ntype ClusterShard struct {\n\tSlots []SlotRange\n\tNodes []Node\n}\n\ntype ClusterShardsCmd struct {\n\tbaseCmd\n\n\tval []ClusterShard\n}\n\nvar _ Cmder = (*ClusterShardsCmd)(nil)\n\nfunc NewClusterShardsCmd(ctx context.Context, args ...interface{}) *ClusterShardsCmd {\n\treturn &ClusterShardsCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ClusterShardsCmd) SetVal(val []ClusterShard) {\n\tcmd.val = val\n}\n\nfunc (cmd *ClusterShardsCmd) Val() []ClusterShard {\n\treturn cmd.val\n}\n\nfunc (cmd *ClusterShardsCmd) Result() ([]ClusterShard, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ClusterShardsCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ClusterShardsCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]ClusterShard, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tm, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor j := 0; j < m; j++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"slots\":\n\t\t\t\tl, err := rd.ReadArrayLen()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfor k := 0; k < l; k += 2 {\n\t\t\t\t\tstart, err := rd.ReadInt()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\tend, err := rd.ReadInt()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\tcmd.val[i].Slots = append(cmd.val[i].Slots, SlotRange{Start: start, End: end})\n\t\t\t\t}\n\t\t\tcase \"nodes\":\n\t\t\t\tnodesLen, err := rd.ReadArrayLen()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcmd.val[i].Nodes = make([]Node, nodesLen)\n\t\t\t\tfor k := 0; k < nodesLen; k++ {\n\t\t\t\t\tnodeMapLen, err := rd.ReadMapLen()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\tfor l := 0; l < nodeMapLen; l++ {\n\t\t\t\t\t\tnodeKey, err := rd.ReadString()\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch nodeKey {\n\t\t\t\t\t\tcase \"id\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].ID, err = rd.ReadString()\n\t\t\t\t\t\tcase \"endpoint\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].Endpoint, err = rd.ReadString()\n\t\t\t\t\t\tcase \"ip\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].IP, err = rd.ReadString()\n\t\t\t\t\t\tcase \"hostname\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].Hostname, err = rd.ReadString()\n\t\t\t\t\t\tcase \"port\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].Port, err = rd.ReadInt()\n\t\t\t\t\t\tcase \"tls-port\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].TLSPort, err = rd.ReadInt()\n\t\t\t\t\t\tcase \"role\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].Role, err = rd.ReadString()\n\t\t\t\t\t\tcase \"replication-offset\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].ReplicationOffset, err = rd.ReadInt()\n\t\t\t\t\t\tcase \"health\":\n\t\t\t\t\t\t\tcmd.val[i].Nodes[k].Health, err = rd.ReadString()\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn fmt.Errorf(\"redis: unexpected key %q in CLUSTER SHARDS node reply\", nodeKey)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"redis: unexpected key %q in CLUSTER SHARDS reply\", key)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// -----------------------------------------\n\ntype RankScore struct {\n\tRank  int64\n\tScore float64\n}\n\ntype RankWithScoreCmd struct {\n\tbaseCmd\n\n\tval RankScore\n}\n\nvar _ Cmder = (*RankWithScoreCmd)(nil)\n\nfunc NewRankWithScoreCmd(ctx context.Context, args ...interface{}) *RankWithScoreCmd {\n\treturn &RankWithScoreCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *RankWithScoreCmd) SetVal(val RankScore) {\n\tcmd.val = val\n}\n\nfunc (cmd *RankWithScoreCmd) Val() RankScore {\n\treturn cmd.val\n}\n\nfunc (cmd *RankWithScoreCmd) Result() (RankScore, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *RankWithScoreCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *RankWithScoreCmd) readReply(rd *proto.Reader) error {\n\tif err := rd.ReadFixedArrayLen(2); err != nil {\n\t\treturn err\n\t}\n\n\trank, err := rd.ReadInt()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tscore, err := rd.ReadFloat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = RankScore{Rank: rank, Score: score}\n\n\treturn nil\n}\n\n// --------------------------------------------------------------------------------------------------\n\n// ClientFlags is redis-server client flags, copy from redis/src/server.h (redis 7.0)\ntype ClientFlags uint64\n\nconst (\n\tClientSlave            ClientFlags = 1 << 0  /* This client is a replica */\n\tClientMaster           ClientFlags = 1 << 1  /* This client is a master */\n\tClientMonitor          ClientFlags = 1 << 2  /* This client is a slave monitor, see MONITOR */\n\tClientMulti            ClientFlags = 1 << 3  /* This client is in a MULTI context */\n\tClientBlocked          ClientFlags = 1 << 4  /* The client is waiting in a blocking operation */\n\tClientDirtyCAS         ClientFlags = 1 << 5  /* Watched keys modified. EXEC will fail. */\n\tClientCloseAfterReply  ClientFlags = 1 << 6  /* Close after writing entire reply. */\n\tClientUnBlocked        ClientFlags = 1 << 7  /* This client was unblocked and is stored in server.unblocked_clients */\n\tClientScript           ClientFlags = 1 << 8  /* This is a non-connected client used by Lua */\n\tClientAsking           ClientFlags = 1 << 9  /* Client issued the ASKING command */\n\tClientCloseASAP        ClientFlags = 1 << 10 /* Close this client ASAP */\n\tClientUnixSocket       ClientFlags = 1 << 11 /* Client connected via Unix domain socket */\n\tClientDirtyExec        ClientFlags = 1 << 12 /* EXEC will fail for errors while queueing */\n\tClientMasterForceReply ClientFlags = 1 << 13 /* Queue replies even if is master */\n\tClientForceAOF         ClientFlags = 1 << 14 /* Force AOF propagation of current cmd. */\n\tClientForceRepl        ClientFlags = 1 << 15 /* Force replication of current cmd. */\n\tClientPrePSync         ClientFlags = 1 << 16 /* Instance don't understand PSYNC. */\n\tClientReadOnly         ClientFlags = 1 << 17 /* Cluster client is in read-only state. */\n\tClientPubSub           ClientFlags = 1 << 18 /* Client is in Pub/Sub mode. */\n\tClientPreventAOFProp   ClientFlags = 1 << 19 /* Don't propagate to AOF. */\n\tClientPreventReplProp  ClientFlags = 1 << 20 /* Don't propagate to slaves. */\n\tClientPreventProp      ClientFlags = ClientPreventAOFProp | ClientPreventReplProp\n\tClientPendingWrite     ClientFlags = 1 << 21 /* Client has output to send but a-write handler is yet not installed. */\n\tClientReplyOff         ClientFlags = 1 << 22 /* Don't send replies to client. */\n\tClientReplySkipNext    ClientFlags = 1 << 23 /* Set ClientREPLY_SKIP for next cmd */\n\tClientReplySkip        ClientFlags = 1 << 24 /* Don't send just this reply. */\n\tClientLuaDebug         ClientFlags = 1 << 25 /* Run EVAL in debug mode. */\n\tClientLuaDebugSync     ClientFlags = 1 << 26 /* EVAL debugging without fork() */\n\tClientModule           ClientFlags = 1 << 27 /* Non connected client used by some module. */\n\tClientProtected        ClientFlags = 1 << 28 /* Client should not be freed for now. */\n\tClientExecutingCommand ClientFlags = 1 << 29 /* Indicates that the client is currently in the process of handling\n\t   a command. usually this will be marked only during call()\n\t   however, blocked clients might have this flag kept until they\n\t   will try to reprocess the command. */\n\tClientPendingCommand      ClientFlags = 1 << 30 /* Indicates the client has a fully * parsed command ready for execution. */\n\tClientTracking            ClientFlags = 1 << 31 /* Client enabled keys tracking in order to perform client side caching. */\n\tClientTrackingBrokenRedir ClientFlags = 1 << 32 /* Target client is invalid. */\n\tClientTrackingBCAST       ClientFlags = 1 << 33 /* Tracking in BCAST mode. */\n\tClientTrackingOptIn       ClientFlags = 1 << 34 /* Tracking in opt-in mode. */\n\tClientTrackingOptOut      ClientFlags = 1 << 35 /* Tracking in opt-out mode. */\n\tClientTrackingCaching     ClientFlags = 1 << 36 /* CACHING yes/no was given, depending on optin/optout mode. */\n\tClientTrackingNoLoop      ClientFlags = 1 << 37 /* Don't send invalidation messages about writes performed by myself.*/\n\tClientInTimeoutTable      ClientFlags = 1 << 38 /* This client is in the timeout table. */\n\tClientProtocolError       ClientFlags = 1 << 39 /* Protocol error chatting with it. */\n\tClientCloseAfterCommand   ClientFlags = 1 << 40 /* Close after executing commands * and writing entire reply. */\n\tClientDenyBlocking        ClientFlags = 1 << 41 /* Indicate that the client should not be blocked. currently, turned on inside MULTI, Lua, RM_Call, and AOF client */\n\tClientReplRDBOnly         ClientFlags = 1 << 42 /* This client is a replica that only wants RDB without replication buffer. */\n\tClientNoEvict             ClientFlags = 1 << 43 /* This client is protected against client memory eviction. */\n\tClientAllowOOM            ClientFlags = 1 << 44 /* Client used by RM_Call is allowed to fully execute scripts even when in OOM */\n\tClientNoTouch             ClientFlags = 1 << 45 /* This client will not touch LFU/LRU stats. */\n\tClientPushing             ClientFlags = 1 << 46 /* This client is pushing notifications. */\n)\n\n// ClientInfo is redis-server ClientInfo, not go-redis *Client\ntype ClientInfo struct {\n\tID                 int64         // redis version 2.8.12, a unique 64-bit client ID\n\tAddr               string        // address/port of the client\n\tLAddr              string        // address/port of local address client connected to (bind address)\n\tFD                 int64         // file descriptor corresponding to the socket\n\tName               string        // the name set by the client with CLIENT SETNAME\n\tAge                time.Duration // total duration of the connection in seconds\n\tIdle               time.Duration // idle time of the connection in seconds\n\tFlags              ClientFlags   // client flags (see below)\n\tDB                 int           // current database ID\n\tSub                int           // number of channel subscriptions\n\tPSub               int           // number of pattern matching subscriptions\n\tSSub               int           // redis version 7.0.3, number of shard channel subscriptions\n\tMulti              int           // number of commands in a MULTI/EXEC context\n\tWatch              int           // redis version 7.4 RC1, number of keys this client is currently watching.\n\tQueryBuf           int           // qbuf, query buffer length (0 means no query pending)\n\tQueryBufFree       int           // qbuf-free, free space of the query buffer (0 means the buffer is full)\n\tArgvMem            int           // incomplete arguments for the next command (already extracted from query buffer)\n\tMultiMem           int           // redis version 7.0, memory is used up by buffered multi commands\n\tBufferSize         int           // rbs, usable size of buffer\n\tBufferPeak         int           // rbp, peak used size of buffer in last 5 sec interval\n\tOutputBufferLength int           // obl, output buffer length\n\tOutputListLength   int           // oll, output list length (replies are queued in this list when the buffer is full)\n\tOutputMemory       int           // omem, output buffer memory usage\n\tTotalMemory        int           // tot-mem, total memory consumed by this client in its various buffers\n\tEvents             string        // file descriptor events (see below)\n\tLastCmd            string        // cmd, last command played\n\tUser               string        // the authenticated username of the client\n\tRedir              int64         // client id of current client tracking redirection\n\tResp               int           // redis version 7.0, client RESP protocol version\n\tLibName            string        // redis version 7.2, client library name\n\tLibVer             string        // redis version 7.2, client library version\n}\n\ntype ClientInfoCmd struct {\n\tbaseCmd\n\n\tval *ClientInfo\n}\n\nvar _ Cmder = (*ClientInfoCmd)(nil)\n\nfunc NewClientInfoCmd(ctx context.Context, args ...interface{}) *ClientInfoCmd {\n\treturn &ClientInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ClientInfoCmd) SetVal(val *ClientInfo) {\n\tcmd.val = val\n}\n\nfunc (cmd *ClientInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ClientInfoCmd) Val() *ClientInfo {\n\treturn cmd.val\n}\n\nfunc (cmd *ClientInfoCmd) Result() (*ClientInfo, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ClientInfoCmd) readReply(rd *proto.Reader) (err error) {\n\ttxt, err := rd.ReadString()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// sds o = catClientInfoString(sdsempty(), c);\n\t// o = sdscatlen(o,\"\\n\",1);\n\t// addReplyVerbatim(c,o,sdslen(o),\"txt\");\n\t// sdsfree(o);\n\tcmd.val, err = parseClientInfo(strings.TrimSpace(txt))\n\treturn err\n}\n\n// fmt.Sscanf() cannot handle null values\nfunc parseClientInfo(txt string) (info *ClientInfo, err error) {\n\tinfo = &ClientInfo{}\n\tfor _, s := range strings.Split(txt, \" \") {\n\t\tkv := strings.Split(s, \"=\")\n\t\tif len(kv) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"redis: unexpected client info data (%s)\", s)\n\t\t}\n\t\tkey, val := kv[0], kv[1]\n\n\t\tswitch key {\n\t\tcase \"id\":\n\t\t\tinfo.ID, err = strconv.ParseInt(val, 10, 64)\n\t\tcase \"addr\":\n\t\t\tinfo.Addr = val\n\t\tcase \"laddr\":\n\t\t\tinfo.LAddr = val\n\t\tcase \"fd\":\n\t\t\tinfo.FD, err = strconv.ParseInt(val, 10, 64)\n\t\tcase \"name\":\n\t\t\tinfo.Name = val\n\t\tcase \"age\":\n\t\t\tvar age int\n\t\t\tif age, err = strconv.Atoi(val); err == nil {\n\t\t\t\tinfo.Age = time.Duration(age) * time.Second\n\t\t\t}\n\t\tcase \"idle\":\n\t\t\tvar idle int\n\t\t\tif idle, err = strconv.Atoi(val); err == nil {\n\t\t\t\tinfo.Idle = time.Duration(idle) * time.Second\n\t\t\t}\n\t\tcase \"flags\":\n\t\t\tif val == \"N\" {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfor i := 0; i < len(val); i++ {\n\t\t\t\tswitch val[i] {\n\t\t\t\tcase 'S':\n\t\t\t\t\tinfo.Flags |= ClientSlave\n\t\t\t\tcase 'O':\n\t\t\t\t\tinfo.Flags |= ClientSlave | ClientMonitor\n\t\t\t\tcase 'M':\n\t\t\t\t\tinfo.Flags |= ClientMaster\n\t\t\t\tcase 'P':\n\t\t\t\t\tinfo.Flags |= ClientPubSub\n\t\t\t\tcase 'x':\n\t\t\t\t\tinfo.Flags |= ClientMulti\n\t\t\t\tcase 'b':\n\t\t\t\t\tinfo.Flags |= ClientBlocked\n\t\t\t\tcase 't':\n\t\t\t\t\tinfo.Flags |= ClientTracking\n\t\t\t\tcase 'R':\n\t\t\t\t\tinfo.Flags |= ClientTrackingBrokenRedir\n\t\t\t\tcase 'B':\n\t\t\t\t\tinfo.Flags |= ClientTrackingBCAST\n\t\t\t\tcase 'd':\n\t\t\t\t\tinfo.Flags |= ClientDirtyCAS\n\t\t\t\tcase 'c':\n\t\t\t\t\tinfo.Flags |= ClientCloseAfterCommand\n\t\t\t\tcase 'u':\n\t\t\t\t\tinfo.Flags |= ClientUnBlocked\n\t\t\t\tcase 'A':\n\t\t\t\t\tinfo.Flags |= ClientCloseASAP\n\t\t\t\tcase 'U':\n\t\t\t\t\tinfo.Flags |= ClientUnixSocket\n\t\t\t\tcase 'r':\n\t\t\t\t\tinfo.Flags |= ClientReadOnly\n\t\t\t\tcase 'e':\n\t\t\t\t\tinfo.Flags |= ClientNoEvict\n\t\t\t\tcase 'T':\n\t\t\t\t\tinfo.Flags |= ClientNoTouch\n\t\t\t\tdefault:\n\t\t\t\t\treturn nil, fmt.Errorf(\"redis: unexpected client info flags(%s)\", string(val[i]))\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"db\":\n\t\t\tinfo.DB, err = strconv.Atoi(val)\n\t\tcase \"sub\":\n\t\t\tinfo.Sub, err = strconv.Atoi(val)\n\t\tcase \"psub\":\n\t\t\tinfo.PSub, err = strconv.Atoi(val)\n\t\tcase \"ssub\":\n\t\t\tinfo.SSub, err = strconv.Atoi(val)\n\t\tcase \"multi\":\n\t\t\tinfo.Multi, err = strconv.Atoi(val)\n\t\tcase \"watch\":\n\t\t\tinfo.Watch, err = strconv.Atoi(val)\n\t\tcase \"qbuf\":\n\t\t\tinfo.QueryBuf, err = strconv.Atoi(val)\n\t\tcase \"qbuf-free\":\n\t\t\tinfo.QueryBufFree, err = strconv.Atoi(val)\n\t\tcase \"argv-mem\":\n\t\t\tinfo.ArgvMem, err = strconv.Atoi(val)\n\t\tcase \"multi-mem\":\n\t\t\tinfo.MultiMem, err = strconv.Atoi(val)\n\t\tcase \"rbs\":\n\t\t\tinfo.BufferSize, err = strconv.Atoi(val)\n\t\tcase \"rbp\":\n\t\t\tinfo.BufferPeak, err = strconv.Atoi(val)\n\t\tcase \"obl\":\n\t\t\tinfo.OutputBufferLength, err = strconv.Atoi(val)\n\t\tcase \"oll\":\n\t\t\tinfo.OutputListLength, err = strconv.Atoi(val)\n\t\tcase \"omem\":\n\t\t\tinfo.OutputMemory, err = strconv.Atoi(val)\n\t\tcase \"tot-mem\":\n\t\t\tinfo.TotalMemory, err = strconv.Atoi(val)\n\t\tcase \"events\":\n\t\t\tinfo.Events = val\n\t\tcase \"cmd\":\n\t\t\tinfo.LastCmd = val\n\t\tcase \"user\":\n\t\t\tinfo.User = val\n\t\tcase \"redir\":\n\t\t\tinfo.Redir, err = strconv.ParseInt(val, 10, 64)\n\t\tcase \"resp\":\n\t\t\tinfo.Resp, err = strconv.Atoi(val)\n\t\tcase \"lib-name\":\n\t\t\tinfo.LibName = val\n\t\tcase \"lib-ver\":\n\t\t\tinfo.LibVer = val\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"redis: unexpected client info key(%s)\", key)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn info, nil\n}\n\n// -------------------------------------------\n\ntype ACLLogEntry struct {\n\tCount                int64\n\tReason               string\n\tContext              string\n\tObject               string\n\tUsername             string\n\tAgeSeconds           float64\n\tClientInfo           *ClientInfo\n\tEntryID              int64\n\tTimestampCreated     int64\n\tTimestampLastUpdated int64\n}\n\ntype ACLLogCmd struct {\n\tbaseCmd\n\n\tval []*ACLLogEntry\n}\n\nvar _ Cmder = (*ACLLogCmd)(nil)\n\nfunc NewACLLogCmd(ctx context.Context, args ...interface{}) *ACLLogCmd {\n\treturn &ACLLogCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ACLLogCmd) SetVal(val []*ACLLogEntry) {\n\tcmd.val = val\n}\n\nfunc (cmd *ACLLogCmd) Val() []*ACLLogEntry {\n\treturn cmd.val\n}\n\nfunc (cmd *ACLLogCmd) Result() ([]*ACLLogEntry, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ACLLogCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ACLLogCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcmd.val = make([]*ACLLogEntry, n)\n\tfor i := 0; i < n; i++ {\n\t\tcmd.val[i] = &ACLLogEntry{}\n\t\tentry := cmd.val[i]\n\t\trespLen, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor j := 0; j < respLen; j++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch key {\n\t\t\tcase \"count\":\n\t\t\t\tentry.Count, err = rd.ReadInt()\n\t\t\tcase \"reason\":\n\t\t\t\tentry.Reason, err = rd.ReadString()\n\t\t\tcase \"context\":\n\t\t\t\tentry.Context, err = rd.ReadString()\n\t\t\tcase \"object\":\n\t\t\t\tentry.Object, err = rd.ReadString()\n\t\t\tcase \"username\":\n\t\t\t\tentry.Username, err = rd.ReadString()\n\t\t\tcase \"age-seconds\":\n\t\t\t\tentry.AgeSeconds, err = rd.ReadFloat()\n\t\t\tcase \"client-info\":\n\t\t\t\ttxt, err := rd.ReadString()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tentry.ClientInfo, err = parseClientInfo(strings.TrimSpace(txt))\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\tcase \"entry-id\":\n\t\t\t\tentry.EntryID, err = rd.ReadInt()\n\t\t\tcase \"timestamp-created\":\n\t\t\t\tentry.TimestampCreated, err = rd.ReadInt()\n\t\t\tcase \"timestamp-last-updated\":\n\t\t\t\tentry.TimestampLastUpdated, err = rd.ReadInt()\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"redis: unexpected key %q in ACL LOG reply\", key)\n\t\t\t}\n\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// LibraryInfo holds the library info.\ntype LibraryInfo struct {\n\tLibName *string\n\tLibVer  *string\n}\n\n// WithLibraryName returns a valid LibraryInfo with library name only.\nfunc WithLibraryName(libName string) LibraryInfo {\n\treturn LibraryInfo{LibName: &libName}\n}\n\n// WithLibraryVersion returns a valid LibraryInfo with library version only.\nfunc WithLibraryVersion(libVer string) LibraryInfo {\n\treturn LibraryInfo{LibVer: &libVer}\n}\n\n// -------------------------------------------\n\ntype InfoCmd struct {\n\tbaseCmd\n\tval map[string]map[string]string\n}\n\nvar _ Cmder = (*InfoCmd)(nil)\n\nfunc NewInfoCmd(ctx context.Context, args ...interface{}) *InfoCmd {\n\treturn &InfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *InfoCmd) SetVal(val map[string]map[string]string) {\n\tcmd.val = val\n}\n\nfunc (cmd *InfoCmd) Val() map[string]map[string]string {\n\treturn cmd.val\n}\n\nfunc (cmd *InfoCmd) Result() (map[string]map[string]string, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *InfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *InfoCmd) readReply(rd *proto.Reader) error {\n\tval, err := rd.ReadString()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsection := \"\"\n\tscanner := bufio.NewScanner(strings.NewReader(val))\n\tmoduleRe := regexp.MustCompile(`module:name=(.+?),(.+)$`)\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.HasPrefix(line, \"#\") {\n\t\t\tif cmd.val == nil {\n\t\t\t\tcmd.val = make(map[string]map[string]string)\n\t\t\t}\n\t\t\tsection = strings.TrimPrefix(line, \"# \")\n\t\t\tcmd.val[section] = make(map[string]string)\n\t\t} else if line != \"\" {\n\t\t\tif section == \"Modules\" {\n\t\t\t\tkv := moduleRe.FindStringSubmatch(line)\n\t\t\t\tif len(kv) == 3 {\n\t\t\t\t\tcmd.val[section][kv[1]] = kv[2]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkv := strings.SplitN(line, \":\", 2)\n\t\t\t\tif len(kv) == 2 {\n\t\t\t\t\tcmd.val[section][kv[0]] = kv[1]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (cmd *InfoCmd) Item(section, key string) string {\n\tif cmd.val == nil {\n\t\treturn \"\"\n\t} else if cmd.val[section] == nil {\n\t\treturn \"\"\n\t} else {\n\t\treturn cmd.val[section][key]\n\t}\n}\n\ntype MonitorStatus int\n\nconst (\n\tmonitorStatusIdle MonitorStatus = iota\n\tmonitorStatusStart\n\tmonitorStatusStop\n)\n\ntype MonitorCmd struct {\n\tbaseCmd\n\tch     chan string\n\tstatus MonitorStatus\n\tmu     sync.Mutex\n}\n\nfunc newMonitorCmd(ctx context.Context, ch chan string) *MonitorCmd {\n\treturn &MonitorCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: []interface{}{\"monitor\"},\n\t\t},\n\t\tch:     ch,\n\t\tstatus: monitorStatusIdle,\n\t\tmu:     sync.Mutex{},\n\t}\n}\n\nfunc (cmd *MonitorCmd) String() string {\n\treturn cmdString(cmd, nil)\n}\n\nfunc (cmd *MonitorCmd) readReply(rd *proto.Reader) error {\n\tctx, cancel := context.WithCancel(cmd.ctx)\n\tgo func(ctx context.Context) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\terr := cmd.readMonitor(rd, cancel)\n\t\t\t\tif err != nil {\n\t\t\t\t\tcmd.err = err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}(ctx)\n\treturn nil\n}\n\nfunc (cmd *MonitorCmd) readMonitor(rd *proto.Reader, cancel context.CancelFunc) error {\n\tfor {\n\t\tcmd.mu.Lock()\n\t\tst := cmd.status\n\t\tpk, _ := rd.Peek(1)\n\t\tcmd.mu.Unlock()\n\t\tif len(pk) != 0 && st == monitorStatusStart {\n\t\t\tcmd.mu.Lock()\n\t\t\tline, err := rd.ReadString()\n\t\t\tcmd.mu.Unlock()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcmd.ch <- line\n\t\t}\n\t\tif st == monitorStatusStop {\n\t\t\tcancel()\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (cmd *MonitorCmd) Start() {\n\tcmd.mu.Lock()\n\tdefer cmd.mu.Unlock()\n\tcmd.status = monitorStatusStart\n}\n\nfunc (cmd *MonitorCmd) Stop() {\n\tcmd.mu.Lock()\n\tdefer cmd.mu.Unlock()\n\tcmd.status = monitorStatusStop\n}\n"
        },
        {
          "name": "command_test.go",
          "type": "blob",
          "size": 2.265625,
          "content": "package redis_test\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n)\n\nvar _ = Describe(\"Cmd\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"implements Stringer\", func() {\n\t\tset := client.Set(ctx, \"foo\", \"bar\", 0)\n\t\tExpect(set.String()).To(Equal(\"set foo bar: OK\"))\n\n\t\tget := client.Get(ctx, \"foo\")\n\t\tExpect(get.String()).To(Equal(\"get foo: bar\"))\n\t})\n\n\tIt(\"has val/err\", func() {\n\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\tget := client.Get(ctx, \"key\")\n\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\tExpect(get.Val()).To(Equal(\"hello\"))\n\n\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\t})\n\n\tIt(\"has helpers\", func() {\n\t\tset := client.Set(ctx, \"key\", \"10\", 0)\n\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\n\t\tn, err := client.Get(ctx, \"key\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(10)))\n\n\t\tun, err := client.Get(ctx, \"key\").Uint64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(un).To(Equal(uint64(10)))\n\n\t\tf, err := client.Get(ctx, \"key\").Float64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(f).To(Equal(float64(10)))\n\t})\n\n\tIt(\"supports float32\", func() {\n\t\tf := float32(66.97)\n\n\t\terr := client.Set(ctx, \"float_key\", f, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tval, err := client.Get(ctx, \"float_key\").Float32()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(f))\n\t})\n\n\tIt(\"supports time.Time\", func() {\n\t\ttm := time.Date(2019, 1, 1, 9, 45, 10, 222125, time.UTC)\n\n\t\terr := client.Set(ctx, \"time_key\", tm, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\ts, err := client.Get(ctx, \"time_key\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(s).To(Equal(\"2019-01-01T09:45:10.000222125Z\"))\n\n\t\ttm2, err := client.Get(ctx, \"time_key\").Time()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(tm2).To(BeTemporally(\"==\", tm))\n\t})\n\n\tIt(\"allows to set custom error\", func() {\n\t\te := errors.New(\"custom error\")\n\t\tcmd := redis.Cmd{}\n\t\tcmd.SetErr(e)\n\t\t_, err := cmd.Result()\n\t\tExpect(err).To(Equal(e))\n\t})\n})\n"
        },
        {
          "name": "commands.go",
          "type": "blob",
          "size": 19.236328125,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"encoding\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n)\n\n// KeepTTL is a Redis KEEPTTL option to keep existing TTL, it requires your redis-server version >= 6.0,\n// otherwise you will receive an error: (error) ERR syntax error.\n// For example:\n//\n//\trdb.Set(ctx, key, value, redis.KeepTTL)\nconst KeepTTL = -1\n\nfunc usePrecise(dur time.Duration) bool {\n\treturn dur < time.Second || dur%time.Second != 0\n}\n\nfunc formatMs(ctx context.Context, dur time.Duration) int64 {\n\tif dur > 0 && dur < time.Millisecond {\n\t\tinternal.Logger.Printf(\n\t\t\tctx,\n\t\t\t\"specified duration is %s, but minimal supported value is %s - truncating to 1ms\",\n\t\t\tdur, time.Millisecond,\n\t\t)\n\t\treturn 1\n\t}\n\treturn int64(dur / time.Millisecond)\n}\n\nfunc formatSec(ctx context.Context, dur time.Duration) int64 {\n\tif dur > 0 && dur < time.Second {\n\t\tinternal.Logger.Printf(\n\t\t\tctx,\n\t\t\t\"specified duration is %s, but minimal supported value is %s - truncating to 1s\",\n\t\t\tdur, time.Second,\n\t\t)\n\t\treturn 1\n\t}\n\treturn int64(dur / time.Second)\n}\n\nfunc appendArgs(dst, src []interface{}) []interface{} {\n\tif len(src) == 1 {\n\t\treturn appendArg(dst, src[0])\n\t}\n\n\tdst = append(dst, src...)\n\treturn dst\n}\n\nfunc appendArg(dst []interface{}, arg interface{}) []interface{} {\n\tswitch arg := arg.(type) {\n\tcase []string:\n\t\tfor _, s := range arg {\n\t\t\tdst = append(dst, s)\n\t\t}\n\t\treturn dst\n\tcase []interface{}:\n\t\tdst = append(dst, arg...)\n\t\treturn dst\n\tcase map[string]interface{}:\n\t\tfor k, v := range arg {\n\t\t\tdst = append(dst, k, v)\n\t\t}\n\t\treturn dst\n\tcase map[string]string:\n\t\tfor k, v := range arg {\n\t\t\tdst = append(dst, k, v)\n\t\t}\n\t\treturn dst\n\tcase time.Time, time.Duration, encoding.BinaryMarshaler, net.IP:\n\t\treturn append(dst, arg)\n\tdefault:\n\t\t// scan struct field\n\t\tv := reflect.ValueOf(arg)\n\t\tif v.Type().Kind() == reflect.Ptr {\n\t\t\tif v.IsNil() {\n\t\t\t\t// error: arg is not a valid object\n\t\t\t\treturn dst\n\t\t\t}\n\t\t\tv = v.Elem()\n\t\t}\n\n\t\tif v.Type().Kind() == reflect.Struct {\n\t\t\treturn appendStructField(dst, v)\n\t\t}\n\n\t\treturn append(dst, arg)\n\t}\n}\n\n// appendStructField appends the field and value held by the structure v to dst, and returns the appended dst.\nfunc appendStructField(dst []interface{}, v reflect.Value) []interface{} {\n\ttyp := v.Type()\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\ttag := typ.Field(i).Tag.Get(\"redis\")\n\t\tif tag == \"\" || tag == \"-\" {\n\t\t\tcontinue\n\t\t}\n\t\tname, opt, _ := strings.Cut(tag, \",\")\n\t\tif name == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfield := v.Field(i)\n\n\t\t// miss field\n\t\tif omitEmpty(opt) && isEmptyValue(field) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif field.CanInterface() {\n\t\t\tdst = append(dst, name, field.Interface())\n\t\t}\n\t}\n\n\treturn dst\n}\n\nfunc omitEmpty(opt string) bool {\n\tfor opt != \"\" {\n\t\tvar name string\n\t\tname, opt, _ = strings.Cut(opt, \",\")\n\t\tif name == \"omitempty\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc isEmptyValue(v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.Len() == 0\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Interface, reflect.Pointer:\n\t\treturn v.IsNil()\n\t}\n\treturn false\n}\n\ntype Cmdable interface {\n\tPipeline() Pipeliner\n\tPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error)\n\n\tTxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error)\n\tTxPipeline() Pipeliner\n\n\tCommand(ctx context.Context) *CommandsInfoCmd\n\tCommandList(ctx context.Context, filter *FilterBy) *StringSliceCmd\n\tCommandGetKeys(ctx context.Context, commands ...interface{}) *StringSliceCmd\n\tCommandGetKeysAndFlags(ctx context.Context, commands ...interface{}) *KeyFlagsCmd\n\tClientGetName(ctx context.Context) *StringCmd\n\tEcho(ctx context.Context, message interface{}) *StringCmd\n\tPing(ctx context.Context) *StatusCmd\n\tQuit(ctx context.Context) *StatusCmd\n\tUnlink(ctx context.Context, keys ...string) *IntCmd\n\n\tBgRewriteAOF(ctx context.Context) *StatusCmd\n\tBgSave(ctx context.Context) *StatusCmd\n\tClientKill(ctx context.Context, ipPort string) *StatusCmd\n\tClientKillByFilter(ctx context.Context, keys ...string) *IntCmd\n\tClientList(ctx context.Context) *StringCmd\n\tClientInfo(ctx context.Context) *ClientInfoCmd\n\tClientPause(ctx context.Context, dur time.Duration) *BoolCmd\n\tClientUnpause(ctx context.Context) *BoolCmd\n\tClientID(ctx context.Context) *IntCmd\n\tClientUnblock(ctx context.Context, id int64) *IntCmd\n\tClientUnblockWithError(ctx context.Context, id int64) *IntCmd\n\tConfigGet(ctx context.Context, parameter string) *MapStringStringCmd\n\tConfigResetStat(ctx context.Context) *StatusCmd\n\tConfigSet(ctx context.Context, parameter, value string) *StatusCmd\n\tConfigRewrite(ctx context.Context) *StatusCmd\n\tDBSize(ctx context.Context) *IntCmd\n\tFlushAll(ctx context.Context) *StatusCmd\n\tFlushAllAsync(ctx context.Context) *StatusCmd\n\tFlushDB(ctx context.Context) *StatusCmd\n\tFlushDBAsync(ctx context.Context) *StatusCmd\n\tInfo(ctx context.Context, section ...string) *StringCmd\n\tLastSave(ctx context.Context) *IntCmd\n\tSave(ctx context.Context) *StatusCmd\n\tShutdown(ctx context.Context) *StatusCmd\n\tShutdownSave(ctx context.Context) *StatusCmd\n\tShutdownNoSave(ctx context.Context) *StatusCmd\n\tSlaveOf(ctx context.Context, host, port string) *StatusCmd\n\tSlowLogGet(ctx context.Context, num int64) *SlowLogCmd\n\tTime(ctx context.Context) *TimeCmd\n\tDebugObject(ctx context.Context, key string) *StringCmd\n\tMemoryUsage(ctx context.Context, key string, samples ...int) *IntCmd\n\n\tModuleLoadex(ctx context.Context, conf *ModuleLoadexConfig) *StringCmd\n\n\tACLCmdable\n\tBitMapCmdable\n\tClusterCmdable\n\tGearsCmdable\n\tGenericCmdable\n\tGeoCmdable\n\tHashCmdable\n\tHyperLogLogCmdable\n\tListCmdable\n\tProbabilisticCmdable\n\tPubSubCmdable\n\tScriptingFunctionsCmdable\n\tSearchCmdable\n\tSetCmdable\n\tSortedSetCmdable\n\tStringCmdable\n\tStreamCmdable\n\tTimeseriesCmdable\n\tJSONCmdable\n}\n\ntype StatefulCmdable interface {\n\tCmdable\n\tAuth(ctx context.Context, password string) *StatusCmd\n\tAuthACL(ctx context.Context, username, password string) *StatusCmd\n\tSelect(ctx context.Context, index int) *StatusCmd\n\tSwapDB(ctx context.Context, index1, index2 int) *StatusCmd\n\tClientSetName(ctx context.Context, name string) *BoolCmd\n\tClientSetInfo(ctx context.Context, info LibraryInfo) *StatusCmd\n\tHello(ctx context.Context, ver int, username, password, clientName string) *MapStringInterfaceCmd\n}\n\nvar (\n\t_ Cmdable = (*Client)(nil)\n\t_ Cmdable = (*Tx)(nil)\n\t_ Cmdable = (*Ring)(nil)\n\t_ Cmdable = (*ClusterClient)(nil)\n)\n\ntype cmdable func(ctx context.Context, cmd Cmder) error\n\ntype statefulCmdable func(ctx context.Context, cmd Cmder) error\n\n//------------------------------------------------------------------------------\n\nfunc (c statefulCmdable) Auth(ctx context.Context, password string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"auth\", password)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// AuthACL Perform an AUTH command, using the given user and pass.\n// Should be used to authenticate the current connection with one of the connections defined in the ACL list\n// when connecting to a Redis 6.0 instance, or greater, that is using the Redis ACL system.\nfunc (c statefulCmdable) AuthACL(ctx context.Context, username, password string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"auth\", username, password)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Wait(ctx context.Context, numSlaves int, timeout time.Duration) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"wait\", numSlaves, int(timeout/time.Millisecond))\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) WaitAOF(ctx context.Context, numLocal, numSlaves int, timeout time.Duration) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"waitAOF\", numLocal, numSlaves, int(timeout/time.Millisecond))\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c statefulCmdable) Select(ctx context.Context, index int) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"select\", index)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c statefulCmdable) SwapDB(ctx context.Context, index1, index2 int) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"swapdb\", index1, index2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ClientSetName assigns a name to the connection.\nfunc (c statefulCmdable) ClientSetName(ctx context.Context, name string) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"client\", \"setname\", name)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ClientSetInfo sends a CLIENT SETINFO command with the provided info.\nfunc (c statefulCmdable) ClientSetInfo(ctx context.Context, info LibraryInfo) *StatusCmd {\n\terr := info.Validate()\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\n\tvar cmd *StatusCmd\n\tif info.LibName != nil {\n\t\tlibName := fmt.Sprintf(\"go-redis(%s,%s)\", *info.LibName, internal.ReplaceSpaces(runtime.Version()))\n\t\tcmd = NewStatusCmd(ctx, \"client\", \"setinfo\", \"LIB-NAME\", libName)\n\t} else {\n\t\tcmd = NewStatusCmd(ctx, \"client\", \"setinfo\", \"LIB-VER\", *info.LibVer)\n\t}\n\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// Validate checks if only one field in the struct is non-nil.\nfunc (info LibraryInfo) Validate() error {\n\tif info.LibName != nil && info.LibVer != nil {\n\t\treturn errors.New(\"both LibName and LibVer cannot be set at the same time\")\n\t}\n\tif info.LibName == nil && info.LibVer == nil {\n\t\treturn errors.New(\"at least one of LibName and LibVer should be set\")\n\t}\n\treturn nil\n}\n\n// Hello Set the resp protocol used.\nfunc (c statefulCmdable) Hello(ctx context.Context,\n\tver int, username, password, clientName string,\n) *MapStringInterfaceCmd {\n\targs := make([]interface{}, 0, 7)\n\targs = append(args, \"hello\", ver)\n\tif password != \"\" {\n\t\tif username != \"\" {\n\t\t\targs = append(args, \"auth\", username, password)\n\t\t} else {\n\t\t\targs = append(args, \"auth\", \"default\", password)\n\t\t}\n\t}\n\tif clientName != \"\" {\n\t\targs = append(args, \"setname\", clientName)\n\t}\n\tcmd := NewMapStringInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n//------------------------------------------------------------------------------\n\nfunc (c cmdable) Command(ctx context.Context) *CommandsInfoCmd {\n\tcmd := NewCommandsInfoCmd(ctx, \"command\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FilterBy is used for the `CommandList` command parameter.\ntype FilterBy struct {\n\tModule  string\n\tACLCat  string\n\tPattern string\n}\n\nfunc (c cmdable) CommandList(ctx context.Context, filter *FilterBy) *StringSliceCmd {\n\targs := make([]interface{}, 0, 5)\n\targs = append(args, \"command\", \"list\")\n\tif filter != nil {\n\t\tif filter.Module != \"\" {\n\t\t\targs = append(args, \"filterby\", \"module\", filter.Module)\n\t\t} else if filter.ACLCat != \"\" {\n\t\t\targs = append(args, \"filterby\", \"aclcat\", filter.ACLCat)\n\t\t} else if filter.Pattern != \"\" {\n\t\t\targs = append(args, \"filterby\", \"pattern\", filter.Pattern)\n\t\t}\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) CommandGetKeys(ctx context.Context, commands ...interface{}) *StringSliceCmd {\n\targs := make([]interface{}, 2+len(commands))\n\targs[0] = \"command\"\n\targs[1] = \"getkeys\"\n\tcopy(args[2:], commands)\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) CommandGetKeysAndFlags(ctx context.Context, commands ...interface{}) *KeyFlagsCmd {\n\targs := make([]interface{}, 2+len(commands))\n\targs[0] = \"command\"\n\targs[1] = \"getkeysandflags\"\n\tcopy(args[2:], commands)\n\tcmd := NewKeyFlagsCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ClientGetName returns the name of the connection.\nfunc (c cmdable) ClientGetName(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"client\", \"getname\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Echo(ctx context.Context, message interface{}) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"echo\", message)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Ping(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"ping\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Quit(_ context.Context) *StatusCmd {\n\tpanic(\"not implemented\")\n}\n\n//------------------------------------------------------------------------------\n\nfunc (c cmdable) BgRewriteAOF(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"bgrewriteaof\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) BgSave(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"bgsave\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientKill(ctx context.Context, ipPort string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"client\", \"kill\", ipPort)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ClientKillByFilter is new style syntax, while the ClientKill is old\n//\n//\tCLIENT KILL <option> [value] ... <option> [value]\nfunc (c cmdable) ClientKillByFilter(ctx context.Context, keys ...string) *IntCmd {\n\targs := make([]interface{}, 2+len(keys))\n\targs[0] = \"client\"\n\targs[1] = \"kill\"\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientList(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"client\", \"list\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientPause(ctx context.Context, dur time.Duration) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"client\", \"pause\", formatMs(ctx, dur))\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientUnpause(ctx context.Context) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"client\", \"unpause\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientID(ctx context.Context) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"client\", \"id\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientUnblock(ctx context.Context, id int64) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"client\", \"unblock\", id)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientUnblockWithError(ctx context.Context, id int64) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"client\", \"unblock\", id, \"error\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ClientInfo(ctx context.Context) *ClientInfoCmd {\n\tcmd := NewClientInfoCmd(ctx, \"client\", \"info\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ------------------------------------------------------------------------------------------------\n\nfunc (c cmdable) ConfigGet(ctx context.Context, parameter string) *MapStringStringCmd {\n\tcmd := NewMapStringStringCmd(ctx, \"config\", \"get\", parameter)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ConfigResetStat(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"config\", \"resetstat\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ConfigSet(ctx context.Context, parameter, value string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"config\", \"set\", parameter, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ConfigRewrite(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"config\", \"rewrite\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) DBSize(ctx context.Context) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"dbsize\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FlushAll(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"flushall\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FlushAllAsync(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"flushall\", \"async\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FlushDB(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"flushdb\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FlushDBAsync(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"flushdb\", \"async\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Info(ctx context.Context, sections ...string) *StringCmd {\n\targs := make([]interface{}, 1+len(sections))\n\targs[0] = \"info\"\n\tfor i, section := range sections {\n\t\targs[i+1] = section\n\t}\n\tcmd := NewStringCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) InfoMap(ctx context.Context, sections ...string) *InfoCmd {\n\targs := make([]interface{}, 1+len(sections))\n\targs[0] = \"info\"\n\tfor i, section := range sections {\n\t\targs[i+1] = section\n\t}\n\tcmd := NewInfoCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LastSave(ctx context.Context) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"lastsave\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Save(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"save\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) shutdown(ctx context.Context, modifier string) *StatusCmd {\n\tvar args []interface{}\n\tif modifier == \"\" {\n\t\targs = []interface{}{\"shutdown\"}\n\t} else {\n\t\targs = []interface{}{\"shutdown\", modifier}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\tif err := cmd.Err(); err != nil {\n\t\tif err == io.EOF {\n\t\t\t// Server quit as expected.\n\t\t\tcmd.err = nil\n\t\t}\n\t} else {\n\t\t// Server did not quit. String reply contains the reason.\n\t\tcmd.err = errors.New(cmd.val)\n\t\tcmd.val = \"\"\n\t}\n\treturn cmd\n}\n\nfunc (c cmdable) Shutdown(ctx context.Context) *StatusCmd {\n\treturn c.shutdown(ctx, \"\")\n}\n\nfunc (c cmdable) ShutdownSave(ctx context.Context) *StatusCmd {\n\treturn c.shutdown(ctx, \"save\")\n}\n\nfunc (c cmdable) ShutdownNoSave(ctx context.Context) *StatusCmd {\n\treturn c.shutdown(ctx, \"nosave\")\n}\n\nfunc (c cmdable) SlaveOf(ctx context.Context, host, port string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"slaveof\", host, port)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SlowLogGet(ctx context.Context, num int64) *SlowLogCmd {\n\tcmd := NewSlowLogCmd(context.Background(), \"slowlog\", \"get\", num)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Sync(_ context.Context) {\n\tpanic(\"not implemented\")\n}\n\nfunc (c cmdable) Time(ctx context.Context) *TimeCmd {\n\tcmd := NewTimeCmd(ctx, \"time\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) DebugObject(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"debug\", \"object\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) MemoryUsage(ctx context.Context, key string, samples ...int) *IntCmd {\n\targs := []interface{}{\"memory\", \"usage\", key}\n\tif len(samples) > 0 {\n\t\tif len(samples) != 1 {\n\t\t\tpanic(\"MemoryUsage expects single sample count\")\n\t\t}\n\t\targs = append(args, \"SAMPLES\", samples[0])\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n//------------------------------------------------------------------------------\n\n// ModuleLoadexConfig struct is used to specify the arguments for the MODULE LOADEX command of redis.\n// `MODULE LOADEX path [CONFIG name value [CONFIG name value ...]] [ARGS args [args ...]]`\ntype ModuleLoadexConfig struct {\n\tPath string\n\tConf map[string]interface{}\n\tArgs []interface{}\n}\n\nfunc (c *ModuleLoadexConfig) toArgs() []interface{} {\n\targs := make([]interface{}, 3, 3+len(c.Conf)*3+len(c.Args)*2)\n\targs[0] = \"MODULE\"\n\targs[1] = \"LOADEX\"\n\targs[2] = c.Path\n\tfor k, v := range c.Conf {\n\t\targs = append(args, \"CONFIG\", k, v)\n\t}\n\tfor _, arg := range c.Args {\n\t\targs = append(args, \"ARGS\", arg)\n\t}\n\treturn args\n}\n\n// ModuleLoadex Redis `MODULE LOADEX path [CONFIG name value [CONFIG name value ...]] [ARGS args [args ...]]` command.\nfunc (c cmdable) ModuleLoadex(ctx context.Context, conf *ModuleLoadexConfig) *StringCmd {\n\tcmd := NewStringCmd(ctx, conf.toArgs()...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n/*\nMonitor - represents a Redis MONITOR command, allowing the user to capture\nand process all commands sent to a Redis server. This mimics the behavior of\nMONITOR in the redis-cli.\n\nNotes:\n- Using MONITOR blocks the connection to the server for itself. It needs a dedicated connection\n- The user should create a channel of type string\n- This runs concurrently in the background. Trigger via the Start and Stop functions\nSee further: Redis MONITOR command: https://redis.io/commands/monitor\n*/\nfunc (c cmdable) Monitor(ctx context.Context, ch chan string) *MonitorCmd {\n\tcmd := newMonitorCmd(ctx, ch)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "commands_test.go",
          "type": "blob",
          "size": 223.767578125,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\ntype TimeValue struct {\n\ttime.Time\n}\n\nfunc (t *TimeValue) ScanRedis(s string) (err error) {\n\tt.Time, err = time.Parse(time.RFC3339Nano, s)\n\treturn\n}\n\nvar _ = Describe(\"Commands\", func() {\n\tctx := context.TODO()\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tDescribe(\"server\", func() {\n\t\tIt(\"should Auth\", func() {\n\t\t\tcmds, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Auth(ctx, \"password\")\n\t\t\t\tpipe.Auth(ctx, \"\")\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(ContainSubstring(\"ERR AUTH\"))\n\t\t\tExpect(cmds[0].Err().Error()).To(ContainSubstring(\"ERR AUTH\"))\n\t\t\tExpect(cmds[1].Err().Error()).To(ContainSubstring(\"ERR AUTH\"))\n\n\t\t\tstats := client.PoolStats()\n\t\t\tExpect(stats.Hits).To(Equal(uint32(1)))\n\t\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t\t\tExpect(stats.TotalConns).To(Equal(uint32(1)))\n\t\t\tExpect(stats.IdleConns).To(Equal(uint32(1)))\n\t\t})\n\n\t\tIt(\"should hello\", func() {\n\t\t\tcmds, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Hello(ctx, 3, \"\", \"\", \"\")\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tm, err := cmds[0].(*redis.MapStringInterfaceCmd).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(m[\"proto\"]).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should Echo\", func() {\n\t\t\tpipe := client.Pipeline()\n\t\t\techo := pipe.Echo(ctx, \"hello\")\n\t\t\t_, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(echo.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(echo.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should Ping\", func() {\n\t\t\tping := client.Ping(ctx)\n\t\t\tExpect(ping.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ping.Val()).To(Equal(\"PONG\"))\n\t\t})\n\n\t\tIt(\"should Wait\", func() {\n\t\t\tconst wait = 3 * time.Second\n\n\t\t\t// assume testing on single redis instance\n\t\t\tstart := time.Now()\n\t\t\tval, err := client.Wait(ctx, 1, wait).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(int64(0)))\n\t\t\tExpect(time.Now()).To(BeTemporally(\"~\", start.Add(wait), 3*time.Second))\n\t\t})\n\n\t\tIt(\"should WaitAOF\", func() {\n\t\t\tconst waitAOF = 3 * time.Second\n\t\t\tSkip(\"flaky test\")\n\n\t\t\t// assuming that the redis instance doesn't have AOF enabled\n\t\t\tstart := time.Now()\n\t\t\tval, err := client.WaitAOF(ctx, 1, 1, waitAOF).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).NotTo(ContainSubstring(\"ERR WAITAOF cannot be used when numlocal is set but appendonly is disabled\"))\n\t\t\tExpect(time.Now()).To(BeTemporally(\"~\", start.Add(waitAOF), 3*time.Second))\n\t\t})\n\n\t\tIt(\"should Select\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tpipe := client.Pipeline()\n\t\t\tsel := pipe.Select(ctx, 1)\n\t\t\t_, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(sel.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sel.Val()).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should SwapDB\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tpipe := client.Pipeline()\n\t\t\tsel := pipe.SwapDB(ctx, 1, 2)\n\t\t\t_, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(sel.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sel.Val()).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should BgRewriteAOF\", func() {\n\t\t\tSkip(\"flaky test\")\n\n\t\t\tval, err := client.BgRewriteAOF(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(ContainSubstring(\"Background append only file rewriting\"))\n\t\t})\n\n\t\tIt(\"should BgSave\", func() {\n\t\t\tSkip(\"flaky test\")\n\n\t\t\t// workaround for \"ERR Can't BGSAVE while AOF log rewriting is in progress\"\n\t\t\tEventually(func() string {\n\t\t\t\treturn client.BgSave(ctx).Val()\n\t\t\t}, \"30s\").Should(Equal(\"Background saving started\"))\n\t\t})\n\n\t\tIt(\"Should CommandGetKeys\", func() {\n\t\t\tkeys, err := client.CommandGetKeys(ctx, \"MSET\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).To(Equal([]string{\"a\", \"c\", \"e\"}))\n\n\t\t\tkeys, err = client.CommandGetKeys(ctx, \"EVAL\", \"not consulted\", \"3\", \"key1\", \"key2\", \"key3\", \"arg1\", \"arg2\", \"arg3\", \"argN\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).To(Equal([]string{\"key1\", \"key2\", \"key3\"}))\n\n\t\t\tkeys, err = client.CommandGetKeys(ctx, \"SORT\", \"mylist\", \"ALPHA\", \"STORE\", \"outlist\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).To(Equal([]string{\"mylist\", \"outlist\"}))\n\n\t\t\t_, err = client.CommandGetKeys(ctx, \"FAKECOMMAND\", \"arg1\", \"arg2\").Result()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).To(MatchError(\"ERR Invalid command specified\"))\n\t\t})\n\n\t\tIt(\"should CommandGetKeysAndFlags\", func() {\n\t\t\tkeysAndFlags, err := client.CommandGetKeysAndFlags(ctx, \"LMOVE\", \"mylist1\", \"mylist2\", \"left\", \"left\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keysAndFlags).To(Equal([]redis.KeyFlags{\n\t\t\t\t{\n\t\t\t\t\tKey:   \"mylist1\",\n\t\t\t\t\tFlags: []string{\"RW\", \"access\", \"delete\"},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tKey:   \"mylist2\",\n\t\t\t\t\tFlags: []string{\"RW\", \"insert\"},\n\t\t\t\t},\n\t\t\t}))\n\n\t\t\t_, err = client.CommandGetKeysAndFlags(ctx, \"FAKECOMMAND\", \"arg1\", \"arg2\").Result()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err).To(MatchError(\"ERR Invalid command specified\"))\n\t\t})\n\n\t\tIt(\"should ClientKill\", func() {\n\t\t\tr := client.ClientKill(ctx, \"1.1.1.1:1111\")\n\t\t\tExpect(r.Err()).To(MatchError(\"ERR No such client\"))\n\t\t\tExpect(r.Val()).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should ClientKillByFilter\", func() {\n\t\t\tr := client.ClientKillByFilter(ctx, \"TYPE\", \"test\")\n\t\t\tExpect(r.Err()).To(MatchError(\"ERR Unknown client type 'test'\"))\n\t\t\tExpect(r.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should ClientKillByFilter with MAXAGE\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tvar s []string\n\t\t\tstarted := make(chan bool)\n\t\t\tdone := make(chan bool)\n\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tstarted <- true\n\t\t\t\tblpop := client.BLPop(ctx, 0, \"list\")\n\t\t\t\tExpect(blpop.Val()).To(Equal(s))\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\t<-started\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tFail(\"BLPOP is not blocked.\")\n\t\t\tcase <-time.After(2 * time.Second):\n\t\t\t\t// ok\n\t\t\t}\n\n\t\t\tkilled := client.ClientKillByFilter(ctx, \"MAXAGE\", \"1\")\n\t\t\tExpect(killed.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(killed.Val()).To(SatisfyAny(Equal(int64(2)), Equal(int64(3))))\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// ok\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tFail(\"BLPOP is still blocked.\")\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should ClientID\", func() {\n\t\t\terr := client.ClientID(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(client.ClientID(ctx).Val()).To(BeNumerically(\">=\", 0))\n\t\t})\n\n\t\tIt(\"should ClientUnblock\", func() {\n\t\t\tid := client.ClientID(ctx).Val()\n\t\t\tr, err := client.ClientUnblock(ctx, id).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(r).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should ClientUnblockWithError\", func() {\n\t\t\tid := client.ClientID(ctx).Val()\n\t\t\tr, err := client.ClientUnblockWithError(ctx, id).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(r).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should ClientInfo\", func() {\n\t\t\tinfo, err := client.ClientInfo(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(info).NotTo(BeNil())\n\t\t})\n\n\t\tIt(\"should ClientPause\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ClientPause(ctx, time.Second).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tstart := time.Now()\n\t\t\terr = client.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(time.Now()).To(BeTemporally(\"~\", start.Add(time.Second), 800*time.Millisecond))\n\t\t})\n\n\t\tIt(\"should ClientSetName and ClientGetName\", func() {\n\t\t\tpipe := client.Pipeline()\n\t\t\tset := pipe.ClientSetName(ctx, \"theclientname\")\n\t\t\tget := pipe.ClientGetName(ctx)\n\t\t\t_, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(BeTrue())\n\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"theclientname\"))\n\t\t})\n\n\t\tIt(\"should ClientSetInfo\", func() {\n\t\t\tpipe := client.Pipeline()\n\n\t\t\t// Test setting the libName\n\t\t\tlibName := \"go-redis\"\n\t\t\tlibInfo := redis.WithLibraryName(libName)\n\t\t\tsetInfo := pipe.ClientSetInfo(ctx, libInfo)\n\t\t\t_, err := pipe.Exec(ctx)\n\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(setInfo.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(setInfo.Val()).To(Equal(\"OK\"))\n\n\t\t\t// Test setting the libVer\n\t\t\tlibVer := \"vX.x\"\n\t\t\tlibInfo = redis.WithLibraryVersion(libVer)\n\t\t\tsetInfo = pipe.ClientSetInfo(ctx, libInfo)\n\t\t\t_, err = pipe.Exec(ctx)\n\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(setInfo.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(setInfo.Val()).To(Equal(\"OK\"))\n\n\t\t\t// Test setting both fields, expect a panic\n\t\t\tlibInfo = redis.LibraryInfo{LibName: &libName, LibVer: &libVer}\n\n\t\t\tExpect(func() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\terr := r.(error)\n\t\t\t\t\t\tExpect(err).To(MatchError(\"both LibName and LibVer cannot be set at the same time\"))\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tpipe.ClientSetInfo(ctx, libInfo)\n\t\t\t}).To(Panic())\n\n\t\t\t// Test setting neither field, expect a panic\n\t\t\tlibInfo = redis.LibraryInfo{}\n\n\t\t\tExpect(func() {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r != nil {\n\t\t\t\t\t\terr := r.(error)\n\t\t\t\t\t\tExpect(err).To(MatchError(\"at least one of LibName and LibVer should be set\"))\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tpipe.ClientSetInfo(ctx, libInfo)\n\t\t\t}).To(Panic())\n\t\t\t// Test setting the default options for libName, libName suffix and libVer\n\t\t\tclientInfo := client.ClientInfo(ctx).Val()\n\t\t\tExpect(clientInfo.LibName).To(ContainSubstring(\"go-redis(go-redis,\"))\n\t\t\t// Test setting the libName suffix in options\n\t\t\topt := redisOptions()\n\t\t\topt.IdentitySuffix = \"suffix\"\n\t\t\tclient2 := redis.NewClient(opt)\n\t\t\tdefer client2.Close()\n\t\t\tclientInfo = client2.ClientInfo(ctx).Val()\n\t\t\tExpect(clientInfo.LibName).To(ContainSubstring(\"go-redis(suffix,\"))\n\n\t\t})\n\n\t\tIt(\"should ConfigGet\", func() {\n\t\t\tval, err := client.ConfigGet(ctx, \"*\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).NotTo(BeEmpty())\n\t\t})\n\n\t\tIt(\"should ConfigResetStat\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tr := client.ConfigResetStat(ctx)\n\t\t\tExpect(r.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(r.Val()).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should ConfigSet\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tconfigGet := client.ConfigGet(ctx, \"maxmemory\")\n\t\t\tExpect(configGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(configGet.Val()).To(HaveLen(1))\n\t\t\t_, ok := configGet.Val()[\"maxmemory\"]\n\t\t\tExpect(ok).To(BeTrue())\n\n\t\t\tconfigSet := client.ConfigSet(ctx, \"maxmemory\", configGet.Val()[\"maxmemory\"])\n\t\t\tExpect(configSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(configSet.Val()).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should ConfigRewrite\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tconfigRewrite := client.ConfigRewrite(ctx)\n\t\t\tExpect(configRewrite.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(configRewrite.Val()).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should DBSize\", func() {\n\t\t\tsize, err := client.DBSize(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should Info\", func() {\n\t\t\tinfo := client.Info(ctx)\n\t\t\tExpect(info.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(info.Val()).NotTo(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should InfoMap\", Label(\"redis.info\"), func() {\n\t\t\tinfo := client.InfoMap(ctx)\n\t\t\tExpect(info.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(info.Val()).NotTo(BeNil())\n\n\t\t\tinfo = client.InfoMap(ctx, \"dummy\")\n\t\t\tExpect(info.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(info.Val()).To(BeNil())\n\n\t\t\tinfo = client.InfoMap(ctx, \"server\")\n\t\t\tExpect(info.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(info.Val()).To(HaveLen(1))\n\t\t})\n\n\t\tIt(\"should Info cpu\", func() {\n\t\t\tinfo := client.Info(ctx, \"cpu\")\n\t\t\tExpect(info.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(info.Val()).NotTo(Equal(\"\"))\n\t\t\tExpect(info.Val()).To(ContainSubstring(`used_cpu_sys`))\n\t\t})\n\n\t\tIt(\"should Info cpu and memory\", func() {\n\t\t\tinfo := client.Info(ctx, \"cpu\", \"memory\")\n\t\t\tExpect(info.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(info.Val()).NotTo(Equal(\"\"))\n\t\t\tExpect(info.Val()).To(ContainSubstring(`used_cpu_sys`))\n\t\t\tExpect(info.Val()).To(ContainSubstring(`memory`))\n\t\t})\n\n\t\tIt(\"should LastSave\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tlastSave := client.LastSave(ctx)\n\t\t\tExpect(lastSave.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lastSave.Val()).NotTo(Equal(0))\n\t\t})\n\n\t\tIt(\"should Save\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\t// workaround for \"ERR Background save already in progress\"\n\t\t\tEventually(func() string {\n\t\t\t\treturn client.Save(ctx).Val()\n\t\t\t}, \"10s\").Should(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should SlaveOf\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tslaveOf := client.SlaveOf(ctx, \"localhost\", \"8888\")\n\t\t\tExpect(slaveOf.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(slaveOf.Val()).To(Equal(\"OK\"))\n\n\t\t\tslaveOf = client.SlaveOf(ctx, \"NO\", \"ONE\")\n\t\t\tExpect(slaveOf.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(slaveOf.Val()).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should Time\", func() {\n\t\t\ttm, err := client.Time(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(tm).To(BeTemporally(\"~\", time.Now(), 3*time.Second))\n\t\t})\n\n\t\tIt(\"should Command\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tcmds, err := client.Command(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(cmds)).To(BeNumerically(\"~\", 240, 25))\n\n\t\t\tcmd := cmds[\"mget\"]\n\t\t\tExpect(cmd.Name).To(Equal(\"mget\"))\n\t\t\tExpect(cmd.Arity).To(Equal(int8(-2)))\n\t\t\tExpect(cmd.Flags).To(ContainElement(\"readonly\"))\n\t\t\tExpect(cmd.FirstKeyPos).To(Equal(int8(1)))\n\t\t\tExpect(cmd.LastKeyPos).To(Equal(int8(-1)))\n\t\t\tExpect(cmd.StepCount).To(Equal(int8(1)))\n\n\t\t\tcmd = cmds[\"ping\"]\n\t\t\tExpect(cmd.Name).To(Equal(\"ping\"))\n\t\t\tExpect(cmd.Arity).To(Equal(int8(-1)))\n\t\t\tExpect(cmd.Flags).To(ContainElement(\"fast\"))\n\t\t\tExpect(cmd.FirstKeyPos).To(Equal(int8(0)))\n\t\t\tExpect(cmd.LastKeyPos).To(Equal(int8(0)))\n\t\t\tExpect(cmd.StepCount).To(Equal(int8(0)))\n\t\t})\n\n\t\tIt(\"should return all command names\", func() {\n\t\t\tcmdList := client.CommandList(ctx, nil)\n\t\t\tExpect(cmdList.Err()).NotTo(HaveOccurred())\n\t\t\tcmdNames := cmdList.Val()\n\n\t\t\tExpect(cmdNames).NotTo(BeEmpty())\n\n\t\t\t// Assert that some expected commands are present in the list\n\t\t\tExpect(cmdNames).To(ContainElement(\"get\"))\n\t\t\tExpect(cmdNames).To(ContainElement(\"set\"))\n\t\t\tExpect(cmdNames).To(ContainElement(\"hset\"))\n\t\t})\n\n\t\tIt(\"should filter commands by module\", func() {\n\t\t\tfilter := &redis.FilterBy{\n\t\t\t\tModule: \"JSON\",\n\t\t\t}\n\t\t\tcmdList := client.CommandList(ctx, filter)\n\t\t\tExpect(cmdList.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(cmdList.Val()).To(HaveLen(0))\n\t\t})\n\n\t\tIt(\"should filter commands by ACL category\", func() {\n\t\t\tfilter := &redis.FilterBy{\n\t\t\t\tACLCat: \"admin\",\n\t\t\t}\n\n\t\t\tcmdList := client.CommandList(ctx, filter)\n\t\t\tExpect(cmdList.Err()).NotTo(HaveOccurred())\n\t\t\tcmdNames := cmdList.Val()\n\n\t\t\t// Assert that the returned list only contains commands from the admin ACL category\n\t\t\tExpect(len(cmdNames)).To(BeNumerically(\">\", 10))\n\t\t})\n\n\t\tIt(\"should filter commands by pattern\", func() {\n\t\t\tfilter := &redis.FilterBy{\n\t\t\t\tPattern: \"*GET*\",\n\t\t\t}\n\t\t\tcmdList := client.CommandList(ctx, filter)\n\t\t\tExpect(cmdList.Err()).NotTo(HaveOccurred())\n\t\t\tcmdNames := cmdList.Val()\n\n\t\t\t// Assert that the returned list only contains commands that match the given pattern\n\t\t\tExpect(cmdNames).To(ContainElement(\"get\"))\n\t\t\tExpect(cmdNames).To(ContainElement(\"getbit\"))\n\t\t\tExpect(cmdNames).To(ContainElement(\"getrange\"))\n\t\t\tExpect(cmdNames).NotTo(ContainElement(\"set\"))\n\t\t})\n\t})\n\n\tDescribe(\"debugging\", func() {\n\t\tPIt(\"should DebugObject\", func() {\n\t\t\terr := client.DebugObject(ctx, \"foo\").Err()\n\t\t\tExpect(err).To(MatchError(\"ERR no such key\"))\n\n\t\t\terr = client.Set(ctx, \"foo\", \"bar\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\ts, err := client.DebugObject(ctx, \"foo\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(s).To(ContainSubstring(\"serializedlength:4\"))\n\t\t})\n\n\t\tIt(\"should MemoryUsage\", func() {\n\t\t\terr := client.MemoryUsage(ctx, \"foo\").Err()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\n\t\t\terr = client.Set(ctx, \"foo\", \"bar\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tn, err := client.MemoryUsage(ctx, \"foo\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).NotTo(BeZero())\n\n\t\t\tn, err = client.MemoryUsage(ctx, \"foo\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).NotTo(BeZero())\n\t\t})\n\t})\n\n\tDescribe(\"keys\", func() {\n\t\tIt(\"should Del\", func() {\n\t\t\terr := client.Set(ctx, \"key1\", \"Hello\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.Set(ctx, \"key2\", \"World\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tn, err := client.Del(ctx, \"key1\", \"key2\", \"key3\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should Unlink\", func() {\n\t\t\terr := client.Set(ctx, \"key1\", \"Hello\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.Set(ctx, \"key2\", \"World\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tn, err := client.Unlink(ctx, \"key1\", \"key2\", \"key3\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should Dump\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tdump := client.Dump(ctx, \"key\")\n\t\t\tExpect(dump.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(dump.Val()).NotTo(BeEmpty())\n\t\t})\n\n\t\tIt(\"should Exists\", func() {\n\t\t\tset := client.Set(ctx, \"key1\", \"Hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tn, err := client.Exists(ctx, \"key1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(1)))\n\n\t\t\tn, err = client.Exists(ctx, \"key2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(0)))\n\n\t\t\tn, err = client.Exists(ctx, \"key1\", \"key2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(1)))\n\n\t\t\tn, err = client.Exists(ctx, \"key1\", \"key1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should Expire\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"Hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\texpire := client.Expire(ctx, \"key\", 10*time.Second)\n\t\t\tExpect(expire.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expire.Val()).To(Equal(true))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(Equal(10 * time.Second))\n\n\t\t\tset = client.Set(ctx, \"key\", \"Hello World\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tttl = client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(Equal(time.Duration(-1)))\n\n\t\t\tttl = client.TTL(ctx, \"nonexistent_key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(Equal(time.Duration(-2)))\n\t\t})\n\n\t\tIt(\"should ExpireAt\", func() {\n\t\t\tsetCmd := client.Set(ctx, \"key\", \"Hello\", 0)\n\t\t\tExpect(setCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(setCmd.Val()).To(Equal(\"OK\"))\n\n\t\t\tn, err := client.Exists(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(1)))\n\n\t\t\t// Check correct expiration time is set in the future\n\t\t\texpireAt := time.Now().Add(time.Minute)\n\t\t\texpireAtCmd := client.ExpireAt(ctx, \"key\", expireAt)\n\t\t\tExpect(expireAtCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expireAtCmd.Val()).To(Equal(true))\n\n\t\t\ttimeCmd := client.ExpireTime(ctx, \"key\")\n\t\t\tExpect(timeCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(timeCmd.Val().Seconds()).To(BeNumerically(\"==\", expireAt.Unix()))\n\n\t\t\t// Check correct expiration in the past\n\t\t\texpireAtCmd = client.ExpireAt(ctx, \"key\", time.Now().Add(-time.Hour))\n\t\t\tExpect(expireAtCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expireAtCmd.Val()).To(Equal(true))\n\n\t\t\tn, err = client.Exists(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should Keys\", func() {\n\t\t\tmset := client.MSet(ctx, \"one\", \"1\", \"two\", \"2\", \"three\", \"3\", \"four\", \"4\")\n\t\t\tExpect(mset.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mset.Val()).To(Equal(\"OK\"))\n\n\t\t\tkeys := client.Keys(ctx, \"*o*\")\n\t\t\tExpect(keys.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(keys.Val()).To(ConsistOf([]string{\"four\", \"one\", \"two\"}))\n\n\t\t\tkeys = client.Keys(ctx, \"t??\")\n\t\t\tExpect(keys.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(keys.Val()).To(Equal([]string{\"two\"}))\n\n\t\t\tkeys = client.Keys(ctx, \"*\")\n\t\t\tExpect(keys.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(keys.Val()).To(ConsistOf([]string{\"four\", \"one\", \"three\", \"two\"}))\n\t\t})\n\n\t\tIt(\"should Migrate\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tmigrate := client.Migrate(ctx, \"localhost\", redisSecondaryPort, \"key\", 0, 0)\n\t\t\tExpect(migrate.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(migrate.Val()).To(Equal(\"NOKEY\"))\n\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tmigrate = client.Migrate(ctx, \"localhost\", redisSecondaryPort, \"key\", 0, 0)\n\t\t\tExpect(migrate.Err()).To(MatchError(\"IOERR error or timeout writing to target instance\"))\n\t\t\tExpect(migrate.Val()).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should Move\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tmove := client.Move(ctx, \"key\", 2)\n\t\t\tExpect(move.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(move.Val()).To(Equal(false))\n\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tmove = client.Move(ctx, \"key\", 2)\n\t\t\tExpect(move.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(move.Val()).To(Equal(true))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).To(Equal(redis.Nil))\n\t\t\tExpect(get.Val()).To(Equal(\"\"))\n\n\t\t\tpipe := client.Pipeline()\n\t\t\tpipe.Select(ctx, 2)\n\t\t\tget = pipe.Get(ctx, \"key\")\n\t\t\tpipe.FlushDB(ctx)\n\n\t\t\t_, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should Object\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tstart := time.Now()\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\trefCount := client.ObjectRefCount(ctx, \"key\")\n\t\t\tExpect(refCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(refCount.Val()).To(Equal(int64(1)))\n\n\t\t\tclient.ConfigSet(ctx, \"maxmemory-policy\", \"volatile-lfu\")\n\t\t\tfreq := client.ObjectFreq(ctx, \"key\")\n\t\t\tExpect(freq.Err()).NotTo(HaveOccurred())\n\t\t\tclient.ConfigSet(ctx, \"maxmemory-policy\", \"noeviction\") // default\n\n\t\t\terr := client.ObjectEncoding(ctx, \"key\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tidleTime := client.ObjectIdleTime(ctx, \"key\")\n\t\t\tExpect(idleTime.Err()).NotTo(HaveOccurred())\n\n\t\t\t// Redis returned milliseconds/1000, which may cause ObjectIdleTime to be at a critical value,\n\t\t\t// should be +1s to deal with the critical value problem.\n\t\t\t// if too much time (>1s) is used during command execution, it may also cause the test to fail.\n\t\t\t// so the ObjectIdleTime result should be <=now-start+1s\n\t\t\t// link: https://github.com/redis/redis/blob/5b48d900498c85bbf4772c1d466c214439888115/src/object.c#L1265-L1272\n\t\t\tExpect(idleTime.Val()).To(BeNumerically(\"<=\", time.Since(start)+time.Second))\n\t\t})\n\n\t\tIt(\"should Persist\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"Hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\texpire := client.Expire(ctx, \"key\", 10*time.Second)\n\t\t\tExpect(expire.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expire.Val()).To(Equal(true))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(Equal(10 * time.Second))\n\n\t\t\tpersist := client.Persist(ctx, \"key\")\n\t\t\tExpect(persist.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(persist.Val()).To(Equal(true))\n\n\t\t\tttl = client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val() < 0).To(Equal(true))\n\t\t})\n\n\t\tIt(\"should PExpire\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"Hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\texpiration := 900 * time.Millisecond\n\t\t\tpexpire := client.PExpire(ctx, \"key\", expiration)\n\t\t\tExpect(pexpire.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pexpire.Val()).To(Equal(true))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(Equal(time.Second))\n\n\t\t\tpttl := client.PTTL(ctx, \"key\")\n\t\t\tExpect(pttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pttl.Val()).To(BeNumerically(\"~\", expiration, 100*time.Millisecond))\n\t\t})\n\n\t\tIt(\"should PExpireAt\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"Hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\texpiration := 900 * time.Millisecond\n\t\t\tpexpireat := client.PExpireAt(ctx, \"key\", time.Now().Add(expiration))\n\t\t\tExpect(pexpireat.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pexpireat.Val()).To(Equal(true))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(Equal(time.Second))\n\n\t\t\tpttl := client.PTTL(ctx, \"key\")\n\t\t\tExpect(pttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pttl.Val()).To(BeNumerically(\"~\", expiration, 100*time.Millisecond))\n\t\t})\n\n\t\tIt(\"should PExpireTime\", func() {\n\t\t\t// The command returns -1 if the key exists but has no associated expiration time.\n\t\t\t// The command returns -2 if the key does not exist.\n\t\t\tpExpireTime := client.PExpireTime(ctx, \"key\")\n\t\t\tExpect(pExpireTime.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pExpireTime.Val() < 0).To(Equal(true))\n\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\ttimestamp := time.Now().Add(time.Minute)\n\t\t\texpireAt := client.PExpireAt(ctx, \"key\", timestamp)\n\t\t\tExpect(expireAt.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expireAt.Val()).To(Equal(true))\n\n\t\t\tpExpireTime = client.PExpireTime(ctx, \"key\")\n\t\t\tExpect(pExpireTime.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pExpireTime.Val().Milliseconds()).To(BeNumerically(\"==\", timestamp.UnixMilli()))\n\t\t})\n\n\t\tIt(\"should PTTL\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"Hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\texpiration := time.Second\n\t\t\texpire := client.Expire(ctx, \"key\", expiration)\n\t\t\tExpect(expire.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tpttl := client.PTTL(ctx, \"key\")\n\t\t\tExpect(pttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pttl.Val()).To(BeNumerically(\"~\", expiration, 100*time.Millisecond))\n\t\t})\n\n\t\tIt(\"should RandomKey\", func() {\n\t\t\trandomKey := client.RandomKey(ctx)\n\t\t\tExpect(randomKey.Err()).To(Equal(redis.Nil))\n\t\t\tExpect(randomKey.Val()).To(Equal(\"\"))\n\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\trandomKey = client.RandomKey(ctx)\n\t\t\tExpect(randomKey.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(randomKey.Val()).To(Equal(\"key\"))\n\t\t})\n\n\t\tIt(\"should Rename\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tstatus := client.Rename(ctx, \"key\", \"key1\")\n\t\t\tExpect(status.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(status.Val()).To(Equal(\"OK\"))\n\n\t\t\tget := client.Get(ctx, \"key1\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should RenameNX\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\trenameNX := client.RenameNX(ctx, \"key\", \"key1\")\n\t\t\tExpect(renameNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(renameNX.Val()).To(Equal(true))\n\n\t\t\tget := client.Get(ctx, \"key1\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should Restore\", func() {\n\t\t\terr := client.Set(ctx, \"key\", \"hello\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tdump := client.Dump(ctx, \"key\")\n\t\t\tExpect(dump.Err()).NotTo(HaveOccurred())\n\n\t\t\terr = client.Del(ctx, \"key\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\trestore, err := client.Restore(ctx, \"key\", 0, dump.Val()).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(restore).To(Equal(\"OK\"))\n\n\t\t\ttype_, err := client.Type(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(type_).To(Equal(\"string\"))\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should RestoreReplace\", func() {\n\t\t\terr := client.Set(ctx, \"key\", \"hello\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tdump := client.Dump(ctx, \"key\")\n\t\t\tExpect(dump.Err()).NotTo(HaveOccurred())\n\n\t\t\trestore, err := client.RestoreReplace(ctx, \"key\", 0, dump.Val()).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(restore).To(Equal(\"OK\"))\n\n\t\t\ttype_, err := client.Type(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(type_).To(Equal(\"string\"))\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should Sort RO\", func() {\n\t\t\tsize, err := client.LPush(ctx, \"list\", \"1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(1)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"3\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(2)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(3)))\n\n\t\t\tels, err := client.SortRO(ctx, \"list\", &redis.Sort{\n\t\t\t\tOffset: 0,\n\t\t\t\tCount:  2,\n\t\t\t\tOrder:  \"ASC\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(els).To(Equal([]string{\"1\", \"2\"}))\n\t\t})\n\n\t\tIt(\"should Sort\", func() {\n\t\t\tsize, err := client.LPush(ctx, \"list\", \"1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(1)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"3\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(2)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(3)))\n\n\t\t\tels, err := client.Sort(ctx, \"list\", &redis.Sort{\n\t\t\t\tOffset: 0,\n\t\t\t\tCount:  2,\n\t\t\t\tOrder:  \"ASC\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(els).To(Equal([]string{\"1\", \"2\"}))\n\t\t})\n\n\t\tIt(\"should Sort and Get\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsize, err := client.LPush(ctx, \"list\", \"1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(1)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"3\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(2)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(3)))\n\n\t\t\terr = client.Set(ctx, \"object_2\", \"value2\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t{\n\t\t\t\tels, err := client.Sort(ctx, \"list\", &redis.Sort{\n\t\t\t\t\tGet: []string{\"object_*\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(els).To(Equal([]string{\"\", \"value2\", \"\"}))\n\t\t\t}\n\n\t\t\t{\n\t\t\t\tels, err := client.SortInterfaces(ctx, \"list\", &redis.Sort{\n\t\t\t\t\tGet: []string{\"object_*\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(els).To(Equal([]interface{}{nil, \"value2\", nil}))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should Sort and Store\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsize, err := client.LPush(ctx, \"list\", \"1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(1)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"3\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(2)))\n\n\t\t\tsize, err = client.LPush(ctx, \"list\", \"2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(3)))\n\n\t\t\tn, err := client.SortStore(ctx, \"list\", \"list2\", &redis.Sort{\n\t\t\t\tOffset: 0,\n\t\t\t\tCount:  2,\n\t\t\t\tOrder:  \"ASC\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\n\t\t\tels, err := client.LRange(ctx, \"list2\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(els).To(Equal([]string{\"1\", \"2\"}))\n\t\t})\n\n\t\tIt(\"should Touch\", func() {\n\t\t\tset1 := client.Set(ctx, \"touch1\", \"hello\", 0)\n\t\t\tExpect(set1.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set1.Val()).To(Equal(\"OK\"))\n\n\t\t\tset2 := client.Set(ctx, \"touch2\", \"hello\", 0)\n\t\t\tExpect(set2.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set2.Val()).To(Equal(\"OK\"))\n\n\t\t\ttouch := client.Touch(ctx, \"touch1\", \"touch2\", \"touch3\")\n\t\t\tExpect(touch.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(touch.Val()).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should ExpireTime\", func() {\n\t\t\t// The command returns -1 if the key exists but has no associated expiration time.\n\t\t\t// The command returns -2 if the key does not exist.\n\t\t\texpireTimeCmd := client.ExpireTime(ctx, \"key\")\n\t\t\tExpect(expireTimeCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expireTimeCmd.Val() < 0).To(Equal(true))\n\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\texpireAt := time.Now().Add(time.Minute)\n\t\t\texpireAtCmd := client.ExpireAt(ctx, \"key\", expireAt)\n\t\t\tExpect(expireAtCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expireAtCmd.Val()).To(Equal(true))\n\n\t\t\texpireTimeCmd = client.ExpireTime(ctx, \"key\")\n\t\t\tExpect(expireTimeCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expireTimeCmd.Val().Seconds()).To(BeNumerically(\"==\", expireAt.Unix()))\n\t\t})\n\n\t\tIt(\"should TTL\", func() {\n\t\t\t// The command returns -1 if the key exists but has no associated expire\n\t\t\t// The command returns -2 if the key does not exist.\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val() < 0).To(Equal(true))\n\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\texpire := client.Expire(ctx, \"key\", 60*time.Second)\n\t\t\tExpect(expire.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(expire.Val()).To(Equal(true))\n\n\t\t\tttl = client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(Equal(60 * time.Second))\n\t\t})\n\n\t\tIt(\"should Type\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\ttype_ := client.Type(ctx, \"key\")\n\t\t\tExpect(type_.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(type_.Val()).To(Equal(\"string\"))\n\t\t})\n\t})\n\n\tDescribe(\"scanning\", func() {\n\t\tIt(\"should Scan\", func() {\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tset := client.Set(ctx, fmt.Sprintf(\"key%d\", i), \"hello\", 0)\n\t\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tkeys, cursor, err := client.Scan(ctx, 0, \"\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).NotTo(BeEmpty())\n\t\t\tExpect(cursor).NotTo(BeZero())\n\t\t})\n\n\t\tIt(\"should ScanType\", func() {\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tset := client.Set(ctx, fmt.Sprintf(\"key%d\", i), \"hello\", 0)\n\t\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tkeys, cursor, err := client.ScanType(ctx, 0, \"\", 0, \"string\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).NotTo(BeEmpty())\n\t\t\tExpect(cursor).NotTo(BeZero())\n\t\t})\n\n\t\tIt(\"should SScan\", func() {\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tsadd := client.SAdd(ctx, \"myset\", fmt.Sprintf(\"member%d\", i))\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tkeys, cursor, err := client.SScan(ctx, \"myset\", 0, \"\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).NotTo(BeEmpty())\n\t\t\tExpect(cursor).NotTo(BeZero())\n\t\t})\n\n\t\tIt(\"should HScan\", func() {\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tkeys, cursor, err := client.HScan(ctx, \"myhash\", 0, \"\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t// If we don't get at least two items back, it's really strange.\n\t\t\tExpect(cursor).To(BeNumerically(\">=\", 2))\n\t\t\tExpect(len(keys)).To(BeNumerically(\">=\", 2))\n\t\t\tExpect(keys[0]).To(HavePrefix(\"key\"))\n\t\t\tExpect(keys[1]).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should HScan without values\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tkeys, cursor, err := client.HScanNoValues(ctx, \"myhash\", 0, \"\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t// If we don't get at least two items back, it's really strange.\n\t\t\tExpect(cursor).To(BeNumerically(\">=\", 2))\n\t\t\tExpect(len(keys)).To(BeNumerically(\">=\", 2))\n\t\t\tExpect(keys[0]).To(HavePrefix(\"key\"))\n\t\t\tExpect(keys[1]).To(HavePrefix(\"key\"))\n\t\t\tExpect(keys).NotTo(BeEmpty())\n\t\t\tExpect(cursor).NotTo(BeZero())\n\t\t})\n\n\t\tIt(\"should ZScan\", func() {\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\terr := client.ZAdd(ctx, \"myset\", redis.Z{\n\t\t\t\t\tScore:  float64(i),\n\t\t\t\t\tMember: fmt.Sprintf(\"member%d\", i),\n\t\t\t\t}).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tkeys, cursor, err := client.ZScan(ctx, \"myset\", 0, \"\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).NotTo(BeEmpty())\n\t\t\tExpect(cursor).NotTo(BeZero())\n\t\t})\n\t})\n\n\tDescribe(\"strings\", func() {\n\t\tIt(\"should Append\", func() {\n\t\t\tn, err := client.Exists(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(0)))\n\n\t\t\tappendRes := client.Append(ctx, \"key\", \"Hello\")\n\t\t\tExpect(appendRes.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(appendRes.Val()).To(Equal(int64(5)))\n\n\t\t\tappendRes = client.Append(ctx, \"key\", \" World\")\n\t\t\tExpect(appendRes.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(appendRes.Val()).To(Equal(int64(11)))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"Hello World\"))\n\t\t})\n\n\t\tIt(\"should BitCount\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"foobar\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tbitCount := client.BitCount(ctx, \"key\", nil)\n\t\t\tExpect(bitCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bitCount.Val()).To(Equal(int64(26)))\n\n\t\t\tbitCount = client.BitCount(ctx, \"key\", &redis.BitCount{\n\t\t\t\tStart: 0,\n\t\t\t\tEnd:   0,\n\t\t\t})\n\t\t\tExpect(bitCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bitCount.Val()).To(Equal(int64(4)))\n\n\t\t\tbitCount = client.BitCount(ctx, \"key\", &redis.BitCount{\n\t\t\t\tStart: 1,\n\t\t\t\tEnd:   1,\n\t\t\t})\n\t\t\tExpect(bitCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bitCount.Val()).To(Equal(int64(6)))\n\t\t})\n\n\t\tIt(\"should BitOpAnd\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tset := client.Set(ctx, \"key1\", \"1\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tset = client.Set(ctx, \"key2\", \"0\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tbitOpAnd := client.BitOpAnd(ctx, \"dest\", \"key1\", \"key2\")\n\t\t\tExpect(bitOpAnd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bitOpAnd.Val()).To(Equal(int64(1)))\n\n\t\t\tget := client.Get(ctx, \"dest\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"0\"))\n\t\t})\n\n\t\tIt(\"should BitOpOr\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tset := client.Set(ctx, \"key1\", \"1\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tset = client.Set(ctx, \"key2\", \"0\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tbitOpOr := client.BitOpOr(ctx, \"dest\", \"key1\", \"key2\")\n\t\t\tExpect(bitOpOr.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bitOpOr.Val()).To(Equal(int64(1)))\n\n\t\t\tget := client.Get(ctx, \"dest\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"1\"))\n\t\t})\n\n\t\tIt(\"should BitOpXor\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tset := client.Set(ctx, \"key1\", \"\\xff\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tset = client.Set(ctx, \"key2\", \"\\x0f\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tbitOpXor := client.BitOpXor(ctx, \"dest\", \"key1\", \"key2\")\n\t\t\tExpect(bitOpXor.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bitOpXor.Val()).To(Equal(int64(1)))\n\n\t\t\tget := client.Get(ctx, \"dest\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"\\xf0\"))\n\t\t})\n\n\t\tIt(\"should BitOpNot\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tset := client.Set(ctx, \"key1\", \"\\x00\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tbitOpNot := client.BitOpNot(ctx, \"dest\", \"key1\")\n\t\t\tExpect(bitOpNot.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bitOpNot.Val()).To(Equal(int64(1)))\n\n\t\t\tget := client.Get(ctx, \"dest\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"\\xff\"))\n\t\t})\n\n\t\tIt(\"should BitPos\", func() {\n\t\t\terr := client.Set(ctx, \"mykey\", \"\\xff\\xf0\\x00\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tpos, err := client.BitPos(ctx, \"mykey\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(12)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(0)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 0, 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(16)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 1, 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(-1)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(16)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 1, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(-1)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 0, 2, 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(-1)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 0, 0, -3).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(-1)))\n\n\t\t\tpos, err = client.BitPos(ctx, \"mykey\", 0, 0, 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(-1)))\n\t\t})\n\n\t\tIt(\"should BitPosSpan\", func() {\n\t\t\terr := client.Set(ctx, \"mykey\", \"\\x00\\xff\\x00\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tpos, err := client.BitPosSpan(ctx, \"mykey\", 0, 1, 3, \"byte\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(16)))\n\n\t\t\tpos, err = client.BitPosSpan(ctx, \"mykey\", 0, 1, 3, \"bit\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(Equal(int64(1)))\n\t\t})\n\n\t\tIt(\"should BitField\", func() {\n\t\t\tnn, err := client.BitField(ctx, \"mykey\", \"INCRBY\", \"i5\", 100, 1, \"GET\", \"u4\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(nn).To(Equal([]int64{1, 0}))\n\n\t\t\tnn, err = client.BitField(ctx, \"mykey\", \"set\", \"i1\", 1, 1, \"GET\", \"u4\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(nn).To(Equal([]int64{0, 4}))\n\t\t})\n\n\t\tIt(\"should BitFieldRO\", func() {\n\t\t\tnn, err := client.BitField(ctx, \"mykey\", \"SET\", \"u8\", 8, 255).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(nn).To(Equal([]int64{0}))\n\n\t\t\tnn, err = client.BitFieldRO(ctx, \"mykey\", \"u8\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(nn).To(Equal([]int64{0}))\n\n\t\t\tnn, err = client.BitFieldRO(ctx, \"mykey\", \"u8\", 0, \"u4\", 8, \"u4\", 12, \"u4\", 13).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(nn).To(Equal([]int64{0, 15, 15, 14}))\n\t\t})\n\n\t\tIt(\"should Decr\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"10\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tdecr := client.Decr(ctx, \"key\")\n\t\t\tExpect(decr.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(decr.Val()).To(Equal(int64(9)))\n\n\t\t\tset = client.Set(ctx, \"key\", \"234293482390480948029348230948\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tdecr = client.Decr(ctx, \"key\")\n\t\t\tExpect(decr.Err()).To(MatchError(\"ERR value is not an integer or out of range\"))\n\t\t\tExpect(decr.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should DecrBy\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"10\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tdecrBy := client.DecrBy(ctx, \"key\", 5)\n\t\t\tExpect(decrBy.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(decrBy.Val()).To(Equal(int64(5)))\n\t\t})\n\n\t\tIt(\"should Get\", func() {\n\t\t\tget := client.Get(ctx, \"_\")\n\t\t\tExpect(get.Err()).To(Equal(redis.Nil))\n\t\t\tExpect(get.Val()).To(Equal(\"\"))\n\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tget = client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should GetBit\", func() {\n\t\t\tsetBit := client.SetBit(ctx, \"key\", 7, 1)\n\t\t\tExpect(setBit.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(setBit.Val()).To(Equal(int64(0)))\n\n\t\t\tgetBit := client.GetBit(ctx, \"key\", 0)\n\t\t\tExpect(getBit.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getBit.Val()).To(Equal(int64(0)))\n\n\t\t\tgetBit = client.GetBit(ctx, \"key\", 7)\n\t\t\tExpect(getBit.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getBit.Val()).To(Equal(int64(1)))\n\n\t\t\tgetBit = client.GetBit(ctx, \"key\", 100)\n\t\t\tExpect(getBit.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getBit.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should GetRange\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"This is a string\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tgetRange := client.GetRange(ctx, \"key\", 0, 3)\n\t\t\tExpect(getRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getRange.Val()).To(Equal(\"This\"))\n\n\t\t\tgetRange = client.GetRange(ctx, \"key\", -3, -1)\n\t\t\tExpect(getRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getRange.Val()).To(Equal(\"ing\"))\n\n\t\t\tgetRange = client.GetRange(ctx, \"key\", 0, -1)\n\t\t\tExpect(getRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getRange.Val()).To(Equal(\"This is a string\"))\n\n\t\t\tgetRange = client.GetRange(ctx, \"key\", 10, 100)\n\t\t\tExpect(getRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getRange.Val()).To(Equal(\"string\"))\n\t\t})\n\n\t\tIt(\"should GetSet\", func() {\n\t\t\tincr := client.Incr(ctx, \"key\")\n\t\t\tExpect(incr.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(incr.Val()).To(Equal(int64(1)))\n\n\t\t\tgetSet := client.GetSet(ctx, \"key\", \"0\")\n\t\t\tExpect(getSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getSet.Val()).To(Equal(\"1\"))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"0\"))\n\t\t})\n\n\t\tIt(\"should GetEX\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"value\", 100*time.Second)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(BeNumerically(\"~\", 100*time.Second, 3*time.Second))\n\n\t\t\tgetEX := client.GetEx(ctx, \"key\", 200*time.Second)\n\t\t\tExpect(getEX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getEX.Val()).To(Equal(\"value\"))\n\n\t\t\tttl = client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).To(BeNumerically(\"~\", 200*time.Second, 3*time.Second))\n\t\t})\n\n\t\tIt(\"should GetDel\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"value\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tgetDel := client.GetDel(ctx, \"key\")\n\t\t\tExpect(getDel.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getDel.Val()).To(Equal(\"value\"))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).To(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should Incr\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"10\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tincr := client.Incr(ctx, \"key\")\n\t\t\tExpect(incr.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(incr.Val()).To(Equal(int64(11)))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"11\"))\n\t\t})\n\n\t\tIt(\"should IncrBy\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"10\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tincrBy := client.IncrBy(ctx, \"key\", 5)\n\t\t\tExpect(incrBy.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(incrBy.Val()).To(Equal(int64(15)))\n\t\t})\n\n\t\tIt(\"should IncrByFloat\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"10.50\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tincrByFloat := client.IncrByFloat(ctx, \"key\", 0.1)\n\t\t\tExpect(incrByFloat.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(incrByFloat.Val()).To(Equal(10.6))\n\n\t\t\tset = client.Set(ctx, \"key\", \"5.0e3\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tincrByFloat = client.IncrByFloat(ctx, \"key\", 2.0e2)\n\t\t\tExpect(incrByFloat.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(incrByFloat.Val()).To(Equal(float64(5200)))\n\t\t})\n\n\t\tIt(\"should IncrByFloatOverflow\", func() {\n\t\t\tincrByFloat := client.IncrByFloat(ctx, \"key\", 996945661)\n\t\t\tExpect(incrByFloat.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(incrByFloat.Val()).To(Equal(float64(996945661)))\n\t\t})\n\n\t\tIt(\"should MSetMGet\", func() {\n\t\t\tmSet := client.MSet(ctx, \"key1\", \"hello1\", \"key2\", \"hello2\")\n\t\t\tExpect(mSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mSet.Val()).To(Equal(\"OK\"))\n\n\t\t\tmGet := client.MGet(ctx, \"key1\", \"key2\", \"_\")\n\t\t\tExpect(mGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mGet.Val()).To(Equal([]interface{}{\"hello1\", \"hello2\", nil}))\n\n\t\t\t// MSet struct\n\t\t\ttype set struct {\n\t\t\t\tSet1 string                 `redis:\"set1\"`\n\t\t\t\tSet2 int16                  `redis:\"set2\"`\n\t\t\t\tSet3 time.Duration          `redis:\"set3\"`\n\t\t\t\tSet4 interface{}            `redis:\"set4\"`\n\t\t\t\tSet5 map[string]interface{} `redis:\"-\"`\n\t\t\t}\n\t\t\tmSet = client.MSet(ctx, &set{\n\t\t\t\tSet1: \"val1\",\n\t\t\t\tSet2: 1024,\n\t\t\t\tSet3: 2 * time.Millisecond,\n\t\t\t\tSet4: nil,\n\t\t\t\tSet5: map[string]interface{}{\"k1\": 1},\n\t\t\t})\n\t\t\tExpect(mSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mSet.Val()).To(Equal(\"OK\"))\n\n\t\t\tmGet = client.MGet(ctx, \"set1\", \"set2\", \"set3\", \"set4\")\n\t\t\tExpect(mGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mGet.Val()).To(Equal([]interface{}{\n\t\t\t\t\"val1\",\n\t\t\t\t\"1024\",\n\t\t\t\tstrconv.Itoa(int(2 * time.Millisecond.Nanoseconds())),\n\t\t\t\t\"\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should scan Mget\", func() {\n\t\t\tnow := time.Now()\n\n\t\t\terr := client.MSet(ctx, \"key1\", \"hello1\", \"key2\", 123, \"time\", now.Format(time.RFC3339Nano)).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tres := client.MGet(ctx, \"key1\", \"key2\", \"_\", \"time\")\n\t\t\tExpect(res.Err()).NotTo(HaveOccurred())\n\n\t\t\ttype data struct {\n\t\t\t\tKey1 string    `redis:\"key1\"`\n\t\t\t\tKey2 int       `redis:\"key2\"`\n\t\t\t\tTime TimeValue `redis:\"time\"`\n\t\t\t}\n\t\t\tvar d data\n\t\t\tExpect(res.Scan(&d)).NotTo(HaveOccurred())\n\t\t\tExpect(d.Time.UnixNano()).To(Equal(now.UnixNano()))\n\t\t\td.Time.Time = time.Time{}\n\t\t\tExpect(d).To(Equal(data{\n\t\t\t\tKey1: \"hello1\",\n\t\t\t\tKey2: 123,\n\t\t\t\tTime: TimeValue{Time: time.Time{}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should MSetNX\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tmSetNX := client.MSetNX(ctx, \"key1\", \"hello1\", \"key2\", \"hello2\")\n\t\t\tExpect(mSetNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mSetNX.Val()).To(Equal(true))\n\n\t\t\tmSetNX = client.MSetNX(ctx, \"key2\", \"hello1\", \"key3\", \"hello2\")\n\t\t\tExpect(mSetNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mSetNX.Val()).To(Equal(false))\n\n\t\t\t// set struct\n\t\t\t// MSet struct\n\t\t\ttype set struct {\n\t\t\t\tSet1 string                 `redis:\"set1\"`\n\t\t\t\tSet2 int16                  `redis:\"set2\"`\n\t\t\t\tSet3 time.Duration          `redis:\"set3\"`\n\t\t\t\tSet4 interface{}            `redis:\"set4\"`\n\t\t\t\tSet5 map[string]interface{} `redis:\"-\"`\n\t\t\t}\n\t\t\tmSetNX = client.MSetNX(ctx, &set{\n\t\t\t\tSet1: \"val1\",\n\t\t\t\tSet2: 1024,\n\t\t\t\tSet3: 2 * time.Millisecond,\n\t\t\t\tSet4: nil,\n\t\t\t\tSet5: map[string]interface{}{\"k1\": 1},\n\t\t\t})\n\t\t\tExpect(mSetNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(mSetNX.Val()).To(Equal(true))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with TTL\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tTTL: 500 * time.Millisecond,\n\t\t\t}\n\t\t\terr := client.SetArgs(ctx, \"key\", \"hello\", args).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.Get(ctx, \"key\").Err()\n\t\t\t}, \"2s\", \"100ms\").Should(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with expiration date\", func() {\n\t\t\texpireAt := time.Now().AddDate(1, 1, 1)\n\t\t\targs := redis.SetArgs{\n\t\t\t\tExpireAt: expireAt,\n\t\t\t}\n\t\t\terr := client.SetArgs(ctx, \"key\", \"hello\", args).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\n\t\t\t// check the key has an expiration date\n\t\t\t// (so a TTL value different of -1)\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val()).ToNot(Equal(-1))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with negative expiration date\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tExpireAt: time.Now().AddDate(-3, 1, 1),\n\t\t\t}\n\t\t\t// redis accepts a timestamp less than the current date\n\t\t\t// but returns nil when trying to get the key\n\t\t\terr := client.SetArgs(ctx, \"key\", \"hello\", args).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with keepttl\", func() {\n\t\t\t// Set with ttl\n\t\t\targsWithTTL := redis.SetArgs{\n\t\t\t\tTTL: 5 * time.Second,\n\t\t\t}\n\t\t\tset := client.SetArgs(ctx, \"key\", \"hello\", argsWithTTL)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Result()).To(Equal(\"OK\"))\n\n\t\t\t// Set with keepttl\n\t\t\targsWithKeepTTL := redis.SetArgs{\n\t\t\t\tKeepTTL: true,\n\t\t\t}\n\t\t\tset = client.SetArgs(ctx, \"key\", \"hello\", argsWithKeepTTL)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Result()).To(Equal(\"OK\"))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\t// set keepttl will Retain the ttl associated with the key\n\t\t\tExpect(ttl.Val().Nanoseconds()).NotTo(Equal(-1))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with NX mode and key exists\", func() {\n\t\t\terr := client.Set(ctx, \"key\", \"hello\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\targs := redis.SetArgs{\n\t\t\t\tMode: \"nx\",\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"hello\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with NX mode and key does not exist\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tMode: \"nx\",\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"hello\", args).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with NX mode and GET option\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tMode: \"nx\",\n\t\t\t\tGet:  true,\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"hello\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with expiration, NX mode, and key does not exist\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tTTL:  500 * time.Millisecond,\n\t\t\t\tMode: \"nx\",\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"hello\", args).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"OK\"))\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.Get(ctx, \"key\").Err()\n\t\t\t}, \"1s\", \"100ms\").Should(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with expiration, NX mode, and key exists\", func() {\n\t\t\te := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(e.Err()).NotTo(HaveOccurred())\n\n\t\t\targs := redis.SetArgs{\n\t\t\t\tTTL:  500 * time.Millisecond,\n\t\t\t\tMode: \"nx\",\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with expiration, NX mode, and GET option\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tTTL:  500 * time.Millisecond,\n\t\t\t\tMode: \"nx\",\n\t\t\t\tGet:  true,\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"hello\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with XX mode and key does not exist\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tMode: \"xx\",\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with XX mode and key exists\", func() {\n\t\t\te := client.Set(ctx, \"key\", \"hello\", 0).Err()\n\t\t\tExpect(e).NotTo(HaveOccurred())\n\n\t\t\targs := redis.SetArgs{\n\t\t\t\tMode: \"xx\",\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with XX mode and GET option, and key exists\", func() {\n\t\t\te := client.Set(ctx, \"key\", \"hello\", 0).Err()\n\t\t\tExpect(e).NotTo(HaveOccurred())\n\n\t\t\targs := redis.SetArgs{\n\t\t\t\tMode: \"xx\",\n\t\t\t\tGet:  true,\n\t\t\t}\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with XX mode and GET option, and key does not exist\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tMode: \"xx\",\n\t\t\t\tGet:  true,\n\t\t\t}\n\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with expiration, XX mode, GET option, and key does not exist\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tTTL:  500 * time.Millisecond,\n\t\t\t\tMode: \"xx\",\n\t\t\t\tGet:  true,\n\t\t\t}\n\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with expiration, XX mode, GET option, and key exists\", func() {\n\t\t\te := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(e.Err()).NotTo(HaveOccurred())\n\n\t\t\targs := redis.SetArgs{\n\t\t\t\tTTL:  500 * time.Millisecond,\n\t\t\t\tMode: \"xx\",\n\t\t\t\tGet:  true,\n\t\t\t}\n\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.Get(ctx, \"key\").Err()\n\t\t\t}, \"1s\", \"100ms\").Should(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with Get and key does not exist yet\", func() {\n\t\t\targs := redis.SetArgs{\n\t\t\t\tGet: true,\n\t\t\t}\n\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"hello\", args).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should SetWithArgs with Get and key exists\", func() {\n\t\t\te := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(e.Err()).NotTo(HaveOccurred())\n\n\t\t\targs := redis.SetArgs{\n\t\t\t\tGet: true,\n\t\t\t}\n\n\t\t\tval, err := client.SetArgs(ctx, \"key\", \"world\", args).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should Pipelined SetArgs with Get and key exists\", func() {\n\t\t\te := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(e.Err()).NotTo(HaveOccurred())\n\n\t\t\targs := redis.SetArgs{\n\t\t\t\tGet: true,\n\t\t\t}\n\n\t\t\tpipe := client.Pipeline()\n\t\t\tsetArgs := pipe.SetArgs(ctx, \"key\", \"world\", args)\n\t\t\t_, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(setArgs.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(setArgs.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should Set with expiration\", func() {\n\t\t\terr := client.Set(ctx, \"key\", \"hello\", 100*time.Millisecond).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.Get(ctx, \"key\").Err()\n\t\t\t}, \"1s\", \"100ms\").Should(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should Set with keepttl\", func() {\n\t\t\t// set with ttl\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 5*time.Second)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\t// set with keepttl\n\t\t\tset = client.Set(ctx, \"key\", \"hello1\", redis.KeepTTL)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\t// set keepttl will Retain the ttl associated with the key\n\t\t\tExpect(ttl.Val().Nanoseconds()).NotTo(Equal(-1))\n\t\t})\n\n\t\tIt(\"should SetGet\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should SetEX\", func() {\n\t\t\terr := client.SetEx(ctx, \"key\", \"hello\", 1*time.Second).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.Get(ctx, \"foo\").Err()\n\t\t\t}, \"2s\", \"100ms\").Should(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should SetNX\", func() {\n\t\t\tsetNX := client.SetNX(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(setNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(setNX.Val()).To(Equal(true))\n\n\t\t\tsetNX = client.SetNX(ctx, \"key\", \"hello2\", 0)\n\t\t\tExpect(setNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(setNX.Val()).To(Equal(false))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should SetNX with expiration\", func() {\n\t\t\tisSet, err := client.SetNX(ctx, \"key\", \"hello\", time.Second).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(true))\n\n\t\t\tisSet, err = client.SetNX(ctx, \"key\", \"hello2\", time.Second).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(false))\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should SetNX with keepttl\", func() {\n\t\t\tisSet, err := client.SetNX(ctx, \"key\", \"hello1\", redis.KeepTTL).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(true))\n\n\t\t\tttl := client.TTL(ctx, \"key\")\n\t\t\tExpect(ttl.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ttl.Val().Nanoseconds()).To(Equal(int64(-1)))\n\t\t})\n\n\t\tIt(\"should SetXX\", func() {\n\t\t\tisSet, err := client.SetXX(ctx, \"key\", \"hello2\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(false))\n\n\t\t\terr = client.Set(ctx, \"key\", \"hello\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tisSet, err = client.SetXX(ctx, \"key\", \"hello2\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(true))\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello2\"))\n\t\t})\n\n\t\tIt(\"should SetXX with expiration\", func() {\n\t\t\tisSet, err := client.SetXX(ctx, \"key\", \"hello2\", time.Second).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(false))\n\n\t\t\terr = client.Set(ctx, \"key\", \"hello\", time.Second).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tisSet, err = client.SetXX(ctx, \"key\", \"hello2\", time.Second).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(true))\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello2\"))\n\t\t})\n\n\t\tIt(\"should SetXX with keepttl\", func() {\n\t\t\tisSet, err := client.SetXX(ctx, \"key\", \"hello2\", time.Second).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(false))\n\n\t\t\terr = client.Set(ctx, \"key\", \"hello\", time.Second).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tisSet, err = client.SetXX(ctx, \"key\", \"hello2\", 5*time.Second).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(true))\n\n\t\t\tisSet, err = client.SetXX(ctx, \"key\", \"hello3\", redis.KeepTTL).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(isSet).To(Equal(true))\n\n\t\t\tval, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"hello3\"))\n\n\t\t\t// set keepttl will Retain the ttl associated with the key\n\t\t\tttl, err := client.TTL(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(ttl).NotTo(Equal(-1))\n\t\t})\n\n\t\tIt(\"should SetRange\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"Hello World\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\trange_ := client.SetRange(ctx, \"key\", 6, \"Redis\")\n\t\t\tExpect(range_.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(range_.Val()).To(Equal(int64(11)))\n\n\t\t\tget := client.Get(ctx, \"key\")\n\t\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(get.Val()).To(Equal(\"Hello Redis\"))\n\t\t})\n\n\t\tIt(\"should StrLen\", func() {\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tstrLen := client.StrLen(ctx, \"key\")\n\t\t\tExpect(strLen.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(strLen.Val()).To(Equal(int64(5)))\n\n\t\t\tstrLen = client.StrLen(ctx, \"_\")\n\t\t\tExpect(strLen.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(strLen.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should Copy\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tset := client.Set(ctx, \"key\", \"hello\", 0)\n\t\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\t\tcopy := client.Copy(ctx, \"key\", \"newKey\", redisOptions().DB, false)\n\t\t\tExpect(copy.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(copy.Val()).To(Equal(int64(1)))\n\n\t\t\t// Value is available by both keys now\n\t\t\tgetOld := client.Get(ctx, \"key\")\n\t\t\tExpect(getOld.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getOld.Val()).To(Equal(\"hello\"))\n\t\t\tgetNew := client.Get(ctx, \"newKey\")\n\t\t\tExpect(getNew.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(getNew.Val()).To(Equal(\"hello\"))\n\n\t\t\t// Overwriting an existing key should not succeed\n\t\t\toverwrite := client.Copy(ctx, \"newKey\", \"key\", redisOptions().DB, false)\n\t\t\tExpect(overwrite.Val()).To(Equal(int64(0)))\n\n\t\t\t// Overwrite is allowed when replace=rue\n\t\t\treplace := client.Copy(ctx, \"newKey\", \"key\", redisOptions().DB, true)\n\t\t\tExpect(replace.Val()).To(Equal(int64(1)))\n\t\t})\n\n\t\tIt(\"should acl dryrun\", func() {\n\t\t\tdryRun := client.ACLDryRun(ctx, \"default\", \"get\", \"randomKey\")\n\t\t\tExpect(dryRun.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(dryRun.Val()).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should fail module loadex\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tdryRun := client.ModuleLoadex(ctx, &redis.ModuleLoadexConfig{\n\t\t\t\tPath: \"/path/to/non-existent-library.so\",\n\t\t\t\tConf: map[string]interface{}{\n\t\t\t\t\t\"param1\": \"value1\",\n\t\t\t\t},\n\t\t\t\tArgs: []interface{}{\n\t\t\t\t\t\"arg1\",\n\t\t\t\t},\n\t\t\t})\n\t\t\tExpect(dryRun.Err()).To(HaveOccurred())\n\t\t\tExpect(dryRun.Err().Error()).To(Equal(\"ERR Error loading the extension. Please check the server logs.\"))\n\t\t})\n\n\t\tIt(\"converts the module loadex configuration to a slice of arguments correctly\", func() {\n\t\t\tconf := &redis.ModuleLoadexConfig{\n\t\t\t\tPath: \"/path/to/your/module.so\",\n\t\t\t\tConf: map[string]interface{}{\n\t\t\t\t\t\"param1\": \"value1\",\n\t\t\t\t},\n\t\t\t\tArgs: []interface{}{\n\t\t\t\t\t\"arg1\",\n\t\t\t\t\t\"arg2\",\n\t\t\t\t\t3,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\targs := conf.ToArgs()\n\n\t\t\t// Test if the arguments are in the correct order\n\t\t\texpectedArgs := []interface{}{\n\t\t\t\t\"MODULE\",\n\t\t\t\t\"LOADEX\",\n\t\t\t\t\"/path/to/your/module.so\",\n\t\t\t\t\"CONFIG\",\n\t\t\t\t\"param1\",\n\t\t\t\t\"value1\",\n\t\t\t\t\"ARGS\",\n\t\t\t\t\"arg1\",\n\t\t\t\t\"ARGS\",\n\t\t\t\t\"arg2\",\n\t\t\t\t\"ARGS\",\n\t\t\t\t3,\n\t\t\t}\n\n\t\t\tExpect(args).To(Equal(expectedArgs))\n\t\t})\n\n\t\tIt(\"should ACL LOG\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.Do(ctx, \"acl\", \"setuser\", \"test\", \">test\", \"on\", \"allkeys\", \"+get\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tclientAcl := redis.NewClient(redisOptions())\n\t\t\tclientAcl.Options().Username = \"test\"\n\t\t\tclientAcl.Options().Password = \"test\"\n\t\t\tclientAcl.Options().DB = 0\n\t\t\t_ = clientAcl.Set(ctx, \"mystring\", \"foo\", 0).Err()\n\t\t\t_ = clientAcl.HSet(ctx, \"myhash\", \"foo\", \"bar\").Err()\n\t\t\t_ = clientAcl.SAdd(ctx, \"myset\", \"foo\", \"bar\").Err()\n\n\t\t\tlogEntries, err := client.ACLLog(ctx, 10).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(logEntries)).To(Equal(4))\n\n\t\t\tfor _, entry := range logEntries {\n\t\t\t\tExpect(entry.Reason).To(Equal(\"command\"))\n\t\t\t\tExpect(entry.Context).To(Equal(\"toplevel\"))\n\t\t\t\tExpect(entry.Object).NotTo(BeEmpty())\n\t\t\t\tExpect(entry.Username).To(Equal(\"test\"))\n\t\t\t\tExpect(entry.AgeSeconds).To(BeNumerically(\">=\", 0))\n\t\t\t\tExpect(entry.ClientInfo).NotTo(BeNil())\n\t\t\t\tExpect(entry.EntryID).To(BeNumerically(\">=\", 0))\n\t\t\t\tExpect(entry.TimestampCreated).To(BeNumerically(\">=\", 0))\n\t\t\t\tExpect(entry.TimestampLastUpdated).To(BeNumerically(\">=\", 0))\n\t\t\t}\n\n\t\t\tlimitedLogEntries, err := client.ACLLog(ctx, 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(limitedLogEntries)).To(Equal(2))\n\t\t})\n\n\t\tIt(\"should ACL LOG RESET\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\t// Call ACL LOG RESET\n\t\t\tresetCmd := client.ACLLogReset(ctx)\n\t\t\tExpect(resetCmd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(resetCmd.Val()).To(Equal(\"OK\"))\n\n\t\t\t// Verify that the log is empty after the reset\n\t\t\tlogEntries, err := client.ACLLog(ctx, 10).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(logEntries)).To(Equal(0))\n\t\t})\n\t})\n\n\tDescribe(\"hashes\", func() {\n\t\tIt(\"should HDel\", func() {\n\t\t\thSet := client.HSet(ctx, \"hash\", \"key\", \"hello\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\n\t\t\thDel := client.HDel(ctx, \"hash\", \"key\")\n\t\t\tExpect(hDel.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hDel.Val()).To(Equal(int64(1)))\n\n\t\t\thDel = client.HDel(ctx, \"hash\", \"key\")\n\t\t\tExpect(hDel.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hDel.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should HExists\", func() {\n\t\t\thSet := client.HSet(ctx, \"hash\", \"key\", \"hello\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\n\t\t\thExists := client.HExists(ctx, \"hash\", \"key\")\n\t\t\tExpect(hExists.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hExists.Val()).To(Equal(true))\n\n\t\t\thExists = client.HExists(ctx, \"hash\", \"key1\")\n\t\t\tExpect(hExists.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hExists.Val()).To(Equal(false))\n\t\t})\n\n\t\tIt(\"should HGet\", func() {\n\t\t\thSet := client.HSet(ctx, \"hash\", \"key\", \"hello\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\n\t\t\thGet := client.HGet(ctx, \"hash\", \"key\")\n\t\t\tExpect(hGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hGet.Val()).To(Equal(\"hello\"))\n\n\t\t\thGet = client.HGet(ctx, \"hash\", \"key1\")\n\t\t\tExpect(hGet.Err()).To(Equal(redis.Nil))\n\t\t\tExpect(hGet.Val()).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should HGetAll\", func() {\n\t\t\terr := client.HSet(ctx, \"hash\", \"key1\", \"hello1\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.HSet(ctx, \"hash\", \"key2\", \"hello2\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tm, err := client.HGetAll(ctx, \"hash\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(m).To(Equal(map[string]string{\"key1\": \"hello1\", \"key2\": \"hello2\"}))\n\t\t})\n\n\t\tIt(\"should scan\", func() {\n\t\t\tnow := time.Now()\n\n\t\t\terr := client.HMSet(ctx, \"hash\", \"key1\", \"hello1\", \"key2\", 123, \"time\", now.Format(time.RFC3339Nano)).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tres := client.HGetAll(ctx, \"hash\")\n\t\t\tExpect(res.Err()).NotTo(HaveOccurred())\n\n\t\t\ttype data struct {\n\t\t\t\tKey1 string    `redis:\"key1\"`\n\t\t\t\tKey2 int       `redis:\"key2\"`\n\t\t\t\tTime TimeValue `redis:\"time\"`\n\t\t\t}\n\t\t\tvar d data\n\t\t\tExpect(res.Scan(&d)).NotTo(HaveOccurred())\n\t\t\tExpect(d.Time.UnixNano()).To(Equal(now.UnixNano()))\n\t\t\td.Time.Time = time.Time{}\n\t\t\tExpect(d).To(Equal(data{\n\t\t\t\tKey1: \"hello1\",\n\t\t\t\tKey2: 123,\n\t\t\t\tTime: TimeValue{Time: time.Time{}},\n\t\t\t}))\n\n\t\t\ttype data2 struct {\n\t\t\t\tKey1 string    `redis:\"key1\"`\n\t\t\t\tKey2 int       `redis:\"key2\"`\n\t\t\t\tTime time.Time `redis:\"time\"`\n\t\t\t}\n\t\t\terr = client.HSet(ctx, \"hash\", &data2{\n\t\t\t\tKey1: \"hello2\",\n\t\t\t\tKey2: 200,\n\t\t\t\tTime: now,\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar d2 data2\n\t\t\terr = client.HMGet(ctx, \"hash\", \"key1\", \"key2\", \"time\").Scan(&d2)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(d2.Key1).To(Equal(\"hello2\"))\n\t\t\tExpect(d2.Key2).To(Equal(200))\n\t\t\tExpect(d2.Time.Unix()).To(Equal(now.Unix()))\n\t\t})\n\n\t\tIt(\"should HIncrBy\", func() {\n\t\t\thSet := client.HSet(ctx, \"hash\", \"key\", \"5\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\n\t\t\thIncrBy := client.HIncrBy(ctx, \"hash\", \"key\", 1)\n\t\t\tExpect(hIncrBy.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hIncrBy.Val()).To(Equal(int64(6)))\n\n\t\t\thIncrBy = client.HIncrBy(ctx, \"hash\", \"key\", -1)\n\t\t\tExpect(hIncrBy.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hIncrBy.Val()).To(Equal(int64(5)))\n\n\t\t\thIncrBy = client.HIncrBy(ctx, \"hash\", \"key\", -10)\n\t\t\tExpect(hIncrBy.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hIncrBy.Val()).To(Equal(int64(-5)))\n\t\t})\n\n\t\tIt(\"should HIncrByFloat\", func() {\n\t\t\thSet := client.HSet(ctx, \"hash\", \"field\", \"10.50\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hSet.Val()).To(Equal(int64(1)))\n\n\t\t\thIncrByFloat := client.HIncrByFloat(ctx, \"hash\", \"field\", 0.1)\n\t\t\tExpect(hIncrByFloat.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hIncrByFloat.Val()).To(Equal(10.6))\n\n\t\t\thSet = client.HSet(ctx, \"hash\", \"field\", \"5.0e3\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hSet.Val()).To(Equal(int64(0)))\n\n\t\t\thIncrByFloat = client.HIncrByFloat(ctx, \"hash\", \"field\", 2.0e2)\n\t\t\tExpect(hIncrByFloat.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hIncrByFloat.Val()).To(Equal(float64(5200)))\n\t\t})\n\n\t\tIt(\"should HKeys\", func() {\n\t\t\thkeys := client.HKeys(ctx, \"hash\")\n\t\t\tExpect(hkeys.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hkeys.Val()).To(Equal([]string{}))\n\n\t\t\thset := client.HSet(ctx, \"hash\", \"key1\", \"hello1\")\n\t\t\tExpect(hset.Err()).NotTo(HaveOccurred())\n\t\t\thset = client.HSet(ctx, \"hash\", \"key2\", \"hello2\")\n\t\t\tExpect(hset.Err()).NotTo(HaveOccurred())\n\n\t\t\thkeys = client.HKeys(ctx, \"hash\")\n\t\t\tExpect(hkeys.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hkeys.Val()).To(Equal([]string{\"key1\", \"key2\"}))\n\t\t})\n\n\t\tIt(\"should HLen\", func() {\n\t\t\thSet := client.HSet(ctx, \"hash\", \"key1\", \"hello1\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\t\t\thSet = client.HSet(ctx, \"hash\", \"key2\", \"hello2\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\n\t\t\thLen := client.HLen(ctx, \"hash\")\n\t\t\tExpect(hLen.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hLen.Val()).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should HMGet\", func() {\n\t\t\terr := client.HSet(ctx, \"hash\", \"key1\", \"hello1\", \"key2\", \"hello2\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.HMGet(ctx, \"hash\", \"key1\", \"key2\", \"_\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]interface{}{\"hello1\", \"hello2\", nil}))\n\t\t})\n\n\t\tIt(\"should HSet\", func() {\n\t\t\tok, err := client.HSet(ctx, \"hash\", map[string]interface{}{\n\t\t\t\t\"key1\": \"hello1\",\n\t\t\t\t\"key2\": \"hello2\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(ok).To(Equal(int64(2)))\n\n\t\t\tv, err := client.HGet(ctx, \"hash\", \"key1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(\"hello1\"))\n\n\t\t\tv, err = client.HGet(ctx, \"hash\", \"key2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(\"hello2\"))\n\n\t\t\tkeys, err := client.HKeys(ctx, \"hash\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(keys).To(ConsistOf([]string{\"key1\", \"key2\"}))\n\t\t})\n\n\t\tIt(\"should HSet\", func() {\n\t\t\thSet := client.HSet(ctx, \"hash\", \"key\", \"hello\")\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hSet.Val()).To(Equal(int64(1)))\n\n\t\t\thGet := client.HGet(ctx, \"hash\", \"key\")\n\t\t\tExpect(hGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hGet.Val()).To(Equal(\"hello\"))\n\n\t\t\t// set struct\n\t\t\t// MSet struct\n\t\t\ttype set struct {\n\t\t\t\tSet1 string                 `redis:\"set1\"`\n\t\t\t\tSet2 int16                  `redis:\"set2\"`\n\t\t\t\tSet3 time.Duration          `redis:\"set3\"`\n\t\t\t\tSet4 interface{}            `redis:\"set4\"`\n\t\t\t\tSet5 map[string]interface{} `redis:\"-\"`\n\t\t\t\tSet6 string                 `redis:\"set6,omitempty\"`\n\t\t\t}\n\n\t\t\thSet = client.HSet(ctx, \"hash\", &set{\n\t\t\t\tSet1: \"val1\",\n\t\t\t\tSet2: 1024,\n\t\t\t\tSet3: 2 * time.Millisecond,\n\t\t\t\tSet4: nil,\n\t\t\t\tSet5: map[string]interface{}{\"k1\": 1},\n\t\t\t})\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hSet.Val()).To(Equal(int64(4)))\n\n\t\t\thMGet := client.HMGet(ctx, \"hash\", \"set1\", \"set2\", \"set3\", \"set4\", \"set5\", \"set6\")\n\t\t\tExpect(hMGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hMGet.Val()).To(Equal([]interface{}{\n\t\t\t\t\"val1\",\n\t\t\t\t\"1024\",\n\t\t\t\tstrconv.Itoa(int(2 * time.Millisecond.Nanoseconds())),\n\t\t\t\t\"\",\n\t\t\t\tnil,\n\t\t\t\tnil,\n\t\t\t}))\n\n\t\t\thSet = client.HSet(ctx, \"hash2\", &set{\n\t\t\t\tSet1: \"val2\",\n\t\t\t\tSet6: \"val\",\n\t\t\t})\n\t\t\tExpect(hSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hSet.Val()).To(Equal(int64(5)))\n\n\t\t\thMGet = client.HMGet(ctx, \"hash2\", \"set1\", \"set6\")\n\t\t\tExpect(hMGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hMGet.Val()).To(Equal([]interface{}{\n\t\t\t\t\"val2\",\n\t\t\t\t\"val\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should HSetNX\", func() {\n\t\t\thSetNX := client.HSetNX(ctx, \"hash\", \"key\", \"hello\")\n\t\t\tExpect(hSetNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hSetNX.Val()).To(Equal(true))\n\n\t\t\thSetNX = client.HSetNX(ctx, \"hash\", \"key\", \"hello\")\n\t\t\tExpect(hSetNX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hSetNX.Val()).To(Equal(false))\n\n\t\t\thGet := client.HGet(ctx, \"hash\", \"key\")\n\t\t\tExpect(hGet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(hGet.Val()).To(Equal(\"hello\"))\n\t\t})\n\n\t\tIt(\"should HVals\", func() {\n\t\t\terr := client.HSet(ctx, \"hash\", \"key1\", \"hello1\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.HSet(ctx, \"hash\", \"key2\", \"hello2\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.HVals(ctx, \"hash\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal([]string{\"hello1\", \"hello2\"}))\n\n\t\t\tvar slice []string\n\t\t\terr = client.HVals(ctx, \"hash\").ScanSlice(&slice)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(slice).To(Equal([]string{\"hello1\", \"hello2\"}))\n\t\t})\n\n\t\tIt(\"should HRandField\", func() {\n\t\t\terr := client.HSet(ctx, \"hash\", \"key1\", \"hello1\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.HSet(ctx, \"hash\", \"key2\", \"hello2\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv := client.HRandField(ctx, \"hash\", 1)\n\t\t\tExpect(v.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(v.Val()).To(Or(Equal([]string{\"key1\"}), Equal([]string{\"key2\"})))\n\n\t\t\tv = client.HRandField(ctx, \"hash\", 0)\n\t\t\tExpect(v.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(v.Val()).To(HaveLen(0))\n\n\t\t\tkv, err := client.HRandFieldWithValues(ctx, \"hash\", 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(kv).To(Or(\n\t\t\t\tEqual([]redis.KeyValue{{Key: \"key1\", Value: \"hello1\"}}),\n\t\t\t\tEqual([]redis.KeyValue{{Key: \"key2\", Value: \"hello2\"}}),\n\t\t\t))\n\t\t})\n\n\t\tIt(\"should HExpire\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tres, err := client.HExpire(ctx, \"no_such_key\", 10*time.Second, \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(res).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err = client.HExpire(ctx, \"myhash\", 10*time.Second, \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, 1, -2}))\n\t\t})\n\n\t\tIt(\"should HPExpire\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tres, err := client.HPExpire(ctx, \"no_such_key\", 10*time.Second, \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(res).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err = client.HPExpire(ctx, \"myhash\", 10*time.Second, \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, 1, -2}))\n\t\t})\n\n\t\tIt(\"should HExpireAt\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tresEmpty, err := client.HExpireAt(ctx, \"no_such_key\", time.Now().Add(10*time.Second), \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(resEmpty).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err := client.HExpireAt(ctx, \"myhash\", time.Now().Add(10*time.Second), \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, 1, -2}))\n\t\t})\n\n\t\tIt(\"should HPExpireAt\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tresEmpty, err := client.HPExpireAt(ctx, \"no_such_key\", time.Now().Add(10*time.Second), \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(resEmpty).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err := client.HPExpireAt(ctx, \"myhash\", time.Now().Add(10*time.Second), \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, 1, -2}))\n\t\t})\n\n\t\tIt(\"should HPersist\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tresEmpty, err := client.HPersist(ctx, \"no_such_key\", \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(resEmpty).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err := client.HPersist(ctx, \"myhash\", \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{-1, -1, -2}))\n\n\t\t\tres, err = client.HExpire(ctx, \"myhash\", 10*time.Second, \"key1\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, -2}))\n\n\t\t\tres, err = client.HPersist(ctx, \"myhash\", \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, -1, -2}))\n\t\t})\n\n\t\tIt(\"should HExpireTime\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tresEmpty, err := client.HExpireTime(ctx, \"no_such_key\", \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(resEmpty).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err := client.HExpire(ctx, \"myhash\", 10*time.Second, \"key1\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, -2}))\n\n\t\t\tres, err = client.HExpireTime(ctx, \"myhash\", \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res[0]).To(BeNumerically(\"~\", time.Now().Add(10*time.Second).Unix(), 1))\n\t\t})\n\n\t\tIt(\"should HPExpireTime\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tresEmpty, err := client.HPExpireTime(ctx, \"no_such_key\", \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(resEmpty).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\texpireAt := time.Now().Add(10 * time.Second)\n\t\t\tres, err := client.HPExpireAt(ctx, \"myhash\", expireAt, \"key1\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, -2}))\n\n\t\t\tres, err = client.HPExpireTime(ctx, \"myhash\", \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(BeEquivalentTo([]int64{expireAt.UnixMilli(), -1, -2}))\n\t\t})\n\n\t\tIt(\"should HTTL\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tresEmpty, err := client.HTTL(ctx, \"no_such_key\", \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(resEmpty).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err := client.HExpire(ctx, \"myhash\", 10*time.Second, \"key1\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, -2}))\n\n\t\t\tres, err = client.HTTL(ctx, \"myhash\", \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{10, -1, -2}))\n\t\t})\n\n\t\tIt(\"should HPTTL\", Label(\"hash-expiration\", \"NonRedisEnterprise\"), func() {\n\t\t\tresEmpty, err := client.HPTTL(ctx, \"no_such_key\", \"field1\", \"field2\", \"field3\").Result()\n\t\t\tExpect(err).To(BeNil())\n\t\t\tExpect(resEmpty).To(BeEquivalentTo([]int64{-2, -2, -2}))\n\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tsadd := client.HSet(ctx, \"myhash\", fmt.Sprintf(\"key%d\", i), \"hello\")\n\t\t\t\tExpect(sadd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tres, err := client.HExpire(ctx, \"myhash\", 10*time.Second, \"key1\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]int64{1, -2}))\n\n\t\t\tres, err = client.HPTTL(ctx, \"myhash\", \"key1\", \"key2\", \"key200\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res[0]).To(BeNumerically(\"~\", 10*time.Second.Milliseconds(), 1))\n\t\t})\n\t})\n\n\tDescribe(\"hyperloglog\", func() {\n\t\tIt(\"should PFMerge\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tpfAdd := client.PFAdd(ctx, \"hll1\", \"1\", \"2\", \"3\", \"4\", \"5\")\n\t\t\tExpect(pfAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tpfCount := client.PFCount(ctx, \"hll1\")\n\t\t\tExpect(pfCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pfCount.Val()).To(Equal(int64(5)))\n\n\t\t\tpfAdd = client.PFAdd(ctx, \"hll2\", \"a\", \"b\", \"c\", \"d\", \"e\")\n\t\t\tExpect(pfAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tpfMerge := client.PFMerge(ctx, \"hllMerged\", \"hll1\", \"hll2\")\n\t\t\tExpect(pfMerge.Err()).NotTo(HaveOccurred())\n\n\t\t\tpfCount = client.PFCount(ctx, \"hllMerged\")\n\t\t\tExpect(pfCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pfCount.Val()).To(Equal(int64(10)))\n\n\t\t\tpfCount = client.PFCount(ctx, \"hll1\", \"hll2\")\n\t\t\tExpect(pfCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(pfCount.Val()).To(Equal(int64(10)))\n\t\t})\n\t})\n\n\tDescribe(\"lists\", func() {\n\t\tIt(\"should BLPop\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\trPush := client.RPush(ctx, \"list1\", \"a\", \"b\", \"c\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tbLPop := client.BLPop(ctx, 0, \"list1\", \"list2\")\n\t\t\tExpect(bLPop.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bLPop.Val()).To(Equal([]string{\"list1\", \"a\"}))\n\t\t})\n\n\t\tIt(\"should BLPopBlocks\", func() {\n\t\t\tstarted := make(chan bool)\n\t\t\tdone := make(chan bool)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tstarted <- true\n\t\t\t\tbLPop := client.BLPop(ctx, 0, \"list\")\n\t\t\t\tExpect(bLPop.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(bLPop.Val()).To(Equal([]string{\"list\", \"a\"}))\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\t<-started\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tFail(\"BLPop is not blocked\")\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\t// ok\n\t\t\t}\n\n\t\t\trPush := client.RPush(ctx, \"list\", \"a\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// ok\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tFail(\"BLPop is still blocked\")\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should BLPop timeout\", func() {\n\t\t\tval, err := client.BLPop(ctx, time.Second, \"list1\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(BeNil())\n\n\t\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\n\t\t\tstats := client.PoolStats()\n\t\t\tExpect(stats.Hits).To(Equal(uint32(2)))\n\t\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t\t})\n\n\t\tIt(\"should BRPop\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\trPush := client.RPush(ctx, \"list1\", \"a\", \"b\", \"c\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tbRPop := client.BRPop(ctx, 0, \"list1\", \"list2\")\n\t\t\tExpect(bRPop.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(bRPop.Val()).To(Equal([]string{\"list1\", \"c\"}))\n\t\t})\n\n\t\tIt(\"should BRPop blocks\", func() {\n\t\t\tstarted := make(chan bool)\n\t\t\tdone := make(chan bool)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tstarted <- true\n\t\t\t\tbrpop := client.BRPop(ctx, 0, \"list\")\n\t\t\t\tExpect(brpop.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(brpop.Val()).To(Equal([]string{\"list\", \"a\"}))\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\t<-started\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tFail(\"BRPop is not blocked\")\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\t// ok\n\t\t\t}\n\n\t\t\trPush := client.RPush(ctx, \"list\", \"a\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// ok\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tFail(\"BRPop is still blocked\")\n\t\t\t\t// ok\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should BRPopLPush\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\t_, err := client.BRPopLPush(ctx, \"list1\", \"list2\", time.Second).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\n\t\t\terr = client.RPush(ctx, \"list1\", \"a\", \"b\", \"c\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.BRPopLPush(ctx, \"list1\", \"list2\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(\"c\"))\n\t\t})\n\n\t\tIt(\"should LCS\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.MSet(ctx, \"key1\", \"ohmytext\", \"key2\", \"mynewtext\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tlcs, err := client.LCS(ctx, &redis.LCSQuery{\n\t\t\t\tKey1: \"key1\",\n\t\t\t\tKey2: \"key2\",\n\t\t\t}).Result()\n\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(lcs.MatchString).To(Equal(\"mytext\"))\n\n\t\t\tlcs, err = client.LCS(ctx, &redis.LCSQuery{\n\t\t\t\tKey1: \"nonexistent_key1\",\n\t\t\t\tKey2: \"key2\",\n\t\t\t}).Result()\n\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(lcs.MatchString).To(Equal(\"\"))\n\n\t\t\tlcs, err = client.LCS(ctx, &redis.LCSQuery{\n\t\t\t\tKey1: \"key1\",\n\t\t\t\tKey2: \"key2\",\n\t\t\t\tLen:  true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(lcs.MatchString).To(Equal(\"\"))\n\t\t\tExpect(lcs.Len).To(Equal(int64(6)))\n\n\t\t\tlcs, err = client.LCS(ctx, &redis.LCSQuery{\n\t\t\t\tKey1: \"key1\",\n\t\t\t\tKey2: \"key2\",\n\t\t\t\tIdx:  true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(lcs.MatchString).To(Equal(\"\"))\n\t\t\tExpect(lcs.Len).To(Equal(int64(6)))\n\t\t\tExpect(lcs.Matches).To(Equal([]redis.LCSMatchedPosition{\n\t\t\t\t{\n\t\t\t\t\tKey1:     redis.LCSPosition{Start: 4, End: 7},\n\t\t\t\t\tKey2:     redis.LCSPosition{Start: 5, End: 8},\n\t\t\t\t\tMatchLen: 0,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tKey1:     redis.LCSPosition{Start: 2, End: 3},\n\t\t\t\t\tKey2:     redis.LCSPosition{Start: 0, End: 1},\n\t\t\t\t\tMatchLen: 0,\n\t\t\t\t},\n\t\t\t}))\n\n\t\t\tlcs, err = client.LCS(ctx, &redis.LCSQuery{\n\t\t\t\tKey1:         \"key1\",\n\t\t\t\tKey2:         \"key2\",\n\t\t\t\tIdx:          true,\n\t\t\t\tMinMatchLen:  3,\n\t\t\t\tWithMatchLen: true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(lcs.MatchString).To(Equal(\"\"))\n\t\t\tExpect(lcs.Len).To(Equal(int64(6)))\n\t\t\tExpect(lcs.Matches).To(Equal([]redis.LCSMatchedPosition{\n\t\t\t\t{\n\t\t\t\t\tKey1:     redis.LCSPosition{Start: 4, End: 7},\n\t\t\t\t\tKey2:     redis.LCSPosition{Start: 5, End: 8},\n\t\t\t\t\tMatchLen: 4,\n\t\t\t\t},\n\t\t\t}))\n\n\t\t\t_, err = client.Set(ctx, \"keywithstringvalue\", \"golang\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t_, err = client.LPush(ctx, \"keywithnonstringvalue\", \"somevalue\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t_, err = client.LCS(ctx, &redis.LCSQuery{\n\t\t\t\tKey1: \"keywithstringvalue\",\n\t\t\t\tKey2: \"keywithnonstringvalue\",\n\t\t\t}).Result()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(Equal(\"ERR The specified keys must contain string values\"))\n\t\t})\n\n\t\tIt(\"should LIndex\", func() {\n\t\t\tlPush := client.LPush(ctx, \"list\", \"World\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\t\t\tlPush = client.LPush(ctx, \"list\", \"Hello\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlIndex := client.LIndex(ctx, \"list\", 0)\n\t\t\tExpect(lIndex.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lIndex.Val()).To(Equal(\"Hello\"))\n\n\t\t\tlIndex = client.LIndex(ctx, \"list\", -1)\n\t\t\tExpect(lIndex.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lIndex.Val()).To(Equal(\"World\"))\n\n\t\t\tlIndex = client.LIndex(ctx, \"list\", 3)\n\t\t\tExpect(lIndex.Err()).To(Equal(redis.Nil))\n\t\t\tExpect(lIndex.Val()).To(Equal(\"\"))\n\t\t})\n\n\t\tIt(\"should LInsert\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"Hello\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"World\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlInsert := client.LInsert(ctx, \"list\", \"BEFORE\", \"World\", \"There\")\n\t\t\tExpect(lInsert.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lInsert.Val()).To(Equal(int64(3)))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"Hello\", \"There\", \"World\"}))\n\t\t})\n\n\t\tIt(\"should LMPop\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.LPush(ctx, \"list1\", \"one\", \"two\", \"three\", \"four\", \"five\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.LPush(ctx, \"list2\", \"a\", \"b\", \"c\", \"d\", \"e\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tkey, val, err := client.LMPop(ctx, \"left\", 3, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list1\"))\n\t\t\tExpect(val).To(Equal([]string{\"five\", \"four\", \"three\"}))\n\n\t\t\tkey, val, err = client.LMPop(ctx, \"right\", 3, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list1\"))\n\t\t\tExpect(val).To(Equal([]string{\"one\", \"two\"}))\n\n\t\t\tkey, val, err = client.LMPop(ctx, \"left\", 1, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list2\"))\n\t\t\tExpect(val).To(Equal([]string{\"e\"}))\n\n\t\t\tkey, val, err = client.LMPop(ctx, \"right\", 10, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list2\"))\n\t\t\tExpect(val).To(Equal([]string{\"a\", \"b\", \"c\", \"d\"}))\n\n\t\t\terr = client.LMPop(ctx, \"left\", 10, \"list1\", \"list2\").Err()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\n\t\t\terr = client.Set(ctx, \"list3\", 1024, 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.LMPop(ctx, \"left\", 10, \"list1\", \"list2\", \"list3\").Err()\n\t\t\tExpect(err.Error()).To(Equal(\"WRONGTYPE Operation against a key holding the wrong kind of value\"))\n\n\t\t\terr = client.LMPop(ctx, \"right\", 0, \"list1\", \"list2\").Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should BLMPop\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.LPush(ctx, \"list1\", \"one\", \"two\", \"three\", \"four\", \"five\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.LPush(ctx, \"list2\", \"a\", \"b\", \"c\", \"d\", \"e\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tkey, val, err := client.BLMPop(ctx, 0, \"left\", 3, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list1\"))\n\t\t\tExpect(val).To(Equal([]string{\"five\", \"four\", \"three\"}))\n\n\t\t\tkey, val, err = client.BLMPop(ctx, 0, \"right\", 3, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list1\"))\n\t\t\tExpect(val).To(Equal([]string{\"one\", \"two\"}))\n\n\t\t\tkey, val, err = client.BLMPop(ctx, 0, \"left\", 1, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list2\"))\n\t\t\tExpect(val).To(Equal([]string{\"e\"}))\n\n\t\t\tkey, val, err = client.BLMPop(ctx, 0, \"right\", 10, \"list1\", \"list2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"list2\"))\n\t\t\tExpect(val).To(Equal([]string{\"a\", \"b\", \"c\", \"d\"}))\n\t\t})\n\n\t\tIt(\"should BLMPopBlocks\", func() {\n\t\t\tstarted := make(chan bool)\n\t\t\tdone := make(chan bool)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tstarted <- true\n\t\t\t\tkey, val, err := client.BLMPop(ctx, 0, \"left\", 1, \"list_list\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(key).To(Equal(\"list_list\"))\n\t\t\t\tExpect(val).To(Equal([]string{\"a\"}))\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\t<-started\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tFail(\"BLMPop is not blocked\")\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\t// ok\n\t\t\t}\n\n\t\t\t_, err := client.LPush(ctx, \"list_list\", \"a\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// ok\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tFail(\"BLMPop is still blocked\")\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should BLMPop timeout\", func() {\n\t\t\t_, val, err := client.BLMPop(ctx, time.Second, \"left\", 1, \"list1\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(BeNil())\n\n\t\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\n\t\t\tstats := client.PoolStats()\n\t\t\tExpect(stats.Hits).To(Equal(uint32(2)))\n\t\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t\t})\n\n\t\tIt(\"should LLen\", func() {\n\t\t\tlPush := client.LPush(ctx, \"list\", \"World\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\t\t\tlPush = client.LPush(ctx, \"list\", \"Hello\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlLen := client.LLen(ctx, \"list\")\n\t\t\tExpect(lLen.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lLen.Val()).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should LPop\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"two\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"three\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlPop := client.LPop(ctx, \"list\")\n\t\t\tExpect(lPop.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPop.Val()).To(Equal(\"one\"))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"two\", \"three\"}))\n\t\t})\n\n\t\tIt(\"should LPopCount\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"two\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"three\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"four\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlPopCount := client.LPopCount(ctx, \"list\", 2)\n\t\t\tExpect(lPopCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPopCount.Val()).To(Equal([]string{\"one\", \"two\"}))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"three\", \"four\"}))\n\t\t})\n\n\t\tIt(\"should LPos\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"a\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"b\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"c\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"b\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlPos := client.LPos(ctx, \"list\", \"b\", redis.LPosArgs{})\n\t\t\tExpect(lPos.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPos.Val()).To(Equal(int64(1)))\n\n\t\t\tlPos = client.LPos(ctx, \"list\", \"b\", redis.LPosArgs{Rank: 2})\n\t\t\tExpect(lPos.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPos.Val()).To(Equal(int64(3)))\n\n\t\t\tlPos = client.LPos(ctx, \"list\", \"b\", redis.LPosArgs{Rank: -2})\n\t\t\tExpect(lPos.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPos.Val()).To(Equal(int64(1)))\n\n\t\t\tlPos = client.LPos(ctx, \"list\", \"b\", redis.LPosArgs{Rank: 2, MaxLen: 1})\n\t\t\tExpect(lPos.Err()).To(Equal(redis.Nil))\n\n\t\t\tlPos = client.LPos(ctx, \"list\", \"z\", redis.LPosArgs{})\n\t\t\tExpect(lPos.Err()).To(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should LPosCount\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"a\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"b\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"c\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"b\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlPos := client.LPosCount(ctx, \"list\", \"b\", 2, redis.LPosArgs{})\n\t\t\tExpect(lPos.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPos.Val()).To(Equal([]int64{1, 3}))\n\n\t\t\tlPos = client.LPosCount(ctx, \"list\", \"b\", 2, redis.LPosArgs{Rank: 2})\n\t\t\tExpect(lPos.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPos.Val()).To(Equal([]int64{3}))\n\n\t\t\tlPos = client.LPosCount(ctx, \"list\", \"b\", 1, redis.LPosArgs{Rank: 1, MaxLen: 1})\n\t\t\tExpect(lPos.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPos.Val()).To(Equal([]int64{}))\n\n\t\t\tlPos = client.LPosCount(ctx, \"list\", \"b\", 1, redis.LPosArgs{Rank: 1, MaxLen: 0})\n\t\t\tExpect(lPos.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPos.Val()).To(Equal([]int64{1}))\n\t\t})\n\n\t\tIt(\"should LPush\", func() {\n\t\t\tlPush := client.LPush(ctx, \"list\", \"World\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\t\t\tlPush = client.LPush(ctx, \"list\", \"Hello\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"Hello\", \"World\"}))\n\t\t})\n\n\t\tIt(\"should LPushX\", func() {\n\t\t\tlPush := client.LPush(ctx, \"list\", \"World\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlPushX := client.LPushX(ctx, \"list\", \"Hello\")\n\t\t\tExpect(lPushX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPushX.Val()).To(Equal(int64(2)))\n\n\t\t\tlPush = client.LPush(ctx, \"list1\", \"three\")\n\t\t\tExpect(lPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPush.Val()).To(Equal(int64(1)))\n\n\t\t\tlPushX = client.LPushX(ctx, \"list1\", \"two\", \"one\")\n\t\t\tExpect(lPushX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPushX.Val()).To(Equal(int64(3)))\n\n\t\t\tlPushX = client.LPushX(ctx, \"list2\", \"Hello\")\n\t\t\tExpect(lPushX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lPushX.Val()).To(Equal(int64(0)))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"Hello\", \"World\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list1\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\", \"two\", \"three\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list2\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{}))\n\t\t})\n\n\t\tIt(\"should LRange\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"two\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"three\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, 0)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list\", -3, 2)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\", \"two\", \"three\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list\", -100, 100)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\", \"two\", \"three\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list\", 5, 10)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{}))\n\t\t})\n\n\t\tIt(\"should LRem\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"hello\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"hello\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"key\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"hello\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlRem := client.LRem(ctx, \"list\", -2, \"hello\")\n\t\t\tExpect(lRem.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRem.Val()).To(Equal(int64(2)))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"hello\", \"key\"}))\n\t\t})\n\n\t\tIt(\"should LSet\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"two\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"three\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlSet := client.LSet(ctx, \"list\", 0, \"four\")\n\t\t\tExpect(lSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lSet.Val()).To(Equal(\"OK\"))\n\n\t\t\tlSet = client.LSet(ctx, \"list\", -2, \"five\")\n\t\t\tExpect(lSet.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lSet.Val()).To(Equal(\"OK\"))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"four\", \"five\", \"three\"}))\n\t\t})\n\n\t\tIt(\"should LTrim\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"two\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"three\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlTrim := client.LTrim(ctx, \"list\", 1, -1)\n\t\t\tExpect(lTrim.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lTrim.Val()).To(Equal(\"OK\"))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"two\", \"three\"}))\n\t\t})\n\n\t\tIt(\"should RPop\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"two\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"three\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\trPop := client.RPop(ctx, \"list\")\n\t\t\tExpect(rPop.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPop.Val()).To(Equal(\"three\"))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\", \"two\"}))\n\t\t})\n\n\t\tIt(\"should RPopCount\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\", \"two\", \"three\", \"four\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(4)))\n\n\t\t\trPopCount := client.RPopCount(ctx, \"list\", 2)\n\t\t\tExpect(rPopCount.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPopCount.Val()).To(Equal([]string{\"four\", \"three\"}))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\", \"two\"}))\n\t\t})\n\n\t\tIt(\"should RPopLPush\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"two\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\trPush = client.RPush(ctx, \"list\", \"three\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\n\t\t\trPopLPush := client.RPopLPush(ctx, \"list\", \"list2\")\n\t\t\tExpect(rPopLPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPopLPush.Val()).To(Equal(\"three\"))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\", \"two\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list2\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"three\"}))\n\t\t})\n\n\t\tIt(\"should RPush\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"Hello\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(1)))\n\n\t\t\trPush = client.RPush(ctx, \"list\", \"World\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(2)))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"Hello\", \"World\"}))\n\t\t})\n\n\t\tIt(\"should RPushX\", func() {\n\t\t\trPush := client.RPush(ctx, \"list\", \"Hello\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(1)))\n\n\t\t\trPushX := client.RPushX(ctx, \"list\", \"World\")\n\t\t\tExpect(rPushX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPushX.Val()).To(Equal(int64(2)))\n\n\t\t\trPush = client.RPush(ctx, \"list1\", \"one\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(1)))\n\n\t\t\trPushX = client.RPushX(ctx, \"list1\", \"two\", \"three\")\n\t\t\tExpect(rPushX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPushX.Val()).To(Equal(int64(3)))\n\n\t\t\trPushX = client.RPushX(ctx, \"list2\", \"World\")\n\t\t\tExpect(rPushX.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPushX.Val()).To(Equal(int64(0)))\n\n\t\t\tlRange := client.LRange(ctx, \"list\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"Hello\", \"World\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list1\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"one\", \"two\", \"three\"}))\n\n\t\t\tlRange = client.LRange(ctx, \"list2\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{}))\n\t\t})\n\n\t\tIt(\"should LMove\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\trPush := client.RPush(ctx, \"lmove1\", \"ichi\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(1)))\n\n\t\t\trPush = client.RPush(ctx, \"lmove1\", \"ni\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(2)))\n\n\t\t\trPush = client.RPush(ctx, \"lmove1\", \"san\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(3)))\n\n\t\t\tlMove := client.LMove(ctx, \"lmove1\", \"lmove2\", \"RIGHT\", \"LEFT\")\n\t\t\tExpect(lMove.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lMove.Val()).To(Equal(\"san\"))\n\n\t\t\tlRange := client.LRange(ctx, \"lmove2\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"san\"}))\n\t\t})\n\n\t\tIt(\"should BLMove\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\trPush := client.RPush(ctx, \"blmove1\", \"ichi\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(1)))\n\n\t\t\trPush = client.RPush(ctx, \"blmove1\", \"ni\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(2)))\n\n\t\t\trPush = client.RPush(ctx, \"blmove1\", \"san\")\n\t\t\tExpect(rPush.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(rPush.Val()).To(Equal(int64(3)))\n\n\t\t\tblMove := client.BLMove(ctx, \"blmove1\", \"blmove2\", \"RIGHT\", \"LEFT\", time.Second)\n\t\t\tExpect(blMove.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(blMove.Val()).To(Equal(\"san\"))\n\n\t\t\tlRange := client.LRange(ctx, \"blmove2\", 0, -1)\n\t\t\tExpect(lRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(lRange.Val()).To(Equal([]string{\"san\"}))\n\t\t})\n\t})\n\n\tDescribe(\"sets\", func() {\n\t\tIt(\"should SAdd\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"Hello\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sAdd.Val()).To(Equal(int64(1)))\n\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"World\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sAdd.Val()).To(Equal(int64(1)))\n\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"World\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sAdd.Val()).To(Equal(int64(0)))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(ConsistOf([]string{\"Hello\", \"World\"}))\n\t\t})\n\n\t\tIt(\"should SAdd strings\", func() {\n\t\t\tset := []string{\"Hello\", \"World\", \"World\"}\n\t\t\tsAdd := client.SAdd(ctx, \"set\", set)\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sAdd.Val()).To(Equal(int64(2)))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(ConsistOf([]string{\"Hello\", \"World\"}))\n\t\t})\n\n\t\tIt(\"should SCard\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"Hello\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sAdd.Val()).To(Equal(int64(1)))\n\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"World\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sAdd.Val()).To(Equal(int64(1)))\n\n\t\t\tsCard := client.SCard(ctx, \"set\")\n\t\t\tExpect(sCard.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sCard.Val()).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should SDiff\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"a\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"d\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"e\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsDiff := client.SDiff(ctx, \"set1\", \"set2\")\n\t\t\tExpect(sDiff.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sDiff.Val()).To(ConsistOf([]string{\"a\", \"b\"}))\n\t\t})\n\n\t\tIt(\"should SDiffStore\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"a\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"d\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"e\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsDiffStore := client.SDiffStore(ctx, \"set\", \"set1\", \"set2\")\n\t\t\tExpect(sDiffStore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sDiffStore.Val()).To(Equal(int64(2)))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(ConsistOf([]string{\"a\", \"b\"}))\n\t\t})\n\n\t\tIt(\"should SInter\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"a\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"d\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"e\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsInter := client.SInter(ctx, \"set1\", \"set2\")\n\t\t\tExpect(sInter.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInter.Val()).To(Equal([]string{\"c\"}))\n\t\t})\n\n\t\tIt(\"should SInterCard\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"a\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"d\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"e\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\t// limit 0 means no limit,see https://redis.io/commands/sintercard/ for more details\n\t\t\tsInterCard := client.SInterCard(ctx, 0, \"set1\", \"set2\")\n\t\t\tExpect(sInterCard.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInterCard.Val()).To(Equal(int64(2)))\n\n\t\t\tsInterCard = client.SInterCard(ctx, 1, \"set1\", \"set2\")\n\t\t\tExpect(sInterCard.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInterCard.Val()).To(Equal(int64(1)))\n\n\t\t\tsInterCard = client.SInterCard(ctx, 3, \"set1\", \"set2\")\n\t\t\tExpect(sInterCard.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInterCard.Val()).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should SInterStore\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"a\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"d\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"e\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsInterStore := client.SInterStore(ctx, \"set\", \"set1\", \"set2\")\n\t\t\tExpect(sInterStore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInterStore.Val()).To(Equal(int64(1)))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(Equal([]string{\"c\"}))\n\t\t})\n\n\t\tIt(\"should IsMember\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"one\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsIsMember := client.SIsMember(ctx, \"set\", \"one\")\n\t\t\tExpect(sIsMember.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sIsMember.Val()).To(Equal(true))\n\n\t\t\tsIsMember = client.SIsMember(ctx, \"set\", \"two\")\n\t\t\tExpect(sIsMember.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sIsMember.Val()).To(Equal(false))\n\t\t})\n\n\t\tIt(\"should SMIsMember\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"one\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsMIsMember := client.SMIsMember(ctx, \"set\", \"one\", \"two\")\n\t\t\tExpect(sMIsMember.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMIsMember.Val()).To(Equal([]bool{true, false}))\n\t\t})\n\n\t\tIt(\"should SMembers\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"Hello\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"World\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(ConsistOf([]string{\"Hello\", \"World\"}))\n\t\t})\n\n\t\tIt(\"should SMembersMap\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"Hello\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"World\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsMembersMap := client.SMembersMap(ctx, \"set\")\n\t\t\tExpect(sMembersMap.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembersMap.Val()).To(Equal(map[string]struct{}{\"Hello\": {}, \"World\": {}}))\n\t\t})\n\n\t\tIt(\"should SMove\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"one\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"two\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"three\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsMove := client.SMove(ctx, \"set1\", \"set2\", \"two\")\n\t\t\tExpect(sMove.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMove.Val()).To(Equal(true))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set1\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(Equal([]string{\"one\"}))\n\n\t\t\tsMembers = client.SMembers(ctx, \"set2\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(ConsistOf([]string{\"three\", \"two\"}))\n\t\t})\n\n\t\tIt(\"should SPop\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"one\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"two\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"three\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsPop := client.SPop(ctx, \"set\")\n\t\t\tExpect(sPop.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sPop.Val()).NotTo(Equal(\"\"))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(HaveLen(2))\n\t\t})\n\n\t\tIt(\"should SPopN\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"one\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"two\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"three\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"four\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsPopN := client.SPopN(ctx, \"set\", 1)\n\t\t\tExpect(sPopN.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sPopN.Val()).NotTo(Equal([]string{\"\"}))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(HaveLen(3))\n\n\t\t\tsPopN = client.SPopN(ctx, \"set\", 4)\n\t\t\tExpect(sPopN.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sPopN.Val()).To(HaveLen(3))\n\n\t\t\tsMembers = client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(HaveLen(0))\n\t\t})\n\n\t\tIt(\"should SRandMember and SRandMemberN\", func() {\n\t\t\terr := client.SAdd(ctx, \"set\", \"one\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.SAdd(ctx, \"set\", \"two\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.SAdd(ctx, \"set\", \"three\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmembers, err := client.SMembers(ctx, \"set\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(HaveLen(3))\n\n\t\t\tmember, err := client.SRandMember(ctx, \"set\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(member).NotTo(Equal(\"\"))\n\n\t\t\tmembers, err = client.SRandMemberN(ctx, \"set\", 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(HaveLen(2))\n\t\t})\n\n\t\tIt(\"should SRem\", func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set\", \"one\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"two\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set\", \"three\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsRem := client.SRem(ctx, \"set\", \"one\")\n\t\t\tExpect(sRem.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sRem.Val()).To(Equal(int64(1)))\n\n\t\t\tsRem = client.SRem(ctx, \"set\", \"four\")\n\t\t\tExpect(sRem.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sRem.Val()).To(Equal(int64(0)))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(ConsistOf([]string{\"three\", \"two\"}))\n\t\t})\n\n\t\tIt(\"should SUnion\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"a\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"d\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"e\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsUnion := client.SUnion(ctx, \"set1\", \"set2\")\n\t\t\tExpect(sUnion.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sUnion.Val()).To(HaveLen(5))\n\t\t})\n\n\t\tIt(\"should SUnionStore\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tsAdd := client.SAdd(ctx, \"set1\", \"a\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"b\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set1\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"c\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"d\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\t\t\tsAdd = client.SAdd(ctx, \"set2\", \"e\")\n\t\t\tExpect(sAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tsUnionStore := client.SUnionStore(ctx, \"set\", \"set1\", \"set2\")\n\t\t\tExpect(sUnionStore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sUnionStore.Val()).To(Equal(int64(5)))\n\n\t\t\tsMembers := client.SMembers(ctx, \"set\")\n\t\t\tExpect(sMembers.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sMembers.Val()).To(HaveLen(5))\n\t\t})\n\t})\n\n\tDescribe(\"sorted sets\", func() {\n\t\tIt(\"should BZPopMax\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmember, err := client.BZPopMax(ctx, 0, \"zset1\", \"zset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(member).To(Equal(&redis.ZWithKey{\n\t\t\t\tZ: redis.Z{\n\t\t\t\t\tScore:  3,\n\t\t\t\t\tMember: \"three\",\n\t\t\t\t},\n\t\t\t\tKey: \"zset1\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should BZPopMax blocks\", func() {\n\t\t\tstarted := make(chan bool)\n\t\t\tdone := make(chan bool)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tstarted <- true\n\t\t\t\tbZPopMax := client.BZPopMax(ctx, 0, \"zset\")\n\t\t\t\tExpect(bZPopMax.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(bZPopMax.Val()).To(Equal(&redis.ZWithKey{\n\t\t\t\t\tZ: redis.Z{\n\t\t\t\t\t\tMember: \"a\",\n\t\t\t\t\t\tScore:  1,\n\t\t\t\t\t},\n\t\t\t\t\tKey: \"zset\",\n\t\t\t\t}))\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\t<-started\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tFail(\"BZPopMax is not blocked\")\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\t// ok\n\t\t\t}\n\n\t\t\tzAdd := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tMember: \"a\",\n\t\t\t\tScore:  1,\n\t\t\t})\n\t\t\tExpect(zAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// ok\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tFail(\"BZPopMax is still blocked\")\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should BZPopMax timeout\", func() {\n\t\t\tval, err := client.BZPopMax(ctx, time.Second, \"zset1\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(BeNil())\n\n\t\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\n\t\t\tstats := client.PoolStats()\n\t\t\tExpect(stats.Hits).To(Equal(uint32(2)))\n\t\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t\t})\n\n\t\tIt(\"should BZPopMin\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmember, err := client.BZPopMin(ctx, 0, \"zset1\", \"zset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(member).To(Equal(&redis.ZWithKey{\n\t\t\t\tZ: redis.Z{\n\t\t\t\t\tScore:  1,\n\t\t\t\t\tMember: \"one\",\n\t\t\t\t},\n\t\t\t\tKey: \"zset1\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should BZPopMin blocks\", func() {\n\t\t\tstarted := make(chan bool)\n\t\t\tdone := make(chan bool)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tstarted <- true\n\t\t\t\tbZPopMin := client.BZPopMin(ctx, 0, \"zset\")\n\t\t\t\tExpect(bZPopMin.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(bZPopMin.Val()).To(Equal(&redis.ZWithKey{\n\t\t\t\t\tZ: redis.Z{\n\t\t\t\t\t\tMember: \"a\",\n\t\t\t\t\t\tScore:  1,\n\t\t\t\t\t},\n\t\t\t\t\tKey: \"zset\",\n\t\t\t\t}))\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\t<-started\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tFail(\"BZPopMin is not blocked\")\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\t// ok\n\t\t\t}\n\n\t\t\tzAdd := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tMember: \"a\",\n\t\t\t\tScore:  1,\n\t\t\t})\n\t\t\tExpect(zAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// ok\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tFail(\"BZPopMin is still blocked\")\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should BZPopMin timeout\", func() {\n\t\t\tval, err := client.BZPopMin(ctx, time.Second, \"zset1\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(BeNil())\n\n\t\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\n\t\t\tstats := client.PoolStats()\n\t\t\tExpect(stats.Hits).To(Equal(uint32(2)))\n\t\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t\t})\n\n\t\tIt(\"should ZAdd\", func() {\n\t\t\tadded, err := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tadded, err = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"uno\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tadded, err = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tadded, err = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"uno\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZAdd bytes\", func() {\n\t\t\tadded, err := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: []byte(\"one\"),\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tadded, err = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: []byte(\"uno\"),\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tadded, err = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: []byte(\"two\"),\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tadded, err = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: []byte(\"two\"),\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"uno\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsGTAndLT\", func() {\n\t\t\t// Test only the GT+LT options.\n\t\t\tadded, err := client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tGT:      true,\n\t\t\t\tMembers: []redis.Z{{Score: 1, Member: \"one\"}},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\n\t\t\tadded, err = client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tGT:      true,\n\t\t\t\tMembers: []redis.Z{{Score: 2, Member: \"one\"}},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\n\t\t\tadded, err = client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tLT:      true,\n\t\t\t\tMembers: []redis.Z{{Score: 1, Member: \"one\"}},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsLT\", func() {\n\t\t\tadded, err := client.ZAddLT(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\n\t\t\tadded, err = client.ZAddLT(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\n\t\t\tadded, err = client.ZAddLT(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsGT\", func() {\n\t\t\tadded, err := client.ZAddGT(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\n\t\t\tadded, err = client.ZAddGT(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 3, Member: \"one\"}}))\n\n\t\t\tadded, err = client.ZAddGT(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 3, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsNX\", func() {\n\t\t\tadded, err := client.ZAddNX(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\n\t\t\tadded, err = client.ZAddNX(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsXX\", func() {\n\t\t\tadded, err := client.ZAddXX(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(BeEmpty())\n\n\t\t\tadded, err = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tadded, err = client.ZAddXX(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsCh\", func() {\n\t\t\tchanged, err := client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tCh: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(changed).To(Equal(int64(1)))\n\n\t\t\tchanged, err = client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tCh: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(changed).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should ZAddArgsNXCh\", func() {\n\t\t\tchanged, err := client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tNX: true,\n\t\t\t\tCh: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(changed).To(Equal(int64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\n\t\t\tchanged, err = client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tNX: true,\n\t\t\t\tCh: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 2, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(changed).To(Equal(int64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsXXCh\", func() {\n\t\t\tchanged, err := client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tXX: true,\n\t\t\t\tCh: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(changed).To(Equal(int64(0)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(BeEmpty())\n\n\t\t\tadded, err := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tchanged, err = client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tXX: true,\n\t\t\t\tCh: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 2, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(changed).To(Equal(int64(1)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsIncr\", func() {\n\t\t\tscore, err := client.ZAddArgsIncr(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(score).To(Equal(float64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\n\t\t\tscore, err = client.ZAddArgsIncr(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(score).To(Equal(float64(2)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsIncrNX\", func() {\n\t\t\tscore, err := client.ZAddArgsIncr(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tNX: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(score).To(Equal(float64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\n\t\t\tscore, err = client.ZAddArgsIncr(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tNX: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(score).To(Equal(float64(0)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZAddArgsIncrXX\", func() {\n\t\t\tscore, err := client.ZAddArgsIncr(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tXX: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(score).To(Equal(float64(0)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(BeEmpty())\n\n\t\t\tadded, err := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(1)))\n\n\t\t\tscore, err = client.ZAddArgsIncr(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tXX: true,\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(score).To(Equal(float64(2)))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"one\"}}))\n\t\t})\n\n\t\tIt(\"should ZCard\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tcard, err := client.ZCard(ctx, \"zset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(card).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should ZCount\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tcount, err := client.ZCount(ctx, \"zset\", \"-inf\", \"+inf\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(int64(3)))\n\n\t\t\tcount, err = client.ZCount(ctx, \"zset\", \"(1\", \"3\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(int64(2)))\n\n\t\t\tcount, err = client.ZLexCount(ctx, \"zset\", \"-\", \"+\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(count).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should ZIncrBy\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tn, err := client.ZIncrBy(ctx, \"zset\", 2, \"one\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(float64(3)))\n\n\t\t\tval, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]redis.Z{{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZInterStore\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset3\", redis.Z{Score: 3, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tn, err := client.ZInterStore(ctx, \"out\", &redis.ZStore{\n\t\t\t\tKeys:    []string{\"zset1\", \"zset2\"},\n\t\t\t\tWeights: []float64{2, 3},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"out\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  5,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  10,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZMPop\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tkey, elems, err := client.ZMPop(ctx, \"min\", 1, \"zset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"zset\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\n\t\t\t_, _, err = client.ZMPop(ctx, \"min\", 1, \"nosuchkey\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\n\t\t\terr = client.ZAdd(ctx, \"myzset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"myzset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"myzset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tkey, elems, err = client.ZMPop(ctx, \"min\", 1, \"myzset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"myzset\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\n\t\t\tkey, elems, err = client.ZMPop(ctx, \"max\", 10, \"myzset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"myzset\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\n\t\t\terr = client.ZAdd(ctx, \"myzset2\", redis.Z{Score: 4, Member: \"four\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"myzset2\", redis.Z{Score: 5, Member: \"five\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"myzset2\", redis.Z{Score: 6, Member: \"six\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tkey, elems, err = client.ZMPop(ctx, \"min\", 10, \"myzset\", \"myzset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"myzset2\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  4,\n\t\t\t\tMember: \"four\",\n\t\t\t}, {\n\t\t\t\tScore:  5,\n\t\t\t\tMember: \"five\",\n\t\t\t}, {\n\t\t\t\tScore:  6,\n\t\t\t\tMember: \"six\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should BZMPop\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tkey, elems, err := client.BZMPop(ctx, 0, \"min\", 1, \"zset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"zset\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\t\t\tkey, elems, err = client.BZMPop(ctx, 0, \"max\", 1, \"zset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"zset\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\t\t\tkey, elems, err = client.BZMPop(ctx, 0, \"min\", 10, \"zset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"zset\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\n\t\t\tkey, elems, err = client.BZMPop(ctx, 0, \"max\", 10, \"zset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"zset2\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\n\t\t\terr = client.ZAdd(ctx, \"myzset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tkey, elems, err = client.BZMPop(ctx, 0, \"min\", 10, \"myzset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"myzset\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\n\t\t\terr = client.ZAdd(ctx, \"myzset2\", redis.Z{Score: 4, Member: \"four\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"myzset2\", redis.Z{Score: 5, Member: \"five\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tkey, elems, err = client.BZMPop(ctx, 0, \"min\", 10, \"myzset\", \"myzset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(key).To(Equal(\"myzset2\"))\n\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\tScore:  4,\n\t\t\t\tMember: \"four\",\n\t\t\t}, {\n\t\t\t\tScore:  5,\n\t\t\t\tMember: \"five\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should BZMPopBlocks\", func() {\n\t\t\tstarted := make(chan bool)\n\t\t\tdone := make(chan bool)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tstarted <- true\n\t\t\t\tkey, elems, err := client.BZMPop(ctx, 0, \"min\", 1, \"list_list\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(key).To(Equal(\"list_list\"))\n\t\t\t\tExpect(elems).To(Equal([]redis.Z{{\n\t\t\t\t\tScore:  1,\n\t\t\t\t\tMember: \"one\",\n\t\t\t\t}}))\n\t\t\t\tdone <- true\n\t\t\t}()\n\t\t\t<-started\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\tFail(\"BZMPop is not blocked\")\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\t// ok\n\t\t\t}\n\n\t\t\terr := client.ZAdd(ctx, \"list_list\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\t// ok\n\t\t\tcase <-time.After(time.Second):\n\t\t\t\tFail(\"BZMPop is still blocked\")\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should BZMPop timeout\", func() {\n\t\t\t_, val, err := client.BZMPop(ctx, time.Second, \"min\", 1, \"list1\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\tExpect(val).To(BeNil())\n\n\t\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\n\t\t\tstats := client.PoolStats()\n\t\t\tExpect(stats.Hits).To(Equal(uint32(2)))\n\t\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t\t})\n\n\t\tIt(\"should ZMScore\", func() {\n\t\t\tzmScore := client.ZMScore(ctx, \"zset\", \"one\", \"three\")\n\t\t\tExpect(zmScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zmScore.Val()).To(HaveLen(2))\n\t\t\tExpect(zmScore.Val()[0]).To(Equal(float64(0)))\n\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzmScore = client.ZMScore(ctx, \"zset\", \"one\", \"three\")\n\t\t\tExpect(zmScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zmScore.Val()).To(HaveLen(2))\n\t\t\tExpect(zmScore.Val()[0]).To(Equal(float64(1)))\n\n\t\t\tzmScore = client.ZMScore(ctx, \"zset\", \"four\")\n\t\t\tExpect(zmScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zmScore.Val()).To(HaveLen(1))\n\n\t\t\tzmScore = client.ZMScore(ctx, \"zset\", \"four\", \"one\")\n\t\t\tExpect(zmScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zmScore.Val()).To(HaveLen(2))\n\t\t})\n\n\t\tIt(\"should ZPopMax\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmembers, err := client.ZPopMax(ctx, \"zset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\n\t\t\t// adding back 3\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tmembers, err = client.ZPopMax(ctx, \"zset\", 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\n\t\t\t// adding back 2 & 3\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tmembers, err = client.ZPopMax(ctx, \"zset\", 10).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZPopMin\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmembers, err := client.ZPopMin(ctx, \"zset\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\n\t\t\t// adding back 1\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tmembers, err = client.ZPopMin(ctx, \"zset\", 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\n\t\t\t// adding back 1 & 2\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tmembers, err = client.ZPopMin(ctx, \"zset\", 10).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(members).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRange\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRange := client.ZRange(ctx, \"zset\", 0, -1)\n\t\t\tExpect(zRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRange.Val()).To(Equal([]string{\"one\", \"two\", \"three\"}))\n\n\t\t\tzRange = client.ZRange(ctx, \"zset\", 2, 3)\n\t\t\tExpect(zRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRange.Val()).To(Equal([]string{\"three\"}))\n\n\t\t\tzRange = client.ZRange(ctx, \"zset\", -2, -1)\n\t\t\tExpect(zRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRange.Val()).To(Equal([]string{\"two\", \"three\"}))\n\t\t})\n\n\t\tIt(\"should ZRangeWithScores\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", 2, 3).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 3, Member: \"three\"}}))\n\n\t\t\tvals, err = client.ZRangeWithScores(ctx, \"zset\", -2, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRangeArgs\", func() {\n\t\t\tadded, err := client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t\t{Score: 2, Member: \"two\"},\n\t\t\t\t\t{Score: 3, Member: \"three\"},\n\t\t\t\t\t{Score: 4, Member: \"four\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(4)))\n\n\t\t\tzRange, err := client.ZRangeArgs(ctx, redis.ZRangeArgs{\n\t\t\t\tKey:     \"zset\",\n\t\t\t\tStart:   1,\n\t\t\t\tStop:    4,\n\t\t\t\tByScore: true,\n\t\t\t\tRev:     true,\n\t\t\t\tOffset:  1,\n\t\t\t\tCount:   2,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(zRange).To(Equal([]string{\"three\", \"two\"}))\n\n\t\t\tzRange, err = client.ZRangeArgs(ctx, redis.ZRangeArgs{\n\t\t\t\tKey:    \"zset\",\n\t\t\t\tStart:  \"-\",\n\t\t\t\tStop:   \"+\",\n\t\t\t\tByLex:  true,\n\t\t\t\tRev:    true,\n\t\t\t\tOffset: 2,\n\t\t\t\tCount:  2,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(zRange).To(Equal([]string{\"two\", \"one\"}))\n\n\t\t\tzRange, err = client.ZRangeArgs(ctx, redis.ZRangeArgs{\n\t\t\t\tKey:     \"zset\",\n\t\t\t\tStart:   \"(1\",\n\t\t\t\tStop:    \"(4\",\n\t\t\t\tByScore: true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(zRange).To(Equal([]string{\"two\", \"three\"}))\n\n\t\t\t// withScores.\n\t\t\tzSlice, err := client.ZRangeArgsWithScores(ctx, redis.ZRangeArgs{\n\t\t\t\tKey:     \"zset\",\n\t\t\t\tStart:   1,\n\t\t\t\tStop:    4,\n\t\t\t\tByScore: true,\n\t\t\t\tRev:     true,\n\t\t\t\tOffset:  1,\n\t\t\t\tCount:   2,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(zSlice).To(Equal([]redis.Z{\n\t\t\t\t{Score: 3, Member: \"three\"},\n\t\t\t\t{Score: 2, Member: \"two\"},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should ZRangeByScore\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRangeByScore := client.ZRangeByScore(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"-inf\",\n\t\t\t\tMax: \"+inf\",\n\t\t\t})\n\t\t\tExpect(zRangeByScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByScore.Val()).To(Equal([]string{\"one\", \"two\", \"three\"}))\n\n\t\t\tzRangeByScore = client.ZRangeByScore(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"1\",\n\t\t\t\tMax: \"2\",\n\t\t\t})\n\t\t\tExpect(zRangeByScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByScore.Val()).To(Equal([]string{\"one\", \"two\"}))\n\n\t\t\tzRangeByScore = client.ZRangeByScore(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"(1\",\n\t\t\t\tMax: \"2\",\n\t\t\t})\n\t\t\tExpect(zRangeByScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByScore.Val()).To(Equal([]string{\"two\"}))\n\n\t\t\tzRangeByScore = client.ZRangeByScore(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"(1\",\n\t\t\t\tMax: \"(2\",\n\t\t\t})\n\t\t\tExpect(zRangeByScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByScore.Val()).To(Equal([]string{}))\n\t\t})\n\n\t\tIt(\"should ZRangeByLex\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  0,\n\t\t\t\tMember: \"a\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  0,\n\t\t\t\tMember: \"b\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{\n\t\t\t\tScore:  0,\n\t\t\t\tMember: \"c\",\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRangeByLex := client.ZRangeByLex(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"-\",\n\t\t\t\tMax: \"+\",\n\t\t\t})\n\t\t\tExpect(zRangeByLex.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByLex.Val()).To(Equal([]string{\"a\", \"b\", \"c\"}))\n\n\t\t\tzRangeByLex = client.ZRangeByLex(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"[a\",\n\t\t\t\tMax: \"[b\",\n\t\t\t})\n\t\t\tExpect(zRangeByLex.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByLex.Val()).To(Equal([]string{\"a\", \"b\"}))\n\n\t\t\tzRangeByLex = client.ZRangeByLex(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"(a\",\n\t\t\t\tMax: \"[b\",\n\t\t\t})\n\t\t\tExpect(zRangeByLex.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByLex.Val()).To(Equal([]string{\"b\"}))\n\n\t\t\tzRangeByLex = client.ZRangeByLex(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"(a\",\n\t\t\t\tMax: \"(b\",\n\t\t\t})\n\t\t\tExpect(zRangeByLex.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRangeByLex.Val()).To(Equal([]string{}))\n\t\t})\n\n\t\tIt(\"should ZRangeByScoreWithScoresMap\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.ZRangeByScoreWithScores(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"-inf\",\n\t\t\t\tMax: \"+inf\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\n\t\t\tvals, err = client.ZRangeByScoreWithScores(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"1\",\n\t\t\t\tMax: \"2\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\n\t\t\tvals, err = client.ZRangeByScoreWithScores(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"(1\",\n\t\t\t\tMax: \"2\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"two\"}}))\n\n\t\t\tvals, err = client.ZRangeByScoreWithScores(ctx, \"zset\", &redis.ZRangeBy{\n\t\t\t\tMin: \"(1\",\n\t\t\t\tMax: \"(2\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{}))\n\t\t})\n\n\t\tIt(\"should ZRangeStore\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tadded, err := client.ZAddArgs(ctx, \"zset\", redis.ZAddArgs{\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t\t{Score: 2, Member: \"two\"},\n\t\t\t\t\t{Score: 3, Member: \"three\"},\n\t\t\t\t\t{Score: 4, Member: \"four\"},\n\t\t\t\t},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(added).To(Equal(int64(4)))\n\n\t\t\trangeStore, err := client.ZRangeStore(ctx, \"new-zset\", redis.ZRangeArgs{\n\t\t\t\tKey:     \"zset\",\n\t\t\t\tStart:   1,\n\t\t\t\tStop:    4,\n\t\t\t\tByScore: true,\n\t\t\t\tRev:     true,\n\t\t\t\tOffset:  1,\n\t\t\t\tCount:   2,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(rangeStore).To(Equal(int64(2)))\n\n\t\t\tzRange, err := client.ZRange(ctx, \"new-zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(zRange).To(Equal([]string{\"two\", \"three\"}))\n\t\t})\n\n\t\tIt(\"should ZRank\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRank := client.ZRank(ctx, \"zset\", \"three\")\n\t\t\tExpect(zRank.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRank.Val()).To(Equal(int64(2)))\n\n\t\t\tzRank = client.ZRank(ctx, \"zset\", \"four\")\n\t\t\tExpect(zRank.Err()).To(Equal(redis.Nil))\n\t\t\tExpect(zRank.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should ZRankWithScore\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRankWithScore := client.ZRankWithScore(ctx, \"zset\", \"one\")\n\t\t\tExpect(zRankWithScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRankWithScore.Result()).To(Equal(redis.RankScore{Rank: 0, Score: 1}))\n\n\t\t\tzRankWithScore = client.ZRankWithScore(ctx, \"zset\", \"two\")\n\t\t\tExpect(zRankWithScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRankWithScore.Result()).To(Equal(redis.RankScore{Rank: 1, Score: 2}))\n\n\t\t\tzRankWithScore = client.ZRankWithScore(ctx, \"zset\", \"three\")\n\t\t\tExpect(zRankWithScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRankWithScore.Result()).To(Equal(redis.RankScore{Rank: 2, Score: 3}))\n\n\t\t\tzRankWithScore = client.ZRankWithScore(ctx, \"zset\", \"four\")\n\t\t\tExpect(zRankWithScore.Err()).To(HaveOccurred())\n\t\t\tExpect(zRankWithScore.Err()).To(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should ZRem\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRem := client.ZRem(ctx, \"zset\", \"two\")\n\t\t\tExpect(zRem.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRem.Val()).To(Equal(int64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRemRangeByRank\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRemRangeByRank := client.ZRemRangeByRank(ctx, \"zset\", 0, 1)\n\t\t\tExpect(zRemRangeByRank.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRemRangeByRank.Val()).To(Equal(int64(2)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRemRangeByScore\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRemRangeByScore := client.ZRemRangeByScore(ctx, \"zset\", \"-inf\", \"(2\")\n\t\t\tExpect(zRemRangeByScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRemRangeByScore.Val()).To(Equal(int64(1)))\n\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRemRangeByLex\", func() {\n\t\t\tzz := []redis.Z{\n\t\t\t\t{Score: 0, Member: \"aaaa\"},\n\t\t\t\t{Score: 0, Member: \"b\"},\n\t\t\t\t{Score: 0, Member: \"c\"},\n\t\t\t\t{Score: 0, Member: \"d\"},\n\t\t\t\t{Score: 0, Member: \"e\"},\n\t\t\t\t{Score: 0, Member: \"foo\"},\n\t\t\t\t{Score: 0, Member: \"zap\"},\n\t\t\t\t{Score: 0, Member: \"zip\"},\n\t\t\t\t{Score: 0, Member: \"ALPHA\"},\n\t\t\t\t{Score: 0, Member: \"alpha\"},\n\t\t\t}\n\t\t\tfor _, z := range zz {\n\t\t\t\terr := client.ZAdd(ctx, \"zset\", z).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tn, err := client.ZRemRangeByLex(ctx, \"zset\", \"[alpha\", \"[omega\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(6)))\n\n\t\t\tvals, err := client.ZRange(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]string{\"ALPHA\", \"aaaa\", \"zap\", \"zip\"}))\n\t\t})\n\n\t\tIt(\"should ZRevRange\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRevRange := client.ZRevRange(ctx, \"zset\", 0, -1)\n\t\t\tExpect(zRevRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRevRange.Val()).To(Equal([]string{\"three\", \"two\", \"one\"}))\n\n\t\t\tzRevRange = client.ZRevRange(ctx, \"zset\", 2, 3)\n\t\t\tExpect(zRevRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRevRange.Val()).To(Equal([]string{\"one\"}))\n\n\t\t\tzRevRange = client.ZRevRange(ctx, \"zset\", -2, -1)\n\t\t\tExpect(zRevRange.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRevRange.Val()).To(Equal([]string{\"two\", \"one\"}))\n\t\t})\n\n\t\tIt(\"should ZRevRangeWithScoresMap\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.ZRevRangeWithScores(ctx, \"zset\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\n\t\t\tval, err = client.ZRevRangeWithScores(ctx, \"zset\", 2, 3).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]redis.Z{{Score: 1, Member: \"one\"}}))\n\n\t\t\tval, err = client.ZRevRangeWithScores(ctx, \"zset\", -2, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]redis.Z{{\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRevRangeByScore\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.ZRevRangeByScore(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"+inf\", Min: \"-inf\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]string{\"three\", \"two\", \"one\"}))\n\n\t\t\tvals, err = client.ZRevRangeByScore(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"2\", Min: \"(1\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]string{\"two\"}))\n\n\t\t\tvals, err = client.ZRevRangeByScore(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"(2\", Min: \"(1\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]string{}))\n\t\t})\n\n\t\tIt(\"should ZRevRangeByLex\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 0, Member: \"a\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 0, Member: \"b\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 0, Member: \"c\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.ZRevRangeByLex(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"+\", Min: \"-\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]string{\"c\", \"b\", \"a\"}))\n\n\t\t\tvals, err = client.ZRevRangeByLex(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"[b\", Min: \"(a\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]string{\"b\"}))\n\n\t\t\tvals, err = client.ZRevRangeByLex(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"(b\", Min: \"(a\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]string{}))\n\t\t})\n\n\t\tIt(\"should ZRevRangeByScoreWithScores\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.ZRevRangeByScoreWithScores(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"+inf\", Min: \"-inf\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRevRangeByScoreWithScoresMap\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.ZRevRangeByScoreWithScores(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"+inf\", Min: \"-inf\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  2,\n\t\t\t\tMember: \"two\",\n\t\t\t}, {\n\t\t\t\tScore:  1,\n\t\t\t\tMember: \"one\",\n\t\t\t}}))\n\n\t\t\tvals, err = client.ZRevRangeByScoreWithScores(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"2\", Min: \"(1\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{Score: 2, Member: \"two\"}}))\n\n\t\t\tvals, err = client.ZRevRangeByScoreWithScores(\n\t\t\t\tctx, \"zset\", &redis.ZRangeBy{Max: \"(2\", Min: \"(1\"}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{}))\n\t\t})\n\n\t\tIt(\"should ZRevRank\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRevRank := client.ZRevRank(ctx, \"zset\", \"one\")\n\t\t\tExpect(zRevRank.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRevRank.Val()).To(Equal(int64(2)))\n\n\t\t\tzRevRank = client.ZRevRank(ctx, \"zset\", \"four\")\n\t\t\tExpect(zRevRank.Err()).To(Equal(redis.Nil))\n\t\t\tExpect(zRevRank.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should ZRevRankWithScore\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tzRevRankWithScore := client.ZRevRankWithScore(ctx, \"zset\", \"one\")\n\t\t\tExpect(zRevRankWithScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRevRankWithScore.Result()).To(Equal(redis.RankScore{Rank: 2, Score: 1}))\n\n\t\t\tzRevRankWithScore = client.ZRevRankWithScore(ctx, \"zset\", \"two\")\n\t\t\tExpect(zRevRankWithScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRevRankWithScore.Result()).To(Equal(redis.RankScore{Rank: 1, Score: 2}))\n\n\t\t\tzRevRankWithScore = client.ZRevRankWithScore(ctx, \"zset\", \"three\")\n\t\t\tExpect(zRevRankWithScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zRevRankWithScore.Result()).To(Equal(redis.RankScore{Rank: 0, Score: 3}))\n\n\t\t\tzRevRankWithScore = client.ZRevRankWithScore(ctx, \"zset\", \"four\")\n\t\t\tExpect(zRevRankWithScore.Err()).To(HaveOccurred())\n\t\t\tExpect(zRevRankWithScore.Err()).To(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should ZScore\", func() {\n\t\t\tzAdd := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1.001, Member: \"one\"})\n\t\t\tExpect(zAdd.Err()).NotTo(HaveOccurred())\n\n\t\t\tzScore := client.ZScore(ctx, \"zset\", \"one\")\n\t\t\tExpect(zScore.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(zScore.Val()).To(Equal(1.001))\n\t\t})\n\n\t\tIt(\"should ZUnion\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAddArgs(ctx, \"zset1\", redis.ZAddArgs{\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t\t{Score: 2, Member: \"two\"},\n\t\t\t\t},\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ZAddArgs(ctx, \"zset2\", redis.ZAddArgs{\n\t\t\t\tMembers: []redis.Z{\n\t\t\t\t\t{Score: 1, Member: \"one\"},\n\t\t\t\t\t{Score: 2, Member: \"two\"},\n\t\t\t\t\t{Score: 3, Member: \"three\"},\n\t\t\t\t},\n\t\t\t}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tunion, err := client.ZUnion(ctx, redis.ZStore{\n\t\t\t\tKeys:      []string{\"zset1\", \"zset2\"},\n\t\t\t\tWeights:   []float64{2, 3},\n\t\t\t\tAggregate: \"sum\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(union).To(Equal([]string{\"one\", \"three\", \"two\"}))\n\n\t\t\tunionScores, err := client.ZUnionWithScores(ctx, redis.ZStore{\n\t\t\t\tKeys:      []string{\"zset1\", \"zset2\"},\n\t\t\t\tWeights:   []float64{2, 3},\n\t\t\t\tAggregate: \"sum\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(unionScores).To(Equal([]redis.Z{\n\t\t\t\t{Score: 5, Member: \"one\"},\n\t\t\t\t{Score: 9, Member: \"three\"},\n\t\t\t\t{Score: 10, Member: \"two\"},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should ZUnionStore\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tn, err := client.ZUnionStore(ctx, \"out\", &redis.ZStore{\n\t\t\t\tKeys:    []string{\"zset1\", \"zset2\"},\n\t\t\t\tWeights: []float64{2, 3},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(3)))\n\n\t\t\tval, err := client.ZRangeWithScores(ctx, \"out\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]redis.Z{{\n\t\t\t\tScore:  5,\n\t\t\t\tMember: \"one\",\n\t\t\t}, {\n\t\t\t\tScore:  9,\n\t\t\t\tMember: \"three\",\n\t\t\t}, {\n\t\t\t\tScore:  10,\n\t\t\t\tMember: \"two\",\n\t\t\t}}))\n\t\t})\n\n\t\tIt(\"should ZRandMember\", func() {\n\t\t\terr := client.ZAdd(ctx, \"zset\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv := client.ZRandMember(ctx, \"zset\", 1)\n\t\t\tExpect(v.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(v.Val()).To(Or(Equal([]string{\"one\"}), Equal([]string{\"two\"})))\n\n\t\t\tv = client.ZRandMember(ctx, \"zset\", 0)\n\t\t\tExpect(v.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(v.Val()).To(HaveLen(0))\n\n\t\t\tkv, err := client.ZRandMemberWithScores(ctx, \"zset\", 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(kv).To(Or(\n\t\t\t\tEqual([]redis.Z{{Member: \"one\", Score: 1}}),\n\t\t\t\tEqual([]redis.Z{{Member: \"two\", Score: 2}}),\n\t\t\t))\n\t\t})\n\n\t\tIt(\"should ZDiff\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.ZDiff(ctx, \"zset1\", \"zset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal([]string{\"two\", \"three\"}))\n\t\t})\n\n\t\tIt(\"should ZDiffWithScores\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.ZDiffWithScores(ctx, \"zset1\", \"zset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal([]redis.Z{\n\t\t\t\t{\n\t\t\t\t\tMember: \"two\",\n\t\t\t\t\tScore:  2,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMember: \"three\",\n\t\t\t\t\tScore:  3,\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should ZInter\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.ZInter(ctx, &redis.ZStore{\n\t\t\t\tKeys: []string{\"zset1\", \"zset2\"},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal([]string{\"one\", \"two\"}))\n\t\t})\n\n\t\tIt(\"should ZInterCard\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t// limit 0 means no limit\n\t\t\tsInterCard := client.ZInterCard(ctx, 0, \"zset1\", \"zset2\")\n\t\t\tExpect(sInterCard.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInterCard.Val()).To(Equal(int64(2)))\n\n\t\t\tsInterCard = client.ZInterCard(ctx, 1, \"zset1\", \"zset2\")\n\t\t\tExpect(sInterCard.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInterCard.Val()).To(Equal(int64(1)))\n\n\t\t\tsInterCard = client.ZInterCard(ctx, 3, \"zset1\", \"zset2\")\n\t\t\tExpect(sInterCard.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(sInterCard.Val()).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should ZInterWithScores\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.ZInterWithScores(ctx, &redis.ZStore{\n\t\t\t\tKeys:      []string{\"zset1\", \"zset2\"},\n\t\t\t\tWeights:   []float64{2, 3},\n\t\t\t\tAggregate: \"Max\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal([]redis.Z{\n\t\t\t\t{\n\t\t\t\t\tMember: \"one\",\n\t\t\t\t\tScore:  3,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tMember: \"two\",\n\t\t\t\t\tScore:  6,\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should ZDiffStore\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.ZAdd(ctx, \"zset1\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset1\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 1, Member: \"one\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 2, Member: \"two\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.ZAdd(ctx, \"zset2\", redis.Z{Score: 3, Member: \"three\"}).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tv, err := client.ZDiffStore(ctx, \"out1\", \"zset1\", \"zset2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(int64(0)))\n\t\t\tv, err = client.ZDiffStore(ctx, \"out1\", \"zset2\", \"zset1\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(int64(1)))\n\t\t\tvals, err := client.ZRangeWithScores(ctx, \"out1\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.Z{{\n\t\t\t\tScore:  3,\n\t\t\t\tMember: \"three\",\n\t\t\t}}))\n\t\t})\n\t})\n\n\tDescribe(\"streams\", func() {\n\t\tBeforeEach(func() {\n\t\t\tid, err := client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\tStream: \"stream\",\n\t\t\t\tID:     \"1-0\",\n\t\t\t\tValues: map[string]interface{}{\"uno\": \"un\"},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(id).To(Equal(\"1-0\"))\n\n\t\t\t// Values supports []interface{}.\n\t\t\tid, err = client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\tStream: \"stream\",\n\t\t\t\tID:     \"2-0\",\n\t\t\t\tValues: []interface{}{\"dos\", \"deux\"},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(id).To(Equal(\"2-0\"))\n\n\t\t\t// Value supports []string.\n\t\t\tid, err = client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\tStream: \"stream\",\n\t\t\t\tID:     \"3-0\",\n\t\t\t\tValues: []string{\"tres\", \"troix\"},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(id).To(Equal(\"3-0\"))\n\t\t})\n\n\t\tIt(\"should XTrimMaxLen\", func() {\n\t\t\tn, err := client.XTrimMaxLen(ctx, \"stream\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should XTrimMaxLenApprox\", func() {\n\t\t\tn, err := client.XTrimMaxLenApprox(ctx, \"stream\", 0, 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should XTrimMinID\", func() {\n\t\t\tn, err := client.XTrimMinID(ctx, \"stream\", \"4-0\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should XTrimMinIDApprox\", func() {\n\t\t\tn, err := client.XTrimMinIDApprox(ctx, \"stream\", \"4-0\", 0).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should XAdd\", func() {\n\t\t\tid, err := client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\tStream: \"stream\",\n\t\t\t\tValues: map[string]interface{}{\"quatro\": \"quatre\"},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.XRange(ctx, \"stream\", \"-\", \"+\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t{ID: id, Values: map[string]interface{}{\"quatro\": \"quatre\"}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XAdd with MaxLen\", func() {\n\t\t\tid, err := client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\tStream: \"stream\",\n\t\t\t\tMaxLen: 1,\n\t\t\t\tValues: map[string]interface{}{\"quatro\": \"quatre\"},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvals, err := client.XRange(ctx, \"stream\", \"-\", \"+\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: id, Values: map[string]interface{}{\"quatro\": \"quatre\"}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XAdd with MinID\", func() {\n\t\t\tid, err := client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\tStream: \"stream\",\n\t\t\t\tMinID:  \"5-0\",\n\t\t\t\tID:     \"4-0\",\n\t\t\t\tValues: map[string]interface{}{\"quatro\": \"quatre\"},\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(id).To(Equal(\"4-0\"))\n\n\t\t\tvals, err := client.XRange(ctx, \"stream\", \"-\", \"+\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(HaveLen(0))\n\t\t})\n\n\t\tIt(\"should XDel\", func() {\n\t\t\tn, err := client.XDel(ctx, \"stream\", \"1-0\", \"2-0\", \"3-0\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should XLen\", func() {\n\t\t\tn, err := client.XLen(ctx, \"stream\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(3)))\n\t\t})\n\n\t\tIt(\"should XRange\", func() {\n\t\t\tmsgs, err := client.XRange(ctx, \"stream\", \"-\", \"+\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t}))\n\n\t\t\tmsgs, err = client.XRange(ctx, \"stream\", \"2\", \"+\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t}))\n\n\t\t\tmsgs, err = client.XRange(ctx, \"stream\", \"-\", \"2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XRangeN\", func() {\n\t\t\tmsgs, err := client.XRangeN(ctx, \"stream\", \"-\", \"+\", 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t}))\n\n\t\t\tmsgs, err = client.XRangeN(ctx, \"stream\", \"2\", \"+\", 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t}))\n\n\t\t\tmsgs, err = client.XRangeN(ctx, \"stream\", \"-\", \"2\", 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XRevRange\", func() {\n\t\t\tmsgs, err := client.XRevRange(ctx, \"stream\", \"+\", \"-\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t}))\n\n\t\t\tmsgs, err = client.XRevRange(ctx, \"stream\", \"+\", \"2\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XRevRangeN\", func() {\n\t\t\tmsgs, err := client.XRevRangeN(ctx, \"stream\", \"+\", \"-\", 2).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t}))\n\n\t\t\tmsgs, err = client.XRevRangeN(ctx, \"stream\", \"+\", \"2\", 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(msgs).To(Equal([]redis.XMessage{\n\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XRead\", func() {\n\t\t\tres, err := client.XReadStreams(ctx, \"stream\", \"0\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t{\n\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}))\n\n\t\t\t_, err = client.XReadStreams(ctx, \"stream\", \"3\").Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should XRead\", func() {\n\t\t\tres, err := client.XRead(ctx, &redis.XReadArgs{\n\t\t\t\tStreams: []string{\"stream\", \"0\"},\n\t\t\t\tCount:   2,\n\t\t\t\tBlock:   100 * time.Millisecond,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t{\n\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}))\n\n\t\t\t_, err = client.XRead(ctx, &redis.XReadArgs{\n\t\t\t\tStreams: []string{\"stream\", \"3\"},\n\t\t\t\tCount:   1,\n\t\t\t\tBlock:   100 * time.Millisecond,\n\t\t\t}).Result()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"should XRead LastEntry\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tres, err := client.XRead(ctx, &redis.XReadArgs{\n\t\t\t\tStreams: []string{\"stream\"},\n\t\t\t\tCount:   2, // we expect 1 message\n\t\t\t\tID:      \"+\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t{\n\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XRead LastEntry from two streams\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tres, err := client.XRead(ctx, &redis.XReadArgs{\n\t\t\t\tStreams: []string{\"stream\", \"stream\"},\n\t\t\t\tID:      \"+\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t{\n\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should XRead LastEntry blocks\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tstart := time.Now()\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tid, err := client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\t\tStream: \"empty\",\n\t\t\t\t\tID:     \"4-0\",\n\t\t\t\t\tValues: map[string]interface{}{\"quatro\": \"quatre\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(id).To(Equal(\"4-0\"))\n\t\t\t}()\n\n\t\t\tres, err := client.XRead(ctx, &redis.XReadArgs{\n\t\t\t\tStreams: []string{\"empty\"},\n\t\t\t\tBlock:   500 * time.Millisecond,\n\t\t\t\tID:      \"+\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t// Ensure that the XRead call with LastEntry option blocked for at least 100ms.\n\t\t\tExpect(time.Since(start)).To(BeNumerically(\">=\", 100*time.Millisecond))\n\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t{\n\t\t\t\t\tStream: \"empty\",\n\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t{ID: \"4-0\", Values: map[string]interface{}{\"quatro\": \"quatre\"}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tDescribe(\"group\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\terr := client.XGroupCreate(ctx, \"stream\", \"group\", \"0\").Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tres, err := client.XReadGroup(ctx, &redis.XReadGroupArgs{\n\t\t\t\t\tGroup:    \"group\",\n\t\t\t\t\tConsumer: \"consumer\",\n\t\t\t\t\tStreams:  []string{\"stream\", \">\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t\t{\n\t\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t})\n\n\t\t\tAfterEach(func() {\n\t\t\t\tn, err := client.XGroupDestroy(ctx, \"stream\", \"group\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(1)))\n\t\t\t})\n\n\t\t\tIt(\"should XReadGroup skip empty\", func() {\n\t\t\t\tn, err := client.XDel(ctx, \"stream\", \"2-0\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(1)))\n\n\t\t\t\tres, err := client.XReadGroup(ctx, &redis.XReadGroupArgs{\n\t\t\t\t\tGroup:    \"group\",\n\t\t\t\t\tConsumer: \"consumer\",\n\t\t\t\t\tStreams:  []string{\"stream\", \"0\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t\t{\n\t\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t\t\t\t{ID: \"2-0\", Values: nil},\n\t\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t})\n\n\t\t\tIt(\"should XGroupCreateMkStream\", func() {\n\t\t\t\terr := client.XGroupCreateMkStream(ctx, \"stream2\", \"group\", \"0\").Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\terr = client.XGroupCreateMkStream(ctx, \"stream2\", \"group\", \"0\").Err()\n\t\t\t\tExpect(err).To(Equal(proto.RedisError(\"BUSYGROUP Consumer Group name already exists\")))\n\n\t\t\t\tn, err := client.XGroupDestroy(ctx, \"stream2\", \"group\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(1)))\n\n\t\t\t\tn, err = client.Del(ctx, \"stream2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(1)))\n\t\t\t})\n\n\t\t\tIt(\"should XPending\", func() {\n\t\t\t\tinfo, err := client.XPending(ctx, \"stream\", \"group\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(info).To(Equal(&redis.XPending{\n\t\t\t\t\tCount:     3,\n\t\t\t\t\tLower:     \"1-0\",\n\t\t\t\t\tHigher:    \"3-0\",\n\t\t\t\t\tConsumers: map[string]int64{\"consumer\": 3},\n\t\t\t\t}))\n\t\t\t\targs := &redis.XPendingExtArgs{\n\t\t\t\t\tStream:   \"stream\",\n\t\t\t\t\tGroup:    \"group\",\n\t\t\t\t\tStart:    \"-\",\n\t\t\t\t\tEnd:      \"+\",\n\t\t\t\t\tCount:    10,\n\t\t\t\t\tConsumer: \"consumer\",\n\t\t\t\t}\n\t\t\t\tinfoExt, err := client.XPendingExt(ctx, args).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tfor i := range infoExt {\n\t\t\t\t\tinfoExt[i].Idle = 0\n\t\t\t\t}\n\t\t\t\tExpect(infoExt).To(Equal([]redis.XPendingExt{\n\t\t\t\t\t{ID: \"1-0\", Consumer: \"consumer\", Idle: 0, RetryCount: 1},\n\t\t\t\t\t{ID: \"2-0\", Consumer: \"consumer\", Idle: 0, RetryCount: 1},\n\t\t\t\t\t{ID: \"3-0\", Consumer: \"consumer\", Idle: 0, RetryCount: 1},\n\t\t\t\t}))\n\n\t\t\t\targs.Idle = 72 * time.Hour\n\t\t\t\tinfoExt, err = client.XPendingExt(ctx, args).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(infoExt).To(HaveLen(0))\n\t\t\t})\n\n\t\t\tIt(\"should XGroup Create Delete Consumer\", func() {\n\t\t\t\tn, err := client.XGroupCreateConsumer(ctx, \"stream\", \"group\", \"c1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(1)))\n\n\t\t\t\tn, err = client.XGroupDelConsumer(ctx, \"stream\", \"group\", \"consumer\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(3)))\n\t\t\t})\n\n\t\t\tIt(\"should XAutoClaim\", func() {\n\t\t\t\txca := &redis.XAutoClaimArgs{\n\t\t\t\t\tStream:   \"stream\",\n\t\t\t\t\tGroup:    \"group\",\n\t\t\t\t\tConsumer: \"consumer\",\n\t\t\t\t\tStart:    \"-\",\n\t\t\t\t\tCount:    2,\n\t\t\t\t}\n\t\t\t\tmsgs, start, err := client.XAutoClaim(ctx, xca).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(start).To(Equal(\"3-0\"))\n\t\t\t\tExpect(msgs).To(Equal([]redis.XMessage{{\n\t\t\t\t\tID:     \"1-0\",\n\t\t\t\t\tValues: map[string]interface{}{\"uno\": \"un\"},\n\t\t\t\t}, {\n\t\t\t\t\tID:     \"2-0\",\n\t\t\t\t\tValues: map[string]interface{}{\"dos\": \"deux\"},\n\t\t\t\t}}))\n\n\t\t\t\txca.Start = start\n\t\t\t\tmsgs, start, err = client.XAutoClaim(ctx, xca).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(start).To(Equal(\"0-0\"))\n\t\t\t\tExpect(msgs).To(Equal([]redis.XMessage{{\n\t\t\t\t\tID:     \"3-0\",\n\t\t\t\t\tValues: map[string]interface{}{\"tres\": \"troix\"},\n\t\t\t\t}}))\n\n\t\t\t\tids, start, err := client.XAutoClaimJustID(ctx, xca).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(start).To(Equal(\"0-0\"))\n\t\t\t\tExpect(ids).To(Equal([]string{\"3-0\"}))\n\t\t\t})\n\n\t\t\tIt(\"should XClaim\", func() {\n\t\t\t\tmsgs, err := client.XClaim(ctx, &redis.XClaimArgs{\n\t\t\t\t\tStream:   \"stream\",\n\t\t\t\t\tGroup:    \"group\",\n\t\t\t\t\tConsumer: \"consumer\",\n\t\t\t\t\tMessages: []string{\"1-0\", \"2-0\", \"3-0\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(msgs).To(Equal([]redis.XMessage{{\n\t\t\t\t\tID:     \"1-0\",\n\t\t\t\t\tValues: map[string]interface{}{\"uno\": \"un\"},\n\t\t\t\t}, {\n\t\t\t\t\tID:     \"2-0\",\n\t\t\t\t\tValues: map[string]interface{}{\"dos\": \"deux\"},\n\t\t\t\t}, {\n\t\t\t\t\tID:     \"3-0\",\n\t\t\t\t\tValues: map[string]interface{}{\"tres\": \"troix\"},\n\t\t\t\t}}))\n\n\t\t\t\tids, err := client.XClaimJustID(ctx, &redis.XClaimArgs{\n\t\t\t\t\tStream:   \"stream\",\n\t\t\t\t\tGroup:    \"group\",\n\t\t\t\t\tConsumer: \"consumer\",\n\t\t\t\t\tMessages: []string{\"1-0\", \"2-0\", \"3-0\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(ids).To(Equal([]string{\"1-0\", \"2-0\", \"3-0\"}))\n\t\t\t})\n\n\t\t\tIt(\"should XAck\", func() {\n\t\t\t\tn, err := client.XAck(ctx, \"stream\", \"group\", \"1-0\", \"2-0\", \"4-0\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(2)))\n\t\t\t})\n\t\t})\n\n\t\tDescribe(\"xinfo\", func() {\n\t\t\tBeforeEach(func() {\n\t\t\t\terr := client.XGroupCreate(ctx, \"stream\", \"group1\", \"0\").Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tres, err := client.XReadGroup(ctx, &redis.XReadGroupArgs{\n\t\t\t\t\tGroup:    \"group1\",\n\t\t\t\t\tConsumer: \"consumer1\",\n\t\t\t\t\tStreams:  []string{\"stream\", \">\"},\n\t\t\t\t\tCount:    2,\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t\t{\n\t\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t\t{ID: \"1-0\", Values: map[string]interface{}{\"uno\": \"un\"}},\n\t\t\t\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}))\n\n\t\t\t\tres, err = client.XReadGroup(ctx, &redis.XReadGroupArgs{\n\t\t\t\t\tGroup:    \"group1\",\n\t\t\t\t\tConsumer: \"consumer2\",\n\t\t\t\t\tStreams:  []string{\"stream\", \">\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t\t{\n\t\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}))\n\n\t\t\t\terr = client.XGroupCreate(ctx, \"stream\", \"group2\", \"1-0\").Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tres, err = client.XReadGroup(ctx, &redis.XReadGroupArgs{\n\t\t\t\t\tGroup:    \"group2\",\n\t\t\t\t\tConsumer: \"consumer1\",\n\t\t\t\t\tStreams:  []string{\"stream\", \">\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]redis.XStream{\n\t\t\t\t\t{\n\t\t\t\t\t\tStream: \"stream\",\n\t\t\t\t\t\tMessages: []redis.XMessage{\n\t\t\t\t\t\t\t{ID: \"2-0\", Values: map[string]interface{}{\"dos\": \"deux\"}},\n\t\t\t\t\t\t\t{ID: \"3-0\", Values: map[string]interface{}{\"tres\": \"troix\"}},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t})\n\n\t\t\tAfterEach(func() {\n\t\t\t\tn, err := client.XGroupDestroy(ctx, \"stream\", \"group1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(1)))\n\t\t\t\tn, err = client.XGroupDestroy(ctx, \"stream\", \"group2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(1)))\n\t\t\t})\n\n\t\t\tIt(\"should XINFO STREAM\", func() {\n\t\t\t\tres, err := client.XInfoStream(ctx, \"stream\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tres.RadixTreeKeys = 0\n\t\t\t\tres.RadixTreeNodes = 0\n\n\t\t\t\tExpect(res).To(Equal(&redis.XInfoStream{\n\t\t\t\t\tLength:            3,\n\t\t\t\t\tRadixTreeKeys:     0,\n\t\t\t\t\tRadixTreeNodes:    0,\n\t\t\t\t\tGroups:            2,\n\t\t\t\t\tLastGeneratedID:   \"3-0\",\n\t\t\t\t\tMaxDeletedEntryID: \"0-0\",\n\t\t\t\t\tEntriesAdded:      3,\n\t\t\t\t\tFirstEntry: redis.XMessage{\n\t\t\t\t\t\tID:     \"1-0\",\n\t\t\t\t\t\tValues: map[string]interface{}{\"uno\": \"un\"},\n\t\t\t\t\t},\n\t\t\t\t\tLastEntry: redis.XMessage{\n\t\t\t\t\t\tID:     \"3-0\",\n\t\t\t\t\t\tValues: map[string]interface{}{\"tres\": \"troix\"},\n\t\t\t\t\t},\n\t\t\t\t\tRecordedFirstEntryID: \"1-0\",\n\t\t\t\t}))\n\n\t\t\t\t// stream is empty\n\t\t\t\tn, err := client.XDel(ctx, \"stream\", \"1-0\", \"2-0\", \"3-0\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(3)))\n\n\t\t\t\tres, err = client.XInfoStream(ctx, \"stream\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tres.RadixTreeKeys = 0\n\t\t\t\tres.RadixTreeNodes = 0\n\n\t\t\t\tExpect(res).To(Equal(&redis.XInfoStream{\n\t\t\t\t\tLength:               0,\n\t\t\t\t\tRadixTreeKeys:        0,\n\t\t\t\t\tRadixTreeNodes:       0,\n\t\t\t\t\tGroups:               2,\n\t\t\t\t\tLastGeneratedID:      \"3-0\",\n\t\t\t\t\tMaxDeletedEntryID:    \"3-0\",\n\t\t\t\t\tEntriesAdded:         3,\n\t\t\t\t\tFirstEntry:           redis.XMessage{},\n\t\t\t\t\tLastEntry:            redis.XMessage{},\n\t\t\t\t\tRecordedFirstEntryID: \"0-0\",\n\t\t\t\t}))\n\t\t\t})\n\n\t\t\tIt(\"should XINFO STREAM FULL\", func() {\n\t\t\t\tres, err := client.XInfoStreamFull(ctx, \"stream\", 2).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tres.RadixTreeKeys = 0\n\t\t\t\tres.RadixTreeNodes = 0\n\n\t\t\t\t// Verify DeliveryTime\n\t\t\t\tnow := time.Now()\n\t\t\t\tmaxElapsed := 10 * time.Minute\n\t\t\t\tfor k, g := range res.Groups {\n\t\t\t\t\tfor k2, p := range g.Pending {\n\t\t\t\t\t\tExpect(now.Sub(p.DeliveryTime)).To(BeNumerically(\"<=\", maxElapsed))\n\t\t\t\t\t\tres.Groups[k].Pending[k2].DeliveryTime = time.Time{}\n\t\t\t\t\t}\n\t\t\t\t\tfor k3, c := range g.Consumers {\n\t\t\t\t\t\tExpect(now.Sub(c.SeenTime)).To(BeNumerically(\"<=\", maxElapsed))\n\t\t\t\t\t\tExpect(now.Sub(c.ActiveTime)).To(BeNumerically(\"<=\", maxElapsed))\n\t\t\t\t\t\tres.Groups[k].Consumers[k3].SeenTime = time.Time{}\n\t\t\t\t\t\tres.Groups[k].Consumers[k3].ActiveTime = time.Time{}\n\n\t\t\t\t\t\tfor k4, p := range c.Pending {\n\t\t\t\t\t\t\tExpect(now.Sub(p.DeliveryTime)).To(BeNumerically(\"<=\", maxElapsed))\n\t\t\t\t\t\t\tres.Groups[k].Consumers[k3].Pending[k4].DeliveryTime = time.Time{}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tExpect(res.Groups).To(Equal([]redis.XInfoStreamGroup{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:            \"group1\",\n\t\t\t\t\t\tLastDeliveredID: \"3-0\",\n\t\t\t\t\t\tEntriesRead:     3,\n\t\t\t\t\t\tLag:             0,\n\t\t\t\t\t\tPelCount:        3,\n\t\t\t\t\t\tPending: []redis.XInfoStreamGroupPending{\n\t\t\t\t\t\t\t{ID: \"1-0\", Consumer: \"consumer1\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t\t{ID: \"2-0\", Consumer: \"consumer1\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tConsumers: []redis.XInfoStreamConsumer{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:       \"consumer1\",\n\t\t\t\t\t\t\t\tSeenTime:   time.Time{},\n\t\t\t\t\t\t\t\tActiveTime: time.Time{},\n\t\t\t\t\t\t\t\tPelCount:   2,\n\t\t\t\t\t\t\t\tPending: []redis.XInfoStreamConsumerPending{\n\t\t\t\t\t\t\t\t\t{ID: \"1-0\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t\t\t\t{ID: \"2-0\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:       \"consumer2\",\n\t\t\t\t\t\t\t\tSeenTime:   time.Time{},\n\t\t\t\t\t\t\t\tActiveTime: time.Time{},\n\t\t\t\t\t\t\t\tPelCount:   1,\n\t\t\t\t\t\t\t\tPending: []redis.XInfoStreamConsumerPending{\n\t\t\t\t\t\t\t\t\t{ID: \"3-0\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName:            \"group2\",\n\t\t\t\t\t\tLastDeliveredID: \"3-0\",\n\t\t\t\t\t\tEntriesRead:     3,\n\t\t\t\t\t\tLag:             0,\n\t\t\t\t\t\tPelCount:        2,\n\t\t\t\t\t\tPending: []redis.XInfoStreamGroupPending{\n\t\t\t\t\t\t\t{ID: \"2-0\", Consumer: \"consumer1\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t\t{ID: \"3-0\", Consumer: \"consumer1\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tConsumers: []redis.XInfoStreamConsumer{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:       \"consumer1\",\n\t\t\t\t\t\t\t\tSeenTime:   time.Time{},\n\t\t\t\t\t\t\t\tActiveTime: time.Time{},\n\t\t\t\t\t\t\t\tPelCount:   2,\n\t\t\t\t\t\t\t\tPending: []redis.XInfoStreamConsumerPending{\n\t\t\t\t\t\t\t\t\t{ID: \"2-0\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t\t\t\t{ID: \"3-0\", DeliveryTime: time.Time{}, DeliveryCount: 1},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t}))\n\n\t\t\t\t// entries-read = nil\n\t\t\t\tExpect(client.Del(ctx, \"xinfo-stream-full-stream\").Err()).NotTo(HaveOccurred())\n\t\t\t\tid, err := client.XAdd(ctx, &redis.XAddArgs{\n\t\t\t\t\tStream: \"xinfo-stream-full-stream\",\n\t\t\t\t\tID:     \"*\",\n\t\t\t\t\tValues: []any{\"k1\", \"v1\"},\n\t\t\t\t}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(client.XGroupCreateMkStream(ctx, \"xinfo-stream-full-stream\", \"xinfo-stream-full-group\", \"0\").Err()).NotTo(HaveOccurred())\n\t\t\t\tres, err = client.XInfoStreamFull(ctx, \"xinfo-stream-full-stream\", 0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(&redis.XInfoStreamFull{\n\t\t\t\t\tLength:            1,\n\t\t\t\t\tRadixTreeKeys:     1,\n\t\t\t\t\tRadixTreeNodes:    2,\n\t\t\t\t\tLastGeneratedID:   id,\n\t\t\t\t\tMaxDeletedEntryID: \"0-0\",\n\t\t\t\t\tEntriesAdded:      1,\n\t\t\t\t\tEntries:           []redis.XMessage{{ID: id, Values: map[string]any{\"k1\": \"v1\"}}},\n\t\t\t\t\tGroups: []redis.XInfoStreamGroup{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:            \"xinfo-stream-full-group\",\n\t\t\t\t\t\t\tLastDeliveredID: \"0-0\",\n\t\t\t\t\t\t\tEntriesRead:     0,\n\t\t\t\t\t\t\tLag:             1,\n\t\t\t\t\t\t\tPelCount:        0,\n\t\t\t\t\t\t\tPending:         []redis.XInfoStreamGroupPending{},\n\t\t\t\t\t\t\tConsumers:       []redis.XInfoStreamConsumer{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRecordedFirstEntryID: id,\n\t\t\t\t}))\n\t\t\t})\n\n\t\t\tIt(\"should XINFO GROUPS\", func() {\n\t\t\t\tres, err := client.XInfoGroups(ctx, \"stream\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]redis.XInfoGroup{\n\t\t\t\t\t{Name: \"group1\", Consumers: 2, Pending: 3, LastDeliveredID: \"3-0\", EntriesRead: 3},\n\t\t\t\t\t{Name: \"group2\", Consumers: 1, Pending: 2, LastDeliveredID: \"3-0\", EntriesRead: 3},\n\t\t\t\t}))\n\t\t\t})\n\n\t\t\tIt(\"should XINFO CONSUMERS\", func() {\n\t\t\t\tres, err := client.XInfoConsumers(ctx, \"stream\", \"group1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tfor i := range res {\n\t\t\t\t\tres[i].Idle = 0\n\t\t\t\t\tres[i].Inactive = 0\n\t\t\t\t}\n\n\t\t\t\tExpect(res).To(Equal([]redis.XInfoConsumer{\n\t\t\t\t\t{Name: \"consumer1\", Pending: 2, Idle: 0, Inactive: 0},\n\t\t\t\t\t{Name: \"consumer2\", Pending: 1, Idle: 0, Inactive: 0},\n\t\t\t\t}))\n\t\t\t})\n\t\t})\n\t})\n\n\tDescribe(\"Geo add and radius search\", func() {\n\t\tBeforeEach(func() {\n\t\t\tn, err := client.GeoAdd(\n\t\t\t\tctx,\n\t\t\t\t\"Sicily\",\n\t\t\t\t&redis.GeoLocation{Longitude: 13.361389, Latitude: 38.115556, Name: \"Palermo\"},\n\t\t\t\t&redis.GeoLocation{Longitude: 15.087269, Latitude: 37.502669, Name: \"Catania\"},\n\t\t\t).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\t\t})\n\n\t\tIt(\"should not add same geo location\", func() {\n\t\t\tgeoAdd := client.GeoAdd(\n\t\t\t\tctx,\n\t\t\t\t\"Sicily\",\n\t\t\t\t&redis.GeoLocation{Longitude: 13.361389, Latitude: 38.115556, Name: \"Palermo\"},\n\t\t\t)\n\t\t\tExpect(geoAdd.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(geoAdd.Val()).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should search geo radius\", func() {\n\t\t\tres, err := client.GeoRadius(ctx, \"Sicily\", 15, 37, &redis.GeoRadiusQuery{\n\t\t\t\tRadius: 200,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(HaveLen(2))\n\t\t\tExpect(res[0].Name).To(Equal(\"Palermo\"))\n\t\t\tExpect(res[1].Name).To(Equal(\"Catania\"))\n\t\t})\n\n\t\tIt(\"should geo radius and store the result\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tn, err := client.GeoRadiusStore(ctx, \"Sicily\", 15, 37, &redis.GeoRadiusQuery{\n\t\t\t\tRadius: 200,\n\t\t\t\tStore:  \"result\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\n\t\t\tres, err := client.ZRangeWithScores(ctx, \"result\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(ContainElement(redis.Z{\n\t\t\t\tScore:  3.479099956230698e+15,\n\t\t\t\tMember: \"Palermo\",\n\t\t\t}))\n\t\t\tExpect(res).To(ContainElement(redis.Z{\n\t\t\t\tScore:  3.479447370796909e+15,\n\t\t\t\tMember: \"Catania\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should geo radius and store dist\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tn, err := client.GeoRadiusStore(ctx, \"Sicily\", 15, 37, &redis.GeoRadiusQuery{\n\t\t\t\tRadius:    200,\n\t\t\t\tStoreDist: \"result\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(2)))\n\n\t\t\tres, err := client.ZRangeWithScores(ctx, \"result\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(ContainElement(redis.Z{\n\t\t\t\tScore:  190.44242984775784,\n\t\t\t\tMember: \"Palermo\",\n\t\t\t}))\n\t\t\tExpect(res).To(ContainElement(redis.Z{\n\t\t\t\tScore:  56.4412578701582,\n\t\t\t\tMember: \"Catania\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should search geo radius with options\", func() {\n\t\t\tres, err := client.GeoRadius(ctx, \"Sicily\", 15, 37, &redis.GeoRadiusQuery{\n\t\t\t\tRadius:      200,\n\t\t\t\tUnit:        \"km\",\n\t\t\t\tWithGeoHash: true,\n\t\t\t\tWithCoord:   true,\n\t\t\t\tWithDist:    true,\n\t\t\t\tCount:       2,\n\t\t\t\tSort:        \"ASC\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(HaveLen(2))\n\t\t\tExpect(res[1].Name).To(Equal(\"Palermo\"))\n\t\t\tExpect(res[1].Dist).To(Equal(190.4424))\n\t\t\tExpect(res[1].GeoHash).To(Equal(int64(3479099956230698)))\n\t\t\tExpect(res[1].Longitude).To(Equal(13.361389338970184))\n\t\t\tExpect(res[1].Latitude).To(Equal(38.115556395496299))\n\t\t\tExpect(res[0].Name).To(Equal(\"Catania\"))\n\t\t\tExpect(res[0].Dist).To(Equal(56.4413))\n\t\t\tExpect(res[0].GeoHash).To(Equal(int64(3479447370796909)))\n\t\t\tExpect(res[0].Longitude).To(Equal(15.087267458438873))\n\t\t\tExpect(res[0].Latitude).To(Equal(37.50266842333162))\n\t\t})\n\n\t\tIt(\"should search geo radius with WithDist=false\", func() {\n\t\t\tres, err := client.GeoRadius(ctx, \"Sicily\", 15, 37, &redis.GeoRadiusQuery{\n\t\t\t\tRadius:      200,\n\t\t\t\tUnit:        \"km\",\n\t\t\t\tWithGeoHash: true,\n\t\t\t\tWithCoord:   true,\n\t\t\t\tCount:       2,\n\t\t\t\tSort:        \"ASC\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(HaveLen(2))\n\t\t\tExpect(res[1].Name).To(Equal(\"Palermo\"))\n\t\t\tExpect(res[1].Dist).To(Equal(float64(0)))\n\t\t\tExpect(res[1].GeoHash).To(Equal(int64(3479099956230698)))\n\t\t\tExpect(res[1].Longitude).To(Equal(13.361389338970184))\n\t\t\tExpect(res[1].Latitude).To(Equal(38.115556395496299))\n\t\t\tExpect(res[0].Name).To(Equal(\"Catania\"))\n\t\t\tExpect(res[0].Dist).To(Equal(float64(0)))\n\t\t\tExpect(res[0].GeoHash).To(Equal(int64(3479447370796909)))\n\t\t\tExpect(res[0].Longitude).To(Equal(15.087267458438873))\n\t\t\tExpect(res[0].Latitude).To(Equal(37.50266842333162))\n\t\t})\n\n\t\tIt(\"should search geo radius by member with options\", func() {\n\t\t\tres, err := client.GeoRadiusByMember(ctx, \"Sicily\", \"Catania\", &redis.GeoRadiusQuery{\n\t\t\t\tRadius:      200,\n\t\t\t\tUnit:        \"km\",\n\t\t\t\tWithGeoHash: true,\n\t\t\t\tWithCoord:   true,\n\t\t\t\tWithDist:    true,\n\t\t\t\tCount:       2,\n\t\t\t\tSort:        \"ASC\",\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(HaveLen(2))\n\t\t\tExpect(res[0].Name).To(Equal(\"Catania\"))\n\t\t\tExpect(res[0].Dist).To(Equal(0.0))\n\t\t\tExpect(res[0].GeoHash).To(Equal(int64(3479447370796909)))\n\t\t\tExpect(res[0].Longitude).To(Equal(15.087267458438873))\n\t\t\tExpect(res[0].Latitude).To(Equal(37.50266842333162))\n\t\t\tExpect(res[1].Name).To(Equal(\"Palermo\"))\n\t\t\tExpect(res[1].Dist).To(Equal(166.2742))\n\t\t\tExpect(res[1].GeoHash).To(Equal(int64(3479099956230698)))\n\t\t\tExpect(res[1].Longitude).To(Equal(13.361389338970184))\n\t\t\tExpect(res[1].Latitude).To(Equal(38.115556395496299))\n\t\t})\n\n\t\tIt(\"should search geo radius with no results\", func() {\n\t\t\tres, err := client.GeoRadius(ctx, \"Sicily\", 99, 37, &redis.GeoRadiusQuery{\n\t\t\t\tRadius:      200,\n\t\t\t\tUnit:        \"km\",\n\t\t\t\tWithGeoHash: true,\n\t\t\t\tWithCoord:   true,\n\t\t\t\tWithDist:    true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(HaveLen(0))\n\t\t})\n\n\t\tIt(\"should get geo distance with unit options\", func() {\n\t\t\t// From Redis CLI, note the difference in rounding in m vs\n\t\t\t// km on Redis itself.\n\t\t\t//\n\t\t\t// GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"\n\t\t\t// GEODIST Sicily Palermo Catania m\n\t\t\t// \"166274.15156960033\"\n\t\t\t// GEODIST Sicily Palermo Catania km\n\t\t\t// \"166.27415156960032\"\n\t\t\tdist, err := client.GeoDist(ctx, \"Sicily\", \"Palermo\", \"Catania\", \"km\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(dist).To(BeNumerically(\"~\", 166.27, 0.01))\n\n\t\t\tdist, err = client.GeoDist(ctx, \"Sicily\", \"Palermo\", \"Catania\", \"m\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(dist).To(BeNumerically(\"~\", 166274.15, 0.01))\n\t\t})\n\n\t\tIt(\"should get geo hash in string representation\", func() {\n\t\t\thashes, err := client.GeoHash(ctx, \"Sicily\", \"Palermo\", \"Catania\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(hashes).To(ConsistOf([]string{\"sqc8b49rny0\", \"sqdtr74hyu0\"}))\n\t\t})\n\n\t\tIt(\"should return geo position\", func() {\n\t\t\tpos, err := client.GeoPos(ctx, \"Sicily\", \"Palermo\", \"Catania\", \"NonExisting\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(pos).To(ConsistOf([]*redis.GeoPos{\n\t\t\t\t{\n\t\t\t\t\tLongitude: 13.361389338970184,\n\t\t\t\t\tLatitude:  38.1155563954963,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tLongitude: 15.087267458438873,\n\t\t\t\t\tLatitude:  37.50266842333162,\n\t\t\t\t},\n\t\t\t\tnil,\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should geo search\", func() {\n\t\t\tq := &redis.GeoSearchQuery{\n\t\t\t\tMember:    \"Catania\",\n\t\t\t\tBoxWidth:  400,\n\t\t\t\tBoxHeight: 100,\n\t\t\t\tBoxUnit:   \"km\",\n\t\t\t\tSort:      \"asc\",\n\t\t\t}\n\t\t\tval, err := client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.BoxHeight = 400\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\", \"Palermo\"}))\n\n\t\t\tq.Count = 1\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.CountAny = true\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Palermo\"}))\n\n\t\t\tq = &redis.GeoSearchQuery{\n\t\t\t\tMember:     \"Catania\",\n\t\t\t\tRadius:     100,\n\t\t\t\tRadiusUnit: \"km\",\n\t\t\t\tSort:       \"asc\",\n\t\t\t}\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.Radius = 400\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\", \"Palermo\"}))\n\n\t\t\tq.Count = 1\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.CountAny = true\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Palermo\"}))\n\n\t\t\tq = &redis.GeoSearchQuery{\n\t\t\t\tLongitude: 15,\n\t\t\t\tLatitude:  37,\n\t\t\t\tBoxWidth:  200,\n\t\t\t\tBoxHeight: 200,\n\t\t\t\tBoxUnit:   \"km\",\n\t\t\t\tSort:      \"asc\",\n\t\t\t}\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.BoxWidth, q.BoxHeight = 400, 400\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\", \"Palermo\"}))\n\n\t\t\tq.Count = 1\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.CountAny = true\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Palermo\"}))\n\n\t\t\tq = &redis.GeoSearchQuery{\n\t\t\t\tLongitude:  15,\n\t\t\t\tLatitude:   37,\n\t\t\t\tRadius:     100,\n\t\t\t\tRadiusUnit: \"km\",\n\t\t\t\tSort:       \"asc\",\n\t\t\t}\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.Radius = 200\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\", \"Palermo\"}))\n\n\t\t\tq.Count = 1\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Catania\"}))\n\n\t\t\tq.CountAny = true\n\t\t\tval, err = client.GeoSearch(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]string{\"Palermo\"}))\n\t\t})\n\n\t\tIt(\"should geo search with options\", func() {\n\t\t\tq := &redis.GeoSearchLocationQuery{\n\t\t\t\tGeoSearchQuery: redis.GeoSearchQuery{\n\t\t\t\t\tLongitude:  15,\n\t\t\t\t\tLatitude:   37,\n\t\t\t\t\tRadius:     200,\n\t\t\t\t\tRadiusUnit: \"km\",\n\t\t\t\t\tSort:       \"asc\",\n\t\t\t\t},\n\t\t\t\tWithHash:  true,\n\t\t\t\tWithDist:  true,\n\t\t\t\tWithCoord: true,\n\t\t\t}\n\t\t\tval, err := client.GeoSearchLocation(ctx, \"Sicily\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal([]redis.GeoLocation{\n\t\t\t\t{\n\t\t\t\t\tName:      \"Catania\",\n\t\t\t\t\tLongitude: 15.08726745843887329,\n\t\t\t\t\tLatitude:  37.50266842333162032,\n\t\t\t\t\tDist:      56.4413,\n\t\t\t\t\tGeoHash:   3479447370796909,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:      \"Palermo\",\n\t\t\t\t\tLongitude: 13.36138933897018433,\n\t\t\t\t\tLatitude:  38.11555639549629859,\n\t\t\t\t\tDist:      190.4424,\n\t\t\t\t\tGeoHash:   3479099956230698,\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should geo search store\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tq := &redis.GeoSearchStoreQuery{\n\t\t\t\tGeoSearchQuery: redis.GeoSearchQuery{\n\t\t\t\t\tLongitude:  15,\n\t\t\t\t\tLatitude:   37,\n\t\t\t\t\tRadius:     200,\n\t\t\t\t\tRadiusUnit: \"km\",\n\t\t\t\t\tSort:       \"asc\",\n\t\t\t\t},\n\t\t\t\tStoreDist: false,\n\t\t\t}\n\n\t\t\tval, err := client.GeoSearchStore(ctx, \"Sicily\", \"key1\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(int64(2)))\n\n\t\t\tq.StoreDist = true\n\t\t\tval, err = client.GeoSearchStore(ctx, \"Sicily\", \"key2\", q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(int64(2)))\n\n\t\t\tloc, err := client.GeoSearchLocation(ctx, \"key1\", &redis.GeoSearchLocationQuery{\n\t\t\t\tGeoSearchQuery: q.GeoSearchQuery,\n\t\t\t\tWithCoord:      true,\n\t\t\t\tWithDist:       true,\n\t\t\t\tWithHash:       true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(loc).To(Equal([]redis.GeoLocation{\n\t\t\t\t{\n\t\t\t\t\tName:      \"Catania\",\n\t\t\t\t\tLongitude: 15.08726745843887329,\n\t\t\t\t\tLatitude:  37.50266842333162032,\n\t\t\t\t\tDist:      56.4413,\n\t\t\t\t\tGeoHash:   3479447370796909,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:      \"Palermo\",\n\t\t\t\t\tLongitude: 13.36138933897018433,\n\t\t\t\t\tLatitude:  38.11555639549629859,\n\t\t\t\t\tDist:      190.4424,\n\t\t\t\t\tGeoHash:   3479099956230698,\n\t\t\t\t},\n\t\t\t}))\n\n\t\t\tv, err := client.ZRangeWithScores(ctx, \"key2\", 0, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal([]redis.Z{\n\t\t\t\t{\n\t\t\t\t\tScore:  56.441257870158204,\n\t\t\t\t\tMember: \"Catania\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tScore:  190.44242984775784,\n\t\t\t\t\tMember: \"Palermo\",\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\t})\n\n\tDescribe(\"marshaling/unmarshaling\", func() {\n\t\ttype convTest struct {\n\t\t\tvalue  interface{}\n\t\t\twanted string\n\t\t\tdest   interface{}\n\t\t}\n\n\t\tconvTests := []convTest{\n\t\t\t{nil, \"\", nil},\n\t\t\t{\"hello\", \"hello\", new(string)},\n\t\t\t{[]byte(\"hello\"), \"hello\", new([]byte)},\n\t\t\t{1, \"1\", new(int)},\n\t\t\t{int8(1), \"1\", new(int8)},\n\t\t\t{int16(1), \"1\", new(int16)},\n\t\t\t{int32(1), \"1\", new(int32)},\n\t\t\t{int64(1), \"1\", new(int64)},\n\t\t\t{uint(1), \"1\", new(uint)},\n\t\t\t{uint8(1), \"1\", new(uint8)},\n\t\t\t{uint16(1), \"1\", new(uint16)},\n\t\t\t{uint32(1), \"1\", new(uint32)},\n\t\t\t{uint64(1), \"1\", new(uint64)},\n\t\t\t{float32(1.0), \"1\", new(float32)},\n\t\t\t{1.0, \"1\", new(float64)},\n\t\t\t{true, \"1\", new(bool)},\n\t\t\t{false, \"0\", new(bool)},\n\t\t}\n\n\t\tIt(\"should convert to string\", func() {\n\t\t\tfor _, test := range convTests {\n\t\t\t\terr := client.Set(ctx, \"key\", test.value, 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\ts, err := client.Get(ctx, \"key\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(s).To(Equal(test.wanted))\n\n\t\t\t\tif test.dest == nil {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\terr = client.Get(ctx, \"key\").Scan(test.dest)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(deref(test.dest)).To(Equal(test.value))\n\t\t\t}\n\t\t})\n\t})\n\n\tDescribe(\"json marshaling/unmarshaling\", func() {\n\t\tBeforeEach(func() {\n\t\t\tvalue := &numberStruct{Number: 42}\n\t\t\terr := client.Set(ctx, \"key\", value, 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should marshal custom values using json\", func() {\n\t\t\ts, err := client.Get(ctx, \"key\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(s).To(Equal(`{\"Number\":42}`))\n\t\t})\n\n\t\tIt(\"should scan custom values using json\", func() {\n\t\t\tvalue := &numberStruct{}\n\t\t\terr := client.Get(ctx, \"key\").Scan(value)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(value.Number).To(Equal(42))\n\t\t})\n\t})\n\n\tDescribe(\"Eval\", func() {\n\t\tIt(\"returns keys and values\", func() {\n\t\t\tvals, err := client.Eval(\n\t\t\t\tctx,\n\t\t\t\t\"return {KEYS[1],ARGV[1]}\",\n\t\t\t\t[]string{\"key\"},\n\t\t\t\t\"hello\",\n\t\t\t).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]interface{}{\"key\", \"hello\"}))\n\t\t})\n\n\t\tIt(\"returns all values after an error\", func() {\n\t\t\tvals, err := client.Eval(\n\t\t\t\tctx,\n\t\t\t\t`return {12, {err=\"error\"}, \"abc\"}`,\n\t\t\t\tnil,\n\t\t\t).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]interface{}{int64(12), proto.RedisError(\"error\"), \"abc\"}))\n\t\t})\n\t})\n\n\tDescribe(\"EvalRO\", func() {\n\t\tIt(\"returns keys and values\", func() {\n\t\t\tvals, err := client.EvalRO(\n\t\t\t\tctx,\n\t\t\t\t\"return {KEYS[1],ARGV[1]}\",\n\t\t\t\t[]string{\"key\"},\n\t\t\t\t\"hello\",\n\t\t\t).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]interface{}{\"key\", \"hello\"}))\n\t\t})\n\n\t\tIt(\"returns all values after an error\", func() {\n\t\t\tvals, err := client.EvalRO(\n\t\t\t\tctx,\n\t\t\t\t`return {12, {err=\"error\"}, \"abc\"}`,\n\t\t\t\tnil,\n\t\t\t).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(vals).To(Equal([]interface{}{int64(12), proto.RedisError(\"error\"), \"abc\"}))\n\t\t})\n\t})\n\n\tDescribe(\"Functions\", func() {\n\t\tvar (\n\t\t\tq        redis.FunctionListQuery\n\t\t\tlib1Code string\n\t\t\tlib2Code string\n\t\t\tlib1     redis.Library\n\t\t\tlib2     redis.Library\n\t\t)\n\n\t\tBeforeEach(func() {\n\t\t\tflush := client.FunctionFlush(ctx)\n\t\t\tExpect(flush.Err()).NotTo(HaveOccurred())\n\n\t\t\tlib1 = redis.Library{\n\t\t\t\tName:   \"mylib1\",\n\t\t\t\tEngine: \"LUA\",\n\t\t\t\tFunctions: []redis.Function{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:        \"lib1_func1\",\n\t\t\t\t\t\tDescription: \"This is the func-1 of lib 1\",\n\t\t\t\t\t\tFlags:       []string{\"allow-oom\", \"allow-stale\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCode: `#!lua name=%s\n\t\t\t\t\t\n                     local function f1(keys, args)\n                        local hash = keys[1]  -- Get the key name\n                        local time = redis.call('TIME')[1]  -- Get the current time from the Redis server\n\n                        -- Add the current timestamp to the arguments that the user passed to the function, stored in args\n                        table.insert(args, '_updated_at')\n                        table.insert(args, time)\n\n                        -- Run HSET with the updated argument list\n                        return redis.call('HSET', hash, unpack(args))\n                     end\n\n\t\t\t\t\tredis.register_function{\n\t\t\t\t\t\tfunction_name='%s',\n\t\t\t\t\t\tdescription ='%s',\n\t\t\t\t\t\tcallback=f1,\n\t\t\t\t\t\tflags={'%s', '%s'}\n\t\t\t\t\t}`,\n\t\t\t}\n\n\t\t\tlib2 = redis.Library{\n\t\t\t\tName:   \"mylib2\",\n\t\t\t\tEngine: \"LUA\",\n\t\t\t\tFunctions: []redis.Function{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:  \"lib2_func1\",\n\t\t\t\t\t\tFlags: []string{},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tName:        \"lib2_func2\",\n\t\t\t\t\t\tDescription: \"This is the func-2 of lib 2\",\n\t\t\t\t\t\tFlags:       []string{\"no-writes\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCode: `#!lua name=%s\n\n\t\t\t\t\tlocal function f1(keys, args)\n\t\t\t\t\t\t return 'Function 1'\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tlocal function f2(keys, args)\n\t\t\t\t\t\t return 'Function 2'\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t\tredis.register_function('%s', f1)\n\t\t\t\t\tredis.register_function{\n\t\t\t\t\t\tfunction_name='%s',\n\t\t\t\t\t\tdescription ='%s',\n\t\t\t\t\t\tcallback=f2,\n\t\t\t\t\t\tflags={'%s'}\n\t\t\t\t\t}`,\n\t\t\t}\n\n\t\t\tlib1Code = fmt.Sprintf(lib1.Code, lib1.Name, lib1.Functions[0].Name,\n\t\t\t\tlib1.Functions[0].Description, lib1.Functions[0].Flags[0], lib1.Functions[0].Flags[1])\n\t\t\tlib2Code = fmt.Sprintf(lib2.Code, lib2.Name, lib2.Functions[0].Name,\n\t\t\t\tlib2.Functions[1].Name, lib2.Functions[1].Description, lib2.Functions[1].Flags[0])\n\n\t\t\tq = redis.FunctionListQuery{}\n\t\t})\n\n\t\tIt(\"Loads a new library\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tfunctionLoad := client.FunctionLoad(ctx, lib1Code)\n\t\t\tExpect(functionLoad.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(functionLoad.Val()).To(Equal(lib1.Name))\n\n\t\t\tfunctionList := client.FunctionList(ctx, q)\n\t\t\tExpect(functionList.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(functionList.Val()).To(HaveLen(1))\n\t\t})\n\n\t\tIt(\"Loads and replaces a new library\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\t// Load a library for the first time\n\t\t\terr := client.FunctionLoad(ctx, lib1Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tnewFuncName := \"replaces_func_name\"\n\t\t\tnewFuncDesc := \"replaces_func_desc\"\n\t\t\tflag1, flag2 := \"allow-stale\", \"no-cluster\"\n\t\t\tnewCode := fmt.Sprintf(lib1.Code, lib1.Name, newFuncName, newFuncDesc, flag1, flag2)\n\n\t\t\t// And then replace it\n\t\t\tfunctionLoadReplace := client.FunctionLoadReplace(ctx, newCode)\n\t\t\tExpect(functionLoadReplace.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(functionLoadReplace.Val()).To(Equal(lib1.Name))\n\n\t\t\tlib, err := client.FunctionList(ctx, q).First()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(lib.Functions).To(Equal([]redis.Function{\n\t\t\t\t{\n\t\t\t\t\tName:        newFuncName,\n\t\t\t\t\tDescription: newFuncDesc,\n\t\t\t\t\tFlags:       []string{flag1, flag2},\n\t\t\t\t},\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"Deletes a library\", func() {\n\t\t\terr := client.FunctionLoad(ctx, lib1Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.FunctionDelete(ctx, lib1.Name).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.FunctionList(ctx, redis.FunctionListQuery{\n\t\t\t\tLibraryNamePattern: lib1.Name,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(HaveLen(0))\n\t\t})\n\n\t\tIt(\"Flushes all libraries\", func() {\n\t\t\terr := client.FunctionLoad(ctx, lib1Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.FunctionLoad(ctx, lib2Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.FunctionFlush(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.FunctionList(ctx, q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(HaveLen(0))\n\t\t})\n\n\t\tIt(\"Flushes all libraries asynchronously\", func() {\n\t\t\tfunctionLoad := client.FunctionLoad(ctx, lib1Code)\n\t\t\tExpect(functionLoad.Err()).NotTo(HaveOccurred())\n\n\t\t\t// we only verify the command result.\n\t\t\tfunctionFlush := client.FunctionFlushAsync(ctx)\n\t\t\tExpect(functionFlush.Err()).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"Kills a running function\", func() {\n\t\t\tfunctionKill := client.FunctionKill(ctx)\n\t\t\tExpect(functionKill.Err()).To(MatchError(\"NOTBUSY No scripts in execution right now.\"))\n\n\t\t\t// Add test for a long-running function, once we make the test for `function stats` pass\n\t\t})\n\n\t\tIt(\"Lists registered functions\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.FunctionLoad(ctx, lib1Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err := client.FunctionList(ctx, redis.FunctionListQuery{\n\t\t\t\tLibraryNamePattern: \"*\",\n\t\t\t\tWithCode:           true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(HaveLen(1))\n\t\t\tExpect(val[0].Name).To(Equal(lib1.Name))\n\t\t\tExpect(val[0].Engine).To(Equal(lib1.Engine))\n\t\t\tExpect(val[0].Code).To(Equal(lib1Code))\n\t\t\tExpect(val[0].Functions).Should(ConsistOf(lib1.Functions))\n\n\t\t\terr = client.FunctionLoad(ctx, lib2Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tval, err = client.FunctionList(ctx, redis.FunctionListQuery{\n\t\t\t\tWithCode: true,\n\t\t\t}).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(HaveLen(2))\n\n\t\t\tlib, err := client.FunctionList(ctx, redis.FunctionListQuery{\n\t\t\t\tLibraryNamePattern: lib2.Name,\n\t\t\t\tWithCode:           false,\n\t\t\t}).First()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(lib.Name).To(Equal(lib2.Name))\n\t\t\tExpect(lib.Code).To(Equal(\"\"))\n\n\t\t\t_, err = client.FunctionList(ctx, redis.FunctionListQuery{\n\t\t\t\tLibraryNamePattern: \"non_lib\",\n\t\t\t\tWithCode:           true,\n\t\t\t}).First()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t})\n\n\t\tIt(\"Dump and restores all libraries\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\terr := client.FunctionLoad(ctx, lib1Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\terr = client.FunctionLoad(ctx, lib2Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tdump, err := client.FunctionDump(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(dump).NotTo(BeEmpty())\n\n\t\t\terr = client.FunctionRestore(ctx, dump).Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\n\t\t\terr = client.FunctionFlush(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tlist, err := client.FunctionList(ctx, q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(list).To(HaveLen(0))\n\n\t\t\terr = client.FunctionRestore(ctx, dump).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tlist, err = client.FunctionList(ctx, q).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(list).To(HaveLen(2))\n\t\t})\n\n\t\tIt(\"Calls a function\", func() {\n\t\t\tlib1Code = fmt.Sprintf(lib1.Code, lib1.Name, lib1.Functions[0].Name,\n\t\t\t\tlib1.Functions[0].Description, lib1.Functions[0].Flags[0], lib1.Functions[0].Flags[1])\n\n\t\t\terr := client.FunctionLoad(ctx, lib1Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tx := client.FCall(ctx, lib1.Functions[0].Name, []string{\"my_hash\"}, \"a\", 1, \"b\", 2)\n\t\t\tExpect(x.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(x.Int()).To(Equal(3))\n\t\t})\n\n\t\tIt(\"Calls a function as read-only\", func() {\n\t\t\tlib1Code = fmt.Sprintf(lib1.Code, lib1.Name, lib1.Functions[0].Name,\n\t\t\t\tlib1.Functions[0].Description, lib1.Functions[0].Flags[0], lib1.Functions[0].Flags[1])\n\n\t\t\terr := client.FunctionLoad(ctx, lib1Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t// This function doesn't have a \"no-writes\" flag\n\t\t\tx := client.FCallRo(ctx, lib1.Functions[0].Name, []string{\"my_hash\"}, \"a\", 1, \"b\", 2)\n\n\t\t\tExpect(x.Err()).To(HaveOccurred())\n\n\t\t\tlib2Code = fmt.Sprintf(lib2.Code, lib2.Name, lib2.Functions[0].Name, lib2.Functions[1].Name,\n\t\t\t\tlib2.Functions[1].Description, lib2.Functions[1].Flags[0])\n\n\t\t\t// This function has a \"no-writes\" flag\n\t\t\terr = client.FunctionLoad(ctx, lib2Code).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tx = client.FCallRo(ctx, lib2.Functions[1].Name, []string{})\n\n\t\t\tExpect(x.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(x.Text()).To(Equal(\"Function 2\"))\n\t\t})\n\n\t\tIt(\"Shows function stats\", func() {\n\t\t\tdefer client.FunctionKill(ctx)\n\n\t\t\t// We can not run blocking commands in Redis functions, so we're using an infinite loop,\n\t\t\t// but we're killing the function after calling FUNCTION STATS\n\t\t\tlib := redis.Library{\n\t\t\t\tName:   \"mylib1\",\n\t\t\t\tEngine: \"LUA\",\n\t\t\t\tFunctions: []redis.Function{\n\t\t\t\t\t{\n\t\t\t\t\t\tName:        \"lib1_func1\",\n\t\t\t\t\t\tDescription: \"This is the func-1 of lib 1\",\n\t\t\t\t\t\tFlags:       []string{\"no-writes\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tCode: `#!lua name=%s\n\t\t\t\t\tlocal function f1(keys, args)\n\t\t\t\t\t\tlocal i = 0\n\t\t\t\t\t   \twhile true do\n\t\t\t\t\t\t\ti = i + 1\n\t\t\t\t\t   \tend\n\t\t\t\t\tend\n\n\t\t\t\t\tredis.register_function{\n\t\t\t\t\t\tfunction_name='%s',\n\t\t\t\t\t\tdescription ='%s',\n\t\t\t\t\t\tcallback=f1,\n\t\t\t\t\t\tflags={'%s'}\n\t\t\t\t\t}`,\n\t\t\t}\n\t\t\tlibCode := fmt.Sprintf(lib.Code, lib.Name, lib.Functions[0].Name,\n\t\t\t\tlib.Functions[0].Description, lib.Functions[0].Flags[0])\n\t\t\terr := client.FunctionLoad(ctx, libCode).Err()\n\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tr, err := client.FunctionStats(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(r.Engines)).To(Equal(1))\n\t\t\tExpect(r.Running()).To(BeFalse())\n\n\t\t\tstarted := make(chan bool)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tclient2 := redis.NewClient(redisOptions())\n\n\t\t\t\tstarted <- true\n\t\t\t\t_, err = client2.FCall(ctx, lib.Functions[0].Name, nil).Result()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t}()\n\n\t\t\t<-started\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tr, err = client.FunctionStats(ctx).Result()\n\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(r.Engines)).To(Equal(1))\n\t\t\trs, isRunning := r.RunningScript()\n\t\t\tExpect(isRunning).To(BeTrue())\n\t\t\tExpect(rs.Name).To(Equal(lib.Functions[0].Name))\n\t\t\tExpect(rs.Duration > 0).To(BeTrue())\n\n\t\t\tclose(started)\n\t\t})\n\t})\n\n\tDescribe(\"SlowLogGet\", func() {\n\t\tIt(\"returns slow query result\", func() {\n\t\t\tconst key = \"slowlog-log-slower-than\"\n\n\t\t\told := client.ConfigGet(ctx, key).Val()\n\t\t\tclient.ConfigSet(ctx, key, \"0\")\n\t\t\tdefer client.ConfigSet(ctx, key, old[key])\n\n\t\t\terr := client.Do(ctx, \"slowlog\", \"reset\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tclient.Set(ctx, \"test\", \"true\", 0)\n\n\t\t\tresult, err := client.SlowLogGet(ctx, -1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(result)).NotTo(BeZero())\n\t\t})\n\t})\n})\n\ntype numberStruct struct {\n\tNumber int\n}\n\nfunc (s *numberStruct) MarshalBinary() ([]byte, error) {\n\treturn json.Marshal(s)\n}\n\nfunc (s *numberStruct) UnmarshalBinary(b []byte) error {\n\treturn json.Unmarshal(b, s)\n}\n\nfunc deref(viface interface{}) interface{} {\n\tv := reflect.ValueOf(viface)\n\tfor v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\treturn v.Interface()\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.0595703125,
          "content": "/*\nPackage redis implements a Redis client.\n*/\npackage redis\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.6083984375,
          "content": "---\n\nservices:\n\n  redis-stanalone:\n    image: redislabs/client-libs-test:8.0-M02\n    container_name: redis-standalone\n    environment:\n      - REDIS_CLUSTER=no\n      - PORT=6379\n      - TLS_PORT=6666\n    command: --loadmodule /usr/local/lib/redis/modules/redisbloom.so --loadmodule /usr/local/lib/redis/modules/redisearch.so --loadmodule  /usr/local/lib/redis/modules/redistimeseries.so --loadmodule /usr/local/lib/redis/modules/rejson.so \n    ports:\n      - 6379:6379\n      - 6380:6379\n      - 6666:6666 # TLS port\n    volumes:\n      - \"./dockers/redis-standalone:/redis/work\"\n    profiles:\n      - standalone\n      - all\n"
        },
        {
          "name": "doctests",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 3.2216796875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\n// ErrClosed performs any operation on the closed client will return this error.\nvar ErrClosed = pool.ErrClosed\n\n// HasErrorPrefix checks if the err is a Redis error and the message contains a prefix.\nfunc HasErrorPrefix(err error, prefix string) bool {\n\tvar rErr Error\n\tif !errors.As(err, &rErr) {\n\t\treturn false\n\t}\n\tmsg := rErr.Error()\n\tmsg = strings.TrimPrefix(msg, \"ERR \") // KVRocks adds such prefix\n\treturn strings.HasPrefix(msg, prefix)\n}\n\ntype Error interface {\n\terror\n\n\t// RedisError is a no-op function but\n\t// serves to distinguish types that are Redis\n\t// errors from ordinary errors: a type is a\n\t// Redis error if it has a RedisError method.\n\tRedisError()\n}\n\nvar _ Error = proto.RedisError(\"\")\n\nfunc shouldRetry(err error, retryTimeout bool) bool {\n\tswitch err {\n\tcase io.EOF, io.ErrUnexpectedEOF:\n\t\treturn true\n\tcase nil, context.Canceled, context.DeadlineExceeded:\n\t\treturn false\n\t}\n\n\tif v, ok := err.(timeoutError); ok {\n\t\tif v.Timeout() {\n\t\t\treturn retryTimeout\n\t\t}\n\t\treturn true\n\t}\n\n\ts := err.Error()\n\tif s == \"ERR max number of clients reached\" {\n\t\treturn true\n\t}\n\tif strings.HasPrefix(s, \"LOADING \") {\n\t\treturn true\n\t}\n\tif strings.HasPrefix(s, \"READONLY \") {\n\t\treturn true\n\t}\n\tif strings.HasPrefix(s, \"CLUSTERDOWN \") {\n\t\treturn true\n\t}\n\tif strings.HasPrefix(s, \"TRYAGAIN \") {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc isRedisError(err error) bool {\n\t_, ok := err.(proto.RedisError)\n\treturn ok\n}\n\nfunc isBadConn(err error, allowTimeout bool, addr string) bool {\n\tswitch err {\n\tcase nil:\n\t\treturn false\n\tcase context.Canceled, context.DeadlineExceeded:\n\t\treturn true\n\t}\n\n\tif isRedisError(err) {\n\t\tswitch {\n\t\tcase isReadOnlyError(err):\n\t\t\t// Close connections in read only state in case domain addr is used\n\t\t\t// and domain resolves to a different Redis Server. See #790.\n\t\t\treturn true\n\t\tcase isMovedSameConnAddr(err, addr):\n\t\t\t// Close connections when we are asked to move to the same addr\n\t\t\t// of the connection. Force a DNS resolution when all connections\n\t\t\t// of the pool are recycled\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif allowTimeout {\n\t\tif netErr, ok := err.(net.Error); ok && netErr.Timeout() {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc isMovedError(err error) (moved bool, ask bool, addr string) {\n\tif !isRedisError(err) {\n\t\treturn\n\t}\n\n\ts := err.Error()\n\tswitch {\n\tcase strings.HasPrefix(s, \"MOVED \"):\n\t\tmoved = true\n\tcase strings.HasPrefix(s, \"ASK \"):\n\t\task = true\n\tdefault:\n\t\treturn\n\t}\n\n\tind := strings.LastIndex(s, \" \")\n\tif ind == -1 {\n\t\treturn false, false, \"\"\n\t}\n\n\taddr = s[ind+1:]\n\taddr = internal.GetAddr(addr)\n\treturn\n}\n\nfunc isLoadingError(err error) bool {\n\treturn strings.HasPrefix(err.Error(), \"LOADING \")\n}\n\nfunc isReadOnlyError(err error) bool {\n\treturn strings.HasPrefix(err.Error(), \"READONLY \")\n}\n\nfunc isMovedSameConnAddr(err error, addr string) bool {\n\tredisError := err.Error()\n\tif !strings.HasPrefix(redisError, \"MOVED \") {\n\t\treturn false\n\t}\n\treturn strings.HasSuffix(redisError, \" \"+addr)\n}\n\n//------------------------------------------------------------------------------\n\ntype timeoutError interface {\n\tTimeout() bool\n}\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "example_instrumentation_test.go",
          "type": "blob",
          "size": 2.2666015625,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\ntype redisHook struct{}\n\nvar _ redis.Hook = redisHook{}\n\nfunc (redisHook) DialHook(hook redis.DialHook) redis.DialHook {\n\treturn func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\tfmt.Printf(\"dialing %s %s\\n\", network, addr)\n\t\tconn, err := hook(ctx, network, addr)\n\t\tfmt.Printf(\"finished dialing %s %s\\n\", network, addr)\n\t\treturn conn, err\n\t}\n}\n\nfunc (redisHook) ProcessHook(hook redis.ProcessHook) redis.ProcessHook {\n\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\tfmt.Printf(\"starting processing: <%s>\\n\", cmd)\n\t\terr := hook(ctx, cmd)\n\t\tfmt.Printf(\"finished processing: <%s>\\n\", cmd)\n\t\treturn err\n\t}\n}\n\nfunc (redisHook) ProcessPipelineHook(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\tfmt.Printf(\"pipeline starting processing: %v\\n\", cmds)\n\t\terr := hook(ctx, cmds)\n\t\tfmt.Printf(\"pipeline finished processing: %v\\n\", cmds)\n\t\treturn err\n\t}\n}\n\nfunc Example_instrumentation() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr: \":6379\",\n\t})\n\trdb.AddHook(redisHook{})\n\n\trdb.Ping(ctx)\n\t// Output: starting processing: <ping: >\n\t// dialing tcp :6379\n\t// finished dialing tcp :6379\n\t// finished processing: <ping: PONG>\n}\n\nfunc ExamplePipeline_instrumentation() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr: \":6379\",\n\t})\n\trdb.AddHook(redisHook{})\n\n\trdb.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\tpipe.Ping(ctx)\n\t\tpipe.Ping(ctx)\n\t\treturn nil\n\t})\n\t// Output: pipeline starting processing: [ping:  ping: ]\n\t// dialing tcp :6379\n\t// finished dialing tcp :6379\n\t// pipeline finished processing: [ping: PONG ping: PONG]\n}\n\nfunc ExampleClient_Watch_instrumentation() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr: \":6379\",\n\t})\n\trdb.AddHook(redisHook{})\n\n\trdb.Watch(ctx, func(tx *redis.Tx) error {\n\t\ttx.Ping(ctx)\n\t\ttx.Ping(ctx)\n\t\treturn nil\n\t}, \"foo\")\n\t// Output:\n\t// starting processing: <watch foo: >\n\t// dialing tcp :6379\n\t// finished dialing tcp :6379\n\t// finished processing: <watch foo: OK>\n\t// starting processing: <ping: >\n\t// finished processing: <ping: PONG>\n\t// starting processing: <ping: >\n\t// finished processing: <ping: PONG>\n\t// starting processing: <unwatch: >\n\t// finished processing: <unwatch: OK>\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 14.29296875,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar (\n\tctx = context.Background()\n\trdb *redis.Client\n)\n\nfunc init() {\n\trdb = redis.NewClient(&redis.Options{\n\t\tAddr:         \":6379\",\n\t\tDialTimeout:  10 * time.Second,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\t\tPoolSize:     10,\n\t\tPoolTimeout:  30 * time.Second,\n\t})\n}\n\nfunc ExampleNewClient() {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr:     \"localhost:6379\", // use default Addr\n\t\tPassword: \"\",               // no password set\n\t\tDB:       0,                // use default DB\n\t})\n\n\tpong, err := rdb.Ping(ctx).Result()\n\tfmt.Println(pong, err)\n\t// Output: PONG <nil>\n}\n\nfunc ExampleParseURL() {\n\topt, err := redis.ParseURL(\"redis://:qwerty@localhost:6379/1?dial_timeout=5s\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"addr is\", opt.Addr)\n\tfmt.Println(\"db is\", opt.DB)\n\tfmt.Println(\"password is\", opt.Password)\n\tfmt.Println(\"dial timeout is\", opt.DialTimeout)\n\n\t// Create client as usually.\n\t_ = redis.NewClient(opt)\n\n\t// Output: addr is localhost:6379\n\t// db is 1\n\t// password is qwerty\n\t// dial timeout is 5s\n}\n\nfunc ExampleNewFailoverClient() {\n\t// See http://redis.io/topics/sentinel for instructions how to\n\t// setup Redis Sentinel.\n\trdb := redis.NewFailoverClient(&redis.FailoverOptions{\n\t\tMasterName:    \"master\",\n\t\tSentinelAddrs: []string{\":26379\"},\n\t})\n\trdb.Ping(ctx)\n}\n\nfunc ExampleNewClusterClient() {\n\t// See http://redis.io/topics/cluster-tutorial for instructions\n\t// how to setup Redis Cluster.\n\trdb := redis.NewClusterClient(&redis.ClusterOptions{\n\t\tAddrs: []string{\":7000\", \":7001\", \":7002\", \":7003\", \":7004\", \":7005\"},\n\t})\n\trdb.Ping(ctx)\n}\n\n// Following example creates a cluster from 2 master nodes and 2 slave nodes\n// without using cluster mode or Redis Sentinel.\nfunc ExampleNewClusterClient_manualSetup() {\n\t// clusterSlots returns cluster slots information.\n\t// It can use service like ZooKeeper to maintain configuration information\n\t// and Cluster.ReloadState to manually trigger state reloading.\n\tclusterSlots := func(ctx context.Context) ([]redis.ClusterSlot, error) {\n\t\tslots := []redis.ClusterSlot{\n\t\t\t// First node with 1 master and 1 slave.\n\t\t\t{\n\t\t\t\tStart: 0,\n\t\t\t\tEnd:   8191,\n\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\tAddr: \":7000\", // master\n\t\t\t\t}, {\n\t\t\t\t\tAddr: \":8000\", // 1st slave\n\t\t\t\t}},\n\t\t\t},\n\t\t\t// Second node with 1 master and 1 slave.\n\t\t\t{\n\t\t\t\tStart: 8192,\n\t\t\t\tEnd:   16383,\n\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\tAddr: \":7001\", // master\n\t\t\t\t}, {\n\t\t\t\t\tAddr: \":8001\", // 1st slave\n\t\t\t\t}},\n\t\t\t},\n\t\t}\n\t\treturn slots, nil\n\t}\n\n\trdb := redis.NewClusterClient(&redis.ClusterOptions{\n\t\tClusterSlots:  clusterSlots,\n\t\tRouteRandomly: true,\n\t})\n\trdb.Ping(ctx)\n\n\t// ReloadState reloads cluster state. It calls ClusterSlots func\n\t// to get cluster slots information.\n\trdb.ReloadState(ctx)\n}\n\nfunc ExampleNewRing() {\n\trdb := redis.NewRing(&redis.RingOptions{\n\t\tAddrs: map[string]string{\n\t\t\t\"shard1\": \":7000\",\n\t\t\t\"shard2\": \":7001\",\n\t\t\t\"shard3\": \":7002\",\n\t\t},\n\t})\n\trdb.Ping(ctx)\n}\n\nfunc ExampleClient() {\n\terr := rdb.Set(ctx, \"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tval, err := rdb.Get(ctx, \"key\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"key\", val)\n\n\tval2, err := rdb.Get(ctx, \"missing_key\").Result()\n\tif err == redis.Nil {\n\t\tfmt.Println(\"missing_key does not exist\")\n\t} else if err != nil {\n\t\tpanic(err)\n\t} else {\n\t\tfmt.Println(\"missing_key\", val2)\n\t}\n\t// Output: key value\n\t// missing_key does not exist\n}\n\nfunc ExampleConn_name() {\n\tconn := rdb.Conn()\n\n\terr := conn.ClientSetName(ctx, \"foobar\").Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Open other connections.\n\tfor i := 0; i < 10; i++ {\n\t\tgo rdb.Ping(ctx)\n\t}\n\n\ts, err := conn.ClientGetName(ctx).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(s)\n\t// Output: foobar\n}\n\nfunc ExampleConn_client_setInfo_libraryVersion() {\n\tconn := rdb.Conn()\n\n\terr := conn.ClientSetInfo(ctx, redis.WithLibraryVersion(\"1.2.3\")).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Open other connections.\n\tfor i := 0; i < 10; i++ {\n\t\tgo rdb.Ping(ctx)\n\t}\n\n\ts, err := conn.ClientInfo(ctx).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(s.LibVer)\n\t// Output: 1.2.3\n}\n\nfunc ExampleClient_Set() {\n\t// Last argument is expiration. Zero means the key has no\n\t// expiration time.\n\terr := rdb.Set(ctx, \"key\", \"value\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// key2 will expire in an hour.\n\terr = rdb.Set(ctx, \"key2\", \"value\", time.Hour).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleClient_SetEx() {\n\terr := rdb.SetEx(ctx, \"key\", \"value\", time.Hour).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleClient_HSet() {\n\t// Set \"redis\" tag for hash key\n\ttype ExampleUser struct {\n\t\tName string `redis:\"name\"`\n\t\tAge  int    `redis:\"age\"`\n\t}\n\n\titems := ExampleUser{\"jane\", 22}\n\n\terr := rdb.HSet(ctx, \"user:1\", items).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleClient_Incr() {\n\tresult, err := rdb.Incr(ctx, \"counter\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(result)\n\t// Output: 1\n}\n\nfunc ExampleClient_BLPop() {\n\tif err := rdb.RPush(ctx, \"queue\", \"message\").Err(); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// use `rdb.BLPop(ctx, 0, \"queue\")` for infinite waiting time\n\tresult, err := rdb.BLPop(ctx, 1*time.Second, \"queue\").Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(result[0], result[1])\n\t// Output: queue message\n}\n\nfunc ExampleClient_Scan() {\n\trdb.FlushDB(ctx)\n\tfor i := 0; i < 33; i++ {\n\t\terr := rdb.Set(ctx, fmt.Sprintf(\"key%d\", i), \"value\", 0).Err()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tvar cursor uint64\n\tvar n int\n\tfor {\n\t\tvar keys []string\n\t\tvar err error\n\t\tkeys, cursor, err = rdb.Scan(ctx, cursor, \"key*\", 10).Result()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tn += len(keys)\n\t\tif cursor == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfmt.Printf(\"found %d keys\\n\", n)\n\t// Output: found 33 keys\n}\n\nfunc ExampleClient_ScanType() {\n\trdb.FlushDB(ctx)\n\tfor i := 0; i < 33; i++ {\n\t\terr := rdb.Set(ctx, fmt.Sprintf(\"key%d\", i), \"value\", 0).Err()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tvar cursor uint64\n\tvar n int\n\tfor {\n\t\tvar keys []string\n\t\tvar err error\n\t\tkeys, cursor, err = rdb.ScanType(ctx, cursor, \"key*\", 10, \"string\").Result()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tn += len(keys)\n\t\tif cursor == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfmt.Printf(\"found %d keys\\n\", n)\n\t// Output: found 33 keys\n}\n\n// ExampleClient_ScanType_hashType uses the keyType \"hash\".\nfunc ExampleClient_ScanType_hashType() {\n\trdb.FlushDB(ctx)\n\tfor i := 0; i < 33; i++ {\n\t\terr := rdb.HSet(context.TODO(), fmt.Sprintf(\"key%d\", i), \"value\", \"foo\").Err()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tvar allKeys []string\n\tvar cursor uint64\n\tvar err error\n\n\tfor {\n\t\tvar keysFromScan []string\n\t\tkeysFromScan, cursor, err = rdb.ScanType(context.TODO(), cursor, \"key*\", 10, \"hash\").Result()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tallKeys = append(allKeys, keysFromScan...)\n\t\tif cursor == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\tfmt.Printf(\"%d keys ready for use\", len(allKeys))\n\t// Output: 33 keys ready for use\n}\n\n// ExampleMapStringStringCmd_Scan shows how to scan the results of a map fetch\n// into a struct.\nfunc ExampleMapStringStringCmd_Scan() {\n\trdb.FlushDB(ctx)\n\terr := rdb.HMSet(ctx, \"map\",\n\t\t\"name\", \"hello\",\n\t\t\"count\", 123,\n\t\t\"correct\", true).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get the map. The same approach works for HmGet().\n\tres := rdb.HGetAll(ctx, \"map\")\n\tif res.Err() != nil {\n\t\tpanic(err)\n\t}\n\n\ttype data struct {\n\t\tName    string `redis:\"name\"`\n\t\tCount   int    `redis:\"count\"`\n\t\tCorrect bool   `redis:\"correct\"`\n\t}\n\n\t// Scan the results into the struct.\n\tvar d data\n\tif err := res.Scan(&d); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(d)\n\t// Output: {hello 123 true}\n}\n\n// ExampleSliceCmd_Scan shows how to scan the results of a multi key fetch\n// into a struct.\nfunc ExampleSliceCmd_Scan() {\n\trdb.FlushDB(ctx)\n\terr := rdb.MSet(ctx,\n\t\t\"name\", \"hello\",\n\t\t\"count\", 123,\n\t\t\"correct\", true).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tres := rdb.MGet(ctx, \"name\", \"count\", \"empty\", \"correct\")\n\tif res.Err() != nil {\n\t\tpanic(err)\n\t}\n\n\ttype data struct {\n\t\tName    string `redis:\"name\"`\n\t\tCount   int    `redis:\"count\"`\n\t\tCorrect bool   `redis:\"correct\"`\n\t}\n\n\t// Scan the results into the struct.\n\tvar d data\n\tif err := res.Scan(&d); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(d)\n\t// Output: {hello 123 true}\n}\n\nfunc ExampleClient_Pipelined() {\n\tvar incr *redis.IntCmd\n\t_, err := rdb.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\tincr = pipe.Incr(ctx, \"pipelined_counter\")\n\t\tpipe.Expire(ctx, \"pipelined_counter\", time.Hour)\n\t\treturn nil\n\t})\n\tfmt.Println(incr.Val(), err)\n\t// Output: 1 <nil>\n}\n\nfunc ExampleClient_Pipeline() {\n\tpipe := rdb.Pipeline()\n\n\tincr := pipe.Incr(ctx, \"pipeline_counter\")\n\tpipe.Expire(ctx, \"pipeline_counter\", time.Hour)\n\n\t// Execute\n\t//\n\t//     INCR pipeline_counter\n\t//     EXPIRE pipeline_counts 3600\n\t//\n\t// using one rdb-server roundtrip.\n\t_, err := pipe.Exec(ctx)\n\tfmt.Println(incr.Val(), err)\n\t// Output: 1 <nil>\n}\n\nfunc ExampleClient_TxPipelined() {\n\tvar incr *redis.IntCmd\n\t_, err := rdb.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\tincr = pipe.Incr(ctx, \"tx_pipelined_counter\")\n\t\tpipe.Expire(ctx, \"tx_pipelined_counter\", time.Hour)\n\t\treturn nil\n\t})\n\tfmt.Println(incr.Val(), err)\n\t// Output: 1 <nil>\n}\n\nfunc ExampleClient_TxPipeline() {\n\tpipe := rdb.TxPipeline()\n\n\tincr := pipe.Incr(ctx, \"tx_pipeline_counter\")\n\tpipe.Expire(ctx, \"tx_pipeline_counter\", time.Hour)\n\n\t// Execute\n\t//\n\t//     MULTI\n\t//     INCR pipeline_counter\n\t//     EXPIRE pipeline_counts 3600\n\t//     EXEC\n\t//\n\t// using one rdb-server roundtrip.\n\t_, err := pipe.Exec(ctx)\n\tfmt.Println(incr.Val(), err)\n\t// Output: 1 <nil>\n}\n\nfunc ExampleClient_Watch() {\n\tconst maxRetries = 10000\n\n\t// Increment transactionally increments key using GET and SET commands.\n\tincrement := func(key string) error {\n\t\t// Transactional function.\n\t\ttxf := func(tx *redis.Tx) error {\n\t\t\t// Get current value or zero.\n\t\t\tn, err := tx.Get(ctx, key).Int()\n\t\t\tif err != nil && err != redis.Nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Actual operation (local in optimistic lock).\n\t\t\tn++\n\n\t\t\t// Operation is committed only if the watched keys remain unchanged.\n\t\t\t_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Set(ctx, key, n, 0)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\treturn err\n\t\t}\n\n\t\tfor i := 0; i < maxRetries; i++ {\n\t\t\terr := rdb.Watch(ctx, txf, key)\n\t\t\tif err == nil {\n\t\t\t\t// Success.\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif err == redis.TxFailedErr {\n\t\t\t\t// Optimistic lock lost. Retry.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Return any other error.\n\t\t\treturn err\n\t\t}\n\n\t\treturn errors.New(\"increment reached maximum number of retries\")\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\n\t\t\tif err := increment(\"counter3\"); err != nil {\n\t\t\t\tfmt.Println(\"increment error:\", err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\n\tn, err := rdb.Get(ctx, \"counter3\").Int()\n\tfmt.Println(\"ended with\", n, err)\n\t// Output: ended with 100 <nil>\n}\n\nfunc ExamplePubSub() {\n\tpubsub := rdb.Subscribe(ctx, \"mychannel1\")\n\n\t// Wait for confirmation that subscription is created before publishing anything.\n\t_, err := pubsub.Receive(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Go channel which receives messages.\n\tch := pubsub.Channel()\n\n\t// Publish a message.\n\terr = rdb.Publish(ctx, \"mychannel1\", \"hello\").Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttime.AfterFunc(time.Second, func() {\n\t\t// When pubsub is closed channel is closed too.\n\t\t_ = pubsub.Close()\n\t})\n\n\t// Consume messages.\n\tfor msg := range ch {\n\t\tfmt.Println(msg.Channel, msg.Payload)\n\t}\n\n\t// Output: mychannel1 hello\n}\n\nfunc ExamplePubSub_Receive() {\n\tpubsub := rdb.Subscribe(ctx, \"mychannel2\")\n\tdefer pubsub.Close()\n\n\tfor i := 0; i < 2; i++ {\n\t\t// ReceiveTimeout is a low level API. Use ReceiveMessage instead.\n\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\tswitch msg := msgi.(type) {\n\t\tcase *redis.Subscription:\n\t\t\tfmt.Println(\"subscribed to\", msg.Channel)\n\n\t\t\t_, err := rdb.Publish(ctx, \"mychannel2\", \"hello\").Result()\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\tcase *redis.Message:\n\t\t\tfmt.Println(\"received\", msg.Payload, \"from\", msg.Channel)\n\t\tdefault:\n\t\t\tpanic(\"unreached\")\n\t\t}\n\t}\n\n\t// sent message to 1 rdb\n\t// received hello from mychannel2\n}\n\nfunc ExampleScript() {\n\tIncrByXX := redis.NewScript(`\n\t\tif redis.call(\"GET\", KEYS[1]) ~= false then\n\t\t\treturn redis.call(\"INCRBY\", KEYS[1], ARGV[1])\n\t\tend\n\t\treturn false\n\t`)\n\n\tn, err := IncrByXX.Run(ctx, rdb, []string{\"xx_counter\"}, 2).Result()\n\tfmt.Println(n, err)\n\n\terr = rdb.Set(ctx, \"xx_counter\", \"40\", 0).Err()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tn, err = IncrByXX.Run(ctx, rdb, []string{\"xx_counter\"}, 2).Result()\n\tfmt.Println(n, err)\n\n\t// Output: <nil> redis: nil\n\t// 42 <nil>\n}\n\nfunc Example_customCommand() {\n\tGet := func(ctx context.Context, rdb *redis.Client, key string) *redis.StringCmd {\n\t\tcmd := redis.NewStringCmd(ctx, \"get\", key)\n\t\trdb.Process(ctx, cmd)\n\t\treturn cmd\n\t}\n\n\tv, err := Get(ctx, rdb, \"key_does_not_exist\").Result()\n\tfmt.Printf(\"%q %s\", v, err)\n\t// Output: \"\" redis: nil\n}\n\nfunc Example_customCommand2() {\n\tv, err := rdb.Do(ctx, \"get\", \"key_does_not_exist\").Text()\n\tfmt.Printf(\"%q %s\", v, err)\n\t// Output: \"\" redis: nil\n}\n\nfunc ExampleScanIterator() {\n\titer := rdb.Scan(ctx, 0, \"\", 0).Iterator()\n\tfor iter.Next(ctx) {\n\t\tfmt.Println(iter.Val())\n\t}\n\tif err := iter.Err(); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleScanCmd_Iterator() {\n\titer := rdb.Scan(ctx, 0, \"\", 0).Iterator()\n\tfor iter.Next(ctx) {\n\t\tfmt.Println(iter.Val())\n\t}\n\tif err := iter.Err(); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleNewUniversalClient_simple() {\n\trdb := redis.NewUniversalClient(&redis.UniversalOptions{\n\t\tAddrs: []string{\":6379\"},\n\t})\n\tdefer rdb.Close()\n\n\trdb.Ping(ctx)\n}\n\nfunc ExampleNewUniversalClient_failover() {\n\trdb := redis.NewUniversalClient(&redis.UniversalOptions{\n\t\tMasterName: \"master\",\n\t\tAddrs:      []string{\":26379\"},\n\t})\n\tdefer rdb.Close()\n\n\trdb.Ping(ctx)\n}\n\nfunc ExampleNewUniversalClient_cluster() {\n\trdb := redis.NewUniversalClient(&redis.UniversalOptions{\n\t\tAddrs: []string{\":7000\", \":7001\", \":7002\", \":7003\", \":7004\", \":7005\"},\n\t})\n\tdefer rdb.Close()\n\n\trdb.Ping(ctx)\n}\n\nfunc ExampleClient_SlowLogGet() {\n\tif RECluster {\n\t\t// skip slowlog test for cluster\n\t\tfmt.Println(2)\n\t\treturn\n\t}\n\tconst key = \"slowlog-log-slower-than\"\n\n\told := rdb.ConfigGet(ctx, key).Val()\n\trdb.ConfigSet(ctx, key, \"0\")\n\tdefer rdb.ConfigSet(ctx, key, old[key])\n\n\tif err := rdb.Do(ctx, \"slowlog\", \"reset\").Err(); err != nil {\n\t\tpanic(err)\n\t}\n\n\trdb.Set(ctx, \"test\", \"true\", 0)\n\n\tresult, err := rdb.SlowLogGet(ctx, -1).Result()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(len(result))\n\t// Output: 2\n}\n"
        },
        {
          "name": "export_test.go",
          "type": "blob",
          "size": 2.205078125,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/hashtag\"\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n)\n\nfunc (c *baseClient) Pool() pool.Pooler {\n\treturn c.connPool\n}\n\nfunc (c *PubSub) SetNetConn(netConn net.Conn) {\n\tc.cn = pool.NewConn(netConn)\n}\n\nfunc (c *ClusterClient) LoadState(ctx context.Context) (*clusterState, error) {\n\t// return c.state.Reload(ctx)\n\treturn c.loadState(ctx)\n}\n\nfunc (c *ClusterClient) SlotAddrs(ctx context.Context, slot int) []string {\n\tstate, err := c.state.Get(ctx)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar addrs []string\n\tfor _, n := range state.slotNodes(slot) {\n\t\taddrs = append(addrs, n.Client.getAddr())\n\t}\n\treturn addrs\n}\n\nfunc (c *ClusterClient) Nodes(ctx context.Context, key string) ([]*clusterNode, error) {\n\tstate, err := c.state.Reload(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tslot := hashtag.Slot(key)\n\tnodes := state.slotNodes(slot)\n\tif len(nodes) != 2 {\n\t\treturn nil, fmt.Errorf(\"slot=%d does not have enough nodes: %v\", slot, nodes)\n\t}\n\treturn nodes, nil\n}\n\nfunc (c *ClusterClient) SwapNodes(ctx context.Context, key string) error {\n\tnodes, err := c.Nodes(ctx, key)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnodes[0], nodes[1] = nodes[1], nodes[0]\n\treturn nil\n}\n\nfunc (c *clusterState) IsConsistent(ctx context.Context) bool {\n\tif len(c.Masters) < 3 {\n\t\treturn false\n\t}\n\tfor _, master := range c.Masters {\n\t\ts := master.Client.Info(ctx, \"replication\").Val()\n\t\tif !strings.Contains(s, \"role:master\") {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif len(c.Slaves) < 3 {\n\t\treturn false\n\t}\n\tfor _, slave := range c.Slaves {\n\t\ts := slave.Client.Info(ctx, \"replication\").Val()\n\t\tif !strings.Contains(s, \"role:slave\") {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc GetSlavesAddrByName(ctx context.Context, c *SentinelClient, name string) []string {\n\taddrs, err := c.Replicas(ctx, name).Result()\n\tif err != nil {\n\t\tinternal.Logger.Printf(ctx, \"sentinel: Replicas name=%q failed: %s\",\n\t\t\tname, err)\n\t\treturn []string{}\n\t}\n\treturn parseReplicaAddrs(addrs, false)\n}\n\nfunc (c *Ring) ShardByName(name string) *ringShard {\n\tshard, _ := c.sharding.GetByName(name)\n\treturn shard\n}\n\nfunc (c *ModuleLoadexConfig) ToArgs() []interface{} {\n\treturn c.toArgs()\n}\n"
        },
        {
          "name": "extra",
          "type": "tree",
          "content": null
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "gears_commands.go",
          "type": "blob",
          "size": 4.54296875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype GearsCmdable interface {\n\tTFunctionLoad(ctx context.Context, lib string) *StatusCmd\n\tTFunctionLoadArgs(ctx context.Context, lib string, options *TFunctionLoadOptions) *StatusCmd\n\tTFunctionDelete(ctx context.Context, libName string) *StatusCmd\n\tTFunctionList(ctx context.Context) *MapStringInterfaceSliceCmd\n\tTFunctionListArgs(ctx context.Context, options *TFunctionListOptions) *MapStringInterfaceSliceCmd\n\tTFCall(ctx context.Context, libName string, funcName string, numKeys int) *Cmd\n\tTFCallArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd\n\tTFCallASYNC(ctx context.Context, libName string, funcName string, numKeys int) *Cmd\n\tTFCallASYNCArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd\n}\n\ntype TFunctionLoadOptions struct {\n\tReplace bool\n\tConfig  string\n}\n\ntype TFunctionListOptions struct {\n\tWithcode bool\n\tVerbose  int\n\tLibrary  string\n}\n\ntype TFCallOptions struct {\n\tKeys      []string\n\tArguments []string\n}\n\n// TFunctionLoad - load a new JavaScript library into Redis.\n// For more information - https://redis.io/commands/tfunction-load/\nfunc (c cmdable) TFunctionLoad(ctx context.Context, lib string) *StatusCmd {\n\targs := []interface{}{\"TFUNCTION\", \"LOAD\", lib}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) TFunctionLoadArgs(ctx context.Context, lib string, options *TFunctionLoadOptions) *StatusCmd {\n\targs := []interface{}{\"TFUNCTION\", \"LOAD\"}\n\tif options != nil {\n\t\tif options.Replace {\n\t\t\targs = append(args, \"REPLACE\")\n\t\t}\n\t\tif options.Config != \"\" {\n\t\t\targs = append(args, \"CONFIG\", options.Config)\n\t\t}\n\t}\n\targs = append(args, lib)\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TFunctionDelete - delete a JavaScript library from Redis.\n// For more information - https://redis.io/commands/tfunction-delete/\nfunc (c cmdable) TFunctionDelete(ctx context.Context, libName string) *StatusCmd {\n\targs := []interface{}{\"TFUNCTION\", \"DELETE\", libName}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TFunctionList - list the functions with additional information about each function.\n// For more information - https://redis.io/commands/tfunction-list/\nfunc (c cmdable) TFunctionList(ctx context.Context) *MapStringInterfaceSliceCmd {\n\targs := []interface{}{\"TFUNCTION\", \"LIST\"}\n\tcmd := NewMapStringInterfaceSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) TFunctionListArgs(ctx context.Context, options *TFunctionListOptions) *MapStringInterfaceSliceCmd {\n\targs := []interface{}{\"TFUNCTION\", \"LIST\"}\n\tif options != nil {\n\t\tif options.Withcode {\n\t\t\targs = append(args, \"WITHCODE\")\n\t\t}\n\t\tif options.Verbose != 0 {\n\t\t\tv := strings.Repeat(\"v\", options.Verbose)\n\t\t\targs = append(args, v)\n\t\t}\n\t\tif options.Library != \"\" {\n\t\t\targs = append(args, \"LIBRARY\", options.Library)\n\t\t}\n\t}\n\tcmd := NewMapStringInterfaceSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TFCall - invoke a function.\n// For more information - https://redis.io/commands/tfcall/\nfunc (c cmdable) TFCall(ctx context.Context, libName string, funcName string, numKeys int) *Cmd {\n\tlf := libName + \".\" + funcName\n\targs := []interface{}{\"TFCALL\", lf, numKeys}\n\tcmd := NewCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) TFCallArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd {\n\tlf := libName + \".\" + funcName\n\targs := []interface{}{\"TFCALL\", lf, numKeys}\n\tif options != nil {\n\t\tfor _, key := range options.Keys {\n\t\t\targs = append(args, key)\n\t\t}\n\t\tfor _, key := range options.Arguments {\n\t\t\targs = append(args, key)\n\t\t}\n\t}\n\tcmd := NewCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TFCallASYNC - invoke an asynchronous JavaScript function (coroutine).\n// For more information - https://redis.io/commands/TFCallASYNC/\nfunc (c cmdable) TFCallASYNC(ctx context.Context, libName string, funcName string, numKeys int) *Cmd {\n\tlf := fmt.Sprintf(\"%s.%s\", libName, funcName)\n\targs := []interface{}{\"TFCALLASYNC\", lf, numKeys}\n\tcmd := NewCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) TFCallASYNCArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd {\n\tlf := fmt.Sprintf(\"%s.%s\", libName, funcName)\n\targs := []interface{}{\"TFCALLASYNC\", lf, numKeys}\n\tif options != nil {\n\t\tfor _, key := range options.Keys {\n\t\t\targs = append(args, key)\n\t\t}\n\t\tfor _, key := range options.Arguments {\n\t\t\targs = append(args, key)\n\t\t}\n\t}\n\tcmd := NewCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "gears_commands_test.go",
          "type": "blob",
          "size": 4.119140625,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nfunc libCode(libName string) string {\n\treturn fmt.Sprintf(\"#!js api_version=1.0 name=%s\\n redis.registerFunction('foo', ()=>{{return 'bar'}})\", libName)\n}\n\nfunc libCodeWithConfig(libName string) string {\n\tlib := `#!js api_version=1.0 name=%s\n\n\tvar last_update_field_name = \"__last_update__\"\n\t\n\tif (redis.config.last_update_field_name !== undefined) {\n\t\tif (typeof redis.config.last_update_field_name != 'string') {\n\t\t\tthrow \"last_update_field_name must be a string\";\n\t\t}\n\t\tlast_update_field_name = redis.config.last_update_field_name\n\t}\n\t\n\tredis.registerFunction(\"hset\", function(client, key, field, val){\n\t\t// get the current time in ms\n\t\tvar curr_time = client.call(\"time\")[0];\n\t\treturn client.call('hset', key, field, val, last_update_field_name, curr_time);\n\t});`\n\treturn fmt.Sprintf(lib, libName)\n}\n\nvar _ = Describe(\"RedisGears commands\", Label(\"gears\"), func() {\n\tctx := context.TODO()\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(&redis.Options{Addr: \":6379\"})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t\tclient.TFunctionDelete(ctx, \"lib1\")\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should TFunctionLoad, TFunctionLoadArgs and TFunctionDelete \", Label(\"gears\", \"tfunctionload\"), func() {\n\t\tresultAdd, err := client.TFunctionLoad(ctx, libCode(\"lib1\")).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"OK\"))\n\t\topt := &redis.TFunctionLoadOptions{Replace: true, Config: `{\"last_update_field_name\":\"last_update\"}`}\n\t\tresultAdd, err = client.TFunctionLoadArgs(ctx, libCodeWithConfig(\"lib1\"), opt).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"OK\"))\n\t})\n\tIt(\"should TFunctionList\", Label(\"gears\", \"tfunctionlist\"), func() {\n\t\tresultAdd, err := client.TFunctionLoad(ctx, libCode(\"lib1\")).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"OK\"))\n\t\tresultList, err := client.TFunctionList(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultList[0][\"engine\"]).To(BeEquivalentTo(\"js\"))\n\t\topt := &redis.TFunctionListOptions{Withcode: true, Verbose: 2}\n\t\tresultListArgs, err := client.TFunctionListArgs(ctx, opt).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultListArgs[0][\"code\"]).NotTo(BeEquivalentTo(\"\"))\n\t})\n\n\tIt(\"should TFCall\", Label(\"gears\", \"tfcall\"), func() {\n\t\tvar resultAdd interface{}\n\t\tresultAdd, err := client.TFunctionLoad(ctx, libCode(\"lib1\")).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"OK\"))\n\t\tresultAdd, err = client.TFCall(ctx, \"lib1\", \"foo\", 0).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"bar\"))\n\t})\n\n\tIt(\"should TFCallArgs\", Label(\"gears\", \"tfcallargs\"), func() {\n\t\tvar resultAdd interface{}\n\t\tresultAdd, err := client.TFunctionLoad(ctx, libCode(\"lib1\")).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"OK\"))\n\t\topt := &redis.TFCallOptions{Arguments: []string{\"foo\", \"bar\"}}\n\t\tresultAdd, err = client.TFCallArgs(ctx, \"lib1\", \"foo\", 0, opt).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"bar\"))\n\t})\n\n\tIt(\"should TFCallASYNC\", Label(\"gears\", \"TFCallASYNC\"), func() {\n\t\tvar resultAdd interface{}\n\t\tresultAdd, err := client.TFunctionLoad(ctx, libCode(\"lib1\")).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"OK\"))\n\t\tresultAdd, err = client.TFCallASYNC(ctx, \"lib1\", \"foo\", 0).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"bar\"))\n\t})\n\n\tIt(\"should TFCallASYNCArgs\", Label(\"gears\", \"TFCallASYNCargs\"), func() {\n\t\tvar resultAdd interface{}\n\t\tresultAdd, err := client.TFunctionLoad(ctx, libCode(\"lib1\")).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"OK\"))\n\t\topt := &redis.TFCallOptions{Arguments: []string{\"foo\", \"bar\"}}\n\t\tresultAdd, err = client.TFCallASYNCArgs(ctx, \"lib1\", \"foo\", 0, opt).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resultAdd).To(BeEquivalentTo(\"bar\"))\n\t})\n})\n"
        },
        {
          "name": "generic_commands.go",
          "type": "blob",
          "size": 10.529296875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\ntype GenericCmdable interface {\n\tDel(ctx context.Context, keys ...string) *IntCmd\n\tDump(ctx context.Context, key string) *StringCmd\n\tExists(ctx context.Context, keys ...string) *IntCmd\n\tExpire(ctx context.Context, key string, expiration time.Duration) *BoolCmd\n\tExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd\n\tExpireTime(ctx context.Context, key string) *DurationCmd\n\tExpireNX(ctx context.Context, key string, expiration time.Duration) *BoolCmd\n\tExpireXX(ctx context.Context, key string, expiration time.Duration) *BoolCmd\n\tExpireGT(ctx context.Context, key string, expiration time.Duration) *BoolCmd\n\tExpireLT(ctx context.Context, key string, expiration time.Duration) *BoolCmd\n\tKeys(ctx context.Context, pattern string) *StringSliceCmd\n\tMigrate(ctx context.Context, host, port, key string, db int, timeout time.Duration) *StatusCmd\n\tMove(ctx context.Context, key string, db int) *BoolCmd\n\tObjectFreq(ctx context.Context, key string) *IntCmd\n\tObjectRefCount(ctx context.Context, key string) *IntCmd\n\tObjectEncoding(ctx context.Context, key string) *StringCmd\n\tObjectIdleTime(ctx context.Context, key string) *DurationCmd\n\tPersist(ctx context.Context, key string) *BoolCmd\n\tPExpire(ctx context.Context, key string, expiration time.Duration) *BoolCmd\n\tPExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd\n\tPExpireTime(ctx context.Context, key string) *DurationCmd\n\tPTTL(ctx context.Context, key string) *DurationCmd\n\tRandomKey(ctx context.Context) *StringCmd\n\tRename(ctx context.Context, key, newkey string) *StatusCmd\n\tRenameNX(ctx context.Context, key, newkey string) *BoolCmd\n\tRestore(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd\n\tRestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd\n\tSort(ctx context.Context, key string, sort *Sort) *StringSliceCmd\n\tSortRO(ctx context.Context, key string, sort *Sort) *StringSliceCmd\n\tSortStore(ctx context.Context, key, store string, sort *Sort) *IntCmd\n\tSortInterfaces(ctx context.Context, key string, sort *Sort) *SliceCmd\n\tTouch(ctx context.Context, keys ...string) *IntCmd\n\tTTL(ctx context.Context, key string) *DurationCmd\n\tType(ctx context.Context, key string) *StatusCmd\n\tCopy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *IntCmd\n\n\tScan(ctx context.Context, cursor uint64, match string, count int64) *ScanCmd\n\tScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *ScanCmd\n}\n\nfunc (c cmdable) Del(ctx context.Context, keys ...string) *IntCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"del\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Unlink(ctx context.Context, keys ...string) *IntCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"unlink\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Dump(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"dump\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Exists(ctx context.Context, keys ...string) *IntCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"exists\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Expire(ctx context.Context, key string, expiration time.Duration) *BoolCmd {\n\treturn c.expire(ctx, key, expiration, \"\")\n}\n\nfunc (c cmdable) ExpireNX(ctx context.Context, key string, expiration time.Duration) *BoolCmd {\n\treturn c.expire(ctx, key, expiration, \"NX\")\n}\n\nfunc (c cmdable) ExpireXX(ctx context.Context, key string, expiration time.Duration) *BoolCmd {\n\treturn c.expire(ctx, key, expiration, \"XX\")\n}\n\nfunc (c cmdable) ExpireGT(ctx context.Context, key string, expiration time.Duration) *BoolCmd {\n\treturn c.expire(ctx, key, expiration, \"GT\")\n}\n\nfunc (c cmdable) ExpireLT(ctx context.Context, key string, expiration time.Duration) *BoolCmd {\n\treturn c.expire(ctx, key, expiration, \"LT\")\n}\n\nfunc (c cmdable) expire(\n\tctx context.Context, key string, expiration time.Duration, mode string,\n) *BoolCmd {\n\targs := make([]interface{}, 3, 4)\n\targs[0] = \"expire\"\n\targs[1] = key\n\targs[2] = formatSec(ctx, expiration)\n\tif mode != \"\" {\n\t\targs = append(args, mode)\n\t}\n\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"expireat\", key, tm.Unix())\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ExpireTime(ctx context.Context, key string) *DurationCmd {\n\tcmd := NewDurationCmd(ctx, time.Second, \"expiretime\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Keys(ctx context.Context, pattern string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"keys\", pattern)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Migrate(ctx context.Context, host, port, key string, db int, timeout time.Duration) *StatusCmd {\n\tcmd := NewStatusCmd(\n\t\tctx,\n\t\t\"migrate\",\n\t\thost,\n\t\tport,\n\t\tkey,\n\t\tdb,\n\t\tformatMs(ctx, timeout),\n\t)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Move(ctx context.Context, key string, db int) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"move\", key, db)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ObjectFreq(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"object\", \"freq\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ObjectRefCount(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"object\", \"refcount\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ObjectEncoding(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"object\", \"encoding\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ObjectIdleTime(ctx context.Context, key string) *DurationCmd {\n\tcmd := NewDurationCmd(ctx, time.Second, \"object\", \"idletime\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Persist(ctx context.Context, key string) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"persist\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PExpire(ctx context.Context, key string, expiration time.Duration) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"pexpire\", key, formatMs(ctx, expiration))\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd {\n\tcmd := NewBoolCmd(\n\t\tctx,\n\t\t\"pexpireat\",\n\t\tkey,\n\t\ttm.UnixNano()/int64(time.Millisecond),\n\t)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PExpireTime(ctx context.Context, key string) *DurationCmd {\n\tcmd := NewDurationCmd(ctx, time.Millisecond, \"pexpiretime\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PTTL(ctx context.Context, key string) *DurationCmd {\n\tcmd := NewDurationCmd(ctx, time.Millisecond, \"pttl\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RandomKey(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"randomkey\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Rename(ctx context.Context, key, newkey string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"rename\", key, newkey)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RenameNX(ctx context.Context, key, newkey string) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"renamenx\", key, newkey)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Restore(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd {\n\tcmd := NewStatusCmd(\n\t\tctx,\n\t\t\"restore\",\n\t\tkey,\n\t\tformatMs(ctx, ttl),\n\t\tvalue,\n\t)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd {\n\tcmd := NewStatusCmd(\n\t\tctx,\n\t\t\"restore\",\n\t\tkey,\n\t\tformatMs(ctx, ttl),\n\t\tvalue,\n\t\t\"replace\",\n\t)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype Sort struct {\n\tBy            string\n\tOffset, Count int64\n\tGet           []string\n\tOrder         string\n\tAlpha         bool\n}\n\nfunc (sort *Sort) args(command, key string) []interface{} {\n\targs := []interface{}{command, key}\n\n\tif sort.By != \"\" {\n\t\targs = append(args, \"by\", sort.By)\n\t}\n\tif sort.Offset != 0 || sort.Count != 0 {\n\t\targs = append(args, \"limit\", sort.Offset, sort.Count)\n\t}\n\tfor _, get := range sort.Get {\n\t\targs = append(args, \"get\", get)\n\t}\n\tif sort.Order != \"\" {\n\t\targs = append(args, sort.Order)\n\t}\n\tif sort.Alpha {\n\t\targs = append(args, \"alpha\")\n\t}\n\treturn args\n}\n\nfunc (c cmdable) SortRO(ctx context.Context, key string, sort *Sort) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, sort.args(\"sort_ro\", key)...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Sort(ctx context.Context, key string, sort *Sort) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, sort.args(\"sort\", key)...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SortStore(ctx context.Context, key, store string, sort *Sort) *IntCmd {\n\targs := sort.args(\"sort\", key)\n\tif store != \"\" {\n\t\targs = append(args, \"store\", store)\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SortInterfaces(ctx context.Context, key string, sort *Sort) *SliceCmd {\n\tcmd := NewSliceCmd(ctx, sort.args(\"sort\", key)...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Touch(ctx context.Context, keys ...string) *IntCmd {\n\targs := make([]interface{}, len(keys)+1)\n\targs[0] = \"touch\"\n\tfor i, key := range keys {\n\t\targs[i+1] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) TTL(ctx context.Context, key string) *DurationCmd {\n\tcmd := NewDurationCmd(ctx, time.Second, \"ttl\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Type(ctx context.Context, key string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"type\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Copy(ctx context.Context, sourceKey, destKey string, db int, replace bool) *IntCmd {\n\targs := []interface{}{\"copy\", sourceKey, destKey, \"DB\", db}\n\tif replace {\n\t\targs = append(args, \"REPLACE\")\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n//------------------------------------------------------------------------------\n\nfunc (c cmdable) Scan(ctx context.Context, cursor uint64, match string, count int64) *ScanCmd {\n\targs := []interface{}{\"scan\", cursor}\n\tif match != \"\" {\n\t\targs = append(args, \"match\", match)\n\t}\n\tif count > 0 {\n\t\targs = append(args, \"count\", count)\n\t}\n\tcmd := NewScanCmd(ctx, c, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *ScanCmd {\n\targs := []interface{}{\"scan\", cursor}\n\tif match != \"\" {\n\t\targs = append(args, \"match\", match)\n\t}\n\tif count > 0 {\n\t\targs = append(args, \"count\", count)\n\t}\n\tif keyType != \"\" {\n\t\targs = append(args, \"type\", keyType)\n\t}\n\tcmd := NewScanCmd(ctx, c, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "geo_commands.go",
          "type": "blob",
          "size": 4.916015625,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"errors\"\n)\n\ntype GeoCmdable interface {\n\tGeoAdd(ctx context.Context, key string, geoLocation ...*GeoLocation) *IntCmd\n\tGeoPos(ctx context.Context, key string, members ...string) *GeoPosCmd\n\tGeoRadius(ctx context.Context, key string, longitude, latitude float64, query *GeoRadiusQuery) *GeoLocationCmd\n\tGeoRadiusStore(ctx context.Context, key string, longitude, latitude float64, query *GeoRadiusQuery) *IntCmd\n\tGeoRadiusByMember(ctx context.Context, key, member string, query *GeoRadiusQuery) *GeoLocationCmd\n\tGeoRadiusByMemberStore(ctx context.Context, key, member string, query *GeoRadiusQuery) *IntCmd\n\tGeoSearch(ctx context.Context, key string, q *GeoSearchQuery) *StringSliceCmd\n\tGeoSearchLocation(ctx context.Context, key string, q *GeoSearchLocationQuery) *GeoSearchLocationCmd\n\tGeoSearchStore(ctx context.Context, key, store string, q *GeoSearchStoreQuery) *IntCmd\n\tGeoDist(ctx context.Context, key string, member1, member2, unit string) *FloatCmd\n\tGeoHash(ctx context.Context, key string, members ...string) *StringSliceCmd\n}\n\nfunc (c cmdable) GeoAdd(ctx context.Context, key string, geoLocation ...*GeoLocation) *IntCmd {\n\targs := make([]interface{}, 2+3*len(geoLocation))\n\targs[0] = \"geoadd\"\n\targs[1] = key\n\tfor i, eachLoc := range geoLocation {\n\t\targs[2+3*i] = eachLoc.Longitude\n\t\targs[2+3*i+1] = eachLoc.Latitude\n\t\targs[2+3*i+2] = eachLoc.Name\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// GeoRadius is a read-only GEORADIUS_RO command.\nfunc (c cmdable) GeoRadius(\n\tctx context.Context, key string, longitude, latitude float64, query *GeoRadiusQuery,\n) *GeoLocationCmd {\n\tcmd := NewGeoLocationCmd(ctx, query, \"georadius_ro\", key, longitude, latitude)\n\tif query.Store != \"\" || query.StoreDist != \"\" {\n\t\tcmd.SetErr(errors.New(\"GeoRadius does not support Store or StoreDist\"))\n\t\treturn cmd\n\t}\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// GeoRadiusStore is a writing GEORADIUS command.\nfunc (c cmdable) GeoRadiusStore(\n\tctx context.Context, key string, longitude, latitude float64, query *GeoRadiusQuery,\n) *IntCmd {\n\targs := geoLocationArgs(query, \"georadius\", key, longitude, latitude)\n\tcmd := NewIntCmd(ctx, args...)\n\tif query.Store == \"\" && query.StoreDist == \"\" {\n\t\tcmd.SetErr(errors.New(\"GeoRadiusStore requires Store or StoreDist\"))\n\t\treturn cmd\n\t}\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// GeoRadiusByMember is a read-only GEORADIUSBYMEMBER_RO command.\nfunc (c cmdable) GeoRadiusByMember(\n\tctx context.Context, key, member string, query *GeoRadiusQuery,\n) *GeoLocationCmd {\n\tcmd := NewGeoLocationCmd(ctx, query, \"georadiusbymember_ro\", key, member)\n\tif query.Store != \"\" || query.StoreDist != \"\" {\n\t\tcmd.SetErr(errors.New(\"GeoRadiusByMember does not support Store or StoreDist\"))\n\t\treturn cmd\n\t}\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// GeoRadiusByMemberStore is a writing GEORADIUSBYMEMBER command.\nfunc (c cmdable) GeoRadiusByMemberStore(\n\tctx context.Context, key, member string, query *GeoRadiusQuery,\n) *IntCmd {\n\targs := geoLocationArgs(query, \"georadiusbymember\", key, member)\n\tcmd := NewIntCmd(ctx, args...)\n\tif query.Store == \"\" && query.StoreDist == \"\" {\n\t\tcmd.SetErr(errors.New(\"GeoRadiusByMemberStore requires Store or StoreDist\"))\n\t\treturn cmd\n\t}\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GeoSearch(ctx context.Context, key string, q *GeoSearchQuery) *StringSliceCmd {\n\targs := make([]interface{}, 0, 13)\n\targs = append(args, \"geosearch\", key)\n\targs = geoSearchArgs(q, args)\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GeoSearchLocation(\n\tctx context.Context, key string, q *GeoSearchLocationQuery,\n) *GeoSearchLocationCmd {\n\targs := make([]interface{}, 0, 16)\n\targs = append(args, \"geosearch\", key)\n\targs = geoSearchLocationArgs(q, args)\n\tcmd := NewGeoSearchLocationCmd(ctx, q, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GeoSearchStore(ctx context.Context, key, store string, q *GeoSearchStoreQuery) *IntCmd {\n\targs := make([]interface{}, 0, 15)\n\targs = append(args, \"geosearchstore\", store, key)\n\targs = geoSearchArgs(&q.GeoSearchQuery, args)\n\tif q.StoreDist {\n\t\targs = append(args, \"storedist\")\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GeoDist(\n\tctx context.Context, key string, member1, member2, unit string,\n) *FloatCmd {\n\tif unit == \"\" {\n\t\tunit = \"km\"\n\t}\n\tcmd := NewFloatCmd(ctx, \"geodist\", key, member1, member2, unit)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GeoHash(ctx context.Context, key string, members ...string) *StringSliceCmd {\n\targs := make([]interface{}, 2+len(members))\n\targs[0] = \"geohash\"\n\targs[1] = key\n\tfor i, member := range members {\n\t\targs[2+i] = member\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GeoPos(ctx context.Context, key string, members ...string) *GeoPosCmd {\n\targs := make([]interface{}, 2+len(members))\n\targs[0] = \"geopos\"\n\targs[1] = key\n\tfor i, member := range members {\n\t\targs[2+i] = member\n\t}\n\tcmd := NewGeoPosCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4033203125,
          "content": "module github.com/redis/go-redis/v9\n\ngo 1.18\n\nrequire (\n\tgithub.com/bsm/ginkgo/v2 v2.12.0\n\tgithub.com/bsm/gomega v1.27.10\n\tgithub.com/cespare/xxhash/v2 v2.2.0\n\tgithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f\n)\n\nretract (\n\tv9.5.4 // This version was accidentally released. Please use version 9.6.0 instead.\n\tv9.5.3 // This version was accidentally released. Please use version 9.6.0 instead.\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.73046875,
          "content": "github.com/bsm/ginkgo/v2 v2.12.0 h1:Ny8MWAHyOepLGlLKYmXG4IEkioBysk6GpaRTLC8zwWs=\ngithub.com/bsm/ginkgo/v2 v2.12.0/go.mod h1:SwYbGRRDovPVboqFv0tPTcG1sN61LM1Z4ARdbAV9g4c=\ngithub.com/bsm/gomega v1.27.10 h1:yeMWxP2pV2fG3FgAODIY8EiRE3dy0aeFYt4l7wh6yKA=\ngithub.com/bsm/gomega v1.27.10/go.mod h1:JyEr/xRbxbtgWNi8tIEVPUYZ5Dzef52k01W3YH0H+O0=\ngithub.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=\ngithub.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=\n"
        },
        {
          "name": "hash_commands.go",
          "type": "blob",
          "size": 16.8544921875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\ntype HashCmdable interface {\n\tHDel(ctx context.Context, key string, fields ...string) *IntCmd\n\tHExists(ctx context.Context, key, field string) *BoolCmd\n\tHGet(ctx context.Context, key, field string) *StringCmd\n\tHGetAll(ctx context.Context, key string) *MapStringStringCmd\n\tHIncrBy(ctx context.Context, key, field string, incr int64) *IntCmd\n\tHIncrByFloat(ctx context.Context, key, field string, incr float64) *FloatCmd\n\tHKeys(ctx context.Context, key string) *StringSliceCmd\n\tHLen(ctx context.Context, key string) *IntCmd\n\tHMGet(ctx context.Context, key string, fields ...string) *SliceCmd\n\tHSet(ctx context.Context, key string, values ...interface{}) *IntCmd\n\tHMSet(ctx context.Context, key string, values ...interface{}) *BoolCmd\n\tHSetNX(ctx context.Context, key, field string, value interface{}) *BoolCmd\n\tHScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd\n\tHScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd\n\tHVals(ctx context.Context, key string) *StringSliceCmd\n\tHRandField(ctx context.Context, key string, count int) *StringSliceCmd\n\tHRandFieldWithValues(ctx context.Context, key string, count int) *KeyValueSliceCmd\n\tHExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd\n\tHExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd\n\tHPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd\n\tHPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd\n\tHExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd\n\tHExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd\n\tHPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd\n\tHPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd\n\tHPersist(ctx context.Context, key string, fields ...string) *IntSliceCmd\n\tHExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd\n\tHPExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd\n\tHTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd\n\tHPTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd\n}\n\nfunc (c cmdable) HDel(ctx context.Context, key string, fields ...string) *IntCmd {\n\targs := make([]interface{}, 2+len(fields))\n\targs[0] = \"hdel\"\n\targs[1] = key\n\tfor i, field := range fields {\n\t\targs[2+i] = field\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HExists(ctx context.Context, key, field string) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"hexists\", key, field)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HGet(ctx context.Context, key, field string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"hget\", key, field)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HGetAll(ctx context.Context, key string) *MapStringStringCmd {\n\tcmd := NewMapStringStringCmd(ctx, \"hgetall\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HIncrBy(ctx context.Context, key, field string, incr int64) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"hincrby\", key, field, incr)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HIncrByFloat(ctx context.Context, key, field string, incr float64) *FloatCmd {\n\tcmd := NewFloatCmd(ctx, \"hincrbyfloat\", key, field, incr)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HKeys(ctx context.Context, key string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"hkeys\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HLen(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"hlen\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HMGet returns the values for the specified fields in the hash stored at key.\n// It returns an interface{} to distinguish between empty string and nil value.\nfunc (c cmdable) HMGet(ctx context.Context, key string, fields ...string) *SliceCmd {\n\targs := make([]interface{}, 2+len(fields))\n\targs[0] = \"hmget\"\n\targs[1] = key\n\tfor i, field := range fields {\n\t\targs[2+i] = field\n\t}\n\tcmd := NewSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HSet accepts values in following formats:\n//\n//   - HSet(\"myhash\", \"key1\", \"value1\", \"key2\", \"value2\")\n//\n//   - HSet(\"myhash\", []string{\"key1\", \"value1\", \"key2\", \"value2\"})\n//\n//   - HSet(\"myhash\", map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"})\n//\n//     Playing struct With \"redis\" tag.\n//     type MyHash struct { Key1 string `redis:\"key1\"`; Key2 int `redis:\"key2\"` }\n//\n//   - HSet(\"myhash\", MyHash{\"value1\", \"value2\"}) Warn: redis-server >= 4.0\n//\n//     For struct, can be a structure pointer type, we only parse the field whose tag is redis.\n//     if you don't want the field to be read, you can use the `redis:\"-\"` flag to ignore it,\n//     or you don't need to set the redis tag.\n//     For the type of structure field, we only support simple data types:\n//     string, int/uint(8,16,32,64), float(32,64), time.Time(to RFC3339Nano), time.Duration(to Nanoseconds ),\n//     if you are other more complex or custom data types, please implement the encoding.BinaryMarshaler interface.\n//\n// Note that in older versions of Redis server(redis-server < 4.0), HSet only supports a single key-value pair.\n// redis-docs: https://redis.io/commands/hset (Starting with Redis version 4.0.0: Accepts multiple field and value arguments.)\n// If you are using a Struct type and the number of fields is greater than one,\n// you will receive an error similar to \"ERR wrong number of arguments\", you can use HMSet as a substitute.\nfunc (c cmdable) HSet(ctx context.Context, key string, values ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"hset\"\n\targs[1] = key\n\targs = appendArgs(args, values)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HMSet is a deprecated version of HSet left for compatibility with Redis 3.\nfunc (c cmdable) HMSet(ctx context.Context, key string, values ...interface{}) *BoolCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"hmset\"\n\targs[1] = key\n\targs = appendArgs(args, values)\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HSetNX(ctx context.Context, key, field string, value interface{}) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"hsetnx\", key, field, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HVals(ctx context.Context, key string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"hvals\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HRandField redis-server version >= 6.2.0.\nfunc (c cmdable) HRandField(ctx context.Context, key string, count int) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"hrandfield\", key, count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HRandFieldWithValues redis-server version >= 6.2.0.\nfunc (c cmdable) HRandFieldWithValues(ctx context.Context, key string, count int) *KeyValueSliceCmd {\n\tcmd := NewKeyValueSliceCmd(ctx, \"hrandfield\", key, count, \"withvalues\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {\n\targs := []interface{}{\"hscan\", key, cursor}\n\tif match != \"\" {\n\t\targs = append(args, \"match\", match)\n\t}\n\tif count > 0 {\n\t\targs = append(args, \"count\", count)\n\t}\n\tcmd := NewScanCmd(ctx, c, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {\n\targs := []interface{}{\"hscan\", key, cursor}\n\tif match != \"\" {\n\t\targs = append(args, \"match\", match)\n\t}\n\tif count > 0 {\n\t\targs = append(args, \"count\", count)\n\t}\n\targs = append(args, \"novalues\")\n\tcmd := NewScanCmd(ctx, c, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype HExpireArgs struct {\n\tNX bool\n\tXX bool\n\tGT bool\n\tLT bool\n}\n\n// HExpire - Sets the expiration time for specified fields in a hash in seconds.\n// The command constructs an argument list starting with \"HEXPIRE\", followed by the key, duration, any conditional flags, and the specified fields.\n// For more information - https://redis.io/commands/hexpire/\nfunc (c cmdable) HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HEXPIRE\", key, formatSec(ctx, expiration), \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HExpire - Sets the expiration time for specified fields in a hash in seconds.\n// It requires a key, an expiration duration, a struct with boolean flags for conditional expiration settings (NX, XX, GT, LT), and a list of fields.\n// The command constructs an argument list starting with \"HEXPIRE\", followed by the key, duration, any conditional flags, and the specified fields.\n// For more information - https://redis.io/commands/hexpire/\nfunc (c cmdable) HExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HEXPIRE\", key, formatSec(ctx, expiration)}\n\n\t// only if one argument is true, we can add it to the args\n\t// if more than one argument is true, it will cause an error\n\tif expirationArgs.NX {\n\t\targs = append(args, \"NX\")\n\t} else if expirationArgs.XX {\n\t\targs = append(args, \"XX\")\n\t} else if expirationArgs.GT {\n\t\targs = append(args, \"GT\")\n\t} else if expirationArgs.LT {\n\t\targs = append(args, \"LT\")\n\t}\n\n\targs = append(args, \"FIELDS\", len(fields))\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HPExpire - Sets the expiration time for specified fields in a hash in milliseconds.\n// Similar to HExpire, it accepts a key, an expiration duration in milliseconds, a struct with expiration condition flags, and a list of fields.\n// The command modifies the standard time.Duration to milliseconds for the Redis command.\n// For more information - https://redis.io/commands/hpexpire/\nfunc (c cmdable) HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HPEXPIRE\", key, formatMs(ctx, expiration), \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HPEXPIRE\", key, formatMs(ctx, expiration)}\n\n\t// only if one argument is true, we can add it to the args\n\t// if more than one argument is true, it will cause an error\n\tif expirationArgs.NX {\n\t\targs = append(args, \"NX\")\n\t} else if expirationArgs.XX {\n\t\targs = append(args, \"XX\")\n\t} else if expirationArgs.GT {\n\t\targs = append(args, \"GT\")\n\t} else if expirationArgs.LT {\n\t\targs = append(args, \"LT\")\n\t}\n\n\targs = append(args, \"FIELDS\", len(fields))\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HExpireAt - Sets the expiration time for specified fields in a hash to a UNIX timestamp in seconds.\n// Takes a key, a UNIX timestamp, a struct of conditional flags, and a list of fields.\n// The command sets absolute expiration times based on the UNIX timestamp provided.\n// For more information - https://redis.io/commands/hexpireat/\nfunc (c cmdable) HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd {\n\n\targs := []interface{}{\"HEXPIREAT\", key, tm.Unix(), \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HEXPIREAT\", key, tm.Unix()}\n\n\t// only if one argument is true, we can add it to the args\n\t// if more than one argument is true, it will cause an error\n\tif expirationArgs.NX {\n\t\targs = append(args, \"NX\")\n\t} else if expirationArgs.XX {\n\t\targs = append(args, \"XX\")\n\t} else if expirationArgs.GT {\n\t\targs = append(args, \"GT\")\n\t} else if expirationArgs.LT {\n\t\targs = append(args, \"LT\")\n\t}\n\n\targs = append(args, \"FIELDS\", len(fields))\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HPExpireAt - Sets the expiration time for specified fields in a hash to a UNIX timestamp in milliseconds.\n// Similar to HExpireAt but for timestamps in milliseconds. It accepts the same parameters and adjusts the UNIX time to milliseconds.\n// For more information - https://redis.io/commands/hpexpireat/\nfunc (c cmdable) HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HPEXPIREAT\", key, tm.UnixNano() / int64(time.Millisecond), \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) HPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HPEXPIREAT\", key, tm.UnixNano() / int64(time.Millisecond)}\n\n\t// only if one argument is true, we can add it to the args\n\t// if more than one argument is true, it will cause an error\n\tif expirationArgs.NX {\n\t\targs = append(args, \"NX\")\n\t} else if expirationArgs.XX {\n\t\targs = append(args, \"XX\")\n\t} else if expirationArgs.GT {\n\t\targs = append(args, \"GT\")\n\t} else if expirationArgs.LT {\n\t\targs = append(args, \"LT\")\n\t}\n\n\targs = append(args, \"FIELDS\", len(fields))\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HPersist - Removes the expiration time from specified fields in a hash.\n// Accepts a key and the fields themselves.\n// This command ensures that each field specified will have its expiration removed if present.\n// For more information - https://redis.io/commands/hpersist/\nfunc (c cmdable) HPersist(ctx context.Context, key string, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HPERSIST\", key, \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HExpireTime - Retrieves the expiration time for specified fields in a hash as a UNIX timestamp in seconds.\n// Requires a key and the fields themselves to fetch their expiration timestamps.\n// This command returns the expiration times for each field or error/status codes for each field as specified.\n// For more information - https://redis.io/commands/hexpiretime/\nfunc (c cmdable) HExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HEXPIRETIME\", key, \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HPExpireTime - Retrieves the expiration time for specified fields in a hash as a UNIX timestamp in milliseconds.\n// Similar to HExpireTime, adjusted for timestamps in milliseconds. It requires the same parameters.\n// Provides the expiration timestamp for each field in milliseconds.\n// For more information - https://redis.io/commands/hexpiretime/\nfunc (c cmdable) HPExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HPEXPIRETIME\", key, \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HTTL - Retrieves the remaining time to live for specified fields in a hash in seconds.\n// Requires a key and the fields themselves. It returns the TTL for each specified field.\n// This command fetches the TTL in seconds for each field or returns error/status codes as appropriate.\n// For more information - https://redis.io/commands/httl/\nfunc (c cmdable) HTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HTTL\", key, \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// HPTTL - Retrieves the remaining time to live for specified fields in a hash in milliseconds.\n// Similar to HTTL, but returns the TTL in milliseconds. It requires a key and the specified fields.\n// This command provides the TTL in milliseconds for each field or returns error/status codes as needed.\n// For more information - https://redis.io/commands/hpttl/\nfunc (c cmdable) HPTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd {\n\targs := []interface{}{\"HPTTL\", key, \"FIELDS\", len(fields)}\n\n\tfor _, field := range fields {\n\t\targs = append(args, field)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "hyperloglog_commands.go",
          "type": "blob",
          "size": 1.02734375,
          "content": "package redis\n\nimport \"context\"\n\ntype HyperLogLogCmdable interface {\n\tPFAdd(ctx context.Context, key string, els ...interface{}) *IntCmd\n\tPFCount(ctx context.Context, keys ...string) *IntCmd\n\tPFMerge(ctx context.Context, dest string, keys ...string) *StatusCmd\n}\n\nfunc (c cmdable) PFAdd(ctx context.Context, key string, els ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(els))\n\targs[0] = \"pfadd\"\n\targs[1] = key\n\targs = appendArgs(args, els)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PFCount(ctx context.Context, keys ...string) *IntCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"pfcount\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PFMerge(ctx context.Context, dest string, keys ...string) *StatusCmd {\n\targs := make([]interface{}, 2+len(keys))\n\targs[0] = \"pfmerge\"\n\targs[1] = dest\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal_test.go",
          "type": "blob",
          "size": 7.712890625,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n)\n\nvar _ = Describe(\"newClusterState\", func() {\n\tvar state *clusterState\n\n\tcreateClusterState := func(slots []ClusterSlot) *clusterState {\n\t\topt := &ClusterOptions{}\n\t\topt.init()\n\t\tnodes := newClusterNodes(opt)\n\t\tstate, err := newClusterState(nodes, slots, \"10.10.10.10:1234\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\treturn state\n\t}\n\n\tDescribe(\"sorting\", func() {\n\t\tBeforeEach(func() {\n\t\t\tstate = createClusterState([]ClusterSlot{{\n\t\t\t\tStart: 1000,\n\t\t\t\tEnd:   1999,\n\t\t\t}, {\n\t\t\t\tStart: 0,\n\t\t\t\tEnd:   999,\n\t\t\t}, {\n\t\t\t\tStart: 2000,\n\t\t\t\tEnd:   2999,\n\t\t\t}})\n\t\t})\n\n\t\tIt(\"sorts slots\", func() {\n\t\t\tExpect(state.slots).To(Equal([]*clusterSlot{\n\t\t\t\t{start: 0, end: 999, nodes: nil},\n\t\t\t\t{start: 1000, end: 1999, nodes: nil},\n\t\t\t\t{start: 2000, end: 2999, nodes: nil},\n\t\t\t}))\n\t\t})\n\t})\n\n\tDescribe(\"loopback\", func() {\n\t\tBeforeEach(func() {\n\t\t\tstate = createClusterState([]ClusterSlot{{\n\t\t\t\tNodes: []ClusterNode{{Addr: \"127.0.0.1:7001\"}},\n\t\t\t}, {\n\t\t\t\tNodes: []ClusterNode{{Addr: \"127.0.0.1:7002\"}},\n\t\t\t}, {\n\t\t\t\tNodes: []ClusterNode{{Addr: \"1.2.3.4:1234\"}},\n\t\t\t}, {\n\t\t\t\tNodes: []ClusterNode{{Addr: \":1234\"}},\n\t\t\t}})\n\t\t})\n\n\t\tIt(\"replaces loopback hosts in addresses\", func() {\n\t\t\tslotAddr := func(slot *clusterSlot) string {\n\t\t\t\treturn slot.nodes[0].Client.Options().Addr\n\t\t\t}\n\n\t\t\tExpect(slotAddr(state.slots[0])).To(Equal(\"10.10.10.10:7001\"))\n\t\t\tExpect(slotAddr(state.slots[1])).To(Equal(\"10.10.10.10:7002\"))\n\t\t\tExpect(slotAddr(state.slots[2])).To(Equal(\"1.2.3.4:1234\"))\n\t\t\tExpect(slotAddr(state.slots[3])).To(Equal(\":1234\"))\n\t\t})\n\t})\n})\n\ntype fixedHash string\n\nfunc (h fixedHash) Get(string) string {\n\treturn string(h)\n}\n\nfunc TestRingSetAddrsAndRebalanceRace(t *testing.T) {\n\tconst (\n\t\tringShard1Name = \"ringShardOne\"\n\t\tringShard2Name = \"ringShardTwo\"\n\n\t\tringShard1Port = \"6390\"\n\t\tringShard2Port = \"6391\"\n\t)\n\n\tring := NewRing(&RingOptions{\n\t\tAddrs: map[string]string{\n\t\t\tringShard1Name: \":\" + ringShard1Port,\n\t\t},\n\t\t// Disable heartbeat\n\t\tHeartbeatFrequency: 1 * time.Hour,\n\t\tNewConsistentHash: func(shards []string) ConsistentHash {\n\t\t\tswitch len(shards) {\n\t\t\tcase 1:\n\t\t\t\treturn fixedHash(ringShard1Name)\n\t\t\tcase 2:\n\t\t\t\treturn fixedHash(ringShard2Name)\n\t\t\tdefault:\n\t\t\t\tt.Fatalf(\"Unexpected number of shards: %v\", shards)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t},\n\t})\n\tdefer ring.Close()\n\n\t// Continuously update addresses by adding and removing one address\n\tupdatesDone := make(chan struct{})\n\tdefer func() { close(updatesDone) }()\n\tgo func() {\n\t\tfor i := 0; ; i++ {\n\t\t\tselect {\n\t\t\tcase <-updatesDone:\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tif i%2 == 0 {\n\t\t\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\t\t\tringShard1Name: \":\" + ringShard1Port,\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\t\t\tringShard1Name: \":\" + ringShard1Port,\n\t\t\t\t\t\tringShard2Name: \":\" + ringShard2Port,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\ttimer := time.NewTimer(1 * time.Second)\n\tfor running := true; running; {\n\t\tselect {\n\t\tcase <-timer.C:\n\t\t\trunning = false\n\t\tdefault:\n\t\t\tshard, err := ring.sharding.GetByKey(\"whatever\")\n\t\t\tif err == nil && shard == nil {\n\t\t\t\tt.Fatal(\"shard is nil\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc BenchmarkRingShardingRebalanceLocked(b *testing.B) {\n\topts := &RingOptions{\n\t\tAddrs: make(map[string]string),\n\t\t// Disable heartbeat\n\t\tHeartbeatFrequency: 1 * time.Hour,\n\t}\n\tfor i := 0; i < 100; i++ {\n\t\topts.Addrs[fmt.Sprintf(\"shard%d\", i)] = fmt.Sprintf(\":63%02d\", i)\n\t}\n\n\tring := NewRing(opts)\n\tdefer ring.Close()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tring.sharding.rebalanceLocked()\n\t}\n}\n\ntype testCounter struct {\n\tmu sync.Mutex\n\tt  *testing.T\n\tm  map[string]int\n}\n\nfunc newTestCounter(t *testing.T) *testCounter {\n\treturn &testCounter{t: t, m: make(map[string]int)}\n}\n\nfunc (ct *testCounter) increment(key string) {\n\tct.mu.Lock()\n\tdefer ct.mu.Unlock()\n\tct.m[key]++\n}\n\nfunc (ct *testCounter) expect(values map[string]int) {\n\tct.mu.Lock()\n\tdefer ct.mu.Unlock()\n\tct.t.Helper()\n\tif !reflect.DeepEqual(values, ct.m) {\n\t\tct.t.Errorf(\"expected %v != actual %v\", values, ct.m)\n\t}\n}\n\nfunc TestRingShardsCleanup(t *testing.T) {\n\tconst (\n\t\tringShard1Name = \"ringShardOne\"\n\t\tringShard2Name = \"ringShardTwo\"\n\n\t\tringShard1Addr = \"shard1.test\"\n\t\tringShard2Addr = \"shard2.test\"\n\t)\n\n\tt.Run(\"closes unused shards\", func(t *testing.T) {\n\t\tcloseCounter := newTestCounter(t)\n\n\t\tring := NewRing(&RingOptions{\n\t\t\tAddrs: map[string]string{\n\t\t\t\tringShard1Name: ringShard1Addr,\n\t\t\t\tringShard2Name: ringShard2Addr,\n\t\t\t},\n\t\t\tNewClient: func(opt *Options) *Client {\n\t\t\t\tc := NewClient(opt)\n\t\t\t\tc.baseClient.onClose = func() error {\n\t\t\t\t\tcloseCounter.increment(opt.Addr)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn c\n\t\t\t},\n\t\t})\n\t\tcloseCounter.expect(map[string]int{})\n\n\t\t// no change due to the same addresses\n\t\tring.SetAddrs(map[string]string{\n\t\t\tringShard1Name: ringShard1Addr,\n\t\t\tringShard2Name: ringShard2Addr,\n\t\t})\n\t\tcloseCounter.expect(map[string]int{})\n\n\t\tring.SetAddrs(map[string]string{\n\t\t\tringShard1Name: ringShard1Addr,\n\t\t})\n\t\tcloseCounter.expect(map[string]int{ringShard2Addr: 1})\n\n\t\tring.SetAddrs(map[string]string{\n\t\t\tringShard2Name: ringShard2Addr,\n\t\t})\n\t\tcloseCounter.expect(map[string]int{ringShard1Addr: 1, ringShard2Addr: 1})\n\n\t\tring.Close()\n\t\tcloseCounter.expect(map[string]int{ringShard1Addr: 1, ringShard2Addr: 2})\n\t})\n\n\tt.Run(\"closes created shards if ring was closed\", func(t *testing.T) {\n\t\tcreateCounter := newTestCounter(t)\n\t\tcloseCounter := newTestCounter(t)\n\n\t\tvar (\n\t\t\tring        *Ring\n\t\t\tshouldClose int32\n\t\t)\n\n\t\tring = NewRing(&RingOptions{\n\t\t\tAddrs: map[string]string{\n\t\t\t\tringShard1Name: ringShard1Addr,\n\t\t\t},\n\t\t\tNewClient: func(opt *Options) *Client {\n\t\t\t\tif atomic.LoadInt32(&shouldClose) != 0 {\n\t\t\t\t\tring.Close()\n\t\t\t\t}\n\t\t\t\tcreateCounter.increment(opt.Addr)\n\t\t\t\tc := NewClient(opt)\n\t\t\t\tc.baseClient.onClose = func() error {\n\t\t\t\t\tcloseCounter.increment(opt.Addr)\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t\treturn c\n\t\t\t},\n\t\t})\n\t\tcreateCounter.expect(map[string]int{ringShard1Addr: 1})\n\t\tcloseCounter.expect(map[string]int{})\n\n\t\tatomic.StoreInt32(&shouldClose, 1)\n\n\t\tring.SetAddrs(map[string]string{\n\t\t\tringShard2Name: ringShard2Addr,\n\t\t})\n\t\tcreateCounter.expect(map[string]int{ringShard1Addr: 1, ringShard2Addr: 1})\n\t\tcloseCounter.expect(map[string]int{ringShard1Addr: 1, ringShard2Addr: 1})\n\t})\n}\n\n//------------------------------------------------------------------------------\n\ntype timeoutErr struct {\n\terror\n}\n\nfunc (e timeoutErr) Timeout() bool {\n\treturn true\n}\n\nfunc (e timeoutErr) Temporary() bool {\n\treturn true\n}\n\nfunc (e timeoutErr) Error() string {\n\treturn \"i/o timeout\"\n}\n\nvar _ = Describe(\"withConn\", func() {\n\tvar client *Client\n\n\tBeforeEach(func() {\n\t\tclient = NewClient(&Options{\n\t\t\tPoolSize: 1,\n\t\t})\n\t})\n\n\tAfterEach(func() {\n\t\tclient.Close()\n\t})\n\n\tIt(\"should replace the connection in the pool when there is no error\", func() {\n\t\tvar conn *pool.Conn\n\n\t\tclient.withConn(ctx, func(ctx context.Context, c *pool.Conn) error {\n\t\t\tconn = c\n\t\t\treturn nil\n\t\t})\n\n\t\tnewConn, err := client.connPool.Get(ctx)\n\t\tExpect(err).To(BeNil())\n\t\tExpect(newConn).To(Equal(conn))\n\t})\n\n\tIt(\"should replace the connection in the pool when there is an error not related to a bad connection\", func() {\n\t\tvar conn *pool.Conn\n\n\t\tclient.withConn(ctx, func(ctx context.Context, c *pool.Conn) error {\n\t\t\tconn = c\n\t\t\treturn proto.RedisError(\"LOADING\")\n\t\t})\n\n\t\tnewConn, err := client.connPool.Get(ctx)\n\t\tExpect(err).To(BeNil())\n\t\tExpect(newConn).To(Equal(conn))\n\t})\n\n\tIt(\"should remove the connection from the pool when it times out\", func() {\n\t\tvar conn *pool.Conn\n\n\t\tclient.withConn(ctx, func(ctx context.Context, c *pool.Conn) error {\n\t\t\tconn = c\n\t\t\treturn timeoutErr{}\n\t\t})\n\n\t\tnewConn, err := client.connPool.Get(ctx)\n\t\tExpect(err).To(BeNil())\n\t\tExpect(newConn).NotTo(Equal(conn))\n\t\tExpect(client.connPool.Len()).To(Equal(1))\n\t})\n})\n"
        },
        {
          "name": "iterator.go",
          "type": "blob",
          "size": 1.2490234375,
          "content": "package redis\n\nimport (\n\t\"context\"\n)\n\n// ScanIterator is used to incrementally iterate over a collection of elements.\ntype ScanIterator struct {\n\tcmd *ScanCmd\n\tpos int\n}\n\n// Err returns the last iterator error, if any.\nfunc (it *ScanIterator) Err() error {\n\treturn it.cmd.Err()\n}\n\n// Next advances the cursor and returns true if more values can be read.\nfunc (it *ScanIterator) Next(ctx context.Context) bool {\n\t// Instantly return on errors.\n\tif it.cmd.Err() != nil {\n\t\treturn false\n\t}\n\n\t// Advance cursor, check if we are still within range.\n\tif it.pos < len(it.cmd.page) {\n\t\tit.pos++\n\t\treturn true\n\t}\n\n\tfor {\n\t\t// Return if there is no more data to fetch.\n\t\tif it.cmd.cursor == 0 {\n\t\t\treturn false\n\t\t}\n\n\t\t// Fetch next page.\n\t\tswitch it.cmd.args[0] {\n\t\tcase \"scan\", \"qscan\":\n\t\t\tit.cmd.args[1] = it.cmd.cursor\n\t\tdefault:\n\t\t\tit.cmd.args[2] = it.cmd.cursor\n\t\t}\n\n\t\terr := it.cmd.process(ctx, it.cmd)\n\t\tif err != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tit.pos = 1\n\n\t\t// Redis can occasionally return empty page.\n\t\tif len(it.cmd.page) > 0 {\n\t\t\treturn true\n\t\t}\n\t}\n}\n\n// Val returns the key/field at the current cursor position.\nfunc (it *ScanIterator) Val() string {\n\tvar v string\n\tif it.cmd.Err() == nil && it.pos > 0 && it.pos <= len(it.cmd.page) {\n\t\tv = it.cmd.page[it.pos-1]\n\t}\n\treturn v\n}\n"
        },
        {
          "name": "iterator_test.go",
          "type": "blob",
          "size": 3.7724609375,
          "content": "package redis_test\n\nimport (\n\t\"fmt\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"ScanIterator\", func() {\n\tvar client *redis.Client\n\n\tseed := func(n int) error {\n\t\tpipe := client.Pipeline()\n\t\tfor i := 1; i <= n; i++ {\n\t\t\tpipe.Set(ctx, fmt.Sprintf(\"K%02d\", i), \"x\", 0).Err()\n\t\t}\n\t\t_, err := pipe.Exec(ctx)\n\t\treturn err\n\t}\n\n\textraSeed := func(n int, m int) error {\n\t\tpipe := client.Pipeline()\n\t\tfor i := 1; i <= m; i++ {\n\t\t\tpipe.Set(ctx, fmt.Sprintf(\"A%02d\", i), \"x\", 0).Err()\n\t\t}\n\t\tfor i := 1; i <= n; i++ {\n\t\t\tpipe.Set(ctx, fmt.Sprintf(\"K%02d\", i), \"x\", 0).Err()\n\t\t}\n\t\t_, err := pipe.Exec(ctx)\n\t\treturn err\n\t}\n\n\thashKey := \"K_HASHTEST\"\n\thashSeed := func(n int) error {\n\t\tpipe := client.Pipeline()\n\t\tfor i := 1; i <= n; i++ {\n\t\t\tpipe.HSet(ctx, hashKey, fmt.Sprintf(\"K%02d\", i), \"x\").Err()\n\t\t}\n\t\t_, err := pipe.Exec(ctx)\n\t\treturn err\n\t}\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should scan across empty DBs\", func() {\n\t\titer := client.Scan(ctx, 0, \"\", 10).Iterator()\n\t\tExpect(iter.Next(ctx)).To(BeFalse())\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should scan across one page\", func() {\n\t\tExpect(seed(7)).NotTo(HaveOccurred())\n\n\t\tvar vals []string\n\t\titer := client.Scan(ctx, 0, \"\", 0).Iterator()\n\t\tfor iter.Next(ctx) {\n\t\t\tvals = append(vals, iter.Val())\n\t\t}\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t\tExpect(vals).To(ConsistOf([]string{\"K01\", \"K02\", \"K03\", \"K04\", \"K05\", \"K06\", \"K07\"}))\n\t})\n\n\tIt(\"should scan across multiple pages\", func() {\n\t\tExpect(seed(71)).NotTo(HaveOccurred())\n\n\t\tvar vals []string\n\t\titer := client.Scan(ctx, 0, \"\", 10).Iterator()\n\t\tfor iter.Next(ctx) {\n\t\t\tvals = append(vals, iter.Val())\n\t\t}\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t\tExpect(vals).To(HaveLen(71))\n\t\tExpect(vals).To(ContainElement(\"K01\"))\n\t\tExpect(vals).To(ContainElement(\"K71\"))\n\t})\n\n\tIt(\"should hscan across multiple pages\", func() {\n\t\tExpect(hashSeed(71)).NotTo(HaveOccurred())\n\n\t\tvar vals []string\n\t\titer := client.HScan(ctx, hashKey, 0, \"\", 10).Iterator()\n\t\tfor iter.Next(ctx) {\n\t\t\tvals = append(vals, iter.Val())\n\t\t}\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t\tExpect(vals).To(HaveLen(71 * 2))\n\t\tExpect(vals).To(ContainElement(\"K01\"))\n\t\tExpect(vals).To(ContainElement(\"K71\"))\n\t\tExpect(vals).To(ContainElement(\"x\"))\n\t})\n\n\tIt(\"should hscan without values across multiple pages\", Label(\"NonRedisEnterprise\"), func() {\n\t\tExpect(hashSeed(71)).NotTo(HaveOccurred())\n\n\t\tvar vals []string\n\t\titer := client.HScanNoValues(ctx, hashKey, 0, \"\", 10).Iterator()\n\t\tfor iter.Next(ctx) {\n\t\t\tvals = append(vals, iter.Val())\n\t\t}\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t\tExpect(vals).To(HaveLen(71))\n\t\tExpect(vals).To(ContainElement(\"K01\"))\n\t\tExpect(vals).To(ContainElement(\"K71\"))\n\t\tExpect(vals).NotTo(ContainElement(\"x\"))\n\t})\n\n\tIt(\"should scan to page borders\", func() {\n\t\tExpect(seed(20)).NotTo(HaveOccurred())\n\n\t\tvar vals []string\n\t\titer := client.Scan(ctx, 0, \"\", 10).Iterator()\n\t\tfor iter.Next(ctx) {\n\t\t\tvals = append(vals, iter.Val())\n\t\t}\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t\tExpect(vals).To(HaveLen(20))\n\t})\n\n\tIt(\"should scan with match\", func() {\n\t\tExpect(seed(33)).NotTo(HaveOccurred())\n\n\t\tvar vals []string\n\t\titer := client.Scan(ctx, 0, \"K*2*\", 10).Iterator()\n\t\tfor iter.Next(ctx) {\n\t\t\tvals = append(vals, iter.Val())\n\t\t}\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t\tExpect(vals).To(HaveLen(13))\n\t})\n\n\tIt(\"should scan with match across empty pages\", func() {\n\t\tExpect(extraSeed(2, 10)).NotTo(HaveOccurred())\n\n\t\tvar vals []string\n\t\titer := client.Scan(ctx, 0, \"K*\", 1).Iterator()\n\t\tfor iter.Next(ctx) {\n\t\t\tvals = append(vals, iter.Val())\n\t\t}\n\t\tExpect(iter.Err()).NotTo(HaveOccurred())\n\t\tExpect(vals).To(HaveLen(2))\n\t})\n})\n"
        },
        {
          "name": "json.go",
          "type": "blob",
          "size": 18.115234375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"strings\"\n\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n\t\"github.com/redis/go-redis/v9/internal/util\"\n)\n\n// -------------------------------------------\n\ntype JSONCmdable interface {\n\tJSONArrAppend(ctx context.Context, key, path string, values ...interface{}) *IntSliceCmd\n\tJSONArrIndex(ctx context.Context, key, path string, value ...interface{}) *IntSliceCmd\n\tJSONArrIndexWithArgs(ctx context.Context, key, path string, options *JSONArrIndexArgs, value ...interface{}) *IntSliceCmd\n\tJSONArrInsert(ctx context.Context, key, path string, index int64, values ...interface{}) *IntSliceCmd\n\tJSONArrLen(ctx context.Context, key, path string) *IntSliceCmd\n\tJSONArrPop(ctx context.Context, key, path string, index int) *StringSliceCmd\n\tJSONArrTrim(ctx context.Context, key, path string) *IntSliceCmd\n\tJSONArrTrimWithArgs(ctx context.Context, key, path string, options *JSONArrTrimArgs) *IntSliceCmd\n\tJSONClear(ctx context.Context, key, path string) *IntCmd\n\tJSONDebugMemory(ctx context.Context, key, path string) *IntCmd\n\tJSONDel(ctx context.Context, key, path string) *IntCmd\n\tJSONForget(ctx context.Context, key, path string) *IntCmd\n\tJSONGet(ctx context.Context, key string, paths ...string) *JSONCmd\n\tJSONGetWithArgs(ctx context.Context, key string, options *JSONGetArgs, paths ...string) *JSONCmd\n\tJSONMerge(ctx context.Context, key, path string, value string) *StatusCmd\n\tJSONMSetArgs(ctx context.Context, docs []JSONSetArgs) *StatusCmd\n\tJSONMSet(ctx context.Context, params ...interface{}) *StatusCmd\n\tJSONMGet(ctx context.Context, path string, keys ...string) *JSONSliceCmd\n\tJSONNumIncrBy(ctx context.Context, key, path string, value float64) *JSONCmd\n\tJSONObjKeys(ctx context.Context, key, path string) *SliceCmd\n\tJSONObjLen(ctx context.Context, key, path string) *IntPointerSliceCmd\n\tJSONSet(ctx context.Context, key, path string, value interface{}) *StatusCmd\n\tJSONSetMode(ctx context.Context, key, path string, value interface{}, mode string) *StatusCmd\n\tJSONStrAppend(ctx context.Context, key, path, value string) *IntPointerSliceCmd\n\tJSONStrLen(ctx context.Context, key, path string) *IntPointerSliceCmd\n\tJSONToggle(ctx context.Context, key, path string) *IntPointerSliceCmd\n\tJSONType(ctx context.Context, key, path string) *JSONSliceCmd\n}\n\ntype JSONSetArgs struct {\n\tKey   string\n\tPath  string\n\tValue interface{}\n}\n\ntype JSONArrIndexArgs struct {\n\tStart int\n\tStop  *int\n}\n\ntype JSONArrTrimArgs struct {\n\tStart int\n\tStop  *int\n}\n\ntype JSONCmd struct {\n\tbaseCmd\n\tval      string\n\texpanded interface{}\n}\n\nvar _ Cmder = (*JSONCmd)(nil)\n\nfunc newJSONCmd(ctx context.Context, args ...interface{}) *JSONCmd {\n\treturn &JSONCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *JSONCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *JSONCmd) SetVal(val string) {\n\tcmd.val = val\n}\n\nfunc (cmd *JSONCmd) Val() string {\n\tif len(cmd.val) == 0 && cmd.expanded != nil {\n\t\tval, err := json.Marshal(cmd.expanded)\n\t\tif err != nil {\n\t\t\tcmd.SetErr(err)\n\t\t\treturn \"\"\n\t\t}\n\t\treturn string(val)\n\n\t} else {\n\t\treturn cmd.val\n\t}\n}\n\nfunc (cmd *JSONCmd) Result() (string, error) {\n\treturn cmd.Val(), cmd.Err()\n}\n\nfunc (cmd *JSONCmd) Expanded() (interface{}, error) {\n\tif len(cmd.val) != 0 && cmd.expanded == nil {\n\t\terr := json.Unmarshal([]byte(cmd.val), &cmd.expanded)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn cmd.expanded, nil\n}\n\nfunc (cmd *JSONCmd) readReply(rd *proto.Reader) error {\n\t// nil response from JSON.(M)GET (cmd.baseCmd.err will be \"redis: nil\")\n\tif cmd.baseCmd.Err() == Nil {\n\t\tcmd.val = \"\"\n\t\treturn Nil\n\t}\n\n\tif readType, err := rd.PeekReplyType(); err != nil {\n\t\treturn err\n\t} else if readType == proto.RespArray {\n\n\t\tsize, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\texpanded := make([]interface{}, size)\n\n\t\tfor i := 0; i < size; i++ {\n\t\t\tif expanded[i], err = rd.ReadReply(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tcmd.expanded = expanded\n\n\t} else {\n\t\tif str, err := rd.ReadString(); err != nil && err != Nil {\n\t\t\treturn err\n\t\t} else if str == \"\" || err == Nil {\n\t\t\tcmd.val = \"\"\n\t\t} else {\n\t\t\tcmd.val = str\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// -------------------------------------------\n\ntype JSONSliceCmd struct {\n\tbaseCmd\n\tval []interface{}\n}\n\nfunc NewJSONSliceCmd(ctx context.Context, args ...interface{}) *JSONSliceCmd {\n\treturn &JSONSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *JSONSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *JSONSliceCmd) SetVal(val []interface{}) {\n\tcmd.val = val\n}\n\nfunc (cmd *JSONSliceCmd) Val() []interface{} {\n\treturn cmd.val\n}\n\nfunc (cmd *JSONSliceCmd) Result() ([]interface{}, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *JSONSliceCmd) readReply(rd *proto.Reader) error {\n\tif cmd.baseCmd.Err() == Nil {\n\t\tcmd.val = nil\n\t\treturn Nil\n\t}\n\n\tif readType, err := rd.PeekReplyType(); err != nil {\n\t\treturn err\n\t} else if readType == proto.RespArray {\n\t\tresponse, err := rd.ReadReply()\n\t\tif err != nil {\n\t\t\treturn nil\n\t\t} else {\n\t\t\tcmd.val = response.([]interface{})\n\t\t}\n\n\t} else {\n\t\tn, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val = make([]interface{}, n)\n\t\tfor i := 0; i < len(cmd.val); i++ {\n\t\t\tswitch s, err := rd.ReadString(); {\n\t\t\tcase err == Nil:\n\t\t\t\tcmd.val[i] = \"\"\n\t\t\tcase err != nil:\n\t\t\t\treturn err\n\t\t\tdefault:\n\t\t\t\tcmd.val[i] = s\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n/*******************************************************************************\n*\n* IntPointerSliceCmd\n* used to represent a RedisJSON response where the result is either an integer or nil\n*\n*******************************************************************************/\n\ntype IntPointerSliceCmd struct {\n\tbaseCmd\n\tval []*int64\n}\n\n// NewIntPointerSliceCmd initialises an IntPointerSliceCmd\nfunc NewIntPointerSliceCmd(ctx context.Context, args ...interface{}) *IntPointerSliceCmd {\n\treturn &IntPointerSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *IntPointerSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *IntPointerSliceCmd) SetVal(val []*int64) {\n\tcmd.val = val\n}\n\nfunc (cmd *IntPointerSliceCmd) Val() []*int64 {\n\treturn cmd.val\n}\n\nfunc (cmd *IntPointerSliceCmd) Result() ([]*int64, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *IntPointerSliceCmd) readReply(rd *proto.Reader) error {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]*int64, n)\n\n\tfor i := 0; i < len(cmd.val); i++ {\n\t\tval, err := rd.ReadInt()\n\t\tif err != nil && err != Nil {\n\t\t\treturn err\n\t\t} else if err != Nil {\n\t\t\tcmd.val[i] = &val\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\n// JSONArrAppend adds the provided JSON values to the end of the array at the given path.\n// For more information, see https://redis.io/commands/json.arrappend\nfunc (c cmdable) JSONArrAppend(ctx context.Context, key, path string, values ...interface{}) *IntSliceCmd {\n\targs := []interface{}{\"JSON.ARRAPPEND\", key, path}\n\targs = append(args, values...)\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONArrIndex searches for the first occurrence of the provided JSON value in the array at the given path.\n// For more information, see https://redis.io/commands/json.arrindex\nfunc (c cmdable) JSONArrIndex(ctx context.Context, key, path string, value ...interface{}) *IntSliceCmd {\n\targs := []interface{}{\"JSON.ARRINDEX\", key, path}\n\targs = append(args, value...)\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONArrIndexWithArgs searches for the first occurrence of a JSON value in an array while allowing the start and\n// stop options to be provided.\n// For more information, see https://redis.io/commands/json.arrindex\nfunc (c cmdable) JSONArrIndexWithArgs(ctx context.Context, key, path string, options *JSONArrIndexArgs, value ...interface{}) *IntSliceCmd {\n\targs := []interface{}{\"JSON.ARRINDEX\", key, path}\n\targs = append(args, value...)\n\n\tif options != nil {\n\t\targs = append(args, options.Start)\n\t\tif options.Stop != nil {\n\t\t\targs = append(args, *options.Stop)\n\t\t}\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONArrInsert inserts the JSON values into the array at the specified path before the index (shifts to the right).\n// For more information, see https://redis.io/commands/json.arrinsert\nfunc (c cmdable) JSONArrInsert(ctx context.Context, key, path string, index int64, values ...interface{}) *IntSliceCmd {\n\targs := []interface{}{\"JSON.ARRINSERT\", key, path, index}\n\targs = append(args, values...)\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONArrLen reports the length of the JSON array at the specified path in the given key.\n// For more information, see https://redis.io/commands/json.arrlen\nfunc (c cmdable) JSONArrLen(ctx context.Context, key, path string) *IntSliceCmd {\n\targs := []interface{}{\"JSON.ARRLEN\", key, path}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONArrPop removes and returns an element from the specified index in the array.\n// For more information, see https://redis.io/commands/json.arrpop\nfunc (c cmdable) JSONArrPop(ctx context.Context, key, path string, index int) *StringSliceCmd {\n\targs := []interface{}{\"JSON.ARRPOP\", key, path, index}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONArrTrim trims an array to contain only the specified inclusive range of elements.\n// For more information, see https://redis.io/commands/json.arrtrim\nfunc (c cmdable) JSONArrTrim(ctx context.Context, key, path string) *IntSliceCmd {\n\targs := []interface{}{\"JSON.ARRTRIM\", key, path}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONArrTrimWithArgs trims an array to contain only the specified inclusive range of elements.\n// For more information, see https://redis.io/commands/json.arrtrim\nfunc (c cmdable) JSONArrTrimWithArgs(ctx context.Context, key, path string, options *JSONArrTrimArgs) *IntSliceCmd {\n\targs := []interface{}{\"JSON.ARRTRIM\", key, path}\n\n\tif options != nil {\n\t\targs = append(args, options.Start)\n\n\t\tif options.Stop != nil {\n\t\t\targs = append(args, *options.Stop)\n\t\t}\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONClear clears container values (arrays/objects) and sets numeric values to 0.\n// For more information, see https://redis.io/commands/json.clear\nfunc (c cmdable) JSONClear(ctx context.Context, key, path string) *IntCmd {\n\targs := []interface{}{\"JSON.CLEAR\", key, path}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONDebugMemory reports a value's memory usage in bytes (unimplemented)\n// For more information, see https://redis.io/commands/json.debug-memory\nfunc (c cmdable) JSONDebugMemory(ctx context.Context, key, path string) *IntCmd {\n\tpanic(\"not implemented\")\n}\n\n// JSONDel deletes a value.\n// For more information, see https://redis.io/commands/json.del\nfunc (c cmdable) JSONDel(ctx context.Context, key, path string) *IntCmd {\n\targs := []interface{}{\"JSON.DEL\", key, path}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONForget deletes a value.\n// For more information, see https://redis.io/commands/json.forget\nfunc (c cmdable) JSONForget(ctx context.Context, key, path string) *IntCmd {\n\targs := []interface{}{\"JSON.FORGET\", key, path}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONGet returns the value at path in JSON serialized form. JSON.GET returns an\n// array of strings. This function parses out the wrapping array but leaves the\n// internal strings unprocessed by default (see Val())\n// For more information - https://redis.io/commands/json.get/\nfunc (c cmdable) JSONGet(ctx context.Context, key string, paths ...string) *JSONCmd {\n\targs := make([]interface{}, len(paths)+2)\n\targs[0] = \"JSON.GET\"\n\targs[1] = key\n\tfor n, path := range paths {\n\t\targs[n+2] = path\n\t}\n\tcmd := newJSONCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype JSONGetArgs struct {\n\tIndent  string\n\tNewline string\n\tSpace   string\n}\n\n// JSONGetWithArgs - Retrieves the value of a key from a JSON document.\n// This function also allows for specifying additional options such as:\n// Indention, NewLine and Space\n// For more information - https://redis.io/commands/json.get/\nfunc (c cmdable) JSONGetWithArgs(ctx context.Context, key string, options *JSONGetArgs, paths ...string) *JSONCmd {\n\targs := []interface{}{\"JSON.GET\", key}\n\tif options != nil {\n\t\tif options.Indent != \"\" {\n\t\t\targs = append(args, \"INDENT\", options.Indent)\n\t\t}\n\t\tif options.Newline != \"\" {\n\t\t\targs = append(args, \"NEWLINE\", options.Newline)\n\t\t}\n\t\tif options.Space != \"\" {\n\t\t\targs = append(args, \"SPACE\", options.Space)\n\t\t}\n\t\tfor _, path := range paths {\n\t\t\targs = append(args, path)\n\t\t}\n\t}\n\tcmd := newJSONCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONMerge merges a given JSON value into matching paths.\n// For more information, see https://redis.io/commands/json.merge\nfunc (c cmdable) JSONMerge(ctx context.Context, key, path string, value string) *StatusCmd {\n\targs := []interface{}{\"JSON.MERGE\", key, path, value}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONMGet returns the values at the specified path from multiple key arguments.\n// Note - the arguments are reversed when compared with `JSON.MGET` as we want\n// to follow the pattern of having the last argument be variable.\n// For more information, see https://redis.io/commands/json.mget\nfunc (c cmdable) JSONMGet(ctx context.Context, path string, keys ...string) *JSONSliceCmd {\n\targs := make([]interface{}, len(keys)+1)\n\targs[0] = \"JSON.MGET\"\n\tfor n, key := range keys {\n\t\targs[n+1] = key\n\t}\n\targs = append(args, path)\n\tcmd := NewJSONSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONMSetArgs sets or updates one or more JSON values according to the specified key-path-value triplets.\n// For more information, see https://redis.io/commands/json.mset\nfunc (c cmdable) JSONMSetArgs(ctx context.Context, docs []JSONSetArgs) *StatusCmd {\n\targs := []interface{}{\"JSON.MSET\"}\n\tfor _, doc := range docs {\n\t\targs = append(args, doc.Key, doc.Path, doc.Value)\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) JSONMSet(ctx context.Context, params ...interface{}) *StatusCmd {\n\targs := []interface{}{\"JSON.MSET\"}\n\targs = append(args, params...)\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONNumIncrBy increments the number value stored at the specified path by the provided number.\n// For more information, see https://redis.io/docs/latest/commands/json.numincrby/\nfunc (c cmdable) JSONNumIncrBy(ctx context.Context, key, path string, value float64) *JSONCmd {\n\targs := []interface{}{\"JSON.NUMINCRBY\", key, path, value}\n\tcmd := newJSONCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONObjKeys returns the keys in the object that's referenced by the specified path.\n// For more information, see https://redis.io/commands/json.objkeys\nfunc (c cmdable) JSONObjKeys(ctx context.Context, key, path string) *SliceCmd {\n\targs := []interface{}{\"JSON.OBJKEYS\", key, path}\n\tcmd := NewSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONObjLen reports the number of keys in the JSON object at the specified path in the given key.\n// For more information, see https://redis.io/commands/json.objlen\nfunc (c cmdable) JSONObjLen(ctx context.Context, key, path string) *IntPointerSliceCmd {\n\targs := []interface{}{\"JSON.OBJLEN\", key, path}\n\tcmd := NewIntPointerSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONSet sets the JSON value at the given path in the given key. The value must be something that\n// can be marshaled to JSON (using encoding/JSON) unless the argument is a string or a []byte when we assume that\n// it can be passed directly as JSON.\n// For more information, see https://redis.io/commands/json.set\nfunc (c cmdable) JSONSet(ctx context.Context, key, path string, value interface{}) *StatusCmd {\n\treturn c.JSONSetMode(ctx, key, path, value, \"\")\n}\n\n// JSONSetMode sets the JSON value at the given path in the given key and allows the mode to be set\n// (the mode value must be \"XX\" or \"NX\"). The value must be something that can be marshaled to JSON (using encoding/JSON) unless\n// the argument is a string or []byte when we assume that it can be passed directly as JSON.\n// For more information, see https://redis.io/commands/json.set\nfunc (c cmdable) JSONSetMode(ctx context.Context, key, path string, value interface{}, mode string) *StatusCmd {\n\tvar bytes []byte\n\tvar err error\n\tswitch v := value.(type) {\n\tcase string:\n\t\tbytes = []byte(v)\n\tcase []byte:\n\t\tbytes = v\n\tdefault:\n\t\tbytes, err = json.Marshal(v)\n\t}\n\targs := []interface{}{\"JSON.SET\", key, path, util.BytesToString(bytes)}\n\tif mode != \"\" {\n\t\tswitch strings.ToUpper(mode) {\n\t\tcase \"XX\", \"NX\":\n\t\t\targs = append(args, strings.ToUpper(mode))\n\n\t\tdefault:\n\t\t\tpanic(\"redis: JSON.SET mode must be NX or XX\")\n\t\t}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\tif err != nil {\n\t\tcmd.SetErr(err)\n\t} else {\n\t\t_ = c(ctx, cmd)\n\t}\n\treturn cmd\n}\n\n// JSONStrAppend appends the JSON-string values to the string at the specified path.\n// For more information, see https://redis.io/commands/json.strappend\nfunc (c cmdable) JSONStrAppend(ctx context.Context, key, path, value string) *IntPointerSliceCmd {\n\targs := []interface{}{\"JSON.STRAPPEND\", key, path, value}\n\tcmd := NewIntPointerSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONStrLen reports the length of the JSON String at the specified path in the given key.\n// For more information, see https://redis.io/commands/json.strlen\nfunc (c cmdable) JSONStrLen(ctx context.Context, key, path string) *IntPointerSliceCmd {\n\targs := []interface{}{\"JSON.STRLEN\", key, path}\n\tcmd := NewIntPointerSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONToggle toggles a Boolean value stored at the specified path.\n// For more information, see https://redis.io/commands/json.toggle\nfunc (c cmdable) JSONToggle(ctx context.Context, key, path string) *IntPointerSliceCmd {\n\targs := []interface{}{\"JSON.TOGGLE\", key, path}\n\tcmd := NewIntPointerSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// JSONType reports the type of JSON value at the specified path.\n// For more information, see https://redis.io/commands/json.type\nfunc (c cmdable) JSONType(ctx context.Context, key, path string) *JSONSliceCmd {\n\targs := []interface{}{\"JSON.TYPE\", key, path}\n\tcmd := NewJSONSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "json_test.go",
          "type": "blob",
          "size": 30.0478515625,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\ntype JSONGetTestStruct struct {\n\tHello string `json:\"hello\"`\n}\n\nvar _ = Describe(\"JSON Commands\", Label(\"json\"), func() {\n\tctx := context.TODO()\n\tvar client *redis.Client\n\n\tsetupRedisClient := func(protocolVersion int) *redis.Client {\n\t\treturn redis.NewClient(&redis.Options{\n\t\t\tAddr:          \"localhost:6379\",\n\t\t\tDB:            0,\n\t\t\tProtocol:      protocolVersion,\n\t\t\tUnstableResp3: true,\n\t\t})\n\t}\n\n\tAfterEach(func() {\n\t\tif client != nil {\n\t\t\tclient.FlushDB(ctx)\n\t\t\tclient.Close()\n\t\t}\n\t})\n\n\tprotocols := []int{2, 3}\n\tfor _, protocol := range protocols {\n\t\tBeforeEach(func() {\n\t\t\tclient = setupRedisClient(protocol)\n\t\t\tExpect(client.FlushAll(ctx).Err()).NotTo(HaveOccurred())\n\t\t})\n\n\t\tDescribe(\"arrays\", Label(\"arrays\"), func() {\n\t\t\tIt(\"should JSONArrAppend\", Label(\"json.arrappend\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"append2\", \"$\", `{\"a\": [10], \"b\": {\"a\": [12, 13]}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONArrAppend(ctx, \"append2\", \"$..a\", 10)\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal([]int64{2, 3}))\n\t\t\t})\n\n\t\t\tIt(\"should JSONArrIndex and JSONArrIndexWithArgs\", Label(\"json.arrindex\", \"json\"), func() {\n\t\t\t\tcmd1, err := client.JSONSet(ctx, \"index1\", \"$\", `{\"a\": [10], \"b\": {\"a\": [12, 10]}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2, err := client.JSONArrIndex(ctx, \"index1\", \"$.b.a\", 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2).To(Equal([]int64{1}))\n\n\t\t\t\tcmd3, err := client.JSONSet(ctx, \"index2\", \"$\", `[0,1,2,3,4]`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3).To(Equal(\"OK\"))\n\n\t\t\t\tres, err := client.JSONArrIndex(ctx, \"index2\", \"$\", 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res[0]).To(Equal(int64(1)))\n\n\t\t\t\tres, err = client.JSONArrIndex(ctx, \"index2\", \"$\", 1, 2).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res[0]).To(Equal(int64(-1)))\n\n\t\t\t\tres, err = client.JSONArrIndex(ctx, \"index2\", \"$\", 4).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res[0]).To(Equal(int64(4)))\n\n\t\t\t\tres, err = client.JSONArrIndexWithArgs(ctx, \"index2\", \"$\", &redis.JSONArrIndexArgs{}, 4).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res[0]).To(Equal(int64(4)))\n\n\t\t\t\tstop := 5000\n\t\t\t\tres, err = client.JSONArrIndexWithArgs(ctx, \"index2\", \"$\", &redis.JSONArrIndexArgs{Stop: &stop}, 4).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res[0]).To(Equal(int64(4)))\n\n\t\t\t\tstop = -1\n\t\t\t\tres, err = client.JSONArrIndexWithArgs(ctx, \"index2\", \"$\", &redis.JSONArrIndexArgs{Stop: &stop}, 4).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res[0]).To(Equal(int64(-1)))\n\t\t\t})\n\n\t\t\tIt(\"should JSONArrIndex and JSONArrIndexWithArgs with $\", Label(\"json.arrindex\", \"json\"), func() {\n\t\t\t\tdoc := `{\n\t\t\t\t\t\"store\": {\n\t\t\t\t\t\t\"book\": [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"category\": \"reference\",\n\t\t\t\t\t\t\t\t\"author\": \"Nigel Rees\",\n\t\t\t\t\t\t\t\t\"title\": \"Sayings of the Century\",\n\t\t\t\t\t\t\t\t\"price\": 8.95,\n\t\t\t\t\t\t\t\t\"size\": [10, 20, 30, 40]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"category\": \"fiction\",\n\t\t\t\t\t\t\t\t\"author\": \"Evelyn Waugh\",\n\t\t\t\t\t\t\t\t\"title\": \"Sword of Honour\",\n\t\t\t\t\t\t\t\t\"price\": 12.99,\n\t\t\t\t\t\t\t\t\"size\": [50, 60, 70, 80]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"category\": \"fiction\",\n\t\t\t\t\t\t\t\t\"author\": \"Herman Melville\",\n\t\t\t\t\t\t\t\t\"title\": \"Moby Dick\",\n\t\t\t\t\t\t\t\t\"isbn\": \"0-553-21311-3\",\n\t\t\t\t\t\t\t\t\"price\": 8.99,\n\t\t\t\t\t\t\t\t\"size\": [5, 10, 20, 30]\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"category\": \"fiction\",\n\t\t\t\t\t\t\t\t\"author\": \"J. R. R. Tolkien\",\n\t\t\t\t\t\t\t\t\"title\": \"The Lord of the Rings\",\n\t\t\t\t\t\t\t\t\"isbn\": \"0-395-19395-8\",\n\t\t\t\t\t\t\t\t\"price\": 22.99,\n\t\t\t\t\t\t\t\t\"size\": [5, 6, 7, 8]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"bicycle\": {\"color\": \"red\", \"price\": 19.95}\n\t\t\t\t\t}\n\t\t\t\t}`\n\t\t\t\tres, err := client.JSONSet(ctx, \"doc1\", \"$\", doc).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tresGet, err := client.JSONGet(ctx, \"doc1\", \"$.store.book[?(@.price<10)].size\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(\"[[10,20,30,40],[5,10,20,30]]\"))\n\n\t\t\t\tresArr, err := client.JSONArrIndex(ctx, \"doc1\", \"$.store.book[?(@.price<10)].size\", 20).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resArr).To(Equal([]int64{1, 2}))\n\t\t\t})\n\n\t\t\tIt(\"should JSONArrInsert\", Label(\"json.arrinsert\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"insert2\", \"$\", `[100, 200, 300, 200]`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONArrInsert(ctx, \"insert2\", \"$\", -1, 1, 2)\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal([]int64{6}))\n\n\t\t\t\tcmd3 := client.JSONGet(ctx, \"insert2\")\n\t\t\t\tExpect(cmd3.Err()).NotTo(HaveOccurred())\n\t\t\t\t// RESP2 vs RESP3\n\t\t\t\tExpect(cmd3.Val()).To(Or(\n\t\t\t\t\tEqual(`[100,200,300,1,2,200]`),\n\t\t\t\t\tEqual(`[[100,200,300,1,2,200]]`)))\n\t\t\t})\n\n\t\t\tIt(\"should JSONArrLen\", Label(\"json.arrlen\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"length2\", \"$\", `{\"a\": [10], \"b\": {\"a\": [12, 10, 20, 12, 90, 10]}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONArrLen(ctx, \"length2\", \"$..a\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal([]int64{1, 6}))\n\t\t\t})\n\n\t\t\tIt(\"should JSONArrPop\", Label(\"json.arrpop\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"pop4\", \"$\", `[100, 200, 300, 200]`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONArrPop(ctx, \"pop4\", \"$\", 2)\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal([]string{\"300\"}))\n\n\t\t\t\tcmd3 := client.JSONGet(ctx, \"pop4\", \"$\")\n\t\t\t\tExpect(cmd3.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3.Val()).To(Equal(\"[[100,200,200]]\"))\n\t\t\t})\n\n\t\t\tIt(\"should JSONArrTrim\", Label(\"json.arrtrim\", \"json\"), func() {\n\t\t\t\tcmd1, err := client.JSONSet(ctx, \"trim1\", \"$\", `[0,1,2,3,4]`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1).To(Equal(\"OK\"))\n\n\t\t\t\tstop := 3\n\t\t\t\tcmd2, err := client.JSONArrTrimWithArgs(ctx, \"trim1\", \"$\", &redis.JSONArrTrimArgs{Start: 1, Stop: &stop}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2).To(Equal([]int64{3}))\n\n\t\t\t\tres, err := client.JSONGet(ctx, \"trim1\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(`[[1,2,3]]`))\n\n\t\t\t\tcmd3, err := client.JSONSet(ctx, \"trim2\", \"$\", `[0,1,2,3,4]`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3).To(Equal(\"OK\"))\n\n\t\t\t\tstop = 3\n\t\t\t\tcmd4, err := client.JSONArrTrimWithArgs(ctx, \"trim2\", \"$\", &redis.JSONArrTrimArgs{Start: -1, Stop: &stop}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd4).To(Equal([]int64{0}))\n\n\t\t\t\tcmd5, err := client.JSONSet(ctx, \"trim3\", \"$\", `[0,1,2,3,4]`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd5).To(Equal(\"OK\"))\n\n\t\t\t\tstop = 99\n\t\t\t\tcmd6, err := client.JSONArrTrimWithArgs(ctx, \"trim3\", \"$\", &redis.JSONArrTrimArgs{Start: 3, Stop: &stop}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd6).To(Equal([]int64{2}))\n\n\t\t\t\tcmd7, err := client.JSONSet(ctx, \"trim4\", \"$\", `[0,1,2,3,4]`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd7).To(Equal(\"OK\"))\n\n\t\t\t\tstop = 1\n\t\t\t\tcmd8, err := client.JSONArrTrimWithArgs(ctx, \"trim4\", \"$\", &redis.JSONArrTrimArgs{Start: 9, Stop: &stop}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd8).To(Equal([]int64{0}))\n\n\t\t\t\tcmd9, err := client.JSONSet(ctx, \"trim5\", \"$\", `[0,1,2,3,4]`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd9).To(Equal(\"OK\"))\n\n\t\t\t\tstop = 11\n\t\t\t\tcmd10, err := client.JSONArrTrimWithArgs(ctx, \"trim5\", \"$\", &redis.JSONArrTrimArgs{Start: 9, Stop: &stop}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd10).To(Equal([]int64{0}))\n\t\t\t})\n\n\t\t\tIt(\"should JSONArrPop\", Label(\"json.arrpop\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"pop4\", \"$\", `[100, 200, 300, 200]`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONArrPop(ctx, \"pop4\", \"$\", 2)\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal([]string{\"300\"}))\n\n\t\t\t\tcmd3 := client.JSONGet(ctx, \"pop4\", \"$\")\n\t\t\t\tExpect(cmd3.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3.Val()).To(Equal(\"[[100,200,200]]\"))\n\t\t\t})\n\t\t})\n\n\t\tDescribe(\"get/set\", Label(\"getset\"), func() {\n\t\t\tIt(\"should JSONSet\", Label(\"json.set\", \"json\"), func() {\n\t\t\t\tcmd := client.JSONSet(ctx, \"set1\", \"$\", `{\"a\": 1, \"b\": 2, \"hello\": \"world\"}`)\n\t\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd.Val()).To(Equal(\"OK\"))\n\t\t\t})\n\n\t\t\tIt(\"should JSONGet\", Label(\"json.get\", \"json\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tres, err := client.JSONSet(ctx, \"get3\", \"$\", `{\"a\": 1, \"b\": 2}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tres, err = client.JSONGetWithArgs(ctx, \"get3\", &redis.JSONGetArgs{Indent: \"-\"}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(`{-\"a\":1,-\"b\":2}`))\n\n\t\t\t\tres, err = client.JSONGetWithArgs(ctx, \"get3\", &redis.JSONGetArgs{Indent: \"-\", Newline: `~`, Space: `!`}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(`{~-\"a\":!1,~-\"b\":!2~}`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONMerge\", Label(\"json.merge\", \"json\"), func() {\n\t\t\t\tres, err := client.JSONSet(ctx, \"merge1\", \"$\", `{\"a\": 1, \"b\": 2}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tres, err = client.JSONMerge(ctx, \"merge1\", \"$\", `{\"b\": 3, \"c\": 4}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tres, err = client.JSONGet(ctx, \"merge1\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(`[{\"a\":1,\"b\":3,\"c\":4}]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONMSet\", Label(\"json.mset\", \"json\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tdoc1 := redis.JSONSetArgs{Key: \"mset1\", Path: \"$\", Value: `{\"a\": 1}`}\n\t\t\t\tdoc2 := redis.JSONSetArgs{Key: \"mset2\", Path: \"$\", Value: 2}\n\t\t\t\tdocs := []redis.JSONSetArgs{doc1, doc2}\n\n\t\t\t\tmSetResult, err := client.JSONMSetArgs(ctx, docs).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(mSetResult).To(Equal(\"OK\"))\n\n\t\t\t\tres, err := client.JSONMGet(ctx, \"$\", \"mset1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]interface{}{`[{\"a\":1}]`}))\n\n\t\t\t\tres, err = client.JSONMGet(ctx, \"$\", \"mset1\", \"mset2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal([]interface{}{`[{\"a\":1}]`, \"[2]\"}))\n\n\t\t\t\t_, err = client.JSONMSet(ctx, \"mset1\", \"$.a\", 2, \"mset3\", \"$\", `[1]`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"should JSONMGet\", Label(\"json.mget\", \"json\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"mget2a\", \"$\", `{\"a\": [\"aa\", \"ab\", \"ac\", \"ad\"], \"b\": {\"a\": [\"ba\", \"bb\", \"bc\", \"bd\"]}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\t\t\t\tcmd2 := client.JSONSet(ctx, \"mget2b\", \"$\", `{\"a\": [100, 200, 300, 200], \"b\": {\"a\": [100, 200, 300, 200]}}`)\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd3 := client.JSONMGet(ctx, \"$..a\", \"mget2a\", \"mget2b\")\n\t\t\t\tExpect(cmd3.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3.Val()).To(HaveLen(2))\n\t\t\t\tExpect(cmd3.Val()[0]).To(Equal(`[[\"aa\",\"ab\",\"ac\",\"ad\"],[\"ba\",\"bb\",\"bc\",\"bd\"]]`))\n\t\t\t\tExpect(cmd3.Val()[1]).To(Equal(`[[100,200,300,200],[100,200,300,200]]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONMget with $\", Label(\"json.mget\", \"json\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tres, err := client.JSONSet(ctx, \"doc1\", \"$\", `{\"a\": 1, \"b\": 2, \"nested\": {\"a\": 3}, \"c\": \"\", \"nested2\": {\"a\": \"\"}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tres, err = client.JSONSet(ctx, \"doc2\", \"$\", `{\"a\": 4, \"b\": 5, \"nested\": {\"a\": 6}, \"c\": \"\", \"nested2\": {\"a\": [\"\"]}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err := client.JSONMGet(ctx, \"$..a\", \"doc1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal([]interface{}{`[1,3,\"\"]`}))\n\n\t\t\t\tiRes, err = client.JSONMGet(ctx, \"$..a\", \"doc1\", \"doc2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal([]interface{}{`[1,3,\"\"]`, `[4,6,[\"\"]]`}))\n\n\t\t\t\tiRes, err = client.JSONMGet(ctx, \"$..a\", \"non_existing_doc\", \"non_existing_doc1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal([]interface{}{nil, nil}))\n\t\t\t})\n\t\t})\n\n\t\tDescribe(\"Misc\", Label(\"misc\"), func() {\n\t\t\tIt(\"should JSONClear\", Label(\"json.clear\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"clear1\", \"$\", `[1]`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONClear(ctx, \"clear1\", \"$\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal(int64(1)))\n\n\t\t\t\tcmd3 := client.JSONGet(ctx, \"clear1\", \"$\")\n\t\t\t\tExpect(cmd3.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3.Val()).To(Equal(`[[]]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONClear with $\", Label(\"json.clear\", \"json\"), func() {\n\t\t\t\tdoc := `{\n\t\t\t\t\t\"nested1\": {\"a\": {\"foo\": 10, \"bar\": 20}},\n\t\t\t\t\t\"a\": [\"foo\"],\n\t\t\t\t\t\"nested2\": {\"a\": \"claro\"},\n\t\t\t\t\t\"nested3\": {\"a\": {\"baz\": 50}}\n\t\t\t\t}`\n\t\t\t\tres, err := client.JSONSet(ctx, \"doc1\", \"$\", doc).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err := client.JSONClear(ctx, \"doc1\", \"$..a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(3)))\n\n\t\t\t\tresGet, err := client.JSONGet(ctx, \"doc1\", `$`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(`[{\"nested1\":{\"a\":{}},\"a\":[],\"nested2\":{\"a\":\"claro\"},\"nested3\":{\"a\":{}}}]`))\n\n\t\t\t\tres, err = client.JSONSet(ctx, \"doc1\", \"$\", doc).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err = client.JSONClear(ctx, \"doc1\", \"$.nested1.a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(1)))\n\n\t\t\t\tresGet, err = client.JSONGet(ctx, \"doc1\", `$`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(`[{\"nested1\":{\"a\":{}},\"a\":[\"foo\"],\"nested2\":{\"a\":\"claro\"},\"nested3\":{\"a\":{\"baz\":50}}}]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONDel\", Label(\"json.del\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"del1\", \"$\", `[1]`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONDel(ctx, \"del1\", \"$\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal(int64(1)))\n\n\t\t\t\tcmd3 := client.JSONGet(ctx, \"del1\", \"$\")\n\t\t\t\tExpect(cmd3.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3.Val()).To(HaveLen(0))\n\t\t\t})\n\n\t\t\tIt(\"should JSONDel with $\", Label(\"json.del\", \"json\"), func() {\n\t\t\t\tres, err := client.JSONSet(ctx, \"del1\", \"$\", `{\"a\": 1, \"nested\": {\"a\": 2, \"b\": 3}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err := client.JSONDel(ctx, \"del1\", \"$..a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(2)))\n\n\t\t\t\tresGet, err := client.JSONGet(ctx, \"del1\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(`[{\"nested\":{\"b\":3}}]`))\n\n\t\t\t\tres, err = client.JSONSet(ctx, \"del2\", \"$\", `{\"a\": {\"a\": 2, \"b\": 3}, \"b\": [\"a\", \"b\"], \"nested\": {\"b\": [true, \"a\", \"b\"]}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err = client.JSONDel(ctx, \"del2\", \"$..a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(1)))\n\n\t\t\t\tresGet, err = client.JSONGet(ctx, \"del2\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(`[{\"nested\":{\"b\":[true,\"a\",\"b\"]},\"b\":[\"a\",\"b\"]}]`))\n\n\t\t\t\tdoc := `[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"ciao\": [\"non ancora\"],\n\t\t\t\t\t\t\"nested\": [\n\t\t\t\t\t\t\t{\"ciao\": [1, \"a\"]},\n\t\t\t\t\t\t\t{\"ciao\": [2, \"a\"]},\n\t\t\t\t\t\t\t{\"ciaoc\": [3, \"non\", \"ciao\"]},\n\t\t\t\t\t\t\t{\"ciao\": [4, \"a\"]},\n\t\t\t\t\t\t\t{\"e\": [5, \"non\", \"ciao\"]}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t]`\n\t\t\t\tres, err = client.JSONSet(ctx, \"del3\", \"$\", doc).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err = client.JSONDel(ctx, \"del3\", `$.[0][\"nested\"]..ciao`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(3)))\n\n\t\t\t\tresVal := `[[{\"ciao\":[\"non ancora\"],\"nested\":[{},{},{\"ciaoc\":[3,\"non\",\"ciao\"]},{},{\"e\":[5,\"non\",\"ciao\"]}]}]]`\n\t\t\t\tresGet, err = client.JSONGet(ctx, \"del3\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(resVal))\n\t\t\t})\n\n\t\t\tIt(\"should JSONForget\", Label(\"json.forget\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"forget3\", \"$\", `{\"a\": [1,2,3], \"b\": {\"a\": [1,2,3], \"b\": \"annie\"}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONForget(ctx, \"forget3\", \"$..a\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal(int64(2)))\n\n\t\t\t\tcmd3 := client.JSONGet(ctx, \"forget3\", \"$\")\n\t\t\t\tExpect(cmd3.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3.Val()).To(Equal(`[{\"b\":{\"b\":\"annie\"}}]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONForget with $\", Label(\"json.forget\", \"json\"), func() {\n\t\t\t\tres, err := client.JSONSet(ctx, \"doc1\", \"$\", `{\"a\": 1, \"nested\": {\"a\": 2, \"b\": 3}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err := client.JSONForget(ctx, \"doc1\", \"$..a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(2)))\n\n\t\t\t\tresGet, err := client.JSONGet(ctx, \"doc1\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(`[{\"nested\":{\"b\":3}}]`))\n\n\t\t\t\tres, err = client.JSONSet(ctx, \"doc2\", \"$\", `{\"a\": {\"a\": 2, \"b\": 3}, \"b\": [\"a\", \"b\"], \"nested\": {\"b\": [true, \"a\", \"b\"]}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err = client.JSONForget(ctx, \"doc2\", \"$..a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(1)))\n\n\t\t\t\tresGet, err = client.JSONGet(ctx, \"doc2\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(`[{\"nested\":{\"b\":[true,\"a\",\"b\"]},\"b\":[\"a\",\"b\"]}]`))\n\n\t\t\t\tdoc := `[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"ciao\": [\"non ancora\"],\n\t\t\t\t\t\t\"nested\": [\n\t\t\t\t\t\t\t{\"ciao\": [1, \"a\"]},\n\t\t\t\t\t\t\t{\"ciao\": [2, \"a\"]},\n\t\t\t\t\t\t\t{\"ciaoc\": [3, \"non\", \"ciao\"]},\n\t\t\t\t\t\t\t{\"ciao\": [4, \"a\"]},\n\t\t\t\t\t\t\t{\"e\": [5, \"non\", \"ciao\"]}\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t]`\n\t\t\t\tres, err = client.JSONSet(ctx, \"doc3\", \"$\", doc).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tiRes, err = client.JSONForget(ctx, \"doc3\", `$.[0][\"nested\"]..ciao`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(iRes).To(Equal(int64(3)))\n\n\t\t\t\tresVal := `[[{\"ciao\":[\"non ancora\"],\"nested\":[{},{},{\"ciaoc\":[3,\"non\",\"ciao\"]},{},{\"e\":[5,\"non\",\"ciao\"]}]}]]`\n\t\t\t\tresGet, err = client.JSONGet(ctx, \"doc3\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resGet).To(Equal(resVal))\n\t\t\t})\n\n\t\t\tIt(\"should JSONNumIncrBy\", Label(\"json.numincrby\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"incr3\", \"$\", `{\"a\": [1, 2], \"b\": {\"a\": [0, -1]}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONNumIncrBy(ctx, \"incr3\", \"$..a[1]\", float64(1))\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(Equal(`[3,0]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONNumIncrBy with $\", Label(\"json.numincrby\", \"json\"), func() {\n\t\t\t\tres, err := client.JSONSet(ctx, \"doc1\", \"$\", `{\"a\": \"b\", \"b\": [{\"a\": 2}, {\"a\": 5.0}, {\"a\": \"c\"}]}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tres, err = client.JSONNumIncrBy(ctx, \"doc1\", \"$.b[1].a\", 2).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(`[7]`))\n\n\t\t\t\tres, err = client.JSONNumIncrBy(ctx, \"doc1\", \"$.b[1].a\", 3.5).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(`[10.5]`))\n\n\t\t\t\tres, err = client.JSONSet(ctx, \"doc2\", \"$\", `{\"a\": \"b\", \"b\": [{\"a\": 2}, {\"a\": 5.0}, {\"a\": \"c\"}]}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tres, err = client.JSONNumIncrBy(ctx, \"doc2\", \"$.b[0].a\", 3).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(`[5]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONObjKeys\", Label(\"json.objkeys\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"objkeys1\", \"$\", `{\"a\": [1, 2], \"b\": {\"a\": [0, -1]}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONObjKeys(ctx, \"objkeys1\", \"$..*\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(HaveLen(7))\n\t\t\t\tExpect(cmd2.Val()).To(Equal([]interface{}{nil, []interface{}{\"a\"}, nil, nil, nil, nil, nil}))\n\t\t\t})\n\n\t\t\tIt(\"should JSONObjKeys with $\", Label(\"json.objkeys\", \"json\"), func() {\n\t\t\t\tdoc := `{\n\t\t\t\t\t\"nested1\": {\"a\": {\"foo\": 10, \"bar\": 20}},\n\t\t\t\t\t\"a\": [\"foo\"],\n\t\t\t\t\t\"nested2\": {\"a\": {\"baz\": 50}}\n\t\t\t\t}`\n\t\t\t\tcmd1, err := client.JSONSet(ctx, \"objkeys1\", \"$\", doc).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2, err := client.JSONObjKeys(ctx, \"objkeys1\", \"$.nested1.a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2).To(Equal([]interface{}{[]interface{}{\"foo\", \"bar\"}}))\n\n\t\t\t\tcmd2, err = client.JSONObjKeys(ctx, \"objkeys1\", \".*.a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2).To(Equal([]interface{}{\"foo\", \"bar\"}))\n\n\t\t\t\tcmd2, err = client.JSONObjKeys(ctx, \"objkeys1\", \".nested2.a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2).To(Equal([]interface{}{\"baz\"}))\n\n\t\t\t\t_, err = client.JSONObjKeys(ctx, \"non_existing_doc\", \"..a\").Result()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t})\n\n\t\t\tIt(\"should JSONObjLen\", Label(\"json.objlen\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"objlen2\", \"$\", `{\"a\": [1, 2], \"b\": {\"a\": [0, -1]}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONObjLen(ctx, \"objlen2\", \"$..*\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(HaveLen(7))\n\t\t\t\tExpect(cmd2.Val()[0]).To(BeNil())\n\t\t\t\tExpect(*cmd2.Val()[1]).To(Equal(int64(1)))\n\t\t\t})\n\n\t\t\tIt(\"should JSONStrLen\", Label(\"json.strlen\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"strlen2\", \"$\", `{\"a\": \"alice\", \"b\": \"bob\", \"c\": {\"a\": \"alice\", \"b\": \"bob\"}}`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONStrLen(ctx, \"strlen2\", \"$..*\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(HaveLen(5))\n\t\t\t\tvar tmp int64 = 20\n\t\t\t\tExpect(cmd2.Val()[0]).To(BeAssignableToTypeOf(&tmp))\n\t\t\t\tExpect(*cmd2.Val()[0]).To(Equal(int64(5)))\n\t\t\t\tExpect(*cmd2.Val()[1]).To(Equal(int64(3)))\n\t\t\t\tExpect(cmd2.Val()[2]).To(BeNil())\n\t\t\t\tExpect(*cmd2.Val()[3]).To(Equal(int64(5)))\n\t\t\t\tExpect(*cmd2.Val()[4]).To(Equal(int64(3)))\n\t\t\t})\n\n\t\t\tIt(\"should JSONStrAppend\", Label(\"json.strappend\", \"json\"), func() {\n\t\t\t\tcmd1, err := client.JSONSet(ctx, \"strapp1\", \"$\", `\"foo\"`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1).To(Equal(\"OK\"))\n\t\t\t\tcmd2, err := client.JSONStrAppend(ctx, \"strapp1\", \"$\", `\"bar\"`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(*cmd2[0]).To(Equal(int64(6)))\n\t\t\t\tcmd3, err := client.JSONGet(ctx, \"strapp1\", \"$\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd3).To(Equal(`[\"foobar\"]`))\n\t\t\t})\n\n\t\t\tIt(\"should JSONStrAppend and JSONStrLen with $\", Label(\"json.strappend\", \"json.strlen\", \"json\"), func() {\n\t\t\t\tres, err := client.JSONSet(ctx, \"doc1\", \"$\", `{\"a\": \"foo\", \"nested1\": {\"a\": \"hello\"}, \"nested2\": {\"a\": 31}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tintArrayResult, err := client.JSONStrAppend(ctx, \"doc1\", \"$.nested1.a\", `\"baz\"`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(*intArrayResult[0]).To(Equal(int64(8)))\n\n\t\t\t\tres, err = client.JSONSet(ctx, \"doc2\", \"$\", `{\"a\": \"foo\", \"nested1\": {\"a\": \"hello\"}, \"nested2\": {\"a\": 31}}`).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(Equal(\"OK\"))\n\n\t\t\t\tintResult, err := client.JSONStrLen(ctx, \"doc2\", \"$.nested1.a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(*intResult[0]).To(Equal(int64(5)))\n\t\t\t})\n\n\t\t\tIt(\"should JSONToggle\", Label(\"json.toggle\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"toggle1\", \"$\", `[true]`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONToggle(ctx, \"toggle1\", \"$[0]\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(HaveLen(1))\n\t\t\t\tExpect(*cmd2.Val()[0]).To(Equal(int64(0)))\n\t\t\t})\n\n\t\t\tIt(\"should JSONType\", Label(\"json.type\", \"json\"), func() {\n\t\t\t\tcmd1 := client.JSONSet(ctx, \"type1\", \"$\", `[true]`)\n\t\t\t\tExpect(cmd1.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd1.Val()).To(Equal(\"OK\"))\n\n\t\t\t\tcmd2 := client.JSONType(ctx, \"type1\", \"$[0]\")\n\t\t\t\tExpect(cmd2.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd2.Val()).To(HaveLen(1))\n\t\t\t\t// RESP2 v RESP3\n\t\t\t\tExpect(cmd2.Val()[0]).To(Or(Equal([]interface{}{\"boolean\"}), Equal(\"boolean\")))\n\t\t\t})\n\t\t})\n\t}\n})\n\nvar _ = Describe(\"Go-Redis Advanced JSON and RediSearch Tests\", func() {\n\tvar client *redis.Client\n\tvar ctx = context.Background()\n\n\tsetupRedisClient := func(protocolVersion int) *redis.Client {\n\t\treturn redis.NewClient(&redis.Options{\n\t\t\tAddr:          \"localhost:6379\",\n\t\t\tDB:            0,\n\t\t\tProtocol:      protocolVersion, // Setting RESP2 or RESP3 protocol\n\t\t\tUnstableResp3: true,            // Enable RESP3 features\n\t\t})\n\t}\n\n\tAfterEach(func() {\n\t\tif client != nil {\n\t\t\tclient.FlushDB(ctx)\n\t\t\tclient.Close()\n\t\t}\n\t})\n\n\tContext(\"when testing with RESP2 and RESP3\", func() {\n\t\tprotocols := []int{2, 3}\n\n\t\tfor _, protocol := range protocols {\n\t\t\tWhen(\"using protocol version\", func() {\n\t\t\t\tBeforeEach(func() {\n\t\t\t\t\tclient = setupRedisClient(protocol)\n\t\t\t\t})\n\n\t\t\t\tIt(\"should perform complex JSON and RediSearch operations\", func() {\n\t\t\t\t\tjsonDoc := map[string]interface{}{\n\t\t\t\t\t\t\"person\": map[string]interface{}{\n\t\t\t\t\t\t\t\"name\":   \"Alice\",\n\t\t\t\t\t\t\t\"age\":    30,\n\t\t\t\t\t\t\t\"status\": true,\n\t\t\t\t\t\t\t\"address\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\"city\":     \"Wonderland\",\n\t\t\t\t\t\t\t\t\"postcode\": \"12345\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"contacts\": []map[string]interface{}{\n\t\t\t\t\t\t\t\t{\"type\": \"email\", \"value\": \"alice@example.com\"},\n\t\t\t\t\t\t\t\t{\"type\": \"phone\", \"value\": \"+123456789\"},\n\t\t\t\t\t\t\t\t{\"type\": \"fax\", \"value\": \"+987654321\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"friends\": []map[string]interface{}{\n\t\t\t\t\t\t\t\t{\"name\": \"Bob\", \"age\": 35, \"status\": true},\n\t\t\t\t\t\t\t\t{\"name\": \"Charlie\", \"age\": 28, \"status\": false},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"settings\": map[string]interface{}{\n\t\t\t\t\t\t\t\"notifications\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\"email\":  true,\n\t\t\t\t\t\t\t\t\"sms\":    false,\n\t\t\t\t\t\t\t\t\"alerts\": []string{\"low battery\", \"door open\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"theme\": \"dark\",\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\n\t\t\t\t\tsetCmd := client.JSONSet(ctx, \"person:1\", \".\", jsonDoc)\n\t\t\t\t\tExpect(setCmd.Err()).NotTo(HaveOccurred(), \"JSON.SET failed\")\n\n\t\t\t\t\tgetCmdRaw := client.JSONGet(ctx, \"person:1\", \".\")\n\t\t\t\t\trawJSON, err := getCmdRaw.Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"JSON.GET (raw) failed\")\n\t\t\t\t\tGinkgoWriter.Printf(\"Raw JSON: %s\\n\", rawJSON)\n\n\t\t\t\t\tgetCmdExpanded := client.JSONGet(ctx, \"person:1\", \".\")\n\t\t\t\t\texpandedJSON, err := getCmdExpanded.Expanded()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"JSON.GET (expanded) failed\")\n\t\t\t\t\tGinkgoWriter.Printf(\"Expanded JSON: %+v\\n\", expandedJSON)\n\n\t\t\t\t\tExpect(rawJSON).To(MatchJSON(jsonMustMarshal(expandedJSON)))\n\n\t\t\t\t\tarrAppendCmd := client.JSONArrAppend(ctx, \"person:1\", \"$.person.contacts\", `{\"type\": \"social\", \"value\": \"@alice_wonder\"}`)\n\t\t\t\t\tExpect(arrAppendCmd.Err()).NotTo(HaveOccurred(), \"JSON.ARRAPPEND failed\")\n\t\t\t\t\tarrLenCmd := client.JSONArrLen(ctx, \"person:1\", \"$.person.contacts\")\n\t\t\t\t\tarrLen, err := arrLenCmd.Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"JSON.ARRLEN failed\")\n\t\t\t\t\tExpect(arrLen).To(Equal([]int64{4}), \"Array length mismatch after append\")\n\n\t\t\t\t\tarrInsertCmd := client.JSONArrInsert(ctx, \"person:1\", \"$.person.friends\", 1, `{\"name\": \"Diana\", \"age\": 25, \"status\": true}`)\n\t\t\t\t\tExpect(arrInsertCmd.Err()).NotTo(HaveOccurred(), \"JSON.ARRINSERT failed\")\n\n\t\t\t\t\tstart := 0\n\t\t\t\t\tstop := 1\n\t\t\t\t\tarrTrimCmd := client.JSONArrTrimWithArgs(ctx, \"person:1\", \"$.person.friends\", &redis.JSONArrTrimArgs{Start: start, Stop: &stop})\n\t\t\t\t\tExpect(arrTrimCmd.Err()).NotTo(HaveOccurred(), \"JSON.ARRTRIM failed\")\n\n\t\t\t\t\tmergeData := map[string]interface{}{\n\t\t\t\t\t\t\"status\":    false,\n\t\t\t\t\t\t\"nickname\":  \"WonderAlice\",\n\t\t\t\t\t\t\"lastLogin\": time.Now().Format(time.RFC3339),\n\t\t\t\t\t}\n\t\t\t\t\tmergeCmd := client.JSONMerge(ctx, \"person:1\", \"$.person\", jsonMustMarshal(mergeData))\n\t\t\t\t\tExpect(mergeCmd.Err()).NotTo(HaveOccurred(), \"JSON.MERGE failed\")\n\n\t\t\t\t\ttypeCmd := client.JSONType(ctx, \"person:1\", \"$.person.nickname\")\n\t\t\t\t\tnicknameType, err := typeCmd.Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"JSON.TYPE failed\")\n\t\t\t\t\tExpect(nicknameType[0]).To(Equal([]interface{}{\"string\"}), \"JSON.TYPE mismatch for nickname\")\n\n\t\t\t\t\tcreateIndexCmd := client.Do(ctx, \"FT.CREATE\", \"person_idx\", \"ON\", \"JSON\",\n\t\t\t\t\t\t\"PREFIX\", \"1\", \"person:\", \"SCHEMA\",\n\t\t\t\t\t\t\"$.person.name\", \"AS\", \"name\", \"TEXT\",\n\t\t\t\t\t\t\"$.person.age\", \"AS\", \"age\", \"NUMERIC\",\n\t\t\t\t\t\t\"$.person.address.city\", \"AS\", \"city\", \"TEXT\",\n\t\t\t\t\t\t\"$.person.contacts[*].value\", \"AS\", \"contact_value\", \"TEXT\",\n\t\t\t\t\t)\n\t\t\t\t\tExpect(createIndexCmd.Err()).NotTo(HaveOccurred(), \"FT.CREATE failed\")\n\n\t\t\t\t\tsearchCmd := client.FTSearchWithArgs(ctx, \"person_idx\", \"@contact_value:(alice\\\\@example\\\\.com alice_wonder)\", &redis.FTSearchOptions{Return: []redis.FTSearchReturn{{FieldName: \"$.person.name\"}, {FieldName: \"$.person.age\"}, {FieldName: \"$.person.address.city\"}}})\n\t\t\t\t\tsearchResult, err := searchCmd.Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"FT.SEARCH failed\")\n\t\t\t\t\tGinkgoWriter.Printf(\"Advanced Search result: %+v\\n\", searchResult)\n\n\t\t\t\t\tincrCmd := client.JSONNumIncrBy(ctx, \"person:1\", \"$.person.age\", 5)\n\t\t\t\t\tincrResult, err := incrCmd.Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"JSON.NUMINCRBY failed\")\n\t\t\t\t\tExpect(incrResult).To(Equal(\"[35]\"), \"Age increment mismatch\")\n\n\t\t\t\t\tdelCmd := client.JSONDel(ctx, \"person:1\", \"$.settings.notifications.email\")\n\t\t\t\t\tExpect(delCmd.Err()).NotTo(HaveOccurred(), \"JSON.DEL failed\")\n\n\t\t\t\t\ttypeCmd = client.JSONType(ctx, \"person:1\", \"$.settings.notifications.email\")\n\t\t\t\t\ttypeResult, err := typeCmd.Result()\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(typeResult[0]).To(BeEmpty(), \"Expected JSON.TYPE to be empty for deleted field\")\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t})\n})\n\n// Helper function to marshal data into JSON for comparisons\nfunc jsonMustMarshal(v interface{}) string {\n\tbytes, err := json.Marshal(v)\n\tExpect(err).NotTo(HaveOccurred())\n\treturn string(bytes)\n}\n"
        },
        {
          "name": "list_commands.go",
          "type": "blob",
          "size": 8.7529296875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype ListCmdable interface {\n\tBLPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd\n\tBLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *KeyValuesCmd\n\tBRPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd\n\tBRPopLPush(ctx context.Context, source, destination string, timeout time.Duration) *StringCmd\n\tLIndex(ctx context.Context, key string, index int64) *StringCmd\n\tLInsert(ctx context.Context, key, op string, pivot, value interface{}) *IntCmd\n\tLInsertBefore(ctx context.Context, key string, pivot, value interface{}) *IntCmd\n\tLInsertAfter(ctx context.Context, key string, pivot, value interface{}) *IntCmd\n\tLLen(ctx context.Context, key string) *IntCmd\n\tLMPop(ctx context.Context, direction string, count int64, keys ...string) *KeyValuesCmd\n\tLPop(ctx context.Context, key string) *StringCmd\n\tLPopCount(ctx context.Context, key string, count int) *StringSliceCmd\n\tLPos(ctx context.Context, key string, value string, args LPosArgs) *IntCmd\n\tLPosCount(ctx context.Context, key string, value string, count int64, args LPosArgs) *IntSliceCmd\n\tLPush(ctx context.Context, key string, values ...interface{}) *IntCmd\n\tLPushX(ctx context.Context, key string, values ...interface{}) *IntCmd\n\tLRange(ctx context.Context, key string, start, stop int64) *StringSliceCmd\n\tLRem(ctx context.Context, key string, count int64, value interface{}) *IntCmd\n\tLSet(ctx context.Context, key string, index int64, value interface{}) *StatusCmd\n\tLTrim(ctx context.Context, key string, start, stop int64) *StatusCmd\n\tRPop(ctx context.Context, key string) *StringCmd\n\tRPopCount(ctx context.Context, key string, count int) *StringSliceCmd\n\tRPopLPush(ctx context.Context, source, destination string) *StringCmd\n\tRPush(ctx context.Context, key string, values ...interface{}) *IntCmd\n\tRPushX(ctx context.Context, key string, values ...interface{}) *IntCmd\n\tLMove(ctx context.Context, source, destination, srcpos, destpos string) *StringCmd\n\tBLMove(ctx context.Context, source, destination, srcpos, destpos string, timeout time.Duration) *StringCmd\n}\n\nfunc (c cmdable) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd {\n\targs := make([]interface{}, 1+len(keys)+1)\n\targs[0] = \"blpop\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\targs[len(args)-1] = formatSec(ctx, timeout)\n\tcmd := NewStringSliceCmd(ctx, args...)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) BLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *KeyValuesCmd {\n\targs := make([]interface{}, 3+len(keys), 6+len(keys))\n\targs[0] = \"blmpop\"\n\targs[1] = formatSec(ctx, timeout)\n\targs[2] = len(keys)\n\tfor i, key := range keys {\n\t\targs[3+i] = key\n\t}\n\targs = append(args, strings.ToLower(direction), \"count\", count)\n\tcmd := NewKeyValuesCmd(ctx, args...)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd {\n\targs := make([]interface{}, 1+len(keys)+1)\n\targs[0] = \"brpop\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\targs[len(keys)+1] = formatSec(ctx, timeout)\n\tcmd := NewStringSliceCmd(ctx, args...)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) BRPopLPush(ctx context.Context, source, destination string, timeout time.Duration) *StringCmd {\n\tcmd := NewStringCmd(\n\t\tctx,\n\t\t\"brpoplpush\",\n\t\tsource,\n\t\tdestination,\n\t\tformatSec(ctx, timeout),\n\t)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LIndex(ctx context.Context, key string, index int64) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"lindex\", key, index)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// LMPop Pops one or more elements from the first non-empty list key from the list of provided key names.\n// direction: left or right, count: > 0\n// example: client.LMPop(ctx, \"left\", 3, \"key1\", \"key2\")\nfunc (c cmdable) LMPop(ctx context.Context, direction string, count int64, keys ...string) *KeyValuesCmd {\n\targs := make([]interface{}, 2+len(keys), 5+len(keys))\n\targs[0] = \"lmpop\"\n\targs[1] = len(keys)\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t}\n\targs = append(args, strings.ToLower(direction), \"count\", count)\n\tcmd := NewKeyValuesCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LInsert(ctx context.Context, key, op string, pivot, value interface{}) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"linsert\", key, op, pivot, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LInsertBefore(ctx context.Context, key string, pivot, value interface{}) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"linsert\", key, \"before\", pivot, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LInsertAfter(ctx context.Context, key string, pivot, value interface{}) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"linsert\", key, \"after\", pivot, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LLen(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"llen\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LPop(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"lpop\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LPopCount(ctx context.Context, key string, count int) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"lpop\", key, count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype LPosArgs struct {\n\tRank, MaxLen int64\n}\n\nfunc (c cmdable) LPos(ctx context.Context, key string, value string, a LPosArgs) *IntCmd {\n\targs := []interface{}{\"lpos\", key, value}\n\tif a.Rank != 0 {\n\t\targs = append(args, \"rank\", a.Rank)\n\t}\n\tif a.MaxLen != 0 {\n\t\targs = append(args, \"maxlen\", a.MaxLen)\n\t}\n\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LPosCount(ctx context.Context, key string, value string, count int64, a LPosArgs) *IntSliceCmd {\n\targs := []interface{}{\"lpos\", key, value, \"count\", count}\n\tif a.Rank != 0 {\n\t\targs = append(args, \"rank\", a.Rank)\n\t}\n\tif a.MaxLen != 0 {\n\t\targs = append(args, \"maxlen\", a.MaxLen)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LPush(ctx context.Context, key string, values ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"lpush\"\n\targs[1] = key\n\targs = appendArgs(args, values)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LPushX(ctx context.Context, key string, values ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"lpushx\"\n\targs[1] = key\n\targs = appendArgs(args, values)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LRange(ctx context.Context, key string, start, stop int64) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(\n\t\tctx,\n\t\t\"lrange\",\n\t\tkey,\n\t\tstart,\n\t\tstop,\n\t)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LRem(ctx context.Context, key string, count int64, value interface{}) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"lrem\", key, count, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LSet(ctx context.Context, key string, index int64, value interface{}) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"lset\", key, index, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LTrim(ctx context.Context, key string, start, stop int64) *StatusCmd {\n\tcmd := NewStatusCmd(\n\t\tctx,\n\t\t\"ltrim\",\n\t\tkey,\n\t\tstart,\n\t\tstop,\n\t)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RPop(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"rpop\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RPopCount(ctx context.Context, key string, count int) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"rpop\", key, count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RPopLPush(ctx context.Context, source, destination string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"rpoplpush\", source, destination)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RPush(ctx context.Context, key string, values ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"rpush\"\n\targs[1] = key\n\targs = appendArgs(args, values)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) RPushX(ctx context.Context, key string, values ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"rpushx\"\n\targs[1] = key\n\targs = appendArgs(args, values)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LMove(ctx context.Context, source, destination, srcpos, destpos string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"lmove\", source, destination, srcpos, destpos)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) BLMove(\n\tctx context.Context, source, destination, srcpos, destpos string, timeout time.Duration,\n) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"blmove\", source, destination, srcpos, destpos, formatSec(ctx, timeout))\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 10.6416015625,
          "content": "package redis_test\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nconst (\n\tredisSecondaryPort = \"6381\"\n)\n\nconst (\n\tringShard1Port = \"6390\"\n\tringShard2Port = \"6391\"\n\tringShard3Port = \"6392\"\n)\n\nconst (\n\tsentinelName       = \"mymaster\"\n\tsentinelMasterPort = \"9123\"\n\tsentinelSlave1Port = \"9124\"\n\tsentinelSlave2Port = \"9125\"\n\tsentinelPort1      = \"9126\"\n\tsentinelPort2      = \"9127\"\n\tsentinelPort3      = \"9128\"\n)\n\nvar (\n\tredisPort = \"6380\"\n\tredisAddr = \":\" + redisPort\n)\n\nvar (\n\trediStackPort = \"6379\"\n\trediStackAddr = \":\" + rediStackPort\n)\n\nvar (\n\tsentinelAddrs = []string{\":\" + sentinelPort1, \":\" + sentinelPort2, \":\" + sentinelPort3}\n\n\tprocesses map[string]*redisProcess\n\n\tredisMain                                      *redisProcess\n\tringShard1, ringShard2, ringShard3             *redisProcess\n\tsentinelMaster, sentinelSlave1, sentinelSlave2 *redisProcess\n\tsentinel1, sentinel2, sentinel3                *redisProcess\n)\n\nvar cluster = &clusterScenario{\n\tports:     []string{\"8220\", \"8221\", \"8222\", \"8223\", \"8224\", \"8225\"},\n\tnodeIDs:   make([]string, 6),\n\tprocesses: make(map[string]*redisProcess, 6),\n\tclients:   make(map[string]*redis.Client, 6),\n}\n\nvar RECluster = false\nvar USE_CONTAINERIZED_REDIS = false\n\nfunc registerProcess(port string, p *redisProcess) {\n\tif processes == nil {\n\t\tprocesses = make(map[string]*redisProcess)\n\t}\n\tprocesses[port] = p\n}\n\nvar _ = BeforeSuite(func() {\n\taddr := os.Getenv(\"REDIS_PORT\")\n\tif addr != \"\" {\n\t\tredisPort = addr\n\t\tredisAddr = \":\" + redisPort\n\t}\n\tvar err error\n\tRECluster, _ = strconv.ParseBool(os.Getenv(\"RE_CLUSTER\"))\n\tUSE_CONTAINERIZED_REDIS, _ = strconv.ParseBool(os.Getenv(\"USE_CONTAINERIZED_REDIS\"))\n\tif !RECluster || !USE_CONTAINERIZED_REDIS {\n\n\t\tredisMain, err = startRedis(redisPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tringShard1, err = startRedis(ringShard1Port)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tringShard2, err = startRedis(ringShard2Port)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tringShard3, err = startRedis(ringShard3Port)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tsentinelMaster, err = startRedis(sentinelMasterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tsentinel1, err = startSentinel(sentinelPort1, sentinelName, sentinelMasterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tsentinel2, err = startSentinel(sentinelPort2, sentinelName, sentinelMasterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tsentinel3, err = startSentinel(sentinelPort3, sentinelName, sentinelMasterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tsentinelSlave1, err = startRedis(\n\t\t\tsentinelSlave1Port, \"--slaveof\", \"127.0.0.1\", sentinelMasterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tsentinelSlave2, err = startRedis(\n\t\t\tsentinelSlave2Port, \"--slaveof\", \"127.0.0.1\", sentinelMasterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(startCluster(ctx, cluster)).NotTo(HaveOccurred())\n\t} else {\n\t\tredisPort = rediStackPort\n\t\tredisAddr = rediStackAddr\n\t}\n})\n\nvar _ = AfterSuite(func() {\n\tif !RECluster {\n\t\tExpect(cluster.Close()).NotTo(HaveOccurred())\n\n\t\tfor _, p := range processes {\n\t\t\tExpect(p.Close()).NotTo(HaveOccurred())\n\t\t}\n\t}\n\tprocesses = nil\n})\n\nfunc TestGinkgoSuite(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"go-redis\")\n}\n\n//------------------------------------------------------------------------------\n\nfunc redisOptions() *redis.Options {\n\tif RECluster {\n\t\treturn &redis.Options{\n\t\t\tAddr: redisAddr,\n\t\t\tDB:   0,\n\n\t\t\tDialTimeout:           10 * time.Second,\n\t\t\tReadTimeout:           30 * time.Second,\n\t\t\tWriteTimeout:          30 * time.Second,\n\t\t\tContextTimeoutEnabled: true,\n\n\t\t\tMaxRetries: -1,\n\t\t\tPoolSize:   10,\n\n\t\t\tPoolTimeout:     30 * time.Second,\n\t\t\tConnMaxIdleTime: time.Minute,\n\t\t}\n\t}\n\treturn &redis.Options{\n\t\tAddr: redisAddr,\n\t\tDB:   15,\n\n\t\tDialTimeout:           10 * time.Second,\n\t\tReadTimeout:           30 * time.Second,\n\t\tWriteTimeout:          30 * time.Second,\n\t\tContextTimeoutEnabled: true,\n\n\t\tMaxRetries: -1,\n\n\t\tPoolSize:        10,\n\t\tPoolTimeout:     30 * time.Second,\n\t\tConnMaxIdleTime: time.Minute,\n\t}\n}\n\nfunc redisClusterOptions() *redis.ClusterOptions {\n\treturn &redis.ClusterOptions{\n\t\tDialTimeout:  10 * time.Second,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\n\t\tMaxRedirects: 8,\n\n\t\tPoolSize:        10,\n\t\tPoolTimeout:     30 * time.Second,\n\t\tConnMaxIdleTime: time.Minute,\n\t}\n}\n\nfunc redisRingOptions() *redis.RingOptions {\n\treturn &redis.RingOptions{\n\t\tAddrs: map[string]string{\n\t\t\t\"ringShardOne\": \":\" + ringShard1Port,\n\t\t\t\"ringShardTwo\": \":\" + ringShard2Port,\n\t\t},\n\n\t\tDialTimeout:  10 * time.Second,\n\t\tReadTimeout:  30 * time.Second,\n\t\tWriteTimeout: 30 * time.Second,\n\n\t\tMaxRetries: -1,\n\n\t\tPoolSize:        10,\n\t\tPoolTimeout:     30 * time.Second,\n\t\tConnMaxIdleTime: time.Minute,\n\t}\n}\n\nfunc performAsync(n int, cbs ...func(int)) *sync.WaitGroup {\n\tvar wg sync.WaitGroup\n\tfor _, cb := range cbs {\n\t\twg.Add(n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tgo func(cb func(int), i int) {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\tcb(i)\n\t\t\t}(cb, i)\n\t\t}\n\t}\n\treturn &wg\n}\n\nfunc perform(n int, cbs ...func(int)) {\n\twg := performAsync(n, cbs...)\n\twg.Wait()\n}\n\nfunc eventually(fn func() error, timeout time.Duration) error {\n\terrCh := make(chan error, 1)\n\tdone := make(chan struct{})\n\texit := make(chan struct{})\n\n\tgo func() {\n\t\tfor {\n\t\t\terr := fn()\n\t\t\tif err == nil {\n\t\t\t\tclose(done)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase errCh <- err:\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase <-exit:\n\t\t\t\treturn\n\t\t\tcase <-time.After(timeout / 100):\n\t\t\t}\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-done:\n\t\treturn nil\n\tcase <-time.After(timeout):\n\t\tclose(exit)\n\t\tselect {\n\t\tcase err := <-errCh:\n\t\t\treturn err\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"timeout after %s without an error\", timeout)\n\t\t}\n\t}\n}\n\nfunc execCmd(name string, args ...string) (*os.Process, error) {\n\tcmd := exec.Command(name, args...)\n\tif testing.Verbose() {\n\t\tcmd.Stdout = os.Stdout\n\t\tcmd.Stderr = os.Stderr\n\t}\n\treturn cmd.Process, cmd.Start()\n}\n\nfunc connectTo(port string) (*redis.Client, error) {\n\tclient := redis.NewClient(&redis.Options{\n\t\tAddr:       \":\" + port,\n\t\tMaxRetries: -1,\n\t})\n\n\terr := eventually(func() error {\n\t\treturn client.Ping(ctx).Err()\n\t}, 30*time.Second)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn client, nil\n}\n\ntype redisProcess struct {\n\t*os.Process\n\t*redis.Client\n}\n\nfunc (p *redisProcess) Close() error {\n\tif err := p.Kill(); err != nil {\n\t\treturn err\n\t}\n\n\terr := eventually(func() error {\n\t\tif err := p.Client.Ping(ctx).Err(); err != nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"client %s is not shutdown\", p.Options().Addr)\n\t}, 10*time.Second)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tp.Client.Close()\n\treturn nil\n}\n\nvar (\n\tredisServerBin, _    = filepath.Abs(filepath.Join(\"testdata\", \"redis\", \"src\", \"redis-server\"))\n\tredisServerConf, _   = filepath.Abs(filepath.Join(\"testdata\", \"redis\", \"redis.conf\"))\n\tredisSentinelConf, _ = filepath.Abs(filepath.Join(\"testdata\", \"redis\", \"sentinel.conf\"))\n)\n\nfunc redisDir(port string) (string, error) {\n\tdir, err := filepath.Abs(filepath.Join(\"testdata\", \"instances\", port))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := os.RemoveAll(dir); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := os.MkdirAll(dir, 0o775); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn dir, nil\n}\n\nfunc startRedis(port string, args ...string) (*redisProcess, error) {\n\tdir, err := redisDir(port)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := exec.Command(\"cp\", \"-f\", redisServerConf, dir).Run(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tbaseArgs := []string{filepath.Join(dir, \"redis.conf\"), \"--port\", port, \"--dir\", dir, \"--enable-module-command\", \"yes\"}\n\tprocess, err := execCmd(redisServerBin, append(baseArgs, args...)...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient, err := connectTo(port)\n\tif err != nil {\n\t\tprocess.Kill()\n\t\treturn nil, err\n\t}\n\n\tp := &redisProcess{process, client}\n\tregisterProcess(port, p)\n\treturn p, nil\n}\n\nfunc startSentinel(port, masterName, masterPort string) (*redisProcess, error) {\n\tdir, err := redisDir(port)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsentinelConf := filepath.Join(dir, \"sentinel.conf\")\n\tif err := os.WriteFile(sentinelConf, nil, 0o644); err != nil {\n\t\treturn nil, err\n\t}\n\n\tprocess, err := execCmd(redisServerBin, sentinelConf, \"--sentinel\", \"--port\", port, \"--dir\", dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient, err := connectTo(port)\n\tif err != nil {\n\t\tprocess.Kill()\n\t\treturn nil, err\n\t}\n\n\t// set down-after-milliseconds=2000\n\t// link: https://github.com/redis/redis/issues/8607\n\tfor _, cmd := range []*redis.StatusCmd{\n\t\tredis.NewStatusCmd(ctx, \"SENTINEL\", \"MONITOR\", masterName, \"127.0.0.1\", masterPort, \"2\"),\n\t\tredis.NewStatusCmd(ctx, \"SENTINEL\", \"SET\", masterName, \"down-after-milliseconds\", \"2000\"),\n\t\tredis.NewStatusCmd(ctx, \"SENTINEL\", \"SET\", masterName, \"failover-timeout\", \"1000\"),\n\t\tredis.NewStatusCmd(ctx, \"SENTINEL\", \"SET\", masterName, \"parallel-syncs\", \"1\"),\n\t} {\n\t\tclient.Process(ctx, cmd)\n\t\tif err := cmd.Err(); err != nil {\n\t\t\tprocess.Kill()\n\t\t\treturn nil, fmt.Errorf(\"%s failed: %w\", cmd, err)\n\t\t}\n\t}\n\n\tp := &redisProcess{process, client}\n\tregisterProcess(port, p)\n\treturn p, nil\n}\n\n//------------------------------------------------------------------------------\n\ntype badConnError string\n\nfunc (e badConnError) Error() string   { return string(e) }\nfunc (e badConnError) Timeout() bool   { return true }\nfunc (e badConnError) Temporary() bool { return false }\n\ntype badConn struct {\n\tnet.TCPConn\n\n\treadDelay, writeDelay time.Duration\n\treadErr, writeErr     error\n}\n\nvar _ net.Conn = &badConn{}\n\nfunc (cn *badConn) SetReadDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (cn *badConn) SetWriteDeadline(t time.Time) error {\n\treturn nil\n}\n\nfunc (cn *badConn) Read([]byte) (int, error) {\n\tif cn.readDelay != 0 {\n\t\ttime.Sleep(cn.readDelay)\n\t}\n\tif cn.readErr != nil {\n\t\treturn 0, cn.readErr\n\t}\n\treturn 0, badConnError(\"bad connection\")\n}\n\nfunc (cn *badConn) Write([]byte) (int, error) {\n\tif cn.writeDelay != 0 {\n\t\ttime.Sleep(cn.writeDelay)\n\t}\n\tif cn.writeErr != nil {\n\t\treturn 0, cn.writeErr\n\t}\n\treturn 0, badConnError(\"bad connection\")\n}\n\n//------------------------------------------------------------------------------\n\ntype hook struct {\n\tdialHook            func(hook redis.DialHook) redis.DialHook\n\tprocessHook         func(hook redis.ProcessHook) redis.ProcessHook\n\tprocessPipelineHook func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook\n}\n\nfunc (h *hook) DialHook(hook redis.DialHook) redis.DialHook {\n\tif h.dialHook != nil {\n\t\treturn h.dialHook(hook)\n\t}\n\treturn hook\n}\n\nfunc (h *hook) ProcessHook(hook redis.ProcessHook) redis.ProcessHook {\n\tif h.processHook != nil {\n\t\treturn h.processHook(hook)\n\t}\n\treturn hook\n}\n\nfunc (h *hook) ProcessPipelineHook(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\tif h.processPipelineHook != nil {\n\t\treturn h.processPipelineHook(hook)\n\t}\n\treturn hook\n}\n"
        },
        {
          "name": "monitor_test.go",
          "type": "blob",
          "size": 2.962890625,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\n// This test is for manual use and is not part of the CI of Go-Redis.\nvar _ = Describe(\"Monitor command\", Label(\"monitor\"), func() {\n\tctx := context.TODO()\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tif os.Getenv(\"RUN_MONITOR_TEST\") != \"true\" {\n\t\t\tSkip(\"Skipping Monitor command test. Set RUN_MONITOR_TEST=true to run it.\")\n\t\t}\n\t\tclient = redis.NewClient(&redis.Options{Addr: \":6379\"})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should monitor\", Label(\"monitor\"), func() {\n\t\tress := make(chan string)\n\t\tclient1 := redis.NewClient(&redis.Options{Addr: rediStackAddr})\n\t\tmn := client1.Monitor(ctx, ress)\n\t\tmn.Start()\n\t\t// Wait for the Redis server to be in monitoring mode.\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tclient.Set(ctx, \"foo\", \"bar\", 0)\n\t\tclient.Set(ctx, \"bar\", \"baz\", 0)\n\t\tclient.Set(ctx, \"bap\", 8, 0)\n\t\tclient.Get(ctx, \"bap\")\n\t\tlst := []string{}\n\t\tfor i := 0; i < 5; i++ {\n\t\t\ts := <-ress\n\t\t\tlst = append(lst, s)\n\t\t}\n\t\tmn.Stop()\n\t\tExpect(lst[0]).To(ContainSubstring(\"OK\"))\n\t\tExpect(lst[1]).To(ContainSubstring(`\"set\" \"foo\" \"bar\"`))\n\t\tExpect(lst[2]).To(ContainSubstring(`\"set\" \"bar\" \"baz\"`))\n\t\tExpect(lst[3]).To(ContainSubstring(`\"set\" \"bap\" \"8\"`))\n\t})\n})\n\nfunc TestMonitorCommand(t *testing.T) {\n\tif os.Getenv(\"RUN_MONITOR_TEST\") != \"true\" {\n\t\tt.Skip(\"Skipping Monitor command test. Set RUN_MONITOR_TEST=true to run it.\")\n\t}\n\n\tctx := context.TODO()\n\tclient := redis.NewClient(&redis.Options{Addr: \":6379\"})\n\tif err := client.FlushDB(ctx).Err(); err != nil {\n\t\tt.Fatalf(\"FlushDB failed: %v\", err)\n\t}\n\n\tdefer func() {\n\t\tif err := client.Close(); err != nil {\n\t\t\tt.Fatalf(\"Close failed: %v\", err)\n\t\t}\n\t}()\n\n\tress := make(chan string, 10)                             // Buffer to prevent blocking\n\tclient1 := redis.NewClient(&redis.Options{Addr: \":6379\"}) // Adjust the Addr field as necessary\n\tmn := client1.Monitor(ctx, ress)\n\tmn.Start()\n\t// Wait for the Redis server to be in monitoring mode.\n\ttime.Sleep(100 * time.Millisecond)\n\tclient.Set(ctx, \"foo\", \"bar\", 0)\n\tclient.Set(ctx, \"bar\", \"baz\", 0)\n\tclient.Set(ctx, \"bap\", 8, 0)\n\tclient.Get(ctx, \"bap\")\n\tmn.Stop()\n\tvar lst []string\n\tfor i := 0; i < 5; i++ {\n\t\ts := <-ress\n\t\tlst = append(lst, s)\n\t}\n\n\t// Assertions\n\tif !containsSubstring(lst[0], \"OK\") {\n\t\tt.Errorf(\"Expected lst[0] to contain 'OK', got %s\", lst[0])\n\t}\n\tif !containsSubstring(lst[1], `\"set\" \"foo\" \"bar\"`) {\n\t\tt.Errorf(`Expected lst[1] to contain '\"set\" \"foo\" \"bar\"', got %s`, lst[1])\n\t}\n\tif !containsSubstring(lst[2], `\"set\" \"bar\" \"baz\"`) {\n\t\tt.Errorf(`Expected lst[2] to contain '\"set\" \"bar\" \"baz\"', got %s`, lst[2])\n\t}\n\tif !containsSubstring(lst[3], `\"set\" \"bap\" \"8\"`) {\n\t\tt.Errorf(`Expected lst[3] to contain '\"set\" \"bap\" \"8\"', got %s`, lst[3])\n\t}\n}\n\nfunc containsSubstring(s, substr string) bool {\n\treturn strings.Contains(s, substr)\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 15.0458984375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n)\n\n// Limiter is the interface of a rate limiter or a circuit breaker.\ntype Limiter interface {\n\t// Allow returns nil if operation is allowed or an error otherwise.\n\t// If operation is allowed client must ReportResult of the operation\n\t// whether it is a success or a failure.\n\tAllow() error\n\t// ReportResult reports the result of the previously allowed operation.\n\t// nil indicates a success, non-nil error usually indicates a failure.\n\tReportResult(result error)\n}\n\n// Options keeps the settings to set up redis connection.\ntype Options struct {\n\t// The network type, either tcp or unix.\n\t// Default is tcp.\n\tNetwork string\n\t// host:port address.\n\tAddr string\n\n\t// ClientName will execute the `CLIENT SETNAME ClientName` command for each conn.\n\tClientName string\n\n\t// Dialer creates new network connection and has priority over\n\t// Network and Addr options.\n\tDialer func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\t// Hook that is called when new connection is established.\n\tOnConnect func(ctx context.Context, cn *Conn) error\n\n\t// Protocol 2 or 3. Use the version to negotiate RESP version with redis-server.\n\t// Default is 3.\n\tProtocol int\n\t// Use the specified Username to authenticate the current connection\n\t// with one of the connections defined in the ACL list when connecting\n\t// to a Redis 6.0 instance, or greater, that is using the Redis ACL system.\n\tUsername string\n\t// Optional password. Must match the password specified in the\n\t// requirepass server configuration option (if connecting to a Redis 5.0 instance, or lower),\n\t// or the User Password when connecting to a Redis 6.0 instance, or greater,\n\t// that is using the Redis ACL system.\n\tPassword string\n\t// CredentialsProvider allows the username and password to be updated\n\t// before reconnecting. It should return the current username and password.\n\tCredentialsProvider func() (username string, password string)\n\n\t// CredentialsProviderContext is an enhanced parameter of CredentialsProvider,\n\t// done to maintain API compatibility. In the future,\n\t// there might be a merge between CredentialsProviderContext and CredentialsProvider.\n\t// There will be a conflict between them; if CredentialsProviderContext exists, we will ignore CredentialsProvider.\n\tCredentialsProviderContext func(ctx context.Context) (username string, password string, err error)\n\n\t// Database to be selected after connecting to the server.\n\tDB int\n\n\t// Maximum number of retries before giving up.\n\t// Default is 3 retries; -1 (not 0) disables retries.\n\tMaxRetries int\n\t// Minimum backoff between each retry.\n\t// Default is 8 milliseconds; -1 disables backoff.\n\tMinRetryBackoff time.Duration\n\t// Maximum backoff between each retry.\n\t// Default is 512 milliseconds; -1 disables backoff.\n\tMaxRetryBackoff time.Duration\n\n\t// Dial timeout for establishing new connections.\n\t// Default is 5 seconds.\n\tDialTimeout time.Duration\n\t// Timeout for socket reads. If reached, commands will fail\n\t// with a timeout instead of blocking. Supported values:\n\t//   - `0` - default timeout (3 seconds).\n\t//   - `-1` - no timeout (block indefinitely).\n\t//   - `-2` - disables SetReadDeadline calls completely.\n\tReadTimeout time.Duration\n\t// Timeout for socket writes. If reached, commands will fail\n\t// with a timeout instead of blocking.  Supported values:\n\t//   - `0` - default timeout (3 seconds).\n\t//   - `-1` - no timeout (block indefinitely).\n\t//   - `-2` - disables SetWriteDeadline calls completely.\n\tWriteTimeout time.Duration\n\t// ContextTimeoutEnabled controls whether the client respects context timeouts and deadlines.\n\t// See https://redis.uptrace.dev/guide/go-redis-debugging.html#timeouts\n\tContextTimeoutEnabled bool\n\n\t// Type of connection pool.\n\t// true for FIFO pool, false for LIFO pool.\n\t// Note that FIFO has slightly higher overhead compared to LIFO,\n\t// but it helps closing idle connections faster reducing the pool size.\n\tPoolFIFO bool\n\t// Base number of socket connections.\n\t// Default is 10 connections per every available CPU as reported by runtime.GOMAXPROCS.\n\t// If there is not enough connections in the pool, new connections will be allocated in excess of PoolSize,\n\t// you can limit it through MaxActiveConns\n\tPoolSize int\n\t// Amount of time client waits for connection if all connections\n\t// are busy before returning an error.\n\t// Default is ReadTimeout + 1 second.\n\tPoolTimeout time.Duration\n\t// Minimum number of idle connections which is useful when establishing\n\t// new connection is slow.\n\t// Default is 0. the idle connections are not closed by default.\n\tMinIdleConns int\n\t// Maximum number of idle connections.\n\t// Default is 0. the idle connections are not closed by default.\n\tMaxIdleConns int\n\t// Maximum number of connections allocated by the pool at a given time.\n\t// When zero, there is no limit on the number of connections in the pool.\n\tMaxActiveConns int\n\t// ConnMaxIdleTime is the maximum amount of time a connection may be idle.\n\t// Should be less than server's timeout.\n\t//\n\t// Expired connections may be closed lazily before reuse.\n\t// If d <= 0, connections are not closed due to a connection's idle time.\n\t//\n\t// Default is 30 minutes. -1 disables idle timeout check.\n\tConnMaxIdleTime time.Duration\n\t// ConnMaxLifetime is the maximum amount of time a connection may be reused.\n\t//\n\t// Expired connections may be closed lazily before reuse.\n\t// If <= 0, connections are not closed due to a connection's age.\n\t//\n\t// Default is to not close idle connections.\n\tConnMaxLifetime time.Duration\n\n\t// TLS Config to use. When set, TLS will be negotiated.\n\tTLSConfig *tls.Config\n\n\t// Limiter interface used to implement circuit breaker or rate limiter.\n\tLimiter Limiter\n\n\t// Enables read only queries on slave/follower nodes.\n\treadOnly bool\n\n\t// Disable set-lib on connect. Default is false.\n\tDisableIndentity bool\n\n\t// Add suffix to client name. Default is empty.\n\tIdentitySuffix string\n\n\t// Enable Unstable mode for Redis Search module with RESP3.\n\tUnstableResp3 bool\n}\n\nfunc (opt *Options) init() {\n\tif opt.Addr == \"\" {\n\t\topt.Addr = \"localhost:6379\"\n\t}\n\tif opt.Network == \"\" {\n\t\tif strings.HasPrefix(opt.Addr, \"/\") {\n\t\t\topt.Network = \"unix\"\n\t\t} else {\n\t\t\topt.Network = \"tcp\"\n\t\t}\n\t}\n\tif opt.DialTimeout == 0 {\n\t\topt.DialTimeout = 5 * time.Second\n\t}\n\tif opt.Dialer == nil {\n\t\topt.Dialer = NewDialer(opt)\n\t}\n\tif opt.PoolSize == 0 {\n\t\topt.PoolSize = 10 * runtime.GOMAXPROCS(0)\n\t}\n\tswitch opt.ReadTimeout {\n\tcase -2:\n\t\topt.ReadTimeout = -1\n\tcase -1:\n\t\topt.ReadTimeout = 0\n\tcase 0:\n\t\topt.ReadTimeout = 3 * time.Second\n\t}\n\tswitch opt.WriteTimeout {\n\tcase -2:\n\t\topt.WriteTimeout = -1\n\tcase -1:\n\t\topt.WriteTimeout = 0\n\tcase 0:\n\t\topt.WriteTimeout = opt.ReadTimeout\n\t}\n\tif opt.PoolTimeout == 0 {\n\t\tif opt.ReadTimeout > 0 {\n\t\t\topt.PoolTimeout = opt.ReadTimeout + time.Second\n\t\t} else {\n\t\t\topt.PoolTimeout = 30 * time.Second\n\t\t}\n\t}\n\tif opt.ConnMaxIdleTime == 0 {\n\t\topt.ConnMaxIdleTime = 30 * time.Minute\n\t}\n\n\tif opt.MaxRetries == -1 {\n\t\topt.MaxRetries = 0\n\t} else if opt.MaxRetries == 0 {\n\t\topt.MaxRetries = 3\n\t}\n\tswitch opt.MinRetryBackoff {\n\tcase -1:\n\t\topt.MinRetryBackoff = 0\n\tcase 0:\n\t\topt.MinRetryBackoff = 8 * time.Millisecond\n\t}\n\tswitch opt.MaxRetryBackoff {\n\tcase -1:\n\t\topt.MaxRetryBackoff = 0\n\tcase 0:\n\t\topt.MaxRetryBackoff = 512 * time.Millisecond\n\t}\n}\n\nfunc (opt *Options) clone() *Options {\n\tclone := *opt\n\treturn &clone\n}\n\n// NewDialer returns a function that will be used as the default dialer\n// when none is specified in Options.Dialer.\nfunc NewDialer(opt *Options) func(context.Context, string, string) (net.Conn, error) {\n\treturn func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\tnetDialer := &net.Dialer{\n\t\t\tTimeout:   opt.DialTimeout,\n\t\t\tKeepAlive: 5 * time.Minute,\n\t\t}\n\t\tif opt.TLSConfig == nil {\n\t\t\treturn netDialer.DialContext(ctx, network, addr)\n\t\t}\n\t\treturn tls.DialWithDialer(netDialer, network, addr, opt.TLSConfig)\n\t}\n}\n\n// ParseURL parses a URL into Options that can be used to connect to Redis.\n// Scheme is required.\n// There are two connection types: by tcp socket and by unix socket.\n// Tcp connection:\n//\n//\tredis://<user>:<password>@<host>:<port>/<db_number>\n//\n// Unix connection:\n//\n//\tunix://<user>:<password>@</path/to/redis.sock>?db=<db_number>\n//\n// Most Option fields can be set using query parameters, with the following restrictions:\n//   - field names are mapped using snake-case conversion: to set MaxRetries, use max_retries\n//   - only scalar type fields are supported (bool, int, time.Duration)\n//   - for time.Duration fields, values must be a valid input for time.ParseDuration();\n//     additionally a plain integer as value (i.e. without unit) is interpreted as seconds\n//   - to disable a duration field, use value less than or equal to 0; to use the default\n//     value, leave the value blank or remove the parameter\n//   - only the last value is interpreted if a parameter is given multiple times\n//   - fields \"network\", \"addr\", \"username\" and \"password\" can only be set using other\n//     URL attributes (scheme, host, userinfo, resp.), query parameters using these\n//     names will be treated as unknown parameters\n//   - unknown parameter names will result in an error\n//\n// Examples:\n//\n//\tredis://user:password@localhost:6789/3?dial_timeout=3&db=1&read_timeout=6s&max_retries=2\n//\tis equivalent to:\n//\t&Options{\n//\t\tNetwork:     \"tcp\",\n//\t\tAddr:        \"localhost:6789\",\n//\t\tDB:          1,               // path \"/3\" was overridden by \"&db=1\"\n//\t\tDialTimeout: 3 * time.Second, // no time unit = seconds\n//\t\tReadTimeout: 6 * time.Second,\n//\t\tMaxRetries:  2,\n//\t}\nfunc ParseURL(redisURL string) (*Options, error) {\n\tu, err := url.Parse(redisURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch u.Scheme {\n\tcase \"redis\", \"rediss\":\n\t\treturn setupTCPConn(u)\n\tcase \"unix\":\n\t\treturn setupUnixConn(u)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"redis: invalid URL scheme: %s\", u.Scheme)\n\t}\n}\n\nfunc setupTCPConn(u *url.URL) (*Options, error) {\n\to := &Options{Network: \"tcp\"}\n\n\to.Username, o.Password = getUserPassword(u)\n\n\th, p := getHostPortWithDefaults(u)\n\to.Addr = net.JoinHostPort(h, p)\n\n\tf := strings.FieldsFunc(u.Path, func(r rune) bool {\n\t\treturn r == '/'\n\t})\n\tswitch len(f) {\n\tcase 0:\n\t\to.DB = 0\n\tcase 1:\n\t\tvar err error\n\t\tif o.DB, err = strconv.Atoi(f[0]); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"redis: invalid database number: %q\", f[0])\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"redis: invalid URL path: %s\", u.Path)\n\t}\n\n\tif u.Scheme == \"rediss\" {\n\t\to.TLSConfig = &tls.Config{\n\t\t\tServerName: h,\n\t\t\tMinVersion: tls.VersionTLS12,\n\t\t}\n\t}\n\n\treturn setupConnParams(u, o)\n}\n\n// getHostPortWithDefaults is a helper function that splits the url into\n// a host and a port. If the host is missing, it defaults to localhost\n// and if the port is missing, it defaults to 6379.\nfunc getHostPortWithDefaults(u *url.URL) (string, string) {\n\thost, port, err := net.SplitHostPort(u.Host)\n\tif err != nil {\n\t\thost = u.Host\n\t}\n\tif host == \"\" {\n\t\thost = \"localhost\"\n\t}\n\tif port == \"\" {\n\t\tport = \"6379\"\n\t}\n\treturn host, port\n}\n\nfunc setupUnixConn(u *url.URL) (*Options, error) {\n\to := &Options{\n\t\tNetwork: \"unix\",\n\t}\n\n\tif strings.TrimSpace(u.Path) == \"\" { // path is required with unix connection\n\t\treturn nil, errors.New(\"redis: empty unix socket path\")\n\t}\n\to.Addr = u.Path\n\to.Username, o.Password = getUserPassword(u)\n\treturn setupConnParams(u, o)\n}\n\ntype queryOptions struct {\n\tq   url.Values\n\terr error\n}\n\nfunc (o *queryOptions) has(name string) bool {\n\treturn len(o.q[name]) > 0\n}\n\nfunc (o *queryOptions) string(name string) string {\n\tvs := o.q[name]\n\tif len(vs) == 0 {\n\t\treturn \"\"\n\t}\n\tdelete(o.q, name) // enable detection of unknown parameters\n\treturn vs[len(vs)-1]\n}\n\nfunc (o *queryOptions) strings(name string) []string {\n\tvs := o.q[name]\n\tdelete(o.q, name)\n\treturn vs\n}\n\nfunc (o *queryOptions) int(name string) int {\n\ts := o.string(name)\n\tif s == \"\" {\n\t\treturn 0\n\t}\n\ti, err := strconv.Atoi(s)\n\tif err == nil {\n\t\treturn i\n\t}\n\tif o.err == nil {\n\t\to.err = fmt.Errorf(\"redis: invalid %s number: %s\", name, err)\n\t}\n\treturn 0\n}\n\nfunc (o *queryOptions) duration(name string) time.Duration {\n\ts := o.string(name)\n\tif s == \"\" {\n\t\treturn 0\n\t}\n\t// try plain number first\n\tif i, err := strconv.Atoi(s); err == nil {\n\t\tif i <= 0 {\n\t\t\t// disable timeouts\n\t\t\treturn -1\n\t\t}\n\t\treturn time.Duration(i) * time.Second\n\t}\n\tdur, err := time.ParseDuration(s)\n\tif err == nil {\n\t\treturn dur\n\t}\n\tif o.err == nil {\n\t\to.err = fmt.Errorf(\"redis: invalid %s duration: %w\", name, err)\n\t}\n\treturn 0\n}\n\nfunc (o *queryOptions) bool(name string) bool {\n\tswitch s := o.string(name); s {\n\tcase \"true\", \"1\":\n\t\treturn true\n\tcase \"false\", \"0\", \"\":\n\t\treturn false\n\tdefault:\n\t\tif o.err == nil {\n\t\t\to.err = fmt.Errorf(\"redis: invalid %s boolean: expected true/false/1/0 or an empty string, got %q\", name, s)\n\t\t}\n\t\treturn false\n\t}\n}\n\nfunc (o *queryOptions) remaining() []string {\n\tif len(o.q) == 0 {\n\t\treturn nil\n\t}\n\tkeys := make([]string, 0, len(o.q))\n\tfor k := range o.q {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}\n\n// setupConnParams converts query parameters in u to option value in o.\nfunc setupConnParams(u *url.URL, o *Options) (*Options, error) {\n\tq := queryOptions{q: u.Query()}\n\n\t// compat: a future major release may use q.int(\"db\")\n\tif tmp := q.string(\"db\"); tmp != \"\" {\n\t\tdb, err := strconv.Atoi(tmp)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"redis: invalid database number: %w\", err)\n\t\t}\n\t\to.DB = db\n\t}\n\n\to.Protocol = q.int(\"protocol\")\n\to.ClientName = q.string(\"client_name\")\n\to.MaxRetries = q.int(\"max_retries\")\n\to.MinRetryBackoff = q.duration(\"min_retry_backoff\")\n\to.MaxRetryBackoff = q.duration(\"max_retry_backoff\")\n\to.DialTimeout = q.duration(\"dial_timeout\")\n\to.ReadTimeout = q.duration(\"read_timeout\")\n\to.WriteTimeout = q.duration(\"write_timeout\")\n\to.PoolFIFO = q.bool(\"pool_fifo\")\n\to.PoolSize = q.int(\"pool_size\")\n\to.PoolTimeout = q.duration(\"pool_timeout\")\n\to.MinIdleConns = q.int(\"min_idle_conns\")\n\to.MaxIdleConns = q.int(\"max_idle_conns\")\n\to.MaxActiveConns = q.int(\"max_active_conns\")\n\tif q.has(\"conn_max_idle_time\") {\n\t\to.ConnMaxIdleTime = q.duration(\"conn_max_idle_time\")\n\t} else {\n\t\to.ConnMaxIdleTime = q.duration(\"idle_timeout\")\n\t}\n\tif q.has(\"conn_max_lifetime\") {\n\t\to.ConnMaxLifetime = q.duration(\"conn_max_lifetime\")\n\t} else {\n\t\to.ConnMaxLifetime = q.duration(\"max_conn_age\")\n\t}\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\t// any parameters left?\n\tif r := q.remaining(); len(r) > 0 {\n\t\treturn nil, fmt.Errorf(\"redis: unexpected option: %s\", strings.Join(r, \", \"))\n\t}\n\n\treturn o, nil\n}\n\nfunc getUserPassword(u *url.URL) (string, string) {\n\tvar user, password string\n\tif u.User != nil {\n\t\tuser = u.User.Username()\n\t\tif p, ok := u.User.Password(); ok {\n\t\t\tpassword = p\n\t\t}\n\t}\n\treturn user, password\n}\n\nfunc newConnPool(\n\topt *Options,\n\tdialer func(ctx context.Context, network, addr string) (net.Conn, error),\n) *pool.ConnPool {\n\treturn pool.NewConnPool(&pool.Options{\n\t\tDialer: func(ctx context.Context) (net.Conn, error) {\n\t\t\treturn dialer(ctx, opt.Network, opt.Addr)\n\t\t},\n\t\tPoolFIFO:        opt.PoolFIFO,\n\t\tPoolSize:        opt.PoolSize,\n\t\tPoolTimeout:     opt.PoolTimeout,\n\t\tMinIdleConns:    opt.MinIdleConns,\n\t\tMaxIdleConns:    opt.MaxIdleConns,\n\t\tMaxActiveConns:  opt.MaxActiveConns,\n\t\tConnMaxIdleTime: opt.ConnMaxIdleTime,\n\t\tConnMaxLifetime: opt.ConnMaxLifetime,\n\t})\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 7.6005859375,
          "content": "//go:build go1.7\n\npackage redis\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestParseURL(t *testing.T) {\n\tcases := []struct {\n\t\turl string\n\t\to   *Options // expected value\n\t\terr error\n\t}{\n\t\t{\n\t\t\turl: \"redis://localhost:123/1\",\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 1},\n\t\t}, {\n\t\t\turl: \"redis://localhost:123\",\n\t\t\to:   &Options{Addr: \"localhost:123\"},\n\t\t}, {\n\t\t\turl: \"redis://localhost/1\",\n\t\t\to:   &Options{Addr: \"localhost:6379\", DB: 1},\n\t\t}, {\n\t\t\turl: \"redis://12345\",\n\t\t\to:   &Options{Addr: \"12345:6379\"},\n\t\t}, {\n\t\t\turl: \"rediss://localhost:123\",\n\t\t\to:   &Options{Addr: \"localhost:123\", TLSConfig: &tls.Config{ /* no deep comparison */ }},\n\t\t}, {\n\t\t\turl: \"redis://:bar@localhost:123\",\n\t\t\to:   &Options{Addr: \"localhost:123\", Password: \"bar\"},\n\t\t}, {\n\t\t\turl: \"redis://foo@localhost:123\",\n\t\t\to:   &Options{Addr: \"localhost:123\", Username: \"foo\"},\n\t\t}, {\n\t\t\turl: \"redis://foo:bar@localhost:123\",\n\t\t\to:   &Options{Addr: \"localhost:123\", Username: \"foo\", Password: \"bar\"},\n\t\t}, {\n\t\t\t// multiple params\n\t\t\turl: \"redis://localhost:123/?db=2&read_timeout=2&pool_fifo=true\",\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 2, ReadTimeout: 2 * time.Second, PoolFIFO: true},\n\t\t}, {\n\t\t\t// special case handling for disabled timeouts\n\t\t\turl: \"redis://localhost:123/?db=2&conn_max_idle_time=0\",\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 2, ConnMaxIdleTime: -1},\n\t\t}, {\n\t\t\t// negative values disable timeouts as well\n\t\t\turl: \"redis://localhost:123/?db=2&conn_max_idle_time=-1\",\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 2, ConnMaxIdleTime: -1},\n\t\t}, {\n\t\t\t// absent timeout values will use defaults\n\t\t\turl: \"redis://localhost:123/?db=2&conn_max_idle_time=\",\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 2, ConnMaxIdleTime: 0},\n\t\t}, {\n\t\t\turl: \"redis://localhost:123/?db=2&conn_max_idle_time\", // missing \"=\" at the end\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 2, ConnMaxIdleTime: 0},\n\t\t}, {\n\t\t\turl: \"redis://localhost:123/?db=2&client_name=hi\", // client name\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 2, ClientName: \"hi\"},\n\t\t}, {\n\t\t\turl: \"redis://localhost:123/?db=2&protocol=2\", // RESP Protocol\n\t\t\to:   &Options{Addr: \"localhost:123\", DB: 2, Protocol: 2},\n\t\t}, {\n\t\t\turl: \"unix:///tmp/redis.sock\",\n\t\t\to:   &Options{Addr: \"/tmp/redis.sock\"},\n\t\t}, {\n\t\t\turl: \"unix://foo:bar@/tmp/redis.sock\",\n\t\t\to:   &Options{Addr: \"/tmp/redis.sock\", Username: \"foo\", Password: \"bar\"},\n\t\t}, {\n\t\t\turl: \"unix://foo:bar@/tmp/redis.sock?db=3\",\n\t\t\to:   &Options{Addr: \"/tmp/redis.sock\", Username: \"foo\", Password: \"bar\", DB: 3},\n\t\t}, {\n\t\t\t// invalid db format\n\t\t\turl: \"unix://foo:bar@/tmp/redis.sock?db=test\",\n\t\t\terr: errors.New(`redis: invalid database number: strconv.Atoi: parsing \"test\": invalid syntax`),\n\t\t}, {\n\t\t\t// invalid int value\n\t\t\turl: \"redis://localhost/?pool_size=five\",\n\t\t\terr: errors.New(`redis: invalid pool_size number: strconv.Atoi: parsing \"five\": invalid syntax`),\n\t\t}, {\n\t\t\t// invalid bool value\n\t\t\turl: \"redis://localhost/?pool_fifo=yes\",\n\t\t\terr: errors.New(`redis: invalid pool_fifo boolean: expected true/false/1/0 or an empty string, got \"yes\"`),\n\t\t}, {\n\t\t\t// it returns first error\n\t\t\turl: \"redis://localhost/?db=foo&pool_size=five\",\n\t\t\terr: errors.New(`redis: invalid database number: strconv.Atoi: parsing \"foo\": invalid syntax`),\n\t\t}, {\n\t\t\turl: \"redis://localhost/?abc=123\",\n\t\t\terr: errors.New(\"redis: unexpected option: abc\"),\n\t\t}, {\n\t\t\turl: \"redis://foo@localhost/?username=bar\",\n\t\t\terr: errors.New(\"redis: unexpected option: username\"),\n\t\t}, {\n\t\t\turl: \"redis://localhost/?wrte_timout=10s&abc=123\",\n\t\t\terr: errors.New(\"redis: unexpected option: abc, wrte_timout\"),\n\t\t}, {\n\t\t\turl: \"http://google.com\",\n\t\t\terr: errors.New(\"redis: invalid URL scheme: http\"),\n\t\t}, {\n\t\t\turl: \"redis://localhost/1/2/3/4\",\n\t\t\terr: errors.New(\"redis: invalid URL path: /1/2/3/4\"),\n\t\t}, {\n\t\t\turl: \"12345\",\n\t\t\terr: errors.New(\"redis: invalid URL scheme: \"),\n\t\t}, {\n\t\t\turl: \"redis://localhost/iamadatabase\",\n\t\t\terr: errors.New(`redis: invalid database number: \"iamadatabase\"`),\n\t\t},\n\t}\n\n\tfor i := range cases {\n\t\ttc := cases[i]\n\t\tt.Run(tc.url, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tactual, err := ParseURL(tc.url)\n\t\t\tif tc.err == nil && err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %q\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tc.err != nil && err != nil {\n\t\t\t\tif tc.err.Error() != err.Error() {\n\t\t\t\t\tt.Fatalf(\"got %q, expected %q\", err, tc.err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcomprareOptions(t, actual, tc.o)\n\t\t})\n\t}\n}\n\nfunc comprareOptions(t *testing.T, actual, expected *Options) {\n\tt.Helper()\n\n\tif actual.Addr != expected.Addr {\n\t\tt.Errorf(\"got %q, want %q\", actual.Addr, expected.Addr)\n\t}\n\tif actual.DB != expected.DB {\n\t\tt.Errorf(\"DB: got %q, expected %q\", actual.DB, expected.DB)\n\t}\n\tif actual.TLSConfig == nil && expected.TLSConfig != nil {\n\t\tt.Errorf(\"got nil TLSConfig, expected a TLSConfig\")\n\t}\n\tif actual.TLSConfig != nil && expected.TLSConfig == nil {\n\t\tt.Errorf(\"got TLSConfig, expected no TLSConfig\")\n\t}\n\tif actual.Username != expected.Username {\n\t\tt.Errorf(\"Username: got %q, expected %q\", actual.Username, expected.Username)\n\t}\n\tif actual.Password != expected.Password {\n\t\tt.Errorf(\"Password: got %q, expected %q\", actual.Password, expected.Password)\n\t}\n\tif actual.MaxRetries != expected.MaxRetries {\n\t\tt.Errorf(\"MaxRetries: got %v, expected %v\", actual.MaxRetries, expected.MaxRetries)\n\t}\n\tif actual.MinRetryBackoff != expected.MinRetryBackoff {\n\t\tt.Errorf(\"MinRetryBackoff: got %v, expected %v\", actual.MinRetryBackoff, expected.MinRetryBackoff)\n\t}\n\tif actual.MaxRetryBackoff != expected.MaxRetryBackoff {\n\t\tt.Errorf(\"MaxRetryBackoff: got %v, expected %v\", actual.MaxRetryBackoff, expected.MaxRetryBackoff)\n\t}\n\tif actual.DialTimeout != expected.DialTimeout {\n\t\tt.Errorf(\"DialTimeout: got %v, expected %v\", actual.DialTimeout, expected.DialTimeout)\n\t}\n\tif actual.ReadTimeout != expected.ReadTimeout {\n\t\tt.Errorf(\"ReadTimeout: got %v, expected %v\", actual.ReadTimeout, expected.ReadTimeout)\n\t}\n\tif actual.WriteTimeout != expected.WriteTimeout {\n\t\tt.Errorf(\"WriteTimeout: got %v, expected %v\", actual.WriteTimeout, expected.WriteTimeout)\n\t}\n\tif actual.PoolFIFO != expected.PoolFIFO {\n\t\tt.Errorf(\"PoolFIFO: got %v, expected %v\", actual.PoolFIFO, expected.PoolFIFO)\n\t}\n\tif actual.PoolSize != expected.PoolSize {\n\t\tt.Errorf(\"PoolSize: got %v, expected %v\", actual.PoolSize, expected.PoolSize)\n\t}\n\tif actual.PoolTimeout != expected.PoolTimeout {\n\t\tt.Errorf(\"PoolTimeout: got %v, expected %v\", actual.PoolTimeout, expected.PoolTimeout)\n\t}\n\tif actual.MinIdleConns != expected.MinIdleConns {\n\t\tt.Errorf(\"MinIdleConns: got %v, expected %v\", actual.MinIdleConns, expected.MinIdleConns)\n\t}\n\tif actual.MaxIdleConns != expected.MaxIdleConns {\n\t\tt.Errorf(\"MaxIdleConns: got %v, expected %v\", actual.MaxIdleConns, expected.MaxIdleConns)\n\t}\n\tif actual.ConnMaxIdleTime != expected.ConnMaxIdleTime {\n\t\tt.Errorf(\"ConnMaxIdleTime: got %v, expected %v\", actual.ConnMaxIdleTime, expected.ConnMaxIdleTime)\n\t}\n\tif actual.ConnMaxLifetime != expected.ConnMaxLifetime {\n\t\tt.Errorf(\"ConnMaxLifetime: got %v, expected %v\", actual.ConnMaxLifetime, expected.ConnMaxLifetime)\n\t}\n}\n\n// Test ReadTimeout option initialization, including special values -1 and 0.\n// And also test behaviour of WriteTimeout option, when it is not explicitly set and use\n// ReadTimeout value.\nfunc TestReadTimeoutOptions(t *testing.T) {\n\ttestDataInputOutputMap := map[time.Duration]time.Duration{\n\t\t-1: 0 * time.Second,\n\t\t0:  3 * time.Second,\n\t\t1:  1 * time.Nanosecond,\n\t\t3:  3 * time.Nanosecond,\n\t}\n\n\tfor in, out := range testDataInputOutputMap {\n\t\to := &Options{ReadTimeout: in}\n\t\to.init()\n\t\tif o.ReadTimeout != out {\n\t\t\tt.Errorf(\"got %d instead of %d as ReadTimeout option\", o.ReadTimeout, out)\n\t\t}\n\n\t\tif o.WriteTimeout != o.ReadTimeout {\n\t\t\tt.Errorf(\"got %d instead of %d as WriteTimeout option\", o.WriteTimeout, o.ReadTimeout)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "osscluster.go",
          "type": "blob",
          "size": 44.4013671875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/hashtag\"\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n\t\"github.com/redis/go-redis/v9/internal/rand\"\n)\n\nconst (\n\tminLatencyMeasurementInterval = 10 * time.Second\n)\n\nvar errClusterNoNodes = fmt.Errorf(\"redis: cluster has no nodes\")\n\n// ClusterOptions are used to configure a cluster client and should be\n// passed to NewClusterClient.\ntype ClusterOptions struct {\n\t// A seed list of host:port addresses of cluster nodes.\n\tAddrs []string\n\n\t// ClientName will execute the `CLIENT SETNAME ClientName` command for each conn.\n\tClientName string\n\n\t// NewClient creates a cluster node client with provided name and options.\n\tNewClient func(opt *Options) *Client\n\n\t// The maximum number of retries before giving up. Command is retried\n\t// on network errors and MOVED/ASK redirects.\n\t// Default is 3 retries.\n\tMaxRedirects int\n\n\t// Enables read-only commands on slave nodes.\n\tReadOnly bool\n\t// Allows routing read-only commands to the closest master or slave node.\n\t// It automatically enables ReadOnly.\n\tRouteByLatency bool\n\t// Allows routing read-only commands to the random master or slave node.\n\t// It automatically enables ReadOnly.\n\tRouteRandomly bool\n\n\t// Optional function that returns cluster slots information.\n\t// It is useful to manually create cluster of standalone Redis servers\n\t// and load-balance read/write operations between master and slaves.\n\t// It can use service like ZooKeeper to maintain configuration information\n\t// and Cluster.ReloadState to manually trigger state reloading.\n\tClusterSlots func(context.Context) ([]ClusterSlot, error)\n\n\t// Following options are copied from Options struct.\n\n\tDialer func(ctx context.Context, network, addr string) (net.Conn, error)\n\n\tOnConnect func(ctx context.Context, cn *Conn) error\n\n\tProtocol                   int\n\tUsername                   string\n\tPassword                   string\n\tCredentialsProvider        func() (username string, password string)\n\tCredentialsProviderContext func(ctx context.Context) (username string, password string, err error)\n\n\tMaxRetries      int\n\tMinRetryBackoff time.Duration\n\tMaxRetryBackoff time.Duration\n\n\tDialTimeout           time.Duration\n\tReadTimeout           time.Duration\n\tWriteTimeout          time.Duration\n\tContextTimeoutEnabled bool\n\n\tPoolFIFO        bool\n\tPoolSize        int // applies per cluster node and not for the whole cluster\n\tPoolTimeout     time.Duration\n\tMinIdleConns    int\n\tMaxIdleConns    int\n\tMaxActiveConns  int // applies per cluster node and not for the whole cluster\n\tConnMaxIdleTime time.Duration\n\tConnMaxLifetime time.Duration\n\n\tTLSConfig        *tls.Config\n\tDisableIndentity bool // Disable set-lib on connect. Default is false.\n\n\tIdentitySuffix string // Add suffix to client name. Default is empty.\n}\n\nfunc (opt *ClusterOptions) init() {\n\tif opt.MaxRedirects == -1 {\n\t\topt.MaxRedirects = 0\n\t} else if opt.MaxRedirects == 0 {\n\t\topt.MaxRedirects = 3\n\t}\n\n\tif opt.RouteByLatency || opt.RouteRandomly {\n\t\topt.ReadOnly = true\n\t}\n\n\tif opt.PoolSize == 0 {\n\t\topt.PoolSize = 5 * runtime.GOMAXPROCS(0)\n\t}\n\n\tswitch opt.ReadTimeout {\n\tcase -1:\n\t\topt.ReadTimeout = 0\n\tcase 0:\n\t\topt.ReadTimeout = 3 * time.Second\n\t}\n\tswitch opt.WriteTimeout {\n\tcase -1:\n\t\topt.WriteTimeout = 0\n\tcase 0:\n\t\topt.WriteTimeout = opt.ReadTimeout\n\t}\n\n\tif opt.MaxRetries == 0 {\n\t\topt.MaxRetries = -1\n\t}\n\tswitch opt.MinRetryBackoff {\n\tcase -1:\n\t\topt.MinRetryBackoff = 0\n\tcase 0:\n\t\topt.MinRetryBackoff = 8 * time.Millisecond\n\t}\n\tswitch opt.MaxRetryBackoff {\n\tcase -1:\n\t\topt.MaxRetryBackoff = 0\n\tcase 0:\n\t\topt.MaxRetryBackoff = 512 * time.Millisecond\n\t}\n\n\tif opt.NewClient == nil {\n\t\topt.NewClient = NewClient\n\t}\n}\n\n// ParseClusterURL parses a URL into ClusterOptions that can be used to connect to Redis.\n// The URL must be in the form:\n//\n//\tredis://<user>:<password>@<host>:<port>\n//\tor\n//\trediss://<user>:<password>@<host>:<port>\n//\n// To add additional addresses, specify the query parameter, \"addr\" one or more times. e.g:\n//\n//\tredis://<user>:<password>@<host>:<port>?addr=<host2>:<port2>&addr=<host3>:<port3>\n//\tor\n//\trediss://<user>:<password>@<host>:<port>?addr=<host2>:<port2>&addr=<host3>:<port3>\n//\n// Most Option fields can be set using query parameters, with the following restrictions:\n//   - field names are mapped using snake-case conversion: to set MaxRetries, use max_retries\n//   - only scalar type fields are supported (bool, int, time.Duration)\n//   - for time.Duration fields, values must be a valid input for time.ParseDuration();\n//     additionally a plain integer as value (i.e. without unit) is interpreted as seconds\n//   - to disable a duration field, use value less than or equal to 0; to use the default\n//     value, leave the value blank or remove the parameter\n//   - only the last value is interpreted if a parameter is given multiple times\n//   - fields \"network\", \"addr\", \"username\" and \"password\" can only be set using other\n//     URL attributes (scheme, host, userinfo, resp.), query parameters using these\n//     names will be treated as unknown parameters\n//   - unknown parameter names will result in an error\n//\n// Example:\n//\n//\tredis://user:password@localhost:6789?dial_timeout=3&read_timeout=6s&addr=localhost:6790&addr=localhost:6791\n//\tis equivalent to:\n//\t&ClusterOptions{\n//\t\tAddr:        [\"localhost:6789\", \"localhost:6790\", \"localhost:6791\"]\n//\t\tDialTimeout: 3 * time.Second, // no time unit = seconds\n//\t\tReadTimeout: 6 * time.Second,\n//\t}\nfunc ParseClusterURL(redisURL string) (*ClusterOptions, error) {\n\to := &ClusterOptions{}\n\n\tu, err := url.Parse(redisURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// add base URL to the array of addresses\n\t// more addresses may be added through the URL params\n\th, p := getHostPortWithDefaults(u)\n\to.Addrs = append(o.Addrs, net.JoinHostPort(h, p))\n\n\t// setup username, password, and other configurations\n\to, err = setupClusterConn(u, h, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn o, nil\n}\n\n// setupClusterConn gets the username and password from the URL and the query parameters.\nfunc setupClusterConn(u *url.URL, host string, o *ClusterOptions) (*ClusterOptions, error) {\n\tswitch u.Scheme {\n\tcase \"rediss\":\n\t\to.TLSConfig = &tls.Config{ServerName: host}\n\t\tfallthrough\n\tcase \"redis\":\n\t\to.Username, o.Password = getUserPassword(u)\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"redis: invalid URL scheme: %s\", u.Scheme)\n\t}\n\n\t// retrieve the configuration from the query parameters\n\to, err := setupClusterQueryParams(u, o)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn o, nil\n}\n\n// setupClusterQueryParams converts query parameters in u to option value in o.\nfunc setupClusterQueryParams(u *url.URL, o *ClusterOptions) (*ClusterOptions, error) {\n\tq := queryOptions{q: u.Query()}\n\n\to.Protocol = q.int(\"protocol\")\n\to.ClientName = q.string(\"client_name\")\n\to.MaxRedirects = q.int(\"max_redirects\")\n\to.ReadOnly = q.bool(\"read_only\")\n\to.RouteByLatency = q.bool(\"route_by_latency\")\n\to.RouteRandomly = q.bool(\"route_randomly\")\n\to.MaxRetries = q.int(\"max_retries\")\n\to.MinRetryBackoff = q.duration(\"min_retry_backoff\")\n\to.MaxRetryBackoff = q.duration(\"max_retry_backoff\")\n\to.DialTimeout = q.duration(\"dial_timeout\")\n\to.ReadTimeout = q.duration(\"read_timeout\")\n\to.WriteTimeout = q.duration(\"write_timeout\")\n\to.PoolFIFO = q.bool(\"pool_fifo\")\n\to.PoolSize = q.int(\"pool_size\")\n\to.MinIdleConns = q.int(\"min_idle_conns\")\n\to.MaxIdleConns = q.int(\"max_idle_conns\")\n\to.MaxActiveConns = q.int(\"max_active_conns\")\n\to.PoolTimeout = q.duration(\"pool_timeout\")\n\to.ConnMaxLifetime = q.duration(\"conn_max_lifetime\")\n\to.ConnMaxIdleTime = q.duration(\"conn_max_idle_time\")\n\n\tif q.err != nil {\n\t\treturn nil, q.err\n\t}\n\n\t// addr can be specified as many times as needed\n\taddrs := q.strings(\"addr\")\n\tfor _, addr := range addrs {\n\t\th, p, err := net.SplitHostPort(addr)\n\t\tif err != nil || h == \"\" || p == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"redis: unable to parse addr param: %s\", addr)\n\t\t}\n\n\t\to.Addrs = append(o.Addrs, net.JoinHostPort(h, p))\n\t}\n\n\t// any parameters left?\n\tif r := q.remaining(); len(r) > 0 {\n\t\treturn nil, fmt.Errorf(\"redis: unexpected option: %s\", strings.Join(r, \", \"))\n\t}\n\n\treturn o, nil\n}\n\nfunc (opt *ClusterOptions) clientOptions() *Options {\n\treturn &Options{\n\t\tClientName: opt.ClientName,\n\t\tDialer:     opt.Dialer,\n\t\tOnConnect:  opt.OnConnect,\n\n\t\tProtocol:                   opt.Protocol,\n\t\tUsername:                   opt.Username,\n\t\tPassword:                   opt.Password,\n\t\tCredentialsProvider:        opt.CredentialsProvider,\n\t\tCredentialsProviderContext: opt.CredentialsProviderContext,\n\n\t\tMaxRetries:      opt.MaxRetries,\n\t\tMinRetryBackoff: opt.MinRetryBackoff,\n\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n\n\t\tDialTimeout:           opt.DialTimeout,\n\t\tReadTimeout:           opt.ReadTimeout,\n\t\tWriteTimeout:          opt.WriteTimeout,\n\t\tContextTimeoutEnabled: opt.ContextTimeoutEnabled,\n\n\t\tPoolFIFO:         opt.PoolFIFO,\n\t\tPoolSize:         opt.PoolSize,\n\t\tPoolTimeout:      opt.PoolTimeout,\n\t\tMinIdleConns:     opt.MinIdleConns,\n\t\tMaxIdleConns:     opt.MaxIdleConns,\n\t\tMaxActiveConns:   opt.MaxActiveConns,\n\t\tConnMaxIdleTime:  opt.ConnMaxIdleTime,\n\t\tConnMaxLifetime:  opt.ConnMaxLifetime,\n\t\tDisableIndentity: opt.DisableIndentity,\n\t\tIdentitySuffix:   opt.IdentitySuffix,\n\t\tTLSConfig:        opt.TLSConfig,\n\t\t// If ClusterSlots is populated, then we probably have an artificial\n\t\t// cluster whose nodes are not in clustering mode (otherwise there isn't\n\t\t// much use for ClusterSlots config).  This means we cannot execute the\n\t\t// READONLY command against that node -- setting readOnly to false in such\n\t\t// situations in the options below will prevent that from happening.\n\t\treadOnly: opt.ReadOnly && opt.ClusterSlots == nil,\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype clusterNode struct {\n\tClient *Client\n\n\tlatency    uint32 // atomic\n\tgeneration uint32 // atomic\n\tfailing    uint32 // atomic\n\n\t// last time the latency measurement was performed for the node, stored in nanoseconds\n\t// from epoch\n\tlastLatencyMeasurement int64 // atomic\n}\n\nfunc newClusterNode(clOpt *ClusterOptions, addr string) *clusterNode {\n\topt := clOpt.clientOptions()\n\topt.Addr = addr\n\tnode := clusterNode{\n\t\tClient: clOpt.NewClient(opt),\n\t}\n\n\tnode.latency = math.MaxUint32\n\tif clOpt.RouteByLatency {\n\t\tgo node.updateLatency()\n\t}\n\n\treturn &node\n}\n\nfunc (n *clusterNode) String() string {\n\treturn n.Client.String()\n}\n\nfunc (n *clusterNode) Close() error {\n\treturn n.Client.Close()\n}\n\nconst maximumNodeLatency = 1 * time.Minute\n\nfunc (n *clusterNode) updateLatency() {\n\tconst numProbe = 10\n\tvar dur uint64\n\n\tsuccesses := 0\n\tfor i := 0; i < numProbe; i++ {\n\t\ttime.Sleep(time.Duration(10+rand.Intn(10)) * time.Millisecond)\n\n\t\tstart := time.Now()\n\t\terr := n.Client.Ping(context.TODO()).Err()\n\t\tif err == nil {\n\t\t\tdur += uint64(time.Since(start) / time.Microsecond)\n\t\t\tsuccesses++\n\t\t}\n\t}\n\n\tvar latency float64\n\tif successes == 0 {\n\t\t// If none of the pings worked, set latency to some arbitrarily high value so this node gets\n\t\t// least priority.\n\t\tlatency = float64((maximumNodeLatency) / time.Microsecond)\n\t} else {\n\t\tlatency = float64(dur) / float64(successes)\n\t}\n\tatomic.StoreUint32(&n.latency, uint32(latency+0.5))\n\tn.SetLastLatencyMeasurement(time.Now())\n}\n\nfunc (n *clusterNode) Latency() time.Duration {\n\tlatency := atomic.LoadUint32(&n.latency)\n\treturn time.Duration(latency) * time.Microsecond\n}\n\nfunc (n *clusterNode) MarkAsFailing() {\n\tatomic.StoreUint32(&n.failing, uint32(time.Now().Unix()))\n}\n\nfunc (n *clusterNode) Failing() bool {\n\tconst timeout = 15 // 15 seconds\n\n\tfailing := atomic.LoadUint32(&n.failing)\n\tif failing == 0 {\n\t\treturn false\n\t}\n\tif time.Now().Unix()-int64(failing) < timeout {\n\t\treturn true\n\t}\n\tatomic.StoreUint32(&n.failing, 0)\n\treturn false\n}\n\nfunc (n *clusterNode) Generation() uint32 {\n\treturn atomic.LoadUint32(&n.generation)\n}\n\nfunc (n *clusterNode) LastLatencyMeasurement() int64 {\n\treturn atomic.LoadInt64(&n.lastLatencyMeasurement)\n}\n\nfunc (n *clusterNode) SetGeneration(gen uint32) {\n\tfor {\n\t\tv := atomic.LoadUint32(&n.generation)\n\t\tif gen < v || atomic.CompareAndSwapUint32(&n.generation, v, gen) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (n *clusterNode) SetLastLatencyMeasurement(t time.Time) {\n\tfor {\n\t\tv := atomic.LoadInt64(&n.lastLatencyMeasurement)\n\t\tif t.UnixNano() < v || atomic.CompareAndSwapInt64(&n.lastLatencyMeasurement, v, t.UnixNano()) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype clusterNodes struct {\n\topt *ClusterOptions\n\n\tmu          sync.RWMutex\n\taddrs       []string\n\tnodes       map[string]*clusterNode\n\tactiveAddrs []string\n\tclosed      bool\n\tonNewNode   []func(rdb *Client)\n\n\t_generation uint32 // atomic\n}\n\nfunc newClusterNodes(opt *ClusterOptions) *clusterNodes {\n\treturn &clusterNodes{\n\t\topt: opt,\n\n\t\taddrs: opt.Addrs,\n\t\tnodes: make(map[string]*clusterNode),\n\t}\n}\n\nfunc (c *clusterNodes) Close() error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.closed {\n\t\treturn nil\n\t}\n\tc.closed = true\n\n\tvar firstErr error\n\tfor _, node := range c.nodes {\n\t\tif err := node.Client.Close(); err != nil && firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\n\tc.nodes = nil\n\tc.activeAddrs = nil\n\n\treturn firstErr\n}\n\nfunc (c *clusterNodes) OnNewNode(fn func(rdb *Client)) {\n\tc.mu.Lock()\n\tc.onNewNode = append(c.onNewNode, fn)\n\tc.mu.Unlock()\n}\n\nfunc (c *clusterNodes) Addrs() ([]string, error) {\n\tvar addrs []string\n\n\tc.mu.RLock()\n\tclosed := c.closed //nolint:ifshort\n\tif !closed {\n\t\tif len(c.activeAddrs) > 0 {\n\t\t\taddrs = c.activeAddrs\n\t\t} else {\n\t\t\taddrs = c.addrs\n\t\t}\n\t}\n\tc.mu.RUnlock()\n\n\tif closed {\n\t\treturn nil, pool.ErrClosed\n\t}\n\tif len(addrs) == 0 {\n\t\treturn nil, errClusterNoNodes\n\t}\n\treturn addrs, nil\n}\n\nfunc (c *clusterNodes) NextGeneration() uint32 {\n\treturn atomic.AddUint32(&c._generation, 1)\n}\n\n// GC removes unused nodes.\nfunc (c *clusterNodes) GC(generation uint32) {\n\t//nolint:prealloc\n\tvar collected []*clusterNode\n\n\tc.mu.Lock()\n\n\tc.activeAddrs = c.activeAddrs[:0]\n\tnow := time.Now()\n\tfor addr, node := range c.nodes {\n\t\tif node.Generation() >= generation {\n\t\t\tc.activeAddrs = append(c.activeAddrs, addr)\n\t\t\tif c.opt.RouteByLatency && node.LastLatencyMeasurement() < now.Add(-minLatencyMeasurementInterval).UnixNano() {\n\t\t\t\tgo node.updateLatency()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tdelete(c.nodes, addr)\n\t\tcollected = append(collected, node)\n\t}\n\n\tc.mu.Unlock()\n\n\tfor _, node := range collected {\n\t\t_ = node.Client.Close()\n\t}\n}\n\nfunc (c *clusterNodes) GetOrCreate(addr string) (*clusterNode, error) {\n\tnode, err := c.get(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif node != nil {\n\t\treturn node, nil\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.closed {\n\t\treturn nil, pool.ErrClosed\n\t}\n\n\tnode, ok := c.nodes[addr]\n\tif ok {\n\t\treturn node, nil\n\t}\n\n\tnode = newClusterNode(c.opt, addr)\n\tfor _, fn := range c.onNewNode {\n\t\tfn(node.Client)\n\t}\n\n\tc.addrs = appendIfNotExists(c.addrs, addr)\n\tc.nodes[addr] = node\n\n\treturn node, nil\n}\n\nfunc (c *clusterNodes) get(addr string) (*clusterNode, error) {\n\tvar node *clusterNode\n\tvar err error\n\tc.mu.RLock()\n\tif c.closed {\n\t\terr = pool.ErrClosed\n\t} else {\n\t\tnode = c.nodes[addr]\n\t}\n\tc.mu.RUnlock()\n\treturn node, err\n}\n\nfunc (c *clusterNodes) All() ([]*clusterNode, error) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tif c.closed {\n\t\treturn nil, pool.ErrClosed\n\t}\n\n\tcp := make([]*clusterNode, 0, len(c.nodes))\n\tfor _, node := range c.nodes {\n\t\tcp = append(cp, node)\n\t}\n\treturn cp, nil\n}\n\nfunc (c *clusterNodes) Random() (*clusterNode, error) {\n\taddrs, err := c.Addrs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tn := rand.Intn(len(addrs))\n\treturn c.GetOrCreate(addrs[n])\n}\n\n//------------------------------------------------------------------------------\n\ntype clusterSlot struct {\n\tstart, end int\n\tnodes      []*clusterNode\n}\n\ntype clusterSlotSlice []*clusterSlot\n\nfunc (p clusterSlotSlice) Len() int {\n\treturn len(p)\n}\n\nfunc (p clusterSlotSlice) Less(i, j int) bool {\n\treturn p[i].start < p[j].start\n}\n\nfunc (p clusterSlotSlice) Swap(i, j int) {\n\tp[i], p[j] = p[j], p[i]\n}\n\ntype clusterState struct {\n\tnodes   *clusterNodes\n\tMasters []*clusterNode\n\tSlaves  []*clusterNode\n\n\tslots []*clusterSlot\n\n\tgeneration uint32\n\tcreatedAt  time.Time\n}\n\nfunc newClusterState(\n\tnodes *clusterNodes, slots []ClusterSlot, origin string,\n) (*clusterState, error) {\n\tc := clusterState{\n\t\tnodes: nodes,\n\n\t\tslots: make([]*clusterSlot, 0, len(slots)),\n\n\t\tgeneration: nodes.NextGeneration(),\n\t\tcreatedAt:  time.Now(),\n\t}\n\n\toriginHost, _, _ := net.SplitHostPort(origin)\n\tisLoopbackOrigin := isLoopback(originHost)\n\n\tfor _, slot := range slots {\n\t\tvar nodes []*clusterNode\n\t\tfor i, slotNode := range slot.Nodes {\n\t\t\taddr := slotNode.Addr\n\t\t\tif !isLoopbackOrigin {\n\t\t\t\taddr = replaceLoopbackHost(addr, originHost)\n\t\t\t}\n\n\t\t\tnode, err := c.nodes.GetOrCreate(addr)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tnode.SetGeneration(c.generation)\n\t\t\tnodes = append(nodes, node)\n\n\t\t\tif i == 0 {\n\t\t\t\tc.Masters = appendUniqueNode(c.Masters, node)\n\t\t\t} else {\n\t\t\t\tc.Slaves = appendUniqueNode(c.Slaves, node)\n\t\t\t}\n\t\t}\n\n\t\tc.slots = append(c.slots, &clusterSlot{\n\t\t\tstart: slot.Start,\n\t\t\tend:   slot.End,\n\t\t\tnodes: nodes,\n\t\t})\n\t}\n\n\tsort.Sort(clusterSlotSlice(c.slots))\n\n\ttime.AfterFunc(time.Minute, func() {\n\t\tnodes.GC(c.generation)\n\t})\n\n\treturn &c, nil\n}\n\nfunc replaceLoopbackHost(nodeAddr, originHost string) string {\n\tnodeHost, nodePort, err := net.SplitHostPort(nodeAddr)\n\tif err != nil {\n\t\treturn nodeAddr\n\t}\n\n\tnodeIP := net.ParseIP(nodeHost)\n\tif nodeIP == nil {\n\t\treturn nodeAddr\n\t}\n\n\tif !nodeIP.IsLoopback() {\n\t\treturn nodeAddr\n\t}\n\n\t// Use origin host which is not loopback and node port.\n\treturn net.JoinHostPort(originHost, nodePort)\n}\n\nfunc isLoopback(host string) bool {\n\tip := net.ParseIP(host)\n\tif ip == nil {\n\t\treturn true\n\t}\n\treturn ip.IsLoopback()\n}\n\nfunc (c *clusterState) slotMasterNode(slot int) (*clusterNode, error) {\n\tnodes := c.slotNodes(slot)\n\tif len(nodes) > 0 {\n\t\treturn nodes[0], nil\n\t}\n\treturn c.nodes.Random()\n}\n\nfunc (c *clusterState) slotSlaveNode(slot int) (*clusterNode, error) {\n\tnodes := c.slotNodes(slot)\n\tswitch len(nodes) {\n\tcase 0:\n\t\treturn c.nodes.Random()\n\tcase 1:\n\t\treturn nodes[0], nil\n\tcase 2:\n\t\tif slave := nodes[1]; !slave.Failing() {\n\t\t\treturn slave, nil\n\t\t}\n\t\treturn nodes[0], nil\n\tdefault:\n\t\tvar slave *clusterNode\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tn := rand.Intn(len(nodes)-1) + 1\n\t\t\tslave = nodes[n]\n\t\t\tif !slave.Failing() {\n\t\t\t\treturn slave, nil\n\t\t\t}\n\t\t}\n\n\t\t// All slaves are loading - use master.\n\t\treturn nodes[0], nil\n\t}\n}\n\nfunc (c *clusterState) slotClosestNode(slot int) (*clusterNode, error) {\n\tnodes := c.slotNodes(slot)\n\tif len(nodes) == 0 {\n\t\treturn c.nodes.Random()\n\t}\n\n\tvar allNodesFailing = true\n\tvar (\n\t\tclosestNonFailingNode *clusterNode\n\t\tclosestNode           *clusterNode\n\t\tminLatency            time.Duration\n\t)\n\n\t// setting the max possible duration as zerovalue for minlatency\n\tminLatency = time.Duration(math.MaxInt64)\n\n\tfor _, n := range nodes {\n\t\tif closestNode == nil || n.Latency() < minLatency {\n\t\t\tclosestNode = n\n\t\t\tminLatency = n.Latency()\n\t\t\tif !n.Failing() {\n\t\t\t\tclosestNonFailingNode = n\n\t\t\t\tallNodesFailing = false\n\t\t\t}\n\t\t}\n\t}\n\n\t// pick the healthly node with the lowest latency\n\tif !allNodesFailing && closestNonFailingNode != nil {\n\t\treturn closestNonFailingNode, nil\n\t}\n\n\t// if all nodes are failing, we will pick the temporarily failing node with lowest latency\n\tif minLatency < maximumNodeLatency && closestNode != nil {\n\t\tinternal.Logger.Printf(context.TODO(), \"redis: all nodes are marked as failed, picking the temporarily failing node with lowest latency\")\n\t\treturn closestNode, nil\n\t}\n\n\t// If all nodes are having the maximum latency(all pings are failing) - return a random node across the cluster\n\tinternal.Logger.Printf(context.TODO(), \"redis: pings to all nodes are failing, picking a random node across the cluster\")\n\treturn c.nodes.Random()\n}\n\nfunc (c *clusterState) slotRandomNode(slot int) (*clusterNode, error) {\n\tnodes := c.slotNodes(slot)\n\tif len(nodes) == 0 {\n\t\treturn c.nodes.Random()\n\t}\n\tif len(nodes) == 1 {\n\t\treturn nodes[0], nil\n\t}\n\trandomNodes := rand.Perm(len(nodes))\n\tfor _, idx := range randomNodes {\n\t\tif node := nodes[idx]; !node.Failing() {\n\t\t\treturn node, nil\n\t\t}\n\t}\n\treturn nodes[randomNodes[0]], nil\n}\n\nfunc (c *clusterState) slotNodes(slot int) []*clusterNode {\n\ti := sort.Search(len(c.slots), func(i int) bool {\n\t\treturn c.slots[i].end >= slot\n\t})\n\tif i >= len(c.slots) {\n\t\treturn nil\n\t}\n\tx := c.slots[i]\n\tif slot >= x.start && slot <= x.end {\n\t\treturn x.nodes\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype clusterStateHolder struct {\n\tload func(ctx context.Context) (*clusterState, error)\n\n\tstate     atomic.Value\n\treloading uint32 // atomic\n}\n\nfunc newClusterStateHolder(fn func(ctx context.Context) (*clusterState, error)) *clusterStateHolder {\n\treturn &clusterStateHolder{\n\t\tload: fn,\n\t}\n}\n\nfunc (c *clusterStateHolder) Reload(ctx context.Context) (*clusterState, error) {\n\tstate, err := c.load(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc.state.Store(state)\n\treturn state, nil\n}\n\nfunc (c *clusterStateHolder) LazyReload() {\n\tif !atomic.CompareAndSwapUint32(&c.reloading, 0, 1) {\n\t\treturn\n\t}\n\tgo func() {\n\t\tdefer atomic.StoreUint32(&c.reloading, 0)\n\n\t\t_, err := c.Reload(context.Background())\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\ttime.Sleep(200 * time.Millisecond)\n\t}()\n}\n\nfunc (c *clusterStateHolder) Get(ctx context.Context) (*clusterState, error) {\n\tv := c.state.Load()\n\tif v == nil {\n\t\treturn c.Reload(ctx)\n\t}\n\n\tstate := v.(*clusterState)\n\tif time.Since(state.createdAt) > 10*time.Second {\n\t\tc.LazyReload()\n\t}\n\treturn state, nil\n}\n\nfunc (c *clusterStateHolder) ReloadOrGet(ctx context.Context) (*clusterState, error) {\n\tstate, err := c.Reload(ctx)\n\tif err == nil {\n\t\treturn state, nil\n\t}\n\treturn c.Get(ctx)\n}\n\n//------------------------------------------------------------------------------\n\n// ClusterClient is a Redis Cluster client representing a pool of zero\n// or more underlying connections. It's safe for concurrent use by\n// multiple goroutines.\ntype ClusterClient struct {\n\topt           *ClusterOptions\n\tnodes         *clusterNodes\n\tstate         *clusterStateHolder\n\tcmdsInfoCache *cmdsInfoCache\n\tcmdable\n\thooksMixin\n}\n\n// NewClusterClient returns a Redis Cluster client as described in\n// http://redis.io/topics/cluster-spec.\nfunc NewClusterClient(opt *ClusterOptions) *ClusterClient {\n\topt.init()\n\n\tc := &ClusterClient{\n\t\topt:   opt,\n\t\tnodes: newClusterNodes(opt),\n\t}\n\n\tc.state = newClusterStateHolder(c.loadState)\n\tc.cmdsInfoCache = newCmdsInfoCache(c.cmdsInfo)\n\tc.cmdable = c.Process\n\n\tc.initHooks(hooks{\n\t\tdial:       nil,\n\t\tprocess:    c.process,\n\t\tpipeline:   c.processPipeline,\n\t\ttxPipeline: c.processTxPipeline,\n\t})\n\n\treturn c\n}\n\n// Options returns read-only Options that were used to create the client.\nfunc (c *ClusterClient) Options() *ClusterOptions {\n\treturn c.opt\n}\n\n// ReloadState reloads cluster state. If available it calls ClusterSlots func\n// to get cluster slots information.\nfunc (c *ClusterClient) ReloadState(ctx context.Context) {\n\tc.state.LazyReload()\n}\n\n// Close closes the cluster client, releasing any open resources.\n//\n// It is rare to Close a ClusterClient, as the ClusterClient is meant\n// to be long-lived and shared between many goroutines.\nfunc (c *ClusterClient) Close() error {\n\treturn c.nodes.Close()\n}\n\n// Do create a Cmd from the args and processes the cmd.\nfunc (c *ClusterClient) Do(ctx context.Context, args ...interface{}) *Cmd {\n\tcmd := NewCmd(ctx, args...)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c *ClusterClient) Process(ctx context.Context, cmd Cmder) error {\n\terr := c.processHook(ctx, cmd)\n\tcmd.SetErr(err)\n\treturn err\n}\n\nfunc (c *ClusterClient) process(ctx context.Context, cmd Cmder) error {\n\tslot := c.cmdSlot(ctx, cmd)\n\tvar node *clusterNode\n\tvar moved bool\n\tvar ask bool\n\tvar lastErr error\n\tfor attempt := 0; attempt <= c.opt.MaxRedirects; attempt++ {\n\t\t// MOVED and ASK responses are not transient errors that require retry delay; they\n\t\t// should be attempted immediately.\n\t\tif attempt > 0 && !moved && !ask {\n\t\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif node == nil {\n\t\t\tvar err error\n\t\t\tnode, err = c.cmdNode(ctx, cmd.Name(), slot)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif ask {\n\t\t\task = false\n\n\t\t\tpipe := node.Client.Pipeline()\n\t\t\t_ = pipe.Process(ctx, NewCmd(ctx, \"asking\"))\n\t\t\t_ = pipe.Process(ctx, cmd)\n\t\t\t_, lastErr = pipe.Exec(ctx)\n\t\t} else {\n\t\t\tlastErr = node.Client.Process(ctx, cmd)\n\t\t}\n\n\t\t// If there is no error - we are done.\n\t\tif lastErr == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif isReadOnly := isReadOnlyError(lastErr); isReadOnly || lastErr == pool.ErrClosed {\n\t\t\tif isReadOnly {\n\t\t\t\tc.state.LazyReload()\n\t\t\t}\n\t\t\tnode = nil\n\t\t\tcontinue\n\t\t}\n\n\t\t// If slave is loading - pick another node.\n\t\tif c.opt.ReadOnly && isLoadingError(lastErr) {\n\t\t\tnode.MarkAsFailing()\n\t\t\tnode = nil\n\t\t\tcontinue\n\t\t}\n\n\t\tvar addr string\n\t\tmoved, ask, addr = isMovedError(lastErr)\n\t\tif moved || ask {\n\t\t\tc.state.LazyReload()\n\n\t\t\tvar err error\n\t\t\tnode, err = c.nodes.GetOrCreate(addr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif shouldRetry(lastErr, cmd.readTimeout() == nil) {\n\t\t\t// First retry the same node.\n\t\t\tif attempt == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Second try another node.\n\t\t\tnode.MarkAsFailing()\n\t\t\tnode = nil\n\t\t\tcontinue\n\t\t}\n\n\t\treturn lastErr\n\t}\n\treturn lastErr\n}\n\nfunc (c *ClusterClient) OnNewNode(fn func(rdb *Client)) {\n\tc.nodes.OnNewNode(fn)\n}\n\n// ForEachMaster concurrently calls the fn on each master node in the cluster.\n// It returns the first error if any.\nfunc (c *ClusterClient) ForEachMaster(\n\tctx context.Context,\n\tfn func(ctx context.Context, client *Client) error,\n) error {\n\tstate, err := c.state.ReloadOrGet(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar wg sync.WaitGroup\n\terrCh := make(chan error, 1)\n\n\tfor _, master := range state.Masters {\n\t\twg.Add(1)\n\t\tgo func(node *clusterNode) {\n\t\t\tdefer wg.Done()\n\t\t\terr := fn(ctx, node.Client)\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errCh <- err:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}(master)\n\t}\n\n\twg.Wait()\n\n\tselect {\n\tcase err := <-errCh:\n\t\treturn err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// ForEachSlave concurrently calls the fn on each slave node in the cluster.\n// It returns the first error if any.\nfunc (c *ClusterClient) ForEachSlave(\n\tctx context.Context,\n\tfn func(ctx context.Context, client *Client) error,\n) error {\n\tstate, err := c.state.ReloadOrGet(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar wg sync.WaitGroup\n\terrCh := make(chan error, 1)\n\n\tfor _, slave := range state.Slaves {\n\t\twg.Add(1)\n\t\tgo func(node *clusterNode) {\n\t\t\tdefer wg.Done()\n\t\t\terr := fn(ctx, node.Client)\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errCh <- err:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}(slave)\n\t}\n\n\twg.Wait()\n\n\tselect {\n\tcase err := <-errCh:\n\t\treturn err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// ForEachShard concurrently calls the fn on each known node in the cluster.\n// It returns the first error if any.\nfunc (c *ClusterClient) ForEachShard(\n\tctx context.Context,\n\tfn func(ctx context.Context, client *Client) error,\n) error {\n\tstate, err := c.state.ReloadOrGet(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar wg sync.WaitGroup\n\terrCh := make(chan error, 1)\n\n\tworker := func(node *clusterNode) {\n\t\tdefer wg.Done()\n\t\terr := fn(ctx, node.Client)\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase errCh <- err:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, node := range state.Masters {\n\t\twg.Add(1)\n\t\tgo worker(node)\n\t}\n\tfor _, node := range state.Slaves {\n\t\twg.Add(1)\n\t\tgo worker(node)\n\t}\n\n\twg.Wait()\n\n\tselect {\n\tcase err := <-errCh:\n\t\treturn err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\n// PoolStats returns accumulated connection pool stats.\nfunc (c *ClusterClient) PoolStats() *PoolStats {\n\tvar acc PoolStats\n\n\tstate, _ := c.state.Get(context.TODO())\n\tif state == nil {\n\t\treturn &acc\n\t}\n\n\tfor _, node := range state.Masters {\n\t\ts := node.Client.connPool.Stats()\n\t\tacc.Hits += s.Hits\n\t\tacc.Misses += s.Misses\n\t\tacc.Timeouts += s.Timeouts\n\n\t\tacc.TotalConns += s.TotalConns\n\t\tacc.IdleConns += s.IdleConns\n\t\tacc.StaleConns += s.StaleConns\n\t}\n\n\tfor _, node := range state.Slaves {\n\t\ts := node.Client.connPool.Stats()\n\t\tacc.Hits += s.Hits\n\t\tacc.Misses += s.Misses\n\t\tacc.Timeouts += s.Timeouts\n\n\t\tacc.TotalConns += s.TotalConns\n\t\tacc.IdleConns += s.IdleConns\n\t\tacc.StaleConns += s.StaleConns\n\t}\n\n\treturn &acc\n}\n\nfunc (c *ClusterClient) loadState(ctx context.Context) (*clusterState, error) {\n\tif c.opt.ClusterSlots != nil {\n\t\tslots, err := c.opt.ClusterSlots(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn newClusterState(c.nodes, slots, \"\")\n\t}\n\n\taddrs, err := c.nodes.Addrs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar firstErr error\n\n\tfor _, idx := range rand.Perm(len(addrs)) {\n\t\taddr := addrs[idx]\n\n\t\tnode, err := c.nodes.GetOrCreate(addr)\n\t\tif err != nil {\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tslots, err := node.Client.ClusterSlots(ctx).Result()\n\t\tif err != nil {\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\treturn newClusterState(c.nodes, slots, node.Client.opt.Addr)\n\t}\n\n\t/*\n\t * No node is connectable. It's possible that all nodes' IP has changed.\n\t * Clear activeAddrs to let client be able to re-connect using the initial\n\t * setting of the addresses (e.g. [redis-cluster-0:6379, redis-cluster-1:6379]),\n\t * which might have chance to resolve domain name and get updated IP address.\n\t */\n\tc.nodes.mu.Lock()\n\tc.nodes.activeAddrs = nil\n\tc.nodes.mu.Unlock()\n\n\treturn nil, firstErr\n}\n\nfunc (c *ClusterClient) Pipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: pipelineExecer(c.processPipelineHook),\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc (c *ClusterClient) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.Pipeline().Pipelined(ctx, fn)\n}\n\nfunc (c *ClusterClient) processPipeline(ctx context.Context, cmds []Cmder) error {\n\tcmdsMap := newCmdsMap()\n\n\tif err := c.mapCmdsByNode(ctx, cmdsMap, cmds); err != nil {\n\t\tsetCmdsErr(cmds, err)\n\t\treturn err\n\t}\n\n\tfor attempt := 0; attempt <= c.opt.MaxRedirects; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n\t\t\t\tsetCmdsErr(cmds, err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tfailedCmds := newCmdsMap()\n\t\tvar wg sync.WaitGroup\n\n\t\tfor node, cmds := range cmdsMap.m {\n\t\t\twg.Add(1)\n\t\t\tgo func(node *clusterNode, cmds []Cmder) {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tc.processPipelineNode(ctx, node, cmds, failedCmds)\n\t\t\t}(node, cmds)\n\t\t}\n\n\t\twg.Wait()\n\t\tif len(failedCmds.m) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tcmdsMap = failedCmds\n\t}\n\n\treturn cmdsFirstErr(cmds)\n}\n\nfunc (c *ClusterClient) mapCmdsByNode(ctx context.Context, cmdsMap *cmdsMap, cmds []Cmder) error {\n\tstate, err := c.state.Get(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif c.opt.ReadOnly && c.cmdsAreReadOnly(ctx, cmds) {\n\t\tfor _, cmd := range cmds {\n\t\t\tslot := c.cmdSlot(ctx, cmd)\n\t\t\tnode, err := c.slotReadOnlyNode(state, slot)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcmdsMap.Add(node, cmd)\n\t\t}\n\t\treturn nil\n\t}\n\n\tfor _, cmd := range cmds {\n\t\tslot := c.cmdSlot(ctx, cmd)\n\t\tnode, err := state.slotMasterNode(slot)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmdsMap.Add(node, cmd)\n\t}\n\treturn nil\n}\n\nfunc (c *ClusterClient) cmdsAreReadOnly(ctx context.Context, cmds []Cmder) bool {\n\tfor _, cmd := range cmds {\n\t\tcmdInfo := c.cmdInfo(ctx, cmd.Name())\n\t\tif cmdInfo == nil || !cmdInfo.ReadOnly {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (c *ClusterClient) processPipelineNode(\n\tctx context.Context, node *clusterNode, cmds []Cmder, failedCmds *cmdsMap,\n) {\n\t_ = node.Client.withProcessPipelineHook(ctx, cmds, func(ctx context.Context, cmds []Cmder) error {\n\t\tcn, err := node.Client.getConn(ctx)\n\t\tif err != nil {\n\t\t\tnode.MarkAsFailing()\n\t\t\t_ = c.mapCmdsByNode(ctx, failedCmds, cmds)\n\t\t\tsetCmdsErr(cmds, err)\n\t\t\treturn err\n\t\t}\n\n\t\tvar processErr error\n\t\tdefer func() {\n\t\t\tnode.Client.releaseConn(ctx, cn, processErr)\n\t\t}()\n\t\tprocessErr = c.processPipelineNodeConn(ctx, node, cn, cmds, failedCmds)\n\n\t\treturn processErr\n\t})\n}\n\nfunc (c *ClusterClient) processPipelineNodeConn(\n\tctx context.Context, node *clusterNode, cn *pool.Conn, cmds []Cmder, failedCmds *cmdsMap,\n) error {\n\tif err := cn.WithWriter(c.context(ctx), c.opt.WriteTimeout, func(wr *proto.Writer) error {\n\t\treturn writeCmds(wr, cmds)\n\t}); err != nil {\n\t\tif isBadConn(err, false, node.Client.getAddr()) {\n\t\t\tnode.MarkAsFailing()\n\t\t}\n\t\tif shouldRetry(err, true) {\n\t\t\t_ = c.mapCmdsByNode(ctx, failedCmds, cmds)\n\t\t}\n\t\tsetCmdsErr(cmds, err)\n\t\treturn err\n\t}\n\n\treturn cn.WithReader(c.context(ctx), c.opt.ReadTimeout, func(rd *proto.Reader) error {\n\t\treturn c.pipelineReadCmds(ctx, node, rd, cmds, failedCmds)\n\t})\n}\n\nfunc (c *ClusterClient) pipelineReadCmds(\n\tctx context.Context,\n\tnode *clusterNode,\n\trd *proto.Reader,\n\tcmds []Cmder,\n\tfailedCmds *cmdsMap,\n) error {\n\tfor i, cmd := range cmds {\n\t\terr := cmd.readReply(rd)\n\t\tcmd.SetErr(err)\n\n\t\tif err == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.checkMovedErr(ctx, cmd, err, failedCmds) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif c.opt.ReadOnly && isBadConn(err, false, node.Client.getAddr()) {\n\t\t\tnode.MarkAsFailing()\n\t\t}\n\n\t\tif !isRedisError(err) {\n\t\t\tif shouldRetry(err, true) {\n\t\t\t\t_ = c.mapCmdsByNode(ctx, failedCmds, cmds)\n\t\t\t}\n\t\t\tsetCmdsErr(cmds[i+1:], err)\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := cmds[0].Err(); err != nil && shouldRetry(err, true) {\n\t\t_ = c.mapCmdsByNode(ctx, failedCmds, cmds)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *ClusterClient) checkMovedErr(\n\tctx context.Context, cmd Cmder, err error, failedCmds *cmdsMap,\n) bool {\n\tmoved, ask, addr := isMovedError(err)\n\tif !moved && !ask {\n\t\treturn false\n\t}\n\n\tnode, err := c.nodes.GetOrCreate(addr)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif moved {\n\t\tc.state.LazyReload()\n\t\tfailedCmds.Add(node, cmd)\n\t\treturn true\n\t}\n\n\tif ask {\n\t\tfailedCmds.Add(node, NewCmd(ctx, \"asking\"), cmd)\n\t\treturn true\n\t}\n\n\tpanic(\"not reached\")\n}\n\n// TxPipeline acts like Pipeline, but wraps queued commands with MULTI/EXEC.\nfunc (c *ClusterClient) TxPipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: func(ctx context.Context, cmds []Cmder) error {\n\t\t\tcmds = wrapMultiExec(ctx, cmds)\n\t\t\treturn c.processTxPipelineHook(ctx, cmds)\n\t\t},\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc (c *ClusterClient) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.TxPipeline().Pipelined(ctx, fn)\n}\n\nfunc (c *ClusterClient) processTxPipeline(ctx context.Context, cmds []Cmder) error {\n\t// Trim multi .. exec.\n\tcmds = cmds[1 : len(cmds)-1]\n\n\tstate, err := c.state.Get(ctx)\n\tif err != nil {\n\t\tsetCmdsErr(cmds, err)\n\t\treturn err\n\t}\n\n\tcmdsMap := c.mapCmdsBySlot(ctx, cmds)\n\tfor slot, cmds := range cmdsMap {\n\t\tnode, err := state.slotMasterNode(slot)\n\t\tif err != nil {\n\t\t\tsetCmdsErr(cmds, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcmdsMap := map[*clusterNode][]Cmder{node: cmds}\n\t\tfor attempt := 0; attempt <= c.opt.MaxRedirects; attempt++ {\n\t\t\tif attempt > 0 {\n\t\t\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n\t\t\t\t\tsetCmdsErr(cmds, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfailedCmds := newCmdsMap()\n\t\t\tvar wg sync.WaitGroup\n\n\t\t\tfor node, cmds := range cmdsMap {\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func(node *clusterNode, cmds []Cmder) {\n\t\t\t\t\tdefer wg.Done()\n\t\t\t\t\tc.processTxPipelineNode(ctx, node, cmds, failedCmds)\n\t\t\t\t}(node, cmds)\n\t\t\t}\n\n\t\t\twg.Wait()\n\t\t\tif len(failedCmds.m) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcmdsMap = failedCmds.m\n\t\t}\n\t}\n\n\treturn cmdsFirstErr(cmds)\n}\n\nfunc (c *ClusterClient) mapCmdsBySlot(ctx context.Context, cmds []Cmder) map[int][]Cmder {\n\tcmdsMap := make(map[int][]Cmder)\n\tfor _, cmd := range cmds {\n\t\tslot := c.cmdSlot(ctx, cmd)\n\t\tcmdsMap[slot] = append(cmdsMap[slot], cmd)\n\t}\n\treturn cmdsMap\n}\n\nfunc (c *ClusterClient) processTxPipelineNode(\n\tctx context.Context, node *clusterNode, cmds []Cmder, failedCmds *cmdsMap,\n) {\n\tcmds = wrapMultiExec(ctx, cmds)\n\t_ = node.Client.withProcessPipelineHook(ctx, cmds, func(ctx context.Context, cmds []Cmder) error {\n\t\tcn, err := node.Client.getConn(ctx)\n\t\tif err != nil {\n\t\t\t_ = c.mapCmdsByNode(ctx, failedCmds, cmds)\n\t\t\tsetCmdsErr(cmds, err)\n\t\t\treturn err\n\t\t}\n\n\t\tvar processErr error\n\t\tdefer func() {\n\t\t\tnode.Client.releaseConn(ctx, cn, processErr)\n\t\t}()\n\t\tprocessErr = c.processTxPipelineNodeConn(ctx, node, cn, cmds, failedCmds)\n\n\t\treturn processErr\n\t})\n}\n\nfunc (c *ClusterClient) processTxPipelineNodeConn(\n\tctx context.Context, node *clusterNode, cn *pool.Conn, cmds []Cmder, failedCmds *cmdsMap,\n) error {\n\tif err := cn.WithWriter(c.context(ctx), c.opt.WriteTimeout, func(wr *proto.Writer) error {\n\t\treturn writeCmds(wr, cmds)\n\t}); err != nil {\n\t\tif shouldRetry(err, true) {\n\t\t\t_ = c.mapCmdsByNode(ctx, failedCmds, cmds)\n\t\t}\n\t\tsetCmdsErr(cmds, err)\n\t\treturn err\n\t}\n\n\treturn cn.WithReader(c.context(ctx), c.opt.ReadTimeout, func(rd *proto.Reader) error {\n\t\tstatusCmd := cmds[0].(*StatusCmd)\n\t\t// Trim multi and exec.\n\t\ttrimmedCmds := cmds[1 : len(cmds)-1]\n\n\t\tif err := c.txPipelineReadQueued(\n\t\t\tctx, rd, statusCmd, trimmedCmds, failedCmds,\n\t\t); err != nil {\n\t\t\tsetCmdsErr(cmds, err)\n\n\t\t\tmoved, ask, addr := isMovedError(err)\n\t\t\tif moved || ask {\n\t\t\t\treturn c.cmdsMoved(ctx, trimmedCmds, moved, ask, addr, failedCmds)\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\n\t\treturn pipelineReadCmds(rd, trimmedCmds)\n\t})\n}\n\nfunc (c *ClusterClient) txPipelineReadQueued(\n\tctx context.Context,\n\trd *proto.Reader,\n\tstatusCmd *StatusCmd,\n\tcmds []Cmder,\n\tfailedCmds *cmdsMap,\n) error {\n\t// Parse queued replies.\n\tif err := statusCmd.readReply(rd); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, cmd := range cmds {\n\t\terr := statusCmd.readReply(rd)\n\t\tif err == nil || c.checkMovedErr(ctx, cmd, err, failedCmds) || isRedisError(err) {\n\t\t\tcontinue\n\t\t}\n\t\treturn err\n\t}\n\n\t// Parse number of replies.\n\tline, err := rd.ReadLine()\n\tif err != nil {\n\t\tif err == Nil {\n\t\t\terr = TxFailedErr\n\t\t}\n\t\treturn err\n\t}\n\n\tif line[0] != proto.RespArray {\n\t\treturn fmt.Errorf(\"redis: expected '*', but got line %q\", line)\n\t}\n\n\treturn nil\n}\n\nfunc (c *ClusterClient) cmdsMoved(\n\tctx context.Context, cmds []Cmder,\n\tmoved, ask bool,\n\taddr string,\n\tfailedCmds *cmdsMap,\n) error {\n\tnode, err := c.nodes.GetOrCreate(addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif moved {\n\t\tc.state.LazyReload()\n\t\tfor _, cmd := range cmds {\n\t\t\tfailedCmds.Add(node, cmd)\n\t\t}\n\t\treturn nil\n\t}\n\n\tif ask {\n\t\tfor _, cmd := range cmds {\n\t\t\tfailedCmds.Add(node, NewCmd(ctx, \"asking\"), cmd)\n\t\t}\n\t\treturn nil\n\t}\n\n\treturn nil\n}\n\nfunc (c *ClusterClient) Watch(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n\tif len(keys) == 0 {\n\t\treturn fmt.Errorf(\"redis: Watch requires at least one key\")\n\t}\n\n\tslot := hashtag.Slot(keys[0])\n\tfor _, key := range keys[1:] {\n\t\tif hashtag.Slot(key) != slot {\n\t\t\terr := fmt.Errorf(\"redis: Watch requires all keys to be in the same slot\")\n\t\t\treturn err\n\t\t}\n\t}\n\n\tnode, err := c.slotMasterNode(ctx, slot)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor attempt := 0; attempt <= c.opt.MaxRedirects; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\terr = node.Client.Watch(ctx, fn, keys...)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\n\t\tmoved, ask, addr := isMovedError(err)\n\t\tif moved || ask {\n\t\t\tnode, err = c.nodes.GetOrCreate(addr)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif isReadOnly := isReadOnlyError(err); isReadOnly || err == pool.ErrClosed {\n\t\t\tif isReadOnly {\n\t\t\t\tc.state.LazyReload()\n\t\t\t}\n\t\t\tnode, err = c.slotMasterNode(ctx, slot)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif shouldRetry(err, true) {\n\t\t\tcontinue\n\t\t}\n\n\t\treturn err\n\t}\n\n\treturn err\n}\n\nfunc (c *ClusterClient) pubSub() *PubSub {\n\tvar node *clusterNode\n\tpubsub := &PubSub{\n\t\topt: c.opt.clientOptions(),\n\n\t\tnewConn: func(ctx context.Context, channels []string) (*pool.Conn, error) {\n\t\t\tif node != nil {\n\t\t\t\tpanic(\"node != nil\")\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tif len(channels) > 0 {\n\t\t\t\tslot := hashtag.Slot(channels[0])\n\t\t\t\tnode, err = c.slotMasterNode(ctx, slot)\n\t\t\t} else {\n\t\t\t\tnode, err = c.nodes.Random()\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tcn, err := node.Client.newConn(context.TODO())\n\t\t\tif err != nil {\n\t\t\t\tnode = nil\n\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn cn, nil\n\t\t},\n\t\tcloseConn: func(cn *pool.Conn) error {\n\t\t\terr := node.Client.connPool.CloseConn(cn)\n\t\t\tnode = nil\n\t\t\treturn err\n\t\t},\n\t}\n\tpubsub.init()\n\n\treturn pubsub\n}\n\n// Subscribe subscribes the client to the specified channels.\n// Channels can be omitted to create empty subscription.\nfunc (c *ClusterClient) Subscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.Subscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\n// PSubscribe subscribes the client to the given patterns.\n// Patterns can be omitted to create empty subscription.\nfunc (c *ClusterClient) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.PSubscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\n// SSubscribe Subscribes the client to the specified shard channels.\nfunc (c *ClusterClient) SSubscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.SSubscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\nfunc (c *ClusterClient) retryBackoff(attempt int) time.Duration {\n\treturn internal.RetryBackoff(attempt, c.opt.MinRetryBackoff, c.opt.MaxRetryBackoff)\n}\n\nfunc (c *ClusterClient) cmdsInfo(ctx context.Context) (map[string]*CommandInfo, error) {\n\t// Try 3 random nodes.\n\tconst nodeLimit = 3\n\n\taddrs, err := c.nodes.Addrs()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar firstErr error\n\n\tperm := rand.Perm(len(addrs))\n\tif len(perm) > nodeLimit {\n\t\tperm = perm[:nodeLimit]\n\t}\n\n\tfor _, idx := range perm {\n\t\taddr := addrs[idx]\n\n\t\tnode, err := c.nodes.GetOrCreate(addr)\n\t\tif err != nil {\n\t\t\tif firstErr == nil {\n\t\t\t\tfirstErr = err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tinfo, err := node.Client.Command(ctx).Result()\n\t\tif err == nil {\n\t\t\treturn info, nil\n\t\t}\n\t\tif firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\n\tif firstErr == nil {\n\t\tpanic(\"not reached\")\n\t}\n\treturn nil, firstErr\n}\n\nfunc (c *ClusterClient) cmdInfo(ctx context.Context, name string) *CommandInfo {\n\tcmdsInfo, err := c.cmdsInfoCache.Get(ctx)\n\tif err != nil {\n\t\tinternal.Logger.Printf(context.TODO(), \"getting command info: %s\", err)\n\t\treturn nil\n\t}\n\n\tinfo := cmdsInfo[name]\n\tif info == nil {\n\t\tinternal.Logger.Printf(context.TODO(), \"info for cmd=%s not found\", name)\n\t}\n\treturn info\n}\n\nfunc (c *ClusterClient) cmdSlot(ctx context.Context, cmd Cmder) int {\n\targs := cmd.Args()\n\tif args[0] == \"cluster\" && args[1] == \"getkeysinslot\" {\n\t\treturn args[2].(int)\n\t}\n\n\treturn cmdSlot(cmd, cmdFirstKeyPos(cmd))\n}\n\nfunc cmdSlot(cmd Cmder, pos int) int {\n\tif pos == 0 {\n\t\treturn hashtag.RandomSlot()\n\t}\n\tfirstKey := cmd.stringArg(pos)\n\treturn hashtag.Slot(firstKey)\n}\n\nfunc (c *ClusterClient) cmdNode(\n\tctx context.Context,\n\tcmdName string,\n\tslot int,\n) (*clusterNode, error) {\n\tstate, err := c.state.Get(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.opt.ReadOnly {\n\t\tcmdInfo := c.cmdInfo(ctx, cmdName)\n\t\tif cmdInfo != nil && cmdInfo.ReadOnly {\n\t\t\treturn c.slotReadOnlyNode(state, slot)\n\t\t}\n\t}\n\treturn state.slotMasterNode(slot)\n}\n\nfunc (c *ClusterClient) slotReadOnlyNode(state *clusterState, slot int) (*clusterNode, error) {\n\tif c.opt.RouteByLatency {\n\t\treturn state.slotClosestNode(slot)\n\t}\n\tif c.opt.RouteRandomly {\n\t\treturn state.slotRandomNode(slot)\n\t}\n\treturn state.slotSlaveNode(slot)\n}\n\nfunc (c *ClusterClient) slotMasterNode(ctx context.Context, slot int) (*clusterNode, error) {\n\tstate, err := c.state.Get(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn state.slotMasterNode(slot)\n}\n\n// SlaveForKey gets a client for a replica node to run any command on it.\n// This is especially useful if we want to run a particular lua script which has\n// only read only commands on the replica.\n// This is because other redis commands generally have a flag that points that\n// they are read only and automatically run on the replica nodes\n// if ClusterOptions.ReadOnly flag is set to true.\nfunc (c *ClusterClient) SlaveForKey(ctx context.Context, key string) (*Client, error) {\n\tstate, err := c.state.Get(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tslot := hashtag.Slot(key)\n\tnode, err := c.slotReadOnlyNode(state, slot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn node.Client, err\n}\n\n// MasterForKey return a client to the master node for a particular key.\nfunc (c *ClusterClient) MasterForKey(ctx context.Context, key string) (*Client, error) {\n\tslot := hashtag.Slot(key)\n\tnode, err := c.slotMasterNode(ctx, slot)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn node.Client, err\n}\n\nfunc (c *ClusterClient) context(ctx context.Context) context.Context {\n\tif c.opt.ContextTimeoutEnabled {\n\t\treturn ctx\n\t}\n\treturn context.Background()\n}\n\nfunc appendUniqueNode(nodes []*clusterNode, node *clusterNode) []*clusterNode {\n\tfor _, n := range nodes {\n\t\tif n == node {\n\t\t\treturn nodes\n\t\t}\n\t}\n\treturn append(nodes, node)\n}\n\nfunc appendIfNotExists(ss []string, es ...string) []string {\nloop:\n\tfor _, e := range es {\n\t\tfor _, s := range ss {\n\t\t\tif s == e {\n\t\t\t\tcontinue loop\n\t\t\t}\n\t\t}\n\t\tss = append(ss, e)\n\t}\n\treturn ss\n}\n\n//------------------------------------------------------------------------------\n\ntype cmdsMap struct {\n\tmu sync.Mutex\n\tm  map[*clusterNode][]Cmder\n}\n\nfunc newCmdsMap() *cmdsMap {\n\treturn &cmdsMap{\n\t\tm: make(map[*clusterNode][]Cmder),\n\t}\n}\n\nfunc (m *cmdsMap) Add(node *clusterNode, cmds ...Cmder) {\n\tm.mu.Lock()\n\tm.m[node] = append(m.m[node], cmds...)\n\tm.mu.Unlock()\n}\n"
        },
        {
          "name": "osscluster_commands.go",
          "type": "blob",
          "size": 2.3017578125,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\nfunc (c *ClusterClient) DBSize(ctx context.Context) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"dbsize\")\n\t_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n\t\tvar size int64\n\t\terr := c.ForEachMaster(ctx, func(ctx context.Context, master *Client) error {\n\t\t\tn, err := master.DBSize(ctx).Result()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tatomic.AddInt64(&size, n)\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tcmd.SetErr(err)\n\t\t} else {\n\t\t\tcmd.val = size\n\t\t}\n\t\treturn nil\n\t})\n\treturn cmd\n}\n\nfunc (c *ClusterClient) ScriptLoad(ctx context.Context, script string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"script\", \"load\", script)\n\t_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n\t\tvar mu sync.Mutex\n\t\terr := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {\n\t\t\tval, err := shard.ScriptLoad(ctx, script).Result()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmu.Lock()\n\t\t\tif cmd.Val() == \"\" {\n\t\t\t\tcmd.val = val\n\t\t\t}\n\t\t\tmu.Unlock()\n\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tcmd.SetErr(err)\n\t\t}\n\t\treturn nil\n\t})\n\treturn cmd\n}\n\nfunc (c *ClusterClient) ScriptFlush(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"script\", \"flush\")\n\t_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n\t\terr := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {\n\t\t\treturn shard.ScriptFlush(ctx).Err()\n\t\t})\n\t\tif err != nil {\n\t\t\tcmd.SetErr(err)\n\t\t}\n\t\treturn nil\n\t})\n\treturn cmd\n}\n\nfunc (c *ClusterClient) ScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd {\n\targs := make([]interface{}, 2+len(hashes))\n\targs[0] = \"script\"\n\targs[1] = \"exists\"\n\tfor i, hash := range hashes {\n\t\targs[2+i] = hash\n\t}\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\n\tresult := make([]bool, len(hashes))\n\tfor i := range result {\n\t\tresult[i] = true\n\t}\n\n\t_ = c.withProcessHook(ctx, cmd, func(ctx context.Context, _ Cmder) error {\n\t\tvar mu sync.Mutex\n\t\terr := c.ForEachShard(ctx, func(ctx context.Context, shard *Client) error {\n\t\t\tval, err := shard.ScriptExists(ctx, hashes...).Result()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tmu.Lock()\n\t\t\tfor i, v := range val {\n\t\t\t\tresult[i] = result[i] && v\n\t\t\t}\n\t\t\tmu.Unlock()\n\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tcmd.SetErr(err)\n\t\t} else {\n\t\t\tcmd.val = result\n\t\t}\n\t\treturn nil\n\t})\n\treturn cmd\n}\n"
        },
        {
          "name": "osscluster_test.go",
          "type": "blob",
          "size": 42.904296875,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n\t\"github.com/redis/go-redis/v9/internal/hashtag\"\n)\n\ntype clusterScenario struct {\n\tports     []string\n\tnodeIDs   []string\n\tprocesses map[string]*redisProcess\n\tclients   map[string]*redis.Client\n}\n\nfunc (s *clusterScenario) masters() []*redis.Client {\n\tresult := make([]*redis.Client, 3)\n\tfor pos, port := range s.ports[:3] {\n\t\tresult[pos] = s.clients[port]\n\t}\n\treturn result\n}\n\nfunc (s *clusterScenario) slaves() []*redis.Client {\n\tresult := make([]*redis.Client, 3)\n\tfor pos, port := range s.ports[3:] {\n\t\tresult[pos] = s.clients[port]\n\t}\n\treturn result\n}\n\nfunc (s *clusterScenario) addrs() []string {\n\taddrs := make([]string, len(s.ports))\n\tfor i, port := range s.ports {\n\t\taddrs[i] = net.JoinHostPort(\"127.0.0.1\", port)\n\t}\n\treturn addrs\n}\n\nfunc (s *clusterScenario) newClusterClientUnstable(opt *redis.ClusterOptions) *redis.ClusterClient {\n\topt.Addrs = s.addrs()\n\treturn redis.NewClusterClient(opt)\n}\n\nfunc (s *clusterScenario) newClusterClient(\n\tctx context.Context, opt *redis.ClusterOptions,\n) *redis.ClusterClient {\n\tclient := s.newClusterClientUnstable(opt)\n\n\terr := eventually(func() error {\n\t\tif opt.ClusterSlots != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tstate, err := client.LoadState(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !state.IsConsistent(ctx) {\n\t\t\treturn fmt.Errorf(\"cluster state is not consistent\")\n\t\t}\n\n\t\treturn nil\n\t}, 30*time.Second)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn client\n}\n\nfunc (s *clusterScenario) Close() error {\n\tfor _, port := range s.ports {\n\t\tif process, ok := processes[port]; ok {\n\t\t\tprocess.Close()\n\t\t\tdelete(processes, port)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc startCluster(ctx context.Context, scenario *clusterScenario) error {\n\t// Start processes and collect node ids\n\tfor pos, port := range scenario.ports {\n\t\tprocess, err := startRedis(port, \"--cluster-enabled\", \"yes\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tclient := redis.NewClient(&redis.Options{\n\t\t\tAddr: \":\" + port,\n\t\t})\n\n\t\tinfo, err := client.ClusterNodes(ctx).Result()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tscenario.processes[port] = process\n\t\tscenario.clients[port] = client\n\t\tscenario.nodeIDs[pos] = info[:40]\n\t}\n\n\t// Meet cluster nodes.\n\tfor _, client := range scenario.clients {\n\t\terr := client.ClusterMeet(ctx, \"127.0.0.1\", scenario.ports[0]).Err()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Bootstrap masters.\n\tslots := []int{0, 5000, 10000, 16384}\n\tfor pos, master := range scenario.masters() {\n\t\terr := master.ClusterAddSlotsRange(ctx, slots[pos], slots[pos+1]-1).Err()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Bootstrap slaves.\n\tfor idx, slave := range scenario.slaves() {\n\t\tmasterID := scenario.nodeIDs[idx]\n\n\t\t// Wait until master is available\n\t\terr := eventually(func() error {\n\t\t\ts := slave.ClusterNodes(ctx).Val()\n\t\t\twanted := masterID\n\t\t\tif !strings.Contains(s, wanted) {\n\t\t\t\treturn fmt.Errorf(\"%q does not contain %q\", s, wanted)\n\t\t\t}\n\t\t\treturn nil\n\t\t}, 10*time.Second)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = slave.ClusterReplicate(ctx, masterID).Err()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Wait until all nodes have consistent info.\n\twanted := []redis.ClusterSlot{{\n\t\tStart: 0,\n\t\tEnd:   4999,\n\t\tNodes: []redis.ClusterNode{{\n\t\t\tID:   \"\",\n\t\t\tAddr: \"127.0.0.1:8220\",\n\t\t}, {\n\t\t\tID:   \"\",\n\t\t\tAddr: \"127.0.0.1:8223\",\n\t\t}},\n\t}, {\n\t\tStart: 5000,\n\t\tEnd:   9999,\n\t\tNodes: []redis.ClusterNode{{\n\t\t\tID:   \"\",\n\t\t\tAddr: \"127.0.0.1:8221\",\n\t\t}, {\n\t\t\tID:   \"\",\n\t\t\tAddr: \"127.0.0.1:8224\",\n\t\t}},\n\t}, {\n\t\tStart: 10000,\n\t\tEnd:   16383,\n\t\tNodes: []redis.ClusterNode{{\n\t\t\tID:   \"\",\n\t\t\tAddr: \"127.0.0.1:8222\",\n\t\t}, {\n\t\t\tID:   \"\",\n\t\t\tAddr: \"127.0.0.1:8225\",\n\t\t}},\n\t}}\n\tfor _, client := range scenario.clients {\n\t\terr := eventually(func() error {\n\t\t\tres, err := client.ClusterSlots(ctx).Result()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn assertSlotsEqual(res, wanted)\n\t\t}, 30*time.Second)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc assertSlotsEqual(slots, wanted []redis.ClusterSlot) error {\nouterLoop:\n\tfor _, s2 := range wanted {\n\t\tfor _, s1 := range slots {\n\t\t\tif slotEqual(s1, s2) {\n\t\t\t\tcontinue outerLoop\n\t\t\t}\n\t\t}\n\t\treturn fmt.Errorf(\"%v not found in %v\", s2, slots)\n\t}\n\treturn nil\n}\n\nfunc slotEqual(s1, s2 redis.ClusterSlot) bool {\n\tif s1.Start != s2.Start {\n\t\treturn false\n\t}\n\tif s1.End != s2.End {\n\t\treturn false\n\t}\n\tif len(s1.Nodes) != len(s2.Nodes) {\n\t\treturn false\n\t}\n\tfor i, n1 := range s1.Nodes {\n\t\tif n1.Addr != s2.Nodes[i].Addr {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n//------------------------------------------------------------------------------\n\nvar _ = Describe(\"ClusterClient\", func() {\n\tvar failover bool\n\tvar opt *redis.ClusterOptions\n\tvar client *redis.ClusterClient\n\n\tassertClusterClient := func() {\n\t\tIt(\"should GET/SET/DEL\", func() {\n\t\t\terr := client.Get(ctx, \"A\").Err()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\n\t\t\terr = client.Set(ctx, \"A\", \"VALUE\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tEventually(func() string {\n\t\t\t\treturn client.Get(ctx, \"A\").Val()\n\t\t\t}, 30*time.Second).Should(Equal(\"VALUE\"))\n\n\t\t\tcnt, err := client.Del(ctx, \"A\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cnt).To(Equal(int64(1)))\n\t\t})\n\n\t\tIt(\"GET follows redirects\", func() {\n\t\t\terr := client.Set(ctx, \"A\", \"VALUE\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tif !failover {\n\t\t\t\tEventually(func() int64 {\n\t\t\t\t\tnodes, err := client.Nodes(ctx, \"A\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn 0\n\t\t\t\t\t}\n\t\t\t\t\treturn nodes[1].Client.DBSize(ctx).Val()\n\t\t\t\t}, 30*time.Second).Should(Equal(int64(1)))\n\n\t\t\t\tEventually(func() error {\n\t\t\t\t\treturn client.SwapNodes(ctx, \"A\")\n\t\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\t\t\t}\n\n\t\t\tv, err := client.Get(ctx, \"A\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(\"VALUE\"))\n\t\t})\n\n\t\tIt(\"SET follows redirects\", func() {\n\t\t\tif !failover {\n\t\t\t\tEventually(func() error {\n\t\t\t\t\treturn client.SwapNodes(ctx, \"A\")\n\t\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\t\t\t}\n\n\t\t\terr := client.Set(ctx, \"A\", \"VALUE\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.Get(ctx, \"A\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(\"VALUE\"))\n\t\t})\n\n\t\tIt(\"distributes keys\", func() {\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\terr := client.Set(ctx, fmt.Sprintf(\"key%d\", i), \"value\", 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tclient.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tEventually(func() string {\n\t\t\t\t\treturn master.Info(ctx, \"keyspace\").Val()\n\t\t\t\t}, 30*time.Second).Should(Or(\n\t\t\t\t\tContainSubstring(\"keys=31\"),\n\t\t\t\t\tContainSubstring(\"keys=29\"),\n\t\t\t\t\tContainSubstring(\"keys=40\"),\n\t\t\t\t))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\n\t\tIt(\"distributes keys when using EVAL\", func() {\n\t\t\tscript := redis.NewScript(`\n\t\t\t\tlocal r = redis.call('SET', KEYS[1], ARGV[1])\n\t\t\t\treturn r\n\t\t\t`)\n\n\t\t\tvar key string\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tkey = fmt.Sprintf(\"key%d\", i)\n\t\t\t\terr := script.Run(ctx, client, []string{key}, \"value\").Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tclient.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tEventually(func() string {\n\t\t\t\t\treturn master.Info(ctx, \"keyspace\").Val()\n\t\t\t\t}, 30*time.Second).Should(Or(\n\t\t\t\t\tContainSubstring(\"keys=31\"),\n\t\t\t\t\tContainSubstring(\"keys=29\"),\n\t\t\t\t\tContainSubstring(\"keys=40\"),\n\t\t\t\t))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\n\t\tIt(\"distributes scripts when using Script Load\", func() {\n\t\t\tclient.ScriptFlush(ctx)\n\n\t\t\tscript := redis.NewScript(`return 'Unique script'`)\n\n\t\t\tscript.Load(ctx, client)\n\n\t\t\tclient.ForEachShard(ctx, func(ctx context.Context, shard *redis.Client) error {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\tval, _ := script.Exists(ctx, shard).Result()\n\t\t\t\tExpect(val[0]).To(Equal(true))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\n\t\tIt(\"checks all shards when using Script Exists\", func() {\n\t\t\tclient.ScriptFlush(ctx)\n\n\t\t\tscript := redis.NewScript(`return 'First script'`)\n\t\t\tlostScriptSrc := `return 'Lost script'`\n\t\t\tlostScript := redis.NewScript(lostScriptSrc)\n\n\t\t\tscript.Load(ctx, client)\n\t\t\tclient.Do(ctx, \"script\", \"load\", lostScriptSrc)\n\n\t\t\tval, _ := client.ScriptExists(ctx, script.Hash(), lostScript.Hash()).Result()\n\n\t\t\tExpect(val).To(Equal([]bool{true, false}))\n\t\t})\n\n\t\tIt(\"flushes scripts from all shards when using ScriptFlush\", func() {\n\t\t\tscript := redis.NewScript(`return 'Unnecessary script'`)\n\t\t\tscript.Load(ctx, client)\n\n\t\t\tval, _ := client.ScriptExists(ctx, script.Hash()).Result()\n\t\t\tExpect(val).To(Equal([]bool{true}))\n\n\t\t\tclient.ScriptFlush(ctx)\n\n\t\t\tval, _ = client.ScriptExists(ctx, script.Hash()).Result()\n\t\t\tExpect(val).To(Equal([]bool{false}))\n\t\t})\n\n\t\tIt(\"supports Watch\", func() {\n\t\t\tvar incr func(string) error\n\n\t\t\t// Transactionally increments key using GET and SET commands.\n\t\t\tincr = func(key string) error {\n\t\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\t\tn, err := tx.Get(ctx, key).Int64()\n\t\t\t\t\tif err != nil && err != redis.Nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\n\t\t\t\t\t_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\t\tpipe.Set(ctx, key, strconv.FormatInt(n+1, 10), 0)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t})\n\t\t\t\t\treturn err\n\t\t\t\t}, key)\n\t\t\t\tif err == redis.TxFailedErr {\n\t\t\t\t\treturn incr(key)\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tvar wg sync.WaitGroup\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\twg.Add(1)\n\t\t\t\tgo func() {\n\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\tdefer wg.Done()\n\n\t\t\t\t\terr := incr(\"key\")\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}()\n\t\t\t}\n\t\t\twg.Wait()\n\n\t\t\tEventually(func() string {\n\t\t\t\treturn client.Get(ctx, \"key\").Val()\n\t\t\t}, 30*time.Second).Should(Equal(\"100\"))\n\t\t})\n\n\t\tDescribe(\"pipelining\", func() {\n\t\t\tvar pipe *redis.Pipeline\n\n\t\t\tassertPipeline := func() {\n\t\t\t\tkeys := []string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"}\n\n\t\t\t\tIt(\"follows redirects\", func() {\n\t\t\t\t\tif !failover {\n\t\t\t\t\t\tfor _, key := range keys {\n\t\t\t\t\t\t\tEventually(func() error {\n\t\t\t\t\t\t\t\treturn client.SwapNodes(ctx, key)\n\t\t\t\t\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor i, key := range keys {\n\t\t\t\t\t\tpipe.Set(ctx, key, key+\"_value\", 0)\n\t\t\t\t\t\tpipe.Expire(ctx, key, time.Duration(i+1)*time.Hour)\n\t\t\t\t\t}\n\t\t\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(cmds).To(HaveLen(14))\n\n\t\t\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, node *redis.Client) error {\n\t\t\t\t\t\tdefer GinkgoRecover()\n\t\t\t\t\t\tEventually(func() int64 {\n\t\t\t\t\t\t\treturn node.DBSize(ctx).Val()\n\t\t\t\t\t\t}, 30*time.Second).ShouldNot(BeZero())\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t})\n\n\t\t\t\t\tif !failover {\n\t\t\t\t\t\tfor _, key := range keys {\n\t\t\t\t\t\t\tEventually(func() error {\n\t\t\t\t\t\t\t\treturn client.SwapNodes(ctx, key)\n\t\t\t\t\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor _, key := range keys {\n\t\t\t\t\t\tpipe.Get(ctx, key)\n\t\t\t\t\t\tpipe.TTL(ctx, key)\n\t\t\t\t\t}\n\t\t\t\t\tcmds, err = pipe.Exec(ctx)\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(cmds).To(HaveLen(14))\n\n\t\t\t\t\tfor i, key := range keys {\n\t\t\t\t\t\tget := cmds[i*2].(*redis.StringCmd)\n\t\t\t\t\t\tExpect(get.Val()).To(Equal(key + \"_value\"))\n\n\t\t\t\t\t\tttl := cmds[(i*2)+1].(*redis.DurationCmd)\n\t\t\t\t\t\tdur := time.Duration(i+1) * time.Hour\n\t\t\t\t\t\tExpect(ttl.Val()).To(BeNumerically(\"~\", dur, 30*time.Second))\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tIt(\"works with missing keys\", func() {\n\t\t\t\t\tpipe.Set(ctx, \"A\", \"A_value\", 0)\n\t\t\t\t\tpipe.Set(ctx, \"C\", \"C_value\", 0)\n\t\t\t\t\t_, err := pipe.Exec(ctx)\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\ta := pipe.Get(ctx, \"A\")\n\t\t\t\t\tb := pipe.Get(ctx, \"B\")\n\t\t\t\t\tc := pipe.Get(ctx, \"C\")\n\t\t\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\n\t\t\t\t\tExpect(a.Err()).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(a.Val()).To(Equal(\"A_value\"))\n\n\t\t\t\t\tExpect(b.Err()).To(Equal(redis.Nil))\n\t\t\t\t\tExpect(b.Val()).To(Equal(\"\"))\n\n\t\t\t\t\tExpect(c.Err()).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(c.Val()).To(Equal(\"C_value\"))\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tDescribe(\"with Pipeline\", func() {\n\t\t\t\tBeforeEach(func() {\n\t\t\t\t\tpipe = client.Pipeline().(*redis.Pipeline)\n\t\t\t\t})\n\n\t\t\t\tAfterEach(func() {})\n\n\t\t\t\tassertPipeline()\n\t\t\t})\n\n\t\t\tDescribe(\"with TxPipeline\", func() {\n\t\t\t\tBeforeEach(func() {\n\t\t\t\t\tpipe = client.TxPipeline().(*redis.Pipeline)\n\t\t\t\t})\n\n\t\t\t\tAfterEach(func() {})\n\n\t\t\t\tassertPipeline()\n\t\t\t})\n\t\t})\n\n\t\tIt(\"supports PubSub\", func() {\n\t\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\t\tdefer pubsub.Close()\n\n\t\t\tEventually(func() error {\n\t\t\t\t_, err := client.Publish(ctx, \"mychannel\", \"hello\").Result()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tmsg, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t_, ok := msg.(*redis.Message)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn fmt.Errorf(\"got %T, wanted *redis.Message\", msg)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\t\t})\n\n\t\tIt(\"supports sharded PubSub\", func() {\n\t\t\tpubsub := client.SSubscribe(ctx, \"mychannel\")\n\t\t\tdefer pubsub.Close()\n\n\t\t\tEventually(func() error {\n\t\t\t\t_, err := client.SPublish(ctx, \"mychannel\", \"hello\").Result()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tmsg, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t_, ok := msg.(*redis.Message)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn fmt.Errorf(\"got %T, wanted *redis.Message\", msg)\n\t\t\t\t}\n\n\t\t\t\treturn nil\n\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\t\t})\n\n\t\tIt(\"supports PubSub.Ping without channels\", func() {\n\t\t\tpubsub := client.Subscribe(ctx)\n\t\t\tdefer pubsub.Close()\n\n\t\t\terr := pubsub.Ping(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t}\n\n\tDescribe(\"ClusterClient PROTO 2\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt = redisClusterOptions()\n\t\t\topt.Protocol = 2\n\t\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t_ = client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should CLUSTER PROTO 2\", func() {\n\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\t\tval, err := c.Do(ctx, \"HELLO\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(val).Should(ContainElements(\"proto\", int64(2)))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\t})\n\n\tDescribe(\"ClusterClient\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt = redisClusterOptions()\n\t\t\topt.ClientName = \"cluster_hi\"\n\t\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t_ = client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"returns pool stats\", func() {\n\t\t\tstats := client.PoolStats()\n\t\t\tExpect(stats).To(BeAssignableToTypeOf(&redis.PoolStats{}))\n\t\t})\n\n\t\tIt(\"returns an error when there are no attempts left\", func() {\n\t\t\topt := redisClusterOptions()\n\t\t\topt.MaxRedirects = -1\n\t\t\tclient := cluster.newClusterClient(ctx, opt)\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.SwapNodes(ctx, \"A\")\n\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\n\t\t\terr := client.Get(ctx, \"A\").Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(ContainSubstring(\"MOVED\"))\n\n\t\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"determines hash slots correctly for generic commands\", func() {\n\t\t\topt := redisClusterOptions()\n\t\t\topt.MaxRedirects = -1\n\t\t\tclient := cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.Do(ctx, \"GET\", \"A\").Err()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\n\t\t\terr = client.Do(ctx, []byte(\"GET\"), []byte(\"A\")).Err()\n\t\t\tExpect(err).To(Equal(redis.Nil))\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.SwapNodes(ctx, \"A\")\n\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\n\t\t\terr = client.Do(ctx, \"GET\", \"A\").Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(ContainSubstring(\"MOVED\"))\n\n\t\t\terr = client.Do(ctx, []byte(\"GET\"), []byte(\"A\")).Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(ContainSubstring(\"MOVED\"))\n\n\t\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"follows node redirection immediately\", func() {\n\t\t\t// Configure retry backoffs far in excess of the expected duration of redirection\n\t\t\topt := redisClusterOptions()\n\t\t\topt.MinRetryBackoff = 10 * time.Minute\n\t\t\topt.MaxRetryBackoff = 20 * time.Minute\n\t\t\tclient := cluster.newClusterClient(ctx, opt)\n\n\t\t\tEventually(func() error {\n\t\t\t\treturn client.SwapNodes(ctx, \"A\")\n\t\t\t}, 30*time.Second).ShouldNot(HaveOccurred())\n\n\t\t\t// Note that this context sets a deadline more aggressive than the lowest possible bound\n\t\t\t// of the retry backoff; this verifies that redirection completes immediately.\n\t\t\tredirCtx, cancel := context.WithTimeout(ctx, 5*time.Second)\n\t\t\tdefer cancel()\n\n\t\t\terr := client.Set(redirCtx, \"A\", \"VALUE\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tv, err := client.Get(redirCtx, \"A\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(v).To(Equal(\"VALUE\"))\n\n\t\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"calls fn for every master node\", func() {\n\t\t\tfor i := 0; i < 10; i++ {\n\t\t\t\tExpect(client.Set(ctx, strconv.Itoa(i), \"\", 0).Err()).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\terr := client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tsize, err := client.DBSize(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(size).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should CLUSTER SLOTS\", func() {\n\t\t\tres, err := client.ClusterSlots(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(HaveLen(3))\n\n\t\t\twanted := []redis.ClusterSlot{{\n\t\t\t\tStart: 0,\n\t\t\t\tEnd:   4999,\n\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\tID:   \"\",\n\t\t\t\t\tAddr: \"127.0.0.1:8220\",\n\t\t\t\t}, {\n\t\t\t\t\tID:   \"\",\n\t\t\t\t\tAddr: \"127.0.0.1:8223\",\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tStart: 5000,\n\t\t\t\tEnd:   9999,\n\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\tID:   \"\",\n\t\t\t\t\tAddr: \"127.0.0.1:8221\",\n\t\t\t\t}, {\n\t\t\t\t\tID:   \"\",\n\t\t\t\t\tAddr: \"127.0.0.1:8224\",\n\t\t\t\t}},\n\t\t\t}, {\n\t\t\t\tStart: 10000,\n\t\t\t\tEnd:   16383,\n\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\tID:   \"\",\n\t\t\t\t\tAddr: \"127.0.0.1:8222\",\n\t\t\t\t}, {\n\t\t\t\t\tID:   \"\",\n\t\t\t\t\tAddr: \"127.0.0.1:8225\",\n\t\t\t\t}},\n\t\t\t}}\n\t\t\tExpect(assertSlotsEqual(res, wanted)).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"should CLUSTER SHARDS\", func() {\n\t\t\tres, err := client.ClusterShards(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).NotTo(BeEmpty())\n\n\t\t\t// Iterate over the ClusterShard results and validate the fields.\n\t\t\tfor _, shard := range res {\n\t\t\t\tExpect(shard.Slots).NotTo(BeEmpty())\n\t\t\t\tfor _, slotRange := range shard.Slots {\n\t\t\t\t\tExpect(slotRange.Start).To(BeNumerically(\">=\", 0))\n\t\t\t\t\tExpect(slotRange.End).To(BeNumerically(\">=\", slotRange.Start))\n\t\t\t\t}\n\n\t\t\t\tExpect(shard.Nodes).NotTo(BeEmpty())\n\t\t\t\tfor _, node := range shard.Nodes {\n\t\t\t\t\tExpect(node.ID).NotTo(BeEmpty())\n\t\t\t\t\tExpect(node.Endpoint).NotTo(BeEmpty())\n\t\t\t\t\tExpect(node.IP).NotTo(BeEmpty())\n\t\t\t\t\tExpect(node.Port).To(BeNumerically(\">\", 0))\n\n\t\t\t\t\tvalidRoles := []string{\"master\", \"slave\", \"replica\"}\n\t\t\t\t\tExpect(validRoles).To(ContainElement(node.Role))\n\n\t\t\t\t\tExpect(node.ReplicationOffset).To(BeNumerically(\">=\", 0))\n\n\t\t\t\t\tvalidHealthStatuses := []string{\"online\", \"failed\", \"loading\"}\n\t\t\t\t\tExpect(validHealthStatuses).To(ContainElement(node.Health))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should CLUSTER LINKS\", func() {\n\t\t\tres, err := client.ClusterLinks(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).NotTo(BeEmpty())\n\n\t\t\t// Iterate over the ClusterLink results and validate the map keys.\n\t\t\tfor _, link := range res {\n\n\t\t\t\tExpect(link.Direction).NotTo(BeEmpty())\n\t\t\t\tExpect([]string{\"from\", \"to\"}).To(ContainElement(link.Direction))\n\t\t\t\tExpect(link.Node).NotTo(BeEmpty())\n\t\t\t\tExpect(link.CreateTime).To(BeNumerically(\">\", 0))\n\n\t\t\t\tExpect(link.Events).NotTo(BeEmpty())\n\t\t\t\tvalidEventChars := []rune{'r', 'w'}\n\t\t\t\tfor _, eventChar := range link.Events {\n\t\t\t\t\tExpect(validEventChars).To(ContainElement(eventChar))\n\t\t\t\t}\n\n\t\t\t\tExpect(link.SendBufferAllocated).To(BeNumerically(\">=\", 0))\n\t\t\t\tExpect(link.SendBufferUsed).To(BeNumerically(\">=\", 0))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should cluster client setname\", func() {\n\t\t\terr := client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\t\treturn c.Ping(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\t\tval, err := c.ClientList(ctx).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(val).Should(ContainSubstring(\"name=cluster_hi\"))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\n\t\tIt(\"should CLUSTER PROTO 3\", func() {\n\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\t\tval, err := c.Do(ctx, \"HELLO\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(val).Should(HaveKeyWithValue(\"proto\", int64(3)))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\n\t\tIt(\"should CLUSTER MYSHARDID\", func() {\n\t\t\tshardID, err := client.ClusterMyShardID(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(shardID).ToNot(BeEmpty())\n\t\t})\n\n\t\tIt(\"should CLUSTER NODES\", func() {\n\t\t\tres, err := client.ClusterNodes(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(res)).To(BeNumerically(\">\", 400))\n\t\t})\n\n\t\tIt(\"should CLUSTER INFO\", func() {\n\t\t\tres, err := client.ClusterInfo(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(ContainSubstring(\"cluster_known_nodes:6\"))\n\t\t})\n\n\t\tIt(\"should CLUSTER KEYSLOT\", func() {\n\t\t\thashSlot, err := client.ClusterKeySlot(ctx, \"somekey\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(hashSlot).To(Equal(int64(hashtag.Slot(\"somekey\"))))\n\t\t})\n\n\t\tIt(\"should CLUSTER GETKEYSINSLOT\", func() {\n\t\t\tkeys, err := client.ClusterGetKeysInSlot(ctx, hashtag.Slot(\"somekey\"), 1).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(keys)).To(Equal(0))\n\t\t})\n\n\t\tIt(\"should CLUSTER COUNT-FAILURE-REPORTS\", func() {\n\t\t\tn, err := client.ClusterCountFailureReports(ctx, cluster.nodeIDs[0]).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should CLUSTER COUNTKEYSINSLOT\", func() {\n\t\t\tn, err := client.ClusterCountKeysInSlot(ctx, 10).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(n).To(Equal(int64(0)))\n\t\t})\n\n\t\tIt(\"should CLUSTER SAVECONFIG\", func() {\n\t\t\tres, err := client.ClusterSaveConfig(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res).To(Equal(\"OK\"))\n\t\t})\n\n\t\tIt(\"should CLUSTER SLAVES\", func() {\n\t\t\tnodesList, err := client.ClusterSlaves(ctx, cluster.nodeIDs[0]).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(nodesList).Should(ContainElement(ContainSubstring(\"slave\")))\n\t\t\tExpect(nodesList).Should(HaveLen(1))\n\t\t})\n\n\t\tIt(\"should RANDOMKEY\", func() {\n\t\t\tconst nkeys = 100\n\n\t\t\tfor i := 0; i < nkeys; i++ {\n\t\t\t\terr := client.Set(ctx, fmt.Sprintf(\"key%d\", i), \"value\", 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tvar keys []string\n\t\t\taddKey := func(key string) {\n\t\t\t\tfor _, k := range keys {\n\t\t\t\t\tif k == key {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeys = append(keys, key)\n\t\t\t}\n\n\t\t\tfor i := 0; i < nkeys*10; i++ {\n\t\t\t\tkey := client.RandomKey(ctx).Val()\n\t\t\t\taddKey(key)\n\t\t\t}\n\n\t\t\tExpect(len(keys)).To(BeNumerically(\"~\", nkeys, nkeys/10))\n\t\t})\n\n\t\tIt(\"supports Process hook\", func() {\n\t\t\ttestCtx, cancel := context.WithCancel(ctx)\n\t\t\tdefer cancel()\n\n\t\t\terr := client.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ForEachShard(ctx, func(ctx context.Context, node *redis.Client) error {\n\t\t\t\treturn node.Ping(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar stack []string\n\n\t\t\tclusterHook := &hook{\n\t\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase <-testCtx.Done():\n\t\t\t\t\t\t\treturn hook(ctx, cmd)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\tstack = append(stack, \"cluster.BeforeProcess\")\n\n\t\t\t\t\t\terr := hook(ctx, cmd)\n\n\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\tstack = append(stack, \"cluster.AfterProcess\")\n\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t\tclient.AddHook(clusterHook)\n\n\t\t\tnodeHook := &hook{\n\t\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase <-testCtx.Done():\n\t\t\t\t\t\t\treturn hook(ctx, cmd)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\tstack = append(stack, \"shard.BeforeProcess\")\n\n\t\t\t\t\t\terr := hook(ctx, cmd)\n\n\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\tstack = append(stack, \"shard.AfterProcess\")\n\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\n\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, node *redis.Client) error {\n\t\t\t\tnode.AddHook(nodeHook)\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\terr = client.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(stack).To(Equal([]string{\n\t\t\t\t\"cluster.BeforeProcess\",\n\t\t\t\t\"shard.BeforeProcess\",\n\t\t\t\t\"shard.AfterProcess\",\n\t\t\t\t\"cluster.AfterProcess\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"supports Pipeline hook\", func() {\n\t\t\terr := client.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ForEachShard(ctx, func(ctx context.Context, node *redis.Client) error {\n\t\t\t\treturn node.Ping(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar stack []string\n\n\t\t\tclient.AddHook(&hook{\n\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\tstack = append(stack, \"cluster.BeforeProcessPipeline\")\n\n\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\tstack = append(stack, \"cluster.AfterProcessPipeline\")\n\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t})\n\n\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, node *redis.Client) error {\n\t\t\t\tnode.AddHook(&hook{\n\t\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.BeforeProcessPipeline\")\n\n\t\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.AfterProcessPipeline\")\n\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\t_, err = client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(stack).To(Equal([]string{\n\t\t\t\t\"cluster.BeforeProcessPipeline\",\n\t\t\t\t\"shard.BeforeProcessPipeline\",\n\t\t\t\t\"shard.AfterProcessPipeline\",\n\t\t\t\t\"cluster.AfterProcessPipeline\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"supports TxPipeline hook\", func() {\n\t\t\terr := client.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ForEachShard(ctx, func(ctx context.Context, node *redis.Client) error {\n\t\t\t\treturn node.Ping(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar stack []string\n\n\t\t\tclient.AddHook(&hook{\n\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\tstack = append(stack, \"cluster.BeforeProcessPipeline\")\n\n\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\tstack = append(stack, \"cluster.AfterProcessPipeline\")\n\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t})\n\n\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, node *redis.Client) error {\n\t\t\t\tnode.AddHook(&hook{\n\t\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.BeforeProcessPipeline\")\n\n\t\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.AfterProcessPipeline\")\n\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\t_, err = client.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(stack).To(Equal([]string{\n\t\t\t\t\"cluster.BeforeProcessPipeline\",\n\t\t\t\t\"shard.BeforeProcessPipeline\",\n\t\t\t\t\"shard.AfterProcessPipeline\",\n\t\t\t\t\"cluster.AfterProcessPipeline\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"should return correct replica for key\", func() {\n\t\t\tclient, err := client.SlaveForKey(ctx, \"test\")\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tinfo := client.Info(ctx, \"server\")\n\t\t\tExpect(info.Val()).Should(ContainSubstring(\"tcp_port:8224\"))\n\t\t})\n\n\t\tIt(\"should return correct master for key\", func() {\n\t\t\tclient, err := client.MasterForKey(ctx, \"test\")\n\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\tinfo := client.Info(ctx, \"server\")\n\t\t\tExpect(info.Val()).Should(ContainSubstring(\"tcp_port:8221\"))\n\t\t})\n\n\t\tassertClusterClient()\n\t})\n\n\tDescribe(\"ClusterClient with RouteByLatency\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt = redisClusterOptions()\n\t\t\topt.RouteByLatency = true\n\t\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ForEachSlave(ctx, func(ctx context.Context, slave *redis.Client) error {\n\t\t\t\tEventually(func() int64 {\n\t\t\t\t\treturn client.DBSize(ctx).Val()\n\t\t\t\t}, 30*time.Second).Should(Equal(int64(0)))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\terr := client.ForEachSlave(ctx, func(ctx context.Context, slave *redis.Client) error {\n\t\t\t\treturn slave.ReadWrite(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.Close()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tassertClusterClient()\n\t})\n\n\tDescribe(\"ClusterClient with ClusterSlots\", func() {\n\t\tBeforeEach(func() {\n\t\t\tfailover = true\n\n\t\t\topt = redisClusterOptions()\n\t\t\topt.ClusterSlots = func(ctx context.Context) ([]redis.ClusterSlot, error) {\n\t\t\t\tslots := []redis.ClusterSlot{{\n\t\t\t\t\tStart: 0,\n\t\t\t\t\tEnd:   4999,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":\" + ringShard1Port,\n\t\t\t\t\t}},\n\t\t\t\t}, {\n\t\t\t\t\tStart: 5000,\n\t\t\t\t\tEnd:   9999,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":\" + ringShard2Port,\n\t\t\t\t\t}},\n\t\t\t\t}, {\n\t\t\t\t\tStart: 10000,\n\t\t\t\t\tEnd:   16383,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":\" + ringShard3Port,\n\t\t\t\t\t}},\n\t\t\t\t}}\n\t\t\t\treturn slots, nil\n\t\t\t}\n\t\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ForEachSlave(ctx, func(ctx context.Context, slave *redis.Client) error {\n\t\t\t\tEventually(func() int64 {\n\t\t\t\t\treturn client.DBSize(ctx).Val()\n\t\t\t\t}, 30*time.Second).Should(Equal(int64(0)))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tfailover = false\n\n\t\t\terr := client.Close()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tassertClusterClient()\n\t})\n\n\tDescribe(\"ClusterClient with RouteRandomly and ClusterSlots\", func() {\n\t\tBeforeEach(func() {\n\t\t\tfailover = true\n\n\t\t\topt = redisClusterOptions()\n\t\t\topt.RouteRandomly = true\n\t\t\topt.ClusterSlots = func(ctx context.Context) ([]redis.ClusterSlot, error) {\n\t\t\t\tslots := []redis.ClusterSlot{{\n\t\t\t\t\tStart: 0,\n\t\t\t\t\tEnd:   4999,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":\" + ringShard1Port,\n\t\t\t\t\t}},\n\t\t\t\t}, {\n\t\t\t\t\tStart: 5000,\n\t\t\t\t\tEnd:   9999,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":\" + ringShard2Port,\n\t\t\t\t\t}},\n\t\t\t\t}, {\n\t\t\t\t\tStart: 10000,\n\t\t\t\t\tEnd:   16383,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":\" + ringShard3Port,\n\t\t\t\t\t}},\n\t\t\t\t}}\n\t\t\t\treturn slots, nil\n\t\t\t}\n\t\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ForEachSlave(ctx, func(ctx context.Context, slave *redis.Client) error {\n\t\t\t\tEventually(func() int64 {\n\t\t\t\t\treturn client.DBSize(ctx).Val()\n\t\t\t\t}, 30*time.Second).Should(Equal(int64(0)))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tfailover = false\n\n\t\t\terr := client.Close()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tassertClusterClient()\n\t})\n\n\tDescribe(\"ClusterClient with ClusterSlots with multiple nodes per slot\", func() {\n\t\tBeforeEach(func() {\n\t\t\tfailover = true\n\n\t\t\topt = redisClusterOptions()\n\t\t\topt.ReadOnly = true\n\t\t\topt.ClusterSlots = func(ctx context.Context) ([]redis.ClusterSlot, error) {\n\t\t\t\tslots := []redis.ClusterSlot{{\n\t\t\t\t\tStart: 0,\n\t\t\t\t\tEnd:   4999,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":8220\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tAddr: \":8223\",\n\t\t\t\t\t}},\n\t\t\t\t}, {\n\t\t\t\t\tStart: 5000,\n\t\t\t\t\tEnd:   9999,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":8221\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tAddr: \":8224\",\n\t\t\t\t\t}},\n\t\t\t\t}, {\n\t\t\t\t\tStart: 10000,\n\t\t\t\t\tEnd:   16383,\n\t\t\t\t\tNodes: []redis.ClusterNode{{\n\t\t\t\t\t\tAddr: \":8222\",\n\t\t\t\t\t}, {\n\t\t\t\t\t\tAddr: \":8225\",\n\t\t\t\t\t}},\n\t\t\t\t}}\n\t\t\t\treturn slots, nil\n\t\t\t}\n\t\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.ForEachMaster(ctx, func(ctx context.Context, master *redis.Client) error {\n\t\t\t\treturn master.FlushDB(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = client.ForEachSlave(ctx, func(ctx context.Context, slave *redis.Client) error {\n\t\t\t\tEventually(func() int64 {\n\t\t\t\t\treturn client.DBSize(ctx).Val()\n\t\t\t\t}, 30*time.Second).Should(Equal(int64(0)))\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\tfailover = false\n\n\t\t\terr := client.Close()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tassertClusterClient()\n\t})\n})\n\nvar _ = Describe(\"ClusterClient without nodes\", func() {\n\tvar client *redis.ClusterClient\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClusterClient(&redis.ClusterOptions{})\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"Ping returns an error\", func() {\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).To(MatchError(\"redis: cluster has no nodes\"))\n\t})\n\n\tIt(\"pipeline returns an error\", func() {\n\t\t_, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\tpipe.Ping(ctx)\n\t\t\treturn nil\n\t\t})\n\t\tExpect(err).To(MatchError(\"redis: cluster has no nodes\"))\n\t})\n})\n\nvar _ = Describe(\"ClusterClient without valid nodes\", func() {\n\tvar client *redis.ClusterClient\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClusterClient(&redis.ClusterOptions{\n\t\t\tAddrs: []string{redisAddr},\n\t\t})\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"returns an error\", func() {\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).To(MatchError(\"ERR This instance has cluster support disabled\"))\n\t})\n\n\tIt(\"pipeline returns an error\", func() {\n\t\t_, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\tpipe.Ping(ctx)\n\t\t\treturn nil\n\t\t})\n\t\tExpect(err).To(MatchError(\"ERR This instance has cluster support disabled\"))\n\t})\n})\n\nvar _ = Describe(\"ClusterClient with unavailable Cluster\", func() {\n\tvar client *redis.ClusterClient\n\n\tBeforeEach(func() {\n\t\topt := redisClusterOptions()\n\t\topt.ReadTimeout = 250 * time.Millisecond\n\t\topt.WriteTimeout = 250 * time.Millisecond\n\t\topt.MaxRedirects = 1\n\t\tclient = cluster.newClusterClientUnstable(opt)\n\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\n\t\tfor _, node := range cluster.clients {\n\t\t\terr := node.ClientPause(ctx, 5*time.Second).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"recovers when Cluster recovers\", func() {\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).To(HaveOccurred())\n\n\t\tEventually(func() error {\n\t\t\treturn client.Ping(ctx).Err()\n\t\t}, \"30s\").ShouldNot(HaveOccurred())\n\t})\n})\n\nvar _ = Describe(\"ClusterClient timeout\", func() {\n\tvar client *redis.ClusterClient\n\n\tAfterEach(func() {\n\t\t_ = client.Close()\n\t})\n\n\ttestTimeout := func() {\n\t\tIt(\"Ping timeouts\", func() {\n\t\t\terr := client.Ping(ctx).Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Pipeline timeouts\", func() {\n\t\t\t_, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Tx timeouts\", func() {\n\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\treturn tx.Ping(ctx).Err()\n\t\t\t}, \"foo\")\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Tx Pipeline timeouts\", func() {\n\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\t_, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tpipe.Ping(ctx)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\treturn err\n\t\t\t}, \"foo\")\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\t}\n\n\tconst pause = 5 * time.Second\n\n\tContext(\"read/write timeout\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt := redisClusterOptions()\n\t\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\t\terr := client.ForEachShard(ctx, func(ctx context.Context, client *redis.Client) error {\n\t\t\t\terr := client.ClientPause(ctx, pause).Err()\n\n\t\t\t\topt := client.Options()\n\t\t\t\topt.ReadTimeout = time.Nanosecond\n\t\t\t\topt.WriteTimeout = time.Nanosecond\n\n\t\t\t\treturn err\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t// Overwrite timeouts after the client is initialized.\n\t\t\topt.ReadTimeout = time.Nanosecond\n\t\t\topt.WriteTimeout = time.Nanosecond\n\t\t\topt.MaxRedirects = 0\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, client *redis.Client) error {\n\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\topt := client.Options()\n\t\t\t\topt.ReadTimeout = time.Second\n\t\t\t\topt.WriteTimeout = time.Second\n\n\t\t\t\tEventually(func() error {\n\t\t\t\t\treturn client.Ping(ctx).Err()\n\t\t\t\t}, 2*pause).ShouldNot(HaveOccurred())\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\terr := client.Close()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\ttestTimeout()\n\t})\n})\n\nvar _ = Describe(\"ClusterClient ParseURL\", func() {\n\tcases := []struct {\n\t\ttest string\n\t\turl  string\n\t\to    *redis.ClusterOptions // expected value\n\t\terr  error\n\t}{\n\t\t{\n\t\t\ttest: \"ParseRedisURL\",\n\t\t\turl:  \"redis://localhost:123\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}},\n\t\t}, {\n\t\t\ttest: \"ParseRedissURL\",\n\t\t\turl:  \"rediss://localhost:123\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, TLSConfig: &tls.Config{ServerName: \"localhost\"}},\n\t\t}, {\n\t\t\ttest: \"MissingRedisPort\",\n\t\t\turl:  \"redis://localhost\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:6379\"}},\n\t\t}, {\n\t\t\ttest: \"MissingRedissPort\",\n\t\t\turl:  \"rediss://localhost\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:6379\"}, TLSConfig: &tls.Config{ServerName: \"localhost\"}},\n\t\t}, {\n\t\t\ttest: \"MultipleRedisURLs\",\n\t\t\turl:  \"redis://localhost:123?addr=localhost:1234&addr=localhost:12345\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\", \"localhost:1234\", \"localhost:12345\"}},\n\t\t}, {\n\t\t\ttest: \"MultipleRedissURLs\",\n\t\t\turl:  \"rediss://localhost:123?addr=localhost:1234&addr=localhost:12345\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\", \"localhost:1234\", \"localhost:12345\"}, TLSConfig: &tls.Config{ServerName: \"localhost\"}},\n\t\t}, {\n\t\t\ttest: \"OnlyPassword\",\n\t\t\turl:  \"redis://:bar@localhost:123\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, Password: \"bar\"},\n\t\t}, {\n\t\t\ttest: \"OnlyUser\",\n\t\t\turl:  \"redis://foo@localhost:123\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, Username: \"foo\"},\n\t\t}, {\n\t\t\ttest: \"RedisUsernamePassword\",\n\t\t\turl:  \"redis://foo:bar@localhost:123\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, Username: \"foo\", Password: \"bar\"},\n\t\t}, {\n\t\t\ttest: \"RedissUsernamePassword\",\n\t\t\turl:  \"rediss://foo:bar@localhost:123?addr=localhost:1234\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\", \"localhost:1234\"}, Username: \"foo\", Password: \"bar\", TLSConfig: &tls.Config{ServerName: \"localhost\"}},\n\t\t}, {\n\t\t\ttest: \"QueryParameters\",\n\t\t\turl:  \"redis://localhost:123?read_timeout=2&pool_fifo=true&addr=localhost:1234\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\", \"localhost:1234\"}, ReadTimeout: 2 * time.Second, PoolFIFO: true},\n\t\t}, {\n\t\t\ttest: \"DisabledTimeout\",\n\t\t\turl:  \"redis://localhost:123?conn_max_idle_time=0\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, ConnMaxIdleTime: -1},\n\t\t}, {\n\t\t\ttest: \"DisabledTimeoutNeg\",\n\t\t\turl:  \"redis://localhost:123?conn_max_idle_time=-1\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, ConnMaxIdleTime: -1},\n\t\t}, {\n\t\t\ttest: \"UseDefault\",\n\t\t\turl:  \"redis://localhost:123?conn_max_idle_time=\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, ConnMaxIdleTime: 0},\n\t\t}, {\n\t\t\ttest: \"Protocol\",\n\t\t\turl:  \"redis://localhost:123?protocol=2\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, Protocol: 2},\n\t\t}, {\n\t\t\ttest: \"ClientName\",\n\t\t\turl:  \"redis://localhost:123?client_name=cluster_hi\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, ClientName: \"cluster_hi\"},\n\t\t}, {\n\t\t\ttest: \"UseDefaultMissing=\",\n\t\t\turl:  \"redis://localhost:123?conn_max_idle_time\",\n\t\t\to:    &redis.ClusterOptions{Addrs: []string{\"localhost:123\"}, ConnMaxIdleTime: 0},\n\t\t}, {\n\t\t\ttest: \"InvalidQueryAddr\",\n\t\t\turl:  \"rediss://foo:bar@localhost:123?addr=rediss://foo:barr@localhost:1234\",\n\t\t\terr:  errors.New(`redis: unable to parse addr param: rediss://foo:barr@localhost:1234`),\n\t\t}, {\n\t\t\ttest: \"InvalidInt\",\n\t\t\turl:  \"redis://localhost?pool_size=five\",\n\t\t\terr:  errors.New(`redis: invalid pool_size number: strconv.Atoi: parsing \"five\": invalid syntax`),\n\t\t}, {\n\t\t\ttest: \"InvalidBool\",\n\t\t\turl:  \"redis://localhost?pool_fifo=yes\",\n\t\t\terr:  errors.New(`redis: invalid pool_fifo boolean: expected true/false/1/0 or an empty string, got \"yes\"`),\n\t\t}, {\n\t\t\ttest: \"UnknownParam\",\n\t\t\turl:  \"redis://localhost?abc=123\",\n\t\t\terr:  errors.New(\"redis: unexpected option: abc\"),\n\t\t}, {\n\t\t\ttest: \"InvalidScheme\",\n\t\t\turl:  \"https://google.com\",\n\t\t\terr:  errors.New(\"redis: invalid URL scheme: https\"),\n\t\t},\n\t}\n\n\tIt(\"match ParseClusterURL\", func() {\n\t\tfor i := range cases {\n\t\t\ttc := cases[i]\n\t\t\tactual, err := redis.ParseClusterURL(tc.url)\n\t\t\tif tc.err != nil {\n\t\t\t\tExpect(err).Should(MatchError(tc.err))\n\t\t\t} else {\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tif err == nil {\n\t\t\t\tExpect(tc.o).NotTo(BeNil())\n\n\t\t\t\tExpect(tc.o.Addrs).To(Equal(actual.Addrs))\n\t\t\t\tExpect(tc.o.TLSConfig).To(Equal(actual.TLSConfig))\n\t\t\t\tExpect(tc.o.Username).To(Equal(actual.Username))\n\t\t\t\tExpect(tc.o.Password).To(Equal(actual.Password))\n\t\t\t\tExpect(tc.o.MaxRetries).To(Equal(actual.MaxRetries))\n\t\t\t\tExpect(tc.o.MinRetryBackoff).To(Equal(actual.MinRetryBackoff))\n\t\t\t\tExpect(tc.o.MaxRetryBackoff).To(Equal(actual.MaxRetryBackoff))\n\t\t\t\tExpect(tc.o.DialTimeout).To(Equal(actual.DialTimeout))\n\t\t\t\tExpect(tc.o.ReadTimeout).To(Equal(actual.ReadTimeout))\n\t\t\t\tExpect(tc.o.WriteTimeout).To(Equal(actual.WriteTimeout))\n\t\t\t\tExpect(tc.o.PoolFIFO).To(Equal(actual.PoolFIFO))\n\t\t\t\tExpect(tc.o.PoolSize).To(Equal(actual.PoolSize))\n\t\t\t\tExpect(tc.o.MinIdleConns).To(Equal(actual.MinIdleConns))\n\t\t\t\tExpect(tc.o.ConnMaxLifetime).To(Equal(actual.ConnMaxLifetime))\n\t\t\t\tExpect(tc.o.ConnMaxIdleTime).To(Equal(actual.ConnMaxIdleTime))\n\t\t\t\tExpect(tc.o.PoolTimeout).To(Equal(actual.PoolTimeout))\n\t\t\t}\n\t\t}\n\t})\n})\n"
        },
        {
          "name": "pipeline.go",
          "type": "blob",
          "size": 3.2216796875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"errors\"\n)\n\ntype pipelineExecer func(context.Context, []Cmder) error\n\n// Pipeliner is an mechanism to realise Redis Pipeline technique.\n//\n// Pipelining is a technique to extremely speed up processing by packing\n// operations to batches, send them at once to Redis and read a replies in a\n// single step.\n// See https://redis.io/topics/pipelining\n//\n// Pay attention, that Pipeline is not a transaction, so you can get unexpected\n// results in case of big pipelines and small read/write timeouts.\n// Redis client has retransmission logic in case of timeouts, pipeline\n// can be retransmitted and commands can be executed more then once.\n// To avoid this: it is good idea to use reasonable bigger read/write timeouts\n// depends of your batch size and/or use TxPipeline.\ntype Pipeliner interface {\n\tStatefulCmdable\n\n\t// Len is to obtain the number of commands in the pipeline that have not yet been executed.\n\tLen() int\n\n\t// Do is an API for executing any command.\n\t// If a certain Redis command is not yet supported, you can use Do to execute it.\n\tDo(ctx context.Context, args ...interface{}) *Cmd\n\n\t// Process is to put the commands to be executed into the pipeline buffer.\n\tProcess(ctx context.Context, cmd Cmder) error\n\n\t// Discard is to discard all commands in the cache that have not yet been executed.\n\tDiscard()\n\n\t// Exec is to send all the commands buffered in the pipeline to the redis-server.\n\tExec(ctx context.Context) ([]Cmder, error)\n}\n\nvar _ Pipeliner = (*Pipeline)(nil)\n\n// Pipeline implements pipelining as described in\n// http://redis.io/topics/pipelining.\n// Please note: it is not safe for concurrent use by multiple goroutines.\ntype Pipeline struct {\n\tcmdable\n\tstatefulCmdable\n\n\texec pipelineExecer\n\tcmds []Cmder\n}\n\nfunc (c *Pipeline) init() {\n\tc.cmdable = c.Process\n\tc.statefulCmdable = c.Process\n}\n\n// Len returns the number of queued commands.\nfunc (c *Pipeline) Len() int {\n\treturn len(c.cmds)\n}\n\n// Do queues the custom command for later execution.\nfunc (c *Pipeline) Do(ctx context.Context, args ...interface{}) *Cmd {\n\tcmd := NewCmd(ctx, args...)\n\tif len(args) == 0 {\n\t\tcmd.SetErr(errors.New(\"redis: please enter the command to be executed\"))\n\t\treturn cmd\n\t}\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Process queues the cmd for later execution.\nfunc (c *Pipeline) Process(ctx context.Context, cmd Cmder) error {\n\tc.cmds = append(c.cmds, cmd)\n\treturn nil\n}\n\n// Discard resets the pipeline and discards queued commands.\nfunc (c *Pipeline) Discard() {\n\tc.cmds = c.cmds[:0]\n}\n\n// Exec executes all previously queued commands using one\n// client-server roundtrip.\n//\n// Exec always returns list of commands and error of the first failed\n// command if any.\nfunc (c *Pipeline) Exec(ctx context.Context) ([]Cmder, error) {\n\tif len(c.cmds) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tcmds := c.cmds\n\tc.cmds = nil\n\n\treturn cmds, c.exec(ctx, cmds)\n}\n\nfunc (c *Pipeline) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\tif err := fn(c); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Exec(ctx)\n}\n\nfunc (c *Pipeline) Pipeline() Pipeliner {\n\treturn c\n}\n\nfunc (c *Pipeline) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.Pipelined(ctx, fn)\n}\n\nfunc (c *Pipeline) TxPipeline() Pipeliner {\n\treturn c\n}\n"
        },
        {
          "name": "pipeline_test.go",
          "type": "blob",
          "size": 2.5,
          "content": "package redis_test\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"pipelining\", func() {\n\tvar client *redis.Client\n\tvar pipe *redis.Pipeline\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"supports block style\", func() {\n\t\tvar get *redis.StringCmd\n\t\tcmds, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\tget = pipe.Get(ctx, \"foo\")\n\t\t\treturn nil\n\t\t})\n\t\tExpect(err).To(Equal(redis.Nil))\n\t\tExpect(cmds).To(HaveLen(1))\n\t\tExpect(cmds[0]).To(Equal(get))\n\t\tExpect(get.Err()).To(Equal(redis.Nil))\n\t\tExpect(get.Val()).To(Equal(\"\"))\n\t})\n\n\tassertPipeline := func() {\n\t\tIt(\"returns no errors when there are no commands\", func() {\n\t\t\t_, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tIt(\"discards queued commands\", func() {\n\t\t\tpipe.Get(ctx, \"key\")\n\t\t\tpipe.Discard()\n\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cmds).To(BeNil())\n\t\t})\n\n\t\tIt(\"handles val/err\", func() {\n\t\t\terr := client.Set(ctx, \"key\", \"value\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tget := pipe.Get(ctx, \"key\")\n\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cmds).To(HaveLen(1))\n\n\t\t\tval, err := get.Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"value\"))\n\t\t})\n\n\t\tIt(\"supports custom command\", func() {\n\t\t\tpipe.Do(ctx, \"ping\")\n\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t})\n\n\t\tIt(\"handles large pipelines\", Label(\"NonRedisEnterprise\"), func() {\n\t\t\tfor callCount := 1; callCount < 16; callCount++ {\n\t\t\t\tfor i := 1; i <= callCount; i++ {\n\t\t\t\t\tpipe.SetNX(ctx, strconv.Itoa(i)+\"_key\", strconv.Itoa(i)+\"_value\", 0)\n\t\t\t\t}\n\n\t\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmds).To(HaveLen(callCount))\n\t\t\t\tfor _, cmd := range cmds {\n\t\t\t\t\tExpect(cmd).To(BeAssignableToTypeOf(&redis.BoolCmd{}))\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tIt(\"should Exec, not Do\", func() {\n\t\t\terr := pipe.Do(ctx).Err()\n\t\t\tExpect(err).To(Equal(errors.New(\"redis: please enter the command to be executed\")))\n\t\t})\n\t}\n\n\tDescribe(\"Pipeline\", func() {\n\t\tBeforeEach(func() {\n\t\t\tpipe = client.Pipeline().(*redis.Pipeline)\n\t\t})\n\n\t\tassertPipeline()\n\t})\n\n\tDescribe(\"TxPipeline\", func() {\n\t\tBeforeEach(func() {\n\t\t\tpipe = client.TxPipeline().(*redis.Pipeline)\n\t\t})\n\n\t\tassertPipeline()\n\t})\n})\n"
        },
        {
          "name": "pool_test.go",
          "type": "blob",
          "size": 3.2119140625,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"pool\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\topt := redisOptions()\n\t\topt.MinIdleConns = 0\n\t\topt.ConnMaxLifetime = 0\n\t\topt.ConnMaxIdleTime = time.Second\n\t\tclient = redis.NewClient(opt)\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"respects max size\", func() {\n\t\tperform(1000, func(id int) {\n\t\t\tval, err := client.Ping(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"PONG\"))\n\t\t})\n\n\t\tpool := client.Pool()\n\t\tExpect(pool.Len()).To(BeNumerically(\"<=\", 10))\n\t\tExpect(pool.IdleLen()).To(BeNumerically(\"<=\", 10))\n\t\tExpect(pool.Len()).To(Equal(pool.IdleLen()))\n\t})\n\n\tIt(\"respects max size on multi\", func() {\n\t\tperform(1000, func(id int) {\n\t\t\tvar ping *redis.StatusCmd\n\n\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\tcmds, err := tx.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tping = pipe.Ping(ctx)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\treturn err\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(ping.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ping.Val()).To(Equal(\"PONG\"))\n\t\t})\n\n\t\tpool := client.Pool()\n\t\tExpect(pool.Len()).To(BeNumerically(\"<=\", 10))\n\t\tExpect(pool.IdleLen()).To(BeNumerically(\"<=\", 10))\n\t\tExpect(pool.Len()).To(Equal(pool.IdleLen()))\n\t})\n\n\tIt(\"respects max size on pipelines\", func() {\n\t\tperform(1000, func(id int) {\n\t\t\tpipe := client.Pipeline()\n\t\t\tping := pipe.Ping(ctx)\n\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\tExpect(ping.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ping.Val()).To(Equal(\"PONG\"))\n\t\t})\n\n\t\tpool := client.Pool()\n\t\tExpect(pool.Len()).To(BeNumerically(\"<=\", 10))\n\t\tExpect(pool.IdleLen()).To(BeNumerically(\"<=\", 10))\n\t\tExpect(pool.Len()).To(Equal(pool.IdleLen()))\n\t})\n\n\tIt(\"removes broken connections\", func() {\n\t\tcn, err := client.Pool().Get(context.Background())\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tcn.SetNetConn(&badConn{})\n\t\tclient.Pool().Put(ctx, cn)\n\n\t\tval, err := client.Ping(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(\"PONG\"))\n\n\t\tval, err = client.Ping(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(\"PONG\"))\n\n\t\tpool := client.Pool()\n\t\tExpect(pool.Len()).To(Equal(1))\n\t\tExpect(pool.IdleLen()).To(Equal(1))\n\n\t\tstats := pool.Stats()\n\t\tExpect(stats.Hits).To(Equal(uint32(1)))\n\t\tExpect(stats.Misses).To(Equal(uint32(2)))\n\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t})\n\n\tIt(\"reuses connections\", func() {\n\t\t// explain: https://github.com/redis/go-redis/pull/1675\n\t\topt := redisOptions()\n\t\topt.MinIdleConns = 0\n\t\topt.ConnMaxLifetime = 0\n\t\topt.ConnMaxIdleTime = 10 * time.Second\n\t\tclient = redis.NewClient(opt)\n\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tval, err := client.Ping(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).To(Equal(\"PONG\"))\n\t\t}\n\n\t\tpool := client.Pool()\n\t\tExpect(pool.Len()).To(Equal(1))\n\t\tExpect(pool.IdleLen()).To(Equal(1))\n\n\t\tstats := pool.Stats()\n\t\tExpect(stats.Hits).To(Equal(uint32(99)))\n\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t\tExpect(stats.Timeouts).To(Equal(uint32(0)))\n\t})\n})\n"
        },
        {
          "name": "probabilistic.go",
          "type": "blob",
          "size": 47.142578125,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\ntype ProbabilisticCmdable interface {\n\tBFAdd(ctx context.Context, key string, element interface{}) *BoolCmd\n\tBFCard(ctx context.Context, key string) *IntCmd\n\tBFExists(ctx context.Context, key string, element interface{}) *BoolCmd\n\tBFInfo(ctx context.Context, key string) *BFInfoCmd\n\tBFInfoArg(ctx context.Context, key, option string) *BFInfoCmd\n\tBFInfoCapacity(ctx context.Context, key string) *BFInfoCmd\n\tBFInfoSize(ctx context.Context, key string) *BFInfoCmd\n\tBFInfoFilters(ctx context.Context, key string) *BFInfoCmd\n\tBFInfoItems(ctx context.Context, key string) *BFInfoCmd\n\tBFInfoExpansion(ctx context.Context, key string) *BFInfoCmd\n\tBFInsert(ctx context.Context, key string, options *BFInsertOptions, elements ...interface{}) *BoolSliceCmd\n\tBFMAdd(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd\n\tBFMExists(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd\n\tBFReserve(ctx context.Context, key string, errorRate float64, capacity int64) *StatusCmd\n\tBFReserveExpansion(ctx context.Context, key string, errorRate float64, capacity, expansion int64) *StatusCmd\n\tBFReserveNonScaling(ctx context.Context, key string, errorRate float64, capacity int64) *StatusCmd\n\tBFReserveWithArgs(ctx context.Context, key string, options *BFReserveOptions) *StatusCmd\n\tBFScanDump(ctx context.Context, key string, iterator int64) *ScanDumpCmd\n\tBFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *StatusCmd\n\n\tCFAdd(ctx context.Context, key string, element interface{}) *BoolCmd\n\tCFAddNX(ctx context.Context, key string, element interface{}) *BoolCmd\n\tCFCount(ctx context.Context, key string, element interface{}) *IntCmd\n\tCFDel(ctx context.Context, key string, element interface{}) *BoolCmd\n\tCFExists(ctx context.Context, key string, element interface{}) *BoolCmd\n\tCFInfo(ctx context.Context, key string) *CFInfoCmd\n\tCFInsert(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{}) *BoolSliceCmd\n\tCFInsertNX(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{}) *IntSliceCmd\n\tCFMExists(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd\n\tCFReserve(ctx context.Context, key string, capacity int64) *StatusCmd\n\tCFReserveWithArgs(ctx context.Context, key string, options *CFReserveOptions) *StatusCmd\n\tCFReserveExpansion(ctx context.Context, key string, capacity int64, expansion int64) *StatusCmd\n\tCFReserveBucketSize(ctx context.Context, key string, capacity int64, bucketsize int64) *StatusCmd\n\tCFReserveMaxIterations(ctx context.Context, key string, capacity int64, maxiterations int64) *StatusCmd\n\tCFScanDump(ctx context.Context, key string, iterator int64) *ScanDumpCmd\n\tCFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *StatusCmd\n\n\tCMSIncrBy(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd\n\tCMSInfo(ctx context.Context, key string) *CMSInfoCmd\n\tCMSInitByDim(ctx context.Context, key string, width, height int64) *StatusCmd\n\tCMSInitByProb(ctx context.Context, key string, errorRate, probability float64) *StatusCmd\n\tCMSMerge(ctx context.Context, destKey string, sourceKeys ...string) *StatusCmd\n\tCMSMergeWithWeight(ctx context.Context, destKey string, sourceKeys map[string]int64) *StatusCmd\n\tCMSQuery(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd\n\n\tTopKAdd(ctx context.Context, key string, elements ...interface{}) *StringSliceCmd\n\tTopKCount(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd\n\tTopKIncrBy(ctx context.Context, key string, elements ...interface{}) *StringSliceCmd\n\tTopKInfo(ctx context.Context, key string) *TopKInfoCmd\n\tTopKList(ctx context.Context, key string) *StringSliceCmd\n\tTopKListWithCount(ctx context.Context, key string) *MapStringIntCmd\n\tTopKQuery(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd\n\tTopKReserve(ctx context.Context, key string, k int64) *StatusCmd\n\tTopKReserveWithOptions(ctx context.Context, key string, k int64, width, depth int64, decay float64) *StatusCmd\n\n\tTDigestAdd(ctx context.Context, key string, elements ...float64) *StatusCmd\n\tTDigestByRank(ctx context.Context, key string, rank ...uint64) *FloatSliceCmd\n\tTDigestByRevRank(ctx context.Context, key string, rank ...uint64) *FloatSliceCmd\n\tTDigestCDF(ctx context.Context, key string, elements ...float64) *FloatSliceCmd\n\tTDigestCreate(ctx context.Context, key string) *StatusCmd\n\tTDigestCreateWithCompression(ctx context.Context, key string, compression int64) *StatusCmd\n\tTDigestInfo(ctx context.Context, key string) *TDigestInfoCmd\n\tTDigestMax(ctx context.Context, key string) *FloatCmd\n\tTDigestMin(ctx context.Context, key string) *FloatCmd\n\tTDigestMerge(ctx context.Context, destKey string, options *TDigestMergeOptions, sourceKeys ...string) *StatusCmd\n\tTDigestQuantile(ctx context.Context, key string, elements ...float64) *FloatSliceCmd\n\tTDigestRank(ctx context.Context, key string, values ...float64) *IntSliceCmd\n\tTDigestReset(ctx context.Context, key string) *StatusCmd\n\tTDigestRevRank(ctx context.Context, key string, values ...float64) *IntSliceCmd\n\tTDigestTrimmedMean(ctx context.Context, key string, lowCutQuantile, highCutQuantile float64) *FloatCmd\n}\n\ntype BFInsertOptions struct {\n\tCapacity   int64\n\tError      float64\n\tExpansion  int64\n\tNonScaling bool\n\tNoCreate   bool\n}\n\ntype BFReserveOptions struct {\n\tCapacity   int64\n\tError      float64\n\tExpansion  int64\n\tNonScaling bool\n}\n\ntype CFReserveOptions struct {\n\tCapacity      int64\n\tBucketSize    int64\n\tMaxIterations int64\n\tExpansion     int64\n}\n\ntype CFInsertOptions struct {\n\tCapacity int64\n\tNoCreate bool\n}\n\n// -------------------------------------------\n// Bloom filter commands\n//-------------------------------------------\n\n// BFReserve creates an empty Bloom filter with a single sub-filter\n// for the initial specified capacity and with an upper bound error_rate.\n// For more information - https://redis.io/commands/bf.reserve/\nfunc (c cmdable) BFReserve(ctx context.Context, key string, errorRate float64, capacity int64) *StatusCmd {\n\targs := []interface{}{\"BF.RESERVE\", key, errorRate, capacity}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFReserveExpansion creates an empty Bloom filter with a single sub-filter\n// for the initial specified capacity and with an upper bound error_rate.\n// This function also allows for specifying an expansion rate for the filter.\n// For more information - https://redis.io/commands/bf.reserve/\nfunc (c cmdable) BFReserveExpansion(ctx context.Context, key string, errorRate float64, capacity, expansion int64) *StatusCmd {\n\targs := []interface{}{\"BF.RESERVE\", key, errorRate, capacity, \"EXPANSION\", expansion}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFReserveNonScaling creates an empty Bloom filter with a single sub-filter\n// for the initial specified capacity and with an upper bound error_rate.\n// This function also allows for specifying that the filter should not scale.\n// For more information - https://redis.io/commands/bf.reserve/\nfunc (c cmdable) BFReserveNonScaling(ctx context.Context, key string, errorRate float64, capacity int64) *StatusCmd {\n\targs := []interface{}{\"BF.RESERVE\", key, errorRate, capacity, \"NONSCALING\"}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFReserveWithArgs creates an empty Bloom filter with a single sub-filter\n// for the initial specified capacity and with an upper bound error_rate.\n// This function also allows for specifying additional options such as expansion rate and non-scaling behavior.\n// For more information - https://redis.io/commands/bf.reserve/\nfunc (c cmdable) BFReserveWithArgs(ctx context.Context, key string, options *BFReserveOptions) *StatusCmd {\n\targs := []interface{}{\"BF.RESERVE\", key}\n\tif options != nil {\n\t\targs = append(args, options.Error, options.Capacity)\n\t\tif options.Expansion != 0 {\n\t\t\targs = append(args, \"EXPANSION\", options.Expansion)\n\t\t}\n\t\tif options.NonScaling {\n\t\t\targs = append(args, \"NONSCALING\")\n\t\t}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFAdd adds an item to a Bloom filter.\n// For more information - https://redis.io/commands/bf.add/\nfunc (c cmdable) BFAdd(ctx context.Context, key string, element interface{}) *BoolCmd {\n\targs := []interface{}{\"BF.ADD\", key, element}\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFCard returns the cardinality of a Bloom filter -\n// number of items that were added to a Bloom filter and detected as unique\n// (items that caused at least one bit to be set in at least one sub-filter).\n// For more information - https://redis.io/commands/bf.card/\nfunc (c cmdable) BFCard(ctx context.Context, key string) *IntCmd {\n\targs := []interface{}{\"BF.CARD\", key}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFExists determines whether a given item was added to a Bloom filter.\n// For more information - https://redis.io/commands/bf.exists/\nfunc (c cmdable) BFExists(ctx context.Context, key string, element interface{}) *BoolCmd {\n\targs := []interface{}{\"BF.EXISTS\", key, element}\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFLoadChunk restores a Bloom filter previously saved using BF.SCANDUMP.\n// For more information - https://redis.io/commands/bf.loadchunk/\nfunc (c cmdable) BFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *StatusCmd {\n\targs := []interface{}{\"BF.LOADCHUNK\", key, iterator, data}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// Begins an incremental save of the Bloom filter.\n// This command is useful for large Bloom filters that cannot fit into the DUMP and RESTORE model.\n// For more information - https://redis.io/commands/bf.scandump/\nfunc (c cmdable) BFScanDump(ctx context.Context, key string, iterator int64) *ScanDumpCmd {\n\targs := []interface{}{\"BF.SCANDUMP\", key, iterator}\n\tcmd := newScanDumpCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype ScanDump struct {\n\tIter int64\n\tData string\n}\n\ntype ScanDumpCmd struct {\n\tbaseCmd\n\n\tval ScanDump\n}\n\nfunc newScanDumpCmd(ctx context.Context, args ...interface{}) *ScanDumpCmd {\n\treturn &ScanDumpCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *ScanDumpCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *ScanDumpCmd) SetVal(val ScanDump) {\n\tcmd.val = val\n}\n\nfunc (cmd *ScanDumpCmd) Result() (ScanDump, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *ScanDumpCmd) Val() ScanDump {\n\treturn cmd.val\n}\n\nfunc (cmd *ScanDumpCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = ScanDump{}\n\tfor i := 0; i < n; i++ {\n\t\titer, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdata, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val.Data = data\n\t\tcmd.val.Iter = iter\n\n\t}\n\n\treturn nil\n}\n\n// Returns information about a Bloom filter.\n// For more information - https://redis.io/commands/bf.info/\nfunc (c cmdable) BFInfo(ctx context.Context, key string) *BFInfoCmd {\n\targs := []interface{}{\"BF.INFO\", key}\n\tcmd := NewBFInfoCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype BFInfo struct {\n\tCapacity      int64\n\tSize          int64\n\tFilters       int64\n\tItemsInserted int64\n\tExpansionRate int64\n}\n\ntype BFInfoCmd struct {\n\tbaseCmd\n\n\tval BFInfo\n}\n\nfunc NewBFInfoCmd(ctx context.Context, args ...interface{}) *BFInfoCmd {\n\treturn &BFInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *BFInfoCmd) SetVal(val BFInfo) {\n\tcmd.val = val\n}\n\nfunc (cmd *BFInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *BFInfoCmd) Val() BFInfo {\n\treturn cmd.val\n}\n\nfunc (cmd *BFInfoCmd) Result() (BFInfo, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *BFInfoCmd) readReply(rd *proto.Reader) (err error) {\n\tresult := BFInfo{}\n\n\t// Create a mapping from key names to pointers of struct fields\n\trespMapping := map[string]*int64{\n\t\t\"Capacity\":                 &result.Capacity,\n\t\t\"CAPACITY\":                 &result.Capacity,\n\t\t\"Size\":                     &result.Size,\n\t\t\"SIZE\":                     &result.Size,\n\t\t\"Number of filters\":        &result.Filters,\n\t\t\"FILTERS\":                  &result.Filters,\n\t\t\"Number of items inserted\": &result.ItemsInserted,\n\t\t\"ITEMS\":                    &result.ItemsInserted,\n\t\t\"Expansion rate\":           &result.ExpansionRate,\n\t\t\"EXPANSION\":                &result.ExpansionRate,\n\t}\n\n\t// Helper function to read and assign a value based on the key\n\treadAndAssignValue := func(key string) error {\n\t\tfieldPtr, exists := respMapping[key]\n\t\tif !exists {\n\t\t\treturn fmt.Errorf(\"redis: BLOOM.INFO unexpected key %s\", key)\n\t\t}\n\n\t\t// Read the integer and assign to the field via pointer dereferencing\n\t\tval, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*fieldPtr = val\n\t\treturn nil\n\t}\n\n\treadType, err := rd.PeekReplyType()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(cmd.args) > 2 && readType == proto.RespArray {\n\t\tn, err := rd.ReadArrayLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif key, ok := cmd.args[2].(string); ok && n == 1 {\n\t\t\tif err := readAndAssignValue(key); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"redis: BLOOM.INFO invalid argument key type\")\n\t\t}\n\t} else {\n\t\tn, err := rd.ReadMapLen()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i := 0; i < n; i++ {\n\t\t\tkey, err := rd.ReadString()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := readAndAssignValue(key); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd.val = result\n\treturn nil\n}\n\n// BFInfoCapacity returns information about the capacity of a Bloom filter.\n// For more information - https://redis.io/commands/bf.info/\nfunc (c cmdable) BFInfoCapacity(ctx context.Context, key string) *BFInfoCmd {\n\treturn c.BFInfoArg(ctx, key, \"CAPACITY\")\n}\n\n// BFInfoSize returns information about the size of a Bloom filter.\n// For more information - https://redis.io/commands/bf.info/\nfunc (c cmdable) BFInfoSize(ctx context.Context, key string) *BFInfoCmd {\n\treturn c.BFInfoArg(ctx, key, \"SIZE\")\n}\n\n// BFInfoFilters returns information about the filters of a Bloom filter.\n// For more information - https://redis.io/commands/bf.info/\nfunc (c cmdable) BFInfoFilters(ctx context.Context, key string) *BFInfoCmd {\n\treturn c.BFInfoArg(ctx, key, \"FILTERS\")\n}\n\n// BFInfoItems returns information about the items of a Bloom filter.\n// For more information - https://redis.io/commands/bf.info/\nfunc (c cmdable) BFInfoItems(ctx context.Context, key string) *BFInfoCmd {\n\treturn c.BFInfoArg(ctx, key, \"ITEMS\")\n}\n\n// BFInfoExpansion returns information about the expansion rate of a Bloom filter.\n// For more information - https://redis.io/commands/bf.info/\nfunc (c cmdable) BFInfoExpansion(ctx context.Context, key string) *BFInfoCmd {\n\treturn c.BFInfoArg(ctx, key, \"EXPANSION\")\n}\n\n// BFInfoArg returns information about a specific option of a Bloom filter.\n// For more information - https://redis.io/commands/bf.info/\nfunc (c cmdable) BFInfoArg(ctx context.Context, key, option string) *BFInfoCmd {\n\targs := []interface{}{\"BF.INFO\", key, option}\n\tcmd := NewBFInfoCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFInsert inserts elements into a Bloom filter.\n// This function also allows for specifying additional options such as:\n// capacity, error rate, expansion rate, and non-scaling behavior.\n// For more information - https://redis.io/commands/bf.insert/\nfunc (c cmdable) BFInsert(ctx context.Context, key string, options *BFInsertOptions, elements ...interface{}) *BoolSliceCmd {\n\targs := []interface{}{\"BF.INSERT\", key}\n\tif options != nil {\n\t\tif options.Capacity != 0 {\n\t\t\targs = append(args, \"CAPACITY\", options.Capacity)\n\t\t}\n\t\tif options.Error != 0 {\n\t\t\targs = append(args, \"ERROR\", options.Error)\n\t\t}\n\t\tif options.Expansion != 0 {\n\t\t\targs = append(args, \"EXPANSION\", options.Expansion)\n\t\t}\n\t\tif options.NoCreate {\n\t\t\targs = append(args, \"NOCREATE\")\n\t\t}\n\t\tif options.NonScaling {\n\t\t\targs = append(args, \"NONSCALING\")\n\t\t}\n\t}\n\targs = append(args, \"ITEMS\")\n\targs = append(args, elements...)\n\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFMAdd adds multiple elements to a Bloom filter.\n// Returns an array of booleans indicating whether each element was added to the filter or not.\n// For more information - https://redis.io/commands/bf.madd/\nfunc (c cmdable) BFMAdd(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {\n\targs := []interface{}{\"BF.MADD\", key}\n\targs = append(args, elements...)\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BFMExists check if multiple elements exist in a Bloom filter.\n// Returns an array of booleans indicating whether each element exists in the filter or not.\n// For more information - https://redis.io/commands/bf.mexists/\nfunc (c cmdable) BFMExists(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {\n\targs := []interface{}{\"BF.MEXISTS\", key}\n\targs = append(args, elements...)\n\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// -------------------------------------------\n// Cuckoo filter commands\n//-------------------------------------------\n\n// CFReserve creates an empty Cuckoo filter with the specified capacity.\n// For more information - https://redis.io/commands/cf.reserve/\nfunc (c cmdable) CFReserve(ctx context.Context, key string, capacity int64) *StatusCmd {\n\targs := []interface{}{\"CF.RESERVE\", key, capacity}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFReserveExpansion creates an empty Cuckoo filter with the specified capacity and expansion rate.\n// For more information - https://redis.io/commands/cf.reserve/\nfunc (c cmdable) CFReserveExpansion(ctx context.Context, key string, capacity int64, expansion int64) *StatusCmd {\n\targs := []interface{}{\"CF.RESERVE\", key, capacity, \"EXPANSION\", expansion}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFReserveBucketSize creates an empty Cuckoo filter with the specified capacity and bucket size.\n// For more information - https://redis.io/commands/cf.reserve/\nfunc (c cmdable) CFReserveBucketSize(ctx context.Context, key string, capacity int64, bucketsize int64) *StatusCmd {\n\targs := []interface{}{\"CF.RESERVE\", key, capacity, \"BUCKETSIZE\", bucketsize}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFReserveMaxIterations creates an empty Cuckoo filter with the specified capacity and maximum number of iterations.\n// For more information - https://redis.io/commands/cf.reserve/\nfunc (c cmdable) CFReserveMaxIterations(ctx context.Context, key string, capacity int64, maxiterations int64) *StatusCmd {\n\targs := []interface{}{\"CF.RESERVE\", key, capacity, \"MAXITERATIONS\", maxiterations}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFReserveWithArgs creates an empty Cuckoo filter with the specified options.\n// This function allows for specifying additional options such as bucket size and maximum number of iterations.\n// For more information - https://redis.io/commands/cf.reserve/\nfunc (c cmdable) CFReserveWithArgs(ctx context.Context, key string, options *CFReserveOptions) *StatusCmd {\n\targs := []interface{}{\"CF.RESERVE\", key, options.Capacity}\n\tif options.BucketSize != 0 {\n\t\targs = append(args, \"BUCKETSIZE\", options.BucketSize)\n\t}\n\tif options.MaxIterations != 0 {\n\t\targs = append(args, \"MAXITERATIONS\", options.MaxIterations)\n\t}\n\tif options.Expansion != 0 {\n\t\targs = append(args, \"EXPANSION\", options.Expansion)\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFAdd adds an element to a Cuckoo filter.\n// Returns true if the element was added to the filter or false if it already exists in the filter.\n// For more information - https://redis.io/commands/cf.add/\nfunc (c cmdable) CFAdd(ctx context.Context, key string, element interface{}) *BoolCmd {\n\targs := []interface{}{\"CF.ADD\", key, element}\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFAddNX adds an element to a Cuckoo filter only if it does not already exist in the filter.\n// Returns true if the element was added to the filter or false if it already exists in the filter.\n// For more information - https://redis.io/commands/cf.addnx/\nfunc (c cmdable) CFAddNX(ctx context.Context, key string, element interface{}) *BoolCmd {\n\targs := []interface{}{\"CF.ADDNX\", key, element}\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFCount returns an estimate of the number of times an element may be in a Cuckoo Filter.\n// For more information - https://redis.io/commands/cf.count/\nfunc (c cmdable) CFCount(ctx context.Context, key string, element interface{}) *IntCmd {\n\targs := []interface{}{\"CF.COUNT\", key, element}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFDel deletes an item once from the cuckoo filter.\n// For more information - https://redis.io/commands/cf.del/\nfunc (c cmdable) CFDel(ctx context.Context, key string, element interface{}) *BoolCmd {\n\targs := []interface{}{\"CF.DEL\", key, element}\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFExists determines whether an item may exist in the Cuckoo Filter or not.\n// For more information - https://redis.io/commands/cf.exists/\nfunc (c cmdable) CFExists(ctx context.Context, key string, element interface{}) *BoolCmd {\n\targs := []interface{}{\"CF.EXISTS\", key, element}\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFLoadChunk restores a filter previously saved using SCANDUMP.\n// For more information - https://redis.io/commands/cf.loadchunk/\nfunc (c cmdable) CFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *StatusCmd {\n\targs := []interface{}{\"CF.LOADCHUNK\", key, iterator, data}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFScanDump begins an incremental save of the cuckoo filter.\n// For more information - https://redis.io/commands/cf.scandump/\nfunc (c cmdable) CFScanDump(ctx context.Context, key string, iterator int64) *ScanDumpCmd {\n\targs := []interface{}{\"CF.SCANDUMP\", key, iterator}\n\tcmd := newScanDumpCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype CFInfo struct {\n\tSize             int64\n\tNumBuckets       int64\n\tNumFilters       int64\n\tNumItemsInserted int64\n\tNumItemsDeleted  int64\n\tBucketSize       int64\n\tExpansionRate    int64\n\tMaxIteration     int64\n}\n\ntype CFInfoCmd struct {\n\tbaseCmd\n\n\tval CFInfo\n}\n\nfunc NewCFInfoCmd(ctx context.Context, args ...interface{}) *CFInfoCmd {\n\treturn &CFInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *CFInfoCmd) SetVal(val CFInfo) {\n\tcmd.val = val\n}\n\nfunc (cmd *CFInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *CFInfoCmd) Val() CFInfo {\n\treturn cmd.val\n}\n\nfunc (cmd *CFInfoCmd) Result() (CFInfo, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *CFInfoCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar key string\n\tvar result CFInfo\n\tfor f := 0; f < n; f++ {\n\t\tkey, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"Size\":\n\t\t\tresult.Size, err = rd.ReadInt()\n\t\tcase \"Number of buckets\":\n\t\t\tresult.NumBuckets, err = rd.ReadInt()\n\t\tcase \"Number of filters\":\n\t\t\tresult.NumFilters, err = rd.ReadInt()\n\t\tcase \"Number of items inserted\":\n\t\t\tresult.NumItemsInserted, err = rd.ReadInt()\n\t\tcase \"Number of items deleted\":\n\t\t\tresult.NumItemsDeleted, err = rd.ReadInt()\n\t\tcase \"Bucket size\":\n\t\t\tresult.BucketSize, err = rd.ReadInt()\n\t\tcase \"Expansion rate\":\n\t\t\tresult.ExpansionRate, err = rd.ReadInt()\n\t\tcase \"Max iterations\":\n\t\t\tresult.MaxIteration, err = rd.ReadInt()\n\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: CF.INFO unexpected key %s\", key)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcmd.val = result\n\treturn nil\n}\n\n// CFInfo returns information about a Cuckoo filter.\n// For more information - https://redis.io/commands/cf.info/\nfunc (c cmdable) CFInfo(ctx context.Context, key string) *CFInfoCmd {\n\targs := []interface{}{\"CF.INFO\", key}\n\tcmd := NewCFInfoCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFInsert inserts elements into a Cuckoo filter.\n// This function also allows for specifying additional options such as capacity, error rate, expansion rate, and non-scaling behavior.\n// Returns an array of booleans indicating whether each element was added to the filter or not.\n// For more information - https://redis.io/commands/cf.insert/\nfunc (c cmdable) CFInsert(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{}) *BoolSliceCmd {\n\targs := []interface{}{\"CF.INSERT\", key}\n\targs = c.getCfInsertWithArgs(args, options, elements...)\n\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CFInsertNX inserts elements into a Cuckoo filter only if they do not already exist in the filter.\n// This function also allows for specifying additional options such as:\n// capacity, error rate, expansion rate, and non-scaling behavior.\n// Returns an array of integers indicating whether each element was added to the filter or not.\n// For more information - https://redis.io/commands/cf.insertnx/\nfunc (c cmdable) CFInsertNX(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{}) *IntSliceCmd {\n\targs := []interface{}{\"CF.INSERTNX\", key}\n\targs = c.getCfInsertWithArgs(args, options, elements...)\n\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) getCfInsertWithArgs(args []interface{}, options *CFInsertOptions, elements ...interface{}) []interface{} {\n\tif options != nil {\n\t\tif options.Capacity != 0 {\n\t\t\targs = append(args, \"CAPACITY\", options.Capacity)\n\t\t}\n\t\tif options.NoCreate {\n\t\t\targs = append(args, \"NOCREATE\")\n\t\t}\n\t}\n\targs = append(args, \"ITEMS\")\n\targs = append(args, elements...)\n\n\treturn args\n}\n\n// CFMExists check if multiple elements exist in a Cuckoo filter.\n// Returns an array of booleans indicating whether each element exists in the filter or not.\n// For more information - https://redis.io/commands/cf.mexists/\nfunc (c cmdable) CFMExists(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {\n\targs := []interface{}{\"CF.MEXISTS\", key}\n\targs = append(args, elements...)\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// -------------------------------------------\n// CMS commands\n//-------------------------------------------\n\n// CMSIncrBy increments the count of one or more items in a Count-Min Sketch filter.\n// Returns an array of integers representing the updated count of each item.\n// For more information - https://redis.io/commands/cms.incrby/\nfunc (c cmdable) CMSIncrBy(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"CMS.INCRBY\"\n\targs[1] = key\n\targs = appendArgs(args, elements)\n\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype CMSInfo struct {\n\tWidth int64\n\tDepth int64\n\tCount int64\n}\n\ntype CMSInfoCmd struct {\n\tbaseCmd\n\n\tval CMSInfo\n}\n\nfunc NewCMSInfoCmd(ctx context.Context, args ...interface{}) *CMSInfoCmd {\n\treturn &CMSInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *CMSInfoCmd) SetVal(val CMSInfo) {\n\tcmd.val = val\n}\n\nfunc (cmd *CMSInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *CMSInfoCmd) Val() CMSInfo {\n\treturn cmd.val\n}\n\nfunc (cmd *CMSInfoCmd) Result() (CMSInfo, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *CMSInfoCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar key string\n\tvar result CMSInfo\n\tfor f := 0; f < n; f++ {\n\t\tkey, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"width\":\n\t\t\tresult.Width, err = rd.ReadInt()\n\t\tcase \"depth\":\n\t\t\tresult.Depth, err = rd.ReadInt()\n\t\tcase \"count\":\n\t\t\tresult.Count, err = rd.ReadInt()\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: CMS.INFO unexpected key %s\", key)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcmd.val = result\n\treturn nil\n}\n\n// CMSInfo returns information about a Count-Min Sketch filter.\n// For more information - https://redis.io/commands/cms.info/\nfunc (c cmdable) CMSInfo(ctx context.Context, key string) *CMSInfoCmd {\n\targs := []interface{}{\"CMS.INFO\", key}\n\tcmd := NewCMSInfoCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CMSInitByDim creates an empty Count-Min Sketch filter with the specified dimensions.\n// For more information - https://redis.io/commands/cms.initbydim/\nfunc (c cmdable) CMSInitByDim(ctx context.Context, key string, width, depth int64) *StatusCmd {\n\targs := []interface{}{\"CMS.INITBYDIM\", key, width, depth}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CMSInitByProb creates an empty Count-Min Sketch filter with the specified error rate and probability.\n// For more information - https://redis.io/commands/cms.initbyprob/\nfunc (c cmdable) CMSInitByProb(ctx context.Context, key string, errorRate, probability float64) *StatusCmd {\n\targs := []interface{}{\"CMS.INITBYPROB\", key, errorRate, probability}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CMSMerge merges multiple Count-Min Sketch filters into a single filter.\n// The destination filter must not exist and will be created with the dimensions of the first source filter.\n// The number of items in each source filter must be equal.\n// Returns OK on success or an error if the filters could not be merged.\n// For more information - https://redis.io/commands/cms.merge/\nfunc (c cmdable) CMSMerge(ctx context.Context, destKey string, sourceKeys ...string) *StatusCmd {\n\targs := []interface{}{\"CMS.MERGE\", destKey, len(sourceKeys)}\n\tfor _, s := range sourceKeys {\n\t\targs = append(args, s)\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CMSMergeWithWeight merges multiple Count-Min Sketch filters into a single filter with weights for each source filter.\n// The destination filter must not exist and will be created with the dimensions of the first source filter.\n// The number of items in each source filter must be equal.\n// Returns OK on success or an error if the filters could not be merged.\n// For more information - https://redis.io/commands/cms.merge/\nfunc (c cmdable) CMSMergeWithWeight(ctx context.Context, destKey string, sourceKeys map[string]int64) *StatusCmd {\n\targs := make([]interface{}, 0, 4+(len(sourceKeys)*2+1))\n\targs = append(args, \"CMS.MERGE\", destKey, len(sourceKeys))\n\n\tif len(sourceKeys) > 0 {\n\t\tsk := make([]interface{}, len(sourceKeys))\n\t\tsw := make([]interface{}, len(sourceKeys))\n\n\t\ti := 0\n\t\tfor k, w := range sourceKeys {\n\t\t\tsk[i] = k\n\t\t\tsw[i] = w\n\t\t\ti++\n\t\t}\n\n\t\targs = append(args, sk...)\n\t\targs = append(args, \"WEIGHTS\")\n\t\targs = append(args, sw...)\n\t}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// CMSQuery returns count for item(s).\n// For more information - https://redis.io/commands/cms.query/\nfunc (c cmdable) CMSQuery(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd {\n\targs := []interface{}{\"CMS.QUERY\", key}\n\targs = append(args, elements...)\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// -------------------------------------------\n// TopK commands\n//--------------------------------------------\n\n// TopKAdd adds one or more elements to a Top-K filter.\n// Returns an array of strings representing the items that were removed from the filter, if any.\n// For more information - https://redis.io/commands/topk.add/\nfunc (c cmdable) TopKAdd(ctx context.Context, key string, elements ...interface{}) *StringSliceCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"TOPK.ADD\"\n\targs[1] = key\n\targs = appendArgs(args, elements)\n\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TopKReserve creates an empty Top-K filter with the specified number of top items to keep.\n// For more information - https://redis.io/commands/topk.reserve/\nfunc (c cmdable) TopKReserve(ctx context.Context, key string, k int64) *StatusCmd {\n\targs := []interface{}{\"TOPK.RESERVE\", key, k}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TopKReserveWithOptions creates an empty Top-K filter with the specified number of top items to keep and additional options.\n// This function allows for specifying additional options such as width, depth and decay.\n// For more information - https://redis.io/commands/topk.reserve/\nfunc (c cmdable) TopKReserveWithOptions(ctx context.Context, key string, k int64, width, depth int64, decay float64) *StatusCmd {\n\targs := []interface{}{\"TOPK.RESERVE\", key, k, width, depth, decay}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype TopKInfo struct {\n\tK     int64\n\tWidth int64\n\tDepth int64\n\tDecay float64\n}\n\ntype TopKInfoCmd struct {\n\tbaseCmd\n\n\tval TopKInfo\n}\n\nfunc NewTopKInfoCmd(ctx context.Context, args ...interface{}) *TopKInfoCmd {\n\treturn &TopKInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *TopKInfoCmd) SetVal(val TopKInfo) {\n\tcmd.val = val\n}\n\nfunc (cmd *TopKInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *TopKInfoCmd) Val() TopKInfo {\n\treturn cmd.val\n}\n\nfunc (cmd *TopKInfoCmd) Result() (TopKInfo, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *TopKInfoCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar key string\n\tvar result TopKInfo\n\tfor f := 0; f < n; f++ {\n\t\tkey, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"k\":\n\t\t\tresult.K, err = rd.ReadInt()\n\t\tcase \"width\":\n\t\t\tresult.Width, err = rd.ReadInt()\n\t\tcase \"depth\":\n\t\t\tresult.Depth, err = rd.ReadInt()\n\t\tcase \"decay\":\n\t\t\tresult.Decay, err = rd.ReadFloat()\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: topk.info unexpected key %s\", key)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcmd.val = result\n\treturn nil\n}\n\n// TopKInfo returns information about a Top-K filter.\n// For more information - https://redis.io/commands/topk.info/\nfunc (c cmdable) TopKInfo(ctx context.Context, key string) *TopKInfoCmd {\n\targs := []interface{}{\"TOPK.INFO\", key}\n\n\tcmd := NewTopKInfoCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TopKQuery check if multiple elements exist in a Top-K filter.\n// Returns an array of booleans indicating whether each element exists in the filter or not.\n// For more information - https://redis.io/commands/topk.query/\nfunc (c cmdable) TopKQuery(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"TOPK.QUERY\"\n\targs[1] = key\n\targs = appendArgs(args, elements)\n\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TopKCount returns an estimate of the number of times an item may be in a Top-K filter.\n// For more information - https://redis.io/commands/topk.count/\nfunc (c cmdable) TopKCount(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"TOPK.COUNT\"\n\targs[1] = key\n\targs = appendArgs(args, elements)\n\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TopKIncrBy increases the count of one or more items in a Top-K filter.\n// For more information - https://redis.io/commands/topk.incrby/\nfunc (c cmdable) TopKIncrBy(ctx context.Context, key string, elements ...interface{}) *StringSliceCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"TOPK.INCRBY\"\n\targs[1] = key\n\targs = appendArgs(args, elements)\n\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TopKList returns all items in Top-K list.\n// For more information - https://redis.io/commands/topk.list/\nfunc (c cmdable) TopKList(ctx context.Context, key string) *StringSliceCmd {\n\targs := []interface{}{\"TOPK.LIST\", key}\n\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TopKListWithCount returns all items in Top-K list with their respective count.\n// For more information - https://redis.io/commands/topk.list/\nfunc (c cmdable) TopKListWithCount(ctx context.Context, key string) *MapStringIntCmd {\n\targs := []interface{}{\"TOPK.LIST\", key, \"WITHCOUNT\"}\n\n\tcmd := NewMapStringIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// -------------------------------------------\n// t-digest commands\n// --------------------------------------------\n\n// TDigestAdd adds one or more elements to a t-Digest data structure.\n// Returns OK on success or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.add/\nfunc (c cmdable) TDigestAdd(ctx context.Context, key string, elements ...float64) *StatusCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"TDIGEST.ADD\"\n\targs[1] = key\n\n\t// Convert floatSlice to []interface{}\n\tinterfaceSlice := make([]interface{}, len(elements))\n\tfor i, v := range elements {\n\t\tinterfaceSlice[i] = v\n\t}\n\n\targs = append(args, interfaceSlice...)\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestByRank returns an array of values from a t-Digest data structure based on their rank.\n// The rank of an element is its position in the sorted list of all elements in the t-Digest.\n// Returns an array of floats representing the values at the specified ranks or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.byrank/\nfunc (c cmdable) TDigestByRank(ctx context.Context, key string, rank ...uint64) *FloatSliceCmd {\n\targs := make([]interface{}, 2, 2+len(rank))\n\targs[0] = \"TDIGEST.BYRANK\"\n\targs[1] = key\n\n\t// Convert uint slice to []interface{}\n\tinterfaceSlice := make([]interface{}, len(rank))\n\tfor i, v := range rank {\n\t\tinterfaceSlice[i] = v\n\t}\n\n\targs = append(args, interfaceSlice...)\n\n\tcmd := NewFloatSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestByRevRank returns an array of values from a t-Digest data structure based on their reverse rank.\n// The reverse rank of an element is its position in the sorted list of all elements in the t-Digest when sorted in descending order.\n// Returns an array of floats representing the values at the specified ranks or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.byrevrank/\nfunc (c cmdable) TDigestByRevRank(ctx context.Context, key string, rank ...uint64) *FloatSliceCmd {\n\targs := make([]interface{}, 2, 2+len(rank))\n\targs[0] = \"TDIGEST.BYREVRANK\"\n\targs[1] = key\n\n\t// Convert uint slice to []interface{}\n\tinterfaceSlice := make([]interface{}, len(rank))\n\tfor i, v := range rank {\n\t\tinterfaceSlice[i] = v\n\t}\n\n\targs = append(args, interfaceSlice...)\n\n\tcmd := NewFloatSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestCDF returns an array of cumulative distribution function (CDF) values for one or more elements in a t-Digest data structure.\n// The CDF value for an element is the fraction of all elements in the t-Digest that are less than or equal to it.\n// Returns an array of floats representing the CDF values for each element or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.cdf/\nfunc (c cmdable) TDigestCDF(ctx context.Context, key string, elements ...float64) *FloatSliceCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"TDIGEST.CDF\"\n\targs[1] = key\n\n\t// Convert floatSlice to []interface{}\n\tinterfaceSlice := make([]interface{}, len(elements))\n\tfor i, v := range elements {\n\t\tinterfaceSlice[i] = v\n\t}\n\n\targs = append(args, interfaceSlice...)\n\n\tcmd := NewFloatSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestCreate creates an empty t-Digest data structure with default parameters.\n// Returns OK on success or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.create/\nfunc (c cmdable) TDigestCreate(ctx context.Context, key string) *StatusCmd {\n\targs := []interface{}{\"TDIGEST.CREATE\", key}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestCreateWithCompression creates an empty t-Digest data structure with a specified compression parameter.\n// The compression parameter controls the accuracy and memory usage of the t-Digest.\n// Returns OK on success or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.create/\nfunc (c cmdable) TDigestCreateWithCompression(ctx context.Context, key string, compression int64) *StatusCmd {\n\targs := []interface{}{\"TDIGEST.CREATE\", key, \"COMPRESSION\", compression}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype TDigestInfo struct {\n\tCompression       int64\n\tCapacity          int64\n\tMergedNodes       int64\n\tUnmergedNodes     int64\n\tMergedWeight      int64\n\tUnmergedWeight    int64\n\tObservations      int64\n\tTotalCompressions int64\n\tMemoryUsage       int64\n}\n\ntype TDigestInfoCmd struct {\n\tbaseCmd\n\n\tval TDigestInfo\n}\n\nfunc NewTDigestInfoCmd(ctx context.Context, args ...interface{}) *TDigestInfoCmd {\n\treturn &TDigestInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *TDigestInfoCmd) SetVal(val TDigestInfo) {\n\tcmd.val = val\n}\n\nfunc (cmd *TDigestInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *TDigestInfoCmd) Val() TDigestInfo {\n\treturn cmd.val\n}\n\nfunc (cmd *TDigestInfoCmd) Result() (TDigestInfo, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *TDigestInfoCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar key string\n\tvar result TDigestInfo\n\tfor f := 0; f < n; f++ {\n\t\tkey, err = rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch key {\n\t\tcase \"Compression\":\n\t\t\tresult.Compression, err = rd.ReadInt()\n\t\tcase \"Capacity\":\n\t\t\tresult.Capacity, err = rd.ReadInt()\n\t\tcase \"Merged nodes\":\n\t\t\tresult.MergedNodes, err = rd.ReadInt()\n\t\tcase \"Unmerged nodes\":\n\t\t\tresult.UnmergedNodes, err = rd.ReadInt()\n\t\tcase \"Merged weight\":\n\t\t\tresult.MergedWeight, err = rd.ReadInt()\n\t\tcase \"Unmerged weight\":\n\t\t\tresult.UnmergedWeight, err = rd.ReadInt()\n\t\tcase \"Observations\":\n\t\t\tresult.Observations, err = rd.ReadInt()\n\t\tcase \"Total compressions\":\n\t\t\tresult.TotalCompressions, err = rd.ReadInt()\n\t\tcase \"Memory usage\":\n\t\t\tresult.MemoryUsage, err = rd.ReadInt()\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"redis: tdigest.info unexpected key %s\", key)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tcmd.val = result\n\treturn nil\n}\n\n// TDigestInfo returns information about a t-Digest data structure.\n// For more information - https://redis.io/commands/tdigest.info/\nfunc (c cmdable) TDigestInfo(ctx context.Context, key string) *TDigestInfoCmd {\n\targs := []interface{}{\"TDIGEST.INFO\", key}\n\n\tcmd := NewTDigestInfoCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestMax returns the maximum value from a t-Digest data structure.\n// For more information - https://redis.io/commands/tdigest.max/\nfunc (c cmdable) TDigestMax(ctx context.Context, key string) *FloatCmd {\n\targs := []interface{}{\"TDIGEST.MAX\", key}\n\n\tcmd := NewFloatCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype TDigestMergeOptions struct {\n\tCompression int64\n\tOverride    bool\n}\n\n// TDigestMerge merges multiple t-Digest data structures into a single t-Digest.\n// This function also allows for specifying additional options such as compression and override behavior.\n// Returns OK on success or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.merge/\nfunc (c cmdable) TDigestMerge(ctx context.Context, destKey string, options *TDigestMergeOptions, sourceKeys ...string) *StatusCmd {\n\targs := []interface{}{\"TDIGEST.MERGE\", destKey, len(sourceKeys)}\n\n\tfor _, sourceKey := range sourceKeys {\n\t\targs = append(args, sourceKey)\n\t}\n\n\tif options != nil {\n\t\tif options.Compression != 0 {\n\t\t\targs = append(args, \"COMPRESSION\", options.Compression)\n\t\t}\n\t\tif options.Override {\n\t\t\targs = append(args, \"OVERRIDE\")\n\t\t}\n\t}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestMin returns the minimum value from a t-Digest data structure.\n// For more information - https://redis.io/commands/tdigest.min/\nfunc (c cmdable) TDigestMin(ctx context.Context, key string) *FloatCmd {\n\targs := []interface{}{\"TDIGEST.MIN\", key}\n\n\tcmd := NewFloatCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestQuantile returns an array of quantile values for one or more elements in a t-Digest data structure.\n// The quantile value for an element is the fraction of all elements in the t-Digest that are less than or equal to it.\n// Returns an array of floats representing the quantile values for each element or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.quantile/\nfunc (c cmdable) TDigestQuantile(ctx context.Context, key string, elements ...float64) *FloatSliceCmd {\n\targs := make([]interface{}, 2, 2+len(elements))\n\targs[0] = \"TDIGEST.QUANTILE\"\n\targs[1] = key\n\n\t// Convert floatSlice to []interface{}\n\tinterfaceSlice := make([]interface{}, len(elements))\n\tfor i, v := range elements {\n\t\tinterfaceSlice[i] = v\n\t}\n\n\targs = append(args, interfaceSlice...)\n\n\tcmd := NewFloatSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestRank returns an array of rank values for one or more elements in a t-Digest data structure.\n// The rank of an element is its position in the sorted list of all elements in the t-Digest.\n// Returns an array of integers representing the rank values for each element or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.rank/\nfunc (c cmdable) TDigestRank(ctx context.Context, key string, values ...float64) *IntSliceCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"TDIGEST.RANK\"\n\targs[1] = key\n\n\t// Convert floatSlice to []interface{}\n\tinterfaceSlice := make([]interface{}, len(values))\n\tfor i, v := range values {\n\t\tinterfaceSlice[i] = v\n\t}\n\n\targs = append(args, interfaceSlice...)\n\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestReset resets a t-Digest data structure to its initial state.\n// Returns OK on success or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.reset/\nfunc (c cmdable) TDigestReset(ctx context.Context, key string) *StatusCmd {\n\targs := []interface{}{\"TDIGEST.RESET\", key}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestRevRank returns an array of reverse rank values for one or more elements in a t-Digest data structure.\n// The reverse rank of an element is its position in the sorted list of all elements in the t-Digest when sorted in descending order.\n// Returns an array of integers representing the reverse rank values for each element or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.revrank/\nfunc (c cmdable) TDigestRevRank(ctx context.Context, key string, values ...float64) *IntSliceCmd {\n\targs := make([]interface{}, 2, 2+len(values))\n\targs[0] = \"TDIGEST.REVRANK\"\n\targs[1] = key\n\n\t// Convert floatSlice to []interface{}\n\tinterfaceSlice := make([]interface{}, len(values))\n\tfor i, v := range values {\n\t\tinterfaceSlice[i] = v\n\t}\n\n\targs = append(args, interfaceSlice...)\n\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TDigestTrimmedMean returns the trimmed mean value from a t-Digest data structure.\n// The trimmed mean is calculated by removing a specified fraction of the highest and lowest values from the t-Digest and then calculating the mean of the remaining values.\n// Returns a float representing the trimmed mean value or an error if the operation could not be completed.\n// For more information - https://redis.io/commands/tdigest.trimmed_mean/\nfunc (c cmdable) TDigestTrimmedMean(ctx context.Context, key string, lowCutQuantile, highCutQuantile float64) *FloatCmd {\n\targs := []interface{}{\"TDIGEST.TRIMMED_MEAN\", key, lowCutQuantile, highCutQuantile}\n\n\tcmd := NewFloatCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "probabilistic_test.go",
          "type": "blob",
          "size": 28.591796875,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"Probabilistic commands\", Label(\"probabilistic\"), func() {\n\tctx := context.TODO()\n\n\tsetupRedisClient := func(protocolVersion int) *redis.Client {\n\t\treturn redis.NewClient(&redis.Options{\n\t\t\tAddr:     \"localhost:6379\",\n\t\t\tDB:       0,\n\t\t\tProtocol: protocolVersion,\n\t\t})\n\t}\n\n\tprotocols := []int{2, 3}\n\tfor _, protocol := range protocols {\n\t\tprotocol := protocol // capture loop variable for each context\n\n\t\tContext(fmt.Sprintf(\"with protocol version %d\", protocol), func() {\n\t\t\tvar client *redis.Client\n\n\t\t\tBeforeEach(func() {\n\t\t\t\tclient = setupRedisClient(protocol)\n\t\t\t\tExpect(client.FlushAll(ctx).Err()).NotTo(HaveOccurred())\n\t\t\t})\n\n\t\t\tAfterEach(func() {\n\t\t\t\tif client != nil {\n\t\t\t\t\tclient.FlushDB(ctx)\n\t\t\t\t\tclient.Close()\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tDescribe(\"bloom\", Label(\"bloom\"), func() {\n\t\t\t\tIt(\"should BFAdd\", Label(\"bloom\", \"bfadd\"), func() {\n\t\t\t\t\tresultAdd, err := client.BFAdd(ctx, \"testbf1\", 1).Result()\n\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultAdd).To(BeTrue())\n\n\t\t\t\t\tresultInfo, err := client.BFInfo(ctx, \"testbf1\").Result()\n\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultInfo).To(BeAssignableToTypeOf(redis.BFInfo{}))\n\t\t\t\t\tExpect(resultInfo.ItemsInserted).To(BeEquivalentTo(int64(1)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFCard\", Label(\"bloom\", \"bfcard\"), func() {\n\t\t\t\t\t// This is a probabilistic data structure, and it's not always guaranteed that we will get back\n\t\t\t\t\t// the exact number of inserted items, during hash collisions\n\t\t\t\t\t// But with such a low number of items (only 3),\n\t\t\t\t\t// the probability of a collision is very low, so we can expect to get back the exact number of items\n\t\t\t\t\t_, err := client.BFAdd(ctx, \"testbf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t_, err = client.BFAdd(ctx, \"testbf1\", \"item2\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t_, err = client.BFAdd(ctx, \"testbf1\", 3).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.BFCard(ctx, \"testbf1\").Result()\n\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeEquivalentTo(int64(3)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFExists\", Label(\"bloom\", \"bfexists\"), func() {\n\t\t\t\t\texists, err := client.BFExists(ctx, \"testbf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(exists).To(BeFalse())\n\n\t\t\t\t\t_, err = client.BFAdd(ctx, \"testbf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\texists, err = client.BFExists(ctx, \"testbf1\", \"item1\").Result()\n\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(exists).To(BeTrue())\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFInfo and BFReserve\", Label(\"bloom\", \"bfinfo\", \"bfreserve\"), func() {\n\t\t\t\t\terr := client.BFReserve(ctx, \"testbf1\", 0.001, 2000).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.BFInfo(ctx, \"testbf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeAssignableToTypeOf(redis.BFInfo{}))\n\t\t\t\t\tExpect(result.Capacity).To(BeEquivalentTo(int64(2000)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFInfoCapacity, BFInfoSize, BFInfoFilters, BFInfoItems, BFInfoExpansion, \", Label(\"bloom\", \"bfinfocapacity\", \"bfinfosize\", \"bfinfofilters\", \"bfinfoitems\", \"bfinfoexpansion\"), func() {\n\t\t\t\t\terr := client.BFReserve(ctx, \"testbf1\", 0.001, 2000).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.BFInfoCapacity(ctx, \"testbf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result.Capacity).To(BeEquivalentTo(int64(2000)))\n\n\t\t\t\t\tresult, err = client.BFInfoItems(ctx, \"testbf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result.ItemsInserted).To(BeEquivalentTo(int64(0)))\n\n\t\t\t\t\tresult, err = client.BFInfoSize(ctx, \"testbf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result.Size).To(BeEquivalentTo(int64(4056)))\n\n\t\t\t\t\terr = client.BFReserveExpansion(ctx, \"testbf2\", 0.001, 2000, 3).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err = client.BFInfoFilters(ctx, \"testbf2\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result.Filters).To(BeEquivalentTo(int64(1)))\n\n\t\t\t\t\tresult, err = client.BFInfoExpansion(ctx, \"testbf2\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result.ExpansionRate).To(BeEquivalentTo(int64(3)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFInsert\", Label(\"bloom\", \"bfinsert\"), func() {\n\t\t\t\t\toptions := &redis.BFInsertOptions{\n\t\t\t\t\t\tCapacity:   2000,\n\t\t\t\t\t\tError:      0.001,\n\t\t\t\t\t\tExpansion:  3,\n\t\t\t\t\t\tNonScaling: false,\n\t\t\t\t\t\tNoCreate:   true,\n\t\t\t\t\t}\n\n\t\t\t\t\t_, err := client.BFInsert(ctx, \"testbf1\", options, \"item1\").Result()\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t\tExpect(err).To(MatchError(\"ERR not found\"))\n\n\t\t\t\t\toptions = &redis.BFInsertOptions{\n\t\t\t\t\t\tCapacity:   2000,\n\t\t\t\t\t\tError:      0.001,\n\t\t\t\t\t\tExpansion:  3,\n\t\t\t\t\t\tNonScaling: false,\n\t\t\t\t\t\tNoCreate:   false,\n\t\t\t\t\t}\n\n\t\t\t\t\tresultInsert, err := client.BFInsert(ctx, \"testbf1\", options, \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultInsert)).To(BeEquivalentTo(1))\n\n\t\t\t\t\texists, err := client.BFExists(ctx, \"testbf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(exists).To(BeTrue())\n\n\t\t\t\t\tresult, err := client.BFInfo(ctx, \"testbf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeAssignableToTypeOf(redis.BFInfo{}))\n\t\t\t\t\tExpect(result.Capacity).To(BeEquivalentTo(int64(2000)))\n\t\t\t\t\tExpect(result.ExpansionRate).To(BeEquivalentTo(int64(3)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFMAdd\", Label(\"bloom\", \"bfmadd\"), func() {\n\t\t\t\t\tresultAdd, err := client.BFMAdd(ctx, \"testbf1\", \"item1\", \"item2\", \"item3\").Result()\n\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultAdd)).To(Equal(3))\n\n\t\t\t\t\tresultInfo, err := client.BFInfo(ctx, \"testbf1\").Result()\n\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultInfo).To(BeAssignableToTypeOf(redis.BFInfo{}))\n\t\t\t\t\tExpect(resultInfo.ItemsInserted).To(BeEquivalentTo(int64(3)))\n\t\t\t\t\tresultAdd2, err := client.BFMAdd(ctx, \"testbf1\", \"item1\", \"item2\", \"item4\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultAdd2[0]).To(BeFalse())\n\t\t\t\t\tExpect(resultAdd2[1]).To(BeFalse())\n\t\t\t\t\tExpect(resultAdd2[2]).To(BeTrue())\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFMExists\", Label(\"bloom\", \"bfmexists\"), func() {\n\t\t\t\t\texist, err := client.BFMExists(ctx, \"testbf1\", \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(exist)).To(Equal(3))\n\t\t\t\t\tExpect(exist[0]).To(BeFalse())\n\t\t\t\t\tExpect(exist[1]).To(BeFalse())\n\t\t\t\t\tExpect(exist[2]).To(BeFalse())\n\n\t\t\t\t\t_, err = client.BFMAdd(ctx, \"testbf1\", \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\texist, err = client.BFMExists(ctx, \"testbf1\", \"item1\", \"item2\", \"item3\", \"item4\").Result()\n\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(exist)).To(Equal(4))\n\t\t\t\t\tExpect(exist[0]).To(BeTrue())\n\t\t\t\t\tExpect(exist[1]).To(BeTrue())\n\t\t\t\t\tExpect(exist[2]).To(BeTrue())\n\t\t\t\t\tExpect(exist[3]).To(BeFalse())\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFReserveExpansion\", Label(\"bloom\", \"bfreserveexpansion\"), func() {\n\t\t\t\t\terr := client.BFReserveExpansion(ctx, \"testbf1\", 0.001, 2000, 3).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.BFInfo(ctx, \"testbf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeAssignableToTypeOf(redis.BFInfo{}))\n\t\t\t\t\tExpect(result.Capacity).To(BeEquivalentTo(int64(2000)))\n\t\t\t\t\tExpect(result.ExpansionRate).To(BeEquivalentTo(int64(3)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFReserveNonScaling\", Label(\"bloom\", \"bfreservenonscaling\"), func() {\n\t\t\t\t\terr := client.BFReserveNonScaling(ctx, \"testbfns1\", 0.001, 1000).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\t_, err = client.BFInfo(ctx, \"testbfns1\").Result()\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFScanDump and BFLoadChunk\", Label(\"bloom\", \"bfscandump\", \"bfloadchunk\"), func() {\n\t\t\t\t\terr := client.BFReserve(ctx, \"testbfsd1\", 0.001, 3000).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\t\t\tclient.BFAdd(ctx, \"testbfsd1\", i)\n\t\t\t\t\t}\n\t\t\t\t\tinfBefore := client.BFInfoSize(ctx, \"testbfsd1\")\n\t\t\t\t\tfd := []redis.ScanDump{}\n\t\t\t\t\tsd, err := client.BFScanDump(ctx, \"testbfsd1\", 0).Result()\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif sd.Iter == 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t\tfd = append(fd, sd)\n\t\t\t\t\t\tsd, err = client.BFScanDump(ctx, \"testbfsd1\", sd.Iter).Result()\n\t\t\t\t\t}\n\t\t\t\t\tclient.Del(ctx, \"testbfsd1\")\n\t\t\t\t\tfor _, e := range fd {\n\t\t\t\t\t\tclient.BFLoadChunk(ctx, \"testbfsd1\", e.Iter, e.Data)\n\t\t\t\t\t}\n\t\t\t\t\tinfAfter := client.BFInfoSize(ctx, \"testbfsd1\")\n\t\t\t\t\tExpect(infBefore).To(BeEquivalentTo(infAfter))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should BFReserveWithArgs\", Label(\"bloom\", \"bfreserveargs\"), func() {\n\t\t\t\t\toptions := &redis.BFReserveOptions{\n\t\t\t\t\t\tCapacity:   2000,\n\t\t\t\t\t\tError:      0.001,\n\t\t\t\t\t\tExpansion:  3,\n\t\t\t\t\t\tNonScaling: false,\n\t\t\t\t\t}\n\t\t\t\t\terr := client.BFReserveWithArgs(ctx, \"testbf\", options).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.BFInfo(ctx, \"testbf\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeAssignableToTypeOf(redis.BFInfo{}))\n\t\t\t\t\tExpect(result.Capacity).To(BeEquivalentTo(int64(2000)))\n\t\t\t\t\tExpect(result.ExpansionRate).To(BeEquivalentTo(int64(3)))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tDescribe(\"cuckoo\", Label(\"cuckoo\"), func() {\n\t\t\t\tIt(\"should CFAdd\", Label(\"cuckoo\", \"cfadd\"), func() {\n\t\t\t\t\tadd, err := client.CFAdd(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(add).To(BeTrue())\n\n\t\t\t\t\texists, err := client.CFExists(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(exists).To(BeTrue())\n\n\t\t\t\t\tinfo, err := client.CFInfo(ctx, \"testcf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(info).To(BeAssignableToTypeOf(redis.CFInfo{}))\n\t\t\t\t\tExpect(info.NumItemsInserted).To(BeEquivalentTo(int64(1)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFAddNX\", Label(\"cuckoo\", \"cfaddnx\"), func() {\n\t\t\t\t\tadd, err := client.CFAddNX(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(add).To(BeTrue())\n\n\t\t\t\t\texists, err := client.CFExists(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(exists).To(BeTrue())\n\n\t\t\t\t\tresult, err := client.CFAddNX(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeFalse())\n\n\t\t\t\t\tinfo, err := client.CFInfo(ctx, \"testcf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(info).To(BeAssignableToTypeOf(redis.CFInfo{}))\n\t\t\t\t\tExpect(info.NumItemsInserted).To(BeEquivalentTo(int64(1)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFCount\", Label(\"cuckoo\", \"cfcount\"), func() {\n\t\t\t\t\terr := client.CFAdd(ctx, \"testcf1\", \"item1\").Err()\n\t\t\t\t\tcnt, err := client.CFCount(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(cnt).To(BeEquivalentTo(int64(1)))\n\n\t\t\t\t\terr = client.CFAdd(ctx, \"testcf1\", \"item1\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tcnt, err = client.CFCount(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(cnt).To(BeEquivalentTo(int64(2)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFDel and CFExists\", Label(\"cuckoo\", \"cfdel\", \"cfexists\"), func() {\n\t\t\t\t\terr := client.CFAdd(ctx, \"testcf1\", \"item1\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\texists, err := client.CFExists(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(exists).To(BeTrue())\n\n\t\t\t\t\tdel, err := client.CFDel(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(del).To(BeTrue())\n\n\t\t\t\t\texists, err = client.CFExists(ctx, \"testcf1\", \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(exists).To(BeFalse())\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFInfo and CFReserve\", Label(\"cuckoo\", \"cfinfo\", \"cfreserve\"), func() {\n\t\t\t\t\terr := client.CFReserve(ctx, \"testcf1\", 1000).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.CFReserveExpansion(ctx, \"testcfe1\", 1000, 1).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.CFReserveBucketSize(ctx, \"testcfbs1\", 1000, 4).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.CFReserveMaxIterations(ctx, \"testcfmi1\", 1000, 10).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.CFInfo(ctx, \"testcf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeAssignableToTypeOf(redis.CFInfo{}))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFScanDump and CFLoadChunk\", Label(\"bloom\", \"cfscandump\", \"cfloadchunk\"), func() {\n\t\t\t\t\terr := client.CFReserve(ctx, \"testcfsd1\", 1000).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\t\t\tItem := fmt.Sprintf(\"item%d\", i)\n\t\t\t\t\t\tclient.CFAdd(ctx, \"testcfsd1\", Item)\n\t\t\t\t\t}\n\t\t\t\t\tinfBefore := client.CFInfo(ctx, \"testcfsd1\")\n\t\t\t\t\tfd := []redis.ScanDump{}\n\t\t\t\t\tsd, err := client.CFScanDump(ctx, \"testcfsd1\", 0).Result()\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif sd.Iter == 0 {\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t\tfd = append(fd, sd)\n\t\t\t\t\t\tsd, err = client.CFScanDump(ctx, \"testcfsd1\", sd.Iter).Result()\n\t\t\t\t\t}\n\t\t\t\t\tclient.Del(ctx, \"testcfsd1\")\n\t\t\t\t\tfor _, e := range fd {\n\t\t\t\t\t\tclient.CFLoadChunk(ctx, \"testcfsd1\", e.Iter, e.Data)\n\t\t\t\t\t}\n\t\t\t\t\tinfAfter := client.CFInfo(ctx, \"testcfsd1\")\n\t\t\t\t\tExpect(infBefore).To(BeEquivalentTo(infAfter))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFInfo and CFReserveWithArgs\", Label(\"cuckoo\", \"cfinfo\", \"cfreserveargs\"), func() {\n\t\t\t\t\targs := &redis.CFReserveOptions{\n\t\t\t\t\t\tCapacity:      2048,\n\t\t\t\t\t\tBucketSize:    3,\n\t\t\t\t\t\tMaxIterations: 15,\n\t\t\t\t\t\tExpansion:     2,\n\t\t\t\t\t}\n\n\t\t\t\t\terr := client.CFReserveWithArgs(ctx, \"testcf1\", args).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.CFInfo(ctx, \"testcf1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeAssignableToTypeOf(redis.CFInfo{}))\n\t\t\t\t\tExpect(result.BucketSize).To(BeEquivalentTo(int64(3)))\n\t\t\t\t\tExpect(result.MaxIteration).To(BeEquivalentTo(int64(15)))\n\t\t\t\t\tExpect(result.ExpansionRate).To(BeEquivalentTo(int64(2)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFInsert\", Label(\"cuckoo\", \"cfinsert\"), func() {\n\t\t\t\t\targs := &redis.CFInsertOptions{\n\t\t\t\t\t\tCapacity: 3000,\n\t\t\t\t\t\tNoCreate: true,\n\t\t\t\t\t}\n\n\t\t\t\t\tresult, err := client.CFInsert(ctx, \"testcf1\", args, \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\n\t\t\t\t\targs = &redis.CFInsertOptions{\n\t\t\t\t\t\tCapacity: 3000,\n\t\t\t\t\t\tNoCreate: false,\n\t\t\t\t\t}\n\n\t\t\t\t\tresult, err = client.CFInsert(ctx, \"testcf1\", args, \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(result)).To(BeEquivalentTo(3))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFInsertNX\", Label(\"cuckoo\", \"cfinsertnx\"), func() {\n\t\t\t\t\targs := &redis.CFInsertOptions{\n\t\t\t\t\t\tCapacity: 3000,\n\t\t\t\t\t\tNoCreate: true,\n\t\t\t\t\t}\n\n\t\t\t\t\t_, err := client.CFInsertNX(ctx, \"testcf1\", args, \"item1\", \"item2\", \"item2\").Result()\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\n\t\t\t\t\targs = &redis.CFInsertOptions{\n\t\t\t\t\t\tCapacity: 3000,\n\t\t\t\t\t\tNoCreate: false,\n\t\t\t\t\t}\n\n\t\t\t\t\tresult, err := client.CFInsertNX(ctx, \"testcf2\", args, \"item1\", \"item2\", \"item2\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(result)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(result[0]).To(BeEquivalentTo(int64(1)))\n\t\t\t\t\tExpect(result[1]).To(BeEquivalentTo(int64(1)))\n\t\t\t\t\tExpect(result[2]).To(BeEquivalentTo(int64(0)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CFMexists\", Label(\"cuckoo\", \"cfmexists\"), func() {\n\t\t\t\t\terr := client.CFInsert(ctx, \"testcf1\", nil, \"item1\", \"item2\", \"item3\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.CFMExists(ctx, \"testcf1\", \"item1\", \"item2\", \"item3\", \"item4\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(result)).To(BeEquivalentTo(4))\n\t\t\t\t\tExpect(result[0]).To(BeTrue())\n\t\t\t\t\tExpect(result[1]).To(BeTrue())\n\t\t\t\t\tExpect(result[2]).To(BeTrue())\n\t\t\t\t\tExpect(result[3]).To(BeFalse())\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tDescribe(\"CMS\", Label(\"cms\"), func() {\n\t\t\t\tIt(\"should CMSIncrBy\", Label(\"cms\", \"cmsincrby\"), func() {\n\t\t\t\t\terr := client.CMSInitByDim(ctx, \"testcms1\", 5, 10).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.CMSIncrBy(ctx, \"testcms1\", \"item1\", 1, \"item2\", 2, \"item3\", 3).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(result)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(result[0]).To(BeEquivalentTo(int64(1)))\n\t\t\t\t\tExpect(result[1]).To(BeEquivalentTo(int64(2)))\n\t\t\t\t\tExpect(result[2]).To(BeEquivalentTo(int64(3)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CMSInitByDim and CMSInfo\", Label(\"cms\", \"cmsinitbydim\", \"cmsinfo\"), func() {\n\t\t\t\t\terr := client.CMSInitByDim(ctx, \"testcms1\", 5, 10).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tinfo, err := client.CMSInfo(ctx, \"testcms1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tExpect(info).To(BeAssignableToTypeOf(redis.CMSInfo{}))\n\t\t\t\t\tExpect(info.Width).To(BeEquivalentTo(int64(5)))\n\t\t\t\t\tExpect(info.Depth).To(BeEquivalentTo(int64(10)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CMSInitByProb\", Label(\"cms\", \"cmsinitbyprob\"), func() {\n\t\t\t\t\terr := client.CMSInitByProb(ctx, \"testcms1\", 0.002, 0.01).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tinfo, err := client.CMSInfo(ctx, \"testcms1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(info).To(BeAssignableToTypeOf(redis.CMSInfo{}))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should CMSMerge, CMSMergeWithWeight and CMSQuery\", Label(\"cms\", \"cmsmerge\", \"cmsquery\", \"NonRedisEnterprise\"), func() {\n\t\t\t\t\terr := client.CMSMerge(ctx, \"destCms1\", \"testcms2\", \"testcms3\").Err()\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t\tExpect(err).To(MatchError(\"CMS: key does not exist\"))\n\n\t\t\t\t\terr = client.CMSInitByDim(ctx, \"destCms1\", 5, 10).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.CMSInitByDim(ctx, \"destCms2\", 5, 10).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.CMSInitByDim(ctx, \"cms1\", 2, 20).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.CMSInitByDim(ctx, \"cms2\", 3, 20).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\terr = client.CMSMerge(ctx, \"destCms1\", \"cms1\", \"cms2\").Err()\n\t\t\t\t\tExpect(err).To(MatchError(\"CMS: width/depth is not equal\"))\n\n\t\t\t\t\tclient.Del(ctx, \"cms1\", \"cms2\")\n\n\t\t\t\t\terr = client.CMSInitByDim(ctx, \"cms1\", 5, 10).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.CMSInitByDim(ctx, \"cms2\", 5, 10).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tclient.CMSIncrBy(ctx, \"cms1\", \"item1\", 1, \"item2\", 2)\n\t\t\t\t\tclient.CMSIncrBy(ctx, \"cms2\", \"item2\", 2, \"item3\", 3)\n\n\t\t\t\t\terr = client.CMSMerge(ctx, \"destCms1\", \"cms1\", \"cms2\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err := client.CMSQuery(ctx, \"destCms1\", \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(result)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(result[0]).To(BeEquivalentTo(int64(1)))\n\t\t\t\t\tExpect(result[1]).To(BeEquivalentTo(int64(4)))\n\t\t\t\t\tExpect(result[2]).To(BeEquivalentTo(int64(3)))\n\n\t\t\t\t\tsourceSketches := map[string]int64{\n\t\t\t\t\t\t\"cms1\": 1,\n\t\t\t\t\t\t\"cms2\": 2,\n\t\t\t\t\t}\n\t\t\t\t\terr = client.CMSMergeWithWeight(ctx, \"destCms2\", sourceSketches).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresult, err = client.CMSQuery(ctx, \"destCms2\", \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(result)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(result[0]).To(BeEquivalentTo(int64(1)))\n\t\t\t\t\tExpect(result[1]).To(BeEquivalentTo(int64(6)))\n\t\t\t\t\tExpect(result[2]).To(BeEquivalentTo(int64(6)))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tDescribe(\"TopK\", Label(\"topk\"), func() {\n\t\t\t\tIt(\"should TopKReserve, TopKInfo, TopKAdd, TopKQuery, TopKCount, TopKIncrBy, TopKList, TopKListWithCount\", Label(\"topk\", \"topkreserve\", \"topkinfo\", \"topkadd\", \"topkquery\", \"topkcount\", \"topkincrby\", \"topklist\", \"topklistwithcount\"), func() {\n\t\t\t\t\terr := client.TopKReserve(ctx, \"topk1\", 3).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresultInfo, err := client.TopKInfo(ctx, \"topk1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultInfo.K).To(BeEquivalentTo(int64(3)))\n\n\t\t\t\t\tresultAdd, err := client.TopKAdd(ctx, \"topk1\", \"item1\", \"item2\", 3, \"item1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultAdd)).To(BeEquivalentTo(int64(4)))\n\n\t\t\t\t\tresultQuery, err := client.TopKQuery(ctx, \"topk1\", \"item1\", \"item2\", 4, 3).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultQuery)).To(BeEquivalentTo(4))\n\t\t\t\t\tExpect(resultQuery[0]).To(BeTrue())\n\t\t\t\t\tExpect(resultQuery[1]).To(BeTrue())\n\t\t\t\t\tExpect(resultQuery[2]).To(BeFalse())\n\t\t\t\t\tExpect(resultQuery[3]).To(BeTrue())\n\n\t\t\t\t\tresultCount, err := client.TopKCount(ctx, \"topk1\", \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultCount)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(resultCount[0]).To(BeEquivalentTo(int64(2)))\n\t\t\t\t\tExpect(resultCount[1]).To(BeEquivalentTo(int64(1)))\n\t\t\t\t\tExpect(resultCount[2]).To(BeEquivalentTo(int64(0)))\n\n\t\t\t\t\tresultIncr, err := client.TopKIncrBy(ctx, \"topk1\", \"item1\", 5, \"item2\", 10).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultIncr)).To(BeEquivalentTo(2))\n\n\t\t\t\t\tresultCount, err = client.TopKCount(ctx, \"topk1\", \"item1\", \"item2\", \"item3\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultCount)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(resultCount[0]).To(BeEquivalentTo(int64(7)))\n\t\t\t\t\tExpect(resultCount[1]).To(BeEquivalentTo(int64(11)))\n\t\t\t\t\tExpect(resultCount[2]).To(BeEquivalentTo(int64(0)))\n\n\t\t\t\t\tresultList, err := client.TopKList(ctx, \"topk1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultList)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(resultList).To(ContainElements(\"item2\", \"item1\", \"3\"))\n\n\t\t\t\t\tresultListWithCount, err := client.TopKListWithCount(ctx, \"topk1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(resultListWithCount)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(resultListWithCount[\"3\"]).To(BeEquivalentTo(int64(1)))\n\t\t\t\t\tExpect(resultListWithCount[\"item1\"]).To(BeEquivalentTo(int64(7)))\n\t\t\t\t\tExpect(resultListWithCount[\"item2\"]).To(BeEquivalentTo(int64(11)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should TopKReserveWithOptions\", Label(\"topk\", \"topkreservewithoptions\"), func() {\n\t\t\t\t\terr := client.TopKReserveWithOptions(ctx, \"topk1\", 3, 1500, 8, 0.5).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tresultInfo, err := client.TopKInfo(ctx, \"topk1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultInfo.K).To(BeEquivalentTo(int64(3)))\n\t\t\t\t\tExpect(resultInfo.Width).To(BeEquivalentTo(int64(1500)))\n\t\t\t\t\tExpect(resultInfo.Depth).To(BeEquivalentTo(int64(8)))\n\t\t\t\t\tExpect(resultInfo.Decay).To(BeEquivalentTo(0.5))\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tDescribe(\"t-digest\", Label(\"tdigest\"), func() {\n\t\t\t\tIt(\"should TDigestAdd, TDigestCreate, TDigestInfo, TDigestByRank, TDigestByRevRank, TDigestCDF, TDigestMax, TDigestMin, TDigestQuantile, TDigestRank, TDigestRevRank, TDigestTrimmedMean, TDigestReset, \", Label(\"tdigest\", \"tdigestadd\", \"tdigestcreate\", \"tdigestinfo\", \"tdigestbyrank\", \"tdigestbyrevrank\", \"tdigestcdf\", \"tdigestmax\", \"tdigestmin\", \"tdigestquantile\", \"tdigestrank\", \"tdigestrevrank\", \"tdigesttrimmedmean\", \"tdigestreset\"), func() {\n\t\t\t\t\terr := client.TDigestCreate(ctx, \"tdigest1\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tinfo, err := client.TDigestInfo(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(info.Observations).To(BeEquivalentTo(int64(0)))\n\n\t\t\t\t\t// Test with empty sketch\n\t\t\t\t\tbyRank, err := client.TDigestByRank(ctx, \"tdigest1\", 0, 1, 2, 3).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(byRank)).To(BeEquivalentTo(4))\n\n\t\t\t\t\tbyRevRank, err := client.TDigestByRevRank(ctx, \"tdigest1\", 0, 1, 2).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(byRevRank)).To(BeEquivalentTo(3))\n\n\t\t\t\t\tcdf, err := client.TDigestCDF(ctx, \"tdigest1\", 15, 35, 70).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(cdf)).To(BeEquivalentTo(3))\n\n\t\t\t\t\tmax, err := client.TDigestMax(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(math.IsNaN(max)).To(BeTrue())\n\n\t\t\t\t\tmin, err := client.TDigestMin(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(math.IsNaN(min)).To(BeTrue())\n\n\t\t\t\t\tquantile, err := client.TDigestQuantile(ctx, \"tdigest1\", 0.1, 0.2).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(quantile)).To(BeEquivalentTo(2))\n\n\t\t\t\t\trank, err := client.TDigestRank(ctx, \"tdigest1\", 10, 20).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(rank)).To(BeEquivalentTo(2))\n\n\t\t\t\t\trevRank, err := client.TDigestRevRank(ctx, \"tdigest1\", 10, 20).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(revRank)).To(BeEquivalentTo(2))\n\n\t\t\t\t\ttrimmedMean, err := client.TDigestTrimmedMean(ctx, \"tdigest1\", 0.1, 0.6).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(math.IsNaN(trimmedMean)).To(BeTrue())\n\n\t\t\t\t\t// Add elements\n\t\t\t\t\terr = client.TDigestAdd(ctx, \"tdigest1\", 10, 20, 30, 40, 50, 60, 70, 80, 90, 100).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tinfo, err = client.TDigestInfo(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(info.Observations).To(BeEquivalentTo(int64(10)))\n\n\t\t\t\t\tbyRank, err = client.TDigestByRank(ctx, \"tdigest1\", 0, 1, 2).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(byRank)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(byRank[0]).To(BeEquivalentTo(float64(10)))\n\t\t\t\t\tExpect(byRank[1]).To(BeEquivalentTo(float64(20)))\n\t\t\t\t\tExpect(byRank[2]).To(BeEquivalentTo(float64(30)))\n\n\t\t\t\t\tbyRevRank, err = client.TDigestByRevRank(ctx, \"tdigest1\", 0, 1, 2).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(byRevRank)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(byRevRank[0]).To(BeEquivalentTo(float64(100)))\n\t\t\t\t\tExpect(byRevRank[1]).To(BeEquivalentTo(float64(90)))\n\t\t\t\t\tExpect(byRevRank[2]).To(BeEquivalentTo(float64(80)))\n\n\t\t\t\t\tcdf, err = client.TDigestCDF(ctx, \"tdigest1\", 15, 35, 70).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(cdf)).To(BeEquivalentTo(3))\n\t\t\t\t\tExpect(cdf[0]).To(BeEquivalentTo(0.1))\n\t\t\t\t\tExpect(cdf[1]).To(BeEquivalentTo(0.3))\n\t\t\t\t\tExpect(cdf[2]).To(BeEquivalentTo(0.65))\n\n\t\t\t\t\tmax, err = client.TDigestMax(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(max).To(BeEquivalentTo(float64(100)))\n\n\t\t\t\t\tmin, err = client.TDigestMin(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(min).To(BeEquivalentTo(float64(10)))\n\n\t\t\t\t\tquantile, err = client.TDigestQuantile(ctx, \"tdigest1\", 0.1, 0.2).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(quantile)).To(BeEquivalentTo(2))\n\t\t\t\t\tExpect(quantile[0]).To(BeEquivalentTo(float64(20)))\n\t\t\t\t\tExpect(quantile[1]).To(BeEquivalentTo(float64(30)))\n\n\t\t\t\t\trank, err = client.TDigestRank(ctx, \"tdigest1\", 10, 20).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(rank)).To(BeEquivalentTo(2))\n\t\t\t\t\tExpect(rank[0]).To(BeEquivalentTo(int64(0)))\n\t\t\t\t\tExpect(rank[1]).To(BeEquivalentTo(int64(1)))\n\n\t\t\t\t\trevRank, err = client.TDigestRevRank(ctx, \"tdigest1\", 10, 20).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(len(revRank)).To(BeEquivalentTo(2))\n\t\t\t\t\tExpect(revRank[0]).To(BeEquivalentTo(int64(9)))\n\t\t\t\t\tExpect(revRank[1]).To(BeEquivalentTo(int64(8)))\n\n\t\t\t\t\ttrimmedMean, err = client.TDigestTrimmedMean(ctx, \"tdigest1\", 0.1, 0.6).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(trimmedMean).To(BeEquivalentTo(float64(40)))\n\n\t\t\t\t\treset, err := client.TDigestReset(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(reset).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should TDigestCreateWithCompression\", Label(\"tdigest\", \"tcreatewithcompression\"), func() {\n\t\t\t\t\terr := client.TDigestCreateWithCompression(ctx, \"tdigest1\", 2000).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tinfo, err := client.TDigestInfo(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(info.Compression).To(BeEquivalentTo(int64(2000)))\n\t\t\t\t})\n\n\t\t\t\tIt(\"should TDigestMerge\", Label(\"tdigest\", \"tmerge\", \"NonRedisEnterprise\"), func() {\n\t\t\t\t\terr := client.TDigestCreate(ctx, \"tdigest1\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.TDigestAdd(ctx, \"tdigest1\", 10, 20, 30, 40, 50, 60, 70, 80, 90, 100).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\terr = client.TDigestCreate(ctx, \"tdigest2\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.TDigestAdd(ctx, \"tdigest2\", 15, 25, 35, 45, 55, 65, 75, 85, 95, 105).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\terr = client.TDigestCreate(ctx, \"tdigest3\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\terr = client.TDigestAdd(ctx, \"tdigest3\", 50, 60, 70, 80, 90, 100, 110, 120, 130, 140).Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\toptions := &redis.TDigestMergeOptions{\n\t\t\t\t\t\tCompression: 1000,\n\t\t\t\t\t\tOverride:    false,\n\t\t\t\t\t}\n\t\t\t\t\terr = client.TDigestMerge(ctx, \"tdigest1\", options, \"tdigest2\", \"tdigest3\").Err()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tinfo, err := client.TDigestInfo(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(info.Observations).To(BeEquivalentTo(int64(30)))\n\t\t\t\t\tExpect(info.Compression).To(BeEquivalentTo(int64(1000)))\n\n\t\t\t\t\tmax, err := client.TDigestMax(ctx, \"tdigest1\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(max).To(BeEquivalentTo(float64(140)))\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t}\n})\n"
        },
        {
          "name": "pubsub.go",
          "type": "blob",
          "size": 16.3984375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\n// PubSub implements Pub/Sub commands as described in\n// http://redis.io/topics/pubsub. Message receiving is NOT safe\n// for concurrent use by multiple goroutines.\n//\n// PubSub automatically reconnects to Redis Server and resubscribes\n// to the channels in case of network errors.\ntype PubSub struct {\n\topt *Options\n\n\tnewConn   func(ctx context.Context, channels []string) (*pool.Conn, error)\n\tcloseConn func(*pool.Conn) error\n\n\tmu        sync.Mutex\n\tcn        *pool.Conn\n\tchannels  map[string]struct{}\n\tpatterns  map[string]struct{}\n\tschannels map[string]struct{}\n\n\tclosed bool\n\texit   chan struct{}\n\n\tcmd *Cmd\n\n\tchOnce sync.Once\n\tmsgCh  *channel\n\tallCh  *channel\n}\n\nfunc (c *PubSub) init() {\n\tc.exit = make(chan struct{})\n}\n\nfunc (c *PubSub) String() string {\n\tchannels := mapKeys(c.channels)\n\tchannels = append(channels, mapKeys(c.patterns)...)\n\tchannels = append(channels, mapKeys(c.schannels)...)\n\treturn fmt.Sprintf(\"PubSub(%s)\", strings.Join(channels, \", \"))\n}\n\nfunc (c *PubSub) connWithLock(ctx context.Context) (*pool.Conn, error) {\n\tc.mu.Lock()\n\tcn, err := c.conn(ctx, nil)\n\tc.mu.Unlock()\n\treturn cn, err\n}\n\nfunc (c *PubSub) conn(ctx context.Context, newChannels []string) (*pool.Conn, error) {\n\tif c.closed {\n\t\treturn nil, pool.ErrClosed\n\t}\n\tif c.cn != nil {\n\t\treturn c.cn, nil\n\t}\n\n\tchannels := mapKeys(c.channels)\n\tchannels = append(channels, newChannels...)\n\n\tcn, err := c.newConn(ctx, channels)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := c.resubscribe(ctx, cn); err != nil {\n\t\t_ = c.closeConn(cn)\n\t\treturn nil, err\n\t}\n\n\tc.cn = cn\n\treturn cn, nil\n}\n\nfunc (c *PubSub) writeCmd(ctx context.Context, cn *pool.Conn, cmd Cmder) error {\n\treturn cn.WithWriter(ctx, c.opt.WriteTimeout, func(wr *proto.Writer) error {\n\t\treturn writeCmd(wr, cmd)\n\t})\n}\n\nfunc (c *PubSub) resubscribe(ctx context.Context, cn *pool.Conn) error {\n\tvar firstErr error\n\n\tif len(c.channels) > 0 {\n\t\tfirstErr = c._subscribe(ctx, cn, \"subscribe\", mapKeys(c.channels))\n\t}\n\n\tif len(c.patterns) > 0 {\n\t\terr := c._subscribe(ctx, cn, \"psubscribe\", mapKeys(c.patterns))\n\t\tif err != nil && firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\n\tif len(c.schannels) > 0 {\n\t\terr := c._subscribe(ctx, cn, \"ssubscribe\", mapKeys(c.schannels))\n\t\tif err != nil && firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\n\treturn firstErr\n}\n\nfunc mapKeys(m map[string]struct{}) []string {\n\ts := make([]string, len(m))\n\ti := 0\n\tfor k := range m {\n\t\ts[i] = k\n\t\ti++\n\t}\n\treturn s\n}\n\nfunc (c *PubSub) _subscribe(\n\tctx context.Context, cn *pool.Conn, redisCmd string, channels []string,\n) error {\n\targs := make([]interface{}, 0, 1+len(channels))\n\targs = append(args, redisCmd)\n\tfor _, channel := range channels {\n\t\targs = append(args, channel)\n\t}\n\tcmd := NewSliceCmd(ctx, args...)\n\treturn c.writeCmd(ctx, cn, cmd)\n}\n\nfunc (c *PubSub) releaseConnWithLock(\n\tctx context.Context,\n\tcn *pool.Conn,\n\terr error,\n\tallowTimeout bool,\n) {\n\tc.mu.Lock()\n\tc.releaseConn(ctx, cn, err, allowTimeout)\n\tc.mu.Unlock()\n}\n\nfunc (c *PubSub) releaseConn(ctx context.Context, cn *pool.Conn, err error, allowTimeout bool) {\n\tif c.cn != cn {\n\t\treturn\n\t}\n\tif isBadConn(err, allowTimeout, c.opt.Addr) {\n\t\tc.reconnect(ctx, err)\n\t}\n}\n\nfunc (c *PubSub) reconnect(ctx context.Context, reason error) {\n\t_ = c.closeTheCn(reason)\n\t_, _ = c.conn(ctx, nil)\n}\n\nfunc (c *PubSub) closeTheCn(reason error) error {\n\tif c.cn == nil {\n\t\treturn nil\n\t}\n\tif !c.closed {\n\t\tinternal.Logger.Printf(c.getContext(), \"redis: discarding bad PubSub connection: %s\", reason)\n\t}\n\terr := c.closeConn(c.cn)\n\tc.cn = nil\n\treturn err\n}\n\nfunc (c *PubSub) Close() error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.closed {\n\t\treturn pool.ErrClosed\n\t}\n\tc.closed = true\n\tclose(c.exit)\n\n\treturn c.closeTheCn(pool.ErrClosed)\n}\n\n// Subscribe the client to the specified channels. It returns\n// empty subscription if there are no channels.\nfunc (c *PubSub) Subscribe(ctx context.Context, channels ...string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\terr := c.subscribe(ctx, \"subscribe\", channels...)\n\tif c.channels == nil {\n\t\tc.channels = make(map[string]struct{})\n\t}\n\tfor _, s := range channels {\n\t\tc.channels[s] = struct{}{}\n\t}\n\treturn err\n}\n\n// PSubscribe the client to the given patterns. It returns\n// empty subscription if there are no patterns.\nfunc (c *PubSub) PSubscribe(ctx context.Context, patterns ...string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\terr := c.subscribe(ctx, \"psubscribe\", patterns...)\n\tif c.patterns == nil {\n\t\tc.patterns = make(map[string]struct{})\n\t}\n\tfor _, s := range patterns {\n\t\tc.patterns[s] = struct{}{}\n\t}\n\treturn err\n}\n\n// SSubscribe Subscribes the client to the specified shard channels.\nfunc (c *PubSub) SSubscribe(ctx context.Context, channels ...string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\terr := c.subscribe(ctx, \"ssubscribe\", channels...)\n\tif c.schannels == nil {\n\t\tc.schannels = make(map[string]struct{})\n\t}\n\tfor _, s := range channels {\n\t\tc.schannels[s] = struct{}{}\n\t}\n\treturn err\n}\n\n// Unsubscribe the client from the given channels, or from all of\n// them if none is given.\nfunc (c *PubSub) Unsubscribe(ctx context.Context, channels ...string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif len(channels) > 0 {\n\t\tfor _, channel := range channels {\n\t\t\tdelete(c.channels, channel)\n\t\t}\n\t} else {\n\t\t// Unsubscribe from all channels.\n\t\tfor channel := range c.channels {\n\t\t\tdelete(c.channels, channel)\n\t\t}\n\t}\n\n\terr := c.subscribe(ctx, \"unsubscribe\", channels...)\n\treturn err\n}\n\n// PUnsubscribe the client from the given patterns, or from all of\n// them if none is given.\nfunc (c *PubSub) PUnsubscribe(ctx context.Context, patterns ...string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif len(patterns) > 0 {\n\t\tfor _, pattern := range patterns {\n\t\t\tdelete(c.patterns, pattern)\n\t\t}\n\t} else {\n\t\t// Unsubscribe from all patterns.\n\t\tfor pattern := range c.patterns {\n\t\t\tdelete(c.patterns, pattern)\n\t\t}\n\t}\n\n\terr := c.subscribe(ctx, \"punsubscribe\", patterns...)\n\treturn err\n}\n\n// SUnsubscribe unsubscribes the client from the given shard channels,\n// or from all of them if none is given.\nfunc (c *PubSub) SUnsubscribe(ctx context.Context, channels ...string) error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif len(channels) > 0 {\n\t\tfor _, channel := range channels {\n\t\t\tdelete(c.schannels, channel)\n\t\t}\n\t} else {\n\t\t// Unsubscribe from all channels.\n\t\tfor channel := range c.schannels {\n\t\t\tdelete(c.schannels, channel)\n\t\t}\n\t}\n\n\terr := c.subscribe(ctx, \"sunsubscribe\", channels...)\n\treturn err\n}\n\nfunc (c *PubSub) subscribe(ctx context.Context, redisCmd string, channels ...string) error {\n\tcn, err := c.conn(ctx, channels)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = c._subscribe(ctx, cn, redisCmd, channels)\n\tc.releaseConn(ctx, cn, err, false)\n\treturn err\n}\n\nfunc (c *PubSub) Ping(ctx context.Context, payload ...string) error {\n\targs := []interface{}{\"ping\"}\n\tif len(payload) == 1 {\n\t\targs = append(args, payload[0])\n\t}\n\tcmd := NewCmd(ctx, args...)\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tcn, err := c.conn(ctx, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = c.writeCmd(ctx, cn, cmd)\n\tc.releaseConn(ctx, cn, err, false)\n\treturn err\n}\n\n// Subscription received after a successful subscription to channel.\ntype Subscription struct {\n\t// Can be \"subscribe\", \"unsubscribe\", \"psubscribe\" or \"punsubscribe\".\n\tKind string\n\t// Channel name we have subscribed to.\n\tChannel string\n\t// Number of channels we are currently subscribed to.\n\tCount int\n}\n\nfunc (m *Subscription) String() string {\n\treturn fmt.Sprintf(\"%s: %s\", m.Kind, m.Channel)\n}\n\n// Message received as result of a PUBLISH command issued by another client.\ntype Message struct {\n\tChannel      string\n\tPattern      string\n\tPayload      string\n\tPayloadSlice []string\n}\n\nfunc (m *Message) String() string {\n\treturn fmt.Sprintf(\"Message<%s: %s>\", m.Channel, m.Payload)\n}\n\n// Pong received as result of a PING command issued by another client.\ntype Pong struct {\n\tPayload string\n}\n\nfunc (p *Pong) String() string {\n\tif p.Payload != \"\" {\n\t\treturn fmt.Sprintf(\"Pong<%s>\", p.Payload)\n\t}\n\treturn \"Pong\"\n}\n\nfunc (c *PubSub) newMessage(reply interface{}) (interface{}, error) {\n\tswitch reply := reply.(type) {\n\tcase string:\n\t\treturn &Pong{\n\t\t\tPayload: reply,\n\t\t}, nil\n\tcase []interface{}:\n\t\tswitch kind := reply[0].(string); kind {\n\t\tcase \"subscribe\", \"unsubscribe\", \"psubscribe\", \"punsubscribe\", \"ssubscribe\", \"sunsubscribe\":\n\t\t\t// Can be nil in case of \"unsubscribe\".\n\t\t\tchannel, _ := reply[1].(string)\n\t\t\treturn &Subscription{\n\t\t\t\tKind:    kind,\n\t\t\t\tChannel: channel,\n\t\t\t\tCount:   int(reply[2].(int64)),\n\t\t\t}, nil\n\t\tcase \"message\", \"smessage\":\n\t\t\tswitch payload := reply[2].(type) {\n\t\t\tcase string:\n\t\t\t\treturn &Message{\n\t\t\t\t\tChannel: reply[1].(string),\n\t\t\t\t\tPayload: payload,\n\t\t\t\t}, nil\n\t\t\tcase []interface{}:\n\t\t\t\tss := make([]string, len(payload))\n\t\t\t\tfor i, s := range payload {\n\t\t\t\t\tss[i] = s.(string)\n\t\t\t\t}\n\t\t\t\treturn &Message{\n\t\t\t\t\tChannel:      reply[1].(string),\n\t\t\t\t\tPayloadSlice: ss,\n\t\t\t\t}, nil\n\t\t\tdefault:\n\t\t\t\treturn nil, fmt.Errorf(\"redis: unsupported pubsub message payload: %T\", payload)\n\t\t\t}\n\t\tcase \"pmessage\":\n\t\t\treturn &Message{\n\t\t\t\tPattern: reply[1].(string),\n\t\t\t\tChannel: reply[2].(string),\n\t\t\t\tPayload: reply[3].(string),\n\t\t\t}, nil\n\t\tcase \"pong\":\n\t\t\treturn &Pong{\n\t\t\t\tPayload: reply[1].(string),\n\t\t\t}, nil\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"redis: unsupported pubsub message: %q\", kind)\n\t\t}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"redis: unsupported pubsub message: %#v\", reply)\n\t}\n}\n\n// ReceiveTimeout acts like Receive but returns an error if message\n// is not received in time. This is low-level API and in most cases\n// Channel should be used instead.\nfunc (c *PubSub) ReceiveTimeout(ctx context.Context, timeout time.Duration) (interface{}, error) {\n\tif c.cmd == nil {\n\t\tc.cmd = NewCmd(ctx)\n\t}\n\n\t// Don't hold the lock to allow subscriptions and pings.\n\n\tcn, err := c.connWithLock(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = cn.WithReader(context.Background(), timeout, func(rd *proto.Reader) error {\n\t\treturn c.cmd.readReply(rd)\n\t})\n\n\tc.releaseConnWithLock(ctx, cn, err, timeout > 0)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn c.newMessage(c.cmd.Val())\n}\n\n// Receive returns a message as a Subscription, Message, Pong or error.\n// See PubSub example for details. This is low-level API and in most cases\n// Channel should be used instead.\nfunc (c *PubSub) Receive(ctx context.Context) (interface{}, error) {\n\treturn c.ReceiveTimeout(ctx, 0)\n}\n\n// ReceiveMessage returns a Message or error ignoring Subscription and Pong\n// messages. This is low-level API and in most cases Channel should be used\n// instead.\nfunc (c *PubSub) ReceiveMessage(ctx context.Context) (*Message, error) {\n\tfor {\n\t\tmsg, err := c.Receive(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tswitch msg := msg.(type) {\n\t\tcase *Subscription:\n\t\t\t// Ignore.\n\t\tcase *Pong:\n\t\t\t// Ignore.\n\t\tcase *Message:\n\t\t\treturn msg, nil\n\t\tdefault:\n\t\t\terr := fmt.Errorf(\"redis: unknown message: %T\", msg)\n\t\t\treturn nil, err\n\t\t}\n\t}\n}\n\nfunc (c *PubSub) getContext() context.Context {\n\tif c.cmd != nil {\n\t\treturn c.cmd.ctx\n\t}\n\treturn context.Background()\n}\n\n//------------------------------------------------------------------------------\n\n// Channel returns a Go channel for concurrently receiving messages.\n// The channel is closed together with the PubSub. If the Go channel\n// is blocked full for 1 minute the message is dropped.\n// Receive* APIs can not be used after channel is created.\n//\n// go-redis periodically sends ping messages to test connection health\n// and re-subscribes if ping can not received for 1 minute.\nfunc (c *PubSub) Channel(opts ...ChannelOption) <-chan *Message {\n\tc.chOnce.Do(func() {\n\t\tc.msgCh = newChannel(c, opts...)\n\t\tc.msgCh.initMsgChan()\n\t})\n\tif c.msgCh == nil {\n\t\terr := fmt.Errorf(\"redis: Channel can't be called after ChannelWithSubscriptions\")\n\t\tpanic(err)\n\t}\n\treturn c.msgCh.msgCh\n}\n\n// ChannelSize is like Channel, but creates a Go channel\n// with specified buffer size.\n//\n// Deprecated: use Channel(WithChannelSize(size)), remove in v9.\nfunc (c *PubSub) ChannelSize(size int) <-chan *Message {\n\treturn c.Channel(WithChannelSize(size))\n}\n\n// ChannelWithSubscriptions is like Channel, but message type can be either\n// *Subscription or *Message. Subscription messages can be used to detect\n// reconnections.\n//\n// ChannelWithSubscriptions can not be used together with Channel or ChannelSize.\nfunc (c *PubSub) ChannelWithSubscriptions(opts ...ChannelOption) <-chan interface{} {\n\tc.chOnce.Do(func() {\n\t\tc.allCh = newChannel(c, opts...)\n\t\tc.allCh.initAllChan()\n\t})\n\tif c.allCh == nil {\n\t\terr := fmt.Errorf(\"redis: ChannelWithSubscriptions can't be called after Channel\")\n\t\tpanic(err)\n\t}\n\treturn c.allCh.allCh\n}\n\ntype ChannelOption func(c *channel)\n\n// WithChannelSize specifies the Go chan size that is used to buffer incoming messages.\n//\n// The default is 100 messages.\nfunc WithChannelSize(size int) ChannelOption {\n\treturn func(c *channel) {\n\t\tc.chanSize = size\n\t}\n}\n\n// WithChannelHealthCheckInterval specifies the health check interval.\n// PubSub will ping Redis Server if it does not receive any messages within the interval.\n// To disable health check, use zero interval.\n//\n// The default is 3 seconds.\nfunc WithChannelHealthCheckInterval(d time.Duration) ChannelOption {\n\treturn func(c *channel) {\n\t\tc.checkInterval = d\n\t}\n}\n\n// WithChannelSendTimeout specifies the channel send timeout after which\n// the message is dropped.\n//\n// The default is 60 seconds.\nfunc WithChannelSendTimeout(d time.Duration) ChannelOption {\n\treturn func(c *channel) {\n\t\tc.chanSendTimeout = d\n\t}\n}\n\ntype channel struct {\n\tpubSub *PubSub\n\n\tmsgCh chan *Message\n\tallCh chan interface{}\n\tping  chan struct{}\n\n\tchanSize        int\n\tchanSendTimeout time.Duration\n\tcheckInterval   time.Duration\n}\n\nfunc newChannel(pubSub *PubSub, opts ...ChannelOption) *channel {\n\tc := &channel{\n\t\tpubSub: pubSub,\n\n\t\tchanSize:        100,\n\t\tchanSendTimeout: time.Minute,\n\t\tcheckInterval:   3 * time.Second,\n\t}\n\tfor _, opt := range opts {\n\t\topt(c)\n\t}\n\tif c.checkInterval > 0 {\n\t\tc.initHealthCheck()\n\t}\n\treturn c\n}\n\nfunc (c *channel) initHealthCheck() {\n\tctx := context.TODO()\n\tc.ping = make(chan struct{}, 1)\n\n\tgo func() {\n\t\ttimer := time.NewTimer(time.Minute)\n\t\ttimer.Stop()\n\n\t\tfor {\n\t\t\ttimer.Reset(c.checkInterval)\n\t\t\tselect {\n\t\t\tcase <-c.ping:\n\t\t\t\tif !timer.Stop() {\n\t\t\t\t\t<-timer.C\n\t\t\t\t}\n\t\t\tcase <-timer.C:\n\t\t\t\tif pingErr := c.pubSub.Ping(ctx); pingErr != nil {\n\t\t\t\t\tc.pubSub.mu.Lock()\n\t\t\t\t\tc.pubSub.reconnect(ctx, pingErr)\n\t\t\t\t\tc.pubSub.mu.Unlock()\n\t\t\t\t}\n\t\t\tcase <-c.pubSub.exit:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// initMsgChan must be in sync with initAllChan.\nfunc (c *channel) initMsgChan() {\n\tctx := context.TODO()\n\tc.msgCh = make(chan *Message, c.chanSize)\n\n\tgo func() {\n\t\ttimer := time.NewTimer(time.Minute)\n\t\ttimer.Stop()\n\n\t\tvar errCount int\n\t\tfor {\n\t\t\tmsg, err := c.pubSub.Receive(ctx)\n\t\t\tif err != nil {\n\t\t\t\tif err == pool.ErrClosed {\n\t\t\t\t\tclose(c.msgCh)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif errCount > 0 {\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t}\n\t\t\t\terrCount++\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terrCount = 0\n\n\t\t\t// Any message is as good as a ping.\n\t\t\tselect {\n\t\t\tcase c.ping <- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tswitch msg := msg.(type) {\n\t\t\tcase *Subscription:\n\t\t\t\t// Ignore.\n\t\t\tcase *Pong:\n\t\t\t\t// Ignore.\n\t\t\tcase *Message:\n\t\t\t\ttimer.Reset(c.chanSendTimeout)\n\t\t\t\tselect {\n\t\t\t\tcase c.msgCh <- msg:\n\t\t\t\t\tif !timer.Stop() {\n\t\t\t\t\t\t<-timer.C\n\t\t\t\t\t}\n\t\t\t\tcase <-timer.C:\n\t\t\t\t\tinternal.Logger.Printf(\n\t\t\t\t\t\tctx, \"redis: %s channel is full for %s (message is dropped)\",\n\t\t\t\t\t\tc, c.chanSendTimeout)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tinternal.Logger.Printf(ctx, \"redis: unknown message type: %T\", msg)\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// initAllChan must be in sync with initMsgChan.\nfunc (c *channel) initAllChan() {\n\tctx := context.TODO()\n\tc.allCh = make(chan interface{}, c.chanSize)\n\n\tgo func() {\n\t\ttimer := time.NewTimer(time.Minute)\n\t\ttimer.Stop()\n\n\t\tvar errCount int\n\t\tfor {\n\t\t\tmsg, err := c.pubSub.Receive(ctx)\n\t\t\tif err != nil {\n\t\t\t\tif err == pool.ErrClosed {\n\t\t\t\t\tclose(c.allCh)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif errCount > 0 {\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t}\n\t\t\t\terrCount++\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terrCount = 0\n\n\t\t\t// Any message is as good as a ping.\n\t\t\tselect {\n\t\t\tcase c.ping <- struct{}{}:\n\t\t\tdefault:\n\t\t\t}\n\n\t\t\tswitch msg := msg.(type) {\n\t\t\tcase *Pong:\n\t\t\t\t// Ignore.\n\t\t\tcase *Subscription, *Message:\n\t\t\t\ttimer.Reset(c.chanSendTimeout)\n\t\t\t\tselect {\n\t\t\t\tcase c.allCh <- msg:\n\t\t\t\t\tif !timer.Stop() {\n\t\t\t\t\t\t<-timer.C\n\t\t\t\t\t}\n\t\t\t\tcase <-timer.C:\n\t\t\t\t\tinternal.Logger.Printf(\n\t\t\t\t\t\tctx, \"redis: %s channel is full for %s (message is dropped)\",\n\t\t\t\t\t\tc, c.chanSendTimeout)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tinternal.Logger.Printf(ctx, \"redis: unknown message type: %T\", msg)\n\t\t\t}\n\t\t}\n\t}()\n}\n"
        },
        {
          "name": "pubsub_commands.go",
          "type": "blob",
          "size": 2.1943359375,
          "content": "package redis\n\nimport \"context\"\n\ntype PubSubCmdable interface {\n\tPublish(ctx context.Context, channel string, message interface{}) *IntCmd\n\tSPublish(ctx context.Context, channel string, message interface{}) *IntCmd\n\tPubSubChannels(ctx context.Context, pattern string) *StringSliceCmd\n\tPubSubNumSub(ctx context.Context, channels ...string) *MapStringIntCmd\n\tPubSubNumPat(ctx context.Context) *IntCmd\n\tPubSubShardChannels(ctx context.Context, pattern string) *StringSliceCmd\n\tPubSubShardNumSub(ctx context.Context, channels ...string) *MapStringIntCmd\n}\n\n// Publish posts the message to the channel.\nfunc (c cmdable) Publish(ctx context.Context, channel string, message interface{}) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"publish\", channel, message)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SPublish(ctx context.Context, channel string, message interface{}) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"spublish\", channel, message)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PubSubChannels(ctx context.Context, pattern string) *StringSliceCmd {\n\targs := []interface{}{\"pubsub\", \"channels\"}\n\tif pattern != \"*\" {\n\t\targs = append(args, pattern)\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PubSubNumSub(ctx context.Context, channels ...string) *MapStringIntCmd {\n\targs := make([]interface{}, 2+len(channels))\n\targs[0] = \"pubsub\"\n\targs[1] = \"numsub\"\n\tfor i, channel := range channels {\n\t\targs[2+i] = channel\n\t}\n\tcmd := NewMapStringIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PubSubShardChannels(ctx context.Context, pattern string) *StringSliceCmd {\n\targs := []interface{}{\"pubsub\", \"shardchannels\"}\n\tif pattern != \"*\" {\n\t\targs = append(args, pattern)\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PubSubShardNumSub(ctx context.Context, channels ...string) *MapStringIntCmd {\n\targs := make([]interface{}, 2+len(channels))\n\targs[0] = \"pubsub\"\n\targs[1] = \"shardnumsub\"\n\tfor i, channel := range channels {\n\t\targs[2+i] = channel\n\t}\n\tcmd := NewMapStringIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) PubSubNumPat(ctx context.Context) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"pubsub\", \"numpat\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "pubsub_test.go",
          "type": "blob",
          "size": 14.84375,
          "content": "package redis_test\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"PubSub\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\topt := redisOptions()\n\t\topt.MinIdleConns = 0\n\t\topt.ConnMaxLifetime = 0\n\t\tclient = redis.NewClient(opt)\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"implements Stringer\", func() {\n\t\tpubsub := client.PSubscribe(ctx, \"mychannel*\")\n\t\tdefer pubsub.Close()\n\n\t\tExpect(pubsub.String()).To(Equal(\"PubSub(mychannel*)\"))\n\t})\n\n\tIt(\"should support pattern matching\", func() {\n\t\tpubsub := client.PSubscribe(ctx, \"mychannel*\")\n\t\tdefer pubsub.Close()\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"psubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel*\"))\n\t\t\tExpect(subscr.Count).To(Equal(1))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err.(net.Error).Timeout()).To(Equal(true))\n\t\t\tExpect(msgi).To(BeNil())\n\t\t}\n\n\t\tn, err := client.Publish(ctx, \"mychannel1\", \"hello\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(1)))\n\n\t\tExpect(pubsub.PUnsubscribe(ctx, \"mychannel*\")).NotTo(HaveOccurred())\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Message)\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel1\"))\n\t\t\tExpect(subscr.Pattern).To(Equal(\"mychannel*\"))\n\t\t\tExpect(subscr.Payload).To(Equal(\"hello\"))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"punsubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel*\"))\n\t\t\tExpect(subscr.Count).To(Equal(0))\n\t\t}\n\n\t\tstats := client.PoolStats()\n\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t})\n\n\tIt(\"should pub/sub channels\", func() {\n\t\tchannels, err := client.PubSubChannels(ctx, \"mychannel*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(channels).To(BeEmpty())\n\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\", \"mychannel2\")\n\t\tdefer pubsub.Close()\n\n\t\tchannels, err = client.PubSubChannels(ctx, \"mychannel*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(channels).To(ConsistOf([]string{\"mychannel\", \"mychannel2\"}))\n\n\t\tchannels, err = client.PubSubChannels(ctx, \"\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(channels).To(BeEmpty())\n\n\t\tchannels, err = client.PubSubChannels(ctx, \"*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(len(channels)).To(BeNumerically(\">=\", 2))\n\t})\n\n\tIt(\"should sharded pub/sub channels\", func() {\n\t\tchannels, err := client.PubSubShardChannels(ctx, \"mychannel*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(channels).To(BeEmpty())\n\n\t\tpubsub := client.SSubscribe(ctx, \"mychannel\", \"mychannel2\")\n\t\tdefer pubsub.Close()\n\n\t\tchannels, err = client.PubSubShardChannels(ctx, \"mychannel*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(channels).To(ConsistOf([]string{\"mychannel\", \"mychannel2\"}))\n\n\t\tchannels, err = client.PubSubShardChannels(ctx, \"\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(channels).To(BeEmpty())\n\n\t\tchannels, err = client.PubSubShardChannels(ctx, \"*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(len(channels)).To(BeNumerically(\">=\", 2))\n\n\t\tnums, err := client.PubSubShardNumSub(ctx, \"mychannel\", \"mychannel2\", \"mychannel3\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(nums).To(Equal(map[string]int64{\n\t\t\t\"mychannel\":  1,\n\t\t\t\"mychannel2\": 1,\n\t\t\t\"mychannel3\": 0,\n\t\t}))\n\t})\n\n\tIt(\"should return the numbers of subscribers\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\", \"mychannel2\")\n\t\tdefer pubsub.Close()\n\n\t\tchannels, err := client.PubSubNumSub(ctx, \"mychannel\", \"mychannel2\", \"mychannel3\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(channels).To(Equal(map[string]int64{\n\t\t\t\"mychannel\":  1,\n\t\t\t\"mychannel2\": 1,\n\t\t\t\"mychannel3\": 0,\n\t\t}))\n\t})\n\n\tIt(\"should return the numbers of subscribers by pattern\", func() {\n\t\tnum, err := client.PubSubNumPat(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(num).To(Equal(int64(0)))\n\n\t\tpubsub := client.PSubscribe(ctx, \"*\")\n\t\tdefer pubsub.Close()\n\n\t\tnum, err = client.PubSubNumPat(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(num).To(Equal(int64(1)))\n\t})\n\n\tIt(\"should pub/sub\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\", \"mychannel2\")\n\t\tdefer pubsub.Close()\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"subscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel\"))\n\t\t\tExpect(subscr.Count).To(Equal(1))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"subscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel2\"))\n\t\t\tExpect(subscr.Count).To(Equal(2))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err.(net.Error).Timeout()).To(Equal(true))\n\t\t\tExpect(msgi).NotTo(HaveOccurred())\n\t\t}\n\n\t\tn, err := client.Publish(ctx, \"mychannel\", \"hello\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(1)))\n\n\t\tn, err = client.Publish(ctx, \"mychannel2\", \"hello2\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(1)))\n\n\t\tExpect(pubsub.Unsubscribe(ctx, \"mychannel\", \"mychannel2\")).NotTo(HaveOccurred())\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tmsg := msgi.(*redis.Message)\n\t\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\t\tExpect(msg.Payload).To(Equal(\"hello\"))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tmsg := msgi.(*redis.Message)\n\t\t\tExpect(msg.Channel).To(Equal(\"mychannel2\"))\n\t\t\tExpect(msg.Payload).To(Equal(\"hello2\"))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"unsubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel\"))\n\t\t\tExpect(subscr.Count).To(Equal(1))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"unsubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel2\"))\n\t\t\tExpect(subscr.Count).To(Equal(0))\n\t\t}\n\n\t\tstats := client.PoolStats()\n\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t})\n\n\tIt(\"should sharded pub/sub\", func() {\n\t\tpubsub := client.SSubscribe(ctx, \"mychannel\", \"mychannel2\")\n\t\tdefer pubsub.Close()\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"ssubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel\"))\n\t\t\tExpect(subscr.Count).To(Equal(1))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"ssubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel2\"))\n\t\t\tExpect(subscr.Count).To(Equal(2))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err.(net.Error).Timeout()).To(Equal(true))\n\t\t\tExpect(msgi).NotTo(HaveOccurred())\n\t\t}\n\n\t\tn, err := client.SPublish(ctx, \"mychannel\", \"hello\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(1)))\n\n\t\tn, err = client.SPublish(ctx, \"mychannel2\", \"hello2\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(1)))\n\n\t\tExpect(pubsub.SUnsubscribe(ctx, \"mychannel\", \"mychannel2\")).NotTo(HaveOccurred())\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tmsg := msgi.(*redis.Message)\n\t\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\t\tExpect(msg.Payload).To(Equal(\"hello\"))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tmsg := msgi.(*redis.Message)\n\t\t\tExpect(msg.Channel).To(Equal(\"mychannel2\"))\n\t\t\tExpect(msg.Payload).To(Equal(\"hello2\"))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"sunsubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel\"))\n\t\t\tExpect(subscr.Count).To(Equal(1))\n\t\t}\n\n\t\t{\n\t\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tsubscr := msgi.(*redis.Subscription)\n\t\t\tExpect(subscr.Kind).To(Equal(\"sunsubscribe\"))\n\t\t\tExpect(subscr.Channel).To(Equal(\"mychannel2\"))\n\t\t\tExpect(subscr.Count).To(Equal(0))\n\t\t}\n\n\t\tstats := client.PoolStats()\n\t\tExpect(stats.Misses).To(Equal(uint32(1)))\n\t})\n\n\tIt(\"should ping/pong\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\t_, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = pubsub.Ping(ctx, \"\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tpong := msgi.(*redis.Pong)\n\t\tExpect(pong.Payload).To(Equal(\"\"))\n\t})\n\n\tIt(\"should ping/pong with payload\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\t_, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = pubsub.Ping(ctx, \"hello\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tmsgi, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tpong := msgi.(*redis.Pong)\n\t\tExpect(pong.Payload).To(Equal(\"hello\"))\n\t})\n\n\tIt(\"should multi-ReceiveMessage\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\tsubscr, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(subscr).To(Equal(&redis.Subscription{\n\t\t\tKind:    \"subscribe\",\n\t\t\tChannel: \"mychannel\",\n\t\t\tCount:   1,\n\t\t}))\n\n\t\terr = client.Publish(ctx, \"mychannel\", \"hello\").Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = client.Publish(ctx, \"mychannel\", \"world\").Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tmsg, err := pubsub.ReceiveMessage(ctx)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\tExpect(msg.Payload).To(Equal(\"hello\"))\n\n\t\tmsg, err = pubsub.ReceiveMessage(ctx)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\tExpect(msg.Payload).To(Equal(\"world\"))\n\t})\n\n\tIt(\"returns an error when subscribe fails\", func() {\n\t\tpubsub := client.Subscribe(ctx)\n\t\tdefer pubsub.Close()\n\n\t\tpubsub.SetNetConn(&badConn{\n\t\t\treadErr:  io.EOF,\n\t\t\twriteErr: io.EOF,\n\t\t})\n\n\t\terr := pubsub.Subscribe(ctx, \"mychannel\")\n\t\tExpect(err).To(MatchError(\"EOF\"))\n\n\t\terr = pubsub.Subscribe(ctx, \"mychannel\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\texpectReceiveMessageOnError := func(pubsub *redis.PubSub) {\n\t\tpubsub.SetNetConn(&badConn{\n\t\t\treadErr:  io.EOF,\n\t\t\twriteErr: io.EOF,\n\t\t})\n\n\t\tstep := make(chan struct{}, 3)\n\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\tEventually(step).Should(Receive())\n\t\t\terr := client.Publish(ctx, \"mychannel\", \"hello\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tstep <- struct{}{}\n\t\t}()\n\n\t\t_, err := pubsub.ReceiveMessage(ctx)\n\t\tExpect(err).To(Equal(io.EOF))\n\t\tstep <- struct{}{}\n\n\t\tmsg, err := pubsub.ReceiveMessage(ctx)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\tExpect(msg.Payload).To(Equal(\"hello\"))\n\n\t\tEventually(step).Should(Receive())\n\t}\n\n\tIt(\"Subscribe should reconnect on ReceiveMessage error\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\tsubscr, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(subscr).To(Equal(&redis.Subscription{\n\t\t\tKind:    \"subscribe\",\n\t\t\tChannel: \"mychannel\",\n\t\t\tCount:   1,\n\t\t}))\n\n\t\texpectReceiveMessageOnError(pubsub)\n\t})\n\n\tIt(\"PSubscribe should reconnect on ReceiveMessage error\", func() {\n\t\tpubsub := client.PSubscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\tsubscr, err := pubsub.ReceiveTimeout(ctx, time.Second)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(subscr).To(Equal(&redis.Subscription{\n\t\t\tKind:    \"psubscribe\",\n\t\t\tChannel: \"mychannel\",\n\t\t\tCount:   1,\n\t\t}))\n\n\t\texpectReceiveMessageOnError(pubsub)\n\t})\n\n\tIt(\"should return on Close\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\twg.Done()\n\t\t\tdefer wg.Done()\n\n\t\t\t_, err := pubsub.ReceiveMessage(ctx)\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(SatisfyAny(\n\t\t\t\tEqual(\"redis: client is closed\"),\n\t\t\t\tContainSubstring(\"use of closed network connection\"),\n\t\t\t))\n\t\t}()\n\n\t\twg.Wait()\n\t\twg.Add(1)\n\n\t\tExpect(pubsub.Close()).NotTo(HaveOccurred())\n\n\t\twg.Wait()\n\t})\n\n\tIt(\"should ReceiveMessage without a subscription\", func() {\n\t\ttimeout := 100 * time.Millisecond\n\n\t\tpubsub := client.Subscribe(ctx)\n\t\tdefer pubsub.Close()\n\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\t\t\tdefer wg.Done()\n\n\t\t\ttime.Sleep(timeout)\n\n\t\t\terr := pubsub.Subscribe(ctx, \"mychannel\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\ttime.Sleep(timeout)\n\n\t\t\terr = client.Publish(ctx, \"mychannel\", \"hello\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}()\n\n\t\tmsg, err := pubsub.ReceiveMessage(ctx)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\tExpect(msg.Payload).To(Equal(\"hello\"))\n\n\t\twg.Wait()\n\t})\n\n\tIt(\"handles big message payload\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\tch := pubsub.Channel()\n\n\t\tbigVal := bigVal()\n\t\terr := client.Publish(ctx, \"mychannel\", bigVal).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tvar msg *redis.Message\n\t\tEventually(ch).Should(Receive(&msg))\n\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\tExpect(msg.Payload).To(Equal(string(bigVal)))\n\t})\n\n\tIt(\"supports concurrent Ping and Receive\", func() {\n\t\tconst N = 100\n\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\tdone := make(chan struct{})\n\t\tgo func() {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\t_, err := pubsub.ReceiveTimeout(ctx, 5*time.Second)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t\tclose(done)\n\t\t}()\n\n\t\tfor i := 0; i < N; i++ {\n\t\t\terr := pubsub.Ping(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\tselect {\n\t\tcase <-done:\n\t\tcase <-time.After(30 * time.Second):\n\t\t\tFail(\"timeout\")\n\t\t}\n\t})\n\n\tIt(\"should ChannelMessage\", func() {\n\t\tpubsub := client.Subscribe(ctx, \"mychannel\")\n\t\tdefer pubsub.Close()\n\n\t\tch := pubsub.Channel(\n\t\t\tredis.WithChannelSize(10),\n\t\t\tredis.WithChannelHealthCheckInterval(time.Second),\n\t\t)\n\n\t\ttext := \"test channel message\"\n\t\terr := client.Publish(ctx, \"mychannel\", text).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tvar msg *redis.Message\n\t\tEventually(ch).Should(Receive(&msg))\n\t\tExpect(msg.Channel).To(Equal(\"mychannel\"))\n\t\tExpect(msg.Payload).To(Equal(text))\n\t})\n})\n"
        },
        {
          "name": "race_test.go",
          "type": "blob",
          "size": 6.9189453125,
          "content": "package redis_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"races\", func() {\n\tvar client *redis.Client\n\tvar C, N int\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).To(BeNil())\n\n\t\tC, N = 10, 1000\n\t\tif testing.Short() {\n\t\t\tC = 4\n\t\t\tN = 100\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\terr := client.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should echo\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tmsg := fmt.Sprintf(\"echo %d %d\", id, i)\n\t\t\t\techo, err := client.Echo(ctx, msg).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(echo).To(Equal(msg))\n\t\t\t}\n\t\t})\n\t})\n\n\tIt(\"should incr\", func() {\n\t\tkey := \"TestIncrFromGoroutines\"\n\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := client.Incr(ctx, key).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\n\t\tval, err := client.Get(ctx, key).Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(int64(C * N)))\n\t})\n\n\tIt(\"should handle many keys\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := client.Set(\n\t\t\t\t\tctx,\n\t\t\t\t\tfmt.Sprintf(\"keys.key-%d-%d\", id, i),\n\t\t\t\t\tfmt.Sprintf(\"hello-%d-%d\", id, i),\n\t\t\t\t\t0,\n\t\t\t\t).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\n\t\tkeys := client.Keys(ctx, \"keys.*\")\n\t\tExpect(keys.Err()).NotTo(HaveOccurred())\n\t\tExpect(len(keys.Val())).To(Equal(C * N))\n\t})\n\n\tIt(\"should handle many keys 2\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tkeys := []string{\"non-existent-key\"}\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tkey := fmt.Sprintf(\"keys.key-%d\", i)\n\t\t\t\tkeys = append(keys, key)\n\n\t\t\t\terr := client.Set(ctx, key, fmt.Sprintf(\"hello-%d\", i), 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t\tkeys = append(keys, \"non-existent-key\")\n\n\t\t\tvals, err := client.MGet(ctx, keys...).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(vals)).To(Equal(N + 2))\n\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tExpect(vals[i+1]).To(Equal(fmt.Sprintf(\"hello-%d\", i)))\n\t\t\t}\n\n\t\t\tExpect(vals[0]).To(BeNil())\n\t\t\tExpect(vals[N+1]).To(BeNil())\n\t\t})\n\t})\n\n\tIt(\"should handle big vals in Get\", func() {\n\t\tC, N = 4, 100\n\n\t\tbigVal := bigVal()\n\n\t\terr := client.Set(ctx, \"key\", bigVal, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t// Reconnect to get new connection.\n\t\tExpect(client.Close()).To(BeNil())\n\t\tclient = redis.NewClient(redisOptions())\n\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tgot, err := client.Get(ctx, \"key\").Bytes()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(got).To(Equal(bigVal))\n\t\t\t}\n\t\t})\n\t})\n\n\tIt(\"should handle big vals in Set\", func() {\n\t\tC, N = 4, 100\n\n\t\tbigVal := bigVal()\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := client.Set(ctx, \"key\", bigVal, 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\t})\n\n\tIt(\"should select db\", Label(\"NonRedisEnterprise\"), func() {\n\t\terr := client.Set(ctx, \"db\", 1, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tperform(C, func(id int) {\n\t\t\topt := redisOptions()\n\t\t\topt.DB = id\n\t\t\tclient := redis.NewClient(opt)\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := client.Set(ctx, \"db\", id, 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tn, err := client.Get(ctx, \"db\").Int64()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(n).To(Equal(int64(id)))\n\t\t\t}\n\t\t\terr := client.Close()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tn, err := client.Get(ctx, \"db\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(1)))\n\t})\n\n\tIt(\"should select DB with read timeout\", func() {\n\t\tperform(C, func(id int) {\n\t\t\topt := redisOptions()\n\t\t\topt.DB = id\n\t\t\topt.ReadTimeout = time.Nanosecond\n\t\t\tclient := redis.NewClient(opt)\n\n\t\t\tperform(C, func(id int) {\n\t\t\t\terr := client.Ping(ctx).Err()\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t\t})\n\n\t\t\terr := client.Close()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t})\n\n\tIt(\"should Watch/Unwatch\", func() {\n\t\terr := client.Set(ctx, \"key\", \"0\", 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\t\tval, err := tx.Get(ctx, \"key\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(val).NotTo(Equal(redis.Nil))\n\n\t\t\t\t\tnum, err := strconv.ParseInt(val, 10, 64)\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tcmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\t\tpipe.Set(ctx, \"key\", strconv.FormatInt(num+1, 10), 0)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t})\n\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\treturn err\n\t\t\t\t}, \"key\")\n\t\t\t\tif err == redis.TxFailedErr {\n\t\t\t\t\ti--\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\n\t\tval, err := client.Get(ctx, \"key\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(int64(C * N)))\n\t})\n\n\tPIt(\"should BLPop\", func() {\n\t\tvar received uint32\n\n\t\twg := performAsync(C, func(id int) {\n\t\t\tfor {\n\t\t\t\tv, err := client.BLPop(ctx, 5*time.Second, \"list\").Result()\n\t\t\t\tif err != nil {\n\t\t\t\t\tif err == redis.Nil {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tExpect(v).To(Equal([]string{\"list\", \"hello\"}))\n\t\t\t\tatomic.AddUint32(&received, 1)\n\t\t\t}\n\t\t})\n\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := client.LPush(ctx, \"list\", \"hello\").Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\n\t\twg.Wait()\n\t\tExpect(atomic.LoadUint32(&received)).To(Equal(uint32(C * N)))\n\t})\n})\n\nvar _ = Describe(\"cluster races\", Label(\"NonRedisEnterprise\"), func() {\n\tvar client *redis.ClusterClient\n\tvar C, N int\n\n\tBeforeEach(func() {\n\t\topt := redisClusterOptions()\n\t\tclient = cluster.newClusterClient(ctx, opt)\n\n\t\tC, N = 10, 1000\n\t\tif testing.Short() {\n\t\t\tC = 4\n\t\t\tN = 100\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\terr := client.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should echo\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tmsg := fmt.Sprintf(\"echo %d %d\", id, i)\n\t\t\t\techo, err := client.Echo(ctx, msg).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(echo).To(Equal(msg))\n\t\t\t}\n\t\t})\n\t})\n\n\tIt(\"should get\", func() {\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\tkey := fmt.Sprintf(\"key_%d_%d\", id, i)\n\t\t\t\t_, err := client.Get(ctx, key).Result()\n\t\t\t\tExpect(err).To(Equal(redis.Nil))\n\t\t\t}\n\t\t})\n\t})\n\n\tIt(\"should incr\", func() {\n\t\tkey := \"TestIncrFromGoroutines\"\n\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := client.Incr(ctx, key).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\n\t\tval, err := client.Get(ctx, key).Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(int64(C * N)))\n\t})\n\n\tIt(\"write cmd data-race\", func() {\n\t\tpubsub := client.Subscribe(ctx)\n\t\tdefer pubsub.Close()\n\n\t\tpubsub.Channel(redis.WithChannelHealthCheckInterval(time.Millisecond))\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tkey := fmt.Sprintf(\"channel_%d\", i)\n\t\t\tpubsub.Subscribe(ctx, key)\n\t\t\tpubsub.Unsubscribe(ctx, key)\n\t\t}\n\t})\n})\n\nfunc bigVal() []byte {\n\treturn bytes.Repeat([]byte{'*'}, 1<<17) // 128kb\n}\n"
        },
        {
          "name": "redis.go",
          "type": "blob",
          "size": 21.1953125,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/hscan\"\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\n// Scanner internal/hscan.Scanner exposed interface.\ntype Scanner = hscan.Scanner\n\n// Nil reply returned by Redis when key does not exist.\nconst Nil = proto.Nil\n\n// SetLogger set custom log\nfunc SetLogger(logger internal.Logging) {\n\tinternal.Logger = logger\n}\n\n//------------------------------------------------------------------------------\n\ntype Hook interface {\n\tDialHook(next DialHook) DialHook\n\tProcessHook(next ProcessHook) ProcessHook\n\tProcessPipelineHook(next ProcessPipelineHook) ProcessPipelineHook\n}\n\ntype (\n\tDialHook            func(ctx context.Context, network, addr string) (net.Conn, error)\n\tProcessHook         func(ctx context.Context, cmd Cmder) error\n\tProcessPipelineHook func(ctx context.Context, cmds []Cmder) error\n)\n\ntype hooksMixin struct {\n\thooksMu *sync.Mutex\n\n\tslice   []Hook\n\tinitial hooks\n\tcurrent hooks\n}\n\nfunc (hs *hooksMixin) initHooks(hooks hooks) {\n\ths.hooksMu = new(sync.Mutex)\n\ths.initial = hooks\n\ths.chain()\n}\n\ntype hooks struct {\n\tdial       DialHook\n\tprocess    ProcessHook\n\tpipeline   ProcessPipelineHook\n\ttxPipeline ProcessPipelineHook\n}\n\nfunc (h *hooks) setDefaults() {\n\tif h.dial == nil {\n\t\th.dial = func(ctx context.Context, network, addr string) (net.Conn, error) { return nil, nil }\n\t}\n\tif h.process == nil {\n\t\th.process = func(ctx context.Context, cmd Cmder) error { return nil }\n\t}\n\tif h.pipeline == nil {\n\t\th.pipeline = func(ctx context.Context, cmds []Cmder) error { return nil }\n\t}\n\tif h.txPipeline == nil {\n\t\th.txPipeline = func(ctx context.Context, cmds []Cmder) error { return nil }\n\t}\n}\n\n// AddHook is to add a hook to the queue.\n// Hook is a function executed during network connection, command execution, and pipeline,\n// it is a first-in-first-out stack queue (FIFO).\n// You need to execute the next hook in each hook, unless you want to terminate the execution of the command.\n// For example, you added hook-1, hook-2:\n//\n//\tclient.AddHook(hook-1, hook-2)\n//\n// hook-1:\n//\n//\tfunc (Hook1) ProcessHook(next redis.ProcessHook) redis.ProcessHook {\n//\t \treturn func(ctx context.Context, cmd Cmder) error {\n//\t\t \tprint(\"hook-1 start\")\n//\t\t \tnext(ctx, cmd)\n//\t\t \tprint(\"hook-1 end\")\n//\t\t \treturn nil\n//\t \t}\n//\t}\n//\n// hook-2:\n//\n//\tfunc (Hook2) ProcessHook(next redis.ProcessHook) redis.ProcessHook {\n//\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n//\t\t\tprint(\"hook-2 start\")\n//\t\t\tnext(ctx, cmd)\n//\t\t\tprint(\"hook-2 end\")\n//\t\t\treturn nil\n//\t\t}\n//\t}\n//\n// The execution sequence is:\n//\n//\thook-1 start -> hook-2 start -> exec redis cmd -> hook-2 end -> hook-1 end\n//\n// Please note: \"next(ctx, cmd)\" is very important, it will call the next hook,\n// if \"next(ctx, cmd)\" is not executed, the redis command will not be executed.\nfunc (hs *hooksMixin) AddHook(hook Hook) {\n\ths.slice = append(hs.slice, hook)\n\ths.chain()\n}\n\nfunc (hs *hooksMixin) chain() {\n\ths.initial.setDefaults()\n\n\ths.hooksMu.Lock()\n\tdefer hs.hooksMu.Unlock()\n\n\ths.current.dial = hs.initial.dial\n\ths.current.process = hs.initial.process\n\ths.current.pipeline = hs.initial.pipeline\n\ths.current.txPipeline = hs.initial.txPipeline\n\n\tfor i := len(hs.slice) - 1; i >= 0; i-- {\n\t\tif wrapped := hs.slice[i].DialHook(hs.current.dial); wrapped != nil {\n\t\t\ths.current.dial = wrapped\n\t\t}\n\t\tif wrapped := hs.slice[i].ProcessHook(hs.current.process); wrapped != nil {\n\t\t\ths.current.process = wrapped\n\t\t}\n\t\tif wrapped := hs.slice[i].ProcessPipelineHook(hs.current.pipeline); wrapped != nil {\n\t\t\ths.current.pipeline = wrapped\n\t\t}\n\t\tif wrapped := hs.slice[i].ProcessPipelineHook(hs.current.txPipeline); wrapped != nil {\n\t\t\ths.current.txPipeline = wrapped\n\t\t}\n\t}\n}\n\nfunc (hs *hooksMixin) clone() hooksMixin {\n\ths.hooksMu.Lock()\n\tdefer hs.hooksMu.Unlock()\n\n\tclone := *hs\n\tl := len(clone.slice)\n\tclone.slice = clone.slice[:l:l]\n\tclone.hooksMu = new(sync.Mutex)\n\treturn clone\n}\n\nfunc (hs *hooksMixin) withProcessHook(ctx context.Context, cmd Cmder, hook ProcessHook) error {\n\tfor i := len(hs.slice) - 1; i >= 0; i-- {\n\t\tif wrapped := hs.slice[i].ProcessHook(hook); wrapped != nil {\n\t\t\thook = wrapped\n\t\t}\n\t}\n\treturn hook(ctx, cmd)\n}\n\nfunc (hs *hooksMixin) withProcessPipelineHook(\n\tctx context.Context, cmds []Cmder, hook ProcessPipelineHook,\n) error {\n\tfor i := len(hs.slice) - 1; i >= 0; i-- {\n\t\tif wrapped := hs.slice[i].ProcessPipelineHook(hook); wrapped != nil {\n\t\t\thook = wrapped\n\t\t}\n\t}\n\treturn hook(ctx, cmds)\n}\n\nfunc (hs *hooksMixin) dialHook(ctx context.Context, network, addr string) (net.Conn, error) {\n\treturn hs.current.dial(ctx, network, addr)\n}\n\nfunc (hs *hooksMixin) processHook(ctx context.Context, cmd Cmder) error {\n\treturn hs.current.process(ctx, cmd)\n}\n\nfunc (hs *hooksMixin) processPipelineHook(ctx context.Context, cmds []Cmder) error {\n\treturn hs.current.pipeline(ctx, cmds)\n}\n\nfunc (hs *hooksMixin) processTxPipelineHook(ctx context.Context, cmds []Cmder) error {\n\treturn hs.current.txPipeline(ctx, cmds)\n}\n\n//------------------------------------------------------------------------------\n\ntype baseClient struct {\n\topt      *Options\n\tconnPool pool.Pooler\n\n\tonClose func() error // hook called when client is closed\n}\n\nfunc (c *baseClient) clone() *baseClient {\n\tclone := *c\n\treturn &clone\n}\n\nfunc (c *baseClient) withTimeout(timeout time.Duration) *baseClient {\n\topt := c.opt.clone()\n\topt.ReadTimeout = timeout\n\topt.WriteTimeout = timeout\n\n\tclone := c.clone()\n\tclone.opt = opt\n\n\treturn clone\n}\n\nfunc (c *baseClient) String() string {\n\treturn fmt.Sprintf(\"Redis<%s db:%d>\", c.getAddr(), c.opt.DB)\n}\n\nfunc (c *baseClient) newConn(ctx context.Context) (*pool.Conn, error) {\n\tcn, err := c.connPool.NewConn(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = c.initConn(ctx, cn)\n\tif err != nil {\n\t\t_ = c.connPool.CloseConn(cn)\n\t\treturn nil, err\n\t}\n\n\treturn cn, nil\n}\n\nfunc (c *baseClient) getConn(ctx context.Context) (*pool.Conn, error) {\n\tif c.opt.Limiter != nil {\n\t\terr := c.opt.Limiter.Allow()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tcn, err := c._getConn(ctx)\n\tif err != nil {\n\t\tif c.opt.Limiter != nil {\n\t\t\tc.opt.Limiter.ReportResult(err)\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn cn, nil\n}\n\nfunc (c *baseClient) _getConn(ctx context.Context) (*pool.Conn, error) {\n\tcn, err := c.connPool.Get(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cn.Inited {\n\t\treturn cn, nil\n\t}\n\n\tif err := c.initConn(ctx, cn); err != nil {\n\t\tc.connPool.Remove(ctx, cn, err)\n\t\tif err := errors.Unwrap(err); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, err\n\t}\n\n\treturn cn, nil\n}\n\nfunc (c *baseClient) initConn(ctx context.Context, cn *pool.Conn) error {\n\tif cn.Inited {\n\t\treturn nil\n\t}\n\tcn.Inited = true\n\n\tvar err error\n\tusername, password := c.opt.Username, c.opt.Password\n\tif c.opt.CredentialsProviderContext != nil {\n\t\tif username, password, err = c.opt.CredentialsProviderContext(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if c.opt.CredentialsProvider != nil {\n\t\tusername, password = c.opt.CredentialsProvider()\n\t}\n\n\tconnPool := pool.NewSingleConnPool(c.connPool, cn)\n\tconn := newConn(c.opt, connPool)\n\n\tvar auth bool\n\tprotocol := c.opt.Protocol\n\t// By default, use RESP3 in current version.\n\tif protocol < 2 {\n\t\tprotocol = 3\n\t}\n\n\t// for redis-server versions that do not support the HELLO command,\n\t// RESP2 will continue to be used.\n\tif err = conn.Hello(ctx, protocol, username, password, \"\").Err(); err == nil {\n\t\tauth = true\n\t} else if !isRedisError(err) {\n\t\t// When the server responds with the RESP protocol and the result is not a normal\n\t\t// execution result of the HELLO command, we consider it to be an indication that\n\t\t// the server does not support the HELLO command.\n\t\t// The server may be a redis-server that does not support the HELLO command,\n\t\t// or it could be DragonflyDB or a third-party redis-proxy. They all respond\n\t\t// with different error string results for unsupported commands, making it\n\t\t// difficult to rely on error strings to determine all results.\n\t\treturn err\n\t}\n\n\t_, err = conn.Pipelined(ctx, func(pipe Pipeliner) error {\n\t\tif !auth && password != \"\" {\n\t\t\tif username != \"\" {\n\t\t\t\tpipe.AuthACL(ctx, username, password)\n\t\t\t} else {\n\t\t\t\tpipe.Auth(ctx, password)\n\t\t\t}\n\t\t}\n\n\t\tif c.opt.DB > 0 {\n\t\t\tpipe.Select(ctx, c.opt.DB)\n\t\t}\n\n\t\tif c.opt.readOnly {\n\t\t\tpipe.ReadOnly(ctx)\n\t\t}\n\n\t\tif c.opt.ClientName != \"\" {\n\t\t\tpipe.ClientSetName(ctx, c.opt.ClientName)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !c.opt.DisableIndentity {\n\t\tlibName := \"\"\n\t\tlibVer := Version()\n\t\tif c.opt.IdentitySuffix != \"\" {\n\t\t\tlibName = c.opt.IdentitySuffix\n\t\t}\n\t\tp := conn.Pipeline()\n\t\tp.ClientSetInfo(ctx, WithLibraryName(libName))\n\t\tp.ClientSetInfo(ctx, WithLibraryVersion(libVer))\n\t\t_, _ = p.Exec(ctx)\n\t}\n\n\tif c.opt.OnConnect != nil {\n\t\treturn c.opt.OnConnect(ctx, conn)\n\t}\n\treturn nil\n}\n\nfunc (c *baseClient) releaseConn(ctx context.Context, cn *pool.Conn, err error) {\n\tif c.opt.Limiter != nil {\n\t\tc.opt.Limiter.ReportResult(err)\n\t}\n\n\tif isBadConn(err, false, c.opt.Addr) {\n\t\tc.connPool.Remove(ctx, cn, err)\n\t} else {\n\t\tc.connPool.Put(ctx, cn)\n\t}\n}\n\nfunc (c *baseClient) withConn(\n\tctx context.Context, fn func(context.Context, *pool.Conn) error,\n) error {\n\tcn, err := c.getConn(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar fnErr error\n\tdefer func() {\n\t\tc.releaseConn(ctx, cn, fnErr)\n\t}()\n\n\tfnErr = fn(ctx, cn)\n\n\treturn fnErr\n}\n\nfunc (c *baseClient) dial(ctx context.Context, network, addr string) (net.Conn, error) {\n\treturn c.opt.Dialer(ctx, network, addr)\n}\n\nfunc (c *baseClient) process(ctx context.Context, cmd Cmder) error {\n\tvar lastErr error\n\tfor attempt := 0; attempt <= c.opt.MaxRetries; attempt++ {\n\t\tattempt := attempt\n\n\t\tretry, err := c._process(ctx, cmd, attempt)\n\t\tif err == nil || !retry {\n\t\t\treturn err\n\t\t}\n\n\t\tlastErr = err\n\t}\n\treturn lastErr\n}\n\nfunc (c *baseClient) assertUnstableCommand(cmd Cmder) bool {\n\tswitch cmd.(type) {\n\tcase *AggregateCmd, *FTInfoCmd, *FTSpellCheckCmd, *FTSearchCmd, *FTSynDumpCmd:\n\t\tif c.opt.UnstableResp3 {\n\t\t\treturn true\n\t\t} else {\n\t\t\tpanic(\"RESP3 responses for this command are disabled because they may still change. Please set the flag UnstableResp3 .  See the [README](https://github.com/redis/go-redis/blob/master/README.md) and the release notes for guidance.\")\n\t\t}\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (c *baseClient) _process(ctx context.Context, cmd Cmder, attempt int) (bool, error) {\n\tif attempt > 0 {\n\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n\t\t\treturn false, err\n\t\t}\n\t}\n\n\tretryTimeout := uint32(0)\n\tif err := c.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n\t\tif err := cn.WithWriter(c.context(ctx), c.opt.WriteTimeout, func(wr *proto.Writer) error {\n\t\t\treturn writeCmd(wr, cmd)\n\t\t}); err != nil {\n\t\t\tatomic.StoreUint32(&retryTimeout, 1)\n\t\t\treturn err\n\t\t}\n\t\treadReplyFunc := cmd.readReply\n\t\t// Apply unstable RESP3 search module.\n\t\tif c.opt.Protocol != 2 && c.assertUnstableCommand(cmd) {\n\t\t\treadReplyFunc = cmd.readRawReply\n\t\t}\n\t\tif err := cn.WithReader(c.context(ctx), c.cmdTimeout(cmd), readReplyFunc); err != nil {\n\t\t\tif cmd.readTimeout() == nil {\n\t\t\t\tatomic.StoreUint32(&retryTimeout, 1)\n\t\t\t} else {\n\t\t\t\tatomic.StoreUint32(&retryTimeout, 0)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tretry := shouldRetry(err, atomic.LoadUint32(&retryTimeout) == 1)\n\t\treturn retry, err\n\t}\n\n\treturn false, nil\n}\n\nfunc (c *baseClient) retryBackoff(attempt int) time.Duration {\n\treturn internal.RetryBackoff(attempt, c.opt.MinRetryBackoff, c.opt.MaxRetryBackoff)\n}\n\nfunc (c *baseClient) cmdTimeout(cmd Cmder) time.Duration {\n\tif timeout := cmd.readTimeout(); timeout != nil {\n\t\tt := *timeout\n\t\tif t == 0 {\n\t\t\treturn 0\n\t\t}\n\t\treturn t + 10*time.Second\n\t}\n\treturn c.opt.ReadTimeout\n}\n\n// Close closes the client, releasing any open resources.\n//\n// It is rare to Close a Client, as the Client is meant to be\n// long-lived and shared between many goroutines.\nfunc (c *baseClient) Close() error {\n\tvar firstErr error\n\tif c.onClose != nil {\n\t\tif err := c.onClose(); err != nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\tif err := c.connPool.Close(); err != nil && firstErr == nil {\n\t\tfirstErr = err\n\t}\n\treturn firstErr\n}\n\nfunc (c *baseClient) getAddr() string {\n\treturn c.opt.Addr\n}\n\nfunc (c *baseClient) processPipeline(ctx context.Context, cmds []Cmder) error {\n\tif err := c.generalProcessPipeline(ctx, cmds, c.pipelineProcessCmds); err != nil {\n\t\treturn err\n\t}\n\treturn cmdsFirstErr(cmds)\n}\n\nfunc (c *baseClient) processTxPipeline(ctx context.Context, cmds []Cmder) error {\n\tif err := c.generalProcessPipeline(ctx, cmds, c.txPipelineProcessCmds); err != nil {\n\t\treturn err\n\t}\n\treturn cmdsFirstErr(cmds)\n}\n\ntype pipelineProcessor func(context.Context, *pool.Conn, []Cmder) (bool, error)\n\nfunc (c *baseClient) generalProcessPipeline(\n\tctx context.Context, cmds []Cmder, p pipelineProcessor,\n) error {\n\tvar lastErr error\n\tfor attempt := 0; attempt <= c.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n\t\t\t\tsetCmdsErr(cmds, err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\t// Enable retries by default to retry dial errors returned by withConn.\n\t\tcanRetry := true\n\t\tlastErr = c.withConn(ctx, func(ctx context.Context, cn *pool.Conn) error {\n\t\t\tvar err error\n\t\t\tcanRetry, err = p(ctx, cn, cmds)\n\t\t\treturn err\n\t\t})\n\t\tif lastErr == nil || !canRetry || !shouldRetry(lastErr, true) {\n\t\t\treturn lastErr\n\t\t}\n\t}\n\treturn lastErr\n}\n\nfunc (c *baseClient) pipelineProcessCmds(\n\tctx context.Context, cn *pool.Conn, cmds []Cmder,\n) (bool, error) {\n\tif err := cn.WithWriter(c.context(ctx), c.opt.WriteTimeout, func(wr *proto.Writer) error {\n\t\treturn writeCmds(wr, cmds)\n\t}); err != nil {\n\t\tsetCmdsErr(cmds, err)\n\t\treturn true, err\n\t}\n\n\tif err := cn.WithReader(c.context(ctx), c.opt.ReadTimeout, func(rd *proto.Reader) error {\n\t\treturn pipelineReadCmds(rd, cmds)\n\t}); err != nil {\n\t\treturn true, err\n\t}\n\n\treturn false, nil\n}\n\nfunc pipelineReadCmds(rd *proto.Reader, cmds []Cmder) error {\n\tfor i, cmd := range cmds {\n\t\terr := cmd.readReply(rd)\n\t\tcmd.SetErr(err)\n\t\tif err != nil && !isRedisError(err) {\n\t\t\tsetCmdsErr(cmds[i+1:], err)\n\t\t\treturn err\n\t\t}\n\t}\n\t// Retry errors like \"LOADING redis is loading the dataset in memory\".\n\treturn cmds[0].Err()\n}\n\nfunc (c *baseClient) txPipelineProcessCmds(\n\tctx context.Context, cn *pool.Conn, cmds []Cmder,\n) (bool, error) {\n\tif err := cn.WithWriter(c.context(ctx), c.opt.WriteTimeout, func(wr *proto.Writer) error {\n\t\treturn writeCmds(wr, cmds)\n\t}); err != nil {\n\t\tsetCmdsErr(cmds, err)\n\t\treturn true, err\n\t}\n\n\tif err := cn.WithReader(c.context(ctx), c.opt.ReadTimeout, func(rd *proto.Reader) error {\n\t\tstatusCmd := cmds[0].(*StatusCmd)\n\t\t// Trim multi and exec.\n\t\ttrimmedCmds := cmds[1 : len(cmds)-1]\n\n\t\tif err := txPipelineReadQueued(rd, statusCmd, trimmedCmds); err != nil {\n\t\t\tsetCmdsErr(cmds, err)\n\t\t\treturn err\n\t\t}\n\n\t\treturn pipelineReadCmds(rd, trimmedCmds)\n\t}); err != nil {\n\t\treturn false, err\n\t}\n\n\treturn false, nil\n}\n\nfunc txPipelineReadQueued(rd *proto.Reader, statusCmd *StatusCmd, cmds []Cmder) error {\n\t// Parse +OK.\n\tif err := statusCmd.readReply(rd); err != nil {\n\t\treturn err\n\t}\n\n\t// Parse +QUEUED.\n\tfor range cmds {\n\t\tif err := statusCmd.readReply(rd); err != nil && !isRedisError(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Parse number of replies.\n\tline, err := rd.ReadLine()\n\tif err != nil {\n\t\tif err == Nil {\n\t\t\terr = TxFailedErr\n\t\t}\n\t\treturn err\n\t}\n\n\tif line[0] != proto.RespArray {\n\t\treturn fmt.Errorf(\"redis: expected '*', but got line %q\", line)\n\t}\n\n\treturn nil\n}\n\nfunc (c *baseClient) context(ctx context.Context) context.Context {\n\tif c.opt.ContextTimeoutEnabled {\n\t\treturn ctx\n\t}\n\treturn context.Background()\n}\n\n//------------------------------------------------------------------------------\n\n// Client is a Redis client representing a pool of zero or more underlying connections.\n// It's safe for concurrent use by multiple goroutines.\n//\n// Client creates and frees connections automatically; it also maintains a free pool\n// of idle connections. You can control the pool size with Config.PoolSize option.\ntype Client struct {\n\t*baseClient\n\tcmdable\n\thooksMixin\n}\n\n// NewClient returns a client to the Redis Server specified by Options.\nfunc NewClient(opt *Options) *Client {\n\topt.init()\n\n\tc := Client{\n\t\tbaseClient: &baseClient{\n\t\t\topt: opt,\n\t\t},\n\t}\n\tc.init()\n\tc.connPool = newConnPool(opt, c.dialHook)\n\n\treturn &c\n}\n\nfunc (c *Client) init() {\n\tc.cmdable = c.Process\n\tc.initHooks(hooks{\n\t\tdial:       c.baseClient.dial,\n\t\tprocess:    c.baseClient.process,\n\t\tpipeline:   c.baseClient.processPipeline,\n\t\ttxPipeline: c.baseClient.processTxPipeline,\n\t})\n}\n\nfunc (c *Client) WithTimeout(timeout time.Duration) *Client {\n\tclone := *c\n\tclone.baseClient = c.baseClient.withTimeout(timeout)\n\tclone.init()\n\treturn &clone\n}\n\nfunc (c *Client) Conn() *Conn {\n\treturn newConn(c.opt, pool.NewStickyConnPool(c.connPool))\n}\n\n// Do create a Cmd from the args and processes the cmd.\nfunc (c *Client) Do(ctx context.Context, args ...interface{}) *Cmd {\n\tcmd := NewCmd(ctx, args...)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c *Client) Process(ctx context.Context, cmd Cmder) error {\n\terr := c.processHook(ctx, cmd)\n\tcmd.SetErr(err)\n\treturn err\n}\n\n// Options returns read-only Options that were used to create the client.\nfunc (c *Client) Options() *Options {\n\treturn c.opt\n}\n\ntype PoolStats pool.Stats\n\n// PoolStats returns connection pool stats.\nfunc (c *Client) PoolStats() *PoolStats {\n\tstats := c.connPool.Stats()\n\treturn (*PoolStats)(stats)\n}\n\nfunc (c *Client) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.Pipeline().Pipelined(ctx, fn)\n}\n\nfunc (c *Client) Pipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: pipelineExecer(c.processPipelineHook),\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc (c *Client) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.TxPipeline().Pipelined(ctx, fn)\n}\n\n// TxPipeline acts like Pipeline, but wraps queued commands with MULTI/EXEC.\nfunc (c *Client) TxPipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: func(ctx context.Context, cmds []Cmder) error {\n\t\t\tcmds = wrapMultiExec(ctx, cmds)\n\t\t\treturn c.processTxPipelineHook(ctx, cmds)\n\t\t},\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc (c *Client) pubSub() *PubSub {\n\tpubsub := &PubSub{\n\t\topt: c.opt,\n\n\t\tnewConn: func(ctx context.Context, channels []string) (*pool.Conn, error) {\n\t\t\treturn c.newConn(ctx)\n\t\t},\n\t\tcloseConn: c.connPool.CloseConn,\n\t}\n\tpubsub.init()\n\treturn pubsub\n}\n\n// Subscribe subscribes the client to the specified channels.\n// Channels can be omitted to create empty subscription.\n// Note that this method does not wait on a response from Redis, so the\n// subscription may not be active immediately. To force the connection to wait,\n// you may call the Receive() method on the returned *PubSub like so:\n//\n//\tsub := client.Subscribe(queryResp)\n//\tiface, err := sub.Receive()\n//\tif err != nil {\n//\t    // handle error\n//\t}\n//\n//\t// Should be *Subscription, but others are possible if other actions have been\n//\t// taken on sub since it was created.\n//\tswitch iface.(type) {\n//\tcase *Subscription:\n//\t    // subscribe succeeded\n//\tcase *Message:\n//\t    // received first message\n//\tcase *Pong:\n//\t    // pong received\n//\tdefault:\n//\t    // handle error\n//\t}\n//\n//\tch := sub.Channel()\nfunc (c *Client) Subscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.Subscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\n// PSubscribe subscribes the client to the given patterns.\n// Patterns can be omitted to create empty subscription.\nfunc (c *Client) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.PSubscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\n// SSubscribe Subscribes the client to the specified shard channels.\n// Channels can be omitted to create empty subscription.\nfunc (c *Client) SSubscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.SSubscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\n//------------------------------------------------------------------------------\n\n// Conn represents a single Redis connection rather than a pool of connections.\n// Prefer running commands from Client unless there is a specific need\n// for a continuous single Redis connection.\ntype Conn struct {\n\tbaseClient\n\tcmdable\n\tstatefulCmdable\n\thooksMixin\n}\n\nfunc newConn(opt *Options, connPool pool.Pooler) *Conn {\n\tc := Conn{\n\t\tbaseClient: baseClient{\n\t\t\topt:      opt,\n\t\t\tconnPool: connPool,\n\t\t},\n\t}\n\n\tc.cmdable = c.Process\n\tc.statefulCmdable = c.Process\n\tc.initHooks(hooks{\n\t\tdial:       c.baseClient.dial,\n\t\tprocess:    c.baseClient.process,\n\t\tpipeline:   c.baseClient.processPipeline,\n\t\ttxPipeline: c.baseClient.processTxPipeline,\n\t})\n\n\treturn &c\n}\n\nfunc (c *Conn) Process(ctx context.Context, cmd Cmder) error {\n\terr := c.processHook(ctx, cmd)\n\tcmd.SetErr(err)\n\treturn err\n}\n\nfunc (c *Conn) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.Pipeline().Pipelined(ctx, fn)\n}\n\nfunc (c *Conn) Pipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: c.processPipelineHook,\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc (c *Conn) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.TxPipeline().Pipelined(ctx, fn)\n}\n\n// TxPipeline acts like Pipeline, but wraps queued commands with MULTI/EXEC.\nfunc (c *Conn) TxPipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: func(ctx context.Context, cmds []Cmder) error {\n\t\t\tcmds = wrapMultiExec(ctx, cmds)\n\t\t\treturn c.processTxPipelineHook(ctx, cmds)\n\t\t},\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n"
        },
        {
          "name": "redis_test.go",
          "type": "blob",
          "size": 16.8916015625,
          "content": "package redis_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\ntype redisHookError struct{}\n\nvar _ redis.Hook = redisHookError{}\n\nfunc (redisHookError) DialHook(hook redis.DialHook) redis.DialHook {\n\treturn hook\n}\n\nfunc (redisHookError) ProcessHook(hook redis.ProcessHook) redis.ProcessHook {\n\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\treturn errors.New(\"hook error\")\n\t}\n}\n\nfunc (redisHookError) ProcessPipelineHook(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\treturn hook\n}\n\nfunc TestHookError(t *testing.T) {\n\trdb := redis.NewClient(&redis.Options{\n\t\tAddr: \":6379\",\n\t})\n\trdb.AddHook(redisHookError{})\n\n\terr := rdb.Ping(ctx).Err()\n\tif err == nil {\n\t\tt.Fatalf(\"got nil, expected an error\")\n\t}\n\n\twanted := \"hook error\"\n\tif err.Error() != wanted {\n\t\tt.Fatalf(`got %q, wanted %q`, err, wanted)\n\t}\n}\n\n//------------------------------------------------------------------------------\n\nvar _ = Describe(\"Client\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tclient.Close()\n\t})\n\n\tIt(\"should Stringer\", func() {\n\t\tif RECluster {\n\t\t\tExpect(client.String()).To(Equal(fmt.Sprintf(\"Redis<:%s db:0>\", redisPort)))\n\t\t} else {\n\t\t\tExpect(client.String()).To(Equal(fmt.Sprintf(\"Redis<:%s db:15>\", redisPort)))\n\t\t}\n\t})\n\n\tIt(\"supports context\", func() {\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\tcancel()\n\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).To(MatchError(\"context canceled\"))\n\t})\n\n\tIt(\"supports WithTimeout\", Label(\"NonRedisEnterprise\"), func() {\n\t\terr := client.ClientPause(ctx, time.Second).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\terr = client.WithTimeout(10 * time.Millisecond).Ping(ctx).Err()\n\t\tExpect(err).To(HaveOccurred())\n\n\t\terr = client.Ping(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should ping\", func() {\n\t\tval, err := client.Ping(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(\"PONG\"))\n\t})\n\n\tIt(\"should return pool stats\", func() {\n\t\tExpect(client.PoolStats()).To(BeAssignableToTypeOf(&redis.PoolStats{}))\n\t})\n\n\tIt(\"should support custom dialers\", func() {\n\t\tcustom := redis.NewClient(&redis.Options{\n\t\t\tNetwork: \"tcp\",\n\t\t\tAddr:    redisAddr,\n\t\t\tDialer: func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\t\tvar d net.Dialer\n\t\t\t\treturn d.DialContext(ctx, network, addr)\n\t\t\t},\n\t\t})\n\n\t\tval, err := custom.Ping(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(\"PONG\"))\n\t\tExpect(custom.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should close\", func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).To(MatchError(\"redis: client is closed\"))\n\t})\n\n\tIt(\"should close pubsub without closing the client\", func() {\n\t\tpubsub := client.Subscribe(ctx)\n\t\tExpect(pubsub.Close()).NotTo(HaveOccurred())\n\n\t\t_, err := pubsub.Receive(ctx)\n\t\tExpect(err).To(MatchError(\"redis: client is closed\"))\n\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should close Tx without closing the client\", func() {\n\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t_, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\treturn err\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should close pubsub when client is closed\", func() {\n\t\tpubsub := client.Subscribe(ctx)\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\n\t\t_, err := pubsub.Receive(ctx)\n\t\tExpect(err).To(MatchError(\"redis: client is closed\"))\n\n\t\tExpect(pubsub.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should select DB\", Label(\"NonRedisEnterprise\"), func() {\n\t\tdb2 := redis.NewClient(&redis.Options{\n\t\t\tAddr: redisAddr,\n\t\t\tDB:   2,\n\t\t})\n\t\tExpect(db2.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t\tExpect(db2.Get(ctx, \"db\").Err()).To(Equal(redis.Nil))\n\t\tExpect(db2.Set(ctx, \"db\", 2, 0).Err()).NotTo(HaveOccurred())\n\n\t\tn, err := db2.Get(ctx, \"db\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(2)))\n\n\t\tExpect(client.Get(ctx, \"db\").Err()).To(Equal(redis.Nil))\n\n\t\tExpect(db2.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t\tExpect(db2.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should client setname\", func() {\n\t\topt := redisOptions()\n\t\topt.ClientName = \"hi\"\n\t\tdb := redis.NewClient(opt)\n\n\t\tdefer func() {\n\t\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t\t}()\n\n\t\tExpect(db.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t\tval, err := db.ClientList(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).Should(ContainSubstring(\"name=hi\"))\n\t})\n\n\tIt(\"should client PROTO 2\", func() {\n\t\topt := redisOptions()\n\t\topt.Protocol = 2\n\t\tdb := redis.NewClient(opt)\n\n\t\tdefer func() {\n\t\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t\t}()\n\n\t\tval, err := db.Do(ctx, \"HELLO\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).Should(ContainElements(\"proto\", int64(2)))\n\t})\n\n\tIt(\"should client PROTO 3\", func() {\n\t\topt := redisOptions()\n\t\tdb := redis.NewClient(opt)\n\n\t\tdefer func() {\n\t\t\tExpect(db.Close()).NotTo(HaveOccurred())\n\t\t}()\n\n\t\tval, err := db.Do(ctx, \"HELLO\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).Should(HaveKeyWithValue(\"proto\", int64(3)))\n\t})\n\n\tIt(\"processes custom commands\", func() {\n\t\tcmd := redis.NewCmd(ctx, \"PING\")\n\t\t_ = client.Process(ctx, cmd)\n\n\t\t// Flush buffers.\n\t\tExpect(client.Echo(ctx, \"hello\").Err()).NotTo(HaveOccurred())\n\n\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\tExpect(cmd.Val()).To(Equal(\"PONG\"))\n\t})\n\n\tIt(\"should retry command on network error\", func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\n\t\tclient = redis.NewClient(&redis.Options{\n\t\t\tAddr:       redisAddr,\n\t\t\tMaxRetries: 1,\n\t\t})\n\n\t\t// Put bad connection in the pool.\n\t\tcn, err := client.Pool().Get(ctx)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tcn.SetNetConn(&badConn{})\n\t\tclient.Pool().Put(ctx, cn)\n\n\t\terr = client.Ping(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should retry with backoff\", func() {\n\t\tclientNoRetry := redis.NewClient(&redis.Options{\n\t\t\tAddr:       \":1234\",\n\t\t\tMaxRetries: -1,\n\t\t})\n\t\tdefer clientNoRetry.Close()\n\n\t\tclientRetry := redis.NewClient(&redis.Options{\n\t\t\tAddr:            \":1234\",\n\t\t\tMaxRetries:      5,\n\t\t\tMaxRetryBackoff: 128 * time.Millisecond,\n\t\t})\n\t\tdefer clientRetry.Close()\n\n\t\tstartNoRetry := time.Now()\n\t\terr := clientNoRetry.Ping(ctx).Err()\n\t\tExpect(err).To(HaveOccurred())\n\t\telapseNoRetry := time.Since(startNoRetry)\n\n\t\tstartRetry := time.Now()\n\t\terr = clientRetry.Ping(ctx).Err()\n\t\tExpect(err).To(HaveOccurred())\n\t\telapseRetry := time.Since(startRetry)\n\n\t\tExpect(elapseRetry).To(BeNumerically(\">\", elapseNoRetry, 10*time.Millisecond))\n\t})\n\n\tIt(\"should update conn.UsedAt on read/write\", func() {\n\t\tcn, err := client.Pool().Get(context.Background())\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(cn.UsedAt).NotTo(BeZero())\n\n\t\t// set cn.SetUsedAt(time) or time.Sleep(>1*time.Second)\n\t\t// simulate the last time Conn was used\n\t\t// time.Sleep() is not the standard sleep time\n\t\t// link: https://go-review.googlesource.com/c/go/+/232298\n\t\tcn.SetUsedAt(time.Now().Add(-1 * time.Second))\n\t\tcreatedAt := cn.UsedAt()\n\n\t\tclient.Pool().Put(ctx, cn)\n\t\tExpect(cn.UsedAt().Equal(createdAt)).To(BeTrue())\n\n\t\terr = client.Ping(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tcn, err = client.Pool().Get(context.Background())\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(cn).NotTo(BeNil())\n\t\tExpect(cn.UsedAt().After(createdAt)).To(BeTrue())\n\t})\n\n\tIt(\"should process command with special chars\", func() {\n\t\tset := client.Set(ctx, \"key\", \"hello1\\r\\nhello2\\r\\n\", 0)\n\t\tExpect(set.Err()).NotTo(HaveOccurred())\n\t\tExpect(set.Val()).To(Equal(\"OK\"))\n\n\t\tget := client.Get(ctx, \"key\")\n\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\tExpect(get.Val()).To(Equal(\"hello1\\r\\nhello2\\r\\n\"))\n\t})\n\n\tIt(\"should handle big vals\", func() {\n\t\tbigVal := bytes.Repeat([]byte{'*'}, 2e6)\n\n\t\terr := client.Set(ctx, \"key\", bigVal, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t// Reconnect to get new connection.\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t\tclient = redis.NewClient(redisOptions())\n\n\t\tgot, err := client.Get(ctx, \"key\").Bytes()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(got).To(Equal(bigVal))\n\t})\n\n\tIt(\"should set and scan time\", func() {\n\t\ttm := time.Now()\n\t\terr := client.Set(ctx, \"now\", tm, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tvar tm2 time.Time\n\t\terr = client.Get(ctx, \"now\").Scan(&tm2)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(tm2).To(BeTemporally(\"==\", tm))\n\t})\n\n\tIt(\"should set and scan durations\", func() {\n\t\tduration := 10 * time.Minute\n\t\terr := client.Set(ctx, \"duration\", duration, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tvar duration2 time.Duration\n\t\terr = client.Get(ctx, \"duration\").Scan(&duration2)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(duration2).To(Equal(duration))\n\t})\n\n\tIt(\"should Conn\", func() {\n\t\terr := client.Conn().Get(ctx, \"this-key-does-not-exist\").Err()\n\t\tExpect(err).To(Equal(redis.Nil))\n\t})\n\n\tIt(\"should set and scan net.IP\", func() {\n\t\tip := net.ParseIP(\"192.168.1.1\")\n\t\terr := client.Set(ctx, \"ip\", ip, 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tvar ip2 net.IP\n\t\terr = client.Get(ctx, \"ip\").Scan(&ip2)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(ip2).To(Equal(ip))\n\t})\n})\n\nvar _ = Describe(\"Client timeout\", func() {\n\tvar opt *redis.Options\n\tvar client *redis.Client\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\ttestTimeout := func() {\n\t\tIt(\"Ping timeouts\", func() {\n\t\t\terr := client.Ping(ctx).Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Pipeline timeouts\", func() {\n\t\t\t_, err := client.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Subscribe timeouts\", func() {\n\t\t\tif opt.WriteTimeout == 0 {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tpubsub := client.Subscribe(ctx)\n\t\t\tdefer pubsub.Close()\n\n\t\t\terr := pubsub.Subscribe(ctx, \"_\")\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Tx timeouts\", func() {\n\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\treturn tx.Ping(ctx).Err()\n\t\t\t})\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Tx Pipeline timeouts\", func() {\n\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\t_, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tpipe.Ping(ctx)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\treturn err\n\t\t\t})\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\t}\n\n\tContext(\"read timeout\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt = redisOptions()\n\t\t\topt.ReadTimeout = time.Nanosecond\n\t\t\topt.WriteTimeout = -1\n\t\t\tclient = redis.NewClient(opt)\n\t\t})\n\n\t\ttestTimeout()\n\t})\n\n\tContext(\"write timeout\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt = redisOptions()\n\t\t\topt.ReadTimeout = -1\n\t\t\topt.WriteTimeout = time.Nanosecond\n\t\t\tclient = redis.NewClient(opt)\n\t\t})\n\n\t\ttestTimeout()\n\t})\n})\n\nvar _ = Describe(\"Client OnConnect\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\topt := redisOptions()\n\t\topt.DB = 0\n\t\topt.OnConnect = func(ctx context.Context, cn *redis.Conn) error {\n\t\t\treturn cn.ClientSetName(ctx, \"on_connect\").Err()\n\t\t}\n\n\t\tclient = redis.NewClient(opt)\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"calls OnConnect\", func() {\n\t\tname, err := client.ClientGetName(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(name).To(Equal(\"on_connect\"))\n\t})\n})\n\nvar _ = Describe(\"Client context cancellation\", func() {\n\tvar opt *redis.Options\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\topt = redisOptions()\n\t\topt.ReadTimeout = -1\n\t\topt.WriteTimeout = -1\n\t\tclient = redis.NewClient(opt)\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"Blocking operation cancellation\", func() {\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\tcancel()\n\n\t\terr := client.BLPop(ctx, 1*time.Second, \"test\").Err()\n\t\tExpect(err).To(HaveOccurred())\n\t\tExpect(err).To(BeIdenticalTo(context.Canceled))\n\t})\n})\n\nvar _ = Describe(\"Conn\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\terr := client.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"TxPipeline\", Label(\"NonRedisEnterprise\"), func() {\n\t\ttx := client.Conn().TxPipeline()\n\t\ttx.SwapDB(ctx, 0, 2)\n\t\ttx.SwapDB(ctx, 1, 0)\n\t\t_, err := tx.Exec(ctx)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n})\n\nvar _ = Describe(\"Hook\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\terr := client.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"fifo\", func() {\n\t\tvar res []string\n\t\tclient.AddHook(&hook{\n\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\tres = append(res, \"hook-1-process-start\")\n\t\t\t\t\terr := hook(ctx, cmd)\n\t\t\t\t\tres = append(res, \"hook-1-process-end\")\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\t\tclient.AddHook(&hook{\n\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\tres = append(res, \"hook-2-process-start\")\n\t\t\t\t\terr := hook(ctx, cmd)\n\t\t\t\t\tres = append(res, \"hook-2-process-end\")\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(res).To(Equal([]string{\n\t\t\t\"hook-1-process-start\",\n\t\t\t\"hook-2-process-start\",\n\t\t\t\"hook-2-process-end\",\n\t\t\t\"hook-1-process-end\",\n\t\t}))\n\t})\n\n\tIt(\"wrapped error in a hook\", func() {\n\t\tclient.AddHook(&hook{\n\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\tif err := hook(ctx, cmd); err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"wrapped error: %w\", err)\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\t\tclient.ScriptFlush(ctx)\n\n\t\tscript := redis.NewScript(`return 'Script and hook'`)\n\n\t\tcmd := script.Run(ctx, client, nil)\n\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\tExpect(cmd.Val()).To(Equal(\"Script and hook\"))\n\t})\n})\n\nvar _ = Describe(\"Hook with MinIdleConns\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\toptions := redisOptions()\n\t\toptions.MinIdleConns = 1\n\t\tclient = redis.NewClient(options)\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\terr := client.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"fifo\", func() {\n\t\tvar res []string\n\t\tclient.AddHook(&hook{\n\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\tres = append(res, \"hook-1-process-start\")\n\t\t\t\t\terr := hook(ctx, cmd)\n\t\t\t\t\tres = append(res, \"hook-1-process-end\")\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\t\tclient.AddHook(&hook{\n\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\tres = append(res, \"hook-2-process-start\")\n\t\t\t\t\terr := hook(ctx, cmd)\n\t\t\t\t\tres = append(res, \"hook-2-process-end\")\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t},\n\t\t})\n\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(res).To(Equal([]string{\n\t\t\t\"hook-1-process-start\",\n\t\t\t\"hook-2-process-start\",\n\t\t\t\"hook-2-process-end\",\n\t\t\t\"hook-1-process-end\",\n\t\t}))\n\t})\n})\n\nvar _ = Describe(\"Dialer connection timeouts\", func() {\n\tvar client *redis.Client\n\n\tconst dialSimulatedDelay = 1 * time.Second\n\n\tBeforeEach(func() {\n\t\toptions := redisOptions()\n\t\toptions.Dialer = func(ctx context.Context, network, addr string) (net.Conn, error) {\n\t\t\t// Simulated slow dialer.\n\t\t\t// Note that the following sleep is deliberately not context-aware.\n\t\t\ttime.Sleep(dialSimulatedDelay)\n\t\t\treturn net.Dial(\"tcp\", options.Addr)\n\t\t}\n\t\toptions.MinIdleConns = 1\n\t\tclient = redis.NewClient(options)\n\t})\n\n\tAfterEach(func() {\n\t\terr := client.Close()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"does not contend on connection dial for concurrent commands\", func() {\n\t\tvar wg sync.WaitGroup\n\n\t\tconst concurrency = 10\n\n\t\tdurations := make(chan time.Duration, concurrency)\n\t\terrs := make(chan error, concurrency)\n\n\t\tstart := time.Now()\n\t\twg.Add(concurrency)\n\n\t\tfor i := 0; i < concurrency; i++ {\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\tstart := time.Now()\n\t\t\t\terr := client.Ping(ctx).Err()\n\t\t\t\tdurations <- time.Since(start)\n\t\t\t\terrs <- err\n\t\t\t}()\n\t\t}\n\n\t\twg.Wait()\n\t\tclose(durations)\n\t\tclose(errs)\n\n\t\t// All commands should eventually succeed, after acquiring a connection.\n\t\tfor err := range errs {\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\t// Each individual command should complete within the simulated dial duration bound.\n\t\tfor duration := range durations {\n\t\t\tExpect(duration).To(BeNumerically(\"<\", 2*dialSimulatedDelay))\n\t\t}\n\n\t\t// Due to concurrent execution, the entire test suite should also complete within\n\t\t// the same dial duration bound applied for individual commands.\n\t\tExpect(time.Since(start)).To(BeNumerically(\"<\", 2*dialSimulatedDelay))\n\t})\n})\n"
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 5.0400390625,
          "content": "package redis\n\nimport \"time\"\n\n// NewCmdResult returns a Cmd initialised with val and err for testing.\nfunc NewCmdResult(val interface{}, err error) *Cmd {\n\tvar cmd Cmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewSliceResult returns a SliceCmd initialised with val and err for testing.\nfunc NewSliceResult(val []interface{}, err error) *SliceCmd {\n\tvar cmd SliceCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewStatusResult returns a StatusCmd initialised with val and err for testing.\nfunc NewStatusResult(val string, err error) *StatusCmd {\n\tvar cmd StatusCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewIntResult returns an IntCmd initialised with val and err for testing.\nfunc NewIntResult(val int64, err error) *IntCmd {\n\tvar cmd IntCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewDurationResult returns a DurationCmd initialised with val and err for testing.\nfunc NewDurationResult(val time.Duration, err error) *DurationCmd {\n\tvar cmd DurationCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewBoolResult returns a BoolCmd initialised with val and err for testing.\nfunc NewBoolResult(val bool, err error) *BoolCmd {\n\tvar cmd BoolCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewStringResult returns a StringCmd initialised with val and err for testing.\nfunc NewStringResult(val string, err error) *StringCmd {\n\tvar cmd StringCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewFloatResult returns a FloatCmd initialised with val and err for testing.\nfunc NewFloatResult(val float64, err error) *FloatCmd {\n\tvar cmd FloatCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewStringSliceResult returns a StringSliceCmd initialised with val and err for testing.\nfunc NewStringSliceResult(val []string, err error) *StringSliceCmd {\n\tvar cmd StringSliceCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewBoolSliceResult returns a BoolSliceCmd initialised with val and err for testing.\nfunc NewBoolSliceResult(val []bool, err error) *BoolSliceCmd {\n\tvar cmd BoolSliceCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewMapStringStringResult returns a MapStringStringCmd initialised with val and err for testing.\nfunc NewMapStringStringResult(val map[string]string, err error) *MapStringStringCmd {\n\tvar cmd MapStringStringCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewMapStringIntCmdResult returns a MapStringIntCmd initialised with val and err for testing.\nfunc NewMapStringIntCmdResult(val map[string]int64, err error) *MapStringIntCmd {\n\tvar cmd MapStringIntCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewTimeCmdResult returns a TimeCmd initialised with val and err for testing.\nfunc NewTimeCmdResult(val time.Time, err error) *TimeCmd {\n\tvar cmd TimeCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewZSliceCmdResult returns a ZSliceCmd initialised with val and err for testing.\nfunc NewZSliceCmdResult(val []Z, err error) *ZSliceCmd {\n\tvar cmd ZSliceCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewZWithKeyCmdResult returns a ZWithKeyCmd initialised with val and err for testing.\nfunc NewZWithKeyCmdResult(val *ZWithKey, err error) *ZWithKeyCmd {\n\tvar cmd ZWithKeyCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewScanCmdResult returns a ScanCmd initialised with val and err for testing.\nfunc NewScanCmdResult(keys []string, cursor uint64, err error) *ScanCmd {\n\tvar cmd ScanCmd\n\tcmd.page = keys\n\tcmd.cursor = cursor\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewClusterSlotsCmdResult returns a ClusterSlotsCmd initialised with val and err for testing.\nfunc NewClusterSlotsCmdResult(val []ClusterSlot, err error) *ClusterSlotsCmd {\n\tvar cmd ClusterSlotsCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewGeoLocationCmdResult returns a GeoLocationCmd initialised with val and err for testing.\nfunc NewGeoLocationCmdResult(val []GeoLocation, err error) *GeoLocationCmd {\n\tvar cmd GeoLocationCmd\n\tcmd.locations = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewGeoPosCmdResult returns a GeoPosCmd initialised with val and err for testing.\nfunc NewGeoPosCmdResult(val []*GeoPos, err error) *GeoPosCmd {\n\tvar cmd GeoPosCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewCommandsInfoCmdResult returns a CommandsInfoCmd initialised with val and err for testing.\nfunc NewCommandsInfoCmdResult(val map[string]*CommandInfo, err error) *CommandsInfoCmd {\n\tvar cmd CommandsInfoCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewXMessageSliceCmdResult returns a XMessageSliceCmd initialised with val and err for testing.\nfunc NewXMessageSliceCmdResult(val []XMessage, err error) *XMessageSliceCmd {\n\tvar cmd XMessageSliceCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewXStreamSliceCmdResult returns a XStreamSliceCmd initialised with val and err for testing.\nfunc NewXStreamSliceCmdResult(val []XStream, err error) *XStreamSliceCmd {\n\tvar cmd XStreamSliceCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n\n// NewXPendingResult returns a XPendingCmd initialised with val and err for testing.\nfunc NewXPendingResult(val *XPending, err error) *XPendingCmd {\n\tvar cmd XPendingCmd\n\tcmd.val = val\n\tcmd.SetErr(err)\n\treturn &cmd\n}\n"
        },
        {
          "name": "ring.go",
          "type": "blob",
          "size": 18.123046875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/cespare/xxhash/v2\"\n\t\"github.com/dgryski/go-rendezvous\" //nolint\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/hashtag\"\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/rand\"\n)\n\nvar errRingShardsDown = errors.New(\"redis: all ring shards are down\")\n\n//------------------------------------------------------------------------------\n\ntype ConsistentHash interface {\n\tGet(string) string\n}\n\ntype rendezvousWrapper struct {\n\t*rendezvous.Rendezvous\n}\n\nfunc (w rendezvousWrapper) Get(key string) string {\n\treturn w.Lookup(key)\n}\n\nfunc newRendezvous(shards []string) ConsistentHash {\n\treturn rendezvousWrapper{rendezvous.New(shards, xxhash.Sum64String)}\n}\n\n//------------------------------------------------------------------------------\n\n// RingOptions are used to configure a ring client and should be\n// passed to NewRing.\ntype RingOptions struct {\n\t// Map of name => host:port addresses of ring shards.\n\tAddrs map[string]string\n\n\t// NewClient creates a shard client with provided options.\n\tNewClient func(opt *Options) *Client\n\n\t// ClientName will execute the `CLIENT SETNAME ClientName` command for each conn.\n\tClientName string\n\n\t// Frequency of PING commands sent to check shards availability.\n\t// Shard is considered down after 3 subsequent failed checks.\n\tHeartbeatFrequency time.Duration\n\n\t// NewConsistentHash returns a consistent hash that is used\n\t// to distribute keys across the shards.\n\t//\n\t// See https://medium.com/@dgryski/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8\n\t// for consistent hashing algorithmic tradeoffs.\n\tNewConsistentHash func(shards []string) ConsistentHash\n\n\t// Following options are copied from Options struct.\n\n\tDialer    func(ctx context.Context, network, addr string) (net.Conn, error)\n\tOnConnect func(ctx context.Context, cn *Conn) error\n\n\tProtocol int\n\tUsername string\n\tPassword string\n\tDB       int\n\n\tMaxRetries      int\n\tMinRetryBackoff time.Duration\n\tMaxRetryBackoff time.Duration\n\n\tDialTimeout           time.Duration\n\tReadTimeout           time.Duration\n\tWriteTimeout          time.Duration\n\tContextTimeoutEnabled bool\n\n\t// PoolFIFO uses FIFO mode for each node connection pool GET/PUT (default LIFO).\n\tPoolFIFO bool\n\n\tPoolSize        int\n\tPoolTimeout     time.Duration\n\tMinIdleConns    int\n\tMaxIdleConns    int\n\tMaxActiveConns  int\n\tConnMaxIdleTime time.Duration\n\tConnMaxLifetime time.Duration\n\n\tTLSConfig *tls.Config\n\tLimiter   Limiter\n\n\tDisableIndentity bool\n\tIdentitySuffix   string\n\tUnstableResp3    bool\n}\n\nfunc (opt *RingOptions) init() {\n\tif opt.NewClient == nil {\n\t\topt.NewClient = func(opt *Options) *Client {\n\t\t\treturn NewClient(opt)\n\t\t}\n\t}\n\n\tif opt.HeartbeatFrequency == 0 {\n\t\topt.HeartbeatFrequency = 500 * time.Millisecond\n\t}\n\n\tif opt.NewConsistentHash == nil {\n\t\topt.NewConsistentHash = newRendezvous\n\t}\n\n\tif opt.MaxRetries == -1 {\n\t\topt.MaxRetries = 0\n\t} else if opt.MaxRetries == 0 {\n\t\topt.MaxRetries = 3\n\t}\n\tswitch opt.MinRetryBackoff {\n\tcase -1:\n\t\topt.MinRetryBackoff = 0\n\tcase 0:\n\t\topt.MinRetryBackoff = 8 * time.Millisecond\n\t}\n\tswitch opt.MaxRetryBackoff {\n\tcase -1:\n\t\topt.MaxRetryBackoff = 0\n\tcase 0:\n\t\topt.MaxRetryBackoff = 512 * time.Millisecond\n\t}\n}\n\nfunc (opt *RingOptions) clientOptions() *Options {\n\treturn &Options{\n\t\tClientName: opt.ClientName,\n\t\tDialer:     opt.Dialer,\n\t\tOnConnect:  opt.OnConnect,\n\n\t\tProtocol: opt.Protocol,\n\t\tUsername: opt.Username,\n\t\tPassword: opt.Password,\n\t\tDB:       opt.DB,\n\n\t\tMaxRetries: -1,\n\n\t\tDialTimeout:           opt.DialTimeout,\n\t\tReadTimeout:           opt.ReadTimeout,\n\t\tWriteTimeout:          opt.WriteTimeout,\n\t\tContextTimeoutEnabled: opt.ContextTimeoutEnabled,\n\n\t\tPoolFIFO:        opt.PoolFIFO,\n\t\tPoolSize:        opt.PoolSize,\n\t\tPoolTimeout:     opt.PoolTimeout,\n\t\tMinIdleConns:    opt.MinIdleConns,\n\t\tMaxIdleConns:    opt.MaxIdleConns,\n\t\tMaxActiveConns:  opt.MaxActiveConns,\n\t\tConnMaxIdleTime: opt.ConnMaxIdleTime,\n\t\tConnMaxLifetime: opt.ConnMaxLifetime,\n\n\t\tTLSConfig: opt.TLSConfig,\n\t\tLimiter:   opt.Limiter,\n\n\t\tDisableIndentity: opt.DisableIndentity,\n\t\tIdentitySuffix:   opt.IdentitySuffix,\n\t\tUnstableResp3:    opt.UnstableResp3,\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype ringShard struct {\n\tClient *Client\n\tdown   int32\n\taddr   string\n}\n\nfunc newRingShard(opt *RingOptions, addr string) *ringShard {\n\tclopt := opt.clientOptions()\n\tclopt.Addr = addr\n\n\treturn &ringShard{\n\t\tClient: opt.NewClient(clopt),\n\t\taddr:   addr,\n\t}\n}\n\nfunc (shard *ringShard) String() string {\n\tvar state string\n\tif shard.IsUp() {\n\t\tstate = \"up\"\n\t} else {\n\t\tstate = \"down\"\n\t}\n\treturn fmt.Sprintf(\"%s is %s\", shard.Client, state)\n}\n\nfunc (shard *ringShard) IsDown() bool {\n\tconst threshold = 3\n\treturn atomic.LoadInt32(&shard.down) >= threshold\n}\n\nfunc (shard *ringShard) IsUp() bool {\n\treturn !shard.IsDown()\n}\n\n// Vote votes to set shard state and returns true if state was changed.\nfunc (shard *ringShard) Vote(up bool) bool {\n\tif up {\n\t\tchanged := shard.IsDown()\n\t\tatomic.StoreInt32(&shard.down, 0)\n\t\treturn changed\n\t}\n\n\tif shard.IsDown() {\n\t\treturn false\n\t}\n\n\tatomic.AddInt32(&shard.down, 1)\n\treturn shard.IsDown()\n}\n\n//------------------------------------------------------------------------------\n\ntype ringSharding struct {\n\topt *RingOptions\n\n\tmu        sync.RWMutex\n\tshards    *ringShards\n\tclosed    bool\n\thash      ConsistentHash\n\tnumShard  int\n\tonNewNode []func(rdb *Client)\n\n\t// ensures exclusive access to SetAddrs so there is no need\n\t// to hold mu for the duration of potentially long shard creation\n\tsetAddrsMu sync.Mutex\n}\n\ntype ringShards struct {\n\tm    map[string]*ringShard\n\tlist []*ringShard\n}\n\nfunc newRingSharding(opt *RingOptions) *ringSharding {\n\tc := &ringSharding{\n\t\topt: opt,\n\t}\n\tc.SetAddrs(opt.Addrs)\n\n\treturn c\n}\n\nfunc (c *ringSharding) OnNewNode(fn func(rdb *Client)) {\n\tc.mu.Lock()\n\tc.onNewNode = append(c.onNewNode, fn)\n\tc.mu.Unlock()\n}\n\n// SetAddrs replaces the shards in use, such that you can increase and\n// decrease number of shards, that you use. It will reuse shards that\n// existed before and close the ones that will not be used anymore.\nfunc (c *ringSharding) SetAddrs(addrs map[string]string) {\n\tc.setAddrsMu.Lock()\n\tdefer c.setAddrsMu.Unlock()\n\n\tcleanup := func(shards map[string]*ringShard) {\n\t\tfor addr, shard := range shards {\n\t\t\tif err := shard.Client.Close(); err != nil {\n\t\t\t\tinternal.Logger.Printf(context.Background(), \"shard.Close %s failed: %s\", addr, err)\n\t\t\t}\n\t\t}\n\t}\n\n\tc.mu.RLock()\n\tif c.closed {\n\t\tc.mu.RUnlock()\n\t\treturn\n\t}\n\texisting := c.shards\n\tc.mu.RUnlock()\n\n\tshards, created, unused := c.newRingShards(addrs, existing)\n\n\tc.mu.Lock()\n\tif c.closed {\n\t\tcleanup(created)\n\t\tc.mu.Unlock()\n\t\treturn\n\t}\n\tc.shards = shards\n\tc.rebalanceLocked()\n\tc.mu.Unlock()\n\n\tcleanup(unused)\n}\n\nfunc (c *ringSharding) newRingShards(\n\taddrs map[string]string, existing *ringShards,\n) (shards *ringShards, created, unused map[string]*ringShard) {\n\tshards = &ringShards{m: make(map[string]*ringShard, len(addrs))}\n\tcreated = make(map[string]*ringShard) // indexed by addr\n\tunused = make(map[string]*ringShard)  // indexed by addr\n\n\tif existing != nil {\n\t\tfor _, shard := range existing.list {\n\t\t\tunused[shard.addr] = shard\n\t\t}\n\t}\n\n\tfor name, addr := range addrs {\n\t\tif shard, ok := unused[addr]; ok {\n\t\t\tshards.m[name] = shard\n\t\t\tdelete(unused, addr)\n\t\t} else {\n\t\t\tshard := newRingShard(c.opt, addr)\n\t\t\tshards.m[name] = shard\n\t\t\tcreated[addr] = shard\n\n\t\t\tfor _, fn := range c.onNewNode {\n\t\t\t\tfn(shard.Client)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, shard := range shards.m {\n\t\tshards.list = append(shards.list, shard)\n\t}\n\n\treturn\n}\n\nfunc (c *ringSharding) List() []*ringShard {\n\tvar list []*ringShard\n\n\tc.mu.RLock()\n\tif !c.closed {\n\t\tlist = c.shards.list\n\t}\n\tc.mu.RUnlock()\n\n\treturn list\n}\n\nfunc (c *ringSharding) Hash(key string) string {\n\tkey = hashtag.Key(key)\n\n\tvar hash string\n\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tif c.numShard > 0 {\n\t\thash = c.hash.Get(key)\n\t}\n\n\treturn hash\n}\n\nfunc (c *ringSharding) GetByKey(key string) (*ringShard, error) {\n\tkey = hashtag.Key(key)\n\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\tif c.closed {\n\t\treturn nil, pool.ErrClosed\n\t}\n\n\tif c.numShard == 0 {\n\t\treturn nil, errRingShardsDown\n\t}\n\n\tshardName := c.hash.Get(key)\n\tif shardName == \"\" {\n\t\treturn nil, errRingShardsDown\n\t}\n\treturn c.shards.m[shardName], nil\n}\n\nfunc (c *ringSharding) GetByName(shardName string) (*ringShard, error) {\n\tif shardName == \"\" {\n\t\treturn c.Random()\n\t}\n\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\treturn c.shards.m[shardName], nil\n}\n\nfunc (c *ringSharding) Random() (*ringShard, error) {\n\treturn c.GetByKey(strconv.Itoa(rand.Int()))\n}\n\n// Heartbeat monitors state of each shard in the ring.\nfunc (c *ringSharding) Heartbeat(ctx context.Context, frequency time.Duration) {\n\tticker := time.NewTicker(frequency)\n\tdefer ticker.Stop()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\tvar rebalance bool\n\n\t\t\tfor _, shard := range c.List() {\n\t\t\t\terr := shard.Client.Ping(ctx).Err()\n\t\t\t\tisUp := err == nil || err == pool.ErrPoolTimeout\n\t\t\t\tif shard.Vote(isUp) {\n\t\t\t\t\tinternal.Logger.Printf(ctx, \"ring shard state changed: %s\", shard)\n\t\t\t\t\trebalance = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif rebalance {\n\t\t\t\tc.mu.Lock()\n\t\t\t\tc.rebalanceLocked()\n\t\t\t\tc.mu.Unlock()\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// rebalanceLocked removes dead shards from the Ring.\n// Requires c.mu locked.\nfunc (c *ringSharding) rebalanceLocked() {\n\tif c.closed {\n\t\treturn\n\t}\n\tif c.shards == nil {\n\t\treturn\n\t}\n\n\tliveShards := make([]string, 0, len(c.shards.m))\n\n\tfor name, shard := range c.shards.m {\n\t\tif shard.IsUp() {\n\t\t\tliveShards = append(liveShards, name)\n\t\t}\n\t}\n\n\tc.hash = c.opt.NewConsistentHash(liveShards)\n\tc.numShard = len(liveShards)\n}\n\nfunc (c *ringSharding) Len() int {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\n\treturn c.numShard\n}\n\nfunc (c *ringSharding) Close() error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.closed {\n\t\treturn nil\n\t}\n\tc.closed = true\n\n\tvar firstErr error\n\n\tfor _, shard := range c.shards.list {\n\t\tif err := shard.Client.Close(); err != nil && firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\n\tc.hash = nil\n\tc.shards = nil\n\tc.numShard = 0\n\n\treturn firstErr\n}\n\n//------------------------------------------------------------------------------\n\n// Ring is a Redis client that uses consistent hashing to distribute\n// keys across multiple Redis servers (shards). It's safe for\n// concurrent use by multiple goroutines.\n//\n// Ring monitors the state of each shard and removes dead shards from\n// the ring. When a shard comes online it is added back to the ring. This\n// gives you maximum availability and partition tolerance, but no\n// consistency between different shards or even clients. Each client\n// uses shards that are available to the client and does not do any\n// coordination when shard state is changed.\n//\n// Ring should be used when you need multiple Redis servers for caching\n// and can tolerate losing data when one of the servers dies.\n// Otherwise you should use Redis Cluster.\ntype Ring struct {\n\tcmdable\n\thooksMixin\n\n\topt               *RingOptions\n\tsharding          *ringSharding\n\tcmdsInfoCache     *cmdsInfoCache\n\theartbeatCancelFn context.CancelFunc\n}\n\nfunc NewRing(opt *RingOptions) *Ring {\n\topt.init()\n\n\thbCtx, hbCancel := context.WithCancel(context.Background())\n\n\tring := Ring{\n\t\topt:               opt,\n\t\tsharding:          newRingSharding(opt),\n\t\theartbeatCancelFn: hbCancel,\n\t}\n\n\tring.cmdsInfoCache = newCmdsInfoCache(ring.cmdsInfo)\n\tring.cmdable = ring.Process\n\n\tring.initHooks(hooks{\n\t\tprocess: ring.process,\n\t\tpipeline: func(ctx context.Context, cmds []Cmder) error {\n\t\t\treturn ring.generalProcessPipeline(ctx, cmds, false)\n\t\t},\n\t\ttxPipeline: func(ctx context.Context, cmds []Cmder) error {\n\t\t\treturn ring.generalProcessPipeline(ctx, cmds, true)\n\t\t},\n\t})\n\n\tgo ring.sharding.Heartbeat(hbCtx, opt.HeartbeatFrequency)\n\n\treturn &ring\n}\n\nfunc (c *Ring) SetAddrs(addrs map[string]string) {\n\tc.sharding.SetAddrs(addrs)\n}\n\n// Do create a Cmd from the args and processes the cmd.\nfunc (c *Ring) Do(ctx context.Context, args ...interface{}) *Cmd {\n\tcmd := NewCmd(ctx, args...)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c *Ring) Process(ctx context.Context, cmd Cmder) error {\n\terr := c.processHook(ctx, cmd)\n\tcmd.SetErr(err)\n\treturn err\n}\n\n// Options returns read-only Options that were used to create the client.\nfunc (c *Ring) Options() *RingOptions {\n\treturn c.opt\n}\n\nfunc (c *Ring) retryBackoff(attempt int) time.Duration {\n\treturn internal.RetryBackoff(attempt, c.opt.MinRetryBackoff, c.opt.MaxRetryBackoff)\n}\n\n// PoolStats returns accumulated connection pool stats.\nfunc (c *Ring) PoolStats() *PoolStats {\n\tshards := c.sharding.List()\n\tvar acc PoolStats\n\tfor _, shard := range shards {\n\t\ts := shard.Client.connPool.Stats()\n\t\tacc.Hits += s.Hits\n\t\tacc.Misses += s.Misses\n\t\tacc.Timeouts += s.Timeouts\n\t\tacc.TotalConns += s.TotalConns\n\t\tacc.IdleConns += s.IdleConns\n\t}\n\treturn &acc\n}\n\n// Len returns the current number of shards in the ring.\nfunc (c *Ring) Len() int {\n\treturn c.sharding.Len()\n}\n\n// Subscribe subscribes the client to the specified channels.\nfunc (c *Ring) Subscribe(ctx context.Context, channels ...string) *PubSub {\n\tif len(channels) == 0 {\n\t\tpanic(\"at least one channel is required\")\n\t}\n\n\tshard, err := c.sharding.GetByKey(channels[0])\n\tif err != nil {\n\t\t// TODO: return PubSub with sticky error\n\t\tpanic(err)\n\t}\n\treturn shard.Client.Subscribe(ctx, channels...)\n}\n\n// PSubscribe subscribes the client to the given patterns.\nfunc (c *Ring) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n\tif len(channels) == 0 {\n\t\tpanic(\"at least one channel is required\")\n\t}\n\n\tshard, err := c.sharding.GetByKey(channels[0])\n\tif err != nil {\n\t\t// TODO: return PubSub with sticky error\n\t\tpanic(err)\n\t}\n\treturn shard.Client.PSubscribe(ctx, channels...)\n}\n\n// SSubscribe Subscribes the client to the specified shard channels.\nfunc (c *Ring) SSubscribe(ctx context.Context, channels ...string) *PubSub {\n\tif len(channels) == 0 {\n\t\tpanic(\"at least one channel is required\")\n\t}\n\tshard, err := c.sharding.GetByKey(channels[0])\n\tif err != nil {\n\t\t// TODO: return PubSub with sticky error\n\t\tpanic(err)\n\t}\n\treturn shard.Client.SSubscribe(ctx, channels...)\n}\n\nfunc (c *Ring) OnNewNode(fn func(rdb *Client)) {\n\tc.sharding.OnNewNode(fn)\n}\n\n// ForEachShard concurrently calls the fn on each live shard in the ring.\n// It returns the first error if any.\nfunc (c *Ring) ForEachShard(\n\tctx context.Context,\n\tfn func(ctx context.Context, client *Client) error,\n) error {\n\tshards := c.sharding.List()\n\tvar wg sync.WaitGroup\n\terrCh := make(chan error, 1)\n\tfor _, shard := range shards {\n\t\tif shard.IsDown() {\n\t\t\tcontinue\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func(shard *ringShard) {\n\t\t\tdefer wg.Done()\n\t\t\terr := fn(ctx, shard.Client)\n\t\t\tif err != nil {\n\t\t\t\tselect {\n\t\t\t\tcase errCh <- err:\n\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t}\n\t\t}(shard)\n\t}\n\twg.Wait()\n\n\tselect {\n\tcase err := <-errCh:\n\t\treturn err\n\tdefault:\n\t\treturn nil\n\t}\n}\n\nfunc (c *Ring) cmdsInfo(ctx context.Context) (map[string]*CommandInfo, error) {\n\tshards := c.sharding.List()\n\tvar firstErr error\n\tfor _, shard := range shards {\n\t\tcmdsInfo, err := shard.Client.Command(ctx).Result()\n\t\tif err == nil {\n\t\t\treturn cmdsInfo, nil\n\t\t}\n\t\tif firstErr == nil {\n\t\t\tfirstErr = err\n\t\t}\n\t}\n\tif firstErr == nil {\n\t\treturn nil, errRingShardsDown\n\t}\n\treturn nil, firstErr\n}\n\nfunc (c *Ring) cmdShard(ctx context.Context, cmd Cmder) (*ringShard, error) {\n\tpos := cmdFirstKeyPos(cmd)\n\tif pos == 0 {\n\t\treturn c.sharding.Random()\n\t}\n\tfirstKey := cmd.stringArg(pos)\n\treturn c.sharding.GetByKey(firstKey)\n}\n\nfunc (c *Ring) process(ctx context.Context, cmd Cmder) error {\n\tvar lastErr error\n\tfor attempt := 0; attempt <= c.opt.MaxRetries; attempt++ {\n\t\tif attempt > 0 {\n\t\t\tif err := internal.Sleep(ctx, c.retryBackoff(attempt)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tshard, err := c.cmdShard(ctx, cmd)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlastErr = shard.Client.Process(ctx, cmd)\n\t\tif lastErr == nil || !shouldRetry(lastErr, cmd.readTimeout() == nil) {\n\t\t\treturn lastErr\n\t\t}\n\t}\n\treturn lastErr\n}\n\nfunc (c *Ring) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.Pipeline().Pipelined(ctx, fn)\n}\n\nfunc (c *Ring) Pipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: pipelineExecer(c.processPipelineHook),\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc (c *Ring) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.TxPipeline().Pipelined(ctx, fn)\n}\n\nfunc (c *Ring) TxPipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: func(ctx context.Context, cmds []Cmder) error {\n\t\t\tcmds = wrapMultiExec(ctx, cmds)\n\t\t\treturn c.processTxPipelineHook(ctx, cmds)\n\t\t},\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc (c *Ring) generalProcessPipeline(\n\tctx context.Context, cmds []Cmder, tx bool,\n) error {\n\tif tx {\n\t\t// Trim multi .. exec.\n\t\tcmds = cmds[1 : len(cmds)-1]\n\t}\n\n\tcmdsMap := make(map[string][]Cmder)\n\n\tfor _, cmd := range cmds {\n\t\thash := cmd.stringArg(cmdFirstKeyPos(cmd))\n\t\tif hash != \"\" {\n\t\t\thash = c.sharding.Hash(hash)\n\t\t}\n\t\tcmdsMap[hash] = append(cmdsMap[hash], cmd)\n\t}\n\n\tvar wg sync.WaitGroup\n\tfor hash, cmds := range cmdsMap {\n\t\twg.Add(1)\n\t\tgo func(hash string, cmds []Cmder) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// TODO: retry?\n\t\t\tshard, err := c.sharding.GetByName(hash)\n\t\t\tif err != nil {\n\t\t\t\tsetCmdsErr(cmds, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif tx {\n\t\t\t\tcmds = wrapMultiExec(ctx, cmds)\n\t\t\t\t_ = shard.Client.processTxPipelineHook(ctx, cmds)\n\t\t\t} else {\n\t\t\t\t_ = shard.Client.processPipelineHook(ctx, cmds)\n\t\t\t}\n\t\t}(hash, cmds)\n\t}\n\n\twg.Wait()\n\treturn cmdsFirstErr(cmds)\n}\n\nfunc (c *Ring) Watch(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n\tif len(keys) == 0 {\n\t\treturn fmt.Errorf(\"redis: Watch requires at least one key\")\n\t}\n\n\tvar shards []*ringShard\n\n\tfor _, key := range keys {\n\t\tif key != \"\" {\n\t\t\tshard, err := c.sharding.GetByKey(hashtag.Key(key))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tshards = append(shards, shard)\n\t\t}\n\t}\n\n\tif len(shards) == 0 {\n\t\treturn fmt.Errorf(\"redis: Watch requires at least one shard\")\n\t}\n\n\tif len(shards) > 1 {\n\t\tfor _, shard := range shards[1:] {\n\t\t\tif shard.Client != shards[0].Client {\n\t\t\t\terr := fmt.Errorf(\"redis: Watch requires all keys to be in the same shard\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\treturn shards[0].Client.Watch(ctx, fn, keys...)\n}\n\n// Close closes the ring client, releasing any open resources.\n//\n// It is rare to Close a Ring, as the Ring is meant to be long-lived\n// and shared between many goroutines.\nfunc (c *Ring) Close() error {\n\tc.heartbeatCancelFn()\n\n\treturn c.sharding.Close()\n}\n"
        },
        {
          "name": "ring_test.go",
          "type": "blob",
          "size": 20.6748046875,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"Redis Ring PROTO 2\", func() {\n\tconst heartbeat = 100 * time.Millisecond\n\n\tvar ring *redis.Ring\n\n\tBeforeEach(func() {\n\t\topt := redisRingOptions()\n\t\topt.Protocol = 2\n\t\topt.HeartbeatFrequency = heartbeat\n\t\tring = redis.NewRing(opt)\n\n\t\terr := ring.ForEachShard(ctx, func(ctx context.Context, cl *redis.Client) error {\n\t\t\treturn cl.FlushDB(ctx).Err()\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(ring.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should ring PROTO 2\", func() {\n\t\t_ = ring.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\tval, err := c.Do(ctx, \"HELLO\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).Should(ContainElements(\"proto\", int64(2)))\n\t\t\treturn nil\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"Redis Ring\", func() {\n\tconst heartbeat = 100 * time.Millisecond\n\n\tvar ring *redis.Ring\n\n\tsetRingKeys := func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\terr := ring.Set(ctx, fmt.Sprintf(\"key%d\", i), \"value\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\t}\n\n\tBeforeEach(func() {\n\t\topt := redisRingOptions()\n\t\topt.ClientName = \"ring_hi\"\n\t\topt.HeartbeatFrequency = heartbeat\n\t\tring = redis.NewRing(opt)\n\n\t\terr := ring.ForEachShard(ctx, func(ctx context.Context, cl *redis.Client) error {\n\t\t\treturn cl.FlushDB(ctx).Err()\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(ring.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"supports context\", func() {\n\t\tctx, cancel := context.WithCancel(ctx)\n\t\tcancel()\n\n\t\terr := ring.Ping(ctx).Err()\n\t\tExpect(err).To(MatchError(\"context canceled\"))\n\t})\n\n\tIt(\"should ring client setname\", func() {\n\t\terr := ring.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\treturn c.Ping(ctx).Err()\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_ = ring.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\tval, err := c.ClientList(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).Should(ContainSubstring(\"name=ring_hi\"))\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tIt(\"should ring PROTO 3\", func() {\n\t\t_ = ring.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\tval, err := c.Do(ctx, \"HELLO\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).Should(HaveKeyWithValue(\"proto\", int64(3)))\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tIt(\"distributes keys\", func() {\n\t\tsetRingKeys()\n\n\t\t// Both shards should have some keys now.\n\t\tExpect(ringShard1.Info(ctx, \"keyspace\").Val()).To(ContainSubstring(\"keys=56\"))\n\t\tExpect(ringShard2.Info(ctx, \"keyspace\").Val()).To(ContainSubstring(\"keys=44\"))\n\t})\n\n\tIt(\"distributes keys when using EVAL\", func() {\n\t\tscript := redis.NewScript(`\n\t\t\tlocal r = redis.call('SET', KEYS[1], ARGV[1])\n\t\t\treturn r\n\t\t`)\n\n\t\tvar key string\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tkey = fmt.Sprintf(\"key%d\", i)\n\t\t\terr := script.Run(ctx, ring, []string{key}, \"value\").Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\tExpect(ringShard1.Info(ctx, \"keyspace\").Val()).To(ContainSubstring(\"keys=56\"))\n\t\tExpect(ringShard2.Info(ctx, \"keyspace\").Val()).To(ContainSubstring(\"keys=44\"))\n\t})\n\n\tIt(\"uses single shard when one of the shards is down\", func() {\n\t\t// Stop ringShard2.\n\t\tExpect(ringShard2.Close()).NotTo(HaveOccurred())\n\n\t\tEventually(func() int {\n\t\t\treturn ring.Len()\n\t\t}, \"30s\").Should(Equal(1))\n\n\t\tsetRingKeys()\n\n\t\t// RingShard1 should have all keys.\n\t\tExpect(ringShard1.Info(ctx, \"keyspace\").Val()).To(ContainSubstring(\"keys=100\"))\n\n\t\t// Start ringShard2.\n\t\tvar err error\n\t\tringShard2, err = startRedis(ringShard2Port)\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tEventually(func() int {\n\t\t\treturn ring.Len()\n\t\t}, \"30s\").Should(Equal(2))\n\n\t\tsetRingKeys()\n\n\t\t// RingShard2 should have its keys.\n\t\tExpect(ringShard2.Info(ctx, \"keyspace\").Val()).To(ContainSubstring(\"keys=44\"))\n\t})\n\n\tIt(\"supports hash tags\", func() {\n\t\tfor i := 0; i < 100; i++ {\n\t\t\terr := ring.Set(ctx, fmt.Sprintf(\"key%d{tag}\", i), \"value\", 0).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\tExpect(ringShard1.Info(ctx, \"keyspace\").Val()).ToNot(ContainSubstring(\"keys=\"))\n\t\tExpect(ringShard2.Info(ctx, \"keyspace\").Val()).To(ContainSubstring(\"keys=100\"))\n\t})\n\n\tDescribe(\"[new] dynamic setting ring shards\", func() {\n\t\tIt(\"downscale shard and check reuse shard, upscale shard and check reuse\", func() {\n\t\t\tExpect(ring.Len(), 2)\n\n\t\t\twantShard := ring.ShardByName(\"ringShardOne\")\n\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\t\"ringShardOne\": \":\" + ringShard1Port,\n\t\t\t})\n\t\t\tExpect(ring.Len(), 1)\n\t\t\tgotShard := ring.ShardByName(\"ringShardOne\")\n\t\t\tExpect(gotShard).To(BeIdenticalTo(wantShard))\n\n\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\t\"ringShardOne\": \":\" + ringShard1Port,\n\t\t\t\t\"ringShardTwo\": \":\" + ringShard2Port,\n\t\t\t})\n\t\t\tExpect(ring.Len(), 2)\n\t\t\tgotShard = ring.ShardByName(\"ringShardOne\")\n\t\t\tExpect(gotShard).To(BeIdenticalTo(wantShard))\n\t\t})\n\n\t\tIt(\"uses 3 shards after setting it to 3 shards\", func() {\n\t\t\tExpect(ring.Len(), 2)\n\n\t\t\tshardName1 := \"ringShardOne\"\n\t\t\tshardAddr1 := \":\" + ringShard1Port\n\t\t\twantShard1 := ring.ShardByName(shardName1)\n\t\t\tshardName2 := \"ringShardTwo\"\n\t\t\tshardAddr2 := \":\" + ringShard2Port\n\t\t\twantShard2 := ring.ShardByName(shardName2)\n\t\t\tshardName3 := \"ringShardThree\"\n\t\t\tshardAddr3 := \":\" + ringShard3Port\n\n\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\tshardName1: shardAddr1,\n\t\t\t\tshardName2: shardAddr2,\n\t\t\t\tshardName3: shardAddr3,\n\t\t\t})\n\t\t\tExpect(ring.Len(), 3)\n\t\t\tgotShard1 := ring.ShardByName(shardName1)\n\t\t\tgotShard2 := ring.ShardByName(shardName2)\n\t\t\tgotShard3 := ring.ShardByName(shardName3)\n\t\t\tExpect(gotShard1).To(BeIdenticalTo(wantShard1))\n\t\t\tExpect(gotShard2).To(BeIdenticalTo(wantShard2))\n\t\t\tExpect(gotShard3).ToNot(BeNil())\n\n\t\t\tring.SetAddrs(map[string]string{\n\t\t\t\tshardName1: shardAddr1,\n\t\t\t\tshardName2: shardAddr2,\n\t\t\t})\n\t\t\tExpect(ring.Len(), 2)\n\t\t\tgotShard1 = ring.ShardByName(shardName1)\n\t\t\tgotShard2 = ring.ShardByName(shardName2)\n\t\t\tgotShard3 = ring.ShardByName(shardName3)\n\t\t\tExpect(gotShard1).To(BeIdenticalTo(wantShard1))\n\t\t\tExpect(gotShard2).To(BeIdenticalTo(wantShard2))\n\t\t\tExpect(gotShard3).To(BeNil())\n\t\t})\n\t})\n\tDescribe(\"pipeline\", func() {\n\t\tIt(\"doesn't panic closed ring, returns error\", func() {\n\t\t\tpipe := ring.Pipeline()\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\terr := pipe.Set(ctx, fmt.Sprintf(\"key%d\", i), \"value\", 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\n\t\t\tExpect(ring.Close()).NotTo(HaveOccurred())\n\n\t\t\tExpect(func() {\n\t\t\t\t_, execErr := pipe.Exec(ctx)\n\t\t\t\tExpect(execErr).To(HaveOccurred())\n\t\t\t}).NotTo(Panic())\n\t\t})\n\n\t\tIt(\"distributes keys\", func() {\n\t\t\tpipe := ring.Pipeline()\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\terr := pipe.Set(ctx, fmt.Sprintf(\"key%d\", i), \"value\", 0).Err()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t\tcmds, err := pipe.Exec(ctx)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cmds).To(HaveLen(100))\n\n\t\t\tfor _, cmd := range cmds {\n\t\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmd.(*redis.StatusCmd).Val()).To(Equal(\"OK\"))\n\t\t\t}\n\n\t\t\t// Both shards should have some keys now.\n\t\t\tExpect(ringShard1.Info(ctx).Val()).To(ContainSubstring(\"keys=56\"))\n\t\t\tExpect(ringShard2.Info(ctx).Val()).To(ContainSubstring(\"keys=44\"))\n\t\t})\n\n\t\tIt(\"is consistent with ring\", func() {\n\t\t\tvar keys []string\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\tkey := make([]byte, 64)\n\t\t\t\t_, err := rand.Read(key)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tkeys = append(keys, string(key))\n\t\t\t}\n\n\t\t\t_, err := ring.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tfor _, key := range keys {\n\t\t\t\t\tpipe.Set(ctx, key, \"value\", 0).Err()\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tfor _, key := range keys {\n\t\t\t\tval, err := ring.Get(ctx, key).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(val).To(Equal(\"value\"))\n\t\t\t}\n\t\t})\n\n\t\tIt(\"supports hash tags\", func() {\n\t\t\t_, err := ring.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\tpipe.Set(ctx, fmt.Sprintf(\"key%d{tag}\", i), \"value\", 0).Err()\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(ringShard1.Info(ctx).Val()).ToNot(ContainSubstring(\"keys=\"))\n\t\t\tExpect(ringShard2.Info(ctx).Val()).To(ContainSubstring(\"keys=100\"))\n\t\t})\n\t})\n\n\tDescribe(\"new client callback\", func() {\n\t\tIt(\"can be initialized with a new client callback\", func() {\n\t\t\topts := redisRingOptions()\n\t\t\topts.NewClient = func(opt *redis.Options) *redis.Client {\n\t\t\t\topt.Username = \"username1\"\n\t\t\t\topt.Password = \"password1\"\n\t\t\t\treturn redis.NewClient(opt)\n\t\t\t}\n\t\t\tring = redis.NewRing(opts)\n\n\t\t\terr := ring.Ping(ctx).Err()\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.Error()).To(ContainSubstring(\"WRONGPASS\"))\n\t\t})\n\t})\n\n\tDescribe(\"Process hook\", func() {\n\t\tBeforeEach(func() {\n\t\t\t// the health check leads to data race for variable \"stack []string\".\n\t\t\t// here, the health check time is set to 72 hours to avoid health check\n\t\t\topt := redisRingOptions()\n\t\t\topt.HeartbeatFrequency = 72 * time.Hour\n\t\t\tring = redis.NewRing(opt)\n\t\t})\n\t\tIt(\"supports Process hook\", func() {\n\t\t\terr := ring.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar stack []string\n\n\t\t\tring.AddHook(&hook{\n\t\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\tstack = append(stack, \"ring.BeforeProcess\")\n\n\t\t\t\t\t\terr := hook(ctx, cmd)\n\n\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\tstack = append(stack, \"ring.AfterProcess\")\n\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tring.ForEachShard(ctx, func(ctx context.Context, shard *redis.Client) error {\n\t\t\t\tshard.AddHook(&hook{\n\t\t\t\t\tprocessHook: func(hook redis.ProcessHook) redis.ProcessHook {\n\t\t\t\t\t\treturn func(ctx context.Context, cmd redis.Cmder) error {\n\t\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.BeforeProcess\")\n\n\t\t\t\t\t\t\terr := hook(ctx, cmd)\n\n\t\t\t\t\t\t\tExpect(cmd.String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.AfterProcess\")\n\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\terr = ring.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(stack).To(Equal([]string{\n\t\t\t\t\"ring.BeforeProcess\",\n\t\t\t\t\"shard.BeforeProcess\",\n\t\t\t\t\"shard.AfterProcess\",\n\t\t\t\t\"ring.AfterProcess\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"supports Pipeline hook\", func() {\n\t\t\terr := ring.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar stack []string\n\n\t\t\tring.AddHook(&hook{\n\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\tstack = append(stack, \"ring.BeforeProcessPipeline\")\n\n\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\tstack = append(stack, \"ring.AfterProcessPipeline\")\n\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tring.ForEachShard(ctx, func(ctx context.Context, shard *redis.Client) error {\n\t\t\t\tshard.AddHook(&hook{\n\t\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.BeforeProcessPipeline\")\n\n\t\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\t\t\tExpect(cmds[0].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.AfterProcessPipeline\")\n\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\t_, err = ring.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(stack).To(Equal([]string{\n\t\t\t\t\"ring.BeforeProcessPipeline\",\n\t\t\t\t\"shard.BeforeProcessPipeline\",\n\t\t\t\t\"shard.AfterProcessPipeline\",\n\t\t\t\t\"ring.AfterProcessPipeline\",\n\t\t\t}))\n\t\t})\n\n\t\tIt(\"supports TxPipeline hook\", func() {\n\t\t\terr := ring.Ping(ctx).Err()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tvar stack []string\n\n\t\t\tring.AddHook(&hook{\n\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\tstack = append(stack, \"ring.BeforeProcessPipeline\")\n\n\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\tstack = append(stack, \"ring.AfterProcessPipeline\")\n\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tring.ForEachShard(ctx, func(ctx context.Context, shard *redis.Client) error {\n\t\t\t\tshard.AddHook(&hook{\n\t\t\t\t\tprocessPipelineHook: func(hook redis.ProcessPipelineHook) redis.ProcessPipelineHook {\n\t\t\t\t\t\treturn func(ctx context.Context, cmds []redis.Cmder) error {\n\t\t\t\t\t\t\tdefer GinkgoRecover()\n\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: \"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.BeforeProcessPipeline\")\n\n\t\t\t\t\t\t\terr := hook(ctx, cmds)\n\n\t\t\t\t\t\t\tExpect(cmds).To(HaveLen(3))\n\t\t\t\t\t\t\tExpect(cmds[1].String()).To(Equal(\"ping: PONG\"))\n\t\t\t\t\t\t\tstack = append(stack, \"shard.AfterProcessPipeline\")\n\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\treturn nil\n\t\t\t})\n\n\t\t\t_, err = ring.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(stack).To(Equal([]string{\n\t\t\t\t\"ring.BeforeProcessPipeline\",\n\t\t\t\t\"shard.BeforeProcessPipeline\",\n\t\t\t\t\"shard.AfterProcessPipeline\",\n\t\t\t\t\"ring.AfterProcessPipeline\",\n\t\t\t}))\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"empty Redis Ring\", func() {\n\tvar ring *redis.Ring\n\n\tBeforeEach(func() {\n\t\tring = redis.NewRing(&redis.RingOptions{})\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(ring.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"returns an error\", func() {\n\t\terr := ring.Ping(ctx).Err()\n\t\tExpect(err).To(MatchError(\"redis: all ring shards are down\"))\n\t})\n\n\tIt(\"pipeline returns an error\", func() {\n\t\t_, err := ring.Pipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\tpipe.Ping(ctx)\n\t\t\treturn nil\n\t\t})\n\t\tExpect(err).To(MatchError(\"redis: all ring shards are down\"))\n\t})\n})\n\nvar _ = Describe(\"Ring watch\", func() {\n\tconst heartbeat = 100 * time.Millisecond\n\n\tvar ring *redis.Ring\n\n\tBeforeEach(func() {\n\t\topt := redisRingOptions()\n\t\topt.HeartbeatFrequency = heartbeat\n\t\tring = redis.NewRing(opt)\n\n\t\terr := ring.ForEachShard(ctx, func(ctx context.Context, cl *redis.Client) error {\n\t\t\treturn cl.FlushDB(ctx).Err()\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(ring.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should Watch\", func() {\n\t\tvar incr func(string) error\n\n\t\t// Transactionally increments key using GET and SET commands.\n\t\tincr = func(key string) error {\n\t\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\tn, err := tx.Get(ctx, key).Int64()\n\t\t\t\tif err != nil && err != redis.Nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tpipe.Set(ctx, key, strconv.FormatInt(n+1, 10), 0)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\treturn err\n\t\t\t}, key)\n\t\t\tif err == redis.TxFailedErr {\n\t\t\t\treturn incr(key)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < 100; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\terr := incr(\"key\")\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\tn, err := ring.Get(ctx, \"key\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(100)))\n\t})\n\n\tIt(\"should discard\", func() {\n\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\tcmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Set(ctx, \"{shard}key1\", \"hello1\", 0)\n\t\t\t\tpipe.Discard()\n\t\t\t\tpipe.Set(ctx, \"{shard}key2\", \"hello2\", 0)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\treturn err\n\t\t}, \"{shard}key1\", \"{shard}key2\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tget := ring.Get(ctx, \"{shard}key1\")\n\t\tExpect(get.Err()).To(Equal(redis.Nil))\n\t\tExpect(get.Val()).To(Equal(\"\"))\n\n\t\tget = ring.Get(ctx, \"{shard}key2\")\n\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\tExpect(get.Val()).To(Equal(\"hello2\"))\n\t})\n\n\tIt(\"returns no error when there are no commands\", func() {\n\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t_, err := tx.TxPipelined(ctx, func(redis.Pipeliner) error { return nil })\n\t\t\treturn err\n\t\t}, \"key\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tv, err := ring.Ping(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(v).To(Equal(\"PONG\"))\n\t})\n\n\tIt(\"should exec bulks\", func() {\n\t\tconst N = 20000\n\n\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\tcmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\t\tpipe.Incr(ctx, \"key\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(cmds)).To(Equal(N))\n\t\t\tfor _, cmd := range cmds {\n\t\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\t\t\treturn err\n\t\t}, \"key\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tnum, err := ring.Get(ctx, \"key\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(num).To(Equal(int64(N)))\n\t})\n\n\tIt(\"should Watch/Unwatch\", func() {\n\t\tvar C, N int\n\n\t\terr := ring.Set(ctx, \"key\", \"0\", 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tperform(C, func(id int) {\n\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\t\tval, err := tx.Get(ctx, \"key\").Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(val).NotTo(Equal(redis.Nil))\n\n\t\t\t\t\tnum, err := strconv.ParseInt(val, 10, 64)\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t\tcmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\t\tpipe.Set(ctx, \"key\", strconv.FormatInt(num+1, 10), 0)\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t})\n\t\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\t\treturn err\n\t\t\t\t}, \"key\")\n\t\t\t\tif err == redis.TxFailedErr {\n\t\t\t\t\ti--\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}\n\t\t})\n\n\t\tval, err := ring.Get(ctx, \"key\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(int64(C * N)))\n\t})\n\n\tIt(\"should close Tx without closing the client\", func() {\n\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t_, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Ping(ctx)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\treturn err\n\t\t}, \"key\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tExpect(ring.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"respects max size on multi\", func() {\n\t\t//this test checks the number of \"pool.conn\"\n\t\t//if the health check is performed at the same time\n\t\t//conn will be used, resulting in an abnormal number of \"pool.conn\".\n\t\t//\n\t\t//redis.NewRing() does not have an option to prohibit health checks.\n\t\t//set a relatively large time here to avoid health checks.\n\t\topt := redisRingOptions()\n\t\topt.HeartbeatFrequency = 72 * time.Hour\n\t\tring = redis.NewRing(opt)\n\n\t\tperform(1000, func(id int) {\n\t\t\tvar ping *redis.StatusCmd\n\n\t\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\tcmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tping = pipe.Ping(ctx)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\t\treturn err\n\t\t\t}, \"key\")\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tExpect(ping.Err()).NotTo(HaveOccurred())\n\t\t\tExpect(ping.Val()).To(Equal(\"PONG\"))\n\t\t})\n\n\t\tring.ForEachShard(ctx, func(ctx context.Context, cl *redis.Client) error {\n\t\t\tdefer GinkgoRecover()\n\n\t\t\tpool := cl.Pool()\n\t\t\tExpect(pool.Len()).To(BeNumerically(\"<=\", 10))\n\t\t\tExpect(pool.IdleLen()).To(BeNumerically(\"<=\", 10))\n\t\t\tExpect(pool.Len()).To(Equal(pool.IdleLen()))\n\n\t\t\treturn nil\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"Ring Tx timeout\", func() {\n\tconst heartbeat = 100 * time.Millisecond\n\n\tvar ring *redis.Ring\n\n\tAfterEach(func() {\n\t\t_ = ring.Close()\n\t})\n\n\ttestTimeout := func() {\n\t\tIt(\"Tx timeouts\", func() {\n\t\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\treturn tx.Ping(ctx).Err()\n\t\t\t}, \"foo\")\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\n\t\tIt(\"Tx Pipeline timeouts\", func() {\n\t\t\terr := ring.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\t_, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tpipe.Ping(ctx)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\treturn err\n\t\t\t}, \"foo\")\n\t\t\tExpect(err).To(HaveOccurred())\n\t\t\tExpect(err.(net.Error).Timeout()).To(BeTrue())\n\t\t})\n\t}\n\n\tconst pause = 5 * time.Second\n\n\tContext(\"read/write timeout\", func() {\n\t\tBeforeEach(func() {\n\t\t\topt := redisRingOptions()\n\t\t\topt.ReadTimeout = 250 * time.Millisecond\n\t\t\topt.WriteTimeout = 250 * time.Millisecond\n\t\t\topt.HeartbeatFrequency = heartbeat\n\t\t\tring = redis.NewRing(opt)\n\n\t\t\terr := ring.ForEachShard(ctx, func(ctx context.Context, client *redis.Client) error {\n\t\t\t\treturn client.ClientPause(ctx, pause).Err()\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t\tAfterEach(func() {\n\t\t\t_ = ring.ForEachShard(ctx, func(ctx context.Context, client *redis.Client) error {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tEventually(func() error {\n\t\t\t\t\treturn client.Ping(ctx).Err()\n\t\t\t\t}, 2*pause).ShouldNot(HaveOccurred())\n\t\t\t\treturn nil\n\t\t\t})\n\t\t})\n\n\t\ttestTimeout()\n\t})\n})\n"
        },
        {
          "name": "script.go",
          "type": "blob",
          "size": 2.37109375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"io\"\n)\n\ntype Scripter interface {\n\tEval(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd\n\tEvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd\n\tEvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd\n\tEvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd\n\tScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd\n\tScriptLoad(ctx context.Context, script string) *StringCmd\n}\n\nvar (\n\t_ Scripter = (*Client)(nil)\n\t_ Scripter = (*Ring)(nil)\n\t_ Scripter = (*ClusterClient)(nil)\n)\n\ntype Script struct {\n\tsrc, hash string\n}\n\nfunc NewScript(src string) *Script {\n\th := sha1.New()\n\t_, _ = io.WriteString(h, src)\n\treturn &Script{\n\t\tsrc:  src,\n\t\thash: hex.EncodeToString(h.Sum(nil)),\n\t}\n}\n\nfunc (s *Script) Hash() string {\n\treturn s.hash\n}\n\nfunc (s *Script) Load(ctx context.Context, c Scripter) *StringCmd {\n\treturn c.ScriptLoad(ctx, s.src)\n}\n\nfunc (s *Script) Exists(ctx context.Context, c Scripter) *BoolSliceCmd {\n\treturn c.ScriptExists(ctx, s.hash)\n}\n\nfunc (s *Script) Eval(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n\treturn c.Eval(ctx, s.src, keys, args...)\n}\n\nfunc (s *Script) EvalRO(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n\treturn c.EvalRO(ctx, s.src, keys, args...)\n}\n\nfunc (s *Script) EvalSha(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n\treturn c.EvalSha(ctx, s.hash, keys, args...)\n}\n\nfunc (s *Script) EvalShaRO(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n\treturn c.EvalShaRO(ctx, s.hash, keys, args...)\n}\n\n// Run optimistically uses EVALSHA to run the script. If script does not exist\n// it is retried using EVAL.\nfunc (s *Script) Run(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n\tr := s.EvalSha(ctx, c, keys, args...)\n\tif HasErrorPrefix(r.Err(), \"NOSCRIPT\") {\n\t\treturn s.Eval(ctx, c, keys, args...)\n\t}\n\treturn r\n}\n\n// RunRO optimistically uses EVALSHA_RO to run the script. If script does not exist\n// it is retried using EVAL_RO.\nfunc (s *Script) RunRO(ctx context.Context, c Scripter, keys []string, args ...interface{}) *Cmd {\n\tr := s.EvalShaRO(ctx, c, keys, args...)\n\tif HasErrorPrefix(r.Err(), \"NOSCRIPT\") {\n\t\treturn s.EvalRO(ctx, c, keys, args...)\n\t}\n\treturn r\n}\n"
        },
        {
          "name": "scripting_commands.go",
          "type": "blob",
          "size": 6.7109375,
          "content": "package redis\n\nimport \"context\"\n\ntype ScriptingFunctionsCmdable interface {\n\tEval(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd\n\tEvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd\n\tEvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd\n\tEvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd\n\tScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd\n\tScriptFlush(ctx context.Context) *StatusCmd\n\tScriptKill(ctx context.Context) *StatusCmd\n\tScriptLoad(ctx context.Context, script string) *StringCmd\n\n\tFunctionLoad(ctx context.Context, code string) *StringCmd\n\tFunctionLoadReplace(ctx context.Context, code string) *StringCmd\n\tFunctionDelete(ctx context.Context, libName string) *StringCmd\n\tFunctionFlush(ctx context.Context) *StringCmd\n\tFunctionKill(ctx context.Context) *StringCmd\n\tFunctionFlushAsync(ctx context.Context) *StringCmd\n\tFunctionList(ctx context.Context, q FunctionListQuery) *FunctionListCmd\n\tFunctionDump(ctx context.Context) *StringCmd\n\tFunctionRestore(ctx context.Context, libDump string) *StringCmd\n\tFunctionStats(ctx context.Context) *FunctionStatsCmd\n\tFCall(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd\n\tFCallRo(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd\n\tFCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd\n}\n\nfunc (c cmdable) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd {\n\treturn c.eval(ctx, \"eval\", script, keys, args...)\n}\n\nfunc (c cmdable) EvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd {\n\treturn c.eval(ctx, \"eval_ro\", script, keys, args...)\n}\n\nfunc (c cmdable) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd {\n\treturn c.eval(ctx, \"evalsha\", sha1, keys, args...)\n}\n\nfunc (c cmdable) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd {\n\treturn c.eval(ctx, \"evalsha_ro\", sha1, keys, args...)\n}\n\nfunc (c cmdable) eval(ctx context.Context, name, payload string, keys []string, args ...interface{}) *Cmd {\n\tcmdArgs := make([]interface{}, 3+len(keys), 3+len(keys)+len(args))\n\tcmdArgs[0] = name\n\tcmdArgs[1] = payload\n\tcmdArgs[2] = len(keys)\n\tfor i, key := range keys {\n\t\tcmdArgs[3+i] = key\n\t}\n\tcmdArgs = appendArgs(cmdArgs, args)\n\tcmd := NewCmd(ctx, cmdArgs...)\n\n\t// it is possible that only args exist without a key.\n\t// rdb.eval(ctx, eval, script, nil, arg1, arg2)\n\tif len(keys) > 0 {\n\t\tcmd.SetFirstKeyPos(3)\n\t}\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd {\n\targs := make([]interface{}, 2+len(hashes))\n\targs[0] = \"script\"\n\targs[1] = \"exists\"\n\tfor i, hash := range hashes {\n\t\targs[2+i] = hash\n\t}\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ScriptFlush(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"script\", \"flush\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ScriptKill(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"script\", \"kill\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ScriptLoad(ctx context.Context, script string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"script\", \"load\", script)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ------------------------------------------------------------------------------\n\n// FunctionListQuery is used with FunctionList to query for Redis libraries\n//\n//\t  \tLibraryNamePattern \t- Use an empty string to get all libraries.\n//\t  \t\t\t\t\t\t- Use a glob-style pattern to match multiple libraries with a matching name\n//\t  \t\t\t\t\t\t- Use a library's full name to match a single library\n//\t\tWithCode\t\t\t- If true, it will return the code of the library\ntype FunctionListQuery struct {\n\tLibraryNamePattern string\n\tWithCode           bool\n}\n\nfunc (c cmdable) FunctionLoad(ctx context.Context, code string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"load\", code)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionLoadReplace(ctx context.Context, code string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"load\", \"replace\", code)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionDelete(ctx context.Context, libName string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"delete\", libName)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionFlush(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"flush\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionKill(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"kill\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionFlushAsync(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"flush\", \"async\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionList(ctx context.Context, q FunctionListQuery) *FunctionListCmd {\n\targs := make([]interface{}, 2, 5)\n\targs[0] = \"function\"\n\targs[1] = \"list\"\n\tif q.LibraryNamePattern != \"\" {\n\t\targs = append(args, \"libraryname\", q.LibraryNamePattern)\n\t}\n\tif q.WithCode {\n\t\targs = append(args, \"withcode\")\n\t}\n\tcmd := NewFunctionListCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionDump(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"dump\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionRestore(ctx context.Context, libDump string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"function\", \"restore\", libDump)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FunctionStats(ctx context.Context) *FunctionStatsCmd {\n\tcmd := NewFunctionStatsCmd(ctx, \"function\", \"stats\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) FCall(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {\n\tcmdArgs := fcallArgs(\"fcall\", function, keys, args...)\n\tcmd := NewCmd(ctx, cmdArgs...)\n\tif len(keys) > 0 {\n\t\tcmd.SetFirstKeyPos(3)\n\t}\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FCallRo this function simply calls FCallRO,\n// Deprecated: to maintain convention FCallRO.\nfunc (c cmdable) FCallRo(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {\n\treturn c.FCallRO(ctx, function, keys, args...)\n}\n\nfunc (c cmdable) FCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {\n\tcmdArgs := fcallArgs(\"fcall_ro\", function, keys, args...)\n\tcmd := NewCmd(ctx, cmdArgs...)\n\tif len(keys) > 0 {\n\t\tcmd.SetFirstKeyPos(3)\n\t}\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc fcallArgs(command string, function string, keys []string, args ...interface{}) []interface{} {\n\tcmdArgs := make([]interface{}, 3+len(keys), 3+len(keys)+len(args))\n\tcmdArgs[0] = command\n\tcmdArgs[1] = function\n\tcmdArgs[2] = len(keys)\n\tfor i, key := range keys {\n\t\tcmdArgs[3+i] = key\n\t}\n\n\tcmdArgs = append(cmdArgs, args...)\n\treturn cmdArgs\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "search_commands.go",
          "type": "blob",
          "size": 66.404296875,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\ntype SearchCmdable interface {\n\tFT_List(ctx context.Context) *StringSliceCmd\n\tFTAggregate(ctx context.Context, index string, query string) *MapStringInterfaceCmd\n\tFTAggregateWithArgs(ctx context.Context, index string, query string, options *FTAggregateOptions) *AggregateCmd\n\tFTAliasAdd(ctx context.Context, index string, alias string) *StatusCmd\n\tFTAliasDel(ctx context.Context, alias string) *StatusCmd\n\tFTAliasUpdate(ctx context.Context, index string, alias string) *StatusCmd\n\tFTAlter(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *StatusCmd\n\tFTConfigGet(ctx context.Context, option string) *MapMapStringInterfaceCmd\n\tFTConfigSet(ctx context.Context, option string, value interface{}) *StatusCmd\n\tFTCreate(ctx context.Context, index string, options *FTCreateOptions, schema ...*FieldSchema) *StatusCmd\n\tFTCursorDel(ctx context.Context, index string, cursorId int) *StatusCmd\n\tFTCursorRead(ctx context.Context, index string, cursorId int, count int) *MapStringInterfaceCmd\n\tFTDictAdd(ctx context.Context, dict string, term ...interface{}) *IntCmd\n\tFTDictDel(ctx context.Context, dict string, term ...interface{}) *IntCmd\n\tFTDictDump(ctx context.Context, dict string) *StringSliceCmd\n\tFTDropIndex(ctx context.Context, index string) *StatusCmd\n\tFTDropIndexWithArgs(ctx context.Context, index string, options *FTDropIndexOptions) *StatusCmd\n\tFTExplain(ctx context.Context, index string, query string) *StringCmd\n\tFTExplainWithArgs(ctx context.Context, index string, query string, options *FTExplainOptions) *StringCmd\n\tFTInfo(ctx context.Context, index string) *FTInfoCmd\n\tFTSpellCheck(ctx context.Context, index string, query string) *FTSpellCheckCmd\n\tFTSpellCheckWithArgs(ctx context.Context, index string, query string, options *FTSpellCheckOptions) *FTSpellCheckCmd\n\tFTSearch(ctx context.Context, index string, query string) *FTSearchCmd\n\tFTSearchWithArgs(ctx context.Context, index string, query string, options *FTSearchOptions) *FTSearchCmd\n\tFTSynDump(ctx context.Context, index string) *FTSynDumpCmd\n\tFTSynUpdate(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *StatusCmd\n\tFTSynUpdateWithArgs(ctx context.Context, index string, synGroupId interface{}, options *FTSynUpdateOptions, terms []interface{}) *StatusCmd\n\tFTTagVals(ctx context.Context, index string, field string) *StringSliceCmd\n}\n\ntype FTCreateOptions struct {\n\tOnHash          bool\n\tOnJSON          bool\n\tPrefix          []interface{}\n\tFilter          string\n\tDefaultLanguage string\n\tLanguageField   string\n\tScore           float64\n\tScoreField      string\n\tPayloadField    string\n\tMaxTextFields   int\n\tNoOffsets       bool\n\tTemporary       int\n\tNoHL            bool\n\tNoFields        bool\n\tNoFreqs         bool\n\tStopWords       []interface{}\n\tSkipInitialScan bool\n}\n\ntype FieldSchema struct {\n\tFieldName         string\n\tAs                string\n\tFieldType         SearchFieldType\n\tSortable          bool\n\tUNF               bool\n\tNoStem            bool\n\tNoIndex           bool\n\tPhoneticMatcher   string\n\tWeight            float64\n\tSeparator         string\n\tCaseSensitive     bool\n\tWithSuffixtrie    bool\n\tVectorArgs        *FTVectorArgs\n\tGeoShapeFieldType string\n\tIndexEmpty        bool\n\tIndexMissing      bool\n}\n\ntype FTVectorArgs struct {\n\tFlatOptions *FTFlatOptions\n\tHNSWOptions *FTHNSWOptions\n}\n\ntype FTFlatOptions struct {\n\tType            string\n\tDim             int\n\tDistanceMetric  string\n\tInitialCapacity int\n\tBlockSize       int\n}\n\ntype FTHNSWOptions struct {\n\tType                   string\n\tDim                    int\n\tDistanceMetric         string\n\tInitialCapacity        int\n\tMaxEdgesPerNode        int\n\tMaxAllowedEdgesPerNode int\n\tEFRunTime              int\n\tEpsilon                float64\n}\n\ntype FTDropIndexOptions struct {\n\tDeleteDocs bool\n}\n\ntype SpellCheckTerms struct {\n\tInclude    bool\n\tExclude    bool\n\tDictionary string\n}\n\ntype FTExplainOptions struct {\n\tDialect string\n}\n\ntype FTSynUpdateOptions struct {\n\tSkipInitialScan bool\n}\n\ntype SearchAggregator int\n\nconst (\n\tSearchInvalid = SearchAggregator(iota)\n\tSearchAvg\n\tSearchSum\n\tSearchMin\n\tSearchMax\n\tSearchCount\n\tSearchCountDistinct\n\tSearchCountDistinctish\n\tSearchStdDev\n\tSearchQuantile\n\tSearchToList\n\tSearchFirstValue\n\tSearchRandomSample\n)\n\nfunc (a SearchAggregator) String() string {\n\tswitch a {\n\tcase SearchInvalid:\n\t\treturn \"\"\n\tcase SearchAvg:\n\t\treturn \"AVG\"\n\tcase SearchSum:\n\t\treturn \"SUM\"\n\tcase SearchMin:\n\t\treturn \"MIN\"\n\tcase SearchMax:\n\t\treturn \"MAX\"\n\tcase SearchCount:\n\t\treturn \"COUNT\"\n\tcase SearchCountDistinct:\n\t\treturn \"COUNT_DISTINCT\"\n\tcase SearchCountDistinctish:\n\t\treturn \"COUNT_DISTINCTISH\"\n\tcase SearchStdDev:\n\t\treturn \"STDDEV\"\n\tcase SearchQuantile:\n\t\treturn \"QUANTILE\"\n\tcase SearchToList:\n\t\treturn \"TOLIST\"\n\tcase SearchFirstValue:\n\t\treturn \"FIRST_VALUE\"\n\tcase SearchRandomSample:\n\t\treturn \"RANDOM_SAMPLE\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\ntype SearchFieldType int\n\nconst (\n\tSearchFieldTypeInvalid = SearchFieldType(iota)\n\tSearchFieldTypeNumeric\n\tSearchFieldTypeTag\n\tSearchFieldTypeText\n\tSearchFieldTypeGeo\n\tSearchFieldTypeVector\n\tSearchFieldTypeGeoShape\n)\n\nfunc (t SearchFieldType) String() string {\n\tswitch t {\n\tcase SearchFieldTypeInvalid:\n\t\treturn \"\"\n\tcase SearchFieldTypeNumeric:\n\t\treturn \"NUMERIC\"\n\tcase SearchFieldTypeTag:\n\t\treturn \"TAG\"\n\tcase SearchFieldTypeText:\n\t\treturn \"TEXT\"\n\tcase SearchFieldTypeGeo:\n\t\treturn \"GEO\"\n\tcase SearchFieldTypeVector:\n\t\treturn \"VECTOR\"\n\tcase SearchFieldTypeGeoShape:\n\t\treturn \"GEOSHAPE\"\n\tdefault:\n\t\treturn \"TEXT\"\n\t}\n}\n\n// Each AggregateReducer have different args.\n// Please follow https://redis.io/docs/interact/search-and-query/search/aggregations/#supported-groupby-reducers for more information.\ntype FTAggregateReducer struct {\n\tReducer SearchAggregator\n\tArgs    []interface{}\n\tAs      string\n}\n\ntype FTAggregateGroupBy struct {\n\tFields []interface{}\n\tReduce []FTAggregateReducer\n}\n\ntype FTAggregateSortBy struct {\n\tFieldName string\n\tAsc       bool\n\tDesc      bool\n}\n\ntype FTAggregateApply struct {\n\tField string\n\tAs    string\n}\n\ntype FTAggregateLoad struct {\n\tField string\n\tAs    string\n}\n\ntype FTAggregateWithCursor struct {\n\tCount   int\n\tMaxIdle int\n}\n\ntype FTAggregateOptions struct {\n\tVerbatim          bool\n\tLoadAll           bool\n\tLoad              []FTAggregateLoad\n\tTimeout           int\n\tGroupBy           []FTAggregateGroupBy\n\tSortBy            []FTAggregateSortBy\n\tSortByMax         int\n\tApply             []FTAggregateApply\n\tLimitOffset       int\n\tLimit             int\n\tFilter            string\n\tWithCursor        bool\n\tWithCursorOptions *FTAggregateWithCursor\n\tParams            map[string]interface{}\n\tDialectVersion    int\n}\n\ntype FTSearchFilter struct {\n\tFieldName interface{}\n\tMin       interface{}\n\tMax       interface{}\n}\n\ntype FTSearchGeoFilter struct {\n\tFieldName string\n\tLongitude float64\n\tLatitude  float64\n\tRadius    float64\n\tUnit      string\n}\n\ntype FTSearchReturn struct {\n\tFieldName string\n\tAs        string\n}\n\ntype FTSearchSortBy struct {\n\tFieldName string\n\tAsc       bool\n\tDesc      bool\n}\n\ntype FTSearchOptions struct {\n\tNoContent       bool\n\tVerbatim        bool\n\tNoStopWords     bool\n\tWithScores      bool\n\tWithPayloads    bool\n\tWithSortKeys    bool\n\tFilters         []FTSearchFilter\n\tGeoFilter       []FTSearchGeoFilter\n\tInKeys          []interface{}\n\tInFields        []interface{}\n\tReturn          []FTSearchReturn\n\tSlop            int\n\tTimeout         int\n\tInOrder         bool\n\tLanguage        string\n\tExpander        string\n\tScorer          string\n\tExplainScore    bool\n\tPayload         string\n\tSortBy          []FTSearchSortBy\n\tSortByWithCount bool\n\tLimitOffset     int\n\tLimit           int\n\tParams          map[string]interface{}\n\tDialectVersion  int\n}\n\ntype FTSynDumpResult struct {\n\tTerm     string\n\tSynonyms []string\n}\n\ntype FTSynDumpCmd struct {\n\tbaseCmd\n\tval []FTSynDumpResult\n}\n\ntype FTAggregateResult struct {\n\tTotal int\n\tRows  []AggregateRow\n}\n\ntype AggregateRow struct {\n\tFields map[string]interface{}\n}\n\ntype AggregateCmd struct {\n\tbaseCmd\n\tval *FTAggregateResult\n}\n\ntype FTInfoResult struct {\n\tIndexErrors              IndexErrors\n\tAttributes               []FTAttribute\n\tBytesPerRecordAvg        string\n\tCleaning                 int\n\tCursorStats              CursorStats\n\tDialectStats             map[string]int\n\tDocTableSizeMB           float64\n\tFieldStatistics          []FieldStatistic\n\tGCStats                  GCStats\n\tGeoshapesSzMB            float64\n\tHashIndexingFailures     int\n\tIndexDefinition          IndexDefinition\n\tIndexName                string\n\tIndexOptions             []string\n\tIndexing                 int\n\tInvertedSzMB             float64\n\tKeyTableSizeMB           float64\n\tMaxDocID                 int\n\tNumDocs                  int\n\tNumRecords               int\n\tNumTerms                 int\n\tNumberOfUses             int\n\tOffsetBitsPerRecordAvg   string\n\tOffsetVectorsSzMB        float64\n\tOffsetsPerTermAvg        string\n\tPercentIndexed           float64\n\tRecordsPerDocAvg         string\n\tSortableValuesSizeMB     float64\n\tTagOverheadSzMB          float64\n\tTextOverheadSzMB         float64\n\tTotalIndexMemorySzMB     float64\n\tTotalIndexingTime        int\n\tTotalInvertedIndexBlocks int\n\tVectorIndexSzMB          float64\n}\n\ntype IndexErrors struct {\n\tIndexingFailures     int\n\tLastIndexingError    string\n\tLastIndexingErrorKey string\n}\n\ntype FTAttribute struct {\n\tIdentifier      string\n\tAttribute       string\n\tType            string\n\tWeight          float64\n\tSortable        bool\n\tNoStem          bool\n\tNoIndex         bool\n\tUNF             bool\n\tPhoneticMatcher string\n\tCaseSensitive   bool\n\tWithSuffixtrie  bool\n}\n\ntype CursorStats struct {\n\tGlobalIdle    int\n\tGlobalTotal   int\n\tIndexCapacity int\n\tIndexTotal    int\n}\n\ntype FieldStatistic struct {\n\tIdentifier  string\n\tAttribute   string\n\tIndexErrors IndexErrors\n}\n\ntype GCStats struct {\n\tBytesCollected       int\n\tTotalMsRun           int\n\tTotalCycles          int\n\tAverageCycleTimeMs   string\n\tLastRunTimeMs        int\n\tGCNumericTreesMissed int\n\tGCBlocksDenied       int\n}\n\ntype IndexDefinition struct {\n\tKeyType      string\n\tPrefixes     []string\n\tDefaultScore float64\n}\n\ntype FTSpellCheckOptions struct {\n\tDistance int\n\tTerms    *FTSpellCheckTerms\n\tDialect  int\n}\n\ntype FTSpellCheckTerms struct {\n\tInclusion  string // Either \"INCLUDE\" or \"EXCLUDE\"\n\tDictionary string\n\tTerms      []interface{}\n}\n\ntype SpellCheckResult struct {\n\tTerm        string\n\tSuggestions []SpellCheckSuggestion\n}\n\ntype SpellCheckSuggestion struct {\n\tScore      float64\n\tSuggestion string\n}\n\ntype FTSearchResult struct {\n\tTotal int\n\tDocs  []Document\n}\n\ntype Document struct {\n\tID      string\n\tScore   *float64\n\tPayload *string\n\tSortKey *string\n\tFields  map[string]string\n}\n\ntype AggregateQuery []interface{}\n\n// FT_List - Lists all the existing indexes in the database.\n// For more information, please refer to the Redis documentation:\n// [FT._LIST]: (https://redis.io/commands/ft._list/)\nfunc (c cmdable) FT_List(ctx context.Context) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"FT._LIST\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTAggregate - Performs a search query on an index and applies a series of aggregate transformations to the result.\n// The 'index' parameter specifies the index to search, and the 'query' parameter specifies the search query.\n// For more information, please refer to the Redis documentation:\n// [FT.AGGREGATE]: (https://redis.io/commands/ft.aggregate/)\nfunc (c cmdable) FTAggregate(ctx context.Context, index string, query string) *MapStringInterfaceCmd {\n\targs := []interface{}{\"FT.AGGREGATE\", index, query}\n\tcmd := NewMapStringInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc FTAggregateQuery(query string, options *FTAggregateOptions) AggregateQuery {\n\tqueryArgs := []interface{}{query}\n\tif options != nil {\n\t\tif options.Verbatim {\n\t\t\tqueryArgs = append(queryArgs, \"VERBATIM\")\n\t\t}\n\t\tif options.LoadAll && options.Load != nil {\n\t\t\tpanic(\"FT.AGGREGATE: LOADALL and LOAD are mutually exclusive\")\n\t\t}\n\t\tif options.LoadAll {\n\t\t\tqueryArgs = append(queryArgs, \"LOAD\", \"*\")\n\t\t}\n\t\tif options.Load != nil {\n\t\t\tqueryArgs = append(queryArgs, \"LOAD\", len(options.Load))\n\t\t\tfor _, load := range options.Load {\n\t\t\t\tqueryArgs = append(queryArgs, load.Field)\n\t\t\t\tif load.As != \"\" {\n\t\t\t\t\tqueryArgs = append(queryArgs, \"AS\", load.As)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif options.Timeout > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"TIMEOUT\", options.Timeout)\n\t\t}\n\t\tif options.GroupBy != nil {\n\t\t\tfor _, groupBy := range options.GroupBy {\n\t\t\t\tqueryArgs = append(queryArgs, \"GROUPBY\", len(groupBy.Fields))\n\t\t\t\tqueryArgs = append(queryArgs, groupBy.Fields...)\n\n\t\t\t\tfor _, reducer := range groupBy.Reduce {\n\t\t\t\t\tqueryArgs = append(queryArgs, \"REDUCE\")\n\t\t\t\t\tqueryArgs = append(queryArgs, reducer.Reducer.String())\n\t\t\t\t\tif reducer.Args != nil {\n\t\t\t\t\t\tqueryArgs = append(queryArgs, len(reducer.Args))\n\t\t\t\t\t\tqueryArgs = append(queryArgs, reducer.Args...)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueryArgs = append(queryArgs, 0)\n\t\t\t\t\t}\n\t\t\t\t\tif reducer.As != \"\" {\n\t\t\t\t\t\tqueryArgs = append(queryArgs, \"AS\", reducer.As)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif options.SortBy != nil {\n\t\t\tqueryArgs = append(queryArgs, \"SORTBY\")\n\t\t\tsortByOptions := []interface{}{}\n\t\t\tfor _, sortBy := range options.SortBy {\n\t\t\t\tsortByOptions = append(sortByOptions, sortBy.FieldName)\n\t\t\t\tif sortBy.Asc && sortBy.Desc {\n\t\t\t\t\tpanic(\"FT.AGGREGATE: ASC and DESC are mutually exclusive\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Asc {\n\t\t\t\t\tsortByOptions = append(sortByOptions, \"ASC\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Desc {\n\t\t\t\t\tsortByOptions = append(sortByOptions, \"DESC\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueryArgs = append(queryArgs, len(sortByOptions))\n\t\t\tqueryArgs = append(queryArgs, sortByOptions...)\n\t\t}\n\t\tif options.SortByMax > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"MAX\", options.SortByMax)\n\t\t}\n\t\tfor _, apply := range options.Apply {\n\t\t\tqueryArgs = append(queryArgs, \"APPLY\", apply.Field)\n\t\t\tif apply.As != \"\" {\n\t\t\t\tqueryArgs = append(queryArgs, \"AS\", apply.As)\n\t\t\t}\n\t\t}\n\t\tif options.LimitOffset > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"LIMIT\", options.LimitOffset)\n\t\t}\n\t\tif options.Limit > 0 {\n\t\t\tqueryArgs = append(queryArgs, options.Limit)\n\t\t}\n\t\tif options.Filter != \"\" {\n\t\t\tqueryArgs = append(queryArgs, \"FILTER\", options.Filter)\n\t\t}\n\t\tif options.WithCursor {\n\t\t\tqueryArgs = append(queryArgs, \"WITHCURSOR\")\n\t\t\tif options.WithCursorOptions != nil {\n\t\t\t\tif options.WithCursorOptions.Count > 0 {\n\t\t\t\t\tqueryArgs = append(queryArgs, \"COUNT\", options.WithCursorOptions.Count)\n\t\t\t\t}\n\t\t\t\tif options.WithCursorOptions.MaxIdle > 0 {\n\t\t\t\t\tqueryArgs = append(queryArgs, \"MAXIDLE\", options.WithCursorOptions.MaxIdle)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif options.Params != nil {\n\t\t\tqueryArgs = append(queryArgs, \"PARAMS\", len(options.Params)*2)\n\t\t\tfor key, value := range options.Params {\n\t\t\t\tqueryArgs = append(queryArgs, key, value)\n\t\t\t}\n\t\t}\n\t\tif options.DialectVersion > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"DIALECT\", options.DialectVersion)\n\t\t}\n\t}\n\treturn queryArgs\n}\n\nfunc ProcessAggregateResult(data []interface{}) (*FTAggregateResult, error) {\n\tif len(data) == 0 {\n\t\treturn nil, fmt.Errorf(\"no data returned\")\n\t}\n\n\ttotal, ok := data[0].(int64)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"invalid total format\")\n\t}\n\n\trows := make([]AggregateRow, 0, len(data)-1)\n\tfor _, row := range data[1:] {\n\t\tfields, ok := row.([]interface{})\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"invalid row format\")\n\t\t}\n\n\t\trowMap := make(map[string]interface{})\n\t\tfor i := 0; i < len(fields); i += 2 {\n\t\t\tkey, ok := fields[i].(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid field key format\")\n\t\t\t}\n\t\t\tvalue := fields[i+1]\n\t\t\trowMap[key] = value\n\t\t}\n\t\trows = append(rows, AggregateRow{Fields: rowMap})\n\t}\n\n\tresult := &FTAggregateResult{\n\t\tTotal: int(total),\n\t\tRows:  rows,\n\t}\n\treturn result, nil\n}\n\nfunc NewAggregateCmd(ctx context.Context, args ...interface{}) *AggregateCmd {\n\treturn &AggregateCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *AggregateCmd) SetVal(val *FTAggregateResult) {\n\tcmd.val = val\n}\n\nfunc (cmd *AggregateCmd) Val() *FTAggregateResult {\n\treturn cmd.val\n}\n\nfunc (cmd *AggregateCmd) Result() (*FTAggregateResult, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *AggregateCmd) RawVal() interface{} {\n\treturn cmd.rawVal\n}\n\nfunc (cmd *AggregateCmd) RawResult() (interface{}, error) {\n\treturn cmd.rawVal, cmd.err\n}\n\nfunc (cmd *AggregateCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *AggregateCmd) readReply(rd *proto.Reader) (err error) {\n\tdata, err := rd.ReadSlice()\n\tif err != nil {\n\t\tcmd.err = err\n\t\treturn nil\n\t}\n\tcmd.val, err = ProcessAggregateResult(data)\n\tif err != nil {\n\t\tcmd.err = err\n\t}\n\treturn nil\n}\n\n// FTAggregateWithArgs - Performs a search query on an index and applies a series of aggregate transformations to the result.\n// The 'index' parameter specifies the index to search, and the 'query' parameter specifies the search query.\n// This function also allows for specifying additional options such as: Verbatim, LoadAll, Load, Timeout, GroupBy, SortBy, SortByMax, Apply, LimitOffset, Limit, Filter, WithCursor, Params, and DialectVersion.\n// For more information, please refer to the Redis documentation:\n// [FT.AGGREGATE]: (https://redis.io/commands/ft.aggregate/)\nfunc (c cmdable) FTAggregateWithArgs(ctx context.Context, index string, query string, options *FTAggregateOptions) *AggregateCmd {\n\targs := []interface{}{\"FT.AGGREGATE\", index, query}\n\tif options != nil {\n\t\tif options.Verbatim {\n\t\t\targs = append(args, \"VERBATIM\")\n\t\t}\n\t\tif options.LoadAll && options.Load != nil {\n\t\t\tpanic(\"FT.AGGREGATE: LOADALL and LOAD are mutually exclusive\")\n\t\t}\n\t\tif options.LoadAll {\n\t\t\targs = append(args, \"LOAD\", \"*\")\n\t\t}\n\t\tif options.Load != nil {\n\t\t\targs = append(args, \"LOAD\", len(options.Load))\n\t\t\tfor _, load := range options.Load {\n\t\t\t\targs = append(args, load.Field)\n\t\t\t\tif load.As != \"\" {\n\t\t\t\t\targs = append(args, \"AS\", load.As)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif options.Timeout > 0 {\n\t\t\targs = append(args, \"TIMEOUT\", options.Timeout)\n\t\t}\n\t\tif options.GroupBy != nil {\n\t\t\tfor _, groupBy := range options.GroupBy {\n\t\t\t\targs = append(args, \"GROUPBY\", len(groupBy.Fields))\n\t\t\t\targs = append(args, groupBy.Fields...)\n\n\t\t\t\tfor _, reducer := range groupBy.Reduce {\n\t\t\t\t\targs = append(args, \"REDUCE\")\n\t\t\t\t\targs = append(args, reducer.Reducer.String())\n\t\t\t\t\tif reducer.Args != nil {\n\t\t\t\t\t\targs = append(args, len(reducer.Args))\n\t\t\t\t\t\targs = append(args, reducer.Args...)\n\t\t\t\t\t} else {\n\t\t\t\t\t\targs = append(args, 0)\n\t\t\t\t\t}\n\t\t\t\t\tif reducer.As != \"\" {\n\t\t\t\t\t\targs = append(args, \"AS\", reducer.As)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif options.SortBy != nil {\n\t\t\targs = append(args, \"SORTBY\")\n\t\t\tsortByOptions := []interface{}{}\n\t\t\tfor _, sortBy := range options.SortBy {\n\t\t\t\tsortByOptions = append(sortByOptions, sortBy.FieldName)\n\t\t\t\tif sortBy.Asc && sortBy.Desc {\n\t\t\t\t\tpanic(\"FT.AGGREGATE: ASC and DESC are mutually exclusive\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Asc {\n\t\t\t\t\tsortByOptions = append(sortByOptions, \"ASC\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Desc {\n\t\t\t\t\tsortByOptions = append(sortByOptions, \"DESC\")\n\t\t\t\t}\n\t\t\t}\n\t\t\targs = append(args, len(sortByOptions))\n\t\t\targs = append(args, sortByOptions...)\n\t\t}\n\t\tif options.SortByMax > 0 {\n\t\t\targs = append(args, \"MAX\", options.SortByMax)\n\t\t}\n\t\tfor _, apply := range options.Apply {\n\t\t\targs = append(args, \"APPLY\", apply.Field)\n\t\t\tif apply.As != \"\" {\n\t\t\t\targs = append(args, \"AS\", apply.As)\n\t\t\t}\n\t\t}\n\t\tif options.LimitOffset > 0 {\n\t\t\targs = append(args, \"LIMIT\", options.LimitOffset)\n\t\t}\n\t\tif options.Limit > 0 {\n\t\t\targs = append(args, options.Limit)\n\t\t}\n\t\tif options.Filter != \"\" {\n\t\t\targs = append(args, \"FILTER\", options.Filter)\n\t\t}\n\t\tif options.WithCursor {\n\t\t\targs = append(args, \"WITHCURSOR\")\n\t\t\tif options.WithCursorOptions != nil {\n\t\t\t\tif options.WithCursorOptions.Count > 0 {\n\t\t\t\t\targs = append(args, \"COUNT\", options.WithCursorOptions.Count)\n\t\t\t\t}\n\t\t\t\tif options.WithCursorOptions.MaxIdle > 0 {\n\t\t\t\t\targs = append(args, \"MAXIDLE\", options.WithCursorOptions.MaxIdle)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif options.Params != nil {\n\t\t\targs = append(args, \"PARAMS\", len(options.Params)*2)\n\t\t\tfor key, value := range options.Params {\n\t\t\t\targs = append(args, key, value)\n\t\t\t}\n\t\t}\n\t\tif options.DialectVersion > 0 {\n\t\t\targs = append(args, \"DIALECT\", options.DialectVersion)\n\t\t}\n\t}\n\n\tcmd := NewAggregateCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTAliasAdd - Adds an alias to an index.\n// The 'index' parameter specifies the index to which the alias is added, and the 'alias' parameter specifies the alias.\n// For more information, please refer to the Redis documentation:\n// [FT.ALIASADD]: (https://redis.io/commands/ft.aliasadd/)\nfunc (c cmdable) FTAliasAdd(ctx context.Context, index string, alias string) *StatusCmd {\n\targs := []interface{}{\"FT.ALIASADD\", alias, index}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTAliasDel - Removes an alias from an index.\n// The 'alias' parameter specifies the alias to be removed.\n// For more information, please refer to the Redis documentation:\n// [FT.ALIASDEL]: (https://redis.io/commands/ft.aliasdel/)\nfunc (c cmdable) FTAliasDel(ctx context.Context, alias string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"FT.ALIASDEL\", alias)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTAliasUpdate - Updates an alias to an index.\n// The 'index' parameter specifies the index to which the alias is updated, and the 'alias' parameter specifies the alias.\n// If the alias already exists for a different index, it updates the alias to point to the specified index instead.\n// For more information, please refer to the Redis documentation:\n// [FT.ALIASUPDATE]: (https://redis.io/commands/ft.aliasupdate/)\nfunc (c cmdable) FTAliasUpdate(ctx context.Context, index string, alias string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"FT.ALIASUPDATE\", alias, index)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTAlter - Alters the definition of an existing index.\n// The 'index' parameter specifies the index to alter, and the 'skipInitialScan' parameter specifies whether to skip the initial scan.\n// The 'definition' parameter specifies the new definition for the index.\n// For more information, please refer to the Redis documentation:\n// [FT.ALTER]: (https://redis.io/commands/ft.alter/)\nfunc (c cmdable) FTAlter(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *StatusCmd {\n\targs := []interface{}{\"FT.ALTER\", index}\n\tif skipInitialScan {\n\t\targs = append(args, \"SKIPINITIALSCAN\")\n\t}\n\targs = append(args, \"SCHEMA\", \"ADD\")\n\targs = append(args, definition...)\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTConfigGet - Retrieves the value of a RediSearch configuration parameter.\n// The 'option' parameter specifies the configuration parameter to retrieve.\n// For more information, please refer to the Redis documentation:\n// [FT.CONFIG GET]: (https://redis.io/commands/ft.config-get/)\nfunc (c cmdable) FTConfigGet(ctx context.Context, option string) *MapMapStringInterfaceCmd {\n\tcmd := NewMapMapStringInterfaceCmd(ctx, \"FT.CONFIG\", \"GET\", option)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTConfigSet - Sets the value of a RediSearch configuration parameter.\n// The 'option' parameter specifies the configuration parameter to set, and the 'value' parameter specifies the new value.\n// For more information, please refer to the Redis documentation:\n// [FT.CONFIG SET]: (https://redis.io/commands/ft.config-set/)\nfunc (c cmdable) FTConfigSet(ctx context.Context, option string, value interface{}) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"FT.CONFIG\", \"SET\", option, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTCreate - Creates a new index with the given options and schema.\n// The 'index' parameter specifies the name of the index to create.\n// The 'options' parameter specifies various options for the index, such as:\n// whether to index hashes or JSONs, prefixes, filters, default language, score, score field, payload field, etc.\n// The 'schema' parameter specifies the schema for the index, which includes the field name, field type, etc.\n// For more information, please refer to the Redis documentation:\n// [FT.CREATE]: (https://redis.io/commands/ft.create/)\nfunc (c cmdable) FTCreate(ctx context.Context, index string, options *FTCreateOptions, schema ...*FieldSchema) *StatusCmd {\n\targs := []interface{}{\"FT.CREATE\", index}\n\tif options != nil {\n\t\tif options.OnHash && !options.OnJSON {\n\t\t\targs = append(args, \"ON\", \"HASH\")\n\t\t}\n\t\tif options.OnJSON && !options.OnHash {\n\t\t\targs = append(args, \"ON\", \"JSON\")\n\t\t}\n\t\tif options.OnHash && options.OnJSON {\n\t\t\tpanic(\"FT.CREATE: ON HASH and ON JSON are mutually exclusive\")\n\t\t}\n\t\tif options.Prefix != nil {\n\t\t\targs = append(args, \"PREFIX\", len(options.Prefix))\n\t\t\targs = append(args, options.Prefix...)\n\t\t}\n\t\tif options.Filter != \"\" {\n\t\t\targs = append(args, \"FILTER\", options.Filter)\n\t\t}\n\t\tif options.DefaultLanguage != \"\" {\n\t\t\targs = append(args, \"LANGUAGE\", options.DefaultLanguage)\n\t\t}\n\t\tif options.LanguageField != \"\" {\n\t\t\targs = append(args, \"LANGUAGE_FIELD\", options.LanguageField)\n\t\t}\n\t\tif options.Score > 0 {\n\t\t\targs = append(args, \"SCORE\", options.Score)\n\t\t}\n\t\tif options.ScoreField != \"\" {\n\t\t\targs = append(args, \"SCORE_FIELD\", options.ScoreField)\n\t\t}\n\t\tif options.PayloadField != \"\" {\n\t\t\targs = append(args, \"PAYLOAD_FIELD\", options.PayloadField)\n\t\t}\n\t\tif options.MaxTextFields > 0 {\n\t\t\targs = append(args, \"MAXTEXTFIELDS\", options.MaxTextFields)\n\t\t}\n\t\tif options.NoOffsets {\n\t\t\targs = append(args, \"NOOFFSETS\")\n\t\t}\n\t\tif options.Temporary > 0 {\n\t\t\targs = append(args, \"TEMPORARY\", options.Temporary)\n\t\t}\n\t\tif options.NoHL {\n\t\t\targs = append(args, \"NOHL\")\n\t\t}\n\t\tif options.NoFields {\n\t\t\targs = append(args, \"NOFIELDS\")\n\t\t}\n\t\tif options.NoFreqs {\n\t\t\targs = append(args, \"NOFREQS\")\n\t\t}\n\t\tif options.StopWords != nil {\n\t\t\targs = append(args, \"STOPWORDS\", len(options.StopWords))\n\t\t\targs = append(args, options.StopWords...)\n\t\t}\n\t\tif options.SkipInitialScan {\n\t\t\targs = append(args, \"SKIPINITIALSCAN\")\n\t\t}\n\t}\n\tif schema == nil {\n\t\tpanic(\"FT.CREATE: SCHEMA is required\")\n\t}\n\targs = append(args, \"SCHEMA\")\n\tfor _, schema := range schema {\n\t\tif schema.FieldName == \"\" || schema.FieldType == SearchFieldTypeInvalid {\n\t\t\tpanic(\"FT.CREATE: SCHEMA FieldName and FieldType are required\")\n\t\t}\n\t\targs = append(args, schema.FieldName)\n\t\tif schema.As != \"\" {\n\t\t\targs = append(args, \"AS\", schema.As)\n\t\t}\n\t\targs = append(args, schema.FieldType.String())\n\t\tif schema.VectorArgs != nil {\n\t\t\tif schema.FieldType != SearchFieldTypeVector {\n\t\t\t\tpanic(\"FT.CREATE: SCHEMA FieldType VECTOR is required for VectorArgs\")\n\t\t\t}\n\t\t\tif schema.VectorArgs.FlatOptions != nil && schema.VectorArgs.HNSWOptions != nil {\n\t\t\t\tpanic(\"FT.CREATE: SCHEMA VectorArgs FlatOptions and HNSWOptions are mutually exclusive\")\n\t\t\t}\n\t\t\tif schema.VectorArgs.FlatOptions != nil {\n\t\t\t\targs = append(args, \"FLAT\")\n\t\t\t\tif schema.VectorArgs.FlatOptions.Type == \"\" || schema.VectorArgs.FlatOptions.Dim == 0 || schema.VectorArgs.FlatOptions.DistanceMetric == \"\" {\n\t\t\t\t\tpanic(\"FT.CREATE: Type, Dim and DistanceMetric are required for VECTOR FLAT\")\n\t\t\t\t}\n\t\t\t\tflatArgs := []interface{}{\n\t\t\t\t\t\"TYPE\", schema.VectorArgs.FlatOptions.Type,\n\t\t\t\t\t\"DIM\", schema.VectorArgs.FlatOptions.Dim,\n\t\t\t\t\t\"DISTANCE_METRIC\", schema.VectorArgs.FlatOptions.DistanceMetric,\n\t\t\t\t}\n\t\t\t\tif schema.VectorArgs.FlatOptions.InitialCapacity > 0 {\n\t\t\t\t\tflatArgs = append(flatArgs, \"INITIAL_CAP\", schema.VectorArgs.FlatOptions.InitialCapacity)\n\t\t\t\t}\n\t\t\t\tif schema.VectorArgs.FlatOptions.BlockSize > 0 {\n\t\t\t\t\tflatArgs = append(flatArgs, \"BLOCK_SIZE\", schema.VectorArgs.FlatOptions.BlockSize)\n\t\t\t\t}\n\t\t\t\targs = append(args, len(flatArgs))\n\t\t\t\targs = append(args, flatArgs...)\n\t\t\t}\n\t\t\tif schema.VectorArgs.HNSWOptions != nil {\n\t\t\t\targs = append(args, \"HNSW\")\n\t\t\t\tif schema.VectorArgs.HNSWOptions.Type == \"\" || schema.VectorArgs.HNSWOptions.Dim == 0 || schema.VectorArgs.HNSWOptions.DistanceMetric == \"\" {\n\t\t\t\t\tpanic(\"FT.CREATE: Type, Dim and DistanceMetric are required for VECTOR HNSW\")\n\t\t\t\t}\n\t\t\t\thnswArgs := []interface{}{\n\t\t\t\t\t\"TYPE\", schema.VectorArgs.HNSWOptions.Type,\n\t\t\t\t\t\"DIM\", schema.VectorArgs.HNSWOptions.Dim,\n\t\t\t\t\t\"DISTANCE_METRIC\", schema.VectorArgs.HNSWOptions.DistanceMetric,\n\t\t\t\t}\n\t\t\t\tif schema.VectorArgs.HNSWOptions.InitialCapacity > 0 {\n\t\t\t\t\thnswArgs = append(hnswArgs, \"INITIAL_CAP\", schema.VectorArgs.HNSWOptions.InitialCapacity)\n\t\t\t\t}\n\t\t\t\tif schema.VectorArgs.HNSWOptions.MaxEdgesPerNode > 0 {\n\t\t\t\t\thnswArgs = append(hnswArgs, \"M\", schema.VectorArgs.HNSWOptions.MaxEdgesPerNode)\n\t\t\t\t}\n\t\t\t\tif schema.VectorArgs.HNSWOptions.MaxAllowedEdgesPerNode > 0 {\n\t\t\t\t\thnswArgs = append(hnswArgs, \"EF_CONSTRUCTION\", schema.VectorArgs.HNSWOptions.MaxAllowedEdgesPerNode)\n\t\t\t\t}\n\t\t\t\tif schema.VectorArgs.HNSWOptions.EFRunTime > 0 {\n\t\t\t\t\thnswArgs = append(hnswArgs, \"EF_RUNTIME\", schema.VectorArgs.HNSWOptions.EFRunTime)\n\t\t\t\t}\n\t\t\t\tif schema.VectorArgs.HNSWOptions.Epsilon > 0 {\n\t\t\t\t\thnswArgs = append(hnswArgs, \"EPSILON\", schema.VectorArgs.HNSWOptions.Epsilon)\n\t\t\t\t}\n\t\t\t\targs = append(args, len(hnswArgs))\n\t\t\t\targs = append(args, hnswArgs...)\n\t\t\t}\n\t\t}\n\t\tif schema.GeoShapeFieldType != \"\" {\n\t\t\tif schema.FieldType != SearchFieldTypeGeoShape {\n\t\t\t\tpanic(\"FT.CREATE: SCHEMA FieldType GEOSHAPE is required for GeoShapeFieldType\")\n\t\t\t}\n\t\t\targs = append(args, schema.GeoShapeFieldType)\n\t\t}\n\t\tif schema.NoStem {\n\t\t\targs = append(args, \"NOSTEM\")\n\t\t}\n\t\tif schema.Sortable {\n\t\t\targs = append(args, \"SORTABLE\")\n\t\t}\n\t\tif schema.UNF {\n\t\t\targs = append(args, \"UNF\")\n\t\t}\n\t\tif schema.NoIndex {\n\t\t\targs = append(args, \"NOINDEX\")\n\t\t}\n\t\tif schema.PhoneticMatcher != \"\" {\n\t\t\targs = append(args, \"PHONETIC\", schema.PhoneticMatcher)\n\t\t}\n\t\tif schema.Weight > 0 {\n\t\t\targs = append(args, \"WEIGHT\", schema.Weight)\n\t\t}\n\t\tif schema.Separator != \"\" {\n\t\t\targs = append(args, \"SEPARATOR\", schema.Separator)\n\t\t}\n\t\tif schema.CaseSensitive {\n\t\t\targs = append(args, \"CASESENSITIVE\")\n\t\t}\n\t\tif schema.WithSuffixtrie {\n\t\t\targs = append(args, \"WITHSUFFIXTRIE\")\n\t\t}\n\t\tif schema.IndexEmpty {\n\t\t\targs = append(args, \"INDEXEMPTY\")\n\t\t}\n\t\tif schema.IndexMissing {\n\t\t\targs = append(args, \"INDEXMISSING\")\n\n\t\t}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTCursorDel - Deletes a cursor from an existing index.\n// The 'index' parameter specifies the index from which to delete the cursor, and the 'cursorId' parameter specifies the ID of the cursor to delete.\n// For more information, please refer to the Redis documentation:\n// [FT.CURSOR DEL]: (https://redis.io/commands/ft.cursor-del/)\nfunc (c cmdable) FTCursorDel(ctx context.Context, index string, cursorId int) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"FT.CURSOR\", \"DEL\", index, cursorId)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTCursorRead - Reads the next results from an existing cursor.\n// The 'index' parameter specifies the index from which to read the cursor, the 'cursorId' parameter specifies the ID of the cursor to read, and the 'count' parameter specifies the number of results to read.\n// For more information, please refer to the Redis documentation:\n// [FT.CURSOR READ]: (https://redis.io/commands/ft.cursor-read/)\nfunc (c cmdable) FTCursorRead(ctx context.Context, index string, cursorId int, count int) *MapStringInterfaceCmd {\n\targs := []interface{}{\"FT.CURSOR\", \"READ\", index, cursorId}\n\tif count > 0 {\n\t\targs = append(args, \"COUNT\", count)\n\t}\n\tcmd := NewMapStringInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTDictAdd - Adds terms to a dictionary.\n// The 'dict' parameter specifies the dictionary to which to add the terms, and the 'term' parameter specifies the terms to add.\n// For more information, please refer to the Redis documentation:\n// [FT.DICTADD]: (https://redis.io/commands/ft.dictadd/)\nfunc (c cmdable) FTDictAdd(ctx context.Context, dict string, term ...interface{}) *IntCmd {\n\targs := []interface{}{\"FT.DICTADD\", dict}\n\targs = append(args, term...)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTDictDel - Deletes terms from a dictionary.\n// The 'dict' parameter specifies the dictionary from which to delete the terms, and the 'term' parameter specifies the terms to delete.\n// For more information, please refer to the Redis documentation:\n// [FT.DICTDEL]: (https://redis.io/commands/ft.dictdel/)\nfunc (c cmdable) FTDictDel(ctx context.Context, dict string, term ...interface{}) *IntCmd {\n\targs := []interface{}{\"FT.DICTDEL\", dict}\n\targs = append(args, term...)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTDictDump - Returns all terms in the specified dictionary.\n// The 'dict' parameter specifies the dictionary from which to return the terms.\n// For more information, please refer to the Redis documentation:\n// [FT.DICTDUMP]: (https://redis.io/commands/ft.dictdump/)\nfunc (c cmdable) FTDictDump(ctx context.Context, dict string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"FT.DICTDUMP\", dict)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTDropIndex - Deletes an index.\n// The 'index' parameter specifies the index to delete.\n// For more information, please refer to the Redis documentation:\n// [FT.DROPINDEX]: (https://redis.io/commands/ft.dropindex/)\nfunc (c cmdable) FTDropIndex(ctx context.Context, index string) *StatusCmd {\n\targs := []interface{}{\"FT.DROPINDEX\", index}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTDropIndexWithArgs - Deletes an index with options.\n// The 'index' parameter specifies the index to delete, and the 'options' parameter specifies the DeleteDocs option for docs deletion.\n// For more information, please refer to the Redis documentation:\n// [FT.DROPINDEX]: (https://redis.io/commands/ft.dropindex/)\nfunc (c cmdable) FTDropIndexWithArgs(ctx context.Context, index string, options *FTDropIndexOptions) *StatusCmd {\n\targs := []interface{}{\"FT.DROPINDEX\", index}\n\tif options != nil {\n\t\tif options.DeleteDocs {\n\t\t\targs = append(args, \"DD\")\n\t\t}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTExplain - Returns the execution plan for a complex query.\n// The 'index' parameter specifies the index to query, and the 'query' parameter specifies the query string.\n// For more information, please refer to the Redis documentation:\n// [FT.EXPLAIN]: (https://redis.io/commands/ft.explain/)\nfunc (c cmdable) FTExplain(ctx context.Context, index string, query string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"FT.EXPLAIN\", index, query)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTExplainWithArgs - Returns the execution plan for a complex query with options.\n// The 'index' parameter specifies the index to query, the 'query' parameter specifies the query string, and the 'options' parameter specifies the Dialect for the query.\n// For more information, please refer to the Redis documentation:\n// [FT.EXPLAIN]: (https://redis.io/commands/ft.explain/)\nfunc (c cmdable) FTExplainWithArgs(ctx context.Context, index string, query string, options *FTExplainOptions) *StringCmd {\n\targs := []interface{}{\"FT.EXPLAIN\", index, query}\n\tif options.Dialect != \"\" {\n\t\targs = append(args, \"DIALECT\", options.Dialect)\n\t}\n\tcmd := NewStringCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTExplainCli - Returns the execution plan for a complex query. [Not Implemented]\n// For more information, see https://redis.io/commands/ft.explaincli/\nfunc (c cmdable) FTExplainCli(ctx context.Context, key, path string) error {\n\tpanic(\"not implemented\")\n}\n\nfunc parseFTInfo(data map[string]interface{}) (FTInfoResult, error) {\n\tvar ftInfo FTInfoResult\n\t// Manually parse each field from the map\n\tif indexErrors, ok := data[\"Index Errors\"].([]interface{}); ok {\n\t\tftInfo.IndexErrors = IndexErrors{\n\t\t\tIndexingFailures:     internal.ToInteger(indexErrors[1]),\n\t\t\tLastIndexingError:    internal.ToString(indexErrors[3]),\n\t\t\tLastIndexingErrorKey: internal.ToString(indexErrors[5]),\n\t\t}\n\t}\n\n\tif attributes, ok := data[\"attributes\"].([]interface{}); ok {\n\t\tfor _, attr := range attributes {\n\t\t\tif attrMap, ok := attr.([]interface{}); ok {\n\t\t\t\tatt := FTAttribute{}\n\t\t\t\tfor i := 0; i < len(attrMap); i++ {\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"attribute\" {\n\t\t\t\t\t\tatt.Attribute = internal.ToString(attrMap[i+1])\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"identifier\" {\n\t\t\t\t\t\tatt.Identifier = internal.ToString(attrMap[i+1])\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"type\" {\n\t\t\t\t\t\tatt.Type = internal.ToString(attrMap[i+1])\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"weight\" {\n\t\t\t\t\t\tatt.Weight = internal.ToFloat(attrMap[i+1])\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"nostem\" {\n\t\t\t\t\t\tatt.NoStem = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"sortable\" {\n\t\t\t\t\t\tatt.Sortable = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"noindex\" {\n\t\t\t\t\t\tatt.NoIndex = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"unf\" {\n\t\t\t\t\t\tatt.UNF = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"phonetic\" {\n\t\t\t\t\t\tatt.PhoneticMatcher = internal.ToString(attrMap[i+1])\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"case_sensitive\" {\n\t\t\t\t\t\tatt.CaseSensitive = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif internal.ToLower(internal.ToString(attrMap[i])) == \"withsuffixtrie\" {\n\t\t\t\t\t\tatt.WithSuffixtrie = true\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tftInfo.Attributes = append(ftInfo.Attributes, att)\n\t\t\t}\n\t\t}\n\t}\n\n\tftInfo.BytesPerRecordAvg = internal.ToString(data[\"bytes_per_record_avg\"])\n\tftInfo.Cleaning = internal.ToInteger(data[\"cleaning\"])\n\n\tif cursorStats, ok := data[\"cursor_stats\"].([]interface{}); ok {\n\t\tftInfo.CursorStats = CursorStats{\n\t\t\tGlobalIdle:    internal.ToInteger(cursorStats[1]),\n\t\t\tGlobalTotal:   internal.ToInteger(cursorStats[3]),\n\t\t\tIndexCapacity: internal.ToInteger(cursorStats[5]),\n\t\t\tIndexTotal:    internal.ToInteger(cursorStats[7]),\n\t\t}\n\t}\n\n\tif dialectStats, ok := data[\"dialect_stats\"].([]interface{}); ok {\n\t\tftInfo.DialectStats = make(map[string]int)\n\t\tfor i := 0; i < len(dialectStats); i += 2 {\n\t\t\tftInfo.DialectStats[internal.ToString(dialectStats[i])] = internal.ToInteger(dialectStats[i+1])\n\t\t}\n\t}\n\n\tftInfo.DocTableSizeMB = internal.ToFloat(data[\"doc_table_size_mb\"])\n\n\tif fieldStats, ok := data[\"field statistics\"].([]interface{}); ok {\n\t\tfor _, stat := range fieldStats {\n\t\t\tif statMap, ok := stat.([]interface{}); ok {\n\t\t\t\tftInfo.FieldStatistics = append(ftInfo.FieldStatistics, FieldStatistic{\n\t\t\t\t\tIdentifier: internal.ToString(statMap[1]),\n\t\t\t\t\tAttribute:  internal.ToString(statMap[3]),\n\t\t\t\t\tIndexErrors: IndexErrors{\n\t\t\t\t\t\tIndexingFailures:     internal.ToInteger(statMap[5].([]interface{})[1]),\n\t\t\t\t\t\tLastIndexingError:    internal.ToString(statMap[5].([]interface{})[3]),\n\t\t\t\t\t\tLastIndexingErrorKey: internal.ToString(statMap[5].([]interface{})[5]),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif gcStats, ok := data[\"gc_stats\"].([]interface{}); ok {\n\t\tftInfo.GCStats = GCStats{}\n\t\tfor i := 0; i < len(gcStats); i += 2 {\n\t\t\tif internal.ToLower(internal.ToString(gcStats[i])) == \"bytes_collected\" {\n\t\t\t\tftInfo.GCStats.BytesCollected = internal.ToInteger(gcStats[i+1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif internal.ToLower(internal.ToString(gcStats[i])) == \"total_ms_run\" {\n\t\t\t\tftInfo.GCStats.TotalMsRun = internal.ToInteger(gcStats[i+1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif internal.ToLower(internal.ToString(gcStats[i])) == \"total_cycles\" {\n\t\t\t\tftInfo.GCStats.TotalCycles = internal.ToInteger(gcStats[i+1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif internal.ToLower(internal.ToString(gcStats[i])) == \"average_cycle_time_ms\" {\n\t\t\t\tftInfo.GCStats.AverageCycleTimeMs = internal.ToString(gcStats[i+1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif internal.ToLower(internal.ToString(gcStats[i])) == \"last_run_time_ms\" {\n\t\t\t\tftInfo.GCStats.LastRunTimeMs = internal.ToInteger(gcStats[i+1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif internal.ToLower(internal.ToString(gcStats[i])) == \"gc_numeric_trees_missed\" {\n\t\t\t\tftInfo.GCStats.GCNumericTreesMissed = internal.ToInteger(gcStats[i+1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif internal.ToLower(internal.ToString(gcStats[i])) == \"gc_blocks_denied\" {\n\t\t\t\tftInfo.GCStats.GCBlocksDenied = internal.ToInteger(gcStats[i+1])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\tftInfo.GeoshapesSzMB = internal.ToFloat(data[\"geoshapes_sz_mb\"])\n\tftInfo.HashIndexingFailures = internal.ToInteger(data[\"hash_indexing_failures\"])\n\n\tif indexDef, ok := data[\"index_definition\"].([]interface{}); ok {\n\t\tftInfo.IndexDefinition = IndexDefinition{\n\t\t\tKeyType:      internal.ToString(indexDef[1]),\n\t\t\tPrefixes:     internal.ToStringSlice(indexDef[3]),\n\t\t\tDefaultScore: internal.ToFloat(indexDef[5]),\n\t\t}\n\t}\n\n\tftInfo.IndexName = internal.ToString(data[\"index_name\"])\n\tftInfo.IndexOptions = internal.ToStringSlice(data[\"index_options\"].([]interface{}))\n\tftInfo.Indexing = internal.ToInteger(data[\"indexing\"])\n\tftInfo.InvertedSzMB = internal.ToFloat(data[\"inverted_sz_mb\"])\n\tftInfo.KeyTableSizeMB = internal.ToFloat(data[\"key_table_size_mb\"])\n\tftInfo.MaxDocID = internal.ToInteger(data[\"max_doc_id\"])\n\tftInfo.NumDocs = internal.ToInteger(data[\"num_docs\"])\n\tftInfo.NumRecords = internal.ToInteger(data[\"num_records\"])\n\tftInfo.NumTerms = internal.ToInteger(data[\"num_terms\"])\n\tftInfo.NumberOfUses = internal.ToInteger(data[\"number_of_uses\"])\n\tftInfo.OffsetBitsPerRecordAvg = internal.ToString(data[\"offset_bits_per_record_avg\"])\n\tftInfo.OffsetVectorsSzMB = internal.ToFloat(data[\"offset_vectors_sz_mb\"])\n\tftInfo.OffsetsPerTermAvg = internal.ToString(data[\"offsets_per_term_avg\"])\n\tftInfo.PercentIndexed = internal.ToFloat(data[\"percent_indexed\"])\n\tftInfo.RecordsPerDocAvg = internal.ToString(data[\"records_per_doc_avg\"])\n\tftInfo.SortableValuesSizeMB = internal.ToFloat(data[\"sortable_values_size_mb\"])\n\tftInfo.TagOverheadSzMB = internal.ToFloat(data[\"tag_overhead_sz_mb\"])\n\tftInfo.TextOverheadSzMB = internal.ToFloat(data[\"text_overhead_sz_mb\"])\n\tftInfo.TotalIndexMemorySzMB = internal.ToFloat(data[\"total_index_memory_sz_mb\"])\n\tftInfo.TotalIndexingTime = internal.ToInteger(data[\"total_indexing_time\"])\n\tftInfo.TotalInvertedIndexBlocks = internal.ToInteger(data[\"total_inverted_index_blocks\"])\n\tftInfo.VectorIndexSzMB = internal.ToFloat(data[\"vector_index_sz_mb\"])\n\n\treturn ftInfo, nil\n}\n\ntype FTInfoCmd struct {\n\tbaseCmd\n\tval FTInfoResult\n}\n\nfunc newFTInfoCmd(ctx context.Context, args ...interface{}) *FTInfoCmd {\n\treturn &FTInfoCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *FTInfoCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FTInfoCmd) SetVal(val FTInfoResult) {\n\tcmd.val = val\n}\n\nfunc (cmd *FTInfoCmd) Result() (FTInfoResult, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FTInfoCmd) Val() FTInfoResult {\n\treturn cmd.val\n}\n\nfunc (cmd *FTInfoCmd) RawVal() interface{} {\n\treturn cmd.rawVal\n}\n\nfunc (cmd *FTInfoCmd) RawResult() (interface{}, error) {\n\treturn cmd.rawVal, cmd.err\n}\nfunc (cmd *FTInfoCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdata := make(map[string]interface{}, n)\n\tfor i := 0; i < n; i++ {\n\t\tk, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tv, err := rd.ReadReply()\n\t\tif err != nil {\n\t\t\tif err == Nil {\n\t\t\t\tdata[k] = Nil\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif err, ok := err.(proto.RedisError); ok {\n\t\t\t\tdata[k] = err\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tdata[k] = v\n\t}\n\tcmd.val, err = parseFTInfo(data)\n\tif err != nil {\n\t\tcmd.err = err\n\t}\n\n\treturn nil\n}\n\n// FTInfo - Retrieves information about an index.\n// The 'index' parameter specifies the index to retrieve information about.\n// For more information, please refer to the Redis documentation:\n// [FT.INFO]: (https://redis.io/commands/ft.info/)\nfunc (c cmdable) FTInfo(ctx context.Context, index string) *FTInfoCmd {\n\tcmd := newFTInfoCmd(ctx, \"FT.INFO\", index)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTSpellCheck - Checks a query string for spelling errors.\n// For more details about spellcheck query please follow:\n// https://redis.io/docs/interact/search-and-query/advanced-concepts/spellcheck/\n// For more information, please refer to the Redis documentation:\n// [FT.SPELLCHECK]: (https://redis.io/commands/ft.spellcheck/)\nfunc (c cmdable) FTSpellCheck(ctx context.Context, index string, query string) *FTSpellCheckCmd {\n\targs := []interface{}{\"FT.SPELLCHECK\", index, query}\n\tcmd := newFTSpellCheckCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTSpellCheckWithArgs - Checks a query string for spelling errors with additional options.\n// For more details about spellcheck query please follow:\n// https://redis.io/docs/interact/search-and-query/advanced-concepts/spellcheck/\n// For more information, please refer to the Redis documentation:\n// [FT.SPELLCHECK]: (https://redis.io/commands/ft.spellcheck/)\nfunc (c cmdable) FTSpellCheckWithArgs(ctx context.Context, index string, query string, options *FTSpellCheckOptions) *FTSpellCheckCmd {\n\targs := []interface{}{\"FT.SPELLCHECK\", index, query}\n\tif options != nil {\n\t\tif options.Distance > 0 {\n\t\t\targs = append(args, \"DISTANCE\", options.Distance)\n\t\t}\n\t\tif options.Terms != nil {\n\t\t\targs = append(args, \"TERMS\", options.Terms.Inclusion, options.Terms.Dictionary)\n\t\t\targs = append(args, options.Terms.Terms...)\n\t\t}\n\t\tif options.Dialect > 0 {\n\t\t\targs = append(args, \"DIALECT\", options.Dialect)\n\t\t}\n\t}\n\tcmd := newFTSpellCheckCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype FTSpellCheckCmd struct {\n\tbaseCmd\n\tval []SpellCheckResult\n}\n\nfunc newFTSpellCheckCmd(ctx context.Context, args ...interface{}) *FTSpellCheckCmd {\n\treturn &FTSpellCheckCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *FTSpellCheckCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FTSpellCheckCmd) SetVal(val []SpellCheckResult) {\n\tcmd.val = val\n}\n\nfunc (cmd *FTSpellCheckCmd) Result() ([]SpellCheckResult, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FTSpellCheckCmd) Val() []SpellCheckResult {\n\treturn cmd.val\n}\n\nfunc (cmd *FTSpellCheckCmd) RawVal() interface{} {\n\treturn cmd.rawVal\n}\n\nfunc (cmd *FTSpellCheckCmd) RawResult() (interface{}, error) {\n\treturn cmd.rawVal, cmd.err\n}\n\nfunc (cmd *FTSpellCheckCmd) readReply(rd *proto.Reader) (err error) {\n\tdata, err := rd.ReadSlice()\n\tif err != nil {\n\t\tcmd.err = err\n\t\treturn nil\n\t}\n\tcmd.val, err = parseFTSpellCheck(data)\n\tif err != nil {\n\t\tcmd.err = err\n\t}\n\treturn nil\n}\n\nfunc parseFTSpellCheck(data []interface{}) ([]SpellCheckResult, error) {\n\tresults := make([]SpellCheckResult, 0, len(data))\n\n\tfor _, termData := range data {\n\t\ttermInfo, ok := termData.([]interface{})\n\t\tif !ok || len(termInfo) != 3 {\n\t\t\treturn nil, fmt.Errorf(\"invalid term format\")\n\t\t}\n\n\t\tterm, ok := termInfo[1].(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"invalid term format\")\n\t\t}\n\n\t\tsuggestionsData, ok := termInfo[2].([]interface{})\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"invalid suggestions format\")\n\t\t}\n\n\t\tsuggestions := make([]SpellCheckSuggestion, 0, len(suggestionsData))\n\t\tfor _, suggestionData := range suggestionsData {\n\t\t\tsuggestionInfo, ok := suggestionData.([]interface{})\n\t\t\tif !ok || len(suggestionInfo) != 2 {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid suggestion format\")\n\t\t\t}\n\n\t\t\tscoreStr, ok := suggestionInfo[0].(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid suggestion score format\")\n\t\t\t}\n\t\t\tscore, err := strconv.ParseFloat(scoreStr, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid suggestion score value\")\n\t\t\t}\n\n\t\t\tsuggestion, ok := suggestionInfo[1].(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid suggestion format\")\n\t\t\t}\n\n\t\t\tsuggestions = append(suggestions, SpellCheckSuggestion{\n\t\t\t\tScore:      score,\n\t\t\t\tSuggestion: suggestion,\n\t\t\t})\n\t\t}\n\n\t\tresults = append(results, SpellCheckResult{\n\t\t\tTerm:        term,\n\t\t\tSuggestions: suggestions,\n\t\t})\n\t}\n\n\treturn results, nil\n}\n\nfunc parseFTSearch(data []interface{}, noContent, withScores, withPayloads, withSortKeys bool) (FTSearchResult, error) {\n\tif len(data) < 1 {\n\t\treturn FTSearchResult{}, fmt.Errorf(\"unexpected search result format\")\n\t}\n\n\ttotal, ok := data[0].(int64)\n\tif !ok {\n\t\treturn FTSearchResult{}, fmt.Errorf(\"invalid total results format\")\n\t}\n\n\tvar results []Document\n\tfor i := 1; i < len(data); {\n\t\tdocID, ok := data[i].(string)\n\t\tif !ok {\n\t\t\treturn FTSearchResult{}, fmt.Errorf(\"invalid document ID format\")\n\t\t}\n\n\t\tdoc := Document{\n\t\t\tID:     docID,\n\t\t\tFields: make(map[string]string),\n\t\t}\n\t\ti++\n\n\t\tif noContent {\n\t\t\tresults = append(results, doc)\n\t\t\tcontinue\n\t\t}\n\n\t\tif withScores && i < len(data) {\n\t\t\tif scoreStr, ok := data[i].(string); ok {\n\t\t\t\tscore, err := strconv.ParseFloat(scoreStr, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn FTSearchResult{}, fmt.Errorf(\"invalid score format\")\n\t\t\t\t}\n\t\t\t\tdoc.Score = &score\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tif withPayloads && i < len(data) {\n\t\t\tif payload, ok := data[i].(string); ok {\n\t\t\t\tdoc.Payload = &payload\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tif withSortKeys && i < len(data) {\n\t\t\tif sortKey, ok := data[i].(string); ok {\n\t\t\t\tdoc.SortKey = &sortKey\n\t\t\t\ti++\n\t\t\t}\n\t\t}\n\n\t\tif i < len(data) {\n\t\t\tfields, ok := data[i].([]interface{})\n\t\t\tif !ok {\n\t\t\t\treturn FTSearchResult{}, fmt.Errorf(\"invalid document fields format\")\n\t\t\t}\n\n\t\t\tfor j := 0; j < len(fields); j += 2 {\n\t\t\t\tkey, ok := fields[j].(string)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn FTSearchResult{}, fmt.Errorf(\"invalid field key format\")\n\t\t\t\t}\n\t\t\t\tvalue, ok := fields[j+1].(string)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn FTSearchResult{}, fmt.Errorf(\"invalid field value format\")\n\t\t\t\t}\n\t\t\t\tdoc.Fields[key] = value\n\t\t\t}\n\t\t\ti++\n\t\t}\n\n\t\tresults = append(results, doc)\n\t}\n\treturn FTSearchResult{\n\t\tTotal: int(total),\n\t\tDocs:  results,\n\t}, nil\n}\n\ntype FTSearchCmd struct {\n\tbaseCmd\n\tval     FTSearchResult\n\toptions *FTSearchOptions\n}\n\nfunc newFTSearchCmd(ctx context.Context, options *FTSearchOptions, args ...interface{}) *FTSearchCmd {\n\treturn &FTSearchCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t\toptions: options,\n\t}\n}\n\nfunc (cmd *FTSearchCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FTSearchCmd) SetVal(val FTSearchResult) {\n\tcmd.val = val\n}\n\nfunc (cmd *FTSearchCmd) Result() (FTSearchResult, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FTSearchCmd) Val() FTSearchResult {\n\treturn cmd.val\n}\n\nfunc (cmd *FTSearchCmd) RawVal() interface{} {\n\treturn cmd.rawVal\n}\n\nfunc (cmd *FTSearchCmd) RawResult() (interface{}, error) {\n\treturn cmd.rawVal, cmd.err\n}\n\nfunc (cmd *FTSearchCmd) readReply(rd *proto.Reader) (err error) {\n\tdata, err := rd.ReadSlice()\n\tif err != nil {\n\t\tcmd.err = err\n\t\treturn nil\n\t}\n\tcmd.val, err = parseFTSearch(data, cmd.options.NoContent, cmd.options.WithScores, cmd.options.WithPayloads, cmd.options.WithSortKeys)\n\tif err != nil {\n\t\tcmd.err = err\n\t}\n\treturn nil\n}\n\n// FTSearch - Executes a search query on an index.\n// The 'index' parameter specifies the index to search, and the 'query' parameter specifies the search query.\n// For more information, please refer to the Redis documentation:\n// [FT.SEARCH]: (https://redis.io/commands/ft.search/)\nfunc (c cmdable) FTSearch(ctx context.Context, index string, query string) *FTSearchCmd {\n\targs := []interface{}{\"FT.SEARCH\", index, query}\n\tcmd := newFTSearchCmd(ctx, &FTSearchOptions{}, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype SearchQuery []interface{}\n\nfunc FTSearchQuery(query string, options *FTSearchOptions) SearchQuery {\n\tqueryArgs := []interface{}{query}\n\tif options != nil {\n\t\tif options.NoContent {\n\t\t\tqueryArgs = append(queryArgs, \"NOCONTENT\")\n\t\t}\n\t\tif options.Verbatim {\n\t\t\tqueryArgs = append(queryArgs, \"VERBATIM\")\n\t\t}\n\t\tif options.NoStopWords {\n\t\t\tqueryArgs = append(queryArgs, \"NOSTOPWORDS\")\n\t\t}\n\t\tif options.WithScores {\n\t\t\tqueryArgs = append(queryArgs, \"WITHSCORES\")\n\t\t}\n\t\tif options.WithPayloads {\n\t\t\tqueryArgs = append(queryArgs, \"WITHPAYLOADS\")\n\t\t}\n\t\tif options.WithSortKeys {\n\t\t\tqueryArgs = append(queryArgs, \"WITHSORTKEYS\")\n\t\t}\n\t\tif options.Filters != nil {\n\t\t\tfor _, filter := range options.Filters {\n\t\t\t\tqueryArgs = append(queryArgs, \"FILTER\", filter.FieldName, filter.Min, filter.Max)\n\t\t\t}\n\t\t}\n\t\tif options.GeoFilter != nil {\n\t\t\tfor _, geoFilter := range options.GeoFilter {\n\t\t\t\tqueryArgs = append(queryArgs, \"GEOFILTER\", geoFilter.FieldName, geoFilter.Longitude, geoFilter.Latitude, geoFilter.Radius, geoFilter.Unit)\n\t\t\t}\n\t\t}\n\t\tif options.InKeys != nil {\n\t\t\tqueryArgs = append(queryArgs, \"INKEYS\", len(options.InKeys))\n\t\t\tqueryArgs = append(queryArgs, options.InKeys...)\n\t\t}\n\t\tif options.InFields != nil {\n\t\t\tqueryArgs = append(queryArgs, \"INFIELDS\", len(options.InFields))\n\t\t\tqueryArgs = append(queryArgs, options.InFields...)\n\t\t}\n\t\tif options.Return != nil {\n\t\t\tqueryArgs = append(queryArgs, \"RETURN\")\n\t\t\tqueryArgsReturn := []interface{}{}\n\t\t\tfor _, ret := range options.Return {\n\t\t\t\tqueryArgsReturn = append(queryArgsReturn, ret.FieldName)\n\t\t\t\tif ret.As != \"\" {\n\t\t\t\t\tqueryArgsReturn = append(queryArgsReturn, \"AS\", ret.As)\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueryArgs = append(queryArgs, len(queryArgsReturn))\n\t\t\tqueryArgs = append(queryArgs, queryArgsReturn...)\n\t\t}\n\t\tif options.Slop > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"SLOP\", options.Slop)\n\t\t}\n\t\tif options.Timeout > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"TIMEOUT\", options.Timeout)\n\t\t}\n\t\tif options.InOrder {\n\t\t\tqueryArgs = append(queryArgs, \"INORDER\")\n\t\t}\n\t\tif options.Language != \"\" {\n\t\t\tqueryArgs = append(queryArgs, \"LANGUAGE\", options.Language)\n\t\t}\n\t\tif options.Expander != \"\" {\n\t\t\tqueryArgs = append(queryArgs, \"EXPANDER\", options.Expander)\n\t\t}\n\t\tif options.Scorer != \"\" {\n\t\t\tqueryArgs = append(queryArgs, \"SCORER\", options.Scorer)\n\t\t}\n\t\tif options.ExplainScore {\n\t\t\tqueryArgs = append(queryArgs, \"EXPLAINSCORE\")\n\t\t}\n\t\tif options.Payload != \"\" {\n\t\t\tqueryArgs = append(queryArgs, \"PAYLOAD\", options.Payload)\n\t\t}\n\t\tif options.SortBy != nil {\n\t\t\tqueryArgs = append(queryArgs, \"SORTBY\")\n\t\t\tfor _, sortBy := range options.SortBy {\n\t\t\t\tqueryArgs = append(queryArgs, sortBy.FieldName)\n\t\t\t\tif sortBy.Asc && sortBy.Desc {\n\t\t\t\t\tpanic(\"FT.SEARCH: ASC and DESC are mutually exclusive\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Asc {\n\t\t\t\t\tqueryArgs = append(queryArgs, \"ASC\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Desc {\n\t\t\t\t\tqueryArgs = append(queryArgs, \"DESC\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif options.SortByWithCount {\n\t\t\t\tqueryArgs = append(queryArgs, \"WITHCOUNT\")\n\t\t\t}\n\t\t}\n\t\tif options.LimitOffset >= 0 && options.Limit > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"LIMIT\", options.LimitOffset, options.Limit)\n\t\t}\n\t\tif options.Params != nil {\n\t\t\tqueryArgs = append(queryArgs, \"PARAMS\", len(options.Params)*2)\n\t\t\tfor key, value := range options.Params {\n\t\t\t\tqueryArgs = append(queryArgs, key, value)\n\t\t\t}\n\t\t}\n\t\tif options.DialectVersion > 0 {\n\t\t\tqueryArgs = append(queryArgs, \"DIALECT\", options.DialectVersion)\n\t\t}\n\t}\n\treturn queryArgs\n}\n\n// FTSearchWithArgs - Executes a search query on an index with additional options.\n// The 'index' parameter specifies the index to search, the 'query' parameter specifies the search query,\n// and the 'options' parameter specifies additional options for the search.\n// For more information, please refer to the Redis documentation:\n// [FT.SEARCH]: (https://redis.io/commands/ft.search/)\nfunc (c cmdable) FTSearchWithArgs(ctx context.Context, index string, query string, options *FTSearchOptions) *FTSearchCmd {\n\targs := []interface{}{\"FT.SEARCH\", index, query}\n\tif options != nil {\n\t\tif options.NoContent {\n\t\t\targs = append(args, \"NOCONTENT\")\n\t\t}\n\t\tif options.Verbatim {\n\t\t\targs = append(args, \"VERBATIM\")\n\t\t}\n\t\tif options.NoStopWords {\n\t\t\targs = append(args, \"NOSTOPWORDS\")\n\t\t}\n\t\tif options.WithScores {\n\t\t\targs = append(args, \"WITHSCORES\")\n\t\t}\n\t\tif options.WithPayloads {\n\t\t\targs = append(args, \"WITHPAYLOADS\")\n\t\t}\n\t\tif options.WithSortKeys {\n\t\t\targs = append(args, \"WITHSORTKEYS\")\n\t\t}\n\t\tif options.Filters != nil {\n\t\t\tfor _, filter := range options.Filters {\n\t\t\t\targs = append(args, \"FILTER\", filter.FieldName, filter.Min, filter.Max)\n\t\t\t}\n\t\t}\n\t\tif options.GeoFilter != nil {\n\t\t\tfor _, geoFilter := range options.GeoFilter {\n\t\t\t\targs = append(args, \"GEOFILTER\", geoFilter.FieldName, geoFilter.Longitude, geoFilter.Latitude, geoFilter.Radius, geoFilter.Unit)\n\t\t\t}\n\t\t}\n\t\tif options.InKeys != nil {\n\t\t\targs = append(args, \"INKEYS\", len(options.InKeys))\n\t\t\targs = append(args, options.InKeys...)\n\t\t}\n\t\tif options.InFields != nil {\n\t\t\targs = append(args, \"INFIELDS\", len(options.InFields))\n\t\t\targs = append(args, options.InFields...)\n\t\t}\n\t\tif options.Return != nil {\n\t\t\targs = append(args, \"RETURN\")\n\t\t\targsReturn := []interface{}{}\n\t\t\tfor _, ret := range options.Return {\n\t\t\t\targsReturn = append(argsReturn, ret.FieldName)\n\t\t\t\tif ret.As != \"\" {\n\t\t\t\t\targsReturn = append(argsReturn, \"AS\", ret.As)\n\t\t\t\t}\n\t\t\t}\n\t\t\targs = append(args, len(argsReturn))\n\t\t\targs = append(args, argsReturn...)\n\t\t}\n\t\tif options.Slop > 0 {\n\t\t\targs = append(args, \"SLOP\", options.Slop)\n\t\t}\n\t\tif options.Timeout > 0 {\n\t\t\targs = append(args, \"TIMEOUT\", options.Timeout)\n\t\t}\n\t\tif options.InOrder {\n\t\t\targs = append(args, \"INORDER\")\n\t\t}\n\t\tif options.Language != \"\" {\n\t\t\targs = append(args, \"LANGUAGE\", options.Language)\n\t\t}\n\t\tif options.Expander != \"\" {\n\t\t\targs = append(args, \"EXPANDER\", options.Expander)\n\t\t}\n\t\tif options.Scorer != \"\" {\n\t\t\targs = append(args, \"SCORER\", options.Scorer)\n\t\t}\n\t\tif options.ExplainScore {\n\t\t\targs = append(args, \"EXPLAINSCORE\")\n\t\t}\n\t\tif options.Payload != \"\" {\n\t\t\targs = append(args, \"PAYLOAD\", options.Payload)\n\t\t}\n\t\tif options.SortBy != nil {\n\t\t\targs = append(args, \"SORTBY\")\n\t\t\tfor _, sortBy := range options.SortBy {\n\t\t\t\targs = append(args, sortBy.FieldName)\n\t\t\t\tif sortBy.Asc && sortBy.Desc {\n\t\t\t\t\tpanic(\"FT.SEARCH: ASC and DESC are mutually exclusive\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Asc {\n\t\t\t\t\targs = append(args, \"ASC\")\n\t\t\t\t}\n\t\t\t\tif sortBy.Desc {\n\t\t\t\t\targs = append(args, \"DESC\")\n\t\t\t\t}\n\t\t\t}\n\t\t\tif options.SortByWithCount {\n\t\t\t\targs = append(args, \"WITHCOUT\")\n\t\t\t}\n\t\t}\n\t\tif options.LimitOffset >= 0 && options.Limit > 0 {\n\t\t\targs = append(args, \"LIMIT\", options.LimitOffset, options.Limit)\n\t\t}\n\t\tif options.Params != nil {\n\t\t\targs = append(args, \"PARAMS\", len(options.Params)*2)\n\t\t\tfor key, value := range options.Params {\n\t\t\t\targs = append(args, key, value)\n\t\t\t}\n\t\t}\n\t\tif options.DialectVersion > 0 {\n\t\t\targs = append(args, \"DIALECT\", options.DialectVersion)\n\t\t}\n\t}\n\tcmd := newFTSearchCmd(ctx, options, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc NewFTSynDumpCmd(ctx context.Context, args ...interface{}) *FTSynDumpCmd {\n\treturn &FTSynDumpCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *FTSynDumpCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *FTSynDumpCmd) SetVal(val []FTSynDumpResult) {\n\tcmd.val = val\n}\n\nfunc (cmd *FTSynDumpCmd) Val() []FTSynDumpResult {\n\treturn cmd.val\n}\n\nfunc (cmd *FTSynDumpCmd) Result() ([]FTSynDumpResult, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *FTSynDumpCmd) RawVal() interface{} {\n\treturn cmd.rawVal\n}\n\nfunc (cmd *FTSynDumpCmd) RawResult() (interface{}, error) {\n\treturn cmd.rawVal, cmd.err\n}\n\nfunc (cmd *FTSynDumpCmd) readReply(rd *proto.Reader) error {\n\ttermSynonymPairs, err := rd.ReadSlice()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar results []FTSynDumpResult\n\tfor i := 0; i < len(termSynonymPairs); i += 2 {\n\t\tterm, ok := termSynonymPairs[i].(string)\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"invalid term format\")\n\t\t}\n\n\t\tsynonyms, ok := termSynonymPairs[i+1].([]interface{})\n\t\tif !ok {\n\t\t\treturn fmt.Errorf(\"invalid synonyms format\")\n\t\t}\n\n\t\tsynonymList := make([]string, len(synonyms))\n\t\tfor j, syn := range synonyms {\n\t\t\tsynonym, ok := syn.(string)\n\t\t\tif !ok {\n\t\t\t\treturn fmt.Errorf(\"invalid synonym format\")\n\t\t\t}\n\t\t\tsynonymList[j] = synonym\n\t\t}\n\n\t\tresults = append(results, FTSynDumpResult{\n\t\t\tTerm:     term,\n\t\t\tSynonyms: synonymList,\n\t\t})\n\t}\n\n\tcmd.val = results\n\treturn nil\n}\n\n// FTSynDump - Dumps the contents of a synonym group.\n// The 'index' parameter specifies the index to dump.\n// For more information, please refer to the Redis documentation:\n// [FT.SYNDUMP]: (https://redis.io/commands/ft.syndump/)\nfunc (c cmdable) FTSynDump(ctx context.Context, index string) *FTSynDumpCmd {\n\tcmd := NewFTSynDumpCmd(ctx, \"FT.SYNDUMP\", index)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTSynUpdate - Creates or updates a synonym group with additional terms.\n// The 'index' parameter specifies the index to update, the 'synGroupId' parameter specifies the synonym group id, and the 'terms' parameter specifies the additional terms.\n// For more information, please refer to the Redis documentation:\n// [FT.SYNUPDATE]: (https://redis.io/commands/ft.synupdate/)\nfunc (c cmdable) FTSynUpdate(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *StatusCmd {\n\targs := []interface{}{\"FT.SYNUPDATE\", index, synGroupId}\n\targs = append(args, terms...)\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTSynUpdateWithArgs - Creates or updates a synonym group with additional terms and options.\n// The 'index' parameter specifies the index to update, the 'synGroupId' parameter specifies the synonym group id, the 'options' parameter specifies additional options for the update, and the 'terms' parameter specifies the additional terms.\n// For more information, please refer to the Redis documentation:\n// [FT.SYNUPDATE]: (https://redis.io/commands/ft.synupdate/)\nfunc (c cmdable) FTSynUpdateWithArgs(ctx context.Context, index string, synGroupId interface{}, options *FTSynUpdateOptions, terms []interface{}) *StatusCmd {\n\targs := []interface{}{\"FT.SYNUPDATE\", index, synGroupId}\n\tif options.SkipInitialScan {\n\t\targs = append(args, \"SKIPINITIALSCAN\")\n\t}\n\targs = append(args, terms...)\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// FTTagVals - Returns all distinct values indexed in a tag field.\n// The 'index' parameter specifies the index to check, and the 'field' parameter specifies the tag field to retrieve values from.\n// For more information, please refer to the Redis documentation:\n// [FT.TAGVALS]: (https://redis.io/commands/ft.tagvals/)\nfunc (c cmdable) FTTagVals(ctx context.Context, index string, field string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"FT.TAGVALS\", index, field)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// type FTProfileResult struct {\n// \tResults []interface{}\n// \tProfile ProfileDetails\n// }\n\n// type ProfileDetails struct {\n// \tTotalProfileTime        string\n// \tParsingTime             string\n// \tPipelineCreationTime    string\n// \tWarning                 string\n// \tIteratorsProfile        []IteratorProfile\n// \tResultProcessorsProfile []ResultProcessorProfile\n// }\n\n// type IteratorProfile struct {\n// \tType           string\n// \tQueryType      string\n// \tTime           interface{}\n// \tCounter        int\n// \tTerm           string\n// \tSize           int\n// \tChildIterators []IteratorProfile\n// }\n\n// type ResultProcessorProfile struct {\n// \tType    string\n// \tTime    interface{}\n// \tCounter int\n// }\n\n// func parseFTProfileResult(data []interface{}) (FTProfileResult, error) {\n// \tvar result FTProfileResult\n// \tif len(data) < 2 {\n// \t\treturn result, fmt.Errorf(\"unexpected data length\")\n// \t}\n\n// \t// Parse results\n// \tresult.Results = data[0].([]interface{})\n\n// \t// Parse profile details\n// \tprofileData := data[1].([]interface{})\n// \tprofileDetails := ProfileDetails{}\n// \tfor i := 0; i < len(profileData); i += 2 {\n// \t\tswitch profileData[i].(string) {\n// \t\tcase \"Total profile time\":\n// \t\t\tprofileDetails.TotalProfileTime = profileData[i+1].(string)\n// \t\tcase \"Parsing time\":\n// \t\t\tprofileDetails.ParsingTime = profileData[i+1].(string)\n// \t\tcase \"Pipeline creation time\":\n// \t\t\tprofileDetails.PipelineCreationTime = profileData[i+1].(string)\n// \t\tcase \"Warning\":\n// \t\t\tprofileDetails.Warning = profileData[i+1].(string)\n// \t\tcase \"Iterators profile\":\n// \t\t\tprofileDetails.IteratorsProfile = parseIteratorsProfile(profileData[i+1].([]interface{}))\n// \t\tcase \"Result processors profile\":\n// \t\t\tprofileDetails.ResultProcessorsProfile = parseResultProcessorsProfile(profileData[i+1].([]interface{}))\n// \t\t}\n// \t}\n\n// \tresult.Profile = profileDetails\n// \treturn result, nil\n// }\n\n// func parseIteratorsProfile(data []interface{}) []IteratorProfile {\n// \tvar iterators []IteratorProfile\n// \tfor _, item := range data {\n// \t\tprofile := item.([]interface{})\n// \t\titerator := IteratorProfile{}\n// \t\tfor i := 0; i < len(profile); i += 2 {\n// \t\t\tswitch profile[i].(string) {\n// \t\t\tcase \"Type\":\n// \t\t\t\titerator.Type = profile[i+1].(string)\n// \t\t\tcase \"Query type\":\n// \t\t\t\titerator.QueryType = profile[i+1].(string)\n// \t\t\tcase \"Time\":\n// \t\t\t\titerator.Time = profile[i+1]\n// \t\t\tcase \"Counter\":\n// \t\t\t\titerator.Counter = int(profile[i+1].(int64))\n// \t\t\tcase \"Term\":\n// \t\t\t\titerator.Term = profile[i+1].(string)\n// \t\t\tcase \"Size\":\n// \t\t\t\titerator.Size = int(profile[i+1].(int64))\n// \t\t\tcase \"Child iterators\":\n// \t\t\t\titerator.ChildIterators = parseChildIteratorsProfile(profile[i+1].([]interface{}))\n// \t\t\t}\n// \t\t}\n// \t\titerators = append(iterators, iterator)\n// \t}\n// \treturn iterators\n// }\n\n// func parseChildIteratorsProfile(data []interface{}) []IteratorProfile {\n// \tvar iterators []IteratorProfile\n// \tfor _, item := range data {\n// \t\tprofile := item.([]interface{})\n// \t\titerator := IteratorProfile{}\n// \t\tfor i := 0; i < len(profile); i += 2 {\n// \t\t\tswitch profile[i].(string) {\n// \t\t\tcase \"Type\":\n// \t\t\t\titerator.Type = profile[i+1].(string)\n// \t\t\tcase \"Query type\":\n// \t\t\t\titerator.QueryType = profile[i+1].(string)\n// \t\t\tcase \"Time\":\n// \t\t\t\titerator.Time = profile[i+1]\n// \t\t\tcase \"Counter\":\n// \t\t\t\titerator.Counter = int(profile[i+1].(int64))\n// \t\t\tcase \"Term\":\n// \t\t\t\titerator.Term = profile[i+1].(string)\n// \t\t\tcase \"Size\":\n// \t\t\t\titerator.Size = int(profile[i+1].(int64))\n// \t\t\t}\n// \t\t}\n// \t\titerators = append(iterators, iterator)\n// \t}\n// \treturn iterators\n// }\n\n// func parseResultProcessorsProfile(data []interface{}) []ResultProcessorProfile {\n// \tvar processors []ResultProcessorProfile\n// \tfor _, item := range data {\n// \t\tprofile := item.([]interface{})\n// \t\tprocessor := ResultProcessorProfile{}\n// \t\tfor i := 0; i < len(profile); i += 2 {\n// \t\t\tswitch profile[i].(string) {\n// \t\t\tcase \"Type\":\n// \t\t\t\tprocessor.Type = profile[i+1].(string)\n// \t\t\tcase \"Time\":\n// \t\t\t\tprocessor.Time = profile[i+1]\n// \t\t\tcase \"Counter\":\n// \t\t\t\tprocessor.Counter = int(profile[i+1].(int64))\n// \t\t\t}\n// \t\t}\n// \t\tprocessors = append(processors, processor)\n// \t}\n// \treturn processors\n// }\n\n// func NewFTProfileCmd(ctx context.Context, args ...interface{}) *FTProfileCmd {\n// \treturn &FTProfileCmd{\n// \t\tbaseCmd: baseCmd{\n// \t\t\tctx:  ctx,\n// \t\t\targs: args,\n// \t\t},\n// \t}\n// }\n\n// type FTProfileCmd struct {\n// \tbaseCmd\n// \tval FTProfileResult\n// }\n\n// func (cmd *FTProfileCmd) String() string {\n// \treturn cmdString(cmd, cmd.val)\n// }\n\n// func (cmd *FTProfileCmd) SetVal(val FTProfileResult) {\n// \tcmd.val = val\n// }\n\n// func (cmd *FTProfileCmd) Result() (FTProfileResult, error) {\n// \treturn cmd.val, cmd.err\n// }\n\n// func (cmd *FTProfileCmd) Val() FTProfileResult {\n// \treturn cmd.val\n// }\n\n// func (cmd *FTProfileCmd) readReply(rd *proto.Reader) (err error) {\n// \tdata, err := rd.ReadSlice()\n// \tif err != nil {\n// \t\treturn err\n// \t}\n// \tcmd.val, err = parseFTProfileResult(data)\n// \tif err != nil {\n// \t\tcmd.err = err\n// \t}\n// \treturn nil\n// }\n\n// // FTProfile - Executes a search query and returns a profile of how the query was processed.\n// // The 'index' parameter specifies the index to search, the 'limited' parameter specifies whether to limit the results,\n// // and the 'query' parameter specifies the search / aggreagte query. Please notice that you must either pass a SearchQuery or an AggregateQuery.\n// // For more information, please refer to the Redis documentation:\n// // [FT.PROFILE]: (https://redis.io/commands/ft.profile/)\n// func (c cmdable) FTProfile(ctx context.Context, index string, limited bool, query interface{}) *FTProfileCmd {\n// \tqueryType := \"\"\n// \tvar argsQuery []interface{}\n\n// \tswitch v := query.(type) {\n// \tcase AggregateQuery:\n// \t\tqueryType = \"AGGREGATE\"\n// \t\targsQuery = v\n// \tcase SearchQuery:\n// \t\tqueryType = \"SEARCH\"\n// \t\targsQuery = v\n// \tdefault:\n// \t\tpanic(\"FT.PROFILE: query must be either AggregateQuery or SearchQuery\")\n// \t}\n\n// \targs := []interface{}{\"FT.PROFILE\", index, queryType}\n\n// \tif limited {\n// \t\targs = append(args, \"LIMITED\")\n// \t}\n// \targs = append(args, \"QUERY\")\n// \targs = append(args, argsQuery...)\n\n// \tcmd := NewFTProfileCmd(ctx, args...)\n// \t_ = c(ctx, cmd)\n// \treturn cmd\n// }\n"
        },
        {
          "name": "search_test.go",
          "type": "blob",
          "size": 79.7900390625,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\t\"github.com/redis/go-redis/v9\"\n)\n\nfunc WaitForIndexing(c *redis.Client, index string) {\n\tfor {\n\t\tres, err := c.FTInfo(context.Background(), index).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tif c.Options().Protocol == 2 {\n\t\t\tif res.Indexing == 0 {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t} else {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nvar _ = Describe(\"RediSearch commands Resp 2\", Label(\"search\"), func() {\n\tctx := context.TODO()\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(&redis.Options{Addr: \":6379\", Protocol: 2})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should FTCreate and FTSearch WithScores\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"txt\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"txt\")\n\t\tclient.HSet(ctx, \"doc1\", \"txt\", \"foo baz\")\n\t\tclient.HSet(ctx, \"doc2\", \"txt\", \"foo bar\")\n\t\tres, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo ~bar\", &redis.FTSearchOptions{WithScores: true}).Result()\n\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(int64(2)))\n\t\tfor _, doc := range res.Docs {\n\t\t\tExpect(*doc.Score).To(BeNumerically(\">\", 0))\n\t\t\tExpect(doc.ID).To(Or(Equal(\"doc1\"), Equal(\"doc2\")))\n\t\t}\n\t})\n\n\tIt(\"should FTCreate and FTSearch stopwords\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"txt\", &redis.FTCreateOptions{StopWords: []interface{}{\"foo\", \"bar\", \"baz\"}}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"txt\")\n\t\tclient.HSet(ctx, \"doc1\", \"txt\", \"foo baz\")\n\t\tclient.HSet(ctx, \"doc2\", \"txt\", \"hello world\")\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo bar\", &redis.FTSearchOptions{NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(0)))\n\t\tres2, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo bar hello world\", &redis.FTSearchOptions{NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res2.Total).To(BeEquivalentTo(int64(1)))\n\t})\n\n\tIt(\"should FTCreate and FTSearch filters\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"txt\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText}, &redis.FieldSchema{FieldName: \"num\", FieldType: redis.SearchFieldTypeNumeric}, &redis.FieldSchema{FieldName: \"loc\", FieldType: redis.SearchFieldTypeGeo}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"txt\")\n\t\tclient.HSet(ctx, \"doc1\", \"txt\", \"foo bar\", \"num\", 3.141, \"loc\", \"-0.441,51.458\")\n\t\tclient.HSet(ctx, \"doc2\", \"txt\", \"foo baz\", \"num\", 2, \"loc\", \"-0.1,51.2\")\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo\", &redis.FTSearchOptions{Filters: []redis.FTSearchFilter{{FieldName: \"num\", Min: 0, Max: 2}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(1)))\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"doc2\"))\n\t\tres2, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo\", &redis.FTSearchOptions{Filters: []redis.FTSearchFilter{{FieldName: \"num\", Min: 0, Max: \"+inf\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res2.Total).To(BeEquivalentTo(int64(2)))\n\t\tExpect(res2.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\t// Test Geo filter\n\t\tgeoFilter1 := redis.FTSearchGeoFilter{FieldName: \"loc\", Longitude: -0.44, Latitude: 51.45, Radius: 10, Unit: \"km\"}\n\t\tgeoFilter2 := redis.FTSearchGeoFilter{FieldName: \"loc\", Longitude: -0.44, Latitude: 51.45, Radius: 100, Unit: \"km\"}\n\t\tres3, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo\", &redis.FTSearchOptions{GeoFilter: []redis.FTSearchGeoFilter{geoFilter1}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res3.Total).To(BeEquivalentTo(int64(1)))\n\t\tExpect(res3.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tres4, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo\", &redis.FTSearchOptions{GeoFilter: []redis.FTSearchGeoFilter{geoFilter2}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res4.Total).To(BeEquivalentTo(int64(2)))\n\t\tdocs := []interface{}{res4.Docs[0].ID, res4.Docs[1].ID}\n\t\tExpect(docs).To(ContainElement(\"doc1\"))\n\t\tExpect(docs).To(ContainElement(\"doc2\"))\n\n\t})\n\n\tIt(\"should FTCreate and FTSearch sortby\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"num\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText}, &redis.FieldSchema{FieldName: \"num\", FieldType: redis.SearchFieldTypeNumeric, Sortable: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"num\")\n\t\tclient.HSet(ctx, \"doc1\", \"txt\", \"foo bar\", \"num\", 1)\n\t\tclient.HSet(ctx, \"doc2\", \"txt\", \"foo baz\", \"num\", 2)\n\t\tclient.HSet(ctx, \"doc3\", \"txt\", \"foo qux\", \"num\", 3)\n\n\t\tsortBy1 := redis.FTSearchSortBy{FieldName: \"num\", Asc: true}\n\t\tsortBy2 := redis.FTSearchSortBy{FieldName: \"num\", Desc: true}\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"num\", \"foo\", &redis.FTSearchOptions{NoContent: true, SortBy: []redis.FTSearchSortBy{sortBy1}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(3)))\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tExpect(res1.Docs[1].ID).To(BeEquivalentTo(\"doc2\"))\n\t\tExpect(res1.Docs[2].ID).To(BeEquivalentTo(\"doc3\"))\n\n\t\tres2, err := client.FTSearchWithArgs(ctx, \"num\", \"foo\", &redis.FTSearchOptions{NoContent: true, SortBy: []redis.FTSearchSortBy{sortBy2}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res2.Total).To(BeEquivalentTo(int64(3)))\n\t\tExpect(res2.Docs[2].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tExpect(res2.Docs[1].ID).To(BeEquivalentTo(\"doc2\"))\n\t\tExpect(res2.Docs[0].ID).To(BeEquivalentTo(\"doc3\"))\n\n\t\tres3, err := client.FTSearchWithArgs(ctx, \"num\", \"foo\", &redis.FTSearchOptions{NoContent: true, SortBy: []redis.FTSearchSortBy{sortBy2}, SortByWithCount: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res3.Total).To(BeEquivalentTo(int64(0)))\n\n\t})\n\n\tIt(\"should FTCreate and FTSearch example\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"txt\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"title\", FieldType: redis.SearchFieldTypeText, Weight: 5}, &redis.FieldSchema{FieldName: \"body\", FieldType: redis.SearchFieldTypeText}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"txt\")\n\t\tclient.HSet(ctx, \"doc1\", \"title\", \"RediSearch\", \"body\", \"Redisearch impements a search engine on top of redis\")\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"txt\", \"search engine\", &redis.FTSearchOptions{NoContent: true, Verbatim: true, LimitOffset: 0, Limit: 5}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(1)))\n\n\t})\n\n\tIt(\"should FTCreate NoIndex\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"field\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"text\", FieldType: redis.SearchFieldTypeText, NoIndex: true, Sortable: true}\n\t\tnum := &redis.FieldSchema{FieldName: \"numeric\", FieldType: redis.SearchFieldTypeNumeric, NoIndex: true, Sortable: true}\n\t\tgeo := &redis.FieldSchema{FieldName: \"geo\", FieldType: redis.SearchFieldTypeGeo, NoIndex: true, Sortable: true}\n\t\ttag := &redis.FieldSchema{FieldName: \"tag\", FieldType: redis.SearchFieldTypeTag, NoIndex: true, Sortable: true}\n\t\tval, err := client.FTCreate(ctx, \"idx\", &redis.FTCreateOptions{}, text1, text2, num, geo, tag).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx\")\n\t\tclient.HSet(ctx, \"doc1\", \"field\", \"aaa\", \"text\", \"1\", \"numeric\", 1, \"geo\", \"1,1\", \"tag\", \"1\")\n\t\tclient.HSet(ctx, \"doc2\", \"field\", \"aab\", \"text\", \"2\", \"numeric\", 2, \"geo\", \"2,2\", \"tag\", \"2\")\n\t\tres1, err := client.FTSearch(ctx, \"idx\", \"@text:aa*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(0)))\n\t\tres2, err := client.FTSearch(ctx, \"idx\", \"@field:aa*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res2.Total).To(BeEquivalentTo(int64(2)))\n\t\tres3, err := client.FTSearchWithArgs(ctx, \"idx\", \"*\", &redis.FTSearchOptions{SortBy: []redis.FTSearchSortBy{{FieldName: \"text\", Desc: true}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res3.Total).To(BeEquivalentTo(int64(2)))\n\t\tExpect(res3.Docs[0].ID).To(BeEquivalentTo(\"doc2\"))\n\t\tres4, err := client.FTSearchWithArgs(ctx, \"idx\", \"*\", &redis.FTSearchOptions{SortBy: []redis.FTSearchSortBy{{FieldName: \"text\", Asc: true}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res4.Total).To(BeEquivalentTo(int64(2)))\n\t\tExpect(res4.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tres5, err := client.FTSearchWithArgs(ctx, \"idx\", \"*\", &redis.FTSearchOptions{SortBy: []redis.FTSearchSortBy{{FieldName: \"numeric\", Asc: true}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res5.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tres6, err := client.FTSearchWithArgs(ctx, \"idx\", \"*\", &redis.FTSearchOptions{SortBy: []redis.FTSearchSortBy{{FieldName: \"geo\", Asc: true}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res6.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tres7, err := client.FTSearchWithArgs(ctx, \"idx\", \"*\", &redis.FTSearchOptions{SortBy: []redis.FTSearchSortBy{{FieldName: \"tag\", Asc: true}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res7.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\n\t})\n\n\tIt(\"should FTExplain\", Label(\"search\", \"ftexplain\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"f1\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"f2\", FieldType: redis.SearchFieldTypeText}\n\t\ttext3 := &redis.FieldSchema{FieldName: \"f3\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"txt\", &redis.FTCreateOptions{}, text1, text2, text3).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"txt\")\n\t\tres1, err := client.FTExplain(ctx, \"txt\", \"@f3:f3_val @f2:f2_val @f1:f1_val\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1).ToNot(BeEmpty())\n\n\t})\n\n\tIt(\"should FTAlias\", Label(\"search\", \"ftexplain\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"name\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"name\", FieldType: redis.SearchFieldTypeText}\n\t\tval1, err := client.FTCreate(ctx, \"testAlias\", &redis.FTCreateOptions{Prefix: []interface{}{\"index1:\"}}, text1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val1).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"testAlias\")\n\t\tval2, err := client.FTCreate(ctx, \"testAlias2\", &redis.FTCreateOptions{Prefix: []interface{}{\"index2:\"}}, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val2).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"testAlias2\")\n\n\t\tclient.HSet(ctx, \"index1:lonestar\", \"name\", \"lonestar\")\n\t\tclient.HSet(ctx, \"index2:yogurt\", \"name\", \"yogurt\")\n\n\t\tres1, err := client.FTSearch(ctx, \"testAlias\", \"*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"index1:lonestar\"))\n\n\t\taliasAddRes, err := client.FTAliasAdd(ctx, \"testAlias\", \"mj23\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(aliasAddRes).To(BeEquivalentTo(\"OK\"))\n\n\t\tres1, err = client.FTSearch(ctx, \"mj23\", \"*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"index1:lonestar\"))\n\n\t\taliasUpdateRes, err := client.FTAliasUpdate(ctx, \"testAlias2\", \"kb24\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(aliasUpdateRes).To(BeEquivalentTo(\"OK\"))\n\n\t\tres3, err := client.FTSearch(ctx, \"kb24\", \"*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res3.Docs[0].ID).To(BeEquivalentTo(\"index2:yogurt\"))\n\n\t\taliasDelRes, err := client.FTAliasDel(ctx, \"mj23\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(aliasDelRes).To(BeEquivalentTo(\"OK\"))\n\n\t})\n\n\tIt(\"should FTCreate and FTSearch textfield, sortable and nostem \", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText, Sortable: true, NoStem: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tresInfo, err := client.FTInfo(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resInfo.Attributes[0].Sortable).To(BeTrue())\n\t\tExpect(resInfo.Attributes[0].NoStem).To(BeTrue())\n\n\t})\n\n\tIt(\"should FTAlter\", Label(\"search\", \"ftcreate\", \"ftsearch\", \"ftalter\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tresAlter, err := client.FTAlter(ctx, \"idx1\", false, []interface{}{\"body\", redis.SearchFieldTypeText.String()}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resAlter).To(BeEquivalentTo(\"OK\"))\n\n\t\tclient.HSet(ctx, \"doc1\", \"title\", \"MyTitle\", \"body\", \"Some content only in the body\")\n\t\tres1, err := client.FTSearch(ctx, \"idx1\", \"only in the body\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(1)))\n\n\t})\n\n\tIt(\"should FTSpellCheck\", Label(\"search\", \"ftcreate\", \"ftsearch\", \"ftspellcheck\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"f1\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"f2\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"f1\", \"some valid content\", \"f2\", \"this is sample text\")\n\t\tclient.HSet(ctx, \"doc2\", \"f1\", \"very important\", \"f2\", \"lorem ipsum\")\n\n\t\tresSpellCheck, err := client.FTSpellCheck(ctx, \"idx1\", \"impornant\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSpellCheck[0].Suggestions[0].Suggestion).To(BeEquivalentTo(\"important\"))\n\n\t\tresSpellCheck2, err := client.FTSpellCheck(ctx, \"idx1\", \"contnt\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSpellCheck2[0].Suggestions[0].Suggestion).To(BeEquivalentTo(\"content\"))\n\n\t\t// test spellcheck with Levenshtein distance\n\t\tresSpellCheck3, err := client.FTSpellCheck(ctx, \"idx1\", \"vlis\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSpellCheck3[0].Term).To(BeEquivalentTo(\"vlis\"))\n\n\t\tresSpellCheck4, err := client.FTSpellCheckWithArgs(ctx, \"idx1\", \"vlis\", &redis.FTSpellCheckOptions{Distance: 2}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSpellCheck4[0].Suggestions[0].Suggestion).To(BeEquivalentTo(\"valid\"))\n\n\t\t// test spellcheck include\n\t\tresDictAdd, err := client.FTDictAdd(ctx, \"dict\", \"lore\", \"lorem\", \"lorm\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDictAdd).To(BeEquivalentTo(3))\n\t\tterms := &redis.FTSpellCheckTerms{Inclusion: \"INCLUDE\", Dictionary: \"dict\"}\n\t\tresSpellCheck5, err := client.FTSpellCheckWithArgs(ctx, \"idx1\", \"lorm\", &redis.FTSpellCheckOptions{Terms: terms}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tlorm := resSpellCheck5[0].Suggestions\n\t\tExpect(len(lorm)).To(BeEquivalentTo(3))\n\t\tExpect(lorm[0].Score).To(BeEquivalentTo(0.5))\n\t\tExpect(lorm[1].Score).To(BeEquivalentTo(0))\n\t\tExpect(lorm[2].Score).To(BeEquivalentTo(0))\n\n\t\tterms2 := &redis.FTSpellCheckTerms{Inclusion: \"EXCLUDE\", Dictionary: \"dict\"}\n\t\tresSpellCheck6, err := client.FTSpellCheckWithArgs(ctx, \"idx1\", \"lorm\", &redis.FTSpellCheckOptions{Terms: terms2}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSpellCheck6).To(BeEmpty())\n\t})\n\n\tIt(\"should FTDict opreations\", Label(\"search\", \"ftdictdump\", \"ftdictdel\", \"ftdictadd\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"f1\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"f2\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tresDictAdd, err := client.FTDictAdd(ctx, \"custom_dict\", \"item1\", \"item2\", \"item3\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDictAdd).To(BeEquivalentTo(3))\n\n\t\tresDictDel, err := client.FTDictDel(ctx, \"custom_dict\", \"item2\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDictDel).To(BeEquivalentTo(1))\n\n\t\tresDictDump, err := client.FTDictDump(ctx, \"custom_dict\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDictDump).To(BeEquivalentTo([]string{\"item1\", \"item3\"}))\n\n\t\tresDictDel2, err := client.FTDictDel(ctx, \"custom_dict\", \"item1\", \"item3\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDictDel2).To(BeEquivalentTo(2))\n\t})\n\n\tIt(\"should FTSearch phonetic matcher\", Label(\"search\", \"ftsearch\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"name\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"name\", \"Jon\")\n\t\tclient.HSet(ctx, \"doc2\", \"name\", \"John\")\n\n\t\tres1, err := client.FTSearch(ctx, \"idx1\", \"Jon\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(1)))\n\t\tExpect(res1.Docs[0].Fields[\"name\"]).To(BeEquivalentTo(\"Jon\"))\n\n\t\tclient.FlushDB(ctx)\n\t\ttext2 := &redis.FieldSchema{FieldName: \"name\", FieldType: redis.SearchFieldTypeText, PhoneticMatcher: \"dm:en\"}\n\t\tval2, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val2).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"name\", \"Jon\")\n\t\tclient.HSet(ctx, \"doc2\", \"name\", \"John\")\n\n\t\tres2, err := client.FTSearch(ctx, \"idx1\", \"Jon\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res2.Total).To(BeEquivalentTo(int64(2)))\n\t\tnames := []interface{}{res2.Docs[0].Fields[\"name\"], res2.Docs[1].Fields[\"name\"]}\n\t\tExpect(names).To(ContainElement(\"Jon\"))\n\t\tExpect(names).To(ContainElement(\"John\"))\n\t})\n\n\tIt(\"should FTSearch WithScores\", Label(\"search\", \"ftsearch\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"description\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"description\", \"The quick brown fox jumps over the lazy dog\")\n\t\tclient.HSet(ctx, \"doc2\", \"description\", \"Quick alice was beginning to get very tired of sitting by her quick sister on the bank, and of having nothing to do.\")\n\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"quick\", &redis.FTSearchOptions{WithScores: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(*res.Docs[0].Score).To(BeEquivalentTo(float64(1)))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"quick\", &redis.FTSearchOptions{WithScores: true, Scorer: \"TFIDF\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(*res.Docs[0].Score).To(BeEquivalentTo(float64(1)))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"quick\", &redis.FTSearchOptions{WithScores: true, Scorer: \"TFIDF.DOCNORM\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(*res.Docs[0].Score).To(BeEquivalentTo(0.14285714285714285))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"quick\", &redis.FTSearchOptions{WithScores: true, Scorer: \"BM25\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(*res.Docs[0].Score).To(BeNumerically(\"<=\", 0.22471909420069797))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"quick\", &redis.FTSearchOptions{WithScores: true, Scorer: \"DISMAX\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(*res.Docs[0].Score).To(BeEquivalentTo(float64(2)))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"quick\", &redis.FTSearchOptions{WithScores: true, Scorer: \"DOCSCORE\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(*res.Docs[0].Score).To(BeEquivalentTo(float64(1)))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"quick\", &redis.FTSearchOptions{WithScores: true, Scorer: \"HAMMING\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(*res.Docs[0].Score).To(BeEquivalentTo(float64(0)))\n\t})\n\n\tIt(\"should FTConfigSet and FTConfigGet \", Label(\"search\", \"ftconfigget\", \"ftconfigset\", \"NonRedisEnterprise\"), func() {\n\t\tval, err := client.FTConfigSet(ctx, \"TIMEOUT\", \"100\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\n\t\tres, err := client.FTConfigGet(ctx, \"*\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res[\"TIMEOUT\"]).To(BeEquivalentTo(\"100\"))\n\n\t\tres, err = client.FTConfigGet(ctx, \"TIMEOUT\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res).To(BeEquivalentTo(map[string]interface{}{\"TIMEOUT\": \"100\"}))\n\n\t})\n\n\tIt(\"should FTAggregate GroupBy \", Label(\"search\", \"ftaggregate\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"title\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"body\", FieldType: redis.SearchFieldTypeText}\n\t\ttext3 := &redis.FieldSchema{FieldName: \"parent\", FieldType: redis.SearchFieldTypeText}\n\t\tnum := &redis.FieldSchema{FieldName: \"random_num\", FieldType: redis.SearchFieldTypeNumeric}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, text2, text3, num).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"search\", \"title\", \"RediSearch\",\n\t\t\t\"body\", \"Redisearch impements a search engine on top of redis\",\n\t\t\t\"parent\", \"redis\",\n\t\t\t\"random_num\", 10)\n\t\tclient.HSet(ctx, \"ai\", \"title\", \"RedisAI\",\n\t\t\t\"body\", \"RedisAI executes Deep Learning/Machine Learning models and managing their data.\",\n\t\t\t\"parent\", \"redis\",\n\t\t\t\"random_num\", 3)\n\t\tclient.HSet(ctx, \"json\", \"title\", \"RedisJson\",\n\t\t\t\"body\", \"RedisJSON implements ECMA-404 The JSON Data Interchange Standard as a native data type.\",\n\t\t\t\"parent\", \"redis\",\n\t\t\t\"random_num\", 8)\n\n\t\treducer := redis.FTAggregateReducer{Reducer: redis.SearchCount}\n\t\toptions := &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err := client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliascount\"]).To(BeEquivalentTo(\"3\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchCountDistinct, Args: []interface{}{\"@title\"}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliascount_distincttitle\"]).To(BeEquivalentTo(\"3\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchSum, Args: []interface{}{\"@random_num\"}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliassumrandom_num\"]).To(BeEquivalentTo(\"21\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchMin, Args: []interface{}{\"@random_num\"}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliasminrandom_num\"]).To(BeEquivalentTo(\"3\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchMax, Args: []interface{}{\"@random_num\"}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliasmaxrandom_num\"]).To(BeEquivalentTo(\"10\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchAvg, Args: []interface{}{\"@random_num\"}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliasavgrandom_num\"]).To(BeEquivalentTo(\"7\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchStdDev, Args: []interface{}{\"@random_num\"}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliasstddevrandom_num\"]).To(BeEquivalentTo(\"3.60555127546\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchQuantile, Args: []interface{}{\"@random_num\", 0.5}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliasquantilerandom_num,0.5\"]).To(BeEquivalentTo(\"8\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchToList, Args: []interface{}{\"@title\"}}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"__generated_aliastolisttitle\"]).To(ContainElements(\"RediSearch\", \"RedisAI\", \"RedisJson\"))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchFirstValue, Args: []interface{}{\"@title\"}, As: \"first\"}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"first\"]).To(Or(BeEquivalentTo(\"RediSearch\"), BeEquivalentTo(\"RedisAI\"), BeEquivalentTo(\"RedisJson\")))\n\n\t\treducer = redis.FTAggregateReducer{Reducer: redis.SearchRandomSample, Args: []interface{}{\"@title\", 2}, As: \"random\"}\n\t\toptions = &redis.FTAggregateOptions{GroupBy: []redis.FTAggregateGroupBy{{Fields: []interface{}{\"@parent\"}, Reduce: []redis.FTAggregateReducer{reducer}}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"redis\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"parent\"]).To(BeEquivalentTo(\"redis\"))\n\t\tExpect(res.Rows[0].Fields[\"random\"]).To(Or(\n\t\t\tContainElement(\"RediSearch\"),\n\t\t\tContainElement(\"RedisAI\"),\n\t\t\tContainElement(\"RedisJson\"),\n\t\t))\n\n\t})\n\n\tIt(\"should FTAggregate sort and limit\", Label(\"search\", \"ftaggregate\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"t1\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"t2\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"t1\", \"a\", \"t2\", \"b\")\n\t\tclient.HSet(ctx, \"doc2\", \"t1\", \"b\", \"t2\", \"a\")\n\n\t\toptions := &redis.FTAggregateOptions{SortBy: []redis.FTAggregateSortBy{{FieldName: \"@t2\", Asc: true}, {FieldName: \"@t1\", Desc: true}}}\n\t\tres, err := client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"t1\"]).To(BeEquivalentTo(\"b\"))\n\t\tExpect(res.Rows[1].Fields[\"t1\"]).To(BeEquivalentTo(\"a\"))\n\t\tExpect(res.Rows[0].Fields[\"t2\"]).To(BeEquivalentTo(\"a\"))\n\t\tExpect(res.Rows[1].Fields[\"t2\"]).To(BeEquivalentTo(\"b\"))\n\n\t\toptions = &redis.FTAggregateOptions{SortBy: []redis.FTAggregateSortBy{{FieldName: \"@t1\"}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"t1\"]).To(BeEquivalentTo(\"a\"))\n\t\tExpect(res.Rows[1].Fields[\"t1\"]).To(BeEquivalentTo(\"b\"))\n\n\t\toptions = &redis.FTAggregateOptions{SortBy: []redis.FTAggregateSortBy{{FieldName: \"@t1\"}}, SortByMax: 1}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"t1\"]).To(BeEquivalentTo(\"a\"))\n\n\t\toptions = &redis.FTAggregateOptions{SortBy: []redis.FTAggregateSortBy{{FieldName: \"@t1\"}}, Limit: 1, LimitOffset: 1}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"t1\"]).To(BeEquivalentTo(\"b\"))\n\t})\n\n\tIt(\"should FTAggregate load \", Label(\"search\", \"ftaggregate\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"t1\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"t2\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"t1\", \"hello\", \"t2\", \"world\")\n\n\t\toptions := &redis.FTAggregateOptions{Load: []redis.FTAggregateLoad{{Field: \"t1\"}}}\n\t\tres, err := client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"t1\"]).To(BeEquivalentTo(\"hello\"))\n\n\t\toptions = &redis.FTAggregateOptions{Load: []redis.FTAggregateLoad{{Field: \"t2\"}}}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"t2\"]).To(BeEquivalentTo(\"world\"))\n\n\t\toptions = &redis.FTAggregateOptions{LoadAll: true}\n\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"t1\"]).To(BeEquivalentTo(\"hello\"))\n\t\tExpect(res.Rows[0].Fields[\"t2\"]).To(BeEquivalentTo(\"world\"))\n\t})\n\n\tIt(\"should FTAggregate apply\", Label(\"search\", \"ftaggregate\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"PrimaryKey\", FieldType: redis.SearchFieldTypeText, Sortable: true}\n\t\tnum1 := &redis.FieldSchema{FieldName: \"CreatedDateTimeUTC\", FieldType: redis.SearchFieldTypeNumeric, Sortable: true}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, num1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"PrimaryKey\", \"9::362330\", \"CreatedDateTimeUTC\", \"637387878524969984\")\n\t\tclient.HSet(ctx, \"doc2\", \"PrimaryKey\", \"9::362329\", \"CreatedDateTimeUTC\", \"637387875859270016\")\n\n\t\toptions := &redis.FTAggregateOptions{Apply: []redis.FTAggregateApply{{Field: \"@CreatedDateTimeUTC * 10\", As: \"CreatedDateTimeUTC\"}}}\n\t\tres, err := client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Rows[0].Fields[\"CreatedDateTimeUTC\"]).To(Or(BeEquivalentTo(\"6373878785249699840\"), BeEquivalentTo(\"6373878758592700416\")))\n\t\tExpect(res.Rows[1].Fields[\"CreatedDateTimeUTC\"]).To(Or(BeEquivalentTo(\"6373878785249699840\"), BeEquivalentTo(\"6373878758592700416\")))\n\n\t})\n\n\tIt(\"should FTAggregate filter\", Label(\"search\", \"ftaggregate\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"name\", FieldType: redis.SearchFieldTypeText, Sortable: true}\n\t\tnum1 := &redis.FieldSchema{FieldName: \"age\", FieldType: redis.SearchFieldTypeNumeric, Sortable: true}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, num1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"name\", \"bar\", \"age\", \"25\")\n\t\tclient.HSet(ctx, \"doc2\", \"name\", \"foo\", \"age\", \"19\")\n\n\t\tfor _, dlc := range []int{1, 2} {\n\t\t\toptions := &redis.FTAggregateOptions{Filter: \"@name=='foo' && @age < 20\", DialectVersion: dlc}\n\t\t\tres, err := client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.Total).To(Or(BeEquivalentTo(2), BeEquivalentTo(1)))\n\t\t\tExpect(res.Rows[0].Fields[\"name\"]).To(BeEquivalentTo(\"foo\"))\n\n\t\t\toptions = &redis.FTAggregateOptions{Filter: \"@age > 15\", DialectVersion: dlc, SortBy: []redis.FTAggregateSortBy{{FieldName: \"@age\"}}}\n\t\t\tres, err = client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res.Total).To(BeEquivalentTo(2))\n\t\t\tExpect(res.Rows[0].Fields[\"age\"]).To(BeEquivalentTo(\"19\"))\n\t\t\tExpect(res.Rows[1].Fields[\"age\"]).To(BeEquivalentTo(\"25\"))\n\t\t}\n\n\t})\n\n\tIt(\"should FTSearch SkipInitialScan\", Label(\"search\", \"ftsearch\"), func() {\n\t\tclient.HSet(ctx, \"doc1\", \"foo\", \"bar\")\n\n\t\ttext1 := &redis.FieldSchema{FieldName: \"foo\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{SkipInitialScan: true}, text1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tres, err := client.FTSearch(ctx, \"idx1\", \"@foo:bar\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(int64(0)))\n\t})\n\n\tIt(\"should FTCreate json\", Label(\"search\", \"ftcreate\"), func() {\n\n\t\ttext1 := &redis.FieldSchema{FieldName: \"$.name\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnJSON: true, Prefix: []interface{}{\"king:\"}}, text1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.JSONSet(ctx, \"king:1\", \"$\", `{\"name\": \"henry\"}`)\n\t\tclient.JSONSet(ctx, \"king:2\", \"$\", `{\"name\": \"james\"}`)\n\n\t\tres, err := client.FTSearch(ctx, \"idx1\", \"henry\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"king:1\"))\n\t\tExpect(res.Docs[0].Fields[\"$\"]).To(BeEquivalentTo(`{\"name\":\"henry\"}`))\n\t})\n\n\tIt(\"should FTCreate json fields as names\", Label(\"search\", \"ftcreate\"), func() {\n\n\t\ttext1 := &redis.FieldSchema{FieldName: \"$.name\", FieldType: redis.SearchFieldTypeText, As: \"name\"}\n\t\tnum1 := &redis.FieldSchema{FieldName: \"$.age\", FieldType: redis.SearchFieldTypeNumeric, As: \"just_a_number\"}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnJSON: true}, text1, num1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.JSONSet(ctx, \"doc:1\", \"$\", `{\"name\": \"Jon\", \"age\": 25}`)\n\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"Jon\", &redis.FTSearchOptions{Return: []redis.FTSearchReturn{{FieldName: \"name\"}, {FieldName: \"just_a_number\"}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"doc:1\"))\n\t\tExpect(res.Docs[0].Fields[\"name\"]).To(BeEquivalentTo(\"Jon\"))\n\t\tExpect(res.Docs[0].Fields[\"just_a_number\"]).To(BeEquivalentTo(\"25\"))\n\t})\n\n\tIt(\"should FTCreate CaseSensitive\", Label(\"search\", \"ftcreate\"), func() {\n\n\t\ttag1 := &redis.FieldSchema{FieldName: \"t\", FieldType: redis.SearchFieldTypeTag, CaseSensitive: false}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, tag1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"1\", \"t\", \"HELLO\")\n\t\tclient.HSet(ctx, \"2\", \"t\", \"hello\")\n\n\t\tres, err := client.FTSearch(ctx, \"idx1\", \"@t:{HELLO}\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(2))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"1\"))\n\t\tExpect(res.Docs[1].ID).To(BeEquivalentTo(\"2\"))\n\n\t\tresDrop, err := client.FTDropIndex(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDrop).To(BeEquivalentTo(\"OK\"))\n\n\t\ttag2 := &redis.FieldSchema{FieldName: \"t\", FieldType: redis.SearchFieldTypeTag, CaseSensitive: true}\n\t\tval, err = client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, tag2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tres, err = client.FTSearch(ctx, \"idx1\", \"@t:{HELLO}\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"1\"))\n\n\t})\n\n\tIt(\"should FTSearch ReturnFields\", Label(\"search\", \"ftsearch\"), func() {\n\t\tresJson, err := client.JSONSet(ctx, \"doc:1\", \"$\", `{\"t\": \"riceratops\",\"t2\": \"telmatosaurus\", \"n\": 9072, \"flt\": 97.2}`).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resJson).To(BeEquivalentTo(\"OK\"))\n\n\t\ttext1 := &redis.FieldSchema{FieldName: \"$.t\", FieldType: redis.SearchFieldTypeText}\n\t\tnum1 := &redis.FieldSchema{FieldName: \"$.flt\", FieldType: redis.SearchFieldTypeNumeric}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnJSON: true}, text1, num1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"*\", &redis.FTSearchOptions{Return: []redis.FTSearchReturn{{FieldName: \"$.t\", As: \"txt\"}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"doc:1\"))\n\t\tExpect(res.Docs[0].Fields[\"txt\"]).To(BeEquivalentTo(\"riceratops\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"*\", &redis.FTSearchOptions{Return: []redis.FTSearchReturn{{FieldName: \"$.t2\", As: \"txt\"}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"doc:1\"))\n\t\tExpect(res.Docs[0].Fields[\"txt\"]).To(BeEquivalentTo(\"telmatosaurus\"))\n\t})\n\n\tIt(\"should FTSynUpdate\", Label(\"search\", \"ftsynupdate\"), func() {\n\n\t\ttext1 := &redis.FieldSchema{FieldName: \"title\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"body\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnHash: true}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tresSynUpdate, err := client.FTSynUpdateWithArgs(ctx, \"idx1\", \"id1\", &redis.FTSynUpdateOptions{SkipInitialScan: true}, []interface{}{\"boy\", \"child\", \"offspring\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\t\tclient.HSet(ctx, \"doc1\", \"title\", \"he is a baby\", \"body\", \"this is a test\")\n\n\t\tresSynUpdate, err = client.FTSynUpdateWithArgs(ctx, \"idx1\", \"id1\", &redis.FTSynUpdateOptions{SkipInitialScan: true}, []interface{}{\"baby\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\t\tclient.HSet(ctx, \"doc2\", \"title\", \"he is another baby\", \"body\", \"another test\")\n\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"child\", &redis.FTSearchOptions{Expander: \"SYNONYM\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"doc2\"))\n\t\tExpect(res.Docs[0].Fields[\"title\"]).To(BeEquivalentTo(\"he is another baby\"))\n\t\tExpect(res.Docs[0].Fields[\"body\"]).To(BeEquivalentTo(\"another test\"))\n\t})\n\n\tIt(\"should FTSynDump\", Label(\"search\", \"ftsyndump\"), func() {\n\n\t\ttext1 := &redis.FieldSchema{FieldName: \"title\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"body\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnHash: true}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tresSynUpdate, err := client.FTSynUpdate(ctx, \"idx1\", \"id1\", []interface{}{\"boy\", \"child\", \"offspring\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\n\t\tresSynUpdate, err = client.FTSynUpdate(ctx, \"idx1\", \"id1\", []interface{}{\"baby\", \"child\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\n\t\tresSynUpdate, err = client.FTSynUpdate(ctx, \"idx1\", \"id1\", []interface{}{\"tree\", \"wood\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\n\t\tresSynDump, err := client.FTSynDump(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynDump[0].Term).To(BeEquivalentTo(\"baby\"))\n\t\tExpect(resSynDump[0].Synonyms).To(BeEquivalentTo([]string{\"id1\"}))\n\t\tExpect(resSynDump[1].Term).To(BeEquivalentTo(\"wood\"))\n\t\tExpect(resSynDump[1].Synonyms).To(BeEquivalentTo([]string{\"id1\"}))\n\t\tExpect(resSynDump[2].Term).To(BeEquivalentTo(\"boy\"))\n\t\tExpect(resSynDump[2].Synonyms).To(BeEquivalentTo([]string{\"id1\"}))\n\t\tExpect(resSynDump[3].Term).To(BeEquivalentTo(\"tree\"))\n\t\tExpect(resSynDump[3].Synonyms).To(BeEquivalentTo([]string{\"id1\"}))\n\t\tExpect(resSynDump[4].Term).To(BeEquivalentTo(\"child\"))\n\t\tExpect(resSynDump[4].Synonyms).To(Or(BeEquivalentTo([]string{\"id1\"}), BeEquivalentTo([]string{\"id1\", \"id1\"})))\n\t\tExpect(resSynDump[5].Term).To(BeEquivalentTo(\"offspring\"))\n\t\tExpect(resSynDump[5].Synonyms).To(BeEquivalentTo([]string{\"id1\"}))\n\n\t})\n\n\tIt(\"should FTCreate json with alias\", Label(\"search\", \"ftcreate\"), func() {\n\n\t\ttext1 := &redis.FieldSchema{FieldName: \"$.name\", FieldType: redis.SearchFieldTypeText, As: \"name\"}\n\t\tnum1 := &redis.FieldSchema{FieldName: \"$.num\", FieldType: redis.SearchFieldTypeNumeric, As: \"num\"}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnJSON: true, Prefix: []interface{}{\"king:\"}}, text1, num1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.JSONSet(ctx, \"king:1\", \"$\", `{\"name\": \"henry\", \"num\": 42}`)\n\t\tclient.JSONSet(ctx, \"king:2\", \"$\", `{\"name\": \"james\", \"num\": 3.14}`)\n\n\t\tres, err := client.FTSearch(ctx, \"idx1\", \"@name:henry\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"king:1\"))\n\t\tExpect(res.Docs[0].Fields[\"$\"]).To(BeEquivalentTo(`{\"name\":\"henry\",\"num\":42}`))\n\n\t\tres, err = client.FTSearch(ctx, \"idx1\", \"@num:[0 10]\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"king:2\"))\n\t\tExpect(res.Docs[0].Fields[\"$\"]).To(BeEquivalentTo(`{\"name\":\"james\",\"num\":3.14}`))\n\t})\n\n\tIt(\"should FTCreate json with multipath\", Label(\"search\", \"ftcreate\"), func() {\n\n\t\ttag1 := &redis.FieldSchema{FieldName: \"$..name\", FieldType: redis.SearchFieldTypeTag, As: \"name\"}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnJSON: true, Prefix: []interface{}{\"king:\"}}, tag1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.JSONSet(ctx, \"king:1\", \"$\", `{\"name\": \"henry\", \"country\": {\"name\": \"england\"}}`)\n\n\t\tres, err := client.FTSearch(ctx, \"idx1\", \"@name:{england}\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"king:1\"))\n\t\tExpect(res.Docs[0].Fields[\"$\"]).To(BeEquivalentTo(`{\"name\":\"henry\",\"country\":{\"name\":\"england\"}}`))\n\t})\n\n\tIt(\"should FTCreate json with jsonpath\", Label(\"search\", \"ftcreate\"), func() {\n\n\t\ttext1 := &redis.FieldSchema{FieldName: `$[\"prod:name\"]`, FieldType: redis.SearchFieldTypeText, As: \"name\"}\n\t\ttext2 := &redis.FieldSchema{FieldName: `$.prod:name`, FieldType: redis.SearchFieldTypeText, As: \"name_unsupported\"}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnJSON: true}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.JSONSet(ctx, \"doc:1\", \"$\", `{\"prod:name\": \"RediSearch\"}`)\n\n\t\tres, err := client.FTSearch(ctx, \"idx1\", \"@name:RediSearch\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"doc:1\"))\n\t\tExpect(res.Docs[0].Fields[\"$\"]).To(BeEquivalentTo(`{\"prod:name\":\"RediSearch\"}`))\n\n\t\tres, err = client.FTSearch(ctx, \"idx1\", \"@name_unsupported:RediSearch\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"@name:RediSearch\", &redis.FTSearchOptions{Return: []redis.FTSearchReturn{{FieldName: \"name\"}}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(1))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"doc:1\"))\n\t\tExpect(res.Docs[0].Fields[\"name\"]).To(BeEquivalentTo(\"RediSearch\"))\n\n\t})\n\n\tIt(\"should FTCreate VECTOR\", Label(\"search\", \"ftcreate\"), func() {\n\t\thnswOptions := &redis.FTHNSWOptions{Type: \"FLOAT32\", Dim: 2, DistanceMetric: \"L2\"}\n\t\tval, err := client.FTCreate(ctx, \"idx1\",\n\t\t\t&redis.FTCreateOptions{},\n\t\t\t&redis.FieldSchema{FieldName: \"v\", FieldType: redis.SearchFieldTypeVector, VectorArgs: &redis.FTVectorArgs{HNSWOptions: hnswOptions}}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"a\", \"v\", \"aaaaaaaa\")\n\t\tclient.HSet(ctx, \"b\", \"v\", \"aaaabaaa\")\n\t\tclient.HSet(ctx, \"c\", \"v\", \"aaaaabaa\")\n\n\t\tsearchOptions := &redis.FTSearchOptions{\n\t\t\tReturn:         []redis.FTSearchReturn{{FieldName: \"__v_score\"}},\n\t\t\tSortBy:         []redis.FTSearchSortBy{{FieldName: \"__v_score\", Asc: true}},\n\t\t\tDialectVersion: 2,\n\t\t\tParams:         map[string]interface{}{\"vec\": \"aaaaaaaa\"},\n\t\t}\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"*=>[KNN 2 @v $vec]\", searchOptions).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"a\"))\n\t\tExpect(res.Docs[0].Fields[\"__v_score\"]).To(BeEquivalentTo(\"0\"))\n\t})\n\n\tIt(\"should FTCreate and FTSearch text params\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"name\", FieldType: redis.SearchFieldTypeText}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"name\", \"Alice\")\n\t\tclient.HSet(ctx, \"doc2\", \"name\", \"Bob\")\n\t\tclient.HSet(ctx, \"doc3\", \"name\", \"Carol\")\n\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@name:($name1 | $name2 )\", &redis.FTSearchOptions{Params: map[string]interface{}{\"name1\": \"Alice\", \"name2\": \"Bob\"}, DialectVersion: 2}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(2)))\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tExpect(res1.Docs[1].ID).To(BeEquivalentTo(\"doc2\"))\n\n\t})\n\n\tIt(\"should FTCreate and FTSearch numeric params\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"numval\", FieldType: redis.SearchFieldTypeNumeric}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"numval\", 101)\n\t\tclient.HSet(ctx, \"doc2\", \"numval\", 102)\n\t\tclient.HSet(ctx, \"doc3\", \"numval\", 103)\n\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@numval:[$min $max]\", &redis.FTSearchOptions{Params: map[string]interface{}{\"min\": 101, \"max\": 102}, DialectVersion: 2}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(2)))\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tExpect(res1.Docs[1].ID).To(BeEquivalentTo(\"doc2\"))\n\n\t})\n\n\tIt(\"should FTCreate and FTSearch geo params\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"g\", FieldType: redis.SearchFieldTypeGeo}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"g\", \"29.69465, 34.95126\")\n\t\tclient.HSet(ctx, \"doc2\", \"g\", \"29.69350, 34.94737\")\n\t\tclient.HSet(ctx, \"doc3\", \"g\", \"29.68746, 34.94882\")\n\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@g:[$lon $lat $radius $units]\", &redis.FTSearchOptions{Params: map[string]interface{}{\"lat\": \"34.95126\", \"lon\": \"29.69465\", \"radius\": 1000, \"units\": \"km\"}, DialectVersion: 2}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(3)))\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"doc1\"))\n\t\tExpect(res1.Docs[1].ID).To(BeEquivalentTo(\"doc2\"))\n\t\tExpect(res1.Docs[2].ID).To(BeEquivalentTo(\"doc3\"))\n\n\t})\n\n\tIt(\"should FTConfigSet and FTConfigGet dialect\", Label(\"search\", \"ftconfigget\", \"ftconfigset\", \"NonRedisEnterprise\"), func() {\n\t\tres, err := client.FTConfigSet(ctx, \"DEFAULT_DIALECT\", \"1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res).To(BeEquivalentTo(\"OK\"))\n\n\t\tdefDialect, err := client.FTConfigGet(ctx, \"DEFAULT_DIALECT\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(defDialect).To(BeEquivalentTo(map[string]interface{}{\"DEFAULT_DIALECT\": \"1\"}))\n\n\t\tres, err = client.FTConfigSet(ctx, \"DEFAULT_DIALECT\", \"2\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res).To(BeEquivalentTo(\"OK\"))\n\n\t\tdefDialect, err = client.FTConfigGet(ctx, \"DEFAULT_DIALECT\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(defDialect).To(BeEquivalentTo(map[string]interface{}{\"DEFAULT_DIALECT\": \"2\"}))\n\t})\n\n\tIt(\"should FTCreate WithSuffixtrie\", Label(\"search\", \"ftcreate\", \"ftinfo\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tres, err := client.FTInfo(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Attributes[0].Attribute).To(BeEquivalentTo(\"txt\"))\n\n\t\tresDrop, err := client.FTDropIndex(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDrop).To(BeEquivalentTo(\"OK\"))\n\n\t\t// create withsuffixtrie index - text field\n\t\tval, err = client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText, WithSuffixtrie: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tres, err = client.FTInfo(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Attributes[0].WithSuffixtrie).To(BeTrue())\n\n\t\tresDrop, err = client.FTDropIndex(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resDrop).To(BeEquivalentTo(\"OK\"))\n\n\t\t// create withsuffixtrie index - tag field\n\t\tval, err = client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"t\", FieldType: redis.SearchFieldTypeTag, WithSuffixtrie: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tres, err = client.FTInfo(ctx, \"idx1\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Attributes[0].WithSuffixtrie).To(BeTrue())\n\t})\n\n\tIt(\"should test dialect 4\", Label(\"search\", \"ftcreate\", \"ftsearch\", \"NonRedisEnterprise\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{\n\t\t\tPrefix: []interface{}{\"resource:\"},\n\t\t}, &redis.FieldSchema{\n\t\t\tFieldName: \"uuid\",\n\t\t\tFieldType: redis.SearchFieldTypeTag,\n\t\t}, &redis.FieldSchema{\n\t\t\tFieldName: \"tags\",\n\t\t\tFieldType: redis.SearchFieldTypeTag,\n\t\t}, &redis.FieldSchema{\n\t\t\tFieldName: \"description\",\n\t\t\tFieldType: redis.SearchFieldTypeText,\n\t\t}, &redis.FieldSchema{\n\t\t\tFieldName: \"rating\",\n\t\t\tFieldType: redis.SearchFieldTypeNumeric,\n\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\n\t\tclient.HSet(ctx, \"resource:1\", map[string]interface{}{\n\t\t\t\"uuid\":        \"123e4567-e89b-12d3-a456-426614174000\",\n\t\t\t\"tags\":        \"finance|crypto|$btc|blockchain\",\n\t\t\t\"description\": \"Analysis of blockchain technologies & Bitcoin's potential.\",\n\t\t\t\"rating\":      5,\n\t\t})\n\t\tclient.HSet(ctx, \"resource:2\", map[string]interface{}{\n\t\t\t\"uuid\":        \"987e6543-e21c-12d3-a456-426614174999\",\n\t\t\t\"tags\":        \"health|well-being|fitness|new-year's-resolutions\",\n\t\t\t\"description\": \"Health trends for the new year, including fitness regimes.\",\n\t\t\t\"rating\":      4,\n\t\t})\n\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@uuid:{$uuid}\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 2,\n\t\t\t\tParams:         map[string]interface{}{\"uuid\": \"123e4567-e89b-12d3-a456-426614174000\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(int64(1)))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"resource:1\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"@uuid:{$uuid}\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 4,\n\t\t\t\tParams:         map[string]interface{}{\"uuid\": \"123e4567-e89b-12d3-a456-426614174000\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Total).To(BeEquivalentTo(int64(1)))\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"resource:1\"))\n\n\t\tclient.HSet(ctx, \"test:1\", map[string]interface{}{\n\t\t\t\"uuid\":  \"3d3586fe-0416-4572-8ce\",\n\t\t\t\"email\": \"adriano@acme.com.ie\",\n\t\t\t\"num\":   5,\n\t\t})\n\n\t\t// Create the index\n\t\tftCreateOptions := &redis.FTCreateOptions{\n\t\t\tPrefix: []interface{}{\"test:\"},\n\t\t}\n\t\tschema := []*redis.FieldSchema{\n\t\t\t{\n\t\t\t\tFieldName: \"uuid\",\n\t\t\t\tFieldType: redis.SearchFieldTypeTag,\n\t\t\t},\n\t\t\t{\n\t\t\t\tFieldName: \"email\",\n\t\t\t\tFieldType: redis.SearchFieldTypeTag,\n\t\t\t},\n\t\t\t{\n\t\t\t\tFieldName: \"num\",\n\t\t\t\tFieldType: redis.SearchFieldTypeNumeric,\n\t\t\t},\n\t\t}\n\n\t\tval, err = client.FTCreate(ctx, \"idx_hash\", ftCreateOptions, schema...).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(\"OK\"))\n\n\t\tftSearchOptions := &redis.FTSearchOptions{\n\t\t\tDialectVersion: 4,\n\t\t\tParams: map[string]interface{}{\n\t\t\t\t\"uuid\":  \"3d3586fe-0416-4572-8ce\",\n\t\t\t\t\"email\": \"adriano@acme.com.ie\",\n\t\t\t},\n\t\t}\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx_hash\", \"@uuid:{$uuid}\", ftSearchOptions).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"test:1\"))\n\t\tExpect(res.Docs[0].Fields[\"uuid\"]).To(BeEquivalentTo(\"3d3586fe-0416-4572-8ce\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx_hash\", \"@email:{$email}\", ftSearchOptions).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"test:1\"))\n\t\tExpect(res.Docs[0].Fields[\"email\"]).To(BeEquivalentTo(\"adriano@acme.com.ie\"))\n\n\t\tftSearchOptions.Params = map[string]interface{}{\"num\": 5}\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx_hash\", \"@num:[5]\", ftSearchOptions).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"test:1\"))\n\t\tExpect(res.Docs[0].Fields[\"num\"]).To(BeEquivalentTo(\"5\"))\n\t})\n\n\tIt(\"should FTCreate GeoShape\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"geom\", FieldType: redis.SearchFieldTypeGeoShape, GeoShapeFieldType: \"FLAT\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"small\", \"geom\", \"POLYGON((1 1, 1 100, 100 100, 100 1, 1 1))\")\n\t\tclient.HSet(ctx, \"large\", \"geom\", \"POLYGON((1 1, 1 200, 200 200, 200 1, 1 1))\")\n\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@geom:[WITHIN $poly]\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 3,\n\t\t\t\tParams:         map[string]interface{}{\"poly\": \"POLYGON((0 0, 0 150, 150 150, 150 0, 0 0))\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1.Total).To(BeEquivalentTo(int64(1)))\n\t\tExpect(res1.Docs[0].ID).To(BeEquivalentTo(\"small\"))\n\n\t\tres2, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@geom:[CONTAINS $poly]\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 3,\n\t\t\t\tParams:         map[string]interface{}{\"poly\": \"POLYGON((2 2, 2 50, 50 50, 50 2, 2 2))\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res2.Total).To(BeEquivalentTo(int64(2)))\n\t})\n\n\tIt(\"should create search index with FLOAT16 and BFLOAT16 vectors\", Label(\"search\", \"ftcreate\", \"NonRedisEnterprise\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"index\", &redis.FTCreateOptions{},\n\t\t\t&redis.FieldSchema{FieldName: \"float16\", FieldType: redis.SearchFieldTypeVector, VectorArgs: &redis.FTVectorArgs{FlatOptions: &redis.FTFlatOptions{Type: \"FLOAT16\", Dim: 768, DistanceMetric: \"COSINE\"}}},\n\t\t\t&redis.FieldSchema{FieldName: \"bfloat16\", FieldType: redis.SearchFieldTypeVector, VectorArgs: &redis.FTVectorArgs{FlatOptions: &redis.FTFlatOptions{Type: \"BFLOAT16\", Dim: 768, DistanceMetric: \"COSINE\"}}},\n\t\t).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"index\")\n\t})\n\n\tIt(\"should test geoshapes query intersects and disjoint\", Label(\"NonRedisEnterprise\"), func() {\n\t\t_, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{\n\t\t\tFieldName:         \"g\",\n\t\t\tFieldType:         redis.SearchFieldTypeGeoShape,\n\t\t\tGeoShapeFieldType: \"FLAT\",\n\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tclient.HSet(ctx, \"doc_point1\", \"g\", \"POINT (10 10)\")\n\t\tclient.HSet(ctx, \"doc_point2\", \"g\", \"POINT (50 50)\")\n\t\tclient.HSet(ctx, \"doc_polygon1\", \"g\", \"POLYGON ((20 20, 25 35, 35 25, 20 20))\")\n\t\tclient.HSet(ctx, \"doc_polygon2\", \"g\", \"POLYGON ((60 60, 65 75, 70 70, 65 55, 60 60))\")\n\n\t\tintersection, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@g:[intersects $shape]\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 3,\n\t\t\t\tParams:         map[string]interface{}{\"shape\": \"POLYGON((15 15, 75 15, 50 70, 20 40, 15 15))\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\t_assert_geosearch_result(&intersection, []string{\"doc_point2\", \"doc_polygon1\"})\n\n\t\tdisjunction, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@g:[disjoint $shape]\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 3,\n\t\t\t\tParams:         map[string]interface{}{\"shape\": \"POLYGON((15 15, 75 15, 50 70, 20 40, 15 15))\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\t_assert_geosearch_result(&disjunction, []string{\"doc_point1\", \"doc_polygon2\"})\n\t})\n\n\tIt(\"should test geoshapes query contains and within\", func() {\n\t\t_, err := client.FTCreate(ctx, \"idx2\", &redis.FTCreateOptions{}, &redis.FieldSchema{\n\t\t\tFieldName:         \"g\",\n\t\t\tFieldType:         redis.SearchFieldTypeGeoShape,\n\t\t\tGeoShapeFieldType: \"FLAT\",\n\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tclient.HSet(ctx, \"doc_point1\", \"g\", \"POINT (10 10)\")\n\t\tclient.HSet(ctx, \"doc_point2\", \"g\", \"POINT (50 50)\")\n\t\tclient.HSet(ctx, \"doc_polygon1\", \"g\", \"POLYGON ((20 20, 25 35, 35 25, 20 20))\")\n\t\tclient.HSet(ctx, \"doc_polygon2\", \"g\", \"POLYGON ((60 60, 65 75, 70 70, 65 55, 60 60))\")\n\n\t\tcontainsA, err := client.FTSearchWithArgs(ctx, \"idx2\", \"@g:[contains $shape]\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 3,\n\t\t\t\tParams:         map[string]interface{}{\"shape\": \"POINT(25 25)\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\t_assert_geosearch_result(&containsA, []string{\"doc_polygon1\"})\n\n\t\tcontainsB, err := client.FTSearchWithArgs(ctx, \"idx2\", \"@g:[contains $shape]\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 3,\n\t\t\t\tParams:         map[string]interface{}{\"shape\": \"POLYGON((24 24, 24 26, 25 25, 24 24))\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\t_assert_geosearch_result(&containsB, []string{\"doc_polygon1\"})\n\n\t\twithin, err := client.FTSearchWithArgs(ctx, \"idx2\", \"@g:[within $shape]\",\n\t\t\t&redis.FTSearchOptions{\n\t\t\t\tDialectVersion: 3,\n\t\t\t\tParams:         map[string]interface{}{\"shape\": \"POLYGON((15 15, 75 15, 50 70, 20 40, 15 15))\"},\n\t\t\t}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\t_assert_geosearch_result(&within, []string{\"doc_point2\", \"doc_polygon1\"})\n\t})\n\n\tIt(\"should search missing fields\", Label(\"search\", \"ftcreate\", \"ftsearch\", \"NonRedisEnterprise\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{Prefix: []interface{}{\"property:\"}},\n\t\t\t&redis.FieldSchema{FieldName: \"title\", FieldType: redis.SearchFieldTypeText, Sortable: true},\n\t\t\t&redis.FieldSchema{FieldName: \"features\", FieldType: redis.SearchFieldTypeTag, IndexMissing: true},\n\t\t\t&redis.FieldSchema{FieldName: \"description\", FieldType: redis.SearchFieldTypeText, IndexMissing: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"property:1\", map[string]interface{}{\n\t\t\t\"title\":       \"Luxury Villa in Malibu\",\n\t\t\t\"features\":    \"pool,sea view,modern\",\n\t\t\t\"description\": \"A stunning modern villa overlooking the Pacific Ocean.\",\n\t\t})\n\n\t\tclient.HSet(ctx, \"property:2\", map[string]interface{}{\n\t\t\t\"title\":       \"Downtown Flat\",\n\t\t\t\"description\": \"Modern flat in central Paris with easy access to metro.\",\n\t\t})\n\n\t\tclient.HSet(ctx, \"property:3\", map[string]interface{}{\n\t\t\t\"title\":    \"Beachfront Bungalow\",\n\t\t\t\"features\": \"beachfront,sun deck\",\n\t\t})\n\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"ismissing(@features)\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:2\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"-ismissing(@features)\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:1\"))\n\t\tExpect(res.Docs[1].ID).To(BeEquivalentTo(\"property:3\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"ismissing(@description)\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:3\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"-ismissing(@description)\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:1\"))\n\t\tExpect(res.Docs[1].ID).To(BeEquivalentTo(\"property:2\"))\n\t})\n\n\tIt(\"should search empty fields\", Label(\"search\", \"ftcreate\", \"ftsearch\", \"NonRedisEnterprise\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{Prefix: []interface{}{\"property:\"}},\n\t\t\t&redis.FieldSchema{FieldName: \"title\", FieldType: redis.SearchFieldTypeText, Sortable: true},\n\t\t\t&redis.FieldSchema{FieldName: \"features\", FieldType: redis.SearchFieldTypeTag, IndexEmpty: true},\n\t\t\t&redis.FieldSchema{FieldName: \"description\", FieldType: redis.SearchFieldTypeText, IndexEmpty: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"property:1\", map[string]interface{}{\n\t\t\t\"title\":       \"Luxury Villa in Malibu\",\n\t\t\t\"features\":    \"pool,sea view,modern\",\n\t\t\t\"description\": \"A stunning modern villa overlooking the Pacific Ocean.\",\n\t\t})\n\n\t\tclient.HSet(ctx, \"property:2\", map[string]interface{}{\n\t\t\t\"title\":       \"Downtown Flat\",\n\t\t\t\"features\":    \"\",\n\t\t\t\"description\": \"Modern flat in central Paris with easy access to metro.\",\n\t\t})\n\n\t\tclient.HSet(ctx, \"property:3\", map[string]interface{}{\n\t\t\t\"title\":       \"Beachfront Bungalow\",\n\t\t\t\"features\":    \"beachfront,sun deck\",\n\t\t\t\"description\": \"\",\n\t\t})\n\n\t\tres, err := client.FTSearchWithArgs(ctx, \"idx1\", \"@features:{\\\"\\\"}\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:2\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"-@features:{\\\"\\\"}\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:1\"))\n\t\tExpect(res.Docs[1].ID).To(BeEquivalentTo(\"property:3\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"@description:''\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:3\"))\n\n\t\tres, err = client.FTSearchWithArgs(ctx, \"idx1\", \"-@description:''\", &redis.FTSearchOptions{DialectVersion: 4, Return: []redis.FTSearchReturn{{FieldName: \"id\"}}, NoContent: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res.Docs[0].ID).To(BeEquivalentTo(\"property:1\"))\n\t\tExpect(res.Docs[1].ID).To(BeEquivalentTo(\"property:2\"))\n\t})\n})\n\nfunc _assert_geosearch_result(result *redis.FTSearchResult, expectedDocIDs []string) {\n\tids := make([]string, len(result.Docs))\n\tfor i, doc := range result.Docs {\n\t\tids[i] = doc.ID\n\t}\n\tExpect(ids).To(ConsistOf(expectedDocIDs))\n\tExpect(result.Total).To(BeEquivalentTo(len(expectedDocIDs)))\n}\n\n// It(\"should FTProfile Search and Aggregate\", Label(\"search\", \"ftprofile\"), func() {\n// \tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"t\", FieldType: redis.SearchFieldTypeText}).Result()\n// \tExpect(err).NotTo(HaveOccurred())\n// \tExpect(val).To(BeEquivalentTo(\"OK\"))\n// \tWaitForIndexing(client, \"idx1\")\n\n// \tclient.HSet(ctx, \"1\", \"t\", \"hello\")\n// \tclient.HSet(ctx, \"2\", \"t\", \"world\")\n\n// \t// FTProfile Search\n// \tquery := redis.FTSearchQuery(\"hello|world\", &redis.FTSearchOptions{NoContent: true})\n// \tres1, err := client.FTProfile(ctx, \"idx1\", false, query).Result()\n// \tExpect(err).NotTo(HaveOccurred())\n// \tpanic(res1)\n// Expect(len(res1[\"results\"].([]interface{}))).To(BeEquivalentTo(3))\n// resProfile := res1[\"profile\"].(map[interface{}]interface{})\n// Expect(resProfile[\"Parsing time\"].(float64) < 0.5).To(BeTrue())\n// iterProfile0 := resProfile[\"Iterators profile\"].([]interface{})[0].(map[interface{}]interface{})\n// Expect(iterProfile0[\"Counter\"]).To(BeEquivalentTo(2.0))\n// Expect(iterProfile0[\"Type\"]).To(BeEquivalentTo(\"UNION\"))\n\n// // FTProfile Aggregate\n// aggQuery := redis.FTAggregateQuery(\"*\", &redis.FTAggregateOptions{\n// \tLoad:  []redis.FTAggregateLoad{{Field: \"t\"}},\n// \tApply: []redis.FTAggregateApply{{Field: \"startswith(@t, 'hel')\", As: \"prefix\"}}})\n// res2, err := client.FTProfile(ctx, \"idx1\", false, aggQuery).Result()\n// Expect(err).NotTo(HaveOccurred())\n// Expect(len(res2[\"results\"].([]interface{}))).To(BeEquivalentTo(2))\n// resProfile = res2[\"profile\"].(map[interface{}]interface{})\n// iterProfile0 = resProfile[\"Iterators profile\"].([]interface{})[0].(map[interface{}]interface{})\n// Expect(iterProfile0[\"Counter\"]).To(BeEquivalentTo(2))\n// Expect(iterProfile0[\"Type\"]).To(BeEquivalentTo(\"WILDCARD\"))\n// })\n\n// \tIt(\"should FTProfile Search Limited\", Label(\"search\", \"ftprofile\"), func() {\n// \t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"t\", FieldType: redis.SearchFieldTypeText}).Result()\n// \t\tExpect(err).NotTo(HaveOccurred())\n// \t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n// \t\tWaitForIndexing(client, \"idx1\")\n\n// \t\tclient.HSet(ctx, \"1\", \"t\", \"hello\")\n// \t\tclient.HSet(ctx, \"2\", \"t\", \"hell\")\n// \t\tclient.HSet(ctx, \"3\", \"t\", \"help\")\n// \t\tclient.HSet(ctx, \"4\", \"t\", \"helowa\")\n\n// \t\t// FTProfile Search\n// \t\tquery := redis.FTSearchQuery(\"%hell% hel*\", &redis.FTSearchOptions{})\n// \t\tres1, err := client.FTProfile(ctx, \"idx1\", true, query).Result()\n// \t\tExpect(err).NotTo(HaveOccurred())\n// \t\tresProfile := res1[\"profile\"].(map[interface{}]interface{})\n// \t\titerProfile0 := resProfile[\"Iterators profile\"].([]interface{})[0].(map[interface{}]interface{})\n// \t\tExpect(iterProfile0[\"Type\"]).To(BeEquivalentTo(\"INTERSECT\"))\n// \t\tExpect(len(res1[\"results\"].([]interface{}))).To(BeEquivalentTo(3))\n// \t\tExpect(iterProfile0[\"Child iterators\"].([]interface{})[0].(map[interface{}]interface{})[\"Child iterators\"]).To(BeEquivalentTo(\"The number of iterators in the union is 3\"))\n// \t\tExpect(iterProfile0[\"Child iterators\"].([]interface{})[1].(map[interface{}]interface{})[\"Child iterators\"]).To(BeEquivalentTo(\"The number of iterators in the union is 4\"))\n// \t})\n\n// \tIt(\"should FTProfile Search query params\", Label(\"search\", \"ftprofile\"), func() {\n// \t\thnswOptions := &redis.FTHNSWOptions{Type: \"FLOAT32\", Dim: 2, DistanceMetric: \"L2\"}\n// \t\tval, err := client.FTCreate(ctx, \"idx1\",\n// \t\t\t&redis.FTCreateOptions{},\n// \t\t\t&redis.FieldSchema{FieldName: \"v\", FieldType: redis.SearchFieldTypeVector, VectorArgs: &redis.FTVectorArgs{HNSWOptions: hnswOptions}}).Result()\n// \t\tExpect(err).NotTo(HaveOccurred())\n// \t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n// \t\tWaitForIndexing(client, \"idx1\")\n\n// \t\tclient.HSet(ctx, \"a\", \"v\", \"aaaaaaaa\")\n// \t\tclient.HSet(ctx, \"b\", \"v\", \"aaaabaaa\")\n// \t\tclient.HSet(ctx, \"c\", \"v\", \"aaaaabaa\")\n\n// \t\t// FTProfile Search\n// \t\tsearchOptions := &redis.FTSearchOptions{\n// \t\t\tReturn:         []redis.FTSearchReturn{{FieldName: \"__v_score\"}},\n// \t\t\tSortBy:         []redis.FTSearchSortBy{{FieldName: \"__v_score\", Asc: true}},\n// \t\t\tDialectVersion: 2,\n// \t\t\tParams:         map[string]interface{}{\"vec\": \"aaaaaaaa\"},\n// \t\t}\n// \t\tquery := redis.FTSearchQuery(\"*=>[KNN 2 @v $vec]\", searchOptions)\n// \t\tres1, err := client.FTProfile(ctx, \"idx1\", false, query).Result()\n// \t\tExpect(err).NotTo(HaveOccurred())\n// \t\tresProfile := res1[\"profile\"].(map[interface{}]interface{})\n// \t\titerProfile0 := resProfile[\"Iterators profile\"].([]interface{})[0].(map[interface{}]interface{})\n// \t\tExpect(iterProfile0[\"Counter\"]).To(BeEquivalentTo(2))\n// \t\tExpect(iterProfile0[\"Type\"]).To(BeEquivalentTo(redis.SearchFieldTypeVector.String()))\n// \t\tExpect(res1[\"total_results\"]).To(BeEquivalentTo(2))\n// \t\tresults0 := res1[\"results\"].([]interface{})[0].(map[interface{}]interface{})\n// \t\tExpect(results0[\"id\"]).To(BeEquivalentTo(\"a\"))\n// \t\tExpect(results0[\"extra_attributes\"].(map[interface{}]interface{})[\"__v_score\"]).To(BeEquivalentTo(\"0\"))\n// \t})\n\nvar _ = Describe(\"RediSearch commands Resp 3\", Label(\"search\"), func() {\n\tctx := context.TODO()\n\tvar client *redis.Client\n\tvar client2 *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(&redis.Options{Addr: \":6379\", Protocol: 3, UnstableResp3: true})\n\t\tclient2 = redis.NewClient(&redis.Options{Addr: \":6379\", Protocol: 3})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should handle FTAggregate with Unstable RESP3 Search Module and without stability\", Label(\"search\", \"ftcreate\", \"ftaggregate\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"PrimaryKey\", FieldType: redis.SearchFieldTypeText, Sortable: true}\n\t\tnum1 := &redis.FieldSchema{FieldName: \"CreatedDateTimeUTC\", FieldType: redis.SearchFieldTypeNumeric, Sortable: true}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, num1).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"PrimaryKey\", \"9::362330\", \"CreatedDateTimeUTC\", \"637387878524969984\")\n\t\tclient.HSet(ctx, \"doc2\", \"PrimaryKey\", \"9::362329\", \"CreatedDateTimeUTC\", \"637387875859270016\")\n\n\t\toptions := &redis.FTAggregateOptions{Apply: []redis.FTAggregateApply{{Field: \"@CreatedDateTimeUTC * 10\", As: \"CreatedDateTimeUTC\"}}}\n\t\tres, err := client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).RawResult()\n\t\tresults := res.(map[interface{}]interface{})[\"results\"].([]interface{})\n\t\tExpect(results[0].(map[interface{}]interface{})[\"extra_attributes\"].(map[interface{}]interface{})[\"CreatedDateTimeUTC\"]).\n\t\t\tTo(Or(BeEquivalentTo(\"6373878785249699840\"), BeEquivalentTo(\"6373878758592700416\")))\n\t\tExpect(results[1].(map[interface{}]interface{})[\"extra_attributes\"].(map[interface{}]interface{})[\"CreatedDateTimeUTC\"]).\n\t\t\tTo(Or(BeEquivalentTo(\"6373878785249699840\"), BeEquivalentTo(\"6373878758592700416\")))\n\n\t\trawVal := client.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).RawVal()\n\t\trawValResults := rawVal.(map[interface{}]interface{})[\"results\"].([]interface{})\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(rawValResults[0]).To(Or(BeEquivalentTo(results[0]), BeEquivalentTo(results[1])))\n\t\tExpect(rawValResults[1]).To(Or(BeEquivalentTo(results[0]), BeEquivalentTo(results[1])))\n\n\t\t// Test with UnstableResp3 false\n\t\tExpect(func() {\n\t\t\toptions = &redis.FTAggregateOptions{Apply: []redis.FTAggregateApply{{Field: \"@CreatedDateTimeUTC * 10\", As: \"CreatedDateTimeUTC\"}}}\n\t\t\trawRes, _ := client2.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).RawResult()\n\t\t\trawVal = client2.FTAggregateWithArgs(ctx, \"idx1\", \"*\", options).RawVal()\n\t\t\tExpect(rawRes).To(BeNil())\n\t\t\tExpect(rawVal).To(BeNil())\n\t\t}).Should(Panic())\n\n\t})\n\n\tIt(\"should handle FTInfo with Unstable RESP3 Search Module and without stability\", Label(\"search\", \"ftcreate\", \"ftinfo\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText, Sortable: true, NoStem: true}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tresInfo, err := client.FTInfo(ctx, \"idx1\").RawResult()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tattributes := resInfo.(map[interface{}]interface{})[\"attributes\"].([]interface{})\n\t\tflags := attributes[0].(map[interface{}]interface{})[\"flags\"].([]interface{})\n\t\tExpect(flags).To(ConsistOf(\"SORTABLE\", \"NOSTEM\"))\n\n\t\tvalInfo := client.FTInfo(ctx, \"idx1\").RawVal()\n\t\tattributes = valInfo.(map[interface{}]interface{})[\"attributes\"].([]interface{})\n\t\tflags = attributes[0].(map[interface{}]interface{})[\"flags\"].([]interface{})\n\t\tExpect(flags).To(ConsistOf(\"SORTABLE\", \"NOSTEM\"))\n\n\t\t// Test with UnstableResp3 false\n\t\tExpect(func() {\n\t\t\trawResInfo, _ := client2.FTInfo(ctx, \"idx1\").RawResult()\n\t\t\trawValInfo := client2.FTInfo(ctx, \"idx1\").RawVal()\n\t\t\tExpect(rawResInfo).To(BeNil())\n\t\t\tExpect(rawValInfo).To(BeNil())\n\t\t}).Should(Panic())\n\t})\n\n\tIt(\"should handle FTSpellCheck with Unstable RESP3 Search Module and without stability\", Label(\"search\", \"ftcreate\", \"ftspellcheck\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"f1\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"f2\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tclient.HSet(ctx, \"doc1\", \"f1\", \"some valid content\", \"f2\", \"this is sample text\")\n\t\tclient.HSet(ctx, \"doc2\", \"f1\", \"very important\", \"f2\", \"lorem ipsum\")\n\n\t\tresSpellCheck, err := client.FTSpellCheck(ctx, \"idx1\", \"impornant\").RawResult()\n\t\tvalSpellCheck := client.FTSpellCheck(ctx, \"idx1\", \"impornant\").RawVal()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(valSpellCheck).To(BeEquivalentTo(resSpellCheck))\n\t\tresults := resSpellCheck.(map[interface{}]interface{})[\"results\"].(map[interface{}]interface{})\n\t\tExpect(results[\"impornant\"].([]interface{})[0].(map[interface{}]interface{})[\"important\"]).To(BeEquivalentTo(0.5))\n\n\t\t// Test with UnstableResp3 false\n\t\tExpect(func() {\n\t\t\trawResSpellCheck, _ := client2.FTSpellCheck(ctx, \"idx1\", \"impornant\").RawResult()\n\t\t\trawValSpellCheck := client2.FTSpellCheck(ctx, \"idx1\", \"impornant\").RawVal()\n\t\t\tExpect(rawResSpellCheck).To(BeNil())\n\t\t\tExpect(rawValSpellCheck).To(BeNil())\n\t\t}).Should(Panic())\n\t})\n\n\tIt(\"should handle FTSearch with Unstable RESP3 Search Module and without stability\", Label(\"search\", \"ftcreate\", \"ftsearch\"), func() {\n\t\tval, err := client.FTCreate(ctx, \"txt\", &redis.FTCreateOptions{StopWords: []interface{}{\"foo\", \"bar\", \"baz\"}}, &redis.FieldSchema{FieldName: \"txt\", FieldType: redis.SearchFieldTypeText}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"txt\")\n\t\tclient.HSet(ctx, \"doc1\", \"txt\", \"foo baz\")\n\t\tclient.HSet(ctx, \"doc2\", \"txt\", \"hello world\")\n\t\tres1, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo bar\", &redis.FTSearchOptions{NoContent: true}).RawResult()\n\t\tval1 := client.FTSearchWithArgs(ctx, \"txt\", \"foo bar\", &redis.FTSearchOptions{NoContent: true}).RawVal()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val1).To(BeEquivalentTo(res1))\n\t\ttotalResults := res1.(map[interface{}]interface{})[\"total_results\"]\n\t\tExpect(totalResults).To(BeEquivalentTo(int64(0)))\n\t\tres2, err := client.FTSearchWithArgs(ctx, \"txt\", \"foo bar hello world\", &redis.FTSearchOptions{NoContent: true}).RawResult()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\ttotalResults2 := res2.(map[interface{}]interface{})[\"total_results\"]\n\t\tExpect(totalResults2).To(BeEquivalentTo(int64(1)))\n\n\t\t// Test with UnstableResp3 false\n\t\tExpect(func() {\n\t\t\trawRes2, _ := client2.FTSearchWithArgs(ctx, \"txt\", \"foo bar hello world\", &redis.FTSearchOptions{NoContent: true}).RawResult()\n\t\t\trawVal2 := client2.FTSearchWithArgs(ctx, \"txt\", \"foo bar hello world\", &redis.FTSearchOptions{NoContent: true}).RawVal()\n\t\t\tExpect(rawRes2).To(BeNil())\n\t\t\tExpect(rawVal2).To(BeNil())\n\t\t}).Should(Panic())\n\t})\n\tIt(\"should handle FTSynDump with Unstable RESP3 Search Module and without stability\", Label(\"search\", \"ftsyndump\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"title\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"body\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"idx1\", &redis.FTCreateOptions{OnHash: true}, text1, text2).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"idx1\")\n\n\t\tresSynUpdate, err := client.FTSynUpdate(ctx, \"idx1\", \"id1\", []interface{}{\"boy\", \"child\", \"offspring\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\n\t\tresSynUpdate, err = client.FTSynUpdate(ctx, \"idx1\", \"id1\", []interface{}{\"baby\", \"child\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\n\t\tresSynUpdate, err = client.FTSynUpdate(ctx, \"idx1\", \"id1\", []interface{}{\"tree\", \"wood\"}).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(resSynUpdate).To(BeEquivalentTo(\"OK\"))\n\n\t\tresSynDump, err := client.FTSynDump(ctx, \"idx1\").RawResult()\n\t\tvalSynDump := client.FTSynDump(ctx, \"idx1\").RawVal()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(valSynDump).To(BeEquivalentTo(resSynDump))\n\t\tExpect(resSynDump.(map[interface{}]interface{})[\"baby\"]).To(BeEquivalentTo([]interface{}{\"id1\"}))\n\n\t\t// Test with UnstableResp3 false\n\t\tExpect(func() {\n\t\t\trawResSynDump, _ := client2.FTSynDump(ctx, \"idx1\").RawResult()\n\t\t\trawValSynDump := client2.FTSynDump(ctx, \"idx1\").RawVal()\n\t\t\tExpect(rawResSynDump).To(BeNil())\n\t\t\tExpect(rawValSynDump).To(BeNil())\n\t\t}).Should(Panic())\n\t})\n\n\tIt(\"should test not affected Resp 3 Search method - FTExplain\", Label(\"search\", \"ftexplain\"), func() {\n\t\ttext1 := &redis.FieldSchema{FieldName: \"f1\", FieldType: redis.SearchFieldTypeText}\n\t\ttext2 := &redis.FieldSchema{FieldName: \"f2\", FieldType: redis.SearchFieldTypeText}\n\t\ttext3 := &redis.FieldSchema{FieldName: \"f3\", FieldType: redis.SearchFieldTypeText}\n\t\tval, err := client.FTCreate(ctx, \"txt\", &redis.FTCreateOptions{}, text1, text2, text3).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(BeEquivalentTo(\"OK\"))\n\t\tWaitForIndexing(client, \"txt\")\n\t\tres1, err := client.FTExplain(ctx, \"txt\", \"@f3:f3_val @f2:f2_val @f1:f1_val\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(res1).ToNot(BeEmpty())\n\n\t\t// Test with UnstableResp3 false\n\t\tExpect(func() {\n\t\t\tres2, err := client2.FTExplain(ctx, \"txt\", \"@f3:f3_val @f2:f2_val @f1:f1_val\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(res2).ToNot(BeEmpty())\n\t\t}).ShouldNot(Panic())\n\t})\n})\n"
        },
        {
          "name": "sentinel.go",
          "type": "blob",
          "size": 21.8662109375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/redis/go-redis/v9/internal\"\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/rand\"\n)\n\n//------------------------------------------------------------------------------\n\n// FailoverOptions are used to configure a failover client and should\n// be passed to NewFailoverClient.\ntype FailoverOptions struct {\n\t// The master name.\n\tMasterName string\n\t// A seed list of host:port addresses of sentinel nodes.\n\tSentinelAddrs []string\n\n\t// ClientName will execute the `CLIENT SETNAME ClientName` command for each conn.\n\tClientName string\n\n\t// If specified with SentinelPassword, enables ACL-based authentication (via\n\t// AUTH <user> <pass>).\n\tSentinelUsername string\n\t// Sentinel password from \"requirepass <password>\" (if enabled) in Sentinel\n\t// configuration, or, if SentinelUsername is also supplied, used for ACL-based\n\t// authentication.\n\tSentinelPassword string\n\n\t// Allows routing read-only commands to the closest master or replica node.\n\t// This option only works with NewFailoverClusterClient.\n\tRouteByLatency bool\n\t// Allows routing read-only commands to the random master or replica node.\n\t// This option only works with NewFailoverClusterClient.\n\tRouteRandomly bool\n\n\t// Route all commands to replica read-only nodes.\n\tReplicaOnly bool\n\n\t// Use replicas disconnected with master when cannot get connected replicas\n\t// Now, this option only works in RandomReplicaAddr function.\n\tUseDisconnectedReplicas bool\n\n\t// Following options are copied from Options struct.\n\n\tDialer    func(ctx context.Context, network, addr string) (net.Conn, error)\n\tOnConnect func(ctx context.Context, cn *Conn) error\n\n\tProtocol int\n\tUsername string\n\tPassword string\n\tDB       int\n\n\tMaxRetries      int\n\tMinRetryBackoff time.Duration\n\tMaxRetryBackoff time.Duration\n\n\tDialTimeout           time.Duration\n\tReadTimeout           time.Duration\n\tWriteTimeout          time.Duration\n\tContextTimeoutEnabled bool\n\n\tPoolFIFO bool\n\n\tPoolSize        int\n\tPoolTimeout     time.Duration\n\tMinIdleConns    int\n\tMaxIdleConns    int\n\tMaxActiveConns  int\n\tConnMaxIdleTime time.Duration\n\tConnMaxLifetime time.Duration\n\n\tTLSConfig *tls.Config\n\n\tDisableIndentity bool\n\tIdentitySuffix   string\n\tUnstableResp3    bool\n}\n\nfunc (opt *FailoverOptions) clientOptions() *Options {\n\treturn &Options{\n\t\tAddr:       \"FailoverClient\",\n\t\tClientName: opt.ClientName,\n\n\t\tDialer:    opt.Dialer,\n\t\tOnConnect: opt.OnConnect,\n\n\t\tDB:       opt.DB,\n\t\tProtocol: opt.Protocol,\n\t\tUsername: opt.Username,\n\t\tPassword: opt.Password,\n\n\t\tMaxRetries:      opt.MaxRetries,\n\t\tMinRetryBackoff: opt.MinRetryBackoff,\n\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n\n\t\tDialTimeout:           opt.DialTimeout,\n\t\tReadTimeout:           opt.ReadTimeout,\n\t\tWriteTimeout:          opt.WriteTimeout,\n\t\tContextTimeoutEnabled: opt.ContextTimeoutEnabled,\n\n\t\tPoolFIFO:        opt.PoolFIFO,\n\t\tPoolSize:        opt.PoolSize,\n\t\tPoolTimeout:     opt.PoolTimeout,\n\t\tMinIdleConns:    opt.MinIdleConns,\n\t\tMaxIdleConns:    opt.MaxIdleConns,\n\t\tMaxActiveConns:  opt.MaxActiveConns,\n\t\tConnMaxIdleTime: opt.ConnMaxIdleTime,\n\t\tConnMaxLifetime: opt.ConnMaxLifetime,\n\n\t\tTLSConfig: opt.TLSConfig,\n\n\t\tDisableIndentity: opt.DisableIndentity,\n\t\tIdentitySuffix:   opt.IdentitySuffix,\n\t\tUnstableResp3:    opt.UnstableResp3,\n\t}\n}\n\nfunc (opt *FailoverOptions) sentinelOptions(addr string) *Options {\n\treturn &Options{\n\t\tAddr:       addr,\n\t\tClientName: opt.ClientName,\n\n\t\tDialer:    opt.Dialer,\n\t\tOnConnect: opt.OnConnect,\n\n\t\tDB:       0,\n\t\tUsername: opt.SentinelUsername,\n\t\tPassword: opt.SentinelPassword,\n\n\t\tMaxRetries:      opt.MaxRetries,\n\t\tMinRetryBackoff: opt.MinRetryBackoff,\n\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n\n\t\tDialTimeout:           opt.DialTimeout,\n\t\tReadTimeout:           opt.ReadTimeout,\n\t\tWriteTimeout:          opt.WriteTimeout,\n\t\tContextTimeoutEnabled: opt.ContextTimeoutEnabled,\n\n\t\tPoolFIFO:        opt.PoolFIFO,\n\t\tPoolSize:        opt.PoolSize,\n\t\tPoolTimeout:     opt.PoolTimeout,\n\t\tMinIdleConns:    opt.MinIdleConns,\n\t\tMaxIdleConns:    opt.MaxIdleConns,\n\t\tMaxActiveConns:  opt.MaxActiveConns,\n\t\tConnMaxIdleTime: opt.ConnMaxIdleTime,\n\t\tConnMaxLifetime: opt.ConnMaxLifetime,\n\n\t\tTLSConfig: opt.TLSConfig,\n\n\t\tDisableIndentity: opt.DisableIndentity,\n\t\tIdentitySuffix:   opt.IdentitySuffix,\n\t\tUnstableResp3:    opt.UnstableResp3,\n\t}\n}\n\nfunc (opt *FailoverOptions) clusterOptions() *ClusterOptions {\n\treturn &ClusterOptions{\n\t\tClientName: opt.ClientName,\n\n\t\tDialer:    opt.Dialer,\n\t\tOnConnect: opt.OnConnect,\n\n\t\tProtocol: opt.Protocol,\n\t\tUsername: opt.Username,\n\t\tPassword: opt.Password,\n\n\t\tMaxRedirects: opt.MaxRetries,\n\n\t\tRouteByLatency: opt.RouteByLatency,\n\t\tRouteRandomly:  opt.RouteRandomly,\n\n\t\tMinRetryBackoff: opt.MinRetryBackoff,\n\t\tMaxRetryBackoff: opt.MaxRetryBackoff,\n\n\t\tDialTimeout:           opt.DialTimeout,\n\t\tReadTimeout:           opt.ReadTimeout,\n\t\tWriteTimeout:          opt.WriteTimeout,\n\t\tContextTimeoutEnabled: opt.ContextTimeoutEnabled,\n\n\t\tPoolFIFO:        opt.PoolFIFO,\n\t\tPoolSize:        opt.PoolSize,\n\t\tPoolTimeout:     opt.PoolTimeout,\n\t\tMinIdleConns:    opt.MinIdleConns,\n\t\tMaxIdleConns:    opt.MaxIdleConns,\n\t\tMaxActiveConns:  opt.MaxActiveConns,\n\t\tConnMaxIdleTime: opt.ConnMaxIdleTime,\n\t\tConnMaxLifetime: opt.ConnMaxLifetime,\n\n\t\tTLSConfig: opt.TLSConfig,\n\n\t\tDisableIndentity: opt.DisableIndentity,\n\t\tIdentitySuffix:   opt.IdentitySuffix,\n\t}\n}\n\n// NewFailoverClient returns a Redis client that uses Redis Sentinel\n// for automatic failover. It's safe for concurrent use by multiple\n// goroutines.\nfunc NewFailoverClient(failoverOpt *FailoverOptions) *Client {\n\tif failoverOpt.RouteByLatency {\n\t\tpanic(\"to route commands by latency, use NewFailoverClusterClient\")\n\t}\n\tif failoverOpt.RouteRandomly {\n\t\tpanic(\"to route commands randomly, use NewFailoverClusterClient\")\n\t}\n\n\tsentinelAddrs := make([]string, len(failoverOpt.SentinelAddrs))\n\tcopy(sentinelAddrs, failoverOpt.SentinelAddrs)\n\n\trand.Shuffle(len(sentinelAddrs), func(i, j int) {\n\t\tsentinelAddrs[i], sentinelAddrs[j] = sentinelAddrs[j], sentinelAddrs[i]\n\t})\n\n\tfailover := &sentinelFailover{\n\t\topt:           failoverOpt,\n\t\tsentinelAddrs: sentinelAddrs,\n\t}\n\n\topt := failoverOpt.clientOptions()\n\topt.Dialer = masterReplicaDialer(failover)\n\topt.init()\n\n\tvar connPool *pool.ConnPool\n\n\trdb := &Client{\n\t\tbaseClient: &baseClient{\n\t\t\topt: opt,\n\t\t},\n\t}\n\trdb.init()\n\n\tconnPool = newConnPool(opt, rdb.dialHook)\n\trdb.connPool = connPool\n\trdb.onClose = failover.Close\n\n\tfailover.mu.Lock()\n\tfailover.onFailover = func(ctx context.Context, addr string) {\n\t\t_ = connPool.Filter(func(cn *pool.Conn) bool {\n\t\t\treturn cn.RemoteAddr().String() != addr\n\t\t})\n\t}\n\tfailover.mu.Unlock()\n\n\treturn rdb\n}\n\nfunc masterReplicaDialer(\n\tfailover *sentinelFailover,\n) func(ctx context.Context, network, addr string) (net.Conn, error) {\n\treturn func(ctx context.Context, network, _ string) (net.Conn, error) {\n\t\tvar addr string\n\t\tvar err error\n\n\t\tif failover.opt.ReplicaOnly {\n\t\t\taddr, err = failover.RandomReplicaAddr(ctx)\n\t\t} else {\n\t\t\taddr, err = failover.MasterAddr(ctx)\n\t\t\tif err == nil {\n\t\t\t\tfailover.trySwitchMaster(ctx, addr)\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif failover.opt.Dialer != nil {\n\t\t\treturn failover.opt.Dialer(ctx, network, addr)\n\t\t}\n\n\t\tnetDialer := &net.Dialer{\n\t\t\tTimeout:   failover.opt.DialTimeout,\n\t\t\tKeepAlive: 5 * time.Minute,\n\t\t}\n\t\tif failover.opt.TLSConfig == nil {\n\t\t\treturn netDialer.DialContext(ctx, network, addr)\n\t\t}\n\t\treturn tls.DialWithDialer(netDialer, network, addr, failover.opt.TLSConfig)\n\t}\n}\n\n//------------------------------------------------------------------------------\n\n// SentinelClient is a client for a Redis Sentinel.\ntype SentinelClient struct {\n\t*baseClient\n\thooksMixin\n}\n\nfunc NewSentinelClient(opt *Options) *SentinelClient {\n\topt.init()\n\tc := &SentinelClient{\n\t\tbaseClient: &baseClient{\n\t\t\topt: opt,\n\t\t},\n\t}\n\n\tc.initHooks(hooks{\n\t\tdial:    c.baseClient.dial,\n\t\tprocess: c.baseClient.process,\n\t})\n\tc.connPool = newConnPool(opt, c.dialHook)\n\n\treturn c\n}\n\nfunc (c *SentinelClient) Process(ctx context.Context, cmd Cmder) error {\n\terr := c.processHook(ctx, cmd)\n\tcmd.SetErr(err)\n\treturn err\n}\n\nfunc (c *SentinelClient) pubSub() *PubSub {\n\tpubsub := &PubSub{\n\t\topt: c.opt,\n\n\t\tnewConn: func(ctx context.Context, channels []string) (*pool.Conn, error) {\n\t\t\treturn c.newConn(ctx)\n\t\t},\n\t\tcloseConn: c.connPool.CloseConn,\n\t}\n\tpubsub.init()\n\treturn pubsub\n}\n\n// Ping is used to test if a connection is still alive, or to\n// measure latency.\nfunc (c *SentinelClient) Ping(ctx context.Context) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"ping\")\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Subscribe subscribes the client to the specified channels.\n// Channels can be omitted to create empty subscription.\nfunc (c *SentinelClient) Subscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.Subscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\n// PSubscribe subscribes the client to the given patterns.\n// Patterns can be omitted to create empty subscription.\nfunc (c *SentinelClient) PSubscribe(ctx context.Context, channels ...string) *PubSub {\n\tpubsub := c.pubSub()\n\tif len(channels) > 0 {\n\t\t_ = pubsub.PSubscribe(ctx, channels...)\n\t}\n\treturn pubsub\n}\n\nfunc (c *SentinelClient) GetMasterAddrByName(ctx context.Context, name string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"sentinel\", \"get-master-addr-by-name\", name)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c *SentinelClient) Sentinels(ctx context.Context, name string) *MapStringStringSliceCmd {\n\tcmd := NewMapStringStringSliceCmd(ctx, \"sentinel\", \"sentinels\", name)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Failover forces a failover as if the master was not reachable, and without\n// asking for agreement to other Sentinels.\nfunc (c *SentinelClient) Failover(ctx context.Context, name string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"sentinel\", \"failover\", name)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Reset resets all the masters with matching name. The pattern argument is a\n// glob-style pattern. The reset process clears any previous state in a master\n// (including a failover in progress), and removes every replica and sentinel\n// already discovered and associated with the master.\nfunc (c *SentinelClient) Reset(ctx context.Context, pattern string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"sentinel\", \"reset\", pattern)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// FlushConfig forces Sentinel to rewrite its configuration on disk, including\n// the current Sentinel state.\nfunc (c *SentinelClient) FlushConfig(ctx context.Context) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"sentinel\", \"flushconfig\")\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Master shows the state and info of the specified master.\nfunc (c *SentinelClient) Master(ctx context.Context, name string) *MapStringStringCmd {\n\tcmd := NewMapStringStringCmd(ctx, \"sentinel\", \"master\", name)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Masters shows a list of monitored masters and their state.\nfunc (c *SentinelClient) Masters(ctx context.Context) *SliceCmd {\n\tcmd := NewSliceCmd(ctx, \"sentinel\", \"masters\")\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Replicas shows a list of replicas for the specified master and their state.\nfunc (c *SentinelClient) Replicas(ctx context.Context, name string) *MapStringStringSliceCmd {\n\tcmd := NewMapStringStringSliceCmd(ctx, \"sentinel\", \"replicas\", name)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// CkQuorum checks if the current Sentinel configuration is able to reach the\n// quorum needed to failover a master, and the majority needed to authorize the\n// failover. This command should be used in monitoring systems to check if a\n// Sentinel deployment is ok.\nfunc (c *SentinelClient) CkQuorum(ctx context.Context, name string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"sentinel\", \"ckquorum\", name)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Monitor tells the Sentinel to start monitoring a new master with the specified\n// name, ip, port, and quorum.\nfunc (c *SentinelClient) Monitor(ctx context.Context, name, ip, port, quorum string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"sentinel\", \"monitor\", name, ip, port, quorum)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Set is used in order to change configuration parameters of a specific master.\nfunc (c *SentinelClient) Set(ctx context.Context, name, option, value string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"sentinel\", \"set\", name, option, value)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Remove is used in order to remove the specified master: the master will no\n// longer be monitored, and will totally be removed from the internal state of\n// the Sentinel.\nfunc (c *SentinelClient) Remove(ctx context.Context, name string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"sentinel\", \"remove\", name)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n//------------------------------------------------------------------------------\n\ntype sentinelFailover struct {\n\topt *FailoverOptions\n\n\tsentinelAddrs []string\n\n\tonFailover func(ctx context.Context, addr string)\n\tonUpdate   func(ctx context.Context)\n\n\tmu          sync.RWMutex\n\t_masterAddr string\n\tsentinel    *SentinelClient\n\tpubsub      *PubSub\n}\n\nfunc (c *sentinelFailover) Close() error {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tif c.sentinel != nil {\n\t\treturn c.closeSentinel()\n\t}\n\treturn nil\n}\n\nfunc (c *sentinelFailover) closeSentinel() error {\n\tfirstErr := c.pubsub.Close()\n\tc.pubsub = nil\n\n\terr := c.sentinel.Close()\n\tif err != nil && firstErr == nil {\n\t\tfirstErr = err\n\t}\n\tc.sentinel = nil\n\n\treturn firstErr\n}\n\nfunc (c *sentinelFailover) RandomReplicaAddr(ctx context.Context) (string, error) {\n\tif c.opt == nil {\n\t\treturn \"\", errors.New(\"opt is nil\")\n\t}\n\n\taddresses, err := c.replicaAddrs(ctx, false)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif len(addresses) == 0 && c.opt.UseDisconnectedReplicas {\n\t\taddresses, err = c.replicaAddrs(ctx, true)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tif len(addresses) == 0 {\n\t\treturn c.MasterAddr(ctx)\n\t}\n\treturn addresses[rand.Intn(len(addresses))], nil\n}\n\nfunc (c *sentinelFailover) MasterAddr(ctx context.Context) (string, error) {\n\tc.mu.RLock()\n\tsentinel := c.sentinel\n\tc.mu.RUnlock()\n\n\tif sentinel != nil {\n\t\taddr, err := c.getMasterAddr(ctx, sentinel)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\t// Continue on other errors\n\t\t\tinternal.Logger.Printf(ctx, \"sentinel: GetMasterAddrByName name=%q failed: %s\",\n\t\t\t\tc.opt.MasterName, err)\n\t\t} else {\n\t\t\treturn addr, nil\n\t\t}\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.sentinel != nil {\n\t\taddr, err := c.getMasterAddr(ctx, c.sentinel)\n\t\tif err != nil {\n\t\t\t_ = c.closeSentinel()\n\t\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\t// Continue on other errors\n\t\t\tinternal.Logger.Printf(ctx, \"sentinel: GetMasterAddrByName name=%q failed: %s\",\n\t\t\t\tc.opt.MasterName, err)\n\t\t} else {\n\t\t\treturn addr, nil\n\t\t}\n\t}\n\n\tfor i, sentinelAddr := range c.sentinelAddrs {\n\t\tsentinel := NewSentinelClient(c.opt.sentinelOptions(sentinelAddr))\n\n\t\tmasterAddr, err := sentinel.GetMasterAddrByName(ctx, c.opt.MasterName).Result()\n\t\tif err != nil {\n\t\t\t_ = sentinel.Close()\n\t\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\tinternal.Logger.Printf(ctx, \"sentinel: GetMasterAddrByName master=%q failed: %s\",\n\t\t\t\tc.opt.MasterName, err)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Push working sentinel to the top.\n\t\tc.sentinelAddrs[0], c.sentinelAddrs[i] = c.sentinelAddrs[i], c.sentinelAddrs[0]\n\t\tc.setSentinel(ctx, sentinel)\n\n\t\taddr := net.JoinHostPort(masterAddr[0], masterAddr[1])\n\t\treturn addr, nil\n\t}\n\n\treturn \"\", errors.New(\"redis: all sentinels specified in configuration are unreachable\")\n}\n\nfunc (c *sentinelFailover) replicaAddrs(ctx context.Context, useDisconnected bool) ([]string, error) {\n\tc.mu.RLock()\n\tsentinel := c.sentinel\n\tc.mu.RUnlock()\n\n\tif sentinel != nil {\n\t\taddrs, err := c.getReplicaAddrs(ctx, sentinel)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t// Continue on other errors\n\t\t\tinternal.Logger.Printf(ctx, \"sentinel: Replicas name=%q failed: %s\",\n\t\t\t\tc.opt.MasterName, err)\n\t\t} else if len(addrs) > 0 {\n\t\t\treturn addrs, nil\n\t\t}\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif c.sentinel != nil {\n\t\taddrs, err := c.getReplicaAddrs(ctx, c.sentinel)\n\t\tif err != nil {\n\t\t\t_ = c.closeSentinel()\n\t\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t// Continue on other errors\n\t\t\tinternal.Logger.Printf(ctx, \"sentinel: Replicas name=%q failed: %s\",\n\t\t\t\tc.opt.MasterName, err)\n\t\t} else if len(addrs) > 0 {\n\t\t\treturn addrs, nil\n\t\t} else {\n\t\t\t// No error and no replicas.\n\t\t\t_ = c.closeSentinel()\n\t\t}\n\t}\n\n\tvar sentinelReachable bool\n\n\tfor i, sentinelAddr := range c.sentinelAddrs {\n\t\tsentinel := NewSentinelClient(c.opt.sentinelOptions(sentinelAddr))\n\n\t\treplicas, err := sentinel.Replicas(ctx, c.opt.MasterName).Result()\n\t\tif err != nil {\n\t\t\t_ = sentinel.Close()\n\t\t\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tinternal.Logger.Printf(ctx, \"sentinel: Replicas master=%q failed: %s\",\n\t\t\t\tc.opt.MasterName, err)\n\t\t\tcontinue\n\t\t}\n\t\tsentinelReachable = true\n\t\taddrs := parseReplicaAddrs(replicas, useDisconnected)\n\t\tif len(addrs) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\t// Push working sentinel to the top.\n\t\tc.sentinelAddrs[0], c.sentinelAddrs[i] = c.sentinelAddrs[i], c.sentinelAddrs[0]\n\t\tc.setSentinel(ctx, sentinel)\n\n\t\treturn addrs, nil\n\t}\n\n\tif sentinelReachable {\n\t\treturn []string{}, nil\n\t}\n\treturn []string{}, errors.New(\"redis: all sentinels specified in configuration are unreachable\")\n}\n\nfunc (c *sentinelFailover) getMasterAddr(ctx context.Context, sentinel *SentinelClient) (string, error) {\n\taddr, err := sentinel.GetMasterAddrByName(ctx, c.opt.MasterName).Result()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn net.JoinHostPort(addr[0], addr[1]), nil\n}\n\nfunc (c *sentinelFailover) getReplicaAddrs(ctx context.Context, sentinel *SentinelClient) ([]string, error) {\n\taddrs, err := sentinel.Replicas(ctx, c.opt.MasterName).Result()\n\tif err != nil {\n\t\tinternal.Logger.Printf(ctx, \"sentinel: Replicas name=%q failed: %s\",\n\t\t\tc.opt.MasterName, err)\n\t\treturn nil, err\n\t}\n\treturn parseReplicaAddrs(addrs, false), nil\n}\n\nfunc parseReplicaAddrs(addrs []map[string]string, keepDisconnected bool) []string {\n\tnodes := make([]string, 0, len(addrs))\n\tfor _, node := range addrs {\n\t\tisDown := false\n\t\tif flags, ok := node[\"flags\"]; ok {\n\t\t\tfor _, flag := range strings.Split(flags, \",\") {\n\t\t\t\tswitch flag {\n\t\t\t\tcase \"s_down\", \"o_down\":\n\t\t\t\t\tisDown = true\n\t\t\t\tcase \"disconnected\":\n\t\t\t\t\tif !keepDisconnected {\n\t\t\t\t\t\tisDown = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !isDown && node[\"ip\"] != \"\" && node[\"port\"] != \"\" {\n\t\t\tnodes = append(nodes, net.JoinHostPort(node[\"ip\"], node[\"port\"]))\n\t\t}\n\t}\n\n\treturn nodes\n}\n\nfunc (c *sentinelFailover) trySwitchMaster(ctx context.Context, addr string) {\n\tc.mu.RLock()\n\tcurrentAddr := c._masterAddr //nolint:ifshort\n\tc.mu.RUnlock()\n\n\tif addr == currentAddr {\n\t\treturn\n\t}\n\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif addr == c._masterAddr {\n\t\treturn\n\t}\n\tc._masterAddr = addr\n\n\tinternal.Logger.Printf(ctx, \"sentinel: new master=%q addr=%q\",\n\t\tc.opt.MasterName, addr)\n\tif c.onFailover != nil {\n\t\tc.onFailover(ctx, addr)\n\t}\n}\n\nfunc (c *sentinelFailover) setSentinel(ctx context.Context, sentinel *SentinelClient) {\n\tif c.sentinel != nil {\n\t\tpanic(\"not reached\")\n\t}\n\tc.sentinel = sentinel\n\tc.discoverSentinels(ctx)\n\n\tc.pubsub = sentinel.Subscribe(ctx, \"+switch-master\", \"+replica-reconf-done\")\n\tgo c.listen(c.pubsub)\n}\n\nfunc (c *sentinelFailover) discoverSentinels(ctx context.Context) {\n\tsentinels, err := c.sentinel.Sentinels(ctx, c.opt.MasterName).Result()\n\tif err != nil {\n\t\tinternal.Logger.Printf(ctx, \"sentinel: Sentinels master=%q failed: %s\", c.opt.MasterName, err)\n\t\treturn\n\t}\n\tfor _, sentinel := range sentinels {\n\t\tip, ok := sentinel[\"ip\"]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tport, ok := sentinel[\"port\"]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif ip != \"\" && port != \"\" {\n\t\t\tsentinelAddr := net.JoinHostPort(ip, port)\n\t\t\tif !contains(c.sentinelAddrs, sentinelAddr) {\n\t\t\t\tinternal.Logger.Printf(ctx, \"sentinel: discovered new sentinel=%q for master=%q\",\n\t\t\t\t\tsentinelAddr, c.opt.MasterName)\n\t\t\t\tc.sentinelAddrs = append(c.sentinelAddrs, sentinelAddr)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (c *sentinelFailover) listen(pubsub *PubSub) {\n\tctx := context.TODO()\n\n\tif c.onUpdate != nil {\n\t\tc.onUpdate(ctx)\n\t}\n\n\tch := pubsub.Channel()\n\tfor msg := range ch {\n\t\tif msg.Channel == \"+switch-master\" {\n\t\t\tparts := strings.Split(msg.Payload, \" \")\n\t\t\tif parts[0] != c.opt.MasterName {\n\t\t\t\tinternal.Logger.Printf(pubsub.getContext(), \"sentinel: ignore addr for master=%q\", parts[0])\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\taddr := net.JoinHostPort(parts[3], parts[4])\n\t\t\tc.trySwitchMaster(pubsub.getContext(), addr)\n\t\t}\n\n\t\tif c.onUpdate != nil {\n\t\t\tc.onUpdate(ctx)\n\t\t}\n\t}\n}\n\nfunc contains(slice []string, str string) bool {\n\tfor _, s := range slice {\n\t\tif s == str {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n//------------------------------------------------------------------------------\n\n// NewFailoverClusterClient returns a client that supports routing read-only commands\n// to a replica node.\nfunc NewFailoverClusterClient(failoverOpt *FailoverOptions) *ClusterClient {\n\tsentinelAddrs := make([]string, len(failoverOpt.SentinelAddrs))\n\tcopy(sentinelAddrs, failoverOpt.SentinelAddrs)\n\n\tfailover := &sentinelFailover{\n\t\topt:           failoverOpt,\n\t\tsentinelAddrs: sentinelAddrs,\n\t}\n\n\topt := failoverOpt.clusterOptions()\n\topt.ClusterSlots = func(ctx context.Context) ([]ClusterSlot, error) {\n\t\tmasterAddr, err := failover.MasterAddr(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tnodes := []ClusterNode{{\n\t\t\tAddr: masterAddr,\n\t\t}}\n\n\t\treplicaAddrs, err := failover.replicaAddrs(ctx, false)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, replicaAddr := range replicaAddrs {\n\t\t\tnodes = append(nodes, ClusterNode{\n\t\t\t\tAddr: replicaAddr,\n\t\t\t})\n\t\t}\n\n\t\tslots := []ClusterSlot{\n\t\t\t{\n\t\t\t\tStart: 0,\n\t\t\t\tEnd:   16383,\n\t\t\t\tNodes: nodes,\n\t\t\t},\n\t\t}\n\t\treturn slots, nil\n\t}\n\n\tc := NewClusterClient(opt)\n\n\tfailover.mu.Lock()\n\tfailover.onUpdate = func(ctx context.Context) {\n\t\tc.ReloadState(ctx)\n\t}\n\tfailover.mu.Unlock()\n\n\treturn c\n}\n"
        },
        {
          "name": "sentinel_test.go",
          "type": "blob",
          "size": 10.34765625,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"net\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"Sentinel PROTO 2\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewFailoverClient(&redis.FailoverOptions{\n\t\t\tMasterName:    sentinelName,\n\t\t\tSentinelAddrs: sentinelAddrs,\n\t\t\tMaxRetries:    -1,\n\t\t\tProtocol:      2,\n\t\t})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\t_ = client.Close()\n\t})\n\n\tIt(\"should sentinel client PROTO 2\", func() {\n\t\tval, err := client.Do(ctx, \"HELLO\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).Should(ContainElements(\"proto\", int64(2)))\n\t})\n})\n\nvar _ = Describe(\"Sentinel\", func() {\n\tvar client *redis.Client\n\tvar master *redis.Client\n\tvar masterPort string\n\tvar sentinel *redis.SentinelClient\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewFailoverClient(&redis.FailoverOptions{\n\t\t\tClientName:    \"sentinel_hi\",\n\t\t\tMasterName:    sentinelName,\n\t\t\tSentinelAddrs: sentinelAddrs,\n\t\t\tMaxRetries:    -1,\n\t\t})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\n\t\tsentinel = redis.NewSentinelClient(&redis.Options{\n\t\t\tAddr:       \":\" + sentinelPort1,\n\t\t\tMaxRetries: -1,\n\t\t})\n\n\t\taddr, err := sentinel.GetMasterAddrByName(ctx, sentinelName).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tmaster = redis.NewClient(&redis.Options{\n\t\t\tAddr:       net.JoinHostPort(addr[0], addr[1]),\n\t\t\tMaxRetries: -1,\n\t\t})\n\t\tmasterPort = addr[1]\n\n\t\t// Wait until slaves are picked up by sentinel.\n\t\tEventually(func() string {\n\t\t\treturn sentinel1.Info(ctx).Val()\n\t\t}, \"15s\", \"100ms\").Should(ContainSubstring(\"slaves=2\"))\n\t\tEventually(func() string {\n\t\t\treturn sentinel2.Info(ctx).Val()\n\t\t}, \"15s\", \"100ms\").Should(ContainSubstring(\"slaves=2\"))\n\t\tEventually(func() string {\n\t\t\treturn sentinel3.Info(ctx).Val()\n\t\t}, \"15s\", \"100ms\").Should(ContainSubstring(\"slaves=2\"))\n\t})\n\n\tAfterEach(func() {\n\t\t_ = client.Close()\n\t\t_ = master.Close()\n\t\t_ = sentinel.Close()\n\t})\n\n\tIt(\"should facilitate failover\", func() {\n\t\t// Set value on master.\n\t\terr := client.Set(ctx, \"foo\", \"master\", 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t// Verify.\n\t\tval, err := client.Get(ctx, \"foo\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(\"master\"))\n\n\t\t// Verify master->slaves sync.\n\t\tvar slavesAddr []string\n\t\tEventually(func() []string {\n\t\t\tslavesAddr = redis.GetSlavesAddrByName(ctx, sentinel, sentinelName)\n\t\t\treturn slavesAddr\n\t\t}, \"15s\", \"100ms\").Should(HaveLen(2))\n\t\tEventually(func() bool {\n\t\t\tsync := true\n\t\t\tfor _, addr := range slavesAddr {\n\t\t\t\tslave := redis.NewClient(&redis.Options{\n\t\t\t\t\tAddr:       addr,\n\t\t\t\t\tMaxRetries: -1,\n\t\t\t\t})\n\t\t\t\tsync = slave.Get(ctx, \"foo\").Val() == \"master\"\n\t\t\t\t_ = slave.Close()\n\t\t\t}\n\t\t\treturn sync\n\t\t}, \"15s\", \"100ms\").Should(BeTrue())\n\n\t\t// Create subscription.\n\t\tpub := client.Subscribe(ctx, \"foo\")\n\t\tch := pub.Channel()\n\n\t\t// Kill master.\n\t\terr = master.Shutdown(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tEventually(func() error {\n\t\t\treturn master.Ping(ctx).Err()\n\t\t}, \"15s\", \"100ms\").Should(HaveOccurred())\n\n\t\t// Check that client picked up new master.\n\t\tEventually(func() string {\n\t\t\treturn client.Get(ctx, \"foo\").Val()\n\t\t}, \"15s\", \"100ms\").Should(Equal(\"master\"))\n\n\t\t// Check if subscription is renewed.\n\t\tvar msg *redis.Message\n\t\tEventually(func() <-chan *redis.Message {\n\t\t\t_ = client.Publish(ctx, \"foo\", \"hello\").Err()\n\t\t\treturn ch\n\t\t}, \"15s\", \"100ms\").Should(Receive(&msg))\n\t\tExpect(msg.Channel).To(Equal(\"foo\"))\n\t\tExpect(msg.Payload).To(Equal(\"hello\"))\n\t\tExpect(pub.Close()).NotTo(HaveOccurred())\n\n\t\t_, err = startRedis(masterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"supports DB selection\", func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\n\t\tclient = redis.NewFailoverClient(&redis.FailoverOptions{\n\t\t\tMasterName:    sentinelName,\n\t\t\tSentinelAddrs: sentinelAddrs,\n\t\t\tDB:            1,\n\t\t})\n\t\terr := client.Ping(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should sentinel client setname\", func() {\n\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t\tval, err := client.ClientList(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).Should(ContainSubstring(\"name=sentinel_hi\"))\n\t})\n\n\tIt(\"should sentinel client PROTO 3\", func() {\n\t\tval, err := client.Do(ctx, \"HELLO\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).Should(HaveKeyWithValue(\"proto\", int64(3)))\n\t})\n})\n\nvar _ = Describe(\"NewFailoverClusterClient PROTO 2\", func() {\n\tvar client *redis.ClusterClient\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewFailoverClusterClient(&redis.FailoverOptions{\n\t\t\tMasterName:    sentinelName,\n\t\t\tSentinelAddrs: sentinelAddrs,\n\t\t\tProtocol:      2,\n\n\t\t\tRouteRandomly: true,\n\t\t})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\t_ = client.Close()\n\t})\n\n\tIt(\"should sentinel cluster PROTO 2\", func() {\n\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\tval, err := client.Do(ctx, \"HELLO\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).Should(ContainElements(\"proto\", int64(2)))\n\t\t\treturn nil\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"NewFailoverClusterClient\", func() {\n\tvar client *redis.ClusterClient\n\tvar master *redis.Client\n\tvar masterPort string\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewFailoverClusterClient(&redis.FailoverOptions{\n\t\t\tClientName:    \"sentinel_cluster_hi\",\n\t\t\tMasterName:    sentinelName,\n\t\t\tSentinelAddrs: sentinelAddrs,\n\n\t\t\tRouteRandomly: true,\n\t\t})\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\n\t\tsentinel := redis.NewSentinelClient(&redis.Options{\n\t\t\tAddr:       \":\" + sentinelPort1,\n\t\t\tMaxRetries: -1,\n\t\t})\n\n\t\taddr, err := sentinel.GetMasterAddrByName(ctx, sentinelName).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tmaster = redis.NewClient(&redis.Options{\n\t\t\tAddr:       net.JoinHostPort(addr[0], addr[1]),\n\t\t\tMaxRetries: -1,\n\t\t})\n\t\tmasterPort = addr[1]\n\n\t\t// Wait until slaves are picked up by sentinel.\n\t\tEventually(func() string {\n\t\t\treturn sentinel1.Info(ctx).Val()\n\t\t}, \"15s\", \"100ms\").Should(ContainSubstring(\"slaves=2\"))\n\t\tEventually(func() string {\n\t\t\treturn sentinel2.Info(ctx).Val()\n\t\t}, \"15s\", \"100ms\").Should(ContainSubstring(\"slaves=2\"))\n\t\tEventually(func() string {\n\t\t\treturn sentinel3.Info(ctx).Val()\n\t\t}, \"15s\", \"100ms\").Should(ContainSubstring(\"slaves=2\"))\n\t})\n\n\tAfterEach(func() {\n\t\t_ = client.Close()\n\t\t_ = master.Close()\n\t})\n\n\tIt(\"should facilitate failover\", func() {\n\t\tSkip(\"Flaky Test\")\n\t\t// Set value.\n\t\terr := client.Set(ctx, \"foo\", \"master\", 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t// Verify.\n\t\t\tEventually(func() string {\n\t\t\t\treturn client.Get(ctx, \"foo\").Val()\n\t\t\t}, \"15s\", \"1ms\").Should(Equal(\"master\"))\n\t\t}\n\n\t\t// Create subscription.\n\t\tsub := client.Subscribe(ctx, \"foo\")\n\t\tch := sub.Channel()\n\n\t\t// Kill master.\n\t\terr = master.Shutdown(ctx).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tEventually(func() error {\n\t\t\treturn master.Ping(ctx).Err()\n\t\t}, \"15s\", \"100ms\").Should(HaveOccurred())\n\n\t\t// Check that client picked up new master.\n\t\tEventually(func() string {\n\t\t\treturn client.Get(ctx, \"foo\").Val()\n\t\t}, \"15s\", \"100ms\").Should(Equal(\"master\"))\n\n\t\t// Check if subscription is renewed.\n\t\tvar msg *redis.Message\n\t\tEventually(func() <-chan *redis.Message {\n\t\t\t_ = client.Publish(ctx, \"foo\", \"hello\").Err()\n\t\t\treturn ch\n\t\t}, \"15s\", \"100ms\").Should(Receive(&msg))\n\t\tExpect(msg.Channel).To(Equal(\"foo\"))\n\t\tExpect(msg.Payload).To(Equal(\"hello\"))\n\t\tExpect(sub.Close()).NotTo(HaveOccurred())\n\n\t\t_, err = startRedis(masterPort)\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should sentinel cluster client setname\", func() {\n\t\tSkip(\"Flaky Test\")\n\t\terr := client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\treturn c.Ping(ctx).Err()\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\tval, err := c.ClientList(ctx).Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).Should(ContainSubstring(\"name=sentinel_cluster_hi\"))\n\t\t\treturn nil\n\t\t})\n\t})\n\n\tIt(\"should sentinel cluster PROTO 3\", func() {\n\t\tSkip(\"Flaky Test\")\n\t\t_ = client.ForEachShard(ctx, func(ctx context.Context, c *redis.Client) error {\n\t\t\tval, err := client.Do(ctx, \"HELLO\").Result()\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(val).Should(HaveKeyWithValue(\"proto\", int64(3)))\n\t\t\treturn nil\n\t\t})\n\t})\n})\n\nvar _ = Describe(\"SentinelAclAuth\", func() {\n\tconst (\n\t\taclSentinelUsername = \"sentinel-user\"\n\t\taclSentinelPassword = \"sentinel-pass\"\n\t)\n\n\tvar client *redis.Client\n\tvar sentinel *redis.SentinelClient\n\tsentinels := func() []*redisProcess {\n\t\treturn []*redisProcess{sentinel1, sentinel2, sentinel3}\n\t}\n\n\tBeforeEach(func() {\n\t\tauthCmd := redis.NewStatusCmd(ctx, \"ACL\", \"SETUSER\", aclSentinelUsername, \"ON\",\n\t\t\t\">\"+aclSentinelPassword, \"-@all\", \"+auth\", \"+client|getname\", \"+client|id\", \"+client|setname\",\n\t\t\t\"+command\", \"+hello\", \"+ping\", \"+client|setinfo\", \"+role\", \"+sentinel|get-master-addr-by-name\", \"+sentinel|master\",\n\t\t\t\"+sentinel|myid\", \"+sentinel|replicas\", \"+sentinel|sentinels\")\n\n\t\tfor _, process := range sentinels() {\n\t\t\terr := process.Client.Process(ctx, authCmd)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\tclient = redis.NewFailoverClient(&redis.FailoverOptions{\n\t\t\tMasterName:       sentinelName,\n\t\t\tSentinelAddrs:    sentinelAddrs,\n\t\t\tMaxRetries:       -1,\n\t\t\tSentinelUsername: aclSentinelUsername,\n\t\t\tSentinelPassword: aclSentinelPassword,\n\t\t})\n\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\n\t\tsentinel = redis.NewSentinelClient(&redis.Options{\n\t\t\tAddr:       sentinelAddrs[0],\n\t\t\tMaxRetries: -1,\n\t\t\tUsername:   aclSentinelUsername,\n\t\t\tPassword:   aclSentinelPassword,\n\t\t})\n\n\t\t_, err := sentinel.GetMasterAddrByName(ctx, sentinelName).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t// Wait until sentinels are picked up by each other.\n\t\tfor _, process := range sentinels() {\n\t\t\tEventually(func() string {\n\t\t\t\treturn process.Info(ctx).Val()\n\t\t\t}, \"15s\", \"100ms\").Should(ContainSubstring(\"sentinels=3\"))\n\t\t}\n\t})\n\n\tAfterEach(func() {\n\t\tunauthCommand := redis.NewStatusCmd(ctx, \"ACL\", \"DELUSER\", aclSentinelUsername)\n\n\t\tfor _, process := range sentinels() {\n\t\t\terr := process.Client.Process(ctx, unauthCommand)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t}\n\n\t\t_ = client.Close()\n\t\t_ = sentinel.Close()\n\t})\n\n\tIt(\"should still facilitate operations\", func() {\n\t\terr := client.Set(ctx, \"wow\", \"acl-auth\", 0).Err()\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tval, err := client.Get(ctx, \"wow\").Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(val).To(Equal(\"acl-auth\"))\n\t})\n})\n"
        },
        {
          "name": "set_commands.go",
          "type": "blob",
          "size": 6.431640625,
          "content": "package redis\n\nimport \"context\"\n\ntype SetCmdable interface {\n\tSAdd(ctx context.Context, key string, members ...interface{}) *IntCmd\n\tSCard(ctx context.Context, key string) *IntCmd\n\tSDiff(ctx context.Context, keys ...string) *StringSliceCmd\n\tSDiffStore(ctx context.Context, destination string, keys ...string) *IntCmd\n\tSInter(ctx context.Context, keys ...string) *StringSliceCmd\n\tSInterCard(ctx context.Context, limit int64, keys ...string) *IntCmd\n\tSInterStore(ctx context.Context, destination string, keys ...string) *IntCmd\n\tSIsMember(ctx context.Context, key string, member interface{}) *BoolCmd\n\tSMIsMember(ctx context.Context, key string, members ...interface{}) *BoolSliceCmd\n\tSMembers(ctx context.Context, key string) *StringSliceCmd\n\tSMembersMap(ctx context.Context, key string) *StringStructMapCmd\n\tSMove(ctx context.Context, source, destination string, member interface{}) *BoolCmd\n\tSPop(ctx context.Context, key string) *StringCmd\n\tSPopN(ctx context.Context, key string, count int64) *StringSliceCmd\n\tSRandMember(ctx context.Context, key string) *StringCmd\n\tSRandMemberN(ctx context.Context, key string, count int64) *StringSliceCmd\n\tSRem(ctx context.Context, key string, members ...interface{}) *IntCmd\n\tSScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd\n\tSUnion(ctx context.Context, keys ...string) *StringSliceCmd\n\tSUnionStore(ctx context.Context, destination string, keys ...string) *IntCmd\n}\n\n//------------------------------------------------------------------------------\n\nfunc (c cmdable) SAdd(ctx context.Context, key string, members ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(members))\n\targs[0] = \"sadd\"\n\targs[1] = key\n\targs = appendArgs(args, members)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SCard(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"scard\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SDiff(ctx context.Context, keys ...string) *StringSliceCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"sdiff\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SDiffStore(ctx context.Context, destination string, keys ...string) *IntCmd {\n\targs := make([]interface{}, 2+len(keys))\n\targs[0] = \"sdiffstore\"\n\targs[1] = destination\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SInter(ctx context.Context, keys ...string) *StringSliceCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"sinter\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SInterCard(ctx context.Context, limit int64, keys ...string) *IntCmd {\n\targs := make([]interface{}, 4+len(keys))\n\targs[0] = \"sintercard\"\n\tnumkeys := int64(0)\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t\tnumkeys++\n\t}\n\targs[1] = numkeys\n\targs[2+numkeys] = \"limit\"\n\targs[3+numkeys] = limit\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SInterStore(ctx context.Context, destination string, keys ...string) *IntCmd {\n\targs := make([]interface{}, 2+len(keys))\n\targs[0] = \"sinterstore\"\n\targs[1] = destination\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SIsMember(ctx context.Context, key string, member interface{}) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"sismember\", key, member)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SMIsMember Redis `SMISMEMBER key member [member ...]` command.\nfunc (c cmdable) SMIsMember(ctx context.Context, key string, members ...interface{}) *BoolSliceCmd {\n\targs := make([]interface{}, 2, 2+len(members))\n\targs[0] = \"smismember\"\n\targs[1] = key\n\targs = appendArgs(args, members)\n\tcmd := NewBoolSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SMembers Redis `SMEMBERS key` command output as a slice.\nfunc (c cmdable) SMembers(ctx context.Context, key string) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"smembers\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SMembersMap Redis `SMEMBERS key` command output as a map.\nfunc (c cmdable) SMembersMap(ctx context.Context, key string) *StringStructMapCmd {\n\tcmd := NewStringStructMapCmd(ctx, \"smembers\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SMove(ctx context.Context, source, destination string, member interface{}) *BoolCmd {\n\tcmd := NewBoolCmd(ctx, \"smove\", source, destination, member)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SPop Redis `SPOP key` command.\nfunc (c cmdable) SPop(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"spop\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SPopN Redis `SPOP key count` command.\nfunc (c cmdable) SPopN(ctx context.Context, key string, count int64) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"spop\", key, count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SRandMember Redis `SRANDMEMBER key` command.\nfunc (c cmdable) SRandMember(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"srandmember\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SRandMemberN Redis `SRANDMEMBER key count` command.\nfunc (c cmdable) SRandMemberN(ctx context.Context, key string, count int64) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"srandmember\", key, count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SRem(ctx context.Context, key string, members ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(members))\n\targs[0] = \"srem\"\n\targs[1] = key\n\targs = appendArgs(args, members)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SUnion(ctx context.Context, keys ...string) *StringSliceCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"sunion\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SUnionStore(ctx context.Context, destination string, keys ...string) *IntCmd {\n\targs := make([]interface{}, 2+len(keys))\n\targs[0] = \"sunionstore\"\n\targs[1] = destination\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {\n\targs := []interface{}{\"sscan\", key, cursor}\n\tif match != \"\" {\n\t\targs = append(args, \"match\", match)\n\t}\n\tif count > 0 {\n\t\targs = append(args, \"count\", count)\n\t}\n\tcmd := NewScanCmd(ctx, c, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "sortedset_commands.go",
          "type": "blob",
          "size": 22.505859375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype SortedSetCmdable interface {\n\tBZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *ZWithKeyCmd\n\tBZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *ZWithKeyCmd\n\tBZMPop(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *ZSliceWithKeyCmd\n\tZAdd(ctx context.Context, key string, members ...Z) *IntCmd\n\tZAddLT(ctx context.Context, key string, members ...Z) *IntCmd\n\tZAddGT(ctx context.Context, key string, members ...Z) *IntCmd\n\tZAddNX(ctx context.Context, key string, members ...Z) *IntCmd\n\tZAddXX(ctx context.Context, key string, members ...Z) *IntCmd\n\tZAddArgs(ctx context.Context, key string, args ZAddArgs) *IntCmd\n\tZAddArgsIncr(ctx context.Context, key string, args ZAddArgs) *FloatCmd\n\tZCard(ctx context.Context, key string) *IntCmd\n\tZCount(ctx context.Context, key, min, max string) *IntCmd\n\tZLexCount(ctx context.Context, key, min, max string) *IntCmd\n\tZIncrBy(ctx context.Context, key string, increment float64, member string) *FloatCmd\n\tZInter(ctx context.Context, store *ZStore) *StringSliceCmd\n\tZInterWithScores(ctx context.Context, store *ZStore) *ZSliceCmd\n\tZInterCard(ctx context.Context, limit int64, keys ...string) *IntCmd\n\tZInterStore(ctx context.Context, destination string, store *ZStore) *IntCmd\n\tZMPop(ctx context.Context, order string, count int64, keys ...string) *ZSliceWithKeyCmd\n\tZMScore(ctx context.Context, key string, members ...string) *FloatSliceCmd\n\tZPopMax(ctx context.Context, key string, count ...int64) *ZSliceCmd\n\tZPopMin(ctx context.Context, key string, count ...int64) *ZSliceCmd\n\tZRange(ctx context.Context, key string, start, stop int64) *StringSliceCmd\n\tZRangeWithScores(ctx context.Context, key string, start, stop int64) *ZSliceCmd\n\tZRangeByScore(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd\n\tZRangeByLex(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd\n\tZRangeByScoreWithScores(ctx context.Context, key string, opt *ZRangeBy) *ZSliceCmd\n\tZRangeArgs(ctx context.Context, z ZRangeArgs) *StringSliceCmd\n\tZRangeArgsWithScores(ctx context.Context, z ZRangeArgs) *ZSliceCmd\n\tZRangeStore(ctx context.Context, dst string, z ZRangeArgs) *IntCmd\n\tZRank(ctx context.Context, key, member string) *IntCmd\n\tZRankWithScore(ctx context.Context, key, member string) *RankWithScoreCmd\n\tZRem(ctx context.Context, key string, members ...interface{}) *IntCmd\n\tZRemRangeByRank(ctx context.Context, key string, start, stop int64) *IntCmd\n\tZRemRangeByScore(ctx context.Context, key, min, max string) *IntCmd\n\tZRemRangeByLex(ctx context.Context, key, min, max string) *IntCmd\n\tZRevRange(ctx context.Context, key string, start, stop int64) *StringSliceCmd\n\tZRevRangeWithScores(ctx context.Context, key string, start, stop int64) *ZSliceCmd\n\tZRevRangeByScore(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd\n\tZRevRangeByLex(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd\n\tZRevRangeByScoreWithScores(ctx context.Context, key string, opt *ZRangeBy) *ZSliceCmd\n\tZRevRank(ctx context.Context, key, member string) *IntCmd\n\tZRevRankWithScore(ctx context.Context, key, member string) *RankWithScoreCmd\n\tZScore(ctx context.Context, key, member string) *FloatCmd\n\tZUnionStore(ctx context.Context, dest string, store *ZStore) *IntCmd\n\tZRandMember(ctx context.Context, key string, count int) *StringSliceCmd\n\tZRandMemberWithScores(ctx context.Context, key string, count int) *ZSliceCmd\n\tZUnion(ctx context.Context, store ZStore) *StringSliceCmd\n\tZUnionWithScores(ctx context.Context, store ZStore) *ZSliceCmd\n\tZDiff(ctx context.Context, keys ...string) *StringSliceCmd\n\tZDiffWithScores(ctx context.Context, keys ...string) *ZSliceCmd\n\tZDiffStore(ctx context.Context, destination string, keys ...string) *IntCmd\n\tZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd\n}\n\n// BZPopMax Redis `BZPOPMAX key [key ...] timeout` command.\nfunc (c cmdable) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *ZWithKeyCmd {\n\targs := make([]interface{}, 1+len(keys)+1)\n\targs[0] = \"bzpopmax\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\targs[len(args)-1] = formatSec(ctx, timeout)\n\tcmd := NewZWithKeyCmd(ctx, args...)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BZPopMin Redis `BZPOPMIN key [key ...] timeout` command.\nfunc (c cmdable) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *ZWithKeyCmd {\n\targs := make([]interface{}, 1+len(keys)+1)\n\targs[0] = \"bzpopmin\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\targs[len(args)-1] = formatSec(ctx, timeout)\n\tcmd := NewZWithKeyCmd(ctx, args...)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// BZMPop is the blocking variant of ZMPOP.\n// When any of the sorted sets contains elements, this command behaves exactly like ZMPOP.\n// When all sorted sets are empty, Redis will block the connection until another client adds members to one of the keys or until the timeout elapses.\n// A timeout of zero can be used to block indefinitely.\n// example: client.BZMPop(ctx, 0,\"max\", 1, \"set\")\nfunc (c cmdable) BZMPop(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *ZSliceWithKeyCmd {\n\targs := make([]interface{}, 3+len(keys), 6+len(keys))\n\targs[0] = \"bzmpop\"\n\targs[1] = formatSec(ctx, timeout)\n\targs[2] = len(keys)\n\tfor i, key := range keys {\n\t\targs[3+i] = key\n\t}\n\targs = append(args, strings.ToLower(order), \"count\", count)\n\tcmd := NewZSliceWithKeyCmd(ctx, args...)\n\tcmd.setReadTimeout(timeout)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZAddArgs WARN: The GT, LT and NX options are mutually exclusive.\ntype ZAddArgs struct {\n\tNX      bool\n\tXX      bool\n\tLT      bool\n\tGT      bool\n\tCh      bool\n\tMembers []Z\n}\n\nfunc (c cmdable) zAddArgs(key string, args ZAddArgs, incr bool) []interface{} {\n\ta := make([]interface{}, 0, 6+2*len(args.Members))\n\ta = append(a, \"zadd\", key)\n\n\t// The GT, LT and NX options are mutually exclusive.\n\tif args.NX {\n\t\ta = append(a, \"nx\")\n\t} else {\n\t\tif args.XX {\n\t\t\ta = append(a, \"xx\")\n\t\t}\n\t\tif args.GT {\n\t\t\ta = append(a, \"gt\")\n\t\t} else if args.LT {\n\t\t\ta = append(a, \"lt\")\n\t\t}\n\t}\n\tif args.Ch {\n\t\ta = append(a, \"ch\")\n\t}\n\tif incr {\n\t\ta = append(a, \"incr\")\n\t}\n\tfor _, m := range args.Members {\n\t\ta = append(a, m.Score)\n\t\ta = append(a, m.Member)\n\t}\n\treturn a\n}\n\nfunc (c cmdable) ZAddArgs(ctx context.Context, key string, args ZAddArgs) *IntCmd {\n\tcmd := NewIntCmd(ctx, c.zAddArgs(key, args, false)...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZAddArgsIncr(ctx context.Context, key string, args ZAddArgs) *FloatCmd {\n\tcmd := NewFloatCmd(ctx, c.zAddArgs(key, args, true)...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZAdd Redis `ZADD key score member [score member ...]` command.\nfunc (c cmdable) ZAdd(ctx context.Context, key string, members ...Z) *IntCmd {\n\treturn c.ZAddArgs(ctx, key, ZAddArgs{\n\t\tMembers: members,\n\t})\n}\n\n// ZAddLT Redis `ZADD key LT score member [score member ...]` command.\nfunc (c cmdable) ZAddLT(ctx context.Context, key string, members ...Z) *IntCmd {\n\treturn c.ZAddArgs(ctx, key, ZAddArgs{\n\t\tLT:      true,\n\t\tMembers: members,\n\t})\n}\n\n// ZAddGT Redis `ZADD key GT score member [score member ...]` command.\nfunc (c cmdable) ZAddGT(ctx context.Context, key string, members ...Z) *IntCmd {\n\treturn c.ZAddArgs(ctx, key, ZAddArgs{\n\t\tGT:      true,\n\t\tMembers: members,\n\t})\n}\n\n// ZAddNX Redis `ZADD key NX score member [score member ...]` command.\nfunc (c cmdable) ZAddNX(ctx context.Context, key string, members ...Z) *IntCmd {\n\treturn c.ZAddArgs(ctx, key, ZAddArgs{\n\t\tNX:      true,\n\t\tMembers: members,\n\t})\n}\n\n// ZAddXX Redis `ZADD key XX score member [score member ...]` command.\nfunc (c cmdable) ZAddXX(ctx context.Context, key string, members ...Z) *IntCmd {\n\treturn c.ZAddArgs(ctx, key, ZAddArgs{\n\t\tXX:      true,\n\t\tMembers: members,\n\t})\n}\n\nfunc (c cmdable) ZCard(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"zcard\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZCount(ctx context.Context, key, min, max string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"zcount\", key, min, max)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZLexCount(ctx context.Context, key, min, max string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"zlexcount\", key, min, max)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZIncrBy(ctx context.Context, key string, increment float64, member string) *FloatCmd {\n\tcmd := NewFloatCmd(ctx, \"zincrby\", key, increment, member)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZInterStore(ctx context.Context, destination string, store *ZStore) *IntCmd {\n\targs := make([]interface{}, 0, 3+store.len())\n\targs = append(args, \"zinterstore\", destination, len(store.Keys))\n\targs = store.appendArgs(args)\n\tcmd := NewIntCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(3)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZInter(ctx context.Context, store *ZStore) *StringSliceCmd {\n\targs := make([]interface{}, 0, 2+store.len())\n\targs = append(args, \"zinter\", len(store.Keys))\n\targs = store.appendArgs(args)\n\tcmd := NewStringSliceCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZInterWithScores(ctx context.Context, store *ZStore) *ZSliceCmd {\n\targs := make([]interface{}, 0, 3+store.len())\n\targs = append(args, \"zinter\", len(store.Keys))\n\targs = store.appendArgs(args)\n\targs = append(args, \"withscores\")\n\tcmd := NewZSliceCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZInterCard(ctx context.Context, limit int64, keys ...string) *IntCmd {\n\targs := make([]interface{}, 4+len(keys))\n\targs[0] = \"zintercard\"\n\tnumkeys := int64(0)\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t\tnumkeys++\n\t}\n\targs[1] = numkeys\n\targs[2+numkeys] = \"limit\"\n\targs[3+numkeys] = limit\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZMPop Pops one or more elements with the highest or lowest score from the first non-empty sorted set key from the list of provided key names.\n// direction: \"max\" (highest score) or \"min\" (lowest score), count: > 0\n// example: client.ZMPop(ctx, \"max\", 5, \"set1\", \"set2\")\nfunc (c cmdable) ZMPop(ctx context.Context, order string, count int64, keys ...string) *ZSliceWithKeyCmd {\n\targs := make([]interface{}, 2+len(keys), 5+len(keys))\n\targs[0] = \"zmpop\"\n\targs[1] = len(keys)\n\tfor i, key := range keys {\n\t\targs[2+i] = key\n\t}\n\targs = append(args, strings.ToLower(order), \"count\", count)\n\tcmd := NewZSliceWithKeyCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZMScore(ctx context.Context, key string, members ...string) *FloatSliceCmd {\n\targs := make([]interface{}, 2+len(members))\n\targs[0] = \"zmscore\"\n\targs[1] = key\n\tfor i, member := range members {\n\t\targs[2+i] = member\n\t}\n\tcmd := NewFloatSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZPopMax(ctx context.Context, key string, count ...int64) *ZSliceCmd {\n\targs := []interface{}{\n\t\t\"zpopmax\",\n\t\tkey,\n\t}\n\n\tswitch len(count) {\n\tcase 0:\n\t\tbreak\n\tcase 1:\n\t\targs = append(args, count[0])\n\tdefault:\n\t\tpanic(\"too many arguments\")\n\t}\n\n\tcmd := NewZSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZPopMin(ctx context.Context, key string, count ...int64) *ZSliceCmd {\n\targs := []interface{}{\n\t\t\"zpopmin\",\n\t\tkey,\n\t}\n\n\tswitch len(count) {\n\tcase 0:\n\t\tbreak\n\tcase 1:\n\t\targs = append(args, count[0])\n\tdefault:\n\t\tpanic(\"too many arguments\")\n\t}\n\n\tcmd := NewZSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZRangeArgs is all the options of the ZRange command.\n// In version> 6.2.0, you can replace the(cmd):\n//\n//\tZREVRANGE,\n//\tZRANGEBYSCORE,\n//\tZREVRANGEBYSCORE,\n//\tZRANGEBYLEX,\n//\tZREVRANGEBYLEX.\n//\n// Please pay attention to your redis-server version.\n//\n// Rev, ByScore, ByLex and Offset+Count options require redis-server 6.2.0 and higher.\ntype ZRangeArgs struct {\n\tKey string\n\n\t// When the ByScore option is provided, the open interval(exclusive) can be set.\n\t// By default, the score intervals specified by <Start> and <Stop> are closed (inclusive).\n\t// It is similar to the deprecated(6.2.0+) ZRangeByScore command.\n\t// For example:\n\t//\t\tZRangeArgs{\n\t//\t\t\tKey: \t\t\t\t\"example-key\",\n\t//\t \t\tStart: \t\t\t\t\"(3\",\n\t//\t \t\tStop: \t\t\t\t8,\n\t//\t\t\tByScore:\t\t\ttrue,\n\t//\t \t}\n\t// \t \tcmd: \"ZRange example-key (3 8 ByScore\"  (3 < score <= 8).\n\t//\n\t// For the ByLex option, it is similar to the deprecated(6.2.0+) ZRangeByLex command.\n\t// You can set the <Start> and <Stop> options as follows:\n\t//\t\tZRangeArgs{\n\t//\t\t\tKey: \t\t\t\t\"example-key\",\n\t//\t \t\tStart: \t\t\t\t\"[abc\",\n\t//\t \t\tStop: \t\t\t\t\"(def\",\n\t//\t\t\tByLex:\t\t\t\ttrue,\n\t//\t \t}\n\t//\t\tcmd: \"ZRange example-key [abc (def ByLex\"\n\t//\n\t// For normal cases (ByScore==false && ByLex==false), <Start> and <Stop> should be set to the index range (int).\n\t// You can read the documentation for more information: https://redis.io/commands/zrange\n\tStart interface{}\n\tStop  interface{}\n\n\t// The ByScore and ByLex options are mutually exclusive.\n\tByScore bool\n\tByLex   bool\n\n\tRev bool\n\n\t// limit offset count.\n\tOffset int64\n\tCount  int64\n}\n\nfunc (z ZRangeArgs) appendArgs(args []interface{}) []interface{} {\n\t// For Rev+ByScore/ByLex, we need to adjust the position of <Start> and <Stop>.\n\tif z.Rev && (z.ByScore || z.ByLex) {\n\t\targs = append(args, z.Key, z.Stop, z.Start)\n\t} else {\n\t\targs = append(args, z.Key, z.Start, z.Stop)\n\t}\n\n\tif z.ByScore {\n\t\targs = append(args, \"byscore\")\n\t} else if z.ByLex {\n\t\targs = append(args, \"bylex\")\n\t}\n\tif z.Rev {\n\t\targs = append(args, \"rev\")\n\t}\n\tif z.Offset != 0 || z.Count != 0 {\n\t\targs = append(args, \"limit\", z.Offset, z.Count)\n\t}\n\treturn args\n}\n\nfunc (c cmdable) ZRangeArgs(ctx context.Context, z ZRangeArgs) *StringSliceCmd {\n\targs := make([]interface{}, 0, 9)\n\targs = append(args, \"zrange\")\n\targs = z.appendArgs(args)\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRangeArgsWithScores(ctx context.Context, z ZRangeArgs) *ZSliceCmd {\n\targs := make([]interface{}, 0, 10)\n\targs = append(args, \"zrange\")\n\targs = z.appendArgs(args)\n\targs = append(args, \"withscores\")\n\tcmd := NewZSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRange(ctx context.Context, key string, start, stop int64) *StringSliceCmd {\n\treturn c.ZRangeArgs(ctx, ZRangeArgs{\n\t\tKey:   key,\n\t\tStart: start,\n\t\tStop:  stop,\n\t})\n}\n\nfunc (c cmdable) ZRangeWithScores(ctx context.Context, key string, start, stop int64) *ZSliceCmd {\n\treturn c.ZRangeArgsWithScores(ctx, ZRangeArgs{\n\t\tKey:   key,\n\t\tStart: start,\n\t\tStop:  stop,\n\t})\n}\n\ntype ZRangeBy struct {\n\tMin, Max      string\n\tOffset, Count int64\n}\n\nfunc (c cmdable) zRangeBy(ctx context.Context, zcmd, key string, opt *ZRangeBy, withScores bool) *StringSliceCmd {\n\targs := []interface{}{zcmd, key, opt.Min, opt.Max}\n\tif withScores {\n\t\targs = append(args, \"withscores\")\n\t}\n\tif opt.Offset != 0 || opt.Count != 0 {\n\t\targs = append(\n\t\t\targs,\n\t\t\t\"limit\",\n\t\t\topt.Offset,\n\t\t\topt.Count,\n\t\t)\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRangeByScore(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {\n\treturn c.zRangeBy(ctx, \"zrangebyscore\", key, opt, false)\n}\n\nfunc (c cmdable) ZRangeByLex(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {\n\treturn c.zRangeBy(ctx, \"zrangebylex\", key, opt, false)\n}\n\nfunc (c cmdable) ZRangeByScoreWithScores(ctx context.Context, key string, opt *ZRangeBy) *ZSliceCmd {\n\targs := []interface{}{\"zrangebyscore\", key, opt.Min, opt.Max, \"withscores\"}\n\tif opt.Offset != 0 || opt.Count != 0 {\n\t\targs = append(\n\t\t\targs,\n\t\t\t\"limit\",\n\t\t\topt.Offset,\n\t\t\topt.Count,\n\t\t)\n\t}\n\tcmd := NewZSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRangeStore(ctx context.Context, dst string, z ZRangeArgs) *IntCmd {\n\targs := make([]interface{}, 0, 10)\n\targs = append(args, \"zrangestore\", dst)\n\targs = z.appendArgs(args)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRank(ctx context.Context, key, member string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"zrank\", key, member)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZRankWithScore according to the Redis documentation, if member does not exist\n// in the sorted set or key does not exist, it will return a redis.Nil error.\nfunc (c cmdable) ZRankWithScore(ctx context.Context, key, member string) *RankWithScoreCmd {\n\tcmd := NewRankWithScoreCmd(ctx, \"zrank\", key, member, \"withscore\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRem(ctx context.Context, key string, members ...interface{}) *IntCmd {\n\targs := make([]interface{}, 2, 2+len(members))\n\targs[0] = \"zrem\"\n\targs[1] = key\n\targs = appendArgs(args, members)\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRemRangeByRank(ctx context.Context, key string, start, stop int64) *IntCmd {\n\tcmd := NewIntCmd(\n\t\tctx,\n\t\t\"zremrangebyrank\",\n\t\tkey,\n\t\tstart,\n\t\tstop,\n\t)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRemRangeByScore(ctx context.Context, key, min, max string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"zremrangebyscore\", key, min, max)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRemRangeByLex(ctx context.Context, key, min, max string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"zremrangebylex\", key, min, max)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRevRange(ctx context.Context, key string, start, stop int64) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"zrevrange\", key, start, stop)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZRevRangeWithScores according to the Redis documentation, if member does not exist\n// in the sorted set or key does not exist, it will return a redis.Nil error.\nfunc (c cmdable) ZRevRangeWithScores(ctx context.Context, key string, start, stop int64) *ZSliceCmd {\n\tcmd := NewZSliceCmd(ctx, \"zrevrange\", key, start, stop, \"withscores\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) zRevRangeBy(ctx context.Context, zcmd, key string, opt *ZRangeBy) *StringSliceCmd {\n\targs := []interface{}{zcmd, key, opt.Max, opt.Min}\n\tif opt.Offset != 0 || opt.Count != 0 {\n\t\targs = append(\n\t\t\targs,\n\t\t\t\"limit\",\n\t\t\topt.Offset,\n\t\t\topt.Count,\n\t\t)\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRevRangeByScore(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {\n\treturn c.zRevRangeBy(ctx, \"zrevrangebyscore\", key, opt)\n}\n\nfunc (c cmdable) ZRevRangeByLex(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {\n\treturn c.zRevRangeBy(ctx, \"zrevrangebylex\", key, opt)\n}\n\nfunc (c cmdable) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *ZRangeBy) *ZSliceCmd {\n\targs := []interface{}{\"zrevrangebyscore\", key, opt.Max, opt.Min, \"withscores\"}\n\tif opt.Offset != 0 || opt.Count != 0 {\n\t\targs = append(\n\t\t\targs,\n\t\t\t\"limit\",\n\t\t\topt.Offset,\n\t\t\topt.Count,\n\t\t)\n\t}\n\tcmd := NewZSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRevRank(ctx context.Context, key, member string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"zrevrank\", key, member)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZRevRankWithScore(ctx context.Context, key, member string) *RankWithScoreCmd {\n\tcmd := NewRankWithScoreCmd(ctx, \"zrevrank\", key, member, \"withscore\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZScore(ctx context.Context, key, member string) *FloatCmd {\n\tcmd := NewFloatCmd(ctx, \"zscore\", key, member)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZUnion(ctx context.Context, store ZStore) *StringSliceCmd {\n\targs := make([]interface{}, 0, 2+store.len())\n\targs = append(args, \"zunion\", len(store.Keys))\n\targs = store.appendArgs(args)\n\tcmd := NewStringSliceCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZUnionWithScores(ctx context.Context, store ZStore) *ZSliceCmd {\n\targs := make([]interface{}, 0, 3+store.len())\n\targs = append(args, \"zunion\", len(store.Keys))\n\targs = store.appendArgs(args)\n\targs = append(args, \"withscores\")\n\tcmd := NewZSliceCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZUnionStore(ctx context.Context, dest string, store *ZStore) *IntCmd {\n\targs := make([]interface{}, 0, 3+store.len())\n\targs = append(args, \"zunionstore\", dest, len(store.Keys))\n\targs = store.appendArgs(args)\n\tcmd := NewIntCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(3)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZRandMember redis-server version >= 6.2.0.\nfunc (c cmdable) ZRandMember(ctx context.Context, key string, count int) *StringSliceCmd {\n\tcmd := NewStringSliceCmd(ctx, \"zrandmember\", key, count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZRandMemberWithScores redis-server version >= 6.2.0.\nfunc (c cmdable) ZRandMemberWithScores(ctx context.Context, key string, count int) *ZSliceCmd {\n\tcmd := NewZSliceCmd(ctx, \"zrandmember\", key, count, \"withscores\")\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZDiff redis-server version >= 6.2.0.\nfunc (c cmdable) ZDiff(ctx context.Context, keys ...string) *StringSliceCmd {\n\targs := make([]interface{}, 2+len(keys))\n\targs[0] = \"zdiff\"\n\targs[1] = len(keys)\n\tfor i, key := range keys {\n\t\targs[i+2] = key\n\t}\n\n\tcmd := NewStringSliceCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZDiffWithScores redis-server version >= 6.2.0.\nfunc (c cmdable) ZDiffWithScores(ctx context.Context, keys ...string) *ZSliceCmd {\n\targs := make([]interface{}, 3+len(keys))\n\targs[0] = \"zdiff\"\n\targs[1] = len(keys)\n\tfor i, key := range keys {\n\t\targs[i+2] = key\n\t}\n\targs[len(keys)+2] = \"withscores\"\n\n\tcmd := NewZSliceCmd(ctx, args...)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// ZDiffStore redis-server version >=6.2.0.\nfunc (c cmdable) ZDiffStore(ctx context.Context, destination string, keys ...string) *IntCmd {\n\targs := make([]interface{}, 0, 3+len(keys))\n\targs = append(args, \"zdiffstore\", destination, len(keys))\n\tfor _, key := range keys {\n\t\targs = append(args, key)\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {\n\targs := []interface{}{\"zscan\", key, cursor}\n\tif match != \"\" {\n\t\targs = append(args, \"match\", match)\n\t}\n\tif count > 0 {\n\t\targs = append(args, \"count\", count)\n\t}\n\tcmd := NewScanCmd(ctx, c, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// Z represents sorted set member.\ntype Z struct {\n\tScore  float64\n\tMember interface{}\n}\n\n// ZWithKey represents sorted set member including the name of the key where it was popped.\ntype ZWithKey struct {\n\tZ\n\tKey string\n}\n\n// ZStore is used as an arg to ZInter/ZInterStore and ZUnion/ZUnionStore.\ntype ZStore struct {\n\tKeys    []string\n\tWeights []float64\n\t// Can be SUM, MIN or MAX.\n\tAggregate string\n}\n\nfunc (z ZStore) len() (n int) {\n\tn = len(z.Keys)\n\tif len(z.Weights) > 0 {\n\t\tn += 1 + len(z.Weights)\n\t}\n\tif z.Aggregate != \"\" {\n\t\tn += 2\n\t}\n\treturn n\n}\n\nfunc (z ZStore) appendArgs(args []interface{}) []interface{} {\n\tfor _, key := range z.Keys {\n\t\targs = append(args, key)\n\t}\n\tif len(z.Weights) > 0 {\n\t\targs = append(args, \"weights\")\n\t\tfor _, weights := range z.Weights {\n\t\t\targs = append(args, weights)\n\t\t}\n\t}\n\tif z.Aggregate != \"\" {\n\t\targs = append(args, \"aggregate\", z.Aggregate)\n\t}\n\treturn args\n}\n"
        },
        {
          "name": "stream_commands.go",
          "type": "blob",
          "size": 12.83984375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\ntype StreamCmdable interface {\n\tXAdd(ctx context.Context, a *XAddArgs) *StringCmd\n\tXDel(ctx context.Context, stream string, ids ...string) *IntCmd\n\tXLen(ctx context.Context, stream string) *IntCmd\n\tXRange(ctx context.Context, stream, start, stop string) *XMessageSliceCmd\n\tXRangeN(ctx context.Context, stream, start, stop string, count int64) *XMessageSliceCmd\n\tXRevRange(ctx context.Context, stream string, start, stop string) *XMessageSliceCmd\n\tXRevRangeN(ctx context.Context, stream string, start, stop string, count int64) *XMessageSliceCmd\n\tXRead(ctx context.Context, a *XReadArgs) *XStreamSliceCmd\n\tXReadStreams(ctx context.Context, streams ...string) *XStreamSliceCmd\n\tXGroupCreate(ctx context.Context, stream, group, start string) *StatusCmd\n\tXGroupCreateMkStream(ctx context.Context, stream, group, start string) *StatusCmd\n\tXGroupSetID(ctx context.Context, stream, group, start string) *StatusCmd\n\tXGroupDestroy(ctx context.Context, stream, group string) *IntCmd\n\tXGroupCreateConsumer(ctx context.Context, stream, group, consumer string) *IntCmd\n\tXGroupDelConsumer(ctx context.Context, stream, group, consumer string) *IntCmd\n\tXReadGroup(ctx context.Context, a *XReadGroupArgs) *XStreamSliceCmd\n\tXAck(ctx context.Context, stream, group string, ids ...string) *IntCmd\n\tXPending(ctx context.Context, stream, group string) *XPendingCmd\n\tXPendingExt(ctx context.Context, a *XPendingExtArgs) *XPendingExtCmd\n\tXClaim(ctx context.Context, a *XClaimArgs) *XMessageSliceCmd\n\tXClaimJustID(ctx context.Context, a *XClaimArgs) *StringSliceCmd\n\tXAutoClaim(ctx context.Context, a *XAutoClaimArgs) *XAutoClaimCmd\n\tXAutoClaimJustID(ctx context.Context, a *XAutoClaimArgs) *XAutoClaimJustIDCmd\n\tXTrimMaxLen(ctx context.Context, key string, maxLen int64) *IntCmd\n\tXTrimMaxLenApprox(ctx context.Context, key string, maxLen, limit int64) *IntCmd\n\tXTrimMinID(ctx context.Context, key string, minID string) *IntCmd\n\tXTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *IntCmd\n\tXInfoGroups(ctx context.Context, key string) *XInfoGroupsCmd\n\tXInfoStream(ctx context.Context, key string) *XInfoStreamCmd\n\tXInfoStreamFull(ctx context.Context, key string, count int) *XInfoStreamFullCmd\n\tXInfoConsumers(ctx context.Context, key string, group string) *XInfoConsumersCmd\n}\n\n// XAddArgs accepts values in the following formats:\n//   - XAddArgs.Values = []interface{}{\"key1\", \"value1\", \"key2\", \"value2\"}\n//   - XAddArgs.Values = []string(\"key1\", \"value1\", \"key2\", \"value2\")\n//   - XAddArgs.Values = map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"}\n//\n// Note that map will not preserve the order of key-value pairs.\n// MaxLen/MaxLenApprox and MinID are in conflict, only one of them can be used.\ntype XAddArgs struct {\n\tStream     string\n\tNoMkStream bool\n\tMaxLen     int64 // MAXLEN N\n\tMinID      string\n\t// Approx causes MaxLen and MinID to use \"~\" matcher (instead of \"=\").\n\tApprox bool\n\tLimit  int64\n\tID     string\n\tValues interface{}\n}\n\nfunc (c cmdable) XAdd(ctx context.Context, a *XAddArgs) *StringCmd {\n\targs := make([]interface{}, 0, 11)\n\targs = append(args, \"xadd\", a.Stream)\n\tif a.NoMkStream {\n\t\targs = append(args, \"nomkstream\")\n\t}\n\tswitch {\n\tcase a.MaxLen > 0:\n\t\tif a.Approx {\n\t\t\targs = append(args, \"maxlen\", \"~\", a.MaxLen)\n\t\t} else {\n\t\t\targs = append(args, \"maxlen\", a.MaxLen)\n\t\t}\n\tcase a.MinID != \"\":\n\t\tif a.Approx {\n\t\t\targs = append(args, \"minid\", \"~\", a.MinID)\n\t\t} else {\n\t\t\targs = append(args, \"minid\", a.MinID)\n\t\t}\n\t}\n\tif a.Limit > 0 {\n\t\targs = append(args, \"limit\", a.Limit)\n\t}\n\tif a.ID != \"\" {\n\t\targs = append(args, a.ID)\n\t} else {\n\t\targs = append(args, \"*\")\n\t}\n\targs = appendArg(args, a.Values)\n\n\tcmd := NewStringCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XDel(ctx context.Context, stream string, ids ...string) *IntCmd {\n\targs := []interface{}{\"xdel\", stream}\n\tfor _, id := range ids {\n\t\targs = append(args, id)\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XLen(ctx context.Context, stream string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"xlen\", stream)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XRange(ctx context.Context, stream, start, stop string) *XMessageSliceCmd {\n\tcmd := NewXMessageSliceCmd(ctx, \"xrange\", stream, start, stop)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XRangeN(ctx context.Context, stream, start, stop string, count int64) *XMessageSliceCmd {\n\tcmd := NewXMessageSliceCmd(ctx, \"xrange\", stream, start, stop, \"count\", count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XRevRange(ctx context.Context, stream, start, stop string) *XMessageSliceCmd {\n\tcmd := NewXMessageSliceCmd(ctx, \"xrevrange\", stream, start, stop)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XRevRangeN(ctx context.Context, stream, start, stop string, count int64) *XMessageSliceCmd {\n\tcmd := NewXMessageSliceCmd(ctx, \"xrevrange\", stream, start, stop, \"count\", count)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype XReadArgs struct {\n\tStreams []string // list of streams and ids, e.g. stream1 stream2 id1 id2\n\tCount   int64\n\tBlock   time.Duration\n\tID      string\n}\n\nfunc (c cmdable) XRead(ctx context.Context, a *XReadArgs) *XStreamSliceCmd {\n\targs := make([]interface{}, 0, 2*len(a.Streams)+6)\n\targs = append(args, \"xread\")\n\n\tkeyPos := int8(1)\n\tif a.Count > 0 {\n\t\targs = append(args, \"count\")\n\t\targs = append(args, a.Count)\n\t\tkeyPos += 2\n\t}\n\tif a.Block >= 0 {\n\t\targs = append(args, \"block\")\n\t\targs = append(args, int64(a.Block/time.Millisecond))\n\t\tkeyPos += 2\n\t}\n\targs = append(args, \"streams\")\n\tkeyPos++\n\tfor _, s := range a.Streams {\n\t\targs = append(args, s)\n\t}\n\tif a.ID != \"\" {\n\t\tfor range a.Streams {\n\t\t\targs = append(args, a.ID)\n\t\t}\n\t}\n\n\tcmd := NewXStreamSliceCmd(ctx, args...)\n\tif a.Block >= 0 {\n\t\tcmd.setReadTimeout(a.Block)\n\t}\n\tcmd.SetFirstKeyPos(keyPos)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XReadStreams(ctx context.Context, streams ...string) *XStreamSliceCmd {\n\treturn c.XRead(ctx, &XReadArgs{\n\t\tStreams: streams,\n\t\tBlock:   -1,\n\t})\n}\n\nfunc (c cmdable) XGroupCreate(ctx context.Context, stream, group, start string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"xgroup\", \"create\", stream, group, start)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XGroupCreateMkStream(ctx context.Context, stream, group, start string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"xgroup\", \"create\", stream, group, start, \"mkstream\")\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XGroupSetID(ctx context.Context, stream, group, start string) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"xgroup\", \"setid\", stream, group, start)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XGroupDestroy(ctx context.Context, stream, group string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"xgroup\", \"destroy\", stream, group)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XGroupCreateConsumer(ctx context.Context, stream, group, consumer string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"xgroup\", \"createconsumer\", stream, group, consumer)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XGroupDelConsumer(ctx context.Context, stream, group, consumer string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"xgroup\", \"delconsumer\", stream, group, consumer)\n\tcmd.SetFirstKeyPos(2)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype XReadGroupArgs struct {\n\tGroup    string\n\tConsumer string\n\tStreams  []string // list of streams and ids, e.g. stream1 stream2 id1 id2\n\tCount    int64\n\tBlock    time.Duration\n\tNoAck    bool\n}\n\nfunc (c cmdable) XReadGroup(ctx context.Context, a *XReadGroupArgs) *XStreamSliceCmd {\n\targs := make([]interface{}, 0, 10+len(a.Streams))\n\targs = append(args, \"xreadgroup\", \"group\", a.Group, a.Consumer)\n\n\tkeyPos := int8(4)\n\tif a.Count > 0 {\n\t\targs = append(args, \"count\", a.Count)\n\t\tkeyPos += 2\n\t}\n\tif a.Block >= 0 {\n\t\targs = append(args, \"block\", int64(a.Block/time.Millisecond))\n\t\tkeyPos += 2\n\t}\n\tif a.NoAck {\n\t\targs = append(args, \"noack\")\n\t\tkeyPos++\n\t}\n\targs = append(args, \"streams\")\n\tkeyPos++\n\tfor _, s := range a.Streams {\n\t\targs = append(args, s)\n\t}\n\n\tcmd := NewXStreamSliceCmd(ctx, args...)\n\tif a.Block >= 0 {\n\t\tcmd.setReadTimeout(a.Block)\n\t}\n\tcmd.SetFirstKeyPos(keyPos)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XAck(ctx context.Context, stream, group string, ids ...string) *IntCmd {\n\targs := []interface{}{\"xack\", stream, group}\n\tfor _, id := range ids {\n\t\targs = append(args, id)\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XPending(ctx context.Context, stream, group string) *XPendingCmd {\n\tcmd := NewXPendingCmd(ctx, \"xpending\", stream, group)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype XPendingExtArgs struct {\n\tStream   string\n\tGroup    string\n\tIdle     time.Duration\n\tStart    string\n\tEnd      string\n\tCount    int64\n\tConsumer string\n}\n\nfunc (c cmdable) XPendingExt(ctx context.Context, a *XPendingExtArgs) *XPendingExtCmd {\n\targs := make([]interface{}, 0, 9)\n\targs = append(args, \"xpending\", a.Stream, a.Group)\n\tif a.Idle != 0 {\n\t\targs = append(args, \"idle\", formatMs(ctx, a.Idle))\n\t}\n\targs = append(args, a.Start, a.End, a.Count)\n\tif a.Consumer != \"\" {\n\t\targs = append(args, a.Consumer)\n\t}\n\tcmd := NewXPendingExtCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype XAutoClaimArgs struct {\n\tStream   string\n\tGroup    string\n\tMinIdle  time.Duration\n\tStart    string\n\tCount    int64\n\tConsumer string\n}\n\nfunc (c cmdable) XAutoClaim(ctx context.Context, a *XAutoClaimArgs) *XAutoClaimCmd {\n\targs := xAutoClaimArgs(ctx, a)\n\tcmd := NewXAutoClaimCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XAutoClaimJustID(ctx context.Context, a *XAutoClaimArgs) *XAutoClaimJustIDCmd {\n\targs := xAutoClaimArgs(ctx, a)\n\targs = append(args, \"justid\")\n\tcmd := NewXAutoClaimJustIDCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc xAutoClaimArgs(ctx context.Context, a *XAutoClaimArgs) []interface{} {\n\targs := make([]interface{}, 0, 8)\n\targs = append(args, \"xautoclaim\", a.Stream, a.Group, a.Consumer, formatMs(ctx, a.MinIdle), a.Start)\n\tif a.Count > 0 {\n\t\targs = append(args, \"count\", a.Count)\n\t}\n\treturn args\n}\n\ntype XClaimArgs struct {\n\tStream   string\n\tGroup    string\n\tConsumer string\n\tMinIdle  time.Duration\n\tMessages []string\n}\n\nfunc (c cmdable) XClaim(ctx context.Context, a *XClaimArgs) *XMessageSliceCmd {\n\targs := xClaimArgs(a)\n\tcmd := NewXMessageSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XClaimJustID(ctx context.Context, a *XClaimArgs) *StringSliceCmd {\n\targs := xClaimArgs(a)\n\targs = append(args, \"justid\")\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc xClaimArgs(a *XClaimArgs) []interface{} {\n\targs := make([]interface{}, 0, 5+len(a.Messages))\n\targs = append(args,\n\t\t\"xclaim\",\n\t\ta.Stream,\n\t\ta.Group, a.Consumer,\n\t\tint64(a.MinIdle/time.Millisecond))\n\tfor _, id := range a.Messages {\n\t\targs = append(args, id)\n\t}\n\treturn args\n}\n\n// xTrim If approx is true, add the \"~\" parameter, otherwise it is the default \"=\" (redis default).\n// example:\n//\n//\tXTRIM key MAXLEN/MINID threshold LIMIT limit.\n//\tXTRIM key MAXLEN/MINID ~ threshold LIMIT limit.\n//\n// The redis-server version is lower than 6.2, please set limit to 0.\nfunc (c cmdable) xTrim(\n\tctx context.Context, key, strategy string,\n\tapprox bool, threshold interface{}, limit int64,\n) *IntCmd {\n\targs := make([]interface{}, 0, 7)\n\targs = append(args, \"xtrim\", key, strategy)\n\tif approx {\n\t\targs = append(args, \"~\")\n\t}\n\targs = append(args, threshold)\n\tif limit > 0 {\n\t\targs = append(args, \"limit\", limit)\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// XTrimMaxLen No `~` rules are used, `limit` cannot be used.\n// cmd: XTRIM key MAXLEN maxLen\nfunc (c cmdable) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *IntCmd {\n\treturn c.xTrim(ctx, key, \"maxlen\", false, maxLen, 0)\n}\n\nfunc (c cmdable) XTrimMaxLenApprox(ctx context.Context, key string, maxLen, limit int64) *IntCmd {\n\treturn c.xTrim(ctx, key, \"maxlen\", true, maxLen, limit)\n}\n\nfunc (c cmdable) XTrimMinID(ctx context.Context, key string, minID string) *IntCmd {\n\treturn c.xTrim(ctx, key, \"minid\", false, minID, 0)\n}\n\nfunc (c cmdable) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *IntCmd {\n\treturn c.xTrim(ctx, key, \"minid\", true, minID, limit)\n}\n\nfunc (c cmdable) XInfoConsumers(ctx context.Context, key string, group string) *XInfoConsumersCmd {\n\tcmd := NewXInfoConsumersCmd(ctx, key, group)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XInfoGroups(ctx context.Context, key string) *XInfoGroupsCmd {\n\tcmd := NewXInfoGroupsCmd(ctx, key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) XInfoStream(ctx context.Context, key string) *XInfoStreamCmd {\n\tcmd := NewXInfoStreamCmd(ctx, key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// XInfoStreamFull XINFO STREAM FULL [COUNT count]\n// redis-server >= 6.0.\nfunc (c cmdable) XInfoStreamFull(ctx context.Context, key string, count int) *XInfoStreamFullCmd {\n\targs := make([]interface{}, 0, 6)\n\targs = append(args, \"xinfo\", \"stream\", key, \"full\")\n\tif count > 0 {\n\t\targs = append(args, \"count\", count)\n\t}\n\tcmd := NewXInfoStreamFullCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "string_commands.go",
          "type": "blob",
          "size": 9.5087890625,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"time\"\n)\n\ntype StringCmdable interface {\n\tAppend(ctx context.Context, key, value string) *IntCmd\n\tDecr(ctx context.Context, key string) *IntCmd\n\tDecrBy(ctx context.Context, key string, decrement int64) *IntCmd\n\tGet(ctx context.Context, key string) *StringCmd\n\tGetRange(ctx context.Context, key string, start, end int64) *StringCmd\n\tGetSet(ctx context.Context, key string, value interface{}) *StringCmd\n\tGetEx(ctx context.Context, key string, expiration time.Duration) *StringCmd\n\tGetDel(ctx context.Context, key string) *StringCmd\n\tIncr(ctx context.Context, key string) *IntCmd\n\tIncrBy(ctx context.Context, key string, value int64) *IntCmd\n\tIncrByFloat(ctx context.Context, key string, value float64) *FloatCmd\n\tLCS(ctx context.Context, q *LCSQuery) *LCSCmd\n\tMGet(ctx context.Context, keys ...string) *SliceCmd\n\tMSet(ctx context.Context, values ...interface{}) *StatusCmd\n\tMSetNX(ctx context.Context, values ...interface{}) *BoolCmd\n\tSet(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd\n\tSetArgs(ctx context.Context, key string, value interface{}, a SetArgs) *StatusCmd\n\tSetEx(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd\n\tSetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd\n\tSetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd\n\tSetRange(ctx context.Context, key string, offset int64, value string) *IntCmd\n\tStrLen(ctx context.Context, key string) *IntCmd\n}\n\nfunc (c cmdable) Append(ctx context.Context, key, value string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"append\", key, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Decr(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"decr\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) DecrBy(ctx context.Context, key string, decrement int64) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"decrby\", key, decrement)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// Get Redis `GET key` command. It returns redis.Nil error when key does not exist.\nfunc (c cmdable) Get(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"get\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GetRange(ctx context.Context, key string, start, end int64) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"getrange\", key, start, end)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) GetSet(ctx context.Context, key string, value interface{}) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"getset\", key, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// GetEx An expiration of zero removes the TTL associated with the key (i.e. GETEX key persist).\n// Requires Redis >= 6.2.0.\nfunc (c cmdable) GetEx(ctx context.Context, key string, expiration time.Duration) *StringCmd {\n\targs := make([]interface{}, 0, 4)\n\targs = append(args, \"getex\", key)\n\tif expiration > 0 {\n\t\tif usePrecise(expiration) {\n\t\t\targs = append(args, \"px\", formatMs(ctx, expiration))\n\t\t} else {\n\t\t\targs = append(args, \"ex\", formatSec(ctx, expiration))\n\t\t}\n\t} else if expiration == 0 {\n\t\targs = append(args, \"persist\")\n\t}\n\n\tcmd := NewStringCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// GetDel redis-server version >= 6.2.0.\nfunc (c cmdable) GetDel(ctx context.Context, key string) *StringCmd {\n\tcmd := NewStringCmd(ctx, \"getdel\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) Incr(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"incr\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) IncrBy(ctx context.Context, key string, value int64) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"incrby\", key, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) IncrByFloat(ctx context.Context, key string, value float64) *FloatCmd {\n\tcmd := NewFloatCmd(ctx, \"incrbyfloat\", key, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) LCS(ctx context.Context, q *LCSQuery) *LCSCmd {\n\tcmd := NewLCSCmd(ctx, q)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) MGet(ctx context.Context, keys ...string) *SliceCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"mget\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// MSet is like Set but accepts multiple values:\n//   - MSet(\"key1\", \"value1\", \"key2\", \"value2\")\n//   - MSet([]string{\"key1\", \"value1\", \"key2\", \"value2\"})\n//   - MSet(map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"})\n//   - MSet(struct), For struct types, see HSet description.\nfunc (c cmdable) MSet(ctx context.Context, values ...interface{}) *StatusCmd {\n\targs := make([]interface{}, 1, 1+len(values))\n\targs[0] = \"mset\"\n\targs = appendArgs(args, values)\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// MSetNX is like SetNX but accepts multiple values:\n//   - MSetNX(\"key1\", \"value1\", \"key2\", \"value2\")\n//   - MSetNX([]string{\"key1\", \"value1\", \"key2\", \"value2\"})\n//   - MSetNX(map[string]interface{}{\"key1\": \"value1\", \"key2\": \"value2\"})\n//   - MSetNX(struct), For struct types, see HSet description.\nfunc (c cmdable) MSetNX(ctx context.Context, values ...interface{}) *BoolCmd {\n\targs := make([]interface{}, 1, 1+len(values))\n\targs[0] = \"msetnx\"\n\targs = appendArgs(args, values)\n\tcmd := NewBoolCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// Set Redis `SET key value [expiration]` command.\n// Use expiration for `SETEx`-like behavior.\n//\n// Zero expiration means the key has no expiration time.\n// KeepTTL is a Redis KEEPTTL option to keep existing TTL, it requires your redis-server version >= 6.0,\n// otherwise you will receive an error: (error) ERR syntax error.\nfunc (c cmdable) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd {\n\targs := make([]interface{}, 3, 5)\n\targs[0] = \"set\"\n\targs[1] = key\n\targs[2] = value\n\tif expiration > 0 {\n\t\tif usePrecise(expiration) {\n\t\t\targs = append(args, \"px\", formatMs(ctx, expiration))\n\t\t} else {\n\t\t\targs = append(args, \"ex\", formatSec(ctx, expiration))\n\t\t}\n\t} else if expiration == KeepTTL {\n\t\targs = append(args, \"keepttl\")\n\t}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SetArgs provides arguments for the SetArgs function.\ntype SetArgs struct {\n\t// Mode can be `NX` or `XX` or empty.\n\tMode string\n\n\t// Zero `TTL` or `Expiration` means that the key has no expiration time.\n\tTTL      time.Duration\n\tExpireAt time.Time\n\n\t// When Get is true, the command returns the old value stored at key, or nil when key did not exist.\n\tGet bool\n\n\t// KeepTTL is a Redis KEEPTTL option to keep existing TTL, it requires your redis-server version >= 6.0,\n\t// otherwise you will receive an error: (error) ERR syntax error.\n\tKeepTTL bool\n}\n\n// SetArgs supports all the options that the SET command supports.\n// It is the alternative to the Set function when you want\n// to have more control over the options.\nfunc (c cmdable) SetArgs(ctx context.Context, key string, value interface{}, a SetArgs) *StatusCmd {\n\targs := []interface{}{\"set\", key, value}\n\n\tif a.KeepTTL {\n\t\targs = append(args, \"keepttl\")\n\t}\n\n\tif !a.ExpireAt.IsZero() {\n\t\targs = append(args, \"exat\", a.ExpireAt.Unix())\n\t}\n\tif a.TTL > 0 {\n\t\tif usePrecise(a.TTL) {\n\t\t\targs = append(args, \"px\", formatMs(ctx, a.TTL))\n\t\t} else {\n\t\t\targs = append(args, \"ex\", formatSec(ctx, a.TTL))\n\t\t}\n\t}\n\n\tif a.Mode != \"\" {\n\t\targs = append(args, a.Mode)\n\t}\n\n\tif a.Get {\n\t\targs = append(args, \"get\")\n\t}\n\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SetEx Redis `SETEx key expiration value` command.\nfunc (c cmdable) SetEx(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd {\n\tcmd := NewStatusCmd(ctx, \"setex\", key, formatSec(ctx, expiration), value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SetNX Redis `SET key value [expiration] NX` command.\n//\n// Zero expiration means the key has no expiration time.\n// KeepTTL is a Redis KEEPTTL option to keep existing TTL, it requires your redis-server version >= 6.0,\n// otherwise you will receive an error: (error) ERR syntax error.\nfunc (c cmdable) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd {\n\tvar cmd *BoolCmd\n\tswitch expiration {\n\tcase 0:\n\t\t// Use old `SETNX` to support old Redis versions.\n\t\tcmd = NewBoolCmd(ctx, \"setnx\", key, value)\n\tcase KeepTTL:\n\t\tcmd = NewBoolCmd(ctx, \"set\", key, value, \"keepttl\", \"nx\")\n\tdefault:\n\t\tif usePrecise(expiration) {\n\t\t\tcmd = NewBoolCmd(ctx, \"set\", key, value, \"px\", formatMs(ctx, expiration), \"nx\")\n\t\t} else {\n\t\t\tcmd = NewBoolCmd(ctx, \"set\", key, value, \"ex\", formatSec(ctx, expiration), \"nx\")\n\t\t}\n\t}\n\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// SetXX Redis `SET key value [expiration] XX` command.\n//\n// Zero expiration means the key has no expiration time.\n// KeepTTL is a Redis KEEPTTL option to keep existing TTL, it requires your redis-server version >= 6.0,\n// otherwise you will receive an error: (error) ERR syntax error.\nfunc (c cmdable) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd {\n\tvar cmd *BoolCmd\n\tswitch expiration {\n\tcase 0:\n\t\tcmd = NewBoolCmd(ctx, \"set\", key, value, \"xx\")\n\tcase KeepTTL:\n\t\tcmd = NewBoolCmd(ctx, \"set\", key, value, \"keepttl\", \"xx\")\n\tdefault:\n\t\tif usePrecise(expiration) {\n\t\t\tcmd = NewBoolCmd(ctx, \"set\", key, value, \"px\", formatMs(ctx, expiration), \"xx\")\n\t\t} else {\n\t\t\tcmd = NewBoolCmd(ctx, \"set\", key, value, \"ex\", formatSec(ctx, expiration), \"xx\")\n\t\t}\n\t}\n\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) SetRange(ctx context.Context, key string, offset int64, value string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"setrange\", key, offset, value)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\nfunc (c cmdable) StrLen(ctx context.Context, key string) *IntCmd {\n\tcmd := NewIntCmd(ctx, \"strlen\", key)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "timeseries_commands.go",
          "type": "blob",
          "size": 29.8486328125,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"strconv\"\n\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\ntype TimeseriesCmdable interface {\n\tTSAdd(ctx context.Context, key string, timestamp interface{}, value float64) *IntCmd\n\tTSAddWithArgs(ctx context.Context, key string, timestamp interface{}, value float64, options *TSOptions) *IntCmd\n\tTSCreate(ctx context.Context, key string) *StatusCmd\n\tTSCreateWithArgs(ctx context.Context, key string, options *TSOptions) *StatusCmd\n\tTSAlter(ctx context.Context, key string, options *TSAlterOptions) *StatusCmd\n\tTSCreateRule(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int) *StatusCmd\n\tTSCreateRuleWithArgs(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int, options *TSCreateRuleOptions) *StatusCmd\n\tTSIncrBy(ctx context.Context, Key string, timestamp float64) *IntCmd\n\tTSIncrByWithArgs(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions) *IntCmd\n\tTSDecrBy(ctx context.Context, Key string, timestamp float64) *IntCmd\n\tTSDecrByWithArgs(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions) *IntCmd\n\tTSDel(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *IntCmd\n\tTSDeleteRule(ctx context.Context, sourceKey string, destKey string) *StatusCmd\n\tTSGet(ctx context.Context, key string) *TSTimestampValueCmd\n\tTSGetWithArgs(ctx context.Context, key string, options *TSGetOptions) *TSTimestampValueCmd\n\tTSInfo(ctx context.Context, key string) *MapStringInterfaceCmd\n\tTSInfoWithArgs(ctx context.Context, key string, options *TSInfoOptions) *MapStringInterfaceCmd\n\tTSMAdd(ctx context.Context, ktvSlices [][]interface{}) *IntSliceCmd\n\tTSQueryIndex(ctx context.Context, filterExpr []string) *StringSliceCmd\n\tTSRevRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *TSTimestampValueSliceCmd\n\tTSRevRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRevRangeOptions) *TSTimestampValueSliceCmd\n\tTSRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *TSTimestampValueSliceCmd\n\tTSRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRangeOptions) *TSTimestampValueSliceCmd\n\tTSMRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *MapStringSliceInterfaceCmd\n\tTSMRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRangeOptions) *MapStringSliceInterfaceCmd\n\tTSMRevRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *MapStringSliceInterfaceCmd\n\tTSMRevRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRevRangeOptions) *MapStringSliceInterfaceCmd\n\tTSMGet(ctx context.Context, filters []string) *MapStringSliceInterfaceCmd\n\tTSMGetWithArgs(ctx context.Context, filters []string, options *TSMGetOptions) *MapStringSliceInterfaceCmd\n}\n\ntype TSOptions struct {\n\tRetention         int\n\tChunkSize         int\n\tEncoding          string\n\tDuplicatePolicy   string\n\tLabels            map[string]string\n\tIgnoreMaxTimeDiff int64\n\tIgnoreMaxValDiff  float64\n}\ntype TSIncrDecrOptions struct {\n\tTimestamp         int64\n\tRetention         int\n\tChunkSize         int\n\tUncompressed      bool\n\tDuplicatePolicy   string\n\tLabels            map[string]string\n\tIgnoreMaxTimeDiff int64\n\tIgnoreMaxValDiff  float64\n}\n\ntype TSAlterOptions struct {\n\tRetention         int\n\tChunkSize         int\n\tDuplicatePolicy   string\n\tLabels            map[string]string\n\tIgnoreMaxTimeDiff int64\n\tIgnoreMaxValDiff  float64\n}\n\ntype TSCreateRuleOptions struct {\n\talignTimestamp int64\n}\n\ntype TSGetOptions struct {\n\tLatest bool\n}\n\ntype TSInfoOptions struct {\n\tDebug bool\n}\ntype Aggregator int\n\nconst (\n\tInvalid = Aggregator(iota)\n\tAvg\n\tSum\n\tMin\n\tMax\n\tRange\n\tCount\n\tFirst\n\tLast\n\tStdP\n\tStdS\n\tVarP\n\tVarS\n\tTwa\n)\n\nfunc (a Aggregator) String() string {\n\tswitch a {\n\tcase Invalid:\n\t\treturn \"\"\n\tcase Avg:\n\t\treturn \"AVG\"\n\tcase Sum:\n\t\treturn \"SUM\"\n\tcase Min:\n\t\treturn \"MIN\"\n\tcase Max:\n\t\treturn \"MAX\"\n\tcase Range:\n\t\treturn \"RANGE\"\n\tcase Count:\n\t\treturn \"COUNT\"\n\tcase First:\n\t\treturn \"FIRST\"\n\tcase Last:\n\t\treturn \"LAST\"\n\tcase StdP:\n\t\treturn \"STD.P\"\n\tcase StdS:\n\t\treturn \"STD.S\"\n\tcase VarP:\n\t\treturn \"VAR.P\"\n\tcase VarS:\n\t\treturn \"VAR.S\"\n\tcase Twa:\n\t\treturn \"TWA\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\ntype TSRangeOptions struct {\n\tLatest          bool\n\tFilterByTS      []int\n\tFilterByValue   []int\n\tCount           int\n\tAlign           interface{}\n\tAggregator      Aggregator\n\tBucketDuration  int\n\tBucketTimestamp interface{}\n\tEmpty           bool\n}\n\ntype TSRevRangeOptions struct {\n\tLatest          bool\n\tFilterByTS      []int\n\tFilterByValue   []int\n\tCount           int\n\tAlign           interface{}\n\tAggregator      Aggregator\n\tBucketDuration  int\n\tBucketTimestamp interface{}\n\tEmpty           bool\n}\n\ntype TSMRangeOptions struct {\n\tLatest          bool\n\tFilterByTS      []int\n\tFilterByValue   []int\n\tWithLabels      bool\n\tSelectedLabels  []interface{}\n\tCount           int\n\tAlign           interface{}\n\tAggregator      Aggregator\n\tBucketDuration  int\n\tBucketTimestamp interface{}\n\tEmpty           bool\n\tGroupByLabel    interface{}\n\tReducer         interface{}\n}\n\ntype TSMRevRangeOptions struct {\n\tLatest          bool\n\tFilterByTS      []int\n\tFilterByValue   []int\n\tWithLabels      bool\n\tSelectedLabels  []interface{}\n\tCount           int\n\tAlign           interface{}\n\tAggregator      Aggregator\n\tBucketDuration  int\n\tBucketTimestamp interface{}\n\tEmpty           bool\n\tGroupByLabel    interface{}\n\tReducer         interface{}\n}\n\ntype TSMGetOptions struct {\n\tLatest         bool\n\tWithLabels     bool\n\tSelectedLabels []interface{}\n}\n\n// TSAdd - Adds one or more observations to a t-digest sketch.\n// For more information - https://redis.io/commands/ts.add/\nfunc (c cmdable) TSAdd(ctx context.Context, key string, timestamp interface{}, value float64) *IntCmd {\n\targs := []interface{}{\"TS.ADD\", key, timestamp, value}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSAddWithArgs - Adds one or more observations to a t-digest sketch.\n// This function also allows for specifying additional options such as:\n// Retention, ChunkSize, Encoding, DuplicatePolicy and Labels.\n// For more information - https://redis.io/commands/ts.add/\nfunc (c cmdable) TSAddWithArgs(ctx context.Context, key string, timestamp interface{}, value float64, options *TSOptions) *IntCmd {\n\targs := []interface{}{\"TS.ADD\", key, timestamp, value}\n\tif options != nil {\n\t\tif options.Retention != 0 {\n\t\t\targs = append(args, \"RETENTION\", options.Retention)\n\t\t}\n\t\tif options.ChunkSize != 0 {\n\t\t\targs = append(args, \"CHUNK_SIZE\", options.ChunkSize)\n\t\t}\n\t\tif options.Encoding != \"\" {\n\t\t\targs = append(args, \"ENCODING\", options.Encoding)\n\t\t}\n\n\t\tif options.DuplicatePolicy != \"\" {\n\t\t\targs = append(args, \"DUPLICATE_POLICY\", options.DuplicatePolicy)\n\t\t}\n\t\tif options.Labels != nil {\n\t\t\targs = append(args, \"LABELS\")\n\t\t\tfor label, value := range options.Labels {\n\t\t\t\targs = append(args, label, value)\n\t\t\t}\n\t\t}\n\t\tif options.IgnoreMaxTimeDiff != 0 || options.IgnoreMaxValDiff != 0 {\n\t\t\targs = append(args, \"IGNORE\", options.IgnoreMaxTimeDiff, options.IgnoreMaxValDiff)\n\t\t}\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSCreate - Creates a new time-series key.\n// For more information - https://redis.io/commands/ts.create/\nfunc (c cmdable) TSCreate(ctx context.Context, key string) *StatusCmd {\n\targs := []interface{}{\"TS.CREATE\", key}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSCreateWithArgs - Creates a new time-series key with additional options.\n// This function allows for specifying additional options such as:\n// Retention, ChunkSize, Encoding, DuplicatePolicy and Labels.\n// For more information - https://redis.io/commands/ts.create/\nfunc (c cmdable) TSCreateWithArgs(ctx context.Context, key string, options *TSOptions) *StatusCmd {\n\targs := []interface{}{\"TS.CREATE\", key}\n\tif options != nil {\n\t\tif options.Retention != 0 {\n\t\t\targs = append(args, \"RETENTION\", options.Retention)\n\t\t}\n\t\tif options.ChunkSize != 0 {\n\t\t\targs = append(args, \"CHUNK_SIZE\", options.ChunkSize)\n\t\t}\n\t\tif options.Encoding != \"\" {\n\t\t\targs = append(args, \"ENCODING\", options.Encoding)\n\t\t}\n\n\t\tif options.DuplicatePolicy != \"\" {\n\t\t\targs = append(args, \"DUPLICATE_POLICY\", options.DuplicatePolicy)\n\t\t}\n\t\tif options.Labels != nil {\n\t\t\targs = append(args, \"LABELS\")\n\t\t\tfor label, value := range options.Labels {\n\t\t\t\targs = append(args, label, value)\n\t\t\t}\n\t\t}\n\t\tif options.IgnoreMaxTimeDiff != 0 || options.IgnoreMaxValDiff != 0 {\n\t\t\targs = append(args, \"IGNORE\", options.IgnoreMaxTimeDiff, options.IgnoreMaxValDiff)\n\t\t}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSAlter - Alters an existing time-series key with additional options.\n// This function allows for specifying additional options such as:\n// Retention, ChunkSize and DuplicatePolicy.\n// For more information - https://redis.io/commands/ts.alter/\nfunc (c cmdable) TSAlter(ctx context.Context, key string, options *TSAlterOptions) *StatusCmd {\n\targs := []interface{}{\"TS.ALTER\", key}\n\tif options != nil {\n\t\tif options.Retention != 0 {\n\t\t\targs = append(args, \"RETENTION\", options.Retention)\n\t\t}\n\t\tif options.ChunkSize != 0 {\n\t\t\targs = append(args, \"CHUNK_SIZE\", options.ChunkSize)\n\t\t}\n\t\tif options.DuplicatePolicy != \"\" {\n\t\t\targs = append(args, \"DUPLICATE_POLICY\", options.DuplicatePolicy)\n\t\t}\n\t\tif options.Labels != nil {\n\t\t\targs = append(args, \"LABELS\")\n\t\t\tfor label, value := range options.Labels {\n\t\t\t\targs = append(args, label, value)\n\t\t\t}\n\t\t}\n\t\tif options.IgnoreMaxTimeDiff != 0 || options.IgnoreMaxValDiff != 0 {\n\t\t\targs = append(args, \"IGNORE\", options.IgnoreMaxTimeDiff, options.IgnoreMaxValDiff)\n\t\t}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSCreateRule - Creates a compaction rule from sourceKey to destKey.\n// For more information - https://redis.io/commands/ts.createrule/\nfunc (c cmdable) TSCreateRule(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int) *StatusCmd {\n\targs := []interface{}{\"TS.CREATERULE\", sourceKey, destKey, \"AGGREGATION\", aggregator.String(), bucketDuration}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSCreateRuleWithArgs - Creates a compaction rule from sourceKey to destKey with additional option.\n// This function allows for specifying additional option such as:\n// alignTimestamp.\n// For more information - https://redis.io/commands/ts.createrule/\nfunc (c cmdable) TSCreateRuleWithArgs(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int, options *TSCreateRuleOptions) *StatusCmd {\n\targs := []interface{}{\"TS.CREATERULE\", sourceKey, destKey, \"AGGREGATION\", aggregator.String(), bucketDuration}\n\tif options != nil {\n\t\tif options.alignTimestamp != 0 {\n\t\t\targs = append(args, options.alignTimestamp)\n\t\t}\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSIncrBy - Increments the value of a time-series key by the specified timestamp.\n// For more information - https://redis.io/commands/ts.incrby/\nfunc (c cmdable) TSIncrBy(ctx context.Context, Key string, timestamp float64) *IntCmd {\n\targs := []interface{}{\"TS.INCRBY\", Key, timestamp}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSIncrByWithArgs - Increments the value of a time-series key by the specified timestamp with additional options.\n// This function allows for specifying additional options such as:\n// Timestamp, Retention, ChunkSize, Uncompressed and Labels.\n// For more information - https://redis.io/commands/ts.incrby/\nfunc (c cmdable) TSIncrByWithArgs(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions) *IntCmd {\n\targs := []interface{}{\"TS.INCRBY\", key, timestamp}\n\tif options != nil {\n\t\tif options.Timestamp != 0 {\n\t\t\targs = append(args, \"TIMESTAMP\", options.Timestamp)\n\t\t}\n\t\tif options.Retention != 0 {\n\t\t\targs = append(args, \"RETENTION\", options.Retention)\n\t\t}\n\t\tif options.ChunkSize != 0 {\n\t\t\targs = append(args, \"CHUNK_SIZE\", options.ChunkSize)\n\t\t}\n\t\tif options.Uncompressed {\n\t\t\targs = append(args, \"UNCOMPRESSED\")\n\t\t}\n\t\tif options.DuplicatePolicy != \"\" {\n\t\t\targs = append(args, \"DUPLICATE_POLICY\", options.DuplicatePolicy)\n\t\t}\n\t\tif options.Labels != nil {\n\t\t\targs = append(args, \"LABELS\")\n\t\t\tfor label, value := range options.Labels {\n\t\t\t\targs = append(args, label, value)\n\t\t\t}\n\t\t}\n\t\tif options.IgnoreMaxTimeDiff != 0 || options.IgnoreMaxValDiff != 0 {\n\t\t\targs = append(args, \"IGNORE\", options.IgnoreMaxTimeDiff, options.IgnoreMaxValDiff)\n\t\t}\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSDecrBy - Decrements the value of a time-series key by the specified timestamp.\n// For more information - https://redis.io/commands/ts.decrby/\nfunc (c cmdable) TSDecrBy(ctx context.Context, Key string, timestamp float64) *IntCmd {\n\targs := []interface{}{\"TS.DECRBY\", Key, timestamp}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSDecrByWithArgs - Decrements the value of a time-series key by the specified timestamp with additional options.\n// This function allows for specifying additional options such as:\n// Timestamp, Retention, ChunkSize, Uncompressed and Labels.\n// For more information - https://redis.io/commands/ts.decrby/\nfunc (c cmdable) TSDecrByWithArgs(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions) *IntCmd {\n\targs := []interface{}{\"TS.DECRBY\", key, timestamp}\n\tif options != nil {\n\t\tif options.Timestamp != 0 {\n\t\t\targs = append(args, \"TIMESTAMP\", options.Timestamp)\n\t\t}\n\t\tif options.Retention != 0 {\n\t\t\targs = append(args, \"RETENTION\", options.Retention)\n\t\t}\n\t\tif options.ChunkSize != 0 {\n\t\t\targs = append(args, \"CHUNK_SIZE\", options.ChunkSize)\n\t\t}\n\t\tif options.Uncompressed {\n\t\t\targs = append(args, \"UNCOMPRESSED\")\n\t\t}\n\t\tif options.DuplicatePolicy != \"\" {\n\t\t\targs = append(args, \"DUPLICATE_POLICY\", options.DuplicatePolicy)\n\t\t}\n\t\tif options.Labels != nil {\n\t\t\targs = append(args, \"LABELS\")\n\t\t\tfor label, value := range options.Labels {\n\t\t\t\targs = append(args, label, value)\n\t\t\t}\n\t\t}\n\t\tif options.IgnoreMaxTimeDiff != 0 || options.IgnoreMaxValDiff != 0 {\n\t\t\targs = append(args, \"IGNORE\", options.IgnoreMaxTimeDiff, options.IgnoreMaxValDiff)\n\t\t}\n\t}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSDel - Deletes a range of samples from a time-series key.\n// For more information - https://redis.io/commands/ts.del/\nfunc (c cmdable) TSDel(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *IntCmd {\n\targs := []interface{}{\"TS.DEL\", Key, fromTimestamp, toTimestamp}\n\tcmd := NewIntCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSDeleteRule - Deletes a compaction rule from sourceKey to destKey.\n// For more information - https://redis.io/commands/ts.deleterule/\nfunc (c cmdable) TSDeleteRule(ctx context.Context, sourceKey string, destKey string) *StatusCmd {\n\targs := []interface{}{\"TS.DELETERULE\", sourceKey, destKey}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSGetWithArgs - Gets the last sample of a time-series key with additional option.\n// This function allows for specifying additional option such as:\n// Latest.\n// For more information - https://redis.io/commands/ts.get/\nfunc (c cmdable) TSGetWithArgs(ctx context.Context, key string, options *TSGetOptions) *TSTimestampValueCmd {\n\targs := []interface{}{\"TS.GET\", key}\n\tif options != nil {\n\t\tif options.Latest {\n\t\t\targs = append(args, \"LATEST\")\n\t\t}\n\t}\n\tcmd := newTSTimestampValueCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSGet - Gets the last sample of a time-series key.\n// For more information - https://redis.io/commands/ts.get/\nfunc (c cmdable) TSGet(ctx context.Context, key string) *TSTimestampValueCmd {\n\targs := []interface{}{\"TS.GET\", key}\n\tcmd := newTSTimestampValueCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype TSTimestampValue struct {\n\tTimestamp int64\n\tValue     float64\n}\ntype TSTimestampValueCmd struct {\n\tbaseCmd\n\tval TSTimestampValue\n}\n\nfunc newTSTimestampValueCmd(ctx context.Context, args ...interface{}) *TSTimestampValueCmd {\n\treturn &TSTimestampValueCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *TSTimestampValueCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *TSTimestampValueCmd) SetVal(val TSTimestampValue) {\n\tcmd.val = val\n}\n\nfunc (cmd *TSTimestampValueCmd) Result() (TSTimestampValue, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *TSTimestampValueCmd) Val() TSTimestampValue {\n\treturn cmd.val\n}\n\nfunc (cmd *TSTimestampValueCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = TSTimestampValue{}\n\tfor i := 0; i < n; i++ {\n\t\ttimestamp, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalue, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val.Timestamp = timestamp\n\t\tcmd.val.Value, err = strconv.ParseFloat(value, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// TSInfo - Returns information about a time-series key.\n// For more information - https://redis.io/commands/ts.info/\nfunc (c cmdable) TSInfo(ctx context.Context, key string) *MapStringInterfaceCmd {\n\targs := []interface{}{\"TS.INFO\", key}\n\tcmd := NewMapStringInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSInfoWithArgs - Returns information about a time-series key with additional option.\n// This function allows for specifying additional option such as:\n// Debug.\n// For more information - https://redis.io/commands/ts.info/\nfunc (c cmdable) TSInfoWithArgs(ctx context.Context, key string, options *TSInfoOptions) *MapStringInterfaceCmd {\n\targs := []interface{}{\"TS.INFO\", key}\n\tif options != nil {\n\t\tif options.Debug {\n\t\t\targs = append(args, \"DEBUG\")\n\t\t}\n\t}\n\tcmd := NewMapStringInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSMAdd - Adds multiple samples to multiple time-series keys.\n// It accepts a slice of 'ktv' slices, each containing exactly three elements: key, timestamp, and value.\n// This struct must be provided for this command to work.\n// For more information - https://redis.io/commands/ts.madd/\nfunc (c cmdable) TSMAdd(ctx context.Context, ktvSlices [][]interface{}) *IntSliceCmd {\n\targs := []interface{}{\"TS.MADD\"}\n\tfor _, ktv := range ktvSlices {\n\t\targs = append(args, ktv...)\n\t}\n\tcmd := NewIntSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSQueryIndex - Returns all the keys matching the filter expression.\n// For more information - https://redis.io/commands/ts.queryindex/\nfunc (c cmdable) TSQueryIndex(ctx context.Context, filterExpr []string) *StringSliceCmd {\n\targs := []interface{}{\"TS.QUERYINDEX\"}\n\tfor _, f := range filterExpr {\n\t\targs = append(args, f)\n\t}\n\tcmd := NewStringSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSRevRange - Returns a range of samples from a time-series key in reverse order.\n// For more information - https://redis.io/commands/ts.revrange/\nfunc (c cmdable) TSRevRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *TSTimestampValueSliceCmd {\n\targs := []interface{}{\"TS.REVRANGE\", key, fromTimestamp, toTimestamp}\n\tcmd := newTSTimestampValueSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSRevRangeWithArgs - Returns a range of samples from a time-series key in reverse order with additional options.\n// This function allows for specifying additional options such as:\n// Latest, FilterByTS, FilterByValue, Count, Align, Aggregator,\n// BucketDuration, BucketTimestamp and Empty.\n// For more information - https://redis.io/commands/ts.revrange/\nfunc (c cmdable) TSRevRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRevRangeOptions) *TSTimestampValueSliceCmd {\n\targs := []interface{}{\"TS.REVRANGE\", key, fromTimestamp, toTimestamp}\n\tif options != nil {\n\t\tif options.Latest {\n\t\t\targs = append(args, \"LATEST\")\n\t\t}\n\t\tif options.FilterByTS != nil {\n\t\t\targs = append(args, \"FILTER_BY_TS\")\n\t\t\tfor _, f := range options.FilterByTS {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.FilterByValue != nil {\n\t\t\targs = append(args, \"FILTER_BY_VALUE\")\n\t\t\tfor _, f := range options.FilterByValue {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.Count != 0 {\n\t\t\targs = append(args, \"COUNT\", options.Count)\n\t\t}\n\t\tif options.Align != nil {\n\t\t\targs = append(args, \"ALIGN\", options.Align)\n\t\t}\n\t\tif options.Aggregator != 0 {\n\t\t\targs = append(args, \"AGGREGATION\", options.Aggregator.String())\n\t\t}\n\t\tif options.BucketDuration != 0 {\n\t\t\targs = append(args, options.BucketDuration)\n\t\t}\n\t\tif options.BucketTimestamp != nil {\n\t\t\targs = append(args, \"BUCKETTIMESTAMP\", options.BucketTimestamp)\n\t\t}\n\t\tif options.Empty {\n\t\t\targs = append(args, \"EMPTY\")\n\t\t}\n\t}\n\tcmd := newTSTimestampValueSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSRange - Returns a range of samples from a time-series key.\n// For more information - https://redis.io/commands/ts.range/\nfunc (c cmdable) TSRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *TSTimestampValueSliceCmd {\n\targs := []interface{}{\"TS.RANGE\", key, fromTimestamp, toTimestamp}\n\tcmd := newTSTimestampValueSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSRangeWithArgs - Returns a range of samples from a time-series key with additional options.\n// This function allows for specifying additional options such as:\n// Latest, FilterByTS, FilterByValue, Count, Align, Aggregator,\n// BucketDuration, BucketTimestamp and Empty.\n// For more information - https://redis.io/commands/ts.range/\nfunc (c cmdable) TSRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRangeOptions) *TSTimestampValueSliceCmd {\n\targs := []interface{}{\"TS.RANGE\", key, fromTimestamp, toTimestamp}\n\tif options != nil {\n\t\tif options.Latest {\n\t\t\targs = append(args, \"LATEST\")\n\t\t}\n\t\tif options.FilterByTS != nil {\n\t\t\targs = append(args, \"FILTER_BY_TS\")\n\t\t\tfor _, f := range options.FilterByTS {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.FilterByValue != nil {\n\t\t\targs = append(args, \"FILTER_BY_VALUE\")\n\t\t\tfor _, f := range options.FilterByValue {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.Count != 0 {\n\t\t\targs = append(args, \"COUNT\", options.Count)\n\t\t}\n\t\tif options.Align != nil {\n\t\t\targs = append(args, \"ALIGN\", options.Align)\n\t\t}\n\t\tif options.Aggregator != 0 {\n\t\t\targs = append(args, \"AGGREGATION\", options.Aggregator.String())\n\t\t}\n\t\tif options.BucketDuration != 0 {\n\t\t\targs = append(args, options.BucketDuration)\n\t\t}\n\t\tif options.BucketTimestamp != nil {\n\t\t\targs = append(args, \"BUCKETTIMESTAMP\", options.BucketTimestamp)\n\t\t}\n\t\tif options.Empty {\n\t\t\targs = append(args, \"EMPTY\")\n\t\t}\n\t}\n\tcmd := newTSTimestampValueSliceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\ntype TSTimestampValueSliceCmd struct {\n\tbaseCmd\n\tval []TSTimestampValue\n}\n\nfunc newTSTimestampValueSliceCmd(ctx context.Context, args ...interface{}) *TSTimestampValueSliceCmd {\n\treturn &TSTimestampValueSliceCmd{\n\t\tbaseCmd: baseCmd{\n\t\t\tctx:  ctx,\n\t\t\targs: args,\n\t\t},\n\t}\n}\n\nfunc (cmd *TSTimestampValueSliceCmd) String() string {\n\treturn cmdString(cmd, cmd.val)\n}\n\nfunc (cmd *TSTimestampValueSliceCmd) SetVal(val []TSTimestampValue) {\n\tcmd.val = val\n}\n\nfunc (cmd *TSTimestampValueSliceCmd) Result() ([]TSTimestampValue, error) {\n\treturn cmd.val, cmd.err\n}\n\nfunc (cmd *TSTimestampValueSliceCmd) Val() []TSTimestampValue {\n\treturn cmd.val\n}\n\nfunc (cmd *TSTimestampValueSliceCmd) readReply(rd *proto.Reader) (err error) {\n\tn, err := rd.ReadArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcmd.val = make([]TSTimestampValue, n)\n\tfor i := 0; i < n; i++ {\n\t\t_, _ = rd.ReadArrayLen()\n\t\ttimestamp, err := rd.ReadInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvalue, err := rd.ReadString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.val[i].Timestamp = timestamp\n\t\tcmd.val[i].Value, err = strconv.ParseFloat(value, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// TSMRange - Returns a range of samples from multiple time-series keys.\n// For more information - https://redis.io/commands/ts.mrange/\nfunc (c cmdable) TSMRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *MapStringSliceInterfaceCmd {\n\targs := []interface{}{\"TS.MRANGE\", fromTimestamp, toTimestamp, \"FILTER\"}\n\tfor _, f := range filterExpr {\n\t\targs = append(args, f)\n\t}\n\tcmd := NewMapStringSliceInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSMRangeWithArgs - Returns a range of samples from multiple time-series keys with additional options.\n// This function allows for specifying additional options such as:\n// Latest, FilterByTS, FilterByValue, WithLabels, SelectedLabels,\n// Count, Align, Aggregator, BucketDuration, BucketTimestamp,\n// Empty, GroupByLabel and Reducer.\n// For more information - https://redis.io/commands/ts.mrange/\nfunc (c cmdable) TSMRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRangeOptions) *MapStringSliceInterfaceCmd {\n\targs := []interface{}{\"TS.MRANGE\", fromTimestamp, toTimestamp}\n\tif options != nil {\n\t\tif options.Latest {\n\t\t\targs = append(args, \"LATEST\")\n\t\t}\n\t\tif options.FilterByTS != nil {\n\t\t\targs = append(args, \"FILTER_BY_TS\")\n\t\t\tfor _, f := range options.FilterByTS {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.FilterByValue != nil {\n\t\t\targs = append(args, \"FILTER_BY_VALUE\")\n\t\t\tfor _, f := range options.FilterByValue {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.WithLabels {\n\t\t\targs = append(args, \"WITHLABELS\")\n\t\t}\n\t\tif options.SelectedLabels != nil {\n\t\t\targs = append(args, \"SELECTED_LABELS\")\n\t\t\targs = append(args, options.SelectedLabels...)\n\t\t}\n\t\tif options.Count != 0 {\n\t\t\targs = append(args, \"COUNT\", options.Count)\n\t\t}\n\t\tif options.Align != nil {\n\t\t\targs = append(args, \"ALIGN\", options.Align)\n\t\t}\n\t\tif options.Aggregator != 0 {\n\t\t\targs = append(args, \"AGGREGATION\", options.Aggregator.String())\n\t\t}\n\t\tif options.BucketDuration != 0 {\n\t\t\targs = append(args, options.BucketDuration)\n\t\t}\n\t\tif options.BucketTimestamp != nil {\n\t\t\targs = append(args, \"BUCKETTIMESTAMP\", options.BucketTimestamp)\n\t\t}\n\t\tif options.Empty {\n\t\t\targs = append(args, \"EMPTY\")\n\t\t}\n\t}\n\targs = append(args, \"FILTER\")\n\tfor _, f := range filterExpr {\n\t\targs = append(args, f)\n\t}\n\tif options != nil {\n\t\tif options.GroupByLabel != nil {\n\t\t\targs = append(args, \"GROUPBY\", options.GroupByLabel)\n\t\t}\n\t\tif options.Reducer != nil {\n\t\t\targs = append(args, \"REDUCE\", options.Reducer)\n\t\t}\n\t}\n\tcmd := NewMapStringSliceInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSMRevRange - Returns a range of samples from multiple time-series keys in reverse order.\n// For more information - https://redis.io/commands/ts.mrevrange/\nfunc (c cmdable) TSMRevRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *MapStringSliceInterfaceCmd {\n\targs := []interface{}{\"TS.MREVRANGE\", fromTimestamp, toTimestamp, \"FILTER\"}\n\tfor _, f := range filterExpr {\n\t\targs = append(args, f)\n\t}\n\tcmd := NewMapStringSliceInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSMRevRangeWithArgs - Returns a range of samples from multiple time-series keys in reverse order with additional options.\n// This function allows for specifying additional options such as:\n// Latest, FilterByTS, FilterByValue, WithLabels, SelectedLabels,\n// Count, Align, Aggregator, BucketDuration, BucketTimestamp,\n// Empty, GroupByLabel and Reducer.\n// For more information - https://redis.io/commands/ts.mrevrange/\nfunc (c cmdable) TSMRevRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRevRangeOptions) *MapStringSliceInterfaceCmd {\n\targs := []interface{}{\"TS.MREVRANGE\", fromTimestamp, toTimestamp}\n\tif options != nil {\n\t\tif options.Latest {\n\t\t\targs = append(args, \"LATEST\")\n\t\t}\n\t\tif options.FilterByTS != nil {\n\t\t\targs = append(args, \"FILTER_BY_TS\")\n\t\t\tfor _, f := range options.FilterByTS {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.FilterByValue != nil {\n\t\t\targs = append(args, \"FILTER_BY_VALUE\")\n\t\t\tfor _, f := range options.FilterByValue {\n\t\t\t\targs = append(args, f)\n\t\t\t}\n\t\t}\n\t\tif options.WithLabels {\n\t\t\targs = append(args, \"WITHLABELS\")\n\t\t}\n\t\tif options.SelectedLabels != nil {\n\t\t\targs = append(args, \"SELECTED_LABELS\")\n\t\t\targs = append(args, options.SelectedLabels...)\n\t\t}\n\t\tif options.Count != 0 {\n\t\t\targs = append(args, \"COUNT\", options.Count)\n\t\t}\n\t\tif options.Align != nil {\n\t\t\targs = append(args, \"ALIGN\", options.Align)\n\t\t}\n\t\tif options.Aggregator != 0 {\n\t\t\targs = append(args, \"AGGREGATION\", options.Aggregator.String())\n\t\t}\n\t\tif options.BucketDuration != 0 {\n\t\t\targs = append(args, options.BucketDuration)\n\t\t}\n\t\tif options.BucketTimestamp != nil {\n\t\t\targs = append(args, \"BUCKETTIMESTAMP\", options.BucketTimestamp)\n\t\t}\n\t\tif options.Empty {\n\t\t\targs = append(args, \"EMPTY\")\n\t\t}\n\t}\n\targs = append(args, \"FILTER\")\n\tfor _, f := range filterExpr {\n\t\targs = append(args, f)\n\t}\n\tif options != nil {\n\t\tif options.GroupByLabel != nil {\n\t\t\targs = append(args, \"GROUPBY\", options.GroupByLabel)\n\t\t}\n\t\tif options.Reducer != nil {\n\t\t\targs = append(args, \"REDUCE\", options.Reducer)\n\t\t}\n\t}\n\tcmd := NewMapStringSliceInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSMGet - Returns the last sample of multiple time-series keys.\n// For more information - https://redis.io/commands/ts.mget/\nfunc (c cmdable) TSMGet(ctx context.Context, filters []string) *MapStringSliceInterfaceCmd {\n\targs := []interface{}{\"TS.MGET\", \"FILTER\"}\n\tfor _, f := range filters {\n\t\targs = append(args, f)\n\t}\n\tcmd := NewMapStringSliceInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n\n// TSMGetWithArgs - Returns the last sample of multiple time-series keys with additional options.\n// This function allows for specifying additional options such as:\n// Latest, WithLabels and SelectedLabels.\n// For more information - https://redis.io/commands/ts.mget/\nfunc (c cmdable) TSMGetWithArgs(ctx context.Context, filters []string, options *TSMGetOptions) *MapStringSliceInterfaceCmd {\n\targs := []interface{}{\"TS.MGET\"}\n\tif options != nil {\n\t\tif options.Latest {\n\t\t\targs = append(args, \"LATEST\")\n\t\t}\n\t\tif options.WithLabels {\n\t\t\targs = append(args, \"WITHLABELS\")\n\t\t}\n\t\tif options.SelectedLabels != nil {\n\t\t\targs = append(args, \"SELECTED_LABELS\")\n\t\t\targs = append(args, options.SelectedLabels...)\n\t\t}\n\t}\n\targs = append(args, \"FILTER\")\n\tfor _, f := range filters {\n\t\targs = append(args, f)\n\t}\n\tcmd := NewMapStringSliceInterfaceCmd(ctx, args...)\n\t_ = c(ctx, cmd)\n\treturn cmd\n}\n"
        },
        {
          "name": "timeseries_commands_test.go",
          "type": "blob",
          "size": 60.310546875,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"RedisTimeseries commands\", Label(\"timeseries\"), func() {\n\tctx := context.TODO()\n\n\tsetupRedisClient := func(protocolVersion int) *redis.Client {\n\t\treturn redis.NewClient(&redis.Options{\n\t\t\tAddr:          \"localhost:6379\",\n\t\t\tDB:            0,\n\t\t\tProtocol:      protocolVersion,\n\t\t\tUnstableResp3: true,\n\t\t})\n\t}\n\n\tprotocols := []int{2, 3}\n\tfor _, protocol := range protocols {\n\t\tprotocol := protocol // capture loop variable for each context\n\n\t\tContext(fmt.Sprintf(\"with protocol version %d\", protocol), func() {\n\t\t\tvar client *redis.Client\n\n\t\t\tBeforeEach(func() {\n\t\t\t\tclient = setupRedisClient(protocol)\n\t\t\t\tExpect(client.FlushAll(ctx).Err()).NotTo(HaveOccurred())\n\t\t\t})\n\n\t\t\tAfterEach(func() {\n\t\t\t\tif client != nil {\n\t\t\t\t\tclient.FlushDB(ctx)\n\t\t\t\t\tclient.Close()\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tIt(\"should TSCreate and TSCreateWithArgs\", Label(\"timeseries\", \"tscreate\", \"tscreateWithArgs\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tresult, err := client.TSCreate(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t// Test TSCreateWithArgs\n\t\t\t\topt := &redis.TSOptions{Retention: 5}\n\t\t\t\tresult, err = client.TSCreateWithArgs(ctx, \"2\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"Redis\": \"Labs\"}}\n\t\t\t\tresult, err = client.TSCreateWithArgs(ctx, \"3\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"Time\": \"Series\"}, Retention: 20}\n\t\t\t\tresult, err = client.TSCreateWithArgs(ctx, \"4\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultInfo, err := client.TSInfo(ctx, \"4\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(resultInfo[\"labels\"].([]interface{})[0]).To(BeEquivalentTo([]interface{}{\"Time\", \"Series\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(resultInfo[\"labels\"].(map[interface{}]interface{})[\"Time\"]).To(BeEquivalentTo(\"Series\"))\n\t\t\t\t}\n\t\t\t\t// Test chunk size\n\t\t\t\topt = &redis.TSOptions{ChunkSize: 128}\n\t\t\t\tresult, err = client.TSCreateWithArgs(ctx, \"ts-cs-1\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultInfo, err = client.TSInfo(ctx, \"ts-cs-1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultInfo[\"chunkSize\"]).To(BeEquivalentTo(128))\n\t\t\t\t// Test duplicate policy\n\t\t\t\tduplicate_policies := []string{\"BLOCK\", \"LAST\", \"FIRST\", \"MIN\", \"MAX\"}\n\t\t\t\tfor _, dup := range duplicate_policies {\n\t\t\t\t\tkeyName := \"ts-dup-\" + dup\n\t\t\t\t\topt = &redis.TSOptions{DuplicatePolicy: dup}\n\t\t\t\t\tresult, err = client.TSCreateWithArgs(ctx, keyName, opt).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t\tresultInfo, err = client.TSInfo(ctx, keyName).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(strings.ToUpper(resultInfo[\"duplicatePolicy\"].(string))).To(BeEquivalentTo(dup))\n\t\t\t\t}\n\t\t\t\t// Test insertion filters\n\t\t\t\topt = &redis.TSOptions{IgnoreMaxTimeDiff: 5, DuplicatePolicy: \"LAST\", IgnoreMaxValDiff: 10.0}\n\t\t\t\tresult, err = client.TSCreateWithArgs(ctx, \"ts-if-1\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultAdd, err := client.TSAdd(ctx, \"ts-if-1\", 1000, 1.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1000))\n\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"ts-if-1\", 1010, 11.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1010))\n\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"ts-if-1\", 1013, 10.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1010))\n\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"ts-if-1\", 1020, 11.5).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1020))\n\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"ts-if-1\", 1021, 22.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1021))\n\n\t\t\t\trangePoints, err := client.TSRange(ctx, \"ts-if-1\", 1000, 1021).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(4))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{\n\t\t\t\t\t{Timestamp: 1000, Value: 1.0},\n\t\t\t\t\t{Timestamp: 1010, Value: 11.0},\n\t\t\t\t\t{Timestamp: 1020, Value: 11.5},\n\t\t\t\t\t{Timestamp: 1021, Value: 22.0}}))\n\t\t\t\t// Test insertion filters with other duplicate policy\n\t\t\t\topt = &redis.TSOptions{IgnoreMaxTimeDiff: 5, IgnoreMaxValDiff: 10.0}\n\t\t\t\tresult, err = client.TSCreateWithArgs(ctx, \"ts-if-2\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultAdd1, err := client.TSAdd(ctx, \"ts-if-1\", 1000, 1.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd1).To(BeEquivalentTo(1000))\n\t\t\t\tresultAdd1, err = client.TSAdd(ctx, \"ts-if-1\", 1010, 11.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd1).To(BeEquivalentTo(1010))\n\t\t\t\tresultAdd1, err = client.TSAdd(ctx, \"ts-if-1\", 1013, 10.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd1).To(BeEquivalentTo(1013))\n\n\t\t\t\trangePoints, err = client.TSRange(ctx, \"ts-if-1\", 1000, 1013).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(3))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{\n\t\t\t\t\t{Timestamp: 1000, Value: 1.0},\n\t\t\t\t\t{Timestamp: 1010, Value: 11.0},\n\t\t\t\t\t{Timestamp: 1013, Value: 10.0}}))\n\t\t\t})\n\t\t\tIt(\"should TSAdd and TSAddWithArgs\", Label(\"timeseries\", \"tsadd\", \"tsaddWithArgs\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tresult, err := client.TSAdd(ctx, \"1\", 1, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\t// Test TSAddWithArgs\n\t\t\t\topt := &redis.TSOptions{Retention: 10}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"2\", 2, 3, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(2))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"Redis\": \"Labs\"}}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"3\", 3, 2, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(3))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"Redis\": \"Labs\", \"Time\": \"Series\"}, Retention: 10}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"4\", 4, 2, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(4))\n\t\t\t\tresultInfo, err := client.TSInfo(ctx, \"4\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(resultInfo[\"labels\"].([]interface{})).To(ContainElement([]interface{}{\"Time\", \"Series\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(resultInfo[\"labels\"].(map[interface{}]interface{})[\"Time\"]).To(BeEquivalentTo(\"Series\"))\n\t\t\t\t}\n\t\t\t\t// Test chunk size\n\t\t\t\topt = &redis.TSOptions{ChunkSize: 128}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"ts-cs-1\", 1, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresultInfo, err = client.TSInfo(ctx, \"ts-cs-1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultInfo[\"chunkSize\"]).To(BeEquivalentTo(128))\n\t\t\t\t// Test duplicate policy\n\t\t\t\t// LAST\n\t\t\t\topt = &redis.TSOptions{DuplicatePolicy: \"LAST\"}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsal-1\", 1, 5, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsal-1\", 1, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresultGet, err := client.TSGet(ctx, \"tsal-1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet.Value).To(BeEquivalentTo(10))\n\t\t\t\t// FIRST\n\t\t\t\topt = &redis.TSOptions{DuplicatePolicy: \"FIRST\"}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsaf-1\", 1, 5, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsaf-1\", 1, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresultGet, err = client.TSGet(ctx, \"tsaf-1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet.Value).To(BeEquivalentTo(5))\n\t\t\t\t// MAX\n\t\t\t\topt = &redis.TSOptions{DuplicatePolicy: \"MAX\"}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsam-1\", 1, 5, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsam-1\", 1, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresultGet, err = client.TSGet(ctx, \"tsam-1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet.Value).To(BeEquivalentTo(10))\n\t\t\t\t// MIN\n\t\t\t\topt = &redis.TSOptions{DuplicatePolicy: \"MIN\"}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsami-1\", 1, 5, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"tsami-1\", 1, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1))\n\t\t\t\tresultGet, err = client.TSGet(ctx, \"tsami-1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet.Value).To(BeEquivalentTo(5))\n\t\t\t\t// Insertion filters\n\t\t\t\topt = &redis.TSOptions{IgnoreMaxTimeDiff: 5, IgnoreMaxValDiff: 10.0, DuplicatePolicy: \"LAST\"}\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"ts-if-1\", 1000, 1.0, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1000))\n\n\t\t\t\tresult, err = client.TSAddWithArgs(ctx, \"ts-if-1\", 1004, 3.0, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(1000))\n\n\t\t\t\trangePoints, err := client.TSRange(ctx, \"ts-if-1\", 1000, 1004).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(1))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 1000, Value: 1.0}}))\n\t\t\t})\n\n\t\t\tIt(\"should TSAlter\", Label(\"timeseries\", \"tsalter\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tresult, err := client.TSCreate(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultInfo, err := client.TSInfo(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultInfo[\"retentionTime\"]).To(BeEquivalentTo(0))\n\n\t\t\t\topt := &redis.TSAlterOptions{Retention: 10}\n\t\t\t\tresultAlter, err := client.TSAlter(ctx, \"1\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAlter).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultInfo, err = client.TSInfo(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultInfo[\"retentionTime\"]).To(BeEquivalentTo(10))\n\n\t\t\t\tresultInfo, err = client.TSInfo(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(resultInfo[\"labels\"]).To(BeEquivalentTo([]interface{}{}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(resultInfo[\"labels\"]).To(BeEquivalentTo(map[interface{}]interface{}{}))\n\t\t\t\t}\n\n\t\t\t\topt = &redis.TSAlterOptions{Labels: map[string]string{\"Time\": \"Series\"}}\n\t\t\t\tresultAlter, err = client.TSAlter(ctx, \"1\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAlter).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultInfo, err = client.TSInfo(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(resultInfo[\"labels\"].([]interface{})[0]).To(BeEquivalentTo([]interface{}{\"Time\", \"Series\"}))\n\t\t\t\t\tExpect(resultInfo[\"retentionTime\"]).To(BeEquivalentTo(10))\n\t\t\t\t\tExpect(resultInfo[\"duplicatePolicy\"]).To(BeEquivalentTo(redis.Nil))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(resultInfo[\"labels\"].(map[interface{}]interface{})[\"Time\"]).To(BeEquivalentTo(\"Series\"))\n\t\t\t\t\tExpect(resultInfo[\"retentionTime\"]).To(BeEquivalentTo(10))\n\t\t\t\t\tExpect(resultInfo[\"duplicatePolicy\"]).To(BeEquivalentTo(redis.Nil))\n\t\t\t\t}\n\t\t\t\topt = &redis.TSAlterOptions{DuplicatePolicy: \"min\"}\n\t\t\t\tresultAlter, err = client.TSAlter(ctx, \"1\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAlter).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultInfo, err = client.TSInfo(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultInfo[\"duplicatePolicy\"]).To(BeEquivalentTo(\"min\"))\n\t\t\t\t// Test insertion filters\n\t\t\t\tresultAdd, err := client.TSAdd(ctx, \"ts-if-1\", 1000, 1.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1000))\n\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"ts-if-1\", 1010, 11.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1010))\n\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"ts-if-1\", 1013, 10.0).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1013))\n\n\t\t\t\talterOpt := &redis.TSAlterOptions{IgnoreMaxTimeDiff: 5, IgnoreMaxValDiff: 10.0, DuplicatePolicy: \"LAST\"}\n\t\t\t\tresultAlter, err = client.TSAlter(ctx, \"ts-if-1\", alterOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAlter).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"ts-if-1\", 1015, 11.5).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(1013))\n\n\t\t\t\trangePoints, err := client.TSRange(ctx, \"ts-if-1\", 1000, 1013).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(3))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{\n\t\t\t\t\t{Timestamp: 1000, Value: 1.0},\n\t\t\t\t\t{Timestamp: 1010, Value: 11.0},\n\t\t\t\t\t{Timestamp: 1013, Value: 10.0}}))\n\t\t\t})\n\n\t\t\tIt(\"should TSCreateRule and TSDeleteRule\", Label(\"timeseries\", \"tscreaterule\", \"tsdeleterule\"), func() {\n\t\t\t\tresult, err := client.TSCreate(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresult, err = client.TSCreate(ctx, \"2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresult, err = client.TSCreateRule(ctx, \"1\", \"2\", redis.Avg, 100).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tfor i := 0; i < 50; i++ {\n\t\t\t\t\tresultAdd, err := client.TSAdd(ctx, \"1\", 100+i*2, 1).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(100 + i*2))\n\t\t\t\t\tresultAdd, err = client.TSAdd(ctx, \"1\", 100+i*2+1, 2).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(100 + i*2 + 1))\n\n\t\t\t\t}\n\t\t\t\tresultAdd, err := client.TSAdd(ctx, \"1\", 100*2, 1.5).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultAdd).To(BeEquivalentTo(100 * 2))\n\t\t\t\tresultGet, err := client.TSGet(ctx, \"2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet.Value).To(BeEquivalentTo(1.5))\n\t\t\t\tExpect(resultGet.Timestamp).To(BeEquivalentTo(100))\n\n\t\t\t\tresultDeleteRule, err := client.TSDeleteRule(ctx, \"1\", \"2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultDeleteRule).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultInfo, err := client.TSInfo(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(resultInfo[\"rules\"]).To(BeEquivalentTo([]interface{}{}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(resultInfo[\"rules\"]).To(BeEquivalentTo(map[interface{}]interface{}{}))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tIt(\"should TSIncrBy, TSIncrByWithArgs, TSDecrBy and TSDecrByWithArgs\", Label(\"timeseries\", \"tsincrby\", \"tsdecrby\", \"tsincrbyWithArgs\", \"tsdecrbyWithArgs\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSIncrBy(ctx, \"1\", 1).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tresult, err := client.TSGet(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(100))\n\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSDecrBy(ctx, \"1\", 1).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tresult, err = client.TSGet(ctx, \"1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(0))\n\n\t\t\t\topt := &redis.TSIncrDecrOptions{Timestamp: 5}\n\t\t\t\t_, err = client.TSIncrByWithArgs(ctx, \"2\", 1.5, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tresult, err = client.TSGet(ctx, \"2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Timestamp).To(BeEquivalentTo(5))\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(1.5))\n\n\t\t\t\topt = &redis.TSIncrDecrOptions{Timestamp: 7}\n\t\t\t\t_, err = client.TSIncrByWithArgs(ctx, \"2\", 2.25, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tresult, err = client.TSGet(ctx, \"2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Timestamp).To(BeEquivalentTo(7))\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(3.75))\n\n\t\t\t\topt = &redis.TSIncrDecrOptions{Timestamp: 15}\n\t\t\t\t_, err = client.TSDecrByWithArgs(ctx, \"2\", 1.5, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tresult, err = client.TSGet(ctx, \"2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Timestamp).To(BeEquivalentTo(15))\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(2.25))\n\n\t\t\t\t// Test chunk size INCRBY\n\t\t\t\topt = &redis.TSIncrDecrOptions{ChunkSize: 128}\n\t\t\t\t_, err = client.TSIncrByWithArgs(ctx, \"3\", 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tresultInfo, err := client.TSInfo(ctx, \"3\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultInfo[\"chunkSize\"]).To(BeEquivalentTo(128))\n\n\t\t\t\t// Test chunk size DECRBY\n\t\t\t\topt = &redis.TSIncrDecrOptions{ChunkSize: 128}\n\t\t\t\t_, err = client.TSDecrByWithArgs(ctx, \"4\", 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tresultInfo, err = client.TSInfo(ctx, \"4\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultInfo[\"chunkSize\"]).To(BeEquivalentTo(128))\n\n\t\t\t\t// Test insertion filters INCRBY\n\t\t\t\topt = &redis.TSIncrDecrOptions{Timestamp: 1000, IgnoreMaxTimeDiff: 5, IgnoreMaxValDiff: 10.0, DuplicatePolicy: \"LAST\"}\n\t\t\t\tres, err := client.TSIncrByWithArgs(ctx, \"ts-if-1\", 1.0, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(BeEquivalentTo(1000))\n\n\t\t\t\tres, err = client.TSIncrByWithArgs(ctx, \"ts-if-1\", 3.0, &redis.TSIncrDecrOptions{Timestamp: 1000}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(BeEquivalentTo(1000))\n\n\t\t\t\trangePoints, err := client.TSRange(ctx, \"ts-if-1\", 1000, 1004).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(1))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 1000, Value: 1.0}}))\n\n\t\t\t\tres, err = client.TSIncrByWithArgs(ctx, \"ts-if-1\", 10.1, &redis.TSIncrDecrOptions{Timestamp: 1000}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(BeEquivalentTo(1000))\n\n\t\t\t\trangePoints, err = client.TSRange(ctx, \"ts-if-1\", 1000, 1004).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(1))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 1000, Value: 11.1}}))\n\n\t\t\t\t// Test insertion filters DECRBY\n\t\t\t\topt = &redis.TSIncrDecrOptions{Timestamp: 1000, IgnoreMaxTimeDiff: 5, IgnoreMaxValDiff: 10.0, DuplicatePolicy: \"LAST\"}\n\t\t\t\tres, err = client.TSDecrByWithArgs(ctx, \"ts-if-2\", 1.0, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(BeEquivalentTo(1000))\n\n\t\t\t\tres, err = client.TSDecrByWithArgs(ctx, \"ts-if-2\", 3.0, &redis.TSIncrDecrOptions{Timestamp: 1000}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(BeEquivalentTo(1000))\n\n\t\t\t\trangePoints, err = client.TSRange(ctx, \"ts-if-2\", 1000, 1004).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(1))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 1000, Value: -1.0}}))\n\n\t\t\t\tres, err = client.TSDecrByWithArgs(ctx, \"ts-if-2\", 10.1, &redis.TSIncrDecrOptions{Timestamp: 1000}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(res).To(BeEquivalentTo(1000))\n\n\t\t\t\trangePoints, err = client.TSRange(ctx, \"ts-if-2\", 1000, 1004).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(rangePoints)).To(BeEquivalentTo(1))\n\t\t\t\tExpect(rangePoints).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 1000, Value: -11.1}}))\n\t\t\t})\n\n\t\t\tIt(\"should TSGet\", Label(\"timeseries\", \"tsget\"), func() {\n\t\t\t\topt := &redis.TSOptions{DuplicatePolicy: \"max\"}\n\t\t\t\tresultGet, err := client.TSAddWithArgs(ctx, \"foo\", 2265985, 151, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet).To(BeEquivalentTo(2265985))\n\t\t\t\tresult, err := client.TSGet(ctx, \"foo\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Timestamp).To(BeEquivalentTo(2265985))\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(151))\n\t\t\t})\n\n\t\t\tIt(\"should TSGet Latest\", Label(\"timeseries\", \"tsgetlatest\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tresultGet, err := client.TSCreate(ctx, \"tsgl-1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultGet, err = client.TSCreate(ctx, \"tsgl-2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultGet, err = client.TSCreateRule(ctx, \"tsgl-1\", \"tsgl-2\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tExpect(resultGet).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t_, err = client.TSAdd(ctx, \"tsgl-1\", 1, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"tsgl-1\", 2, 3).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"tsgl-1\", 11, 7).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"tsgl-1\", 13, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tresult, errGet := client.TSGet(ctx, \"tsgl-2\").Result()\n\t\t\t\tExpect(errGet).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Timestamp).To(BeEquivalentTo(0))\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(4))\n\t\t\t\tresult, errGet = client.TSGetWithArgs(ctx, \"tsgl-2\", &redis.TSGetOptions{Latest: true}).Result()\n\t\t\t\tExpect(errGet).NotTo(HaveOccurred())\n\t\t\t\tExpect(result.Timestamp).To(BeEquivalentTo(10))\n\t\t\t\tExpect(result.Value).To(BeEquivalentTo(8))\n\t\t\t})\n\n\t\t\tIt(\"should TSInfo\", Label(\"timeseries\", \"tsinfo\"), func() {\n\t\t\t\tresultGet, err := client.TSAdd(ctx, \"foo\", 2265985, 151).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet).To(BeEquivalentTo(2265985))\n\t\t\t\tresult, err := client.TSInfo(ctx, \"foo\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result[\"firstTimestamp\"]).To(BeEquivalentTo(2265985))\n\t\t\t})\n\n\t\t\tIt(\"should TSMAdd\", Label(\"timeseries\", \"tsmadd\"), func() {\n\t\t\t\tresultGet, err := client.TSCreate(ctx, \"a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultGet).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tktvSlices := make([][]interface{}, 3)\n\t\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\t\tktvSlices[i] = make([]interface{}, 3)\n\t\t\t\t\tktvSlices[i][0] = \"a\"\n\t\t\t\t\tfor j := 1; j < 3; j++ {\n\t\t\t\t\t\tktvSlices[i][j] = (i + j) * j\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult, err := client.TSMAdd(ctx, ktvSlices).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo([]int64{1, 2, 3}))\n\t\t\t})\n\n\t\t\tIt(\"should TSMGet and TSMGetWithArgs\", Label(\"timeseries\", \"tsmget\", \"tsmgetWithArgs\", \"NonRedisEnterprise\"), func() {\n\t\t\t\topt := &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\"}}\n\t\t\t\tresultCreate, err := client.TSCreateWithArgs(ctx, \"a\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\", \"Taste\": \"That\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"b\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", \"*\", 15).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"b\", \"*\", 25).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\tresult, err := client.TSMGet(ctx, []string{\"Test=This\"}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][1].([]interface{})[1]).To(BeEquivalentTo(\"15\"))\n\t\t\t\t\tExpect(result[\"b\"][1].([]interface{})[1]).To(BeEquivalentTo(\"25\"))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][1].([]interface{})[1]).To(BeEquivalentTo(15))\n\t\t\t\t\tExpect(result[\"b\"][1].([]interface{})[1]).To(BeEquivalentTo(25))\n\t\t\t\t}\n\t\t\t\tmgetOpt := &redis.TSMGetOptions{WithLabels: true}\n\t\t\t\tresult, err = client.TSMGetWithArgs(ctx, []string{\"Test=This\"}, mgetOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"b\"][0]).To(ConsistOf([]interface{}{\"Test\", \"This\"}, []interface{}{\"Taste\", \"That\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"b\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{\"Test\": \"This\", \"Taste\": \"That\"}))\n\t\t\t\t}\n\n\t\t\t\tresultCreate, err = client.TSCreate(ctx, \"c\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"is_compaction\": \"true\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"d\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultCreateRule, err := client.TSCreateRule(ctx, \"c\", \"d\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreateRule).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 1, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 2, 3).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 11, 7).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 13, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tresult, err = client.TSMGet(ctx, []string{\"is_compaction=true\"}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"d\"][1]).To(BeEquivalentTo([]interface{}{int64(0), \"4\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"d\"][1]).To(BeEquivalentTo([]interface{}{int64(0), 4.0}))\n\t\t\t\t}\n\t\t\t\tmgetOpt = &redis.TSMGetOptions{Latest: true}\n\t\t\t\tresult, err = client.TSMGetWithArgs(ctx, []string{\"is_compaction=true\"}, mgetOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"d\"][1]).To(BeEquivalentTo([]interface{}{int64(10), \"8\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"d\"][1]).To(BeEquivalentTo([]interface{}{int64(10), 8.0}))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tIt(\"should TSQueryIndex\", Label(\"timeseries\", \"tsqueryindex\"), func() {\n\t\t\t\topt := &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\"}}\n\t\t\t\tresultCreate, err := client.TSCreateWithArgs(ctx, \"a\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\", \"Taste\": \"That\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"b\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresult, err := client.TSQueryIndex(ctx, []string{\"Test=This\"}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\tresult, err = client.TSQueryIndex(ctx, []string{\"Taste=That\"}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(1))\n\t\t\t})\n\n\t\t\tIt(\"should TSDel and TSRange\", Label(\"timeseries\", \"tsdel\", \"tsrange\"), func() {\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSAdd(ctx, \"a\", i, float64(i%7)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tresultDelete, err := client.TSDel(ctx, \"a\", 0, 21).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultDelete).To(BeEquivalentTo(22))\n\n\t\t\t\tresultRange, err := client.TSRange(ctx, \"a\", 0, 21).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange).To(BeEquivalentTo([]redis.TSTimestampValue{}))\n\n\t\t\t\tresultRange, err = client.TSRange(ctx, \"a\", 22, 22).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 22, Value: 1}))\n\t\t\t})\n\n\t\t\tIt(\"should TSRange, TSRangeWithArgs\", Label(\"timeseries\", \"tsrange\", \"tsrangeWithArgs\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSAdd(ctx, \"a\", i, float64(i%7)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t}\n\t\t\t\tresult, err := client.TSRange(ctx, \"a\", 0, 200).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(100))\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\tclient.TSAdd(ctx, \"a\", i+200, float64(i%7))\n\t\t\t\t}\n\t\t\t\tresult, err = client.TSRange(ctx, \"a\", 0, 500).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(200))\n\t\t\t\tfts := make([]int, 0)\n\t\t\t\tfor i := 10; i < 20; i++ {\n\t\t\t\t\tfts = append(fts, i)\n\t\t\t\t}\n\t\t\t\topt := &redis.TSRangeOptions{FilterByTS: fts, FilterByValue: []int{1, 2}}\n\t\t\t\tresult, err = client.TSRangeWithArgs(ctx, \"a\", 0, 500, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\topt = &redis.TSRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: \"+\"}\n\t\t\t\tresult, err = client.TSRangeWithArgs(ctx, \"a\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 0, Value: 10}, {Timestamp: 10, Value: 1}}))\n\t\t\t\topt = &redis.TSRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: \"5\"}\n\t\t\t\tresult, err = client.TSRangeWithArgs(ctx, \"a\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 0, Value: 5}, {Timestamp: 5, Value: 6}}))\n\t\t\t\topt = &redis.TSRangeOptions{Aggregator: redis.Twa, BucketDuration: 10}\n\t\t\t\tresult, err = client.TSRangeWithArgs(ctx, \"a\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 0, Value: 2.55}, {Timestamp: 10, Value: 3}}))\n\t\t\t\t// Test Range Latest\n\t\t\t\tresultCreate, err := client.TSCreate(ctx, \"t1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultCreate, err = client.TSCreate(ctx, \"t2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultRule, err := client.TSCreateRule(ctx, \"t1\", \"t2\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRule).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t_, errAdd := client.TSAdd(ctx, \"t1\", 1, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t1\", 2, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t1\", 11, 7).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t1\", 13, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\tresultRange, err := client.TSRange(ctx, \"t1\", 0, 20).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 1, Value: 1}))\n\n\t\t\t\topt = &redis.TSRangeOptions{Latest: true}\n\t\t\t\tresultRange, err = client.TSRangeWithArgs(ctx, \"t2\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 0, Value: 4}))\n\t\t\t\t// Test Bucket Timestamp\n\t\t\t\tresultCreate, err = client.TSCreate(ctx, \"t3\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 15, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 17, 4).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 51, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 73, 5).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 75, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\n\t\t\t\topt = &redis.TSRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10}\n\t\t\t\tresultRange, err = client.TSRangeWithArgs(ctx, \"t3\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 10, Value: 4}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(3))\n\n\t\t\t\topt = &redis.TSRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10, BucketTimestamp: \"+\"}\n\t\t\t\tresultRange, err = client.TSRangeWithArgs(ctx, \"t3\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 20, Value: 4}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(3))\n\t\t\t\t// Test Empty\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 15, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 17, 4).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 51, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 73, 5).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 75, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\n\t\t\t\topt = &redis.TSRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10}\n\t\t\t\tresultRange, err = client.TSRangeWithArgs(ctx, \"t4\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 10, Value: 4}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(3))\n\n\t\t\t\topt = &redis.TSRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10, Empty: true}\n\t\t\t\tresultRange, err = client.TSRangeWithArgs(ctx, \"t4\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 10, Value: 4}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(7))\n\t\t\t})\n\n\t\t\tIt(\"should TSRevRange, TSRevRangeWithArgs\", Label(\"timeseries\", \"tsrevrange\", \"tsrevrangeWithArgs\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSAdd(ctx, \"a\", i, float64(i%7)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t}\n\t\t\t\tresult, err := client.TSRange(ctx, \"a\", 0, 200).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(100))\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\tclient.TSAdd(ctx, \"a\", i+200, float64(i%7))\n\t\t\t\t}\n\t\t\t\tresult, err = client.TSRange(ctx, \"a\", 0, 500).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(200))\n\n\t\t\t\topt := &redis.TSRevRangeOptions{Aggregator: redis.Avg, BucketDuration: 10}\n\t\t\t\tresult, err = client.TSRevRangeWithArgs(ctx, \"a\", 0, 500, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(20))\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Count: 10}\n\t\t\t\tresult, err = client.TSRevRangeWithArgs(ctx, \"a\", 0, 500, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(10))\n\n\t\t\t\tfts := make([]int, 0)\n\t\t\t\tfor i := 10; i < 20; i++ {\n\t\t\t\t\tfts = append(fts, i)\n\t\t\t\t}\n\t\t\t\topt = &redis.TSRevRangeOptions{FilterByTS: fts, FilterByValue: []int{1, 2}}\n\t\t\t\tresult, err = client.TSRevRangeWithArgs(ctx, \"a\", 0, 500, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: \"+\"}\n\t\t\t\tresult, err = client.TSRevRangeWithArgs(ctx, \"a\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 10, Value: 1}, {Timestamp: 0, Value: 10}}))\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: \"1\"}\n\t\t\t\tresult, err = client.TSRevRangeWithArgs(ctx, \"a\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 1, Value: 10}, {Timestamp: 0, Value: 1}}))\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Aggregator: redis.Twa, BucketDuration: 10}\n\t\t\t\tresult, err = client.TSRevRangeWithArgs(ctx, \"a\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(result).To(BeEquivalentTo([]redis.TSTimestampValue{{Timestamp: 10, Value: 3}, {Timestamp: 0, Value: 2.55}}))\n\t\t\t\t// Test Range Latest\n\t\t\t\tresultCreate, err := client.TSCreate(ctx, \"t1\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultCreate, err = client.TSCreate(ctx, \"t2\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultRule, err := client.TSCreateRule(ctx, \"t1\", \"t2\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRule).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t_, errAdd := client.TSAdd(ctx, \"t1\", 1, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t1\", 2, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t1\", 11, 7).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t1\", 13, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\tresultRange, err := client.TSRange(ctx, \"t2\", 0, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 0, Value: 4}))\n\t\t\t\topt = &redis.TSRevRangeOptions{Latest: true}\n\t\t\t\tresultRange, err = client.TSRevRangeWithArgs(ctx, \"t2\", 0, 10, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 10, Value: 8}))\n\t\t\t\tresultRange, err = client.TSRevRangeWithArgs(ctx, \"t2\", 0, 9, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 0, Value: 4}))\n\t\t\t\t// Test Bucket Timestamp\n\t\t\t\tresultCreate, err = client.TSCreate(ctx, \"t3\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 15, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 17, 4).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 51, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 73, 5).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t3\", 75, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10}\n\t\t\t\tresultRange, err = client.TSRevRangeWithArgs(ctx, \"t3\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 70, Value: 5}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(3))\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10, BucketTimestamp: \"+\"}\n\t\t\t\tresultRange, err = client.TSRevRangeWithArgs(ctx, \"t3\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 80, Value: 5}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(3))\n\t\t\t\t// Test Empty\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 15, 1).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 17, 4).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 51, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 73, 5).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\t\t\t\t_, errAdd = client.TSAdd(ctx, \"t4\", 75, 3).Result()\n\t\t\t\tExpect(errAdd).NotTo(HaveOccurred())\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10}\n\t\t\t\tresultRange, err = client.TSRevRangeWithArgs(ctx, \"t4\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 70, Value: 5}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(3))\n\n\t\t\t\topt = &redis.TSRevRangeOptions{Aggregator: redis.Max, Align: 0, BucketDuration: 10, Empty: true}\n\t\t\t\tresultRange, err = client.TSRevRangeWithArgs(ctx, \"t4\", 0, 100, opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultRange[0]).To(BeEquivalentTo(redis.TSTimestampValue{Timestamp: 70, Value: 5}))\n\t\t\t\tExpect(len(resultRange)).To(BeEquivalentTo(7))\n\t\t\t})\n\n\t\t\tIt(\"should TSMRange and TSMRangeWithArgs\", Label(\"timeseries\", \"tsmrange\", \"tsmrangeWithArgs\"), func() {\n\t\t\t\tcreateOpt := &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\", \"team\": \"ny\"}}\n\t\t\t\tresultCreate, err := client.TSCreateWithArgs(ctx, \"a\", createOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tcreateOpt = &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\", \"Taste\": \"That\", \"team\": \"sf\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"b\", createOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSAdd(ctx, \"a\", i, float64(i%7)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t_, err = client.TSAdd(ctx, \"b\", i, float64(i%11)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\n\t\t\t\tresult, err := client.TSMRange(ctx, 0, 200, []string{\"Test=This\"}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(len(result[\"a\"][1].([]interface{}))).To(BeEquivalentTo(100))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(len(result[\"a\"][2].([]interface{}))).To(BeEquivalentTo(100))\n\t\t\t\t}\n\t\t\t\t// Test Count\n\t\t\t\tmrangeOpt := &redis.TSMRangeOptions{Count: 10}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(len(result[\"a\"][1].([]interface{}))).To(BeEquivalentTo(10))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(len(result[\"a\"][2].([]interface{}))).To(BeEquivalentTo(10))\n\t\t\t\t}\n\t\t\t\t// Test Aggregation and BucketDuration\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSAdd(ctx, \"a\", i+200, float64(i%7)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{Aggregator: redis.Avg, BucketDuration: 10}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 500, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(len(result[\"a\"][1].([]interface{}))).To(BeEquivalentTo(20))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(len(result[\"a\"][2].([]interface{}))).To(BeEquivalentTo(20))\n\t\t\t\t}\n\t\t\t\t// Test WithLabels\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo([]interface{}{}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{}))\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{WithLabels: true}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(ConsistOf([]interface{}{[]interface{}{\"Test\", \"This\"}, []interface{}{\"team\", \"ny\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{\"Test\": \"This\", \"team\": \"ny\"}))\n\t\t\t\t}\n\t\t\t\t// Test SelectedLabels\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{SelectedLabels: []interface{}{\"team\"}}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][0].([]interface{})[0]).To(BeEquivalentTo([]interface{}{\"team\", \"ny\"}))\n\t\t\t\t\tExpect(result[\"b\"][0].([]interface{})[0]).To(BeEquivalentTo([]interface{}{\"team\", \"sf\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{\"team\": \"ny\"}))\n\t\t\t\t\tExpect(result[\"b\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{\"team\": \"sf\"}))\n\t\t\t\t}\n\t\t\t\t// Test FilterBy\n\t\t\t\tfts := make([]int, 0)\n\t\t\t\tfor i := 10; i < 20; i++ {\n\t\t\t\t\tfts = append(fts, i)\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{FilterByTS: fts, FilterByValue: []int{1, 2}}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][1].([]interface{})).To(BeEquivalentTo([]interface{}{[]interface{}{int64(15), \"1\"}, []interface{}{int64(16), \"2\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(15), 1.0}, []interface{}{int64(16), 2.0}}))\n\t\t\t\t}\n\t\t\t\t// Test GroupBy\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{GroupByLabel: \"Test\", Reducer: \"sum\"}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 3, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"Test=This\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), \"0\"}, []interface{}{int64(1), \"2\"}, []interface{}{int64(2), \"4\"}, []interface{}{int64(3), \"6\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"Test=This\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 0.0}, []interface{}{int64(1), 2.0}, []interface{}{int64(2), 4.0}, []interface{}{int64(3), 6.0}}))\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{GroupByLabel: \"Test\", Reducer: \"max\"}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 3, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"Test=This\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), \"0\"}, []interface{}{int64(1), \"1\"}, []interface{}{int64(2), \"2\"}, []interface{}{int64(3), \"3\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"Test=This\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 0.0}, []interface{}{int64(1), 1.0}, []interface{}{int64(2), 2.0}, []interface{}{int64(3), 3.0}}))\n\t\t\t\t}\n\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{GroupByLabel: \"team\", Reducer: \"min\"}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 3, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"team=ny\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), \"0\"}, []interface{}{int64(1), \"1\"}, []interface{}{int64(2), \"2\"}, []interface{}{int64(3), \"3\"}}))\n\t\t\t\t\tExpect(result[\"team=sf\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), \"0\"}, []interface{}{int64(1), \"1\"}, []interface{}{int64(2), \"2\"}, []interface{}{int64(3), \"3\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"team=ny\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 0.0}, []interface{}{int64(1), 1.0}, []interface{}{int64(2), 2.0}, []interface{}{int64(3), 3.0}}))\n\t\t\t\t\tExpect(result[\"team=sf\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 0.0}, []interface{}{int64(1), 1.0}, []interface{}{int64(2), 2.0}, []interface{}{int64(3), 3.0}}))\n\t\t\t\t}\n\t\t\t\t// Test Align\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: \"-\"}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 10, []string{\"team=ny\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), \"10\"}, []interface{}{int64(10), \"1\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 10.0}, []interface{}{int64(10), 1.0}}))\n\t\t\t\t}\n\n\t\t\t\tmrangeOpt = &redis.TSMRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: 5}\n\t\t\t\tresult, err = client.TSMRangeWithArgs(ctx, 0, 10, []string{\"team=ny\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), \"5\"}, []interface{}{int64(5), \"6\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 5.0}, []interface{}{int64(5), 6.0}}))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tIt(\"should TSMRangeWithArgs Latest\", Label(\"timeseries\", \"tsmrangeWithArgs\", \"tsmrangelatest\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tresultCreate, err := client.TSCreate(ctx, \"a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt := &redis.TSOptions{Labels: map[string]string{\"is_compaction\": \"true\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"b\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultCreate, err = client.TSCreate(ctx, \"c\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"is_compaction\": \"true\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"d\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultCreateRule, err := client.TSCreateRule(ctx, \"a\", \"b\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreateRule).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultCreateRule, err = client.TSCreateRule(ctx, \"c\", \"d\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreateRule).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 1, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 2, 3).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 11, 7).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 13, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 1, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 2, 3).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 11, 7).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 13, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tmrangeOpt := &redis.TSMRangeOptions{Latest: true}\n\t\t\t\tresult, err := client.TSMRangeWithArgs(ctx, 0, 10, []string{\"is_compaction=true\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"b\"][1]).To(ConsistOf([]interface{}{int64(0), \"4\"}, []interface{}{int64(10), \"8\"}))\n\t\t\t\t\tExpect(result[\"d\"][1]).To(ConsistOf([]interface{}{int64(0), \"4\"}, []interface{}{int64(10), \"8\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"b\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 4.0}, []interface{}{int64(10), 8.0}}))\n\t\t\t\t\tExpect(result[\"d\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(0), 4.0}, []interface{}{int64(10), 8.0}}))\n\t\t\t\t}\n\t\t\t})\n\t\t\tIt(\"should TSMRevRange and TSMRevRangeWithArgs\", Label(\"timeseries\", \"tsmrevrange\", \"tsmrevrangeWithArgs\"), func() {\n\t\t\t\tcreateOpt := &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\", \"team\": \"ny\"}}\n\t\t\t\tresultCreate, err := client.TSCreateWithArgs(ctx, \"a\", createOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tcreateOpt = &redis.TSOptions{Labels: map[string]string{\"Test\": \"This\", \"Taste\": \"That\", \"team\": \"sf\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"b\", createOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSAdd(ctx, \"a\", i, float64(i%7)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t\t_, err = client.TSAdd(ctx, \"b\", i, float64(i%11)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tresult, err := client.TSMRevRange(ctx, 0, 200, []string{\"Test=This\"}).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(len(result[\"a\"][1].([]interface{}))).To(BeEquivalentTo(100))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(len(result[\"a\"][2].([]interface{}))).To(BeEquivalentTo(100))\n\t\t\t\t}\n\t\t\t\t// Test Count\n\t\t\t\tmrangeOpt := &redis.TSMRevRangeOptions{Count: 10}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(len(result[\"a\"][1].([]interface{}))).To(BeEquivalentTo(10))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(len(result[\"a\"][2].([]interface{}))).To(BeEquivalentTo(10))\n\t\t\t\t}\n\t\t\t\t// Test Aggregation and BucketDuration\n\t\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\t\t_, err := client.TSAdd(ctx, \"a\", i+200, float64(i%7)).Result()\n\t\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{Aggregator: redis.Avg, BucketDuration: 10}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 500, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(len(result[\"a\"][1].([]interface{}))).To(BeEquivalentTo(20))\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo([]interface{}{}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(len(result[\"a\"][2].([]interface{}))).To(BeEquivalentTo(20))\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{}))\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{WithLabels: true}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(ConsistOf([]interface{}{[]interface{}{\"Test\", \"This\"}, []interface{}{\"team\", \"ny\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{\"Test\": \"This\", \"team\": \"ny\"}))\n\t\t\t\t}\n\t\t\t\t// Test SelectedLabels\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{SelectedLabels: []interface{}{\"team\"}}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][0].([]interface{})[0]).To(BeEquivalentTo([]interface{}{\"team\", \"ny\"}))\n\t\t\t\t\tExpect(result[\"b\"][0].([]interface{})[0]).To(BeEquivalentTo([]interface{}{\"team\", \"sf\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{\"team\": \"ny\"}))\n\t\t\t\t\tExpect(result[\"b\"][0]).To(BeEquivalentTo(map[interface{}]interface{}{\"team\": \"sf\"}))\n\t\t\t\t}\n\t\t\t\t// Test FilterBy\n\t\t\t\tfts := make([]int, 0)\n\t\t\t\tfor i := 10; i < 20; i++ {\n\t\t\t\t\tfts = append(fts, i)\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{FilterByTS: fts, FilterByValue: []int{1, 2}}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 200, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][1].([]interface{})).To(ConsistOf([]interface{}{int64(16), \"2\"}, []interface{}{int64(15), \"1\"}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(16), 2.0}, []interface{}{int64(15), 1.0}}))\n\t\t\t\t}\n\t\t\t\t// Test GroupBy\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{GroupByLabel: \"Test\", Reducer: \"sum\"}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 3, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"Test=This\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), \"6\"}, []interface{}{int64(2), \"4\"}, []interface{}{int64(1), \"2\"}, []interface{}{int64(0), \"0\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"Test=This\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), 6.0}, []interface{}{int64(2), 4.0}, []interface{}{int64(1), 2.0}, []interface{}{int64(0), 0.0}}))\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{GroupByLabel: \"Test\", Reducer: \"max\"}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 3, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"Test=This\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), \"3\"}, []interface{}{int64(2), \"2\"}, []interface{}{int64(1), \"1\"}, []interface{}{int64(0), \"0\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"Test=This\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), 3.0}, []interface{}{int64(2), 2.0}, []interface{}{int64(1), 1.0}, []interface{}{int64(0), 0.0}}))\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{GroupByLabel: \"team\", Reducer: \"min\"}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 3, []string{\"Test=This\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(len(result)).To(BeEquivalentTo(2))\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"team=ny\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), \"3\"}, []interface{}{int64(2), \"2\"}, []interface{}{int64(1), \"1\"}, []interface{}{int64(0), \"0\"}}))\n\t\t\t\t\tExpect(result[\"team=sf\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), \"3\"}, []interface{}{int64(2), \"2\"}, []interface{}{int64(1), \"1\"}, []interface{}{int64(0), \"0\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"team=ny\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), 3.0}, []interface{}{int64(2), 2.0}, []interface{}{int64(1), 1.0}, []interface{}{int64(0), 0.0}}))\n\t\t\t\t\tExpect(result[\"team=sf\"][3]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(3), 3.0}, []interface{}{int64(2), 2.0}, []interface{}{int64(1), 1.0}, []interface{}{int64(0), 0.0}}))\n\t\t\t\t}\n\t\t\t\t// Test Align\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: \"-\"}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 10, []string{\"team=ny\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(10), \"1\"}, []interface{}{int64(0), \"10\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(10), 1.0}, []interface{}{int64(0), 10.0}}))\n\t\t\t\t}\n\t\t\t\tmrangeOpt = &redis.TSMRevRangeOptions{Aggregator: redis.Count, BucketDuration: 10, Align: 1}\n\t\t\t\tresult, err = client.TSMRevRangeWithArgs(ctx, 0, 10, []string{\"team=ny\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"a\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(1), \"10\"}, []interface{}{int64(0), \"1\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"a\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(1), 10.0}, []interface{}{int64(0), 1.0}}))\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tIt(\"should TSMRevRangeWithArgs Latest\", Label(\"timeseries\", \"tsmrevrangeWithArgs\", \"tsmrevrangelatest\", \"NonRedisEnterprise\"), func() {\n\t\t\t\tresultCreate, err := client.TSCreate(ctx, \"a\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt := &redis.TSOptions{Labels: map[string]string{\"is_compaction\": \"true\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"b\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultCreate, err = client.TSCreate(ctx, \"c\").Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\t\t\t\topt = &redis.TSOptions{Labels: map[string]string{\"is_compaction\": \"true\"}}\n\t\t\t\tresultCreate, err = client.TSCreateWithArgs(ctx, \"d\", opt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreate).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\tresultCreateRule, err := client.TSCreateRule(ctx, \"a\", \"b\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreateRule).To(BeEquivalentTo(\"OK\"))\n\t\t\t\tresultCreateRule, err = client.TSCreateRule(ctx, \"c\", \"d\", redis.Sum, 10).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(resultCreateRule).To(BeEquivalentTo(\"OK\"))\n\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 1, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 2, 3).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 11, 7).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"a\", 13, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 1, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 2, 3).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 11, 7).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\t_, err = client.TSAdd(ctx, \"c\", 13, 1).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tmrangeOpt := &redis.TSMRevRangeOptions{Latest: true}\n\t\t\t\tresult, err := client.TSMRevRangeWithArgs(ctx, 0, 10, []string{\"is_compaction=true\"}, mrangeOpt).Result()\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tif client.Options().Protocol == 2 {\n\t\t\t\t\tExpect(result[\"b\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(10), \"8\"}, []interface{}{int64(0), \"4\"}}))\n\t\t\t\t\tExpect(result[\"d\"][1]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(10), \"8\"}, []interface{}{int64(0), \"4\"}}))\n\t\t\t\t} else {\n\t\t\t\t\tExpect(result[\"b\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(10), 8.0}, []interface{}{int64(0), 4.0}}))\n\t\t\t\t\tExpect(result[\"d\"][2]).To(BeEquivalentTo([]interface{}{[]interface{}{int64(10), 8.0}, []interface{}{int64(0), 4.0}}))\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n})\n"
        },
        {
          "name": "tx.go",
          "type": "blob",
          "size": 3.9609375,
          "content": "package redis\n\nimport (\n\t\"context\"\n\n\t\"github.com/redis/go-redis/v9/internal/pool\"\n\t\"github.com/redis/go-redis/v9/internal/proto\"\n)\n\n// TxFailedErr transaction redis failed.\nconst TxFailedErr = proto.RedisError(\"redis: transaction failed\")\n\n// Tx implements Redis transactions as described in\n// http://redis.io/topics/transactions. It's NOT safe for concurrent use\n// by multiple goroutines, because Exec resets list of watched keys.\n//\n// If you don't need WATCH, use Pipeline instead.\ntype Tx struct {\n\tbaseClient\n\tcmdable\n\tstatefulCmdable\n\thooksMixin\n}\n\nfunc (c *Client) newTx() *Tx {\n\ttx := Tx{\n\t\tbaseClient: baseClient{\n\t\t\topt:      c.opt,\n\t\t\tconnPool: pool.NewStickyConnPool(c.connPool),\n\t\t},\n\t\thooksMixin: c.hooksMixin.clone(),\n\t}\n\ttx.init()\n\treturn &tx\n}\n\nfunc (c *Tx) init() {\n\tc.cmdable = c.Process\n\tc.statefulCmdable = c.Process\n\n\tc.initHooks(hooks{\n\t\tdial:       c.baseClient.dial,\n\t\tprocess:    c.baseClient.process,\n\t\tpipeline:   c.baseClient.processPipeline,\n\t\ttxPipeline: c.baseClient.processTxPipeline,\n\t})\n}\n\nfunc (c *Tx) Process(ctx context.Context, cmd Cmder) error {\n\terr := c.processHook(ctx, cmd)\n\tcmd.SetErr(err)\n\treturn err\n}\n\n// Watch prepares a transaction and marks the keys to be watched\n// for conditional execution if there are any keys.\n//\n// The transaction is automatically closed when fn exits.\nfunc (c *Client) Watch(ctx context.Context, fn func(*Tx) error, keys ...string) error {\n\ttx := c.newTx()\n\tdefer tx.Close(ctx)\n\tif len(keys) > 0 {\n\t\tif err := tx.Watch(ctx, keys...).Err(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn fn(tx)\n}\n\n// Close closes the transaction, releasing any open resources.\nfunc (c *Tx) Close(ctx context.Context) error {\n\t_ = c.Unwatch(ctx).Err()\n\treturn c.baseClient.Close()\n}\n\n// Watch marks the keys to be watched for conditional execution\n// of a transaction.\nfunc (c *Tx) Watch(ctx context.Context, keys ...string) *StatusCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"watch\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Unwatch flushes all the previously watched keys for a transaction.\nfunc (c *Tx) Unwatch(ctx context.Context, keys ...string) *StatusCmd {\n\targs := make([]interface{}, 1+len(keys))\n\targs[0] = \"unwatch\"\n\tfor i, key := range keys {\n\t\targs[1+i] = key\n\t}\n\tcmd := NewStatusCmd(ctx, args...)\n\t_ = c.Process(ctx, cmd)\n\treturn cmd\n}\n\n// Pipeline creates a pipeline. Usually it is more convenient to use Pipelined.\nfunc (c *Tx) Pipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: func(ctx context.Context, cmds []Cmder) error {\n\t\t\treturn c.processPipelineHook(ctx, cmds)\n\t\t},\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\n// Pipelined executes commands queued in the fn outside of the transaction.\n// Use TxPipelined if you need transactional behavior.\nfunc (c *Tx) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.Pipeline().Pipelined(ctx, fn)\n}\n\n// TxPipelined executes commands queued in the fn in the transaction.\n//\n// When using WATCH, EXEC will execute commands only if the watched keys\n// were not modified, allowing for a check-and-set mechanism.\n//\n// Exec always returns list of commands. If transaction fails\n// TxFailedErr is returned. Otherwise Exec returns an error of the first\n// failed command or nil.\nfunc (c *Tx) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {\n\treturn c.TxPipeline().Pipelined(ctx, fn)\n}\n\n// TxPipeline creates a pipeline. Usually it is more convenient to use TxPipelined.\nfunc (c *Tx) TxPipeline() Pipeliner {\n\tpipe := Pipeline{\n\t\texec: func(ctx context.Context, cmds []Cmder) error {\n\t\t\tcmds = wrapMultiExec(ctx, cmds)\n\t\t\treturn c.processTxPipelineHook(ctx, cmds)\n\t\t},\n\t}\n\tpipe.init()\n\treturn &pipe\n}\n\nfunc wrapMultiExec(ctx context.Context, cmds []Cmder) []Cmder {\n\tif len(cmds) == 0 {\n\t\tpanic(\"not reached\")\n\t}\n\tcmdsCopy := make([]Cmder, len(cmds)+2)\n\tcmdsCopy[0] = NewStatusCmd(ctx, \"multi\")\n\tcopy(cmdsCopy[1:], cmds)\n\tcmdsCopy[len(cmdsCopy)-1] = NewSliceCmd(ctx, \"exec\")\n\treturn cmdsCopy\n}\n"
        },
        {
          "name": "tx_test.go",
          "type": "blob",
          "size": 3.3623046875,
          "content": "package redis_test\n\nimport (\n\t\"context\"\n\t\"strconv\"\n\t\"sync\"\n\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"Tx\", func() {\n\tvar client *redis.Client\n\n\tBeforeEach(func() {\n\t\tclient = redis.NewClient(redisOptions())\n\t\tExpect(client.FlushDB(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tAfterEach(func() {\n\t\tExpect(client.Close()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should Watch\", func() {\n\t\tvar incr func(string) error\n\n\t\t// Transactionally increments key using GET and SET commands.\n\t\tincr = func(key string) error {\n\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\tn, err := tx.Get(ctx, key).Int64()\n\t\t\t\tif err != nil && err != redis.Nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t_, err = tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tpipe.Set(ctx, key, strconv.FormatInt(n+1, 10), 0)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\treturn err\n\t\t\t}, key)\n\t\t\tif err == redis.TxFailedErr {\n\t\t\t\treturn incr(key)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tvar wg sync.WaitGroup\n\t\tfor i := 0; i < 100; i++ {\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer GinkgoRecover()\n\t\t\t\tdefer wg.Done()\n\n\t\t\t\terr := incr(\"key\")\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\tn, err := client.Get(ctx, \"key\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(n).To(Equal(int64(100)))\n\t})\n\n\tIt(\"should discard\", Label(\"NonRedisEnterprise\"), func() {\n\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\tcmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tpipe.Set(ctx, \"key1\", \"hello1\", 0)\n\t\t\t\tpipe.Discard()\n\t\t\t\tpipe.Set(ctx, \"key2\", \"hello2\", 0)\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(cmds).To(HaveLen(1))\n\t\t\treturn err\n\t\t}, \"key1\", \"key2\")\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tget := client.Get(ctx, \"key1\")\n\t\tExpect(get.Err()).To(Equal(redis.Nil))\n\t\tExpect(get.Val()).To(Equal(\"\"))\n\n\t\tget = client.Get(ctx, \"key2\")\n\t\tExpect(get.Err()).NotTo(HaveOccurred())\n\t\tExpect(get.Val()).To(Equal(\"hello2\"))\n\t})\n\n\tIt(\"returns no error when there are no commands\", func() {\n\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t_, err := tx.TxPipelined(ctx, func(redis.Pipeliner) error { return nil })\n\t\t\treturn err\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tv, err := client.Ping(ctx).Result()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(v).To(Equal(\"PONG\"))\n\t})\n\n\tIt(\"should exec bulks\", func() {\n\t\tconst N = 20000\n\n\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\tcmds, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\tfor i := 0; i < N; i++ {\n\t\t\t\t\tpipe.Incr(ctx, \"key\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\tExpect(len(cmds)).To(Equal(N))\n\t\t\tfor _, cmd := range cmds {\n\t\t\t\tExpect(cmd.Err()).NotTo(HaveOccurred())\n\t\t\t}\n\t\t\treturn err\n\t\t})\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tnum, err := client.Get(ctx, \"key\").Int64()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t\tExpect(num).To(Equal(int64(N)))\n\t})\n\n\tIt(\"should recover from bad connection\", func() {\n\t\t// Put bad connection in the pool.\n\t\tcn, err := client.Pool().Get(context.Background())\n\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\tcn.SetNetConn(&badConn{})\n\t\tclient.Pool().Put(ctx, cn)\n\n\t\tdo := func() error {\n\t\t\terr := client.Watch(ctx, func(tx *redis.Tx) error {\n\t\t\t\t_, err := tx.TxPipelined(ctx, func(pipe redis.Pipeliner) error {\n\t\t\t\t\tpipe.Ping(ctx)\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\treturn err\n\t\t\t})\n\t\t\treturn err\n\t\t}\n\n\t\terr = do()\n\t\tExpect(err).NotTo(HaveOccurred())\n\t})\n})\n"
        },
        {
          "name": "universal.go",
          "type": "blob",
          "size": 6.5322265625,
          "content": "package redis\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net\"\n\t\"time\"\n)\n\n// UniversalOptions information is required by UniversalClient to establish\n// connections.\ntype UniversalOptions struct {\n\t// Either a single address or a seed list of host:port addresses\n\t// of cluster/sentinel nodes.\n\tAddrs []string\n\n\t// ClientName will execute the `CLIENT SETNAME ClientName` command for each conn.\n\tClientName string\n\n\t// Database to be selected after connecting to the server.\n\t// Only single-node and failover clients.\n\tDB int\n\n\t// Common options.\n\n\tDialer    func(ctx context.Context, network, addr string) (net.Conn, error)\n\tOnConnect func(ctx context.Context, cn *Conn) error\n\n\tProtocol         int\n\tUsername         string\n\tPassword         string\n\tSentinelUsername string\n\tSentinelPassword string\n\n\tMaxRetries      int\n\tMinRetryBackoff time.Duration\n\tMaxRetryBackoff time.Duration\n\n\tDialTimeout           time.Duration\n\tReadTimeout           time.Duration\n\tWriteTimeout          time.Duration\n\tContextTimeoutEnabled bool\n\n\t// PoolFIFO uses FIFO mode for each node connection pool GET/PUT (default LIFO).\n\tPoolFIFO bool\n\n\tPoolSize        int\n\tPoolTimeout     time.Duration\n\tMinIdleConns    int\n\tMaxIdleConns    int\n\tMaxActiveConns  int\n\tConnMaxIdleTime time.Duration\n\tConnMaxLifetime time.Duration\n\n\tTLSConfig *tls.Config\n\n\t// Only cluster clients.\n\n\tMaxRedirects   int\n\tReadOnly       bool\n\tRouteByLatency bool\n\tRouteRandomly  bool\n\n\t// The sentinel master name.\n\t// Only failover clients.\n\n\tMasterName string\n\n\tDisableIndentity bool\n\tIdentitySuffix   string\n\tUnstableResp3    bool\n}\n\n// Cluster returns cluster options created from the universal options.\nfunc (o *UniversalOptions) Cluster() *ClusterOptions {\n\tif len(o.Addrs) == 0 {\n\t\to.Addrs = []string{\"127.0.0.1:6379\"}\n\t}\n\n\treturn &ClusterOptions{\n\t\tAddrs:      o.Addrs,\n\t\tClientName: o.ClientName,\n\t\tDialer:     o.Dialer,\n\t\tOnConnect:  o.OnConnect,\n\n\t\tProtocol: o.Protocol,\n\t\tUsername: o.Username,\n\t\tPassword: o.Password,\n\n\t\tMaxRedirects:   o.MaxRedirects,\n\t\tReadOnly:       o.ReadOnly,\n\t\tRouteByLatency: o.RouteByLatency,\n\t\tRouteRandomly:  o.RouteRandomly,\n\n\t\tMaxRetries:      o.MaxRetries,\n\t\tMinRetryBackoff: o.MinRetryBackoff,\n\t\tMaxRetryBackoff: o.MaxRetryBackoff,\n\n\t\tDialTimeout:           o.DialTimeout,\n\t\tReadTimeout:           o.ReadTimeout,\n\t\tWriteTimeout:          o.WriteTimeout,\n\t\tContextTimeoutEnabled: o.ContextTimeoutEnabled,\n\n\t\tPoolFIFO: o.PoolFIFO,\n\n\t\tPoolSize:        o.PoolSize,\n\t\tPoolTimeout:     o.PoolTimeout,\n\t\tMinIdleConns:    o.MinIdleConns,\n\t\tMaxIdleConns:    o.MaxIdleConns,\n\t\tMaxActiveConns:  o.MaxActiveConns,\n\t\tConnMaxIdleTime: o.ConnMaxIdleTime,\n\t\tConnMaxLifetime: o.ConnMaxLifetime,\n\n\t\tTLSConfig: o.TLSConfig,\n\n\t\tDisableIndentity: o.DisableIndentity,\n\t\tIdentitySuffix:   o.IdentitySuffix,\n\t}\n}\n\n// Failover returns failover options created from the universal options.\nfunc (o *UniversalOptions) Failover() *FailoverOptions {\n\tif len(o.Addrs) == 0 {\n\t\to.Addrs = []string{\"127.0.0.1:26379\"}\n\t}\n\n\treturn &FailoverOptions{\n\t\tSentinelAddrs: o.Addrs,\n\t\tMasterName:    o.MasterName,\n\t\tClientName:    o.ClientName,\n\n\t\tDialer:    o.Dialer,\n\t\tOnConnect: o.OnConnect,\n\n\t\tDB:               o.DB,\n\t\tProtocol:         o.Protocol,\n\t\tUsername:         o.Username,\n\t\tPassword:         o.Password,\n\t\tSentinelUsername: o.SentinelUsername,\n\t\tSentinelPassword: o.SentinelPassword,\n\n\t\tMaxRetries:      o.MaxRetries,\n\t\tMinRetryBackoff: o.MinRetryBackoff,\n\t\tMaxRetryBackoff: o.MaxRetryBackoff,\n\n\t\tDialTimeout:           o.DialTimeout,\n\t\tReadTimeout:           o.ReadTimeout,\n\t\tWriteTimeout:          o.WriteTimeout,\n\t\tContextTimeoutEnabled: o.ContextTimeoutEnabled,\n\n\t\tPoolFIFO:        o.PoolFIFO,\n\t\tPoolSize:        o.PoolSize,\n\t\tPoolTimeout:     o.PoolTimeout,\n\t\tMinIdleConns:    o.MinIdleConns,\n\t\tMaxIdleConns:    o.MaxIdleConns,\n\t\tMaxActiveConns:  o.MaxActiveConns,\n\t\tConnMaxIdleTime: o.ConnMaxIdleTime,\n\t\tConnMaxLifetime: o.ConnMaxLifetime,\n\n\t\tTLSConfig: o.TLSConfig,\n\n\t\tDisableIndentity: o.DisableIndentity,\n\t\tIdentitySuffix:   o.IdentitySuffix,\n\t\tUnstableResp3:    o.UnstableResp3,\n\t}\n}\n\n// Simple returns basic options created from the universal options.\nfunc (o *UniversalOptions) Simple() *Options {\n\taddr := \"127.0.0.1:6379\"\n\tif len(o.Addrs) > 0 {\n\t\taddr = o.Addrs[0]\n\t}\n\n\treturn &Options{\n\t\tAddr:       addr,\n\t\tClientName: o.ClientName,\n\t\tDialer:     o.Dialer,\n\t\tOnConnect:  o.OnConnect,\n\n\t\tDB:       o.DB,\n\t\tProtocol: o.Protocol,\n\t\tUsername: o.Username,\n\t\tPassword: o.Password,\n\n\t\tMaxRetries:      o.MaxRetries,\n\t\tMinRetryBackoff: o.MinRetryBackoff,\n\t\tMaxRetryBackoff: o.MaxRetryBackoff,\n\n\t\tDialTimeout:           o.DialTimeout,\n\t\tReadTimeout:           o.ReadTimeout,\n\t\tWriteTimeout:          o.WriteTimeout,\n\t\tContextTimeoutEnabled: o.ContextTimeoutEnabled,\n\n\t\tPoolFIFO:        o.PoolFIFO,\n\t\tPoolSize:        o.PoolSize,\n\t\tPoolTimeout:     o.PoolTimeout,\n\t\tMinIdleConns:    o.MinIdleConns,\n\t\tMaxIdleConns:    o.MaxIdleConns,\n\t\tMaxActiveConns:  o.MaxActiveConns,\n\t\tConnMaxIdleTime: o.ConnMaxIdleTime,\n\t\tConnMaxLifetime: o.ConnMaxLifetime,\n\n\t\tTLSConfig: o.TLSConfig,\n\n\t\tDisableIndentity: o.DisableIndentity,\n\t\tIdentitySuffix:   o.IdentitySuffix,\n\t\tUnstableResp3:    o.UnstableResp3,\n\t}\n}\n\n// --------------------------------------------------------------------\n\n// UniversalClient is an abstract client which - based on the provided options -\n// represents either a ClusterClient, a FailoverClient, or a single-node Client.\n// This can be useful for testing cluster-specific applications locally or having different\n// clients in different environments.\ntype UniversalClient interface {\n\tCmdable\n\tAddHook(Hook)\n\tWatch(ctx context.Context, fn func(*Tx) error, keys ...string) error\n\tDo(ctx context.Context, args ...interface{}) *Cmd\n\tProcess(ctx context.Context, cmd Cmder) error\n\tSubscribe(ctx context.Context, channels ...string) *PubSub\n\tPSubscribe(ctx context.Context, channels ...string) *PubSub\n\tSSubscribe(ctx context.Context, channels ...string) *PubSub\n\tClose() error\n\tPoolStats() *PoolStats\n}\n\nvar (\n\t_ UniversalClient = (*Client)(nil)\n\t_ UniversalClient = (*ClusterClient)(nil)\n\t_ UniversalClient = (*Ring)(nil)\n)\n\n// NewUniversalClient returns a new multi client. The type of the returned client depends\n// on the following conditions:\n//\n// 1. If the MasterName option is specified, a sentinel-backed FailoverClient is returned.\n// 2. if the number of Addrs is two or more, a ClusterClient is returned.\n// 3. Otherwise, a single-node Client is returned.\nfunc NewUniversalClient(opts *UniversalOptions) UniversalClient {\n\tif opts.MasterName != \"\" {\n\t\treturn NewFailoverClient(opts.Failover())\n\t} else if len(opts.Addrs) > 1 {\n\t\treturn NewClusterClient(opts.Cluster())\n\t}\n\treturn NewClient(opts.Simple())\n}\n"
        },
        {
          "name": "universal_test.go",
          "type": "blob",
          "size": 0.958984375,
          "content": "package redis_test\n\nimport (\n\t. \"github.com/bsm/ginkgo/v2\"\n\t. \"github.com/bsm/gomega\"\n\n\t\"github.com/redis/go-redis/v9\"\n)\n\nvar _ = Describe(\"UniversalClient\", func() {\n\tvar client redis.UniversalClient\n\n\tAfterEach(func() {\n\t\tif client != nil {\n\t\t\tExpect(client.Close()).To(Succeed())\n\t\t}\n\t})\n\n\tIt(\"should connect to failover servers\", func() {\n\t\tSkip(\"Flaky Test\")\n\t\tclient = redis.NewUniversalClient(&redis.UniversalOptions{\n\t\t\tMasterName: sentinelName,\n\t\t\tAddrs:      sentinelAddrs,\n\t\t})\n\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should connect to simple servers\", func() {\n\t\tclient = redis.NewUniversalClient(&redis.UniversalOptions{\n\t\t\tAddrs: []string{redisAddr},\n\t\t})\n\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t})\n\n\tIt(\"should connect to clusters\", Label(\"NonRedisEnterprise\"), func() {\n\t\tclient = redis.NewUniversalClient(&redis.UniversalOptions{\n\t\t\tAddrs: cluster.addrs(),\n\t\t})\n\t\tExpect(client.Ping(ctx).Err()).NotTo(HaveOccurred())\n\t})\n})\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.09765625,
          "content": "package redis\n\n// Version is the current release version.\nfunc Version() string {\n\treturn \"9.6.2\"\n}\n"
        }
      ]
    }
  ]
}