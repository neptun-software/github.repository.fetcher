{
  "metadata": {
    "timestamp": 1736567856399,
    "page": 12,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tsenart/vegeta",
      "stars": 23796,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.328125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\nvegeta\nvegeta.test\nvegeta-*.tar.gz\nlib/lib.test\ndist\nvendor\n\n*.gob\n*.lz\n\n.DS_Store\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 2.48828125,
          "content": "2018-05-18: v7.0.0\n  Include response body in hit results (#279)\n  Added support for h2c requests (HTTP/2 without TLS) (#261)\n  Prevent \"null\" Metrics.Errors JSON encoding (#277)\n  Add option to override HTTP Proxy on Attacker (#234)\n\n2017-03-19: v6.3.0\n  Mark responses as success in no redirect following mode (#222)\n\n2017-03-04: v6.2.0\n  Allow any upper-case ASCII word to be an HTTP method (#217)\n  Correctly compute Metrics.Rate with sub-second duration results (#208)\n\n2016-08-26: v6.1.1\n  Respect case sensitivity in target file header names (#195, #191)\n\n2016-04-03: v6.1.0\n  Add HTTP2 support\n\n2015-11-27: v6.0.0\n  Insecure attack flag (#160)\n  Client certificates (#156)\n  Infinite attacks (#155)\n  Allow empty lines between targets (#147)\n\n2015-09-19: v5.9.0\n  Bounded memory streaming reporters (#136)\n\n2015-09-04: v5.8.1\n  Fix support for DELETE methods in targets\n\n2015-08-11: v5.8.0\n  Change reporters quantile estimation method to match R's 8th type.\n\n2015-05-23: v5.7.1\n  Revert end-to-end attack timeout change\n\n2015-05-23: v5.7.0\n  Allow case sensitve headers in attacks\n\n2015-04-15: v5.6.3\n  Expose connections flag in the attack command\n  Add global cpu and heap profiling flags\n  Measure actual attack rate and print it in relevant reporters\n  Major performance improvements that allow much higher attack rates\n\n2015-04-02: v5.6.2\n  Update dygraph to latest version\n  Improve plot reporter screenshot rendering by using html2canvas.js\n  Improve plot reporter performance\n\n2015-03-23: v5.6.1\n  Allow spaces in hist reporter flag format\n\n2015-03-12: v5.6.0\n  Set default dumper to \"json\" in the dump command.\n  Add --version to global vegeta command flags.\n  Fix response body leak regression introduced in v5.5.3.\n\n2015-03-11: v5.5.3\n  Always read response bodies for each request.\n  Homebrew install instructions.\n\n2015-01-3: v5.5.2\n  Refactor core request logic and simplify tests with a 4x speedup.\n\n2015-01-2: v5.5.1\n  Treat bad status codes as errors.\n\n2014-11-21: v5.5.0\n  Implement dump command with CSV and JSON record format.\n  Optionally ignore redirects and treat them as successes.\n\n2014-11-16: v5.4.0\n  Add histogram reporter to the report command.\n\n2014-11-16: v5.3.0\n  Add support for extended targets dsl that supports per-target headers and body.\n  Target file comments support has been removed.\n\n2014-11-7: v5.2.0\n  Don't treat 3xx status codes as errors.\n  Add -keepalive flag to the attack command.\n\n2014-11-3: v5.1.1\n  Add FreeBSD and Windows releases.\n  Fix non termination bug in the report command. #85\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.298828125,
          "content": "FROM golang:1.20-alpine3.18 AS BUILD\n\nRUN apk add make build-base git\n\nWORKDIR /vegeta\n\n# cache dependencies\nADD go.mod /vegeta\nADD go.sum /vegeta\nRUN go mod download\n\nADD . /vegeta\n\nRUN make generate\nRUN make vegeta\n\nFROM alpine:3.18.0\n\nCOPY --from=BUILD /vegeta/vegeta /bin/vegeta\n\nENTRYPOINT [\"vegeta\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0595703125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013-2023 Tom√°s Senart\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.544921875,
          "content": "COMMIT=$(shell git rev-parse HEAD)\nVERSION=$(shell git describe --tags --exact-match --always)\nDATE=$(shell date +'%FT%TZ%z')\n\nvegeta: generate\n\tCGO_ENABLED=0 go build -v -a -tags=netgo \\\n  \t-ldflags '-s -w -extldflags \"-static\" -X main.Version=$(VERSION) -X main.Commit=$(COMMIT) -X main.Date=$(DATE)'\n\ngenerate: GOARCH := $(shell go env GOHOSTARCH)\ngenerate: GOOS := $(shell go env GOHOSTOS)\ngenerate:\n\tgo install github.com/mailru/easyjson/...@latest\n\tgo get github.com/shurcooL/vfsgen\n\tgo install github.com/shurcooL/vfsgen/...@latest\n\tgo generate ./...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 31.021484375,
          "content": "# Vegeta [![Build Status](https://github.com/tsenart/vegeta/workflows/CI/badge.svg)](https://github.com/tsenart/vegeta/actions) [![Go Report Card](https://goreportcard.com/badge/github.com/tsenart/vegeta)](https://goreportcard.com/report/github.com/tsenart/vegeta) [![PkgGoDev](https://pkg.go.dev/badge/github.com/tsenart/vegeta/v12/lib)](https://pkg.go.dev/github.com/tsenart/vegeta/v12/lib) [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/tsenart/vegeta?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge) [![Donate](https://img.shields.io/badge/donate-bitcoin-yellow.svg)](#donate)\n\nVegeta is a versatile HTTP load testing tool built out of a need to drill\nHTTP services with a constant request rate. [It's over 9000!](https://en.wikipedia.org/wiki/It's_Over_9000)\n\n![Vegeta](http://fc09.deviantart.net/fs49/i/2009/198/c/c/ssj2_vegeta_by_trunks24.jpg)\n\n## Features\n\n- Usable as a command line tool and a Go library.\n- CLI designed with UNIX composability in mind.\n- [Avoids](https://github.com/tsenart/vegeta/pull/92/files#r20198929) nasty [Coordinated Omission](http://highscalability.com/blog/2015/10/5/your-load-generator-is-probably-lying-to-you-take-the-red-pi.html).\n- Extensive reporting functionality.\n- Simple to use for [distributed load testing](https://kubernetes.io/blog/2015/11/one-million-requests-per-second-dependable-and-dynamic-distributed-systems-at-scale/).\n- Easy to install and run (static binary, package managers, etc).\n\n## Install\n\n### Pre-compiled executables\n\nGet them [here](http://github.com/tsenart/vegeta/releases).\n\n### macOS\n\nYou can install Vegeta using the [Homebrew](https://github.com/Homebrew/homebrew/):\n\n```shell\n$ brew update && brew install vegeta\n```\n\nOr with [MacPorts](https://www.macports.org/):\n\n```shell\n$ port install vegeta\n```\n\n### Arch Linux\n\n```shell\n$ pacman -S vegeta\n```\n\n### FreeBSD\n\nOn FreeBSD you can install Vegeta with the built in package manager because there is a [Vegeta Package](https://www.freshports.org/benchmarks/vegeta) available.\n\n```shell\n$ pkg install vegeta\n```\n\n### Source\n\n```shell\ngit clone https://github.com/tsenart/vegeta\ncd vegeta\nmake vegeta\nmv vegeta ~/bin # Or elsewhere, up to you.\n```\n\n## Versioning\n\nBoth the library and the CLI are versioned with [SemVer v2.0.0](https://semver.org/spec/v2.0.0.html).\n\nAfter [v8.0.0](https://github.com/tsenart/vegeta/tree/v8.0.0), the two components\nare versioned separately to better isolate breaking changes to each.\n\nCLI releases are tagged with `cli/vMAJOR.MINOR.PATCH` and published on the [GitHub releases page](https://github.com/tsenart/vegeta/releases).\nAs for the library, new versions are tagged with both `lib/vMAJOR.MINOR.PATCH` and `vMAJOR.MINOR.PATCH`.\nThe latter tag is required for compatibility with `go mod`.\n\n## Contributing\n\nSee [CONTRIBUTING.md](.github/CONTRIBUTING.md).\n\n## Usage manual\n\n```console\nUsage: vegeta [global flags] <command> [command flags]\n\nglobal flags:\n  -cpus int\n    \tNumber of CPUs to use (default = number of cpus)\n  -profile string\n    \tEnable profiling of [cpu, heap]\n  -version\n    \tPrint version and exit\n\nattack command:\n  -body string\n    \tRequests body file\n  -cert string\n    \tTLS client PEM encoded certificate file\n  -chunked\n    \tSend body with chunked transfer encoding\n  -connect-to value\n    \tA mapping of (ip|host):port to use instead of a target URL's (ip|host):port. Can be repeated multiple times.\n    \tIdentical src:port with different dst:port will round-robin over the different dst:port pairs.\n    \tExample: google.com:80:localhost:6060\n  -connections int\n    \tMax open idle connections per target host (default 10000)\n  -dns-ttl value\n    \tCache DNS lookups for the given duration [-1 = disabled, 0 = forever] (default 0s)\n  -duration duration\n    \tDuration of the test [0 = forever]\n  -format string\n    \tTargets format [http, json] (default \"http\")\n  -h2c\n    \tSend HTTP/2 requests without TLS encryption\n  -header value\n    \tRequest header\n  -http2\n    \tSend HTTP/2 requests when supported by the server (default true)\n  -insecure\n    \tIgnore invalid server TLS certificates\n  -keepalive\n    \tUse persistent connections (default true)\n  -key string\n    \tTLS client PEM encoded private key file\n  -laddr value\n    \tLocal IP address (default 0.0.0.0)\n  -lazy\n    \tRead targets lazily\n  -max-body value\n    \tMaximum number of bytes to capture from response bodies. [-1 = no limit] (default -1)\n  -max-connections int\n    \tMax connections per target host\n  -max-workers uint\n    \tMaximum number of workers (default 18446744073709551615)\n  -name string\n    \tAttack name\n  -output string\n    \tOutput file (default \"stdout\")\n  -prometheus-addr string\n    \tPrometheus exporter listen address [empty = disabled]. Example: 0.0.0.0:8880\n  -proxy-header value\n    \tProxy CONNECT header\n  -rate value\n    \tNumber of requests per time unit [0 = infinity] (default 50/1s)\n  -redirects int\n    \tNumber of redirects to follow. -1 will not follow but marks as success (default 10)\n  -resolvers value\n    \tList of addresses (ip:port) to use for DNS resolution. Disables use of local system DNS. (comma separated list)\n  -root-certs value\n    \tTLS root certificate files (comma separated list)\n  -session-tickets\n    \tEnable TLS session resumption using session tickets\n  -targets string\n    \tTargets file (default \"stdin\")\n  -timeout duration\n    \tRequests timeout (default 30s)\n  -unix-socket string\n    \tConnect over a unix socket. This overrides the host address in target URLs\n  -workers uint\n    \tInitial number of workers (default 10)\n\nencode command:\n  -output string\n    \tOutput file (default \"stdout\")\n  -to string\n    \tOutput encoding [csv, gob, json] (default \"json\")\n\nplot command:\n  -output string\n    \tOutput file (default \"stdout\")\n  -threshold int\n    \tThreshold of data points above which series are downsampled. (default 4000)\n  -title string\n    \tTitle and header of the resulting HTML page (default \"Vegeta Plot\")\n\nreport command:\n  -buckets string\n    \tHistogram buckets, e.g.: \"[0,1ms,10ms]\"\n  -every duration\n    \tReport interval\n  -output string\n    \tOutput file (default \"stdout\")\n  -type string\n    \tReport type to generate [text, json, hist[buckets], hdrplot] (default \"text\")\n\nexamples:\n  echo \"GET http://localhost/\" | vegeta attack -duration=5s | tee results.bin | vegeta report\n  vegeta report -type=json results.bin > metrics.json\n  cat results.bin | vegeta plot > plot.html\n  cat results.bin | vegeta report -type=\"hist[0,100ms,200ms,300ms]\"\n```\n\n#### `-cpus`\n\nSpecifies the number of CPUs to be used internally.\nIt defaults to the amount of CPUs available in the system.\n\n#### `-profile`\n\nSpecifies which profiler to enable during execution. Both _cpu_ and\n_heap_ profiles are supported. It defaults to none.\n\n#### `-version`\n\nPrints the version and exits.\n\n### `attack` command\n\n#### `-body`\n\nSpecifies the file whose content will be set as the body of every\nrequest unless overridden per attack target, see `-targets`.\n\n#### `-cert`\n\nSpecifies the PEM encoded TLS client certificate file to be used with HTTPS requests.\nIf `-key` isn't specified, it will be set to the value of this flag.\n\n#### `-chunked`\n\nSpecifies whether to send request bodies with the chunked transfer encoding.\n\n#### `-connections`\n\nSpecifies the maximum number of idle open connections per target host.\n\n#### `-dns-ttl`\n\nSpecifies the duration to cache DNS lookups for. A zero value caches forever.\nA negative value disables caching altogether.\n\n#### `-max-connections`\n\nSpecifies the maximum number of connections per target host.\n\n#### `-duration`\n\nSpecifies the amount of time to issue request to the targets.\nThe internal concurrency structure's setup has this value as a variable.\nThe actual run time of the test can be longer than specified due to the\nresponses delay. Use 0 for an infinite attack.\n\n#### `-format`\n\nSpecifies the targets format to decode.\n\n##### `json` format\n\nThe JSON format makes integration with programs that produce targets dynamically easier.\nEach target is one JSON object in its own line. The method and url fields are required.\nIf present, the body field must be base64 encoded. The generated [JSON Schema](lib/target.schema.json)\ndefines the format in detail.\n\n```bash\njq -ncM '{method: \"GET\", url: \"http://goku\", body: \"Punch!\" | @base64, header: {\"Content-Type\": [\"text/plain\"]}}' |\n  vegeta attack -format=json -rate=100 | vegeta encode\n```\n\n##### `http` format\n\nThe http format almost resembles the plain-text HTTP message format defined in\n[RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html) but it\ndoesn't support in-line HTTP bodies, only references to files that are loaded and used\nas request bodies (as exemplified below).\n\nAlthough targets in this format can be produced by other programs, it was originally\nmeant to be used by people writing targets by hand for simple use cases.\n\nHere are a few examples of valid targets files in the http format:\n\n###### Simple targets\n\n```\nGET http://goku:9090/path/to/dragon?item=ball\nGET http://user:password@goku:9090/path/to\nHEAD http://goku:9090/path/to/success\n```\n\n###### Targets with custom headers\n\n```\nGET http://user:password@goku:9090/path/to\nX-Account-ID: 8675309\n\nDELETE http://goku:9090/path/to/remove\nConfirmation-Token: 90215\nAuthorization: Token DEADBEEF\n```\n\n###### Targets with custom bodies\n\n```\nPOST http://goku:9090/things\n@/path/to/newthing.json\n\nPATCH http://goku:9090/thing/71988591\n@/path/to/thing-71988591.json\n```\n\n###### Targets with custom bodies and headers\n\n```\nPOST http://goku:9090/things\nX-Account-ID: 99\n@/path/to/newthing.json\n```\n\n###### Add comments\n\nLines starting with `#` are ignored.\n\n```\n# get a dragon ball\nGET http://goku:9090/path/to/dragon?item=ball\n# specify a test account\nX-Account-ID: 99\n```\n\n#### `-h2c`\n\nSpecifies that HTTP2 requests are to be sent over TCP without TLS encryption.\n\n#### `-header`\n\nSpecifies a request header to be used in all targets defined, see `-targets`.\nYou can specify as many as needed by repeating the flag.\n\n#### `-http2`\n\nSpecifies whether to enable HTTP/2 requests to servers which support it.\n\n#### `-insecure`\n\nSpecifies whether to ignore invalid server TLS certificates.\n\n#### `-keepalive`\n\nSpecifies whether to reuse TCP connections between HTTP requests.\n\n#### `-key`\n\nSpecifies the PEM encoded TLS client certificate private key file to be\nused with HTTPS requests.\n\n#### `-laddr`\n\nSpecifies the local IP address to be used.\n\n#### `-lazy`\n\nSpecifies whether to read the input targets lazily instead of eagerly.\nThis allows streaming targets into the attack command and reduces memory\nfootprint.\nThe trade-off is one of added latency in each hit against the targets.\n\n#### `-max-body`\n\nSpecifies the maximum number of bytes to capture from the body of each\nresponse. Remaining unread bytes will be fully read but discarded.\nSet to -1 for no limit. It knows how to interpret values like these:\n\n- `\"10 MB\"` -> `10MB`\n- `\"10240 g\"` -> `10TB`\n- `\"2000\"` -> `2000B`\n- `\"1tB\"` -> `1TB`\n- `\"5 peta\"` -> `5PB`\n- `\"28 kilobytes\"` -> `28KB`\n- `\"1 gigabyte\"` -> `1GB`\n\n#### `-name`\n\nSpecifies the name of the attack to be recorded in responses.\n\n#### `-output`\n\nSpecifies the output file to which the binary results will be written\nto. Made to be piped to the report command input. Defaults to stdout.\n\n#### `-rate`\n\nSpecifies the request rate per time unit to issue against\nthe targets. The actual request rate can vary slightly due to things like\ngarbage collection, but overall it should stay very close to the specified.\nIf no time unit is provided, 1s is used.\n\nA `-rate` of `0` or `infinity` means vegeta will send requests as fast as possible.\nUse together with `-max-workers` to model a fixed set of concurrent users sending\nrequests serially (i.e. waiting for a response before sending the next request).\n\nSetting `-max-workers` to a very high number while setting `-rate=0` can result in\nvegeta consuming too many resources and crashing. Use with care.\n\n#### `-redirects`\n\nSpecifies the max number of redirects followed on each request. The\ndefault is 10. When the value is -1, redirects are not followed but\nthe response is marked as successful.\n\n#### `-resolvers`\n\nSpecifies custom DNS resolver addresses to use for name resolution instead of\nthe ones configured by the operating system. Works only on non Windows systems.\n\n#### `-root-certs`\n\nSpecifies the trusted TLS root CAs certificate files as a comma separated\nlist. If unspecified, the default system CAs certificates will be used.\n\n#### `-session-tickets`\n\nSpecifies whether to support TLS session resumption using session tickets.\n\n#### `-targets`\n\nSpecifies the file from which to read targets, defaulting to stdin.\nSee the [`-format`](#-format) section to learn about the different target formats.\n\n#### `-timeout`\n\nSpecifies the timeout for each request. A value of `0` disables timeouts.\n\n#### `-workers`\n\nSpecifies the initial number of workers used in the attack. The actual\nnumber of workers will increase if necessary in order to sustain the\nrequested rate, unless it'd go beyond `-max-workers`.\n\n#### `-max-workers`\n\nSpecifies the maximum number of workers used in the attack. It can be used to\ncontrol the concurrency level used by an attack.\n\n### `report` command\n\n```console\nUsage: vegeta report [options] [<file>...]\n\nOutputs a report of attack results.\n\nArguments:\n  <file>  A file with vegeta attack results encoded with one of\n          the supported encodings (gob | json | csv) [default: stdin]\n\nOptions:\n  --type    Which report type to generate (text | json | hist[buckets] | hdrplot).\n            [default: text]\n\n  --buckets Histogram buckets, e.g.: '[0,1ms,10ms]'\n\n  --every   Write the report to --output at every given interval (e.g 100ms)\n            The default of 0 means the report will only be written after\n            all results have been processed. [default: 0]\n\n  --output  Output file [default: stdout]\n\nExamples:\n  echo \"GET http://:80\" | vegeta attack -rate=10/s > results.gob\n  echo \"GET http://:80\" | vegeta attack -rate=100/s | vegeta encode > results.json\n  vegeta report results.*\n```\n\n#### `report -type=text`\n\n```console\nRequests      [total, rate, throughput] 1200, 120.00, 65.87\nDuration      [total, attack, wait]     10.094965987s, 9.949883921s, 145.082066ms\nLatencies     [min, mean, 50, 95, 99, max]  90.438129ms, 113.172398ms, 108.272568ms, 140.18235ms, 247.771566ms, 264.815246ms\nBytes In      [total, mean]             3714690, 3095.57\nBytes Out     [total, mean]             0, 0.00\nSuccess       [ratio]                   55.42%\nStatus Codes  [code:count]              0:535  200:665\nError Set:\nGet http://localhost:6060: dial tcp 127.0.0.1:6060: connection refused\nGet http://localhost:6060: read tcp 127.0.0.1:6060: connection reset by peer\nGet http://localhost:6060: dial tcp 127.0.0.1:6060: connection reset by peer\nGet http://localhost:6060: write tcp 127.0.0.1:6060: broken pipe\nGet http://localhost:6060: net/http: transport closed before response was received\nGet http://localhost:6060: http: can't write HTTP request on broken connection\n```\n\nThe `Requests` row shows:\n\n- The `total` number of issued requests.\n- The real request `rate` sustained during the `attack` period.\n- The `throughput` of successful requests over the `total` period.\n\nThe `Duration` row shows:\n\n- The `attack` time taken issuing all requests (`total` - `wait`)\n- The `wait` time waiting for the response to the last issued request (`total` - `attack`)\n- The `total` time taken in the attack (`attack` + `wait`)\n\nLatency is the amount of time taken for a response to a request to be read (including the `-max-body` bytes from the response body).\n\n- `min` is the minimum latency of all requests in an attack.\n- `mean` is the [arithmetic mean / average](https://en.wikipedia.org/wiki/Arithmetic_mean) of the latencies of all requests in an attack.\n- `50`, `90`, `95`, `99` are the 50th, 90th, 95th and 99th [percentiles](https://en.wikipedia.org/wiki/Percentile), respectively, of the latencies of all requests in an attack. To understand more about why these are useful, I recommend [this article](https://bravenewgeek.com/everything-you-know-about-latency-is-wrong/) from @tylertreat.\n- `max` is the maximum latency of all requests in an attack.\n\nThe `Bytes In` and `Bytes Out` rows shows:\n\n- The `total` number of bytes sent (out) or received (in) with the request or response bodies.\n- The `mean` number of bytes sent (out) or received (in) with the request or response bodies.\n\nThe `Success` ratio shows the percentage of requests whose responses didn't error and had status codes between **200** and **400** (non-inclusive).\n\nThe `Status Codes` row shows a histogram of status codes. `0` status codes mean a request failed to be sent.\n\nThe `Error Set` shows a unique set of errors returned by all issued requests. These include requests that got non-successful response status code.\n\n#### `report -type=json`\n\nAll duration like fields are in nanoseconds.\n\n```json\n{\n  \"latencies\": {\n    \"total\": 237119463,\n    \"mean\": 2371194,\n    \"50th\": 2854306,\n    \"90th\": 3228223,\n    \"95th\": 3478629,\n    \"99th\": 3530000,\n    \"max\": 3660505,\n    \"min\": 1949582\n  },\n  \"buckets\": {\n    \"0\": 9952,\n    \"1000000\": 40,\n    \"2000000\": 6,\n    \"3000000\": 0,\n    \"4000000\": 0,\n    \"5000000\": 2\n  },\n  \"bytes_in\": {\n    \"total\": 606700,\n    \"mean\": 6067\n  },\n  \"bytes_out\": {\n    \"total\": 0,\n    \"mean\": 0\n  },\n  \"earliest\": \"2015-09-19T14:45:50.645818631+02:00\",\n  \"latest\": \"2015-09-19T14:45:51.635818575+02:00\",\n  \"end\": \"2015-09-19T14:45:51.639325797+02:00\",\n  \"duration\": 989999944,\n  \"wait\": 3507222,\n  \"requests\": 100,\n  \"rate\": 101.01010672380401,\n  \"throughput\": 101.00012489812,\n  \"success\": 1,\n  \"status_codes\": {\n    \"200\": 100\n  },\n  \"errors\": []\n}\n```\n\nIn the `buckets` field, each key is a nanosecond value representing the lower bound of a bucket.\nThe upper bound is implied by the next higher bucket.\nUpper bounds are non-inclusive.\nThe highest bucket is the overflow bucket; it has no upper bound.\nThe values are counts of how many requests fell into that particular bucket.\nIf the `-buckets` parameter is not present, the `buckets` field is omitted.\n\n#### `report -type=hist`\n\nComputes and prints a text based histogram for the given buckets.\nEach bucket upper bound is non-inclusive.\n\n```console\ncat results.bin | vegeta report -type='hist[0,2ms,4ms,6ms]'\nBucket         #     %       Histogram\n[0,     2ms]   6007  32.65%  ########################\n[2ms,   4ms]   5505  29.92%  ######################\n[4ms,   6ms]   2117  11.51%  ########\n[6ms,   +Inf]  4771  25.93%  ###################\n```\n\n#### `report -type=hdrplot`\n\nWrites out results in a format plottable by https://hdrhistogram.github.io/HdrHistogram/plotFiles.html.\n\n```\nValue(ms)  Percentile  TotalCount  1/(1-Percentile)\n0.076715   0.000000    0           1.000000\n0.439370   0.100000    200         1.111111\n0.480836   0.200000    400         1.250000\n0.495559   0.300000    599         1.428571\n0.505101   0.400000    799         1.666667\n0.513059   0.500000    999         2.000000\n0.516664   0.550000    1099        2.222222\n0.520455   0.600000    1199        2.500000\n0.525008   0.650000    1299        2.857143\n0.530174   0.700000    1399        3.333333\n0.534891   0.750000    1499        4.000000\n0.537572   0.775000    1548        4.444444\n0.540340   0.800000    1598        5.000000\n0.543763   0.825000    1648        5.714286\n0.547164   0.850000    1698        6.666667\n0.551432   0.875000    1748        8.000000\n0.553444   0.887500    1773        8.888889\n0.555774   0.900000    1798        10.000000\n0.558454   0.912500    1823        11.428571\n0.562123   0.925000    1848        13.333333\n0.565563   0.937500    1873        16.000000\n0.567831   0.943750    1886        17.777778\n0.570617   0.950000    1898        20.000000\n0.574522   0.956250    1911        22.857143\n0.579046   0.962500    1923        26.666667\n0.584426   0.968750    1936        32.000000\n0.586695   0.971875    1942        35.555556\n0.590451   0.975000    1948        40.000000\n0.597543   0.978125    1954        45.714286\n0.605637   0.981250    1961        53.333333\n0.613564   0.984375    1967        64.000000\n0.620393   0.985938    1970        71.113640\n0.629121   0.987500    1973        80.000000\n0.638060   0.989062    1976        91.424392\n0.648085   0.990625    1979        106.666667\n0.659689   0.992188    1982        128.008193\n0.665870   0.992969    1984        142.227279\n0.672985   0.993750    1986        160.000000\n0.680101   0.994531    1987        182.848784\n0.687810   0.995313    1989        213.356091\n0.695729   0.996094    1990        256.016385\n0.730641   0.996484    1991        284.414107\n0.785516   0.996875    1992        320.000000\n0.840392   0.997266    1993        365.764448\n1.009646   0.997656    1993        426.621160\n1.347020   0.998047    1994        512.032770\n1.515276   0.998242    1994        568.828214\n1.683532   0.998437    1995        639.795266\n1.887487   0.998633    1995        731.528895\n2.106249   0.998828    1996        853.242321\n2.325011   0.999023    1996        1023.541453\n2.434952   0.999121    1996        1137.656428\n2.544894   0.999219    1996        1280.409731\n2.589510   0.999316    1997        1461.988304\n2.605192   0.999414    1997        1706.484642\n2.620873   0.999512    1997        2049.180328\n2.628713   0.999561    1997        2277.904328\n2.636394   0.999609    1997        2557.544757\n2.644234   0.999658    1997        2923.976608\n2.652075   0.999707    1997        3412.969283\n2.658916   0.999756    1998        4098.360656\n2.658916   0.999780    1998        4545.454545\n2.658916   0.999805    1998        5128.205128\n2.658916   0.999829    1998        5847.953216\n2.658916   0.999854    1998        6849.315068\n2.658916   0.999878    1998        8196.721311\n2.658916   0.999890    1998        9090.909091\n2.658916   0.999902    1998        10204.081633\n2.658916   0.999915    1998        11764.705882\n2.658916   0.999927    1998        13698.630137\n2.658916   0.999939    1998        16393.442623\n2.658916   0.999945    1998        18181.818182\n2.658916   0.999951    1998        20408.163265\n2.658916   0.999957    1998        23255.813953\n2.658916   0.999963    1998        27027.027027\n2.658916   0.999969    1998        32258.064516\n2.658916   0.999973    1998        37037.037037\n2.658916   0.999976    1998        41666.666667\n2.658916   0.999979    1998        47619.047619\n2.658916   0.999982    1998        55555.555556\n2.658916   0.999985    1998        66666.666667\n2.658916   0.999986    1998        71428.571429\n2.658916   0.999988    1998        83333.333333\n2.658916   0.999989    1998        90909.090909\n2.658916   0.999991    1998        111111.111111\n2.658916   0.999992    1998        125000.000000\n2.658916   0.999993    1998        142857.142858\n2.658916   0.999994    1998        166666.666668\n2.658916   0.999995    1998        199999.999999\n2.658916   0.999996    1998        250000.000000\n2.658916   0.999997    1998        333333.333336\n2.658916   0.999998    1998        500000.000013\n2.658916   0.999999    1998        999999.999971\n2.658916   1.000000    1998        10000000.000000\n```\n\n### `encode` command\n\n```\nUsage: vegeta encode [options] [<file>...]\n\nEncodes vegeta attack results from one encoding to another.\nThe supported encodings are Gob (binary), CSV and JSON.\nEach input file may have a different encoding which is detected\nautomatically.\n\nThe CSV encoder doesn't write a header. The columns written by it are:\n\n  1. Unix timestamp in nanoseconds since epoch\n  2. HTTP status code\n  3. Request latency in nanoseconds\n  4. Bytes out\n  5. Bytes in\n  6. Error\n  7. Base64 encoded response body\n  8. Attack name\n  9. Sequence number of request\n  10. Method\n  11. URL\n  12. Base64 encoded response headers\n\nArguments:\n  <file>  A file with vegeta attack results encoded with one of\n          the supported encodings (gob | json | csv) [default: stdin]\n\nOptions:\n  --to      Output encoding (gob | json | csv) [default: json]\n  --output  Output file [default: stdout]\n\nExamples:\n  echo \"GET http://:80\" | vegeta attack -rate=1/s > results.gob\n  cat results.gob | vegeta encode | jq -c 'del(.body)' | vegeta encode -to gob\n```\n\n### `plot` command\n\n![Plot](https://i.imgur.com/Jra1sNH.png)\n\n```\nUsage: vegeta plot [options] [<file>...]\n\nOutputs an HTML time series plot of request latencies over time.\nThe X axis represents elapsed time in seconds from the beginning\nof the earliest attack in all input files. The Y axis represents\nrequest latency in milliseconds.\n\nClick and drag to select a region to zoom into. Double click to zoom out.\nChoose a different number on the bottom left corner input field\nto change the moving average window size (in data points).\n\nArguments:\n  <file>  A file output by running vegeta attack [default: stdin]\n\nOptions:\n  --title      Title and header of the resulting HTML page.\n               [default: Vegeta Plot]\n  --threshold  Threshold of data points to downsample series to.\n               Series with less than --threshold number of data\n               points are not downsampled. [default: 4000]\n\nExamples:\n  echo \"GET http://:80\" | vegeta attack -name=50qps -rate=50 -duration=5s > results.50qps.bin\n  cat results.50qps.bin | vegeta plot > plot.50qps.html\n  echo \"GET http://:80\" | vegeta attack -name=100qps -rate=100 -duration=5s > results.100qps.bin\n  vegeta plot results.50qps.bin results.100qps.bin > plot.html\n```\n\n## Usage: Generated targets\n\nApart from accepting a static list of targets, Vegeta can be used together with another program that generates them in a streaming fashion. Here's an example of that using the `jq` utility that generates targets with an incrementing id in their body.\n\n```console\njq -ncM 'while(true; .+1) | {method: \"POST\", url: \"http://:6060\", body: {id: .} | @base64 }' | \\\n  vegeta attack -rate=50/s -lazy -format=json -duration=30s | \\\n  tee results.bin | \\\n  vegeta report\n```\n\n## Usage: Distributed attacks\n\nWhenever your load test can't be conducted due to Vegeta hitting machine limits\nsuch as open files, memory, CPU or network bandwidth, it's a good idea to use Vegeta in a distributed manner.\n\nIn a hypothetical scenario where the desired attack rate is 60k requests per second,\nlet's assume we have 3 machines with `vegeta` installed.\n\nMake sure open file descriptor and process limits are set to a high number for your user **on each machine**\nusing the `ulimit` command.\n\nWe're ready to start the attack. All we need to do is to divide the intended rate by the number of machines,\nand use that number on each attack. Here we'll use [pdsh](https://code.google.com/p/pdsh/) for orchestration.\n\n```shell\n$ PDSH_RCMD_TYPE=ssh pdsh -b -w '10.0.1.1,10.0.2.1,10.0.3.1' \\\n    'echo \"GET http://target/\" | vegeta attack -rate=20000 -duration=60s > result.bin'\n```\n\nAfter the previous command finishes, we can gather the result files to use on our report.\n\n```shell\n$ for machine in 10.0.1.1 10.0.2.1 10.0.3.1; do\n    scp $machine:~/result.bin $machine.bin &\n  done\n```\n\nThe `report` command accepts multiple result files.\nIt'll read and sort them by timestamp before generating reports.\n\n```console\nvegeta report *.bin\n```\n\nAnother way to gather results in distributed tests is to use the built-in Prometheus Exporter and configure a Prometheus Server to get test results from all Vegeta instances. See `attack` option \"prometheus-addr\" for more details and a complete example in the section \"Prometheus Support\".\n\n## Usage: Real-time Analysis\n\nIf you are a happy user of iTerm, you can integrate vegeta with [jplot](https://github.com/rs/jplot) using [jaggr](https://github.com/rs/jaggr) to plot a vegeta report in real-time in the comfort of your terminal:\n\n```\necho 'GET http://localhost:8080' | \\\n    vegeta attack -rate 5000 -duration 10m | vegeta encode | \\\n    jaggr @count=rps \\\n          hist\\[100,200,300,400,500\\]:code \\\n          p25,p50,p95:latency \\\n          sum:bytes_in \\\n          sum:bytes_out | \\\n    jplot rps+code.hist.100+code.hist.200+code.hist.300+code.hist.400+code.hist.500 \\\n          latency.p95+latency.p50+latency.p25 \\\n          bytes_in.sum+bytes_out.sum\n```\n\n![](https://i.imgur.com/ttBDsQS.gif)\n\n## Usage: Library\n\nThe library versioning follows [SemVer v2.0.0](https://semver.org/spec/v2.0.0.html).\nSince [lib/v9.0.0](https://github.com/tsenart/vegeta/tree/lib/v9.0.0), the library and cli\nare versioned separately to better isolate breaking changes to each component.\n\nSee [Versioning](#Versioning) for more details on git tag naming schemes and compatibility\nwith `go mod`.\n\n```go\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n\n  vegeta \"github.com/tsenart/vegeta/v12/lib\"\n)\n\nfunc main() {\n  rate := vegeta.Rate{Freq: 100, Per: time.Second}\n  duration := 4 * time.Second\n  targeter := vegeta.NewStaticTargeter(vegeta.Target{\n    Method: \"GET\",\n    URL:    \"http://localhost:9100/\",\n  })\n  attacker := vegeta.NewAttacker()\n\n  var metrics vegeta.Metrics\n  for res := range attacker.Attack(targeter, rate, duration, \"Big Bang!\") {\n    metrics.Add(res)\n  }\n  metrics.Close()\n\n  fmt.Printf(\"99th percentile: %s\\n\", metrics.Latencies.P99)\n}\n```\n\n#### Limitations\n\nThere will be an upper bound of the supported `rate` which varies on the\nmachine being used.\nYou could be CPU bound (unlikely), memory bound (more likely) or\nhave system resource limits being reached which ought to be tuned for\nthe process execution. The important limits for us are file descriptors\nand processes. On a UNIX system you can get and set the current\nsoft-limit values for a user.\n\n```shell\n$ ulimit -n # file descriptors\n2560\n$ ulimit -u # processes / threads\n709\n```\n\nJust pass a new number as the argument to change it.\n\n## Prometheus support\n\nVegeta has a built-in Prometheus Exporter that may be enabled during attacks so that you can point any Prometheus instance to Vegeta attack processes and monitor attack metrics.\n\nTo enable the Prometheus Exporter on the command line, set the \"prometheus-addr\" flag.\n\nA Prometheus HTTP endpoint will be available only during the lifespan of an attack and will be closed right after the attack is finished.\n\nThe following metrics are exposed:\n\n* `request_bytes_in` - bytes count received from targeted servers by \"url\", \"method\" and \"status\"\n* `request_bytes_out` - bytes count sent to targeted server by \"url\", \"method\" and \"status\"\n* `request_seconds` - histogram with request latency and counters by \"url\", \"method\" and \"status\"\n* `request_fail_count` - count of failed requests by \"url\", \"method\", \"status\" and \"message\"\n\n<image src=\"lib/prom/prometheus-sample.png\" width=\"500\" />\n\nCheck file [lib/prom/grafana.json](lib/prom/grafana.json) with the source of this sample dashboard in Grafana.\n\n### Limitations\n\n1. Prometheus scrapes metrics from a running vegeta attack process and assigns timestamps to samples on its server. This means result timestamps aren't accurate (i.e. they're scraping time, not result time).\n2. Configuring Prometheus to scrape vegeta needs to happen out-of-band. That's a hassle!\n3. Since there's no coordination between a vegeta attack process and a Prometheus server, an attack process will finish before Prometheus has the chance to scrape the latest observations.\n\n\nWhy aren't we using pushgateway instead? See [this comment](https://github.com/tsenart/vegeta/pull/534#issuecomment-1629943731).\n\nThere's [an issue](https://github.com/tsenart/vegeta/issues/637) tracking the proper solution to all these limitations which is a remote write integration.\n\n## License\n\nSee [LICENSE](LICENSE).\n\n## Donate\n\nIf you use and love Vegeta, please consider sending some Satoshi to\n`1MDmKC51ve7Upxt75KoNM6x1qdXHFK6iW2`. In case you want to be mentioned as a\nsponsor, let me know!\n\n[![Donate Bitcoin](https://i.imgur.com/W9Vc51d.png)](#donate)\n"
        },
        {
          "name": "attack.go",
          "type": "blob",
          "size": 9.068359375,
          "content": "package main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/tsenart/vegeta/v12/internal/resolver\"\n\tvegeta \"github.com/tsenart/vegeta/v12/lib\"\n\tprom \"github.com/tsenart/vegeta/v12/lib/prom\"\n)\n\nfunc attackCmd() command {\n\tfs := flag.NewFlagSet(\"vegeta attack\", flag.ExitOnError)\n\topts := &attackOpts{\n\t\theaders:      headers{http.Header{}},\n\t\tproxyHeaders: headers{http.Header{}},\n\t\tladdr:        localAddr{&vegeta.DefaultLocalAddr},\n\t\trate:         vegeta.Rate{Freq: 50, Per: time.Second},\n\t\tmaxBody:      vegeta.DefaultMaxBody,\n\t\tpromAddr:     \"0.0.0.0:8880\",\n\t}\n\tfs.StringVar(&opts.name, \"name\", \"\", \"Attack name\")\n\tfs.StringVar(&opts.targetsf, \"targets\", \"stdin\", \"Targets file\")\n\tfs.StringVar(&opts.format, \"format\", vegeta.HTTPTargetFormat,\n\t\tfmt.Sprintf(\"Targets format [%s]\", strings.Join(vegeta.TargetFormats, \", \")))\n\tfs.StringVar(&opts.outputf, \"output\", \"stdout\", \"Output file\")\n\tfs.StringVar(&opts.bodyf, \"body\", \"\", \"Requests body file\")\n\tfs.BoolVar(&opts.chunked, \"chunked\", false, \"Send body with chunked transfer encoding\")\n\tfs.StringVar(&opts.certf, \"cert\", \"\", \"TLS client PEM encoded certificate file\")\n\tfs.StringVar(&opts.keyf, \"key\", \"\", \"TLS client PEM encoded private key file\")\n\tfs.Var(&opts.rootCerts, \"root-certs\", \"TLS root certificate files (comma separated list)\")\n\tfs.BoolVar(&opts.http2, \"http2\", true, \"Send HTTP/2 requests when supported by the server\")\n\tfs.BoolVar(&opts.h2c, \"h2c\", false, \"Send HTTP/2 requests without TLS encryption\")\n\tfs.BoolVar(&opts.insecure, \"insecure\", false, \"Ignore invalid server TLS certificates\")\n\tfs.BoolVar(&opts.lazy, \"lazy\", false, \"Read targets lazily\")\n\tfs.DurationVar(&opts.duration, \"duration\", 0, \"Duration of the test [0 = forever]\")\n\tfs.DurationVar(&opts.timeout, \"timeout\", vegeta.DefaultTimeout, \"Requests timeout\")\n\tfs.Uint64Var(&opts.workers, \"workers\", vegeta.DefaultWorkers, \"Initial number of workers\")\n\tfs.Uint64Var(&opts.maxWorkers, \"max-workers\", vegeta.DefaultMaxWorkers, \"Maximum number of workers\")\n\tfs.IntVar(&opts.connections, \"connections\", vegeta.DefaultConnections, \"Max open idle connections per target host\")\n\tfs.IntVar(&opts.maxConnections, \"max-connections\", vegeta.DefaultMaxConnections, \"Max connections per target host\")\n\tfs.IntVar(&opts.redirects, \"redirects\", vegeta.DefaultRedirects, \"Number of redirects to follow. -1 will not follow but marks as success\")\n\tfs.Var(&maxBodyFlag{&opts.maxBody}, \"max-body\", \"Maximum number of bytes to capture from response bodies. [-1 = no limit]\")\n\tfs.Var(&rateFlag{&opts.rate}, \"rate\", \"Number of requests per time unit [0 = infinity]\")\n\tfs.Var(&opts.headers, \"header\", \"Request header\")\n\tfs.Var(&opts.proxyHeaders, \"proxy-header\", \"Proxy CONNECT header\")\n\tfs.Var(&opts.laddr, \"laddr\", \"Local IP address\")\n\tfs.BoolVar(&opts.keepalive, \"keepalive\", true, \"Use persistent connections\")\n\tfs.StringVar(&opts.unixSocket, \"unix-socket\", \"\", \"Connect over a unix socket. This overrides the host address in target URLs\")\n\tfs.StringVar(&opts.promAddr, \"prometheus-addr\", \"\", \"Prometheus exporter listen address [empty = disabled]. Example: 0.0.0.0:8880\")\n\tfs.Var(&dnsTTLFlag{&opts.dnsTTL}, \"dns-ttl\", \"Cache DNS lookups for the given duration [-1 = disabled, 0 = forever]\")\n\tfs.BoolVar(&opts.sessionTickets, \"session-tickets\", false, \"Enable TLS session resumption using session tickets\")\n\tfs.Var(&connectToFlag{&opts.connectTo}, \"connect-to\", \"A mapping of (ip|host):port to use instead of a target URL's (ip|host):port. Can be repeated multiple times.\\nIdentical src:port with different dst:port will round-robin over the different dst:port pairs.\\nExample: google.com:80:localhost:6060\")\n\tsystemSpecificFlags(fs, opts)\n\n\treturn command{fs, func(args []string) error {\n\t\tfs.Parse(args)\n\t\treturn attack(opts)\n\t}}\n}\n\nvar (\n\terrZeroRate = errors.New(\"rate frequency and time unit must be bigger than zero\")\n\terrBadCert  = errors.New(\"bad certificate\")\n)\n\n// attackOpts aggregates the attack function command options\ntype attackOpts struct {\n\tname           string\n\ttargetsf       string\n\tformat         string\n\toutputf        string\n\tbodyf          string\n\tcertf          string\n\tkeyf           string\n\trootCerts      csl\n\thttp2          bool\n\th2c            bool\n\tinsecure       bool\n\tlazy           bool\n\tchunked        bool\n\tduration       time.Duration\n\ttimeout        time.Duration\n\trate           vegeta.Rate\n\tworkers        uint64\n\tmaxWorkers     uint64\n\tconnections    int\n\tmaxConnections int\n\tredirects      int\n\tmaxBody        int64\n\theaders        headers\n\tproxyHeaders   headers\n\tladdr          localAddr\n\tkeepalive      bool\n\tresolvers      csl\n\tunixSocket     string\n\tpromAddr       string\n\tdnsTTL         time.Duration\n\tsessionTickets bool\n\tconnectTo      map[string][]string\n}\n\n// attack validates the attack arguments, sets up the\n// required resources, launches the attack and writes the results\nfunc attack(opts *attackOpts) (err error) {\n\tif opts.maxWorkers == vegeta.DefaultMaxWorkers && opts.rate.Freq == 0 {\n\t\treturn fmt.Errorf(\"-rate=0 requires setting -max-workers\")\n\t}\n\n\tif len(opts.resolvers) > 0 {\n\t\tres, err := resolver.NewResolver(opts.resolvers)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tnet.DefaultResolver = res\n\t}\n\n\tnet.DefaultResolver.PreferGo = true\n\n\tfiles := map[string]io.Reader{}\n\tfor _, filename := range []string{opts.targetsf, opts.bodyf} {\n\t\tif filename == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tf, err := file(filename, false)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error opening %s: %s\", filename, err)\n\t\t}\n\t\tdefer f.Close()\n\t\tfiles[filename] = f\n\t}\n\n\tvar body []byte\n\tif bodyf, ok := files[opts.bodyf]; ok {\n\t\tif body, err = io.ReadAll(bodyf); err != nil {\n\t\t\treturn fmt.Errorf(\"error reading %s: %s\", opts.bodyf, err)\n\t\t}\n\t}\n\n\tvar (\n\t\ttr       vegeta.Targeter\n\t\tsrc      = files[opts.targetsf]\n\t\thdr      = opts.headers.Header\n\t\tproxyHdr = opts.proxyHeaders.Header\n\t)\n\n\tswitch opts.format {\n\tcase vegeta.JSONTargetFormat:\n\t\ttr = vegeta.NewJSONTargeter(src, body, hdr)\n\tcase vegeta.HTTPTargetFormat:\n\t\ttr = vegeta.NewHTTPTargeter(src, body, hdr)\n\tdefault:\n\t\treturn fmt.Errorf(\"format %q isn't one of [%s]\",\n\t\t\topts.format, strings.Join(vegeta.TargetFormats, \", \"))\n\t}\n\n\tif !opts.lazy {\n\t\ttargets, err := vegeta.ReadAllTargets(tr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttr = vegeta.NewStaticTargeter(targets...)\n\t}\n\n\tout, err := file(opts.outputf, true)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error opening %s: %s\", opts.outputf, err)\n\t}\n\tdefer out.Close()\n\n\ttlsc, err := tlsConfig(opts.insecure, opts.certf, opts.keyf, opts.rootCerts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar pm *prom.Metrics\n\tif opts.promAddr != \"\" {\n\t\tpm = prom.NewMetrics()\n\n\t\tr := prometheus.NewRegistry()\n\t\tif err := pm.Register(r); err != nil {\n\t\t\treturn fmt.Errorf(\"error registering prometheus metrics: %s\", err)\n\t\t}\n\n\t\tsrv := http.Server{\n\t\t\tAddr:    opts.promAddr,\n\t\t\tHandler: prom.NewHandler(r, time.Now().UTC()),\n\t\t}\n\n\t\tdefer srv.Close()\n\t\tgo srv.ListenAndServe()\n\t}\n\n\tatk := vegeta.NewAttacker(\n\t\tvegeta.Redirects(opts.redirects),\n\t\tvegeta.Timeout(opts.timeout),\n\t\tvegeta.LocalAddr(*opts.laddr.IPAddr),\n\t\tvegeta.TLSConfig(tlsc),\n\t\tvegeta.Workers(opts.workers),\n\t\tvegeta.MaxWorkers(opts.maxWorkers),\n\t\tvegeta.KeepAlive(opts.keepalive),\n\t\tvegeta.Connections(opts.connections),\n\t\tvegeta.MaxConnections(opts.maxConnections),\n\t\tvegeta.HTTP2(opts.http2),\n\t\tvegeta.H2C(opts.h2c),\n\t\tvegeta.MaxBody(opts.maxBody),\n\t\tvegeta.UnixSocket(opts.unixSocket),\n\t\tvegeta.ProxyHeader(proxyHdr),\n\t\tvegeta.ChunkedBody(opts.chunked),\n\t\tvegeta.DNSCaching(opts.dnsTTL),\n\t\tvegeta.ConnectTo(opts.connectTo),\n\t\tvegeta.SessionTickets(opts.sessionTickets),\n\t)\n\n\tres := atk.Attack(tr, opts.rate, opts.duration, opts.name)\n\tenc := vegeta.NewEncoder(out)\n\tsig := make(chan os.Signal, 1)\n\tsignal.Notify(sig, os.Interrupt, syscall.SIGTERM)\n\n\treturn processAttack(atk, res, enc, sig, pm)\n}\n\nfunc processAttack(\n\tatk *vegeta.Attacker,\n\tres <-chan *vegeta.Result,\n\tenc vegeta.Encoder,\n\tsig <-chan os.Signal,\n\tpm *prom.Metrics,\n) error {\n\tfor {\n\t\tselect {\n\t\tcase <-sig:\n\t\t\tif stopSent := atk.Stop(); !stopSent {\n\t\t\t\t// Exit immediately on second signal.\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase r, ok := <-res:\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tif pm != nil {\n\t\t\t\tpm.Observe(r)\n\t\t\t}\n\n\t\t\tif err := enc.Encode(r); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n}\n\n// tlsConfig builds a *tls.Config from the given options.\nfunc tlsConfig(insecure bool, certf, keyf string, rootCerts []string) (*tls.Config, error) {\n\tvar err error\n\tfiles := map[string][]byte{}\n\tfilenames := append([]string{certf, keyf}, rootCerts...)\n\tfor _, f := range filenames {\n\t\tif f != \"\" {\n\t\t\tif files[f], err = os.ReadFile(f); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tc := tls.Config{InsecureSkipVerify: insecure}\n\tif cert, ok := files[certf]; ok {\n\t\tkey, ok := files[keyf]\n\t\tif !ok {\n\t\t\tkey = cert\n\t\t}\n\n\t\tcertificate, err := tls.X509KeyPair(cert, key)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tc.Certificates = append(c.Certificates, certificate)\n\t\tc.BuildNameToCertificate()\n\t}\n\n\tif len(rootCerts) > 0 {\n\t\tc.RootCAs = x509.NewCertPool()\n\t\tfor _, f := range rootCerts {\n\t\t\tif !c.RootCAs.AppendCertsFromPEM(files[f]) {\n\t\t\t\treturn nil, errBadCert\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &c, nil\n}\n"
        },
        {
          "name": "attack_nonwindows.go",
          "type": "blob",
          "size": 0.2802734375,
          "content": "//go:build !windows\n// +build !windows\n\npackage main\n\nimport \"flag\"\n\nfunc systemSpecificFlags(fs *flag.FlagSet, opts *attackOpts) {\n\tfs.Var(&opts.resolvers, \"resolvers\", \"List of addresses (ip:port) to use for DNS resolution. Disables use of local system DNS. (comma separated list)\")\n}\n"
        },
        {
          "name": "attack_test.go",
          "type": "blob",
          "size": 3.8642578125,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\tvegeta \"github.com/tsenart/vegeta/v12/lib\"\n)\n\nfunc TestHeadersSet(t *testing.T) {\n\th := headers{\n\t\tHeader: make(http.Header),\n\t}\n\tfor i, tt := range []struct {\n\t\tkey, val string\n\t\twant     []string\n\t}{\n\t\t{\"key\", \"value\", []string{\"value\"}},\n\t\t{\"key\", \"value\", []string{\"value\", \"value\"}},\n\t\t{\"Key\", \"Value\", []string{\"Value\"}},\n\t\t{\"KEY\", \"VALUE\", []string{\"VALUE\"}},\n\t} {\n\t\tif err := h.Set(tt.key + \": \" + tt.val); err != nil {\n\t\t\tt.Error(err)\n\t\t} else if got := h.Header[tt.key]; !reflect.DeepEqual(got, tt.want) {\n\t\t\tt.Errorf(\"test #%d, '%s: %s': got: %+v, want: %+v\", i, tt.key, tt.val, got, tt.want)\n\t\t}\n\t}\n}\n\nfunc decodeMetrics(buf bytes.Buffer) (vegeta.Metrics, error) {\n\tvar metrics vegeta.Metrics\n\tdec := vegeta.NewDecoder(bufio.NewReader(&buf))\n\n\tfor {\n\t\tvar r vegeta.Result\n\t\tif err := dec.Decode(&r); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn metrics, err\n\t\t}\n\t\tmetrics.Add(&r)\n\t}\n\tmetrics.Close()\n\n\treturn metrics, nil\n}\n\nfunc TestAttackSignalOnce(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tsignalDelay    = 300 * time.Millisecond // Delay before stopping.\n\t\tclientTimeout  = 1 * time.Second        // This, plus delay, is the max time for the attack.\n\t\tserverTimeout  = 2 * time.Second        // Must be more than clientTimeout.\n\t\tattackDuration = 10 * time.Second       // The attack should never take this long.\n\t)\n\n\tserver := httptest.NewServer(\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\ttime.Sleep(serverTimeout) // Server.Close() will block for this long on shutdown.\n\t\t}),\n\t)\n\tdefer server.Close()\n\n\ttr := vegeta.NewStaticTargeter(vegeta.Target{Method: \"GET\", URL: server.URL})\n\tatk := vegeta.NewAttacker(vegeta.Timeout(clientTimeout))\n\trate := vegeta.Rate{Freq: 10, Per: time.Second} // Every 100ms.\n\n\tvar buf bytes.Buffer\n\twriter := bufio.NewWriter(&buf)\n\tenc := vegeta.NewEncoder(writer)\n\tsig := make(chan os.Signal, 1)\n\tres := atk.Attack(tr, rate, attackDuration, \"\")\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tprocessAttack(atk, res, enc, sig, nil)\n\t}()\n\n\t// Allow more than one request to have started before stopping.\n\ttime.Sleep(signalDelay)\n\tsig <- os.Interrupt\n\twg.Wait()\n\twriter.Flush()\n\n\tmetrics, err := decodeMetrics(buf)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif got, min := metrics.Requests, uint64(2); got < min {\n\t\tt.Errorf(\"not enough requests recorded. got %+v, min: %+v\", got, min)\n\t}\n\tif got, want := metrics.Success, 0.0; got != want {\n\t\tt.Errorf(\"all requests should fail. got %+v, want: %+v\", got, want)\n\t}\n\tif got, max := metrics.Duration, clientTimeout; got > max {\n\t\tt.Errorf(\"attack duration too long. got %+v, max: %+v\", got, max)\n\t}\n\tif got, want := metrics.Wait.Round(time.Second), clientTimeout; got != want {\n\t\tt.Errorf(\"attack wait doesn't match timeout. got %+v, want: %+v\", got, want)\n\t}\n}\n\nfunc TestAttackSignalTwice(t *testing.T) {\n\tt.Parallel()\n\n\tconst (\n\t\tattackDuration = 10 * time.Second // The attack should never take this long.\n\t)\n\n\tserver := httptest.NewServer(\n\t\thttp.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}),\n\t)\n\tdefer server.Close()\n\n\ttr := vegeta.NewStaticTargeter(vegeta.Target{Method: \"GET\", URL: server.URL})\n\tatk := vegeta.NewAttacker()\n\trate := vegeta.Rate{Freq: 1, Per: time.Second}\n\n\tvar buf bytes.Buffer\n\twriter := bufio.NewWriter(&buf)\n\tenc := vegeta.NewEncoder(writer)\n\tsig := make(chan os.Signal, 1)\n\tres := atk.Attack(tr, rate, attackDuration, \"\")\n\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tprocessAttack(atk, res, enc, sig, nil)\n\t}()\n\n\t// Exit as soon as possible.\n\tsig <- os.Interrupt\n\tsig <- os.Interrupt\n\twg.Wait()\n\twriter.Flush()\n\n\tmetrics, err := decodeMetrics(buf)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif got, max := metrics.Duration, time.Second; got > max {\n\t\tt.Errorf(\"attack duration too long. got %+v, max: %+v\", got, max)\n\t}\n}\n"
        },
        {
          "name": "attack_windows.go",
          "type": "blob",
          "size": 0.0908203125,
          "content": "package main\n\nimport \"flag\"\n\nfunc systemSpecificFlags(fs *flag.FlagSet, opts *attackOpts) {}\n"
        },
        {
          "name": "dump.go",
          "type": "blob",
          "size": 0.2001953125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n)\n\nfunc dumpCmd() command {\n\treturn command{fn: func([]string) error {\n\t\treturn fmt.Errorf(\"vegeta dump has been deprecated and succeeded by the vegeta encode command\")\n\t}}\n}\n"
        },
        {
          "name": "encode.go",
          "type": "blob",
          "size": 2.5625,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\n\tvegeta \"github.com/tsenart/vegeta/v12/lib\"\n)\n\nconst (\n\tencodingCSV  = \"csv\"\n\tencodingGob  = \"gob\"\n\tencodingJSON = \"json\"\n)\n\nconst encodeUsage = `Usage: vegeta encode [options] [<file>...]\n\nEncodes vegeta attack results from one encoding to another.\nThe supported encodings are Gob (binary), CSV and JSON.\nEach input file may have a different encoding which is detected\nautomatically.\n\nThe CSV encoder doesn't write a header. The columns written by it are:\n\n   1. Unix timestamp in nanoseconds since epoch\n   2. HTTP status code\n   3. Request latency in nanoseconds\n   4. Bytes out\n   5. Bytes in\n   6. Error\n   7. Base64 encoded response body\n   8. Attack name\n   9. Sequence number of request\n  10. Method\n  11. URL\n  12. Base64 encoded response headers\n\nArguments:\n  <file>  A file with vegeta attack results encoded with one of\n          the supported encodings (gob | json | csv) [default: stdin]\n\nOptions:\n  --to      Output encoding (gob | json | csv) [default: json]\n  --output  Output file [default: stdout]\n\nExamples:\n  echo \"GET http://:80\" | vegeta attack -rate=1/s > results.gob\n  cat results.gob | vegeta encode | jq -c 'del(.body)' | vegeta encode -to gob\n`\n\nfunc encodeCmd() command {\n\tencs := \"[\" + strings.Join([]string{encodingCSV, encodingGob, encodingJSON}, \", \") + \"]\"\n\tfs := flag.NewFlagSet(\"vegeta encode\", flag.ExitOnError)\n\tto := fs.String(\"to\", encodingJSON, \"Output encoding \"+encs)\n\toutput := fs.String(\"output\", \"stdout\", \"Output file\")\n\n\tfs.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", encodeUsage)\n\t}\n\n\treturn command{fs, func(args []string) error {\n\t\tfs.Parse(args)\n\t\tfiles := fs.Args()\n\t\tif len(files) == 0 {\n\t\t\tfiles = append(files, \"stdin\")\n\t\t}\n\t\treturn encode(files, *to, *output)\n\t}}\n}\n\nfunc encode(files []string, to, output string) error {\n\tdec, mc, err := decoder(files)\n\tdefer mc.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tout, err := file(output, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tvar enc vegeta.Encoder\n\tswitch to {\n\tcase encodingCSV:\n\t\tenc = vegeta.NewCSVEncoder(out)\n\tcase encodingGob:\n\t\tenc = vegeta.NewEncoder(out)\n\tcase encodingJSON:\n\t\tenc = vegeta.NewJSONEncoder(out)\n\tdefault:\n\t\treturn fmt.Errorf(\"encode: unknown encoding %q\", to)\n\t}\n\n\tsigch := make(chan os.Signal, 1)\n\tsignal.Notify(sigch, os.Interrupt)\n\n\tfor {\n\t\tselect {\n\t\tcase <-sigch:\n\t\t\treturn nil\n\t\tdefault:\n\t\t}\n\n\t\tvar r vegeta.Result\n\t\tif err = dec.Decode(&r); err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\treturn err\n\t\t} else if err = enc.Encode(&r); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "file.go",
          "type": "blob",
          "size": 1.1044921875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\tvegeta \"github.com/tsenart/vegeta/v12/lib\"\n)\n\nfunc file(name string, create bool) (*os.File, error) {\n\tswitch name {\n\tcase \"stdin\":\n\t\treturn os.Stdin, nil\n\tcase \"stdout\":\n\t\treturn os.Stdout, nil\n\tdefault:\n\t\tif create {\n\t\t\treturn os.Create(name)\n\t\t}\n\t\treturn os.Open(name)\n\t}\n}\n\nfunc decoder(files []string) (vegeta.Decoder, io.Closer, error) {\n\tcloser := make(multiCloser, 0, len(files))\n\tdecs := make([]vegeta.Decoder, 0, len(files))\n\tfor _, f := range files {\n\t\trc, err := file(f, false)\n\t\tif err != nil {\n\t\t\treturn nil, closer, err\n\t\t}\n\n\t\tdec := vegeta.DecoderFor(rc)\n\t\tif dec == nil {\n\t\t\treturn nil, closer, fmt.Errorf(\"encode: can't detect encoding of %q\", f)\n\t\t}\n\n\t\tdecs = append(decs, dec)\n\t\tcloser = append(closer, rc)\n\t}\n\treturn vegeta.NewRoundRobinDecoder(decs...), closer, nil\n}\n\ntype multiCloser []io.Closer\n\nfunc (mc multiCloser) Close() error {\n\tvar errs []string\n\tfor _, c := range mc {\n\t\tif err := c.Close(); err != nil {\n\t\t\terrs = append(errs, err.Error())\n\t\t}\n\t}\n\n\tif len(errs) > 0 {\n\t\treturn errors.New(strings.Join(errs, \"; \"))\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "flags.go",
          "type": "blob",
          "size": 4.3154296875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"net/http\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/c2h5oh/datasize\"\n\tvegeta \"github.com/tsenart/vegeta/v12/lib\"\n)\n\n// headers is the http.Header used in each target request\n// it is defined here to implement the flag.Value interface\n// in order to support multiple identical flags for request header\n// specification\ntype headers struct{ http.Header }\n\nfunc (h headers) String() string {\n\tbuf := &bytes.Buffer{}\n\tif err := h.Write(buf); err != nil {\n\t\treturn \"\"\n\t}\n\treturn buf.String()\n}\n\n// Set implements the flag.Value interface for a map of HTTP Headers.\nfunc (h headers) Set(value string) error {\n\tparts := strings.SplitN(value, \":\", 2)\n\tif len(parts) != 2 {\n\t\treturn fmt.Errorf(\"header '%s' has a wrong format\", value)\n\t}\n\tkey, val := strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1])\n\tif key == \"\" || val == \"\" {\n\t\treturn fmt.Errorf(\"header '%s' has a wrong format\", value)\n\t}\n\t// Add key/value directly to the http.Header (map[string][]string).\n\t// http.Header.Add() canonicalizes keys but vegeta is used\n\t// to test systems that require case-sensitive headers.\n\th.Header[key] = append(h.Header[key], val)\n\treturn nil\n}\n\n// localAddr implements the Flag interface for parsing net.IPAddr\ntype localAddr struct{ *net.IPAddr }\n\nfunc (ip *localAddr) Set(value string) (err error) {\n\tip.IPAddr, err = net.ResolveIPAddr(\"ip\", value)\n\treturn\n}\n\n// csl implements the flag.Value interface for comma separated lists\ntype csl []string\n\nfunc (l *csl) Set(v string) error {\n\t*l = strings.Split(v, \",\")\n\treturn nil\n}\n\nfunc (l csl) String() string { return strings.Join(l, \",\") }\n\ntype rateFlag struct{ *vegeta.Rate }\n\nfunc (f *rateFlag) Set(v string) (err error) {\n\tif v == \"infinity\" {\n\t\treturn nil\n\t}\n\n\tps := strings.SplitN(v, \"/\", 2)\n\tswitch len(ps) {\n\tcase 1:\n\t\tps = append(ps, \"1s\")\n\tcase 0:\n\t\treturn fmt.Errorf(\"-rate format %q doesn't match the \\\"freq/duration\\\" format (i.e. 50/1s)\", v)\n\t}\n\n\tf.Freq, err = strconv.Atoi(ps[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif f.Freq == 0 {\n\t\treturn nil\n\t}\n\n\tswitch ps[1] {\n\tcase \"ns\", \"us\", \"¬µs\", \"ms\", \"s\", \"m\", \"h\":\n\t\tps[1] = \"1\" + ps[1]\n\t}\n\n\tf.Per, err = time.ParseDuration(ps[1])\n\treturn err\n}\n\nfunc (f *rateFlag) String() string {\n\tif f.Rate == nil {\n\t\treturn \"\"\n\t}\n\treturn fmt.Sprintf(\"%d/%s\", f.Freq, f.Per)\n}\n\ntype maxBodyFlag struct{ n *int64 }\n\nfunc (f *maxBodyFlag) Set(v string) (err error) {\n\tif v == \"-1\" {\n\t\t*(f.n) = -1\n\t\treturn nil\n\t}\n\n\tvar ds datasize.ByteSize\n\tif err = ds.UnmarshalText([]byte(v)); err != nil {\n\t\treturn err\n\t}\n\n\tif ds > math.MaxInt64 {\n\t\treturn fmt.Errorf(\"-max-body=%d overflows int64\", ds)\n\t}\n\n\t*(f.n) = int64(ds)\n\treturn nil\n}\n\nfunc (f *maxBodyFlag) String() string {\n\tif f.n == nil {\n\t\treturn \"\"\n\t} else if *(f.n) == -1 {\n\t\treturn \"-1\"\n\t}\n\treturn datasize.ByteSize(*(f.n)).String()\n}\n\ntype dnsTTLFlag struct{ ttl *time.Duration }\n\nfunc (f *dnsTTLFlag) Set(v string) (err error) {\n\tif v == \"-1\" {\n\t\t*(f.ttl) = -1\n\t\treturn nil\n\t}\n\n\t*(f.ttl), err = time.ParseDuration(v)\n\treturn err\n}\n\nfunc (f *dnsTTLFlag) String() string {\n\tif f.ttl == nil {\n\t\treturn \"\"\n\t} else if *(f.ttl) == -1 {\n\t\treturn \"-1\"\n\t}\n\treturn f.ttl.String()\n}\n\nconst connectToFormat = \"src:port:dst:port\"\n\ntype connectToFlag struct {\n\taddrMap *map[string][]string\n}\n\nfunc (c *connectToFlag) String() string {\n\tif c.addrMap == nil {\n\t\treturn \"\"\n\t}\n\n\taddrMappings := make([]string, 0, len(*c.addrMap))\n\tfor k, v := range *c.addrMap {\n\t\taddrMappings = append(addrMappings, k+\":\"+strings.Join(v, \",\"))\n\t}\n\n\tsort.Strings(addrMappings)\n\treturn strings.Join(addrMappings, \";\")\n}\n\nfunc (c *connectToFlag) Set(s string) error {\n\tif c.addrMap == nil {\n\t\treturn nil\n\t}\n\n\tif *c.addrMap == nil {\n\t\t*c.addrMap = make(map[string][]string)\n\t}\n\n\tparts := strings.Split(s, \":\")\n\tif len(parts) != 4 {\n\t\treturn fmt.Errorf(\"invalid -connect-to %q, expected format: %s\", s, connectToFormat)\n\t}\n\tsrcAddr := parts[0] + \":\" + parts[1]\n\tdstAddr := parts[2] + \":\" + parts[3]\n\n\t// Parse source address\n\tif _, _, err := net.SplitHostPort(srcAddr); err != nil {\n\t\treturn fmt.Errorf(\"invalid source address expression [%s], expected address:port\", srcAddr)\n\t}\n\n\t// Parse destination address\n\tif _, _, err := net.SplitHostPort(dstAddr); err != nil {\n\t\treturn fmt.Errorf(\"invalid destination address expression [%s], expected address:port\", dstAddr)\n\t}\n\n\t(*c.addrMap)[srcAddr] = append((*c.addrMap)[srcAddr], dstAddr)\n\n\treturn nil\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.8193359375,
          "content": "module github.com/tsenart/vegeta/v12\n\ngo 1.22\n\nrequire (\n\tgithub.com/alecthomas/jsonschema v0.0.0-20220216202328-9eeeec9d044b\n\tgithub.com/bmizerany/perks v0.0.0-20230307044200-03f9df79da1e\n\tgithub.com/c2h5oh/datasize v0.0.0-20231215233829-aa82cc1e6500\n\tgithub.com/dgryski/go-gk v0.0.0-20200319235926-a69029f61654\n\tgithub.com/dgryski/go-lttb v0.0.0-20230207170358-f8fc36cdbff1\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/influxdata/tdigest v0.0.1\n\tgithub.com/mailru/easyjson v0.7.7\n\tgithub.com/miekg/dns v1.1.61\n\tgithub.com/prometheus/client_golang v1.19.1\n\tgithub.com/prometheus/prometheus v0.53.1\n\tgithub.com/rs/dnscache v0.0.0-20230804202142-fc85eb664529\n\tgithub.com/streadway/quantile v0.0.0-20220407130108-4246515d968d\n\tgithub.com/tsenart/go-tsz v0.0.0-20180814235614-0bd30b3df1c3\n\tgolang.org/x/net v0.27.0\n\tpgregory.net/rapid v1.1.0\n)\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.3.0 // indirect\n\tgithub.com/gogo/protobuf v1.3.2 // indirect\n\tgithub.com/golang/protobuf v1.5.4 // indirect\n\tgithub.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc // indirect\n\tgithub.com/iancoleman/orderedmap v0.3.0 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect\n\tgithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect\n\tgithub.com/pkg/errors v0.9.1 // indirect\n\tgithub.com/prometheus/client_model v0.6.1 // indirect\n\tgithub.com/prometheus/common v0.55.0 // indirect\n\tgithub.com/prometheus/procfs v0.15.1 // indirect\n\tgolang.org/x/exp v0.0.0-20240119083558-1b970713d09a // indirect\n\tgolang.org/x/mod v0.19.0 // indirect\n\tgolang.org/x/sync v0.7.0 // indirect\n\tgolang.org/x/sys v0.22.0 // indirect\n\tgolang.org/x/text v0.16.0 // indirect\n\tgolang.org/x/tools v0.23.0 // indirect\n\tgoogle.golang.org/protobuf v1.34.2 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 15.4423828125,
          "content": "github.com/alecthomas/jsonschema v0.0.0-20220216202328-9eeeec9d044b h1:doCpXjVwui6HUN+xgNsNS3SZ0/jUZ68Eb+mJRNOZfog=\ngithub.com/alecthomas/jsonschema v0.0.0-20220216202328-9eeeec9d044b/go.mod h1:/n6+1/DWPltRLWL/VKyUxg6tzsl5kHUCcraimt4vr60=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bmizerany/perks v0.0.0-20230307044200-03f9df79da1e h1:mWOqoK5jV13ChKf/aF3plwQ96laasTJgZi4f1aSOu+M=\ngithub.com/bmizerany/perks v0.0.0-20230307044200-03f9df79da1e/go.mod h1:ac9efd0D1fsDb3EJvhqgXRbFx7bs2wqZ10HQPeU8U/Q=\ngithub.com/c2h5oh/datasize v0.0.0-20220606134207-859f65c6625b h1:6+ZFm0flnudZzdSE0JxlhR2hKnGPcNB35BjQf4RYQDY=\ngithub.com/c2h5oh/datasize v0.0.0-20220606134207-859f65c6625b/go.mod h1:S/7n9copUssQ56c7aAgHqftWO4LTf4xY6CGWt8Bc+3M=\ngithub.com/c2h5oh/datasize v0.0.0-20231215233829-aa82cc1e6500 h1:6lhrsTEnloDPXyeZBvSYvQf8u86jbKehZPVDDlkgDl4=\ngithub.com/c2h5oh/datasize v0.0.0-20231215233829-aa82cc1e6500/go.mod h1:S/7n9copUssQ56c7aAgHqftWO4LTf4xY6CGWt8Bc+3M=\ngithub.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=\ngithub.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=\ngithub.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.2-0.20180830191138-d8f796af33cc h1:U9qPSI2PIWSS1VwoXQT9A3Wy9MM3WgvqSxFWenqJduM=\ngithub.com/dgryski/go-gk v0.0.0-20200319235926-a69029f61654 h1:XOPLOMn/zT4jIgxfxSsoXPxkrzz0FaCHwp33x5POJ+Q=\ngithub.com/dgryski/go-gk v0.0.0-20200319235926-a69029f61654/go.mod h1:qm+vckxRlDt0aOla0RYJJVeqHZlWfOm2UIxHaqPB46E=\ngithub.com/dgryski/go-lttb v0.0.0-20230207170358-f8fc36cdbff1 h1:dxwR3CStJdJamsIoMPCmxuIfBAPTgmzvFax+MvFav3M=\ngithub.com/dgryski/go-lttb v0.0.0-20230207170358-f8fc36cdbff1/go.mod h1:UwftcHUI/qTYvLAxrWmANuRckf8+08O3C3hwStvkhDU=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/golang/protobuf v1.5.4 h1:i7eJL8qZTpSEXOPTxNKhASYpMn+8e5Q6AdndVa1dWek=\ngithub.com/golang/protobuf v1.5.4/go.mod h1:lnTiLA8Wa4RWRcIUkrtSVa5nRhsEGBg48fD6rSs7xps=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/grafana/regexp v0.0.0-20221122212121-6b5c0a4cb7fd h1:PpuIBO5P3e9hpqBD0O/HjhShYuM6XE0i/lbE6J94kww=\ngithub.com/grafana/regexp v0.0.0-20221122212121-6b5c0a4cb7fd/go.mod h1:M5qHK+eWfAv8VR/265dIuEpL3fNfeC21tXXp9itM24A=\ngithub.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc h1:GN2Lv3MGO7AS6PrRoT6yV5+wkrOpcszoIsO4+4ds248=\ngithub.com/grafana/regexp v0.0.0-20240518133315-a468a5bfb3bc/go.mod h1:+JKpmjMGhpgPL+rXZ5nsZieVzvarn86asRlBg4uNGnk=\ngithub.com/iancoleman/orderedmap v0.0.0-20190318233801-ac98e3ecb4b0/go.mod h1:N0Wam8K1arqPXNWjMo21EXnBPOPp36vB07FNRdD2geA=\ngithub.com/iancoleman/orderedmap v0.3.0 h1:5cbR2grmZR/DiVt+VJopEhtVs9YGInGIxAoMJn+Ichc=\ngithub.com/iancoleman/orderedmap v0.3.0/go.mod h1:XuLcCUkdL5owUCQeF2Ue9uuw1EptkJDkXXS7VoV7XGE=\ngithub.com/influxdata/tdigest v0.0.1 h1:XpFptwYmnEKUqmkcDjrzffswZ3nvNeevbUSLPP/ZzIY=\ngithub.com/influxdata/tdigest v0.0.1/go.mod h1:Z0kXnxzbTC2qrx4NaIzYkE1k66+6oEDQTvL95hQFh5Y=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/mailru/easyjson v0.7.7 h1:UGYAvKxe3sBsEDzO8ZeWOSlIQfWFlxbzLZe7hwFURr0=\ngithub.com/mailru/easyjson v0.7.7/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.4 h1:mmDVorXM7PCGKw94cs5zkfA9PSy5pEvNWRP0ET0TIVo=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.4/go.mod h1:BSXmuO+STAnVfrANrmjBb36TMTDstsz7MSK+HVaYKv4=\ngithub.com/miekg/dns v1.1.56 h1:5imZaSeoRNvpM9SzWNhEcP9QliKiz20/dA2QabIGVnE=\ngithub.com/miekg/dns v1.1.56/go.mod h1:cRm6Oo2C8TY9ZS/TqsSrseAcncm74lfK5G+ikN2SWWY=\ngithub.com/miekg/dns v1.1.59 h1:C9EXc/UToRwKLhK5wKU/I4QVsBUc8kE6MkHBkeypWZs=\ngithub.com/miekg/dns v1.1.59/go.mod h1:nZpewl5p6IvctfgrckopVx2OlSEHPRO/U4SYkRklrEk=\ngithub.com/miekg/dns v1.1.61 h1:nLxbwF3XxhwVSm8g9Dghm9MHPaUZuqhPiGL+675ZmEs=\ngithub.com/miekg/dns v1.1.61/go.mod h1:mnAarhS3nWaW+NVP2wTkYVIZyHNJ098SJZUki3eykwQ=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 h1:C3w9PqII01/Oq1c1nUAm88MOHcQC9l5mIlSMApZMrHA=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRIccs7FGNTlIRMkT8wgtp5eCXdBlqhYGL6U=\ngithub.com/prometheus/client_golang v1.17.0 h1:rl2sfwZMtSthVU752MqfjQozy7blglC+1SOtjMAMh+Q=\ngithub.com/prometheus/client_golang v1.17.0/go.mod h1:VeL+gMmOAxkS2IqfCq0ZmHSL+LjWfWDUmp1mBz9JgUY=\ngithub.com/prometheus/client_golang v1.19.1 h1:wZWJDwK+NameRJuPGDhlnFgx8e8HN3XHQeLaYJFJBOE=\ngithub.com/prometheus/client_golang v1.19.1/go.mod h1:mP78NwGzrVks5S2H6ab8+ZZGJLZUq1hoULYBAYBw1Ho=\ngithub.com/prometheus/client_model v0.4.1-0.20230718164431-9a2bf3000d16 h1:v7DLqVdK4VrYkVD5diGdl4sxJurKJEMnODWRJlxV9oM=\ngithub.com/prometheus/client_model v0.4.1-0.20230718164431-9a2bf3000d16/go.mod h1:oMQmHW1/JoDwqLtg57MGgP/Fb1CJEYF2imWWhWtMkYU=\ngithub.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=\ngithub.com/prometheus/client_model v0.6.1/go.mod h1:OrxVMOVHjw3lKMa8+x6HeMGkHMQyHDk9E3jmP2AmGiY=\ngithub.com/prometheus/common v0.44.0 h1:+5BrQJwiBB9xsMygAB3TNvpQKOwlkc25LbISbrdOOfY=\ngithub.com/prometheus/common v0.44.0/go.mod h1:ofAIvZbQ1e/nugmZGz4/qCb9Ap1VoSTIO7x0VV9VvuY=\ngithub.com/prometheus/common v0.55.0 h1:KEi6DK7lXW/m7Ig5i47x0vRzuBsHuvJdi5ee6Y3G1dc=\ngithub.com/prometheus/common v0.55.0/go.mod h1:2SECS4xJG1kd8XF9IcM1gMX6510RAEL65zxzNImwdc8=\ngithub.com/prometheus/procfs v0.11.1 h1:xRC8Iq1yyca5ypa9n1EZnWZkt7dwcoRPQwX/5gwaUuI=\ngithub.com/prometheus/procfs v0.11.1/go.mod h1:eesXgaPo1q7lBpVMoMy0ZOFTth9hBn4W/y0/p/ScXhY=\ngithub.com/prometheus/procfs v0.15.1 h1:YagwOFzUgYfKKHX6Dr+sHT7km/hxC76UB0learggepc=\ngithub.com/prometheus/procfs v0.15.1/go.mod h1:fB45yRUv8NstnjriLhBQLuOUt+WW4BsoGhij/e3PBqk=\ngithub.com/prometheus/prometheus v0.47.2 h1:jWcnuQHz1o1Wu3MZ6nMJDuTI0kU5yJp9pkxh8XEkNvI=\ngithub.com/prometheus/prometheus v0.47.2/go.mod h1:J/bmOSjgH7lFxz2gZhrWEZs2i64vMS+HIuZfmYNhJ/M=\ngithub.com/prometheus/prometheus v0.53.1 h1:B0xu4VuVTKYrIuBMn/4YSUoIPYxs956qsOfcS4rqCuA=\ngithub.com/prometheus/prometheus v0.53.1/go.mod h1:RZDkzs+ShMBDkAPQkLEaLBXpjmDcjhNxU2drUVPgKUU=\ngithub.com/rs/dnscache v0.0.0-20211102005908-e0241e321417 h1:Lt9DzQALzHoDwMBGJ6v8ObDPR0dzr2a6sXTB1Fq7IHs=\ngithub.com/rs/dnscache v0.0.0-20211102005908-e0241e321417/go.mod h1:qe5TWALJ8/a1Lqznoc5BDHpYX/8HU60Hm2AwRmqzxqA=\ngithub.com/rs/dnscache v0.0.0-20230804202142-fc85eb664529 h1:18kd+8ZUlt/ARXhljq+14TwAoKa61q6dX8jtwOf6DH8=\ngithub.com/rs/dnscache v0.0.0-20230804202142-fc85eb664529/go.mod h1:qe5TWALJ8/a1Lqznoc5BDHpYX/8HU60Hm2AwRmqzxqA=\ngithub.com/streadway/quantile v0.0.0-20220407130108-4246515d968d h1:X4+kt6zM/OVO6gbJdAfJR60MGPsqCzbtXNnjoGqdfAs=\ngithub.com/streadway/quantile v0.0.0-20220407130108-4246515d968d/go.mod h1:lbP8tGiBjZ5YWIc2fzuRpTaz0b/53vT6PEs3QuAWzuU=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.3.1-0.20190311161405-34c6fa2dc709/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=\ngithub.com/tsenart/go-tsz v0.0.0-20180814235614-0bd30b3df1c3 h1:pcQGQzTwCg//7FgVywqge1sW9Yf8VMsMdG58MI5kd8s=\ngithub.com/tsenart/go-tsz v0.0.0-20180814235614-0bd30b3df1c3/go.mod h1:SWZznP1z5Ki7hDT2ioqiFKEse8K9tU2OUvaRI0NeGQo=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/exp v0.0.0-20180321215751-8460e604b9de/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20230713183714-613f0c0eb8a1 h1:MGwJjxBy0HJshjDNfLsYO8xppfqWlA5ZT9OhtUUhTNw=\ngolang.org/x/exp v0.0.0-20230713183714-613f0c0eb8a1/go.mod h1:FXUEEKJgO7OQYeo8N01OfiKP8RXMtf6e8aTskBGqWdc=\ngolang.org/x/exp v0.0.0-20240119083558-1b970713d09a h1:Q8/wZp0KX97QFTc2ywcOE0YRjZPVIx+MXInMzdvQqcA=\ngolang.org/x/exp v0.0.0-20240119083558-1b970713d09a/go.mod h1:idGWGoKP1toJGkd5/ig9ZLuPcZBC3ewk7SzmH0uou08=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.12.0 h1:rmsUpXtvNzj340zd98LZ4KntptpfRHwpFOHG188oHXc=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.18.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.19.0 h1:fEdghXQSo20giMthA7cd28ZC+jts4amQ3YMXiP5oMQ8=\ngolang.org/x/mod v0.19.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.15.0 h1:ugBLEUaxABaB5AJqW9enI0ACdci2RUd4eP51NTBvuJ8=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.27.0 h1:5K3Njcw06/l2y9vpGCSdcxWOYHOUk3dVNGDXN+FvAys=\ngolang.org/x/net v0.27.0/go.mod h1:dDi0PyhWNoiUOrAS8uXv/vnScO4wnHQO4mj9fn/RytE=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0 h1:ftCYgMx6zT/asHUrPw8BLLscYtGznsLAnjq5RH9P66E=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.7.0 h1:YsImfSBoP9QPYL0xyKJPq0gcaJdG3rInoqxTWbfQu9M=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.12.0 h1:CM0HF96J0hcLAwsHPJZjfdNzs0gftsLfgKt57wWHJ0o=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.22.0 h1:RI27ohtqKCnwULzJLqkv897zojh5/DwS/ENaMzUOaWI=\ngolang.org/x/sys v0.22.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.13.0 h1:ablQoSUd0tRdKxZewP80B+BaqeKJuVhuRxj/dkrun3k=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.16.0 h1:a94ExnEXNtEwYLGJSIUxnWoxoRz/ZcCsV63ROupILh4=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngolang.org/x/tools v0.0.0-20180525024113-a5b4c53f6e8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.13.0 h1:Iey4qkscZuv0VvIt8E0neZjtPVQFSc870HQ448QgEmQ=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/tools v0.22.0/go.mod h1:aCwcsjqvq7Yqt6TNyX7QMU2enbQ/Gt0bo6krSeEri+c=\ngolang.org/x/tools v0.23.0 h1:SGsXPZ+2l4JsgaCKkx+FQ9YZ5XEtA1GZYuoDjenLjvg=\ngolang.org/x/tools v0.23.0/go.mod h1:pnu6ufv6vQkll6szChhK3C3L/ruaIv5eBeztNG8wtsI=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngonum.org/v1/gonum v0.0.0-20181121035319-3f7ecaa7e8ca h1:PupagGYwj8+I4ubCxcmcBRk3VlUWtTg5huQpZR9flmE=\ngonum.org/v1/gonum v0.0.0-20181121035319-3f7ecaa7e8ca/go.mod h1:Y+Yx5eoAFn32cQvJDxZx5Dpnq+c3wtXuadVZAcxbbBo=\ngonum.org/v1/netlib v0.0.0-20181029234149-ec6d1f5cefe6/go.mod h1:wa6Ws7BG/ESfp6dHfk7C6KdzKA7wR7u/rKwOGE66zvw=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.31.0 h1:g0LDEJHgrBl9N9r17Ru3sqWhkIx2NB67okBHPwC7hs8=\ngoogle.golang.org/protobuf v1.31.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.34.2 h1:6xV6lTsCfpGD21XK49h7MhtcApnLqkfYgPcdHftf6hg=\ngoogle.golang.org/protobuf v1.34.2/go.mod h1:qYOHts0dSfpeUzUFpOMr/WGzszTmLH+DiWniOlNbLDw=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\npgregory.net/rapid v1.1.0 h1:CMa0sjHSru3puNx+J0MIAuiiEV4N0qj8/cMWGBBCsjw=\npgregory.net/rapid v1.1.0/go.mod h1:PY5XlDGj0+V1FCq0o192FdRhpKHGTRIWBgqjDBTrq04=\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 2.3671875,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"runtime\"\n\t\"runtime/pprof\"\n\t\"sort\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcommands := map[string]command{\n\t\t\"attack\": attackCmd(),\n\t\t\"report\": reportCmd(),\n\t\t\"plot\":   plotCmd(),\n\t\t\"encode\": encodeCmd(),\n\t\t\"dump\":   dumpCmd(),\n\t}\n\n\tfs := flag.NewFlagSet(\"vegeta\", flag.ExitOnError)\n\tcpus := fs.Int(\"cpus\", runtime.NumCPU(), \"Number of CPUs to use\")\n\tprofile := fs.String(\"profile\", \"\", \"Enable profiling of [cpu, heap]\")\n\tversion := fs.Bool(\"version\", false, \"Print version and exit\")\n\n\tfs.Usage = func() {\n\t\tfmt.Fprintln(fs.Output(), \"Usage: vegeta [global flags] <command> [command flags]\")\n\t\tfmt.Fprintf(fs.Output(), \"\\nglobal flags:\\n\")\n\t\tfs.PrintDefaults()\n\n\t\tnames := make([]string, 0, len(commands))\n\t\tfor name := range commands {\n\t\t\tnames = append(names, name)\n\t\t}\n\n\t\tsort.Strings(names)\n\t\tfor _, name := range names {\n\t\t\tif cmd := commands[name]; cmd.fs != nil {\n\t\t\t\tfmt.Fprintf(fs.Output(), \"\\n%s command:\\n\", name)\n\t\t\t\tcmd.fs.SetOutput(fs.Output())\n\t\t\t\tcmd.fs.PrintDefaults()\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprintf(fs.Output(), \"%s\\n\", examples)\n\t}\n\n\tfs.Parse(os.Args[1:])\n\n\tif *version {\n\t\tfmt.Printf(\"Version: %s\\nCommit: %s\\nRuntime: %s %s/%s\\nDate: %s\\n\",\n\t\t\tVersion,\n\t\t\tCommit,\n\t\t\truntime.Version(),\n\t\t\truntime.GOOS,\n\t\t\truntime.GOARCH,\n\t\t\tDate,\n\t\t)\n\t\treturn\n\t}\n\n\truntime.GOMAXPROCS(*cpus)\n\n\tfor _, prof := range strings.Split(*profile, \",\") {\n\t\tif prof = strings.TrimSpace(prof); prof == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tf, err := os.Create(prof + \".pprof\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer f.Close()\n\n\t\tswitch {\n\t\tcase strings.HasPrefix(prof, \"cpu\"):\n\t\t\tpprof.StartCPUProfile(f)\n\t\t\tdefer pprof.StopCPUProfile()\n\t\tcase strings.HasPrefix(prof, \"heap\"):\n\t\t\tdefer pprof.Lookup(\"heap\").WriteTo(f, 0)\n\t\t}\n\t}\n\n\targs := fs.Args()\n\tif len(args) == 0 {\n\t\tfs.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tif cmd, ok := commands[args[0]]; !ok {\n\t\tlog.Fatalf(\"Unknown command: %s\", args[0])\n\t} else if err := cmd.fn(args[1:]); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\n// Set at linking time\nvar (\n\tCommit  string\n\tDate    string\n\tVersion string\n)\n\nconst examples = `\nexamples:\n  echo \"GET http://localhost/\" | vegeta attack -duration=5s | tee results.bin | vegeta report\n  vegeta report -type=json results.bin > metrics.json\n  cat results.bin | vegeta plot > plot.html\n  cat results.bin | vegeta report -type=\"hist[0,100ms,200ms,300ms]\"\n`\n\ntype command struct {\n\tfs *flag.FlagSet\n\tfn func(args []string) error\n}\n"
        },
        {
          "name": "plot.go",
          "type": "blob",
          "size": 2.6845703125,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/signal\"\n\n\tvegeta \"github.com/tsenart/vegeta/v12/lib\"\n\t\"github.com/tsenart/vegeta/v12/lib/plot\"\n)\n\nconst plotUsage = `Usage: vegeta plot [options] [<file>...]\n\nOutputs an HTML time series plot of request latencies over time.\nThe X axis represents elapsed time in seconds from the beginning\nof the earliest attack in all input files. The Y axis represents\nrequest latency in milliseconds.\n\nClick and drag to select a region to zoom into. Double click to zoom out.\nChoose a different number on the bottom left corner input field\nto change the moving average window size (in data points).\n\nArguments:\n  <file>  A file with vegeta attack results encoded with one of\n          the supported encodings (gob | json | csv) [default: stdin]\n\nOptions:\n  --title      Title and header of the resulting HTML page.\n               [default: Vegeta Plot]\n  --threshold  Threshold of data points to downsample series to.\n               Series with less than --threshold number of data\n               points are not downsampled. [default: 4000]\n\nExamples:\n  echo \"GET http://:80\" | vegeta attack -name=50qps -rate=50 -duration=5s > results.50qps.bin\n  cat results.50qps.bin | vegeta plot > plot.50qps.html\n  echo \"GET http://:80\" | vegeta attack -name=100qps -rate=100 -duration=5s > results.100qps.bin\n  vegeta plot results.50qps.bin results.100qps.bin > plot.html\n`\n\nfunc plotCmd() command {\n\tfs := flag.NewFlagSet(\"vegeta plot\", flag.ExitOnError)\n\ttitle := fs.String(\"title\", \"Vegeta Plot\", \"Title and header of the resulting HTML page\")\n\tthreshold := fs.Int(\"threshold\", 4000, \"Threshold of data points above which series are downsampled.\")\n\toutput := fs.String(\"output\", \"stdout\", \"Output file\")\n\n\tfs.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", plotUsage)\n\t}\n\n\treturn command{fs, func(args []string) error {\n\t\tfs.Parse(args)\n\t\tfiles := fs.Args()\n\t\tif len(files) == 0 {\n\t\t\tfiles = append(files, \"stdin\")\n\t\t}\n\t\treturn plotRun(files, *threshold, *title, *output)\n\t}}\n}\n\nfunc plotRun(files []string, threshold int, title, output string) error {\n\tdec, mc, err := decoder(files)\n\tdefer mc.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tout, err := file(output, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tsigch := make(chan os.Signal, 1)\n\tsignal.Notify(sigch, os.Interrupt)\n\n\tp := plot.New(\n\t\tplot.Title(title),\n\t\tplot.Downsample(threshold),\n\t\tplot.Label(plot.ErrorLabeler),\n\t)\n\ndecode:\n\tfor {\n\t\tselect {\n\t\tcase <-sigch:\n\t\t\tbreak decode\n\t\tdefault:\n\t\t\tvar r vegeta.Result\n\t\t\tif err = dec.Decode(&r); err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak decode\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err = p.Add(&r); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tp.Close()\n\n\t_, err = p.WriteTo(out)\n\treturn err\n}\n"
        },
        {
          "name": "report.go",
          "type": "blob",
          "size": 3.8955078125,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"time\"\n\n\tvegeta \"github.com/tsenart/vegeta/v12/lib\"\n)\n\nconst reportUsage = `Usage: vegeta report [options] [<file>...]\n\nOutputs a report of attack results.\n\nArguments:\n  <file>  A file with vegeta attack results encoded with one of\n          the supported encodings (gob | json | csv) [default: stdin]\n\nOptions:\n  --type    Which report type to generate (text | json | hist[buckets] | hdrplot).\n            [default: text]\n\n  --every   Write the report to --output at every given interval (e.g 100ms)\n            The default of 0 means the report will only be written after\n            all results have been processed. [default: 0]\n\n  --output  Output file [default: stdout]\n\nExamples:\n  echo \"GET http://:80\" | vegeta attack -rate=10/s > results.gob\n  echo \"GET http://:80\" | vegeta attack -rate=100/s | vegeta encode > results.json\n  vegeta report < results.gob | rg -vU 'Error Set:.*' # Don't show errors\n  vegeta report results.*\n`\n\nfunc reportCmd() command {\n\tfs := flag.NewFlagSet(\"vegeta report\", flag.ExitOnError)\n\ttyp := fs.String(\"type\", \"text\", \"Report type to generate [text, json, hist[buckets], hdrplot]\")\n\tevery := fs.Duration(\"every\", 0, \"Report interval\")\n\toutput := fs.String(\"output\", \"stdout\", \"Output file\")\n\tbuckets := fs.String(\"buckets\", \"\", \"Histogram buckets, e.g.: \\\"[0,1ms,10ms]\\\"\")\n\n\tfs.Usage = func() {\n\t\tfmt.Fprintf(os.Stderr, \"%s\\n\", reportUsage)\n\t}\n\n\treturn command{fs, func(args []string) error {\n\t\tfs.Parse(args)\n\t\tfiles := fs.Args()\n\t\tif len(files) == 0 {\n\t\t\tfiles = append(files, \"stdin\")\n\t\t}\n\t\treturn report(files, *typ, *output, *every, *buckets)\n\t}}\n}\n\nfunc report(files []string, typ, output string, every time.Duration, bucketsStr string) error {\n\tif len(typ) < 4 {\n\t\treturn fmt.Errorf(\"invalid report type: %s\", typ)\n\t}\n\n\tdec, mc, err := decoder(files)\n\tdefer mc.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tout, err := file(output, true)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tvar (\n\t\trep    vegeta.Reporter\n\t\treport vegeta.Report\n\t)\n\n\tswitch typ {\n\tcase \"plot\":\n\t\treturn fmt.Errorf(\"The plot reporter has been deprecated and succeeded by the vegeta plot command\")\n\tcase \"text\":\n\t\tvar m vegeta.Metrics\n\t\trep, report = vegeta.NewTextReporter(&m), &m\n\tcase \"json\":\n\t\tvar m vegeta.Metrics\n\t\tif bucketsStr != \"\" {\n\t\t\tm.Histogram = &vegeta.Histogram{}\n\t\t\tif err := m.Histogram.Buckets.UnmarshalText([]byte(bucketsStr)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\trep, report = vegeta.NewJSONReporter(&m), &m\n\tcase \"hdrplot\":\n\t\tvar m vegeta.Metrics\n\t\trep, report = vegeta.NewHDRHistogramPlotReporter(&m), &m\n\tdefault:\n\t\tswitch {\n\t\tcase strings.HasPrefix(typ, \"hist\"):\n\t\t\tvar hist vegeta.Histogram\n\t\t\tif bucketsStr == \"\" { // Old way\n\t\t\t\tif len(typ) < 6 {\n\t\t\t\t\treturn fmt.Errorf(\"bad buckets: '%s'\", typ[4:])\n\t\t\t\t}\n\t\t\t\tbucketsStr = typ[4:]\n\t\t\t}\n\t\t\tif err := hist.Buckets.UnmarshalText([]byte(bucketsStr)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trep, report = vegeta.NewHistogramReporter(&hist), &hist\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unknown report type: %q\", typ)\n\t\t}\n\t}\n\n\tsigch := make(chan os.Signal, 1)\n\tsignal.Notify(sigch, os.Interrupt)\n\n\tvar ticks <-chan time.Time\n\tif every > 0 {\n\t\tticker := time.NewTicker(every)\n\t\tdefer ticker.Stop()\n\t\tticks = ticker.C\n\t}\n\n\trc, _ := report.(vegeta.Closer)\ndecode:\n\tfor {\n\t\tselect {\n\t\tcase <-sigch:\n\t\t\tbreak decode\n\t\tcase <-ticks:\n\t\t\tif err = clear(out); err != nil {\n\t\t\t\treturn err\n\t\t\t} else if err = writeReport(rep, rc, out); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\tvar r vegeta.Result\n\t\t\tif err = dec.Decode(&r); err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak decode\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treport.Add(&r)\n\t\t}\n\t}\n\n\treturn writeReport(rep, rc, out)\n}\n\nfunc writeReport(r vegeta.Reporter, rc vegeta.Closer, out io.Writer) error {\n\tif rc != nil {\n\t\trc.Close()\n\t}\n\treturn r.Report(out)\n}\n\nfunc clear(out io.Writer) error {\n\tif f, ok := out.(*os.File); ok && f == os.Stdout {\n\t\treturn clearScreen()\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "report_nonwindows.go",
          "type": "blob",
          "size": 0.1884765625,
          "content": "//go:build !windows\n// +build !windows\n\npackage main\n\nimport (\n\t\"os\"\n)\n\nvar escCodes = []byte(\"\\033[2J\\033[0;0H\")\n\nfunc clearScreen() error {\n\t_, err := os.Stdout.Write(escCodes)\n\treturn err\n}\n"
        },
        {
          "name": "report_windows.go",
          "type": "blob",
          "size": 0.1884765625,
          "content": "//go:build windows\n// +build windows\n\npackage main\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc clearScreen() error {\n\tcmd := exec.Command(\"cmd\", \"/c\", \"cls\")\n\tcmd.Stdout = os.Stdout\n\treturn cmd.Run()\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}