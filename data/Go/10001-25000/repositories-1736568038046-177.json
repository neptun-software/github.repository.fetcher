{
  "metadata": {
    "timestamp": 1736568038046,
    "page": 177,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "opencontainers/runc",
      "stars": 12043,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 6.5771484375,
          "content": "---\n# We use Cirrus for RHEL clones (native) and Fedora (in Vagrant), because\n# neither is available on GHA natively, so the only option is VM.\n# In GHA, nested virtualization is only supported on macOS instances, which\n# are slow and flaky.\n\n# NOTE Cirrus execution environments lack a terminal, needed for\n# some integration tests. So we use `ssh -tt` command to fake a terminal.\n\ntask:\n  timeout_in: 30m\n\n  env:\n    DEBIAN_FRONTEND: noninteractive\n    HOME: /root\n    # yamllint disable rule:key-duplicates\n    matrix:\n      DISTRO: fedora\n\n  name: vagrant DISTRO:$DISTRO\n\n  compute_engine_instance:\n    image_project: cirrus-images\n    image: family/docker-kvm\n    platform: linux\n    nested_virtualization: true\n    # CPU limit: `16 / NTASK`: see https://cirrus-ci.org/faq/#are-there-any-limits\n    cpu: 4\n    # Memory limit: `4GB * NCPU`\n    memory: 16G\n\n  host_info_script: |\n    uname -a\n    # -----\n    cat /etc/os-release\n    # -----\n    df -T\n    # -----\n    cat /proc/cpuinfo\n  install_libvirt_vagrant_script: |\n    curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg\n    echo \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\n    sudo sed -i 's/^# deb-src/deb-src/' /etc/apt/sources.list\n    apt-get update\n    apt-get install -y libvirt-daemon libvirt-daemon-system vagrant\n    systemctl enable --now libvirtd\n    apt-get build-dep -y vagrant ruby-libvirt\n    apt-get install -y --no-install-recommends libxslt-dev libxml2-dev libvirt-dev ruby-bundler ruby-dev zlib1g-dev\n    vagrant plugin install vagrant-libvirt\n  vagrant_cache:\n    fingerprint_script: cat Vagrantfile.$DISTRO\n    folder: /root/.vagrant.d/boxes\n  vagrant_up_script: |\n    ln -sf Vagrantfile.$DISTRO Vagrantfile\n    # Retry if it fails (download.fedoraproject.org returns 404 sometimes)\n    vagrant up --no-tty || vagrant up --no-tty\n    mkdir -p -m 0700 /root/.ssh\n    vagrant ssh-config >> /root/.ssh/config\n  guest_info_script: |\n    ssh default 'sh -exc \"uname -a && systemctl --version && df -T && cat /etc/os-release && go version && sestatus && rpm -q container-selinux\"'\n  check_config_script: |\n    ssh default /vagrant/script/check-config.sh\n  unit_tests_script: |\n    ssh default 'sudo -i make -C /vagrant localunittest'\n  integration_systemd_script: |\n    ssh -tt default \"sudo -i make -C /vagrant localintegration RUNC_USE_SYSTEMD=yes\"\n  integration_fs_script: |\n    ssh -tt default \"sudo -i make -C /vagrant localintegration\"\n  integration_systemd_rootless_script: |\n    ssh -tt default \"sudo -i make -C /vagrant localrootlessintegration RUNC_USE_SYSTEMD=yes\"\n  integration_fs_rootless_script: |\n    ssh -tt default \"sudo -i make -C /vagrant localrootlessintegration\"\n\ntask:\n  timeout_in: 30m\n\n  env:\n    HOME: /root\n    CIRRUS_WORKING_DIR: /home/runc\n    GO_VERSION: \"1.23\"\n    BATS_VERSION: \"v1.9.0\"\n    RPMS: gcc git iptables jq glibc-static libseccomp-devel make criu fuse-sshfs container-selinux\n    # yamllint disable rule:key-duplicates\n    matrix:\n      DISTRO: almalinux-8\n      DISTRO: almalinux-9\n\n  name: ci / $DISTRO\n\n  compute_engine_instance:\n    image_project: almalinux-cloud\n    image: family/$DISTRO\n    platform: linux\n    cpu: 4\n    memory: 8G\n\n  install_dependencies_script: |\n    case $DISTRO in\n    *-8)\n      yum config-manager --set-enabled powertools # for glibc-static\n      ;;\n    *-9)\n      dnf config-manager --set-enabled crb # for glibc-static\n      dnf -y install epel-release # for fuse-sshfs\n      # Delegate all cgroup v2 controllers to rootless user via --systemd-cgroup.\n      # The default (since systemd v252) is \"pids memory cpu\".\n      mkdir -p /etc/systemd/system/user@.service.d\n      printf \"[Service]\\nDelegate=yes\\n\" > /etc/systemd/system/user@.service.d/delegate.conf\n      systemctl daemon-reload\n      ;;\n    esac\n    # Work around dnf mirror failures by retrying a few times.\n    for i in $(seq 0 2); do\n      sleep $i\n      yum install -y $RPMS && break\n    done\n    [ $? -eq 0 ] # fail if yum failed\n\n    # Install Go.\n    PREFIX=\"https://go.dev/dl/\"\n    # Find out the latest minor release URL.\n    filename=$(curl -fsSL \"${PREFIX}?mode=json&include=all\" | jq -r --arg Ver \"go$GO_VERSION.\" '. | map(select(.version | contains($Ver))) | first | .files[] | select(.os == \"linux\" and .arch == \"amd64\" and .kind == \"archive\") | .filename')\n    curl -fsSL \"$PREFIX$filename\" | tar Cxz /usr/local\n    # install bats\n    cd /tmp\n    git clone https://github.com/bats-core/bats-core\n    cd bats-core\n    git checkout $BATS_VERSION\n    ./install.sh /usr/local\n    cd -\n    # Add a user for rootless tests\n    useradd -u2000 -m -d/home/rootless -s/bin/bash rootless\n    # Allow root and rootless itself to execute `ssh rootless@localhost` in tests/rootless.sh\n    ssh-keygen -t ecdsa -N \"\" -f /root/rootless.key\n    mkdir -m 0700 -p /home/rootless/.ssh\n    cp /root/rootless.key /home/rootless/.ssh/id_ecdsa\n    cat /root/rootless.key.pub >> /home/rootless/.ssh/authorized_keys\n    chown -R rootless.rootless /home/rootless\n    # set PATH\n    echo 'export PATH=/usr/local/go/bin:/usr/local/bin:$PATH' >> /root/.bashrc\n    # Setup ssh localhost for terminal emulation (script -e did not work)\n    ssh-keygen -t ed25519 -f /root/.ssh/id_ed25519 -N \"\"\n    cat /root/.ssh/id_ed25519.pub >> /root/.ssh/authorized_keys\n    chmod 400 /root/.ssh/authorized_keys\n    ssh-keyscan localhost >> /root/.ssh/known_hosts\n    echo -e \"Host localhost\\n\\tStrictHostKeyChecking no\\t\\nIdentityFile /root/.ssh/id_ed25519\\n\" >> /root/.ssh/config\n    sed -e \"s,PermitRootLogin.*,PermitRootLogin prohibit-password,g\" -i /etc/ssh/sshd_config\n    systemctl restart sshd\n  host_info_script: |\n    uname -a\n    # -----\n    /usr/local/go/bin/go version\n    # -----\n    systemctl --version\n    # -----\n    cat /etc/os-release\n    # -----\n    df -T\n    # -----\n    sestatus\n    # -----\n    cat /proc/cpuinfo\n  check_config_script: |\n    /home/runc/script/check-config.sh\n  unit_tests_script: |\n    ssh -tt localhost \"make -C /home/runc localunittest\"\n  integration_systemd_script: |\n    ssh -tt localhost \"make -C /home/runc localintegration RUNC_USE_SYSTEMD=yes\"\n  integration_fs_script: |\n    ssh -tt localhost \"make -C /home/runc localintegration\"\n  integration_systemd_rootless_script: |\n    case $DISTRO in\n      *-8)\n        echo \"SKIP: integration_systemd_rootless_script requires cgroup v2\"\n        ;;\n      *)\n        ssh -tt localhost \"make -C /home/runc localrootlessintegration RUNC_USE_SYSTEMD=yes\"\n    esac\n  integration_fs_rootless_script: |\n    ssh -tt localhost \"make -C /home/runc localrootlessintegration\"\n"
        },
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.2822265625,
          "content": "---\n# We use GNU indent from the Makefile to format C code in this project. Alas,\n# there is no way to map indent options to clang-format style options in a way\n# to achieve identical results for both formatters.\n#\n# Therefore, let's disable clang-format entirely.\nDisableFormat: true\n...\n"
        },
        {
          "name": ".codespellrc",
          "type": "blob",
          "size": 0.0712890625,
          "content": "[codespell]\nskip = ./vendor,./.git,./go.sum\nignore-words-list = clos,mis\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1748046875,
          "content": "# This file is used by shfmt. See https://EditorConfig.org\n\n# This is a top-most EditorConfig file.\nroot = true\n\n# Ignore the entire \"vendor\" directory.\n[vendor/**]\nignore = true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.111328125,
          "content": "vendor/pkg\n/runc\n/runc-*\n/contrib/cmd/memfd-bind/memfd-bind\n/tests/cmd/_bin\nman/man8\nrelease\nVagrantfile\n.vagrant\n"
        },
        {
          "name": ".golangci-extra.yml",
          "type": "blob",
          "size": 0.3720703125,
          "content": "# This is golangci-lint config file which is used to check new code in\n# github PRs only (see lint-extra in .github/workflows/validate.yml).\n#\n# For the default linter config, see .golangci.yml. This config should\n# only enable additional linters not enabled in the default config.\n\nrun:\n  build-tags:\n    - seccomp\n\nlinters:\n  disable-all: true\n  enable:\n    - godot\n    - revive\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.236328125,
          "content": "# For documentation, see https://golangci-lint.run/usage/configuration/\n\nrun:\n  build-tags:\n    - seccomp\n\nlinters:\n  enable:\n    - gofumpt\n    - errorlint\n    - unconvert\n    - unparam\n\nlinters-settings:\n  govet:\n    enable:\n      - nilness\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 40.9970703125,
          "content": "# Changelog\nThis file documents all notable changes made to this project since runc 1.0.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]\n\n### libcontainer API\n * `configs.CommandHook` struct has changed, Command is now a pointer.\n   Also, `configs.NewCommandHook` now accepts a `*Command`. (#4325)\n\n## [1.2.0] - 2024-10-22\n\n> できるときにできることをやるんだ。それが今だ。\n\n### Added\n * In order to alleviate the remaining concerns around the memory usage and\n   (arguably somewhat unimportant, but measurable) performance overhead of\n   memfds for cloning `/proc/self/exe`, we have added a new protection using\n   `overlayfs` that is used if you have enough privileges and the running\n   kernel supports it. It has effectively no performance nor memory overhead\n   (compared to no cloning at all). (#4448)\n\n### Fixed\n * The original fix for [CVE-2024-45310][cve-2024-45310] was intentionally very\n   limited in scope to make it easier to review, however it also did not handle\n   all possible `os.MkdirAll` cases and thus could lead to regressions. We have\n   switched to the more complete implementation in the newer versions of\n   `github.com/cyphar/filepath-securejoin`. (#4393, #4400, #4421, #4430)\n * In certain situations (a system with lots of mounts or racing mounts) we\n   could accidentally end up leaking mounts from the container into the host.\n   This has been fixed. (#4417)\n * The fallback logic for `O_TMPFILE` clones of `/proc/self/exe` had a minor\n   bug that would cause us to miss non-`noexec` directories and thus fail to\n   start containers on some systems. (#4444)\n * Sometimes the cloned `/proc/self/exe` file descriptor could be placed in a\n   way that it would get clobbered by the Go runtime. We had a fix for this\n   already but it turns out it could still break in rare circumstances, but it\n   has now been fixed. (#4294, #4452)\n\n### Changed\n * It is not possible for `runc kill` to work properly in some specific\n   configurations (such as rootless containers with no cgroups and a shared pid\n   namespace). We now output a warning for such configurations. (#4398)\n * memfd-bind: update the documentation and make path handling with the systemd\n   unit more idiomatic. (#4428)\n * We now use v0.16 of Cilium's eBPF library, including fixes that quite a few\n   downstreams asked for. (#4397, #4396)\n * Some internal `runc init` synchronisation that was no longer necessary (due\n   to the `/proc/self/exe` cloning move to Go) was removed. (#4441)\n\n[cve-2024-45310]: https://github.com/opencontainers/runc/security/advisories/GHSA-jfvp-7x6p-h2pv\n\n## [1.2.0-rc.3] - 2024-09-02\n\n> The supreme happiness of life is the conviction that we are loved.\n\n### Security\n\n * Fix [CVE-2024-45310][cve-2024-45310], a low-severity attack that allowed\n   maliciously configured containers to create empty files and directories on\n   the host.\n\n### Added\n\n * Document build prerequisites for different platforms. (#4353)\n\n### Fixed\n\n * Try to delete exec fifo file when failure in creation. (#4319)\n * Revert \"libcontainer: seccomp: pass around *os.File for notifyfd\". (#4337)\n * Fix link to gvariant documentation in systemd docs. (#4369)\n\n### Changed\n\n * Remove pre-go1.17 build-tags. (#4329)\n * libct/userns: assorted (godoc) improvements. (#4330)\n * libct/userns: split userns detection from internal userns code. (#4331)\n * rootfs: consolidate mountpoint creation logic. (#4359)\n * Add Go 1.23, drop 1.21. (#4360)\n * Revert \"allow overriding VERSION value in Makefile\" and add `EXTRA_VERSION`.\n   (#4370)\n * Mv contrib/cmd tests/cmd (except memfd-bind). (#4377)\n * Makefile: Don't read COMMIT, BUILDTAGS, `EXTRA_BUILDTAGS` from env vars.\n   (#4380)\n\n[cve-2024-45310]: https://github.com/opencontainers/runc/security/advisories/GHSA-jfvp-7x6p-h2pv\n\n## [1.2.0-rc.2] - 2024-06-26\n\n> TRUE or FALSE, it's a problem!\n\n### Important Notes\n\n * libcontainer/cgroups users who want to manage cgroup devices need to explicitly\n   import libcontainer/cgroups/devices. (#3452, #4248)\n * If building with Go 1.22.x, make sure to use 1.22.4 or a later version.\n   (see #4233 for more details)\n\n### Added\n\n * CI: add actuated-arm64. (#4142, #4252, #4276)\n\n### Fixed\n\n * cgroup v2: do not set swap to 0 or unlimited when it's not available. (#4188)\n * Set the default value of CpuBurst to nil instead of 0. (#4210, #4211)\n * libct/cg: write unified resources line by line. (#4186)\n * libct.Start: fix locking, do not allow a second container init. (#4271)\n * Fix tests in debian testing (mount_sshfs.bats). (#4245)\n * Fix codespell warnings. (#4291)\n * libct/cg/dev: fix TestSetV1Allow panic. (#4295)\n * tests/int/scheduler: require smp. (#4298)\n\n### Changed\n\n * libct/cg/fs: don't write cpu_burst twice on ENOENT. (#4259)\n * Make trimpath optional. (#3908)\n * Remove unused system.Execv. (#4268)\n * Stop blacklisting Go 1.22+, drop Go < 1.21 support, use Go 1.22 in CI. (#4292)\n * Improve some error messages for runc exec. (#4320)\n * ci/gha: bump golangci-lint[-action]. (#4255)\n * tests/int/tty: increase the timeout. (#4260)\n * [ci] use go mod instead of go get in spec.bats. (#4264)\n * tests/int/checkpoint: rm double logging. (#4251)\n * .cirrus.yml: rm FIXME from rootless fs on CentOS 7. (#4279)\n * Dockerfile: bump Debian to 12, Go to 1.21. (#4296)\n * ci/gha: switch to ubuntu 24.04. (#4286)\n * Vagrantfile.fedora: bump to F40. (#4285)\n\n## [1.2.0-rc.1] - 2024-04-03\n\n> There's a frood who really knows where his towel is.\n\n`runc` now requires a minimum of Go 1.20 to compile.\n\n> **NOTE**: runc currently will not work properly when compiled with Go 1.22 or\n> newer. This is due to some unfortunate glibc behaviour that Go 1.22\n> exacerbates in a way that results in containers not being able to start on\n> some systems. [See this issue for more information.][runc-4233]\n\n[runc-4233]: https://github.com/opencontainers/runc/issues/4233\n\n### Breaking\n\n * Several aspects of how mount options work has been adjusted in a way that\n   could theoretically break users that have very strange mount option strings.\n   This was necessary to fix glaring issues in how mount options were being\n   treated. The key changes are:\n\n   - Mount options on bind-mounts that clear a mount flag are now always\n     applied. Previously, if a user requested a bind-mount with only clearing\n     options (such as `rw,exec,dev`) the options would be ignored and the\n     original bind-mount options would be set. Unfortunately this also means\n     that container configurations which specified only clearing mount options\n     will now actually get what they asked for, which could break existing\n     containers (though it seems unlikely that a user who requested a specific\n     mount option would consider it \"broken\" to get the mount options they\n     asked foruser who requested a specific mount option would consider it\n     \"broken\" to get the mount options they asked for). This also allows us to\n     silently add locked mount flags the user *did not explicitly request to be\n     cleared* in rootless mode, allowing for easier use of bind-mounts for\n     rootless containers. (#3967)\n\n   - Container configurations using bind-mounts with superblock mount flags\n     (i.e. filesystem-specific mount flags, referred to as \"data\" in\n     `mount(2)`, as opposed to VFS generic mount flags like `MS_NODEV`) will\n     now return an error. This is because superblock mount flags will also\n     affect the host mount (as the superblock is shared when bind-mounting),\n     which is obviously not acceptable. Previously, these flags were silently\n     ignored so this change simply tells users that runc cannot fulfil their\n     request rather than just ignoring it. (#3990)\n\n   If any of these changes cause problems in real-world workloads, please [open\n   an issue](https://github.com/opencontainers/runc/issues/new/choose) so we\n   can adjust the behaviour to avoid compatibility issues.\n\n### Added\n\n * runc has been updated to OCI runtime-spec 1.2.0, and supports all Linux\n   features with a few minor exceptions. See\n   [`docs/spec-conformance.md`](https://github.com/opencontainers/runc/blob/v1.2.0-rc.1/docs/spec-conformance.md)\n   for more details.\n * runc now supports id-mapped mounts for bind-mounts (with no restrictions on\n   the mapping used for each mount). Other mount types are not currently\n   supported. This feature requires `MOUNT_ATTR_IDMAP` kernel support (Linux\n   5.12 or newer) as well as kernel support for the underlying filesystem used\n   for the bind-mount. See [`mount_setattr(2)`][mount_setattr.2] for a list of\n   supported filesystems and other restrictions. (#3717, #3985, #3993)\n * Two new mechanisms for reducing the memory usage of our protections against\n   [CVE-2019-5736][cve-2019-5736] have been introduced:\n   - `runc-dmz` is a minimal binary (~8K) which acts as an additional execve\n     stage, allowing us to only need to protect the smaller binary. It should\n     be noted that there have been several compatibility issues reported with\n     the usage of `runc-dmz` (namely related to capabilities and SELinux). As\n     such, this mechanism is **opt-in** and can be enabled by running `runc`\n     with the environment variable `RUNC_DMZ=true` (setting this environment\n     variable in `config.json` will have no effect). This feature can be\n     disabled at build time using the `runc_nodmz` build tag. (#3983, #3987)\n   - `contrib/memfd-bind` is a helper daemon which will bind-mount a memfd copy\n     of `/usr/bin/runc` on top of `/usr/bin/runc`. This entirely eliminates\n     per-container copies of the binary, but requires care to ensure that\n     upgrades to runc are handled properly, and requires a long-running daemon\n     (unfortunately memfds cannot be bind-mounted directly and thus require a\n     daemon to keep them alive). (#3987)\n * runc will now use `cgroup.kill` if available to kill all processes in a\n   container (such as when doing `runc kill`). (#3135, #3825)\n * Add support for setting the umask for `runc exec`. (#3661)\n * libct/cg: support `SCHED_IDLE` for runc cgroupfs. (#3377)\n * checkpoint/restore: implement `--manage-cgroups-mode=ignore`. (#3546)\n * seccomp: refactor flags support; add flags to features, set `SPEC_ALLOW` by\n   default. (#3588)\n * libct/cg/sd: use systemd v240+ new `MAJOR:*` syntax. (#3843)\n * Support CFS bandwidth burst for CPU. (#3749, #3145)\n * Support time namespaces. (#3876)\n * Reduce the `runc` binary size by ~11% by updating\n   `github.com/checkpoint-restore/go-criu`. (#3652)\n * Add `--pidfd-socket` to `runc run` and `runc exec` to allow for management\n   processes to receive a pidfd for the new process, allowing them to avoid pid\n   reuse attacks. (#4045)\n\n[mount_setattr.2]: https://man7.org/linux/man-pages/man2/mount_setattr.2.html\n[cve-2019-5736]: https://github.com/advisories/GHSA-gxmr-w5mj-v8hh\n\n### Deprecated\n\n * `runc` option `--criu` is now ignored (with a warning), and the option will\n   be removed entirely in a future release. Users who need a non-standard\n   `criu` binary should rely on the standard way of looking up binaries in\n   `$PATH`. (#3316)\n * `runc kill` option `-a` is now deprecated. Previously, it had to be specified\n   to kill a container (with SIGKILL) which does not have its own private PID\n   namespace (so that runc would send SIGKILL to all processes). Now, this is\n   done automatically. (#3864, #3825)\n * `github.com/opencontainers/runc/libcontainer/user` is now deprecated, please\n   use `github.com/moby/sys/user` instead. It will be removed in a future\n   release. (#4017)\n\n### Changed\n\n * When Intel RDT feature is not available, its initialization is skipped,\n   resulting in slightly faster `runc exec` and `runc run`. (#3306)\n * `runc features` is no longer experimental. (#3861)\n * libcontainer users that create and kill containers from a daemon process\n   (so that the container init is a child of that process) must now implement\n   a proper child reaper in case a container does not have its own private PID\n   namespace, as documented in `container.Signal`. (#3825)\n * Sum `anon` and `file` from `memory.stat` for cgroupv2 root usage,\n   as the root does not have `memory.current` for cgroupv2.\n   This aligns cgroupv2 root usage more closely with cgroupv1 reporting.\n   Additionally, report root swap usage as sum of swap and memory usage,\n   aligned with v1 and existing non-root v2 reporting. (#3933)\n * Add `swapOnlyUsage` in `MemoryStats`. This field reports swap-only usage.\n   For cgroupv1, `Usage` and `Failcnt` are set by subtracting memory usage\n   from memory+swap usage. For cgroupv2, `Usage`, `Limit`, and `MaxUsage`\n   are set. (#4010)\n * libcontainer users that create and kill containers from a daemon process\n   (so that the container init is a child of that process) must now implement\n   a proper child reaper in case a container does not have its own private PID\n   namespace, as documented in `container.Signal`. (#3825)\n * libcontainer: `container.Signal` no longer takes an `all` argument. Whether\n   or not it is necessary to kill all processes in the container individually\n   is now determined automatically. (#3825, #3885)\n * seccomp: enable seccomp binary tree optimization. (#3405)\n * `runc run`/`runc exec`: ignore SIGURG. (#3368)\n * Remove tun/tap from the default device allowlist. (#3468)\n * `runc --root non-existent-dir list` now reports an error for non-existent\n   root directory. (#3374)\n\n### Fixed\n\n * In case the runc binary resides on tmpfs, `runc init` no longer re-execs\n   itself twice. (#3342)\n * Our seccomp `-ENOSYS` stub now correctly handles multiplexed syscalls on\n   s390 and s390x. This solves the issue where syscalls the host kernel did not\n   support would return `-EPERM` despite the existence of the `-ENOSYS` stub\n   code (this was due to how s390x does syscall multiplexing). (#3474)\n * Remove tun/tap from the default device rules. (#3468)\n * specconv: avoid mapping \"acl\" to `MS_POSIXACL`. (#3739)\n * libcontainer: fix private PID namespace detection when killing the\n   container. (#3866, #3825)\n * systemd socket notification: fix race where runc exited before systemd\n   properly handled the `READY` notification. (#3291, #3293)\n * The `-ENOSYS` seccomp stub is now always generated for the native\n   architecture that `runc` is running on. This is needed to work around some\n   arguably specification-incompliant behaviour from Docker on architectures\n   such as ppc64le, where the allowed architecture list is set to `null`. This\n   ensures that we always generate at least one `-ENOSYS` stub for the native\n   architecture even with these weird configs. (#4219)\n\n### Removed\n\n * In order to fix performance issues in the \"lightweight\" bindfd protection\n   against [CVE-2019-5736][cve-2019-5736], the temporary `ro` bind-mount of\n   `/proc/self/exe` has been removed. runc now creates a binary copy in all\n   cases. See the above notes about `memfd-bind` and `runc-dmz` as well as\n   `contrib/cmd/memfd-bind/README.md` for more information about how this\n   (minor) change in memory usage can be further reduced. (#3987, #3599, #2532,\n   #3931)\n * libct/cg: Remove `EnterPid` (a function with no users). (#3797)\n * libcontainer: Remove `{Pre,Post}MountCmds` which were never used and are\n   obsoleted by more generic container hooks. (#3350)\n\n[cve-2019-5736]: https://github.com/advisories/GHSA-gxmr-w5mj-v8hh\n\n## [1.1.15] - 2024-10-07\n\n> How, dear sir, did you cross the flood? By not stopping, friend, and by not\n> straining I crossed the flood.\n\n### Fixed\n\n * The `-ENOSYS` seccomp stub is now always generated for the native\n   architecture that `runc` is running on. This is needed to work around some\n   arguably specification-incompliant behaviour from Docker on architectures\n   such as ppc64le, where the allowed architecture list is set to `null`. This\n   ensures that we always generate at least one `-ENOSYS` stub for the native\n   architecture even with these weird configs. (#4391)\n * On a system with older kernel, reading `/proc/self/mountinfo` may skip some\n   entries, as a consequence runc may not properly set mount propagation,\n   causing container mounts leak onto the host mount namespace. (#2404, #4425)\n\n### Removed\n\n * In order to fix performance issues in the \"lightweight\" bindfd protection\n   against [CVE-2019-5736], the temporary `ro` bind-mount of `/proc/self/exe`\n   has been removed. runc now creates a binary copy in all cases. (#4392, #2532)\n\n[CVE-2019-5736]: https://www.openwall.com/lists/oss-security/2019/02/11/2\n\n## [1.1.14] - 2024-09-03\n\n> 年を取っていいことは、驚かなくなることね。\n\n### Security\n\n * Fix [CVE-2024-45310][cve-2024-45310], a low-severity attack that allowed\n   maliciously configured containers to create empty files and directories on\n   the host.\n\n[cve-2024-45310]: https://github.com/opencontainers/runc/security/advisories/GHSA-jfvp-7x6p-h2pv\n\n### Added\n\n * Add support for Go 1.23. (#4360, #4372)\n\n### Fixed\n\n * Revert \"allow overriding VERSION value in Makefile\" and add `EXTRA_VERSION`.\n   (#4370, #4382)\n * rootfs: consolidate mountpoint creation logic. (#4359)\n\n## [1.1.13] - 2024-06-13\n\n> There is no certainty in the world. This is the only certainty I have.\n\n### Important Notes\n\n * If building with Go 1.22.x, make sure to use 1.22.4 or a later version.\n   (see #4233 for more details)\n\n### Fixed\n\n * Support go 1.22.4+. (#4313)\n * runc list: fix race with runc delete. (#4231)\n * Fix set nofile rlimit error. (#4277, #4299)\n * libct/cg/fs: fix setting rt_period vs rt_runtime. (#4284)\n * Fix a debug msg for user ns in nsexec. (#4315)\n * script/*: fix gpg usage wrt keyboxd. (#4316)\n * CI fixes and misc backports. (#4241)\n * Fix codespell warnings. (#4300)\n\n### Changed\n\n * Silence security false positives from golang/net. (#4244)\n * libcontainer: allow containers to make apps think fips is enabled/disabled for testing. (#4257)\n * allow overriding VERSION value in Makefile. (#4270)\n * Vagrantfile.fedora: bump Fedora to 39. (#4261)\n * ci/cirrus: rm centos stream 8. (#4305, #4308)\n\n## [1.1.12] - 2024-01-31\n\n> Now you're thinking with Portals™!\n\n### Security\n\n* Fix [CVE-2024-21626][cve-2024-21626], a container breakout attack that took\n  advantage of a file descriptor that was leaked internally within runc (but\n  never leaked to the container process). In addition to fixing the leak,\n  several strict hardening measures were added to ensure that future internal\n  leaks could not be used to break out in this manner again. Based on our\n  research, while no other container runtime had a similar leak, none had any\n  of the hardening steps we've introduced (and some runtimes would not check\n  for any file descriptors that a calling process may have leaked to them,\n  allowing for container breakouts due to basic user error).\n\n[cve-2024-21626]: https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv\n\n## [1.1.11] - 2024-01-01\n\n> Happy New Year!\n\n### Fixed\n\n* Fix several issues with userns path handling. (#4122, #4124, #4134, #4144)\n\n### Changed\n\n * Support memory.peak and memory.swap.peak in cgroups v2.\n   Add `swapOnlyUsage` in `MemoryStats`. This field reports swap-only usage.\n   For cgroupv1, `Usage` and `Failcnt` are set by subtracting memory usage\n   from memory+swap usage. For cgroupv2, `Usage`, `Limit`, and `MaxUsage`\n   are set. (#4000, #4010, #4131)\n * build(deps): bump github.com/cyphar/filepath-securejoin. (#4140)\n\n## [1.1.10] - 2023-10-31\n\n> Śruba, przykręcona we śnie, nie zmieni sytuacji, jaka panuje na jawie.\n\n### Added\n\n* Support for `hugetlb.<pagesize>.rsvd` limiting and accounting. Fixes the\n  issue of postres failing when hugepage limits are set. (#3859, #4077)\n\n### Fixed\n\n* Fixed permissions of a newly created directories to not depend on the value\n  of umask in tmpcopyup feature implementation. (#3991, #4060)\n* libcontainer: cgroup v1 GetStats now ignores missing `kmem.limit_in_bytes`\n  (fixes the compatibility with Linux kernel 6.1+). (#4028)\n* Fix a semi-arbitrary cgroup write bug when given a malicious hugetlb\n  configuration. This issue is not a security issue because it requires a\n  malicious `config.json`, which is outside of our threat model. (#4103)\n* Various CI fixes. (#4081, #4055)\n\n## [1.1.9] - 2023-08-10\n\n> There is a crack in everything. That's how the light gets in.\n\n### Added\n\n* Added go 1.21 to the CI matrix; other CI updates. (#3976, #3958)\n\n### Fixed\n\n* Fixed losing sticky bit on tmpfs (a regression in 1.1.8). (#3952, #3961)\n* intelrdt: fixed ignoring ClosID on some systems. (#3550, #3978)\n\n### Changed\n\n * Sum `anon` and `file` from `memory.stat` for cgroupv2 root usage,\n   as the root does not have `memory.current` for cgroupv2.\n   This aligns cgroupv2 root usage more closely with cgroupv1 reporting.\n   Additionally, report root swap usage as sum of swap and memory usage,\n   aligned with v1 and existing non-root v2 reporting. (#3933)\n\n## [1.1.8] - 2023-07-20\n\n> 海纳百川 有容乃大\n\n### Added\n\n* Support riscv64. (#3905)\n\n### Fixed\n\n* init: do not print environment variable value. (#3879)\n* libct: fix a race with systemd removal. (#3877)\n* tests/int: increase num retries for oom tests. (#3891)\n* man/runc: fixes. (#3892)\n* Fix tmpfs mode opts when dir already exists. (#3916)\n* docs/systemd: fix a broken link. (#3917)\n* ci/cirrus: enable some rootless tests on cs9. (#3918)\n* runc delete: call systemd's reset-failed. (#3932)\n* libct/cg/sd/v1: do not update non-frozen cgroup after frozen failed. (#3921)\n\n### Changed\n\n* CI: bump Fedora, Vagrant, bats. (#3878)\n* `.codespellrc`: update for 2.2.5. (#3909)\n\n## [1.1.7] - 2023-04-26\n\n> Ночевала тучка золотая на груди утеса-великана.\n\n### Fixed\n\n* When used with systemd v240+, systemd cgroup drivers no longer skip\n  `DeviceAllow` rules if the device does not exist (a regression introduced\n  in runc 1.1.3). This fix also reverts the workaround added in runc 1.1.5,\n  removing an extra warning emitted by runc run/start. (#3845, #3708, #3671)\n\n### Added\n\n* The source code now has a new file, `runc.keyring`, which contains the keys\n  used to sign runc releases. (#3838)\n\n## [1.1.6] - 2023-04-11\n\n> In this world nothing is certain but death and taxes.\n\n### Compatibility\n\n* This release can no longer be built from sources using Go 1.16. Using a\n  latest maintained Go 1.20.x or Go 1.19.x release is recommended.\n  Go 1.17 can still be used.\n\n### Fixed\n\n* systemd cgroup v1 and v2 drivers were deliberately ignoring `UnitExist` error\n  from systemd while trying to create a systemd unit, which in some scenarios\n  may result in a container not being added to the proper systemd unit and\n  cgroup. (#3780, #3806)\n* systemd cgroup v2 driver was incorrectly translating cpuset range from spec's\n  `resources.cpu.cpus` to systemd unit property (`AllowedCPUs`) in case of more\n  than 8 CPUs, resulting in the wrong AllowedCPUs setting. (#3808)\n* systemd cgroup v1 driver was prefixing container's cgroup path with the path\n  of PID 1 cgroup, resulting in inability to place PID 1 in a non-root cgroup.\n  (#3811)\n* runc run/start may return \"permission denied\" error when starting a rootless\n  container when the file to be executed does not have executable bit set for\n  the user, not taking the `CAP_DAC_OVERRIDE` capability into account. This is\n  a regression in runc 1.1.4, as well as in Go 1.20 and 1.20.1 (#3715, #3817)\n* cgroup v1 drivers are now aware of `misc` controller. (#3823)\n* Various CI fixes and improvements, mostly to ensure Go 1.19.x and Go 1.20.x\n  compatibility.\n\n## [1.1.5] - 2023-03-29\n\n> 囚われた屈辱は\n> 反撃の嚆矢だ\n\n### Security\n\nThe following CVEs were fixed in this release:\n\n* [CVE-2023-25809][] is a vulnerability involving rootless containers where\n  (under specific configurations), the container would have write access to the\n  `/sys/fs/cgroup/user.slice/...` cgroup hierarchy. No other hierarchies on the\n  host were affected. This vulnerability was discovered by Akihiro Suda.\n\n* [CVE-2023-27561][] was a regression in our protections against tricky `/proc`\n  and `/sys` configurations (where the container mountpoint is a symlink)\n  causing us to be tricked into incorrectly configuring the container, which\n  effectively re-introduced [CVE-2019-19921][]. This regression was present\n  from v1.0.0-rc95 to v1.1.4 and was discovered by @Beuc. (#3785)\n\n* [CVE-2023-28642][] is a different attack vector using the same regression\n  as in [CVE-2023-27561][]. This was reported by Lei Wang.\n\n[CVE-2019-19921]: https://github.com/advisories/GHSA-fh74-hm69-rqjw\n[CVE-2023-25809]: https://github.com/opencontainers/runc/security/advisories/GHSA-m8cg-xc2p-r3fc\n[CVE-2023-27561]: https://github.com/advisories/GHSA-vpvm-3wq2-2wvm\n[CVE-2023-28642]: https://github.com/opencontainers/runc/security/advisories/GHSA-g2j6-57v7-gm8c\n\n### Fixed\n\n* Fix the inability to use `/dev/null` when inside a container. (#3620)\n* Fix changing the ownership of host's `/dev/null` caused by fd redirection\n  (a regression in 1.1.1). (#3674, #3731)\n* Fix rare runc exec/enter unshare error on older kernels, including\n  CentOS < 7.7. (#3776)\n* nsexec: Check for errors in `write_log()`. (#3721)\n* Various CI fixes and updates. (#3618, #3630, #3640, #3729)\n\n## [1.1.4] - 2022-08-24\n\n> If you look for perfection, you'll never be content.\n\n### Fixed\n\n* Fix mounting via wrong proc fd.\n  When the user and mount namespaces are used, and the bind mount is followed by\n  the cgroup mount in the spec, the cgroup was mounted using the bind mount's\n  mount fd. (#3511)\n* Switch `kill()` in `libcontainer/nsenter` to `sane_kill()`. (#3536)\n* Fix \"permission denied\" error from `runc run` on `noexec` fs. (#3541)\n* Fix failed exec after `systemctl daemon-reload`.\n  Due to a regression in v1.1.3, the `DeviceAllow=char-pts rwm` rule was no\n  longer added and was causing an error `open /dev/pts/0: operation not permitted: unknown`\n  when systemd was reloaded. (#3554)\n* Various CI fixes. (#3538, #3558, #3562)\n\n## [1.1.3] - 2022-06-09\n\n> In the beginning there was nothing, which exploded.\n\n### Fixed\n * Our seccomp `-ENOSYS` stub now correctly handles multiplexed syscalls on\n   s390 and s390x. This solves the issue where syscalls the host kernel did not\n   support would return `-EPERM` despite the existence of the `-ENOSYS` stub\n   code (this was due to how s390x does syscall multiplexing). (#3478)\n * Retry on dbus disconnect logic in libcontainer/cgroups/systemd now works as\n   intended; this fix does not affect runc binary itself but is important for\n   libcontainer users such as Kubernetes. (#3476)\n * Inability to compile with recent clang due to an issue with duplicate\n   constants in libseccomp-golang. (#3477)\n * When using systemd cgroup driver, skip adding device paths that don't exist,\n   to stop systemd from emitting warnings about those paths. (#3504)\n * Socket activation was failing when more than 3 sockets were used. (#3494)\n * Various CI fixes. (#3472, #3479)\n\n### Added\n * Allow to bind mount /proc/sys/kernel/ns_last_pid to inside container. (#3493)\n\n### Changed\n * runc static binaries are now linked against libseccomp v2.5.4. (#3481)\n\n\n## [1.1.2] - 2022-05-11\n\n> I should think I'm going to be a perpetual student.\n\n### Security\n * A bug was found in runc where runc exec --cap executed processes with\n   non-empty inheritable Linux process capabilities, creating an atypical Linux\n   environment. For more information, see [GHSA-f3fp-gc8g-vw66][] and\n   CVE-2022-29162.\n\n### Changed\n * `runc spec` no longer sets any inheritable capabilities in the created\n   example OCI spec (`config.json`) file.\n\n[GHSA-f3fp-gc8g-vw66]: https://github.com/opencontainers/runc/security/advisories/GHSA-f3fp-gc8g-vw66\n\n\n## [1.1.1] - 2022-03-28\n\n> Violence is the last refuge of the incompetent.\n\n### Added\n * CI is now also run on centos-stream-9. (#3436)\n\n### Fixed\n * `runc run/start` can now run a container with read-only `/dev` in OCI spec,\n   rather than error out. (#3355)\n * `runc exec` now ensures that `--cgroup` argument is a sub-cgroup. (#3403)\n * libcontainer systemd v2 manager no longer errors out if one of the files\n   listed in `/sys/kernel/cgroup/delegate` do not exist in container's cgroup.\n   (#3387, #3404)\n * Loose OCI spec validation to avoid bogus \"Intel RDT is not supported\" error.\n   (#3406)\n * libcontainer/cgroups no longer panics in cgroup v1 managers if `stat`\n   of `/sys/fs/cgroup/unified` returns an error other than ENOENT. (#3435)\n\n\n## [1.1.0] - 2022-01-14\n\n> A plan depends as much upon execution as it does upon concept.\n\n### Changed\n * libcontainer will now refuse to build without the nsenter package being\n   correctly compiled (specifically this requires CGO to be enabled). This\n   should avoid folks accidentally creating broken runc binaries (and\n   incorrectly importing our internal libraries into their projects). (#3331)\n\n\n## [1.1.0-rc.1] - 2021-12-14\n\n> He who controls the spice controls the universe.\n\n### Deprecated\n * runc run/start now warns if a new container cgroup is non-empty or frozen;\n   this warning will become an error in runc 1.2. (#3132, #3223)\n * runc can only be built with Go 1.16 or later from this release onwards.\n   (#3100, #3245, #3325)\n\n### Removed\n * `cgroup.GetHugePageSizes` has been removed entirely, and been replaced with\n   `cgroup.HugePageSizes` which is more efficient. (#3234)\n * `intelrdt.GetIntelRdtPath` has been removed. Users who were using this\n   function to get the intelrdt root should use the new `intelrdt.Root`\n   instead. (#2920, #3239)\n\n### Added\n * Add support for RDMA cgroup added in Linux 4.11. (#2883)\n * runc exec now produces exit code of 255 when the exec failed.\n   This may help in distinguishing between runc exec failures\n   (such as invalid options, non-running container or non-existent\n   binary etc.) and failures of the command being executed. (#3073)\n * runc run: new `--keep` option to skip removal exited containers artefacts.\n   This might be useful to check the state (e.g. of cgroup controllers) after\n   the container has exited. (#2817, #2825)\n * seccomp: add support for `SCMP_ACT_KILL_PROCESS` and `SCMP_ACT_KILL_THREAD`\n   (the latter is just an alias for `SCMP_ACT_KILL`). (#3204)\n * seccomp: add support for `SCMP_ACT_NOTIFY` (seccomp actions). This allows\n   users to create sophisticated seccomp filters where syscalls can be\n   efficiently emulated by privileged processes on the host. (#2682)\n * checkpoint/restore: add an option (`--lsm-mount-context`) to set\n   a different LSM mount context on restore. (#3068)\n * runc releases are now cross-compiled for several architectures. Static\n   builds for said architectures will be available for all future releases.\n   (#3197)\n * intelrdt: support ClosID parameter. (#2920)\n * runc exec --cgroup: an option to specify a (non-top) in-container cgroup\n   to use for the process being executed. (#3040, #3059)\n * cgroup v1 controllers now support hybrid hierarchy (i.e. when on a cgroup v1\n   machine a cgroup2 filesystem is mounted to /sys/fs/cgroup/unified, runc\n   run/exec now adds the container to the appropriate cgroup under it). (#2087,\n   #3059)\n * sysctl: allow slashes in sysctl names, to better match `sysctl(8)`'s\n   behaviour. (#3254, #3257)\n * mounts: add support for bind-mounts which are inaccessible after switching\n   the user namespace. Note that this does not permit the container any\n   additional access to the host filesystem, it simply allows containers to\n   have bind-mounts configured for paths the user can access but have\n   restrictive access control settings for other users. (#2576)\n * Add support for recursive mount attributes using `mount_setattr(2)`. These\n   have the same names as the proposed `mount(8)` options -- just prepend `r`\n   to the option name (such as `rro`). (#3272)\n * Add `runc features` subcommand to allow runc users to detect what features\n   runc has been built with. This includes critical information such as\n   supported mount flags, hook names, and so on. Note that the output of this\n   command is subject to change and will not be considered stable until runc\n   1.2 at the earliest. The runtime-spec specification for this feature is\n   being developed in [opencontainers/runtime-spec#1130]. (#3296)\n\n[opencontainers/runtime-spec#1130]: https://github.com/opencontainers/runtime-spec/pull/1130\n\n### Changed\n * system: improve performance of `/proc/$pid/stat` parsing. (#2696)\n * cgroup2: when `/sys/fs/cgroup` is configured as a read-write mount, change\n   the ownership of certain cgroup control files (as per\n   `/sys/kernel/cgroup/delegate`) to allow for proper deferral to the container\n   process. (#3057)\n * docs: series of improvements to man pages to make them easier to read and\n   use. (#3032)\n\n#### libcontainer API\n * internal api: remove internal error types and handling system, switch to Go\n   wrapped errors. (#3033)\n * New configs.Cgroup structure fields (#3177):\n   * Systemd (whether to use systemd cgroup manager); and\n   * Rootless (whether to use rootless cgroups).\n * New cgroups/manager package aiming to simplify cgroup manager instantiation.\n   (#3177)\n * All cgroup managers' instantiation methods now initialize cgroup paths and\n   can return errors. This allows to use any cgroup manager method (e.g.\n   Exists, Destroy, Set, GetStats) right after instantiation, which was not\n   possible before (as paths were initialized in Apply only). (#3178)\n\n### Fixed\n * nsenter: do not try to close already-closed fds during container setup and\n   bail on close(2) failures. (#3058)\n * runc checkpoint/restore: fixed for containers with an external bind mount\n   which destination is a symlink. (#3047).\n * cgroup: improve openat2 handling for cgroup directory handle hardening.\n   (#3030)\n * `runc delete -f` now succeeds (rather than timing out) on a paused\n   container. (#3134)\n * runc run/start/exec now refuses a frozen cgroup (paused container in case of\n   exec). Users can disable this using `--ignore-paused`. (#3132, #3223)\n * config: do not permit null bytes in mount fields. (#3287)\n\n\n## [1.0.3] - 2021-12-06\n\n> If you were waiting for the opportune moment, that was it.\n\n### Security\n * A potential vulnerability was discovered in runc (related to an internal\n   usage of netlink), however upon further investigation we discovered that\n   while this bug was exploitable on the master branch of runc, no released\n   version of runc could be exploited using this bug. The exploit required being\n   able to create a netlink attribute with a length that would overflow a uint16\n   but this was not possible in any released version of runc. For more\n   information, see [GHSA-v95c-p5hm-xq8f][] and CVE-2021-43784.\n\n### Fixed\n * Fixed inability to start a container with read-write bind mount of a\n   read-only fuse host mount. (#3283, #3292)\n * Fixed inability to start when read-only /dev in set in spec. (#3276, #3277)\n * Fixed not removing sub-cgroups upon container delete, when rootless cgroup v2\n   is used with older systemd. (#3226, #3297)\n * Fixed returning error from GetStats when hugetlb is unsupported (which causes\n   excessive logging for Kubernetes). (#3233, #3295)\n * Improved an error message when dbus-user-session is not installed and\n   rootless + cgroup2 + systemd are used. (#3212)\n\n[GHSA-v95c-p5hm-xq8f]: https://github.com/opencontainers/runc/security/advisories/GHSA-v95c-p5hm-xq8f\n\n\n## [1.0.2] - 2021-07-16\n\n> Given the right lever, you can move a planet.\n\n### Changed\n * Made release builds reproducible from now on. (#3099, #3142)\n\n### Fixed\n * Fixed a failure to set CPU quota period in some cases on cgroup v1. (#3090\n   #3115)\n * Fixed the inability to start a container with the \"adding seccomp filter\n   rule for syscall ...\" error, caused by redundant seccomp rules (i.e. those\n   that has action equal to the default one). Such redundant rules are now\n   skipped. (#3109, #3129)\n * Fixed a rare debug log race in runc init, which can result in occasional\n   harmful \"failed to decode ...\" errors from runc run or exec. (#3120, #3130)\n * Fixed the check in cgroup v1 systemd manager if a container needs to be\n   frozen before Set, and add a setting to skip such freeze unconditionally.\n   The previous fix for that issue, done in  runc 1.0.1, was not working.\n   (#3166, #3167)\n\n\n## [1.0.1] - 2021-07-16\n\n> If in doubt, Meriadoc, always follow your nose.\n\n### Fixed\n * Fixed occasional runc exec/run failure (\"interrupted system call\") on an\n   Azure volume. (#3045, #3074)\n * Fixed \"unable to find groups ... token too long\" error with /etc/group\n   containing lines longer than 64K characters. (#3062, #3079)\n * cgroup/systemd/v1: fix leaving cgroup frozen after Set if a parent cgroup is\n   frozen.  This is a regression in 1.0.0, not affecting runc itself but some\n   of libcontainer users (e.g Kubernetes). (#3081, #3085)\n * cgroupv2: bpf: Ignore inaccessible existing programs in case of\n   permission error when handling replacement of existing bpf cgroup\n   programs. This fixes a regression in 1.0.0, where some SELinux\n   policies would block runc from being able to run entirely. (#3055, #3087)\n * cgroup/systemd/v2: don't freeze cgroup on Set. (#3067, #3092)\n * cgroup/systemd/v1: avoid unnecessary freeze on Set. (#3082, #3093)\n\n\n## [1.0.0] - 2021-06-22\n\n> A wizard is never late, nor is he early, he arrives precisely when he means\n> to.\n\nAs runc follows Semantic Versioning, we will endeavour to not make any\nbreaking changes without bumping the major version number of runc.\nHowever, it should be noted that Go API usage of runc's internal\nimplementation (libcontainer) is *not* covered by this policy.\n\n### Removed\n * Removed libcontainer/configs.Device* identifiers (deprecated since rc94,\n   use libcontainer/devices). (#2999)\n * Removed libcontainer/system.RunningInUserNS function (deprecated since\n   rc94, use libcontainer/userns). (#2999)\n\n### Deprecated\n * The usage of relative paths for mountpoints will now produce a warning\n   (such configurations are outside of the spec, and in future runc will\n   produce an error when given such configurations). (#2917, #3004)\n\n### Fixed\n * cgroupv2: devices: rework the filter generation to produce consistent\n   results with cgroupv1, and always clobber any existing eBPF\n   program(s) to fix `runc update` and avoid leaking eBPF programs\n   (resulting in errors when managing containers).  (#2951)\n * cgroupv2: correctly convert \"number of IOs\" statistics in a\n   cgroupv1-compatible way. (#2965, #2967, #2968, #2964)\n * cgroupv2: support larger than 32-bit IO statistics on 32-bit architectures.\n * cgroupv2: wait for freeze to finish before returning from the freezing\n   code, optimize the method for checking whether a cgroup is frozen. (#2955)\n * cgroups/systemd: fixed \"retry on dbus disconnect\" logic introduced in rc94\n * cgroups/systemd: fixed returning \"unit already exists\" error from a systemd\n   cgroup manager (regression in rc94). (#2997, #2996)\n\n### Added\n * cgroupv2: support SkipDevices with systemd driver. (#2958, #3019)\n * cgroup1: blkio: support BFQ weights. (#3010)\n * cgroupv2: set per-device io weights if BFQ IO scheduler is available.\n   (#3022)\n\n### Changed\n * cgroup/systemd: return, not ignore, stop unit error from Destroy. (#2946)\n * Fix all golangci-lint failures. (#2781, #2962)\n * Make `runc --version` output sane even when built with `go get` or\n   otherwise outside of our build scripts. (#2962)\n * cgroups: set SkipDevices during runc update (so we don't modify\n   cgroups at all during `runc update`). (#2994)\n\n<!-- minor releases -->\n[Unreleased]: https://github.com/opencontainers/runc/compare/v1.2.0...HEAD\n[1.2.0]: https://github.com/opencontainers/runc/compare/v1.2.0-rc.1...v1.2.0\n[1.1.0]: https://github.com/opencontainers/runc/compare/v1.1.0-rc.1...v1.1.0\n[1.0.0]: https://github.com/opencontainers/runc/releases/tag/v1.0.0\n\n<!-- 1.0.z patch releases -->\n[Unreleased 1.0.z]: https://github.com/opencontainers/runc/compare/v1.0.3...release-1.0\n[1.0.3]: https://github.com/opencontainers/runc/compare/v1.0.2...v1.0.3\n[1.0.2]: https://github.com/opencontainers/runc/compare/v1.0.1...v1.0.2\n[1.0.1]: https://github.com/opencontainers/runc/compare/v1.0.0...v1.0.1\n\n<!-- 1.1.z patch releases -->\n[Unreleased 1.1.z]: https://github.com/opencontainers/runc/compare/v1.1.15...release-1.1\n[1.1.15]: https://github.com/opencontainers/runc/compare/v1.1.14...v1.1.15\n[1.1.14]: https://github.com/opencontainers/runc/compare/v1.1.13...v1.1.14\n[1.1.13]: https://github.com/opencontainers/runc/compare/v1.1.12...v1.1.13\n[1.1.12]: https://github.com/opencontainers/runc/compare/v1.1.11...v1.1.12\n[1.1.11]: https://github.com/opencontainers/runc/compare/v1.1.10...v1.1.11\n[1.1.10]: https://github.com/opencontainers/runc/compare/v1.1.9...v1.1.10\n[1.1.9]: https://github.com/opencontainers/runc/compare/v1.1.8...v1.1.9\n[1.1.8]: https://github.com/opencontainers/runc/compare/v1.1.7...v1.1.8\n[1.1.7]: https://github.com/opencontainers/runc/compare/v1.1.6...v1.1.7\n[1.1.6]: https://github.com/opencontainers/runc/compare/v1.1.5...v1.1.6\n[1.1.5]: https://github.com/opencontainers/runc/compare/v1.1.4...v1.1.5\n[1.1.4]: https://github.com/opencontainers/runc/compare/v1.1.3...v1.1.4\n[1.1.3]: https://github.com/opencontainers/runc/compare/v1.1.2...v1.1.3\n[1.1.2]: https://github.com/opencontainers/runc/compare/v1.1.1...v1.1.2\n[1.1.1]: https://github.com/opencontainers/runc/compare/v1.1.0...v1.1.1\n[1.1.0-rc.1]: https://github.com/opencontainers/runc/compare/v1.0.0...v1.1.0-rc.1\n\n<!-- 1.2.z patch releases -->\n[Unreleased 1.2.z]: https://github.com/opencontainers/runc/compare/v1.2.0...release-1.2\n[1.2.0-rc.3]: https://github.com/opencontainers/runc/compare/v1.2.0-rc.2...v1.2.0-rc.3\n[1.2.0-rc.2]: https://github.com/opencontainers/runc/compare/v1.2.0-rc.1...v1.2.0-rc.2\n[1.2.0-rc.1]: https://github.com/opencontainers/runc/compare/v1.1.0...v1.2.0-rc.1\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5.0615234375,
          "content": "## Contribution Guidelines\n\n### Security issues\n\nIf you are reporting a security issue, do not create an issue or file a pull\nrequest on GitHub. Instead, disclose the issue responsibly by sending an email\nto security@opencontainers.org (which is inhabited only by the maintainers of\nthe various OCI projects).\n\n### Pull requests are always welcome\n\nWe are always thrilled to receive pull requests, and do our best to\nprocess them as fast as possible. Not sure if that typo is worth a pull\nrequest? Do it! We will appreciate it.\n\nIf your pull request is not accepted on the first try, don't be\ndiscouraged! If there's a problem with the implementation, hopefully you\nreceived feedback on what to improve.\n\nWe're trying very hard to keep runc lean and focused. We don't want it\nto do everything for everybody. This means that we might decide against\nincorporating a new feature. However, there might be a way to implement\nthat feature *on top of* runc.\n\n\n### Conventions\n\nFork the repo and make changes on your fork in a feature branch:\n\n- If it's a bugfix branch, name it XXX-something where XXX is the number of the\n  issue\n- If it's a feature branch, create an enhancement issue to announce your\n  intentions, and name it XXX-something where XXX is the number of the issue.\n\nSubmit unit tests for your changes.  Go has a great test framework built in; use\nit! Take a look at existing tests for inspiration. Run the full test suite on\nyour branch before submitting a pull request.\n\nUpdate the documentation when creating or modifying features. Test\nyour documentation changes for clarity, concision, and correctness, as\nwell as a clean documentation build. See ``docs/README.md`` for more\ninformation on building the docs and how docs get released.\n\nWrite clean code. Universally formatted code promotes ease of writing, reading,\nand maintenance. Always run `gofmt -s -w file.go` on each changed file before\ncommitting your changes. Most editors have plugins that do this automatically.\n\nPull requests descriptions should be as clear as possible and include a\nreference to all the issues that they address.\n\nPull requests must not contain commits from other users or branches.\n\nCommit messages must start with a capitalized and short summary (max. 50\nchars) written in the imperative, followed by an optional, more detailed\nexplanatory text which is separated from the summary by an empty line.\n\nCode review comments may be added to your pull request. Discuss, then make the\nsuggested modifications and push additional commits to your feature branch. Be\nsure to post a comment after pushing. The new commits will show up in the pull\nrequest automatically, but the reviewers will not be notified unless you\ncomment.\n\nBefore the pull request is merged, make sure that you squash your commits into\nlogical units of work using `git rebase -i` and `git push -f`. After every\ncommit the test suite should be passing. Include documentation changes in the\nsame commit so that a revert would remove all traces of the feature or fix.\n\nCommits that fix or close an issue should include a reference like `Closes #XXX`\nor `Fixes #XXX`, which will automatically close the issue when merged.\n\n### Sign your work\n\nThe sign-off is a simple line at the end of the explanation for the\npatch, which certifies that you wrote it or otherwise have the right to\npass it on as an open-source patch.  The rules are pretty simple: if you\ncan certify the below (from\n[developercertificate.org](http://developercertificate.org/)):\n\n```\nDeveloper Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n660 York Street, Suite 102,\nSan Francisco, CA 94110 USA\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n```\n\nthen you just add a line to every git commit message:\n\n    Signed-off-by: Joe Smith <joe@gmail.com>\n\nusing your real name (sorry, no pseudonyms or anonymous contributions.)\n\nYou can add the sign off when creating the git commit via `git commit -s`.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 2.58203125,
          "content": "ARG GO_VERSION=1.23\nARG BATS_VERSION=v1.9.0\nARG LIBSECCOMP_VERSION=2.5.5\n\nFROM golang:${GO_VERSION}-bookworm\nARG DEBIAN_FRONTEND=noninteractive\nARG CRIU_REPO=https://download.opensuse.org/repositories/devel:/tools:/criu/Debian_12\n\nRUN KEYFILE=/usr/share/keyrings/criu-repo-keyring.gpg; \\\n    wget -nv $CRIU_REPO/Release.key -O- | gpg --dearmor > \"$KEYFILE\" \\\n    && echo \"deb [signed-by=$KEYFILE] $CRIU_REPO/ /\" > /etc/apt/sources.list.d/criu.list \\\n    && dpkg --add-architecture i386 \\\n    && apt-get update \\\n    && apt-get install -y --no-install-recommends \\\n        build-essential \\\n        criu \\\n        gcc \\\n        gcc-multilib \\\n        curl \\\n        gawk \\\n        gperf \\\n        iptables \\\n        jq \\\n        kmod \\\n        pkg-config \\\n        python3-minimal \\\n        sshfs \\\n        sudo \\\n        uidmap \\\n        iproute2 \\\n    && apt-get install -y --no-install-recommends \\\n        libc-dev:i386 libgcc-s1:i386 \\\n        gcc-aarch64-linux-gnu libc-dev-arm64-cross \\\n        gcc-arm-linux-gnueabi libc-dev-armel-cross \\\n        gcc-arm-linux-gnueabihf libc-dev-armhf-cross \\\n        gcc-powerpc64le-linux-gnu libc-dev-ppc64el-cross \\\n        gcc-s390x-linux-gnu libc-dev-s390x-cross \\\n        gcc-riscv64-linux-gnu libc-dev-riscv64-cross \\\n    && apt-get clean \\\n    && rm -rf /var/cache/apt /var/lib/apt/lists/* /etc/apt/sources.list.d/*.list\n\n# Add a dummy user for the rootless integration tests. While runC does\n# not require an entry in /etc/passwd to operate, one of the tests uses\n# `git clone` -- and `git clone` does not allow you to clone a\n# repository if the current uid does not have an entry in /etc/passwd.\nRUN useradd -u1000 -m -d/home/rootless -s/bin/bash rootless\n\n# install bats\nARG BATS_VERSION\nRUN cd /tmp \\\n    && git clone https://github.com/bats-core/bats-core.git \\\n    && cd bats-core \\\n    && git reset --hard \"${BATS_VERSION}\" \\\n    && ./install.sh /usr/local \\\n    && rm -rf /tmp/bats-core\n\n# install libseccomp\nARG LIBSECCOMP_VERSION\nCOPY script/seccomp.sh script/lib.sh /tmp/script/\nRUN mkdir -p /opt/libseccomp \\\n    && /tmp/script/seccomp.sh \"$LIBSECCOMP_VERSION\" /opt/libseccomp 386 amd64 arm64 armel armhf ppc64le riscv64 s390x\nENV LIBSECCOMP_VERSION=$LIBSECCOMP_VERSION\nENV LD_LIBRARY_PATH=/opt/libseccomp/lib\nENV PKG_CONFIG_PATH=/opt/libseccomp/lib/pkgconfig\n\n# Prevent the \"fatal: detected dubious ownership in repository\" git complain during build.\nRUN git config --global --add safe.directory /go/src/github.com/opencontainers/runc\n\nWORKDIR /go/src/github.com/opencontainers/runc\n\n# Fixup for cgroup v2.\nCOPY script/prepare-cgroup-v2.sh /\nENTRYPOINT [ \"/prepare-cgroup-v2.sh\" ]\n"
        },
        {
          "name": "EMERITUS.md",
          "type": "blob",
          "size": 0.3876953125,
          "content": "## Emeritus ##\n\nWe would like to acknowledge previous runc maintainers and their huge\ncontributions to our collective success:\n\n * Alexander Morozov (@lk4d4)\n * Andrei Vagin (@avagin)\n * Rohit Jnagal (@rjnagal)\n * Victor Marmol (@vmarmol)\n * Michael Crosby (@crosbymichael)\n * Daniel, Dao Quang Minh (@dqminh)\n * Qiang Huang (@hqhq)\n\nWe thank these members for their service to the OCI community.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.505859375,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   Copyright 2014 Docker, Inc.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 0.3349609375,
          "content": "Mrunal Patel <mpatel@redhat.com> (@mrunalp)\nAleksa Sarai <cyphar@cyphar.com> (@cyphar)\nAkihiro Suda <akihiro.suda.cz@hco.ntt.co.jp> (@AkihiroSuda)\nKir Kolyshkin <kolyshkin@gmail.com> (@kolyshkin)\nSebastiaan van Stijn <github@gone.nl> (@thaJeztah)\nLi Fu Bang <lifubang@acmcoder.com> (@lifubang)\nRodrigo Campos <rodrigoca@microsoft.com> (@rata)\n"
        },
        {
          "name": "MAINTAINERS_GUIDE.md",
          "type": "blob",
          "size": 4.5791015625,
          "content": "## Introduction\n\nDear maintainer. Thank you for investing the time and energy to help\nmake runc as useful as possible. Maintaining a project is difficult,\nsometimes unrewarding work.  Sure, you will get to contribute cool\nfeatures to the project. But most of your time will be spent reviewing,\ncleaning up, documenting, answering questions, justifying design\ndecisions - while everyone has all the fun! But remember - the quality\nof the maintainers work is what distinguishes the good projects from the\ngreat.  So please be proud of your work, even the unglamorous parts,\nand encourage a culture of appreciation and respect for *every* aspect\nof improving the project - not just the hot new features.\n\nThis document is a manual for maintainers old and new. It explains what\nis expected of maintainers, how they should work, and what tools are\navailable to them.\n\nThis is a living document - if you see something out of date or missing,\nspeak up!\n\n## What are a maintainer's responsibility?\n\nIt is every maintainer's responsibility to:\n\n* 1) Expose a clear roadmap for improving their component.\n* 2) Deliver prompt feedback and decisions on pull requests.\n* 3) Be available to anyone with questions, bug reports, criticism etc.\n  on their component. This includes IRC and GitHub issues and pull requests.\n* 4) Make sure their component respects the philosophy, design and\n  roadmap of the project.\n\n## How are decisions made?\n\nShort answer: with pull requests to the runc repository.\n\nrunc is an open-source project with an open design philosophy. This\nmeans that the repository is the source of truth for EVERY aspect of the\nproject, including its philosophy, design, roadmap and APIs. *If it's\npart of the project, it's in the repo. It's in the repo, it's part of\nthe project.*\n\nAs a result, all decisions can be expressed as changes to the\nrepository. An implementation change is a change to the source code. An\nAPI change is a change to the API specification. A philosophy change is\na change to the philosophy manifesto. And so on.\n\nAll decisions affecting runc, big and small, follow the same 3 steps:\n\n* Step 1: Open a pull request. Anyone can do this.\n\n* Step 2: Discuss the pull request. Anyone can do this.\n\n* Step 3: Accept (`LGTM`) or refuse a pull request. The relevant maintainers do\nthis (see below \"Who decides what?\")\n\n*I'm a maintainer, should I make pull requests too?*\n\nYes. Nobody should ever push to master directly. All changes should be\nmade through a pull request.\n\n## Who decides what?\n\nAll decisions are pull requests, and the relevant maintainers make\ndecisions by accepting or refusing the pull request. Review and acceptance\nby anyone is denoted by adding a comment in the pull request: `LGTM`.\nHowever, only currently listed `MAINTAINERS` are counted towards the required\ntwo LGTMs.\n\nOverall the maintainer system works because of mutual respect across the\nmaintainers of the project.  The maintainers trust one another to make decisions\nin the best interests of the project.  Sometimes maintainers can disagree and\nthis is part of a healthy project to represent the point of views of various people.\n\n\n### How are maintainers added?\n\nThe best maintainers have a vested interest in the project.  Maintainers\nare first and foremost contributors that have shown they are committed to\nthe long term success of the project.  Contributors wanting to become\nmaintainers are expected to be deeply involved in contributing code,\npull request review, and triage of issues in the project for more than two months.\n\nJust contributing does not make you a maintainer, it is about building trust\nwith the current maintainers of the project and being a person that they can\ndepend on and trust to make decisions in the best interest of the project.  The\nfinal vote to add a new maintainer should be approved by over 66% of the current\nmaintainers. The voting period is five business days on the Pull Request\nto add the new maintainer.\n\n\n### What is expected of maintainers?\n\nPart of a healthy project is to have active maintainers to support the community\nin contributions and perform tasks to keep the project running.  Maintainers are\nexpected to be able to respond in a timely manner if their help is required on specific\nissues where they are pinged.  Being a maintainer is a time consuming commitment and should\nnot be taken lightly.\n\nWhen a maintainer is unable to perform the required duties they can be removed with\na vote by 66% of the current maintainers.\nThe voting period is ten business days.  Issues related to a maintainer's performance should\nbe discussed with them among the other maintainers so that they are not surprised by\na pull request removing them.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 7.056640625,
          "content": "SHELL = /bin/bash\n\nCONTAINER_ENGINE := docker\nGO ?= go\n\nPREFIX ?= /usr/local\nBINDIR := $(PREFIX)/sbin\nMANDIR := $(PREFIX)/share/man\n\nGIT_BRANCH := $(shell git rev-parse --abbrev-ref HEAD 2>/dev/null)\nGIT_BRANCH_CLEAN := $(shell echo $(GIT_BRANCH) | sed -e \"s/[^[:alnum:]]/-/g\")\nRUNC_IMAGE := runc_dev$(if $(GIT_BRANCH_CLEAN),:$(GIT_BRANCH_CLEAN))\nPROJECT := github.com/opencontainers/runc\nEXTRA_BUILDTAGS :=\nBUILDTAGS := seccomp urfave_cli_no_docs\nBUILDTAGS += $(EXTRA_BUILDTAGS)\n\nCOMMIT := $(shell git describe --dirty --long --always)\nEXTRA_VERSION :=\nVERSION := $(shell cat ./VERSION)$(EXTRA_VERSION)\nLDFLAGS_COMMON := -X main.gitCommit=$(COMMIT) -X main.version=$(VERSION)\n\nGOARCH := $(shell $(GO) env GOARCH)\n\n# -trimpath may be required on some platforms to create reproducible builds\n# on the other hand, it does strip out build information, like -ldflags, which\n# some tools use to infer the version, in the absence of go information,\n# which happens when you use `go build`.\n# This enables someone to override by doing `make runc TRIMPATH= ` etc.\nTRIMPATH := -trimpath\n\nGO_BUILDMODE :=\n# Enable dynamic PIE executables on supported platforms.\nifneq (,$(filter $(GOARCH),386 amd64 arm arm64 ppc64le riscv64 s390x))\n\tifeq (,$(findstring -race,$(EXTRA_FLAGS)))\n\t\tGO_BUILDMODE := \"-buildmode=pie\"\n\tendif\nendif\nGO_BUILD := $(GO) build $(TRIMPATH) $(GO_BUILDMODE) \\\n\t$(EXTRA_FLAGS) -tags \"$(BUILDTAGS)\" \\\n\t-ldflags \"$(LDFLAGS_COMMON) $(EXTRA_LDFLAGS)\"\n\nGO_BUILDMODE_STATIC :=\nLDFLAGS_STATIC := -extldflags -static\n# Enable static PIE executables on supported platforms.\n# This (among the other things) requires libc support (rcrt1.o), which seems\n# to be available only for arm64 and amd64 (Debian Bullseye).\nifneq (,$(filter $(GOARCH),arm64 amd64))\n\tifeq (,$(findstring -race,$(EXTRA_FLAGS)))\n\t\tGO_BUILDMODE_STATIC := -buildmode=pie\n\t\tLDFLAGS_STATIC := -linkmode external -extldflags -static-pie\n\tendif\nendif\n# Enable static PIE binaries on supported platforms.\nGO_BUILD_STATIC := $(GO) build $(TRIMPATH) $(GO_BUILDMODE_STATIC) \\\n\t$(EXTRA_FLAGS) -tags \"$(BUILDTAGS) netgo osusergo\" \\\n\t-ldflags \"$(LDFLAGS_COMMON) $(LDFLAGS_STATIC) $(EXTRA_LDFLAGS)\"\n\nGPG_KEYID ?= asarai@suse.de\n\n# Some targets need cgo, which is disabled by default when cross compiling.\n# Enable cgo explicitly for those.\n# Both runc and libcontainer/integration need libcontainer/nsenter.\nrunc static localunittest: export CGO_ENABLED=1\n# seccompagent needs libseccomp (when seccomp build tag is set).\nifneq (,$(filter $(BUILDTAGS),seccomp))\nseccompagent: export CGO_ENABLED=1\nendif\n\n.DEFAULT: runc\n\n.PHONY: runc\nrunc: runc-bin\n\n.PHONY: runc-bin\nrunc-bin:\n\t$(GO_BUILD) -o runc .\n\n.PHONY: all\nall: runc memfd-bind\n\n.PHONY: memfd-bind\nmemfd-bind:\n\t$(GO_BUILD) -o contrib/cmd/$@/$@ ./contrib/cmd/$@\n\nTESTBINDIR := tests/cmd/_bin\n$(TESTBINDIR):\n\tmkdir $(TESTBINDIR)\n\nTESTBINS := recvtty sd-helper seccompagent fs-idmap pidfd-kill remap-rootfs\n.PHONY: test-binaries $(TESTBINS)\ntest-binaries: $(TESTBINS)\n$(TESTBINS): $(TESTBINDIR)\n\t$(GO_BUILD) -o $(TESTBINDIR) ./tests/cmd/$@\n\n.PHONY: clean\nclean:\n\trm -f runc runc-*\n\trm -f contrib/cmd/memfd-bind/memfd-bind\n\trm -fr $(TESTBINDIR)\n\tsudo rm -rf release\n\trm -rf man/man8\n\n.PHONY: static\nstatic: static-bin\n\n.PHONY: static-bin\nstatic-bin:\n\t$(GO_BUILD_STATIC) -o runc .\n\n.PHONY: releaseall\nreleaseall: RELEASE_ARGS := \"-a 386 -a amd64 -a arm64 -a armel -a armhf -a ppc64le -a riscv64 -a s390x\"\nreleaseall: release\n\n.PHONY: release\nrelease: runcimage\n\t$(CONTAINER_ENGINE) run $(CONTAINER_ENGINE_RUN_FLAGS) \\\n\t\t--rm -v $(CURDIR):/go/src/$(PROJECT) \\\n\t\t-e RELEASE_ARGS=$(RELEASE_ARGS) \\\n\t\t$(RUNC_IMAGE) make localrelease\n\tscript/release_sign.sh -S $(GPG_KEYID) -r release/$(VERSION) -v $(VERSION)\n\n.PHONY: localrelease\nlocalrelease: verify-changelog\n\tscript/release_build.sh -r release/$(VERSION) -v $(VERSION) $(RELEASE_ARGS)\n\n.PHONY: dbuild\ndbuild: runcimage\n\t$(CONTAINER_ENGINE) run $(CONTAINER_ENGINE_RUN_FLAGS) \\\n\t\t--privileged --rm \\\n\t\t-v $(CURDIR):/go/src/$(PROJECT) \\\n\t\t$(RUNC_IMAGE) make clean runc test-binaries\n\n.PHONY: lint\nlint:\n\tgolangci-lint run ./...\n\n.PHONY: man\nman:\n\tman/md2man-all.sh\n\n.PHONY: runcimage\nruncimage:\n\t$(CONTAINER_ENGINE) build $(CONTAINER_ENGINE_BUILD_FLAGS) -t $(RUNC_IMAGE) .\n\n.PHONY: test\ntest: unittest integration rootlessintegration\n\n.PHONY: localtest\nlocaltest: localunittest localintegration localrootlessintegration\n\n.PHONY: unittest\nunittest: runcimage\n\t$(CONTAINER_ENGINE) run $(CONTAINER_ENGINE_RUN_FLAGS) \\\n\t\t-t --privileged --rm \\\n\t\t-v /lib/modules:/lib/modules:ro \\\n\t\t-v $(CURDIR):/go/src/$(PROJECT) \\\n\t\t$(RUNC_IMAGE) make localunittest TESTFLAGS=\"$(TESTFLAGS)\"\n\n.PHONY: localunittest\nlocalunittest: test-binaries\n\t$(GO) test -timeout 3m -tags \"$(BUILDTAGS)\" $(TESTFLAGS) -v ./...\n\n.PHONY: integration\nintegration: runcimage\n\t$(CONTAINER_ENGINE) run $(CONTAINER_ENGINE_RUN_FLAGS) \\\n\t\t-t --privileged --rm \\\n\t\t-v /lib/modules:/lib/modules:ro \\\n\t\t-v $(CURDIR):/go/src/$(PROJECT) \\\n\t\t$(RUNC_IMAGE) make localintegration TESTPATH=\"$(TESTPATH)\"\n\n.PHONY: localintegration\nlocalintegration: runc test-binaries\n\tbats -t tests/integration$(TESTPATH)\n\n.PHONY: rootlessintegration\nrootlessintegration: runcimage\n\t$(CONTAINER_ENGINE) run $(CONTAINER_ENGINE_RUN_FLAGS) \\\n\t\t-t --privileged --rm \\\n\t\t-v $(CURDIR):/go/src/$(PROJECT) \\\n\t\t-e ROOTLESS_TESTPATH \\\n\t\t$(RUNC_IMAGE) make localrootlessintegration\n\n.PHONY: localrootlessintegration\nlocalrootlessintegration: runc test-binaries\n\ttests/rootless.sh\n\n.PHONY: shell\nshell: runcimage\n\t$(CONTAINER_ENGINE) run $(CONTAINER_ENGINE_RUN_FLAGS) \\\n\t\t-ti --privileged --rm \\\n\t\t-v $(CURDIR):/go/src/$(PROJECT) \\\n\t\t$(RUNC_IMAGE) bash\n\n.PHONY: install\ninstall:\n\tinstall -D -m0755 runc $(DESTDIR)$(BINDIR)/runc\n\n.PHONY: install-bash\ninstall-bash:\n\tinstall -D -m0644 contrib/completions/bash/runc $(DESTDIR)$(PREFIX)/share/bash-completion/completions/runc\n\n.PHONY: install-man\ninstall-man: man\n\tinstall -d -m 755 $(DESTDIR)$(MANDIR)/man8\n\tinstall -D -m 644 man/man8/*.8 $(DESTDIR)$(MANDIR)/man8\n\n.PHONY: cfmt\ncfmt: C_SRC=$(shell git ls-files '*.c' | grep -v '^vendor/')\ncfmt:\n\tindent -linux -l120 -il0 -ppi2 -cp1 -sar -T size_t -T jmp_buf $(C_SRC)\n\n.PHONY: shellcheck\nshellcheck:\n\tshellcheck tests/integration/*.bats tests/integration/*.sh \\\n\t\ttests/integration/*.bash tests/*.sh \\\n\t\tman/*.sh script/*\n\t# TODO: add shellcheck for more sh files (contrib/completions/bash/runc).\n\n.PHONY: shfmt\nshfmt:\n\t$(CONTAINER_ENGINE) run $(CONTAINER_ENGINE_RUN_FLAGS) \\\n\t\t--rm -v $(CURDIR):/src -w /src \\\n\t\tmvdan/shfmt:v3.5.1 -d -w .\n\n.PHONY: localshfmt\nlocalshfmt:\n\tshfmt -d -w .\n\n.PHONY: vendor\nvendor:\n\t$(GO) mod tidy\n\t$(GO) mod vendor\n\t$(GO) mod verify\n\n.PHONY: verify-changelog\nverify-changelog:\n\t# No space at EOL.\n\t! grep -n '\\s$$' CHANGELOG.md\n\t# Period before issue/PR references.\n\t! grep -n '[0-9a-zA-Z][^.] (#[1-9][0-9, #]*)$$' CHANGELOG.md\n\n.PHONY: verify-dependencies\nverify-dependencies: vendor\n\t@test -z \"$$(git status --porcelain -- go.mod go.sum vendor/)\" \\\n\t\t|| (echo -e \"git status:\\n $$(git status -- go.mod go.sum vendor/)\\nerror: vendor/, go.mod and/or go.sum not up to date. Run \\\"make vendor\\\" to update\"; exit 1) \\\n\t\t&& echo \"all vendor files are up to date.\"\n\n.PHONY: validate-keyring\nvalidate-keyring:\n\tscript/keyring_validate.sh\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.5029296875,
          "content": "runc\n\nCopyright 2012-2015 Docker, Inc.\n\nThis product includes software developed at Docker, Inc. (http://www.docker.com).\n\nThe following is courtesy of our legal counsel:\n\n\nUse and transfer of Docker may be subject to certain restrictions by the\nUnited States and other governments.\nIt is your responsibility to ensure that your use and/or transfer does not\nviolate applicable laws.\n\nFor more information, please see http://www.bis.doc.gov\n\nSee also http://www.apache.org/dev/crypto.html and/or seek legal counsel.\n"
        },
        {
          "name": "PRINCIPLES.md",
          "type": "blob",
          "size": 1.1123046875,
          "content": "# runc principles\n\nIn the design and development of runc and libcontainer we try to follow these principles:\n\n(Work in progress)\n\n* Don't try to replace every tool. Instead, be an ingredient to improve them.\n* Less code is better.\n* Fewer components are better. Do you really need to add one more class?\n* 50 lines of straightforward, readable code is better than 10 lines of magic that nobody can understand.\n* Don't do later what you can do now. \"//TODO: refactor\" is not acceptable in new code.\n* When hesitating between two options, choose the one that is easier to reverse.\n* \"No\" is temporary; \"Yes\" is forever. If you're not sure about a new feature, say no. You can change your mind later.\n* Containers must be portable to the greatest possible number of machines. Be suspicious of any change which makes machines less interchangeable.\n* The fewer moving parts in a container, the better.\n* Don't merge it unless you document it.\n* Don't document it unless you can keep it up-to-date.\n* Don't merge it unless you test it!\n* Everyone's problem is slightly different. Focus on the part that is the same for everyone, and solve that.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.6357421875,
          "content": "# runc\n\n[![Go Report Card](https://goreportcard.com/badge/github.com/opencontainers/runc)](https://goreportcard.com/report/github.com/opencontainers/runc)\n[![Go Reference](https://pkg.go.dev/badge/github.com/opencontainers/runc.svg)](https://pkg.go.dev/github.com/opencontainers/runc)\n[![CII Best Practices](https://bestpractices.coreinfrastructure.org/projects/588/badge)](https://bestpractices.coreinfrastructure.org/projects/588)\n[![gha/validate](https://github.com/opencontainers/runc/workflows/validate/badge.svg)](https://github.com/opencontainers/runc/actions?query=workflow%3Avalidate)\n[![gha/ci](https://github.com/opencontainers/runc/workflows/ci/badge.svg)](https://github.com/opencontainers/runc/actions?query=workflow%3Aci)\n[![CirrusCI](https://api.cirrus-ci.com/github/opencontainers/runc.svg)](https://cirrus-ci.com/github/opencontainers/runc)\n<a href=\"https://actuated.dev\"><img alt=\"Arm CI sponsored by Actuated\" src=\"https://docs.actuated.dev/images/actuated-badge.png\" width=\"120px\"></img></a>\n\n## Introduction\n\n`runc` is a CLI tool for spawning and running containers on Linux according to the OCI specification.\n\n## Releases\n\nYou can find official releases of `runc` on the [release](https://github.com/opencontainers/runc/releases) page.\n\nAll releases are signed by one of the keys listed in the [`runc.keyring` file in the root of this repository](runc.keyring).\n\n## Security\n\nThe reporting process and disclosure communications are outlined [here](https://github.com/opencontainers/org/blob/master/SECURITY.md).\n\n### Security Audit\nA third party security audit was performed by Cure53, you can see the full report [here](https://github.com/opencontainers/runc/blob/master/docs/Security-Audit.pdf).\n\n## Building\n\n`runc` only supports Linux. See the header of [`go.mod`](./go.mod) for the required Go version.\n\n### Pre-Requisites\n\n#### Utilities and Libraries\n\nIn addition to Go, building `runc` requires multiple utilities and libraries to be installed on your system.\n\nOn Ubuntu/Debian, you can install the required dependencies with:\n\n```bash\napt update && apt install -y make gcc linux-libc-dev libseccomp-dev pkg-config git\n```\n\nOn CentOS/Fedora, you can install the required dependencies with:\n\n```bash\nyum install -y make gcc kernel-headers libseccomp-devel pkg-config git\n```\n\nOn Alpine Linux, you can install the required dependencies with:\n\n```bash\napk --update add bash make gcc libseccomp-dev musl-dev linux-headers git\n```\n\nThe following dependencies are optional:\n\n* `libseccomp` - only required if you enable seccomp support; to disable, see [Build Tags](#build-tags)\n\n### Build\n\n```bash\n# create a 'github.com/opencontainers' in your GOPATH/src\ncd github.com/opencontainers\ngit clone https://github.com/opencontainers/runc\ncd runc\n\nmake\nsudo make install\n```\n\nYou can also use `go get` to install to your `GOPATH`, assuming that you have a `github.com` parent folder already created under `src`:\n\n```bash\ngo get github.com/opencontainers/runc\ncd $GOPATH/src/github.com/opencontainers/runc\nmake\nsudo make install\n```\n\n`runc` will be installed to `/usr/local/sbin/runc` on your system.\n\n#### Version string customization\n\nYou can see the runc version by running `runc --version`. You can append a custom string to the\nversion using the `EXTRA_VERSION` make variable when building, e.g.:\n\n```bash\nmake EXTRA_VERSION=\"+build-1\"\n```\n\nBear in mind to include some separator for readability.\n\n#### Build Tags\n\n`runc` supports optional build tags for compiling support of various features,\nwith some of them enabled by default (see `BUILDTAGS` in top-level `Makefile`).\n\nTo change build tags from the default, set the `BUILDTAGS` variable for make,\ne.g. to disable seccomp:\n\n```bash\nmake BUILDTAGS=\"\"\n```\n\nTo add some more build tags to the default set, use the `EXTRA_BUILDTAGS`\nmake variable, e.g. to disable checkpoint/restore:\n\n```bash\nmake EXTRA_BUILDTAGS=\"runc_nocriu\"\n```\n\n| Build Tag     | Feature                               | Enabled by Default | Dependencies        |\n|---------------|---------------------------------------|--------------------|---------------------|\n| `seccomp`     | Syscall filtering using `libseccomp`. | yes                | `libseccomp`        |\n| `runc_nocriu` | **Disables** runc checkpoint/restore. | no                 | `criu`              |\n\nThe following build tags were used earlier, but are now obsoleted:\n - **runc_nodmz** (since runc v1.2.1 runc dmz binary is dropped)\n - **nokmem** (since runc v1.0.0-rc94 kernel memory settings are ignored)\n - **apparmor** (since runc v1.0.0-rc93 the feature is always enabled)\n - **selinux**  (since runc v1.0.0-rc93 the feature is always enabled)\n\n### Running the test suite\n\n`runc` currently supports running its test suite via Docker.\nTo run the suite just type `make test`.\n\n```bash\nmake test\n```\n\nThere are additional make targets for running the tests outside of a container but this is not recommended as the tests are written with the expectation that they can write and remove anywhere.\n\nYou can run a specific test case by setting the `TESTFLAGS` variable.\n\n```bash\n# make test TESTFLAGS=\"-run=SomeTestFunction\"\n```\n\nYou can run a specific integration test by setting the `TESTPATH` variable.\n\n```bash\n# make test TESTPATH=\"/checkpoint.bats\"\n```\n\nYou can run a specific rootless integration test by setting the `ROOTLESS_TESTPATH` variable.\n\n```bash\n# make test ROOTLESS_TESTPATH=\"/checkpoint.bats\"\n```\n\nYou can run a test using your container engine's flags by setting `CONTAINER_ENGINE_BUILD_FLAGS` and `CONTAINER_ENGINE_RUN_FLAGS` variables.\n\n```bash\n# make test CONTAINER_ENGINE_BUILD_FLAGS=\"--build-arg http_proxy=http://yourproxy/\" CONTAINER_ENGINE_RUN_FLAGS=\"-e http_proxy=http://yourproxy/\"\n```\n\n### Go Dependencies Management\n\n`runc` uses [Go Modules](https://github.com/golang/go/wiki/Modules) for dependencies management.\nPlease refer to [Go Modules](https://github.com/golang/go/wiki/Modules) for how to add or update\nnew dependencies.\n\n```\n# Update vendored dependencies\nmake vendor\n# Verify all dependencies\nmake verify-dependencies\n```\n\n## Using runc\n\nPlease note that runc is a low level tool not designed with an end user\nin mind. It is mostly employed by other higher level container software.\n\nTherefore, unless there is some specific use case that prevents the use\nof tools like Docker or Podman, it is not recommended to use runc directly.\n\nIf you still want to use runc, here's how.\n\n### Creating an OCI Bundle\n\nIn order to use runc you must have your container in the format of an OCI bundle.\nIf you have Docker installed you can use its `export` method to acquire a root filesystem from an existing Docker container.\n\n```bash\n# create the top most bundle directory\nmkdir /mycontainer\ncd /mycontainer\n\n# create the rootfs directory\nmkdir rootfs\n\n# export busybox via Docker into the rootfs directory\ndocker export $(docker create busybox) | tar -C rootfs -xvf -\n```\n\nAfter a root filesystem is populated you just generate a spec in the format of a `config.json` file inside your bundle.\n`runc` provides a `spec` command to generate a base template spec that you are then able to edit.\nTo find features and documentation for fields in the spec please refer to the [specs](https://github.com/opencontainers/runtime-spec) repository.\n\n```bash\nrunc spec\n```\n\n### Running Containers\n\nAssuming you have an OCI bundle from the previous step you can execute the container in two different ways.\n\nThe first way is to use the convenience command `run` that will handle creating, starting, and deleting the container after it exits.\n\n```bash\n# run as root\ncd /mycontainer\nrunc run mycontainerid\n```\n\nIf you used the unmodified `runc spec` template this should give you a `sh` session inside the container.\n\nThe second way to start a container is using the specs lifecycle operations.\nThis gives you more power over how the container is created and managed while it is running.\nThis will also launch the container in the background so you will have to edit\nthe `config.json` to remove the `terminal` setting for the simple examples\nbelow (see more details about [runc terminal handling](docs/terminals.md)).\nYour process field in the `config.json` should look like this below with `\"terminal\": false` and `\"args\": [\"sleep\", \"5\"]`.\n\n\n```json\n        \"process\": {\n                \"terminal\": false,\n                \"user\": {\n                        \"uid\": 0,\n                        \"gid\": 0\n                },\n                \"args\": [\n                        \"sleep\", \"5\"\n                ],\n                \"env\": [\n                        \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n                        \"TERM=xterm\"\n                ],\n                \"cwd\": \"/\",\n                \"capabilities\": {\n                        \"bounding\": [\n                                \"CAP_AUDIT_WRITE\",\n                                \"CAP_KILL\",\n                                \"CAP_NET_BIND_SERVICE\"\n                        ],\n                        \"effective\": [\n                                \"CAP_AUDIT_WRITE\",\n                                \"CAP_KILL\",\n                                \"CAP_NET_BIND_SERVICE\"\n                        ],\n                        \"inheritable\": [\n                                \"CAP_AUDIT_WRITE\",\n                                \"CAP_KILL\",\n                                \"CAP_NET_BIND_SERVICE\"\n                        ],\n                        \"permitted\": [\n                                \"CAP_AUDIT_WRITE\",\n                                \"CAP_KILL\",\n                                \"CAP_NET_BIND_SERVICE\"\n                        ],\n                        \"ambient\": [\n                                \"CAP_AUDIT_WRITE\",\n                                \"CAP_KILL\",\n                                \"CAP_NET_BIND_SERVICE\"\n                        ]\n                },\n                \"rlimits\": [\n                        {\n                                \"type\": \"RLIMIT_NOFILE\",\n                                \"hard\": 1024,\n                                \"soft\": 1024\n                        }\n                ],\n                \"noNewPrivileges\": true\n        },\n```\n\nNow we can go through the lifecycle operations in your shell.\n\n\n```bash\n# run as root\ncd /mycontainer\nrunc create mycontainerid\n\n# view the container is created and in the \"created\" state\nrunc list\n\n# start the process inside the container\nrunc start mycontainerid\n\n# after 5 seconds view that the container has exited and is now in the stopped state\nrunc list\n\n# now delete the container\nrunc delete mycontainerid\n```\n\nThis allows higher level systems to augment the containers creation logic with setup of various settings after the container is created and/or before it is deleted. For example, the container's network stack is commonly set up after `create` but before `start`.\n\n#### Rootless containers\n`runc` has the ability to run containers without root privileges. This is called `rootless`. You need to pass some parameters to `runc` in order to run rootless containers. See below and compare with the previous version.\n\n**Note:** In order to use this feature, \"User Namespaces\" must be compiled and enabled in your kernel. There are various ways to do this depending on your distribution:\n- Confirm `CONFIG_USER_NS=y` is set in your kernel configuration (normally found in `/proc/config.gz`)\n- Arch/Debian: `echo 1 > /proc/sys/kernel/unprivileged_userns_clone`\n- RHEL/CentOS 7: `echo 28633 > /proc/sys/user/max_user_namespaces`\n\nRun the following commands as an ordinary user:\n```bash\n# Same as the first example\nmkdir ~/mycontainer\ncd ~/mycontainer\nmkdir rootfs\ndocker export $(docker create busybox) | tar -C rootfs -xvf -\n\n# The --rootless parameter instructs runc spec to generate a configuration for a rootless container, which will allow you to run the container as a non-root user.\nrunc spec --rootless\n\n# The --root parameter tells runc where to store the container state. It must be writable by the user.\nrunc --root /tmp/runc run mycontainerid\n```\n\n#### Supervisors\n\n`runc` can be used with process supervisors and init systems to ensure that containers are restarted when they exit.\nAn example systemd unit file looks something like this.\n\n```systemd\n[Unit]\nDescription=Start My Container\n\n[Service]\nType=forking\nExecStart=/usr/local/sbin/runc run -d --pid-file /run/mycontainerid.pid mycontainerid\nExecStopPost=/usr/local/sbin/runc delete mycontainerid\nWorkingDirectory=/mycontainer\nPIDFile=/run/mycontainerid.pid\n\n[Install]\nWantedBy=multi-user.target\n```\n\n## More documentation\n\n* [Spec conformance](./docs/spec-conformance.md)\n* [cgroup v2](./docs/cgroup-v2.md)\n* [Checkpoint and restore](./docs/checkpoint-restore.md)\n* [systemd cgroup driver](./docs/systemd.md)\n* [Terminals and standard IO](./docs/terminals.md)\n* [Experimental features](./docs/experimental.md)\n\n## License\n\nThe code and docs are released under the [Apache 2.0 license](LICENSE).\n"
        },
        {
          "name": "RELEASES.md",
          "type": "blob",
          "size": 5.4541015625,
          "content": "## Release Cadence and Support Policy ##\n\nThis document describes the release cadence for runc as well as outlining the\nsupport policy for old release branches. Historically, despite runc being the\nmost widely used Linux container runtime, our release schedule has been very\nad-hoc and has resulted in very long periods of time between minor releases,\ncausing issues for downstreams that wanted particular features.\n\n### Semantic Versioning ###\n\nrunc uses [Semantic Versioning][semver] for releases. However, our\ncompatibility policy only applies to the runc binary. We will make a\nbest-effort attempt to reduce the impact to users that make direct use of the\nGo packages prefixed with `github.com/opencontainers/runc`, but we do not\nformally guarantee that API compatibility will be preserved.\n\n[semver]: https://semver.org/spec/v2.0.0.html\n\n### Release Cadence ###\n\n> **NOTE**: At time of writing, this proposal is still a draft as we have not\n> yet done several releases using this cadence. If you have feedback on this\n> proposal (such as how well this proposal addresses your needs as a downstream\n> packager of runc), please feel free to [open an issue][new-issue] so we can\n> discuss it further. However, the current plan is for this proposal to be\n> followed for the `1.3.0` and `1.4.0` releases in 2025.\n\n[new-issue]: https://github.com/opencontainers/runc/issues/new/choose\n\nrunc follows a 6-month minor version release schedule, with the aim of releases\nhappening at the end of April and October each year.\n\nThe first release candidate will be created 2 months before the planned release\ndate (i.e. the end of February and August, respectively), at which point the\nrelease branch will be created and will enter a feature freeze. No new features\nwill be merged into the release branch, and large features being developed\nimmediately before the feature freeze may have their merge delayed so as to not\nbe included in the next release. Most releases will have two or three release\ncandidates, but this may change depending on the circumstances of the release\nat the time.\n\nIf a last-minute critical issue is discovered, the release may be delayed.\nHowever, the following release will still go according to schedule (except in\nthe exceptionally unlikely scenario where the delay is 4-6 months long, in\nwhich case the next release is moved forward to when the subsequent release\nwould have been).\n\nHere is a hypothetical release timeline to see how this works in practice:\n\n| Date       | Release      | Notes |\n| ---------- | ------------ | ----- |\n| 200X-02-28 | `1.3.0-rc.1` | `release-1.3` branch created, feature freeze. |\n| 200X-03-12 | `1.3.0-rc.2` | |\n| 200X-03-25 | `1.3.0-rc.3` | |\n| 200X-04-30 | `1.3.0`      | `1.3` release published. |\n| 200X-05-10 | `1.3.1`      | |\n| 200X-06-21 | `1.3.2`      | |\n| 200X-06-25 | `1.3.3`      | |\n| 200X-07-02 | `1.3.4`      | |\n| 200X-08-28 | `1.4.0-rc.1` | `release-1.4` branch created, feature freeze. |\n| 200X-09-15 | `1.3.5`      | Patch releases in other release branches have no impact on the new release branch. |\n| 200X-09-21 | `1.4.0-rc.2` | |\n| 200X-10-31 | `1.4.0`      | `1.4` release published. |\n| 200X-11-10 | `1.4.1`      | |\n| 200X-12-25 | `1.4.2`      | |\n\n(And so on for the next year.)\n\n### Support Policy ###\n\n> **NOTE**: The following policy provides much longer support guarantees than\n> we have historically provided for older runc releases. In order to avoid\n> adding new support guarantees for old runc versions we have long-since\n> stopped supporting, the following support policy only applies for runc\n> releases from `1.2.0` onwards. In other words, runc `1.1.0` and `1.0.0` are\n> not guaranteed support by this policy.\n\nIn order to ease the transition between minor runc releases, previous minor\nrelease branches of runc will be maintained for some time after the newest\nminor release is published. In the following text, `latest` refers to the\nlatest minor (non-release-candidate) runc release published; `latest-1` is the\nprevious minor release branch; and `latest-2` is the minor release branch\nbefore `latest-1`. For example, if `latest` is `1.4.0` then `latest-1` is\n`1.3.z` and `latest-2` is `1.2.z`.\n\n * Once `latest` is released, new features will no longer be merged into\n   `latest` and only bug and security fixes will be backported, though we will\n   be fairly liberal with what kinds of bugs will considered candidates for\n   backporting.\n\n * `latest-1` will only receive security fixes and significant bug fixes (what\n   bug fixes are \"significant\" are down to the maintainer's judgement, but\n   maintainers should err on the side of reducing the number of backports at\n   this stage). At this stage, users of `latest-1` are encouraged to start\n   planning the migration to the `latest` release of runc (as well as reporting\n   any issues they may find).\n\n * `latest-2` will only receive high severity security fixes (i.e. CVEs that\n   have been assessed as having a CVSS score of 7.0 or higher). At this stage,\n   users still using `latest-2` would be strongly encouraged to upgrade to\n   either `latest` or `latest-1`.\n\n * Any older releases will no longer receive any updates, and users are\n   encouraged to upgrade in the strongest possible terms, as they will not\n   receive any security fixes regardless of severity or impact.\n\nThis policy only applies to minor releases of runc with major version `1`. If\nthere is a runc `2.0` release in the future, this document will be updated to\nreflect the necessary changes to the support policy for the `1.y` major release\nbranch of runc.\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.232421875,
          "content": "# Security\n\nWhen reporting a security issue, do not create an issue or file a pull request on GitHub.\nThe reporting process and disclosure communications are outlined [here](https://github.com/opencontainers/org/blob/master/SECURITY.md).\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.009765625,
          "content": "1.2.0+dev\n"
        },
        {
          "name": "Vagrantfile.fedora",
          "type": "blob",
          "size": 1.9873046875,
          "content": "# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"fedora-41\"\n  # For URL, check https://www.fedoraproject.org/cloud/download\n  config.vm.box_url = \"https://download.fedoraproject.org/pub/fedora/linux/releases/41/Cloud/x86_64/images/Fedora-Cloud-Base-Vagrant-libvirt-41-1.4.x86_64.vagrant.libvirt.box\"\n  config.vm.provider :virtualbox do |v|\n    v.memory = 2048\n    v.cpus = 2\n  end\n  config.vm.provider :libvirt do |v|\n    v.memory = 2048\n    v.cpus = 2\n  end\n  config.vm.provision \"shell\", inline: <<-SHELL\n    set -e -u -o pipefail\n    DNF_OPTS=\"-y --setopt=install_weak_deps=False --setopt=tsflags=nodocs --exclude=kernel,kernel-core\"\n    RPMS=\"bats git-core glibc-static golang jq libseccomp-devel make\"\n    # Work around dnf mirror failures by retrying a few times.\n    for i in $(seq 0 2); do\n      sleep $i\n      dnf $DNF_OPTS update && dnf $DNF_OPTS install $RPMS && break\n    done\n    dnf clean all\n\n    # To avoid \"avc: denied { nosuid_transition }\" from SELinux as we run tests on /tmp.\n    mount -o remount,suid /tmp\n\n    # Prevent the \"fatal: unsafe repository\" git complain during build.\n    git config --global --add safe.directory /vagrant\n\n    # Add a user for rootless tests\n    useradd -u2000 -m -d/home/rootless -s/bin/bash rootless\n\n    # Allow root and rootless itself to execute `ssh rootless@localhost` in tests/rootless.sh\n    ssh-keygen -t ecdsa -N \"\" -f /root/rootless.key\n    mkdir -m 0700 -p /home/rootless/.ssh\n    cp /root/rootless.key /home/rootless/.ssh/id_ecdsa\n    cat /root/rootless.key.pub >> /home/rootless/.ssh/authorized_keys\n    chown -R rootless.rootless /home/rootless\n\n    # Delegate cgroup v2 controllers to rootless user via --systemd-cgroup\n    mkdir -p /etc/systemd/system/user@.service.d\n    cat > /etc/systemd/system/user@.service.d/delegate.conf << EOF\n[Service]\n# default: Delegate=pids memory\n# NOTE: delegation of cpuset requires systemd >= 244 (Fedora >= 32, Ubuntu >= 20.04).\nDelegate=yes\nEOF\n    systemctl daemon-reload\n  SHELL\nend\n"
        },
        {
          "name": "checkpoint.go",
          "type": "blob",
          "size": 5.66796875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\n\t\"github.com/moby/sys/userns\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n)\n\nvar checkpointCommand = cli.Command{\n\tName:  \"checkpoint\",\n\tUsage: \"checkpoint a running container\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container to be\ncheckpointed.`,\n\tDescription: `The checkpoint command saves the state of the container instance.`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{Name: \"image-path\", Value: \"\", Usage: \"path for saving criu image files\"},\n\t\tcli.StringFlag{Name: \"work-path\", Value: \"\", Usage: \"path for saving work files and logs\"},\n\t\tcli.StringFlag{Name: \"parent-path\", Value: \"\", Usage: \"path for previous criu image files in pre-dump\"},\n\t\tcli.BoolFlag{Name: \"leave-running\", Usage: \"leave the process running after checkpointing\"},\n\t\tcli.BoolFlag{Name: \"tcp-established\", Usage: \"allow open tcp connections\"},\n\t\tcli.BoolFlag{Name: \"ext-unix-sk\", Usage: \"allow external unix sockets\"},\n\t\tcli.BoolFlag{Name: \"shell-job\", Usage: \"allow shell jobs\"},\n\t\tcli.BoolFlag{Name: \"lazy-pages\", Usage: \"use userfaultfd to lazily restore memory pages\"},\n\t\tcli.IntFlag{Name: \"status-fd\", Value: -1, Usage: \"criu writes \\\\0 to this FD once lazy-pages is ready\"},\n\t\tcli.StringFlag{Name: \"page-server\", Value: \"\", Usage: \"ADDRESS:PORT of the page server\"},\n\t\tcli.BoolFlag{Name: \"file-locks\", Usage: \"handle file locks, for safety\"},\n\t\tcli.BoolFlag{Name: \"pre-dump\", Usage: \"dump container's memory information only, leave the container running after this\"},\n\t\tcli.StringFlag{Name: \"manage-cgroups-mode\", Value: \"\", Usage: \"cgroups mode: soft|full|strict|ignore (default: soft)\"},\n\t\tcli.StringSliceFlag{Name: \"empty-ns\", Usage: \"create a namespace, but don't restore its properties\"},\n\t\tcli.BoolFlag{Name: \"auto-dedup\", Usage: \"enable auto deduplication of memory images\"},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// XXX: Currently this is untested with rootless containers.\n\t\tif os.Geteuid() != 0 || userns.RunningInUserNS() {\n\t\t\tlogrus.Warn(\"runc checkpoint is untested with rootless containers\")\n\t\t}\n\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := container.Status()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif status == libcontainer.Created || status == libcontainer.Stopped {\n\t\t\treturn fmt.Errorf(\"Container cannot be checkpointed in %s state\", status.String())\n\t\t}\n\t\toptions, err := criuOptions(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = container.Checkpoint(options)\n\t\tif err == nil && !(options.LeaveRunning || options.PreDump) {\n\t\t\t// Destroy the container unless we tell CRIU to keep it.\n\t\t\tif err := container.Destroy(); err != nil {\n\t\t\t\tlogrus.Warn(err)\n\t\t\t}\n\t\t}\n\t\treturn err\n\t},\n}\n\nfunc prepareImagePaths(context *cli.Context) (string, string, error) {\n\timagePath := context.String(\"image-path\")\n\tif imagePath == \"\" {\n\t\timagePath = getDefaultImagePath()\n\t}\n\n\tif err := os.MkdirAll(imagePath, 0o600); err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\n\tparentPath := context.String(\"parent-path\")\n\tif parentPath == \"\" {\n\t\treturn imagePath, parentPath, nil\n\t}\n\n\tif filepath.IsAbs(parentPath) {\n\t\treturn \"\", \"\", errors.New(\"--parent-path must be relative\")\n\t}\n\n\trealParent := filepath.Join(imagePath, parentPath)\n\tfi, err := os.Stat(realParent)\n\tif err == nil && !fi.IsDir() {\n\t\terr = &os.PathError{Path: realParent, Err: unix.ENOTDIR}\n\t}\n\n\tif err != nil {\n\t\treturn \"\", \"\", fmt.Errorf(\"invalid --parent-path: %w\", err)\n\t}\n\n\treturn imagePath, parentPath, nil\n}\n\nfunc criuOptions(context *cli.Context) (*libcontainer.CriuOpts, error) {\n\timagePath, parentPath, err := prepareImagePaths(context)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\topts := &libcontainer.CriuOpts{\n\t\tImagesDirectory:         imagePath,\n\t\tWorkDirectory:           context.String(\"work-path\"),\n\t\tParentImage:             parentPath,\n\t\tLeaveRunning:            context.Bool(\"leave-running\"),\n\t\tTcpEstablished:          context.Bool(\"tcp-established\"),\n\t\tExternalUnixConnections: context.Bool(\"ext-unix-sk\"),\n\t\tShellJob:                context.Bool(\"shell-job\"),\n\t\tFileLocks:               context.Bool(\"file-locks\"),\n\t\tPreDump:                 context.Bool(\"pre-dump\"),\n\t\tAutoDedup:               context.Bool(\"auto-dedup\"),\n\t\tLazyPages:               context.Bool(\"lazy-pages\"),\n\t\tStatusFd:                context.Int(\"status-fd\"),\n\t\tLsmProfile:              context.String(\"lsm-profile\"),\n\t\tLsmMountContext:         context.String(\"lsm-mount-context\"),\n\t\tManageCgroupsMode:       context.String(\"manage-cgroups-mode\"),\n\t}\n\n\t// CRIU options below may or may not be set.\n\n\tif psOpt := context.String(\"page-server\"); psOpt != \"\" {\n\t\taddress, port, err := net.SplitHostPort(psOpt)\n\n\t\tif err != nil || address == \"\" || port == \"\" {\n\t\t\treturn nil, errors.New(\"Use --page-server ADDRESS:PORT to specify page server\")\n\t\t}\n\t\tportInt, err := strconv.Atoi(port)\n\t\tif err != nil {\n\t\t\treturn nil, errors.New(\"Invalid port number\")\n\t\t}\n\t\topts.PageServer = libcontainer.CriuPageServerInfo{\n\t\t\tAddress: address,\n\t\t\tPort:    int32(portInt),\n\t\t}\n\t}\n\n\t// runc doesn't manage network devices and their configuration.\n\tnsmask := unix.CLONE_NEWNET\n\n\tif context.IsSet(\"empty-ns\") {\n\t\tnamespaceMapping := map[specs.LinuxNamespaceType]int{\n\t\t\tspecs.NetworkNamespace: unix.CLONE_NEWNET,\n\t\t}\n\n\t\tfor _, ns := range context.StringSlice(\"empty-ns\") {\n\t\t\tf, exists := namespaceMapping[specs.LinuxNamespaceType(ns)]\n\t\t\tif !exists {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace %q is not supported\", ns)\n\t\t\t}\n\t\t\tnsmask |= f\n\t\t}\n\t}\n\n\topts.EmptyNs = uint32(nsmask)\n\n\treturn opts, nil\n}\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "create.go",
          "type": "blob",
          "size": 2.32421875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar createCommand = cli.Command{\n\tName:  \"create\",\n\tUsage: \"create a container\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is your name for the instance of the container that you\nare starting. The name you provide for the container instance must be unique on\nyour host.`,\n\tDescription: `The create command creates an instance of a container for a bundle. The bundle\nis a directory with a specification file named \"` + specConfig + `\" and a root\nfilesystem.\n\nThe specification file includes an args parameter. The args parameter is used\nto specify command(s) that get run when the container is started. To change the\ncommand(s) that get executed on start, edit the args parameter of the spec. See\n\"runc spec --help\" for more explanation.`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"bundle, b\",\n\t\t\tValue: \"\",\n\t\t\tUsage: `path to the root of the bundle directory, defaults to the current directory`,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"console-socket\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pidfd-socket\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the init process\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pid-file\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"specify the file to write the process id to\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-pivot\",\n\t\t\tUsage: \"do not use pivot root to jail process inside rootfs.  This should be used whenever the rootfs is on top of a ramdisk\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-new-keyring\",\n\t\t\tUsage: \"do not create a new session keyring for the container.  This will cause the container to inherit the calling processes session key\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:  \"preserve-fds\",\n\t\t\tUsage: \"Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total)\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := startContainer(context, CT_ACT_CREATE, nil)\n\t\tif err == nil {\n\t\t\t// exit with the container's exit status so any external supervisor\n\t\t\t// is notified of the exit with the correct exit status.\n\t\t\tos.Exit(status)\n\t\t}\n\t\treturn fmt.Errorf(\"runc create failed: %w\", err)\n\t},\n}\n"
        },
        {
          "name": "delete.go",
          "type": "blob",
          "size": 2.451171875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/urfave/cli\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc killContainer(container *libcontainer.Container) error {\n\t_ = container.Signal(unix.SIGKILL)\n\tfor i := 0; i < 100; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tif err := container.Signal(unix.Signal(0)); err != nil {\n\t\t\treturn container.Destroy()\n\t\t}\n\t}\n\treturn errors.New(\"container init still running\")\n}\n\nvar deleteCommand = cli.Command{\n\tName:  \"delete\",\n\tUsage: \"delete any resources held by the container often used with detached container\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container.\n\nEXAMPLE:\nFor example, if the container id is \"ubuntu01\" and runc list currently shows the\nstatus of \"ubuntu01\" as \"stopped\" the following will delete resources held for\n\"ubuntu01\" removing \"ubuntu01\" from the runc list of containers:\n\n       # runc delete ubuntu01`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"force, f\",\n\t\t\tUsage: \"Forcibly deletes the container if it is still running (uses SIGKILL)\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tid := context.Args().First()\n\t\tforce := context.Bool(\"force\")\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, libcontainer.ErrNotExist) {\n\t\t\t\t// if there was an aborted start or something of the sort then the container's directory could exist but\n\t\t\t\t// libcontainer does not see it because the state.json file inside that directory was never created.\n\t\t\t\tpath := filepath.Join(context.GlobalString(\"root\"), id)\n\t\t\t\tif e := os.RemoveAll(path); e != nil {\n\t\t\t\t\tfmt.Fprintf(os.Stderr, \"remove %s: %v\\n\", path, e)\n\t\t\t\t}\n\t\t\t\tif force {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\t// When --force is given, we kill all container processes and\n\t\t// then destroy the container. This is done even for a stopped\n\t\t// container, because (in case it does not have its own PID\n\t\t// namespace) there may be some leftover processes in the\n\t\t// container's cgroup.\n\t\tif force {\n\t\t\treturn killContainer(container)\n\t\t}\n\t\ts, err := container.Status()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch s {\n\t\tcase libcontainer.Stopped:\n\t\t\treturn container.Destroy()\n\t\tcase libcontainer.Created:\n\t\t\treturn killContainer(container)\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"cannot delete container %s that is not stopped: %s\", id, s)\n\t\t}\n\t},\n}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "events.go",
          "type": "blob",
          "size": 6.1015625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/types\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n)\n\nvar eventsCommand = cli.Command{\n\tName:  \"events\",\n\tUsage: \"display container events such as OOM notifications, cpu, memory, and IO usage statistics\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container.`,\n\tDescription: `The events command displays information about the container. By default the\ninformation is displayed once every 5 seconds.`,\n\tFlags: []cli.Flag{\n\t\tcli.DurationFlag{Name: \"interval\", Value: 5 * time.Second, Usage: \"set the stats collection interval\"},\n\t\tcli.BoolFlag{Name: \"stats\", Usage: \"display the container's stats then exit\"},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tduration := context.Duration(\"interval\")\n\t\tif duration <= 0 {\n\t\t\treturn errors.New(\"duration interval must be greater than 0\")\n\t\t}\n\t\tstatus, err := container.Status()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif status == libcontainer.Stopped {\n\t\t\treturn fmt.Errorf(\"container with id %s is not running\", container.ID())\n\t\t}\n\t\tvar (\n\t\t\tstats  = make(chan *libcontainer.Stats, 1)\n\t\t\tevents = make(chan *types.Event, 1024)\n\t\t\tgroup  = &sync.WaitGroup{}\n\t\t)\n\t\tgroup.Add(1)\n\t\tgo func() {\n\t\t\tdefer group.Done()\n\t\t\tenc := json.NewEncoder(os.Stdout)\n\t\t\tfor e := range events {\n\t\t\t\tif err := enc.Encode(e); err != nil {\n\t\t\t\t\tlogrus.Error(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tif context.Bool(\"stats\") {\n\t\t\ts, err := container.Stats()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tevents <- &types.Event{Type: \"stats\", ID: container.ID(), Data: convertLibcontainerStats(s)}\n\t\t\tclose(events)\n\t\t\tgroup.Wait()\n\t\t\treturn nil\n\t\t}\n\t\tgo func() {\n\t\t\tfor range time.Tick(context.Duration(\"interval\")) {\n\t\t\t\ts, err := container.Stats()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlogrus.Error(err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tstats <- s\n\t\t\t}\n\t\t}()\n\t\tn, err := container.NotifyOOM()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase _, ok := <-n:\n\t\t\t\tif ok {\n\t\t\t\t\t// this means an oom event was received, if it is !ok then\n\t\t\t\t\t// the channel was closed because the container stopped and\n\t\t\t\t\t// the cgroups no longer exist.\n\t\t\t\t\tevents <- &types.Event{Type: \"oom\", ID: container.ID()}\n\t\t\t\t} else {\n\t\t\t\t\tn = nil\n\t\t\t\t}\n\t\t\tcase s := <-stats:\n\t\t\t\tevents <- &types.Event{Type: \"stats\", ID: container.ID(), Data: convertLibcontainerStats(s)}\n\t\t\t}\n\t\t\tif n == nil {\n\t\t\t\tclose(events)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tgroup.Wait()\n\t\treturn nil\n\t},\n}\n\nfunc convertLibcontainerStats(ls *libcontainer.Stats) *types.Stats {\n\tcg := ls.CgroupStats\n\tif cg == nil {\n\t\treturn nil\n\t}\n\tvar s types.Stats\n\ts.Pids.Current = cg.PidsStats.Current\n\ts.Pids.Limit = cg.PidsStats.Limit\n\n\ts.CPU.Usage.Kernel = cg.CpuStats.CpuUsage.UsageInKernelmode\n\ts.CPU.Usage.User = cg.CpuStats.CpuUsage.UsageInUsermode\n\ts.CPU.Usage.Total = cg.CpuStats.CpuUsage.TotalUsage\n\ts.CPU.Usage.Percpu = cg.CpuStats.CpuUsage.PercpuUsage\n\ts.CPU.Usage.PercpuKernel = cg.CpuStats.CpuUsage.PercpuUsageInKernelmode\n\ts.CPU.Usage.PercpuUser = cg.CpuStats.CpuUsage.PercpuUsageInUsermode\n\ts.CPU.Throttling.Periods = cg.CpuStats.ThrottlingData.Periods\n\ts.CPU.Throttling.ThrottledPeriods = cg.CpuStats.ThrottlingData.ThrottledPeriods\n\ts.CPU.Throttling.ThrottledTime = cg.CpuStats.ThrottlingData.ThrottledTime\n\ts.CPU.PSI = cg.CpuStats.PSI\n\n\ts.CPUSet = types.CPUSet(cg.CPUSetStats)\n\n\ts.Memory.Cache = cg.MemoryStats.Cache\n\ts.Memory.Kernel = convertMemoryEntry(cg.MemoryStats.KernelUsage)\n\ts.Memory.KernelTCP = convertMemoryEntry(cg.MemoryStats.KernelTCPUsage)\n\ts.Memory.Swap = convertMemoryEntry(cg.MemoryStats.SwapUsage)\n\ts.Memory.Usage = convertMemoryEntry(cg.MemoryStats.Usage)\n\ts.Memory.Raw = cg.MemoryStats.Stats\n\ts.Memory.PSI = cg.MemoryStats.PSI\n\n\ts.Blkio.IoServiceBytesRecursive = convertBlkioEntry(cg.BlkioStats.IoServiceBytesRecursive)\n\ts.Blkio.IoServicedRecursive = convertBlkioEntry(cg.BlkioStats.IoServicedRecursive)\n\ts.Blkio.IoQueuedRecursive = convertBlkioEntry(cg.BlkioStats.IoQueuedRecursive)\n\ts.Blkio.IoServiceTimeRecursive = convertBlkioEntry(cg.BlkioStats.IoServiceTimeRecursive)\n\ts.Blkio.IoWaitTimeRecursive = convertBlkioEntry(cg.BlkioStats.IoWaitTimeRecursive)\n\ts.Blkio.IoMergedRecursive = convertBlkioEntry(cg.BlkioStats.IoMergedRecursive)\n\ts.Blkio.IoTimeRecursive = convertBlkioEntry(cg.BlkioStats.IoTimeRecursive)\n\ts.Blkio.SectorsRecursive = convertBlkioEntry(cg.BlkioStats.SectorsRecursive)\n\ts.Blkio.PSI = cg.BlkioStats.PSI\n\n\ts.Hugetlb = make(map[string]types.Hugetlb)\n\tfor k, v := range cg.HugetlbStats {\n\t\ts.Hugetlb[k] = convertHugtlb(v)\n\t}\n\n\tif is := ls.IntelRdtStats; is != nil {\n\t\tif intelrdt.IsCATEnabled() {\n\t\t\ts.IntelRdt.L3CacheInfo = convertL3CacheInfo(is.L3CacheInfo)\n\t\t\ts.IntelRdt.L3CacheSchemaRoot = is.L3CacheSchemaRoot\n\t\t\ts.IntelRdt.L3CacheSchema = is.L3CacheSchema\n\t\t}\n\t\tif intelrdt.IsMBAEnabled() {\n\t\t\ts.IntelRdt.MemBwInfo = convertMemBwInfo(is.MemBwInfo)\n\t\t\ts.IntelRdt.MemBwSchemaRoot = is.MemBwSchemaRoot\n\t\t\ts.IntelRdt.MemBwSchema = is.MemBwSchema\n\t\t}\n\t\tif intelrdt.IsMBMEnabled() {\n\t\t\ts.IntelRdt.MBMStats = is.MBMStats\n\t\t}\n\t\tif intelrdt.IsCMTEnabled() {\n\t\t\ts.IntelRdt.CMTStats = is.CMTStats\n\t\t}\n\t}\n\n\ts.NetworkInterfaces = ls.Interfaces\n\treturn &s\n}\n\nfunc convertHugtlb(c cgroups.HugetlbStats) types.Hugetlb {\n\treturn types.Hugetlb{\n\t\tUsage:   c.Usage,\n\t\tMax:     c.MaxUsage,\n\t\tFailcnt: c.Failcnt,\n\t}\n}\n\nfunc convertMemoryEntry(c cgroups.MemoryData) types.MemoryEntry {\n\treturn types.MemoryEntry{\n\t\tLimit:   c.Limit,\n\t\tUsage:   c.Usage,\n\t\tMax:     c.MaxUsage,\n\t\tFailcnt: c.Failcnt,\n\t}\n}\n\nfunc convertBlkioEntry(c []cgroups.BlkioStatEntry) []types.BlkioEntry {\n\tvar out []types.BlkioEntry\n\tfor _, e := range c {\n\t\tout = append(out, types.BlkioEntry(e))\n\t}\n\treturn out\n}\n\nfunc convertL3CacheInfo(i *intelrdt.L3CacheInfo) *types.L3CacheInfo {\n\tci := types.L3CacheInfo(*i)\n\treturn &ci\n}\n\nfunc convertMemBwInfo(i *intelrdt.MemBwInfo) *types.MemBwInfo {\n\tmi := types.MemBwInfo(*i)\n\treturn &mi\n}\n"
        },
        {
          "name": "exec.go",
          "type": "blob",
          "size": 7.50390625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/urfave/cli\"\n)\n\nvar execCommand = cli.Command{\n\tName:  \"exec\",\n\tUsage: \"execute new process inside the container\",\n\tArgsUsage: `<container-id> <command> [command options]  || -p process.json <container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container and\n\"<command>\" is the command to be executed in the container.\n\"<command>\" can't be empty unless a \"-p\" flag provided.\n\nEXAMPLE:\nFor example, if the container is configured to run the linux ps command the\nfollowing will output a list of processes running in the container:\n\n       # runc exec <container-id> ps`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"console-socket\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pidfd-socket\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the exec process\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cwd\",\n\t\t\tUsage: \"current working directory in the container\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"env, e\",\n\t\t\tUsage: \"set environment variables\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"tty, t\",\n\t\t\tUsage: \"allocate a pseudo-TTY\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"user, u\",\n\t\t\tUsage: \"UID (format: <uid>[:<gid>])\",\n\t\t},\n\t\tcli.Int64SliceFlag{\n\t\t\tName:  \"additional-gids, g\",\n\t\t\tUsage: \"additional gids\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"process, p\",\n\t\t\tUsage: \"path to the process.json\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"detach,d\",\n\t\t\tUsage: \"detach from the container's process\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pid-file\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"specify the file to write the process id to\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"process-label\",\n\t\t\tUsage: \"set the asm process label for the process commonly used with selinux\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"apparmor\",\n\t\t\tUsage: \"set the apparmor profile for the process\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-new-privs\",\n\t\t\tUsage: \"set the no new privileges value for the process\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"cap, c\",\n\t\t\tValue: &cli.StringSlice{},\n\t\t\tUsage: \"add a capability to the bounding set for the process\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:  \"preserve-fds\",\n\t\t\tUsage: \"Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total)\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"cgroup\",\n\t\t\tUsage: \"run the process in an (existing) sub-cgroup(s). Format is [<controller>:]<cgroup>.\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"ignore-paused\",\n\t\t\tUsage: \"allow exec in a paused container\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, minArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := revisePidFile(context); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := execProcess(context)\n\t\tif err == nil {\n\t\t\tos.Exit(status)\n\t\t}\n\t\tfatalWithCode(fmt.Errorf(\"exec failed: %w\", err), 255)\n\t\treturn nil // to satisfy the linter\n\t},\n\tSkipArgReorder: true,\n}\n\nfunc getSubCgroupPaths(args []string) (map[string]string, error) {\n\tif len(args) == 0 {\n\t\treturn nil, nil\n\t}\n\tpaths := make(map[string]string, len(args))\n\tfor _, c := range args {\n\t\t// Split into controller:path.\n\t\tcs := strings.SplitN(c, \":\", 3)\n\t\tif len(cs) > 2 {\n\t\t\treturn nil, fmt.Errorf(\"invalid --cgroup argument: %s\", c)\n\t\t}\n\t\tif len(cs) == 1 { // no controller: prefix\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid --cgroup argument: %s (missing <controller>: prefix)\", c)\n\t\t\t}\n\t\t\tpaths[\"\"] = c\n\t\t} else {\n\t\t\t// There may be a few comma-separated controllers.\n\t\t\tfor _, ctrl := range strings.Split(cs[0], \",\") {\n\t\t\t\tpaths[ctrl] = cs[1]\n\t\t\t}\n\t\t}\n\t}\n\treturn paths, nil\n}\n\nfunc execProcess(context *cli.Context) (int, error) {\n\tcontainer, err := getContainer(context)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tstatus, err := container.Status()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tif status == libcontainer.Stopped {\n\t\treturn -1, errors.New(\"cannot exec in a stopped container\")\n\t}\n\tif status == libcontainer.Paused && !context.Bool(\"ignore-paused\") {\n\t\treturn -1, errors.New(\"cannot exec in a paused container (use --ignore-paused to override)\")\n\t}\n\tpath := context.String(\"process\")\n\tif path == \"\" && len(context.Args()) == 1 {\n\t\treturn -1, errors.New(\"process args cannot be empty\")\n\t}\n\tstate, err := container.State()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tbundle, ok := utils.SearchLabels(state.Config.Labels, \"bundle\")\n\tif !ok {\n\t\treturn -1, errors.New(\"bundle not found in labels\")\n\t}\n\tp, err := getProcess(context, bundle)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tcgPaths, err := getSubCgroupPaths(context.StringSlice(\"cgroup\"))\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tr := &runner{\n\t\tenableSubreaper: false,\n\t\tshouldDestroy:   false,\n\t\tcontainer:       container,\n\t\tconsoleSocket:   context.String(\"console-socket\"),\n\t\tpidfdSocket:     context.String(\"pidfd-socket\"),\n\t\tdetach:          context.Bool(\"detach\"),\n\t\tpidFile:         context.String(\"pid-file\"),\n\t\taction:          CT_ACT_RUN,\n\t\tinit:            false,\n\t\tpreserveFDs:     context.Int(\"preserve-fds\"),\n\t\tsubCgroupPaths:  cgPaths,\n\t}\n\treturn r.run(p)\n}\n\nfunc getProcess(context *cli.Context, bundle string) (*specs.Process, error) {\n\tif path := context.String(\"process\"); path != \"\" {\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer f.Close()\n\t\tvar p specs.Process\n\t\tif err := json.NewDecoder(f).Decode(&p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &p, validateProcessSpec(&p)\n\t}\n\t// process via cli flags\n\tif err := os.Chdir(bundle); err != nil {\n\t\treturn nil, err\n\t}\n\tspec, err := loadSpec(specConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := spec.Process\n\tp.Args = context.Args()[1:]\n\t// Override the cwd, if passed.\n\tif cwd := context.String(\"cwd\"); cwd != \"\" {\n\t\tp.Cwd = cwd\n\t}\n\tif ap := context.String(\"apparmor\"); ap != \"\" {\n\t\tp.ApparmorProfile = ap\n\t}\n\tif l := context.String(\"process-label\"); l != \"\" {\n\t\tp.SelinuxLabel = l\n\t}\n\tif caps := context.StringSlice(\"cap\"); len(caps) > 0 {\n\t\tfor _, c := range caps {\n\t\t\tp.Capabilities.Bounding = append(p.Capabilities.Bounding, c)\n\t\t\tp.Capabilities.Effective = append(p.Capabilities.Effective, c)\n\t\t\tp.Capabilities.Permitted = append(p.Capabilities.Permitted, c)\n\t\t\t// Since ambient capabilities can't be set without inherritable,\n\t\t\t// and runc exec --cap don't set inheritable, let's only set\n\t\t\t// ambient if we already have some inheritable bits set from spec.\n\t\t\tif p.Capabilities.Inheritable != nil {\n\t\t\t\tp.Capabilities.Ambient = append(p.Capabilities.Ambient, c)\n\t\t\t}\n\t\t}\n\t}\n\t// append the passed env variables\n\tp.Env = append(p.Env, context.StringSlice(\"env\")...)\n\n\t// Always set tty to false, unless explicitly enabled from CLI.\n\tp.Terminal = context.Bool(\"tty\")\n\tif context.IsSet(\"no-new-privs\") {\n\t\tp.NoNewPrivileges = context.Bool(\"no-new-privs\")\n\t}\n\t// Override the user, if passed.\n\tif user := context.String(\"user\"); user != \"\" {\n\t\tuids, gids, ok := strings.Cut(user, \":\")\n\t\tif ok {\n\t\t\tgid, err := strconv.Atoi(gids)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"bad gid: %w\", err)\n\t\t\t}\n\t\t\tp.User.GID = uint32(gid)\n\t\t}\n\t\tuid, err := strconv.Atoi(uids)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"bad uid: %w\", err)\n\t\t}\n\t\tp.User.UID = uint32(uid)\n\t}\n\tfor _, gid := range context.Int64Slice(\"additional-gids\") {\n\t\tif gid < 0 {\n\t\t\treturn nil, fmt.Errorf(\"additional-gids must be a positive number %d\", gid)\n\t\t}\n\t\tp.User.AdditionalGids = append(p.User.AdditionalGids, uint32(gid))\n\t}\n\treturn p, validateProcessSpec(p)\n}\n"
        },
        {
          "name": "features.go",
          "type": "blob",
          "size": 2.529296875,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/opencontainers/runc/libcontainer/capabilities\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/specconv\"\n\truncfeatures \"github.com/opencontainers/runc/types/features\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/runtime-spec/specs-go/features\"\n\t\"github.com/urfave/cli\"\n)\n\nvar featuresCommand = cli.Command{\n\tName:      \"features\",\n\tUsage:     \"show the enabled features\",\n\tArgsUsage: \"\",\n\tDescription: `Show the enabled features.\n   The result is parsable as a JSON.\n   See https://github.com/opencontainers/runtime-spec/blob/main/features.md for the type definition.\n`,\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 0, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tt := true\n\n\t\tfeat := features.Features{\n\t\t\tOCIVersionMin: \"1.0.0\",\n\t\t\tOCIVersionMax: specs.Version,\n\t\t\tAnnotations: map[string]string{\n\t\t\t\truncfeatures.AnnotationRuncVersion:           version,\n\t\t\t\truncfeatures.AnnotationRuncCommit:            gitCommit,\n\t\t\t\truncfeatures.AnnotationRuncCheckpointEnabled: \"true\",\n\t\t\t},\n\t\t\tHooks:        configs.KnownHookNames(),\n\t\t\tMountOptions: specconv.KnownMountOptions(),\n\t\t\tLinux: &features.Linux{\n\t\t\t\tNamespaces:   specconv.KnownNamespaces(),\n\t\t\t\tCapabilities: capabilities.KnownCapabilities(),\n\t\t\t\tCgroup: &features.Cgroup{\n\t\t\t\t\tV1:          &t,\n\t\t\t\t\tV2:          &t,\n\t\t\t\t\tSystemd:     &t,\n\t\t\t\t\tSystemdUser: &t,\n\t\t\t\t\tRdma:        &t,\n\t\t\t\t},\n\t\t\t\tApparmor: &features.Apparmor{\n\t\t\t\t\tEnabled: &t,\n\t\t\t\t},\n\t\t\t\tSelinux: &features.Selinux{\n\t\t\t\t\tEnabled: &t,\n\t\t\t\t},\n\t\t\t\tIntelRdt: &features.IntelRdt{\n\t\t\t\t\tEnabled: &t,\n\t\t\t\t},\n\t\t\t\tMountExtensions: &features.MountExtensions{\n\t\t\t\t\tIDMap: &features.IDMap{\n\t\t\t\t\t\tEnabled: &t,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tPotentiallyUnsafeConfigAnnotations: []string{\n\t\t\t\t\"bundle\",\n\t\t\t\t\"org.systemd.property.\", // prefix form\n\t\t\t\t\"org.criu.config\",\n\t\t\t},\n\t\t}\n\n\t\tif seccomp.Enabled {\n\t\t\tfeat.Linux.Seccomp = &features.Seccomp{\n\t\t\t\tEnabled:        &t,\n\t\t\t\tActions:        seccomp.KnownActions(),\n\t\t\t\tOperators:      seccomp.KnownOperators(),\n\t\t\t\tArchs:          seccomp.KnownArchs(),\n\t\t\t\tKnownFlags:     seccomp.KnownFlags(),\n\t\t\t\tSupportedFlags: seccomp.SupportedFlags(),\n\t\t\t}\n\t\t\tmajor, minor, patch := seccomp.Version()\n\t\t\tfeat.Annotations[runcfeatures.AnnotationLibseccompVersion] = fmt.Sprintf(\"%d.%d.%d\", major, minor, patch)\n\t\t}\n\n\t\tenc := json.NewEncoder(context.App.Writer)\n\t\tenc.SetIndent(\"\", \"    \")\n\t\treturn enc.Encode(feat)\n\t},\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.1982421875,
          "content": "module github.com/opencontainers/runc\n\ngo 1.22\n\n// Suggest toolchain 1.22.4 due to a fix in golang for libcontainer/nsenter/.\n// For more info, see: #4233\n// Note that toolchain does not impose a requirement on other modules using runc.\ntoolchain go1.22.4\n\nrequire (\n\tgithub.com/checkpoint-restore/go-criu/v6 v6.3.0\n\tgithub.com/cilium/ebpf v0.17.1\n\tgithub.com/containerd/console v1.0.4\n\tgithub.com/coreos/go-systemd/v22 v22.5.0\n\tgithub.com/cyphar/filepath-securejoin v0.3.6\n\tgithub.com/docker/go-units v0.5.0\n\tgithub.com/godbus/dbus/v5 v5.1.0\n\tgithub.com/moby/sys/capability v0.4.0\n\tgithub.com/moby/sys/mountinfo v0.7.2\n\tgithub.com/moby/sys/user v0.3.0\n\tgithub.com/moby/sys/userns v0.1.0\n\tgithub.com/mrunalp/fileutils v0.5.1\n\tgithub.com/opencontainers/runtime-spec v1.2.0\n\tgithub.com/opencontainers/selinux v1.11.1\n\tgithub.com/seccomp/libseccomp-golang v0.10.0\n\tgithub.com/sirupsen/logrus v1.9.3\n\tgithub.com/urfave/cli v1.22.16\n\tgithub.com/vishvananda/netlink v1.3.0\n\tgolang.org/x/net v0.34.0\n\tgolang.org/x/sys v0.29.0\n\tgoogle.golang.org/protobuf v1.36.2\n)\n\nrequire (\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.5 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.1.0 // indirect\n\tgithub.com/vishvananda/netns v0.0.4 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 8.951171875,
          "content": "github.com/BurntSushi/toml v1.4.0/go.mod h1:ukJfTF/6rtPPRCnwkur4qwRxa8vTRFBF0uk2lLoLwho=\ngithub.com/checkpoint-restore/go-criu/v6 v6.3.0 h1:mIdrSO2cPNWQY1truPg6uHLXyKHk3Z5Odx4wjKOASzA=\ngithub.com/checkpoint-restore/go-criu/v6 v6.3.0/go.mod h1:rrRTN/uSwY2X+BPRl/gkulo9gsKOSAeVp9/K2tv7xZI=\ngithub.com/cilium/ebpf v0.17.1 h1:G8mzU81R2JA1nE5/8SRubzqvBMmAmri2VL8BIZPWvV0=\ngithub.com/cilium/ebpf v0.17.1/go.mod h1:vay2FaYSmIlv3r8dNACd4mW/OCaZLJKJOo+IHBvCIO8=\ngithub.com/containerd/console v1.0.4 h1:F2g4+oChYvBTsASRTz8NP6iIAi97J3TtSAsLbIFn4ro=\ngithub.com/containerd/console v1.0.4/go.mod h1:YynlIjWYF8myEu6sdkwKIvGQq+cOckRm6So2avqoYAk=\ngithub.com/coreos/go-systemd/v22 v22.5.0 h1:RrqgGjYQKalulkV8NGVIfkXQf6YYmOyiJKk8iXXhfZs=\ngithub.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.2/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.5 h1:ZtcqGrnekaHpVLArFSe4HK5DoKx1T0rq2DwVB0alcyc=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.5/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=\ngithub.com/cyphar/filepath-securejoin v0.3.6 h1:4d9N5ykBnSp5Xn2JkhocYDkOpURL/18CYMpo6xB9uWM=\ngithub.com/cyphar/filepath-securejoin v0.3.6/go.mod h1:Sdj7gXlvMcPZsbhwhQ33GguGLDGQL7h7bg04C/+u9jI=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=\ngithub.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/go-quicktest/qt v1.101.0 h1:O1K29Txy5P2OK0dGo59b7b0LR6wKfIhttaAhHUyn7eI=\ngithub.com/go-quicktest/qt v1.101.0/go.mod h1:14Bz/f7NwaXPtdYEgzsx46kqSxVwTbzVZsDC26tQJow=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/godbus/dbus/v5 v5.1.0 h1:4KLkAxT3aOY8Li4FRJe/KvhoNFFxo0m6fNuFUO8QJUk=\ngithub.com/godbus/dbus/v5 v5.1.0/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/josharian/native v1.1.0 h1:uuaP0hAbW7Y4l0ZRQ6C9zfb7Mg1mbFKry/xzDAfmtLA=\ngithub.com/josharian/native v1.1.0/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=\ngithub.com/jsimonetti/rtnetlink/v2 v2.0.1 h1:xda7qaHDSVOsADNouv7ukSuicKZO7GgVUCXxpaIEIlM=\ngithub.com/jsimonetti/rtnetlink/v2 v2.0.1/go.mod h1:7MoNYNbb3UaDHtF8udiJo/RH6VsTKP1pqKLUTVCvToE=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/mdlayher/netlink v1.7.2 h1:/UtM3ofJap7Vl4QWCPDGXY8d3GIY2UGSDbK+QWmY8/g=\ngithub.com/mdlayher/netlink v1.7.2/go.mod h1:xraEF7uJbxLhc5fpHL4cPe221LI2bdttWlU+ZGLfQSw=\ngithub.com/mdlayher/socket v0.4.1 h1:eM9y2/jlbs1M615oshPQOHZzj6R6wMT7bX5NPiQvn2U=\ngithub.com/mdlayher/socket v0.4.1/go.mod h1:cAqeGjoufqdxWkD7DkpyS+wcefOtmu5OQ8KuoJGIReA=\ngithub.com/moby/sys/capability v0.4.0 h1:4D4mI6KlNtWMCM1Z/K0i7RV1FkX+DBDHKVJpCndZoHk=\ngithub.com/moby/sys/capability v0.4.0/go.mod h1:4g9IK291rVkms3LKCDOoYlnV8xKwoDTpIrNEE35Wq0I=\ngithub.com/moby/sys/mountinfo v0.7.2 h1:1shs6aH5s4o5H2zQLn796ADW1wMrIwHsyJ2v9KouLrg=\ngithub.com/moby/sys/mountinfo v0.7.2/go.mod h1:1YOa8w8Ih7uW0wALDUgT1dTTSBrZ+HiBLGws92L2RU4=\ngithub.com/moby/sys/user v0.3.0 h1:9ni5DlcW5an3SvRSx4MouotOygvzaXbaSrc/wGDFWPo=\ngithub.com/moby/sys/user v0.3.0/go.mod h1:bG+tYYYJgaMtRKgEmuueC0hJEAZWwtIbZTB+85uoHjs=\ngithub.com/moby/sys/userns v0.1.0 h1:tVLXkFOxVu9A64/yh59slHVv9ahO9UIev4JZusOLG/g=\ngithub.com/moby/sys/userns v0.1.0/go.mod h1:IHUYgu/kao6N8YZlp9Cf444ySSvCmDlmzUcYfDHOl28=\ngithub.com/mrunalp/fileutils v0.5.1 h1:F+S7ZlNKnrwHfSwdlgNSkKo67ReVf8o9fel6C3dkm/Q=\ngithub.com/mrunalp/fileutils v0.5.1/go.mod h1:M1WthSahJixYnrXQl/DFQuteStB1weuxD2QJNHXfbSQ=\ngithub.com/opencontainers/runtime-spec v1.2.0 h1:z97+pHb3uELt/yiAWD691HNHQIF07bE7dzrbT927iTk=\ngithub.com/opencontainers/runtime-spec v1.2.0/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/selinux v1.11.1 h1:nHFvthhM0qY8/m+vfhJylliSshm8G1jJ2jDMcgULaH8=\ngithub.com/opencontainers/selinux v1.11.1/go.mod h1:E5dMC3VPuVvVHDYmi78qvhJp8+M586T4DlDRYpFkyec=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rogpeppe/go-internal v1.11.0 h1:cWPaGQEPrBb5/AsnsZesgZZ9yb1OQ+GOISoDNXVBh4M=\ngithub.com/rogpeppe/go-internal v1.11.0/go.mod h1:ddIwULY96R17DhadqLgMfk9H9tvdUzkipdSkR5nkCZA=\ngithub.com/russross/blackfriday/v2 v2.1.0 h1:JIOH55/0cWyOuilr9/qlrm0BSXldqnqwMsf35Ld67mk=\ngithub.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/seccomp/libseccomp-golang v0.10.0 h1:aA4bp+/Zzi0BnWZ2F1wgNBs5gTpm+na2rWM6M9YjLpY=\ngithub.com/seccomp/libseccomp-golang v0.10.0/go.mod h1:JA8cRccbGaA1s33RQf7Y1+q9gHmZX1yB/z9WDN1C6fg=\ngithub.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=\ngithub.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/spf13/cobra v1.5.0/go.mod h1:dWXEIy2H428czQCjInthrTRUg7yKbok+2Qi/yBIJoUM=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/urfave/cli v1.22.16 h1:MH0k6uJxdwdeWQTwhSO42Pwr4YLrNLwBtg1MRgTqPdQ=\ngithub.com/urfave/cli v1.22.16/go.mod h1:EeJR6BKodywf4zciqrdw6hpCPk68JO9z5LazXZMn5Po=\ngithub.com/vishvananda/netlink v1.3.0 h1:X7l42GfcV4S6E4vHTsw48qbrV+9PVojNfIhZcwQdrZk=\ngithub.com/vishvananda/netlink v1.3.0/go.mod h1:i6NetklAujEcC6fK0JPjT8qSwWyO0HLn4UKG+hGqeJs=\ngithub.com/vishvananda/netns v0.0.4 h1:Oeaw1EM2JMxD51g9uhtC0D7erkIjgmj8+JZc26m1YX8=\ngithub.com/vishvananda/netns v0.0.4/go.mod h1:SpkAiCQRtJ6TvvxPnOSyH3BMl6unz3xZlaprSwhNNJM=\ngolang.org/x/net v0.34.0 h1:Mb7Mrk043xzHgnRM88suvJFwzVrRfHEHJEl5/71CKw0=\ngolang.org/x/net v0.34.0/go.mod h1:di0qlW3YNM5oh6GqDGQr92MyTozJPmybPK4Ev/Gm31k=\ngolang.org/x/sync v0.1.0 h1:wsuoTGHzEhffawBOhz5CYhcrV4IdKZbEyZjBMuTp12o=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.10.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.28.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngoogle.golang.org/protobuf v1.36.2 h1:R8FeyR1/eLmkutZOM5CWghmo5itiG9z0ktFlTVLuTmU=\ngoogle.golang.org/protobuf v1.36.2/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "init.go",
          "type": "blob",
          "size": 0.3388671875,
          "content": "package main\n\nimport (\n\t\"os\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t_ \"github.com/opencontainers/runc/libcontainer/nsenter\"\n)\n\nfunc init() {\n\tif len(os.Args) > 1 && os.Args[1] == \"init\" {\n\t\t// This is the golang entry point for runc init, executed\n\t\t// before main() but after libcontainer/nsenter's nsexec().\n\t\tlibcontainer.Init()\n\t}\n}\n"
        },
        {
          "name": "kill.go",
          "type": "blob",
          "size": 1.671875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/urfave/cli\"\n\t\"golang.org/x/sys/unix\"\n)\n\nvar killCommand = cli.Command{\n\tName:  \"kill\",\n\tUsage: \"kill sends the specified signal (default: SIGTERM) to the container's init process\",\n\tArgsUsage: `<container-id> [signal]\n\nWhere \"<container-id>\" is the name for the instance of the container and\n\"[signal]\" is the signal to be sent to the init process.\n\nEXAMPLE:\nFor example, if the container id is \"ubuntu01\" the following will send a \"KILL\"\nsignal to the init process of the \"ubuntu01\" container:\n\n       # runc kill ubuntu01 KILL`,\n\tFlags: []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:   \"all, a\",\n\t\t\tUsage:  \"(obsoleted, do not use)\",\n\t\t\tHidden: true,\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, minArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := checkArgs(context, 2, maxArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsigstr := context.Args().Get(1)\n\t\tif sigstr == \"\" {\n\t\t\tsigstr = \"SIGTERM\"\n\t\t}\n\n\t\tsignal, err := parseSignal(sigstr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = container.Signal(signal)\n\t\tif errors.Is(err, libcontainer.ErrNotRunning) && context.Bool(\"all\") {\n\t\t\terr = nil\n\t\t}\n\t\treturn err\n\t},\n}\n\nfunc parseSignal(rawSignal string) (unix.Signal, error) {\n\ts, err := strconv.Atoi(rawSignal)\n\tif err == nil {\n\t\treturn unix.Signal(s), nil\n\t}\n\tsig := strings.ToUpper(rawSignal)\n\tif !strings.HasPrefix(sig, \"SIG\") {\n\t\tsig = \"SIG\" + sig\n\t}\n\tsignal := unix.SignalNum(sig)\n\tif signal == 0 {\n\t\treturn -1, fmt.Errorf(\"unknown signal %q\", rawSignal)\n\t}\n\treturn signal, nil\n}\n"
        },
        {
          "name": "libcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": "list.go",
          "type": "blob",
          "size": 4.6064453125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"text/tabwriter\"\n\t\"time\"\n\n\t\"github.com/moby/sys/user\"\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/urfave/cli\"\n)\n\nconst formatOptions = `table or json`\n\n// containerState represents the platform agnostic pieces relating to a\n// running container's status and state\ntype containerState struct {\n\t// Version is the OCI version for the container\n\tVersion string `json:\"ociVersion\"`\n\t// ID is the container ID\n\tID string `json:\"id\"`\n\t// InitProcessPid is the init process id in the parent namespace\n\tInitProcessPid int `json:\"pid\"`\n\t// Status is the current status of the container, running, paused, ...\n\tStatus string `json:\"status\"`\n\t// Bundle is the path on the filesystem to the bundle\n\tBundle string `json:\"bundle\"`\n\t// Rootfs is a path to a directory containing the container's root filesystem.\n\tRootfs string `json:\"rootfs\"`\n\t// Created is the unix timestamp for the creation time of the container in UTC\n\tCreated time.Time `json:\"created\"`\n\t// Annotations is the user defined annotations added to the config.\n\tAnnotations map[string]string `json:\"annotations,omitempty\"`\n\t// The owner of the state directory (the owner of the container).\n\tOwner string `json:\"owner\"`\n}\n\nvar listCommand = cli.Command{\n\tName:  \"list\",\n\tUsage: \"lists containers started by runc with the given root\",\n\tArgsUsage: `\n\nWhere the given root is specified via the global option \"--root\"\n(default: \"/run/runc\").\n\nEXAMPLE 1:\nTo list containers created via the default \"--root\":\n       # runc list\n\nEXAMPLE 2:\nTo list containers created using a non-default value for \"--root\":\n       # runc --root value list`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"format, f\",\n\t\t\tValue: \"table\",\n\t\t\tUsage: `select one of: ` + formatOptions,\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"quiet, q\",\n\t\t\tUsage: \"display only container IDs\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 0, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts, err := getContainers(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif context.Bool(\"quiet\") {\n\t\t\tfor _, item := range s {\n\t\t\t\tfmt.Println(item.ID)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tswitch context.String(\"format\") {\n\t\tcase \"table\":\n\t\t\tw := tabwriter.NewWriter(os.Stdout, 12, 1, 3, ' ', 0)\n\t\t\tfmt.Fprint(w, \"ID\\tPID\\tSTATUS\\tBUNDLE\\tCREATED\\tOWNER\\n\")\n\t\t\tfor _, item := range s {\n\t\t\t\tfmt.Fprintf(w, \"%s\\t%d\\t%s\\t%s\\t%s\\t%s\\n\",\n\t\t\t\t\titem.ID,\n\t\t\t\t\titem.InitProcessPid,\n\t\t\t\t\titem.Status,\n\t\t\t\t\titem.Bundle,\n\t\t\t\t\titem.Created.Format(time.RFC3339Nano),\n\t\t\t\t\titem.Owner)\n\t\t\t}\n\t\t\tif err := w.Flush(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tcase \"json\":\n\t\t\tif err := json.NewEncoder(os.Stdout).Encode(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\treturn errors.New(\"invalid format option\")\n\t\t}\n\t\treturn nil\n\t},\n}\n\nfunc getContainers(context *cli.Context) ([]containerState, error) {\n\troot := context.GlobalString(\"root\")\n\tlist, err := os.ReadDir(root)\n\tif err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) && context.IsSet(\"root\") {\n\t\t\t// Ignore non-existing default root directory\n\t\t\t// (no containers created yet).\n\t\t\treturn nil, nil\n\t\t}\n\t\t// Report other errors, including non-existent custom --root.\n\t\treturn nil, err\n\t}\n\tvar s []containerState\n\tfor _, item := range list {\n\t\tif !item.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tst, err := item.Info()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\t\t// Possible race with runc delete.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\t// This cast is safe on Linux.\n\t\tuid := st.Sys().(*syscall.Stat_t).Uid\n\t\towner, err := user.LookupUid(int(uid))\n\t\tif err != nil {\n\t\t\towner.Name = fmt.Sprintf(\"#%d\", uid)\n\t\t}\n\n\t\tcontainer, err := libcontainer.Load(root, item.Name())\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"load container %s: %v\\n\", item.Name(), err)\n\t\t\tcontinue\n\t\t}\n\t\tcontainerStatus, err := container.Status()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"status for %s: %v\\n\", item.Name(), err)\n\t\t\tcontinue\n\t\t}\n\t\tstate, err := container.State()\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"state for %s: %v\\n\", item.Name(), err)\n\t\t\tcontinue\n\t\t}\n\t\tpid := state.BaseState.InitProcessPid\n\t\tif containerStatus == libcontainer.Stopped {\n\t\t\tpid = 0\n\t\t}\n\t\tbundle, annotations := utils.Annotations(state.Config.Labels)\n\t\ts = append(s, containerState{\n\t\t\tVersion:        state.BaseState.Config.Version,\n\t\t\tID:             state.BaseState.ID,\n\t\t\tInitProcessPid: pid,\n\t\t\tStatus:         containerStatus.String(),\n\t\t\tBundle:         bundle,\n\t\t\tRootfs:         state.BaseState.Config.Rootfs,\n\t\t\tCreated:        state.BaseState.Created,\n\t\t\tAnnotations:    annotations,\n\t\t\tOwner:          owner.Name,\n\t\t})\n\t}\n\treturn s, nil\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 6.064453125,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t//nolint:revive // Enable cgroup manager to manage devices\n\t_ \"github.com/opencontainers/runc/libcontainer/cgroups/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n)\n\n// version must be set from the contents of VERSION file by go build's\n// -X main.version= option in the Makefile.\nvar version = \"unknown\"\n\n// gitCommit will be the hash that the binary was built from\n// and will be populated by the Makefile\nvar gitCommit = \"\"\n\nconst (\n\tspecConfig = \"config.json\"\n\tusage      = `Open Container Initiative runtime\n\nrunc is a command line client for running applications packaged according to\nthe Open Container Initiative (OCI) format and is a compliant implementation of the\nOpen Container Initiative specification.\n\nrunc integrates well with existing process supervisors to provide a production\ncontainer runtime environment for applications. It can be used with your\nexisting process monitoring tools and the container will be spawned as a\ndirect child of the process supervisor.\n\nContainers are configured using bundles. A bundle for a container is a directory\nthat includes a specification file named \"` + specConfig + `\" and a root filesystem.\nThe root filesystem contains the contents of the container.\n\nTo start a new instance of a container:\n\n    # runc run [ -b bundle ] <container-id>\n\nWhere \"<container-id>\" is your name for the instance of the container that you\nare starting. The name you provide for the container instance must be unique on\nyour host. Providing the bundle directory using \"-b\" is optional. The default\nvalue for \"bundle\" is the current directory.`\n)\n\nfunc main() {\n\tapp := cli.NewApp()\n\tapp.Name = \"runc\"\n\tapp.Usage = usage\n\n\tv := []string{version}\n\n\tif gitCommit != \"\" {\n\t\tv = append(v, \"commit: \"+gitCommit)\n\t}\n\tv = append(v, \"spec: \"+specs.Version)\n\tv = append(v, \"go: \"+runtime.Version())\n\n\tmajor, minor, micro := seccomp.Version()\n\tif major+minor+micro > 0 {\n\t\tv = append(v, fmt.Sprintf(\"libseccomp: %d.%d.%d\", major, minor, micro))\n\t}\n\tapp.Version = strings.Join(v, \"\\n\")\n\n\troot := \"/run/runc\"\n\txdgDirUsed := false\n\txdgRuntimeDir := os.Getenv(\"XDG_RUNTIME_DIR\")\n\tif xdgRuntimeDir != \"\" && shouldHonorXDGRuntimeDir() {\n\t\troot = xdgRuntimeDir + \"/runc\"\n\t\txdgDirUsed = true\n\t}\n\n\tapp.Flags = []cli.Flag{\n\t\tcli.BoolFlag{\n\t\t\tName:  \"debug\",\n\t\t\tUsage: \"enable debug logging\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"log\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"set the log file to write runc logs to (default is '/dev/stderr')\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"log-format\",\n\t\t\tValue: \"text\",\n\t\t\tUsage: \"set the log format ('text' (default), or 'json')\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"root\",\n\t\t\tValue: root,\n\t\t\tUsage: \"root directory for storage of container state (this should be located in tmpfs)\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"criu\",\n\t\t\tUsage:  \"(obsoleted; do not use)\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"systemd-cgroup\",\n\t\t\tUsage: \"enable systemd cgroup support, expects cgroupsPath to be of form \\\"slice:prefix:name\\\" for e.g. \\\"system.slice:runc:434234\\\"\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"rootless\",\n\t\t\tValue: \"auto\",\n\t\t\tUsage: \"ignore cgroup permission errors ('true', 'false', or 'auto')\",\n\t\t},\n\t}\n\tapp.Commands = []cli.Command{\n\t\tcheckpointCommand,\n\t\tcreateCommand,\n\t\tdeleteCommand,\n\t\teventsCommand,\n\t\texecCommand,\n\t\tkillCommand,\n\t\tlistCommand,\n\t\tpauseCommand,\n\t\tpsCommand,\n\t\trestoreCommand,\n\t\tresumeCommand,\n\t\trunCommand,\n\t\tspecCommand,\n\t\tstartCommand,\n\t\tstateCommand,\n\t\tupdateCommand,\n\t\tfeaturesCommand,\n\t}\n\tapp.Before = func(context *cli.Context) error {\n\t\tif !context.IsSet(\"root\") && xdgDirUsed {\n\t\t\t// According to the XDG specification, we need to set anything in\n\t\t\t// XDG_RUNTIME_DIR to have a sticky bit if we don't want it to get\n\t\t\t// auto-pruned.\n\t\t\tif err := os.MkdirAll(root, 0o700); err != nil {\n\t\t\t\tfmt.Fprintln(os.Stderr, \"the path in $XDG_RUNTIME_DIR must be writable by the user\")\n\t\t\t\tfatal(err)\n\t\t\t}\n\t\t\tif err := os.Chmod(root, os.FileMode(0o700)|os.ModeSticky); err != nil {\n\t\t\t\tfmt.Fprintln(os.Stderr, \"you should check permission of the path in $XDG_RUNTIME_DIR\")\n\t\t\t\tfatal(err)\n\t\t\t}\n\t\t}\n\t\tif err := reviseRootDir(context); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// TODO: remove this in runc 1.3.0.\n\t\tif context.IsSet(\"criu\") {\n\t\t\tfmt.Fprintln(os.Stderr, \"WARNING: --criu ignored (criu binary from $PATH is used); do not use\")\n\t\t}\n\n\t\treturn configLogrus(context)\n\t}\n\n\t// If the command returns an error, cli takes upon itself to print\n\t// the error on cli.ErrWriter and exit.\n\t// Use our own writer here to ensure the log gets sent to the right location.\n\tcli.ErrWriter = &FatalWriter{cli.ErrWriter}\n\tif err := app.Run(os.Args); err != nil {\n\t\tfatal(err)\n\t}\n}\n\ntype FatalWriter struct {\n\tcliErrWriter io.Writer\n}\n\nfunc (f *FatalWriter) Write(p []byte) (n int, err error) {\n\tlogrus.Error(string(p))\n\tif !logrusToStderr() {\n\t\treturn f.cliErrWriter.Write(p)\n\t}\n\treturn len(p), nil\n}\n\nfunc configLogrus(context *cli.Context) error {\n\tif context.GlobalBool(\"debug\") {\n\t\tlogrus.SetLevel(logrus.DebugLevel)\n\t\tlogrus.SetReportCaller(true)\n\t\t// Shorten function and file names reported by the logger, by\n\t\t// trimming common \"github.com/opencontainers/runc\" prefix.\n\t\t// This is only done for text formatter.\n\t\t_, file, _, _ := runtime.Caller(0)\n\t\tprefix := filepath.Dir(file) + \"/\"\n\t\tlogrus.SetFormatter(&logrus.TextFormatter{\n\t\t\tCallerPrettyfier: func(f *runtime.Frame) (string, string) {\n\t\t\t\tfunction := strings.TrimPrefix(f.Function, prefix) + \"()\"\n\t\t\t\tfileLine := strings.TrimPrefix(f.File, prefix) + \":\" + strconv.Itoa(f.Line)\n\t\t\t\treturn function, fileLine\n\t\t\t},\n\t\t})\n\t}\n\n\tswitch f := context.GlobalString(\"log-format\"); f {\n\tcase \"\":\n\t\t// do nothing\n\tcase \"text\":\n\t\t// do nothing\n\tcase \"json\":\n\t\tlogrus.SetFormatter(new(logrus.JSONFormatter))\n\tdefault:\n\t\treturn errors.New(\"invalid log-format: \" + f)\n\t}\n\n\tif file := context.GlobalString(\"log\"); file != \"\" {\n\t\tf, err := os.OpenFile(file, os.O_CREATE|os.O_WRONLY|os.O_APPEND|os.O_SYNC, 0o644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlogrus.SetOutput(f)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "notify_socket.go",
          "type": "blob",
          "size": 5.3974609375,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n\t\"golang.org/x/sys/unix\"\n)\n\ntype notifySocket struct {\n\tsocket     *net.UnixConn\n\thost       string\n\tsocketPath string\n}\n\nfunc newNotifySocket(context *cli.Context, notifySocketHost string, id string) *notifySocket {\n\tif notifySocketHost == \"\" {\n\t\treturn nil\n\t}\n\n\troot := filepath.Join(context.GlobalString(\"root\"), id)\n\tsocketPath := filepath.Join(root, \"notify\", \"notify.sock\")\n\n\tnotifySocket := &notifySocket{\n\t\tsocket:     nil,\n\t\thost:       notifySocketHost,\n\t\tsocketPath: socketPath,\n\t}\n\n\treturn notifySocket\n}\n\nfunc (s *notifySocket) Close() error {\n\treturn s.socket.Close()\n}\n\n// If systemd is supporting sd_notify protocol, this function will add support\n// for sd_notify protocol from within the container.\nfunc (s *notifySocket) setupSpec(spec *specs.Spec) {\n\tpathInContainer := filepath.Join(\"/run/notify\", path.Base(s.socketPath))\n\tmount := specs.Mount{\n\t\tDestination: path.Dir(pathInContainer),\n\t\tSource:      path.Dir(s.socketPath),\n\t\tOptions:     []string{\"bind\", \"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t}\n\tspec.Mounts = append(spec.Mounts, mount)\n\tspec.Process.Env = append(spec.Process.Env, \"NOTIFY_SOCKET=\"+pathInContainer)\n}\n\nfunc (s *notifySocket) bindSocket() error {\n\taddr := net.UnixAddr{\n\t\tName: s.socketPath,\n\t\tNet:  \"unixgram\",\n\t}\n\n\tsocket, err := net.ListenUnixgram(\"unixgram\", &addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = os.Chmod(s.socketPath, 0o777)\n\tif err != nil {\n\t\tsocket.Close()\n\t\treturn err\n\t}\n\n\ts.socket = socket\n\treturn nil\n}\n\nfunc (s *notifySocket) setupSocketDirectory() error {\n\treturn os.Mkdir(path.Dir(s.socketPath), 0o755)\n}\n\nfunc notifySocketStart(context *cli.Context, notifySocketHost, id string) (*notifySocket, error) {\n\tnotifySocket := newNotifySocket(context, notifySocketHost, id)\n\tif notifySocket == nil {\n\t\treturn nil, nil\n\t}\n\n\tif err := notifySocket.bindSocket(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn notifySocket, nil\n}\n\nfunc (s *notifySocket) waitForContainer(container *libcontainer.Container) error {\n\tstate, err := container.State()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.run(state.InitProcessPid)\n}\n\nfunc (n *notifySocket) run(pid1 int) error {\n\tif n.socket == nil {\n\t\treturn nil\n\t}\n\tnotifySocketHostAddr := net.UnixAddr{Name: n.host, Net: \"unixgram\"}\n\tclient, err := net.DialUnix(\"unixgram\", nil, &notifySocketHostAddr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tticker := time.NewTicker(time.Millisecond * 100)\n\tdefer ticker.Stop()\n\n\tfileChan := make(chan []byte)\n\tgo func() {\n\t\tfor {\n\t\t\tbuf := make([]byte, 4096)\n\t\t\tr, err := n.socket.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tgot := buf[0:r]\n\t\t\t// systemd-ready sends a single datagram with the state string as payload,\n\t\t\t// so we don't need to worry about partial messages.\n\t\t\tfor _, line := range bytes.Split(got, []byte{'\\n'}) {\n\t\t\t\tif bytes.HasPrefix(got, []byte(\"READY=\")) {\n\t\t\t\t\tfileChan <- line\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\t_, err := os.Stat(filepath.Join(\"/proc\", strconv.Itoa(pid1)))\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase b := <-fileChan:\n\t\t\treturn notifyHost(client, b, pid1)\n\t\t}\n\t}\n}\n\n// notifyHost tells the host (usually systemd) that the container reported READY.\n// Also sends MAINPID and BARRIER.\nfunc notifyHost(client *net.UnixConn, ready []byte, pid1 int) error {\n\t_, err := client.Write(append(ready, '\\n'))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// now we can inform systemd to use pid1 as the pid to monitor\n\tnewPid := \"MAINPID=\" + strconv.Itoa(pid1)\n\t_, err = client.Write([]byte(newPid + \"\\n\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// wait for systemd to acknowledge the communication\n\treturn sdNotifyBarrier(client)\n}\n\n// errUnexpectedRead is reported when actual data was read from the pipe used\n// to synchronize with systemd. Usually, that pipe is only closed.\nvar errUnexpectedRead = errors.New(\"unexpected read from synchronization pipe\")\n\n// sdNotifyBarrier performs synchronization with systemd by means of the sd_notify_barrier protocol.\nfunc sdNotifyBarrier(client *net.UnixConn) error {\n\t// Create a pipe for communicating with systemd daemon.\n\tpipeR, pipeW, err := os.Pipe()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the FD for the unix socket file to be able to do perform syscall.Sendmsg.\n\tclientFd, err := client.File()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Send the write end of the pipe along with a BARRIER=1 message.\n\tfdRights := unix.UnixRights(int(pipeW.Fd()))\n\terr = unix.Sendmsg(int(clientFd.Fd()), []byte(\"BARRIER=1\"), fdRights, nil, 0)\n\tif err != nil {\n\t\treturn &os.SyscallError{Syscall: \"sendmsg\", Err: err}\n\t}\n\n\t// Close our copy of pipeW.\n\terr = pipeW.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Expect the read end of the pipe to be closed after 30 seconds.\n\terr = pipeR.SetReadDeadline(time.Now().Add(30 * time.Second))\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\t// Read a single byte expecting EOF.\n\tvar buf [1]byte\n\tn, err := pipeR.Read(buf[:])\n\tif n != 0 || err == nil {\n\t\treturn errUnexpectedRead\n\t} else if errors.Is(err, os.ErrDeadlineExceeded) {\n\t\t// Probably the other end doesn't support the sd_notify_barrier protocol.\n\t\tlogrus.Warn(\"Timeout after waiting 30s for barrier. Ignored.\")\n\t\treturn nil\n\t} else if err == io.EOF { //nolint:errorlint // https://github.com/polyfloyd/go-errorlint/issues/49\n\t\treturn nil\n\t} else {\n\t\treturn err\n\t}\n}\n"
        },
        {
          "name": "notify_socket_test.go",
          "type": "blob",
          "size": 2.7373046875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net\"\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\n// TestNotifyHost tests how runc reports container readiness to the host (usually systemd).\nfunc TestNotifyHost(t *testing.T) {\n\taddr := net.UnixAddr{\n\t\tName: t.TempDir() + \"/testsocket\",\n\t\tNet:  \"unixgram\",\n\t}\n\n\tserver, err := net.ListenUnixgram(\"unixgram\", &addr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer server.Close()\n\n\tclient, err := net.DialUnix(\"unixgram\", nil, &addr)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer client.Close()\n\n\t// run notifyHost in a separate goroutine\n\tnotifyHostChan := make(chan error)\n\tgo func() {\n\t\tnotifyHostChan <- notifyHost(client, []byte(\"READY=42\"), 1337)\n\t}()\n\n\t// mock a host process listening for runc's notifications\n\texpectRead(t, server, \"READY=42\\n\")\n\texpectRead(t, server, \"MAINPID=1337\\n\")\n\texpectBarrier(t, server, notifyHostChan)\n}\n\nfunc expectRead(t *testing.T, r io.Reader, expected string) {\n\tvar buf [1024]byte\n\tn, err := r.Read(buf[:])\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(buf[:n], []byte(expected)) {\n\t\tt.Fatalf(\"Expected to read '%s' but runc sent '%s' instead\", expected, buf[:n])\n\t}\n}\n\nfunc expectBarrier(t *testing.T, conn *net.UnixConn, notifyHostChan <-chan error) {\n\tvar msg, oob [1024]byte\n\tn, oobn, _, _, err := conn.ReadMsgUnix(msg[:], oob[:])\n\tif err != nil {\n\t\tt.Fatal(\"Failed to receive BARRIER message\", err)\n\t}\n\tif !bytes.Equal(msg[:n], []byte(\"BARRIER=1\")) {\n\t\tt.Fatalf(\"Expected to receive 'BARRIER=1' but got '%s' instead.\", msg[:n])\n\t}\n\n\tfd := mustExtractFd(t, oob[:oobn])\n\n\t// Test whether notifyHost actually honors the barrier\n\ttimer := time.NewTimer(500 * time.Millisecond)\n\tselect {\n\tcase <-timer.C:\n\t\t// this is the expected case\n\t\tbreak\n\tcase <-notifyHostChan:\n\t\tt.Fatal(\"runc has terminated before barrier was lifted\")\n\t}\n\n\t// Lift the barrier\n\terr = unix.Close(fd)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Expect notifyHost to terminate now\n\terr = <-notifyHostChan\n\tif err != nil {\n\t\tt.Fatal(\"notifyHost function returned with error\", err)\n\t}\n}\n\nfunc mustExtractFd(t *testing.T, buf []byte) int {\n\tcmsgs, err := unix.ParseSocketControlMessage(buf)\n\tif err != nil {\n\t\tt.Fatal(\"Failed to parse control message\", err)\n\t}\n\n\tfd := 0\n\tseenScmRights := false\n\tfor _, cmsg := range cmsgs {\n\t\tif cmsg.Header.Type != unix.SCM_RIGHTS {\n\t\t\tcontinue\n\t\t}\n\t\tif seenScmRights {\n\t\t\tt.Fatal(\"Expected to see exactly one SCM_RIGHTS message, but got a second one\")\n\t\t}\n\t\tseenScmRights = true\n\t\tfds, err := unix.ParseUnixRights(&cmsg)\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Failed to parse SCM_RIGHTS message\", err)\n\t\t}\n\t\tif len(fds) != 1 {\n\t\t\tt.Fatal(\"Expected to read exactly one file descriptor, but got\", len(fds))\n\t\t}\n\t\tfd = fds[0]\n\t}\n\tif !seenScmRights {\n\t\tt.Fatal(\"Control messages didn't contain an SCM_RIGHTS message\")\n\t}\n\n\treturn fd\n}\n"
        },
        {
          "name": "pause.go",
          "type": "blob",
          "size": 1.70703125,
          "content": "package main\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n)\n\nvar pauseCommand = cli.Command{\n\tName:  \"pause\",\n\tUsage: \"pause suspends all processes inside the container\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container to be\npaused. `,\n\tDescription: `The pause command suspends all processes in the instance of the container.\n\nUse runc list to identify instances of containers and their current status.`,\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\trootlessCg, err := shouldUseRootlessCgroupManager(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rootlessCg {\n\t\t\tlogrus.Warnf(\"runc pause may fail if you don't have the full access to cgroups\")\n\t\t}\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn container.Pause()\n\t},\n}\n\nvar resumeCommand = cli.Command{\n\tName:  \"resume\",\n\tUsage: \"resumes all processes that have been previously paused\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container to be\nresumed.`,\n\tDescription: `The resume command resumes all processes in the instance of the container.\n\nUse runc list to identify instances of containers and their current status.`,\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\trootlessCg, err := shouldUseRootlessCgroupManager(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rootlessCg {\n\t\t\tlogrus.Warn(\"runc resume may fail if you don't have the full access to cgroups\")\n\t\t}\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn container.Resume()\n\t},\n}\n"
        },
        {
          "name": "ps.go",
          "type": "blob",
          "size": 2.1884765625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n)\n\nvar psCommand = cli.Command{\n\tName:      \"ps\",\n\tUsage:     \"ps displays the processes running inside a container\",\n\tArgsUsage: `<container-id> [ps options]`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"format, f\",\n\t\t\tValue: \"table\",\n\t\t\tUsage: `select one of: ` + formatOptions,\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, minArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\trootlessCg, err := shouldUseRootlessCgroupManager(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rootlessCg {\n\t\t\tlogrus.Warn(\"runc ps may fail if you don't have the full access to cgroups\")\n\t\t}\n\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tpids, err := container.Processes()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch context.String(\"format\") {\n\t\tcase \"table\":\n\t\tcase \"json\":\n\t\t\treturn json.NewEncoder(os.Stdout).Encode(pids)\n\t\tdefault:\n\t\t\treturn errors.New(\"invalid format option\")\n\t\t}\n\n\t\t// [1:] is to remove command name, ex:\n\t\t// context.Args(): [container_id ps_arg1 ps_arg2 ...]\n\t\t// psArgs:         [ps_arg1 ps_arg2 ...]\n\t\t//\n\t\tpsArgs := context.Args()[1:]\n\t\tif len(psArgs) == 0 {\n\t\t\tpsArgs = []string{\"-ef\"}\n\t\t}\n\n\t\tcmd := exec.Command(\"ps\", psArgs...)\n\t\toutput, err := cmd.CombinedOutput()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"%w: %s\", err, output)\n\t\t}\n\n\t\tlines := strings.Split(string(output), \"\\n\")\n\t\tpidIndex, err := getPidIndex(lines[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println(lines[0])\n\t\tfor _, line := range lines[1:] {\n\t\t\tif len(line) == 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfields := strings.Fields(line)\n\t\t\tp, err := strconv.Atoi(fields[pidIndex])\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to parse pid: %w\", err)\n\t\t\t}\n\n\t\t\tfor _, pid := range pids {\n\t\t\t\tif pid == p {\n\t\t\t\t\tfmt.Println(line)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t},\n\tSkipArgReorder: true,\n}\n\nfunc getPidIndex(title string) (int, error) {\n\ttitles := strings.Fields(title)\n\n\tpidIndex := -1\n\tfor i, name := range titles {\n\t\tif name == \"PID\" {\n\t\t\treturn i, nil\n\t\t}\n\t}\n\n\treturn pidIndex, errors.New(\"couldn't find PID field in ps output\")\n}\n"
        },
        {
          "name": "restore.go",
          "type": "blob",
          "size": 3.2060546875,
          "content": "package main\n\nimport (\n\t\"os\"\n\n\t\"github.com/moby/sys/userns\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n)\n\nvar restoreCommand = cli.Command{\n\tName:  \"restore\",\n\tUsage: \"restore a container from a previous checkpoint\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container to be\nrestored.`,\n\tDescription: `Restores the saved state of the container instance that was previously saved\nusing the runc checkpoint command.`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"console-socket\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"image-path\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"path to criu image files for restoring\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"work-path\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"path for saving work files and logs\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"tcp-established\",\n\t\t\tUsage: \"allow open tcp connections\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"ext-unix-sk\",\n\t\t\tUsage: \"allow external unix sockets\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"shell-job\",\n\t\t\tUsage: \"allow shell jobs\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"file-locks\",\n\t\t\tUsage: \"handle file locks, for safety\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"manage-cgroups-mode\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"cgroups mode: soft|full|strict|ignore (default: soft)\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"bundle, b\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"path to the root of the bundle directory\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"detach,d\",\n\t\t\tUsage: \"detach from the container's process\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pid-file\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"specify the file to write the process id to\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-subreaper\",\n\t\t\tUsage: \"disable the use of the subreaper used to reap reparented processes\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-pivot\",\n\t\t\tUsage: \"do not use pivot root to jail process inside rootfs.  This should be used whenever the rootfs is on top of a ramdisk\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"empty-ns\",\n\t\t\tUsage: \"create a namespace, but don't restore its properties\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"auto-dedup\",\n\t\t\tUsage: \"enable auto deduplication of memory images\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"lazy-pages\",\n\t\t\tUsage: \"use userfaultfd to lazily restore memory pages\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"lsm-profile\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"Specify an LSM profile to be used during restore in the form of TYPE:NAME.\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"lsm-mount-context\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"Specify an LSM mount context to be used during restore.\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// XXX: Currently this is untested with rootless containers.\n\t\tif os.Geteuid() != 0 || userns.RunningInUserNS() {\n\t\t\tlogrus.Warn(\"runc checkpoint is untested with rootless containers\")\n\t\t}\n\n\t\toptions, err := criuOptions(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := startContainer(context, CT_ACT_RESTORE, options)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// exit with the container's exit status so any external supervisor is\n\t\t// notified of the exit with the correct exit status.\n\t\tos.Exit(status)\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "rlimit_linux.go",
          "type": "blob",
          "size": 0.88671875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nvar rlimitMap = map[string]int{\n\t\"RLIMIT_CPU\":        unix.RLIMIT_CPU,\n\t\"RLIMIT_FSIZE\":      unix.RLIMIT_FSIZE,\n\t\"RLIMIT_DATA\":       unix.RLIMIT_DATA,\n\t\"RLIMIT_STACK\":      unix.RLIMIT_STACK,\n\t\"RLIMIT_CORE\":       unix.RLIMIT_CORE,\n\t\"RLIMIT_RSS\":        unix.RLIMIT_RSS,\n\t\"RLIMIT_NPROC\":      unix.RLIMIT_NPROC,\n\t\"RLIMIT_NOFILE\":     unix.RLIMIT_NOFILE,\n\t\"RLIMIT_MEMLOCK\":    unix.RLIMIT_MEMLOCK,\n\t\"RLIMIT_AS\":         unix.RLIMIT_AS,\n\t\"RLIMIT_LOCKS\":      unix.RLIMIT_LOCKS,\n\t\"RLIMIT_SIGPENDING\": unix.RLIMIT_SIGPENDING,\n\t\"RLIMIT_MSGQUEUE\":   unix.RLIMIT_MSGQUEUE,\n\t\"RLIMIT_NICE\":       unix.RLIMIT_NICE,\n\t\"RLIMIT_RTPRIO\":     unix.RLIMIT_RTPRIO,\n\t\"RLIMIT_RTTIME\":     unix.RLIMIT_RTTIME,\n}\n\nfunc strToRlimit(key string) (int, error) {\n\trl, ok := rlimitMap[key]\n\tif !ok {\n\t\treturn 0, fmt.Errorf(\"wrong rlimit value: %s\", key)\n\t}\n\treturn rl, nil\n}\n"
        },
        {
          "name": "rootless_linux.go",
          "type": "blob",
          "size": 1.9228515625,
          "content": "package main\n\nimport (\n\t\"os\"\n\n\t\"github.com/moby/sys/userns\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/systemd\"\n)\n\nfunc shouldUseRootlessCgroupManager(context *cli.Context) (bool, error) {\n\tif context != nil {\n\t\tb, err := parseBoolOrAuto(context.GlobalString(\"rootless\"))\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\t// nil b stands for \"auto detect\"\n\t\tif b != nil {\n\t\t\treturn *b, nil\n\t\t}\n\t}\n\tif os.Geteuid() != 0 {\n\t\treturn true, nil\n\t}\n\tif !userns.RunningInUserNS() {\n\t\t// euid == 0 , in the initial ns (i.e. the real root)\n\t\treturn false, nil\n\t}\n\t// euid = 0, in a userns.\n\t//\n\t// [systemd driver]\n\t// We can call DetectUID() to parse the OwnerUID value from `busctl --user --no-pager status` result.\n\t// The value corresponds to sd_bus_creds_get_owner_uid(3).\n\t// If the value is 0, we have rootful systemd inside userns, so we do not need the rootless cgroup manager.\n\t//\n\t// On error, we assume we are root. An error may happen during shelling out to `busctl` CLI,\n\t// mostly when $DBUS_SESSION_BUS_ADDRESS is unset.\n\tif context.GlobalBool(\"systemd-cgroup\") {\n\t\townerUID, err := systemd.DetectUID()\n\t\tif err != nil {\n\t\t\tlogrus.WithError(err).Debug(\"failed to get the OwnerUID value, assuming the value to be 0\")\n\t\t\townerUID = 0\n\t\t}\n\t\treturn ownerUID != 0, nil\n\t}\n\t// [cgroupfs driver]\n\t// As we are unaware of cgroups path, we can't determine whether we have the full\n\t// access to the cgroups path.\n\t// Either way, we can safely decide to use the rootless cgroups manager.\n\treturn true, nil\n}\n\nfunc shouldHonorXDGRuntimeDir() bool {\n\tif os.Geteuid() != 0 {\n\t\treturn true\n\t}\n\tif !userns.RunningInUserNS() {\n\t\t// euid == 0 , in the initial ns (i.e. the real root)\n\t\t// in this case, we should use /run/runc and ignore\n\t\t// $XDG_RUNTIME_DIR (e.g. /run/user/0) for backward\n\t\t// compatibility.\n\t\treturn false\n\t}\n\t// euid = 0, in a userns.\n\tu, ok := os.LookupEnv(\"USER\")\n\treturn !ok || u != \"root\"\n}\n"
        },
        {
          "name": "run.go",
          "type": "blob",
          "size": 2.666015625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/urfave/cli\"\n)\n\n// default action is to start a container\nvar runCommand = cli.Command{\n\tName:  \"run\",\n\tUsage: \"create and run a container\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is your name for the instance of the container that you\nare starting. The name you provide for the container instance must be unique on\nyour host.`,\n\tDescription: `The run command creates an instance of a container for a bundle. The bundle\nis a directory with a specification file named \"` + specConfig + `\" and a root\nfilesystem.\n\nThe specification file includes an args parameter. The args parameter is used\nto specify command(s) that get run when the container is started. To change the\ncommand(s) that get executed on start, edit the args parameter of the spec. See\n\"runc spec --help\" for more explanation.`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"bundle, b\",\n\t\t\tValue: \"\",\n\t\t\tUsage: `path to the root of the bundle directory, defaults to the current directory`,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"console-socket\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pidfd-socket\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the init process\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"detach, d\",\n\t\t\tUsage: \"detach from the container's process\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"keep\",\n\t\t\tUsage: \"do not delete the container after it exits\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pid-file\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"specify the file to write the process id to\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-subreaper\",\n\t\t\tUsage: \"disable the use of the subreaper used to reap reparented processes\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-pivot\",\n\t\t\tUsage: \"do not use pivot root to jail process inside rootfs.  This should be used whenever the rootfs is on top of a ramdisk\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-new-keyring\",\n\t\t\tUsage: \"do not create a new session keyring for the container.  This will cause the container to inherit the calling processes session key\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:  \"preserve-fds\",\n\t\t\tUsage: \"Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total)\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := startContainer(context, CT_ACT_RUN, nil)\n\t\tif err == nil {\n\t\t\t// exit with the container's exit status so any external supervisor is\n\t\t\t// notified of the exit with the correct exit status.\n\t\t\tos.Exit(status)\n\t\t}\n\t\treturn fmt.Errorf(\"runc run failed: %w\", err)\n\t},\n}\n"
        },
        {
          "name": "runc.keyring",
          "type": "blob",
          "size": 12.3525390625,
          "content": "pub   rsa4096 2016-06-21 [SC] [expires: 2031-06-18]\n      5F36C6C61B5460124A75F5A69E18AA267DDB8DB4\nuid           [ultimate] Aleksa Sarai <asarai@suse.com>\nuid           [ultimate] Aleksa Sarai <asarai@suse.de>\nsub   rsa4096 2016-06-21 [E] [expires: 2031-06-18]\n\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: github=cyphar\n\nmQINBFdpGN0BEADMEmLpnUel7OI2SM8f88i7w0iRgJd4kOvF1z673+zWCgaw9QW8\nha7wAm/+3isas9IqlvGx61i6hbO7TFwcYi472VHhs4HP8jMtWytHHkjc3O9xlMc0\nCfekjIpoR1CffYtCvkLr8/f74jHNRfqsmZ1Oxa9GjbhgDnbw4Baztp6WctzMXyOJ\nj5bJuSfQTcgFbIeQ27zx7gNjbnHyEP5TEm1/CeoWpGPpZLJPiKHdI/TBCyFexHJ0\nIlabKc4DC43RZyh0Btuf+FiX9K2NkoCC7l5nQdde8B6YG7SA6xEhwhQ73bSs7A56\nrlZxfIFmLCB/81FyXk5eH0Eu9Lbwj69YQ81EdkLnLAyP3ZB+MRGuiWVD88Jr1He2\n25m3dxTVzaP0TAV4LqdbuqTwr2wagu9MZQ5XXDiaEuiPwTrO10xlmivOjRaWxoWA\nE0I3fOdrzqfg9XK6g1pG23v2WhHFIejqVCXrf5oPcCd62lGeh0ghEdNN89ikXbka\n1PJRiWI3uDQ6STSKa+6uC5eUM7tK/ymqS8JYSQf4d3eIaC2H403psPt5kbq1bHdx\nnRPX2eh/t1QzR1dhPxzai4CzLERIYJ9iD4nGiSscwy0P44AgyeuywSg4qXzr9Sfe\nigOj+6lfJb3iZRN3dKLTRAKWvo7yfdi/UOycodlaQyW8v0yXAx7Yh1NgJQARAQAB\ntB1BbGVrc2EgU2FyYWkgPGFzYXJhaUBzdXNlLmRlPokCPQQTAQgAJwUCV2kY3QIb\nAwUJHDIEgAULCQgHAgYVCAkKCwIEFgIDAQIeAQIXgAAKCRCeGKomfduNtGecEACZ\nJLVdeKHKsSUqTLOjbC6t9uKfKlNpu+iQ2/TS9YazLWXoFEc8f/uWB8BpHcJBFrqz\nj+mI34ShEkbbNJArxR76njnAtPF+73GiD0dAjRDWz8YtQgSg5UhYm6O2Si/EM4I8\nTDzflyjaZltCkDe2U+2T8dTkYxqOi11IuCukPBNe0moxGKvLGPWEqZQMPCfBgllD\nlv2Toiry2Fp1bkBlT6hk0C684rfAwzPQuH0BBv8vgfgroRMJg/qfZb64lhMCXaPr\nrCtVHP+F1bVXKZCBCt7ETTtcteUEKaFmGgDGpXGnIqPL5iWLK5u8DQL/1lGcinj9\nQdD9IUNqsrsNAbdyMMqQvZKQwIVDgFMXrCwSRymOi6cppN7eF0VyFN7YsATttRGx\nCZBoSMhVW6VVxuJFGaQWFXWthVGVEd2jkvny1TX8Nm8KBHC2G/wNVU3pKrCPhMCt\nrYc8xWZ+6uisQ6XWs8H4nyBOVN6RvhIqqXJL1nvViOSFMLSDyFgPA16368krgxYE\npVDvie04aDjKZj2/0LSogNQPqZxs8uKIjLZ1NYQQmCQ8Dx9/nshg1wbyDD/c///M\nEmVFmZhlNLZ8tV/iTlwfD/4vjbeaAQTVanhPFRbUtmL/iuz5f0gH0b0xc+mc+yQ1\negjBwMuKr+h7jbSXIWoFGZLrqT3WswTg0Khk6oEL57QeQWxla3NhIFNhcmFpIDxh\nc2FyYWlAc3VzZS5jb20+iQI9BBMBCAAnBQJXaRngAhsDBQkcMgSABQsJCAcCBhUI\nCQoLAgQWAgMBAh4BAheAAAoJEJ4YqiZ924202mIQAIjGrikF7OPBCbV5Oo4oC0QQ\n7HcG+DM9cN6UcFO+rzWQxZ/atEpiULa4O3YKoGOkSV5WAjUpaY5Rf7Obt3EjgrwE\nPhtGvOpC6kkkTV43RmmK06CxHiZPrUJBwcpbW1rf2JZx7PPBMbZfsmWdVZc+LjzC\nD3KtJ7xhzT0mi+zN5ONNHody6sDQO6n0mN+bRVxiVdcxwjYHfJYGobI6aaKyupvl\n+xCGK4ekzNCVzaxudzqmbFE6qk+cWcvcA8HpggA63rCvCLfK1embNOtqzKAcJh1o\ncJvrtpe18qBvd4yXFWEqQBW6IoDLvdzaLY7eNMI97UDInciz/GUtbxhqbs1lAOBz\nV1y9fi0+NIIq1qmhbLxpUFC2BWsZRuWEqYWdr4FFJCuYEEXX6KXM7d9CSdWlErCU\nmqKYsx6X4E7Iy1yupYbIqXRea9wBr8aPoFk+gLdNbCWAE4o7InKJY1uqOt141ffs\n+6XJe2wVvA2xLr0ZphlcyF0EHZX8tMWLCYdQJdLMps2hl5oFpi7ccdM1GpE/Kwt5\npEBqsJ6vP59BsbmciYmNkYKvFIKJcasImglQP6nrQiBwjTd7fYXpMDeO0yNtklaZ\nIZlbNvxOe1TqbRzfVFk3oSBbEaFzPAx/W0uU1evZynpu2PcIvOuadScc9j0jMzt8\n0wknTD5AqhD/fkfZlwRouQINBFdpGN0BEADfqvO6AkGOWf+lcQZfWBMSMpzneCCS\nJvQvD65VrFt0CCbSlJv1pc3GwLlL2dMulIxQGg0JMTjfPZcCYqrnOcWe0gedETRV\nnOucY7zWmohR7L70YWwh46FlAPifY6bIIYGYTHyI9w1adS9K4tAJW/XS0WrvZ5KA\nl7htrAzUAsMhag9y9jtQJVPLErGJta3jZJASs8PZWWmLYZE+oy1R3W52w/HqGQHS\n8BPgo4oL+lrjPmjAwouhhNETTq9W2xmCe18EJodOjNKdF5ODOq1LOkPNHIaIdG0s\nsY3qbifcRLVDvSmb8++4WRYl1HLy2vpsTQ31mZ3KyRKR6cP61ivTZy8idwD+Qt1t\n3uKTCGNZj96OCob8ZeZsak6enuFZleVbLty1eULIw/IZuq8g6E+/V7mbFo4vkXMN\nq4YrX0Q3XEzB8Cdxd5vsnz7Uga35j44gwJ+BUsCyaRUyGzLqhUWHJS73Vy3IxHfX\nRj7TQUBFYDKbOS9oKearmvTb1SQzH7NM5jQUFzXeJQE03jetRneNQ5hkh9UhUr64\ngtRnnKXTimXkczEMU9eDSTgQoaebdPnWEnzoStS5ln03zH+CNTQF9qjcpYBrJ2mZ\nwnxO9OP/45KQL4hPAi2+hGkq2yjuIzeCkFJabAc7sF6lwJqH82XtiIIR+AGTM8QC\nEno0eqAytg8YawARAQABiQIlBBgBCAAPBQJXaRjdAhsMBQkcMgSAAAoJEJ4YqiZ9\n2420AuIP/1PYZDKFLv//+iY6Z9xGz4zHL+9nWND/Kll3xHeuWjYGZ2nmcovSnEW4\n0eiMn1c6KMgs/CCR4+9bm7MdgaF73pjM4xzHBIBetLLkcKQIrniX2Fq+WgscJfFx\n+0ha7Xb2TTpSy8PRiYHowVUaMPwyqSsAUwrSenLuwyiKr+EW4Wzo+YM2w9a86yw1\nGfWuiyk0Z4sGoPoPEjmD4y6Xlf8kIfuZeb+joHd6W1nMf7cxDkNLQqX6sWvs62Tv\nLsx2jApPKD2PyTyyxItJKc6NXFVM+Uww323ZYVWMkz+VKalHRiv6xzGqArhpAIH6\nfn+1WjjqkrrLU4I7smjlulZCy/NZLOKqQYaqM+7BgC2mOPMb5CM99cg4SrK86dFr\n3Cf22+OTmC6/Wb5Gu4PzTzkYIJDnt3BJQYjJlp4zyOHluN6notrWagLIB06oX+jQ\npxGySHW++Cha/JCUb0mfeHIJKvRor3v7YaSJoFIo//rz6XJ9WVZfsKnOte/3s9m7\nqkEvLArbe2o7pUJ2mxZZw/nAk/Y39FYAMvgMA9f+uv18O7u+ojYjS6DlrmNuIEg/\nmp8FqVxVNdIS2capSF4+eOn3a4kcF0018xbTLA2AwQ2o9eF5G9qTdSVrN865VPCd\nKWr9ByCKAwVHsaSgVSJE/dse4f1toqeEHHbWk682U4RqOWZR4bA0\n=3/jE\n-----END PGP PUBLIC KEY BLOCK-----\n\npub   ed25519 2019-06-21 [C]\n      C9C370B246B09F6DBCFC744C34401015D1D2D386\nuid           [ultimate] Aleksa Sarai <cyphar@cyphar.com>\nsub   ed25519 2022-09-30 [S] [expires: 2030-03-25]\nsub   cv25519 2022-09-30 [E] [expires: 2030-03-25]\nsub   ed25519 2022-09-30 [A] [expires: 2030-03-25]\n\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: github=cyphar\n\nmDMEXQxvLxYJKwYBBAHaRw8BAQdArRQoZs9YzYtQIiPA1qdvUT8Q0wbPZyRV65Tz\nQNTIZla0IEFsZWtzYSBTYXJhaSA8Y3lwaGFyQGN5cGhhci5jb20+iJAEExYIADgF\nCwkIBwIGFQoJCAsCBBYCAwECHgECF4ACGwEWIQTJw3CyRrCfbbz8dEw0QBAV0dLT\nhgUCZa3xwQAKCRA0QBAV0dLThpQyAQDGzjZyyWWmd6Ykg5/lymp2MLIg1f2jG6ew\nAiPT4ATkBAD/RgdLDf1IQStEH7pHmQa1qvqyRq1jeEgF23KruXbbdQ64MwRdDMJS\nFgkrBgEEAdpHDwEBB0B2IGusH7LuDH3hNT6JYM30S7G92FGogA6a9WQzKRlqvIh4\nBCgWCgAgFiEEycNwskawn228/HRMNEAQFdHS04YFAmM2ukUCHQEACgkQNEAQFdHS\n04ZTQAEAjAT0fXVJHdRL6UMCxDYsgjG+QyH1mr7gKgbPvB8A5LgBAN4QDqCxIY3b\n8+X4Ud3C9yLfkbcsdgctU3fO/jHpKVIIiO8EGBYIACAWIQTJw3CyRrCfbbz8dEw0\nQBAV0dLThgUCXQzCUgIbAgCBCRA0QBAV0dLThnYgBBkWCAAdFiEEsWZunbXxPIMS\ny32KnZS5YyG50BIFAl0MwlIACgkQnZS5YyG50BLusQD/aPjX4NhlSYgzNV2x31aw\nx5AxTp+18xoQDwaU123grDgA/2B73RiaTO2boRK5UETxx6awdsA51hZubxo4LyxG\nSP8IW5gA/2JWrDg+7cSQrS71gHmtqvz0se+D7zmWdcnN8O3LoUZeAQDW3Pkq0cru\nYVbsXiTwzenLPUJrjGBAVaoFmYqFUelFDLg4BF0MwmoSCisGAQQBl1UBBQEBB0BL\nFI5mD555F7t6dovnw4DW19nkG/g/Vd5Zb/7qhMLWagMBCAeIeAQoFgoAIBYhBMnD\ncLJGsJ9tvPx0TDRAEBXR0tOGBQJjNrpFAh0BAAoJEDRAEBXR0tOGgPkA/1Z69M4e\nqU3ZM7czYOHKAbNHiRuAqzc6o90WBJLhgFJmAQCcKmpnnnTpbnGoXgkcRSr2y1wk\nuId1oVRwfRbN9h94Doh4BBgWCAAgFiEEycNwskawn228/HRMNEAQFdHS04YFAl0M\nwmoCGwwACgkQNEAQFdHS04aZWgD/d0gCCB7ytnRB9RBtns9RRrtGXOIrzzWKw+zx\nza6Y2zgBANoj7CUeH0MygzZkgMrCmKPNnMxEnHJaTuYZA4yBixkIuDMEXQzCjRYJ\nKwYBBAHaRw8BAQdAAiFh7AD1u/UhjVbGJkRflPhjHBKIsAuP4pkI/qjavwaIeAQo\nFgoAIBYhBMnDcLJGsJ9tvPx0TDRAEBXR0tOGBQJjNrpFAh0BAAoJEDRAEBXR0tOG\nAUgA/2ZDB3tCRBON1WjLBESkHZmNtplYcV03u/oshA/MVCzpAQDGusGcv/rf1ZI9\no7lcWozXFlQDOM7eoT4avvWOVcsaD4h4BBgWCAAgFiEEycNwskawn228/HRMNEAQ\nFdHS04YFAl0Mwo0CGyAACgkQNEAQFdHS04ajxQEAsZf1yDORUVYicREc/7z0U+51\nDJzeAexeJTYM+N+x13EA/0Ex+o7qQ7dZLGDn7x4LSbd39C+++suHsEaE4XwlX6cH\nuDMEYza6SxYJKwYBBAHaRw8BAQdAE3s7dZQFuImQX2tWshIdGjeUKZc7rlMcrZ6+\nq25gaH2I9QQYFgoAJgIbAhYhBMnDcLJGsJ9tvPx0TDRAEBXR0tOGBQJlrfJcBQkO\nEpjFAIF2IAQZFgoAHRYhBLZOSVWyn6PUY/KpBiiX+tK36URvBQJjNrpLAAoJECiX\n+tK36URv2hsBALyKPjIlNTtlwC1PHZkyOPwSiu4ZveS7pWlHLHX6nJBCAP9CBDtf\nUbvG3C5WljSQdiBrXKgosDbJxPwXw+tW0XukAwkQNEAQFdHS04bMkQEA9elVwA0A\n+ywDw+jnifIc98XqLI+KF3Xl0A9+lMuwthMBAO00DeAEjkryFMGp62GPNHqr/r6p\n+6DIeUjWgK4Sh8IMuDgEYza6YBIKKwYBBAGXVQEFAQEHQKECW5Y7nUGCka0/WcCM\nOerRY95Pm2DQVL76QzvhXD8tAwEIB4h+BBgWCgAmAhsMFiEEycNwskawn228/HRM\nNEAQFdHS04YFAmWt8lwFCQ4SmLAACgkQNEAQFdHS04apHgD+MIRj2kujpxtQt04D\nZB+hofBtHIEMo2tplFBYvhZ6KOMA/1q3aRv6jnWAv8woc50KitP4/+iPmfyzaBA/\n8XA5DdIKuDMEYza6bhYJKwYBBAHaRw8BAQdAgHXd0yf6MPXJZCZ3TFz8xLymyPsD\nTF2SQwwqM4+nYbeIfgQYFgoAJgIbIBYhBMnDcLJGsJ9tvPx0TDRAEBXR0tOGBQJl\nrfJcBQkOEpiiAAoJEDRAEBXR0tOGAUwA/jbaz04OXnV3PYC/yQUsUJsihCTqz4Ne\nlxxclgJYU604APsFzpoLD0oUlfMn5Fh75ftkKPrwiHpTj4rRU6oIQu1/Bg==\n=Ab7w\n-----END PGP PUBLIC KEY BLOCK-----\n\npub   rsa2048 2020-04-28 [SC] [expires: 2028-04-18]\n      C2428CD75720FACDCF76B6EA17DE5ECB75A1100E\nuid           [ultimate] Kir Kolyshkin <kolyshkin@gmail.com>\nsub   rsa2048 2020-04-28 [E] [expires: 2028-04-18]\n\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: github=kolyshkin\n\nmQENBF6ou34BCACow4f1kUqw0varU4pq+C91xhYeNb/0sGyFKCvYfiLY74yG8EXW\nrZ8n06AYDHzPv9oubkUhnFk/u25kXQVgLB6Z5SKRBCiFq1QZirXeNJ8Iss8AwDBV\nppTSiCl8/x/gKoXiJ+7MyvOZozUavkVHdim1NKCzwD014VOB8RXz+heUjS+HDXY9\n2IknlaZg2oGpQe6weVmXmEhxERapG/y+/Vo6t8UfhSv0gEeM00/yWhBJKSYPtzMg\nSbTL4jCsN/x0bq+ZNp4lunihVY5WqX+BGLcx7xPnJ0Rp9Ju1mAhKrbKUmOG3rkWu\nDIJuVP8HQfCoffsBLUKQ0V4fh18kfq1bo3JvABEBAAG0I0tpciBLb2x5c2hraW4g\nPGtvbHlzaGtpbkBnbWFpbC5jb20+iQFUBBMBCAA+AhsDBQsJCAcCBhUKCQgLAgQW\nAgMBAh4BAheAFiEEwkKM11cg+s3PdrbqF95ey3WhEA4FAmdcs+gFCQ7+0bIACgkQ\nF95ey3WhEA6rRwf8CxnbLB/uqPZfmmiTzTk7luWaIo6YxtnNz3bn2rTByEo+rBgO\ngbgtKaV4REYeKhtbdstkMTX3zr+zlqwuqaPaag/Cz20HLkD04bI+JCPoRH/dPadd\n3nOdbdRfdWZeDDSFKjVunVpXlLxwvZ1WaaYKCfF06U3F7/z7MTAuKHrHTG9SrNPJ\nUPJTy63dNnuiPpVNNtOyftLGEGgD1JH2tcosVEwEpAlXpIpJy4Lad9ajaRVoYNtT\nqZr26sRFYNOQqWgl25QM8LyLFyYry9HfEXkbilW0OpkAkUvv0yAe97UPZ0beP8D+\nd5rMbZps6Ph1TtosdE/Gx8xWs7ALNDmXyCI/F7kBDQReqLt+AQgAtKUDLyUFxQ9k\np8OwI/MsPTLLoYfjilJaXnmtzQjGYFrEuU3lt7omRUBldNChkjGghEukGTq0RD7Z\ns6Qv5PM5dtOypPJM0lmz2j7seun3AfDV44h/bjOFwTUjab3Nr9fQ52qESmRS03ik\n6+5YNwq2D/+2kHVJ2vkUoo6KvioA1vPU311oW/Yfky8dLS5NguikE3to6YElWW38\noqFUVdMScCbf9a6CPXSQEz/rH4TgAhwyTo6oegv+8L/szGFy5ToNGiA0D45HcFDc\nyXs1d+b3bYRuGfC1l/z+WZWwbeHt1fKEQ8pCLDLRre5y0hPRHeN2CG4U7iyI5B5h\n8LITPcZ66wARAQABiQE8BBgBCAAmAhsMFiEEwkKM11cg+s3PdrbqF95ey3WhEA4F\nAmdctAIFCQ7+0bIACgkQF95ey3WhEA7PDggAlZxK7mCYThh7Z75mWftIaT3ms5jR\ncuQcCQYy2Z7qCaNxJtRklhsaAwpO0NQdNdQEfVXlNYLXRuFDq+hemhZKMu4lzQbZ\n3atm5swWcB8+9q+aCMP5nppwUXxCxHdhp4VxIYEv+wNjTF/6Fxu66fYPQPDKVacS\nH9NLjHsVoDFSi9rvtAy/Bs2aVn0hZkwpxzHJNVPnNcMAEnYXfM+kXu3761J61FAr\no8zT9XXXnUYRuxHRAsrpa3atQj7jDHvFlcc3VfPmUFPs0aLRy19/44xRE1FZOSur\nf7jJ1HOKSJA9zx0xWaURRTRkMTIVuMnQKZofxC96GavBDVTtZlgLzeWVnQ==\n=eHgH\n-----END PGP PUBLIC KEY BLOCK-----\n\npub   rsa3072 2019-07-25 [SC] [expires: 2025-07-27]\n      C020EA876CE4E06C7AB95AEF49524C6F9F638F1A\nuid           [ultimate] Akihiro Suda <akihiro.suda.cz@hco.ntt.co.jp>\nuid           [ultimate] Akihiro Suda <suda.kyoto@gmail.com>\nsub   rsa3072 2019-07-25 [E] [expires: 2025-07-27]\n\n-----BEGIN PGP PUBLIC KEY BLOCK-----\nComment: github=AkihiroSuda\n\nmQGNBF06GR8BDADEpCHv9HzGbqzQ2RAqTWBGHUNsiHD89NVmbXx4nw56odXf5mAK\nQHxyh9tKkt0BIaKMLcxcU6+GXP5iSLdHnQvnxxbR0gW3CJ8bIWPUflE4hjv8QLbc\n5CSpqa3d7/tsntVYNLPFs6B0acTXB4YLK+u2aC42US6by5zO4KS+8/7RyXhdkYGY\nwy6dCU1ysnuG4QstxlObKJUtxcW/9vQkF/ZdqaqLf6HHL/kMasWUxWG1uvf+V/MO\nBRKu7zBW290XDE5Dd9DomyX4q2kqoWQBkpvkJlVsKWpW+AXnBizbVD+pX90VEQmk\nTvnr6U9OiArS6m2yVwZlu836l2yo3tX2tsgTNn8gtZugO4Qb3iZnDUexqgCwnLBx\ndsyq4W565jNRV/HWRUMR+LDIS1KiEalzDoID3aUXRHHLUQG0oqX8jqFJUqp1P9pO\n9nezuUDg8SsaBg8O4tyv/CZq/FeF3RMMc2EHTiO8HTERqmRMxUFZv3bkgA4GnjnA\n3wsZhLXQq+UaIJUAEQEAAbQsQWtpaGlybyBTdWRhIDxha2loaXJvLnN1ZGEuY3pA\naGNvLm50dC5jby5qcD6JAdQEEwEKAD4CGwMFCwkIBwIGFQoJCAsCBBYCAwECHgEC\nF4AWIQTAIOqHbOTgbHq5Wu9JUkxvn2OPGgUCZMPL2QUJC0wZugAKCRBJUkxvn2OP\nGqTiC/93jTl0ci2zWC8vVBPSyjHDrpOhn+3ukCeC7VxHOdo6hBwbsxqaBUWi0Maf\np9oa4HzmsQjhMM+i3/Q/jHBvijXQ2UO5MaDrLhacoAW8i/YeU2aKn2yIyrQPIdc/\ntlcwjvsRPt534DOisf1N5+w6Y4DRgt2tNl0KOjEBmXsBWN7Fg+QRfLeNWKS9soq7\nQkI68T0e0h752FmI8TK4yy6FrhLVUU2ArLcOV2wjx5zKnWjgX7BbwYjAp8fi9hcC\nXdmSvllQ8U9Y2ll8dDq3HBmo+uI4lfz31S4B5EKo4Wn+3bA4Y+VBNoJfoKyLeOgr\n0cmo6SRJIsVaSvAJcMZ6oq+jvTDuygfRkxxgoTzCgwre7CPzcvC8gC0sYOB34TN4\nUogwN3pFmCPfi5TjXsx7vgfWKlHgwe3L/5aoQjTm+z6WanTHbIqOK9QkIuGykMpL\n7nOJeH9LoRzpzc8aOwIOki2bbo7s9yzL8Gil+zaqe16Q+Y7wVBxSRxbg/3oUTi1K\n/uM8N4S0I0FraWhpcm8gU3VkYSA8c3VkYS5reW90b0BnbWFpbC5jb20+iQHUBBMB\nCgA+AhsDBQsJCAcCBhUKCQgLAgQWAgMBAh4BAheAFiEEwCDqh2zk4Gx6uVrvSVJM\nb59jjxoFAmTDy9kFCQtMGboACgkQSVJMb59jjxogzgv/a+4+T5Xoklt0rGujSgtD\nogpQp4guaImEhkPieWMPG7+UfqxwoMLcvLE5kTzqLPe1DdYs8Tm/gtteHttLUfjD\nqwY/+BsqIYYMJMRoXFBk2iokn0m/36da7WKpN+5r5ssujsvGj991k4oLQgFV0kEx\nf4PSRxWQNlAqp4OfQNI91S7oMDH94dR+V5TIYYHxsPsnCvygD72GVER4G5mUvkCH\nNf8aqeckVxu8uZ/2LiNtYxbh5pwriuj8XbifuawdMdjpTvwAAa2DuKqCtj9cuQIt\nhmOF1ux68TRxk//QGPqX49+WT0mwdHBX/I/nZVTOGt9sjjKU5m1o+rUiVHtQ3Yhw\nfSLWEbfZiTjWDPWpjLU+r3C2qCiJyPjNpsxYAp4y3v511BXesejcXm24+MHFym5F\nngyAItzwDD9ieTt3uviuC64VZVz7NgnDMUK0LumKh9mrZZ20dTcX9Vw70o41CMQN\nyBKloXOSPzQDZp1ZXzR3P/22WXG/e52YuU3Aw1femld+uQGNBF06GR8BDACxpQ9c\ny72+/WZGon+CToNj+a24PiduyExfFv26E0D77ACS6UAC5jz71mSuLbHiauQ3MHj+\n786z4m4St8+HjDL9YrAe19MobxWsLHAFvBJ8UHfZdkLzBkIKPHz7TUqlhvFR13b6\nZAZVZk975hgCT3LpzA1miHBY2E5WDpVa3pe94xshVHL3iVf9Jv1a4hmM+eu0gxX4\niEw7RLq9LssTyjeuRVN23X+ojD4Mp3jQnPA+cjLF718KpCsw5r+tGZ98/5GZevmH\nQf6sg0b/k6/vkVveopeeH28zb/nnVuhgGSxcbiZUrFC9EfhX4/6NNFRhE300AjeF\nbP7SoXx3qRhr993BDSP32r44hy+kYLhZP5K5oXivcITJZuGcJh49P4QuYGrnODIL\ngEhedWeePcJXFcEz09teizlWKGzd+EA3uwYd/bQelflwXkGuCLaoNv4qcH3oJDp1\nvYI0zT7hGvnz3thRLg3SOWFq5cBhnfNGXPLsoNZBzWGn2cm5MJYSKjIM470AEQEA\nAYkBvAQYAQoAJgIbDBYhBMAg6ods5OBserla70lSTG+fY48aBQJkw8uyBQkLTBmT\nAAoJEElSTG+fY48ayhsL+gLvKlfkYgxodyWKR5hOiUMKWE5tqfQY6kqrgssPYw+u\nFn69AamQLt4I2AHRg0AHjoZEsMfR19uXZ24XwwcWwgWU6yRJgMSIK67bLvL+d686\nm2KQ2PpmfDrizUgY4J0sY+tzwNZeWxQiFy/Ni6AdEqJvJQDsrKYJ2GGWm6JMZCPw\ny3h5ouueieiEc0pvwEz2kg64uv6p8SUV1me66IXQaGseXb/BcW+Ap2WJO+IZjtNB\nqhk+V+1x5ZT6s9RecjiTDmKfZ71zyRWplkfL22+4XVEc3qLS3r0ZSzeIA4JPRf+N\nyCGjavdTNgu2bTo8iSgBq2NRT9kNwTaS8j883L0eY/JJktrfWnWE4qAuXBqLzkIl\nsmspRWy0byLQrrzk9stncF/CDt5XuHPcsXOcRVXVyM+/RXqWKdNAwZO67HD4wJR9\nYR4avhGZZXguH3b0ka2zO8sxTju/09yb07NJ2qfjfWSHCmaj9KuhhE0EO625tckS\n58ceqolNBtrydoYZOc2CKw==\n=ol6W\n-----END PGP PUBLIC KEY BLOCK-----\n\n"
        },
        {
          "name": "script",
          "type": "tree",
          "content": null
        },
        {
          "name": "signals.go",
          "type": "blob",
          "size": 3.71484375,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"os/signal\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst signalBufferSize = 2048\n\n// newSignalHandler returns a signal handler for processing SIGCHLD and SIGWINCH signals\n// while still forwarding all other signals to the process.\n// If notifySocket is present, use it to read systemd notifications from the container and\n// forward them to notifySocketHost.\nfunc newSignalHandler(enableSubreaper bool, notifySocket *notifySocket) *signalHandler {\n\tif enableSubreaper {\n\t\t// set us as the subreaper before registering the signal handler for the container\n\t\tif err := system.SetSubreaper(1); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n\t// ensure that we have a large buffer size so that we do not miss any signals\n\t// in case we are not processing them fast enough.\n\ts := make(chan os.Signal, signalBufferSize)\n\t// handle all signals for the process.\n\tsignal.Notify(s)\n\treturn &signalHandler{\n\t\tsignals:      s,\n\t\tnotifySocket: notifySocket,\n\t}\n}\n\n// exit models a process exit status with the pid and\n// exit status.\ntype exit struct {\n\tpid    int\n\tstatus int\n}\n\ntype signalHandler struct {\n\tsignals      chan os.Signal\n\tnotifySocket *notifySocket\n}\n\n// forward handles the main signal event loop forwarding, resizing, or reaping depending\n// on the signal received.\nfunc (h *signalHandler) forward(process *libcontainer.Process, tty *tty, detach bool) (int, error) {\n\t// make sure we know the pid of our main process so that we can return\n\t// after it dies.\n\tif detach && h.notifySocket == nil {\n\t\treturn 0, nil\n\t}\n\n\tpid1, err := process.Pid()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tif h.notifySocket != nil {\n\t\tif detach {\n\t\t\t_ = h.notifySocket.run(pid1)\n\t\t\treturn 0, nil\n\t\t}\n\t\t_ = h.notifySocket.run(os.Getpid())\n\t\tgo func() { _ = h.notifySocket.run(0) }()\n\t}\n\n\t// Perform the initial tty resize. Always ignore errors resizing because\n\t// stdout might have disappeared (due to races with when SIGHUP is sent).\n\t_ = tty.resize()\n\t// Handle and forward signals.\n\tfor s := range h.signals {\n\t\tswitch s {\n\t\tcase unix.SIGWINCH:\n\t\t\t// Ignore errors resizing, as above.\n\t\t\t_ = tty.resize()\n\t\tcase unix.SIGCHLD:\n\t\t\texits, err := h.reap()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Error(err)\n\t\t\t}\n\t\t\tfor _, e := range exits {\n\t\t\t\tlogrus.WithFields(logrus.Fields{\n\t\t\t\t\t\"pid\":    e.pid,\n\t\t\t\t\t\"status\": e.status,\n\t\t\t\t}).Debug(\"process exited\")\n\t\t\t\tif e.pid == pid1 {\n\t\t\t\t\t// call Wait() on the process even though we already have the exit\n\t\t\t\t\t// status because we must ensure that any of the go specific process\n\t\t\t\t\t// fun such as flushing pipes are complete before we return.\n\t\t\t\t\t_, _ = process.Wait()\n\t\t\t\t\treturn e.status, nil\n\t\t\t\t}\n\t\t\t}\n\t\tcase unix.SIGURG:\n\t\t\t// SIGURG is used by go runtime for async preemptive\n\t\t\t// scheduling, so runc receives it from time to time,\n\t\t\t// and it should not be forwarded to the container.\n\t\t\t// Do nothing.\n\t\tdefault:\n\t\t\tus := s.(unix.Signal)\n\t\t\tlogrus.Debugf(\"forwarding signal %d (%s) to %d\", int(us), unix.SignalName(us), pid1)\n\t\t\tif err := unix.Kill(pid1, us); err != nil {\n\t\t\t\tlogrus.Error(err)\n\t\t\t}\n\t\t}\n\t}\n\treturn -1, nil\n}\n\n// reap runs wait4 in a loop until we have finished processing any existing exits\n// then returns all exits to the main event loop for further processing.\nfunc (h *signalHandler) reap() (exits []exit, err error) {\n\tvar (\n\t\tws  unix.WaitStatus\n\t\trus unix.Rusage\n\t)\n\tfor {\n\t\tpid, err := unix.Wait4(-1, &ws, unix.WNOHANG, &rus)\n\t\tif err != nil {\n\t\t\tif err == unix.ECHILD {\n\t\t\t\treturn exits, nil\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t\tif pid <= 0 {\n\t\t\treturn exits, nil\n\t\t}\n\t\texits = append(exits, exit{\n\t\t\tpid:    pid,\n\t\t\tstatus: utils.ExitStatus(ws),\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "spec.go",
          "type": "blob",
          "size": 4.3330078125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/specconv\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/urfave/cli\"\n)\n\nvar specCommand = cli.Command{\n\tName:      \"spec\",\n\tUsage:     \"create a new specification file\",\n\tArgsUsage: \"\",\n\tDescription: `The spec command creates the new specification file named \"` + specConfig + `\" for\nthe bundle.\n\nThe spec generated is just a starter file. Editing of the spec is required to\nachieve desired results. For example, the newly generated spec includes an args\nparameter that is initially set to call the \"sh\" command when the container is\nstarted. Calling \"sh\" may work for an ubuntu container or busybox, but will not\nwork for containers that do not include the \"sh\" program.\n\nEXAMPLE:\n  To run docker's hello-world container one needs to set the args parameter\nin the spec to call hello. This can be done using the sed command or a text\neditor. The following commands create a bundle for hello-world, change the\ndefault args parameter in the spec from \"sh\" to \"/hello\", then run the hello\ncommand in a new hello-world container named container1:\n\n    mkdir hello\n    cd hello\n    docker pull hello-world\n    docker export $(docker create hello-world) > hello-world.tar\n    mkdir rootfs\n    tar -C rootfs -xf hello-world.tar\n    runc spec\n    sed -i 's;\"sh\";\"/hello\";' ` + specConfig + `\n    runc run container1\n\nIn the run command above, \"container1\" is the name for the instance of the\ncontainer that you are starting. The name you provide for the container instance\nmust be unique on your host.\n\nAn alternative for generating a customized spec config is to use \"oci-runtime-tool\", the\nsub-command \"oci-runtime-tool generate\" has lots of options that can be used to do any\ncustomizations as you want, see runtime-tools (https://github.com/opencontainers/runtime-tools)\nto get more information.\n\nWhen starting a container through runc, runc needs root privilege. If not\nalready running as root, you can use sudo to give runc root privilege. For\nexample: \"sudo runc start container1\" will give runc root privilege to start the\ncontainer on your host.\n\nAlternatively, you can start a rootless container, which has the ability to run\nwithout root privileges. For this to work, the specification file needs to be\nadjusted accordingly. You can pass the parameter --rootless to this command to\ngenerate a proper rootless spec file.\n\nNote that --rootless is not needed when you execute runc as the root in a user namespace\ncreated by an unprivileged user.\n`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"bundle, b\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"path to the root of the bundle directory\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"rootless\",\n\t\t\tUsage: \"generate a configuration for a rootless container\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 0, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tspec := specconv.Example()\n\n\t\trootless := context.Bool(\"rootless\")\n\t\tif rootless {\n\t\t\tspecconv.ToRootless(spec)\n\t\t}\n\n\t\tcheckNoFile := func(name string) error {\n\t\t\t_, err := os.Stat(name)\n\t\t\tif err == nil {\n\t\t\t\treturn fmt.Errorf(\"File %s exists. Remove it first\", name)\n\t\t\t}\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tbundle := context.String(\"bundle\")\n\t\tif bundle != \"\" {\n\t\t\tif err := os.Chdir(bundle); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := checkNoFile(specConfig); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdata, err := json.MarshalIndent(spec, \"\", \"\\t\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn os.WriteFile(specConfig, data, 0o666)\n\t},\n}\n\n// loadSpec loads the specification from the provided path.\nfunc loadSpec(cPath string) (spec *specs.Spec, err error) {\n\tcf, err := os.Open(cPath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, fmt.Errorf(\"JSON specification file %s not found\", cPath)\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer cf.Close()\n\n\tif err = json.NewDecoder(cf).Decode(&spec); err != nil {\n\t\treturn nil, err\n\t}\n\tif spec == nil {\n\t\treturn nil, errors.New(\"config cannot be null\")\n\t}\n\treturn spec, validateProcessSpec(spec.Process)\n}\n\nfunc createLibContainerRlimit(rlimit specs.POSIXRlimit) (configs.Rlimit, error) {\n\trl, err := strToRlimit(rlimit.Type)\n\tif err != nil {\n\t\treturn configs.Rlimit{}, err\n\t}\n\treturn configs.Rlimit{\n\t\tType: rl,\n\t\tHard: rlimit.Hard,\n\t\tSoft: rlimit.Soft,\n\t}, nil\n}\n"
        },
        {
          "name": "start.go",
          "type": "blob",
          "size": 1.3984375,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/urfave/cli\"\n)\n\nvar startCommand = cli.Command{\n\tName:  \"start\",\n\tUsage: \"executes the user defined process in a created container\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is your name for the instance of the container that you\nare starting. The name you provide for the container instance must be unique on\nyour host.`,\n\tDescription: `The start command executes the user defined process in a created container.`,\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := container.Status()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch status {\n\t\tcase libcontainer.Created:\n\t\t\tnotifySocket, err := notifySocketStart(context, os.Getenv(\"NOTIFY_SOCKET\"), container.ID())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := container.Exec(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif notifySocket != nil {\n\t\t\t\treturn notifySocket.waitForContainer(container)\n\t\t\t}\n\t\t\treturn nil\n\t\tcase libcontainer.Stopped:\n\t\t\treturn errors.New(\"cannot start a container that has stopped\")\n\t\tcase libcontainer.Running:\n\t\t\treturn errors.New(\"cannot start an already running container\")\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"cannot start a container in the %s state\", status)\n\t\t}\n\t},\n}\n"
        },
        {
          "name": "state.go",
          "type": "blob",
          "size": 1.419921875,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/urfave/cli\"\n)\n\nvar stateCommand = cli.Command{\n\tName:  \"state\",\n\tUsage: \"output the state of a container\",\n\tArgsUsage: `<container-id>\n\nWhere \"<container-id>\" is your name for the instance of the container.`,\n\tDescription: `The state command outputs current state information for the\ninstance of a container.`,\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontainerStatus, err := container.Status()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstate, err := container.State()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpid := state.BaseState.InitProcessPid\n\t\tif containerStatus == libcontainer.Stopped {\n\t\t\tpid = 0\n\t\t}\n\t\tbundle, annotations := utils.Annotations(state.Config.Labels)\n\t\tcs := containerState{\n\t\t\tVersion:        state.BaseState.Config.Version,\n\t\t\tID:             state.BaseState.ID,\n\t\t\tInitProcessPid: pid,\n\t\t\tStatus:         containerStatus.String(),\n\t\t\tBundle:         bundle,\n\t\t\tRootfs:         state.BaseState.Config.Rootfs,\n\t\t\tCreated:        state.BaseState.Created,\n\t\t\tAnnotations:    annotations,\n\t\t}\n\t\tdata, err := json.MarshalIndent(cs, \"\", \"  \")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tos.Stdout.Write(data)\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tty.go",
          "type": "blob",
          "size": 4.365234375,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\n\t\"github.com/containerd/console\"\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\ntype tty struct {\n\tepoller     *console.Epoller\n\tconsole     *console.EpollConsole\n\thostConsole console.Console\n\tclosers     []io.Closer\n\tpostStart   []io.Closer\n\twg          sync.WaitGroup\n\tconsoleC    chan error\n}\n\nfunc (t *tty) copyIO(w io.Writer, r io.ReadCloser) {\n\tdefer t.wg.Done()\n\t_, _ = io.Copy(w, r)\n\t_ = r.Close()\n}\n\n// setup pipes for the process so that advanced features like c/r are able to easily checkpoint\n// and restore the process's IO without depending on a host specific path or device\nfunc setupProcessPipes(p *libcontainer.Process, rootuid, rootgid int) (*tty, error) {\n\ti, err := p.InitializeIO(rootuid, rootgid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tt := &tty{\n\t\tclosers: []io.Closer{\n\t\t\ti.Stdin,\n\t\t\ti.Stdout,\n\t\t\ti.Stderr,\n\t\t},\n\t}\n\t// add the process's io to the post start closers if they support close\n\tfor _, cc := range []interface{}{\n\t\tp.Stdin,\n\t\tp.Stdout,\n\t\tp.Stderr,\n\t} {\n\t\tif c, ok := cc.(io.Closer); ok {\n\t\t\tt.postStart = append(t.postStart, c)\n\t\t}\n\t}\n\tgo func() {\n\t\t_, _ = io.Copy(i.Stdin, os.Stdin)\n\t\t_ = i.Stdin.Close()\n\t}()\n\tt.wg.Add(2)\n\tgo t.copyIO(os.Stdout, i.Stdout)\n\tgo t.copyIO(os.Stderr, i.Stderr)\n\treturn t, nil\n}\n\nfunc inheritStdio(process *libcontainer.Process) {\n\tprocess.Stdin = os.Stdin\n\tprocess.Stdout = os.Stdout\n\tprocess.Stderr = os.Stderr\n}\n\nfunc (t *tty) initHostConsole() error {\n\t// Usually all three (stdin, stdout, and stderr) streams are open to\n\t// the terminal, but they might be redirected, so try them all.\n\tfor _, s := range []*os.File{os.Stderr, os.Stdout, os.Stdin} {\n\t\tc, err := console.ConsoleFromFile(s)\n\t\tif err == nil {\n\t\t\tt.hostConsole = c\n\t\t\treturn nil\n\t\t}\n\t\tif errors.Is(err, console.ErrNotAConsole) {\n\t\t\tcontinue\n\t\t}\n\t\t// should not happen\n\t\treturn fmt.Errorf(\"unable to get console: %w\", err)\n\t}\n\t// If all streams are redirected, but we still have a controlling\n\t// terminal, it can be obtained by opening /dev/tty.\n\ttty, err := os.Open(\"/dev/tty\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tc, err := console.ConsoleFromFile(tty)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to get console: %w\", err)\n\t}\n\n\tt.hostConsole = c\n\treturn nil\n}\n\nfunc (t *tty) recvtty(socket *os.File) (Err error) {\n\tf, err := utils.RecvFile(socket)\n\tif err != nil {\n\t\treturn err\n\t}\n\tcons, err := console.ConsoleFromFile(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = console.ClearONLCR(cons.Fd())\n\tif err != nil {\n\t\treturn err\n\t}\n\tepoller, err := console.NewEpoller()\n\tif err != nil {\n\t\treturn err\n\t}\n\tepollConsole, err := epoller.Add(cons)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif Err != nil {\n\t\t\t_ = epollConsole.Close()\n\t\t}\n\t}()\n\tgo func() { _ = epoller.Wait() }()\n\tgo func() { _, _ = io.Copy(epollConsole, os.Stdin) }()\n\tt.wg.Add(1)\n\tgo t.copyIO(os.Stdout, epollConsole)\n\n\t// Set raw mode for the controlling terminal.\n\tif err := t.hostConsole.SetRaw(); err != nil {\n\t\treturn fmt.Errorf(\"failed to set the terminal from the stdin: %w\", err)\n\t}\n\tgo handleInterrupt(t.hostConsole)\n\n\tt.epoller = epoller\n\tt.console = epollConsole\n\tt.closers = []io.Closer{epollConsole}\n\treturn nil\n}\n\nfunc handleInterrupt(c console.Console) {\n\tsigchan := make(chan os.Signal, 1)\n\tsignal.Notify(sigchan, os.Interrupt)\n\t<-sigchan\n\t_ = c.Reset()\n\tos.Exit(0)\n}\n\nfunc (t *tty) waitConsole() error {\n\tif t.consoleC != nil {\n\t\treturn <-t.consoleC\n\t}\n\treturn nil\n}\n\n// ClosePostStart closes any fds that are provided to the container and dup2'd\n// so that we no longer have copy in our process.\nfunc (t *tty) ClosePostStart() {\n\tfor _, c := range t.postStart {\n\t\t_ = c.Close()\n\t}\n}\n\n// Close closes all open fds for the tty and/or restores the original\n// stdin state to what it was prior to the container execution\nfunc (t *tty) Close() {\n\t// ensure that our side of the fds are always closed\n\tfor _, c := range t.postStart {\n\t\t_ = c.Close()\n\t}\n\t// the process is gone at this point, shutting down the console if we have\n\t// one and wait for all IO to be finished\n\tif t.console != nil && t.epoller != nil {\n\t\t_ = t.console.Shutdown(t.epoller.CloseConsole)\n\t}\n\tt.wg.Wait()\n\tfor _, c := range t.closers {\n\t\t_ = c.Close()\n\t}\n\tif t.hostConsole != nil {\n\t\t_ = t.hostConsole.Reset()\n\t}\n}\n\nfunc (t *tty) resize() error {\n\tif t.console == nil || t.hostConsole == nil {\n\t\treturn nil\n\t}\n\treturn t.console.ResizeFrom(t.hostConsole)\n}\n"
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        },
        {
          "name": "update.go",
          "type": "blob",
          "size": 10.751953125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/sirupsen/logrus\"\n\n\t\"github.com/docker/go-units\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/urfave/cli\"\n)\n\nfunc i64Ptr(i int64) *int64   { return &i }\nfunc u64Ptr(i uint64) *uint64 { return &i }\nfunc u16Ptr(i uint16) *uint16 { return &i }\nfunc boolPtr(b bool) *bool    { return &b }\n\nvar updateCommand = cli.Command{\n\tName:      \"update\",\n\tUsage:     \"update container resource constraints\",\n\tArgsUsage: `<container-id>`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"resources, r\",\n\t\t\tValue: \"\",\n\t\t\tUsage: `path to the file containing the resources to update or '-' to read from the standard input\n\nThe accepted format is as follow (unchanged values can be omitted):\n\n{\n  \"memory\": {\n    \"limit\": 0,\n    \"reservation\": 0,\n    \"swap\": 0,\n    \"checkBeforeUpdate\": true\n  },\n  \"cpu\": {\n    \"shares\": 0,\n    \"quota\": 0,\n    \"burst\": 0,\n    \"period\": 0,\n    \"realtimeRuntime\": 0,\n    \"realtimePeriod\": 0,\n    \"cpus\": \"\",\n    \"mems\": \"\",\n    \"idle\": 0\n  },\n  \"blockIO\": {\n    \"weight\": 0\n  }\n}\n\nNote: if data is to be read from a file or the standard input, all\nother options are ignored.\n`,\n\t\t},\n\n\t\tcli.IntFlag{\n\t\t\tName:  \"blkio-weight\",\n\t\t\tUsage: \"Specifies per cgroup weight, range is from 10 to 1000\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpu-period\",\n\t\t\tUsage: \"CPU CFS period to be used for hardcapping (in usecs). 0 to use system default\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpu-quota\",\n\t\t\tUsage: \"CPU CFS hardcap limit (in usecs). Allowed cpu time in a given period\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpu-burst\",\n\t\t\tUsage: \"CPU CFS hardcap burst limit (in usecs). Allowed accumulated cpu time additionally for burst a given period\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpu-share\",\n\t\t\tUsage: \"CPU shares (relative weight vs. other containers)\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpu-rt-period\",\n\t\t\tUsage: \"CPU realtime period to be used for hardcapping (in usecs). 0 to use system default\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpu-rt-runtime\",\n\t\t\tUsage: \"CPU realtime hardcap limit (in usecs). Allowed cpu time in a given period\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpuset-cpus\",\n\t\t\tUsage: \"CPU(s) to use\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpuset-mems\",\n\t\t\tUsage: \"Memory node(s) to use\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"kernel-memory\",\n\t\t\tUsage:  \"(obsoleted; do not use)\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:   \"kernel-memory-tcp\",\n\t\t\tUsage:  \"(obsoleted; do not use)\",\n\t\t\tHidden: true,\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"memory\",\n\t\t\tUsage: \"Memory limit (in bytes)\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cpu-idle\",\n\t\t\tUsage: \"set cgroup SCHED_IDLE or not, 0: default behavior, 1: SCHED_IDLE\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"memory-reservation\",\n\t\t\tUsage: \"Memory reservation or soft_limit (in bytes)\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"memory-swap\",\n\t\t\tUsage: \"Total memory usage (memory + swap); set '-1' to enable unlimited swap\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:  \"pids-limit\",\n\t\t\tUsage: \"Maximum number of pids allowed in the container\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"l3-cache-schema\",\n\t\t\tUsage: \"The string of Intel RDT/CAT L3 cache schema\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"mem-bw-schema\",\n\t\t\tUsage: \"The string of Intel RDT/MBA memory bandwidth schema\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, exactArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcontainer, err := getContainer(context)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tr := specs.LinuxResources{\n\t\t\t// nil and u64Ptr(0) are not interchangeable\n\t\t\tMemory: &specs.LinuxMemory{\n\t\t\t\tCheckBeforeUpdate: boolPtr(false), // constant\n\t\t\t},\n\t\t\tCPU:     &specs.LinuxCPU{},\n\t\t\tBlockIO: &specs.LinuxBlockIO{},\n\t\t\tPids:    &specs.LinuxPids{},\n\t\t}\n\n\t\tconfig := container.Config()\n\n\t\tif in := context.String(\"resources\"); in != \"\" {\n\t\t\tvar (\n\t\t\t\tf   *os.File\n\t\t\t\terr error\n\t\t\t)\n\t\t\tswitch in {\n\t\t\tcase \"-\":\n\t\t\t\tf = os.Stdin\n\t\t\tdefault:\n\t\t\t\tf, err = os.Open(in)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tdefer f.Close()\n\t\t\t}\n\t\t\terr = json.NewDecoder(f).Decode(&r)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif val := context.Int(\"blkio-weight\"); val != 0 {\n\t\t\t\tr.BlockIO.Weight = u16Ptr(uint16(val))\n\t\t\t}\n\t\t\tif val := context.String(\"cpuset-cpus\"); val != \"\" {\n\t\t\t\tr.CPU.Cpus = val\n\t\t\t}\n\t\t\tif val := context.String(\"cpuset-mems\"); val != \"\" {\n\t\t\t\tr.CPU.Mems = val\n\t\t\t}\n\t\t\tif val := context.String(\"cpu-idle\"); val != \"\" {\n\t\t\t\tidle, err := strconv.ParseInt(val, 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"invalid value for cpu-idle: %w\", err)\n\t\t\t\t}\n\t\t\t\tr.CPU.Idle = i64Ptr(idle)\n\t\t\t}\n\n\t\t\tfor _, pair := range []struct {\n\t\t\t\topt  string\n\t\t\t\tdest **uint64\n\t\t\t}{\n\t\t\t\t{\"cpu-burst\", &r.CPU.Burst},\n\t\t\t\t{\"cpu-period\", &r.CPU.Period},\n\t\t\t\t{\"cpu-rt-period\", &r.CPU.RealtimePeriod},\n\t\t\t\t{\"cpu-share\", &r.CPU.Shares},\n\t\t\t} {\n\t\t\t\tif val := context.String(pair.opt); val != \"\" {\n\t\t\t\t\tv, err := strconv.ParseUint(val, 10, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"invalid value for %s: %w\", pair.opt, err)\n\t\t\t\t\t}\n\t\t\t\t\t*pair.dest = &v\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, pair := range []struct {\n\t\t\t\topt  string\n\t\t\t\tdest **int64\n\t\t\t}{\n\t\t\t\t{\"cpu-quota\", &r.CPU.Quota},\n\t\t\t\t{\"cpu-rt-runtime\", &r.CPU.RealtimeRuntime},\n\t\t\t} {\n\t\t\t\tif val := context.String(pair.opt); val != \"\" {\n\t\t\t\t\tv, err := strconv.ParseInt(val, 10, 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn fmt.Errorf(\"invalid value for %s: %w\", pair.opt, err)\n\t\t\t\t\t}\n\t\t\t\t\t*pair.dest = &v\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, pair := range []struct {\n\t\t\t\topt  string\n\t\t\t\tdest **int64\n\t\t\t}{\n\t\t\t\t{\"memory\", &r.Memory.Limit},\n\t\t\t\t{\"memory-swap\", &r.Memory.Swap},\n\t\t\t\t{\"kernel-memory\", &r.Memory.Kernel}, //nolint:staticcheck // Ignore SA1019. Need to keep deprecated package for compatibility.\n\t\t\t\t{\"kernel-memory-tcp\", &r.Memory.KernelTCP},\n\t\t\t\t{\"memory-reservation\", &r.Memory.Reservation},\n\t\t\t} {\n\t\t\t\tif val := context.String(pair.opt); val != \"\" {\n\t\t\t\t\tvar v int64\n\n\t\t\t\t\tif val != \"-1\" {\n\t\t\t\t\t\tv, err = units.RAMInBytes(val)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"invalid value for %s: %w\", pair.opt, err)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv = -1\n\t\t\t\t\t}\n\t\t\t\t\t*pair.dest = &v\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tr.Pids.Limit = int64(context.Int(\"pids-limit\"))\n\t\t}\n\n\t\t// Fix up values\n\t\tif r.Memory.Limit != nil && *r.Memory.Limit == -1 && r.Memory.Swap == nil {\n\t\t\t// To avoid error \"unable to set swap limit without memory limit\"\n\t\t\tr.Memory.Swap = i64Ptr(0)\n\t\t}\n\t\tif r.CPU.Idle != nil && r.CPU.Shares == nil {\n\t\t\t// To avoid error \"failed to write \\\"4\\\": write /sys/fs/cgroup/runc-cgroups-integration-test/test-cgroup-7341/cpu.weight: invalid argument\"\n\t\t\tr.CPU.Shares = u64Ptr(0)\n\t\t}\n\n\t\tif (r.Memory.Kernel != nil) || (r.Memory.KernelTCP != nil) { //nolint:staticcheck // Ignore SA1019. Need to keep deprecated package for compatibility.\n\t\t\tlogrus.Warn(\"Kernel memory settings are ignored and will be removed\")\n\t\t}\n\n\t\t// Update the values\n\t\tif r.BlockIO.Weight != nil {\n\t\t\tconfig.Cgroups.Resources.BlkioWeight = *r.BlockIO.Weight\n\t\t}\n\n\t\t// Setting CPU quota and period independently does not make much sense,\n\t\t// but historically runc allowed it and this needs to be supported\n\t\t// to not break compatibility.\n\t\t//\n\t\t// For systemd cgroup drivers to set CPU quota/period correctly,\n\t\t// it needs to know both values. For fs2 cgroup driver to be compatible\n\t\t// with the fs driver, it also needs to know both values.\n\t\t//\n\t\t// Here in update, previously set values are available from config.\n\t\t// If only one of {quota,period} is set and the other is not, leave\n\t\t// the unset parameter at the old value (don't overwrite config).\n\t\tvar (\n\t\t\tp uint64\n\t\t\tq int64\n\t\t)\n\t\tif r.CPU.Period != nil {\n\t\t\tp = *r.CPU.Period\n\t\t}\n\t\tif r.CPU.Quota != nil {\n\t\t\tq = *r.CPU.Quota\n\t\t}\n\t\tif (p == 0 && q == 0) || (p != 0 && q != 0) {\n\t\t\t// both values are either set or unset (0)\n\t\t\tconfig.Cgroups.Resources.CpuPeriod = p\n\t\t\tconfig.Cgroups.Resources.CpuQuota = q\n\t\t} else {\n\t\t\t// one is set and the other is not\n\t\t\tif p != 0 {\n\t\t\t\t// set new period, leave quota at old value\n\t\t\t\tconfig.Cgroups.Resources.CpuPeriod = p\n\t\t\t} else if q != 0 {\n\t\t\t\t// set new quota, leave period at old value\n\t\t\t\tconfig.Cgroups.Resources.CpuQuota = q\n\t\t\t}\n\t\t}\n\n\t\tconfig.Cgroups.Resources.CpuBurst = r.CPU.Burst // can be nil\n\t\tif r.CPU.Shares != nil {\n\t\t\tconfig.Cgroups.Resources.CpuShares = *r.CPU.Shares\n\t\t\t// CpuWeight is used for cgroupv2 and should be converted\n\t\t\tconfig.Cgroups.Resources.CpuWeight = cgroups.ConvertCPUSharesToCgroupV2Value(*r.CPU.Shares)\n\t\t}\n\t\tif r.CPU.RealtimePeriod != nil {\n\t\t\tconfig.Cgroups.Resources.CpuRtPeriod = *r.CPU.RealtimePeriod\n\t\t}\n\t\tif r.CPU.RealtimeRuntime != nil {\n\t\t\tconfig.Cgroups.Resources.CpuRtRuntime = *r.CPU.RealtimeRuntime\n\t\t}\n\t\tconfig.Cgroups.Resources.CpusetCpus = r.CPU.Cpus\n\t\tconfig.Cgroups.Resources.CpusetMems = r.CPU.Mems\n\t\tif r.Memory.Limit != nil {\n\t\t\tconfig.Cgroups.Resources.Memory = *r.Memory.Limit\n\t\t}\n\t\tconfig.Cgroups.Resources.CPUIdle = r.CPU.Idle\n\t\tif r.Memory.Reservation != nil {\n\t\t\tconfig.Cgroups.Resources.MemoryReservation = *r.Memory.Reservation\n\t\t}\n\t\tif r.Memory.Swap != nil {\n\t\t\tconfig.Cgroups.Resources.MemorySwap = *r.Memory.Swap\n\t\t}\n\t\tif r.Memory.CheckBeforeUpdate != nil {\n\t\t\tconfig.Cgroups.Resources.MemoryCheckBeforeUpdate = *r.Memory.CheckBeforeUpdate\n\t\t}\n\t\tconfig.Cgroups.Resources.PidsLimit = r.Pids.Limit\n\t\tconfig.Cgroups.Resources.Unified = r.Unified\n\n\t\t// Update Intel RDT\n\t\tl3CacheSchema := context.String(\"l3-cache-schema\")\n\t\tmemBwSchema := context.String(\"mem-bw-schema\")\n\t\tif l3CacheSchema != \"\" && !intelrdt.IsCATEnabled() {\n\t\t\treturn errors.New(\"Intel RDT/CAT: l3 cache schema is not enabled\")\n\t\t}\n\n\t\tif memBwSchema != \"\" && !intelrdt.IsMBAEnabled() {\n\t\t\treturn errors.New(\"Intel RDT/MBA: memory bandwidth schema is not enabled\")\n\t\t}\n\n\t\tif l3CacheSchema != \"\" || memBwSchema != \"\" {\n\t\t\t// If intelRdt is not specified in original configuration, we just don't\n\t\t\t// Apply() to create intelRdt group or attach tasks for this container.\n\t\t\t// In update command, we could re-enable through IntelRdtManager.Apply()\n\t\t\t// and then update intelrdt constraint.\n\t\t\tif config.IntelRdt == nil {\n\t\t\t\tstate, err := container.State()\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tconfig.IntelRdt = &configs.IntelRdt{}\n\t\t\t\tintelRdtManager := intelrdt.NewManager(&config, container.ID(), state.IntelRdtPath)\n\t\t\t\tif err := intelRdtManager.Apply(state.InitProcessPid); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tconfig.IntelRdt.L3CacheSchema = l3CacheSchema\n\t\t\tconfig.IntelRdt.MemBwSchema = memBwSchema\n\t\t}\n\n\t\t// XXX(kolyshkin@): currently \"runc update\" is unable to change\n\t\t// device configuration, so add this to skip device update.\n\t\t// This helps in case an extra plugin (nvidia GPU) applies some\n\t\t// configuration on top of what runc does.\n\t\t// Note this field is not saved into container's state.json.\n\t\tconfig.Cgroups.SkipDevices = true\n\n\t\treturn container.Set(config)\n\t},\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 2.9443359375,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n)\n\nconst (\n\texactArgs = iota\n\tminArgs\n\tmaxArgs\n)\n\nfunc checkArgs(context *cli.Context, expected, checkType int) error {\n\tvar err error\n\tcmdName := context.Command.Name\n\tswitch checkType {\n\tcase exactArgs:\n\t\tif context.NArg() != expected {\n\t\t\terr = fmt.Errorf(\"%s: %q requires exactly %d argument(s)\", os.Args[0], cmdName, expected)\n\t\t}\n\tcase minArgs:\n\t\tif context.NArg() < expected {\n\t\t\terr = fmt.Errorf(\"%s: %q requires a minimum of %d argument(s)\", os.Args[0], cmdName, expected)\n\t\t}\n\tcase maxArgs:\n\t\tif context.NArg() > expected {\n\t\t\terr = fmt.Errorf(\"%s: %q requires a maximum of %d argument(s)\", os.Args[0], cmdName, expected)\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tfmt.Printf(\"Incorrect Usage.\\n\\n\")\n\t\t_ = cli.ShowCommandHelp(context, cmdName)\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc logrusToStderr() bool {\n\tl, ok := logrus.StandardLogger().Out.(*os.File)\n\treturn ok && l.Fd() == os.Stderr.Fd()\n}\n\n// fatal prints the error's details if it is a libcontainer specific error type\n// then exits the program with an exit status of 1.\nfunc fatal(err error) {\n\tfatalWithCode(err, 1)\n}\n\nfunc fatalWithCode(err error, ret int) {\n\t// Make sure the error is written to the logger.\n\tlogrus.Error(err)\n\tif !logrusToStderr() {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t}\n\n\tos.Exit(ret)\n}\n\n// setupSpec performs initial setup based on the cli.Context for the container\nfunc setupSpec(context *cli.Context) (*specs.Spec, error) {\n\tbundle := context.String(\"bundle\")\n\tif bundle != \"\" {\n\t\tif err := os.Chdir(bundle); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tspec, err := loadSpec(specConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn spec, nil\n}\n\nfunc revisePidFile(context *cli.Context) error {\n\tpidFile := context.String(\"pid-file\")\n\tif pidFile == \"\" {\n\t\treturn nil\n\t}\n\n\t// convert pid-file to an absolute path so we can write to the right\n\t// file after chdir to bundle\n\tpidFile, err := filepath.Abs(pidFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn context.Set(\"pid-file\", pidFile)\n}\n\n// reviseRootDir ensures that the --root option argument,\n// if specified, is converted to an absolute and cleaned path,\n// and that this path is sane.\nfunc reviseRootDir(context *cli.Context) error {\n\tif !context.IsSet(\"root\") {\n\t\treturn nil\n\t}\n\troot, err := filepath.Abs(context.GlobalString(\"root\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif root == \"/\" {\n\t\t// This can happen if --root argument is\n\t\t//  - \"\" (i.e. empty);\n\t\t//  - \".\" (and the CWD is /);\n\t\t//  - \"../../..\" (enough to get to /);\n\t\t//  - \"/\" (the actual /).\n\t\treturn errors.New(\"Option --root argument should not be set to /\")\n\t}\n\n\treturn context.GlobalSet(\"root\", root)\n}\n\n// parseBoolOrAuto returns (nil, nil) if s is empty or \"auto\"\nfunc parseBoolOrAuto(s string) (*bool, error) {\n\tif s == \"\" || strings.ToLower(s) == \"auto\" {\n\t\treturn nil, nil\n\t}\n\tb, err := strconv.ParseBool(s)\n\treturn &b, err\n}\n"
        },
        {
          "name": "utils_linux.go",
          "type": "blob",
          "size": 11.4736328125,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\n\t\"github.com/coreos/go-systemd/v22/activation\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\tselinux \"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/urfave/cli\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/specconv\"\n\t\"github.com/opencontainers/runc/libcontainer/system/kernelversion\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\nvar errEmptyID = errors.New(\"container id cannot be empty\")\n\n// getContainer returns the specified container instance by loading it from\n// a state directory (root).\nfunc getContainer(context *cli.Context) (*libcontainer.Container, error) {\n\tid := context.Args().First()\n\tif id == \"\" {\n\t\treturn nil, errEmptyID\n\t}\n\troot := context.GlobalString(\"root\")\n\treturn libcontainer.Load(root, id)\n}\n\nfunc getDefaultImagePath() string {\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn filepath.Join(cwd, \"checkpoint\")\n}\n\n// newProcess returns a new libcontainer Process with the arguments from the\n// spec and stdio from the current process.\nfunc newProcess(p specs.Process) (*libcontainer.Process, error) {\n\tlp := &libcontainer.Process{\n\t\tArgs: p.Args,\n\t\tEnv:  p.Env,\n\t\t// TODO: fix libcontainer's API to better support uid/gid in a typesafe way.\n\t\tUser:            fmt.Sprintf(\"%d:%d\", p.User.UID, p.User.GID),\n\t\tCwd:             p.Cwd,\n\t\tLabel:           p.SelinuxLabel,\n\t\tNoNewPrivileges: &p.NoNewPrivileges,\n\t\tAppArmorProfile: p.ApparmorProfile,\n\t\tScheduler:       p.Scheduler,\n\t\tIOPriority:      p.IOPriority,\n\t}\n\n\tif p.ConsoleSize != nil {\n\t\tlp.ConsoleWidth = uint16(p.ConsoleSize.Width)\n\t\tlp.ConsoleHeight = uint16(p.ConsoleSize.Height)\n\t}\n\n\tif p.Capabilities != nil {\n\t\tlp.Capabilities = &configs.Capabilities{}\n\t\tlp.Capabilities.Bounding = p.Capabilities.Bounding\n\t\tlp.Capabilities.Effective = p.Capabilities.Effective\n\t\tlp.Capabilities.Inheritable = p.Capabilities.Inheritable\n\t\tlp.Capabilities.Permitted = p.Capabilities.Permitted\n\t\tlp.Capabilities.Ambient = p.Capabilities.Ambient\n\t}\n\tfor _, gid := range p.User.AdditionalGids {\n\t\tlp.AdditionalGroups = append(lp.AdditionalGroups, strconv.FormatUint(uint64(gid), 10))\n\t}\n\tfor _, rlimit := range p.Rlimits {\n\t\trl, err := createLibContainerRlimit(rlimit)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlp.Rlimits = append(lp.Rlimits, rl)\n\t}\n\treturn lp, nil\n}\n\n// setupIO modifies the given process config according to the options.\nfunc setupIO(process *libcontainer.Process, rootuid, rootgid int, createTTY, detach bool, sockpath string) (*tty, error) {\n\tif createTTY {\n\t\tprocess.Stdin = nil\n\t\tprocess.Stdout = nil\n\t\tprocess.Stderr = nil\n\t\tt := &tty{}\n\t\tif !detach {\n\t\t\tif err := t.initHostConsole(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tparent, child, err := utils.NewSockPair(\"console\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tprocess.ConsoleSocket = child\n\t\t\tt.postStart = append(t.postStart, parent, child)\n\t\t\tt.consoleC = make(chan error, 1)\n\t\t\tgo func() {\n\t\t\t\tt.consoleC <- t.recvtty(parent)\n\t\t\t}()\n\t\t} else {\n\t\t\t// the caller of runc will handle receiving the console master\n\t\t\tconn, err := net.Dial(\"unix\", sockpath)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tuc, ok := conn.(*net.UnixConn)\n\t\t\tif !ok {\n\t\t\t\treturn nil, errors.New(\"casting to UnixConn failed\")\n\t\t\t}\n\t\t\tt.postStart = append(t.postStart, uc)\n\t\t\tsocket, err := uc.File()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tt.postStart = append(t.postStart, socket)\n\t\t\tprocess.ConsoleSocket = socket\n\t\t}\n\t\treturn t, nil\n\t}\n\t// when runc will detach the caller provides the stdio to runc via runc's 0,1,2\n\t// and the container's process inherits runc's stdio.\n\tif detach {\n\t\tinheritStdio(process)\n\t\treturn &tty{}, nil\n\t}\n\treturn setupProcessPipes(process, rootuid, rootgid)\n}\n\n// createPidFile creates a file containing the PID,\n// doing so atomically (via create and rename).\nfunc createPidFile(path string, process *libcontainer.Process) error {\n\tpid, err := process.Pid()\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar (\n\t\ttmpDir  = filepath.Dir(path)\n\t\ttmpName = filepath.Join(tmpDir, \".\"+filepath.Base(path))\n\t)\n\tf, err := os.OpenFile(tmpName, os.O_RDWR|os.O_CREATE|os.O_EXCL|os.O_SYNC, 0o666)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = f.WriteString(strconv.Itoa(pid))\n\tf.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn os.Rename(tmpName, path)\n}\n\nfunc createContainer(context *cli.Context, id string, spec *specs.Spec) (*libcontainer.Container, error) {\n\trootlessCg, err := shouldUseRootlessCgroupManager(context)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig, err := specconv.CreateLibcontainerConfig(&specconv.CreateOpts{\n\t\tCgroupName:       id,\n\t\tUseSystemdCgroup: context.GlobalBool(\"systemd-cgroup\"),\n\t\tNoPivotRoot:      context.Bool(\"no-pivot\"),\n\t\tNoNewKeyring:     context.Bool(\"no-new-keyring\"),\n\t\tSpec:             spec,\n\t\tRootlessEUID:     os.Geteuid() != 0,\n\t\tRootlessCgroups:  rootlessCg,\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\troot := context.GlobalString(\"root\")\n\treturn libcontainer.Create(root, id, config)\n}\n\ntype runner struct {\n\tinit            bool\n\tenableSubreaper bool\n\tshouldDestroy   bool\n\tdetach          bool\n\tlistenFDs       []*os.File\n\tpreserveFDs     int\n\tpidFile         string\n\tconsoleSocket   string\n\tpidfdSocket     string\n\tcontainer       *libcontainer.Container\n\taction          CtAct\n\tnotifySocket    *notifySocket\n\tcriuOpts        *libcontainer.CriuOpts\n\tsubCgroupPaths  map[string]string\n}\n\nfunc (r *runner) run(config *specs.Process) (int, error) {\n\tvar err error\n\tdefer func() {\n\t\tif err != nil {\n\t\t\tr.destroy()\n\t\t}\n\t}()\n\tif err = r.checkTerminal(config); err != nil {\n\t\treturn -1, err\n\t}\n\tprocess, err := newProcess(*config)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tprocess.LogLevel = strconv.Itoa(int(logrus.GetLevel()))\n\t// Populate the fields that come from runner.\n\tprocess.Init = r.init\n\tprocess.SubCgroupPaths = r.subCgroupPaths\n\tif len(r.listenFDs) > 0 {\n\t\tprocess.Env = append(process.Env, \"LISTEN_FDS=\"+strconv.Itoa(len(r.listenFDs)), \"LISTEN_PID=1\")\n\t\tprocess.ExtraFiles = append(process.ExtraFiles, r.listenFDs...)\n\t}\n\tbaseFd := 3 + len(process.ExtraFiles)\n\tprocSelfFd, closer := utils.ProcThreadSelf(\"fd/\")\n\tdefer closer()\n\tfor i := baseFd; i < baseFd+r.preserveFDs; i++ {\n\t\t_, err = os.Stat(filepath.Join(procSelfFd, strconv.Itoa(i)))\n\t\tif err != nil {\n\t\t\treturn -1, fmt.Errorf(\"unable to stat preserved-fd %d (of %d): %w\", i-baseFd, r.preserveFDs, err)\n\t\t}\n\t\tprocess.ExtraFiles = append(process.ExtraFiles, os.NewFile(uintptr(i), \"PreserveFD:\"+strconv.Itoa(i)))\n\t}\n\trootuid, err := r.container.Config().HostRootUID()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\trootgid, err := r.container.Config().HostRootGID()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tdetach := r.detach || (r.action == CT_ACT_CREATE)\n\t// Setting up IO is a two stage process. We need to modify process to deal\n\t// with detaching containers, and then we get a tty after the container has\n\t// started.\n\thandler := newSignalHandler(r.enableSubreaper, r.notifySocket)\n\ttty, err := setupIO(process, rootuid, rootgid, config.Terminal, detach, r.consoleSocket)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tdefer tty.Close()\n\n\tif r.pidfdSocket != \"\" {\n\t\tconnClose, err := setupPidfdSocket(process, r.pidfdSocket)\n\t\tif err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\tdefer connClose()\n\t}\n\n\tswitch r.action {\n\tcase CT_ACT_CREATE:\n\t\terr = r.container.Start(process)\n\tcase CT_ACT_RESTORE:\n\t\terr = r.container.Restore(process, r.criuOpts)\n\tcase CT_ACT_RUN:\n\t\terr = r.container.Run(process)\n\tdefault:\n\t\tpanic(\"Unknown action\")\n\t}\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tif err = tty.waitConsole(); err != nil {\n\t\tr.terminate(process)\n\t\treturn -1, err\n\t}\n\ttty.ClosePostStart()\n\tif r.pidFile != \"\" {\n\t\tif err = createPidFile(r.pidFile, process); err != nil {\n\t\t\tr.terminate(process)\n\t\t\treturn -1, err\n\t\t}\n\t}\n\tstatus, err := handler.forward(process, tty, detach)\n\tif err != nil {\n\t\tr.terminate(process)\n\t}\n\tif detach {\n\t\treturn 0, nil\n\t}\n\tif err == nil {\n\t\tr.destroy()\n\t}\n\treturn status, err\n}\n\nfunc (r *runner) destroy() {\n\tif r.shouldDestroy {\n\t\tif err := r.container.Destroy(); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n}\n\nfunc (r *runner) terminate(p *libcontainer.Process) {\n\t_ = p.Signal(unix.SIGKILL)\n\t_, _ = p.Wait()\n}\n\nfunc (r *runner) checkTerminal(config *specs.Process) error {\n\tdetach := r.detach || (r.action == CT_ACT_CREATE)\n\t// Check command-line for sanity.\n\tif detach && config.Terminal && r.consoleSocket == \"\" {\n\t\treturn errors.New(\"cannot allocate tty if runc will detach without setting console socket\")\n\t}\n\tif (!detach || !config.Terminal) && r.consoleSocket != \"\" {\n\t\treturn errors.New(\"cannot use console socket if runc will not detach or allocate tty\")\n\t}\n\treturn nil\n}\n\nfunc validateProcessSpec(spec *specs.Process) error {\n\tif spec == nil {\n\t\treturn errors.New(\"process property must not be empty\")\n\t}\n\tif spec.Cwd == \"\" {\n\t\treturn errors.New(\"Cwd property must not be empty\")\n\t}\n\tif !filepath.IsAbs(spec.Cwd) {\n\t\treturn errors.New(\"Cwd must be an absolute path\")\n\t}\n\tif len(spec.Args) == 0 {\n\t\treturn errors.New(\"args must not be empty\")\n\t}\n\tif spec.SelinuxLabel != \"\" && !selinux.GetEnabled() {\n\t\treturn errors.New(\"selinux label is specified in config, but selinux is disabled or not supported\")\n\t}\n\treturn nil\n}\n\ntype CtAct uint8\n\nconst (\n\tCT_ACT_CREATE CtAct = iota + 1\n\tCT_ACT_RUN\n\tCT_ACT_RESTORE\n)\n\nfunc startContainer(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) {\n\tif err := revisePidFile(context); err != nil {\n\t\treturn -1, err\n\t}\n\tspec, err := setupSpec(context)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tid := context.Args().First()\n\tif id == \"\" {\n\t\treturn -1, errEmptyID\n\t}\n\n\tnotifySocket := newNotifySocket(context, os.Getenv(\"NOTIFY_SOCKET\"), id)\n\tif notifySocket != nil {\n\t\tnotifySocket.setupSpec(spec)\n\t}\n\n\tcontainer, err := createContainer(context, id, spec)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tif notifySocket != nil {\n\t\tif err := notifySocket.setupSocketDirectory(); err != nil {\n\t\t\treturn -1, err\n\t\t}\n\t\tif action == CT_ACT_RUN {\n\t\t\tif err := notifySocket.bindSocket(); err != nil {\n\t\t\t\treturn -1, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Support on-demand socket activation by passing file descriptors into the container init process.\n\tlistenFDs := []*os.File{}\n\tif os.Getenv(\"LISTEN_FDS\") != \"\" {\n\t\tlistenFDs = activation.Files(false)\n\t}\n\n\tr := &runner{\n\t\tenableSubreaper: !context.Bool(\"no-subreaper\"),\n\t\tshouldDestroy:   !context.Bool(\"keep\"),\n\t\tcontainer:       container,\n\t\tlistenFDs:       listenFDs,\n\t\tnotifySocket:    notifySocket,\n\t\tconsoleSocket:   context.String(\"console-socket\"),\n\t\tpidfdSocket:     context.String(\"pidfd-socket\"),\n\t\tdetach:          context.Bool(\"detach\"),\n\t\tpidFile:         context.String(\"pid-file\"),\n\t\tpreserveFDs:     context.Int(\"preserve-fds\"),\n\t\taction:          action,\n\t\tcriuOpts:        criuOpts,\n\t\tinit:            true,\n\t}\n\treturn r.run(spec.Process)\n}\n\nfunc setupPidfdSocket(process *libcontainer.Process, sockpath string) (_clean func(), _ error) {\n\tlinux530 := kernelversion.KernelVersion{Kernel: 5, Major: 3}\n\tok, err := kernelversion.GreaterEqualThan(linux530)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"--pidfd-socket requires >= v5.3 kernel\")\n\t}\n\n\tconn, err := net.Dial(\"unix\", sockpath)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to dail %s: %w\", sockpath, err)\n\t}\n\n\tuc, ok := conn.(*net.UnixConn)\n\tif !ok {\n\t\tconn.Close()\n\t\treturn nil, errors.New(\"failed to cast to UnixConn\")\n\t}\n\n\tsocket, err := uc.File()\n\tif err != nil {\n\t\tconn.Close()\n\t\treturn nil, fmt.Errorf(\"failed to dup socket: %w\", err)\n\t}\n\n\tprocess.PidfdSocket = socket\n\treturn func() {\n\t\tconn.Close()\n\t}, nil\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}